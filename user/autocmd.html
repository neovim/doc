<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Vim documentation: autocmd</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <div class="site-nav">
          <ul>
            <li><a href="/">Neovim Home</a></li>
          </ul>
        </div>
        <a href="/"><img class="logo" alt="Vim documentation: autocmd" src="/images/logo@2x.png" /></a>
      </div>
    </header>

    <div class="container">
      <h1>Vim documentation: autocmd</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="autocmd.txt"></A><B>autocmd.txt</B>*   For Vim version 7.4.  Last change: 2014 Aug 22


		  VIM REFERENCE MANUAL    by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>



Automatic commands					*<A NAME="autocommand"></A><B>autocommand</B>*

For a basic explanation, see section |<A HREF="usr_40.html#40.3">40.3</A>| in the user manual.

1.  Introduction		|<A HREF="#autocmd-intro">autocmd-intro</A>|
2.  Defining autocommands	|<A HREF="#autocmd-define">autocmd-define</A>|
3.  Removing autocommands	|<A HREF="#autocmd-remove">autocmd-remove</A>|
4.  Listing autocommands	|<A HREF="#autocmd-list">autocmd-list</A>|
5.  Events			|<A HREF="#autocmd-events">autocmd-events</A>|
6.  Patterns			|<A HREF="#autocmd-patterns">autocmd-patterns</A>|
7.  Buffer-local autocommands	|<A HREF="#autocmd-buflocal">autocmd-buflocal</A>|
8.  Groups			|<A HREF="#autocmd-groups">autocmd-groups</A>|
9.  Executing autocommands	|<A HREF="#autocmd-execute">autocmd-execute</A>|
10. Using autocommands		|<A HREF="#autocmd-use">autocmd-use</A>|
11. Disabling autocommands	|<A HREF="#autocmd-disable">autocmd-disable</A>|

{Vi does not have any of these commands}
{only when the |<A HREF="various.html#+autocmd">+autocmd</A>| feature has not been disabled at compile time}

==============================================================================

1. Introduction						*<A NAME="autocmd-intro"></A><B>autocmd-intro</B>*

You can specify commands to be executed automatically when reading or <A HREF="editing.html#writing">writing</A>
a file, when entering or leaving a buffer or <A HREF="windows.html#window">window</A>, and when exiting Vim.
For example, you can create an <A HREF="#autocommand">autocommand</A> to set the <A HREF="options.html#'cindent'">'cindent'</A> option for
files matching *.c.  You can also use autocommands to implement advanced
features, such <A HREF="motion.html#as">as</A> editing compressed files (see |<A HREF="#gzip-example">gzip-example</A>|).  The usual
place to put autocommands is in your <A HREF="starting.html#.vimrc">.vimrc</A> or <A HREF="starting.html#.exrc">.exrc</A> file.


						*<A NAME="E203"></A><B>E203</B>* *<A NAME="E204"></A><B>E204</B>* *<A NAME="E143"></A><B>E143</B>* *<A NAME="E855"></A><B>E855</B>*
WARNING: Using autocommands is very powerful, and may lead to unexpected side
effects.  Be careful not to destroy your text.
- It's a good idea to <A HREF="diff.html#do">do</A> some testing on an expendable copy of a file first.
  For example: If you use autocommands to decompress a file when starting to
  edit <A HREF="motion.html#it">it</A>, make sure that the autocommands for compressing when <A HREF="editing.html#writing">writing</A> work
  correctly.
- Be prepared for an error halfway through (e.g., disk full).  Vim will mostly
  be able to <A HREF="undo.html#undo">undo</A> the changes to the buffer, but you may have to clean up the
  changes to other files by hand (e.g., <A HREF="pi_gzip.html#compress">compress</A> a file that has been
  decompressed).
- If the BufRead* events allow you to edit a compressed file, the FileRead*
  events should <A HREF="diff.html#do">do</A> the same (this makes <A HREF="recover.html#recovery">recovery</A> possible in some rare cases).
  It's a good idea to use the same autocommands for the File* and Buf* events
  when possible.

==============================================================================

2. Defining autocommands				*<A NAME="autocmd-define"></A><B>autocmd-define</B>*

Note: The &quot;<A HREF="#:autocmd">:autocmd</A>&quot; command cannot be followed by another command, since any
'&#124;' is considered part of the command.


							*<A NAME=":au"></A><B>:au</B>* *<A NAME=":autocmd"></A><B>:autocmd</B>*
:au[tocmd] [group] <A HREF="#{event}">{event}</A> <A HREF="#{pat}">{pat}</A> [nested] {cmd}
			Add {cmd} to the <A HREF="eval.html#list">list</A> of commands that Vim will
			execute automatically on <A HREF="#{event}">{event}</A> for a file matching
			<A HREF="#{pat}">{pat}</A> |<A HREF="#autocmd-patterns">autocmd-patterns</A>|.
			Vim always adds the {cmd} after existing autocommands,
			so that the autocommands execute in the order in which
			they were given.  See |<A HREF="#autocmd-nested">autocmd-nested</A>| for [nested].

The special <A HREF="pattern.html#pattern">pattern</A> &lt;buffer&gt; or <A HREF="#&lt;buffer=N&gt;">&lt;buffer=N&gt;</A> defines a buffer-local <A HREF="#autocommand">autocommand</A>.
See |<A HREF="#autocmd-buflocal">autocmd-buflocal</A>|.

Note that special characters (e.g., &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot;, &quot;&lt;cword&gt;&quot;) in the &quot;<A HREF="#:autocmd">:autocmd</A>&quot;
arguments are not expanded when the <A HREF="#autocommand">autocommand</A> is defined.  These will be
expanded when the Event is recognized, and the {cmd} is executed.  The only
exception is that &quot;<A HREF="cmdline.html#&lt;sfile&gt;">&lt;sfile&gt;</A>&quot; is expanded when the autocmd is defined.  Example:

<B>	:au BufNewFile,BufRead *.html so &lt;sfile&gt;:h/html.vim</B>

Here Vim expands <A HREF="cmdline.html#&lt;sfile&gt;">&lt;sfile&gt;</A> to the name of the file containing this line.

When your <A HREF="starting.html#.vimrc">.vimrc</A> file is sourced <A HREF="if_cscop.html#twice">twice</A>, the autocommands will appear <A HREF="if_cscop.html#twice">twice</A>.
To avoid this, put this command in your <A HREF="starting.html#.vimrc">.vimrc</A> file, before defining
autocommands:

<B>	:autocmd!	" Remove ALL autocommands for the current group.</B>

If you don't want to remove all autocommands, you can instead use a variable
to ensure that Vim includes the autocommands only once:

<B>	:if !exists("autocommands_loaded")</B>
<B>	:  let autocommands_loaded = 1</B>
<B>	:  au ...</B>
<B>	:endif</B>

When the [group] argument is not given, Vim uses the current group (as defined
with &quot;:augroup&quot;); otherwise, Vim uses the group defined with [group].  Note
that [group] must have been defined before.  You cannot define a new group
with &quot;<A HREF="#:au">:au</A> group ...&quot;; use &quot;<A HREF="#:augroup">:augroup</A>&quot; for that.

While testing autocommands, you might find the <A HREF="options.html#'verbose'">'verbose'</A> option to be useful:
<B>	:set verbose=9</B>
This setting makes Vim echo the autocommands <A HREF="motion.html#as">as</A> <A HREF="motion.html#it">it</A> executes them.

When defining an <A HREF="#autocommand">autocommand</A> in a <A HREF="usr_41.html#script">script</A>, <A HREF="motion.html#it">it</A> will be able to call <A HREF="eval.html#functions">functions</A>
local to the <A HREF="usr_41.html#script">script</A> and use mappings local to the <A HREF="usr_41.html#script">script</A>.  When the event is
triggered and the command executed, <A HREF="motion.html#it">it</A> will run in the context of the <A HREF="usr_41.html#script">script</A>
<A HREF="motion.html#it">it</A> was defined in.  This matters if |<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>| is used in a command.

When executing the commands, the message from one command overwrites a
previous message.  This is different from when executing the commands
manually.  Mostly the screen will not scroll up, thus there is no <A HREF="message.html#hit-enter">hit-enter</A>
prompt.  When one command outputs two <A HREF="message.html#messages">messages</A> this can happen anyway.

==============================================================================

3. Removing autocommands				*<A NAME="autocmd-remove"></A><B>autocmd-remove</B>*

:au[tocmd]! [group] <A HREF="#{event}">{event}</A> <A HREF="#{pat}">{pat}</A> [nested] {cmd}
			Remove all autocommands associated with <A HREF="#{event}">{event}</A> and
			<A HREF="#{pat}">{pat}</A>, and add the command {cmd}.  See
			|<A HREF="#autocmd-nested">autocmd-nested</A>| for [nested].

:au[tocmd]! [group] <A HREF="#{event}">{event}</A> <A HREF="#{pat}">{pat}</A>
			Remove all autocommands associated with <A HREF="#{event}">{event}</A> and
			<A HREF="#{pat}">{pat}</A>.

:au[tocmd]! [group] &#42; <A HREF="#{pat}">{pat}</A>
			Remove all autocommands associated with <A HREF="#{pat}">{pat}</A> for all
			events.

:au[tocmd]! [group] <A HREF="#{event}">{event}</A>
			Remove ALL autocommands for <A HREF="#{event}">{event}</A>.

:au[tocmd]! [group]	Remove ALL autocommands.

When the [group] argument is not given, Vim uses the current group (as defined
with &quot;:augroup&quot;); otherwise, Vim uses the group defined with [group].

==============================================================================

4. Listing autocommands					*<A NAME="autocmd-list"></A><B>autocmd-list</B>*

:au[tocmd] [group] <A HREF="#{event}">{event}</A> <A HREF="#{pat}">{pat}</A>
			Show the autocommands associated with <A HREF="#{event}">{event}</A> and
			<A HREF="#{pat}">{pat}</A>.

:au[tocmd] [group] &#42; <A HREF="#{pat}">{pat}</A>
			Show the autocommands associated with <A HREF="#{pat}">{pat}</A> for all
			events.

:au[tocmd] [group] <A HREF="#{event}">{event}</A>
			Show all autocommands for <A HREF="#{event}">{event}</A>.

:au[tocmd] [group]	Show all autocommands.

If you provide the [group] argument, Vim lists only the autocommands for
[group]; otherwise, Vim lists the autocommands for ALL groups.  Note that this
argument behavior differs from that for defining and removing autocommands.

In order to <A HREF="eval.html#list">list</A> buffer-local autocommands, use a <A HREF="pattern.html#pattern">pattern</A> in the form &lt;buffer&gt;
or <A HREF="#&lt;buffer=N&gt;">&lt;buffer=N&gt;</A>.  See |<A HREF="#autocmd-buflocal">autocmd-buflocal</A>|.


							*<A NAME=":autocmd-verbose"></A><B>:autocmd-verbose</B>*
When <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, listing an <A HREF="#autocommand">autocommand</A> will also display where <A HREF="motion.html#it">it</A>
was last defined. Example:

<B>    :verbose autocmd BufEnter</B>
<B>    FileExplorer  BufEnter</B>
<B>	*	  call s:LocalBrowse(expand("&lt;amatch&gt;"))</B>
<B>	    Last set from /usr/share/vim/vim-7.0/plugin/NetrwPlugin.vim</B>
 
See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.

==============================================================================

5. Events					*<A NAME="autocmd-events"></A><B>autocmd-events</B>* *<A NAME="E215"></A><B>E215</B>* *<A NAME="E216"></A><B>E216</B>*

You can specify a comma-separated <A HREF="eval.html#list">list</A> of event names.  No white space can be
used in this <A HREF="eval.html#list">list</A>.  The command applies to all the events in the <A HREF="eval.html#list">list</A>.

For READING FILES there are four kinds of events possible:
	<A HREF="#BufNewFile">BufNewFile</A>			starting to edit a non-existent file
	<A HREF="#BufReadPre">BufReadPre</A>	<A HREF="#BufReadPost">BufReadPost</A>	starting to edit an existing file
	<A HREF="#FilterReadPre">FilterReadPre</A>	<A HREF="#FilterReadPost">FilterReadPost</A>	read the temp file with <A HREF="change.html#filter">filter</A> output
	<A HREF="#FileReadPre">FileReadPre</A>	<A HREF="#FileReadPost">FileReadPost</A>	any other file read
Vim uses only one of these four kinds when reading a file.  The &quot;Pre&quot; and
&quot;Post&quot; events are both triggered, before and after reading the file.

Note that the autocommands for the *ReadPre events and all the Filter events
are not allowed to change the current buffer (you will get an error message if
this happens).  This is to prevent the file to be read into the wrong buffer.

Note that the <A HREF="options.html#'modified'">'modified'</A> flag is reset AFTER executing the <A HREF="#BufReadPost">BufReadPost</A>
and <A HREF="#BufNewFile">BufNewFile</A> autocommands.  But when the <A HREF="options.html#'modified'">'modified'</A> option was set by the
autocommands, this doesn't happen.

You can use the <A HREF="options.html#'eventignore'">'eventignore'</A> option to ignore a number of events or all
events.

					*<A NAME="autocommand-events"></A><B>autocommand-events</B>* *<A NAME="{event}"></A><B>{event}</B>*
Vim recognizes the following events.  Vim ignores the <A HREF="change.html#case">case</A> of event names
(e.g., you can use &quot;BUFread&quot; or &quot;bufread&quot; instead of &quot;BufRead&quot;).

First an overview by function with a short explanation.  Then the <A HREF="eval.html#list">list</A>
alphabetically with full explanations |<A HREF="#autocmd-events-abc">autocmd-events-abc</A>|.

<B><FONT color="#54A23D">Name			triggered by </FONT></B>

	Reading
|<A HREF="#BufNewFile">BufNewFile</A>|		starting to edit a file that doesn't exist
|<A HREF="#BufReadPre">BufReadPre</A>|		starting to edit a new buffer, before reading the file
|<A HREF="#BufRead">BufRead</A>|		starting to edit a new buffer, after reading the file
|<A HREF="#BufReadPost">BufReadPost</A>|		starting to edit a new buffer, after reading the file
|<A HREF="#BufReadCmd">BufReadCmd</A>|		before starting to edit a new buffer |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#FileReadPre">FileReadPre</A>|		before reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command
|<A HREF="#FileReadPost">FileReadPost</A>|		after reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command
|<A HREF="#FileReadCmd">FileReadCmd</A>|		before reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#FilterReadPre">FilterReadPre</A>|		before reading a file from a <A HREF="change.html#filter">filter</A> command
|<A HREF="#FilterReadPost">FilterReadPost</A>|	after reading a file from a <A HREF="change.html#filter">filter</A> command

|<A HREF="#StdinReadPre">StdinReadPre</A>|		before reading from stdin into the buffer
|<A HREF="#StdinReadPost">StdinReadPost</A>|		After reading from the stdin into the buffer

	Writing
|<A HREF="#BufWrite">BufWrite</A>|		starting to write the whole buffer to a file
|<A HREF="#BufWritePre">BufWritePre</A>|		starting to write the whole buffer to a file
|<A HREF="#BufWritePost">BufWritePost</A>|		after <A HREF="editing.html#writing">writing</A> the whole buffer to a file
|<A HREF="#BufWriteCmd">BufWriteCmd</A>|		before <A HREF="editing.html#writing">writing</A> the whole buffer to a file |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#FileWritePre">FileWritePre</A>|		starting to write part of a buffer to a file
|<A HREF="#FileWritePost">FileWritePost</A>|		after <A HREF="editing.html#writing">writing</A> part of a buffer to a file
|<A HREF="#FileWriteCmd">FileWriteCmd</A>|		before <A HREF="editing.html#writing">writing</A> part of a buffer to a file |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#FileAppendPre">FileAppendPre</A>|		starting to append to a file
|<A HREF="#FileAppendPost">FileAppendPost</A>|	after appending to a file
|<A HREF="#FileAppendCmd">FileAppendCmd</A>|		before appending to a file |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#FilterWritePre">FilterWritePre</A>|	starting to write a file for a <A HREF="change.html#filter">filter</A> command or <A HREF="diff.html#diff">diff</A>
|<A HREF="#FilterWritePost">FilterWritePost</A>|	after <A HREF="editing.html#writing">writing</A> a file for a <A HREF="change.html#filter">filter</A> command or <A HREF="diff.html#diff">diff</A>

	Buffers
|<A HREF="#BufAdd">BufAdd</A>|		just after adding a buffer to the buffer <A HREF="eval.html#list">list</A>
|<A HREF="#BufCreate">BufCreate</A>|		just after adding a buffer to the buffer <A HREF="eval.html#list">list</A>
|<A HREF="#BufDelete">BufDelete</A>|		before <A HREF="change.html#deleting">deleting</A> a buffer from the buffer <A HREF="eval.html#list">list</A>
|<A HREF="#BufWipeout">BufWipeout</A>|		before completely <A HREF="change.html#deleting">deleting</A> a buffer

|<A HREF="#BufFilePre">BufFilePre</A>|		before <A HREF="change.html#changing">changing</A> the name of the current buffer
|<A HREF="#BufFilePost">BufFilePost</A>|		after <A HREF="change.html#changing">changing</A> the name of the current buffer

|<A HREF="#BufEnter">BufEnter</A>|		after entering a buffer
|<A HREF="#BufLeave">BufLeave</A>|		before leaving to another buffer
|<A HREF="#BufWinEnter">BufWinEnter</A>|		after a buffer is displayed in a <A HREF="windows.html#window">window</A>
|<A HREF="#BufWinLeave">BufWinLeave</A>|		before a buffer is removed from a <A HREF="windows.html#window">window</A>

|<A HREF="#BufUnload">BufUnload</A>|		before unloading a buffer
|<A HREF="#BufHidden">BufHidden</A>|		just after a buffer has become hidden
|<A HREF="#BufNew">BufNew</A>|		just after creating a new buffer

|<A HREF="#SwapExists">SwapExists</A>|		detected an existing swap file

	Options
|<A HREF="#FileType">FileType</A>|		when the <A HREF="options.html#'filetype'">'filetype'</A> option has been set
|<A HREF="#Syntax">Syntax</A>|		when the <A HREF="options.html#'syntax'">'syntax'</A> option has been set
|<A HREF="#EncodingChanged">EncodingChanged</A>|	after the <A HREF="options.html#'encoding'">'encoding'</A> option has been changed
|<A HREF="#TermChanged">TermChanged</A>|		after the value of <A HREF="options.html#'term'">'term'</A> has changed

	Startup and exit
|<A HREF="#VimEnter">VimEnter</A>|		after doing all the <A HREF="starting.html#startup">startup</A> stuff
|<A HREF="#GUIEnter">GUIEnter</A>|		after starting the GUI successfully
|<A HREF="#GUIFailed">GUIFailed</A>|		after starting the GUI failed
|<A HREF="#TermResponse">TermResponse</A>|		after the terminal response to |<A HREF="term.html#t_RV">t_RV</A>| is received

|<A HREF="#QuitPre">QuitPre</A>|		when using `:quit`, before deciding whether to quit
|<A HREF="#VimLeavePre">VimLeavePre</A>|		before exiting Vim, before <A HREF="editing.html#writing">writing</A> the <A HREF="starting.html#viminfo">viminfo</A> file
|<A HREF="#VimLeave">VimLeave</A>|		before exiting Vim, after <A HREF="editing.html#writing">writing</A> the <A HREF="starting.html#viminfo">viminfo</A> file

	Various
|<A HREF="#FileChangedShell">FileChangedShell</A>|	Vim notices that a file changed since editing started
|<A HREF="#FileChangedShellPost">FileChangedShellPost</A>|	After handling a file changed since editing started
|<A HREF="#FileChangedRO">FileChangedRO</A>|		before making the first change to a read-only file

|<A HREF="#ShellCmdPost">ShellCmdPost</A>|		after executing a shell command
|<A HREF="#ShellFilterPost">ShellFilterPost</A>|	after filtering with a shell command

|<A HREF="#CmdUndefined">CmdUndefined</A>|		a user command is used but <A HREF="motion.html#it">it</A> isn't defined
|<A HREF="#FuncUndefined">FuncUndefined</A>|		a user function is used but <A HREF="motion.html#it">it</A> isn't defined
|<A HREF="#SpellFileMissing">SpellFileMissing</A>|	a <A HREF="spell.html#spell">spell</A> file is used but <A HREF="motion.html#it">it</A> can't be found
|<A HREF="#SourcePre">SourcePre</A>|		before sourcing a Vim <A HREF="usr_41.html#script">script</A>
|<A HREF="#SourceCmd">SourceCmd</A>|		before sourcing a Vim <A HREF="usr_41.html#script">script</A> |<A HREF="#Cmd-event">Cmd-event</A>|

|<A HREF="#VimResized">VimResized</A>|		after the Vim <A HREF="windows.html#window">window</A> size changed
|<A HREF="#FocusGained">FocusGained</A>|		Vim got input focus
|<A HREF="#FocusLost">FocusLost</A>|		Vim lost input focus
|<A HREF="#CursorHold">CursorHold</A>|		the user doesn't press a key for a while
|<A HREF="#CursorHoldI">CursorHoldI</A>|		the user doesn't press a key for a while in <A HREF="insert.html#Insert">Insert</A> mode
|<A HREF="#CursorMoved">CursorMoved</A>|		the cursor was moved in <A HREF="intro.html#Normal">Normal</A> mode
|<A HREF="#CursorMovedI">CursorMovedI</A>|		the cursor was moved in <A HREF="insert.html#Insert">Insert</A> mode

|<A HREF="#WinEnter">WinEnter</A>|		after entering another <A HREF="windows.html#window">window</A>
|<A HREF="#WinLeave">WinLeave</A>|		before leaving a <A HREF="windows.html#window">window</A>
|<A HREF="#TabEnter">TabEnter</A>|		after entering another <A HREF="intro.html#tab">tab</A> page
|<A HREF="#TabLeave">TabLeave</A>|		before leaving a <A HREF="intro.html#tab">tab</A> page
|<A HREF="#CmdwinEnter">CmdwinEnter</A>|		after entering the command-line <A HREF="windows.html#window">window</A>
|<A HREF="#CmdwinLeave">CmdwinLeave</A>|		before leaving the command-line <A HREF="windows.html#window">window</A>

|<A HREF="#InsertEnter">InsertEnter</A>|		starting Insert mode
|<A HREF="#InsertChange">InsertChange</A>|		when typing <A HREF="insert.html#&lt;Insert&gt;">&lt;Insert&gt;</A> while in Insert or <A HREF="insert.html#Replace">Replace</A> mode
|<A HREF="#InsertLeave">InsertLeave</A>|		when leaving Insert mode
|<A HREF="#InsertCharPre">InsertCharPre</A>|		when a character was typed in Insert mode, before
			<A HREF="insert.html#inserting">inserting</A> <A HREF="motion.html#it">it</A>
|<A HREF="#JobActivity">JobActivity</A>|		when something interesting happens with a job

|<A HREF="#TextChanged">TextChanged</A>|		after a change was made to the text in <A HREF="intro.html#Normal">Normal</A> mode
|<A HREF="#TextChangedI">TextChangedI</A>|		after a change was made to the text in <A HREF="insert.html#Insert">Insert</A> mode

|<A HREF="#ColorScheme">ColorScheme</A>|		after loading a color scheme

|<A HREF="#RemoteReply">RemoteReply</A>|		a reply from a server Vim was received

|<A HREF="#QuickFixCmdPre">QuickFixCmdPre</A>|	before a <A HREF="quickfix.html#quickfix">quickfix</A> command is run
|<A HREF="#QuickFixCmdPost">QuickFixCmdPost</A>|	after a <A HREF="quickfix.html#quickfix">quickfix</A> command is run

|<A HREF="#SessionLoadPost">SessionLoadPost</A>|	after loading a session file

|<A HREF="#MenuPopup">MenuPopup</A>|		just before showing the popup menu
|<A HREF="#CompleteDone">CompleteDone</A>|		after <A HREF="insert.html#Insert">Insert</A> mode completion is done

|<A HREF="#User">User</A>|			to be used in combination with &quot;<A HREF="#:doautocmd">:doautocmd</A>&quot;



The alphabetical <A HREF="eval.html#list">list</A> of <A HREF="#autocommand">autocommand</A> events:		*<A NAME="autocmd-events-abc"></A><B>autocmd-events-abc</B>*


							*<A NAME="BufCreate"></A><B>BufCreate</B>* *<A NAME="BufAdd"></A><B>BufAdd</B>*
<A HREF="#BufAdd">BufAdd</A> or <A HREF="#BufCreate">BufCreate</A>		Just after creating a new buffer which is
				added to the buffer <A HREF="eval.html#list">list</A>, or adding a buffer
				to the buffer <A HREF="eval.html#list">list</A>.
				Also used just after a buffer in the buffer
				<A HREF="eval.html#list">list</A> has been renamed.
				The <A HREF="#BufCreate">BufCreate</A> event is for historic reasons.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being created &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.

							*<A NAME="BufDelete"></A><B>BufDelete</B>*
<A HREF="#BufDelete">BufDelete</A>			Before <A HREF="change.html#deleting">deleting</A> a buffer from the buffer <A HREF="eval.html#list">list</A>.
				The <A HREF="#BufUnload">BufUnload</A> may be called first (if the
				buffer was loaded).
				Also used just before a buffer in the buffer
				<A HREF="eval.html#list">list</A> is renamed.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being deleted &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot; and &quot;<A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A>&quot;.
				Don't change to another buffer, <A HREF="motion.html#it">it</A> will cause
				problems.

							*<A NAME="BufEnter"></A><B>BufEnter</B>*
<A HREF="#BufEnter">BufEnter</A>			After entering a buffer.  Useful for setting
				<A HREF="options.html#options">options</A> for a file type.  Also executed when
				starting to edit a buffer, after the
				<A HREF="#BufReadPost">BufReadPost</A> autocommands.

							*<A NAME="BufFilePost"></A><B>BufFilePost</B>*
<A HREF="#BufFilePost">BufFilePost</A>			After <A HREF="change.html#changing">changing</A> the name of the current buffer
				with the &quot;<A HREF="editing.html#:file">:file</A>&quot; or &quot;<A HREF="editing.html#:saveas">:saveas</A>&quot; command.

							*<A NAME="BufFilePre"></A><B>BufFilePre</B>*
<A HREF="#BufFilePre">BufFilePre</A>			Before <A HREF="change.html#changing">changing</A> the name of the current buffer
				with the &quot;<A HREF="editing.html#:file">:file</A>&quot; or &quot;<A HREF="editing.html#:saveas">:saveas</A>&quot; command.

							*<A NAME="BufHidden"></A><B>BufHidden</B>*
<A HREF="#BufHidden">BufHidden</A>			Just after a buffer has become hidden.  That
				is, when there are no longer <A HREF="windows.html#windows">windows</A> that show
				the buffer, but the buffer is not unloaded or
				deleted.  Not used for &quot;<A HREF="editing.html#:qa">:qa</A>&quot; or &quot;<A HREF="editing.html#:q">:q</A>&quot; when
				exiting Vim.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being unloaded &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.

							*<A NAME="BufLeave"></A><B>BufLeave</B>*
<A HREF="#BufLeave">BufLeave</A>			Before leaving to another buffer.  Also when
				leaving or closing the current <A HREF="windows.html#window">window</A> and the
				new current <A HREF="windows.html#window">window</A> is not for the same buffer.
				Not used for &quot;<A HREF="editing.html#:qa">:qa</A>&quot; or &quot;<A HREF="editing.html#:q">:q</A>&quot; when exiting Vim.

							*<A NAME="BufNew"></A><B>BufNew</B>*
<A HREF="#BufNew">BufNew</A>				Just after creating a new buffer.  Also used
				just after a buffer has been renamed.  When
				the buffer is added to the buffer <A HREF="eval.html#list">list</A> <A HREF="#BufAdd">BufAdd</A>
				will be triggered too.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being created &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.

							*<A NAME="BufNewFile"></A><B>BufNewFile</B>*
<A HREF="#BufNewFile">BufNewFile</A>			When starting to edit a file that doesn't
				exist.  Can be used to read in a <A HREF="#skeleton">skeleton</A>
				file.

						*<A NAME="BufRead"></A><B>BufRead</B>* *<A NAME="BufReadPost"></A><B>BufReadPost</B>*
<A HREF="#BufRead">BufRead</A> or <A HREF="#BufReadPost">BufReadPost</A>		When starting to edit a new buffer, after
				reading the file into the buffer, before
				executing the modelines.  See |<A HREF="#BufWinEnter">BufWinEnter</A>|
				for when you need to <A HREF="diff.html#do">do</A> something after
				processing the modelines.
				This does NOT work for &quot;<A HREF="insert.html#:r">:r</A> file&quot;.  Not used
				when the file doesn't exist.  Also used after
				successfully recovering a file.
				Also triggered for the filetypedetect group
				when executing &quot;<A HREF="filetype.html#:filetype">:filetype</A> detect&quot; and when
				<A HREF="editing.html#writing">writing</A> an unnamed buffer in a way that the
				buffer gets a name.

							*<A NAME="BufReadCmd"></A><B>BufReadCmd</B>*
<A HREF="#BufReadCmd">BufReadCmd</A>			Before starting to edit a new buffer.  Should
				read the file into the buffer. |<A HREF="#Cmd-event">Cmd-event</A>|

						*<A NAME="BufReadPre"></A><B>BufReadPre</B>* *<A NAME="E200"></A><B>E200</B>* *<A NAME="E201"></A><B>E201</B>*
<A HREF="#BufReadPre">BufReadPre</A>			When starting to edit a new buffer, before
				reading the file into the buffer.  Not used
				if the file doesn't exist.

							*<A NAME="BufUnload"></A><B>BufUnload</B>*
<A HREF="#BufUnload">BufUnload</A>			Before unloading a buffer.  This is when the
				text in the buffer is going to be freed.  This
				may be after a <A HREF="#BufWritePost">BufWritePost</A> and before a
				<A HREF="#BufDelete">BufDelete</A>.  Also used for all <A HREF="windows.html#buffers">buffers</A> that are
				loaded when Vim is going to exit.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being unloaded &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.
				Don't change to another buffer, <A HREF="motion.html#it">it</A> will cause
				problems.
				When exiting and <A HREF="eval.html#v:dying">v:dying</A> is 2 or more this
				event is not triggered.

							*<A NAME="BufWinEnter"></A><B>BufWinEnter</B>*
<A HREF="#BufWinEnter">BufWinEnter</A>			After a buffer is displayed in a <A HREF="windows.html#window">window</A>.  This
				can be when the buffer is loaded (after
				processing the modelines) or when a hidden
				buffer is displayed in a <A HREF="windows.html#window">window</A> (and is no
				longer hidden).
				Does not happen for |<A HREF="windows.html#:split">:split</A>| without
				arguments, since you keep editing the same
				buffer, or &quot;<A HREF="windows.html#:split">:split</A>&quot; with a file that's already
				open in a <A HREF="windows.html#window">window</A>, because <A HREF="motion.html#it">it</A> re-uses an
				existing buffer.  But <A HREF="motion.html#it">it</A> does happen for a
				&quot;<A HREF="windows.html#:split">:split</A>&quot; with the name of the current buffer,
				since <A HREF="motion.html#it">it</A> reloads that buffer.

							*<A NAME="BufWinLeave"></A><B>BufWinLeave</B>*
<A HREF="#BufWinLeave">BufWinLeave</A>			Before a buffer is removed from a <A HREF="windows.html#window">window</A>.
				Not when it's still visible in another <A HREF="windows.html#window">window</A>.
				Also triggered when exiting.  It's triggered
				before <A HREF="#BufUnload">BufUnload</A> or <A HREF="#BufHidden">BufHidden</A>.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being unloaded &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.
				When exiting and <A HREF="eval.html#v:dying">v:dying</A> is 2 or more this
				event is not triggered.

							*<A NAME="BufWipeout"></A><B>BufWipeout</B>*
<A HREF="#BufWipeout">BufWipeout</A>			Before completely <A HREF="change.html#deleting">deleting</A> a buffer.  The
				<A HREF="#BufUnload">BufUnload</A> and <A HREF="#BufDelete">BufDelete</A> events may be called
				first (if the buffer was loaded and was in the
				buffer <A HREF="eval.html#list">list</A>).  Also used just before a buffer
				is renamed (also when it's not in the buffer
				<A HREF="eval.html#list">list</A>).
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer being deleted &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.
				Don't change to another buffer, <A HREF="motion.html#it">it</A> will cause
				problems.

						*<A NAME="BufWrite"></A><B>BufWrite</B>* *<A NAME="BufWritePre"></A><B>BufWritePre</B>*
<A HREF="#BufWrite">BufWrite</A> or <A HREF="#BufWritePre">BufWritePre</A>		Before <A HREF="editing.html#writing">writing</A> the whole buffer to a file.

							*<A NAME="BufWriteCmd"></A><B>BufWriteCmd</B>*
<A HREF="#BufWriteCmd">BufWriteCmd</A>			Before <A HREF="editing.html#writing">writing</A> the whole buffer to a file.
				Should <A HREF="diff.html#do">do</A> the <A HREF="editing.html#writing">writing</A> of the file and reset
				<A HREF="options.html#'modified'">'modified'</A> if successful, unless '<A HREF="motion.html#+">+</A>' is in
				<A HREF="options.html#'cpo'">'cpo'</A> and <A HREF="editing.html#writing">writing</A> to another file |<A HREF="options.html#cpo-+">cpo-+</A>|.
				The buffer contents should not be changed.
				When the command resets <A HREF="options.html#'modified'">'modified'</A> the <A HREF="undo.html#undo">undo</A>
				information is adjusted to <A HREF="motion.html#mark">mark</A> older <A HREF="undo.html#undo">undo</A>
				states <A HREF="motion.html#as">as</A> <A HREF="options.html#'modified'">'modified'</A>, like |<A HREF="editing.html#:write">:write</A>| does.
				|<A HREF="#Cmd-event">Cmd-event</A>|

							*<A NAME="BufWritePost"></A><B>BufWritePost</B>*
<A HREF="#BufWritePost">BufWritePost</A>			After <A HREF="editing.html#writing">writing</A> the whole buffer to a file
				(should <A HREF="undo.html#undo">undo</A> the commands for <A HREF="#BufWritePre">BufWritePre</A>).

							*<A NAME="CmdUndefined"></A><B>CmdUndefined</B>*
<A HREF="#CmdUndefined">CmdUndefined</A>			When a user command is used but <A HREF="motion.html#it">it</A> isn't
				defined.  Useful for defining a command only
				when it's used.  The <A HREF="pattern.html#pattern">pattern</A> is matched
				against the command name.  Both <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> and
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> are set to the name of the command.
				NOTE: Autocompletion won't work until the
				command is defined.  An alternative is to
				always define the user command and have <A HREF="motion.html#it">it</A>
				invoke an autoloaded function.  See |<A HREF="eval.html#autoload">autoload</A>|.

							*<A NAME="CmdwinEnter"></A><B>CmdwinEnter</B>*
<A HREF="#CmdwinEnter">CmdwinEnter</A>			After entering the command-line <A HREF="windows.html#window">window</A>.
				Useful for setting <A HREF="options.html#options">options</A> specifically for
				this special type of <A HREF="windows.html#window">window</A>.  This is
				triggered _instead_ of <A HREF="#BufEnter">BufEnter</A> and <A HREF="#WinEnter">WinEnter</A>.
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> is set to a single character,
				indicating the type of command-line.
				|<A HREF="cmdline.html#cmdwin-char">cmdwin-char</A>|

							*<A NAME="CmdwinLeave"></A><B>CmdwinLeave</B>*
<A HREF="#CmdwinLeave">CmdwinLeave</A>			Before leaving the command-line <A HREF="windows.html#window">window</A>.
				Useful to clean up any global setting done
				with <A HREF="#CmdwinEnter">CmdwinEnter</A>.  This is triggered _instead_
				of <A HREF="#BufLeave">BufLeave</A> and <A HREF="#WinLeave">WinLeave</A>.
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> is set to a single character,
				indicating the type of command-line.
				|<A HREF="cmdline.html#cmdwin-char">cmdwin-char</A>|

							*<A NAME="ColorScheme"></A><B>ColorScheme</B>*
<A HREF="#ColorScheme">ColorScheme</A>			After loading a color scheme. |<A HREF="syntax.html#:colorscheme">:colorscheme</A>|
				The <A HREF="pattern.html#pattern">pattern</A> is matched against the
				colorscheme name. <A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> can be used for the
				name of the actual file where this option was
				set, and <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> for the new colorscheme
				name.



							*<A NAME="CompleteDone"></A><B>CompleteDone</B>*
<A HREF="#CompleteDone">CompleteDone</A>			After <A HREF="insert.html#Insert">Insert</A> mode completion is done.  Either
				when something was completed or abandoning
				completion. |<A HREF="insert.html#ins-completion">ins-completion</A>|


							*<A NAME="CursorHold"></A><B>CursorHold</B>*
<A HREF="#CursorHold">CursorHold</A>			When the user doesn't press a key for the time
				specified with <A HREF="options.html#'updatetime'">'updatetime'</A>.  Not re-triggered
				until the user has pressed a key (i.e. doesn't
				fire every <A HREF="options.html#'updatetime'">'updatetime'</A> ms if you leave Vim to
				make some coffee. :)  See |<A HREF="windows.html#CursorHold-example">CursorHold-example</A>|
				for previewing <A HREF="tagsrch.html#tags">tags</A>.
				This event is only triggered in <A HREF="intro.html#Normal">Normal</A> mode.
				It is not triggered when waiting for a command
				argument to be typed, or a <A HREF="intro.html#movement">movement</A> after an
				<A HREF="motion.html#operator">operator</A>.
				While <A HREF="repeat.html#recording">recording</A> the <A HREF="#CursorHold">CursorHold</A> event is not
				triggered. |<A HREF="repeat.html#q">q</A>|
				Note: Interactive commands cannot be used for
				this event.  There is no <A HREF="message.html#hit-enter">hit-enter</A> prompt,
				the screen is updated directly (when needed).
				Note: In the future there will probably be
				another option to set the time.
				Hint: to force an update of the status lines
				use:
<B>					:let &amp;ro = &amp;ro</B>

<B>							*CursorHoldI*</B>
<A HREF="#CursorHoldI">CursorHoldI</A>			Just like <A HREF="#CursorHold">CursorHold</A>, but in <A HREF="insert.html#Insert">Insert</A> mode.


							*<A NAME="CursorMoved"></A><B>CursorMoved</B>*
<A HREF="#CursorMoved">CursorMoved</A>			After the cursor was moved in <A HREF="intro.html#Normal">Normal</A> or <A HREF="visual.html#Visual">Visual</A>
				mode.  Also when the text of the cursor line
				has been changed, e.g., with &quot;<A HREF="change.html#x">x</A>&quot;, &quot;rx&quot; or &quot;<A HREF="change.html#p">p</A>&quot;.
				Not triggered when there is typeahead or when
				an <A HREF="motion.html#operator">operator</A> is pending.
				For an example see |<A HREF="tips.html#match-parens">match-parens</A>|.
				Careful: This is triggered very often, don't
				<A HREF="diff.html#do">do</A> anything that the user does not expect or
				that is slow.

							*<A NAME="CursorMovedI"></A><B>CursorMovedI</B>*
<A HREF="#CursorMovedI">CursorMovedI</A>			After the cursor was moved in <A HREF="insert.html#Insert">Insert</A> mode.
				Not triggered when the popup menu is visible.
				Otherwise the same <A HREF="motion.html#as">as</A> <A HREF="#CursorMoved">CursorMoved</A>.

							*<A NAME="EncodingChanged"></A><B>EncodingChanged</B>*
<A HREF="#EncodingChanged">EncodingChanged</A>			Fires off after the <A HREF="options.html#'encoding'">'encoding'</A> option has been
				changed.  Useful to set up fonts, for example.

							*<A NAME="FileAppendCmd"></A><B>FileAppendCmd</B>*
<A HREF="#FileAppendCmd">FileAppendCmd</A>			Before appending to a file.  Should <A HREF="diff.html#do">do</A> the
				appending to the file.  Use the <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A>
				marks for the range of lines.|Cmd-eventYXXY

							*<A NAME="FileAppendPost"></A><B>FileAppendPost</B>*
<A HREF="#FileAppendPost">FileAppendPost</A>			After appending to a file.

							*<A NAME="FileAppendPre"></A><B>FileAppendPre</B>*
<A HREF="#FileAppendPre">FileAppendPre</A>			Before appending to a file.  Use the <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A>
				marks for the range of lines.

							*<A NAME="FileChangedRO"></A><B>FileChangedRO</B>*
<A HREF="#FileChangedRO">FileChangedRO</A>			Before making the first change to a read-only
				file.  Can be used to check-out the file from
				a source <A HREF="intro.html#control">control</A> system.  Not triggered when
				the change was caused by an <A HREF="#autocommand">autocommand</A>.
				This event is triggered when making the first
				change in a buffer or the first change after
				<A HREF="options.html#'readonly'">'readonly'</A> was set, just before the change is
				applied to the text.
				WARNING: If the <A HREF="#autocommand">autocommand</A> moves the cursor
				the effect of the change is undefined.

							*<A NAME="E788"></A><B>E788</B>*
				It is not allowed to change to another buffer
				here.  You can <A HREF="editing.html#reload">reload</A> the buffer but not edit
				another one.

							*<A NAME="E881"></A><B>E881</B>*
				If the number of lines changes saving for <A HREF="undo.html#undo">undo</A>
				may fail and the change will be aborted.

							*<A NAME="FileChangedShell"></A><B>FileChangedShell</B>*
<A HREF="#FileChangedShell">FileChangedShell</A>		When Vim notices that the modification time of
				a file has changed since editing started.
				Also when the file attributes of the file
				change or when the size of the file changes.
				|<A HREF="editing.html#timestamp">timestamp</A>|
				Mostly triggered after executing a shell
				command, but also with a |<A HREF="editing.html#:checktime">:checktime</A>| command
				or when Gvim regains input focus.
				This <A HREF="#autocommand">autocommand</A> is triggered for each changed
				file.  It is not used when <A HREF="options.html#'autoread'">'autoread'</A> is set
				and the buffer was not changed.  If a
				<A HREF="#FileChangedShell">FileChangedShell</A> <A HREF="#autocommand">autocommand</A> is present the
				warning message and prompt is not given.
				The |<A HREF="eval.html#v:fcs_reason">v:fcs_reason</A>| variable is set to indicate
				what happened and |<A HREF="eval.html#v:fcs_choice">v:fcs_choice</A>| can be used
				to tell Vim what to <A HREF="diff.html#do">do</A> next.
				NOTE: When this <A HREF="#autocommand">autocommand</A> is executed, the
				current buffer &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; may be different from the
				buffer that was changed &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot;.
				NOTE: The commands must not change the current
				buffer, jump to another buffer or delete a

				buffer.  *<A NAME="E246"></A><B>E246</B>* *<A NAME="E811"></A><B>E811</B>*
				NOTE: This event never nests, to avoid an
				endless loop.  This means that while executing
				commands for the <A HREF="#FileChangedShell">FileChangedShell</A> event no
				other <A HREF="#FileChangedShell">FileChangedShell</A> event will be
				triggered.

							*<A NAME="FileChangedShellPost"></A><B>FileChangedShellPost</B>*
<A HREF="#FileChangedShellPost">FileChangedShellPost</A>		After handling a file that was changed outside
				of Vim.  Can be used to update the statusline.

							*<A NAME="FileEncoding"></A><B>FileEncoding</B>*
<A HREF="#FileEncoding">FileEncoding</A>			Obsolete.  It still works and is equivalent
				to |<A HREF="#EncodingChanged">EncodingChanged</A>|.

							*<A NAME="FileReadCmd"></A><B>FileReadCmd</B>*
<A HREF="#FileReadCmd">FileReadCmd</A>			Before reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command.
				Should <A HREF="diff.html#do">do</A> the reading of the file. |<A HREF="#Cmd-event">Cmd-event</A>|

							*<A NAME="FileReadPost"></A><B>FileReadPost</B>*
<A HREF="#FileReadPost">FileReadPost</A>			After reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command.
				Note that Vim sets the <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> marks to the
				first and last line of the read.  This can be
				used to operate on the lines just read.

							*<A NAME="FileReadPre"></A><B>FileReadPre</B>*
<A HREF="#FileReadPre">FileReadPre</A>			Before reading a file with a &quot;<A HREF="insert.html#:read">:read</A>&quot; command.

							*<A NAME="FileType"></A><B>FileType</B>*
<A HREF="#FileType">FileType</A>			When the <A HREF="options.html#'filetype'">'filetype'</A> option has been set.  The
				<A HREF="pattern.html#pattern">pattern</A> is matched against the <A HREF="filetype.html#filetype">filetype</A>.
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> can be used for the name of the file
				where this option was set, and <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> for
				the new value of <A HREF="options.html#'filetype'">'filetype'</A>.
				See |<A HREF="filetype.html#filetypes">filetypes</A>|.

							*<A NAME="FileWriteCmd"></A><B>FileWriteCmd</B>*
<A HREF="#FileWriteCmd">FileWriteCmd</A>			Before <A HREF="editing.html#writing">writing</A> to a file, when not <A HREF="editing.html#writing">writing</A> the
				whole buffer.  Should <A HREF="diff.html#do">do</A> the <A HREF="editing.html#writing">writing</A> to the
				file.  Should not change the buffer.  Use the
				<A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> marks for the range of lines.
				|<A HREF="#Cmd-event">Cmd-event</A>|

							*<A NAME="FileWritePost"></A><B>FileWritePost</B>*
<A HREF="#FileWritePost">FileWritePost</A>			After <A HREF="editing.html#writing">writing</A> to a file, when not <A HREF="editing.html#writing">writing</A> the
				whole buffer.

							*<A NAME="FileWritePre"></A><B>FileWritePre</B>*
<A HREF="#FileWritePre">FileWritePre</A>			Before <A HREF="editing.html#writing">writing</A> to a file, when not <A HREF="editing.html#writing">writing</A> the
				whole buffer.  Use the <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> marks for the
				range of lines.

							*<A NAME="FilterReadPost"></A><B>FilterReadPost</B>*
<A HREF="#FilterReadPost">FilterReadPost</A>			After reading a file from a <A HREF="change.html#filter">filter</A> command.
				Vim checks the <A HREF="pattern.html#pattern">pattern</A> against the name of
				the current buffer <A HREF="motion.html#as">as</A> with <A HREF="#FilterReadPre">FilterReadPre</A>.
				Not triggered when <A HREF="options.html#'shelltemp'">'shelltemp'</A> is off.

							*<A NAME="FilterReadPre"></A><B>FilterReadPre</B>* *<A NAME="E135"></A><B>E135</B>*
<A HREF="#FilterReadPre">FilterReadPre</A>			Before reading a file from a <A HREF="change.html#filter">filter</A> command.
				Vim checks the <A HREF="pattern.html#pattern">pattern</A> against the name of
				the current buffer, not the name of the
				temporary file that is the output of the
				<A HREF="change.html#filter">filter</A> command.
				Not triggered when <A HREF="options.html#'shelltemp'">'shelltemp'</A> is off.

							*<A NAME="FilterWritePost"></A><B>FilterWritePost</B>*
<A HREF="#FilterWritePost">FilterWritePost</A>			After <A HREF="editing.html#writing">writing</A> a file for a <A HREF="change.html#filter">filter</A> command or
				making a <A HREF="diff.html#diff">diff</A>.
				Vim checks the <A HREF="pattern.html#pattern">pattern</A> against the name of
				the current buffer <A HREF="motion.html#as">as</A> with <A HREF="#FilterWritePre">FilterWritePre</A>.
				Not triggered when <A HREF="options.html#'shelltemp'">'shelltemp'</A> is off.

							*<A NAME="FilterWritePre"></A><B>FilterWritePre</B>*
<A HREF="#FilterWritePre">FilterWritePre</A>			Before <A HREF="editing.html#writing">writing</A> a file for a <A HREF="change.html#filter">filter</A> command or
				making a <A HREF="diff.html#diff">diff</A>.
				Vim checks the <A HREF="pattern.html#pattern">pattern</A> against the name of
				the current buffer, not the name of the
				temporary file that is the output of the
				<A HREF="change.html#filter">filter</A> command.
				Not triggered when <A HREF="options.html#'shelltemp'">'shelltemp'</A> is off.

							*<A NAME="FocusGained"></A><B>FocusGained</B>*
<A HREF="#FocusGained">FocusGained</A>			When Vim got input focus.  Only for the <A HREF="gui.html#GUI">GUI</A>
				version and a few console versions where this
				can be detected.

							*<A NAME="FocusLost"></A><B>FocusLost</B>*
<A HREF="#FocusLost">FocusLost</A>			When Vim lost input focus.  Only for the <A HREF="gui.html#GUI">GUI</A>
				version and a few console versions where this
				can be detected.  May also happen when a
				<A HREF="gui_w32.html#dialog">dialog</A> pops up.

							*<A NAME="FuncUndefined"></A><B>FuncUndefined</B>*
<A HREF="#FuncUndefined">FuncUndefined</A>			When a user function is used but <A HREF="motion.html#it">it</A> isn't
				defined.  Useful for defining a function only
				when it's used.  The <A HREF="pattern.html#pattern">pattern</A> is matched
				against the function name.  Both <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> and
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> are set to the name of the function.
				NOTE: When <A HREF="editing.html#writing">writing</A> Vim scripts a better
				alternative is to use an autoloaded function.
				See |<A HREF="eval.html#autoload-functions">autoload-functions</A>|.

							*<A NAME="GUIEnter"></A><B>GUIEnter</B>*
<A HREF="#GUIEnter">GUIEnter</A>			After starting the <A HREF="gui.html#GUI">GUI</A> successfully, and after
				opening the <A HREF="windows.html#window">window</A>.  It is triggered before
				<A HREF="#VimEnter">VimEnter</A> when using <A HREF="starting.html#gvim">gvim</A>.  Can be used to
				position the <A HREF="windows.html#window">window</A> from a <A HREF="gui.html#.gvimrc">.gvimrc</A> file:
<B>	:autocmd GUIEnter * winpos 100 50</B>

 							*<A NAME="GUIFailed"></A><B>GUIFailed</B>*
<A HREF="#GUIFailed">GUIFailed</A>			After starting the <A HREF="gui.html#GUI">GUI</A> failed.  Vim may
				continue to run in the terminal, if possible
				(only on <A HREF="os_unix.html#Unix">Unix</A> and alikes, when connecting the
				X server fails).  You may want to quit Vim:
<B>	:autocmd GUIFailed * qall</B>

 							*<A NAME="InsertChange"></A><B>InsertChange</B>*
<A HREF="#InsertChange">InsertChange</A>			When typing <A HREF="insert.html#&lt;Insert&gt;">&lt;Insert&gt;</A> while in <A HREF="insert.html#Insert">Insert</A> or
				<A HREF="insert.html#Replace">Replace</A> mode.  The |<A HREF="eval.html#v:insertmode">v:insertmode</A>| variable
				indicates the new mode.
				Be careful not to move the cursor or <A HREF="diff.html#do">do</A>
				anything else that the user does not expect.

							*<A NAME="InsertCharPre"></A><B>InsertCharPre</B>*
<A HREF="#InsertCharPre">InsertCharPre</A>			When a character is typed in <A HREF="insert.html#Insert">Insert</A> mode,
				before <A HREF="insert.html#inserting">inserting</A> the char.
				The |<A HREF="eval.html#v:char">v:char</A>| variable indicates the char typed
				and can be changed during the event to insert
				a different character.  When |<A HREF="eval.html#v:char">v:char</A>| is set
				to more than one character this text is
				inserted literally.
				It is not allowed to change the text |<A HREF="eval.html#textlock">textlock</A>|.
				The event is not triggered when <A HREF="options.html#'paste'">'paste'</A> is
				set.

							*<A NAME="InsertEnter"></A><B>InsertEnter</B>*
<A HREF="#InsertEnter">InsertEnter</A>			Just before starting <A HREF="insert.html#Insert">Insert</A> mode.  Also for
				<A HREF="insert.html#Replace">Replace</A> mode and Virtual <A HREF="insert.html#Replace">Replace</A> mode.  The
				|<A HREF="eval.html#v:insertmode">v:insertmode</A>| variable indicates the mode.
				Be careful not to <A HREF="diff.html#do">do</A> anything else that the
				user does not expect.
				The cursor is restored afterwards.  If you <A HREF="diff.html#do">do</A>
				not want that set |<A HREF="eval.html#v:char">v:char</A>| to a non-empty
				<A HREF="eval.html#string">string</A>.

							*<A NAME="InsertLeave"></A><B>InsertLeave</B>*
<A HREF="#InsertLeave">InsertLeave</A>			When leaving <A HREF="insert.html#Insert">Insert</A> mode.  Also when using
				CTRL-O |<A HREF="insert.html#i_CTRL-O">i_CTRL-O</A>|.  But not for |<A HREF="insert.html#i_CTRL-C">i_CTRL-C</A>|.

						{Nvim}  *<A NAME="JobActivity"></A><B>JobActivity</B>*
<A HREF="#JobActivity">JobActivity</A>			When something interesting happens with a job
				spawned by |<A HREF="eval.html#jobstart()">jobstart()</A>|. See |<A HREF="job_control.html#job-control">job-control</A>| for
				details. 

							*<A NAME="MenuPopup"></A><B>MenuPopup</B>*
<A HREF="#MenuPopup">MenuPopup</A>			Just before showing the popup menu (under the
				right mouse button).  Useful for adjusting the
				menu for what is under the cursor or mouse
				pointer.
				The <A HREF="pattern.html#pattern">pattern</A> is matched against a single
				character representing the mode:
					<A HREF="pattern.html#n">n</A>	<A HREF="intro.html#Normal">Normal</A>
					<A HREF="visual.html#v">v</A>	<A HREF="visual.html#Visual">Visual</A>
					<A HREF="insert.html#o">o</A>	<A HREF="intro.html#Operator-pending">Operator-pending</A>
					<A HREF="insert.html#i">i</A>	<A HREF="insert.html#Insert">Insert</A>
					<A HREF="change.html#c">c</A>	Command line

							*<A NAME="QuickFixCmdPre"></A><B>QuickFixCmdPre</B>*
<A HREF="#QuickFixCmdPre">QuickFixCmdPre</A>			Before a <A HREF="quickfix.html#quickfix">quickfix</A> command is run (|<A HREF="quickfix.html#:make">:make</A>|,
				|<A HREF="quickfix.html#:lmake">:lmake</A>|, |<A HREF="quickfix.html#:grep">:grep</A>|, |<A HREF="quickfix.html#:lgrep">:lgrep</A>|, |<A HREF="quickfix.html#:grepadd">:grepadd</A>|,
				|<A HREF="quickfix.html#:lgrepadd">:lgrepadd</A>|, |<A HREF="quickfix.html#:vimgrep">:vimgrep</A>|, |<A HREF="quickfix.html#:lvimgrep">:lvimgrep</A>|,
				|<A HREF="quickfix.html#:vimgrepadd">:vimgrepadd</A>|, |<A HREF="quickfix.html#:lvimgrepadd">:lvimgrepadd</A>|, |<A HREF="if_cscop.html#:cscope">:cscope</A>|,
				|<A HREF="quickfix.html#:cfile">:cfile</A>|, |<A HREF="quickfix.html#:cgetfile">:cgetfile</A>|, |<A HREF="quickfix.html#:caddfile">:caddfile</A>|, |<A HREF="quickfix.html#:lfile">:lfile</A>|,
				|<A HREF="quickfix.html#:lgetfile">:lgetfile</A>|, |<A HREF="quickfix.html#:laddfile">:laddfile</A>|, |<A HREF="helphelp.html#:helpgrep">:helpgrep</A>|,
				|<A HREF="helphelp.html#:lhelpgrep">:lhelpgrep</A>|).
				The <A HREF="pattern.html#pattern">pattern</A> is matched against the command
				being run.  When |<A HREF="quickfix.html#:grep">:grep</A>| is used but <A HREF="options.html#'grepprg'">'grepprg'</A>
				is set to &quot;internal&quot; <A HREF="motion.html#it">it</A> still matches &quot;<A HREF="quickfix.html#grep">grep</A>&quot;.
				This command cannot be used to set the
				<A HREF="options.html#'makeprg'">'makeprg'</A> and <A HREF="options.html#'grepprg'">'grepprg'</A> <A HREF="eval.html#variables">variables</A>.
				If this command causes an error, the <A HREF="quickfix.html#quickfix">quickfix</A>
				command is not executed.

							*<A NAME="QuickFixCmdPost"></A><B>QuickFixCmdPost</B>*
<A HREF="#QuickFixCmdPost">QuickFixCmdPost</A>			Like <A HREF="#QuickFixCmdPre">QuickFixCmdPre</A>, but after a <A HREF="quickfix.html#quickfix">quickfix</A>
				command is run, before jumping to the first
				location. For |<A HREF="quickfix.html#:cfile">:cfile</A>| and |<A HREF="quickfix.html#:lfile">:lfile</A>| commands
				<A HREF="motion.html#it">it</A> is run after error file is read and before
				moving to the first error.
				See |<A HREF="quickfix.html#QuickFixCmdPost-example">QuickFixCmdPost-example</A>|.

							*<A NAME="QuitPre"></A><B>QuitPre</B>*
<A HREF="#QuitPre">QuitPre</A>				When using `:quit`, `:wq` or `:qall`, before
				deciding whether <A HREF="motion.html#it">it</A> closes the current <A HREF="windows.html#window">window</A>
				or quits Vim.  Can be used to close any
				non-essential <A HREF="windows.html#window">window</A> if the current <A HREF="windows.html#window">window</A> is
				the last ordinary <A HREF="windows.html#window">window</A>.

							*<A NAME="RemoteReply"></A><B>RemoteReply</B>*
<A HREF="#RemoteReply">RemoteReply</A>			When a reply from a Vim that <A HREF="eval.html#functions">functions</A> <A HREF="motion.html#as">as</A>
				server was received |<A HREF="eval.html#server2client()">server2client()</A>|.  The
				<A HREF="pattern.html#pattern">pattern</A> is matched against the {serverid}.
				<A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> is equal to the {serverid} from which
				the reply was sent, and <A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> is the actual
				reply <A HREF="eval.html#string">string</A>.
				Note that even if an <A HREF="#autocommand">autocommand</A> is defined,
				the reply should be read with |<A HREF="eval.html#remote_read()">remote_read()</A>|
				to consume <A HREF="motion.html#it">it</A>.

							*<A NAME="SessionLoadPost"></A><B>SessionLoadPost</B>*
<A HREF="#SessionLoadPost">SessionLoadPost</A>			After loading the session file created using
				the |<A HREF="starting.html#:mksession">:mksession</A>| command.

							*<A NAME="ShellCmdPost"></A><B>ShellCmdPost</B>*
<A HREF="#ShellCmdPost">ShellCmdPost</A>			After executing a shell command with |<A HREF="various.html#:!cmd">:!cmd</A>|,
				|<A HREF="quickfix.html#:make">:make</A>| and |<A HREF="quickfix.html#:grep">:grep</A>|.  Can be used to check for
				any changed files.
				For non-blocking shell commands, see
				|<A HREF="#JobActivity">JobActivity</A>|.

							*<A NAME="ShellFilterPost"></A><B>ShellFilterPost</B>*
<A HREF="#ShellFilterPost">ShellFilterPost</A>			After executing a shell command with
				&quot;:{range}!cmd&quot;, &quot;<A HREF="editing.html#:w">:w</A> !cmd&quot; or &quot;<A HREF="insert.html#:r">:r</A> !cmd&quot;.
				Can be used to check for any changed files.

							*<A NAME="SourcePre"></A><B>SourcePre</B>*
<A HREF="#SourcePre">SourcePre</A>			Before sourcing a Vim <A HREF="usr_41.html#script">script</A>. |<A HREF="repeat.html#:source">:source</A>|
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> is the name of the file being sourced.

							*<A NAME="SourceCmd"></A><B>SourceCmd</B>*
<A HREF="#SourceCmd">SourceCmd</A>			When sourcing a Vim <A HREF="usr_41.html#script">script</A>. |<A HREF="repeat.html#:source">:source</A>|
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> is the name of the file being sourced.
				The <A HREF="#autocommand">autocommand</A> must source this file.
				|<A HREF="#Cmd-event">Cmd-event</A>|

							*<A NAME="SpellFileMissing"></A><B>SpellFileMissing</B>*
<A HREF="#SpellFileMissing">SpellFileMissing</A>		When trying to load a <A HREF="spell.html#spell">spell</A> checking file and
				<A HREF="motion.html#it">it</A> can't be found.  The <A HREF="pattern.html#pattern">pattern</A> is matched
				against the language.  <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> is the
				language, <A HREF="options.html#'encoding'">'encoding'</A> also matters.  See
				|<A HREF="spell.html#spell-SpellFileMissing">spell-SpellFileMissing</A>|.

							*<A NAME="StdinReadPost"></A><B>StdinReadPost</B>*
<A HREF="#StdinReadPost">StdinReadPost</A>			After reading from the stdin into the buffer,
				before executing the modelines.  Only used
				when the &quot;<A HREF="motion.html#-">-</A>&quot; argument was used when Vim was
				started |<A HREF="starting.html#--">--</A>|.

							*<A NAME="StdinReadPre"></A><B>StdinReadPre</B>*
<A HREF="#StdinReadPre">StdinReadPre</A>			Before reading from stdin into the buffer.
				Only used when the &quot;<A HREF="motion.html#-">-</A>&quot; argument was used when
				Vim was started |<A HREF="starting.html#--">--</A>|.

							*<A NAME="SwapExists"></A><B>SwapExists</B>*
<A HREF="#SwapExists">SwapExists</A>			Detected an existing swap file when starting
				to edit a file.  Only when <A HREF="motion.html#it">it</A> is possible to
				select a way to handle the situation, when Vim
				would ask the user what to <A HREF="diff.html#do">do</A>.
				The |<A HREF="eval.html#v:swapname">v:swapname</A>| variable holds the name of
				the swap file found, <A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> the file being
				edited.  |<A HREF="eval.html#v:swapcommand">v:swapcommand</A>| may contain a command
				to be executed in the opened file.
				The commands should set the |<A HREF="eval.html#v:swapchoice">v:swapchoice</A>|
				variable to a <A HREF="eval.html#string">string</A> with one character to
				tell Vim what should be done next:
					'<A HREF="insert.html#o">o</A>'	open read-only
					'<A HREF="motion.html#e">e</A>'	edit the file anyway
					'<A HREF="change.html#r">r</A>'	recover
					'<A HREF="change.html#d">d</A>'	delete the swap file
					'<A HREF="repeat.html#q">q</A>'	quit, don't edit the file
					'<A HREF="insert.html#a">a</A>'	abort, like hitting <A HREF="pattern.html#CTRL-C">CTRL-C</A>
				When set to an empty <A HREF="eval.html#string">string</A> the user will be
				asked, <A HREF="motion.html#as">as</A> if there was no <A HREF="#SwapExists">SwapExists</A> autocmd.

							*<A NAME="E812"></A><B>E812</B>*
				It is not allowed to change to another buffer,
				change a buffer name or change directory
				here.

							*<A NAME="Syntax"></A><B>Syntax</B>*
<A HREF="#Syntax">Syntax</A>				When the <A HREF="options.html#'syntax'">'syntax'</A> option has been set.  The
				<A HREF="pattern.html#pattern">pattern</A> is matched against the <A HREF="syntax.html#syntax">syntax</A> name.
				<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A> can be used for the name of the file
				where this option was set, and <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> for
				the new value of <A HREF="options.html#'syntax'">'syntax'</A>.
				See |<A HREF="syntax.html#:syn-on">:syn-on</A>|.

							*<A NAME="TabEnter"></A><B>TabEnter</B>*
<A HREF="#TabEnter">TabEnter</A>			Just after entering a tab page. |<A HREF="tabpage.html#tab-page">tab-page</A>|
				After triggering the <A HREF="#WinEnter">WinEnter</A> and before
				triggering the <A HREF="#BufEnter">BufEnter</A> event.

							*<A NAME="TabLeave"></A><B>TabLeave</B>*
<A HREF="#TabLeave">TabLeave</A>			Just before leaving a tab page. |<A HREF="tabpage.html#tab-page">tab-page</A>|
				A <A HREF="#WinLeave">WinLeave</A> event will have been triggered
				first.

							*<A NAME="TermChanged"></A><B>TermChanged</B>*
<A HREF="#TermChanged">TermChanged</A>			After the value of <A HREF="options.html#'term'">'term'</A> has changed.  Useful
				for re-loading the <A HREF="syntax.html#syntax">syntax</A> file to update the
				colors, fonts and other terminal-dependent
				settings.  Executed for all loaded <A HREF="windows.html#buffers">buffers</A>.

							*<A NAME="TermResponse"></A><B>TermResponse</B>*
<A HREF="#TermResponse">TermResponse</A>			After the response to |<A HREF="term.html#t_RV">t_RV</A>| is received from
				the terminal.  The value of |<A HREF="eval.html#v:termresponse">v:termresponse</A>|
				can be used to <A HREF="diff.html#do">do</A> things depending on the
				terminal version.  Note that this event may be
				triggered halfway executing another event,
				especially if file I/O, a shell command or
				anything else that takes time is involved.

							*<A NAME="TextChanged"></A><B>TextChanged</B>*
<A HREF="#TextChanged">TextChanged</A>			After a change was made to the text in the
				current buffer in <A HREF="intro.html#Normal">Normal</A> mode.  That is when
				|<A HREF="eval.html#b:changedtick">b:changedtick</A>| has changed.
				Not triggered when there is typeahead or when
				an <A HREF="motion.html#operator">operator</A> is pending.
				Careful: This is triggered very often, don't
				<A HREF="diff.html#do">do</A> anything that the user does not expect or
				that is slow.

							*<A NAME="TextChangedI"></A><B>TextChangedI</B>*
<A HREF="#TextChangedI">TextChangedI</A>			After a change was made to the text in the
				current buffer in <A HREF="insert.html#Insert">Insert</A> mode.
				Not triggered when the popup menu is visible.
				Otherwise the same <A HREF="motion.html#as">as</A> <A HREF="#TextChanged">TextChanged</A>.

							*<A NAME="User"></A><B>User</B>*
<A HREF="#User">User</A>				Never executed automatically.  To be used for
				autocommands that are only executed with
				&quot;<A HREF="#:doautocmd">:doautocmd</A>&quot;.

							*<A NAME="UserGettingBored"></A><B>UserGettingBored</B>*
<A HREF="#UserGettingBored">UserGettingBored</A>		When the user presses the same key <A HREF="usr_42.html#42">42</A> times.
				Just kidding! :-)

							*<A NAME="VimEnter"></A><B>VimEnter</B>*
<A HREF="#VimEnter">VimEnter</A>			After doing all the <A HREF="starting.html#startup">startup</A> stuff, including
				loading <A HREF="starting.html#.vimrc">.vimrc</A> files, executing the &quot;<A HREF="starting.html#-c">-c</A> cmd&quot;
				arguments, creating all <A HREF="windows.html#windows">windows</A> and loading
				the <A HREF="windows.html#buffers">buffers</A> in them.

							*<A NAME="VimLeave"></A><B>VimLeave</B>*
<A HREF="#VimLeave">VimLeave</A>			Before exiting Vim, just after <A HREF="editing.html#writing">writing</A> the
				.viminfo file.  Executed only once, like
				<A HREF="#VimLeavePre">VimLeavePre</A>.
				To detect an abnormal exit use |<A HREF="eval.html#v:dying">v:dying</A>|.
				When <A HREF="eval.html#v:dying">v:dying</A> is 2 or more this event is not
				triggered.

							*<A NAME="VimLeavePre"></A><B>VimLeavePre</B>*
<A HREF="#VimLeavePre">VimLeavePre</A>			Before exiting Vim, just before <A HREF="editing.html#writing">writing</A> the
				.viminfo file.  This is executed only once,
				if there is a match with the name of what
				happens to be the current buffer when exiting.
				Mostly useful with a &quot;*&quot; <A HREF="pattern.html#pattern">pattern</A>.
<B>	:autocmd VimLeavePre * call CleanupStuff()</B>
 				To detect an abnormal exit use |<A HREF="eval.html#v:dying">v:dying</A>|.
				When <A HREF="eval.html#v:dying">v:dying</A> is 2 or more this event is not
				triggered.

							*<A NAME="VimResized"></A><B>VimResized</B>*
<A HREF="#VimResized">VimResized</A>			After the Vim <A HREF="windows.html#window">window</A> was resized, thus <A HREF="options.html#'lines'">'lines'</A>
				and/or <A HREF="options.html#'columns'">'columns'</A> changed.  Not when starting
				up though.

							*<A NAME="WinEnter"></A><B>WinEnter</B>*
<A HREF="#WinEnter">WinEnter</A>			After entering another <A HREF="windows.html#window">window</A>.  Not done for
				the first <A HREF="windows.html#window">window</A>, when Vim has just started.
				Useful for setting the <A HREF="windows.html#window">window</A> height.
				If the <A HREF="windows.html#window">window</A> is for another buffer, Vim
				executes the <A HREF="#BufEnter">BufEnter</A> autocommands after the
				<A HREF="#WinEnter">WinEnter</A> autocommands.
				Note: When using &quot;<A HREF="windows.html#:split">:split</A> fname&quot; the <A HREF="#WinEnter">WinEnter</A>
				event is triggered after the split but before
				the file &quot;fname&quot; is loaded.

							*<A NAME="WinLeave"></A><B>WinLeave</B>*
<A HREF="#WinLeave">WinLeave</A>			Before leaving a <A HREF="windows.html#window">window</A>.  If the <A HREF="windows.html#window">window</A> to be
				entered next is for a different buffer, Vim
				executes the <A HREF="#BufLeave">BufLeave</A> autocommands before the
				<A HREF="#WinLeave">WinLeave</A> autocommands (but not for &quot;:new&quot;).
				Not used for &quot;<A HREF="editing.html#:qa">:qa</A>&quot; or &quot;<A HREF="editing.html#:q">:q</A>&quot; when exiting Vim.

==============================================================================

6. Patterns					*<A NAME="autocmd-patterns"></A><B>autocmd-patterns</B>* *<A NAME="{pat}"></A><B>{pat}</B>*

The file <A HREF="pattern.html#pattern">pattern</A> <A HREF="#{pat}">{pat}</A> is tested for a match against the file name in one of
two ways:
1. When there is no '<A HREF="pattern.html#/">/</A>' in the <A HREF="pattern.html#pattern">pattern</A>, Vim checks for a match against only
   the tail part of the file name (without its leading directory path).
2. When there is a '<A HREF="pattern.html#/">/</A>' in the <A HREF="pattern.html#pattern">pattern</A>, Vim checks for a match against both the
   short file name (as you typed <A HREF="motion.html#it">it</A>) and the full file name (after expanding
   <A HREF="motion.html#it">it</A> to a full path and resolving symbolic links).

The special <A HREF="pattern.html#pattern">pattern</A> &lt;buffer&gt; or <A HREF="#&lt;buffer=N&gt;">&lt;buffer=N&gt;</A> is used for buffer-local
autocommands |<A HREF="#autocmd-buflocal">autocmd-buflocal</A>|.  This <A HREF="pattern.html#pattern">pattern</A> is not matched against the name
of a buffer.

Examples:
<B>	:autocmd BufRead *.txt		set et</B>
Set the <A HREF="options.html#'et'">'et'</A> option for all text files.

<B>	:autocmd BufRead /vim/src/*.c	set cindent</B>
Set the <A HREF="options.html#'cindent'">'cindent'</A> option for C files in the /vim/src directory.

<B>	:autocmd BufRead /tmp/*.c	set ts=5</B>
If you have a link from &quot;/tmp/test.c&quot; to &quot;/home/nobody/vim/src/test.c&quot;, and
you start editing &quot;/tmp/test.c&quot;, this <A HREF="#autocommand">autocommand</A> will match.

Note:  To match part of a path, but not from the root directory, use a '*' <A HREF="motion.html#as">as</A>
the first character.  Example:
<B>	:autocmd BufRead */doc/*.txt	set tw=78</B>
This <A HREF="#autocommand">autocommand</A> will for example be executed for &quot;/tmp/doc/xx.txt&quot; and
&quot;/usr/home/piet/doc/yy.txt&quot;.  The number of directories does not matter here.


The file name that the <A HREF="pattern.html#pattern">pattern</A> is matched against is after expanding
<A HREF="editing.html#wildcards">wildcards</A>.  Thus if you issue this command:
<B>	:e $ROOTDIR/main.$EXT</B>
The argument is first expanded to:
<B>	/usr/root/main.py</B>
Before it's matched with the <A HREF="pattern.html#pattern">pattern</A> of the <A HREF="#autocommand">autocommand</A>.  Careful with this
when using events like <A HREF="#FileReadCmd">FileReadCmd</A>, the value of <A HREF="cmdline.html#&lt;amatch&gt;">&lt;amatch&gt;</A> may not be what you
expect.


Environment <A HREF="eval.html#variables">variables</A> can be used in a <A HREF="pattern.html#pattern">pattern</A>:
<B>	:autocmd BufRead $VIMRUNTIME/doc/*.txt  set expandtab</B>
And ~ can be used for the home directory (if <A HREF="options.html#$HOME">$HOME</A> is defined):
<B>	:autocmd BufWritePost ~/.vimrc   so ~/.vimrc</B>
<B>	:autocmd BufRead ~archive/*      set readonly</B>
The environment variable is expanded when the <A HREF="#autocommand">autocommand</A> is defined, not when
the <A HREF="#autocommand">autocommand</A> is executed.  This is different from the command!


							*<A NAME="file-pattern"></A><B>file-pattern</B>*
The <A HREF="pattern.html#pattern">pattern</A> is interpreted like mostly used in file names:
	&#42;	matches any sequence of characters; Unusual: includes path
		separators
	?	matches any single character
	\?	matches a '<A HREF="pattern.html#?">?</A>'
	.	matches a '<A HREF="repeat.html#.">.</A>'
	~	matches a '<A HREF="change.html#~">~</A>'
	,	separates patterns
	\,	matches a '<A HREF="motion.html#,">,</A>'
	{ }	like \( \) in a |<A HREF="pattern.html#pattern">pattern</A>|
	,	inside { }: like \| in a |pattern||||
	\}	literal }
	\{	literal {
	\\\{n,m\}  like \{n,m} in a |<A HREF="pattern.html#pattern">pattern</A>|
	\	special meaning like in a |<A HREF="pattern.html#pattern">pattern</A>|
	[ch]	matches '<A HREF="change.html#c">c</A>' or '<A HREF="motion.html#h">h</A>'
	[^ch]   match any character but '<A HREF="change.html#c">c</A>' and '<A HREF="motion.html#h">h</A>'

Note that for all systems the '<A HREF="pattern.html#/">/</A>' character is used for path separator (even
MS-DOS). This was done because the <A HREF="intro.html#backslash">backslash</A> is difficult to use in a <A HREF="pattern.html#pattern">pattern</A>
and to make the autocommands portable across different systems.


							*<A NAME="autocmd-changes"></A><B>autocmd-changes</B>*
Matching with the <A HREF="pattern.html#pattern">pattern</A> is done when an event is triggered.  Changing the
buffer name in one of the autocommands, or even <A HREF="change.html#deleting">deleting</A> the buffer, does not
change which autocommands will be executed.  Example:

<B>	au BufEnter *.foo  bdel</B>
<B>	au BufEnter *.foo  set modified</B>

This will delete the current buffer and then set <A HREF="options.html#'modified'">'modified'</A> in what has become
the current buffer instead.  Vim doesn't take into account that &quot;*.foo&quot;
doesn't match with that buffer name.  It matches &quot;*.foo&quot; with the name of the
buffer at the moment the event was triggered.

However, buffer-local autocommands will not be executed for a buffer that has
been wiped out with |<A HREF="windows.html#:bwipe">:bwipe</A>|.  After <A HREF="change.html#deleting">deleting</A> the buffer with |<A HREF="windows.html#:bdel">:bdel</A>| the
buffer actually still exists (it becomes unlisted), thus the autocommands are
still executed.

==============================================================================

7. Buffer-local autocommands	*<A NAME="autocmd-buflocal"></A><B>autocmd-buflocal</B>* *<A NAME="autocmd-buffer-local"></A><B>autocmd-buffer-local</B>*

					*<A NAME="&lt;buffer=N&gt;"></A><B>&lt;buffer=N&gt;</B>* *<A NAME="&lt;buffer=abuf&gt;"></A><B>&lt;buffer=abuf&gt;</B>* *<A NAME="E680"></A><B>E680</B>*

Buffer-local autocommands are attached to a specific buffer.  They are useful
if the buffer does not have a name and when the name does not match a specific
<A HREF="pattern.html#pattern">pattern</A>.  But <A HREF="motion.html#it">it</A> also means they must be explicitly added to each buffer.

Instead of a <A HREF="pattern.html#pattern">pattern</A> buffer-local autocommands use one of these forms:
	&lt;buffer&gt;	current buffer
	&lt;buffer=99&gt;	buffer number 99
	<A HREF="#&lt;buffer=abuf&gt;">&lt;buffer=abuf&gt;</A>	using <A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A> (only when executing autocommands)
			|<A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A>|

Examples:
<B>    :au CursorHold &lt;buffer&gt;  echo 'hold'</B>
<B>    :au CursorHold &lt;buffer=33&gt;  echo 'hold'</B>
<B>    :au CursorHold &lt;buffer=abuf&gt;  echo 'hold'</B>

All the commands for autocommands also work with buffer-local autocommands,
simply use the special <A HREF="eval.html#string">string</A> instead of the <A HREF="pattern.html#pattern">pattern</A>.  Examples:
<B>    :au! * &lt;buffer&gt;		     " remove buffer-local autocommands for</B>
<B>				     " current buffer</B>
<B>    :au! * &lt;buffer=33&gt;		     " remove buffer-local autocommands for</B>
<B>				     " buffer #33</B>
<B>    :bufdo :au! CursorHold &lt;buffer&gt;  " remove autocmd for given event for all</B>
<B>				     " buffers</B>
<B>    :au * &lt;buffer&gt;		     " list buffer-local autocommands for</B>
<B>				     " current buffer</B>

Note that when an <A HREF="#autocommand">autocommand</A> is defined for the current buffer, <A HREF="motion.html#it">it</A> is stored
with the buffer number.  Thus <A HREF="motion.html#it">it</A> uses the form &quot;&lt;buffer=12&gt;&quot;, where 12 is the
number of the current buffer.  You will see this when listing autocommands,
for example.

To test for presence of buffer-local autocommands use the |<A HREF="eval.html#exists()">exists()</A>| function
<A HREF="motion.html#as">as</A> follows:
<B>    :if exists("#CursorHold#&lt;buffer=12&gt;") | ... | endif</B>
<B>    :if exists("#CursorHold#&lt;buffer&gt;") | ... | endif    " for current buffer</B>

When a buffer is wiped out its buffer-local autocommands are also gone, of
course.  Note that when <A HREF="change.html#deleting">deleting</A> a buffer, e.g., with &quot;<A HREF="windows.html#:bdel">:bdel</A>&quot;, <A HREF="motion.html#it">it</A> is only
unlisted, the autocommands are still present.  In order to see the removal of
buffer-local autocommands:
<B>    :set verbose=6</B>

It is not possible to define buffer-local autocommands for a non-existent
buffer.

==============================================================================

8. Groups						*<A NAME="autocmd-groups"></A><B>autocmd-groups</B>*

Autocommands can be put together in a group.  This is useful for removing or
executing a group of autocommands.  For example, all the autocommands for
<A HREF="syntax.html#syntax">syntax</A> highlighting are put in the &quot;highlight&quot; group, to be able to execute
&quot;<A HREF="#:doautoall">:doautoall</A> highlight BufRead&quot; when the <A HREF="gui.html#GUI">GUI</A> starts.

When no specific group is selected, Vim uses the default group.  The default
group does not have a name.  You cannot execute the autocommands from the
default group separately; you can execute them only by executing autocommands
for all groups.

Normally, when executing autocommands automatically, Vim uses the autocommands
for all groups.  The group only matters when executing autocommands with
&quot;<A HREF="#:doautocmd">:doautocmd</A>&quot; or &quot;<A HREF="#:doautoall">:doautoall</A>&quot;, or when defining or <A HREF="change.html#deleting">deleting</A> autocommands.

The group name can contain any characters except white space.  The group name
&quot;end&quot; is reserved (also in <A HREF="change.html#uppercase">uppercase</A>).

The group name is <A HREF="change.html#case">case</A> sensitive.  Note that this is different from the event
name!


							*<A NAME=":aug"></A><B>:aug</B>* *<A NAME=":augroup"></A><B>:augroup</B>*
:aug[roup] {name}		Define the autocmd group name for the
				following &quot;<A HREF="#:autocmd">:autocmd</A>&quot; commands.  The name &quot;end&quot;
				or &quot;END&quot; selects the default group.


						*<A NAME=":augroup-delete"></A><B>:augroup-delete</B>* *<A NAME="E367"></A><B>E367</B>*
:aug[roup]! {name}		Delete the autocmd group {name}.  Don't use
				this if there is still an <A HREF="#autocommand">autocommand</A> using
				this group!  This is not checked.

To enter autocommands for a specific group, use this method:
1. <A HREF="visual.html#Select">Select</A> the group with &quot;<A HREF="#:augroup">:augroup</A> {name}&quot;.
2. Delete any old autocommands with &quot;:au!&quot;.
3. Define the autocommands.
4. Go back to the default group with &quot;augroup END&quot;.

Example:
<B>	:augroup uncompress</B>
<B>	:  au!</B>
<B>	:  au BufEnter *.gz	%!gunzip</B>
<B>	:augroup END</B>

This prevents having the autocommands defined <A HREF="if_cscop.html#twice">twice</A> (e.g., after sourcing the
<A HREF="starting.html#.vimrc">.vimrc</A> file again).

==============================================================================

9. Executing autocommands				*<A NAME="autocmd-execute"></A><B>autocmd-execute</B>*

Vim can also execute Autocommands non-automatically.  This is useful if you
have changed autocommands, or when Vim has executed the wrong autocommands
(e.g., the file <A HREF="pattern.html#pattern">pattern</A> match was wrong).

Note that the <A HREF="options.html#'eventignore'">'eventignore'</A> option applies here too.  Events listed in this
option will not cause any commands to be executed.


					*<A NAME=":do"></A><B>:do</B>* *<A NAME=":doau"></A><B>:doau</B>* *<A NAME=":doautocmd"></A><B>:doautocmd</B>* *<A NAME="E217"></A><B>E217</B>*
:do[autocmd] [&lt;nomodeline&gt;] [group] <A HREF="#{event}">{event}</A> [fname]
			Apply the autocommands matching [fname] (default:
			current file name) for <A HREF="#{event}">{event}</A> to the current buffer.
			You can use this when the current file name does not
			match the right <A HREF="pattern.html#pattern">pattern</A>, after <A HREF="change.html#changing">changing</A> settings, or
			to execute autocommands for a certain event.
			It's possible to use this inside an <A HREF="#autocommand">autocommand</A> too,
			so you can base the autocommands for one extension on
			another extension.  Example:
<B>				:au BufEnter *.cpp so ~/.vimrc_cpp</B>
<B>				:au BufEnter *.cpp doau BufEnter x.c</B>
 			Be careful to avoid endless loops.  See
			|<A HREF="#autocmd-nested">autocmd-nested</A>|.

			When the [group] argument is not given, Vim executes
			the autocommands for all groups.  When the [group]
			argument is included, Vim executes only the matching
			autocommands for that group.  Note: if you use an
			undefined group name, Vim gives you an error message.

							*<A NAME="&lt;nomodeline&gt;"></A><B>&lt;nomodeline&gt;</B>*
			After applying the autocommands the modelines are
			processed, so that their settings overrule the
			settings from autocommands, like what happens when
			editing a file. This is skipped when the <A HREF="#&lt;nomodeline&gt;">&lt;nomodeline&gt;</A>
			argument is present. You probably want to use
			<A HREF="#&lt;nomodeline&gt;">&lt;nomodeline&gt;</A> for events that are not used when loading
			a buffer, such <A HREF="motion.html#as">as</A> |<A HREF="#User">User</A>|.


						*<A NAME=":doautoa"></A><B>:doautoa</B>* *<A NAME=":doautoall"></A><B>:doautoall</B>*
:doautoa[ll] [&lt;nomodeline&gt;] [group] <A HREF="#{event}">{event}</A> [fname]
			Like &quot;<A HREF="#:doautocmd">:doautocmd</A>&quot;, but apply the autocommands to each
			loaded buffer.  Note that [fname] is used to select
			the autocommands, not the <A HREF="windows.html#buffers">buffers</A> to which they are
			applied.
			Careful: Don't use this for autocommands that delete a
			buffer, change to another buffer or change the
			contents of a buffer; the result is unpredictable.
			This command is intended for autocommands that set
			<A HREF="options.html#options">options</A>, change highlighting, and things like that.

==============================================================================

10. Using autocommands					*<A NAME="autocmd-use"></A><B>autocmd-use</B>*

For WRITING FILES there are four possible sets of events.  Vim uses only one
of these sets for a write command:

<A HREF="#BufWriteCmd">BufWriteCmd</A>	<A HREF="#BufWritePre">BufWritePre</A>	<A HREF="#BufWritePost">BufWritePost</A>	<A HREF="editing.html#writing">writing</A> the whole buffer
		<A HREF="#FilterWritePre">FilterWritePre</A>	<A HREF="#FilterWritePost">FilterWritePost</A>	<A HREF="editing.html#writing">writing</A> to <A HREF="change.html#filter">filter</A> temp file
<A HREF="#FileAppendCmd">FileAppendCmd</A>	<A HREF="#FileAppendPre">FileAppendPre</A>	<A HREF="#FileAppendPost">FileAppendPost</A>	appending to a file
<A HREF="#FileWriteCmd">FileWriteCmd</A>	<A HREF="#FileWritePre">FileWritePre</A>	<A HREF="#FileWritePost">FileWritePost</A>	any other file write

When there is a matching &quot;*Cmd&quot; <A HREF="#autocommand">autocommand</A>, <A HREF="motion.html#it">it</A> is assumed <A HREF="motion.html#it">it</A> will <A HREF="diff.html#do">do</A> the
<A HREF="editing.html#writing">writing</A>.  No further <A HREF="editing.html#writing">writing</A> is done and the other events are not triggered.
|<A HREF="#Cmd-event">Cmd-event</A>|

Note that the *WritePost commands should <A HREF="undo.html#undo">undo</A> any changes to the buffer that
were caused by the *WritePre commands; otherwise, <A HREF="editing.html#writing">writing</A> the file will have
the side effect of <A HREF="change.html#changing">changing</A> the buffer.

Before executing the autocommands, the buffer from which the lines are to be
written temporarily becomes the current buffer.  Unless the autocommands
change the current buffer or delete the previously current buffer, the
previously current buffer is made the current buffer again.

The *WritePre and *AppendPre autocommands must not delete the buffer from
which the lines are to be written.

The <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> marks have a special position:
- Before the *ReadPre event the <A HREF="motion.html#'[">'[</A> <A HREF="motion.html#mark">mark</A> is set to the line just above where
  the new lines will be inserted.
- Before the *ReadPost event the <A HREF="motion.html#'[">'[</A> <A HREF="motion.html#mark">mark</A> is set to the first line that was
  just read, the <A HREF="motion.html#']">']</A> <A HREF="motion.html#mark">mark</A> to the last line.
- Before executing the *WriteCmd, *WritePre and *AppendPre autocommands the <A HREF="motion.html#'[">'[</A>
  <A HREF="motion.html#mark">mark</A> is set to the first line that will be written, the <A HREF="motion.html#']">']</A> <A HREF="motion.html#mark">mark</A> to the last
  line.
Careful: <A HREF="motion.html#'[">'[</A> and <A HREF="motion.html#']">']</A> change when using commands that change the buffer.

In commands which expect a file name, you can use &quot;<A HREF="cmdline.html#&lt;afile&gt;">&lt;afile&gt;</A>&quot; for the file name
that is being read |<A HREF="cmdline.html#:&lt;afile&gt;">:&lt;afile&gt;</A>| (you can also use &quot;<A HREF="motion.html#&#37;">&#37;</A>&quot; for the current file
name).  &quot;<A HREF="cmdline.html#&lt;abuf&gt;">&lt;abuf&gt;</A>&quot; can be used for the buffer number of the currently effective
buffer.  This also works for <A HREF="windows.html#buffers">buffers</A> that doesn't have a name.  But <A HREF="motion.html#it">it</A> doesn't
work for files without a buffer (e.g., with &quot;<A HREF="insert.html#:r">:r</A> file&quot;).


							*<A NAME="gzip-example"></A><B>gzip-example</B>*
Examples for reading and <A HREF="editing.html#writing">writing</A> compressed files:
<B>  :augroup gzip</B>
<B>  :  autocmd!</B>
<B>  :  autocmd BufReadPre,FileReadPre	*.gz set bin</B>
<B>  :  autocmd BufReadPost,FileReadPost	*.gz '[,']!gunzip</B>
<B>  :  autocmd BufReadPost,FileReadPost	*.gz set nobin</B>
<B>  :  autocmd BufReadPost,FileReadPost	*.gz execute ":doautocmd BufReadPost " . expand("%:r")</B>
<B>  :  autocmd BufWritePost,FileWritePost	*.gz !mv &lt;afile&gt; &lt;afile&gt;:r</B>
<B>  :  autocmd BufWritePost,FileWritePost	*.gz !gzip &lt;afile&gt;:r</B>

<B>  :  autocmd FileAppendPre		*.gz !gunzip &lt;afile&gt;</B>
<B>  :  autocmd FileAppendPre		*.gz !mv &lt;afile&gt;:r &lt;afile&gt;</B>
<B>  :  autocmd FileAppendPost		*.gz !mv &lt;afile&gt; &lt;afile&gt;:r</B>
<B>  :  autocmd FileAppendPost		*.gz !gzip &lt;afile&gt;:r</B>
<B>  :augroup END</B>

The &quot;<A HREF="pi_gzip.html#gzip">gzip</A>&quot; group is used to be able to delete any existing autocommands with
&quot;:autocmd!&quot;, for when the file is sourced <A HREF="if_cscop.html#twice">twice</A>.

(&quot;&lt;afile&gt;:r&quot; is the file name without the extension, see |<A HREF="cmdline.html#:_&#37;:">:_&#37;:</A>|)

The commands executed for the <A HREF="#BufNewFile">BufNewFile</A>, BufRead/BufReadPost, <A HREF="#BufWritePost">BufWritePost</A>,
<A HREF="#FileAppendPost">FileAppendPost</A> and <A HREF="#VimLeave">VimLeave</A> events <A HREF="diff.html#do">do</A> not set or reset the changed flag of the
buffer.  When you decompress the buffer with the <A HREF="#BufReadPost">BufReadPost</A> autocommands, you
can still exit with &quot;<A HREF="editing.html#:q">:q</A>&quot;.  When you use &quot;<A HREF="undo.html#:undo">:undo</A>&quot; in <A HREF="#BufWritePost">BufWritePost</A> to <A HREF="undo.html#undo">undo</A> the
changes made by <A HREF="#BufWritePre">BufWritePre</A> commands, you can still <A HREF="diff.html#do">do</A> &quot;<A HREF="editing.html#:q">:q</A>&quot; (this also makes
&quot;<A HREF="editing.html#ZZ">ZZ</A>&quot; work).  If you <A HREF="diff.html#do">do</A> want the buffer to be marked <A HREF="motion.html#as">as</A> modified, set the
<A HREF="options.html#'modified'">'modified'</A> option.

To execute <A HREF="intro.html#Normal">Normal</A> mode commands from an <A HREF="#autocommand">autocommand</A>, use the &quot;<A HREF="various.html#:normal">:normal</A>&quot;
command.  Use with care!  If the <A HREF="intro.html#Normal">Normal</A> mode command is not finished, the user
needs to type characters (e.g., after &quot;<A HREF="various.html#:normal">:normal</A> m&quot; you need to type a <A HREF="motion.html#mark">mark</A>
name).

If you want the buffer to be unmodified after <A HREF="change.html#changing">changing</A> <A HREF="motion.html#it">it</A>, reset the
<A HREF="options.html#'modified'">'modified'</A> option.  This makes <A HREF="motion.html#it">it</A> possible to exit the buffer with &quot;<A HREF="editing.html#:q">:q</A>&quot;
instead of &quot;:q!&quot;.


							*<A NAME="autocmd-nested"></A><B>autocmd-nested</B>* *<A NAME="E218"></A><B>E218</B>*
By default, autocommands <A HREF="diff.html#do">do</A> not nest.  If you use &quot;<A HREF="editing.html#:e">:e</A>&quot; or &quot;<A HREF="editing.html#:w">:w</A>&quot; in an
<A HREF="#autocommand">autocommand</A>, Vim does not execute the <A HREF="#BufRead">BufRead</A> and <A HREF="#BufWrite">BufWrite</A> autocommands for
those commands.  If you <A HREF="diff.html#do">do</A> want this, use the &quot;nested&quot; flag for those commands
in which you want nesting.  For example:
<B>  :autocmd FileChangedShell *.c nested e!</B>
The nesting is limited to 10 levels to get out of recursive loops.

It's possible to use the &quot;<A HREF="#:au">:au</A>&quot; command in an <A HREF="#autocommand">autocommand</A>.  This can be a
self-modifying command!  This can be useful for an <A HREF="#autocommand">autocommand</A> that should
execute only once.

If you want to skip autocommands for one command, use the |<A HREF="#:noautocmd">:noautocmd</A>| command
modifier or the <A HREF="options.html#'eventignore'">'eventignore'</A> option.

Note: When reading a file (with &quot;<A HREF="insert.html#:read">:read</A> file&quot; or with a <A HREF="change.html#filter">filter</A> command) and the
last line in the file does not have an <A HREF="intro.html#&lt;EOL&gt;">&lt;EOL&gt;</A>, Vim remembers this.  At the next
write (with &quot;<A HREF="editing.html#:write">:write</A> file&quot; or with a <A HREF="change.html#filter">filter</A> command), if the same line is
written again <A HREF="motion.html#as">as</A> the last line in a file AND <A HREF="options.html#'binary'">'binary'</A> is set, Vim does not
supply an <A HREF="intro.html#&lt;EOL&gt;">&lt;EOL&gt;</A>.  This makes a <A HREF="change.html#filter">filter</A> command on the just read lines write the
same file <A HREF="motion.html#as">as</A> was read, and makes a write command on just filtered lines write
the same file <A HREF="motion.html#as">as</A> was read from the <A HREF="change.html#filter">filter</A>.  For example, another way to write
a compressed file:

<B>  :autocmd FileWritePre *.gz   set bin|'[,']!gzip</B>
<B>  :autocmd FileWritePost *.gz  undo|set nobin</B>
 

							*<A NAME="autocommand-pattern"></A><B>autocommand-pattern</B>*
You can specify multiple patterns, separated by commas.  Here are some
examples:

<B>  :autocmd BufRead   *		set tw=79 nocin ic infercase fo=2croq</B>
<B>  :autocmd BufRead   .letter	set tw=72 fo=2tcrq</B>
<B>  :autocmd BufEnter  .letter	set dict=/usr/lib/dict/words</B>
<B>  :autocmd BufLeave  .letter	set dict=</B>
<B>  :autocmd BufRead,BufNewFile   *.c,*.h	set tw=0 cin noic</B>
<B>  :autocmd BufEnter  *.c,*.h	abbr FOR for (i = 0; i &lt; 3; ++i)&lt;CR&gt;{&lt;CR&gt;}&lt;Esc&gt;O</B>
<B>  :autocmd BufLeave  *.c,*.h	unabbr FOR</B>

For makefiles (makefile, Makefile, imakefile, makefile.unix, etc.):

<B>  :autocmd BufEnter  ?akefile*	set include=^s\=include</B>
<B>  :autocmd BufLeave  ?akefile*	set include&amp;</B>

To always start editing C files at the first function:

<B>  :autocmd BufRead   *.c,*.h	1;/^{</B>

Without the &quot;1;&quot; above, the search would start from wherever the file was
entered, rather than from the start of the file.


						*<A NAME="skeleton"></A><B>skeleton</B>* *<A NAME="template"></A><B>template</B>*
To read a <A HREF="#skeleton">skeleton</A> (template) file when opening a new file:

<B>  :autocmd BufNewFile  *.c	0r ~/vim/skeleton.c</B>
<B>  :autocmd BufNewFile  *.h	0r ~/vim/skeleton.h</B>
<B>  :autocmd BufNewFile  *.java	0r ~/vim/skeleton.java</B>

To insert the current date and time in a *.html file when <A HREF="editing.html#writing">writing</A> <A HREF="motion.html#it">it</A>:

<B>  :autocmd BufWritePre,FileWritePre *.html   ks|call LastMod()|'s</B>
<B>  :fun LastMod()</B>
<B>  :  if line("$") &gt; 20</B>
<B>  :    let l = 20</B>
<B>  :  else</B>
<B>  :    let l = line("$")</B>
<B>  :  endif</B>
<B>  :  exe "1," . l . "g/Last modified: /s/Last modified: .*/Last modified: " .</B>
<B>  :  \ strftime("%Y %b %d")</B>
<B>  :endfun</B>

You need to have a line &quot;Last modified: &lt;date time&gt;&quot; in the first 20 lines
of the file for this to work.  Vim replaces &lt;date time&gt; (and anything in the
same line after <A HREF="motion.html#it">it</A>) with the current date and time.  Explanation:
	ks		<A HREF="motion.html#mark">mark</A> current position with <A HREF="motion.html#mark">mark</A> '<A HREF="change.html#s">s</A>'
	call LastMod()  call the LastMod() function to <A HREF="diff.html#do">do</A> the work
	's		return the cursor to the old position
The LastMod() function checks if the file is shorter than 20 lines, and then
uses the &quot;<A HREF="repeat.html#:g">:g</A>&quot; command to find lines that contain &quot;Last modified: &quot;.  For those
lines the &quot;<A HREF="change.html#:s">:s</A>&quot; command is executed to replace the existing date with the
current one.  The &quot;<A HREF="eval.html#:execute">:execute</A>&quot; command is used to be able to use an <A HREF="eval.html#expression">expression</A>
for the &quot;<A HREF="repeat.html#:g">:g</A>&quot; and &quot;<A HREF="change.html#:s">:s</A>&quot; commands.  The date is obtained with the <A HREF="eval.html#strftime()">strftime()</A>
function.  You can change its argument to get another date <A HREF="eval.html#string">string</A>.

When entering <A HREF="#:autocmd">:autocmd</A> on the command-line, completion of events and command
names may be done (with <A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>, <A HREF="scroll.html#CTRL-D">CTRL-D</A>, etc.) where appropriate.

Vim executes all matching autocommands in the order that you specify them.
It is recommended that your first <A HREF="#autocommand">autocommand</A> be used for all files by using
&quot;*&quot; <A HREF="motion.html#as">as</A> the file <A HREF="pattern.html#pattern">pattern</A>.  This means that you can define defaults you like
here for any settings, and if there is another matching <A HREF="#autocommand">autocommand</A> <A HREF="motion.html#it">it</A> will
override these.  But if there is no other matching <A HREF="#autocommand">autocommand</A>, then at least
your default settings are recovered (if entering this file from another for
which autocommands did match).  Note that &quot;*&quot; will also match files starting
with &quot;<A HREF="repeat.html#.">.</A>&quot;, unlike <A HREF="os_unix.html#Unix">Unix</A> shells.


						    *<A NAME="autocmd-searchpat"></A><B>autocmd-searchpat</B>*
Autocommands <A HREF="diff.html#do">do</A> not change the current search patterns.  Vim saves the current
search patterns before executing autocommands then restores them after the
autocommands finish.  This means that autocommands <A HREF="diff.html#do">do</A> not affect the strings
highlighted with the <A HREF="options.html#'hlsearch'">'hlsearch'</A> option.  Within autocommands, you can still
use search patterns normally, e.g., with the &quot;<A HREF="pattern.html#n">n</A>&quot; command.
If you want an <A HREF="#autocommand">autocommand</A> to set the search <A HREF="pattern.html#pattern">pattern</A>, such that <A HREF="motion.html#it">it</A> is used
after the <A HREF="#autocommand">autocommand</A> finishes, use the &quot;<A HREF="eval.html#:let">:let</A> <A HREF="change.html#@/">@/</A> =&quot; command.
The search-highlighting cannot be switched off with &quot;<A HREF="pattern.html#:nohlsearch">:nohlsearch</A>&quot; in an
<A HREF="#autocommand">autocommand</A>.  Use the '<A HREF="motion.html#h">h</A>' flag in the <A HREF="options.html#'viminfo'">'viminfo'</A> option to disable search-
highlighting when starting Vim.


							*<A NAME="Cmd-event"></A><B>Cmd-event</B>*
When using one of the &quot;*Cmd&quot; events, the matching autocommands are expected to
<A HREF="diff.html#do">do</A> the file reading, <A HREF="editing.html#writing">writing</A> or sourcing.  This can be used when working with
a special kind of file, for example on a remote system.
CAREFUL: If you use these events in a wrong way, <A HREF="motion.html#it">it</A> may have the effect of
making <A HREF="motion.html#it">it</A> impossible to read or write the matching files!  Make sure you test
your autocommands properly.  Best is to use a <A HREF="pattern.html#pattern">pattern</A> that will never match a
 normal file name, for example &quot;ftp://*&quot;.

When defining a <A HREF="#BufReadCmd">BufReadCmd</A> <A HREF="motion.html#it">it</A> will be difficult for Vim to recover a crashed
editing session.  When recovering from the original file, Vim reads only those
parts of a file that are not found in the swap file.  Since that is not
possible with a <A HREF="#BufReadCmd">BufReadCmd</A>, use the |<A HREF="recover.html#:preserve">:preserve</A>| command to make sure the
original file isn't needed for <A HREF="recover.html#recovery">recovery</A>.  You might want to <A HREF="diff.html#do">do</A> this only when
you expect the file to be modified.

For file read and write commands the |<A HREF="eval.html#v:cmdarg">v:cmdarg</A>| variable holds the &quot;++enc=&quot;
and &quot;++ff=&quot; argument that are effective.  These should be used for the command
that reads/writes the file.  The |<A HREF="eval.html#v:cmdbang">v:cmdbang</A>| variable is one when &quot;<A HREF="change.html#!">!</A>&quot; was
used, zero otherwise.

See the $VIMRUNTIME/plugin/netrwPlugin.vim for examples.

==============================================================================

11. Disabling autocommands				*<A NAME="autocmd-disable"></A><B>autocmd-disable</B>*

To disable autocommands for some time use the <A HREF="options.html#'eventignore'">'eventignore'</A> option.  Note that
this may cause unexpected behavior, make sure you restore <A HREF="options.html#'eventignore'">'eventignore'</A>
afterwards, using a |<A HREF="eval.html#:try">:try</A>| block with |<A HREF="eval.html#:finally">:finally</A>|.


							*<A NAME=":noautocmd"></A><B>:noautocmd</B>* *<A NAME=":noa"></A><B>:noa</B>*
To disable autocommands for just one command use the &quot;<A HREF="#:noautocmd">:noautocmd</A>&quot; command
modifier.  This will set <A HREF="options.html#'eventignore'">'eventignore'</A> to &quot;all&quot; for the duration of the
following command.  Example:

<B>	:noautocmd w fname.gz</B>

This will write the file without triggering the autocommands defined by the
<A HREF="pi_gzip.html#gzip">gzip</A> <A HREF="usr_05.html#plugin">plugin</A>.


<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun Jan 18 09:15:22 UTC 2015 from <a href="https://github.com/neovim/neovim/commit/bff48b23d700d6202e1c85564cd7fcb1b3ce4c34"><code>bff48b2</code></a>.
      </div>
    </footer>
  </body>
</html>
