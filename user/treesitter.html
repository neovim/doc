  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Neovim user documentation">

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" />
    <link rel="preconnect" href="https://X185E15FPG-dsn.algolia.net" crossorigin />

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="help.css" rel="stylesheet">
    <link href="/highlight/styles/neovim.min.css" rel="stylesheet">

    <script src="/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title> Treesitter - Neovim docs</title>
  </head>
  <body>
    <header class="container">
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a href="/" class="navbar-brand" aria-label="logo">
          <!--TODO: use <img src="….svg"> here instead. Need one that has green lettering instead of gray. -->
              <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214" aria-label="Neovim">
      <title>Neovim</title>
      <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
          <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
          <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
          <stop stop-color="#7DB643" offset="0%" />
          <stop stop-color="#367533" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
          <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
          <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
        </linearGradient>
      </defs>
      <g fill="none" fill-rule="evenodd">
        <path
          d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
          fill="url(#a)"
          transform="translate(1 1)"
        />
        <path
          d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
          fill="url(#b)"
          transform="matrix(-1 0 0 1 305 1)"
        />
        <path
          d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
          fill="url(#c)"
          transform="translate(1 1)"
        />
        <path
          d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
          fill-opacity=".13"
          fill="#000"
        />
        <g fill="#444">
          <path
            d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
            fill="currentColor"
          />
          <path
            d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
            fill="currentColor"
            fill-opacity=".8"
          />
        </g>
      </g>
    </svg>
  
          <!--<img src="https://neovim.io/logos/neovim-logo.svg" width="173" height="50" alt="Neovim" />-->
        </a>
        <div id="docsearch"></div> <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
      </div>
    </nav>
  </header>

  <div class="container golden-grid help-body">
  <div class="col-wide">
  <a name="treesitter.txt" href="#treesitter"><h1 id="treesitter"> Treesitter</h1></a>
  <p>
    <i>
    Nvim <code>:help</code> pages, <a href="https://github.com/neovim/neovim/blob/master/src/gen/gen_help_html.lua">generated</a>
    from <a href="https://github.com/neovim/neovim/blob/master/runtime/doc/treesitter.txt">source</a>
    using the <a href="https://github.com/neovim/tree-sitter-vimdoc">tree-sitter-vimdoc</a> parser.
    </i>
  </p>
  <hr/>
  <div class="old-help-para">Treesitter integration</div>
<div class="old-help-para">Nvim integrates the <code>tree-sitter</code> library for incremental parsing of buffers:
<a href="https://tree-sitter.github.io/tree-sitter/">https://tree-sitter.github.io/tree-sitter/</a></div>
<div class="old-help-para"><b>WARNING:</b> Treesitter support is still experimental and subject to frequent
changes. This documentation may also not fully reflect the latest changes.</div>
<div class="old-help-para"><h2 id="_parser-files" class="help-heading">PARSER FILES<span class="help-heading-tags">                                              <span id="treesitter-parsers" class="help-tag"><a href="#treesitter-parsers">treesitter-parsers</a></span></h2></div>
<div class="old-help-para">Parsers are the heart of treesitter. They are libraries that treesitter will
search for in the <code>parser</code> runtime directory.</div>
<div class="old-help-para">Nvim includes these parsers:</div>
<div class="old-help-para"><div class="help-li" style=""> C
</div><div class="help-li" style=""> Lua
</div><div class="help-li" style=""> Markdown
</div><div class="help-li" style=""> Vimscript
</div><div class="help-li" style=""> Vimdoc
</div><div class="help-li" style=""> Treesitter query files <a href="filetype.html#ft-query-plugin">ft-query-plugin</a>
</div></div>
<div class="old-help-para">You can install more parsers manually, or with a plugin like
<a href="https://github.com/nvim-treesitter/nvim-treesitter">https://github.com/nvim-treesitter/nvim-treesitter</a> .</div>
<div class="old-help-para">Parsers are searched for as <code>parser/{lang}.*</code> in any <a href="options.html#'runtimepath'">'runtimepath'</a> directory.
If multiple parsers for the same language are found, the first one is used.
(NOTE: This typically implies the priority "user config &gt; plugins &gt; bundled".)</div>
<div class="old-help-para">To load a parser from its filepath:<pre><code class="language-lua">vim.treesitter.language.add('python', { path = "/path/to/python.so" })</code></pre></div>
<div class="old-help-para">Parser names are assumed to be lower case if the file system is
case-sensitive.</div>
<div class="old-help-para">To associate certain <a href="filetype.html#filetypes">filetypes</a> with a treesitter language (name of parser),
use <a href="treesitter.html#vim.treesitter.language.register()">vim.treesitter.language.register()</a>. For example, to use the <code>xml</code>
treesitter parser for buffers with filetype <code>svg</code> or <code>xslt</code>, use:<pre><code class="language-lua">vim.treesitter.language.register('xml', { 'svg', 'xslt' })</code></pre></div>
<div class="old-help-para">                                                    <span id="treesitter-parsers-wasm" class="help-tag-right"><a href="#treesitter-parsers-wasm">treesitter-parsers-wasm</a></span><br></div>
<div class="old-help-para">If Nvim is built with <code>ENABLE_WASMTIME</code>, then wasm parsers can also be
loaded:<pre><code class="language-lua">vim.treesitter.language.add('python', { path = "/path/to/python.wasm" })</code></pre></div>
<div class="old-help-para"><h2 id="_treesitter-queries" class="help-heading">TREESITTER QUERIES<span class="help-heading-tags">                                          <span id="treesitter-query" class="help-tag"><a href="#treesitter-query">treesitter-query</a></span></h2></div>
<div class="old-help-para">Treesitter queries are a way to extract information about a parsed <a href="treesitter.html#TSTree">TSTree</a>,
e.g., for the purpose of highlighting. Briefly, a <code>query</code> consists of one or
more patterns. A <code>pattern</code> is defined over node types in the syntax tree. A
<code>match</code> corresponds to specific elements of the syntax tree which match a
pattern. Patterns may optionally define captures and predicates. A <code>capture</code>
allows you to associate names with a specific node in a pattern. A <code>predicate</code>
adds arbitrary metadata and conditional data to a match.</div>
<div class="old-help-para">Queries are written in a lisp-like language documented in
<a href="https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html">https://tree-sitter.github.io/tree-sitter/using-parsers/queries/1-syntax.html</a>
<b>Note:</b> The predicates listed there differ from those Nvim supports. See
<a href="treesitter.html#treesitter-predicates">treesitter-predicates</a> for a complete list of predicates supported by Nvim.</div>
<div class="old-help-para">Nvim looks for queries as <code>*.scm</code> files in a <code>queries</code> directory under
<code>runtimepath</code>, where each file contains queries for a specific language and
purpose, e.g., <code>queries/lua/highlights.scm</code> for highlighting Lua files.
By default, the first query on <code>runtimepath</code> is used (which usually implies
that user config takes precedence over plugins, which take precedence over
queries bundled with Nvim). If a query should extend other queries instead
of replacing them, use <a href="treesitter.html#treesitter-query-modeline-extends">treesitter-query-modeline-extends</a>.</div>
<div class="old-help-para">The Lua interface is described at <a href="treesitter.html#lua-treesitter-query">lua-treesitter-query</a>.</div>
<div class="old-help-para"><h3 id="_treesitter-query-predicates" class="help-heading">TREESITTER QUERY PREDICATES<span class="help-heading-tags">                            <span id="treesitter-predicates" class="help-tag"><a href="#treesitter-predicates">treesitter-predicates</a></span></h3></div>
<div class="old-help-para">Predicates are special scheme nodes that are evaluated to conditionally capture
nodes. For example, the <code>eq?</code> predicate can be used as follows:<pre><code class="language-query">((identifier) @variable.builtin
  (#eq? @variable.builtin "self"))</code></pre></div>
<div class="old-help-para">to only match identifier corresponding to the <code>"self"</code> text. Such queries can
be used to highlight built-in functions or variables differently, for instance.</div>
<div class="old-help-para">The following predicates are built in:</div>
<div class="old-help-para">    <code>eq?</code>                                            <span id="treesitter-predicate-eq%3F" class="help-tag-right"><a href="#treesitter-predicate-eq%3F">treesitter-predicate-eq?</a></span><br>
        Match a string against the text corresponding to a node:<pre><code class="language-query">((identifier) @variable.builtin (#eq? @variable.builtin "self"))
((node1) @left (node2) @right (#eq? @left @right))</code></pre></div>
<div class="old-help-para">    <code>any-eq?</code>                                    <span id="treesitter-predicate-any-eq%3F" class="help-tag-right"><a href="#treesitter-predicate-any-eq%3F">treesitter-predicate-any-eq?</a></span><br>
        Like <code>eq?</code>, but for quantified patterns only one captured node must
        match.</div>
<div class="old-help-para">    <code>match?</code>                                      <span id="treesitter-predicate-match%3F" class="help-tag-right"><a href="#treesitter-predicate-match%3F">treesitter-predicate-match?</a></span><br>
    <code>vim-match?</code>                              <span id="treesitter-predicate-vim-match%3F" class="help-tag-right"><a href="#treesitter-predicate-vim-match%3F">treesitter-predicate-vim-match?</a></span><br>
         Match a <a href="pattern.html#regexp">regexp</a> against the text corresponding to a node:<pre><code class="language-query">((identifier) @constant (#match? @constant "^[A-Z_]+$"))</code></pre></div>
<div class="old-help-para"><b>         Note:</b> The <code>^</code> and <code>$</code> anchors will match the start and end of the
               node's text.</div>
<div class="old-help-para">    <code>any-match?</code>                              <span id="treesitter-predicate-any-match%3F" class="help-tag-right"><a href="#treesitter-predicate-any-match%3F">treesitter-predicate-any-match?</a></span><br>
    <code>any-vim-match?</code>                      <span id="treesitter-predicate-any-vim-match%3F" class="help-tag-right"><a href="#treesitter-predicate-any-vim-match%3F">treesitter-predicate-any-vim-match?</a></span><br>
        Like <code>match?</code>, but for quantified patterns only one captured node must
        match.</div>
<div class="old-help-para">    <code>lua-match?</code>                              <span id="treesitter-predicate-lua-match%3F" class="help-tag-right"><a href="#treesitter-predicate-lua-match%3F">treesitter-predicate-lua-match?</a></span><br>
         Match <a href="luaref.html#lua-pattern">lua-pattern</a>s against the text corresponding to a node,
         similar to <code>match?</code></div>
<div class="old-help-para">    <code>any-lua-match?</code>                      <span id="treesitter-predicate-any-lua-match%3F" class="help-tag-right"><a href="#treesitter-predicate-any-lua-match%3F">treesitter-predicate-any-lua-match?</a></span><br>
         Like <code>lua-match?</code>, but for quantified patterns only one captured node
         must match.</div>
<div class="old-help-para">    <code>contains?</code>                                <span id="treesitter-predicate-contains%3F" class="help-tag-right"><a href="#treesitter-predicate-contains%3F">treesitter-predicate-contains?</a></span><br>
        Match a string against parts of the text corresponding to a node:<pre><code class="language-query">((identifier) @foo (#contains? @foo "foo"))
((identifier) @foo-bar (#contains? @foo-bar "foo" "bar"))</code></pre></div>
<div class="old-help-para">    <code>any-contains?</code>                        <span id="treesitter-predicate-any-contains%3F" class="help-tag-right"><a href="#treesitter-predicate-any-contains%3F">treesitter-predicate-any-contains?</a></span><br>
        Like <code>contains?</code>, but for quantified patterns only one captured node
        must match.</div>
<div class="old-help-para">    <code>any-of?</code>                                    <span id="treesitter-predicate-any-of%3F" class="help-tag-right"><a href="#treesitter-predicate-any-of%3F">treesitter-predicate-any-of?</a></span><br>
        Match any of the given strings against the text corresponding to
        a node:<pre><code class="language-query">((identifier) @foo (#any-of? @foo "foo" "bar"))</code></pre></div>
<div class="old-help-para">        This is the recommended way to check if the node matches one of many
        keywords, as it has been optimized for this.</div>
<div class="old-help-para">    <code>has-ancestor?</code>                        <span id="treesitter-predicate-has-ancestor%3F" class="help-tag-right"><a href="#treesitter-predicate-has-ancestor%3F">treesitter-predicate-has-ancestor?</a></span><br>
        Match any of the given node types against all ancestors of a node:<pre><code class="language-query">((identifier) @variable.builtin
  (#any-of? @variable.builtin "begin" "end")
  (#has-ancestor? @variable.builtin range_expression))</code></pre></div>
<div class="old-help-para">    <code>has-parent?</code>                            <span id="treesitter-predicate-has-parent%3F" class="help-tag-right"><a href="#treesitter-predicate-has-parent%3F">treesitter-predicate-has-parent?</a></span><br>
        Match any of the given node types against the direct ancestor of a
        node:<pre><code class="language-query">(((field_expression
     (field_identifier) @method)) @_parent
 (#has-parent? @_parent template_method function_declarator))</code></pre></div>
<div class="old-help-para">                                                    <span id="treesitter-predicate-not" class="help-tag-right"><a href="#treesitter-predicate-not">treesitter-predicate-not</a></span><br>
Each predicate has a <code>not-</code> prefixed predicate that is just the negation of
the predicate.</div>
<div class="old-help-para">                                                    <span id="treesitter-predicate-all" class="help-tag-right"><a href="#treesitter-predicate-all">treesitter-predicate-all</a></span><br>
                                                    <span id="treesitter-predicate-any" class="help-tag-right"><a href="#treesitter-predicate-any">treesitter-predicate-any</a></span><br>
Queries can use quantifiers to capture multiple nodes. When a capture contains
multiple nodes, predicates match only if ALL nodes contained by the capture
match the predicate. Some predicates (<code>eq?</code>, <code>match?</code>, <code>lua-match?</code>,
<code>contains?</code>) accept an <code>any-</code> prefix to instead match if ANY of the nodes
contained by the capture match the predicate.</div>
<div class="old-help-para">As an example, consider the following Lua code:<pre><code class="language-lua">-- TODO: This is a
-- very long
-- comment (just imagine it)</code></pre></div>
<div class="old-help-para">using the following predicated query:
<pre><code class="language-query">(((comment)+ @comment)
 (#match? @comment "TODO"))</code></pre></div>
<div class="old-help-para">This query will not match because not all of the nodes captured by @comment
match the predicate. Instead, use:
<pre><code class="language-query">(((comment)+ @comment)
 (#any-match? @comment "TODO"))</code></pre></div>
<div class="old-help-para">Further predicates can be added via <a href="treesitter.html#vim.treesitter.query.add_predicate()">vim.treesitter.query.add_predicate()</a>.
Use <a href="treesitter.html#vim.treesitter.query.list_predicates()">vim.treesitter.query.list_predicates()</a> to list all available predicates.</div>
<div class="old-help-para"><h3 id="_treesitter-query-directives" class="help-heading">TREESITTER QUERY DIRECTIVES<span class="help-heading-tags">                            <span id="treesitter-directives" class="help-tag"><a href="#treesitter-directives">treesitter-directives</a></span></h3></div>
<div class="old-help-para">Treesitter directives store metadata for a node or match and perform side
effects. For example, the <code>set!</code> directive sets metadata on the match or node:<pre><code class="language-query">((identifier) @foo (#set! type "parameter"))</code></pre></div>
<div class="old-help-para">The following directives are built in:</div>
<div class="old-help-para">    <code>set!</code>                                          <span id="treesitter-directive-set%21" class="help-tag-right"><a href="#treesitter-directive-set%21">treesitter-directive-set!</a></span><br>
        Sets key/value metadata for a specific match or capture. Value is
        accessible as either <code>metadata[key]</code> (match specific) or
        <code>metadata[capture_id][key]</code> (capture specific).</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div>            <code>{capture_id}</code> (optional)
            <code>{key}</code>
            <code>{value}</code></div>
<div class="old-help-para">        Examples:<pre><code class="language-query">((identifier) @foo (#set! @foo kind "parameter"))
((node1) @left (node2) @right (#set! type "pair"))
((codeblock) @markup.raw.block (#set! priority 90))</code></pre></div>
<div class="old-help-para">    <code>offset!</code>                                      <span id="treesitter-directive-offset%21" class="help-tag-right"><a href="#treesitter-directive-offset%21">treesitter-directive-offset!</a></span><br>
        Takes the range of the captured node and applies an offset. This will
        set a new range in the form of a list like { <code>{start_row}</code>, <code>{start_col}</code>,
        <code>{end_row}</code>, <code>{end_col}</code> } for the captured node with <code>capture_id</code> as
        <code>metadata[capture_id].offset</code>. This offset will be applied to the
        range returned in <a href="treesitter.html#vim.treesitter.get_range()">vim.treesitter.get_range()</a>. Useful for
        <a href="treesitter.html#treesitter-language-injections">treesitter-language-injections</a>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div>            <code>{capture_id}</code>
            <code>{start_row}</code>
            <code>{start_col}</code>
            <code>{end_row}</code>
            <code>{end_col}</code></div>
<div class="old-help-para">        Example:<pre><code class="language-query">((identifier) @constant (#offset! @constant 0 1 0 -1))</code></pre></div>
<div class="old-help-para">    <code>gsub!</code>                                          <span id="treesitter-directive-gsub%21" class="help-tag-right"><a href="#treesitter-directive-gsub%21">treesitter-directive-gsub!</a></span><br>
        Transforms the content of the node using a <a href="luaref.html#lua-pattern">lua-pattern</a>. This will set
        a new <code>metadata[capture_id].text</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div>            <code>{capture_id}</code>
            <code>{pattern}</code>
            <code>{replacement}</code></div>
<div class="old-help-para">        Example:<pre><code class="language-query">(#gsub! @_node ".*%.(.*)" "%1")</code></pre></div>
<div class="old-help-para">    <code>trim!</code>                                          <span id="treesitter-directive-trim%21" class="help-tag-right"><a href="#treesitter-directive-trim%21">treesitter-directive-trim!</a></span><br>
        Trims whitespace from the node. Sets a new
        <code>metadata[capture_id].range</code>. Takes a capture ID and, optionally, four
        integers to customize trimming behavior (<code>1</code> meaning trim, <code>0</code> meaning
        don't trim). When only given a capture ID, trims blank lines (lines
        that contain only whitespace, or are empty) from the end of the node
        (for backwards compatibility). Can trim all whitespace from both sides
        of the node if parameters are given.</div>
<div class="old-help-para">        Examples:<pre><code class="language-query">; only trim blank lines from the end of the node
; (equivalent to (#trim! @fold 0 0 1 0))
(#trim! @fold)
; trim blank lines from both sides of the node
(#trim! @fold 1 0 1 0)
; trim all whitespace around the node
(#trim! @fold 1 1 1 1)</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div>            <code>{capture_id}</code>
            <code>{trim_start_linewise}</code>
            <code>{trim_start_charwise}</code>
            <code>{trim_end_linewise}</code> (default <code>1</code> if only given <code>{capture_id}</code>)
            <code>{trim_end_charwise}</code></div>
<div class="old-help-para">Further directives can be added via <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a>.
Use <a href="treesitter.html#vim.treesitter.query.list_directives()">vim.treesitter.query.list_directives()</a> to list all available directives.</div>
<div class="old-help-para"><h3 id="_treesitter-query-modelines" class="help-heading">TREESITTER QUERY MODELINES<span class="help-heading-tags">                          <span id="treesitter-query-modeline" class="help-tag"><a href="#treesitter-query-modeline">treesitter-query-modeline</a></span></h3></div>
<div class="old-help-para">Nvim supports to customize the behavior of the queries using a set of
"modelines", that is comments in the queries starting with <code>;</code>. Here are the
currently supported modeline alternatives:</div>
<div class="old-help-para">    <code>inherits: {lang}...</code>                     <span id="treesitter-query-modeline-inherits" class="help-tag-right"><a href="#treesitter-query-modeline-inherits">treesitter-query-modeline-inherits</a></span><br>
        Specifies that this query should inherit the queries from <code>{lang}</code>.
        This will recursively descend in the queries of <code>{lang}</code> unless wrapped
        in parentheses: <code>({lang})</code>.
<b>        Note:</b> This is meant to be used to include queries from another
        language. If you want your query to extend the queries of the same
        language, use <code>extends</code>.</div>
<div class="old-help-para">    <code>extends</code>                                  <span id="treesitter-query-modeline-extends" class="help-tag-right"><a href="#treesitter-query-modeline-extends">treesitter-query-modeline-extends</a></span><br>
        Specifies that this query should be used as an extension for the
        query, i.e. that it should be merged with the others.
<b>        Note:</b> The order of the extensions, and the query that will be used as
        a base depends on your <a href="options.html#'runtimepath'">'runtimepath'</a> value.</div>
<div class="old-help-para"><b>Note:</b> These modeline comments must be at the top of the query, but can be
repeated, for example, the following two modeline blocks are both valid:
<pre><code class="language-query">;; inherits: typescript,jsx
;; extends</code></pre></div>
<div class="old-help-para"><pre><code class="language-query">;; extends
;;
;; inherits: css</code></pre></div>
<div class="old-help-para"><h2 id="_treesitter-syntax-highlighting" class="help-heading">TREESITTER SYNTAX HIGHLIGHTING<span class="help-heading-tags">                          <span id="treesitter-highlight" class="help-tag"><a href="#treesitter-highlight">treesitter-highlight</a></span></h2></div>
<div class="old-help-para">Syntax highlighting is specified through queries named <code>highlights.scm</code>,
which match a <a href="treesitter.html#TSNode">TSNode</a> in the parsed <a href="treesitter.html#TSTree">TSTree</a> to a <code>capture</code> that can be
assigned a highlight group. For example, the query<pre><code class="language-query">(parameters (identifier) @variable.parameter)</code></pre></div>
<div class="old-help-para">matches any <code>identifier</code> node inside a function <code>parameters</code> node to the
capture named <code>@variable.parameter</code>. For example, for a Lua code<pre><code class="language-lua">function f(foo, bar) end</code></pre></div>
<div class="old-help-para">which will be parsed as (see <a href="treesitter.html#%3AInspectTree">:InspectTree</a>):<pre><code class="language-query">(function_declaration ; [1:1 - 24]
  name: (identifier) ; [1:10 - 10]
  parameters: (parameters ; [1:11 - 20]
    name: (identifier) ; [1:12 - 14]
    name: (identifier))) ; [1:17 - 19]</code></pre></div>
<div class="old-help-para">the above query will highlight <code>foo</code> and <code>bar</code> as <code>@variable.parameter</code>.</div>
<div class="old-help-para">It is also possible to match literal expressions (provided the parser returns
them):
<pre><code class="language-query">[
  "if"
  "else"
] @keyword.conditional</code></pre></div>
<div class="old-help-para">Assuming a suitable parser and <code>highlights.scm</code> query is found in runtimepath,
treesitter highlighting for the current buffer can be enabled simply via
<a href="treesitter.html#vim.treesitter.start()">vim.treesitter.start()</a>.</div>
<div class="old-help-para">                                                 <span id="treesitter-highlight-groups" class="help-tag-right"><a href="#treesitter-highlight-groups">treesitter-highlight-groups</a></span><br>
The capture names, prefixed with <code>@</code>, are directly usable as highlight groups.
For many commonly used captures, the corresponding highlight groups are linked
to Nvim's standard <a href="syntax.html#highlight-groups">highlight-groups</a> by default (e.g., <code>@comment</code> links to
<code>Comment</code>) but can be overridden in colorschemes.</div>
<div class="old-help-para">A fallback system is implemented, so that more specific groups fallback to
more generic ones. For instance, in a language that has separate doc comments
(e.g., c, java, etc.), <code>@comment.documentation</code> could be used. If this group
is not defined, the highlighting for an ordinary <code>@comment</code> is used. This way,
existing color schemes already work out of the box, but it is possible to add
more specific variants for queries that make them available.</div>
<div class="old-help-para">As an additional rule, capture highlights can always be specialized by
language, by appending the language name after an additional dot. For
instance, to highlight comments differently per language:<pre><code class="language-vim">hi @comment.c guifg=Blue
hi @comment.lua guifg=DarkBlue
hi link @comment.documentation.java String</code></pre></div>
<div class="old-help-para">The following is a list of standard captures used in queries for Nvim,
highlighted according to the current colorscheme (use <a href="lua.html#%3AInspect">:Inspect</a> on one to see
the exact definition):</div>
<div class="old-help-para">@variable                       various variable names
@variable.builtin               built-in variable names (e.g. <code>this</code>, <code>self</code>)
@variable.parameter             parameters of a function
@variable.parameter.builtin     special parameters (e.g. <code>_</code>, <code>it</code>)
@variable.member                object and struct fields</div>
<div class="old-help-para">@constant               constant identifiers
@constant.builtin       built-in constant values
@constant.macro         constants defined by the preprocessor</div>
<div class="old-help-para">@module                 modules or namespaces
@module.builtin         built-in modules or namespaces
@label                  <code>GOTO</code> and other labels (e.g. <code>label:</code> in C), including heredoc labels</div>
<div class="old-help-para">@string                 string literals
@string.documentation   string documenting code (e.g. Python docstrings)
@string.regexp          regular expressions
@string.escape          escape sequences
@string.special         other special strings (e.g. dates)
@string.special.symbol  symbols or atoms
@string.special.path    filenames
@string.special.url     URIs (e.g. hyperlinks)</div>
<div class="old-help-para">@character              character literals
@character.special      special characters (e.g. wildcards)</div>
<div class="old-help-para">@boolean                boolean literals
@number                 numeric literals
@number.float           floating-point number literals</div>
<div class="old-help-para">@type                   type or class definitions and annotations
@type.builtin           built-in types
@type.definition        identifiers in type definitions (e.g. <code>typedef &lt;type&gt; &lt;identifier&gt;</code> in C)</div>
<div class="old-help-para">@attribute              attribute annotations (e.g. Python decorators, Rust lifetimes)
@attribute.builtin      builtin annotations (e.g. <code>@property</code> in Python)
@property               the key in key/value pairs</div>
<div class="old-help-para">@function               function definitions
@function.builtin       built-in functions
@function.call          function calls
@function.macro         preprocessor macros</div>
<div class="old-help-para">@function.method        method definitions
@function.method.call   method calls</div>
<div class="old-help-para">@constructor            constructor calls and definitions
@operator               symbolic operators (e.g. <code>+</code>, <code>*</code>)</div>
<div class="old-help-para">@keyword                keywords not fitting into specific categories
@keyword.coroutine      keywords related to coroutines (e.g. <code>go</code> in Go, <code>async/await</code> in Python)
@keyword.function       keywords that define a function (e.g. <code>func</code> in Go, <code>def</code> in Python)
@keyword.operator       operators that are English words (e.g. <code>and</code>, <code>or</code>)
@keyword.import         keywords for including or exporting modules (e.g. <code>import</code>, <code>from</code> in Python)
@keyword.type           keywords describing namespaces and composite types (e.g. <code>struct</code>, <code>enum</code>)
@keyword.modifier       keywords modifying other constructs (e.g. <code>const</code>, <code>static</code>, <code>public</code>)
@keyword.repeat         keywords related to loops (e.g. <code>for</code>, <code>while</code>)
@keyword.return         keywords like <code>return</code> and <code>yield</code>
@keyword.debug          keywords related to debugging
@keyword.exception      keywords related to exceptions (e.g. <code>throw</code>, <code>catch</code>)</div>
<div class="old-help-para">@keyword.conditional         keywords related to conditionals (e.g. <code>if</code>, <code>else</code>)
@keyword.conditional.ternary ternary operator (e.g. <code>?</code>, <code>:</code>)</div>
<div class="old-help-para">@keyword.directive           various preprocessor directives and shebangs
@keyword.directive.define    preprocessor definition directives</div>
<div class="old-help-para">@punctuation.delimiter  delimiters (e.g. <code>;</code>, <code>.</code>, <code>,</code>)
@punctuation.bracket    brackets (e.g. <code>()</code>, <code>{}</code>, <code>[]</code>)
@punctuation.special    special symbols (e.g. <code>{}</code> in string interpolation)</div>
<div class="old-help-para">@comment                line and block comments
@comment.documentation  comments documenting code</div>
<div class="old-help-para">@comment.error          error-type comments (e.g. <code>ERROR</code>, <code>FIXME</code>, <code>DEPRECATED</code>)
@comment.warning        warning-type comments (e.g. <code>WARNING</code>, <code>FIX</code>, <code>HACK</code>)
@comment.todo           todo-type comments (e.g. <code>TODO</code>, <code>WIP</code>)
@comment.note           note-type comments (e.g. <code>NOTE</code>, <code>INFO</code>, <code>XXX</code>)</div>
<div class="old-help-para">@markup.strong          bold text
@markup.italic          italic text
@markup.strikethrough   struck-through text
@markup.underline       underlined text (only for literal underline markup!)</div>
<div class="old-help-para">@markup.heading         headings, titles (including markers)
@markup.heading.1       top-level heading
@markup.heading.2       section heading
@markup.heading.3       subsection heading
@markup.heading.4       and so on
@markup.heading.5       and so forth
@markup.heading.6       six levels ought to be enough for anybody</div>
<div class="old-help-para">@markup.quote           block quotes
@markup.math            math environments (e.g. <code>$ ... $</code> in LaTeX)</div>
<div class="old-help-para">@markup.link            text references, footnotes, citations, etc.
@markup.link.label      link, reference descriptions
@markup.link.url        URL-style links</div>
<div class="old-help-para">@markup.raw             literal or verbatim text (e.g. inline code)
@markup.raw.block       literal or verbatim text as a stand-alone block</div>
<div class="old-help-para">@markup.list            list markers
@markup.list.checked    checked todo-style list markers
@markup.list.unchecked  unchecked todo-style list markers</div>
<div class="old-help-para">@diff.plus              added text (for diff files)
@diff.minus             deleted text (for diff files)
@diff.delta             changed text (for diff files)</div>
<div class="old-help-para">@tag                    XML-style tag names (e.g. in XML, HTML, etc.)
@tag.builtin            builtin tag names (e.g. HTML5 tags)
@tag.attribute          XML-style tag attributes
@tag.delimiter          XML-style tag delimiters</div>
<div class="old-help-para">                                                  <span id="treesitter-highlight-spell" class="help-tag-right"><a href="#treesitter-highlight-spell">treesitter-highlight-spell</a></span><br>
The special <code>@spell</code> capture can be used to indicate that a node should be
spell checked by Nvim's builtin <a href="spell.html#spell">spell</a> checker. For example, the following
capture marks comments as to be checked:<pre><code class="language-query">(comment) @spell</code></pre></div>
<div class="old-help-para">There is also <code>@nospell</code> which disables spellchecking regions with <code>@spell</code>.</div>
<div class="old-help-para">                                                <span id="treesitter-highlight-conceal" class="help-tag-right"><a href="#treesitter-highlight-conceal">treesitter-highlight-conceal</a></span><br>
Treesitter highlighting supports <a href="syntax.html#conceal">conceal</a> via the <code>conceal</code> and <code>conceal_lines</code>
metadata. By convention, nodes to be concealed are captured as <code>@conceal</code>, but
any capture can be used. For example, the following query can be used to hide
code block delimiters in Markdown:<pre><code class="language-query">((fenced_code_block_delimiter) @conceal (#set! conceal ""))</code></pre></div>
<div class="old-help-para">It is also possible to replace a node with a single character, which (unlike
legacy syntax) can be given a custom highlight. For example, the following
(ill-advised) query replaces the <code>!=</code> operator by a Unicode glyph, which is
still highlighted the same as other operators:<pre><code class="language-query">"!=" @operator (#set! conceal "≠")</code></pre></div>
<div class="old-help-para">To conceal an entire line (do not draw it at all), a query with <code>conceal_lines</code>
metadata can be used:<pre><code class="language-query">((comment) @comment @spell
  (#set! conceal_lines ""))</code></pre></div>
<div class="old-help-para">Conceals specified in this way respect <a href="options.html#'conceallevel'">'conceallevel'</a> and <a href="options.html#'concealcursor'">'concealcursor'</a>.</div>
<div class="old-help-para">Note that although you can use any string for <code>conceal</code>, only the first
character will be used:<pre><code class="language-query">; identifiers will be concealed with 'f'.
((identifier) @conceal (#set! conceal "foo"))</code></pre></div>
<div class="old-help-para">                                               <span id="treesitter-highlight-priority" class="help-tag-right"><a href="#treesitter-highlight-priority">treesitter-highlight-priority</a></span><br>
Treesitter uses <a href="api.html#nvim_buf_set_extmark()">nvim_buf_set_extmark()</a> to set highlights with a default
priority of 100. This enables plugins to set a highlighting priority lower or
higher than treesitter. It is also possible to change the priority of an
individual query pattern manually by setting its <code>"priority"</code> metadata
attribute:<pre><code class="language-query">((super_important_node) @superimportant (#set! priority 105))</code></pre></div>
<div class="old-help-para">                                          <span id="treesitter-highlight-commentstring" class="help-tag-right"><a href="#treesitter-highlight-commentstring">treesitter-highlight-commentstring</a></span><br>
Treesitter highlighting supports finer-grained <a href="options.html#'commentstring'">'commentstring'</a>s, used by the
built-in <a href="various.html#commenting">commenting</a> plugin. When the cursor is within a node that sets the
<code>bo.commentstring</code> metadata property (<a href="treesitter.html#treesitter-directive-set%21">treesitter-directive-set!</a>), that
property defines the comment delimiter (where "innermost wins"). This is
useful for languages like <code>JSX</code> that have different comment syntax depending
on the code region, for example:<pre><code class="language-query">((jsx_element) @_tag (#set! @_tag bo.commentstring "{/* %s */}"))</code></pre></div>
<div class="old-help-para">When multiple captures set this metadata over a region, only the innermost
(most specific) one is applied to a given area.</div>
<div class="old-help-para"><h2 id="_treesitter-language-injections" class="help-heading">TREESITTER LANGUAGE INJECTIONS<span class="help-heading-tags">                <span id="treesitter-language-injections" class="help-tag"><a href="#treesitter-language-injections">treesitter-language-injections</a></span></h2></div>
<div class="old-help-para">Note the following information is adapted from:
<a href="https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection">https://tree-sitter.github.io/tree-sitter/3-syntax-highlighting.html#language-injection</a></div>
<div class="old-help-para">Some source files contain code written in multiple different languages.
Examples include:</div>
<div class="old-help-para"><div class="help-li" style=""> HTML files, which can contain JavaScript inside of <code>&lt;script&gt;</code> tags and
      CSS inside of <code>&lt;style&gt;</code> tags
</div><div class="help-li" style=""> ERB files, which contain Ruby inside of <code>&lt;%</code> <code>%&gt;</code> tags, and HTML outside of
      those tags
</div><div class="help-li" style=""> PHP files, which can contain HTML between the <code>&lt;php</code> tags
</div><div class="help-li" style=""> JavaScript files, which contain regular expression syntax within regex
      literals
</div><div class="help-li" style=""> Ruby, which can contain snippets of code inside of heredoc literals,
      where the heredoc delimiter often indicates the language
</div><div class="help-li" style=""> Lua, which can contain snippets of Vimscript inside <a href="lua.html#vim.cmd()">vim.cmd()</a> calls.
</div><div class="help-li" style=""> Vimscript, which can contain snippets of Lua inside <a href="lua.html#%3Alua-heredoc">:lua-heredoc</a>
      blocks.
</div></div>
<div class="old-help-para">All of these examples can be modeled in terms of a parent syntax tree and one
or more injected syntax trees, which reside inside of certain nodes in the
parent tree. The language injection query allows you to specify these
“injections” using the following captures:</div>
<div class="old-help-para"><div class="help-li" style=""> <code>@injection.content</code> - indicates that the captured node should have its
      contents re-parsed using another language. If there are multiple
      <code>@injection.content</code> captures in one pattern, all ranges will be
      collected and parsed as one tree. This allows query authors to create
      "scoped" injections with injection query quantifiers.
</div><div class="help-li" style=""> <code>@injection.language</code> - indicates that the captured node’s text may
      contain the name of a language that should be used to re-parse the
      <code>@injection.content</code>.
</div><div class="help-li" style=""> <code>@injection.filename</code> - indicates that the captured node’s text may
      contain a filename; the corresponding filetype is then looked-up up via
      <a href="lua.html#vim.filetype.match()">vim.filetype.match()</a> and treated as the name of a language that should
      be used to re-parse the <code>@injection.content</code>.
</div></div>
<div class="old-help-para">The language injection behavior can also be configured by some properties
associated with patterns:</div>
<div class="old-help-para"><div class="help-li" style=""> <code>injection.language</code> - can be used to hard-code the name of a specific
    language.
</div><div class="help-li" style=""> <code>injection.combined</code> - indicates that all of the matching nodes in the
    tree should have their content parsed as one nested document.
</div><div class="help-li" style=""> <code>injection.include-children</code> - indicates that the <code>@injection.content</code>
    node's entire text should be re-parsed, including the text of its child
    nodes. By default, child nodes' text will be excluded from the injected
    document.
</div><div class="help-li" style=""> <code>injection.self</code> - indicates that the node's text should be parsed with
      the same language as the node's LanguageTree.
</div><div class="help-li" style=""> <code>injection.parent</code> - indicates that the captured node’s text should
      be parsed with the same language as the node's parent LanguageTree.
</div></div>
<div class="old-help-para">Injection queries are currently run over the entire buffer, which can be slow
for large buffers. To disable injections for, e.g.,  <code>c</code>, just place an
empty <code>queries/c/injections.scm</code> file in your <a href="options.html#'runtimepath'">'runtimepath'</a>.</div>
<div class="old-help-para"><h2 id="_vim.treesitter" class="help-heading">VIM.TREESITTER<span class="help-heading-tags">                                                <span id="lua-treesitter" class="help-tag"><a href="#lua-treesitter">lua-treesitter</a></span></h2></div>
<div class="old-help-para">The remainder of this document is a reference manual for the <code>vim.treesitter</code>
Lua module, which is the main interface for Nvim's treesitter integration.
Most of the following content is automatically generated from the function
documentation.</div>
<div class="old-help-para">                                             <span id="vim.treesitter.language_version" class="help-tag-right"><a href="#vim.treesitter.language_version">vim.treesitter.language_version</a></span><br>
The latest parser ABI version that is supported by the bundled treesitter
library.</div>
<div class="old-help-para">                                     <span id="vim.treesitter.minimum_language_version" class="help-tag-right"><a href="#vim.treesitter.minimum_language_version">vim.treesitter.minimum_language_version</a></span><br>
The earliest parser ABI version that is supported by the bundled treesitter
library.</div>
<div class="old-help-para"><h2 id="_treesitter-trees" class="help-heading">TREESITTER TREES<span class="help-heading-tags">                                    <span id="treesitter-tree" class="help-tag"><a href="#treesitter-tree">treesitter-tree</a></span> <span id="TSTree" class="help-tag"><a href="#TSTree">TSTree</a></span></span></h2></div>
<div class="old-help-para">A "treesitter tree" represents the parsed contents of a buffer, which can be
used to perform further analysis. It is a <a href="luaref.html#userdata">userdata</a> reference to an object
held by the treesitter library.</div>
<div class="old-help-para">An instance <code>TSTree</code> of a treesitter tree supports the following methods.</div>
<div class="old-help-para">TSTree:copy()                                                  <span id="TSTree%3Acopy()" class="help-tag-right"><a href="#TSTree%3Acopy()">TSTree:copy()</a></span><br>
    Returns a copy of the <code>TSTree</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSTree</code>)</div>
<div class="old-help-para">TSTree:root()                                                  <span id="TSTree%3Aroot()" class="help-tag-right"><a href="#TSTree%3Aroot()">TSTree:root()</a></span><br>
    Return the root node of this tree.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode</code>)</div>
<div class="old-help-para"><h2 id="_treesitter-nodes" class="help-heading">TREESITTER NODES<span class="help-heading-tags">                                    <span id="treesitter-node" class="help-tag"><a href="#treesitter-node">treesitter-node</a></span> <span id="TSNode" class="help-tag"><a href="#TSNode">TSNode</a></span></span></h2></div>
<div class="old-help-para">A "treesitter node" represents one specific element of the parsed contents of
a buffer, which can be captured by a |Query| for, e.g., highlighting. It is a
<a href="luaref.html#userdata">userdata</a> reference to an object held by the treesitter library.</div>
<div class="old-help-para">An instance <code>TSNode</code> of a treesitter node supports the following methods.</div>
<div class="old-help-para">TSNode:byte_length()                                    <span id="TSNode%3Abyte_length()" class="help-tag-right"><a href="#TSNode%3Abyte_length()">TSNode:byte_length()</a></span><br>
    Return the number of bytes spanned by this node.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:child(<code>{index}</code>)                                         <span id="TSNode%3Achild()" class="help-tag-right"><a href="#TSNode%3Achild()">TSNode:child()</a></span><br>
    Get the node's child at the given <code>{index}</code>, where zero represents the first
    child.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{index}</code>  (<code>integer</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:child_count()                                    <span id="TSNode%3Achild_count()" class="help-tag-right"><a href="#TSNode%3Achild_count()">TSNode:child_count()</a></span><br>
    Get the node's number of children.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>integer</code>)</div>
<div class="old-help-para">                                              <span id="TSNode%3Achild_with_descendant()" class="help-tag-right"><a href="#TSNode%3Achild_with_descendant()">TSNode:child_with_descendant()</a></span><br>
TSNode:child_with_descendant(<code>{descendant}</code>)
    Get the node's child that contains <code>{descendant}</code> (includes <code>{descendant}</code>).</div>
<div class="old-help-para">    For example, with the following node hierarchy:<pre>a -&gt; b -&gt; c
a:child_with_descendant(c) == b
a:child_with_descendant(b) == b
a:child_with_descendant(a) == nil</pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{descendant}</code>  (<code>TSNode</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">                                               <span id="TSNode%3Adescendant_for_range()" class="help-tag-right"><a href="#TSNode%3Adescendant_for_range()">TSNode:descendant_for_range()</a></span><br>
TSNode:descendant_for_range(<code>{start_row}</code>, <code>{start_col}</code>, <code>{end_row}</code>, <code>{end_col}</code>)
    Get the smallest node within this node that spans the given range of (row,
    column) positions</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{start_row}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{start_col}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{end_row}</code>    (<code>integer</code>)
</div><div class="help-li" style=""> <code>{end_col}</code>    (<code>integer</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:end_()                                                  <span id="TSNode%3Aend_()" class="help-tag-right"><a href="#TSNode%3Aend_()">TSNode:end_()</a></span><br>
    Get the node's end position. Return three values: the row, column and
    total byte count (all zero-based).</div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>integer</code>)
        (<code>integer</code>)
        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:equal(<code>{node}</code>)                                          <span id="TSNode%3Aequal()" class="help-tag-right"><a href="#TSNode%3Aequal()">TSNode:equal()</a></span><br>
    Check if <code>{node}</code> refers to the same node within the same tree.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>  (<code>TSNode</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:extra()                                                <span id="TSNode%3Aextra()" class="help-tag-right"><a href="#TSNode%3Aextra()">TSNode:extra()</a></span><br>
    Check if the node is extra. Extra nodes represent things like comments,
    which are not required by the grammar but can appear anywhere.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:field(<code>{name}</code>)                                          <span id="TSNode%3Afield()" class="help-tag-right"><a href="#TSNode%3Afield()">TSNode:field()</a></span><br>
    Returns a list of all the node's children that have the given field name.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{name}</code>  (<code>string</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode[]</code>)</div>
<div class="old-help-para">TSNode:has_changes()                                    <span id="TSNode%3Ahas_changes()" class="help-tag-right"><a href="#TSNode%3Ahas_changes()">TSNode:has_changes()</a></span><br>
    Check if a syntax node has been edited.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:has_error()                                        <span id="TSNode%3Ahas_error()" class="help-tag-right"><a href="#TSNode%3Ahas_error()">TSNode:has_error()</a></span><br>
    Check if the node is a syntax error or contains any syntax errors.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:id()                                                      <span id="TSNode%3Aid()" class="help-tag-right"><a href="#TSNode%3Aid()">TSNode:id()</a></span><br>
    Get a unique identifier for the node inside its own tree.</div>
<div class="old-help-para">    No guarantees are made about this identifier's internal representation,
    except for being a primitive Lua type with value equality (so not a
    table). Presently it is a (non-printable) string.</div>
<div class="old-help-para"><b>    Note:</b> The <code>id</code> is not guaranteed to be unique for nodes from different
    trees.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para">TSNode:iter_children()                                <span id="TSNode%3Aiter_children()" class="help-tag-right"><a href="#TSNode%3Aiter_children()">TSNode:iter_children()</a></span><br>
    Iterates over all the direct children of <code>{TSNode}</code>, regardless of whether
    they are named or not. Returns the child node plus the eventual field name
    corresponding to this child node.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>fun(): TSNode, string</code>)</div>
<div class="old-help-para">TSNode:missing()                                            <span id="TSNode%3Amissing()" class="help-tag-right"><a href="#TSNode%3Amissing()">TSNode:missing()</a></span><br>
    Check if the node is missing. Missing nodes are inserted by the parser in
    order to recover from certain kinds of syntax errors.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:named()                                                <span id="TSNode%3Anamed()" class="help-tag-right"><a href="#TSNode%3Anamed()">TSNode:named()</a></span><br>
    Check if the node is named. Named nodes correspond to named rules in the
    grammar, whereas anonymous nodes correspond to string literals in the
    grammar.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">TSNode:named_child(<code>{index}</code>)                             <span id="TSNode%3Anamed_child()" class="help-tag-right"><a href="#TSNode%3Anamed_child()">TSNode:named_child()</a></span><br>
    Get the node's named child at the given <code>{index}</code>, where zero represents the
    first named child.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{index}</code>  (<code>integer</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:named_child_count()                        <span id="TSNode%3Anamed_child_count()" class="help-tag-right"><a href="#TSNode%3Anamed_child_count()">TSNode:named_child_count()</a></span><br>
    Get the node's number of named children.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:named_children()                              <span id="TSNode%3Anamed_children()" class="help-tag-right"><a href="#TSNode%3Anamed_children()">TSNode:named_children()</a></span><br>
    Returns a list of the node's named children.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode[]</code>)</div>
<div class="old-help-para">                                         <span id="TSNode%3Anamed_descendant_for_range()" class="help-tag-right"><a href="#TSNode%3Anamed_descendant_for_range()">TSNode:named_descendant_for_range()</a></span><br>
TSNode:named_descendant_for_range(<code>{start_row}</code>, <code>{start_col}</code>, <code>{end_row}</code>,
                                  <code>{end_col}</code>)
    Get the smallest named node within this node that spans the given range of
    (row, column) positions</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{start_row}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{start_col}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{end_row}</code>    (<code>integer</code>)
</div><div class="help-li" style=""> <code>{end_col}</code>    (<code>integer</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:next_named_sibling()                      <span id="TSNode%3Anext_named_sibling()" class="help-tag-right"><a href="#TSNode%3Anext_named_sibling()">TSNode:next_named_sibling()</a></span><br>
    Get the node's next named sibling.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:next_sibling()                                  <span id="TSNode%3Anext_sibling()" class="help-tag-right"><a href="#TSNode%3Anext_sibling()">TSNode:next_sibling()</a></span><br>
    Get the node's next sibling.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:parent()                                              <span id="TSNode%3Aparent()" class="help-tag-right"><a href="#TSNode%3Aparent()">TSNode:parent()</a></span><br>
    Get the node's immediate parent. Prefer <a href="treesitter.html#TSNode%3Achild_with_descendant()">TSNode:child_with_descendant()</a>
    for iterating over the node's ancestors.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:prev_named_sibling()                      <span id="TSNode%3Aprev_named_sibling()" class="help-tag-right"><a href="#TSNode%3Aprev_named_sibling()">TSNode:prev_named_sibling()</a></span><br>
    Get the node's previous named sibling.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:prev_sibling()                                  <span id="TSNode%3Aprev_sibling()" class="help-tag-right"><a href="#TSNode%3Aprev_sibling()">TSNode:prev_sibling()</a></span><br>
    Get the node's previous sibling.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">TSNode:range(<code>{include_bytes}</code>)                                 <span id="TSNode%3Arange()" class="help-tag-right"><a href="#TSNode%3Arange()">TSNode:range()</a></span><br>
    Get the range of the node.</div>
<div class="old-help-para">    Return four or six values:
<div class="help-li" style=""> start row
</div><div class="help-li" style=""> start column
</div><div class="help-li" style=""> start byte (if <code>{include_bytes}</code> is <code>true</code>)
</div><div class="help-li" style=""> end row
</div><div class="help-li" style=""> end column
</div><div class="help-li" style=""> end byte (if <code>{include_bytes}</code> is <code>true</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{include_bytes}</code>  (<code>false?</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Overloads:</div><div class="help-li" style=""> <code>fun(self: TSNode, include_bytes: true): integer, integer, integer, integer, integer, integer</code>
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>integer</code>)
        (<code>integer</code>)
        (<code>integer</code>)
        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:sexpr()                                                <span id="TSNode%3Asexpr()" class="help-tag-right"><a href="#TSNode%3Asexpr()">TSNode:sexpr()</a></span><br>
    Get an S-expression representing the node as a string.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para">TSNode:start()                                                <span id="TSNode%3Astart()" class="help-tag-right"><a href="#TSNode%3Astart()">TSNode:start()</a></span><br>
    Get the node's start position. Return three values: the row, column and
    total byte count (all zero-based).</div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>integer</code>)
        (<code>integer</code>)
        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:symbol()                                              <span id="TSNode%3Asymbol()" class="help-tag-right"><a href="#TSNode%3Asymbol()">TSNode:symbol()</a></span><br>
    Get the node's type as a numerical id.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>integer</code>)</div>
<div class="old-help-para">TSNode:tree()                                                  <span id="TSNode%3Atree()" class="help-tag-right"><a href="#TSNode%3Atree()">TSNode:tree()</a></span><br>
    Get the <a href="treesitter.html#TSTree">TSTree</a> of the node.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSTree</code>)</div>
<div class="old-help-para">TSNode:type()                                                  <span id="TSNode%3Atype()" class="help-tag-right"><a href="#TSNode%3Atype()">TSNode:type()</a></span><br>
    Get the node's type as a string.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para"><h2 id="_lua-module:-vim.treesitter" class="help-heading">Lua module: vim.treesitter<span class="help-heading-tags">                               <span id="lua-treesitter-core" class="help-tag"><a href="#lua-treesitter-core">lua-treesitter-core</a></span></h2></div>
<div class="old-help-para">foldexpr(<code>{lnum}</code>)                                   <span id="vim.treesitter.foldexpr()" class="help-tag-right"><a href="#vim.treesitter.foldexpr()">vim.treesitter.foldexpr()</a></span><br>
    Returns the fold level for <code>{lnum}</code> in the current buffer. Can be set
    directly to <a href="options.html#'foldexpr'">'foldexpr'</a>:<pre><code class="language-lua">vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Attributes:</div>        Since: 0.9.0</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lnum}</code>  (<code>integer?</code>) Line number to calculate fold level for
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para">                                     <span id="vim.treesitter.get_captures_at_cursor()" class="help-tag-right"><a href="#vim.treesitter.get_captures_at_cursor()">vim.treesitter.get_captures_at_cursor()</a></span><br>
get_captures_at_cursor(<code>{winnr}</code>)
    Returns a list of highlight capture names under the cursor</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{winnr}</code>  (<code>integer?</code>) <a href="windows.html#window-ID">window-ID</a> or 0 for current window (default)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string[]</code>) List of capture names</div>
<div class="old-help-para">                                        <span id="vim.treesitter.get_captures_at_pos()" class="help-tag-right"><a href="#vim.treesitter.get_captures_at_pos()">vim.treesitter.get_captures_at_pos()</a></span><br>
get_captures_at_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>)
    Returns a list of highlight captures at the given position</div>
<div class="old-help-para">    Each capture is represented by a table containing the capture name as a
    string, the capture's language, a table of metadata (<code>priority</code>,
    <code>conceal</code>, ...; empty if none are defined), and the id of the capture.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (<code>integer</code>) Buffer number (0 for current buffer)
</div><div class="help-li" style=""> <code>{row}</code>    (<code>integer</code>) Position row
</div><div class="help-li" style=""> <code>{col}</code>    (<code>integer</code>) Position column
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>{capture: string, lang: string, metadata: vim.treesitter.query.TSMetadata, id: integer}[]</code>)</div>
<div class="old-help-para">get_node(<code>{opts}</code>)                                   <span id="vim.treesitter.get_node()" class="help-tag-right"><a href="#vim.treesitter.get_node()">vim.treesitter.get_node()</a></span><br>
    Returns the smallest named node at the given position</div>
<div class="old-help-para"><b>    NOTE:</b> Calling this on an unparsed tree can yield an invalid node. If the
    tree is not known to be parsed by, e.g., an active highlighter, parse the
    tree first via<pre><code class="language-lua">vim.treesitter.get_parser(bufnr):parse(range)</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{bufnr}</code> (<code>integer?</code>) Buffer number (nil or 0 for current
                  buffer)
</div><div class="help-li" style="margin-left: 3rem;"> <code>{pos}</code> (<code>[integer, integer]?</code>) 0-indexed (row, col) tuple.
                  Defaults to cursor position in the current window. Required
                  if <code>{bufnr}</code> is not the current buffer
</div><div class="help-li" style="margin-left: 3rem;"> <code>{lang}</code> (<code>string?</code>) Parser language. (default: from buffer
                  filetype)
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_injections}</code> (<code>boolean?</code>) Ignore injected languages
                  (default true)
</div><div class="help-li" style="margin-left: 3rem;"> <code>{include_anonymous}</code> (<code>boolean?</code>) Include anonymous nodes
                  (default false)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>) Node at the given position</div>
<div class="old-help-para">get_node_range(<code>{node_or_range}</code>)              <span id="vim.treesitter.get_node_range()" class="help-tag-right"><a href="#vim.treesitter.get_node_range()">vim.treesitter.get_node_range()</a></span><br>
    Returns the node's range or an unpacked range table</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node_or_range}</code>  (<code>TSNode|Range4</code>) Node or table of positions
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>integer</code>) start_row
        (<code>integer</code>) start_col (byte offset)
        (<code>integer</code>) end_row
        (<code>integer</code>) end_col (byte offset)</div>
<div class="old-help-para">                                              <span id="vim.treesitter.get_node_text()" class="help-tag-right"><a href="#vim.treesitter.get_node_text()">vim.treesitter.get_node_text()</a></span><br>
get_node_text(<code>{node}</code>, <code>{source}</code>, <code>{opts}</code>)
    Gets the text corresponding to a given node</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>    (<code>TSNode</code>)
</div><div class="help-li" style=""> <code>{source}</code>  (<code>integer|string</code>) Buffer or string from which the <code>{node}</code> is
                  extracted
</div><div class="help-li" style=""> <code>{opts}</code>    (<code>table?</code>) Optional parameters.
</div><div class="help-li" style="margin-left: 3rem;"> metadata (table) Metadata of a specific capture. This
                    would be set to <code>metadata[capture_id]</code> when using
                    <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a>.
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para">get_parser(<code>{bufnr}</code>, <code>{lang}</code>, <code>{opts}</code>)              <span id="vim.treesitter.get_parser()" class="help-tag-right"><a href="#vim.treesitter.get_parser()">vim.treesitter.get_parser()</a></span><br>
    Returns the parser for a specific buffer and attaches it to the buffer</div>
<div class="old-help-para">    If needed, this will create the parser.</div>
<div class="old-help-para">    If no parser can be created, an error is thrown. Set <code>opts.error = false</code>
    to suppress this and return nil (and an error message) instead.<b> WARNING:</b>
    This behavior will become default in Nvim 0.12 and the option will be
    removed.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (<code>integer?</code>) Buffer the parser should be tied to (default:
                 current buffer)
</div><div class="help-li" style=""> <code>{lang}</code>   (<code>string?</code>) Language of this parser (default: from buffer
                 filetype)
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Options to pass to the created language tree
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>vim.treesitter.LanguageTree?</code>) object to use for parsing
        (<code>string?</code>) error message, if applicable</div>
<div class="old-help-para">get_range(<code>{node}</code>, <code>{source}</code>, <code>{metadata}</code>)           <span id="vim.treesitter.get_range()" class="help-tag-right"><a href="#vim.treesitter.get_range()">vim.treesitter.get_range()</a></span><br>
    Get the range of a <a href="treesitter.html#TSNode">TSNode</a>. Can also supply <code>{source}</code> and <code>{metadata}</code> to
    get the range with directives applied.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>      (<code>TSNode</code>)
</div><div class="help-li" style=""> <code>{source}</code>    (<code>integer|string?</code>) Buffer or string from which the <code>{node}</code>
                    is extracted
</div><div class="help-li" style=""> <code>{metadata}</code>  (<code>vim.treesitter.query.TSMetadata?</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>table</code>) A table with the following fields:
<div class="help-li" style=""> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style=""> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style=""> <code>{[3]}</code> (<code>integer</code>) start bytes
</div><div class="help-li" style=""> <code>{[4]}</code> (<code>integer</code>) end row
</div><div class="help-li" style=""> <code>{[5]}</code> (<code>integer</code>) end column
</div><div class="help-li" style=""> <code>{[6]}</code> (<code>integer</code>) end bytes
</div></div>
<div class="old-help-para">                                          <span id="vim.treesitter.get_string_parser()" class="help-tag-right"><a href="#vim.treesitter.get_string_parser()">vim.treesitter.get_string_parser()</a></span><br>
get_string_parser(<code>{str}</code>, <code>{lang}</code>, <code>{opts}</code>)
    Returns a string parser</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{str}</code>   (<code>string</code>) Text to parse
</div><div class="help-li" style=""> <code>{lang}</code>  (<code>string</code>) Language of this string
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Options to pass to the created language tree
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>vim.treesitter.LanguageTree</code>) object to use for parsing</div>
<div class="old-help-para">inspect_tree(<code>{opts}</code>)                           <span id="vim.treesitter.inspect_tree()" class="help-tag-right"><a href="#vim.treesitter.inspect_tree()">vim.treesitter.inspect_tree()</a></span><br>
    Open a window that displays a textual representation of the nodes in the
    language tree.</div>
<div class="old-help-para">    While in the window, press "a" to toggle display of anonymous nodes, "I"
    to toggle the display of the source language of each node, "o" to toggle
    the query editor, and press <code>&lt;Enter&gt;</code> to jump to the node under the cursor
    in the source buffer. Folding also works (try <a href="fold.html#zo">zo</a>, <a href="fold.html#zc">zc</a>, etc.).</div>
<div class="old-help-para">    Can also be shown with <code>:InspectTree</code>.                      <span id="%3AInspectTree" class="help-tag-right"><a href="#%3AInspectTree">:InspectTree</a></span><br></div>
<div class="old-help-para"><div class="help-column_heading">Attributes:</div>        Since: 0.9.0</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional options table with the following possible
                keys:
</div><div class="help-li" style="margin-left: 3rem;"> lang (string|nil): The language of the source buffer. If
                  omitted, detect from the filetype of the source buffer.
</div><div class="help-li" style="margin-left: 3rem;"> bufnr (integer|nil): Buffer to draw the tree into. If
                  omitted, a new buffer is created.
</div><div class="help-li" style="margin-left: 3rem;"> winid (integer|nil): Window id to display the tree buffer
                  in. If omitted, a new window is created with <code>{command}</code>.
</div><div class="help-li" style="margin-left: 3rem;"> command (string|nil): Vimscript command to create the
                  window. Default value is "60vnew". Only used when <code>{winid}</code> is
                  nil.
</div><div class="help-li" style="margin-left: 3rem;"> title (string|fun(bufnr:integer):string|nil): Title of the
                  window. If a function, it accepts the buffer number of the
                  source buffer as its only argument and should return a
                  string.
</div></div>
<div class="old-help-para">is_ancestor(<code>{dest}</code>, <code>{source}</code>)                   <span id="vim.treesitter.is_ancestor()" class="help-tag-right"><a href="#vim.treesitter.is_ancestor()">vim.treesitter.is_ancestor()</a></span><br>
    Determines whether a node is the ancestor of another</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{dest}</code>    (<code>TSNode</code>) Possible ancestor
</div><div class="help-li" style=""> <code>{source}</code>  (<code>TSNode</code>) Possible descendant
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>) True if <code>{dest}</code> is an ancestor of <code>{source}</code></div>
<div class="old-help-para">                                           <span id="vim.treesitter.is_in_node_range()" class="help-tag-right"><a href="#vim.treesitter.is_in_node_range()">vim.treesitter.is_in_node_range()</a></span><br>
is_in_node_range(<code>{node}</code>, <code>{line}</code>, <code>{col}</code>)
    Determines whether (line, col) position is in node range</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>  (<code>TSNode</code>) defining the range
</div><div class="help-li" style=""> <code>{line}</code>  (<code>integer</code>) Line (0-based)
</div><div class="help-li" style=""> <code>{col}</code>   (<code>integer</code>) Column (0-based)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>) True if the position is in node range</div>
<div class="old-help-para">node_contains(<code>{node}</code>, <code>{range}</code>)                <span id="vim.treesitter.node_contains()" class="help-tag-right"><a href="#vim.treesitter.node_contains()">vim.treesitter.node_contains()</a></span><br>
    Determines if a node contains a range</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>   (<code>TSNode</code>)
</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>) True if the <code>{node}</code> contains the <code>{range}</code></div>
<div class="old-help-para">start(<code>{bufnr}</code>, <code>{lang}</code>)                                <span id="vim.treesitter.start()" class="help-tag-right"><a href="#vim.treesitter.start()">vim.treesitter.start()</a></span><br>
    Starts treesitter highlighting for a buffer</div>
<div class="old-help-para">    Can be used in an ftplugin or FileType autocommand.</div>
<div class="old-help-para"><b>    Note:</b> By default, disables regex syntax highlighting, which may be
    required for some plugins. In this case, add <code>vim.bo.syntax = 'ON'</code> after
    the call to <code>start</code>.</div>
<div class="old-help-para"><b>    Note:</b> By default, the highlighter parses code asynchronously, using a
    segment time of 3ms.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">vim.api.nvim_create_autocmd( 'FileType', { pattern = 'tex',
    callback = function(args)
        vim.treesitter.start(args.buf, 'latex')
        vim.bo[args.buf].syntax = 'ON'  -- only if additional legacy syntax is needed
    end
})</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (<code>integer?</code>) Buffer to be highlighted (default: current
                 buffer)
</div><div class="help-li" style=""> <code>{lang}</code>   (<code>string?</code>) Language of the parser (default: from buffer
                 filetype)
</div></div>
<div class="old-help-para">stop(<code>{bufnr}</code>)                                          <span id="vim.treesitter.stop()" class="help-tag-right"><a href="#vim.treesitter.stop()">vim.treesitter.stop()</a></span><br>
    Stops treesitter highlighting for a buffer</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (<code>integer?</code>) Buffer to stop highlighting (default: current
                 buffer)
</div></div>
<div class="old-help-para"><h2 id="_lua-module:-vim.treesitter.language" class="help-heading">Lua module: vim.treesitter.language<span class="help-heading-tags">                      <span id="treesitter-language" class="help-tag"><a href="#treesitter-language">treesitter-language</a></span></h2></div>
<div class="old-help-para">add(<code>{lang}</code>, <code>{opts}</code>)                            <span id="vim.treesitter.language.add()" class="help-tag-right"><a href="#vim.treesitter.language.add()">vim.treesitter.language.add()</a></span><br>
    Load parser with name <code>{lang}</code></div>
<div class="old-help-para">    Parsers are searched in the <code>parser</code> runtime directory, or the provided
    <code>{path}</code>. Can be used to check for available parsers before enabling
    treesitter features, e.g.,<pre><code class="language-lua">if vim.treesitter.language.add('markdown') then
  vim.treesitter.start(bufnr, 'markdown')
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (<code>string</code>) Name of the parser (alphanumerical and <code>_</code> only)
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Options:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{path}?</code> (<code>string</code>) Optional path the parser is located at
</div><div class="help-li" style="margin-left: 3rem;"> <code>{symbol_name}?</code> (<code>string</code>) Internal symbol name for the
                  language to load
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return (multiple):</div>        (<code>boolean?</code>) True if parser is loaded
        (<code>string?</code>) Error if parser cannot be loaded</div>
<div class="old-help-para">get_filetypes(<code>{lang}</code>)                <span id="vim.treesitter.language.get_filetypes()" class="help-tag-right"><a href="#vim.treesitter.language.get_filetypes()">vim.treesitter.language.get_filetypes()</a></span><br>
    Returns the filetypes for which a parser named <code>{lang}</code> is used.</div>
<div class="old-help-para">    The list includes <code>{lang}</code> itself plus all filetypes registered via
    <a href="treesitter.html#vim.treesitter.language.register()">vim.treesitter.language.register()</a>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (<code>string</code>) Name of parser
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string[]</code>) filetypes</div>
<div class="old-help-para">get_lang(<code>{filetype}</code>)                      <span id="vim.treesitter.language.get_lang()" class="help-tag-right"><a href="#vim.treesitter.language.get_lang()">vim.treesitter.language.get_lang()</a></span><br>
    Returns the language name to be used when loading a parser for <code>{filetype}</code>.</div>
<div class="old-help-para">    If no language has been explicitly registered via
    <a href="treesitter.html#vim.treesitter.language.register()">vim.treesitter.language.register()</a>, default to <code>{filetype}</code>. For composite
    filetypes like <code>html.glimmer</code>, only the main filetype is returned.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{filetype}</code>  (<code>string</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string?</code>)</div>
<div class="old-help-para">inspect(<code>{lang}</code>)                            <span id="vim.treesitter.language.inspect()" class="help-tag-right"><a href="#vim.treesitter.language.inspect()">vim.treesitter.language.inspect()</a></span><br>
    Inspects the provided language.</div>
<div class="old-help-para">    Inspecting provides some useful information on the language like ABI
    version, parser state count (a measure of parser complexity), node and
    field names, and whether the language came from a WASM module.</div>
<div class="old-help-para">    Node names are returned in a table mapping each node name to a <code>boolean</code>
    indicating whether or not the node is named (i.e., not anonymous).
    Anonymous nodes are surrounded with double quotes (<code>"</code>).</div>
<div class="old-help-para">    For ABI 15 parsers, also show parser metadata (major, minor, patch
    version) and a table of supertypes with their respective subtypes.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (<code>string</code>) Language
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSLangInfo</code>)</div>
<div class="old-help-para">register(<code>{lang}</code>, <code>{filetype}</code>)              <span id="vim.treesitter.language.register()" class="help-tag-right"><a href="#vim.treesitter.language.register()">vim.treesitter.language.register()</a></span><br>
    Register a parser named <code>{lang}</code> to be used for <code>{filetype}</code>(s).</div>
<div class="old-help-para"><b>    Note:</b> this adds or overrides the mapping for <code>{filetype}</code>, any existing
    mappings from other filetypes to <code>{lang}</code> will be preserved.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>      (<code>string</code>) Name of parser
</div><div class="help-li" style=""> <code>{filetype}</code>  (<code>string|string[]</code>) Filetype(s) to associate with lang
</div></div>
<div class="old-help-para"><h2 id="_lua-module:-vim.treesitter.languagetree" class="help-heading">Lua module: vim.treesitter.languagetree<span class="help-heading-tags">              <span id="treesitter-languagetree" class="help-tag"><a href="#treesitter-languagetree">treesitter-languagetree</a></span></h2></div>
<div class="old-help-para">A <span id="LanguageTree" class="help-tag"><a href="#LanguageTree">LanguageTree</a></span> contains a tree of parsers: the root treesitter parser for
<code>{lang}</code> and any "injected" language parsers, which themselves may inject other
languages, recursively. For example a Lua buffer containing some Vimscript
commands needs multiple parsers to fully understand its contents.</div>
<div class="old-help-para">To create a LanguageTree (parser object) for a given buffer and language, use:<pre><code class="language-lua">local parser = vim.treesitter.get_parser(bufnr, lang)</code></pre></div>
<div class="old-help-para">(where <code>bufnr=0</code> means current buffer). <code>lang</code> defaults to <a href="options.html#'filetype'">'filetype'</a>.<b> Note:</b>
currently the parser is retained for the lifetime of a buffer but this may
change; a plugin should keep a reference to the parser object if it wants
incremental updates.</div>
<div class="old-help-para">Whenever you need to access the current syntax tree, parse the buffer:<pre><code class="language-lua">local tree = parser:parse({ start_row, end_row })</code></pre></div>
<div class="old-help-para">This returns a table of immutable <a href="treesitter.html#treesitter-tree">treesitter-tree</a> objects representing the
current state of the buffer. When the plugin wants to access the state after a
(possible) edit it must call <code>parse()</code> again. If the buffer wasn't edited, the
same tree will be returned again without extra work. If the buffer was parsed
before, incremental parsing will be done of the changed parts.</div>
<div class="old-help-para"><b>Note:</b> To use the parser directly inside a <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a> Lua callback,
you must call <a href="treesitter.html#vim.treesitter.get_parser()">vim.treesitter.get_parser()</a> before you register your callback.
But preferably parsing shouldn't be done directly in the change callback
anyway as they will be very frequent. Rather a plugin that does any kind of
analysis on a tree should use a timer to throttle too frequent updates.</div>
<div class="old-help-para">LanguageTree:children()                              <span id="LanguageTree%3Achildren()" class="help-tag-right"><a href="#LanguageTree%3Achildren()">LanguageTree:children()</a></span><br>
    Returns a map of language to child tree.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>table&lt;string,vim.treesitter.LanguageTree&gt;</code>)</div>
<div class="old-help-para">LanguageTree:contains(<code>{range}</code>)                       <span id="LanguageTree%3Acontains()" class="help-tag-right"><a href="#LanguageTree%3Acontains()">LanguageTree:contains()</a></span><br>
    Determines whether <code>{range}</code> is contained in the <a href="treesitter.html#LanguageTree">LanguageTree</a>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[3]}</code> (<code>integer</code>) end row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[4]}</code> (<code>integer</code>) end column
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">LanguageTree:destroy()                                <span id="LanguageTree%3Adestroy()" class="help-tag-right"><a href="#LanguageTree%3Adestroy()">LanguageTree:destroy()</a></span><br>
    Destroys this <a href="treesitter.html#LanguageTree">LanguageTree</a> and all its children.</div>
<div class="old-help-para">    Any cleanup logic should be performed here.</div>
<div class="old-help-para"><b>    Note:</b> This DOES NOT remove this tree from a parent. Instead,
    <code>remove_child</code> must be called on the parent to remove it.</div>
<div class="old-help-para">LanguageTree:for_each_tree(<code>{fn}</code>)                <span id="LanguageTree%3Afor_each_tree()" class="help-tag-right"><a href="#LanguageTree%3Afor_each_tree()">LanguageTree:for_each_tree()</a></span><br>
    Invokes the callback for each <a href="treesitter.html#LanguageTree">LanguageTree</a> recursively.</div>
<div class="old-help-para"><b>    Note:</b> This includes the invoking tree's child trees as well.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{fn}</code>  (<code>fun(tree: TSTree, ltree: vim.treesitter.LanguageTree)</code>)
</div></div>
<div class="old-help-para">LanguageTree:included_regions()              <span id="LanguageTree%3Aincluded_regions()" class="help-tag-right"><a href="#LanguageTree%3Aincluded_regions()">LanguageTree:included_regions()</a></span><br>
    Gets the set of included regions managed by this LanguageTree. This can be
    different from the regions set by injection query, because a partial
    <a href="treesitter.html#LanguageTree%3Aparse()">LanguageTree:parse()</a> drops the regions outside the requested range. Each
    list represents a range in the form of { <code>{start_row}</code>, <code>{start_col}</code>,
    <code>{start_bytes}</code>, <code>{end_row}</code>, <code>{end_col}</code>, <code>{end_bytes}</code> }.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>table&lt;integer, Range6[]&gt;</code>)</div>
<div class="old-help-para">LanguageTree:invalidate(<code>{reload}</code>)                  <span id="LanguageTree%3Ainvalidate()" class="help-tag-right"><a href="#LanguageTree%3Ainvalidate()">LanguageTree:invalidate()</a></span><br>
    Invalidates this parser and its children.</div>
<div class="old-help-para">    Should only be called when the tracked state of the LanguageTree is not
    valid against the parse tree in treesitter. Doesn't clear filesystem
    cache. Called often, so needs to be fast.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{reload}</code>  (<code>boolean?</code>)
</div></div>
<div class="old-help-para">                                                     <span id="LanguageTree%3Ais_valid()" class="help-tag-right"><a href="#LanguageTree%3Ais_valid()">LanguageTree:is_valid()</a></span><br>
LanguageTree:is_valid(<code>{exclude_children}</code>, <code>{range}</code>)
    Returns whether this LanguageTree is valid, i.e., <a href="treesitter.html#LanguageTree%3Atrees()">LanguageTree:trees()</a>
    reflects the latest state of the source. If invalid, user should call
    <a href="treesitter.html#LanguageTree%3Aparse()">LanguageTree:parse()</a>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{exclude_children}</code>  (<code>boolean?</code>) whether to ignore the validity of
                            children (default <code>false</code>)
</div><div class="help-li" style=""> <code>{range}</code>             (<code>Range|Range[]?</code>) range (or list of ranges,
                            sorted by starting point in ascending order) to
                            check for validity
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>boolean</code>)</div>
<div class="old-help-para">LanguageTree:lang()                                      <span id="LanguageTree%3Alang()" class="help-tag-right"><a href="#LanguageTree%3Alang()">LanguageTree:lang()</a></span><br>
    Gets the language of this tree node.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string</code>)</div>
<div class="old-help-para">                                           <span id="LanguageTree%3Alanguage_for_range()" class="help-tag-right"><a href="#LanguageTree%3Alanguage_for_range()">LanguageTree:language_for_range()</a></span><br>
LanguageTree:language_for_range(<code>{range}</code>)
    Gets the appropriate language that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[3]}</code> (<code>integer</code>) end row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[4]}</code> (<code>integer</code>) end column
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>vim.treesitter.LanguageTree</code>) tree Managing <code>{range}</code></div>
<div class="old-help-para">                                         <span id="LanguageTree%3Anamed_node_for_range()" class="help-tag-right"><a href="#LanguageTree%3Anamed_node_for_range()">LanguageTree:named_node_for_range()</a></span><br>
LanguageTree:named_node_for_range(<code>{range}</code>, <code>{opts}</code>)
    Gets the smallest named node that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[3]}</code> (<code>integer</code>) end row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[4]}</code> (<code>integer</code>) end column
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_injections}?</code> (<code>boolean</code>, default: <code>true</code>) Ignore
                   injected languages
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">                                               <span id="LanguageTree%3Anode_for_range()" class="help-tag-right"><a href="#LanguageTree%3Anode_for_range()">LanguageTree:node_for_range()</a></span><br>
LanguageTree:node_for_range(<code>{range}</code>, <code>{opts}</code>)
    Gets the smallest node that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[3]}</code> (<code>integer</code>) end row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[4]}</code> (<code>integer</code>) end column
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_injections}?</code> (<code>boolean</code>, default: <code>true</code>) Ignore
                   injected languages
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSNode?</code>)</div>
<div class="old-help-para">LanguageTree:parent()                                  <span id="LanguageTree%3Aparent()" class="help-tag-right"><a href="#LanguageTree%3Aparent()">LanguageTree:parent()</a></span><br>
    Returns the parent tree. <code>nil</code> for the root tree.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>vim.treesitter.LanguageTree?</code>)</div>
<div class="old-help-para">LanguageTree:parse(<code>{range}</code>, <code>{on_parse}</code>)                 <span id="LanguageTree%3Aparse()" class="help-tag-right"><a href="#LanguageTree%3Aparse()">LanguageTree:parse()</a></span><br>
    Recursively parse all regions in the language tree using
    <a href="treesitter.html#treesitter-parsers">treesitter-parsers</a> for the corresponding languages and run injection
    queries on the parsed trees to determine whether child trees should be
    created and parsed.</div>
<div class="old-help-para">    Any region with empty range (<code>{}</code>, typically only the root tree) is always
    parsed; otherwise (typically injections) only if it intersects <code>{range}</code> (or
    if <code>{range}</code> is <code>true</code>).</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>     (<code>boolean|Range|Range[]?</code>) Parse this range (or list of
                    ranges, sorted by starting point in ascending order) in
                    the parser's source. Set to <code>true</code> to run a complete parse
                    of the source (<b>Note:</b> Can be slow!) Set to <code>false|nil</code> to
                    only parse regions with empty ranges (typically only the
                    root tree without injections).
</div><div class="help-li" style=""> <code>{on_parse}</code>  (<code>fun(err?: string, trees?: table&lt;integer, TSTree&gt;)?</code>)
                    Function invoked when parsing completes. When provided and
                    <code>vim.g._ts_force_sync_parsing</code> is not set, parsing will
                    run asynchronously. The first argument to the function is
                    a string representing the error type, in case of a failure
                    (currently only possible for timeouts). The second
                    argument is the list of trees returned by the parse (upon
                    success), or <code>nil</code> if the parse timed out (determined by
                    <a href="options.html#'redrawtime'">'redrawtime'</a>).
</div></div>
<div class="old-help-para">                    If parsing was still able to finish synchronously (within
                    3ms), <code>parse()</code> returns the list of trees. Otherwise, it
                    returns <code>nil</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>table&lt;integer, TSTree&gt;?</code>)</div>
<div class="old-help-para">                                                 <span id="LanguageTree%3Aregister_cbs()" class="help-tag-right"><a href="#LanguageTree%3Aregister_cbs()">LanguageTree:register_cbs()</a></span><br>
LanguageTree:register_cbs(<code>{cbs}</code>, <code>{recursive}</code>)
    Registers callbacks for the <a href="treesitter.html#LanguageTree">LanguageTree</a>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{cbs}</code>        (<code>table&lt;TSCallbackNameOn,function&gt;</code>) An
                     <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a>-like table argument with the
                     following handlers:
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_bytes</code> : see <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_changedtree</code> : a callback that will be called every
                       time the tree has syntactical changes. It will be
                       passed two arguments: a table of the ranges (as node
                       ranges) that changed and the changed tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_child_added</code> : emitted when a child is added to the
                       tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_child_removed</code> : emitted when a child is removed
                       from the tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_detach</code> : emitted when the buffer is detached, see
                       <a href="api.html#nvim_buf_detach_event">nvim_buf_detach_event</a>. Takes one argument, the number
                       of the buffer.
</div><div class="help-li" style=""> <code>{recursive}</code>  (<code>boolean?</code>) Apply callbacks recursively for all
                     children. Any new children will also inherit the
                     callbacks.
</div></div>
<div class="old-help-para">LanguageTree:source()                                  <span id="LanguageTree%3Asource()" class="help-tag-right"><a href="#LanguageTree%3Asource()">LanguageTree:source()</a></span><br>
    Returns the source content of the language tree (bufnr or string).</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>integer|string</code>)</div>
<div class="old-help-para">                                               <span id="LanguageTree%3Atree_for_range()" class="help-tag-right"><a href="#LanguageTree%3Atree_for_range()">LanguageTree:tree_for_range()</a></span><br>
LanguageTree:tree_for_range(<code>{range}</code>, <code>{opts}</code>)
    Gets the tree that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[1]}</code> (<code>integer</code>) start row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[2]}</code> (<code>integer</code>) start column
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[3]}</code> (<code>integer</code>) end row
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[4]}</code> (<code>integer</code>) end column
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_injections}?</code> (<code>boolean</code>, default: <code>true</code>) Ignore
                   injected languages
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>TSTree?</code>)</div>
<div class="old-help-para">LanguageTree:trees()                                    <span id="LanguageTree%3Atrees()" class="help-tag-right"><a href="#LanguageTree%3Atrees()">LanguageTree:trees()</a></span><br>
    Returns all trees of the regions parsed by this parser. Does not include
    child languages. The result is list-like if
<div class="help-li" style=""> this LanguageTree is the root, in which case the result is empty or a
      singleton list; or
</div><div class="help-li" style=""> the root LanguageTree is fully parsed.
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>table&lt;integer, TSTree&gt;</code>)</div>
<div class="old-help-para"><h2 id="_lua-module:-vim.treesitter.query" class="help-heading">Lua module: vim.treesitter.query<span class="help-heading-tags">                        <span id="lua-treesitter-query" class="help-tag"><a href="#lua-treesitter-query">lua-treesitter-query</a></span></h2></div>
<div class="old-help-para">This Lua <a href="treesitter.html#treesitter-query">treesitter-query</a> interface allows you to create queries and use
them to parse text. See <a href="treesitter.html#vim.treesitter.query.parse()">vim.treesitter.query.parse()</a> for a working example.</div>
<div class="old-help-para"><span id="vim.treesitter.Query" class="help-tag"><a href="#vim.treesitter.Query">vim.treesitter.Query</a></span>
    Parsed query, see <a href="treesitter.html#vim.treesitter.query.parse()">vim.treesitter.query.parse()</a></div>
<div class="old-help-para"><div class="help-column_heading">Fields:</div><div class="help-li" style=""> <code>{lang}</code>                     (<code>string</code>) parser language name
</div><div class="help-li" style=""> <code>{captures}</code>                 (<code>string[]</code>) list of (unique) capture names
                                   defined in query
</div><div class="help-li" style=""> <code>{info}</code>                     (<code>vim.treesitter.QueryInfo</code>) query context
                                   (e.g. captures, predicates, directives)
</div><div class="help-li" style=""> <code>{has_conceal_line}</code>         (<code>boolean</code>) whether the query sets
                                   conceal_lines metadata
</div><div class="help-li" style=""> <code>{has_combined_injections}</code>  (<code>boolean</code>) whether the query contains
                                   combined injections
</div><div class="help-li" style=""> <code>{query}</code>                    (<code>TSQuery</code>) userdata query object
</div><div class="help-li" style=""> <code>{iter_captures}</code>            (<code>fun(self: vim.treesitter.Query, node: TSNode, source: integer|string, start_row: integer?, end_row: integer?, opts: table?): fun(end_line: integer?, end_col: integer?): integer, TSNode, vim.treesitter.query.TSMetadata, TSQueryMatch, TSTree</code>)
                                   See <a href="treesitter.html#Query%3Aiter_captures()">Query:iter_captures()</a>.
</div><div class="help-li" style=""> <code>{iter_matches}</code>             (<code>fun(self: vim.treesitter.Query, node: TSNode, source: integer|string, start: integer?, stop: integer?, opts: table?): fun(): integer, table&lt;integer, TSNode[]&gt;, vim.treesitter.query.TSMetadata, TSTree</code>)
                                   See <a href="treesitter.html#Query%3Aiter_matches()">Query:iter_matches()</a>.
</div></div>
<div class="old-help-para">                                        <span id="vim.treesitter.query.add_directive()" class="help-tag-right"><a href="#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a></span><br>
add_directive(<code>{name}</code>, <code>{handler}</code>, <code>{opts}</code>)
    Adds a new directive to be used in queries</div>
<div class="old-help-para">    Handlers can set match level data by setting directly on the metadata
    object <code>metadata.key = value</code>. Additionally, handlers can set node level
    data by using the capture id on the metadata table
    <code>metadata[capture_id].key = value</code></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{name}</code>     (<code>string</code>) Name of the directive, without leading #
</div><div class="help-li" style=""> <code>{handler}</code>  (<code>fun(match: table&lt;integer,TSNode[]&gt;, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata)</code>)
</div><div class="help-li" style="margin-left: 3rem;"> match: A table mapping capture IDs to a list of captured
                     nodes
</div><div class="help-li" style="margin-left: 3rem;"> pattern: the index of the matching pattern in the query
                     file
</div><div class="help-li" style="margin-left: 3rem;"> predicate: list of strings containing the full directive
                     being called, e.g. <code>(node (#set! conceal "-"))</code> would get
                     the predicate <code>{ "#set!", "conceal", "-" }</code>
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{force}?</code> (<code>boolean</code>) Override an existing predicate of
                     the same name
</div><div class="help-li" style="margin-left: 3rem;"> <code>{all}?</code> (<code>boolean</code>) Use the correct implementation of the
                     match table where capture IDs map to a list of nodes
                     instead of a single node. Defaults to true. This option
                     will be removed in a future release.
</div></div>
<div class="old-help-para">                                        <span id="vim.treesitter.query.add_predicate()" class="help-tag-right"><a href="#vim.treesitter.query.add_predicate()">vim.treesitter.query.add_predicate()</a></span><br>
add_predicate(<code>{name}</code>, <code>{handler}</code>, <code>{opts}</code>)
    Adds a new predicate to be used in queries</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{name}</code>     (<code>string</code>) Name of the predicate, without leading #
</div><div class="help-li" style=""> <code>{handler}</code>  (<code>fun(match: table&lt;integer,TSNode[]&gt;, pattern: integer, source: integer|string, predicate: any[], metadata: vim.treesitter.query.TSMetadata): boolean?</code>)
</div><div class="help-li" style="margin-left: 3rem;"> see <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a> for argument
                     meanings
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{force}?</code> (<code>boolean</code>) Override an existing predicate of
                     the same name
</div><div class="help-li" style="margin-left: 3rem;"> <code>{all}?</code> (<code>boolean</code>) Use the correct implementation of the
                     match table where capture IDs map to a list of nodes
                     instead of a single node. Defaults to true. This option
                     will be removed in a future release.
</div></div>
<div class="old-help-para">edit(<code>{lang}</code>)                                     <span id="vim.treesitter.query.edit()" class="help-tag-right"><a href="#vim.treesitter.query.edit()">vim.treesitter.query.edit()</a></span><br>
    Opens a live editor to query the buffer you started from.</div>
<div class="old-help-para">    Can also be shown with the <span id="%3AEditQuery" class="help-tag"><a href="#%3AEditQuery">:EditQuery</a></span> command. <code>:EditQuery &lt;tab&gt;</code>
    completes available parsers.</div>
<div class="old-help-para">    If you move the cursor to a capture name ("@foo"), text matching the
    capture is highlighted in the source buffer. The query editor is a scratch
    buffer, use <code>:write</code> to save it. You can find example queries at
    <code>$VIMRUNTIME/queries/</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (<code>string?</code>) language to open the query editor for. If omitted,
                inferred from the current buffer's filetype.
</div></div>
<div class="old-help-para">get(<code>{lang}</code>, <code>{query_name}</code>)                         <span id="vim.treesitter.query.get()" class="help-tag-right"><a href="#vim.treesitter.query.get()">vim.treesitter.query.get()</a></span><br>
    Returns the runtime query <code>{query_name}</code> for <code>{lang}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>        (<code>string</code>) Language to use for the query
</div><div class="help-li" style=""> <code>{query_name}</code>  (<code>string</code>) Name of the query (e.g. "highlights")
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>vim.treesitter.Query?</code>) Parsed query. <code>nil</code> if no query files are
        found. See <a href="treesitter.html#vim.treesitter.Query">vim.treesitter.Query</a>.</div>
<div class="old-help-para">                                            <span id="vim.treesitter.query.get_files()" class="help-tag-right"><a href="#vim.treesitter.query.get_files()">vim.treesitter.query.get_files()</a></span><br>
get_files(<code>{lang}</code>, <code>{query_name}</code>, <code>{is_included}</code>)
    Gets the list of files used to make up a query</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>         (<code>string</code>) Language to get query for
</div><div class="help-li" style=""> <code>{query_name}</code>   (<code>string</code>) Name of the query to load (e.g.,
                       "highlights")
</div><div class="help-li" style=""> <code>{is_included}</code>  (<code>boolean?</code>) Internal parameter, most of the time left
                       as <code>nil</code>
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string[]</code>) query_files List of files to load for given query and
        language</div>
<div class="old-help-para">lint(<code>{buf}</code>, <code>{opts}</code>)                              <span id="vim.treesitter.query.lint()" class="help-tag-right"><a href="#vim.treesitter.query.lint()">vim.treesitter.query.lint()</a></span><br>
    Lint treesitter queries using installed parser, or clear lint errors.</div>
<div class="old-help-para">    Use <a href="treesitter.html#treesitter-parsers">treesitter-parsers</a> in runtimepath to check the query file in <code>{buf}</code>
    for errors:
<div class="help-li" style=""> verify that used nodes are valid identifiers in the grammar.
</div><div class="help-li" style=""> verify that predicates and directives are valid.
</div><div class="help-li" style=""> verify that top-level s-expressions are valid.
</div></div>
<div class="old-help-para">    The found diagnostics are reported using <a href="diagnostic.html#diagnostic-api">diagnostic-api</a>. By default, the
    parser used for verification is determined by the containing folder of the
    query file, e.g., if the path ends in <code>/lua/highlights.scm</code>, the parser
    for the <code>lua</code> language will be used.</div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{buf}</code>   (<code>integer</code>) Buffer handle
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{langs}?</code> (<code>string|string[]</code>) Language(s) to use for checking
                  the query. If multiple languages are specified, queries are
                  validated for all of them
</div><div class="help-li" style="margin-left: 3rem;"> <code>{clear}</code> (<code>boolean</code>) Just clear current lint errors
</div></div>
<div class="old-help-para">list_directives()                     <span id="vim.treesitter.query.list_directives()" class="help-tag-right"><a href="#vim.treesitter.query.list_directives()">vim.treesitter.query.list_directives()</a></span><br>
    Lists the currently available directives to use in queries.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string[]</code>) Supported directives.</div>
<div class="old-help-para">list_predicates()                     <span id="vim.treesitter.query.list_predicates()" class="help-tag-right"><a href="#vim.treesitter.query.list_predicates()">vim.treesitter.query.list_predicates()</a></span><br>
    Lists the currently available predicates to use in queries.</div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>string[]</code>) Supported predicates.</div>
<div class="old-help-para">omnifunc(<code>{findstart}</code>, <code>{base}</code>)                <span id="vim.treesitter.query.omnifunc()" class="help-tag-right"><a href="#vim.treesitter.query.omnifunc()">vim.treesitter.query.omnifunc()</a></span><br>
    Omnifunc for completing node names and predicates in treesitter queries.</div>
<div class="old-help-para">    Use via<pre><code class="language-lua">vim.bo.omnifunc = 'v:lua.vim.treesitter.query.omnifunc'</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{findstart}</code>  (<code>0|1</code>)
</div><div class="help-li" style=""> <code>{base}</code>       (<code>string</code>)
</div></div>
<div class="old-help-para">parse(<code>{lang}</code>, <code>{query}</code>)                          <span id="vim.treesitter.query.parse()" class="help-tag-right"><a href="#vim.treesitter.query.parse()">vim.treesitter.query.parse()</a></span><br>
    Parses a <code>{query}</code> string and returns a <code>Query</code> object
    (<a href="treesitter.html#lua-treesitter-query">lua-treesitter-query</a>), which can be used to search the tree for the
    query patterns (via <a href="treesitter.html#Query%3Aiter_captures()">Query:iter_captures()</a>, <a href="treesitter.html#Query%3Aiter_matches()">Query:iter_matches()</a>), or
    inspect/modify the query via these fields:
<div class="help-li" style=""> <code>captures</code>: a list of unique capture names defined in the query (alias:
      <code>info.captures</code>).
</div><div class="help-li" style=""> <code>info.patterns</code>: information about predicates.
</div><div class="help-li" style=""> <code>query</code>: the underlying <a href="treesitter.html#TSQuery">TSQuery</a> which can be used to disable patterns
      or captures.
</div></div>
<div class="old-help-para">    Example:<pre><code class="language-lua">local query = vim.treesitter.query.parse('vimdoc', [[
  ; query
  ((h1) @str
    (#trim! @str 1 1 1 1))
]])
local tree = vim.treesitter.get_parser():parse()[1]
for id, node, metadata in query:iter_captures(tree:root(), 0) do
   -- Print the node name and source text.
   vim.print({node:type(), vim.treesitter.get_node_text(node, vim.api.nvim_get_current_buf())})
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>   (<code>string</code>) Language to use for the query
</div><div class="help-li" style=""> <code>{query}</code>  (<code>string</code>) Query text, in s-expr syntax
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>vim.treesitter.Query</code>) Parsed query . See <a href="treesitter.html#vim.treesitter.Query">vim.treesitter.Query</a>.</div>
<div class="old-help-para"><div class="help-column_heading">See also:</div><div class="help-li" style=""> <a href="treesitter.html#vim.treesitter.query.get()">vim.treesitter.query.get()</a>
</div></div>
<div class="old-help-para">                                                       <span id="Query%3Aiter_captures()" class="help-tag-right"><a href="#Query%3Aiter_captures()">Query:iter_captures()</a></span><br>
Query:iter_captures(<code>{node}</code>, <code>{source}</code>, <code>{start_row}</code>, <code>{end_row}</code>, <code>{opts}</code>)
    Iterates over all captures from all matches in <code>{node}</code>.</div>
<div class="old-help-para">    <code>{source}</code> is required if the query contains predicates; then the caller
    must ensure to use a freshly parsed tree consistent with the current text
    of the buffer (if relevant). <code>{start}</code> and <code>{stop}</code> can be used to limit
    matches inside a row range (this is typically used with root node as the
    <code>{node}</code>, i.e., to get syntax highlight matches in the current viewport).
    When omitted, the <code>{start}</code> and <code>{stop}</code> row values are used from the given
    node.</div>
<div class="old-help-para">    The iterator returns four values:
<div class="help-li-num" style=""> the numeric id identifying the capture
</div></div>
<div class="old-help-para"><div class="help-li-num" style=""> the captured node
</div></div>
<div class="old-help-para"><div class="help-li-num" style=""> metadata from any directives processing the match
</div></div>
<div class="old-help-para"><div class="help-li-num" style=""> the match itself
</div></div>
<div class="old-help-para">    Example: how to get captures by name:<pre><code class="language-lua">for id, node, metadata, match in query:iter_captures(tree:root(), bufnr, first, last) do
  local name = query.captures[id] -- name of the capture in the query
  -- typically useful info about the node:
  local type = node:type() -- type of the captured node
  local row1, col1, row2, col2 = node:range() -- range of the capture
  -- ... use the info here ...
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading"><b>    Note:</b></div><div class="help-li" style=""> Captures are only returned if the query pattern of a specific capture
        contained predicates.
</div></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>       (<code>TSNode</code>) under which the search will occur
</div><div class="help-li" style=""> <code>{source}</code>     (<code>integer|string</code>) Source buffer or string to extract
                     text from
</div><div class="help-li" style=""> <code>{start_row}</code>  (<code>integer?</code>) Starting line for the search. Defaults to
                     <code>node:start()</code>.
</div><div class="help-li" style=""> <code>{end_row}</code>    (<code>integer?</code>) Stopping line for the search (end-inclusive,
                     unless <code>stop_col</code> is provided). Defaults to
                     <code>node:end_()</code>.
</div><div class="help-li" style=""> <code>{opts}</code>       (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> max_start_depth (integer) if non-zero, sets the maximum
                       start depth for each match. This is used to prevent
                       traversing too deep into a tree.
</div><div class="help-li" style="margin-left: 3rem;"> match_limit (integer) Set the maximum number of
                       in-progress matches (Default: 256).
</div><div class="help-li" style="margin-left: 3rem;"> start_col (integer) Starting column for the search.
</div><div class="help-li" style="margin-left: 3rem;"> end_col (integer) Stopping column for the search
                       (end-exclusive).
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>fun(end_line: integer?, end_col: integer?): integer, TSNode, vim.treesitter.query.TSMetadata, TSQueryMatch, TSTree</code>)
        capture id, capture node, metadata, match, tree</div>
<div class="old-help-para">                                                        <span id="Query%3Aiter_matches()" class="help-tag-right"><a href="#Query%3Aiter_matches()">Query:iter_matches()</a></span><br>
Query:iter_matches(<code>{node}</code>, <code>{source}</code>, <code>{start}</code>, <code>{stop}</code>, <code>{opts}</code>)
    Iterates the matches of self on a given range.</div>
<div class="old-help-para">    Iterate over all matches within a <code>{node}</code>. The arguments are the same as
    for <a href="treesitter.html#Query%3Aiter_captures()">Query:iter_captures()</a> but the iterated values are different: an
    (1-based) index of the pattern in the query, a table mapping capture
    indices to a list of nodes, and metadata from any directives processing
    the match.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, 0, -1) do
  for id, nodes in pairs(match) do
    local name = query.captures[id]
    for _, node in ipairs(nodes) do
      -- `node` was captured by the `name` capture in the match
      local node_data = metadata[id] -- Node level metadata
      -- ... use the info here ...
    end
  end
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{node}</code>    (<code>TSNode</code>) under which the search will occur
</div><div class="help-li" style=""> <code>{source}</code>  (<code>integer|string</code>) Source buffer or string to search
</div><div class="help-li" style=""> <code>{start}</code>   (<code>integer?</code>) Starting line for the search. Defaults to
                  <code>node:start()</code>.
</div><div class="help-li" style=""> <code>{stop}</code>    (<code>integer?</code>) Stopping line for the search (end-exclusive).
                  Defaults to <code>node:end_()</code>.
</div><div class="help-li" style=""> <code>{opts}</code>    (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> max_start_depth (integer) if non-zero, sets the maximum
                    start depth for each match. This is used to prevent
                    traversing too deep into a tree.
</div><div class="help-li" style="margin-left: 3rem;"> match_limit (integer) Set the maximum number of
                    in-progress matches (Default: 256).
</div><div class="help-li" style="margin-left: 3rem;"> all (boolean) When <code>false</code> (default <code>true</code>), the returned
                    table maps capture IDs to a single (last) node instead of
                    the full list of matching nodes. This option is only for
                    backward compatibility and will be removed in a future
                    release.
</div></div>
<div class="old-help-para"><div class="help-column_heading">Return:</div>        (<code>fun(): integer, table&lt;integer, TSNode[]&gt;, vim.treesitter.query.TSMetadata, TSTree</code>)
        pattern id, match, metadata, tree</div>
<div class="old-help-para">set(<code>{lang}</code>, <code>{query_name}</code>, <code>{text}</code>)                 <span id="vim.treesitter.query.set()" class="help-tag-right"><a href="#vim.treesitter.query.set()">vim.treesitter.query.set()</a></span><br>
    Sets the runtime query named <code>{query_name}</code> for <code>{lang}</code></div>
<div class="old-help-para">    This allows users to override or extend any runtime files and/or
    configuration set by plugins.</div>
<div class="old-help-para">    For example, you could enable spellchecking of <code>C</code> identifiers with the
    following code:<pre><code class="language-lua">vim.treesitter.query.set(
  'c',
  'highlights',
  [[;inherits c
  (identifier) @spell]])
]])</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{lang}</code>        (<code>string</code>) Language to use for the query
</div><div class="help-li" style=""> <code>{query_name}</code>  (<code>string</code>) Name of the query (e.g., "highlights")
</div><div class="help-li" style=""> <code>{text}</code>        (<code>string</code>) Query text (unparsed).
</div></div>
<div class="old-help-para"><span id="TSQuery" class="help-tag"><a href="#TSQuery">TSQuery</a></span>
    Extends: <a href="luaref.html#userdata">userdata</a></div>
<div class="old-help-para">    Reference to an object held by the treesitter library that is used as a
    component of the <a href="treesitter.html#vim.treesitter.Query">vim.treesitter.Query</a> for language feature support. See
    <a href="treesitter.html#treesitter-query">treesitter-query</a> for more about queries or
    <a href="treesitter.html#vim.treesitter.query.parse()">vim.treesitter.query.parse()</a> for an example of how to obtain a query
    object.</div>
<div class="old-help-para"><div class="help-column_heading">Fields:</div><div class="help-li" style=""> <code>{disable_capture}</code>  (<code>fun(self: TSQuery, capture_name: string)</code>) See
                           <a href="treesitter.html#TSQuery%3Adisable_capture()">TSQuery:disable_capture()</a>.
</div><div class="help-li" style=""> <code>{disable_pattern}</code>  (<code>fun(self: TSQuery, pattern_index: integer)</code>) See
                           <a href="treesitter.html#TSQuery%3Adisable_pattern()">TSQuery:disable_pattern()</a>.
</div></div>
<div class="old-help-para">TSQuery:disable_capture(<code>{capture_name}</code>)            <span id="TSQuery%3Adisable_capture()" class="help-tag-right"><a href="#TSQuery%3Adisable_capture()">TSQuery:disable_capture()</a></span><br>
    Disable a specific capture in this query; once disabled the capture cannot
    be re-enabled. <code>{capture_name}</code> should not include a leading "@".</div>
<div class="old-help-para">    Example: To disable the <code>@variable.parameter</code> capture from the vimdoc
    highlights query:<pre><code class="language-lua">local query = vim.treesitter.query.get('vimdoc', 'highlights')
query.query:disable_capture("variable.parameter")
vim.treesitter.get_parser():parse()</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{capture_name}</code>  (<code>string</code>)
</div></div>
<div class="old-help-para">TSQuery:disable_pattern(<code>{pattern_index}</code>)           <span id="TSQuery%3Adisable_pattern()" class="help-tag-right"><a href="#TSQuery%3Adisable_pattern()">TSQuery:disable_pattern()</a></span><br>
    Disable a specific pattern in this query; once disabled the pattern cannot
    be re-enabled. The <code>{pattern_index}</code> for a particular match can be obtained
    with <a href="lua.html#%3AInspect%21">:Inspect!</a>, or by reading the source of the query (i.e. from
    <a href="treesitter.html#vim.treesitter.query.get_files()">vim.treesitter.query.get_files()</a>).</div>
<div class="old-help-para">    Example: To disable <code>|</code> links in vimdoc but keep other <code>@markup.link</code>s
    highlighted:<pre><code class="language-lua">local link_pattern = 9 -- from :Inspect!
local query = vim.treesitter.query.get('vimdoc', 'highlights')
query.query:disable_pattern(link_pattern)
local tree = vim.treesitter.get_parser():parse()[1]</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">Parameters:</div><div class="help-li" style=""> <code>{pattern_index}</code>  (<code>integer</code>)
</div></div>

  </div>
      <div class="col-narrow toc">
      <div><a href="index.html">Main</a></div>
      <div><a href="vimindex.html">Commands index</a></div>
      <div><a href="quickref.html">Quick reference</a></div>
      <hr/>
  <div class="help-toc-h1"><a href="#_parser-files">PARSER FILES</a>
</div><div class="help-toc-h1"><a href="#_treesitter-queries">TREESITTER QUERIES</a>
<div class="help-toc-h2"><a href="#_treesitter-query-predicates">TREESITTER QUERY PREDICATES</a></div>
<div class="help-toc-h2"><a href="#_treesitter-query-directives">TREESITTER QUERY DIRECTIVES</a></div>
<div class="help-toc-h2"><a href="#_treesitter-query-modelines">TREESITTER QUERY MODELINES</a></div>
</div><div class="help-toc-h1"><a href="#_treesitter-syntax-highlighting">TREESITTER SYNTAX HIGHLIGHTING</a>
</div><div class="help-toc-h1"><a href="#_treesitter-language-injections">TREESITTER LANGUAGE INJECTIONS</a>
</div><div class="help-toc-h1"><a href="#_vim.treesitter">VIM.TREESITTER</a>
</div><div class="help-toc-h1"><a href="#_treesitter-trees">TREESITTER TREES</a>
</div><div class="help-toc-h1"><a href="#_treesitter-nodes">TREESITTER NODES</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.treesitter">Lua module: vim.treesitter</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.treesitter.language">Lua module: vim.treesitter.language</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.treesitter.languagetree">Lua module: vim.treesitter.languagetree</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.treesitter.query">Lua module: vim.treesitter.query</a>
</div></div>
</div>
  <footer>
    <div class="container flex">
      <div class="generator-stats">
        Generated at 2026-01-15 05:30 from <code><a href="https://github.com/neovim/neovim/commit/86c939ba91e97f0364bf5ba877a0fb4f45309c35">86c939b</a></code>
      </div>
      <div class="generator-stats">
      parse_errors: 0 (<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML%3A+treesitter.txt+&body=%60gen_help_html.lua%60+problem+at%3A+https://neovim.io/doc/user/treesitter.html%0D%0DContext%3A%0D%0D%60%60%60%0DTODO%0D%60%60%60" target="_blank">report docs bug...</a>) | <span title="    Nvim
                            NVIM REFERENCE MANUAL
                                      Type &lt;a href="various.html#gO"&gt;gO&lt;/a&gt; to see the table of contents.">noise_lines: 3</span>
      </div>
    <div>

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
    <script type="module">
      docsearch({
        container: '#docsearch',
        appId: 'X185E15FPG',
        apiKey: 'b5e6b2f9c636b2b471303205e59832ed',
        indexName: 'nvim',
      });
    </script>

  </footer>
  </body>
</html>
