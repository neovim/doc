  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Neovim user documentation">

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" />
    <link rel="preconnect" href="https://X185E15FPG-dsn.algolia.net" crossorigin />

    <link href="/css/normalize.min.css" rel="stylesheet">
    <link href="/css/bootstrap.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="help.css" rel="stylesheet">
    <link href="/highlight/styles/neovim.min.css" rel="stylesheet">

    <script src="/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title> Treesitter - Neovim docs</title>
  </head>
  <body>
    <header class="container">
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a href="/" class="navbar-brand" aria-label="logo">
          <!--TODO: use <img src="….svg"> here instead. Need one that has green lettering instead of gray. -->
              <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214" aria-label="Neovim">
      <title>Neovim</title>
      <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
          <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
          <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
          <stop stop-color="#7DB643" offset="0%" />
          <stop stop-color="#367533" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
          <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
          <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
        </linearGradient>
      </defs>
      <g fill="none" fill-rule="evenodd">
        <path
          d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
          fill="url(#a)"
          transform="translate(1 1)"
        />
        <path
          d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
          fill="url(#b)"
          transform="matrix(-1 0 0 1 305 1)"
        />
        <path
          d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
          fill="url(#c)"
          transform="translate(1 1)"
        />
        <path
          d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
          fill-opacity=".13"
          fill="#000"
        />
        <g fill="#444">
          <path
            d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
            fill="currentColor"
          />
          <path
            d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
            fill="currentColor"
            fill-opacity=".8"
          />
        </g>
      </g>
    </svg>
  
          <!--<img src="https://neovim.io/logos/neovim-logo.svg" width="173" height="50" alt="Neovim" />-->
        </a>
        <div id="docsearch"></div> <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
      </div>
    </nav>
  </header>

  <div class="container golden-grid help-body">
  <div class="col-wide">
  <a name="treesitter"></a><h1 id="treesitter.txt"> Treesitter</h1>
  <p>
    <i>
    Nvim <code>:help</code> pages, <a href="https://github.com/neovim/neovim/blob/master/scripts/gen_help_html.lua">generated</a>
    from <a href="https://github.com/neovim/neovim/blob/master/runtime/doc/treesitter.txt">source</a>
    using the <a href="https://github.com/neovim/tree-sitter-vimdoc">tree-sitter-vimdoc</a> parser.
    </i>
  </p>
  <hr/>
  <div class="old-help-para">Treesitter integration</div>
<div class="old-help-para">Nvim integrates the <code>tree-sitter</code> library for incremental parsing of buffers:
<a href="https://tree-sitter.github.io/tree-sitter/">https://tree-sitter.github.io/tree-sitter/</a></div>
<div class="old-help-para">WARNING: Treesitter support is still experimental and subject to frequent
changes. This documentation may also not fully reflect the latest changes.</div>
<div class="old-help-para"><h2 id="treesitter-parsers" class="help-heading">PARSER FILES<span class="help-heading-tags">                                              <span class="help-tag"><a href="#treesitter-parsers">treesitter-parsers</a></span></h2></div>
<div class="old-help-para">Parsers are the heart of tree-sitter. They are libraries that tree-sitter will
search for in the <code>parser</code> runtime directory. By default, Nvim bundles parsers
for C, Lua, Vimscript, Vimdoc and Treesitter query files, but parsers can be
installed manually or via a plugin like
<a href="https://github.com/nvim-treesitter/nvim-treesitter">https://github.com/nvim-treesitter/nvim-treesitter</a>. Parsers are searched for
as <code>parser/{lang}.*</code> in any <a href="options.html#'runtimepath'">'runtimepath'</a> directory. If multiple parsers for
the same language are found, the first one is used. (This typically implies
the priority "user config &gt; plugins &gt; bundled".
A parser can also be loaded manually using a full path:<pre><code class="language-lua">vim.treesitter.language.add('python', { path = "/path/to/python.so" })</code></pre></div>
<div class="old-help-para"><h2 id="treesitter-tree" class="help-heading">TREESITTER TREES<span class="help-heading-tags">                                             <span class="help-tag"><a href="#treesitter-tree">treesitter-tree</a></span></h2>                                                                      <code id="TSTree" class="help-tag-right"><a href="#TSTree">TSTree</a></code></div>
<div class="old-help-para">A "treesitter tree" represents the parsed contents of a buffer, which can be
used to perform further analysis. It is a <a href="luaref.html#userdata">userdata</a> reference to an object
held by the tree-sitter library.</div>
<div class="old-help-para">An instance <code>TSTree</code> of a treesitter tree supports the following methods.</div>
<div class="old-help-para">TSTree:root()                                           <code id="TSTree%3Aroot()" class="help-tag-right"><a href="#TSTree%3Aroot()">TSTree:root()</a></code>
    Return the root node of this tree.</div>
<div class="old-help-para">TSTree:copy()                                           <code id="TSTree%3Acopy()" class="help-tag-right"><a href="#TSTree%3Acopy()">TSTree:copy()</a></code>
    Returns a copy of the <code>TSTree</code>.</div>
<div class="old-help-para"><h2 id="treesitter-node" class="help-heading">TREESITTER NODES<span class="help-heading-tags">                                             <span class="help-tag"><a href="#treesitter-node">treesitter-node</a></span></h2>                                                                      <code id="TSNode" class="help-tag-right"><a href="#TSNode">TSNode</a></code></div>
<div class="old-help-para">A "treesitter node" represents one specific element of the parsed contents of
a buffer, which can be captured by aQuery for, e.g., highlighting. It is
a <a href="luaref.html#userdata">userdata</a> reference to an object held by the tree-sitter library.</div>
<div class="old-help-para">An instance <code>TSNode</code> of a treesitter node supports the following methods.</div>
<div class="old-help-para">TSNode:parent()                                         <code id="TSNode%3Aparent()" class="help-tag-right"><a href="#TSNode%3Aparent()">TSNode:parent()</a></code>
    Get the node's immediate parent.</div>
<div class="old-help-para">TSNode:next_sibling()                                   <code id="TSNode%3Anext_sibling()" class="help-tag-right"><a href="#TSNode%3Anext_sibling()">TSNode:next_sibling()</a></code>
    Get the node's next sibling.</div>
<div class="old-help-para">TSNode:prev_sibling()                                   <code id="TSNode%3Aprev_sibling()" class="help-tag-right"><a href="#TSNode%3Aprev_sibling()">TSNode:prev_sibling()</a></code>
    Get the node's previous sibling.</div>
<div class="old-help-para">TSNode:next_named_sibling()                       <code id="TSNode%3Anext_named_sibling()" class="help-tag-right"><a href="#TSNode%3Anext_named_sibling()">TSNode:next_named_sibling()</a></code>
    Get the node's next named sibling.</div>
<div class="old-help-para">TSNode:prev_named_sibling()                       <code id="TSNode%3Aprev_named_sibling()" class="help-tag-right"><a href="#TSNode%3Aprev_named_sibling()">TSNode:prev_named_sibling()</a></code>
    Get the node's previous named sibling.</div>
<div class="old-help-para">TSNode:iter_children()                                 <code id="TSNode%3Aiter_children()" class="help-tag-right"><a href="#TSNode%3Aiter_children()">TSNode:iter_children()</a></code>
    Iterates over all the direct children of <code>{TSNode}</code>, regardless of whether
    they are named or not.
    Returns the child node plus the eventual field name corresponding to this
    child node.</div>
<div class="old-help-para">TSNode:field(<code>{name}</code>)                                    <code id="TSNode%3Afield()" class="help-tag-right"><a href="#TSNode%3Afield()">TSNode:field()</a></code>
    Returns a table of the nodes corresponding to the <code>{name}</code> field.</div>
<div class="old-help-para">TSNode:child_count()                                    <code id="TSNode%3Achild_count()" class="help-tag-right"><a href="#TSNode%3Achild_count()">TSNode:child_count()</a></code>
    Get the node's number of children.</div>
<div class="old-help-para">TSNode:child(<code>{index}</code>)                                   <code id="TSNode%3Achild()" class="help-tag-right"><a href="#TSNode%3Achild()">TSNode:child()</a></code>
    Get the node's child at the given <code>{index}</code>, where zero represents the first
    child.</div>
<div class="old-help-para">TSNode:named_child_count()                         <code id="TSNode%3Anamed_child_count()" class="help-tag-right"><a href="#TSNode%3Anamed_child_count()">TSNode:named_child_count()</a></code>
    Get the node's number of named children.</div>
<div class="old-help-para">TSNode:named_child(<code>{index}</code>)                              <code id="TSNode%3Anamed_child()" class="help-tag-right"><a href="#TSNode%3Anamed_child()">TSNode:named_child()</a></code>
    Get the node's named child at the given <code>{index}</code>, where zero represents the
    first named child.</div>
<div class="old-help-para">TSNode:start()                                          <code id="TSNode%3Astart()" class="help-tag-right"><a href="#TSNode%3Astart()">TSNode:start()</a></code>
    Get the node's start position. Return three values: the row, column and
    total byte count (all zero-based).</div>
<div class="old-help-para">TSNode:end_()                                           <code id="TSNode%3Aend_()" class="help-tag-right"><a href="#TSNode%3Aend_()">TSNode:end_()</a></code>
    Get the node's end position. Return three values: the row, column and
    total byte count (all zero-based).</div>
<div class="old-help-para">TSNode:range(<code>{include_bytes}</code>)                           <code id="TSNode%3Arange()" class="help-tag-right"><a href="#TSNode%3Arange()">TSNode:range()</a></code>
    Get the range of the node.</div>
<div class="old-help-para">    Return four or six values:
<div class="help-li" style=""> start row
</div><div class="help-li" style=""> start column
</div><div class="help-li" style=""> start byte (if <code>{include_bytes}</code> is <code>true</code>)
</div><div class="help-li" style=""> end row
</div><div class="help-li" style=""> end column
</div><div class="help-li" style=""> end byte (if <code>{include_bytes}</code> is <code>true</code>)
</div></div>
<div class="old-help-para">TSNode:type()                                           <code id="TSNode%3Atype()" class="help-tag-right"><a href="#TSNode%3Atype()">TSNode:type()</a></code>
    Get the node's type as a string.</div>
<div class="old-help-para">TSNode:symbol()                                         <code id="TSNode%3Asymbol()" class="help-tag-right"><a href="#TSNode%3Asymbol()">TSNode:symbol()</a></code>
    Get the node's type as a numerical id.</div>
<div class="old-help-para">TSNode:named()                                          <code id="TSNode%3Anamed()" class="help-tag-right"><a href="#TSNode%3Anamed()">TSNode:named()</a></code>
    Check if the node is named. Named nodes correspond to named rules in the
    grammar, whereas anonymous nodes correspond to string literals in the
    grammar.</div>
<div class="old-help-para">TSNode:missing()                                        <code id="TSNode%3Amissing()" class="help-tag-right"><a href="#TSNode%3Amissing()">TSNode:missing()</a></code>
    Check if the node is missing. Missing nodes are inserted by the parser in
    order to recover from certain kinds of syntax errors.</div>
<div class="old-help-para">TSNode:extra()                                          <code id="TSNode%3Aextra()" class="help-tag-right"><a href="#TSNode%3Aextra()">TSNode:extra()</a></code>
    Check if the node is extra. Extra nodes represent things like comments,
    which are not required by the grammar but can appear anywhere.</div>
<div class="old-help-para">TSNode:has_changes()                                    <code id="TSNode%3Ahas_changes()" class="help-tag-right"><a href="#TSNode%3Ahas_changes()">TSNode:has_changes()</a></code>
    Check if a syntax node has been edited.</div>
<div class="old-help-para">TSNode:has_error()                                      <code id="TSNode%3Ahas_error()" class="help-tag-right"><a href="#TSNode%3Ahas_error()">TSNode:has_error()</a></code>
    Check if the node is a syntax error or contains any syntax errors.</div>
<div class="old-help-para">TSNode:sexpr()                                          <code id="TSNode%3Asexpr()" class="help-tag-right"><a href="#TSNode%3Asexpr()">TSNode:sexpr()</a></code>
    Get an S-expression representing the node as a string.</div>
<div class="old-help-para">TSNode:id()                                             <code id="TSNode%3Aid()" class="help-tag-right"><a href="#TSNode%3Aid()">TSNode:id()</a></code>
    Get an unique identifier for the node inside its own tree.</div>
<div class="old-help-para">    No guarantees are made about this identifier's internal representation,
    except for being a primitive Lua type with value equality (so not a
    table). Presently it is a (non-printable) string.</div>
<div class="old-help-para">    Note: The <code>id</code> is not guaranteed to be unique for nodes from different
    trees.</div>
<div class="old-help-para">TSNode:tree()                                           <code id="TSNode%3Atree()" class="help-tag-right"><a href="#TSNode%3Atree()">TSNode:tree()</a></code>
    Get the <a href="treesitter.html#TSTree">TSTree</a> of the node.
                                                <code id="TSNode%3Adescendant_for_range()" class="help-tag-right"><a href="#TSNode%3Adescendant_for_range()">TSNode:descendant_for_range()</a></code>
TSNode:descendant_for_range(<code>{start_row}</code>, <code>{start_col}</code>, <code>{end_row}</code>, <code>{end_col}</code>)
    Get the smallest node within this node that spans the given range of (row,
    column) positions</div>
<div class="old-help-para">                                          <code id="TSNode%3Anamed_descendant_for_range()" class="help-tag-right"><a href="#TSNode%3Anamed_descendant_for_range()">TSNode:named_descendant_for_range()</a></code>
TSNode:named_descendant_for_range(<code>{start_row}</code>, <code>{start_col}</code>, <code>{end_row}</code>, <code>{end_col}</code>)
    Get the smallest named node within this node that spans the given range of
    (row, column) positions
                                                        <code id="TSNode%3Aequal()" class="help-tag-right"><a href="#TSNode%3Aequal()">TSNode:equal()</a></code>
TSNode:equal(<code>{node}</code>)
    Check if <code>{node}</code> refers to the same node within the same tree.</div>
<div class="old-help-para"><h2 id="treesitter-query" class="help-heading">TREESITTER QUERIES<span class="help-heading-tags">                                          <span class="help-tag"><a href="#treesitter-query">treesitter-query</a></span></h2></div>
<div class="old-help-para">Treesitter queries are a way to extract information about a parsed <a href="treesitter.html#TSTree">TSTree</a>,
e.g., for the purpose of highlighting. Briefly, a <code>query</code> consists of one or
more patterns. A <code>pattern</code> is defined over node types in the syntax tree. A
<code>match</code> corresponds to specific elements of the syntax tree which match a
pattern. Patterns may optionally define captures and predicates. A <code>capture</code>
allows you to associate names with a specific node in a pattern. A <code>predicate</code>
adds arbitrary metadata and conditional data to a match.</div>
<div class="old-help-para">Queries are written in a lisp-like language documented in
<a href="https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax">https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax</a>
Note: The predicates listed there page differ from those Nvim supports. See
<a href="treesitter.html#treesitter-predicates">treesitter-predicates</a> for a complete list of predicates supported by Nvim.</div>
<div class="old-help-para">Nvim looks for queries as <code>*.scm</code> files in a <code>queries</code> directory under
<code>runtimepath</code>, where each file contains queries for a specific language and
purpose, e.g., <code>queries/lua/highlights.scm</code> for highlighting Lua files.
By default, the first query on <code>runtimepath</code> is used (which usually implies
that user config takes precedence over plugins, which take precedence over
queries bundled with Nvim). If a query should extend other queries instead
of replacing them, use <a href="treesitter.html#treesitter-query-modeline-extends">treesitter-query-modeline-extends</a>.</div>
<div class="old-help-para">See <a href="treesitter.html#lua-treesitter-query">lua-treesitter-query</a> for the list of available methods for working with
treesitter queries from Lua.</div>
<div class="old-help-para"><h3 id="treesitter-predicates" class="help-heading">TREESITTER QUERY PREDICATES<span class="help-heading-tags">                            <span class="help-tag"><a href="#treesitter-predicates">treesitter-predicates</a></span></h3></div>
<div class="old-help-para">Predicates are special scheme nodes that are evaluated to conditionally capture
nodes. For example, the <code>eq?</code> predicate can be used as follows:<pre><code class="language-query">((identifier) @foo (#eq? @foo "foo"))</code></pre></div>
<div class="old-help-para">to only match identifier corresponding to the <code>"foo"</code> text.</div>
<div class="old-help-para">The following predicates are built in:</div>
<div class="old-help-para">    <code>eq?</code>                                            <code id="treesitter-predicate-eq%3F" class="help-tag-right"><a href="#treesitter-predicate-eq%3F">treesitter-predicate-eq?</a></code>
        Match a string against the text corresponding to a node:<pre><code class="language-query">((identifier) @foo (#eq? @foo "foo"))
((node1) @left (node2) @right (#eq? @left @right))</code></pre></div>
<div class="old-help-para">    <code>match?</code>                                      <code id="treesitter-predicate-match%3F" class="help-tag-right"><a href="#treesitter-predicate-match%3F">treesitter-predicate-match?</a></code>
    <code>vim-match?</code>                              <code id="treesitter-predicate-vim-match%3F" class="help-tag-right"><a href="#treesitter-predicate-vim-match%3F">treesitter-predicate-vim-match?</a></code>
         Match a <a href="pattern.html#regexp">regexp</a> against the text corresponding to a node:<pre><code class="language-query">((identifier) @constant (#match? @constant "^[A-Z_]+$"))</code></pre></div>
<div class="old-help-para">         Note: The <code>^</code> and <code>$</code> anchors will match the start and end of the
               node's text.</div>
<div class="old-help-para">    <code>lua-match?</code>                              <code id="treesitter-predicate-lua-match%3F" class="help-tag-right"><a href="#treesitter-predicate-lua-match%3F">treesitter-predicate-lua-match?</a></code>
         Match <a href="lua.html#lua-patterns">lua-patterns</a> against the text corresponding to a node,
         similar to <code>match?</code></div>
<div class="old-help-para">    <code>contains?</code>                                <code id="treesitter-predicate-contains%3F" class="help-tag-right"><a href="#treesitter-predicate-contains%3F">treesitter-predicate-contains?</a></code>
        Match a string against parts of the text corresponding to a node:<pre><code class="language-query">((identifier) @foo (#contains? @foo "foo"))
((identifier) @foo-bar (#contains? @foo-bar "foo" "bar"))</code></pre></div>
<div class="old-help-para">    <code>any-of?</code>                                    <code id="treesitter-predicate-any-of%3F" class="help-tag-right"><a href="#treesitter-predicate-any-of%3F">treesitter-predicate-any-of?</a></code>
        Match any of the given strings against the text corresponding to
        a node:<pre><code class="language-query">((identifier) @foo (#any-of? @foo "foo" "bar"))</code></pre></div>
<div class="old-help-para">        This is the recommended way to check if the node matches one of many
        keywords, as it has been optimized for this.</div>
<div class="old-help-para">    <code>has-ancestor?</code>                        <code id="treesitter-predicate-has-ancestor%3F" class="help-tag-right"><a href="#treesitter-predicate-has-ancestor%3F">treesitter-predicate-has-ancestor?</a></code>
        Match any of the given node types against all ancestors of a node:<pre><code class="language-query">((identifier) @variable.builtin
  (#any-of? @variable.builtin "begin" "end")
  (#has-ancestor? @variable.builtin range_expression))</code></pre></div>
<div class="old-help-para">    <code>has-parent?</code>                            <code id="treesitter-predicate-has-parent%3F" class="help-tag-right"><a href="#treesitter-predicate-has-parent%3F">treesitter-predicate-has-parent?</a></code>
        Match any of the given node types against the direct ancestor of a
        node:<pre><code class="language-query">(((field_expression
     (field_identifier) @method)) @_parent
 (#has-parent? @_parent template_method function_declarator))</code></pre></div>
<div class="old-help-para">                                                 <code id="lua-treesitter-not-predicate" class="help-tag-right"><a href="#lua-treesitter-not-predicate">lua-treesitter-not-predicate</a></code>
Each predicate has a <code>not-</code> prefixed predicate that is just the negation of
the predicate.</div>
<div class="old-help-para">Further predicates can be added via <a href="treesitter.html#vim.treesitter.query.add_predicate()">vim.treesitter.query.add_predicate()</a>.
Use <a href="treesitter.html#vim.treesitter.query.list_predicates()">vim.treesitter.query.list_predicates()</a> to list all available predicates.</div>
<div class="old-help-para"><h3 id="treesitter-directives" class="help-heading">TREESITTER QUERY DIRECTIVES<span class="help-heading-tags">                            <span class="help-tag"><a href="#treesitter-directives">treesitter-directives</a></span></h3></div>
<div class="old-help-para">Treesitter directives store metadata for a node or match and perform side
effects. For example, the <code>set!</code> directive sets metadata on the match or node:<pre><code class="language-query">((identifier) @foo (#set! "type" "parameter"))</code></pre></div>
<div class="old-help-para">The following directives are built in:</div>
<div class="old-help-para">    <code>set!</code>                                          <code id="treesitter-directive-set%21" class="help-tag-right"><a href="#treesitter-directive-set%21">treesitter-directive-set!</a></code>
        Sets key/value metadata for a specific match or capture. Value is
        accessible as either <code>metadata[key]</code> (match specific) or
        <code>metadata[capture_id][key]</code> (capture specific).</div>
<div class="old-help-para"><div class="help-column_heading">        Parameters:</div>            <code>{capture_id}</code> (optional)
            <code>{key}</code>
            <code>{value}</code></div>
<div class="old-help-para">        Examples:<pre><code class="language-query">((identifier) @foo (#set! @foo "kind" "parameter"))
((node1) @left (node2) @right (#set! "type" "pair"))</code></pre></div>
<div class="old-help-para">    <code>offset!</code>                                      <code id="treesitter-directive-offset%21" class="help-tag-right"><a href="#treesitter-directive-offset%21">treesitter-directive-offset!</a></code>
        Takes the range of the captured node and applies an offset. This will
        generate a new range object for the captured node as
        <code>metadata[capture_id].range</code>.</div>
<div class="old-help-para"><div class="help-column_heading">        Parameters:</div>            <code>{capture_id}</code>
            <code>{start_row}</code>
            <code>{start_col}</code>
            <code>{end_row}</code>
            <code>{end_col}</code></div>
<div class="old-help-para">        Example:<pre><code class="language-query">((identifier) @constant (#offset! @constant 0 1 0 -1))</code></pre></div>
<div class="old-help-para">    <code>gsub!</code>                                          <code id="treesitter-directive-gsub%21" class="help-tag-right"><a href="#treesitter-directive-gsub%21">treesitter-directive-gsub!</a></code>
        Transforms the content of the node using a Lua pattern. This will set
        a new <code>metadata[capture_id].text</code>.</div>
<div class="old-help-para"><div class="help-column_heading">        Parameters:</div>            <code>{capture_id}</code>
            <code>{pattern}</code></div>
<div class="old-help-para">        Example:<pre><code class="language-query">(#gsub! @_node ".*%.(.*)" "%1")</code></pre></div>
<div class="old-help-para">    <code>trim!</code>                                          <code id="treesitter-directive-trim%21" class="help-tag-right"><a href="#treesitter-directive-trim%21">treesitter-directive-trim!</a></code>
        Trim blank lines from the end of the node. This will set a new
        <code>metadata[capture_id].range</code>.</div>
<div class="old-help-para"><div class="help-column_heading">        Parameters:</div>            <code>{capture_id}</code></div>
<div class="old-help-para">        Example:<pre><code class="language-query">(#trim! @fold)</code></pre></div>
<div class="old-help-para">Further directives can be added via <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a>.
Use <a href="treesitter.html#vim.treesitter.query.list_directives()">vim.treesitter.query.list_directives()</a> to list all available directives.</div>
<div class="old-help-para"><h3 id="treesitter-query-modeline" class="help-heading">TREESITTER QUERY MODELINES<span class="help-heading-tags">                          <span class="help-tag"><a href="#treesitter-query-modeline">treesitter-query-modeline</a></span></h3></div>
<div class="old-help-para">Nvim supports to customize the behavior of the queries using a set of
"modelines", that is comments in the queries starting with <code>;</code>. Here are the
currently supported modeline alternatives:</div>
<div class="old-help-para">    <code>inherits: {lang}...</code>                     <code id="treesitter-query-modeline-inherits" class="help-tag-right"><a href="#treesitter-query-modeline-inherits">treesitter-query-modeline-inherits</a></code>
        Specifies that this query should inherit the queries from <code>{lang}</code>.
        This will recursively descend in the queries of <code>{lang}</code> unless wrapped
        in parentheses: <code>({lang})</code>.
        Note: This is meant to be used to include queries from another
        language. If you want your query to extend the queries of the same
        language, use <code>extends</code>.</div>
<div class="old-help-para">    <code>extends</code>                                  <code id="treesitter-query-modeline-extends" class="help-tag-right"><a href="#treesitter-query-modeline-extends">treesitter-query-modeline-extends</a></code>
        Specifies that this query should be used as an extension for the
        query, i.e. that it should be merged with the others.
        Note: The order of the extensions, and the query that will be used as
        a base depends on your <a href="options.html#'runtimepath'">'runtimepath'</a> value.</div>
<div class="old-help-para">Note: These modeline comments must be at the top of the query, but can be
repeated, for example, the following two modeline blocks are both valid:
<pre><code class="language-query">;; inherits: foo,bar
;; extends</code></pre></div>
<div class="old-help-para"><pre><code class="language-query">;; extends
;;
;; inherits: baz</code></pre></div>
<div class="old-help-para"><h2 id="treesitter-highlight" class="help-heading">TREESITTER SYNTAX HIGHLIGHTING<span class="help-heading-tags">                          <span class="help-tag"><a href="#treesitter-highlight">treesitter-highlight</a></span></h2></div>
<div class="old-help-para">Syntax highlighting is specified through queries named <code>highlights.scm</code>,
which match a <a href="treesitter.html#TSNode">TSNode</a> in the parsed <a href="treesitter.html#TSTree">TSTree</a> to a <code>capture</code> that can be
assigned a highlight group. For example, the query<pre><code class="language-query">(parameters (identifier) @parameter)</code></pre></div>
<div class="old-help-para">matches any <code>identifier</code> node inside a function <code>parameter</code> node (e.g., the
<code>bar</code> in <code>foo(bar)</code>) to the capture named <code>@parameter</code>. It is also possible to
match literal expressions (provided the parser returns them):<pre><code class="language-query">"return" @keyword.return</code></pre></div>
<div class="old-help-para">Assuming a suitable parser and <code>highlights.scm</code> query is found in runtimepath,
treesitter highlighting for the current buffer can be enabled simply via
<a href="treesitter.html#vim.treesitter.start()">vim.treesitter.start()</a>.</div>
<div class="old-help-para">                                                 <code id="treesitter-highlight-groups" class="help-tag-right"><a href="#treesitter-highlight-groups">treesitter-highlight-groups</a></code>
The capture names, with <code>@</code> included, are directly usable as highlight groups.
For many commonly used captures, the corresponding highlight groups are linked
to Nvim's standard <a href="syntax.html#highlight-groups">highlight-groups</a> by default but can be overridden in
colorschemes.</div>
<div class="old-help-para">A fallback system is implemented, so that more specific groups fallback to
more generic ones. For instance, in a language that has separate doc comments,
<code>@comment.doc</code> could be used. If this group is not defined, the highlighting
for an ordinary <code>@comment</code> is used. This way, existing color schemes already
work out of the box, but it is possible to add more specific variants for
queries that make them available.</div>
<div class="old-help-para">As an additional rule, capture highlights can always be specialized by
language, by appending the language name after an additional dot. For
instance, to highlight comments differently per language:<pre><code class="language-vim">hi @comment.c guifg=Blue
hi @comment.lua guifg=DarkBlue
hi link @comment.doc.java String</code></pre></div>
<div class="old-help-para">The following captures are linked by default to standard <a href="syntax.html#group-name">group-name</a>s:
<pre>@text.literal      Comment
@text.reference    Identifier
@text.title        Title
@text.uri          Underlined
@text.underline    Underlined
@text.todo         Todo
@comment           Comment
@punctuation       Delimiter
@constant          Constant
@constant.builtin  Special
@constant.macro    Define
@define            Define
@macro             Macro
@string            String
@string.escape     SpecialChar
@string.special    SpecialChar
@character         Character
@character.special SpecialChar
@number            Number
@boolean           Boolean
@float             Float
@function          Function
@function.builtin  Special
@function.macro    Macro
@parameter         Identifier
@method            Function
@field             Identifier
@property          Identifier
@constructor       Special
@conditional       Conditional
@repeat            Repeat
@label             Label
@operator          Operator
@keyword           Keyword
@exception         Exception
@variable          Identifier
@type              Type
@type.definition   Typedef
@storageclass      StorageClass
@structure         Structure
@namespace         Identifier
@include           Include
@preproc           PreProc
@debug             Debug
@tag               Tag</pre></div>
<div class="old-help-para">                                                  <code id="treesitter-highlight-spell" class="help-tag-right"><a href="#treesitter-highlight-spell">treesitter-highlight-spell</a></code>
The special <code>@spell</code> capture can be used to indicate that a node should be
spell checked by Nvim's builtin <a href="spell.html#spell">spell</a> checker. For example, the following
capture marks comments as to be checked:<pre><code class="language-query">(comment) @spell</code></pre></div>
<div class="old-help-para">There is also <code>@nospell</code> which disables spellchecking regions with <code>@spell</code>.</div>
<div class="old-help-para">                                                <code id="treesitter-highlight-conceal" class="help-tag-right"><a href="#treesitter-highlight-conceal">treesitter-highlight-conceal</a></code>
Treesitter highlighting supports <a href="syntax.html#conceal">conceal</a> via the <code>conceal</code> metadata. By
convention, nodes to be concealed are captured as <code>@conceal</code>, but any capture
can be used. For example, the following query can be used to hide code block
delimiters in Markdown:<pre><code class="language-query">(fenced_code_block_delimiter @conceal (#set! conceal ""))</code></pre></div>
<div class="old-help-para">It is also possible to replace a node with a single character, which (unlike
legacy syntax) can be given a custom highlight. For example, the following
(ill-advised) query replaces the <code>!=</code> operator by a Unicode glyph, which is
still highlighted the same as other operators:<pre><code class="language-query">"!=" @operator (#set! conceal "≠")</code></pre></div>
<div class="old-help-para">Conceals specified in this way respect <a href="options.html#'conceallevel'">'conceallevel'</a>.</div>
<div class="old-help-para">                                               <code id="treesitter-highlight-priority" class="help-tag-right"><a href="#treesitter-highlight-priority">treesitter-highlight-priority</a></code>
Treesitter uses <a href="api.html#nvim_buf_set_extmark()">nvim_buf_set_extmark()</a> to set highlights with a default
priority of 100. This enables plugins to set a highlighting priority lower or
higher than tree-sitter. It is also possible to change the priority of an
individual query pattern manually by setting its <code>"priority"</code> metadata
attribute:<pre><code class="language-query">((super_important_node) @superimportant (#set! "priority" 105))</code></pre></div>
<div class="old-help-para"><h2 id="treesitter-language-injections" class="help-heading">TREESITTER LANGUAGE INJECTIONS<span class="help-heading-tags">                <span class="help-tag"><a href="#treesitter-language-injections">treesitter-language-injections</a></span></h2></div>
<div class="old-help-para">Note the following information is adapted from:
  <a href="https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection">https://tree-sitter.github.io/tree-sitter/syntax-highlighting#language-injection</a></div>
<div class="old-help-para">Some source files contain code written in multiple different languages.
Examples include:</div>
<div class="old-help-para"><div class="help-li" style=""> HTML files, which can contain JavaScript inside of <code>&lt;script&gt;</code> tags and
      CSS inside of <code>&lt;style&gt;</code> tags
</div><div class="help-li" style=""> ERB files, which contain Ruby inside of <code>&lt;%</code> <code>%&gt;</code> tags, and HTML outside of
      those tags
</div><div class="help-li" style=""> PHP files, which can contain HTML between the <code>&lt;php</code> tags
</div><div class="help-li" style=""> JavaScript files, which contain regular expression syntax within regex
      literals
</div><div class="help-li" style=""> Ruby, which can contain snippets of code inside of heredoc literals,
      where the heredoc delimiter often indicates the language
</div><div class="help-li" style=""> Lua, which can contain snippets of Vimscript inside <a href="lua.html#vim.cmd()">vim.cmd()</a> calls.
</div><div class="help-li" style=""> Vimscript, which can contain snippets of Lua inside <a href="lua.html#%3Alua-heredoc">:lua-heredoc</a>
      blocks.
</div></div>
<div class="old-help-para">All of these examples can be modeled in terms of a parent syntax tree and one
or more injected syntax trees, which reside inside of certain nodes in the
parent tree. The language injection query allows you to specify these
“injections” using the following captures:</div>
<div class="old-help-para"><div class="help-li" style=""> <code>@injection.content</code> - indicates that the captured node should have its
      contents re-parsed using another language.
</div><div class="help-li" style=""> <code>@injection.language</code> - indicates that the captured node’s text may
      contain the name of a language that should be used to re-parse the
      <code>@injection.content</code>.
</div></div>
<div class="old-help-para">The language injection behavior can also be configured by some properties
associated with patterns:</div>
<div class="old-help-para"><div class="help-li" style=""> <code>injection.language</code> - can be used to hard-code the name of a specific
    language.
</div><div class="help-li" style=""> <code>injection.combined</code> - indicates that all of the matching nodes in the
    tree should have their content parsed as one nested document.
</div><div class="help-li" style=""> <code>injection.include-children</code> - indicates that the <code>@injection.content</code>
    node's entire text should be re-parsed, including the text of its child
    nodes. By default, child nodes' text will be excluded from the injected
    document.
</div><div class="help-li" style=""> <code>injection.self</code> - indicates that the node's text should be parsed with
      the same language as the node's LanguageTree.
</div><div class="help-li" style=""> <code>injection.parent</code> - indicates that the captured node’s text should
      be parsed with the same language as the node's parent LanguageTree.
</div></div>
<div class="old-help-para"><h2 id="lua-treesitter" class="help-heading">VIM.TREESITTER<span class="help-heading-tags">                                                <span class="help-tag"><a href="#lua-treesitter">lua-treesitter</a></span></h2></div>
<div class="old-help-para">The remainder of this document is a reference manual for the <code>vim.treesitter</code>
Lua module, which is the main interface for Nvim's tree-sitter integration.
Most of the following content is automatically generated from the function
documentation.</div>
<div class="old-help-para">                                             <code id="vim.treesitter.language_version" class="help-tag-right"><a href="#vim.treesitter.language_version">vim.treesitter.language_version</a></code>
The latest parser ABI version that is supported by the bundled tree-sitter
library.</div>
<div class="old-help-para">                                     <code id="vim.treesitter.minimum_language_version" class="help-tag-right"><a href="#vim.treesitter.minimum_language_version">vim.treesitter.minimum_language_version</a></code>
The earliest parser ABI version that is supported by the bundled tree-sitter
library.</div>
<div class="old-help-para"><h2 id="lua-treesitter-core" class="help-heading">Lua module: vim.treesitter<span class="help-heading-tags">                               <span class="help-tag"><a href="#lua-treesitter-core">lua-treesitter-core</a></span></h2></div>
<div class="old-help-para">foldexpr(<code>{lnum}</code>)                                   <code id="vim.treesitter.foldexpr()" class="help-tag-right"><a href="#vim.treesitter.foldexpr()">vim.treesitter.foldexpr()</a></code>
    Returns the fold level for <code>{lnum}</code> in the current buffer. Can be set
    directly to <a href="options.html#'foldexpr'">'foldexpr'</a>:<pre><code class="language-lua">vim.wo.foldexpr = 'v:lua.vim.treesitter.foldexpr()'</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lnum}</code>  (integer|nil) Line number to calculate fold level for
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (string)</div>
<div class="old-help-para">                                     <code id="vim.treesitter.get_captures_at_cursor()" class="help-tag-right"><a href="#vim.treesitter.get_captures_at_cursor()">vim.treesitter.get_captures_at_cursor()</a></code>
get_captures_at_cursor(<code>{winnr}</code>)
    Returns a list of highlight capture names under the cursor</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{winnr}</code>  (integer|nil) Window handle or 0 for current window (default)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        string[] List of capture names</div>
<div class="old-help-para">                                        <code id="vim.treesitter.get_captures_at_pos()" class="help-tag-right"><a href="#vim.treesitter.get_captures_at_pos()">vim.treesitter.get_captures_at_pos()</a></code>
get_captures_at_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>)
    Returns a list of highlight captures at the given position</div>
<div class="old-help-para">    Each capture is represented by a table containing the capture name as a
    string as well as a table of metadata (<code>priority</code>, <code>conceal</code>, ...; empty
    if none are defined).</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (integer) Buffer number (0 for current buffer)
</div><div class="help-li" style=""> <code>{row}</code>    (integer) Position row
</div><div class="help-li" style=""> <code>{col}</code>    (integer) Position column
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        table[] List of captures <code>{ capture = "name", metadata = { ... } }</code></div>
<div class="old-help-para">get_node(<code>{opts}</code>)                                   <code id="vim.treesitter.get_node()" class="help-tag-right"><a href="#vim.treesitter.get_node()">vim.treesitter.get_node()</a></code>
    Returns the smallest named node at the given position</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> bufnr integer|nil Buffer number (nil or 0 for current
                  buffer)
</div><div class="help-li" style="margin-left: 3rem;"> pos table|nil 0-indexed (row, col) tuple. Defaults to cursor
                  position in the current window. Required if <code>{bufnr}</code> is not
                  the current buffer
</div><div class="help-li" style="margin-left: 3rem;"> ignore_injections boolean Ignore injected languages (default
                  true)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        <a href="treesitter.html#TSNode">TSNode</a> | nil Node at the given position</div>
<div class="old-help-para">get_node_range(<code>{node_or_range}</code>)              <code id="vim.treesitter.get_node_range()" class="help-tag-right"><a href="#vim.treesitter.get_node_range()">vim.treesitter.get_node_range()</a></code>
    Returns the node's range or an unpacked range table</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node_or_range}</code>  (<a href="treesitter.html#TSNode">TSNode</a> | table) Node or table of positions
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return (multiple):</div>        (integer) start_row
        (integer) start_col
        (integer) end_row
        (integer) end_col</div>
<div class="old-help-para">                                              <code id="vim.treesitter.get_node_text()" class="help-tag-right"><a href="#vim.treesitter.get_node_text()">vim.treesitter.get_node_text()</a></code>
get_node_text(<code>{node}</code>, <code>{source}</code>, <code>{opts}</code>)
    Gets the text corresponding to a given node</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>    <a href="treesitter.html#TSNode">TSNode</a>
</div><div class="help-li" style=""> <code>{source}</code>  (integer|string) Buffer or string from which the <code>{node}</code> is
                  extracted
</div><div class="help-li" style=""> <code>{opts}</code>    (table|nil) Optional parameters.
</div><div class="help-li" style="margin-left: 3rem;"> metadata (table) Metadata of a specific capture. This
                    would be set to <code>metadata[capture_id]</code> when using
                    <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a>.
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (string)</div>
<div class="old-help-para">get_parser(<code>{bufnr}</code>, <code>{lang}</code>, <code>{opts}</code>)              <code id="vim.treesitter.get_parser()" class="help-tag-right"><a href="#vim.treesitter.get_parser()">vim.treesitter.get_parser()</a></code>
    Returns the parser for a specific buffer and attaches it to the buffer</div>
<div class="old-help-para">    If needed, this will create the parser.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (integer|nil) Buffer the parser should be tied to (default:
                 current buffer)
</div><div class="help-li" style=""> <code>{lang}</code>   (string|nil) Filetype of this parser (default: buffer
                 filetype)
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Options to pass to the created language tree
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        <a href="treesitter.html#LanguageTree">LanguageTree</a> object to use for parsing</div>
<div class="old-help-para">get_range(<code>{node}</code>, <code>{source}</code>, <code>{metadata}</code>)           <code id="vim.treesitter.get_range()" class="help-tag-right"><a href="#vim.treesitter.get_range()">vim.treesitter.get_range()</a></code>
    Get the range of a <a href="treesitter.html#TSNode">TSNode</a>. Can also supply <code>{source}</code> and <code>{metadata}</code> to
    get the range with directives applied.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>      <a href="treesitter.html#TSNode">TSNode</a>
</div><div class="help-li" style=""> <code>{source}</code>    integer|string|nil Buffer or string from which the <code>{node}</code>
                    is extracted
</div><div class="help-li" style=""> <code>{metadata}</code>  TSMetadata|nil
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (table)</div>
<div class="old-help-para">                                          <code id="vim.treesitter.get_string_parser()" class="help-tag-right"><a href="#vim.treesitter.get_string_parser()">vim.treesitter.get_string_parser()</a></code>
get_string_parser(<code>{str}</code>, <code>{lang}</code>, <code>{opts}</code>)
    Returns a string parser</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{str}</code>   (string) Text to parse
</div><div class="help-li" style=""> <code>{lang}</code>  (string) Language of this string
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Options to pass to the created language tree
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        <a href="treesitter.html#LanguageTree">LanguageTree</a> object to use for parsing</div>
<div class="old-help-para">inspect_tree(<code>{opts}</code>)                           <code id="vim.treesitter.inspect_tree()" class="help-tag-right"><a href="#vim.treesitter.inspect_tree()">vim.treesitter.inspect_tree()</a></code>
    Open a window that displays a textual representation of the nodes in the
    language tree.</div>
<div class="old-help-para">    While in the window, press "a" to toggle display of anonymous nodes, "I"
    to toggle the display of the source language of each node, "o" to toggle
    the query editor, and press <code>&lt;Enter&gt;</code> to jump to the node under the cursor
    in the source buffer.</div>
<div class="old-help-para">    Can also be shown with <code>:InspectTree</code>.                      <code id="%3AInspectTree" class="help-tag-right"><a href="#%3AInspectTree">:InspectTree</a></code></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Optional options table with the following possible
                keys:
</div><div class="help-li" style="margin-left: 3rem;"> lang (string|nil): The language of the source buffer. If
                  omitted, the filetype of the source buffer is used.
</div><div class="help-li" style="margin-left: 3rem;"> bufnr (integer|nil): Buffer to draw the tree into. If
                  omitted, a new buffer is created.
</div><div class="help-li" style="margin-left: 3rem;"> winid (integer|nil): Window id to display the tree buffer
                  in. If omitted, a new window is created with <code>{command}</code>.
</div><div class="help-li" style="margin-left: 3rem;"> command (string|nil): Vimscript command to create the
                  window. Default value is "60vnew". Only used when <code>{winid}</code> is
                  nil.
</div><div class="help-li" style="margin-left: 3rem;"> title (string|fun(bufnr:integer):string|nil): Title of the
                  window. If a function, it accepts the buffer number of the
                  source buffer as its only argument and should return a
                  string.
</div></div>
<div class="old-help-para">is_ancestor(<code>{dest}</code>, <code>{source}</code>)                   <code id="vim.treesitter.is_ancestor()" class="help-tag-right"><a href="#vim.treesitter.is_ancestor()">vim.treesitter.is_ancestor()</a></code>
    Determines whether a node is the ancestor of another</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{dest}</code>    <a href="treesitter.html#TSNode">TSNode</a> Possible ancestor
</div><div class="help-li" style=""> <code>{source}</code>  <a href="treesitter.html#TSNode">TSNode</a> Possible descendant
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (boolean) True if <code>{dest}</code> is an ancestor of <code>{source}</code></div>
<div class="old-help-para">                                           <code id="vim.treesitter.is_in_node_range()" class="help-tag-right"><a href="#vim.treesitter.is_in_node_range()">vim.treesitter.is_in_node_range()</a></code>
is_in_node_range(<code>{node}</code>, <code>{line}</code>, <code>{col}</code>)
    Determines whether (line, col) position is in node range</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>  <a href="treesitter.html#TSNode">TSNode</a> defining the range
</div><div class="help-li" style=""> <code>{line}</code>  (integer) Line (0-based)
</div><div class="help-li" style=""> <code>{col}</code>   (integer) Column (0-based)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (boolean) True if the position is in node range</div>
<div class="old-help-para">node_contains(<code>{node}</code>, <code>{range}</code>)                <code id="vim.treesitter.node_contains()" class="help-tag-right"><a href="#vim.treesitter.node_contains()">vim.treesitter.node_contains()</a></code>
    Determines if a node contains a range</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>   <a href="treesitter.html#TSNode">TSNode</a>
</div><div class="help-li" style=""> <code>{range}</code>  (table)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (boolean) True if the <code>{node}</code> contains the <code>{range}</code></div>
<div class="old-help-para">start(<code>{bufnr}</code>, <code>{lang}</code>)                                <code id="vim.treesitter.start()" class="help-tag-right"><a href="#vim.treesitter.start()">vim.treesitter.start()</a></code>
    Starts treesitter highlighting for a buffer</div>
<div class="old-help-para">    Can be used in an ftplugin or FileType autocommand.</div>
<div class="old-help-para">    Note: By default, disables regex syntax highlighting, which may be
    required for some plugins. In this case, add <code>vim.bo.syntax = 'on'</code> after
    the call to <code>start</code>.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">vim.api.nvim_create_autocmd( 'FileType', { pattern = 'tex',
    callback = function(args)
        vim.treesitter.start(args.buf, 'latex')
        vim.bo[args.buf].syntax = 'on'  -- only if additional legacy syntax is needed
    end
})</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (integer|nil) Buffer to be highlighted (default: current
                 buffer)
</div><div class="help-li" style=""> <code>{lang}</code>   (string|nil) Language of the parser (default: buffer
                 filetype)
</div></div>
<div class="old-help-para">stop(<code>{bufnr}</code>)                                          <code id="vim.treesitter.stop()" class="help-tag-right"><a href="#vim.treesitter.stop()">vim.treesitter.stop()</a></code>
    Stops treesitter highlighting for a buffer</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{bufnr}</code>  (integer|nil) Buffer to stop highlighting (default: current
                 buffer)
</div></div>
<div class="old-help-para"><h2 id="lua-treesitter-language" class="help-heading">Lua module: vim.treesitter.language<span class="help-heading-tags">                  <span class="help-tag"><a href="#lua-treesitter-language">lua-treesitter-language</a></span></h2></div>
<div class="old-help-para">add(<code>{lang}</code>, <code>{opts}</code>)                            <code id="vim.treesitter.language.add()" class="help-tag-right"><a href="#vim.treesitter.language.add()">vim.treesitter.language.add()</a></code>
    Load parser with name <code>{lang}</code></div>
<div class="old-help-para">    Parsers are searched in the <code>parser</code> runtime directory, or the provided
    <code>{path}</code></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (string) Name of the parser (alphanumerical and <code>_</code> only)
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Options:
</div><div class="help-li" style="margin-left: 3rem;"> filetype (string|string[]) Default filetype the parser
                  should be associated with. Defaults to <code>{lang}</code>.
</div><div class="help-li" style="margin-left: 3rem;"> path (string|nil) Optional path the parser is located at
</div><div class="help-li" style="margin-left: 3rem;"> symbol_name (string|nil) Internal symbol name for the
                  language to load
</div></div>
<div class="old-help-para">get_filetypes(<code>{lang}</code>)                <code id="vim.treesitter.language.get_filetypes()" class="help-tag-right"><a href="#vim.treesitter.language.get_filetypes()">vim.treesitter.language.get_filetypes()</a></code>
    Get the filetypes associated with the parser named <code>{lang}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (string) Name of parser
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        string[] filetypes</div>
<div class="old-help-para">get_lang(<code>{filetype}</code>)                      <code id="vim.treesitter.language.get_lang()" class="help-tag-right"><a href="#vim.treesitter.language.get_lang()">vim.treesitter.language.get_lang()</a></code>
<div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{filetype}</code>  (string)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (string|nil)</div>
<div class="old-help-para">inspect(<code>{lang}</code>)                            <code id="vim.treesitter.language.inspect()" class="help-tag-right"><a href="#vim.treesitter.language.inspect()">vim.treesitter.language.inspect()</a></code>
    Inspects the provided language.</div>
<div class="old-help-para">    Inspecting provides some useful information on the language like node
    names, ...</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (string) Language
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (table)</div>
<div class="old-help-para">register(<code>{lang}</code>, <code>{filetype}</code>)              <code id="vim.treesitter.language.register()" class="help-tag-right"><a href="#vim.treesitter.language.register()">vim.treesitter.language.register()</a></code>
    Register a parser named <code>{lang}</code> to be used for <code>{filetype}</code>(s).</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>      (string) Name of parser
</div><div class="help-li" style=""> <code>{filetype}</code>  string|string[] Filetype(s) to associate with lang
</div></div>
<div class="old-help-para"><h2 id="lua-treesitter-query" class="help-heading">Lua module: vim.treesitter.query<span class="help-heading-tags">                        <span class="help-tag"><a href="#lua-treesitter-query">lua-treesitter-query</a></span></h2></div>
<div class="old-help-para">                                        <code id="vim.treesitter.query.add_directive()" class="help-tag-right"><a href="#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a></code>
add_directive(<code>{name}</code>, <code>{handler}</code>, <code>{force}</code>)
    Adds a new directive to be used in queries</div>
<div class="old-help-para">    Handlers can set match level data by setting directly on the metadata
    object <code>metadata.key = value</code>, additionally, handlers can set node level
    data by using the capture id on the metadata table
    <code>metadata[capture_id].key = value</code></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{name}</code>     (string) Name of the directive, without leading #
</div><div class="help-li" style=""> <code>{handler}</code>  function(match:table&lt;string,<a href="treesitter.html#TSNode">TSNode</a>&gt;, pattern:string,
                   bufnr:integer, predicate:string[], metadata:table)
</div><div class="help-li" style="margin-left: 3rem;"> match: see <a href="treesitter.html#treesitter-query">treesitter-query</a>
</div><div class="help-li" style="margin-left: 4rem;"> node-level data are accessible via <code>match[capture_id]</code>
</div></div>
<div class="old-help-para"><div class="help-li" style=""> pattern: see <a href="treesitter.html#treesitter-query">treesitter-query</a>
</div><div class="help-li" style=""> predicate: list of strings containing the full directive
                     being called, e.g. <code>(node (#set! conceal "-"))</code> would get
                     the predicate <code>{ "#set!", "conceal", "-" }</code>
</div><div class="help-li" style=""> <code>{force}</code>    (boolean|nil)
</div></div>
<div class="old-help-para">                                        <code id="vim.treesitter.query.add_predicate()" class="help-tag-right"><a href="#vim.treesitter.query.add_predicate()">vim.treesitter.query.add_predicate()</a></code>
add_predicate(<code>{name}</code>, <code>{handler}</code>, <code>{force}</code>)
    Adds a new predicate to be used in queries</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{name}</code>     (string) Name of the predicate, without leading #
</div><div class="help-li" style=""> <code>{handler}</code>  function(match:table&lt;string,<a href="treesitter.html#TSNode">TSNode</a>&gt;, pattern:string,
                   bufnr:integer, predicate:string[])
</div><div class="help-li" style="margin-left: 3rem;"> see <a href="treesitter.html#vim.treesitter.query.add_directive()">vim.treesitter.query.add_directive()</a> for argument
                     meanings
</div><div class="help-li" style=""> <code>{force}</code>    (boolean|nil)
</div></div>
<div class="old-help-para">edit(<code>{lang}</code>)                                     <code id="vim.treesitter.query.edit()" class="help-tag-right"><a href="#vim.treesitter.query.edit()">vim.treesitter.query.edit()</a></code>
    Opens a live editor to query the buffer you started from.</div>
<div class="old-help-para">    Can also be shown with <code id="%3AEditQuery" class="help-tag"><a href="#%3AEditQuery">:EditQuery</a></code>.</div>
<div class="old-help-para">    If you move the cursor to a capture name ("@foo"), text matching the
    capture is highlighted in the source buffer. The query editor is a scratch
    buffer, use <code>:write</code> to save it. You can find example queries at
    <code>$VIMRUNTIME/queries/</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>  (string|nil) language to open the query editor for. If
                omitted, inferred from the current buffer's filetype.
</div></div>
<div class="old-help-para">get(<code>{lang}</code>, <code>{query_name}</code>)                         <code id="vim.treesitter.query.get()" class="help-tag-right"><a href="#vim.treesitter.query.get()">vim.treesitter.query.get()</a></code>
    Returns the runtime query <code>{query_name}</code> for <code>{lang}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>        (string) Language to use for the query
</div><div class="help-li" style=""> <code>{query_name}</code>  (string) Name of the query (e.g. "highlights")
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        Query|nil Parsed query</div>
<div class="old-help-para">                                            <code id="vim.treesitter.query.get_files()" class="help-tag-right"><a href="#vim.treesitter.query.get_files()">vim.treesitter.query.get_files()</a></code>
get_files(<code>{lang}</code>, <code>{query_name}</code>, <code>{is_included}</code>)
    Gets the list of files used to make up a query</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>         (string) Language to get query for
</div><div class="help-li" style=""> <code>{query_name}</code>   (string) Name of the query to load (e.g., "highlights")
</div><div class="help-li" style=""> <code>{is_included}</code>  (boolean|nil) Internal parameter, most of the time left
                       as <code>nil</code>
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        string[] query_files List of files to load for given query and
        language</div>
<div class="old-help-para">lint(<code>{buf}</code>, <code>{opts}</code>)                              <code id="vim.treesitter.query.lint()" class="help-tag-right"><a href="#vim.treesitter.query.lint()">vim.treesitter.query.lint()</a></code>
    Lint treesitter queries using installed parser, or clear lint errors.</div>
<div class="old-help-para">    Use <a href="treesitter.html#treesitter-parsers">treesitter-parsers</a> in runtimepath to check the query file in <code>{buf}</code>
    for errors:</div>
<div class="old-help-para"><div class="help-li" style=""> verify that used nodes are valid identifiers in the grammar.
</div><div class="help-li" style=""> verify that predicates and directives are valid.
</div><div class="help-li" style=""> verify that top-level s-expressions are valid.
</div></div>
<div class="old-help-para">    The found diagnostics are reported using <a href="diagnostic.html#diagnostic-api">diagnostic-api</a>. By default, the
    parser used for verification is determined by the containing folder of the
    query file, e.g., if the path ends in <code>/lua/highlights.scm</code> , the parser for the <code>lua</code> language will be used.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{buf}</code>   (integer) Buffer handle
</div><div class="help-li" style=""> <code>{opts}</code>  (QueryLinterOpts|nil) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> langs (string|string[]|nil) Language(s) to use for checking
                  the query. If multiple languages are specified, queries are
                  validated for all of them
</div><div class="help-li" style="margin-left: 3rem;"> clear (boolean) if <code>true</code>, just clear current lint errors
</div></div>
<div class="old-help-para">list_directives()                     <code id="vim.treesitter.query.list_directives()" class="help-tag-right"><a href="#vim.treesitter.query.list_directives()">vim.treesitter.query.list_directives()</a></code>
    Lists the currently available directives to use in queries.</div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        string[] List of supported directives.</div>
<div class="old-help-para">list_predicates()                     <code id="vim.treesitter.query.list_predicates()" class="help-tag-right"><a href="#vim.treesitter.query.list_predicates()">vim.treesitter.query.list_predicates()</a></code>
    Lists the currently available predicates to use in queries.</div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        string[] List of supported predicates.</div>
<div class="old-help-para">omnifunc(<code>{findstart}</code>, <code>{base}</code>)                <code id="vim.treesitter.query.omnifunc()" class="help-tag-right"><a href="#vim.treesitter.query.omnifunc()">vim.treesitter.query.omnifunc()</a></code>
    Omnifunc for completing node names and predicates in treesitter queries.</div>
<div class="old-help-para">    Use via<pre><code class="language-lua">vim.bo.omnifunc = 'v:lua.vim.treesitter.query.omnifunc'</code></pre></div>
<div class="old-help-para">parse(<code>{lang}</code>, <code>{query}</code>)                          <code id="vim.treesitter.query.parse()" class="help-tag-right"><a href="#vim.treesitter.query.parse()">vim.treesitter.query.parse()</a></code>
    Parse <code>{query}</code> as a string. (If the query is in a file, the caller should
    read the contents into a string before calling).</div>
<div class="old-help-para">    Returns a <code>Query</code> (see <a href="treesitter.html#lua-treesitter-query">lua-treesitter-query</a>) object which can be used to search nodes in
    the syntax tree for the patterns defined in <code>{query}</code> using <code>iter_*</code> methods below.</div>
<div class="old-help-para">    Exposes <code>info</code> and <code>captures</code> with additional context about <code>{query}</code>.
<div class="help-li" style=""> <code>captures</code> contains the list of unique capture names defined in <code>{query}</code>.
      -`info.captures` also points to <code>captures</code>.
</div><div class="help-li" style=""> <code>info.patterns</code> contains information about predicates.
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>   (string) Language to use for the query
</div><div class="help-li" style=""> <code>{query}</code>  (string) Query in s-expr syntax
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        Query Parsed query</div>
<div class="old-help-para">                                                       <code id="Query%3Aiter_captures()" class="help-tag-right"><a href="#Query%3Aiter_captures()">Query:iter_captures()</a></code>
Query:iter_captures(<code>{node}</code>, <code>{source}</code>, <code>{start}</code>, <code>{stop}</code>)
    Iterate over all captures from all matches inside <code>{node}</code></div>
<div class="old-help-para">    <code>{source}</code> is needed if the query contains predicates; then the caller must
    ensure to use a freshly parsed tree consistent with the current text of
    the buffer (if relevant). <code>{start}</code> and <code>{stop}</code> can be used to limit matches
    inside a row range (this is typically used with root node as the <code>{node}</code>,
    i.e., to get syntax highlight matches in the current viewport). When
    omitted, the <code>{start}</code> and <code>{stop}</code> row values are used from the given node.</div>
<div class="old-help-para">    The iterator returns three values: a numeric id identifying the capture,
    the captured node, and metadata from any directives processing the match.
    The following example shows how to get captures by name:<pre><code class="language-lua">for id, node, metadata in query:iter_captures(tree:root(), bufnr, first, last) do
  local name = query.captures[id] -- name of the capture in the query
  -- typically useful info about the node:
  local type = node:type() -- type of the captured node
  local row1, col1, row2, col2 = node:range() -- range of the capture
  -- ... use the info here ...
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>    <a href="treesitter.html#TSNode">TSNode</a> under which the search will occur
</div><div class="help-li" style=""> <code>{source}</code>  (integer|string) Source buffer or string to extract text
                  from
</div><div class="help-li" style=""> <code>{start}</code>   (integer) Starting line for the search
</div><div class="help-li" style=""> <code>{stop}</code>    (integer) Stopping line for the search (end-exclusive)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (fun(end_line: integer|nil): integer, TSNode, TSMetadata): capture id,
        capture node, metadata</div>
<div class="old-help-para">                                                        <code id="Query%3Aiter_matches()" class="help-tag-right"><a href="#Query%3Aiter_matches()">Query:iter_matches()</a></code>
Query:iter_matches(<code>{node}</code>, <code>{source}</code>, <code>{start}</code>, <code>{stop}</code>, <code>{opts}</code>)
    Iterates the matches of self on a given range.</div>
<div class="old-help-para">    Iterate over all matches within a <code>{node}</code>. The arguments are the same as
    for <a href="treesitter.html#Query%3Aiter_captures()">Query:iter_captures()</a> but the iterated values are different: an
    (1-based) index of the pattern in the query, a table mapping capture
    indices to nodes, and metadata from any directives processing the match.
    If the query has more than one pattern, the capture table might be sparse
    and e.g. <code>pairs()</code> method should be used over <code>ipairs</code>. Here is an example
    iterating over all captures in every match:<pre><code class="language-lua">for pattern, match, metadata in cquery:iter_matches(tree:root(), bufnr, first, last) do
  for id, node in pairs(match) do
    local name = query.captures[id]
    -- `node` was captured by the `name` capture in the match
    local node_data = metadata[id] -- Node level metadata
    -- ... use the info here ...
  end
end</code></pre></div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{node}</code>    <a href="treesitter.html#TSNode">TSNode</a> under which the search will occur
</div><div class="help-li" style=""> <code>{source}</code>  (integer|string) Source buffer or string to search
</div><div class="help-li" style=""> <code>{start}</code>   (integer) Starting line for the search
</div><div class="help-li" style=""> <code>{stop}</code>    (integer) Stopping line for the search (end-exclusive)
</div><div class="help-li" style=""> <code>{opts}</code>    (table|nil) Options:
</div><div class="help-li" style="margin-left: 3rem;"> max_start_depth (integer) if non-zero, sets the maximum
                    start depth for each match. This is used to prevent
                    traversing too deep into a tree. Requires treesitter &gt;=
                    0.20.9.
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (fun(): integer, table&lt;integer,TSNode&gt;, table): pattern id, match,
        metadata</div>
<div class="old-help-para">set(<code>{lang}</code>, <code>{query_name}</code>, <code>{text}</code>)                 <code id="vim.treesitter.query.set()" class="help-tag-right"><a href="#vim.treesitter.query.set()">vim.treesitter.query.set()</a></code>
    Sets the runtime query named <code>{query_name}</code> for <code>{lang}</code></div>
<div class="old-help-para">    This allows users to override any runtime files and/or configuration set
    by plugins.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{lang}</code>        (string) Language to use for the query
</div><div class="help-li" style=""> <code>{query_name}</code>  (string) Name of the query (e.g., "highlights")
</div><div class="help-li" style=""> <code>{text}</code>        (string) Query text (unparsed).
</div></div>
<div class="old-help-para"><h2 id="lua-treesitter-languagetree" class="help-heading">Lua module: vim.treesitter.languagetree<span class="help-heading-tags">          <span class="help-tag"><a href="#lua-treesitter-languagetree">lua-treesitter-languagetree</a></span></h2></div>
<div class="old-help-para">A <code id="LanguageTree" class="help-tag"><a href="#LanguageTree">LanguageTree</a></code> contains a tree of parsers: the root treesitter parser
for <code>{lang}</code> and any "injected" language parsers, which themselves may
inject other languages, recursively. For example a Lua buffer containing
some Vimscript commands needs multiple parsers to fully understand its
contents.</div>
<div class="old-help-para">To create a LanguageTree (parser object) for a given buffer and language, use:<pre><code class="language-lua">local parser = vim.treesitter.get_parser(bufnr, lang)</code></pre></div>
<div class="old-help-para">(where <code>bufnr=0</code> means current buffer). <code>lang</code> defaults to <a href="options.html#'filetype'">'filetype'</a>.
Note: currently the parser is retained for the lifetime of a buffer but
this may change; a plugin should keep a reference to the parser object if
it wants incremental updates.</div>
<div class="old-help-para">Whenever you need to access the current syntax tree, parse the buffer:<pre><code class="language-lua">local tree = parser:parse({ start_row, end_row })</code></pre></div>
<div class="old-help-para">This returns a table of immutable <a href="treesitter.html#treesitter-tree">treesitter-tree</a> objects representing
the current state of the buffer. When the plugin wants to access the state
after a (possible) edit it must call <code>parse()</code> again. If the buffer wasn't
edited, the same tree will be returned again without extra work. If the
buffer was parsed before, incremental parsing will be done of the changed
parts.</div>
<div class="old-help-para">Note: To use the parser directly inside a <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a> Lua
callback, you must call <a href="treesitter.html#vim.treesitter.get_parser()">vim.treesitter.get_parser()</a> before you register
your callback. But preferably parsing shouldn't be done directly in the
change callback anyway as they will be very frequent. Rather a plugin that
does any kind of analysis on a tree should use a timer to throttle too
frequent updates.</div>
<div class="old-help-para">LanguageTree:children()                              <code id="LanguageTree%3Achildren()" class="help-tag-right"><a href="#LanguageTree%3Achildren()">LanguageTree:children()</a></code>
    Returns a map of language to child tree.</div>
<div class="old-help-para">LanguageTree:contains(<code>{range}</code>)                       <code id="LanguageTree%3Acontains()" class="help-tag-right"><a href="#LanguageTree%3Acontains()">LanguageTree:contains()</a></code>
    Determines whether <code>{range}</code> is contained in the <a href="treesitter.html#LanguageTree">LanguageTree</a>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (table) <code>{ start_line, start_col, end_line, end_col }</code>
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (boolean)</div>
<div class="old-help-para">LanguageTree:destroy()                                <code id="LanguageTree%3Adestroy()" class="help-tag-right"><a href="#LanguageTree%3Adestroy()">LanguageTree:destroy()</a></code>
    Destroys this <a href="treesitter.html#LanguageTree">LanguageTree</a> and all its children.</div>
<div class="old-help-para">    Any cleanup logic should be performed here.</div>
<div class="old-help-para">    Note: This DOES NOT remove this tree from a parent. Instead,
    <code>remove_child</code> must be called on the parent to remove it.</div>
<div class="old-help-para">LanguageTree:for_each_tree(<code>{fn}</code>)                <code id="LanguageTree%3Afor_each_tree()" class="help-tag-right"><a href="#LanguageTree%3Afor_each_tree()">LanguageTree:for_each_tree()</a></code>
    Invokes the callback for each <a href="treesitter.html#LanguageTree">LanguageTree</a> recursively.</div>
<div class="old-help-para">    Note: This includes the invoking tree's child trees as well.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{fn}</code>  fun(tree: TSTree, ltree: LanguageTree)
</div></div>
<div class="old-help-para">LanguageTree:included_regions()              <code id="LanguageTree%3Aincluded_regions()" class="help-tag-right"><a href="#LanguageTree%3Aincluded_regions()">LanguageTree:included_regions()</a></code>
    Gets the set of included regions managed by this LanguageTree . This can be different from the regions set by injection query, because a
    partial <a href="treesitter.html#LanguageTree%3Aparse()">LanguageTree:parse()</a> drops the regions outside the requested
    range.</div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        table&lt;integer, Range6[]&gt;</div>
<div class="old-help-para">LanguageTree:invalidate(<code>{reload}</code>)                  <code id="LanguageTree%3Ainvalidate()" class="help-tag-right"><a href="#LanguageTree%3Ainvalidate()">LanguageTree:invalidate()</a></code>
    Invalidates this parser and all its children</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{reload}</code>  (boolean|nil)
</div></div>
<div class="old-help-para">LanguageTree:is_valid(<code>{exclude_children}</code>)            <code id="LanguageTree%3Ais_valid()" class="help-tag-right"><a href="#LanguageTree%3Ais_valid()">LanguageTree:is_valid()</a></code>
    Returns whether this LanguageTree is valid, i.e., <a href="treesitter.html#LanguageTree%3Atrees()">LanguageTree:trees()</a> reflects the latest state of the
    source. If invalid, user should call <a href="treesitter.html#LanguageTree%3Aparse()">LanguageTree:parse()</a>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{exclude_children}</code>  (boolean|nil) whether to ignore the validity of
                            children (default <code>false</code>)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        (boolean)</div>
<div class="old-help-para">LanguageTree:lang()                                      <code id="LanguageTree%3Alang()" class="help-tag-right"><a href="#LanguageTree%3Alang()">LanguageTree:lang()</a></code>
    Gets the language of this tree node.</div>
<div class="old-help-para">                                           <code id="LanguageTree%3Alanguage_for_range()" class="help-tag-right"><a href="#LanguageTree%3Alanguage_for_range()">LanguageTree:language_for_range()</a></code>
LanguageTree:language_for_range(<code>{range}</code>)
    Gets the appropriate language that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (table) <code>{ start_line, start_col, end_line, end_col }</code>
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        <a href="treesitter.html#LanguageTree">LanguageTree</a> Managing <code>{range}</code></div>
<div class="old-help-para">                                         <code id="LanguageTree%3Anamed_node_for_range()" class="help-tag-right"><a href="#LanguageTree%3Anamed_node_for_range()">LanguageTree:named_node_for_range()</a></code>
LanguageTree:named_node_for_range(<code>{range}</code>, <code>{opts}</code>)
    Gets the smallest named node that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (table) <code>{ start_line, start_col, end_line, end_col }</code>
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> ignore_injections boolean Ignore injected languages
                   (default true)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        <a href="treesitter.html#TSNode">TSNode</a> | nil Found node</div>
<div class="old-help-para">LanguageTree:parse(<code>{range}</code>)                             <code id="LanguageTree%3Aparse()" class="help-tag-right"><a href="#LanguageTree%3Aparse()">LanguageTree:parse()</a></code>
    Recursively parse all regions in the language tree using
    <a href="treesitter.html#treesitter-parsers">treesitter-parsers</a> for the corresponding languages and run injection
    queries on the parsed trees to determine whether child trees should be
    created and parsed.</div>
<div class="old-help-para">    Any region with empty range (<code>{}</code>, typically only the root tree) is always
    parsed; otherwise (typically injections) only if it intersects <code>{range}</code> (or
    if <code>{range}</code> is <code>true</code>).</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{range}</code>  boolean|Range|nil: Parse this range in the parser's source.
                 Set to <code>true</code> to run a complete parse of the source (Note:
                 Can be slow!) Set to <code>false|nil</code> to only parse regions with
                 empty ranges (typically only the root tree without
                 injections).
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        table&lt;integer, TSTree&gt;</div>
<div class="old-help-para">                                                 <code id="LanguageTree%3Aregister_cbs()" class="help-tag-right"><a href="#LanguageTree%3Aregister_cbs()">LanguageTree:register_cbs()</a></code>
LanguageTree:register_cbs(<code>{cbs}</code>, <code>{recursive}</code>)
    Registers callbacks for the <a href="treesitter.html#LanguageTree">LanguageTree</a>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{cbs}</code>        (table) An <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a>-like table argument with
                     the following handlers:
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_bytes</code> : see <a href="api.html#nvim_buf_attach()">nvim_buf_attach()</a>, but this will be called after the parsers callback.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_changedtree</code> : a callback that will be called every
                       time the tree has syntactical changes. It will be
                       passed two arguments: a table of the ranges (as node
                       ranges) that changed and the changed tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_child_added</code> : emitted when a child is added to the
                       tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_child_removed</code> : emitted when a child is removed
                       from the tree.
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_detach</code> : emitted when the buffer is detached, see
                       <a href="api.html#nvim_buf_detach_event">nvim_buf_detach_event</a>. Takes one argument, the number
                       of the buffer.
</div><div class="help-li" style=""> <code>{recursive}</code>  (boolean|nil) Apply callbacks recursively for all
                     children. Any new children will also inherit the
                     callbacks.
</div></div>
<div class="old-help-para">LanguageTree:source()                                  <code id="LanguageTree%3Asource()" class="help-tag-right"><a href="#LanguageTree%3Asource()">LanguageTree:source()</a></code>
    Returns the source content of the language tree (bufnr or string).</div>
<div class="old-help-para">                                               <code id="LanguageTree%3Atree_for_range()" class="help-tag-right"><a href="#LanguageTree%3Atree_for_range()">LanguageTree:tree_for_range()</a></code>
LanguageTree:tree_for_range(<code>{range}</code>, <code>{opts}</code>)
    Gets the tree that contains <code>{range}</code>.</div>
<div class="old-help-para"><div class="help-column_heading">    Parameters:</div><div class="help-li" style=""> <code>{range}</code>  (table) <code>{ start_line, start_col, end_line, end_col }</code>
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> ignore_injections boolean Ignore injected languages
                   (default true)
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        TSTree|nil</div>
<div class="old-help-para">LanguageTree:trees()                                    <code id="LanguageTree%3Atrees()" class="help-tag-right"><a href="#LanguageTree%3Atrees()">LanguageTree:trees()</a></code>
    Returns all trees of the regions parsed by this parser. Does not include
    child languages. The result is list-like if
<div class="help-li" style=""> this LanguageTree is the root, in which case the result is empty or a singleton list; or
</div><div class="help-li" style=""> the root LanguageTree is fully parsed.
</div></div>
<div class="old-help-para"><div class="help-column_heading">    Return:</div>        table&lt;integer, TSTree&gt;</div>

  </div>
      <div class="col-narrow toc">
      <div><a href="index.html">Main</a></div>
      <div><a href="vimindex.html">Commands index</a></div>
      <div><a href="quickref.html">Quick reference</a></div>
      <hr/>
  <div class="help-toc-h1"><a href="#treesitter-parsers">
PARSER FILES                                              </a>
</div><div class="help-toc-h1"><a href="#treesitter-tree">
TREESITTER TREES                                             </a>
</div><div class="help-toc-h1"><a href="#treesitter-node">
TREESITTER NODES                                             </a>
</div><div class="help-toc-h1"><a href="#treesitter-query">
TREESITTER QUERIES                                          </a>
<div class="help-toc-h2"><a href="#treesitter-predicates">TREESITTER QUERY PREDICATES                            </a></div>
<div class="help-toc-h2"><a href="#treesitter-directives">TREESITTER QUERY DIRECTIVES                            </a></div>
<div class="help-toc-h2"><a href="#treesitter-query-modeline">TREESITTER QUERY MODELINES                          </a></div>
</div><div class="help-toc-h1"><a href="#treesitter-highlight">
TREESITTER SYNTAX HIGHLIGHTING                          </a>
</div><div class="help-toc-h1"><a href="#treesitter-language-injections">
TREESITTER LANGUAGE INJECTIONS                </a>
</div><div class="help-toc-h1"><a href="#lua-treesitter">
VIM.TREESITTER                                                </a>
</div><div class="help-toc-h1"><a href="#lua-treesitter-core">
Lua module: vim.treesitter                               </a>
</div><div class="help-toc-h1"><a href="#lua-treesitter-language">
Lua module: vim.treesitter.language                  </a>
</div><div class="help-toc-h1"><a href="#lua-treesitter-query">
Lua module: vim.treesitter.query                        </a>
</div><div class="help-toc-h1"><a href="#lua-treesitter-languagetree">
Lua module: vim.treesitter.languagetree          </a>
</div></div>
</div>
  <footer>
    <div class="container flex">
      <div class="generator-stats">
        Generated at 2023-09-28 05:27 from <code><a href="https://github.com/neovim/neovim/commit/19130415183763a572c50c8ae343dff8cc20526e">1913041</a></code>
      </div>
      <div class="generator-stats">
      parse_errors: 0 (<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML%3A+treesitter.txt+&body=%60gen_help_html.lua%60+problem+at%3A+https://neovim.io/doc/user/treesitter.html%0D%0DContext%3A%0D%0D%60%60%60%0DTODO%0D%60%60%60" target="_blank">report docs bug...</a>) | <span title="    Nvim
                            NVIM REFERENCE MANUAL
                                      Type &lt;a href="various.html#gO"&gt;gO&lt;/a&gt; to see the table of contents.
 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:">noise_lines: 4</span>
      </div>
    <div>

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
    <script type="module">
      docsearch({
        container: '#docsearch',
        appId: 'X185E15FPG',
        apiKey: 'b5e6b2f9c636b2b471303205e59832ed',
        indexName: 'nvim',
      });
    </script>

  </footer>
  </body>
</html>
