<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Vim documentation: usr_41</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <div class="site-nav">
          <ul>
            <li><a href="/">Neovim Home</a></li>
          </ul>
        </div>
        <a href="/"><img class="logo" alt="Vim documentation: usr_41" src="/images/logo@2x.png" /></a>
      </div>
    </header>

    <div class="container">
      <h1>Vim documentation: usr_41</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="usr_41.txt"></A><B>usr_41.txt</B>*	For Vim version 7.4.  Last change: 2014 Aug 16

		     VIM USER MANUAL - by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>

			      Write a Vim <A HREF="#script">script</A>


The Vim <A HREF="#script">script</A> language is used for the <A HREF="starting.html#startup">startup</A> <A HREF="starting.html#vimrc">vimrc</A> file, <A HREF="syntax.html#syntax">syntax</A> files, and
many other things.  This chapter explains the items that can be used in a Vim
<A HREF="#script">script</A>.  There are a lot of them, thus this is a long chapter.

|<A HREF="#41.1">41.1</A>|	Introduction
|<A HREF="#41.2">41.2</A>|	Variables
|<A HREF="#41.3">41.3</A>|	Expressions
|<A HREF="#41.4">41.4</A>|	Conditionals
|<A HREF="#41.5">41.5</A>|	Executing an <A HREF="eval.html#expression">expression</A>
|<A HREF="#41.6">41.6</A>|	Using <A HREF="eval.html#functions">functions</A>
|<A HREF="#41.7">41.7</A>|	Defining a function
|<A HREF="#41.8">41.8</A>|	<A HREF="eval.html#Lists">Lists</A> and <A HREF="eval.html#Dictionaries">Dictionaries</A>
|<A HREF="#41.9">41.9</A>|	Exceptions
|<A HREF="#41.10">41.10</A>|	Various remarks
|<A HREF="#41.11">41.11</A>|	Writing a <A HREF="usr_05.html#plugin">plugin</A>
|<A HREF="#41.12">41.12</A>|	Writing a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>
|<A HREF="#41.13">41.13</A>|	Writing a compiler <A HREF="usr_05.html#plugin">plugin</A>
|<A HREF="#41.14">41.14</A>|	Writing a <A HREF="usr_05.html#plugin">plugin</A> that loads quickly
|<A HREF="#41.15">41.15</A>|	Writing library scripts
|<A HREF="#41.16">41.16</A>|	Distributing Vim scripts

     Next chapter: |<A HREF="usr_42.html">usr_42.txt</A>|  Add new <A HREF="gui.html#menus">menus</A>
 Previous chapter: |<A HREF="usr_40.html">usr_40.txt</A>|  Make new commands
Table of contents: |<A HREF="usr_toc.html">usr_toc.txt</A>|

==============================================================================

*<A NAME="41.1"></A><B>41.1</B>*	Introduction				*<A NAME="vim-script-intro"></A><B>vim-script-intro</B>* *<A NAME="script"></A><B>script</B>*

Your first experience with Vim scripts is the <A HREF="starting.html#vimrc">vimrc</A> file.  Vim reads <A HREF="motion.html#it">it</A> when
<A HREF="motion.html#it">it</A> starts up and executes the commands.  You can set <A HREF="options.html#options">options</A> to values you
prefer.  And you can use any colon command in <A HREF="motion.html#it">it</A> (commands that start with a
&quot;<A HREF="cmdline.html#:">:</A>&quot;; these are sometimes referred to <A HREF="motion.html#as">as</A> <A HREF="intro.html#Ex">Ex</A> commands or command-line commands).
   <A HREF="autocmd.html#Syntax">Syntax</A> files are also Vim scripts.  As are files that set <A HREF="options.html#options">options</A> for a
specific file type.  A complicated <A HREF="map.html#macro">macro</A> can be defined by a separate Vim
<A HREF="#script">script</A> file.  You can think of other uses yourself.

Let's start with a simple example:

<B>	:let i = 1</B>
<B>	:while i &lt; 5</B>
<B>	:  echo "count is" i</B>
<B>	:  let i += 1</B>
<B>	:endwhile</B>
 
	Note:
	The &quot;<A HREF="cmdline.html#:">:</A>&quot; characters are not really needed here.  You only need to use
	them when you type a command.  In a Vim <A HREF="#script">script</A> file they can be left
	out.  We will use them here anyway to make clear these are colon
	commands and make them stand out from <A HREF="intro.html#Normal">Normal</A> mode commands.
	Note:
	You can try out the examples by yanking the lines from the text here
	and executing them with :@&quot;

The output of the example code is:

<B><FONT color="#54A23D">	count is 1 </FONT></B>
<B><FONT color="#54A23D">	count is 2 </FONT></B>
<B><FONT color="#54A23D">	count is 3 </FONT></B>
<B><FONT color="#54A23D">	count is 4 </FONT></B>

In the first line the &quot;<A HREF="eval.html#:let">:let</A>&quot; command assigns a value to a variable.  The
generic form is:

<B>	:let {variable} = {expression}</B>

In this <A HREF="change.html#case">case</A> the variable name is &quot;<A HREF="insert.html#i">i</A>&quot; and the <A HREF="eval.html#expression">expression</A> is a simple value,
the number one.
   The &quot;<A HREF="eval.html#:while">:while</A>&quot; command starts a loop.  The generic form is:

<B>	:while {condition}</B>
<B>	:  {statements}</B>
<B>	:endwhile</B>

The statements until the matching &quot;<A HREF="eval.html#:endwhile">:endwhile</A>&quot; are executed for <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> the
condition is true.  The condition used here is the <A HREF="eval.html#expression">expression</A> &quot;<A HREF="insert.html#i">i</A> <A HREF="change.html#&lt;">&lt;</A> 5&quot;.  This
is true when the variable <A HREF="insert.html#i">i</A> is smaller than five.
	Note:
	If you happen to write a while loop that keeps on running, you can
	interrupt <A HREF="motion.html#it">it</A> by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A> (CTRL-Break on <A HREF="os_win32.html#MS-Windows">MS-Windows</A>).

The &quot;<A HREF="eval.html#:echo">:echo</A>&quot; command prints its arguments.  In this <A HREF="change.html#case">case</A> the <A HREF="eval.html#string">string</A> &quot;<A HREF="intro.html#count">count</A> is&quot;
and the value of the variable <A HREF="insert.html#i">i</A>.  Since <A HREF="insert.html#i">i</A> is one, this will print:

<B><FONT color="#54A23D">	count is 1 </FONT></B>

Then there is the &quot;<A HREF="eval.html#:let">:let</A> <A HREF="insert.html#i">i</A> += 1&quot; command.  This does the same thing <A HREF="motion.html#as">as</A>
&quot;<A HREF="eval.html#:let">:let</A> <A HREF="insert.html#i">i</A> = <A HREF="insert.html#i">i</A> + 1&quot;.  This adds one to the variable <A HREF="insert.html#i">i</A> and assigns the new value
to the same variable.

The example was given to explain the commands, but would you really want to
make such a loop <A HREF="motion.html#it">it</A> can be written much more compact:

<B>	:for i in range(1, 4)</B>
<B>	:  echo "count is" i</B>
<B>	:endfor</B>

We won't explain how |<A HREF="eval.html#:for">:for</A>| and |<A HREF="eval.html#range()">range()</A>| work until later.  Follow the links
if you are impatient.


THREE KINDS OF NUMBERS

Numbers can be decimal, hexadecimal or <A HREF="eval.html#octal">octal</A>.  A hexadecimal number starts
with &quot;0x&quot; or &quot;0X&quot;.  For example &quot;0x1f&quot; is decimal 31.  An <A HREF="eval.html#octal">octal</A> number starts
with a zero.  &quot;017&quot; is decimal 15.  Careful: don't put a zero before a decimal
number, <A HREF="motion.html#it">it</A> will be interpreted <A HREF="motion.html#as">as</A> an <A HREF="eval.html#octal">octal</A> number!
   The &quot;<A HREF="eval.html#:echo">:echo</A>&quot; command always prints decimal numbers.  Example:

<B>	:echo 0x7f 036</B>
<B><FONT color="#54A23D"> 	127 30 </FONT></B>

A number is made negative with a minus sign.  This also works for hexadecimal
and <A HREF="eval.html#octal">octal</A> numbers.   A minus sign is also used for subtraction.  Compare this
with the previous example:

<B>	:echo 0x7f -036</B>
<B><FONT color="#54A23D"> 	97 </FONT></B>

White space in an <A HREF="eval.html#expression">expression</A> is ignored.  However, it's recommended to use <A HREF="motion.html#it">it</A>
for separating items, to make the <A HREF="eval.html#expression">expression</A> easier to read.  For example, to
avoid the confusion with a negative number above, put a space between the
minus sign and the following number:

<B>	:echo 0x7f - 036</B>

==============================================================================

*<A NAME="41.2"></A><B>41.2</B>*	Variables

A variable name consists of ASCII letters, digits and the underscore.  It
cannot start with a digit.  Valid variable names are:

	counter
	_aap3
	very_long_variable_name_with_underscores
	FuncLength
	LENGTH

Invalid names are &quot;foo+bar&quot; and &quot;6var&quot;.
   These <A HREF="eval.html#variables">variables</A> are global.  To see a <A HREF="eval.html#list">list</A> of currently defined <A HREF="eval.html#variables">variables</A>
use this command:

<B>	:let</B>

You can use global <A HREF="eval.html#variables">variables</A> everywhere.  This also means that when the
variable &quot;<A HREF="intro.html#count">count</A>&quot; is used in one <A HREF="#script">script</A> file, <A HREF="motion.html#it">it</A> might also be used in another
file.  This leads to confusion at least, and real problems at worst.  To avoid
this, you can use a variable local to a <A HREF="#script">script</A> file by prepending &quot;s:&quot;.  For
example, one <A HREF="#script">script</A> contains this code:

<B>	:let s:count = 1</B>
<B>	:while s:count &lt; 5</B>
<B>	:  source other.vim</B>
<B>	:  let s:count += 1</B>
<B>	:endwhile</B>

Since &quot;s:count&quot; is local to this <A HREF="#script">script</A>, you can be sure that sourcing the
&quot;other.vim&quot; <A HREF="#script">script</A> will not change this variable.  If &quot;other.vim&quot; also uses an
&quot;s:count&quot; variable, <A HREF="motion.html#it">it</A> will be a different copy, local to that <A HREF="#script">script</A>.  More
about <A HREF="map.html#script-local">script-local</A> <A HREF="eval.html#variables">variables</A> here: |<A HREF="eval.html#script-variable">script-variable</A>|.

There are more kinds of variables, see |<A HREF="eval.html#internal-variables">internal-variables</A>|.  The most often
used ones are:

	b:name		variable local to a buffer
	w:name		variable local to a <A HREF="windows.html#window">window</A>
	g:name		global variable (also in a function)
	v:name		variable predefined by Vim


DELETING VARIABLES

Variables take up memory and show up in the output of the &quot;<A HREF="eval.html#:let">:let</A>&quot; command.  To
delete a variable use the &quot;<A HREF="eval.html#:unlet">:unlet</A>&quot; command.  Example:

<B>	:unlet s:count</B>

This deletes the <A HREF="map.html#script-local">script-local</A> variable &quot;s:count&quot; to free up the memory <A HREF="motion.html#it">it</A>
uses.  If you are not sure if the variable exists, and don't want an error
message when <A HREF="motion.html#it">it</A> doesn't, append !:

<B>	:unlet! s:count</B>

When a <A HREF="#script">script</A> finishes, the local <A HREF="eval.html#variables">variables</A> used there will not be
automatically freed.  The next time the <A HREF="#script">script</A> executes, <A HREF="motion.html#it">it</A> can still use the
old value.  Example:

<B>	:if !exists("s:call_count")</B>
<B>	:  let s:call_count = 0</B>
<B>	:endif</B>
<B>	:let s:call_count = s:call_count + 1</B>
<B>	:echo "called" s:call_count "times"</B>

The &quot;<A HREF="eval.html#exists()">exists()</A>&quot; function checks if a variable has already been defined.  Its
argument is the name of the variable you want to check.  Not the variable
itself!  If you would <A HREF="diff.html#do">do</A> this:

<B>	:if !exists(s:call_count)</B>

Then the value of s:call_count will be used <A HREF="motion.html#as">as</A> the name of the variable that
<A HREF="eval.html#exists()">exists()</A> checks.  That's not what you want.
   The exclamation <A HREF="motion.html#mark">mark</A> ! negates a value.  When the value was true, <A HREF="motion.html#it">it</A>
becomes false.  When <A HREF="motion.html#it">it</A> was false, <A HREF="motion.html#it">it</A> becomes true.  You can read <A HREF="motion.html#it">it</A> <A HREF="motion.html#as">as</A> &quot;not&quot;.
Thus &quot;if !exists()&quot; can be read <A HREF="motion.html#as">as</A> &quot;if not exists()&quot;.
   What Vim calls true is anything that is not zero.  Zero is false.
	Note:
	Vim automatically converts a <A HREF="eval.html#string">string</A> to a number when <A HREF="motion.html#it">it</A> is looking for
	a number.  When using a <A HREF="eval.html#string">string</A> that doesn't start with a digit the
	resulting number is zero.  Thus look out for this:
<B>		:if "true"</B>
 	The &quot;true&quot; will be interpreted <A HREF="motion.html#as">as</A> a zero, thus <A HREF="motion.html#as">as</A> false!


STRING VARIABLES AND CONSTANTS

So far only numbers were used for the variable value.  Strings can be used <A HREF="motion.html#as">as</A>
well.  Numbers and strings are the basic types of <A HREF="eval.html#variables">variables</A> that Vim supports.
The type is dynamic, <A HREF="motion.html#it">it</A> is set each time when assigning a value to the
variable with &quot;<A HREF="eval.html#:let">:let</A>&quot;.  More about types in |<A HREF="#41.8">41.8</A>|.
   To assign a <A HREF="eval.html#string">string</A> value to a variable, you need to use a <A HREF="eval.html#string">string</A> constant.
There are two types of these.  First the <A HREF="eval.html#string">string</A> in double <A HREF="quotes.html#quotes">quotes</A>:

<B>	:let name = "peter"</B>
<B>	:echo name</B>
<B><FONT color="#54A23D"> 	peter </FONT></B>

If you want to include a double <A HREF="change.html#quote">quote</A> inside the <A HREF="eval.html#string">string</A>, put a <A HREF="intro.html#backslash">backslash</A> in
front of <A HREF="motion.html#it">it</A>:

<B>	:let name = "\"peter\""</B>
<B>	:echo name</B>
<B><FONT color="#54A23D"> 	"peter" </FONT></B>

To avoid the need for a <A HREF="intro.html#backslash">backslash</A>, you can use a <A HREF="eval.html#string">string</A> in single <A HREF="quotes.html#quotes">quotes</A>:

<B>	:let name = '"peter"'</B>
<B>	:echo name</B>
<B><FONT color="#54A23D"> 	"peter" </FONT></B>

Inside a single-quote <A HREF="eval.html#string">string</A> all the characters are <A HREF="motion.html#as">as</A> they are.  Only the
single <A HREF="change.html#quote">quote</A> itself is special: you need to use two to get one.  A <A HREF="intro.html#backslash">backslash</A>
is taken literally, thus you can't use <A HREF="motion.html#it">it</A> to change the meaning of the
character after <A HREF="motion.html#it">it</A>.
   In double-quote strings <A HREF="motion.html#it">it</A> is possible to use special characters.  Here are
a few useful ones:

	\t		<A HREF="motion.html#&lt;Tab&gt;">&lt;Tab&gt;</A>
	\n		<A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>, line break
	\r		<A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>, <A HREF="intro.html#&lt;Enter&gt;">&lt;Enter&gt;</A>
	\e		<A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>
	\b		<A HREF="motion.html#&lt;BS&gt;">&lt;BS&gt;</A>, backspace
	\&quot;		&quot;
	\\		\, <A HREF="intro.html#backslash">backslash</A>
	\&lt;Esc&gt;		<A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>
	\&lt;C-W&gt;		<A HREF="vimindex.html#CTRL-W">CTRL-W</A>

The last two are just examples.  The  &quot;\&lt;name&gt;&quot; form can be used to include
the special key &quot;name&quot;.
   See |<A HREF="eval.html#expr-quote">expr-quote</A>| for the full <A HREF="eval.html#list">list</A> of special items in a <A HREF="eval.html#string">string</A>.

==============================================================================

*<A NAME="41.3"></A><B>41.3</B>*	Expressions

Vim has a rich, yet simple way to handle expressions.  You can read the
definition here: |<A HREF="eval.html#expression-syntax">expression-syntax</A>|.  Here we will show the most common
items.
   The numbers, strings and <A HREF="eval.html#variables">variables</A> mentioned above are expressions by
themselves.  Thus everywhere an <A HREF="eval.html#expression">expression</A> is expected, you can use a number,
<A HREF="eval.html#string">string</A> or variable.  Other basic items in an <A HREF="eval.html#expression">expression</A> are:

	$NAME		environment variable
	&amp;name		option
	<A HREF="eval.html#@r">@r</A>		<A HREF="sponsor.html#register">register</A>

Examples:

<B>	:echo "The value of 'tabstop' is" &amp;ts</B>
<B>	:echo "Your home directory is" $HOME</B>
<B>	:if @a &gt; 5</B>

The &amp;name form can be used to save an option value, set <A HREF="motion.html#it">it</A> to a new value,
<A HREF="diff.html#do">do</A> something and restore the old value.  Example:

<B>	:let save_ic = &amp;ic</B>
<B>	:set noic</B>
<B>	:/The Start/,$delete</B>
<B>	:let &amp;ic = save_ic</B>

This makes sure the &quot;The Start&quot; <A HREF="pattern.html#pattern">pattern</A> is used with the <A HREF="options.html#'ignorecase'">'ignorecase'</A> option
off.  Still, <A HREF="motion.html#it">it</A> keeps the value that the user had set.  (Another way to <A HREF="diff.html#do">do</A>
this would be to add &quot;\C&quot; to the <A HREF="pattern.html#pattern">pattern</A>, see |<A HREF="pattern.html#/\C">/\C</A>|.)


MATHEMATICS

It becomes more interesting if we combine these basic items.  Let's start with
mathematics on numbers:

	a + <A HREF="motion.html#b">b</A>		add
	a - <A HREF="motion.html#b">b</A>		subtract
	a &#42; <A HREF="motion.html#b">b</A>		multiply
	a / <A HREF="motion.html#b">b</A>		divide
	a <A HREF="motion.html#&#37;">&#37;</A> <A HREF="motion.html#b">b</A>		modulo

The usual precedence is used.  Example:

<B>	:echo 10 + 5 * 2</B>
<B><FONT color="#54A23D"> 	20 </FONT></B>

Grouping is done with parentheses.  No surprises here.  Example:

<B>	:echo (10 + 5) * 2</B>
<B><FONT color="#54A23D"> 	30 </FONT></B>

Strings can be concatenated with &quot;<A HREF="repeat.html#.">.</A>&quot;.  Example:

<B>	:echo "foo" . "bar"</B>
<B><FONT color="#54A23D"> 	foobar </FONT></B>

When the &quot;<A HREF="eval.html#:echo">:echo</A>&quot; command gets multiple arguments, <A HREF="motion.html#it">it</A> separates them with a
space.  In the example the argument is a single <A HREF="eval.html#expression">expression</A>, thus no space is
inserted.

Borrowed from the C language is the conditional <A HREF="eval.html#expression">expression</A>:

	a ? <A HREF="motion.html#b">b</A> : <A HREF="change.html#c">c</A>

If &quot;<A HREF="insert.html#a">a</A>&quot; evaluates to true &quot;<A HREF="motion.html#b">b</A>&quot; is used, otherwise &quot;<A HREF="change.html#c">c</A>&quot; is used.  Example:

<B>	:let i = 4</B>
<B>	:echo i &gt; 5 ? "i is big" : "i is small"</B>
<B><FONT color="#54A23D"> 	i is small </FONT></B>

The three parts of the constructs are always evaluated first, thus you could
see <A HREF="motion.html#it">it</A> work <A HREF="motion.html#as">as</A>:

	(a) ? (b) : (c)

==============================================================================

*<A NAME="41.4"></A><B>41.4</B>*	Conditionals

The &quot;<A HREF="eval.html#:if">:if</A>&quot; commands executes the following statements, until the matching
&quot;<A HREF="eval.html#:endif">:endif</A>&quot;, only when a condition is met.  The generic form is:

	<A HREF="eval.html#:if">:if</A> {condition}
	   {statements}
	<A HREF="eval.html#:endif">:endif</A>

Only when the <A HREF="eval.html#expression">expression</A> {condition} evaluates to true (non-zero) will the
{statements} be executed.  These must still be valid commands.  If they
contain garbage, Vim won't be able to find the &quot;<A HREF="eval.html#:endif">:endif</A>&quot;.
   You can also use &quot;<A HREF="eval.html#:else">:else</A>&quot;.  The generic form for this is:

	<A HREF="eval.html#:if">:if</A> {condition}
	   {statements}
	<A HREF="eval.html#:else">:else</A>
	   {statements}
	<A HREF="eval.html#:endif">:endif</A>

The second {statements} is only executed if the first one isn't.
   Finally, there is &quot;<A HREF="eval.html#:elseif">:elseif</A>&quot;:

	<A HREF="eval.html#:if">:if</A> {condition}
	   {statements}
	<A HREF="eval.html#:elseif">:elseif</A> {condition}
	   {statements}
	<A HREF="eval.html#:endif">:endif</A>

This works just like using &quot;<A HREF="eval.html#:else">:else</A>&quot; and then &quot;if&quot;, but without the need for an
extra &quot;<A HREF="eval.html#:endif">:endif</A>&quot;.
   A useful example for your <A HREF="starting.html#vimrc">vimrc</A> file is checking the <A HREF="options.html#'term'">'term'</A> option and
doing something depending upon its value:

<B>	:if &amp;term == "xterm"</B>
<B>	:  " Do stuff for xterm</B>
<B>	:elseif &amp;term == "vt100"</B>
<B>	:  " Do stuff for a vt100 terminal</B>
<B>	:else</B>
<B>	:  " Do something for other terminals</B>
<B>	:endif</B>


LOGIC OPERATIONS

We already used some of them in the examples.  These are the most often used
ones:

	a <A HREF="change.html#==">==</A> <A HREF="motion.html#b">b</A>		equal to
	a != <A HREF="motion.html#b">b</A>		not equal to
	a <A HREF="change.html#&gt;">&gt;</A>  <A HREF="motion.html#b">b</A>		greater than
	a &gt;= <A HREF="motion.html#b">b</A>		greater than or equal to
	a <A HREF="change.html#&lt;">&lt;</A>  <A HREF="motion.html#b">b</A>		<A HREF="various.html#less">less</A> than
	a &lt;= <A HREF="motion.html#b">b</A>		<A HREF="various.html#less">less</A> than or equal to

The result is one if the condition is met and zero otherwise.  An example:

<B>	:if v:version &gt;= 700</B>
<B>	:  echo "congratulations"</B>
<B>	:else</B>
<B>	:  echo "you are using an old version, upgrade!"</B>
<B>	:endif</B>

Here &quot;<A HREF="eval.html#v:version">v:version</A>&quot; is a variable defined by Vim, which has the value of the Vim
version.  600 is for version 6.0.  Version 6.1 has the value 601.  This is
very useful to write a <A HREF="#script">script</A> that works with multiple versions of Vim.
|<A HREF="eval.html#v:version">v:version</A>|

The logic operators work both for numbers and strings.  When comparing two
strings, the mathematical difference is used.  This compares byte values,
which may not be right for some languages.
   When comparing a <A HREF="eval.html#string">string</A> with a number, the <A HREF="eval.html#string">string</A> is first converted to a
number.  This is a bit tricky, because when a <A HREF="eval.html#string">string</A> doesn't look like a
number, the number zero is used.  Example:

<B>	:if 0 == "one"</B>
<B>	:  echo "yes"</B>
<B>	:endif</B>

This will echo &quot;yes&quot;, because &quot;one&quot; doesn't look like a number, thus <A HREF="motion.html#it">it</A> is
converted to the number zero.

For strings there are two more items:

	a =~ <A HREF="motion.html#b">b</A>		matches with
	a !~ <A HREF="motion.html#b">b</A>		does not match with

The left item &quot;<A HREF="insert.html#a">a</A>&quot; is used <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>.  The right item &quot;<A HREF="motion.html#b">b</A>&quot; is used <A HREF="motion.html#as">as</A> a
<A HREF="pattern.html#pattern">pattern</A>, like what's used for searching.  Example:

<B>	:if str =~ " "</B>
<B>	:  echo "str contains a space"</B>
<B>	:endif</B>
<B>	:if str !~ '\.$'</B>
<B>	:  echo "str does not end in a full stop"</B>
<B>	:endif</B>

Notice the use of a single-quote <A HREF="eval.html#string">string</A> for the <A HREF="pattern.html#pattern">pattern</A>.  This is useful,
because backslashes would need to be doubled in a double-quote <A HREF="eval.html#string">string</A> and
patterns tend to contain many backslashes.

The <A HREF="options.html#'ignorecase'">'ignorecase'</A> option is used when comparing strings.  When you don't want
that, append &quot;<A HREF="pattern.html##">#</A>&quot; to match <A HREF="change.html#case">case</A> and &quot;<A HREF="pattern.html#?">?</A>&quot; to ignore <A HREF="change.html#case">case</A>.  Thus &quot;==?&quot; compares
two strings to be equal while ignoring <A HREF="change.html#case">case</A>.  And &quot;!~#&quot; checks if a <A HREF="pattern.html#pattern">pattern</A>
doesn't match, also checking the <A HREF="change.html#case">case</A> of letters.  For the full table see
|<A HREF="eval.html#expr-==">expr-==</A>|.


MORE LOOPING

The &quot;<A HREF="eval.html#:while">:while</A>&quot; command was already mentioned.  Two more statements can be used
in between the &quot;<A HREF="eval.html#:while">:while</A>&quot; and the &quot;<A HREF="eval.html#:endwhile">:endwhile</A>&quot;:

	<A HREF="eval.html#:continue">:continue</A>		Jump back to the start of the while loop; the
				loop continues.
	<A HREF="eval.html#:break">:break</A>			Jump forward to the &quot;<A HREF="eval.html#:endwhile">:endwhile</A>&quot;; the loop is
				discontinued.

Example:

<B>	:while counter &lt; 40</B>
<B>	:  call do_something()</B>
<B>	:  if skip_flag</B>
<B>	:    continue</B>
<B>	:  endif</B>
<B>	:  if finished_flag</B>
<B>	:    break</B>
<B>	:  endif</B>
<B>	:  sleep 50m</B>
<B>	:endwhile</B>

The &quot;<A HREF="various.html#:sleep">:sleep</A>&quot; command makes Vim take a nap.  The &quot;50m&quot; specifies fifty
milliseconds.  Another example is &quot;<A HREF="various.html#:sleep">:sleep</A> 4&quot;, which sleeps for four seconds.

Even more looping can be done with the &quot;<A HREF="eval.html#:for">:for</A>&quot; command, see below in |<A HREF="#41.8">41.8</A>|.

==============================================================================

*<A NAME="41.5"></A><B>41.5</B>*	Executing an <A HREF="eval.html#expression">expression</A>

So far the commands in the <A HREF="#script">script</A> were executed by Vim directly.  The
&quot;<A HREF="eval.html#:execute">:execute</A>&quot; command allows executing the result of an <A HREF="eval.html#expression">expression</A>.  This is a
very powerful way to build commands and execute them.
   An example is to jump to a <A HREF="tagsrch.html#tag">tag</A>, which is contained in a variable:

<B>	:execute "tag " . tag_name</B>

The &quot;<A HREF="repeat.html#.">.</A>&quot; is used to concatenate the <A HREF="eval.html#string">string</A> &quot;<A HREF="tagsrch.html#tag">tag</A> &quot; with the value of variable
&quot;tag_name&quot;.  Suppose &quot;tag_name&quot; has the value &quot;get_cmd&quot;, then the command that
will be executed is:

<B>	:tag get_cmd</B>

The &quot;<A HREF="eval.html#:execute">:execute</A>&quot; command can only execute colon commands.  The &quot;<A HREF="various.html#:normal">:normal</A>&quot; command
executes <A HREF="intro.html#Normal">Normal</A> mode commands.  However, its argument is not an <A HREF="eval.html#expression">expression</A> but
the literal command characters.  Example:

<B>	:normal gg=G</B>

This jumps to the first line and formats all lines with the &quot;<A HREF="change.html#=">=</A>&quot; <A HREF="motion.html#operator">operator</A>.
   To make &quot;<A HREF="various.html#:normal">:normal</A>&quot; work with an <A HREF="eval.html#expression">expression</A>, combine &quot;<A HREF="eval.html#:execute">:execute</A>&quot; with <A HREF="motion.html#it">it</A>.
Example:

<B>	:execute "normal " . normal_commands</B>

The variable &quot;normal_commands&quot; must contain the <A HREF="intro.html#Normal">Normal</A> mode commands.
   Make sure that the argument for &quot;<A HREF="various.html#:normal">:normal</A>&quot; is a complete command.  Otherwise
Vim will run into the end of the argument and abort the command.  For example,
if you start <A HREF="insert.html#Insert">Insert</A> mode, you must leave <A HREF="insert.html#Insert">Insert</A> mode <A HREF="motion.html#as">as</A> well.  This works:

<B>	:execute "normal Inew text \&lt;Esc&gt;"</B>

This inserts &quot;new text &quot; in the current line.  Notice the use of the special
key &quot;\&lt;Esc&gt;&quot;.  This avoids having to enter a real <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> character in your
<A HREF="#script">script</A>.

If you don't want to execute a <A HREF="eval.html#string">string</A> but evaluate <A HREF="motion.html#it">it</A> to get its <A HREF="eval.html#expression">expression</A>
value, you can use the <A HREF="eval.html#eval()">eval()</A> function:

<B>	:let optname = "path"</B>
<B>	:let optval = eval('&amp;' . optname)</B>

A &quot;<A HREF="change.html#&amp;">&amp;</A>&quot; character is prepended to &quot;path&quot;, thus the argument to <A HREF="eval.html#eval()">eval()</A> is
&quot;&amp;path&quot;.  The result will then be the value of the <A HREF="options.html#'path'">'path'</A> option.
   The same thing can be done with:
<B>	:exe 'let optval = &amp;' . optname</B>

==============================================================================

*<A NAME="41.6"></A><B>41.6</B>*	Using <A HREF="eval.html#functions">functions</A>

Vim defines many <A HREF="eval.html#functions">functions</A> and provides a large amount of functionality that
way.  A few examples will be given in this section.  You can find the whole
<A HREF="eval.html#list">list</A> here: |<A HREF="eval.html#functions">functions</A>|.

A function is called with the &quot;<A HREF="eval.html#:call">:call</A>&quot; command.  The parameters are passed in
between parentheses separated by commas.  Example:

<B>	:call search("Date: ", "W")</B>

This calls the <A HREF="eval.html#search()">search()</A> function, with arguments &quot;Date: &quot; and &quot;<A HREF="motion.html#W">W</A>&quot;.  The
<A HREF="eval.html#search()">search()</A> function uses its first argument <A HREF="motion.html#as">as</A> a search <A HREF="pattern.html#pattern">pattern</A> and the second
one <A HREF="motion.html#as">as</A> flags.  The &quot;<A HREF="motion.html#W">W</A>&quot; flag means the search doesn't wrap around the end of
the file.

A function can be called in an <A HREF="eval.html#expression">expression</A>.  Example:

<B>	:let line = getline(".")</B>
<B>	:let repl = substitute(line, '\a', "*", "g")</B>
<B>	:call setline(".", repl)</B>

The <A HREF="eval.html#getline()">getline()</A> function obtains a line from the current buffer.  Its argument
is a specification of the line number.  In this <A HREF="change.html#case">case</A> &quot;<A HREF="repeat.html#.">.</A>&quot; is used, which means
the line where the cursor is.
   The <A HREF="eval.html#substitute()">substitute()</A> function does something similar to the &quot;<A HREF="change.html#:substitute">:substitute</A>&quot;
command.  The first argument is the <A HREF="eval.html#string">string</A> on which to perform the
substitution.  The second argument is the <A HREF="pattern.html#pattern">pattern</A>, the third the replacement
<A HREF="eval.html#string">string</A>.  Finally, the last arguments are the flags.
   The <A HREF="eval.html#setline()">setline()</A> function sets the line, specified by the first argument, to a
new <A HREF="eval.html#string">string</A>, the second argument.  In this example the line under the cursor is
replaced with the result of the <A HREF="eval.html#substitute()">substitute()</A>.  Thus the effect of the three
statements is equal to:

<B>	:substitute/\a/*/g</B>

Using the <A HREF="eval.html#functions">functions</A> becomes more interesting when you <A HREF="diff.html#do">do</A> more work before and
after the <A HREF="eval.html#substitute()">substitute()</A> call.



FUNCTIONS						*<A NAME="function-list"></A><B>function-list</B>*

There are many <A HREF="eval.html#functions">functions</A>.  We will mention them here, grouped by what they are
used for.  You can find an alphabetical <A HREF="eval.html#list">list</A> here: |<A HREF="eval.html#functions">functions</A>|.  Use <A HREF="tagsrch.html#CTRL-]">CTRL-]</A> on
the function name to jump to detailed help on <A HREF="motion.html#it">it</A>.


String manipulation:					*<A NAME="string-functions"></A><B>string-functions</B>*
	<A HREF="eval.html#nr2char()">nr2char()</A>		get a character by its ASCII value
	<A HREF="eval.html#char2nr()">char2nr()</A>		get ASCII value of a character
	<A HREF="eval.html#str2nr()">str2nr()</A>		convert a <A HREF="eval.html#string">string</A> to a <A HREF="eval.html#Number">Number</A>
	<A HREF="eval.html#str2float()">str2float()</A>		convert a <A HREF="eval.html#string">string</A> to a <A HREF="eval.html#Float">Float</A>
	<A HREF="eval.html#printf()">printf()</A>		format a <A HREF="eval.html#string">string</A> according to <A HREF="motion.html#&#37;">&#37;</A> items
	<A HREF="eval.html#escape()">escape()</A>		<A HREF="intro.html#escape">escape</A> characters in a <A HREF="eval.html#string">string</A> with a '\'
	<A HREF="eval.html#shellescape()">shellescape()</A>		<A HREF="intro.html#escape">escape</A> a <A HREF="eval.html#string">string</A> for use with a shell command
	<A HREF="eval.html#fnameescape()">fnameescape()</A>		<A HREF="intro.html#escape">escape</A> a file name for use with a Vim command
	<A HREF="eval.html#tr()">tr()</A>			translate characters from one set to another
	<A HREF="eval.html#strtrans()">strtrans()</A>		translate a <A HREF="eval.html#string">string</A> to make <A HREF="motion.html#it">it</A> printable
	<A HREF="eval.html#tolower()">tolower()</A>		turn a <A HREF="eval.html#string">string</A> to <A HREF="change.html#lowercase">lowercase</A>
	<A HREF="eval.html#toupper()">toupper()</A>		turn a <A HREF="eval.html#string">string</A> to <A HREF="change.html#uppercase">uppercase</A>
	<A HREF="eval.html#match()">match()</A>			position where a <A HREF="pattern.html#pattern">pattern</A> matches in a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#matchend()">matchend()</A>		position where a <A HREF="pattern.html#pattern">pattern</A> match ends in a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#matchstr()">matchstr()</A>		match of a <A HREF="pattern.html#pattern">pattern</A> in a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#matchlist()">matchlist()</A>		like <A HREF="eval.html#matchstr()">matchstr()</A> and also return submatches
	<A HREF="eval.html#stridx()">stridx()</A>		first index of a short <A HREF="eval.html#string">string</A> in a long <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#strridx()">strridx()</A>		last index of a short <A HREF="eval.html#string">string</A> in a long <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#strlen()">strlen()</A>		length of a <A HREF="eval.html#string">string</A> in bytes
	<A HREF="eval.html#strchars()">strchars()</A>		length of a <A HREF="eval.html#string">string</A> in characters
	<A HREF="eval.html#strwidth()">strwidth()</A>		size of <A HREF="eval.html#string">string</A> when displayed
	<A HREF="eval.html#strdisplaywidth()">strdisplaywidth()</A>	size of <A HREF="eval.html#string">string</A> when displayed, deals with tabs
	<A HREF="eval.html#substitute()">substitute()</A>		substitute a <A HREF="pattern.html#pattern">pattern</A> match with a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#submatch()">submatch()</A>		get a specific match in &quot;<A HREF="change.html#:s">:s</A>&quot; and <A HREF="eval.html#substitute()">substitute()</A>
	<A HREF="eval.html#strpart()">strpart()</A>		get part of a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#expand()">expand()</A>		expand special keywords
	<A HREF="eval.html#iconv()">iconv()</A>			convert text from one encoding to another
	<A HREF="eval.html#byteidx()">byteidx()</A>		byte index of a character in a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#byteidxcomp()">byteidxcomp()</A>		like <A HREF="eval.html#byteidx()">byteidx()</A> but <A HREF="intro.html#count">count</A> composing characters
	<A HREF="eval.html#repeat()">repeat()</A>		repeat a <A HREF="eval.html#string">string</A> multiple times
	<A HREF="eval.html#eval()">eval()</A>			evaluate a <A HREF="eval.html#string">string</A> <A HREF="eval.html#expression">expression</A>


<A HREF="eval.html#List">List</A> manipulation:					*<A NAME="list-functions"></A><B>list-functions</B>*
	<A HREF="eval.html#get()">get()</A>			get an item without error for wrong index
	<A HREF="eval.html#len()">len()</A>			number of items in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#empty()">empty()</A>			check if <A HREF="eval.html#List">List</A> is empty
	<A HREF="eval.html#insert()">insert()</A>		insert an item somewhere in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#add()">add()</A>			append an item to a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#extend()">extend()</A>		append a <A HREF="eval.html#List">List</A> to a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#remove()">remove()</A>		remove one or more items from a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#copy()">copy()</A>			make a shallow copy of a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#deepcopy()">deepcopy()</A>		make a full copy of a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#filter()">filter()</A>		remove selected items from a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#map()">map()</A>			change each <A HREF="eval.html#List">List</A> item
	<A HREF="eval.html#sort()">sort()</A>			sort a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#reverse()">reverse()</A>		reverse the order of a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#uniq()">uniq()</A>			remove copies of repeated adjacent items
	<A HREF="eval.html#split()">split()</A>			split a String into a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#join()">join()</A>			join <A HREF="eval.html#List">List</A> items into a String
	<A HREF="eval.html#range()">range()</A>			return a <A HREF="eval.html#List">List</A> with a sequence of numbers
	<A HREF="eval.html#string()">string()</A>		String representation of a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#call()">call()</A>			call a function with <A HREF="eval.html#List">List</A> <A HREF="motion.html#as">as</A> arguments
	<A HREF="eval.html#index()">index()</A>			index of a value in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#max()">max()</A>			maximum value in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#min()">min()</A>			minimum value in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#count()">count()</A>			<A HREF="intro.html#count">count</A> number of times a value appears in a <A HREF="eval.html#List">List</A>
	<A HREF="eval.html#repeat()">repeat()</A>		repeat a <A HREF="eval.html#List">List</A> multiple times


<A HREF="eval.html#Dictionary">Dictionary</A> manipulation:				*<A NAME="dict-functions"></A><B>dict-functions</B>*
	<A HREF="eval.html#get()">get()</A>			get an entry without an error for a wrong key
	<A HREF="eval.html#len()">len()</A>			number of entries in a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#has_key()">has_key()</A>		check whether a key appears in a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#empty()">empty()</A>			check if <A HREF="eval.html#Dictionary">Dictionary</A> is empty
	<A HREF="eval.html#remove()">remove()</A>		remove an entry from a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#extend()">extend()</A>		add entries from one <A HREF="eval.html#Dictionary">Dictionary</A> to another
	<A HREF="eval.html#filter()">filter()</A>		remove selected entries from a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#map()">map()</A>			change each <A HREF="eval.html#Dictionary">Dictionary</A> entry
	<A HREF="eval.html#keys()">keys()</A>			get <A HREF="eval.html#List">List</A> of <A HREF="eval.html#Dictionary">Dictionary</A> keys
	<A HREF="eval.html#values()">values()</A>		get <A HREF="eval.html#List">List</A> of <A HREF="eval.html#Dictionary">Dictionary</A> values
	<A HREF="eval.html#items()">items()</A>			get <A HREF="eval.html#List">List</A> of <A HREF="eval.html#Dictionary">Dictionary</A> key-value pairs
	<A HREF="eval.html#copy()">copy()</A>			make a shallow copy of a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#deepcopy()">deepcopy()</A>		make a full copy of a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#string()">string()</A>		String representation of a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#max()">max()</A>			maximum value in a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#min()">min()</A>			minimum value in a <A HREF="eval.html#Dictionary">Dictionary</A>
	<A HREF="eval.html#count()">count()</A>			<A HREF="intro.html#count">count</A> number of times a value appears


Floating point computation:				*<A NAME="float-functions"></A><B>float-functions</B>*
	<A HREF="eval.html#float2nr()">float2nr()</A>		convert <A HREF="eval.html#Float">Float</A> to <A HREF="eval.html#Number">Number</A>
	<A HREF="eval.html#abs()">abs()</A>			absolute value (also works for <A HREF="eval.html#Number">Number</A>)
	<A HREF="eval.html#round()">round()</A>			round off
	<A HREF="eval.html#ceil()">ceil()</A>			round up
	<A HREF="eval.html#floor()">floor()</A>			round down
	<A HREF="eval.html#trunc()">trunc()</A>			remove value after decimal point
	<A HREF="eval.html#fmod()">fmod()</A>			remainder of division
	<A HREF="eval.html#exp()">exp()</A>			exponential
	<A HREF="eval.html#log()">log()</A>			natural logarithm (logarithm to base <A HREF="motion.html#e">e</A>)
	<A HREF="eval.html#log10()">log10()</A>			logarithm to base 10
	<A HREF="eval.html#pow()">pow()</A>			value of <A HREF="change.html#x">x</A> to the exponent <A HREF="change.html#y">y</A>
	<A HREF="eval.html#sqrt()">sqrt()</A>			square root
	<A HREF="eval.html#sin()">sin()</A>			sine
	<A HREF="eval.html#cos()">cos()</A>			cosine
	<A HREF="eval.html#tan()">tan()</A>			tangent
	<A HREF="eval.html#asin()">asin()</A>			arc sine
	<A HREF="eval.html#acos()">acos()</A>			arc cosine
	<A HREF="eval.html#atan()">atan()</A>			arc tangent
	<A HREF="eval.html#atan2()">atan2()</A>			arc tangent
	<A HREF="eval.html#sinh()">sinh()</A>			hyperbolic sine
	<A HREF="eval.html#cosh()">cosh()</A>			hyperbolic cosine
	<A HREF="eval.html#tanh()">tanh()</A>			hyperbolic tangent


Other computation:					*<A NAME="bitwise-function"></A><B>bitwise-function</B>*
	<A HREF="eval.html#and()">and()</A>			bitwise AND
	<A HREF="eval.html#invert()">invert()</A>		bitwise invert
	<A HREF="eval.html#or()">or()</A>			bitwise OR
	<A HREF="eval.html#xor()">xor()</A>			bitwise XOR
	<A HREF="eval.html#sha256()">sha256()</A>		SHA-256 hash


Variables:						*<A NAME="var-functions"></A><B>var-functions</B>*
	<A HREF="eval.html#type()">type()</A>			type of a variable
	<A HREF="eval.html#islocked()">islocked()</A>		check if a variable is locked
	<A HREF="eval.html#function()">function()</A>		get a <A HREF="eval.html#Funcref">Funcref</A> for a function name
	<A HREF="eval.html#getbufvar()">getbufvar()</A>		get a variable value from a specific buffer
	<A HREF="eval.html#setbufvar()">setbufvar()</A>		set a variable in a specific buffer
	<A HREF="eval.html#getwinvar()">getwinvar()</A>		get a variable from specific <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#gettabvar()">gettabvar()</A>		get a variable from specific <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#gettabwinvar()">gettabwinvar()</A>		get a variable from specific <A HREF="windows.html#window">window</A> <A HREF="change.html#&amp;">&amp;</A> <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#setwinvar()">setwinvar()</A>		set a variable in a specific <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#settabvar()">settabvar()</A>		set a variable in a specific <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#settabwinvar()">settabwinvar()</A>		set a variable in a specific <A HREF="windows.html#window">window</A> <A HREF="change.html#&amp;">&amp;</A> <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#garbagecollect()">garbagecollect()</A>	possibly free memory


Cursor and <A HREF="motion.html#mark">mark</A> position:		*<A NAME="cursor-functions"></A><B>cursor-functions</B>* *<A NAME="mark-functions"></A><B>mark-functions</B>*
	<A HREF="eval.html#col()">col()</A>			column number of the cursor or a <A HREF="motion.html#mark">mark</A>
	<A HREF="eval.html#virtcol()">virtcol()</A>		screen column of the cursor or a <A HREF="motion.html#mark">mark</A>
	<A HREF="eval.html#line()">line()</A>			line number of the cursor or <A HREF="motion.html#mark">mark</A>
	<A HREF="eval.html#wincol()">wincol()</A>		<A HREF="windows.html#window">window</A> column number of the cursor
	<A HREF="eval.html#winline()">winline()</A>		<A HREF="windows.html#window">window</A> line number of the cursor
	<A HREF="eval.html#cursor()">cursor()</A>		position the cursor at a line/column
	<A HREF="eval.html#screencol()">screencol()</A>		get screen column of the cursor
	<A HREF="eval.html#screenrow()">screenrow()</A>		get screen row of the cursor
	<A HREF="eval.html#getcurpos()">getcurpos()</A>		get position of the cursor
	<A HREF="eval.html#getpos()">getpos()</A>		get position of cursor, <A HREF="motion.html#mark">mark</A>, etc.
	<A HREF="eval.html#setpos()">setpos()</A>		set position of cursor, <A HREF="motion.html#mark">mark</A>, etc.
	<A HREF="eval.html#byte2line()">byte2line()</A>		get line number at a specific byte <A HREF="intro.html#count">count</A>
	<A HREF="eval.html#line2byte()">line2byte()</A>		byte <A HREF="intro.html#count">count</A> at a specific line
	<A HREF="eval.html#diff_filler()">diff_filler()</A>		get the number of filler lines above a line
	<A HREF="eval.html#screenattr()">screenattr()</A>		get attribute at a screen line/row
	<A HREF="eval.html#screenchar()">screenchar()</A>		get character code at a screen line/row


Working with text in the current buffer:		*<A NAME="text-functions"></A><B>text-functions</B>*
	<A HREF="eval.html#getline()">getline()</A>		get a line or <A HREF="eval.html#list">list</A> of lines from the buffer
	<A HREF="eval.html#setline()">setline()</A>		replace a line in the buffer
	<A HREF="eval.html#append()">append()</A>		append line or <A HREF="eval.html#list">list</A> of lines in the buffer
	<A HREF="eval.html#indent()">indent()</A>		indent of a specific line
	<A HREF="eval.html#cindent()">cindent()</A>		indent according to C indenting
	<A HREF="eval.html#lispindent()">lispindent()</A>		indent according to Lisp indenting
	<A HREF="eval.html#nextnonblank()">nextnonblank()</A>		find next non-blank line
	<A HREF="eval.html#prevnonblank()">prevnonblank()</A>		find previous non-blank line
	<A HREF="eval.html#search()">search()</A>		find a match for a <A HREF="pattern.html#pattern">pattern</A>
	<A HREF="eval.html#searchpos()">searchpos()</A>		find a match for a <A HREF="pattern.html#pattern">pattern</A>
	<A HREF="eval.html#searchpair()">searchpair()</A>		find the other end of a start/skip/end
	<A HREF="eval.html#searchpairpos()">searchpairpos()</A>		find the other end of a start/skip/end
	<A HREF="eval.html#searchdecl()">searchdecl()</A>		search for the declaration of a name


					*<A NAME="system-functions"></A><B>system-functions</B>* *<A NAME="file-functions"></A><B>file-functions</B>*
System <A HREF="eval.html#functions">functions</A> and manipulation of files:
	<A HREF="eval.html#glob()">glob()</A>			expand <A HREF="editing.html#wildcards">wildcards</A>
	<A HREF="eval.html#globpath()">globpath()</A>		expand <A HREF="editing.html#wildcards">wildcards</A> in a number of directories
	<A HREF="eval.html#findfile()">findfile()</A>		find a file in a <A HREF="eval.html#list">list</A> of directories
	<A HREF="eval.html#finddir()">finddir()</A>		find a directory in a <A HREF="eval.html#list">list</A> of directories
	<A HREF="eval.html#resolve()">resolve()</A>		find out where a shortcut points to
	<A HREF="eval.html#fnamemodify()">fnamemodify()</A>		modify a file name
	<A HREF="eval.html#pathshorten()">pathshorten()</A>		shorten directory names in a path
	<A HREF="eval.html#simplify()">simplify()</A>		simplify a path without <A HREF="change.html#changing">changing</A> its meaning
	<A HREF="eval.html#executable()">executable()</A>		check if an executable program exists
	<A HREF="eval.html#exepath()">exepath()</A>		full path of an executable program
	<A HREF="eval.html#filereadable()">filereadable()</A>		check if a file can be read
	<A HREF="eval.html#filewritable()">filewritable()</A>		check if a file can be written to
	<A HREF="eval.html#getfperm()">getfperm()</A>		get the permissions of a file
	<A HREF="eval.html#getftype()">getftype()</A>		get the kind of a file
	<A HREF="eval.html#isdirectory()">isdirectory()</A>		check if a directory exists
	<A HREF="eval.html#getfsize()">getfsize()</A>		get the size of a file
	<A HREF="eval.html#getcwd()">getcwd()</A>		get the current working directory
	<A HREF="eval.html#haslocaldir()">haslocaldir()</A>		check if current <A HREF="windows.html#window">window</A> used |<A HREF="editing.html#:lcd">:lcd</A>|
	<A HREF="eval.html#tempname()">tempname()</A>		get the name of a temporary file
	<A HREF="eval.html#mkdir()">mkdir()</A>			create a new directory
	<A HREF="eval.html#delete()">delete()</A>		delete a file
	<A HREF="eval.html#rename()">rename()</A>		rename a file
	<A HREF="eval.html#system()">system()</A>		get the result of a shell command <A HREF="motion.html#as">as</A> a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#systemlist()">systemlist()</A>		get the result of a shell command <A HREF="motion.html#as">as</A> a <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#hostname()">hostname()</A>		name of the system
	<A HREF="eval.html#readfile()">readfile()</A>		read a file into a <A HREF="eval.html#List">List</A> of lines
	<A HREF="eval.html#writefile()">writefile()</A>		write a <A HREF="eval.html#List">List</A> of lines into a file


Date and Time:				*<A NAME="date-functions"></A><B>date-functions</B>* *<A NAME="time-functions"></A><B>time-functions</B>*
	<A HREF="eval.html#getftime()">getftime()</A>		get last modification time of a file
	<A HREF="eval.html#localtime()">localtime()</A>		get current time in seconds
	<A HREF="eval.html#strftime()">strftime()</A>		convert time to a <A HREF="eval.html#string">string</A>
	<A HREF="eval.html#reltime()">reltime()</A>		get the current or elapsed time accurately
	<A HREF="eval.html#reltimestr()">reltimestr()</A>		convert <A HREF="eval.html#reltime()">reltime()</A> result to a <A HREF="eval.html#string">string</A>


			*<A NAME="buffer-functions"></A><B>buffer-functions</B>* *<A NAME="window-functions"></A><B>window-functions</B>* *<A NAME="arg-functions"></A><B>arg-functions</B>*
Buffers, <A HREF="windows.html#windows">windows</A> and the argument <A HREF="eval.html#list">list</A>:
	<A HREF="eval.html#argc()">argc()</A>			number of entries in the argument <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#argidx()">argidx()</A>		current position in the argument <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#arglistid()">arglistid()</A>		get id of the argument <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#argv()">argv()</A>			get one entry from the argument <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#bufexists()">bufexists()</A>		check if a buffer exists
	<A HREF="eval.html#buflisted()">buflisted()</A>		check if a buffer exists and is listed
	<A HREF="eval.html#bufloaded()">bufloaded()</A>		check if a buffer exists and is loaded
	<A HREF="eval.html#bufname()">bufname()</A>		get the name of a specific buffer
	<A HREF="eval.html#bufnr()">bufnr()</A>			get the buffer number of a specific buffer
	<A HREF="eval.html#tabpagebuflist()">tabpagebuflist()</A>	return <A HREF="eval.html#List">List</A> of <A HREF="windows.html#buffers">buffers</A> in a <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#tabpagenr()">tabpagenr()</A>		get the number of a <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#tabpagewinnr()">tabpagewinnr()</A>		like <A HREF="eval.html#winnr()">winnr()</A> for a specified <A HREF="intro.html#tab">tab</A> page
	<A HREF="eval.html#winnr()">winnr()</A>			get the <A HREF="windows.html#window">window</A> number for the current <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#bufwinnr()">bufwinnr()</A>		get the <A HREF="windows.html#window">window</A> number of a specific buffer
	<A HREF="eval.html#winbufnr()">winbufnr()</A>		get the buffer number of a specific <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#getbufline()">getbufline()</A>		get a <A HREF="eval.html#list">list</A> of lines from the specified buffer


Command line:					*<A NAME="command-line-functions"></A><B>command-line-functions</B>*
	<A HREF="eval.html#getcmdline()">getcmdline()</A>		get the current command line
	<A HREF="eval.html#getcmdpos()">getcmdpos()</A>		get position of the cursor in the command line
	<A HREF="eval.html#setcmdpos()">setcmdpos()</A>		set position of the cursor in the command line
	<A HREF="eval.html#getcmdtype()">getcmdtype()</A>		return the current command-line type
	<A HREF="eval.html#getcmdwintype()">getcmdwintype()</A>		return the current command-line <A HREF="windows.html#window">window</A> type


<A HREF="quickfix.html#Quickfix">Quickfix</A> and location lists:			*<A NAME="quickfix-functions"></A><B>quickfix-functions</B>*
	<A HREF="eval.html#getqflist()">getqflist()</A>		<A HREF="eval.html#list">list</A> of <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="message.html#errors">errors</A>
	<A HREF="eval.html#setqflist()">setqflist()</A>		modify a <A HREF="quickfix.html#quickfix">quickfix</A> <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#getloclist()">getloclist()</A>		<A HREF="eval.html#list">list</A> of location <A HREF="eval.html#list">list</A> items
	<A HREF="eval.html#setloclist()">setloclist()</A>		modify a location <A HREF="eval.html#list">list</A>


<A HREF="insert.html#Insert">Insert</A> mode completion:				*<A NAME="completion-functions"></A><B>completion-functions</B>*
	<A HREF="eval.html#complete()">complete()</A>		set found matches
	<A HREF="eval.html#complete_add()">complete_add()</A>		add to found matches
	<A HREF="eval.html#complete_check()">complete_check()</A>	check if completion should be aborted
	<A HREF="eval.html#pumvisible()">pumvisible()</A>		check if the popup menu is displayed


<A HREF="fold.html#Folding">Folding</A>:					*<A NAME="folding-functions"></A><B>folding-functions</B>*
	<A HREF="eval.html#foldclosed()">foldclosed()</A>		check for a closed fold at a specific line
	<A HREF="eval.html#foldclosedend()">foldclosedend()</A>		like <A HREF="eval.html#foldclosed()">foldclosed()</A> but return the last line
	<A HREF="eval.html#foldlevel()">foldlevel()</A>		check for the fold level at a specific line
	<A HREF="eval.html#foldtext()">foldtext()</A>		generate the line displayed for a closed fold
	<A HREF="eval.html#foldtextresult()">foldtextresult()</A>	get the text displayed for a closed fold


<A HREF="autocmd.html#Syntax">Syntax</A> and highlighting:	  *<A NAME="syntax-functions"></A><B>syntax-functions</B>* *<A NAME="highlighting-functions"></A><B>highlighting-functions</B>*
	<A HREF="eval.html#clearmatches()">clearmatches()</A>		clear all matches defined by |<A HREF="eval.html#matchadd()">matchadd()</A>| and
				the |<A HREF="pattern.html#:match">:match</A>| commands
	<A HREF="eval.html#getmatches()">getmatches()</A>		get all matches defined by |<A HREF="eval.html#matchadd()">matchadd()</A>| and
				the |<A HREF="pattern.html#:match">:match</A>| commands
	<A HREF="eval.html#hlexists()">hlexists()</A>		check if a highlight group exists
	<A HREF="eval.html#hlID()">hlID()</A>			get ID of a highlight group
	<A HREF="eval.html#synID()">synID()</A>			get <A HREF="syntax.html#syntax">syntax</A> ID at a specific position
	<A HREF="eval.html#synIDattr()">synIDattr()</A>		get a specific attribute of a <A HREF="syntax.html#syntax">syntax</A> ID
	<A HREF="eval.html#synIDtrans()">synIDtrans()</A>		get translated <A HREF="syntax.html#syntax">syntax</A> ID
	<A HREF="eval.html#synstack()">synstack()</A>		get <A HREF="eval.html#list">list</A> of <A HREF="syntax.html#syntax">syntax</A> IDs at a specific position
	<A HREF="eval.html#synconcealed()">synconcealed()</A>		get info about concealing
	<A HREF="eval.html#diff_hlID()">diff_hlID()</A>		get highlight ID for <A HREF="diff.html#diff">diff</A> mode at a position
	<A HREF="eval.html#matchadd()">matchadd()</A>		define a <A HREF="pattern.html#pattern">pattern</A> to highlight (a &quot;match&quot;)
	<A HREF="eval.html#matchaddpos()">matchaddpos()</A>		define a <A HREF="eval.html#list">list</A> of positions to highlight
	<A HREF="eval.html#matcharg()">matcharg()</A>		get info about |<A HREF="pattern.html#:match">:match</A>| arguments
	<A HREF="eval.html#matchdelete()">matchdelete()</A>		delete a match defined by |<A HREF="eval.html#matchadd()">matchadd()</A>| or a
				|<A HREF="pattern.html#:match">:match</A>| command
	<A HREF="eval.html#setmatches()">setmatches()</A>		restore a <A HREF="eval.html#list">list</A> of matches saved by
				|<A HREF="eval.html#getmatches()">getmatches()</A>|


Spelling:					*<A NAME="spell-functions"></A><B>spell-functions</B>*
	<A HREF="eval.html#spellbadword()">spellbadword()</A>		locate badly spelled <A HREF="motion.html#word">word</A> at or after cursor
	<A HREF="eval.html#spellsuggest()">spellsuggest()</A>		return suggested spelling corrections
	<A HREF="eval.html#soundfold()">soundfold()</A>		return the sound-a-like equivalent of a <A HREF="motion.html#word">word</A>


History:					*<A NAME="history-functions"></A><B>history-functions</B>*
	<A HREF="eval.html#histadd()">histadd()</A>		add an item to a <A HREF="cmdline.html#history">history</A>
	<A HREF="eval.html#histdel()">histdel()</A>		delete an item from a <A HREF="cmdline.html#history">history</A>
	<A HREF="eval.html#histget()">histget()</A>		get an item from a <A HREF="cmdline.html#history">history</A>
	<A HREF="eval.html#histnr()">histnr()</A>		get highest index of a <A HREF="cmdline.html#history">history</A> <A HREF="eval.html#list">list</A>


Interactive:					*<A NAME="interactive-functions"></A><B>interactive-functions</B>*
	<A HREF="eval.html#browse()">browse()</A>		put up a file requester
	<A HREF="eval.html#browsedir()">browsedir()</A>		put up a directory requester
	<A HREF="eval.html#confirm()">confirm()</A>		let the user make a choice
	<A HREF="eval.html#getchar()">getchar()</A>		get a character from the user
	<A HREF="eval.html#getcharmod()">getcharmod()</A>		get modifiers for the last typed character
	<A HREF="eval.html#feedkeys()">feedkeys()</A>		put characters in the typeahead queue
	<A HREF="eval.html#input()">input()</A>			get a line from the user
	<A HREF="eval.html#inputlist()">inputlist()</A>		let the user pick an entry from a <A HREF="eval.html#list">list</A>
	<A HREF="eval.html#inputsecret()">inputsecret()</A>		get a line from the user without showing <A HREF="motion.html#it">it</A>
	<A HREF="eval.html#inputdialog()">inputdialog()</A>		get a line from the user in a <A HREF="gui_w32.html#dialog">dialog</A>
	<A HREF="eval.html#inputsave()">inputsave()</A>		save and clear typeahead
	<A HREF="eval.html#inputrestore()">inputrestore()</A>		restore typeahead


<A HREF="gui.html#GUI">GUI</A>:						*<A NAME="gui-functions"></A><B>gui-functions</B>*
	<A HREF="eval.html#getfontname()">getfontname()</A>		get name of current font being used
	<A HREF="eval.html#getwinposx()">getwinposx()</A>		X position of the <A HREF="gui.html#GUI">GUI</A> Vim <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#getwinposy()">getwinposy()</A>		<A HREF="change.html#Y">Y</A> position of the <A HREF="gui.html#GUI">GUI</A> Vim <A HREF="windows.html#window">window</A>


Vim server:					*<A NAME="server-functions"></A><B>server-functions</B>*
	<A HREF="eval.html#serverlist()">serverlist()</A>		return the <A HREF="eval.html#list">list</A> of server names
	<A HREF="eval.html#remote_send()">remote_send()</A>		send command characters to a Vim server
	<A HREF="eval.html#remote_expr()">remote_expr()</A>		evaluate an <A HREF="eval.html#expression">expression</A> in a Vim server
	<A HREF="eval.html#server2client()">server2client()</A>		send a reply to a client of a Vim server
	<A HREF="eval.html#remote_peek()">remote_peek()</A>		check if there is a reply from a Vim server
	<A HREF="eval.html#remote_read()">remote_read()</A>		read a reply from a Vim server
	<A HREF="eval.html#foreground()">foreground()</A>		move the Vim <A HREF="windows.html#window">window</A> to the foreground
	<A HREF="eval.html#remote_foreground()">remote_foreground()</A>	move the Vim server <A HREF="windows.html#window">window</A> to the foreground


Window size and position:			*<A NAME="window-size-functions"></A><B>window-size-functions</B>*
	<A HREF="eval.html#winheight()">winheight()</A>		get height of a specific <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#winwidth()">winwidth()</A>		get width of a specific <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#winrestcmd()">winrestcmd()</A>		return command to restore <A HREF="windows.html#window">window</A> sizes
	<A HREF="eval.html#winsaveview()">winsaveview()</A>		get <A HREF="starting.html#view">view</A> of current <A HREF="windows.html#window">window</A>
	<A HREF="eval.html#winrestview()">winrestview()</A>		restore saved <A HREF="starting.html#view">view</A> of current <A HREF="windows.html#window">window</A>


Mappings:				    *<A NAME="mapping-functions"></A><B>mapping-functions</B>*
	<A HREF="eval.html#hasmapto()">hasmapto()</A>		check if a <A HREF="map.html#mapping">mapping</A> exists
	<A HREF="eval.html#mapcheck()">mapcheck()</A>		check if a matching <A HREF="map.html#mapping">mapping</A> exists
	<A HREF="eval.html#maparg()">maparg()</A>		get rhs of a <A HREF="map.html#mapping">mapping</A>
	<A HREF="eval.html#wildmenumode()">wildmenumode()</A>		check if the wildmode is active


Various:					*<A NAME="various-functions"></A><B>various-functions</B>*
	<A HREF="eval.html#mode()">mode()</A>			get current editing mode
	<A HREF="eval.html#visualmode()">visualmode()</A>		last visual mode used
	<A HREF="eval.html#exists()">exists()</A>		check if a variable, function, etc. exists
	<A HREF="eval.html#has()">has()</A>			check if a feature is supported in Vim
	<A HREF="eval.html#changenr()">changenr()</A>		return number of most recent change
	<A HREF="eval.html#cscope_connection()">cscope_connection()</A>	check if a <A HREF="if_cscop.html#cscope">cscope</A> connection exists
	<A HREF="eval.html#did_filetype()">did_filetype()</A>		check if a <A HREF="autocmd.html#FileType">FileType</A> <A HREF="autocmd.html#autocommand">autocommand</A> was used
	<A HREF="eval.html#eventhandler()">eventhandler()</A>		check if invoked by an event handler
	<A HREF="eval.html#getpid()">getpid()</A>		get process ID of Vim

	<A HREF="eval.html#libcall()">libcall()</A>		call a function in an external library
	<A HREF="eval.html#libcallnr()">libcallnr()</A>		idem, returning a number

	<A HREF="eval.html#undofile()">undofile()</A>		get the name of the <A HREF="undo.html#undo">undo</A> file
	<A HREF="eval.html#undotree()">undotree()</A>		return the state of the <A HREF="undo.html#undo">undo</A> tree

	<A HREF="eval.html#getreg()">getreg()</A>		get contents of a <A HREF="sponsor.html#register">register</A>
	<A HREF="eval.html#getregtype()">getregtype()</A>		get type of a <A HREF="sponsor.html#register">register</A>
	<A HREF="eval.html#setreg()">setreg()</A>		set contents and type of a <A HREF="sponsor.html#register">register</A>

	<A HREF="eval.html#shiftwidth()">shiftwidth()</A>		effective value of <A HREF="options.html#'shiftwidth'">'shiftwidth'</A>

	<A HREF="eval.html#taglist()">taglist()</A>		get <A HREF="eval.html#list">list</A> of matching <A HREF="tagsrch.html#tags">tags</A>
	<A HREF="eval.html#tagfiles()">tagfiles()</A>		get a <A HREF="eval.html#list">list</A> of <A HREF="tagsrch.html#tags">tags</A> files

	<A HREF="eval.html#luaeval()">luaeval()</A>		evaluate <A HREF="if_lua.html#Lua">Lua</A> <A HREF="eval.html#expression">expression</A>
	<A HREF="eval.html#mzeval()">mzeval()</A>		evaluate |<A HREF="if_mzsch.html#MzScheme">MzScheme</A>| <A HREF="eval.html#expression">expression</A>
	<A HREF="eval.html#py3eval()">py3eval()</A>		evaluate <A HREF="if_pyth.html#Python">Python</A> <A HREF="eval.html#expression">expression</A> (|<A HREF="various.html#+python3">+python3</A>|)
	<A HREF="eval.html#pyeval()">pyeval()</A>		evaluate <A HREF="if_pyth.html#Python">Python</A> <A HREF="eval.html#expression">expression</A> (|<A HREF="various.html#+python">+python</A>|)

==============================================================================

*<A NAME="41.7"></A><B>41.7</B>*	Defining a function

Vim enables you to define your own <A HREF="eval.html#functions">functions</A>.  The basic function declaration
begins <A HREF="motion.html#as">as</A> follows:

<B>	:function {name}({var1}, {var2}, ...)</B>
<B>	:  {body}</B>
<B>	:endfunction</B>
 
	Note:
	Function names must begin with a capital <A HREF="print.html#letter">letter</A>.

Let's define a short function to return the smaller of two numbers.  It starts
with this line:

<B>	:function Min(num1, num2)</B>

This tells Vim that the function is named &quot;Min&quot; and <A HREF="motion.html#it">it</A> takes two arguments:
&quot;num1&quot; and &quot;num2&quot;.
   The first thing you need to <A HREF="diff.html#do">do</A> is to check to see which number is smaller:
  
<B>	:  if a:num1 &lt; a:num2</B>

The special prefix &quot;a:&quot; tells Vim that the variable is a function argument.
Let's assign the variable &quot;smaller&quot; the value of the smallest number:

<B>	:  if a:num1 &lt; a:num2</B>
<B>	:    let smaller = a:num1</B>
<B>	:  else</B>
<B>	:    let smaller = a:num2</B>
<B>	:  endif</B>

The variable &quot;smaller&quot; is a local variable.  Variables used inside a function
are local unless prefixed by something like &quot;<A HREF="eval.html#g:">g:</A>&quot;, &quot;a:&quot;, or &quot;s:&quot;.

	Note:
	To access a global variable from inside a function you must prepend
	&quot;<A HREF="eval.html#g:">g:</A>&quot; to <A HREF="motion.html#it">it</A>.  Thus &quot;g:today&quot; inside a function is used for the global
	variable &quot;today&quot;, and &quot;today&quot; is another variable, local to the
	function.

You now use the &quot;<A HREF="eval.html#:return">:return</A>&quot; statement to return the smallest number to the user.
Finally, you end the function:

<B>	:  return smaller</B>
<B>	:endfunction</B>

The complete function definition is <A HREF="motion.html#as">as</A> follows:

<B>	:function Min(num1, num2)</B>
<B>	:  if a:num1 &lt; a:num2</B>
<B>	:    let smaller = a:num1</B>
<B>	:  else</B>
<B>	:    let smaller = a:num2</B>
<B>	:  endif</B>
<B>	:  return smaller</B>
<B>	:endfunction</B>

For people who like short <A HREF="eval.html#functions">functions</A>, this does the same thing:

<B>	:function Min(num1, num2)</B>
<B>	:  if a:num1 &lt; a:num2</B>
<B>	:    return a:num1</B>
<B>	:  endif</B>
<B>	:  return a:num2</B>
<B>	:endfunction</B>

A user defined function is called in exactly the same way <A HREF="motion.html#as">as</A> a built-in
function.  Only the name is different.  The Min function can be used like
this:

<B>	:echo Min(5, 8)</B>

Only now will the function be executed and the lines be interpreted by Vim.
If there are mistakes, like using an undefined variable or function, you will
now get an error message.  When defining the function these <A HREF="message.html#errors">errors</A> are not
detected.

When a function reaches &quot;<A HREF="eval.html#:endfunction">:endfunction</A>&quot; or &quot;<A HREF="eval.html#:return">:return</A>&quot; is used without an
argument, the function returns zero.

To redefine a function that already exists, use the ! for the &quot;<A HREF="eval.html#:function">:function</A>&quot;
command:

<B>	:function!  Min(num1, num2, num3)</B>


USING A RANGE

The &quot;<A HREF="eval.html#:call">:call</A>&quot; command can be given a line range.  This can have one of two
meanings.  When a function has been defined with the &quot;range&quot; keyword, <A HREF="motion.html#it">it</A> will
take care of the line range itself.
  The function will be passed the <A HREF="eval.html#variables">variables</A> &quot;<A HREF="eval.html#a:firstline">a:firstline</A>&quot; and &quot;<A HREF="eval.html#a:lastline">a:lastline</A>&quot;.
These will have the line numbers from the range the function was called with.
Example:

<B>	:function Count_words() range</B>
<B>	:  let lnum = a:firstline</B>
<B>	:  let n = 0</B>
<B>	:  while lnum &lt;= a:lastline</B>
<B>	:    let n = n + len(split(getline(lnum)))</B>
<B>	:    let lnum = lnum + 1</B>
<B>	:  endwhile</B>
<B>	:  echo "found " . n . " words"</B>
<B>	:endfunction</B>

You can call this function with:

<B>	:10,30call Count_words()</B>

It will be executed once and echo the number of words.
   The other way to use a line range is by defining a function without the
&quot;range&quot; keyword.  The function will be called once for every line in the
range, with the cursor in that line.  Example:

<B>	:function  Number()</B>
<B>	:  echo "line " . line(".") . " contains: " . getline(".")</B>
<B>	:endfunction</B>

If you call this function with:

<B>	:10,15call Number()</B>

The function will be called six times.


VARIABLE NUMBER OF ARGUMENTS

Vim enables you to define <A HREF="eval.html#functions">functions</A> that have a variable number of arguments.
The following command, for instance, defines a function that must have 1
argument (start) and can have up to 20 additional arguments:

<B>	:function Show(start, ...)</B>

The variable &quot;<A HREF="eval.html#a:1">a:1</A>&quot; contains the first optional argument, &quot;a:2&quot; the second, and
so on.  The variable &quot;<A HREF="eval.html#a:0">a:0</A>&quot; contains the number of extra arguments.
   For example:

<B>	:function Show(start, ...)</B>
<B>	:  echohl Title</B>
<B>	:  echo "start is " . a:start</B>
<B>	:  echohl None</B>
<B>	:  let index = 1</B>
<B>	:  while index &lt;= a:0</B>
<B>	:    echo "  Arg " . index . " is " . a:{index}</B>
<B>	:    let index = index + 1</B>
<B>	:  endwhile</B>
<B>	:  echo ""</B>
<B>	:endfunction</B>

This uses the &quot;<A HREF="eval.html#:echohl">:echohl</A>&quot; command to specify the highlighting used for the
following &quot;<A HREF="eval.html#:echo">:echo</A>&quot; command.  &quot;<A HREF="eval.html#:echohl">:echohl</A> None&quot; stops <A HREF="motion.html#it">it</A> again.  The &quot;<A HREF="eval.html#:echon">:echon</A>&quot;
command works like &quot;<A HREF="eval.html#:echo">:echo</A>&quot;, but doesn't output a line break.

You can also use the <A HREF="eval.html#a:000">a:000</A> variable, <A HREF="motion.html#it">it</A> is a <A HREF="eval.html#List">List</A> of all the &quot;<A HREF="eval.html#...">...</A>&quot; arguments.
See |<A HREF="eval.html#a:000">a:000</A>|.


LISTING FUNCTIONS

The &quot;<A HREF="eval.html#:function">:function</A>&quot; command lists the names and arguments of all user-defined
<A HREF="eval.html#functions">functions</A>:

<B>	:function</B>
<B><FONT color="#54A23D"> 	function Show(start, ...) </FONT></B>
<B><FONT color="#54A23D">	function GetVimIndent() </FONT></B>
<B><FONT color="#54A23D">	function SetSyn(name) </FONT></B>

To see what a function does, use its name <A HREF="motion.html#as">as</A> an argument for &quot;<A HREF="eval.html#:function">:function</A>&quot;:

<B>	:function SetSyn</B>
<B><FONT color="#54A23D"> 	1     if &amp;syntax == '' </FONT></B>
<B><FONT color="#54A23D">	2       let &amp;syntax = a:name </FONT></B>
<B><FONT color="#54A23D">	3     endif </FONT></B>
<B><FONT color="#54A23D">	   endfunction </FONT></B>


DEBUGGING

The line number is useful for when you get an error message or when debugging.
See |<A HREF="repeat.html#debug-scripts">debug-scripts</A>| about debugging mode.
   You can also set the <A HREF="options.html#'verbose'">'verbose'</A> option to 12 or higher to see all function
calls.  Set <A HREF="motion.html#it">it</A> to 15 or higher to see every executed line.


DELETING A FUNCTION

To delete the Show() function:

<B>	:delfunction Show</B>

You get an error when the function doesn't exist.


FUNCTION REFERENCES

Sometimes <A HREF="motion.html#it">it</A> can be useful to have a variable point to one function or
another.  You can <A HREF="diff.html#do">do</A> <A HREF="motion.html#it">it</A> with the <A HREF="eval.html#function()">function()</A> function.  It turns the name of a
function into a reference:

<B>	:let result = 0		" or 1</B>
<B>	:function! Right()</B>
<B>	:  return 'Right!'</B>
<B>	:endfunc</B>
<B>	:function! Wrong()</B>
<B>	:  return 'Wrong!'</B>
<B>	:endfunc</B>
<B>	:</B>
<B>	:if result == 1</B>
<B>	:  let Afunc = function('Right')</B>
<B>	:else</B>
<B>	:  let Afunc = function('Wrong')</B>
<B>	:endif</B>
<B>	:echo call(Afunc, [])</B>
<B><FONT color="#54A23D"> 	Wrong! </FONT></B>

Note that the name of a variable that holds a function reference must start
with a capital.  Otherwise <A HREF="motion.html#it">it</A> could be confused with the name of a builtin
function.
   The way to invoke a function that a variable refers to is with the <A HREF="eval.html#call()">call()</A>
function.  Its first argument is the function reference, the second argument
is a <A HREF="eval.html#List">List</A> with arguments.

Function references are most useful in combination with a <A HREF="eval.html#Dictionary">Dictionary</A>, <A HREF="motion.html#as">as</A> is
explained in the next section.

==============================================================================

*<A NAME="41.8"></A><B>41.8</B>*	<A HREF="eval.html#Lists">Lists</A> and <A HREF="eval.html#Dictionaries">Dictionaries</A>

So far we have used the basic types String and <A HREF="eval.html#Number">Number</A>.  Vim also supports two
composite types: <A HREF="eval.html#List">List</A> and <A HREF="eval.html#Dictionary">Dictionary</A>.

A <A HREF="eval.html#List">List</A> is an ordered sequence of things.  The things can be any kind of value,
thus you can make a <A HREF="eval.html#List">List</A> of numbers, a <A HREF="eval.html#List">List</A> of <A HREF="eval.html#Lists">Lists</A> and even a <A HREF="eval.html#List">List</A> of mixed
items.  To create a <A HREF="eval.html#List">List</A> with three strings:

<B>	:let alist = ['aap', 'mies', 'noot']</B>

The <A HREF="eval.html#List">List</A> items are enclosed in square brackets and separated by commas.  To
create an empty <A HREF="eval.html#List">List</A>:

<B>	:let alist = []</B>

You can add items to a <A HREF="eval.html#List">List</A> with the <A HREF="eval.html#add()">add()</A> function:

<B>	:let alist = []</B>
<B>	:call add(alist, 'foo')</B>
<B>	:call add(alist, 'bar')</B>
<B>	:echo alist</B>
<B><FONT color="#54A23D"> 	['foo', 'bar'] </FONT></B>

<A HREF="eval.html#List">List</A> concatenation is done with +:

<B>	:echo alist + ['foo', 'bar']</B>
<B><FONT color="#54A23D"> 	['foo', 'bar', 'foo', 'bar'] </FONT></B>

Or, if you want to extend a <A HREF="eval.html#List">List</A> directly:

<B>	:let alist = ['one']</B>
<B>	:call extend(alist, ['two', 'three'])</B>
<B>	:echo alist</B>
<B><FONT color="#54A23D"> 	['one', 'two', 'three'] </FONT></B>

Notice that using <A HREF="eval.html#add()">add()</A> will have a different effect:

<B>	:let alist = ['one']</B>
<B>	:call add(alist, ['two', 'three'])</B>
<B>	:echo alist</B>
<B><FONT color="#54A23D"> 	['one', ['two', 'three']] </FONT></B>

The second argument of <A HREF="eval.html#add()">add()</A> is added <A HREF="motion.html#as">as</A> a single item.


FOR LOOP

One of the <A HREF="todo.html#nice">nice</A> things you can <A HREF="diff.html#do">do</A> with a <A HREF="eval.html#List">List</A> is iterate over <A HREF="motion.html#it">it</A>:

<B>	:let alist = ['one', 'two', 'three']</B>
<B>	:for n in alist</B>
<B>	:  echo n</B>
<B>	:endfor</B>
<B><FONT color="#54A23D"> 	one </FONT></B>
<B><FONT color="#54A23D">	two </FONT></B>
<B><FONT color="#54A23D">	three </FONT></B>

This will loop over each element in <A HREF="eval.html#List">List</A> &quot;alist&quot;, assigning the value to
variable &quot;<A HREF="pattern.html#n">n</A>&quot;.  The generic form of a for loop is:

<B>	:for {varname} in {listexpression}</B>
<B>	:  {commands}</B>
<B>	:endfor</B>

To loop a certain number of times you need a <A HREF="eval.html#List">List</A> of a specific length.  The
<A HREF="eval.html#range()">range()</A> function creates one for you:

<B>	:for a in range(3)</B>
<B>	:  echo a</B>
<B>	:endfor</B>
<B><FONT color="#54A23D"> 	0 </FONT></B>
<B><FONT color="#54A23D">	1 </FONT></B>
<B><FONT color="#54A23D">	2 </FONT></B>

Notice that the first item of the <A HREF="eval.html#List">List</A> that <A HREF="eval.html#range()">range()</A> produces is zero, thus the
last item is one <A HREF="various.html#less">less</A> than the length of the <A HREF="eval.html#list">list</A>.
   You can also specify the maximum value, the stride and even go backwards:

<B>	:for a in range(8, 4, -2)</B>
<B>	:  echo a</B>
<B>	:endfor</B>
<B><FONT color="#54A23D"> 	8 </FONT></B>
<B><FONT color="#54A23D">	6 </FONT></B>
<B><FONT color="#54A23D">	4 </FONT></B>

A more useful example, looping over lines in the buffer:

<B>	:for line in getline(1, 20)</B>
<B>	:  if line =~ "Date: "</B>
<B>	:    echo matchstr(line, 'Date: \zs.*')</B>
<B>	:  endif</B>
<B>	:endfor</B>

This looks into lines 1 to 20 (inclusive) and echoes any date found in there.


DICTIONARIES

A <A HREF="eval.html#Dictionary">Dictionary</A> stores key-value pairs.  You can quickly lookup a value if you
know the key.  A <A HREF="eval.html#Dictionary">Dictionary</A> is created with curly braces:

<B>	:let uk2nl = {'one': 'een', 'two': 'twee', 'three': 'drie'}</B>

Now you can lookup words by putting the key in square brackets:

<B>	:echo uk2nl['two']</B>
<B><FONT color="#54A23D"> 	twee </FONT></B>

The generic form for defining a <A HREF="eval.html#Dictionary">Dictionary</A> is:

<B>	{&lt;key&gt; : &lt;value&gt;, ...}</B>

An empty <A HREF="eval.html#Dictionary">Dictionary</A> is one without any keys:

<B>	{}</B>

The possibilities with <A HREF="eval.html#Dictionaries">Dictionaries</A> are numerous.  There are various <A HREF="eval.html#functions">functions</A>
for them <A HREF="motion.html#as">as</A> well.  For example, you can obtain a <A HREF="eval.html#list">list</A> of the keys and loop
over them:

<B>	:for key in keys(uk2nl)</B>
<B>	:  echo key</B>
<B>	:endfor</B>
<B><FONT color="#54A23D"> 	three </FONT></B>
<B><FONT color="#54A23D">	one </FONT></B>
<B><FONT color="#54A23D">	two </FONT></B>

You will notice the keys are not ordered.  You can sort the <A HREF="eval.html#list">list</A> to get a
specific order:

<B>	:for key in sort(keys(uk2nl))</B>
<B>	:  echo key</B>
<B>	:endfor</B>
<B><FONT color="#54A23D"> 	one </FONT></B>
<B><FONT color="#54A23D">	three </FONT></B>
<B><FONT color="#54A23D">	two </FONT></B>

But you can never get back the order in which items are defined.  For that you
need to use a <A HREF="eval.html#List">List</A>, <A HREF="motion.html#it">it</A> stores items in an ordered sequence.


DICTIONARY FUNCTIONS

The items in a <A HREF="eval.html#Dictionary">Dictionary</A> can normally be obtained with an index in square
brackets:

<B>	:echo uk2nl['one']</B>
<B><FONT color="#54A23D"> 	een </FONT></B>

A method that does the same, but without so many punctuation characters:

<B>	:echo uk2nl.one</B>
<B><FONT color="#54A23D"> 	een </FONT></B>

This only works for a key that is made of ASCII letters, digits and the
underscore.  You can also assign a new value this way:

<B>	:let uk2nl.four = 'vier'</B>
<B>	:echo uk2nl</B>
<B><FONT color="#54A23D"> 	{'three': 'drie', 'four': 'vier', 'one': 'een', 'two': 'twee'} </FONT></B>

And now for something special: you can directly define a function and store a
reference to <A HREF="motion.html#it">it</A> in the dictionary:

<B>	:function uk2nl.translate(line) dict</B>
<B>	:  return join(map(split(a:line), 'get(self, v:val, "???")'))</B>
<B>	:endfunction</B>

Let's first try <A HREF="motion.html#it">it</A> out:

<B>	:echo uk2nl.translate('three two five one')</B>
<B><FONT color="#54A23D"> 	drie twee ??? een </FONT></B>

The first special thing you notice is the &quot;<A HREF="eval.html#dict">dict</A>&quot; at the end of the &quot;<A HREF="eval.html#:function">:function</A>&quot;
line.  This marks the function <A HREF="motion.html#as">as</A> being used from a <A HREF="eval.html#Dictionary">Dictionary</A>.  The &quot;<A HREF="eval.html#self">self</A>&quot;
local variable will then refer to that <A HREF="eval.html#Dictionary">Dictionary</A>.
   Now let's break up the complicated return command:

<B>	split(a:line)</B>

The <A HREF="eval.html#split()">split()</A> function takes a <A HREF="eval.html#string">string</A>, chops <A HREF="motion.html#it">it</A> into <A HREF="pattern.html#whitespace">whitespace</A> separated words
and returns a <A HREF="eval.html#list">list</A> with these words.  Thus in the example <A HREF="motion.html#it">it</A> returns:

<B>	:echo split('three two five one')</B>
<B><FONT color="#54A23D"> 	['three', 'two', 'five', 'one'] </FONT></B>

This <A HREF="eval.html#list">list</A> is the first argument to the <A HREF="eval.html#map()">map()</A> function.  This will go through
the <A HREF="eval.html#list">list</A>, evaluating its second argument with &quot;<A HREF="eval.html#v:val">v:val</A>&quot; set to the value of each
item.  This is a shortcut to using a for loop.  This command:

<B>	:let alist = map(split(a:line), 'get(self, v:val, "???")')</B>

Is equivalent to:

<B>	:let alist = split(a:line)</B>
<B>	:for idx in range(len(alist))</B>
<B>	:  let alist[idx] = get(self, alist[idx], "???")</B>
<B>	:endfor</B>

The <A HREF="eval.html#get()">get()</A> function checks if a key is present in a <A HREF="eval.html#Dictionary">Dictionary</A>.  If <A HREF="motion.html#it">it</A> is, then
the value is retrieved.  If <A HREF="motion.html#it">it</A> isn't, then the default value is returned, in
the example it's '???'.  This is a convenient way to handle situations where a
key may not be present and you don't want an error message.

The <A HREF="eval.html#join()">join()</A> function does the opposite of <A HREF="eval.html#split()">split()</A>: <A HREF="motion.html#it">it</A> joins together a <A HREF="eval.html#list">list</A> of
words, putting a space in between.
  This combination of <A HREF="eval.html#split()">split()</A>, <A HREF="eval.html#map()">map()</A> and <A HREF="eval.html#join()">join()</A> is a <A HREF="todo.html#nice">nice</A> way to <A HREF="change.html#filter">filter</A> a line
of words in a very compact way.


OBJECT ORIENTED PROGRAMMING

Now that you can put both values and <A HREF="eval.html#functions">functions</A> in a <A HREF="eval.html#Dictionary">Dictionary</A>, you can
actually use a <A HREF="eval.html#Dictionary">Dictionary</A> like an object.
   Above we used a <A HREF="eval.html#Dictionary">Dictionary</A> for translating Dutch to English.  We might want
to <A HREF="diff.html#do">do</A> the same for other languages.  Let's first make an object (aka
<A HREF="eval.html#Dictionary">Dictionary</A>) that has the translate function, but no words to translate:

<B>	:let transdict = {}</B>
<B>	:function transdict.translate(line) dict</B>
<B>	:  return join(map(split(a:line), 'get(self.words, v:val, "???")'))</B>
<B>	:endfunction</B>

It's slightly different from the function above, using 'self.words' to lookup
<A HREF="motion.html#word">word</A> translations.  But we don't have a self.words.  Thus you could call this
an abstract class.

Now we can instantiate a Dutch translation object:

<B>	:let uk2nl = copy(transdict)</B>
<B>	:let uk2nl.words = {'one': 'een', 'two': 'twee', 'three': 'drie'}</B>
<B>	:echo uk2nl.translate('three one')</B>
<B><FONT color="#54A23D"> 	drie een </FONT></B>

And a German translator:

<B>	:let uk2de = copy(transdict)</B>
<B>	:let uk2de.words = {'one': 'ein', 'two': 'zwei', 'three': 'drei'}</B>
<B>	:echo uk2de.translate('three one')</B>
<B><FONT color="#54A23D"> 	drei ein </FONT></B>

You see that the <A HREF="eval.html#copy()">copy()</A> function is used to make a copy of the &quot;transdict&quot;
<A HREF="eval.html#Dictionary">Dictionary</A> and then the copy is changed to add the words.  The original
remains the same, of course.

Now you can go one step further, and use your preferred translator:

<B>	:if $LANG =~ "de"</B>
<B>	:  let trans = uk2de</B>
<B>	:else</B>
<B>	:  let trans = uk2nl</B>
<B>	:endif</B>
<B>	:echo trans.translate('one two three')</B>
<B><FONT color="#54A23D"> 	een twee drie </FONT></B>

Here &quot;trans&quot; refers to one of the two <A HREF="vimindex.html#objects">objects</A> (Dictionaries).  No copy is
made.  More about <A HREF="eval.html#List">List</A> and <A HREF="eval.html#Dictionary">Dictionary</A> identity can be found at |<A HREF="eval.html#list-identity">list-identity</A>|
and |<A HREF="eval.html#dict-identity">dict-identity</A>|.

Now you might use a language that isn't supported.  You can overrule the
translate() function to <A HREF="diff.html#do">do</A> nothing:

<B>	:let uk2uk = copy(transdict)</B>
<B>	:function! uk2uk.translate(line)</B>
<B>	:  return a:line</B>
<B>	:endfunction</B>
<B>	:echo uk2uk.translate('three one wladiwostok')</B>
<B><FONT color="#54A23D"> 	three one wladiwostok </FONT></B>

Notice that a ! was used to overwrite the existing function reference.  Now
use &quot;uk2uk&quot; when no recognized language is found:

<B>	:if $LANG =~ "de"</B>
<B>	:  let trans = uk2de</B>
<B>	:elseif $LANG =~ "nl"</B>
<B>	:  let trans = uk2nl</B>
<B>	:else</B>
<B>	:  let trans = uk2uk</B>
<B>	:endif</B>
<B>	:echo trans.translate('one two three')</B>
<B><FONT color="#54A23D"> 	one two three </FONT></B>

For further reading see |<A HREF="eval.html#Lists">Lists</A>| and |<A HREF="eval.html#Dictionaries">Dictionaries</A>|.

==============================================================================

*<A NAME="41.9"></A><B>41.9</B>*	Exceptions

Let's start with an example:

<B>	:try</B>
<B>	:   read ~/templates/pascal.tmpl</B>
<B>	:catch /E484:/</B>
<B>	:   echo "Sorry, the Pascal template file cannot be found."</B>
<B>	:endtry</B>

The &quot;<A HREF="insert.html#:read">:read</A>&quot; command will fail if the file does not exist.  Instead of
generating an error message, this code catches the error and gives the user a
<A HREF="todo.html#nice">nice</A> message.

For the commands in between &quot;<A HREF="eval.html#:try">:try</A>&quot; and &quot;<A HREF="eval.html#:endtry">:endtry</A>&quot; <A HREF="message.html#errors">errors</A> are turned into
exceptions.  An exception is a <A HREF="eval.html#string">string</A>.  In the <A HREF="change.html#case">case</A> of an error the <A HREF="eval.html#string">string</A>
contains the error message.  And every error message has a number.  In this
<A HREF="change.html#case">case</A>, the error we catch contains &quot;E484:&quot;.  This number is guaranteed to stay
the same (the text may change, e.g., <A HREF="motion.html#it">it</A> may be translated).

When the &quot;<A HREF="insert.html#:read">:read</A>&quot; command causes another error, the <A HREF="pattern.html#pattern">pattern</A> &quot;E484:&quot; will not
match in <A HREF="motion.html#it">it</A>.  Thus this exception will not be caught and result in the usual
error message.

You might be tempted to <A HREF="diff.html#do">do</A> this:

<B>	:try</B>
<B>	:   read ~/templates/pascal.tmpl</B>
<B>	:catch</B>
<B>	:   echo "Sorry, the Pascal template file cannot be found."</B>
<B>	:endtry</B>

This means all <A HREF="message.html#errors">errors</A> are caught.  But then you will not see <A HREF="message.html#errors">errors</A> that are
useful, such <A HREF="motion.html#as">as</A> &quot;E21: Cannot make changes, <A HREF="options.html#'modifiable'">'modifiable'</A> is off&quot;.

Another useful mechanism is the &quot;<A HREF="eval.html#:finally">:finally</A>&quot; command:

<B>	:let tmp = tempname()</B>
<B>	:try</B>
<B>	:   exe ".,$write " . tmp</B>
<B>	:   exe "!filter " . tmp</B>
<B>	:   .,$delete</B>
<B>	:   exe "$read " . tmp</B>
<B>	:finally</B>
<B>	:   call delete(tmp)</B>
<B>	:endtry</B>

This filters the lines from the cursor until the end of the file through the
&quot;<A HREF="change.html#filter">filter</A>&quot; command, which takes a file name argument.  No matter if the
filtering works, something goes wrong in between &quot;<A HREF="eval.html#:try">:try</A>&quot; and &quot;<A HREF="eval.html#:finally">:finally</A>&quot; or the
user cancels the filtering by pressing <A HREF="pattern.html#CTRL-C">CTRL-C</A>, the &quot;call delete(tmp)&quot; is
always executed.  This makes sure you don't leave the temporary file behind.

More information about exception handling can be found in the reference
manual: |<A HREF="eval.html#exception-handling">exception-handling</A>|.

==============================================================================

*<A NAME="41.10"></A><B>41.10</B>*	Various remarks

Here is a summary of items that apply to Vim scripts.  They are also mentioned
elsewhere, but form a <A HREF="todo.html#nice">nice</A> checklist.

The end-of-line character depends on the system.  For <A HREF="os_unix.html#Unix">Unix</A> a single <A HREF="motion.html#&lt;NL&gt;">&lt;NL&gt;</A>
character is used.  For MS-DOS, Windows and the like, &lt;CR&gt;&lt;LF&gt; is used.
This is important when using mappings that end in a <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>.  See |<A HREF="repeat.html#:source_crnl">:source_crnl</A>|.


WHITE SPACE

Blank lines are allowed and ignored.

Leading <A HREF="pattern.html#whitespace">whitespace</A> characters (blanks and TABs) are always ignored.  The
whitespaces between parameters (e.g. between the 'set' and the <A HREF="options.html#'cpoptions'">'cpoptions'</A> in
the example below) are reduced to one blank character and plays the role of a
separator, the whitespaces after the last (visible) character may or may not
be ignored depending on the situation, see below.

For a &quot;<A HREF="options.html#:set">:set</A>&quot; command involving the &quot;<A HREF="change.html#=">=</A>&quot; (equal) sign, such <A HREF="motion.html#as">as</A> in:

<B>	:set cpoptions    =aABceFst</B>

the <A HREF="pattern.html#whitespace">whitespace</A> immediately before the &quot;<A HREF="change.html#=">=</A>&quot; sign is ignored.  But there can be
no <A HREF="pattern.html#whitespace">whitespace</A> after the &quot;<A HREF="change.html#=">=</A>&quot; sign!

To include a <A HREF="pattern.html#whitespace">whitespace</A> character in the value of an option, <A HREF="motion.html#it">it</A> must be
escaped by a &quot;\&quot; (backslash)  <A HREF="motion.html#as">as</A> in the following example:

<B>	:set tags=my\ nice\ file</B>

The same example written <A HREF="motion.html#as">as</A>:

<B>	:set tags=my nice file</B>

will issue an error, because <A HREF="motion.html#it">it</A> is interpreted <A HREF="motion.html#as">as</A>:

<B>	:set tags=my</B>
<B>	:set nice</B>
<B>	:set file</B>


COMMENTS

The character &quot; (the double <A HREF="change.html#quote">quote</A> <A HREF="motion.html#mark">mark</A>) starts a comment.  Everything after
and including this character until the end-of-line is considered a comment and
is ignored, except for commands that don't consider comments, <A HREF="motion.html#as">as</A> shown in
examples below.  A comment can start on any character position on the line.

There is a little &quot;catch&quot; with comments for some commands.  Examples:

<B>	:abbrev dev development		" shorthand</B>
<B>	:map &lt;F3&gt; o#include		" insert include</B>
<B>	:execute cmd			" do it</B>
<B>	:!ls *.c			" list C files</B>

The abbreviation 'dev' will be expanded to 'development     &quot; shorthand'.  The
<A HREF="map.html#mapping">mapping</A> of <A HREF="term.html#&lt;F3&gt;">&lt;F3&gt;</A> will actually be the whole line after the 'o# ....' including
the &#39;&#34;' insert include'.  The &quot;execute&quot; command will give an error.  The &quot;<A HREF="change.html#!">!</A>&quot;
command will send everything after <A HREF="motion.html#it">it</A> to the shell, causing an error for an
unmatched &#39;&#34;'' character.
   There can be no comment after &quot;<A HREF="map.html#:map">:map</A>&quot;, &quot;<A HREF="map.html#:abbreviate">:abbreviate</A>&quot;, &quot;<A HREF="eval.html#:execute">:execute</A>&quot; and &quot;<A HREF="change.html#!">!</A>&quot;
commands (there are a few more commands with this restriction).  For the
&quot;<A HREF="map.html#:map">:map</A>&quot;, &quot;<A HREF="map.html#:abbreviate">:abbreviate</A>&quot; and &quot;<A HREF="eval.html#:execute">:execute</A>&quot; commands there is a trick:

<B>	:abbrev dev development|" shorthand</B>
<B>	:map &lt;F3&gt; o#include|" insert include</B>
<B>	:execute cmd			|" do it</B>

With the '&#124;' character the command is separated from the next one.  And that
next command is only a comment.  For the last command you need to <A HREF="diff.html#do">do</A> two
things: |<A HREF="eval.html#:execute">:execute</A>| and use '&#124;':
<B>	:exe '!ls *.c'			|" list C files</B>

Notice that there is no white space before the '&#124;' in the abbreviation and
<A HREF="map.html#mapping">mapping</A>.  For these commands, any character until the end-of-line or '&#124;' is
included.  As a consequence of this behavior, you don't always see that
trailing <A HREF="pattern.html#whitespace">whitespace</A> is included:

<B>	:map &lt;F4&gt; o#include  </B>

To spot these problems, you can set the <A HREF="options.html#'list'">'list'</A> option when editing <A HREF="starting.html#vimrc">vimrc</A>
files.

For <A HREF="os_unix.html#Unix">Unix</A> there is one special way to comment a line, that allows making a Vim
<A HREF="#script">script</A> executable:
<B>	#!/usr/bin/env vim -S</B>
<B>	echo "this is a Vim script"</B>
<B>	quit</B>

The &quot;<A HREF="pattern.html##">#</A>&quot; command by itself lists a line with the line number.  Adding an
exclamation <A HREF="motion.html#mark">mark</A> changes <A HREF="motion.html#it">it</A> into doing nothing, so that you can add the shell
command to execute the rest of the file. |<A HREF="various.html#:#!">:#!</A>| |<A HREF="starting.html#-S">-S</A>|


PITFALLS

Even bigger problem arises in the following example:

<B>	:map ,ab o#include</B>
<B>	:unmap ,ab </B>

Here the unmap command will not work, because <A HREF="motion.html#it">it</A> tries to unmap &quot;,ab &quot;.  This
does not exist <A HREF="motion.html#as">as</A> a mapped sequence.  An error will be issued, which is very
hard to identify, because the ending <A HREF="pattern.html#whitespace">whitespace</A> character in &quot;<A HREF="map.html#:unmap">:unmap</A> ,ab &quot; is
not visible.

And this is the same <A HREF="motion.html#as">as</A> what happens when one uses a comment after an 'unmap'
command:

<B>	:unmap ,ab     " comment</B>

Here the comment part will be ignored.  However, Vim will try to unmap
',ab     '', which does not exist.  Rewrite <A HREF="motion.html#it">it</A> <A HREF="motion.html#as">as</A>:

<B>	:unmap ,ab|    " comment</B>


RESTORING THE VIEW

Sometimes you want to make a change and go back to where the cursor was.
Restoring the relative position would also be <A HREF="todo.html#nice">nice</A>, so that the same line
appears at the top of the <A HREF="windows.html#window">window</A>.
   This example yanks the current line, puts <A HREF="motion.html#it">it</A> above the first line in the
file and then restores the <A HREF="starting.html#view">view</A>:

<B>	map ,p ma"aYHmbgg"aP`bzt`a</B>

What this does:
<B>	ma"aYHmbgg"aP`bzt`a</B>
 	ma			set <A HREF="motion.html#mark">mark</A> a at cursor position
	  &quot;aY			<A HREF="change.html#yank">yank</A> current line into <A HREF="sponsor.html#register">register</A> a
	     Hmb		go to top line in <A HREF="windows.html#window">window</A> and set <A HREF="motion.html#mark">mark</A> <A HREF="motion.html#b">b</A> there
		<A HREF="motion.html#gg">gg</A>		go to first line in file
		  &quot;aP		put the yanked line above <A HREF="motion.html#it">it</A>
		     `b		go back to top line in display
		       <A HREF="scroll.html#zt">zt</A>	position the text in the <A HREF="windows.html#window">window</A> <A HREF="motion.html#as">as</A> before
			 `a	go back to saved cursor position


PACKAGING

To avoid your function names to interfere with <A HREF="eval.html#functions">functions</A> that you get from
others, use this scheme:
- Prepend a unique <A HREF="eval.html#string">string</A> before each function name.  I often use an
  abbreviation.  For example, &quot;OW_&quot; is used for the option <A HREF="windows.html#window">window</A> <A HREF="eval.html#functions">functions</A>.
- Put the definition of your <A HREF="eval.html#functions">functions</A> together in a file.  Set a global
  variable to indicate that the <A HREF="eval.html#functions">functions</A> have been loaded.  When sourcing the
  file again, first unload the <A HREF="eval.html#functions">functions</A>.
Example:

<B>	" This is the XXX package</B>

<B>	if exists("XXX_loaded")</B>
<B>	  delfun XXX_one</B>
<B>	  delfun XXX_two</B>
<B>	endif</B>

<B>	function XXX_one(a)</B>
<B>		... body of function ...</B>
<B>	endfun</B>

<B>	function XXX_two(b)</B>
<B>		... body of function ...</B>
<B>	endfun</B>

<B>	let XXX_loaded = 1</B>

==============================================================================

*<A NAME="41.11"></A><B>41.11</B>*	Writing a <A HREF="usr_05.html#plugin">plugin</A>				*<A NAME="write-plugin"></A><B>write-plugin</B>*

You can write a Vim <A HREF="#script">script</A> in such a way that many people can use <A HREF="motion.html#it">it</A>.  This is
called a <A HREF="usr_05.html#plugin">plugin</A>.  Vim users can drop your <A HREF="#script">script</A> in their <A HREF="usr_05.html#plugin">plugin</A> directory and
use its features right away |<A HREF="usr_05.html#add-plugin">add-plugin</A>|.

There are actually two types of plugins:

  global plugins: For all types of files.
<A HREF="filetype.html#filetype">filetype</A> plugins: Only for files of a specific type.

In this section the first type is explained.  Most items are also relevant for
<A HREF="editing.html#writing">writing</A> <A HREF="filetype.html#filetype">filetype</A> plugins.  The specifics for <A HREF="filetype.html#filetype">filetype</A> plugins are in the next
section |<A HREF="#write-filetype-plugin">write-filetype-plugin</A>|.


NAME

First of all you must choose a name for your <A HREF="usr_05.html#plugin">plugin</A>.  The features provided
by the <A HREF="usr_05.html#plugin">plugin</A> should be clear from its name.  And <A HREF="motion.html#it">it</A> should be unlikely that
someone else writes a <A HREF="usr_05.html#plugin">plugin</A> with the same name but which does something
different.  And please limit the name to 8 characters, to avoid problems on
old Windows systems.

A <A HREF="#script">script</A> that corrects typing mistakes could be called &quot;typecorr.vim&quot;.  We
will use <A HREF="motion.html#it">it</A> here <A HREF="motion.html#as">as</A> an example.

For the <A HREF="usr_05.html#plugin">plugin</A> to work for everybody, <A HREF="motion.html#it">it</A> should follow a few guidelines.  This
will be explained step-by-step.  The complete example <A HREF="usr_05.html#plugin">plugin</A> is at the end.


BODY

Let's start with the body of the <A HREF="usr_05.html#plugin">plugin</A>, the lines that <A HREF="diff.html#do">do</A> the actual work:

<B> 14	iabbrev teh the</B>
<B> 15	iabbrev otehr other</B>
<B> 16	iabbrev wnat want</B>
<B> 17	iabbrev synchronisation</B>
<B> 18		\ synchronization</B>
<B> 19	let s:count = 4</B>

The actual <A HREF="eval.html#list">list</A> should be much longer, of course.

The line numbers have only been added to explain a few things, don't put them
in your <A HREF="usr_05.html#plugin">plugin</A> file!


HEADER

You will probably add new corrections to the <A HREF="usr_05.html#plugin">plugin</A> and soon have several
versions lying around.  And when distributing this file, people will want to
know who wrote this wonderful <A HREF="usr_05.html#plugin">plugin</A> and where they can send remarks.
Therefore, put a header at the top of your <A HREF="usr_05.html#plugin">plugin</A>:

<B>  1	" Vim global plugin for correcting typing mistakes</B>
<B>  2	" Last Change:	2000 Oct 15</B>
<B>  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;</B>

About <A HREF="uganda.html#copyright">copyright</A> and licensing: Since plugins are very useful and it's hardly
worth restricting their <A HREF="intro.html#distribution">distribution</A>, please consider making your <A HREF="usr_05.html#plugin">plugin</A>
either public domain or use the Vim |<A HREF="uganda.html#license">license</A>|.  A short note about this near
the top of the <A HREF="usr_05.html#plugin">plugin</A> should be sufficient.  Example:

<B>  4	" License:	This file is placed in the public domain.</B>



LINE CONTINUATION, AVOIDING SIDE EFFECTS		*<A NAME="use-cpo-save"></A><B>use-cpo-save</B>*

In line 18 above, the line-continuation mechanism is used |<A HREF="repeat.html#line-continuation">line-continuation</A>|.
Users with <A HREF="options.html#'compatible'">'compatible'</A> set will run into trouble here, they will get an error
message.  We can't just reset <A HREF="options.html#'compatible'">'compatible'</A>, because that has a lot of side
effects.  To avoid this, we will set the <A HREF="options.html#'cpoptions'">'cpoptions'</A> option to its Vim default
value and restore <A HREF="motion.html#it">it</A> later.  That will allow the use of <A HREF="repeat.html#line-continuation">line-continuation</A> and
make the <A HREF="#script">script</A> work for most people.  It is done like this:

<B> 11	let s:save_cpo = &amp;cpo</B>
<B> 12	set cpo&amp;vim</B>
<B> ..</B>
<B> 42	let &amp;cpo = s:save_cpo</B>
<B> 43	unlet s:save_cpo</B>

We first store the old value of <A HREF="options.html#'cpoptions'">'cpoptions'</A> in the s:save_cpo variable.  At
the end of the <A HREF="usr_05.html#plugin">plugin</A> this value is restored.

Notice that a <A HREF="map.html#script-local">script-local</A> variable is used |<A HREF="eval.html#s:var">s:var</A>|.  A global variable could
already be in use for something else.  Always use <A HREF="map.html#script-local">script-local</A> <A HREF="eval.html#variables">variables</A> for
things that are only used in the <A HREF="#script">script</A>.


NOT LOADING

It's possible that a user doesn't always want to load this <A HREF="usr_05.html#plugin">plugin</A>.  Or the
system administrator has dropped <A HREF="motion.html#it">it</A> in the system-wide <A HREF="usr_05.html#plugin">plugin</A> directory, but a
user has his own <A HREF="usr_05.html#plugin">plugin</A> he wants to use.  Then the user must have a chance to
disable loading this specific <A HREF="usr_05.html#plugin">plugin</A>.  This will make <A HREF="motion.html#it">it</A> possible:

<B>  6	if exists("g:loaded_typecorr")</B>
<B>  7	  finish</B>
<B>  8	endif</B>
<B>  9	let g:loaded_typecorr = 1</B>

This also avoids that when the <A HREF="#script">script</A> is loaded <A HREF="if_cscop.html#twice">twice</A> <A HREF="motion.html#it">it</A> would cause error
<A HREF="message.html#messages">messages</A> for redefining <A HREF="eval.html#functions">functions</A> and cause trouble for autocommands that are
added <A HREF="if_cscop.html#twice">twice</A>.

The name is recommended to start with &quot;loaded_&quot; and then the file name of the
<A HREF="usr_05.html#plugin">plugin</A>, literally.  The &quot;<A HREF="eval.html#g:">g:</A>&quot; is prepended just to avoid mistakes when using
the variable in a function (without &quot;<A HREF="eval.html#g:">g:</A>&quot; <A HREF="motion.html#it">it</A> would be a variable local to the
function).

Using &quot;finish&quot; stops Vim from reading the rest of the file, it's much quicker
than using if-endif around the whole file.


MAPPING

Now let's make the <A HREF="usr_05.html#plugin">plugin</A> more interesting: We will add a <A HREF="map.html#mapping">mapping</A> that adds a
correction for the <A HREF="motion.html#word">word</A> under the cursor.  We could just pick a key sequence
for this <A HREF="map.html#mapping">mapping</A>, but the user might already use <A HREF="motion.html#it">it</A> for something else.  To
allow the user to define which keys a <A HREF="map.html#mapping">mapping</A> in a <A HREF="usr_05.html#plugin">plugin</A> uses, the <A HREF="map.html#&lt;Leader&gt;">&lt;Leader&gt;</A>
item can be used:

<B> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</B>

The &quot;&lt;Plug&gt;TypecorrAdd&quot; thing will <A HREF="diff.html#do">do</A> the work, more about that further on.

The user can set the &quot;<A HREF="map.html#mapleader">mapleader</A>&quot; variable to the key sequence that he wants
this <A HREF="map.html#mapping">mapping</A> to start with.  Thus if the user has done:

<B>	let mapleader = "_"</B>

the <A HREF="map.html#mapping">mapping</A> will define &quot;_a&quot;.  If the user didn't <A HREF="diff.html#do">do</A> this, the default value
will be used, which is a <A HREF="intro.html#backslash">backslash</A>.  Then a map for &quot;\a&quot; will be defined.

Note that &lt;unique&gt; is used, this will cause an error message if the <A HREF="map.html#mapping">mapping</A>
already happened to exist. |<A HREF="map.html#:map-&lt;unique&gt;">:map-&lt;unique&gt;</A>|

But what if the user wants to define his own key sequence?  We can allow that
with this mechanism:

<B> 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')</B>
<B> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</B>
<B> 23	endif</B>

This checks if a <A HREF="map.html#mapping">mapping</A> to &quot;&lt;Plug&gt;TypecorrAdd&quot; already exists, and only
defines the <A HREF="map.html#mapping">mapping</A> from &quot;&lt;Leader&gt;a&quot; if <A HREF="motion.html#it">it</A> doesn't.  The user then has a
chance of putting this in his <A HREF="starting.html#vimrc">vimrc</A> file:

<B>	map ,c  &lt;Plug&gt;TypecorrAdd</B>

Then the mapped key sequence will be &quot;,c&quot; instead of &quot;_a&quot; or &quot;\a&quot;.


PIECES

If a <A HREF="#script">script</A> gets longer, you often want to break up the work in pieces.  You
can use <A HREF="eval.html#functions">functions</A> or mappings for this.  But you don't want these <A HREF="eval.html#functions">functions</A>
and mappings to interfere with the ones from other scripts.  For example, you
could define a function Add(), but another <A HREF="#script">script</A> could try to define the same
function.  To avoid this, we define the function local to the <A HREF="#script">script</A> by
prepending <A HREF="motion.html#it">it</A> with &quot;s:&quot;.

We will define a function that adds a new typing correction:

<B> 30	function s:Add(from, correct)</B>
<B> 31	  let to = input("type the correction for " . a:from . ": ")</B>
<B> 32	  exe ":iabbrev " . a:from . " " . to</B>
<B> ..</B>
<B> 36	endfunction</B>

Now we can call the function s:Add() from within this <A HREF="#script">script</A>.  If another
<A HREF="#script">script</A> also defines s:Add(), <A HREF="motion.html#it">it</A> will be local to that <A HREF="#script">script</A> and can only
be called from the <A HREF="#script">script</A> <A HREF="motion.html#it">it</A> was defined in.  There can also be a global Add()
function (without the &quot;s:&quot;), which is again another function.

<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> can be used with mappings.  It generates a <A HREF="#script">script</A> ID, which identifies
the current <A HREF="#script">script</A>.  In our typing correction <A HREF="usr_05.html#plugin">plugin</A> we use <A HREF="motion.html#it">it</A> like this:

<B> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add</B>
<B> ..</B>
<B> 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;</B>

Thus when a user types &quot;\a&quot;, this sequence is invoked:

<B>	\a  -&gt;  &lt;Plug&gt;TypecorrAdd  -&gt;  &lt;SID&gt;Add  -&gt;  :call &lt;SID&gt;Add()</B>

If another <A HREF="#script">script</A> would also map &lt;SID&gt;Add, <A HREF="motion.html#it">it</A> would get another <A HREF="#script">script</A> ID and
thus define another <A HREF="map.html#mapping">mapping</A>.

Note that instead of s:Add() we use &lt;SID&gt;Add() here.  That is because the
<A HREF="map.html#mapping">mapping</A> is typed by the user, thus outside of the <A HREF="#script">script</A>.  The <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> is
translated to the <A HREF="#script">script</A> ID, so that Vim knows in which <A HREF="#script">script</A> to look for
the Add() function.

This is a bit complicated, but it's required for the <A HREF="usr_05.html#plugin">plugin</A> to work together
with other plugins.  The basic rule is that you use &lt;SID&gt;Add() in mappings and
s:Add() in other places (the <A HREF="#script">script</A> itself, autocommands, user commands).

We can also add a menu entry to <A HREF="diff.html#do">do</A> the same <A HREF="motion.html#as">as</A> the <A HREF="map.html#mapping">mapping</A>:

<B> 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</B>

The &quot;Plugin&quot; menu is recommended for adding menu items for plugins.  In this
<A HREF="change.html#case">case</A> only one item is used.  When adding more items, creating a submenu is
recommended.  For example, &quot;Plugin.CVS&quot; could be used for a <A HREF="usr_05.html#plugin">plugin</A> that offers
CVS operations &quot;Plugin.CVS.checkin&quot;, &quot;Plugin.CVS.checkout&quot;, etc.

Note that in line 28 &quot;<A HREF="map.html#:noremap">:noremap</A>&quot; is used to avoid that any other mappings cause
trouble.  Someone may have remapped &quot;<A HREF="eval.html#:call">:call</A>&quot;, for example.  In line 24 we also
use &quot;<A HREF="map.html#:noremap">:noremap</A>&quot;, but we <A HREF="diff.html#do">do</A> want &quot;&lt;SID&gt;Add&quot; to be remapped.  This is why
&quot;&lt;script&gt;&quot; is used here.  This only allows mappings which are local to the
script. |<A HREF="map.html#:map-&lt;script&gt;">:map-&lt;script&gt;</A>|  The same is done in line 26 for &quot;<A HREF="gui.html#:noremenu">:noremenu</A>&quot;.
|<A HREF="gui.html#:menu-&lt;script&gt;">:menu-&lt;script&gt;</A>|



<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> AND <A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A>					*<A NAME="using-&lt;Plug&gt;"></A><B>using-&lt;Plug&gt;</B>*

Both <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> and <A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A> are used to avoid that mappings of typed keys interfere
with mappings that are only to be used from other mappings.  Note the
difference between using <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> and <A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A>:

<A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A>	is visible outside of the <A HREF="#script">script</A>.  It is used for mappings which the
	user might want to map a key sequence to.  <A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A> is a special code
	that a typed key will never produce.
	To make <A HREF="motion.html#it">it</A> very unlikely that other plugins use the same sequence of
	characters, use this structure: <A HREF="map.html#&lt;Plug&gt;">&lt;Plug&gt;</A> scriptname mapname
	In our example the scriptname is &quot;Typecorr&quot; and the mapname is &quot;Add&quot;.
	This results in &quot;&lt;Plug&gt;TypecorrAdd&quot;.  Only the first character of
	scriptname and mapname is <A HREF="change.html#uppercase">uppercase</A>, so that we can see where mapname
	starts.

<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>	is the <A HREF="#script">script</A> ID, a unique identifier for a <A HREF="#script">script</A>.
	Internally Vim translates <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> to &quot;&lt;SNR&gt;123_&quot;, where &quot;123&quot; can be any
	number.  Thus a function &quot;&lt;SID&gt;Add()&quot; will have a name &quot;&lt;SNR&gt;11_Add()&quot;
	in one <A HREF="#script">script</A>, and &quot;&lt;SNR&gt;22_Add()&quot; in another.  You can see this if
	you use the &quot;<A HREF="eval.html#:function">:function</A>&quot; command to get a <A HREF="eval.html#list">list</A> of <A HREF="eval.html#functions">functions</A>.  The
	translation of <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A> in mappings is exactly the same, that's how you
	can call a <A HREF="map.html#script-local">script-local</A> function from a <A HREF="map.html#mapping">mapping</A>.


USER COMMAND

Now let's add a user command to add a correction:

<B> 38	if !exists(":Correct")</B>
<B> 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)</B>
<B> 40	endif</B>

The user command is defined only if no command with the same name already
exists.  Otherwise we would get an error here.  Overriding the existing user
command with &quot;:command!&quot; is not a good idea, this would probably make the user
wonder why the command he defined himself doesn't work.  |<A HREF="map.html#:command">:command</A>|


SCRIPT VARIABLES

When a variable starts with &quot;s:&quot; <A HREF="motion.html#it">it</A> is a <A HREF="#script">script</A> variable.  It can only be used
inside a <A HREF="#script">script</A>.  Outside the <A HREF="#script">script</A> it's not visible.  This avoids trouble
with using the same variable name in different scripts.  The <A HREF="eval.html#variables">variables</A> will be
kept <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> Vim is running.  And the same <A HREF="eval.html#variables">variables</A> are used when sourcing
the same <A HREF="#script">script</A> again. |<A HREF="eval.html#s:var">s:var</A>|

The fun is that these <A HREF="eval.html#variables">variables</A> can also be used in <A HREF="eval.html#functions">functions</A>, autocommands
and user commands that are defined in the <A HREF="#script">script</A>.  In our example we can add
a few lines to <A HREF="intro.html#count">count</A> the number of corrections:

<B> 19	let s:count = 4</B>
<B> ..</B>
<B> 30	function s:Add(from, correct)</B>
<B> ..</B>
<B> 34	  let s:count = s:count + 1</B>
<B> 35	  echo s:count . " corrections now"</B>
<B> 36	endfunction</B>

First s:count is initialized to 4 in the <A HREF="#script">script</A> itself.  When later the
s:Add() function is called, <A HREF="motion.html#it">it</A> increments s:count.  It doesn't matter from
where the function was called, since <A HREF="motion.html#it">it</A> has been defined in the <A HREF="#script">script</A>, <A HREF="motion.html#it">it</A>
will use the local <A HREF="eval.html#variables">variables</A> from this <A HREF="#script">script</A>.


THE RESULT

Here is the resulting complete example:

<B>  1	" Vim global plugin for correcting typing mistakes</B>
<B>  2	" Last Change:	2000 Oct 15</B>
<B>  3	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;</B>
<B>  4	" License:	This file is placed in the public domain.</B>
<B>  5</B>
<B>  6	if exists("g:loaded_typecorr")</B>
<B>  7	  finish</B>
<B>  8	endif</B>
<B>  9	let g:loaded_typecorr = 1</B>
<B> 10</B>
<B> 11	let s:save_cpo = &amp;cpo</B>
<B> 12	set cpo&amp;vim</B>
<B> 13</B>
<B> 14	iabbrev teh the</B>
<B> 15	iabbrev otehr other</B>
<B> 16	iabbrev wnat want</B>
<B> 17	iabbrev synchronisation</B>
<B> 18		\ synchronization</B>
<B> 19	let s:count = 4</B>
<B> 20</B>
<B> 21	if !hasmapto('&lt;Plug&gt;TypecorrAdd')</B>
<B> 22	  map &lt;unique&gt; &lt;Leader&gt;a  &lt;Plug&gt;TypecorrAdd</B>
<B> 23	endif</B>
<B> 24	noremap &lt;unique&gt; &lt;script&gt; &lt;Plug&gt;TypecorrAdd  &lt;SID&gt;Add</B>
<B> 25</B>
<B> 26	noremenu &lt;script&gt; Plugin.Add\ Correction      &lt;SID&gt;Add</B>
<B> 27</B>
<B> 28	noremap &lt;SID&gt;Add  :call &lt;SID&gt;Add(expand("&lt;cword&gt;"), 1)&lt;CR&gt;</B>
<B> 29</B>
<B> 30	function s:Add(from, correct)</B>
<B> 31	  let to = input("type the correction for " . a:from . ": ")</B>
<B> 32	  exe ":iabbrev " . a:from . " " . to</B>
<B> 33	  if a:correct | exe "normal viws\&lt;C-R&gt;\" \b\e" | endif</B>
<B> 34	  let s:count = s:count + 1</B>
<B> 35	  echo s:count . " corrections now"</B>
<B> 36	endfunction</B>
<B> 37</B>
<B> 38	if !exists(":Correct")</B>
<B> 39	  command -nargs=1  Correct  :call s:Add(&lt;q-args&gt;, 0)</B>
<B> 40	endif</B>
<B> 41</B>
<B> 42	let &amp;cpo = s:save_cpo</B>
<B> 43	unlet s:save_cpo</B>

Line 33 wasn't explained yet.  It applies the new correction to the <A HREF="motion.html#word">word</A> under
the cursor.  The |<A HREF="various.html#:normal">:normal</A>| command is used to use the new abbreviation.  Note
that mappings and <A HREF="map.html#abbreviations">abbreviations</A> are expanded here, even though the function
was called from a <A HREF="map.html#mapping">mapping</A> defined with &quot;<A HREF="map.html#:noremap">:noremap</A>&quot;.

Using &quot;<A HREF="os_unix.html#unix">unix</A>&quot; for the <A HREF="options.html#'fileformat'">'fileformat'</A> option is recommended.  The Vim scripts will
then work everywhere.  Scripts with <A HREF="options.html#'fileformat'">'fileformat'</A> set to &quot;<A HREF="os_dos.html#dos">dos</A>&quot; <A HREF="diff.html#do">do</A> not work on
<A HREF="os_unix.html#Unix">Unix</A>.  Also see |<A HREF="repeat.html#:source_crnl">:source_crnl</A>|.  To be sure <A HREF="motion.html#it">it</A> is set right, <A HREF="diff.html#do">do</A> this before
<A HREF="editing.html#writing">writing</A> the file:

<B>	:set fileformat=unix</B>



DOCUMENTATION						*<A NAME="write-local-help"></A><B>write-local-help</B>*

It's a good idea to also write some documentation for your <A HREF="usr_05.html#plugin">plugin</A>.  Especially
when its behavior can be changed by the user.  See |<A HREF="usr_05.html#add-local-help">add-local-help</A>| for how
they are installed.

Here is a simple example for a <A HREF="usr_05.html#plugin">plugin</A> help file, called &quot;<A HREF="#typecorr.txt">typecorr.txt</A>&quot;:

<B>  1	*typecorr.txt*	Plugin for correcting typing mistakes</B>
<B>  2</B>
<B>  3	If you make typing mistakes, this plugin will have them corrected</B>
<B>  4	automatically.</B>
<B>  5</B>
<B>  6	There are currently only a few corrections.  Add your own if you like.</B>
<B>  7</B>
<B>  8	Mappings:</B>
<B>  9	&lt;Leader&gt;a   or   &lt;Plug&gt;TypecorrAdd</B>
<B> 10		Add a correction for the word under the cursor.</B>
<B> 11</B>
<B> 12	Commands:</B>
<B> 13	:Correct {word}</B>
<B> 14		Add a correction for {word}.</B>
<B> 15</B>
<B> 16							*typecorr-settings*</B>
<B> 17	This plugin doesn't have any settings.</B>

The first line is actually the only one for which the format matters.  It will
be extracted from the help file to be put in the &quot;LOCAL ADDITIONS:&quot; section of
<A HREF="index.html#help.txt">help.txt</A> |<A HREF="index.html#local-additions">local-additions</A>|.  The first &quot;*&quot; must be in the first column of the
first line.  After adding your help file <A HREF="diff.html#do">do</A> &quot;<A HREF="helphelp.html#:help">:help</A>&quot; and check that the entries
line up nicely.


You can add more <A HREF="tagsrch.html#tags">tags</A> inside ** in your help file.  But be careful not to use
existing help <A HREF="tagsrch.html#tags">tags</A>.  You would probably use the name of your <A HREF="usr_05.html#plugin">plugin</A> in most of
them, like &quot;<A HREF="#typecorr-settings">typecorr-settings</A>&quot; in the example.

Using references to other parts of the help in &#124;&#124; is recommended.  This makes
<A HREF="motion.html#it">it</A> easy for the user to find associated help.



FILETYPE DETECTION					*<A NAME="plugin-filetype"></A><B>plugin-filetype</B>*

If your <A HREF="filetype.html#filetype">filetype</A> is not already detected by Vim, you should create a <A HREF="filetype.html#filetype">filetype</A>
detection snippet in a separate file.  It is usually in the form of an
<A HREF="autocmd.html#autocommand">autocommand</A> that sets the <A HREF="filetype.html#filetype">filetype</A> when the file name matches a <A HREF="pattern.html#pattern">pattern</A>.
Example:

<B>	au BufNewFile,BufRead *.foo			set filetype=foofoo</B>

Write this single-line file <A HREF="motion.html#as">as</A> &quot;ftdetect/foofoo.vim&quot; in the first directory
that appears in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.  For <A HREF="os_unix.html#Unix">Unix</A> that would be
&quot;~/.vim/ftdetect/foofoo.vim&quot;.  The convention is to use the name of the
<A HREF="filetype.html#filetype">filetype</A> for the <A HREF="#script">script</A> name.

You can make more complicated checks if you like, for example to inspect the
contents of the file to recognize the language.  Also see |<A HREF="filetype.html#new-filetype">new-filetype</A>|.



SUMMARY							*<A NAME="plugin-special"></A><B>plugin-special</B>*

Summary of special things to use in a <A HREF="usr_05.html#plugin">plugin</A>:

s:name			Variables local to the <A HREF="#script">script</A>.

<A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>			Script-ID, used for mappings and <A HREF="eval.html#functions">functions</A> local to
			the <A HREF="#script">script</A>.

<A HREF="eval.html#hasmapto()">hasmapto()</A>		Function to test if the user already defined a <A HREF="map.html#mapping">mapping</A>
			for functionality the <A HREF="#script">script</A> offers.

<A HREF="map.html#&lt;Leader&gt;">&lt;Leader&gt;</A>		Value of &quot;<A HREF="map.html#mapleader">mapleader</A>&quot;, which the user defines <A HREF="motion.html#as">as</A> the
			keys that <A HREF="usr_05.html#plugin">plugin</A> mappings start with.

<A HREF="map.html#:map">:map</A> &lt;unique&gt;		Give a warning if a <A HREF="map.html#mapping">mapping</A> already exists.

<A HREF="map.html#:noremap">:noremap</A> &lt;script&gt;	Use only mappings local to the <A HREF="#script">script</A>, not global
			mappings.

exists(&quot;:Cmd&quot;)		Check if a user command already exists.

==============================================================================

*<A NAME="41.12"></A><B>41.12</B>*	Writing a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>	*<A NAME="write-filetype-plugin"></A><B>write-filetype-plugin</B>* *<A NAME="ftplugin"></A><B>ftplugin</B>*

A <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> is like a global <A HREF="usr_05.html#plugin">plugin</A>, except that <A HREF="motion.html#it">it</A> sets <A HREF="options.html#options">options</A> and
defines mappings for the current buffer only.  See |<A HREF="usr_05.html#add-filetype-plugin">add-filetype-plugin</A>| for
how this type of <A HREF="usr_05.html#plugin">plugin</A> is used.

First read the section on global plugins above |<A HREF="#41.11">41.11</A>|.  All that is said there
also applies to <A HREF="filetype.html#filetype">filetype</A> plugins.  There are a few extras, which are explained
here.  The essential thing is that a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> should only have an
effect on the current buffer.


DISABLING

If you are <A HREF="editing.html#writing">writing</A> a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> to be used by many people, they need a
chance to disable loading <A HREF="motion.html#it">it</A>.  Put this at the top of the <A HREF="usr_05.html#plugin">plugin</A>:

<B>	" Only do this when not done yet for this buffer</B>
<B>	if exists("b:did_ftplugin")</B>
<B>	  finish</B>
<B>	endif</B>
<B>	let b:did_ftplugin = 1</B>

This also needs to be used to avoid that the same <A HREF="usr_05.html#plugin">plugin</A> is executed <A HREF="if_cscop.html#twice">twice</A> for
the same buffer (happens when using an &quot;<A HREF="editing.html#:edit">:edit</A>&quot; command without arguments).

Now users can disable loading the default <A HREF="usr_05.html#plugin">plugin</A> completely by making a
<A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> with only this line:

<B>	let b:did_ftplugin = 1</B>

This does require that the <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> directory comes before <A HREF="starting.html#$VIMRUNTIME">$VIMRUNTIME</A>
in <A HREF="options.html#'runtimepath'">'runtimepath'</A>!

If you <A HREF="diff.html#do">do</A> want to use the default <A HREF="usr_05.html#plugin">plugin</A>, but overrule one of the settings,
you can write the different setting in a <A HREF="#script">script</A>:

<B>	setlocal textwidth=70</B>

Now write this in the &quot;after&quot; directory, so that <A HREF="motion.html#it">it</A> gets sourced after the
distributed &quot;<A HREF="syntax.html#vim.vim">vim.vim</A>&quot; <A HREF="#ftplugin">ftplugin</A> |<A HREF="options.html#after-directory">after-directory</A>|.  For <A HREF="os_unix.html#Unix">Unix</A> this would be
&quot;~/.vim/after/ftplugin/vim.vim&quot;.  Note that the default <A HREF="usr_05.html#plugin">plugin</A> will have set
&quot;b:did_ftplugin&quot;, but <A HREF="motion.html#it">it</A> is ignored here.


OPTIONS

To make sure the <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> only affects the current buffer use the

<B>	:setlocal</B>

command to set <A HREF="options.html#options">options</A>.  And only set <A HREF="options.html#options">options</A> which are local to a buffer (see
the help for the option to check that).  When using |<A HREF="options.html#:setlocal">:setlocal</A>| for global
<A HREF="options.html#options">options</A> or <A HREF="options.html#options">options</A> local to a <A HREF="windows.html#window">window</A>, the value will change for many <A HREF="windows.html#buffers">buffers</A>,
and that is not what a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> should <A HREF="diff.html#do">do</A>.

When an option has a value that is a <A HREF="eval.html#list">list</A> of flags or items, consider using
&quot;+=&quot; and &quot;-=&quot; to keep the existing value.  Be aware that the user may have
changed an option value already.  First resetting to the default value and
then <A HREF="change.html#changing">changing</A> <A HREF="motion.html#it">it</A> is often a good idea.  Example:

<B>	:setlocal formatoptions&amp; formatoptions+=ro</B>


MAPPINGS

To make sure mappings will only work in the current buffer use the

<B>	:map &lt;buffer&gt;</B>

command.  This needs to be combined with the two-step <A HREF="map.html#mapping">mapping</A> explained above.
An example of how to define functionality in a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>:

<B>	if !hasmapto('&lt;Plug&gt;JavaImport')</B>
<B>	  map &lt;buffer&gt; &lt;unique&gt; &lt;LocalLeader&gt;i &lt;Plug&gt;JavaImport</B>
<B>	endif</B>
<B>	noremap &lt;buffer&gt; &lt;unique&gt; &lt;Plug&gt;JavaImport oimport ""&lt;Left&gt;&lt;Esc&gt;</B>

|<A HREF="eval.html#hasmapto()">hasmapto()</A>| is used to check if the user has already defined a map to
&lt;Plug&gt;JavaImport.  If not, then the <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> defines the default
<A HREF="map.html#mapping">mapping</A>.  This starts with |<A HREF="map.html#&lt;LocalLeader&gt;">&lt;LocalLeader&gt;</A>|, which allows the user to select
the key(s) he wants <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> mappings to start with.  The default is a
<A HREF="intro.html#backslash">backslash</A>.
&quot;&lt;unique&gt;&quot; is used to give an error message if the <A HREF="map.html#mapping">mapping</A> already exists or
overlaps with an existing <A HREF="map.html#mapping">mapping</A>.
|<A HREF="map.html#:noremap">:noremap</A>| is used to avoid that any other mappings that the user has defined
interferes.  You might want to use &quot;<A HREF="map.html#:noremap">:noremap</A> &lt;script&gt;&quot; to allow remapping
mappings defined in this <A HREF="#script">script</A> that start with <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>.

The user must have a chance to disable the mappings in a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>,
without disabling everything.  Here is an example of how this is done for a
<A HREF="usr_05.html#plugin">plugin</A> for the mail <A HREF="filetype.html#filetype">filetype</A>:

<B>	" Add mappings, unless the user didn't want this.</B>
<B>	if !exists("no_plugin_maps") &amp;&amp; !exists("no_mail_maps")</B>
<B>	  " Quote text by inserting "&gt; "</B>
<B>	  if !hasmapto('&lt;Plug&gt;MailQuote')</B>
<B>	    vmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</B>
<B>	    nmap &lt;buffer&gt; &lt;LocalLeader&gt;q &lt;Plug&gt;MailQuote</B>
<B>	  endif</B>
<B>	  vnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :s/^/&gt; /&lt;CR&gt;</B>
<B>	  nnoremap &lt;buffer&gt; &lt;Plug&gt;MailQuote :.,$s/^/&gt; /&lt;CR&gt;</B>
<B>	endif</B>

Two global <A HREF="eval.html#variables">variables</A> are used:
no_plugin_maps		disables mappings for all <A HREF="filetype.html#filetype">filetype</A> plugins
no_mail_maps		disables mappings for a specific <A HREF="filetype.html#filetype">filetype</A>


USER COMMANDS

To add a user command for a specific file type, so that <A HREF="motion.html#it">it</A> can only be used in
one buffer, use the &quot;-buffer&quot; argument to |<A HREF="map.html#:command">:command</A>|.  Example:

<B>	:command -buffer  Make  make %:r.s</B>


VARIABLES

A <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> will be sourced for each buffer of the type it's for.  Local
<A HREF="#script">script</A> <A HREF="eval.html#variables">variables</A> |<A HREF="eval.html#s:var">s:var</A>| will be shared between all invocations.  Use local
buffer <A HREF="eval.html#variables">variables</A> |<A HREF="eval.html#b:var">b:var</A>| if you want a variable specifically for one buffer.


FUNCTIONS

When defining a function, this only needs to be done once.  But the <A HREF="filetype.html#filetype">filetype</A>
<A HREF="usr_05.html#plugin">plugin</A> will be sourced every time a file with this <A HREF="filetype.html#filetype">filetype</A> will be opened.
This construct makes sure the function is only defined once:

<B>	:if !exists("*s:Func")</B>
<B>	:  function s:Func(arg)</B>
<B>	:    ...</B>
<B>	:  endfunction</B>
<B>	:endif</B>
 


UNDO							*<A NAME="undo_ftplugin"></A><B>undo_ftplugin</B>*

When the user does &quot;<A HREF="options.html#:setfiletype">:setfiletype</A> xyz&quot; the effect of the previous <A HREF="filetype.html#filetype">filetype</A>
should be undone.  Set the b:undo_ftplugin variable to the commands that will
<A HREF="undo.html#undo">undo</A> the settings in your <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>.  Example:

<B>	let b:undo_ftplugin = "setlocal fo&lt; com&lt; tw&lt; commentstring&lt;"</B>
<B>		\ . "| unlet b:match_ignorecase b:match_words b:match_skip"</B>

Using &quot;<A HREF="options.html#:setlocal">:setlocal</A>&quot; with &quot;<A HREF="change.html#&lt;">&lt;</A>&quot; after the option name resets the option to its
global value.  That is mostly the best way to reset the option value.

This does require removing the &quot;<A HREF="change.html#C">C</A>&quot; flag from <A HREF="options.html#'cpoptions'">'cpoptions'</A> to allow line
continuation, <A HREF="motion.html#as">as</A> mentioned above |<A HREF="#use-cpo-save">use-cpo-save</A>|.


FILE NAME

The <A HREF="filetype.html#filetype">filetype</A> must be included in the file name |<A HREF="usr_05.html#ftplugin-name">ftplugin-name</A>|.  Use one of
these three forms:

	.../ftplugin/stuff.vim
	.../ftplugin/stuff_foo.vim
	.../ftplugin/stuff/bar.vim

&quot;stuff&quot; is the <A HREF="filetype.html#filetype">filetype</A>, &quot;foo&quot; and &quot;<A HREF="motion.html#bar">bar</A>&quot; are arbitrary names.



SUMMARY							*<A NAME="ftplugin-special"></A><B>ftplugin-special</B>*

Summary of special things to use in a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>:

<A HREF="map.html#&lt;LocalLeader&gt;">&lt;LocalLeader&gt;</A>		Value of &quot;<A HREF="map.html#maplocalleader">maplocalleader</A>&quot;, which the user defines <A HREF="motion.html#as">as</A>
			the keys that <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A> mappings start with.

<A HREF="map.html#:map">:map</A> &lt;buffer&gt;		Define a <A HREF="map.html#mapping">mapping</A> local to the buffer.

<A HREF="map.html#:noremap">:noremap</A> &lt;script&gt;	Only remap mappings defined in this <A HREF="#script">script</A> that start
			with <A HREF="map.html#&lt;SID&gt;">&lt;SID&gt;</A>.

<A HREF="options.html#:setlocal">:setlocal</A>		Set an option for the current buffer only.

<A HREF="map.html#:command">:command</A> -buffer	Define a user command local to the buffer.

exists(&quot;*s:Func&quot;)	Check if a function was already defined.

Also see |<A HREF="#plugin-special">plugin-special</A>|, the special things used for all plugins.

==============================================================================

*<A NAME="41.13"></A><B>41.13</B>*	Writing a compiler <A HREF="usr_05.html#plugin">plugin</A>		*<A NAME="write-compiler-plugin"></A><B>write-compiler-plugin</B>*

A compiler <A HREF="usr_05.html#plugin">plugin</A> sets <A HREF="options.html#options">options</A> for use with a specific compiler.  The user can
load <A HREF="motion.html#it">it</A> with the |<A HREF="quickfix.html#:compiler">:compiler</A>| command.  The main use is to set the
<A HREF="options.html#'errorformat'">'errorformat'</A> and <A HREF="options.html#'makeprg'">'makeprg'</A> <A HREF="options.html#options">options</A>.

Easiest is to have a look at examples.  This command will edit all the default
compiler plugins:

<B>	:next $VIMRUNTIME/compiler/*.vim</B>

Use |<A HREF="editing.html#:next">:next</A>| to go to the next <A HREF="usr_05.html#plugin">plugin</A> file.

There are two special items about these files.  First is a mechanism to allow
a user to overrule or add to the default file.  The default files start with:

<B>	:if exists("current_compiler")</B>
<B>	:  finish</B>
<B>	:endif</B>
<B>	:let current_compiler = "mine"</B>

When you write a compiler file and put <A HREF="motion.html#it">it</A> in your personal runtime directory
(e.g., ~/.vim/compiler for Unix), you set the &quot;<A HREF="quickfix.html#current_compiler">current_compiler</A>&quot; variable to
make the default file skip the settings.

							*<A NAME=":CompilerSet"></A><B>:CompilerSet</B>*
The second mechanism is to use &quot;<A HREF="options.html#:set">:set</A>&quot; for &quot;:compiler!&quot; and &quot;<A HREF="options.html#:setlocal">:setlocal</A>&quot; for
&quot;<A HREF="quickfix.html#:compiler">:compiler</A>&quot;.  Vim defines the &quot;<A HREF="#:CompilerSet">:CompilerSet</A>&quot; user command for this.  However,
older Vim versions don't, thus your <A HREF="usr_05.html#plugin">plugin</A> should define <A HREF="motion.html#it">it</A> then.  This is an
example:

<B>  if exists(":CompilerSet") != 2</B>
<B>    command -nargs=* CompilerSet setlocal &lt;args&gt;</B>
<B>  endif</B>
<B>  CompilerSet errorformat&amp;		" use the default 'errorformat'</B>
<B>  CompilerSet makeprg=nmake</B>

When you write a compiler <A HREF="usr_05.html#plugin">plugin</A> for the Vim <A HREF="intro.html#distribution">distribution</A> or for a system-wide
runtime directory, use the mechanism mentioned above.  When
&quot;<A HREF="quickfix.html#current_compiler">current_compiler</A>&quot; was already set by a user <A HREF="usr_05.html#plugin">plugin</A> nothing will be done.

When you write a compiler <A HREF="usr_05.html#plugin">plugin</A> to overrule settings from a default <A HREF="usr_05.html#plugin">plugin</A>,
don't check &quot;<A HREF="quickfix.html#current_compiler">current_compiler</A>&quot;.  This <A HREF="usr_05.html#plugin">plugin</A> is supposed to be loaded
last, thus <A HREF="motion.html#it">it</A> should be in a directory at the end of <A HREF="options.html#'runtimepath'">'runtimepath'</A>.  For <A HREF="os_unix.html#Unix">Unix</A>
that could be ~/.vim/after/compiler.

==============================================================================

*<A NAME="41.14"></A><B>41.14</B>*	Writing a <A HREF="usr_05.html#plugin">plugin</A> that loads quickly	*<A NAME="write-plugin-quickload"></A><B>write-plugin-quickload</B>*

A <A HREF="usr_05.html#plugin">plugin</A> may grow and become quite long.  The <A HREF="starting.html#startup">startup</A> delay may become
noticeable, while you hardly ever use the <A HREF="usr_05.html#plugin">plugin</A>.  Then it's time for a
quickload <A HREF="usr_05.html#plugin">plugin</A>.

The basic idea is that the <A HREF="usr_05.html#plugin">plugin</A> is loaded <A HREF="if_cscop.html#twice">twice</A>.  The first time user
commands and mappings are defined that offer the functionality.  The second
time the <A HREF="eval.html#functions">functions</A> that implement the functionality are defined.

It may sound surprising that quickload means loading a <A HREF="#script">script</A> <A HREF="if_cscop.html#twice">twice</A>.  What we
mean is that <A HREF="motion.html#it">it</A> loads quickly the first time, postponing the bulk of the
<A HREF="#script">script</A> to the second time, which only happens when you actually use <A HREF="motion.html#it">it</A>.  When
you always use the functionality <A HREF="motion.html#it">it</A> actually gets slower!

Note that since Vim 7 there is an alternative: use the |<A HREF="eval.html#autoload">autoload</A>|
functionality |<A HREF="#41.15">41.15</A>|.

The following example shows how it's done:

<B>	" Vim global plugin for demonstrating quick loading</B>
<B>	" Last Change:	2005 Feb 25</B>
<B>	" Maintainer:	Bram Moolenaar &lt;Bram@vim.org&gt;</B>
<B>	" License:	This file is placed in the public domain.</B>

<B>	if !exists("s:did_load")</B>
<B>		command -nargs=* BNRead  call BufNetRead(&lt;f-args&gt;)</B>
<B>		map &lt;F19&gt; :call BufNetWrite('something')&lt;CR&gt;</B>

<B>		let s:did_load = 1</B>
<B>		exe 'au FuncUndefined BufNet* source ' . expand('&lt;sfile&gt;')</B>
<B>		finish</B>
<B>	endif</B>

<B>	function BufNetRead(...)</B>
<B>		echo 'BufNetRead(' . string(a:000) . ')'</B>
<B>		" read functionality here</B>
<B>	endfunction</B>

<B>	function BufNetWrite(...)</B>
<B>		echo 'BufNetWrite(' . string(a:000) . ')'</B>
<B>		" write functionality here</B>
<B>	endfunction</B>

When the <A HREF="#script">script</A> is first loaded &quot;s:did_load&quot; is not set.  The commands between
the &quot;if&quot; and &quot;endif&quot; will be executed.  This ends in a |<A HREF="repeat.html#:finish">:finish</A>| command, thus
the rest of the <A HREF="#script">script</A> is not executed.

The second time the <A HREF="#script">script</A> is loaded &quot;s:did_load&quot; exists and the commands
after the &quot;endif&quot; are executed.  This defines the (possible long)
BufNetRead() and BufNetWrite() <A HREF="eval.html#functions">functions</A>.

If you drop this <A HREF="#script">script</A> in your <A HREF="usr_05.html#plugin">plugin</A> directory Vim will execute <A HREF="motion.html#it">it</A> on
<A HREF="starting.html#startup">startup</A>.  This is the sequence of events that happens:

1. The &quot;BNRead&quot; command is defined and the <A HREF="term.html#&lt;F19&gt;">&lt;F19&gt;</A> key is mapped when the <A HREF="#script">script</A>
   is sourced at <A HREF="starting.html#startup">startup</A>.  A |<A HREF="autocmd.html#FuncUndefined">FuncUndefined</A>| <A HREF="autocmd.html#autocommand">autocommand</A> is defined.  The
   &quot;<A HREF="repeat.html#:finish">:finish</A>&quot; command causes the <A HREF="#script">script</A> to terminate early.

2. The user types the BNRead command or presses the <A HREF="term.html#&lt;F19&gt;">&lt;F19&gt;</A> key.  The
   BufNetRead() or BufNetWrite() function will be called.

3. Vim can't find the function and triggers the |<A HREF="autocmd.html#FuncUndefined">FuncUndefined</A>| <A HREF="autocmd.html#autocommand">autocommand</A>
   event.  Since the <A HREF="pattern.html#pattern">pattern</A> &quot;BufNet*&quot; matches the invoked function, the
   command &quot;source fname&quot; will be executed.  &quot;fname&quot; will be equal to the name
   of the <A HREF="#script">script</A>, no matter where <A HREF="motion.html#it">it</A> is located, because <A HREF="motion.html#it">it</A> comes from
   expanding &quot;<A HREF="cmdline.html#&lt;sfile&gt;">&lt;sfile&gt;</A>&quot; (see |<A HREF="eval.html#expand()">expand()</A>|).

4. The <A HREF="#script">script</A> is sourced again, the &quot;s:did_load&quot; variable exists and the
   <A HREF="eval.html#functions">functions</A> are defined.

Notice that the <A HREF="eval.html#functions">functions</A> that are loaded afterwards match the <A HREF="pattern.html#pattern">pattern</A> in the
|<A HREF="autocmd.html#FuncUndefined">FuncUndefined</A>| <A HREF="autocmd.html#autocommand">autocommand</A>.  You must make sure that no other <A HREF="usr_05.html#plugin">plugin</A> defines
<A HREF="eval.html#functions">functions</A> that match this <A HREF="pattern.html#pattern">pattern</A>.

==============================================================================

*<A NAME="41.15"></A><B>41.15</B>*	Writing library scripts			*<A NAME="write-library-script"></A><B>write-library-script</B>*

Some functionality will be required in several places.  When this becomes more
than a few lines you will want to put <A HREF="motion.html#it">it</A> in one <A HREF="#script">script</A> and use <A HREF="motion.html#it">it</A> from many
scripts.  We will call that one <A HREF="#script">script</A> a library <A HREF="#script">script</A>.

Manually loading a library <A HREF="#script">script</A> is possible, so long <A HREF="motion.html#as">as</A> you avoid loading <A HREF="motion.html#it">it</A>
when it's already done.  You can <A HREF="diff.html#do">do</A> this with the |<A HREF="eval.html#exists()">exists()</A>| function.
Example:

<B>	if !exists('*MyLibFunction')</B>
<B>	   runtime library/mylibscript.vim</B>
<B>	endif</B>
<B>	call MyLibFunction(arg)</B>

Here you need to know that MyLibFunction() is defined in a <A HREF="#script">script</A>
&quot;library/mylibscript.vim&quot; in one of the directories in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.

To make this a bit simpler Vim offers the <A HREF="eval.html#autoload">autoload</A> mechanism.  Then the
example looks like this:

<B>	call mylib#myfunction(arg)</B>

That's a lot simpler, isn't <A HREF="motion.html#it">it</A>?  Vim will recognize the function name and when
it's not defined search for the <A HREF="#script">script</A> &quot;autoload/mylib.vim&quot; in <A HREF="options.html#'runtimepath'">'runtimepath'</A>.
That <A HREF="#script">script</A> must define the &quot;mylib#myfunction()&quot; function.

You can put many other <A HREF="eval.html#functions">functions</A> in the mylib.vim <A HREF="#script">script</A>, you are free to
organize your <A HREF="eval.html#functions">functions</A> in library scripts.  But you must use function names
where the part before the '<A HREF="pattern.html##">#</A>' matches the <A HREF="#script">script</A> name.  Otherwise Vim would
not know what <A HREF="#script">script</A> to load.

If you get really enthusiastic and write lots of library scripts, you may
want to use subdirectories.  Example:

<B>	call netlib#ftp#read('somefile')</B>

For <A HREF="os_unix.html#Unix">Unix</A> the library <A HREF="#script">script</A> used for this could be:

	~/.vim/autoload/netlib/ftp.vim

Where the function is defined like this:

<B>	function netlib#ftp#read(fname)</B>
<B>		"  Read the file fname through ftp</B>
<B>	endfunction</B>

Notice that the name the function is defined with is exactly the same <A HREF="motion.html#as">as</A> the
name used for calling the function.  And the part before the last '<A HREF="pattern.html##">#</A>'
exactly matches the subdirectory and <A HREF="#script">script</A> name.

You can use the same mechanism for <A HREF="eval.html#variables">variables</A>:

<B>	let weekdays = dutch#weekdays</B>

This will load the <A HREF="#script">script</A> &quot;autoload/dutch.vim&quot;, which should contain something
like:

<B>	let dutch#weekdays = ['zondag', 'maandag', 'dinsdag', 'woensdag',</B>
<B>		\ 'donderdag', 'vrijdag', 'zaterdag']</B>

Further reading: |<A HREF="eval.html#autoload">autoload</A>|.

==============================================================================

*<A NAME="41.16"></A><B>41.16</B>*	Distributing Vim scripts			*<A NAME="distribute-script"></A><B>distribute-script</B>*

 Vim users will look for scripts on the Vim website:	<A HREF="http://www.vim.org">http://www.vim.org</A>.
If you made something that is useful for others, share <A HREF="motion.html#it">it</A>!

Vim scripts can be used on any system.  There might not be a <A HREF="pi_tar.html#tar">tar</A> or <A HREF="pi_gzip.html#gzip">gzip</A>
command.  If you want to pack files together and/or <A HREF="pi_gzip.html#compress">compress</A> them the &quot;<A HREF="pi_zip.html#zip">zip</A>&quot;
utility is recommended.

For utmost portability use Vim itself to pack scripts together.  This can be
done with the Vimball utility.  See |<A HREF="pi_vimball.html#vimball">vimball</A>|.

It's good if you add a line to allow automatic updating.  See |<A HREF="pi_getscript.html#glvs-plugins">glvs-plugins</A>|.

==============================================================================

Next chapter: |<A HREF="usr_42.html">usr_42.txt</A>|  Add new <A HREF="gui.html#menus">menus</A>

Copyright: see |<A HREF="usr_01.html#manual-copyright">manual-copyright</A>|  vim:tw=78:ts=8:ft=help:norl:
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Thu Mar 12 08:17:21 UTC 2015 from <a href="https://github.com/neovim/neovim/commit/032c20078a617252ff9fc5ac03b4c390a6868a4d"><code>032c200</code></a>.
      </div>
    </footer>
  </body>
</html>
