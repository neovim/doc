<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Vim documentation: msgpack_rpc</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <div class="site-nav">
          <ul>
            <li><a href="/">Neovim Home</a></li>
          </ul>
        </div>
        <a href="/"><img class="logo" alt="Vim documentation: msgpack_rpc" src="/images/logo@2x.png" /></a>
      </div>
    </header>

    <div class="container">
      <h1>Vim documentation: msgpack_rpc</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="msgpack_rpc.txt"></A><B>msgpack_rpc.txt</B>*    For Nvim.						 {Nvim}


		 NVIM REFERENCE MANUAL    by Thiago de Arruda



The Msgpack-RPC Interface to Nvim				  *<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*

1. Introduction			|<A HREF="#msgpack-rpc-intro">msgpack-rpc-intro</A>|
2. API				|<A HREF="#msgpack-rpc-api">msgpack-rpc-api</A>|
3. Connecting			|<A HREF="#msgpack-rpc-connecting">msgpack-rpc-connecting</A>|
4. Clients			|<A HREF="#msgpack-rpc-clients">msgpack-rpc-clients</A>|
5. Types			|<A HREF="#msgpack-rpc-types">msgpack-rpc-types</A>|
6. Wrapping methods		|<A HREF="#msgpack-rpc-wrap-methods">msgpack-rpc-wrap-methods</A>|
7. Vimscript functions		|<A HREF="#msgpack-rpc-vim-functions">msgpack-rpc-vim-functions</A>|

==============================================================================

1. Introduction						    *<A NAME="msgpack-rpc-intro"></A><B>msgpack-rpc-intro</B>*

The primary means of controlling a running Nvim instance is through
MessagePack-RPC, a messaging protocol that uses the MessagePack serialization
format: https://github.com/msgpack/msgpack/blob/7498cf3/spec.md.
From now on, we'll be referring to the protocol <A HREF="motion.html#as">as</A> <A HREF="#msgpack-rpc">msgpack-rpc</A>.

At this point, only plugins use <A HREF="#msgpack-rpc">msgpack-rpc</A>, but eventually even user
interaction will be achieved through the protocol, since user interfaces will
be separate programs that <A HREF="intro.html#control">control</A> a headless Nvim instance.

This is what can be achieved by connecting to the <A HREF="#msgpack-rpc">msgpack-rpc</A> interface:

- Call any Nvim API function
- Listen for Nvim events
- Receive remote calls from Nvim

Nvim's <A HREF="#msgpack-rpc">msgpack-rpc</A> interface can be seen <A HREF="motion.html#as">as</A> a more powerful version of Vim's
`clientserver` feature.

==============================================================================

2. API							      *<A NAME="msgpack-rpc-api"></A><B>msgpack-rpc-api</B>*

The Nvim C API is automatically exposed to the <A HREF="#msgpack-rpc">msgpack-rpc</A> interface by the
build system, which parses headers at src/nvim/api from the project root. A
dispatch function is generated, which matches <A HREF="#msgpack-rpc">msgpack-rpc</A> method names with
non-static API <A HREF="eval.html#functions">functions</A>, converting/validating arguments and return values
back to msgpack.

Client libraries will normally provide wrappers that hide <A HREF="#msgpack-rpc">msgpack-rpc</A> details
from programmers, which can be automatically generated by reading bundled API
metadata from a compiled <A HREF="nvim_intro.html#nvim">nvim</A> instance.

There are two ways to obtain API metadata:

1. By connecting to a running <A HREF="nvim_intro.html#nvim">nvim</A> instance and calling `vim_get_api_info`
   via <A HREF="#msgpack-rpc">msgpack-rpc</A>. This is the preferred way for clients written in
   dynamically-typed languages, which can define <A HREF="eval.html#functions">functions</A> at runtime.

2. Through the `--api-info` command-line option, which makes <A HREF="nvim_intro.html#nvim">nvim</A> dump a
   msgpack blob containing metadata to stdout and exit. This is preferred
   when <A HREF="editing.html#writing">writing</A> clients for statically-typed languages, which require a
   separate compilation step.

Here's a simple way to get human-readable description of the API (requires
<A HREF="if_pyth.html#Python">Python</A> and the `pyyaml`/`msgpack-python` pip packages):

<B>    nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))' &gt; api.yaml</B>

==============================================================================

3. Connecting					       *<A NAME="msgpack-rpc-connecting"></A><B>msgpack-rpc-connecting</B>*

There are four ways to open <A HREF="#msgpack-rpc">msgpack-rpc</A> streams to <A HREF="nvim_intro.html#nvim">nvim</A>:

1. Through Nvim's stdin/stdout when started with the `--embed` option. This is
   how other programs can embed <A HREF="nvim_intro.html#nvim">nvim</A>.

2. Through the stdin/stdout of a program spawned by the |<A HREF="eval.html#rpcstart()">rpcstart()</A>| function.

3. Through the socket automatically created with each instance. To find out
   the socket location (which is random by default) from a running <A HREF="nvim_intro.html#nvim">nvim</A>
   instance, one can inspect the |<A HREF="intro.html#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| environment variable:

<B>    :echo $NVIM_LISTEN_ADDRESS</B>
 
4. Through a TCP/IP socket. To make <A HREF="nvim_intro.html#nvim">nvim</A> listen on a TCP/IP socket, set the
   |<A HREF="intro.html#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| environment variable in a shell before starting:

<B>    NVIM_LISTEN_ADDRESS=127.0.0.1:6666 nvim</B>
 
Connecting to the socket is the easiest way a programmer can test the API,
which can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or fully-featured
Nvim client (which we'll see below). Here's a <A HREF="if_ruby.html#ruby">ruby</A> <A HREF="usr_41.html#script">script</A> that will print the
<A HREF="eval.html#string">string</A> 'hello world!' on the current <A HREF="nvim_intro.html#nvim">nvim</A> instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #	:!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:vim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the `neovim` package, where API
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from neovim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
==============================================================================

4. Implementing new clients				  *<A NAME="msgpack-rpc-clients"></A><B>msgpack-rpc-clients</B>*

Nvim is still in alpha, so there's no in-depth documentation explaining how to
properly implement a client library yet. The <A HREF="if_pyth.html#Python">Python</A> client (the pip package
&quot;neovim&quot;) will always be up-to-date with the latest API changes, so its source
code is the best documentation currently available. There are some guidelines
however:

- Separate the transport layer from the rest of the library. See
  |<A HREF="#msgpack-rpc-connecting">msgpack-rpc-connecting</A>| for details on how clients can connect to <A HREF="nvim_intro.html#nvim">nvim</A>.
- Use a MessagePack library that implements at least version 5 of the
  MessagePack spec, which supports the `bin` and `ext` types used by <A HREF="nvim_intro.html#nvim">nvim</A>.
- Read API metadata in order to create client-side wrappers for all
  <A HREF="#msgpack-rpc">msgpack-rpc</A> methods.
- Use a single-threaded event loop library/pattern.
- Use a fiber/coroutine library for the language being used for implementing a
  client. These greatly simplify concurrency and allow the library to expose a
  blocking API on top of a non-blocking event loop without the complexity that
  comes with preemptive multitasking.
- Don't assume anything about the order that responses to <A HREF="#msgpack-rpc">msgpack-rpc</A> requests
  will arrive.
- Clients should expect to receive <A HREF="#msgpack-rpc">msgpack-rpc</A> requests, which need to be
  handled immediately because Nvim is blocked while waiting for the client
  response.
- Clients should expect to receive <A HREF="#msgpack-rpc">msgpack-rpc</A> notifications, but these don't
  need to be handled immediately because they won't block Nvim (although they
  should probably be handled immediately anyway).

Most of the complexity could be handled by a <A HREF="#msgpack-rpc">msgpack-rpc</A> library that supports
server to client requests and notifications, but it's not clear if this is part
of the <A HREF="#msgpack-rpc">msgpack-rpc</A> spec. At least the <A HREF="if_ruby.html#ruby">ruby</A> <A HREF="#msgpack-rpc">msgpack-rpc</A> library does not seem
to support <A HREF="motion.html#it">it</A>:
https://github.com/msgpack-rpc/msgpack-rpc-ruby/blob/master/lib/msgpack/rpc/transport/tcp.rb#L150-L158

==============================================================================

5. Types						    *<A NAME="msgpack-rpc-types"></A><B>msgpack-rpc-types</B>*

Nvim's C API uses custom types for all <A HREF="eval.html#functions">functions</A> (some are just typedefs
around C99 standard types). The types can be split into two groups:

- Basic types that map natively to msgpack (and probably have a default
  representation in msgpack-supported programming languages)
- Special Nvim types that map to msgpack EXT with custom type codes.

Basic type <A HREF="map.html#mapping">mapping</A>:

Nil				  -&gt; msgpack nil
Boolean				  -&gt; msgpack <A HREF="options.html#boolean">boolean</A>
Integer (signed 64-bit integer)	  -&gt; msgpack integer
<A HREF="eval.html#Float">Float</A> (IEEE 754 double precision) -&gt; msgpack float
String				  -&gt; msgpack binary
Array				  -&gt; msgpack array
<A HREF="eval.html#Dictionary">Dictionary</A>			  -&gt; msgpack map

Special Nvim types that use msgpack EXT:

Buffer				  -&gt; enum value kObjectTypeBuffer
Window				  -&gt; enum value kObjectTypeWindow
Tabpage				  -&gt; enum value kObjectTypeTabpage

The most reliable way of determining the type codes for the special <A HREF="nvim_intro.html#nvim">nvim</A> types
is at runtime by inspecting the `types` key of metadata dictionary returned by
`vim_get_api_info` method. Here's an example json representation of the
`types` object:

<B>  "types": {</B>
<B>    "Buffer": {</B>
<B>      "id": 0</B>
<B>    },</B>
<B>    "Window": {</B>
<B>      "id": 1</B>
<B>    },</B>
<B>    "Tabpage": {</B>
<B>      "id": 2</B>
<B>    }</B>
<B>  }</B>
 
Even for statically compiled clients, it's a good practice to avoid hardcoding
the type codes, because a client may build for a Nvim version and connect to
another that may have different type codes.

==============================================================================

6. Wrapping methods				     *<A NAME="msgpack-rpc-wrap-methods"></A><B>msgpack-rpc-wrap-methods</B>*

As mentioned before, clients should provide an API that hides <A HREF="#msgpack-rpc">msgpack-rpc</A>
details from programmers, and the API metadata object contains information
that makes this task easier:

- The &quot;<A HREF="eval.html#functions">functions</A>&quot; key contains a <A HREF="eval.html#list">list</A> of metadata <A HREF="vimindex.html#objects">objects</A> for individual
  <A HREF="eval.html#functions">functions</A>.
- Each function metadata object has type information about the return value
  and parameters. These can be used for generating strongly-typed APIs in
  static languages.
- Container types may be decorated with type/size constraints, e.g.
  ArrayOf(Buffer) or ArrayOf(Integer, 2). This can be useful to generate even
  more strongly-typed APIs.
- Methods that operate instances of Nvim's types are prefixed with the type
  name in lower <A HREF="change.html#case">case</A>, e.g. `buffer_get_line` represents the `get_line` method
  of a Buffer instance.
- Global methods are prefixed with `vim`, e.g. `vim_list_buffers`.

So, for an object-oriented language, a client library would have the classes
that represent Nvim's types, and the methods of each class could be defined
by inspecting the method name prefix. There could also be a singleton Vim
class with methods mapped to <A HREF="eval.html#functions">functions</A> prefixed with `vim_`

==============================================================================

7. Vimscript <A HREF="eval.html#functions">functions</A>				   *<A NAME="msgpack-rpc-vim-functions"></A><B>msgpack-rpc-vim-functions</B>*

Four <A HREF="eval.html#functions">functions</A> related to <A HREF="#msgpack-rpc">msgpack-rpc</A> are available in vimscript:

1. |<A HREF="eval.html#rpcstart()">rpcstart()</A>|: Similarly to |<A HREF="eval.html#jobstart()">jobstart()</A>|, this will spawn a co-process with
   its standard handles connected to Nvim. The difference is that it's not
   possible to process raw data to/from the process's stdin/stdout/stderr.
   This is because the job's stdin and stdout are used <A HREF="motion.html#as">as</A> a single msgpack
   channel that is processed directly by Nvim.

2. |<A HREF="eval.html#rpcstop()">rpcstop()</A>|: Same <A HREF="motion.html#as">as</A> |<A HREF="eval.html#jobstop()">jobstop()</A>|, but operates on handles returned by
   |<A HREF="eval.html#rpcstart()">rpcstart()</A>|.

3. |rpcrequest()|: Sends a <A HREF="#msgpack-rpc">msgpack-rpc</A> request to the process.

4. |rpcnotify()|: Sends a <A HREF="#msgpack-rpc">msgpack-rpc</A> notification to the process.

The last two <A HREF="eval.html#functions">functions</A> may also be used with channels created from
connections to |<A HREF="intro.html#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>|.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun Mar 15 08:24:40 UTC 2015 from <a href="https://github.com/neovim/neovim/commit/3e9ca91ff6832000340b4bda85ca2412f7d26dc7"><code>3e9ca91</code></a>.
      </div>
    </footer>
  </body>
</html>
