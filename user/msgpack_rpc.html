<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Vim documentation: msgpack_rpc</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Vim documentation: msgpack_rpc</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="msgpack_rpc.txt"></A><B>msgpack_rpc.txt</B>*    For Nvim.						 {Nvim}


		 NVIM REFERENCE MANUAL    by Thiago de Arruda



The Msgpack-RPC Interface to Nvim				  *<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*

1. Introduction			|<A HREF="#msgpack-rpc-intro">msgpack-rpc-intro</A>|
2. API				|<A HREF="#msgpack-rpc-api">msgpack-rpc-api</A>|
3. Connecting			|<A HREF="#msgpack-rpc-connecting">msgpack-rpc-connecting</A>|
4. Clients			|<A HREF="#msgpack-rpc-clients">msgpack-rpc-clients</A>|
5. Types			|<A HREF="#msgpack-rpc-types">msgpack-rpc-types</A>|
6. Wrapping methods		|<A HREF="#msgpack-rpc-wrap-methods">msgpack-rpc-wrap-methods</A>|
7. Vimscript functions		|<A HREF="#msgpack-rpc-vim-functions">msgpack-rpc-vim-functions</A>|

==============================================================================

1. Introduction						    *<A NAME="msgpack-rpc-intro"></A><B>msgpack-rpc-intro</B>*

The primary way to <A HREF="intro.html#control">control</A> a running Nvim instance is through
MessagePack-RPC, a messaging protocol that uses the MessagePack serialization
format: https://github.com/msgpack/msgpack/blob/7498cf3/spec.md.
From now on, we refer to the protocol <A HREF="motion.html#as">as</A> <A HREF="#msgpack-rpc">msgpack-rpc</A>.

At this point, only plugins use <A HREF="#msgpack-rpc">msgpack-rpc</A>, but eventually even user
interaction will happen through <A HREF="motion.html#it">it</A>, since user interfaces will be separate
programs that <A HREF="intro.html#control">control</A> a headless Nvim instance.

By connecting to the <A HREF="#msgpack-rpc">msgpack-rpc</A> interface, programs can:

- Call any Nvim API function
- Listen for Nvim events
- Receive remote calls from Nvim

Nvim's <A HREF="#msgpack-rpc">msgpack-rpc</A> interface is like a more powerful version of Vim's
`clientserver` feature.

==============================================================================

2. API							      *<A NAME="msgpack-rpc-api"></A><B>msgpack-rpc-api</B>*

The Nvim C API is automatically exposed to the <A HREF="#msgpack-rpc">msgpack-rpc</A> interface by the
build system, which parses headers at src/nvim/api from the project root. A
dispatch function is generated, which matches <A HREF="#msgpack-rpc">msgpack-rpc</A> method names with
non-static API <A HREF="eval.html#functions">functions</A>, converting/validating arguments and return values
back to msgpack.

Client libraries will normally provide wrappers that hide <A HREF="#msgpack-rpc">msgpack-rpc</A> details
from programmers. The wrappers can be automatically generated by reading
bundled API metadata from a compiled Nvim instance.

There are two ways to obtain API metadata:

1. By connecting to a running Nvim instance and calling `vim_get_api_info`
   via <A HREF="#msgpack-rpc">msgpack-rpc</A>. This is best for clients written in dynamically-typed
   languages, which can define <A HREF="eval.html#functions">functions</A> at runtime.

2. By starting Nvim with the `--api-info` command-line option, which makes Nvim
   dump a blob of msgpack metadata to standard output and exit. This is best
   for clients written in statically-typed languages, which require a separate
   compilation step.

Here's a simple way to get human-readable description of the API (requires
<A HREF="if_pyth.html#Python">Python</A> and the `pyyaml`/`msgpack-python` pip packages):

<B>    nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))' &gt; api.yaml</B>

==============================================================================

3. Connecting					       *<A NAME="msgpack-rpc-connecting"></A><B>msgpack-rpc-connecting</B>*

There are four ways to open <A HREF="#msgpack-rpc">msgpack-rpc</A> streams to Nvim:

1. Through Nvim's stdin/stdout when it's started with the `--embed` option.
   This is how other programs can embed Nvim.

2. Through the stdin/stdout of a program spawned by the |<A HREF="eval.html#rpcstart()">rpcstart()</A>| function.


							*<A NAME="$NVIM_LISTEN_ADDRESS"></A><B>$NVIM_LISTEN_ADDRESS</B>*
3. Through the socket automatically created with each instance. To get the
   socket location for a running Nvim instance (which is random by default),
   see the |<A HREF="#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| environment variable:

<B>       :echo $NVIM_LISTEN_ADDRESS</B>
 
   See also |<A HREF="eval.html#v:servername">v:servername</A>|.

4. Through a TCP/IP socket. To make Nvim listen on a TCP/IP socket, set the
   |<A HREF="#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| environment variable in a shell before starting Nvim:

<B>        NVIM_LISTEN_ADDRESS=127.0.0.1:6666 nvim</B>
 
Connecting to the socket is the easiest way a programmer can test the API, which
can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or fully-featured Nvim client
(which we'll see in the next section). Here's a Ruby <A HREF="usr_41.html#script">script</A> that prints 'hello
world!' in the current Nvim instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running Nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since Nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #	:!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:vim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the `neovim` package, where API
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from neovim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
One can also spawn and connect to an embedded Nvim instance via |<A HREF="eval.html#rpcstart()">rpcstart()</A>|

<B>    let vim = rpcstart('nvim', ['--embed'])</B>
<B>    echo rpcrequest(vim, 'vim_eval', '"Hello " . "world!"')</B>
<B>    call rpcstop(vim)</B>
 
==============================================================================

4. Implementing new clients				  *<A NAME="msgpack-rpc-clients"></A><B>msgpack-rpc-clients</B>*

Nvim is still in alpha, so there's no in-depth documentation explaining how to
properly implement a client library yet. The <A HREF="if_pyth.html#Python">Python</A> client (the pip package
&quot;neovim&quot;) will always be up-to-date with the latest API changes, so its source
code is the best documentation currently available. There are some guidelines
however:

- Separate the transport layer from the rest of the library. See
  |<A HREF="#msgpack-rpc-connecting">msgpack-rpc-connecting</A>| for details on how clients can connect to Nvim.
- Use a MessagePack library that implements at least version 5 of the
  MessagePack spec, which supports the `bin` and `ext` types used by Nvim.
- Read API metadata in order to create client-side wrappers for all
  <A HREF="#msgpack-rpc">msgpack-rpc</A> methods.
- Use a single-threaded event loop library/pattern.
- Use a fiber/coroutine library for the language being used for implementing a
  client. These greatly simplify concurrency and allow the library to expose a
  blocking API on top of a non-blocking event loop without the complexity that
  comes with preemptive multitasking.
- Don't assume anything about the order that responses to <A HREF="#msgpack-rpc">msgpack-rpc</A> requests
  will arrive.
- Clients should expect <A HREF="#msgpack-rpc">msgpack-rpc</A> requests, which need to be handled
  immediately because Nvim is blocked while waiting for the client response.
- Clients should expect to receive <A HREF="#msgpack-rpc">msgpack-rpc</A> notifications, but these don't
  need to be handled immediately because they won't block Nvim (although they
  should probably be handled immediately anyway).

Most of the complexity could be handled by a <A HREF="#msgpack-rpc">msgpack-rpc</A> library that supports
server to client requests and notifications, but it's not clear if this is part
of the <A HREF="#msgpack-rpc">msgpack-rpc</A> spec. At least the Ruby <A HREF="#msgpack-rpc">msgpack-rpc</A> library does not seem
to support <A HREF="motion.html#it">it</A>:

https://github.com/msgpack-rpc/msgpack-rpc-ruby/blob/master/lib/msgpack/rpc/transport/tcp.rb#L150-L158

==============================================================================

5. Types						    *<A NAME="msgpack-rpc-types"></A><B>msgpack-rpc-types</B>*

Nvim's C API uses custom types for all <A HREF="eval.html#functions">functions</A> (some are just typedefs
around C99 standard types). The types can be split into two groups:

- Basic types that map natively to msgpack (and probably have a default
  representation in msgpack-supported programming languages)
- Special Nvim types that map to msgpack EXT with custom type codes.

Basic type <A HREF="map.html#mapping">mapping</A>:

Nil				  -&gt; msgpack nil
Boolean				  -&gt; msgpack <A HREF="options.html#boolean">boolean</A>
Integer (signed 64-bit integer)	  -&gt; msgpack integer
<A HREF="eval.html#Float">Float</A> (IEEE 754 double precision) -&gt; msgpack float
String				  -&gt; msgpack <A HREF="eval.html#string">string</A>
Array				  -&gt; msgpack array
<A HREF="eval.html#Dictionary">Dictionary</A>			  -&gt; msgpack map

Special Nvim types that use msgpack EXT:

Buffer				  -&gt; enum value kObjectTypeBuffer
Window				  -&gt; enum value kObjectTypeWindow
Tabpage				  -&gt; enum value kObjectTypeTabpage

An API method expecting one of these types may be passed an integer instead,
although they are not interchangeable. For example, a Buffer may be passed <A HREF="motion.html#as">as</A>
an integer, but not a Window or Tabpage.

The most reliable way of determining the type codes for the special Nvim types
is to inspect the `types` key of metadata dictionary returned by the
`vim_get_api_info` method at runtime. Here's an example JSON representation of
the `types` object:

<B>  "types": {</B>
<B>    "Buffer": {</B>
<B>      "id": 0</B>
<B>    },</B>
<B>    "Window": {</B>
<B>      "id": 1</B>
<B>    },</B>
<B>    "Tabpage": {</B>
<B>      "id": 2</B>
<B>    }</B>
<B>  }</B>
 
Even for statically compiled clients, it's a good practice to avoid hardcoding
the type codes, because a client may be built against one Nvim version but connect
to another with different type codes.

==============================================================================

6. Wrapping methods				     *<A NAME="msgpack-rpc-wrap-methods"></A><B>msgpack-rpc-wrap-methods</B>*

As mentioned before, clients should provide an API that hides <A HREF="#msgpack-rpc">msgpack-rpc</A>
details from programmers, and the API metadata object contains information
that makes this task easier:

- The &quot;<A HREF="eval.html#functions">functions</A>&quot; key contains a <A HREF="eval.html#list">list</A> of metadata <A HREF="vimindex.html#objects">objects</A> for individual
  <A HREF="eval.html#functions">functions</A>.
- Each function metadata object has type information about the return value
  and parameters. These can be used for generating strongly-typed APIs in
  static languages.
- Container types may be decorated with type/size constraints, e.g.
  ArrayOf(Buffer) or ArrayOf(Integer, 2). This can be useful to generate even
  more strongly-typed APIs.
- Methods that operate instances of Nvim's types are prefixed with the type
  name in lower <A HREF="change.html#case">case</A>, e.g. `buffer_get_line` represents the `get_line` method
  of a Buffer instance.
- Global methods are prefixed with `vim`, e.g. `vim_get_buffers`.

So, for an object-oriented language, a client library would have the classes
that represent Nvim's types, and the methods of each class could be defined
by inspecting the method name prefix. There could also be a singleton Vim
class with methods mapped to <A HREF="eval.html#functions">functions</A> prefixed with `vim_`

==============================================================================

7. Vimscript <A HREF="eval.html#functions">functions</A>				   *<A NAME="msgpack-rpc-vim-functions"></A><B>msgpack-rpc-vim-functions</B>*

Four <A HREF="#msgpack-rpc">msgpack-rpc</A> <A HREF="eval.html#functions">functions</A> are available in Vimscript:

1. |<A HREF="eval.html#rpcstart()">rpcstart()</A>|: Similarly to |<A HREF="eval.html#jobstart()">jobstart()</A>|, this will spawn a co-process with
   its standard handles connected to Nvim. The difference is that it's not
   possible to process raw data to or from the process's stdin, stdout, or
   stderr.  This is because the job's stdin and stdout are used <A HREF="motion.html#as">as</A> a single
   msgpack channel that is processed directly by Nvim.

2. |<A HREF="eval.html#rpcstop()">rpcstop()</A>|: Same <A HREF="motion.html#as">as</A> |<A HREF="eval.html#jobstop()">jobstop()</A>|, but operates on handles returned by
   |<A HREF="eval.html#rpcstart()">rpcstart()</A>|.

3. |rpcrequest()|: Sends a <A HREF="#msgpack-rpc">msgpack-rpc</A> request to the process.

4. |rpcnotify()|: Sends a <A HREF="#msgpack-rpc">msgpack-rpc</A> notification to the process.

The last two <A HREF="eval.html#functions">functions</A> may also be used with channels created from
connections to |<A HREF="#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>|.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sun Nov  1 09:16:04 UTC 2015 from <a href="https://github.com/neovim/neovim/commit/2e4baa9ae475e1ea01c5e15a440933b4814f0637"><code>2e4baa9</code></a>.
      </div>
    </footer>
  </body>
</html>
