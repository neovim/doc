<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta content="width=device-width, initial-scale=1" name="viewport">
    <title>Vim documentation: msgpack_rpc</title>
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700,900" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.0/normalize.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href="/css/main.css" rel="stylesheet">
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
  </head>
  <body>
    <header class="navbar">
      <div class="container">
        <nav class="navbar">
          <div class="container-fluid">
            <div class="navbar-header">

              <a href="/" class="navbar-brand">
                <img src="/images/logo@2x.png" id="navbar-logo" alt="Neovim">
              </a>
            </div>
          </div>
        </nav>
      </div>
    </header>

    <div class="container">
      <h1>Vim documentation: msgpack_rpc</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

*<A NAME="msgpack_rpc.txt"></A><B>msgpack_rpc.txt</B>*							{Nvim}


		 NVIM REFERENCE MANUAL    by Thiago de Arruda



<A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> for Nvim				     *<A NAME="RPC"></A><B>RPC</B>* *<A NAME="rpc"></A><B>rpc</B>* *<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*

1. Introduction			|<A HREF="#rpc-intro">rpc-intro</A>|
2. <A HREF="api.html#API">API</A> <A HREF="map.html#mapping">mapping</A>			|<A HREF="#rpc-api">rpc-api</A>|
3. Connecting			|<A HREF="#rpc-connecting">rpc-connecting</A>|
4. Clients			|<A HREF="#rpc-api-client">rpc-api-client</A>|
5. Types			|<A HREF="#rpc-types">rpc-types</A>|
6. Remote UIs			|<A HREF="#rpc-remote-ui">rpc-remote-ui</A>|

==============================================================================

1. Introduction						            *<A NAME="rpc-intro"></A><B>rpc-intro</B>*

The primary way to <A HREF="intro.html#control">control</A> Nvim programmatically is the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>, which speaks
MessagePack-RPC (&quot;msgpack-rpc&quot;), a messaging protocol that uses the
MessagePack serialization format:
  https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md

All kinds of Nvim &quot;clients&quot; use the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>: user interfaces (GUIs), remote
plugins, scripts like &quot;nvr&quot; (https://github.com/mhinz/neovim-remote), and even
`nvim` itself can <A HREF="intro.html#control">control</A> other `nvim` instances. By connecting to the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>
programs can:

  - Call any <A HREF="api.html#API">API</A> function
  - Listen for events
  - Receive remote calls from Nvim

The <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> is like a more powerful version of Vim's `clientserver` feature.

==============================================================================

 2. <A HREF="api.html#API">API</A> <A HREF="map.html#mapping">mapping</A>							    *<A NAME="rpc-api"></A><B>rpc-api</B>*

The Nvim C |<A HREF="api.html#API">API</A>| is automatically exposed to the <A HREF="#RPC">RPC</A> API by the build system,
which parses headers at src/nvim/api/*. A dispatch function is generated which
matches <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> method names with public <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>, converting/validating
arguments and return values back to msgpack.

Client libraries (|<A HREF="#api-client">api-client</A>|<A HREF="change.html#s">s</A>) normally provide wrappers that hide
<A HREF="#msgpack-rpc">msgpack-rpc</A> details from application developers. The wrappers can be
automatically generated by reading bundled <A HREF="api.html#API">API</A> metadata from a compiled Nvim
instance.

There are three ways to obtain <A HREF="api.html#API">API</A> metadata:

  1. Connect to a running Nvim instance and call `nvim_get_api_info` via
     <A HREF="#msgpack-rpc">msgpack-rpc</A>. This is best for clients written in dynamic languages which
     can define <A HREF="eval.html#functions">functions</A> at runtime.

  2. Start Nvim with the |<A HREF="starting.html#--api-info">--api-info</A>| option. Useful for clients written in
     statically-compiled languages.

  3. Use the |<A HREF="eval.html#api_info()">api_info()</A>| vimscript function.

To get a human-readable <A HREF="eval.html#list">list</A> of <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>:
<B>    :new|put =map(api_info().functions, 'v:val.name')</B>
 
To get a formatted dump of the <A HREF="api.html#API">API</A> using <A HREF="if_pyth.html#python">python</A> (requires the `pyyaml` and
`msgpack-python` packages):
<B>    nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))'</B>
 
==============================================================================

3. Connecting						      *<A NAME="rpc-connecting"></A><B>rpc-connecting</B>*

There are several ways to open a <A HREF="#msgpack-rpc">msgpack-rpc</A> channel to an Nvim instance:

  1. Through stdin/stdout when `nvim` is started with `--embed`. This is how
     applications can embed Nvim.

  2. Through stdin/stdout of some other process spawned by |<A HREF="eval.html#jobstart()">jobstart()</A>|.
     Set the &quot;<A HREF="#rpc">rpc</A>&quot; key to |<A HREF="eval.html#v:true">v:true</A>| in the <A HREF="options.html#options">options</A> <A HREF="eval.html#dict">dict</A> to use the job's stdin
     and stdout <A HREF="motion.html#as">as</A> a single msgpack channel that is processed directly by
     Nvim.  Then <A HREF="motion.html#it">it</A> is not possible to process raw data to or from the
     process's stdin and stdout. stderr can still be used, though.

  3. Through the socket automatically created with each instance. The socket
     location is stored in |<A HREF="eval.html#v:servername">v:servername</A>|.

  4. Through a TCP/IP socket. To make Nvim listen on a TCP/IP socket, set the
     |<A HREF="eval.html#$NVIM_LISTEN_ADDRESS">$NVIM_LISTEN_ADDRESS</A>| environment variable before starting Nvim:
<B>        NVIM_LISTEN_ADDRESS=127.0.0.1:6666 nvim</B>
 
Connecting to the socket is the easiest way a programmer can test the <A HREF="api.html#API">API</A>,
which can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or full-featured
|<A HREF="#api-client">api-client</A>|. Here's a <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="usr_41.html#script">script</A> that prints 'hello world!' in the current
Nvim instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running Nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since Nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #	:!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:nvim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the `neovim` package, where <A HREF="api.html#API">API</A>
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from neovim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
You can also embed an Nvim instance via |<A HREF="eval.html#jobstart()">jobstart()</A>|, and communicate using
|<A HREF="eval.html#rpcrequest()">rpcrequest()</A>| and |<A HREF="eval.html#rpcnotify()">rpcnotify()</A>|:

<B>    let nvim = jobstart(['nvim', '--embed'], {'rpc': v:true})</B>
<B>    echo rpcrequest(nvim, 'nvim_eval', '"Hello " . "world!"')</B>
<B>    call jobstop(nvim)</B>
 
==============================================================================

4. Implementing <A HREF="api.html#API">API</A> clients			*<A NAME="rpc-api-client"></A><B>rpc-api-client</B>* *<A NAME="api-client"></A><B>api-client</B>*

&quot;<A HREF="api.html#API">API</A> clients&quot; wrap the Nvim <A HREF="api.html#API">API</A> to provide idiomatic &quot;SDKs&quot; for their
respective platforms (see |<A HREF="develop.html#dev-jargon">dev-jargon</A>|). You can build a new <A HREF="api.html#API">API</A> client for
your favorite platform or programming language.

Existing <A HREF="api.html#API">API</A> clients are listed here:
    https://github.com/neovim/neovim/wiki/Related-projects#api-clients

The <A HREF="if_pyth.html#Python">Python</A> client is the reference implementation for <A HREF="api.html#API">API</A> clients. It is
always up-to-date with the Nvim <A HREF="api.html#API">API</A>, so its source code and test suite are
authoritative references.
    https://github.com/neovim/python-client

<B><FONT color="#54A23D">API client implementation guidelines </FONT></B>

  - Separate the transport layer from the rest of the library. See
    |<A HREF="#rpc-connecting">rpc-connecting</A>| for details on how clients can connect to Nvim.
  - Use a MessagePack library that implements at least version 5 of the
    MessagePack spec, which supports the `bin` and `ext` types used by Nvim.
  - Read <A HREF="api.html#API">API</A> metadata in order to create client-side wrappers for all
    <A HREF="#msgpack-rpc">msgpack-rpc</A> methods.
  - Use a single-threaded event loop library/pattern.
  - Use a fiber/coroutine library for the language being used for implementing
    a client. These greatly simplify concurrency and allow the library to
    expose a blocking <A HREF="api.html#API">API</A> on top of a non-blocking event loop without the
    complexity that comes with preemptive multitasking.
  - Don't assume anything about the order that responses to <A HREF="#msgpack-rpc">msgpack-rpc</A>
    requests will arrive.
  - Clients should expect <A HREF="#msgpack-rpc">msgpack-rpc</A> requests, which need to be handled
    immediately because Nvim is blocked while waiting for the client response.
  - Clients should expect to receive <A HREF="#msgpack-rpc">msgpack-rpc</A> notifications, but these
    don't need to be handled immediately because they won't block Nvim
    (although they should probably be handled immediately anyway).

Note: Most of the complexity could be handled by a <A HREF="#msgpack-rpc">msgpack-rpc</A> library that
supports server to client requests and notifications, but it's not clear if
this is part of the <A HREF="#msgpack-rpc">msgpack-rpc</A> spec. At least the <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="#msgpack-rpc">msgpack-rpc</A> library
does not seem to support <A HREF="motion.html#it">it</A>:
https://github.com/msgpack-rpc/msgpack-rpc-ruby/blob/master/lib/msgpack/rpc/transport/tcp.rb#L150-L158

<B><FONT color="#54A23D">API metadata object </FONT></B>

<A HREF="api.html#API">API</A> clients exist to hide <A HREF="#msgpack-rpc">msgpack-rpc</A> details. The <A HREF="api.html#API">API</A> metadata object
contains information that makes this task easier (see also |<A HREF="#rpc-types">rpc-types</A>|):

  - The &quot;version&quot; key contains the Nvim version, <A HREF="api.html#API">API</A> level, and <A HREF="api.html#API">API</A>
    backwards-compatibility level.
  - The &quot;<A HREF="eval.html#functions">functions</A>&quot; key contains a <A HREF="eval.html#list">list</A> of metadata <A HREF="vimindex.html#objects">objects</A> for individual
    <A HREF="eval.html#functions">functions</A>.
  - Each function metadata object has |<A HREF="#rpc-types">rpc-types</A>| information about the return
    value and parameters. These can be used for generating strongly-typed APIs
    in static languages.
  - Container types may be decorated with type/size constraints, e.g.
    ArrayOf(Buffer) or ArrayOf(Integer, 2). This can be useful to generate
    even more strongly-typed APIs.
  - Functions that are considered to be methods that operate on instances of
    Nvim special types (msgpack EXT) will have the `&quot;method&quot;` attribute set to
    `true`. The reciever type is the type of the first argument. The method
    names are prefixed with `nvim_` plus a shortened type name, e.g.
    `nvim_buf_get_lines` represents the `get_lines` method of a Buffer instance.
    - Global <A HREF="eval.html#functions">functions</A> have `&quot;method&quot;` set to `false` and are prefixed with just
    `nvim_`, e.g. `nvim_get_buffers`.

So for an object-oriented language, an <A HREF="api.html#API">API</A> client contains the classes
representing Nvim special types, and the methods of each class could be
defined by stripping the prefix for the type <A HREF="motion.html#as">as</A> defined in the `types` metadata
(this will always be the first two &quot;_&quot;-separated parts of the function name).
There could also be a singleton Vim class with methods where the `nvim_`
prefix is stripped off.

==============================================================================

5. Types							    *<A NAME="rpc-types"></A><B>rpc-types</B>*

The Nvim C <A HREF="api.html#API">API</A> uses custom types for all <A HREF="eval.html#functions">functions</A>. |<A HREF="api.html#api-types">api-types</A>|
For the purpose of <A HREF="map.html#mapping">mapping</A> to msgpack, the types can be split into two groups:

  - Basic types that map natively to msgpack (and probably have a default
    representation in msgpack-supported programming languages)
  - Special Nvim types that map to msgpack EXT with custom type codes.

<B><FONT color="#54A23D">Basic types </FONT></B>

  Nil                               -&gt; msgpack nil
  Boolean                           -&gt; msgpack <A HREF="options.html#boolean">boolean</A>
  Integer (signed 64-bit integer)   -&gt; msgpack integer
  <A HREF="eval.html#Float">Float</A> (IEEE 754 double precision) -&gt; msgpack float
  <A HREF="eval.html#String">String</A>                            -&gt; msgpack <A HREF="eval.html#string">string</A>
  Array                             -&gt; msgpack array
  <A HREF="eval.html#Dictionary">Dictionary</A>                        -&gt; msgpack map

<B><FONT color="#54A23D">Special types (msgpack EXT) </FONT></B>

  Buffer                            -&gt; enum value kObjectTypeBuffer
  Window                            -&gt; enum value kObjectTypeWindow
  Tabpage                           -&gt; enum value kObjectTypeTabpage

An <A HREF="api.html#API">API</A> method expecting one of these types may be passed an integer instead,
although they are not interchangeable. For example, a Buffer may be passed <A HREF="motion.html#as">as</A>
an integer, but not a Window or Tabpage.

The most reliable way of determining the type codes for the special Nvim types
is to inspect the `types` key of metadata dictionary returned by the
`nvim_get_api_info` method at runtime. Here's a sample JSON representation of
the `types` object:

<B>  "types": {</B>
<B>    "Buffer": {</B>
<B>      "id": 0,</B>
<B>      "prefix": "nvim_buf_"</B>
<B>    },</B>
<B>    "Window": {</B>
<B>      "id": 1,</B>
<B>      "prefix": "nvim_win_"</B>
<B>    },</B>
<B>    "Tabpage": {</B>
<B>      "id": 2,</B>
<B>      "prefix": "nvim_tabpage_"</B>
<B>    }</B>
<B>  }</B>
 
Even for statically compiled clients <A HREF="motion.html#it">it</A> is good practice to avoid hardcoding
the type codes, because a client may be built against one Nvim version but
connect to another with different type codes.

==============================================================================

6. Remote UIs					           *<A NAME="rpc-remote-ui"></A><B>rpc-remote-ui</B>*

Nvim allows Graphical user interfaces to be implemented by separate processes
communicating with Nvim over the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>. Currently the ui model conists of a
terminal-like grid with one single, monospace font size, with a few elements
that could be drawn separately from the grid (for the momemnt only the popup
menu)

After connecting to a <A HREF="nvim.html#nvim">nvim</A> instance (typically a spawned, embedded instance)
use the |nvim_ui_attach|(width, height, <A HREF="options.html#options">options</A>) <A HREF="api.html#API">API</A> method to tell <A HREF="nvim.html#nvim">nvim</A> that your
program wants to draw the <A HREF="nvim.html#nvim">nvim</A> screen on a grid with &quot;width&quot; times
&quot;height&quot; cells. &quot;<A HREF="options.html#options">options</A>&quot; should be a dictionary with the following (all
optional) keys:
	`rgb`:			Controls what color format to use.
				Set to true (default) to use 24-bit rgb
				colors.
				Set to false to use terminal color codes (at
				most 256 different colors).
	`popupmenu_external`:	Instead of drawing the completion popupmenu on
				the grid, Nvim will send higher-level events to
				the ui and let <A HREF="motion.html#it">it</A> draw the popupmenu.
				Defaults to false.

Nvim will then send <A HREF="#msgpack-rpc">msgpack-rpc</A> notifications, with the method name &quot;redraw&quot;
and a single argument, an array of screen updates (described below).
These should be processed in order. Preferably the user should only be able to
see the screen state after all updates are processed (not any intermediate
state after processing only a part of the array).

Screen updates are arrays. The first element a <A HREF="eval.html#string">string</A> describing the kind
of update.

[&quot;resize&quot;, width, height]
	The grid is resized to `width` and `height` cells.

[&quot;clear&quot;]
	Clear the screen.

[&quot;eol_clear&quot;]
	Clear from the cursor position to the end of the current line.

[&quot;cursor_goto&quot;, row, col]
	Move the cursor to position (row, col). Currently, the same cursor is
	used to define the position for text insertion and the visible cursor.
	However, only the last cursor position, after processing the entire
	array in the &quot;redraw&quot; event, is intended to be a visible cursor
	position.

[&quot;update_fg&quot;, color]
[&quot;update_bg&quot;, color]
[&quot;update_sp&quot;, color]
	Set the default foreground, background and special colors
	respectively.

[&quot;highlight_set&quot;, attrs]
	Set the attributes that the next text put on the screen will have.
	`attrs` is a <A HREF="eval.html#dict">dict</A> with the keys below. Any absent key is reset
	to its default value. Color defaults are set by the `update_fg` etc
	updates. All <A HREF="options.html#boolean">boolean</A> keys default to false.

	`foreground`:	foreground color.
	`background`:	backround color.
	`special`:	color to use for <A HREF="syntax.html#underline">underline</A> and <A HREF="syntax.html#undercurl">undercurl</A>, when present.
	`reverse`:	reverse video. Foreground and background colors are
			switched.
	`italic`:	<A HREF="syntax.html#italic">italic</A> text.
	`bold`:		<A HREF="syntax.html#bold">bold</A> text.
	`underline`:	underlined text. The line has `special` color.
	`undercurl`:	undercurled text. The curl has `special` color.

[&quot;put&quot;, text]
	The (utf-8 encoded) <A HREF="eval.html#string">string</A> `text` is put at the cursor position
	(and the cursor is advanced), with the highlights <A HREF="motion.html#as">as</A> set by the
	last `highlight_set` update.

[&quot;set_scroll_region&quot;, top, bot, left, right]
	Define the scroll region used by `scroll` below.

[&quot;scroll&quot;, count]
	Scroll the text in the scroll region. The diagrams below illustrate
	what will happen, depending on the scroll direction. &quot;<A HREF="change.html#=">=</A>&quot; is used to
	represent the SR(scroll region) boundaries and &quot;<A HREF="motion.html#-">-</A>&quot; the moved rectangles.
	Note that dst and src share a common region.

	If <A HREF="intro.html#count">count</A> is bigger than 0, move a rectangle in the SR up, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> down.

<B>		+-------------------------+</B>
<B>		| (clipped above SR)      |            ^</B>
<B>		|=========================| dst_top    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		+-------------------------+ src_top    |</B>
<B>		| src (moved up) and dst  |            |</B>
<B>		|-------------------------| dst_bot    |</B>
<B>		| src (cleared)           |            |</B>
<B>		+=========================+ src_bot</B>
 
	If <A HREF="intro.html#count">count</A> is <A HREF="various.html#less">less</A> than zero, move a rectangle in the SR down, this can
	happen while <A HREF="scroll.html#scrolling">scrolling</A> up.

<B>		+=========================+ src_top</B>
<B>		| src (cleared)           |            |</B>
<B>		|------------------------ | dst_top    |</B>
<B>		| src (moved down) and dst|            |</B>
<B>		+-------------------------+ src_bot    |</B>
<B>		| dst (still in SR)       |            |</B>
<B>		|=========================| dst_bot    |</B>
<B>		| (clipped below SR)      |            v</B>
<B>		+-------------------------+</B>
 
[&quot;set_title&quot;, title]
[&quot;set_icon&quot;, icon]
	Set the <A HREF="windows.html#window">window</A> title, and icon (minimized) <A HREF="windows.html#window">window</A> title, respectively.
	In windowing systems not distinguishing between the two, &quot;set_icon&quot;
	can be ignored.

[&quot;mouse_on&quot;]
[&quot;mouse_off&quot;]
	Tells the client whether mouse support, <A HREF="motion.html#as">as</A> determined by |<A HREF="options.html#'mouse'">'mouse'</A>|
	option, is considered to be active in the current mode. This is mostly
	useful for a terminal frontend, or other situations where <A HREF="nvim.html#nvim">nvim</A> mouse
	would conflict with other usages of the mouse. It is safe for a client
	to ignore this and always send mouse events.

[&quot;busy_on&quot;]
[&quot;busy_off&quot;]
	Nvim started or stopped being busy, and possibly not responsible to user
	input. This could be indicated to the user by hiding the cursor.

[&quot;suspend&quot;]
	|<A HREF="starting.html#:suspend">:suspend</A>| command or |<A HREF="intro.html#Ctrl-Z">Ctrl-Z</A>| <A HREF="map.html#mapping">mapping</A> is used. A terminal client (or other
	client where <A HREF="motion.html#it">it</A> makes sense) could <A HREF="starting.html#suspend">suspend</A> itself.  Other clients can
	safely ignore <A HREF="motion.html#it">it</A>.

[&quot;bell&quot;]
[&quot;visual_bell&quot;]
	Notify the user with an audible or visual bell, respectively.

[&quot;update_menu&quot;]
	The menu mappings changed.

[&quot;mode_change&quot;, mode]
	The mode changed. Currently sent when &quot;insert&quot;, &quot;replace&quot; and &quot;normal&quot;
	modes are entered. A client could for instance change the cursor shape.

[&quot;popupmenu_show&quot;, items, selected, row, col]
	When `popupmenu_external` is set to true, <A HREF="nvim.html#nvim">nvim</A> will not draw the
	popupmenu on the grid, instead when the popupmenu is to be displayed
	this update is sent. `items` is an array of the items to show, the
	items are themselves arrays of the form [word, kind, menu, info]
	<A HREF="motion.html#as">as</A> defined at |<A HREF="insert.html#complete-items">complete-items</A>|, except that `word` is replaced by
	`abbr` if present.  `selected` is the initially selected item, either a
	zero-based index into the array of items, or -1 if no item is
	selected. `row` and `col` is the anchor position, where the first
	character of the completed <A HREF="motion.html#word">word</A> will be.

[&quot;popupmenu_select&quot;, selected]
	An item in the currently displayed popupmenu is selected. `selected`
	is either a zero-based index into the array of items from the last
	`popupmenu_show` event, or -1 if no item is selected.

[&quot;popupmenu_hide&quot;]
	The popupmenu is hidden.

==============================================================================
<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>

    <footer>
      <div class="container">
        Generated Sat Oct 29 20:09:50 UTC 2016 from <a href="https://github.com/neovim/neovim/commit/6143cfdeec4e67cdf73879b92fe2a80b5b36bc1b"><code>6143cfd</code></a>.
      </div>
    </footer>
  </body>
</html>
