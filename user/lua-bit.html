  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Neovim user documentation">

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" />
    <link rel="preconnect" href="https://X185E15FPG-dsn.algolia.net" crossorigin />

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="help.css" rel="stylesheet">
    <link href="/highlight/styles/neovim.min.css" rel="stylesheet">

    <script src="/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title> Lua-bit - Neovim docs</title>
  </head>
  <body>
    <header class="container">
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a href="/" class="navbar-brand" aria-label="logo">
          <!--TODO: use <img src="….svg"> here instead. Need one that has green lettering instead of gray. -->
              <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214" aria-label="Neovim">
      <title>Neovim</title>
      <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
          <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
          <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
          <stop stop-color="#7DB643" offset="0%" />
          <stop stop-color="#367533" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
          <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
          <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
        </linearGradient>
      </defs>
      <g fill="none" fill-rule="evenodd">
        <path
          d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
          fill="url(#a)"
          transform="translate(1 1)"
        />
        <path
          d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
          fill="url(#b)"
          transform="matrix(-1 0 0 1 305 1)"
        />
        <path
          d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
          fill="url(#c)"
          transform="translate(1 1)"
        />
        <path
          d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
          fill-opacity=".13"
          fill="#000"
        />
        <g fill="#444">
          <path
            d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
            fill="currentColor"
          />
          <path
            d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
            fill="currentColor"
            fill-opacity=".8"
          />
        </g>
      </g>
    </svg>
  
          <!--<img src="https://neovim.io/logos/neovim-logo.svg" width="173" height="50" alt="Neovim" />-->
        </a>
        <div id="docsearch"></div> <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
      </div>
    </nav>
  </header>

  <div class="container golden-grid help-body">
  <div class="col-wide">
  <a name="lua-bit.txt" href="#lua-bit"><h1 id="lua-bit"> Lua-bit</h1></a>
  <p>
    <i>
    Nvim <code>:help</code> pages, <a href="https://github.com/neovim/neovim/blob/master/src/gen/gen_help_html.lua">generated</a>
    from <a href="https://github.com/neovim/neovim/blob/master/runtime/doc/lua-bit.txt">source</a>
    using the <a href="https://github.com/neovim/tree-sitter-vimdoc">tree-sitter-vimdoc</a> parser.
    </i>
  </p>
  <hr/>
  <div class="old-help-para">			  LUA BITOP REFERENCE MANUAL</div>
<div class="old-help-para">		   Adapted from &lt;https://bitop.luajit.org&gt;</div>
<div class="old-help-para">Lua BitOp is a C extension module for Lua 5.1/5.2 which adds bitwise
operations on numbers.</div>
<div class="old-help-para"><h2 id="_api-functions" class="help-heading">API FUNCTIONS<span class="help-heading-tags">                                                    <span id="lua-bit-api" class="help-tag"><a href="#lua-bit-api">lua-bit-api</a></span></h2></div>
<div class="old-help-para">This list of API functions is not intended to replace a tutorial. If you are
not familiar with the terms used, you may want to study the Wikipedia article
on bitwise operations (<a href="https://en.wikipedia.org/wiki/Bitwise_operation">https://en.wikipedia.org/wiki/Bitwise_operation</a>) first.</div>
<div class="old-help-para"><h3 id="_loading-the-bitop-module" class="help-heading">Loading the BitOp module</h3>                                                               <span id="lua-bit-module" class="help-tag-right"><a href="#lua-bit-module">lua-bit-module</a></span><br></div>
<div class="old-help-para">The suggested way to use the BitOp module is to add the following to the start
of every Lua file that needs one of its functions:<pre><code class="language-lua">local bit = require("bit")</code></pre></div>
<div class="old-help-para">This makes the dependency explicit, limits the scope to the current file and
provides faster access to the bit.* functions, too. It's good programming
practice not to rely on the global variable bit being set (assuming some other
part of your application has already loaded the module). The require function
ensures the module is only loaded once, in any case.</div>
<div class="old-help-para"><h3 id="_defining-shortcuts" class="help-heading">Defining Shortcuts</h3>                                                            <span id="lua-bit-shortcuts" class="help-tag-right"><a href="#lua-bit-shortcuts">lua-bit-shortcuts</a></span><br></div>
<div class="old-help-para">It's a common (but not a required) practice to cache often used module
functions in locals. This serves as a shortcut to save some typing and also
speeds up resolving them (only relevant if called hundreds of thousands of
times).
<pre><code class="language-lua">local bnot = bit.bnot
local band, bor, bxor = bit.band, bit.bor, bit.bxor
local lshift, rshift, rol = bit.lshift, bit.rshift, bit.rol
-- etc...
-- Example use of the shortcuts:
local function tr_i(a, b, c, d, x, s)
  return rol(bxor(c, bor(b, bnot(d))) + a + x, s) + b
end</code></pre></div>
<div class="old-help-para">Remember that <code>and</code>, <code>or</code> and <code>not</code> are reserved keywords in Lua. They cannot
be used for variable names or literal field names. That's why the
corresponding bitwise functions have been named <code>band</code>, <code>bor</code>, and <code>bnot</code> (and
<code>bxor</code> for consistency).</div>
<div class="old-help-para">While we are at it: a common pitfall is to use bit as the name of a local
temporary variable — well, don't! :-)</div>
<div class="old-help-para"><h3 id="_about-the-examples" class="help-heading">About the Examples</h3></div>
<div class="old-help-para">The examples below show small Lua one-liners. Their expected output is shown
after <code>--&gt;</code>. This is interpreted as a comment marker by Lua so you can cut &amp;
paste the whole line to a Lua prompt and experiment with it.</div>
<div class="old-help-para">Note that all bit operations return signed 32 bit numbers (rationale). And
these print as signed decimal numbers by default.</div>
<div class="old-help-para">For clarity the examples assume the definition of a helper function
<code>printx()</code>. This prints its argument as an unsigned 32 bit hexadecimal number
on all platforms:
<pre><code class="language-lua">function printx(x)
  print("0x"..bit.tohex(x))
end</code></pre></div>
<div class="old-help-para"><h3 id="_bit-operations" class="help-heading">Bit operations</h3>                                                                    <span id="lua-bitop" class="help-tag-right"><a href="#lua-bitop">lua-bitop</a></span><br></div>
<div class="old-help-para">y = bit.tobit(x)                                                   <span id="bit.tobit()" class="help-tag-right"><a href="#bit.tobit()">bit.tobit()</a></span><br>
    Normalizes a number to the numeric range for bit operations and returns
    it. This function is usually not needed since all bit operations already
    normalize all of their input arguments. See <a href="lua-bit.html#lua-bit-semantics">lua-bit-semantics</a>.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">print(0xffffffff)                --&gt; 4294967295 (see Note)
print(bit.tobit(0xffffffff))     --&gt; -1
printx(bit.tobit(0xffffffff))    --&gt; 0xffffffff
print(bit.tobit(0xffffffff + 1)) --&gt; 0
print(bit.tobit(2^40 + 1234))    --&gt; 1234</code></pre></div>
<div class="old-help-para"><b>    Note:</b> <a href="lua-bit.html#lua-bit-hex-literals">lua-bit-hex-literals</a> explains why the numbers printed in the first
    two lines differ (if your Lua installation uses a double number type).</div>
<div class="old-help-para">y = bit.tohex(x [,n])                                           <span id="bit.tohex()" class="help-tag-right"><a href="#bit.tohex()">bit.tohex()</a></span><br>
    Converts its first argument to a hex string. The number of hex digits is
    given by the absolute value of the optional second argument. Positive
    numbers between 1 and 8 generate lowercase hex digits. Negative numbers
    generate uppercase hex digits. Only the least-significant <code>4*|n|</code> bits are
    used. The default is to generate 8 lowercase hex digits.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">print(bit.tohex(1))              --&gt; 00000001
print(bit.tohex(-1))             --&gt; ffffffff
print(bit.tohex(0xffffffff))     --&gt; ffffffff
print(bit.tohex(-1, -8))         --&gt; FFFFFFFF
print(bit.tohex(0x21, 4))        --&gt; 0021
print(bit.tohex(0x87654321, 4))  --&gt; 4321</code></pre></div>
<div class="old-help-para">y = bit.bnot(x)                                                 <span id="bit.bnot()" class="help-tag-right"><a href="#bit.bnot()">bit.bnot()</a></span><br>
    Returns the bitwise <code>not</code> of its argument.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">print(bit.bnot(0))            --&gt; -1
printx(bit.bnot(0))           --&gt; 0xffffffff
print(bit.bnot(-1))           --&gt; 0
print(bit.bnot(0xffffffff))   --&gt; 0
printx(bit.bnot(0x12345678))  --&gt; 0xedcba987</code></pre></div>
<div class="old-help-para">y = bit.bor(x1 [,x2...])                                        <span id="bit.bor()" class="help-tag-right"><a href="#bit.bor()">bit.bor()</a></span><br>
y = bit.band(x1 [,x2...])                                       <span id="bit.band()" class="help-tag-right"><a href="#bit.band()">bit.band()</a></span><br>
y = bit.bxor(x1 [,x2...])                                       <span id="bit.bxor()" class="help-tag-right"><a href="#bit.bxor()">bit.bxor()</a></span><br>
    Returns either the bitwise <code>or</code>, bitwise <code>and</code>, or bitwise <code>xor</code> of all of its
    arguments. Note that more than two arguments are allowed.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">print(bit.bor(1, 2, 4, 8))                --&gt; 15
printx(bit.band(0x12345678, 0xff))        --&gt; 0x00000078
printx(bit.bxor(0xa5a5f0f0, 0xaa55ff00))  --&gt; 0x0ff00ff0</code></pre></div>
<div class="old-help-para">y = bit.lshift(x, n)                                            <span id="bit.lshift()" class="help-tag-right"><a href="#bit.lshift()">bit.lshift()</a></span><br>
y = bit.rshift(x, n)                                            <span id="bit.rshift()" class="help-tag-right"><a href="#bit.rshift()">bit.rshift()</a></span><br>
y = bit.arshift(x, n)                                           <span id="bit.arshift()" class="help-tag-right"><a href="#bit.arshift()">bit.arshift()</a></span><br>
    Returns either the bitwise <code>logical left-shift</code>, bitwise <code>logical</code>
    <code>right-shift</code>, or bitwise <code>arithmetic right-shift</code> of its first argument
    by the number of bits given by the second argument.</div>
<div class="old-help-para">    Logical shifts treat the first argument as an unsigned number and shift in
    0-bits. Arithmetic right-shift treats the most-significant bit as a sign
    bit and replicates it. Only the lower 5 bits of the shift count are used
    (reduces to the range [0..31]).</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">print(bit.lshift(1, 0))              --&gt; 1
print(bit.lshift(1, 8))              --&gt; 256
print(bit.lshift(1, 40))             --&gt; 256
print(bit.rshift(256, 8))            --&gt; 1
print(bit.rshift(-256, 8))           --&gt; 16777215
print(bit.arshift(256, 8))           --&gt; 1
print(bit.arshift(-256, 8))          --&gt; -1
printx(bit.lshift(0x87654321, 12))   --&gt; 0x54321000
printx(bit.rshift(0x87654321, 12))   --&gt; 0x00087654
printx(bit.arshift(0x87654321, 12))  --&gt; 0xfff87654</code></pre></div>
<div class="old-help-para">y = bit.rol(x, n)                                               <span id="bit.rol()" class="help-tag-right"><a href="#bit.rol()">bit.rol()</a></span><br>
y = bit.ror(x, n)                                               <span id="bit.ror()" class="help-tag-right"><a href="#bit.ror()">bit.ror()</a></span><br>
    Returns either the bitwise <code>left rotation</code>, or bitwise <code>right rotation</code> of its
    first argument by the number of bits given by the second argument. Bits
    shifted out on one side are shifted back in on the other side.</div>
<div class="old-help-para">    Only the lower 5 bits of the rotate count are used (reduces to the range
    [0..31]).</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">printx(bit.rol(0x12345678, 12))   --&gt; 0x45678123
printx(bit.ror(0x12345678, 12))   --&gt; 0x67812345</code></pre></div>
<div class="old-help-para">y = bit.bswap(x)
    Swaps the bytes of its argument and returns it. This can be used to
    convert little-endian 32 bit numbers to big-endian 32 bit numbers or vice
    versa.</div>
<div class="old-help-para">    Example:<pre><code class="language-lua">printx(bit.bswap(0x12345678)) --&gt; 0x78563412
printx(bit.bswap(0x78563412)) --&gt; 0x12345678</code></pre></div>
<div class="old-help-para"><h3 id="_example-program" class="help-heading">Example Program</h3></div>
<div class="old-help-para">This is an implementation of the (naïve) Sieve of Eratosthenes algorithm. It
counts the number of primes up to some maximum number.</div>
<div class="old-help-para">A Lua table is used to hold a bit-vector. Every array index has 32 bits of the
vector. Bitwise operations are used to access and modify them. Note that the
shift counts don't need to be masked since this is already done by the BitOp
shift and rotate functions.
<pre><code class="language-lua">local bit = require("bit")
local band, bxor = bit.band, bit.bxor
local rshift, rol = bit.rshift, bit.rol
local m = tonumber(arg and arg[1]) or 100000
if m &lt; 2 then m = 2 end
local count = 0
local p = {}
for i=0,(m+31)/32 do p[i] = -1 end
for i=2,m do
  if band(rshift(p[rshift(i, 5)], i), 1) ~= 0 then
    count = count + 1
    for j=i+i,m,i do
      local jx = rshift(j, 5)
      p[jx] = band(p[jx], rol(-2, j))
    end
  end
end
io.write(string.format("Found %d primes up to %d\n", count, m))</code></pre></div>
<div class="old-help-para">Lua BitOp is quite fast. This program runs in less than 90 milliseconds on a 3
GHz CPU with a standard Lua installation, but performs more than a million
calls to bitwise functions. If you're looking for even more speed, check out
<a href="lua.html#lua-luajit">lua-luajit</a>.</div>
<div class="old-help-para"><h3 id="_caveats" class="help-heading">Caveats<span class="help-heading-tags">                                                      <span id="lua-bit-caveats" class="help-tag"><a href="#lua-bit-caveats">lua-bit-caveats</a></span></h3></div>
<div class="old-help-para"><div class="help-column_heading">Signed Results</div></div>
<div class="old-help-para">Returning signed numbers from bitwise operations may be surprising to
programmers coming from other programming languages which have both signed and
unsigned types. But as long as you treat the results of bitwise operations
uniformly everywhere, this shouldn't cause any problems.</div>
<div class="old-help-para">Preferably format results with <code>bit.tohex</code> if you want a reliable unsigned
string representation. Avoid the <code>"%x"</code> or <code>"%u"</code> formats for <code>string.format</code>. They
fail on some architectures for negative numbers and can return more than 8 hex
digits on others.</div>
<div class="old-help-para">You may also want to avoid the default number to string coercion, since this
is a signed conversion. The coercion is used for string concatenation and all
standard library functions which accept string arguments (such as <code>print()</code> or
<code>io.write()</code>).</div>
<div class="old-help-para"><div class="help-column_heading">Conditionals</div></div>
<div class="old-help-para">If you're transcribing some code from C/C++, watch out for bit operations in
conditionals. In C/C++ any non-zero value is implicitly considered as <code>true</code>.
E.g. this C code:<pre><code class="language-c">if (x &amp; 3) ...</code></pre></div>
<div class="old-help-para">must not be turned into this Lua code:<pre><code class="language-lua">if band(x, 3) then ... -- wrong!</code></pre></div>
<div class="old-help-para">In Lua all objects except <code>nil</code> and <code>false</code> are considered <code>true</code>. This
includes all numbers. An explicit comparison against zero is required in this
case:<pre><code class="language-lua">if band(x, 3) ~= 0 then ... -- correct!</code></pre>
<div class="help-column_heading">Comparing Against Hex Literals</div></div>
<div class="old-help-para">Comparing the results of bitwise operations (signed numbers) against hex
literals (unsigned numbers) needs some additional care. The following
conditional expression may or may not work right, depending on the platform
you run it on:<pre><code class="language-lua">bit.bor(x, 1) == 0xffffffff</code></pre></div>
<div class="old-help-para">E.g. it's never true on a Lua installation with the default number type. Some
simple solutions:</div>
<div class="old-help-para">    Never use hex literals larger than 0x7fffffff in comparisons:<pre><code class="language-lua">bit.bor(x, 1) == -1</code></pre></div>
<div class="old-help-para">    Or convert them with bit.tobit() before comparing:<pre><code class="language-lua">bit.bor(x, 1) == bit.tobit(0xffffffff)</code></pre></div>
<div class="old-help-para">    Or use a generic workaround with bit.bxor():<pre><code class="language-lua">bit.bxor(bit.bor(x, 1), 0xffffffff) == 0</code></pre></div>
<div class="old-help-para">    Or use a case-specific workaround:<pre><code class="language-lua">bit.rshift(x, 1) == 0x7fffffff</code></pre></div>
<div class="old-help-para"><h2 id="_operational-semantics-and-rationale" class="help-heading">OPERATIONAL SEMANTICS AND RATIONALE<span class="help-heading-tags">                        <span id="lua-bit-semantics" class="help-tag"><a href="#lua-bit-semantics">lua-bit-semantics</a></span></h2></div>
<div class="old-help-para"><div class="help-column_heading">Input and Output Ranges</div>                                                          <span id="lua-bit-io-ranges" class="help-tag-right"><a href="#lua-bit-io-ranges">lua-bit-io-ranges</a></span><br></div>
<div class="old-help-para">Bitwise operations cannot sensibly be applied to FP numbers (or their
underlying bit patterns). They must be converted to integers before operating
on them and then back to FP numbers.</div>
<div class="old-help-para">It's desirable to define semantics that work the same across all platforms.
This dictates that all operations are based on the common denominator of 32
bit integers. The <code>float</code> type provides only 24 bits of precision. This makes it
unsuitable for use in bitwise operations. Lua BitOp refuses to compile against
a Lua installation with this number type.</div>
<div class="old-help-para">Bit operations only deal with the underlying bit patterns and generally ignore
signedness (except for arithmetic right-shift). They are commonly displayed
and treated like unsigned numbers, though.</div>
<div class="old-help-para">But the Lua number type must be signed and may be limited to 32 bits. Defining
the result type as an unsigned number would not be cross-platform safe. All
bit operations are thus defined to return results in the range of signed 32
bit numbers (converted to the Lua number type).</div>
<div class="old-help-para">                                                        <span id="lua-bit-hex-literals" class="help-tag-right"><a href="#lua-bit-hex-literals">lua-bit-hex-literals</a></span><br>
Hexadecimal literals are treated as unsigned numbers by the Lua parser before
converting them to the Lua number type. This means they can be out of the
range of signed 32 bit integers if the Lua number type has a greater range.
E.g. 0xffffffff has a value of 4294967295 in the default installation, but may
be -1 on embedded systems. It's highly desirable that hex literals are treated
uniformly across systems when used in bitwise operations. All bit operations
accept arguments in the signed or the unsigned 32 bit range (and more, see
below). Numbers with the same underlying bit pattern are treated the same by
all operations.</div>
<div class="old-help-para"><div class="help-column_heading">Modular Arithmetic</div>                                                        <span id="lua-bit-modular-arith" class="help-tag-right"><a href="#lua-bit-modular-arith">lua-bit-modular-arith</a></span><br></div>
<div class="old-help-para">Arithmetic operations on n-bit integers are usually based on the rules of
modular arithmetic modulo 2^n. Numbers wrap around when the mathematical result
of operations is outside their defined range. This simplifies hardware
implementations and some algorithms actually require this behavior (like many
cryptographic functions).</div>
<div class="old-help-para">E.g. for 32 bit integers the following holds: <code>0xffffffff + 1 = 0</code></div>
<div class="old-help-para">Arithmetic modulo 2^32 is trivially available if the Lua number type is a 32
bit integer. Otherwise normalization steps must be inserted. Modular
arithmetic should work the same across all platforms as far as possible:</div>
<div class="old-help-para"><div class="help-li" style=""> For the default number type of double, arguments can be in the range of
  ±2^51 and still be safely normalized across all platforms by taking their
  least-significant 32 bits. The limit is derived from the way doubles are
  converted to integers.
</div><div class="help-li" style=""> The function bit.tobit can be used to explicitly normalize numbers to
  implement modular addition or subtraction. E.g.<pre><code class="language-lua">              bit.tobit(0xffffffff + 1)
returns 0 on all platforms.</code></pre>
</div><div class="help-li" style=""> The limit on the argument range implies that modular multiplication is
  usually restricted to multiplying already normalized numbers with small
  constants. FP numbers are limited to 53 bits of precision, anyway. E.g.
  (2^30+1)^2 does not return an odd number when computed with doubles.
</div></div>
<div class="old-help-para">BTW: The <code>tr_i</code> function shown here <a href="lua-bit.html#lua-bit-shortcuts">lua-bit-shortcuts</a> is one of the
non-linear functions of the (flawed) MD5 cryptographic hash and relies on
modular arithmetic for correct operation. The result is fed back to other
bitwise operations (not shown) and does not need to be normalized until the
last step.</div>
<div class="old-help-para"><div class="help-column_heading">Restricted and undefined behaviors</div>                                                      <span id="lua-bit-restrictions" class="help-tag-right"><a href="#lua-bit-restrictions">lua-bit-restrictions</a></span><br></div>
<div class="old-help-para">The following rules are intended to give a precise and useful definition (for
the programmer), yet give the implementation (interpreter and compiler) the
maximum flexibility and the freedom to apply advanced optimizations. It's
strongly advised not to rely on undefined or implementation-defined behavior.</div>
<div class="old-help-para"><div class="help-li" style=""> All kinds of floating-point numbers are acceptable to the bitwise
  operations. None of them cause an error, but some may invoke undefined
  behavior:
</div><div class="help-li" style="margin-left: 3rem;"> -0 is treated the same as +0 on input and is never returned as a result.
</div><div class="help-li" style="margin-left: 3rem;"> Passing ±Inf, NaN or numbers outside the range of ±2^51 as input yields
          an undefined result.
</div><div class="help-li" style="margin-left: 3rem;"> Non-integral numbers may be rounded or truncated in an
          implementation-defined way. This means the result could differ between
          different BitOp versions, different Lua VMs, on different platforms or
          even between interpreted vs. compiled code (as in LuaJIT). Avoid
          passing fractional numbers to bitwise functions. Use <code>math.floor()</code> or
          <code>math.ceil()</code> to get defined behavior.
</div><div class="help-li" style=""> Lua provides auto-coercion of string arguments to numbers by default. This
  behavior is deprecated for bitwise operations.
</div></div>
<div class="old-help-para"><h2 id="_copyright" class="help-heading">COPYRIGHT</h2></div>
<div class="old-help-para">Lua BitOp is Copyright (C) 2008-2025 Mike Pall.
Lua BitOp is free software, released under the MIT license.</div>

  </div>
      <div class="col-narrow toc">
      <div><a href="index.html">Main</a></div>
      <div><a href="vimindex.html">Commands index</a></div>
      <div><a href="quickref.html">Quick reference</a></div>
      <hr/>
  <div class="help-toc-h1"><a href="#_api-functions">API FUNCTIONS</a>
<div class="help-toc-h2"><a href="#_loading-the-bitop-module">Loading the BitOp module</a></div>
<div class="help-toc-h2"><a href="#_defining-shortcuts">Defining Shortcuts</a></div>
<div class="help-toc-h2"><a href="#_about-the-examples">About the Examples</a></div>
<div class="help-toc-h2"><a href="#_bit-operations">Bit operations</a></div>
<div class="help-toc-h2"><a href="#_example-program">Example Program</a></div>
<div class="help-toc-h2"><a href="#_caveats">Caveats</a></div>
</div><div class="help-toc-h1"><a href="#_operational-semantics-and-rationale">OPERATIONAL SEMANTICS AND RATIONALE</a>
</div><div class="help-toc-h1"><a href="#_copyright">COPYRIGHT</a>
</div></div>
</div>
  <footer>
    <div class="container flex">
      <div class="generator-stats">
        Generated at 2026-01-17 05:24 from <code><a href="https://github.com/neovim/neovim/commit/e51f5e17e18429b847be4e0d99698727dec47ca9">e51f5e1</a></code>
      </div>
      <div class="generator-stats">
      parse_errors: 0 (<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML%3A+lua-bit.txt+&body=%60gen_help_html.lua%60+problem+at%3A+https://neovim.io/doc/user/lua-bit.html%0D%0DContext%3A%0D%0D%60%60%60%0DTODO%0D%60%60%60" target="_blank">report docs bug...</a>) | <span title="           Nvim
                                        Type &lt;a href="various.html#gO"&gt;gO&lt;/a&gt; to see the table of contents.">noise_lines: 2</span>
      </div>
    <div>

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
    <script type="module">
      docsearch({
        container: '#docsearch',
        appId: 'X185E15FPG',
        apiKey: 'b5e6b2f9c636b2b471303205e59832ed',
        indexName: 'nvim',
      });
    </script>

  </footer>
  </body>
</html>
