  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Neovim user documentation">

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" />
    <link rel="preconnect" href="https://X185E15FPG-dsn.algolia.net" crossorigin />

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="help.css" rel="stylesheet">
    <link href="/highlight/styles/neovim.min.css" rel="stylesheet">

    <script src="/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title> Lua - Neovim docs</title>
  </head>
  <body>
    <header class="container">
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a href="/" class="navbar-brand" aria-label="logo">
          <!--TODO: use <img src="….svg"> here instead. Need one that has green lettering instead of gray. -->
              <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214" aria-label="Neovim">
      <title>Neovim</title>
      <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
          <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
          <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
          <stop stop-color="#7DB643" offset="0%" />
          <stop stop-color="#367533" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
          <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
          <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
        </linearGradient>
      </defs>
      <g fill="none" fill-rule="evenodd">
        <path
          d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
          fill="url(#a)"
          transform="translate(1 1)"
        />
        <path
          d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
          fill="url(#b)"
          transform="matrix(-1 0 0 1 305 1)"
        />
        <path
          d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
          fill="url(#c)"
          transform="translate(1 1)"
        />
        <path
          d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
          fill-opacity=".13"
          fill="#000"
        />
        <g fill="#444">
          <path
            d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
            fill="currentColor"
          />
          <path
            d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
            fill="currentColor"
            fill-opacity=".8"
          />
        </g>
      </g>
    </svg>
  
          <!--<img src="https://neovim.io/logos/neovim-logo.svg" width="173" height="50" alt="Neovim" />-->
        </a>
        <div id="docsearch"></div> <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
      </div>
    </nav>
  </header>

  <div class="container golden-grid help-body">
  <div class="col-wide">
  <a name="lua.txt" href="#lua"><h1 id="lua"> Lua</h1></a>
  <p>
    <i>
    Nvim <code>:help</code> pages, <a href="https://github.com/neovim/neovim/blob/master/src/gen/gen_help_html.lua">generated</a>
    from <a href="https://github.com/neovim/neovim/blob/master/runtime/doc/lua.txt">source</a>
    using the <a href="https://github.com/neovim/tree-sitter-vimdoc">tree-sitter-vimdoc</a> parser.
    </i>
  </p>
  <hr/>
  <div class="help-para">
Lua engine <span id="Lua" class="help-tag"><a href="#Lua">Lua</a></span>

</div>
<div class="help-para">
<h2 id="_introduction" class="help-heading">INTRODUCTION<span class="help-heading-tags">                                                       <span id="lua-intro" class="help-tag"><a href="#lua-intro">lua-intro</a></span></h2>


</div>
<div class="help-para">
The Lua 5.1 script engine is builtin and always available. Try this command to
get an idea of what lurks beneath:<pre><code class="language-vim">:lua vim.print(package.loaded)</code></pre>
Nvim includes a "standard library" <a href="lua.html#lua-stdlib">lua-stdlib</a> for Lua.  It complements the
"editor stdlib" (<a href="vimfn.html#vimscript-functions">vimscript-functions</a> + <a href="vimindex.html#Ex-commands">Ex-commands</a>) and the <a href="api.html#API">API</a>, all of
which can be used from Lua code (<a href="lua.html#lua-vimscript">lua-vimscript</a> <a href="lua.html#vim.api">vim.api</a>). These three
namespaces form the Nvim programming interface.

</div>
<div class="help-para">
Lua plugins and user config are automatically discovered and loaded, just like
Vimscript. See <a href="lua-guide.html#lua-guide">lua-guide</a> for practical guidance.

</div>
<div class="help-para">
You can also run Lua scripts from your shell using the <a href="starting.html#-l">-l</a> argument:<pre>nvim -l foo.lua [args...]</pre>

</div>
<div class="help-para">
                                                                  <span id="lua-compat" class="help-tag-right"><a href="#lua-compat">lua-compat</a></span><br>
Lua 5.1 is the permanent interface for Nvim Lua. Plugins should target Lua 5.1
as specified in <a href="luaref.html#luaref">luaref</a>; later versions (which are essentially different,
incompatible, dialects) are not supported. This includes extensions such as
<code>goto</code> that some Lua 5.1 interpreters like LuaJIT may support.

</div>
<div class="help-para">
                                                                  <span id="lua-luajit" class="help-tag-right"><a href="#lua-luajit">lua-luajit</a></span><br>
While Nvim officially only requires Lua 5.1 support, it should be built with
LuaJIT or a compatible fork on supported platforms for performance reasons.
LuaJIT also comes with useful extensions such as <code>ffi</code>, <a href="lua.html#lua-profile">lua-profile</a>, and
enhanced standard library functions; these cannot be assumed to be available,
and Lua code in <a href="starting.html#init.lua">init.lua</a> or plugins should check the <code>jit</code> global variable
before using them:<pre><code class="language-lua">if jit then
  -- code for luajit
else
  -- code for plain lua 5.1
end</code></pre>

</div>
<div class="help-para">
One exception is the LuaJIT <code>bit</code> extension, which is always available: when
built with PUC Lua, Nvim includes a fallback implementation which provides
<code>require("bit")</code>. See <a href="lua-bit.html#lua-bit">lua-bit</a>.

</div>
<div class="help-para">
                                                                  <span id="lua-profile" class="help-tag-right"><a href="#lua-profile">lua-profile</a></span><br>
If Nvim is built with LuaJIT, Lua code can be profiled via<pre><code class="language-lua">-- Start a profiling session:
require('jit.p').start('ri1', '/tmp/profile')
-- Perform arbitrary tasks (use plugins, scripts, etc.) ...
-- Stop the session. Profile is written to /tmp/profile.
require('jit.p').stop()</code></pre>
See <a href="https://luajit.org/ext_profiler.html">https://luajit.org/ext_profiler.html</a> or the <code>p.lua</code> source for details:<pre>:lua vim.cmd.edit(package.searchpath('jit.p', package.path))</pre>
<h2 id="_lua-concepts-and-idioms" class="help-heading">LUA CONCEPTS AND IDIOMS<span class="help-heading-tags">                                         <span id="lua-concepts" class="help-tag"><a href="#lua-concepts">lua-concepts</a></span></h2>


</div>
<div class="help-para">
Lua is very simple, and _consistent_: while there are some quirks, once you
internalize those quirks, everything works the same everywhere. Scopes
(closures) in particular are very consistent, unlike JavaScript or most other
languages.

</div>
<div class="help-para">
Lua has three fundamental mechanisms—one for "each major aspect of
programming": tables, closures, and coroutines.
<a href="https://www.lua.org/doc/cacm2018.pdf">https://www.lua.org/doc/cacm2018.pdf</a>
<div class="help-li" style=""> Tables are the "object" or container datastructure: they represent both
  lists and maps, you can extend them to represent your own datatypes and
  change their behavior using <a href="luaref.html#metatable">metatable</a>s (like Python's "datamodel").
</div><div class="help-li" style=""> EVERY scope in Lua is a closure: a function is a closure, a module is
  a closure, a <code>do</code> block (<a href="luaref.html#lua-do">lua-do</a>) is a closure--and they all work the same.
  A Lua module is literally just a big closure discovered on the "path"
  (where your modules are found: <a href="luaref.html#package.cpath">package.cpath</a>).
</div><div class="help-li" style=""> Stackful coroutines enable cooperative multithreading, generators, and
  versatile control for both Lua and its host (Nvim).
</div>
</div>
<div class="help-para">
                                                          <span id="lua-error-handling" class="help-tag-right"><a href="#lua-error-handling">lua-error-handling</a></span><br>
Lua functions may throw <a href="luaref.html#lua-errors">lua-errors</a> for exceptional (unexpected) failures,
which you can handle with <a href="luaref.html#pcall()">pcall()</a>.
                                                       <span id="lua-result-or-message" class="help-tag-right"><a href="#lua-result-or-message">lua-result-or-message</a></span><br>
When failure is normal and expected, it's idiomatic to return <code>nil</code> which
signals to the caller that failure is not "exceptional" and must be handled.
This "result-or-message" pattern is expressed as the multi-value return type
<code>any|nil,nil|string</code>, or in LuaLS notation:<pre>---@return any|nil    # result on success, nil on failure.
---@return nil|string # nil on success, error message on failure.</pre>

</div>
<div class="help-para">
Examples of the "result-or-message" pattern:
<div class="help-li" style=""> <a href="lua.html#vim.ui.open()">vim.ui.open()</a>
</div><div class="help-li" style=""> <a href="luaref.html#io.open()">io.open()</a>
</div><div class="help-li" style=""> <a href="luvref.html#luv-error-handling">luv-error-handling</a>
</div>
</div>
<div class="help-para">
When a caller can't proceed on failure, it's idiomatic to <code>assert()</code> the
"result-or-message" result:<pre><code class="language-lua">local value = assert(fn())</code></pre>
Guidance: use the "result-or-message" pattern for...
<div class="help-li" style=""> Functions where failure is expected, especially when communicating with the
  external world. E.g. HTTP requests or LSP requests often fail because of
  server problems, even if the caller did everything right.
</div><div class="help-li" style=""> Functions that return a value, e.g. Foo:new().
</div><div class="help-li" style=""> When there is a list of known error codes which can be returned as a third
  value (like <a href="luvref.html#luv-error-handling">luv-error-handling</a>).
</div>
</div>
<div class="help-para">
                                                                    <span id="iterator" class="help-tag-right"><a href="#iterator">iterator</a></span><br>
An iterator is just a function that can be called repeatedly to get the "next"
value of a collection (or any other <a href="lua.html#iterable">iterable</a>). This interface is expected by
<a href="luaref.html#for-in">for-in</a> loops, produced by <a href="luaref.html#pairs()">pairs()</a>, supported by <a href="lua.html#vim.iter">vim.iter</a>, etc.
<a href="https://www.lua.org/pil/7.1.html">https://www.lua.org/pil/7.1.html</a>

</div>
<div class="help-para">
                                                                    <span id="iterable" class="help-tag-right"><a href="#iterable">iterable</a></span><br>
An "iterable" is anything that <a href="lua.html#vim.iter()">vim.iter()</a> can consume: tables, dicts, lists,
iterator functions, tables implementing the <a href="luaref.html#__call()">__call()</a> metamethod, and
<a href="lua.html#vim.iter()">vim.iter()</a> objects.

</div>
<div class="help-para">
                                                               <span id="list-iterator" class="help-tag-right"><a href="#list-iterator">list-iterator</a></span><br>
Iterators on <a href="lua.html#lua-list">lua-list</a> tables have a "middle" and "end", whereas iterators in
general may be logically infinite. Therefore some <a href="lua.html#vim.iter">vim.iter</a> operations (e.g.
<a href="lua.html#Iter%3Arev()">Iter:rev()</a>) make sense only on list-like tables (which are finite by
definition).

</div>
<div class="help-para">
                                                           <span id="lua-function-call" class="help-tag-right"><a href="#lua-function-call">lua-function-call</a></span><br>
Lua functions can be called in multiple ways. Consider the function:<pre><code class="language-lua">local foo = function(a, b)
    print("A: ", a)
    print("B: ", b)
end</code></pre>
The first way to call this function is:<pre><code class="language-lua">foo(1, 2)
-- ==== Result ====
-- A: 1
-- B: 2</code></pre>
This way of calling a function is familiar from most scripting languages. In
Lua, any missing arguments are passed as <code>nil</code>, and extra parameters are
silently discarded. Example:<pre><code class="language-lua">foo(1)
-- ==== Result ====
-- A: 1
-- B: nil</code></pre>

</div>
<div class="help-para">
                                                                      <span id="kwargs" class="help-tag-right"><a href="#kwargs">kwargs</a></span><br>
When calling a function, you can omit the parentheses if the function takes
exactly one string literal (<code>"foo"</code>) or table literal (<code>{1,2,3}</code>). The latter
is often used to mimic "named parameters" ("kwargs" or "keyword args") as in
languages like Python and C#. Example:<pre><code class="language-lua">local func_with_opts = function(opts)
    local will_do_foo = opts.foo
    local filename = opts.filename
    -- ...
end
func_with_opts { foo = true, filename = "hello.world" }</code></pre>

</div>
<div class="help-para">
There's nothing special going on here except that parentheses are implicitly
added. But visually, this small bit of sugar gets reasonably close to a
"keyword args" interface.

</div>
<div class="help-para">
                                                                   <span id="lua-regex" class="help-tag-right"><a href="#lua-regex">lua-regex</a></span><br>
Lua intentionally does not support regular expressions, instead it has limited
<a href="luaref.html#lua-pattern">lua-pattern</a>s which avoid the performance pitfalls of extended regex. Lua
scripts can also use Vim regex via <a href="lua.html#vim.regex()">vim.regex()</a>.

</div>
<div class="help-para">
Examples:<pre><code class="language-lua">print(string.match("foo123bar123", "%d+"))
-- 123
print(string.match("foo123bar123", "[^%d]+"))
-- foo
print(string.match("foo123bar123", "[abc]+"))
-- ba
print(string.match("foo.bar", "%.bar"))
-- .bar</code></pre>

</div>
<div class="help-para">
                                                                  <span id="lua-truthy" class="help-tag-right"><a href="#lua-truthy">lua-truthy</a></span><br>
Only <code>false</code> and <code>nil</code> evaluate to "false" in Lua. All other values are "true".

</div>
<div class="help-para">
<h2 id="_importing-lua-modules" class="help-heading">IMPORTING LUA MODULES<span class="help-heading-tags">                                        <span id="lua-module-load" class="help-tag"><a href="#lua-module-load">lua-module-load</a></span></h2>


</div>
<div class="help-para">
Modules are searched for under the directories specified in <a href="options.html#'runtimepath'">'runtimepath'</a> and
<a href="options.html#packages-runtimepath">packages-runtimepath</a>, in the order they appear in the output of this command
<pre><code class="language-vim">:echo nvim_list_runtime_paths()</code></pre>

</div>
<div class="help-para">
Any "." in the module name is treated as a directory separator when searching.
For a module <code>foo.bar</code>, each directory is searched for <code>lua/foo/bar.lua</code>, then
<code>lua/foo/bar/init.lua</code>.  If no files are found, the directories are searched
again for a shared library with a name matching <code>lua/foo/bar.?</code>, where <code>?</code> is
a list of suffixes (such as <code>so</code> or <code>dll</code>) derived from the initial value of
<a href="luaref.html#package.cpath">package.cpath</a>. If still no files are found, Nvim falls back to Lua's default
search mechanism. The first script found is run and <code>require()</code> returns the
value returned by the script if any, else <code>true</code>.

</div>
<div class="help-para">
The return value is cached after the first call to <code>require()</code> for each module,
with subsequent calls returning the cached value without searching for, or
executing any script. For further details see <a href="luaref.html#require()">require()</a>.

</div>
<div class="help-para">
For example, if <a href="options.html#'runtimepath'">'runtimepath'</a> is <code>foo,bar</code> and <a href="luaref.html#package.cpath">package.cpath</a> was
<code>./?.so;./?.dll</code> at startup, <code>require('mod')</code> searches these paths in order
and loads the first module found ("first wins"):<pre>foo/lua/mod.lua
foo/lua/mod/init.lua
bar/lua/mod.lua
bar/lua/mod/init.lua
foo/lua/mod.so
foo/lua/mod.dll
bar/lua/mod.so
bar/lua/mod.dll</pre>

</div>
<div class="help-para">
<b>Note:</b>

</div>
<div class="help-para">
<div class="help-li" style=""> Although <a href="options.html#'runtimepath'">'runtimepath'</a> is tracked, Nvim does not track current
  values of <a href="luaref.html#package.path">package.path</a> or <a href="luaref.html#package.cpath">package.cpath</a>. If you happen to delete some
  paths from there you can set <a href="options.html#'runtimepath'">'runtimepath'</a> to trigger an update:<pre><code class="language-vim">let &amp;runtimepath = &amp;runtimepath</code></pre>
</div><div class="help-li" style=""> Skipping paths from <a href="options.html#'runtimepath'">'runtimepath'</a> which contain semicolons applies both to
  <a href="luaref.html#package.path">package.path</a> and <a href="luaref.html#package.cpath">package.cpath</a>. Given that there are some badly written
  plugins using shell, which will not work with paths containing semicolons,
  it is better to not have them in <a href="options.html#'runtimepath'">'runtimepath'</a> at all.
</div>
</div>
<div class="help-para">
                                                         <span id="lua-script-location" class="help-tag-right"><a href="#lua-script-location">lua-script-location</a></span><br>
To get its own location, Lua scripts/modules can use <a href="luaref.html#debug.getinfo()">debug.getinfo()</a>:<pre>debug.getinfo(1, 'S').source:gsub('^@', '')</pre>

</div>
<div class="help-para">
<h2 id="_commands" class="help-heading">COMMANDS<span class="help-heading-tags">                                                        <span id="lua-commands" class="help-tag"><a href="#lua-commands">lua-commands</a></span></h2>


</div>
<div class="help-para">
These commands execute a Lua chunk from either the command line (:lua, :luado)
or a file (:luafile) on the given line [range]. As always in Lua, each chunk
has its own scope (closure), so only global variables are shared between
command calls. The <a href="lua.html#lua-stdlib">lua-stdlib</a> modules, user modules, and anything else on
<a href="luaref.html#package.path">package.path</a> are available.

</div>
<div class="help-para">
The Lua print() function redirects its output to the Nvim message area, with
arguments separated by " " (space) instead of "\t" (tab).

</div>
<div class="help-para">
                                                                  <span id="%3Alua%3D" class="help-tag"><a href="#%3Alua%3D">:lua=</a></span> <span id="%3Alua" class="help-tag"><a href="#%3Alua">:lua</a></span>
:lua <code>{chunk}</code>
    Executes Lua chunk <code>{chunk}</code>. If <code>{chunk}</code> starts with "=" the rest of the
    chunk is evaluated as an expression and printed. <code>:lua =expr</code> and <code>:=expr</code>
    are equivalent to <code>:lua print(vim.inspect(expr))</code>. <a href="message.html#E5107">E5107</a> <a href="message.html#E5108">E5108</a>

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:lua vim.api.nvim_command('echo "Hello, Nvim!"')</code></pre>

</div>
<div class="help-para">
    To see the Lua version:<pre><code class="language-vim">:lua print(_VERSION)</code></pre>

</div>
<div class="help-para">
    To see the LuaJIT version:<pre><code class="language-vim">:lua =jit.version</code></pre>

</div>
<div class="help-para">
:{range}lua
    Executes buffer lines in <code>{range}</code> as Lua code. Unlike <a href="repeat.html#%3Asource">:source</a>, this
    always treats the lines as Lua code.

</div>
<div class="help-para">
    Example: select the following code and type ":lua&lt;Enter&gt;" to execute it:<pre><code class="language-lua">print(string.format(
    'unix time: %s', os.time()))</code></pre>

</div>
<div class="help-para">
                                                                <span id="%3Alua-heredoc" class="help-tag-right"><a href="#%3Alua-heredoc">:lua-heredoc</a></span><br>
:lua &lt;&lt; [trim] [<code>{endmarker}</code>]
<code>{script}</code>
<code>{endmarker}</code>
    Executes Lua script <code>{script}</code> from within Vimscript. You can omit
    [endmarker] after the "&lt;&lt;" and use a dot "." after <code>{script}</code> (similar to
    <a href="insert.html#%3Aappend">:append</a>, <a href="insert.html#%3Ainsert">:insert</a>). Refer to <a href="vimeval.html#%3Alet-heredoc">:let-heredoc</a> for more information.

</div>
<div class="help-para">
    Example:<pre><code class="language-vim">function! CurrentLineInfo()
lua &lt;&lt; EOF
local linenr = vim.api.nvim_win_get_cursor(0)[1]
local curline = vim.api.nvim_buf_get_lines(0, linenr - 1, linenr, false)[1]
print(string.format('Line [%d] has %d bytes', linenr, #curline))
EOF
endfunction</code></pre>

</div>
<div class="help-para">
    Note that the <code>local</code> variables will disappear when the block finishes.
    But not globals.

</div>
<div class="help-para">
                                                                      <span id="%3Aluado" class="help-tag-right"><a href="#%3Aluado">:luado</a></span><br>
:[range]luado <code>{body}</code>
    Executes Lua chunk "function(line, linenr) <code>{body}</code> end" for each buffer
    line in [range], where <code>line</code> is the current line text (without <code>&lt;EOL&gt;</code>),
    and <code>linenr</code> is the current line number. If the function returns a string
    that becomes the text of the corresponding buffer line. Default [range] is
    the whole file: "1,$". <a href="message.html#E5109">E5109</a> <a href="message.html#E5110">E5110</a> <a href="message.html#E5111">E5111</a>

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:luado return string.format("%s\t%d", line:reverse(), #line)
:lua require"lpeg"
:lua -- balanced parenthesis grammar:
:lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }
:luado if bp:match(line) then return "=&gt;\t" .. line end</code></pre>

</div>
<div class="help-para">
                                                                    <span id="%3Aluafile" class="help-tag-right"><a href="#%3Aluafile">:luafile</a></span><br>
:luafile <code>{file}</code>
    Execute Lua script in <code>{file}</code>.
    The whole argument is used as the filename (like <a href="editing.html#%3Aedit">:edit</a>), spaces do not
    need to be escaped. Alternatively you can <a href="repeat.html#%3Asource">:source</a> Lua files.
    <a href="message.html#E5111">E5111</a> <a href="message.html#E5112">E5112</a> <a href="message.html#E5113">E5113</a>

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:luafile script.lua
:luafile %</code></pre>

</div>
<div class="help-para">
<h2 id="_luaeval()" class="help-heading">luaeval()<span class="help-heading-tags">                                                 <span id="lua-eval" class="help-tag"><a href="#lua-eval">lua-eval</a></span></h2>


</div>
<div class="help-para">
The (dual) equivalent of "vim.eval" for passing Lua values to Nvim is
"luaeval". "luaeval" takes an expression string and an optional argument used
for _A inside expression and returns the result of the expression. It is
semantically equivalent in Lua to:<pre><code class="language-lua">local chunkheader = "local _A = select(1, ...) return "
function luaeval (expstr, arg)
    local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))
    return chunk(arg) -- return typval
end</code></pre>

</div>
<div class="help-para">
Lua nils, numbers, strings, tables and booleans are converted to their
respective Vimscript types. If a Lua string contains a NUL byte, it will be
converted to a <a href="vimeval.html#Blob">Blob</a>. Conversion of other Lua types is an error.

</div>
<div class="help-para">
The magic global "_A" contains the second argument to luaeval().

</div>
<div class="help-para">
Example:<pre><code class="language-vim">:echo luaeval('_A[1] + _A[2]', [40, 2])
" 42
:echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')
" foo</code></pre>

</div>
<div class="help-para">
                                                         <span id="lua-table-ambiguous" class="help-tag-right"><a href="#lua-table-ambiguous">lua-table-ambiguous</a></span><br>
Lua tables are used as both dictionaries and lists, so it is impossible to
decide whether empty table is a list or a dict. Also Lua does not have integer
numbers. To disambiguate these cases, we define:
                                                                    <span id="lua-list" class="help-tag-right"><a href="#lua-list">lua-list</a></span><br>
<div class="help-li-num" style=""> Empty table is a list. Use <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a> to represent empty dict.
</div><div class="help-li-num" style=""> Table with N consecutive (no <code>nil</code> values, aka "holes") integer keys 1…N is
   a list. See also <a href="lua.html#list-iterator">list-iterator</a>.
                                                                    <span id="lua-dict" class="help-tag-right"><a href="#lua-dict">lua-dict</a></span><br>
</div><div class="help-li-num" style=""> Table with string keys, none of which contains NUL byte, is a dict.
</div><div class="help-li-num" style=""> Table with string keys, at least one of which contains NUL byte, is also
   considered to be a dictionary, but this time it is converted to
   a <a href="vimfn.html#msgpack-special-map">msgpack-special-map</a>.
                                                             <span id="lua-special-tbl" class="help-tag-right"><a href="#lua-special-tbl">lua-special-tbl</a></span><br>
</div><div class="help-li-num" style=""> Table with <code>vim.type_idx</code> key may be a dictionary, a list or floating-point
   value:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}</code> is converted to
     a floating-point 1.0. Note that by default integral Lua numbers are
     converted to <a href="vimeval.html#Number">Number</a>s, non-integral are converted to <a href="vimeval.html#Float">Float</a>s. This
     variant allows integral <a href="vimeval.html#Float">Float</a>s.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[vim.type_idx]=vim.types.dictionary}</code> is converted to an empty
     dictionary, <code>{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}</code> is
     converted to a dictionary <code>{'a': 42}</code>: non-string keys are ignored.
     Without <code>vim.type_idx</code> key tables with keys not fitting in 1., 2. or 3.
     are errors.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{[vim.type_idx]=vim.types.array}</code> is converted to an empty list. As well
     as <code>{[vim.type_idx]=vim.types.array, [42]=1}</code>: integral keys that do not
     form a 1-step sequence from 1 to N are ignored, as well as all
     non-integral keys.
</div>
</div>
<div class="help-para">
Examples:<pre><code class="language-vim">:echo luaeval('math.pi')
:function Rand(x,y) " random uniform between x and y
:  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})
:  endfunction
:echo Rand(1,10)</code></pre>

</div>
<div class="help-para">
<b>Note:</b> Second argument to <code>luaeval</code> is converted ("marshalled") from Vimscript
to Lua, so changes to Lua containers do not affect values in Vimscript. Return
value is also always converted. When converting, <a href="vimfn.html#msgpack-special-dict">msgpack-special-dict</a>s are
treated specially.

</div>
<div class="help-para">
<h2 id="_vimscript-v:lua-interface" class="help-heading">Vimscript v:lua interface<span class="help-heading-tags">                                         <span id="v%3Alua-call" class="help-tag"><a href="#v%3Alua-call">v:lua-call</a></span></h2>


</div>
<div class="help-para">
From Vimscript the special <code>v:lua</code> prefix can be used to call Lua functions
which are global or accessible from global tables. The expression<pre><code class="language-vim">call v:lua.func(arg1, arg2)</code></pre>
is equivalent to the Lua chunk<pre><code class="language-lua">return func(...)</code></pre>
where the args are converted to Lua values. The expression<pre><code class="language-vim">call v:lua.somemod.func(args)</code></pre>
is equivalent to the Lua chunk<pre><code class="language-lua">return somemod.func(...)</code></pre>
Lua module functions can be accessed like:<pre><code class="language-vim">call v:lua.require'mypack'.func(arg1, arg2)
call v:lua.require'mypack.submod'.func(arg1, arg2)</code></pre>
<b>Note:</b> Only single quote form without parens is allowed. Using
<code>require"mypack"</code> or <code>require('mypack')</code> as a prefix does NOT work.

</div>
<div class="help-para">
You can use <code>v:lua</code> in "func" options like <a href="options.html#'tagfunc'">'tagfunc'</a>, <a href="options.html#'omnifunc'">'omnifunc'</a>, etc.
For example consider the following Lua omnifunc handler:<pre><code class="language-lua">function mymod.omnifunc(findstart, base)
  if findstart == 1 then
    return 0
  else
    return {'stuff', 'steam', 'strange things'}
  end
end
-- Note: The module ("mymod") must be a Lua global, or use require() as
-- shown above to access it from a package.
vim.bo[buf].omnifunc = 'v:lua.mymod.omnifunc'</code></pre>
You can also use <code>v:lua</code> to call Lua functions as Vimscript <a href="vimeval.html#method">method</a>s:<pre><code class="language-vim">:eval arg1-&gt;v:lua.somemod.func(arg2)</code></pre>

</div>
<div class="help-para">
<b>Note:</b> <code>v:lua</code> without a call is not allowed in a Vimscript expression:
<a href="vimeval.html#Funcref">Funcref</a>s cannot represent Lua functions. The following are errors:<pre><code class="language-vim">let g:Myvar = v:lua.myfunc        " Error
call SomeFunc(v:lua.mycallback)   " Error
let g:foo = v:lua                 " Error
let g:foo = v:['lua']             " Error</code></pre>

</div>
<div class="help-para">
<h2 id="_lua-standard-modules" class="help-heading">Lua standard modules<span class="help-heading-tags">                                              <span id="lua-stdlib" class="help-tag"><a href="#lua-stdlib">lua-stdlib</a></span></h2>


</div>
<div class="help-para">
The Nvim Lua "standard library" (stdlib) is the <code>vim</code> module, which exposes
various functions and sub-modules. It is always loaded, thus <code>require("vim")</code>
is unnecessary.

</div>
<div class="help-para">
You can peek at the module properties:<pre><code class="language-vim">:lua vim.print(vim)</code></pre>
Result is something like this:<pre>{
  _os_proc_children = &lt;function 1&gt;,
  _os_proc_info = &lt;function 2&gt;,
  ...
  api = {
    nvim__id = &lt;function 5&gt;,
    nvim__id_array = &lt;function 6&gt;,
    ...
  },
  deepcopy = &lt;function 106&gt;,
  gsplit = &lt;function 107&gt;,
  ...
}</pre>
To find documentation on e.g. the "deepcopy" function:<pre><code class="language-vim">:help vim.deepcopy()</code></pre>
Note that underscore-prefixed functions (e.g. "_os_proc_children") are
internal/private and must not be used by plugins.

</div>
<div class="help-para">
<h3 id="_vim.uv" class="help-heading">VIM.UV<span class="help-heading-tags">                                                   <span id="lua-loop" class="help-tag"><a href="#lua-loop">lua-loop</a></span> <span id="vim.uv" class="help-tag"><a href="#vim.uv">vim.uv</a></span></span></h3>


</div>
<div class="help-para">
<code>vim.uv</code> exposes the "luv" Lua bindings for the libUV library that Nvim uses
for networking, filesystem, and process management, see <a href="luvref.html#luvref.txt">luvref.txt</a>.
In particular, it allows interacting with the main Nvim <a href="luvref.html#luv-event-loop">luv-event-loop</a>.

</div>
<div class="help-para">
                                                    <span id="E5560" class="help-tag"><a href="#E5560">E5560</a></span> <span id="lua-loop-callbacks" class="help-tag"><a href="#lua-loop-callbacks">lua-loop-callbacks</a></span>
It is an error to directly invoke <code>vim.api</code> functions (except <a href="api.html#api-fast">api-fast</a>) in
<code>vim.uv</code> callbacks. For example, this is an error:<pre><code class="language-lua">local timer = vim.uv.new_timer()
timer:start(1000, 0, function()
  vim.api.nvim_command('echomsg "test"')
end)</code></pre>

</div>
<div class="help-para">
To avoid the error use <a href="lua.html#vim.schedule_wrap()">vim.schedule_wrap()</a> to defer the callback:<pre><code class="language-lua">local timer = vim.uv.new_timer()
timer:start(1000, 0, vim.schedule_wrap(function()
  vim.api.nvim_command('echomsg "test"')
end))</code></pre>

</div>
<div class="help-para">
(For one-shot timers, see <a href="lua.html#vim.defer_fn()">vim.defer_fn()</a>, which automatically adds the
wrapping.)

</div>
<div class="help-para">
Example: repeating timer
<div class="help-li-num" style=""> Save this code to a file.
</div><div class="help-li-num" style=""> Execute it with ":luafile %".
<pre><code class="language-lua">-- Create a timer handle (implementation detail: uv_timer_t).
local timer = vim.uv.new_timer()
local i = 0
-- Waits 1000ms, then repeats every 750ms until timer:close().
timer:start(1000, 750, function()
  print('timer invoked! i='..tostring(i))
  if i &gt; 4 then
    timer:close()  -- Always close handles to avoid leaks.
  end
  i = i + 1
end)
print('sleeping');</code></pre></div>
</div>
<div class="help-para">
Example: File-change detection                                    <span id="watch-file" class="help-tag-right"><a href="#watch-file">watch-file</a></span><br>
<div class="help-li-num" style=""> Save this code to a file.
</div><div class="help-li-num" style=""> Execute it with ":luafile %".
</div><div class="help-li-num" style=""> Use ":Watch %" to watch any file.
</div><div class="help-li-num" style=""> Try editing the file from another text editor.
</div><div class="help-li-num" style=""> Observe that the file reloads in Nvim (because on_change() calls
       <a href="editing.html#%3Achecktime">:checktime</a>).<pre><code class="language-lua">local w = vim.uv.new_fs_event()
local function on_change(err, fname, status)
  -- Do work...
  vim.api.nvim_command('checktime')
  -- Debounce: stop/start.
  w:stop()
  watch_file(fname)
end
function watch_file(fname)
  local fullpath = vim.api.nvim_call_function(
    'fnamemodify', {fname, ':p'})
  w:start(fullpath, {}, vim.schedule_wrap(function(...)
    on_change(...) end))
end
vim.api.nvim_command(
  "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('&lt;args&gt;'))")</code></pre>
</div>
</div>
<div class="help-para">
                                                         <span id="inotify-limitations" class="help-tag-right"><a href="#inotify-limitations">inotify-limitations</a></span><br>
When on Linux you may need to increase the maximum number of <code>inotify</code> watches
and queued events as the default limit can be too low. To increase the limit,
run:<pre><code class="language-bash">sysctl fs.inotify.max_user_watches=494462</code></pre>

</div>
<div class="help-para">
This will increase the limit to 494462 watches and queued events. These lines
can be added to <code>/etc/sysctl.conf</code> to make the changes persistent.

</div>
<div class="help-para">
Note that each watch is a structure in the Kernel, thus available memory is
also a bottleneck for using inotify. In fact, a watch can take up to 1KB of
space. This means a million watches could result in 1GB of extra RAM usage.

</div>
<div class="help-para">
Example: TCP echo-server                                          <span id="tcp-server" class="help-tag-right"><a href="#tcp-server">tcp-server</a></span><br>
<div class="help-li-num" style=""> Save this code to a file.
</div><div class="help-li-num" style=""> Execute it with ":luafile %".
</div><div class="help-li-num" style=""> Note the port number.
</div><div class="help-li-num" style=""> Connect from any TCP client (e.g. "nc 0.0.0.0 36795"):
<pre><code class="language-lua">local function create_server(host, port, on_connect)
  local server = vim.uv.new_tcp()
  server:bind(host, port)
  server:listen(128, function(err)
    assert(not err, err)  -- Check for errors.
    local sock = vim.uv.new_tcp()
    server:accept(sock)  -- Accept client connection.
    on_connect(sock)  -- Start reading messages.
  end)
  return server
end
local server = create_server('0.0.0.0', 0, function(sock)
  sock:read_start(function(err, chunk)
    assert(not err, err)  -- Check for errors.
    if chunk then
      sock:write(chunk)  -- Echo received messages to the channel.
    else  -- EOF (stream closed).
      sock:close()  -- Always close handles to avoid leaks.
    end
  end)
end)
print('TCP echo-server listening on port: '..server:getsockname().port)</code></pre></div>
</div>
<div class="help-para">
Multithreading                                            <span id="lua-loop-threading" class="help-tag-right"><a href="#lua-loop-threading">lua-loop-threading</a></span><br>

</div>
<div class="help-para">
Plugins can perform work in separate (os-level) threads using the threading
APIs in luv, for instance <code>vim.uv.new_thread</code>. Each thread has its own
separate Lua interpreter state, with no access to Lua globals on the main
thread. Neither can the editor state (buffers, windows, etc) be directly
accessed from threads.

</div>
<div class="help-para">
A subset of the <code>vim.*</code> stdlib is available in threads, including:

</div>
<div class="help-para">
<div class="help-li" style=""> <code>vim.uv</code> with a separate event loop per thread.
</div><div class="help-li" style=""> <code>vim.mpack</code> and <code>vim.json</code> (useful for serializing messages between threads)
</div><div class="help-li" style=""> <code>require</code> in threads can use Lua packages from the global <a href="luaref.html#package.path">package.path</a>
</div><div class="help-li" style=""> <code>print()</code> and <code>vim.inspect</code>
</div><div class="help-li" style=""> <code>vim.text.diff</code>
</div><div class="help-li" style=""> Most utility functions in <code>vim.*</code> that work with pure Lua values, like
  <code>vim.split</code>, <code>vim.tbl_*</code>, <code>vim.list_*</code>, etc.
</div><div class="help-li" style=""> <code>vim.is_thread()</code> returns true from a non-main thread.
</div>
</div>
<div class="help-para">
<h2 id="_vim" class="help-heading">VIM<span class="help-heading-tags">                                                              <span id="vim.builtin" class="help-tag"><a href="#vim.builtin">vim.builtin</a></span></h2>


</div>
<div class="help-para">
vim.api.<code>{func}</code>(<code>{...}</code>)                                                <span id="vim.api" class="help-tag-right"><a href="#vim.api">vim.api</a></span><br>
    Invokes Nvim <a href="api.html#API">API</a> function <code>{func}</code> with arguments <code>{...}</code>.
    Example: call the "nvim_get_current_line()" API function:<pre><code class="language-lua">print(tostring(vim.api.nvim_get_current_line()))</code></pre>
vim.NIL                                                              <span id="vim.NIL" class="help-tag-right"><a href="#vim.NIL">vim.NIL</a></span><br>
    Special value representing NIL in <a href="api.html#RPC">RPC</a> and <a href="vvars.html#v%3Anull">v:null</a> in Vimscript
    conversion, and similar cases. Lua <code>nil</code> cannot be used as part of a Lua
    table representing a Dictionary or Array, because it is treated as
    missing: <code>{"foo", nil}</code> is the same as <code>{"foo"}</code>.

</div>
<div class="help-para">
vim.type_idx                                                    <span id="vim.type_idx" class="help-tag-right"><a href="#vim.type_idx">vim.type_idx</a></span><br>
    Type index for use in <a href="lua.html#lua-special-tbl">lua-special-tbl</a>. Specifying one of the values from
    <a href="lua.html#vim.types">vim.types</a> allows typing the empty table (it is unclear whether empty Lua
    table represents empty list or empty array) and forcing integral numbers
    to be <a href="vimeval.html#Float">Float</a>. See <a href="lua.html#lua-special-tbl">lua-special-tbl</a> for more details.

</div>
<div class="help-para">
vim.val_idx                                                      <span id="vim.val_idx" class="help-tag-right"><a href="#vim.val_idx">vim.val_idx</a></span><br>
    Value index for tables representing <a href="vimeval.html#Float">Float</a>s. A table representing
    floating-point value 1.0 looks like this:<pre><code class="language-lua">{
  [vim.type_idx] = vim.types.float,
  [vim.val_idx] = 1.0,
}</code></pre>

</div>
<div class="help-para">
    See also <a href="lua.html#vim.type_idx">vim.type_idx</a> and <a href="lua.html#lua-special-tbl">lua-special-tbl</a>.

</div>
<div class="help-para">
vim.types                                                          <span id="vim.types" class="help-tag-right"><a href="#vim.types">vim.types</a></span><br>
    Table with possible values for <a href="lua.html#vim.type_idx">vim.type_idx</a>. Contains two sets of
    key-value pairs: first maps possible values for <a href="lua.html#vim.type_idx">vim.type_idx</a> to
    human-readable strings, second maps human-readable type names to values
    for <a href="lua.html#vim.type_idx">vim.type_idx</a>. Currently contains pairs for <code>float</code>, <code>array</code> and
        <code>dictionary</code> types.

</div>
<div class="help-para">
<b>    Note:</b> One must expect that values corresponding to <code>vim.types.float</code>,
    <code>vim.types.array</code> and <code>vim.types.dictionary</code> fall under only two following
    assumptions:
<div class="help-li-num" style=""> Value may serve both as a key and as a value in a table. Given the
       properties of Lua tables this basically means “value is not <code>nil</code>”.
</div><div class="help-li-num" style=""> For each value in <code>vim.types</code> table <code>vim.types[vim.types[value]]</code> is the
       same as <code>value</code>.
    No other restrictions are put on types, and it is not guaranteed that
    values corresponding to <code>vim.types.float</code>, <code>vim.types.array</code> and
    <code>vim.types.dictionary</code> will not change or that <code>vim.types</code> table will only
    contain values for these three types.
</div>
</div>
<div class="help-para">
                                                   <span id="log_levels" class="help-tag"><a href="#log_levels">log_levels</a></span> <span id="vim.log.levels" class="help-tag"><a href="#vim.log.levels">vim.log.levels</a></span>
Log levels are one of the values defined in <code>vim.log.levels</code>:

</div>
<div class="help-para">
    vim.log.levels.DEBUG
    vim.log.levels.ERROR
    vim.log.levels.INFO
    vim.log.levels.TRACE
    vim.log.levels.WARN
    vim.log.levels.OFF

</div>
<div class="help-para">
vim.empty_dict()                                            <span id="vim.empty_dict()" class="help-tag-right"><a href="#vim.empty_dict()">vim.empty_dict()</a></span><br>
    Creates a special empty table (marked with a metatable), which Nvim
    converts to an empty dictionary when translating Lua values to Vimscript
    or API types. Nvim by default converts an empty table <code>{}</code> without this
    metatable to an list/array.

</div>
<div class="help-para">
<b>    Note:</b> If numeric keys are present in the table, Nvim ignores the metatable
    marker and converts the dict to a list/array anyway.

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>)

</div>
<div class="help-para">
vim.iconv(<code>{str}</code>, <code>{from}</code>, <code>{to}</code>)                                   <span id="vim.iconv()" class="help-tag-right"><a href="#vim.iconv()">vim.iconv()</a></span><br>
    The result is a String, which is the text <code>{str}</code> converted from encoding
    <code>{from}</code> to encoding <code>{to}</code>. When the conversion fails <code>nil</code> is returned. When
    some characters could not be converted they are replaced with "?". The
    encoding names are whatever the iconv() library function can accept, see
    ":Man 3 iconv".

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>   (<code>string</code>) Text to convert
</div><div class="help-li" style=""> <code>{from}</code>  (<code>string</code>) Encoding of <code>{str}</code>
</div><div class="help-li" style=""> <code>{to}</code>    (<code>string</code>) Target encoding
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>) Converted string if conversion succeeds, <code>nil</code> otherwise.

</div>
<div class="help-para">
vim.in_fast_event()                                      <span id="vim.in_fast_event()" class="help-tag-right"><a href="#vim.in_fast_event()">vim.in_fast_event()</a></span><br>
    Returns true if the code is executing as part of a "fast" event handler,
    where most of the API is disabled. These are low-level events (e.g.
    <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>) which can be invoked whenever Nvim polls for input.
    When this is <code>false</code> most API functions are callable (but may be subject
    to other restrictions such as <a href="vimeval.html#textlock">textlock</a>).

</div>
<div class="help-para">
vim.rpcnotify(<code>{channel}</code>, <code>{method}</code>, <code>{...}</code>)                    <span id="vim.rpcnotify()" class="help-tag-right"><a href="#vim.rpcnotify()">vim.rpcnotify()</a></span><br>
    Sends <code>{event}</code> to <code>{channel}</code> via <a href="api.html#RPC">RPC</a> and returns immediately. If <code>{channel}</code>
    is 0, the event is broadcast to all channels.

</div>
<div class="help-para">
    This function also works in a fast callback <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{channel}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{method}</code>   (<code>string</code>)
</div><div class="help-li" style=""> <code>{...}</code>      (<code>any?</code>)
</div>
</div>
<div class="help-para">
vim.rpcrequest(<code>{channel}</code>, <code>{method}</code>, <code>{...}</code>)                  <span id="vim.rpcrequest()" class="help-tag-right"><a href="#vim.rpcrequest()">vim.rpcrequest()</a></span><br>
    Invokes <a href="api.html#RPC">RPC</a> <code>method</code> on <code>channel</code> and blocks until a response is
    received.

</div>
<div class="help-para">
<b>    Note:</b> Msgpack NIL values in the response are represented as <a href="lua.html#vim.NIL">vim.NIL</a>.

</div>
<div class="help-para">
    Example: see <a href="api.html#nvim_exec_lua()">nvim_exec_lua()</a>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{channel}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{method}</code>   (<code>string</code>)
</div><div class="help-li" style=""> <code>{...}</code>      (<code>any?</code>)
</div>
</div>
<div class="help-para">
vim.schedule(<code>{fn}</code>)                                            <span id="vim.schedule()" class="help-tag-right"><a href="#vim.schedule()">vim.schedule()</a></span><br>
    Schedules <code>{fn}</code> to be invoked soon by the main event-loop. Useful to avoid
    <a href="vimeval.html#textlock">textlock</a> or other temporary restrictions.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>  (<code>fun()</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>nil</code>) result
        (<code>string?</code>) err Error message if scheduling failed, <code>nil</code> otherwise.

</div>
<div class="help-para">
vim.str_utf_end(<code>{str}</code>, <code>{index}</code>)                            <span id="vim.str_utf_end()" class="help-tag-right"><a href="#vim.str_utf_end()">vim.str_utf_end()</a></span><br>
    Gets the distance (in bytes) from the last byte of the codepoint
    (character) that <code>{index}</code> points to.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- The character 'æ' is stored as the bytes '\xc3\xa6' (using UTF-8)
-- Returns 0 because the index is pointing at the last byte of a character
vim.str_utf_end('æ', 2)
-- Returns 1 because the index is pointing at the penultimate byte of a character
vim.str_utf_end('æ', 1)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>    (<code>string</code>)
</div><div class="help-li" style=""> <code>{index}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>)

</div>
<div class="help-para">
vim.str_utf_pos(<code>{str}</code>)                                     <span id="vim.str_utf_pos()" class="help-tag-right"><a href="#vim.str_utf_pos()">vim.str_utf_pos()</a></span><br>
    Gets a list of the starting byte positions of each UTF-8 codepoint in the
    given string.

</div>
<div class="help-para">
    Embedded NUL bytes are treated as terminating the string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer[]</code>)

</div>
<div class="help-para">
vim.str_utf_start(<code>{str}</code>, <code>{index}</code>)                        <span id="vim.str_utf_start()" class="help-tag-right"><a href="#vim.str_utf_start()">vim.str_utf_start()</a></span><br>
    Gets the distance (in bytes) from the starting byte of the codepoint
    (character) that <code>{index}</code> points to.

</div>
<div class="help-para">
    The result can be added to <code>{index}</code> to get the starting byte of a
    character.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- The character 'æ' is stored as the bytes '\xc3\xa6' (using UTF-8)
-- Returns 0 because the index is pointing at the first byte of a character
vim.str_utf_start('æ', 1)
-- Returns -1 because the index is pointing at the second byte of a character
vim.str_utf_start('æ', 2)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>    (<code>string</code>)
</div><div class="help-li" style=""> <code>{index}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>)

</div>
<div class="help-para">
vim.stricmp(<code>{a}</code>, <code>{b}</code>)                                          <span id="vim.stricmp()" class="help-tag-right"><a href="#vim.stricmp()">vim.stricmp()</a></span><br>
    Compares strings case-insensitively.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{a}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{b}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>0|1|-1</code>) if strings are equal, <code>{a}</code> is greater than <code>{b}</code> or <code>{a}</code> is
        lesser than <code>{b}</code>, respectively.

</div>
<div class="help-para">
vim.ui_attach(<code>{ns}</code>, <code>{opts}</code>, <code>{callback}</code>)                      <span id="vim.ui_attach()" class="help-tag-right"><a href="#vim.ui_attach()">vim.ui_attach()</a></span><br>
<b>    WARNING:</b> This feature is experimental/unstable.

</div>
<div class="help-para">
    Subscribe to <a href="api-ui-events.html#ui-events">ui-events</a>, similar to <a href="api.html#nvim_ui_attach()">nvim_ui_attach()</a> but receive events
    in a Lua callback. Used to implement screen elements like popupmenu or
    message handling in Lua.

</div>
<div class="help-para">
    <code>{callback}</code> receives event name plus additional parameters. See
    <a href="api-ui-events.html#ui-popupmenu">ui-popupmenu</a> and the sections below for event format for respective
    events.

</div>
<div class="help-para">
    Callbacks for <code>msg_show</code> events originating from internal messages (as
    opposed to events from commands or API calls) are executed in <a href="api.html#api-fast">api-fast</a>
    context; showing the message needs to be scheduled.

</div>
<div class="help-para">
    Excessive errors inside the callback will result in forced detachment.

</div>
<div class="help-para">
<b>    WARNING:</b> This api is considered experimental. Usability will vary for
    different screen elements. In particular <code>ext_messages</code> behavior is
    subject to further changes and usability improvements. This is expected to
    be used to handle messages when setting <a href="options.html#'cmdheight'">'cmdheight'</a> to zero (which is
    likewise experimental).

</div>
<div class="help-para">
    Example (stub for a <a href="api-ui-events.html#ui-popupmenu">ui-popupmenu</a> implementation):<pre><code class="language-lua">ns = vim.api.nvim_create_namespace('my_fancy_pum')
vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)
  if event == 'popupmenu_show' then
    local items, selected, row, col, grid = ...
    print('display pum ', #items)
  elseif event == 'popupmenu_select' then
    local selected = ...
    print('selected', selected)
  elseif event == 'popupmenu_hide' then
    print('FIN')
  end
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{ns}</code>        (<code>integer</code>) Namespace ID
</div><div class="help-li" style=""> <code>{opts}</code>      (<code>table&lt;string, any&gt;</code>) Optional parameters.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ext_…}?</code> (<code>boolean</code>) Any of <a href="api-ui-events.html#ui-ext-options">ui-ext-options</a>, if true
                      enable events for the respective UI element.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{set_cmdheight}?</code> (<code>boolean</code>) If false, avoid setting
                      <a href="options.html#'cmdheight'">'cmdheight'</a> to 0 when <code>ext_messages</code> is enabled.
</div><div class="help-li" style=""> <code>{callback}</code>  (<code>fun(event: string, ...): any</code>) Function called for each
                    UI event. A truthy return value signals to Nvim that the
                    event is handled, in which case it is not propagated to
                    remote UIs.
</div>
</div>
<div class="help-para">
vim.ui_detach(<code>{ns}</code>)                                          <span id="vim.ui_detach()" class="help-tag-right"><a href="#vim.ui_detach()">vim.ui_detach()</a></span><br>
    Detach a callback previously attached with <a href="lua.html#vim.ui_attach()">vim.ui_attach()</a> for the given
    namespace <code>{ns}</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{ns}</code>  (<code>integer</code>) Namespace ID
</div>
</div>
<div class="help-para">
vim.wait(<code>{time}</code>, <code>{callback}</code>, <code>{interval}</code>, <code>{fast_only}</code>)             <span id="vim.wait()" class="help-tag-right"><a href="#vim.wait()">vim.wait()</a></span><br>
    Waits up to <code>time</code> milliseconds, until <code>callback</code> returns <code>true</code>
    (success). Executes <code>callback</code> immediately, then on user events, internal
    events, and approximately every <code>interval</code> milliseconds (default 200).
    Returns all <code>callback</code> results on success.

</div>
<div class="help-para">
    Nvim processes other events while waiting. Cannot be called during an
    <a href="api.html#api-fast">api-fast</a> event.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Wait for 100 ms, allowing other events to process.
vim.wait(100)
-- Wait up to 1000 ms or until `vim.g.foo` is true, at intervals of ~500 ms.
vim.wait(1000, function() return vim.g.foo end, 500)
-- Wait indefinitely until `vim.g.foo` is true, and get the callback results.
local ok, rv1, rv2, rv3 = vim.wait(math.huge, function()
  return vim.g.foo, 'a', 42, { ok = { 'yes' } }
end)
-- Schedule a function to set a value in 100ms. This would wait 10s if blocked, but actually
-- only waits 100ms because `vim.wait` processes other events while waiting.
vim.defer_fn(function() vim.g.timer_result = true end, 100)
if vim.wait(10000, function() return vim.g.timer_result end) then
  print('Only waiting a little bit of time!')
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{time}</code>       (<code>number</code>) Number of milliseconds to wait. Must be
                     non-negative number, any fractional part is truncated.
</div><div class="help-li" style=""> <code>{callback}</code>   (<code>fun(): boolean, ...?</code>) Optional callback. Waits until
                     <code>{callback}</code> returns true
</div><div class="help-li" style=""> <code>{interval}</code>   (<code>integer?</code>) (Approximate) number of milliseconds to wait
                     between polls
</div><div class="help-li" style=""> <code>{fast_only}</code>  (<code>boolean?</code>) If true, only <a href="api.html#api-fast">api-fast</a> events will be
                     processed.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>boolean</code>)
        (<code>-1|-2?</code>)
<div class="help-li" style=""> If callback returns <code>true</code> before timeout: <code>true, nil, ...</code>
</div><div class="help-li" style=""> On timeout: <code>false, -1</code>
</div><div class="help-li" style=""> On interrupt: <code>false, -2</code>
</div><div class="help-li" style=""> On error: the error is raised.
</div>
</div>
<div class="help-para">
<h2 id="_lua-vimscript-bridge" class="help-heading">LUA-VIMSCRIPT BRIDGE<span class="help-heading-tags">                                           <span id="lua-vimscript" class="help-tag"><a href="#lua-vimscript">lua-vimscript</a></span></h2>


</div>
<div class="help-para">
Nvim Lua provides an interface or "bridge" to Vimscript variables and
functions, and editor commands and options.

</div>
<div class="help-para">
Objects passed over this bridge are COPIED (marshalled): there are no
"references". <a href="lua-guide.html#lua-guide-variables">lua-guide-variables</a> For example, using <code>vim.fn.remove()</code> on a
Lua list copies the list object to Vimscript and does NOT modify the Lua list:<pre><code class="language-lua">local list = { 1, 2, 3 }
vim.fn.remove(list, 0)
vim.print(list)  --&gt; "{ 1, 2, 3 }"</code></pre>

</div>
<div class="help-para">
vim.call(<code>{func}</code>, <code>{...}</code>)                                           <span id="vim.call()" class="help-tag-right"><a href="#vim.call()">vim.call()</a></span><br>
    Invokes <a href="vimeval.html#vim-function">vim-function</a> or <a href="vimeval.html#user-function">user-function</a> <code>{func}</code> with arguments <code>{...}</code>.
    See also <a href="lua.html#vim.fn">vim.fn</a>.
    Equivalent to:<pre><code class="language-lua">vim.fn[func]({...})</code></pre>

</div>
<div class="help-para">
vim.cmd(<code>{command}</code>)
    See <a href="lua.html#vim.cmd()">vim.cmd()</a>.

</div>
<div class="help-para">
vim.fn.<code>{func}</code>(<code>{...}</code>)                                                  <span id="vim.fn" class="help-tag-right"><a href="#vim.fn">vim.fn</a></span><br>
    Invokes <a href="vimeval.html#vim-function">vim-function</a> or <a href="vimeval.html#user-function">user-function</a> <code>{func}</code> with arguments <code>{...}</code>.
    To call autoload functions, use the syntax:<pre><code class="language-lua">vim.fn['some#function']({...})</code></pre>

</div>
<div class="help-para">
    Unlike vim.api.<a href="api.html#nvim_call_function()">nvim_call_function()</a> this converts directly between Vim
    objects and Lua objects. If the Vim function returns a float, it will be
    represented directly as a Lua number. Empty lists and dictionaries both
    are represented by an empty table.

</div>
<div class="help-para">
<b>    Note:</b> <a href="vvars.html#v%3Anull">v:null</a> values as part of the return value is represented as
    <a href="lua.html#vim.NIL">vim.NIL</a> special value

</div>
<div class="help-para">
<b>    Note:</b> vim.fn keys are generated lazily, thus <code>pairs(vim.fn)</code> only
    enumerates functions that were called at least once.

</div>
<div class="help-para">
<b>    Note:</b> The majority of functions cannot run in <a href="api.html#api-fast">api-fast</a> callbacks with some
    undocumented exceptions which are allowed.

</div>
<div class="help-para">
                                                           <span id="lua-vim-variables" class="help-tag-right"><a href="#lua-vim-variables">lua-vim-variables</a></span><br>
The Vim editor global dictionaries <a href="vimeval.html#g%3A">g:</a> <a href="vimeval.html#w%3A">w:</a> <a href="vimeval.html#b%3A">b:</a> <a href="vimeval.html#t%3A">t:</a> <a href="vimeval.html#v%3A">v:</a> can be accessed
from Lua conveniently and idiomatically by referencing the <code>vim.*</code> Lua tables
described below. In this way you can easily read and modify global Vimscript
variables from Lua.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">vim.g.foo = 5     -- Set the g:foo Vimscript variable.
print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.
vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.
vim.b[2].foo = 6  -- Set b:foo for buffer 2</code></pre>

</div>
<div class="help-para">
Note that setting dictionary fields directly will not write them back into
Nvim. This is because the index into the namespace simply returns a copy.
Instead the whole dictionary must be written as one. This can be achieved by
creating a short-lived temporary.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">vim.g.my_dict.field1 = 'value'  -- Does not work
local my_dict = vim.g.my_dict   --
my_dict.field1 = 'value'        -- Instead do
vim.g.my_dict = my_dict         --</code></pre>
vim.g                                                                  <span id="vim.g" class="help-tag-right"><a href="#vim.g">vim.g</a></span><br>
    Global (<a href="vimeval.html#g%3A">g:</a>) editor variables.
    Key with no value returns <code>nil</code>.

</div>
<div class="help-para">
vim.b                                                                  <span id="vim.b" class="help-tag-right"><a href="#vim.b">vim.b</a></span><br>
    Buffer-scoped (<a href="vimeval.html#b%3A">b:</a>) variables for the current buffer.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific buffer.

</div>
<div class="help-para">
vim.w                                                                  <span id="vim.w" class="help-tag-right"><a href="#vim.w">vim.w</a></span><br>
    Window-scoped (<a href="vimeval.html#w%3A">w:</a>) variables for the current window.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific window.

</div>
<div class="help-para">
vim.t                                                                  <span id="vim.t" class="help-tag-right"><a href="#vim.t">vim.t</a></span><br>
    Tabpage-scoped (<a href="vimeval.html#t%3A">t:</a>) variables for the current tabpage.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific tabpage.

</div>
<div class="help-para">
vim.v                                                                  <span id="vim.v" class="help-tag-right"><a href="#vim.v">vim.v</a></span><br>
    <a href="vimeval.html#v%3A">v:</a> variables.
    Invalid or unset key returns <code>nil</code>.

</div>
<div class="help-para">
                                                                 <span id="lua-options" class="help-tag-right"><a href="#lua-options">lua-options</a></span><br>
                                                             <span id="lua-vim-options" class="help-tag-right"><a href="#lua-vim-options">lua-vim-options</a></span><br>
                                                                 <span id="lua-vim-set" class="help-tag-right"><a href="#lua-vim-set">lua-vim-set</a></span><br>
                                                            <span id="lua-vim-setlocal" class="help-tag-right"><a href="#lua-vim-setlocal">lua-vim-setlocal</a></span><br>

</div>
<div class="help-para">
Vim options can be accessed through <a href="lua.html#vim.o">vim.o</a>, which behaves like Vimscript
<a href="options.html#%3Aset">:set</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Examples:</div>

</div>
<div class="help-para">
    To set a boolean toggle:
        Vimscript: <code>set number</code>
        Lua:       <code>vim.o.number = true</code>

</div>
<div class="help-para">
    To set a string value:
        Vimscript: <code>set wildignore=*.o,*.a,__pycache__</code>
        Lua:       <code>vim.o.wildignore = '*.o,*.a,__pycache__'</code>

</div>
<div class="help-para">
Similarly, there is <a href="lua.html#vim.bo">vim.bo</a> and <a href="lua.html#vim.wo">vim.wo</a> for setting buffer-scoped and
window-scoped options. Note that this must NOT be confused with
<a href="options.html#local-options">local-options</a> and <a href="options.html#%3Asetlocal">:setlocal</a>. There is also <a href="lua.html#vim.go">vim.go</a> that only accesses the
global value of a <a href="options.html#global-local">global-local</a> option, see <a href="options.html#%3Asetglobal">:setglobal</a>.

</div>
<div class="help-para">
                                                               <span id="vim.opt_local" class="help-tag-right"><a href="#vim.opt_local">vim.opt_local</a></span><br>
                                                              <span id="vim.opt_global" class="help-tag-right"><a href="#vim.opt_global">vim.opt_global</a></span><br>
                                                                     <span id="vim.opt" class="help-tag-right"><a href="#vim.opt">vim.opt</a></span><br>

</div>
<div class="help-para">
A special interface <a href="lua.html#vim.opt">vim.opt</a> exists for conveniently interacting with list-
and map-style options from Lua: It allows accessing them as Lua tables and
offers object-oriented method for adding and removing entries.

</div>
<div class="help-para">
<div class="help-column_heading">Examples:</div>

</div>
<div class="help-para">
    The following methods of setting a list-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">set wildignore=*.o,*.a,__pycache__</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">vim.o.wildignore = '*.o,*.a,__pycache__'</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset%2B%3D">:set+=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:append { "*.pyc", "node_modules" }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset%5E%3D">:set^=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:prepend { "new_first_value" }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset-%3D">:set-=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:remove { "node_modules" }</code></pre>

</div>
<div class="help-para">
    The following methods of setting a map-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">set listchars=space:_,tab:&gt;~</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">vim.o.listchars = 'space:_,tab:&gt;~'</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.opt.listchars = { space = '_', tab = '&gt;~' }</code></pre>

</div>
<div class="help-para">
Note that <a href="lua.html#vim.opt">vim.opt</a> returns an <code>Option</code> object, not the value of the option,
which is accessed through <a href="lua.html#vim.opt%3Aget()">vim.opt:get()</a>:

</div>
<div class="help-para">
<div class="help-column_heading">Examples:</div>

</div>
<div class="help-para">
    The following methods of getting a list-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">echo wildignore</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">print(vim.o.wildignore)</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.print(vim.opt.wildignore:get())</code></pre>

</div>
<div class="help-para">
In any of the above examples, to replicate the behavior <a href="options.html#%3Asetlocal">:setlocal</a>, use
<code>vim.opt_local</code>. Additionally, to replicate the behavior of <a href="options.html#%3Asetglobal">:setglobal</a>, use
<code>vim.opt_global</code>.

</div>
<div class="help-para">
Option:append(<code>{value}</code>)                                      <span id="vim.opt%3Aappend()" class="help-tag-right"><a href="#vim.opt%3Aappend()">vim.opt:append()</a></span><br>
    Append a value to string-style options. See <a href="options.html#%3Aset%2B%3D">:set+=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.formatoptions:append('j')
vim.opt.formatoptions = vim.opt.formatoptions + 'j'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{value}</code>  (<code>string</code>) Value to append
</div>
</div>
<div class="help-para">
Option:get()                                                   <span id="vim.opt%3Aget()" class="help-tag-right"><a href="#vim.opt%3Aget()">vim.opt:get()</a></span><br>
    Returns a Lua-representation of the option. Boolean, number and string
    values will be returned in exactly the same fashion.

</div>
<div class="help-para">
    For values that are comma-separated lists, an array will be returned with
    the values as entries in the array:<pre><code class="language-lua">vim.cmd [[set wildignore=*.pyc,*.o]]
vim.print(vim.opt.wildignore:get())
-- { "*.pyc", "*.o", }
for _, ignore_pattern in ipairs(vim.opt.wildignore:get()) do
    print("Will ignore:", ignore_pattern)
end
-- Will ignore: *.pyc
-- Will ignore: *.o</code></pre>

</div>
<div class="help-para">
    For values that are comma-separated maps, a table will be returned with
    the names as keys and the values as entries:<pre><code class="language-lua">vim.cmd [[set listchars=space:_,tab:&gt;~]]
vim.print(vim.opt.listchars:get())
--  { space = "_", tab = "&gt;~", }
for char, representation in pairs(vim.opt.listchars:get()) do
    print(char, "=&gt;", representation)
end</code></pre>

</div>
<div class="help-para">
    For values that are lists of flags, a set will be returned with the flags
    as keys and <code>true</code> as entries.<pre><code class="language-lua">vim.cmd [[set formatoptions=njtcroql]]
vim.print(vim.opt.formatoptions:get())
-- { n = true, j = true, c = true, ... }
local format_opts = vim.opt.formatoptions:get()
if format_opts.j then
    print("J is enabled!")
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string|integer|boolean?</code>) value of option

</div>
<div class="help-para">
Option:prepend(<code>{value}</code>)                                    <span id="vim.opt%3Aprepend()" class="help-tag-right"><a href="#vim.opt%3Aprepend()">vim.opt:prepend()</a></span><br>
    Prepend a value to string-style options. See <a href="options.html#%3Aset%5E%3D">:set^=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.wildignore:prepend('*.o')
vim.opt.wildignore = vim.opt.wildignore ^ '*.o'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{value}</code>  (<code>string</code>) Value to prepend
</div>
</div>
<div class="help-para">
Option:remove(<code>{value}</code>)                                      <span id="vim.opt%3Aremove()" class="help-tag-right"><a href="#vim.opt%3Aremove()">vim.opt:remove()</a></span><br>
    Remove a value from string-style options. See <a href="options.html#%3Aset-%3D">:set-=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.wildignore:remove('*.pyc')
vim.opt.wildignore = vim.opt.wildignore - '*.pyc'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{value}</code>  (<code>string</code>) Value to remove
</div>
</div>
<div class="help-para">
vim.bo[<code>{bufnr}</code>]                                                       <span id="vim.bo" class="help-tag-right"><a href="#vim.bo">vim.bo</a></span><br>
    Get or set buffer-scoped <a href="options.html#options">options</a> for the buffer with number <code>{bufnr}</code>.
    Like <code>:setlocal</code>. If <code>{bufnr}</code> is omitted then the current buffer is used.
    Invalid <code>{bufnr}</code> or key is an error.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local bufnr = vim.api.nvim_get_current_buf()
vim.bo[bufnr].buflisted = true    -- same as vim.bo.buflisted = true
print(vim.bo.comments)
print(vim.bo.baz)                 -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.env                                                              <span id="vim.env" class="help-tag-right"><a href="#vim.env">vim.env</a></span><br>
    Environment variables defined in the editor session. See <a href="options.html#expand-env">expand-env</a> and
    <a href="vimeval.html#%3Alet-environment">:let-environment</a> for the Vimscript behavior. Invalid or unset key
    returns <code>nil</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.env.FOO = 'bar'
print(vim.env.TERM)</code></pre>

</div>
<div class="help-para">
vim.go                                                                <span id="vim.go" class="help-tag-right"><a href="#vim.go">vim.go</a></span><br>
    Get or set global <a href="options.html#options">options</a>. Like <code>:setglobal</code>. Invalid key is an error.

</div>
<div class="help-para">
<b>    Note:</b> this is different from <a href="lua.html#vim.o">vim.o</a> because this accesses the global
    option value and thus is mostly useful for use with <a href="options.html#global-local">global-local</a>
    options.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.go.cmdheight = 4
print(vim.go.columns)
print(vim.go.bar)     -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.o                                                                  <span id="vim.o" class="help-tag-right"><a href="#vim.o">vim.o</a></span><br>
    Get or set <a href="options.html#options">options</a>. Works like <code>:set</code>, so buffer/window-scoped options
    target the current buffer/window. Invalid key is an error.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.o.cmdheight = 4
print(vim.o.columns)
print(vim.o.foo)     -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.wo[<code>{winid}</code>][<code>{bufnr}</code>]                                              <span id="vim.wo" class="help-tag-right"><a href="#vim.wo">vim.wo</a></span><br>
    Get or set window-scoped <a href="options.html#options">options</a> for the window with handle <code>{winid}</code> and
    buffer with number <code>{bufnr}</code>. Like <code>:setlocal</code> if setting a <a href="options.html#global-local">global-local</a>
    option or if <code>{bufnr}</code> is provided, like <code>:set</code> otherwise. If <code>{winid}</code> is
    omitted then the current window is used. Invalid <code>{winid}</code>, <code>{bufnr}</code> or key
    is an error.

</div>
<div class="help-para">
<b>    Note:</b> only <code>{bufnr}</code> with value <code>0</code> (the current buffer in the window) is
    supported.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local winid = vim.api.nvim_get_current_win()
vim.wo[winid].number = true    -- same as vim.wo.number = true
print(vim.wo.foldmarker)
print(vim.wo.quux)             -- error: invalid key
vim.wo[winid][0].spell = false -- like ':setlocal nospell'</code></pre>

</div>
<div class="help-para">
<h2 id="_lua-module:-vim" class="help-heading">Lua module: vim<span class="help-heading-tags">                                                      <span id="lua-vim" class="help-tag"><a href="#lua-vim">lua-vim</a></span></h2>


</div>
<div class="help-para">
vim.cmd(<code>{command}</code>)                                                 <span id="vim.cmd()" class="help-tag-right"><a href="#vim.cmd()">vim.cmd()</a></span><br>
    Executes Vimscript (<a href="vimindex.html#Ex-commands">Ex-commands</a>).

</div>
<div class="help-para">
    Can be indexed with a command name to get a function, thus you can write
    <code>vim.cmd.echo(…)</code> instead of <code>vim.cmd{cmd='echo',…}</code>.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Single command:
vim.cmd('echo 42')
-- Multiline script:
vim.cmd([[
  augroup my.group
    autocmd!
    autocmd FileType c setlocal cindent
  augroup END
]])
-- Ex command :echo "foo". Note: string literals must be double-quoted.
vim.cmd('echo "foo"')
vim.cmd { cmd = 'echo', args = { '"foo"' } }
vim.cmd.echo({ args = { '"foo"' } })
vim.cmd.echo('"foo"')
-- Ex command :write! myfile.txt
vim.cmd('write! myfile.txt')
vim.cmd { cmd = 'write', args = { 'myfile.txt' }, bang = true }
vim.cmd.write { args = { 'myfile.txt' }, bang = true }
vim.cmd.write { 'myfile.txt', bang = true }
-- Ex command :vertical resize +2
vim.cmd.resize({ '+2', mods = { vertical = true } })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{command}</code>  (<code>string|table</code>) Command(s) to execute.
</div><div class="help-li" style="margin-left: 3rem;"> The string form supports multiline Vimscript (alias to
                     <a href="api.html#nvim_exec2()">nvim_exec2()</a>, behaves like <a href="repeat.html#%3Asource">:source</a>).
</div><div class="help-li" style="margin-left: 3rem;"> The table form executes a single command (alias to
                     <a href="api.html#nvim_cmd()">nvim_cmd()</a>).
</div>
</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="vimindex.html#ex-cmd-index">ex-cmd-index</a>
</div>
</div>
<div class="help-para">
vim.defer_fn(<code>{fn}</code>, <code>{timeout}</code>)                                 <span id="vim.defer_fn()" class="help-tag-right"><a href="#vim.defer_fn()">vim.defer_fn()</a></span><br>
    Defers calling <code>{fn}</code> until <code>{timeout}</code> ms passes.

</div>
<div class="help-para">
    Use to do a one-shot timer that calls <code>{fn}</code><b> Note:</b> The <code>{fn}</code> is
    <a href="lua.html#vim.schedule()">vim.schedule()</a>d automatically, so API functions are safe to call.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>       (<code>function</code>) Callback to call once <code>timeout</code> expires
</div><div class="help-li" style=""> <code>{timeout}</code>  (<code>integer</code>) Number of milliseconds to wait before calling
                   <code>fn</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>uv.uv_timer_t</code>) timer luv timer object

</div>
<div class="help-para">
                                                             <span id="vim.deprecate()" class="help-tag-right"><a href="#vim.deprecate()">vim.deprecate()</a></span><br>
vim.deprecate(<code>{name}</code>, <code>{alternative}</code>, <code>{version}</code>, <code>{plugin}</code>, <code>{backtrace}</code>)
    Shows a deprecation message to the user.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{name}</code>         (<code>string</code>)<b> Deprecated</b> feature (function, API, etc.).
</div><div class="help-li" style=""> <code>{alternative}</code>  (<code>string?</code>) Suggested alternative feature.
</div><div class="help-li" style=""> <code>{version}</code>      (<code>string</code>) Version when the deprecated function will be
                       removed.
</div><div class="help-li" style=""> <code>{plugin}</code>       (<code>string?</code>) Name of the plugin that owns the deprecated
                       feature. Defaults to "Nvim".
</div><div class="help-li" style=""> <code>{backtrace}</code>    (<code>boolean?</code>) Prints backtrace. Defaults to true.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>)<b> Deprecated</b> message, or nil if no message was shown.

</div>
<div class="help-para">
vim.inspect()                                                  <span id="vim.inspect()" class="help-tag-right"><a href="#vim.inspect()">vim.inspect()</a></span><br>
    Gets a human-readable representation of the given object.

</div>
<div class="help-para">
<div class="help-column_heading">Overloads:</div>
<div class="help-li" style=""> <code>fun(x: any, opts?: vim.inspect.Opts): string</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.print()">vim.print()</a>
</div><div class="help-li" style=""> <a href="https://github.com/kikito/inspect.lua">https://github.com/kikito/inspect.lua</a>
</div><div class="help-li" style=""> <a href="https://github.com/mpeterv/vinspect">https://github.com/mpeterv/vinspect</a>
</div>
</div>
<div class="help-para">
vim.keycode(<code>{str}</code>)                                             <span id="vim.keycode()" class="help-tag-right"><a href="#vim.keycode()">vim.keycode()</a></span><br>
    Translates keycodes.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local k = vim.keycode
vim.g.mapleader = k'&lt;bs&gt;'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) String to be converted.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="api.html#nvim_replace_termcodes()">nvim_replace_termcodes()</a>
</div>
</div>
<div class="help-para">
vim.lua_omnifunc(<code>{find_start}</code>)                            <span id="vim.lua_omnifunc()" class="help-tag-right"><a href="#vim.lua_omnifunc()">vim.lua_omnifunc()</a></span><br>
    Omnifunc for completing Lua values from the runtime Lua interpreter,
    similar to the builtin completion for the <code>:lua</code> command.

</div>
<div class="help-para">
    Activate using <code>set omnifunc=v:lua.vim.lua_omnifunc</code> in a Lua buffer.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{find_start}</code>  (<code>1|0</code>)
</div>
</div>
<div class="help-para">
vim.notify(<code>{msg}</code>, <code>{level}</code>, <code>{opts}</code>)                              <span id="vim.notify()" class="help-tag-right"><a href="#vim.notify()">vim.notify()</a></span><br>
    Displays a notification to the user.

</div>
<div class="help-para">
    This function can be overridden by plugins to display notifications using
    a custom provider (such as the system notification provider). By default,
    writes to <a href="message.html#%3Amessages">:messages</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{msg}</code>    (<code>string</code>) Content of the notification to show to the user.
</div><div class="help-li" style=""> <code>{level}</code>  (<code>integer?</code>) One of the values from <a href="lua.html#vim.log.levels">vim.log.levels</a>.
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Optional parameters. Unused by default.
</div>
</div>
<div class="help-para">
vim.notify_once(<code>{msg}</code>, <code>{level}</code>, <code>{opts}</code>)                    <span id="vim.notify_once()" class="help-tag-right"><a href="#vim.notify_once()">vim.notify_once()</a></span><br>
    Displays a notification only one time.

</div>
<div class="help-para">
    Like <a href="lua.html#vim.notify()">vim.notify()</a>, but subsequent calls with the same message will not
    display a notification.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{msg}</code>    (<code>string</code>) Content of the notification to show to the user.
</div><div class="help-li" style=""> <code>{level}</code>  (<code>integer?</code>) One of the values from <a href="lua.html#vim.log.levels">vim.log.levels</a>.
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Optional parameters. Unused by default.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) true if message was displayed, else false

</div>
<div class="help-para">
vim.on_key(<code>{fn}</code>, <code>{ns_id}</code>, <code>{opts}</code>)                               <span id="vim.on_key()" class="help-tag-right"><a href="#vim.on_key()">vim.on_key()</a></span><br>
    Adds Lua function <code>{fn}</code> with namespace id <code>{ns_id}</code> as a listener to every,
    yes every, input key.

</div>
<div class="help-para">
    The Nvim command-line option <a href="starting.html#-w">-w</a> is related but does not support
    callbacks and cannot be toggled dynamically.

</div>
<div class="help-para">
<div class="help-column_heading"><b>    Note:</b></div>
<div class="help-li" style=""> <code>{fn}</code> will be removed on error.
</div><div class="help-li" style=""> <code>{fn}</code> won't be invoked recursively, i.e. if <code>{fn}</code> itself consumes input,
        it won't be invoked for those keys.
</div><div class="help-li" style=""> <code>{fn}</code> will not be cleared by <a href="api.html#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</a>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>     (<code>fun(key: string, typed: string): string??</code>) Function
                 invoked for every input key, after mappings have been applied
                 but before further processing. Arguments <code>{key}</code> and <code>{typed}</code>
                 are raw keycodes, where <code>{key}</code> is the key after mappings are
                 applied, and <code>{typed}</code> is the key(s) before mappings are
                 applied. <code>{typed}</code> may be empty if <code>{key}</code> is produced by
                 non-typed key(s) or by the same typed key(s) that produced a
                 previous <code>{key}</code>. If <code>{fn}</code> returns an empty string, <code>{key}</code> is
                 discarded/ignored, and if <code>{key}</code> is <code>&lt;Cmd&gt;</code> then the
                 "&lt;Cmd&gt;…&lt;CR&gt;" sequence is discarded as a whole. When <code>{fn}</code> is
                 <code>nil</code>, the callback associated with namespace <code>{ns_id}</code> is
                 removed.
</div><div class="help-li" style=""> <code>{ns_id}</code>  (<code>integer?</code>) Namespace ID. If nil or 0, generates and returns
                 a new <a href="api.html#nvim_create_namespace()">nvim_create_namespace()</a> id.
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Optional parameters
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>) Namespace id associated with <code>{fn}</code>. Or count of all
        callbacks if on_key() is called without arguments.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="vimfn.html#keytrans()">keytrans()</a>
</div>
</div>
<div class="help-para">
vim.paste(<code>{lines}</code>, <code>{phase}</code>)                                      <span id="vim.paste()" class="help-tag-right"><a href="#vim.paste()">vim.paste()</a></span><br>
    Paste handler, invoked by <a href="api.html#nvim_paste()">nvim_paste()</a>.

</div>
<div class="help-para">
<b>    Note:</b> This is provided only as a "hook", don't call it directly; call
    <a href="api.html#nvim_paste()">nvim_paste()</a> instead, which arranges redo (dot-repeat) and invokes
    <code>vim.paste</code>.

</div>
<div class="help-para">
    Example: To remove ANSI color codes when pasting:<pre><code class="language-lua">vim.paste = (function(overridden)
  return function(lines, phase)
    for i,line in ipairs(lines) do
      -- Scrub ANSI color codes from paste input.
      lines[i] = line:gsub('\27%[[0-9;mK]+', '')
    end
    return overridden(lines, phase)
  end
end)(vim.paste)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{lines}</code>  (<code>string[]</code>) <a href="vimfn.html#readfile()">readfile()</a>-style list of lines to paste.
                 <a href="channel.html#channel-lines">channel-lines</a>
</div><div class="help-li" style=""> <code>{phase}</code>  (<code>-1|1|2|3</code>) -1: "non-streaming" paste: the call contains all
                 lines. If paste is "streamed", <code>phase</code> indicates the stream
                 state:
</div><div class="help-li" style="margin-left: 3rem;"> 1: starts the paste (exactly once)
</div><div class="help-li" style="margin-left: 3rem;"> 2: continues the paste (zero or more times)
</div><div class="help-li" style="margin-left: 3rem;"> 3: ends the paste (exactly once)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) result false if client should cancel the paste.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="provider.html#paste">paste</a>
</div>
</div>
<div class="help-para">
vim.print(<code>{...}</code>)                                                 <span id="vim.print()" class="help-tag-right"><a href="#vim.print()">vim.print()</a></span><br>
    "Pretty prints" the given arguments and returns them unmodified.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local hl_normal = vim.print(vim.api.nvim_get_hl(0, { name = 'Normal' }))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{...}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>) given arguments.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.inspect()">vim.inspect()</a>
</div><div class="help-li" style=""> <a href="various.html#%3A%3D">:=</a>
</div>
</div>
<div class="help-para">
vim.schedule_wrap(<code>{fn}</code>)                                  <span id="vim.schedule_wrap()" class="help-tag-right"><a href="#vim.schedule_wrap()">vim.schedule_wrap()</a></span><br>
    Returns a function which calls <code>{fn}</code> via <a href="lua.html#vim.schedule()">vim.schedule()</a>.

</div>
<div class="help-para">
    The returned function passes all arguments to <code>{fn}</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">function notify_readable(_err, readable)
  vim.notify("readable? " .. tostring(readable))
end
vim.uv.fs_access(vim.fn.stdpath("config"), "R", vim.schedule_wrap(notify_readable))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>  (<code>function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>function</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.schedule()">vim.schedule()</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.in_fast_event()">vim.in_fast_event()</a>
</div>
</div>
<div class="help-para">
                                                         <span id="vim.str_byteindex()" class="help-tag-right"><a href="#vim.str_byteindex()">vim.str_byteindex()</a></span><br>
vim.str_byteindex(<code>{s}</code>, <code>{encoding}</code>, <code>{index}</code>, <code>{strict_indexing}</code>)
    Convert UTF-32, UTF-16 or UTF-8 <code>{index}</code> to byte index. If
    <code>{strict_indexing}</code> is false then an out of range index will return byte
    length instead of throwing an error.

</div>
<div class="help-para">
    Invalid UTF-8 and NUL is treated like in <a href="lua.html#vim.str_utfindex()">vim.str_utfindex()</a>. An <code>{index}</code>
    in the middle of a UTF-16 sequence is rounded upwards to the end of that
    sequence.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>                (<code>string</code>)
</div><div class="help-li" style=""> <code>{encoding}</code>         (<code>"utf-8"|"utf-16"|"utf-32"</code>)
</div><div class="help-li" style=""> <code>{index}</code>            (<code>integer</code>)
</div><div class="help-li" style=""> <code>{strict_indexing}</code>  (<code>boolean?</code>) default: true
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>)

</div>
<div class="help-para">
                                                          <span id="vim.str_utfindex()" class="help-tag-right"><a href="#vim.str_utfindex()">vim.str_utfindex()</a></span><br>
vim.str_utfindex(<code>{s}</code>, <code>{encoding}</code>, <code>{index}</code>, <code>{strict_indexing}</code>)
    Convert byte index to UTF-32, UTF-16 or UTF-8 indices. If <code>{index}</code> is not
    supplied, the length of the string is used. All indices are zero-based.

</div>
<div class="help-para">
    If <code>{strict_indexing}</code> is false then an out of range index will return
    string length instead of throwing an error. Invalid UTF-8 bytes, and
    embedded surrogates are counted as one code point each. An <code>{index}</code> in the
    middle of a UTF-8 sequence is rounded upwards to the end of that sequence.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>                (<code>string</code>)
</div><div class="help-li" style=""> <code>{encoding}</code>         (<code>"utf-8"|"utf-16"|"utf-32"</code>)
</div><div class="help-li" style=""> <code>{index}</code>            (<code>integer?</code>)
</div><div class="help-li" style=""> <code>{strict_indexing}</code>  (<code>boolean?</code>) default: true
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.inspector" class="help-heading">Lua module: vim.inspector<span class="help-heading-tags">                                      <span id="vim.inspector" class="help-tag"><a href="#vim.inspector">vim.inspector</a></span></h2>


</div>
<div class="help-para">
vim.inspect_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>, <code>{filter}</code>)           <span id="vim.inspect_pos()" class="help-tag-right"><a href="#vim.inspect_pos()">vim.inspect_pos()</a></span><br>
    Get all the items at a given buffer position.

</div>
<div class="help-para">
    Can also be pretty-printed with <code>:Inspect!</code>.                   <span id="%3AInspect%21" class="help-tag-right"><a href="#%3AInspect%21">:Inspect!</a></span><br>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>   (<code>integer?</code>) defaults to the current buffer
</div><div class="help-li" style=""> <code>{row}</code>     (<code>integer?</code>) row to inspect, 0-based. Defaults to the row of
                  the current cursor
</div><div class="help-li" style=""> <code>{col}</code>     (<code>integer?</code>) col to inspect, 0-based. Defaults to the col of
                  the current cursor
</div><div class="help-li" style=""> <code>{filter}</code>  (<code>table?</code>) Table with key-value pairs to filter the items
</div><div class="help-li" style="margin-left: 3rem;"> <code>{syntax}</code> (<code>boolean</code>, default: <code>true</code>) Include syntax based
                    highlight groups.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{treesitter}</code> (<code>boolean</code>, default: <code>true</code>) Include
                    treesitter based highlight groups.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{extmarks}</code> (<code>boolean|"all"</code>, default: true) Include
                    extmarks. When <code>all</code>, then extmarks without a <code>hl_group</code>
                    will also be included.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{semantic_tokens}</code> (<code>boolean</code>, default: true) Include
                    semantic token highlights.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) a table with the following key-value pairs. Items are in
        "traversal order":
<div class="help-li" style=""> treesitter: a list of treesitter captures
</div><div class="help-li" style=""> syntax: a list of syntax groups
</div><div class="help-li" style=""> semantic_tokens: a list of semantic tokens
</div><div class="help-li" style=""> extmarks: a list of extmarks
</div><div class="help-li" style=""> buffer: the buffer used to get the items
</div><div class="help-li" style=""> row: the row used to get the items
</div><div class="help-li" style=""> col: the col used to get the items
</div>
</div>
<div class="help-para">
vim.show_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>, <code>{filter}</code>)                 <span id="vim.show_pos()" class="help-tag-right"><a href="#vim.show_pos()">vim.show_pos()</a></span><br>
    Show all the items at a given buffer position.

</div>
<div class="help-para">
    Can also be shown with <code>:Inspect</code>.                              <span id="%3AInspect" class="help-tag-right"><a href="#%3AInspect">:Inspect</a></span><br>

</div>
<div class="help-para">
    Example: To bind this function to the vim-scriptease inspired <code>zS</code> in
    Normal mode:<pre><code class="language-lua">vim.keymap.set('n', 'zS', vim.show_pos)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>   (<code>integer?</code>) defaults to the current buffer
</div><div class="help-li" style=""> <code>{row}</code>     (<code>integer?</code>) row to inspect, 0-based. Defaults to the row of
                  the current cursor
</div><div class="help-li" style=""> <code>{col}</code>     (<code>integer?</code>) col to inspect, 0-based. Defaults to the col of
                  the current cursor
</div><div class="help-li" style=""> <code>{filter}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{syntax}</code> (<code>boolean</code>, default: <code>true</code>) Include syntax based
                    highlight groups.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{treesitter}</code> (<code>boolean</code>, default: <code>true</code>) Include
                    treesitter based highlight groups.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{extmarks}</code> (<code>boolean|"all"</code>, default: true) Include
                    extmarks. When <code>all</code>, then extmarks without a <code>hl_group</code>
                    will also be included.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{semantic_tokens}</code> (<code>boolean</code>, default: true) Include
                    semantic token highlights.
</div>
</div>
<div class="help-para">
<span id="vim.Ringbuf" class="help-tag"><a href="#vim.Ringbuf">vim.Ringbuf</a></span>

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{clear}</code>  (<code>fun()</code>) See <a href="lua.html#Ringbuf%3Aclear()">Ringbuf:clear()</a>.
</div><div class="help-li" style=""> <code>{push}</code>   (<code>fun(item: T)</code>) See <a href="lua.html#Ringbuf%3Apush()">Ringbuf:push()</a>.
</div><div class="help-li" style=""> <code>{pop}</code>    (<code>fun(): T?</code>) See <a href="lua.html#Ringbuf%3Apop()">Ringbuf:pop()</a>.
</div><div class="help-li" style=""> <code>{peek}</code>   (<code>fun(): T?</code>) See <a href="lua.html#Ringbuf%3Apeek()">Ringbuf:peek()</a>.
</div>
</div>
<div class="help-para">
Ringbuf:clear()                                              <span id="Ringbuf%3Aclear()" class="help-tag-right"><a href="#Ringbuf%3Aclear()">Ringbuf:clear()</a></span><br>
    Clear all items

</div>
<div class="help-para">
Ringbuf:peek()                                                <span id="Ringbuf%3Apeek()" class="help-tag-right"><a href="#Ringbuf%3Apeek()">Ringbuf:peek()</a></span><br>
    Returns the first unread item without removing it

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any?</code>)

</div>
<div class="help-para">
Ringbuf:pop()                                                  <span id="Ringbuf%3Apop()" class="help-tag-right"><a href="#Ringbuf%3Apop()">Ringbuf:pop()</a></span><br>
    Removes and returns the first unread item

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any?</code>)

</div>
<div class="help-para">
Ringbuf:push(<code>{item}</code>)                                          <span id="Ringbuf%3Apush()" class="help-tag-right"><a href="#Ringbuf%3Apush()">Ringbuf:push()</a></span><br>
    Adds an item, overriding the oldest item if the buffer is full.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{item}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
vim.deep_equal(<code>{a}</code>, <code>{b}</code>)                                    <span id="vim.deep_equal()" class="help-tag-right"><a href="#vim.deep_equal()">vim.deep_equal()</a></span><br>
    Deep compare values for equality

</div>
<div class="help-para">
    Tables are compared recursively unless they both provide the <code>eq</code>
    metamethod. All other types are compared using the equality <code>==</code> operator.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{a}</code>  (<code>any</code>) First value
</div><div class="help-li" style=""> <code>{b}</code>  (<code>any</code>) Second value
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if values are equals, else <code>false</code>

</div>
<div class="help-para">
vim.deepcopy(<code>{orig}</code>, <code>{noref}</code>)                                 <span id="vim.deepcopy()" class="help-tag-right"><a href="#vim.deepcopy()">vim.deepcopy()</a></span><br>
    Returns a deep copy of the given object. Non-table objects are copied as
    in a typical Lua assignment, whereas table objects are copied recursively.
    Functions are naively copied, so functions in the copied table point to
    the same functions as those in the input table. Userdata and threads are
    not copied and will throw an error.

</div>
<div class="help-para">
<b>    Note:</b> <code>noref=true</code> is much more performant on tables with unique table
    fields, while <code>noref=false</code> is more performant on tables that reuse table
    fields.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{orig}</code>   (<code>table</code>) Table to copy
</div><div class="help-li" style=""> <code>{noref}</code>  (<code>boolean?</code>) When <code>false</code> (default) a contained table is only
                 copied once and all references point to this single copy.
                 When <code>true</code> every occurrence of a table results in a new
                 copy. This also means that a cyclic reference can cause
                 <code>deepcopy()</code> to fail.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) Table of copied keys and (nested) values.

</div>
<div class="help-para">
vim.defaulttable(<code>{createfn}</code>)                              <span id="vim.defaulttable()" class="help-tag-right"><a href="#vim.defaulttable()">vim.defaulttable()</a></span><br>
    Creates a table whose missing keys are provided by <code>{createfn}</code> (like
    Python's "defaultdict").

</div>
<div class="help-para">
    If <code>{createfn}</code> is <code>nil</code> it defaults to defaulttable() itself, so accessing
    nested keys creates nested tables:<pre><code class="language-lua">local a = vim.defaulttable()
a.b.c = 1</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{createfn}</code>  (<code>fun(key:any):any?</code>) Provides the value for a missing
                    <code>key</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) Empty table with <code>__index</code> metamethod.

</div>
<div class="help-para">
vim.endswith(<code>{s}</code>, <code>{suffix}</code>)                                   <span id="vim.endswith()" class="help-tag-right"><a href="#vim.endswith()">vim.endswith()</a></span><br>
    Tests if <code>s</code> ends with <code>suffix</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>       (<code>string</code>) String
</div><div class="help-li" style=""> <code>{suffix}</code>  (<code>string</code>) Suffix to match
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>suffix</code> is a suffix of <code>s</code>

</div>
<div class="help-para">
vim.gsplit(<code>{s}</code>, <code>{sep}</code>, <code>{opts}</code>)                                  <span id="vim.gsplit()" class="help-tag-right"><a href="#vim.gsplit()">vim.gsplit()</a></span><br>
    Gets an <a href="lua.html#iterator">iterator</a> that splits a string at each instance of a separator,
    in "lazy" fashion (as opposed to <a href="lua.html#vim.split()">vim.split()</a> which is "eager").

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">for s in vim.gsplit(':aa::b:', ':', {plain=true}) do
  print(s)
end</code></pre>

</div>
<div class="help-para">
    If you want to also inspect the separator itself (instead of discarding
    it), use <a href="luaref.html#string.gmatch()">string.gmatch()</a>. Example:<pre><code class="language-lua">for word, num in ('foo111bar222'):gmatch('([^0-9]*)(%d*)') do
  print(('word: %s num: %s'):format(word, num))
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>     (<code>string</code>) String to split
</div><div class="help-li" style=""> <code>{sep}</code>   (<code>string</code>) Separator or pattern
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Keyword arguments <a href="lua.html#kwargs">kwargs</a>:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{plain}?</code> (<code>boolean</code>) Use <code>sep</code> literally (as in
                  string.find).
</div><div class="help-li" style="margin-left: 3rem;"> <code>{trimempty}?</code> (<code>boolean</code>) Discard empty segments at start and
                  end of the sequence.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>fun():string?</code>) Iterator over the split components

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="luaref.html#string.gmatch()">string.gmatch()</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.split()">vim.split()</a>
</div><div class="help-li" style=""> <a href="luaref.html#lua-pattern">lua-pattern</a>s
</div><div class="help-li" style=""> <a href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>
</div><div class="help-li" style=""> <a href="http://lua-users.org/wiki/StringLibraryTutorial">http://lua-users.org/wiki/StringLibraryTutorial</a>
</div>
</div>
<div class="help-para">
vim.is_callable(<code>{f}</code>)                                       <span id="vim.is_callable()" class="help-tag-right"><a href="#vim.is_callable()">vim.is_callable()</a></span><br>
    Returns true if object <code>f</code> can be called as a function.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>any?</code>) Any object
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>f</code> is callable, else <code>false</code>

</div>
<div class="help-para">
vim.isarray(<code>{t}</code>)                                               <span id="vim.isarray()" class="help-tag-right"><a href="#vim.isarray()">vim.isarray()</a></span><br>
    Tests if <code>t</code> is an "array": a table indexed only by integers (potentially
    non-contiguous).

</div>
<div class="help-para">
    If the indexes start from 1 and are contiguous then the array is also a
    list. <a href="lua.html#vim.islist()">vim.islist()</a>

</div>
<div class="help-para">
    Empty table <code>{}</code> is an array, unless it was created by <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>
    or returned as a dict-like <a href="api.html#API">API</a> or Vimscript result, for example from
    <a href="vimfn.html#rpcrequest()">rpcrequest()</a> or <a href="lua.html#vim.fn">vim.fn</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>any?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if array-like table, else <code>false</code>.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://github.com/openresty/luajit2#tableisarray">https://github.com/openresty/luajit2#tableisarray</a>
</div>
</div>
<div class="help-para">
vim.islist(<code>{t}</code>)                                                 <span id="vim.islist()" class="help-tag-right"><a href="#vim.islist()">vim.islist()</a></span><br>
    Tests if <code>t</code> is a "list": a table indexed only by contiguous integers
    starting from 1 (what <a href="luaref.html#lua-length">lua-length</a> calls a "regular array").

</div>
<div class="help-para">
    Empty table <code>{}</code> is a list, unless it was created by <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a> or
    returned as a dict-like <a href="api.html#API">API</a> or Vimscript result, for example from
    <a href="vimfn.html#rpcrequest()">rpcrequest()</a> or <a href="lua.html#vim.fn">vim.fn</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>any?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if list-like table, else <code>false</code>.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.isarray()">vim.isarray()</a>
</div>
</div>
<div class="help-para">
vim.list.bisect(<code>{t}</code>, <code>{val}</code>, <code>{opts}</code>)                        <span id="vim.list.bisect()" class="help-tag-right"><a href="#vim.list.bisect()">vim.list.bisect()</a></span><br>
    Search for a position in a sorted list <code>{t}</code> where <code>{val}</code> can be inserted
    while keeping the list sorted.

</div>
<div class="help-para">
    Use <code>{bound}</code> to determine whether to return the first or the last position,
    defaults to "lower", i.e., the first position.

</div>
<div class="help-para">
<b>    NOTE:</b> Behavior is undefined on unsorted lists!

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local t = { 1, 2, 2, 3, 3, 3 }
local first = vim.list.bisect(t, 3)
-- `first` is `val`'s first index if found,
-- useful for existence checks.
print(t[first]) -- 3
local last = vim.list.bisect(t, 3, { bound = 'upper' })
-- Note that `last` is 7, not 6,
-- this is suitable for insertion.
table.insert(t, last, 4)
-- t is now { 1, 2, 2, 3, 3, 3, 4 }
-- You can use lower bound and upper bound together
-- to obtain the range of occurrences of `val`.
-- 3 is in [first, last)
for i = first, last - 1 do
  print(t[i]) -- { 3, 3, 3 }
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>     (<code>any[]</code>) A comparable list.
</div><div class="help-li" style=""> <code>{val}</code>   (<code>any</code>) The value to search.
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{lo}?</code> (<code>integer</code>, default: <code>1</code>) Start index of the list.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{hi}?</code> (<code>integer</code>, default: <code>#t + 1</code>) End index of the list,
                  exclusive.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{key}?</code> (<code>fun(val: any): any</code>) Optional, compare the return
                  value instead of the <code>{val}</code> itself if provided.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{bound}?</code> (<code>'lower'|'upper'</code>, default: <code>'lower'</code>) Specifies
                  the search variant.
</div><div class="help-li" style="margin-left: 4rem;"> "lower": returns the first position where inserting <code>{val}</code>
                    keeps the list sorted.
</div><div class="help-li" style="margin-left: 4rem;"> "upper": returns the last position where inserting <code>{val}</code>
                    keeps the list sorted..
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>) index serves as either the lower bound or the upper bound
        position.

</div>
<div class="help-para">
vim.list.unique(<code>{t}</code>, <code>{key}</code>)                                <span id="vim.list.unique()" class="help-tag-right"><a href="#vim.list.unique()">vim.list.unique()</a></span><br>
    Removes duplicate values from a list-like table in-place.

</div>
<div class="help-para">
    Only the first occurrence of each value is kept. The operation is
    performed in-place and the input table is modified.

</div>
<div class="help-para">
    Accepts an optional <code>key</code> argument, which if provided is called for each
    value in the list to compute a hash key for uniqueness comparison. This is
    useful for deduplicating table values or complex objects. If <code>key</code> returns
    <code>nil</code> for a value, that value will be considered unique, even if multiple
    values return <code>nil</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local t = {1, 2, 2, 3, 1}
vim.list.unique(t)
-- t is now {1, 2, 3}
local t = { {id=1}, {id=2}, {id=1} }
vim.list.unique(t, function(x) return x.id end)
-- t is now { {id=1}, {id=2} }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>    (<code>any[]</code>)
</div><div class="help-li" style=""> <code>{key}</code>  (<code>fun(x: T): any?</code>) Optional hash function to determine
               uniqueness of values
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any[]</code>) The deduplicated list

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Aunique()">Iter:unique()</a>
</div>
</div>
<div class="help-para">
vim.list_contains(<code>{t}</code>, <code>{value}</code>)                          <span id="vim.list_contains()" class="help-tag-right"><a href="#vim.list_contains()">vim.list_contains()</a></span><br>
    Checks if a list-like table (integer keys without gaps) contains <code>value</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>      (<code>table</code>) Table to check (must be list-like, not validated)
</div><div class="help-li" style=""> <code>{value}</code>  (<code>any</code>) Value to compare
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>t</code> contains <code>value</code>

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_contains()">vim.tbl_contains()</a> for checking values in general tables
</div>
</div>
<div class="help-para">
vim.list_extend(<code>{dst}</code>, <code>{src}</code>, <code>{start}</code>, <code>{finish}</code>)           <span id="vim.list_extend()" class="help-tag-right"><a href="#vim.list_extend()">vim.list_extend()</a></span><br>
    Extends a list-like table with the values of another list-like table.

</div>
<div class="help-para">
<b>    NOTE:</b> This mutates dst!

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{dst}</code>     (<code>table</code>) List which will be modified and appended to
</div><div class="help-li" style=""> <code>{src}</code>     (<code>table</code>) List from which values will be inserted
</div><div class="help-li" style=""> <code>{start}</code>   (<code>integer?</code>) Start index on src. Defaults to 1
</div><div class="help-li" style=""> <code>{finish}</code>  (<code>integer?</code>) Final index on src. Defaults to <code>#src</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) dst

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_extend()">vim.tbl_extend()</a>
</div>
</div>
<div class="help-para">
vim.list_slice(<code>{list}</code>, <code>{start}</code>, <code>{finish}</code>)                   <span id="vim.list_slice()" class="help-tag-right"><a href="#vim.list_slice()">vim.list_slice()</a></span><br>
    Creates a copy of a table containing only elements from start to end
    (inclusive)

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{list}</code>    (<code>any[]</code>) Table
</div><div class="help-li" style=""> <code>{start}</code>   (<code>integer?</code>) Start range of slice
</div><div class="help-li" style=""> <code>{finish}</code>  (<code>integer?</code>) End range of slice
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any[]</code>) Copy of table sliced from start to finish (inclusive)

</div>
<div class="help-para">
vim.pesc(<code>{s}</code>)                                                     <span id="vim.pesc()" class="help-tag-right"><a href="#vim.pesc()">vim.pesc()</a></span><br>
    Escapes magic chars in <a href="luaref.html#lua-pattern">lua-pattern</a>s.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>  (<code>string</code>) String to escape
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) %-escaped pattern string

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://github.com/rxi/lume">https://github.com/rxi/lume</a>
</div>
</div>
<div class="help-para">
vim.ringbuf(<code>{size}</code>)                                            <span id="vim.ringbuf()" class="help-tag-right"><a href="#vim.ringbuf()">vim.ringbuf()</a></span><br>
    Create a ring buffer limited to a maximal number of items. Once the buffer
    is full, adding a new entry overrides the oldest entry.<pre><code class="language-lua">local ringbuf = vim.ringbuf(4)
ringbuf:push("a")
ringbuf:push("b")
ringbuf:push("c")
ringbuf:push("d")
ringbuf:push("e")    -- overrides "a"
print(ringbuf:pop()) -- returns "b"
print(ringbuf:pop()) -- returns "c"
-- Can be used as iterator. Pops remaining items:
for val in ringbuf do
  print(val)
end</code></pre>

</div>
<div class="help-para">
    Returns a Ringbuf instance with the following methods:
<div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apush()">Ringbuf:push()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apop()">Ringbuf:pop()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apeek()">Ringbuf:peek()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Aclear()">Ringbuf:clear()</a>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{size}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.Ringbuf</code>) ringbuf See <a href="lua.html#vim.Ringbuf">vim.Ringbuf</a>.

</div>
<div class="help-para">
vim.spairs(<code>{t}</code>)                                                 <span id="vim.spairs()" class="help-tag-right"><a href="#vim.spairs()">vim.spairs()</a></span><br>
    Enumerates key-value pairs of a table, ordered by key.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>table</code>) Dict-like table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>fun(table: table&lt;K, V&gt;, index?: K):K, V</code>) <a href="luaref.html#for-in">for-in</a> iterator over
        sorted keys and their values
        (<code>table</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> Based on
        <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
vim.split(<code>{s}</code>, <code>{sep}</code>, <code>{opts}</code>)                                    <span id="vim.split()" class="help-tag-right"><a href="#vim.split()">vim.split()</a></span><br>
    Splits a string at each instance of a separator and returns the result as
    a table (unlike <a href="lua.html#vim.gsplit()">vim.gsplit()</a>).

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">split(":aa::b:", ":")                   --&gt; {'','aa','','b',''}
split("axaby", "ab?")                   --&gt; {'','x','y'}
split("x*yz*o", "*", {plain=true})      --&gt; {'x','yz','o'}
split("|x|y|z|", "|", {trimempty=true}) --&gt; {'x', 'y', 'z'}</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>     (<code>string</code>) String to split
</div><div class="help-li" style=""> <code>{sep}</code>   (<code>string</code>) Separator or pattern
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Keyword arguments <a href="lua.html#kwargs">kwargs</a>:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{plain}?</code> (<code>boolean</code>) Use <code>sep</code> literally (as in
                  string.find).
</div><div class="help-li" style="margin-left: 3rem;"> <code>{trimempty}?</code> (<code>boolean</code>) Discard empty segments at start and
                  end of the sequence.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string[]</code>) List of split components

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.gsplit()">vim.gsplit()</a>
</div><div class="help-li" style=""> <a href="luaref.html#string.gmatch()">string.gmatch()</a>
</div>
</div>
<div class="help-para">
vim.startswith(<code>{s}</code>, <code>{prefix}</code>)                               <span id="vim.startswith()" class="help-tag-right"><a href="#vim.startswith()">vim.startswith()</a></span><br>
    Tests if <code>s</code> starts with <code>prefix</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>       (<code>string</code>) String
</div><div class="help-li" style=""> <code>{prefix}</code>  (<code>string</code>) Prefix to match
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>prefix</code> is a prefix of <code>s</code>

</div>
<div class="help-para">
vim.tbl_contains(<code>{t}</code>, <code>{value}</code>, <code>{opts}</code>)                    <span id="vim.tbl_contains()" class="help-tag-right"><a href="#vim.tbl_contains()">vim.tbl_contains()</a></span><br>
    Checks if a table contains a given value, specified either directly or via
    a predicate that is checked for each value.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)
  return vim.deep_equal(v, { 'b', 'c' })
end, { predicate = true })
-- true</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>      (<code>table</code>) Table to check
</div><div class="help-li" style=""> <code>{value}</code>  (<code>any</code>) Value to compare or predicate function reference
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Keyword arguments <a href="lua.html#kwargs">kwargs</a>:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{predicate}?</code> (<code>boolean</code>) <code>value</code> is a function reference to
                   be checked (default false)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>t</code> contains <code>value</code>

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.list_contains()">vim.list_contains()</a> for checking values in list-like tables
</div>
</div>
<div class="help-para">
vim.tbl_count(<code>{t}</code>)                                           <span id="vim.tbl_count()" class="help-tag-right"><a href="#vim.tbl_count()">vim.tbl_count()</a></span><br>
    Counts the number of non-nil values in table <code>t</code>.<pre><code class="language-lua">vim.tbl_count({ a=1, b=2 })  --&gt; 2
vim.tbl_count({ 1, 2 })      --&gt; 2</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>table</code>) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>) Number of non-nil values in table

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua">https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua</a>
</div>
</div>
<div class="help-para">
vim.tbl_deep_extend(<code>{behavior}</code>, <code>{...}</code>)                 <span id="vim.tbl_deep_extend()" class="help-tag-right"><a href="#vim.tbl_deep_extend()">vim.tbl_deep_extend()</a></span><br>
    Merges recursively two or more tables.

</div>
<div class="help-para">
    Only values that are empty tables or tables that are not <a href="lua.html#lua-list">lua-list</a>s
    (indexed by consecutive integers starting from 1) are merged recursively.
    This is useful for merging nested tables like default and user
    configurations where lists should be treated as literals (i.e., are
    overwritten instead of merged).

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{behavior}</code>  (<code>'error'|'keep'|'force'|fun(key:any, prev_value:any?, value:any): any</code>)
                    Decides what to do if a key is found in more than one map:
</div><div class="help-li" style="margin-left: 3rem;"> "error": raise an error
</div><div class="help-li" style="margin-left: 3rem;"> "keep": use value from the leftmost map
</div><div class="help-li" style="margin-left: 3rem;"> "force": use value from the rightmost map
</div><div class="help-li" style="margin-left: 3rem;"> If a function, it receives the current key, the previous
                      value in the currently merged table (if present), the
                      current value and should return the value for the given
                      key in the merged table.
</div><div class="help-li" style=""> <code>{...}</code>       (<code>table</code>) Two or more tables
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) Merged table

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_extend()">vim.tbl_extend()</a>
</div>
</div>
<div class="help-para">
vim.tbl_extend(<code>{behavior}</code>, <code>{...}</code>)                           <span id="vim.tbl_extend()" class="help-tag-right"><a href="#vim.tbl_extend()">vim.tbl_extend()</a></span><br>
    Merges two or more tables.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{behavior}</code>  (<code>'error'|'keep'|'force'|fun(key:any, prev_value:any?, value:any): any</code>)
                    Decides what to do if a key is found in more than one map:
</div><div class="help-li" style="margin-left: 3rem;"> "error": raise an error
</div><div class="help-li" style="margin-left: 3rem;"> "keep": use value from the leftmost map
</div><div class="help-li" style="margin-left: 3rem;"> "force": use value from the rightmost map
</div><div class="help-li" style="margin-left: 3rem;"> If a function, it receives the current key, the previous
                      value in the currently merged table (if present), the
                      current value and should return the value for the given
                      key in the merged table.
</div><div class="help-li" style=""> <code>{...}</code>       (<code>table</code>) Two or more tables
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) Merged table

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="vimfn.html#extend()">extend()</a>
</div>
</div>
<div class="help-para">
vim.tbl_filter(<code>{fn}</code>, <code>{t}</code>)                                   <span id="vim.tbl_filter()" class="help-tag-right"><a href="#vim.tbl_filter()">vim.tbl_filter()</a></span><br>
    Filter a table using a predicate function

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>  (<code>function</code>) Function
</div><div class="help-li" style=""> <code>{t}</code>   (<code>table</code>) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any[]</code>) Table of filtered values

</div>
<div class="help-para">
vim.tbl_get(<code>{o}</code>, <code>{...}</code>)                                        <span id="vim.tbl_get()" class="help-tag-right"><a href="#vim.tbl_get()">vim.tbl_get()</a></span><br>
    Index into a table (first argument) via string keys passed as subsequent
    arguments. Return <code>nil</code> if the key does not exist.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true
vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{o}</code>    (<code>table</code>) Table to index
</div><div class="help-li" style=""> <code>{...}</code>  (<code>any</code>) Optional keys (0 or more, variadic) via which to index
               the table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>) Nested value indexed by key (if it exists), else nil

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="luaref.html#unpack()">unpack()</a>
</div>
</div>
<div class="help-para">
vim.tbl_isempty(<code>{t}</code>)                                       <span id="vim.tbl_isempty()" class="help-tag-right"><a href="#vim.tbl_isempty()">vim.tbl_isempty()</a></span><br>
    Checks if a table is empty.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>table</code>) Table to check
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>t</code> is empty

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
vim.tbl_keys(<code>{t}</code>)                                             <span id="vim.tbl_keys()" class="help-tag-right"><a href="#vim.tbl_keys()">vim.tbl_keys()</a></span><br>
    Return a list of all keys used in a table. However, the order of the
    return table of keys is not guaranteed.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>table</code>) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any[]</code>) List of keys

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> From
        <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
vim.tbl_map(<code>{fn}</code>, <code>{t}</code>)                                         <span id="vim.tbl_map()" class="help-tag-right"><a href="#vim.tbl_map()">vim.tbl_map()</a></span><br>
    Applies function <code>fn</code> to all values of table <code>t</code>, in <code>pairs()</code> iteration
    order (which is not guaranteed to be stable, even when the data doesn't
    change).

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>  (<code>fun(value: T): any</code>) Function
</div><div class="help-li" style=""> <code>{t}</code>   (<code>table&lt;any, T&gt;</code>) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>) Table of transformed values

</div>
<div class="help-para">
vim.tbl_values(<code>{t}</code>)                                         <span id="vim.tbl_values()" class="help-tag-right"><a href="#vim.tbl_values()">vim.tbl_values()</a></span><br>
    Return a list of all values used in a table. However, the order of the
    return table of values is not guaranteed.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (<code>table</code>) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any[]</code>) List of values

</div>
<div class="help-para">
vim.trim(<code>{s}</code>)                                                     <span id="vim.trim()" class="help-tag-right"><a href="#vim.trim()">vim.trim()</a></span><br>
    Trim whitespace (Lua pattern "%s") from both sides of a string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>  (<code>string</code>) String to trim
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) String with whitespace removed from its beginning and end

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="luaref.html#lua-pattern">lua-pattern</a>s
</div><div class="help-li" style=""> <a href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>
</div>
</div>
<div class="help-para">
                                                              <span id="vim.validate()" class="help-tag-right"><a href="#vim.validate()">vim.validate()</a></span><br>
vim.validate(<code>{name}</code>, <code>{value}</code>, <code>{validator}</code>, <code>{optional}</code>, <code>{message}</code>)
    Validate function arguments.

</div>
<div class="help-para">
    This function has two valid forms:
<div class="help-li-num" style=""> <code>vim.validate(name, value, validator[, optional][, message])</code>
       Validates that argument <code>{name}</code> with value <code>{value}</code> satisfies
       <code>{validator}</code>. If <code>{optional}</code> is given and is <code>true</code>, then <code>{value}</code> may be
       <code>nil</code>. If <code>{message}</code> is given, then it is used as the expected type in
       the error message.
       Example:<pre><code class="language-lua"> function vim.startswith(s, prefix)
  vim.validate('s', s, 'string')
  vim.validate('prefix', prefix, 'string')
  -- ...
end</code></pre>
</div>
</div>
<div class="help-para">
<div class="help-li-num" style=""> <code>vim.validate(spec)</code> (deprecated) where <code>spec</code> is of type
       <code>table&lt;string,[value:any, validator: vim.validate.Validator, optional_or_msg? : boolean|string]&gt;)</code>
       Validates a argument specification. Specs are evaluated in alphanumeric
       order, until the first failure.
       Example:<pre><code class="language-lua"> function user.new(name, age, hobbies)
  vim.validate{
    name={name, 'string'},
    age={age, 'number'},
    hobbies={hobbies, 'table'},
  }
  -- ...
end</code></pre>
</div>
</div>
<div class="help-para">
    Examples with explicit argument values (can be run directly):<pre><code class="language-lua">vim.validate('arg1', {'foo'}, 'table')
   --&gt; NOP (success)
vim.validate('arg2', 'foo', 'string')
   --&gt; NOP (success)
vim.validate('arg1', 1, 'table')
   --&gt; error('arg1: expected table, got number')
vim.validate('arg1', 3, function(a) return (a % 2) == 0 end, 'even number')
   --&gt; error('arg1: expected even number, got 3')</code></pre>

</div>
<div class="help-para">
    If multiple types are valid they can be given as a list.<pre><code class="language-lua">vim.validate('arg1', {'foo'}, {'table', 'string'})
vim.validate('arg2', 'foo', {'table', 'string'})
-- NOP (success)
vim.validate('arg1', 1, {'string', 'table'})
-- error('arg1: expected string|table, got number')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading"><b>    Note:</b></div>
<div class="help-li" style=""> <code>validator</code> set to a value returned by <a href="luaref.html#lua-type()">lua-type()</a> provides the best
        performance.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{name}</code>       (<code>string</code>) Argument name
</div><div class="help-li" style=""> <code>{value}</code>      (<code>any</code>) Argument value
</div><div class="help-li" style=""> <code>{validator}</code>  (<code>vim.validate.Validator</code>)
</div><div class="help-li" style="margin-left: 3rem;"> (<code>string|string[]</code>): Any value that can be returned
                       from <a href="luaref.html#lua-type()">lua-type()</a> in addition to <code>'callable'</code>:
                       <code>'boolean'</code>, <code>'callable'</code>, <code>'function'</code>, <code>'nil'</code>,
                       <code>'number'</code>, <code>'string'</code>, <code>'table'</code>, <code>'thread'</code>,
                       <code>'userdata'</code>.
</div><div class="help-li" style="margin-left: 3rem;"> (<code>fun(val:any): boolean, string?</code>) A function that
                       returns a boolean and an optional string message.
</div><div class="help-li" style=""> <code>{optional}</code>   (<code>boolean?</code>) Argument is optional (may be omitted)
</div><div class="help-li" style=""> <code>{message}</code>    (<code>string?</code>) message when validation fails
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Overloads:</div>
<div class="help-li" style=""> <code>fun(name: string, val: any, validator: vim.validate.Validator, message: string)</code>
</div><div class="help-li" style=""> <code>fun(spec: table&lt;string,[any, vim.validate.Validator, boolean|string]&gt;)</code>
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.base64" class="help-heading">Lua module: vim.base64<span class="help-heading-tags">                                            <span id="vim.base64" class="help-tag"><a href="#vim.base64">vim.base64</a></span></h2>


</div>
<div class="help-para">
vim.base64.decode(<code>{str}</code>)                                 <span id="vim.base64.decode()" class="help-tag-right"><a href="#vim.base64.decode()">vim.base64.decode()</a></span><br>
    Decode a Base64 encoded string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) Base64 encoded string
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) Decoded string

</div>
<div class="help-para">
vim.base64.encode(<code>{str}</code>)                                 <span id="vim.base64.encode()" class="help-tag-right"><a href="#vim.base64.encode()">vim.base64.encode()</a></span><br>
    Encode <code>{str}</code> using Base64.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) String to encode
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) Encoded string

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.filetype" class="help-heading">Lua module: vim.filetype<span class="help-heading-tags">                                        <span id="vim.filetype" class="help-tag"><a href="#vim.filetype">vim.filetype</a></span></h2>


</div>
<div class="help-para">
vim.filetype.add(<code>{filetypes}</code>)                             <span id="vim.filetype.add()" class="help-tag-right"><a href="#vim.filetype.add()">vim.filetype.add()</a></span><br>
    Add new filetype mappings.

</div>
<div class="help-para">
    Filetype mappings can be added either by extension or by filename (either
    the "tail" or the full file path). The full file path is checked first,
    followed by the file name. If a match is not found using the filename,
    then the filename is matched against the list of <a href="luaref.html#lua-pattern">lua-pattern</a>s (sorted by
    priority) until a match is found. Lastly, if pattern matching does not
    find a filetype, then the file extension is used.

</div>
<div class="help-para">
    The filetype can be either a string (in which case it is used as the
    filetype directly) or a function. If a function, it takes the full path
    and buffer number of the file as arguments (along with captures from the
    matched pattern, if any) and should return a string that will be used as
    the buffer's filetype. Optionally, the function can return a second
    function value which, when called, modifies the state of the buffer. This
    can be used to, for example, set filetype-specific buffer variables. This
    function will be called by Nvim before setting the buffer's filetype.

</div>
<div class="help-para">
    Filename patterns can specify an optional priority to resolve cases when a
    file path matches multiple patterns. Higher priorities are matched first.
    When omitted, the priority defaults to 0. A pattern can contain
    environment variables of the form "${SOME_VAR}" that will be automatically
    expanded. If the environment variable is not set, the pattern won't be
    matched.

</div>
<div class="help-para">
    See $VIMRUNTIME/lua/vim/filetype.lua for more examples.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.filetype.add({
  extension = {
    foo = 'fooscript',
    bar = function(path, bufnr)
      if some_condition() then
        return 'barscript', function(bufnr)
          -- Set a buffer variable
          vim.b[bufnr].barscript_version = 2
        end
      end
      return 'bar'
    end,
  },
  filename = {
    ['.foorc'] = 'toml',
    ['/etc/foo/config'] = 'toml',
  },
  pattern = {
    ['.*/etc/foo/.*'] = 'fooscript',
    -- Using an optional priority
    ['.*/etc/foo/.*%.conf'] = { 'dosini', { priority = 10 } },
    -- A pattern containing an environment variable
    ['${XDG_CONFIG_HOME}/foo/git'] = 'git',
    ['.*README.(%a+)'] = function(path, bufnr, ext)
      if ext == 'md' then
        return 'markdown'
      elseif ext == 'rst' then
        return 'rst'
      end
    end,
  },
})</code></pre>

</div>
<div class="help-para">
    To add a fallback match on contents, use<pre><code class="language-lua">vim.filetype.add {
  pattern = {
    ['.*'] = {
      function(path, bufnr)
        local content = vim.api.nvim_buf_get_lines(bufnr, 0, 1, false)[1] or ''
        if vim.regex([[^#!.*\\&lt;mine\\&gt;]]):match_str(content) ~= nil then
          return 'mine'
        elseif vim.regex([[\\&lt;drawing\\&gt;]]):match_str(content) ~= nil then
          return 'drawing'
        end
      end,
      { priority = -math.huge },
    },
  },
}</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{filetypes}</code>  (<code>table</code>) A table containing new filetype maps (see
                     example).
</div><div class="help-li" style="margin-left: 3rem;"> <code>{pattern}?</code> (<code>vim.filetype.mapping</code>)
</div><div class="help-li" style="margin-left: 3rem;"> <code>{extension}?</code> (<code>vim.filetype.mapping</code>)
</div><div class="help-li" style="margin-left: 3rem;"> <code>{filename}?</code> (<code>vim.filetype.mapping</code>)
</div>
</div>
<div class="help-para">
                                                   <span id="vim.filetype.get_option()" class="help-tag-right"><a href="#vim.filetype.get_option()">vim.filetype.get_option()</a></span><br>
vim.filetype.get_option(<code>{filetype}</code>, <code>{option}</code>)
    Get the default option value for a <code>{filetype}</code>.

</div>
<div class="help-para">
    The returned value is what would be set in a new buffer after <a href="options.html#'filetype'">'filetype'</a>
    is set, meaning it should respect all FileType autocmds and ftplugin
    files.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.filetype.get_option('vim', 'commentstring')</code></pre>

</div>
<div class="help-para">
<b>    Note:</b> this uses <a href="api.html#nvim_get_option_value()">nvim_get_option_value()</a> but caches the result. This
    means <a href="usr_41.html#ftplugin">ftplugin</a> and <a href="autocmd.html#FileType">FileType</a> autocommands are only triggered once and
    may not reflect later changes.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{filetype}</code>  (<code>string</code>) Filetype
</div><div class="help-li" style=""> <code>{option}</code>    (<code>string</code>) Option name
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string|boolean|integer</code>) Option value

</div>
<div class="help-para">
vim.filetype.match(<code>{args}</code>)                              <span id="vim.filetype.match()" class="help-tag-right"><a href="#vim.filetype.match()">vim.filetype.match()</a></span><br>
    Perform filetype detection.

</div>
<div class="help-para">
    The filetype can be detected using one of three methods:
<div class="help-li-num" style=""> Using an existing buffer
</div>
</div>
<div class="help-para">
<div class="help-li-num" style=""> Using only a file name
</div>
</div>
<div class="help-para">
<div class="help-li-num" style=""> Using only file contents
</div>
</div>
<div class="help-para">
    Of these, option 1 provides the most accurate result as it uses both the
    buffer's filename and (optionally) the buffer contents. Options 2 and 3
    can be used without an existing buffer, but may not always provide a match
    in cases where the filename (or contents) cannot unambiguously determine
    the filetype.

</div>
<div class="help-para">
    Each of the three options is specified using a key to the single argument
    of this function. Example:<pre><code class="language-lua">-- Using a buffer number
vim.filetype.match({ buf = 42 })
-- Override the filename of the given buffer
vim.filetype.match({ buf = 42, filename = 'foo.c' })
-- Using a filename without a buffer
vim.filetype.match({ filename = 'main.lua' })
-- Using file contents
vim.filetype.match({ contents = {'#!/usr/bin/env bash'} })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{args}</code>  (<code>table</code>) Table specifying which matching strategy to use.
                Accepted keys are:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{buf}?</code> (<code>integer</code>) Buffer number to use for matching.
                  Mutually exclusive with <code>{contents}</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{filename}?</code> (<code>string</code>) Filename to use for matching. When
                  <code>{buf}</code> is given, defaults to the filename of the given buffer
                  number. The file need not actually exist in the filesystem.
                  When used without <code>{buf}</code> only the name of the file is used
                  for filetype matching. This may result in failure to detect
                  the filetype in cases where the filename alone is not enough
                  to disambiguate the filetype.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{contents}?</code> (<code>string[]</code>) An array of lines representing file
                  contents to use for matching. Can be used with <code>{filename}</code>.
                  Mutually exclusive with <code>{buf}</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>string?</code>) The matched filetype, if any.
        (<code>function?</code>) A function <code>fun(buf: integer)</code> that modifies buffer
        state when called (for example, to set some filetype specific buffer
        variables).
        (<code>boolean?</code>) true if a match was found by falling back to a generic
        filetype (i.e., ".conf"), which indicates the filetype should be set
        with <code>:setf FALLBACK conf</code>. See <a href="options.html#%3Asetfiletype">:setfiletype</a>.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.fs" class="help-heading">Lua module: vim.fs<span class="help-heading-tags">                                                    <span id="vim.fs" class="help-tag"><a href="#vim.fs">vim.fs</a></span></h2>


</div>
<div class="help-para">
                                                             <span id="vim.fs.exists()" class="help-tag-right"><a href="#vim.fs.exists()">vim.fs.exists()</a></span><br>
Use <a href="luvref.html#uv.fs_stat()">uv.fs_stat()</a> to check a file's type, and whether it exists.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">if vim.uv.fs_stat(file) then
  vim.print('file exists')
end</code></pre>

</div>
<div class="help-para">
                                                               <span id="vim.fs.read()" class="help-tag-right"><a href="#vim.fs.read()">vim.fs.read()</a></span><br>
You can use <a href="vimfn.html#readblob()">readblob()</a> to get a file's contents without explicitly opening/closing it.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">vim.print(vim.fn.readblob('.git/config'))</code></pre>

</div>
<div class="help-para">
vim.fs.abspath(<code>{path}</code>)                                      <span id="vim.fs.abspath()" class="help-tag-right"><a href="#vim.fs.abspath()">vim.fs.abspath()</a></span><br>
    Converts <code>path</code> to an absolute path. Expands tilde (~) at the beginning of
    the path to the user's home directory. Does not check if the path exists,
    normalize the path, resolve symlinks or hardlinks (including <code>.</code> and
    <code>..</code>), or expand environment variables. If the path is already absolute,
    it is returned unchanged. Also converts <code>\</code> path separators to <code>/</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.11.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) Absolute path

</div>
<div class="help-para">
vim.fs.basename(<code>{file}</code>)                                    <span id="vim.fs.basename()" class="help-tag-right"><a href="#vim.fs.basename()">vim.fs.basename()</a></span><br>
    Gets the basename of the given path (not expanded/resolved).

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{file}</code>  (<code>string?</code>) Path
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>) Basename of <code>{file}</code>

</div>
<div class="help-para">
vim.fs.dir(<code>{path}</code>, <code>{opts}</code>)                                      <span id="vim.fs.dir()" class="help-tag-right"><a href="#vim.fs.dir()">vim.fs.dir()</a></span><br>
    Gets an iterator over items found in <code>path</code> (normalized via
    <a href="lua.html#vim.fs.normalize()">vim.fs.normalize()</a>).

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Directory to iterate over, normalized via
                <a href="lua.html#vim.fs.normalize()">vim.fs.normalize()</a>.
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{depth}?</code> (<code>integer</code>, default: <code>1</code>) How deep to traverse.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{skip}?</code> (<code>fun(dir_name: string): boolean</code>) Predicate to
                  control traversal. Return false to stop searching the
                  current directory. Only useful when depth &gt; 1 Return an
                  iterator over the items located in <code>{path}</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{follow}?</code> (<code>boolean</code>, default: <code>false</code>) Follow symbolic
                  links.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iterator</code>) over items in <code>{path}</code>. Each iteration yields two values:
        "name" and "type". "name" is the basename of the item relative to
        <code>{path}</code>. "type" is one of the following: "file", "directory", "link",
        "fifo", "socket", "char", "block", "unknown".

</div>
<div class="help-para">
vim.fs.dirname(<code>{file}</code>)                                      <span id="vim.fs.dirname()" class="help-tag-right"><a href="#vim.fs.dirname()">vim.fs.dirname()</a></span><br>
    Gets the parent directory of the given path (not expanded/resolved, the
    caller must do that).

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{file}</code>  (<code>string?</code>) Path
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>) Parent directory of <code>{file}</code>

</div>
<div class="help-para">
vim.fs.find(<code>{names}</code>, <code>{opts}</code>)                                   <span id="vim.fs.find()" class="help-tag-right"><a href="#vim.fs.find()">vim.fs.find()</a></span><br>
    Find files or directories (or other items as specified by <code>opts.type</code>) in
    the given path.

</div>
<div class="help-para">
    Finds items given in <code>{names}</code> starting from <code>{path}</code>. If <code>{upward}</code> is "true"
    then the search traverses upward through parent directories; otherwise,
    the search traverses downward. Note that downward searches are recursive
    and may search through many directories! If <code>{stop}</code> is non-nil, then the
    search stops when the directory given in <code>{stop}</code> is reached. The search
    terminates when <code>{limit}</code> (default 1) matches are found. You can set <code>{type}</code>
    to "file", "directory", "link", "socket", "char", "block", or "fifo" to
    narrow the search to find only that type.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- List all test directories under the runtime directory.
local dirs = vim.fs.find(
  { 'test', 'tst', 'testdir' },
  { limit = math.huge, type = 'directory', path = './runtime/' }
)
-- Get all "lib/*.cpp" and "lib/*.hpp" files, using Lua patterns.
-- Or use `vim.glob.to_lpeg(…):match(…)` for glob/wildcard matching.
local files = vim.fs.find(function(name, path)
  return name:match('.*%.[ch]pp$') and path:match('[/\\]lib$')
end, { limit = math.huge, type = 'file' })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{names}</code>  (<code>string|string[]|fun(name: string, path: string): boolean</code>)
                 Names of the items to find. Must be base names, paths and
                 globs are not supported when <code>{names}</code> is a string or a table.
                 If <code>{names}</code> is a function, it is called for each traversed
                 item with args:
</div><div class="help-li" style="margin-left: 3rem;"> name: base name of the current item
</div><div class="help-li" style="margin-left: 3rem;"> path: full path of the current item
</div>
</div>
<div class="help-para">
                 The function should return <code>true</code> if the given item is
                 considered a match.
<div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{path}?</code> (<code>string</code>) Path to begin searching from, defaults
                   to <a href="editing.html#current-directory">current-directory</a>. Not expanded.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{upward}?</code> (<code>boolean</code>, default: <code>false</code>) Search upward
                   through parent directories. Otherwise, search child
                   directories (recursively).
</div><div class="help-li" style="margin-left: 3rem;"> <code>{stop}?</code> (<code>string</code>) Stop searching when this directory is
                   reached. The directory itself is not searched.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{type}?</code> (<code>string</code>) Find only items of the given type. If
                   omitted, all items that match <code>{names}</code> are included.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{limit}?</code> (<code>number</code>, default: <code>1</code>) Stop searching after this
                   many matches. Use <code>math.huge</code> for "unlimited".
</div><div class="help-li" style="margin-left: 3rem;"> <code>{follow}?</code> (<code>boolean</code>, default: <code>false</code>) Follow symbolic
                   links.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string[]</code>) Normalized paths <a href="lua.html#vim.fs.normalize()">vim.fs.normalize()</a> of all matching
        items

</div>
<div class="help-para">
vim.fs.joinpath(<code>{...}</code>)                                     <span id="vim.fs.joinpath()" class="help-tag-right"><a href="#vim.fs.joinpath()">vim.fs.joinpath()</a></span><br>
    Concatenates partial paths (one absolute or relative path followed by zero
    or more relative paths). Slashes are normalized: redundant slashes are
    removed, and (on Windows) backslashes are replaced with forward-slashes.
    Paths are not expanded/resolved.

</div>
<div class="help-para">
    Examples:
<div class="help-li" style=""> "foo/", "/bar" =&gt; "foo/bar"
</div><div class="help-li" style=""> Windows: "a\foo\", "\bar" =&gt; "a/foo/bar"
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.10.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{...}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
vim.fs.normalize(<code>{path}</code>, <code>{opts}</code>)                          <span id="vim.fs.normalize()" class="help-tag-right"><a href="#vim.fs.normalize()">vim.fs.normalize()</a></span><br>
    Normalize a path to a standard format. A tilde (~) character at the
    beginning of the path is expanded to the user's home directory and
    environment variables are also expanded. "." and ".." components are also
    resolved, except when the path is relative and trying to resolve it would
    result in an absolute path.
<div class="help-li" style=""> "." as the only part in a relative path:
</div><div class="help-li" style="margin-left: 3rem;"> "." =&gt; "."
</div><div class="help-li" style="margin-left: 3rem;"> "././" =&gt; "."
</div><div class="help-li" style=""> ".." when it leads outside the current directory
</div><div class="help-li" style="margin-left: 3rem;"> "foo/../../bar" =&gt; "../bar"
</div><div class="help-li" style="margin-left: 3rem;"> "../../foo" =&gt; "../../foo"
</div><div class="help-li" style=""> ".." in the root directory returns the root directory.
</div><div class="help-li" style="margin-left: 3rem;"> "/../../" =&gt; "/"
</div>
</div>
<div class="help-para">
    On Windows, backslash (\) characters are converted to forward slashes (/).

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">[[C:\Users\jdoe]]                         =&gt; "C:/Users/jdoe"
"~/src/neovim"                            =&gt; "/home/jdoe/src/neovim"
"$XDG_CONFIG_HOME/nvim/init.vim"          =&gt; "/Users/jdoe/.config/nvim/init.vim"
"~/src/nvim/api/../tui/./tui.c"           =&gt; "/home/jdoe/src/nvim/tui/tui.c"
"./foo/bar"                               =&gt; "foo/bar"
"foo/../../../bar"                        =&gt; "../../bar"
"/home/jdoe/../../../bar"                 =&gt; "/bar"
"C:foo/../../baz"                         =&gt; "C:../baz"
"C:/foo/../../baz"                        =&gt; "C:/baz"
[[\\?\UNC\server\share\foo\..\..\..\bar]] =&gt; "//?/UNC/server/share/bar"</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path to normalize
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{expand_env}?</code> (<code>boolean</code>, default: <code>true</code>) Expand
                  environment variables.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{win}?</code> (<code>boolean</code>, default: <code>true</code> in Windows, <code>false</code>
                  otherwise) Path is a Windows path.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) Normalized path

</div>
<div class="help-para">
vim.fs.parents(<code>{start}</code>)                                     <span id="vim.fs.parents()" class="help-tag-right"><a href="#vim.fs.parents()">vim.fs.parents()</a></span><br>
    Iterate over all the parents of the given path (not expanded/resolved, the
    caller must do that).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local root_dir
for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do
  if vim.fn.isdirectory(dir .. '/.git') == 1 then
    root_dir = dir
    break
  end
end
if root_dir then
  print('Found git repository at', root_dir)
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.8.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{start}</code>  (<code>string</code>) Initial path.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>fun(_, dir: string): string?</code>) Iterator
        (<code>nil</code>)
        (<code>string?</code>)

</div>
<div class="help-para">
vim.fs.relpath(<code>{base}</code>, <code>{target}</code>, <code>{opts}</code>)                    <span id="vim.fs.relpath()" class="help-tag-right"><a href="#vim.fs.relpath()">vim.fs.relpath()</a></span><br>
    Gets <code>target</code> path relative to <code>base</code>, or <code>nil</code> if <code>base</code> is not an
    ancestor.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.fs.relpath('/var', '/var/lib') -- 'lib'
vim.fs.relpath('/var', '/usr/bin') -- nil</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.11.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{base}</code>    (<code>string</code>)
</div><div class="help-li" style=""> <code>{target}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{opts}</code>    (<code>table?</code>) Reserved for future use
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>)

</div>
<div class="help-para">
vim.fs.rm(<code>{path}</code>, <code>{opts}</code>)                                        <span id="vim.fs.rm()" class="help-tag-right"><a href="#vim.fs.rm()">vim.fs.rm()</a></span><br>
    Removes a file or directory.

</div>
<div class="help-para">
    Removes symlinks without touching the origin. To remove the origin,
    resolve it explicitly with <a href="luvref.html#uv.fs_realpath()">uv.fs_realpath()</a>:<pre><code class="language-lua">vim.fs.rm(vim.uv.fs_realpath('symlink-dir'), { recursive = true })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.11.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path to remove (not expanded/resolved).
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{recursive}?</code> (<code>boolean</code>) Remove directory contents
                  recursively.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{force}?</code> (<code>boolean</code>) Ignore nonexistent files and arguments.
</div>
</div>
<div class="help-para">
vim.fs.root(<code>{source}</code>, <code>{marker}</code>)                                <span id="vim.fs.root()" class="help-tag-right"><a href="#vim.fs.root()">vim.fs.root()</a></span><br>
    Find the first parent directory containing a specific "marker", relative
    to a file path or buffer.

</div>
<div class="help-para">
    If the buffer is unnamed (has no backing file) or has a non-empty
    <a href="options.html#'buftype'">'buftype'</a> then the search begins from Nvim's <a href="editing.html#current-directory">current-directory</a>.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Find the root of a Python project, starting from file 'main.py'
vim.fs.root(vim.fs.joinpath(vim.env.PWD, 'main.py'), {'pyproject.toml', 'setup.py' })
-- Find the root of a git repository
vim.fs.root(0, '.git')
-- Find the parent directory containing any file with a .csproj extension
vim.fs.root(0, function(name, path)
  return name:match('%.csproj$') ~= nil
end)
-- Find the first ancestor directory containing EITHER "stylua.toml" or ".luarc.json"; if
-- not found, find the first ancestor containing ".git":
vim.fs.root(0, { { 'stylua.toml', '.luarc.json' }, '.git' })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.10.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{source}</code>  (<code>integer|string</code>) Buffer number (0 for current buffer) or
                  file path (absolute or relative, expanded via <code>abspath()</code>)
                  to begin the search from.
</div><div class="help-li" style=""> <code>{marker}</code>  (<code>(string|string[]|fun(name: string, path: string): boolean)[]|string|fun(name: string, path: string): boolean</code>)
                  Filename, function, or list thereof, that decides how to
                  find the root. To indicate "equal priority", specify items
                  in a nested list <code>{ { 'a.txt', 'b.lua' }, … }</code>. A function
                  item must return true if <code>name</code> and <code>path</code> are a match. Each
                  item (which may itself be a nested list) is evaluated
                  in-order against all ancestors, until a match is found.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string?</code>) Directory path containing one of the given markers, or nil
        if no directory was found.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.glob" class="help-heading">Lua module: vim.glob<span class="help-heading-tags">                                                <span id="vim.glob" class="help-tag"><a href="#vim.glob">vim.glob</a></span></h2>


</div>
<div class="help-para">
Glob-to-LPeg Converter (Peglob) This module converts glob patterns to LPeg
patterns according to the LSP 3.17 specification:
<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern">https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#pattern</a>

</div>
<div class="help-para">
Glob grammar overview:
<div class="help-li" style=""> <code>*</code> to match zero or more characters in a path segment
</div><div class="help-li" style=""> <code>?</code> to match on one character in a path segment
</div><div class="help-li" style=""> <code>**</code> to match any number of path segments, including none
</div><div class="help-li" style=""> <code>{}</code> to group conditions (e.g. <code>*.{ts,js}</code> matches TypeScript and JavaScript
  files)
</div><div class="help-li" style=""> <code>[]</code> to declare a range of characters to match in a path segment (e.g.,
  <code>example.[0-9]</code> to match on <code>example.0</code>, <code>example.1</code>, …)
</div><div class="help-li" style=""> <code>[!...]</code> to negate a range of characters to match in a path segment (e.g.,
  <code>example.[!0-9]</code> to match on <code>example.a</code>, <code>example.b</code>, but not <code>example.0</code>)
</div>
</div>
<div class="help-para">
Additional constraints:
<div class="help-li" style=""> A Glob pattern must match an entire path, with partial matches considered
  failures.
</div><div class="help-li" style=""> The pattern only determines success or failure, without specifying which
  parts correspond to which characters.
</div><div class="help-li" style=""> A path segment is the portion of a path between two adjacent path separators
  (<code>/</code>), or between the start/end of the path and the nearest separator.
</div><div class="help-li" style=""> The <code>**</code> (globstar) pattern matches zero or more path segments, including
  intervening separators (<code>/</code>). Within pattern strings, <code>**</code> must be delimited
  by path separators (<code>/</code>) or pattern boundaries and cannot be adjacent to any
  characters other than <code>/</code>. If <code>**</code> is not the final element, it must be
  followed by <code>/</code>.
</div><div class="help-li" style=""> <code>{}</code> (braced conditions) contains valid Glob patterns as branches, separated
  by commas. Commas are exclusively used for separating branches and cannot
  appear within a branch for any other purpose. Nested <code>{}</code> structures are
  allowed, but <code>{}</code> must contain at least two branches—zero or one branch is
  not permitted.
</div><div class="help-li" style=""> In <code>[]</code> or <code>[!...]</code>, a character range consists of character intervals
  (e.g., <code>a-z</code>) or individual characters (e.g., <code>w</code>). A range including <code>/</code>
  won’t match that character.
</div>
</div>
<div class="help-para">
vim.glob.to_lpeg(<code>{pattern}</code>)                               <span id="vim.glob.to_lpeg()" class="help-tag-right"><a href="#vim.glob.to_lpeg()">vim.glob.to_lpeg()</a></span><br>
    Parses a raw glob into an <a href="lua.html#lua-lpeg">lua-lpeg</a> pattern.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pattern}</code>  (<code>string</code>) The raw glob pattern
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>) An <a href="lua.html#lua-lpeg">lua-lpeg</a> representation of the pattern

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.hl" class="help-heading">Lua module: vim.hl<span class="help-heading-tags">                                                    <span id="vim.hl" class="help-tag"><a href="#vim.hl">vim.hl</a></span></h2>


</div>
<div class="help-para">
vim.hl.on_yank(<code>{opts}</code>)                                      <span id="vim.hl.on_yank()" class="help-tag-right"><a href="#vim.hl.on_yank()">vim.hl.on_yank()</a></span><br>
    Highlight the yanked text during a <a href="autocmd.html#TextYankPost">TextYankPost</a> event.

</div>
<div class="help-para">
    Add the following to your <code>init.vim</code>:<pre><code class="language-vim">autocmd TextYankPost * silent! lua vim.hl.on_yank {higroup='Visual', timeout=300}</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional parameters
</div><div class="help-li" style="margin-left: 3rem;"> higroup highlight group for yanked region (default
                  "IncSearch")
</div><div class="help-li" style="margin-left: 3rem;"> timeout time in ms before highlight is cleared (default 150)
</div><div class="help-li" style="margin-left: 3rem;"> on_macro highlight when executing macro (default false)
</div><div class="help-li" style="margin-left: 3rem;"> on_visual highlight when yanking visual selection (default
                  true)
</div><div class="help-li" style="margin-left: 3rem;"> event event structure (default vim.v.event)
</div><div class="help-li" style="margin-left: 3rem;"> priority integer priority (default
                  <a href="lua.html#vim.hl.priorities">vim.hl.priorities</a><code>.user</code>)
</div>
</div>
<div class="help-para">
vim.hl.priorities                                          <span id="vim.hl.priorities" class="help-tag-right"><a href="#vim.hl.priorities">vim.hl.priorities</a></span><br>
    Table with default priorities used for highlighting:
<div class="help-li" style=""> <code>syntax</code>: <code>50</code>, used for standard syntax highlighting
</div><div class="help-li" style=""> <code>treesitter</code>: <code>100</code>, used for treesitter-based highlighting
</div><div class="help-li" style=""> <code>semantic_tokens</code>: <code>125</code>, used for LSP semantic token highlighting
</div><div class="help-li" style=""> <code>diagnostics</code>: <code>150</code>, used for code analysis such as diagnostics
</div><div class="help-li" style=""> <code>user</code>: <code>200</code>, used for user-triggered highlights such as LSP document
      symbols or <code>on_yank</code> autocommands
</div>
</div>
<div class="help-para">
                                                              <span id="vim.hl.range()" class="help-tag-right"><a href="#vim.hl.range()">vim.hl.range()</a></span><br>
vim.hl.range(<code>{bufnr}</code>, <code>{ns}</code>, <code>{higroup}</code>, <code>{start}</code>, <code>{finish}</code>, <code>{opts}</code>)
    Apply highlight group to range of text.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>    (<code>integer</code>) Buffer number to apply highlighting to
</div><div class="help-li" style=""> <code>{ns}</code>       (<code>integer</code>) Namespace to add highlight to
</div><div class="help-li" style=""> <code>{higroup}</code>  (<code>string</code>) Highlight group to use for highlighting
</div><div class="help-li" style=""> <code>{start}</code>    (<code>[integer,integer]|string</code>) Start of region as a (line,
                   column) tuple or string accepted by <a href="vimfn.html#getpos()">getpos()</a>
</div><div class="help-li" style=""> <code>{finish}</code>   (<code>[integer,integer]|string</code>) End of region as a (line,
                   column) tuple or string accepted by <a href="vimfn.html#getpos()">getpos()</a>
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{regtype}?</code> (<code>string</code>, default: <code>'v'</code> i.e. charwise) Type
                     of range. See <a href="vimfn.html#getregtype()">getregtype()</a>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{inclusive}?</code> (<code>boolean</code>, default: <code>false</code>) Indicates
                     whether the range is end-inclusive
</div><div class="help-li" style="margin-left: 3rem;"> <code>{priority}?</code> (<code>integer</code>, default:
                     <code>vim.hl.priorities.user</code>) Highlight priority
</div><div class="help-li" style="margin-left: 3rem;"> <code>{timeout}?</code> (<code>integer</code>, default: -1 no timeout) Time in ms
                     before highlight is cleared
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>uv.uv_timer_t?</code>) range_timer A timer which manages how much time the
        highlight has left
        (<code>fun()?</code>) range_clear A function which allows clearing the highlight
        manually. nil is returned if timeout is not specified

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.iter" class="help-heading">Lua module: vim.iter<span class="help-heading-tags">                                                <span id="vim.iter" class="help-tag"><a href="#vim.iter">vim.iter</a></span></h2>


</div>
<div class="help-para">
<span id="vim.iter()" class="help-tag"><a href="#vim.iter()">vim.iter()</a></span> is an interface for <a href="lua.html#iterable">iterable</a>s: it wraps a table or function
argument into an <span id="Iter" class="help-tag"><a href="#Iter">Iter</a></span> object with methods (such as <a href="lua.html#Iter%3Afilter()">Iter:filter()</a> and
<a href="lua.html#Iter%3Amap()">Iter:map()</a>) that transform the underlying source data. These methods can be
chained to create iterator "pipelines": the output of each pipeline stage is
input to the next stage. The first stage depends on the type passed to
<code>vim.iter()</code>:
<div class="help-li" style=""> Lists or arrays (<a href="lua.html#lua-list">lua-list</a>) yield only the value of each element.
</div><div class="help-li" style="margin-left: 3rem;"> Holes (nil values) are allowed (but discarded).
</div><div class="help-li" style="margin-left: 3rem;"> Use pairs() to treat array/list tables as dicts (preserve holes and
    non-contiguous integer keys): <code>vim.iter(pairs(…))</code>.
</div><div class="help-li" style="margin-left: 3rem;"> Use <a href="lua.html#Iter%3Aenumerate()">Iter:enumerate()</a> to also pass the index to the next stage.
</div><div class="help-li" style="margin-left: 4rem;"> Or initialize with ipairs(): <code>vim.iter(ipairs(…))</code>.
</div><div class="help-li" style=""> Non-list tables (<a href="lua.html#lua-dict">lua-dict</a>) yield both the key and value of each element.
</div><div class="help-li" style=""> Function <a href="lua.html#iterator">iterator</a>s yield all values returned by the underlying function.
</div><div class="help-li" style=""> Tables with a <a href="luaref.html#__call()">__call()</a> metamethod are treated as function iterators.
</div>
</div>
<div class="help-para">
The iterator pipeline terminates when the underlying <a href="lua.html#iterable">iterable</a> is exhausted
(for function iterators this means it returned nil).

</div>
<div class="help-para">
<b>Note:</b> <code>vim.iter()</code> scans table input to decide if it is a list or a dict; to
avoid this cost you can wrap the table with an iterator e.g.
<code>vim.iter(ipairs({…}))</code>, but that precludes the use of <a href="lua.html#list-iterator">list-iterator</a>
operations such as <a href="lua.html#Iter%3Arev()">Iter:rev()</a>).

</div>
<div class="help-para">
Examples:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4, 5 })
it:map(function(v)
  return v * 3
end)
it:rev()
it:skip(2)
it:totable()
-- { 9, 6, 3 }
-- ipairs() is a function iterator which returns both the index (i) and the value (v)
vim.iter(ipairs({ 1, 2, 3, 4, 5 })):map(function(i, v)
  if i &gt; 2 then return v end
end):totable()
-- { 3, 4, 5 }
local it = vim.iter(vim.gsplit('1,2,3,4,5', ','))
it:map(function(s) return tonumber(s) end)
for i, d in it:enumerate() do
  print(string.format("Column %d is %d", i, d))
end
-- Column 1 is 1
-- Column 2 is 2
-- Column 3 is 3
-- Column 4 is 4
-- Column 5 is 5
vim.iter({ a = 1, b = 2, c = 3, z = 26 }):any(function(k, v)
  return k == 'z'
end)
-- true
local rb = vim.ringbuf(3)
rb:push("a")
rb:push("b")
vim.iter(rb):totable()
-- { "a", "b" }</code></pre>

</div>
<div class="help-para">
Iter:all(<code>{pred}</code>)                                                  <span id="Iter%3Aall()" class="help-tag-right"><a href="#Iter%3Aall()">Iter:all()</a></span><br>
    Returns true if all items in the iterator match the given predicate.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pred}</code>  (<code>fun(...):boolean</code>) Predicate function. Takes all values
                returned from the previous stage in the pipeline as arguments
                and returns true if the predicate matches.
</div>
</div>
<div class="help-para">
Iter:any(<code>{pred}</code>)                                                  <span id="Iter%3Aany()" class="help-tag-right"><a href="#Iter%3Aany()">Iter:any()</a></span><br>
    Returns true if any of the items in the iterator match the given
    predicate.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pred}</code>  (<code>fun(...):boolean</code>) Predicate function. Takes all values
                returned from the previous stage in the pipeline as arguments
                and returns true if the predicate matches.
</div>
</div>
<div class="help-para">
Iter:each(<code>{f}</code>)                                                   <span id="Iter%3Aeach()" class="help-tag-right"><a href="#Iter%3Aeach()">Iter:each()</a></span><br>
    Calls a function once for each item in the pipeline, draining the
    iterator.

</div>
<div class="help-para">
    For functions with side effects. To modify the values in the iterator, use
    <a href="lua.html#Iter%3Amap()">Iter:map()</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>fun(...)</code>) Function to execute for each item in the pipeline.
             Takes all of the values returned by the previous stage in the
             pipeline as arguments.
</div>
</div>
<div class="help-para">
Iter:enumerate()                                            <span id="Iter%3Aenumerate()" class="help-tag-right"><a href="#Iter%3Aenumerate()">Iter:enumerate()</a></span><br>
    Yields the item index (count) and value for each item of an iterator
    pipeline.

</div>
<div class="help-para">
    For list tables, this is more efficient:<pre><code class="language-lua">vim.iter(ipairs(t))</code></pre>

</div>
<div class="help-para">
    instead of:<pre><code class="language-lua">vim.iter(t):enumerate()</code></pre>

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(vim.gsplit('abc', '')):enumerate()
it:next()
-- 1	'a'
it:next()
-- 2	'b'
it:next()
-- 3	'c'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:filter(<code>{f}</code>)                                               <span id="Iter%3Afilter()" class="help-tag-right"><a href="#Iter%3Afilter()">Iter:filter()</a></span><br>
    Filters an iterator pipeline.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>fun(...):boolean</code>) Takes all values returned from the previous
             stage in the pipeline and returns false or nil if the current
             iterator element should be removed.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:find(<code>{f}</code>)                                                   <span id="Iter%3Afind()" class="help-tag-right"><a href="#Iter%3Afind()">Iter:find()</a></span><br>
    Find the first value in the iterator that satisfies the given predicate.

</div>
<div class="help-para">
    Advances the iterator. Returns nil and drains the iterator if no value is
    found.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:find(12)
-- 12
local it = vim.iter({ 3, 6, 9, 12 })
it:find(20)
-- nil
local it = vim.iter({ 3, 6, 9, 12 })
it:find(function(v) return v % 4 == 0 end)
-- 12</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:flatten(<code>{depth}</code>)                                         <span id="Iter%3Aflatten()" class="help-tag-right"><a href="#Iter%3Aflatten()">Iter:flatten()</a></span><br>
    Flattens a <a href="lua.html#list-iterator">list-iterator</a>, un-nesting nested values up to the given
    <code>{depth}</code>. Errors if it attempts to flatten a dict-like value.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.iter({ 1, { 2 }, { { 3 } } }):flatten():totable()
-- { 1, 2, { 3 } }
vim.iter({1, { { a = 2 } }, { 3 } }):flatten():totable()
-- { 1, { a = 2 }, 3 }
vim.iter({ 1, { { a = 2 } }, { 3 } }):flatten(math.huge):totable()
-- error: attempt to flatten a dict-like table</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{depth}</code>  (<code>number?</code>) Depth to which <a href="lua.html#list-iterator">list-iterator</a> should be
                 flattened (defaults to 1)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:fold(<code>{init}</code>, <code>{f}</code>)                                           <span id="Iter%3Afold()" class="help-tag-right"><a href="#Iter%3Afold()">Iter:fold()</a></span><br>
    Folds ("reduces") an iterator into a single value.         <span id="Iter%3Areduce()" class="help-tag-right"><a href="#Iter%3Areduce()">Iter:reduce()</a></span><br>

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Create a new table with only even values
vim.iter({ a = 1, b = 2, c = 3, d = 4 })
  :filter(function(k, v) return v % 2 == 0 end)
  :fold({}, function(acc, k, v)
    acc[k] = v
    return acc
  end) --&gt; { b = 2, d = 4 }
-- Get the "maximum" item of an iterable.
vim.iter({ -99, -4, 3, 42, 0, 0, 7 })
  :fold({}, function(acc, v)
    acc.max = math.max(v, acc.max or v)
    return acc
  end) --&gt; { max = 42 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{init}</code>  (<code>any</code>) Initial value of the accumulator.
</div><div class="help-li" style=""> <code>{f}</code>     (<code>fun(acc:A, ...):A</code>) Accumulation function.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:join(<code>{delim}</code>)                                               <span id="Iter%3Ajoin()" class="help-tag-right"><a href="#Iter%3Ajoin()">Iter:join()</a></span><br>
    Collect the iterator into a delimited string.

</div>
<div class="help-para">
    Each element in the iterator is joined into a string separated by <code>{delim}</code>.

</div>
<div class="help-para">
    Consumes the iterator.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{delim}</code>  (<code>string</code>) Delimiter
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
Iter:last()                                                      <span id="Iter%3Alast()" class="help-tag-right"><a href="#Iter%3Alast()">Iter:last()</a></span><br>
    Drains the iterator and returns the last item.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(vim.gsplit('abcdefg', ''))
it:last()
-- 'g'
local it = vim.iter({ 3, 6, 9, 12, 15 })
it:last()
-- 15</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Arpeek()">Iter:rpeek()</a>
</div>
</div>
<div class="help-para">
Iter:map(<code>{f}</code>)                                                     <span id="Iter%3Amap()" class="help-tag-right"><a href="#Iter%3Amap()">Iter:map()</a></span><br>
    Maps the items of an iterator pipeline to the values returned by <code>f</code>.

</div>
<div class="help-para">
    If the map function returns nil, the value is filtered from the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4 }):map(function(v)
  if v % 2 == 0 then
    return v * 3
  end
end)
it:totable()
-- { 6, 12 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>fun(...):...:any</code>) Mapping function. Takes all values returned
             from the previous stage in the pipeline as arguments and returns
             one or more new values, which are used in the next pipeline
             stage. Nil return values are filtered from the output.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:next()                                                      <span id="Iter%3Anext()" class="help-tag-right"><a href="#Iter%3Anext()">Iter:next()</a></span><br>
    Gets the next value from the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(string.gmatch('1 2 3', '%d+')):map(tonumber)
it:next()
-- 1
it:next()
-- 2
it:next()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:nth(<code>{n}</code>)                                                     <span id="Iter%3Anth()" class="help-tag-right"><a href="#Iter%3Anth()">Iter:nth()</a></span><br>
    Gets the nth value of an iterator (and advances to it).

</div>
<div class="help-para">
    If <code>n</code> is negative, offsets from the end of a <a href="lua.html#list-iterator">list-iterator</a>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:nth(2)
-- 6
it:nth(2)
-- 12
local it2 = vim.iter({ 3, 6, 9, 12 })
it2:nth(-2)
-- 9
it2:nth(-2)
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (<code>number</code>) Index of the value to return. May be negative if the
             source is a <a href="lua.html#list-iterator">list-iterator</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:peek()                                                      <span id="Iter%3Apeek()" class="help-tag-right"><a href="#Iter%3Apeek()">Iter:peek()</a></span><br>
    Gets the next value from the iterator without consuming it.

</div>
<div class="help-para">
    The value returned by <a href="lua.html#Iter%3Apeek()">Iter:peek()</a> will be returned again by the next
    call to <a href="lua.html#Iter%3Anext()">Iter:next()</a>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:peek()
-- 3
it:peek()
-- 3
it:next()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:pop()                                                        <span id="Iter%3Apop()" class="help-tag-right"><a href="#Iter%3Apop()">Iter:pop()</a></span><br>
    "Pops" a value from a <a href="lua.html#list-iterator">list-iterator</a> (gets the last value and decrements
    the tail).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({1, 2, 3, 4})
it:pop()
-- 4
it:pop()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
Iter:rev()                                                        <span id="Iter%3Arev()" class="help-tag-right"><a href="#Iter%3Arev()">Iter:rev()</a></span><br>
    Reverses a <a href="lua.html#list-iterator">list-iterator</a> pipeline.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 }):rev()
it:totable()
-- { 12, 9, 6, 3 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:rfind(<code>{f}</code>)                                                 <span id="Iter%3Arfind()" class="help-tag-right"><a href="#Iter%3Arfind()">Iter:rfind()</a></span><br>
    Gets the first value satisfying a predicate, from the end of a
    <a href="lua.html#list-iterator">list-iterator</a>.

</div>
<div class="help-para">
    Advances the iterator. Returns nil and drains the iterator if no value is
    found.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 2, 1 }):enumerate()
it:rfind(1)
-- 5	1
it:rfind(1)
-- 1	1</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Afind()">Iter:find()</a>
</div>
</div>
<div class="help-para">
Iter:rpeek()                                                    <span id="Iter%3Arpeek()" class="help-tag-right"><a href="#Iter%3Arpeek()">Iter:rpeek()</a></span><br>
    Gets the last value of a <a href="lua.html#list-iterator">list-iterator</a> without consuming it.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({1, 2, 3, 4})
it:rpeek()
-- 4
it:rpeek()
-- 4
it:pop()
-- 4</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Alast()">Iter:last()</a>
</div>
</div>
<div class="help-para">
Iter:rskip(<code>{n}</code>)                                                 <span id="Iter%3Arskip()" class="help-tag-right"><a href="#Iter%3Arskip()">Iter:rskip()</a></span><br>
    Discards <code>n</code> values from the end of a <a href="lua.html#list-iterator">list-iterator</a> pipeline.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4, 5 }):rskip(2)
it:next()
-- 1
it:pop()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (<code>number</code>) Number of values to skip.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:skip(<code>{n}</code>)                                                   <span id="Iter%3Askip()" class="help-tag-right"><a href="#Iter%3Askip()">Iter:skip()</a></span><br>
    Skips <code>n</code> values of an iterator pipeline, or skips values while a
    predicate returns <a href="lua.html#lua-truthy">lua-truthy</a>.

</div>
<div class="help-para">
    When a predicate is used, skipping stops at the first value for which the
    predicate returns non-truthy. That value is not consumed and will be
    returned by the next call to <a href="lua.html#Iter%3Anext()">Iter:next()</a>

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 }):skip(2)
it:next()
-- 9
local function pred(x) return x &lt; 10 end
local it2 = vim.iter({ 3, 6, 9, 12 }):skip(pred)
it2:next()
-- 12</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (<code>integer|fun(...):boolean</code>) Number of values to skip or a
             predicate.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:slice(<code>{first}</code>, <code>{last}</code>)                                     <span id="Iter%3Aslice()" class="help-tag-right"><a href="#Iter%3Aslice()">Iter:slice()</a></span><br>
    Sets the start and end of a <a href="lua.html#list-iterator">list-iterator</a> pipeline.

</div>
<div class="help-para">
    Equivalent to <code>:skip(first - 1):rskip(len - last + 1)</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{first}</code>  (<code>number</code>)
</div><div class="help-li" style=""> <code>{last}</code>   (<code>number</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:take(<code>{n}</code>)                                                   <span id="Iter%3Atake()" class="help-tag-right"><a href="#Iter%3Atake()">Iter:take()</a></span><br>
    Transforms an iterator to yield only the first n values, or all values
    satisfying a predicate.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4 }):take(2)
it:next()
-- 1
it:next()
-- 2
it:next()
-- nil
local function pred(x) return x &lt; 2 end
local it2 = vim.iter({ 1, 2, 3, 4 }):take(pred)
it2:next()
-- 1
it2:next()
-- nil</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (<code>integer|fun(...):boolean</code>) Number of values to take or a
             predicate.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
Iter:totable()                                                <span id="Iter%3Atotable()" class="help-tag-right"><a href="#Iter%3Atotable()">Iter:totable()</a></span><br>
    Collect the iterator into a table.

</div>
<div class="help-para">
    The resulting table depends on the initial source in the iterator
    pipeline. Array-like tables and function iterators will be collected into
    an array-like table. If multiple values are returned from the final stage
    in the iterator pipeline, each value will be included in a table.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.iter(string.gmatch('100 20 50', '%d+')):map(tonumber):totable()
-- { 100, 20, 50 }
vim.iter({ 1, 2, 3 }):map(function(v) return v, 2 * v end):totable()
-- { { 1, 2 }, { 2, 4 }, { 3, 6 } }
vim.iter({ a = 1, b = 2, c = 3 }):filter(function(k, v) return v % 2 ~= 0 end):totable()
-- { { 'a', 1 }, { 'c', 3 } }</code></pre>

</div>
<div class="help-para">
    The generated table is an array-like table with consecutive, numeric
    indices. To create a map-like table with arbitrary keys, use
    <a href="lua.html#Iter%3Afold()">Iter:fold()</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table</code>)

</div>
<div class="help-para">
Iter:unique(<code>{key}</code>)                                             <span id="Iter%3Aunique()" class="help-tag-right"><a href="#Iter%3Aunique()">Iter:unique()</a></span><br>
    Removes duplicate values from an iterator pipeline.

</div>
<div class="help-para">
    Only the first occurrence of each value is kept.

</div>
<div class="help-para">
    Accepts an optional <code>key</code> argument, which if provided is called for each
    value in the iterator to compute a hash key for uniqueness comparison.
    This is useful for deduplicating table values or complex objects. If <code>key</code>
    returns <code>nil</code> for a value, that value will be considered unique, even if
    multiple values return <code>nil</code>.

</div>
<div class="help-para">
    If a function-based iterator returns multiple arguments, uniqueness is
    checked based on the first return value. To change this behavior, specify
    <code>key</code>.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.iter({ 1, 2, 2, 3, 2 }):unique():totable()
-- { 1, 2, 3 }
vim.iter({ {id=1}, {id=2}, {id=1} })
  :unique(function(x)
    return x.id
  end)
  :totable()
-- { {id=1}, {id=2} }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{key}</code>  (<code>fun(...):any?</code>) Optional hash function to determine
               uniqueness of values.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>Iter</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.list.unique()">vim.list.unique()</a>
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.json" class="help-heading">Lua module: vim.json<span class="help-heading-tags">                                                <span id="vim.json" class="help-tag"><a href="#vim.json">vim.json</a></span></h2>


</div>
<div class="help-para">
This module provides encoding and decoding of Lua objects to and from
JSON-encoded strings. Supports <a href="lua.html#vim.NIL">vim.NIL</a> and <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.

</div>
<div class="help-para">
vim.json.decode(<code>{str}</code>, <code>{opts}</code>)                             <span id="vim.json.decode()" class="help-tag-right"><a href="#vim.json.decode()">vim.json.decode()</a></span><br>
    Decodes (or "unpacks") stringified JSON to a Lua object.
<div class="help-li" style=""> Decodes JSON "null" as <a href="lua.html#vim.NIL">vim.NIL</a> (controllable by <code>{opts}</code>, see below).
</div><div class="help-li" style=""> Decodes empty object as <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.
</div><div class="help-li" style=""> Decodes empty array as <code>{}</code> (empty Lua table).
</div>
</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.print(vim.json.decode('{"bar":[],"foo":{},"zub":null}'))
-- { bar = {}, foo = vim.empty_dict(), zub = vim.NIL }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>   (<code>string</code>) Stringified JSON data.
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{luanil}?</code> (<code>{ object?: boolean, array?: boolean }</code>, default:
                  <code>nil</code>) Convert <code>null</code> in JSON objects and/or arrays to Lua
                  <code>nil</code> instead of <a href="lua.html#vim.NIL">vim.NIL</a>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{skip_comments}?</code> (<code>boolean</code>, default: <code>false</code>) Allows
                  JavaScript-style comments within JSON data. Comments are
                  treated as whitespace and may appear anywhere whitespace is
                  valid in JSON. Supports single-line comments beginning with
                  '//' and block comments enclosed with '/' and '/'.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
vim.json.encode(<code>{obj}</code>, <code>{opts}</code>)                             <span id="vim.json.encode()" class="help-tag-right"><a href="#vim.json.encode()">vim.json.encode()</a></span><br>
    Encodes (or "packs") a Lua object to stringified JSON.

</div>
<div class="help-para">
    Example: Implement a basic <a href="options.html#'formatexpr'">'formatexpr'</a> for JSON, so <a href="change.html#gq">gq</a> with a motion
    formats JSON in a buffer. (The motion must operate on a valid JSON
    object.)<pre><code class="language-lua">function _G.fmt_json()
  local indent = vim.bo.expandtab and (' '):rep(vim.o.shiftwidth) or '\t'
  local lines = vim.api.nvim_buf_get_lines(0, vim.v.lnum - 1, vim.v.lnum + vim.v.count - 1, true)
  local o = vim.json.decode(table.concat(lines, '\n'))
  local stringified = vim.json.encode(o, { indent = indent, sort_keys = true })
  lines = vim.split(stringified, '\n')
  vim.api.nvim_buf_set_lines(0, vim.v.lnum - 1, vim.v.count, true, lines)
end
vim.o.formatexpr = 'v:lua.fmt_json()'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{obj}</code>   (<code>any</code>)
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{escape_slash}?</code> (<code>boolean</code>, default: <code>false</code>) Escape slash
                  characters "/" in string values.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{indent}?</code> (<code>string</code>, default: <code>""</code>) If non-empty, the
                  returned JSON is formatted with newlines and whitespace,
                  where <code>indent</code> defines the whitespace at each nesting level.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{sort_keys}?</code> (<code>boolean</code>, default: <code>false</code>) Sort object keys
                  in alphabetical order.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.keymap" class="help-heading">Lua module: vim.keymap<span class="help-heading-tags">                                            <span id="vim.keymap" class="help-tag"><a href="#vim.keymap">vim.keymap</a></span></h2>


</div>
<div class="help-para">
vim.keymap.del(<code>{modes}</code>, <code>{lhs}</code>, <code>{opts}</code>)                      <span id="vim.keymap.del()" class="help-tag-right"><a href="#vim.keymap.del()">vim.keymap.del()</a></span><br>
    Remove an existing mapping. Examples:<pre><code class="language-lua">vim.keymap.del('n', 'lhs')
vim.keymap.del({'n', 'i', 'v'}, '&lt;leader&gt;w', { buffer = 5 })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{modes}</code>  (<code>string|string[]</code>)
</div><div class="help-li" style=""> <code>{lhs}</code>    (<code>string</code>)
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{buffer}?</code> (<code>integer|boolean</code>) Remove a mapping from the
                   given buffer. When <code>0</code> or <code>true</code>, use the current buffer.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.keymap.set()">vim.keymap.set()</a>
</div>
</div>
<div class="help-para">
vim.keymap.set(<code>{modes}</code>, <code>{lhs}</code>, <code>{rhs}</code>, <code>{opts}</code>)               <span id="vim.keymap.set()" class="help-tag-right"><a href="#vim.keymap.set()">vim.keymap.set()</a></span><br>
    Defines a <a href="map.html#mapping">mapping</a> of <a href="intro.html#keycodes">keycodes</a> to a function or keycodes.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Map "x" to a Lua function:
vim.keymap.set('n', 'x', function() print('real lua function') end)
-- Map "&lt;leader&gt;x" to multiple modes for the current buffer:
vim.keymap.set({'n', 'v'}, '&lt;leader&gt;x', vim.lsp.buf.references, { buffer = true })
-- Map &lt;Tab&gt; to an expression (|:map-&lt;expr&gt;|):
vim.keymap.set('i', '&lt;Tab&gt;', function()
  return vim.fn.pumvisible() == 1 and '&lt;C-n&gt;' or '&lt;Tab&gt;'
end, { expr = true })
-- Map "[%%" to a &lt;Plug&gt; mapping:
vim.keymap.set('n', '[%%', '&lt;Plug&gt;(MatchitNormalMultiBackward)')
-- Use `getregionpos(getpos('v'))` to get the "current visual selection":
vim.keymap.set('x', 'M', function()
  local region = vim.fn.getregionpos(vim.fn.getpos('v'), vim.fn.getpos('.'), {
    type = 'v',
    exclusive = false,
    eol = false,
  })
  local line1 = region[1][1][2]
  local line2 = region[#region][1][2]
  vim.print({ line1, line2 })
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{modes}</code>  (<code>string|string[]</code>) Mode "short-name" (see
                 <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a>), or a list thereof.
</div><div class="help-li" style=""> <code>{lhs}</code>    (<code>string</code>) Left-hand side <a href="map.html#%7Blhs%7D">{lhs}</a> of the mapping.
</div><div class="help-li" style=""> <code>{rhs}</code>    (<code>string|function</code>) Right-hand side <a href="map.html#%7Brhs%7D">{rhs}</a> of the mapping,
                 can be a Lua function.
</div><div class="help-li" style=""> <code>{opts}</code>   (<code>table?</code>) Table of <a href="map.html#%3Amap-arguments">:map-arguments</a>. Same as
                 <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a> <code>{opts}</code>, except:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{replace_keycodes}</code> defaults to <code>true</code> if "expr" is <code>true</code>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{noremap}</code> is not supported; use <code>{remap}</code> instead (see
                   below).
</div>
</div>
<div class="help-para">
                 Also accepts:
<div class="help-li" style=""> <code>{buffer}?</code> (<code>integer|boolean</code>) Creates buffer-local mapping,
                   <code>0</code> or <code>true</code> for current buffer.
</div><div class="help-li" style=""> <code>{remap}?</code> (<code>boolean</code>, default: <code>false</code>) Make the mapping
                   recursive. Inverse of <code>{noremap}</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a>
</div><div class="help-li" style=""> <a href="vimfn.html#maparg()">maparg()</a>
</div><div class="help-li" style=""> <a href="vimfn.html#mapcheck()">mapcheck()</a>
</div><div class="help-li" style=""> <a href="vimfn.html#mapset()">mapset()</a>
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.loader" class="help-heading">Lua module: vim.loader<span class="help-heading-tags">                                            <span id="vim.loader" class="help-tag"><a href="#vim.loader">vim.loader</a></span></h2>


</div>
<div class="help-para">
vim.loader.enable(<code>{enable}</code>)                              <span id="vim.loader.enable()" class="help-tag-right"><a href="#vim.loader.enable()">vim.loader.enable()</a></span><br>
<b>    WARNING:</b> This feature is experimental/unstable.

</div>
<div class="help-para">
    Enables or disables the experimental Lua module loader:

</div>
<div class="help-para">
    Enable (<code>enable=true</code>):
<div class="help-li" style=""> overrides <a href="luaref.html#loadfile()">loadfile()</a>
</div><div class="help-li" style=""> adds the Lua loader using the byte-compilation cache
</div><div class="help-li" style=""> adds the libs loader
</div><div class="help-li" style=""> removes the default Nvim loader
</div>
</div>
<div class="help-para">
    Disable (<code>enable=false</code>):
<div class="help-li" style=""> removes the loaders
</div><div class="help-li" style=""> adds the default Nvim loader
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{enable}</code>  (<code>boolean?</code>) true/nil to enable, false to disable
</div>
</div>
<div class="help-para">
vim.loader.find(<code>{modname}</code>, <code>{opts}</code>)                         <span id="vim.loader.find()" class="help-tag-right"><a href="#vim.loader.find()">vim.loader.find()</a></span><br>
<b>    WARNING:</b> This feature is experimental/unstable.

</div>
<div class="help-para">
    Finds Lua modules for the given module name.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{modname}</code>  (<code>string</code>) Module name, or <code>"*"</code> to find the top-level
                   modules instead
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table?</code>) Options for finding a module:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{rtp}?</code> (<code>boolean</code>, default: <code>true</code>) Search for modname in
                     the runtime path.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{paths}?</code> (<code>string[]</code>, default: <code>{}</code>) Extra paths to
                     search for modname
</div><div class="help-li" style="margin-left: 3rem;"> <code>{patterns}?</code> (<code>string[]</code>, default:
                     <code>{"/init.lua", ".lua"}</code>) List of patterns to use when
                     searching for modules. A pattern is a string added to the
                     basename of the Lua module being searched.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{all}?</code> (<code>boolean</code>, default: <code>false</code>) Search for all
                     matches.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>table[]</code>) A list of objects with the following fields:
<div class="help-li" style=""> <code>{modpath}</code> (<code>string</code>) Path of the module
</div><div class="help-li" style=""> <code>{modname}</code> (<code>string</code>) Name of the module
</div><div class="help-li" style=""> <code>{stat}?</code> (<code>uv.fs_stat.result</code>) The fs_stat of the module path. Won't
          be returned for <code>modname="*"</code>
</div>
</div>
<div class="help-para">
vim.loader.reset(<code>{path}</code>)                                  <span id="vim.loader.reset()" class="help-tag-right"><a href="#vim.loader.reset()">vim.loader.reset()</a></span><br>
<b>    WARNING:</b> This feature is experimental/unstable.

</div>
<div class="help-para">
    Resets the cache for the path, or all the paths if path is nil.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string?</code>) path to reset
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.lpeg" class="help-heading">Lua module: vim.lpeg<span class="help-heading-tags">                                                <span id="vim.lpeg" class="help-tag"><a href="#vim.lpeg">vim.lpeg</a></span></h2>


</div>
<div class="help-para">
LPeg is a pattern-matching library for Lua, based on Parsing Expression
Grammars (PEGs). <a href="https://bford.info/packrat/">https://bford.info/packrat/</a>

</div>
<div class="help-para">
                                                   <span id="lua-lpeg" class="help-tag"><a href="#lua-lpeg">lua-lpeg</a></span> <span id="vim.lpeg.Pattern" class="help-tag"><a href="#vim.lpeg.Pattern">vim.lpeg.Pattern</a></span>
The LPeg library for parsing expression grammars is included as <code>vim.lpeg</code>
(<a href="https://www.inf.puc-rio.br/~roberto/lpeg/">https://www.inf.puc-rio.br/~roberto/lpeg/</a>).

</div>
<div class="help-para">
In addition, its regex-like interface is available as <a href="lua.html#vim.re">vim.re</a>
(<a href="https://www.inf.puc-rio.br/~roberto/lpeg/re.html">https://www.inf.puc-rio.br/~roberto/lpeg/re.html</a>).

</div>
<div class="help-para">
Pattern:match(<code>{subject}</code>, <code>{init}</code>, <code>{...}</code>)                      <span id="Pattern%3Amatch()" class="help-tag-right"><a href="#Pattern%3Amatch()">Pattern:match()</a></span><br>
    Matches the given <code>pattern</code> against the <code>subject</code> string. If the match
    succeeds, returns the index in the subject of the first character after
    the match, or the captured values (if the pattern captured any value). An
    optional numeric argument <code>init</code> makes the match start at that position in
    the subject string. As usual in Lua libraries, a negative value counts
    from the end. Unlike typical pattern-matching functions, <code>match</code> works
    only in anchored mode; that is, it tries to match the pattern with a
    prefix of the given subject string (at position <code>init</code>), not with an
    arbitrary substring of the subject. So, if we want to find a pattern
    anywhere in a string, we must either write a loop in Lua or write a
    pattern that matches anywhere.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local pattern = lpeg.R('az') ^ 1 * -1
assert(pattern:match('hello') == 6)
assert(lpeg.match(pattern, 'hello') == 6)
assert(pattern:match('1 hello') == nil)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{subject}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{init}</code>     (<code>integer?</code>)
</div><div class="help-li" style=""> <code>{...}</code>      (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>) ...

</div>
<div class="help-para">
vim.lpeg.B(<code>{pattern}</code>)                                           <span id="vim.lpeg.B()" class="help-tag-right"><a href="#vim.lpeg.B()">vim.lpeg.B()</a></span><br>
    Returns a pattern that matches only if the input string at the current
    position is preceded by <code>patt</code>. Pattern <code>patt</code> must match only strings
    with some fixed length, and it cannot contain captures. Like the <code>and</code>
    predicate, this pattern never consumes any input, independently of success
    or failure.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pattern}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.lpeg.C(<code>{patt}</code>)                                              <span id="vim.lpeg.C()" class="help-tag-right"><a href="#vim.lpeg.C()">vim.lpeg.C()</a></span><br>
    Creates a simple capture, which captures the substring of the subject that
    matches <code>patt</code>. The captured value is a string. If <code>patt</code> has other
    captures, their values are returned after this one.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local function split (s, sep)
  sep = lpeg.P(sep)
  local elem = lpeg.C((1 - sep) ^ 0)
  local p = elem * (sep * elem) ^ 0
  return lpeg.match(p, s)
end
local a, b, c = split('a,b,c', ',')
assert(a == 'a')
assert(b == 'b')
assert(c == 'c')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Carg(<code>{n}</code>)                                           <span id="vim.lpeg.Carg()" class="help-tag-right"><a href="#vim.lpeg.Carg()">vim.lpeg.Carg()</a></span><br>
    Creates an argument capture. This pattern matches the empty string and
    produces the value given as the nth extra argument given in the call to
    <code>lpeg.match</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cb(<code>{name}</code>)                                            <span id="vim.lpeg.Cb()" class="help-tag-right"><a href="#vim.lpeg.Cb()">vim.lpeg.Cb()</a></span><br>
    Creates a back capture. This pattern matches the empty string and produces
    the values produced by the most recent group capture named <code>name</code> (where
    <code>name</code> can be any Lua value). Most recent means the last complete
    outermost group capture with the given name. A Complete capture means that
    the entire pattern corresponding to the capture has matched. An Outermost
    capture means that the capture is not inside another complete capture. In
    the same way that LPeg does not specify when it evaluates captures, it
    does not specify whether it reuses values previously produced by the group
    or re-evaluates them.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{name}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cc(<code>{...}</code>)                                             <span id="vim.lpeg.Cc()" class="help-tag-right"><a href="#vim.lpeg.Cc()">vim.lpeg.Cc()</a></span><br>
    Creates a constant capture. This pattern matches the empty string and
    produces all given values as its captured values.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{...}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cf(<code>{patt}</code>, <code>{func}</code>)                                    <span id="vim.lpeg.Cf()" class="help-tag-right"><a href="#vim.lpeg.Cf()">vim.lpeg.Cf()</a></span><br>
    Creates a fold capture. If <code>patt</code> produces a list of captures C1 C2 ...
    Cn, this capture will produce the value
    <code>func(...func(func(C1, C2), C3)...,Cn)</code>, that is, it will fold (or
    accumulate, or reduce) the captures from <code>patt</code> using function <code>func</code>.
    This capture assumes that <code>patt</code> should produce at least one capture with
    at least one value (of any type), which becomes the initial value of an
    accumulator. (If you need a specific initial value, you may prefix a
    constant capture to <code>patt</code>.) For each subsequent capture, LPeg calls
    <code>func</code> with this accumulator as the first argument and all values produced
    by the capture as extra arguments; the first result from this call becomes
    the new value for the accumulator. The final value of the accumulator
    becomes the captured value.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local number = lpeg.R('09') ^ 1 / tonumber
local list = number * (',' * number) ^ 0
local function add(acc, newvalue) return acc + newvalue end
local sum = lpeg.Cf(list, add)
assert(sum:match('10,30,43') == 83)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div><div class="help-li" style=""> <code>{func}</code>  (<code>fun(acc, newvalue)</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cg(<code>{patt}</code>, <code>{name}</code>)                                    <span id="vim.lpeg.Cg()" class="help-tag-right"><a href="#vim.lpeg.Cg()">vim.lpeg.Cg()</a></span><br>
    Creates a group capture. It groups all values returned by <code>patt</code> into a
    single capture. The group may be anonymous (if no name is given) or named
    with the given name (which can be any non-nil Lua value).

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div><div class="help-li" style=""> <code>{name}</code>  (<code>string?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cmt(<code>{patt}</code>, <code>{fn}</code>)                                    <span id="vim.lpeg.Cmt()" class="help-tag-right"><a href="#vim.lpeg.Cmt()">vim.lpeg.Cmt()</a></span><br>
    Creates a match-time capture. Unlike all other captures, this one is
    evaluated immediately when a match occurs (even if it is part of a larger
    pattern that fails later). It forces the immediate evaluation of all its
    nested captures and then calls <code>function</code>. The given function gets as
    arguments the entire subject, the current position (after the match of
    <code>patt</code>), plus any capture values produced by <code>patt</code>. The first value
    returned by <code>function</code> defines how the match happens. If the call returns
    a number, the match succeeds and the returned number becomes the new
    current position. (Assuming a subject sand current position <code>i</code>, the
    returned number must be in the range <code>[i, len(s) + 1]</code>.) If the call
    returns <code>true</code>, the match succeeds without consuming any input (so, to
    return true is equivalent to return <code>i</code>). If the call returns <code>false</code>,
    <code>nil</code>, or no value, the match fails. Any extra values returned by the
    function become the values produced by the capture.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div><div class="help-li" style=""> <code>{fn}</code>    (<code>fun(s: string, i: integer, ...: any)</code>) (position:
                boolean|integer, ...: any)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cp()                                                  <span id="vim.lpeg.Cp()" class="help-tag-right"><a href="#vim.lpeg.Cp()">vim.lpeg.Cp()</a></span><br>
    Creates a position capture. It matches the empty string and captures the
    position in the subject where the match occurs. The captured value is a
    number.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local I = lpeg.Cp()
local function anywhere(p) return lpeg.P({I * p * I + 1 * lpeg.V(1)}) end
local match_start, match_end = anywhere('world'):match('hello world!')
assert(match_start == 7)
assert(match_end == 12)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Cs(<code>{patt}</code>)                                            <span id="vim.lpeg.Cs()" class="help-tag-right"><a href="#vim.lpeg.Cs()">vim.lpeg.Cs()</a></span><br>
    Creates a substitution capture. This function creates a substitution
    capture, which captures the substring of the subject that matches <code>patt</code>,
    with substitutions. For any capture inside <code>patt</code> with a value, the
    substring that matched the capture is replaced by the capture value (which
    should be a string). The final captured value is the string resulting from
    all replacements.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local function gsub (s, patt, repl)
  patt = lpeg.P(patt)
  patt = lpeg.Cs((patt / repl + 1) ^ 0)
  return lpeg.match(patt, s)
end
assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.Ct(<code>{patt}</code>)                                            <span id="vim.lpeg.Ct()" class="help-tag-right"><a href="#vim.lpeg.Ct()">vim.lpeg.Ct()</a></span><br>
    Creates a table capture. This capture returns a table with all values from
    all anonymous captures made by <code>patt</code> inside this table in successive
    integer keys, starting at 1. Moreover, for each named capture group
    created by <code>patt</code>, the first value of the group is put into the table with
    the group name as its key. The captured value is only the table.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{patt}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Capture</code>)

</div>
<div class="help-para">
vim.lpeg.locale(<code>{tab}</code>)                                     <span id="vim.lpeg.locale()" class="help-tag-right"><a href="#vim.lpeg.locale()">vim.lpeg.locale()</a></span><br>
    Returns a table with patterns for matching some character classes
    according to the current locale. The table has fields named <code>alnum</code>,
    <code>alpha</code>, <code>cntrl</code>, <code>digit</code>, <code>graph</code>, <code>lower</code>, <code>print</code>, <code>punct</code>, <code>space</code>,
    <code>upper</code>, and <code>xdigit</code>, each one containing a correspondent pattern. Each
    pattern matches any single character that belongs to its class. If called
    with an argument <code>table</code>, then it creates those fields inside the given
    table and returns that table.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">lpeg.locale(lpeg)
local space = lpeg.space ^ 0
local name = lpeg.C(lpeg.alpha ^ 1) * space
local sep = lpeg.S(',;') * space
local pair = lpeg.Cg(name * '=' * space * name) * sep ^ -1
local list = lpeg.Cf(lpeg.Ct('') * pair ^ 0, rawset)
local t = list:match('a=b, c = hi; next = pi')
assert(t.a == 'b')
assert(t.c == 'hi')
assert(t.next == 'pi')
local locale = lpeg.locale()
assert(type(locale.digit) == 'userdata')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{tab}</code>  (<code>table?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Locale</code>)

</div>
<div class="help-para">
vim.lpeg.match(<code>{pattern}</code>, <code>{subject}</code>, <code>{init}</code>, <code>{...}</code>)         <span id="vim.lpeg.match()" class="help-tag-right"><a href="#vim.lpeg.match()">vim.lpeg.match()</a></span><br>
    Matches the given <code>pattern</code> against the <code>subject</code> string. If the match
    succeeds, returns the index in the subject of the first character after
    the match, or the captured values (if the pattern captured any value). An
    optional numeric argument <code>init</code> makes the match start at that position in
    the subject string. As usual in Lua libraries, a negative value counts
    from the end. Unlike typical pattern-matching functions, <code>match</code> works
    only in anchored mode; that is, it tries to match the pattern with a
    prefix of the given subject string (at position <code>init</code>), not with an
    arbitrary substring of the subject. So, if we want to find a pattern
    anywhere in a string, we must either write a loop in Lua or write a
    pattern that matches anywhere.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local pattern = lpeg.R('az') ^ 1 * -1
assert(pattern:match('hello') == 6)
assert(lpeg.match(pattern, 'hello') == 6)
assert(pattern:match('1 hello') == nil)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pattern}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div><div class="help-li" style=""> <code>{subject}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{init}</code>     (<code>integer?</code>)
</div><div class="help-li" style=""> <code>{...}</code>      (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>) ...

</div>
<div class="help-para">
vim.lpeg.P(<code>{value}</code>)                                             <span id="vim.lpeg.P()" class="help-tag-right"><a href="#vim.lpeg.P()">vim.lpeg.P()</a></span><br>
    Converts the given value into a proper pattern. The following rules are
    applied:
<div class="help-li" style=""> If the argument is a pattern, it is returned unmodified.
</div><div class="help-li" style=""> If the argument is a string, it is translated to a pattern that matches
      the string literally.
</div><div class="help-li" style=""> If the argument is a non-negative number <code>n</code>, the result is a pattern
      that matches exactly <code>n</code> characters.
</div><div class="help-li" style=""> If the argument is a negative number <code>-n</code>, the result is a pattern that
      succeeds only if the input string has less than <code>n</code> characters left:
      <code>lpeg.P(-n)</code> is equivalent to <code>-lpeg.P(n)</code> (see the unary minus
      operation).
</div><div class="help-li" style=""> If the argument is a boolean, the result is a pattern that always
      succeeds or always fails (according to the boolean value), without
      consuming any input.
</div><div class="help-li" style=""> If the argument is a table, it is interpreted as a grammar (see
      Grammars).
</div><div class="help-li" style=""> If the argument is a function, returns a pattern equivalent to a
      match-time capture over the empty string.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{value}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.lpeg.R(<code>{...}</code>)                                               <span id="vim.lpeg.R()" class="help-tag-right"><a href="#vim.lpeg.R()">vim.lpeg.R()</a></span><br>
    Returns a pattern that matches any single character belonging to one of
    the given ranges. Each <code>range</code> is a string <code>xy</code> of length 2, representing
    all characters with code between the codes of <code>x</code> and <code>y</code> (both
    inclusive). As an example, the pattern <code>lpeg.R('09')</code> matches any digit,
    and <code>lpeg.R('az', 'AZ')</code> matches any ASCII letter.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local pattern = lpeg.R('az') ^ 1 * -1
assert(pattern:match('hello') == 6)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{...}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.lpeg.S(<code>{string}</code>)                                            <span id="vim.lpeg.S()" class="help-tag-right"><a href="#vim.lpeg.S()">vim.lpeg.S()</a></span><br>
    Returns a pattern that matches any single character that appears in the
    given string (the <code>S</code> stands for Set). As an example, the pattern
    <code>lpeg.S('+-*/')</code> matches any arithmetic operator. Note that, if <code>s</code> is a
    character (that is, a string of length 1), then <code>lpeg.P(s)</code> is equivalent
    to <code>lpeg.S(s)</code> which is equivalent to <code>lpeg.R(s..s)</code>. Note also that both
    <code>lpeg.S('')</code> and <code>lpeg.R()</code> are patterns that always fail.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{string}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.lpeg.setmaxstack(<code>{max}</code>)                           <span id="vim.lpeg.setmaxstack()" class="help-tag-right"><a href="#vim.lpeg.setmaxstack()">vim.lpeg.setmaxstack()</a></span><br>
    Sets a limit for the size of the backtrack stack used by LPeg to track
    calls and choices. The default limit is <code>400</code>. Most well-written patterns
    need little backtrack levels and therefore you seldom need to change this
    limit; before changing it you should try to rewrite your pattern to avoid
    the need for extra space. Nevertheless, a few useful patterns may
    overflow. Also, with recursive grammars, subjects with deep recursion may
    also need larger limits.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{max}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
vim.lpeg.type(<code>{value}</code>)                                       <span id="vim.lpeg.type()" class="help-tag-right"><a href="#vim.lpeg.type()">vim.lpeg.type()</a></span><br>
    Returns the string <code>"pattern"</code> if the given value is a pattern, otherwise
    <code>nil</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{value}</code>  (<code>vim.lpeg.Pattern|string|integer|boolean|table|function</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>"pattern"?</code>)

</div>
<div class="help-para">
vim.lpeg.V(<code>{v}</code>)                                                 <span id="vim.lpeg.V()" class="help-tag-right"><a href="#vim.lpeg.V()">vim.lpeg.V()</a></span><br>
    Creates a non-terminal (a variable) for a grammar. This operation creates
    a non-terminal (a variable) for a grammar. The created non-terminal refers
    to the rule indexed by <code>v</code> in the enclosing grammar.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local b = lpeg.P({'(' * ((1 - lpeg.S '()') + lpeg.V(1)) ^ 0 * ')'})
assert(b:match('((string))') == 11)
assert(b:match('(') == nil)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v}</code>  (<code>boolean|string|number|function|table|thread|userdata|lightuserdata</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.lpeg.version()                                        <span id="vim.lpeg.version()" class="help-tag-right"><a href="#vim.lpeg.version()">vim.lpeg.version()</a></span><br>
    Returns a string with the running version of LPeg.

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.mpack" class="help-heading">Lua module: vim.mpack<span class="help-heading-tags">                                              <span id="vim.mpack" class="help-tag"><a href="#vim.mpack">vim.mpack</a></span></h2>


</div>
<div class="help-para">
This module provides encoding and decoding of Lua objects to and from
msgpack-encoded strings. Supports <a href="lua.html#vim.NIL">vim.NIL</a> and <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.

</div>
<div class="help-para">
vim.mpack.decode(<code>{str}</code>)                                   <span id="vim.mpack.decode()" class="help-tag-right"><a href="#vim.mpack.decode()">vim.mpack.decode()</a></span><br>
    Decodes (or "unpacks") the msgpack-encoded <code>{str}</code> to a Lua object.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>any</code>)

</div>
<div class="help-para">
vim.mpack.encode(<code>{obj}</code>)                                   <span id="vim.mpack.encode()" class="help-tag-right"><a href="#vim.mpack.encode()">vim.mpack.encode()</a></span><br>
    Encodes (or "packs") Lua object <code>{obj}</code> as msgpack in a Lua string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{obj}</code>  (<code>any</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.net" class="help-heading">Lua module: vim.net<span class="help-heading-tags">                                                  <span id="vim.net" class="help-tag"><a href="#vim.net">vim.net</a></span></h2>


</div>
<div class="help-para">
vim.net.request(<code>{url}</code>, <code>{opts}</code>, <code>{on_response}</code>)              <span id="vim.net.request()" class="help-tag-right"><a href="#vim.net.request()">vim.net.request()</a></span><br>
    Makes an HTTP GET request to the given URL (asynchronous).

</div>
<div class="help-para">
    This function operates in one mode:
<div class="help-li" style=""> Asynchronous (non-blocking): Returns immediately and passes the response
      object to the provided <code>on_response</code> handler on completion.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{url}</code>          (<code>string</code>) The URL for the request.
</div><div class="help-li" style=""> <code>{opts}</code>         (<code>table?</code>) Optional parameters:
</div><div class="help-li" style="margin-left: 3rem;"> <code>verbose</code> (boolean|nil): Enables verbose output.
</div><div class="help-li" style="margin-left: 3rem;"> <code>retry</code> (integer|nil): Number of retries on transient
                         failures (default: 3).
</div><div class="help-li" style="margin-left: 3rem;"> <code>outpath</code> (string|nil): File path to save the
                         response body to. If set, the <code>body</code> value in the
                         Response Object will be <code>true</code> instead of the
                         response body.
</div><div class="help-li" style=""> <code>{on_response}</code>  (<code>fun(err?: string, response?: { body: string|boolean })</code>)
                       Callback invoked on request completion. The <code>body</code>
                       field in the response object contains the raw response
                       data (text or binary). Called with (err, nil) on
                       failure, or (nil, { body = string|boolean }) on
                       success.
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.pos" class="help-heading">Lua module: vim.pos<span class="help-heading-tags">                                                  <span id="vim.pos" class="help-tag"><a href="#vim.pos">vim.pos</a></span></h2>


</div>
<div class="help-para">
EXPERIMENTAL: This API may change in the future. Its semantics are not yet
finalized. Subscribe to <a href="https://github.com/neovim/neovim/issues/25509">https://github.com/neovim/neovim/issues/25509</a> to stay
updated or contribute to its development.

</div>
<div class="help-para">
Provides operations to compare, calculate, and convert positions represented
by <a href="lua.html#vim.Pos">vim.Pos</a> objects.

</div>
<div class="help-para">
<span id="vim.Pos" class="help-tag"><a href="#vim.Pos">vim.Pos</a></span>
    Represents a well-defined position.

</div>
<div class="help-para">
    A <a href="lua.html#vim.Pos">vim.Pos</a> object contains the <code>{row}</code> and <code>{col}</code> coordinates of a position.
    To create a new <a href="lua.html#vim.Pos">vim.Pos</a> object, call <code>vim.pos()</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local pos1 = vim.pos(3, 5)
local pos2 = vim.pos(4, 0)
-- Operators are overloaded for comparing two `vim.Pos` objects.
if pos1 &lt; pos2 then
  print("pos1 comes before pos2")
end
if pos1 ~= pos2 then
  print("pos1 and pos2 are different positions")
end</code></pre>

</div>
<div class="help-para">
    It may include optional fields that enable additional capabilities, such
    as format conversions.

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{row}</code>         (<code>integer</code>) 0-based byte index.
</div><div class="help-li" style=""> <code>{col}</code>         (<code>integer</code>) 0-based byte index.
</div><div class="help-li" style=""> <code>{buf}?</code>        (<code>integer</code>) Optional buffer handle.
</div>
</div>
<div class="help-para">
                      When specified, it indicates that this position belongs
                      to a specific buffer. This field is required when
                      performing position conversions.
<div class="help-li" style=""> <code>{to_lsp}</code>      (<code>fun(pos: vim.Pos, position_encoding: lsp.PositionEncodingKind)</code>)
                      See <a href="lua.html#Pos%3Ato_lsp()">Pos:to_lsp()</a>.
</div><div class="help-li" style=""> <code>{lsp}</code>         (<code>fun(buf: integer, pos: lsp.Position, position_encoding: lsp.PositionEncodingKind)</code>)
                      See <a href="lua.html#Pos%3Alsp()">Pos:lsp()</a>.
</div><div class="help-li" style=""> <code>{to_cursor}</code>   (<code>fun(pos: vim.Pos): [integer, integer]</code>) See
                      <a href="lua.html#Pos%3Ato_cursor()">Pos:to_cursor()</a>.
</div><div class="help-li" style=""> <code>{cursor}</code>      (<code>fun(pos: [integer, integer])</code>) See <a href="lua.html#Pos%3Acursor()">Pos:cursor()</a>.
</div><div class="help-li" style=""> <code>{to_extmark}</code>  (<code>fun(pos: vim.Pos): [integer, integer]</code>) See
                      <a href="lua.html#Pos%3Ato_extmark()">Pos:to_extmark()</a>.
</div><div class="help-li" style=""> <code>{extmark}</code>     (<code>fun(pos: [integer, integer])</code>) See <a href="lua.html#Pos%3Aextmark()">Pos:extmark()</a>.
</div>
</div>
<div class="help-para">
Pos:cursor(<code>{pos}</code>)                                               <span id="Pos%3Acursor()" class="help-tag-right"><a href="#Pos%3Acursor()">Pos:cursor()</a></span><br>
    Creates a new <a href="lua.html#vim.Pos">vim.Pos</a> from cursor position.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pos}</code>  (<code>[integer, integer]</code>)
</div>
</div>
<div class="help-para">
Pos:extmark(<code>{pos}</code>)                                             <span id="Pos%3Aextmark()" class="help-tag-right"><a href="#Pos%3Aextmark()">Pos:extmark()</a></span><br>
    Creates a new <a href="lua.html#vim.Pos">vim.Pos</a> from extmark position.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pos}</code>  (<code>[integer, integer]</code>)
</div>
</div>
<div class="help-para">
Pos:lsp(<code>{buf}</code>, <code>{pos}</code>, <code>{position_encoding}</code>)                         <span id="Pos%3Alsp()" class="help-tag-right"><a href="#Pos%3Alsp()">Pos:lsp()</a></span><br>
    Creates a new <a href="lua.html#vim.Pos">vim.Pos</a> from <code>lsp.Position</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local buf = vim.api.nvim_get_current_buf()
local lsp_pos = {
  line = 3,
  character = 5
}
-- `buf` is mandatory, as LSP positions are always associated with a buffer.
local pos = vim.pos.lsp(buf, lsp_pos, 'utf-16')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{buf}</code>                (<code>integer</code>)
</div><div class="help-li" style=""> <code>{pos}</code>                (<code>lsp.Position</code>)
</div><div class="help-li" style=""> <code>{position_encoding}</code>  (<code>lsp.PositionEncodingKind</code>)
</div>
</div>
<div class="help-para">
Pos:to_cursor(<code>{pos}</code>)                                         <span id="Pos%3Ato_cursor()" class="help-tag-right"><a href="#Pos%3Ato_cursor()">Pos:to_cursor()</a></span><br>
    Converts <a href="lua.html#vim.Pos">vim.Pos</a> to cursor position.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pos}</code>  (<code>vim.Pos</code>) See <a href="lua.html#vim.Pos">vim.Pos</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>[integer, integer]</code>)

</div>
<div class="help-para">
Pos:to_extmark(<code>{pos}</code>)                                       <span id="Pos%3Ato_extmark()" class="help-tag-right"><a href="#Pos%3Ato_extmark()">Pos:to_extmark()</a></span><br>
    Converts <a href="lua.html#vim.Pos">vim.Pos</a> to extmark position.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pos}</code>  (<code>vim.Pos</code>) See <a href="lua.html#vim.Pos">vim.Pos</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>[integer, integer]</code>)

</div>
<div class="help-para">
Pos:to_lsp(<code>{pos}</code>, <code>{position_encoding}</code>)                          <span id="Pos%3Ato_lsp()" class="help-tag-right"><a href="#Pos%3Ato_lsp()">Pos:to_lsp()</a></span><br>
    Converts <a href="lua.html#vim.Pos">vim.Pos</a> to <code>lsp.Position</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">-- `buf` is required for conversion to LSP position.
local buf = vim.api.nvim_get_current_buf()
local pos = vim.pos(3, 5, { buf = buf })
-- Convert to LSP position, you can call it in a method style.
local lsp_pos = pos:lsp('utf-16')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{pos}</code>                (<code>vim.Pos</code>) See <a href="lua.html#vim.Pos">vim.Pos</a>.
</div><div class="help-li" style=""> <code>{position_encoding}</code>  (<code>lsp.PositionEncodingKind</code>)
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.range" class="help-heading">Lua module: vim.range<span class="help-heading-tags">                                              <span id="vim.range" class="help-tag"><a href="#vim.range">vim.range</a></span></h2>


</div>
<div class="help-para">
EXPERIMENTAL: This API may change in the future. Its semantics are not yet
finalized. Subscribe to <a href="https://github.com/neovim/neovim/issues/25509">https://github.com/neovim/neovim/issues/25509</a> to stay
updated or contribute to its development.

</div>
<div class="help-para">
Provides operations to compare, calculate, and convert ranges represented by
<a href="lua.html#vim.Range">vim.Range</a> objects.

</div>
<div class="help-para">
<span id="vim.Range" class="help-tag"><a href="#vim.Range">vim.Range</a></span>
    Represents a well-defined range.

</div>
<div class="help-para">
    A <a href="lua.html#vim.Range">vim.Range</a> object contains a <code>{start}</code> and a <code>{end_}</code> position(see
    <a href="lua.html#vim.Pos">vim.Pos</a>). Note that the <code>{end_}</code> position is exclusive. To create a new
    <a href="lua.html#vim.Range">vim.Range</a> object, call <code>vim.range()</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local pos1 = vim.pos(3, 5)
local pos2 = vim.pos(4, 0)
-- Create a range from two positions.
local range1 = vim.range(pos1, pos2)
-- Or create a range from four integers representing start and end positions.
local range2 = vim.range(3, 5, 4, 0)
-- Because `vim.Range` is end exclusive, `range1` and `range2` both represent
-- a range starting at the row 3, column 5 and ending at where the row 3 ends.
-- Operators are overloaded for comparing two `vim.Pos` objects.
if range1 == range2 then
  print("range1 and range2 are the same range")
end</code></pre>

</div>
<div class="help-para">
    It may include optional fields that enable additional capabilities, such
    as format conversions. Note that the <code>{start}</code> and <code>{end_}</code> positions need to
    have the same optional fields.

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{start}</code>      (<code>vim.Pos</code>) Start position.
</div><div class="help-li" style=""> <code>{end_}</code>       (<code>vim.Pos</code>) End position, exclusive.
</div><div class="help-li" style=""> <code>{is_empty}</code>   (<code>fun(self: vim.Range): boolean</code>) See <a href="lua.html#Range%3Ais_empty()">Range:is_empty()</a>.
</div><div class="help-li" style=""> <code>{has}</code>        (<code>fun(outer: vim.Range, inner: vim.Range|vim.Pos): boolean</code>)
                     See <a href="lua.html#Range%3Ahas()">Range:has()</a>.
</div><div class="help-li" style=""> <code>{intersect}</code>  (<code>fun(r1: vim.Range, r2: vim.Range): vim.Range?</code>) See
                     <a href="lua.html#Range%3Aintersect()">Range:intersect()</a>.
</div><div class="help-li" style=""> <code>{to_lsp}</code>     (<code>fun(range: vim.Range, position_encoding: lsp.PositionEncodingKind): lsp.Range</code>)
                     See <a href="lua.html#Range%3Ato_lsp()">Range:to_lsp()</a>.
</div><div class="help-li" style=""> <code>{lsp}</code>        (<code>fun(buf: integer, range: lsp.Range, position_encoding: lsp.PositionEncodingKind)</code>)
                     See <a href="lua.html#Range%3Alsp()">Range:lsp()</a>.
</div>
</div>
<div class="help-para">
Range:has(<code>{outer}</code>, <code>{inner}</code>)                                      <span id="Range%3Ahas()" class="help-tag-right"><a href="#Range%3Ahas()">Range:has()</a></span><br>
    Checks whether <code>{outer}</code> range contains <code>{inner}</code> range or position.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{outer}</code>  (<code>vim.Range</code>) See <a href="lua.html#vim.Range">vim.Range</a>.
</div><div class="help-li" style=""> <code>{inner}</code>  (<code>vim.Range|vim.Pos</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if <code>{outer}</code> range fully contains <code>{inner}</code> range or
        position.

</div>
<div class="help-para">
Range:intersect(<code>{r1}</code>, <code>{r2}</code>)                                <span id="Range%3Aintersect()" class="help-tag-right"><a href="#Range%3Aintersect()">Range:intersect()</a></span><br>
    Computes the common range shared by the given ranges.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{r1}</code>  (<code>vim.Range</code>) First range to intersect. See <a href="lua.html#vim.Range">vim.Range</a>.
</div><div class="help-li" style=""> <code>{r2}</code>  (<code>vim.Range</code>) Second range to intersect. See <a href="lua.html#vim.Range">vim.Range</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.Range?</code>) range that is present inside both <code>r1</code> and <code>r2</code>. <code>nil</code>
        if such range does not exist. See <a href="lua.html#vim.Range">vim.Range</a>.

</div>
<div class="help-para">
Range:is_empty()                                            <span id="Range%3Ais_empty()" class="help-tag-right"><a href="#Range%3Ais_empty()">Range:is_empty()</a></span><br>
    Checks whether the given range is empty; i.e., start &gt;= end.

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>) <code>true</code> if the given range is empty

</div>
<div class="help-para">
Range:lsp(<code>{buf}</code>, <code>{range}</code>, <code>{position_encoding}</code>)                   <span id="Range%3Alsp()" class="help-tag-right"><a href="#Range%3Alsp()">Range:lsp()</a></span><br>
    Creates a new <a href="lua.html#vim.Range">vim.Range</a> from <code>lsp.Range</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local buf = vim.api.nvim_get_current_buf()
local lsp_range = {
  ['start'] = { line = 3, character = 5 },
  ['end'] = { line = 4, character = 0 }
}
-- `buf` is mandatory, as LSP ranges are always associated with a buffer.
local range = vim.range.lsp(buf, lsp_range, 'utf-16')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{buf}</code>                (<code>integer</code>)
</div><div class="help-li" style=""> <code>{range}</code>              (<code>lsp.Range</code>)
</div><div class="help-li" style=""> <code>{position_encoding}</code>  (<code>lsp.PositionEncodingKind</code>)
</div>
</div>
<div class="help-para">
Range:to_lsp(<code>{range}</code>, <code>{position_encoding}</code>)                    <span id="Range%3Ato_lsp()" class="help-tag-right"><a href="#Range%3Ato_lsp()">Range:to_lsp()</a></span><br>
    Converts <a href="lua.html#vim.Range">vim.Range</a> to <code>lsp.Range</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">-- `buf` is required for conversion to LSP range.
local buf = vim.api.nvim_get_current_buf()
local range = vim.range(3, 5, 4, 0, { buf = buf })
-- Convert to LSP range, you can call it in a method style.
local lsp_range = range:to_lsp('utf-16')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{range}</code>              (<code>vim.Range</code>) See <a href="lua.html#vim.Range">vim.Range</a>.
</div><div class="help-li" style=""> <code>{position_encoding}</code>  (<code>lsp.PositionEncodingKind</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>lsp.Range</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.re" class="help-heading">Lua module: vim.re<span class="help-heading-tags">                                                    <span id="vim.re" class="help-tag"><a href="#vim.re">vim.re</a></span></h2>


</div>
<div class="help-para">
The <code>vim.re</code> module provides a conventional regex-like syntax for pattern
usage within LPeg <a href="lua.html#vim.lpeg">vim.lpeg</a>. (Unrelated to <a href="lua.html#vim.regex">vim.regex</a> which provides Vim
<a href="pattern.html#regexp">regexp</a> from Lua.)

</div>
<div class="help-para">
See <a href="https://www.inf.puc-rio.br/~roberto/lpeg/re.html">https://www.inf.puc-rio.br/~roberto/lpeg/re.html</a> for the original
documentation including regex syntax and examples.

</div>
<div class="help-para">
vim.re.compile(<code>{string}</code>, <code>{defs}</code>)                            <span id="vim.re.compile()" class="help-tag-right"><a href="#vim.re.compile()">vim.re.compile()</a></span><br>
    Compiles the given <code>{string}</code> and returns an equivalent LPeg pattern. The
    given string may define either an expression or a grammar. The optional
    <code>{defs}</code> table provides extra Lua values to be used by the pattern.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{string}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{defs}</code>    (<code>table?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.lpeg.Pattern</code>)

</div>
<div class="help-para">
vim.re.find(<code>{subject}</code>, <code>{pattern}</code>, <code>{init}</code>)                      <span id="vim.re.find()" class="help-tag-right"><a href="#vim.re.find()">vim.re.find()</a></span><br>
    Searches the given <code>{pattern}</code> in the given <code>{subject}</code>. If it finds a match,
    returns the index where this occurrence starts and the index where it
    ends. Otherwise, returns nil.

</div>
<div class="help-para">
    An optional numeric argument <code>{init}</code> makes the search starts at that
    position in the subject string. As usual in Lua libraries, a negative
    value counts from the end.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{subject}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{pattern}</code>  (<code>vim.lpeg.Pattern|string</code>)
</div><div class="help-li" style=""> <code>{init}</code>     (<code>integer?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>integer?</code>) the index where the occurrence starts, nil if no match
        (<code>integer?</code>) the index where the occurrence ends, nil if no match

</div>
<div class="help-para">
vim.re.gsub(<code>{subject}</code>, <code>{pattern}</code>, <code>{replacement}</code>)               <span id="vim.re.gsub()" class="help-tag-right"><a href="#vim.re.gsub()">vim.re.gsub()</a></span><br>
    Does a global substitution, replacing all occurrences of <code>{pattern}</code> in the
    given <code>{subject}</code> by <code>{replacement}</code>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{subject}</code>      (<code>string</code>)
</div><div class="help-li" style=""> <code>{pattern}</code>      (<code>vim.lpeg.Pattern|string</code>)
</div><div class="help-li" style=""> <code>{replacement}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>)

</div>
<div class="help-para">
vim.re.match(<code>{subject}</code>, <code>{pattern}</code>, <code>{init}</code>)                    <span id="vim.re.match()" class="help-tag-right"><a href="#vim.re.match()">vim.re.match()</a></span><br>
    Matches the given <code>{pattern}</code> against the given <code>{subject}</code>, returning all
    captures.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{subject}</code>  (<code>string</code>)
</div><div class="help-li" style=""> <code>{pattern}</code>  (<code>vim.lpeg.Pattern|string</code>)
</div><div class="help-li" style=""> <code>{init}</code>     (<code>integer?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer|vim.lpeg.Capture?</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> vim.lpeg.match()
</div>
</div>
<div class="help-para">
vim.re.updatelocale()                                  <span id="vim.re.updatelocale()" class="help-tag-right"><a href="#vim.re.updatelocale()">vim.re.updatelocale()</a></span><br>
    Updates the pre-defined character classes to the current locale.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.regex" class="help-heading">Lua module: vim.regex<span class="help-heading-tags">                                              <span id="vim.regex" class="help-tag"><a href="#vim.regex">vim.regex</a></span></h2>


</div>
<div class="help-para">
Vim regexes can be used directly from Lua. Currently they only allow matching
within a single line.

</div>
<div class="help-para">
                                                          <span id="regex%3Amatch_line()" class="help-tag-right"><a href="#regex%3Amatch_line()">regex:match_line()</a></span><br>
regex:match_line(<code>{bufnr}</code>, <code>{line_idx}</code>, <code>{start}</code>, <code>{end_}</code>)
    Matches line at <code>line_idx</code> (zero-based) in buffer <code>bufnr</code>. Match is
    restricted to byte index range <code>start</code> and <code>end_</code> if given, otherwise see
    <a href="lua.html#regex%3Amatch_str()">regex:match_str()</a>. Returned byte indices are relative to <code>start</code> if
    given.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>     (<code>integer</code>)
</div><div class="help-li" style=""> <code>{line_idx}</code>  (<code>integer</code>)
</div><div class="help-li" style=""> <code>{start}</code>     (<code>integer?</code>)
</div><div class="help-li" style=""> <code>{end_}</code>      (<code>integer?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>integer?</code>) match start (byte index) relative to <code>start</code>, or <code>nil</code> if
        no match
        (<code>integer?</code>) match end (byte index) relative to <code>start</code>, or <code>nil</code> if
        no match

</div>
<div class="help-para">
regex:match_str(<code>{str}</code>)                                     <span id="regex%3Amatch_str()" class="help-tag-right"><a href="#regex%3Amatch_str()">regex:match_str()</a></span><br>
    Matches string <code>str</code> against this regex. To match the string precisely,
    surround the regex with "^" and "$". Returns the byte indices for the
    start and end of the match, or <code>nil</code> if there is no match. Because any
    integer is "truthy", <code>regex:match_str()</code> can be directly used as a
    condition in an if-statement.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>integer?</code>) match start (byte index), or <code>nil</code> if no match
        (<code>integer?</code>) match end (byte index), or <code>nil</code> if no match

</div>
<div class="help-para">
vim.regex(<code>{re}</code>)                                                  <span id="vim.regex()" class="help-tag-right"><a href="#vim.regex()">vim.regex()</a></span><br>
    Parses the Vim regex <code>re</code> and returns a regex object. Regexes are "magic"
    and case-sensitive by default, regardless of <a href="deprecated.html#'magic'">'magic'</a> and <a href="options.html#'ignorecase'">'ignorecase'</a>.
    They can be controlled with flags, see <a href="pattern.html#%2Fmagic">/magic</a> and <a href="pattern.html#%2Fignorecase">/ignorecase</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{re}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.regex</code>)

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.secure" class="help-heading">Lua module: vim.secure<span class="help-heading-tags">                                            <span id="vim.secure" class="help-tag"><a href="#vim.secure">vim.secure</a></span></h2>


</div>
<div class="help-para">
vim.secure.read(<code>{path}</code>)                                    <span id="vim.secure.read()" class="help-tag-right"><a href="#vim.secure.read()">vim.secure.read()</a></span><br>
    If <code>{path}</code> is a file: attempt to read the file, prompting the user if the
    file should be trusted.

</div>
<div class="help-para">
    If <code>{path}</code> is a directory: return true if the directory is trusted
    (non-recursive), prompting the user as necessary.

</div>
<div class="help-para">
    The user's choice is persisted in a trust database at
    $XDG_STATE_HOME/nvim/trust.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path to a file or directory to read.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean|string?</code>) If <code>{path}</code> is not trusted or does not exist,
        returns <code>nil</code>. Otherwise, returns the contents of <code>{path}</code> if it is a
        file, or true if <code>{path}</code> is a directory.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="editing.html#%3Atrust">:trust</a>
</div>
</div>
<div class="help-para">
vim.secure.trust(<code>{opts}</code>)                                  <span id="vim.secure.trust()" class="help-tag-right"><a href="#vim.secure.trust()">vim.secure.trust()</a></span><br>
    Manage the trust database.

</div>
<div class="help-para">
    The trust database is located at <a href="starting.html#%24XDG_STATE_HOME">$XDG_STATE_HOME</a>/nvim/trust.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>  (<code>table</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{action}</code> (<code>'allow'|'deny'|'remove'</code>) - <code>'allow'</code> to add a
                  file to the trust database and trust it,
</div><div class="help-li" style="margin-left: 3rem;"> <code>'deny'</code> to add a file to the trust database and deny it,
</div><div class="help-li" style="margin-left: 3rem;"> <code>'remove'</code> to remove file from the trust database
</div><div class="help-li" style="margin-left: 3rem;"> <code>{path}?</code> (<code>string</code>) Path to a file to update. Mutually
                  exclusive with <code>{bufnr}</code>. Cannot be used when <code>{action}</code> is
                  "allow".
</div><div class="help-li" style="margin-left: 3rem;"> <code>{bufnr}?</code> (<code>integer</code>) Buffer number to update. Mutually
                  exclusive with <code>{path}</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>boolean</code>) success true if operation was successful
        (<code>string</code>) msg full path if operation was successful, else error
        message

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.snippet" class="help-heading">Lua module: vim.snippet<span class="help-heading-tags">                                          <span id="vim.snippet" class="help-tag"><a href="#vim.snippet">vim.snippet</a></span></h2>


</div>
<div class="help-para">
<span id="vim.snippet.ActiveFilter" class="help-tag"><a href="#vim.snippet.ActiveFilter">vim.snippet.ActiveFilter</a></span>

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{direction}</code>  (<code>vim.snippet.Direction</code>) Navigation direction. -1 for
                     previous, 1 for next.
</div>
</div>
<div class="help-para">
vim.snippet.active(<code>{filter}</code>)                            <span id="vim.snippet.active()" class="help-tag-right"><a href="#vim.snippet.active()">vim.snippet.active()</a></span><br>
    Returns <code>true</code> if there's an active snippet in the current buffer,
    applying the given filter if provided.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{filter}</code>  (<code>vim.snippet.ActiveFilter?</code>) Filter to constrain the search
                  with:
</div><div class="help-li" style="margin-left: 3rem;"> <code>direction</code> (vim.snippet.Direction): Navigation direction.
                    Will return <code>true</code> if the snippet can be jumped in the
                    given direction. See <a href="lua.html#vim.snippet.ActiveFilter">vim.snippet.ActiveFilter</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.snippet.expand(<code>{input}</code>)                             <span id="vim.snippet.expand()" class="help-tag-right"><a href="#vim.snippet.expand()">vim.snippet.expand()</a></span><br>
    Expands the given snippet text. Refer to
    <a href="https://microsoft.github.io/language-server-protocol/specification/#snippet_syntax">https://microsoft.github.io/language-server-protocol/specification/#snippet_syntax</a>
    for the specification of valid input.

</div>
<div class="help-para">
    Tabstops are highlighted with <a href="syntax.html#hl-SnippetTabstop">hl-SnippetTabstop</a> and
    <a href="syntax.html#hl-SnippetTabstopActive">hl-SnippetTabstopActive</a>.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{input}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
vim.snippet.jump(<code>{direction}</code>)                             <span id="vim.snippet.jump()" class="help-tag-right"><a href="#vim.snippet.jump()">vim.snippet.jump()</a></span><br>
    Jumps to the next (or previous) placeholder in the current snippet, if
    possible.

</div>
<div class="help-para">
    By default <code>&lt;Tab&gt;</code> is setup to jump if a snippet is active. The default
    mapping looks like:<pre><code class="language-lua">vim.keymap.set({ 'i', 's' }, '&lt;Tab&gt;', function()
   if vim.snippet.active({ direction = 1 }) then
     return '&lt;Cmd&gt;lua vim.snippet.jump(1)&lt;CR&gt;'
   else
     return '&lt;Tab&gt;'
   end
 end, { desc = '...', expr = true, silent = true })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{direction}</code>  (<code>vim.snippet.Direction</code>) Navigation direction. -1 for
                     previous, 1 for next.
</div>
</div>
<div class="help-para">
vim.snippet.stop()                                        <span id="vim.snippet.stop()" class="help-tag-right"><a href="#vim.snippet.stop()">vim.snippet.stop()</a></span><br>
    Exits the current snippet.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.spell" class="help-heading">Lua module: vim.spell<span class="help-heading-tags">                                              <span id="vim.spell" class="help-tag"><a href="#vim.spell">vim.spell</a></span></h2>


</div>
<div class="help-para">
vim.spell.check(<code>{str}</code>)                                     <span id="vim.spell.check()" class="help-tag-right"><a href="#vim.spell.check()">vim.spell.check()</a></span><br>
    Check <code>{str}</code> for spelling errors. Similar to the Vimscript function
    <a href="vimfn.html#spellbadword()">spellbadword()</a>.

</div>
<div class="help-para">
<b>    Note:</b> The behaviour of this function is dependent on: <a href="options.html#'spelllang'">'spelllang'</a>,
    <a href="options.html#'spellfile'">'spellfile'</a>, <a href="options.html#'spellcapcheck'">'spellcapcheck'</a> and <a href="options.html#'spelloptions'">'spelloptions'</a> which can all be local to
    the buffer. Consider calling this with <a href="api.html#nvim_buf_call()">nvim_buf_call()</a>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.spell.check("the quik brown fox")
-- =&gt;
-- {
--     {'quik', 'bad', 5}
-- }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>[string, 'bad'|'rare'|'local'|'caps', integer][]</code>) List of tuples
        with three items:
<div class="help-li" style=""> The badly spelled word.
</div><div class="help-li" style=""> The type of the spelling error: "bad" spelling mistake "rare" rare
          word "local" word only valid in another region "caps" word should
          start with Capital
</div><div class="help-li" style=""> The position in <code>{str}</code> where the word begins.
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.system" class="help-heading">Lua module: vim.system<span class="help-heading-tags">                                        <span id="lua-vim-system" class="help-tag"><a href="#lua-vim-system">lua-vim-system</a></span></h2>


</div>
<div class="help-para">
<span id="vim.SystemCompleted" class="help-tag"><a href="#vim.SystemCompleted">vim.SystemCompleted</a></span>

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{code}</code>     (<code>integer</code>)
</div><div class="help-li" style=""> <code>{signal}</code>   (<code>integer</code>)
</div><div class="help-li" style=""> <code>{stdout}?</code>  (<code>string</code>) <code>nil</code> if stdout is disabled or has a custom
                   handler.
</div><div class="help-li" style=""> <code>{stderr}?</code>  (<code>string</code>) <code>nil</code> if stderr is disabled or has a custom
                   handler.
</div>
</div>
<div class="help-para">
<span id="vim.SystemObj" class="help-tag"><a href="#vim.SystemObj">vim.SystemObj</a></span>

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{cmd}</code>         (<code>string[]</code>) Command name and args
</div><div class="help-li" style=""> <code>{pid}</code>         (<code>integer</code>) Process ID
</div><div class="help-li" style=""> <code>{kill}</code>        (<code>fun(self: vim.SystemObj, signal: integer|string)</code>) See
                      <a href="lua.html#SystemObj%3Akill()">SystemObj:kill()</a>.
</div><div class="help-li" style=""> <code>{wait}</code>        (<code>fun(self: vim.SystemObj, timeout: integer?): vim.SystemCompleted</code>)
                      See <a href="lua.html#SystemObj%3Await()">SystemObj:wait()</a>.
</div><div class="help-li" style=""> <code>{write}</code>       (<code>fun(self: vim.SystemObj, data: string[]|string?)</code>) See
                      <a href="lua.html#SystemObj%3Awrite()">SystemObj:write()</a>.
</div><div class="help-li" style=""> <code>{is_closing}</code>  (<code>fun(self: vim.SystemObj): boolean</code>) See
                      <a href="lua.html#SystemObj%3Ais_closing()">SystemObj:is_closing()</a>.
</div>
</div>
<div class="help-para">
SystemObj:is_closing()                                <span id="SystemObj%3Ais_closing()" class="help-tag-right"><a href="#SystemObj%3Ais_closing()">SystemObj:is_closing()</a></span><br>
    Checks if the process handle is closing or already closed.

</div>
<div class="help-para">
    This method returns <code>true</code> if the underlying process handle is either
    <code>nil</code> or is in the process of closing. It is useful for determining
    whether it is safe to perform operations on the process handle.

</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
SystemObj:kill(<code>{signal}</code>)                                    <span id="SystemObj%3Akill()" class="help-tag-right"><a href="#SystemObj%3Akill()">SystemObj:kill()</a></span><br>
    Sends a signal to the process.

</div>
<div class="help-para">
    The signal can be specified as an integer or as a string.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local obj = vim.system({'sleep', '10'})
obj:kill('sigterm') -- sends SIGTERM to the process</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{signal}</code>  (<code>integer|string</code>) Signal to send to the process. See
                  <a href="luvref.html#luv-constants">luv-constants</a>.
</div>
</div>
<div class="help-para">
SystemObj:wait(<code>{timeout}</code>)                                   <span id="SystemObj%3Await()" class="help-tag-right"><a href="#SystemObj%3Await()">SystemObj:wait()</a></span><br>
    Waits for the process to complete or until the specified timeout elapses.

</div>
<div class="help-para">
    This method blocks execution until the associated process has exited or
    the optional <code>timeout</code> (in milliseconds) has been reached. If the process
    does not exit before the timeout, it is forcefully terminated with SIGKILL
    (signal 9), and the exit code is set to 124.

</div>
<div class="help-para">
    If no <code>timeout</code> is provided, the method will wait indefinitely (or use the
    timeout specified in the options when the process was started).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local obj = vim.system({'echo', 'hello'}, { text = true })
local result = obj:wait(1000) -- waits up to 1000ms
print(result.code, result.signal, result.stdout, result.stderr)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{timeout}</code>  (<code>integer?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.SystemCompleted</code>) See <a href="lua.html#vim.SystemCompleted">vim.SystemCompleted</a>.

</div>
<div class="help-para">
SystemObj:write(<code>{data}</code>)                                    <span id="SystemObj%3Awrite()" class="help-tag-right"><a href="#SystemObj%3Awrite()">SystemObj:write()</a></span><br>
    Writes data to the stdin of the process or closes stdin.

</div>
<div class="help-para">
    If <code>data</code> is a list of strings, each string is written followed by a
    newline.

</div>
<div class="help-para">
    If <code>data</code> is a string, it is written as-is.

</div>
<div class="help-para">
    If <code>data</code> is <code>nil</code>, the write side of the stream is shut down and the pipe
    is closed.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local obj = vim.system({'cat'}, { stdin = true })
obj:write({'hello', 'world'}) -- writes 'hello\nworld\n' to stdin
obj:write(nil) -- closes stdin</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{data}</code>  (<code>string[]|string?</code>)
</div>
</div>
<div class="help-para">
vim.system(<code>{cmd}</code>, <code>{opts}</code>, <code>{on_exit}</code>)                            <span id="vim.system()" class="help-tag-right"><a href="#vim.system()">vim.system()</a></span><br>
    Runs a system command or throws an error if <code>{cmd}</code> cannot be run.

</div>
<div class="help-para">
    The command runs directly (not in <a href="options.html#'shell'">'shell'</a>) so shell builtins such as
    "echo" in cmd.exe, cmdlets in powershell, or "help" in bash, will not work
    unless you actually invoke a shell: <code>vim.system({'bash', '-c', 'help'})</code>.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local on_exit = function(obj)
  print(obj.code)
  print(obj.signal)
  print(obj.stdout)
  print(obj.stderr)
end
-- Runs asynchronously:
vim.system({'echo', 'hello'}, { text = true }, on_exit)
-- Runs synchronously:
local obj = vim.system({'echo', 'hello'}, { text = true }):wait()
-- { code = 0, signal = 0, stdout = 'hello\n', stderr = '' }</code></pre>

</div>
<div class="help-para">
    See <a href="luvref.html#uv.spawn()">uv.spawn()</a> for more details.<b> Note:</b> unlike <a href="luvref.html#uv.spawn()">uv.spawn()</a>, vim.system
    throws an error if <code>{cmd}</code> cannot be run.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{cmd}</code>      (<code>string[]</code>) Command to execute
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table?</code>) A table with the following fields:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{cwd}?</code> (<code>string</code>) Set the current working directory for
                     the sub-process.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{env}?</code> (<code>table&lt;string,string|number&gt;</code>) Set environment
                     variables for the new process. Inherits the current
                     environment with <code>NVIM</code> set to <a href="vvars.html#v%3Aservername">v:servername</a>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{clear_env}?</code> (<code>boolean</code>) <code>env</code> defines the job
                     environment exactly, instead of merging current
                     environment.<b> Note:</b> if <code>env</code> is <code>nil</code>, the current
                     environment is used but without <code>NVIM</code> set.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{stdin}?</code> (<code>string|string[]|true</code>) If <code>true</code>, then a pipe
                     to stdin is opened and can be written to via the
                     <code>write()</code> method to SystemObj. If <code>string</code> or <code>string[]</code>
                     then will be written to stdin and closed.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{stdout}?</code> (<code>fun(err:string?, data: string?)|boolean</code>,
                     default: <code>true</code>) Handle output from stdout.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{stderr}?</code> (<code>fun(err:string?, data: string?)|boolean</code>,
                     default: <code>true</code>) Handle output from stderr.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{text}?</code> (<code>boolean</code>) Handle stdout and stderr as text.
                     Normalizes line endings by replacing <code>\r\n</code> with <code>\n</code>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{timeout}?</code> (<code>integer</code>) Run the command with a time limit
                     in ms. Upon timeout the process is sent the TERM signal
                     (15) and the exit code is set to 124.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{detach}?</code> (<code>boolean</code>) Spawn the child process in a
                     detached state - this will make it a process group
                     leader, and will effectively enable the child to keep
                     running after the parent exits. Note that the child
                     process will still keep the parent's event loop alive
                     unless the parent process calls <a href="luvref.html#uv.unref()">uv.unref()</a> on the
                     child's process handle.
</div><div class="help-li" style=""> <code>{on_exit}</code>  (<code>fun(out: vim.SystemCompleted)?</code>) Called when subprocess
                   exits. When provided, the command runs asynchronously. See
                   return of SystemObj:wait().
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Overloads:</div>
<div class="help-li" style=""> <code>fun(cmd: string[], on_exit: fun(out: vim.SystemCompleted)): vim.SystemObj</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.SystemObj</code>) See <a href="lua.html#vim.SystemObj">vim.SystemObj</a>.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.text" class="help-heading">Lua module: vim.text<span class="help-heading-tags">                                                <span id="vim.text" class="help-tag"><a href="#vim.text">vim.text</a></span></h2>


</div>
<div class="help-para">
vim.text.diff(<code>{a}</code>, <code>{b}</code>, <code>{opts}</code>)                              <span id="vim.text.diff()" class="help-tag-right"><a href="#vim.text.diff()">vim.text.diff()</a></span><br>
    Run diff on strings <code>{a}</code> and <code>{b}</code>. Any indices returned by this function,
    either directly or via callback arguments, are 1-based.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.text.diff('a\n', 'b\nc\n')
-- =&gt;
-- @@ -1 +1,2 @@
-- -a
-- +b
-- +c
vim.text.diff('a\n', 'b\nc\n', {result_type = 'indices'})
-- =&gt;
-- {
--   {1, 1, 1, 2}
-- }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{a}</code>     (<code>string</code>) First string to compare
</div><div class="help-li" style=""> <code>{b}</code>     (<code>string</code>) Second string to compare
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>table?</code>) Optional parameters:
</div><div class="help-li" style="margin-left: 3rem;"> <code>{on_hunk}?</code>
                  (<code>fun(start_a: integer, count_a: integer, start_b: integer, count_b: integer): integer?</code>)
                  Invoked for each hunk in the diff. Return a negative number
                  to cancel the callback for any remaining hunks. Arguments:
</div><div class="help-li" style="margin-left: 4rem;"> <code>start_a</code> (<code>integer</code>): Start line of hunk in <code>{a}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>count_a</code> (<code>integer</code>): Hunk size in <code>{a}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>start_b</code> (<code>integer</code>): Start line of hunk in <code>{b}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>count_b</code> (<code>integer</code>): Hunk size in <code>{b}</code>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{result_type}?</code> (<code>'unified'|'indices'</code>, default: <code>'unified'</code>)
                  Form of the returned diff:
</div><div class="help-li" style="margin-left: 4rem;"> <code>unified</code>: String in unified format.
</div><div class="help-li" style="margin-left: 4rem;"> <code>indices</code>: Array of hunk locations.<b> Note:</b> This option is
                    ignored if <code>on_hunk</code> is used.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{linematch}?</code> (<code>boolean|integer</code>) Run linematch on the
                  resulting hunks from xdiff. When integer, only hunks upto
                  this size in lines are run through linematch. Requires
                  <code>result_type = indices</code>, ignored otherwise.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{algorithm}?</code> (<code>'myers'|'minimal'|'patience'|'histogram'</code>,
                  default: <code>'myers'</code>) Diff algorithm to use. Values:
</div><div class="help-li" style="margin-left: 4rem;"> <code>myers</code>: the default algorithm
</div><div class="help-li" style="margin-left: 4rem;"> <code>minimal</code>: spend extra time to generate the smallest
                    possible diff
</div><div class="help-li" style="margin-left: 4rem;"> <code>patience</code>: patience diff algorithm
</div><div class="help-li" style="margin-left: 4rem;"> <code>histogram</code>: histogram diff algorithm
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ctxlen}?</code> (<code>integer</code>) Context length
</div><div class="help-li" style="margin-left: 3rem;"> <code>{interhunkctxlen}?</code> (<code>integer</code>) Inter hunk context length
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_whitespace}?</code> (<code>boolean</code>) Ignore whitespace
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_whitespace_change}?</code> (<code>boolean</code>) Ignore whitespace
                  change
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_whitespace_change_at_eol}?</code> (<code>boolean</code>) Ignore
                  whitespace change at end-of-line.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_cr_at_eol}?</code> (<code>boolean</code>) Ignore carriage return at
                  end-of-line
</div><div class="help-li" style="margin-left: 3rem;"> <code>{ignore_blank_lines}?</code> (<code>boolean</code>) Ignore blank lines
</div><div class="help-li" style="margin-left: 3rem;"> <code>{indent_heuristic}?</code> (<code>boolean</code>) Use the indent heuristic for
                  the internal diff library.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string|integer[][]?</code>) See <code>{opts.result_type}</code>. <code>nil</code> if
        <code>{opts.on_hunk}</code> is given.

</div>
<div class="help-para">
vim.text.hexdecode(<code>{enc}</code>)                               <span id="vim.text.hexdecode()" class="help-tag-right"><a href="#vim.text.hexdecode()">vim.text.hexdecode()</a></span><br>
    Hex decode a string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{enc}</code>  (<code>string</code>) String to decode
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>string?</code>) Decoded string
        (<code>string?</code>) Error message, if any

</div>
<div class="help-para">
vim.text.hexencode(<code>{str}</code>)                               <span id="vim.text.hexencode()" class="help-tag-right"><a href="#vim.text.hexencode()">vim.text.hexencode()</a></span><br>
    Hex encode a string.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) String to encode
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) Hex encoded string

</div>
<div class="help-para">
vim.text.indent(<code>{size}</code>, <code>{text}</code>, <code>{opts}</code>)                    <span id="vim.text.indent()" class="help-tag-right"><a href="#vim.text.indent()">vim.text.indent()</a></span><br>
    Sets the indent (i.e. the common leading whitespace) of non-empty lines in
    <code>text</code> to <code>size</code> spaces/tabs.

</div>
<div class="help-para">
    Indent is calculated by number of consecutive indent chars.
<div class="help-li" style=""> The first indented, non-empty line decides the indent char (space/tab):
</div><div class="help-li" style="margin-left: 3rem;"> <code>SPC SPC TAB …</code> = two-space indent.
</div><div class="help-li" style="margin-left: 3rem;"> <code>TAB SPC …</code> = one-tab indent.
</div><div class="help-li" style=""> Set <code>opts.expandtab</code> to treat tabs as spaces.
</div>
</div>
<div class="help-para">
    To "dedent" (remove the common indent), pass <code>size=0</code>:<pre><code class="language-lua">vim.print(vim.text.indent(0, ' a\n  b\n'))</code></pre>

</div>
<div class="help-para">
    To adjust relative-to an existing indent, call indent() twice:<pre><code class="language-lua">local indented, old_indent = vim.text.indent(0, ' a\n b\n')
indented = vim.text.indent(old_indent + 2, indented)
vim.print(indented)</code></pre>

</div>
<div class="help-para">
    To ignore the final, blank line when calculating the indent, use gsub()
    before calling indent():<pre><code class="language-lua">local text = '  a\n  b\n '
vim.print(vim.text.indent(0, (text:gsub('\n[\t ]+\n?$', '\n'))))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{size}</code>  (<code>integer</code>) Number of spaces.
</div><div class="help-li" style=""> <code>{text}</code>  (<code>string</code>) Text to indent.
</div><div class="help-li" style=""> <code>{opts}</code>  (<code>{ expandtab?: integer }?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>string</code>) Indented text.
        (<code>integer</code>) Indent size before modification.

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.ui" class="help-heading">Lua module: vim.ui<span class="help-heading-tags">                                                    <span id="vim.ui" class="help-tag"><a href="#vim.ui">vim.ui</a></span></h2>


</div>
<div class="help-para">
vim.ui.input(<code>{opts}</code>, <code>{on_confirm}</code>)                            <span id="vim.ui.input()" class="help-tag-right"><a href="#vim.ui.input()">vim.ui.input()</a></span><br>
    Prompts the user for input, allowing arbitrary (potentially asynchronous)
    work until <code>on_confirm</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)
    vim.o.shiftwidth = tonumber(input)
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>        (<code>table?</code>) Additional options. See <a href="vimfn.html#input()">input()</a>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{prompt}?</code> (<code>string</code>) Text of the prompt
</div><div class="help-li" style="margin-left: 3rem;"> <code>{default}?</code> (<code>string</code>) Default reply to the input
</div><div class="help-li" style="margin-left: 3rem;"> <code>{completion}?</code> (<code>string</code>) Specifies type of completion
                        supported for input. Supported types are the same that
                        can be supplied to a user-defined command using the
                        "-complete=" argument. See <a href="map.html#%3Acommand-completion">:command-completion</a>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{highlight}?</code> (<code>function</code>) Function that will be used
                        for highlighting user inputs.
</div><div class="help-li" style=""> <code>{on_confirm}</code>  (<code>fun(input?: string)</code>) Called once the user confirms or
                      abort the input. <code>input</code> is what the user typed (it
                      might be an empty string if nothing was entered), or
                      <code>nil</code> if the user aborted the dialog.
</div>
</div>
<div class="help-para">
vim.ui.open(<code>{path}</code>, <code>{opt}</code>)                                     <span id="vim.ui.open()" class="help-tag-right"><a href="#vim.ui.open()">vim.ui.open()</a></span><br>
    Opens <code>path</code> with the system default handler (macOS <code>open</code>, Windows
    <code>explorer.exe</code>, Linux <code>xdg-open</code>, …), or returns (but does not show) an
    error message on failure.

</div>
<div class="help-para">
    Can also be invoked with <code>:Open</code>.                                  <span id="%3AOpen" class="help-tag-right"><a href="#%3AOpen">:Open</a></span><br>

</div>
<div class="help-para">
    Expands "~/" and environment variables in filesystem paths.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Asynchronous.
vim.ui.open("https://neovim.io/")
vim.ui.open("~/path/to/file")
-- Use the "osurl" command to handle the path or URL.
vim.ui.open("gh#neovim/neovim!29490", { cmd = { 'osurl' } })
-- Synchronous (wait until the process exits).
local cmd, err = vim.ui.open("$VIMRUNTIME")
if cmd then
  cmd:wait()
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path or URL to open
</div><div class="help-li" style=""> <code>{opt}</code>   (<code>table?</code>) Options
</div><div class="help-li" style="margin-left: 3rem;"> <code>{cmd}?</code> (<code>string[]</code>) Command used to open the path or URL.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return (multiple):</div>
        (<code>vim.SystemObj?</code>) Command object, or nil if not found. See
        <a href="lua.html#vim.SystemObj">vim.SystemObj</a>.
        (<code>string?</code>) Error message on failure, or nil on success.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.system()">vim.system()</a>
</div>
</div>
<div class="help-para">
vim.ui.select(<code>{items}</code>, <code>{opts}</code>, <code>{on_choice}</code>)                  <span id="vim.ui.select()" class="help-tag-right"><a href="#vim.ui.select()">vim.ui.select()</a></span><br>
    Prompts the user to pick from a list of items, allowing arbitrary
    (potentially asynchronous) work until <code>on_choice</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.ui.select({ 'tabs', 'spaces' }, {
    prompt = 'Select tabs or spaces:',
    format_item = function(item)
        return "I'd like to choose " .. item
    end,
}, function(choice)
    if choice == 'spaces' then
        vim.o.expandtab = true
    else
        vim.o.expandtab = false
    end
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{items}</code>      (<code>any[]</code>) Arbitrary items
</div><div class="help-li" style=""> <code>{opts}</code>       (<code>table</code>) Additional options
</div><div class="help-li" style="margin-left: 3rem;"> <code>{prompt}?</code> (<code>string</code>) Text of the prompt. Defaults to
                       <code>Select one of:</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>{format_item}?</code> (<code>fun(item: any):string</code>) Function to
                       format an individual item from <code>items</code>. Defaults to
                       <code>tostring</code>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{kind}?</code> (<code>string</code>) Arbitrary hint string indicating the
                       item shape. Plugins reimplementing <code>vim.ui.select</code> may
                       wish to use this to infer the structure or semantics of
                       <code>items</code>, or the context in which select() was called.
</div><div class="help-li" style=""> <code>{on_choice}</code>  (<code>fun(item: T?, idx: integer?)</code>) Called once the user
                     made a choice. <code>idx</code> is the 1-based index of <code>item</code>
                     within <code>items</code>. <code>nil</code> if the user aborted the dialog.
</div>
</div>
<div class="help-para">
<h2 id="_lua-module:-vim.uri" class="help-heading">Lua module: vim.uri<span class="help-heading-tags">                                                  <span id="vim.uri" class="help-tag"><a href="#vim.uri">vim.uri</a></span></h2>


</div>
<div class="help-para">
vim.uri_decode(<code>{str}</code>)                                       <span id="vim.uri_decode()" class="help-tag-right"><a href="#vim.uri_decode()">vim.uri_decode()</a></span><br>
    URI-decodes a string containing percent escapes.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) string to decode
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) decoded string

</div>
<div class="help-para">
vim.uri_encode(<code>{str}</code>, <code>{rfc}</code>)                                <span id="vim.uri_encode()" class="help-tag-right"><a href="#vim.uri_encode()">vim.uri_encode()</a></span><br>
    URI-encodes a string using percent escapes.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  (<code>string</code>) string to encode
</div><div class="help-li" style=""> <code>{rfc}</code>  (<code>"rfc2396"|"rfc2732"|"rfc3986"?</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) encoded string

</div>
<div class="help-para">
vim.uri_from_bufnr(<code>{bufnr}</code>)                             <span id="vim.uri_from_bufnr()" class="help-tag-right"><a href="#vim.uri_from_bufnr()">vim.uri_from_bufnr()</a></span><br>
    Gets a URI from a bufnr.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>  (<code>integer</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) URI

</div>
<div class="help-para">
vim.uri_from_fname(<code>{path}</code>)                              <span id="vim.uri_from_fname()" class="help-tag-right"><a href="#vim.uri_from_fname()">vim.uri_from_fname()</a></span><br>
    Gets a URI from a file path.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (<code>string</code>) Path to file
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) URI

</div>
<div class="help-para">
vim.uri_to_bufnr(<code>{uri}</code>)                                   <span id="vim.uri_to_bufnr()" class="help-tag-right"><a href="#vim.uri_to_bufnr()">vim.uri_to_bufnr()</a></span><br>
    Gets the buffer for a uri. Creates a new unloaded buffer if no buffer for
    the uri already exists.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{uri}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>) bufnr

</div>
<div class="help-para">
vim.uri_to_fname(<code>{uri}</code>)                                   <span id="vim.uri_to_fname()" class="help-tag-right"><a href="#vim.uri_to_fname()">vim.uri_to_fname()</a></span><br>
    Gets a filename from a URI.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{uri}</code>  (<code>string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>string</code>) filename or unchanged URI for non-file URIs

</div>
<div class="help-para">
<h2 id="_lua-module:-vim.version" class="help-heading">Lua module: vim.version<span class="help-heading-tags">                                          <span id="vim.version" class="help-tag"><a href="#vim.version">vim.version</a></span></h2>


</div>
<div class="help-para">
The <code>vim.version</code> module provides functions for comparing versions and ranges
conforming to the <a href="https://semver.org">https://semver.org</a> spec. Plugins, and plugin managers, can
use this to check available tools and dependencies on the current system.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">local v = vim.version.parse(vim.system({'tmux', '-V'}):wait().stdout, {strict=false})
if vim.version.gt(v, {3, 2, 0}) then
  -- ...
end</code></pre>

</div>
<div class="help-para">
<span id="vim.version()" class="help-tag"><a href="#vim.version()">vim.version()</a></span> returns the version of the current Nvim process.

</div>
<div class="help-para">
<h3 id="_version-range-spec" class="help-heading">VERSION RANGE SPEC<span class="help-heading-tags">                                             <span id="version-range" class="help-tag"><a href="#version-range">version-range</a></span></h3>


</div>
<div class="help-para">
A version "range spec" defines a semantic version range which can be tested
against a version, using <a href="lua.html#vim.version.range()">vim.version.range()</a>.

</div>
<div class="help-para">
Supported range specs are shown in the following table.<b> Note:</b> suffixed
versions (1.2.3-rc1) are not matched.<pre>1.2.3             is 1.2.3
=1.2.3            is 1.2.3
&gt;1.2.3            greater than 1.2.3
&lt;1.2.3            before 1.2.3
&gt;=1.2.3           at least 1.2.3
&lt;=1.2.3           at most 1.2.3
~1.2.3            is &gt;=1.2.3 &lt;1.3.0       "reasonably close to 1.2.3"
^1.2.3            is &gt;=1.2.3 &lt;2.0.0       "compatible with 1.2.3"
^0.2.3            is &gt;=0.2.3 &lt;0.3.0       (0.x.x is special)
^0.0.1            is =0.0.1               (0.0.x is special)
^1.2              is &gt;=1.2.0 &lt;2.0.0       (like ^1.2.0)
~1.2              is &gt;=1.2.0 &lt;1.3.0       (like ~1.2.0)
^1                is &gt;=1.0.0 &lt;2.0.0       "compatible with 1"
~1                same                    "reasonably close to 1"
1.x               same
1.*               same
1                 same
*                 any version
x                 same
1.2.3 - 2.3.4     is &gt;=1.2.3 &lt;2.3.4
Partial right: missing pieces treated as x (2.3 =&gt; 2.3.x).
1.2.3 - 2.3       is &gt;=1.2.3 &lt;2.4.0
1.2.3 - 2         is &gt;=1.2.3 &lt;3.0.0
Partial left: missing pieces treated as 0 (1.2 =&gt; 1.2.0).
1.2 - 2.3.0       is 1.2.0 - 2.3.0</pre>

</div>
<div class="help-para">
<span id="vim.VersionRange" class="help-tag"><a href="#vim.VersionRange">vim.VersionRange</a></span>

</div>
<div class="help-para">
<div class="help-column_heading">Fields:</div>
<div class="help-li" style=""> <code>{from}</code>  (<code>vim.Version</code>)
</div><div class="help-li" style=""> <code>{to}?</code>   (<code>vim.Version</code>)
</div><div class="help-li" style=""> <code>{has}</code>   (<code>fun(self: vim.VersionRange, version: string|vim.Version): boolean</code>)
                See <a href="lua.html#VersionRange%3Ahas()">VersionRange:has()</a>.
</div>
</div>
<div class="help-para">
VersionRange:has(<code>{version}</code>)                               <span id="VersionRange%3Ahas()" class="help-tag-right"><a href="#VersionRange%3Ahas()">VersionRange:has()</a></span><br>
    Check if a version is in the range (inclusive <code>from</code>, exclusive <code>to</code>).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local r = vim.version.range('1.0.0 - 2.0.0')
print(r:has('1.9.9'))       -- true
print(r:has('2.0.0'))       -- false
print(r:has(vim.version())) -- check against current Nvim version</code></pre>

</div>
<div class="help-para">
    Or use cmp(), le(), lt(), ge(), gt(), and/or eq() to compare a version
    against <code>.to</code> and <code>.from</code> directly:<pre><code class="language-lua">local r = vim.version.range('1.0.0 - 2.0.0') -- &gt;=1.0, &lt;2.0
print(vim.version.ge({1,0,3}, r.from) and vim.version.lt({1,0,3}, r.to))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{version}</code>  (<code>string|vim.Version</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://github.com/npm/node-semver#ranges">https://github.com/npm/node-semver#ranges</a>
</div>
</div>
<div class="help-para">
vim.version.cmp(<code>{v1}</code>, <code>{v2}</code>)                                <span id="vim.version.cmp()" class="help-tag-right"><a href="#vim.version.cmp()">vim.version.cmp()</a></span><br>
    Parses and compares two version objects (the result of
    <a href="lua.html#vim.version.parse()">vim.version.parse()</a>, or specified literally as a <code>{major, minor, patch}</code>
    tuple, e.g. <code>{1, 0, 3}</code>).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">if vim.version.cmp({1,0,3}, {0,2,1}) == 0 then
  -- ...
end
local v1 = vim.version.parse('1.0.3-pre')
local v2 = vim.version.parse('0.2.1')
if vim.version.cmp(v1, v2) == 0 then
  -- ...
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading"><b>    Note:</b></div>
<div class="help-li" style=""> Per semver, build metadata is ignored when comparing two
        otherwise-equivalent versions.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>) Version object.
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>) Version to compare with <code>v1</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>integer</code>) -1 if <code>v1 &lt; v2</code>, 0 if <code>v1 == v2</code>, 1 if <code>v1 &gt; v2</code>.

</div>
<div class="help-para">
vim.version.eq(<code>{v1}</code>, <code>{v2}</code>)                                  <span id="vim.version.eq()" class="help-tag-right"><a href="#vim.version.eq()">vim.version.eq()</a></span><br>
    Returns <code>true</code> if the given versions are equal. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a>
    for usage.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>)
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.version.ge(<code>{v1}</code>, <code>{v2}</code>)                                  <span id="vim.version.ge()" class="help-tag-right"><a href="#vim.version.ge()">vim.version.ge()</a></span><br>
    Returns <code>true</code> if <code>v1 &gt;= v2</code>. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.10.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>)
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.version.gt(<code>{v1}</code>, <code>{v2}</code>)                                  <span id="vim.version.gt()" class="help-tag-right"><a href="#vim.version.gt()">vim.version.gt()</a></span><br>
    Returns <code>true</code> if <code>v1 &gt; v2</code>. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>)
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.version.intersect(<code>{r1}</code>, <code>{r2}</code>)                    <span id="vim.version.intersect()" class="help-tag-right"><a href="#vim.version.intersect()">vim.version.intersect()</a></span><br>
<b>    WARNING:</b> This feature is experimental/unstable.

</div>
<div class="help-para">
    Computes the common range shared by the given ranges.

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{r1}</code>  (<code>vim.VersionRange</code>) First range to intersect. See
              <a href="lua.html#vim.VersionRange">vim.VersionRange</a>.
</div><div class="help-li" style=""> <code>{r2}</code>  (<code>vim.VersionRange</code>) Second range to intersect. See
              <a href="lua.html#vim.VersionRange">vim.VersionRange</a>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.VersionRange?</code>) Maximal range that is present inside both <code>r1</code>
        and <code>r2</code>. <code>nil</code> if such range does not exist. See <a href="lua.html#vim.VersionRange">vim.VersionRange</a>.

</div>
<div class="help-para">
vim.version.last(<code>{versions}</code>)                              <span id="vim.version.last()" class="help-tag-right"><a href="#vim.version.last()">vim.version.last()</a></span><br>
    TODO: generalize this, move to func.lua

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{versions}</code>  (<code>vim.Version[]</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.Version?</code>)

</div>
<div class="help-para">
vim.version.le(<code>{v1}</code>, <code>{v2}</code>)                                  <span id="vim.version.le()" class="help-tag-right"><a href="#vim.version.le()">vim.version.le()</a></span><br>
    Returns <code>true</code> if <code>v1 &lt;= v2</code>. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.10.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>)
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.version.lt(<code>{v1}</code>, <code>{v2}</code>)                                  <span id="vim.version.lt()" class="help-tag-right"><a href="#vim.version.lt()">vim.version.lt()</a></span><br>
    Returns <code>true</code> if <code>v1 &lt; v2</code>. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  (<code>vim.Version|number[]|string</code>)
</div><div class="help-li" style=""> <code>{v2}</code>  (<code>vim.Version|number[]|string</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>boolean</code>)

</div>
<div class="help-para">
vim.version.parse(<code>{version}</code>, <code>{opts}</code>)                     <span id="vim.version.parse()" class="help-tag-right"><a href="#vim.version.parse()">vim.version.parse()</a></span><br>
    Parses a semantic version string and returns a version object which can be
    used with other <code>vim.version</code> functions. For example "1.0.1-rc1+build.2"
    returns:<pre>{ major = 1, minor = 0, patch = 1, prerelease = "rc1", build = "build.2" }</pre>

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{version}</code>  (<code>string</code>) Version string to parse.
</div><div class="help-li" style=""> <code>{opts}</code>     (<code>table?</code>) Options for parsing.
</div><div class="help-li" style="margin-left: 3rem;"> <code>{strict}?</code> (<code>boolean</code>, default: <code>false</code>) If <code>true</code>, no
                     coercion is attempted on input not conforming to semver
                     v2.0.0. If <code>false</code>, <code>parse()</code> attempts to coerce input
                     such as "1.0", "0-x", "tmux 3.2a" into valid versions.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.Version?</code>) <code>Version</code> object or <code>nil</code> if input is invalid.

</div>
<div class="help-para">
<div class="help-column_heading">See also:</div>
<div class="help-li" style=""> <a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>
</div>
</div>
<div class="help-para">
vim.version.range(<code>{spec}</code>)                                <span id="vim.version.range()" class="help-tag-right"><a href="#vim.version.range()">vim.version.range()</a></span><br>
    Parses a semver <a href="lua.html#version-range">version-range</a> "spec" and returns <a href="lua.html#vim.VersionRange">vim.VersionRange</a>
    object:

</div>
<div class="help-para">
<div class="help-column_heading">Attributes:</div>
        Since: 0.9.0

</div>
<div class="help-para">
<div class="help-column_heading">Parameters:</div>
<div class="help-li" style=""> <code>{spec}</code>  (<code>string</code>) Version range "spec"
</div>
</div>
<div class="help-para">
<div class="help-column_heading">Return:</div>
        (<code>vim.VersionRange?</code>) See <a href="lua.html#vim.VersionRange">vim.VersionRange</a>.

</div>
<div class="help-para">
<h2 id="_ui2" class="help-heading">UI2<span class="help-heading-tags">                                                                      <span id="ui2" class="help-tag"><a href="#ui2">ui2</a></span></h2>


</div>
<div class="help-para">
<b>WARNING:</b> This is an experimental interface intended to replace the message
grid in the TUI.

</div>
<div class="help-para">
To enable the experimental UI (default opts shown):<pre><code class="language-lua">require('vim._core.ui2').enable({
 enable = true, -- Whether to enable or disable the UI.
 msg = { -- Options related to the message module.
   ---@type 'cmd'|'msg' Where to place regular messages, either in the
   ---cmdline or in a separate ephemeral message window.
   target = 'cmd',
   timeout = 4000, -- Time a message is visible in the message window.
 },
})</code></pre>

</div>
<div class="help-para">
There are four separate window types used by this interface:
<div class="help-li" style=""> "cmd": The cmdline window; also used for <a href="options.html#'showcmd'">'showcmd'</a>, <a href="options.html#'showmode'">'showmode'</a>, <a href="options.html#'ruler'">'ruler'</a>, and
  messages if <a href="options.html#'cmdheight'">'cmdheight'</a> &gt; 0.
</div><div class="help-li" style=""> "msg": The message window; used for messages when <a href="options.html#'cmdheight'">'cmdheight'</a> == 0.
</div><div class="help-li" style=""> "pager": The pager window; used for <a href="message.html#%3Amessages">:messages</a> and certain messages that
  should be shown in full.
</div><div class="help-li" style=""> "dialog": The dialog window; used for prompt messages that expect user
  input.
</div>
</div>
<div class="help-para">
These four windows are assigned the "cmd", "msg", "pager" and "dialog"
<a href="options.html#'filetype'">'filetype'</a> respectively. Use a <a href="autocmd.html#FileType">FileType</a> autocommand to configure any local
options for these windows and their respective buffers.

</div>
<div class="help-para">
Rather than a <a href="message.html#hit-enter-prompt">hit-enter-prompt</a>, messages shown in the cmdline area that do
not fit are appended with a <code>[+x]</code> "spill" indicator, where <code>x</code> indicates the
spilled lines. To see the full message, the <a href="message.html#g%3C">g&lt;</a> command can be used.

</div>

  </div>
      <div class="col-narrow toc">
      <div><a href="index.html">Main</a></div>
      <div><a href="vimindex.html">Commands index</a></div>
      <div><a href="quickref.html">Quick reference</a></div>
      <hr/>
  <div class="help-toc-h1"><a href="#_introduction">INTRODUCTION</a>
</div><div class="help-toc-h1"><a href="#_lua-concepts-and-idioms">LUA CONCEPTS AND IDIOMS</a>
</div><div class="help-toc-h1"><a href="#_importing-lua-modules">IMPORTING LUA MODULES</a>
</div><div class="help-toc-h1"><a href="#_commands">COMMANDS</a>
</div><div class="help-toc-h1"><a href="#_luaeval()">luaeval()</a>
</div><div class="help-toc-h1"><a href="#_vimscript-v:lua-interface">Vimscript v:lua interface</a>
</div><div class="help-toc-h1"><a href="#_lua-standard-modules">Lua standard modules</a>
</div><div class="help-toc-h1"><a href="#_vim">VIM</a>
</div><div class="help-toc-h1"><a href="#_lua-vimscript-bridge">LUA-VIMSCRIPT BRIDGE</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim">Lua module: vim</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.inspector">Lua module: vim.inspector</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.base64">Lua module: vim.base64</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.filetype">Lua module: vim.filetype</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.fs">Lua module: vim.fs</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.glob">Lua module: vim.glob</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.hl">Lua module: vim.hl</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.iter">Lua module: vim.iter</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.json">Lua module: vim.json</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.keymap">Lua module: vim.keymap</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.loader">Lua module: vim.loader</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.lpeg">Lua module: vim.lpeg</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.mpack">Lua module: vim.mpack</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.net">Lua module: vim.net</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.pos">Lua module: vim.pos</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.range">Lua module: vim.range</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.re">Lua module: vim.re</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.regex">Lua module: vim.regex</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.secure">Lua module: vim.secure</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.snippet">Lua module: vim.snippet</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.spell">Lua module: vim.spell</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.system">Lua module: vim.system</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.text">Lua module: vim.text</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.ui">Lua module: vim.ui</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.uri">Lua module: vim.uri</a>
</div><div class="help-toc-h1"><a href="#_lua-module:-vim.version">Lua module: vim.version</a>
</div><div class="help-toc-h1"><a href="#_ui2">UI2</a>
</div></div>
</div>
  <footer>
    <div class="container flex">
      <div class="generator-stats">
        Generated at 2026-02-23 22:01 from <code><a href="https://github.com/neovim/neovim/commit/eb90f5d9e3a6615870f9bf0b28e30f6e84ccd6f4">eb90f5d</a></code>
      </div>
      <div class="generator-stats">
      parse_errors: 0 (<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML%3A+lua.txt+&body=%60gen_help_html.lua%60+problem+at%3A+https://neovim.io/doc/user/lua.html%0D%0DContext%3A%0D%0D%60%60%60%0DTODO%0D%60%60%60" target="_blank">report docs bug...</a>) | <span title="    Nvim
                            NVIM REFERENCE MANUAL
                                       Type &lt;a href="various.html#gO"&gt;gO&lt;/a&gt; to see the table of contents.">noise_lines: 3</span>
      </div>
    <div>

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
    <script type="module">
      docsearch({
        container: '#docsearch',
        appId: 'X185E15FPG',
        apiKey: 'b5e6b2f9c636b2b471303205e59832ed',
        indexName: 'nvim',
      });
    </script>

  </footer>
  </body>
</html>
