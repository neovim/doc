  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Neovim user documentation">
    <link href="/css/normalize.min.css" rel="stylesheet">
    <link href="/css/bootstrap.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="help.css" rel="stylesheet">
    <link href="/highlight/styles/neovim.min.css" rel="stylesheet">

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@3" />
    <link rel="preconnect" href="https://X185E15FPG-dsn.algolia.net" crossorigin />

    <script src="/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <title> Lua - Neovim docs</title>
  </head>
  <body>
    <header class="container">
    <nav class="navbar navbar-expand-lg">
      <div class="container-fluid">
        <a href="/" class="navbar-brand" aria-label="logo">
          <!--TODO: use <img src="….svg"> here instead. Need one that has green lettering instead of gray. -->
              <svg xmlns="http://www.w3.org/2000/svg" role="img" width="173" height="50" viewBox="0 0 742 214" aria-label="Neovim">
      <title>Neovim</title>
      <defs>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="a">
          <stop stop-color="#16B0ED" stop-opacity=".8" offset="0%" />
          <stop stop-color="#0F59B2" stop-opacity=".837" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="b">
          <stop stop-color="#7DB643" offset="0%" />
          <stop stop-color="#367533" offset="100%" />
        </linearGradient>
        <linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c">
          <stop stop-color="#88C649" stop-opacity=".8" offset="0%" />
          <stop stop-color="#439240" stop-opacity=".84" offset="100%" />
        </linearGradient>
      </defs>
      <g fill="none" fill-rule="evenodd">
        <path
          d="M.027 45.459L45.224-.173v212.171L.027 166.894V45.459z"
          fill="url(#a)"
          transform="translate(1 1)"
        />
        <path
          d="M129.337 45.89L175.152-.149l-.928 212.146-45.197-45.104.31-121.005z"
          fill="url(#b)"
          transform="matrix(-1 0 0 1 305 1)"
        />
        <path
          d="M45.194-.137L162.7 179.173l-32.882 32.881L12.25 33.141 45.194-.137z"
          fill="url(#c)"
          transform="translate(1 1)"
        />
        <path
          d="M46.234 84.032l-.063 7.063-36.28-53.563 3.36-3.422 32.983 49.922z"
          fill-opacity=".13"
          fill="#000"
        />
        <g fill="#444">
          <path
            d="M227 154V64.44h4.655c1.55 0 2.445.75 2.685 2.25l.806 13.502c4.058-5.16 8.786-9.316 14.188-12.466 5.4-3.15 11.413-4.726 18.037-4.726 4.893 0 9.205.781 12.935 2.34 3.729 1.561 6.817 3.811 9.264 6.751 2.448 2.942 4.297 6.48 5.55 10.621 1.253 4.14 1.88 8.821 1.88 14.042V154h-8.504V96.754c0-8.402-1.91-14.987-5.729-19.757-3.82-4.771-9.667-7.156-17.544-7.156-5.851 0-11.28 1.516-16.292 4.545-5.013 3.032-9.489 7.187-13.427 12.467V154H227zM350.624 63c5.066 0 9.755.868 14.069 2.605 4.312 1.738 8.052 4.268 11.219 7.592s5.638 7.412 7.419 12.264C385.11 90.313 386 95.883 386 102.17c0 1.318-.195 2.216-.588 2.696-.393.48-1.01.719-1.851.719h-64.966v1.70c0 6.708.784 12.609 2.353 17.7 1.567 5.09 3.8 9.357 6.695 12.802 2.895 3.445 6.393 6.034 10.495 7.771 4.1 1.738 8.686 2.606 13.752 2.606 4.524 0 8.446-.494 11.762-1.483 3.317-.988 6.108-2.097 8.37-3.324 2.261-1.227 4.056-2.336 5.383-3.324 1.326-.988 2.292-1.482 2.895-1.482.784 0 1.388.3 1.81.898l2.352 2.875c-1.448 1.797-3.362 3.475-5.745 5.031-2.383 1.558-5.038 2.891-7.962 3.998-2.926 1.109-6.062 1.991-9.41 2.65a52.21 52.21 0 01-10.088.989c-6.152 0-11.762-1.064-16.828-3.19-5.067-2.125-9.415-5.225-13.043-9.298-3.63-4.074-6.435-9.06-8.415-14.96C310.99 121.655 310 114.9 310 107.294c0-6.408.92-12.323 2.76-17.744 1.84-5.421 4.493-10.093 7.961-14.016 3.467-3.922 7.72-6.991 12.758-9.209C338.513 64.11 344.229 63 350.624 63zm.573 6c-4.696 0-8.904.702-12.623 2.105-3.721 1.404-6.936 3.421-9.65 6.053-2.713 2.631-4.908 5.79-6.586 9.474S319.55 94.439 319 99h60c0-4.679-.672-8.874-2.013-12.588-1.343-3.712-3.232-6.856-5.67-9.43-2.44-2.571-5.367-4.545-8.782-5.92-3.413-1.374-7.192-2.062-11.338-2.062zM435.546 63c6.526 0 12.368 1.093 17.524 3.28 5.154 2.186 9.5 5.286 13.04 9.298 3.538 4.013 6.238 8.85 8.099 14.51 1.861 5.66 2.791 11.994 2.791 19.002 0 7.008-.932 13.327-2.791 18.957-1.861 5.631-4.561 10.452-8.099 14.465-3.54 4.012-7.886 7.097-13.04 9.254-5.156 2.156-10.998 3.234-17.524 3.234-6.529 0-12.369-1.078-17.525-3.234-5.155-2.157-9.517-5.242-13.085-9.254-3.57-4.013-6.285-8.836-8.145-14.465-1.861-5.63-2.791-11.95-2.791-18.957 0-7.008.93-13.342 2.791-19.002 1.861-5.66 4.576-10.496 8.145-14.51 3.568-4.012 7.93-7.112 13.085-9.299C423.177 64.094 429.017 63 435.546 63zm-.501 86c5.341 0 10.006-.918 13.997-2.757 3.99-1.838 7.32-4.474 9.992-7.909 2.67-3.435 4.664-7.576 5.986-12.428 1.317-4.85 1.98-10.288 1.98-16.316 0-5.965-.66-11.389-1.98-16.27-1.322-4.88-3.316-9.053-5.986-12.519-2.67-3.463-6-6.13-9.992-7.999-3.991-1.867-8.657-2.802-13.997-2.802s-10.008.935-13.997 2.802c-3.991 1.87-7.322 4.536-9.992 8-2.671 3.465-4.68 7.637-6.03 12.518-1.35 4.881-2.026 10.305-2.026 16.27 0 6.026.675 11.465 2.025 16.316 1.35 4.852 3.36 8.993 6.031 12.428 2.67 3.435 6 6.07 9.992 7.91 3.99 1.838 8.656 2.756 13.997 2.756z"
            fill="currentColor"
          />
          <path
            d="M530.57 152h-20.05L474 60h18.35c1.61 0 2.967.39 4.072 1.166 1.103.778 1.865 1.763 2.283 2.959l17.722 49.138a92.762 92.762 0 012.551 8.429c.686 2.751 1.298 5.5 1.835 8.25.537-2.75 1.148-5.499 1.835-8.25a77.713 77.713 0 012.64-8.429l18.171-49.138c.417-1.196 1.164-2.181 2.238-2.96 1.074-.776 2.356-1.165 3.849-1.165H567l-36.43 92zM572 61h23v92h-23zM610 153V60.443h13.624c2.887 0 4.78 1.354 5.682 4.06l1.443 6.856a52.7 52.7 0 015.097-4.962 32.732 32.732 0 015.683-3.879 30.731 30.731 0 016.496-2.57c2.314-.632 4.855-.948 7.624-.948 5.832 0 10.63 1.579 14.39 4.736 3.758 3.157 6.57 7.352 8.434 12.585 1.444-3.068 3.248-5.698 5.413-7.894 2.165-2.194 4.541-3.984 7.127-5.367a32.848 32.848 0 018.254-3.068 39.597 39.597 0 018.796-.992c5.111 0 9.653.783 13.622 2.345 3.97 1.565 7.307 3.849 10.014 6.857 2.706 3.007 4.766 6.675 6.18 11.005C739.29 83.537 740 88.5 740 94.092V153h-22.284V94.092c0-5.894-1.294-10.329-3.878-13.306-2.587-2.977-6.376-4.465-11.368-4.465-2.286 0-4.404.391-6.358 1.172a15.189 15.189 0 00-5.144 3.383c-1.473 1.474-2.631 3.324-3.474 5.548-.842 2.225-1.263 4.781-1.263 7.668V153h-22.37V94.092c0-6.194-1.249-10.704-3.744-13.532-2.497-2.825-6.18-4.24-11.051-4.24-3.19 0-6.18.798-8.976 2.391-2.799 1.593-5.399 3.775-7.804 6.54V153H610zM572 30h23v19h-23z"
            fill="currentColor"
            fill-opacity=".8"
          />
        </g>
      </g>
    </svg>
  
          <!--<img src="https://neovim.io/logos/neovim-logo.svg" width="173" height="50" alt="Neovim" />-->
        </a>
        <div id="docsearch"></div> <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
      </div>
    </nav>
  </header>

  <div class="container golden-grid help-body">
  <div class="col-wide">
  <a name="lua"></a><h1 id="lua.txt"> Lua</h1>
  <p>
    <i>
    Nvim <code>:help</code> pages, <a href="https://github.com/neovim/neovim/blob/master/scripts/gen_help_html.lua">generated</a>
    from <a href="https://github.com/neovim/neovim/blob/master/runtime/doc/lua.txt">source</a>
    using the <a href="https://github.com/neovim/tree-sitter-vimdoc">tree-sitter-vimdoc</a> parser.
    </i>
  </p>
  <hr/>
  <div class="help-para">
Lua engine <code id="Lua" class="help-tag">Lua</code>

</div>
<div class="help-para">
<h2 id="lua-intro" class="help-heading">INTRODUCTION<span class="help-heading-tags">                                                       <span class="help-tag">lua-intro</span></h2>


</div>
<div class="help-para">
The Lua 5.1 script engine is builtin and always available. Try this command to
get an idea of what lurks beneath:<pre><code class="language-vim">:lua vim.print(package.loaded)</code></pre>
Nvim includes a "standard library" <a href="lua.html#lua-stdlib">lua-stdlib</a> for Lua.  It complements the
"editor stdlib" (<a href="builtin.html#builtin-functions">builtin-functions</a> and <a href="vimindex.html#Ex-commands">Ex-commands</a>) and the <a href="api.html#API">API</a>, all of
which can be used from Lua code (<a href="lua.html#lua-vimscript">lua-vimscript</a> <a href="lua.html#vim.api">vim.api</a>). Together these
"namespaces" form the Nvim programming interface.

</div>
<div class="help-para">
Lua plugins and user config are automatically discovered and loaded, just like
Vimscript. See <a href="lua-guide.html#lua-guide">lua-guide</a> for practical guidance.

</div>
<div class="help-para">
You can also run Lua scripts from your shell using the <a href="starting.html#-l">-l</a> argument:<pre>nvim -l foo.lua [args...]</pre>

</div>
<div class="help-para">
                                                                  <code id="lua-compat" class="help-tag-right">lua-compat</code>
Lua 5.1 is the permanent interface for Nvim Lua.  Plugins need only consider
Lua 5.1, not worry about forward-compatibility with future Lua versions.  If
Nvim ever ships with Lua 5.4+, a Lua 5.1 compatibility shim will be provided
so that old plugins continue to work transparently.

</div>
<div class="help-para">
                                                                  <code id="lua-luajit" class="help-tag-right">lua-luajit</code>
Nvim is built with luajit on platforms which support it, which provides
extra functionality. Lua code in <a href="starting.html#init.lua">init.lua</a> and plugins can assume its presence
on installations on common platforms. For maximum compatibility with less
common platforms, availability can be checked using the <code>jit</code> global variable:<pre><code class="language-lua">if jit then
  -- code for luajit
else
  -- code for plain lua 5.1
end</code></pre>

</div>
<div class="help-para">
                                                                  <code id="lua-bit" class="help-tag-right">lua-bit</code>
In particular, the luajit "bit" extension module is _always_ available.
A fallback implementation is included when nvim is built with PUC Lua 5.1,
and will be transparently used when <code>require("bit")</code> is invoked.

</div>
<div class="help-para">
<h2 id="lua-concepts" class="help-heading">LUA CONCEPTS AND IDIOMS<span class="help-heading-tags">                                         <span class="help-tag">lua-concepts</span></h2>


</div>
<div class="help-para">
Lua is very simple: this means that, while there are some quirks, once you
internalize those quirks, everything works the same everywhere. Scopes
(closures) in particular are very consistent, unlike JavaScript or most other
languages.

</div>
<div class="help-para">
Lua has three fundamental mechanisms—one for "each major aspect of
programming": tables, closures, and coroutines.
<a href="https://www.lua.org/doc/cacm2018.pdf">https://www.lua.org/doc/cacm2018.pdf</a>
<div class="help-li" style=""> Tables are the "object" or container datastructure: they represent both
  lists and maps, you can extend them to represent your own datatypes and
  change their behavior using <a href="luaref.html#luaref-metatable">luaref-metatable</a> (like Python's "datamodel").
</div><div class="help-li" style=""> EVERY scope in Lua is a closure: a function is a closure, a module is
  a closure, a <code>do</code> block (<a href="luaref.html#luaref-do">luaref-do</a>) is a closure--and they all work the
  same. A Lua module is literally just a big closure discovered on the "path"
  (where your modules are found: <a href="luaref.html#package.cpath">package.cpath</a>).
</div><div class="help-li" style=""> Stackful coroutines enable cooperative multithreading, generators, and
  versatile control for both Lua and its host (Nvim).
</div>
</div>
<div class="help-para">
                                                           <code id="lua-call-function" class="help-tag-right">lua-call-function</code>
Lua functions can be called in multiple ways. Consider the function:<pre><code class="language-lua">local foo = function(a, b)
    print("A: ", a)
    print("B: ", b)
end</code></pre>
The first way to call this function is:<pre><code class="language-lua">foo(1, 2)
-- ==== Result ====
-- A: 1
-- B: 2</code></pre>
This way of calling a function is familiar from most scripting languages.
In Lua, any missing arguments are passed as <code>nil</code>. Example:<pre><code class="language-lua">foo(1)
-- ==== Result ====
-- A: 1
-- B: nil</code></pre>
Furthermore it is not an error if extra parameters are passed, they are just
discarded.

</div>
<div class="help-para">
                                                                      <code id="kwargs" class="help-tag-right">kwargs</code>
When calling a function, you can omit the parentheses if the function takes
exactly one string literal (<code>"foo"</code>) or table literal (<code>{1,2,3}</code>). The latter
is often used to approximate "named parameters" ("kwargs" or "keyword args")
as in languages like Python and C#. Example:<pre><code class="language-lua">local func_with_opts = function(opts)
    local will_do_foo = opts.foo
    local filename = opts.filename
    ...
end
func_with_opts { foo = true, filename = "hello.world" }</code></pre>

</div>
<div class="help-para">
There's nothing special going on here except that parentheses are treated as
whitespace. But visually, this small bit of sugar gets reasonably close to
a "keyword args" interface.

</div>
<div class="help-para">
It is of course also valid to call the function with parentheses:<pre><code class="language-lua">func_with_opts({ foo = true, filename = "hello.world" })</code></pre>

</div>
<div class="help-para">
Nvim tends to prefer the keyword args style.

</div>
<div class="help-para">
<h3 id="lua-patterns" class="help-heading">LUA PATTERNS<span class="help-heading-tags">                                                    <span class="help-tag">lua-patterns</span></h3>


</div>
<div class="help-para">
Lua intentionally does not support regular expressions, instead it has limited
"patterns" <a href="luaref.html#luaref-patterns">luaref-patterns</a> which avoid the performance pitfalls of extended
regex. Lua scripts can also use Vim regex via <a href="lua.html#vim.regex()">vim.regex()</a>.

</div>
<div class="help-para">
These examples use <a href="luaref.html#string.match()">string.match()</a> to demonstrate Lua patterns:<pre><code class="language-lua">print(string.match("foo123bar123", "%d+"))
-- 123
print(string.match("foo123bar123", "[^%d]+"))
-- foo
print(string.match("foo123bar123", "[abc]+"))
-- ba
print(string.match("foo.bar", "%.bar"))
-- .bar</code></pre>
<h2 id="require()" class="help-heading">IMPORTING LUA MODULES<span class="help-heading-tags">                                  <span class="help-tag">require()</span> <span id="lua-require" class="help-tag">lua-require</span></span></h2>


</div>
<div class="help-para">
Modules are searched for under the directories specified in <a href="options.html#'runtimepath'">'runtimepath'</a>, in
the order they appear.  Any "." in the module name is treated as a directory
separator when searching.  For a module <code>foo.bar</code>, each directory is searched
for <code>lua/foo/bar.lua</code>, then <code>lua/foo/bar/init.lua</code>.  If no files are found,
the directories are searched again for a shared library with a name matching
<code>lua/foo/bar.?</code>, where <code>?</code> is a list of suffixes (such as <code>so</code> or <code>dll</code>) derived from
the initial value of <a href="luaref.html#package.cpath">package.cpath</a>. If still no files are found, Nvim falls
back to Lua's default search mechanism. The first script found is run and
<code>require()</code> returns the value returned by the script if any, else <code>true</code>.

</div>
<div class="help-para">
The return value is cached after the first call to <code>require()</code> for each module,
with subsequent calls returning the cached value without searching for, or
executing any script. For further details on <code>require()</code>, see <a href="luaref.html#luaref-require()">luaref-require()</a>.

</div>
<div class="help-para">
For example, if <a href="options.html#'runtimepath'">'runtimepath'</a> is <code>foo,bar</code> and <a href="luaref.html#package.cpath">package.cpath</a> was
<code>./?.so;./?.dll</code> at startup, <code>require('mod')</code> searches these paths in order
and loads the first module found ("first wins"):<pre>foo/lua/mod.lua
foo/lua/mod/init.lua
bar/lua/mod.lua
bar/lua/mod/init.lua
foo/lua/mod.so
foo/lua/mod.dll
bar/lua/mod.so
bar/lua/mod.dll</pre>

</div>
<div class="help-para">
                                                        <code id="lua-package-path" class="help-tag-right">lua-package-path</code>
Nvim automatically adjusts <a href="luaref.html#package.path">package.path</a> and <a href="luaref.html#package.cpath">package.cpath</a> according to the
effective <a href="options.html#'runtimepath'">'runtimepath'</a> value. Adjustment happens whenever <a href="options.html#'runtimepath'">'runtimepath'</a> is
changed. <code>package.path</code> is adjusted by simply appending <code>/lua/?.lua</code> and
<code>/lua/?/init.lua</code> to each directory from <a href="options.html#'runtimepath'">'runtimepath'</a> (<code>/</code> is actually the
first character of <code>package.config</code>).

</div>
<div class="help-para">
Similarly to <a href="luaref.html#package.path">package.path</a>, modified directories from <a href="options.html#'runtimepath'">'runtimepath'</a> are also
added to <a href="luaref.html#package.cpath">package.cpath</a>. In this case, instead of appending <code>/lua/?.lua</code> and
<code>/lua/?/init.lua</code> to each runtimepath, all unique <code>?</code>-containing suffixes of
the existing <a href="luaref.html#package.cpath">package.cpath</a> are used. Example:

</div>
<div class="help-para">
<div class="help-li" style=""> 1. Given that
</div><div class="help-li" style="margin-left: 3rem;"> <a href="options.html#'runtimepath'">'runtimepath'</a> contains <code>/foo/bar,/xxx;yyy/baz,/abc</code>;
</div><div class="help-li" style="margin-left: 3rem;"> initial <a href="luaref.html#package.cpath">package.cpath</a> (defined at compile-time or derived from
     <code>$LUA_CPATH</code> / <code>$LUA_INIT</code>) contains <code>./?.so;/def/ghi/a?d/j/g.elf;/def/?.so</code>.
</div><div class="help-li" style=""> 2. It finds <code>?</code>-containing suffixes <code>/?.so</code>, <code>/a?d/j/g.elf</code> and <code>/?.so</code>, in
     order: parts of the path starting from the first path component containing
     question mark and preceding path separator.
</div><div class="help-li" style=""> 3. The suffix of <code>/def/?.so</code>, namely <code>/?.so</code> is not unique, as it’s the same
     as the suffix of the first path from <a href="luaref.html#package.path">package.path</a> (i.e. <code>./?.so</code>). Which
     leaves <code>/?.so</code> and <code>/a?d/j/g.elf</code>, in this order.
</div><div class="help-li" style=""> 4. <a href="options.html#'runtimepath'">'runtimepath'</a> has three paths: <code>/foo/bar</code>, <code>/xxx;yyy/baz</code> and <code>/abc</code>. The
     second one contains a semicolon which is a paths separator so it is out,
     leaving only <code>/foo/bar</code> and <code>/abc</code>, in order.
</div><div class="help-li" style=""> 5. The cartesian product of paths from 4. and suffixes from 3. is taken,
     giving four variants. In each variant a <code>/lua</code> path segment is inserted
     between path and suffix, leaving:
</div><div class="help-li" style="margin-left: 3rem;"> <code>/foo/bar/lua/?.so</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>/foo/bar/lua/a?d/j/g.elf</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>/abc/lua/?.so</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>/abc/lua/a?d/j/g.elf</code>
</div><div class="help-li" style=""> 6. New paths are prepended to the original <a href="luaref.html#package.cpath">package.cpath</a>.
</div>
</div>
<div class="help-para">
The result will look like this:<pre>/foo/bar,/xxx;yyy/baz,/abc ('runtimepath')
× ./?.so;/def/ghi/a?d/j/g.elf;/def/?.so (package.cpath)
= /foo/bar/lua/?.so;/foo/bar/lua/a?d/j/g.elf;/abc/lua/?.so;/abc/lua/a?d/j/g.elf;./?.so;/def/ghi/a?d/j/g.elf;/def/?.so</pre>
Note:

</div>
<div class="help-para">
<div class="help-li" style=""> To track <a href="options.html#'runtimepath'">'runtimepath'</a> updates, paths added at previous update are
  remembered and removed at the next update, while all paths derived from the
  new <a href="options.html#'runtimepath'">'runtimepath'</a> are prepended as described above. This allows removing
  paths when path is removed from <a href="options.html#'runtimepath'">'runtimepath'</a>, adding paths when they are
  added and reordering <a href="luaref.html#package.path">package.path</a>/|package.cpath| content if <a href="options.html#'runtimepath'">'runtimepath'</a>
  was reordered.
</div>
</div>
<div class="help-para">
<div class="help-li" style=""> Although adjustments happen automatically, Nvim does not track current
  values of <a href="luaref.html#package.path">package.path</a> or <a href="luaref.html#package.cpath">package.cpath</a>. If you happen to delete some
  paths from there you can set <a href="options.html#'runtimepath'">'runtimepath'</a> to trigger an update:<pre><code class="language-vim">let &amp;runtimepath = &amp;runtimepath</code></pre>
</div><div class="help-li" style=""> Skipping paths from <a href="options.html#'runtimepath'">'runtimepath'</a> which contain semicolons applies both to
  <a href="luaref.html#package.path">package.path</a> and <a href="luaref.html#package.cpath">package.cpath</a>. Given that there are some badly written
  plugins using shell, which will not work with paths containing semicolons,
  it is better to not have them in <a href="options.html#'runtimepath'">'runtimepath'</a> at all.
</div>
</div>
<div class="help-para">
<h2 id="lua-commands" class="help-heading">COMMANDS<span class="help-heading-tags">                                                        <span class="help-tag">lua-commands</span></h2>


</div>
<div class="help-para">
These commands execute a Lua chunk from either the command line (:lua, :luado)
or a file (:luafile) on the given line [range]. As always in Lua, each chunk
has its own scope (closure), so only global variables are shared between
command calls. The <a href="lua.html#lua-stdlib">lua-stdlib</a> modules, user modules, and anything else on
<a href="luaref.html#package.path">package.path</a> are available.

</div>
<div class="help-para">
The Lua print() function redirects its output to the Nvim message area, with
arguments separated by " " (space) instead of "\t" (tab).

</div>
<div class="help-para">
                                                                  <code id="%3Alua%3D" class="help-tag-right">:lua=</code> <code id="%3Alua" class="help-tag">:lua</code>
:lua <code>{chunk}</code>
    Executes Lua chunk <code>{chunk}</code>. If <code>{chunk}</code> starts with "=" the rest of the
    chunk is evaluated as an expression and printed. <code>:lua =expr</code> or <code>:=expr</code> is
    equivalent to <code>:lua print(vim.inspect(expr))</code>.

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:lua vim.api.nvim_command('echo "Hello, Nvim!"')</code></pre>

</div>
<div class="help-para">
    To see the Lua version:<pre><code class="language-vim">:lua print(_VERSION)</code></pre>

</div>
<div class="help-para">
    To see the LuaJIT version:<pre><code class="language-vim">:lua =jit.version</code></pre>

</div>
<div class="help-para">
                                                                <code id="%3Alua-heredoc" class="help-tag-right">:lua-heredoc</code>
:lua &lt;&lt; [trim] [<code>{endmarker}</code>]
<code>{script}</code>
<code>{endmarker}</code>
    Executes Lua script <code>{script}</code> from within Vimscript. You can omit
    [endmarker] after the "&lt;&lt;" and use a dot "." after <code>{script}</code> (similar to
    <a href="insert.html#%3Aappend">:append</a>, <a href="insert.html#%3Ainsert">:insert</a>). Refer to <a href="eval.html#%3Alet-heredoc">:let-heredoc</a> for more information.

</div>
<div class="help-para">
    Example:<pre><code class="language-vim">function! CurrentLineInfo()
lua &lt;&lt; EOF
local linenr = vim.api.nvim_win_get_cursor(0)[1]
local curline = vim.api.nvim_buf_get_lines(
        0, linenr - 1, linenr, false)[1]
print(string.format("Current line [%d] has %d bytes",
        linenr, #curline))
EOF
endfunction</code></pre>

</div>
<div class="help-para">
    Note that the <code>local</code> variables will disappear when the block finishes.
    But not globals.

</div>
<div class="help-para">
                                                                      <code id="%3Aluado" class="help-tag-right">:luado</code>
:[range]luado <code>{body}</code>
    Executes Lua chunk "function(line, linenr) <code>{body}</code> end" for each buffer
    line in [range], where <code>line</code> is the current line text (without <code>&lt;EOL&gt;</code>),
    and <code>linenr</code> is the current line number. If the function returns a string
    that becomes the text of the corresponding buffer line. Default [range] is
    the whole file: "1,$".

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:luado return string.format("%s\t%d", line:reverse(), #line)
:lua require"lpeg"
:lua -- balanced parenthesis grammar:
:lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }
:luado if bp:match(line) then return "=&gt;\t" .. line end</code></pre>

</div>
<div class="help-para">
                                                                    <code id="%3Aluafile" class="help-tag-right">:luafile</code>
:luafile <code>{file}</code>
    Execute Lua script in <code>{file}</code>.
    The whole argument is used as the filename (like <a href="editing.html#%3Aedit">:edit</a>), spaces do not
    need to be escaped. Alternatively you can <a href="repeat.html#%3Asource">:source</a> Lua files.

</div>
<div class="help-para">
    Examples:<pre><code class="language-vim">:luafile script.lua
:luafile %</code></pre>

</div>
<div class="help-para">
<h2 id="lua-eval" class="help-heading">luaeval()<span class="help-heading-tags">                                                 <span class="help-tag">lua-eval</span> <span id="luaeval()" class="help-tag">luaeval()</span></span></h2>


</div>
<div class="help-para">
The (dual) equivalent of "vim.eval" for passing Lua values to Nvim is
"luaeval". "luaeval" takes an expression string and an optional argument used
for _A inside expression and returns the result of the expression. It is
semantically equivalent in Lua to:<pre><code class="language-lua">local chunkheader = "local _A = select(1, ...) return "
function luaeval (expstr, arg)
    local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))
    return chunk(arg) -- return typval
end</code></pre>

</div>
<div class="help-para">
Lua nils, numbers, strings, tables and booleans are converted to their
respective Vimscript types. If a Lua string contains a NUL byte, it will be
converted to a <a href="eval.html#Blob">Blob</a>. Conversion of other Lua types is an error.

</div>
<div class="help-para">
The magic global "_A" contains the second argument to luaeval().

</div>
<div class="help-para">
Example:<pre><code class="language-vim">:echo luaeval('_A[1] + _A[2]', [40, 2])
" 42
:echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')
" foo</code></pre>

</div>
<div class="help-para">
                                                                    <code id="lua-table" class="help-tag-right">lua-table</code>
Lua tables are used as both dictionaries and lists, so it is impossible to
determine whether empty table is meant to be empty list or empty dictionary.
Additionally Lua does not have integer numbers. To distinguish between these
cases there is the following agreement:
                                                                     <code id="lua-list" class="help-tag-right">lua-list</code>
0. Empty table is empty list.
1. Table with N incrementally growing integral numbers, starting from 1 and
   ending with N is considered to be a list.
                                                                     <code id="lua-dict" class="help-tag-right">lua-dict</code>
2. Table with string keys, none of which contains NUL byte, is considered to
   be a dictionary.
3. Table with string keys, at least one of which contains NUL byte, is also
   considered to be a dictionary, but this time it is converted to
   a <a href="builtin.html#msgpack-special-map">msgpack-special-map</a>.
                                                              <code id="lua-special-tbl" class="help-tag-right">lua-special-tbl</code>
4. Table with <code>vim.type_idx</code> key may be a dictionary, a list or floating-point
   value:
<div class="help-li" style=""> <code>{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}</code> is converted to
     a floating-point 1.0. Note that by default integral Lua numbers are
     converted to <a href="eval.html#Number">Number</a>s, non-integral are converted to <a href="eval.html#Float">Float</a>s. This
     variant allows integral <a href="eval.html#Float">Float</a>s.
</div><div class="help-li" style=""> <code>{[vim.type_idx]=vim.types.dictionary}</code> is converted to an empty
     dictionary, <code>{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}</code> is
     converted to a dictionary <code>{'a': 42}</code>: non-string keys are ignored.
     Without <code>vim.type_idx</code> key tables with keys not fitting in 1., 2. or 3.
     are errors.
</div><div class="help-li" style=""> <code>{[vim.type_idx]=vim.types.array}</code> is converted to an empty list. As well
     as <code>{[vim.type_idx]=vim.types.array, [42]=1}</code>: integral keys that do not
     form a 1-step sequence from 1 to N are ignored, as well as all
     non-integral keys.
</div>
</div>
<div class="help-para">
Examples:<pre><code class="language-vim">:echo luaeval('math.pi')
:function Rand(x,y) " random uniform between x and y
:  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})
:  endfunction
:echo Rand(1,10)</code></pre>

</div>
<div class="help-para">
Note: Second argument to <code>luaeval</code> is converted ("marshalled") from Vimscript
to Lua, so changes to Lua containers do not affect values in Vimscript. Return
value is also always converted. When converting, <a href="builtin.html#msgpack-special-dict">msgpack-special-dict</a>s are
treated specially.

</div>
<div class="help-para">
<h2 id="v%3Alua-call" class="help-heading">Vimscript v:lua interface<span class="help-heading-tags">                                         <span class="help-tag">v:lua-call</span></h2>


</div>
<div class="help-para">
From Vimscript the special <code>v:lua</code> prefix can be used to call Lua functions
which are global or accessible from global tables. The expression<pre><code class="language-vim">call v:lua.func(arg1, arg2)</code></pre>
is equivalent to the Lua chunk<pre><code class="language-lua">return func(...)</code></pre>
where the args are converted to Lua values. The expression<pre><code class="language-vim">call v:lua.somemod.func(args)</code></pre>
is equivalent to the Lua chunk<pre><code class="language-lua">return somemod.func(...)</code></pre>
In addition, functions of packages can be accessed like<pre><code class="language-vim">call v:lua.require'mypack'.func(arg1, arg2)
call v:lua.require'mypack.submod'.func(arg1, arg2)</code></pre>
Note: Only single quote form without parens is allowed. Using
<code>require"mypack"</code> or <code>require('mypack')</code> as prefixes do NOT work (the latter
is still valid as a function call of itself, in case require returns a useful
value).

</div>
<div class="help-para">
The <code>v:lua</code> prefix may be used to call Lua functions as <a href="eval.html#method">method</a>s. For
example:<pre><code class="language-vim">:eval arg1-&gt;v:lua.somemod.func(arg2)</code></pre>

</div>
<div class="help-para">
You can use <code>v:lua</code> in "func" options like <a href="options.html#'tagfunc'">'tagfunc'</a>, <a href="options.html#'omnifunc'">'omnifunc'</a>, etc.
For example consider the following Lua omnifunc handler:<pre><code class="language-lua">function mymod.omnifunc(findstart, base)
  if findstart == 1 then
    return 0
  else
    return {'stuff', 'steam', 'strange things'}
  end
end
vim.bo[buf].omnifunc = 'v:lua.mymod.omnifunc'</code></pre>
Note: The module ("mymod" in the above example) must either be a Lua global,
or use require() as shown above to access it from a package.

</div>
<div class="help-para">
Note: <code>v:lua</code> without a call is not allowed in a Vimscript expression:
<a href="eval.html#Funcref">Funcref</a>s cannot represent Lua functions. The following are errors:<pre><code class="language-vim">let g:Myvar = v:lua.myfunc        " Error
call SomeFunc(v:lua.mycallback)   " Error
let g:foo = v:lua                 " Error
let g:foo = v:['lua']             " Error</code></pre>

</div>
<div class="help-para">
<h2 id="lua-stdlib" class="help-heading">Lua standard modules<span class="help-heading-tags">                                              <span class="help-tag">lua-stdlib</span></h2>


</div>
<div class="help-para">
The Nvim Lua "standard library" (stdlib) is the <code>vim</code> module, which exposes
various functions and sub-modules. It is always loaded, thus <code>require("vim")</code>
is unnecessary.

</div>
<div class="help-para">
You can peek at the module properties:<pre><code class="language-vim">:lua vim.print(vim)</code></pre>
Result is something like this:<pre>{
  _os_proc_children = &lt;function 1&gt;,
  _os_proc_info = &lt;function 2&gt;,
  ...
  api = {
    nvim__id = &lt;function 5&gt;,
    nvim__id_array = &lt;function 6&gt;,
    ...
  },
  deepcopy = &lt;function 106&gt;,
  gsplit = &lt;function 107&gt;,
  ...
}</pre>
To find documentation on e.g. the "deepcopy" function:<pre><code class="language-vim">:help vim.deepcopy()</code></pre>
Note that underscore-prefixed functions (e.g. "_os_proc_children") are
internal/private and must not be used by plugins.

</div>
<div class="help-para">
<h3 id="lua-loop" class="help-heading">VIM.UV<span class="help-heading-tags">                                                   <span class="help-tag">lua-loop</span> <span id="vim.uv" class="help-tag">vim.uv</span></span></h3>


</div>
<div class="help-para">
<code>vim.uv</code> exposes the "luv" Lua bindings for the libUV library that Nvim uses
for networking, filesystem, and process management, see <a href="luvref.html#luvref.txt">luvref.txt</a>.
In particular, it allows interacting with the main Nvim <a href="luvref.html#luv-event-loop">luv-event-loop</a>.

</div>
<div class="help-para">
                                                    <code id="E5560" class="help-tag-right">E5560</code> <code id="lua-loop-callbacks" class="help-tag">lua-loop-callbacks</code>
It is an error to directly invoke <code>vim.api</code> functions (except <a href="api.html#api-fast">api-fast</a>) in
<code>vim.uv</code> callbacks. For example, this is an error:<pre><code class="language-lua">local timer = vim.uv.new_timer()
timer:start(1000, 0, function()
  vim.api.nvim_command('echomsg "test"')
end)</code></pre>

</div>
<div class="help-para">
To avoid the error use <a href="lua.html#vim.schedule_wrap()">vim.schedule_wrap()</a> to defer the callback:<pre><code class="language-lua">local timer = vim.uv.new_timer()
timer:start(1000, 0, vim.schedule_wrap(function()
  vim.api.nvim_command('echomsg "test"')
end))</code></pre>

</div>
<div class="help-para">
(For one-shot timers, see <a href="lua.html#vim.defer_fn()">vim.defer_fn()</a>, which automatically adds the
wrapping.)

</div>
<div class="help-para">
Example: repeating timer
    1. Save this code to a file.
    2. Execute it with ":luafile %".<pre><code class="language-lua">-- Create a timer handle (implementation detail: uv_timer_t).
local timer = vim.uv.new_timer()
local i = 0
-- Waits 1000ms, then repeats every 750ms until timer:close().
timer:start(1000, 750, function()
  print('timer invoked! i='..tostring(i))
  if i &gt; 4 then
    timer:close()  -- Always close handles to avoid leaks.
  end
  i = i + 1
end)
print('sleeping');</code></pre>

</div>
<div class="help-para">
Example: File-change detection                                    <code id="watch-file" class="help-tag-right">watch-file</code>
    1. Save this code to a file.
    2. Execute it with ":luafile %".
    3. Use ":Watch %" to watch any file.
    4. Try editing the file from another text editor.
    5. Observe that the file reloads in Nvim (because on_change() calls
       <a href="editing.html#%3Achecktime">:checktime</a>).<pre><code class="language-lua">local w = vim.uv.new_fs_event()
local function on_change(err, fname, status)
  -- Do work...
  vim.api.nvim_command('checktime')
  -- Debounce: stop/start.
  w:stop()
  watch_file(fname)
end
function watch_file(fname)
  local fullpath = vim.api.nvim_call_function(
    'fnamemodify', {fname, ':p'})
  w:start(fullpath, {}, vim.schedule_wrap(function(...)
    on_change(...) end))
end
vim.api.nvim_command(
  "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('&lt;args&gt;'))")</code></pre>

</div>
<div class="help-para">
Example: TCP echo-server                                          <code id="tcp-server" class="help-tag-right">tcp-server</code>
    1. Save this code to a file.
    2. Execute it with ":luafile %".
    3. Note the port number.
    4. Connect from any TCP client (e.g. "nc 0.0.0.0 36795"):<pre><code class="language-lua">local function create_server(host, port, on_connect)
  local server = vim.uv.new_tcp()
  server:bind(host, port)
  server:listen(128, function(err)
    assert(not err, err)  -- Check for errors.
    local sock = vim.uv.new_tcp()
    server:accept(sock)  -- Accept client connection.
    on_connect(sock)  -- Start reading messages.
  end)
  return server
end
local server = create_server('0.0.0.0', 0, function(sock)
  sock:read_start(function(err, chunk)
    assert(not err, err)  -- Check for errors.
    if chunk then
      sock:write(chunk)  -- Echo received messages to the channel.
    else  -- EOF (stream closed).
      sock:close()  -- Always close handles to avoid leaks.
    end
  end)
end)
print('TCP echo-server listening on port: '..server:getsockname().port)</code></pre>

</div>
<div class="help-para">
Multithreading                                            <code id="lua-loop-threading" class="help-tag-right">lua-loop-threading</code>

</div>
<div class="help-para">
Plugins can perform work in separate (os-level) threads using the threading
APIs in luv, for instance <code>vim.uv.new_thread</code>. Note that every thread
gets its own separate Lua interpreter state, with no access to Lua globals
in the main thread. Neither can the state of the editor (buffers, windows,
etc) be directly accessed from threads.

</div>
<div class="help-para">
A subset of the <code>vim.*</code> API is available in threads. This includes:

</div>
<div class="help-para">
<div class="help-li" style=""> <code>vim.uv</code> with a separate event loop per thread.
</div><div class="help-li" style=""> <code>vim.mpack</code> and <code>vim.json</code> (useful for serializing messages between threads)
</div><div class="help-li" style=""> <code>require</code> in threads can use Lua packages from the global <a href="luaref.html#package.path">package.path</a>
</div><div class="help-li" style=""> <code>print()</code> and <code>vim.inspect</code>
</div><div class="help-li" style=""> <code>vim.diff</code>
</div><div class="help-li" style=""> most utility functions in <code>vim.*</code> for working with pure Lua values
  like <code>vim.split</code>, <code>vim.tbl_*</code>, <code>vim.list_*</code>, and so on.
</div><div class="help-li" style=""> <code>vim.is_thread()</code> returns true from a non-main thread.
</div>
</div>
<div class="help-para">
<h3 id="lua-highlight" class="help-heading">VIM.HIGHLIGHT<span class="help-heading-tags">                                                  <span class="help-tag">lua-highlight</span></h3>


</div>
<div class="help-para">
Nvim includes a function for highlighting a selection on yank (see for example
<a href="https://github.com/machakann/vim-highlightedyank">https://github.com/machakann/vim-highlightedyank</a>). To enable it, add
<pre><code class="language-vim">au TextYankPost * silent! lua vim.highlight.on_yank()</code></pre>

</div>
<div class="help-para">
to your <code>init.vim</code>. You can customize the highlight group and the duration of
the highlight via
<pre><code class="language-vim">au TextYankPost * silent! lua vim.highlight.on_yank {higroup="IncSearch", timeout=150}</code></pre>

</div>
<div class="help-para">
If you want to exclude visual selections from highlighting on yank, use
<pre><code class="language-vim">au TextYankPost * silent! lua vim.highlight.on_yank {on_visual=false}</code></pre>

</div>
<div class="help-para">
vim.highlight.on_yank(<code>{opts}</code>)                        <code id="vim.highlight.on_yank()" class="help-tag-right">vim.highlight.on_yank()</code>
    Highlights the yanked text. The fields of the optional dict <code>{opts}</code>
    control the highlight:
<div class="help-li" style=""> <code>{higroup}</code> highlight group for yanked region (default <a href="syntax.html#hl-IncSearch">hl-IncSearch</a>)
</div><div class="help-li" style=""> <code>{timeout}</code> time in ms before highlight is cleared (default <code>150</code>)
</div><div class="help-li" style=""> <code>{on_macro}</code> highlight when executing macro (default <code>false</code>)
</div><div class="help-li" style=""> <code>{on_visual}</code> highlight when yanking visual selection (default <code>true</code>)
</div><div class="help-li" style=""> <code>{event}</code> event structure (default <a href="eval.html#v%3Aevent">v:event</a>)
</div><div class="help-li" style=""> <code>{priority}</code> priority of highlight (default <a href="lua.html#vim.highlight.priorities">vim.highlight.priorities</a><code>.user</code>)
</div>
</div>
<div class="help-para">
vim.highlight.range(<code>{bufnr}</code>, <code>{ns}</code>, <code>{hlgroup}</code>, <code>{start}</code>, <code>{finish}</code>, <code>{opts}</code>)
                                                       <code id="vim.highlight.range()" class="help-tag-right">vim.highlight.range()</code>

</div>
<div class="help-para">
    Apply highlight group to range of text.

</div>
<div class="help-para">
<div class="help-column_heading">            Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>   buffer number
</div><div class="help-li" style=""> <code>{ns}</code>      namespace for highlights
</div><div class="help-li" style=""> <code>{hlgroup}</code> highlight group name
</div><div class="help-li" style=""> <code>{start}</code>   starting position (tuple <code>{line,col}</code>)
</div><div class="help-li" style=""> <code>{finish}</code>  finish position (tuple <code>{line,col}</code>)
</div><div class="help-li" style=""> <code>{opts}</code>    optional parameters:
</div><div class="help-li" style="margin-left: 3rem;"> <code>regtype</code>: type of range (characterwise, linewise,
                            or blockwise, see <a href="builtin.html#setreg()">setreg()</a>), default <code>'v'</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>inclusive</code>: range includes end position,
                            default <code>false</code>
</div><div class="help-li" style="margin-left: 3rem;"> <code>priority</code>: priority of highlight, default
                            <code>vim.highlight.user</code> (see below)
</div>
</div>
<div class="help-para">
vim.highlight.priorities                            <code id="vim.highlight.priorities" class="help-tag-right">vim.highlight.priorities</code>

</div>
<div class="help-para">
    Table with default priorities used for highlighting:
<div class="help-li" style=""> <code>syntax</code>: <code>50</code>, used for standard syntax highlighting
</div><div class="help-li" style=""> <code>treesitter</code>: <code>100</code>, used for tree-sitter-based highlighting
</div><div class="help-li" style=""> <code>semantic_tokens</code>: <code>125</code>, used for LSP semantic token highlighting
</div><div class="help-li" style=""> <code>diagnostics</code>: <code>150</code>, used for code analysis such as diagnostics
</div><div class="help-li" style=""> <code>user</code>: <code>200</code>, used for user-triggered highlights such as LSP document
          symbols or <code>on_yank</code> autocommands
</div>
</div>
<div class="help-para">
<h3 id="lua-regex" class="help-heading">VIM.REGEX<span class="help-heading-tags">                                                          <span class="help-tag">lua-regex</span></h3>


</div>
<div class="help-para">
Vim regexes can be used directly from Lua. Currently they only allow
matching within a single line.

</div>
<div class="help-para">
vim.regex(<code>{re}</code>)                                                  <code id="vim.regex()" class="help-tag-right">vim.regex()</code>
    Parse the Vim regex <code>{re}</code> and return a regex object. Regexes are "magic"
    and case-sensitive by default, regardless of <a href="options.html#'magic'">'magic'</a> and <a href="options.html#'ignorecase'">'ignorecase'</a>.
    They can be controlled with flags, see <a href="pattern.html#%2Fmagic">/magic</a> and <a href="pattern.html#%2Fignorecase">/ignorecase</a>.

</div>
<div class="help-para">
Methods on the regex object:

</div>
<div class="help-para">
regex:match_str(<code>{str}</code>)                                     <code id="regex%3Amatch_str()" class="help-tag-right">regex:match_str()</code>
    Match the string against the regex. If the string should match the regex
    precisely, surround the regex with <code>^</code> and <code>$</code>. If the was a match, the
    byte indices for the beginning and end of the match is returned. When
    there is no match, <code>nil</code> is returned. As any integer is truth-y,
    <code>regex:match()</code> can be directly used as a condition in an if-statement.

</div>
<div class="help-para">
regex:match_line(<code>{bufnr}</code>, <code>{line_idx}</code> [, <code>{start}</code>, <code>{end}</code>])  <code id="regex%3Amatch_line()" class="help-tag">regex:match_line()</code>
    Match line <code>{line_idx}</code> (zero-based) in buffer <code>{bufnr}</code>. If <code>{start}</code> and <code>{end}</code>
    are supplied, match only this byte index range. Otherwise see
    <a href="lua.html#regex%3Amatch_str()">regex:match_str()</a>. If <code>{start}</code> is used, then the returned byte indices
    will be relative <code>{start}</code>.

</div>
<div class="help-para">
<h3 id="lua-lpeg" class="help-heading">VIM.LPEG<span class="help-heading-tags">                                                            <span class="help-tag">lua-lpeg</span></h3>


</div>
<div class="help-para">
                                                             <code id="vim.lpeg" class="help-tag-right">vim.lpeg</code> <code id="vim.re" class="help-tag">vim.re</code>
The Lpeg library for parsing expression grammars is being included as
<code>vim.lpeg</code> (<a href="https://www.inf.puc-rio.br/~roberto/lpeg/">https://www.inf.puc-rio.br/~roberto/lpeg/</a>). In addition, its regex-like
interface is available as <code>vim.re</code> (<a href="https://www.inf.puc-rio.br/~roberto/lpeg/re.html">https://www.inf.puc-rio.br/~roberto/lpeg/re.html</a>).

</div>
<div class="help-para">
<h3 id="lua-diff" class="help-heading">VIM.DIFF<span class="help-heading-tags">                                                            <span class="help-tag">lua-diff</span></h3>


</div>
<div class="help-para">
vim.diff(<code>{a}</code>, <code>{b}</code>, <code>{opts}</code>)                                        <code id="vim.diff()" class="help-tag-right">vim.diff()</code>
    Run diff on strings <code>{a}</code> and <code>{b}</code>. Any indices returned by this function,
    either directly or via callback arguments, are 1-based.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.diff('a\n', 'b\nc\n')
-- =&gt;
-- @@ -1 +1,2 @@
-- -a
-- +b
-- +c
vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})
-- =&gt;
-- {
--   {1, 1, 1, 2}
-- }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{a}</code>      First string to compare
</div><div class="help-li" style=""> <code>{b}</code>      Second string to compare
</div><div class="help-li" style=""> <code>{opts}</code>   Optional parameters:
</div><div class="help-li" style="margin-left: 3rem;"> <code>on_hunk</code> (callback):
                   Invoked for each hunk in the diff. Return a negative number
                   to cancel the callback for any remaining hunks.
                   Args:
</div><div class="help-li" style="margin-left: 4rem;"> <code>start_a</code> (integer): Start line of hunk in <code>{a}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>count_a</code> (integer): Hunk size in <code>{a}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>start_b</code> (integer): Start line of hunk in <code>{b}</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>count_b</code> (integer): Hunk size in <code>{b}</code>.
</div><div class="help-li" style="margin-left: 3rem;"> <code>result_type</code> (string): Form of the returned diff:
</div><div class="help-li" style="margin-left: 4rem;"> "unified": (default) String in unified format.
</div><div class="help-li" style="margin-left: 4rem;"> "indices": Array of hunk locations.
                   Note: This option is ignored if <code>on_hunk</code> is used.
</div><div class="help-li" style="margin-left: 3rem;"> <code>linematch</code> (boolean|integer): Run linematch on the resulting hunks
                   from xdiff. When integer, only hunks upto this size in
                   lines are run through linematch. Requires <code>result_type = indices</code>,
                   ignored otherwise.
</div><div class="help-li" style="margin-left: 3rem;"> <code>algorithm</code> (string):
                   Diff algorithm to use. Values:
</div><div class="help-li" style="margin-left: 4rem;"> "myers"      the default algorithm
</div><div class="help-li" style="margin-left: 4rem;"> "minimal"    spend extra time to generate the
                                  smallest possible diff
</div><div class="help-li" style="margin-left: 4rem;"> "patience"   patience diff algorithm
</div><div class="help-li" style="margin-left: 4rem;"> "histogram"  histogram diff algorithm
</div><div class="help-li" style="margin-left: 3rem;"> <code>ctxlen</code> (integer): Context length
</div><div class="help-li" style="margin-left: 3rem;"> <code>interhunkctxlen</code> (integer):
                   Inter hunk context length
</div><div class="help-li" style="margin-left: 3rem;"> <code>ignore_whitespace</code> (boolean):
                   Ignore whitespace
</div><div class="help-li" style="margin-left: 3rem;"> <code>ignore_whitespace_change</code> (boolean):
                   Ignore whitespace change
</div><div class="help-li" style="margin-left: 3rem;"> <code>ignore_whitespace_change_at_eol</code> (boolean)
                   Ignore whitespace change at end-of-line.
</div><div class="help-li" style="margin-left: 3rem;"> <code>ignore_cr_at_eol</code> (boolean)
                   Ignore carriage return at end-of-line
</div><div class="help-li" style="margin-left: 3rem;"> <code>ignore_blank_lines</code> (boolean)
                   Ignore blank lines
</div><div class="help-li" style="margin-left: 3rem;"> <code>indent_heuristic</code> (boolean):
                   Use the indent heuristic for the internal
                   diff library.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        See <code>{opts.result_type}</code>. nil if <code>{opts.on_hunk}</code> is given.

</div>
<div class="help-para">
<h3 id="lua-mpack" class="help-heading">VIM.MPACK<span class="help-heading-tags">                                                          <span class="help-tag">lua-mpack</span></h3>


</div>
<div class="help-para">
The <code id="vim.mpack" class="help-tag">vim.mpack</code> module provides encoding and decoding of Lua objects to and
from msgpack-encoded strings. Supports <a href="lua.html#vim.NIL">vim.NIL</a> and <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.

</div>
<div class="help-para">
vim.mpack.encode(<code>{obj}</code>)                                     <code id="vim.mpack.encode" class="help-tag-right">vim.mpack.encode</code>
    Encodes (or "packs") Lua object <code>{obj}</code> as msgpack in a Lua string.

</div>
<div class="help-para">
vim.mpack.decode(<code>{str}</code>)                                     <code id="vim.mpack.decode" class="help-tag-right">vim.mpack.decode</code>
    Decodes (or "unpacks") the msgpack-encoded <code>{str}</code> to a Lua object.

</div>
<div class="help-para">
<h3 id="lua-json" class="help-heading">VIM.JSON<span class="help-heading-tags">                                                            <span class="help-tag">lua-json</span></h3>


</div>
<div class="help-para">
The <code id="vim.json" class="help-tag">vim.json</code> module provides encoding and decoding of Lua objects to and
from JSON-encoded strings. Supports <a href="lua.html#vim.NIL">vim.NIL</a> and <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.

</div>
<div class="help-para">
vim.json.encode(<code>{obj}</code>)                                       <code id="vim.json.encode" class="help-tag-right">vim.json.encode</code>
    Encodes (or "packs") Lua object <code>{obj}</code> as JSON in a Lua string.

</div>
<div class="help-para">
vim.json.decode(<code>{str}</code>[, <code>{opts}</code>])                             <code id="vim.json.decode" class="help-tag-right">vim.json.decode</code>
    Decodes (or "unpacks") the JSON-encoded <code>{str}</code> to a Lua object.

</div>
<div class="help-para">
<div class="help-li" style=""> Decodes JSON "null" as <a href="lua.html#vim.NIL">vim.NIL</a> (controllable by <code>{opts}</code>, see below).
</div><div class="help-li" style=""> Decodes empty object as <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a>.
</div><div class="help-li" style=""> Decodes empty array as <code>{}</code> (empty Lua table).
</div>
</div>
<div class="help-para">
    Example:<pre><code class="language-lua">:lua vim.print(vim.json.decode('{"bar":[],"foo":{},"zub":null}'))
--&gt; { bar = {}, foo = vim.empty_dict(), zub = vim.NIL }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>    Stringified JSON data.
</div><div class="help-li" style=""> <code>{opts}</code>   Options map keys:
</div><div class="help-li" style="margin-left: 3rem;"> luanil: { object: bool, array: bool }
</div><div class="help-li" style="margin-left: 4rem;"> <code>luanil.object=true</code> converts <code>null</code> in JSON objects to
                     Lua <code>nil</code> instead of <code>vim.NIL</code>.
</div><div class="help-li" style="margin-left: 4rem;"> <code>luanil.array=true</code> converts <code>null</code> in JSON arrays to Lua
                     <code>nil</code> instead of <code>vim.NIL</code>.
</div>
</div>
<div class="help-para">
<h3 id="lua-spell" class="help-heading">VIM.SPELL<span class="help-heading-tags">                                                          <span class="help-tag">lua-spell</span></h3>


</div>
<div class="help-para">
vim.spell.check(<code>{str}</code>)                                     <code id="vim.spell.check()" class="help-tag-right">vim.spell.check()</code>
    Check <code>{str}</code> for spelling errors. Similar to the Vimscript function
    <a href="builtin.html#spellbadword()">spellbadword()</a>.

</div>
<div class="help-para">
    Note: The behaviour of this function is dependent on: <a href="options.html#'spelllang'">'spelllang'</a>,
    <a href="options.html#'spellfile'">'spellfile'</a>, <a href="options.html#'spellcapcheck'">'spellcapcheck'</a> and <a href="options.html#'spelloptions'">'spelloptions'</a> which can all be local to
    the buffer. Consider calling this with <a href="api.html#nvim_buf_call()">nvim_buf_call()</a>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.spell.check("the quik brown fox")
-- =&gt;
-- {
--     {'quik', 'bad', 5}
-- }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>    String to spell check.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
      List of tuples with three items:
<div class="help-li" style=""> The badly spelled word.
</div><div class="help-li" style=""> The type of the spelling error:
            "bad"   spelling mistake
            "rare"  rare word
            "local" word only valid in another region
            "caps"  word should start with Capital
</div><div class="help-li" style=""> The position in <code>{str}</code> where the word begins.
</div>
</div>
<div class="help-para">
<h3 id="lua-builtin" class="help-heading">VIM<span class="help-heading-tags">                                                              <span class="help-tag">lua-builtin</span></h3>


</div>
<div class="help-para">
vim.api.{func}(<code>{...}</code>)                                                <code id="vim.api" class="help-tag-right">vim.api</code>
    Invokes Nvim <a href="api.html#API">API</a> function <code>{func}</code> with arguments <code>{...}</code>.
    Example: call the "nvim_get_current_line()" API function:<pre><code class="language-lua">print(tostring(vim.api.nvim_get_current_line()))</code></pre>
vim.in_fast_event()                                      <code id="vim.in_fast_event()" class="help-tag-right">vim.in_fast_event()</code>
    Returns true if the code is executing as part of a "fast" event handler,
    where most of the API is disabled. These are low-level events (e.g.
    <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>) which can be invoked whenever Nvim polls for input.
    When this is <code>false</code> most API functions are callable (but may be subject
    to other restrictions such as <a href="eval.html#textlock">textlock</a>).

</div>
<div class="help-para">
vim.NIL                                                              <code id="vim.NIL" class="help-tag-right">vim.NIL</code>
    Special value representing NIL in <a href="api.html#RPC">RPC</a> and <a href="eval.html#v%3Anull">v:null</a> in Vimscript
    conversion, and similar cases. Lua <code>nil</code> cannot be used as part of a Lua
    table representing a Dictionary or Array, because it is treated as
    missing: <code>{"foo", nil}</code> is the same as <code>{"foo"}</code>.

</div>
<div class="help-para">
vim.empty_dict()                                            <code id="vim.empty_dict()" class="help-tag-right">vim.empty_dict()</code>
    Creates a special empty table (marked with a metatable), which Nvim to an
    empty dictionary when translating Lua values to Vimscript or API types.
    Nvim by default converts an empty table <code>{}</code> without this metatable to an
    list/array.

</div>
<div class="help-para">
    Note: If numeric keys are present in the table, Nvim ignores the metatable
    marker and converts the dict to a list/array anyway.

</div>
<div class="help-para">
vim.rpcnotify(<code>{channel}</code>, <code>{method}</code> [, <code>{args}</code>...])             <code id="vim.rpcnotify()" class="help-tag-right">vim.rpcnotify()</code>
    Sends <code>{event}</code> to <code>{channel}</code> via <a href="api.html#RPC">RPC</a> and returns immediately. If <code>{channel}</code>
    is 0, the event is broadcast to all channels.

</div>
<div class="help-para">
    This function also works in a fast callback <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>.

</div>
<div class="help-para">
vim.rpcrequest(<code>{channel}</code>, <code>{method}</code> [, <code>{args}</code>...])           <code id="vim.rpcrequest()" class="help-tag-right">vim.rpcrequest()</code>
    Sends a request to <code>{channel}</code> to invoke <code>{method}</code> via <a href="api.html#RPC">RPC</a> and blocks until
    a response is received.

</div>
<div class="help-para">
    Note: NIL values as part of the return value is represented as <a href="lua.html#vim.NIL">vim.NIL</a>
    special value

</div>
<div class="help-para">
vim.stricmp(<code>{a}</code>, <code>{b}</code>)                                          <code id="vim.stricmp()" class="help-tag-right">vim.stricmp()</code>
    Compares strings case-insensitively. Returns 0, 1 or -1 if strings are
    equal, <code>{a}</code> is greater than <code>{b}</code> or <code>{a}</code> is lesser than <code>{b}</code>, respectively.

</div>
<div class="help-para">
vim.str_utfindex(<code>{str}</code> [, <code>{index}</code>])                       <code id="vim.str_utfindex()" class="help-tag-right">vim.str_utfindex()</code>
    Convert byte index to UTF-32 and UTF-16 indices. If <code>{index}</code> is not
    supplied, the length of the string is used. All indices are zero-based.
    Returns two values: the UTF-32 and UTF-16 indices respectively.

</div>
<div class="help-para">
    Embedded NUL bytes are treated as terminating the string. Invalid UTF-8
    bytes, and embedded surrogates are counted as one code point each. An
    <code>{index}</code> in the middle of a UTF-8 sequence is rounded upwards to the end of
    that sequence.

</div>
<div class="help-para">
vim.str_byteindex(<code>{str}</code>, <code>{index}</code> [, <code>{use_utf16}</code>])        <code id="vim.str_byteindex()" class="help-tag">vim.str_byteindex()</code>
    Convert UTF-32 or UTF-16 <code>{index}</code> to byte index. If <code>{use_utf16}</code> is not
    supplied, it defaults to false (use UTF-32). Returns the byte index.

</div>
<div class="help-para">
    Invalid UTF-8 and NUL is treated like by <a href="lua.html#vim.str_byteindex()">vim.str_byteindex()</a>.
    An <code>{index}</code> in the middle of a UTF-16 sequence is rounded upwards to
    the end of that sequence.

</div>
<div class="help-para">
vim.iconv(<code>{str}</code>, <code>{from}</code>, <code>{to}</code>[, <code>{opts}</code>])                        <code id="vim.iconv()" class="help-tag-right">vim.iconv()</code>
        The result is a String, which is the text <code>{str}</code> converted from
        encoding <code>{from}</code> to encoding <code>{to}</code>. When the conversion fails <code>nil</code> is
        returned.  When some characters could not be converted they
        are replaced with "?".
        The encoding names are whatever the iconv() library function
        can accept, see ":Man 3 iconv".

</div>
<div class="help-para">
<div class="help-column_heading">        Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>   (string) Text to convert
</div><div class="help-li" style=""> <code>{from}</code>  (string) Encoding of <code>{str}</code>
</div><div class="help-li" style=""> <code>{to}</code>    (string) Target encoding
</div>
</div>
<div class="help-para">
<div class="help-column_heading">        Returns:</div>
            Converted string if conversion succeeds, <code>nil</code> otherwise.

</div>
<div class="help-para">
vim.schedule(<code>{callback}</code>)                                      <code id="vim.schedule()" class="help-tag-right">vim.schedule()</code>
    Schedules <code>{callback}</code> to be invoked soon by the main event-loop. Useful
    to avoid <a href="eval.html#textlock">textlock</a> or other temporary restrictions.

</div>
<div class="help-para">
vim.wait(<code>{time}</code> [, <code>{callback}</code>, <code>{interval}</code>, <code>{fast_only}</code>])          <code id="vim.wait()" class="help-tag-right">vim.wait()</code>
    Wait for <code>{time}</code> in milliseconds until <code>{callback}</code> returns <code>true</code>.

</div>
<div class="help-para">
    Executes <code>{callback}</code> immediately and at approximately <code>{interval}</code>
    milliseconds (default 200). Nvim still processes other events during
    this time.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{time}</code>      Number of milliseconds to wait
</div><div class="help-li" style=""> <code>{callback}</code>  Optional callback. Waits until <code>{callback}</code> returns true
</div><div class="help-li" style=""> <code>{interval}</code>  (Approximate) number of milliseconds to wait between polls
</div><div class="help-li" style=""> <code>{fast_only}</code> If true, only <a href="api.html#api-fast">api-fast</a> events will be processed.
                        If called from while in an <a href="api.html#api-fast">api-fast</a> event, will
                        automatically be set to <code>true</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Returns:</div>
        If <code>{callback}</code> returns <code>true</code> during the <code>{time}</code>:
            <code>true, nil</code>

</div>
<div class="help-para">
        If <code>{callback}</code> never returns <code>true</code> during the <code>{time}</code>:
            <code>false, -1</code>

</div>
<div class="help-para">
        If <code>{callback}</code> is interrupted during the <code>{time}</code>:
            <code>false, -2</code>

</div>
<div class="help-para">
        If <code>{callback}</code> errors, the error is raised.

</div>
<div class="help-para">
        Examples:<pre><code class="language-lua">---
-- Wait for 100 ms, allowing other events to process
vim.wait(100, function() end)
---
-- Wait for 100 ms or until global variable set.
vim.wait(100, function() return vim.g.waiting_for_var end)
---
-- Wait for 1 second or until global variable set, checking every ~500 ms
vim.wait(1000, function() return vim.g.waiting_for_var end, 500)
---
-- Schedule a function to set a value in 100ms
vim.defer_fn(function() vim.g.timer_result = true end, 100)
-- Would wait ten seconds if results blocked. Actually only waits  100 ms
if vim.wait(10000, function() return vim.g.timer_result end) then
  print('Only waiting a little bit of time!')
end</code></pre>

</div>
<div class="help-para">
vim.ui_attach(<code>{ns}</code>, <code>{options}</code>, <code>{callback}</code>)                <code id="vim.ui_attach()" class="help-tag-right">vim.ui_attach()</code>
    Attach to ui events, similar to <a href="api.html#nvim_ui_attach()">nvim_ui_attach()</a> but receive events
    as Lua callback. Can be used to implement screen elements like
    popupmenu or message handling in Lua.

</div>
<div class="help-para">
    <code>{options}</code> should be a dictionary-like table, where <code>ext_...</code> options should
    be set to true to receive events for the respective external element.

</div>
<div class="help-para">
    <code>{callback}</code> receives event name plus additional parameters. See <a href="ui.html#ui-popupmenu">ui-popupmenu</a>
    and the sections below for event format for respective events.

</div>
<div class="help-para">
    WARNING: This api is considered experimental.  Usability will vary for
    different screen elements. In particular <code>ext_messages</code> behavior is subject
    to further changes and usability improvements.  This is expected to be
    used to handle messages when setting <a href="options.html#'cmdheight'">'cmdheight'</a> to zero (which is
    likewise experimental).

</div>
<div class="help-para">
    Example (stub for a <a href="ui.html#ui-popupmenu">ui-popupmenu</a> implementation):<pre><code class="language-lua">ns = vim.api.nvim_create_namespace('my_fancy_pum')
vim.ui_attach(ns, {ext_popupmenu=true}, function(event, ...)
  if event == "popupmenu_show" then
    local items, selected, row, col, grid = ...
    print("display pum ", #items)
  elseif event == "popupmenu_select" then
    local selected = ...
    print("selected", selected)
  elseif event == "popupmenu_hide" then
    print("FIN")
  end
end)</code></pre>
vim.ui_detach(<code>{ns}</code>)                                           <code id="vim.ui_detach()" class="help-tag-right">vim.ui_detach()</code>
    Detach a callback previously attached with <a href="lua.html#vim.ui_attach()">vim.ui_attach()</a> for the
    given namespace <code>{ns}</code>.

</div>
<div class="help-para">
vim.type_idx                                                    <code id="vim.type_idx" class="help-tag-right">vim.type_idx</code>
    Type index for use in <a href="lua.html#lua-special-tbl">lua-special-tbl</a>. Specifying one of the values from
    <a href="lua.html#vim.types">vim.types</a> allows typing the empty table (it is unclear whether empty Lua
    table represents empty list or empty array) and forcing integral numbers
    to be <a href="eval.html#Float">Float</a>. See <a href="lua.html#lua-special-tbl">lua-special-tbl</a> for more details.

</div>
<div class="help-para">
vim.val_idx                                                      <code id="vim.val_idx" class="help-tag-right">vim.val_idx</code>
    Value index for tables representing <a href="eval.html#Float">Float</a>s. A table representing
    floating-point value 1.0 looks like this:<pre><code class="language-lua">{
  [vim.type_idx] = vim.types.float,
  [vim.val_idx] = 1.0,
}</code></pre>

</div>
<div class="help-para">
    See also <a href="lua.html#vim.type_idx">vim.type_idx</a> and <a href="lua.html#lua-special-tbl">lua-special-tbl</a>.

</div>
<div class="help-para">
vim.types                                                          <code id="vim.types" class="help-tag-right">vim.types</code>
    Table with possible values for <a href="lua.html#vim.type_idx">vim.type_idx</a>. Contains two sets of
    key-value pairs: first maps possible values for <a href="lua.html#vim.type_idx">vim.type_idx</a> to
    human-readable strings, second maps human-readable type names to values
    for <a href="lua.html#vim.type_idx">vim.type_idx</a>. Currently contains pairs for <code>float</code>, <code>array</code> and
        <code>dictionary</code> types.

</div>
<div class="help-para">
    Note: One must expect that values corresponding to <code>vim.types.float</code>,
    <code>vim.types.array</code> and <code>vim.types.dictionary</code> fall under only two following
    assumptions:
    1. Value may serve both as a key and as a value in a table. Given the
       properties of Lua tables this basically means “value is not <code>nil</code>”.
    2. For each value in <code>vim.types</code> table <code>vim.types[vim.types[value]]</code> is the
       same as <code>value</code>.
    No other restrictions are put on types, and it is not guaranteed that
    values corresponding to <code>vim.types.float</code>, <code>vim.types.array</code> and
    <code>vim.types.dictionary</code> will not change or that <code>vim.types</code> table will only
    contain values for these three types.

</div>
<div class="help-para">
                                                   <code id="log_levels" class="help-tag-right">log_levels</code> <code id="vim.log.levels" class="help-tag">vim.log.levels</code>
Log levels are one of the values defined in <code>vim.log.levels</code>:

</div>
<div class="help-para">
    vim.log.levels.DEBUG
    vim.log.levels.ERROR
    vim.log.levels.INFO
    vim.log.levels.TRACE
    vim.log.levels.WARN
    vim.log.levels.OFF

</div>
<div class="help-para">
<h3 id="lua-vimscript" class="help-heading">LUA-VIMSCRIPT BRIDGE<span class="help-heading-tags">                                           <span class="help-tag">lua-vimscript</span></h3>


</div>
<div class="help-para">
Nvim Lua provides an interface or "bridge" to Vimscript variables and
functions, and editor commands and options.

</div>
<div class="help-para">
Objects passed over this bridge are COPIED (marshalled): there are no
"references". <a href="lua-guide.html#lua-guide-variables">lua-guide-variables</a> For example, using <code>vim.fn.remove()</code> on
a Lua list copies the list object to Vimscript and does NOT modify the Lua
list:<pre><code class="language-lua">local list = { 1, 2, 3 }
vim.fn.remove(list, 0)
vim.print(list)  --&gt; "{ 1, 2, 3 }"</code></pre>
vim.call(<code>{func}</code>, <code>{...}</code>)                                           <code id="vim.call()" class="help-tag-right">vim.call()</code>
    Invokes <a href="eval.html#vim-function">vim-function</a> or <a href="eval.html#user-function">user-function</a> <code>{func}</code> with arguments <code>{...}</code>.
    See also <a href="lua.html#vim.fn">vim.fn</a>.
    Equivalent to:<pre><code class="language-lua">vim.fn[func]({...})</code></pre>
vim.cmd(<code>{command}</code>)
    See <a href="lua.html#vim.cmd()">vim.cmd()</a>.

</div>
<div class="help-para">
vim.fn.{func}(<code>{...}</code>)                                                  <code id="vim.fn" class="help-tag-right">vim.fn</code>
    Invokes <a href="eval.html#vim-function">vim-function</a> or <a href="eval.html#user-function">user-function</a> <code>{func}</code> with arguments <code>{...}</code>.
    To call autoload functions, use the syntax:<pre><code class="language-lua">vim.fn['some#function']({...})</code></pre>

</div>
<div class="help-para">
    Unlike vim.api.|nvim_call_function()| this converts directly between Vim
    objects and Lua objects. If the Vim function returns a float, it will be
    represented directly as a Lua number. Empty lists and dictionaries both
    are represented by an empty table.

</div>
<div class="help-para">
    Note: <a href="eval.html#v%3Anull">v:null</a> values as part of the return value is represented as
    <a href="lua.html#vim.NIL">vim.NIL</a> special value

</div>
<div class="help-para">
    Note: vim.fn keys are generated lazily, thus <code>pairs(vim.fn)</code> only
    enumerates functions that were called at least once.

</div>
<div class="help-para">
    Note: The majority of functions cannot run in <a href="api.html#api-fast">api-fast</a> callbacks with some
    undocumented exceptions which are allowed.

</div>
<div class="help-para">
                                                           <code id="lua-vim-variables" class="help-tag-right">lua-vim-variables</code>
The Vim editor global dictionaries <a href="eval.html#g%3A">g:</a> <a href="eval.html#w%3A">w:</a> <a href="eval.html#b%3A">b:</a> <a href="eval.html#t%3A">t:</a> <a href="eval.html#v%3A">v:</a> can be accessed
from Lua conveniently and idiomatically by referencing the <code>vim.*</code> Lua tables
described below. In this way you can easily read and modify global Vimscript
variables from Lua.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">vim.g.foo = 5     -- Set the g:foo Vimscript variable.
print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.
vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.
vim.b[2].foo = 6  -- Set b:foo for buffer 2</code></pre>

</div>
<div class="help-para">
Note that setting dictionary fields directly will not write them back into
Nvim. This is because the index into the namespace simply returns a copy.
Instead the whole dictionary must be written as one. This can be achieved by
creating a short-lived temporary.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">vim.g.my_dict.field1 = 'value'  -- Does not work
local my_dict = vim.g.my_dict   --
my_dict.field1 = 'value'        -- Instead do
vim.g.my_dict = my_dict         --</code></pre>
vim.g                                                                  <code id="vim.g" class="help-tag-right">vim.g</code>
    Global (<a href="eval.html#g%3A">g:</a>) editor variables.
    Key with no value returns <code>nil</code>.

</div>
<div class="help-para">
vim.b                                                                  <code id="vim.b" class="help-tag-right">vim.b</code>
    Buffer-scoped (<a href="eval.html#b%3A">b:</a>) variables for the current buffer.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific buffer.

</div>
<div class="help-para">
vim.w                                                                  <code id="vim.w" class="help-tag-right">vim.w</code>
    Window-scoped (<a href="eval.html#w%3A">w:</a>) variables for the current window.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific window.

</div>
<div class="help-para">
vim.t                                                                  <code id="vim.t" class="help-tag-right">vim.t</code>
    Tabpage-scoped (<a href="eval.html#t%3A">t:</a>) variables for the current tabpage.
    Invalid or unset key returns <code>nil</code>. Can be indexed with
    an integer to access variables for a specific tabpage.

</div>
<div class="help-para">
vim.v                                                                  <code id="vim.v" class="help-tag-right">vim.v</code>
    <a href="eval.html#v%3A">v:</a> variables.
    Invalid or unset key returns <code>nil</code>.

</div>
<div class="help-para">
vim.env                                                              <code id="vim.env" class="help-tag-right">vim.env</code>
    Environment variables defined in the editor session.
    See <a href="options.html#expand-env">expand-env</a> and <a href="eval.html#%3Alet-environment">:let-environment</a> for the Vimscript behavior.
    Invalid or unset key returns <code>nil</code>.
    Example:<pre><code class="language-lua">vim.env.FOO = 'bar'
print(vim.env.TERM)</code></pre>

</div>
<div class="help-para">
                                                                 <code id="lua-options" class="help-tag-right">lua-options</code>
                                                             <code id="lua-vim-options" class="help-tag-right">lua-vim-options</code>
                                                                 <code id="lua-vim-set" class="help-tag-right">lua-vim-set</code>
                                                            <code id="lua-vim-setlocal" class="help-tag-right">lua-vim-setlocal</code>

</div>
<div class="help-para">
Vim options can be accessed through <a href="lua.html#vim.o">vim.o</a>, which behaves like Vimscript
<a href="options.html#%3Aset">:set</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Examples:</div>

</div>
<div class="help-para">
    To set a boolean toggle:
        Vimscript: <code>set number</code>
        Lua:       <code>vim.o.number = true</code>

</div>
<div class="help-para">
    To set a string value:
        Vimscript: <code>set wildignore=*.o,*.a,__pycache__</code>
        Lua:       <code>vim.o.wildignore = '*.o,*.a,__pycache__'</code>

</div>
<div class="help-para">
Similarly, there is <a href="lua.html#vim.bo">vim.bo</a> and <a href="lua.html#vim.wo">vim.wo</a> for setting buffer-scoped and
window-scoped options. Note that this must NOT be confused with
<a href="options.html#local-options">local-options</a> and <a href="options.html#%3Asetlocal">:setlocal</a>. There is also <a href="lua.html#vim.go">vim.go</a> that only accesses the
global value of a <a href="options.html#global-local">global-local</a> option, see <a href="options.html#%3Asetglobal">:setglobal</a>.

</div>
<div class="help-para">
vim.o                                                                  <code id="vim.o" class="help-tag-right">vim.o</code>
    Get or set <a href="options.html#options">options</a>. Like <code>:set</code>. Invalid key is an error.

</div>
<div class="help-para">
    Note: this works on both buffer-scoped and window-scoped options using the
    current buffer and window.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.o.cmdheight = 4
print(vim.o.columns)
print(vim.o.foo)     -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.go                                                                <code id="vim.go" class="help-tag-right">vim.go</code>
    Get or set global <a href="options.html#options">options</a>. Like <code>:setglobal</code>. Invalid key is
    an error.

</div>
<div class="help-para">
    Note: this is different from <a href="lua.html#vim.o">vim.o</a> because this accesses the global
    option value and thus is mostly useful for use with <a href="options.html#global-local">global-local</a>
    options.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.go.cmdheight = 4
print(vim.go.columns)
print(vim.go.bar)     -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.bo[<code>{bufnr}</code>]                                                                <code id="vim.bo" class="help-tag-right">vim.bo</code>
    Get or set buffer-scoped <a href="options.html#options">options</a> for the buffer with number <code>{bufnr}</code>.
    Like <code>:set</code> and <code>:setlocal</code>. If [<code>{bufnr}</code>] is omitted then the current
    buffer is used. Invalid <code>{bufnr}</code> or key is an error.

</div>
<div class="help-para">
    Note: this is equivalent to both <code>:set</code> and <code>:setlocal</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local bufnr = vim.api.nvim_get_current_buf()
vim.bo[bufnr].buflisted = true    -- same as vim.bo.buflisted = true
print(vim.bo.comments)
print(vim.bo.baz)                 -- error: invalid key</code></pre>

</div>
<div class="help-para">
vim.wo[<code>{winid}</code>]                                                                <code id="vim.wo" class="help-tag-right">vim.wo</code>
    Get or set window-scoped <a href="options.html#options">options</a> for the window with handle <code>{winid}</code>.
    Like <code>:set</code>. If [<code>{winid}</code>] is omitted then the current window is used.
    Invalid <code>{winid}</code> or key is an error.

</div>
<div class="help-para">
    Note: this does not access <a href="options.html#local-options">local-options</a> (<code>:setlocal</code>) instead use:<pre><code class="language-lua">nvim_get_option_value(OPTION, { scope = 'local', win = winid })
nvim_set_option_value(OPTION, VALUE, { scope = 'local', win = winid }</code></pre>

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local winid = vim.api.nvim_get_current_win()
vim.wo[winid].number = true    -- same as vim.wo.number = true
print(vim.wo.foldmarker)
print(vim.wo.quux)             -- error: invalid key</code></pre>

</div>
<div class="help-para">
                                                                        <code id="vim.opt_local" class="help-tag-right">vim.opt_local</code>
                                                                       <code id="vim.opt_global" class="help-tag-right">vim.opt_global</code>
                                                                              <code id="vim.opt" class="help-tag-right">vim.opt</code>

</div>
<div class="help-para">
A special interface <a href="lua.html#vim.opt">vim.opt</a> exists for conveniently interacting with list-
and map-style option from Lua: It allows accessing them as Lua tables and
offers object-oriented method for adding and removing entries.

</div>
<div class="help-para">
<div class="help-column_heading">    Examples:</div>

</div>
<div class="help-para">
    The following methods of setting a list-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">set wildignore=*.o,*.a,__pycache__</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">vim.o.wildignore = '*.o,*.a,__pycache__'</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset%2B%3D">:set+=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:append { "*.pyc", "node_modules" }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset%5E%3D">:set^=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:prepend { "new_first_value" }</code></pre>

</div>
<div class="help-para">
    To replicate the behavior of <a href="options.html#%3Aset-%3D">:set-=</a>, use:<pre><code class="language-lua">vim.opt.wildignore:remove { "node_modules" }</code></pre>

</div>
<div class="help-para">
    The following methods of setting a map-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">set listchars=space:_,tab:&gt;~</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">vim.o.listchars = 'space:_,tab:&gt;~'</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.opt.listchars = { space = '_', tab = '&gt;~' }</code></pre>

</div>
<div class="help-para">
Note that <a href="lua.html#vim.opt">vim.opt</a> returns an <code>Option</code> object, not the value of the option,
which is accessed through <a href="lua.html#vim.opt%3Aget()">vim.opt:get()</a>:

</div>
<div class="help-para">
<div class="help-column_heading">    Examples:</div>

</div>
<div class="help-para">
    The following methods of getting a list-style option are equivalent:
        In Vimscript:<pre><code class="language-vim">echo wildignore</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.o</code>:<pre><code class="language-lua">print(vim.o.wildignore)</code></pre>

</div>
<div class="help-para">
        In Lua using <code>vim.opt</code>:<pre><code class="language-lua">vim.print(vim.opt.wildignore:get())</code></pre>

</div>
<div class="help-para">
In any of the above examples, to replicate the behavior <a href="options.html#%3Asetlocal">:setlocal</a>, use
<code>vim.opt_local</code>. Additionally, to replicate the behavior of <a href="options.html#%3Asetglobal">:setglobal</a>, use
<code>vim.opt_global</code>.

</div>
<div class="help-para">
                                                               <code id="vim.opt%3Aget()" class="help-tag-right">vim.opt:get()</code>
Option:get()

</div>
<div class="help-para">
    Returns a Lua-representation of the option. Boolean, number and string
    values will be returned in exactly the same fashion.

</div>
<div class="help-para">
    For values that are comma-separated lists, an array will be returned with
    the values as entries in the array:<pre><code class="language-lua">vim.cmd [[set wildignore=*.pyc,*.o]]
vim.print(vim.opt.wildignore:get())
-- { "*.pyc", "*.o", }
for _, ignore_pattern in ipairs(vim.opt.wildignore:get()) do
    print("Will ignore:", ignore_pattern)
end
-- Will ignore: *.pyc
-- Will ignore: *.o</code></pre>

</div>
<div class="help-para">
    For values that are comma-separated maps, a table will be returned with
    the names as keys and the values as entries:<pre><code class="language-lua">vim.cmd [[set listchars=space:_,tab:&gt;~]]
vim.print(vim.opt.listchars:get())
--  { space = "_", tab = "&gt;~", }
for char, representation in pairs(vim.opt.listchars:get()) do
    print(char, "=&gt;", representation)
end</code></pre>

</div>
<div class="help-para">
    For values that are lists of flags, a set will be returned with the flags
    as keys and <code>true</code> as entries.<pre><code class="language-lua">vim.cmd [[set formatoptions=njtcroql]]
vim.print(vim.opt.formatoptions:get())
-- { n = true, j = true, c = true, ... }
local format_opts = vim.opt.formatoptions:get()
if format_opts.j then
    print("J is enabled!")
end</code></pre>

</div>
<div class="help-para">
                                                            <code id="vim.opt%3Aappend()" class="help-tag-right">vim.opt:append()</code>
Option:append(value)

</div>
<div class="help-para">
    Append a value to string-style options. See <a href="options.html#%3Aset%2B%3D">:set+=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.formatoptions:append('j')
vim.opt.formatoptions = vim.opt.formatoptions + 'j'</code></pre>

</div>
<div class="help-para">
                                                           <code id="vim.opt%3Aprepend()" class="help-tag-right">vim.opt:prepend()</code>
Option:prepend(value)

</div>
<div class="help-para">
    Prepend a value to string-style options. See <a href="options.html#%3Aset%5E%3D">:set^=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.wildignore:prepend('*.o')
vim.opt.wildignore = vim.opt.wildignore ^ '*.o'</code></pre>

</div>
<div class="help-para">
                                                            <code id="vim.opt%3Aremove()" class="help-tag-right">vim.opt:remove()</code>
Option:remove(value)

</div>
<div class="help-para">
    Remove a value from string-style options. See <a href="options.html#%3Aset-%3D">:set-=</a>

</div>
<div class="help-para">
    These are equivalent:<pre><code class="language-lua">vim.opt.wildignore:remove('*.pyc')
vim.opt.wildignore = vim.opt.wildignore - '*.pyc'</code></pre>

</div>
<div class="help-para">
<h2 id="lua-vim" class="help-heading">Lua module: vim<span class="help-heading-tags">                                                      <span class="help-tag">lua-vim</span></h2>


</div>
<div class="help-para">
cmd(<code>{command}</code>)                                                     <code id="vim.cmd()" class="help-tag-right">vim.cmd()</code>
    Execute Vim script commands.

</div>
<div class="help-para">
    Note that <code>vim.cmd</code> can be indexed with a command name to return a
    callable function to the command.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.cmd('echo 42')
vim.cmd([[
  augroup My_group
    autocmd!
    autocmd FileType c setlocal cindent
  augroup END
]])
-- Ex command :echo "foo"
-- Note string literals need to be double quoted.
vim.cmd('echo "foo"')
vim.cmd { cmd = 'echo', args = { '"foo"' } }
vim.cmd.echo({ args = { '"foo"' } })
vim.cmd.echo('"foo"')
-- Ex command :write! myfile.txt
vim.cmd('write! myfile.txt')
vim.cmd { cmd = 'write', args = { "myfile.txt" }, bang = true }
vim.cmd.write { args = { "myfile.txt" }, bang = true }
vim.cmd.write { "myfile.txt", bang = true }
-- Ex command :colorscheme blue
vim.cmd('colorscheme blue')
vim.cmd.colorscheme('blue')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{command}</code>  string|table Command(s) to execute. If a string, executes
                   multiple lines of Vim script at once. In this case, it is
                   an alias to <a href="api.html#nvim_exec2()">nvim_exec2()</a>, where <code>opts.output</code> is set to
                   false. Thus it works identical to <a href="repeat.html#%3Asource">:source</a>. If a table,
                   executes a single command. In this case, it is an alias to
                   <a href="api.html#nvim_cmd()">nvim_cmd()</a> where <code>opts</code> is empty.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="vimindex.html#ex-cmd-index">ex-cmd-index</a>
</div>
</div>
<div class="help-para">
                                             <code id="vim.connection_failure_errmsg()" class="help-tag-right">vim.connection_failure_errmsg()</code>
connection_failure_errmsg(<code>{consequence}</code>)
    TODO: Documentation

</div>
<div class="help-para">
defer_fn(<code>{fn}</code>, <code>{timeout}</code>)                                     <code id="vim.defer_fn()" class="help-tag-right">vim.defer_fn()</code>
    Defers calling <code>{fn}</code> until <code>{timeout}</code> ms passes.

</div>
<div class="help-para">
    Use to do a one-shot timer that calls <code>{fn}</code> Note: The <code>{fn}</code> is
    <a href="lua.html#vim.schedule_wrap()">vim.schedule_wrap()</a>ped automatically, so API functions are safe to call.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>       (function) Callback to call once <code>timeout</code> expires
</div><div class="help-li" style=""> <code>{timeout}</code>  (integer) Number of milliseconds to wait before calling
                   <code>fn</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) timer luv timer object

</div>
<div class="help-para">
                                                             <code id="vim.deprecate()" class="help-tag-right">vim.deprecate()</code>
deprecate(<code>{name}</code>, <code>{alternative}</code>, <code>{version}</code>, <code>{plugin}</code>, <code>{backtrace}</code>)
    Shows a deprecation message to the user.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{name}</code>         string Deprecated feature (function, API, etc.).
</div><div class="help-li" style=""> <code>{alternative}</code>  (string|nil) Suggested alternative feature.
</div><div class="help-li" style=""> <code>{version}</code>      string Version when the deprecated function will be removed.
</div><div class="help-li" style=""> <code>{plugin}</code>       string|nil Name of the plugin that owns the deprecated
                       feature. Defaults to "Nvim".
</div><div class="help-li" style=""> <code>{backtrace}</code>    boolean|nil Prints backtrace. Defaults to true.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string|nil) # Deprecated message, or nil if no message was shown.

</div>
<div class="help-para">
inspect(<code>{object}</code>, <code>{options}</code>)                                   <code id="vim.inspect()" class="help-tag-right">vim.inspect()</code>
    Gets a human-readable representation of the given object.

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.print()">vim.print()</a>
</div><div class="help-li" style=""> <a href="https://github.com/kikito/inspect.lua">https://github.com/kikito/inspect.lua</a>
</div><div class="help-li" style=""> <a href="https://github.com/mpeterv/vinspect">https://github.com/mpeterv/vinspect</a>
</div>
</div>
<div class="help-para">
keycode(<code>{str}</code>)                                                 <code id="vim.keycode()" class="help-tag-right">vim.keycode()</code>
    Translate keycodes.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local k = vim.keycode
vim.g.mapleader = k'&lt;bs&gt;'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{str}</code>  string String to be converted.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        string

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="api.html#nvim_replace_termcodes()">nvim_replace_termcodes()</a>
</div>
</div>
<div class="help-para">
lua_omnifunc(<code>{find_start}</code>, <code>{_}</code>)                           <code id="vim.lua_omnifunc()" class="help-tag-right">vim.lua_omnifunc()</code>
    Omnifunc for completing Lua values from the runtime Lua interpreter,
    similar to the builtin completion for the <code>:lua</code> command.

</div>
<div class="help-para">
    Activate using <code>set omnifunc=v:lua.vim.lua_omnifunc</code> in a Lua buffer.

</div>
<div class="help-para">
notify(<code>{msg}</code>, <code>{level}</code>, <code>{opts}</code>)                                  <code id="vim.notify()" class="help-tag-right">vim.notify()</code>
    Display a notification to the user.

</div>
<div class="help-para">
    This function can be overridden by plugins to display notifications using
    a custom provider (such as the system notification provider). By default,
    writes to <a href="message.html#%3Amessages">:messages</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{msg}</code>    (string) Content of the notification to show to the user.
</div><div class="help-li" style=""> <code>{level}</code>  (integer|nil) One of the values from <a href="lua.html#vim.log.levels">vim.log.levels</a>.
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Optional parameters. Unused by default.
</div>
</div>
<div class="help-para">
notify_once(<code>{msg}</code>, <code>{level}</code>, <code>{opts}</code>)                        <code id="vim.notify_once()" class="help-tag-right">vim.notify_once()</code>
    Display a notification only one time.

</div>
<div class="help-para">
    Like <a href="lua.html#vim.notify()">vim.notify()</a>, but subsequent calls with the same message will not
    display a notification.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{msg}</code>    (string) Content of the notification to show to the user.
</div><div class="help-li" style=""> <code>{level}</code>  (integer|nil) One of the values from <a href="lua.html#vim.log.levels">vim.log.levels</a>.
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Optional parameters. Unused by default.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) true if message was displayed, else false

</div>
<div class="help-para">
on_key(<code>{fn}</code>, <code>{ns_id}</code>)                                           <code id="vim.on_key()" class="help-tag-right">vim.on_key()</code>
    Adds Lua function <code>{fn}</code> with namespace id <code>{ns_id}</code> as a listener to every,
    yes every, input key.

</div>
<div class="help-para">
    The Nvim command-line option <a href="starting.html#-w">-w</a> is related but does not support
    callbacks and cannot be toggled dynamically.

</div>
<div class="help-para">
    Note:
        <code>{fn}</code> will not be cleared by <a href="api.html#nvim_buf_clear_namespace()">nvim_buf_clear_namespace()</a>

</div>
<div class="help-para">
    Note:
        <code>{fn}</code> will receive the keys after mappings have been evaluated

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{fn}</code>     (function) Callback function. It should take one string
                 argument. On each key press, Nvim passes the key char to
                 fn(). <a href="insert.html#i_CTRL-V">i_CTRL-V</a> If <code>{fn}</code> is nil, it removes the callback for
                 the associated <code>{ns_id}</code>
</div><div class="help-li" style=""> <code>{ns_id}</code>  integer? Namespace ID. If nil or 0, generates and returns a
                 new <a href="api.html#nvim_create_namespace()">nvim_create_namespace()</a> id.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (integer) Namespace id associated with <code>{fn}</code>. Or count of all callbacks
        if on_key() is called without arguments.

</div>
<div class="help-para">
    Note:
        <code>{fn}</code> will be removed if an error occurs while calling.

</div>
<div class="help-para">
paste(<code>{lines}</code>, <code>{phase}</code>)                                          <code id="vim.paste()" class="help-tag-right">vim.paste()</code>
    Paste handler, invoked by <a href="api.html#nvim_paste()">nvim_paste()</a> when a conforming UI (such as the
    <a href="term.html#TUI">TUI</a>) pastes text into the editor.

</div>
<div class="help-para">
    Example: To remove ANSI color codes when pasting:<pre><code class="language-lua">vim.paste = (function(overridden)
  return function(lines, phase)
    for i,line in ipairs(lines) do
      -- Scrub ANSI color codes from paste input.
      lines[i] = line:gsub('\27%[[0-9;mK]+', '')
    end
    overridden(lines, phase)
  end
end)(vim.paste)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{lines}</code>  string[] # <a href="builtin.html#readfile()">readfile()</a>-style list of lines to paste.
                 <a href="channel.html#channel-lines">channel-lines</a>
</div><div class="help-li" style=""> <code>{phase}</code>  paste_phase -1: "non-streaming" paste: the call contains all
                 lines. If paste is "streamed", <code>phase</code> indicates the stream state:
</div><div class="help-li" style="margin-left: 3rem;"> 1: starts the paste (exactly once)
</div><div class="help-li" style="margin-left: 3rem;"> 2: continues the paste (zero or more times)
</div><div class="help-li" style="margin-left: 3rem;"> 3: ends the paste (exactly once)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) # false if client should cancel the paste.

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="provider.html#paste">paste</a> @alias paste_phase -1 | 1 | 2 | 3
</div>
</div>
<div class="help-para">
print(<code>{...}</code>)                                                     <code id="vim.print()" class="help-tag-right">vim.print()</code>
    "Pretty prints" the given arguments and returns them unmodified.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local hl_normal = vim.print(vim.api.nvim_get_hl_by_name('Normal', true))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any # given arguments.

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.inspect()">vim.inspect()</a>
</div><div class="help-li" style=""> <a href="various.html#%3A%3D">:=</a>
</div>
</div>
<div class="help-para">
region(<code>{bufnr}</code>, <code>{pos1}</code>, <code>{pos2}</code>, <code>{regtype}</code>, <code>{inclusive}</code>)         <code id="vim.region()" class="help-tag-right">vim.region()</code>
    Get a table of lines with start, end columns for a region marked by two
    points. Input and output positions are (0,0)-indexed and indicate byte
    positions.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>      (integer) number of buffer
</div><div class="help-li" style=""> <code>{pos1}</code>       integer[]|string start of region as a (line, column)
                     tuple or string accepted by <a href="builtin.html#getpos()">getpos()</a>
</div><div class="help-li" style=""> <code>{pos2}</code>       integer[]|string end of region as a (line, column) tuple
                     or string accepted by <a href="builtin.html#getpos()">getpos()</a>
</div><div class="help-li" style=""> <code>{regtype}</code>    (string) type of selection, see <a href="builtin.html#setreg()">setreg()</a>
</div><div class="help-li" style=""> <code>{inclusive}</code>  (boolean) indicating whether column of pos2 is inclusive
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) region Table of the form <code>{linenr = {startcol,endcol}}</code>.
        <code>endcol</code> is exclusive, and whole lines are marked with
        <code>{startcol,endcol} = {0,-1}</code>.

</div>
<div class="help-para">
schedule_wrap(<code>{cb}</code>)                                      <code id="vim.schedule_wrap()" class="help-tag-right">vim.schedule_wrap()</code>
    Defers callback <code>cb</code> until the Nvim API is safe to call.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{cb}</code>  (function)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (function)

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#lua-loop-callbacks">lua-loop-callbacks</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.schedule()">vim.schedule()</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.in_fast_event()">vim.in_fast_event()</a>
</div>
</div>
<div class="help-para">
system(<code>{cmd}</code>, <code>{opts}</code>, <code>{on_exit}</code>)                                <code id="vim.system()" class="help-tag-right">vim.system()</code>
    Run a system command

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local on_exit = function(obj)
  print(obj.code)
  print(obj.signal)
  print(obj.stdout)
  print(obj.stderr)
end
-- Run asynchronously
vim.system({'echo', 'hello'}, { text = true }, on_exit)
-- Run synchronously
local obj = vim.system({'echo', 'hello'}, { text = true }):wait()
-- { code = 0, signal = 0, stdout = 'hello', stderr = '' }</code></pre>

</div>
<div class="help-para">
    See <a href="luvref.html#uv.spawn()">uv.spawn()</a> for more details.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{cmd}</code>      (string[]) Command to execute
</div><div class="help-li" style=""> <code>{opts}</code>     (SystemOpts|nil) Options:
</div><div class="help-li" style="margin-left: 3rem;"> cwd: (string) Set the current working directory for the
                     sub-process.
</div><div class="help-li" style="margin-left: 3rem;"> env: table&lt;string,string&gt; Set environment variables for
                     the new process. Inherits the current environment with
                     <code>NVIM</code> set to <a href="eval.html#v%3Aservername">v:servername</a>.
</div><div class="help-li" style="margin-left: 3rem;"> clear_env: (boolean) <code>env</code> defines the job environment
                     exactly, instead of merging current environment.
</div><div class="help-li" style="margin-left: 3rem;"> stdin: (string|string[]|boolean) If <code>true</code>, then a pipe
                     to stdin is opened and can be written to via the
                     <code>write()</code> method to SystemObj. If string or string[] then
                     will be written to stdin and closed. Defaults to <code>false</code>.
</div><div class="help-li" style="margin-left: 3rem;"> stdout: (boolean|function) Handle output from stdout.
                     When passed as a function must have the signature
                     <code>fun(err: string, data: string)</code>. Defaults to <code>true</code>
</div><div class="help-li" style="margin-left: 3rem;"> stderr: (boolean|function) Handle output from stdout.
                     When passed as a function must have the signature
                     <code>fun(err: string, data: string)</code>. Defaults to <code>true</code>.
</div><div class="help-li" style="margin-left: 3rem;"> text: (boolean) Handle stdout and stderr as text.
                     Replaces <code>\r\n</code> with <code>\n</code>.
</div><div class="help-li" style="margin-left: 3rem;"> timeout: (integer)
</div><div class="help-li" style="margin-left: 3rem;"> detach: (boolean) If true, spawn the child process in a
                     detached state - this will make it a process group
                     leader, and will effectively enable the child to keep
                     running after the parent exits. Note that the child
                     process will still keep the parent's event loop alive
                     unless the parent process calls <a href="luvref.html#uv.unref()">uv.unref()</a> on the
                     child's process handle.
</div><div class="help-li" style=""> <code>{on_exit}</code>  (function|nil) Called when subprocess exits. When provided,
                   the command runs asynchronously. Receives SystemCompleted
                   object, see return of SystemObj:wait().
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        SystemObj Object with the fields:
<div class="help-li" style=""> pid (integer) Process ID
</div><div class="help-li" style=""> wait (fun(timeout: integer|nil): SystemCompleted)
</div><div class="help-li" style="margin-left: 3rem;"> SystemCompleted is an object with the fields:
</div><div class="help-li" style="margin-left: 4rem;"> code: (integer)
</div><div class="help-li" style="margin-left: 4rem;"> signal: (integer)
</div><div class="help-li" style="margin-left: 4rem;"> stdout: (string), nil if stdout argument is passed
</div><div class="help-li" style="margin-left: 4rem;"> stderr: (string), nil if stderr argument is passed
</div>
</div>
<div class="help-para">
<div class="help-li" style=""> kill (fun(signal: integer))
</div><div class="help-li" style=""> write (fun(data: string|nil)) Requires <code>stdin=true</code>. Pass <code>nil</code> to
          close the stream.
</div><div class="help-li" style=""> is_closing (fun(): boolean)
</div>
</div>
<div class="help-para">
<h2 id="lua-inspector" class="help-heading">Lua module: inspector<span class="help-heading-tags">                                          <span class="help-tag">lua-inspector</span></h2>


</div>
<div class="help-para">
inspect_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>, <code>{filter}</code>)               <code id="vim.inspect_pos()" class="help-tag-right">vim.inspect_pos()</code>
    Get all the items at a given buffer position.

</div>
<div class="help-para">
    Can also be pretty-printed with <code>:Inspect!</code>.                   <code id="%3AInspect%21" class="help-tag-right">:Inspect!</code>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>   (integer|nil) defaults to the current buffer
</div><div class="help-li" style=""> <code>{row}</code>     (integer|nil) row to inspect, 0-based. Defaults to the row
                  of the current cursor
</div><div class="help-li" style=""> <code>{col}</code>     (integer|nil) col to inspect, 0-based. Defaults to the col
                  of the current cursor
</div><div class="help-li" style=""> <code>{filter}</code>  (table|nil) a table with key-value pairs to filter the items
</div><div class="help-li" style="margin-left: 3rem;"> syntax (boolean): include syntax based highlight groups
                    (defaults to true)
</div><div class="help-li" style="margin-left: 3rem;"> treesitter (boolean): include treesitter based highlight
                    groups (defaults to true)
</div><div class="help-li" style="margin-left: 3rem;"> extmarks (boolean|"all"): include extmarks. When <code>all</code>,
                    then extmarks without a <code>hl_group</code> will also be included
                    (defaults to true)
</div><div class="help-li" style="margin-left: 3rem;"> semantic_tokens (boolean): include semantic tokens
                    (defaults to true)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) a table with the following key-value pairs. Items are in
        "traversal order":
<div class="help-li" style=""> treesitter: a list of treesitter captures
</div><div class="help-li" style=""> syntax: a list of syntax groups
</div><div class="help-li" style=""> semantic_tokens: a list of semantic tokens
</div><div class="help-li" style=""> extmarks: a list of extmarks
</div><div class="help-li" style=""> buffer: the buffer used to get the items
</div><div class="help-li" style=""> row: the row used to get the items
</div><div class="help-li" style=""> col: the col used to get the items
</div>
</div>
<div class="help-para">
show_pos(<code>{bufnr}</code>, <code>{row}</code>, <code>{col}</code>, <code>{filter}</code>)                     <code id="vim.show_pos()" class="help-tag-right">vim.show_pos()</code>
    Show all the items at a given buffer position.

</div>
<div class="help-para">
    Can also be shown with <code>:Inspect</code>.                              <code id="%3AInspect" class="help-tag-right">:Inspect</code>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>   (integer|nil) defaults to the current buffer
</div><div class="help-li" style=""> <code>{row}</code>     (integer|nil) row to inspect, 0-based. Defaults to the row
                  of the current cursor
</div><div class="help-li" style=""> <code>{col}</code>     (integer|nil) col to inspect, 0-based. Defaults to the col
                  of the current cursor
</div><div class="help-li" style=""> <code>{filter}</code>  (table|nil) see <a href="lua.html#vim.inspect_pos()">vim.inspect_pos()</a>
</div>
</div>
<div class="help-para">
deep_equal(<code>{a}</code>, <code>{b}</code>)                                        <code id="vim.deep_equal()" class="help-tag-right">vim.deep_equal()</code>
    Deep compare values for equality

</div>
<div class="help-para">
    Tables are compared recursively unless they both provide the <code>eq</code> metamethod. All other types are compared using the equality <code>==</code> operator.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{a}</code>  any First value
</div><div class="help-li" style=""> <code>{b}</code>  any Second value
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if values are equals, else <code>false</code>

</div>
<div class="help-para">
deepcopy(<code>{orig}</code>)                                              <code id="vim.deepcopy()" class="help-tag-right">vim.deepcopy()</code>
    Returns a deep copy of the given object. Non-table objects are copied as
    in a typical Lua assignment, whereas table objects are copied recursively.
    Functions are naively copied, so functions in the copied table point to
    the same functions as those in the input table. Userdata and threads are
    not copied and will throw an error.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{orig}</code>  (table) Table to copy
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Table of copied keys and (nested) values.

</div>
<div class="help-para">
defaulttable(<code>{create}</code>)                                    <code id="vim.defaulttable()" class="help-tag-right">vim.defaulttable()</code>
    Creates a table whose members are automatically created when accessed, if
    they don't already exist.

</div>
<div class="help-para">
    They mimic defaultdict in python.

</div>
<div class="help-para">
    If <code>{create}</code> is <code>nil</code>, this will create a defaulttable whose constructor
    function is this function, effectively allowing to create nested tables on
    the fly:

</div>
<div class="help-para">
<pre><code class="language-lua">local a = vim.defaulttable()
a.b.c = 1</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{create}</code>  function?(key:any):any The function called to create a
                  missing value.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Empty table with metamethod

</div>
<div class="help-para">
endswith(<code>{s}</code>, <code>{suffix}</code>)                                       <code id="vim.endswith()" class="help-tag-right">vim.endswith()</code>
    Tests if <code>s</code> ends with <code>suffix</code>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>       (string) String
</div><div class="help-li" style=""> <code>{suffix}</code>  (string) Suffix to match
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>suffix</code> is a suffix of <code>s</code>

</div>
<div class="help-para">
gsplit(<code>{s}</code>, <code>{sep}</code>, <code>{opts}</code>)                                      <code id="vim.gsplit()" class="help-tag-right">vim.gsplit()</code>
    Splits a string at each instance of a separator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">for s in vim.gsplit(':aa::b:', ':', {plain=true}) do
  print(s)
end</code></pre>

</div>
<div class="help-para">
    If you want to also inspect the separator itself (instead of discarding
    it), use <a href="luaref.html#string.gmatch()">string.gmatch()</a>. Example:<pre><code class="language-lua">for word, num in ('foo111bar222'):gmatch('([^0-9]*)(d*)') do
  print(('word: s num: s'):format(word, num))
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>     string String to split
</div><div class="help-li" style=""> <code>{sep}</code>   string Separator or pattern
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Keyword arguments <a href="lua.html#kwargs">kwargs</a>:
</div><div class="help-li" style="margin-left: 3rem;"> plain: (boolean) Use <code>sep</code> literally (as in string.find).
</div><div class="help-li" style="margin-left: 3rem;"> trimempty: (boolean) Discard empty segments at start and end
                  of the sequence.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (function) Iterator over the split components

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="luaref.html#string.gmatch()">string.gmatch()</a>
</div><div class="help-li" style=""> <a href="lua.html#vim.split()">vim.split()</a>
</div><div class="help-li" style=""> <a href="luaref.html#luaref-patterns">luaref-patterns</a>
</div><div class="help-li" style=""> <a href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>
</div><div class="help-li" style=""> <a href="http://lua-users.org/wiki/StringLibraryTutorial">http://lua-users.org/wiki/StringLibraryTutorial</a>
</div>
</div>
<div class="help-para">
is_callable(<code>{f}</code>)                                           <code id="vim.is_callable()" class="help-tag-right">vim.is_callable()</code>
    Returns true if object <code>f</code> can be called as a function.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  any Any object
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>f</code> is callable, else <code>false</code>

</div>
<div class="help-para">
list_contains(<code>{t}</code>, <code>{value}</code>)                              <code id="vim.list_contains()" class="help-tag-right">vim.list_contains()</code>
    Checks if a list-like table (integer keys without gaps) contains <code>value</code>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>      (table) Table to check (must be list-like, not validated)
</div><div class="help-li" style=""> <code>{value}</code>  any Value to compare
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>t</code> contains <code>value</code>

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_contains()">vim.tbl_contains()</a> for checking values in general tables
</div>
</div>
<div class="help-para">
list_extend(<code>{dst}</code>, <code>{src}</code>, <code>{start}</code>, <code>{finish}</code>)               <code id="vim.list_extend()" class="help-tag-right">vim.list_extend()</code>
    Extends a list-like table with the values of another list-like table.

</div>
<div class="help-para">
    NOTE: This mutates dst!

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{dst}</code>     (table) List which will be modified and appended to
</div><div class="help-li" style=""> <code>{src}</code>     (table) List from which values will be inserted
</div><div class="help-li" style=""> <code>{start}</code>   (integer|nil) Start index on src. Defaults to 1
</div><div class="help-li" style=""> <code>{finish}</code>  (integer|nil) Final index on src. Defaults to <code>#src</code>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) dst

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_extend()">vim.tbl_extend()</a>
</div>
</div>
<div class="help-para">
list_slice(<code>{list}</code>, <code>{start}</code>, <code>{finish}</code>)                       <code id="vim.list_slice()" class="help-tag-right">vim.list_slice()</code>
    Creates a copy of a table containing only elements from start to end
    (inclusive)

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{list}</code>    (list) Table
</div><div class="help-li" style=""> <code>{start}</code>   (integer|nil) Start range of slice
</div><div class="help-li" style=""> <code>{finish}</code>  (integer|nil) End range of slice
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (list) Copy of table sliced from start to finish (inclusive)

</div>
<div class="help-para">
pesc(<code>{s}</code>)                                                         <code id="vim.pesc()" class="help-tag-right">vim.pesc()</code>
    Escapes magic chars in <a href="lua.html#lua-patterns">lua-patterns</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>  (string) String to escape
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) %-escaped pattern string

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="https://github.com/rxi/lume">https://github.com/rxi/lume</a>
</div>
</div>
<div class="help-para">
ringbuf(<code>{size}</code>)                                                <code id="vim.ringbuf()" class="help-tag-right">vim.ringbuf()</code>
    Create a ring buffer limited to a maximal number of items. Once the buffer
    is full, adding a new entry overrides the oldest entry.
<pre>local ringbuf = vim.ringbuf(4)
ringbuf:push("a")
ringbuf:push("b")
ringbuf:push("c")
ringbuf:push("d")
ringbuf:push("e")    -- overrides "a"
print(ringbuf:pop()) -- returns "b"
print(ringbuf:pop()) -- returns "c"
-- Can be used as iterator. Pops remaining items:
for val in ringbuf do
  print(val)
end</pre>

</div>
<div class="help-para">
    Returns a Ringbuf instance with the following methods:

</div>
<div class="help-para">
<div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apush()">Ringbuf:push()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apop()">Ringbuf:pop()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Apeek()">Ringbuf:peek()</a>
</div><div class="help-li" style=""> <a href="lua.html#Ringbuf%3Aclear()">Ringbuf:clear()</a>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{size}</code>  (integer)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table)

</div>
<div class="help-para">
Ringbuf:clear(<code>{self}</code>)                                        <code id="Ringbuf%3Aclear()" class="help-tag-right">Ringbuf:clear()</code>
    Clear all items.

</div>
<div class="help-para">
Ringbuf:peek(<code>{self}</code>)                                          <code id="Ringbuf%3Apeek()" class="help-tag-right">Ringbuf:peek()</code>
    Returns the first unread item without removing it

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any?|ni

</div>
<div class="help-para">
Ringbuf:pop(<code>{self}</code>)                                            <code id="Ringbuf%3Apop()" class="help-tag-right">Ringbuf:pop()</code>
    Removes and returns the first unread item

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any?|ni

</div>
<div class="help-para">
Ringbuf:push(<code>{self}</code>, <code>{item}</code>)                                  <code id="Ringbuf%3Apush()" class="help-tag-right">Ringbuf:push()</code>
    Adds an item, overriding the oldest item if the buffer is full.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{item}</code>  any
</div>
</div>
<div class="help-para">
spairs(<code>{t}</code>)                                                     <code id="vim.spairs()" class="help-tag-right">vim.spairs()</code>
    Enumerate a table sorted by its keys.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) List-like table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        iterator over sorted keys and their values

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> Based on <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
split(<code>{s}</code>, <code>{sep}</code>, <code>{opts}</code>)                                        <code id="vim.split()" class="help-tag-right">vim.split()</code>
    Splits a string at each instance of a separator.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">split(":aa::b:", ":")                   --&gt; {'','aa','','b',''}
split("axaby", "ab?")                   --&gt; {'','x','y'}
split("x*yz*o", "*", {plain=true})      --&gt; {'x','yz','o'}
split("|x|y|z|", "|", {trimempty=true}) --&gt; {'x', 'y', 'z'}</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>     (string) String to split
</div><div class="help-li" style=""> <code>{sep}</code>   (string) Separator or pattern
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Keyword arguments <a href="lua.html#kwargs">kwargs</a> accepted by
                <a href="lua.html#vim.gsplit()">vim.gsplit()</a>
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        string[] List of split components

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.gsplit()">vim.gsplit()</a>
</div><div class="help-li" style=""> <a href="luaref.html#string.gmatch()">string.gmatch()</a>
</div>
</div>
<div class="help-para">
startswith(<code>{s}</code>, <code>{prefix}</code>)                                   <code id="vim.startswith()" class="help-tag-right">vim.startswith()</code>
    Tests if <code>s</code> starts with <code>prefix</code>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>       (string) String
</div><div class="help-li" style=""> <code>{prefix}</code>  (string) Prefix to match
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>prefix</code> is a prefix of <code>s</code>

</div>
<div class="help-para">
tbl_add_reverse_lookup(<code>{o}</code>)                     <code id="vim.tbl_add_reverse_lookup()" class="help-tag-right">vim.tbl_add_reverse_lookup()</code>
    Add the reverse lookup values to an existing table. For example:
    <code>tbl_add_reverse_lookup { A = 1 } == { [1] = 'A', A = 1 }</code>

</div>
<div class="help-para">
    Note that this modifies the input.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{o}</code>  (table) Table to add the reverse to
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) o

</div>
<div class="help-para">
tbl_contains(<code>{t}</code>, <code>{value}</code>, <code>{opts}</code>)                        <code id="vim.tbl_contains()" class="help-tag-right">vim.tbl_contains()</code>
    Checks if a table contains a given value, specified either directly or via
    a predicate that is checked for each value.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.tbl_contains({ 'a', { 'b', 'c' } }, function(v)
  return vim.deep_equal(v, { 'b', 'c' })
end, { predicate = true })
-- true</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>      (table) Table to check
</div><div class="help-li" style=""> <code>{value}</code>  any Value to compare or predicate function reference
</div><div class="help-li" style=""> <code>{opts}</code>   (table|nil) Keyword arguments <a href="lua.html#kwargs">kwargs</a>:
</div><div class="help-li" style="margin-left: 3rem;"> predicate: (boolean) <code>value</code> is a function reference to be
                   checked (default false)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>t</code> contains <code>value</code>

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.list_contains()">vim.list_contains()</a> for checking values in list-like tables
</div>
</div>
<div class="help-para">
tbl_count(<code>{t}</code>)                                               <code id="vim.tbl_count()" class="help-tag-right">vim.tbl_count()</code>
    Counts the number of non-nil values in table <code>t</code>.

</div>
<div class="help-para">
<pre><code class="language-lua">vim.tbl_count({ a=1, b=2 })  --&gt; 2
vim.tbl_count({ 1, 2 })      --&gt; 2</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (integer) Number of non-nil values in table

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua">https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua</a>
</div>
</div>
<div class="help-para">
tbl_deep_extend(<code>{behavior}</code>, <code>{...}</code>)                     <code id="vim.tbl_deep_extend()" class="help-tag-right">vim.tbl_deep_extend()</code>
    Merges recursively two or more tables.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{behavior}</code>  (string) Decides what to do if a key is found in more than
                    one map:
</div><div class="help-li" style="margin-left: 3rem;"> "error": raise an error
</div><div class="help-li" style="margin-left: 3rem;"> "keep": use value from the leftmost map
</div><div class="help-li" style="margin-left: 3rem;"> "force": use value from the rightmost map
</div><div class="help-li" style=""> <code>{...}</code>       (table) Two or more tables
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Merged table

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.tbl_extend()">vim.tbl_extend()</a>
</div>
</div>
<div class="help-para">
tbl_extend(<code>{behavior}</code>, <code>{...}</code>)                               <code id="vim.tbl_extend()" class="help-tag-right">vim.tbl_extend()</code>
    Merges two or more tables.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{behavior}</code>  (string) Decides what to do if a key is found in more than
                    one map:
</div><div class="help-li" style="margin-left: 3rem;"> "error": raise an error
</div><div class="help-li" style="margin-left: 3rem;"> "keep": use value from the leftmost map
</div><div class="help-li" style="margin-left: 3rem;"> "force": use value from the rightmost map
</div><div class="help-li" style=""> <code>{...}</code>       (table) Two or more tables
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Merged table

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="builtin.html#extend()">extend()</a>
</div>
</div>
<div class="help-para">
tbl_filter(<code>{func}</code>, <code>{t}</code>)                                     <code id="vim.tbl_filter()" class="help-tag-right">vim.tbl_filter()</code>
    Filter a table using a predicate function

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{func}</code>  (function) Function
</div><div class="help-li" style=""> <code>{t}</code>     (table) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Table of filtered values

</div>
<div class="help-para">
tbl_flatten(<code>{t}</code>)                                           <code id="vim.tbl_flatten()" class="help-tag-right">vim.tbl_flatten()</code>
    Creates a copy of a list-like table such that any nested tables are
    "unrolled" and appended to the result.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) List-like table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Flattened copy of the given list-like table

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> From <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
tbl_get(<code>{o}</code>, <code>{...}</code>)                                            <code id="vim.tbl_get()" class="help-tag-right">vim.tbl_get()</code>
    Index into a table (first argument) via string keys passed as subsequent
    arguments. Return <code>nil</code> if the key does not exist.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true
vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{o}</code>    (table) Table to index
</div><div class="help-li" style=""> <code>{...}</code>  any Optional keys (0 or more, variadic) via which to index the
               table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any Nested value indexed by key (if it exists), else nil

</div>
<div class="help-para">
tbl_isarray(<code>{t}</code>)                                           <code id="vim.tbl_isarray()" class="help-tag-right">vim.tbl_isarray()</code>
    Tests if a Lua table can be treated as an array (a table indexed by
    integers).

</div>
<div class="help-para">
    Empty table <code>{}</code> is assumed to be an array, unless it was created by
    <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a> or returned as a dict-like <a href="api.html#API">API</a> or Vimscript result,
    for example from <a href="builtin.html#rpcrequest()">rpcrequest()</a> or <a href="lua.html#vim.fn">vim.fn</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if array-like table, else <code>false</code>.

</div>
<div class="help-para">
tbl_isempty(<code>{t}</code>)                                           <code id="vim.tbl_isempty()" class="help-tag-right">vim.tbl_isempty()</code>
    Checks if a table is empty.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) Table to check
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if <code>t</code> is empty

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
tbl_islist(<code>{t}</code>)                                             <code id="vim.tbl_islist()" class="help-tag-right">vim.tbl_islist()</code>
    Tests if a Lua table can be treated as a list (a table indexed by
    consecutive integers starting from 1).

</div>
<div class="help-para">
    Empty table <code>{}</code> is assumed to be an list, unless it was created by
    <a href="lua.html#vim.empty_dict()">vim.empty_dict()</a> or returned as a dict-like <a href="api.html#API">API</a> or Vimscript result,
    for example from <a href="builtin.html#rpcrequest()">rpcrequest()</a> or <a href="lua.html#vim.fn">vim.fn</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean) <code>true</code> if list-like table, else <code>false</code>.

</div>
<div class="help-para">
tbl_keys(<code>{t}</code>)                                                 <code id="vim.tbl_keys()" class="help-tag-right">vim.tbl_keys()</code>
    Return a list of all keys used in a table. However, the order of the
    return table of keys is not guaranteed.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (list) List of keys

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> From <a href="https://github.com/premake/premake-core/blob/master/src/base/table.lua">https://github.com/premake/premake-core/blob/master/src/base/table.lua</a>
</div>
</div>
<div class="help-para">
tbl_map(<code>{func}</code>, <code>{t}</code>)                                           <code id="vim.tbl_map()" class="help-tag-right">vim.tbl_map()</code>
    Apply a function to all values of a table.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{func}</code>  (function) Function
</div><div class="help-li" style=""> <code>{t}</code>     (table) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Table of transformed values

</div>
<div class="help-para">
tbl_values(<code>{t}</code>)                                             <code id="vim.tbl_values()" class="help-tag-right">vim.tbl_values()</code>
    Return a list of all values used in a table. However, the order of the
    return table of values is not guaranteed.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{t}</code>  (table) Table
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (list) List of values

</div>
<div class="help-para">
trim(<code>{s}</code>)                                                         <code id="vim.trim()" class="help-tag-right">vim.trim()</code>
    Trim whitespace (Lua pattern "%s") from both sides of a string.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{s}</code>  (string) String to trim
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) String with whitespace removed from its beginning and end

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="luaref.html#luaref-patterns">luaref-patterns</a>
</div><div class="help-li" style=""> <a href="https://www.lua.org/pil/20.2.html">https://www.lua.org/pil/20.2.html</a>
</div>
</div>
<div class="help-para">
validate(<code>{opt}</code>)                                               <code id="vim.validate()" class="help-tag-right">vim.validate()</code>
    Validates a parameter specification (types and values).

</div>
<div class="help-para">
    Usage example:<pre><code class="language-lua">function user.new(name, age, hobbies)
  vim.validate{
    name={name, 'string'},
    age={age, 'number'},
    hobbies={hobbies, 'table'},
  }
  ...
end</code></pre>

</div>
<div class="help-para">
    Examples with explicit argument values (can be run directly):<pre><code class="language-lua">vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}
   --&gt; NOP (success)
vim.validate{arg1={1, 'table'}}
   --&gt; error('arg1: expected table, got number')
vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}
   --&gt; error('arg1: expected even number, got 3')</code></pre>

</div>
<div class="help-para">
    If multiple types are valid they can be given as a list.<pre><code class="language-lua">vim.validate{arg1={{'foo'}, {'table', 'string'}}, arg2={'foo', {'table', 'string'}}}
   --&gt; NOP (success)
vim.validate{arg1={1, {'string', 'table'}}}
   --&gt; error('arg1: expected string|table, got number')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{opt}</code>  (table) Names of parameters to validate. Each key is a
               parameter name; each value is a tuple in one of these forms:
               1. (arg_value, type_name, optional)
</div><div class="help-li" style="margin-left: 3rem;"> arg_value: argument value
</div><div class="help-li" style="margin-left: 3rem;"> type_name: string|table type name, one of: ("table", "t",
                    "string", "s", "number", "n", "boolean", "b", "function",
                    "f", "nil", "thread", "userdata") or list of them.
</div><div class="help-li" style="margin-left: 3rem;"> optional: (optional) boolean, if true, <code>nil</code> is valid
</div>
</div>
<div class="help-para">
               2. (arg_value, fn, msg)
<div class="help-li" style=""> arg_value: argument value
</div><div class="help-li" style=""> fn: any function accepting one argument, returns true if
                    and only if the argument is valid. Can optionally return
                    an additional informative error message as the second
                    returned value.
</div><div class="help-li" style=""> msg: (optional) error string if validation fails
</div>
</div>
<div class="help-para">
<h2 id="lua-loader" class="help-heading">Lua module: loader<span class="help-heading-tags">                                                <span class="help-tag">lua-loader</span></h2>


</div>
<div class="help-para">
disable()                                               <code id="vim.loader.disable()" class="help-tag-right">vim.loader.disable()</code>
    Disables the experimental Lua module loader:
<div class="help-li" style=""> removes the loaders
</div><div class="help-li" style=""> adds the default Nvim loader
</div>
</div>
<div class="help-para">
enable()                                                 <code id="vim.loader.enable()" class="help-tag-right">vim.loader.enable()</code>
    Enables the experimental Lua module loader:
<div class="help-li" style=""> overrides loadfile
</div><div class="help-li" style=""> adds the Lua loader using the byte-compilation cache
</div><div class="help-li" style=""> adds the libs loader
</div><div class="help-li" style=""> removes the default Nvim loader
</div>
</div>
<div class="help-para">
find(<code>{modname}</code>, <code>{opts}</code>)                                    <code id="vim.loader.find()" class="help-tag-right">vim.loader.find()</code>
    Finds Lua modules for the given module name.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{modname}</code>  (string) Module name, or <code>"*"</code> to find the top-level
                   modules instead
</div><div class="help-li" style=""> <code>{opts}</code>     (table|nil) Options for finding a module:
</div><div class="help-li" style="margin-left: 3rem;"> rtp: (boolean) Search for modname in the runtime path
                     (defaults to <code>true</code>)
</div><div class="help-li" style="margin-left: 3rem;"> paths: (string[]) Extra paths to search for modname
                     (defaults to <code>{}</code>)
</div><div class="help-li" style="margin-left: 3rem;"> patterns: (string[]) List of patterns to use when
                     searching for modules. A pattern is a string added to the
                     basename of the Lua module being searched. (defaults to
                     <code>{"/init.lua", ".lua"}</code>)
</div><div class="help-li" style="margin-left: 3rem;"> all: (boolean) Return all matches instead of just the
                     first one (defaults to <code>false</code>)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (list) A list of results with the following properties:
<div class="help-li" style=""> modpath: (string) the path to the module
</div><div class="help-li" style=""> modname: (string) the name of the module
</div><div class="help-li" style=""> stat: (table|nil) the fs_stat of the module path. Won't be returned
          for <code>modname="*"</code>
</div>
</div>
<div class="help-para">
reset(<code>{path}</code>)                                             <code id="vim.loader.reset()" class="help-tag-right">vim.loader.reset()</code>
    Resets the cache for the path, or all the paths if path is nil.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  string? path to reset
</div>
</div>
<div class="help-para">
<h2 id="lua-uri" class="help-heading">Lua module: uri<span class="help-heading-tags">                                                      <span class="help-tag">lua-uri</span></h2>


</div>
<div class="help-para">
uri_from_bufnr(<code>{bufnr}</code>)                                 <code id="vim.uri_from_bufnr()" class="help-tag-right">vim.uri_from_bufnr()</code>
    Get a URI from a bufnr

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{bufnr}</code>  (integer)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) URI

</div>
<div class="help-para">
uri_from_fname(<code>{path}</code>)                                  <code id="vim.uri_from_fname()" class="help-tag-right">vim.uri_from_fname()</code>
    Get a URI from a file path.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (string) Path to file
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) URI

</div>
<div class="help-para">
uri_to_bufnr(<code>{uri}</code>)                                       <code id="vim.uri_to_bufnr()" class="help-tag-right">vim.uri_to_bufnr()</code>
    Get the buffer for a uri. Creates a new unloaded buffer if no buffer for
    the uri already exists.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{uri}</code>  (string)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (integer) bufnr

</div>
<div class="help-para">
uri_to_fname(<code>{uri}</code>)                                       <code id="vim.uri_to_fname()" class="help-tag-right">vim.uri_to_fname()</code>
    Get a filename from a URI

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{uri}</code>  (string)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) filename or unchanged URI for non-file URIs

</div>
<div class="help-para">
<h2 id="lua-ui" class="help-heading">Lua module: ui<span class="help-heading-tags">                                                        <span class="help-tag">lua-ui</span></h2>


</div>
<div class="help-para">
input(<code>{opts}</code>, <code>{on_confirm}</code>)                                   <code id="vim.ui.input()" class="help-tag-right">vim.ui.input()</code>
    Prompts the user for input, allowing arbitrary (potentially asynchronous)
    work until <code>on_confirm</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)
    vim.o.shiftwidth = tonumber(input)
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>        (table) Additional options. See <a href="builtin.html#input()">input()</a>
</div><div class="help-li" style="margin-left: 3rem;"> prompt (string|nil) Text of the prompt
</div><div class="help-li" style="margin-left: 3rem;"> default (string|nil) Default reply to the input
</div><div class="help-li" style="margin-left: 3rem;"> completion (string|nil) Specifies type of completion
                        supported for input. Supported types are the same that
                        can be supplied to a user-defined command using the
                        "-complete=" argument. See <a href="map.html#%3Acommand-completion">:command-completion</a>
</div><div class="help-li" style="margin-left: 3rem;"> highlight (function) Function that will be used for
                        highlighting user inputs.
</div><div class="help-li" style=""> <code>{on_confirm}</code>  (function) ((input|nil) -&gt; ()) Called once the user
                      confirms or abort the input. <code>input</code> is what the user
                      typed (it might be an empty string if nothing was
                      entered), or <code>nil</code> if the user aborted the dialog.
</div>
</div>
<div class="help-para">
open(<code>{path}</code>)                                                   <code id="vim.ui.open()" class="help-tag-right">vim.ui.open()</code>
    Opens <code>path</code> with the system default handler (macOS <code>open</code>, Windows
    <code>explorer.exe</code>, Linux <code>xdg-open</code>, …), or returns (but does not show) an
    error message on failure.

</div>
<div class="help-para">
    Expands "~/" and environment variables in filesystem paths.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.ui.open("https://neovim.io/")
vim.ui.open("~/path/to/file")
vim.ui.open("$VIMRUNTIME")</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (string) Path or URL to open
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        SystemCompleted|nil # Command result, or nil if not found.
        (string|nil) # Error message on failure

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.system()">vim.system()</a>
</div>
</div>
<div class="help-para">
select(<code>{items}</code>, <code>{opts}</code>, <code>{on_choice}</code>)                         <code id="vim.ui.select()" class="help-tag-right">vim.ui.select()</code>
    Prompts the user to pick from a list of items, allowing arbitrary
    (potentially asynchronous) work until <code>on_choice</code>.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.ui.select({ 'tabs', 'spaces' }, {
    prompt = 'Select tabs or spaces:',
    format_item = function(item)
        return "I'd like to choose " .. item
    end,
}, function(choice)
    if choice == 'spaces' then
        vim.o.expandtab = true
    else
        vim.o.expandtab = false
    end
end)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{items}</code>      (table) Arbitrary items
</div><div class="help-li" style=""> <code>{opts}</code>       (table) Additional options
</div><div class="help-li" style="margin-left: 3rem;"> prompt (string|nil) Text of the prompt. Defaults to
                       <code>Select one of:</code>
</div><div class="help-li" style="margin-left: 3rem;"> format_item (function item -&gt; text) Function to format
                       an individual item from <code>items</code>. Defaults to
                       <code>tostring</code>.
</div><div class="help-li" style="margin-left: 3rem;"> kind (string|nil) Arbitrary hint string indicating the
                       item shape. Plugins reimplementing <code>vim.ui.select</code> may
                       wish to use this to infer the structure or semantics of
                       <code>items</code>, or the context in which select() was called.
</div><div class="help-li" style=""> <code>{on_choice}</code>  (function) ((item|nil, idx|nil) -&gt; ()) Called once the
                     user made a choice. <code>idx</code> is the 1-based index of <code>item</code>
                     within <code>items</code>. <code>nil</code> if the user aborted the dialog.
</div>
</div>
<div class="help-para">
<h2 id="lua-filetype" class="help-heading">Lua module: filetype<span class="help-heading-tags">                                            <span class="help-tag">lua-filetype</span></h2>


</div>
<div class="help-para">
add(<code>{filetypes}</code>)                                          <code id="vim.filetype.add()" class="help-tag-right">vim.filetype.add()</code>
    Add new filetype mappings.

</div>
<div class="help-para">
    Filetype mappings can be added either by extension or by filename (either
    the "tail" or the full file path). The full file path is checked first,
    followed by the file name. If a match is not found using the filename,
    then the filename is matched against the list of <a href="lua.html#lua-patterns">lua-patterns</a> (sorted by
    priority) until a match is found. Lastly, if pattern matching does not
    find a filetype, then the file extension is used.

</div>
<div class="help-para">
    The filetype can be either a string (in which case it is used as the
    filetype directly) or a function. If a function, it takes the full path
    and buffer number of the file as arguments (along with captures from the
    matched pattern, if any) and should return a string that will be used as
    the buffer's filetype. Optionally, the function can return a second
    function value which, when called, modifies the state of the buffer. This
    can be used to, for example, set filetype-specific buffer variables.

</div>
<div class="help-para">
    Filename patterns can specify an optional priority to resolve cases when a
    file path matches multiple patterns. Higher priorities are matched first.
    When omitted, the priority defaults to 0. A pattern can contain
    environment variables of the form "${SOME_VAR}" that will be automatically
    expanded. If the environment variable is not set, the pattern won't be
    matched.

</div>
<div class="help-para">
    See $VIMRUNTIME/lua/vim/filetype.lua for more examples.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.filetype.add({
  extension = {
    foo = 'fooscript',
    bar = function(path, bufnr)
      if some_condition() then
        return 'barscript', function(bufnr)
          -- Set a buffer variable
          vim.b[bufnr].barscript_version = 2
        end
      end
      return 'bar'
    end,
  },
  filename = {
    ['.foorc'] = 'toml',
    ['/etc/foo/config'] = 'toml',
  },
  pattern = {
    ['.*/etc/foo/.*'] = 'fooscript',
    -- Using an optional priority
    ['.*/etc/foo/.*%.conf'] = { 'dosini', { priority = 10 } },
    -- A pattern containing an environment variable
    ['${XDG_CONFIG_HOME}/foo/git'] = 'git',
    ['README.(a+)$'] = function(path, bufnr, ext)
      if ext == 'md' then
        return 'markdown'
      elseif ext == 'rst' then
        return 'rst'
      end
    end,
  },
})</code></pre>

</div>
<div class="help-para">
    To add a fallback match on contents, use<pre><code class="language-lua">vim.filetype.add {
  pattern = {
    ['.*'] = {
      priority = -math.huge,
      function(path, bufnr)
        local content = vim.filetype.getlines(bufnr, 1)
        if vim.filetype.matchregex(content, [[^#!.*\&lt;mine\&gt;]]) then
          return 'mine'
        elseif vim.filetype.matchregex(content, [[\&lt;drawing\&gt;]]) then
          return 'drawing'
        end
      end,
    },
  },
}</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{filetypes}</code>  (table) A table containing new filetype maps (see
                     example).
</div>
</div>
<div class="help-para">
get_option(<code>{filetype}</code>, <code>{option}</code>)                   <code id="vim.filetype.get_option()" class="help-tag-right">vim.filetype.get_option()</code>
    Get the default option value for a <code>{filetype}</code>.

</div>
<div class="help-para">
    The returned value is what would be set in a new buffer after <a href="options.html#'filetype'">'filetype'</a>
    is set, meaning it should respect all FileType autocmds and ftplugin
    files.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">vim.filetype.get_option('vim', 'commentstring')</code></pre>

</div>
<div class="help-para">
    Note: this uses <a href="api.html#nvim_get_option_value()">nvim_get_option_value()</a> but caches the result. This
    means <a href="usr_41.html#ftplugin">ftplugin</a> and <a href="autocmd.html#FileType">FileType</a> autocommands are only triggered once and
    may not reflect later changes.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{filetype}</code>  string Filetype
</div><div class="help-li" style=""> <code>{option}</code>    string Option name
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        string|boolean|integer: Option value

</div>
<div class="help-para">
match(<code>{args}</code>)                                           <code id="vim.filetype.match()" class="help-tag-right">vim.filetype.match()</code>
    Perform filetype detection.

</div>
<div class="help-para">
    The filetype can be detected using one of three methods:
    1. Using an existing buffer
    2. Using only a file name
    3. Using only file contents

</div>
<div class="help-para">
    Of these, option 1 provides the most accurate result as it uses both the
    buffer's filename and (optionally) the buffer contents. Options 2 and 3
    can be used without an existing buffer, but may not always provide a match
    in cases where the filename (or contents) cannot unambiguously determine
    the filetype.

</div>
<div class="help-para">
    Each of the three options is specified using a key to the single argument
    of this function. Example:

</div>
<div class="help-para">
<pre><code class="language-lua">-- Using a buffer number
vim.filetype.match({ buf = 42 })
-- Override the filename of the given buffer
vim.filetype.match({ buf = 42, filename = 'foo.c' })
-- Using a filename without a buffer
vim.filetype.match({ filename = 'main.lua' })
-- Using file contents
vim.filetype.match({ contents = {'#!/usr/bin/env bash'} })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{args}</code>  (table) Table specifying which matching strategy to use.
                Accepted keys are:
</div><div class="help-li" style="margin-left: 3rem;"> buf (number): Buffer number to use for matching. Mutually
                  exclusive with <code>{contents}</code>
</div><div class="help-li" style="margin-left: 3rem;"> filename (string): Filename to use for matching. When <code>{buf}</code>
                  is given, defaults to the filename of the given buffer
                  number. The file need not actually exist in the filesystem.
                  When used without <code>{buf}</code> only the name of the file is used
                  for filetype matching. This may result in failure to detect
                  the filetype in cases where the filename alone is not enough
                  to disambiguate the filetype.
</div><div class="help-li" style="margin-left: 3rem;"> contents (table): An array of lines representing file
                  contents to use for matching. Can be used with <code>{filename}</code>.
                  Mutually exclusive with <code>{buf}</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string|nil) If a match was found, the matched filetype.
        (function|nil) A function that modifies buffer state when called (for
        example, to set some filetype specific buffer variables). The function
        accepts a buffer number as its only argument.

</div>
<div class="help-para">
<h2 id="lua-keymap" class="help-heading">Lua module: keymap<span class="help-heading-tags">                                                <span class="help-tag">lua-keymap</span></h2>


</div>
<div class="help-para">
del(<code>{modes}</code>, <code>{lhs}</code>, <code>{opts}</code>)                                 <code id="vim.keymap.del()" class="help-tag-right">vim.keymap.del()</code>
    Remove an existing mapping. Examples:<pre><code class="language-lua">vim.keymap.del('n', 'lhs')
vim.keymap.del({'n', 'i', 'v'}, '&lt;leader&gt;w', { buffer = 5 })</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>  (table|nil) A table of optional arguments:
</div><div class="help-li" style="margin-left: 3rem;"> "buffer": (number|boolean) Remove a mapping from the given
                  buffer. When <code>0</code> or <code>true</code>, use the current buffer.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#vim.keymap.set()">vim.keymap.set()</a>
</div>
</div>
<div class="help-para">
set(<code>{mode}</code>, <code>{lhs}</code>, <code>{rhs}</code>, <code>{opts}</code>)                           <code id="vim.keymap.set()" class="help-tag-right">vim.keymap.set()</code>
    Adds a new <a href="map.html#mapping">mapping</a>. Examples:<pre><code class="language-lua">-- Map to a Lua function:
vim.keymap.set('n', 'lhs', function() print("real lua function") end)
-- Map to multiple modes:
vim.keymap.set({'n', 'v'}, '&lt;leader&gt;lr', vim.lsp.buf.references, { buffer = true })
-- Buffer-local mapping:
vim.keymap.set('n', '&lt;leader&gt;w', "&lt;cmd&gt;w&lt;cr&gt;", { silent = true, buffer = 5 })
-- Expr mapping:
vim.keymap.set('i', '&lt;Tab&gt;', function()
  return vim.fn.pumvisible() == 1 and "&lt;C-n&gt;" or "&lt;Tab&gt;"
end, { expr = true })
-- &lt;Plug&gt; mapping:
vim.keymap.set('n', '[%', '&lt;Plug&gt;(MatchitNormalMultiBackward)')</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{mode}</code>  string|table Mode short-name, see <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a>. Can
                also be list of modes to create mapping on multiple modes.
</div><div class="help-li" style=""> <code>{lhs}</code>   (string) Left-hand side <a href="map.html#%7Blhs%7D">{lhs}</a> of the mapping.
</div><div class="help-li" style=""> <code>{rhs}</code>   string|function Right-hand side <a href="map.html#%7Brhs%7D">{rhs}</a> of the mapping, can be
                a Lua function.
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Table of <a href="map.html#%3Amap-arguments">:map-arguments</a>.
</div><div class="help-li" style="margin-left: 3rem;"> Same as <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a> <code>{opts}</code>, except:
</div><div class="help-li" style="margin-left: 4rem;"> "replace_keycodes" defaults to <code>true</code> if "expr" is <code>true</code>.
</div><div class="help-li" style="margin-left: 4rem;"> "noremap": inverse of "remap" (see below).
</div>
</div>
<div class="help-para">
<div class="help-li" style=""> Also accepts:
</div><div class="help-li" style="margin-left: 3rem;"> "buffer": (number|boolean) Creates buffer-local mapping,
                    <code>0</code> or <code>true</code> for current buffer.
</div><div class="help-li" style="margin-left: 3rem;"> "remap": (boolean) Make the mapping recursive. Inverse of
                    "noremap". Defaults to <code>false</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="api.html#nvim_set_keymap()">nvim_set_keymap()</a>
</div>
</div>
<div class="help-para">
<h2 id="lua-fs" class="help-heading">Lua module: fs<span class="help-heading-tags">                                                        <span class="help-tag">lua-fs</span></h2>


</div>
<div class="help-para">
basename(<code>{file}</code>)                                           <code id="vim.fs.basename()" class="help-tag-right">vim.fs.basename()</code>
    Return the basename of the given file or directory

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{file}</code>  (string) File or directory
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) Basename of <code>{file}</code>

</div>
<div class="help-para">
dir(<code>{path}</code>, <code>{opts}</code>)                                             <code id="vim.fs.dir()" class="help-tag-right">vim.fs.dir()</code>
    Return an iterator over the files and directories located in <code>{path}</code>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (string) An absolute or relative path to the directory to
                iterate over. The path is first normalized
                <a href="lua.html#vim.fs.normalize()">vim.fs.normalize()</a>.
</div><div class="help-li" style=""> <code>{opts}</code>  table|nil Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> depth: integer|nil How deep the traverse (default 1)
</div><div class="help-li" style="margin-left: 3rem;"> skip: (fun(dir_name: string): boolean)|nil Predicate to
                  control traversal. Return false to stop searching the
                  current directory. Only useful when depth &gt; 1
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iterator over files and directories in <code>{path}</code>. Each iteration yields
        two values: name and type. Each "name" is the basename of the file or
        directory relative to <code>{path}</code>. Type is one of "file" or "directory".

</div>
<div class="help-para">
dirname(<code>{file}</code>)                                             <code id="vim.fs.dirname()" class="help-tag-right">vim.fs.dirname()</code>
    Return the parent directory of the given file or directory

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{file}</code>  (string) File or directory
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) Parent directory of <code>{file}</code>

</div>
<div class="help-para">
find(<code>{names}</code>, <code>{opts}</code>)                                          <code id="vim.fs.find()" class="help-tag-right">vim.fs.find()</code>
    Find files or directories in the given path.

</div>
<div class="help-para">
    Finds any files or directories given in <code>{names}</code> starting from <code>{path}</code>. If
    <code>{upward}</code> is "true" then the search traverses upward through parent
    directories; otherwise, the search traverses downward. Note that downward
    searches are recursive and may search through many directories! If <code>{stop}</code>
    is non-nil, then the search stops when the directory given in <code>{stop}</code> is
    reached. The search terminates when <code>{limit}</code> (default 1) matches are found.
    The search can be narrowed to find only files or only directories by
    specifying <code>{type}</code> to be "file" or "directory", respectively.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- location of Cargo.toml from the current buffer's path
local cargo = vim.fs.find('Cargo.toml', {
  upward = true,
  stop = vim.uv.os_homedir(),
  path = vim.fs.dirname(vim.api.nvim_buf_get_name(0)),
})
-- list all test directories under the runtime directory
local test_dirs = vim.fs.find(
  {'test', 'tst', 'testdir'},
  {limit = math.huge, type = 'directory', path = './runtime/'}
)
-- get all files ending with .cpp or .hpp inside lib/
local cpp_hpp = vim.fs.find(function(name, path)
  return name:match('.*%.[ch]pp$') and path:match('[/\\]lib$')
end, {limit = math.huge, type = 'file'})</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{names}</code>  (string|table|fun(name: string, path: string): boolean) Names
                 of the files and directories to find. Must be base names,
                 paths and globs are not supported when <code>{names}</code> is a string or
                 a table. If <code>{names}</code> is a function, it is called for each
                 traversed file and directory with args:
</div><div class="help-li" style="margin-left: 3rem;"> name: base name of the current item
</div><div class="help-li" style="margin-left: 3rem;"> path: full path of the current item The function should
                   return <code>true</code> if the given file or directory is considered
                   a match.
</div><div class="help-li" style=""> <code>{opts}</code>   (table) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> path (string): Path to begin searching from. If omitted,
                   the <a href="editing.html#current-directory">current-directory</a> is used.
</div><div class="help-li" style="margin-left: 3rem;"> upward (boolean, default false): If true, search upward
                   through parent directories. Otherwise, search through child
                   directories (recursively).
</div><div class="help-li" style="margin-left: 3rem;"> stop (string): Stop searching when this directory is
                   reached. The directory itself is not searched.
</div><div class="help-li" style="margin-left: 3rem;"> type (string): Find only files ("file") or directories
                   ("directory"). If omitted, both files and directories that
                   match <code>{names}</code> are included.
</div><div class="help-li" style="margin-left: 3rem;"> limit (number, default 1): Stop the search after finding
                   this many matches. Use <code>math.huge</code> to place no limit on the
                   number of matches.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table) Normalized paths <a href="lua.html#vim.fs.normalize()">vim.fs.normalize()</a> of all matching files or
        directories

</div>
<div class="help-para">
joinpath(<code>{...}</code>)                                            <code id="vim.fs.joinpath()" class="help-tag-right">vim.fs.joinpath()</code>
    Concatenate directories and/or file paths into a single path with
    normalization (e.g., <code>"foo/"</code> and <code>"bar"</code> get joined to <code>"foo/bar"</code>)

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{...}</code>  (string)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string)

</div>
<div class="help-para">
normalize(<code>{path}</code>, <code>{opts}</code>)                                 <code id="vim.fs.normalize()" class="help-tag-right">vim.fs.normalize()</code>
    Normalize a path to a standard format. A tilde (~) character at the
    beginning of the path is expanded to the user's home directory and any
    backslash (\) characters are converted to forward slashes (/). Environment
    variables are also expanded.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.fs.normalize('C:\\Users\\jdoe')
--&gt; 'C:/Users/jdoe'
vim.fs.normalize('~/src/neovim')
--&gt; '/home/jdoe/src/neovim'
vim.fs.normalize('$XDG_CONFIG_HOME/nvim/init.vim')
--&gt; '/Users/jdoe/.config/nvim/init.vim'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (string) Path to normalize
</div><div class="help-li" style=""> <code>{opts}</code>  (table|nil) Options:
</div><div class="help-li" style="margin-left: 3rem;"> expand_env: boolean Expand environment variables (default:
                  true)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string) Normalized path

</div>
<div class="help-para">
parents(<code>{start}</code>)                                            <code id="vim.fs.parents()" class="help-tag-right">vim.fs.parents()</code>
    Iterate over all the parents of the given file or directory.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local root_dir
for dir in vim.fs.parents(vim.api.nvim_buf_get_name(0)) do
  if vim.fn.isdirectory(dir .. "/.git") == 1 then
    root_dir = dir
    break
  end
end
if root_dir then
  print("Found git repository at", root_dir)
end</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{start}</code>  (string) Initial file or directory.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (function) Iterator

</div>
<div class="help-para">
<h2 id="lua-secure" class="help-heading">Lua module: secure<span class="help-heading-tags">                                                <span class="help-tag">lua-secure</span></h2>


</div>
<div class="help-para">
read(<code>{path}</code>)                                               <code id="vim.secure.read()" class="help-tag-right">vim.secure.read()</code>
    Attempt to read the file at <code>{path}</code> prompting the user if the file should
    be trusted. The user's choice is persisted in a trust database at
    $XDG_STATE_HOME/nvim/trust.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{path}</code>  (string) Path to a file to read.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (string|nil) The contents of the given file if it exists and is
        trusted, or nil otherwise.

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="editing.html#%3Atrust">:trust</a>
</div>
</div>
<div class="help-para">
trust(<code>{opts}</code>)                                             <code id="vim.secure.trust()" class="help-tag-right">vim.secure.trust()</code>
    Manage the trust database.

</div>
<div class="help-para">
    The trust database is located at <a href="starting.html#%24XDG_STATE_HOME">$XDG_STATE_HOME</a>/nvim/trust.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{opts}</code>  (table)
</div><div class="help-li" style="margin-left: 3rem;"> action (string): "allow" to add a file to the trust database
                  and trust it, "deny" to add a file to the trust database and
                  deny it, "remove" to remove file from the trust database
</div><div class="help-li" style="margin-left: 3rem;"> path (string|nil): Path to a file to update. Mutually
                  exclusive with <code>{bufnr}</code>. Cannot be used when <code>{action}</code> is
                  "allow".
</div><div class="help-li" style="margin-left: 3rem;"> bufnr (number|nil): Buffer number to update. Mutually
                  exclusive with <code>{path}</code>.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean, string) success, msg:
<div class="help-li" style=""> true and full path of target file if operation was successful
</div><div class="help-li" style=""> false and error message on failure
</div>
</div>
<div class="help-para">
<h2 id="lua-version" class="help-heading">Lua module: version<span class="help-heading-tags">                                              <span class="help-tag">lua-version</span></h2>


</div>
<div class="help-para">
The <code>vim.version</code> module provides functions for comparing versions and
ranges conforming to the

</div>
<div class="help-para">
<a href="https://semver.org">https://semver.org</a>

</div>
<div class="help-para">
spec. Plugins, and plugin managers, can use this to check available tools
and dependencies on the current system.

</div>
<div class="help-para">
Example:<pre><code class="language-lua">local v = vim.version.parse(vim.fn.system({'tmux', '-V'}), {strict=false})
if vim.version.gt(v, {3, 2, 0}) then
  -- ...
end</code></pre>

</div>
<div class="help-para">
<code id="vim.version()" class="help-tag">vim.version()</code> returns the version of the current Nvim process.

</div>
<div class="help-para">
<h3 id="version-range" class="help-heading">VERSION RANGE SPEC<span class="help-heading-tags"> <span class="help-tag">version-range</span></h3>


</div>
<div class="help-para">
A version "range spec" defines a semantic version range which can be
tested against a version, using <a href="lua.html#vim.version.range()">vim.version.range()</a>.

</div>
<div class="help-para">
Supported range specs are shown in the following table. Note: suffixed
versions (1.2.3-rc1) are not matched.<pre>1.2.3             is 1.2.3
=1.2.3            is 1.2.3
&gt;1.2.3            greater than 1.2.3
&lt;1.2.3            before 1.2.3
&gt;=1.2.3           at least 1.2.3
~1.2.3            is &gt;=1.2.3 &lt;1.3.0       "reasonably close to 1.2.3"
^1.2.3            is &gt;=1.2.3 &lt;2.0.0       "compatible with 1.2.3"
^0.2.3            is &gt;=0.2.3 &lt;0.3.0       (0.x.x is special)
^0.0.1            is =0.0.1               (0.0.x is special)
^1.2              is &gt;=1.2.0 &lt;2.0.0       (like ^1.2.0)
~1.2              is &gt;=1.2.0 &lt;1.3.0       (like ~1.2.0)
^1                is &gt;=1.0.0 &lt;2.0.0       "compatible with 1"
~1                same                    "reasonably close to 1"
1.x               same
1.*               same
1                 same
*                 any version
x                 same
1.2.3 - 2.3.4     is &gt;=1.2.3 &lt;=2.3.4
Partial right: missing pieces treated as x (2.3 =&gt; 2.3.x).
1.2.3 - 2.3       is &gt;=1.2.3 &lt;2.4.0
1.2.3 - 2         is &gt;=1.2.3 &lt;3.0.0
Partial left: missing pieces treated as 0 (1.2 =&gt; 1.2.0).
1.2 - 2.3.0       is 1.2.0 - 2.3.0</pre>

</div>
<div class="help-para">
cmp(<code>{v1}</code>, <code>{v2}</code>)                                            <code id="vim.version.cmp()" class="help-tag-right">vim.version.cmp()</code>
    Parses and compares two version objects (the result of
    <a href="lua.html#vim.version.parse()">vim.version.parse()</a>, or specified literally as a <code>{major, minor, patch}</code>
    tuple, e.g. <code>{1, 0, 3}</code>).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">if vim.version.cmp({1,0,3}, {0,2,1}) == 0 then
  -- ...
end
local v1 = vim.version.parse('1.0.3-pre')
local v2 = vim.version.parse('0.2.1')
if vim.version.cmp(v1, v2) == 0 then
  -- ...
end</code></pre>

</div>
<div class="help-para">
    Note:
        Per semver, build metadata is ignored when comparing two
        otherwise-equivalent versions.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  Version|number[] Version object.
</div><div class="help-li" style=""> <code>{v2}</code>  Version|number[] Version to compare with <code>v1</code> .
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (integer) -1 if <code>v1 &lt; v2</code>, 0 if <code>v1 == v2</code>, 1 if <code>v1 &gt; v2</code>.

</div>
<div class="help-para">
eq(<code>{v1}</code>, <code>{v2}</code>)                                              <code id="vim.version.eq()" class="help-tag-right">vim.version.eq()</code>
    Returns <code>true</code> if the given versions are equal. See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  Version|number[]
</div><div class="help-li" style=""> <code>{v2}</code>  Version|number[]
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean)

</div>
<div class="help-para">
gt(<code>{v1}</code>, <code>{v2}</code>)                                              <code id="vim.version.gt()" class="help-tag-right">vim.version.gt()</code>
    Returns <code>true</code> if <code>v1 &gt; v2</code> . See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  Version|number[]
</div><div class="help-li" style=""> <code>{v2}</code>  Version|number[]
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean)

</div>
<div class="help-para">
last(<code>{versions}</code>)                                          <code id="vim.version.last()" class="help-tag-right">vim.version.last()</code>
    TODO: generalize this, move to func.lua

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{versions}</code>  Version []
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Version ?|ni

</div>
<div class="help-para">
lt(<code>{v1}</code>, <code>{v2}</code>)                                              <code id="vim.version.lt()" class="help-tag-right">vim.version.lt()</code>
    Returns <code>true</code> if <code>v1 &lt; v2</code> . See <a href="lua.html#vim.version.cmp()">vim.version.cmp()</a> for usage.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{v1}</code>  Version|number[]
</div><div class="help-li" style=""> <code>{v2}</code>  Version|number[]
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (boolean)

</div>
<div class="help-para">
parse(<code>{version}</code>, <code>{opts}</code>)                                 <code id="vim.version.parse()" class="help-tag-right">vim.version.parse()</code>
    Parses a semantic version string and returns a version object which can be
    used with other <code>vim.version</code> functions. For example "1.0.1-rc1+build.2" returns:<pre>{ major = 1, minor = 0, patch = 1, prerelease = "rc1", build = "build.2" }</pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{version}</code>  (string) Version string to parse.
</div><div class="help-li" style=""> <code>{opts}</code>     (table|nil) Optional keyword arguments:
</div><div class="help-li" style="margin-left: 3rem;"> strict (boolean): Default false. If <code>true</code>, no coercion
                     is attempted on input not conforming to semver v2.0.0. If
                     <code>false</code>, <code>parse()</code> attempts to coerce input such as
                     "1.0", "0-x", "tmux 3.2a" into valid versions.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table|nil) parsed_version Version object or <code>nil</code> if input is invalid.

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> # <a href="https://semver.org/spec/v2.0.0.html">https://semver.org/spec/v2.0.0.html</a>
</div>
</div>
<div class="help-para">
range(<code>{spec}</code>)                                            <code id="vim.version.range()" class="help-tag-right">vim.version.range()</code>
    Parses a semver <a href="lua.html#version-range">version-range</a> "spec" and returns a range object:<pre>{
  from: Version
  to: Version
  has(v: string|Version)
}</pre>

</div>
<div class="help-para">
    <code>:has()</code> checks if a version is in the range (inclusive <code>from</code>, exclusive
    <code>to</code>).

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local r = vim.version.range('1.0.0 - 2.0.0')
print(r:has('1.9.9'))       -- true
print(r:has('2.0.0'))       -- false
print(r:has(vim.version())) -- check against current Nvim version</code></pre>

</div>
<div class="help-para">
    Or use cmp(), eq(), lt(), and gt() to compare <code>.to</code> and <code>.from</code> directly:<pre><code class="language-lua">local r = vim.version.range('1.0.0 - 2.0.0')
print(vim.version.gt({1,0,3}, r.from) and vim.version.lt({1,0,3}, r.to))</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{spec}</code>  string Version range "spec"
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> # <a href="https://github.com/npm/node-semver#ranges">https://github.com/npm/node-semver#ranges</a>
</div>
</div>
<div class="help-para">
<h2 id="lua-iter" class="help-heading">Lua module: iter<span class="help-heading-tags">                                                    <span class="help-tag">lua-iter</span></h2>


</div>
<div class="help-para">
The <code id="vim.iter" class="help-tag">vim.iter</code> module provides a generic interface for working with
iterables: tables, lists, iterator functions, pair()/ipair()-like
iterators, and <code>vim.iter()</code> objects.

</div>
<div class="help-para">
<code id="vim.iter()" class="help-tag">vim.iter()</code> wraps its table or function argument into an <code id="Iter" class="help-tag">Iter</code> object
with methods (such as <a href="lua.html#Iter%3Afilter()">Iter:filter()</a> and <a href="lua.html#Iter%3Amap()">Iter:map()</a>) that transform the
underlying source data. These methods can be chained together to create
iterator "pipelines". Each pipeline stage receives as input the output
values from the prior stage. The values used in the first stage of the
pipeline depend on the type passed to this function:

</div>
<div class="help-para">
<div class="help-li" style=""> List tables pass only the value of each element
</div><div class="help-li" style=""> Non-list tables pass both the key and value of each element
</div><div class="help-li" style=""> Function iterators pass all of the values returned by their respective
  function
</div><div class="help-li" style=""> Tables with a metatable implementing __call are treated as function
  iterators
</div>
</div>
<div class="help-para">
Examples:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4, 5 })
it:map(function(v)
  return v * 3
end)
it:rev()
it:skip(2)
it:totable()
-- { 9, 6, 3 }
vim.iter(ipairs({ 1, 2, 3, 4, 5 })):map(function(i, v)
  if i &gt; 2 then return v end
end):totable()
-- { 3, 4, 5 }
local it = vim.iter(vim.gsplit('1,2,3,4,5', ','))
it:map(function(s) return tonumber(s) end)
for i, d in it:enumerate() do
  print(string.format("Column %d is %d", i, d))
end
-- Column 1 is 1
-- Column 2 is 2
-- Column 3 is 3
-- Column 4 is 4
-- Column 5 is 5
vim.iter({ a = 1, b = 2, c = 3, z = 26 }):any(function(k, v)
  return k == 'z'
end)
-- true
local rb = vim.ringbuf(3)
rb:push("a")
rb:push("b")
vim.iter(rb):totable()
-- { "a", "b" }</code></pre>

</div>
<div class="help-para">
In addition to the <a href="lua.html#vim.iter()">vim.iter()</a> function, the <a href="lua.html#vim.iter">vim.iter</a> module provides
convenience functions like <a href="lua.html#vim.iter.filter()">vim.iter.filter()</a> and <a href="lua.html#vim.iter.totable()">vim.iter.totable()</a>.

</div>
<div class="help-para">
filter(<code>{f}</code>, <code>{src}</code>, <code>{...}</code>)                                  <code id="vim.iter.filter()" class="help-tag-right">vim.iter.filter()</code>
    Filter a table or iterator.

</div>
<div class="help-para">
    This is a convenience function that performs:<pre><code class="language-lua">vim.iter(src):filter(f):totable()</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>    function(...):bool Filter function. Accepts the current
               iterator or table values as arguments and returns true if those
               values should be kept in the final table
</div><div class="help-li" style=""> <code>{src}</code>  table|function Table or iterator function to filter
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table)

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Afilter()">Iter:filter()</a>
</div>
</div>
<div class="help-para">
Iter:all(<code>{self}</code>, <code>{pred}</code>)                                          <code id="Iter%3Aall()" class="help-tag-right">Iter:all()</code>
    Return true if all of the items in the iterator match the given predicate.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{pred}</code>  function(...):bool Predicate function. Takes all values
                returned from the previous stage in the pipeline as arguments
                and returns true if the predicate matches.
</div>
</div>
<div class="help-para">
Iter:any(<code>{self}</code>, <code>{pred}</code>)                                          <code id="Iter%3Aany()" class="help-tag-right">Iter:any()</code>
    Return true if any of the items in the iterator match the given predicate.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{pred}</code>  function(...):bool Predicate function. Takes all values
                returned from the previous stage in the pipeline as arguments
                and returns true if the predicate matches.
</div>
</div>
<div class="help-para">
Iter:each(<code>{self}</code>, <code>{f}</code>)                                           <code id="Iter%3Aeach()" class="help-tag-right">Iter:each()</code>
    Call a function once for each item in the pipeline.

</div>
<div class="help-para">
    This is used for functions which have side effects. To modify the values
    in the iterator, use <a href="lua.html#Iter%3Amap()">Iter:map()</a>.

</div>
<div class="help-para">
    This function drains the iterator.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  function(...) Function to execute for each item in the pipeline.
             Takes all of the values returned by the previous stage in the
             pipeline as arguments.
</div>
</div>
<div class="help-para">
Iter:enumerate(<code>{self}</code>)                                      <code id="Iter%3Aenumerate()" class="help-tag-right">Iter:enumerate()</code>
    Add an iterator stage that returns the current iterator count as well as
    the iterator value.

</div>
<div class="help-para">
    For list tables, prefer<pre><code class="language-lua">vim.iter(ipairs(t))</code></pre>

</div>
<div class="help-para">
    over<pre><code class="language-lua">vim.iter(t):enumerate()</code></pre>

</div>
<div class="help-para">
    as the former is faster.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(vim.gsplit('abc', '')):enumerate()
it:next()
-- 1   'a'
it:next()
-- 2   'b'
it:next()
-- 3   'c'</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:filter(<code>{self}</code>, <code>{f}</code>)                                       <code id="Iter%3Afilter()" class="help-tag-right">Iter:filter()</code>
    Add a filter step to the iterator pipeline.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local bufs = vim.iter(vim.api.nvim_list_bufs()):filter(vim.api.nvim_buf_is_loaded)</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  function(...):bool Takes all values returned from the previous
             stage in the pipeline and returns false or nil if the current
             iterator element should be removed.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:find(<code>{self}</code>, <code>{f}</code>)                                           <code id="Iter%3Afind()" class="help-tag-right">Iter:find()</code>
    Find the first value in the iterator that satisfies the given predicate.

</div>
<div class="help-para">
    Advances the iterator. Returns nil and drains the iterator if no value is
    found.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:find(12)
-- 12
local it = vim.iter({ 3, 6, 9, 12 })
it:find(20)
-- nil
local it = vim.iter({ 3, 6, 9, 12 })
it:find(function(v) return v % 4 == 0 end)
-- 12</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:fold(<code>{self}</code>, <code>{init}</code>, <code>{f}</code>)                                   <code id="Iter%3Afold()" class="help-tag-right">Iter:fold()</code>
    Fold ("reduce") an iterator or table into a single value.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">-- Create a new table with only even values
local t = { a = 1, b = 2, c = 3, d = 4 }
local it = vim.iter(t)
it:filter(function(k, v) return v % 2 == 0 end)
it:fold({}, function(t, k, v)
  t[k] = v
  return t
end)
-- { b = 2, d = 4 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{init}</code>  any Initial value of the accumulator.
</div><div class="help-li" style=""> <code>{f}</code>     function(acc:any, ...):A Accumulation function.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:last(<code>{self}</code>)                                                <code id="Iter%3Alast()" class="help-tag-right">Iter:last()</code>
    Return the last item in the iterator.

</div>
<div class="help-para">
    Drains the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(vim.gsplit('abcdefg', ''))
it:last()
-- 'g'
local it = vim.iter({ 3, 6, 9, 12, 15 })
it:last()
-- 15</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:map(<code>{self}</code>, <code>{f}</code>)                                             <code id="Iter%3Amap()" class="help-tag-right">Iter:map()</code>
    Add a map step to the iterator pipeline.

</div>
<div class="help-para">
    If the map function returns nil, the value is filtered from the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4 }):map(function(v)
  if v % 2 == 0 then
    return v * 3
  end
end)
it:totable()
-- { 6, 12 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  function(...):any Mapping function. Takes all values returned
             from the previous stage in the pipeline as arguments and returns
             one or more new values, which are used in the next pipeline
             stage. Nil return values are filtered from the output.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:next(<code>{self}</code>)                                                <code id="Iter%3Anext()" class="help-tag-right">Iter:next()</code>
    Return the next value from the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter(string.gmatch('1 2 3', 'd+')):map(tonumber)
it:next()
-- 1
it:next()
-- 2
it:next()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:nextback(<code>{self}</code>)                                        <code id="Iter%3Anextback()" class="help-tag-right">Iter:nextback()</code>
    Return the next value from the end of the iterator.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({1, 2, 3, 4})
it:nextback()
-- 4
it:nextback()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:nth(<code>{self}</code>, <code>{n}</code>)                                             <code id="Iter%3Anth()" class="help-tag-right">Iter:nth()</code>
    Return the nth value in the iterator.

</div>
<div class="help-para">
    This function advances the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:nth(2)
-- 6
it:nth(2)
-- 12</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (number) The index of the value to return.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:nthback(<code>{self}</code>, <code>{n}</code>)                                     <code id="Iter%3Anthback()" class="help-tag-right">Iter:nthback()</code>
    Return the nth value from the end of the iterator.

</div>
<div class="help-para">
    This function advances the iterator.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:nthback(2)
-- 9
it:nthback(2)
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (number) The index of the value to return.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:peek(<code>{self}</code>)                                                <code id="Iter%3Apeek()" class="help-tag-right">Iter:peek()</code>
    Peek at the next value in the iterator without consuming it.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 })
it:peek()
-- 3
it:peek()
-- 3
it:next()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:peekback(<code>{self}</code>)                                        <code id="Iter%3Apeekback()" class="help-tag-right">Iter:peekback()</code>
    Return the next value from the end of the iterator without consuming it.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({1, 2, 3, 4})
it:peekback()
-- 4
it:peekback()
-- 4
it:nextback()
-- 4</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
Iter:rev(<code>{self}</code>)                                                  <code id="Iter%3Arev()" class="help-tag-right">Iter:rev()</code>
    Reverse an iterator.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 }):rev()
it:totable()
-- { 12, 9, 6, 3 }</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:rfind(<code>{self}</code>, <code>{f}</code>)                                         <code id="Iter%3Arfind()" class="help-tag-right">Iter:rfind()</code>
    Find the first value in the iterator that satisfies the given predicate,
    starting from the end.

</div>
<div class="help-para">
    Advances the iterator. Returns nil and drains the iterator if no value is
    found.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 2, 1 }):enumerate()
it:rfind(1)
-- 5   1
it:rfind(1)
-- 1   1</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        any

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> Iter.find
</div>
</div>
<div class="help-para">
Iter:skip(<code>{self}</code>, <code>{n}</code>)                                           <code id="Iter%3Askip()" class="help-tag-right">Iter:skip()</code>
    Skip values in the iterator.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 3, 6, 9, 12 }):skip(2)
it:next()
-- 9</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (number) Number of values to skip.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:skipback(<code>{self}</code>, <code>{n}</code>)                                   <code id="Iter%3Askipback()" class="help-tag-right">Iter:skipback()</code>
    Skip values in the iterator starting from the end.

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
    Example:<pre><code class="language-lua">local it = vim.iter({ 1, 2, 3, 4, 5 }):skipback(2)
it:next()
-- 1
it:nextback()
-- 3</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{n}</code>  (number) Number of values to skip.
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:slice(<code>{self}</code>, <code>{first}</code>, <code>{last}</code>)                             <code id="Iter%3Aslice()" class="help-tag-right">Iter:slice()</code>
    Slice an iterator, changing its start and end positions.

</div>
<div class="help-para">
    This is equivalent to :skip(first - 1):skipback(len - last + 1)

</div>
<div class="help-para">
    Only supported for iterators on list-like tables.

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{first}</code>  (number)
</div><div class="help-li" style=""> <code>{last}</code>   (number)
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        Iter

</div>
<div class="help-para">
Iter:totable(<code>{self}</code>)                                          <code id="Iter%3Atotable()" class="help-tag-right">Iter:totable()</code>
    Collect the iterator into a table.

</div>
<div class="help-para">
    The resulting table depends on the initial source in the iterator
    pipeline. List-like tables and function iterators will be collected into a
    list-like table. If multiple values are returned from the final stage in
    the iterator pipeline, each value will be included in a table.

</div>
<div class="help-para">
    Examples:<pre><code class="language-lua">vim.iter(string.gmatch('100 20 50', 'd+')):map(tonumber):totable()
-- { 100, 20, 50 }
vim.iter({ 1, 2, 3 }):map(function(v) return v, 2 * v end):totable()
-- { { 1, 2 }, { 2, 4 }, { 3, 6 } }
vim.iter({ a = 1, b = 2, c = 3 }):filter(function(k, v) return v % 2 ~= 0 end):totable()
-- { { 'a', 1 }, { 'c', 3 } }</code></pre>

</div>
<div class="help-para">
    The generated table is a list-like table with consecutive, numeric
    indices. To create a map-like table with arbitrary keys, use
    <a href="lua.html#Iter%3Afold()">Iter:fold()</a>.

</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table)

</div>
<div class="help-para">
map(<code>{f}</code>, <code>{src}</code>, <code>{...}</code>)                                        <code id="vim.iter.map()" class="help-tag-right">vim.iter.map()</code>
    Map and filter a table or iterator.

</div>
<div class="help-para">
    This is a convenience function that performs:<pre><code class="language-lua">vim.iter(src):map(f):totable()</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>    function(...):?any Map function. Accepts the current iterator
               or table values as arguments and returns one or more new
               values. Nil values are removed from the final table.
</div><div class="help-li" style=""> <code>{src}</code>  table|function Table or iterator function to filter
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table)

</div>
<div class="help-para">
<div class="help-column_heading">    See also:</div>
<div class="help-li" style=""> <a href="lua.html#Iter%3Amap()">Iter:map()</a>
</div>
</div>
<div class="help-para">
totable(<code>{f}</code>, <code>{...}</code>)                                       <code id="vim.iter.totable()" class="help-tag-right">vim.iter.totable()</code>
    Collect an iterator into a table.

</div>
<div class="help-para">
    This is a convenience function that performs:<pre><code class="language-lua">vim.iter(f):totable()</code></pre>

</div>
<div class="help-para">
<div class="help-column_heading">    Parameters:</div>
<div class="help-li" style=""> <code>{f}</code>  (function) Iterator function
</div>
</div>
<div class="help-para">
<div class="help-column_heading">    Return:</div>
        (table)

</div>

  </div>
      <div class="col-narrow toc">
      <div><a href="index.html">Main</a></div>
      <div><a href="vimindex.html">Commands index</a></div>
      <div><a href="quickref.html">Quick reference</a></div>
      <hr/>
  <div class="help-toc-h1"><a href="#lua-intro">
INTRODUCTION                                                       </a>
</div><div class="help-toc-h1"><a href="#lua-concepts">
LUA CONCEPTS AND IDIOMS                                         </a>
</div><div class="help-toc-h1"><a href="#require()">
IMPORTING LUA MODULES                                  </a>
</div><div class="help-toc-h1"><a href="#lua-commands">
COMMANDS                                                        </a>
</div><div class="help-toc-h1"><a href="#lua-eval">
luaeval()                                                 </a>
</div><div class="help-toc-h1"><a href="#v%3Alua-call">
Vimscript v:lua interface                                         </a>
</div><div class="help-toc-h1"><a href="#lua-stdlib">
Lua standard modules                                              </a>
</div><div class="help-toc-h1"><a href="#lua-vim">
Lua module: vim                                                      </a>
</div><div class="help-toc-h1"><a href="#lua-inspector">
Lua module: inspector                                          </a>
</div><div class="help-toc-h1"><a href="#lua-loader">
Lua module: loader                                                </a>
</div><div class="help-toc-h1"><a href="#lua-uri">
Lua module: uri                                                      </a>
</div><div class="help-toc-h1"><a href="#lua-ui">
Lua module: ui                                                        </a>
</div><div class="help-toc-h1"><a href="#lua-filetype">
Lua module: filetype                                            </a>
</div><div class="help-toc-h1"><a href="#lua-keymap">
Lua module: keymap                                                </a>
</div><div class="help-toc-h1"><a href="#lua-fs">
Lua module: fs                                                        </a>
</div><div class="help-toc-h1"><a href="#lua-secure">
Lua module: secure                                                </a>
</div><div class="help-toc-h1"><a href="#lua-version">
Lua module: version                                              </a>
</div><div class="help-toc-h1"><a href="#lua-iter">
Lua module: iter                                                    </a>
</div></div>
</div>
  <footer>
    <div class="container flex">
      <div class="generator-stats">
        Generated at 2023-07-07 05:32 from <code><a href="https://github.com/neovim/neovim/commit/811140e276a6312775bfcf9b368de25386f7a356">811140e</a></code>
      </div>
      <div class="generator-stats">
      parse_errors: 0 (<a href="https://github.com/neovim/neovim/issues/new?labels=bug&title=user+docs+HTML%3A+lua.txt+&body=%60gen_help_html.lua%60+problem+at%3A+https://neovim.io/doc/user/lua.html%0D%0DContext%3A%0D%0D%60%60%60%0DTODO%0D%60%60%60" target="_blank">report docs bug...</a>) | <span title="    Nvim
                            NVIM REFERENCE MANUAL
                                       Type &lt;a href="various.html#gO"&gt;gO&lt;/a&gt; to see the table of contents.
 vim:tw=78:ts=8:sw=4:sts=4:et:ft=help:norl:">noise_lines: 4</span>
      </div>
    <div>

    <!-- algolia docsearch https://docsearch.algolia.com/docs/docsearch-v3/ -->
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script>
    <script type="module">
      docsearch({
        container: '#docsearch',
        appId: 'X185E15FPG',
        apiKey: 'b5e6b2f9c636b2b471303205e59832ed',
        indexName: 'nvim',
      });
    </script>

  </footer>
  </body>
</html>
