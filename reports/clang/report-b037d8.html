<!doctype html>
<html>
<head>
<title>/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Dereference of null pointer -->

<!-- BUGTYPE Dereference of null pointer -->

<!-- BUGCATEGORY Logic error -->

<!-- BUGFILE /home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c -->

<!-- FILENAME signal.c -->

<!-- FUNCTIONNAME uv__signal_tree_s_RB_REMOVE_COLOR -->

<!-- BUGLINE 52 -->

<!-- BUGCOLUMN 1 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 52, column 1</a></td></tr>
<tr><td class="rowname">Description:</td><td>Dereference of null pointer</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line"> <span class='comment'>* Permission is hereby granted, free of charge, to any person obtaining a copy</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line"> <span class='comment'>* of this software and associated documentation files (the "Software"), to</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line"> <span class='comment'>* deal in the Software without restriction, including without limitation the</span></td></tr>
<tr><td class="num" id="LN5">5</td><td class="line"> <span class='comment'>* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> <span class='comment'>* sell copies of the Software, and to permit persons to whom the Software is</span></td></tr>
<tr><td class="num" id="LN7">7</td><td class="line"> <span class='comment'>* furnished to do so, subject to the following conditions:</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line"> <span class='comment'>* The above copyright notice and this permission notice shall be included in</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line"> <span class='comment'>* all copies or substantial portions of the Software.</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line"> <span class='comment'>*</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line"> <span class='comment'>* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"> <span class='comment'>* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></td></tr>
<tr><td class="num" id="LN14">14</td><td class="line"> <span class='comment'>* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line"> <span class='comment'>* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line"> <span class='comment'>* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line"> <span class='comment'>* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"> <span class='comment'>* IN THE SOFTWARE.</span></td></tr>
<tr><td class="num" id="LN19">19</td><td class="line"> <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN20">20</td><td class="line"> </td></tr>
<tr><td class="num" id="LN21">21</td><td class="line"><span class='directive'>#include "uv.h"</span></td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='directive'>#include "internal.h"</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"> </td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#include &lt;assert.h&gt;</span></td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#include &lt;<span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span>.h&gt;</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#include &lt;signal.h&gt;</span></td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"><span class='directive'>#include &lt;stdlib.h&gt;</span></td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"><span class='directive'>#include &lt;string.h&gt;</span></td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='directive'>#include &lt;unistd.h&gt;</span></td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"> </td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='keyword'>typedef</span> <span class='keyword'>struct</span> {</td></tr>
<tr><td class="num" id="LN33">33</td><td class="line">  uv_signal_t* handle;</td></tr>
<tr><td class="num" id="LN34">34</td><td class="line">  <span class='keyword'>int</span> signum;</td></tr>
<tr><td class="num" id="LN35">35</td><td class="line">} uv__signal_msg_t;</td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"> </td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='macro'>RB_HEAD(uv__signal_tree_s, uv_signal_s)<span class='expansion'>struct uv__signal_tree_s { struct uv_signal_s *rbh_root; }</span></span>;</td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"> </td></tr>
<tr><td class="num" id="LN39">39</td><td class="line"> </td></tr>
<tr><td class="num" id="LN40">40</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_unlock(<span class='keyword'>void</span>);</td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_event(uv_loop_t* loop, uv__io_t* w, <span class='keyword'>unsigned</span> <span class='keyword'>int</span> events);</td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2);</td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_stop(uv_signal_t* handle);</td></tr>
<tr><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr><td class="num" id="LN45">45</td><td class="line"> </td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"><span class='keyword'>static</span> pthread_once_t uv__signal_global_init_guard = <span class='macro'>PTHREAD_ONCE_INIT<span class='expansion'>0</span></span>;</td></tr>
<tr><td class="num" id="LN47">47</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>struct</span> uv__signal_tree_s uv__signal_tree =</td></tr>
<tr><td class="num" id="LN48">48</td><td class="line">    <span class='macro'>RB_INITIALIZER(uv__signal_tree)<span class='expansion'>{ ((void*)0) }</span></span>;</td></tr>
<tr><td class="num" id="LN49">49</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_lock_pipefd[2];</td></tr>
<tr><td class="num" id="LN50">50</td><td class="line"> </td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"> </td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"><span class='macro'>RB_GENERATE_STATIC(uv__signal_tree_s,<span class='expansion'>__attribute__((unused)) static void uv__signal_tree_s_RB_INSERT_COLOR<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *parent, *gparent, *tmp; while ((parent = (elm)-&gt;<br>tree_entry.rbe_parent) != ((void*)0) &amp;&amp; (parent)-&gt;<br>tree_entry.rbe_color == 1) { gparent = (parent)-&gt;tree_entry<br>.rbe_parent; if (parent == (gparent)-&gt;tree_entry.rbe_left)<br> { tmp = (gparent)-&gt;tree_entry.rbe_right; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_right == elm) { do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_left; if (((gparent)-&gt;<br>tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> else { tmp = (gparent)-&gt;tree_entry.rbe_left; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_left == elm) { do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_right; if (((gparent)-&gt;<br>tree_entry.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_left = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> } (head-&gt;rbh_root)-&gt;tree_entry.rbe_color = 0; } __attribute__<br>((unused)) static void uv__signal_tree_s_RB_REMOVE_COLOR(struct<br> uv__signal_tree_s *head, struct uv_signal_s *parent, struct uv_signal_s<br> *elm) { struct uv_signal_s *tmp; while ((elm == ((void*)0) ||<br> (elm)-&gt;tree_entry.rbe_color == 0) &amp;&amp; elm != (head<br>)-&gt;rbh_root) { if ((parent)-&gt;tree_entry.rbe_left == elm<br>) { tmp = (parent)-&gt;tree_entry.rbe_right; if ((tmp)-&gt;tree_entry<br>.rbe_color == 1) { do { (tmp)-&gt;tree_entry.rbe_color = 0; (<br>parent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = (parent)-&gt;<br>tree_entry.rbe_right; } if (((tmp)-&gt;tree_entry.rbe_left ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry<br>.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_right == ((void*)0) || ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color == 0) { struct<br> uv_signal_s *oleft; if ((oleft = (tmp)-&gt;tree_entry.rbe_left<br>) != ((void*)0)) (oleft)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;<br>tree_entry.rbe_color = 1; do { (oleft) = (tmp)-&gt;tree_entry<br>.rbe_left; if (((tmp)-&gt;tree_entry.rbe_left = (oleft)-&gt;tree_entry<br>.rbe_right) != ((void*)0)) { ((oleft)-&gt;tree_entry.rbe_right<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oleft)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oleft); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oleft); } else (head)-&gt;rbh_root<br> = (oleft); (oleft)-&gt;tree_entry.rbe_right = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oleft); do {} while (0); if (((oleft<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_right; } (tmp)-&gt;tree_entry.<br>rbe_color = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_right) ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color = 0; do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } else { tmp = (parent)-&gt;tree_entry.rbe_left<br>; if ((tmp)-&gt;tree_entry.rbe_color == 1) { do { (tmp)-&gt;tree_entry<br>.rbe_color = 0; (parent)-&gt;tree_entry.rbe_color = 1; } while<br> ( 0); do { (tmp) = (parent)-&gt;tree_entry.rbe_left; if (((parent<br>)-&gt;tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) !=<br> ((void*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_parent = (parent); } do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent = (parent)-&gt;tree_entry.rbe_parent) != ((void*)<br>0)) { if ((parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)<br>-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } if (((tmp)-&gt;tree_entry<br>.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;<br>tree_entry.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right<br> == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry<br>.rbe_left)-&gt;tree_entry.rbe_color == 0) { struct uv_signal_s<br> *oright; if ((oright = (tmp)-&gt;tree_entry.rbe_right) != ((<br>void*)0)) (oright)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;tree_entry<br>.rbe_color = 1; do { (oright) = (tmp)-&gt;tree_entry.rbe_right<br>; if (((tmp)-&gt;tree_entry.rbe_right = (oright)-&gt;tree_entry<br>.rbe_left) != ((void*)0)) { ((oright)-&gt;tree_entry.rbe_left<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oright)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oright); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oright); } else (head)-&gt;rbh_root<br> = (oright); (oright)-&gt;tree_entry.rbe_left = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oright); do {} while (0); if (((oright<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } (tmp)-&gt;tree_entry.rbe_color<br> = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_left) ((tmp)-&gt;<br>tree_entry.rbe_left)-&gt;tree_entry.rbe_color = 0; do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } } if (elm) (elm)-&gt;tree_entry.rbe_color<br> = 0; } __attribute__((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_REMOVE<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *child, *parent, *old = elm; int color; if ((elm<br>)-&gt;tree_entry.rbe_left == ((void*)0)) child = (elm)-&gt;tree_entry<br>.rbe_right; else if ((elm)-&gt;tree_entry.rbe_right == ((void<br>*)0)) child = (elm)-&gt;tree_entry.rbe_left; else { struct uv_signal_s<br> *left; elm = (elm)-&gt;tree_entry.rbe_right; while ((left = (<br>elm)-&gt;tree_entry.rbe_left) != ((void*)0)) elm = left; child<br> = (elm)-&gt;tree_entry.rbe_right; parent = (elm)-&gt;tree_entry<br>.rbe_parent; color = (elm)-&gt;tree_entry.rbe_color; if (child<br>) (child)-&gt;tree_entry.rbe_parent = parent; if (parent) { if<br> ((parent)-&gt;tree_entry.rbe_left == elm) (parent)-&gt;tree_entry<br>.rbe_left = child; else (parent)-&gt;tree_entry.rbe_right = child<br>; do {} while (0); } else (head)-&gt;rbh_root = child; if ((elm<br>)-&gt;tree_entry.rbe_parent == old) parent = elm; (elm)-&gt;tree_entry<br> = (old)-&gt;tree_entry; if ((old)-&gt;tree_entry.rbe_parent)<br> { if (((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> == old) ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = elm; else ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = elm; do {} while (0); } else (head)-&gt;rbh_root<br> = elm; ((old)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = elm; if ((old)-&gt;tree_entry.rbe_right) ((old)-&gt;tree_entry<br>.rbe_right)-&gt;tree_entry.rbe_parent = elm; if (parent) { left<br> = parent; do { do {} while (0); } while ((left = (left)-&gt;<br>tree_entry.rbe_parent) != ((void*)0)); } goto color; } parent<br> = (elm)-&gt;tree_entry.rbe_parent; color = (elm)-&gt;tree_entry<br>.rbe_color; if (child) (child)-&gt;tree_entry.rbe_parent = parent<br>; if (parent) { if ((parent)-&gt;tree_entry.rbe_left == elm) (<br>parent)-&gt;tree_entry.rbe_left = child; else (parent)-&gt;tree_entry<br>.rbe_right = child; do {} while (0); } else (head)-&gt;rbh_root<br> = child; color: if (color == 0) uv__signal_tree_s_RB_REMOVE_COLOR<br>(head, parent, child); return (old); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_INSERT(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp; struct uv_signal_s *parent = ((void*)0); int comp = 0;<br> tmp = (head)-&gt;rbh_root; while (tmp) { parent = tmp; comp =<br> (uv__signal_compare)(elm, parent); if (comp &lt; 0) tmp = (tmp<br>)-&gt;tree_entry.rbe_left; else if (comp &gt; 0) tmp = (tmp)-&gt;<br>tree_entry.rbe_right; else return (tmp); } do { (elm)-&gt;tree_entry<br>.rbe_parent = parent; (elm)-&gt;tree_entry.rbe_left = (elm)-&gt;<br>tree_entry.rbe_right = ((void*)0); (elm)-&gt;tree_entry.rbe_color<br> = 1; } while ( 0); if (parent != ((void*)0)) { if (comp &lt;<br> 0) (parent)-&gt;tree_entry.rbe_left = elm; else (parent)-&gt;<br>tree_entry.rbe_right = elm; do {} while (0); } else (head)-&gt;<br>rbh_root = elm; uv__signal_tree_s_RB_INSERT_COLOR(head, elm);<br> return (((void*)0)); } __attribute__((unused)) static struct<br> uv_signal_s * uv__signal_tree_s_RB_FIND(struct uv__signal_tree_s<br> *head, struct uv_signal_s *elm) { struct uv_signal_s *tmp = (<br>head)-&gt;rbh_root; int comp; while (tmp) { comp = uv__signal_compare<br>(elm, tmp); if (comp &lt; 0) tmp = (tmp)-&gt;tree_entry.rbe_left<br>; else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right;<br> else return (tmp); } return (((void*)0)); } __attribute__((unused<br>)) static struct uv_signal_s * uv__signal_tree_s_RB_NFIND(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *res = ((void<br>*)0); int comp; while (tmp) { comp = uv__signal_compare(elm, tmp<br>); if (comp &lt; 0) { res = tmp; tmp = (tmp)-&gt;tree_entry.rbe_left<br>; } else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right<br>; else return (tmp); } return (res); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_NEXT(struct<br> uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_right) { elm<br> = (elm)-&gt;tree_entry.rbe_right; while ((elm)-&gt;tree_entry<br>.rbe_left) elm = (elm)-&gt;tree_entry.rbe_left; } else { if (<br>(elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;<br>tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry.rbe_parent<br> &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right)) elm = (elm)-&gt;tree_entry.rbe_parent; elm = (elm<br>)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_PREV<br>(struct uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_left<br>) { elm = (elm)-&gt;tree_entry.rbe_left; while ((elm)-&gt;tree_entry<br>.rbe_right) elm = (elm)-&gt;tree_entry.rbe_right; } else { if<br> ((elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_right)) elm = (elm)<br>-&gt;tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry<br>.rbe_parent &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;tree_entry.rbe_parent<br>; elm = (elm)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_MINMAX<br>(struct uv__signal_tree_s *head, int val) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *parent = ((void<br>*)0); while (tmp) { parent = tmp; if (val &lt; 0) tmp = (tmp)<br>-&gt;tree_entry.rbe_left; else tmp = (tmp)-&gt;tree_entry.rbe_right<br>; } return (parent); }</span></span></td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgControl" style="margin-left:1ex; max-width:100em">Within the expansion of the macro 'RB_GENERATE_STATIC':
<div class="msg msgEvent" style="width:94%; margin-left:5px"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">a</div></td><td valign="top">Assuming 'elm' is not equal to null</td></tr></table></div>
<div class="msg msgEvent" style="width:94%; margin-left:5px"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">b</div></td><td valign="top">Value assigned to field 'rbe_left'</td></tr></table></div>
<div class="msg msgEvent" style="width:94%; margin-left:5px"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">c</div></td><td valign="top">Assuming pointer value is null</td></tr></table></div>
<div class="msg msgEvent" style="width:94%; margin-left:5px"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">d</div></td><td valign="top">Null pointer value stored to 'tmp'</td></tr></table></div>
<div class="msg msgEvent" style="width:94%; margin-left:5px"><table class="msgT"><tr><td valign="top"><div class="PathIndex PathIndexEvent">e</div></td><td valign="top">Dereference of null pointer</td></tr></table></div>
</div></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line">                   <span class='macro'>uv_signal_s, tree_entry,<span class='expansion'>__attribute__((unused)) static void uv__signal_tree_s_RB_INSERT_COLOR<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *parent, *gparent, *tmp; while ((parent = (elm)-&gt;<br>tree_entry.rbe_parent) != ((void*)0) &amp;&amp; (parent)-&gt;<br>tree_entry.rbe_color == 1) { gparent = (parent)-&gt;tree_entry<br>.rbe_parent; if (parent == (gparent)-&gt;tree_entry.rbe_left)<br> { tmp = (gparent)-&gt;tree_entry.rbe_right; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_right == elm) { do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_left; if (((gparent)-&gt;<br>tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> else { tmp = (gparent)-&gt;tree_entry.rbe_left; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_left == elm) { do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_right; if (((gparent)-&gt;<br>tree_entry.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_left = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> } (head-&gt;rbh_root)-&gt;tree_entry.rbe_color = 0; } __attribute__<br>((unused)) static void uv__signal_tree_s_RB_REMOVE_COLOR(struct<br> uv__signal_tree_s *head, struct uv_signal_s *parent, struct uv_signal_s<br> *elm) { struct uv_signal_s *tmp; while ((elm == ((void*)0) ||<br> (elm)-&gt;tree_entry.rbe_color == 0) &amp;&amp; elm != (head<br>)-&gt;rbh_root) { if ((parent)-&gt;tree_entry.rbe_left == elm<br>) { tmp = (parent)-&gt;tree_entry.rbe_right; if ((tmp)-&gt;tree_entry<br>.rbe_color == 1) { do { (tmp)-&gt;tree_entry.rbe_color = 0; (<br>parent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = (parent)-&gt;<br>tree_entry.rbe_right; } if (((tmp)-&gt;tree_entry.rbe_left ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry<br>.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_right == ((void*)0) || ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color == 0) { struct<br> uv_signal_s *oleft; if ((oleft = (tmp)-&gt;tree_entry.rbe_left<br>) != ((void*)0)) (oleft)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;<br>tree_entry.rbe_color = 1; do { (oleft) = (tmp)-&gt;tree_entry<br>.rbe_left; if (((tmp)-&gt;tree_entry.rbe_left = (oleft)-&gt;tree_entry<br>.rbe_right) != ((void*)0)) { ((oleft)-&gt;tree_entry.rbe_right<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oleft)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oleft); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oleft); } else (head)-&gt;rbh_root<br> = (oleft); (oleft)-&gt;tree_entry.rbe_right = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oleft); do {} while (0); if (((oleft<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_right; } (tmp)-&gt;tree_entry.<br>rbe_color = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_right) ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color = 0; do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } else { tmp = (parent)-&gt;tree_entry.rbe_left<br>; if ((tmp)-&gt;tree_entry.rbe_color == 1) { do { (tmp)-&gt;tree_entry<br>.rbe_color = 0; (parent)-&gt;tree_entry.rbe_color = 1; } while<br> ( 0); do { (tmp) = (parent)-&gt;tree_entry.rbe_left; if (((parent<br>)-&gt;tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) !=<br> ((void*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_parent = (parent); } do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent = (parent)-&gt;tree_entry.rbe_parent) != ((void*)<br>0)) { if ((parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)<br>-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } if (((tmp)-&gt;tree_entry<br>.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;<br>tree_entry.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right<br> == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry<br>.rbe_left)-&gt;tree_entry.rbe_color == 0) { struct uv_signal_s<br> *oright; if ((oright = (tmp)-&gt;tree_entry.rbe_right) != ((<br>void*)0)) (oright)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;tree_entry<br>.rbe_color = 1; do { (oright) = (tmp)-&gt;tree_entry.rbe_right<br>; if (((tmp)-&gt;tree_entry.rbe_right = (oright)-&gt;tree_entry<br>.rbe_left) != ((void*)0)) { ((oright)-&gt;tree_entry.rbe_left<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oright)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oright); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oright); } else (head)-&gt;rbh_root<br> = (oright); (oright)-&gt;tree_entry.rbe_left = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oright); do {} while (0); if (((oright<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } (tmp)-&gt;tree_entry.rbe_color<br> = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_left) ((tmp)-&gt;<br>tree_entry.rbe_left)-&gt;tree_entry.rbe_color = 0; do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } } if (elm) (elm)-&gt;tree_entry.rbe_color<br> = 0; } __attribute__((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_REMOVE<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *child, *parent, *old = elm; int color; if ((elm<br>)-&gt;tree_entry.rbe_left == ((void*)0)) child = (elm)-&gt;tree_entry<br>.rbe_right; else if ((elm)-&gt;tree_entry.rbe_right == ((void<br>*)0)) child = (elm)-&gt;tree_entry.rbe_left; else { struct uv_signal_s<br> *left; elm = (elm)-&gt;tree_entry.rbe_right; while ((left = (<br>elm)-&gt;tree_entry.rbe_left) != ((void*)0)) elm = left; child<br> = (elm)-&gt;tree_entry.rbe_right; parent = (elm)-&gt;tree_entry<br>.rbe_parent; color = (elm)-&gt;tree_entry.rbe_color; if (child<br>) (child)-&gt;tree_entry.rbe_parent = parent; if (parent) { if<br> ((parent)-&gt;tree_entry.rbe_left == elm) (parent)-&gt;tree_entry<br>.rbe_left = child; else (parent)-&gt;tree_entry.rbe_right = child<br>; do {} while (0); } else (head)-&gt;rbh_root = child; if ((elm<br>)-&gt;tree_entry.rbe_parent == old) parent = elm; (elm)-&gt;tree_entry<br> = (old)-&gt;tree_entry; if ((old)-&gt;tree_entry.rbe_parent)<br> { if (((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> == old) ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = elm; else ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = elm; do {} while (0); } else (head)-&gt;rbh_root<br> = elm; ((old)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = elm; if ((old)-&gt;tree_entry.rbe_right) ((old)-&gt;tree_entry<br>.rbe_right)-&gt;tree_entry.rbe_parent = elm; if (parent) { left<br> = parent; do { do {} while (0); } while ((left = (left)-&gt;<br>tree_entry.rbe_parent) != ((void*)0)); } goto color; } parent<br> = (elm)-&gt;tree_entry.rbe_parent; color = (elm)-&gt;tree_entry<br>.rbe_color; if (child) (child)-&gt;tree_entry.rbe_parent = parent<br>; if (parent) { if ((parent)-&gt;tree_entry.rbe_left == elm) (<br>parent)-&gt;tree_entry.rbe_left = child; else (parent)-&gt;tree_entry<br>.rbe_right = child; do {} while (0); } else (head)-&gt;rbh_root<br> = child; color: if (color == 0) uv__signal_tree_s_RB_REMOVE_COLOR<br>(head, parent, child); return (old); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_INSERT(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp; struct uv_signal_s *parent = ((void*)0); int comp = 0;<br> tmp = (head)-&gt;rbh_root; while (tmp) { parent = tmp; comp =<br> (uv__signal_compare)(elm, parent); if (comp &lt; 0) tmp = (tmp<br>)-&gt;tree_entry.rbe_left; else if (comp &gt; 0) tmp = (tmp)-&gt;<br>tree_entry.rbe_right; else return (tmp); } do { (elm)-&gt;tree_entry<br>.rbe_parent = parent; (elm)-&gt;tree_entry.rbe_left = (elm)-&gt;<br>tree_entry.rbe_right = ((void*)0); (elm)-&gt;tree_entry.rbe_color<br> = 1; } while ( 0); if (parent != ((void*)0)) { if (comp &lt;<br> 0) (parent)-&gt;tree_entry.rbe_left = elm; else (parent)-&gt;<br>tree_entry.rbe_right = elm; do {} while (0); } else (head)-&gt;<br>rbh_root = elm; uv__signal_tree_s_RB_INSERT_COLOR(head, elm);<br> return (((void*)0)); } __attribute__((unused)) static struct<br> uv_signal_s * uv__signal_tree_s_RB_FIND(struct uv__signal_tree_s<br> *head, struct uv_signal_s *elm) { struct uv_signal_s *tmp = (<br>head)-&gt;rbh_root; int comp; while (tmp) { comp = uv__signal_compare<br>(elm, tmp); if (comp &lt; 0) tmp = (tmp)-&gt;tree_entry.rbe_left<br>; else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right;<br> else return (tmp); } return (((void*)0)); } __attribute__((unused<br>)) static struct uv_signal_s * uv__signal_tree_s_RB_NFIND(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *res = ((void<br>*)0); int comp; while (tmp) { comp = uv__signal_compare(elm, tmp<br>); if (comp &lt; 0) { res = tmp; tmp = (tmp)-&gt;tree_entry.rbe_left<br>; } else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right<br>; else return (tmp); } return (res); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_NEXT(struct<br> uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_right) { elm<br> = (elm)-&gt;tree_entry.rbe_right; while ((elm)-&gt;tree_entry<br>.rbe_left) elm = (elm)-&gt;tree_entry.rbe_left; } else { if (<br>(elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;<br>tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry.rbe_parent<br> &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right)) elm = (elm)-&gt;tree_entry.rbe_parent; elm = (elm<br>)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_PREV<br>(struct uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_left<br>) { elm = (elm)-&gt;tree_entry.rbe_left; while ((elm)-&gt;tree_entry<br>.rbe_right) elm = (elm)-&gt;tree_entry.rbe_right; } else { if<br> ((elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_right)) elm = (elm)<br>-&gt;tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry<br>.rbe_parent &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;tree_entry.rbe_parent<br>; elm = (elm)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_MINMAX<br>(struct uv__signal_tree_s *head, int val) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *parent = ((void<br>*)0); while (tmp) { parent = tmp; if (val &lt; 0) tmp = (tmp)<br>-&gt;tree_entry.rbe_left; else tmp = (tmp)-&gt;tree_entry.rbe_right<br>; } return (parent); }</span></span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line">                   <span class='macro'>uv__signal_compare)<span class='expansion'>__attribute__((unused)) static void uv__signal_tree_s_RB_INSERT_COLOR<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *parent, *gparent, *tmp; while ((parent = (elm)-&gt;<br>tree_entry.rbe_parent) != ((void*)0) &amp;&amp; (parent)-&gt;<br>tree_entry.rbe_color == 1) { gparent = (parent)-&gt;tree_entry<br>.rbe_parent; if (parent == (gparent)-&gt;tree_entry.rbe_left)<br> { tmp = (gparent)-&gt;tree_entry.rbe_right; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_right == elm) { do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_left; if (((gparent)-&gt;<br>tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> else { tmp = (gparent)-&gt;tree_entry.rbe_left; if (tmp &amp;&amp;<br> (tmp)-&gt;tree_entry.rbe_color == 1) { (tmp)-&gt;tree_entry.<br>rbe_color = 0; do { (parent)-&gt;tree_entry.rbe_color = 0; (gparent<br>)-&gt;tree_entry.rbe_color = 1; } while ( 0); elm = gparent; continue<br>; } if ((parent)-&gt;tree_entry.rbe_left == elm) { do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = parent; parent<br> = elm; elm = tmp; } do { (parent)-&gt;tree_entry.rbe_color =<br> 0; (gparent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do {<br> (tmp) = (gparent)-&gt;tree_entry.rbe_right; if (((gparent)-&gt;<br>tree_entry.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void<br>*)0)) { ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = (gparent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (gparent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if (<br>(gparent) == ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((gparent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((gparent)-&gt;tree_entry.rbe_parent)<br>-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_left = (gparent); (gparent<br>)-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); }<br> } (head-&gt;rbh_root)-&gt;tree_entry.rbe_color = 0; } __attribute__<br>((unused)) static void uv__signal_tree_s_RB_REMOVE_COLOR(struct<br> uv__signal_tree_s *head, struct uv_signal_s *parent, struct uv_signal_s<br> *elm) { struct uv_signal_s *tmp; while ((elm == ((void*)0) ||<br> (elm)-&gt;tree_entry.rbe_color == 0) &amp;&amp; elm != (head<br>)-&gt;rbh_root) { if ((parent)-&gt;tree_entry.rbe_left == elm<br>) { tmp = (parent)-&gt;tree_entry.rbe_right; if ((tmp)-&gt;tree_entry<br>.rbe_color == 1) { do { (tmp)-&gt;tree_entry.rbe_color = 0; (<br>parent)-&gt;tree_entry.rbe_color = 1; } while ( 0); do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); tmp = (parent)-&gt;<br>tree_entry.rbe_right; } if (((tmp)-&gt;tree_entry.rbe_left ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry<br>.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right ==<br> ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_right == ((void*)0) || ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color == 0) { struct<br> uv_signal_s *oleft; if ((oleft = (tmp)-&gt;tree_entry.rbe_left<br>) != ((void*)0)) (oleft)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;<br>tree_entry.rbe_color = 1; do { (oleft) = (tmp)-&gt;tree_entry<br>.rbe_left; if (((tmp)-&gt;tree_entry.rbe_left = (oleft)-&gt;tree_entry<br>.rbe_right) != ((void*)0)) { ((oleft)-&gt;tree_entry.rbe_right<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oleft)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oleft); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oleft); } else (head)-&gt;rbh_root<br> = (oleft); (oleft)-&gt;tree_entry.rbe_right = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oleft); do {} while (0); if (((oleft<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_right; } (tmp)-&gt;tree_entry.<br>rbe_color = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_right) ((tmp)-&gt;<br>tree_entry.rbe_right)-&gt;tree_entry.rbe_color = 0; do { (tmp<br>) = (parent)-&gt;tree_entry.rbe_right; if (((parent)-&gt;tree_entry<br>.rbe_right = (tmp)-&gt;tree_entry.rbe_left) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent = (parent<br>); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent = (<br>parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((parent<br>) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br>) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp); (tmp)<br>-&gt;tree_entry.rbe_left = (parent); (parent)-&gt;tree_entry.<br>rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } else { tmp = (parent)-&gt;tree_entry.rbe_left<br>; if ((tmp)-&gt;tree_entry.rbe_color == 1) { do { (tmp)-&gt;tree_entry<br>.rbe_color = 0; (parent)-&gt;tree_entry.rbe_color = 1; } while<br> ( 0); do { (tmp) = (parent)-&gt;tree_entry.rbe_left; if (((parent<br>)-&gt;tree_entry.rbe_left = (tmp)-&gt;tree_entry.rbe_right) !=<br> ((void*)0)) { ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_parent = (parent); } do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent = (parent)-&gt;tree_entry.rbe_parent) != ((void*)<br>0)) { if ((parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root<br> = (tmp); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)<br>-&gt;tree_entry.rbe_parent = (tmp); do {} while (0); if (((tmp<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } if (((tmp)-&gt;tree_entry<br>.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_left)-&gt;<br>tree_entry.rbe_color == 0) &amp;&amp; ((tmp)-&gt;tree_entry.rbe_right<br> == ((void*)0) || ((tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry<br>.rbe_color == 0)) { (tmp)-&gt;tree_entry.rbe_color = 1; elm =<br> parent; parent = (elm)-&gt;tree_entry.rbe_parent; } else { if<br> ((tmp)-&gt;tree_entry.rbe_left == ((void*)0) || ((tmp)-&gt;tree_entry<br>.rbe_left)-&gt;tree_entry.rbe_color == 0) { struct uv_signal_s<br> *oright; if ((oright = (tmp)-&gt;tree_entry.rbe_right) != ((<br>void*)0)) (oright)-&gt;tree_entry.rbe_color = 0; (tmp)-&gt;tree_entry<br>.rbe_color = 1; do { (oright) = (tmp)-&gt;tree_entry.rbe_right<br>; if (((tmp)-&gt;tree_entry.rbe_right = (oright)-&gt;tree_entry<br>.rbe_left) != ((void*)0)) { ((oright)-&gt;tree_entry.rbe_left<br>)-&gt;tree_entry.rbe_parent = (tmp); } do {} while (0); if ((<br>(oright)-&gt;tree_entry.rbe_parent = (tmp)-&gt;tree_entry.rbe_parent<br>) != ((void*)0)) { if ((tmp) == ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left) ((tmp)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_left = (oright); else ((tmp)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_right = (oright); } else (head)-&gt;rbh_root<br> = (oright); (oright)-&gt;tree_entry.rbe_left = (tmp); (tmp)-&gt;<br>tree_entry.rbe_parent = (oright); do {} while (0); if (((oright<br>)-&gt;tree_entry.rbe_parent)) do {} while (0); } while ( 0); tmp<br> = (parent)-&gt;tree_entry.rbe_left; } (tmp)-&gt;tree_entry.rbe_color<br> = (parent)-&gt;tree_entry.rbe_color; (parent)-&gt;tree_entry<br>.rbe_color = 0; if ((tmp)-&gt;tree_entry.rbe_left) ((tmp)-&gt;<br>tree_entry.rbe_left)-&gt;tree_entry.rbe_color = 0; do { (tmp)<br> = (parent)-&gt;tree_entry.rbe_left; if (((parent)-&gt;tree_entry<br>.rbe_left = (tmp)-&gt;tree_entry.rbe_right) != ((void*)0)) { (<br>(tmp)-&gt;tree_entry.rbe_right)-&gt;tree_entry.rbe_parent = (<br>parent); } do {} while (0); if (((tmp)-&gt;tree_entry.rbe_parent<br> = (parent)-&gt;tree_entry.rbe_parent) != ((void*)0)) { if ((<br>parent) == ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left) ((parent)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_left = (tmp); else ((parent)-&gt;tree_entry.rbe_parent)-&gt;<br>tree_entry.rbe_right = (tmp); } else (head)-&gt;rbh_root = (tmp<br>); (tmp)-&gt;tree_entry.rbe_right = (parent); (parent)-&gt;tree_entry<br>.rbe_parent = (tmp); do {} while (0); if (((tmp)-&gt;tree_entry<br>.rbe_parent)) do {} while (0); } while ( 0); elm = (head)-&gt;<br>rbh_root; break; } } } if (elm) (elm)-&gt;tree_entry.rbe_color<br> = 0; } __attribute__((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_REMOVE<br>(struct uv__signal_tree_s *head, struct uv_signal_s *elm) { struct<br> uv_signal_s *child, *parent, *old = elm; int color; if ((elm<br>)-&gt;tree_entry.rbe_left == ((void*)0)) child = (elm)-&gt;tree_entry<br>.rbe_right; else if ((elm)-&gt;tree_entry.rbe_right == ((void<br>*)0)) child = (elm)-&gt;tree_entry.rbe_left; else { struct uv_signal_s<br> *left; elm = (elm)-&gt;tree_entry.rbe_right; while ((left = (<br>elm)-&gt;tree_entry.rbe_left) != ((void*)0)) elm = left; child<br> = (elm)-&gt;tree_entry.rbe_right; parent = (elm)-&gt;tree_entry<br>.rbe_parent; color = (elm)-&gt;tree_entry.rbe_color; if (child<br>) (child)-&gt;tree_entry.rbe_parent = parent; if (parent) { if<br> ((parent)-&gt;tree_entry.rbe_left == elm) (parent)-&gt;tree_entry<br>.rbe_left = child; else (parent)-&gt;tree_entry.rbe_right = child<br>; do {} while (0); } else (head)-&gt;rbh_root = child; if ((elm<br>)-&gt;tree_entry.rbe_parent == old) parent = elm; (elm)-&gt;tree_entry<br> = (old)-&gt;tree_entry; if ((old)-&gt;tree_entry.rbe_parent)<br> { if (((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> == old) ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry.rbe_left<br> = elm; else ((old)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right = elm; do {} while (0); } else (head)-&gt;rbh_root<br> = elm; ((old)-&gt;tree_entry.rbe_left)-&gt;tree_entry.rbe_parent<br> = elm; if ((old)-&gt;tree_entry.rbe_right) ((old)-&gt;tree_entry<br>.rbe_right)-&gt;tree_entry.rbe_parent = elm; if (parent) { left<br> = parent; do { do {} while (0); } while ((left = (left)-&gt;<br>tree_entry.rbe_parent) != ((void*)0)); } goto color; } parent<br> = (elm)-&gt;tree_entry.rbe_parent; color = (elm)-&gt;tree_entry<br>.rbe_color; if (child) (child)-&gt;tree_entry.rbe_parent = parent<br>; if (parent) { if ((parent)-&gt;tree_entry.rbe_left == elm) (<br>parent)-&gt;tree_entry.rbe_left = child; else (parent)-&gt;tree_entry<br>.rbe_right = child; do {} while (0); } else (head)-&gt;rbh_root<br> = child; color: if (color == 0) uv__signal_tree_s_RB_REMOVE_COLOR<br>(head, parent, child); return (old); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_INSERT(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp; struct uv_signal_s *parent = ((void*)0); int comp = 0;<br> tmp = (head)-&gt;rbh_root; while (tmp) { parent = tmp; comp =<br> (uv__signal_compare)(elm, parent); if (comp &lt; 0) tmp = (tmp<br>)-&gt;tree_entry.rbe_left; else if (comp &gt; 0) tmp = (tmp)-&gt;<br>tree_entry.rbe_right; else return (tmp); } do { (elm)-&gt;tree_entry<br>.rbe_parent = parent; (elm)-&gt;tree_entry.rbe_left = (elm)-&gt;<br>tree_entry.rbe_right = ((void*)0); (elm)-&gt;tree_entry.rbe_color<br> = 1; } while ( 0); if (parent != ((void*)0)) { if (comp &lt;<br> 0) (parent)-&gt;tree_entry.rbe_left = elm; else (parent)-&gt;<br>tree_entry.rbe_right = elm; do {} while (0); } else (head)-&gt;<br>rbh_root = elm; uv__signal_tree_s_RB_INSERT_COLOR(head, elm);<br> return (((void*)0)); } __attribute__((unused)) static struct<br> uv_signal_s * uv__signal_tree_s_RB_FIND(struct uv__signal_tree_s<br> *head, struct uv_signal_s *elm) { struct uv_signal_s *tmp = (<br>head)-&gt;rbh_root; int comp; while (tmp) { comp = uv__signal_compare<br>(elm, tmp); if (comp &lt; 0) tmp = (tmp)-&gt;tree_entry.rbe_left<br>; else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right;<br> else return (tmp); } return (((void*)0)); } __attribute__((unused<br>)) static struct uv_signal_s * uv__signal_tree_s_RB_NFIND(struct<br> uv__signal_tree_s *head, struct uv_signal_s *elm) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *res = ((void<br>*)0); int comp; while (tmp) { comp = uv__signal_compare(elm, tmp<br>); if (comp &lt; 0) { res = tmp; tmp = (tmp)-&gt;tree_entry.rbe_left<br>; } else if (comp &gt; 0) tmp = (tmp)-&gt;tree_entry.rbe_right<br>; else return (tmp); } return (res); } __attribute__((unused)<br>) static struct uv_signal_s * uv__signal_tree_s_RB_NEXT(struct<br> uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_right) { elm<br> = (elm)-&gt;tree_entry.rbe_right; while ((elm)-&gt;tree_entry<br>.rbe_left) elm = (elm)-&gt;tree_entry.rbe_left; } else { if (<br>(elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;<br>tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry.rbe_parent<br> &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent)-&gt;tree_entry<br>.rbe_right)) elm = (elm)-&gt;tree_entry.rbe_parent; elm = (elm<br>)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_PREV<br>(struct uv_signal_s *elm) { if ((elm)-&gt;tree_entry.rbe_left<br>) { elm = (elm)-&gt;tree_entry.rbe_left; while ((elm)-&gt;tree_entry<br>.rbe_right) elm = (elm)-&gt;tree_entry.rbe_right; } else { if<br> ((elm)-&gt;tree_entry.rbe_parent &amp;&amp; (elm == ((elm)-&gt;<br>tree_entry.rbe_parent)-&gt;tree_entry.rbe_right)) elm = (elm)<br>-&gt;tree_entry.rbe_parent; else { while ((elm)-&gt;tree_entry<br>.rbe_parent &amp;&amp; (elm == ((elm)-&gt;tree_entry.rbe_parent<br>)-&gt;tree_entry.rbe_left)) elm = (elm)-&gt;tree_entry.rbe_parent<br>; elm = (elm)-&gt;tree_entry.rbe_parent; } } return (elm); } __attribute__<br>((unused)) static struct uv_signal_s * uv__signal_tree_s_RB_MINMAX<br>(struct uv__signal_tree_s *head, int val) { struct uv_signal_s<br> *tmp = (head)-&gt;rbh_root; struct uv_signal_s *parent = ((void<br>*)0); while (tmp) { parent = tmp; if (val &lt; 0) tmp = (tmp)<br>-&gt;tree_entry.rbe_left; else tmp = (tmp)-&gt;tree_entry.rbe_right<br>; } return (parent); }</span></span></td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"> </td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"> </td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_global_init(<span class='keyword'>void</span>) {</td></tr>
<tr><td class="num" id="LN58">58</td><td class="line">  <span class='keyword'>if</span> (uv__make_pipe(uv__signal_lock_pipefd, 0))</td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN60">60</td><td class="line"> </td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">  <span class='keyword'>if</span> (uv__signal_unlock())</td></tr>
<tr><td class="num" id="LN62">62</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN63">63</td><td class="line">}</td></tr>
<tr><td class="num" id="LN64">64</td><td class="line"> </td></tr>
<tr><td class="num" id="LN65">65</td><td class="line"> </td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"><span class='keyword'>void</span> uv__signal_global_once_init(<span class='keyword'>void</span>) {</td></tr>
<tr><td class="num" id="LN67">67</td><td class="line">  pthread_once(&amp;uv__signal_global_init_guard, uv__signal_global_init);</td></tr>
<tr><td class="num" id="LN68">68</td><td class="line">}</td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"> </td></tr>
<tr><td class="num" id="LN70">70</td><td class="line"> </td></tr>
<tr><td class="num" id="LN71">71</td><td class="line"> </td></tr>
<tr><td class="num" id="LN72">72</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_lock(<span class='keyword'>void</span>) {</td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">  <span class='keyword'>int</span> r;</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">  <span class='keyword'>char</span> data;</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line"> </td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">  <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line">    r = read(uv__signal_lock_pipefd[0], &amp;data, <span class='keyword'>sizeof</span> data);</td></tr>
<tr><td class="num" id="LN78">78</td><td class="line">  } <span class='keyword'>while</span> (r &lt; 0 &amp;&amp; <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EINTR<span class='expansion'>4</span></span>);</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"> </td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">  <span class='keyword'>return</span> (r &lt; 0) ? -1 : 0;</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">}</td></tr>
<tr><td class="num" id="LN82">82</td><td class="line"> </td></tr>
<tr><td class="num" id="LN83">83</td><td class="line"> </td></tr>
<tr><td class="num" id="LN84">84</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_unlock(<span class='keyword'>void</span>) {</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">  <span class='keyword'>int</span> r;</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">  <span class='keyword'>char</span> data = 42;</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line"> </td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">  <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">    r = write(uv__signal_lock_pipefd[1], &amp;data, <span class='keyword'>sizeof</span> data);</td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">  } <span class='keyword'>while</span> (r &lt; 0 &amp;&amp; <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EINTR<span class='expansion'>4</span></span>);</td></tr>
<tr><td class="num" id="LN91">91</td><td class="line"> </td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">  <span class='keyword'>return</span> (r &lt; 0) ? -1 : 0;</td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">}</td></tr>
<tr><td class="num" id="LN94">94</td><td class="line"> </td></tr>
<tr><td class="num" id="LN95">95</td><td class="line"> </td></tr>
<tr><td class="num" id="LN96">96</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_block_and_lock(sigset_t* saved_sigmask) {</td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">  sigset_t new_mask;</td></tr>
<tr><td class="num" id="LN98">98</td><td class="line"> </td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">  <span class='keyword'>if</span> (sigfillset(&amp;new_mask))</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN101">101</td><td class="line"> </td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">  <span class='keyword'>if</span> (pthread_sigmask(<span class='macro'>SIG_SETMASK<span class='expansion'>2</span></span>, &amp;new_mask, saved_sigmask))</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line"> </td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">  <span class='keyword'>if</span> (uv__signal_lock())</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">}</td></tr>
<tr><td class="num" id="LN108">108</td><td class="line"> </td></tr>
<tr><td class="num" id="LN109">109</td><td class="line"> </td></tr>
<tr><td class="num" id="LN110">110</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_unlock_and_unblock(sigset_t* saved_sigmask) {</td></tr>
<tr><td class="num" id="LN111">111</td><td class="line">  <span class='keyword'>if</span> (uv__signal_unlock())</td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN113">113</td><td class="line"> </td></tr>
<tr><td class="num" id="LN114">114</td><td class="line">  <span class='keyword'>if</span> (pthread_sigmask(<span class='macro'>SIG_SETMASK<span class='expansion'>2</span></span>, saved_sigmask, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>))</td></tr>
<tr><td class="num" id="LN115">115</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">}</td></tr>
<tr><td class="num" id="LN117">117</td><td class="line"> </td></tr>
<tr><td class="num" id="LN118">118</td><td class="line"> </td></tr>
<tr><td class="num" id="LN119">119</td><td class="line"><span class='keyword'>static</span> uv_signal_t* uv__signal_first_handle(<span class='keyword'>int</span> signum) {</td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">  <span class='comment'>/* This function must be called with the signal lock held. */</span></td></tr>
<tr><td class="num" id="LN121">121</td><td class="line">  uv_signal_t lookup;</td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">  uv_signal_t* handle;</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line"> </td></tr>
<tr><td class="num" id="LN124">124</td><td class="line">  lookup.signum = signum;</td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">  lookup.loop = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line"> </td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">  handle = <span class='macro'>RB_NFIND(uv__signal_tree_s, &amp;uv__signal_tree, &amp;lookup)<span class='expansion'>uv__signal_tree_s_RB_NFIND(&amp;uv__signal_tree, &amp;lookup)</span></span>;</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line"> </td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">  <span class='keyword'>if</span> (handle != <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> &amp;&amp; handle-&gt;signum == signum)</td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">    <span class='keyword'>return</span> handle;</td></tr>
<tr><td class="num" id="LN131">131</td><td class="line"> </td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">  <span class='keyword'>return</span> <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">}</td></tr>
<tr><td class="num" id="LN134">134</td><td class="line"> </td></tr>
<tr><td class="num" id="LN135">135</td><td class="line"> </td></tr>
<tr><td class="num" id="LN136">136</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_handler(<span class='keyword'>int</span> signum) {</td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">  uv__signal_msg_t msg;</td></tr>
<tr><td class="num" id="LN138">138</td><td class="line">  uv_signal_t* handle;</td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">  <span class='keyword'>int</span> saved_errno;</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line"> </td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">  saved_errno = <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span>;</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">  memset(&amp;msg, 0, <span class='keyword'>sizeof</span> msg);</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line"> </td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">  <span class='keyword'>if</span> (uv__signal_lock()) {</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">    <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> = saved_errno;</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"> </td></tr>
<tr><td class="num" id="LN149">149</td><td class="line">  <span class='keyword'>for</span> (handle = uv__signal_first_handle(signum);</td></tr>
<tr><td class="num" id="LN150">150</td><td class="line">       handle != <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span> &amp;&amp; handle-&gt;signum == signum;</td></tr>
<tr><td class="num" id="LN151">151</td><td class="line">       handle = <span class='macro'>RB_NEXT(uv__signal_tree_s, &amp;uv__signal_tree, handle)<span class='expansion'>uv__signal_tree_s_RB_NEXT(handle)</span></span>) {</td></tr>
<tr><td class="num" id="LN152">152</td><td class="line">    <span class='keyword'>int</span> r;</td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"> </td></tr>
<tr><td class="num" id="LN154">154</td><td class="line">    msg.signum = signum;</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line">    msg.handle = handle;</td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN157">157</td><td class="line">    <span class='comment'>/* write() should be atomic for small data chunks, so the entire message</span></td></tr>
<tr><td class="num" id="LN158">158</td><td class="line">     <span class='comment'>* should be written at once. In theory the pipe could become full, in</span></td></tr>
<tr><td class="num" id="LN159">159</td><td class="line">     <span class='comment'>* which case the user is out of luck.</span></td></tr>
<tr><td class="num" id="LN160">160</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">    <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">      r = write(handle-&gt;loop-&gt;signal_pipefd[1], &amp;msg, <span class='keyword'>sizeof</span> msg);</td></tr>
<tr><td class="num" id="LN163">163</td><td class="line">    } <span class='keyword'>while</span> (r == -1 &amp;&amp; <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EINTR<span class='expansion'>4</span></span>);</td></tr>
<tr><td class="num" id="LN164">164</td><td class="line"> </td></tr>
<tr><td class="num" id="LN165">165</td><td class="line">    <span class='macro'>assert(r == <span class='keyword'>sizeof</span> msg ||<span class='expansion'>((r == sizeof msg || (r == -1 &amp;&amp; ((*__errno_location (<br>)) == 11 || (*__errno_location ()) == 11))) ? (void) (0) : __assert_fail<br> ("r == sizeof msg || (r == -1 &amp;&amp; ((*__errno_location ()) == 11 || (*__errno_location ()) == 11))"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 166, __PRETTY_FUNCTION__))</span></span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line">           <span class='macro'>(r == -1 &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)))<span class='expansion'>((r == sizeof msg || (r == -1 &amp;&amp; ((*__errno_location (<br>)) == 11 || (*__errno_location ()) == 11))) ? (void) (0) : __assert_fail<br> ("r == sizeof msg || (r == -1 &amp;&amp; ((*__errno_location ()) == 11 || (*__errno_location ()) == 11))"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 166, __PRETTY_FUNCTION__))</span></span>;</td></tr>
<tr><td class="num" id="LN167">167</td><td class="line"> </td></tr>
<tr><td class="num" id="LN168">168</td><td class="line">    <span class='keyword'>if</span> (r != -1)</td></tr>
<tr><td class="num" id="LN169">169</td><td class="line">      handle-&gt;caught_signals++;</td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line"> </td></tr>
<tr><td class="num" id="LN172">172</td><td class="line">  uv__signal_unlock();</td></tr>
<tr><td class="num" id="LN173">173</td><td class="line">  <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> = saved_errno;</td></tr>
<tr><td class="num" id="LN174">174</td><td class="line">}</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line"> </td></tr>
<tr><td class="num" id="LN176">176</td><td class="line"> </td></tr>
<tr><td class="num" id="LN177">177</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_register_handler(<span class='keyword'>int</span> signum) {</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">  <span class='comment'>/* When this function is called, the signal lock must be held. */</span></td></tr>
<tr><td class="num" id="LN179">179</td><td class="line">  <span class='keyword'>struct</span> sigaction sa;</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line"> </td></tr>
<tr><td class="num" id="LN181">181</td><td class="line">  <span class='comment'>/* XXX use a separate signal stack? */</span></td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">  memset(&amp;sa, 0, <span class='keyword'>sizeof</span>(sa));</td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">  <span class='keyword'>if</span> (sigfillset(&amp;sa.sa_mask))</td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">  sa.<span class='macro'>sa_handler<span class='expansion'>__sigaction_handler.sa_handler</span></span> = uv__signal_handler;</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line"> </td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">  <span class='comment'>/* XXX save old action so we can restore it later on? */</span></td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">  <span class='keyword'>if</span> (sigaction(signum, &amp;sa, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>))</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">    <span class='keyword'>return</span> -<span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span>;</td></tr>
<tr><td class="num" id="LN190">190</td><td class="line"> </td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">}</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"> </td></tr>
<tr><td class="num" id="LN195">195</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_unregister_handler(<span class='keyword'>int</span> signum) {</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">  <span class='comment'>/* When this function is called, the signal lock must be held. */</span></td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">  <span class='keyword'>struct</span> sigaction sa;</td></tr>
<tr><td class="num" id="LN198">198</td><td class="line"> </td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">  memset(&amp;sa, 0, <span class='keyword'>sizeof</span>(sa));</td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">  sa.<span class='macro'>sa_handler<span class='expansion'>__sigaction_handler.sa_handler</span></span> = <span class='macro'>SIG_DFL<span class='expansion'>((__sighandler_t) 0)</span></span>;</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line"> </td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">  <span class='comment'>/* sigaction can only fail with EINVAL or EFAULT; an attempt to deregister a</span></td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">   <span class='comment'>* signal implies that it was successfully registered earlier, so EINVAL</span></td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">   <span class='comment'>* should never happen.</span></td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">  <span class='keyword'>if</span> (sigaction(signum, &amp;sa, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>))</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">    abort();</td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">}</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line"> </td></tr>
<tr><td class="num" id="LN210">210</td><td class="line"> </td></tr>
<tr><td class="num" id="LN211">211</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_loop_once_init(uv_loop_t* loop) {</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">  <span class='keyword'>int</span> err;</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line"> </td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">  <span class='comment'>/* Return if already initialized. */</span></td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">  <span class='keyword'>if</span> (loop-&gt;signal_pipefd[0] != -1)</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line"> </td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">  err = uv__make_pipe(loop-&gt;signal_pipefd, <span class='macro'>UV__F_NONBLOCK<span class='expansion'>0x800</span></span>);</td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">  <span class='keyword'>if</span> (err)</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">    <span class='keyword'>return</span> err;</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line"> </td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">  uv__io_init(&amp;loop-&gt;signal_io_watcher,</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">              uv__signal_event,</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">              loop-&gt;signal_pipefd[0]);</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line">  uv__io_start(loop, &amp;loop-&gt;signal_io_watcher, <span class='macro'>UV__POLLIN<span class='expansion'>1</span></span>);</td></tr>
<tr><td class="num" id="LN226">226</td><td class="line"> </td></tr>
<tr><td class="num" id="LN227">227</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN228">228</td><td class="line">}</td></tr>
<tr><td class="num" id="LN229">229</td><td class="line"> </td></tr>
<tr><td class="num" id="LN230">230</td><td class="line"> </td></tr>
<tr><td class="num" id="LN231">231</td><td class="line"><span class='keyword'>void</span> uv__signal_loop_cleanup(uv_loop_t* loop) {</td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">  QUEUE* q;</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line"> </td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">  <span class='comment'>/* Stop all the signal watchers that are still attached to this loop. This</span></td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">   <span class='comment'>* ensures that the (shared) signal tree doesn't contain any invalid entries</span></td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">   <span class='comment'>* entries, and that signal handlers are removed when appropriate.</span></td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">  <span class='macro'>QUEUE_FOREACH(q, &amp;loop-&gt;handle_queue)<span class='expansion'>for ((q) = (*(QUEUE **) &amp;((*(&amp;loop-&gt;handle_queue))<br>[0])); (q) != (&amp;loop-&gt;handle_queue); (q) = (*(QUEUE **<br>) &amp;((*(q))[0])))</span></span> {</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">    uv_handle_t* handle = <span class='macro'>QUEUE_DATA(q, uv_handle_t, handle_queue)<span class='expansion'>((uv_handle_t *) ((char *) (q) - ((char *) &amp;((uv_handle_t<br> *) 0)-&gt;handle_queue)))</span></span>;</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line"> </td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">    <span class='keyword'>if</span> (handle-&gt;type == UV_SIGNAL)</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">      uv__signal_stop((uv_signal_t*) handle);</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line"> </td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">  <span class='keyword'>if</span> (loop-&gt;signal_pipefd[0] != -1) {</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">    uv__close(loop-&gt;signal_pipefd[0]);</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line">    loop-&gt;signal_pipefd[0] = -1;</td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN249">249</td><td class="line"> </td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">  <span class='keyword'>if</span> (loop-&gt;signal_pipefd[1] != -1) {</td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">    uv__close(loop-&gt;signal_pipefd[1]);</td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">    loop-&gt;signal_pipefd[1] = -1;</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">}</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line"> </td></tr>
<tr><td class="num" id="LN256">256</td><td class="line"> </td></tr>
<tr><td class="num" id="LN257">257</td><td class="line"><span class='keyword'>int</span> uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {</td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">  <span class='keyword'>int</span> err;</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line"> </td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">  err = uv__signal_loop_once_init(loop);</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">  <span class='keyword'>if</span> (err)</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">    <span class='keyword'>return</span> err;</td></tr>
<tr><td class="num" id="LN263">263</td><td class="line"> </td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">  <span class='macro'>uv__handle_init(loop, (uv_handle_t*) handle, UV_SIGNAL)<span class='expansion'>do { ((uv_handle_t*) handle)-&gt;loop = (loop); ((uv_handle_t<br>*) handle)-&gt;type = (UV_SIGNAL); ((uv_handle_t*) handle)-&gt;<br>flags = UV__HANDLE_REF; do { (*(QUEUE **) &amp;((*(&amp;((uv_handle_t<br>*) handle)-&gt;handle_queue))[0])) = (&amp;(loop)-&gt;handle_queue<br>); (*(QUEUE **) &amp;((*(&amp;((uv_handle_t*) handle)-&gt;handle_queue<br>))[1])) = (*(QUEUE **) &amp;((*(&amp;(loop)-&gt;handle_queue)<br>)[1])); ((*(QUEUE **) &amp;((*((*(QUEUE **) &amp;((*(&amp;((uv_handle_t<br>*) handle)-&gt;handle_queue))[1]))))[0]))) = (&amp;((uv_handle_t<br>*) handle)-&gt;handle_queue); (*(QUEUE **) &amp;((*(&amp;(loop<br>)-&gt;handle_queue))[1])) = (&amp;((uv_handle_t*) handle)-&gt;<br>handle_queue); } while (0); (((uv_handle_t*) handle)-&gt;next_closing<br> = ((void*)0)); } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line">  handle-&gt;signum = 0;</td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">  handle-&gt;caught_signals = 0;</td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">  handle-&gt;dispatched_signals = 0;</td></tr>
<tr><td class="num" id="LN268">268</td><td class="line"> </td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">}</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line"> </td></tr>
<tr><td class="num" id="LN272">272</td><td class="line"> </td></tr>
<tr><td class="num" id="LN273">273</td><td class="line"><span class='keyword'>void</span> uv__signal_close(uv_signal_t* handle) {</td></tr>
<tr><td class="num" id="LN274">274</td><td class="line"> </td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">  uv__signal_stop(handle);</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line"> </td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">  <span class='comment'>/* If there are any caught signals "trapped" in the signal pipe, we can't</span></td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">   <span class='comment'>* call the close callback yet. Otherwise, add the handle to the finish_close</span></td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">   <span class='comment'>* queue.</span></td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">  <span class='keyword'>if</span> (handle-&gt;caught_signals == handle-&gt;dispatched_signals) {</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">    uv__make_close_pending((uv_handle_t*) handle);</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN284">284</td><td class="line">}</td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"> </td></tr>
<tr><td class="num" id="LN286">286</td><td class="line"> </td></tr>
<tr><td class="num" id="LN287">287</td><td class="line"><span class='keyword'>int</span> uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, <span class='keyword'>int</span> signum) {</td></tr>
<tr><td class="num" id="LN288">288</td><td class="line">  sigset_t saved_sigmask;</td></tr>
<tr><td class="num" id="LN289">289</td><td class="line">  <span class='keyword'>int</span> err;</td></tr>
<tr><td class="num" id="LN290">290</td><td class="line"> </td></tr>
<tr><td class="num" id="LN291">291</td><td class="line">  <span class='macro'>assert(!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED)))<span class='expansion'>((!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED))) ? (void<br>) (0) : __assert_fail ("!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED))"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 291, __PRETTY_FUNCTION__))</span></span>;</td></tr>
<tr><td class="num" id="LN292">292</td><td class="line"> </td></tr>
<tr><td class="num" id="LN293">293</td><td class="line">  <span class='comment'>/* If the user supplies signum == 0, then return an error already. If the</span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line">   <span class='comment'>* signum is otherwise invalid then uv__signal_register will find out</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">   <span class='comment'>* eventually.</span></td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">  <span class='keyword'>if</span> (signum == 0)</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">    <span class='keyword'>return</span> -<span class='macro'>EINVAL<span class='expansion'>22</span></span>;</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line"> </td></tr>
<tr><td class="num" id="LN300">300</td><td class="line">  <span class='comment'>/* Short circuit: if the signal watcher is already watching {signum} don't</span></td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">   <span class='comment'>* go through the process of deregistering and registering the handler.</span></td></tr>
<tr><td class="num" id="LN302">302</td><td class="line">   <span class='comment'>* Additionally, this avoids pending signals getting lost in the small time</span></td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">   <span class='comment'>* time frame that handle-&gt;signum == 0.</span></td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">  <span class='keyword'>if</span> (signum == handle-&gt;signum) {</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">    handle-&gt;signal_cb = signal_cb;</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN309">309</td><td class="line"> </td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">  <span class='comment'>/* If the signal handler was already active, stop it first. */</span></td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">  <span class='keyword'>if</span> (handle-&gt;signum != 0) {</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">    uv__signal_stop(handle);</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line"> </td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">  uv__signal_block_and_lock(&amp;saved_sigmask);</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line"> </td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">  <span class='comment'>/* If at this point there are no active signal watchers for this signum (in</span></td></tr>
<tr><td class="num" id="LN318">318</td><td class="line">   <span class='comment'>* any of the loops), it's time to try and register a handler for it here.</span></td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">  <span class='keyword'>if</span> (uv__signal_first_handle(signum) == <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>) {</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">    err = uv__signal_register_handler(signum);</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">    <span class='keyword'>if</span> (err) {</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">      <span class='comment'>/* Registering the signal handler failed. Must be an invalid signal. */</span></td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">      uv__signal_unlock_and_unblock(&amp;saved_sigmask);</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">      <span class='keyword'>return</span> err;</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN328">328</td><td class="line"> </td></tr>
<tr><td class="num" id="LN329">329</td><td class="line">  handle-&gt;signum = signum;</td></tr>
<tr><td class="num" id="LN330">330</td><td class="line">  <span class='macro'>RB_INSERT(uv__signal_tree_s, &amp;uv__signal_tree, handle)<span class='expansion'>uv__signal_tree_s_RB_INSERT(&amp;uv__signal_tree, handle)</span></span>;</td></tr>
<tr><td class="num" id="LN331">331</td><td class="line"> </td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">  uv__signal_unlock_and_unblock(&amp;saved_sigmask);</td></tr>
<tr><td class="num" id="LN333">333</td><td class="line"> </td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">  handle-&gt;signal_cb = signal_cb;</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">  <span class='macro'>uv__handle_start(handle)<span class='expansion'>do { ((((handle)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0) ? (<br>void) (0) : __assert_fail ("((handle)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 335, __PRETTY_FUNCTION__)); if (((handle)-&gt;flags &amp; UV__HANDLE_ACTIVE<br>) != 0) break; (handle)-&gt;flags |= UV__HANDLE_ACTIVE; if ((<br>(handle)-&gt;flags &amp; UV__HANDLE_REF) != 0) do { (handle)-&gt;<br>loop-&gt;active_handles++; } while (0); } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line"> </td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">}</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line"> </td></tr>
<tr><td class="num" id="LN340">340</td><td class="line"> </td></tr>
<tr><td class="num" id="LN341">341</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_event(uv_loop_t* loop,</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">                             uv__io_t* w,</td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">                             <span class='keyword'>unsigned</span> <span class='keyword'>int</span> events) {</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">  uv__signal_msg_t* msg;</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">  uv_signal_t* handle;</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">  <span class='keyword'>char</span> buf[<span class='keyword'>sizeof</span>(uv__signal_msg_t) * 32];</td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">  size_t bytes, end, i;</td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">  <span class='keyword'>int</span> r;</td></tr>
<tr><td class="num" id="LN349">349</td><td class="line"> </td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">  bytes = 0;</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">  end = 0;</td></tr>
<tr><td class="num" id="LN352">352</td><td class="line"> </td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">  <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">    r = read(loop-&gt;signal_pipefd[0], buf + bytes, <span class='keyword'>sizeof</span>(buf) - bytes);</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line"> </td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">    <span class='keyword'>if</span> (r == -1 &amp;&amp; <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EINTR<span class='expansion'>4</span></span>)</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line"> </td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">    <span class='keyword'>if</span> (r == -1 &amp;&amp; (<span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EAGAIN<span class='expansion'>11</span></span> || <span class='macro'>errno<span class='expansion'>(*__errno_location ())</span></span> == <span class='macro'>EWOULDBLOCK<span class='expansion'>11</span></span>)) {</td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">      <span class='comment'>/* If there are bytes in the buffer already (which really is extremely</span></td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">       <span class='comment'>* unlikely if possible at all) we can't exit the function here. We'll</span></td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">       <span class='comment'>* spin until more bytes are read instead.</span></td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">       <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">      <span class='keyword'>if</span> (bytes &gt; 0)</td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">        <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN366">366</td><td class="line"> </td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">      <span class='comment'>/* Otherwise, there was nothing there. */</span></td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">      <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN370">370</td><td class="line"> </td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">    <span class='comment'>/* Other errors really should never happen. */</span></td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">    <span class='keyword'>if</span> (r == -1)</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">      abort();</td></tr>
<tr><td class="num" id="LN374">374</td><td class="line"> </td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">    bytes += r;</td></tr>
<tr><td class="num" id="LN376">376</td><td class="line"> </td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">    <span class='comment'>/* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */</span></td></tr>
<tr><td class="num" id="LN378">378</td><td class="line">    end = (bytes / <span class='keyword'>sizeof</span>(uv__signal_msg_t)) * <span class='keyword'>sizeof</span>(uv__signal_msg_t);</td></tr>
<tr><td class="num" id="LN379">379</td><td class="line"> </td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">    <span class='keyword'>for</span> (i = 0; i &lt; end; i += <span class='keyword'>sizeof</span>(uv__signal_msg_t)) {</td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">      msg = (uv__signal_msg_t*) (buf + i);</td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">      handle = msg-&gt;handle;</td></tr>
<tr><td class="num" id="LN383">383</td><td class="line"> </td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">      <span class='keyword'>if</span> (msg-&gt;signum == handle-&gt;signum) {</td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">        <span class='macro'>assert(!(handle-&gt;flags &amp; UV_CLOSING))<span class='expansion'>((!(handle-&gt;flags &amp; UV_CLOSING)) ? (void) (0) : __assert_fail<br> ("!(handle-&gt;flags &amp; UV_CLOSING)", "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 385, __PRETTY_FUNCTION__))</span></span>;</td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">        handle-&gt;signal_cb(handle, handle-&gt;signum);</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line"> </td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">      handle-&gt;dispatched_signals++;</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line"> </td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">      <span class='comment'>/* If uv_close was called while there were caught signals that were not</span></td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">       <span class='comment'>* yet dispatched, the uv__finish_close was deferred. Make close pending</span></td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">       <span class='comment'>* now if this has happened.</span></td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">       <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN395">395</td><td class="line">      <span class='keyword'>if</span> ((handle-&gt;flags &amp; UV_CLOSING) &amp;&amp;</td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">          (handle-&gt;caught_signals == handle-&gt;dispatched_signals)) {</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">        uv__make_close_pending((uv_handle_t*) handle);</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN399">399</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN400">400</td><td class="line"> </td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">    bytes -= end;</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line"> </td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">    <span class='comment'>/* If there are any "partial" messages left, move them to the start of the</span></td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">     <span class='comment'>* the buffer, and spin. This should not happen.</span></td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">     <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">    <span class='keyword'>if</span> (bytes) {</td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">      memmove(buf, buf + end, bytes);</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">  } <span class='keyword'>while</span> (end == <span class='keyword'>sizeof</span> buf);</td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">}</td></tr>
<tr><td class="num" id="LN412">412</td><td class="line"> </td></tr>
<tr><td class="num" id="LN413">413</td><td class="line"> </td></tr>
<tr><td class="num" id="LN414">414</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span> uv__signal_compare(uv_signal_t* w1, uv_signal_t* w2) {</td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">  <span class='comment'>/* Compare signums first so all watchers with the same signnum end up</span></td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">   <span class='comment'>* adjacent.</span></td></tr>
<tr><td class="num" id="LN417">417</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">  <span class='keyword'>if</span> (w1-&gt;signum &lt; w2-&gt;signum) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">  <span class='keyword'>if</span> (w1-&gt;signum &gt; w2-&gt;signum) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line"> </td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">  <span class='comment'>/* Sort by loop pointer, so we can easily look up the first item after</span></td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">   <span class='comment'>* { .signum = x, .loop = NULL }.</span></td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">  <span class='keyword'>if</span> (w1-&gt;loop &lt; w2-&gt;loop) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">  <span class='keyword'>if</span> (w1-&gt;loop &gt; w2-&gt;loop) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN426">426</td><td class="line"> </td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">  <span class='keyword'>if</span> (w1 &lt; w2) <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">  <span class='keyword'>if</span> (w1 &gt; w2) <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line"> </td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">}</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line"> </td></tr>
<tr><td class="num" id="LN433">433</td><td class="line"> </td></tr>
<tr><td class="num" id="LN434">434</td><td class="line"><span class='keyword'>int</span> uv_signal_stop(uv_signal_t* handle) {</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">  <span class='macro'>assert(!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED)))<span class='expansion'>((!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED))) ? (void<br>) (0) : __assert_fail ("!(handle-&gt;flags &amp; (UV_CLOSING | UV_CLOSED))"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 435, __PRETTY_FUNCTION__))</span></span>;</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">  uv__signal_stop(handle);</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">}</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line"> </td></tr>
<tr><td class="num" id="LN440">440</td><td class="line"> </td></tr>
<tr><td class="num" id="LN441">441</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span> uv__signal_stop(uv_signal_t* handle) {</td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">  uv_signal_t* removed_handle;</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">  sigset_t saved_sigmask;</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line"> </td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">  <span class='comment'>/* If the watcher wasn't started, this is a no-op. */</span></td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">  <span class='keyword'>if</span> (handle-&gt;signum == 0)</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line"> </td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">  uv__signal_block_and_lock(&amp;saved_sigmask);</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line"> </td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">  removed_handle = <span class='macro'>RB_REMOVE(uv__signal_tree_s, &amp;uv__signal_tree, handle)<span class='expansion'>uv__signal_tree_s_RB_REMOVE(&amp;uv__signal_tree, handle)</span></span>;</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">  <span class='macro'>assert(removed_handle == handle)<span class='expansion'>((removed_handle == handle) ? (void) (0) : __assert_fail ("removed_handle == handle"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 452, __PRETTY_FUNCTION__))</span></span>;</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">  (<span class='keyword'>void</span>) removed_handle;</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line"> </td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">  <span class='comment'>/* Check if there are other active signal watchers observing this signal. If</span></td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">   <span class='comment'>* not, unregister the signal handler.</span></td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">   <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">  <span class='keyword'>if</span> (uv__signal_first_handle(handle-&gt;signum) == <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>)</td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">    uv__signal_unregister_handler(handle-&gt;signum);</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line"> </td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">  uv__signal_unlock_and_unblock(&amp;saved_sigmask);</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line"> </td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">  handle-&gt;signum = 0;</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">  <span class='macro'>uv__handle_stop(handle)<span class='expansion'>do { ((((handle)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0) ? (<br>void) (0) : __assert_fail ("((handle)-&gt;flags &amp; UV__HANDLE_CLOSING) == 0"<br>, "/home/travis/build/neovim/bot-ci/build/neovim/.deps/build/src/libuv/src/unix/signal.c"<br>, 464, __PRETTY_FUNCTION__)); if (((handle)-&gt;flags &amp; UV__HANDLE_ACTIVE<br>) == 0) break; (handle)-&gt;flags &amp;= ~UV__HANDLE_ACTIVE; if<br> (((handle)-&gt;flags &amp; UV__HANDLE_REF) != 0) do { (handle<br>)-&gt;loop-&gt;active_handles--; } while (0); } while (0)</span></span>;</td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">}</td></tr>
</table></body></html>
