<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>marktree.h</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">#ifndef NVIM_MARKTREE_H</a>
<a name="ln2">#define NVIM_MARKTREE_H</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;stdbool.h&gt;</a>
<a name="ln6">#include &lt;stddef.h&gt;</a>
<a name="ln7">#include &lt;stdint.h&gt;</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;klib/kvec.h&quot;</a>
<a name="ln10">#include &quot;nvim/assert.h&quot;</a>
<a name="ln11">#include &quot;nvim/garray.h&quot;</a>
<a name="ln12">#include &quot;nvim/map.h&quot;</a>
<a name="ln13">#include &quot;nvim/pos.h&quot;</a>
<a name="ln14">#include &quot;nvim/types.h&quot;</a>
<a name="ln15">// only for debug functions:</a>
<a name="ln16">#include &quot;api/private/defs.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">struct mtnode_s;</a>
<a name="ln19"> </a>
<a name="ln20">#define MT_MAX_DEPTH 20</a>
<a name="ln21">#define MT_BRANCH_FACTOR 10</a>
<a name="ln22">// note max branch is actually 2*MT_BRANCH_FACTOR</a>
<a name="ln23">// and strictly this is ceil(log2(2*MT_BRANCH_FACTOR + 1))</a>
<a name="ln24">// as we need a pseudo-index for &quot;right before this node&quot;</a>
<a name="ln25">#define MT_LOG2_BRANCH 5</a>
<a name="ln26"> </a>
<a name="ln27">typedef struct {</a>
<a name="ln28">  int32_t row;</a>
<a name="ln29">  int32_t col;</a>
<a name="ln30">} MTPos;</a>
<a name="ln31">#define MTPos(r, c) ((MTPos){ .row = (r), .col = (c) })</a>
<a name="ln32"> </a>
<a name="ln33">typedef struct mtnode_s MTNode;</a>
<a name="ln34"> </a>
<a name="ln35">typedef struct {</a>
<a name="ln36">  MTPos pos;</a>
<a name="ln37">  int lvl;</a>
<a name="ln38">  MTNode *x;</a>
<a name="ln39">  int i;</a>
<a name="ln40">  struct {</a>
<a name="ln41">    int oldcol;</a>
<a name="ln42">    int i;</a>
<a name="ln43">  } s[MT_MAX_DEPTH];</a>
<a name="ln44"> </a>
<a name="ln45">  size_t intersect_idx;</a>
<a name="ln46">  MTPos intersect_pos;</a>
<a name="ln47">  MTPos intersect_pos_x;</a>
<a name="ln48">} MarkTreeIter;</a>
<a name="ln49"> </a>
<a name="ln50">#define marktree_itr_valid(itr) ((itr)-&gt;x != NULL)</a>
<a name="ln51"> </a>
<a name="ln52">// Internal storage</a>
<a name="ln53">//</a>
<a name="ln54">// NB: actual marks have flags &gt; 0, so we can use (row,col,0) pseudo-key for</a>
<a name="ln55">// &quot;space before (row,col)&quot;</a>
<a name="ln56">typedef struct {</a>
<a name="ln57">  MTPos pos;</a>
<a name="ln58">  uint32_t ns;</a>
<a name="ln59">  uint32_t id;</a>
<a name="ln60">  int32_t hl_id;</a>
<a name="ln61">  uint16_t flags;</a>
<a name="ln62">  uint16_t priority;</a>
<a name="ln63">  Decoration *decor_full;</a>
<a name="ln64">} MTKey;</a>
<a name="ln65"> </a>
<a name="ln66">typedef struct {</a>
<a name="ln67">  MTKey start;</a>
<a name="ln68">  MTPos end_pos;</a>
<a name="ln69">  bool end_right_gravity;</a>
<a name="ln70">} MTPair;</a>
<a name="ln71"> </a>
<a name="ln72">#define MT_INVALID_KEY (MTKey) { { -1, -1 }, 0, 0, 0, 0, 0, NULL }</a>
<a name="ln73"> </a>
<a name="ln74">#define MT_FLAG_REAL (((uint16_t)1) &lt;&lt; 0)</a>
<a name="ln75">#define MT_FLAG_END (((uint16_t)1) &lt;&lt; 1)</a>
<a name="ln76">#define MT_FLAG_PAIRED (((uint16_t)1) &lt;&lt; 2)</a>
<a name="ln77">// orphaned: the other side of this paired mark was deleted. this mark must be deleted very soon!</a>
<a name="ln78">#define MT_FLAG_ORPHANED (((uint16_t)1) &lt;&lt; 3)</a>
<a name="ln79">#define MT_FLAG_HL_EOL (((uint16_t)1) &lt;&lt; 4)</a>
<a name="ln80">#define MT_FLAG_NO_UNDO (((uint16_t)1) &lt;&lt; 5)</a>
<a name="ln81">#define MT_FLAG_INVALIDATE (((uint16_t)1) &lt;&lt; 6)</a>
<a name="ln82">#define MT_FLAG_INVALID (((uint16_t)1) &lt;&lt; 7)</a>
<a name="ln83"> </a>
<a name="ln84">#define DECOR_LEVELS 4</a>
<a name="ln85">#define MT_FLAG_DECOR_OFFSET 8</a>
<a name="ln86">#define MT_FLAG_DECOR_MASK (((uint16_t)(DECOR_LEVELS - 1)) &lt;&lt; MT_FLAG_DECOR_OFFSET)</a>
<a name="ln87"> </a>
<a name="ln88">// These _must_ be last to preserve ordering of marks</a>
<a name="ln89">#define MT_FLAG_RIGHT_GRAVITY (((uint16_t)1) &lt;&lt; 14)</a>
<a name="ln90">#define MT_FLAG_LAST (((uint16_t)1) &lt;&lt; 15)</a>
<a name="ln91"> </a>
<a name="ln92">#define MT_FLAG_EXTERNAL_MASK (MT_FLAG_DECOR_MASK | MT_FLAG_RIGHT_GRAVITY | MT_FLAG_HL_EOL \</a>
<a name="ln93">                               | MT_FLAG_NO_UNDO | MT_FLAG_INVALIDATE | MT_FLAG_INVALID)</a>
<a name="ln94"> </a>
<a name="ln95">// this is defined so that start and end of the same range have adjacent ids</a>
<a name="ln96">#define MARKTREE_END_FLAG ((uint64_t)1)</a>
<a name="ln97">static inline uint64_t mt_lookup_id(uint32_t ns, uint32_t id, bool enda)</a>
<a name="ln98">{</a>
<a name="ln99">  return (uint64_t)ns &lt;&lt; 33 | (id &lt;&lt;1) | (enda ? MARKTREE_END_FLAG : 0);</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static inline uint64_t mt_lookup_key_side(MTKey key, bool end)</a>
<a name="ln103">{</a>
<a name="ln104">  return mt_lookup_id(key.ns, key.id, end);</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">static inline uint64_t mt_lookup_key(MTKey key)</a>
<a name="ln108">{</a>
<a name="ln109">  return mt_lookup_id(key.ns, key.id, key.flags &amp; MT_FLAG_END);</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static inline bool mt_paired(MTKey key)</a>
<a name="ln113">{</a>
<a name="ln114">  return key.flags &amp; MT_FLAG_PAIRED;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static inline bool mt_end(MTKey key)</a>
<a name="ln118">{</a>
<a name="ln119">  return key.flags &amp; MT_FLAG_END;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">static inline bool mt_start(MTKey key)</a>
<a name="ln123">{</a>
<a name="ln124">  return mt_paired(key) &amp;&amp; !mt_end(key);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static inline bool mt_right(MTKey key)</a>
<a name="ln128">{</a>
<a name="ln129">  return key.flags &amp; MT_FLAG_RIGHT_GRAVITY;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static inline bool mt_no_undo(MTKey key)</a>
<a name="ln133">{</a>
<a name="ln134">  return key.flags &amp; MT_FLAG_NO_UNDO;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static inline bool mt_invalidate(MTKey key)</a>
<a name="ln138">{</a>
<a name="ln139">  return key.flags &amp; MT_FLAG_INVALIDATE;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">static inline bool mt_invalid(MTKey key)</a>
<a name="ln143">{</a>
<a name="ln144">  return key.flags &amp; MT_FLAG_INVALID;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static inline uint8_t marktree_decor_level(MTKey key)</a>
<a name="ln148">{</a>
<a name="ln149">  return (uint8_t)((key.flags&amp;MT_FLAG_DECOR_MASK) &gt;&gt; MT_FLAG_DECOR_OFFSET);</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static inline uint16_t mt_flags(bool right_gravity, bool hl_eol, bool no_undo, bool invalidate,</a>
<a name="ln153">                                uint8_t decor_level)</a>
<a name="ln154">{</a>
<a name="ln155">  assert(decor_level &lt; DECOR_LEVELS);</a>
<a name="ln156">  return (uint16_t)((right_gravity ? MT_FLAG_RIGHT_GRAVITY : 0)</a>
<a name="ln157">                    | (hl_eol ? MT_FLAG_HL_EOL : 0)</a>
<a name="ln158">                    | (no_undo ? MT_FLAG_NO_UNDO : 0)</a>
<a name="ln159">                    | (invalidate ? MT_FLAG_INVALIDATE : 0)</a>
<a name="ln160">                    | (decor_level &lt;&lt; MT_FLAG_DECOR_OFFSET));</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">typedef kvec_withinit_t(uint64_t, 4) Intersection;</a>
<a name="ln164"> </a>
<a name="ln165">struct mtnode_s {</a>
<a name="ln166">  int32_t n;</a>
<a name="ln167">  int16_t level;</a>
<a name="ln168">  int16_t p_idx;  // index in parent</a>
<a name="ln169">  Intersection intersect;</a>
<a name="ln170">  // TODO(bfredl): we could consider having a only-sometimes-valid</a>
<a name="ln171">  // index into parent for faster &quot;cached&quot; lookup.</a>
<a name="ln172">  MTNode *parent;</a>
<a name="ln173">  MTKey key[2 * MT_BRANCH_FACTOR - 1];</a>
<a name="ln174">  MTNode *ptr[];</a>
<a name="ln175">};</a>
<a name="ln176"> </a>
<a name="ln177">static inline uint64_t mt_dbg_id(uint64_t id)</a>
<a name="ln178">{</a>
<a name="ln179">  return (id&gt;&gt;1)&amp;0xffffffff;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">typedef struct {</a>
<a name="ln183">  MTNode *root;</a>
<a name="ln184">  size_t n_keys, n_nodes;</a>
<a name="ln185">  // TODO(bfredl): the pointer to node could be part of the larger</a>
<a name="ln186">  // Map(uint64_t, ExtmarkItem) essentially;</a>
<a name="ln187">  PMap(uint64_t) id2node[1];</a>
<a name="ln188">} MarkTree;</a>
<a name="ln189"> </a>
<a name="ln190">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln191"># include &quot;marktree.h.generated.h&quot;</a>
<a name="ln192">#endif</a>
<a name="ln193"> </a>
<a name="ln194">#endif  // NVIM_MARKTREE_H</a>
</code></pre>
<div class="balloon" rel="99"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v629/" target="_blank">V629</a> Consider inspecting the 'id &lt;&lt; 1' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>