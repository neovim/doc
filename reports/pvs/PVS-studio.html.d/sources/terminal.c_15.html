<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>terminal.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// VT220/xterm-like terminal emulator.</a>
<a name="ln5">// Powered by libvterm http://www.leonerd.org.uk/code/libvterm</a>
<a name="ln6">//</a>
<a name="ln7">// libvterm is a pure C99 terminal emulation library with abstract input and</a>
<a name="ln8">// display. This means that the library needs to read data from the master fd</a>
<a name="ln9">// and feed VTerm instances, which will invoke user callbacks with screen</a>
<a name="ln10">// update instructions that must be mirrored to the real display.</a>
<a name="ln11">//</a>
<a name="ln12">// Keys are sent to VTerm instances by calling</a>
<a name="ln13">// vterm_keyboard_key/vterm_keyboard_unichar, which generates byte streams that</a>
<a name="ln14">// must be fed back to the master fd.</a>
<a name="ln15">//</a>
<a name="ln16">// Nvim buffers are used as the display mechanism for both the visible screen</a>
<a name="ln17">// and the scrollback buffer.</a>
<a name="ln18">//</a>
<a name="ln19">// When a line becomes invisible due to a decrease in screen height or because</a>
<a name="ln20">// a line was pushed up during normal terminal output, we store the line</a>
<a name="ln21">// information in the scrollback buffer, which is mirrored in the nvim buffer</a>
<a name="ln22">// by appending lines just above the visible part of the buffer.</a>
<a name="ln23">//</a>
<a name="ln24">// When the screen height increases, libvterm will ask for a row in the</a>
<a name="ln25">// scrollback buffer, which is mirrored in the nvim buffer displaying lines</a>
<a name="ln26">// that were previously invisible.</a>
<a name="ln27">//</a>
<a name="ln28">// The vterm-&gt;nvim synchronization is performed in intervals of 10 milliseconds,</a>
<a name="ln29">// to minimize screen updates when receiving large bursts of data.</a>
<a name="ln30">//</a>
<a name="ln31">// This module is decoupled from the processes that normally feed it data, so</a>
<a name="ln32">// it's possible to use it as a general purpose console buffer (possibly as a</a>
<a name="ln33">// log/display mechanism for nvim in the future)</a>
<a name="ln34">//</a>
<a name="ln35">// Inspired by: vimshell http://www.wana.at/vimshell</a>
<a name="ln36">//              Conque https://code.google.com/p/conque</a>
<a name="ln37">// Some code from pangoterm http://www.leonerd.org.uk/code/pangoterm</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;assert.h&gt;</a>
<a name="ln40">#include &lt;limits.h&gt;</a>
<a name="ln41">#include &lt;stdbool.h&gt;</a>
<a name="ln42">#include &lt;stdint.h&gt;</a>
<a name="ln43">#include &lt;stdio.h&gt;</a>
<a name="ln44">#include &lt;stdlib.h&gt;</a>
<a name="ln45">#include &lt;string.h&gt;</a>
<a name="ln46">#include &lt;vterm.h&gt;</a>
<a name="ln47">#include &lt;vterm_keycodes.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln50">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln51">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln52">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln53">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln54">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln55">#include &quot;nvim/change.h&quot;</a>
<a name="ln56">#include &quot;nvim/channel.h&quot;</a>
<a name="ln57">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln58">#include &quot;nvim/drawline.h&quot;</a>
<a name="ln59">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln60">#include &quot;nvim/eval.h&quot;</a>
<a name="ln61">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln62">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln63">#include &quot;nvim/event/time.h&quot;</a>
<a name="ln64">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln65">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln66">#include &quot;nvim/globals.h&quot;</a>
<a name="ln67">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln68">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln69">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln70">#include &quot;nvim/macros.h&quot;</a>
<a name="ln71">#include &quot;nvim/main.h&quot;</a>
<a name="ln72">#include &quot;nvim/map.h&quot;</a>
<a name="ln73">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln74">#include &quot;nvim/memline.h&quot;</a>
<a name="ln75">#include &quot;nvim/memory.h&quot;</a>
<a name="ln76">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln77">#include &quot;nvim/move.h&quot;</a>
<a name="ln78">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln79">#include &quot;nvim/normal.h&quot;</a>
<a name="ln80">#include &quot;nvim/ops.h&quot;</a>
<a name="ln81">#include &quot;nvim/option.h&quot;</a>
<a name="ln82">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln83">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln84">#include &quot;nvim/pos.h&quot;</a>
<a name="ln85">#include &quot;nvim/state.h&quot;</a>
<a name="ln86">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln87">#include &quot;nvim/types.h&quot;</a>
<a name="ln88">#include &quot;nvim/ui.h&quot;</a>
<a name="ln89">#include &quot;nvim/vim.h&quot;</a>
<a name="ln90"> </a>
<a name="ln91">typedef struct terminal_state {</a>
<a name="ln92">  VimState state;</a>
<a name="ln93">  Terminal *term;</a>
<a name="ln94">  int save_rd;              // saved value of RedrawingDisabled</a>
<a name="ln95">  bool close;</a>
<a name="ln96">  bool got_bsl;             // if the last input was &lt;C-\&gt;</a>
<a name="ln97">  bool got_bsl_o;           // if left terminal mode with &lt;c-\&gt;&lt;c-o&gt;</a>
<a name="ln98">} TerminalState;</a>
<a name="ln99"> </a>
<a name="ln100">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln101"># include &quot;terminal.c.generated.h&quot;</a>
<a name="ln102">#endif</a>
<a name="ln103"> </a>
<a name="ln104">// Delay for refreshing the terminal buffer after receiving updates from</a>
<a name="ln105">// libvterm. Improves performance when receiving large bursts of data.</a>
<a name="ln106">#define REFRESH_DELAY 10</a>
<a name="ln107"> </a>
<a name="ln108">static TimeWatcher refresh_timer;</a>
<a name="ln109">static bool refresh_pending = false;</a>
<a name="ln110"> </a>
<a name="ln111">typedef struct {</a>
<a name="ln112">  size_t cols;</a>
<a name="ln113">  VTermScreenCell cells[];</a>
<a name="ln114">} ScrollbackLine;</a>
<a name="ln115"> </a>
<a name="ln116">struct terminal {</a>
<a name="ln117">  TerminalOptions opts;  // options passed to terminal_open</a>
<a name="ln118">  VTerm *vt;</a>
<a name="ln119">  VTermScreen *vts;</a>
<a name="ln120">  // buffer used to:</a>
<a name="ln121">  //  - convert VTermScreen cell arrays into utf8 strings</a>
<a name="ln122">  //  - receive data from libvterm as a result of key presses.</a>
<a name="ln123">  char textbuf[0x1fff];</a>
<a name="ln124"> </a>
<a name="ln125">  ScrollbackLine **sb_buffer;       // Scrollback storage.</a>
<a name="ln126">  size_t sb_current;                // Lines stored in sb_buffer.</a>
<a name="ln127">  size_t sb_size;                   // Capacity of sb_buffer.</a>
<a name="ln128">  // &quot;virtual index&quot; that points to the first sb_buffer row that we need to</a>
<a name="ln129">  // push to the terminal buffer when refreshing the scrollback. When negative,</a>
<a name="ln130">  // it actually points to entries that are no longer in sb_buffer (because the</a>
<a name="ln131">  // window height has increased) and must be deleted from the terminal buffer</a>
<a name="ln132">  int sb_pending;</a>
<a name="ln133"> </a>
<a name="ln134">  char *title;     // VTermStringFragment buffer</a>
<a name="ln135">  size_t title_len;    // number of rows pushed to sb_buffer</a>
<a name="ln136">  size_t title_size;   // sb_buffer size</a>
<a name="ln137"> </a>
<a name="ln138">  // buf_T instance that acts as a &quot;drawing surface&quot; for libvterm</a>
<a name="ln139">  // we can't store a direct reference to the buffer because the</a>
<a name="ln140">  // refresh_timer_cb may be called after the buffer was freed, and there's</a>
<a name="ln141">  // no way to know if the memory was reused.</a>
<a name="ln142">  handle_T buf_handle;</a>
<a name="ln143">  // program exited</a>
<a name="ln144">  bool closed;</a>
<a name="ln145">  // when true, the terminal's destruction is already enqueued.</a>
<a name="ln146">  bool destroy;</a>
<a name="ln147"> </a>
<a name="ln148">  // some vterm properties</a>
<a name="ln149">  bool forward_mouse;</a>
<a name="ln150">  int invalid_start, invalid_end;   // invalid rows in libvterm screen</a>
<a name="ln151">  struct {</a>
<a name="ln152">    int row, col;</a>
<a name="ln153">    bool visible;</a>
<a name="ln154">  } cursor;</a>
<a name="ln155">  bool pending_resize;              // pending width/height</a>
<a name="ln156"> </a>
<a name="ln157">  bool color_set[16];</a>
<a name="ln158"> </a>
<a name="ln159">  size_t refcount;                  // reference count</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">static VTermScreenCallbacks vterm_screen_callbacks = {</a>
<a name="ln163">  .damage = term_damage,</a>
<a name="ln164">  .moverect = term_moverect,</a>
<a name="ln165">  .movecursor = term_movecursor,</a>
<a name="ln166">  .settermprop = term_settermprop,</a>
<a name="ln167">  .bell = term_bell,</a>
<a name="ln168">  .sb_pushline = term_sb_push,  // Called before a line goes offscreen.</a>
<a name="ln169">  .sb_popline = term_sb_pop,</a>
<a name="ln170">};</a>
<a name="ln171"> </a>
<a name="ln172">static Set(ptr_t) invalidated_terminals = SET_INIT;</a>
<a name="ln173"> </a>
<a name="ln174">void terminal_init(void)</a>
<a name="ln175">{</a>
<a name="ln176">  time_watcher_init(&amp;main_loop, &amp;refresh_timer, NULL);</a>
<a name="ln177">  // refresh_timer_cb will redraw the screen which can call vimscript</a>
<a name="ln178">  refresh_timer.events = multiqueue_new_child(main_loop.events);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">void terminal_teardown(void)</a>
<a name="ln182">{</a>
<a name="ln183">  time_watcher_stop(&amp;refresh_timer);</a>
<a name="ln184">  multiqueue_free(refresh_timer.events);</a>
<a name="ln185">  time_watcher_close(&amp;refresh_timer, NULL);</a>
<a name="ln186">  set_destroy(ptr_t, &amp;invalidated_terminals);</a>
<a name="ln187">  // terminal_destroy might be called after terminal_teardown is invoked</a>
<a name="ln188">  // make sure it is in an empty, valid state</a>
<a name="ln189">  invalidated_terminals = (Set(ptr_t)) SET_INIT;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">static void term_output_callback(const char *s, size_t len, void *user_data)</a>
<a name="ln193">{</a>
<a name="ln194">  terminal_send((Terminal *)user_data, (char *)s, len);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">// public API {{{</a>
<a name="ln198"> </a>
<a name="ln199">/// Initializes terminal properties, and triggers TermOpen.</a>
<a name="ln200">///</a>
<a name="ln201">/// The PTY process (TerminalOptions.data) was already started by termopen(),</a>
<a name="ln202">/// via ex_terminal() or the term:// BufReadCmd.</a>
<a name="ln203">///</a>
<a name="ln204">/// @param buf Buffer used for presentation of the terminal.</a>
<a name="ln205">/// @param opts PTY process channel, various terminal properties and callbacks.</a>
<a name="ln206">void terminal_open(Terminal **termpp, buf_T *buf, TerminalOptions opts)</a>
<a name="ln207">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln208">{</a>
<a name="ln209">  // Create a new terminal instance and configure it</a>
<a name="ln210">  Terminal *rv = *termpp = xcalloc(1, sizeof(Terminal));</a>
<a name="ln211">  rv-&gt;opts = opts;</a>
<a name="ln212">  rv-&gt;cursor.visible = true;</a>
<a name="ln213">  // Associate the terminal instance with the new buffer</a>
<a name="ln214">  rv-&gt;buf_handle = buf-&gt;handle;</a>
<a name="ln215">  buf-&gt;terminal = rv;</a>
<a name="ln216">  // Create VTerm</a>
<a name="ln217">  rv-&gt;vt = vterm_new(opts.height, opts.width);</a>
<a name="ln218">  vterm_set_utf8(rv-&gt;vt, 1);</a>
<a name="ln219">  // Setup state</a>
<a name="ln220">  VTermState *state = vterm_obtain_state(rv-&gt;vt);</a>
<a name="ln221">  // Set up screen</a>
<a name="ln222">  rv-&gt;vts = vterm_obtain_screen(rv-&gt;vt);</a>
<a name="ln223">  vterm_screen_enable_altscreen(rv-&gt;vts, true);</a>
<a name="ln224">  vterm_screen_enable_reflow(rv-&gt;vts, true);</a>
<a name="ln225">  // delete empty lines at the end of the buffer</a>
<a name="ln226">  vterm_screen_set_callbacks(rv-&gt;vts, &amp;vterm_screen_callbacks, rv);</a>
<a name="ln227">  vterm_screen_set_damage_merge(rv-&gt;vts, VTERM_DAMAGE_SCROLL);</a>
<a name="ln228">  vterm_screen_reset(rv-&gt;vts, 1);</a>
<a name="ln229">  vterm_output_set_callback(rv-&gt;vt, term_output_callback, rv);</a>
<a name="ln230">  // force a initial refresh of the screen to ensure the buffer will always</a>
<a name="ln231">  // have as many lines as screen rows when refresh_scrollback is called</a>
<a name="ln232">  rv-&gt;invalid_start = 0;</a>
<a name="ln233">  rv-&gt;invalid_end = opts.height;</a>
<a name="ln234"> </a>
<a name="ln235">  aco_save_T aco;</a>
<a name="ln236">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln237"> </a>
<a name="ln238">  refresh_screen(rv, buf);</a>
<a name="ln239">  set_option_value(&quot;buftype&quot;, STATIC_CSTR_AS_OPTVAL(&quot;terminal&quot;), OPT_LOCAL);  // -V666</a>
<a name="ln240"> </a>
<a name="ln241">  // Default settings for terminal buffers</a>
<a name="ln242">  buf-&gt;b_p_ma = false;     // 'nomodifiable'</a>
<a name="ln243">  buf-&gt;b_p_ul = -1;        // 'undolevels'</a>
<a name="ln244">  buf-&gt;b_p_scbk =          // 'scrollback' (initialize local from global)</a>
<a name="ln245">                  (p_scbk &lt; 0) ? 10000 : MAX(1, p_scbk);</a>
<a name="ln246">  buf-&gt;b_p_tw = 0;         // 'textwidth'</a>
<a name="ln247">  set_option_value(&quot;wrap&quot;, BOOLEAN_OPTVAL(false), OPT_LOCAL);</a>
<a name="ln248">  set_option_value(&quot;list&quot;, BOOLEAN_OPTVAL(false), OPT_LOCAL);</a>
<a name="ln249">  if (buf-&gt;b_ffname != NULL) {</a>
<a name="ln250">    buf_set_term_title(buf, buf-&gt;b_ffname, strlen(buf-&gt;b_ffname));</a>
<a name="ln251">  }</a>
<a name="ln252">  RESET_BINDING(curwin);</a>
<a name="ln253">  // Reset cursor in current window.</a>
<a name="ln254">  curwin-&gt;w_cursor = (pos_T){ .lnum = 1, .col = 0, .coladd = 0 };</a>
<a name="ln255">  // Initialize to check if the scrollback buffer has been allocated in a TermOpen autocmd.</a>
<a name="ln256">  rv-&gt;sb_buffer = NULL;</a>
<a name="ln257">  // Apply TermOpen autocmds _before_ configuring the scrollback buffer.</a>
<a name="ln258">  apply_autocmds(EVENT_TERMOPEN, NULL, NULL, false, buf);</a>
<a name="ln259"> </a>
<a name="ln260">  aucmd_restbuf(&amp;aco);</a>
<a name="ln261"> </a>
<a name="ln262">  if (*termpp == NULL) {  // -V547</a>
<a name="ln263">    return;  // Terminal has already been destroyed.</a>
<a name="ln264">  }</a>
<a name="ln265"> </a>
<a name="ln266">  if (rv-&gt;sb_buffer == NULL) {</a>
<a name="ln267">    // Local 'scrollback' _after_ autocmds.</a>
<a name="ln268">    if (buf-&gt;b_p_scbk &lt; 1) {</a>
<a name="ln269">      buf-&gt;b_p_scbk = SB_MAX;</a>
<a name="ln270">    }</a>
<a name="ln271">    // Configure the scrollback buffer.</a>
<a name="ln272">    rv-&gt;sb_size = (size_t)buf-&gt;b_p_scbk;</a>
<a name="ln273">    rv-&gt;sb_buffer = xmalloc(sizeof(ScrollbackLine *) * rv-&gt;sb_size);</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  // Configure the color palette. Try to get the color from:</a>
<a name="ln277">  //</a>
<a name="ln278">  // - b:terminal_color_{NUM}</a>
<a name="ln279">  // - g:terminal_color_{NUM}</a>
<a name="ln280">  // - the VTerm instance</a>
<a name="ln281">  for (int i = 0; i &lt; 16; i++) {</a>
<a name="ln282">    RgbValue color_val = -1;</a>
<a name="ln283">    char var[64];</a>
<a name="ln284">    snprintf(var, sizeof(var), &quot;terminal_color_%d&quot;, i);</a>
<a name="ln285">    char *name = get_config_string(var);</a>
<a name="ln286">    if (name) {</a>
<a name="ln287">      int dummy;</a>
<a name="ln288">      color_val = name_to_color(name, &amp;dummy);</a>
<a name="ln289">      xfree(name);</a>
<a name="ln290"> </a>
<a name="ln291">      if (color_val != -1) {</a>
<a name="ln292">        VTermColor color;</a>
<a name="ln293">        vterm_color_rgb(&amp;color,</a>
<a name="ln294">                        (uint8_t)((color_val &gt;&gt; 16) &amp; 0xFF),</a>
<a name="ln295">                        (uint8_t)((color_val &gt;&gt; 8) &amp; 0xFF),</a>
<a name="ln296">                        (uint8_t)((color_val &gt;&gt; 0) &amp; 0xFF));</a>
<a name="ln297">        vterm_state_set_palette_color(state, i, &amp;color);</a>
<a name="ln298">        rv-&gt;color_set[i] = true;</a>
<a name="ln299">      }</a>
<a name="ln300">    }</a>
<a name="ln301">  }</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">/// Closes the Terminal buffer.</a>
<a name="ln305">///</a>
<a name="ln306">/// May call terminal_destroy, which sets caller storage to NULL.</a>
<a name="ln307">void terminal_close(Terminal **termpp, int status)</a>
<a name="ln308">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln309">{</a>
<a name="ln310">  Terminal *term = *termpp;</a>
<a name="ln311">  if (term-&gt;destroy) {</a>
<a name="ln312">    return;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">#ifdef EXITFREE</a>
<a name="ln316">  if (entered_free_all_mem) {</a>
<a name="ln317">    // If called from close_buffer() inside free_all_mem(), the main loop has</a>
<a name="ln318">    // already been freed, so it is not safe to call the close callback here.</a>
<a name="ln319">    terminal_destroy(termpp);</a>
<a name="ln320">    return;</a>
<a name="ln321">  }</a>
<a name="ln322">#endif</a>
<a name="ln323"> </a>
<a name="ln324">  bool only_destroy = false;</a>
<a name="ln325"> </a>
<a name="ln326">  if (term-&gt;closed) {</a>
<a name="ln327">    // If called from close_buffer() after the process has already exited, we</a>
<a name="ln328">    // only need to call the close callback to clean up the terminal object.</a>
<a name="ln329">    only_destroy = true;</a>
<a name="ln330">  } else {</a>
<a name="ln331">    term-&gt;forward_mouse = false;</a>
<a name="ln332">    // flush any pending changes to the buffer</a>
<a name="ln333">    if (!exiting) {</a>
<a name="ln334">      block_autocmds();</a>
<a name="ln335">      refresh_terminal(term);</a>
<a name="ln336">      unblock_autocmds();</a>
<a name="ln337">    }</a>
<a name="ln338">    term-&gt;closed = true;</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  buf_T *buf = handle_get_buffer(term-&gt;buf_handle);</a>
<a name="ln342"> </a>
<a name="ln343">  if (status == -1 || exiting) {</a>
<a name="ln344">    // If this was called by close_buffer() (status is -1), or if exiting, we</a>
<a name="ln345">    // must inform the buffer the terminal no longer exists so that</a>
<a name="ln346">    // close_buffer() won't call this again.</a>
<a name="ln347">    // If inside Terminal mode K_EVENT handling, setting buf_handle to 0 also</a>
<a name="ln348">    // informs terminal_enter() to call the close callback before returning.</a>
<a name="ln349">    term-&gt;buf_handle = 0;</a>
<a name="ln350">    if (buf) {</a>
<a name="ln351">      buf-&gt;terminal = NULL;</a>
<a name="ln352">    }</a>
<a name="ln353">    if (!term-&gt;refcount) {</a>
<a name="ln354">      // Not inside Terminal mode K_EVENT handling.</a>
<a name="ln355">      // We should not wait for the user to press a key.</a>
<a name="ln356">      term-&gt;destroy = true;</a>
<a name="ln357">      term-&gt;opts.close_cb(term-&gt;opts.data);</a>
<a name="ln358">    }</a>
<a name="ln359">  } else if (!only_destroy) {</a>
<a name="ln360">    // Associated channel has been closed and the editor is not exiting.</a>
<a name="ln361">    // Do not call the close callback now. Wait for the user to press a key.</a>
<a name="ln362">    char msg[sizeof(&quot;\r\n[Process exited ]&quot;) + NUMBUFLEN];</a>
<a name="ln363">    if (((Channel *)term-&gt;opts.data)-&gt;streamtype == kChannelStreamInternal) {</a>
<a name="ln364">      snprintf(msg, sizeof msg, &quot;\r\n[Terminal closed]&quot;);</a>
<a name="ln365">    } else {</a>
<a name="ln366">      snprintf(msg, sizeof msg, &quot;\r\n[Process exited %d]&quot;, status);</a>
<a name="ln367">    }</a>
<a name="ln368">    terminal_receive(term, msg, strlen(msg));</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  if (only_destroy) {</a>
<a name="ln372">    return;</a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375">  if (buf &amp;&amp; !is_autocmd_blocked()) {</a>
<a name="ln376">    save_v_event_T save_v_event;</a>
<a name="ln377">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln378">    tv_dict_add_nr(dict, S_LEN(&quot;status&quot;), status);</a>
<a name="ln379">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln380">    apply_autocmds(EVENT_TERMCLOSE, NULL, NULL, false, buf);</a>
<a name="ln381">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln382">  }</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">void terminal_check_size(Terminal *term)</a>
<a name="ln386">{</a>
<a name="ln387">  if (term-&gt;closed) {</a>
<a name="ln388">    return;</a>
<a name="ln389">  }</a>
<a name="ln390"> </a>
<a name="ln391">  int curwidth, curheight;</a>
<a name="ln392">  vterm_get_size(term-&gt;vt, &amp;curheight, &amp;curwidth);</a>
<a name="ln393">  uint16_t width = 0, height = 0;</a>
<a name="ln394"> </a>
<a name="ln395">  // Check if there is a window that displays the terminal and find the maximum width and height.</a>
<a name="ln396">  // Skip the autocommand window which isn't actually displayed.</a>
<a name="ln397">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln398">    if (is_aucmd_win(wp)) {</a>
<a name="ln399">      continue;</a>
<a name="ln400">    }</a>
<a name="ln401">    if (wp-&gt;w_buffer &amp;&amp; wp-&gt;w_buffer-&gt;terminal == term) {</a>
<a name="ln402">      const uint16_t win_width =</a>
<a name="ln403">        (uint16_t)(MAX(0, wp-&gt;w_width_inner - win_col_off(wp)));</a>
<a name="ln404">      width = MAX(width, win_width);</a>
<a name="ln405">      height = (uint16_t)MAX(height, wp-&gt;w_height_inner);</a>
<a name="ln406">    }</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  // if no window displays the terminal, or such all windows are zero-height,</a>
<a name="ln410">  // don't resize the terminal.</a>
<a name="ln411">  if ((curheight == height &amp;&amp; curwidth == width) || height == 0 || width == 0) {</a>
<a name="ln412">    return;</a>
<a name="ln413">  }</a>
<a name="ln414"> </a>
<a name="ln415">  vterm_set_size(term-&gt;vt, height, width);</a>
<a name="ln416">  vterm_screen_flush_damage(term-&gt;vts);</a>
<a name="ln417">  term-&gt;pending_resize = true;</a>
<a name="ln418">  invalidate_terminal(term, -1, -1);</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">/// Implements MODE_TERMINAL state. :help Terminal-mode</a>
<a name="ln422">bool terminal_enter(void)</a>
<a name="ln423">{</a>
<a name="ln424">  buf_T *buf = curbuf;</a>
<a name="ln425">  assert(buf-&gt;terminal);  // Should only be called when curbuf has a terminal.</a>
<a name="ln426">  TerminalState s[1] = { 0 };</a>
<a name="ln427">  s-&gt;term = buf-&gt;terminal;</a>
<a name="ln428">  stop_insert_mode = false;</a>
<a name="ln429"> </a>
<a name="ln430">  // Ensure the terminal is properly sized. Ideally window size management</a>
<a name="ln431">  // code should always have resized the terminal already, but check here to</a>
<a name="ln432">  // be sure.</a>
<a name="ln433">  terminal_check_size(s-&gt;term);</a>
<a name="ln434"> </a>
<a name="ln435">  int save_state = State;</a>
<a name="ln436">  s-&gt;save_rd = RedrawingDisabled;</a>
<a name="ln437">  State = MODE_TERMINAL;</a>
<a name="ln438">  mapped_ctrl_c |= MODE_TERMINAL;  // Always map CTRL-C to avoid interrupt.</a>
<a name="ln439">  RedrawingDisabled = false;</a>
<a name="ln440"> </a>
<a name="ln441">  // Disable these options in terminal-mode. They are nonsense because cursor is</a>
<a name="ln442">  // placed at end of buffer to &quot;follow&quot; output. #11072</a>
<a name="ln443">  handle_T save_curwin = curwin-&gt;handle;</a>
<a name="ln444">  bool save_w_p_cul = curwin-&gt;w_p_cul;</a>
<a name="ln445">  char *save_w_p_culopt = NULL;</a>
<a name="ln446">  uint8_t save_w_p_culopt_flags = curwin-&gt;w_p_culopt_flags;</a>
<a name="ln447">  int save_w_p_cuc = curwin-&gt;w_p_cuc;</a>
<a name="ln448">  OptInt save_w_p_so = curwin-&gt;w_p_so;</a>
<a name="ln449">  OptInt save_w_p_siso = curwin-&gt;w_p_siso;</a>
<a name="ln450">  if (curwin-&gt;w_p_cul &amp;&amp; curwin-&gt;w_p_culopt_flags &amp; CULOPT_NBR) {</a>
<a name="ln451">    if (strcmp(curwin-&gt;w_p_culopt, &quot;number&quot;) != 0) {</a>
<a name="ln452">      save_w_p_culopt = curwin-&gt;w_p_culopt;</a>
<a name="ln453">      curwin-&gt;w_p_culopt = xstrdup(&quot;number&quot;);</a>
<a name="ln454">    }</a>
<a name="ln455">    curwin-&gt;w_p_culopt_flags = CULOPT_NBR;</a>
<a name="ln456">  } else {</a>
<a name="ln457">    curwin-&gt;w_p_cul = false;</a>
<a name="ln458">  }</a>
<a name="ln459">  curwin-&gt;w_p_cuc = false;</a>
<a name="ln460">  curwin-&gt;w_p_so = 0;</a>
<a name="ln461">  curwin-&gt;w_p_siso = 0;</a>
<a name="ln462"> </a>
<a name="ln463">  adjust_topline(s-&gt;term, buf, 0);  // scroll to end</a>
<a name="ln464">  // erase the unfocused cursor</a>
<a name="ln465">  invalidate_terminal(s-&gt;term, s-&gt;term-&gt;cursor.row, s-&gt;term-&gt;cursor.row + 1);</a>
<a name="ln466">  showmode();</a>
<a name="ln467">  curwin-&gt;w_redr_status = true;  // For mode() in statusline. #8323</a>
<a name="ln468">  ui_busy_start();</a>
<a name="ln469">  apply_autocmds(EVENT_TERMENTER, NULL, NULL, false, curbuf);</a>
<a name="ln470">  may_trigger_modechanged();</a>
<a name="ln471"> </a>
<a name="ln472">  s-&gt;state.execute = terminal_execute;</a>
<a name="ln473">  s-&gt;state.check = terminal_check;</a>
<a name="ln474">  state_enter(&amp;s-&gt;state);</a>
<a name="ln475"> </a>
<a name="ln476">  if (!s-&gt;got_bsl_o) {</a>
<a name="ln477">    restart_edit = 0;</a>
<a name="ln478">  }</a>
<a name="ln479">  State = save_state;</a>
<a name="ln480">  RedrawingDisabled = s-&gt;save_rd;</a>
<a name="ln481">  apply_autocmds(EVENT_TERMLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln482"> </a>
<a name="ln483">  if (save_curwin == curwin-&gt;handle) {  // Else: window was closed.</a>
<a name="ln484">    curwin-&gt;w_p_cul = save_w_p_cul;</a>
<a name="ln485">    if (save_w_p_culopt) {</a>
<a name="ln486">      free_string_option(curwin-&gt;w_p_culopt);</a>
<a name="ln487">      curwin-&gt;w_p_culopt = save_w_p_culopt;</a>
<a name="ln488">    }</a>
<a name="ln489">    curwin-&gt;w_p_culopt_flags = save_w_p_culopt_flags;</a>
<a name="ln490">    curwin-&gt;w_p_cuc = save_w_p_cuc;</a>
<a name="ln491">    curwin-&gt;w_p_so = save_w_p_so;</a>
<a name="ln492">    curwin-&gt;w_p_siso = save_w_p_siso;</a>
<a name="ln493">  } else if (save_w_p_culopt) {</a>
<a name="ln494">    free_string_option(save_w_p_culopt);</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  // draw the unfocused cursor</a>
<a name="ln498">  invalidate_terminal(s-&gt;term, s-&gt;term-&gt;cursor.row, s-&gt;term-&gt;cursor.row + 1);</a>
<a name="ln499">  if (curbuf-&gt;terminal == s-&gt;term &amp;&amp; !s-&gt;close) {</a>
<a name="ln500">    terminal_check_cursor();</a>
<a name="ln501">  }</a>
<a name="ln502">  if (restart_edit) {</a>
<a name="ln503">    showmode();</a>
<a name="ln504">  } else {</a>
<a name="ln505">    unshowmode(true);</a>
<a name="ln506">  }</a>
<a name="ln507">  ui_busy_stop();</a>
<a name="ln508">  if (s-&gt;close) {</a>
<a name="ln509">    bool wipe = s-&gt;term-&gt;buf_handle != 0;</a>
<a name="ln510">    s-&gt;term-&gt;destroy = true;</a>
<a name="ln511">    s-&gt;term-&gt;opts.close_cb(s-&gt;term-&gt;opts.data);</a>
<a name="ln512">    if (wipe) {</a>
<a name="ln513">      do_cmdline_cmd(&quot;bwipeout!&quot;);</a>
<a name="ln514">    }</a>
<a name="ln515">  }</a>
<a name="ln516"> </a>
<a name="ln517">  return s-&gt;got_bsl_o;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">static void terminal_check_cursor(void)</a>
<a name="ln521">{</a>
<a name="ln522">  Terminal *term = curbuf-&gt;terminal;</a>
<a name="ln523">  curwin-&gt;w_wrow = term-&gt;cursor.row;</a>
<a name="ln524">  curwin-&gt;w_wcol = term-&gt;cursor.col + win_col_off(curwin);</a>
<a name="ln525">  curwin-&gt;w_cursor.lnum = MIN(curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln526">                              row_to_linenr(term, term-&gt;cursor.row));</a>
<a name="ln527">  // Nudge cursor when returning to normal-mode.</a>
<a name="ln528">  int off = is_focused(term) ? 0 : (curwin-&gt;w_p_rl ? 1 : -1);</a>
<a name="ln529">  coladvance(MAX(0, term-&gt;cursor.col + off));</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">// Function executed before each iteration of terminal mode.</a>
<a name="ln533">// Return:</a>
<a name="ln534">//   1 if the iteration should continue normally</a>
<a name="ln535">//   0 if the main loop must exit</a>
<a name="ln536">static int terminal_check(VimState *state)</a>
<a name="ln537">{</a>
<a name="ln538">  if (stop_insert_mode) {</a>
<a name="ln539">    return 0;</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  terminal_check_cursor();</a>
<a name="ln543">  validate_cursor();</a>
<a name="ln544"> </a>
<a name="ln545">  if (must_redraw) {</a>
<a name="ln546">    update_screen();</a>
<a name="ln547"> </a>
<a name="ln548">    // Make sure an invoked autocmd doesn't delete the buffer (and the</a>
<a name="ln549">    // terminal) under our fingers.</a>
<a name="ln550">    curbuf-&gt;b_locked++;</a>
<a name="ln551"> </a>
<a name="ln552">    // save and restore curwin and curbuf, in case the autocmd changes them</a>
<a name="ln553">    aco_save_T aco;</a>
<a name="ln554">    aucmd_prepbuf(&amp;aco, curbuf);</a>
<a name="ln555">    apply_autocmds(EVENT_TEXTCHANGEDT, NULL, NULL, false, curbuf);</a>
<a name="ln556">    aucmd_restbuf(&amp;aco);</a>
<a name="ln557"> </a>
<a name="ln558">    curbuf-&gt;b_locked--;</a>
<a name="ln559">  }</a>
<a name="ln560"> </a>
<a name="ln561">  if (need_maketitle) {  // Update title in terminal-mode. #7248</a>
<a name="ln562">    maketitle();</a>
<a name="ln563">  }</a>
<a name="ln564"> </a>
<a name="ln565">  setcursor();</a>
<a name="ln566">  ui_flush();</a>
<a name="ln567">  return 1;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">/// Processes one char of terminal-mode input.</a>
<a name="ln571">static int terminal_execute(VimState *state, int key)</a>
<a name="ln572">{</a>
<a name="ln573">  TerminalState *s = (TerminalState *)state;</a>
<a name="ln574"> </a>
<a name="ln575">  switch (key) {</a>
<a name="ln576">  case K_LEFTMOUSE:</a>
<a name="ln577">  case K_LEFTDRAG:</a>
<a name="ln578">  case K_LEFTRELEASE:</a>
<a name="ln579">  case K_MOUSEMOVE:</a>
<a name="ln580">  case K_MIDDLEMOUSE:</a>
<a name="ln581">  case K_MIDDLEDRAG:</a>
<a name="ln582">  case K_MIDDLERELEASE:</a>
<a name="ln583">  case K_RIGHTMOUSE:</a>
<a name="ln584">  case K_RIGHTDRAG:</a>
<a name="ln585">  case K_RIGHTRELEASE:</a>
<a name="ln586">  case K_MOUSEDOWN:</a>
<a name="ln587">  case K_MOUSEUP:</a>
<a name="ln588">  case K_MOUSELEFT:</a>
<a name="ln589">  case K_MOUSERIGHT:</a>
<a name="ln590">    if (send_mouse_event(s-&gt;term, key)) {</a>
<a name="ln591">      return 0;</a>
<a name="ln592">    }</a>
<a name="ln593">    break;</a>
<a name="ln594"> </a>
<a name="ln595">  case K_EVENT:</a>
<a name="ln596">    // We cannot let an event free the terminal yet. It is still needed.</a>
<a name="ln597">    s-&gt;term-&gt;refcount++;</a>
<a name="ln598">    state_handle_k_event();</a>
<a name="ln599">    s-&gt;term-&gt;refcount--;</a>
<a name="ln600">    if (s-&gt;term-&gt;buf_handle == 0) {</a>
<a name="ln601">      s-&gt;close = true;</a>
<a name="ln602">      return 0;</a>
<a name="ln603">    }</a>
<a name="ln604">    break;</a>
<a name="ln605"> </a>
<a name="ln606">  case K_COMMAND:</a>
<a name="ln607">    do_cmdline(NULL, getcmdkeycmd, NULL, 0);</a>
<a name="ln608">    break;</a>
<a name="ln609"> </a>
<a name="ln610">  case K_LUA:</a>
<a name="ln611">    map_execute_lua(false);</a>
<a name="ln612">    break;</a>
<a name="ln613"> </a>
<a name="ln614">  case Ctrl_N:</a>
<a name="ln615">    if (s-&gt;got_bsl) {</a>
<a name="ln616">      return 0;</a>
<a name="ln617">    }</a>
<a name="ln618">    FALLTHROUGH;</a>
<a name="ln619"> </a>
<a name="ln620">  case Ctrl_O:</a>
<a name="ln621">    if (s-&gt;got_bsl) {</a>
<a name="ln622">      s-&gt;got_bsl_o = true;</a>
<a name="ln623">      restart_edit = 'I';</a>
<a name="ln624">      return 0;</a>
<a name="ln625">    }</a>
<a name="ln626">    FALLTHROUGH;</a>
<a name="ln627"> </a>
<a name="ln628">  default:</a>
<a name="ln629">    if (key == Ctrl_BSL &amp;&amp; !s-&gt;got_bsl) {</a>
<a name="ln630">      s-&gt;got_bsl = true;</a>
<a name="ln631">      break;</a>
<a name="ln632">    }</a>
<a name="ln633">    if (s-&gt;term-&gt;closed) {</a>
<a name="ln634">      s-&gt;close = true;</a>
<a name="ln635">      return 0;</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    s-&gt;got_bsl = false;</a>
<a name="ln639">    terminal_send_key(s-&gt;term, key);</a>
<a name="ln640">  }</a>
<a name="ln641"> </a>
<a name="ln642">  if (curbuf-&gt;terminal == NULL) {</a>
<a name="ln643">    return 0;</a>
<a name="ln644">  }</a>
<a name="ln645">  if (s-&gt;term != curbuf-&gt;terminal) {</a>
<a name="ln646">    invalidate_terminal(s-&gt;term, s-&gt;term-&gt;cursor.row, s-&gt;term-&gt;cursor.row + 1);</a>
<a name="ln647">    invalidate_terminal(curbuf-&gt;terminal,</a>
<a name="ln648">                        curbuf-&gt;terminal-&gt;cursor.row,</a>
<a name="ln649">                        curbuf-&gt;terminal-&gt;cursor.row + 1);</a>
<a name="ln650">    s-&gt;term = curbuf-&gt;terminal;</a>
<a name="ln651">  }</a>
<a name="ln652">  return 1;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">/// Frees the given Terminal structure and sets the caller storage to NULL (in the spirit of</a>
<a name="ln656">/// XFREE_CLEAR).</a>
<a name="ln657">void terminal_destroy(Terminal **termpp)</a>
<a name="ln658">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln659">{</a>
<a name="ln660">  Terminal *term = *termpp;</a>
<a name="ln661">  buf_T *buf = handle_get_buffer(term-&gt;buf_handle);</a>
<a name="ln662">  if (buf) {</a>
<a name="ln663">    term-&gt;buf_handle = 0;</a>
<a name="ln664">    buf-&gt;terminal = NULL;</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if (!term-&gt;refcount) {</a>
<a name="ln668">    if (set_has(ptr_t, &amp;invalidated_terminals, term)) {</a>
<a name="ln669">      // flush any pending changes to the buffer</a>
<a name="ln670">      block_autocmds();</a>
<a name="ln671">      refresh_terminal(term);</a>
<a name="ln672">      unblock_autocmds();</a>
<a name="ln673">      set_del(ptr_t, &amp;invalidated_terminals, term);</a>
<a name="ln674">    }</a>
<a name="ln675">    for (size_t i = 0; i &lt; term-&gt;sb_current; i++) {</a>
<a name="ln676">      xfree(term-&gt;sb_buffer[i]);</a>
<a name="ln677">    }</a>
<a name="ln678">    xfree(term-&gt;sb_buffer);</a>
<a name="ln679">    xfree(term-&gt;title);</a>
<a name="ln680">    vterm_free(term-&gt;vt);</a>
<a name="ln681">    xfree(term);</a>
<a name="ln682">    *termpp = NULL;  // coverity[dead-store]</a>
<a name="ln683">  }</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">void terminal_send(Terminal *term, char *data, size_t size)</a>
<a name="ln687">{</a>
<a name="ln688">  if (term-&gt;closed) {</a>
<a name="ln689">    return;</a>
<a name="ln690">  }</a>
<a name="ln691">  term-&gt;opts.write_cb(data, size, term-&gt;opts.data);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">static bool is_filter_char(int c)</a>
<a name="ln695">{</a>
<a name="ln696">  unsigned flag = 0;</a>
<a name="ln697">  switch (c) {</a>
<a name="ln698">  case 0x08:</a>
<a name="ln699">    flag = TPF_BS;</a>
<a name="ln700">    break;</a>
<a name="ln701">  case 0x09:</a>
<a name="ln702">    flag = TPF_HT;</a>
<a name="ln703">    break;</a>
<a name="ln704">  case 0x0A:</a>
<a name="ln705">  case 0x0D:</a>
<a name="ln706">    break;</a>
<a name="ln707">  case 0x0C:</a>
<a name="ln708">    flag = TPF_FF;</a>
<a name="ln709">    break;</a>
<a name="ln710">  case 0x1b:</a>
<a name="ln711">    flag = TPF_ESC;</a>
<a name="ln712">    break;</a>
<a name="ln713">  case 0x7F:</a>
<a name="ln714">    flag = TPF_DEL;</a>
<a name="ln715">    break;</a>
<a name="ln716">  default:</a>
<a name="ln717">    if (c &lt; ' ') {</a>
<a name="ln718">      flag = TPF_C0;</a>
<a name="ln719">    } else if (c &gt;= 0x80 &amp;&amp; c &lt;= 0x9F) {</a>
<a name="ln720">      flag = TPF_C1;</a>
<a name="ln721">    }</a>
<a name="ln722">  }</a>
<a name="ln723">  return !!(tpf_flags &amp; flag);</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">void terminal_paste(int count, char **y_array, size_t y_size)</a>
<a name="ln727">{</a>
<a name="ln728">  if (y_size == 0) {</a>
<a name="ln729">    return;</a>
<a name="ln730">  }</a>
<a name="ln731">  vterm_keyboard_start_paste(curbuf-&gt;terminal-&gt;vt);</a>
<a name="ln732">  size_t buff_len = strlen(y_array[0]);</a>
<a name="ln733">  char *buff = xmalloc(buff_len);</a>
<a name="ln734">  for (int i = 0; i &lt; count; i++) {  // -V756</a>
<a name="ln735">    // feed the lines to the terminal</a>
<a name="ln736">    for (size_t j = 0; j &lt; y_size; j++) {</a>
<a name="ln737">      if (j) {</a>
<a name="ln738">        // terminate the previous line</a>
<a name="ln739">#ifdef MSWIN</a>
<a name="ln740">        terminal_send(curbuf-&gt;terminal, &quot;\r\n&quot;, 2);</a>
<a name="ln741">#else</a>
<a name="ln742">        terminal_send(curbuf-&gt;terminal, &quot;\n&quot;, 1);</a>
<a name="ln743">#endif</a>
<a name="ln744">      }</a>
<a name="ln745">      size_t len = strlen(y_array[j]);</a>
<a name="ln746">      if (len &gt; buff_len) {</a>
<a name="ln747">        buff = xrealloc(buff, len);</a>
<a name="ln748">        buff_len = len;</a>
<a name="ln749">      }</a>
<a name="ln750">      char *dst = buff;</a>
<a name="ln751">      char *src = y_array[j];</a>
<a name="ln752">      while (*src != '\0') {</a>
<a name="ln753">        len = (size_t)utf_ptr2len(src);</a>
<a name="ln754">        int c = utf_ptr2char(src);</a>
<a name="ln755">        if (!is_filter_char(c)) {</a>
<a name="ln756">          memcpy(dst, src, len);</a>
<a name="ln757">          dst += len;</a>
<a name="ln758">        }</a>
<a name="ln759">        src += len;</a>
<a name="ln760">      }</a>
<a name="ln761">      terminal_send(curbuf-&gt;terminal, buff, (size_t)(dst - buff));</a>
<a name="ln762">    }</a>
<a name="ln763">  }</a>
<a name="ln764">  xfree(buff);</a>
<a name="ln765">  vterm_keyboard_end_paste(curbuf-&gt;terminal-&gt;vt);</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">void terminal_send_key(Terminal *term, int c)</a>
<a name="ln769">{</a>
<a name="ln770">  VTermModifier mod = VTERM_MOD_NONE;</a>
<a name="ln771"> </a>
<a name="ln772">  // Convert K_ZERO back to ASCII</a>
<a name="ln773">  if (c == K_ZERO) {</a>
<a name="ln774">    c = Ctrl_AT;</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  VTermKey key = convert_key(c, &amp;mod);</a>
<a name="ln778"> </a>
<a name="ln779">  if (key) {</a>
<a name="ln780">    vterm_keyboard_key(term-&gt;vt, key, mod);</a>
<a name="ln781">  } else if (!IS_SPECIAL(c)) {</a>
<a name="ln782">    vterm_keyboard_unichar(term-&gt;vt, (uint32_t)c, mod);</a>
<a name="ln783">  }</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">void terminal_receive(Terminal *term, char *data, size_t len)</a>
<a name="ln787">{</a>
<a name="ln788">  if (!data) {</a>
<a name="ln789">    return;</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  vterm_input_write(term-&gt;vt, data, len);</a>
<a name="ln793">  vterm_screen_flush_damage(term-&gt;vts);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">static int get_rgb(VTermState *state, VTermColor color)</a>
<a name="ln797">{</a>
<a name="ln798">  vterm_state_convert_color_to_rgb(state, &amp;color);</a>
<a name="ln799">  return RGB_(color.rgb.red, color.rgb.green, color.rgb.blue);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">static int get_underline_hl_flag(VTermScreenCellAttrs attrs)</a>
<a name="ln803">{</a>
<a name="ln804">  switch (attrs.underline) {</a>
<a name="ln805">  case VTERM_UNDERLINE_OFF:</a>
<a name="ln806">    return 0;</a>
<a name="ln807">  case VTERM_UNDERLINE_SINGLE:</a>
<a name="ln808">    return HL_UNDERLINE;</a>
<a name="ln809">  case VTERM_UNDERLINE_DOUBLE:</a>
<a name="ln810">    return HL_UNDERDOUBLE;</a>
<a name="ln811">  case VTERM_UNDERLINE_CURLY:</a>
<a name="ln812">    return HL_UNDERCURL;</a>
<a name="ln813">  default:</a>
<a name="ln814">    return HL_UNDERLINE;</a>
<a name="ln815">  }</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">void terminal_get_line_attributes(Terminal *term, win_T *wp, int linenr, int *term_attrs)</a>
<a name="ln819">{</a>
<a name="ln820">  int height, width;</a>
<a name="ln821">  vterm_get_size(term-&gt;vt, &amp;height, &amp;width);</a>
<a name="ln822">  VTermState *state = vterm_obtain_state(term-&gt;vt);</a>
<a name="ln823">  assert(linenr);</a>
<a name="ln824">  int row = linenr_to_row(term, linenr);</a>
<a name="ln825">  if (row &gt;= height) {</a>
<a name="ln826">    // Terminal height was decreased but the change wasn't reflected into the</a>
<a name="ln827">    // buffer yet</a>
<a name="ln828">    return;</a>
<a name="ln829">  }</a>
<a name="ln830"> </a>
<a name="ln831">  width = MIN(TERM_ATTRS_MAX, width);</a>
<a name="ln832">  for (int col = 0; col &lt; width; col++) {</a>
<a name="ln833">    VTermScreenCell cell;</a>
<a name="ln834">    bool color_valid = fetch_cell(term, row, col, &amp;cell);</a>
<a name="ln835">    bool fg_default = !color_valid || VTERM_COLOR_IS_DEFAULT_FG(&amp;cell.fg);</a>
<a name="ln836">    bool bg_default = !color_valid || VTERM_COLOR_IS_DEFAULT_BG(&amp;cell.bg);</a>
<a name="ln837"> </a>
<a name="ln838">    // Get the rgb value set by libvterm.</a>
<a name="ln839">    int vt_fg = fg_default ? -1 : get_rgb(state, cell.fg);</a>
<a name="ln840">    int vt_bg = bg_default ? -1 : get_rgb(state, cell.bg);</a>
<a name="ln841"> </a>
<a name="ln842">    bool fg_indexed = VTERM_COLOR_IS_INDEXED(&amp;cell.fg);</a>
<a name="ln843">    bool bg_indexed = VTERM_COLOR_IS_INDEXED(&amp;cell.bg);</a>
<a name="ln844"> </a>
<a name="ln845">    int vt_fg_idx = ((!fg_default &amp;&amp; fg_indexed) ? cell.fg.indexed.idx + 1 : 0);</a>
<a name="ln846">    int vt_bg_idx = ((!bg_default &amp;&amp; bg_indexed) ? cell.bg.indexed.idx + 1 : 0);</a>
<a name="ln847"> </a>
<a name="ln848">    bool fg_set = vt_fg_idx &amp;&amp; vt_fg_idx &lt;= 16 &amp;&amp; term-&gt;color_set[vt_fg_idx - 1];</a>
<a name="ln849">    bool bg_set = vt_bg_idx &amp;&amp; vt_bg_idx &lt;= 16 &amp;&amp; term-&gt;color_set[vt_bg_idx - 1];</a>
<a name="ln850"> </a>
<a name="ln851">    int hl_attrs = (cell.attrs.bold ? HL_BOLD : 0)</a>
<a name="ln852">                   | (cell.attrs.italic ? HL_ITALIC : 0)</a>
<a name="ln853">                   | (cell.attrs.reverse ? HL_INVERSE : 0)</a>
<a name="ln854">                   | get_underline_hl_flag(cell.attrs)</a>
<a name="ln855">                   | (cell.attrs.strike ? HL_STRIKETHROUGH : 0)</a>
<a name="ln856">                   | ((fg_indexed &amp;&amp; !fg_set) ? HL_FG_INDEXED : 0)</a>
<a name="ln857">                   | ((bg_indexed &amp;&amp; !bg_set) ? HL_BG_INDEXED : 0);</a>
<a name="ln858"> </a>
<a name="ln859">    int attr_id = 0;</a>
<a name="ln860"> </a>
<a name="ln861">    if (hl_attrs || !fg_default || !bg_default) {</a>
<a name="ln862">      attr_id = hl_get_term_attr(&amp;(HlAttrs) {</a>
<a name="ln863">        .cterm_ae_attr = (int16_t)hl_attrs,</a>
<a name="ln864">        .cterm_fg_color = vt_fg_idx,</a>
<a name="ln865">        .cterm_bg_color = vt_bg_idx,</a>
<a name="ln866">        .rgb_ae_attr = (int16_t)hl_attrs,</a>
<a name="ln867">        .rgb_fg_color = vt_fg,</a>
<a name="ln868">        .rgb_bg_color = vt_bg,</a>
<a name="ln869">        .rgb_sp_color = -1,</a>
<a name="ln870">        .hl_blend = -1,</a>
<a name="ln871">      });</a>
<a name="ln872">    }</a>
<a name="ln873"> </a>
<a name="ln874">    if (term-&gt;cursor.visible &amp;&amp; term-&gt;cursor.row == row</a>
<a name="ln875">        &amp;&amp; term-&gt;cursor.col == col) {</a>
<a name="ln876">      attr_id = hl_combine_attr(attr_id,</a>
<a name="ln877">                                is_focused(term) &amp;&amp; wp == curwin</a>
<a name="ln878">                                ? win_hl_attr(wp, HLF_TERM)</a>
<a name="ln879">                                : win_hl_attr(wp, HLF_TERMNC));</a>
<a name="ln880">    }</a>
<a name="ln881"> </a>
<a name="ln882">    term_attrs[col] = attr_id;</a>
<a name="ln883">  }</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">Buffer terminal_buf(const Terminal *term)</a>
<a name="ln887">{</a>
<a name="ln888">  return term-&gt;buf_handle;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">bool terminal_running(const Terminal *term)</a>
<a name="ln892">{</a>
<a name="ln893">  return !term-&gt;closed;</a>
<a name="ln894">}</a>
<a name="ln895"> </a>
<a name="ln896">// }}}</a>
<a name="ln897">// libvterm callbacks {{{</a>
<a name="ln898"> </a>
<a name="ln899">static int term_damage(VTermRect rect, void *data)</a>
<a name="ln900">{</a>
<a name="ln901">  invalidate_terminal(data, rect.start_row, rect.end_row);</a>
<a name="ln902">  return 1;</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">static int term_moverect(VTermRect dest, VTermRect src, void *data)</a>
<a name="ln906">{</a>
<a name="ln907">  invalidate_terminal(data, MIN(dest.start_row, src.start_row),</a>
<a name="ln908">                      MAX(dest.end_row, src.end_row));</a>
<a name="ln909">  return 1;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">static int term_movecursor(VTermPos new_pos, VTermPos old_pos, int visible, void *data)</a>
<a name="ln913">{</a>
<a name="ln914">  Terminal *term = data;</a>
<a name="ln915">  term-&gt;cursor.row = new_pos.row;</a>
<a name="ln916">  term-&gt;cursor.col = new_pos.col;</a>
<a name="ln917">  invalidate_terminal(term, old_pos.row, old_pos.row + 1);</a>
<a name="ln918">  invalidate_terminal(term, new_pos.row, new_pos.row + 1);</a>
<a name="ln919">  return 1;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">static void buf_set_term_title(buf_T *buf, const char *title, size_t len)</a>
<a name="ln923">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln924">{</a>
<a name="ln925">  Error err = ERROR_INIT;</a>
<a name="ln926">  dict_set_var(buf-&gt;b_vars,</a>
<a name="ln927">               STATIC_CSTR_AS_STRING(&quot;term_title&quot;),</a>
<a name="ln928">               STRING_OBJ(((String){ .data = (char *)title, .size = len })),</a>
<a name="ln929">               false,</a>
<a name="ln930">               false,</a>
<a name="ln931">               &amp;err);</a>
<a name="ln932">  api_clear_error(&amp;err);</a>
<a name="ln933">  status_redraw_buf(buf);</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">static int term_settermprop(VTermProp prop, VTermValue *val, void *data)</a>
<a name="ln937">{</a>
<a name="ln938">  Terminal *term = data;</a>
<a name="ln939"> </a>
<a name="ln940">  switch (prop) {</a>
<a name="ln941">  case VTERM_PROP_ALTSCREEN:</a>
<a name="ln942">    break;</a>
<a name="ln943"> </a>
<a name="ln944">  case VTERM_PROP_CURSORVISIBLE:</a>
<a name="ln945">    term-&gt;cursor.visible = val-&gt;boolean;</a>
<a name="ln946">    invalidate_terminal(term, term-&gt;cursor.row, term-&gt;cursor.row + 1);</a>
<a name="ln947">    break;</a>
<a name="ln948"> </a>
<a name="ln949">  case VTERM_PROP_TITLE: {</a>
<a name="ln950">    buf_T *buf = handle_get_buffer(term-&gt;buf_handle);</a>
<a name="ln951">    VTermStringFragment frag = val-&gt;string;</a>
<a name="ln952"> </a>
<a name="ln953">    if (frag.initial &amp;&amp; frag.final) {</a>
<a name="ln954">      buf_set_term_title(buf, frag.str, frag.len);</a>
<a name="ln955">      break;</a>
<a name="ln956">    }</a>
<a name="ln957"> </a>
<a name="ln958">    if (frag.initial) {</a>
<a name="ln959">      term-&gt;title_len = 0;</a>
<a name="ln960">      term-&gt;title_size = MAX(frag.len, 1024);</a>
<a name="ln961">      term-&gt;title = xmalloc(sizeof(char *) * term-&gt;title_size);</a>
<a name="ln962">    } else if (term-&gt;title_len + frag.len &gt; term-&gt;title_size) {</a>
<a name="ln963">      term-&gt;title_size *= 2;</a>
<a name="ln964">      term-&gt;title = xrealloc(term-&gt;title, sizeof(char *) * term-&gt;title_size);</a>
<a name="ln965">    }</a>
<a name="ln966"> </a>
<a name="ln967">    memcpy(term-&gt;title + term-&gt;title_len, frag.str, frag.len);</a>
<a name="ln968">    term-&gt;title_len += frag.len;</a>
<a name="ln969"> </a>
<a name="ln970">    if (frag.final) {</a>
<a name="ln971">      buf_set_term_title(buf, term-&gt;title, term-&gt;title_len);</a>
<a name="ln972">      xfree(term-&gt;title);</a>
<a name="ln973">      term-&gt;title = NULL;</a>
<a name="ln974">    }</a>
<a name="ln975">    break;</a>
<a name="ln976">  }</a>
<a name="ln977"> </a>
<a name="ln978">  case VTERM_PROP_MOUSE:</a>
<a name="ln979">    term-&gt;forward_mouse = (bool)val-&gt;number;</a>
<a name="ln980">    break;</a>
<a name="ln981"> </a>
<a name="ln982">  default:</a>
<a name="ln983">    return 0;</a>
<a name="ln984">  }</a>
<a name="ln985"> </a>
<a name="ln986">  return 1;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">static int term_bell(void *data)</a>
<a name="ln990">{</a>
<a name="ln991">  ui_call_bell();</a>
<a name="ln992">  return 1;</a>
<a name="ln993">}</a>
<a name="ln994"> </a>
<a name="ln995">/// Scrollback push handler: called just before a line goes offscreen (and libvterm will forget it),</a>
<a name="ln996">/// giving us a chance to store it.</a>
<a name="ln997">///</a>
<a name="ln998">/// Code adapted from pangoterm.</a>
<a name="ln999">static int term_sb_push(int cols, const VTermScreenCell *cells, void *data)</a>
<a name="ln1000">{</a>
<a name="ln1001">  Terminal *term = data;</a>
<a name="ln1002"> </a>
<a name="ln1003">  if (!term-&gt;sb_size) {</a>
<a name="ln1004">    return 0;</a>
<a name="ln1005">  }</a>
<a name="ln1006"> </a>
<a name="ln1007">  // copy vterm cells into sb_buffer</a>
<a name="ln1008">  size_t c = (size_t)cols;</a>
<a name="ln1009">  ScrollbackLine *sbrow = NULL;</a>
<a name="ln1010">  if (term-&gt;sb_current == term-&gt;sb_size) {</a>
<a name="ln1011">    if (term-&gt;sb_buffer[term-&gt;sb_current - 1]-&gt;cols == c) {</a>
<a name="ln1012">      // Recycle old row if it's the right size</a>
<a name="ln1013">      sbrow = term-&gt;sb_buffer[term-&gt;sb_current - 1];</a>
<a name="ln1014">    } else {</a>
<a name="ln1015">      xfree(term-&gt;sb_buffer[term-&gt;sb_current - 1]);</a>
<a name="ln1016">    }</a>
<a name="ln1017"> </a>
<a name="ln1018">    // Make room at the start by shifting to the right.</a>
<a name="ln1019">    memmove(term-&gt;sb_buffer + 1, term-&gt;sb_buffer,</a>
<a name="ln1020">            sizeof(term-&gt;sb_buffer[0]) * (term-&gt;sb_current - 1));</a>
<a name="ln1021">  } else if (term-&gt;sb_current &gt; 0) {</a>
<a name="ln1022">    // Make room at the start by shifting to the right.</a>
<a name="ln1023">    memmove(term-&gt;sb_buffer + 1, term-&gt;sb_buffer,</a>
<a name="ln1024">            sizeof(term-&gt;sb_buffer[0]) * term-&gt;sb_current);</a>
<a name="ln1025">  }</a>
<a name="ln1026"> </a>
<a name="ln1027">  if (!sbrow) {</a>
<a name="ln1028">    sbrow = xmalloc(sizeof(ScrollbackLine) + c * sizeof(sbrow-&gt;cells[0]));</a>
<a name="ln1029">    sbrow-&gt;cols = c;</a>
<a name="ln1030">  }</a>
<a name="ln1031"> </a>
<a name="ln1032">  // New row is added at the start of the storage buffer.</a>
<a name="ln1033">  term-&gt;sb_buffer[0] = sbrow;</a>
<a name="ln1034">  if (term-&gt;sb_current &lt; term-&gt;sb_size) {</a>
<a name="ln1035">    term-&gt;sb_current++;</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  if (term-&gt;sb_pending &lt; (int)term-&gt;sb_size) {</a>
<a name="ln1039">    term-&gt;sb_pending++;</a>
<a name="ln1040">  }</a>
<a name="ln1041"> </a>
<a name="ln1042">  memcpy(sbrow-&gt;cells, cells, sizeof(cells[0]) * c);</a>
<a name="ln1043">  set_put(ptr_t, &amp;invalidated_terminals, term);</a>
<a name="ln1044"> </a>
<a name="ln1045">  return 1;</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">/// Scrollback pop handler (from pangoterm).</a>
<a name="ln1049">///</a>
<a name="ln1050">/// @param cols</a>
<a name="ln1051">/// @param cells  VTerm state to update.</a>
<a name="ln1052">/// @param data   Terminal</a>
<a name="ln1053">static int term_sb_pop(int cols, VTermScreenCell *cells, void *data)</a>
<a name="ln1054">{</a>
<a name="ln1055">  Terminal *term = data;</a>
<a name="ln1056"> </a>
<a name="ln1057">  if (!term-&gt;sb_current) {</a>
<a name="ln1058">    return 0;</a>
<a name="ln1059">  }</a>
<a name="ln1060"> </a>
<a name="ln1061">  if (term-&gt;sb_pending) {</a>
<a name="ln1062">    term-&gt;sb_pending--;</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  ScrollbackLine *sbrow = term-&gt;sb_buffer[0];</a>
<a name="ln1066">  term-&gt;sb_current--;</a>
<a name="ln1067">  // Forget the &quot;popped&quot; row by shifting the rest onto it.</a>
<a name="ln1068">  memmove(term-&gt;sb_buffer, term-&gt;sb_buffer + 1,</a>
<a name="ln1069">          sizeof(term-&gt;sb_buffer[0]) * (term-&gt;sb_current));</a>
<a name="ln1070"> </a>
<a name="ln1071">  size_t cols_to_copy = (size_t)cols;</a>
<a name="ln1072">  if (cols_to_copy &gt; sbrow-&gt;cols) {</a>
<a name="ln1073">    cols_to_copy = sbrow-&gt;cols;</a>
<a name="ln1074">  }</a>
<a name="ln1075"> </a>
<a name="ln1076">  // copy to vterm state</a>
<a name="ln1077">  memcpy(cells, sbrow-&gt;cells, sizeof(cells[0]) * cols_to_copy);</a>
<a name="ln1078">  for (size_t col = cols_to_copy; col &lt; (size_t)cols; col++) {</a>
<a name="ln1079">    cells[col].chars[0] = 0;</a>
<a name="ln1080">    cells[col].width = 1;</a>
<a name="ln1081">  }</a>
<a name="ln1082"> </a>
<a name="ln1083">  xfree(sbrow);</a>
<a name="ln1084">  set_put(ptr_t, &amp;invalidated_terminals, term);</a>
<a name="ln1085"> </a>
<a name="ln1086">  return 1;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">// }}}</a>
<a name="ln1090">// input handling {{{</a>
<a name="ln1091"> </a>
<a name="ln1092">static void convert_modifiers(int key, VTermModifier *statep)</a>
<a name="ln1093">{</a>
<a name="ln1094">  if (mod_mask &amp; MOD_MASK_SHIFT) {</a>
<a name="ln1095">    *statep |= VTERM_MOD_SHIFT;</a>
<a name="ln1096">  }</a>
<a name="ln1097">  if (mod_mask &amp; MOD_MASK_CTRL) {</a>
<a name="ln1098">    *statep |= VTERM_MOD_CTRL;</a>
<a name="ln1099">  }</a>
<a name="ln1100">  if (mod_mask &amp; MOD_MASK_ALT) {</a>
<a name="ln1101">    *statep |= VTERM_MOD_ALT;</a>
<a name="ln1102">  }</a>
<a name="ln1103"> </a>
<a name="ln1104">  switch (key) {</a>
<a name="ln1105">  case K_S_TAB:</a>
<a name="ln1106">  case K_S_UP:</a>
<a name="ln1107">  case K_S_DOWN:</a>
<a name="ln1108">  case K_S_LEFT:</a>
<a name="ln1109">  case K_S_RIGHT:</a>
<a name="ln1110">  case K_S_HOME:</a>
<a name="ln1111">  case K_S_END:</a>
<a name="ln1112">  case K_S_F1:</a>
<a name="ln1113">  case K_S_F2:</a>
<a name="ln1114">  case K_S_F3:</a>
<a name="ln1115">  case K_S_F4:</a>
<a name="ln1116">  case K_S_F5:</a>
<a name="ln1117">  case K_S_F6:</a>
<a name="ln1118">  case K_S_F7:</a>
<a name="ln1119">  case K_S_F8:</a>
<a name="ln1120">  case K_S_F9:</a>
<a name="ln1121">  case K_S_F10:</a>
<a name="ln1122">  case K_S_F11:</a>
<a name="ln1123">  case K_S_F12:</a>
<a name="ln1124">    *statep |= VTERM_MOD_SHIFT;</a>
<a name="ln1125">    break;</a>
<a name="ln1126"> </a>
<a name="ln1127">  case K_C_LEFT:</a>
<a name="ln1128">  case K_C_RIGHT:</a>
<a name="ln1129">  case K_C_HOME:</a>
<a name="ln1130">  case K_C_END:</a>
<a name="ln1131">    *statep |= VTERM_MOD_CTRL;</a>
<a name="ln1132">    break;</a>
<a name="ln1133">  }</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">static VTermKey convert_key(int key, VTermModifier *statep)</a>
<a name="ln1137">{</a>
<a name="ln1138">  convert_modifiers(key, statep);</a>
<a name="ln1139"> </a>
<a name="ln1140">  switch (key) {</a>
<a name="ln1141">  case K_BS:</a>
<a name="ln1142">    return VTERM_KEY_BACKSPACE;</a>
<a name="ln1143">  case K_S_TAB:</a>
<a name="ln1144">    FALLTHROUGH;</a>
<a name="ln1145">  case TAB:</a>
<a name="ln1146">    return VTERM_KEY_TAB;</a>
<a name="ln1147">  case Ctrl_M:</a>
<a name="ln1148">    return VTERM_KEY_ENTER;</a>
<a name="ln1149">  case ESC:</a>
<a name="ln1150">    return VTERM_KEY_ESCAPE;</a>
<a name="ln1151"> </a>
<a name="ln1152">  case K_S_UP:</a>
<a name="ln1153">    FALLTHROUGH;</a>
<a name="ln1154">  case K_UP:</a>
<a name="ln1155">    return VTERM_KEY_UP;</a>
<a name="ln1156">  case K_S_DOWN:</a>
<a name="ln1157">    FALLTHROUGH;</a>
<a name="ln1158">  case K_DOWN:</a>
<a name="ln1159">    return VTERM_KEY_DOWN;</a>
<a name="ln1160">  case K_S_LEFT:</a>
<a name="ln1161">    FALLTHROUGH;</a>
<a name="ln1162">  case K_C_LEFT:</a>
<a name="ln1163">    FALLTHROUGH;</a>
<a name="ln1164">  case K_LEFT:</a>
<a name="ln1165">    return VTERM_KEY_LEFT;</a>
<a name="ln1166">  case K_S_RIGHT:</a>
<a name="ln1167">    FALLTHROUGH;</a>
<a name="ln1168">  case K_C_RIGHT:</a>
<a name="ln1169">    FALLTHROUGH;</a>
<a name="ln1170">  case K_RIGHT:</a>
<a name="ln1171">    return VTERM_KEY_RIGHT;</a>
<a name="ln1172"> </a>
<a name="ln1173">  case K_INS:</a>
<a name="ln1174">    return VTERM_KEY_INS;</a>
<a name="ln1175">  case K_DEL:</a>
<a name="ln1176">    return VTERM_KEY_DEL;</a>
<a name="ln1177">  case K_S_HOME:</a>
<a name="ln1178">    FALLTHROUGH;</a>
<a name="ln1179">  case K_C_HOME:</a>
<a name="ln1180">    FALLTHROUGH;</a>
<a name="ln1181">  case K_HOME:</a>
<a name="ln1182">    return VTERM_KEY_HOME;</a>
<a name="ln1183">  case K_S_END:</a>
<a name="ln1184">    FALLTHROUGH;</a>
<a name="ln1185">  case K_C_END:</a>
<a name="ln1186">    FALLTHROUGH;</a>
<a name="ln1187">  case K_END:</a>
<a name="ln1188">    return VTERM_KEY_END;</a>
<a name="ln1189">  case K_PAGEUP:</a>
<a name="ln1190">    return VTERM_KEY_PAGEUP;</a>
<a name="ln1191">  case K_PAGEDOWN:</a>
<a name="ln1192">    return VTERM_KEY_PAGEDOWN;</a>
<a name="ln1193"> </a>
<a name="ln1194">  case K_K0:</a>
<a name="ln1195">    FALLTHROUGH;</a>
<a name="ln1196">  case K_KINS:</a>
<a name="ln1197">    return VTERM_KEY_KP_0;</a>
<a name="ln1198">  case K_K1:</a>
<a name="ln1199">    FALLTHROUGH;</a>
<a name="ln1200">  case K_KEND:</a>
<a name="ln1201">    return VTERM_KEY_KP_1;</a>
<a name="ln1202">  case K_K2:</a>
<a name="ln1203">    FALLTHROUGH;</a>
<a name="ln1204">  case K_KDOWN:</a>
<a name="ln1205">    return VTERM_KEY_KP_2;</a>
<a name="ln1206">  case K_K3:</a>
<a name="ln1207">    FALLTHROUGH;</a>
<a name="ln1208">  case K_KPAGEDOWN:</a>
<a name="ln1209">    return VTERM_KEY_KP_3;</a>
<a name="ln1210">  case K_K4:</a>
<a name="ln1211">    FALLTHROUGH;</a>
<a name="ln1212">  case K_KLEFT:</a>
<a name="ln1213">    return VTERM_KEY_KP_4;</a>
<a name="ln1214">  case K_K5:</a>
<a name="ln1215">    FALLTHROUGH;</a>
<a name="ln1216">  case K_KORIGIN:</a>
<a name="ln1217">    return VTERM_KEY_KP_5;</a>
<a name="ln1218">  case K_K6:</a>
<a name="ln1219">    FALLTHROUGH;</a>
<a name="ln1220">  case K_KRIGHT:</a>
<a name="ln1221">    return VTERM_KEY_KP_6;</a>
<a name="ln1222">  case K_K7:</a>
<a name="ln1223">    FALLTHROUGH;</a>
<a name="ln1224">  case K_KHOME:</a>
<a name="ln1225">    return VTERM_KEY_KP_7;</a>
<a name="ln1226">  case K_K8:</a>
<a name="ln1227">    FALLTHROUGH;</a>
<a name="ln1228">  case K_KUP:</a>
<a name="ln1229">    return VTERM_KEY_KP_8;</a>
<a name="ln1230">  case K_K9:</a>
<a name="ln1231">    FALLTHROUGH;</a>
<a name="ln1232">  case K_KPAGEUP:</a>
<a name="ln1233">    return VTERM_KEY_KP_9;</a>
<a name="ln1234">  case K_KDEL:</a>
<a name="ln1235">    FALLTHROUGH;</a>
<a name="ln1236">  case K_KPOINT:</a>
<a name="ln1237">    return VTERM_KEY_KP_PERIOD;</a>
<a name="ln1238">  case K_KENTER:</a>
<a name="ln1239">    return VTERM_KEY_KP_ENTER;</a>
<a name="ln1240">  case K_KPLUS:</a>
<a name="ln1241">    return VTERM_KEY_KP_PLUS;</a>
<a name="ln1242">  case K_KMINUS:</a>
<a name="ln1243">    return VTERM_KEY_KP_MINUS;</a>
<a name="ln1244">  case K_KMULTIPLY:</a>
<a name="ln1245">    return VTERM_KEY_KP_MULT;</a>
<a name="ln1246">  case K_KDIVIDE:</a>
<a name="ln1247">    return VTERM_KEY_KP_DIVIDE;</a>
<a name="ln1248"> </a>
<a name="ln1249">  case K_S_F1:</a>
<a name="ln1250">    FALLTHROUGH;</a>
<a name="ln1251">  case K_F1:</a>
<a name="ln1252">    return VTERM_KEY_FUNCTION(1);</a>
<a name="ln1253">  case K_S_F2:</a>
<a name="ln1254">    FALLTHROUGH;</a>
<a name="ln1255">  case K_F2:</a>
<a name="ln1256">    return VTERM_KEY_FUNCTION(2);</a>
<a name="ln1257">  case K_S_F3:</a>
<a name="ln1258">    FALLTHROUGH;</a>
<a name="ln1259">  case K_F3:</a>
<a name="ln1260">    return VTERM_KEY_FUNCTION(3);</a>
<a name="ln1261">  case K_S_F4:</a>
<a name="ln1262">    FALLTHROUGH;</a>
<a name="ln1263">  case K_F4:</a>
<a name="ln1264">    return VTERM_KEY_FUNCTION(4);</a>
<a name="ln1265">  case K_S_F5:</a>
<a name="ln1266">    FALLTHROUGH;</a>
<a name="ln1267">  case K_F5:</a>
<a name="ln1268">    return VTERM_KEY_FUNCTION(5);</a>
<a name="ln1269">  case K_S_F6:</a>
<a name="ln1270">    FALLTHROUGH;</a>
<a name="ln1271">  case K_F6:</a>
<a name="ln1272">    return VTERM_KEY_FUNCTION(6);</a>
<a name="ln1273">  case K_S_F7:</a>
<a name="ln1274">    FALLTHROUGH;</a>
<a name="ln1275">  case K_F7:</a>
<a name="ln1276">    return VTERM_KEY_FUNCTION(7);</a>
<a name="ln1277">  case K_S_F8:</a>
<a name="ln1278">    FALLTHROUGH;</a>
<a name="ln1279">  case K_F8:</a>
<a name="ln1280">    return VTERM_KEY_FUNCTION(8);</a>
<a name="ln1281">  case K_S_F9:</a>
<a name="ln1282">    FALLTHROUGH;</a>
<a name="ln1283">  case K_F9:</a>
<a name="ln1284">    return VTERM_KEY_FUNCTION(9);</a>
<a name="ln1285">  case K_S_F10:</a>
<a name="ln1286">    FALLTHROUGH;</a>
<a name="ln1287">  case K_F10:</a>
<a name="ln1288">    return VTERM_KEY_FUNCTION(10);</a>
<a name="ln1289">  case K_S_F11:</a>
<a name="ln1290">    FALLTHROUGH;</a>
<a name="ln1291">  case K_F11:</a>
<a name="ln1292">    return VTERM_KEY_FUNCTION(11);</a>
<a name="ln1293">  case K_S_F12:</a>
<a name="ln1294">    FALLTHROUGH;</a>
<a name="ln1295">  case K_F12:</a>
<a name="ln1296">    return VTERM_KEY_FUNCTION(12);</a>
<a name="ln1297"> </a>
<a name="ln1298">  case K_F13:</a>
<a name="ln1299">    return VTERM_KEY_FUNCTION(13);</a>
<a name="ln1300">  case K_F14:</a>
<a name="ln1301">    return VTERM_KEY_FUNCTION(14);</a>
<a name="ln1302">  case K_F15:</a>
<a name="ln1303">    return VTERM_KEY_FUNCTION(15);</a>
<a name="ln1304">  case K_F16:</a>
<a name="ln1305">    return VTERM_KEY_FUNCTION(16);</a>
<a name="ln1306">  case K_F17:</a>
<a name="ln1307">    return VTERM_KEY_FUNCTION(17);</a>
<a name="ln1308">  case K_F18:</a>
<a name="ln1309">    return VTERM_KEY_FUNCTION(18);</a>
<a name="ln1310">  case K_F19:</a>
<a name="ln1311">    return VTERM_KEY_FUNCTION(19);</a>
<a name="ln1312">  case K_F20:</a>
<a name="ln1313">    return VTERM_KEY_FUNCTION(20);</a>
<a name="ln1314">  case K_F21:</a>
<a name="ln1315">    return VTERM_KEY_FUNCTION(21);</a>
<a name="ln1316">  case K_F22:</a>
<a name="ln1317">    return VTERM_KEY_FUNCTION(22);</a>
<a name="ln1318">  case K_F23:</a>
<a name="ln1319">    return VTERM_KEY_FUNCTION(23);</a>
<a name="ln1320">  case K_F24:</a>
<a name="ln1321">    return VTERM_KEY_FUNCTION(24);</a>
<a name="ln1322">  case K_F25:</a>
<a name="ln1323">    return VTERM_KEY_FUNCTION(25);</a>
<a name="ln1324">  case K_F26:</a>
<a name="ln1325">    return VTERM_KEY_FUNCTION(26);</a>
<a name="ln1326">  case K_F27:</a>
<a name="ln1327">    return VTERM_KEY_FUNCTION(27);</a>
<a name="ln1328">  case K_F28:</a>
<a name="ln1329">    return VTERM_KEY_FUNCTION(28);</a>
<a name="ln1330">  case K_F29:</a>
<a name="ln1331">    return VTERM_KEY_FUNCTION(29);</a>
<a name="ln1332">  case K_F30:</a>
<a name="ln1333">    return VTERM_KEY_FUNCTION(30);</a>
<a name="ln1334">  case K_F31:</a>
<a name="ln1335">    return VTERM_KEY_FUNCTION(31);</a>
<a name="ln1336">  case K_F32:</a>
<a name="ln1337">    return VTERM_KEY_FUNCTION(32);</a>
<a name="ln1338">  case K_F33:</a>
<a name="ln1339">    return VTERM_KEY_FUNCTION(33);</a>
<a name="ln1340">  case K_F34:</a>
<a name="ln1341">    return VTERM_KEY_FUNCTION(34);</a>
<a name="ln1342">  case K_F35:</a>
<a name="ln1343">    return VTERM_KEY_FUNCTION(35);</a>
<a name="ln1344">  case K_F36:</a>
<a name="ln1345">    return VTERM_KEY_FUNCTION(36);</a>
<a name="ln1346">  case K_F37:</a>
<a name="ln1347">    return VTERM_KEY_FUNCTION(37);</a>
<a name="ln1348">  case K_F38:</a>
<a name="ln1349">    return VTERM_KEY_FUNCTION(38);</a>
<a name="ln1350">  case K_F39:</a>
<a name="ln1351">    return VTERM_KEY_FUNCTION(39);</a>
<a name="ln1352">  case K_F40:</a>
<a name="ln1353">    return VTERM_KEY_FUNCTION(40);</a>
<a name="ln1354">  case K_F41:</a>
<a name="ln1355">    return VTERM_KEY_FUNCTION(41);</a>
<a name="ln1356">  case K_F42:</a>
<a name="ln1357">    return VTERM_KEY_FUNCTION(42);</a>
<a name="ln1358">  case K_F43:</a>
<a name="ln1359">    return VTERM_KEY_FUNCTION(43);</a>
<a name="ln1360">  case K_F44:</a>
<a name="ln1361">    return VTERM_KEY_FUNCTION(44);</a>
<a name="ln1362">  case K_F45:</a>
<a name="ln1363">    return VTERM_KEY_FUNCTION(45);</a>
<a name="ln1364">  case K_F46:</a>
<a name="ln1365">    return VTERM_KEY_FUNCTION(46);</a>
<a name="ln1366">  case K_F47:</a>
<a name="ln1367">    return VTERM_KEY_FUNCTION(47);</a>
<a name="ln1368">  case K_F48:</a>
<a name="ln1369">    return VTERM_KEY_FUNCTION(48);</a>
<a name="ln1370">  case K_F49:</a>
<a name="ln1371">    return VTERM_KEY_FUNCTION(49);</a>
<a name="ln1372">  case K_F50:</a>
<a name="ln1373">    return VTERM_KEY_FUNCTION(50);</a>
<a name="ln1374">  case K_F51:</a>
<a name="ln1375">    return VTERM_KEY_FUNCTION(51);</a>
<a name="ln1376">  case K_F52:</a>
<a name="ln1377">    return VTERM_KEY_FUNCTION(52);</a>
<a name="ln1378">  case K_F53:</a>
<a name="ln1379">    return VTERM_KEY_FUNCTION(53);</a>
<a name="ln1380">  case K_F54:</a>
<a name="ln1381">    return VTERM_KEY_FUNCTION(54);</a>
<a name="ln1382">  case K_F55:</a>
<a name="ln1383">    return VTERM_KEY_FUNCTION(55);</a>
<a name="ln1384">  case K_F56:</a>
<a name="ln1385">    return VTERM_KEY_FUNCTION(56);</a>
<a name="ln1386">  case K_F57:</a>
<a name="ln1387">    return VTERM_KEY_FUNCTION(57);</a>
<a name="ln1388">  case K_F58:</a>
<a name="ln1389">    return VTERM_KEY_FUNCTION(58);</a>
<a name="ln1390">  case K_F59:</a>
<a name="ln1391">    return VTERM_KEY_FUNCTION(59);</a>
<a name="ln1392">  case K_F60:</a>
<a name="ln1393">    return VTERM_KEY_FUNCTION(60);</a>
<a name="ln1394">  case K_F61:</a>
<a name="ln1395">    return VTERM_KEY_FUNCTION(61);</a>
<a name="ln1396">  case K_F62:</a>
<a name="ln1397">    return VTERM_KEY_FUNCTION(62);</a>
<a name="ln1398">  case K_F63:</a>
<a name="ln1399">    return VTERM_KEY_FUNCTION(63);</a>
<a name="ln1400"> </a>
<a name="ln1401">  default:</a>
<a name="ln1402">    return VTERM_KEY_NONE;</a>
<a name="ln1403">  }</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">static void mouse_action(Terminal *term, int button, int row, int col, bool pressed,</a>
<a name="ln1407">                         VTermModifier mod)</a>
<a name="ln1408">{</a>
<a name="ln1409">  vterm_mouse_move(term-&gt;vt, row, col, mod);</a>
<a name="ln1410">  if (button) {</a>
<a name="ln1411">    vterm_mouse_button(term-&gt;vt, button, pressed, mod);</a>
<a name="ln1412">  }</a>
<a name="ln1413">}</a>
<a name="ln1414"> </a>
<a name="ln1415">// process a mouse event while the terminal is focused. return true if the</a>
<a name="ln1416">// terminal should lose focus</a>
<a name="ln1417">static bool send_mouse_event(Terminal *term, int c)</a>
<a name="ln1418">{</a>
<a name="ln1419">  int row = mouse_row, col = mouse_col, grid = mouse_grid;</a>
<a name="ln1420">  win_T *mouse_win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln1421">  if (mouse_win == NULL) {</a>
<a name="ln1422">    goto end;</a>
<a name="ln1423">  }</a>
<a name="ln1424"> </a>
<a name="ln1425">  int offset;</a>
<a name="ln1426">  if (term-&gt;forward_mouse &amp;&amp; mouse_win-&gt;w_buffer-&gt;terminal == term</a>
<a name="ln1427">      &amp;&amp; col &gt;= (offset = win_col_off(mouse_win))) {</a>
<a name="ln1428">    // event in the terminal window and mouse events was enabled by the</a>
<a name="ln1429">    // program. translate and forward the event</a>
<a name="ln1430">    int button;</a>
<a name="ln1431">    bool pressed = false;</a>
<a name="ln1432"> </a>
<a name="ln1433">    switch (c) {</a>
<a name="ln1434">    case K_LEFTDRAG:</a>
<a name="ln1435">    case K_LEFTMOUSE:</a>
<a name="ln1436">      pressed = true; FALLTHROUGH;</a>
<a name="ln1437">    case K_LEFTRELEASE:</a>
<a name="ln1438">      button = 1; break;</a>
<a name="ln1439">    case K_MOUSEMOVE:</a>
<a name="ln1440">      button = 0; break;</a>
<a name="ln1441">    case K_MIDDLEDRAG:</a>
<a name="ln1442">    case K_MIDDLEMOUSE:</a>
<a name="ln1443">      pressed = true; FALLTHROUGH;</a>
<a name="ln1444">    case K_MIDDLERELEASE:</a>
<a name="ln1445">      button = 2; break;</a>
<a name="ln1446">    case K_RIGHTDRAG:</a>
<a name="ln1447">    case K_RIGHTMOUSE:</a>
<a name="ln1448">      pressed = true; FALLTHROUGH;</a>
<a name="ln1449">    case K_RIGHTRELEASE:</a>
<a name="ln1450">      button = 3; break;</a>
<a name="ln1451">    case K_MOUSEDOWN:</a>
<a name="ln1452">      pressed = true; button = 4; break;</a>
<a name="ln1453">    case K_MOUSEUP:</a>
<a name="ln1454">      pressed = true; button = 5; break;</a>
<a name="ln1455">    case K_MOUSELEFT:</a>
<a name="ln1456">      pressed = true; button = 7; break;</a>
<a name="ln1457">    case K_MOUSERIGHT:</a>
<a name="ln1458">      pressed = true; button = 6; break;</a>
<a name="ln1459">    default:</a>
<a name="ln1460">      return false;</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463">    VTermModifier mod = VTERM_MOD_NONE;</a>
<a name="ln1464">    convert_modifiers(c, &amp;mod);</a>
<a name="ln1465">    mouse_action(term, button, row, col - offset, pressed, mod);</a>
<a name="ln1466">    return false;</a>
<a name="ln1467">  }</a>
<a name="ln1468"> </a>
<a name="ln1469">  if (c == K_MOUSEUP || c == K_MOUSEDOWN || c == K_MOUSELEFT || c == K_MOUSERIGHT) {</a>
<a name="ln1470">    win_T *save_curwin = curwin;</a>
<a name="ln1471">    // switch window/buffer to perform the scroll</a>
<a name="ln1472">    curwin = mouse_win;</a>
<a name="ln1473">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln1474"> </a>
<a name="ln1475">    cmdarg_T cap;</a>
<a name="ln1476">    oparg_T oa;</a>
<a name="ln1477">    CLEAR_FIELD(cap);</a>
<a name="ln1478">    clear_oparg(&amp;oa);</a>
<a name="ln1479">    cap.oap = &amp;oa;</a>
<a name="ln1480"> </a>
<a name="ln1481">    switch (cap.cmdchar = c) {</a>
<a name="ln1482">    case K_MOUSEUP:</a>
<a name="ln1483">      cap.arg = MSCR_UP;</a>
<a name="ln1484">      break;</a>
<a name="ln1485">    case K_MOUSEDOWN:</a>
<a name="ln1486">      cap.arg = MSCR_DOWN;</a>
<a name="ln1487">      break;</a>
<a name="ln1488">    case K_MOUSELEFT:</a>
<a name="ln1489">      cap.arg = MSCR_LEFT;</a>
<a name="ln1490">      break;</a>
<a name="ln1491">    case K_MOUSERIGHT:</a>
<a name="ln1492">      cap.arg = MSCR_RIGHT;</a>
<a name="ln1493">      break;</a>
<a name="ln1494">    default:</a>
<a name="ln1495">      abort();</a>
<a name="ln1496">    }</a>
<a name="ln1497"> </a>
<a name="ln1498">    // Call the common mouse scroll function shared with other modes.</a>
<a name="ln1499">    do_mousescroll(&amp;cap);</a>
<a name="ln1500"> </a>
<a name="ln1501">    curwin-&gt;w_redr_status = true;</a>
<a name="ln1502">    curwin = save_curwin;</a>
<a name="ln1503">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln1504">    redraw_later(mouse_win, UPD_NOT_VALID);</a>
<a name="ln1505">    invalidate_terminal(term, -1, -1);</a>
<a name="ln1506">    // Only need to exit focus if the scrolled window is the terminal window</a>
<a name="ln1507">    return mouse_win == curwin;</a>
<a name="ln1508">  }</a>
<a name="ln1509"> </a>
<a name="ln1510">end:</a>
<a name="ln1511">  // Ignore left release action if it was not forwarded to prevent</a>
<a name="ln1512">  // leaving Terminal mode after entering to it using a mouse.</a>
<a name="ln1513">  if ((c == K_LEFTRELEASE &amp;&amp; mouse_win != NULL &amp;&amp; mouse_win-&gt;w_buffer-&gt;terminal == term)</a>
<a name="ln1514">      || c == K_MOUSEMOVE) {</a>
<a name="ln1515">    return false;</a>
<a name="ln1516">  }</a>
<a name="ln1517"> </a>
<a name="ln1518">  ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1519">  return true;</a>
<a name="ln1520">}</a>
<a name="ln1521"> </a>
<a name="ln1522">// }}}</a>
<a name="ln1523">// terminal buffer refresh &amp; misc {{{</a>
<a name="ln1524"> </a>
<a name="ln1525">static void fetch_row(Terminal *term, int row, int end_col)</a>
<a name="ln1526">{</a>
<a name="ln1527">  int col = 0;</a>
<a name="ln1528">  size_t line_len = 0;</a>
<a name="ln1529">  char *ptr = term-&gt;textbuf;</a>
<a name="ln1530"> </a>
<a name="ln1531">  while (col &lt; end_col) {</a>
<a name="ln1532">    VTermScreenCell cell;</a>
<a name="ln1533">    fetch_cell(term, row, col, &amp;cell);</a>
<a name="ln1534">    if (cell.chars[0]) {</a>
<a name="ln1535">      int cell_len = 0;</a>
<a name="ln1536">      for (int i = 0; i &lt; VTERM_MAX_CHARS_PER_CELL &amp;&amp; cell.chars[i]; i++) {</a>
<a name="ln1537">        cell_len += utf_char2bytes((int)cell.chars[i], ptr + cell_len);</a>
<a name="ln1538">      }</a>
<a name="ln1539">      ptr += cell_len;</a>
<a name="ln1540">      line_len = (size_t)(ptr - term-&gt;textbuf);</a>
<a name="ln1541">    } else {</a>
<a name="ln1542">      *ptr++ = ' ';</a>
<a name="ln1543">    }</a>
<a name="ln1544">    col += cell.width;</a>
<a name="ln1545">  }</a>
<a name="ln1546"> </a>
<a name="ln1547">  // end of line</a>
<a name="ln1548">  term-&gt;textbuf[line_len] = NUL;</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">static bool fetch_cell(Terminal *term, int row, int col, VTermScreenCell *cell)</a>
<a name="ln1552">{</a>
<a name="ln1553">  if (row &lt; 0) {</a>
<a name="ln1554">    ScrollbackLine *sbrow = term-&gt;sb_buffer[-row - 1];</a>
<a name="ln1555">    if ((size_t)col &lt; sbrow-&gt;cols) {</a>
<a name="ln1556">      *cell = sbrow-&gt;cells[col];</a>
<a name="ln1557">    } else {</a>
<a name="ln1558">      // fill the pointer with an empty cell</a>
<a name="ln1559">      *cell = (VTermScreenCell) {</a>
<a name="ln1560">        .chars = { 0 },</a>
<a name="ln1561">        .width = 1,</a>
<a name="ln1562">      };</a>
<a name="ln1563">      return false;</a>
<a name="ln1564">    }</a>
<a name="ln1565">  } else {</a>
<a name="ln1566">    vterm_screen_get_cell(term-&gt;vts, (VTermPos){ .row = row, .col = col },</a>
<a name="ln1567">                          cell);</a>
<a name="ln1568">  }</a>
<a name="ln1569">  return true;</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572">// queue a terminal instance for refresh</a>
<a name="ln1573">static void invalidate_terminal(Terminal *term, int start_row, int end_row)</a>
<a name="ln1574">{</a>
<a name="ln1575">  if (start_row != -1 &amp;&amp; end_row != -1) {</a>
<a name="ln1576">    term-&gt;invalid_start = MIN(term-&gt;invalid_start, start_row);</a>
<a name="ln1577">    term-&gt;invalid_end = MAX(term-&gt;invalid_end, end_row);</a>
<a name="ln1578">  }</a>
<a name="ln1579"> </a>
<a name="ln1580">  set_put(ptr_t, &amp;invalidated_terminals, term);</a>
<a name="ln1581">  if (!refresh_pending) {</a>
<a name="ln1582">    time_watcher_start(&amp;refresh_timer, refresh_timer_cb, REFRESH_DELAY, 0);</a>
<a name="ln1583">    refresh_pending = true;</a>
<a name="ln1584">  }</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">static void refresh_terminal(Terminal *term)</a>
<a name="ln1588">{</a>
<a name="ln1589">  buf_T *buf = handle_get_buffer(term-&gt;buf_handle);</a>
<a name="ln1590">  bool valid = true;</a>
<a name="ln1591">  if (!buf || !(valid = buf_valid(buf))) {</a>
<a name="ln1592">    // Destroyed by `close_buffer`. Do not do anything else.</a>
<a name="ln1593">    if (!valid) {</a>
<a name="ln1594">      term-&gt;buf_handle = 0;</a>
<a name="ln1595">    }</a>
<a name="ln1596">    return;</a>
<a name="ln1597">  }</a>
<a name="ln1598">  linenr_T ml_before = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1599"> </a>
<a name="ln1600">  // refresh_ functions assume the terminal buffer is current</a>
<a name="ln1601">  aco_save_T aco;</a>
<a name="ln1602">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln1603">  refresh_size(term, buf);</a>
<a name="ln1604">  refresh_scrollback(term, buf);</a>
<a name="ln1605">  refresh_screen(term, buf);</a>
<a name="ln1606">  aucmd_restbuf(&amp;aco);</a>
<a name="ln1607"> </a>
<a name="ln1608">  int ml_added = buf-&gt;b_ml.ml_line_count - ml_before;</a>
<a name="ln1609">  adjust_topline(term, buf, ml_added);</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">/// Calls refresh_terminal() on all invalidated_terminals.</a>
<a name="ln1613">static void refresh_timer_cb(TimeWatcher *watcher, void *data)</a>
<a name="ln1614">{</a>
<a name="ln1615">  refresh_pending = false;</a>
<a name="ln1616">  if (exiting) {  // Cannot redraw (requires event loop) during teardown/exit.</a>
<a name="ln1617">    return;</a>
<a name="ln1618">  }</a>
<a name="ln1619">  Terminal *term;</a>
<a name="ln1620">  void *stub; (void)(stub);</a>
<a name="ln1621">  // don't process autocommands while updating terminal buffers</a>
<a name="ln1622">  block_autocmds();</a>
<a name="ln1623">  set_foreach(&amp;invalidated_terminals, term, {</a>
<a name="ln1624">    refresh_terminal(term);</a>
<a name="ln1625">  });</a>
<a name="ln1626">  set_clear(ptr_t, &amp;invalidated_terminals);</a>
<a name="ln1627">  unblock_autocmds();</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">static void refresh_size(Terminal *term, buf_T *buf)</a>
<a name="ln1631">{</a>
<a name="ln1632">  if (!term-&gt;pending_resize || term-&gt;closed) {</a>
<a name="ln1633">    return;</a>
<a name="ln1634">  }</a>
<a name="ln1635"> </a>
<a name="ln1636">  term-&gt;pending_resize = false;</a>
<a name="ln1637">  int width, height;</a>
<a name="ln1638">  vterm_get_size(term-&gt;vt, &amp;height, &amp;width);</a>
<a name="ln1639">  term-&gt;invalid_start = 0;</a>
<a name="ln1640">  term-&gt;invalid_end = height;</a>
<a name="ln1641">  term-&gt;opts.resize_cb((uint16_t)width, (uint16_t)height, term-&gt;opts.data);</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">void on_scrollback_option_changed(Terminal *term)</a>
<a name="ln1645">{</a>
<a name="ln1646">  // Scrollback buffer may not exist yet, e.g. if 'scrollback' is set in a TermOpen autocmd.</a>
<a name="ln1647">  if (term-&gt;sb_buffer != NULL) {</a>
<a name="ln1648">    refresh_terminal(term);</a>
<a name="ln1649">  }</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">/// Adjusts scrollback storage and the terminal buffer scrollback lines</a>
<a name="ln1653">static void adjust_scrollback(Terminal *term, buf_T *buf)</a>
<a name="ln1654">{</a>
<a name="ln1655">  if (buf-&gt;b_p_scbk &lt; 1) {  // Local 'scrollback' was set to -1.</a>
<a name="ln1656">    buf-&gt;b_p_scbk = SB_MAX;</a>
<a name="ln1657">  }</a>
<a name="ln1658">  const size_t scbk = (size_t)buf-&gt;b_p_scbk;</a>
<a name="ln1659">  assert(term-&gt;sb_current &lt; SIZE_MAX);</a>
<a name="ln1660">  if (term-&gt;sb_pending &gt; 0) {  // Pending rows must be processed first.</a>
<a name="ln1661">    abort();</a>
<a name="ln1662">  }</a>
<a name="ln1663"> </a>
<a name="ln1664">  // Delete lines exceeding the new 'scrollback' limit.</a>
<a name="ln1665">  if (scbk &lt; term-&gt;sb_current) {</a>
<a name="ln1666">    size_t diff = term-&gt;sb_current - scbk;</a>
<a name="ln1667">    for (size_t i = 0; i &lt; diff; i++) {</a>
<a name="ln1668">      ml_delete(1, false);</a>
<a name="ln1669">      term-&gt;sb_current--;</a>
<a name="ln1670">      xfree(term-&gt;sb_buffer[term-&gt;sb_current]);</a>
<a name="ln1671">    }</a>
<a name="ln1672">    deleted_lines(1, (linenr_T)diff);</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  // Resize the scrollback storage.</a>
<a name="ln1676">  size_t sb_region = sizeof(ScrollbackLine *) * scbk;</a>
<a name="ln1677">  if (scbk != term-&gt;sb_size) {</a>
<a name="ln1678">    term-&gt;sb_buffer = xrealloc(term-&gt;sb_buffer, sb_region);</a>
<a name="ln1679">  }</a>
<a name="ln1680"> </a>
<a name="ln1681">  term-&gt;sb_size = scbk;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">// Refresh the scrollback of an invalidated terminal.</a>
<a name="ln1685">static void refresh_scrollback(Terminal *term, buf_T *buf)</a>
<a name="ln1686">{</a>
<a name="ln1687">  int width, height;</a>
<a name="ln1688">  vterm_get_size(term-&gt;vt, &amp;height, &amp;width);</a>
<a name="ln1689"> </a>
<a name="ln1690">  // May still have pending scrollback after increase in terminal height if the</a>
<a name="ln1691">  // scrollback wasn't refreshed in time; append these to the top of the buffer.</a>
<a name="ln1692">  int row_offset = term-&gt;sb_pending;</a>
<a name="ln1693">  while (term-&gt;sb_pending &gt; 0 &amp;&amp; buf-&gt;b_ml.ml_line_count &lt; height) {</a>
<a name="ln1694">    fetch_row(term, term-&gt;sb_pending - row_offset - 1, width);</a>
<a name="ln1695">    ml_append(0, term-&gt;textbuf, 0, false);</a>
<a name="ln1696">    appended_lines(0, 1);</a>
<a name="ln1697">    term-&gt;sb_pending--;</a>
<a name="ln1698">  }</a>
<a name="ln1699"> </a>
<a name="ln1700">  row_offset -= term-&gt;sb_pending;</a>
<a name="ln1701">  while (term-&gt;sb_pending &gt; 0) {</a>
<a name="ln1702">    // This means that either the window height has decreased or the screen</a>
<a name="ln1703">    // became full and libvterm had to push all rows up. Convert the first</a>
<a name="ln1704">    // pending scrollback row into a string and append it just above the visible</a>
<a name="ln1705">    // section of the buffer</a>
<a name="ln1706">    if (((int)buf-&gt;b_ml.ml_line_count - height) &gt;= (int)term-&gt;sb_size) {</a>
<a name="ln1707">      // scrollback full, delete lines at the top</a>
<a name="ln1708">      ml_delete(1, false);</a>
<a name="ln1709">      deleted_lines(1, 1);</a>
<a name="ln1710">    }</a>
<a name="ln1711">    fetch_row(term, -term-&gt;sb_pending - row_offset, width);</a>
<a name="ln1712">    int buf_index = (int)buf-&gt;b_ml.ml_line_count - height;</a>
<a name="ln1713">    ml_append(buf_index, term-&gt;textbuf, 0, false);</a>
<a name="ln1714">    appended_lines(buf_index, 1);</a>
<a name="ln1715">    term-&gt;sb_pending--;</a>
<a name="ln1716">  }</a>
<a name="ln1717"> </a>
<a name="ln1718">  // Remove extra lines at the bottom</a>
<a name="ln1719">  int max_line_count = (int)term-&gt;sb_current + height;</a>
<a name="ln1720">  while (buf-&gt;b_ml.ml_line_count &gt; max_line_count) {</a>
<a name="ln1721">    ml_delete(buf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1722">    deleted_lines(buf-&gt;b_ml.ml_line_count, 1);</a>
<a name="ln1723">  }</a>
<a name="ln1724"> </a>
<a name="ln1725">  adjust_scrollback(term, buf);</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">// Refresh the screen (visible part of the buffer when the terminal is</a>
<a name="ln1729">// focused) of a invalidated terminal</a>
<a name="ln1730">static void refresh_screen(Terminal *term, buf_T *buf)</a>
<a name="ln1731">{</a>
<a name="ln1732">  assert(buf == curbuf);  // TODO(bfredl): remove this condition</a>
<a name="ln1733">  int changed = 0;</a>
<a name="ln1734">  int added = 0;</a>
<a name="ln1735">  int height;</a>
<a name="ln1736">  int width;</a>
<a name="ln1737">  vterm_get_size(term-&gt;vt, &amp;height, &amp;width);</a>
<a name="ln1738">  // Terminal height may have decreased before `invalid_end` reflects it.</a>
<a name="ln1739">  term-&gt;invalid_end = MIN(term-&gt;invalid_end, height);</a>
<a name="ln1740"> </a>
<a name="ln1741">  // There are no invalid rows.</a>
<a name="ln1742">  if (term-&gt;invalid_start &gt;= term-&gt;invalid_end) {</a>
<a name="ln1743">    term-&gt;invalid_start = INT_MAX;</a>
<a name="ln1744">    term-&gt;invalid_end = -1;</a>
<a name="ln1745">    return;</a>
<a name="ln1746">  }</a>
<a name="ln1747"> </a>
<a name="ln1748">  for (int r = term-&gt;invalid_start, linenr = row_to_linenr(term, r);</a>
<a name="ln1749">       r &lt; term-&gt;invalid_end; r++, linenr++) {</a>
<a name="ln1750">    fetch_row(term, r, width);</a>
<a name="ln1751"> </a>
<a name="ln1752">    if (linenr &lt;= buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1753">      ml_replace(linenr, term-&gt;textbuf, true);</a>
<a name="ln1754">      changed++;</a>
<a name="ln1755">    } else {</a>
<a name="ln1756">      ml_append(linenr - 1, term-&gt;textbuf, 0, false);</a>
<a name="ln1757">      added++;</a>
<a name="ln1758">    }</a>
<a name="ln1759">  }</a>
<a name="ln1760"> </a>
<a name="ln1761">  int change_start = row_to_linenr(term, term-&gt;invalid_start);</a>
<a name="ln1762">  int change_end = change_start + changed;</a>
<a name="ln1763">  changed_lines(buf, change_start, 0, change_end, added, true);</a>
<a name="ln1764">  term-&gt;invalid_start = INT_MAX;</a>
<a name="ln1765">  term-&gt;invalid_end = -1;</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">static void adjust_topline(Terminal *term, buf_T *buf, int added)</a>
<a name="ln1769">{</a>
<a name="ln1770">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1771">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln1772">      linenr_T ml_end = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln1773">      bool following = ml_end == wp-&gt;w_cursor.lnum + added;  // cursor at end?</a>
<a name="ln1774"> </a>
<a name="ln1775">      if (following || (wp == curwin &amp;&amp; is_focused(term))) {</a>
<a name="ln1776">        // &quot;Follow&quot; the terminal output</a>
<a name="ln1777">        wp-&gt;w_cursor.lnum = ml_end;</a>
<a name="ln1778">        set_topline(wp, MAX(wp-&gt;w_cursor.lnum - wp-&gt;w_height_inner + 1, 1));</a>
<a name="ln1779">      } else {</a>
<a name="ln1780">        // Ensure valid cursor for each window displaying this terminal.</a>
<a name="ln1781">        wp-&gt;w_cursor.lnum = MIN(wp-&gt;w_cursor.lnum, ml_end);</a>
<a name="ln1782">      }</a>
<a name="ln1783">      mb_check_adjust_col(wp);</a>
<a name="ln1784">    }</a>
<a name="ln1785">  }</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">static int row_to_linenr(Terminal *term, int row)</a>
<a name="ln1789">{</a>
<a name="ln1790">  return row != INT_MAX ? row + (int)term-&gt;sb_current + 1 : INT_MAX;</a>
<a name="ln1791">}</a>
<a name="ln1792"> </a>
<a name="ln1793">static int linenr_to_row(Terminal *term, int linenr)</a>
<a name="ln1794">{</a>
<a name="ln1795">  return linenr - (int)term-&gt;sb_current - 1;</a>
<a name="ln1796">}</a>
<a name="ln1797"> </a>
<a name="ln1798">static bool is_focused(Terminal *term)</a>
<a name="ln1799">{</a>
<a name="ln1800">  return State &amp; MODE_TERMINAL &amp;&amp; curbuf-&gt;terminal == term;</a>
<a name="ln1801">}</a>
<a name="ln1802"> </a>
<a name="ln1803">static char *get_config_string(char *key)</a>
<a name="ln1804">{</a>
<a name="ln1805">  Error err = ERROR_INIT;</a>
<a name="ln1806">  // Only called from terminal_open where curbuf-&gt;terminal is the context.</a>
<a name="ln1807">  Object obj = dict_get_value(curbuf-&gt;b_vars, cstr_as_string(key), &amp;err);</a>
<a name="ln1808">  api_clear_error(&amp;err);</a>
<a name="ln1809">  if (obj.type == kObjectTypeNil) {</a>
<a name="ln1810">    obj = dict_get_value(&amp;globvardict, cstr_as_string(key), &amp;err);</a>
<a name="ln1811">    api_clear_error(&amp;err);</a>
<a name="ln1812">  }</a>
<a name="ln1813">  if (obj.type == kObjectTypeString) {</a>
<a name="ln1814">    return obj.data.string.data;</a>
<a name="ln1815">  }</a>
<a name="ln1816">  api_free_object(obj);</a>
<a name="ln1817">  return NULL;</a>
<a name="ln1818">}</a>
<a name="ln1819"> </a>
<a name="ln1820">// }}}</a>
<a name="ln1821"> </a>
<a name="ln1822">// vim: foldmethod=marker</a>
</code></pre>
<div class="balloon" rel="266"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'rv-&gt;sb_buffer == NULL' is always true.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>