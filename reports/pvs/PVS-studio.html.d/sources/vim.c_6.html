<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vim.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;stdbool.h&gt;</a>
<a name="ln8">#include &lt;stddef.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;klib/kvec.h&quot;</a>
<a name="ln14">#include &quot;lauxlib.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln23">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln24">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln25">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln26">#include &quot;nvim/channel.h&quot;</a>
<a name="ln27">#include &quot;nvim/context.h&quot;</a>
<a name="ln28">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln29">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln33">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln35">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln36">#include &quot;nvim/globals.h&quot;</a>
<a name="ln37">#include &quot;nvim/grid.h&quot;</a>
<a name="ln38">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln39">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln40">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln41">#include &quot;nvim/log.h&quot;</a>
<a name="ln42">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln43">#include &quot;nvim/macros.h&quot;</a>
<a name="ln44">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln45">#include &quot;nvim/mark.h&quot;</a>
<a name="ln46">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln47">#include &quot;nvim/memline.h&quot;</a>
<a name="ln48">#include &quot;nvim/memory.h&quot;</a>
<a name="ln49">#include &quot;nvim/message.h&quot;</a>
<a name="ln50">#include &quot;nvim/move.h&quot;</a>
<a name="ln51">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln52">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln54">#include &quot;nvim/ops.h&quot;</a>
<a name="ln55">#include &quot;nvim/option.h&quot;</a>
<a name="ln56">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln57">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln58">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln59">#include &quot;nvim/os/process.h&quot;</a>
<a name="ln60">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln61">#include &quot;nvim/pos.h&quot;</a>
<a name="ln62">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln63">#include &quot;nvim/sign.h&quot;</a>
<a name="ln64">#include &quot;nvim/state.h&quot;</a>
<a name="ln65">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln66">#include &quot;nvim/strings.h&quot;</a>
<a name="ln67">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln68">#include &quot;nvim/types.h&quot;</a>
<a name="ln69">#include &quot;nvim/ui.h&quot;</a>
<a name="ln70">#include &quot;nvim/vim.h&quot;</a>
<a name="ln71">#include &quot;nvim/window.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">#define LINE_BUFFER_MIN_SIZE 4096</a>
<a name="ln74"> </a>
<a name="ln75">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln76"># include &quot;api/vim.c.generated.h&quot;</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">/// Gets a highlight group by name</a>
<a name="ln80">///</a>
<a name="ln81">/// similar to |hlID()|, but allocates a new ID if not present.</a>
<a name="ln82">Integer nvim_get_hl_id_by_name(String name)</a>
<a name="ln83">  FUNC_API_SINCE(7)</a>
<a name="ln84">{</a>
<a name="ln85">  return syn_check_group(name.data, name.size);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">/// Gets all or specific highlight groups in a namespace.</a>
<a name="ln89">///</a>
<a name="ln90">/// @note When the `link` attribute is defined in the highlight definition</a>
<a name="ln91">///       map, other attributes will not be taking effect (see |:hi-link|).</a>
<a name="ln92">///</a>
<a name="ln93">/// @param ns_id Get highlight groups for namespace ns_id |nvim_get_namespaces()|.</a>
<a name="ln94">///              Use 0 to get global highlight groups |:highlight|.</a>
<a name="ln95">/// @param opts  Options dict:</a>
<a name="ln96">///                 - name: (string) Get a highlight definition by name.</a>
<a name="ln97">///                 - id: (integer) Get a highlight definition by id.</a>
<a name="ln98">///                 - link: (boolean, default true) Show linked group name instead of effective definition |:hi-link|.</a>
<a name="ln99">///                 - create: (boolean, default true) When highlight group doesn't exist create it.</a>
<a name="ln100">///</a>
<a name="ln101">/// @param[out] err Error details, if any.</a>
<a name="ln102">/// @return Highlight groups as a map from group name to a highlight definition map as in |nvim_set_hl()|,</a>
<a name="ln103">///                   or only a single highlight definition map if requested by name or id.</a>
<a name="ln104">Dictionary nvim_get_hl(Integer ns_id, Dict(get_highlight) *opts, Arena *arena, Error *err)</a>
<a name="ln105">  FUNC_API_SINCE(11)</a>
<a name="ln106">{</a>
<a name="ln107">  return ns_get_hl_defs((NS)ns_id, opts, arena, err);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/// Sets a highlight group.</a>
<a name="ln111">///</a>
<a name="ln112">/// @note Unlike the `:highlight` command which can update a highlight group,</a>
<a name="ln113">///       this function completely replaces the definition. For example:</a>
<a name="ln114">///       ``nvim_set_hl(0, 'Visual', {})`` will clear the highlight group</a>
<a name="ln115">///       'Visual'.</a>
<a name="ln116">///</a>
<a name="ln117">/// @note The fg and bg keys also accept the string values `&quot;fg&quot;` or `&quot;bg&quot;`</a>
<a name="ln118">///       which act as aliases to the corresponding foreground and background</a>
<a name="ln119">///       values of the Normal group. If the Normal group has not been defined,</a>
<a name="ln120">///       using these values results in an error.</a>
<a name="ln121">///</a>
<a name="ln122">///</a>
<a name="ln123">/// @note If `link` is used in combination with other attributes; only the</a>
<a name="ln124">///       `link` will take effect (see |:hi-link|).</a>
<a name="ln125">///</a>
<a name="ln126">/// @param ns_id Namespace id for this highlight |nvim_create_namespace()|.</a>
<a name="ln127">///              Use 0 to set a highlight group globally |:highlight|.</a>
<a name="ln128">///              Highlights from non-global namespaces are not active by default, use</a>
<a name="ln129">///              |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to activate them.</a>
<a name="ln130">/// @param name  Highlight group name, e.g. &quot;ErrorMsg&quot;</a>
<a name="ln131">/// @param val   Highlight definition map, accepts the following keys:</a>
<a name="ln132">///                - fg (or foreground): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln133">///                - bg (or background): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln134">///                - sp (or special): color name or &quot;#RRGGBB&quot;</a>
<a name="ln135">///                - blend: integer between 0 and 100</a>
<a name="ln136">///                - bold: boolean</a>
<a name="ln137">///                - standout: boolean</a>
<a name="ln138">///                - underline: boolean</a>
<a name="ln139">///                - undercurl: boolean</a>
<a name="ln140">///                - underdouble: boolean</a>
<a name="ln141">///                - underdotted: boolean</a>
<a name="ln142">///                - underdashed: boolean</a>
<a name="ln143">///                - strikethrough: boolean</a>
<a name="ln144">///                - italic: boolean</a>
<a name="ln145">///                - reverse: boolean</a>
<a name="ln146">///                - nocombine: boolean</a>
<a name="ln147">///                - link: name of another highlight group to link to, see |:hi-link|.</a>
<a name="ln148">///                - default: Don't override existing definition |:hi-default|</a>
<a name="ln149">///                - ctermfg: Sets foreground of cterm color |ctermfg|</a>
<a name="ln150">///                - ctermbg: Sets background of cterm color |ctermbg|</a>
<a name="ln151">///                - cterm: cterm attribute map, like |highlight-args|. If not set,</a>
<a name="ln152">///                         cterm attributes will match those from the attribute map</a>
<a name="ln153">///                         documented above.</a>
<a name="ln154">/// @param[out] err Error details, if any</a>
<a name="ln155">///</a>
<a name="ln156">// TODO(bfredl): val should take update vs reset flag</a>
<a name="ln157">void nvim_set_hl(Integer ns_id, String name, Dict(highlight) *val, Error *err)</a>
<a name="ln158">  FUNC_API_SINCE(7)</a>
<a name="ln159">{</a>
<a name="ln160">  int hl_id = syn_check_group(name.data, name.size);</a>
<a name="ln161">  VALIDATE_S((hl_id != 0), &quot;highlight name&quot;, name.data, {</a>
<a name="ln162">    return;</a>
<a name="ln163">  });</a>
<a name="ln164">  int link_id = -1;</a>
<a name="ln165"> </a>
<a name="ln166">  HlAttrs attrs = dict2hlattrs(val, true, &amp;link_id, err);</a>
<a name="ln167">  if (!ERROR_SET(err)) {</a>
<a name="ln168">    ns_hl_def((NS)ns_id, hl_id, attrs, link_id, val);</a>
<a name="ln169">  }</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">/// Set active namespace for highlights defined with |nvim_set_hl()|. This can be set for</a>
<a name="ln173">/// a single window, see |nvim_win_set_hl_ns()|.</a>
<a name="ln174">///</a>
<a name="ln175">/// @param ns_id the namespace to use</a>
<a name="ln176">/// @param[out] err Error details, if any</a>
<a name="ln177">void nvim_set_hl_ns(Integer ns_id, Error *err)</a>
<a name="ln178">  FUNC_API_SINCE(10)</a>
<a name="ln179">{</a>
<a name="ln180">  VALIDATE_INT((ns_id &gt;= 0), &quot;namespace&quot;, ns_id, {</a>
<a name="ln181">    return;</a>
<a name="ln182">  });</a>
<a name="ln183"> </a>
<a name="ln184">  ns_hl_global = (NS)ns_id;</a>
<a name="ln185">  hl_check_ns();</a>
<a name="ln186">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">/// Set active namespace for highlights defined with |nvim_set_hl()| while redrawing.</a>
<a name="ln190">///</a>
<a name="ln191">/// This function meant to be called while redrawing, primarily from</a>
<a name="ln192">/// |nvim_set_decoration_provider()| on_win and on_line callbacks, which</a>
<a name="ln193">/// are allowed to change the namespace during a redraw cycle.</a>
<a name="ln194">///</a>
<a name="ln195">/// @param ns_id the namespace to activate</a>
<a name="ln196">/// @param[out] err Error details, if any</a>
<a name="ln197">void nvim_set_hl_ns_fast(Integer ns_id, Error *err)</a>
<a name="ln198">  FUNC_API_SINCE(10)</a>
<a name="ln199">  FUNC_API_FAST</a>
<a name="ln200">{</a>
<a name="ln201">  ns_hl_fast = (NS)ns_id;</a>
<a name="ln202">  hl_check_ns();</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/// Sends input-keys to Nvim, subject to various quirks controlled by `mode`</a>
<a name="ln206">/// flags. This is a blocking call, unlike |nvim_input()|.</a>
<a name="ln207">///</a>
<a name="ln208">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln209">///</a>
<a name="ln210">/// To input sequences like &lt;C-o&gt; use |nvim_replace_termcodes()| (typically</a>
<a name="ln211">/// with escape_ks=false) to replace |keycodes|, then pass the result to</a>
<a name="ln212">/// nvim_feedkeys().</a>
<a name="ln213">///</a>
<a name="ln214">/// Example:</a>
<a name="ln215">///</a>
<a name="ln216">/// ```vim</a>
<a name="ln217">/// :let key = nvim_replace_termcodes(&quot;&lt;C-o&gt;&quot;, v:true, v:false, v:true)</a>
<a name="ln218">/// :call nvim_feedkeys(key, 'n', v:false)</a>
<a name="ln219">/// ```</a>
<a name="ln220">///</a>
<a name="ln221">/// @param keys         to be typed</a>
<a name="ln222">/// @param mode         behavior flags, see |feedkeys()|</a>
<a name="ln223">/// @param escape_ks    If true, escape K_SPECIAL bytes in `keys`.</a>
<a name="ln224">///                     This should be false if you already used</a>
<a name="ln225">///                     |nvim_replace_termcodes()|, and true otherwise.</a>
<a name="ln226">/// @see feedkeys()</a>
<a name="ln227">/// @see vim_strsave_escape_ks</a>
<a name="ln228">void nvim_feedkeys(String keys, String mode, Boolean escape_ks)</a>
<a name="ln229">  FUNC_API_SINCE(1)</a>
<a name="ln230">{</a>
<a name="ln231">  bool remap = true;</a>
<a name="ln232">  bool insert = false;</a>
<a name="ln233">  bool typed = false;</a>
<a name="ln234">  bool execute = false;</a>
<a name="ln235">  bool dangerous = false;</a>
<a name="ln236"> </a>
<a name="ln237">  for (size_t i = 0; i &lt; mode.size; i++) {</a>
<a name="ln238">    switch (mode.data[i]) {</a>
<a name="ln239">    case 'n':</a>
<a name="ln240">      remap = false; break;</a>
<a name="ln241">    case 'm':</a>
<a name="ln242">      remap = true; break;</a>
<a name="ln243">    case 't':</a>
<a name="ln244">      typed = true; break;</a>
<a name="ln245">    case 'i':</a>
<a name="ln246">      insert = true; break;</a>
<a name="ln247">    case 'x':</a>
<a name="ln248">      execute = true; break;</a>
<a name="ln249">    case '!':</a>
<a name="ln250">      dangerous = true; break;</a>
<a name="ln251">    }</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  if (keys.size == 0 &amp;&amp; !execute) {</a>
<a name="ln255">    return;</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  char *keys_esc;</a>
<a name="ln259">  if (escape_ks) {</a>
<a name="ln260">    // Need to escape K_SPECIAL before putting the string in the</a>
<a name="ln261">    // typeahead buffer.</a>
<a name="ln262">    keys_esc = vim_strsave_escape_ks(keys.data);</a>
<a name="ln263">  } else {</a>
<a name="ln264">    keys_esc = keys.data;</a>
<a name="ln265">  }</a>
<a name="ln266">  ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),</a>
<a name="ln267">              insert ? 0 : typebuf.tb_len, !typed, false);</a>
<a name="ln268">  if (vgetc_busy) {</a>
<a name="ln269">    typebuf_was_filled = true;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  if (escape_ks) {</a>
<a name="ln273">    xfree(keys_esc);</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  if (execute) {</a>
<a name="ln277">    int save_msg_scroll = msg_scroll;</a>
<a name="ln278"> </a>
<a name="ln279">    // Avoid a 1 second delay when the keys start Insert mode.</a>
<a name="ln280">    msg_scroll = false;</a>
<a name="ln281">    if (!dangerous) {</a>
<a name="ln282">      ex_normal_busy++;</a>
<a name="ln283">    }</a>
<a name="ln284">    exec_normal(true);</a>
<a name="ln285">    if (!dangerous) {</a>
<a name="ln286">      ex_normal_busy--;</a>
<a name="ln287">    }</a>
<a name="ln288">    msg_scroll |= save_msg_scroll;</a>
<a name="ln289">  }</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">/// Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level</a>
<a name="ln293">/// input buffer and the call is non-blocking (input is processed</a>
<a name="ln294">/// asynchronously by the eventloop).</a>
<a name="ln295">///</a>
<a name="ln296">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln297">///</a>
<a name="ln298">/// @note |keycodes| like &lt;CR&gt; are translated, so &quot;&lt;&quot; is special.</a>
<a name="ln299">///       To input a literal &quot;&lt;&quot;, send &lt;LT&gt;.</a>
<a name="ln300">///</a>
<a name="ln301">/// @note For mouse events use |nvim_input_mouse()|. The pseudokey form</a>
<a name="ln302">///       &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is deprecated since |api-level| 6.</a>
<a name="ln303">///</a>
<a name="ln304">/// @param keys to be typed</a>
<a name="ln305">/// @return Number of bytes actually written (can be fewer than</a>
<a name="ln306">///         requested if the buffer becomes full).</a>
<a name="ln307">Integer nvim_input(String keys)</a>
<a name="ln308">  FUNC_API_SINCE(1) FUNC_API_FAST</a>
<a name="ln309">{</a>
<a name="ln310">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln311">  return (Integer)input_enqueue(keys);</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">/// Send mouse event from GUI.</a>
<a name="ln315">///</a>
<a name="ln316">/// Non-blocking: does not wait on any result, but queues the event to be</a>
<a name="ln317">/// processed soon by the event loop.</a>
<a name="ln318">///</a>
<a name="ln319">/// @note Currently this doesn't support &quot;scripting&quot; multiple mouse events</a>
<a name="ln320">///       by calling it multiple times in a loop: the intermediate mouse</a>
<a name="ln321">///       positions will be ignored. It should be used to implement real-time</a>
<a name="ln322">///       mouse input in a GUI. The deprecated pseudokey form</a>
<a name="ln323">///       (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of |nvim_input()| has the same limitation.</a>
<a name="ln324">///</a>
<a name="ln325">/// @param button Mouse button: one of &quot;left&quot;, &quot;right&quot;, &quot;middle&quot;, &quot;wheel&quot;, &quot;move&quot;.</a>
<a name="ln326">/// @param action For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;, &quot;release&quot;.</a>
<a name="ln327">///               For the wheel, one of &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;. Ignored for &quot;move&quot;.</a>
<a name="ln328">/// @param modifier String of modifiers each represented by a single char.</a>
<a name="ln329">///                 The same specifiers are used as for a key press, except</a>
<a name="ln330">///                 that the &quot;-&quot; separator is optional, so &quot;C-A-&quot;, &quot;c-a&quot;</a>
<a name="ln331">///                 and &quot;CA&quot; can all be used to specify Ctrl+Alt+click.</a>
<a name="ln332">/// @param grid Grid number if the client uses |ui-multigrid|, else 0.</a>
<a name="ln333">/// @param row Mouse row-position (zero-based, like redraw events)</a>
<a name="ln334">/// @param col Mouse column-position (zero-based, like redraw events)</a>
<a name="ln335">/// @param[out] err Error details, if any</a>
<a name="ln336">void nvim_input_mouse(String button, String action, String modifier, Integer grid, Integer row,</a>
<a name="ln337">                      Integer col, Error *err)</a>
<a name="ln338">  FUNC_API_SINCE(6) FUNC_API_FAST</a>
<a name="ln339">{</a>
<a name="ln340">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln341"> </a>
<a name="ln342">  if (button.data == NULL || action.data == NULL) {</a>
<a name="ln343">    goto error;</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  int code = 0;</a>
<a name="ln347"> </a>
<a name="ln348">  if (strequal(button.data, &quot;left&quot;)) {</a>
<a name="ln349">    code = KE_LEFTMOUSE;</a>
<a name="ln350">  } else if (strequal(button.data, &quot;middle&quot;)) {</a>
<a name="ln351">    code = KE_MIDDLEMOUSE;</a>
<a name="ln352">  } else if (strequal(button.data, &quot;right&quot;)) {</a>
<a name="ln353">    code = KE_RIGHTMOUSE;</a>
<a name="ln354">  } else if (strequal(button.data, &quot;wheel&quot;)) {</a>
<a name="ln355">    code = KE_MOUSEDOWN;</a>
<a name="ln356">  } else if (strequal(button.data, &quot;move&quot;)) {</a>
<a name="ln357">    code = KE_MOUSEMOVE;</a>
<a name="ln358">  } else {</a>
<a name="ln359">    goto error;</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  if (code == KE_MOUSEDOWN) {</a>
<a name="ln363">    if (strequal(action.data, &quot;down&quot;)) {</a>
<a name="ln364">      code = KE_MOUSEUP;</a>
<a name="ln365">    } else if (strequal(action.data, &quot;up&quot;)) {</a>
<a name="ln366">      // code = KE_MOUSEDOWN</a>
<a name="ln367">    } else if (strequal(action.data, &quot;left&quot;)) {</a>
<a name="ln368">      code = KE_MOUSERIGHT;</a>
<a name="ln369">    } else if (strequal(action.data, &quot;right&quot;)) {</a>
<a name="ln370">      code = KE_MOUSELEFT;</a>
<a name="ln371">    } else {</a>
<a name="ln372">      goto error;</a>
<a name="ln373">    }</a>
<a name="ln374">  } else if (code != KE_MOUSEMOVE) {</a>
<a name="ln375">    if (strequal(action.data, &quot;press&quot;)) {</a>
<a name="ln376">      // pass</a>
<a name="ln377">    } else if (strequal(action.data, &quot;drag&quot;)) {</a>
<a name="ln378">      code += KE_LEFTDRAG - KE_LEFTMOUSE;</a>
<a name="ln379">    } else if (strequal(action.data, &quot;release&quot;)) {</a>
<a name="ln380">      code += KE_LEFTRELEASE - KE_LEFTMOUSE;</a>
<a name="ln381">    } else {</a>
<a name="ln382">      goto error;</a>
<a name="ln383">    }</a>
<a name="ln384">  }</a>
<a name="ln385"> </a>
<a name="ln386">  int modmask = 0;</a>
<a name="ln387">  for (size_t i = 0; i &lt; modifier.size; i++) {</a>
<a name="ln388">    char byte = modifier.data[i];</a>
<a name="ln389">    if (byte == '-') {</a>
<a name="ln390">      continue;</a>
<a name="ln391">    }</a>
<a name="ln392">    int mod = name_to_mod_mask(byte);</a>
<a name="ln393">    VALIDATE((mod != 0), &quot;Invalid modifier: %c&quot;, byte, {</a>
<a name="ln394">      return;</a>
<a name="ln395">    });</a>
<a name="ln396">    modmask |= mod;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">  input_enqueue_mouse(code, (uint8_t)modmask, (int)grid, (int)row, (int)col);</a>
<a name="ln400">  return;</a>
<a name="ln401"> </a>
<a name="ln402">error:</a>
<a name="ln403">  api_set_error(err, kErrorTypeValidation,</a>
<a name="ln404">                &quot;invalid button or action&quot;);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">/// Replaces terminal codes and |keycodes| (&lt;CR&gt;, &lt;Esc&gt;, ...) in a string with</a>
<a name="ln408">/// the internal representation.</a>
<a name="ln409">///</a>
<a name="ln410">/// @param str        String to be converted.</a>
<a name="ln411">/// @param from_part  Legacy Vim parameter. Usually true.</a>
<a name="ln412">/// @param do_lt      Also translate &lt;lt&gt;. Ignored if `special` is false.</a>
<a name="ln413">/// @param special    Replace |keycodes|, e.g. &lt;CR&gt; becomes a &quot;\r&quot; char.</a>
<a name="ln414">/// @see replace_termcodes</a>
<a name="ln415">/// @see cpoptions</a>
<a name="ln416">String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt, Boolean special)</a>
<a name="ln417">  FUNC_API_SINCE(1)</a>
<a name="ln418">{</a>
<a name="ln419">  if (str.size == 0) {</a>
<a name="ln420">    // Empty string</a>
<a name="ln421">    return (String) { .data = NULL, .size = 0 };</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  int flags = 0;</a>
<a name="ln425">  if (from_part) {</a>
<a name="ln426">    flags |= REPTERM_FROM_PART;</a>
<a name="ln427">  }</a>
<a name="ln428">  if (do_lt) {</a>
<a name="ln429">    flags |= REPTERM_DO_LT;</a>
<a name="ln430">  }</a>
<a name="ln431">  if (!special) {</a>
<a name="ln432">    flags |= REPTERM_NO_SPECIAL;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  char *ptr = NULL;</a>
<a name="ln436">  replace_termcodes(str.data, str.size, &amp;ptr, 0, flags, NULL, CPO_TO_CPO_FLAGS);</a>
<a name="ln437">  return cstr_as_string(ptr);</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/// Execute Lua code. Parameters (if any) are available as `...` inside the</a>
<a name="ln441">/// chunk. The chunk can return a value.</a>
<a name="ln442">///</a>
<a name="ln443">/// Only statements are executed. To evaluate an expression, prefix it</a>
<a name="ln444">/// with `return`: return my_function(...)</a>
<a name="ln445">///</a>
<a name="ln446">/// @param code       Lua code to execute</a>
<a name="ln447">/// @param args       Arguments to the code</a>
<a name="ln448">/// @param[out] err   Details of an error encountered while parsing</a>
<a name="ln449">///                   or executing the Lua code.</a>
<a name="ln450">///</a>
<a name="ln451">/// @return           Return value of Lua code if present or NIL.</a>
<a name="ln452">Object nvim_exec_lua(String code, Array args, Error *err)</a>
<a name="ln453">  FUNC_API_SINCE(7)</a>
<a name="ln454">  FUNC_API_REMOTE_ONLY</a>
<a name="ln455">{</a>
<a name="ln456">  return nlua_exec(code, args, err);</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">/// Notify the user with a message</a>
<a name="ln460">///</a>
<a name="ln461">/// Relays the call to vim.notify . By default forwards your message in the</a>
<a name="ln462">/// echo area but can be overridden to trigger desktop notifications.</a>
<a name="ln463">///</a>
<a name="ln464">/// @param msg        Message to display to the user</a>
<a name="ln465">/// @param log_level  The log level</a>
<a name="ln466">/// @param opts       Reserved for future use.</a>
<a name="ln467">/// @param[out] err   Error details, if any</a>
<a name="ln468">Object nvim_notify(String msg, Integer log_level, Dictionary opts, Error *err)</a>
<a name="ln469">  FUNC_API_SINCE(7)</a>
<a name="ln470">{</a>
<a name="ln471">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln472">  ADD_C(args, STRING_OBJ(msg));</a>
<a name="ln473">  ADD_C(args, INTEGER_OBJ(log_level));</a>
<a name="ln474">  ADD_C(args, DICTIONARY_OBJ(opts));</a>
<a name="ln475"> </a>
<a name="ln476">  return NLUA_EXEC_STATIC(&quot;return vim.notify(...)&quot;, args, err);</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">/// Calculates the number of display cells occupied by `text`.</a>
<a name="ln480">/// Control characters including &lt;Tab&gt; count as one cell.</a>
<a name="ln481">///</a>
<a name="ln482">/// @param text       Some text</a>
<a name="ln483">/// @param[out] err   Error details, if any</a>
<a name="ln484">/// @return Number of cells</a>
<a name="ln485">Integer nvim_strwidth(String text, Error *err)</a>
<a name="ln486">  FUNC_API_SINCE(1)</a>
<a name="ln487">{</a>
<a name="ln488">  VALIDATE_S((text.size &lt;= INT_MAX), &quot;text length&quot;, &quot;(too long)&quot;, {</a>
<a name="ln489">    return 0;</a>
<a name="ln490">  });</a>
<a name="ln491"> </a>
<a name="ln492">  return (Integer)mb_string2cells(text.data);</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">/// Gets the paths contained in |runtime-search-path|.</a>
<a name="ln496">///</a>
<a name="ln497">/// @return List of paths</a>
<a name="ln498">ArrayOf(String) nvim_list_runtime_paths(Error *err)</a>
<a name="ln499">  FUNC_API_SINCE(1)</a>
<a name="ln500">{</a>
<a name="ln501">  return nvim_get_runtime_file(NULL_STRING, true, err);</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">Array nvim__runtime_inspect(void)</a>
<a name="ln505">{</a>
<a name="ln506">  return runtime_inspect();</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">/// Find files in runtime directories</a>
<a name="ln510">///</a>
<a name="ln511">/// &quot;name&quot; can contain wildcards. For example</a>
<a name="ln512">/// nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all color</a>
<a name="ln513">/// scheme files. Always use forward slashes (/) in the search pattern for</a>
<a name="ln514">/// subdirectories regardless of platform.</a>
<a name="ln515">///</a>
<a name="ln516">/// It is not an error to not find any files. An empty array is returned then.</a>
<a name="ln517">///</a>
<a name="ln518">/// @param name pattern of files to search for</a>
<a name="ln519">/// @param all whether to return all matches or only the first</a>
<a name="ln520">/// @return list of absolute paths to the found files</a>
<a name="ln521">ArrayOf(String) nvim_get_runtime_file(String name, Boolean all, Error *err)</a>
<a name="ln522">  FUNC_API_SINCE(7)</a>
<a name="ln523">  FUNC_API_FAST</a>
<a name="ln524">{</a>
<a name="ln525">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln526"> </a>
<a name="ln527">  int flags = DIP_DIRFILE | (all ? DIP_ALL : 0);</a>
<a name="ln528"> </a>
<a name="ln529">  TRY_WRAP(err, {</a>
<a name="ln530">    do_in_runtimepath((name.size ? name.data : &quot;&quot;), flags, find_runtime_cb, &amp;rv);</a>
<a name="ln531">  });</a>
<a name="ln532">  return rv;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">static bool find_runtime_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln536">{</a>
<a name="ln537">  Array *rv = (Array *)cookie;</a>
<a name="ln538">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln539">    ADD(*rv, CSTR_TO_OBJ(fnames[i]));</a>
<a name="ln540">    if (!all) {</a>
<a name="ln541">      return true;</a>
<a name="ln542">    }</a>
<a name="ln543">  }</a>
<a name="ln544"> </a>
<a name="ln545">  return num_fnames &gt; 0;</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">String nvim__get_lib_dir(void)</a>
<a name="ln549">{</a>
<a name="ln550">  return cstr_as_string(get_lib_dir());</a>
<a name="ln551">}</a>
<a name="ln552"> </a>
<a name="ln553">/// Find files in runtime directories</a>
<a name="ln554">///</a>
<a name="ln555">/// @param pat pattern of files to search for</a>
<a name="ln556">/// @param all whether to return all matches or only the first</a>
<a name="ln557">/// @param opts is_lua: only search Lua subdirs</a>
<a name="ln558">/// @return list of absolute paths to the found files</a>
<a name="ln559">ArrayOf(String) nvim__get_runtime(Array pat, Boolean all, Dict(runtime) *opts, Error *err)</a>
<a name="ln560">  FUNC_API_SINCE(8)</a>
<a name="ln561">  FUNC_API_FAST</a>
<a name="ln562">{</a>
<a name="ln563">  VALIDATE((!opts-&gt;do_source || nlua_is_deferred_safe()), &quot;%s&quot;, &quot;'do_source' used in fast callback&quot;,</a>
<a name="ln564">           {});</a>
<a name="ln565">  if (ERROR_SET(err)) {</a>
<a name="ln566">    return (Array)ARRAY_DICT_INIT;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  ArrayOf(String) res = runtime_get_named(opts-&gt;is_lua, pat, all);</a>
<a name="ln570"> </a>
<a name="ln571">  if (opts-&gt;do_source) {</a>
<a name="ln572">    for (size_t i = 0; i &lt; res.size; i++) {</a>
<a name="ln573">      String name = res.items[i].data.string;</a>
<a name="ln574">      (void)do_source(name.data, false, DOSO_NONE, NULL);</a>
<a name="ln575">    }</a>
<a name="ln576">  }</a>
<a name="ln577"> </a>
<a name="ln578">  return res;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">/// Changes the global working directory.</a>
<a name="ln582">///</a>
<a name="ln583">/// @param dir      Directory path</a>
<a name="ln584">/// @param[out] err Error details, if any</a>
<a name="ln585">void nvim_set_current_dir(String dir, Error *err)</a>
<a name="ln586">  FUNC_API_SINCE(1)</a>
<a name="ln587">{</a>
<a name="ln588">  VALIDATE_S((dir.size &lt; MAXPATHL), &quot;directory name&quot;, &quot;(too long)&quot;, {</a>
<a name="ln589">    return;</a>
<a name="ln590">  });</a>
<a name="ln591"> </a>
<a name="ln592">  char string[MAXPATHL];</a>
<a name="ln593">  memcpy(string, dir.data, dir.size);</a>
<a name="ln594">  string[dir.size] = NUL;</a>
<a name="ln595"> </a>
<a name="ln596">  try_start();</a>
<a name="ln597"> </a>
<a name="ln598">  if (!changedir_func(string, kCdScopeGlobal)) {</a>
<a name="ln599">    if (!try_end(err)) {</a>
<a name="ln600">      api_set_error(err, kErrorTypeException, &quot;Failed to change directory&quot;);</a>
<a name="ln601">    }</a>
<a name="ln602">    return;</a>
<a name="ln603">  }</a>
<a name="ln604"> </a>
<a name="ln605">  try_end(err);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/// Gets the current line.</a>
<a name="ln609">///</a>
<a name="ln610">/// @param[out] err Error details, if any</a>
<a name="ln611">/// @return Current line string</a>
<a name="ln612">String nvim_get_current_line(Error *err)</a>
<a name="ln613">  FUNC_API_SINCE(1)</a>
<a name="ln614">{</a>
<a name="ln615">  return buffer_get_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">/// Sets the current line.</a>
<a name="ln619">///</a>
<a name="ln620">/// @param line     Line contents</a>
<a name="ln621">/// @param[out] err Error details, if any</a>
<a name="ln622">void nvim_set_current_line(String line, Error *err)</a>
<a name="ln623">  FUNC_API_SINCE(1)</a>
<a name="ln624">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln625">{</a>
<a name="ln626">  buffer_set_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, line, err);</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">/// Deletes the current line.</a>
<a name="ln630">///</a>
<a name="ln631">/// @param[out] err Error details, if any</a>
<a name="ln632">void nvim_del_current_line(Error *err)</a>
<a name="ln633">  FUNC_API_SINCE(1)</a>
<a name="ln634">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln635">{</a>
<a name="ln636">  buffer_del_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">/// Gets a global (g:) variable.</a>
<a name="ln640">///</a>
<a name="ln641">/// @param name     Variable name</a>
<a name="ln642">/// @param[out] err Error details, if any</a>
<a name="ln643">/// @return Variable value</a>
<a name="ln644">Object nvim_get_var(String name, Error *err)</a>
<a name="ln645">  FUNC_API_SINCE(1)</a>
<a name="ln646">{</a>
<a name="ln647">  dictitem_T *di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln648">  if (di == NULL) {  // try to autoload script</a>
<a name="ln649">    bool found = script_autoload(name.data, name.size, false) &amp;&amp; !aborting();</a>
<a name="ln650">    VALIDATE(found, &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln651">      return (Object)OBJECT_INIT;</a>
<a name="ln652">    });</a>
<a name="ln653">    di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln654">  }</a>
<a name="ln655">  VALIDATE((di != NULL), &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln656">    return (Object)OBJECT_INIT;</a>
<a name="ln657">  });</a>
<a name="ln658">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">/// Sets a global (g:) variable.</a>
<a name="ln662">///</a>
<a name="ln663">/// @param name     Variable name</a>
<a name="ln664">/// @param value    Variable value</a>
<a name="ln665">/// @param[out] err Error details, if any</a>
<a name="ln666">void nvim_set_var(String name, Object value, Error *err)</a>
<a name="ln667">  FUNC_API_SINCE(1)</a>
<a name="ln668">{</a>
<a name="ln669">  dict_set_var(&amp;globvardict, name, value, false, false, err);</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">/// Removes a global (g:) variable.</a>
<a name="ln673">///</a>
<a name="ln674">/// @param name     Variable name</a>
<a name="ln675">/// @param[out] err Error details, if any</a>
<a name="ln676">void nvim_del_var(String name, Error *err)</a>
<a name="ln677">  FUNC_API_SINCE(1)</a>
<a name="ln678">{</a>
<a name="ln679">  dict_set_var(&amp;globvardict, name, NIL, true, false, err);</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">/// Gets a v: variable.</a>
<a name="ln683">///</a>
<a name="ln684">/// @param name     Variable name</a>
<a name="ln685">/// @param[out] err Error details, if any</a>
<a name="ln686">/// @return         Variable value</a>
<a name="ln687">Object nvim_get_vvar(String name, Error *err)</a>
<a name="ln688">  FUNC_API_SINCE(1)</a>
<a name="ln689">{</a>
<a name="ln690">  return dict_get_value(&amp;vimvardict, name, err);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">/// Sets a v: variable, if it is not readonly.</a>
<a name="ln694">///</a>
<a name="ln695">/// @param name     Variable name</a>
<a name="ln696">/// @param value    Variable value</a>
<a name="ln697">/// @param[out] err Error details, if any</a>
<a name="ln698">void nvim_set_vvar(String name, Object value, Error *err)</a>
<a name="ln699">  FUNC_API_SINCE(6)</a>
<a name="ln700">{</a>
<a name="ln701">  dict_set_var(&amp;vimvardict, name, value, false, false, err);</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">/// Echo a message.</a>
<a name="ln705">///</a>
<a name="ln706">/// @param chunks  A list of [text, hl_group] arrays, each representing a</a>
<a name="ln707">///                text chunk with specified highlight. `hl_group` element</a>
<a name="ln708">///                can be omitted for no highlight.</a>
<a name="ln709">/// @param history  if true, add to |message-history|.</a>
<a name="ln710">/// @param opts  Optional parameters.</a>
<a name="ln711">///          - verbose: Message was printed as a result of 'verbose' option</a>
<a name="ln712">///            if Nvim was invoked with -V3log_file, the message will be</a>
<a name="ln713">///            redirected to the log_file and suppressed from direct output.</a>
<a name="ln714">void nvim_echo(Array chunks, Boolean history, Dict(echo_opts) *opts, Error *err)</a>
<a name="ln715">  FUNC_API_SINCE(7)</a>
<a name="ln716">{</a>
<a name="ln717">  HlMessage hl_msg = parse_hl_msg(chunks, err);</a>
<a name="ln718">  if (ERROR_SET(err)) {</a>
<a name="ln719">    goto error;</a>
<a name="ln720">  }</a>
<a name="ln721"> </a>
<a name="ln722">  if (opts-&gt;verbose) {</a>
<a name="ln723">    verbose_enter();</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  msg_multiattr(hl_msg, history ? &quot;echomsg&quot; : &quot;echo&quot;, history);</a>
<a name="ln727"> </a>
<a name="ln728">  if (opts-&gt;verbose) {</a>
<a name="ln729">    verbose_leave();</a>
<a name="ln730">    verbose_stop();  // flush now</a>
<a name="ln731">  }</a>
<a name="ln732"> </a>
<a name="ln733">  if (history) {</a>
<a name="ln734">    // history takes ownership</a>
<a name="ln735">    return;</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">error:</a>
<a name="ln739">  hl_msg_free(hl_msg);</a>
<a name="ln740">}</a>
<a name="ln741"> </a>
<a name="ln742">/// Writes a message to the Vim output buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln743">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln744">///</a>
<a name="ln745">/// @param str Message</a>
<a name="ln746">void nvim_out_write(String str)</a>
<a name="ln747">  FUNC_API_SINCE(1)</a>
<a name="ln748">{</a>
<a name="ln749">  write_msg(str, false, false);</a>
<a name="ln750">}</a>
<a name="ln751"> </a>
<a name="ln752">/// Writes a message to the Vim error buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln753">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln754">///</a>
<a name="ln755">/// @param str Message</a>
<a name="ln756">void nvim_err_write(String str)</a>
<a name="ln757">  FUNC_API_SINCE(1)</a>
<a name="ln758">{</a>
<a name="ln759">  write_msg(str, true, false);</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">/// Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the buffer is</a>
<a name="ln763">/// flushed (and displayed).</a>
<a name="ln764">///</a>
<a name="ln765">/// @param str Message</a>
<a name="ln766">/// @see nvim_err_write()</a>
<a name="ln767">void nvim_err_writeln(String str)</a>
<a name="ln768">  FUNC_API_SINCE(1)</a>
<a name="ln769">{</a>
<a name="ln770">  write_msg(str, true, true);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/// Gets the current list of buffer handles</a>
<a name="ln774">///</a>
<a name="ln775">/// Includes unlisted (unloaded/deleted) buffers, like `:ls!`.</a>
<a name="ln776">/// Use |nvim_buf_is_loaded()| to check if a buffer is loaded.</a>
<a name="ln777">///</a>
<a name="ln778">/// @return List of buffer handles</a>
<a name="ln779">ArrayOf(Buffer) nvim_list_bufs(void)</a>
<a name="ln780">  FUNC_API_SINCE(1)</a>
<a name="ln781">{</a>
<a name="ln782">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln783"> </a>
<a name="ln784">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln785">    rv.size++;</a>
<a name="ln786">  }</a>
<a name="ln787"> </a>
<a name="ln788">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln789">  size_t i = 0;</a>
<a name="ln790"> </a>
<a name="ln791">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln792">    rv.items[i++] = BUFFER_OBJ(b-&gt;handle);</a>
<a name="ln793">  }</a>
<a name="ln794"> </a>
<a name="ln795">  return rv;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">/// Gets the current buffer.</a>
<a name="ln799">///</a>
<a name="ln800">/// @return Buffer handle</a>
<a name="ln801">Buffer nvim_get_current_buf(void)</a>
<a name="ln802">  FUNC_API_SINCE(1)</a>
<a name="ln803">{</a>
<a name="ln804">  return curbuf-&gt;handle;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">/// Sets the current buffer.</a>
<a name="ln808">///</a>
<a name="ln809">/// @param buffer   Buffer handle</a>
<a name="ln810">/// @param[out] err Error details, if any</a>
<a name="ln811">void nvim_set_current_buf(Buffer buffer, Error *err)</a>
<a name="ln812">  FUNC_API_SINCE(1)</a>
<a name="ln813">  FUNC_API_TEXTLOCK</a>
<a name="ln814">{</a>
<a name="ln815">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln816"> </a>
<a name="ln817">  if (!buf) {</a>
<a name="ln818">    return;</a>
<a name="ln819">  }</a>
<a name="ln820"> </a>
<a name="ln821">  try_start();</a>
<a name="ln822">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum, 0);</a>
<a name="ln823">  if (!try_end(err) &amp;&amp; result == FAIL) {</a>
<a name="ln824">    api_set_error(err,</a>
<a name="ln825">                  kErrorTypeException,</a>
<a name="ln826">                  &quot;Failed to switch to buffer %d&quot;,</a>
<a name="ln827">                  buffer);</a>
<a name="ln828">  }</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">/// Gets the current list of window handles.</a>
<a name="ln832">///</a>
<a name="ln833">/// @return List of window handles</a>
<a name="ln834">ArrayOf(Window) nvim_list_wins(void)</a>
<a name="ln835">  FUNC_API_SINCE(1)</a>
<a name="ln836">{</a>
<a name="ln837">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln838"> </a>
<a name="ln839">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln840">    rv.size++;</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln844">  size_t i = 0;</a>
<a name="ln845"> </a>
<a name="ln846">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln847">    rv.items[i++] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln848">  }</a>
<a name="ln849"> </a>
<a name="ln850">  return rv;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">/// Gets the current window.</a>
<a name="ln854">///</a>
<a name="ln855">/// @return Window handle</a>
<a name="ln856">Window nvim_get_current_win(void)</a>
<a name="ln857">  FUNC_API_SINCE(1)</a>
<a name="ln858">{</a>
<a name="ln859">  return curwin-&gt;handle;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">/// Sets the current window.</a>
<a name="ln863">///</a>
<a name="ln864">/// @param window Window handle</a>
<a name="ln865">/// @param[out] err Error details, if any</a>
<a name="ln866">void nvim_set_current_win(Window window, Error *err)</a>
<a name="ln867">  FUNC_API_SINCE(1)</a>
<a name="ln868">  FUNC_API_TEXTLOCK</a>
<a name="ln869">{</a>
<a name="ln870">  win_T *win = find_window_by_handle(window, err);</a>
<a name="ln871"> </a>
<a name="ln872">  if (!win) {</a>
<a name="ln873">    return;</a>
<a name="ln874">  }</a>
<a name="ln875"> </a>
<a name="ln876">  try_start();</a>
<a name="ln877">  goto_tabpage_win(win_find_tabpage(win), win);</a>
<a name="ln878">  if (!try_end(err) &amp;&amp; win != curwin) {</a>
<a name="ln879">    api_set_error(err,</a>
<a name="ln880">                  kErrorTypeException,</a>
<a name="ln881">                  &quot;Failed to switch to window %d&quot;,</a>
<a name="ln882">                  window);</a>
<a name="ln883">  }</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">/// Creates a new, empty, unnamed buffer.</a>
<a name="ln887">///</a>
<a name="ln888">/// @param listed Sets 'buflisted'</a>
<a name="ln889">/// @param scratch Creates a &quot;throwaway&quot; |scratch-buffer| for temporary work</a>
<a name="ln890">///                (always 'nomodified'). Also sets 'nomodeline' on the buffer.</a>
<a name="ln891">/// @param[out] err Error details, if any</a>
<a name="ln892">/// @return Buffer handle, or 0 on error</a>
<a name="ln893">///</a>
<a name="ln894">/// @see buf_open_scratch</a>
<a name="ln895">Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err)</a>
<a name="ln896">  FUNC_API_SINCE(6)</a>
<a name="ln897">{</a>
<a name="ln898">  try_start();</a>
<a name="ln899">  buf_T *buf = buflist_new(NULL, NULL, (linenr_T)0,</a>
<a name="ln900">                           BLN_NOOPT | BLN_NEW | (listed ? BLN_LISTED : 0));</a>
<a name="ln901">  try_end(err);</a>
<a name="ln902">  if (buf == NULL) {</a>
<a name="ln903">    goto fail;</a>
<a name="ln904">  }</a>
<a name="ln905"> </a>
<a name="ln906">  // Open the memline for the buffer. This will avoid spurious autocmds when</a>
<a name="ln907">  // a later nvim_buf_set_lines call would have needed to &quot;open&quot; the buffer.</a>
<a name="ln908">  try_start();</a>
<a name="ln909">  block_autocmds();</a>
<a name="ln910">  int status = ml_open(buf);</a>
<a name="ln911">  unblock_autocmds();</a>
<a name="ln912">  try_end(err);</a>
<a name="ln913">  if (status == FAIL) {</a>
<a name="ln914">    goto fail;</a>
<a name="ln915">  }</a>
<a name="ln916"> </a>
<a name="ln917">  // Only strictly needed for scratch, but could just as well be consistent</a>
<a name="ln918">  // and do this now. buffer is created NOW, not when it latter first happen</a>
<a name="ln919">  // to reach a window or aucmd_prepbuf() ..</a>
<a name="ln920">  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln921"> </a>
<a name="ln922">  if (scratch) {</a>
<a name="ln923">    set_string_option_direct_in_buf(buf, &quot;bufhidden&quot;, -1, &quot;hide&quot;, OPT_LOCAL, 0);</a>
<a name="ln924">    set_string_option_direct_in_buf(buf, &quot;buftype&quot;, -1, &quot;nofile&quot;, OPT_LOCAL, 0);</a>
<a name="ln925">    assert(buf-&gt;b_ml.ml_mfp-&gt;mf_fd &lt; 0);  // ml_open() should not have opened swapfile already</a>
<a name="ln926">    buf-&gt;b_p_swf = false;</a>
<a name="ln927">    buf-&gt;b_p_ml = false;</a>
<a name="ln928">  }</a>
<a name="ln929">  return buf-&gt;b_fnum;</a>
<a name="ln930"> </a>
<a name="ln931">fail:</a>
<a name="ln932">  if (!ERROR_SET(err)) {</a>
<a name="ln933">    api_set_error(err, kErrorTypeException, &quot;Failed to create buffer&quot;);</a>
<a name="ln934">  }</a>
<a name="ln935">  return 0;</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">/// Open a terminal instance in a buffer</a>
<a name="ln939">///</a>
<a name="ln940">/// By default (and currently the only option) the terminal will not be</a>
<a name="ln941">/// connected to an external process. Instead, input send on the channel</a>
<a name="ln942">/// will be echoed directly by the terminal. This is useful to display</a>
<a name="ln943">/// ANSI terminal sequences returned as part of a rpc message, or similar.</a>
<a name="ln944">///</a>
<a name="ln945">/// Note: to directly initiate the terminal using the right size, display the</a>
<a name="ln946">/// buffer in a configured window before calling this. For instance, for a</a>
<a name="ln947">/// floating display, first create an empty buffer using |nvim_create_buf()|,</a>
<a name="ln948">/// then display it using |nvim_open_win()|, and then  call this function.</a>
<a name="ln949">/// Then |nvim_chan_send()| can be called immediately to process sequences</a>
<a name="ln950">/// in a virtual terminal having the intended size.</a>
<a name="ln951">///</a>
<a name="ln952">/// @param buffer the buffer to use (expected to be empty)</a>
<a name="ln953">/// @param opts   Optional parameters.</a>
<a name="ln954">///          - on_input: Lua callback for input sent, i e keypresses in terminal</a>
<a name="ln955">///            mode. Note: keypresses are sent raw as they would be to the pty</a>
<a name="ln956">///            master end. For instance, a carriage return is sent</a>
<a name="ln957">///            as a &quot;\r&quot;, not as a &quot;\n&quot;. |textlock| applies. It is possible</a>
<a name="ln958">///            to call |nvim_chan_send()| directly in the callback however.</a>
<a name="ln959">///                 [&quot;input&quot;, term, bufnr, data]</a>
<a name="ln960">/// @param[out] err Error details, if any</a>
<a name="ln961">/// @return Channel id, or 0 on error</a>
<a name="ln962">Integer nvim_open_term(Buffer buffer, DictionaryOf(LuaRef) opts, Error *err)</a>
<a name="ln963">  FUNC_API_SINCE(7)</a>
<a name="ln964">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln965">{</a>
<a name="ln966">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln967">  if (!buf) {</a>
<a name="ln968">    return 0;</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  if (cmdwin_type != 0 &amp;&amp; buf == curbuf) {</a>
<a name="ln972">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, e_cmdwin);</a>
<a name="ln973">    return 0;</a>
<a name="ln974">  }</a>
<a name="ln975"> </a>
<a name="ln976">  LuaRef cb = LUA_NOREF;</a>
<a name="ln977">  for (size_t i = 0; i &lt; opts.size; i++) {</a>
<a name="ln978">    String k = opts.items[i].key;</a>
<a name="ln979">    Object *v = &amp;opts.items[i].value;</a>
<a name="ln980">    if (strequal(&quot;on_input&quot;, k.data)) {</a>
<a name="ln981">      VALIDATE_T(&quot;on_input&quot;, kObjectTypeLuaRef, v-&gt;type, {</a>
<a name="ln982">        return 0;</a>
<a name="ln983">      });</a>
<a name="ln984">      cb = v-&gt;data.luaref;</a>
<a name="ln985">      v-&gt;data.luaref = LUA_NOREF;</a>
<a name="ln986">      break;</a>
<a name="ln987">    } else {</a>
<a name="ln988">      VALIDATE_S(false, &quot;'opts' key&quot;, k.data, {});</a>
<a name="ln989">    }</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  TerminalOptions topts;</a>
<a name="ln993">  Channel *chan = channel_alloc(kChannelStreamInternal);</a>
<a name="ln994">  chan-&gt;stream.internal.cb = cb;</a>
<a name="ln995">  chan-&gt;stream.internal.closed = false;</a>
<a name="ln996">  topts.data = chan;</a>
<a name="ln997">  // NB: overridden in terminal_check_size if a window is already</a>
<a name="ln998">  // displaying the buffer</a>
<a name="ln999">  topts.width = (uint16_t)MAX(curwin-&gt;w_width_inner - win_col_off(curwin), 0);</a>
<a name="ln1000">  topts.height = (uint16_t)curwin-&gt;w_height_inner;</a>
<a name="ln1001">  topts.write_cb = term_write;</a>
<a name="ln1002">  topts.resize_cb = term_resize;</a>
<a name="ln1003">  topts.close_cb = term_close;</a>
<a name="ln1004">  Terminal *term = terminal_open(buf, topts);</a>
<a name="ln1005">  terminal_check_size(term);</a>
<a name="ln1006">  chan-&gt;term = term;</a>
<a name="ln1007">  return (Integer)chan-&gt;id;</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">static void term_write(char *buf, size_t size, void *data)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln1011">{</a>
<a name="ln1012">  Channel *chan = data;</a>
<a name="ln1013">  LuaRef cb = chan-&gt;stream.internal.cb;</a>
<a name="ln1014">  if (cb == LUA_NOREF) {</a>
<a name="ln1015">    return;</a>
<a name="ln1016">  }</a>
<a name="ln1017">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln1018">  ADD_C(args, INTEGER_OBJ((Integer)chan-&gt;id));</a>
<a name="ln1019">  ADD_C(args, BUFFER_OBJ(terminal_buf(chan-&gt;term)));</a>
<a name="ln1020">  ADD_C(args, STRING_OBJ(((String){ .data = buf, .size = size })));</a>
<a name="ln1021">  textlock++;</a>
<a name="ln1022">  nlua_call_ref(cb, &quot;input&quot;, args, false, NULL);</a>
<a name="ln1023">  textlock--;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">static void term_resize(uint16_t width, uint16_t height, void *data)</a>
<a name="ln1027">{</a>
<a name="ln1028">  // TODO(bfredl): Lua callback</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">static void term_close(void *data)</a>
<a name="ln1032">{</a>
<a name="ln1033">  Channel *chan = data;</a>
<a name="ln1034">  terminal_destroy(&amp;chan-&gt;term);</a>
<a name="ln1035">  api_free_luaref(chan-&gt;stream.internal.cb);</a>
<a name="ln1036">  chan-&gt;stream.internal.cb = LUA_NOREF;</a>
<a name="ln1037">  channel_decref(chan);</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">/// Send data to channel `id`. For a job, it writes it to the</a>
<a name="ln1041">/// stdin of the process. For the stdio channel |channel-stdio|,</a>
<a name="ln1042">/// it writes to Nvim's stdout.  For an internal terminal instance</a>
<a name="ln1043">/// (|nvim_open_term()|) it writes directly to terminal output.</a>
<a name="ln1044">/// See |channel-bytes| for more information.</a>
<a name="ln1045">///</a>
<a name="ln1046">/// This function writes raw data, not RPC messages.  If the channel</a>
<a name="ln1047">/// was created with `rpc=true` then the channel expects RPC</a>
<a name="ln1048">/// messages, use |vim.rpcnotify()| and |vim.rpcrequest()| instead.</a>
<a name="ln1049">///</a>
<a name="ln1050">/// @param chan id of the channel</a>
<a name="ln1051">/// @param data data to write. 8-bit clean: can contain NUL bytes.</a>
<a name="ln1052">/// @param[out] err Error details, if any</a>
<a name="ln1053">void nvim_chan_send(Integer chan, String data, Error *err)</a>
<a name="ln1054">  FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY FUNC_API_LUA_ONLY</a>
<a name="ln1055">{</a>
<a name="ln1056">  const char *error = NULL;</a>
<a name="ln1057">  if (!data.size) {</a>
<a name="ln1058">    return;</a>
<a name="ln1059">  }</a>
<a name="ln1060"> </a>
<a name="ln1061">  channel_send((uint64_t)chan, data.data, data.size,</a>
<a name="ln1062">               false, &amp;error);</a>
<a name="ln1063">  VALIDATE(!error, &quot;%s&quot;, error, {});</a>
<a name="ln1064">}</a>
<a name="ln1065"> </a>
<a name="ln1066">/// Gets the current list of tabpage handles.</a>
<a name="ln1067">///</a>
<a name="ln1068">/// @return List of tabpage handles</a>
<a name="ln1069">ArrayOf(Tabpage) nvim_list_tabpages(void)</a>
<a name="ln1070">  FUNC_API_SINCE(1)</a>
<a name="ln1071">{</a>
<a name="ln1072">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln1073"> </a>
<a name="ln1074">  FOR_ALL_TABS(tp) {</a>
<a name="ln1075">    rv.size++;</a>
<a name="ln1076">  }</a>
<a name="ln1077"> </a>
<a name="ln1078">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln1079">  size_t i = 0;</a>
<a name="ln1080"> </a>
<a name="ln1081">  FOR_ALL_TABS(tp) {</a>
<a name="ln1082">    rv.items[i++] = TABPAGE_OBJ(tp-&gt;handle);</a>
<a name="ln1083">  }</a>
<a name="ln1084"> </a>
<a name="ln1085">  return rv;</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">/// Gets the current tabpage.</a>
<a name="ln1089">///</a>
<a name="ln1090">/// @return Tabpage handle</a>
<a name="ln1091">Tabpage nvim_get_current_tabpage(void)</a>
<a name="ln1092">  FUNC_API_SINCE(1)</a>
<a name="ln1093">{</a>
<a name="ln1094">  return curtab-&gt;handle;</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/// Sets the current tabpage.</a>
<a name="ln1098">///</a>
<a name="ln1099">/// @param tabpage  Tabpage handle</a>
<a name="ln1100">/// @param[out] err Error details, if any</a>
<a name="ln1101">void nvim_set_current_tabpage(Tabpage tabpage, Error *err)</a>
<a name="ln1102">  FUNC_API_SINCE(1)</a>
<a name="ln1103">  FUNC_API_TEXTLOCK</a>
<a name="ln1104">{</a>
<a name="ln1105">  tabpage_T *tp = find_tab_by_handle(tabpage, err);</a>
<a name="ln1106"> </a>
<a name="ln1107">  if (!tp) {</a>
<a name="ln1108">    return;</a>
<a name="ln1109">  }</a>
<a name="ln1110"> </a>
<a name="ln1111">  try_start();</a>
<a name="ln1112">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln1113">  if (!try_end(err) &amp;&amp; tp != curtab) {</a>
<a name="ln1114">    api_set_error(err,</a>
<a name="ln1115">                  kErrorTypeException,</a>
<a name="ln1116">                  &quot;Failed to switch to tabpage %d&quot;,</a>
<a name="ln1117">                  tabpage);</a>
<a name="ln1118">  }</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">/// Pastes at cursor, in any mode.</a>
<a name="ln1122">///</a>
<a name="ln1123">/// Invokes the `vim.paste` handler, which handles each mode appropriately.</a>
<a name="ln1124">/// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF (&quot;\n&quot;).</a>
<a name="ln1125">///</a>
<a name="ln1126">/// Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`</a>
<a name="ln1127">/// but do not affect the return value (which is strictly decided by</a>
<a name="ln1128">/// `vim.paste()`).  On error, subsequent calls are ignored (&quot;drained&quot;) until</a>
<a name="ln1129">/// the next paste is initiated (phase 1 or -1).</a>
<a name="ln1130">///</a>
<a name="ln1131">/// @param data  Multiline input. May be binary (containing NUL bytes).</a>
<a name="ln1132">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln1133">/// @param phase  -1: paste in a single call (i.e. without streaming).</a>
<a name="ln1134">///               To &quot;stream&quot; a paste, call `nvim_paste` sequentially with</a>
<a name="ln1135">///               these `phase` values:</a>
<a name="ln1136">///                 - 1: starts the paste (exactly once)</a>
<a name="ln1137">///                 - 2: continues the paste (zero or more times)</a>
<a name="ln1138">///                 - 3: ends the paste (exactly once)</a>
<a name="ln1139">/// @param[out] err Error details, if any</a>
<a name="ln1140">/// @return</a>
<a name="ln1141">///     - true: Client may continue pasting.</a>
<a name="ln1142">///     - false: Client must cancel the paste.</a>
<a name="ln1143">Boolean nvim_paste(String data, Boolean crlf, Integer phase, Error *err)</a>
<a name="ln1144">  FUNC_API_SINCE(6)</a>
<a name="ln1145">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1146">{</a>
<a name="ln1147">  static bool draining = false;</a>
<a name="ln1148">  bool cancel = false;</a>
<a name="ln1149"> </a>
<a name="ln1150">  VALIDATE_INT((phase &gt;= -1 &amp;&amp; phase &lt;= 3), &quot;phase&quot;, phase, {</a>
<a name="ln1151">    return false;</a>
<a name="ln1152">  });</a>
<a name="ln1153">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln1154">  Object rv = OBJECT_INIT;</a>
<a name="ln1155">  if (phase == -1 || phase == 1) {  // Start of paste-stream.</a>
<a name="ln1156">    draining = false;</a>
<a name="ln1157">  } else if (draining) {</a>
<a name="ln1158">    // Skip remaining chunks.  Report error only once per &quot;stream&quot;.</a>
<a name="ln1159">    goto theend;</a>
<a name="ln1160">  }</a>
<a name="ln1161">  Array lines = string_to_array(data, crlf);</a>
<a name="ln1162">  ADD(args, ARRAY_OBJ(lines));</a>
<a name="ln1163">  ADD(args, INTEGER_OBJ(phase));</a>
<a name="ln1164">  rv = nvim_exec_lua(STATIC_CSTR_AS_STRING(&quot;return vim.paste(...)&quot;), args,</a>
<a name="ln1165">                     err);</a>
<a name="ln1166">  if (ERROR_SET(err)) {</a>
<a name="ln1167">    draining = true;</a>
<a name="ln1168">    goto theend;</a>
<a name="ln1169">  }</a>
<a name="ln1170">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 1)) {</a>
<a name="ln1171">    ResetRedobuff();</a>
<a name="ln1172">    AppendCharToRedobuff('a');  // Dot-repeat.</a>
<a name="ln1173">  }</a>
<a name="ln1174">  // vim.paste() decides if client should cancel.  Errors do NOT cancel: we</a>
<a name="ln1175">  // want to drain remaining chunks (rather than divert them to main input).</a>
<a name="ln1176">  cancel = (rv.type == kObjectTypeBoolean &amp;&amp; !rv.data.boolean);</a>
<a name="ln1177">  if (!cancel &amp;&amp; !(State &amp; MODE_CMDLINE)) {  // Dot-repeat.</a>
<a name="ln1178">    for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1179">      String s = lines.items[i].data.string;</a>
<a name="ln1180">      assert(s.size &lt;= INT_MAX);</a>
<a name="ln1181">      AppendToRedobuffLit(s.data, (int)s.size);</a>
<a name="ln1182">      // readfile()-style: &quot;\n&quot; is indicated by presence of N+1 item.</a>
<a name="ln1183">      if (i + 1 &lt; lines.size) {</a>
<a name="ln1184">        AppendCharToRedobuff(NL);</a>
<a name="ln1185">      }</a>
<a name="ln1186">    }</a>
<a name="ln1187">  }</a>
<a name="ln1188">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 3)) {</a>
<a name="ln1189">    AppendCharToRedobuff(ESC);  // Dot-repeat.</a>
<a name="ln1190">  }</a>
<a name="ln1191">theend:</a>
<a name="ln1192">  api_free_object(rv);</a>
<a name="ln1193">  api_free_array(args);</a>
<a name="ln1194">  if (cancel || phase == -1 || phase == 3) {  // End of paste-stream.</a>
<a name="ln1195">    draining = false;</a>
<a name="ln1196">  }</a>
<a name="ln1197"> </a>
<a name="ln1198">  return !cancel;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">/// Puts text at cursor, in any mode.</a>
<a name="ln1202">///</a>
<a name="ln1203">/// Compare |:put| and |p| which are always linewise.</a>
<a name="ln1204">///</a>
<a name="ln1205">/// @param lines  |readfile()|-style list of lines. |channel-lines|</a>
<a name="ln1206">/// @param type  Edit behavior: any |getregtype()| result, or:</a>
<a name="ln1207">///              - &quot;b&quot; |blockwise-visual| mode (may include width, e.g. &quot;b3&quot;)</a>
<a name="ln1208">///              - &quot;c&quot; |charwise| mode</a>
<a name="ln1209">///              - &quot;l&quot; |linewise| mode</a>
<a name="ln1210">///              - &quot;&quot;  guess by contents, see |setreg()|</a>
<a name="ln1211">/// @param after  If true insert after cursor (like |p|), or before (like |P|).</a>
<a name="ln1212">/// @param follow  If true place cursor at end of inserted text.</a>
<a name="ln1213">/// @param[out] err Error details, if any</a>
<a name="ln1214">void nvim_put(ArrayOf(String) lines, String type, Boolean after, Boolean follow, Error *err)</a>
<a name="ln1215">  FUNC_API_SINCE(6)</a>
<a name="ln1216">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1217">{</a>
<a name="ln1218">  yankreg_T *reg = xcalloc(1, sizeof(yankreg_T));</a>
<a name="ln1219">  VALIDATE_S((prepare_yankreg_from_object(reg, type, lines.size)), &quot;type&quot;, type.data, {</a>
<a name="ln1220">    goto cleanup;</a>
<a name="ln1221">  });</a>
<a name="ln1222">  if (lines.size == 0) {</a>
<a name="ln1223">    goto cleanup;  // Nothing to do.</a>
<a name="ln1224">  }</a>
<a name="ln1225"> </a>
<a name="ln1226">  for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1227">    VALIDATE_T(&quot;line&quot;, kObjectTypeString, lines.items[i].type, {</a>
<a name="ln1228">      goto cleanup;</a>
<a name="ln1229">    });</a>
<a name="ln1230">    String line = lines.items[i].data.string;</a>
<a name="ln1231">    reg-&gt;y_array[i] = xmemdupz(line.data, line.size);</a>
<a name="ln1232">    memchrsub(reg-&gt;y_array[i], NUL, NL, line.size);</a>
<a name="ln1233">  }</a>
<a name="ln1234"> </a>
<a name="ln1235">  finish_yankreg_from_object(reg, false);</a>
<a name="ln1236"> </a>
<a name="ln1237">  TRY_WRAP(err, {</a>
<a name="ln1238">    bool VIsual_was_active = VIsual_active;</a>
<a name="ln1239">    msg_silent++;  // Avoid &quot;N more lines&quot; message.</a>
<a name="ln1240">    do_put(0, reg, after ? FORWARD : BACKWARD, 1, follow ? PUT_CURSEND : 0);</a>
<a name="ln1241">    msg_silent--;</a>
<a name="ln1242">    VIsual_active = VIsual_was_active;</a>
<a name="ln1243">  });</a>
<a name="ln1244"> </a>
<a name="ln1245">cleanup:</a>
<a name="ln1246">  free_register(reg);</a>
<a name="ln1247">  xfree(reg);</a>
<a name="ln1248">}</a>
<a name="ln1249"> </a>
<a name="ln1250">/// Subscribes to event broadcasts.</a>
<a name="ln1251">///</a>
<a name="ln1252">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1253">/// @param event      Event type string</a>
<a name="ln1254">void nvim_subscribe(uint64_t channel_id, String event)</a>
<a name="ln1255">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1256">{</a>
<a name="ln1257">  size_t length = (event.size &lt; METHOD_MAXLEN ? event.size : METHOD_MAXLEN);</a>
<a name="ln1258">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1259">  memcpy(e, event.data, length);</a>
<a name="ln1260">  e[length] = NUL;</a>
<a name="ln1261">  rpc_subscribe(channel_id, e);</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/// Unsubscribes to event broadcasts.</a>
<a name="ln1265">///</a>
<a name="ln1266">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1267">/// @param event      Event type string</a>
<a name="ln1268">void nvim_unsubscribe(uint64_t channel_id, String event)</a>
<a name="ln1269">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1270">{</a>
<a name="ln1271">  size_t length = (event.size &lt; METHOD_MAXLEN ?</a>
<a name="ln1272">                   event.size :</a>
<a name="ln1273">                   METHOD_MAXLEN);</a>
<a name="ln1274">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1275">  memcpy(e, event.data, length);</a>
<a name="ln1276">  e[length] = NUL;</a>
<a name="ln1277">  rpc_unsubscribe(channel_id, e);</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">/// Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or</a>
<a name="ln1281">/// &quot;#rrggbb&quot; hexadecimal string.</a>
<a name="ln1282">///</a>
<a name="ln1283">/// Example:</a>
<a name="ln1284">///</a>
<a name="ln1285">/// ```vim</a>
<a name="ln1286">/// :echo nvim_get_color_by_name(&quot;Pink&quot;)</a>
<a name="ln1287">/// :echo nvim_get_color_by_name(&quot;#cbcbcb&quot;)</a>
<a name="ln1288">/// ```</a>
<a name="ln1289">///</a>
<a name="ln1290">/// @param name Color name or &quot;#rrggbb&quot; string</a>
<a name="ln1291">/// @return 24-bit RGB value, or -1 for invalid argument.</a>
<a name="ln1292">Integer nvim_get_color_by_name(String name)</a>
<a name="ln1293">  FUNC_API_SINCE(1)</a>
<a name="ln1294">{</a>
<a name="ln1295">  int dummy;</a>
<a name="ln1296">  return name_to_color(name.data, &amp;dummy);</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">/// Returns a map of color names and RGB values.</a>
<a name="ln1300">///</a>
<a name="ln1301">/// Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB color values</a>
<a name="ln1302">/// (e.g. 65535).</a>
<a name="ln1303">///</a>
<a name="ln1304">/// @return Map of color names and RGB values.</a>
<a name="ln1305">Dictionary nvim_get_color_map(void)</a>
<a name="ln1306">  FUNC_API_SINCE(1)</a>
<a name="ln1307">{</a>
<a name="ln1308">  Dictionary colors = ARRAY_DICT_INIT;</a>
<a name="ln1309"> </a>
<a name="ln1310">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln1311">    PUT(colors, color_name_table[i].name,</a>
<a name="ln1312">        INTEGER_OBJ(color_name_table[i].color));</a>
<a name="ln1313">  }</a>
<a name="ln1314">  return colors;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">/// Gets a map of the current editor state.</a>
<a name="ln1318">///</a>
<a name="ln1319">/// @param opts  Optional parameters.</a>
<a name="ln1320">///               - types:  List of |context-types| (&quot;regs&quot;, &quot;jumps&quot;, &quot;bufs&quot;,</a>
<a name="ln1321">///                 &quot;gvars&quot;, …) to gather, or empty for &quot;all&quot;.</a>
<a name="ln1322">/// @param[out]  err  Error details, if any</a>
<a name="ln1323">///</a>
<a name="ln1324">/// @return map of global |context|.</a>
<a name="ln1325">Dictionary nvim_get_context(Dict(context) *opts, Error *err)</a>
<a name="ln1326">  FUNC_API_SINCE(6)</a>
<a name="ln1327">{</a>
<a name="ln1328">  Array types = ARRAY_DICT_INIT;</a>
<a name="ln1329">  if (HAS_KEY(opts, context, types)) {</a>
<a name="ln1330">    types = opts-&gt;types;</a>
<a name="ln1331">  }</a>
<a name="ln1332"> </a>
<a name="ln1333">  int int_types = types.size &gt; 0 ? 0 : kCtxAll;</a>
<a name="ln1334">  if (types.size &gt; 0) {</a>
<a name="ln1335">    for (size_t i = 0; i &lt; types.size; i++) {</a>
<a name="ln1336">      if (types.items[i].type == kObjectTypeString) {</a>
<a name="ln1337">        const char *const s = types.items[i].data.string.data;</a>
<a name="ln1338">        if (strequal(s, &quot;regs&quot;)) {</a>
<a name="ln1339">          int_types |= kCtxRegs;</a>
<a name="ln1340">        } else if (strequal(s, &quot;jumps&quot;)) {</a>
<a name="ln1341">          int_types |= kCtxJumps;</a>
<a name="ln1342">        } else if (strequal(s, &quot;bufs&quot;)) {</a>
<a name="ln1343">          int_types |= kCtxBufs;</a>
<a name="ln1344">        } else if (strequal(s, &quot;gvars&quot;)) {</a>
<a name="ln1345">          int_types |= kCtxGVars;</a>
<a name="ln1346">        } else if (strequal(s, &quot;sfuncs&quot;)) {</a>
<a name="ln1347">          int_types |= kCtxSFuncs;</a>
<a name="ln1348">        } else if (strequal(s, &quot;funcs&quot;)) {</a>
<a name="ln1349">          int_types |= kCtxFuncs;</a>
<a name="ln1350">        } else {</a>
<a name="ln1351">          VALIDATE_S(false, &quot;type&quot;, s, {</a>
<a name="ln1352">            return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1353">          });</a>
<a name="ln1354">        }</a>
<a name="ln1355">      }</a>
<a name="ln1356">    }</a>
<a name="ln1357">  }</a>
<a name="ln1358"> </a>
<a name="ln1359">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1360">  ctx_save(&amp;ctx, int_types);</a>
<a name="ln1361">  Dictionary dict = ctx_to_dict(&amp;ctx);</a>
<a name="ln1362">  ctx_free(&amp;ctx);</a>
<a name="ln1363">  return dict;</a>
<a name="ln1364">}</a>
<a name="ln1365"> </a>
<a name="ln1366">/// Sets the current editor state from the given |context| map.</a>
<a name="ln1367">///</a>
<a name="ln1368">/// @param  dict  |Context| map.</a>
<a name="ln1369">Object nvim_load_context(Dictionary dict)</a>
<a name="ln1370">  FUNC_API_SINCE(6)</a>
<a name="ln1371">{</a>
<a name="ln1372">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1373"> </a>
<a name="ln1374">  int save_did_emsg = did_emsg;</a>
<a name="ln1375">  did_emsg = false;</a>
<a name="ln1376"> </a>
<a name="ln1377">  ctx_from_dict(dict, &amp;ctx);</a>
<a name="ln1378">  if (!did_emsg) {</a>
<a name="ln1379">    ctx_restore(&amp;ctx, kCtxAll);</a>
<a name="ln1380">  }</a>
<a name="ln1381"> </a>
<a name="ln1382">  ctx_free(&amp;ctx);</a>
<a name="ln1383"> </a>
<a name="ln1384">  did_emsg = save_did_emsg;</a>
<a name="ln1385">  return (Object)OBJECT_INIT;</a>
<a name="ln1386">}</a>
<a name="ln1387"> </a>
<a name="ln1388">/// Gets the current mode. |mode()|</a>
<a name="ln1389">/// &quot;blocking&quot; is true if Nvim is waiting for input.</a>
<a name="ln1390">///</a>
<a name="ln1391">/// @returns Dictionary { &quot;mode&quot;: String, &quot;blocking&quot;: Boolean }</a>
<a name="ln1392">Dictionary nvim_get_mode(void)</a>
<a name="ln1393">  FUNC_API_SINCE(2) FUNC_API_FAST</a>
<a name="ln1394">{</a>
<a name="ln1395">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1396">  char modestr[MODE_MAX_LENGTH];</a>
<a name="ln1397">  get_mode(modestr);</a>
<a name="ln1398">  bool blocked = input_blocking();</a>
<a name="ln1399"> </a>
<a name="ln1400">  PUT(rv, &quot;mode&quot;, CSTR_TO_OBJ(modestr));</a>
<a name="ln1401">  PUT(rv, &quot;blocking&quot;, BOOLEAN_OBJ(blocked));</a>
<a name="ln1402"> </a>
<a name="ln1403">  return rv;</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">/// Gets a list of global (non-buffer-local) |mapping| definitions.</a>
<a name="ln1407">///</a>
<a name="ln1408">/// @param  mode       Mode short-name (&quot;n&quot;, &quot;i&quot;, &quot;v&quot;, ...)</a>
<a name="ln1409">/// @returns Array of |maparg()|-like dictionaries describing mappings.</a>
<a name="ln1410">///          The &quot;buffer&quot; key is always zero.</a>
<a name="ln1411">ArrayOf(Dictionary) nvim_get_keymap(String mode)</a>
<a name="ln1412">  FUNC_API_SINCE(3)</a>
<a name="ln1413">{</a>
<a name="ln1414">  return keymap_array(mode, NULL);</a>
<a name="ln1415">}</a>
<a name="ln1416"> </a>
<a name="ln1417">/// Sets a global |mapping| for the given mode.</a>
<a name="ln1418">///</a>
<a name="ln1419">/// To set a buffer-local mapping, use |nvim_buf_set_keymap()|.</a>
<a name="ln1420">///</a>
<a name="ln1421">/// Unlike |:map|, leading/trailing whitespace is accepted as part of the {lhs} or {rhs}.</a>
<a name="ln1422">/// Empty {rhs} is |&lt;Nop&gt;|. |keycodes| are replaced as usual.</a>
<a name="ln1423">///</a>
<a name="ln1424">/// Example:</a>
<a name="ln1425">///</a>
<a name="ln1426">/// ```vim</a>
<a name="ln1427">/// call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</a>
<a name="ln1428">/// ```</a>
<a name="ln1429">///</a>
<a name="ln1430">/// is equivalent to:</a>
<a name="ln1431">///</a>
<a name="ln1432">/// ```vim</a>
<a name="ln1433">/// nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</a>
<a name="ln1434">/// ```</a>
<a name="ln1435">///</a>
<a name="ln1436">/// @param channel_id</a>
<a name="ln1437">/// @param  mode  Mode short-name (map command prefix: &quot;n&quot;, &quot;i&quot;, &quot;v&quot;, &quot;x&quot;, …)</a>
<a name="ln1438">///               or &quot;!&quot; for |:map!|, or empty string for |:map|.</a>
<a name="ln1439">///               &quot;ia&quot;, &quot;ca&quot; or &quot;!a&quot; for abbreviation in Insert mode, Cmdline mode, or both, respectively</a>
<a name="ln1440">/// @param  lhs   Left-hand-side |{lhs}| of the mapping.</a>
<a name="ln1441">/// @param  rhs   Right-hand-side |{rhs}| of the mapping.</a>
<a name="ln1442">/// @param  opts  Optional parameters map: Accepts all |:map-arguments| as keys except |&lt;buffer&gt;|,</a>
<a name="ln1443">///               values are booleans (default false). Also:</a>
<a name="ln1444">///               - &quot;noremap&quot; non-recursive mapping |:noremap|</a>
<a name="ln1445">///               - &quot;desc&quot; human-readable description.</a>
<a name="ln1446">///               - &quot;callback&quot; Lua function called in place of {rhs}.</a>
<a name="ln1447">///               - &quot;replace_keycodes&quot; (boolean) When &quot;expr&quot; is true, replace keycodes in the</a>
<a name="ln1448">///                 resulting string (see |nvim_replace_termcodes()|). Returning nil from the Lua</a>
<a name="ln1449">///                 &quot;callback&quot; is equivalent to returning an empty string.</a>
<a name="ln1450">/// @param[out]   err   Error details, if any.</a>
<a name="ln1451">void nvim_set_keymap(uint64_t channel_id, String mode, String lhs, String rhs, Dict(keymap) *opts,</a>
<a name="ln1452">                     Error *err)</a>
<a name="ln1453">  FUNC_API_SINCE(6)</a>
<a name="ln1454">{</a>
<a name="ln1455">  modify_keymap(channel_id, -1, false, mode, lhs, rhs, opts, err);</a>
<a name="ln1456">}</a>
<a name="ln1457"> </a>
<a name="ln1458">/// Unmaps a global |mapping| for the given mode.</a>
<a name="ln1459">///</a>
<a name="ln1460">/// To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.</a>
<a name="ln1461">///</a>
<a name="ln1462">/// @see |nvim_set_keymap()|</a>
<a name="ln1463">void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)</a>
<a name="ln1464">  FUNC_API_SINCE(6)</a>
<a name="ln1465">{</a>
<a name="ln1466">  nvim_buf_del_keymap(channel_id, -1, mode, lhs, err);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">/// Returns a 2-tuple (Array), where item 0 is the current channel id and item</a>
<a name="ln1470">/// 1 is the |api-metadata| map (Dictionary).</a>
<a name="ln1471">///</a>
<a name="ln1472">/// @returns 2-tuple [{channel-id}, {api-metadata}]</a>
<a name="ln1473">Array nvim_get_api_info(uint64_t channel_id, Arena *arena)</a>
<a name="ln1474">  FUNC_API_SINCE(1) FUNC_API_FAST FUNC_API_REMOTE_ONLY</a>
<a name="ln1475">{</a>
<a name="ln1476">  Array rv = arena_array(arena, 2);</a>
<a name="ln1477"> </a>
<a name="ln1478">  assert(channel_id &lt;= INT64_MAX);</a>
<a name="ln1479">  ADD_C(rv, INTEGER_OBJ((int64_t)channel_id));</a>
<a name="ln1480">  ADD_C(rv, DICTIONARY_OBJ(api_metadata()));</a>
<a name="ln1481"> </a>
<a name="ln1482">  return rv;</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485">/// Self-identifies the client.</a>
<a name="ln1486">///</a>
<a name="ln1487">/// The client/plugin/application should call this after connecting, to provide</a>
<a name="ln1488">/// hints about its identity and purpose, for debugging and orchestration.</a>
<a name="ln1489">///</a>
<a name="ln1490">/// Can be called more than once; the caller should merge old info if</a>
<a name="ln1491">/// appropriate. Example: library first identifies the channel, then a plugin</a>
<a name="ln1492">/// using that library later identifies itself.</a>
<a name="ln1493">///</a>
<a name="ln1494">/// @note &quot;Something is better than nothing&quot;. You don't need to include all the</a>
<a name="ln1495">///       fields.</a>
<a name="ln1496">///</a>
<a name="ln1497">/// @param channel_id</a>
<a name="ln1498">/// @param name Short name for the connected client</a>
<a name="ln1499">/// @param version  Dictionary describing the version, with these</a>
<a name="ln1500">///                 (optional) keys:</a>
<a name="ln1501">///     - &quot;major&quot; major version (defaults to 0 if not set, for no release yet)</a>
<a name="ln1502">///     - &quot;minor&quot; minor version</a>
<a name="ln1503">///     - &quot;patch&quot; patch number</a>
<a name="ln1504">///     - &quot;prerelease&quot; string describing a prerelease, like &quot;dev&quot; or &quot;beta1&quot;</a>
<a name="ln1505">///     - &quot;commit&quot; hash or similar identifier of commit</a>
<a name="ln1506">/// @param type Must be one of the following values. Client libraries should</a>
<a name="ln1507">///             default to &quot;remote&quot; unless overridden by the user.</a>
<a name="ln1508">///     - &quot;remote&quot; remote client connected &quot;Nvim flavored&quot; MessagePack-RPC (responses</a>
<a name="ln1509">///                must be in reverse order of requests). |msgpack-rpc|</a>
<a name="ln1510">///     - &quot;msgpack-rpc&quot; remote client connected to Nvim via fully MessagePack-RPC</a>
<a name="ln1511">///                     compliant protocol.</a>
<a name="ln1512">///     - &quot;ui&quot; gui frontend</a>
<a name="ln1513">///     - &quot;embedder&quot; application using Nvim as a component (for example,</a>
<a name="ln1514">///                  IDE/editor implementing a vim mode).</a>
<a name="ln1515">///     - &quot;host&quot; plugin host, typically started by nvim</a>
<a name="ln1516">///     - &quot;plugin&quot; single plugin, started by nvim</a>
<a name="ln1517">/// @param methods Builtin methods in the client. For a host, this does not</a>
<a name="ln1518">///                include plugin methods which will be discovered later.</a>
<a name="ln1519">///                The key should be the method name, the values are dicts with</a>
<a name="ln1520">///                these (optional) keys (more keys may be added in future</a>
<a name="ln1521">///                versions of Nvim, thus unknown keys are ignored. Clients</a>
<a name="ln1522">///                must only use keys defined in this or later versions of</a>
<a name="ln1523">///                Nvim):</a>
<a name="ln1524">///     - &quot;async&quot;  if true, send as a notification. If false or unspecified,</a>
<a name="ln1525">///                use a blocking request</a>
<a name="ln1526">///     - &quot;nargs&quot; Number of arguments. Could be a single integer or an array</a>
<a name="ln1527">///                of two integers, minimum and maximum inclusive.</a>
<a name="ln1528">///</a>
<a name="ln1529">/// @param attributes Arbitrary string:string map of informal client properties.</a>
<a name="ln1530">///     Suggested keys:</a>
<a name="ln1531">///     - &quot;website&quot;: Client homepage URL (e.g. GitHub repository)</a>
<a name="ln1532">///     - &quot;license&quot;: License description (&quot;Apache 2&quot;, &quot;GPLv3&quot;, &quot;MIT&quot;, …)</a>
<a name="ln1533">///     - &quot;logo&quot;:    URI or path to image, preferably small logo or icon.</a>
<a name="ln1534">///                  .png or .svg format is preferred.</a>
<a name="ln1535">///</a>
<a name="ln1536">/// @param[out] err Error details, if any</a>
<a name="ln1537">void nvim_set_client_info(uint64_t channel_id, String name, Dictionary version, String type,</a>
<a name="ln1538">                          Dictionary methods, Dictionary attributes, Error *err)</a>
<a name="ln1539">  FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY</a>
<a name="ln1540">{</a>
<a name="ln1541">  Dictionary info = ARRAY_DICT_INIT;</a>
<a name="ln1542">  PUT(info, &quot;name&quot;, copy_object(STRING_OBJ(name), NULL));</a>
<a name="ln1543"> </a>
<a name="ln1544">  version = copy_dictionary(version, NULL);</a>
<a name="ln1545">  bool has_major = false;</a>
<a name="ln1546">  for (size_t i = 0; i &lt; version.size; i++) {</a>
<a name="ln1547">    if (strequal(version.items[i].key.data, &quot;major&quot;)) {</a>
<a name="ln1548">      has_major = true;</a>
<a name="ln1549">      break;</a>
<a name="ln1550">    }</a>
<a name="ln1551">  }</a>
<a name="ln1552">  if (!has_major) {</a>
<a name="ln1553">    PUT(version, &quot;major&quot;, INTEGER_OBJ(0));</a>
<a name="ln1554">  }</a>
<a name="ln1555">  PUT(info, &quot;version&quot;, DICTIONARY_OBJ(version));</a>
<a name="ln1556"> </a>
<a name="ln1557">  PUT(info, &quot;type&quot;, copy_object(STRING_OBJ(type), NULL));</a>
<a name="ln1558">  PUT(info, &quot;methods&quot;, DICTIONARY_OBJ(copy_dictionary(methods, NULL)));</a>
<a name="ln1559">  PUT(info, &quot;attributes&quot;, DICTIONARY_OBJ(copy_dictionary(attributes, NULL)));</a>
<a name="ln1560"> </a>
<a name="ln1561">  rpc_set_client_info(channel_id, info);</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">/// Gets information about a channel.</a>
<a name="ln1565">///</a>
<a name="ln1566">/// @returns Dictionary describing a channel, with these keys:</a>
<a name="ln1567">///    - &quot;id&quot;       Channel id.</a>
<a name="ln1568">///    - &quot;argv&quot;     (optional) Job arguments list.</a>
<a name="ln1569">///    - &quot;stream&quot;   Stream underlying the channel.</a>
<a name="ln1570">///         - &quot;stdio&quot;      stdin and stdout of this Nvim instance</a>
<a name="ln1571">///         - &quot;stderr&quot;     stderr of this Nvim instance</a>
<a name="ln1572">///         - &quot;socket&quot;     TCP/IP socket or named pipe</a>
<a name="ln1573">///         - &quot;job&quot;        Job with communication over its stdio.</a>
<a name="ln1574">///    -  &quot;mode&quot;    How data received on the channel is interpreted.</a>
<a name="ln1575">///         - &quot;bytes&quot;      Send and receive raw bytes.</a>
<a name="ln1576">///         - &quot;terminal&quot;   |terminal| instance interprets ASCII sequences.</a>
<a name="ln1577">///         - &quot;rpc&quot;        |RPC| communication on the channel is active.</a>
<a name="ln1578">///    -  &quot;pty&quot;     (optional) Name of pseudoterminal. On a POSIX system this</a>
<a name="ln1579">///                 is a device path like &quot;/dev/pts/1&quot;. If the name is unknown,</a>
<a name="ln1580">///                 the key will still be present if a pty is used (e.g. for</a>
<a name="ln1581">///                 conpty on Windows).</a>
<a name="ln1582">///    -  &quot;buffer&quot;  (optional) Buffer with connected |terminal| instance.</a>
<a name="ln1583">///    -  &quot;client&quot;  (optional) Info about the peer (client on the other end of</a>
<a name="ln1584">///                 the RPC channel), if provided by it via</a>
<a name="ln1585">///                 |nvim_set_client_info()|.</a>
<a name="ln1586">///</a>
<a name="ln1587">Dictionary nvim_get_chan_info(Integer chan, Error *err)</a>
<a name="ln1588">  FUNC_API_SINCE(4)</a>
<a name="ln1589">{</a>
<a name="ln1590">  if (chan &lt; 0) {</a>
<a name="ln1591">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1592">  }</a>
<a name="ln1593">  return channel_info((uint64_t)chan);</a>
<a name="ln1594">}</a>
<a name="ln1595"> </a>
<a name="ln1596">/// Get information about all open channels.</a>
<a name="ln1597">///</a>
<a name="ln1598">/// @returns Array of Dictionaries, each describing a channel with</a>
<a name="ln1599">///          the format specified at |nvim_get_chan_info()|.</a>
<a name="ln1600">Array nvim_list_chans(void)</a>
<a name="ln1601">  FUNC_API_SINCE(4)</a>
<a name="ln1602">{</a>
<a name="ln1603">  return channel_all_info();</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">/// Calls many API methods atomically.</a>
<a name="ln1607">///</a>
<a name="ln1608">/// This has two main usages:</a>
<a name="ln1609">/// 1. To perform several requests from an async context atomically, i.e.</a>
<a name="ln1610">///    without interleaving redraws, RPC requests from other clients, or user</a>
<a name="ln1611">///    interactions (however API methods may trigger autocommands or event</a>
<a name="ln1612">///    processing which have such side effects, e.g. |:sleep| may wake timers).</a>
<a name="ln1613">/// 2. To minimize RPC overhead (roundtrips) of a sequence of many requests.</a>
<a name="ln1614">///</a>
<a name="ln1615">/// @param channel_id</a>
<a name="ln1616">/// @param calls an array of calls, where each call is described by an array</a>
<a name="ln1617">///              with two elements: the request name, and an array of arguments.</a>
<a name="ln1618">/// @param[out] err Validation error details (malformed `calls` parameter),</a>
<a name="ln1619">///             if any. Errors from batched calls are given in the return value.</a>
<a name="ln1620">///</a>
<a name="ln1621">/// @return Array of two elements. The first is an array of return</a>
<a name="ln1622">/// values. The second is NIL if all calls succeeded. If a call resulted in</a>
<a name="ln1623">/// an error, it is a three-element array with the zero-based index of the call</a>
<a name="ln1624">/// which resulted in an error, the error type and the error message. If an</a>
<a name="ln1625">/// error occurred, the values from all preceding calls will still be returned.</a>
<a name="ln1626">Array nvim_call_atomic(uint64_t channel_id, Array calls, Arena *arena, Error *err)</a>
<a name="ln1627">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1628">{</a>
<a name="ln1629">  Array rv = arena_array(arena, 2);</a>
<a name="ln1630">  Array results = arena_array(arena, calls.size);</a>
<a name="ln1631">  Error nested_error = ERROR_INIT;</a>
<a name="ln1632"> </a>
<a name="ln1633">  size_t i;  // also used for freeing the variables</a>
<a name="ln1634">  for (i = 0; i &lt; calls.size; i++) {</a>
<a name="ln1635">    VALIDATE_T(&quot;'calls' item&quot;, kObjectTypeArray, calls.items[i].type, {</a>
<a name="ln1636">      goto theend;</a>
<a name="ln1637">    });</a>
<a name="ln1638">    Array call = calls.items[i].data.array;</a>
<a name="ln1639">    VALIDATE_EXP((call.size == 2), &quot;'calls' item&quot;, &quot;2-item Array&quot;, NULL, {</a>
<a name="ln1640">      goto theend;</a>
<a name="ln1641">    });</a>
<a name="ln1642">    VALIDATE_T(&quot;name&quot;, kObjectTypeString, call.items[0].type, {</a>
<a name="ln1643">      goto theend;</a>
<a name="ln1644">    });</a>
<a name="ln1645">    String name = call.items[0].data.string;</a>
<a name="ln1646">    VALIDATE_T(&quot;call args&quot;, kObjectTypeArray, call.items[1].type, {</a>
<a name="ln1647">      goto theend;</a>
<a name="ln1648">    });</a>
<a name="ln1649">    Array args = call.items[1].data.array;</a>
<a name="ln1650"> </a>
<a name="ln1651">    MsgpackRpcRequestHandler handler =</a>
<a name="ln1652">      msgpack_rpc_get_handler_for(name.data,</a>
<a name="ln1653">                                  name.size,</a>
<a name="ln1654">                                  &amp;nested_error);</a>
<a name="ln1655"> </a>
<a name="ln1656">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1657">      break;</a>
<a name="ln1658">    }</a>
<a name="ln1659"> </a>
<a name="ln1660">    Object result = handler.fn(channel_id, args, arena, &amp;nested_error);</a>
<a name="ln1661">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1662">      // error handled after loop</a>
<a name="ln1663">      break;</a>
<a name="ln1664">    }</a>
<a name="ln1665">    // TODO(bfredl): wasteful copy. It could be avoided to encoding to msgpack</a>
<a name="ln1666">    // directly here. But `result` might become invalid when next api function</a>
<a name="ln1667">    // is called in the loop.</a>
<a name="ln1668">    ADD_C(results, copy_object(result, arena));</a>
<a name="ln1669">    if (!handler.arena_return) {</a>
<a name="ln1670">      api_free_object(result);</a>
<a name="ln1671">    }</a>
<a name="ln1672">  }</a>
<a name="ln1673"> </a>
<a name="ln1674">  ADD_C(rv, ARRAY_OBJ(results));</a>
<a name="ln1675">  if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1676">    Array errval = arena_array(arena, 3);</a>
<a name="ln1677">    ADD_C(errval, INTEGER_OBJ((Integer)i));</a>
<a name="ln1678">    ADD_C(errval, INTEGER_OBJ(nested_error.type));</a>
<a name="ln1679">    ADD_C(errval, STRING_OBJ(copy_string(cstr_as_string(nested_error.msg), arena)));</a>
<a name="ln1680">    ADD_C(rv, ARRAY_OBJ(errval));</a>
<a name="ln1681">  } else {</a>
<a name="ln1682">    ADD_C(rv, NIL);</a>
<a name="ln1683">  }</a>
<a name="ln1684"> </a>
<a name="ln1685">theend:</a>
<a name="ln1686">  api_clear_error(&amp;nested_error);</a>
<a name="ln1687">  return rv;</a>
<a name="ln1688">}</a>
<a name="ln1689"> </a>
<a name="ln1690">/// Writes a message to vim output or error buffer. The string is split</a>
<a name="ln1691">/// and flushed after each newline. Incomplete lines are kept for writing</a>
<a name="ln1692">/// later.</a>
<a name="ln1693">///</a>
<a name="ln1694">/// @param message  Message to write</a>
<a name="ln1695">/// @param to_err   true: message is an error (uses `emsg` instead of `msg`)</a>
<a name="ln1696">/// @param writeln  Append a trailing newline</a>
<a name="ln1697">static void write_msg(String message, bool to_err, bool writeln)</a>
<a name="ln1698">{</a>
<a name="ln1699">  static StringBuilder out_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1700">  static StringBuilder err_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1701"> </a>
<a name="ln1702">#define PUSH_CHAR(c, line_buf, msg) \</a>
<a name="ln1703">  if (kv_max(line_buf) == 0) { \</a>
<a name="ln1704">    kv_resize(line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1705">  } \</a>
<a name="ln1706">  if (c == NL) { \</a>
<a name="ln1707">    kv_push(line_buf, NUL); \</a>
<a name="ln1708">    msg(line_buf.items); \</a>
<a name="ln1709">    msg_didout = true; \</a>
<a name="ln1710">    kv_drop(line_buf, kv_size(line_buf)); \</a>
<a name="ln1711">    kv_resize(line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1712">  } else { \</a>
<a name="ln1713">    kv_push(line_buf, c); \</a>
<a name="ln1714">  }</a>
<a name="ln1715"> </a>
<a name="ln1716">  no_wait_return++;</a>
<a name="ln1717">  for (uint32_t i = 0; i &lt; message.size; i++) {</a>
<a name="ln1718">    if (got_int) {</a>
<a name="ln1719">      break;</a>
<a name="ln1720">    }</a>
<a name="ln1721">    if (to_err) {</a>
<a name="ln1722">      PUSH_CHAR(message.data[i], err_line_buf, emsg);</a>
<a name="ln1723">    } else {</a>
<a name="ln1724">      PUSH_CHAR(message.data[i], out_line_buf, msg);</a>
<a name="ln1725">    }</a>
<a name="ln1726">  }</a>
<a name="ln1727">  if (writeln) {</a>
<a name="ln1728">    if (to_err) {</a>
<a name="ln1729">      PUSH_CHAR(NL, err_line_buf, emsg);</a>
<a name="ln1730">    } else {</a>
<a name="ln1731">      PUSH_CHAR(NL, out_line_buf, msg);</a>
<a name="ln1732">    }</a>
<a name="ln1733">  }</a>
<a name="ln1734">  no_wait_return--;</a>
<a name="ln1735">  msg_end();</a>
<a name="ln1736">}</a>
<a name="ln1737"> </a>
<a name="ln1738">// Functions used for testing purposes</a>
<a name="ln1739"> </a>
<a name="ln1740">/// Returns object given as argument.</a>
<a name="ln1741">///</a>
<a name="ln1742">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1743">/// in plugins.</a>
<a name="ln1744">///</a>
<a name="ln1745">/// @param[in]  obj  Object to return.</a>
<a name="ln1746">///</a>
<a name="ln1747">/// @return its argument.</a>
<a name="ln1748">Object nvim__id(Object obj)</a>
<a name="ln1749">{</a>
<a name="ln1750">  return copy_object(obj, NULL);</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">/// Returns array given as argument.</a>
<a name="ln1754">///</a>
<a name="ln1755">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1756">/// in plugins.</a>
<a name="ln1757">///</a>
<a name="ln1758">/// @param[in]  arr  Array to return.</a>
<a name="ln1759">///</a>
<a name="ln1760">/// @return its argument.</a>
<a name="ln1761">Array nvim__id_array(Array arr)</a>
<a name="ln1762">{</a>
<a name="ln1763">  return copy_array(arr, NULL);</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766">/// Returns dictionary given as argument.</a>
<a name="ln1767">///</a>
<a name="ln1768">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1769">/// in plugins.</a>
<a name="ln1770">///</a>
<a name="ln1771">/// @param[in]  dct  Dictionary to return.</a>
<a name="ln1772">///</a>
<a name="ln1773">/// @return its argument.</a>
<a name="ln1774">Dictionary nvim__id_dictionary(Dictionary dct)</a>
<a name="ln1775">{</a>
<a name="ln1776">  return copy_dictionary(dct, NULL);</a>
<a name="ln1777">}</a>
<a name="ln1778"> </a>
<a name="ln1779">/// Returns floating-point value given as argument.</a>
<a name="ln1780">///</a>
<a name="ln1781">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1782">/// in plugins.</a>
<a name="ln1783">///</a>
<a name="ln1784">/// @param[in]  flt  Value to return.</a>
<a name="ln1785">///</a>
<a name="ln1786">/// @return its argument.</a>
<a name="ln1787">Float nvim__id_float(Float flt)</a>
<a name="ln1788">{</a>
<a name="ln1789">  return flt;</a>
<a name="ln1790">}</a>
<a name="ln1791"> </a>
<a name="ln1792">/// Gets internal stats.</a>
<a name="ln1793">///</a>
<a name="ln1794">/// @return Map of various internal stats.</a>
<a name="ln1795">Dictionary nvim__stats(void)</a>
<a name="ln1796">{</a>
<a name="ln1797">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1798">  PUT(rv, &quot;fsync&quot;, INTEGER_OBJ(g_stats.fsync));</a>
<a name="ln1799">  PUT(rv, &quot;log_skip&quot;, INTEGER_OBJ(g_stats.log_skip));</a>
<a name="ln1800">  PUT(rv, &quot;lua_refcount&quot;, INTEGER_OBJ(nlua_get_global_ref_count()));</a>
<a name="ln1801">  PUT(rv, &quot;redraw&quot;, INTEGER_OBJ(g_stats.redraw));</a>
<a name="ln1802">  PUT(rv, &quot;arena_alloc_count&quot;, INTEGER_OBJ((Integer)arena_alloc_count));</a>
<a name="ln1803">  return rv;</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">/// Gets a list of dictionaries representing attached UIs.</a>
<a name="ln1807">///</a>
<a name="ln1808">/// @return Array of UI dictionaries, each with these keys:</a>
<a name="ln1809">///   - &quot;height&quot;  Requested height of the UI</a>
<a name="ln1810">///   - &quot;width&quot;   Requested width of the UI</a>
<a name="ln1811">///   - &quot;rgb&quot;     true if the UI uses RGB colors (false implies |cterm-colors|)</a>
<a name="ln1812">///   - &quot;ext_...&quot; Requested UI extensions, see |ui-option|</a>
<a name="ln1813">///   - &quot;chan&quot;    |channel-id| of remote UI</a>
<a name="ln1814">Array nvim_list_uis(void)</a>
<a name="ln1815">  FUNC_API_SINCE(4)</a>
<a name="ln1816">{</a>
<a name="ln1817">  return ui_array();</a>
<a name="ln1818">}</a>
<a name="ln1819"> </a>
<a name="ln1820">/// Gets the immediate children of process `pid`.</a>
<a name="ln1821">///</a>
<a name="ln1822">/// @return Array of child process ids, empty if process not found.</a>
<a name="ln1823">Array nvim_get_proc_children(Integer pid, Error *err)</a>
<a name="ln1824">  FUNC_API_SINCE(4)</a>
<a name="ln1825">{</a>
<a name="ln1826">  Array rvobj = ARRAY_DICT_INIT;</a>
<a name="ln1827">  int *proc_list = NULL;</a>
<a name="ln1828"> </a>
<a name="ln1829">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1830">    goto end;</a>
<a name="ln1831">  });</a>
<a name="ln1832"> </a>
<a name="ln1833">  size_t proc_count;</a>
<a name="ln1834">  int rv = os_proc_children((int)pid, &amp;proc_list, &amp;proc_count);</a>
<a name="ln1835">  if (rv == 2) {</a>
<a name="ln1836">    // syscall failed (possibly because of kernel options), try shelling out.</a>
<a name="ln1837">    DLOG(&quot;fallback to vim._os_proc_children()&quot;);</a>
<a name="ln1838">    MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1839">    ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1840">    Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_children(...)&quot;, a, err);</a>
<a name="ln1841">    if (o.type == kObjectTypeArray) {</a>
<a name="ln1842">      rvobj = o.data.array;</a>
<a name="ln1843">    } else if (!ERROR_SET(err)) {</a>
<a name="ln1844">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1845">                    &quot;Failed to get process children. pid=%&quot; PRId64 &quot; error=%d&quot;,</a>
<a name="ln1846">                    pid, rv);</a>
<a name="ln1847">    }</a>
<a name="ln1848">    goto end;</a>
<a name="ln1849">  }</a>
<a name="ln1850"> </a>
<a name="ln1851">  for (size_t i = 0; i &lt; proc_count; i++) {</a>
<a name="ln1852">    ADD(rvobj, INTEGER_OBJ(proc_list[i]));</a>
<a name="ln1853">  }</a>
<a name="ln1854"> </a>
<a name="ln1855">end:</a>
<a name="ln1856">  xfree(proc_list);</a>
<a name="ln1857">  return rvobj;</a>
<a name="ln1858">}</a>
<a name="ln1859"> </a>
<a name="ln1860">/// Gets info describing process `pid`.</a>
<a name="ln1861">///</a>
<a name="ln1862">/// @return Map of process properties, or NIL if process not found.</a>
<a name="ln1863">Object nvim_get_proc(Integer pid, Error *err)</a>
<a name="ln1864">  FUNC_API_SINCE(4)</a>
<a name="ln1865">{</a>
<a name="ln1866">  Object rvobj = OBJECT_INIT;</a>
<a name="ln1867">  rvobj.data.dictionary = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1868">  rvobj.type = kObjectTypeDictionary;</a>
<a name="ln1869"> </a>
<a name="ln1870">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1871">    return NIL;</a>
<a name="ln1872">  });</a>
<a name="ln1873"> </a>
<a name="ln1874">#ifdef MSWIN</a>
<a name="ln1875">  rvobj.data.dictionary = os_proc_info((int)pid);</a>
<a name="ln1876">  if (rvobj.data.dictionary.size == 0) {  // Process not found.</a>
<a name="ln1877">    return NIL;</a>
<a name="ln1878">  }</a>
<a name="ln1879">#else</a>
<a name="ln1880">  // Cross-platform process info APIs are miserable, so use `ps` instead.</a>
<a name="ln1881">  MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1882">  ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1883">  Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_info(...)&quot;, a, err);</a>
<a name="ln1884">  if (o.type == kObjectTypeArray &amp;&amp; o.data.array.size == 0) {</a>
<a name="ln1885">    return NIL;  // Process not found.</a>
<a name="ln1886">  } else if (o.type == kObjectTypeDictionary) {</a>
<a name="ln1887">    rvobj.data.dictionary = o.data.dictionary;</a>
<a name="ln1888">  } else if (!ERROR_SET(err)) {</a>
<a name="ln1889">    api_set_error(err, kErrorTypeException,</a>
<a name="ln1890">                  &quot;Failed to get process info. pid=%&quot; PRId64, pid);</a>
<a name="ln1891">  }</a>
<a name="ln1892">#endif</a>
<a name="ln1893">  return rvobj;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">/// Selects an item in the completion popup menu.</a>
<a name="ln1897">///</a>
<a name="ln1898">/// If neither |ins-completion| nor |cmdline-completion| popup menu is active</a>
<a name="ln1899">/// this API call is silently ignored.</a>
<a name="ln1900">/// Useful for an external UI using |ui-popupmenu| to control the popup menu with the mouse.</a>
<a name="ln1901">/// Can also be used in a mapping; use &lt;Cmd&gt; |:map-cmd| or a Lua mapping to ensure the mapping</a>
<a name="ln1902">/// doesn't end completion mode.</a>
<a name="ln1903">///</a>
<a name="ln1904">/// @param item    Index (zero-based) of the item to select. Value of -1 selects nothing</a>
<a name="ln1905">///                and restores the original text.</a>
<a name="ln1906">/// @param insert  For |ins-completion|, whether the selection should be inserted in the buffer.</a>
<a name="ln1907">///                Ignored for |cmdline-completion|.</a>
<a name="ln1908">/// @param finish  Finish the completion and dismiss the popup menu. Implies {insert}.</a>
<a name="ln1909">/// @param opts    Optional parameters. Reserved for future use.</a>
<a name="ln1910">/// @param[out] err Error details, if any</a>
<a name="ln1911">void nvim_select_popupmenu_item(Integer item, Boolean insert, Boolean finish, Dictionary opts,</a>
<a name="ln1912">                                Error *err)</a>
<a name="ln1913">  FUNC_API_SINCE(6)</a>
<a name="ln1914">{</a>
<a name="ln1915">  VALIDATE((opts.size == 0), &quot;%s&quot;, &quot;opts dict isn't empty&quot;, {</a>
<a name="ln1916">    return;</a>
<a name="ln1917">  });</a>
<a name="ln1918"> </a>
<a name="ln1919">  if (finish) {</a>
<a name="ln1920">    insert = true;</a>
<a name="ln1921">  }</a>
<a name="ln1922"> </a>
<a name="ln1923">  pum_ext_select_item((int)item, insert, finish);</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">/// NB: if your UI doesn't use hlstate, this will not return hlstate first time</a>
<a name="ln1927">Array nvim__inspect_cell(Integer grid, Integer row, Integer col, Arena *arena, Error *err)</a>
<a name="ln1928">{</a>
<a name="ln1929">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1930"> </a>
<a name="ln1931">  // TODO(bfredl): if grid == 0 we should read from the compositor's buffer.</a>
<a name="ln1932">  // The only problem is that it does not yet exist.</a>
<a name="ln1933">  ScreenGrid *g = &amp;default_grid;</a>
<a name="ln1934">  if (grid == pum_grid.handle) {</a>
<a name="ln1935">    g = &amp;pum_grid;</a>
<a name="ln1936">  } else if (grid &gt; 1) {</a>
<a name="ln1937">    win_T *wp = get_win_by_grid_handle((handle_T)grid);</a>
<a name="ln1938">    VALIDATE_INT((wp != NULL &amp;&amp; wp-&gt;w_grid_alloc.chars != NULL), &quot;grid handle&quot;, grid, {</a>
<a name="ln1939">      return ret;</a>
<a name="ln1940">    });</a>
<a name="ln1941">    g = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln1942">  }</a>
<a name="ln1943"> </a>
<a name="ln1944">  if (row &lt; 0 || row &gt;= g-&gt;rows</a>
<a name="ln1945">      || col &lt; 0 || col &gt;= g-&gt;cols) {</a>
<a name="ln1946">    return ret;</a>
<a name="ln1947">  }</a>
<a name="ln1948">  ret = arena_array(arena, 3);</a>
<a name="ln1949">  size_t off = g-&gt;line_offset[(size_t)row] + (size_t)col;</a>
<a name="ln1950">  char *sc_buf = arena_alloc(arena, MAX_SCHAR_SIZE, false);</a>
<a name="ln1951">  schar_get(sc_buf, g-&gt;chars[off]);</a>
<a name="ln1952">  ADD_C(ret, CSTR_AS_OBJ(sc_buf));</a>
<a name="ln1953">  int attr = g-&gt;attrs[off];</a>
<a name="ln1954">  ADD_C(ret, DICTIONARY_OBJ(hl_get_attr_by_id(attr, true, arena, err)));</a>
<a name="ln1955">  // will not work first time</a>
<a name="ln1956">  if (!highlight_use_hlstate()) {</a>
<a name="ln1957">    ADD_C(ret, ARRAY_OBJ(hl_inspect(attr)));</a>
<a name="ln1958">  }</a>
<a name="ln1959">  return ret;</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">void nvim__screenshot(String path)</a>
<a name="ln1963">  FUNC_API_FAST</a>
<a name="ln1964">{</a>
<a name="ln1965">  ui_call_screenshot(path);</a>
<a name="ln1966">}</a>
<a name="ln1967"> </a>
<a name="ln1968">void nvim__invalidate_glyph_cache(void)</a>
<a name="ln1969">{</a>
<a name="ln1970">  schar_cache_clear_force();</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">Object nvim__unpack(String str, Error *err)</a>
<a name="ln1974">  FUNC_API_FAST</a>
<a name="ln1975">{</a>
<a name="ln1976">  return unpack(str.data, str.size, err);</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979">/// Deletes an uppercase/file named mark. See |mark-motions|.</a>
<a name="ln1980">///</a>
<a name="ln1981">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln1982">/// @param name       Mark name</a>
<a name="ln1983">/// @return true if the mark was deleted, else false.</a>
<a name="ln1984">/// @see |nvim_buf_del_mark()|</a>
<a name="ln1985">/// @see |nvim_get_mark()|</a>
<a name="ln1986">Boolean nvim_del_mark(String name, Error *err)</a>
<a name="ln1987">  FUNC_API_SINCE(8)</a>
<a name="ln1988">{</a>
<a name="ln1989">  bool res = false;</a>
<a name="ln1990">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln1991">    return res;</a>
<a name="ln1992">  });</a>
<a name="ln1993">  // Only allow file/uppercase marks</a>
<a name="ln1994">  // TODO(muniter): Refactor this ASCII_ISUPPER macro to a proper function</a>
<a name="ln1995">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln1996">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln1997">    return res;</a>
<a name="ln1998">  });</a>
<a name="ln1999">  res = set_mark(NULL, name, 0, 0, err);</a>
<a name="ln2000">  return res;</a>
<a name="ln2001">}</a>
<a name="ln2002"> </a>
<a name="ln2003">/// Returns a `(row, col, buffer, buffername)` tuple representing the position</a>
<a name="ln2004">/// of the uppercase/file named mark. &quot;End of line&quot; column position is returned</a>
<a name="ln2005">/// as |v:maxcol| (big number). See |mark-motions|.</a>
<a name="ln2006">///</a>
<a name="ln2007">/// Marks are (1,0)-indexed. |api-indexing|</a>
<a name="ln2008">///</a>
<a name="ln2009">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln2010">/// @param name       Mark name</a>
<a name="ln2011">/// @param opts       Optional parameters. Reserved for future use.</a>
<a name="ln2012">/// @return 4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is</a>
<a name="ln2013">/// not set.</a>
<a name="ln2014">/// @see |nvim_buf_set_mark()|</a>
<a name="ln2015">/// @see |nvim_del_mark()|</a>
<a name="ln2016">Array nvim_get_mark(String name, Dictionary opts, Error *err)</a>
<a name="ln2017">  FUNC_API_SINCE(8)</a>
<a name="ln2018">{</a>
<a name="ln2019">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln2020"> </a>
<a name="ln2021">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln2022">    return rv;</a>
<a name="ln2023">  });</a>
<a name="ln2024">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln2025">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2026">    return rv;</a>
<a name="ln2027">  });</a>
<a name="ln2028"> </a>
<a name="ln2029">  xfmark_T *mark = mark_get_global(false, *name.data);  // false avoids loading the mark buffer</a>
<a name="ln2030">  pos_T pos = mark-&gt;fmark.mark;</a>
<a name="ln2031">  bool allocated = false;</a>
<a name="ln2032">  int bufnr;</a>
<a name="ln2033">  char *filename;</a>
<a name="ln2034"> </a>
<a name="ln2035">  // Marks are from an open buffer it fnum is non zero</a>
<a name="ln2036">  if (mark-&gt;fmark.fnum != 0) {</a>
<a name="ln2037">    bufnr = mark-&gt;fmark.fnum;</a>
<a name="ln2038">    filename = buflist_nr2name(bufnr, true, true);</a>
<a name="ln2039">    allocated = true;</a>
<a name="ln2040">    // Marks comes from shada</a>
<a name="ln2041">  } else {</a>
<a name="ln2042">    filename = mark-&gt;fname;</a>
<a name="ln2043">    bufnr = 0;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  bool exists = filename != NULL;</a>
<a name="ln2047">  Integer row;</a>
<a name="ln2048">  Integer col;</a>
<a name="ln2049"> </a>
<a name="ln2050">  if (!exists || pos.lnum &lt;= 0) {</a>
<a name="ln2051">    if (allocated) {</a>
<a name="ln2052">      xfree(filename);</a>
<a name="ln2053">      allocated = false;</a>
<a name="ln2054">    }</a>
<a name="ln2055">    filename = &quot;&quot;;</a>
<a name="ln2056">    bufnr = 0;</a>
<a name="ln2057">    row = 0;</a>
<a name="ln2058">    col = 0;</a>
<a name="ln2059">  } else {</a>
<a name="ln2060">    row = pos.lnum;</a>
<a name="ln2061">    col = pos.col;</a>
<a name="ln2062">  }</a>
<a name="ln2063"> </a>
<a name="ln2064">  ADD(rv, INTEGER_OBJ(row));</a>
<a name="ln2065">  ADD(rv, INTEGER_OBJ(col));</a>
<a name="ln2066">  ADD(rv, INTEGER_OBJ(bufnr));</a>
<a name="ln2067">  ADD(rv, CSTR_TO_OBJ(filename));</a>
<a name="ln2068"> </a>
<a name="ln2069">  if (allocated) {</a>
<a name="ln2070">    xfree(filename);</a>
<a name="ln2071">  }</a>
<a name="ln2072"> </a>
<a name="ln2073">  return rv;</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076">/// Evaluates statusline string.</a>
<a name="ln2077">///</a>
<a name="ln2078">/// @param str Statusline string (see 'statusline').</a>
<a name="ln2079">/// @param opts Optional parameters.</a>
<a name="ln2080">///           - winid: (number) |window-ID| of the window to use as context for statusline.</a>
<a name="ln2081">///           - maxwidth: (number) Maximum width of statusline.</a>
<a name="ln2082">///           - fillchar: (string) Character to fill blank spaces in the statusline (see</a>
<a name="ln2083">///                                'fillchars'). Treated as single-width even if it isn't.</a>
<a name="ln2084">///           - highlights: (boolean) Return highlight information.</a>
<a name="ln2085">///           - use_winbar: (boolean) Evaluate winbar instead of statusline.</a>
<a name="ln2086">///           - use_tabline: (boolean) Evaluate tabline instead of statusline. When true, {winid}</a>
<a name="ln2087">///                                    is ignored. Mutually exclusive with {use_winbar}.</a>
<a name="ln2088">///           - use_statuscol_lnum: (number) Evaluate statuscolumn for this line number instead of statusline.</a>
<a name="ln2089">///</a>
<a name="ln2090">/// @param[out] err Error details, if any.</a>
<a name="ln2091">/// @return Dictionary containing statusline information, with these keys:</a>
<a name="ln2092">///       - str: (string) Characters that will be displayed on the statusline.</a>
<a name="ln2093">///       - width: (number) Display width of the statusline.</a>
<a name="ln2094">///       - highlights: Array containing highlight information of the statusline. Only included when</a>
<a name="ln2095">///                     the &quot;highlights&quot; key in {opts} is true. Each element of the array is a</a>
<a name="ln2096">///                     |Dictionary| with these keys:</a>
<a name="ln2097">///           - start: (number) Byte index (0-based) of first character that uses the highlight.</a>
<a name="ln2098">///           - group: (string) Name of highlight group.</a>
<a name="ln2099">Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *err)</a>
<a name="ln2100">  FUNC_API_SINCE(8) FUNC_API_FAST</a>
<a name="ln2101">{</a>
<a name="ln2102">  Dictionary result = ARRAY_DICT_INIT;</a>
<a name="ln2103"> </a>
<a name="ln2104">  int maxwidth;</a>
<a name="ln2105">  int fillchar = 0;</a>
<a name="ln2106">  int statuscol_lnum = 0;</a>
<a name="ln2107">  Window window = 0;</a>
<a name="ln2108"> </a>
<a name="ln2109">  if (str.size &lt; 2 || memcmp(str.data, &quot;%!&quot;, 2) != 0) {</a>
<a name="ln2110">    const char *const errmsg = check_stl_option(str.data);</a>
<a name="ln2111">    VALIDATE(!errmsg, &quot;%s&quot;, errmsg, {</a>
<a name="ln2112">      return result;</a>
<a name="ln2113">    });</a>
<a name="ln2114">  }</a>
<a name="ln2115"> </a>
<a name="ln2116">  if (HAS_KEY(opts, eval_statusline, winid)) {</a>
<a name="ln2117">    window = opts-&gt;winid;</a>
<a name="ln2118">  }</a>
<a name="ln2119">  if (HAS_KEY(opts, eval_statusline, fillchar)) {</a>
<a name="ln2120">    VALIDATE_EXP((*opts-&gt;fillchar.data != 0</a>
<a name="ln2121">                  &amp;&amp; ((size_t)utf_ptr2len(opts-&gt;fillchar.data) == opts-&gt;fillchar.size)),</a>
<a name="ln2122">                 &quot;fillchar&quot;, &quot;single character&quot;, NULL, {</a>
<a name="ln2123">      return result;</a>
<a name="ln2124">    });</a>
<a name="ln2125">    fillchar = utf_ptr2char(opts-&gt;fillchar.data);</a>
<a name="ln2126">  }</a>
<a name="ln2127"> </a>
<a name="ln2128">  int use_bools = (int)opts-&gt;use_winbar + (int)opts-&gt;use_tabline;</a>
<a name="ln2129"> </a>
<a name="ln2130">  win_T *wp = opts-&gt;use_tabline ? curwin : find_window_by_handle(window, err);</a>
<a name="ln2131">  if (wp == NULL) {</a>
<a name="ln2132">    api_set_error(err, kErrorTypeException, &quot;unknown winid %d&quot;, window);</a>
<a name="ln2133">    return result;</a>
<a name="ln2134">  }</a>
<a name="ln2135"> </a>
<a name="ln2136">  if (HAS_KEY(opts, eval_statusline, use_statuscol_lnum)) {</a>
<a name="ln2137">    statuscol_lnum = (int)opts-&gt;use_statuscol_lnum;</a>
<a name="ln2138">    VALIDATE_RANGE(statuscol_lnum &gt; 0 &amp;&amp; statuscol_lnum &lt;= wp-&gt;w_buffer-&gt;b_ml.ml_line_count,</a>
<a name="ln2139">                   &quot;use_statuscol_lnum&quot;, {</a>
<a name="ln2140">      return result;</a>
<a name="ln2141">    });</a>
<a name="ln2142">    use_bools++;</a>
<a name="ln2143">  }</a>
<a name="ln2144">  VALIDATE(use_bools &lt;= 1, &quot;%s&quot;,</a>
<a name="ln2145">           &quot;Can only use one of 'use_winbar', 'use_tabline' and 'use_statuscol_lnum'&quot;, {</a>
<a name="ln2146">    return result;</a>
<a name="ln2147">  });</a>
<a name="ln2148"> </a>
<a name="ln2149">  int stc_hl_id = 0;</a>
<a name="ln2150">  statuscol_T statuscol = { 0 };</a>
<a name="ln2151">  SignTextAttrs sattrs[SIGN_SHOW_MAX] = { 0 };</a>
<a name="ln2152"> </a>
<a name="ln2153">  if (opts-&gt;use_tabline) {</a>
<a name="ln2154">    fillchar = ' ';</a>
<a name="ln2155">  } else {</a>
<a name="ln2156">    if (fillchar == 0) {</a>
<a name="ln2157">      if (opts-&gt;use_winbar) {</a>
<a name="ln2158">        fillchar = wp-&gt;w_p_fcs_chars.wbr;</a>
<a name="ln2159">      } else {</a>
<a name="ln2160">        int attr;</a>
<a name="ln2161">        fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln2162">      }</a>
<a name="ln2163">    }</a>
<a name="ln2164">    if (statuscol_lnum) {</a>
<a name="ln2165">      HlPriId line = { 0 };</a>
<a name="ln2166">      HlPriId cul  = { 0 };</a>
<a name="ln2167">      HlPriId num  = { 0 };</a>
<a name="ln2168">      linenr_T lnum = statuscol_lnum;</a>
<a name="ln2169">      int num_signs = buf_get_signattrs(wp-&gt;w_buffer, lnum, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2170">      decor_redraw_signs(wp-&gt;w_buffer, lnum - 1, &amp;num_signs, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2171">      wp-&gt;w_scwidth = win_signcol_count(wp);</a>
<a name="ln2172"> </a>
<a name="ln2173">      statuscol.sattrs = sattrs;</a>
<a name="ln2174">      statuscol.foldinfo = fold_info(wp, lnum);</a>
<a name="ln2175">      wp-&gt;w_cursorline = win_cursorline_standout(wp) ? wp-&gt;w_cursor.lnum : 0;</a>
<a name="ln2176"> </a>
<a name="ln2177">      if (wp-&gt;w_p_cul) {</a>
<a name="ln2178">        if (statuscol.foldinfo.fi_level != 0 &amp;&amp; statuscol.foldinfo.fi_lines &gt; 0) {</a>
<a name="ln2179">          wp-&gt;w_cursorline = statuscol.foldinfo.fi_lnum;</a>
<a name="ln2180">        }</a>
<a name="ln2181">        statuscol.use_cul = lnum == wp-&gt;w_cursorline &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR);</a>
<a name="ln2182">      }</a>
<a name="ln2183"> </a>
<a name="ln2184">      statuscol.sign_cul_id = statuscol.use_cul ? cul.hl_id : 0;</a>
<a name="ln2185">      if (num.hl_id) {</a>
<a name="ln2186">        stc_hl_id = num.hl_id;</a>
<a name="ln2187">      } else if (statuscol.use_cul) {</a>
<a name="ln2188">        stc_hl_id = HLF_CLN + 1;</a>
<a name="ln2189">      } else if (wp-&gt;w_p_rnu) {</a>
<a name="ln2190">        stc_hl_id = (lnum &lt; wp-&gt;w_cursor.lnum ? HLF_LNA : HLF_LNB) + 1;</a>
<a name="ln2191">      } else {</a>
<a name="ln2192">        stc_hl_id = HLF_N + 1;</a>
<a name="ln2193">      }</a>
<a name="ln2194"> </a>
<a name="ln2195">      set_vim_var_nr(VV_LNUM, lnum);</a>
<a name="ln2196">      set_vim_var_nr(VV_RELNUM, labs(get_cursor_rel_lnum(wp, lnum)));</a>
<a name="ln2197">      set_vim_var_nr(VV_VIRTNUM, 0);</a>
<a name="ln2198">    }</a>
<a name="ln2199">  }</a>
<a name="ln2200"> </a>
<a name="ln2201">  if (HAS_KEY(opts, eval_statusline, maxwidth)) {</a>
<a name="ln2202">    maxwidth = (int)opts-&gt;maxwidth;</a>
<a name="ln2203">  } else {</a>
<a name="ln2204">    maxwidth = statuscol_lnum ? win_col_off(wp)</a>
<a name="ln2205">               : (opts-&gt;use_tabline</a>
<a name="ln2206">                  || (!opts-&gt;use_winbar &amp;&amp; global_stl_height() &gt; 0)) ? Columns : wp-&gt;w_width;</a>
<a name="ln2207">  }</a>
<a name="ln2208"> </a>
<a name="ln2209">  char buf[MAXPATHL];</a>
<a name="ln2210">  stl_hlrec_t *hltab;</a>
<a name="ln2211"> </a>
<a name="ln2212">  // Temporarily reset 'cursorbind' to prevent side effects from moving the cursor away and back.</a>
<a name="ln2213">  int p_crb_save = wp-&gt;w_p_crb;</a>
<a name="ln2214">  wp-&gt;w_p_crb = false;</a>
<a name="ln2215"> </a>
<a name="ln2216">  int width = build_stl_str_hl(wp,</a>
<a name="ln2217">                               buf,</a>
<a name="ln2218">                               sizeof(buf),</a>
<a name="ln2219">                               str.data,</a>
<a name="ln2220">                               NULL,</a>
<a name="ln2221">                               0,</a>
<a name="ln2222">                               fillchar,</a>
<a name="ln2223">                               maxwidth,</a>
<a name="ln2224">                               opts-&gt;highlights ? &amp;hltab : NULL,</a>
<a name="ln2225">                               NULL,</a>
<a name="ln2226">                               statuscol_lnum ? &amp;statuscol : NULL);</a>
<a name="ln2227"> </a>
<a name="ln2228">  PUT(result, &quot;width&quot;, INTEGER_OBJ(width));</a>
<a name="ln2229"> </a>
<a name="ln2230">  // Restore original value of 'cursorbind'</a>
<a name="ln2231">  wp-&gt;w_p_crb = p_crb_save;</a>
<a name="ln2232"> </a>
<a name="ln2233">  if (opts-&gt;highlights) {</a>
<a name="ln2234">    Array hl_values = ARRAY_DICT_INIT;</a>
<a name="ln2235">    const char *grpname;</a>
<a name="ln2236">    char user_group[15];  // strlen(&quot;User&quot;) + strlen(&quot;2147483647&quot;) + NUL</a>
<a name="ln2237"> </a>
<a name="ln2238">    // If first character doesn't have a defined highlight,</a>
<a name="ln2239">    // add the default highlight at the beginning of the highlight list</a>
<a name="ln2240">    if (hltab-&gt;start == NULL || (hltab-&gt;start - buf) != 0) {</a>
<a name="ln2241">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2242">      grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2243"> </a>
<a name="ln2244">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(0));</a>
<a name="ln2245">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2246"> </a>
<a name="ln2247">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2248">    }</a>
<a name="ln2249"> </a>
<a name="ln2250">    for (stl_hlrec_t *sp = hltab; sp-&gt;start != NULL; sp++) {</a>
<a name="ln2251">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2252"> </a>
<a name="ln2253">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(sp-&gt;start - buf));</a>
<a name="ln2254"> </a>
<a name="ln2255">      if (sp-&gt;userhl == 0) {</a>
<a name="ln2256">        grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2257">      } else if (sp-&gt;userhl &lt; 0) {</a>
<a name="ln2258">        grpname = syn_id2name(-sp-&gt;userhl);</a>
<a name="ln2259">      } else {</a>
<a name="ln2260">        snprintf(user_group, sizeof(user_group), &quot;User%d&quot;, sp-&gt;userhl);</a>
<a name="ln2261">        grpname = user_group;</a>
<a name="ln2262">      }</a>
<a name="ln2263">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2264">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2265">    }</a>
<a name="ln2266">    PUT(result, &quot;highlights&quot;, ARRAY_OBJ(hl_values));</a>
<a name="ln2267">  }</a>
<a name="ln2268">  PUT(result, &quot;str&quot;, CSTR_TO_OBJ(buf));</a>
<a name="ln2269"> </a>
<a name="ln2270">  return result;</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">void nvim_error_event(uint64_t channel_id, Integer lvl, String data)</a>
<a name="ln2274">  FUNC_API_REMOTE_ONLY</a>
<a name="ln2275">{</a>
<a name="ln2276">  // TODO(bfredl): consider printing message to user, as will be relevant</a>
<a name="ln2277">  // if we fork nvim processes as async workers</a>
<a name="ln2278">  ELOG(&quot;async error on channel %&quot; PRId64 &quot;: %s&quot;, channel_id, data.size ? data.data : &quot;&quot;);</a>
<a name="ln2279">}</a>
</code></pre>
<div class="balloon" rel="563"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>