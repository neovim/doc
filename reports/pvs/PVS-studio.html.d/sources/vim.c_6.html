<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vim.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;stdbool.h&gt;</a>
<a name="ln8">#include &lt;stddef.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;klib/kvec.h&quot;</a>
<a name="ln14">#include &quot;lauxlib.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/keysets.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln23">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln24">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln25">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln27">#include &quot;nvim/channel.h&quot;</a>
<a name="ln28">#include &quot;nvim/context.h&quot;</a>
<a name="ln29">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln30">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln31">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval.h&quot;</a>
<a name="ln33">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln36">#include &quot;nvim/fold.h&quot;</a>
<a name="ln37">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln38">#include &quot;nvim/globals.h&quot;</a>
<a name="ln39">#include &quot;nvim/grid.h&quot;</a>
<a name="ln40">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln41">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln42">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln43">#include &quot;nvim/log.h&quot;</a>
<a name="ln44">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln45">#include &quot;nvim/macros.h&quot;</a>
<a name="ln46">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln47">#include &quot;nvim/mark.h&quot;</a>
<a name="ln48">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln49">#include &quot;nvim/memline.h&quot;</a>
<a name="ln50">#include &quot;nvim/memory.h&quot;</a>
<a name="ln51">#include &quot;nvim/message.h&quot;</a>
<a name="ln52">#include &quot;nvim/move.h&quot;</a>
<a name="ln53">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln54">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln55">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln56">#include &quot;nvim/ops.h&quot;</a>
<a name="ln57">#include &quot;nvim/option.h&quot;</a>
<a name="ln58">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln59">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln60">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln61">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln62">#include &quot;nvim/os/process.h&quot;</a>
<a name="ln63">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln64">#include &quot;nvim/pos.h&quot;</a>
<a name="ln65">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln66">#include &quot;nvim/sign.h&quot;</a>
<a name="ln67">#include &quot;nvim/state.h&quot;</a>
<a name="ln68">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln69">#include &quot;nvim/strings.h&quot;</a>
<a name="ln70">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln71">#include &quot;nvim/types.h&quot;</a>
<a name="ln72">#include &quot;nvim/ui.h&quot;</a>
<a name="ln73">#include &quot;nvim/vim.h&quot;</a>
<a name="ln74">#include &quot;nvim/window.h&quot;</a>
<a name="ln75"> </a>
<a name="ln76">#define LINE_BUFFER_MIN_SIZE 4096</a>
<a name="ln77"> </a>
<a name="ln78">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln79"># include &quot;api/vim.c.generated.h&quot;</a>
<a name="ln80">#endif</a>
<a name="ln81"> </a>
<a name="ln82">/// Gets a highlight group by name</a>
<a name="ln83">///</a>
<a name="ln84">/// similar to |hlID()|, but allocates a new ID if not present.</a>
<a name="ln85">Integer nvim_get_hl_id_by_name(String name)</a>
<a name="ln86">  FUNC_API_SINCE(7)</a>
<a name="ln87">{</a>
<a name="ln88">  return syn_check_group(name.data, name.size);</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">/// Gets all or specific highlight groups in a namespace.</a>
<a name="ln92">///</a>
<a name="ln93">/// @note When the `link` attribute is defined in the highlight definition</a>
<a name="ln94">///       map, other attributes will not be taking effect (see |:hi-link|).</a>
<a name="ln95">///</a>
<a name="ln96">/// @param ns_id Get highlight groups for namespace ns_id |nvim_get_namespaces()|.</a>
<a name="ln97">///              Use 0 to get global highlight groups |:highlight|.</a>
<a name="ln98">/// @param opts  Options dict:</a>
<a name="ln99">///                 - name: (string) Get a highlight definition by name.</a>
<a name="ln100">///                 - id: (integer) Get a highlight definition by id.</a>
<a name="ln101">///                 - link: (boolean, default true) Show linked group name instead of effective definition |:hi-link|.</a>
<a name="ln102">///                 - create: (boolean, default true) When highlight group doesn't exist create it.</a>
<a name="ln103">///</a>
<a name="ln104">/// @param[out] err Error details, if any.</a>
<a name="ln105">/// @return Highlight groups as a map from group name to a highlight definition map as in |nvim_set_hl()|,</a>
<a name="ln106">///                   or only a single highlight definition map if requested by name or id.</a>
<a name="ln107">Dictionary nvim_get_hl(Integer ns_id, Dict(get_highlight) *opts, Arena *arena, Error *err)</a>
<a name="ln108">  FUNC_API_SINCE(11)</a>
<a name="ln109">{</a>
<a name="ln110">  return ns_get_hl_defs((NS)ns_id, opts, arena, err);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">/// Sets a highlight group.</a>
<a name="ln114">///</a>
<a name="ln115">/// @note Unlike the `:highlight` command which can update a highlight group,</a>
<a name="ln116">///       this function completely replaces the definition. For example:</a>
<a name="ln117">///       ``nvim_set_hl(0, 'Visual', {})`` will clear the highlight group</a>
<a name="ln118">///       'Visual'.</a>
<a name="ln119">///</a>
<a name="ln120">/// @note The fg and bg keys also accept the string values `&quot;fg&quot;` or `&quot;bg&quot;`</a>
<a name="ln121">///       which act as aliases to the corresponding foreground and background</a>
<a name="ln122">///       values of the Normal group. If the Normal group has not been defined,</a>
<a name="ln123">///       using these values results in an error.</a>
<a name="ln124">///</a>
<a name="ln125">///</a>
<a name="ln126">/// @note If `link` is used in combination with other attributes; only the</a>
<a name="ln127">///       `link` will take effect (see |:hi-link|).</a>
<a name="ln128">///</a>
<a name="ln129">/// @param ns_id Namespace id for this highlight |nvim_create_namespace()|.</a>
<a name="ln130">///              Use 0 to set a highlight group globally |:highlight|.</a>
<a name="ln131">///              Highlights from non-global namespaces are not active by default, use</a>
<a name="ln132">///              |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to activate them.</a>
<a name="ln133">/// @param name  Highlight group name, e.g. &quot;ErrorMsg&quot;</a>
<a name="ln134">/// @param val   Highlight definition map, accepts the following keys:</a>
<a name="ln135">///                - fg (or foreground): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln136">///                - bg (or background): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln137">///                - sp (or special): color name or &quot;#RRGGBB&quot;</a>
<a name="ln138">///                - blend: integer between 0 and 100</a>
<a name="ln139">///                - bold: boolean</a>
<a name="ln140">///                - standout: boolean</a>
<a name="ln141">///                - underline: boolean</a>
<a name="ln142">///                - undercurl: boolean</a>
<a name="ln143">///                - underdouble: boolean</a>
<a name="ln144">///                - underdotted: boolean</a>
<a name="ln145">///                - underdashed: boolean</a>
<a name="ln146">///                - strikethrough: boolean</a>
<a name="ln147">///                - italic: boolean</a>
<a name="ln148">///                - reverse: boolean</a>
<a name="ln149">///                - nocombine: boolean</a>
<a name="ln150">///                - link: name of another highlight group to link to, see |:hi-link|.</a>
<a name="ln151">///                - default: Don't override existing definition |:hi-default|</a>
<a name="ln152">///                - ctermfg: Sets foreground of cterm color |ctermfg|</a>
<a name="ln153">///                - ctermbg: Sets background of cterm color |ctermbg|</a>
<a name="ln154">///                - cterm: cterm attribute map, like |highlight-args|. If not set,</a>
<a name="ln155">///                         cterm attributes will match those from the attribute map</a>
<a name="ln156">///                         documented above.</a>
<a name="ln157">///                - force: if true force update the highlight group when it exists.</a>
<a name="ln158">/// @param[out] err Error details, if any</a>
<a name="ln159">///</a>
<a name="ln160">// TODO(bfredl): val should take update vs reset flag</a>
<a name="ln161">void nvim_set_hl(Integer ns_id, String name, Dict(highlight) *val, Error *err)</a>
<a name="ln162">  FUNC_API_SINCE(7)</a>
<a name="ln163">{</a>
<a name="ln164">  int hl_id = syn_check_group(name.data, name.size);</a>
<a name="ln165">  VALIDATE_S((hl_id != 0), &quot;highlight name&quot;, name.data, {</a>
<a name="ln166">    return;</a>
<a name="ln167">  });</a>
<a name="ln168">  int link_id = -1;</a>
<a name="ln169"> </a>
<a name="ln170">  HlAttrs attrs = dict2hlattrs(val, true, &amp;link_id, err);</a>
<a name="ln171">  if (!ERROR_SET(err)) {</a>
<a name="ln172">    ns_hl_def((NS)ns_id, hl_id, attrs, link_id, val);</a>
<a name="ln173">  }</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/// Set active namespace for highlights defined with |nvim_set_hl()|. This can be set for</a>
<a name="ln177">/// a single window, see |nvim_win_set_hl_ns()|.</a>
<a name="ln178">///</a>
<a name="ln179">/// @param ns_id the namespace to use</a>
<a name="ln180">/// @param[out] err Error details, if any</a>
<a name="ln181">void nvim_set_hl_ns(Integer ns_id, Error *err)</a>
<a name="ln182">  FUNC_API_SINCE(10)</a>
<a name="ln183">{</a>
<a name="ln184">  VALIDATE_INT((ns_id &gt;= 0), &quot;namespace&quot;, ns_id, {</a>
<a name="ln185">    return;</a>
<a name="ln186">  });</a>
<a name="ln187"> </a>
<a name="ln188">  ns_hl_global = (NS)ns_id;</a>
<a name="ln189">  hl_check_ns();</a>
<a name="ln190">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">/// Set active namespace for highlights defined with |nvim_set_hl()| while redrawing.</a>
<a name="ln194">///</a>
<a name="ln195">/// This function meant to be called while redrawing, primarily from</a>
<a name="ln196">/// |nvim_set_decoration_provider()| on_win and on_line callbacks, which</a>
<a name="ln197">/// are allowed to change the namespace during a redraw cycle.</a>
<a name="ln198">///</a>
<a name="ln199">/// @param ns_id the namespace to activate</a>
<a name="ln200">/// @param[out] err Error details, if any</a>
<a name="ln201">void nvim_set_hl_ns_fast(Integer ns_id, Error *err)</a>
<a name="ln202">  FUNC_API_SINCE(10)</a>
<a name="ln203">  FUNC_API_FAST</a>
<a name="ln204">{</a>
<a name="ln205">  ns_hl_fast = (NS)ns_id;</a>
<a name="ln206">  hl_check_ns();</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/// Sends input-keys to Nvim, subject to various quirks controlled by `mode`</a>
<a name="ln210">/// flags. This is a blocking call, unlike |nvim_input()|.</a>
<a name="ln211">///</a>
<a name="ln212">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln213">///</a>
<a name="ln214">/// To input sequences like &lt;C-o&gt; use |nvim_replace_termcodes()| (typically</a>
<a name="ln215">/// with escape_ks=false) to replace |keycodes|, then pass the result to</a>
<a name="ln216">/// nvim_feedkeys().</a>
<a name="ln217">///</a>
<a name="ln218">/// Example:</a>
<a name="ln219">///</a>
<a name="ln220">/// ```vim</a>
<a name="ln221">/// :let key = nvim_replace_termcodes(&quot;&lt;C-o&gt;&quot;, v:true, v:false, v:true)</a>
<a name="ln222">/// :call nvim_feedkeys(key, 'n', v:false)</a>
<a name="ln223">/// ```</a>
<a name="ln224">///</a>
<a name="ln225">/// @param keys         to be typed</a>
<a name="ln226">/// @param mode         behavior flags, see |feedkeys()|</a>
<a name="ln227">/// @param escape_ks    If true, escape K_SPECIAL bytes in `keys`.</a>
<a name="ln228">///                     This should be false if you already used</a>
<a name="ln229">///                     |nvim_replace_termcodes()|, and true otherwise.</a>
<a name="ln230">/// @see feedkeys()</a>
<a name="ln231">/// @see vim_strsave_escape_ks</a>
<a name="ln232">void nvim_feedkeys(String keys, String mode, Boolean escape_ks)</a>
<a name="ln233">  FUNC_API_SINCE(1)</a>
<a name="ln234">{</a>
<a name="ln235">  bool remap = true;</a>
<a name="ln236">  bool insert = false;</a>
<a name="ln237">  bool typed = false;</a>
<a name="ln238">  bool execute = false;</a>
<a name="ln239">  bool dangerous = false;</a>
<a name="ln240"> </a>
<a name="ln241">  for (size_t i = 0; i &lt; mode.size; i++) {</a>
<a name="ln242">    switch (mode.data[i]) {</a>
<a name="ln243">    case 'n':</a>
<a name="ln244">      remap = false; break;</a>
<a name="ln245">    case 'm':</a>
<a name="ln246">      remap = true; break;</a>
<a name="ln247">    case 't':</a>
<a name="ln248">      typed = true; break;</a>
<a name="ln249">    case 'i':</a>
<a name="ln250">      insert = true; break;</a>
<a name="ln251">    case 'x':</a>
<a name="ln252">      execute = true; break;</a>
<a name="ln253">    case '!':</a>
<a name="ln254">      dangerous = true; break;</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  if (keys.size == 0 &amp;&amp; !execute) {</a>
<a name="ln259">    return;</a>
<a name="ln260">  }</a>
<a name="ln261"> </a>
<a name="ln262">  char *keys_esc;</a>
<a name="ln263">  if (escape_ks) {</a>
<a name="ln264">    // Need to escape K_SPECIAL before putting the string in the</a>
<a name="ln265">    // typeahead buffer.</a>
<a name="ln266">    keys_esc = vim_strsave_escape_ks(keys.data);</a>
<a name="ln267">  } else {</a>
<a name="ln268">    keys_esc = keys.data;</a>
<a name="ln269">  }</a>
<a name="ln270">  ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),</a>
<a name="ln271">              insert ? 0 : typebuf.tb_len, !typed, false);</a>
<a name="ln272">  if (vgetc_busy) {</a>
<a name="ln273">    typebuf_was_filled = true;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  if (escape_ks) {</a>
<a name="ln277">    xfree(keys_esc);</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  if (execute) {</a>
<a name="ln281">    int save_msg_scroll = msg_scroll;</a>
<a name="ln282"> </a>
<a name="ln283">    // Avoid a 1 second delay when the keys start Insert mode.</a>
<a name="ln284">    msg_scroll = false;</a>
<a name="ln285">    if (!dangerous) {</a>
<a name="ln286">      ex_normal_busy++;</a>
<a name="ln287">    }</a>
<a name="ln288">    exec_normal(true);</a>
<a name="ln289">    if (!dangerous) {</a>
<a name="ln290">      ex_normal_busy--;</a>
<a name="ln291">    }</a>
<a name="ln292">    msg_scroll |= save_msg_scroll;</a>
<a name="ln293">  }</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">/// Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level</a>
<a name="ln297">/// input buffer and the call is non-blocking (input is processed</a>
<a name="ln298">/// asynchronously by the eventloop).</a>
<a name="ln299">///</a>
<a name="ln300">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln301">///</a>
<a name="ln302">/// @note |keycodes| like &lt;CR&gt; are translated, so &quot;&lt;&quot; is special.</a>
<a name="ln303">///       To input a literal &quot;&lt;&quot;, send &lt;LT&gt;.</a>
<a name="ln304">///</a>
<a name="ln305">/// @note For mouse events use |nvim_input_mouse()|. The pseudokey form</a>
<a name="ln306">///       &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is deprecated since |api-level| 6.</a>
<a name="ln307">///</a>
<a name="ln308">/// @param keys to be typed</a>
<a name="ln309">/// @return Number of bytes actually written (can be fewer than</a>
<a name="ln310">///         requested if the buffer becomes full).</a>
<a name="ln311">Integer nvim_input(String keys)</a>
<a name="ln312">  FUNC_API_SINCE(1) FUNC_API_FAST</a>
<a name="ln313">{</a>
<a name="ln314">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln315">  return (Integer)input_enqueue(keys);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/// Send mouse event from GUI.</a>
<a name="ln319">///</a>
<a name="ln320">/// Non-blocking: does not wait on any result, but queues the event to be</a>
<a name="ln321">/// processed soon by the event loop.</a>
<a name="ln322">///</a>
<a name="ln323">/// @note Currently this doesn't support &quot;scripting&quot; multiple mouse events</a>
<a name="ln324">///       by calling it multiple times in a loop: the intermediate mouse</a>
<a name="ln325">///       positions will be ignored. It should be used to implement real-time</a>
<a name="ln326">///       mouse input in a GUI. The deprecated pseudokey form</a>
<a name="ln327">///       (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of |nvim_input()| has the same limitation.</a>
<a name="ln328">///</a>
<a name="ln329">/// @param button Mouse button: one of &quot;left&quot;, &quot;right&quot;, &quot;middle&quot;, &quot;wheel&quot;, &quot;move&quot;.</a>
<a name="ln330">/// @param action For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;, &quot;release&quot;.</a>
<a name="ln331">///               For the wheel, one of &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;. Ignored for &quot;move&quot;.</a>
<a name="ln332">/// @param modifier String of modifiers each represented by a single char.</a>
<a name="ln333">///                 The same specifiers are used as for a key press, except</a>
<a name="ln334">///                 that the &quot;-&quot; separator is optional, so &quot;C-A-&quot;, &quot;c-a&quot;</a>
<a name="ln335">///                 and &quot;CA&quot; can all be used to specify Ctrl+Alt+click.</a>
<a name="ln336">/// @param grid Grid number if the client uses |ui-multigrid|, else 0.</a>
<a name="ln337">/// @param row Mouse row-position (zero-based, like redraw events)</a>
<a name="ln338">/// @param col Mouse column-position (zero-based, like redraw events)</a>
<a name="ln339">/// @param[out] err Error details, if any</a>
<a name="ln340">void nvim_input_mouse(String button, String action, String modifier, Integer grid, Integer row,</a>
<a name="ln341">                      Integer col, Error *err)</a>
<a name="ln342">  FUNC_API_SINCE(6) FUNC_API_FAST</a>
<a name="ln343">{</a>
<a name="ln344">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln345"> </a>
<a name="ln346">  if (button.data == NULL || action.data == NULL) {</a>
<a name="ln347">    goto error;</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  int code = 0;</a>
<a name="ln351"> </a>
<a name="ln352">  if (strequal(button.data, &quot;left&quot;)) {</a>
<a name="ln353">    code = KE_LEFTMOUSE;</a>
<a name="ln354">  } else if (strequal(button.data, &quot;middle&quot;)) {</a>
<a name="ln355">    code = KE_MIDDLEMOUSE;</a>
<a name="ln356">  } else if (strequal(button.data, &quot;right&quot;)) {</a>
<a name="ln357">    code = KE_RIGHTMOUSE;</a>
<a name="ln358">  } else if (strequal(button.data, &quot;wheel&quot;)) {</a>
<a name="ln359">    code = KE_MOUSEDOWN;</a>
<a name="ln360">  } else if (strequal(button.data, &quot;move&quot;)) {</a>
<a name="ln361">    code = KE_MOUSEMOVE;</a>
<a name="ln362">  } else {</a>
<a name="ln363">    goto error;</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  if (code == KE_MOUSEDOWN) {</a>
<a name="ln367">    if (strequal(action.data, &quot;down&quot;)) {</a>
<a name="ln368">      code = KE_MOUSEUP;</a>
<a name="ln369">    } else if (strequal(action.data, &quot;up&quot;)) {</a>
<a name="ln370">      // code = KE_MOUSEDOWN</a>
<a name="ln371">    } else if (strequal(action.data, &quot;left&quot;)) {</a>
<a name="ln372">      code = KE_MOUSERIGHT;</a>
<a name="ln373">    } else if (strequal(action.data, &quot;right&quot;)) {</a>
<a name="ln374">      code = KE_MOUSELEFT;</a>
<a name="ln375">    } else {</a>
<a name="ln376">      goto error;</a>
<a name="ln377">    }</a>
<a name="ln378">  } else if (code != KE_MOUSEMOVE) {</a>
<a name="ln379">    if (strequal(action.data, &quot;press&quot;)) {</a>
<a name="ln380">      // pass</a>
<a name="ln381">    } else if (strequal(action.data, &quot;drag&quot;)) {</a>
<a name="ln382">      code += KE_LEFTDRAG - KE_LEFTMOUSE;</a>
<a name="ln383">    } else if (strequal(action.data, &quot;release&quot;)) {</a>
<a name="ln384">      code += KE_LEFTRELEASE - KE_LEFTMOUSE;</a>
<a name="ln385">    } else {</a>
<a name="ln386">      goto error;</a>
<a name="ln387">    }</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  int modmask = 0;</a>
<a name="ln391">  for (size_t i = 0; i &lt; modifier.size; i++) {</a>
<a name="ln392">    char byte = modifier.data[i];</a>
<a name="ln393">    if (byte == '-') {</a>
<a name="ln394">      continue;</a>
<a name="ln395">    }</a>
<a name="ln396">    int mod = name_to_mod_mask(byte);</a>
<a name="ln397">    VALIDATE((mod != 0), &quot;Invalid modifier: %c&quot;, byte, {</a>
<a name="ln398">      return;</a>
<a name="ln399">    });</a>
<a name="ln400">    modmask |= mod;</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  input_enqueue_mouse(code, (uint8_t)modmask, (int)grid, (int)row, (int)col);</a>
<a name="ln404">  return;</a>
<a name="ln405"> </a>
<a name="ln406">error:</a>
<a name="ln407">  api_set_error(err, kErrorTypeValidation,</a>
<a name="ln408">                &quot;invalid button or action&quot;);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">/// Replaces terminal codes and |keycodes| (&lt;CR&gt;, &lt;Esc&gt;, ...) in a string with</a>
<a name="ln412">/// the internal representation.</a>
<a name="ln413">///</a>
<a name="ln414">/// @param str        String to be converted.</a>
<a name="ln415">/// @param from_part  Legacy Vim parameter. Usually true.</a>
<a name="ln416">/// @param do_lt      Also translate &lt;lt&gt;. Ignored if `special` is false.</a>
<a name="ln417">/// @param special    Replace |keycodes|, e.g. &lt;CR&gt; becomes a &quot;\r&quot; char.</a>
<a name="ln418">/// @see replace_termcodes</a>
<a name="ln419">/// @see cpoptions</a>
<a name="ln420">String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt, Boolean special)</a>
<a name="ln421">  FUNC_API_SINCE(1)</a>
<a name="ln422">{</a>
<a name="ln423">  if (str.size == 0) {</a>
<a name="ln424">    // Empty string</a>
<a name="ln425">    return (String) { .data = NULL, .size = 0 };</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  int flags = 0;</a>
<a name="ln429">  if (from_part) {</a>
<a name="ln430">    flags |= REPTERM_FROM_PART;</a>
<a name="ln431">  }</a>
<a name="ln432">  if (do_lt) {</a>
<a name="ln433">    flags |= REPTERM_DO_LT;</a>
<a name="ln434">  }</a>
<a name="ln435">  if (!special) {</a>
<a name="ln436">    flags |= REPTERM_NO_SPECIAL;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  char *ptr = NULL;</a>
<a name="ln440">  replace_termcodes(str.data, str.size, &amp;ptr, 0, flags, NULL, CPO_TO_CPO_FLAGS);</a>
<a name="ln441">  return cstr_as_string(ptr);</a>
<a name="ln442">}</a>
<a name="ln443"> </a>
<a name="ln444">/// Execute Lua code. Parameters (if any) are available as `...` inside the</a>
<a name="ln445">/// chunk. The chunk can return a value.</a>
<a name="ln446">///</a>
<a name="ln447">/// Only statements are executed. To evaluate an expression, prefix it</a>
<a name="ln448">/// with `return`: return my_function(...)</a>
<a name="ln449">///</a>
<a name="ln450">/// @param code       Lua code to execute</a>
<a name="ln451">/// @param args       Arguments to the code</a>
<a name="ln452">/// @param[out] err   Details of an error encountered while parsing</a>
<a name="ln453">///                   or executing the Lua code.</a>
<a name="ln454">///</a>
<a name="ln455">/// @return           Return value of Lua code if present or NIL.</a>
<a name="ln456">Object nvim_exec_lua(String code, Array args, Error *err)</a>
<a name="ln457">  FUNC_API_SINCE(7)</a>
<a name="ln458">  FUNC_API_REMOTE_ONLY</a>
<a name="ln459">{</a>
<a name="ln460">  return nlua_exec(code, args, err);</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">/// Notify the user with a message</a>
<a name="ln464">///</a>
<a name="ln465">/// Relays the call to vim.notify . By default forwards your message in the</a>
<a name="ln466">/// echo area but can be overridden to trigger desktop notifications.</a>
<a name="ln467">///</a>
<a name="ln468">/// @param msg        Message to display to the user</a>
<a name="ln469">/// @param log_level  The log level</a>
<a name="ln470">/// @param opts       Reserved for future use.</a>
<a name="ln471">/// @param[out] err   Error details, if any</a>
<a name="ln472">Object nvim_notify(String msg, Integer log_level, Dictionary opts, Error *err)</a>
<a name="ln473">  FUNC_API_SINCE(7)</a>
<a name="ln474">{</a>
<a name="ln475">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln476">  ADD_C(args, STRING_OBJ(msg));</a>
<a name="ln477">  ADD_C(args, INTEGER_OBJ(log_level));</a>
<a name="ln478">  ADD_C(args, DICTIONARY_OBJ(opts));</a>
<a name="ln479"> </a>
<a name="ln480">  return NLUA_EXEC_STATIC(&quot;return vim.notify(...)&quot;, args, err);</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">/// Calculates the number of display cells occupied by `text`.</a>
<a name="ln484">/// Control characters including &lt;Tab&gt; count as one cell.</a>
<a name="ln485">///</a>
<a name="ln486">/// @param text       Some text</a>
<a name="ln487">/// @param[out] err   Error details, if any</a>
<a name="ln488">/// @return Number of cells</a>
<a name="ln489">Integer nvim_strwidth(String text, Error *err)</a>
<a name="ln490">  FUNC_API_SINCE(1)</a>
<a name="ln491">{</a>
<a name="ln492">  VALIDATE_S((text.size &lt;= INT_MAX), &quot;text length&quot;, &quot;(too long)&quot;, {</a>
<a name="ln493">    return 0;</a>
<a name="ln494">  });</a>
<a name="ln495"> </a>
<a name="ln496">  return (Integer)mb_string2cells(text.data);</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/// Gets the paths contained in |runtime-search-path|.</a>
<a name="ln500">///</a>
<a name="ln501">/// @return List of paths</a>
<a name="ln502">ArrayOf(String) nvim_list_runtime_paths(Error *err)</a>
<a name="ln503">  FUNC_API_SINCE(1)</a>
<a name="ln504">{</a>
<a name="ln505">  return nvim_get_runtime_file(NULL_STRING, true, err);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">Array nvim__runtime_inspect(void)</a>
<a name="ln509">{</a>
<a name="ln510">  return runtime_inspect();</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">/// Find files in runtime directories</a>
<a name="ln514">///</a>
<a name="ln515">/// &quot;name&quot; can contain wildcards. For example</a>
<a name="ln516">/// nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all color</a>
<a name="ln517">/// scheme files. Always use forward slashes (/) in the search pattern for</a>
<a name="ln518">/// subdirectories regardless of platform.</a>
<a name="ln519">///</a>
<a name="ln520">/// It is not an error to not find any files. An empty array is returned then.</a>
<a name="ln521">///</a>
<a name="ln522">/// @param name pattern of files to search for</a>
<a name="ln523">/// @param all whether to return all matches or only the first</a>
<a name="ln524">/// @return list of absolute paths to the found files</a>
<a name="ln525">ArrayOf(String) nvim_get_runtime_file(String name, Boolean all, Error *err)</a>
<a name="ln526">  FUNC_API_SINCE(7)</a>
<a name="ln527">  FUNC_API_FAST</a>
<a name="ln528">{</a>
<a name="ln529">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln530"> </a>
<a name="ln531">  int flags = DIP_DIRFILE | (all ? DIP_ALL : 0);</a>
<a name="ln532"> </a>
<a name="ln533">  TRY_WRAP(err, {</a>
<a name="ln534">    do_in_runtimepath((name.size ? name.data : &quot;&quot;), flags, find_runtime_cb, &amp;rv);</a>
<a name="ln535">  });</a>
<a name="ln536">  return rv;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">static bool find_runtime_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln540">{</a>
<a name="ln541">  Array *rv = (Array *)cookie;</a>
<a name="ln542">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln543">    ADD(*rv, CSTR_TO_OBJ(fnames[i]));</a>
<a name="ln544">    if (!all) {</a>
<a name="ln545">      return true;</a>
<a name="ln546">    }</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  return num_fnames &gt; 0;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">String nvim__get_lib_dir(void)</a>
<a name="ln553">{</a>
<a name="ln554">  return cstr_as_string(get_lib_dir());</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">/// Find files in runtime directories</a>
<a name="ln558">///</a>
<a name="ln559">/// @param pat pattern of files to search for</a>
<a name="ln560">/// @param all whether to return all matches or only the first</a>
<a name="ln561">/// @param opts is_lua: only search Lua subdirs</a>
<a name="ln562">/// @return list of absolute paths to the found files</a>
<a name="ln563">ArrayOf(String) nvim__get_runtime(Array pat, Boolean all, Dict(runtime) *opts, Error *err)</a>
<a name="ln564">  FUNC_API_SINCE(8)</a>
<a name="ln565">  FUNC_API_FAST</a>
<a name="ln566">{</a>
<a name="ln567">  VALIDATE((!opts-&gt;do_source || nlua_is_deferred_safe()), &quot;%s&quot;, &quot;'do_source' used in fast callback&quot;,</a>
<a name="ln568">           {});</a>
<a name="ln569">  if (ERROR_SET(err)) {</a>
<a name="ln570">    return (Array)ARRAY_DICT_INIT;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  ArrayOf(String) res = runtime_get_named(opts-&gt;is_lua, pat, all);</a>
<a name="ln574"> </a>
<a name="ln575">  if (opts-&gt;do_source) {</a>
<a name="ln576">    for (size_t i = 0; i &lt; res.size; i++) {</a>
<a name="ln577">      String name = res.items[i].data.string;</a>
<a name="ln578">      (void)do_source(name.data, false, DOSO_NONE, NULL);</a>
<a name="ln579">    }</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582">  return res;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">/// Changes the global working directory.</a>
<a name="ln586">///</a>
<a name="ln587">/// @param dir      Directory path</a>
<a name="ln588">/// @param[out] err Error details, if any</a>
<a name="ln589">void nvim_set_current_dir(String dir, Error *err)</a>
<a name="ln590">  FUNC_API_SINCE(1)</a>
<a name="ln591">{</a>
<a name="ln592">  VALIDATE_S((dir.size &lt; MAXPATHL), &quot;directory name&quot;, &quot;(too long)&quot;, {</a>
<a name="ln593">    return;</a>
<a name="ln594">  });</a>
<a name="ln595"> </a>
<a name="ln596">  char string[MAXPATHL];</a>
<a name="ln597">  memcpy(string, dir.data, dir.size);</a>
<a name="ln598">  string[dir.size] = NUL;</a>
<a name="ln599"> </a>
<a name="ln600">  try_start();</a>
<a name="ln601"> </a>
<a name="ln602">  if (!changedir_func(string, kCdScopeGlobal)) {</a>
<a name="ln603">    if (!try_end(err)) {</a>
<a name="ln604">      api_set_error(err, kErrorTypeException, &quot;Failed to change directory&quot;);</a>
<a name="ln605">    }</a>
<a name="ln606">    return;</a>
<a name="ln607">  }</a>
<a name="ln608"> </a>
<a name="ln609">  try_end(err);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">/// Gets the current line.</a>
<a name="ln613">///</a>
<a name="ln614">/// @param[out] err Error details, if any</a>
<a name="ln615">/// @return Current line string</a>
<a name="ln616">String nvim_get_current_line(Error *err)</a>
<a name="ln617">  FUNC_API_SINCE(1)</a>
<a name="ln618">{</a>
<a name="ln619">  return buffer_get_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">/// Sets the current line.</a>
<a name="ln623">///</a>
<a name="ln624">/// @param line     Line contents</a>
<a name="ln625">/// @param[out] err Error details, if any</a>
<a name="ln626">void nvim_set_current_line(String line, Error *err)</a>
<a name="ln627">  FUNC_API_SINCE(1)</a>
<a name="ln628">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln629">{</a>
<a name="ln630">  buffer_set_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, line, err);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">/// Deletes the current line.</a>
<a name="ln634">///</a>
<a name="ln635">/// @param[out] err Error details, if any</a>
<a name="ln636">void nvim_del_current_line(Error *err)</a>
<a name="ln637">  FUNC_API_SINCE(1)</a>
<a name="ln638">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln639">{</a>
<a name="ln640">  buffer_del_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">/// Gets a global (g:) variable.</a>
<a name="ln644">///</a>
<a name="ln645">/// @param name     Variable name</a>
<a name="ln646">/// @param[out] err Error details, if any</a>
<a name="ln647">/// @return Variable value</a>
<a name="ln648">Object nvim_get_var(String name, Error *err)</a>
<a name="ln649">  FUNC_API_SINCE(1)</a>
<a name="ln650">{</a>
<a name="ln651">  dictitem_T *di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln652">  if (di == NULL) {  // try to autoload script</a>
<a name="ln653">    bool found = script_autoload(name.data, name.size, false) &amp;&amp; !aborting();</a>
<a name="ln654">    VALIDATE(found, &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln655">      return (Object)OBJECT_INIT;</a>
<a name="ln656">    });</a>
<a name="ln657">    di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln658">  }</a>
<a name="ln659">  VALIDATE((di != NULL), &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln660">    return (Object)OBJECT_INIT;</a>
<a name="ln661">  });</a>
<a name="ln662">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/// Sets a global (g:) variable.</a>
<a name="ln666">///</a>
<a name="ln667">/// @param name     Variable name</a>
<a name="ln668">/// @param value    Variable value</a>
<a name="ln669">/// @param[out] err Error details, if any</a>
<a name="ln670">void nvim_set_var(String name, Object value, Error *err)</a>
<a name="ln671">  FUNC_API_SINCE(1)</a>
<a name="ln672">{</a>
<a name="ln673">  dict_set_var(&amp;globvardict, name, value, false, false, err);</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">/// Removes a global (g:) variable.</a>
<a name="ln677">///</a>
<a name="ln678">/// @param name     Variable name</a>
<a name="ln679">/// @param[out] err Error details, if any</a>
<a name="ln680">void nvim_del_var(String name, Error *err)</a>
<a name="ln681">  FUNC_API_SINCE(1)</a>
<a name="ln682">{</a>
<a name="ln683">  dict_set_var(&amp;globvardict, name, NIL, true, false, err);</a>
<a name="ln684">}</a>
<a name="ln685"> </a>
<a name="ln686">/// Gets a v: variable.</a>
<a name="ln687">///</a>
<a name="ln688">/// @param name     Variable name</a>
<a name="ln689">/// @param[out] err Error details, if any</a>
<a name="ln690">/// @return         Variable value</a>
<a name="ln691">Object nvim_get_vvar(String name, Error *err)</a>
<a name="ln692">  FUNC_API_SINCE(1)</a>
<a name="ln693">{</a>
<a name="ln694">  return dict_get_value(&amp;vimvardict, name, err);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">/// Sets a v: variable, if it is not readonly.</a>
<a name="ln698">///</a>
<a name="ln699">/// @param name     Variable name</a>
<a name="ln700">/// @param value    Variable value</a>
<a name="ln701">/// @param[out] err Error details, if any</a>
<a name="ln702">void nvim_set_vvar(String name, Object value, Error *err)</a>
<a name="ln703">  FUNC_API_SINCE(6)</a>
<a name="ln704">{</a>
<a name="ln705">  dict_set_var(&amp;vimvardict, name, value, false, false, err);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">/// Echo a message.</a>
<a name="ln709">///</a>
<a name="ln710">/// @param chunks  A list of [text, hl_group] arrays, each representing a</a>
<a name="ln711">///                text chunk with specified highlight. `hl_group` element</a>
<a name="ln712">///                can be omitted for no highlight.</a>
<a name="ln713">/// @param history  if true, add to |message-history|.</a>
<a name="ln714">/// @param opts  Optional parameters.</a>
<a name="ln715">///          - verbose: Message was printed as a result of 'verbose' option</a>
<a name="ln716">///            if Nvim was invoked with -V3log_file, the message will be</a>
<a name="ln717">///            redirected to the log_file and suppressed from direct output.</a>
<a name="ln718">void nvim_echo(Array chunks, Boolean history, Dict(echo_opts) *opts, Error *err)</a>
<a name="ln719">  FUNC_API_SINCE(7)</a>
<a name="ln720">{</a>
<a name="ln721">  HlMessage hl_msg = parse_hl_msg(chunks, err);</a>
<a name="ln722">  if (ERROR_SET(err)) {</a>
<a name="ln723">    goto error;</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  if (opts-&gt;verbose) {</a>
<a name="ln727">    verbose_enter();</a>
<a name="ln728">  }</a>
<a name="ln729"> </a>
<a name="ln730">  msg_multiattr(hl_msg, history ? &quot;echomsg&quot; : &quot;echo&quot;, history);</a>
<a name="ln731"> </a>
<a name="ln732">  if (opts-&gt;verbose) {</a>
<a name="ln733">    verbose_leave();</a>
<a name="ln734">    verbose_stop();  // flush now</a>
<a name="ln735">  }</a>
<a name="ln736"> </a>
<a name="ln737">  if (history) {</a>
<a name="ln738">    // history takes ownership</a>
<a name="ln739">    return;</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">error:</a>
<a name="ln743">  hl_msg_free(hl_msg);</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">/// Writes a message to the Vim output buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln747">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln748">///</a>
<a name="ln749">/// @param str Message</a>
<a name="ln750">void nvim_out_write(String str)</a>
<a name="ln751">  FUNC_API_SINCE(1)</a>
<a name="ln752">{</a>
<a name="ln753">  write_msg(str, false, false);</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/// Writes a message to the Vim error buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln757">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln758">///</a>
<a name="ln759">/// @param str Message</a>
<a name="ln760">void nvim_err_write(String str)</a>
<a name="ln761">  FUNC_API_SINCE(1)</a>
<a name="ln762">{</a>
<a name="ln763">  write_msg(str, true, false);</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">/// Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the buffer is</a>
<a name="ln767">/// flushed (and displayed).</a>
<a name="ln768">///</a>
<a name="ln769">/// @param str Message</a>
<a name="ln770">/// @see nvim_err_write()</a>
<a name="ln771">void nvim_err_writeln(String str)</a>
<a name="ln772">  FUNC_API_SINCE(1)</a>
<a name="ln773">{</a>
<a name="ln774">  write_msg(str, true, true);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/// Gets the current list of buffer handles</a>
<a name="ln778">///</a>
<a name="ln779">/// Includes unlisted (unloaded/deleted) buffers, like `:ls!`.</a>
<a name="ln780">/// Use |nvim_buf_is_loaded()| to check if a buffer is loaded.</a>
<a name="ln781">///</a>
<a name="ln782">/// @return List of buffer handles</a>
<a name="ln783">ArrayOf(Buffer) nvim_list_bufs(void)</a>
<a name="ln784">  FUNC_API_SINCE(1)</a>
<a name="ln785">{</a>
<a name="ln786">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln787"> </a>
<a name="ln788">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln789">    rv.size++;</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln793">  size_t i = 0;</a>
<a name="ln794"> </a>
<a name="ln795">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln796">    rv.items[i++] = BUFFER_OBJ(b-&gt;handle);</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  return rv;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">/// Gets the current buffer.</a>
<a name="ln803">///</a>
<a name="ln804">/// @return Buffer handle</a>
<a name="ln805">Buffer nvim_get_current_buf(void)</a>
<a name="ln806">  FUNC_API_SINCE(1)</a>
<a name="ln807">{</a>
<a name="ln808">  return curbuf-&gt;handle;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">/// Sets the current buffer.</a>
<a name="ln812">///</a>
<a name="ln813">/// @param buffer   Buffer handle</a>
<a name="ln814">/// @param[out] err Error details, if any</a>
<a name="ln815">void nvim_set_current_buf(Buffer buffer, Error *err)</a>
<a name="ln816">  FUNC_API_SINCE(1)</a>
<a name="ln817">  FUNC_API_TEXTLOCK</a>
<a name="ln818">{</a>
<a name="ln819">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln820"> </a>
<a name="ln821">  if (!buf) {</a>
<a name="ln822">    return;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  try_start();</a>
<a name="ln826">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum, 0);</a>
<a name="ln827">  if (!try_end(err) &amp;&amp; result == FAIL) {</a>
<a name="ln828">    api_set_error(err,</a>
<a name="ln829">                  kErrorTypeException,</a>
<a name="ln830">                  &quot;Failed to switch to buffer %d&quot;,</a>
<a name="ln831">                  buffer);</a>
<a name="ln832">  }</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">/// Gets the current list of window handles.</a>
<a name="ln836">///</a>
<a name="ln837">/// @return List of window handles</a>
<a name="ln838">ArrayOf(Window) nvim_list_wins(void)</a>
<a name="ln839">  FUNC_API_SINCE(1)</a>
<a name="ln840">{</a>
<a name="ln841">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln842"> </a>
<a name="ln843">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln844">    rv.size++;</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln848">  size_t i = 0;</a>
<a name="ln849"> </a>
<a name="ln850">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln851">    rv.items[i++] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln852">  }</a>
<a name="ln853"> </a>
<a name="ln854">  return rv;</a>
<a name="ln855">}</a>
<a name="ln856"> </a>
<a name="ln857">/// Gets the current window.</a>
<a name="ln858">///</a>
<a name="ln859">/// @return Window handle</a>
<a name="ln860">Window nvim_get_current_win(void)</a>
<a name="ln861">  FUNC_API_SINCE(1)</a>
<a name="ln862">{</a>
<a name="ln863">  return curwin-&gt;handle;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">/// Sets the current window.</a>
<a name="ln867">///</a>
<a name="ln868">/// @param window Window handle</a>
<a name="ln869">/// @param[out] err Error details, if any</a>
<a name="ln870">void nvim_set_current_win(Window window, Error *err)</a>
<a name="ln871">  FUNC_API_SINCE(1)</a>
<a name="ln872">  FUNC_API_TEXTLOCK</a>
<a name="ln873">{</a>
<a name="ln874">  win_T *win = find_window_by_handle(window, err);</a>
<a name="ln875"> </a>
<a name="ln876">  if (!win) {</a>
<a name="ln877">    return;</a>
<a name="ln878">  }</a>
<a name="ln879"> </a>
<a name="ln880">  try_start();</a>
<a name="ln881">  goto_tabpage_win(win_find_tabpage(win), win);</a>
<a name="ln882">  if (!try_end(err) &amp;&amp; win != curwin) {</a>
<a name="ln883">    api_set_error(err,</a>
<a name="ln884">                  kErrorTypeException,</a>
<a name="ln885">                  &quot;Failed to switch to window %d&quot;,</a>
<a name="ln886">                  window);</a>
<a name="ln887">  }</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">/// Creates a new, empty, unnamed buffer.</a>
<a name="ln891">///</a>
<a name="ln892">/// @param listed Sets 'buflisted'</a>
<a name="ln893">/// @param scratch Creates a &quot;throwaway&quot; |scratch-buffer| for temporary work</a>
<a name="ln894">///                (always 'nomodified'). Also sets 'nomodeline' on the buffer.</a>
<a name="ln895">/// @param[out] err Error details, if any</a>
<a name="ln896">/// @return Buffer handle, or 0 on error</a>
<a name="ln897">///</a>
<a name="ln898">/// @see buf_open_scratch</a>
<a name="ln899">Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err)</a>
<a name="ln900">  FUNC_API_SINCE(6)</a>
<a name="ln901">{</a>
<a name="ln902">  try_start();</a>
<a name="ln903">  buf_T *buf = buflist_new(NULL, NULL, (linenr_T)0,</a>
<a name="ln904">                           BLN_NOOPT | BLN_NEW | (listed ? BLN_LISTED : 0));</a>
<a name="ln905">  try_end(err);</a>
<a name="ln906">  if (buf == NULL) {</a>
<a name="ln907">    goto fail;</a>
<a name="ln908">  }</a>
<a name="ln909"> </a>
<a name="ln910">  // Open the memline for the buffer. This will avoid spurious autocmds when</a>
<a name="ln911">  // a later nvim_buf_set_lines call would have needed to &quot;open&quot; the buffer.</a>
<a name="ln912">  try_start();</a>
<a name="ln913">  block_autocmds();</a>
<a name="ln914">  int status = ml_open(buf);</a>
<a name="ln915">  unblock_autocmds();</a>
<a name="ln916">  try_end(err);</a>
<a name="ln917">  if (status == FAIL) {</a>
<a name="ln918">    goto fail;</a>
<a name="ln919">  }</a>
<a name="ln920"> </a>
<a name="ln921">  // Only strictly needed for scratch, but could just as well be consistent</a>
<a name="ln922">  // and do this now. buffer is created NOW, not when it latter first happen</a>
<a name="ln923">  // to reach a window or aucmd_prepbuf() ..</a>
<a name="ln924">  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln925"> </a>
<a name="ln926">  if (scratch) {</a>
<a name="ln927">    set_string_option_direct_in_buf(buf, &quot;bufhidden&quot;, -1, &quot;hide&quot;, OPT_LOCAL, 0);</a>
<a name="ln928">    set_string_option_direct_in_buf(buf, &quot;buftype&quot;, -1, &quot;nofile&quot;, OPT_LOCAL, 0);</a>
<a name="ln929">    assert(buf-&gt;b_ml.ml_mfp-&gt;mf_fd &lt; 0);  // ml_open() should not have opened swapfile already</a>
<a name="ln930">    buf-&gt;b_p_swf = false;</a>
<a name="ln931">    buf-&gt;b_p_ml = false;</a>
<a name="ln932">  }</a>
<a name="ln933">  return buf-&gt;b_fnum;</a>
<a name="ln934"> </a>
<a name="ln935">fail:</a>
<a name="ln936">  if (!ERROR_SET(err)) {</a>
<a name="ln937">    api_set_error(err, kErrorTypeException, &quot;Failed to create buffer&quot;);</a>
<a name="ln938">  }</a>
<a name="ln939">  return 0;</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">/// Open a terminal instance in a buffer</a>
<a name="ln943">///</a>
<a name="ln944">/// By default (and currently the only option) the terminal will not be</a>
<a name="ln945">/// connected to an external process. Instead, input send on the channel</a>
<a name="ln946">/// will be echoed directly by the terminal. This is useful to display</a>
<a name="ln947">/// ANSI terminal sequences returned as part of a rpc message, or similar.</a>
<a name="ln948">///</a>
<a name="ln949">/// Note: to directly initiate the terminal using the right size, display the</a>
<a name="ln950">/// buffer in a configured window before calling this. For instance, for a</a>
<a name="ln951">/// floating display, first create an empty buffer using |nvim_create_buf()|,</a>
<a name="ln952">/// then display it using |nvim_open_win()|, and then  call this function.</a>
<a name="ln953">/// Then |nvim_chan_send()| can be called immediately to process sequences</a>
<a name="ln954">/// in a virtual terminal having the intended size.</a>
<a name="ln955">///</a>
<a name="ln956">/// @param buffer the buffer to use (expected to be empty)</a>
<a name="ln957">/// @param opts   Optional parameters.</a>
<a name="ln958">///          - on_input: Lua callback for input sent, i e keypresses in terminal</a>
<a name="ln959">///            mode. Note: keypresses are sent raw as they would be to the pty</a>
<a name="ln960">///            master end. For instance, a carriage return is sent</a>
<a name="ln961">///            as a &quot;\r&quot;, not as a &quot;\n&quot;. |textlock| applies. It is possible</a>
<a name="ln962">///            to call |nvim_chan_send()| directly in the callback however.</a>
<a name="ln963">///                 [&quot;input&quot;, term, bufnr, data]</a>
<a name="ln964">/// @param[out] err Error details, if any</a>
<a name="ln965">/// @return Channel id, or 0 on error</a>
<a name="ln966">Integer nvim_open_term(Buffer buffer, DictionaryOf(LuaRef) opts, Error *err)</a>
<a name="ln967">  FUNC_API_SINCE(7)</a>
<a name="ln968">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln969">{</a>
<a name="ln970">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln971">  if (!buf) {</a>
<a name="ln972">    return 0;</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  if (cmdwin_type != 0 &amp;&amp; buf == curbuf) {</a>
<a name="ln976">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, e_cmdwin);</a>
<a name="ln977">    return 0;</a>
<a name="ln978">  }</a>
<a name="ln979"> </a>
<a name="ln980">  LuaRef cb = LUA_NOREF;</a>
<a name="ln981">  for (size_t i = 0; i &lt; opts.size; i++) {</a>
<a name="ln982">    String k = opts.items[i].key;</a>
<a name="ln983">    Object *v = &amp;opts.items[i].value;</a>
<a name="ln984">    if (strequal(&quot;on_input&quot;, k.data)) {</a>
<a name="ln985">      VALIDATE_T(&quot;on_input&quot;, kObjectTypeLuaRef, v-&gt;type, {</a>
<a name="ln986">        return 0;</a>
<a name="ln987">      });</a>
<a name="ln988">      cb = v-&gt;data.luaref;</a>
<a name="ln989">      v-&gt;data.luaref = LUA_NOREF;</a>
<a name="ln990">      break;</a>
<a name="ln991">    } else {</a>
<a name="ln992">      VALIDATE_S(false, &quot;'opts' key&quot;, k.data, {});</a>
<a name="ln993">    }</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  TerminalOptions topts;</a>
<a name="ln997">  Channel *chan = channel_alloc(kChannelStreamInternal);</a>
<a name="ln998">  chan-&gt;stream.internal.cb = cb;</a>
<a name="ln999">  chan-&gt;stream.internal.closed = false;</a>
<a name="ln1000">  topts.data = chan;</a>
<a name="ln1001">  // NB: overridden in terminal_check_size if a window is already</a>
<a name="ln1002">  // displaying the buffer</a>
<a name="ln1003">  topts.width = (uint16_t)MAX(curwin-&gt;w_width_inner - win_col_off(curwin), 0);</a>
<a name="ln1004">  topts.height = (uint16_t)curwin-&gt;w_height_inner;</a>
<a name="ln1005">  topts.write_cb = term_write;</a>
<a name="ln1006">  topts.resize_cb = term_resize;</a>
<a name="ln1007">  topts.close_cb = term_close;</a>
<a name="ln1008">  Terminal *term = terminal_open(buf, topts);</a>
<a name="ln1009">  terminal_check_size(term);</a>
<a name="ln1010">  chan-&gt;term = term;</a>
<a name="ln1011">  return (Integer)chan-&gt;id;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">static void term_write(char *buf, size_t size, void *data)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln1015">{</a>
<a name="ln1016">  Channel *chan = data;</a>
<a name="ln1017">  LuaRef cb = chan-&gt;stream.internal.cb;</a>
<a name="ln1018">  if (cb == LUA_NOREF) {</a>
<a name="ln1019">    return;</a>
<a name="ln1020">  }</a>
<a name="ln1021">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln1022">  ADD_C(args, INTEGER_OBJ((Integer)chan-&gt;id));</a>
<a name="ln1023">  ADD_C(args, BUFFER_OBJ(terminal_buf(chan-&gt;term)));</a>
<a name="ln1024">  ADD_C(args, STRING_OBJ(((String){ .data = buf, .size = size })));</a>
<a name="ln1025">  textlock++;</a>
<a name="ln1026">  nlua_call_ref(cb, &quot;input&quot;, args, false, NULL);</a>
<a name="ln1027">  textlock--;</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">static void term_resize(uint16_t width, uint16_t height, void *data)</a>
<a name="ln1031">{</a>
<a name="ln1032">  // TODO(bfredl): Lua callback</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">static void term_close(void *data)</a>
<a name="ln1036">{</a>
<a name="ln1037">  Channel *chan = data;</a>
<a name="ln1038">  terminal_destroy(&amp;chan-&gt;term);</a>
<a name="ln1039">  api_free_luaref(chan-&gt;stream.internal.cb);</a>
<a name="ln1040">  chan-&gt;stream.internal.cb = LUA_NOREF;</a>
<a name="ln1041">  channel_decref(chan);</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/// Send data to channel `id`. For a job, it writes it to the</a>
<a name="ln1045">/// stdin of the process. For the stdio channel |channel-stdio|,</a>
<a name="ln1046">/// it writes to Nvim's stdout.  For an internal terminal instance</a>
<a name="ln1047">/// (|nvim_open_term()|) it writes directly to terminal output.</a>
<a name="ln1048">/// See |channel-bytes| for more information.</a>
<a name="ln1049">///</a>
<a name="ln1050">/// This function writes raw data, not RPC messages.  If the channel</a>
<a name="ln1051">/// was created with `rpc=true` then the channel expects RPC</a>
<a name="ln1052">/// messages, use |vim.rpcnotify()| and |vim.rpcrequest()| instead.</a>
<a name="ln1053">///</a>
<a name="ln1054">/// @param chan id of the channel</a>
<a name="ln1055">/// @param data data to write. 8-bit clean: can contain NUL bytes.</a>
<a name="ln1056">/// @param[out] err Error details, if any</a>
<a name="ln1057">void nvim_chan_send(Integer chan, String data, Error *err)</a>
<a name="ln1058">  FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY FUNC_API_LUA_ONLY</a>
<a name="ln1059">{</a>
<a name="ln1060">  const char *error = NULL;</a>
<a name="ln1061">  if (!data.size) {</a>
<a name="ln1062">    return;</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  channel_send((uint64_t)chan, data.data, data.size,</a>
<a name="ln1066">               false, &amp;error);</a>
<a name="ln1067">  VALIDATE(!error, &quot;%s&quot;, error, {});</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/// Gets the current list of tabpage handles.</a>
<a name="ln1071">///</a>
<a name="ln1072">/// @return List of tabpage handles</a>
<a name="ln1073">ArrayOf(Tabpage) nvim_list_tabpages(void)</a>
<a name="ln1074">  FUNC_API_SINCE(1)</a>
<a name="ln1075">{</a>
<a name="ln1076">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln1077"> </a>
<a name="ln1078">  FOR_ALL_TABS(tp) {</a>
<a name="ln1079">    rv.size++;</a>
<a name="ln1080">  }</a>
<a name="ln1081"> </a>
<a name="ln1082">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln1083">  size_t i = 0;</a>
<a name="ln1084"> </a>
<a name="ln1085">  FOR_ALL_TABS(tp) {</a>
<a name="ln1086">    rv.items[i++] = TABPAGE_OBJ(tp-&gt;handle);</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  return rv;</a>
<a name="ln1090">}</a>
<a name="ln1091"> </a>
<a name="ln1092">/// Gets the current tabpage.</a>
<a name="ln1093">///</a>
<a name="ln1094">/// @return Tabpage handle</a>
<a name="ln1095">Tabpage nvim_get_current_tabpage(void)</a>
<a name="ln1096">  FUNC_API_SINCE(1)</a>
<a name="ln1097">{</a>
<a name="ln1098">  return curtab-&gt;handle;</a>
<a name="ln1099">}</a>
<a name="ln1100"> </a>
<a name="ln1101">/// Sets the current tabpage.</a>
<a name="ln1102">///</a>
<a name="ln1103">/// @param tabpage  Tabpage handle</a>
<a name="ln1104">/// @param[out] err Error details, if any</a>
<a name="ln1105">void nvim_set_current_tabpage(Tabpage tabpage, Error *err)</a>
<a name="ln1106">  FUNC_API_SINCE(1)</a>
<a name="ln1107">  FUNC_API_TEXTLOCK</a>
<a name="ln1108">{</a>
<a name="ln1109">  tabpage_T *tp = find_tab_by_handle(tabpage, err);</a>
<a name="ln1110"> </a>
<a name="ln1111">  if (!tp) {</a>
<a name="ln1112">    return;</a>
<a name="ln1113">  }</a>
<a name="ln1114"> </a>
<a name="ln1115">  try_start();</a>
<a name="ln1116">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln1117">  if (!try_end(err) &amp;&amp; tp != curtab) {</a>
<a name="ln1118">    api_set_error(err,</a>
<a name="ln1119">                  kErrorTypeException,</a>
<a name="ln1120">                  &quot;Failed to switch to tabpage %d&quot;,</a>
<a name="ln1121">                  tabpage);</a>
<a name="ln1122">  }</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125">/// Pastes at cursor, in any mode.</a>
<a name="ln1126">///</a>
<a name="ln1127">/// Invokes the `vim.paste` handler, which handles each mode appropriately.</a>
<a name="ln1128">/// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF (&quot;\n&quot;).</a>
<a name="ln1129">///</a>
<a name="ln1130">/// Errors ('nomodifiable', `vim.paste()` failure, ) are reflected in `err`</a>
<a name="ln1131">/// but do not affect the return value (which is strictly decided by</a>
<a name="ln1132">/// `vim.paste()`).  On error, subsequent calls are ignored (&quot;drained&quot;) until</a>
<a name="ln1133">/// the next paste is initiated (phase 1 or -1).</a>
<a name="ln1134">///</a>
<a name="ln1135">/// @param data  Multiline input. May be binary (containing NUL bytes).</a>
<a name="ln1136">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln1137">/// @param phase  -1: paste in a single call (i.e. without streaming).</a>
<a name="ln1138">///               To &quot;stream&quot; a paste, call `nvim_paste` sequentially with</a>
<a name="ln1139">///               these `phase` values:</a>
<a name="ln1140">///                 - 1: starts the paste (exactly once)</a>
<a name="ln1141">///                 - 2: continues the paste (zero or more times)</a>
<a name="ln1142">///                 - 3: ends the paste (exactly once)</a>
<a name="ln1143">/// @param[out] err Error details, if any</a>
<a name="ln1144">/// @return</a>
<a name="ln1145">///     - true: Client may continue pasting.</a>
<a name="ln1146">///     - false: Client must cancel the paste.</a>
<a name="ln1147">Boolean nvim_paste(String data, Boolean crlf, Integer phase, Error *err)</a>
<a name="ln1148">  FUNC_API_SINCE(6)</a>
<a name="ln1149">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1150">{</a>
<a name="ln1151">  static bool draining = false;</a>
<a name="ln1152">  bool cancel = false;</a>
<a name="ln1153"> </a>
<a name="ln1154">  VALIDATE_INT((phase &gt;= -1 &amp;&amp; phase &lt;= 3), &quot;phase&quot;, phase, {</a>
<a name="ln1155">    return false;</a>
<a name="ln1156">  });</a>
<a name="ln1157">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln1158">  Object rv = OBJECT_INIT;</a>
<a name="ln1159">  if (phase == -1 || phase == 1) {  // Start of paste-stream.</a>
<a name="ln1160">    draining = false;</a>
<a name="ln1161">  } else if (draining) {</a>
<a name="ln1162">    // Skip remaining chunks.  Report error only once per &quot;stream&quot;.</a>
<a name="ln1163">    goto theend;</a>
<a name="ln1164">  }</a>
<a name="ln1165">  Array lines = string_to_array(data, crlf);</a>
<a name="ln1166">  ADD(args, ARRAY_OBJ(lines));</a>
<a name="ln1167">  ADD(args, INTEGER_OBJ(phase));</a>
<a name="ln1168">  rv = nvim_exec_lua(STATIC_CSTR_AS_STRING(&quot;return vim.paste(...)&quot;), args,</a>
<a name="ln1169">                     err);</a>
<a name="ln1170">  if (ERROR_SET(err)) {</a>
<a name="ln1171">    draining = true;</a>
<a name="ln1172">    goto theend;</a>
<a name="ln1173">  }</a>
<a name="ln1174">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 1)) {</a>
<a name="ln1175">    ResetRedobuff();</a>
<a name="ln1176">    AppendCharToRedobuff('a');  // Dot-repeat.</a>
<a name="ln1177">  }</a>
<a name="ln1178">  // vim.paste() decides if client should cancel.  Errors do NOT cancel: we</a>
<a name="ln1179">  // want to drain remaining chunks (rather than divert them to main input).</a>
<a name="ln1180">  cancel = (rv.type == kObjectTypeBoolean &amp;&amp; !rv.data.boolean);</a>
<a name="ln1181">  if (!cancel &amp;&amp; !(State &amp; MODE_CMDLINE)) {  // Dot-repeat.</a>
<a name="ln1182">    for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1183">      String s = lines.items[i].data.string;</a>
<a name="ln1184">      assert(s.size &lt;= INT_MAX);</a>
<a name="ln1185">      AppendToRedobuffLit(s.data, (int)s.size);</a>
<a name="ln1186">      // readfile()-style: &quot;\n&quot; is indicated by presence of N+1 item.</a>
<a name="ln1187">      if (i + 1 &lt; lines.size) {</a>
<a name="ln1188">        AppendCharToRedobuff(NL);</a>
<a name="ln1189">      }</a>
<a name="ln1190">    }</a>
<a name="ln1191">  }</a>
<a name="ln1192">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 3)) {</a>
<a name="ln1193">    AppendCharToRedobuff(ESC);  // Dot-repeat.</a>
<a name="ln1194">  }</a>
<a name="ln1195">theend:</a>
<a name="ln1196">  api_free_object(rv);</a>
<a name="ln1197">  api_free_array(args);</a>
<a name="ln1198">  if (cancel || phase == -1 || phase == 3) {  // End of paste-stream.</a>
<a name="ln1199">    draining = false;</a>
<a name="ln1200">  }</a>
<a name="ln1201"> </a>
<a name="ln1202">  return !cancel;</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">/// Puts text at cursor, in any mode.</a>
<a name="ln1206">///</a>
<a name="ln1207">/// Compare |:put| and |p| which are always linewise.</a>
<a name="ln1208">///</a>
<a name="ln1209">/// @param lines  |readfile()|-style list of lines. |channel-lines|</a>
<a name="ln1210">/// @param type  Edit behavior: any |getregtype()| result, or:</a>
<a name="ln1211">///              - &quot;b&quot; |blockwise-visual| mode (may include width, e.g. &quot;b3&quot;)</a>
<a name="ln1212">///              - &quot;c&quot; |charwise| mode</a>
<a name="ln1213">///              - &quot;l&quot; |linewise| mode</a>
<a name="ln1214">///              - &quot;&quot;  guess by contents, see |setreg()|</a>
<a name="ln1215">/// @param after  If true insert after cursor (like |p|), or before (like |P|).</a>
<a name="ln1216">/// @param follow  If true place cursor at end of inserted text.</a>
<a name="ln1217">/// @param[out] err Error details, if any</a>
<a name="ln1218">void nvim_put(ArrayOf(String) lines, String type, Boolean after, Boolean follow, Error *err)</a>
<a name="ln1219">  FUNC_API_SINCE(6)</a>
<a name="ln1220">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1221">{</a>
<a name="ln1222">  yankreg_T *reg = xcalloc(1, sizeof(yankreg_T));</a>
<a name="ln1223">  VALIDATE_S((prepare_yankreg_from_object(reg, type, lines.size)), &quot;type&quot;, type.data, {</a>
<a name="ln1224">    goto cleanup;</a>
<a name="ln1225">  });</a>
<a name="ln1226">  if (lines.size == 0) {</a>
<a name="ln1227">    goto cleanup;  // Nothing to do.</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1231">    VALIDATE_T(&quot;line&quot;, kObjectTypeString, lines.items[i].type, {</a>
<a name="ln1232">      goto cleanup;</a>
<a name="ln1233">    });</a>
<a name="ln1234">    String line = lines.items[i].data.string;</a>
<a name="ln1235">    reg-&gt;y_array[i] = xmemdupz(line.data, line.size);</a>
<a name="ln1236">    memchrsub(reg-&gt;y_array[i], NUL, NL, line.size);</a>
<a name="ln1237">  }</a>
<a name="ln1238"> </a>
<a name="ln1239">  finish_yankreg_from_object(reg, false);</a>
<a name="ln1240"> </a>
<a name="ln1241">  TRY_WRAP(err, {</a>
<a name="ln1242">    bool VIsual_was_active = VIsual_active;</a>
<a name="ln1243">    msg_silent++;  // Avoid &quot;N more lines&quot; message.</a>
<a name="ln1244">    do_put(0, reg, after ? FORWARD : BACKWARD, 1, follow ? PUT_CURSEND : 0);</a>
<a name="ln1245">    msg_silent--;</a>
<a name="ln1246">    VIsual_active = VIsual_was_active;</a>
<a name="ln1247">  });</a>
<a name="ln1248"> </a>
<a name="ln1249">cleanup:</a>
<a name="ln1250">  free_register(reg);</a>
<a name="ln1251">  xfree(reg);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">/// Subscribes to event broadcasts.</a>
<a name="ln1255">///</a>
<a name="ln1256">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1257">/// @param event      Event type string</a>
<a name="ln1258">void nvim_subscribe(uint64_t channel_id, String event)</a>
<a name="ln1259">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1260">{</a>
<a name="ln1261">  size_t length = (event.size &lt; METHOD_MAXLEN ? event.size : METHOD_MAXLEN);</a>
<a name="ln1262">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1263">  memcpy(e, event.data, length);</a>
<a name="ln1264">  e[length] = NUL;</a>
<a name="ln1265">  rpc_subscribe(channel_id, e);</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">/// Unsubscribes to event broadcasts.</a>
<a name="ln1269">///</a>
<a name="ln1270">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1271">/// @param event      Event type string</a>
<a name="ln1272">void nvim_unsubscribe(uint64_t channel_id, String event)</a>
<a name="ln1273">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1274">{</a>
<a name="ln1275">  size_t length = (event.size &lt; METHOD_MAXLEN ?</a>
<a name="ln1276">                   event.size :</a>
<a name="ln1277">                   METHOD_MAXLEN);</a>
<a name="ln1278">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1279">  memcpy(e, event.data, length);</a>
<a name="ln1280">  e[length] = NUL;</a>
<a name="ln1281">  rpc_unsubscribe(channel_id, e);</a>
<a name="ln1282">}</a>
<a name="ln1283"> </a>
<a name="ln1284">/// Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or</a>
<a name="ln1285">/// &quot;#rrggbb&quot; hexadecimal string.</a>
<a name="ln1286">///</a>
<a name="ln1287">/// Example:</a>
<a name="ln1288">///</a>
<a name="ln1289">/// ```vim</a>
<a name="ln1290">/// :echo nvim_get_color_by_name(&quot;Pink&quot;)</a>
<a name="ln1291">/// :echo nvim_get_color_by_name(&quot;#cbcbcb&quot;)</a>
<a name="ln1292">/// ```</a>
<a name="ln1293">///</a>
<a name="ln1294">/// @param name Color name or &quot;#rrggbb&quot; string</a>
<a name="ln1295">/// @return 24-bit RGB value, or -1 for invalid argument.</a>
<a name="ln1296">Integer nvim_get_color_by_name(String name)</a>
<a name="ln1297">  FUNC_API_SINCE(1)</a>
<a name="ln1298">{</a>
<a name="ln1299">  int dummy;</a>
<a name="ln1300">  return name_to_color(name.data, &amp;dummy);</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">/// Returns a map of color names and RGB values.</a>
<a name="ln1304">///</a>
<a name="ln1305">/// Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB color values</a>
<a name="ln1306">/// (e.g. 65535).</a>
<a name="ln1307">///</a>
<a name="ln1308">/// @return Map of color names and RGB values.</a>
<a name="ln1309">Dictionary nvim_get_color_map(void)</a>
<a name="ln1310">  FUNC_API_SINCE(1)</a>
<a name="ln1311">{</a>
<a name="ln1312">  Dictionary colors = ARRAY_DICT_INIT;</a>
<a name="ln1313"> </a>
<a name="ln1314">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln1315">    PUT(colors, color_name_table[i].name,</a>
<a name="ln1316">        INTEGER_OBJ(color_name_table[i].color));</a>
<a name="ln1317">  }</a>
<a name="ln1318">  return colors;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">/// Gets a map of the current editor state.</a>
<a name="ln1322">///</a>
<a name="ln1323">/// @param opts  Optional parameters.</a>
<a name="ln1324">///               - types:  List of |context-types| (&quot;regs&quot;, &quot;jumps&quot;, &quot;bufs&quot;,</a>
<a name="ln1325">///                 &quot;gvars&quot;, ) to gather, or empty for &quot;all&quot;.</a>
<a name="ln1326">/// @param[out]  err  Error details, if any</a>
<a name="ln1327">///</a>
<a name="ln1328">/// @return map of global |context|.</a>
<a name="ln1329">Dictionary nvim_get_context(Dict(context) *opts, Error *err)</a>
<a name="ln1330">  FUNC_API_SINCE(6)</a>
<a name="ln1331">{</a>
<a name="ln1332">  Array types = ARRAY_DICT_INIT;</a>
<a name="ln1333">  if (HAS_KEY(opts, context, types)) {</a>
<a name="ln1334">    types = opts-&gt;types;</a>
<a name="ln1335">  }</a>
<a name="ln1336"> </a>
<a name="ln1337">  int int_types = types.size &gt; 0 ? 0 : kCtxAll;</a>
<a name="ln1338">  if (types.size &gt; 0) {</a>
<a name="ln1339">    for (size_t i = 0; i &lt; types.size; i++) {</a>
<a name="ln1340">      if (types.items[i].type == kObjectTypeString) {</a>
<a name="ln1341">        const char *const s = types.items[i].data.string.data;</a>
<a name="ln1342">        if (strequal(s, &quot;regs&quot;)) {</a>
<a name="ln1343">          int_types |= kCtxRegs;</a>
<a name="ln1344">        } else if (strequal(s, &quot;jumps&quot;)) {</a>
<a name="ln1345">          int_types |= kCtxJumps;</a>
<a name="ln1346">        } else if (strequal(s, &quot;bufs&quot;)) {</a>
<a name="ln1347">          int_types |= kCtxBufs;</a>
<a name="ln1348">        } else if (strequal(s, &quot;gvars&quot;)) {</a>
<a name="ln1349">          int_types |= kCtxGVars;</a>
<a name="ln1350">        } else if (strequal(s, &quot;sfuncs&quot;)) {</a>
<a name="ln1351">          int_types |= kCtxSFuncs;</a>
<a name="ln1352">        } else if (strequal(s, &quot;funcs&quot;)) {</a>
<a name="ln1353">          int_types |= kCtxFuncs;</a>
<a name="ln1354">        } else {</a>
<a name="ln1355">          VALIDATE_S(false, &quot;type&quot;, s, {</a>
<a name="ln1356">            return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1357">          });</a>
<a name="ln1358">        }</a>
<a name="ln1359">      }</a>
<a name="ln1360">    }</a>
<a name="ln1361">  }</a>
<a name="ln1362"> </a>
<a name="ln1363">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1364">  ctx_save(&amp;ctx, int_types);</a>
<a name="ln1365">  Dictionary dict = ctx_to_dict(&amp;ctx);</a>
<a name="ln1366">  ctx_free(&amp;ctx);</a>
<a name="ln1367">  return dict;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">/// Sets the current editor state from the given |context| map.</a>
<a name="ln1371">///</a>
<a name="ln1372">/// @param  dict  |Context| map.</a>
<a name="ln1373">Object nvim_load_context(Dictionary dict)</a>
<a name="ln1374">  FUNC_API_SINCE(6)</a>
<a name="ln1375">{</a>
<a name="ln1376">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1377"> </a>
<a name="ln1378">  int save_did_emsg = did_emsg;</a>
<a name="ln1379">  did_emsg = false;</a>
<a name="ln1380"> </a>
<a name="ln1381">  ctx_from_dict(dict, &amp;ctx);</a>
<a name="ln1382">  if (!did_emsg) {</a>
<a name="ln1383">    ctx_restore(&amp;ctx, kCtxAll);</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">  ctx_free(&amp;ctx);</a>
<a name="ln1387"> </a>
<a name="ln1388">  did_emsg = save_did_emsg;</a>
<a name="ln1389">  return (Object)OBJECT_INIT;</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">/// Gets the current mode. |mode()|</a>
<a name="ln1393">/// &quot;blocking&quot; is true if Nvim is waiting for input.</a>
<a name="ln1394">///</a>
<a name="ln1395">/// @returns Dictionary { &quot;mode&quot;: String, &quot;blocking&quot;: Boolean }</a>
<a name="ln1396">Dictionary nvim_get_mode(void)</a>
<a name="ln1397">  FUNC_API_SINCE(2) FUNC_API_FAST</a>
<a name="ln1398">{</a>
<a name="ln1399">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1400">  char modestr[MODE_MAX_LENGTH];</a>
<a name="ln1401">  get_mode(modestr);</a>
<a name="ln1402">  bool blocked = input_blocking();</a>
<a name="ln1403"> </a>
<a name="ln1404">  PUT(rv, &quot;mode&quot;, CSTR_TO_OBJ(modestr));</a>
<a name="ln1405">  PUT(rv, &quot;blocking&quot;, BOOLEAN_OBJ(blocked));</a>
<a name="ln1406"> </a>
<a name="ln1407">  return rv;</a>
<a name="ln1408">}</a>
<a name="ln1409"> </a>
<a name="ln1410">/// Gets a list of global (non-buffer-local) |mapping| definitions.</a>
<a name="ln1411">///</a>
<a name="ln1412">/// @param  mode       Mode short-name (&quot;n&quot;, &quot;i&quot;, &quot;v&quot;, ...)</a>
<a name="ln1413">/// @returns Array of |maparg()|-like dictionaries describing mappings.</a>
<a name="ln1414">///          The &quot;buffer&quot; key is always zero.</a>
<a name="ln1415">ArrayOf(Dictionary) nvim_get_keymap(String mode)</a>
<a name="ln1416">  FUNC_API_SINCE(3)</a>
<a name="ln1417">{</a>
<a name="ln1418">  return keymap_array(mode, NULL);</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">/// Sets a global |mapping| for the given mode.</a>
<a name="ln1422">///</a>
<a name="ln1423">/// To set a buffer-local mapping, use |nvim_buf_set_keymap()|.</a>
<a name="ln1424">///</a>
<a name="ln1425">/// Unlike |:map|, leading/trailing whitespace is accepted as part of the {lhs} or {rhs}.</a>
<a name="ln1426">/// Empty {rhs} is |&lt;Nop&gt;|. |keycodes| are replaced as usual.</a>
<a name="ln1427">///</a>
<a name="ln1428">/// Example:</a>
<a name="ln1429">///</a>
<a name="ln1430">/// ```vim</a>
<a name="ln1431">/// call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</a>
<a name="ln1432">/// ```</a>
<a name="ln1433">///</a>
<a name="ln1434">/// is equivalent to:</a>
<a name="ln1435">///</a>
<a name="ln1436">/// ```vim</a>
<a name="ln1437">/// nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</a>
<a name="ln1438">/// ```</a>
<a name="ln1439">///</a>
<a name="ln1440">/// @param channel_id</a>
<a name="ln1441">/// @param  mode  Mode short-name (map command prefix: &quot;n&quot;, &quot;i&quot;, &quot;v&quot;, &quot;x&quot;, )</a>
<a name="ln1442">///               or &quot;!&quot; for |:map!|, or empty string for |:map|.</a>
<a name="ln1443">///               &quot;ia&quot;, &quot;ca&quot; or &quot;!a&quot; for abbreviation in Insert mode, Cmdline mode, or both, respectively</a>
<a name="ln1444">/// @param  lhs   Left-hand-side |{lhs}| of the mapping.</a>
<a name="ln1445">/// @param  rhs   Right-hand-side |{rhs}| of the mapping.</a>
<a name="ln1446">/// @param  opts  Optional parameters map: Accepts all |:map-arguments| as keys except |&lt;buffer&gt;|,</a>
<a name="ln1447">///               values are booleans (default false). Also:</a>
<a name="ln1448">///               - &quot;noremap&quot; disables |recursive_mapping|, like |:noremap|</a>
<a name="ln1449">///               - &quot;desc&quot; human-readable description.</a>
<a name="ln1450">///               - &quot;callback&quot; Lua function called in place of {rhs}.</a>
<a name="ln1451">///               - &quot;replace_keycodes&quot; (boolean) When &quot;expr&quot; is true, replace keycodes in the</a>
<a name="ln1452">///                 resulting string (see |nvim_replace_termcodes()|). Returning nil from the Lua</a>
<a name="ln1453">///                 &quot;callback&quot; is equivalent to returning an empty string.</a>
<a name="ln1454">/// @param[out]   err   Error details, if any.</a>
<a name="ln1455">void nvim_set_keymap(uint64_t channel_id, String mode, String lhs, String rhs, Dict(keymap) *opts,</a>
<a name="ln1456">                     Error *err)</a>
<a name="ln1457">  FUNC_API_SINCE(6)</a>
<a name="ln1458">{</a>
<a name="ln1459">  modify_keymap(channel_id, -1, false, mode, lhs, rhs, opts, err);</a>
<a name="ln1460">}</a>
<a name="ln1461"> </a>
<a name="ln1462">/// Unmaps a global |mapping| for the given mode.</a>
<a name="ln1463">///</a>
<a name="ln1464">/// To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.</a>
<a name="ln1465">///</a>
<a name="ln1466">/// @see |nvim_set_keymap()|</a>
<a name="ln1467">void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)</a>
<a name="ln1468">  FUNC_API_SINCE(6)</a>
<a name="ln1469">{</a>
<a name="ln1470">  nvim_buf_del_keymap(channel_id, -1, mode, lhs, err);</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">/// Returns a 2-tuple (Array), where item 0 is the current channel id and item</a>
<a name="ln1474">/// 1 is the |api-metadata| map (Dictionary).</a>
<a name="ln1475">///</a>
<a name="ln1476">/// @returns 2-tuple [{channel-id}, {api-metadata}]</a>
<a name="ln1477">Array nvim_get_api_info(uint64_t channel_id, Arena *arena)</a>
<a name="ln1478">  FUNC_API_SINCE(1) FUNC_API_FAST FUNC_API_REMOTE_ONLY</a>
<a name="ln1479">{</a>
<a name="ln1480">  Array rv = arena_array(arena, 2);</a>
<a name="ln1481"> </a>
<a name="ln1482">  assert(channel_id &lt;= INT64_MAX);</a>
<a name="ln1483">  ADD_C(rv, INTEGER_OBJ((int64_t)channel_id));</a>
<a name="ln1484">  ADD_C(rv, DICTIONARY_OBJ(api_metadata()));</a>
<a name="ln1485"> </a>
<a name="ln1486">  return rv;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">/// Self-identifies the client.</a>
<a name="ln1490">///</a>
<a name="ln1491">/// The client/plugin/application should call this after connecting, to provide</a>
<a name="ln1492">/// hints about its identity and purpose, for debugging and orchestration.</a>
<a name="ln1493">///</a>
<a name="ln1494">/// Can be called more than once; the caller should merge old info if</a>
<a name="ln1495">/// appropriate. Example: library first identifies the channel, then a plugin</a>
<a name="ln1496">/// using that library later identifies itself.</a>
<a name="ln1497">///</a>
<a name="ln1498">/// @note &quot;Something is better than nothing&quot;. You don't need to include all the</a>
<a name="ln1499">///       fields.</a>
<a name="ln1500">///</a>
<a name="ln1501">/// @param channel_id</a>
<a name="ln1502">/// @param name Short name for the connected client</a>
<a name="ln1503">/// @param version  Dictionary describing the version, with these</a>
<a name="ln1504">///                 (optional) keys:</a>
<a name="ln1505">///     - &quot;major&quot; major version (defaults to 0 if not set, for no release yet)</a>
<a name="ln1506">///     - &quot;minor&quot; minor version</a>
<a name="ln1507">///     - &quot;patch&quot; patch number</a>
<a name="ln1508">///     - &quot;prerelease&quot; string describing a prerelease, like &quot;dev&quot; or &quot;beta1&quot;</a>
<a name="ln1509">///     - &quot;commit&quot; hash or similar identifier of commit</a>
<a name="ln1510">/// @param type Must be one of the following values. Client libraries should</a>
<a name="ln1511">///             default to &quot;remote&quot; unless overridden by the user.</a>
<a name="ln1512">///     - &quot;remote&quot; remote client connected &quot;Nvim flavored&quot; MessagePack-RPC (responses</a>
<a name="ln1513">///                must be in reverse order of requests). |msgpack-rpc|</a>
<a name="ln1514">///     - &quot;msgpack-rpc&quot; remote client connected to Nvim via fully MessagePack-RPC</a>
<a name="ln1515">///                     compliant protocol.</a>
<a name="ln1516">///     - &quot;ui&quot; gui frontend</a>
<a name="ln1517">///     - &quot;embedder&quot; application using Nvim as a component (for example,</a>
<a name="ln1518">///                  IDE/editor implementing a vim mode).</a>
<a name="ln1519">///     - &quot;host&quot; plugin host, typically started by nvim</a>
<a name="ln1520">///     - &quot;plugin&quot; single plugin, started by nvim</a>
<a name="ln1521">/// @param methods Builtin methods in the client. For a host, this does not</a>
<a name="ln1522">///                include plugin methods which will be discovered later.</a>
<a name="ln1523">///                The key should be the method name, the values are dicts with</a>
<a name="ln1524">///                these (optional) keys (more keys may be added in future</a>
<a name="ln1525">///                versions of Nvim, thus unknown keys are ignored. Clients</a>
<a name="ln1526">///                must only use keys defined in this or later versions of</a>
<a name="ln1527">///                Nvim):</a>
<a name="ln1528">///     - &quot;async&quot;  if true, send as a notification. If false or unspecified,</a>
<a name="ln1529">///                use a blocking request</a>
<a name="ln1530">///     - &quot;nargs&quot; Number of arguments. Could be a single integer or an array</a>
<a name="ln1531">///                of two integers, minimum and maximum inclusive.</a>
<a name="ln1532">///</a>
<a name="ln1533">/// @param attributes Arbitrary string:string map of informal client properties.</a>
<a name="ln1534">///     Suggested keys:</a>
<a name="ln1535">///     - &quot;website&quot;: Client homepage URL (e.g. GitHub repository)</a>
<a name="ln1536">///     - &quot;license&quot;: License description (&quot;Apache 2&quot;, &quot;GPLv3&quot;, &quot;MIT&quot;, )</a>
<a name="ln1537">///     - &quot;logo&quot;:    URI or path to image, preferably small logo or icon.</a>
<a name="ln1538">///                  .png or .svg format is preferred.</a>
<a name="ln1539">///</a>
<a name="ln1540">/// @param[out] err Error details, if any</a>
<a name="ln1541">void nvim_set_client_info(uint64_t channel_id, String name, Dictionary version, String type,</a>
<a name="ln1542">                          Dictionary methods, Dictionary attributes, Error *err)</a>
<a name="ln1543">  FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY</a>
<a name="ln1544">{</a>
<a name="ln1545">  Dictionary info = ARRAY_DICT_INIT;</a>
<a name="ln1546">  PUT(info, &quot;name&quot;, copy_object(STRING_OBJ(name), NULL));</a>
<a name="ln1547"> </a>
<a name="ln1548">  version = copy_dictionary(version, NULL);</a>
<a name="ln1549">  bool has_major = false;</a>
<a name="ln1550">  for (size_t i = 0; i &lt; version.size; i++) {</a>
<a name="ln1551">    if (strequal(version.items[i].key.data, &quot;major&quot;)) {</a>
<a name="ln1552">      has_major = true;</a>
<a name="ln1553">      break;</a>
<a name="ln1554">    }</a>
<a name="ln1555">  }</a>
<a name="ln1556">  if (!has_major) {</a>
<a name="ln1557">    PUT(version, &quot;major&quot;, INTEGER_OBJ(0));</a>
<a name="ln1558">  }</a>
<a name="ln1559">  PUT(info, &quot;version&quot;, DICTIONARY_OBJ(version));</a>
<a name="ln1560"> </a>
<a name="ln1561">  PUT(info, &quot;type&quot;, copy_object(STRING_OBJ(type), NULL));</a>
<a name="ln1562">  PUT(info, &quot;methods&quot;, DICTIONARY_OBJ(copy_dictionary(methods, NULL)));</a>
<a name="ln1563">  PUT(info, &quot;attributes&quot;, DICTIONARY_OBJ(copy_dictionary(attributes, NULL)));</a>
<a name="ln1564"> </a>
<a name="ln1565">  rpc_set_client_info(channel_id, info);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">/// Gets information about a channel.</a>
<a name="ln1569">///</a>
<a name="ln1570">/// @returns Dictionary describing a channel, with these keys:</a>
<a name="ln1571">///    - &quot;id&quot;       Channel id.</a>
<a name="ln1572">///    - &quot;argv&quot;     (optional) Job arguments list.</a>
<a name="ln1573">///    - &quot;stream&quot;   Stream underlying the channel.</a>
<a name="ln1574">///         - &quot;stdio&quot;      stdin and stdout of this Nvim instance</a>
<a name="ln1575">///         - &quot;stderr&quot;     stderr of this Nvim instance</a>
<a name="ln1576">///         - &quot;socket&quot;     TCP/IP socket or named pipe</a>
<a name="ln1577">///         - &quot;job&quot;        Job with communication over its stdio.</a>
<a name="ln1578">///    -  &quot;mode&quot;    How data received on the channel is interpreted.</a>
<a name="ln1579">///         - &quot;bytes&quot;      Send and receive raw bytes.</a>
<a name="ln1580">///         - &quot;terminal&quot;   |terminal| instance interprets ASCII sequences.</a>
<a name="ln1581">///         - &quot;rpc&quot;        |RPC| communication on the channel is active.</a>
<a name="ln1582">///    -  &quot;pty&quot;     (optional) Name of pseudoterminal. On a POSIX system this</a>
<a name="ln1583">///                 is a device path like &quot;/dev/pts/1&quot;. If the name is unknown,</a>
<a name="ln1584">///                 the key will still be present if a pty is used (e.g. for</a>
<a name="ln1585">///                 conpty on Windows).</a>
<a name="ln1586">///    -  &quot;buffer&quot;  (optional) Buffer with connected |terminal| instance.</a>
<a name="ln1587">///    -  &quot;client&quot;  (optional) Info about the peer (client on the other end of</a>
<a name="ln1588">///                 the RPC channel), if provided by it via</a>
<a name="ln1589">///                 |nvim_set_client_info()|.</a>
<a name="ln1590">///</a>
<a name="ln1591">Dictionary nvim_get_chan_info(Integer chan, Error *err)</a>
<a name="ln1592">  FUNC_API_SINCE(4)</a>
<a name="ln1593">{</a>
<a name="ln1594">  if (chan &lt; 0) {</a>
<a name="ln1595">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1596">  }</a>
<a name="ln1597">  return channel_info((uint64_t)chan);</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">/// Get information about all open channels.</a>
<a name="ln1601">///</a>
<a name="ln1602">/// @returns Array of Dictionaries, each describing a channel with</a>
<a name="ln1603">///          the format specified at |nvim_get_chan_info()|.</a>
<a name="ln1604">Array nvim_list_chans(void)</a>
<a name="ln1605">  FUNC_API_SINCE(4)</a>
<a name="ln1606">{</a>
<a name="ln1607">  return channel_all_info();</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">/// Calls many API methods atomically.</a>
<a name="ln1611">///</a>
<a name="ln1612">/// This has two main usages:</a>
<a name="ln1613">/// 1. To perform several requests from an async context atomically, i.e.</a>
<a name="ln1614">///    without interleaving redraws, RPC requests from other clients, or user</a>
<a name="ln1615">///    interactions (however API methods may trigger autocommands or event</a>
<a name="ln1616">///    processing which have such side effects, e.g. |:sleep| may wake timers).</a>
<a name="ln1617">/// 2. To minimize RPC overhead (roundtrips) of a sequence of many requests.</a>
<a name="ln1618">///</a>
<a name="ln1619">/// @param channel_id</a>
<a name="ln1620">/// @param calls an array of calls, where each call is described by an array</a>
<a name="ln1621">///              with two elements: the request name, and an array of arguments.</a>
<a name="ln1622">/// @param[out] err Validation error details (malformed `calls` parameter),</a>
<a name="ln1623">///             if any. Errors from batched calls are given in the return value.</a>
<a name="ln1624">///</a>
<a name="ln1625">/// @return Array of two elements. The first is an array of return</a>
<a name="ln1626">/// values. The second is NIL if all calls succeeded. If a call resulted in</a>
<a name="ln1627">/// an error, it is a three-element array with the zero-based index of the call</a>
<a name="ln1628">/// which resulted in an error, the error type and the error message. If an</a>
<a name="ln1629">/// error occurred, the values from all preceding calls will still be returned.</a>
<a name="ln1630">Array nvim_call_atomic(uint64_t channel_id, Array calls, Arena *arena, Error *err)</a>
<a name="ln1631">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1632">{</a>
<a name="ln1633">  Array rv = arena_array(arena, 2);</a>
<a name="ln1634">  Array results = arena_array(arena, calls.size);</a>
<a name="ln1635">  Error nested_error = ERROR_INIT;</a>
<a name="ln1636"> </a>
<a name="ln1637">  size_t i;  // also used for freeing the variables</a>
<a name="ln1638">  for (i = 0; i &lt; calls.size; i++) {</a>
<a name="ln1639">    VALIDATE_T(&quot;'calls' item&quot;, kObjectTypeArray, calls.items[i].type, {</a>
<a name="ln1640">      goto theend;</a>
<a name="ln1641">    });</a>
<a name="ln1642">    Array call = calls.items[i].data.array;</a>
<a name="ln1643">    VALIDATE_EXP((call.size == 2), &quot;'calls' item&quot;, &quot;2-item Array&quot;, NULL, {</a>
<a name="ln1644">      goto theend;</a>
<a name="ln1645">    });</a>
<a name="ln1646">    VALIDATE_T(&quot;name&quot;, kObjectTypeString, call.items[0].type, {</a>
<a name="ln1647">      goto theend;</a>
<a name="ln1648">    });</a>
<a name="ln1649">    String name = call.items[0].data.string;</a>
<a name="ln1650">    VALIDATE_T(&quot;call args&quot;, kObjectTypeArray, call.items[1].type, {</a>
<a name="ln1651">      goto theend;</a>
<a name="ln1652">    });</a>
<a name="ln1653">    Array args = call.items[1].data.array;</a>
<a name="ln1654"> </a>
<a name="ln1655">    MsgpackRpcRequestHandler handler =</a>
<a name="ln1656">      msgpack_rpc_get_handler_for(name.data,</a>
<a name="ln1657">                                  name.size,</a>
<a name="ln1658">                                  &amp;nested_error);</a>
<a name="ln1659"> </a>
<a name="ln1660">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1661">      break;</a>
<a name="ln1662">    }</a>
<a name="ln1663"> </a>
<a name="ln1664">    Object result = handler.fn(channel_id, args, arena, &amp;nested_error);</a>
<a name="ln1665">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1666">      // error handled after loop</a>
<a name="ln1667">      break;</a>
<a name="ln1668">    }</a>
<a name="ln1669">    // TODO(bfredl): wasteful copy. It could be avoided to encoding to msgpack</a>
<a name="ln1670">    // directly here. But `result` might become invalid when next api function</a>
<a name="ln1671">    // is called in the loop.</a>
<a name="ln1672">    ADD_C(results, copy_object(result, arena));</a>
<a name="ln1673">    if (!handler.arena_return) {</a>
<a name="ln1674">      api_free_object(result);</a>
<a name="ln1675">    }</a>
<a name="ln1676">  }</a>
<a name="ln1677"> </a>
<a name="ln1678">  ADD_C(rv, ARRAY_OBJ(results));</a>
<a name="ln1679">  if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1680">    Array errval = arena_array(arena, 3);</a>
<a name="ln1681">    ADD_C(errval, INTEGER_OBJ((Integer)i));</a>
<a name="ln1682">    ADD_C(errval, INTEGER_OBJ(nested_error.type));</a>
<a name="ln1683">    ADD_C(errval, STRING_OBJ(copy_string(cstr_as_string(nested_error.msg), arena)));</a>
<a name="ln1684">    ADD_C(rv, ARRAY_OBJ(errval));</a>
<a name="ln1685">  } else {</a>
<a name="ln1686">    ADD_C(rv, NIL);</a>
<a name="ln1687">  }</a>
<a name="ln1688"> </a>
<a name="ln1689">theend:</a>
<a name="ln1690">  api_clear_error(&amp;nested_error);</a>
<a name="ln1691">  return rv;</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694">/// Writes a message to vim output or error buffer. The string is split</a>
<a name="ln1695">/// and flushed after each newline. Incomplete lines are kept for writing</a>
<a name="ln1696">/// later.</a>
<a name="ln1697">///</a>
<a name="ln1698">/// @param message  Message to write</a>
<a name="ln1699">/// @param to_err   true: message is an error (uses `emsg` instead of `msg`)</a>
<a name="ln1700">/// @param writeln  Append a trailing newline</a>
<a name="ln1701">static void write_msg(String message, bool to_err, bool writeln)</a>
<a name="ln1702">{</a>
<a name="ln1703">  static StringBuilder out_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1704">  static StringBuilder err_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1705">  StringBuilder *line_buf = to_err ? &amp;err_line_buf : &amp;out_line_buf;</a>
<a name="ln1706"> </a>
<a name="ln1707">#define PUSH_CHAR(c) \</a>
<a name="ln1708">  if (kv_max(*line_buf) == 0) { \</a>
<a name="ln1709">    kv_resize(*line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1710">  } \</a>
<a name="ln1711">  if (c == NL) { \</a>
<a name="ln1712">    kv_push(*line_buf, NUL); \</a>
<a name="ln1713">    if (to_err) { \</a>
<a name="ln1714">      emsg(line_buf-&gt;items); \</a>
<a name="ln1715">    } else { \</a>
<a name="ln1716">      msg(line_buf-&gt;items, 0); \</a>
<a name="ln1717">    } \</a>
<a name="ln1718">    msg_didout = true; \</a>
<a name="ln1719">    kv_drop(*line_buf, kv_size(*line_buf)); \</a>
<a name="ln1720">    kv_resize(*line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1721">  } else if (c == NUL) { \</a>
<a name="ln1722">    kv_push(*line_buf, NL); \</a>
<a name="ln1723">  } else { \</a>
<a name="ln1724">    kv_push(*line_buf, c); \</a>
<a name="ln1725">  }</a>
<a name="ln1726"> </a>
<a name="ln1727">  no_wait_return++;</a>
<a name="ln1728">  for (uint32_t i = 0; i &lt; message.size; i++) {</a>
<a name="ln1729">    if (got_int) {</a>
<a name="ln1730">      break;</a>
<a name="ln1731">    }</a>
<a name="ln1732">    PUSH_CHAR(message.data[i]);</a>
<a name="ln1733">  }</a>
<a name="ln1734">  if (writeln) {</a>
<a name="ln1735">    PUSH_CHAR(NL);</a>
<a name="ln1736">  }</a>
<a name="ln1737">  no_wait_return--;</a>
<a name="ln1738">  msg_end();</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">// Functions used for testing purposes</a>
<a name="ln1742"> </a>
<a name="ln1743">/// Returns object given as argument.</a>
<a name="ln1744">///</a>
<a name="ln1745">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1746">/// in plugins.</a>
<a name="ln1747">///</a>
<a name="ln1748">/// @param[in]  obj  Object to return.</a>
<a name="ln1749">///</a>
<a name="ln1750">/// @return its argument.</a>
<a name="ln1751">Object nvim__id(Object obj)</a>
<a name="ln1752">{</a>
<a name="ln1753">  return copy_object(obj, NULL);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/// Returns array given as argument.</a>
<a name="ln1757">///</a>
<a name="ln1758">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1759">/// in plugins.</a>
<a name="ln1760">///</a>
<a name="ln1761">/// @param[in]  arr  Array to return.</a>
<a name="ln1762">///</a>
<a name="ln1763">/// @return its argument.</a>
<a name="ln1764">Array nvim__id_array(Array arr)</a>
<a name="ln1765">{</a>
<a name="ln1766">  return copy_array(arr, NULL);</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/// Returns dictionary given as argument.</a>
<a name="ln1770">///</a>
<a name="ln1771">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1772">/// in plugins.</a>
<a name="ln1773">///</a>
<a name="ln1774">/// @param[in]  dct  Dictionary to return.</a>
<a name="ln1775">///</a>
<a name="ln1776">/// @return its argument.</a>
<a name="ln1777">Dictionary nvim__id_dictionary(Dictionary dct)</a>
<a name="ln1778">{</a>
<a name="ln1779">  return copy_dictionary(dct, NULL);</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">/// Returns floating-point value given as argument.</a>
<a name="ln1783">///</a>
<a name="ln1784">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1785">/// in plugins.</a>
<a name="ln1786">///</a>
<a name="ln1787">/// @param[in]  flt  Value to return.</a>
<a name="ln1788">///</a>
<a name="ln1789">/// @return its argument.</a>
<a name="ln1790">Float nvim__id_float(Float flt)</a>
<a name="ln1791">{</a>
<a name="ln1792">  return flt;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">/// Gets internal stats.</a>
<a name="ln1796">///</a>
<a name="ln1797">/// @return Map of various internal stats.</a>
<a name="ln1798">Dictionary nvim__stats(void)</a>
<a name="ln1799">{</a>
<a name="ln1800">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1801">  PUT(rv, &quot;fsync&quot;, INTEGER_OBJ(g_stats.fsync));</a>
<a name="ln1802">  PUT(rv, &quot;log_skip&quot;, INTEGER_OBJ(g_stats.log_skip));</a>
<a name="ln1803">  PUT(rv, &quot;lua_refcount&quot;, INTEGER_OBJ(nlua_get_global_ref_count()));</a>
<a name="ln1804">  PUT(rv, &quot;redraw&quot;, INTEGER_OBJ(g_stats.redraw));</a>
<a name="ln1805">  PUT(rv, &quot;arena_alloc_count&quot;, INTEGER_OBJ((Integer)arena_alloc_count));</a>
<a name="ln1806">  return rv;</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">/// Gets a list of dictionaries representing attached UIs.</a>
<a name="ln1810">///</a>
<a name="ln1811">/// @return Array of UI dictionaries, each with these keys:</a>
<a name="ln1812">///   - &quot;height&quot;  Requested height of the UI</a>
<a name="ln1813">///   - &quot;width&quot;   Requested width of the UI</a>
<a name="ln1814">///   - &quot;rgb&quot;     true if the UI uses RGB colors (false implies |cterm-colors|)</a>
<a name="ln1815">///   - &quot;ext_...&quot; Requested UI extensions, see |ui-option|</a>
<a name="ln1816">///   - &quot;chan&quot;    |channel-id| of remote UI</a>
<a name="ln1817">Array nvim_list_uis(void)</a>
<a name="ln1818">  FUNC_API_SINCE(4)</a>
<a name="ln1819">{</a>
<a name="ln1820">  return ui_array();</a>
<a name="ln1821">}</a>
<a name="ln1822"> </a>
<a name="ln1823">/// Gets the immediate children of process `pid`.</a>
<a name="ln1824">///</a>
<a name="ln1825">/// @return Array of child process ids, empty if process not found.</a>
<a name="ln1826">Array nvim_get_proc_children(Integer pid, Error *err)</a>
<a name="ln1827">  FUNC_API_SINCE(4)</a>
<a name="ln1828">{</a>
<a name="ln1829">  Array rvobj = ARRAY_DICT_INIT;</a>
<a name="ln1830">  int *proc_list = NULL;</a>
<a name="ln1831"> </a>
<a name="ln1832">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1833">    goto end;</a>
<a name="ln1834">  });</a>
<a name="ln1835"> </a>
<a name="ln1836">  size_t proc_count;</a>
<a name="ln1837">  int rv = os_proc_children((int)pid, &amp;proc_list, &amp;proc_count);</a>
<a name="ln1838">  if (rv == 2) {</a>
<a name="ln1839">    // syscall failed (possibly because of kernel options), try shelling out.</a>
<a name="ln1840">    DLOG(&quot;fallback to vim._os_proc_children()&quot;);</a>
<a name="ln1841">    MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1842">    ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1843">    Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_children(...)&quot;, a, err);</a>
<a name="ln1844">    if (o.type == kObjectTypeArray) {</a>
<a name="ln1845">      rvobj = o.data.array;</a>
<a name="ln1846">    } else if (!ERROR_SET(err)) {</a>
<a name="ln1847">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1848">                    &quot;Failed to get process children. pid=%&quot; PRId64 &quot; error=%d&quot;,</a>
<a name="ln1849">                    pid, rv);</a>
<a name="ln1850">    }</a>
<a name="ln1851">    goto end;</a>
<a name="ln1852">  }</a>
<a name="ln1853"> </a>
<a name="ln1854">  for (size_t i = 0; i &lt; proc_count; i++) {</a>
<a name="ln1855">    ADD(rvobj, INTEGER_OBJ(proc_list[i]));</a>
<a name="ln1856">  }</a>
<a name="ln1857"> </a>
<a name="ln1858">end:</a>
<a name="ln1859">  xfree(proc_list);</a>
<a name="ln1860">  return rvobj;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/// Gets info describing process `pid`.</a>
<a name="ln1864">///</a>
<a name="ln1865">/// @return Map of process properties, or NIL if process not found.</a>
<a name="ln1866">Object nvim_get_proc(Integer pid, Error *err)</a>
<a name="ln1867">  FUNC_API_SINCE(4)</a>
<a name="ln1868">{</a>
<a name="ln1869">  Object rvobj = OBJECT_INIT;</a>
<a name="ln1870">  rvobj.data.dictionary = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1871">  rvobj.type = kObjectTypeDictionary;</a>
<a name="ln1872"> </a>
<a name="ln1873">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1874">    return NIL;</a>
<a name="ln1875">  });</a>
<a name="ln1876"> </a>
<a name="ln1877">#ifdef MSWIN</a>
<a name="ln1878">  rvobj.data.dictionary = os_proc_info((int)pid);</a>
<a name="ln1879">  if (rvobj.data.dictionary.size == 0) {  // Process not found.</a>
<a name="ln1880">    return NIL;</a>
<a name="ln1881">  }</a>
<a name="ln1882">#else</a>
<a name="ln1883">  // Cross-platform process info APIs are miserable, so use `ps` instead.</a>
<a name="ln1884">  MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1885">  ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1886">  Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_info(...)&quot;, a, err);</a>
<a name="ln1887">  if (o.type == kObjectTypeArray &amp;&amp; o.data.array.size == 0) {</a>
<a name="ln1888">    return NIL;  // Process not found.</a>
<a name="ln1889">  } else if (o.type == kObjectTypeDictionary) {</a>
<a name="ln1890">    rvobj.data.dictionary = o.data.dictionary;</a>
<a name="ln1891">  } else if (!ERROR_SET(err)) {</a>
<a name="ln1892">    api_set_error(err, kErrorTypeException,</a>
<a name="ln1893">                  &quot;Failed to get process info. pid=%&quot; PRId64, pid);</a>
<a name="ln1894">  }</a>
<a name="ln1895">#endif</a>
<a name="ln1896">  return rvobj;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899">/// Selects an item in the completion popup menu.</a>
<a name="ln1900">///</a>
<a name="ln1901">/// If neither |ins-completion| nor |cmdline-completion| popup menu is active</a>
<a name="ln1902">/// this API call is silently ignored.</a>
<a name="ln1903">/// Useful for an external UI using |ui-popupmenu| to control the popup menu with the mouse.</a>
<a name="ln1904">/// Can also be used in a mapping; use &lt;Cmd&gt; |:map-cmd| or a Lua mapping to ensure the mapping</a>
<a name="ln1905">/// doesn't end completion mode.</a>
<a name="ln1906">///</a>
<a name="ln1907">/// @param item    Index (zero-based) of the item to select. Value of -1 selects nothing</a>
<a name="ln1908">///                and restores the original text.</a>
<a name="ln1909">/// @param insert  For |ins-completion|, whether the selection should be inserted in the buffer.</a>
<a name="ln1910">///                Ignored for |cmdline-completion|.</a>
<a name="ln1911">/// @param finish  Finish the completion and dismiss the popup menu. Implies {insert}.</a>
<a name="ln1912">/// @param opts    Optional parameters. Reserved for future use.</a>
<a name="ln1913">/// @param[out] err Error details, if any</a>
<a name="ln1914">void nvim_select_popupmenu_item(Integer item, Boolean insert, Boolean finish, Dictionary opts,</a>
<a name="ln1915">                                Error *err)</a>
<a name="ln1916">  FUNC_API_SINCE(6)</a>
<a name="ln1917">{</a>
<a name="ln1918">  VALIDATE((opts.size == 0), &quot;%s&quot;, &quot;opts dict isn't empty&quot;, {</a>
<a name="ln1919">    return;</a>
<a name="ln1920">  });</a>
<a name="ln1921"> </a>
<a name="ln1922">  if (finish) {</a>
<a name="ln1923">    insert = true;</a>
<a name="ln1924">  }</a>
<a name="ln1925"> </a>
<a name="ln1926">  pum_ext_select_item((int)item, insert, finish);</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">/// NB: if your UI doesn't use hlstate, this will not return hlstate first time</a>
<a name="ln1930">Array nvim__inspect_cell(Integer grid, Integer row, Integer col, Arena *arena, Error *err)</a>
<a name="ln1931">{</a>
<a name="ln1932">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1933"> </a>
<a name="ln1934">  // TODO(bfredl): if grid == 0 we should read from the compositor's buffer.</a>
<a name="ln1935">  // The only problem is that it does not yet exist.</a>
<a name="ln1936">  ScreenGrid *g = &amp;default_grid;</a>
<a name="ln1937">  if (grid == pum_grid.handle) {</a>
<a name="ln1938">    g = &amp;pum_grid;</a>
<a name="ln1939">  } else if (grid &gt; 1) {</a>
<a name="ln1940">    win_T *wp = get_win_by_grid_handle((handle_T)grid);</a>
<a name="ln1941">    VALIDATE_INT((wp != NULL &amp;&amp; wp-&gt;w_grid_alloc.chars != NULL), &quot;grid handle&quot;, grid, {</a>
<a name="ln1942">      return ret;</a>
<a name="ln1943">    });</a>
<a name="ln1944">    g = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln1945">  }</a>
<a name="ln1946"> </a>
<a name="ln1947">  if (row &lt; 0 || row &gt;= g-&gt;rows</a>
<a name="ln1948">      || col &lt; 0 || col &gt;= g-&gt;cols) {</a>
<a name="ln1949">    return ret;</a>
<a name="ln1950">  }</a>
<a name="ln1951">  ret = arena_array(arena, 3);</a>
<a name="ln1952">  size_t off = g-&gt;line_offset[(size_t)row] + (size_t)col;</a>
<a name="ln1953">  char *sc_buf = arena_alloc(arena, MAX_SCHAR_SIZE, false);</a>
<a name="ln1954">  schar_get(sc_buf, g-&gt;chars[off]);</a>
<a name="ln1955">  ADD_C(ret, CSTR_AS_OBJ(sc_buf));</a>
<a name="ln1956">  int attr = g-&gt;attrs[off];</a>
<a name="ln1957">  ADD_C(ret, DICTIONARY_OBJ(hl_get_attr_by_id(attr, true, arena, err)));</a>
<a name="ln1958">  // will not work first time</a>
<a name="ln1959">  if (!highlight_use_hlstate()) {</a>
<a name="ln1960">    ADD_C(ret, ARRAY_OBJ(hl_inspect(attr)));</a>
<a name="ln1961">  }</a>
<a name="ln1962">  return ret;</a>
<a name="ln1963">}</a>
<a name="ln1964"> </a>
<a name="ln1965">void nvim__screenshot(String path)</a>
<a name="ln1966">  FUNC_API_FAST</a>
<a name="ln1967">{</a>
<a name="ln1968">  ui_call_screenshot(path);</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">void nvim__invalidate_glyph_cache(void)</a>
<a name="ln1972">{</a>
<a name="ln1973">  schar_cache_clear_force();</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">Object nvim__unpack(String str, Error *err)</a>
<a name="ln1977">  FUNC_API_FAST</a>
<a name="ln1978">{</a>
<a name="ln1979">  return unpack(str.data, str.size, err);</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">/// Deletes an uppercase/file named mark. See |mark-motions|.</a>
<a name="ln1983">///</a>
<a name="ln1984">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln1985">/// @param name       Mark name</a>
<a name="ln1986">/// @return true if the mark was deleted, else false.</a>
<a name="ln1987">/// @see |nvim_buf_del_mark()|</a>
<a name="ln1988">/// @see |nvim_get_mark()|</a>
<a name="ln1989">Boolean nvim_del_mark(String name, Error *err)</a>
<a name="ln1990">  FUNC_API_SINCE(8)</a>
<a name="ln1991">{</a>
<a name="ln1992">  bool res = false;</a>
<a name="ln1993">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln1994">    return res;</a>
<a name="ln1995">  });</a>
<a name="ln1996">  // Only allow file/uppercase marks</a>
<a name="ln1997">  // TODO(muniter): Refactor this ASCII_ISUPPER macro to a proper function</a>
<a name="ln1998">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln1999">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2000">    return res;</a>
<a name="ln2001">  });</a>
<a name="ln2002">  res = set_mark(NULL, name, 0, 0, err);</a>
<a name="ln2003">  return res;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">/// Returns a `(row, col, buffer, buffername)` tuple representing the position</a>
<a name="ln2007">/// of the uppercase/file named mark. &quot;End of line&quot; column position is returned</a>
<a name="ln2008">/// as |v:maxcol| (big number). See |mark-motions|.</a>
<a name="ln2009">///</a>
<a name="ln2010">/// Marks are (1,0)-indexed. |api-indexing|</a>
<a name="ln2011">///</a>
<a name="ln2012">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln2013">/// @param name       Mark name</a>
<a name="ln2014">/// @param opts       Optional parameters. Reserved for future use.</a>
<a name="ln2015">/// @return 4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is</a>
<a name="ln2016">/// not set.</a>
<a name="ln2017">/// @see |nvim_buf_set_mark()|</a>
<a name="ln2018">/// @see |nvim_del_mark()|</a>
<a name="ln2019">Array nvim_get_mark(String name, Dictionary opts, Error *err)</a>
<a name="ln2020">  FUNC_API_SINCE(8)</a>
<a name="ln2021">{</a>
<a name="ln2022">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln2023"> </a>
<a name="ln2024">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln2025">    return rv;</a>
<a name="ln2026">  });</a>
<a name="ln2027">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln2028">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2029">    return rv;</a>
<a name="ln2030">  });</a>
<a name="ln2031"> </a>
<a name="ln2032">  xfmark_T *mark = mark_get_global(false, *name.data);  // false avoids loading the mark buffer</a>
<a name="ln2033">  pos_T pos = mark-&gt;fmark.mark;</a>
<a name="ln2034">  bool allocated = false;</a>
<a name="ln2035">  int bufnr;</a>
<a name="ln2036">  char *filename;</a>
<a name="ln2037"> </a>
<a name="ln2038">  // Marks are from an open buffer it fnum is non zero</a>
<a name="ln2039">  if (mark-&gt;fmark.fnum != 0) {</a>
<a name="ln2040">    bufnr = mark-&gt;fmark.fnum;</a>
<a name="ln2041">    filename = buflist_nr2name(bufnr, true, true);</a>
<a name="ln2042">    allocated = true;</a>
<a name="ln2043">    // Marks comes from shada</a>
<a name="ln2044">  } else {</a>
<a name="ln2045">    filename = mark-&gt;fname;</a>
<a name="ln2046">    bufnr = 0;</a>
<a name="ln2047">  }</a>
<a name="ln2048"> </a>
<a name="ln2049">  bool exists = filename != NULL;</a>
<a name="ln2050">  Integer row;</a>
<a name="ln2051">  Integer col;</a>
<a name="ln2052"> </a>
<a name="ln2053">  if (!exists || pos.lnum &lt;= 0) {</a>
<a name="ln2054">    if (allocated) {</a>
<a name="ln2055">      xfree(filename);</a>
<a name="ln2056">      allocated = false;</a>
<a name="ln2057">    }</a>
<a name="ln2058">    filename = &quot;&quot;;</a>
<a name="ln2059">    bufnr = 0;</a>
<a name="ln2060">    row = 0;</a>
<a name="ln2061">    col = 0;</a>
<a name="ln2062">  } else {</a>
<a name="ln2063">    row = pos.lnum;</a>
<a name="ln2064">    col = pos.col;</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  ADD(rv, INTEGER_OBJ(row));</a>
<a name="ln2068">  ADD(rv, INTEGER_OBJ(col));</a>
<a name="ln2069">  ADD(rv, INTEGER_OBJ(bufnr));</a>
<a name="ln2070">  ADD(rv, CSTR_TO_OBJ(filename));</a>
<a name="ln2071"> </a>
<a name="ln2072">  if (allocated) {</a>
<a name="ln2073">    xfree(filename);</a>
<a name="ln2074">  }</a>
<a name="ln2075"> </a>
<a name="ln2076">  return rv;</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">/// Evaluates statusline string.</a>
<a name="ln2080">///</a>
<a name="ln2081">/// @param str Statusline string (see 'statusline').</a>
<a name="ln2082">/// @param opts Optional parameters.</a>
<a name="ln2083">///           - winid: (number) |window-ID| of the window to use as context for statusline.</a>
<a name="ln2084">///           - maxwidth: (number) Maximum width of statusline.</a>
<a name="ln2085">///           - fillchar: (string) Character to fill blank spaces in the statusline (see</a>
<a name="ln2086">///                                'fillchars'). Treated as single-width even if it isn't.</a>
<a name="ln2087">///           - highlights: (boolean) Return highlight information.</a>
<a name="ln2088">///           - use_winbar: (boolean) Evaluate winbar instead of statusline.</a>
<a name="ln2089">///           - use_tabline: (boolean) Evaluate tabline instead of statusline. When true, {winid}</a>
<a name="ln2090">///                                    is ignored. Mutually exclusive with {use_winbar}.</a>
<a name="ln2091">///           - use_statuscol_lnum: (number) Evaluate statuscolumn for this line number instead of statusline.</a>
<a name="ln2092">///</a>
<a name="ln2093">/// @param[out] err Error details, if any.</a>
<a name="ln2094">/// @return Dictionary containing statusline information, with these keys:</a>
<a name="ln2095">///       - str: (string) Characters that will be displayed on the statusline.</a>
<a name="ln2096">///       - width: (number) Display width of the statusline.</a>
<a name="ln2097">///       - highlights: Array containing highlight information of the statusline. Only included when</a>
<a name="ln2098">///                     the &quot;highlights&quot; key in {opts} is true. Each element of the array is a</a>
<a name="ln2099">///                     |Dictionary| with these keys:</a>
<a name="ln2100">///           - start: (number) Byte index (0-based) of first character that uses the highlight.</a>
<a name="ln2101">///           - group: (string) Name of highlight group.</a>
<a name="ln2102">Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *err)</a>
<a name="ln2103">  FUNC_API_SINCE(8) FUNC_API_FAST</a>
<a name="ln2104">{</a>
<a name="ln2105">  Dictionary result = ARRAY_DICT_INIT;</a>
<a name="ln2106"> </a>
<a name="ln2107">  int maxwidth;</a>
<a name="ln2108">  int fillchar = 0;</a>
<a name="ln2109">  int statuscol_lnum = 0;</a>
<a name="ln2110">  Window window = 0;</a>
<a name="ln2111"> </a>
<a name="ln2112">  if (str.size &lt; 2 || memcmp(str.data, &quot;%!&quot;, 2) != 0) {</a>
<a name="ln2113">    const char *const errmsg = check_stl_option(str.data);</a>
<a name="ln2114">    VALIDATE(!errmsg, &quot;%s&quot;, errmsg, {</a>
<a name="ln2115">      return result;</a>
<a name="ln2116">    });</a>
<a name="ln2117">  }</a>
<a name="ln2118"> </a>
<a name="ln2119">  if (HAS_KEY(opts, eval_statusline, winid)) {</a>
<a name="ln2120">    window = opts-&gt;winid;</a>
<a name="ln2121">  }</a>
<a name="ln2122">  if (HAS_KEY(opts, eval_statusline, fillchar)) {</a>
<a name="ln2123">    VALIDATE_EXP((*opts-&gt;fillchar.data != 0</a>
<a name="ln2124">                  &amp;&amp; ((size_t)utf_ptr2len(opts-&gt;fillchar.data) == opts-&gt;fillchar.size)),</a>
<a name="ln2125">                 &quot;fillchar&quot;, &quot;single character&quot;, NULL, {</a>
<a name="ln2126">      return result;</a>
<a name="ln2127">    });</a>
<a name="ln2128">    fillchar = utf_ptr2char(opts-&gt;fillchar.data);</a>
<a name="ln2129">  }</a>
<a name="ln2130"> </a>
<a name="ln2131">  int use_bools = (int)opts-&gt;use_winbar + (int)opts-&gt;use_tabline;</a>
<a name="ln2132"> </a>
<a name="ln2133">  win_T *wp = opts-&gt;use_tabline ? curwin : find_window_by_handle(window, err);</a>
<a name="ln2134">  if (wp == NULL) {</a>
<a name="ln2135">    api_set_error(err, kErrorTypeException, &quot;unknown winid %d&quot;, window);</a>
<a name="ln2136">    return result;</a>
<a name="ln2137">  }</a>
<a name="ln2138"> </a>
<a name="ln2139">  if (HAS_KEY(opts, eval_statusline, use_statuscol_lnum)) {</a>
<a name="ln2140">    statuscol_lnum = (int)opts-&gt;use_statuscol_lnum;</a>
<a name="ln2141">    VALIDATE_RANGE(statuscol_lnum &gt; 0 &amp;&amp; statuscol_lnum &lt;= wp-&gt;w_buffer-&gt;b_ml.ml_line_count,</a>
<a name="ln2142">                   &quot;use_statuscol_lnum&quot;, {</a>
<a name="ln2143">      return result;</a>
<a name="ln2144">    });</a>
<a name="ln2145">    use_bools++;</a>
<a name="ln2146">  }</a>
<a name="ln2147">  VALIDATE(use_bools &lt;= 1, &quot;%s&quot;,</a>
<a name="ln2148">           &quot;Can only use one of 'use_winbar', 'use_tabline' and 'use_statuscol_lnum'&quot;, {</a>
<a name="ln2149">    return result;</a>
<a name="ln2150">  });</a>
<a name="ln2151"> </a>
<a name="ln2152">  int stc_hl_id = 0;</a>
<a name="ln2153">  statuscol_T statuscol = { 0 };</a>
<a name="ln2154">  SignTextAttrs sattrs[SIGN_SHOW_MAX] = { 0 };</a>
<a name="ln2155"> </a>
<a name="ln2156">  if (opts-&gt;use_tabline) {</a>
<a name="ln2157">    fillchar = ' ';</a>
<a name="ln2158">  } else {</a>
<a name="ln2159">    if (fillchar == 0) {</a>
<a name="ln2160">      if (opts-&gt;use_winbar) {</a>
<a name="ln2161">        fillchar = wp-&gt;w_p_fcs_chars.wbr;</a>
<a name="ln2162">      } else {</a>
<a name="ln2163">        int attr;</a>
<a name="ln2164">        fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln2165">      }</a>
<a name="ln2166">    }</a>
<a name="ln2167">    if (statuscol_lnum) {</a>
<a name="ln2168">      HlPriId line = { 0 };</a>
<a name="ln2169">      HlPriId cul  = { 0 };</a>
<a name="ln2170">      HlPriId num  = { 0 };</a>
<a name="ln2171">      linenr_T lnum = statuscol_lnum;</a>
<a name="ln2172">      int num_signs = buf_get_signattrs(wp-&gt;w_buffer, lnum, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2173">      decor_redraw_signs(wp-&gt;w_buffer, lnum - 1, &amp;num_signs, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2174">      wp-&gt;w_scwidth = win_signcol_count(wp);</a>
<a name="ln2175"> </a>
<a name="ln2176">      statuscol.sattrs = sattrs;</a>
<a name="ln2177">      statuscol.foldinfo = fold_info(wp, lnum);</a>
<a name="ln2178">      wp-&gt;w_cursorline = win_cursorline_standout(wp) ? wp-&gt;w_cursor.lnum : 0;</a>
<a name="ln2179"> </a>
<a name="ln2180">      if (wp-&gt;w_p_cul) {</a>
<a name="ln2181">        if (statuscol.foldinfo.fi_level != 0 &amp;&amp; statuscol.foldinfo.fi_lines &gt; 0) {</a>
<a name="ln2182">          wp-&gt;w_cursorline = statuscol.foldinfo.fi_lnum;</a>
<a name="ln2183">        }</a>
<a name="ln2184">        statuscol.use_cul = lnum == wp-&gt;w_cursorline &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR);</a>
<a name="ln2185">      }</a>
<a name="ln2186"> </a>
<a name="ln2187">      statuscol.sign_cul_id = statuscol.use_cul ? cul.hl_id : 0;</a>
<a name="ln2188">      if (num.hl_id) {</a>
<a name="ln2189">        stc_hl_id = num.hl_id;</a>
<a name="ln2190">      } else if (statuscol.use_cul) {</a>
<a name="ln2191">        stc_hl_id = HLF_CLN + 1;</a>
<a name="ln2192">      } else if (wp-&gt;w_p_rnu) {</a>
<a name="ln2193">        stc_hl_id = (lnum &lt; wp-&gt;w_cursor.lnum ? HLF_LNA : HLF_LNB) + 1;</a>
<a name="ln2194">      } else {</a>
<a name="ln2195">        stc_hl_id = HLF_N + 1;</a>
<a name="ln2196">      }</a>
<a name="ln2197"> </a>
<a name="ln2198">      set_vim_var_nr(VV_LNUM, lnum);</a>
<a name="ln2199">      set_vim_var_nr(VV_RELNUM, labs(get_cursor_rel_lnum(wp, lnum)));</a>
<a name="ln2200">      set_vim_var_nr(VV_VIRTNUM, 0);</a>
<a name="ln2201">    }</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  if (HAS_KEY(opts, eval_statusline, maxwidth)) {</a>
<a name="ln2205">    maxwidth = (int)opts-&gt;maxwidth;</a>
<a name="ln2206">  } else {</a>
<a name="ln2207">    maxwidth = statuscol_lnum ? win_col_off(wp)</a>
<a name="ln2208">               : (opts-&gt;use_tabline</a>
<a name="ln2209">                  || (!opts-&gt;use_winbar &amp;&amp; global_stl_height() &gt; 0)) ? Columns : wp-&gt;w_width;</a>
<a name="ln2210">  }</a>
<a name="ln2211"> </a>
<a name="ln2212">  char buf[MAXPATHL];</a>
<a name="ln2213">  stl_hlrec_t *hltab;</a>
<a name="ln2214"> </a>
<a name="ln2215">  // Temporarily reset 'cursorbind' to prevent side effects from moving the cursor away and back.</a>
<a name="ln2216">  int p_crb_save = wp-&gt;w_p_crb;</a>
<a name="ln2217">  wp-&gt;w_p_crb = false;</a>
<a name="ln2218"> </a>
<a name="ln2219">  int width = build_stl_str_hl(wp,</a>
<a name="ln2220">                               buf,</a>
<a name="ln2221">                               sizeof(buf),</a>
<a name="ln2222">                               str.data,</a>
<a name="ln2223">                               NULL,</a>
<a name="ln2224">                               0,</a>
<a name="ln2225">                               fillchar,</a>
<a name="ln2226">                               maxwidth,</a>
<a name="ln2227">                               opts-&gt;highlights ? &amp;hltab : NULL,</a>
<a name="ln2228">                               NULL,</a>
<a name="ln2229">                               statuscol_lnum ? &amp;statuscol : NULL);</a>
<a name="ln2230"> </a>
<a name="ln2231">  PUT(result, &quot;width&quot;, INTEGER_OBJ(width));</a>
<a name="ln2232"> </a>
<a name="ln2233">  // Restore original value of 'cursorbind'</a>
<a name="ln2234">  wp-&gt;w_p_crb = p_crb_save;</a>
<a name="ln2235"> </a>
<a name="ln2236">  if (opts-&gt;highlights) {</a>
<a name="ln2237">    Array hl_values = ARRAY_DICT_INIT;</a>
<a name="ln2238">    const char *grpname;</a>
<a name="ln2239">    char user_group[15];  // strlen(&quot;User&quot;) + strlen(&quot;2147483647&quot;) + NUL</a>
<a name="ln2240"> </a>
<a name="ln2241">    // If first character doesn't have a defined highlight,</a>
<a name="ln2242">    // add the default highlight at the beginning of the highlight list</a>
<a name="ln2243">    if (hltab-&gt;start == NULL || (hltab-&gt;start - buf) != 0) {</a>
<a name="ln2244">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2245">      grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2246"> </a>
<a name="ln2247">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(0));</a>
<a name="ln2248">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2249"> </a>
<a name="ln2250">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2251">    }</a>
<a name="ln2252"> </a>
<a name="ln2253">    for (stl_hlrec_t *sp = hltab; sp-&gt;start != NULL; sp++) {</a>
<a name="ln2254">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2255"> </a>
<a name="ln2256">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(sp-&gt;start - buf));</a>
<a name="ln2257"> </a>
<a name="ln2258">      if (sp-&gt;userhl == 0) {</a>
<a name="ln2259">        grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2260">      } else if (sp-&gt;userhl &lt; 0) {</a>
<a name="ln2261">        grpname = syn_id2name(-sp-&gt;userhl);</a>
<a name="ln2262">      } else {</a>
<a name="ln2263">        snprintf(user_group, sizeof(user_group), &quot;User%d&quot;, sp-&gt;userhl);</a>
<a name="ln2264">        grpname = user_group;</a>
<a name="ln2265">      }</a>
<a name="ln2266">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2267">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2268">    }</a>
<a name="ln2269">    PUT(result, &quot;highlights&quot;, ARRAY_OBJ(hl_values));</a>
<a name="ln2270">  }</a>
<a name="ln2271">  PUT(result, &quot;str&quot;, CSTR_TO_OBJ(buf));</a>
<a name="ln2272"> </a>
<a name="ln2273">  return result;</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276">void nvim_error_event(uint64_t channel_id, Integer lvl, String data)</a>
<a name="ln2277">  FUNC_API_REMOTE_ONLY</a>
<a name="ln2278">{</a>
<a name="ln2279">  // TODO(bfredl): consider printing message to user, as will be relevant</a>
<a name="ln2280">  // if we fork nvim processes as async workers</a>
<a name="ln2281">  ELOG(&quot;async error on channel %&quot; PRId64 &quot;: %s&quot;, channel_id, data.size ? data.data : &quot;&quot;);</a>
<a name="ln2282">}</a>
</code></pre>
<div class="balloon" rel="567"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>