<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vim.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;stdbool.h&gt;</a>
<a name="ln8">#include &lt;stddef.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;klib/kvec.h&quot;</a>
<a name="ln14">#include &quot;lauxlib.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/keysets.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln23">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln24">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln25">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln26">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln27">#include &quot;nvim/channel.h&quot;</a>
<a name="ln28">#include &quot;nvim/context.h&quot;</a>
<a name="ln29">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln30">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln31">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval.h&quot;</a>
<a name="ln33">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln36">#include &quot;nvim/fold.h&quot;</a>
<a name="ln37">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln38">#include &quot;nvim/globals.h&quot;</a>
<a name="ln39">#include &quot;nvim/grid.h&quot;</a>
<a name="ln40">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln41">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln42">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln43">#include &quot;nvim/log.h&quot;</a>
<a name="ln44">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln45">#include &quot;nvim/macros.h&quot;</a>
<a name="ln46">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln47">#include &quot;nvim/mark.h&quot;</a>
<a name="ln48">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln49">#include &quot;nvim/memline.h&quot;</a>
<a name="ln50">#include &quot;nvim/memory.h&quot;</a>
<a name="ln51">#include &quot;nvim/message.h&quot;</a>
<a name="ln52">#include &quot;nvim/move.h&quot;</a>
<a name="ln53">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln54">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln55">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln56">#include &quot;nvim/ops.h&quot;</a>
<a name="ln57">#include &quot;nvim/option.h&quot;</a>
<a name="ln58">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln59">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln60">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln61">#include &quot;nvim/os/process.h&quot;</a>
<a name="ln62">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln63">#include &quot;nvim/pos.h&quot;</a>
<a name="ln64">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln65">#include &quot;nvim/sign.h&quot;</a>
<a name="ln66">#include &quot;nvim/state.h&quot;</a>
<a name="ln67">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln68">#include &quot;nvim/strings.h&quot;</a>
<a name="ln69">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln70">#include &quot;nvim/types.h&quot;</a>
<a name="ln71">#include &quot;nvim/ui.h&quot;</a>
<a name="ln72">#include &quot;nvim/vim.h&quot;</a>
<a name="ln73">#include &quot;nvim/window.h&quot;</a>
<a name="ln74"> </a>
<a name="ln75">#define LINE_BUFFER_MIN_SIZE 4096</a>
<a name="ln76"> </a>
<a name="ln77">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln78"># include &quot;api/vim.c.generated.h&quot;</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">/// Gets a highlight group by name</a>
<a name="ln82">///</a>
<a name="ln83">/// similar to |hlID()|, but allocates a new ID if not present.</a>
<a name="ln84">Integer nvim_get_hl_id_by_name(String name)</a>
<a name="ln85">  FUNC_API_SINCE(7)</a>
<a name="ln86">{</a>
<a name="ln87">  return syn_check_group(name.data, name.size);</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">/// Gets all or specific highlight groups in a namespace.</a>
<a name="ln91">///</a>
<a name="ln92">/// @note When the `link` attribute is defined in the highlight definition</a>
<a name="ln93">///       map, other attributes will not be taking effect (see |:hi-link|).</a>
<a name="ln94">///</a>
<a name="ln95">/// @param ns_id Get highlight groups for namespace ns_id |nvim_get_namespaces()|.</a>
<a name="ln96">///              Use 0 to get global highlight groups |:highlight|.</a>
<a name="ln97">/// @param opts  Options dict:</a>
<a name="ln98">///                 - name: (string) Get a highlight definition by name.</a>
<a name="ln99">///                 - id: (integer) Get a highlight definition by id.</a>
<a name="ln100">///                 - link: (boolean, default true) Show linked group name instead of effective definition |:hi-link|.</a>
<a name="ln101">///                 - create: (boolean, default true) When highlight group doesn't exist create it.</a>
<a name="ln102">///</a>
<a name="ln103">/// @param[out] err Error details, if any.</a>
<a name="ln104">/// @return Highlight groups as a map from group name to a highlight definition map as in |nvim_set_hl()|,</a>
<a name="ln105">///                   or only a single highlight definition map if requested by name or id.</a>
<a name="ln106">Dictionary nvim_get_hl(Integer ns_id, Dict(get_highlight) *opts, Arena *arena, Error *err)</a>
<a name="ln107">  FUNC_API_SINCE(11)</a>
<a name="ln108">{</a>
<a name="ln109">  return ns_get_hl_defs((NS)ns_id, opts, arena, err);</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">/// Sets a highlight group.</a>
<a name="ln113">///</a>
<a name="ln114">/// @note Unlike the `:highlight` command which can update a highlight group,</a>
<a name="ln115">///       this function completely replaces the definition. For example:</a>
<a name="ln116">///       ``nvim_set_hl(0, 'Visual', {})`` will clear the highlight group</a>
<a name="ln117">///       'Visual'.</a>
<a name="ln118">///</a>
<a name="ln119">/// @note The fg and bg keys also accept the string values `&quot;fg&quot;` or `&quot;bg&quot;`</a>
<a name="ln120">///       which act as aliases to the corresponding foreground and background</a>
<a name="ln121">///       values of the Normal group. If the Normal group has not been defined,</a>
<a name="ln122">///       using these values results in an error.</a>
<a name="ln123">///</a>
<a name="ln124">///</a>
<a name="ln125">/// @note If `link` is used in combination with other attributes; only the</a>
<a name="ln126">///       `link` will take effect (see |:hi-link|).</a>
<a name="ln127">///</a>
<a name="ln128">/// @param ns_id Namespace id for this highlight |nvim_create_namespace()|.</a>
<a name="ln129">///              Use 0 to set a highlight group globally |:highlight|.</a>
<a name="ln130">///              Highlights from non-global namespaces are not active by default, use</a>
<a name="ln131">///              |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to activate them.</a>
<a name="ln132">/// @param name  Highlight group name, e.g. &quot;ErrorMsg&quot;</a>
<a name="ln133">/// @param val   Highlight definition map, accepts the following keys:</a>
<a name="ln134">///                - fg (or foreground): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln135">///                - bg (or background): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln136">///                - sp (or special): color name or &quot;#RRGGBB&quot;</a>
<a name="ln137">///                - blend: integer between 0 and 100</a>
<a name="ln138">///                - bold: boolean</a>
<a name="ln139">///                - standout: boolean</a>
<a name="ln140">///                - underline: boolean</a>
<a name="ln141">///                - undercurl: boolean</a>
<a name="ln142">///                - underdouble: boolean</a>
<a name="ln143">///                - underdotted: boolean</a>
<a name="ln144">///                - underdashed: boolean</a>
<a name="ln145">///                - strikethrough: boolean</a>
<a name="ln146">///                - italic: boolean</a>
<a name="ln147">///                - reverse: boolean</a>
<a name="ln148">///                - nocombine: boolean</a>
<a name="ln149">///                - link: name of another highlight group to link to, see |:hi-link|.</a>
<a name="ln150">///                - default: Don't override existing definition |:hi-default|</a>
<a name="ln151">///                - ctermfg: Sets foreground of cterm color |ctermfg|</a>
<a name="ln152">///                - ctermbg: Sets background of cterm color |ctermbg|</a>
<a name="ln153">///                - cterm: cterm attribute map, like |highlight-args|. If not set,</a>
<a name="ln154">///                         cterm attributes will match those from the attribute map</a>
<a name="ln155">///                         documented above.</a>
<a name="ln156">///                - force: if true force update the highlight group when it exists.</a>
<a name="ln157">/// @param[out] err Error details, if any</a>
<a name="ln158">///</a>
<a name="ln159">// TODO(bfredl): val should take update vs reset flag</a>
<a name="ln160">void nvim_set_hl(Integer ns_id, String name, Dict(highlight) *val, Error *err)</a>
<a name="ln161">  FUNC_API_SINCE(7)</a>
<a name="ln162">{</a>
<a name="ln163">  int hl_id = syn_check_group(name.data, name.size);</a>
<a name="ln164">  VALIDATE_S((hl_id != 0), &quot;highlight name&quot;, name.data, {</a>
<a name="ln165">    return;</a>
<a name="ln166">  });</a>
<a name="ln167">  int link_id = -1;</a>
<a name="ln168"> </a>
<a name="ln169">  HlAttrs attrs = dict2hlattrs(val, true, &amp;link_id, err);</a>
<a name="ln170">  if (!ERROR_SET(err)) {</a>
<a name="ln171">    ns_hl_def((NS)ns_id, hl_id, attrs, link_id, val);</a>
<a name="ln172">  }</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">/// Set active namespace for highlights defined with |nvim_set_hl()|. This can be set for</a>
<a name="ln176">/// a single window, see |nvim_win_set_hl_ns()|.</a>
<a name="ln177">///</a>
<a name="ln178">/// @param ns_id the namespace to use</a>
<a name="ln179">/// @param[out] err Error details, if any</a>
<a name="ln180">void nvim_set_hl_ns(Integer ns_id, Error *err)</a>
<a name="ln181">  FUNC_API_SINCE(10)</a>
<a name="ln182">{</a>
<a name="ln183">  VALIDATE_INT((ns_id &gt;= 0), &quot;namespace&quot;, ns_id, {</a>
<a name="ln184">    return;</a>
<a name="ln185">  });</a>
<a name="ln186"> </a>
<a name="ln187">  ns_hl_global = (NS)ns_id;</a>
<a name="ln188">  hl_check_ns();</a>
<a name="ln189">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/// Set active namespace for highlights defined with |nvim_set_hl()| while redrawing.</a>
<a name="ln193">///</a>
<a name="ln194">/// This function meant to be called while redrawing, primarily from</a>
<a name="ln195">/// |nvim_set_decoration_provider()| on_win and on_line callbacks, which</a>
<a name="ln196">/// are allowed to change the namespace during a redraw cycle.</a>
<a name="ln197">///</a>
<a name="ln198">/// @param ns_id the namespace to activate</a>
<a name="ln199">/// @param[out] err Error details, if any</a>
<a name="ln200">void nvim_set_hl_ns_fast(Integer ns_id, Error *err)</a>
<a name="ln201">  FUNC_API_SINCE(10)</a>
<a name="ln202">  FUNC_API_FAST</a>
<a name="ln203">{</a>
<a name="ln204">  ns_hl_fast = (NS)ns_id;</a>
<a name="ln205">  hl_check_ns();</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">/// Sends input-keys to Nvim, subject to various quirks controlled by `mode`</a>
<a name="ln209">/// flags. This is a blocking call, unlike |nvim_input()|.</a>
<a name="ln210">///</a>
<a name="ln211">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln212">///</a>
<a name="ln213">/// To input sequences like &lt;C-o&gt; use |nvim_replace_termcodes()| (typically</a>
<a name="ln214">/// with escape_ks=false) to replace |keycodes|, then pass the result to</a>
<a name="ln215">/// nvim_feedkeys().</a>
<a name="ln216">///</a>
<a name="ln217">/// Example:</a>
<a name="ln218">///</a>
<a name="ln219">/// ```vim</a>
<a name="ln220">/// :let key = nvim_replace_termcodes(&quot;&lt;C-o&gt;&quot;, v:true, v:false, v:true)</a>
<a name="ln221">/// :call nvim_feedkeys(key, 'n', v:false)</a>
<a name="ln222">/// ```</a>
<a name="ln223">///</a>
<a name="ln224">/// @param keys         to be typed</a>
<a name="ln225">/// @param mode         behavior flags, see |feedkeys()|</a>
<a name="ln226">/// @param escape_ks    If true, escape K_SPECIAL bytes in `keys`.</a>
<a name="ln227">///                     This should be false if you already used</a>
<a name="ln228">///                     |nvim_replace_termcodes()|, and true otherwise.</a>
<a name="ln229">/// @see feedkeys()</a>
<a name="ln230">/// @see vim_strsave_escape_ks</a>
<a name="ln231">void nvim_feedkeys(String keys, String mode, Boolean escape_ks)</a>
<a name="ln232">  FUNC_API_SINCE(1)</a>
<a name="ln233">{</a>
<a name="ln234">  bool remap = true;</a>
<a name="ln235">  bool insert = false;</a>
<a name="ln236">  bool typed = false;</a>
<a name="ln237">  bool execute = false;</a>
<a name="ln238">  bool dangerous = false;</a>
<a name="ln239"> </a>
<a name="ln240">  for (size_t i = 0; i &lt; mode.size; i++) {</a>
<a name="ln241">    switch (mode.data[i]) {</a>
<a name="ln242">    case 'n':</a>
<a name="ln243">      remap = false; break;</a>
<a name="ln244">    case 'm':</a>
<a name="ln245">      remap = true; break;</a>
<a name="ln246">    case 't':</a>
<a name="ln247">      typed = true; break;</a>
<a name="ln248">    case 'i':</a>
<a name="ln249">      insert = true; break;</a>
<a name="ln250">    case 'x':</a>
<a name="ln251">      execute = true; break;</a>
<a name="ln252">    case '!':</a>
<a name="ln253">      dangerous = true; break;</a>
<a name="ln254">    }</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  if (keys.size == 0 &amp;&amp; !execute) {</a>
<a name="ln258">    return;</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  char *keys_esc;</a>
<a name="ln262">  if (escape_ks) {</a>
<a name="ln263">    // Need to escape K_SPECIAL before putting the string in the</a>
<a name="ln264">    // typeahead buffer.</a>
<a name="ln265">    keys_esc = vim_strsave_escape_ks(keys.data);</a>
<a name="ln266">  } else {</a>
<a name="ln267">    keys_esc = keys.data;</a>
<a name="ln268">  }</a>
<a name="ln269">  ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),</a>
<a name="ln270">              insert ? 0 : typebuf.tb_len, !typed, false);</a>
<a name="ln271">  if (vgetc_busy) {</a>
<a name="ln272">    typebuf_was_filled = true;</a>
<a name="ln273">  }</a>
<a name="ln274"> </a>
<a name="ln275">  if (escape_ks) {</a>
<a name="ln276">    xfree(keys_esc);</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  if (execute) {</a>
<a name="ln280">    int save_msg_scroll = msg_scroll;</a>
<a name="ln281"> </a>
<a name="ln282">    // Avoid a 1 second delay when the keys start Insert mode.</a>
<a name="ln283">    msg_scroll = false;</a>
<a name="ln284">    if (!dangerous) {</a>
<a name="ln285">      ex_normal_busy++;</a>
<a name="ln286">    }</a>
<a name="ln287">    exec_normal(true);</a>
<a name="ln288">    if (!dangerous) {</a>
<a name="ln289">      ex_normal_busy--;</a>
<a name="ln290">    }</a>
<a name="ln291">    msg_scroll |= save_msg_scroll;</a>
<a name="ln292">  }</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">/// Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level</a>
<a name="ln296">/// input buffer and the call is non-blocking (input is processed</a>
<a name="ln297">/// asynchronously by the eventloop).</a>
<a name="ln298">///</a>
<a name="ln299">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln300">///</a>
<a name="ln301">/// @note |keycodes| like &lt;CR&gt; are translated, so &quot;&lt;&quot; is special.</a>
<a name="ln302">///       To input a literal &quot;&lt;&quot;, send &lt;LT&gt;.</a>
<a name="ln303">///</a>
<a name="ln304">/// @note For mouse events use |nvim_input_mouse()|. The pseudokey form</a>
<a name="ln305">///       &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is deprecated since |api-level| 6.</a>
<a name="ln306">///</a>
<a name="ln307">/// @param keys to be typed</a>
<a name="ln308">/// @return Number of bytes actually written (can be fewer than</a>
<a name="ln309">///         requested if the buffer becomes full).</a>
<a name="ln310">Integer nvim_input(String keys)</a>
<a name="ln311">  FUNC_API_SINCE(1) FUNC_API_FAST</a>
<a name="ln312">{</a>
<a name="ln313">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln314">  return (Integer)input_enqueue(keys);</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">/// Send mouse event from GUI.</a>
<a name="ln318">///</a>
<a name="ln319">/// Non-blocking: does not wait on any result, but queues the event to be</a>
<a name="ln320">/// processed soon by the event loop.</a>
<a name="ln321">///</a>
<a name="ln322">/// @note Currently this doesn't support &quot;scripting&quot; multiple mouse events</a>
<a name="ln323">///       by calling it multiple times in a loop: the intermediate mouse</a>
<a name="ln324">///       positions will be ignored. It should be used to implement real-time</a>
<a name="ln325">///       mouse input in a GUI. The deprecated pseudokey form</a>
<a name="ln326">///       (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of |nvim_input()| has the same limitation.</a>
<a name="ln327">///</a>
<a name="ln328">/// @param button Mouse button: one of &quot;left&quot;, &quot;right&quot;, &quot;middle&quot;, &quot;wheel&quot;, &quot;move&quot;.</a>
<a name="ln329">/// @param action For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;, &quot;release&quot;.</a>
<a name="ln330">///               For the wheel, one of &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;. Ignored for &quot;move&quot;.</a>
<a name="ln331">/// @param modifier String of modifiers each represented by a single char.</a>
<a name="ln332">///                 The same specifiers are used as for a key press, except</a>
<a name="ln333">///                 that the &quot;-&quot; separator is optional, so &quot;C-A-&quot;, &quot;c-a&quot;</a>
<a name="ln334">///                 and &quot;CA&quot; can all be used to specify Ctrl+Alt+click.</a>
<a name="ln335">/// @param grid Grid number if the client uses |ui-multigrid|, else 0.</a>
<a name="ln336">/// @param row Mouse row-position (zero-based, like redraw events)</a>
<a name="ln337">/// @param col Mouse column-position (zero-based, like redraw events)</a>
<a name="ln338">/// @param[out] err Error details, if any</a>
<a name="ln339">void nvim_input_mouse(String button, String action, String modifier, Integer grid, Integer row,</a>
<a name="ln340">                      Integer col, Error *err)</a>
<a name="ln341">  FUNC_API_SINCE(6) FUNC_API_FAST</a>
<a name="ln342">{</a>
<a name="ln343">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln344"> </a>
<a name="ln345">  if (button.data == NULL || action.data == NULL) {</a>
<a name="ln346">    goto error;</a>
<a name="ln347">  }</a>
<a name="ln348"> </a>
<a name="ln349">  int code = 0;</a>
<a name="ln350"> </a>
<a name="ln351">  if (strequal(button.data, &quot;left&quot;)) {</a>
<a name="ln352">    code = KE_LEFTMOUSE;</a>
<a name="ln353">  } else if (strequal(button.data, &quot;middle&quot;)) {</a>
<a name="ln354">    code = KE_MIDDLEMOUSE;</a>
<a name="ln355">  } else if (strequal(button.data, &quot;right&quot;)) {</a>
<a name="ln356">    code = KE_RIGHTMOUSE;</a>
<a name="ln357">  } else if (strequal(button.data, &quot;wheel&quot;)) {</a>
<a name="ln358">    code = KE_MOUSEDOWN;</a>
<a name="ln359">  } else if (strequal(button.data, &quot;move&quot;)) {</a>
<a name="ln360">    code = KE_MOUSEMOVE;</a>
<a name="ln361">  } else {</a>
<a name="ln362">    goto error;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  if (code == KE_MOUSEDOWN) {</a>
<a name="ln366">    if (strequal(action.data, &quot;down&quot;)) {</a>
<a name="ln367">      code = KE_MOUSEUP;</a>
<a name="ln368">    } else if (strequal(action.data, &quot;up&quot;)) {</a>
<a name="ln369">      // code = KE_MOUSEDOWN</a>
<a name="ln370">    } else if (strequal(action.data, &quot;left&quot;)) {</a>
<a name="ln371">      code = KE_MOUSERIGHT;</a>
<a name="ln372">    } else if (strequal(action.data, &quot;right&quot;)) {</a>
<a name="ln373">      code = KE_MOUSELEFT;</a>
<a name="ln374">    } else {</a>
<a name="ln375">      goto error;</a>
<a name="ln376">    }</a>
<a name="ln377">  } else if (code != KE_MOUSEMOVE) {</a>
<a name="ln378">    if (strequal(action.data, &quot;press&quot;)) {</a>
<a name="ln379">      // pass</a>
<a name="ln380">    } else if (strequal(action.data, &quot;drag&quot;)) {</a>
<a name="ln381">      code += KE_LEFTDRAG - KE_LEFTMOUSE;</a>
<a name="ln382">    } else if (strequal(action.data, &quot;release&quot;)) {</a>
<a name="ln383">      code += KE_LEFTRELEASE - KE_LEFTMOUSE;</a>
<a name="ln384">    } else {</a>
<a name="ln385">      goto error;</a>
<a name="ln386">    }</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  int modmask = 0;</a>
<a name="ln390">  for (size_t i = 0; i &lt; modifier.size; i++) {</a>
<a name="ln391">    char byte = modifier.data[i];</a>
<a name="ln392">    if (byte == '-') {</a>
<a name="ln393">      continue;</a>
<a name="ln394">    }</a>
<a name="ln395">    int mod = name_to_mod_mask(byte);</a>
<a name="ln396">    VALIDATE((mod != 0), &quot;Invalid modifier: %c&quot;, byte, {</a>
<a name="ln397">      return;</a>
<a name="ln398">    });</a>
<a name="ln399">    modmask |= mod;</a>
<a name="ln400">  }</a>
<a name="ln401"> </a>
<a name="ln402">  input_enqueue_mouse(code, (uint8_t)modmask, (int)grid, (int)row, (int)col);</a>
<a name="ln403">  return;</a>
<a name="ln404"> </a>
<a name="ln405">error:</a>
<a name="ln406">  api_set_error(err, kErrorTypeValidation,</a>
<a name="ln407">                &quot;invalid button or action&quot;);</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">/// Replaces terminal codes and |keycodes| (&lt;CR&gt;, &lt;Esc&gt;, ...) in a string with</a>
<a name="ln411">/// the internal representation.</a>
<a name="ln412">///</a>
<a name="ln413">/// @param str        String to be converted.</a>
<a name="ln414">/// @param from_part  Legacy Vim parameter. Usually true.</a>
<a name="ln415">/// @param do_lt      Also translate &lt;lt&gt;. Ignored if `special` is false.</a>
<a name="ln416">/// @param special    Replace |keycodes|, e.g. &lt;CR&gt; becomes a &quot;\r&quot; char.</a>
<a name="ln417">/// @see replace_termcodes</a>
<a name="ln418">/// @see cpoptions</a>
<a name="ln419">String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt, Boolean special)</a>
<a name="ln420">  FUNC_API_SINCE(1)</a>
<a name="ln421">{</a>
<a name="ln422">  if (str.size == 0) {</a>
<a name="ln423">    // Empty string</a>
<a name="ln424">    return (String) { .data = NULL, .size = 0 };</a>
<a name="ln425">  }</a>
<a name="ln426"> </a>
<a name="ln427">  int flags = 0;</a>
<a name="ln428">  if (from_part) {</a>
<a name="ln429">    flags |= REPTERM_FROM_PART;</a>
<a name="ln430">  }</a>
<a name="ln431">  if (do_lt) {</a>
<a name="ln432">    flags |= REPTERM_DO_LT;</a>
<a name="ln433">  }</a>
<a name="ln434">  if (!special) {</a>
<a name="ln435">    flags |= REPTERM_NO_SPECIAL;</a>
<a name="ln436">  }</a>
<a name="ln437"> </a>
<a name="ln438">  char *ptr = NULL;</a>
<a name="ln439">  replace_termcodes(str.data, str.size, &amp;ptr, 0, flags, NULL, CPO_TO_CPO_FLAGS);</a>
<a name="ln440">  return cstr_as_string(ptr);</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/// Execute Lua code. Parameters (if any) are available as `...` inside the</a>
<a name="ln444">/// chunk. The chunk can return a value.</a>
<a name="ln445">///</a>
<a name="ln446">/// Only statements are executed. To evaluate an expression, prefix it</a>
<a name="ln447">/// with `return`: return my_function(...)</a>
<a name="ln448">///</a>
<a name="ln449">/// @param code       Lua code to execute</a>
<a name="ln450">/// @param args       Arguments to the code</a>
<a name="ln451">/// @param[out] err   Details of an error encountered while parsing</a>
<a name="ln452">///                   or executing the Lua code.</a>
<a name="ln453">///</a>
<a name="ln454">/// @return           Return value of Lua code if present or NIL.</a>
<a name="ln455">Object nvim_exec_lua(String code, Array args, Error *err)</a>
<a name="ln456">  FUNC_API_SINCE(7)</a>
<a name="ln457">  FUNC_API_REMOTE_ONLY</a>
<a name="ln458">{</a>
<a name="ln459">  return nlua_exec(code, args, err);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/// Notify the user with a message</a>
<a name="ln463">///</a>
<a name="ln464">/// Relays the call to vim.notify . By default forwards your message in the</a>
<a name="ln465">/// echo area but can be overridden to trigger desktop notifications.</a>
<a name="ln466">///</a>
<a name="ln467">/// @param msg        Message to display to the user</a>
<a name="ln468">/// @param log_level  The log level</a>
<a name="ln469">/// @param opts       Reserved for future use.</a>
<a name="ln470">/// @param[out] err   Error details, if any</a>
<a name="ln471">Object nvim_notify(String msg, Integer log_level, Dictionary opts, Error *err)</a>
<a name="ln472">  FUNC_API_SINCE(7)</a>
<a name="ln473">{</a>
<a name="ln474">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln475">  ADD_C(args, STRING_OBJ(msg));</a>
<a name="ln476">  ADD_C(args, INTEGER_OBJ(log_level));</a>
<a name="ln477">  ADD_C(args, DICTIONARY_OBJ(opts));</a>
<a name="ln478"> </a>
<a name="ln479">  return NLUA_EXEC_STATIC(&quot;return vim.notify(...)&quot;, args, err);</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/// Calculates the number of display cells occupied by `text`.</a>
<a name="ln483">/// Control characters including &lt;Tab&gt; count as one cell.</a>
<a name="ln484">///</a>
<a name="ln485">/// @param text       Some text</a>
<a name="ln486">/// @param[out] err   Error details, if any</a>
<a name="ln487">/// @return Number of cells</a>
<a name="ln488">Integer nvim_strwidth(String text, Error *err)</a>
<a name="ln489">  FUNC_API_SINCE(1)</a>
<a name="ln490">{</a>
<a name="ln491">  VALIDATE_S((text.size &lt;= INT_MAX), &quot;text length&quot;, &quot;(too long)&quot;, {</a>
<a name="ln492">    return 0;</a>
<a name="ln493">  });</a>
<a name="ln494"> </a>
<a name="ln495">  return (Integer)mb_string2cells(text.data);</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">/// Gets the paths contained in |runtime-search-path|.</a>
<a name="ln499">///</a>
<a name="ln500">/// @return List of paths</a>
<a name="ln501">ArrayOf(String) nvim_list_runtime_paths(Error *err)</a>
<a name="ln502">  FUNC_API_SINCE(1)</a>
<a name="ln503">{</a>
<a name="ln504">  return nvim_get_runtime_file(NULL_STRING, true, err);</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">Array nvim__runtime_inspect(void)</a>
<a name="ln508">{</a>
<a name="ln509">  return runtime_inspect();</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/// Find files in runtime directories</a>
<a name="ln513">///</a>
<a name="ln514">/// &quot;name&quot; can contain wildcards. For example</a>
<a name="ln515">/// nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all color</a>
<a name="ln516">/// scheme files. Always use forward slashes (/) in the search pattern for</a>
<a name="ln517">/// subdirectories regardless of platform.</a>
<a name="ln518">///</a>
<a name="ln519">/// It is not an error to not find any files. An empty array is returned then.</a>
<a name="ln520">///</a>
<a name="ln521">/// @param name pattern of files to search for</a>
<a name="ln522">/// @param all whether to return all matches or only the first</a>
<a name="ln523">/// @return list of absolute paths to the found files</a>
<a name="ln524">ArrayOf(String) nvim_get_runtime_file(String name, Boolean all, Error *err)</a>
<a name="ln525">  FUNC_API_SINCE(7)</a>
<a name="ln526">  FUNC_API_FAST</a>
<a name="ln527">{</a>
<a name="ln528">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln529"> </a>
<a name="ln530">  int flags = DIP_DIRFILE | (all ? DIP_ALL : 0);</a>
<a name="ln531"> </a>
<a name="ln532">  TRY_WRAP(err, {</a>
<a name="ln533">    do_in_runtimepath((name.size ? name.data : &quot;&quot;), flags, find_runtime_cb, &amp;rv);</a>
<a name="ln534">  });</a>
<a name="ln535">  return rv;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">static bool find_runtime_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln539">{</a>
<a name="ln540">  Array *rv = (Array *)cookie;</a>
<a name="ln541">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln542">    ADD(*rv, CSTR_TO_OBJ(fnames[i]));</a>
<a name="ln543">    if (!all) {</a>
<a name="ln544">      return true;</a>
<a name="ln545">    }</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  return num_fnames &gt; 0;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">String nvim__get_lib_dir(void)</a>
<a name="ln552">{</a>
<a name="ln553">  return cstr_as_string(get_lib_dir());</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/// Find files in runtime directories</a>
<a name="ln557">///</a>
<a name="ln558">/// @param pat pattern of files to search for</a>
<a name="ln559">/// @param all whether to return all matches or only the first</a>
<a name="ln560">/// @param opts is_lua: only search Lua subdirs</a>
<a name="ln561">/// @return list of absolute paths to the found files</a>
<a name="ln562">ArrayOf(String) nvim__get_runtime(Array pat, Boolean all, Dict(runtime) *opts, Error *err)</a>
<a name="ln563">  FUNC_API_SINCE(8)</a>
<a name="ln564">  FUNC_API_FAST</a>
<a name="ln565">{</a>
<a name="ln566">  VALIDATE((!opts-&gt;do_source || nlua_is_deferred_safe()), &quot;%s&quot;, &quot;'do_source' used in fast callback&quot;,</a>
<a name="ln567">           {});</a>
<a name="ln568">  if (ERROR_SET(err)) {</a>
<a name="ln569">    return (Array)ARRAY_DICT_INIT;</a>
<a name="ln570">  }</a>
<a name="ln571"> </a>
<a name="ln572">  ArrayOf(String) res = runtime_get_named(opts-&gt;is_lua, pat, all);</a>
<a name="ln573"> </a>
<a name="ln574">  if (opts-&gt;do_source) {</a>
<a name="ln575">    for (size_t i = 0; i &lt; res.size; i++) {</a>
<a name="ln576">      String name = res.items[i].data.string;</a>
<a name="ln577">      (void)do_source(name.data, false, DOSO_NONE, NULL);</a>
<a name="ln578">    }</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  return res;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">/// Changes the global working directory.</a>
<a name="ln585">///</a>
<a name="ln586">/// @param dir      Directory path</a>
<a name="ln587">/// @param[out] err Error details, if any</a>
<a name="ln588">void nvim_set_current_dir(String dir, Error *err)</a>
<a name="ln589">  FUNC_API_SINCE(1)</a>
<a name="ln590">{</a>
<a name="ln591">  VALIDATE_S((dir.size &lt; MAXPATHL), &quot;directory name&quot;, &quot;(too long)&quot;, {</a>
<a name="ln592">    return;</a>
<a name="ln593">  });</a>
<a name="ln594"> </a>
<a name="ln595">  char string[MAXPATHL];</a>
<a name="ln596">  memcpy(string, dir.data, dir.size);</a>
<a name="ln597">  string[dir.size] = NUL;</a>
<a name="ln598"> </a>
<a name="ln599">  try_start();</a>
<a name="ln600"> </a>
<a name="ln601">  if (!changedir_func(string, kCdScopeGlobal)) {</a>
<a name="ln602">    if (!try_end(err)) {</a>
<a name="ln603">      api_set_error(err, kErrorTypeException, &quot;Failed to change directory&quot;);</a>
<a name="ln604">    }</a>
<a name="ln605">    return;</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  try_end(err);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/// Gets the current line.</a>
<a name="ln612">///</a>
<a name="ln613">/// @param[out] err Error details, if any</a>
<a name="ln614">/// @return Current line string</a>
<a name="ln615">String nvim_get_current_line(Error *err)</a>
<a name="ln616">  FUNC_API_SINCE(1)</a>
<a name="ln617">{</a>
<a name="ln618">  return buffer_get_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">/// Sets the current line.</a>
<a name="ln622">///</a>
<a name="ln623">/// @param line     Line contents</a>
<a name="ln624">/// @param[out] err Error details, if any</a>
<a name="ln625">void nvim_set_current_line(String line, Error *err)</a>
<a name="ln626">  FUNC_API_SINCE(1)</a>
<a name="ln627">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln628">{</a>
<a name="ln629">  buffer_set_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, line, err);</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">/// Deletes the current line.</a>
<a name="ln633">///</a>
<a name="ln634">/// @param[out] err Error details, if any</a>
<a name="ln635">void nvim_del_current_line(Error *err)</a>
<a name="ln636">  FUNC_API_SINCE(1)</a>
<a name="ln637">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln638">{</a>
<a name="ln639">  buffer_del_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/// Gets a global (g:) variable.</a>
<a name="ln643">///</a>
<a name="ln644">/// @param name     Variable name</a>
<a name="ln645">/// @param[out] err Error details, if any</a>
<a name="ln646">/// @return Variable value</a>
<a name="ln647">Object nvim_get_var(String name, Error *err)</a>
<a name="ln648">  FUNC_API_SINCE(1)</a>
<a name="ln649">{</a>
<a name="ln650">  dictitem_T *di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln651">  if (di == NULL) {  // try to autoload script</a>
<a name="ln652">    bool found = script_autoload(name.data, name.size, false) &amp;&amp; !aborting();</a>
<a name="ln653">    VALIDATE(found, &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln654">      return (Object)OBJECT_INIT;</a>
<a name="ln655">    });</a>
<a name="ln656">    di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln657">  }</a>
<a name="ln658">  VALIDATE((di != NULL), &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln659">    return (Object)OBJECT_INIT;</a>
<a name="ln660">  });</a>
<a name="ln661">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln662">}</a>
<a name="ln663"> </a>
<a name="ln664">/// Sets a global (g:) variable.</a>
<a name="ln665">///</a>
<a name="ln666">/// @param name     Variable name</a>
<a name="ln667">/// @param value    Variable value</a>
<a name="ln668">/// @param[out] err Error details, if any</a>
<a name="ln669">void nvim_set_var(String name, Object value, Error *err)</a>
<a name="ln670">  FUNC_API_SINCE(1)</a>
<a name="ln671">{</a>
<a name="ln672">  dict_set_var(&amp;globvardict, name, value, false, false, err);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">/// Removes a global (g:) variable.</a>
<a name="ln676">///</a>
<a name="ln677">/// @param name     Variable name</a>
<a name="ln678">/// @param[out] err Error details, if any</a>
<a name="ln679">void nvim_del_var(String name, Error *err)</a>
<a name="ln680">  FUNC_API_SINCE(1)</a>
<a name="ln681">{</a>
<a name="ln682">  dict_set_var(&amp;globvardict, name, NIL, true, false, err);</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">/// Gets a v: variable.</a>
<a name="ln686">///</a>
<a name="ln687">/// @param name     Variable name</a>
<a name="ln688">/// @param[out] err Error details, if any</a>
<a name="ln689">/// @return         Variable value</a>
<a name="ln690">Object nvim_get_vvar(String name, Error *err)</a>
<a name="ln691">  FUNC_API_SINCE(1)</a>
<a name="ln692">{</a>
<a name="ln693">  return dict_get_value(&amp;vimvardict, name, err);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">/// Sets a v: variable, if it is not readonly.</a>
<a name="ln697">///</a>
<a name="ln698">/// @param name     Variable name</a>
<a name="ln699">/// @param value    Variable value</a>
<a name="ln700">/// @param[out] err Error details, if any</a>
<a name="ln701">void nvim_set_vvar(String name, Object value, Error *err)</a>
<a name="ln702">  FUNC_API_SINCE(6)</a>
<a name="ln703">{</a>
<a name="ln704">  dict_set_var(&amp;vimvardict, name, value, false, false, err);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">/// Echo a message.</a>
<a name="ln708">///</a>
<a name="ln709">/// @param chunks  A list of [text, hl_group] arrays, each representing a</a>
<a name="ln710">///                text chunk with specified highlight. `hl_group` element</a>
<a name="ln711">///                can be omitted for no highlight.</a>
<a name="ln712">/// @param history  if true, add to |message-history|.</a>
<a name="ln713">/// @param opts  Optional parameters.</a>
<a name="ln714">///          - verbose: Message was printed as a result of 'verbose' option</a>
<a name="ln715">///            if Nvim was invoked with -V3log_file, the message will be</a>
<a name="ln716">///            redirected to the log_file and suppressed from direct output.</a>
<a name="ln717">void nvim_echo(Array chunks, Boolean history, Dict(echo_opts) *opts, Error *err)</a>
<a name="ln718">  FUNC_API_SINCE(7)</a>
<a name="ln719">{</a>
<a name="ln720">  HlMessage hl_msg = parse_hl_msg(chunks, err);</a>
<a name="ln721">  if (ERROR_SET(err)) {</a>
<a name="ln722">    goto error;</a>
<a name="ln723">  }</a>
<a name="ln724"> </a>
<a name="ln725">  if (opts-&gt;verbose) {</a>
<a name="ln726">    verbose_enter();</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  msg_multiattr(hl_msg, history ? &quot;echomsg&quot; : &quot;echo&quot;, history);</a>
<a name="ln730"> </a>
<a name="ln731">  if (opts-&gt;verbose) {</a>
<a name="ln732">    verbose_leave();</a>
<a name="ln733">    verbose_stop();  // flush now</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  if (history) {</a>
<a name="ln737">    // history takes ownership</a>
<a name="ln738">    return;</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">error:</a>
<a name="ln742">  hl_msg_free(hl_msg);</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">/// Writes a message to the Vim output buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln746">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln747">///</a>
<a name="ln748">/// @param str Message</a>
<a name="ln749">void nvim_out_write(String str)</a>
<a name="ln750">  FUNC_API_SINCE(1)</a>
<a name="ln751">{</a>
<a name="ln752">  write_msg(str, false, false);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/// Writes a message to the Vim error buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln756">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln757">///</a>
<a name="ln758">/// @param str Message</a>
<a name="ln759">void nvim_err_write(String str)</a>
<a name="ln760">  FUNC_API_SINCE(1)</a>
<a name="ln761">{</a>
<a name="ln762">  write_msg(str, true, false);</a>
<a name="ln763">}</a>
<a name="ln764"> </a>
<a name="ln765">/// Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the buffer is</a>
<a name="ln766">/// flushed (and displayed).</a>
<a name="ln767">///</a>
<a name="ln768">/// @param str Message</a>
<a name="ln769">/// @see nvim_err_write()</a>
<a name="ln770">void nvim_err_writeln(String str)</a>
<a name="ln771">  FUNC_API_SINCE(1)</a>
<a name="ln772">{</a>
<a name="ln773">  write_msg(str, true, true);</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">/// Gets the current list of buffer handles</a>
<a name="ln777">///</a>
<a name="ln778">/// Includes unlisted (unloaded/deleted) buffers, like `:ls!`.</a>
<a name="ln779">/// Use |nvim_buf_is_loaded()| to check if a buffer is loaded.</a>
<a name="ln780">///</a>
<a name="ln781">/// @return List of buffer handles</a>
<a name="ln782">ArrayOf(Buffer) nvim_list_bufs(void)</a>
<a name="ln783">  FUNC_API_SINCE(1)</a>
<a name="ln784">{</a>
<a name="ln785">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln786"> </a>
<a name="ln787">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln788">    rv.size++;</a>
<a name="ln789">  }</a>
<a name="ln790"> </a>
<a name="ln791">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln792">  size_t i = 0;</a>
<a name="ln793"> </a>
<a name="ln794">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln795">    rv.items[i++] = BUFFER_OBJ(b-&gt;handle);</a>
<a name="ln796">  }</a>
<a name="ln797"> </a>
<a name="ln798">  return rv;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">/// Gets the current buffer.</a>
<a name="ln802">///</a>
<a name="ln803">/// @return Buffer handle</a>
<a name="ln804">Buffer nvim_get_current_buf(void)</a>
<a name="ln805">  FUNC_API_SINCE(1)</a>
<a name="ln806">{</a>
<a name="ln807">  return curbuf-&gt;handle;</a>
<a name="ln808">}</a>
<a name="ln809"> </a>
<a name="ln810">/// Sets the current buffer.</a>
<a name="ln811">///</a>
<a name="ln812">/// @param buffer   Buffer handle</a>
<a name="ln813">/// @param[out] err Error details, if any</a>
<a name="ln814">void nvim_set_current_buf(Buffer buffer, Error *err)</a>
<a name="ln815">  FUNC_API_SINCE(1)</a>
<a name="ln816">  FUNC_API_TEXTLOCK</a>
<a name="ln817">{</a>
<a name="ln818">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln819"> </a>
<a name="ln820">  if (!buf) {</a>
<a name="ln821">    return;</a>
<a name="ln822">  }</a>
<a name="ln823"> </a>
<a name="ln824">  try_start();</a>
<a name="ln825">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum, 0);</a>
<a name="ln826">  if (!try_end(err) &amp;&amp; result == FAIL) {</a>
<a name="ln827">    api_set_error(err,</a>
<a name="ln828">                  kErrorTypeException,</a>
<a name="ln829">                  &quot;Failed to switch to buffer %d&quot;,</a>
<a name="ln830">                  buffer);</a>
<a name="ln831">  }</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">/// Gets the current list of window handles.</a>
<a name="ln835">///</a>
<a name="ln836">/// @return List of window handles</a>
<a name="ln837">ArrayOf(Window) nvim_list_wins(void)</a>
<a name="ln838">  FUNC_API_SINCE(1)</a>
<a name="ln839">{</a>
<a name="ln840">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln841"> </a>
<a name="ln842">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln843">    rv.size++;</a>
<a name="ln844">  }</a>
<a name="ln845"> </a>
<a name="ln846">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln847">  size_t i = 0;</a>
<a name="ln848"> </a>
<a name="ln849">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln850">    rv.items[i++] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln851">  }</a>
<a name="ln852"> </a>
<a name="ln853">  return rv;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">/// Gets the current window.</a>
<a name="ln857">///</a>
<a name="ln858">/// @return Window handle</a>
<a name="ln859">Window nvim_get_current_win(void)</a>
<a name="ln860">  FUNC_API_SINCE(1)</a>
<a name="ln861">{</a>
<a name="ln862">  return curwin-&gt;handle;</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">/// Sets the current window.</a>
<a name="ln866">///</a>
<a name="ln867">/// @param window Window handle</a>
<a name="ln868">/// @param[out] err Error details, if any</a>
<a name="ln869">void nvim_set_current_win(Window window, Error *err)</a>
<a name="ln870">  FUNC_API_SINCE(1)</a>
<a name="ln871">  FUNC_API_TEXTLOCK</a>
<a name="ln872">{</a>
<a name="ln873">  win_T *win = find_window_by_handle(window, err);</a>
<a name="ln874"> </a>
<a name="ln875">  if (!win) {</a>
<a name="ln876">    return;</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  try_start();</a>
<a name="ln880">  goto_tabpage_win(win_find_tabpage(win), win);</a>
<a name="ln881">  if (!try_end(err) &amp;&amp; win != curwin) {</a>
<a name="ln882">    api_set_error(err,</a>
<a name="ln883">                  kErrorTypeException,</a>
<a name="ln884">                  &quot;Failed to switch to window %d&quot;,</a>
<a name="ln885">                  window);</a>
<a name="ln886">  }</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">/// Creates a new, empty, unnamed buffer.</a>
<a name="ln890">///</a>
<a name="ln891">/// @param listed Sets 'buflisted'</a>
<a name="ln892">/// @param scratch Creates a &quot;throwaway&quot; |scratch-buffer| for temporary work</a>
<a name="ln893">///                (always 'nomodified'). Also sets 'nomodeline' on the buffer.</a>
<a name="ln894">/// @param[out] err Error details, if any</a>
<a name="ln895">/// @return Buffer handle, or 0 on error</a>
<a name="ln896">///</a>
<a name="ln897">/// @see buf_open_scratch</a>
<a name="ln898">Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err)</a>
<a name="ln899">  FUNC_API_SINCE(6)</a>
<a name="ln900">{</a>
<a name="ln901">  try_start();</a>
<a name="ln902">  buf_T *buf = buflist_new(NULL, NULL, (linenr_T)0,</a>
<a name="ln903">                           BLN_NOOPT | BLN_NEW | (listed ? BLN_LISTED : 0));</a>
<a name="ln904">  try_end(err);</a>
<a name="ln905">  if (buf == NULL) {</a>
<a name="ln906">    goto fail;</a>
<a name="ln907">  }</a>
<a name="ln908"> </a>
<a name="ln909">  // Open the memline for the buffer. This will avoid spurious autocmds when</a>
<a name="ln910">  // a later nvim_buf_set_lines call would have needed to &quot;open&quot; the buffer.</a>
<a name="ln911">  try_start();</a>
<a name="ln912">  block_autocmds();</a>
<a name="ln913">  int status = ml_open(buf);</a>
<a name="ln914">  unblock_autocmds();</a>
<a name="ln915">  try_end(err);</a>
<a name="ln916">  if (status == FAIL) {</a>
<a name="ln917">    goto fail;</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  // Only strictly needed for scratch, but could just as well be consistent</a>
<a name="ln921">  // and do this now. buffer is created NOW, not when it latter first happen</a>
<a name="ln922">  // to reach a window or aucmd_prepbuf() ..</a>
<a name="ln923">  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln924"> </a>
<a name="ln925">  if (scratch) {</a>
<a name="ln926">    set_string_option_direct_in_buf(buf, &quot;bufhidden&quot;, -1, &quot;hide&quot;, OPT_LOCAL, 0);</a>
<a name="ln927">    set_string_option_direct_in_buf(buf, &quot;buftype&quot;, -1, &quot;nofile&quot;, OPT_LOCAL, 0);</a>
<a name="ln928">    assert(buf-&gt;b_ml.ml_mfp-&gt;mf_fd &lt; 0);  // ml_open() should not have opened swapfile already</a>
<a name="ln929">    buf-&gt;b_p_swf = false;</a>
<a name="ln930">    buf-&gt;b_p_ml = false;</a>
<a name="ln931">  }</a>
<a name="ln932">  return buf-&gt;b_fnum;</a>
<a name="ln933"> </a>
<a name="ln934">fail:</a>
<a name="ln935">  if (!ERROR_SET(err)) {</a>
<a name="ln936">    api_set_error(err, kErrorTypeException, &quot;Failed to create buffer&quot;);</a>
<a name="ln937">  }</a>
<a name="ln938">  return 0;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">/// Open a terminal instance in a buffer</a>
<a name="ln942">///</a>
<a name="ln943">/// By default (and currently the only option) the terminal will not be</a>
<a name="ln944">/// connected to an external process. Instead, input send on the channel</a>
<a name="ln945">/// will be echoed directly by the terminal. This is useful to display</a>
<a name="ln946">/// ANSI terminal sequences returned as part of a rpc message, or similar.</a>
<a name="ln947">///</a>
<a name="ln948">/// Note: to directly initiate the terminal using the right size, display the</a>
<a name="ln949">/// buffer in a configured window before calling this. For instance, for a</a>
<a name="ln950">/// floating display, first create an empty buffer using |nvim_create_buf()|,</a>
<a name="ln951">/// then display it using |nvim_open_win()|, and then  call this function.</a>
<a name="ln952">/// Then |nvim_chan_send()| can be called immediately to process sequences</a>
<a name="ln953">/// in a virtual terminal having the intended size.</a>
<a name="ln954">///</a>
<a name="ln955">/// @param buffer the buffer to use (expected to be empty)</a>
<a name="ln956">/// @param opts   Optional parameters.</a>
<a name="ln957">///          - on_input: Lua callback for input sent, i e keypresses in terminal</a>
<a name="ln958">///            mode. Note: keypresses are sent raw as they would be to the pty</a>
<a name="ln959">///            master end. For instance, a carriage return is sent</a>
<a name="ln960">///            as a &quot;\r&quot;, not as a &quot;\n&quot;. |textlock| applies. It is possible</a>
<a name="ln961">///            to call |nvim_chan_send()| directly in the callback however.</a>
<a name="ln962">///                 [&quot;input&quot;, term, bufnr, data]</a>
<a name="ln963">/// @param[out] err Error details, if any</a>
<a name="ln964">/// @return Channel id, or 0 on error</a>
<a name="ln965">Integer nvim_open_term(Buffer buffer, DictionaryOf(LuaRef) opts, Error *err)</a>
<a name="ln966">  FUNC_API_SINCE(7)</a>
<a name="ln967">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln968">{</a>
<a name="ln969">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln970">  if (!buf) {</a>
<a name="ln971">    return 0;</a>
<a name="ln972">  }</a>
<a name="ln973"> </a>
<a name="ln974">  if (cmdwin_type != 0 &amp;&amp; buf == curbuf) {</a>
<a name="ln975">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, e_cmdwin);</a>
<a name="ln976">    return 0;</a>
<a name="ln977">  }</a>
<a name="ln978"> </a>
<a name="ln979">  LuaRef cb = LUA_NOREF;</a>
<a name="ln980">  for (size_t i = 0; i &lt; opts.size; i++) {</a>
<a name="ln981">    String k = opts.items[i].key;</a>
<a name="ln982">    Object *v = &amp;opts.items[i].value;</a>
<a name="ln983">    if (strequal(&quot;on_input&quot;, k.data)) {</a>
<a name="ln984">      VALIDATE_T(&quot;on_input&quot;, kObjectTypeLuaRef, v-&gt;type, {</a>
<a name="ln985">        return 0;</a>
<a name="ln986">      });</a>
<a name="ln987">      cb = v-&gt;data.luaref;</a>
<a name="ln988">      v-&gt;data.luaref = LUA_NOREF;</a>
<a name="ln989">      break;</a>
<a name="ln990">    } else {</a>
<a name="ln991">      VALIDATE_S(false, &quot;'opts' key&quot;, k.data, {});</a>
<a name="ln992">    }</a>
<a name="ln993">  }</a>
<a name="ln994"> </a>
<a name="ln995">  TerminalOptions topts;</a>
<a name="ln996">  Channel *chan = channel_alloc(kChannelStreamInternal);</a>
<a name="ln997">  chan-&gt;stream.internal.cb = cb;</a>
<a name="ln998">  chan-&gt;stream.internal.closed = false;</a>
<a name="ln999">  topts.data = chan;</a>
<a name="ln1000">  // NB: overridden in terminal_check_size if a window is already</a>
<a name="ln1001">  // displaying the buffer</a>
<a name="ln1002">  topts.width = (uint16_t)MAX(curwin-&gt;w_width_inner - win_col_off(curwin), 0);</a>
<a name="ln1003">  topts.height = (uint16_t)curwin-&gt;w_height_inner;</a>
<a name="ln1004">  topts.write_cb = term_write;</a>
<a name="ln1005">  topts.resize_cb = term_resize;</a>
<a name="ln1006">  topts.close_cb = term_close;</a>
<a name="ln1007">  Terminal *term = terminal_open(buf, topts);</a>
<a name="ln1008">  terminal_check_size(term);</a>
<a name="ln1009">  chan-&gt;term = term;</a>
<a name="ln1010">  return (Integer)chan-&gt;id;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">static void term_write(char *buf, size_t size, void *data)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln1014">{</a>
<a name="ln1015">  Channel *chan = data;</a>
<a name="ln1016">  LuaRef cb = chan-&gt;stream.internal.cb;</a>
<a name="ln1017">  if (cb == LUA_NOREF) {</a>
<a name="ln1018">    return;</a>
<a name="ln1019">  }</a>
<a name="ln1020">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln1021">  ADD_C(args, INTEGER_OBJ((Integer)chan-&gt;id));</a>
<a name="ln1022">  ADD_C(args, BUFFER_OBJ(terminal_buf(chan-&gt;term)));</a>
<a name="ln1023">  ADD_C(args, STRING_OBJ(((String){ .data = buf, .size = size })));</a>
<a name="ln1024">  textlock++;</a>
<a name="ln1025">  nlua_call_ref(cb, &quot;input&quot;, args, false, NULL);</a>
<a name="ln1026">  textlock--;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">static void term_resize(uint16_t width, uint16_t height, void *data)</a>
<a name="ln1030">{</a>
<a name="ln1031">  // TODO(bfredl): Lua callback</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">static void term_close(void *data)</a>
<a name="ln1035">{</a>
<a name="ln1036">  Channel *chan = data;</a>
<a name="ln1037">  terminal_destroy(&amp;chan-&gt;term);</a>
<a name="ln1038">  api_free_luaref(chan-&gt;stream.internal.cb);</a>
<a name="ln1039">  chan-&gt;stream.internal.cb = LUA_NOREF;</a>
<a name="ln1040">  channel_decref(chan);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">/// Send data to channel `id`. For a job, it writes it to the</a>
<a name="ln1044">/// stdin of the process. For the stdio channel |channel-stdio|,</a>
<a name="ln1045">/// it writes to Nvim's stdout.  For an internal terminal instance</a>
<a name="ln1046">/// (|nvim_open_term()|) it writes directly to terminal output.</a>
<a name="ln1047">/// See |channel-bytes| for more information.</a>
<a name="ln1048">///</a>
<a name="ln1049">/// This function writes raw data, not RPC messages.  If the channel</a>
<a name="ln1050">/// was created with `rpc=true` then the channel expects RPC</a>
<a name="ln1051">/// messages, use |vim.rpcnotify()| and |vim.rpcrequest()| instead.</a>
<a name="ln1052">///</a>
<a name="ln1053">/// @param chan id of the channel</a>
<a name="ln1054">/// @param data data to write. 8-bit clean: can contain NUL bytes.</a>
<a name="ln1055">/// @param[out] err Error details, if any</a>
<a name="ln1056">void nvim_chan_send(Integer chan, String data, Error *err)</a>
<a name="ln1057">  FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY FUNC_API_LUA_ONLY</a>
<a name="ln1058">{</a>
<a name="ln1059">  const char *error = NULL;</a>
<a name="ln1060">  if (!data.size) {</a>
<a name="ln1061">    return;</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  channel_send((uint64_t)chan, data.data, data.size,</a>
<a name="ln1065">               false, &amp;error);</a>
<a name="ln1066">  VALIDATE(!error, &quot;%s&quot;, error, {});</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">/// Gets the current list of tabpage handles.</a>
<a name="ln1070">///</a>
<a name="ln1071">/// @return List of tabpage handles</a>
<a name="ln1072">ArrayOf(Tabpage) nvim_list_tabpages(void)</a>
<a name="ln1073">  FUNC_API_SINCE(1)</a>
<a name="ln1074">{</a>
<a name="ln1075">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln1076"> </a>
<a name="ln1077">  FOR_ALL_TABS(tp) {</a>
<a name="ln1078">    rv.size++;</a>
<a name="ln1079">  }</a>
<a name="ln1080"> </a>
<a name="ln1081">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln1082">  size_t i = 0;</a>
<a name="ln1083"> </a>
<a name="ln1084">  FOR_ALL_TABS(tp) {</a>
<a name="ln1085">    rv.items[i++] = TABPAGE_OBJ(tp-&gt;handle);</a>
<a name="ln1086">  }</a>
<a name="ln1087"> </a>
<a name="ln1088">  return rv;</a>
<a name="ln1089">}</a>
<a name="ln1090"> </a>
<a name="ln1091">/// Gets the current tabpage.</a>
<a name="ln1092">///</a>
<a name="ln1093">/// @return Tabpage handle</a>
<a name="ln1094">Tabpage nvim_get_current_tabpage(void)</a>
<a name="ln1095">  FUNC_API_SINCE(1)</a>
<a name="ln1096">{</a>
<a name="ln1097">  return curtab-&gt;handle;</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">/// Sets the current tabpage.</a>
<a name="ln1101">///</a>
<a name="ln1102">/// @param tabpage  Tabpage handle</a>
<a name="ln1103">/// @param[out] err Error details, if any</a>
<a name="ln1104">void nvim_set_current_tabpage(Tabpage tabpage, Error *err)</a>
<a name="ln1105">  FUNC_API_SINCE(1)</a>
<a name="ln1106">  FUNC_API_TEXTLOCK</a>
<a name="ln1107">{</a>
<a name="ln1108">  tabpage_T *tp = find_tab_by_handle(tabpage, err);</a>
<a name="ln1109"> </a>
<a name="ln1110">  if (!tp) {</a>
<a name="ln1111">    return;</a>
<a name="ln1112">  }</a>
<a name="ln1113"> </a>
<a name="ln1114">  try_start();</a>
<a name="ln1115">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln1116">  if (!try_end(err) &amp;&amp; tp != curtab) {</a>
<a name="ln1117">    api_set_error(err,</a>
<a name="ln1118">                  kErrorTypeException,</a>
<a name="ln1119">                  &quot;Failed to switch to tabpage %d&quot;,</a>
<a name="ln1120">                  tabpage);</a>
<a name="ln1121">  }</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">/// Pastes at cursor, in any mode.</a>
<a name="ln1125">///</a>
<a name="ln1126">/// Invokes the `vim.paste` handler, which handles each mode appropriately.</a>
<a name="ln1127">/// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF (&quot;\n&quot;).</a>
<a name="ln1128">///</a>
<a name="ln1129">/// Errors ('nomodifiable', `vim.paste()` failure, ) are reflected in `err`</a>
<a name="ln1130">/// but do not affect the return value (which is strictly decided by</a>
<a name="ln1131">/// `vim.paste()`).  On error, subsequent calls are ignored (&quot;drained&quot;) until</a>
<a name="ln1132">/// the next paste is initiated (phase 1 or -1).</a>
<a name="ln1133">///</a>
<a name="ln1134">/// @param data  Multiline input. May be binary (containing NUL bytes).</a>
<a name="ln1135">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln1136">/// @param phase  -1: paste in a single call (i.e. without streaming).</a>
<a name="ln1137">///               To &quot;stream&quot; a paste, call `nvim_paste` sequentially with</a>
<a name="ln1138">///               these `phase` values:</a>
<a name="ln1139">///                 - 1: starts the paste (exactly once)</a>
<a name="ln1140">///                 - 2: continues the paste (zero or more times)</a>
<a name="ln1141">///                 - 3: ends the paste (exactly once)</a>
<a name="ln1142">/// @param[out] err Error details, if any</a>
<a name="ln1143">/// @return</a>
<a name="ln1144">///     - true: Client may continue pasting.</a>
<a name="ln1145">///     - false: Client must cancel the paste.</a>
<a name="ln1146">Boolean nvim_paste(String data, Boolean crlf, Integer phase, Error *err)</a>
<a name="ln1147">  FUNC_API_SINCE(6)</a>
<a name="ln1148">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1149">{</a>
<a name="ln1150">  static bool draining = false;</a>
<a name="ln1151">  bool cancel = false;</a>
<a name="ln1152"> </a>
<a name="ln1153">  VALIDATE_INT((phase &gt;= -1 &amp;&amp; phase &lt;= 3), &quot;phase&quot;, phase, {</a>
<a name="ln1154">    return false;</a>
<a name="ln1155">  });</a>
<a name="ln1156">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln1157">  Object rv = OBJECT_INIT;</a>
<a name="ln1158">  if (phase == -1 || phase == 1) {  // Start of paste-stream.</a>
<a name="ln1159">    draining = false;</a>
<a name="ln1160">  } else if (draining) {</a>
<a name="ln1161">    // Skip remaining chunks.  Report error only once per &quot;stream&quot;.</a>
<a name="ln1162">    goto theend;</a>
<a name="ln1163">  }</a>
<a name="ln1164">  Array lines = string_to_array(data, crlf);</a>
<a name="ln1165">  ADD(args, ARRAY_OBJ(lines));</a>
<a name="ln1166">  ADD(args, INTEGER_OBJ(phase));</a>
<a name="ln1167">  rv = nvim_exec_lua(STATIC_CSTR_AS_STRING(&quot;return vim.paste(...)&quot;), args,</a>
<a name="ln1168">                     err);</a>
<a name="ln1169">  if (ERROR_SET(err)) {</a>
<a name="ln1170">    draining = true;</a>
<a name="ln1171">    goto theend;</a>
<a name="ln1172">  }</a>
<a name="ln1173">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 1)) {</a>
<a name="ln1174">    ResetRedobuff();</a>
<a name="ln1175">    AppendCharToRedobuff('a');  // Dot-repeat.</a>
<a name="ln1176">  }</a>
<a name="ln1177">  // vim.paste() decides if client should cancel.  Errors do NOT cancel: we</a>
<a name="ln1178">  // want to drain remaining chunks (rather than divert them to main input).</a>
<a name="ln1179">  cancel = (rv.type == kObjectTypeBoolean &amp;&amp; !rv.data.boolean);</a>
<a name="ln1180">  if (!cancel &amp;&amp; !(State &amp; MODE_CMDLINE)) {  // Dot-repeat.</a>
<a name="ln1181">    for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1182">      String s = lines.items[i].data.string;</a>
<a name="ln1183">      assert(s.size &lt;= INT_MAX);</a>
<a name="ln1184">      AppendToRedobuffLit(s.data, (int)s.size);</a>
<a name="ln1185">      // readfile()-style: &quot;\n&quot; is indicated by presence of N+1 item.</a>
<a name="ln1186">      if (i + 1 &lt; lines.size) {</a>
<a name="ln1187">        AppendCharToRedobuff(NL);</a>
<a name="ln1188">      }</a>
<a name="ln1189">    }</a>
<a name="ln1190">  }</a>
<a name="ln1191">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 3)) {</a>
<a name="ln1192">    AppendCharToRedobuff(ESC);  // Dot-repeat.</a>
<a name="ln1193">  }</a>
<a name="ln1194">theend:</a>
<a name="ln1195">  api_free_object(rv);</a>
<a name="ln1196">  api_free_array(args);</a>
<a name="ln1197">  if (cancel || phase == -1 || phase == 3) {  // End of paste-stream.</a>
<a name="ln1198">    draining = false;</a>
<a name="ln1199">  }</a>
<a name="ln1200"> </a>
<a name="ln1201">  return !cancel;</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/// Puts text at cursor, in any mode.</a>
<a name="ln1205">///</a>
<a name="ln1206">/// Compare |:put| and |p| which are always linewise.</a>
<a name="ln1207">///</a>
<a name="ln1208">/// @param lines  |readfile()|-style list of lines. |channel-lines|</a>
<a name="ln1209">/// @param type  Edit behavior: any |getregtype()| result, or:</a>
<a name="ln1210">///              - &quot;b&quot; |blockwise-visual| mode (may include width, e.g. &quot;b3&quot;)</a>
<a name="ln1211">///              - &quot;c&quot; |charwise| mode</a>
<a name="ln1212">///              - &quot;l&quot; |linewise| mode</a>
<a name="ln1213">///              - &quot;&quot;  guess by contents, see |setreg()|</a>
<a name="ln1214">/// @param after  If true insert after cursor (like |p|), or before (like |P|).</a>
<a name="ln1215">/// @param follow  If true place cursor at end of inserted text.</a>
<a name="ln1216">/// @param[out] err Error details, if any</a>
<a name="ln1217">void nvim_put(ArrayOf(String) lines, String type, Boolean after, Boolean follow, Error *err)</a>
<a name="ln1218">  FUNC_API_SINCE(6)</a>
<a name="ln1219">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1220">{</a>
<a name="ln1221">  yankreg_T *reg = xcalloc(1, sizeof(yankreg_T));</a>
<a name="ln1222">  VALIDATE_S((prepare_yankreg_from_object(reg, type, lines.size)), &quot;type&quot;, type.data, {</a>
<a name="ln1223">    goto cleanup;</a>
<a name="ln1224">  });</a>
<a name="ln1225">  if (lines.size == 0) {</a>
<a name="ln1226">    goto cleanup;  // Nothing to do.</a>
<a name="ln1227">  }</a>
<a name="ln1228"> </a>
<a name="ln1229">  for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1230">    VALIDATE_T(&quot;line&quot;, kObjectTypeString, lines.items[i].type, {</a>
<a name="ln1231">      goto cleanup;</a>
<a name="ln1232">    });</a>
<a name="ln1233">    String line = lines.items[i].data.string;</a>
<a name="ln1234">    reg-&gt;y_array[i] = xmemdupz(line.data, line.size);</a>
<a name="ln1235">    memchrsub(reg-&gt;y_array[i], NUL, NL, line.size);</a>
<a name="ln1236">  }</a>
<a name="ln1237"> </a>
<a name="ln1238">  finish_yankreg_from_object(reg, false);</a>
<a name="ln1239"> </a>
<a name="ln1240">  TRY_WRAP(err, {</a>
<a name="ln1241">    bool VIsual_was_active = VIsual_active;</a>
<a name="ln1242">    msg_silent++;  // Avoid &quot;N more lines&quot; message.</a>
<a name="ln1243">    do_put(0, reg, after ? FORWARD : BACKWARD, 1, follow ? PUT_CURSEND : 0);</a>
<a name="ln1244">    msg_silent--;</a>
<a name="ln1245">    VIsual_active = VIsual_was_active;</a>
<a name="ln1246">  });</a>
<a name="ln1247"> </a>
<a name="ln1248">cleanup:</a>
<a name="ln1249">  free_register(reg);</a>
<a name="ln1250">  xfree(reg);</a>
<a name="ln1251">}</a>
<a name="ln1252"> </a>
<a name="ln1253">/// Subscribes to event broadcasts.</a>
<a name="ln1254">///</a>
<a name="ln1255">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1256">/// @param event      Event type string</a>
<a name="ln1257">void nvim_subscribe(uint64_t channel_id, String event)</a>
<a name="ln1258">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1259">{</a>
<a name="ln1260">  size_t length = (event.size &lt; METHOD_MAXLEN ? event.size : METHOD_MAXLEN);</a>
<a name="ln1261">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1262">  memcpy(e, event.data, length);</a>
<a name="ln1263">  e[length] = NUL;</a>
<a name="ln1264">  rpc_subscribe(channel_id, e);</a>
<a name="ln1265">}</a>
<a name="ln1266"> </a>
<a name="ln1267">/// Unsubscribes to event broadcasts.</a>
<a name="ln1268">///</a>
<a name="ln1269">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1270">/// @param event      Event type string</a>
<a name="ln1271">void nvim_unsubscribe(uint64_t channel_id, String event)</a>
<a name="ln1272">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1273">{</a>
<a name="ln1274">  size_t length = (event.size &lt; METHOD_MAXLEN ?</a>
<a name="ln1275">                   event.size :</a>
<a name="ln1276">                   METHOD_MAXLEN);</a>
<a name="ln1277">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1278">  memcpy(e, event.data, length);</a>
<a name="ln1279">  e[length] = NUL;</a>
<a name="ln1280">  rpc_unsubscribe(channel_id, e);</a>
<a name="ln1281">}</a>
<a name="ln1282"> </a>
<a name="ln1283">/// Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or</a>
<a name="ln1284">/// &quot;#rrggbb&quot; hexadecimal string.</a>
<a name="ln1285">///</a>
<a name="ln1286">/// Example:</a>
<a name="ln1287">///</a>
<a name="ln1288">/// ```vim</a>
<a name="ln1289">/// :echo nvim_get_color_by_name(&quot;Pink&quot;)</a>
<a name="ln1290">/// :echo nvim_get_color_by_name(&quot;#cbcbcb&quot;)</a>
<a name="ln1291">/// ```</a>
<a name="ln1292">///</a>
<a name="ln1293">/// @param name Color name or &quot;#rrggbb&quot; string</a>
<a name="ln1294">/// @return 24-bit RGB value, or -1 for invalid argument.</a>
<a name="ln1295">Integer nvim_get_color_by_name(String name)</a>
<a name="ln1296">  FUNC_API_SINCE(1)</a>
<a name="ln1297">{</a>
<a name="ln1298">  int dummy;</a>
<a name="ln1299">  return name_to_color(name.data, &amp;dummy);</a>
<a name="ln1300">}</a>
<a name="ln1301"> </a>
<a name="ln1302">/// Returns a map of color names and RGB values.</a>
<a name="ln1303">///</a>
<a name="ln1304">/// Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB color values</a>
<a name="ln1305">/// (e.g. 65535).</a>
<a name="ln1306">///</a>
<a name="ln1307">/// @return Map of color names and RGB values.</a>
<a name="ln1308">Dictionary nvim_get_color_map(void)</a>
<a name="ln1309">  FUNC_API_SINCE(1)</a>
<a name="ln1310">{</a>
<a name="ln1311">  Dictionary colors = ARRAY_DICT_INIT;</a>
<a name="ln1312"> </a>
<a name="ln1313">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln1314">    PUT(colors, color_name_table[i].name,</a>
<a name="ln1315">        INTEGER_OBJ(color_name_table[i].color));</a>
<a name="ln1316">  }</a>
<a name="ln1317">  return colors;</a>
<a name="ln1318">}</a>
<a name="ln1319"> </a>
<a name="ln1320">/// Gets a map of the current editor state.</a>
<a name="ln1321">///</a>
<a name="ln1322">/// @param opts  Optional parameters.</a>
<a name="ln1323">///               - types:  List of |context-types| (&quot;regs&quot;, &quot;jumps&quot;, &quot;bufs&quot;,</a>
<a name="ln1324">///                 &quot;gvars&quot;, ) to gather, or empty for &quot;all&quot;.</a>
<a name="ln1325">/// @param[out]  err  Error details, if any</a>
<a name="ln1326">///</a>
<a name="ln1327">/// @return map of global |context|.</a>
<a name="ln1328">Dictionary nvim_get_context(Dict(context) *opts, Error *err)</a>
<a name="ln1329">  FUNC_API_SINCE(6)</a>
<a name="ln1330">{</a>
<a name="ln1331">  Array types = ARRAY_DICT_INIT;</a>
<a name="ln1332">  if (HAS_KEY(opts, context, types)) {</a>
<a name="ln1333">    types = opts-&gt;types;</a>
<a name="ln1334">  }</a>
<a name="ln1335"> </a>
<a name="ln1336">  int int_types = types.size &gt; 0 ? 0 : kCtxAll;</a>
<a name="ln1337">  if (types.size &gt; 0) {</a>
<a name="ln1338">    for (size_t i = 0; i &lt; types.size; i++) {</a>
<a name="ln1339">      if (types.items[i].type == kObjectTypeString) {</a>
<a name="ln1340">        const char *const s = types.items[i].data.string.data;</a>
<a name="ln1341">        if (strequal(s, &quot;regs&quot;)) {</a>
<a name="ln1342">          int_types |= kCtxRegs;</a>
<a name="ln1343">        } else if (strequal(s, &quot;jumps&quot;)) {</a>
<a name="ln1344">          int_types |= kCtxJumps;</a>
<a name="ln1345">        } else if (strequal(s, &quot;bufs&quot;)) {</a>
<a name="ln1346">          int_types |= kCtxBufs;</a>
<a name="ln1347">        } else if (strequal(s, &quot;gvars&quot;)) {</a>
<a name="ln1348">          int_types |= kCtxGVars;</a>
<a name="ln1349">        } else if (strequal(s, &quot;sfuncs&quot;)) {</a>
<a name="ln1350">          int_types |= kCtxSFuncs;</a>
<a name="ln1351">        } else if (strequal(s, &quot;funcs&quot;)) {</a>
<a name="ln1352">          int_types |= kCtxFuncs;</a>
<a name="ln1353">        } else {</a>
<a name="ln1354">          VALIDATE_S(false, &quot;type&quot;, s, {</a>
<a name="ln1355">            return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1356">          });</a>
<a name="ln1357">        }</a>
<a name="ln1358">      }</a>
<a name="ln1359">    }</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1363">  ctx_save(&amp;ctx, int_types);</a>
<a name="ln1364">  Dictionary dict = ctx_to_dict(&amp;ctx);</a>
<a name="ln1365">  ctx_free(&amp;ctx);</a>
<a name="ln1366">  return dict;</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">/// Sets the current editor state from the given |context| map.</a>
<a name="ln1370">///</a>
<a name="ln1371">/// @param  dict  |Context| map.</a>
<a name="ln1372">Object nvim_load_context(Dictionary dict)</a>
<a name="ln1373">  FUNC_API_SINCE(6)</a>
<a name="ln1374">{</a>
<a name="ln1375">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1376"> </a>
<a name="ln1377">  int save_did_emsg = did_emsg;</a>
<a name="ln1378">  did_emsg = false;</a>
<a name="ln1379"> </a>
<a name="ln1380">  ctx_from_dict(dict, &amp;ctx);</a>
<a name="ln1381">  if (!did_emsg) {</a>
<a name="ln1382">    ctx_restore(&amp;ctx, kCtxAll);</a>
<a name="ln1383">  }</a>
<a name="ln1384"> </a>
<a name="ln1385">  ctx_free(&amp;ctx);</a>
<a name="ln1386"> </a>
<a name="ln1387">  did_emsg = save_did_emsg;</a>
<a name="ln1388">  return (Object)OBJECT_INIT;</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">/// Gets the current mode. |mode()|</a>
<a name="ln1392">/// &quot;blocking&quot; is true if Nvim is waiting for input.</a>
<a name="ln1393">///</a>
<a name="ln1394">/// @returns Dictionary { &quot;mode&quot;: String, &quot;blocking&quot;: Boolean }</a>
<a name="ln1395">Dictionary nvim_get_mode(void)</a>
<a name="ln1396">  FUNC_API_SINCE(2) FUNC_API_FAST</a>
<a name="ln1397">{</a>
<a name="ln1398">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1399">  char modestr[MODE_MAX_LENGTH];</a>
<a name="ln1400">  get_mode(modestr);</a>
<a name="ln1401">  bool blocked = input_blocking();</a>
<a name="ln1402"> </a>
<a name="ln1403">  PUT(rv, &quot;mode&quot;, CSTR_TO_OBJ(modestr));</a>
<a name="ln1404">  PUT(rv, &quot;blocking&quot;, BOOLEAN_OBJ(blocked));</a>
<a name="ln1405"> </a>
<a name="ln1406">  return rv;</a>
<a name="ln1407">}</a>
<a name="ln1408"> </a>
<a name="ln1409">/// Gets a list of global (non-buffer-local) |mapping| definitions.</a>
<a name="ln1410">///</a>
<a name="ln1411">/// @param  mode       Mode short-name (&quot;n&quot;, &quot;i&quot;, &quot;v&quot;, ...)</a>
<a name="ln1412">/// @returns Array of |maparg()|-like dictionaries describing mappings.</a>
<a name="ln1413">///          The &quot;buffer&quot; key is always zero.</a>
<a name="ln1414">ArrayOf(Dictionary) nvim_get_keymap(String mode)</a>
<a name="ln1415">  FUNC_API_SINCE(3)</a>
<a name="ln1416">{</a>
<a name="ln1417">  return keymap_array(mode, NULL);</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">/// Sets a global |mapping| for the given mode.</a>
<a name="ln1421">///</a>
<a name="ln1422">/// To set a buffer-local mapping, use |nvim_buf_set_keymap()|.</a>
<a name="ln1423">///</a>
<a name="ln1424">/// Unlike |:map|, leading/trailing whitespace is accepted as part of the {lhs} or {rhs}.</a>
<a name="ln1425">/// Empty {rhs} is |&lt;Nop&gt;|. |keycodes| are replaced as usual.</a>
<a name="ln1426">///</a>
<a name="ln1427">/// Example:</a>
<a name="ln1428">///</a>
<a name="ln1429">/// ```vim</a>
<a name="ln1430">/// call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</a>
<a name="ln1431">/// ```</a>
<a name="ln1432">///</a>
<a name="ln1433">/// is equivalent to:</a>
<a name="ln1434">///</a>
<a name="ln1435">/// ```vim</a>
<a name="ln1436">/// nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</a>
<a name="ln1437">/// ```</a>
<a name="ln1438">///</a>
<a name="ln1439">/// @param channel_id</a>
<a name="ln1440">/// @param  mode  Mode short-name (map command prefix: &quot;n&quot;, &quot;i&quot;, &quot;v&quot;, &quot;x&quot;, )</a>
<a name="ln1441">///               or &quot;!&quot; for |:map!|, or empty string for |:map|.</a>
<a name="ln1442">///               &quot;ia&quot;, &quot;ca&quot; or &quot;!a&quot; for abbreviation in Insert mode, Cmdline mode, or both, respectively</a>
<a name="ln1443">/// @param  lhs   Left-hand-side |{lhs}| of the mapping.</a>
<a name="ln1444">/// @param  rhs   Right-hand-side |{rhs}| of the mapping.</a>
<a name="ln1445">/// @param  opts  Optional parameters map: Accepts all |:map-arguments| as keys except |&lt;buffer&gt;|,</a>
<a name="ln1446">///               values are booleans (default false). Also:</a>
<a name="ln1447">///               - &quot;noremap&quot; disables |recursive_mapping|, like |:noremap|</a>
<a name="ln1448">///               - &quot;desc&quot; human-readable description.</a>
<a name="ln1449">///               - &quot;callback&quot; Lua function called in place of {rhs}.</a>
<a name="ln1450">///               - &quot;replace_keycodes&quot; (boolean) When &quot;expr&quot; is true, replace keycodes in the</a>
<a name="ln1451">///                 resulting string (see |nvim_replace_termcodes()|). Returning nil from the Lua</a>
<a name="ln1452">///                 &quot;callback&quot; is equivalent to returning an empty string.</a>
<a name="ln1453">/// @param[out]   err   Error details, if any.</a>
<a name="ln1454">void nvim_set_keymap(uint64_t channel_id, String mode, String lhs, String rhs, Dict(keymap) *opts,</a>
<a name="ln1455">                     Error *err)</a>
<a name="ln1456">  FUNC_API_SINCE(6)</a>
<a name="ln1457">{</a>
<a name="ln1458">  modify_keymap(channel_id, -1, false, mode, lhs, rhs, opts, err);</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461">/// Unmaps a global |mapping| for the given mode.</a>
<a name="ln1462">///</a>
<a name="ln1463">/// To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.</a>
<a name="ln1464">///</a>
<a name="ln1465">/// @see |nvim_set_keymap()|</a>
<a name="ln1466">void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)</a>
<a name="ln1467">  FUNC_API_SINCE(6)</a>
<a name="ln1468">{</a>
<a name="ln1469">  nvim_buf_del_keymap(channel_id, -1, mode, lhs, err);</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">/// Returns a 2-tuple (Array), where item 0 is the current channel id and item</a>
<a name="ln1473">/// 1 is the |api-metadata| map (Dictionary).</a>
<a name="ln1474">///</a>
<a name="ln1475">/// @returns 2-tuple [{channel-id}, {api-metadata}]</a>
<a name="ln1476">Array nvim_get_api_info(uint64_t channel_id, Arena *arena)</a>
<a name="ln1477">  FUNC_API_SINCE(1) FUNC_API_FAST FUNC_API_REMOTE_ONLY</a>
<a name="ln1478">{</a>
<a name="ln1479">  Array rv = arena_array(arena, 2);</a>
<a name="ln1480"> </a>
<a name="ln1481">  assert(channel_id &lt;= INT64_MAX);</a>
<a name="ln1482">  ADD_C(rv, INTEGER_OBJ((int64_t)channel_id));</a>
<a name="ln1483">  ADD_C(rv, DICTIONARY_OBJ(api_metadata()));</a>
<a name="ln1484"> </a>
<a name="ln1485">  return rv;</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488">/// Self-identifies the client.</a>
<a name="ln1489">///</a>
<a name="ln1490">/// The client/plugin/application should call this after connecting, to provide</a>
<a name="ln1491">/// hints about its identity and purpose, for debugging and orchestration.</a>
<a name="ln1492">///</a>
<a name="ln1493">/// Can be called more than once; the caller should merge old info if</a>
<a name="ln1494">/// appropriate. Example: library first identifies the channel, then a plugin</a>
<a name="ln1495">/// using that library later identifies itself.</a>
<a name="ln1496">///</a>
<a name="ln1497">/// @note &quot;Something is better than nothing&quot;. You don't need to include all the</a>
<a name="ln1498">///       fields.</a>
<a name="ln1499">///</a>
<a name="ln1500">/// @param channel_id</a>
<a name="ln1501">/// @param name Short name for the connected client</a>
<a name="ln1502">/// @param version  Dictionary describing the version, with these</a>
<a name="ln1503">///                 (optional) keys:</a>
<a name="ln1504">///     - &quot;major&quot; major version (defaults to 0 if not set, for no release yet)</a>
<a name="ln1505">///     - &quot;minor&quot; minor version</a>
<a name="ln1506">///     - &quot;patch&quot; patch number</a>
<a name="ln1507">///     - &quot;prerelease&quot; string describing a prerelease, like &quot;dev&quot; or &quot;beta1&quot;</a>
<a name="ln1508">///     - &quot;commit&quot; hash or similar identifier of commit</a>
<a name="ln1509">/// @param type Must be one of the following values. Client libraries should</a>
<a name="ln1510">///             default to &quot;remote&quot; unless overridden by the user.</a>
<a name="ln1511">///     - &quot;remote&quot; remote client connected &quot;Nvim flavored&quot; MessagePack-RPC (responses</a>
<a name="ln1512">///                must be in reverse order of requests). |msgpack-rpc|</a>
<a name="ln1513">///     - &quot;msgpack-rpc&quot; remote client connected to Nvim via fully MessagePack-RPC</a>
<a name="ln1514">///                     compliant protocol.</a>
<a name="ln1515">///     - &quot;ui&quot; gui frontend</a>
<a name="ln1516">///     - &quot;embedder&quot; application using Nvim as a component (for example,</a>
<a name="ln1517">///                  IDE/editor implementing a vim mode).</a>
<a name="ln1518">///     - &quot;host&quot; plugin host, typically started by nvim</a>
<a name="ln1519">///     - &quot;plugin&quot; single plugin, started by nvim</a>
<a name="ln1520">/// @param methods Builtin methods in the client. For a host, this does not</a>
<a name="ln1521">///                include plugin methods which will be discovered later.</a>
<a name="ln1522">///                The key should be the method name, the values are dicts with</a>
<a name="ln1523">///                these (optional) keys (more keys may be added in future</a>
<a name="ln1524">///                versions of Nvim, thus unknown keys are ignored. Clients</a>
<a name="ln1525">///                must only use keys defined in this or later versions of</a>
<a name="ln1526">///                Nvim):</a>
<a name="ln1527">///     - &quot;async&quot;  if true, send as a notification. If false or unspecified,</a>
<a name="ln1528">///                use a blocking request</a>
<a name="ln1529">///     - &quot;nargs&quot; Number of arguments. Could be a single integer or an array</a>
<a name="ln1530">///                of two integers, minimum and maximum inclusive.</a>
<a name="ln1531">///</a>
<a name="ln1532">/// @param attributes Arbitrary string:string map of informal client properties.</a>
<a name="ln1533">///     Suggested keys:</a>
<a name="ln1534">///     - &quot;website&quot;: Client homepage URL (e.g. GitHub repository)</a>
<a name="ln1535">///     - &quot;license&quot;: License description (&quot;Apache 2&quot;, &quot;GPLv3&quot;, &quot;MIT&quot;, )</a>
<a name="ln1536">///     - &quot;logo&quot;:    URI or path to image, preferably small logo or icon.</a>
<a name="ln1537">///                  .png or .svg format is preferred.</a>
<a name="ln1538">///</a>
<a name="ln1539">/// @param[out] err Error details, if any</a>
<a name="ln1540">void nvim_set_client_info(uint64_t channel_id, String name, Dictionary version, String type,</a>
<a name="ln1541">                          Dictionary methods, Dictionary attributes, Error *err)</a>
<a name="ln1542">  FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY</a>
<a name="ln1543">{</a>
<a name="ln1544">  Dictionary info = ARRAY_DICT_INIT;</a>
<a name="ln1545">  PUT(info, &quot;name&quot;, copy_object(STRING_OBJ(name), NULL));</a>
<a name="ln1546"> </a>
<a name="ln1547">  version = copy_dictionary(version, NULL);</a>
<a name="ln1548">  bool has_major = false;</a>
<a name="ln1549">  for (size_t i = 0; i &lt; version.size; i++) {</a>
<a name="ln1550">    if (strequal(version.items[i].key.data, &quot;major&quot;)) {</a>
<a name="ln1551">      has_major = true;</a>
<a name="ln1552">      break;</a>
<a name="ln1553">    }</a>
<a name="ln1554">  }</a>
<a name="ln1555">  if (!has_major) {</a>
<a name="ln1556">    PUT(version, &quot;major&quot;, INTEGER_OBJ(0));</a>
<a name="ln1557">  }</a>
<a name="ln1558">  PUT(info, &quot;version&quot;, DICTIONARY_OBJ(version));</a>
<a name="ln1559"> </a>
<a name="ln1560">  PUT(info, &quot;type&quot;, copy_object(STRING_OBJ(type), NULL));</a>
<a name="ln1561">  PUT(info, &quot;methods&quot;, DICTIONARY_OBJ(copy_dictionary(methods, NULL)));</a>
<a name="ln1562">  PUT(info, &quot;attributes&quot;, DICTIONARY_OBJ(copy_dictionary(attributes, NULL)));</a>
<a name="ln1563"> </a>
<a name="ln1564">  rpc_set_client_info(channel_id, info);</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">/// Gets information about a channel.</a>
<a name="ln1568">///</a>
<a name="ln1569">/// @returns Dictionary describing a channel, with these keys:</a>
<a name="ln1570">///    - &quot;id&quot;       Channel id.</a>
<a name="ln1571">///    - &quot;argv&quot;     (optional) Job arguments list.</a>
<a name="ln1572">///    - &quot;stream&quot;   Stream underlying the channel.</a>
<a name="ln1573">///         - &quot;stdio&quot;      stdin and stdout of this Nvim instance</a>
<a name="ln1574">///         - &quot;stderr&quot;     stderr of this Nvim instance</a>
<a name="ln1575">///         - &quot;socket&quot;     TCP/IP socket or named pipe</a>
<a name="ln1576">///         - &quot;job&quot;        Job with communication over its stdio.</a>
<a name="ln1577">///    -  &quot;mode&quot;    How data received on the channel is interpreted.</a>
<a name="ln1578">///         - &quot;bytes&quot;      Send and receive raw bytes.</a>
<a name="ln1579">///         - &quot;terminal&quot;   |terminal| instance interprets ASCII sequences.</a>
<a name="ln1580">///         - &quot;rpc&quot;        |RPC| communication on the channel is active.</a>
<a name="ln1581">///    -  &quot;pty&quot;     (optional) Name of pseudoterminal. On a POSIX system this</a>
<a name="ln1582">///                 is a device path like &quot;/dev/pts/1&quot;. If the name is unknown,</a>
<a name="ln1583">///                 the key will still be present if a pty is used (e.g. for</a>
<a name="ln1584">///                 conpty on Windows).</a>
<a name="ln1585">///    -  &quot;buffer&quot;  (optional) Buffer with connected |terminal| instance.</a>
<a name="ln1586">///    -  &quot;client&quot;  (optional) Info about the peer (client on the other end of</a>
<a name="ln1587">///                 the RPC channel), if provided by it via</a>
<a name="ln1588">///                 |nvim_set_client_info()|.</a>
<a name="ln1589">///</a>
<a name="ln1590">Dictionary nvim_get_chan_info(Integer chan, Error *err)</a>
<a name="ln1591">  FUNC_API_SINCE(4)</a>
<a name="ln1592">{</a>
<a name="ln1593">  if (chan &lt; 0) {</a>
<a name="ln1594">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1595">  }</a>
<a name="ln1596">  return channel_info((uint64_t)chan);</a>
<a name="ln1597">}</a>
<a name="ln1598"> </a>
<a name="ln1599">/// Get information about all open channels.</a>
<a name="ln1600">///</a>
<a name="ln1601">/// @returns Array of Dictionaries, each describing a channel with</a>
<a name="ln1602">///          the format specified at |nvim_get_chan_info()|.</a>
<a name="ln1603">Array nvim_list_chans(void)</a>
<a name="ln1604">  FUNC_API_SINCE(4)</a>
<a name="ln1605">{</a>
<a name="ln1606">  return channel_all_info();</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">/// Calls many API methods atomically.</a>
<a name="ln1610">///</a>
<a name="ln1611">/// This has two main usages:</a>
<a name="ln1612">/// 1. To perform several requests from an async context atomically, i.e.</a>
<a name="ln1613">///    without interleaving redraws, RPC requests from other clients, or user</a>
<a name="ln1614">///    interactions (however API methods may trigger autocommands or event</a>
<a name="ln1615">///    processing which have such side effects, e.g. |:sleep| may wake timers).</a>
<a name="ln1616">/// 2. To minimize RPC overhead (roundtrips) of a sequence of many requests.</a>
<a name="ln1617">///</a>
<a name="ln1618">/// @param channel_id</a>
<a name="ln1619">/// @param calls an array of calls, where each call is described by an array</a>
<a name="ln1620">///              with two elements: the request name, and an array of arguments.</a>
<a name="ln1621">/// @param[out] err Validation error details (malformed `calls` parameter),</a>
<a name="ln1622">///             if any. Errors from batched calls are given in the return value.</a>
<a name="ln1623">///</a>
<a name="ln1624">/// @return Array of two elements. The first is an array of return</a>
<a name="ln1625">/// values. The second is NIL if all calls succeeded. If a call resulted in</a>
<a name="ln1626">/// an error, it is a three-element array with the zero-based index of the call</a>
<a name="ln1627">/// which resulted in an error, the error type and the error message. If an</a>
<a name="ln1628">/// error occurred, the values from all preceding calls will still be returned.</a>
<a name="ln1629">Array nvim_call_atomic(uint64_t channel_id, Array calls, Arena *arena, Error *err)</a>
<a name="ln1630">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1631">{</a>
<a name="ln1632">  Array rv = arena_array(arena, 2);</a>
<a name="ln1633">  Array results = arena_array(arena, calls.size);</a>
<a name="ln1634">  Error nested_error = ERROR_INIT;</a>
<a name="ln1635"> </a>
<a name="ln1636">  size_t i;  // also used for freeing the variables</a>
<a name="ln1637">  for (i = 0; i &lt; calls.size; i++) {</a>
<a name="ln1638">    VALIDATE_T(&quot;'calls' item&quot;, kObjectTypeArray, calls.items[i].type, {</a>
<a name="ln1639">      goto theend;</a>
<a name="ln1640">    });</a>
<a name="ln1641">    Array call = calls.items[i].data.array;</a>
<a name="ln1642">    VALIDATE_EXP((call.size == 2), &quot;'calls' item&quot;, &quot;2-item Array&quot;, NULL, {</a>
<a name="ln1643">      goto theend;</a>
<a name="ln1644">    });</a>
<a name="ln1645">    VALIDATE_T(&quot;name&quot;, kObjectTypeString, call.items[0].type, {</a>
<a name="ln1646">      goto theend;</a>
<a name="ln1647">    });</a>
<a name="ln1648">    String name = call.items[0].data.string;</a>
<a name="ln1649">    VALIDATE_T(&quot;call args&quot;, kObjectTypeArray, call.items[1].type, {</a>
<a name="ln1650">      goto theend;</a>
<a name="ln1651">    });</a>
<a name="ln1652">    Array args = call.items[1].data.array;</a>
<a name="ln1653"> </a>
<a name="ln1654">    MsgpackRpcRequestHandler handler =</a>
<a name="ln1655">      msgpack_rpc_get_handler_for(name.data,</a>
<a name="ln1656">                                  name.size,</a>
<a name="ln1657">                                  &amp;nested_error);</a>
<a name="ln1658"> </a>
<a name="ln1659">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1660">      break;</a>
<a name="ln1661">    }</a>
<a name="ln1662"> </a>
<a name="ln1663">    Object result = handler.fn(channel_id, args, arena, &amp;nested_error);</a>
<a name="ln1664">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1665">      // error handled after loop</a>
<a name="ln1666">      break;</a>
<a name="ln1667">    }</a>
<a name="ln1668">    // TODO(bfredl): wasteful copy. It could be avoided to encoding to msgpack</a>
<a name="ln1669">    // directly here. But `result` might become invalid when next api function</a>
<a name="ln1670">    // is called in the loop.</a>
<a name="ln1671">    ADD_C(results, copy_object(result, arena));</a>
<a name="ln1672">    if (!handler.arena_return) {</a>
<a name="ln1673">      api_free_object(result);</a>
<a name="ln1674">    }</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">  ADD_C(rv, ARRAY_OBJ(results));</a>
<a name="ln1678">  if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1679">    Array errval = arena_array(arena, 3);</a>
<a name="ln1680">    ADD_C(errval, INTEGER_OBJ((Integer)i));</a>
<a name="ln1681">    ADD_C(errval, INTEGER_OBJ(nested_error.type));</a>
<a name="ln1682">    ADD_C(errval, STRING_OBJ(copy_string(cstr_as_string(nested_error.msg), arena)));</a>
<a name="ln1683">    ADD_C(rv, ARRAY_OBJ(errval));</a>
<a name="ln1684">  } else {</a>
<a name="ln1685">    ADD_C(rv, NIL);</a>
<a name="ln1686">  }</a>
<a name="ln1687"> </a>
<a name="ln1688">theend:</a>
<a name="ln1689">  api_clear_error(&amp;nested_error);</a>
<a name="ln1690">  return rv;</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">/// Writes a message to vim output or error buffer. The string is split</a>
<a name="ln1694">/// and flushed after each newline. Incomplete lines are kept for writing</a>
<a name="ln1695">/// later.</a>
<a name="ln1696">///</a>
<a name="ln1697">/// @param message  Message to write</a>
<a name="ln1698">/// @param to_err   true: message is an error (uses `emsg` instead of `msg`)</a>
<a name="ln1699">/// @param writeln  Append a trailing newline</a>
<a name="ln1700">static void write_msg(String message, bool to_err, bool writeln)</a>
<a name="ln1701">{</a>
<a name="ln1702">  static StringBuilder out_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1703">  static StringBuilder err_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1704">  StringBuilder *line_buf = to_err ? &amp;err_line_buf : &amp;out_line_buf;</a>
<a name="ln1705"> </a>
<a name="ln1706">#define PUSH_CHAR(c) \</a>
<a name="ln1707">  if (kv_max(*line_buf) == 0) { \</a>
<a name="ln1708">    kv_resize(*line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1709">  } \</a>
<a name="ln1710">  if (c == NL) { \</a>
<a name="ln1711">    kv_push(*line_buf, NUL); \</a>
<a name="ln1712">    if (to_err) { \</a>
<a name="ln1713">      emsg(line_buf-&gt;items); \</a>
<a name="ln1714">    } else { \</a>
<a name="ln1715">      msg(line_buf-&gt;items, 0); \</a>
<a name="ln1716">    } \</a>
<a name="ln1717">    msg_didout = true; \</a>
<a name="ln1718">    kv_drop(*line_buf, kv_size(*line_buf)); \</a>
<a name="ln1719">    kv_resize(*line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1720">  } else if (c == NUL) { \</a>
<a name="ln1721">    kv_push(*line_buf, NL); \</a>
<a name="ln1722">  } else { \</a>
<a name="ln1723">    kv_push(*line_buf, c); \</a>
<a name="ln1724">  }</a>
<a name="ln1725"> </a>
<a name="ln1726">  no_wait_return++;</a>
<a name="ln1727">  for (uint32_t i = 0; i &lt; message.size; i++) {</a>
<a name="ln1728">    if (got_int) {</a>
<a name="ln1729">      break;</a>
<a name="ln1730">    }</a>
<a name="ln1731">    PUSH_CHAR(message.data[i]);</a>
<a name="ln1732">  }</a>
<a name="ln1733">  if (writeln) {</a>
<a name="ln1734">    PUSH_CHAR(NL);</a>
<a name="ln1735">  }</a>
<a name="ln1736">  no_wait_return--;</a>
<a name="ln1737">  msg_end();</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">// Functions used for testing purposes</a>
<a name="ln1741"> </a>
<a name="ln1742">/// Returns object given as argument.</a>
<a name="ln1743">///</a>
<a name="ln1744">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1745">/// in plugins.</a>
<a name="ln1746">///</a>
<a name="ln1747">/// @param[in]  obj  Object to return.</a>
<a name="ln1748">///</a>
<a name="ln1749">/// @return its argument.</a>
<a name="ln1750">Object nvim__id(Object obj)</a>
<a name="ln1751">{</a>
<a name="ln1752">  return copy_object(obj, NULL);</a>
<a name="ln1753">}</a>
<a name="ln1754"> </a>
<a name="ln1755">/// Returns array given as argument.</a>
<a name="ln1756">///</a>
<a name="ln1757">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1758">/// in plugins.</a>
<a name="ln1759">///</a>
<a name="ln1760">/// @param[in]  arr  Array to return.</a>
<a name="ln1761">///</a>
<a name="ln1762">/// @return its argument.</a>
<a name="ln1763">Array nvim__id_array(Array arr)</a>
<a name="ln1764">{</a>
<a name="ln1765">  return copy_array(arr, NULL);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">/// Returns dictionary given as argument.</a>
<a name="ln1769">///</a>
<a name="ln1770">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1771">/// in plugins.</a>
<a name="ln1772">///</a>
<a name="ln1773">/// @param[in]  dct  Dictionary to return.</a>
<a name="ln1774">///</a>
<a name="ln1775">/// @return its argument.</a>
<a name="ln1776">Dictionary nvim__id_dictionary(Dictionary dct)</a>
<a name="ln1777">{</a>
<a name="ln1778">  return copy_dictionary(dct, NULL);</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">/// Returns floating-point value given as argument.</a>
<a name="ln1782">///</a>
<a name="ln1783">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1784">/// in plugins.</a>
<a name="ln1785">///</a>
<a name="ln1786">/// @param[in]  flt  Value to return.</a>
<a name="ln1787">///</a>
<a name="ln1788">/// @return its argument.</a>
<a name="ln1789">Float nvim__id_float(Float flt)</a>
<a name="ln1790">{</a>
<a name="ln1791">  return flt;</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">/// Gets internal stats.</a>
<a name="ln1795">///</a>
<a name="ln1796">/// @return Map of various internal stats.</a>
<a name="ln1797">Dictionary nvim__stats(void)</a>
<a name="ln1798">{</a>
<a name="ln1799">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1800">  PUT(rv, &quot;fsync&quot;, INTEGER_OBJ(g_stats.fsync));</a>
<a name="ln1801">  PUT(rv, &quot;log_skip&quot;, INTEGER_OBJ(g_stats.log_skip));</a>
<a name="ln1802">  PUT(rv, &quot;lua_refcount&quot;, INTEGER_OBJ(nlua_get_global_ref_count()));</a>
<a name="ln1803">  PUT(rv, &quot;redraw&quot;, INTEGER_OBJ(g_stats.redraw));</a>
<a name="ln1804">  PUT(rv, &quot;arena_alloc_count&quot;, INTEGER_OBJ((Integer)arena_alloc_count));</a>
<a name="ln1805">  return rv;</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808">/// Gets a list of dictionaries representing attached UIs.</a>
<a name="ln1809">///</a>
<a name="ln1810">/// @return Array of UI dictionaries, each with these keys:</a>
<a name="ln1811">///   - &quot;height&quot;  Requested height of the UI</a>
<a name="ln1812">///   - &quot;width&quot;   Requested width of the UI</a>
<a name="ln1813">///   - &quot;rgb&quot;     true if the UI uses RGB colors (false implies |cterm-colors|)</a>
<a name="ln1814">///   - &quot;ext_...&quot; Requested UI extensions, see |ui-option|</a>
<a name="ln1815">///   - &quot;chan&quot;    |channel-id| of remote UI</a>
<a name="ln1816">Array nvim_list_uis(void)</a>
<a name="ln1817">  FUNC_API_SINCE(4)</a>
<a name="ln1818">{</a>
<a name="ln1819">  return ui_array();</a>
<a name="ln1820">}</a>
<a name="ln1821"> </a>
<a name="ln1822">/// Gets the immediate children of process `pid`.</a>
<a name="ln1823">///</a>
<a name="ln1824">/// @return Array of child process ids, empty if process not found.</a>
<a name="ln1825">Array nvim_get_proc_children(Integer pid, Error *err)</a>
<a name="ln1826">  FUNC_API_SINCE(4)</a>
<a name="ln1827">{</a>
<a name="ln1828">  Array rvobj = ARRAY_DICT_INIT;</a>
<a name="ln1829">  int *proc_list = NULL;</a>
<a name="ln1830"> </a>
<a name="ln1831">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1832">    goto end;</a>
<a name="ln1833">  });</a>
<a name="ln1834"> </a>
<a name="ln1835">  size_t proc_count;</a>
<a name="ln1836">  int rv = os_proc_children((int)pid, &amp;proc_list, &amp;proc_count);</a>
<a name="ln1837">  if (rv == 2) {</a>
<a name="ln1838">    // syscall failed (possibly because of kernel options), try shelling out.</a>
<a name="ln1839">    DLOG(&quot;fallback to vim._os_proc_children()&quot;);</a>
<a name="ln1840">    MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1841">    ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1842">    Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_children(...)&quot;, a, err);</a>
<a name="ln1843">    if (o.type == kObjectTypeArray) {</a>
<a name="ln1844">      rvobj = o.data.array;</a>
<a name="ln1845">    } else if (!ERROR_SET(err)) {</a>
<a name="ln1846">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1847">                    &quot;Failed to get process children. pid=%&quot; PRId64 &quot; error=%d&quot;,</a>
<a name="ln1848">                    pid, rv);</a>
<a name="ln1849">    }</a>
<a name="ln1850">    goto end;</a>
<a name="ln1851">  }</a>
<a name="ln1852"> </a>
<a name="ln1853">  for (size_t i = 0; i &lt; proc_count; i++) {</a>
<a name="ln1854">    ADD(rvobj, INTEGER_OBJ(proc_list[i]));</a>
<a name="ln1855">  }</a>
<a name="ln1856"> </a>
<a name="ln1857">end:</a>
<a name="ln1858">  xfree(proc_list);</a>
<a name="ln1859">  return rvobj;</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">/// Gets info describing process `pid`.</a>
<a name="ln1863">///</a>
<a name="ln1864">/// @return Map of process properties, or NIL if process not found.</a>
<a name="ln1865">Object nvim_get_proc(Integer pid, Error *err)</a>
<a name="ln1866">  FUNC_API_SINCE(4)</a>
<a name="ln1867">{</a>
<a name="ln1868">  Object rvobj = OBJECT_INIT;</a>
<a name="ln1869">  rvobj.data.dictionary = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1870">  rvobj.type = kObjectTypeDictionary;</a>
<a name="ln1871"> </a>
<a name="ln1872">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1873">    return NIL;</a>
<a name="ln1874">  });</a>
<a name="ln1875"> </a>
<a name="ln1876">#ifdef MSWIN</a>
<a name="ln1877">  rvobj.data.dictionary = os_proc_info((int)pid);</a>
<a name="ln1878">  if (rvobj.data.dictionary.size == 0) {  // Process not found.</a>
<a name="ln1879">    return NIL;</a>
<a name="ln1880">  }</a>
<a name="ln1881">#else</a>
<a name="ln1882">  // Cross-platform process info APIs are miserable, so use `ps` instead.</a>
<a name="ln1883">  MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1884">  ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1885">  Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_info(...)&quot;, a, err);</a>
<a name="ln1886">  if (o.type == kObjectTypeArray &amp;&amp; o.data.array.size == 0) {</a>
<a name="ln1887">    return NIL;  // Process not found.</a>
<a name="ln1888">  } else if (o.type == kObjectTypeDictionary) {</a>
<a name="ln1889">    rvobj.data.dictionary = o.data.dictionary;</a>
<a name="ln1890">  } else if (!ERROR_SET(err)) {</a>
<a name="ln1891">    api_set_error(err, kErrorTypeException,</a>
<a name="ln1892">                  &quot;Failed to get process info. pid=%&quot; PRId64, pid);</a>
<a name="ln1893">  }</a>
<a name="ln1894">#endif</a>
<a name="ln1895">  return rvobj;</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">/// Selects an item in the completion popup menu.</a>
<a name="ln1899">///</a>
<a name="ln1900">/// If neither |ins-completion| nor |cmdline-completion| popup menu is active</a>
<a name="ln1901">/// this API call is silently ignored.</a>
<a name="ln1902">/// Useful for an external UI using |ui-popupmenu| to control the popup menu with the mouse.</a>
<a name="ln1903">/// Can also be used in a mapping; use &lt;Cmd&gt; |:map-cmd| or a Lua mapping to ensure the mapping</a>
<a name="ln1904">/// doesn't end completion mode.</a>
<a name="ln1905">///</a>
<a name="ln1906">/// @param item    Index (zero-based) of the item to select. Value of -1 selects nothing</a>
<a name="ln1907">///                and restores the original text.</a>
<a name="ln1908">/// @param insert  For |ins-completion|, whether the selection should be inserted in the buffer.</a>
<a name="ln1909">///                Ignored for |cmdline-completion|.</a>
<a name="ln1910">/// @param finish  Finish the completion and dismiss the popup menu. Implies {insert}.</a>
<a name="ln1911">/// @param opts    Optional parameters. Reserved for future use.</a>
<a name="ln1912">/// @param[out] err Error details, if any</a>
<a name="ln1913">void nvim_select_popupmenu_item(Integer item, Boolean insert, Boolean finish, Dictionary opts,</a>
<a name="ln1914">                                Error *err)</a>
<a name="ln1915">  FUNC_API_SINCE(6)</a>
<a name="ln1916">{</a>
<a name="ln1917">  VALIDATE((opts.size == 0), &quot;%s&quot;, &quot;opts dict isn't empty&quot;, {</a>
<a name="ln1918">    return;</a>
<a name="ln1919">  });</a>
<a name="ln1920"> </a>
<a name="ln1921">  if (finish) {</a>
<a name="ln1922">    insert = true;</a>
<a name="ln1923">  }</a>
<a name="ln1924"> </a>
<a name="ln1925">  pum_ext_select_item((int)item, insert, finish);</a>
<a name="ln1926">}</a>
<a name="ln1927"> </a>
<a name="ln1928">/// NB: if your UI doesn't use hlstate, this will not return hlstate first time</a>
<a name="ln1929">Array nvim__inspect_cell(Integer grid, Integer row, Integer col, Arena *arena, Error *err)</a>
<a name="ln1930">{</a>
<a name="ln1931">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1932"> </a>
<a name="ln1933">  // TODO(bfredl): if grid == 0 we should read from the compositor's buffer.</a>
<a name="ln1934">  // The only problem is that it does not yet exist.</a>
<a name="ln1935">  ScreenGrid *g = &amp;default_grid;</a>
<a name="ln1936">  if (grid == pum_grid.handle) {</a>
<a name="ln1937">    g = &amp;pum_grid;</a>
<a name="ln1938">  } else if (grid &gt; 1) {</a>
<a name="ln1939">    win_T *wp = get_win_by_grid_handle((handle_T)grid);</a>
<a name="ln1940">    VALIDATE_INT((wp != NULL &amp;&amp; wp-&gt;w_grid_alloc.chars != NULL), &quot;grid handle&quot;, grid, {</a>
<a name="ln1941">      return ret;</a>
<a name="ln1942">    });</a>
<a name="ln1943">    g = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln1944">  }</a>
<a name="ln1945"> </a>
<a name="ln1946">  if (row &lt; 0 || row &gt;= g-&gt;rows</a>
<a name="ln1947">      || col &lt; 0 || col &gt;= g-&gt;cols) {</a>
<a name="ln1948">    return ret;</a>
<a name="ln1949">  }</a>
<a name="ln1950">  ret = arena_array(arena, 3);</a>
<a name="ln1951">  size_t off = g-&gt;line_offset[(size_t)row] + (size_t)col;</a>
<a name="ln1952">  char *sc_buf = arena_alloc(arena, MAX_SCHAR_SIZE, false);</a>
<a name="ln1953">  schar_get(sc_buf, g-&gt;chars[off]);</a>
<a name="ln1954">  ADD_C(ret, CSTR_AS_OBJ(sc_buf));</a>
<a name="ln1955">  int attr = g-&gt;attrs[off];</a>
<a name="ln1956">  ADD_C(ret, DICTIONARY_OBJ(hl_get_attr_by_id(attr, true, arena, err)));</a>
<a name="ln1957">  // will not work first time</a>
<a name="ln1958">  if (!highlight_use_hlstate()) {</a>
<a name="ln1959">    ADD_C(ret, ARRAY_OBJ(hl_inspect(attr)));</a>
<a name="ln1960">  }</a>
<a name="ln1961">  return ret;</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">void nvim__screenshot(String path)</a>
<a name="ln1965">  FUNC_API_FAST</a>
<a name="ln1966">{</a>
<a name="ln1967">  ui_call_screenshot(path);</a>
<a name="ln1968">}</a>
<a name="ln1969"> </a>
<a name="ln1970">void nvim__invalidate_glyph_cache(void)</a>
<a name="ln1971">{</a>
<a name="ln1972">  schar_cache_clear_force();</a>
<a name="ln1973">}</a>
<a name="ln1974"> </a>
<a name="ln1975">Object nvim__unpack(String str, Error *err)</a>
<a name="ln1976">  FUNC_API_FAST</a>
<a name="ln1977">{</a>
<a name="ln1978">  return unpack(str.data, str.size, err);</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">/// Deletes an uppercase/file named mark. See |mark-motions|.</a>
<a name="ln1982">///</a>
<a name="ln1983">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln1984">/// @param name       Mark name</a>
<a name="ln1985">/// @return true if the mark was deleted, else false.</a>
<a name="ln1986">/// @see |nvim_buf_del_mark()|</a>
<a name="ln1987">/// @see |nvim_get_mark()|</a>
<a name="ln1988">Boolean nvim_del_mark(String name, Error *err)</a>
<a name="ln1989">  FUNC_API_SINCE(8)</a>
<a name="ln1990">{</a>
<a name="ln1991">  bool res = false;</a>
<a name="ln1992">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln1993">    return res;</a>
<a name="ln1994">  });</a>
<a name="ln1995">  // Only allow file/uppercase marks</a>
<a name="ln1996">  // TODO(muniter): Refactor this ASCII_ISUPPER macro to a proper function</a>
<a name="ln1997">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln1998">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln1999">    return res;</a>
<a name="ln2000">  });</a>
<a name="ln2001">  res = set_mark(NULL, name, 0, 0, err);</a>
<a name="ln2002">  return res;</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">/// Returns a `(row, col, buffer, buffername)` tuple representing the position</a>
<a name="ln2006">/// of the uppercase/file named mark. &quot;End of line&quot; column position is returned</a>
<a name="ln2007">/// as |v:maxcol| (big number). See |mark-motions|.</a>
<a name="ln2008">///</a>
<a name="ln2009">/// Marks are (1,0)-indexed. |api-indexing|</a>
<a name="ln2010">///</a>
<a name="ln2011">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln2012">/// @param name       Mark name</a>
<a name="ln2013">/// @param opts       Optional parameters. Reserved for future use.</a>
<a name="ln2014">/// @return 4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is</a>
<a name="ln2015">/// not set.</a>
<a name="ln2016">/// @see |nvim_buf_set_mark()|</a>
<a name="ln2017">/// @see |nvim_del_mark()|</a>
<a name="ln2018">Array nvim_get_mark(String name, Dictionary opts, Error *err)</a>
<a name="ln2019">  FUNC_API_SINCE(8)</a>
<a name="ln2020">{</a>
<a name="ln2021">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln2022"> </a>
<a name="ln2023">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln2024">    return rv;</a>
<a name="ln2025">  });</a>
<a name="ln2026">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln2027">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2028">    return rv;</a>
<a name="ln2029">  });</a>
<a name="ln2030"> </a>
<a name="ln2031">  xfmark_T *mark = mark_get_global(false, *name.data);  // false avoids loading the mark buffer</a>
<a name="ln2032">  pos_T pos = mark-&gt;fmark.mark;</a>
<a name="ln2033">  bool allocated = false;</a>
<a name="ln2034">  int bufnr;</a>
<a name="ln2035">  char *filename;</a>
<a name="ln2036"> </a>
<a name="ln2037">  // Marks are from an open buffer it fnum is non zero</a>
<a name="ln2038">  if (mark-&gt;fmark.fnum != 0) {</a>
<a name="ln2039">    bufnr = mark-&gt;fmark.fnum;</a>
<a name="ln2040">    filename = buflist_nr2name(bufnr, true, true);</a>
<a name="ln2041">    allocated = true;</a>
<a name="ln2042">    // Marks comes from shada</a>
<a name="ln2043">  } else {</a>
<a name="ln2044">    filename = mark-&gt;fname;</a>
<a name="ln2045">    bufnr = 0;</a>
<a name="ln2046">  }</a>
<a name="ln2047"> </a>
<a name="ln2048">  bool exists = filename != NULL;</a>
<a name="ln2049">  Integer row;</a>
<a name="ln2050">  Integer col;</a>
<a name="ln2051"> </a>
<a name="ln2052">  if (!exists || pos.lnum &lt;= 0) {</a>
<a name="ln2053">    if (allocated) {</a>
<a name="ln2054">      xfree(filename);</a>
<a name="ln2055">      allocated = false;</a>
<a name="ln2056">    }</a>
<a name="ln2057">    filename = &quot;&quot;;</a>
<a name="ln2058">    bufnr = 0;</a>
<a name="ln2059">    row = 0;</a>
<a name="ln2060">    col = 0;</a>
<a name="ln2061">  } else {</a>
<a name="ln2062">    row = pos.lnum;</a>
<a name="ln2063">    col = pos.col;</a>
<a name="ln2064">  }</a>
<a name="ln2065"> </a>
<a name="ln2066">  ADD(rv, INTEGER_OBJ(row));</a>
<a name="ln2067">  ADD(rv, INTEGER_OBJ(col));</a>
<a name="ln2068">  ADD(rv, INTEGER_OBJ(bufnr));</a>
<a name="ln2069">  ADD(rv, CSTR_TO_OBJ(filename));</a>
<a name="ln2070"> </a>
<a name="ln2071">  if (allocated) {</a>
<a name="ln2072">    xfree(filename);</a>
<a name="ln2073">  }</a>
<a name="ln2074"> </a>
<a name="ln2075">  return rv;</a>
<a name="ln2076">}</a>
<a name="ln2077"> </a>
<a name="ln2078">/// Evaluates statusline string.</a>
<a name="ln2079">///</a>
<a name="ln2080">/// @param str Statusline string (see 'statusline').</a>
<a name="ln2081">/// @param opts Optional parameters.</a>
<a name="ln2082">///           - winid: (number) |window-ID| of the window to use as context for statusline.</a>
<a name="ln2083">///           - maxwidth: (number) Maximum width of statusline.</a>
<a name="ln2084">///           - fillchar: (string) Character to fill blank spaces in the statusline (see</a>
<a name="ln2085">///                                'fillchars'). Treated as single-width even if it isn't.</a>
<a name="ln2086">///           - highlights: (boolean) Return highlight information.</a>
<a name="ln2087">///           - use_winbar: (boolean) Evaluate winbar instead of statusline.</a>
<a name="ln2088">///           - use_tabline: (boolean) Evaluate tabline instead of statusline. When true, {winid}</a>
<a name="ln2089">///                                    is ignored. Mutually exclusive with {use_winbar}.</a>
<a name="ln2090">///           - use_statuscol_lnum: (number) Evaluate statuscolumn for this line number instead of statusline.</a>
<a name="ln2091">///</a>
<a name="ln2092">/// @param[out] err Error details, if any.</a>
<a name="ln2093">/// @return Dictionary containing statusline information, with these keys:</a>
<a name="ln2094">///       - str: (string) Characters that will be displayed on the statusline.</a>
<a name="ln2095">///       - width: (number) Display width of the statusline.</a>
<a name="ln2096">///       - highlights: Array containing highlight information of the statusline. Only included when</a>
<a name="ln2097">///                     the &quot;highlights&quot; key in {opts} is true. Each element of the array is a</a>
<a name="ln2098">///                     |Dictionary| with these keys:</a>
<a name="ln2099">///           - start: (number) Byte index (0-based) of first character that uses the highlight.</a>
<a name="ln2100">///           - group: (string) Name of highlight group.</a>
<a name="ln2101">Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *err)</a>
<a name="ln2102">  FUNC_API_SINCE(8) FUNC_API_FAST</a>
<a name="ln2103">{</a>
<a name="ln2104">  Dictionary result = ARRAY_DICT_INIT;</a>
<a name="ln2105"> </a>
<a name="ln2106">  int maxwidth;</a>
<a name="ln2107">  int fillchar = 0;</a>
<a name="ln2108">  int statuscol_lnum = 0;</a>
<a name="ln2109">  Window window = 0;</a>
<a name="ln2110"> </a>
<a name="ln2111">  if (str.size &lt; 2 || memcmp(str.data, &quot;%!&quot;, 2) != 0) {</a>
<a name="ln2112">    const char *const errmsg = check_stl_option(str.data);</a>
<a name="ln2113">    VALIDATE(!errmsg, &quot;%s&quot;, errmsg, {</a>
<a name="ln2114">      return result;</a>
<a name="ln2115">    });</a>
<a name="ln2116">  }</a>
<a name="ln2117"> </a>
<a name="ln2118">  if (HAS_KEY(opts, eval_statusline, winid)) {</a>
<a name="ln2119">    window = opts-&gt;winid;</a>
<a name="ln2120">  }</a>
<a name="ln2121">  if (HAS_KEY(opts, eval_statusline, fillchar)) {</a>
<a name="ln2122">    VALIDATE_EXP((*opts-&gt;fillchar.data != 0</a>
<a name="ln2123">                  &amp;&amp; ((size_t)utf_ptr2len(opts-&gt;fillchar.data) == opts-&gt;fillchar.size)),</a>
<a name="ln2124">                 &quot;fillchar&quot;, &quot;single character&quot;, NULL, {</a>
<a name="ln2125">      return result;</a>
<a name="ln2126">    });</a>
<a name="ln2127">    fillchar = utf_ptr2char(opts-&gt;fillchar.data);</a>
<a name="ln2128">  }</a>
<a name="ln2129"> </a>
<a name="ln2130">  int use_bools = (int)opts-&gt;use_winbar + (int)opts-&gt;use_tabline;</a>
<a name="ln2131"> </a>
<a name="ln2132">  win_T *wp = opts-&gt;use_tabline ? curwin : find_window_by_handle(window, err);</a>
<a name="ln2133">  if (wp == NULL) {</a>
<a name="ln2134">    api_set_error(err, kErrorTypeException, &quot;unknown winid %d&quot;, window);</a>
<a name="ln2135">    return result;</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  if (HAS_KEY(opts, eval_statusline, use_statuscol_lnum)) {</a>
<a name="ln2139">    statuscol_lnum = (int)opts-&gt;use_statuscol_lnum;</a>
<a name="ln2140">    VALIDATE_RANGE(statuscol_lnum &gt; 0 &amp;&amp; statuscol_lnum &lt;= wp-&gt;w_buffer-&gt;b_ml.ml_line_count,</a>
<a name="ln2141">                   &quot;use_statuscol_lnum&quot;, {</a>
<a name="ln2142">      return result;</a>
<a name="ln2143">    });</a>
<a name="ln2144">    use_bools++;</a>
<a name="ln2145">  }</a>
<a name="ln2146">  VALIDATE(use_bools &lt;= 1, &quot;%s&quot;,</a>
<a name="ln2147">           &quot;Can only use one of 'use_winbar', 'use_tabline' and 'use_statuscol_lnum'&quot;, {</a>
<a name="ln2148">    return result;</a>
<a name="ln2149">  });</a>
<a name="ln2150"> </a>
<a name="ln2151">  int stc_hl_id = 0;</a>
<a name="ln2152">  statuscol_T statuscol = { 0 };</a>
<a name="ln2153">  SignTextAttrs sattrs[SIGN_SHOW_MAX] = { 0 };</a>
<a name="ln2154"> </a>
<a name="ln2155">  if (opts-&gt;use_tabline) {</a>
<a name="ln2156">    fillchar = ' ';</a>
<a name="ln2157">  } else {</a>
<a name="ln2158">    if (fillchar == 0) {</a>
<a name="ln2159">      if (opts-&gt;use_winbar) {</a>
<a name="ln2160">        fillchar = wp-&gt;w_p_fcs_chars.wbr;</a>
<a name="ln2161">      } else {</a>
<a name="ln2162">        int attr;</a>
<a name="ln2163">        fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln2164">      }</a>
<a name="ln2165">    }</a>
<a name="ln2166">    if (statuscol_lnum) {</a>
<a name="ln2167">      HlPriId line = { 0 };</a>
<a name="ln2168">      HlPriId cul  = { 0 };</a>
<a name="ln2169">      HlPriId num  = { 0 };</a>
<a name="ln2170">      linenr_T lnum = statuscol_lnum;</a>
<a name="ln2171">      int num_signs = buf_get_signattrs(wp-&gt;w_buffer, lnum, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2172">      decor_redraw_signs(wp-&gt;w_buffer, lnum - 1, &amp;num_signs, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2173">      wp-&gt;w_scwidth = win_signcol_count(wp);</a>
<a name="ln2174"> </a>
<a name="ln2175">      statuscol.sattrs = sattrs;</a>
<a name="ln2176">      statuscol.foldinfo = fold_info(wp, lnum);</a>
<a name="ln2177">      wp-&gt;w_cursorline = win_cursorline_standout(wp) ? wp-&gt;w_cursor.lnum : 0;</a>
<a name="ln2178"> </a>
<a name="ln2179">      if (wp-&gt;w_p_cul) {</a>
<a name="ln2180">        if (statuscol.foldinfo.fi_level != 0 &amp;&amp; statuscol.foldinfo.fi_lines &gt; 0) {</a>
<a name="ln2181">          wp-&gt;w_cursorline = statuscol.foldinfo.fi_lnum;</a>
<a name="ln2182">        }</a>
<a name="ln2183">        statuscol.use_cul = lnum == wp-&gt;w_cursorline &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR);</a>
<a name="ln2184">      }</a>
<a name="ln2185"> </a>
<a name="ln2186">      statuscol.sign_cul_id = statuscol.use_cul ? cul.hl_id : 0;</a>
<a name="ln2187">      if (num.hl_id) {</a>
<a name="ln2188">        stc_hl_id = num.hl_id;</a>
<a name="ln2189">      } else if (statuscol.use_cul) {</a>
<a name="ln2190">        stc_hl_id = HLF_CLN + 1;</a>
<a name="ln2191">      } else if (wp-&gt;w_p_rnu) {</a>
<a name="ln2192">        stc_hl_id = (lnum &lt; wp-&gt;w_cursor.lnum ? HLF_LNA : HLF_LNB) + 1;</a>
<a name="ln2193">      } else {</a>
<a name="ln2194">        stc_hl_id = HLF_N + 1;</a>
<a name="ln2195">      }</a>
<a name="ln2196"> </a>
<a name="ln2197">      set_vim_var_nr(VV_LNUM, lnum);</a>
<a name="ln2198">      set_vim_var_nr(VV_RELNUM, labs(get_cursor_rel_lnum(wp, lnum)));</a>
<a name="ln2199">      set_vim_var_nr(VV_VIRTNUM, 0);</a>
<a name="ln2200">    }</a>
<a name="ln2201">  }</a>
<a name="ln2202"> </a>
<a name="ln2203">  if (HAS_KEY(opts, eval_statusline, maxwidth)) {</a>
<a name="ln2204">    maxwidth = (int)opts-&gt;maxwidth;</a>
<a name="ln2205">  } else {</a>
<a name="ln2206">    maxwidth = statuscol_lnum ? win_col_off(wp)</a>
<a name="ln2207">               : (opts-&gt;use_tabline</a>
<a name="ln2208">                  || (!opts-&gt;use_winbar &amp;&amp; global_stl_height() &gt; 0)) ? Columns : wp-&gt;w_width;</a>
<a name="ln2209">  }</a>
<a name="ln2210"> </a>
<a name="ln2211">  char buf[MAXPATHL];</a>
<a name="ln2212">  stl_hlrec_t *hltab;</a>
<a name="ln2213"> </a>
<a name="ln2214">  // Temporarily reset 'cursorbind' to prevent side effects from moving the cursor away and back.</a>
<a name="ln2215">  int p_crb_save = wp-&gt;w_p_crb;</a>
<a name="ln2216">  wp-&gt;w_p_crb = false;</a>
<a name="ln2217"> </a>
<a name="ln2218">  int width = build_stl_str_hl(wp,</a>
<a name="ln2219">                               buf,</a>
<a name="ln2220">                               sizeof(buf),</a>
<a name="ln2221">                               str.data,</a>
<a name="ln2222">                               NULL,</a>
<a name="ln2223">                               0,</a>
<a name="ln2224">                               fillchar,</a>
<a name="ln2225">                               maxwidth,</a>
<a name="ln2226">                               opts-&gt;highlights ? &amp;hltab : NULL,</a>
<a name="ln2227">                               NULL,</a>
<a name="ln2228">                               statuscol_lnum ? &amp;statuscol : NULL);</a>
<a name="ln2229"> </a>
<a name="ln2230">  PUT(result, &quot;width&quot;, INTEGER_OBJ(width));</a>
<a name="ln2231"> </a>
<a name="ln2232">  // Restore original value of 'cursorbind'</a>
<a name="ln2233">  wp-&gt;w_p_crb = p_crb_save;</a>
<a name="ln2234"> </a>
<a name="ln2235">  if (opts-&gt;highlights) {</a>
<a name="ln2236">    Array hl_values = ARRAY_DICT_INIT;</a>
<a name="ln2237">    const char *grpname;</a>
<a name="ln2238">    char user_group[15];  // strlen(&quot;User&quot;) + strlen(&quot;2147483647&quot;) + NUL</a>
<a name="ln2239"> </a>
<a name="ln2240">    // If first character doesn't have a defined highlight,</a>
<a name="ln2241">    // add the default highlight at the beginning of the highlight list</a>
<a name="ln2242">    if (hltab-&gt;start == NULL || (hltab-&gt;start - buf) != 0) {</a>
<a name="ln2243">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2244">      grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2245"> </a>
<a name="ln2246">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(0));</a>
<a name="ln2247">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2248"> </a>
<a name="ln2249">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2250">    }</a>
<a name="ln2251"> </a>
<a name="ln2252">    for (stl_hlrec_t *sp = hltab; sp-&gt;start != NULL; sp++) {</a>
<a name="ln2253">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2254"> </a>
<a name="ln2255">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(sp-&gt;start - buf));</a>
<a name="ln2256"> </a>
<a name="ln2257">      if (sp-&gt;userhl == 0) {</a>
<a name="ln2258">        grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2259">      } else if (sp-&gt;userhl &lt; 0) {</a>
<a name="ln2260">        grpname = syn_id2name(-sp-&gt;userhl);</a>
<a name="ln2261">      } else {</a>
<a name="ln2262">        snprintf(user_group, sizeof(user_group), &quot;User%d&quot;, sp-&gt;userhl);</a>
<a name="ln2263">        grpname = user_group;</a>
<a name="ln2264">      }</a>
<a name="ln2265">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2266">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2267">    }</a>
<a name="ln2268">    PUT(result, &quot;highlights&quot;, ARRAY_OBJ(hl_values));</a>
<a name="ln2269">  }</a>
<a name="ln2270">  PUT(result, &quot;str&quot;, CSTR_TO_OBJ(buf));</a>
<a name="ln2271"> </a>
<a name="ln2272">  return result;</a>
<a name="ln2273">}</a>
<a name="ln2274"> </a>
<a name="ln2275">void nvim_error_event(uint64_t channel_id, Integer lvl, String data)</a>
<a name="ln2276">  FUNC_API_REMOTE_ONLY</a>
<a name="ln2277">{</a>
<a name="ln2278">  // TODO(bfredl): consider printing message to user, as will be relevant</a>
<a name="ln2279">  // if we fork nvim processes as async workers</a>
<a name="ln2280">  ELOG(&quot;async error on channel %&quot; PRId64 &quot;: %s&quot;, channel_id, data.size ? data.data : &quot;&quot;);</a>
<a name="ln2281">}</a>
</code></pre>
<div class="balloon" rel="566"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>