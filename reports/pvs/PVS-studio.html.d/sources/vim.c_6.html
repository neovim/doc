<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>vim.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;stdbool.h&gt;</a>
<a name="ln8">#include &lt;stddef.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;klib/kvec.h&quot;</a>
<a name="ln14">#include &quot;lauxlib.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln23">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln24">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln25">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln26">#include &quot;nvim/channel.h&quot;</a>
<a name="ln27">#include &quot;nvim/context.h&quot;</a>
<a name="ln28">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln29">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln33">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln35">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln36">#include &quot;nvim/globals.h&quot;</a>
<a name="ln37">#include &quot;nvim/grid.h&quot;</a>
<a name="ln38">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln39">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln40">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln41">#include &quot;nvim/log.h&quot;</a>
<a name="ln42">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln43">#include &quot;nvim/macros.h&quot;</a>
<a name="ln44">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln45">#include &quot;nvim/mark.h&quot;</a>
<a name="ln46">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln47">#include &quot;nvim/memline.h&quot;</a>
<a name="ln48">#include &quot;nvim/memory.h&quot;</a>
<a name="ln49">#include &quot;nvim/message.h&quot;</a>
<a name="ln50">#include &quot;nvim/move.h&quot;</a>
<a name="ln51">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln52">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln54">#include &quot;nvim/ops.h&quot;</a>
<a name="ln55">#include &quot;nvim/option.h&quot;</a>
<a name="ln56">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln57">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln58">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln59">#include &quot;nvim/os/process.h&quot;</a>
<a name="ln60">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln61">#include &quot;nvim/pos.h&quot;</a>
<a name="ln62">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln63">#include &quot;nvim/sign.h&quot;</a>
<a name="ln64">#include &quot;nvim/state.h&quot;</a>
<a name="ln65">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln66">#include &quot;nvim/strings.h&quot;</a>
<a name="ln67">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln68">#include &quot;nvim/types.h&quot;</a>
<a name="ln69">#include &quot;nvim/ui.h&quot;</a>
<a name="ln70">#include &quot;nvim/vim.h&quot;</a>
<a name="ln71">#include &quot;nvim/window.h&quot;</a>
<a name="ln72"> </a>
<a name="ln73">#define LINE_BUFFER_MIN_SIZE 4096</a>
<a name="ln74"> </a>
<a name="ln75">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln76"># include &quot;api/vim.c.generated.h&quot;</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">/// Gets a highlight group by name</a>
<a name="ln80">///</a>
<a name="ln81">/// similar to |hlID()|, but allocates a new ID if not present.</a>
<a name="ln82">Integer nvim_get_hl_id_by_name(String name)</a>
<a name="ln83">  FUNC_API_SINCE(7)</a>
<a name="ln84">{</a>
<a name="ln85">  return syn_check_group(name.data, name.size);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">/// Gets all or specific highlight groups in a namespace.</a>
<a name="ln89">///</a>
<a name="ln90">/// @note When the `link` attribute is defined in the highlight definition</a>
<a name="ln91">///       map, other attributes will not be taking effect (see |:hi-link|).</a>
<a name="ln92">///</a>
<a name="ln93">/// @param ns_id Get highlight groups for namespace ns_id |nvim_get_namespaces()|.</a>
<a name="ln94">///              Use 0 to get global highlight groups |:highlight|.</a>
<a name="ln95">/// @param opts  Options dict:</a>
<a name="ln96">///                 - name: (string) Get a highlight definition by name.</a>
<a name="ln97">///                 - id: (integer) Get a highlight definition by id.</a>
<a name="ln98">///                 - link: (boolean, default true) Show linked group name instead of effective definition |:hi-link|.</a>
<a name="ln99">///                 - create: (boolean, default true) When highlight group doesn't exist create it.</a>
<a name="ln100">///</a>
<a name="ln101">/// @param[out] err Error details, if any.</a>
<a name="ln102">/// @return Highlight groups as a map from group name to a highlight definition map as in |nvim_set_hl()|,</a>
<a name="ln103">///                   or only a single highlight definition map if requested by name or id.</a>
<a name="ln104">Dictionary nvim_get_hl(Integer ns_id, Dict(get_highlight) *opts, Arena *arena, Error *err)</a>
<a name="ln105">  FUNC_API_SINCE(11)</a>
<a name="ln106">{</a>
<a name="ln107">  return ns_get_hl_defs((NS)ns_id, opts, arena, err);</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/// Sets a highlight group.</a>
<a name="ln111">///</a>
<a name="ln112">/// @note Unlike the `:highlight` command which can update a highlight group,</a>
<a name="ln113">///       this function completely replaces the definition. For example:</a>
<a name="ln114">///       ``nvim_set_hl(0, 'Visual', {})`` will clear the highlight group</a>
<a name="ln115">///       'Visual'.</a>
<a name="ln116">///</a>
<a name="ln117">/// @note The fg and bg keys also accept the string values `&quot;fg&quot;` or `&quot;bg&quot;`</a>
<a name="ln118">///       which act as aliases to the corresponding foreground and background</a>
<a name="ln119">///       values of the Normal group. If the Normal group has not been defined,</a>
<a name="ln120">///       using these values results in an error.</a>
<a name="ln121">///</a>
<a name="ln122">///</a>
<a name="ln123">/// @note If `link` is used in combination with other attributes; only the</a>
<a name="ln124">///       `link` will take effect (see |:hi-link|).</a>
<a name="ln125">///</a>
<a name="ln126">/// @param ns_id Namespace id for this highlight |nvim_create_namespace()|.</a>
<a name="ln127">///              Use 0 to set a highlight group globally |:highlight|.</a>
<a name="ln128">///              Highlights from non-global namespaces are not active by default, use</a>
<a name="ln129">///              |nvim_set_hl_ns()| or |nvim_win_set_hl_ns()| to activate them.</a>
<a name="ln130">/// @param name  Highlight group name, e.g. &quot;ErrorMsg&quot;</a>
<a name="ln131">/// @param val   Highlight definition map, accepts the following keys:</a>
<a name="ln132">///                - fg (or foreground): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln133">///                - bg (or background): color name or &quot;#RRGGBB&quot;, see note.</a>
<a name="ln134">///                - sp (or special): color name or &quot;#RRGGBB&quot;</a>
<a name="ln135">///                - blend: integer between 0 and 100</a>
<a name="ln136">///                - bold: boolean</a>
<a name="ln137">///                - standout: boolean</a>
<a name="ln138">///                - underline: boolean</a>
<a name="ln139">///                - undercurl: boolean</a>
<a name="ln140">///                - underdouble: boolean</a>
<a name="ln141">///                - underdotted: boolean</a>
<a name="ln142">///                - underdashed: boolean</a>
<a name="ln143">///                - strikethrough: boolean</a>
<a name="ln144">///                - italic: boolean</a>
<a name="ln145">///                - reverse: boolean</a>
<a name="ln146">///                - nocombine: boolean</a>
<a name="ln147">///                - link: name of another highlight group to link to, see |:hi-link|.</a>
<a name="ln148">///                - default: Don't override existing definition |:hi-default|</a>
<a name="ln149">///                - ctermfg: Sets foreground of cterm color |ctermfg|</a>
<a name="ln150">///                - ctermbg: Sets background of cterm color |ctermbg|</a>
<a name="ln151">///                - cterm: cterm attribute map, like |highlight-args|. If not set,</a>
<a name="ln152">///                         cterm attributes will match those from the attribute map</a>
<a name="ln153">///                         documented above.</a>
<a name="ln154">///                - force: if true force update the highlight group when it exists.</a>
<a name="ln155">/// @param[out] err Error details, if any</a>
<a name="ln156">///</a>
<a name="ln157">// TODO(bfredl): val should take update vs reset flag</a>
<a name="ln158">void nvim_set_hl(Integer ns_id, String name, Dict(highlight) *val, Error *err)</a>
<a name="ln159">  FUNC_API_SINCE(7)</a>
<a name="ln160">{</a>
<a name="ln161">  int hl_id = syn_check_group(name.data, name.size);</a>
<a name="ln162">  VALIDATE_S((hl_id != 0), &quot;highlight name&quot;, name.data, {</a>
<a name="ln163">    return;</a>
<a name="ln164">  });</a>
<a name="ln165">  int link_id = -1;</a>
<a name="ln166"> </a>
<a name="ln167">  HlAttrs attrs = dict2hlattrs(val, true, &amp;link_id, err);</a>
<a name="ln168">  if (!ERROR_SET(err)) {</a>
<a name="ln169">    ns_hl_def((NS)ns_id, hl_id, attrs, link_id, val);</a>
<a name="ln170">  }</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/// Set active namespace for highlights defined with |nvim_set_hl()|. This can be set for</a>
<a name="ln174">/// a single window, see |nvim_win_set_hl_ns()|.</a>
<a name="ln175">///</a>
<a name="ln176">/// @param ns_id the namespace to use</a>
<a name="ln177">/// @param[out] err Error details, if any</a>
<a name="ln178">void nvim_set_hl_ns(Integer ns_id, Error *err)</a>
<a name="ln179">  FUNC_API_SINCE(10)</a>
<a name="ln180">{</a>
<a name="ln181">  VALIDATE_INT((ns_id &gt;= 0), &quot;namespace&quot;, ns_id, {</a>
<a name="ln182">    return;</a>
<a name="ln183">  });</a>
<a name="ln184"> </a>
<a name="ln185">  ns_hl_global = (NS)ns_id;</a>
<a name="ln186">  hl_check_ns();</a>
<a name="ln187">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">/// Set active namespace for highlights defined with |nvim_set_hl()| while redrawing.</a>
<a name="ln191">///</a>
<a name="ln192">/// This function meant to be called while redrawing, primarily from</a>
<a name="ln193">/// |nvim_set_decoration_provider()| on_win and on_line callbacks, which</a>
<a name="ln194">/// are allowed to change the namespace during a redraw cycle.</a>
<a name="ln195">///</a>
<a name="ln196">/// @param ns_id the namespace to activate</a>
<a name="ln197">/// @param[out] err Error details, if any</a>
<a name="ln198">void nvim_set_hl_ns_fast(Integer ns_id, Error *err)</a>
<a name="ln199">  FUNC_API_SINCE(10)</a>
<a name="ln200">  FUNC_API_FAST</a>
<a name="ln201">{</a>
<a name="ln202">  ns_hl_fast = (NS)ns_id;</a>
<a name="ln203">  hl_check_ns();</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">/// Sends input-keys to Nvim, subject to various quirks controlled by `mode`</a>
<a name="ln207">/// flags. This is a blocking call, unlike |nvim_input()|.</a>
<a name="ln208">///</a>
<a name="ln209">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln210">///</a>
<a name="ln211">/// To input sequences like &lt;C-o&gt; use |nvim_replace_termcodes()| (typically</a>
<a name="ln212">/// with escape_ks=false) to replace |keycodes|, then pass the result to</a>
<a name="ln213">/// nvim_feedkeys().</a>
<a name="ln214">///</a>
<a name="ln215">/// Example:</a>
<a name="ln216">///</a>
<a name="ln217">/// ```vim</a>
<a name="ln218">/// :let key = nvim_replace_termcodes(&quot;&lt;C-o&gt;&quot;, v:true, v:false, v:true)</a>
<a name="ln219">/// :call nvim_feedkeys(key, 'n', v:false)</a>
<a name="ln220">/// ```</a>
<a name="ln221">///</a>
<a name="ln222">/// @param keys         to be typed</a>
<a name="ln223">/// @param mode         behavior flags, see |feedkeys()|</a>
<a name="ln224">/// @param escape_ks    If true, escape K_SPECIAL bytes in `keys`.</a>
<a name="ln225">///                     This should be false if you already used</a>
<a name="ln226">///                     |nvim_replace_termcodes()|, and true otherwise.</a>
<a name="ln227">/// @see feedkeys()</a>
<a name="ln228">/// @see vim_strsave_escape_ks</a>
<a name="ln229">void nvim_feedkeys(String keys, String mode, Boolean escape_ks)</a>
<a name="ln230">  FUNC_API_SINCE(1)</a>
<a name="ln231">{</a>
<a name="ln232">  bool remap = true;</a>
<a name="ln233">  bool insert = false;</a>
<a name="ln234">  bool typed = false;</a>
<a name="ln235">  bool execute = false;</a>
<a name="ln236">  bool dangerous = false;</a>
<a name="ln237"> </a>
<a name="ln238">  for (size_t i = 0; i &lt; mode.size; i++) {</a>
<a name="ln239">    switch (mode.data[i]) {</a>
<a name="ln240">    case 'n':</a>
<a name="ln241">      remap = false; break;</a>
<a name="ln242">    case 'm':</a>
<a name="ln243">      remap = true; break;</a>
<a name="ln244">    case 't':</a>
<a name="ln245">      typed = true; break;</a>
<a name="ln246">    case 'i':</a>
<a name="ln247">      insert = true; break;</a>
<a name="ln248">    case 'x':</a>
<a name="ln249">      execute = true; break;</a>
<a name="ln250">    case '!':</a>
<a name="ln251">      dangerous = true; break;</a>
<a name="ln252">    }</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  if (keys.size == 0 &amp;&amp; !execute) {</a>
<a name="ln256">    return;</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  char *keys_esc;</a>
<a name="ln260">  if (escape_ks) {</a>
<a name="ln261">    // Need to escape K_SPECIAL before putting the string in the</a>
<a name="ln262">    // typeahead buffer.</a>
<a name="ln263">    keys_esc = vim_strsave_escape_ks(keys.data);</a>
<a name="ln264">  } else {</a>
<a name="ln265">    keys_esc = keys.data;</a>
<a name="ln266">  }</a>
<a name="ln267">  ins_typebuf(keys_esc, (remap ? REMAP_YES : REMAP_NONE),</a>
<a name="ln268">              insert ? 0 : typebuf.tb_len, !typed, false);</a>
<a name="ln269">  if (vgetc_busy) {</a>
<a name="ln270">    typebuf_was_filled = true;</a>
<a name="ln271">  }</a>
<a name="ln272"> </a>
<a name="ln273">  if (escape_ks) {</a>
<a name="ln274">    xfree(keys_esc);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  if (execute) {</a>
<a name="ln278">    int save_msg_scroll = msg_scroll;</a>
<a name="ln279"> </a>
<a name="ln280">    // Avoid a 1 second delay when the keys start Insert mode.</a>
<a name="ln281">    msg_scroll = false;</a>
<a name="ln282">    if (!dangerous) {</a>
<a name="ln283">      ex_normal_busy++;</a>
<a name="ln284">    }</a>
<a name="ln285">    exec_normal(true);</a>
<a name="ln286">    if (!dangerous) {</a>
<a name="ln287">      ex_normal_busy--;</a>
<a name="ln288">    }</a>
<a name="ln289">    msg_scroll |= save_msg_scroll;</a>
<a name="ln290">  }</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">/// Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a low-level</a>
<a name="ln294">/// input buffer and the call is non-blocking (input is processed</a>
<a name="ln295">/// asynchronously by the eventloop).</a>
<a name="ln296">///</a>
<a name="ln297">/// On execution error: does not fail, but updates v:errmsg.</a>
<a name="ln298">///</a>
<a name="ln299">/// @note |keycodes| like &lt;CR&gt; are translated, so &quot;&lt;&quot; is special.</a>
<a name="ln300">///       To input a literal &quot;&lt;&quot;, send &lt;LT&gt;.</a>
<a name="ln301">///</a>
<a name="ln302">/// @note For mouse events use |nvim_input_mouse()|. The pseudokey form</a>
<a name="ln303">///       &quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot; is deprecated since |api-level| 6.</a>
<a name="ln304">///</a>
<a name="ln305">/// @param keys to be typed</a>
<a name="ln306">/// @return Number of bytes actually written (can be fewer than</a>
<a name="ln307">///         requested if the buffer becomes full).</a>
<a name="ln308">Integer nvim_input(String keys)</a>
<a name="ln309">  FUNC_API_SINCE(1) FUNC_API_FAST</a>
<a name="ln310">{</a>
<a name="ln311">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln312">  return (Integer)input_enqueue(keys);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">/// Send mouse event from GUI.</a>
<a name="ln316">///</a>
<a name="ln317">/// Non-blocking: does not wait on any result, but queues the event to be</a>
<a name="ln318">/// processed soon by the event loop.</a>
<a name="ln319">///</a>
<a name="ln320">/// @note Currently this doesn't support &quot;scripting&quot; multiple mouse events</a>
<a name="ln321">///       by calling it multiple times in a loop: the intermediate mouse</a>
<a name="ln322">///       positions will be ignored. It should be used to implement real-time</a>
<a name="ln323">///       mouse input in a GUI. The deprecated pseudokey form</a>
<a name="ln324">///       (&quot;&lt;LeftMouse&gt;&lt;col,row&gt;&quot;) of |nvim_input()| has the same limitation.</a>
<a name="ln325">///</a>
<a name="ln326">/// @param button Mouse button: one of &quot;left&quot;, &quot;right&quot;, &quot;middle&quot;, &quot;wheel&quot;, &quot;move&quot;.</a>
<a name="ln327">/// @param action For ordinary buttons, one of &quot;press&quot;, &quot;drag&quot;, &quot;release&quot;.</a>
<a name="ln328">///               For the wheel, one of &quot;up&quot;, &quot;down&quot;, &quot;left&quot;, &quot;right&quot;. Ignored for &quot;move&quot;.</a>
<a name="ln329">/// @param modifier String of modifiers each represented by a single char.</a>
<a name="ln330">///                 The same specifiers are used as for a key press, except</a>
<a name="ln331">///                 that the &quot;-&quot; separator is optional, so &quot;C-A-&quot;, &quot;c-a&quot;</a>
<a name="ln332">///                 and &quot;CA&quot; can all be used to specify Ctrl+Alt+click.</a>
<a name="ln333">/// @param grid Grid number if the client uses |ui-multigrid|, else 0.</a>
<a name="ln334">/// @param row Mouse row-position (zero-based, like redraw events)</a>
<a name="ln335">/// @param col Mouse column-position (zero-based, like redraw events)</a>
<a name="ln336">/// @param[out] err Error details, if any</a>
<a name="ln337">void nvim_input_mouse(String button, String action, String modifier, Integer grid, Integer row,</a>
<a name="ln338">                      Integer col, Error *err)</a>
<a name="ln339">  FUNC_API_SINCE(6) FUNC_API_FAST</a>
<a name="ln340">{</a>
<a name="ln341">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln342"> </a>
<a name="ln343">  if (button.data == NULL || action.data == NULL) {</a>
<a name="ln344">    goto error;</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  int code = 0;</a>
<a name="ln348"> </a>
<a name="ln349">  if (strequal(button.data, &quot;left&quot;)) {</a>
<a name="ln350">    code = KE_LEFTMOUSE;</a>
<a name="ln351">  } else if (strequal(button.data, &quot;middle&quot;)) {</a>
<a name="ln352">    code = KE_MIDDLEMOUSE;</a>
<a name="ln353">  } else if (strequal(button.data, &quot;right&quot;)) {</a>
<a name="ln354">    code = KE_RIGHTMOUSE;</a>
<a name="ln355">  } else if (strequal(button.data, &quot;wheel&quot;)) {</a>
<a name="ln356">    code = KE_MOUSEDOWN;</a>
<a name="ln357">  } else if (strequal(button.data, &quot;move&quot;)) {</a>
<a name="ln358">    code = KE_MOUSEMOVE;</a>
<a name="ln359">  } else {</a>
<a name="ln360">    goto error;</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  if (code == KE_MOUSEDOWN) {</a>
<a name="ln364">    if (strequal(action.data, &quot;down&quot;)) {</a>
<a name="ln365">      code = KE_MOUSEUP;</a>
<a name="ln366">    } else if (strequal(action.data, &quot;up&quot;)) {</a>
<a name="ln367">      // code = KE_MOUSEDOWN</a>
<a name="ln368">    } else if (strequal(action.data, &quot;left&quot;)) {</a>
<a name="ln369">      code = KE_MOUSERIGHT;</a>
<a name="ln370">    } else if (strequal(action.data, &quot;right&quot;)) {</a>
<a name="ln371">      code = KE_MOUSELEFT;</a>
<a name="ln372">    } else {</a>
<a name="ln373">      goto error;</a>
<a name="ln374">    }</a>
<a name="ln375">  } else if (code != KE_MOUSEMOVE) {</a>
<a name="ln376">    if (strequal(action.data, &quot;press&quot;)) {</a>
<a name="ln377">      // pass</a>
<a name="ln378">    } else if (strequal(action.data, &quot;drag&quot;)) {</a>
<a name="ln379">      code += KE_LEFTDRAG - KE_LEFTMOUSE;</a>
<a name="ln380">    } else if (strequal(action.data, &quot;release&quot;)) {</a>
<a name="ln381">      code += KE_LEFTRELEASE - KE_LEFTMOUSE;</a>
<a name="ln382">    } else {</a>
<a name="ln383">      goto error;</a>
<a name="ln384">    }</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  int modmask = 0;</a>
<a name="ln388">  for (size_t i = 0; i &lt; modifier.size; i++) {</a>
<a name="ln389">    char byte = modifier.data[i];</a>
<a name="ln390">    if (byte == '-') {</a>
<a name="ln391">      continue;</a>
<a name="ln392">    }</a>
<a name="ln393">    int mod = name_to_mod_mask(byte);</a>
<a name="ln394">    VALIDATE((mod != 0), &quot;Invalid modifier: %c&quot;, byte, {</a>
<a name="ln395">      return;</a>
<a name="ln396">    });</a>
<a name="ln397">    modmask |= mod;</a>
<a name="ln398">  }</a>
<a name="ln399"> </a>
<a name="ln400">  input_enqueue_mouse(code, (uint8_t)modmask, (int)grid, (int)row, (int)col);</a>
<a name="ln401">  return;</a>
<a name="ln402"> </a>
<a name="ln403">error:</a>
<a name="ln404">  api_set_error(err, kErrorTypeValidation,</a>
<a name="ln405">                &quot;invalid button or action&quot;);</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">/// Replaces terminal codes and |keycodes| (&lt;CR&gt;, &lt;Esc&gt;, ...) in a string with</a>
<a name="ln409">/// the internal representation.</a>
<a name="ln410">///</a>
<a name="ln411">/// @param str        String to be converted.</a>
<a name="ln412">/// @param from_part  Legacy Vim parameter. Usually true.</a>
<a name="ln413">/// @param do_lt      Also translate &lt;lt&gt;. Ignored if `special` is false.</a>
<a name="ln414">/// @param special    Replace |keycodes|, e.g. &lt;CR&gt; becomes a &quot;\r&quot; char.</a>
<a name="ln415">/// @see replace_termcodes</a>
<a name="ln416">/// @see cpoptions</a>
<a name="ln417">String nvim_replace_termcodes(String str, Boolean from_part, Boolean do_lt, Boolean special)</a>
<a name="ln418">  FUNC_API_SINCE(1)</a>
<a name="ln419">{</a>
<a name="ln420">  if (str.size == 0) {</a>
<a name="ln421">    // Empty string</a>
<a name="ln422">    return (String) { .data = NULL, .size = 0 };</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  int flags = 0;</a>
<a name="ln426">  if (from_part) {</a>
<a name="ln427">    flags |= REPTERM_FROM_PART;</a>
<a name="ln428">  }</a>
<a name="ln429">  if (do_lt) {</a>
<a name="ln430">    flags |= REPTERM_DO_LT;</a>
<a name="ln431">  }</a>
<a name="ln432">  if (!special) {</a>
<a name="ln433">    flags |= REPTERM_NO_SPECIAL;</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  char *ptr = NULL;</a>
<a name="ln437">  replace_termcodes(str.data, str.size, &amp;ptr, 0, flags, NULL, CPO_TO_CPO_FLAGS);</a>
<a name="ln438">  return cstr_as_string(ptr);</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/// Execute Lua code. Parameters (if any) are available as `...` inside the</a>
<a name="ln442">/// chunk. The chunk can return a value.</a>
<a name="ln443">///</a>
<a name="ln444">/// Only statements are executed. To evaluate an expression, prefix it</a>
<a name="ln445">/// with `return`: return my_function(...)</a>
<a name="ln446">///</a>
<a name="ln447">/// @param code       Lua code to execute</a>
<a name="ln448">/// @param args       Arguments to the code</a>
<a name="ln449">/// @param[out] err   Details of an error encountered while parsing</a>
<a name="ln450">///                   or executing the Lua code.</a>
<a name="ln451">///</a>
<a name="ln452">/// @return           Return value of Lua code if present or NIL.</a>
<a name="ln453">Object nvim_exec_lua(String code, Array args, Error *err)</a>
<a name="ln454">  FUNC_API_SINCE(7)</a>
<a name="ln455">  FUNC_API_REMOTE_ONLY</a>
<a name="ln456">{</a>
<a name="ln457">  return nlua_exec(code, args, err);</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/// Notify the user with a message</a>
<a name="ln461">///</a>
<a name="ln462">/// Relays the call to vim.notify . By default forwards your message in the</a>
<a name="ln463">/// echo area but can be overridden to trigger desktop notifications.</a>
<a name="ln464">///</a>
<a name="ln465">/// @param msg        Message to display to the user</a>
<a name="ln466">/// @param log_level  The log level</a>
<a name="ln467">/// @param opts       Reserved for future use.</a>
<a name="ln468">/// @param[out] err   Error details, if any</a>
<a name="ln469">Object nvim_notify(String msg, Integer log_level, Dictionary opts, Error *err)</a>
<a name="ln470">  FUNC_API_SINCE(7)</a>
<a name="ln471">{</a>
<a name="ln472">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln473">  ADD_C(args, STRING_OBJ(msg));</a>
<a name="ln474">  ADD_C(args, INTEGER_OBJ(log_level));</a>
<a name="ln475">  ADD_C(args, DICTIONARY_OBJ(opts));</a>
<a name="ln476"> </a>
<a name="ln477">  return NLUA_EXEC_STATIC(&quot;return vim.notify(...)&quot;, args, err);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">/// Calculates the number of display cells occupied by `text`.</a>
<a name="ln481">/// Control characters including &lt;Tab&gt; count as one cell.</a>
<a name="ln482">///</a>
<a name="ln483">/// @param text       Some text</a>
<a name="ln484">/// @param[out] err   Error details, if any</a>
<a name="ln485">/// @return Number of cells</a>
<a name="ln486">Integer nvim_strwidth(String text, Error *err)</a>
<a name="ln487">  FUNC_API_SINCE(1)</a>
<a name="ln488">{</a>
<a name="ln489">  VALIDATE_S((text.size &lt;= INT_MAX), &quot;text length&quot;, &quot;(too long)&quot;, {</a>
<a name="ln490">    return 0;</a>
<a name="ln491">  });</a>
<a name="ln492"> </a>
<a name="ln493">  return (Integer)mb_string2cells(text.data);</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">/// Gets the paths contained in |runtime-search-path|.</a>
<a name="ln497">///</a>
<a name="ln498">/// @return List of paths</a>
<a name="ln499">ArrayOf(String) nvim_list_runtime_paths(Error *err)</a>
<a name="ln500">  FUNC_API_SINCE(1)</a>
<a name="ln501">{</a>
<a name="ln502">  return nvim_get_runtime_file(NULL_STRING, true, err);</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">Array nvim__runtime_inspect(void)</a>
<a name="ln506">{</a>
<a name="ln507">  return runtime_inspect();</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">/// Find files in runtime directories</a>
<a name="ln511">///</a>
<a name="ln512">/// &quot;name&quot; can contain wildcards. For example</a>
<a name="ln513">/// nvim_get_runtime_file(&quot;colors/*.vim&quot;, true) will return all color</a>
<a name="ln514">/// scheme files. Always use forward slashes (/) in the search pattern for</a>
<a name="ln515">/// subdirectories regardless of platform.</a>
<a name="ln516">///</a>
<a name="ln517">/// It is not an error to not find any files. An empty array is returned then.</a>
<a name="ln518">///</a>
<a name="ln519">/// @param name pattern of files to search for</a>
<a name="ln520">/// @param all whether to return all matches or only the first</a>
<a name="ln521">/// @return list of absolute paths to the found files</a>
<a name="ln522">ArrayOf(String) nvim_get_runtime_file(String name, Boolean all, Error *err)</a>
<a name="ln523">  FUNC_API_SINCE(7)</a>
<a name="ln524">  FUNC_API_FAST</a>
<a name="ln525">{</a>
<a name="ln526">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln527"> </a>
<a name="ln528">  int flags = DIP_DIRFILE | (all ? DIP_ALL : 0);</a>
<a name="ln529"> </a>
<a name="ln530">  TRY_WRAP(err, {</a>
<a name="ln531">    do_in_runtimepath((name.size ? name.data : &quot;&quot;), flags, find_runtime_cb, &amp;rv);</a>
<a name="ln532">  });</a>
<a name="ln533">  return rv;</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">static bool find_runtime_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln537">{</a>
<a name="ln538">  Array *rv = (Array *)cookie;</a>
<a name="ln539">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln540">    ADD(*rv, CSTR_TO_OBJ(fnames[i]));</a>
<a name="ln541">    if (!all) {</a>
<a name="ln542">      return true;</a>
<a name="ln543">    }</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  return num_fnames &gt; 0;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">String nvim__get_lib_dir(void)</a>
<a name="ln550">{</a>
<a name="ln551">  return cstr_as_string(get_lib_dir());</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">/// Find files in runtime directories</a>
<a name="ln555">///</a>
<a name="ln556">/// @param pat pattern of files to search for</a>
<a name="ln557">/// @param all whether to return all matches or only the first</a>
<a name="ln558">/// @param opts is_lua: only search Lua subdirs</a>
<a name="ln559">/// @return list of absolute paths to the found files</a>
<a name="ln560">ArrayOf(String) nvim__get_runtime(Array pat, Boolean all, Dict(runtime) *opts, Error *err)</a>
<a name="ln561">  FUNC_API_SINCE(8)</a>
<a name="ln562">  FUNC_API_FAST</a>
<a name="ln563">{</a>
<a name="ln564">  VALIDATE((!opts-&gt;do_source || nlua_is_deferred_safe()), &quot;%s&quot;, &quot;'do_source' used in fast callback&quot;,</a>
<a name="ln565">           {});</a>
<a name="ln566">  if (ERROR_SET(err)) {</a>
<a name="ln567">    return (Array)ARRAY_DICT_INIT;</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  ArrayOf(String) res = runtime_get_named(opts-&gt;is_lua, pat, all);</a>
<a name="ln571"> </a>
<a name="ln572">  if (opts-&gt;do_source) {</a>
<a name="ln573">    for (size_t i = 0; i &lt; res.size; i++) {</a>
<a name="ln574">      String name = res.items[i].data.string;</a>
<a name="ln575">      (void)do_source(name.data, false, DOSO_NONE, NULL);</a>
<a name="ln576">    }</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  return res;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">/// Changes the global working directory.</a>
<a name="ln583">///</a>
<a name="ln584">/// @param dir      Directory path</a>
<a name="ln585">/// @param[out] err Error details, if any</a>
<a name="ln586">void nvim_set_current_dir(String dir, Error *err)</a>
<a name="ln587">  FUNC_API_SINCE(1)</a>
<a name="ln588">{</a>
<a name="ln589">  VALIDATE_S((dir.size &lt; MAXPATHL), &quot;directory name&quot;, &quot;(too long)&quot;, {</a>
<a name="ln590">    return;</a>
<a name="ln591">  });</a>
<a name="ln592"> </a>
<a name="ln593">  char string[MAXPATHL];</a>
<a name="ln594">  memcpy(string, dir.data, dir.size);</a>
<a name="ln595">  string[dir.size] = NUL;</a>
<a name="ln596"> </a>
<a name="ln597">  try_start();</a>
<a name="ln598"> </a>
<a name="ln599">  if (!changedir_func(string, kCdScopeGlobal)) {</a>
<a name="ln600">    if (!try_end(err)) {</a>
<a name="ln601">      api_set_error(err, kErrorTypeException, &quot;Failed to change directory&quot;);</a>
<a name="ln602">    }</a>
<a name="ln603">    return;</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  try_end(err);</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/// Gets the current line.</a>
<a name="ln610">///</a>
<a name="ln611">/// @param[out] err Error details, if any</a>
<a name="ln612">/// @return Current line string</a>
<a name="ln613">String nvim_get_current_line(Error *err)</a>
<a name="ln614">  FUNC_API_SINCE(1)</a>
<a name="ln615">{</a>
<a name="ln616">  return buffer_get_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">/// Sets the current line.</a>
<a name="ln620">///</a>
<a name="ln621">/// @param line     Line contents</a>
<a name="ln622">/// @param[out] err Error details, if any</a>
<a name="ln623">void nvim_set_current_line(String line, Error *err)</a>
<a name="ln624">  FUNC_API_SINCE(1)</a>
<a name="ln625">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln626">{</a>
<a name="ln627">  buffer_set_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, line, err);</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">/// Deletes the current line.</a>
<a name="ln631">///</a>
<a name="ln632">/// @param[out] err Error details, if any</a>
<a name="ln633">void nvim_del_current_line(Error *err)</a>
<a name="ln634">  FUNC_API_SINCE(1)</a>
<a name="ln635">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln636">{</a>
<a name="ln637">  buffer_del_line(curbuf-&gt;handle, curwin-&gt;w_cursor.lnum - 1, err);</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">/// Gets a global (g:) variable.</a>
<a name="ln641">///</a>
<a name="ln642">/// @param name     Variable name</a>
<a name="ln643">/// @param[out] err Error details, if any</a>
<a name="ln644">/// @return Variable value</a>
<a name="ln645">Object nvim_get_var(String name, Error *err)</a>
<a name="ln646">  FUNC_API_SINCE(1)</a>
<a name="ln647">{</a>
<a name="ln648">  dictitem_T *di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln649">  if (di == NULL) {  // try to autoload script</a>
<a name="ln650">    bool found = script_autoload(name.data, name.size, false) &amp;&amp; !aborting();</a>
<a name="ln651">    VALIDATE(found, &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln652">      return (Object)OBJECT_INIT;</a>
<a name="ln653">    });</a>
<a name="ln654">    di = tv_dict_find(&amp;globvardict, name.data, (ptrdiff_t)name.size);</a>
<a name="ln655">  }</a>
<a name="ln656">  VALIDATE((di != NULL), &quot;Key not found: %s&quot;, name.data, {</a>
<a name="ln657">    return (Object)OBJECT_INIT;</a>
<a name="ln658">  });</a>
<a name="ln659">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">/// Sets a global (g:) variable.</a>
<a name="ln663">///</a>
<a name="ln664">/// @param name     Variable name</a>
<a name="ln665">/// @param value    Variable value</a>
<a name="ln666">/// @param[out] err Error details, if any</a>
<a name="ln667">void nvim_set_var(String name, Object value, Error *err)</a>
<a name="ln668">  FUNC_API_SINCE(1)</a>
<a name="ln669">{</a>
<a name="ln670">  dict_set_var(&amp;globvardict, name, value, false, false, err);</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">/// Removes a global (g:) variable.</a>
<a name="ln674">///</a>
<a name="ln675">/// @param name     Variable name</a>
<a name="ln676">/// @param[out] err Error details, if any</a>
<a name="ln677">void nvim_del_var(String name, Error *err)</a>
<a name="ln678">  FUNC_API_SINCE(1)</a>
<a name="ln679">{</a>
<a name="ln680">  dict_set_var(&amp;globvardict, name, NIL, true, false, err);</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">/// Gets a v: variable.</a>
<a name="ln684">///</a>
<a name="ln685">/// @param name     Variable name</a>
<a name="ln686">/// @param[out] err Error details, if any</a>
<a name="ln687">/// @return         Variable value</a>
<a name="ln688">Object nvim_get_vvar(String name, Error *err)</a>
<a name="ln689">  FUNC_API_SINCE(1)</a>
<a name="ln690">{</a>
<a name="ln691">  return dict_get_value(&amp;vimvardict, name, err);</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">/// Sets a v: variable, if it is not readonly.</a>
<a name="ln695">///</a>
<a name="ln696">/// @param name     Variable name</a>
<a name="ln697">/// @param value    Variable value</a>
<a name="ln698">/// @param[out] err Error details, if any</a>
<a name="ln699">void nvim_set_vvar(String name, Object value, Error *err)</a>
<a name="ln700">  FUNC_API_SINCE(6)</a>
<a name="ln701">{</a>
<a name="ln702">  dict_set_var(&amp;vimvardict, name, value, false, false, err);</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/// Echo a message.</a>
<a name="ln706">///</a>
<a name="ln707">/// @param chunks  A list of [text, hl_group] arrays, each representing a</a>
<a name="ln708">///                text chunk with specified highlight. `hl_group` element</a>
<a name="ln709">///                can be omitted for no highlight.</a>
<a name="ln710">/// @param history  if true, add to |message-history|.</a>
<a name="ln711">/// @param opts  Optional parameters.</a>
<a name="ln712">///          - verbose: Message was printed as a result of 'verbose' option</a>
<a name="ln713">///            if Nvim was invoked with -V3log_file, the message will be</a>
<a name="ln714">///            redirected to the log_file and suppressed from direct output.</a>
<a name="ln715">void nvim_echo(Array chunks, Boolean history, Dict(echo_opts) *opts, Error *err)</a>
<a name="ln716">  FUNC_API_SINCE(7)</a>
<a name="ln717">{</a>
<a name="ln718">  HlMessage hl_msg = parse_hl_msg(chunks, err);</a>
<a name="ln719">  if (ERROR_SET(err)) {</a>
<a name="ln720">    goto error;</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  if (opts-&gt;verbose) {</a>
<a name="ln724">    verbose_enter();</a>
<a name="ln725">  }</a>
<a name="ln726"> </a>
<a name="ln727">  msg_multiattr(hl_msg, history ? &quot;echomsg&quot; : &quot;echo&quot;, history);</a>
<a name="ln728"> </a>
<a name="ln729">  if (opts-&gt;verbose) {</a>
<a name="ln730">    verbose_leave();</a>
<a name="ln731">    verbose_stop();  // flush now</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  if (history) {</a>
<a name="ln735">    // history takes ownership</a>
<a name="ln736">    return;</a>
<a name="ln737">  }</a>
<a name="ln738"> </a>
<a name="ln739">error:</a>
<a name="ln740">  hl_msg_free(hl_msg);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// Writes a message to the Vim output buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln744">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln745">///</a>
<a name="ln746">/// @param str Message</a>
<a name="ln747">void nvim_out_write(String str)</a>
<a name="ln748">  FUNC_API_SINCE(1)</a>
<a name="ln749">{</a>
<a name="ln750">  write_msg(str, false, false);</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">/// Writes a message to the Vim error buffer. Does not append &quot;\n&quot;, the</a>
<a name="ln754">/// message is buffered (won't display) until a linefeed is written.</a>
<a name="ln755">///</a>
<a name="ln756">/// @param str Message</a>
<a name="ln757">void nvim_err_write(String str)</a>
<a name="ln758">  FUNC_API_SINCE(1)</a>
<a name="ln759">{</a>
<a name="ln760">  write_msg(str, true, false);</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">/// Writes a message to the Vim error buffer. Appends &quot;\n&quot;, so the buffer is</a>
<a name="ln764">/// flushed (and displayed).</a>
<a name="ln765">///</a>
<a name="ln766">/// @param str Message</a>
<a name="ln767">/// @see nvim_err_write()</a>
<a name="ln768">void nvim_err_writeln(String str)</a>
<a name="ln769">  FUNC_API_SINCE(1)</a>
<a name="ln770">{</a>
<a name="ln771">  write_msg(str, true, true);</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">/// Gets the current list of buffer handles</a>
<a name="ln775">///</a>
<a name="ln776">/// Includes unlisted (unloaded/deleted) buffers, like `:ls!`.</a>
<a name="ln777">/// Use |nvim_buf_is_loaded()| to check if a buffer is loaded.</a>
<a name="ln778">///</a>
<a name="ln779">/// @return List of buffer handles</a>
<a name="ln780">ArrayOf(Buffer) nvim_list_bufs(void)</a>
<a name="ln781">  FUNC_API_SINCE(1)</a>
<a name="ln782">{</a>
<a name="ln783">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln784"> </a>
<a name="ln785">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln786">    rv.size++;</a>
<a name="ln787">  }</a>
<a name="ln788"> </a>
<a name="ln789">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln790">  size_t i = 0;</a>
<a name="ln791"> </a>
<a name="ln792">  FOR_ALL_BUFFERS(b) {</a>
<a name="ln793">    rv.items[i++] = BUFFER_OBJ(b-&gt;handle);</a>
<a name="ln794">  }</a>
<a name="ln795"> </a>
<a name="ln796">  return rv;</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">/// Gets the current buffer.</a>
<a name="ln800">///</a>
<a name="ln801">/// @return Buffer handle</a>
<a name="ln802">Buffer nvim_get_current_buf(void)</a>
<a name="ln803">  FUNC_API_SINCE(1)</a>
<a name="ln804">{</a>
<a name="ln805">  return curbuf-&gt;handle;</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">/// Sets the current buffer.</a>
<a name="ln809">///</a>
<a name="ln810">/// @param buffer   Buffer handle</a>
<a name="ln811">/// @param[out] err Error details, if any</a>
<a name="ln812">void nvim_set_current_buf(Buffer buffer, Error *err)</a>
<a name="ln813">  FUNC_API_SINCE(1)</a>
<a name="ln814">  FUNC_API_TEXTLOCK</a>
<a name="ln815">{</a>
<a name="ln816">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln817"> </a>
<a name="ln818">  if (!buf) {</a>
<a name="ln819">    return;</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  try_start();</a>
<a name="ln823">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum, 0);</a>
<a name="ln824">  if (!try_end(err) &amp;&amp; result == FAIL) {</a>
<a name="ln825">    api_set_error(err,</a>
<a name="ln826">                  kErrorTypeException,</a>
<a name="ln827">                  &quot;Failed to switch to buffer %d&quot;,</a>
<a name="ln828">                  buffer);</a>
<a name="ln829">  }</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/// Gets the current list of window handles.</a>
<a name="ln833">///</a>
<a name="ln834">/// @return List of window handles</a>
<a name="ln835">ArrayOf(Window) nvim_list_wins(void)</a>
<a name="ln836">  FUNC_API_SINCE(1)</a>
<a name="ln837">{</a>
<a name="ln838">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln839"> </a>
<a name="ln840">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln841">    rv.size++;</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln845">  size_t i = 0;</a>
<a name="ln846"> </a>
<a name="ln847">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln848">    rv.items[i++] = WINDOW_OBJ(wp-&gt;handle);</a>
<a name="ln849">  }</a>
<a name="ln850"> </a>
<a name="ln851">  return rv;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">/// Gets the current window.</a>
<a name="ln855">///</a>
<a name="ln856">/// @return Window handle</a>
<a name="ln857">Window nvim_get_current_win(void)</a>
<a name="ln858">  FUNC_API_SINCE(1)</a>
<a name="ln859">{</a>
<a name="ln860">  return curwin-&gt;handle;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/// Sets the current window.</a>
<a name="ln864">///</a>
<a name="ln865">/// @param window Window handle</a>
<a name="ln866">/// @param[out] err Error details, if any</a>
<a name="ln867">void nvim_set_current_win(Window window, Error *err)</a>
<a name="ln868">  FUNC_API_SINCE(1)</a>
<a name="ln869">  FUNC_API_TEXTLOCK</a>
<a name="ln870">{</a>
<a name="ln871">  win_T *win = find_window_by_handle(window, err);</a>
<a name="ln872"> </a>
<a name="ln873">  if (!win) {</a>
<a name="ln874">    return;</a>
<a name="ln875">  }</a>
<a name="ln876"> </a>
<a name="ln877">  try_start();</a>
<a name="ln878">  goto_tabpage_win(win_find_tabpage(win), win);</a>
<a name="ln879">  if (!try_end(err) &amp;&amp; win != curwin) {</a>
<a name="ln880">    api_set_error(err,</a>
<a name="ln881">                  kErrorTypeException,</a>
<a name="ln882">                  &quot;Failed to switch to window %d&quot;,</a>
<a name="ln883">                  window);</a>
<a name="ln884">  }</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">/// Creates a new, empty, unnamed buffer.</a>
<a name="ln888">///</a>
<a name="ln889">/// @param listed Sets 'buflisted'</a>
<a name="ln890">/// @param scratch Creates a &quot;throwaway&quot; |scratch-buffer| for temporary work</a>
<a name="ln891">///                (always 'nomodified'). Also sets 'nomodeline' on the buffer.</a>
<a name="ln892">/// @param[out] err Error details, if any</a>
<a name="ln893">/// @return Buffer handle, or 0 on error</a>
<a name="ln894">///</a>
<a name="ln895">/// @see buf_open_scratch</a>
<a name="ln896">Buffer nvim_create_buf(Boolean listed, Boolean scratch, Error *err)</a>
<a name="ln897">  FUNC_API_SINCE(6)</a>
<a name="ln898">{</a>
<a name="ln899">  try_start();</a>
<a name="ln900">  buf_T *buf = buflist_new(NULL, NULL, (linenr_T)0,</a>
<a name="ln901">                           BLN_NOOPT | BLN_NEW | (listed ? BLN_LISTED : 0));</a>
<a name="ln902">  try_end(err);</a>
<a name="ln903">  if (buf == NULL) {</a>
<a name="ln904">    goto fail;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  // Open the memline for the buffer. This will avoid spurious autocmds when</a>
<a name="ln908">  // a later nvim_buf_set_lines call would have needed to &quot;open&quot; the buffer.</a>
<a name="ln909">  try_start();</a>
<a name="ln910">  block_autocmds();</a>
<a name="ln911">  int status = ml_open(buf);</a>
<a name="ln912">  unblock_autocmds();</a>
<a name="ln913">  try_end(err);</a>
<a name="ln914">  if (status == FAIL) {</a>
<a name="ln915">    goto fail;</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  // Only strictly needed for scratch, but could just as well be consistent</a>
<a name="ln919">  // and do this now. buffer is created NOW, not when it latter first happen</a>
<a name="ln920">  // to reach a window or aucmd_prepbuf() ..</a>
<a name="ln921">  buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln922"> </a>
<a name="ln923">  if (scratch) {</a>
<a name="ln924">    set_string_option_direct_in_buf(buf, &quot;bufhidden&quot;, -1, &quot;hide&quot;, OPT_LOCAL, 0);</a>
<a name="ln925">    set_string_option_direct_in_buf(buf, &quot;buftype&quot;, -1, &quot;nofile&quot;, OPT_LOCAL, 0);</a>
<a name="ln926">    assert(buf-&gt;b_ml.ml_mfp-&gt;mf_fd &lt; 0);  // ml_open() should not have opened swapfile already</a>
<a name="ln927">    buf-&gt;b_p_swf = false;</a>
<a name="ln928">    buf-&gt;b_p_ml = false;</a>
<a name="ln929">  }</a>
<a name="ln930">  return buf-&gt;b_fnum;</a>
<a name="ln931"> </a>
<a name="ln932">fail:</a>
<a name="ln933">  if (!ERROR_SET(err)) {</a>
<a name="ln934">    api_set_error(err, kErrorTypeException, &quot;Failed to create buffer&quot;);</a>
<a name="ln935">  }</a>
<a name="ln936">  return 0;</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">/// Open a terminal instance in a buffer</a>
<a name="ln940">///</a>
<a name="ln941">/// By default (and currently the only option) the terminal will not be</a>
<a name="ln942">/// connected to an external process. Instead, input send on the channel</a>
<a name="ln943">/// will be echoed directly by the terminal. This is useful to display</a>
<a name="ln944">/// ANSI terminal sequences returned as part of a rpc message, or similar.</a>
<a name="ln945">///</a>
<a name="ln946">/// Note: to directly initiate the terminal using the right size, display the</a>
<a name="ln947">/// buffer in a configured window before calling this. For instance, for a</a>
<a name="ln948">/// floating display, first create an empty buffer using |nvim_create_buf()|,</a>
<a name="ln949">/// then display it using |nvim_open_win()|, and then  call this function.</a>
<a name="ln950">/// Then |nvim_chan_send()| can be called immediately to process sequences</a>
<a name="ln951">/// in a virtual terminal having the intended size.</a>
<a name="ln952">///</a>
<a name="ln953">/// @param buffer the buffer to use (expected to be empty)</a>
<a name="ln954">/// @param opts   Optional parameters.</a>
<a name="ln955">///          - on_input: Lua callback for input sent, i e keypresses in terminal</a>
<a name="ln956">///            mode. Note: keypresses are sent raw as they would be to the pty</a>
<a name="ln957">///            master end. For instance, a carriage return is sent</a>
<a name="ln958">///            as a &quot;\r&quot;, not as a &quot;\n&quot;. |textlock| applies. It is possible</a>
<a name="ln959">///            to call |nvim_chan_send()| directly in the callback however.</a>
<a name="ln960">///                 [&quot;input&quot;, term, bufnr, data]</a>
<a name="ln961">/// @param[out] err Error details, if any</a>
<a name="ln962">/// @return Channel id, or 0 on error</a>
<a name="ln963">Integer nvim_open_term(Buffer buffer, DictionaryOf(LuaRef) opts, Error *err)</a>
<a name="ln964">  FUNC_API_SINCE(7)</a>
<a name="ln965">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln966">{</a>
<a name="ln967">  buf_T *buf = find_buffer_by_handle(buffer, err);</a>
<a name="ln968">  if (!buf) {</a>
<a name="ln969">    return 0;</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  if (cmdwin_type != 0 &amp;&amp; buf == curbuf) {</a>
<a name="ln973">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, e_cmdwin);</a>
<a name="ln974">    return 0;</a>
<a name="ln975">  }</a>
<a name="ln976"> </a>
<a name="ln977">  LuaRef cb = LUA_NOREF;</a>
<a name="ln978">  for (size_t i = 0; i &lt; opts.size; i++) {</a>
<a name="ln979">    String k = opts.items[i].key;</a>
<a name="ln980">    Object *v = &amp;opts.items[i].value;</a>
<a name="ln981">    if (strequal(&quot;on_input&quot;, k.data)) {</a>
<a name="ln982">      VALIDATE_T(&quot;on_input&quot;, kObjectTypeLuaRef, v-&gt;type, {</a>
<a name="ln983">        return 0;</a>
<a name="ln984">      });</a>
<a name="ln985">      cb = v-&gt;data.luaref;</a>
<a name="ln986">      v-&gt;data.luaref = LUA_NOREF;</a>
<a name="ln987">      break;</a>
<a name="ln988">    } else {</a>
<a name="ln989">      VALIDATE_S(false, &quot;'opts' key&quot;, k.data, {});</a>
<a name="ln990">    }</a>
<a name="ln991">  }</a>
<a name="ln992"> </a>
<a name="ln993">  TerminalOptions topts;</a>
<a name="ln994">  Channel *chan = channel_alloc(kChannelStreamInternal);</a>
<a name="ln995">  chan-&gt;stream.internal.cb = cb;</a>
<a name="ln996">  chan-&gt;stream.internal.closed = false;</a>
<a name="ln997">  topts.data = chan;</a>
<a name="ln998">  // NB: overridden in terminal_check_size if a window is already</a>
<a name="ln999">  // displaying the buffer</a>
<a name="ln1000">  topts.width = (uint16_t)MAX(curwin-&gt;w_width_inner - win_col_off(curwin), 0);</a>
<a name="ln1001">  topts.height = (uint16_t)curwin-&gt;w_height_inner;</a>
<a name="ln1002">  topts.write_cb = term_write;</a>
<a name="ln1003">  topts.resize_cb = term_resize;</a>
<a name="ln1004">  topts.close_cb = term_close;</a>
<a name="ln1005">  Terminal *term = terminal_open(buf, topts);</a>
<a name="ln1006">  terminal_check_size(term);</a>
<a name="ln1007">  chan-&gt;term = term;</a>
<a name="ln1008">  return (Integer)chan-&gt;id;</a>
<a name="ln1009">}</a>
<a name="ln1010"> </a>
<a name="ln1011">static void term_write(char *buf, size_t size, void *data)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln1012">{</a>
<a name="ln1013">  Channel *chan = data;</a>
<a name="ln1014">  LuaRef cb = chan-&gt;stream.internal.cb;</a>
<a name="ln1015">  if (cb == LUA_NOREF) {</a>
<a name="ln1016">    return;</a>
<a name="ln1017">  }</a>
<a name="ln1018">  MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln1019">  ADD_C(args, INTEGER_OBJ((Integer)chan-&gt;id));</a>
<a name="ln1020">  ADD_C(args, BUFFER_OBJ(terminal_buf(chan-&gt;term)));</a>
<a name="ln1021">  ADD_C(args, STRING_OBJ(((String){ .data = buf, .size = size })));</a>
<a name="ln1022">  textlock++;</a>
<a name="ln1023">  nlua_call_ref(cb, &quot;input&quot;, args, false, NULL);</a>
<a name="ln1024">  textlock--;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">static void term_resize(uint16_t width, uint16_t height, void *data)</a>
<a name="ln1028">{</a>
<a name="ln1029">  // TODO(bfredl): Lua callback</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">static void term_close(void *data)</a>
<a name="ln1033">{</a>
<a name="ln1034">  Channel *chan = data;</a>
<a name="ln1035">  terminal_destroy(&amp;chan-&gt;term);</a>
<a name="ln1036">  api_free_luaref(chan-&gt;stream.internal.cb);</a>
<a name="ln1037">  chan-&gt;stream.internal.cb = LUA_NOREF;</a>
<a name="ln1038">  channel_decref(chan);</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">/// Send data to channel `id`. For a job, it writes it to the</a>
<a name="ln1042">/// stdin of the process. For the stdio channel |channel-stdio|,</a>
<a name="ln1043">/// it writes to Nvim's stdout.  For an internal terminal instance</a>
<a name="ln1044">/// (|nvim_open_term()|) it writes directly to terminal output.</a>
<a name="ln1045">/// See |channel-bytes| for more information.</a>
<a name="ln1046">///</a>
<a name="ln1047">/// This function writes raw data, not RPC messages.  If the channel</a>
<a name="ln1048">/// was created with `rpc=true` then the channel expects RPC</a>
<a name="ln1049">/// messages, use |vim.rpcnotify()| and |vim.rpcrequest()| instead.</a>
<a name="ln1050">///</a>
<a name="ln1051">/// @param chan id of the channel</a>
<a name="ln1052">/// @param data data to write. 8-bit clean: can contain NUL bytes.</a>
<a name="ln1053">/// @param[out] err Error details, if any</a>
<a name="ln1054">void nvim_chan_send(Integer chan, String data, Error *err)</a>
<a name="ln1055">  FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY FUNC_API_LUA_ONLY</a>
<a name="ln1056">{</a>
<a name="ln1057">  const char *error = NULL;</a>
<a name="ln1058">  if (!data.size) {</a>
<a name="ln1059">    return;</a>
<a name="ln1060">  }</a>
<a name="ln1061"> </a>
<a name="ln1062">  channel_send((uint64_t)chan, data.data, data.size,</a>
<a name="ln1063">               false, &amp;error);</a>
<a name="ln1064">  VALIDATE(!error, &quot;%s&quot;, error, {});</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">/// Gets the current list of tabpage handles.</a>
<a name="ln1068">///</a>
<a name="ln1069">/// @return List of tabpage handles</a>
<a name="ln1070">ArrayOf(Tabpage) nvim_list_tabpages(void)</a>
<a name="ln1071">  FUNC_API_SINCE(1)</a>
<a name="ln1072">{</a>
<a name="ln1073">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln1074"> </a>
<a name="ln1075">  FOR_ALL_TABS(tp) {</a>
<a name="ln1076">    rv.size++;</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">  rv.items = xmalloc(sizeof(Object) * rv.size);</a>
<a name="ln1080">  size_t i = 0;</a>
<a name="ln1081"> </a>
<a name="ln1082">  FOR_ALL_TABS(tp) {</a>
<a name="ln1083">    rv.items[i++] = TABPAGE_OBJ(tp-&gt;handle);</a>
<a name="ln1084">  }</a>
<a name="ln1085"> </a>
<a name="ln1086">  return rv;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">/// Gets the current tabpage.</a>
<a name="ln1090">///</a>
<a name="ln1091">/// @return Tabpage handle</a>
<a name="ln1092">Tabpage nvim_get_current_tabpage(void)</a>
<a name="ln1093">  FUNC_API_SINCE(1)</a>
<a name="ln1094">{</a>
<a name="ln1095">  return curtab-&gt;handle;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/// Sets the current tabpage.</a>
<a name="ln1099">///</a>
<a name="ln1100">/// @param tabpage  Tabpage handle</a>
<a name="ln1101">/// @param[out] err Error details, if any</a>
<a name="ln1102">void nvim_set_current_tabpage(Tabpage tabpage, Error *err)</a>
<a name="ln1103">  FUNC_API_SINCE(1)</a>
<a name="ln1104">  FUNC_API_TEXTLOCK</a>
<a name="ln1105">{</a>
<a name="ln1106">  tabpage_T *tp = find_tab_by_handle(tabpage, err);</a>
<a name="ln1107"> </a>
<a name="ln1108">  if (!tp) {</a>
<a name="ln1109">    return;</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112">  try_start();</a>
<a name="ln1113">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln1114">  if (!try_end(err) &amp;&amp; tp != curtab) {</a>
<a name="ln1115">    api_set_error(err,</a>
<a name="ln1116">                  kErrorTypeException,</a>
<a name="ln1117">                  &quot;Failed to switch to tabpage %d&quot;,</a>
<a name="ln1118">                  tabpage);</a>
<a name="ln1119">  }</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/// Pastes at cursor, in any mode.</a>
<a name="ln1123">///</a>
<a name="ln1124">/// Invokes the `vim.paste` handler, which handles each mode appropriately.</a>
<a name="ln1125">/// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF (&quot;\n&quot;).</a>
<a name="ln1126">///</a>
<a name="ln1127">/// Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`</a>
<a name="ln1128">/// but do not affect the return value (which is strictly decided by</a>
<a name="ln1129">/// `vim.paste()`).  On error, subsequent calls are ignored (&quot;drained&quot;) until</a>
<a name="ln1130">/// the next paste is initiated (phase 1 or -1).</a>
<a name="ln1131">///</a>
<a name="ln1132">/// @param data  Multiline input. May be binary (containing NUL bytes).</a>
<a name="ln1133">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln1134">/// @param phase  -1: paste in a single call (i.e. without streaming).</a>
<a name="ln1135">///               To &quot;stream&quot; a paste, call `nvim_paste` sequentially with</a>
<a name="ln1136">///               these `phase` values:</a>
<a name="ln1137">///                 - 1: starts the paste (exactly once)</a>
<a name="ln1138">///                 - 2: continues the paste (zero or more times)</a>
<a name="ln1139">///                 - 3: ends the paste (exactly once)</a>
<a name="ln1140">/// @param[out] err Error details, if any</a>
<a name="ln1141">/// @return</a>
<a name="ln1142">///     - true: Client may continue pasting.</a>
<a name="ln1143">///     - false: Client must cancel the paste.</a>
<a name="ln1144">Boolean nvim_paste(String data, Boolean crlf, Integer phase, Error *err)</a>
<a name="ln1145">  FUNC_API_SINCE(6)</a>
<a name="ln1146">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1147">{</a>
<a name="ln1148">  static bool draining = false;</a>
<a name="ln1149">  bool cancel = false;</a>
<a name="ln1150"> </a>
<a name="ln1151">  VALIDATE_INT((phase &gt;= -1 &amp;&amp; phase &lt;= 3), &quot;phase&quot;, phase, {</a>
<a name="ln1152">    return false;</a>
<a name="ln1153">  });</a>
<a name="ln1154">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln1155">  Object rv = OBJECT_INIT;</a>
<a name="ln1156">  if (phase == -1 || phase == 1) {  // Start of paste-stream.</a>
<a name="ln1157">    draining = false;</a>
<a name="ln1158">  } else if (draining) {</a>
<a name="ln1159">    // Skip remaining chunks.  Report error only once per &quot;stream&quot;.</a>
<a name="ln1160">    goto theend;</a>
<a name="ln1161">  }</a>
<a name="ln1162">  Array lines = string_to_array(data, crlf);</a>
<a name="ln1163">  ADD(args, ARRAY_OBJ(lines));</a>
<a name="ln1164">  ADD(args, INTEGER_OBJ(phase));</a>
<a name="ln1165">  rv = nvim_exec_lua(STATIC_CSTR_AS_STRING(&quot;return vim.paste(...)&quot;), args,</a>
<a name="ln1166">                     err);</a>
<a name="ln1167">  if (ERROR_SET(err)) {</a>
<a name="ln1168">    draining = true;</a>
<a name="ln1169">    goto theend;</a>
<a name="ln1170">  }</a>
<a name="ln1171">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 1)) {</a>
<a name="ln1172">    ResetRedobuff();</a>
<a name="ln1173">    AppendCharToRedobuff('a');  // Dot-repeat.</a>
<a name="ln1174">  }</a>
<a name="ln1175">  // vim.paste() decides if client should cancel.  Errors do NOT cancel: we</a>
<a name="ln1176">  // want to drain remaining chunks (rather than divert them to main input).</a>
<a name="ln1177">  cancel = (rv.type == kObjectTypeBoolean &amp;&amp; !rv.data.boolean);</a>
<a name="ln1178">  if (!cancel &amp;&amp; !(State &amp; MODE_CMDLINE)) {  // Dot-repeat.</a>
<a name="ln1179">    for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1180">      String s = lines.items[i].data.string;</a>
<a name="ln1181">      assert(s.size &lt;= INT_MAX);</a>
<a name="ln1182">      AppendToRedobuffLit(s.data, (int)s.size);</a>
<a name="ln1183">      // readfile()-style: &quot;\n&quot; is indicated by presence of N+1 item.</a>
<a name="ln1184">      if (i + 1 &lt; lines.size) {</a>
<a name="ln1185">        AppendCharToRedobuff(NL);</a>
<a name="ln1186">      }</a>
<a name="ln1187">    }</a>
<a name="ln1188">  }</a>
<a name="ln1189">  if (!(State &amp; (MODE_CMDLINE | MODE_INSERT)) &amp;&amp; (phase == -1 || phase == 3)) {</a>
<a name="ln1190">    AppendCharToRedobuff(ESC);  // Dot-repeat.</a>
<a name="ln1191">  }</a>
<a name="ln1192">theend:</a>
<a name="ln1193">  api_free_object(rv);</a>
<a name="ln1194">  api_free_array(args);</a>
<a name="ln1195">  if (cancel || phase == -1 || phase == 3) {  // End of paste-stream.</a>
<a name="ln1196">    draining = false;</a>
<a name="ln1197">  }</a>
<a name="ln1198"> </a>
<a name="ln1199">  return !cancel;</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">/// Puts text at cursor, in any mode.</a>
<a name="ln1203">///</a>
<a name="ln1204">/// Compare |:put| and |p| which are always linewise.</a>
<a name="ln1205">///</a>
<a name="ln1206">/// @param lines  |readfile()|-style list of lines. |channel-lines|</a>
<a name="ln1207">/// @param type  Edit behavior: any |getregtype()| result, or:</a>
<a name="ln1208">///              - &quot;b&quot; |blockwise-visual| mode (may include width, e.g. &quot;b3&quot;)</a>
<a name="ln1209">///              - &quot;c&quot; |charwise| mode</a>
<a name="ln1210">///              - &quot;l&quot; |linewise| mode</a>
<a name="ln1211">///              - &quot;&quot;  guess by contents, see |setreg()|</a>
<a name="ln1212">/// @param after  If true insert after cursor (like |p|), or before (like |P|).</a>
<a name="ln1213">/// @param follow  If true place cursor at end of inserted text.</a>
<a name="ln1214">/// @param[out] err Error details, if any</a>
<a name="ln1215">void nvim_put(ArrayOf(String) lines, String type, Boolean after, Boolean follow, Error *err)</a>
<a name="ln1216">  FUNC_API_SINCE(6)</a>
<a name="ln1217">  FUNC_API_TEXTLOCK_ALLOW_CMDWIN</a>
<a name="ln1218">{</a>
<a name="ln1219">  yankreg_T *reg = xcalloc(1, sizeof(yankreg_T));</a>
<a name="ln1220">  VALIDATE_S((prepare_yankreg_from_object(reg, type, lines.size)), &quot;type&quot;, type.data, {</a>
<a name="ln1221">    goto cleanup;</a>
<a name="ln1222">  });</a>
<a name="ln1223">  if (lines.size == 0) {</a>
<a name="ln1224">    goto cleanup;  // Nothing to do.</a>
<a name="ln1225">  }</a>
<a name="ln1226"> </a>
<a name="ln1227">  for (size_t i = 0; i &lt; lines.size; i++) {</a>
<a name="ln1228">    VALIDATE_T(&quot;line&quot;, kObjectTypeString, lines.items[i].type, {</a>
<a name="ln1229">      goto cleanup;</a>
<a name="ln1230">    });</a>
<a name="ln1231">    String line = lines.items[i].data.string;</a>
<a name="ln1232">    reg-&gt;y_array[i] = xmemdupz(line.data, line.size);</a>
<a name="ln1233">    memchrsub(reg-&gt;y_array[i], NUL, NL, line.size);</a>
<a name="ln1234">  }</a>
<a name="ln1235"> </a>
<a name="ln1236">  finish_yankreg_from_object(reg, false);</a>
<a name="ln1237"> </a>
<a name="ln1238">  TRY_WRAP(err, {</a>
<a name="ln1239">    bool VIsual_was_active = VIsual_active;</a>
<a name="ln1240">    msg_silent++;  // Avoid &quot;N more lines&quot; message.</a>
<a name="ln1241">    do_put(0, reg, after ? FORWARD : BACKWARD, 1, follow ? PUT_CURSEND : 0);</a>
<a name="ln1242">    msg_silent--;</a>
<a name="ln1243">    VIsual_active = VIsual_was_active;</a>
<a name="ln1244">  });</a>
<a name="ln1245"> </a>
<a name="ln1246">cleanup:</a>
<a name="ln1247">  free_register(reg);</a>
<a name="ln1248">  xfree(reg);</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">/// Subscribes to event broadcasts.</a>
<a name="ln1252">///</a>
<a name="ln1253">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1254">/// @param event      Event type string</a>
<a name="ln1255">void nvim_subscribe(uint64_t channel_id, String event)</a>
<a name="ln1256">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1257">{</a>
<a name="ln1258">  size_t length = (event.size &lt; METHOD_MAXLEN ? event.size : METHOD_MAXLEN);</a>
<a name="ln1259">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1260">  memcpy(e, event.data, length);</a>
<a name="ln1261">  e[length] = NUL;</a>
<a name="ln1262">  rpc_subscribe(channel_id, e);</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">/// Unsubscribes to event broadcasts.</a>
<a name="ln1266">///</a>
<a name="ln1267">/// @param channel_id Channel id (passed automatically by the dispatcher)</a>
<a name="ln1268">/// @param event      Event type string</a>
<a name="ln1269">void nvim_unsubscribe(uint64_t channel_id, String event)</a>
<a name="ln1270">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1271">{</a>
<a name="ln1272">  size_t length = (event.size &lt; METHOD_MAXLEN ?</a>
<a name="ln1273">                   event.size :</a>
<a name="ln1274">                   METHOD_MAXLEN);</a>
<a name="ln1275">  char e[METHOD_MAXLEN + 1];</a>
<a name="ln1276">  memcpy(e, event.data, length);</a>
<a name="ln1277">  e[length] = NUL;</a>
<a name="ln1278">  rpc_unsubscribe(channel_id, e);</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">/// Returns the 24-bit RGB value of a |nvim_get_color_map()| color name or</a>
<a name="ln1282">/// &quot;#rrggbb&quot; hexadecimal string.</a>
<a name="ln1283">///</a>
<a name="ln1284">/// Example:</a>
<a name="ln1285">///</a>
<a name="ln1286">/// ```vim</a>
<a name="ln1287">/// :echo nvim_get_color_by_name(&quot;Pink&quot;)</a>
<a name="ln1288">/// :echo nvim_get_color_by_name(&quot;#cbcbcb&quot;)</a>
<a name="ln1289">/// ```</a>
<a name="ln1290">///</a>
<a name="ln1291">/// @param name Color name or &quot;#rrggbb&quot; string</a>
<a name="ln1292">/// @return 24-bit RGB value, or -1 for invalid argument.</a>
<a name="ln1293">Integer nvim_get_color_by_name(String name)</a>
<a name="ln1294">  FUNC_API_SINCE(1)</a>
<a name="ln1295">{</a>
<a name="ln1296">  int dummy;</a>
<a name="ln1297">  return name_to_color(name.data, &amp;dummy);</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300">/// Returns a map of color names and RGB values.</a>
<a name="ln1301">///</a>
<a name="ln1302">/// Keys are color names (e.g. &quot;Aqua&quot;) and values are 24-bit RGB color values</a>
<a name="ln1303">/// (e.g. 65535).</a>
<a name="ln1304">///</a>
<a name="ln1305">/// @return Map of color names and RGB values.</a>
<a name="ln1306">Dictionary nvim_get_color_map(void)</a>
<a name="ln1307">  FUNC_API_SINCE(1)</a>
<a name="ln1308">{</a>
<a name="ln1309">  Dictionary colors = ARRAY_DICT_INIT;</a>
<a name="ln1310"> </a>
<a name="ln1311">  for (int i = 0; color_name_table[i].name != NULL; i++) {</a>
<a name="ln1312">    PUT(colors, color_name_table[i].name,</a>
<a name="ln1313">        INTEGER_OBJ(color_name_table[i].color));</a>
<a name="ln1314">  }</a>
<a name="ln1315">  return colors;</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">/// Gets a map of the current editor state.</a>
<a name="ln1319">///</a>
<a name="ln1320">/// @param opts  Optional parameters.</a>
<a name="ln1321">///               - types:  List of |context-types| (&quot;regs&quot;, &quot;jumps&quot;, &quot;bufs&quot;,</a>
<a name="ln1322">///                 &quot;gvars&quot;, …) to gather, or empty for &quot;all&quot;.</a>
<a name="ln1323">/// @param[out]  err  Error details, if any</a>
<a name="ln1324">///</a>
<a name="ln1325">/// @return map of global |context|.</a>
<a name="ln1326">Dictionary nvim_get_context(Dict(context) *opts, Error *err)</a>
<a name="ln1327">  FUNC_API_SINCE(6)</a>
<a name="ln1328">{</a>
<a name="ln1329">  Array types = ARRAY_DICT_INIT;</a>
<a name="ln1330">  if (HAS_KEY(opts, context, types)) {</a>
<a name="ln1331">    types = opts-&gt;types;</a>
<a name="ln1332">  }</a>
<a name="ln1333"> </a>
<a name="ln1334">  int int_types = types.size &gt; 0 ? 0 : kCtxAll;</a>
<a name="ln1335">  if (types.size &gt; 0) {</a>
<a name="ln1336">    for (size_t i = 0; i &lt; types.size; i++) {</a>
<a name="ln1337">      if (types.items[i].type == kObjectTypeString) {</a>
<a name="ln1338">        const char *const s = types.items[i].data.string.data;</a>
<a name="ln1339">        if (strequal(s, &quot;regs&quot;)) {</a>
<a name="ln1340">          int_types |= kCtxRegs;</a>
<a name="ln1341">        } else if (strequal(s, &quot;jumps&quot;)) {</a>
<a name="ln1342">          int_types |= kCtxJumps;</a>
<a name="ln1343">        } else if (strequal(s, &quot;bufs&quot;)) {</a>
<a name="ln1344">          int_types |= kCtxBufs;</a>
<a name="ln1345">        } else if (strequal(s, &quot;gvars&quot;)) {</a>
<a name="ln1346">          int_types |= kCtxGVars;</a>
<a name="ln1347">        } else if (strequal(s, &quot;sfuncs&quot;)) {</a>
<a name="ln1348">          int_types |= kCtxSFuncs;</a>
<a name="ln1349">        } else if (strequal(s, &quot;funcs&quot;)) {</a>
<a name="ln1350">          int_types |= kCtxFuncs;</a>
<a name="ln1351">        } else {</a>
<a name="ln1352">          VALIDATE_S(false, &quot;type&quot;, s, {</a>
<a name="ln1353">            return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1354">          });</a>
<a name="ln1355">        }</a>
<a name="ln1356">      }</a>
<a name="ln1357">    }</a>
<a name="ln1358">  }</a>
<a name="ln1359"> </a>
<a name="ln1360">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1361">  ctx_save(&amp;ctx, int_types);</a>
<a name="ln1362">  Dictionary dict = ctx_to_dict(&amp;ctx);</a>
<a name="ln1363">  ctx_free(&amp;ctx);</a>
<a name="ln1364">  return dict;</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">/// Sets the current editor state from the given |context| map.</a>
<a name="ln1368">///</a>
<a name="ln1369">/// @param  dict  |Context| map.</a>
<a name="ln1370">Object nvim_load_context(Dictionary dict)</a>
<a name="ln1371">  FUNC_API_SINCE(6)</a>
<a name="ln1372">{</a>
<a name="ln1373">  Context ctx = CONTEXT_INIT;</a>
<a name="ln1374"> </a>
<a name="ln1375">  int save_did_emsg = did_emsg;</a>
<a name="ln1376">  did_emsg = false;</a>
<a name="ln1377"> </a>
<a name="ln1378">  ctx_from_dict(dict, &amp;ctx);</a>
<a name="ln1379">  if (!did_emsg) {</a>
<a name="ln1380">    ctx_restore(&amp;ctx, kCtxAll);</a>
<a name="ln1381">  }</a>
<a name="ln1382"> </a>
<a name="ln1383">  ctx_free(&amp;ctx);</a>
<a name="ln1384"> </a>
<a name="ln1385">  did_emsg = save_did_emsg;</a>
<a name="ln1386">  return (Object)OBJECT_INIT;</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/// Gets the current mode. |mode()|</a>
<a name="ln1390">/// &quot;blocking&quot; is true if Nvim is waiting for input.</a>
<a name="ln1391">///</a>
<a name="ln1392">/// @returns Dictionary { &quot;mode&quot;: String, &quot;blocking&quot;: Boolean }</a>
<a name="ln1393">Dictionary nvim_get_mode(void)</a>
<a name="ln1394">  FUNC_API_SINCE(2) FUNC_API_FAST</a>
<a name="ln1395">{</a>
<a name="ln1396">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1397">  char modestr[MODE_MAX_LENGTH];</a>
<a name="ln1398">  get_mode(modestr);</a>
<a name="ln1399">  bool blocked = input_blocking();</a>
<a name="ln1400"> </a>
<a name="ln1401">  PUT(rv, &quot;mode&quot;, CSTR_TO_OBJ(modestr));</a>
<a name="ln1402">  PUT(rv, &quot;blocking&quot;, BOOLEAN_OBJ(blocked));</a>
<a name="ln1403"> </a>
<a name="ln1404">  return rv;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">/// Gets a list of global (non-buffer-local) |mapping| definitions.</a>
<a name="ln1408">///</a>
<a name="ln1409">/// @param  mode       Mode short-name (&quot;n&quot;, &quot;i&quot;, &quot;v&quot;, ...)</a>
<a name="ln1410">/// @returns Array of |maparg()|-like dictionaries describing mappings.</a>
<a name="ln1411">///          The &quot;buffer&quot; key is always zero.</a>
<a name="ln1412">ArrayOf(Dictionary) nvim_get_keymap(String mode)</a>
<a name="ln1413">  FUNC_API_SINCE(3)</a>
<a name="ln1414">{</a>
<a name="ln1415">  return keymap_array(mode, NULL);</a>
<a name="ln1416">}</a>
<a name="ln1417"> </a>
<a name="ln1418">/// Sets a global |mapping| for the given mode.</a>
<a name="ln1419">///</a>
<a name="ln1420">/// To set a buffer-local mapping, use |nvim_buf_set_keymap()|.</a>
<a name="ln1421">///</a>
<a name="ln1422">/// Unlike |:map|, leading/trailing whitespace is accepted as part of the {lhs} or {rhs}.</a>
<a name="ln1423">/// Empty {rhs} is |&lt;Nop&gt;|. |keycodes| are replaced as usual.</a>
<a name="ln1424">///</a>
<a name="ln1425">/// Example:</a>
<a name="ln1426">///</a>
<a name="ln1427">/// ```vim</a>
<a name="ln1428">/// call nvim_set_keymap('n', ' &lt;NL&gt;', '', {'nowait': v:true})</a>
<a name="ln1429">/// ```</a>
<a name="ln1430">///</a>
<a name="ln1431">/// is equivalent to:</a>
<a name="ln1432">///</a>
<a name="ln1433">/// ```vim</a>
<a name="ln1434">/// nmap &lt;nowait&gt; &lt;Space&gt;&lt;NL&gt; &lt;Nop&gt;</a>
<a name="ln1435">/// ```</a>
<a name="ln1436">///</a>
<a name="ln1437">/// @param channel_id</a>
<a name="ln1438">/// @param  mode  Mode short-name (map command prefix: &quot;n&quot;, &quot;i&quot;, &quot;v&quot;, &quot;x&quot;, …)</a>
<a name="ln1439">///               or &quot;!&quot; for |:map!|, or empty string for |:map|.</a>
<a name="ln1440">///               &quot;ia&quot;, &quot;ca&quot; or &quot;!a&quot; for abbreviation in Insert mode, Cmdline mode, or both, respectively</a>
<a name="ln1441">/// @param  lhs   Left-hand-side |{lhs}| of the mapping.</a>
<a name="ln1442">/// @param  rhs   Right-hand-side |{rhs}| of the mapping.</a>
<a name="ln1443">/// @param  opts  Optional parameters map: Accepts all |:map-arguments| as keys except |&lt;buffer&gt;|,</a>
<a name="ln1444">///               values are booleans (default false). Also:</a>
<a name="ln1445">///               - &quot;noremap&quot; disables |recursive_mapping|, like |:noremap|</a>
<a name="ln1446">///               - &quot;desc&quot; human-readable description.</a>
<a name="ln1447">///               - &quot;callback&quot; Lua function called in place of {rhs}.</a>
<a name="ln1448">///               - &quot;replace_keycodes&quot; (boolean) When &quot;expr&quot; is true, replace keycodes in the</a>
<a name="ln1449">///                 resulting string (see |nvim_replace_termcodes()|). Returning nil from the Lua</a>
<a name="ln1450">///                 &quot;callback&quot; is equivalent to returning an empty string.</a>
<a name="ln1451">/// @param[out]   err   Error details, if any.</a>
<a name="ln1452">void nvim_set_keymap(uint64_t channel_id, String mode, String lhs, String rhs, Dict(keymap) *opts,</a>
<a name="ln1453">                     Error *err)</a>
<a name="ln1454">  FUNC_API_SINCE(6)</a>
<a name="ln1455">{</a>
<a name="ln1456">  modify_keymap(channel_id, -1, false, mode, lhs, rhs, opts, err);</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">/// Unmaps a global |mapping| for the given mode.</a>
<a name="ln1460">///</a>
<a name="ln1461">/// To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.</a>
<a name="ln1462">///</a>
<a name="ln1463">/// @see |nvim_set_keymap()|</a>
<a name="ln1464">void nvim_del_keymap(uint64_t channel_id, String mode, String lhs, Error *err)</a>
<a name="ln1465">  FUNC_API_SINCE(6)</a>
<a name="ln1466">{</a>
<a name="ln1467">  nvim_buf_del_keymap(channel_id, -1, mode, lhs, err);</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470">/// Returns a 2-tuple (Array), where item 0 is the current channel id and item</a>
<a name="ln1471">/// 1 is the |api-metadata| map (Dictionary).</a>
<a name="ln1472">///</a>
<a name="ln1473">/// @returns 2-tuple [{channel-id}, {api-metadata}]</a>
<a name="ln1474">Array nvim_get_api_info(uint64_t channel_id, Arena *arena)</a>
<a name="ln1475">  FUNC_API_SINCE(1) FUNC_API_FAST FUNC_API_REMOTE_ONLY</a>
<a name="ln1476">{</a>
<a name="ln1477">  Array rv = arena_array(arena, 2);</a>
<a name="ln1478"> </a>
<a name="ln1479">  assert(channel_id &lt;= INT64_MAX);</a>
<a name="ln1480">  ADD_C(rv, INTEGER_OBJ((int64_t)channel_id));</a>
<a name="ln1481">  ADD_C(rv, DICTIONARY_OBJ(api_metadata()));</a>
<a name="ln1482"> </a>
<a name="ln1483">  return rv;</a>
<a name="ln1484">}</a>
<a name="ln1485"> </a>
<a name="ln1486">/// Self-identifies the client.</a>
<a name="ln1487">///</a>
<a name="ln1488">/// The client/plugin/application should call this after connecting, to provide</a>
<a name="ln1489">/// hints about its identity and purpose, for debugging and orchestration.</a>
<a name="ln1490">///</a>
<a name="ln1491">/// Can be called more than once; the caller should merge old info if</a>
<a name="ln1492">/// appropriate. Example: library first identifies the channel, then a plugin</a>
<a name="ln1493">/// using that library later identifies itself.</a>
<a name="ln1494">///</a>
<a name="ln1495">/// @note &quot;Something is better than nothing&quot;. You don't need to include all the</a>
<a name="ln1496">///       fields.</a>
<a name="ln1497">///</a>
<a name="ln1498">/// @param channel_id</a>
<a name="ln1499">/// @param name Short name for the connected client</a>
<a name="ln1500">/// @param version  Dictionary describing the version, with these</a>
<a name="ln1501">///                 (optional) keys:</a>
<a name="ln1502">///     - &quot;major&quot; major version (defaults to 0 if not set, for no release yet)</a>
<a name="ln1503">///     - &quot;minor&quot; minor version</a>
<a name="ln1504">///     - &quot;patch&quot; patch number</a>
<a name="ln1505">///     - &quot;prerelease&quot; string describing a prerelease, like &quot;dev&quot; or &quot;beta1&quot;</a>
<a name="ln1506">///     - &quot;commit&quot; hash or similar identifier of commit</a>
<a name="ln1507">/// @param type Must be one of the following values. Client libraries should</a>
<a name="ln1508">///             default to &quot;remote&quot; unless overridden by the user.</a>
<a name="ln1509">///     - &quot;remote&quot; remote client connected &quot;Nvim flavored&quot; MessagePack-RPC (responses</a>
<a name="ln1510">///                must be in reverse order of requests). |msgpack-rpc|</a>
<a name="ln1511">///     - &quot;msgpack-rpc&quot; remote client connected to Nvim via fully MessagePack-RPC</a>
<a name="ln1512">///                     compliant protocol.</a>
<a name="ln1513">///     - &quot;ui&quot; gui frontend</a>
<a name="ln1514">///     - &quot;embedder&quot; application using Nvim as a component (for example,</a>
<a name="ln1515">///                  IDE/editor implementing a vim mode).</a>
<a name="ln1516">///     - &quot;host&quot; plugin host, typically started by nvim</a>
<a name="ln1517">///     - &quot;plugin&quot; single plugin, started by nvim</a>
<a name="ln1518">/// @param methods Builtin methods in the client. For a host, this does not</a>
<a name="ln1519">///                include plugin methods which will be discovered later.</a>
<a name="ln1520">///                The key should be the method name, the values are dicts with</a>
<a name="ln1521">///                these (optional) keys (more keys may be added in future</a>
<a name="ln1522">///                versions of Nvim, thus unknown keys are ignored. Clients</a>
<a name="ln1523">///                must only use keys defined in this or later versions of</a>
<a name="ln1524">///                Nvim):</a>
<a name="ln1525">///     - &quot;async&quot;  if true, send as a notification. If false or unspecified,</a>
<a name="ln1526">///                use a blocking request</a>
<a name="ln1527">///     - &quot;nargs&quot; Number of arguments. Could be a single integer or an array</a>
<a name="ln1528">///                of two integers, minimum and maximum inclusive.</a>
<a name="ln1529">///</a>
<a name="ln1530">/// @param attributes Arbitrary string:string map of informal client properties.</a>
<a name="ln1531">///     Suggested keys:</a>
<a name="ln1532">///     - &quot;website&quot;: Client homepage URL (e.g. GitHub repository)</a>
<a name="ln1533">///     - &quot;license&quot;: License description (&quot;Apache 2&quot;, &quot;GPLv3&quot;, &quot;MIT&quot;, …)</a>
<a name="ln1534">///     - &quot;logo&quot;:    URI or path to image, preferably small logo or icon.</a>
<a name="ln1535">///                  .png or .svg format is preferred.</a>
<a name="ln1536">///</a>
<a name="ln1537">/// @param[out] err Error details, if any</a>
<a name="ln1538">void nvim_set_client_info(uint64_t channel_id, String name, Dictionary version, String type,</a>
<a name="ln1539">                          Dictionary methods, Dictionary attributes, Error *err)</a>
<a name="ln1540">  FUNC_API_SINCE(4) FUNC_API_REMOTE_ONLY</a>
<a name="ln1541">{</a>
<a name="ln1542">  Dictionary info = ARRAY_DICT_INIT;</a>
<a name="ln1543">  PUT(info, &quot;name&quot;, copy_object(STRING_OBJ(name), NULL));</a>
<a name="ln1544"> </a>
<a name="ln1545">  version = copy_dictionary(version, NULL);</a>
<a name="ln1546">  bool has_major = false;</a>
<a name="ln1547">  for (size_t i = 0; i &lt; version.size; i++) {</a>
<a name="ln1548">    if (strequal(version.items[i].key.data, &quot;major&quot;)) {</a>
<a name="ln1549">      has_major = true;</a>
<a name="ln1550">      break;</a>
<a name="ln1551">    }</a>
<a name="ln1552">  }</a>
<a name="ln1553">  if (!has_major) {</a>
<a name="ln1554">    PUT(version, &quot;major&quot;, INTEGER_OBJ(0));</a>
<a name="ln1555">  }</a>
<a name="ln1556">  PUT(info, &quot;version&quot;, DICTIONARY_OBJ(version));</a>
<a name="ln1557"> </a>
<a name="ln1558">  PUT(info, &quot;type&quot;, copy_object(STRING_OBJ(type), NULL));</a>
<a name="ln1559">  PUT(info, &quot;methods&quot;, DICTIONARY_OBJ(copy_dictionary(methods, NULL)));</a>
<a name="ln1560">  PUT(info, &quot;attributes&quot;, DICTIONARY_OBJ(copy_dictionary(attributes, NULL)));</a>
<a name="ln1561"> </a>
<a name="ln1562">  rpc_set_client_info(channel_id, info);</a>
<a name="ln1563">}</a>
<a name="ln1564"> </a>
<a name="ln1565">/// Gets information about a channel.</a>
<a name="ln1566">///</a>
<a name="ln1567">/// @returns Dictionary describing a channel, with these keys:</a>
<a name="ln1568">///    - &quot;id&quot;       Channel id.</a>
<a name="ln1569">///    - &quot;argv&quot;     (optional) Job arguments list.</a>
<a name="ln1570">///    - &quot;stream&quot;   Stream underlying the channel.</a>
<a name="ln1571">///         - &quot;stdio&quot;      stdin and stdout of this Nvim instance</a>
<a name="ln1572">///         - &quot;stderr&quot;     stderr of this Nvim instance</a>
<a name="ln1573">///         - &quot;socket&quot;     TCP/IP socket or named pipe</a>
<a name="ln1574">///         - &quot;job&quot;        Job with communication over its stdio.</a>
<a name="ln1575">///    -  &quot;mode&quot;    How data received on the channel is interpreted.</a>
<a name="ln1576">///         - &quot;bytes&quot;      Send and receive raw bytes.</a>
<a name="ln1577">///         - &quot;terminal&quot;   |terminal| instance interprets ASCII sequences.</a>
<a name="ln1578">///         - &quot;rpc&quot;        |RPC| communication on the channel is active.</a>
<a name="ln1579">///    -  &quot;pty&quot;     (optional) Name of pseudoterminal. On a POSIX system this</a>
<a name="ln1580">///                 is a device path like &quot;/dev/pts/1&quot;. If the name is unknown,</a>
<a name="ln1581">///                 the key will still be present if a pty is used (e.g. for</a>
<a name="ln1582">///                 conpty on Windows).</a>
<a name="ln1583">///    -  &quot;buffer&quot;  (optional) Buffer with connected |terminal| instance.</a>
<a name="ln1584">///    -  &quot;client&quot;  (optional) Info about the peer (client on the other end of</a>
<a name="ln1585">///                 the RPC channel), if provided by it via</a>
<a name="ln1586">///                 |nvim_set_client_info()|.</a>
<a name="ln1587">///</a>
<a name="ln1588">Dictionary nvim_get_chan_info(Integer chan, Error *err)</a>
<a name="ln1589">  FUNC_API_SINCE(4)</a>
<a name="ln1590">{</a>
<a name="ln1591">  if (chan &lt; 0) {</a>
<a name="ln1592">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1593">  }</a>
<a name="ln1594">  return channel_info((uint64_t)chan);</a>
<a name="ln1595">}</a>
<a name="ln1596"> </a>
<a name="ln1597">/// Get information about all open channels.</a>
<a name="ln1598">///</a>
<a name="ln1599">/// @returns Array of Dictionaries, each describing a channel with</a>
<a name="ln1600">///          the format specified at |nvim_get_chan_info()|.</a>
<a name="ln1601">Array nvim_list_chans(void)</a>
<a name="ln1602">  FUNC_API_SINCE(4)</a>
<a name="ln1603">{</a>
<a name="ln1604">  return channel_all_info();</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">/// Calls many API methods atomically.</a>
<a name="ln1608">///</a>
<a name="ln1609">/// This has two main usages:</a>
<a name="ln1610">/// 1. To perform several requests from an async context atomically, i.e.</a>
<a name="ln1611">///    without interleaving redraws, RPC requests from other clients, or user</a>
<a name="ln1612">///    interactions (however API methods may trigger autocommands or event</a>
<a name="ln1613">///    processing which have such side effects, e.g. |:sleep| may wake timers).</a>
<a name="ln1614">/// 2. To minimize RPC overhead (roundtrips) of a sequence of many requests.</a>
<a name="ln1615">///</a>
<a name="ln1616">/// @param channel_id</a>
<a name="ln1617">/// @param calls an array of calls, where each call is described by an array</a>
<a name="ln1618">///              with two elements: the request name, and an array of arguments.</a>
<a name="ln1619">/// @param[out] err Validation error details (malformed `calls` parameter),</a>
<a name="ln1620">///             if any. Errors from batched calls are given in the return value.</a>
<a name="ln1621">///</a>
<a name="ln1622">/// @return Array of two elements. The first is an array of return</a>
<a name="ln1623">/// values. The second is NIL if all calls succeeded. If a call resulted in</a>
<a name="ln1624">/// an error, it is a three-element array with the zero-based index of the call</a>
<a name="ln1625">/// which resulted in an error, the error type and the error message. If an</a>
<a name="ln1626">/// error occurred, the values from all preceding calls will still be returned.</a>
<a name="ln1627">Array nvim_call_atomic(uint64_t channel_id, Array calls, Arena *arena, Error *err)</a>
<a name="ln1628">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln1629">{</a>
<a name="ln1630">  Array rv = arena_array(arena, 2);</a>
<a name="ln1631">  Array results = arena_array(arena, calls.size);</a>
<a name="ln1632">  Error nested_error = ERROR_INIT;</a>
<a name="ln1633"> </a>
<a name="ln1634">  size_t i;  // also used for freeing the variables</a>
<a name="ln1635">  for (i = 0; i &lt; calls.size; i++) {</a>
<a name="ln1636">    VALIDATE_T(&quot;'calls' item&quot;, kObjectTypeArray, calls.items[i].type, {</a>
<a name="ln1637">      goto theend;</a>
<a name="ln1638">    });</a>
<a name="ln1639">    Array call = calls.items[i].data.array;</a>
<a name="ln1640">    VALIDATE_EXP((call.size == 2), &quot;'calls' item&quot;, &quot;2-item Array&quot;, NULL, {</a>
<a name="ln1641">      goto theend;</a>
<a name="ln1642">    });</a>
<a name="ln1643">    VALIDATE_T(&quot;name&quot;, kObjectTypeString, call.items[0].type, {</a>
<a name="ln1644">      goto theend;</a>
<a name="ln1645">    });</a>
<a name="ln1646">    String name = call.items[0].data.string;</a>
<a name="ln1647">    VALIDATE_T(&quot;call args&quot;, kObjectTypeArray, call.items[1].type, {</a>
<a name="ln1648">      goto theend;</a>
<a name="ln1649">    });</a>
<a name="ln1650">    Array args = call.items[1].data.array;</a>
<a name="ln1651"> </a>
<a name="ln1652">    MsgpackRpcRequestHandler handler =</a>
<a name="ln1653">      msgpack_rpc_get_handler_for(name.data,</a>
<a name="ln1654">                                  name.size,</a>
<a name="ln1655">                                  &amp;nested_error);</a>
<a name="ln1656"> </a>
<a name="ln1657">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1658">      break;</a>
<a name="ln1659">    }</a>
<a name="ln1660"> </a>
<a name="ln1661">    Object result = handler.fn(channel_id, args, arena, &amp;nested_error);</a>
<a name="ln1662">    if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1663">      // error handled after loop</a>
<a name="ln1664">      break;</a>
<a name="ln1665">    }</a>
<a name="ln1666">    // TODO(bfredl): wasteful copy. It could be avoided to encoding to msgpack</a>
<a name="ln1667">    // directly here. But `result` might become invalid when next api function</a>
<a name="ln1668">    // is called in the loop.</a>
<a name="ln1669">    ADD_C(results, copy_object(result, arena));</a>
<a name="ln1670">    if (!handler.arena_return) {</a>
<a name="ln1671">      api_free_object(result);</a>
<a name="ln1672">    }</a>
<a name="ln1673">  }</a>
<a name="ln1674"> </a>
<a name="ln1675">  ADD_C(rv, ARRAY_OBJ(results));</a>
<a name="ln1676">  if (ERROR_SET(&amp;nested_error)) {</a>
<a name="ln1677">    Array errval = arena_array(arena, 3);</a>
<a name="ln1678">    ADD_C(errval, INTEGER_OBJ((Integer)i));</a>
<a name="ln1679">    ADD_C(errval, INTEGER_OBJ(nested_error.type));</a>
<a name="ln1680">    ADD_C(errval, STRING_OBJ(copy_string(cstr_as_string(nested_error.msg), arena)));</a>
<a name="ln1681">    ADD_C(rv, ARRAY_OBJ(errval));</a>
<a name="ln1682">  } else {</a>
<a name="ln1683">    ADD_C(rv, NIL);</a>
<a name="ln1684">  }</a>
<a name="ln1685"> </a>
<a name="ln1686">theend:</a>
<a name="ln1687">  api_clear_error(&amp;nested_error);</a>
<a name="ln1688">  return rv;</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">/// Writes a message to vim output or error buffer. The string is split</a>
<a name="ln1692">/// and flushed after each newline. Incomplete lines are kept for writing</a>
<a name="ln1693">/// later.</a>
<a name="ln1694">///</a>
<a name="ln1695">/// @param message  Message to write</a>
<a name="ln1696">/// @param to_err   true: message is an error (uses `emsg` instead of `msg`)</a>
<a name="ln1697">/// @param writeln  Append a trailing newline</a>
<a name="ln1698">static void write_msg(String message, bool to_err, bool writeln)</a>
<a name="ln1699">{</a>
<a name="ln1700">  static StringBuilder out_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1701">  static StringBuilder err_line_buf = KV_INITIAL_VALUE;</a>
<a name="ln1702"> </a>
<a name="ln1703">#define PUSH_CHAR(c, line_buf, msg) \</a>
<a name="ln1704">  if (kv_max(line_buf) == 0) { \</a>
<a name="ln1705">    kv_resize(line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1706">  } \</a>
<a name="ln1707">  if (c == NL) { \</a>
<a name="ln1708">    kv_push(line_buf, NUL); \</a>
<a name="ln1709">    msg(line_buf.items); \</a>
<a name="ln1710">    msg_didout = true; \</a>
<a name="ln1711">    kv_drop(line_buf, kv_size(line_buf)); \</a>
<a name="ln1712">    kv_resize(line_buf, LINE_BUFFER_MIN_SIZE); \</a>
<a name="ln1713">  } else if (c == NUL) { \</a>
<a name="ln1714">    kv_push(line_buf, NL); \</a>
<a name="ln1715">  } else { \</a>
<a name="ln1716">    kv_push(line_buf, c); \</a>
<a name="ln1717">  }</a>
<a name="ln1718"> </a>
<a name="ln1719">  no_wait_return++;</a>
<a name="ln1720">  for (uint32_t i = 0; i &lt; message.size; i++) {</a>
<a name="ln1721">    if (got_int) {</a>
<a name="ln1722">      break;</a>
<a name="ln1723">    }</a>
<a name="ln1724">    if (to_err) {</a>
<a name="ln1725">      PUSH_CHAR(message.data[i], err_line_buf, emsg);</a>
<a name="ln1726">    } else {</a>
<a name="ln1727">      PUSH_CHAR(message.data[i], out_line_buf, msg);</a>
<a name="ln1728">    }</a>
<a name="ln1729">  }</a>
<a name="ln1730">  if (writeln) {</a>
<a name="ln1731">    if (to_err) {</a>
<a name="ln1732">      PUSH_CHAR(NL, err_line_buf, emsg);</a>
<a name="ln1733">    } else {</a>
<a name="ln1734">      PUSH_CHAR(NL, out_line_buf, msg);</a>
<a name="ln1735">    }</a>
<a name="ln1736">  }</a>
<a name="ln1737">  no_wait_return--;</a>
<a name="ln1738">  msg_end();</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">// Functions used for testing purposes</a>
<a name="ln1742"> </a>
<a name="ln1743">/// Returns object given as argument.</a>
<a name="ln1744">///</a>
<a name="ln1745">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1746">/// in plugins.</a>
<a name="ln1747">///</a>
<a name="ln1748">/// @param[in]  obj  Object to return.</a>
<a name="ln1749">///</a>
<a name="ln1750">/// @return its argument.</a>
<a name="ln1751">Object nvim__id(Object obj)</a>
<a name="ln1752">{</a>
<a name="ln1753">  return copy_object(obj, NULL);</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/// Returns array given as argument.</a>
<a name="ln1757">///</a>
<a name="ln1758">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1759">/// in plugins.</a>
<a name="ln1760">///</a>
<a name="ln1761">/// @param[in]  arr  Array to return.</a>
<a name="ln1762">///</a>
<a name="ln1763">/// @return its argument.</a>
<a name="ln1764">Array nvim__id_array(Array arr)</a>
<a name="ln1765">{</a>
<a name="ln1766">  return copy_array(arr, NULL);</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/// Returns dictionary given as argument.</a>
<a name="ln1770">///</a>
<a name="ln1771">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1772">/// in plugins.</a>
<a name="ln1773">///</a>
<a name="ln1774">/// @param[in]  dct  Dictionary to return.</a>
<a name="ln1775">///</a>
<a name="ln1776">/// @return its argument.</a>
<a name="ln1777">Dictionary nvim__id_dictionary(Dictionary dct)</a>
<a name="ln1778">{</a>
<a name="ln1779">  return copy_dictionary(dct, NULL);</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">/// Returns floating-point value given as argument.</a>
<a name="ln1783">///</a>
<a name="ln1784">/// This API function is used for testing. One should not rely on its presence</a>
<a name="ln1785">/// in plugins.</a>
<a name="ln1786">///</a>
<a name="ln1787">/// @param[in]  flt  Value to return.</a>
<a name="ln1788">///</a>
<a name="ln1789">/// @return its argument.</a>
<a name="ln1790">Float nvim__id_float(Float flt)</a>
<a name="ln1791">{</a>
<a name="ln1792">  return flt;</a>
<a name="ln1793">}</a>
<a name="ln1794"> </a>
<a name="ln1795">/// Gets internal stats.</a>
<a name="ln1796">///</a>
<a name="ln1797">/// @return Map of various internal stats.</a>
<a name="ln1798">Dictionary nvim__stats(void)</a>
<a name="ln1799">{</a>
<a name="ln1800">  Dictionary rv = ARRAY_DICT_INIT;</a>
<a name="ln1801">  PUT(rv, &quot;fsync&quot;, INTEGER_OBJ(g_stats.fsync));</a>
<a name="ln1802">  PUT(rv, &quot;log_skip&quot;, INTEGER_OBJ(g_stats.log_skip));</a>
<a name="ln1803">  PUT(rv, &quot;lua_refcount&quot;, INTEGER_OBJ(nlua_get_global_ref_count()));</a>
<a name="ln1804">  PUT(rv, &quot;redraw&quot;, INTEGER_OBJ(g_stats.redraw));</a>
<a name="ln1805">  PUT(rv, &quot;arena_alloc_count&quot;, INTEGER_OBJ((Integer)arena_alloc_count));</a>
<a name="ln1806">  return rv;</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">/// Gets a list of dictionaries representing attached UIs.</a>
<a name="ln1810">///</a>
<a name="ln1811">/// @return Array of UI dictionaries, each with these keys:</a>
<a name="ln1812">///   - &quot;height&quot;  Requested height of the UI</a>
<a name="ln1813">///   - &quot;width&quot;   Requested width of the UI</a>
<a name="ln1814">///   - &quot;rgb&quot;     true if the UI uses RGB colors (false implies |cterm-colors|)</a>
<a name="ln1815">///   - &quot;ext_...&quot; Requested UI extensions, see |ui-option|</a>
<a name="ln1816">///   - &quot;chan&quot;    |channel-id| of remote UI</a>
<a name="ln1817">Array nvim_list_uis(void)</a>
<a name="ln1818">  FUNC_API_SINCE(4)</a>
<a name="ln1819">{</a>
<a name="ln1820">  return ui_array();</a>
<a name="ln1821">}</a>
<a name="ln1822"> </a>
<a name="ln1823">/// Gets the immediate children of process `pid`.</a>
<a name="ln1824">///</a>
<a name="ln1825">/// @return Array of child process ids, empty if process not found.</a>
<a name="ln1826">Array nvim_get_proc_children(Integer pid, Error *err)</a>
<a name="ln1827">  FUNC_API_SINCE(4)</a>
<a name="ln1828">{</a>
<a name="ln1829">  Array rvobj = ARRAY_DICT_INIT;</a>
<a name="ln1830">  int *proc_list = NULL;</a>
<a name="ln1831"> </a>
<a name="ln1832">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1833">    goto end;</a>
<a name="ln1834">  });</a>
<a name="ln1835"> </a>
<a name="ln1836">  size_t proc_count;</a>
<a name="ln1837">  int rv = os_proc_children((int)pid, &amp;proc_list, &amp;proc_count);</a>
<a name="ln1838">  if (rv == 2) {</a>
<a name="ln1839">    // syscall failed (possibly because of kernel options), try shelling out.</a>
<a name="ln1840">    DLOG(&quot;fallback to vim._os_proc_children()&quot;);</a>
<a name="ln1841">    MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1842">    ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1843">    Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_children(...)&quot;, a, err);</a>
<a name="ln1844">    if (o.type == kObjectTypeArray) {</a>
<a name="ln1845">      rvobj = o.data.array;</a>
<a name="ln1846">    } else if (!ERROR_SET(err)) {</a>
<a name="ln1847">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1848">                    &quot;Failed to get process children. pid=%&quot; PRId64 &quot; error=%d&quot;,</a>
<a name="ln1849">                    pid, rv);</a>
<a name="ln1850">    }</a>
<a name="ln1851">    goto end;</a>
<a name="ln1852">  }</a>
<a name="ln1853"> </a>
<a name="ln1854">  for (size_t i = 0; i &lt; proc_count; i++) {</a>
<a name="ln1855">    ADD(rvobj, INTEGER_OBJ(proc_list[i]));</a>
<a name="ln1856">  }</a>
<a name="ln1857"> </a>
<a name="ln1858">end:</a>
<a name="ln1859">  xfree(proc_list);</a>
<a name="ln1860">  return rvobj;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/// Gets info describing process `pid`.</a>
<a name="ln1864">///</a>
<a name="ln1865">/// @return Map of process properties, or NIL if process not found.</a>
<a name="ln1866">Object nvim_get_proc(Integer pid, Error *err)</a>
<a name="ln1867">  FUNC_API_SINCE(4)</a>
<a name="ln1868">{</a>
<a name="ln1869">  Object rvobj = OBJECT_INIT;</a>
<a name="ln1870">  rvobj.data.dictionary = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln1871">  rvobj.type = kObjectTypeDictionary;</a>
<a name="ln1872"> </a>
<a name="ln1873">  VALIDATE_INT((pid &gt; 0 &amp;&amp; pid &lt;= INT_MAX), &quot;pid&quot;, pid, {</a>
<a name="ln1874">    return NIL;</a>
<a name="ln1875">  });</a>
<a name="ln1876"> </a>
<a name="ln1877">#ifdef MSWIN</a>
<a name="ln1878">  rvobj.data.dictionary = os_proc_info((int)pid);</a>
<a name="ln1879">  if (rvobj.data.dictionary.size == 0) {  // Process not found.</a>
<a name="ln1880">    return NIL;</a>
<a name="ln1881">  }</a>
<a name="ln1882">#else</a>
<a name="ln1883">  // Cross-platform process info APIs are miserable, so use `ps` instead.</a>
<a name="ln1884">  MAXSIZE_TEMP_ARRAY(a, 1);</a>
<a name="ln1885">  ADD(a, INTEGER_OBJ(pid));</a>
<a name="ln1886">  Object o = NLUA_EXEC_STATIC(&quot;return vim._os_proc_info(...)&quot;, a, err);</a>
<a name="ln1887">  if (o.type == kObjectTypeArray &amp;&amp; o.data.array.size == 0) {</a>
<a name="ln1888">    return NIL;  // Process not found.</a>
<a name="ln1889">  } else if (o.type == kObjectTypeDictionary) {</a>
<a name="ln1890">    rvobj.data.dictionary = o.data.dictionary;</a>
<a name="ln1891">  } else if (!ERROR_SET(err)) {</a>
<a name="ln1892">    api_set_error(err, kErrorTypeException,</a>
<a name="ln1893">                  &quot;Failed to get process info. pid=%&quot; PRId64, pid);</a>
<a name="ln1894">  }</a>
<a name="ln1895">#endif</a>
<a name="ln1896">  return rvobj;</a>
<a name="ln1897">}</a>
<a name="ln1898"> </a>
<a name="ln1899">/// Selects an item in the completion popup menu.</a>
<a name="ln1900">///</a>
<a name="ln1901">/// If neither |ins-completion| nor |cmdline-completion| popup menu is active</a>
<a name="ln1902">/// this API call is silently ignored.</a>
<a name="ln1903">/// Useful for an external UI using |ui-popupmenu| to control the popup menu with the mouse.</a>
<a name="ln1904">/// Can also be used in a mapping; use &lt;Cmd&gt; |:map-cmd| or a Lua mapping to ensure the mapping</a>
<a name="ln1905">/// doesn't end completion mode.</a>
<a name="ln1906">///</a>
<a name="ln1907">/// @param item    Index (zero-based) of the item to select. Value of -1 selects nothing</a>
<a name="ln1908">///                and restores the original text.</a>
<a name="ln1909">/// @param insert  For |ins-completion|, whether the selection should be inserted in the buffer.</a>
<a name="ln1910">///                Ignored for |cmdline-completion|.</a>
<a name="ln1911">/// @param finish  Finish the completion and dismiss the popup menu. Implies {insert}.</a>
<a name="ln1912">/// @param opts    Optional parameters. Reserved for future use.</a>
<a name="ln1913">/// @param[out] err Error details, if any</a>
<a name="ln1914">void nvim_select_popupmenu_item(Integer item, Boolean insert, Boolean finish, Dictionary opts,</a>
<a name="ln1915">                                Error *err)</a>
<a name="ln1916">  FUNC_API_SINCE(6)</a>
<a name="ln1917">{</a>
<a name="ln1918">  VALIDATE((opts.size == 0), &quot;%s&quot;, &quot;opts dict isn't empty&quot;, {</a>
<a name="ln1919">    return;</a>
<a name="ln1920">  });</a>
<a name="ln1921"> </a>
<a name="ln1922">  if (finish) {</a>
<a name="ln1923">    insert = true;</a>
<a name="ln1924">  }</a>
<a name="ln1925"> </a>
<a name="ln1926">  pum_ext_select_item((int)item, insert, finish);</a>
<a name="ln1927">}</a>
<a name="ln1928"> </a>
<a name="ln1929">/// NB: if your UI doesn't use hlstate, this will not return hlstate first time</a>
<a name="ln1930">Array nvim__inspect_cell(Integer grid, Integer row, Integer col, Arena *arena, Error *err)</a>
<a name="ln1931">{</a>
<a name="ln1932">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1933"> </a>
<a name="ln1934">  // TODO(bfredl): if grid == 0 we should read from the compositor's buffer.</a>
<a name="ln1935">  // The only problem is that it does not yet exist.</a>
<a name="ln1936">  ScreenGrid *g = &amp;default_grid;</a>
<a name="ln1937">  if (grid == pum_grid.handle) {</a>
<a name="ln1938">    g = &amp;pum_grid;</a>
<a name="ln1939">  } else if (grid &gt; 1) {</a>
<a name="ln1940">    win_T *wp = get_win_by_grid_handle((handle_T)grid);</a>
<a name="ln1941">    VALIDATE_INT((wp != NULL &amp;&amp; wp-&gt;w_grid_alloc.chars != NULL), &quot;grid handle&quot;, grid, {</a>
<a name="ln1942">      return ret;</a>
<a name="ln1943">    });</a>
<a name="ln1944">    g = &amp;wp-&gt;w_grid_alloc;</a>
<a name="ln1945">  }</a>
<a name="ln1946"> </a>
<a name="ln1947">  if (row &lt; 0 || row &gt;= g-&gt;rows</a>
<a name="ln1948">      || col &lt; 0 || col &gt;= g-&gt;cols) {</a>
<a name="ln1949">    return ret;</a>
<a name="ln1950">  }</a>
<a name="ln1951">  ret = arena_array(arena, 3);</a>
<a name="ln1952">  size_t off = g-&gt;line_offset[(size_t)row] + (size_t)col;</a>
<a name="ln1953">  char *sc_buf = arena_alloc(arena, MAX_SCHAR_SIZE, false);</a>
<a name="ln1954">  schar_get(sc_buf, g-&gt;chars[off]);</a>
<a name="ln1955">  ADD_C(ret, CSTR_AS_OBJ(sc_buf));</a>
<a name="ln1956">  int attr = g-&gt;attrs[off];</a>
<a name="ln1957">  ADD_C(ret, DICTIONARY_OBJ(hl_get_attr_by_id(attr, true, arena, err)));</a>
<a name="ln1958">  // will not work first time</a>
<a name="ln1959">  if (!highlight_use_hlstate()) {</a>
<a name="ln1960">    ADD_C(ret, ARRAY_OBJ(hl_inspect(attr)));</a>
<a name="ln1961">  }</a>
<a name="ln1962">  return ret;</a>
<a name="ln1963">}</a>
<a name="ln1964"> </a>
<a name="ln1965">void nvim__screenshot(String path)</a>
<a name="ln1966">  FUNC_API_FAST</a>
<a name="ln1967">{</a>
<a name="ln1968">  ui_call_screenshot(path);</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">void nvim__invalidate_glyph_cache(void)</a>
<a name="ln1972">{</a>
<a name="ln1973">  schar_cache_clear_force();</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">Object nvim__unpack(String str, Error *err)</a>
<a name="ln1977">  FUNC_API_FAST</a>
<a name="ln1978">{</a>
<a name="ln1979">  return unpack(str.data, str.size, err);</a>
<a name="ln1980">}</a>
<a name="ln1981"> </a>
<a name="ln1982">/// Deletes an uppercase/file named mark. See |mark-motions|.</a>
<a name="ln1983">///</a>
<a name="ln1984">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln1985">/// @param name       Mark name</a>
<a name="ln1986">/// @return true if the mark was deleted, else false.</a>
<a name="ln1987">/// @see |nvim_buf_del_mark()|</a>
<a name="ln1988">/// @see |nvim_get_mark()|</a>
<a name="ln1989">Boolean nvim_del_mark(String name, Error *err)</a>
<a name="ln1990">  FUNC_API_SINCE(8)</a>
<a name="ln1991">{</a>
<a name="ln1992">  bool res = false;</a>
<a name="ln1993">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln1994">    return res;</a>
<a name="ln1995">  });</a>
<a name="ln1996">  // Only allow file/uppercase marks</a>
<a name="ln1997">  // TODO(muniter): Refactor this ASCII_ISUPPER macro to a proper function</a>
<a name="ln1998">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln1999">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2000">    return res;</a>
<a name="ln2001">  });</a>
<a name="ln2002">  res = set_mark(NULL, name, 0, 0, err);</a>
<a name="ln2003">  return res;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">/// Returns a `(row, col, buffer, buffername)` tuple representing the position</a>
<a name="ln2007">/// of the uppercase/file named mark. &quot;End of line&quot; column position is returned</a>
<a name="ln2008">/// as |v:maxcol| (big number). See |mark-motions|.</a>
<a name="ln2009">///</a>
<a name="ln2010">/// Marks are (1,0)-indexed. |api-indexing|</a>
<a name="ln2011">///</a>
<a name="ln2012">/// @note Lowercase name (or other buffer-local mark) is an error.</a>
<a name="ln2013">/// @param name       Mark name</a>
<a name="ln2014">/// @param opts       Optional parameters. Reserved for future use.</a>
<a name="ln2015">/// @return 4-tuple (row, col, buffer, buffername), (0, 0, 0, '') if the mark is</a>
<a name="ln2016">/// not set.</a>
<a name="ln2017">/// @see |nvim_buf_set_mark()|</a>
<a name="ln2018">/// @see |nvim_del_mark()|</a>
<a name="ln2019">Array nvim_get_mark(String name, Dictionary opts, Error *err)</a>
<a name="ln2020">  FUNC_API_SINCE(8)</a>
<a name="ln2021">{</a>
<a name="ln2022">  Array rv = ARRAY_DICT_INIT;</a>
<a name="ln2023"> </a>
<a name="ln2024">  VALIDATE_S((name.size == 1), &quot;mark name (must be a single char)&quot;, name.data, {</a>
<a name="ln2025">    return rv;</a>
<a name="ln2026">  });</a>
<a name="ln2027">  VALIDATE_S((ASCII_ISUPPER(*name.data) || ascii_isdigit(*name.data)),</a>
<a name="ln2028">             &quot;mark name (must be file/uppercase)&quot;, name.data, {</a>
<a name="ln2029">    return rv;</a>
<a name="ln2030">  });</a>
<a name="ln2031"> </a>
<a name="ln2032">  xfmark_T *mark = mark_get_global(false, *name.data);  // false avoids loading the mark buffer</a>
<a name="ln2033">  pos_T pos = mark-&gt;fmark.mark;</a>
<a name="ln2034">  bool allocated = false;</a>
<a name="ln2035">  int bufnr;</a>
<a name="ln2036">  char *filename;</a>
<a name="ln2037"> </a>
<a name="ln2038">  // Marks are from an open buffer it fnum is non zero</a>
<a name="ln2039">  if (mark-&gt;fmark.fnum != 0) {</a>
<a name="ln2040">    bufnr = mark-&gt;fmark.fnum;</a>
<a name="ln2041">    filename = buflist_nr2name(bufnr, true, true);</a>
<a name="ln2042">    allocated = true;</a>
<a name="ln2043">    // Marks comes from shada</a>
<a name="ln2044">  } else {</a>
<a name="ln2045">    filename = mark-&gt;fname;</a>
<a name="ln2046">    bufnr = 0;</a>
<a name="ln2047">  }</a>
<a name="ln2048"> </a>
<a name="ln2049">  bool exists = filename != NULL;</a>
<a name="ln2050">  Integer row;</a>
<a name="ln2051">  Integer col;</a>
<a name="ln2052"> </a>
<a name="ln2053">  if (!exists || pos.lnum &lt;= 0) {</a>
<a name="ln2054">    if (allocated) {</a>
<a name="ln2055">      xfree(filename);</a>
<a name="ln2056">      allocated = false;</a>
<a name="ln2057">    }</a>
<a name="ln2058">    filename = &quot;&quot;;</a>
<a name="ln2059">    bufnr = 0;</a>
<a name="ln2060">    row = 0;</a>
<a name="ln2061">    col = 0;</a>
<a name="ln2062">  } else {</a>
<a name="ln2063">    row = pos.lnum;</a>
<a name="ln2064">    col = pos.col;</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  ADD(rv, INTEGER_OBJ(row));</a>
<a name="ln2068">  ADD(rv, INTEGER_OBJ(col));</a>
<a name="ln2069">  ADD(rv, INTEGER_OBJ(bufnr));</a>
<a name="ln2070">  ADD(rv, CSTR_TO_OBJ(filename));</a>
<a name="ln2071"> </a>
<a name="ln2072">  if (allocated) {</a>
<a name="ln2073">    xfree(filename);</a>
<a name="ln2074">  }</a>
<a name="ln2075"> </a>
<a name="ln2076">  return rv;</a>
<a name="ln2077">}</a>
<a name="ln2078"> </a>
<a name="ln2079">/// Evaluates statusline string.</a>
<a name="ln2080">///</a>
<a name="ln2081">/// @param str Statusline string (see 'statusline').</a>
<a name="ln2082">/// @param opts Optional parameters.</a>
<a name="ln2083">///           - winid: (number) |window-ID| of the window to use as context for statusline.</a>
<a name="ln2084">///           - maxwidth: (number) Maximum width of statusline.</a>
<a name="ln2085">///           - fillchar: (string) Character to fill blank spaces in the statusline (see</a>
<a name="ln2086">///                                'fillchars'). Treated as single-width even if it isn't.</a>
<a name="ln2087">///           - highlights: (boolean) Return highlight information.</a>
<a name="ln2088">///           - use_winbar: (boolean) Evaluate winbar instead of statusline.</a>
<a name="ln2089">///           - use_tabline: (boolean) Evaluate tabline instead of statusline. When true, {winid}</a>
<a name="ln2090">///                                    is ignored. Mutually exclusive with {use_winbar}.</a>
<a name="ln2091">///           - use_statuscol_lnum: (number) Evaluate statuscolumn for this line number instead of statusline.</a>
<a name="ln2092">///</a>
<a name="ln2093">/// @param[out] err Error details, if any.</a>
<a name="ln2094">/// @return Dictionary containing statusline information, with these keys:</a>
<a name="ln2095">///       - str: (string) Characters that will be displayed on the statusline.</a>
<a name="ln2096">///       - width: (number) Display width of the statusline.</a>
<a name="ln2097">///       - highlights: Array containing highlight information of the statusline. Only included when</a>
<a name="ln2098">///                     the &quot;highlights&quot; key in {opts} is true. Each element of the array is a</a>
<a name="ln2099">///                     |Dictionary| with these keys:</a>
<a name="ln2100">///           - start: (number) Byte index (0-based) of first character that uses the highlight.</a>
<a name="ln2101">///           - group: (string) Name of highlight group.</a>
<a name="ln2102">Dictionary nvim_eval_statusline(String str, Dict(eval_statusline) *opts, Error *err)</a>
<a name="ln2103">  FUNC_API_SINCE(8) FUNC_API_FAST</a>
<a name="ln2104">{</a>
<a name="ln2105">  Dictionary result = ARRAY_DICT_INIT;</a>
<a name="ln2106"> </a>
<a name="ln2107">  int maxwidth;</a>
<a name="ln2108">  int fillchar = 0;</a>
<a name="ln2109">  int statuscol_lnum = 0;</a>
<a name="ln2110">  Window window = 0;</a>
<a name="ln2111"> </a>
<a name="ln2112">  if (str.size &lt; 2 || memcmp(str.data, &quot;%!&quot;, 2) != 0) {</a>
<a name="ln2113">    const char *const errmsg = check_stl_option(str.data);</a>
<a name="ln2114">    VALIDATE(!errmsg, &quot;%s&quot;, errmsg, {</a>
<a name="ln2115">      return result;</a>
<a name="ln2116">    });</a>
<a name="ln2117">  }</a>
<a name="ln2118"> </a>
<a name="ln2119">  if (HAS_KEY(opts, eval_statusline, winid)) {</a>
<a name="ln2120">    window = opts-&gt;winid;</a>
<a name="ln2121">  }</a>
<a name="ln2122">  if (HAS_KEY(opts, eval_statusline, fillchar)) {</a>
<a name="ln2123">    VALIDATE_EXP((*opts-&gt;fillchar.data != 0</a>
<a name="ln2124">                  &amp;&amp; ((size_t)utf_ptr2len(opts-&gt;fillchar.data) == opts-&gt;fillchar.size)),</a>
<a name="ln2125">                 &quot;fillchar&quot;, &quot;single character&quot;, NULL, {</a>
<a name="ln2126">      return result;</a>
<a name="ln2127">    });</a>
<a name="ln2128">    fillchar = utf_ptr2char(opts-&gt;fillchar.data);</a>
<a name="ln2129">  }</a>
<a name="ln2130"> </a>
<a name="ln2131">  int use_bools = (int)opts-&gt;use_winbar + (int)opts-&gt;use_tabline;</a>
<a name="ln2132"> </a>
<a name="ln2133">  win_T *wp = opts-&gt;use_tabline ? curwin : find_window_by_handle(window, err);</a>
<a name="ln2134">  if (wp == NULL) {</a>
<a name="ln2135">    api_set_error(err, kErrorTypeException, &quot;unknown winid %d&quot;, window);</a>
<a name="ln2136">    return result;</a>
<a name="ln2137">  }</a>
<a name="ln2138"> </a>
<a name="ln2139">  if (HAS_KEY(opts, eval_statusline, use_statuscol_lnum)) {</a>
<a name="ln2140">    statuscol_lnum = (int)opts-&gt;use_statuscol_lnum;</a>
<a name="ln2141">    VALIDATE_RANGE(statuscol_lnum &gt; 0 &amp;&amp; statuscol_lnum &lt;= wp-&gt;w_buffer-&gt;b_ml.ml_line_count,</a>
<a name="ln2142">                   &quot;use_statuscol_lnum&quot;, {</a>
<a name="ln2143">      return result;</a>
<a name="ln2144">    });</a>
<a name="ln2145">    use_bools++;</a>
<a name="ln2146">  }</a>
<a name="ln2147">  VALIDATE(use_bools &lt;= 1, &quot;%s&quot;,</a>
<a name="ln2148">           &quot;Can only use one of 'use_winbar', 'use_tabline' and 'use_statuscol_lnum'&quot;, {</a>
<a name="ln2149">    return result;</a>
<a name="ln2150">  });</a>
<a name="ln2151"> </a>
<a name="ln2152">  int stc_hl_id = 0;</a>
<a name="ln2153">  statuscol_T statuscol = { 0 };</a>
<a name="ln2154">  SignTextAttrs sattrs[SIGN_SHOW_MAX] = { 0 };</a>
<a name="ln2155"> </a>
<a name="ln2156">  if (opts-&gt;use_tabline) {</a>
<a name="ln2157">    fillchar = ' ';</a>
<a name="ln2158">  } else {</a>
<a name="ln2159">    if (fillchar == 0) {</a>
<a name="ln2160">      if (opts-&gt;use_winbar) {</a>
<a name="ln2161">        fillchar = wp-&gt;w_p_fcs_chars.wbr;</a>
<a name="ln2162">      } else {</a>
<a name="ln2163">        int attr;</a>
<a name="ln2164">        fillchar = fillchar_status(&amp;attr, wp);</a>
<a name="ln2165">      }</a>
<a name="ln2166">    }</a>
<a name="ln2167">    if (statuscol_lnum) {</a>
<a name="ln2168">      HlPriId line = { 0 };</a>
<a name="ln2169">      HlPriId cul  = { 0 };</a>
<a name="ln2170">      HlPriId num  = { 0 };</a>
<a name="ln2171">      linenr_T lnum = statuscol_lnum;</a>
<a name="ln2172">      int num_signs = buf_get_signattrs(wp-&gt;w_buffer, lnum, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2173">      decor_redraw_signs(wp-&gt;w_buffer, lnum - 1, &amp;num_signs, sattrs, &amp;num, &amp;line, &amp;cul);</a>
<a name="ln2174">      wp-&gt;w_scwidth = win_signcol_count(wp);</a>
<a name="ln2175"> </a>
<a name="ln2176">      statuscol.sattrs = sattrs;</a>
<a name="ln2177">      statuscol.foldinfo = fold_info(wp, lnum);</a>
<a name="ln2178">      wp-&gt;w_cursorline = win_cursorline_standout(wp) ? wp-&gt;w_cursor.lnum : 0;</a>
<a name="ln2179"> </a>
<a name="ln2180">      if (wp-&gt;w_p_cul) {</a>
<a name="ln2181">        if (statuscol.foldinfo.fi_level != 0 &amp;&amp; statuscol.foldinfo.fi_lines &gt; 0) {</a>
<a name="ln2182">          wp-&gt;w_cursorline = statuscol.foldinfo.fi_lnum;</a>
<a name="ln2183">        }</a>
<a name="ln2184">        statuscol.use_cul = lnum == wp-&gt;w_cursorline &amp;&amp; (wp-&gt;w_p_culopt_flags &amp; CULOPT_NBR);</a>
<a name="ln2185">      }</a>
<a name="ln2186"> </a>
<a name="ln2187">      statuscol.sign_cul_id = statuscol.use_cul ? cul.hl_id : 0;</a>
<a name="ln2188">      if (num.hl_id) {</a>
<a name="ln2189">        stc_hl_id = num.hl_id;</a>
<a name="ln2190">      } else if (statuscol.use_cul) {</a>
<a name="ln2191">        stc_hl_id = HLF_CLN + 1;</a>
<a name="ln2192">      } else if (wp-&gt;w_p_rnu) {</a>
<a name="ln2193">        stc_hl_id = (lnum &lt; wp-&gt;w_cursor.lnum ? HLF_LNA : HLF_LNB) + 1;</a>
<a name="ln2194">      } else {</a>
<a name="ln2195">        stc_hl_id = HLF_N + 1;</a>
<a name="ln2196">      }</a>
<a name="ln2197"> </a>
<a name="ln2198">      set_vim_var_nr(VV_LNUM, lnum);</a>
<a name="ln2199">      set_vim_var_nr(VV_RELNUM, labs(get_cursor_rel_lnum(wp, lnum)));</a>
<a name="ln2200">      set_vim_var_nr(VV_VIRTNUM, 0);</a>
<a name="ln2201">    }</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  if (HAS_KEY(opts, eval_statusline, maxwidth)) {</a>
<a name="ln2205">    maxwidth = (int)opts-&gt;maxwidth;</a>
<a name="ln2206">  } else {</a>
<a name="ln2207">    maxwidth = statuscol_lnum ? win_col_off(wp)</a>
<a name="ln2208">               : (opts-&gt;use_tabline</a>
<a name="ln2209">                  || (!opts-&gt;use_winbar &amp;&amp; global_stl_height() &gt; 0)) ? Columns : wp-&gt;w_width;</a>
<a name="ln2210">  }</a>
<a name="ln2211"> </a>
<a name="ln2212">  char buf[MAXPATHL];</a>
<a name="ln2213">  stl_hlrec_t *hltab;</a>
<a name="ln2214"> </a>
<a name="ln2215">  // Temporarily reset 'cursorbind' to prevent side effects from moving the cursor away and back.</a>
<a name="ln2216">  int p_crb_save = wp-&gt;w_p_crb;</a>
<a name="ln2217">  wp-&gt;w_p_crb = false;</a>
<a name="ln2218"> </a>
<a name="ln2219">  int width = build_stl_str_hl(wp,</a>
<a name="ln2220">                               buf,</a>
<a name="ln2221">                               sizeof(buf),</a>
<a name="ln2222">                               str.data,</a>
<a name="ln2223">                               NULL,</a>
<a name="ln2224">                               0,</a>
<a name="ln2225">                               fillchar,</a>
<a name="ln2226">                               maxwidth,</a>
<a name="ln2227">                               opts-&gt;highlights ? &amp;hltab : NULL,</a>
<a name="ln2228">                               NULL,</a>
<a name="ln2229">                               statuscol_lnum ? &amp;statuscol : NULL);</a>
<a name="ln2230"> </a>
<a name="ln2231">  PUT(result, &quot;width&quot;, INTEGER_OBJ(width));</a>
<a name="ln2232"> </a>
<a name="ln2233">  // Restore original value of 'cursorbind'</a>
<a name="ln2234">  wp-&gt;w_p_crb = p_crb_save;</a>
<a name="ln2235"> </a>
<a name="ln2236">  if (opts-&gt;highlights) {</a>
<a name="ln2237">    Array hl_values = ARRAY_DICT_INIT;</a>
<a name="ln2238">    const char *grpname;</a>
<a name="ln2239">    char user_group[15];  // strlen(&quot;User&quot;) + strlen(&quot;2147483647&quot;) + NUL</a>
<a name="ln2240"> </a>
<a name="ln2241">    // If first character doesn't have a defined highlight,</a>
<a name="ln2242">    // add the default highlight at the beginning of the highlight list</a>
<a name="ln2243">    if (hltab-&gt;start == NULL || (hltab-&gt;start - buf) != 0) {</a>
<a name="ln2244">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2245">      grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2246"> </a>
<a name="ln2247">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(0));</a>
<a name="ln2248">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2249"> </a>
<a name="ln2250">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2251">    }</a>
<a name="ln2252"> </a>
<a name="ln2253">    for (stl_hlrec_t *sp = hltab; sp-&gt;start != NULL; sp++) {</a>
<a name="ln2254">      Dictionary hl_info = ARRAY_DICT_INIT;</a>
<a name="ln2255"> </a>
<a name="ln2256">      PUT(hl_info, &quot;start&quot;, INTEGER_OBJ(sp-&gt;start - buf));</a>
<a name="ln2257"> </a>
<a name="ln2258">      if (sp-&gt;userhl == 0) {</a>
<a name="ln2259">        grpname = get_default_stl_hl(opts-&gt;use_tabline ? NULL : wp, opts-&gt;use_winbar, stc_hl_id);</a>
<a name="ln2260">      } else if (sp-&gt;userhl &lt; 0) {</a>
<a name="ln2261">        grpname = syn_id2name(-sp-&gt;userhl);</a>
<a name="ln2262">      } else {</a>
<a name="ln2263">        snprintf(user_group, sizeof(user_group), &quot;User%d&quot;, sp-&gt;userhl);</a>
<a name="ln2264">        grpname = user_group;</a>
<a name="ln2265">      }</a>
<a name="ln2266">      PUT(hl_info, &quot;group&quot;, CSTR_TO_OBJ(grpname));</a>
<a name="ln2267">      ADD(hl_values, DICTIONARY_OBJ(hl_info));</a>
<a name="ln2268">    }</a>
<a name="ln2269">    PUT(result, &quot;highlights&quot;, ARRAY_OBJ(hl_values));</a>
<a name="ln2270">  }</a>
<a name="ln2271">  PUT(result, &quot;str&quot;, CSTR_TO_OBJ(buf));</a>
<a name="ln2272"> </a>
<a name="ln2273">  return result;</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276">void nvim_error_event(uint64_t channel_id, Integer lvl, String data)</a>
<a name="ln2277">  FUNC_API_REMOTE_ONLY</a>
<a name="ln2278">{</a>
<a name="ln2279">  // TODO(bfredl): consider printing message to user, as will be relevant</a>
<a name="ln2280">  // if we fork nvim processes as async workers</a>
<a name="ln2281">  ELOG(&quot;async error on channel %&quot; PRId64 &quot;: %s&quot;, channel_id, data.size ? data.data : &quot;&quot;);</a>
<a name="ln2282">}</a>
</code></pre>
<div class="balloon" rel="564"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>