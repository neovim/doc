<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_docmd.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_docmd.c: functions for executing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;limits.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;stddef.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;string.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;auto/config.h&quot;</a>
<a name="ln17">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/change.h&quot;</a>
<a name="ln23">#include &quot;nvim/charset.h&quot;</a>
<a name="ln24">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln25">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln26">#include &quot;nvim/debugger.h&quot;</a>
<a name="ln27">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln28">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln29">#include &quot;nvim/edit.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln33">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln36">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln37">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln38">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln39">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln40">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln41">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln42">#include &quot;nvim/fold.h&quot;</a>
<a name="ln43">#include &quot;nvim/garray.h&quot;</a>
<a name="ln44">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln45">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln46">#include &quot;nvim/globals.h&quot;</a>
<a name="ln47">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln48">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln49">#include &quot;nvim/input.h&quot;</a>
<a name="ln50">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln51">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln52">#include &quot;nvim/macros.h&quot;</a>
<a name="ln53">#include &quot;nvim/main.h&quot;</a>
<a name="ln54">#include &quot;nvim/mark.h&quot;</a>
<a name="ln55">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln56">#include &quot;nvim/memline.h&quot;</a>
<a name="ln57">#include &quot;nvim/memory.h&quot;</a>
<a name="ln58">#include &quot;nvim/message.h&quot;</a>
<a name="ln59">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln60">#include &quot;nvim/move.h&quot;</a>
<a name="ln61">#include &quot;nvim/normal.h&quot;</a>
<a name="ln62">#include &quot;nvim/ops.h&quot;</a>
<a name="ln63">#include &quot;nvim/option.h&quot;</a>
<a name="ln64">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln65">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln66">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln68">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln69">#include &quot;nvim/path.h&quot;</a>
<a name="ln70">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln71">#include &quot;nvim/pos.h&quot;</a>
<a name="ln72">#include &quot;nvim/profile.h&quot;</a>
<a name="ln73">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln74">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln75">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln76">#include &quot;nvim/search.h&quot;</a>
<a name="ln77">#include &quot;nvim/shada.h&quot;</a>
<a name="ln78">#include &quot;nvim/state.h&quot;</a>
<a name="ln79">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln80">#include &quot;nvim/strings.h&quot;</a>
<a name="ln81">#include &quot;nvim/tag.h&quot;</a>
<a name="ln82">#include &quot;nvim/types.h&quot;</a>
<a name="ln83">#include &quot;nvim/ui.h&quot;</a>
<a name="ln84">#include &quot;nvim/undo.h&quot;</a>
<a name="ln85">#include &quot;nvim/usercmd.h&quot;</a>
<a name="ln86">#include &quot;nvim/vim.h&quot;</a>
<a name="ln87">#include &quot;nvim/window.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89">static const char e_ambiguous_use_of_user_defined_command[]</a>
<a name="ln90">  = N_(&quot;E464: Ambiguous use of user-defined command&quot;);</a>
<a name="ln91">static const char e_no_call_stack_to_substitute_for_stack[]</a>
<a name="ln92">  = N_(&quot;E489: No call stack to substitute for \&quot;&lt;stack&gt;\&quot;&quot;);</a>
<a name="ln93">static const char e_not_an_editor_command[]</a>
<a name="ln94">  = N_(&quot;E492: Not an editor command&quot;);</a>
<a name="ln95">static const char e_no_autocommand_file_name_to_substitute_for_afile[]</a>
<a name="ln96">  = N_(&quot;E495: No autocommand file name to substitute for \&quot;&lt;afile&gt;\&quot;&quot;);</a>
<a name="ln97">static const char e_no_autocommand_buffer_number_to_substitute_for_abuf[]</a>
<a name="ln98">  = N_(&quot;E496: No autocommand buffer number to substitute for \&quot;&lt;abuf&gt;\&quot;&quot;);</a>
<a name="ln99">static const char e_no_autocommand_match_name_to_substitute_for_amatch[]</a>
<a name="ln100">  = N_(&quot;E497: No autocommand match name to substitute for \&quot;&lt;amatch&gt;\&quot;&quot;);</a>
<a name="ln101">static const char e_no_source_file_name_to_substitute_for_sfile[]</a>
<a name="ln102">  = N_(&quot;E498: No :source file name to substitute for \&quot;&lt;sfile&gt;\&quot;&quot;);</a>
<a name="ln103">static const char e_no_line_number_to_use_for_slnum[]</a>
<a name="ln104">  = N_(&quot;E842: No line number to use for \&quot;&lt;slnum&gt;\&quot;&quot;);</a>
<a name="ln105">static const char e_no_line_number_to_use_for_sflnum[]</a>
<a name="ln106">  = N_(&quot;E961: No line number to use for \&quot;&lt;sflnum&gt;\&quot;&quot;);</a>
<a name="ln107">static const char e_no_script_file_name_to_substitute_for_script[]</a>
<a name="ln108">  = N_(&quot;E1274: No script file name to substitute for \&quot;&lt;script&gt;\&quot;&quot;);</a>
<a name="ln109"> </a>
<a name="ln110">static int quitmore = 0;</a>
<a name="ln111">static bool ex_pressedreturn = false;</a>
<a name="ln112"> </a>
<a name="ln113">// Struct for storing a line inside a while/for loop</a>
<a name="ln114">typedef struct {</a>
<a name="ln115">  char *line;            // command line</a>
<a name="ln116">  linenr_T lnum;                // sourcing_lnum of the line</a>
<a name="ln117">} wcmd_T;</a>
<a name="ln118"> </a>
<a name="ln119">#define FREE_WCMD(wcmd) xfree((wcmd)-&gt;line)</a>
<a name="ln120"> </a>
<a name="ln121">/// Structure used to store info for line position in a while or for loop.</a>
<a name="ln122">/// This is required, because do_one_cmd() may invoke ex_function(), which</a>
<a name="ln123">/// reads more lines that may come from the while/for loop.</a>
<a name="ln124">struct loop_cookie {</a>
<a name="ln125">  garray_T *lines_gap;               // growarray with line info</a>
<a name="ln126">  int current_line;                     // last read line from growarray</a>
<a name="ln127">  int repeating;                        // true when looping a second time</a>
<a name="ln128">  // When &quot;repeating&quot; is false use &quot;getline&quot; and &quot;cookie&quot; to get lines</a>
<a name="ln129">  char *(*getline)(int, void *, int, bool);</a>
<a name="ln130">  void *cookie;</a>
<a name="ln131">};</a>
<a name="ln132"> </a>
<a name="ln133">// Struct to save a few things while debugging.  Used in do_cmdline() only.</a>
<a name="ln134">struct dbg_stuff {</a>
<a name="ln135">  int trylevel;</a>
<a name="ln136">  int force_abort;</a>
<a name="ln137">  except_T *caught_stack;</a>
<a name="ln138">  char *vv_exception;</a>
<a name="ln139">  char *vv_throwpoint;</a>
<a name="ln140">  int did_emsg;</a>
<a name="ln141">  int got_int;</a>
<a name="ln142">  bool did_throw;</a>
<a name="ln143">  int need_rethrow;</a>
<a name="ln144">  int check_cstack;</a>
<a name="ln145">  except_T *current_exception;</a>
<a name="ln146">};</a>
<a name="ln147"> </a>
<a name="ln148">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln149"># include &quot;ex_docmd.c.generated.h&quot;</a>
<a name="ln150">#endif</a>
<a name="ln151"> </a>
<a name="ln152">#ifndef HAVE_WORKING_LIBINTL</a>
<a name="ln153"># define ex_language            ex_ni</a>
<a name="ln154">#endif</a>
<a name="ln155"> </a>
<a name="ln156">// Declare cmdnames[].</a>
<a name="ln157">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln158"># include &quot;ex_cmds_defs.generated.h&quot;</a>
<a name="ln159">#endif</a>
<a name="ln160"> </a>
<a name="ln161">static char dollar_command[2] = { '$', 0 };</a>
<a name="ln162"> </a>
<a name="ln163">static void save_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln164">{</a>
<a name="ln165">  dsp-&gt;trylevel       = trylevel;             trylevel = 0;</a>
<a name="ln166">  dsp-&gt;force_abort    = force_abort;          force_abort = false;</a>
<a name="ln167">  dsp-&gt;caught_stack   = caught_stack;         caught_stack = NULL;</a>
<a name="ln168">  dsp-&gt;vv_exception   = v_exception(NULL);</a>
<a name="ln169">  dsp-&gt;vv_throwpoint  = v_throwpoint(NULL);</a>
<a name="ln170"> </a>
<a name="ln171">  // Necessary for debugging an inactive &quot;:catch&quot;, &quot;:finally&quot;, &quot;:endtry&quot;.</a>
<a name="ln172">  dsp-&gt;did_emsg       = did_emsg;             did_emsg     = false;</a>
<a name="ln173">  dsp-&gt;got_int        = got_int;              got_int      = false;</a>
<a name="ln174">  dsp-&gt;did_throw      = did_throw;            did_throw    = false;</a>
<a name="ln175">  dsp-&gt;need_rethrow   = need_rethrow;         need_rethrow = false;</a>
<a name="ln176">  dsp-&gt;check_cstack   = check_cstack;         check_cstack = false;</a>
<a name="ln177">  dsp-&gt;current_exception = current_exception; current_exception = NULL;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static void restore_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln181">{</a>
<a name="ln182">  suppress_errthrow = false;</a>
<a name="ln183">  trylevel = dsp-&gt;trylevel;</a>
<a name="ln184">  force_abort = dsp-&gt;force_abort;</a>
<a name="ln185">  caught_stack = dsp-&gt;caught_stack;</a>
<a name="ln186">  (void)v_exception(dsp-&gt;vv_exception);</a>
<a name="ln187">  (void)v_throwpoint(dsp-&gt;vv_throwpoint);</a>
<a name="ln188">  did_emsg = dsp-&gt;did_emsg;</a>
<a name="ln189">  got_int = dsp-&gt;got_int;</a>
<a name="ln190">  did_throw = dsp-&gt;did_throw;</a>
<a name="ln191">  need_rethrow = dsp-&gt;need_rethrow;</a>
<a name="ln192">  check_cstack = dsp-&gt;check_cstack;</a>
<a name="ln193">  current_exception = dsp-&gt;current_exception;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">/// Repeatedly get commands for Ex mode, until the &quot;:vi&quot; command is given.</a>
<a name="ln197">void do_exmode(void)</a>
<a name="ln198">{</a>
<a name="ln199">  exmode_active = true;</a>
<a name="ln200">  State = MODE_NORMAL;</a>
<a name="ln201">  may_trigger_modechanged();</a>
<a name="ln202"> </a>
<a name="ln203">  // When using &quot;:global /pat/ visual&quot; and then &quot;Q&quot; we return to continue</a>
<a name="ln204">  // the :global command.</a>
<a name="ln205">  if (global_busy) {</a>
<a name="ln206">    return;</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  int save_msg_scroll = msg_scroll;</a>
<a name="ln210">  RedrawingDisabled++;  // don't redisplay the window</a>
<a name="ln211">  no_wait_return++;  // don't wait for return</a>
<a name="ln212"> </a>
<a name="ln213">  msg(_(&quot;Entering Ex mode.  Type \&quot;visual\&quot; to go to Normal mode.&quot;), 0);</a>
<a name="ln214">  while (exmode_active) {</a>
<a name="ln215">    // Check for a &quot;:normal&quot; command and no more characters left.</a>
<a name="ln216">    if (ex_normal_busy &gt; 0 &amp;&amp; typebuf.tb_len == 0) {</a>
<a name="ln217">      exmode_active = false;</a>
<a name="ln218">      break;</a>
<a name="ln219">    }</a>
<a name="ln220">    msg_scroll = true;</a>
<a name="ln221">    need_wait_return = false;</a>
<a name="ln222">    ex_pressedreturn = false;</a>
<a name="ln223">    ex_no_reprint = false;</a>
<a name="ln224">    varnumber_T changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln225">    int prev_msg_row = msg_row;</a>
<a name="ln226">    linenr_T prev_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln227">    cmdline_row = msg_row;</a>
<a name="ln228">    do_cmdline(NULL, getexline, NULL, 0);</a>
<a name="ln229">    lines_left = Rows - 1;</a>
<a name="ln230"> </a>
<a name="ln231">    if ((prev_line != curwin-&gt;w_cursor.lnum</a>
<a name="ln232">         || changedtick != buf_get_changedtick(curbuf)) &amp;&amp; !ex_no_reprint) {</a>
<a name="ln233">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln234">        emsg(_(e_empty_buffer));</a>
<a name="ln235">      } else {</a>
<a name="ln236">        if (ex_pressedreturn) {</a>
<a name="ln237">          // Make sure the message overwrites the right line and isn't throttled.</a>
<a name="ln238">          msg_scroll_flush();</a>
<a name="ln239">          // go up one line, to overwrite the &quot;:&lt;CR&gt;&quot; line, so the</a>
<a name="ln240">          // output doesn't contain empty lines.</a>
<a name="ln241">          msg_row = prev_msg_row;</a>
<a name="ln242">          if (prev_msg_row == Rows - 1) {</a>
<a name="ln243">            msg_row--;</a>
<a name="ln244">          }</a>
<a name="ln245">        }</a>
<a name="ln246">        msg_col = 0;</a>
<a name="ln247">        print_line_no_prefix(curwin-&gt;w_cursor.lnum, false, false);</a>
<a name="ln248">        msg_clr_eos();</a>
<a name="ln249">      }</a>
<a name="ln250">    } else if (ex_pressedreturn &amp;&amp; !ex_no_reprint) {  // must be at EOF</a>
<a name="ln251">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln252">        emsg(_(e_empty_buffer));</a>
<a name="ln253">      } else {</a>
<a name="ln254">        emsg(_(&quot;E501: At end-of-file&quot;));</a>
<a name="ln255">      }</a>
<a name="ln256">    }</a>
<a name="ln257">  }</a>
<a name="ln258"> </a>
<a name="ln259">  RedrawingDisabled--;</a>
<a name="ln260">  no_wait_return--;</a>
<a name="ln261">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln262">  update_screen();</a>
<a name="ln263">  need_wait_return = false;</a>
<a name="ln264">  msg_scroll = save_msg_scroll;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/// Print the executed command for when 'verbose' is set.</a>
<a name="ln268">///</a>
<a name="ln269">/// @param lnum  if 0, only print the command.</a>
<a name="ln270">static void msg_verbose_cmd(linenr_T lnum, char *cmd)</a>
<a name="ln271">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln272">{</a>
<a name="ln273">  no_wait_return++;</a>
<a name="ln274">  verbose_enter_scroll();</a>
<a name="ln275"> </a>
<a name="ln276">  if (lnum == 0) {</a>
<a name="ln277">    smsg(0, _(&quot;Executing: %s&quot;), cmd);</a>
<a name="ln278">  } else {</a>
<a name="ln279">    smsg(0, _(&quot;line %&quot; PRIdLINENR &quot;: %s&quot;), lnum, cmd);</a>
<a name="ln280">  }</a>
<a name="ln281">  if (msg_silent == 0) {</a>
<a name="ln282">    msg_puts(&quot;\n&quot;);   // don't overwrite this</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  verbose_leave_scroll();</a>
<a name="ln286">  no_wait_return--;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">/// Execute a simple command line.  Used for translated commands like &quot;*&quot;.</a>
<a name="ln290">int do_cmdline_cmd(const char *cmd)</a>
<a name="ln291">{</a>
<a name="ln292">  return do_cmdline((char *)cmd, NULL, NULL, DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">/// do_cmdline(): execute one Ex command line</a>
<a name="ln296">///</a>
<a name="ln297">/// 1. Execute &quot;cmdline&quot; when it is not NULL.</a>
<a name="ln298">///    If &quot;cmdline&quot; is NULL, or more lines are needed, fgetline() is used.</a>
<a name="ln299">/// 2. Split up in parts separated with '|'.</a>
<a name="ln300">///</a>
<a name="ln301">/// This function can be called recursively!</a>
<a name="ln302">///</a>
<a name="ln303">/// flags:</a>
<a name="ln304">///   DOCMD_VERBOSE  - The command will be included in the error message.</a>
<a name="ln305">///   DOCMD_NOWAIT   - Don't call wait_return() and friends.</a>
<a name="ln306">///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.</a>
<a name="ln307">///   DOCMD_KEYTYPED - Don't reset KeyTyped.</a>
<a name="ln308">///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).</a>
<a name="ln309">///   DOCMD_KEEPLINE - Store first typed line (for repeating with &quot;.&quot;).</a>
<a name="ln310">///</a>
<a name="ln311">/// @param cookie  argument for fgetline()</a>
<a name="ln312">///</a>
<a name="ln313">/// @return FAIL if cmdline could not be executed, OK otherwise</a>
<a name="ln314">int do_cmdline(char *cmdline, LineGetter fgetline, void *cookie, int flags)</a>
<a name="ln315">{</a>
<a name="ln316">  char *next_cmdline;                   // next cmd to execute</a>
<a name="ln317">  char *cmdline_copy = NULL;            // copy of cmd line</a>
<a name="ln318">  bool used_getline = false;            // used &quot;fgetline&quot; to obtain command</a>
<a name="ln319">  static int recursive = 0;             // recursive depth</a>
<a name="ln320">  bool msg_didout_before_start = false;</a>
<a name="ln321">  int count = 0;                        // line number count</a>
<a name="ln322">  bool did_inc = false;                 // incremented RedrawingDisabled</a>
<a name="ln323">  int retval = OK;</a>
<a name="ln324">  cstack_T cstack = {                   // conditional stack</a>
<a name="ln325">    .cs_idx = -1,</a>
<a name="ln326">  };</a>
<a name="ln327">  garray_T lines_ga;                    // keep lines for &quot;:while&quot;/&quot;:for&quot;</a>
<a name="ln328">  int current_line = 0;                 // active line in lines_ga</a>
<a name="ln329">  char *fname = NULL;                   // function or script name</a>
<a name="ln330">  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie</a>
<a name="ln331">  int *dbg_tick = NULL;                 // ptr to dbg_tick field in cookie</a>
<a name="ln332">  struct dbg_stuff debug_saved;         // saved things for debug mode</a>
<a name="ln333">  int initial_trylevel;</a>
<a name="ln334">  msglist_T **saved_msg_list = NULL;</a>
<a name="ln335">  msglist_T *private_msg_list;</a>
<a name="ln336"> </a>
<a name="ln337">  // &quot;fgetline&quot; and &quot;cookie&quot; passed to do_one_cmd()</a>
<a name="ln338">  char *(*cmd_getline)(int, void *, int, bool);</a>
<a name="ln339">  void *cmd_cookie;</a>
<a name="ln340">  struct loop_cookie cmd_loop_cookie;</a>
<a name="ln341">  void *real_cookie;</a>
<a name="ln342">  int getline_is_func;</a>
<a name="ln343">  static int call_depth = 0;            // recursiveness</a>
<a name="ln344"> </a>
<a name="ln345">  // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory</a>
<a name="ln346">  // location for storing error messages to be converted to an exception.</a>
<a name="ln347">  // This ensures that the do_errthrow() call in do_one_cmd() does not</a>
<a name="ln348">  // combine the messages stored by an earlier invocation of do_one_cmd()</a>
<a name="ln349">  // with the command name of the later one.  This would happen when</a>
<a name="ln350">  // BufWritePost autocommands are executed after a write error.</a>
<a name="ln351">  saved_msg_list = msg_list;</a>
<a name="ln352">  msg_list = &amp;private_msg_list;</a>
<a name="ln353">  private_msg_list = NULL;</a>
<a name="ln354"> </a>
<a name="ln355">  // It's possible to create an endless loop with &quot;:execute&quot;, catch that</a>
<a name="ln356">  // here.  The value of 200 allows nested function calls, &quot;:source&quot;, etc.</a>
<a name="ln357">  // Allow 200 or 'maxfuncdepth', whatever is larger.</a>
<a name="ln358">  if (call_depth &gt;= 200 &amp;&amp; call_depth &gt;= p_mfd) {</a>
<a name="ln359">    emsg(_(e_command_too_recursive));</a>
<a name="ln360">    // When converting to an exception, we do not include the command name</a>
<a name="ln361">    // since this is not an error of the specific command.</a>
<a name="ln362">    do_errthrow((cstack_T *)NULL, NULL);</a>
<a name="ln363">    msg_list = saved_msg_list;</a>
<a name="ln364">    return FAIL;</a>
<a name="ln365">  }</a>
<a name="ln366">  call_depth++;</a>
<a name="ln367">  start_batch_changes();</a>
<a name="ln368"> </a>
<a name="ln369">  ga_init(&amp;lines_ga, (int)sizeof(wcmd_T), 10);</a>
<a name="ln370"> </a>
<a name="ln371">  real_cookie = getline_cookie(fgetline, cookie);</a>
<a name="ln372"> </a>
<a name="ln373">  // Inside a function use a higher nesting level.</a>
<a name="ln374">  getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln375">  if (getline_is_func &amp;&amp; ex_nesting_level == func_level(real_cookie)) {</a>
<a name="ln376">    ex_nesting_level++;</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  // Get the function or script name and the address where the next breakpoint</a>
<a name="ln380">  // line and the debug tick for a function or script are stored.</a>
<a name="ln381">  if (getline_is_func) {</a>
<a name="ln382">    fname = func_name(real_cookie);</a>
<a name="ln383">    breakpoint = func_breakpoint(real_cookie);</a>
<a name="ln384">    dbg_tick = func_dbg_tick(real_cookie);</a>
<a name="ln385">  } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln386">    fname = SOURCING_NAME;</a>
<a name="ln387">    breakpoint = source_breakpoint(real_cookie);</a>
<a name="ln388">    dbg_tick = source_dbg_tick(real_cookie);</a>
<a name="ln389">  }</a>
<a name="ln390"> </a>
<a name="ln391">  // Initialize &quot;force_abort&quot;  and &quot;suppress_errthrow&quot; at the top level.</a>
<a name="ln392">  if (!recursive) {</a>
<a name="ln393">    force_abort = false;</a>
<a name="ln394">    suppress_errthrow = false;</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  // If requested, store and reset the global values controlling the</a>
<a name="ln398">  // exception handling (used when debugging).  Otherwise clear it to avoid</a>
<a name="ln399">  // a bogus compiler warning when the optimizer uses inline functions...</a>
<a name="ln400">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln401">    save_dbg_stuff(&amp;debug_saved);</a>
<a name="ln402">  } else {</a>
<a name="ln403">    CLEAR_FIELD(debug_saved);</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  initial_trylevel = trylevel;</a>
<a name="ln407"> </a>
<a name="ln408">  // &quot;did_throw&quot; will be set to true when an exception is being thrown.</a>
<a name="ln409">  did_throw = false;</a>
<a name="ln410">  // &quot;did_emsg&quot; will be set to true when emsg() is used, in which case we</a>
<a name="ln411">  // cancel the whole command line, and any if/endif or loop.</a>
<a name="ln412">  // If force_abort is set, we cancel everything.</a>
<a name="ln413">  did_emsg = false;</a>
<a name="ln414"> </a>
<a name="ln415">  // KeyTyped is only set when calling vgetc().  Reset it here when not</a>
<a name="ln416">  // calling vgetc() (sourced command lines).</a>
<a name="ln417">  if (!(flags &amp; DOCMD_KEYTYPED)</a>
<a name="ln418">      &amp;&amp; !getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln419">    KeyTyped = false;</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  // Continue executing command lines:</a>
<a name="ln423">  // - when inside an &quot;:if&quot;, &quot;:while&quot; or &quot;:for&quot;</a>
<a name="ln424">  // - for multiple commands on one line, separated with '|'</a>
<a name="ln425">  // - when repeating until there are no more lines (for &quot;:source&quot;)</a>
<a name="ln426">  next_cmdline = cmdline;</a>
<a name="ln427">  do {</a>
<a name="ln428">    getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln429"> </a>
<a name="ln430">    // stop skipping cmds for an error msg after all endif/while/for</a>
<a name="ln431">    if (next_cmdline == NULL</a>
<a name="ln432">        &amp;&amp; !force_abort</a>
<a name="ln433">        &amp;&amp; cstack.cs_idx &lt; 0</a>
<a name="ln434">        &amp;&amp; !(getline_is_func</a>
<a name="ln435">             &amp;&amp; func_has_abort(real_cookie))) {</a>
<a name="ln436">      did_emsg = false;</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">    // 1. If repeating a line in a loop, get a line from lines_ga.</a>
<a name="ln440">    // 2. If no line given: Get an allocated line with fgetline().</a>
<a name="ln441">    // 3. If a line is given: Make a copy, so we can mess with it.</a>
<a name="ln442"> </a>
<a name="ln443">    // 1. If repeating, get a previous line from lines_ga.</a>
<a name="ln444">    if (cstack.cs_looplevel &gt; 0 &amp;&amp; current_line &lt; lines_ga.ga_len) {</a>
<a name="ln445">      // Each '|' separated command is stored separately in lines_ga, to</a>
<a name="ln446">      // be able to jump to it.  Don't use next_cmdline now.</a>
<a name="ln447">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln448"> </a>
<a name="ln449">      // Check if a function has returned or, unless it has an unclosed</a>
<a name="ln450">      // try conditional, aborted.</a>
<a name="ln451">      if (getline_is_func) {</a>
<a name="ln452">        if (do_profiling == PROF_YES) {</a>
<a name="ln453">          func_line_end(real_cookie);</a>
<a name="ln454">        }</a>
<a name="ln455">        if (func_has_ended(real_cookie)) {</a>
<a name="ln456">          retval = FAIL;</a>
<a name="ln457">          break;</a>
<a name="ln458">        }</a>
<a name="ln459">      } else if (do_profiling == PROF_YES</a>
<a name="ln460">                 &amp;&amp; getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln461">        script_line_end();</a>
<a name="ln462">      }</a>
<a name="ln463"> </a>
<a name="ln464">      // Check if a sourced file hit a &quot;:finish&quot; command.</a>
<a name="ln465">      if (source_finished(fgetline, cookie)) {</a>
<a name="ln466">        retval = FAIL;</a>
<a name="ln467">        break;</a>
<a name="ln468">      }</a>
<a name="ln469"> </a>
<a name="ln470">      // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln471">      if (breakpoint != NULL &amp;&amp; dbg_tick != NULL</a>
<a name="ln472">          &amp;&amp; *dbg_tick != debug_tick) {</a>
<a name="ln473">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln474">                                          fname, SOURCING_LNUM);</a>
<a name="ln475">        *dbg_tick = debug_tick;</a>
<a name="ln476">      }</a>
<a name="ln477"> </a>
<a name="ln478">      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;</a>
<a name="ln479">      SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;</a>
<a name="ln480"> </a>
<a name="ln481">      // Did we encounter a breakpoint?</a>
<a name="ln482">      if (breakpoint != NULL &amp;&amp; *breakpoint != 0 &amp;&amp; *breakpoint &lt;= SOURCING_LNUM) {</a>
<a name="ln483">        dbg_breakpoint(fname, SOURCING_LNUM);</a>
<a name="ln484">        // Find next breakpoint.</a>
<a name="ln485">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln486">                                          fname, SOURCING_LNUM);</a>
<a name="ln487">        *dbg_tick = debug_tick;</a>
<a name="ln488">      }</a>
<a name="ln489">      if (do_profiling == PROF_YES) {</a>
<a name="ln490">        if (getline_is_func) {</a>
<a name="ln491">          func_line_start(real_cookie);</a>
<a name="ln492">        } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln493">          script_line_start();</a>
<a name="ln494">        }</a>
<a name="ln495">      }</a>
<a name="ln496">    }</a>
<a name="ln497"> </a>
<a name="ln498">    // 2. If no line given, get an allocated line with fgetline().</a>
<a name="ln499">    if (next_cmdline == NULL) {</a>
<a name="ln500">      // Need to set msg_didout for the first line after an &quot;:if&quot;,</a>
<a name="ln501">      // otherwise the &quot;:if&quot; will be overwritten.</a>
<a name="ln502">      if (count == 1 &amp;&amp; getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln503">        msg_didout = true;</a>
<a name="ln504">      }</a>
<a name="ln505">      if (fgetline == NULL</a>
<a name="ln506">          || (next_cmdline = fgetline(':', cookie,</a>
<a name="ln507">                                      cstack.cs_idx &lt;</a>
<a name="ln508">                                      0 ? 0 : (cstack.cs_idx + 1) * 2,</a>
<a name="ln509">                                      true)) == NULL) {</a>
<a name="ln510">        // Don't call wait_return() for aborted command line.  The NULL</a>
<a name="ln511">        // returned for the end of a sourced file or executed function</a>
<a name="ln512">        // doesn't do this.</a>
<a name="ln513">        if (KeyTyped &amp;&amp; !(flags &amp; DOCMD_REPEAT)) {</a>
<a name="ln514">          need_wait_return = false;</a>
<a name="ln515">        }</a>
<a name="ln516">        retval = FAIL;</a>
<a name="ln517">        break;</a>
<a name="ln518">      }</a>
<a name="ln519">      used_getline = true;</a>
<a name="ln520"> </a>
<a name="ln521">      // Keep the first typed line.  Clear it when more lines are typed.</a>
<a name="ln522">      if (flags &amp; DOCMD_KEEPLINE) {</a>
<a name="ln523">        xfree(repeat_cmdline);</a>
<a name="ln524">        if (count == 0) {</a>
<a name="ln525">          repeat_cmdline = xstrdup(next_cmdline);</a>
<a name="ln526">        } else {</a>
<a name="ln527">          repeat_cmdline = NULL;</a>
<a name="ln528">        }</a>
<a name="ln529">      }</a>
<a name="ln530">    } else if (cmdline_copy == NULL) {</a>
<a name="ln531">      // 3. Make a copy of the command so we can mess with it.</a>
<a name="ln532">      next_cmdline = xstrdup(next_cmdline);</a>
<a name="ln533">    }</a>
<a name="ln534">    cmdline_copy = next_cmdline;</a>
<a name="ln535"> </a>
<a name="ln536">    int current_line_before = 0;</a>
<a name="ln537">    // Inside a while/for loop, and when the command looks like a &quot;:while&quot;</a>
<a name="ln538">    // or &quot;:for&quot;, the line is stored, because we may need it later when</a>
<a name="ln539">    // looping.</a>
<a name="ln540">    //</a>
<a name="ln541">    // When there is a '|' and another command, it is stored separately,</a>
<a name="ln542">    // because we need to be able to jump back to it from an</a>
<a name="ln543">    // :endwhile/:endfor.</a>
<a name="ln544">    //</a>
<a name="ln545">    // Pass a different &quot;fgetline&quot; function to do_one_cmd() below,</a>
<a name="ln546">    // that it stores lines in or reads them from &quot;lines_ga&quot;.  Makes it</a>
<a name="ln547">    // possible to define a function inside a while/for loop.</a>
<a name="ln548">    if ((cstack.cs_looplevel &gt; 0 || has_loop_cmd(next_cmdline))) {</a>
<a name="ln549">      cmd_getline = get_loop_line;</a>
<a name="ln550">      cmd_cookie = (void *)&amp;cmd_loop_cookie;</a>
<a name="ln551">      cmd_loop_cookie.lines_gap = &amp;lines_ga;</a>
<a name="ln552">      cmd_loop_cookie.current_line = current_line;</a>
<a name="ln553">      cmd_loop_cookie.getline = fgetline;</a>
<a name="ln554">      cmd_loop_cookie.cookie = cookie;</a>
<a name="ln555">      cmd_loop_cookie.repeating = (current_line &lt; lines_ga.ga_len);</a>
<a name="ln556"> </a>
<a name="ln557">      // Save the current line when encountering it the first time.</a>
<a name="ln558">      if (current_line == lines_ga.ga_len) {</a>
<a name="ln559">        store_loop_line(&amp;lines_ga, next_cmdline);</a>
<a name="ln560">      }</a>
<a name="ln561">      current_line_before = current_line;</a>
<a name="ln562">    } else {</a>
<a name="ln563">      cmd_getline = fgetline;</a>
<a name="ln564">      cmd_cookie = cookie;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    did_endif = false;</a>
<a name="ln568"> </a>
<a name="ln569">    if (count++ == 0) {</a>
<a name="ln570">      // All output from the commands is put below each other, without</a>
<a name="ln571">      // waiting for a return. Don't do this when executing commands</a>
<a name="ln572">      // from a script or when being called recursive (e.g. for &quot;:e</a>
<a name="ln573">      // +command file&quot;).</a>
<a name="ln574">      if (!(flags &amp; DOCMD_NOWAIT) &amp;&amp; !recursive) {</a>
<a name="ln575">        msg_didout_before_start = msg_didout;</a>
<a name="ln576">        msg_didany = false;         // no output yet</a>
<a name="ln577">        msg_start();</a>
<a name="ln578">        msg_scroll = true;          // put messages below each other</a>
<a name="ln579">        no_wait_return++;           // don't wait for return until finished</a>
<a name="ln580">        RedrawingDisabled++;</a>
<a name="ln581">        did_inc = true;</a>
<a name="ln582">      }</a>
<a name="ln583">    }</a>
<a name="ln584"> </a>
<a name="ln585">    if ((p_verbose &gt;= 15 &amp;&amp; SOURCING_NAME != NULL) || p_verbose &gt;= 16) {</a>
<a name="ln586">      msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);</a>
<a name="ln587">    }</a>
<a name="ln588"> </a>
<a name="ln589">    // 2. Execute one '|' separated command.</a>
<a name="ln590">    //    do_one_cmd() will return NULL if there is no trailing '|'.</a>
<a name="ln591">    //    &quot;cmdline_copy&quot; can change, e.g. for '%' and '#' expansion.</a>
<a name="ln592">    recursive++;</a>
<a name="ln593">    next_cmdline = do_one_cmd(&amp;cmdline_copy, flags, &amp;cstack, cmd_getline, cmd_cookie);</a>
<a name="ln594">    recursive--;</a>
<a name="ln595"> </a>
<a name="ln596">    if (cmd_cookie == (void *)&amp;cmd_loop_cookie) {</a>
<a name="ln597">      // Use &quot;current_line&quot; from &quot;cmd_loop_cookie&quot;, it may have been</a>
<a name="ln598">      // incremented when defining a function.</a>
<a name="ln599">      current_line = cmd_loop_cookie.current_line;</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">    if (next_cmdline == NULL) {</a>
<a name="ln603">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln604"> </a>
<a name="ln605">      // If the command was typed, remember it for the ':' register.</a>
<a name="ln606">      // Do this AFTER executing the command to make :@: work.</a>
<a name="ln607">      if (getline_equal(fgetline, cookie, getexline)</a>
<a name="ln608">          &amp;&amp; new_last_cmdline != NULL) {</a>
<a name="ln609">        xfree(last_cmdline);</a>
<a name="ln610">        last_cmdline = new_last_cmdline;</a>
<a name="ln611">        new_last_cmdline = NULL;</a>
<a name="ln612">      }</a>
<a name="ln613">    } else {</a>
<a name="ln614">      // need to copy the command after the '|' to cmdline_copy, for the</a>
<a name="ln615">      // next do_one_cmd()</a>
<a name="ln616">      STRMOVE(cmdline_copy, next_cmdline);</a>
<a name="ln617">      next_cmdline = cmdline_copy;</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">    // reset did_emsg for a function that is not aborted by an error</a>
<a name="ln621">    if (did_emsg &amp;&amp; !force_abort</a>
<a name="ln622">        &amp;&amp; getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln623">        &amp;&amp; !func_has_abort(real_cookie)) {</a>
<a name="ln624">      did_emsg = false;</a>
<a name="ln625">    }</a>
<a name="ln626"> </a>
<a name="ln627">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln628">      current_line++;</a>
<a name="ln629"> </a>
<a name="ln630">      // An &quot;:endwhile&quot;, &quot;:endfor&quot; and &quot;:continue&quot; is handled here.</a>
<a name="ln631">      // If we were executing commands, jump back to the &quot;:while&quot; or</a>
<a name="ln632">      // &quot;:for&quot;.</a>
<a name="ln633">      // If we were not executing commands, decrement cs_looplevel.</a>
<a name="ln634">      if (cstack.cs_lflags &amp; (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {</a>
<a name="ln635">        cstack.cs_lflags &amp;= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);</a>
<a name="ln636"> </a>
<a name="ln637">        // Jump back to the matching &quot;:while&quot; or &quot;:for&quot;.  Be careful</a>
<a name="ln638">        // not to use a cs_line[] from an entry that isn't a &quot;:while&quot;</a>
<a name="ln639">        // or &quot;:for&quot;: It would make &quot;current_line&quot; invalid and can</a>
<a name="ln640">        // cause a crash.</a>
<a name="ln641">        if (!did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw</a>
<a name="ln642">            &amp;&amp; cstack.cs_idx &gt;= 0</a>
<a name="ln643">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx]</a>
<a name="ln644">                &amp; (CSF_WHILE | CSF_FOR))</a>
<a name="ln645">            &amp;&amp; cstack.cs_line[cstack.cs_idx] &gt;= 0</a>
<a name="ln646">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx] &amp; CSF_ACTIVE)) {</a>
<a name="ln647">          current_line = cstack.cs_line[cstack.cs_idx];</a>
<a name="ln648">          // remember we jumped there</a>
<a name="ln649">          cstack.cs_lflags |= CSL_HAD_LOOP;</a>
<a name="ln650">          line_breakcheck();                    // check if CTRL-C typed</a>
<a name="ln651"> </a>
<a name="ln652">          // Check for the next breakpoint at or after the &quot;:while&quot;</a>
<a name="ln653">          // or &quot;:for&quot;.</a>
<a name="ln654">          if (breakpoint != NULL &amp;&amp; lines_ga.ga_len &gt; current_line) {</a>
<a name="ln655">            *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline), fname,</a>
<a name="ln656">                                              ((wcmd_T *)lines_ga.ga_data)[current_line].lnum - 1);</a>
<a name="ln657">            *dbg_tick = debug_tick;</a>
<a name="ln658">          }</a>
<a name="ln659">        } else {</a>
<a name="ln660">          // can only get here with &quot;:endwhile&quot; or &quot;:endfor&quot;</a>
<a name="ln661">          if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln662">            rewind_conditionals(&amp;cstack, cstack.cs_idx - 1,</a>
<a name="ln663">                                CSF_WHILE | CSF_FOR, &amp;cstack.cs_looplevel);</a>
<a name="ln664">          }</a>
<a name="ln665">        }</a>
<a name="ln666">      } else if (cstack.cs_lflags &amp; CSL_HAD_LOOP) {</a>
<a name="ln667">        // For a &quot;:while&quot; or &quot;:for&quot; we need to remember the line number.</a>
<a name="ln668">        cstack.cs_lflags &amp;= ~CSL_HAD_LOOP;</a>
<a name="ln669">        cstack.cs_line[cstack.cs_idx] = current_line_before;</a>
<a name="ln670">      }</a>
<a name="ln671">    }</a>
<a name="ln672"> </a>
<a name="ln673">    // When not inside any &quot;:while&quot; loop, clear remembered lines.</a>
<a name="ln674">    if (cstack.cs_looplevel == 0) {</a>
<a name="ln675">      if (!GA_EMPTY(&amp;lines_ga)) {</a>
<a name="ln676">        SOURCING_LNUM = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;</a>
<a name="ln677">        GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln678">      }</a>
<a name="ln679">      current_line = 0;</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    // A &quot;:finally&quot; makes did_emsg, got_int and did_throw pending for</a>
<a name="ln683">    // being restored at the &quot;:endtry&quot;.  Reset them here and set the</a>
<a name="ln684">    // ACTIVE and FINALLY flags, so that the finally clause gets executed.</a>
<a name="ln685">    // This includes the case where a missing &quot;:endif&quot;, &quot;:endwhile&quot; or</a>
<a name="ln686">    // &quot;:endfor&quot; was detected by the &quot;:finally&quot; itself.</a>
<a name="ln687">    if (cstack.cs_lflags &amp; CSL_HAD_FINA) {</a>
<a name="ln688">      cstack.cs_lflags &amp;= ~CSL_HAD_FINA;</a>
<a name="ln689">      report_make_pending((cstack.cs_pending[cstack.cs_idx]</a>
<a name="ln690">                           &amp; (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),</a>
<a name="ln691">                          did_throw ? current_exception : NULL);</a>
<a name="ln692">      did_emsg = got_int = did_throw = false;</a>
<a name="ln693">      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    // Update global &quot;trylevel&quot; for recursive calls to do_cmdline() from</a>
<a name="ln697">    // within this loop.</a>
<a name="ln698">    trylevel = initial_trylevel + cstack.cs_trylevel;</a>
<a name="ln699"> </a>
<a name="ln700">    // If the outermost try conditional (across function calls and sourced</a>
<a name="ln701">    // files) is aborted because of an error, an interrupt, or an uncaught</a>
<a name="ln702">    // exception, cancel everything.  If it is left normally, reset</a>
<a name="ln703">    // force_abort to get the non-EH compatible abortion behavior for</a>
<a name="ln704">    // the rest of the script.</a>
<a name="ln705">    if (trylevel == 0 &amp;&amp; !did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw) {</a>
<a name="ln706">      force_abort = false;</a>
<a name="ln707">    }</a>
<a name="ln708"> </a>
<a name="ln709">    // Convert an interrupt to an exception if appropriate.</a>
<a name="ln710">    (void)do_intthrow(&amp;cstack);</a>
<a name="ln711"> </a>
<a name="ln712">    // Continue executing command lines when:</a>
<a name="ln713">    // - no CTRL-C typed, no aborting error, no exception thrown or try</a>
<a name="ln714">    //   conditionals need to be checked for executing finally clauses or</a>
<a name="ln715">    //   catching an interrupt exception</a>
<a name="ln716">    // - didn't get an error message or lines are not typed</a>
<a name="ln717">    // - there is a command after '|', inside a :if, :while, :for or :try, or</a>
<a name="ln718">    //   looping for &quot;:source&quot; command or function call.</a>
<a name="ln719">  } while (!((got_int || (did_emsg &amp;&amp; force_abort) || did_throw)</a>
<a name="ln720">             &amp;&amp; cstack.cs_trylevel == 0)</a>
<a name="ln721">           &amp;&amp; !(did_emsg</a>
<a name="ln722">                // Keep going when inside try/catch, so that the error can be</a>
<a name="ln723">                // deal with, except when it is a syntax error, it may cause</a>
<a name="ln724">                // the :endtry to be missed.</a>
<a name="ln725">                &amp;&amp; (cstack.cs_trylevel == 0 || did_emsg_syntax)</a>
<a name="ln726">                &amp;&amp; used_getline</a>
<a name="ln727">                &amp;&amp; getline_equal(fgetline, cookie, getexline))</a>
<a name="ln728">           &amp;&amp; (next_cmdline != NULL</a>
<a name="ln729">               || cstack.cs_idx &gt;= 0</a>
<a name="ln730">               || (flags &amp; DOCMD_REPEAT)));</a>
<a name="ln731"> </a>
<a name="ln732">  xfree(cmdline_copy);</a>
<a name="ln733">  did_emsg_syntax = false;</a>
<a name="ln734">  GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln735"> </a>
<a name="ln736">  if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln737">    // If a sourced file or executed function ran to its end, report the</a>
<a name="ln738">    // unclosed conditional.</a>
<a name="ln739">    if (!got_int &amp;&amp; !did_throw &amp;&amp; !aborting()</a>
<a name="ln740">        &amp;&amp; ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln741">             &amp;&amp; !source_finished(fgetline, cookie))</a>
<a name="ln742">            || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln743">                &amp;&amp; !func_has_ended(real_cookie)))) {</a>
<a name="ln744">      if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_TRY) {</a>
<a name="ln745">        emsg(_(e_endtry));</a>
<a name="ln746">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_WHILE) {</a>
<a name="ln747">        emsg(_(e_endwhile));</a>
<a name="ln748">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_FOR) {</a>
<a name="ln749">        emsg(_(e_endfor));</a>
<a name="ln750">      } else {</a>
<a name="ln751">        emsg(_(e_endif));</a>
<a name="ln752">      }</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    // Reset &quot;trylevel&quot; in case of a &quot;:finish&quot; or &quot;:return&quot; or a missing</a>
<a name="ln756">    // &quot;:endtry&quot; in a sourced file or executed function.  If the try</a>
<a name="ln757">    // conditional is in its finally clause, ignore anything pending.</a>
<a name="ln758">    // If it is in a catch clause, finish the caught exception.</a>
<a name="ln759">    // Also cleanup any &quot;cs_forinfo&quot; structures.</a>
<a name="ln760">    do {</a>
<a name="ln761">      int idx = cleanup_conditionals(&amp;cstack, 0, true);</a>
<a name="ln762"> </a>
<a name="ln763">      if (idx &gt;= 0) {</a>
<a name="ln764">        idx--;              // remove try block not in its finally clause</a>
<a name="ln765">      }</a>
<a name="ln766">      rewind_conditionals(&amp;cstack, idx, CSF_WHILE | CSF_FOR,</a>
<a name="ln767">                          &amp;cstack.cs_looplevel);</a>
<a name="ln768">    } while (cstack.cs_idx &gt;= 0);</a>
<a name="ln769">    trylevel = initial_trylevel;</a>
<a name="ln770">  }</a>
<a name="ln771"> </a>
<a name="ln772">  // If a missing &quot;:endtry&quot;, &quot;:endwhile&quot;, &quot;:endfor&quot;, or &quot;:endif&quot; or a memory</a>
<a name="ln773">  // lack was reported above and the error message is to be converted to an</a>
<a name="ln774">  // exception, do this now after rewinding the cstack.</a>
<a name="ln775">  do_errthrow(&amp;cstack, getline_equal(fgetline, cookie, get_func_line) ? &quot;endfunction&quot; : NULL);</a>
<a name="ln776"> </a>
<a name="ln777">  if (trylevel == 0) {</a>
<a name="ln778">    // When an exception is being thrown out of the outermost try</a>
<a name="ln779">    // conditional, discard the uncaught exception, disable the conversion</a>
<a name="ln780">    // of interrupts or errors to exceptions, and ensure that no more</a>
<a name="ln781">    // commands are executed.</a>
<a name="ln782">    if (did_throw) {</a>
<a name="ln783">      handle_did_throw();</a>
<a name="ln784">    } else if (got_int || (did_emsg &amp;&amp; force_abort)) {</a>
<a name="ln785">      // On an interrupt or an aborting error not converted to an exception,</a>
<a name="ln786">      // disable the conversion of errors to exceptions.  (Interrupts are not</a>
<a name="ln787">      // converted any more, here.) This enables also the interrupt message</a>
<a name="ln788">      // when force_abort is set and did_emsg unset in case of an interrupt</a>
<a name="ln789">      // from a finally clause after an error.</a>
<a name="ln790">      suppress_errthrow = true;</a>
<a name="ln791">    }</a>
<a name="ln792">  }</a>
<a name="ln793"> </a>
<a name="ln794">  // The current cstack will be freed when do_cmdline() returns.  An uncaught</a>
<a name="ln795">  // exception will have to be rethrown in the previous cstack.  If a function</a>
<a name="ln796">  // has just returned or a script file was just finished and the previous</a>
<a name="ln797">  // cstack belongs to the same function or, respectively, script file, it</a>
<a name="ln798">  // will have to be checked for finally clauses to be executed due to the</a>
<a name="ln799">  // &quot;:return&quot; or &quot;:finish&quot;.  This is done in do_one_cmd().</a>
<a name="ln800">  if (did_throw) {</a>
<a name="ln801">    need_rethrow = true;</a>
<a name="ln802">  }</a>
<a name="ln803">  if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln804">       &amp;&amp; ex_nesting_level &gt; source_level(real_cookie))</a>
<a name="ln805">      || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln806">          &amp;&amp; ex_nesting_level &gt; func_level(real_cookie) + 1)) {</a>
<a name="ln807">    if (!did_throw) {</a>
<a name="ln808">      check_cstack = true;</a>
<a name="ln809">    }</a>
<a name="ln810">  } else {</a>
<a name="ln811">    // When leaving a function, reduce nesting level.</a>
<a name="ln812">    if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln813">      ex_nesting_level--;</a>
<a name="ln814">    }</a>
<a name="ln815">    // Go to debug mode when returning from a function in which we are</a>
<a name="ln816">    // single-stepping.</a>
<a name="ln817">    if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln818">         || getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln819">        &amp;&amp; ex_nesting_level + 1 &lt;= debug_break_level) {</a>
<a name="ln820">      do_debug(getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln821">               ? _(&quot;End of sourced file&quot;)</a>
<a name="ln822">               : _(&quot;End of function&quot;));</a>
<a name="ln823">    }</a>
<a name="ln824">  }</a>
<a name="ln825"> </a>
<a name="ln826">  // Restore the exception environment (done after returning from the</a>
<a name="ln827">  // debugger).</a>
<a name="ln828">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln829">    restore_dbg_stuff(&amp;debug_saved);</a>
<a name="ln830">  }</a>
<a name="ln831"> </a>
<a name="ln832">  msg_list = saved_msg_list;</a>
<a name="ln833"> </a>
<a name="ln834">  // Cleanup if &quot;cs_emsg_silent_list&quot; remains.</a>
<a name="ln835">  if (cstack.cs_emsg_silent_list != NULL) {</a>
<a name="ln836">    eslist_T *elem, *temp;</a>
<a name="ln837">    for (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp) {</a>
<a name="ln838">      temp = elem-&gt;next;</a>
<a name="ln839">      xfree(elem);</a>
<a name="ln840">    }</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  // If there was too much output to fit on the command line, ask the user to</a>
<a name="ln844">  // hit return before redrawing the screen. With the &quot;:global&quot; command we do</a>
<a name="ln845">  // this only once after the command is finished.</a>
<a name="ln846">  if (did_inc) {</a>
<a name="ln847">    RedrawingDisabled--;</a>
<a name="ln848">    no_wait_return--;</a>
<a name="ln849">    msg_scroll = false;</a>
<a name="ln850"> </a>
<a name="ln851">    // When just finished an &quot;:if&quot;-&quot;:else&quot; which was typed, no need to</a>
<a name="ln852">    // wait for hit-return.  Also for an error situation.</a>
<a name="ln853">    if (retval == FAIL</a>
<a name="ln854">        || (did_endif &amp;&amp; KeyTyped &amp;&amp; !did_emsg)) {</a>
<a name="ln855">      need_wait_return = false;</a>
<a name="ln856">      msg_didany = false;               // don't wait when restarting edit</a>
<a name="ln857">    } else if (need_wait_return) {</a>
<a name="ln858">      // The msg_start() above clears msg_didout. The wait_return() we do</a>
<a name="ln859">      // here should not overwrite the command that may be shown before</a>
<a name="ln860">      // doing that.</a>
<a name="ln861">      msg_didout |= msg_didout_before_start;</a>
<a name="ln862">      wait_return(false);</a>
<a name="ln863">    }</a>
<a name="ln864">  }</a>
<a name="ln865"> </a>
<a name="ln866">  did_endif = false;    // in case do_cmdline used recursively</a>
<a name="ln867"> </a>
<a name="ln868">  call_depth--;</a>
<a name="ln869">  end_batch_changes();</a>
<a name="ln870">  return retval;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// Handle when &quot;did_throw&quot; is set after executing commands.</a>
<a name="ln874">void handle_did_throw(void)</a>
<a name="ln875">{</a>
<a name="ln876">  assert(current_exception != NULL);</a>
<a name="ln877">  char *p = NULL;</a>
<a name="ln878">  msglist_T *messages = NULL;</a>
<a name="ln879"> </a>
<a name="ln880">  // If the uncaught exception is a user exception, report it as an</a>
<a name="ln881">  // error.  If it is an error exception, display the saved error</a>
<a name="ln882">  // message now.  For an interrupt exception, do nothing; the</a>
<a name="ln883">  // interrupt message is given elsewhere.</a>
<a name="ln884">  switch (current_exception-&gt;type) {</a>
<a name="ln885">  case ET_USER:</a>
<a name="ln886">    vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln887">                 _(&quot;E605: Exception not caught: %s&quot;),</a>
<a name="ln888">                 current_exception-&gt;value);</a>
<a name="ln889">    p = xstrdup(IObuff);</a>
<a name="ln890">    break;</a>
<a name="ln891">  case ET_ERROR:</a>
<a name="ln892">    messages = current_exception-&gt;messages;</a>
<a name="ln893">    current_exception-&gt;messages = NULL;</a>
<a name="ln894">    break;</a>
<a name="ln895">  case ET_INTERRUPT:</a>
<a name="ln896">    break;</a>
<a name="ln897">  }</a>
<a name="ln898"> </a>
<a name="ln899">  estack_push(ETYPE_EXCEPT, current_exception-&gt;throw_name, current_exception-&gt;throw_lnum);</a>
<a name="ln900">  current_exception-&gt;throw_name = NULL;</a>
<a name="ln901"> </a>
<a name="ln902">  discard_current_exception();              // uses IObuff if 'verbose'</a>
<a name="ln903">  suppress_errthrow = true;</a>
<a name="ln904">  force_abort = true;</a>
<a name="ln905">  msg_ext_set_kind(&quot;emsg&quot;);  // kind=emsg for :throw, exceptions. #9993</a>
<a name="ln906"> </a>
<a name="ln907">  if (messages != NULL) {</a>
<a name="ln908">    do {</a>
<a name="ln909">      msglist_T *next = messages-&gt;next;</a>
<a name="ln910">      emsg_multiline(messages-&gt;msg, messages-&gt;multiline);</a>
<a name="ln911">      xfree(messages-&gt;msg);</a>
<a name="ln912">      xfree(messages-&gt;sfile);</a>
<a name="ln913">      xfree(messages);</a>
<a name="ln914">      messages = next;</a>
<a name="ln915">    } while (messages != NULL);</a>
<a name="ln916">  } else if (p != NULL) {</a>
<a name="ln917">    emsg(p);</a>
<a name="ln918">    xfree(p);</a>
<a name="ln919">  }</a>
<a name="ln920">  xfree(SOURCING_NAME);</a>
<a name="ln921">  estack_pop();</a>
<a name="ln922">}</a>
<a name="ln923"> </a>
<a name="ln924">/// Obtain a line when inside a &quot;:while&quot; or &quot;:for&quot; loop.</a>
<a name="ln925">static char *get_loop_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln926">{</a>
<a name="ln927">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln928"> </a>
<a name="ln929">  if (cp-&gt;current_line + 1 &gt;= cp-&gt;lines_gap-&gt;ga_len) {</a>
<a name="ln930">    if (cp-&gt;repeating) {</a>
<a name="ln931">      return NULL;              // trying to read past &quot;:endwhile&quot;/&quot;:endfor&quot;</a>
<a name="ln932">    }</a>
<a name="ln933">    char *line;</a>
<a name="ln934">    // First time inside the &quot;:while&quot;/&quot;:for&quot;: get line normally.</a>
<a name="ln935">    if (cp-&gt;getline == NULL) {</a>
<a name="ln936">      line = getcmdline(c, 0L, indent, do_concat);</a>
<a name="ln937">    } else {</a>
<a name="ln938">      line = cp-&gt;getline(c, cp-&gt;cookie, indent, do_concat);</a>
<a name="ln939">    }</a>
<a name="ln940">    if (line != NULL) {</a>
<a name="ln941">      store_loop_line(cp-&gt;lines_gap, line);</a>
<a name="ln942">      cp-&gt;current_line++;</a>
<a name="ln943">    }</a>
<a name="ln944"> </a>
<a name="ln945">    return line;</a>
<a name="ln946">  }</a>
<a name="ln947"> </a>
<a name="ln948">  KeyTyped = false;</a>
<a name="ln949">  cp-&gt;current_line++;</a>
<a name="ln950">  wcmd_T *wp = (wcmd_T *)(cp-&gt;lines_gap-&gt;ga_data) + cp-&gt;current_line;</a>
<a name="ln951">  SOURCING_LNUM = wp-&gt;lnum;</a>
<a name="ln952">  return xstrdup(wp-&gt;line);</a>
<a name="ln953">}</a>
<a name="ln954"> </a>
<a name="ln955">/// Store a line in &quot;gap&quot; so that a &quot;:while&quot; loop can execute it again.</a>
<a name="ln956">static void store_loop_line(garray_T *gap, char *line)</a>
<a name="ln957">{</a>
<a name="ln958">  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);</a>
<a name="ln959">  p-&gt;line = xstrdup(line);</a>
<a name="ln960">  p-&gt;lnum = SOURCING_LNUM;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">/// If &quot;fgetline&quot; is get_loop_line(), return true if the getline it uses equals</a>
<a name="ln964">/// &quot;func&quot;.  * Otherwise return true when &quot;fgetline&quot; equals &quot;func&quot;.</a>
<a name="ln965">///</a>
<a name="ln966">/// @param cookie  argument for fgetline()</a>
<a name="ln967">bool getline_equal(LineGetter fgetline, void *cookie, LineGetter func)</a>
<a name="ln968">{</a>
<a name="ln969">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln970">  // function that's originally used to obtain the lines.  This may be</a>
<a name="ln971">  // nested several levels.</a>
<a name="ln972">  LineGetter gp = fgetline;</a>
<a name="ln973">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln974">  while (gp == get_loop_line) {</a>
<a name="ln975">    gp = cp-&gt;getline;</a>
<a name="ln976">    cp = cp-&gt;cookie;</a>
<a name="ln977">  }</a>
<a name="ln978">  return gp == func;</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">/// If &quot;fgetline&quot; is get_loop_line(), return the cookie used by the original</a>
<a name="ln982">/// getline function.  Otherwise return &quot;cookie&quot;.</a>
<a name="ln983">///</a>
<a name="ln984">/// @param cookie  argument for fgetline()</a>
<a name="ln985">void *getline_cookie(LineGetter fgetline, void *cookie)</a>
<a name="ln986">{</a>
<a name="ln987">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln988">  // cookie that's originally used to obtain the lines.  This may be nested</a>
<a name="ln989">  // several levels.</a>
<a name="ln990">  LineGetter gp = fgetline;</a>
<a name="ln991">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln992">  while (gp == get_loop_line) {</a>
<a name="ln993">    gp = cp-&gt;getline;</a>
<a name="ln994">    cp = cp-&gt;cookie;</a>
<a name="ln995">  }</a>
<a name="ln996">  return cp;</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">/// Helper function to apply an offset for buffer commands, i.e. &quot;:bdelete&quot;,</a>
<a name="ln1000">/// &quot;:bwipeout&quot;, etc.</a>
<a name="ln1001">///</a>
<a name="ln1002">/// @return  the buffer number.</a>
<a name="ln1003">static int compute_buffer_local_count(cmd_addr_T addr_type, linenr_T lnum, int offset)</a>
<a name="ln1004">{</a>
<a name="ln1005">  buf_T *nextbuf;</a>
<a name="ln1006">  int count = offset;</a>
<a name="ln1007"> </a>
<a name="ln1008">  buf_T *buf = firstbuf;</a>
<a name="ln1009">  while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_fnum &lt; lnum) {</a>
<a name="ln1010">    buf = buf-&gt;b_next;</a>
<a name="ln1011">  }</a>
<a name="ln1012">  while (count != 0) {</a>
<a name="ln1013">    count += (count &lt; 0) ? 1 : -1;</a>
<a name="ln1014">    nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1015">    if (nextbuf == NULL) {</a>
<a name="ln1016">      break;</a>
<a name="ln1017">    }</a>
<a name="ln1018">    buf = nextbuf;</a>
<a name="ln1019">    if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1020">      // skip over unloaded buffers</a>
<a name="ln1021">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1022">        nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1023">        if (nextbuf == NULL) {</a>
<a name="ln1024">          break;</a>
<a name="ln1025">        }</a>
<a name="ln1026">        buf = nextbuf;</a>
<a name="ln1027">      }</a>
<a name="ln1028">    }</a>
<a name="ln1029">  }</a>
<a name="ln1030">  // we might have gone too far, last buffer is not loaded</a>
<a name="ln1031">  if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1032">    while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1033">      nextbuf = (offset &gt;= 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1034">      if (nextbuf == NULL) {</a>
<a name="ln1035">        break;</a>
<a name="ln1036">      }</a>
<a name="ln1037">      buf = nextbuf;</a>
<a name="ln1038">    }</a>
<a name="ln1039">  }</a>
<a name="ln1040">  return buf-&gt;b_fnum;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">/// @return  the window number of &quot;win&quot; or,</a>
<a name="ln1044">///          the number of windows if &quot;win&quot; is NULL</a>
<a name="ln1045">static int current_win_nr(const win_T *win)</a>
<a name="ln1046">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1047">{</a>
<a name="ln1048">  int nr = 0;</a>
<a name="ln1049"> </a>
<a name="ln1050">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1051">    nr++;</a>
<a name="ln1052">    if (wp == win) {</a>
<a name="ln1053">      break;</a>
<a name="ln1054">    }</a>
<a name="ln1055">  }</a>
<a name="ln1056">  return nr;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">static int current_tab_nr(tabpage_T *tab)</a>
<a name="ln1060">{</a>
<a name="ln1061">  int nr = 0;</a>
<a name="ln1062"> </a>
<a name="ln1063">  FOR_ALL_TABS(tp) {</a>
<a name="ln1064">    nr++;</a>
<a name="ln1065">    if (tp == tab) {</a>
<a name="ln1066">      break;</a>
<a name="ln1067">    }</a>
<a name="ln1068">  }</a>
<a name="ln1069">  return nr;</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">#define CURRENT_WIN_NR current_win_nr(curwin)</a>
<a name="ln1073">#define LAST_WIN_NR current_win_nr(NULL)</a>
<a name="ln1074">#define CURRENT_TAB_NR current_tab_nr(curtab)</a>
<a name="ln1075">#define LAST_TAB_NR current_tab_nr(NULL)</a>
<a name="ln1076"> </a>
<a name="ln1077">/// Figure out the address type for &quot;:wincmd&quot;.</a>
<a name="ln1078">static void get_wincmd_addr_type(const char *arg, exarg_T *eap)</a>
<a name="ln1079">{</a>
<a name="ln1080">  switch (*arg) {</a>
<a name="ln1081">  case 'S':</a>
<a name="ln1082">  case Ctrl_S:</a>
<a name="ln1083">  case 's':</a>
<a name="ln1084">  case Ctrl_N:</a>
<a name="ln1085">  case 'n':</a>
<a name="ln1086">  case 'j':</a>
<a name="ln1087">  case Ctrl_J:</a>
<a name="ln1088">  case 'k':</a>
<a name="ln1089">  case Ctrl_K:</a>
<a name="ln1090">  case 'T':</a>
<a name="ln1091">  case Ctrl_R:</a>
<a name="ln1092">  case 'r':</a>
<a name="ln1093">  case 'R':</a>
<a name="ln1094">  case 'K':</a>
<a name="ln1095">  case 'J':</a>
<a name="ln1096">  case '+':</a>
<a name="ln1097">  case '-':</a>
<a name="ln1098">  case Ctrl__:</a>
<a name="ln1099">  case '_':</a>
<a name="ln1100">  case '|':</a>
<a name="ln1101">  case ']':</a>
<a name="ln1102">  case Ctrl_RSB:</a>
<a name="ln1103">  case 'g':</a>
<a name="ln1104">  case Ctrl_G:</a>
<a name="ln1105">  case Ctrl_V:</a>
<a name="ln1106">  case 'v':</a>
<a name="ln1107">  case 'h':</a>
<a name="ln1108">  case Ctrl_H:</a>
<a name="ln1109">  case 'l':</a>
<a name="ln1110">  case Ctrl_L:</a>
<a name="ln1111">  case 'H':</a>
<a name="ln1112">  case 'L':</a>
<a name="ln1113">  case '&gt;':</a>
<a name="ln1114">  case '&lt;':</a>
<a name="ln1115">  case '}':</a>
<a name="ln1116">  case 'f':</a>
<a name="ln1117">  case 'F':</a>
<a name="ln1118">  case Ctrl_F:</a>
<a name="ln1119">  case 'i':</a>
<a name="ln1120">  case Ctrl_I:</a>
<a name="ln1121">  case 'd':</a>
<a name="ln1122">  case Ctrl_D:</a>
<a name="ln1123">    // window size or any count</a>
<a name="ln1124">    eap-&gt;addr_type = ADDR_OTHER;  // -V1037</a>
<a name="ln1125">    break;</a>
<a name="ln1126"> </a>
<a name="ln1127">  case Ctrl_HAT:</a>
<a name="ln1128">  case '^':</a>
<a name="ln1129">    // buffer number</a>
<a name="ln1130">    eap-&gt;addr_type = ADDR_BUFFERS;</a>
<a name="ln1131">    break;</a>
<a name="ln1132"> </a>
<a name="ln1133">  case Ctrl_Q:</a>
<a name="ln1134">  case 'q':</a>
<a name="ln1135">  case Ctrl_C:</a>
<a name="ln1136">  case 'c':</a>
<a name="ln1137">  case Ctrl_O:</a>
<a name="ln1138">  case 'o':</a>
<a name="ln1139">  case Ctrl_W:</a>
<a name="ln1140">  case 'w':</a>
<a name="ln1141">  case 'W':</a>
<a name="ln1142">  case 'x':</a>
<a name="ln1143">  case Ctrl_X:</a>
<a name="ln1144">    // window number</a>
<a name="ln1145">    eap-&gt;addr_type = ADDR_WINDOWS;</a>
<a name="ln1146">    break;</a>
<a name="ln1147"> </a>
<a name="ln1148">  case Ctrl_Z:</a>
<a name="ln1149">  case 'z':</a>
<a name="ln1150">  case 'P':</a>
<a name="ln1151">  case 't':</a>
<a name="ln1152">  case Ctrl_T:</a>
<a name="ln1153">  case 'b':</a>
<a name="ln1154">  case Ctrl_B:</a>
<a name="ln1155">  case 'p':</a>
<a name="ln1156">  case Ctrl_P:</a>
<a name="ln1157">  case '=':</a>
<a name="ln1158">  case CAR:</a>
<a name="ln1159">    // no count</a>
<a name="ln1160">    eap-&gt;addr_type = ADDR_NONE;</a>
<a name="ln1161">    break;</a>
<a name="ln1162">  }</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">/// Skip colons and trailing whitespace, returning a pointer to the first</a>
<a name="ln1166">/// non-colon, non-whitespace character.</a>
<a name="ln1167">//</a>
<a name="ln1168">/// @param skipleadingwhite Skip leading whitespace too</a>
<a name="ln1169">static char *skip_colon_white(const char *p, bool skipleadingwhite)</a>
<a name="ln1170">{</a>
<a name="ln1171">  if (skipleadingwhite) {</a>
<a name="ln1172">    p = skipwhite(p);</a>
<a name="ln1173">  }</a>
<a name="ln1174"> </a>
<a name="ln1175">  while (*p == ':') {</a>
<a name="ln1176">    p = skipwhite(p + 1);</a>
<a name="ln1177">  }</a>
<a name="ln1178"> </a>
<a name="ln1179">  return (char *)p;</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">/// Set the addr type for command</a>
<a name="ln1183">///</a>
<a name="ln1184">/// @param p pointer to character after command name in cmdline</a>
<a name="ln1185">void set_cmd_addr_type(exarg_T *eap, char *p)</a>
<a name="ln1186">{</a>
<a name="ln1187">  // ea.addr_type for user commands is set by find_ucmd</a>
<a name="ln1188">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1189">    return;</a>
<a name="ln1190">  }</a>
<a name="ln1191">  if (eap-&gt;cmdidx != CMD_SIZE) {</a>
<a name="ln1192">    eap-&gt;addr_type = cmdnames[(int)eap-&gt;cmdidx].cmd_addr_type;</a>
<a name="ln1193">  } else {</a>
<a name="ln1194">    eap-&gt;addr_type = ADDR_LINES;</a>
<a name="ln1195">  }</a>
<a name="ln1196">  // :wincmd range depends on the argument</a>
<a name="ln1197">  if (eap-&gt;cmdidx == CMD_wincmd &amp;&amp; p != NULL) {</a>
<a name="ln1198">    get_wincmd_addr_type(skipwhite(p), eap);</a>
<a name="ln1199">  }</a>
<a name="ln1200">  // :.cc in quickfix window uses line number</a>
<a name="ln1201">  if ((eap-&gt;cmdidx == CMD_cc || eap-&gt;cmdidx == CMD_ll) &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln1202">    eap-&gt;addr_type = ADDR_OTHER;</a>
<a name="ln1203">  }</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">/// Get default range number for command based on its address type</a>
<a name="ln1207">linenr_T get_cmd_default_range(exarg_T *eap)</a>
<a name="ln1208">{</a>
<a name="ln1209">  switch (eap-&gt;addr_type) {</a>
<a name="ln1210">  case ADDR_LINES:</a>
<a name="ln1211">  case ADDR_OTHER:</a>
<a name="ln1212">    // Default is the cursor line number.  Avoid using an invalid</a>
<a name="ln1213">    // line number though.</a>
<a name="ln1214">    return MIN(curwin-&gt;w_cursor.lnum, curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln1215">    break;</a>
<a name="ln1216">  case ADDR_WINDOWS:</a>
<a name="ln1217">    return CURRENT_WIN_NR;</a>
<a name="ln1218">    break;</a>
<a name="ln1219">  case ADDR_ARGUMENTS:</a>
<a name="ln1220">    return MIN(curwin-&gt;w_arg_idx + 1, ARGCOUNT);</a>
<a name="ln1221">    break;</a>
<a name="ln1222">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1223">  case ADDR_BUFFERS:</a>
<a name="ln1224">    return curbuf-&gt;b_fnum;</a>
<a name="ln1225">    break;</a>
<a name="ln1226">  case ADDR_TABS:</a>
<a name="ln1227">    return CURRENT_TAB_NR;</a>
<a name="ln1228">    break;</a>
<a name="ln1229">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1230">  case ADDR_UNSIGNED:</a>
<a name="ln1231">    return 1;</a>
<a name="ln1232">    break;</a>
<a name="ln1233">  case ADDR_QUICKFIX:</a>
<a name="ln1234">    return (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln1235">    break;</a>
<a name="ln1236">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1237">    return qf_get_cur_valid_idx(eap);</a>
<a name="ln1238">    break;</a>
<a name="ln1239">  default:</a>
<a name="ln1240">    return 0;</a>
<a name="ln1241">    // Will give an error later if a range is found.</a>
<a name="ln1242">    break;</a>
<a name="ln1243">  }</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">/// Set default command range for -range=% based on the addr type of the command</a>
<a name="ln1247">void set_cmd_dflall_range(exarg_T *eap)</a>
<a name="ln1248">{</a>
<a name="ln1249">  buf_T *buf;</a>
<a name="ln1250"> </a>
<a name="ln1251">  eap-&gt;line1 = 1;</a>
<a name="ln1252">  switch (eap-&gt;addr_type) {</a>
<a name="ln1253">  case ADDR_LINES:</a>
<a name="ln1254">  case ADDR_OTHER:</a>
<a name="ln1255">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1256">    break;</a>
<a name="ln1257">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1258">    buf = firstbuf;</a>
<a name="ln1259">    while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1260">      buf = buf-&gt;b_next;</a>
<a name="ln1261">    }</a>
<a name="ln1262">    eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln1263">    buf = lastbuf;</a>
<a name="ln1264">    while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1265">      buf = buf-&gt;b_prev;</a>
<a name="ln1266">    }</a>
<a name="ln1267">    eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln1268">    break;</a>
<a name="ln1269">  case ADDR_BUFFERS:</a>
<a name="ln1270">    eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln1271">    eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln1272">    break;</a>
<a name="ln1273">  case ADDR_WINDOWS:</a>
<a name="ln1274">    eap-&gt;line2 = LAST_WIN_NR;</a>
<a name="ln1275">    break;</a>
<a name="ln1276">  case ADDR_TABS:</a>
<a name="ln1277">    eap-&gt;line2 = LAST_TAB_NR;</a>
<a name="ln1278">    break;</a>
<a name="ln1279">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1280">    eap-&gt;line2 = 1;</a>
<a name="ln1281">    break;</a>
<a name="ln1282">  case ADDR_ARGUMENTS:</a>
<a name="ln1283">    if (ARGCOUNT == 0) {</a>
<a name="ln1284">      eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln1285">    } else {</a>
<a name="ln1286">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln1287">    }</a>
<a name="ln1288">    break;</a>
<a name="ln1289">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1290">    eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln1291">    if (eap-&gt;line2 == 0) {</a>
<a name="ln1292">      eap-&gt;line2 = 1;</a>
<a name="ln1293">    }</a>
<a name="ln1294">    break;</a>
<a name="ln1295">  case ADDR_NONE:</a>
<a name="ln1296">  case ADDR_UNSIGNED:</a>
<a name="ln1297">  case ADDR_QUICKFIX:</a>
<a name="ln1298">    iemsg(_(&quot;INTERNAL: Cannot use EX_DFLALL &quot;</a>
<a name="ln1299">            &quot;with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX&quot;));</a>
<a name="ln1300">    break;</a>
<a name="ln1301">  }</a>
<a name="ln1302">}</a>
<a name="ln1303"> </a>
<a name="ln1304">static void parse_register(exarg_T *eap)</a>
<a name="ln1305">{</a>
<a name="ln1306">  // Accept numbered register only when no count allowed (:put)</a>
<a name="ln1307">  if ((eap-&gt;argt &amp; EX_REGSTR)</a>
<a name="ln1308">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln1309">      // Do not allow register = for user commands</a>
<a name="ln1310">      &amp;&amp; (!IS_USER_CMDIDX(eap-&gt;cmdidx) || *eap-&gt;arg != '=')</a>
<a name="ln1311">      &amp;&amp; !((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg))) {</a>
<a name="ln1312">    if (valid_yank_reg(*eap-&gt;arg, (eap-&gt;cmdidx != CMD_put</a>
<a name="ln1313">                                   &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)))) {</a>
<a name="ln1314">      eap-&gt;regname = (uint8_t)(*eap-&gt;arg++);</a>
<a name="ln1315">      // for '=' register: accept the rest of the line as an expression</a>
<a name="ln1316">      if (eap-&gt;arg[-1] == '=' &amp;&amp; eap-&gt;arg[0] != NUL) {</a>
<a name="ln1317">        if (!eap-&gt;skip) {</a>
<a name="ln1318">          set_expr_line(xstrdup(eap-&gt;arg));</a>
<a name="ln1319">        }</a>
<a name="ln1320">        eap-&gt;arg += strlen(eap-&gt;arg);</a>
<a name="ln1321">      }</a>
<a name="ln1322">      eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1323">    }</a>
<a name="ln1324">  }</a>
<a name="ln1325">}</a>
<a name="ln1326"> </a>
<a name="ln1327">// Change line1 and line2 of Ex command to use count</a>
<a name="ln1328">void set_cmd_count(exarg_T *eap, linenr_T count, bool validate)</a>
<a name="ln1329">{</a>
<a name="ln1330">  if (eap-&gt;addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3</a>
<a name="ln1331">    eap-&gt;line2 = count;</a>
<a name="ln1332">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln1333">      eap-&gt;addr_count = 1;</a>
<a name="ln1334">    }</a>
<a name="ln1335">  } else {</a>
<a name="ln1336">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln1337">    eap-&gt;line2 += count - 1;</a>
<a name="ln1338">    eap-&gt;addr_count++;</a>
<a name="ln1339">    // Be vi compatible: no error message for out of range.</a>
<a name="ln1340">    if (validate &amp;&amp; eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1341">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1342">    }</a>
<a name="ln1343">  }</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">static int parse_count(exarg_T *eap, const char **errormsg, bool validate)</a>
<a name="ln1347">{</a>
<a name="ln1348">  // Check for a count.  When accepting a EX_BUFNAME, don't use &quot;123foo&quot; as a</a>
<a name="ln1349">  // count, it's a buffer name.</a>
<a name="ln1350">  char *p;</a>
<a name="ln1351"> </a>
<a name="ln1352">  if ((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg)</a>
<a name="ln1353">      &amp;&amp; (!(eap-&gt;argt &amp; EX_BUFNAME) || *(p = skipdigits(eap-&gt;arg + 1)) == NUL</a>
<a name="ln1354">          || ascii_iswhite(*p))) {</a>
<a name="ln1355">    linenr_T n = getdigits_int32(&amp;eap-&gt;arg, false, -1);</a>
<a name="ln1356">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1357"> </a>
<a name="ln1358">    if (eap-&gt;args != NULL) {</a>
<a name="ln1359">      assert(eap-&gt;argc &gt; 0 &amp;&amp; eap-&gt;arg &gt;= eap-&gt;args[0]);</a>
<a name="ln1360">      // If eap-&gt;arg is still pointing to the first argument, just make eap-&gt;args[0] point to the</a>
<a name="ln1361">      // same location. This is needed for usecases like vim.cmd.sleep('10m'). If eap-&gt;arg is</a>
<a name="ln1362">      // pointing outside the first argument, shift arguments by 1.</a>
<a name="ln1363">      if (eap-&gt;arg &lt; eap-&gt;args[0] + eap-&gt;arglens[0]) {</a>
<a name="ln1364">        eap-&gt;arglens[0] -= (size_t)(eap-&gt;arg - eap-&gt;args[0]);</a>
<a name="ln1365">        eap-&gt;args[0] = eap-&gt;arg;</a>
<a name="ln1366">      } else {</a>
<a name="ln1367">        shift_cmd_args(eap);</a>
<a name="ln1368">      }</a>
<a name="ln1369">    }</a>
<a name="ln1370"> </a>
<a name="ln1371">    if (n &lt;= 0 &amp;&amp; (eap-&gt;argt &amp; EX_ZEROR) == 0) {</a>
<a name="ln1372">      if (errormsg != NULL) {</a>
<a name="ln1373">        *errormsg = _(e_zerocount);</a>
<a name="ln1374">      }</a>
<a name="ln1375">      return FAIL;</a>
<a name="ln1376">    }</a>
<a name="ln1377">    set_cmd_count(eap, n, validate);</a>
<a name="ln1378">  }</a>
<a name="ln1379"> </a>
<a name="ln1380">  return OK;</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">/// Check if command is not implemented</a>
<a name="ln1384">bool is_cmd_ni(cmdidx_T cmdidx)</a>
<a name="ln1385">{</a>
<a name="ln1386">  return !IS_USER_CMDIDX(cmdidx) &amp;&amp; (cmdnames[cmdidx].cmd_func == ex_ni</a>
<a name="ln1387">                                     || cmdnames[cmdidx].cmd_func == ex_script_ni);</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">/// Parse command line and return information about the first command.</a>
<a name="ln1391">/// If parsing is done successfully, need to free cmod_filter_pat and cmod_filter_regmatch.regprog</a>
<a name="ln1392">/// after calling, usually done using undo_cmdmod() or execute_cmd().</a>
<a name="ln1393">///</a>
<a name="ln1394">/// @param cmdline Command line string</a>
<a name="ln1395">/// @param[out] eap Ex command arguments</a>
<a name="ln1396">/// @param[out] cmdinfo Command parse information</a>
<a name="ln1397">/// @param[out] errormsg Error message, if any</a>
<a name="ln1398">///</a>
<a name="ln1399">/// @return Success or failure</a>
<a name="ln1400">bool parse_cmdline(char *cmdline, exarg_T *eap, CmdParseInfo *cmdinfo, const char **errormsg)</a>
<a name="ln1401">{</a>
<a name="ln1402">  char *after_modifier = NULL;</a>
<a name="ln1403">  bool retval = false;</a>
<a name="ln1404">  // parsing the command modifiers may set ex_pressedreturn</a>
<a name="ln1405">  const bool save_ex_pressedreturn = ex_pressedreturn;</a>
<a name="ln1406">  // parsing the command range may require moving the cursor</a>
<a name="ln1407">  const pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln1408">  // parsing the command range may set the last search pattern</a>
<a name="ln1409">  save_last_search_pattern();</a>
<a name="ln1410"> </a>
<a name="ln1411">  // Initialize cmdinfo</a>
<a name="ln1412">  CLEAR_POINTER(cmdinfo);</a>
<a name="ln1413"> </a>
<a name="ln1414">  // Initialize eap</a>
<a name="ln1415">  *eap = (exarg_T){</a>
<a name="ln1416">    .line1 = 1,</a>
<a name="ln1417">    .line2 = 1,</a>
<a name="ln1418">    .cmd = cmdline,</a>
<a name="ln1419">    .cmdlinep = &amp;cmdline,</a>
<a name="ln1420">    .getline = NULL,</a>
<a name="ln1421">    .cookie = NULL,</a>
<a name="ln1422">  };</a>
<a name="ln1423"> </a>
<a name="ln1424">  // Parse command modifiers</a>
<a name="ln1425">  if (parse_command_modifiers(eap, errormsg, &amp;cmdinfo-&gt;cmdmod, false) == FAIL) {</a>
<a name="ln1426">    goto end;</a>
<a name="ln1427">  }</a>
<a name="ln1428">  after_modifier = eap-&gt;cmd;</a>
<a name="ln1429"> </a>
<a name="ln1430">  // Save location after command modifiers</a>
<a name="ln1431">  char *cmd = eap-&gt;cmd;</a>
<a name="ln1432">  // Skip ranges to find command name since we need the command to know what kind of range it uses</a>
<a name="ln1433">  eap-&gt;cmd = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln1434">  if (*eap-&gt;cmd == '*') {</a>
<a name="ln1435">    eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln1436">  }</a>
<a name="ln1437">  char *p = find_ex_command(eap, NULL);</a>
<a name="ln1438">  if (p == NULL) {</a>
<a name="ln1439">    *errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln1440">    goto end;</a>
<a name="ln1441">  }</a>
<a name="ln1442"> </a>
<a name="ln1443">  // Set command address type and parse command range</a>
<a name="ln1444">  set_cmd_addr_type(eap, p);</a>
<a name="ln1445">  eap-&gt;cmd = cmd;</a>
<a name="ln1446">  if (parse_cmd_address(eap, errormsg, true) == FAIL) {</a>
<a name="ln1447">    goto end;</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  // Skip colon and whitespace</a>
<a name="ln1451">  eap-&gt;cmd = skip_colon_white(eap-&gt;cmd, true);</a>
<a name="ln1452">  // Fail if command is a comment or if command doesn't exist</a>
<a name="ln1453">  if (*eap-&gt;cmd == NUL || *eap-&gt;cmd == '&quot;') {</a>
<a name="ln1454">    goto end;</a>
<a name="ln1455">  }</a>
<a name="ln1456">  // Fail if command is invalid</a>
<a name="ln1457">  if (eap-&gt;cmdidx == CMD_SIZE) {</a>
<a name="ln1458">    xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln1459">    // If the modifier was parsed OK the error must be in the following command</a>
<a name="ln1460">    char *cmdname = after_modifier ? after_modifier : cmdline;</a>
<a name="ln1461">    append_command(cmdname);</a>
<a name="ln1462">    *errormsg = IObuff;</a>
<a name="ln1463">    goto end;</a>
<a name="ln1464">  }</a>
<a name="ln1465"> </a>
<a name="ln1466">  // Correctly set 'forceit' for commands</a>
<a name="ln1467">  if (*p == '!' &amp;&amp; eap-&gt;cmdidx != CMD_substitute</a>
<a name="ln1468">      &amp;&amp; eap-&gt;cmdidx != CMD_smagic &amp;&amp; eap-&gt;cmdidx != CMD_snomagic) {</a>
<a name="ln1469">    p++;</a>
<a name="ln1470">    eap-&gt;forceit = true;</a>
<a name="ln1471">  } else {</a>
<a name="ln1472">    eap-&gt;forceit = false;</a>
<a name="ln1473">  }</a>
<a name="ln1474"> </a>
<a name="ln1475">  // Parse arguments.</a>
<a name="ln1476">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1477">    eap-&gt;argt = cmdnames[(int)eap-&gt;cmdidx].cmd_argt;</a>
<a name="ln1478">  }</a>
<a name="ln1479">  // Skip to start of argument.</a>
<a name="ln1480">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln1481">  if (eap-&gt;cmdidx == CMD_bang) {</a>
<a name="ln1482">    eap-&gt;arg = p;</a>
<a name="ln1483">  } else {</a>
<a name="ln1484">    eap-&gt;arg = skipwhite(p);</a>
<a name="ln1485">  }</a>
<a name="ln1486"> </a>
<a name="ln1487">  // Don't treat &quot;:r! filter&quot; like a bang</a>
<a name="ln1488">  if (eap-&gt;cmdidx == CMD_read) {</a>
<a name="ln1489">    if (eap-&gt;forceit) {</a>
<a name="ln1490">      eap-&gt;forceit = false;                     // :r! filter</a>
<a name="ln1491">    }</a>
<a name="ln1492">  }</a>
<a name="ln1493"> </a>
<a name="ln1494">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln1495">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1496">  if ((eap-&gt;argt &amp; EX_TRLBAR)) {</a>
<a name="ln1497">    separate_nextcmd(eap);</a>
<a name="ln1498">  }</a>
<a name="ln1499">  // Fail if command doesn't support bang but is used with a bang</a>
<a name="ln1500">  if (!(eap-&gt;argt &amp; EX_BANG) &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln1501">    *errormsg = _(e_nobang);</a>
<a name="ln1502">    goto end;</a>
<a name="ln1503">  }</a>
<a name="ln1504">  // Fail if command doesn't support a range but it is given a range</a>
<a name="ln1505">  if (!(eap-&gt;argt &amp; EX_RANGE) &amp;&amp; eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1506">    *errormsg = _(e_norange);</a>
<a name="ln1507">    goto end;</a>
<a name="ln1508">  }</a>
<a name="ln1509">  // Set default range for command if required</a>
<a name="ln1510">  if ((eap-&gt;argt &amp; EX_DFLALL) &amp;&amp; eap-&gt;addr_count == 0) {</a>
<a name="ln1511">    set_cmd_dflall_range(eap);</a>
<a name="ln1512">  }</a>
<a name="ln1513"> </a>
<a name="ln1514">  // Parse register and count</a>
<a name="ln1515">  parse_register(eap);</a>
<a name="ln1516">  if (parse_count(eap, errormsg, false) == FAIL) {</a>
<a name="ln1517">    goto end;</a>
<a name="ln1518">  }</a>
<a name="ln1519"> </a>
<a name="ln1520">  // Remove leading whitespace and colon from next command</a>
<a name="ln1521">  if (eap-&gt;nextcmd) {</a>
<a name="ln1522">    eap-&gt;nextcmd = skip_colon_white(eap-&gt;nextcmd, true);</a>
<a name="ln1523">  }</a>
<a name="ln1524"> </a>
<a name="ln1525">  // Set the &quot;magic&quot; values (characters that get treated specially)</a>
<a name="ln1526">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1527">    cmdinfo-&gt;magic.file = true;</a>
<a name="ln1528">  }</a>
<a name="ln1529">  if (eap-&gt;argt &amp; EX_TRLBAR) {</a>
<a name="ln1530">    cmdinfo-&gt;magic.bar = true;</a>
<a name="ln1531">  }</a>
<a name="ln1532"> </a>
<a name="ln1533">  retval = true;</a>
<a name="ln1534">end:</a>
<a name="ln1535">  if (!retval) {</a>
<a name="ln1536">    undo_cmdmod(&amp;cmdinfo-&gt;cmdmod);</a>
<a name="ln1537">  }</a>
<a name="ln1538">  ex_pressedreturn = save_ex_pressedreturn;</a>
<a name="ln1539">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln1540">  restore_last_search_pattern();</a>
<a name="ln1541">  return retval;</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">// Shift Ex-command arguments to the right.</a>
<a name="ln1545">static void shift_cmd_args(exarg_T *eap)</a>
<a name="ln1546">{</a>
<a name="ln1547">  assert(eap-&gt;args != NULL &amp;&amp; eap-&gt;argc &gt; 0);</a>
<a name="ln1548"> </a>
<a name="ln1549">  char **oldargs = eap-&gt;args;</a>
<a name="ln1550">  size_t *oldarglens = eap-&gt;arglens;</a>
<a name="ln1551"> </a>
<a name="ln1552">  eap-&gt;argc--;</a>
<a name="ln1553">  eap-&gt;args = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(char *)) : NULL;</a>
<a name="ln1554">  eap-&gt;arglens = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(size_t)) : NULL;</a>
<a name="ln1555"> </a>
<a name="ln1556">  for (size_t i = 0; i &lt; eap-&gt;argc; i++) {</a>
<a name="ln1557">    eap-&gt;args[i] = oldargs[i + 1];</a>
<a name="ln1558">    eap-&gt;arglens[i] = oldarglens[i + 1];</a>
<a name="ln1559">  }</a>
<a name="ln1560"> </a>
<a name="ln1561">  // If there are no arguments, make eap-&gt;arg point to the end of string.</a>
<a name="ln1562">  eap-&gt;arg = (eap-&gt;argc &gt; 0 ? eap-&gt;args[0] : (oldargs[0] + oldarglens[0]));</a>
<a name="ln1563"> </a>
<a name="ln1564">  xfree(oldargs);</a>
<a name="ln1565">  xfree(oldarglens);</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">static int execute_cmd0(int *retv, exarg_T *eap, const char **errormsg, bool preview)</a>
<a name="ln1569">{</a>
<a name="ln1570">  // If filename expansion is enabled, expand filenames</a>
<a name="ln1571">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1572">    if (expand_filename(eap, eap-&gt;cmdlinep, errormsg) == FAIL) {</a>
<a name="ln1573">      return FAIL;</a>
<a name="ln1574">    }</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  // Accept buffer name.  Cannot be used at the same time with a buffer</a>
<a name="ln1578">  // number.  Don't do this for a user command.</a>
<a name="ln1579">  if ((eap-&gt;argt &amp; EX_BUFNAME) &amp;&amp; *eap-&gt;arg != NUL &amp;&amp; eap-&gt;addr_count == 0</a>
<a name="ln1580">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1581">    if (eap-&gt;args == NULL) {</a>
<a name="ln1582">      // If argument positions are not specified, search the argument for the buffer name.</a>
<a name="ln1583">      // :bdelete, :bwipeout and :bunload take several arguments, separated by spaces:</a>
<a name="ln1584">      // find next space (skipping over escaped characters).</a>
<a name="ln1585">      // The others take one argument: ignore trailing spaces.</a>
<a name="ln1586">      char *p;</a>
<a name="ln1587"> </a>
<a name="ln1588">      if (eap-&gt;cmdidx == CMD_bdelete || eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln1589">          || eap-&gt;cmdidx == CMD_bunload) {</a>
<a name="ln1590">        p = skiptowhite_esc(eap-&gt;arg);</a>
<a name="ln1591">      } else {</a>
<a name="ln1592">        p = eap-&gt;arg + strlen(eap-&gt;arg);</a>
<a name="ln1593">        while (p &gt; eap-&gt;arg &amp;&amp; ascii_iswhite(p[-1])) {</a>
<a name="ln1594">          p--;</a>
<a name="ln1595">        }</a>
<a name="ln1596">      }</a>
<a name="ln1597">      eap-&gt;line2 = buflist_findpat(eap-&gt;arg, p, (eap-&gt;argt &amp; EX_BUFUNL) != 0,</a>
<a name="ln1598">                                   false, false);</a>
<a name="ln1599">      eap-&gt;addr_count = 1;</a>
<a name="ln1600">      eap-&gt;arg = skipwhite(p);</a>
<a name="ln1601">    } else {</a>
<a name="ln1602">      // If argument positions are specified, just use the first argument</a>
<a name="ln1603">      eap-&gt;line2 = buflist_findpat(eap-&gt;args[0],</a>
<a name="ln1604">                                   eap-&gt;args[0] + eap-&gt;arglens[0],</a>
<a name="ln1605">                                   (eap-&gt;argt &amp; EX_BUFUNL) != 0, false, false);</a>
<a name="ln1606">      eap-&gt;addr_count = 1;</a>
<a name="ln1607">      shift_cmd_args(eap);</a>
<a name="ln1608">    }</a>
<a name="ln1609">    if (eap-&gt;line2 &lt; 0) {  // failed</a>
<a name="ln1610">      return FAIL;</a>
<a name="ln1611">    }</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  // The :try command saves the emsg_silent flag, reset it here when</a>
<a name="ln1615">  // &quot;:silent! try&quot; was used, it should only apply to :try itself.</a>
<a name="ln1616">  if (eap-&gt;cmdidx == CMD_try &amp;&amp; cmdmod.cmod_did_esilent &gt; 0) {</a>
<a name="ln1617">    emsg_silent -= cmdmod.cmod_did_esilent;</a>
<a name="ln1618">    if (emsg_silent &lt; 0) {</a>
<a name="ln1619">      emsg_silent = 0;</a>
<a name="ln1620">    }</a>
<a name="ln1621">    cmdmod.cmod_did_esilent = 0;</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  // Execute the command</a>
<a name="ln1625">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1626">    // Execute a user-defined command.</a>
<a name="ln1627">    *retv = do_ucmd(eap, preview);</a>
<a name="ln1628">  } else {</a>
<a name="ln1629">    // Call the function to execute the builtin command or the preview callback.</a>
<a name="ln1630">    eap-&gt;errmsg = NULL;</a>
<a name="ln1631">    if (preview) {</a>
<a name="ln1632">      *retv = (cmdnames[eap-&gt;cmdidx].cmd_preview_func)(eap, cmdpreview_get_ns(),</a>
<a name="ln1633">                                                       cmdpreview_get_bufnr());</a>
<a name="ln1634">    } else {</a>
<a name="ln1635">      (cmdnames[eap-&gt;cmdidx].cmd_func)(eap);</a>
<a name="ln1636">    }</a>
<a name="ln1637">    if (eap-&gt;errmsg != NULL) {</a>
<a name="ln1638">      *errormsg = eap-&gt;errmsg;</a>
<a name="ln1639">    }</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  return OK;</a>
<a name="ln1643">}</a>
<a name="ln1644"> </a>
<a name="ln1645">/// Execute an Ex command using parsed command line information.</a>
<a name="ln1646">/// Does not do any validation of the Ex command arguments.</a>
<a name="ln1647">///</a>
<a name="ln1648">/// @param eap Ex-command arguments</a>
<a name="ln1649">/// @param cmdinfo Command parse information</a>
<a name="ln1650">/// @param preview Execute command preview callback instead of actual command</a>
<a name="ln1651">int execute_cmd(exarg_T *eap, CmdParseInfo *cmdinfo, bool preview)</a>
<a name="ln1652">{</a>
<a name="ln1653">  const char *errormsg = NULL;</a>
<a name="ln1654">  int retv = 0;</a>
<a name="ln1655"> </a>
<a name="ln1656">#undef ERROR</a>
<a name="ln1657">#define ERROR(msg) \</a>
<a name="ln1658">  do { \</a>
<a name="ln1659">    errormsg = msg; \</a>
<a name="ln1660">    goto end; \</a>
<a name="ln1661">  } while (0)</a>
<a name="ln1662"> </a>
<a name="ln1663">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1664">  cmdmod = cmdinfo-&gt;cmdmod;</a>
<a name="ln1665"> </a>
<a name="ln1666">  // Apply command modifiers</a>
<a name="ln1667">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1668"> </a>
<a name="ln1669">  if (!MODIFIABLE(curbuf) &amp;&amp; (eap-&gt;argt &amp; EX_MODIFY)</a>
<a name="ln1670">      // allow :put in terminals</a>
<a name="ln1671">      &amp;&amp; !(curbuf-&gt;terminal &amp;&amp; eap-&gt;cmdidx == CMD_put)) {</a>
<a name="ln1672">    ERROR(_(e_modifiable));</a>
<a name="ln1673">  }</a>
<a name="ln1674">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1675">    if (cmdwin_type != 0 &amp;&amp; !(eap-&gt;argt &amp; EX_CMDWIN)) {</a>
<a name="ln1676">      // Command not allowed in the command line window</a>
<a name="ln1677">      ERROR(_(e_cmdwin));</a>
<a name="ln1678">    }</a>
<a name="ln1679">    if (text_locked() &amp;&amp; !(eap-&gt;argt &amp; EX_LOCK_OK)) {</a>
<a name="ln1680">      // Command not allowed when text is locked</a>
<a name="ln1681">      ERROR(_(get_text_locked_msg()));</a>
<a name="ln1682">    }</a>
<a name="ln1683">  }</a>
<a name="ln1684">  // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln1685">  // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln1686">  // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln1687">  // Do allow &quot;:file&quot; with no arguments</a>
<a name="ln1688">  if (!(eap-&gt;argt &amp; EX_CMDWIN)</a>
<a name="ln1689">      &amp;&amp; eap-&gt;cmdidx != CMD_checktime</a>
<a name="ln1690">      &amp;&amp; eap-&gt;cmdidx != CMD_edit</a>
<a name="ln1691">      &amp;&amp; !(eap-&gt;cmdidx == CMD_file &amp;&amp; *eap-&gt;arg == NUL)</a>
<a name="ln1692">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)</a>
<a name="ln1693">      &amp;&amp; curbuf_locked()) {</a>
<a name="ln1694">    goto end;</a>
<a name="ln1695">  }</a>
<a name="ln1696"> </a>
<a name="ln1697">  correct_range(eap);</a>
<a name="ln1698"> </a>
<a name="ln1699">  if (((eap-&gt;argt &amp; EX_WHOLEFOLD) || eap-&gt;addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln1700">      &amp;&amp; eap-&gt;addr_type == ADDR_LINES) {</a>
<a name="ln1701">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln1702">    // at the end of a closed fold.</a>
<a name="ln1703">    (void)hasFolding(eap-&gt;line1, &amp;eap-&gt;line1, NULL);</a>
<a name="ln1704">    (void)hasFolding(eap-&gt;line2, NULL, &amp;eap-&gt;line2);</a>
<a name="ln1705">  }</a>
<a name="ln1706"> </a>
<a name="ln1707">  // Use first argument as count when possible</a>
<a name="ln1708">  if (parse_count(eap, &amp;errormsg, true) == FAIL) {</a>
<a name="ln1709">    goto end;</a>
<a name="ln1710">  }</a>
<a name="ln1711"> </a>
<a name="ln1712">  // Execute the command</a>
<a name="ln1713">  execute_cmd0(&amp;retv, eap, &amp;errormsg, preview);</a>
<a name="ln1714"> </a>
<a name="ln1715">end:</a>
<a name="ln1716">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln1717">    emsg(errormsg);</a>
<a name="ln1718">  }</a>
<a name="ln1719">  // Undo command modifiers</a>
<a name="ln1720">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln1721">  cmdmod = save_cmdmod;</a>
<a name="ln1722">  return retv;</a>
<a name="ln1723">#undef ERROR</a>
<a name="ln1724">}</a>
<a name="ln1725"> </a>
<a name="ln1726">static void profile_cmd(const exarg_T *eap, cstack_T *cstack, LineGetter fgetline, void *cookie)</a>
<a name="ln1727">{</a>
<a name="ln1728">  // Count this line for profiling if skip is true.</a>
<a name="ln1729">  if (do_profiling == PROF_YES</a>
<a name="ln1730">      &amp;&amp; (!eap-&gt;skip || cstack-&gt;cs_idx == 0</a>
<a name="ln1731">          || (cstack-&gt;cs_idx &gt; 0</a>
<a name="ln1732">              &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx - 1] &amp; CSF_ACTIVE)))) {</a>
<a name="ln1733">    bool skip = did_emsg || got_int || did_throw;</a>
<a name="ln1734"> </a>
<a name="ln1735">    if (eap-&gt;cmdidx == CMD_catch) {</a>
<a name="ln1736">      skip = !skip &amp;&amp; !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1737">                        &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_THROWN)</a>
<a name="ln1738">                        &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_CAUGHT));</a>
<a name="ln1739">    } else if (eap-&gt;cmdidx == CMD_else || eap-&gt;cmdidx == CMD_elseif) {</a>
<a name="ln1740">      skip = skip || !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1741">                       &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx]</a>
<a name="ln1742">                            &amp; (CSF_ACTIVE | CSF_TRUE)));</a>
<a name="ln1743">    } else if (eap-&gt;cmdidx == CMD_finally) {</a>
<a name="ln1744">      skip = false;</a>
<a name="ln1745">    } else if (eap-&gt;cmdidx != CMD_endif</a>
<a name="ln1746">               &amp;&amp; eap-&gt;cmdidx != CMD_endfor</a>
<a name="ln1747">               &amp;&amp; eap-&gt;cmdidx != CMD_endtry</a>
<a name="ln1748">               &amp;&amp; eap-&gt;cmdidx != CMD_endwhile) {</a>
<a name="ln1749">      skip = eap-&gt;skip;</a>
<a name="ln1750">    }</a>
<a name="ln1751"> </a>
<a name="ln1752">    if (!skip) {</a>
<a name="ln1753">      if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln1754">        func_line_exec(getline_cookie(fgetline, cookie));</a>
<a name="ln1755">      } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln1756">        script_line_exec();</a>
<a name="ln1757">      }</a>
<a name="ln1758">    }</a>
<a name="ln1759">  }</a>
<a name="ln1760">}</a>
<a name="ln1761"> </a>
<a name="ln1762">static bool skip_cmd(const exarg_T *eap)</a>
<a name="ln1763">{</a>
<a name="ln1764">  // Skip the command when it's not going to be executed.</a>
<a name="ln1765">  // The commands like :if, :endif, etc. always need to be executed.</a>
<a name="ln1766">  // Also make an exception for commands that handle a trailing command</a>
<a name="ln1767">  // themselves.</a>
<a name="ln1768">  if (eap-&gt;skip) {</a>
<a name="ln1769">    switch (eap-&gt;cmdidx) {</a>
<a name="ln1770">    // commands that need evaluation</a>
<a name="ln1771">    case CMD_while:</a>
<a name="ln1772">    case CMD_endwhile:</a>
<a name="ln1773">    case CMD_for:</a>
<a name="ln1774">    case CMD_endfor:</a>
<a name="ln1775">    case CMD_if:</a>
<a name="ln1776">    case CMD_elseif:</a>
<a name="ln1777">    case CMD_else:</a>
<a name="ln1778">    case CMD_endif:</a>
<a name="ln1779">    case CMD_try:</a>
<a name="ln1780">    case CMD_catch:</a>
<a name="ln1781">    case CMD_finally:</a>
<a name="ln1782">    case CMD_endtry:</a>
<a name="ln1783">    case CMD_function:</a>
<a name="ln1784">      break;</a>
<a name="ln1785"> </a>
<a name="ln1786">    // Commands that handle '|' themselves.  Check: A command should</a>
<a name="ln1787">    // either have the EX_TRLBAR flag, appear in this list or appear in</a>
<a name="ln1788">    // the list at &quot;:help :bar&quot;.</a>
<a name="ln1789">    case CMD_aboveleft:</a>
<a name="ln1790">    case CMD_and:</a>
<a name="ln1791">    case CMD_belowright:</a>
<a name="ln1792">    case CMD_botright:</a>
<a name="ln1793">    case CMD_browse:</a>
<a name="ln1794">    case CMD_call:</a>
<a name="ln1795">    case CMD_confirm:</a>
<a name="ln1796">    case CMD_const:</a>
<a name="ln1797">    case CMD_delfunction:</a>
<a name="ln1798">    case CMD_djump:</a>
<a name="ln1799">    case CMD_dlist:</a>
<a name="ln1800">    case CMD_dsearch:</a>
<a name="ln1801">    case CMD_dsplit:</a>
<a name="ln1802">    case CMD_echo:</a>
<a name="ln1803">    case CMD_echoerr:</a>
<a name="ln1804">    case CMD_echomsg:</a>
<a name="ln1805">    case CMD_echon:</a>
<a name="ln1806">    case CMD_eval:</a>
<a name="ln1807">    case CMD_execute:</a>
<a name="ln1808">    case CMD_filter:</a>
<a name="ln1809">    case CMD_help:</a>
<a name="ln1810">    case CMD_hide:</a>
<a name="ln1811">    case CMD_horizontal:</a>
<a name="ln1812">    case CMD_ijump:</a>
<a name="ln1813">    case CMD_ilist:</a>
<a name="ln1814">    case CMD_isearch:</a>
<a name="ln1815">    case CMD_isplit:</a>
<a name="ln1816">    case CMD_keepalt:</a>
<a name="ln1817">    case CMD_keepjumps:</a>
<a name="ln1818">    case CMD_keepmarks:</a>
<a name="ln1819">    case CMD_keeppatterns:</a>
<a name="ln1820">    case CMD_leftabove:</a>
<a name="ln1821">    case CMD_let:</a>
<a name="ln1822">    case CMD_lockmarks:</a>
<a name="ln1823">    case CMD_lockvar:</a>
<a name="ln1824">    case CMD_lua:</a>
<a name="ln1825">    case CMD_match:</a>
<a name="ln1826">    case CMD_mzscheme:</a>
<a name="ln1827">    case CMD_noautocmd:</a>
<a name="ln1828">    case CMD_noswapfile:</a>
<a name="ln1829">    case CMD_perl:</a>
<a name="ln1830">    case CMD_psearch:</a>
<a name="ln1831">    case CMD_python:</a>
<a name="ln1832">    case CMD_py3:</a>
<a name="ln1833">    case CMD_python3:</a>
<a name="ln1834">    case CMD_pythonx:</a>
<a name="ln1835">    case CMD_pyx:</a>
<a name="ln1836">    case CMD_return:</a>
<a name="ln1837">    case CMD_rightbelow:</a>
<a name="ln1838">    case CMD_ruby:</a>
<a name="ln1839">    case CMD_silent:</a>
<a name="ln1840">    case CMD_smagic:</a>
<a name="ln1841">    case CMD_snomagic:</a>
<a name="ln1842">    case CMD_substitute:</a>
<a name="ln1843">    case CMD_syntax:</a>
<a name="ln1844">    case CMD_tab:</a>
<a name="ln1845">    case CMD_tcl:</a>
<a name="ln1846">    case CMD_throw:</a>
<a name="ln1847">    case CMD_tilde:</a>
<a name="ln1848">    case CMD_topleft:</a>
<a name="ln1849">    case CMD_trust:</a>
<a name="ln1850">    case CMD_unlet:</a>
<a name="ln1851">    case CMD_unlockvar:</a>
<a name="ln1852">    case CMD_verbose:</a>
<a name="ln1853">    case CMD_vertical:</a>
<a name="ln1854">    case CMD_wincmd:</a>
<a name="ln1855">      break;</a>
<a name="ln1856"> </a>
<a name="ln1857">    default:</a>
<a name="ln1858">      return true;</a>
<a name="ln1859">    }</a>
<a name="ln1860">  }</a>
<a name="ln1861">  return false;</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864">/// Execute one Ex command.</a>
<a name="ln1865">///</a>
<a name="ln1866">/// If &quot;flags&quot; has DOCMD_VERBOSE, the command will be included in the error</a>
<a name="ln1867">/// message.</a>
<a name="ln1868">///</a>
<a name="ln1869">/// 1. skip comment lines and leading space</a>
<a name="ln1870">/// 2. handle command modifiers</a>
<a name="ln1871">/// 3. skip over the range to find the command</a>
<a name="ln1872">/// 4. parse the range</a>
<a name="ln1873">/// 5. parse the command</a>
<a name="ln1874">/// 6. parse arguments</a>
<a name="ln1875">/// 7. switch on command name</a>
<a name="ln1876">///</a>
<a name="ln1877">/// Note: &quot;fgetline&quot; can be NULL.</a>
<a name="ln1878">///</a>
<a name="ln1879">/// This function may be called recursively!</a>
<a name="ln1880">///</a>
<a name="ln1881">/// @param cookie  argument for fgetline()</a>
<a name="ln1882">static char *do_one_cmd(char **cmdlinep, int flags, cstack_T *cstack, LineGetter fgetline,</a>
<a name="ln1883">                        void *cookie)</a>
<a name="ln1884">{</a>
<a name="ln1885">  const char *errormsg = NULL;  // error message</a>
<a name="ln1886">  const int save_reg_executing = reg_executing;</a>
<a name="ln1887">  const bool save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln1888"> </a>
<a name="ln1889">  exarg_T ea = {</a>
<a name="ln1890">    .line1 = 1,</a>
<a name="ln1891">    .line2 = 1,</a>
<a name="ln1892">  };</a>
<a name="ln1893">  ex_nesting_level++;</a>
<a name="ln1894"> </a>
<a name="ln1895">  // When the last file has not been edited :q has to be typed twice.</a>
<a name="ln1896">  if (quitmore</a>
<a name="ln1897">      // avoid that a function call in 'statusline' does this</a>
<a name="ln1898">      &amp;&amp; !getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1899">      // avoid that an autocommand, e.g. QuitPre, does this</a>
<a name="ln1900">      &amp;&amp; !getline_equal(fgetline, cookie, getnextac)) {</a>
<a name="ln1901">    quitmore--;</a>
<a name="ln1902">  }</a>
<a name="ln1903"> </a>
<a name="ln1904">  // Reset browse, confirm, etc..  They are restored when returning, for</a>
<a name="ln1905">  // recursive calls.</a>
<a name="ln1906">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1907"> </a>
<a name="ln1908">  // &quot;#!anything&quot; is handled like a comment.</a>
<a name="ln1909">  if ((*cmdlinep)[0] == '#' &amp;&amp; (*cmdlinep)[1] == '!') {</a>
<a name="ln1910">    goto doend;</a>
<a name="ln1911">  }</a>
<a name="ln1912"> </a>
<a name="ln1913">  // 1. Skip comment lines and leading white space and colons.</a>
<a name="ln1914">  // 2. Handle command modifiers.</a>
<a name="ln1915"> </a>
<a name="ln1916">  // The &quot;ea&quot; structure holds the arguments that can be used.</a>
<a name="ln1917">  ea.cmd = *cmdlinep;</a>
<a name="ln1918">  ea.cmdlinep = cmdlinep;</a>
<a name="ln1919">  ea.getline = fgetline;</a>
<a name="ln1920">  ea.cookie = cookie;</a>
<a name="ln1921">  ea.cstack = cstack;</a>
<a name="ln1922"> </a>
<a name="ln1923">  if (parse_command_modifiers(&amp;ea, &amp;errormsg, &amp;cmdmod, false) == FAIL) {</a>
<a name="ln1924">    goto doend;</a>
<a name="ln1925">  }</a>
<a name="ln1926">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1927"> </a>
<a name="ln1928">  char *after_modifier = ea.cmd;</a>
<a name="ln1929"> </a>
<a name="ln1930">  ea.skip = (did_emsg</a>
<a name="ln1931">             || got_int</a>
<a name="ln1932">             || did_throw</a>
<a name="ln1933">             || (cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1934">                 &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_ACTIVE)));</a>
<a name="ln1935"> </a>
<a name="ln1936">  // 3. Skip over the range to find the command. Let &quot;p&quot; point to after it.</a>
<a name="ln1937">  //</a>
<a name="ln1938">  // We need the command to know what kind of range it uses.</a>
<a name="ln1939">  char *cmd = ea.cmd;</a>
<a name="ln1940">  ea.cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln1941">  if (*ea.cmd == '*') {</a>
<a name="ln1942">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln1943">  }</a>
<a name="ln1944">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln1945"> </a>
<a name="ln1946">  profile_cmd(&amp;ea, cstack, fgetline, cookie);</a>
<a name="ln1947"> </a>
<a name="ln1948">  if (!exiting) {</a>
<a name="ln1949">    // May go to debug mode.  If this happens and the &quot;&gt;quit&quot; debug command is</a>
<a name="ln1950">    // used, throw an interrupt exception and skip the next command.</a>
<a name="ln1951">    dbg_check_breakpoint(&amp;ea);</a>
<a name="ln1952">  }</a>
<a name="ln1953">  if (!ea.skip &amp;&amp; got_int) {</a>
<a name="ln1954">    ea.skip = true;</a>
<a name="ln1955">    (void)do_intthrow(cstack);</a>
<a name="ln1956">  }</a>
<a name="ln1957"> </a>
<a name="ln1958">  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln1959">  //</a>
<a name="ln1960">  // where 'addr' is:</a>
<a name="ln1961">  //</a>
<a name="ln1962">  // %          (entire file)</a>
<a name="ln1963">  // $  [+-NUM]</a>
<a name="ln1964">  // 'x [+-NUM] (where x denotes a currently defined mark)</a>
<a name="ln1965">  // .  [+-NUM]</a>
<a name="ln1966">  // [+-NUM]..</a>
<a name="ln1967">  // NUM</a>
<a name="ln1968">  //</a>
<a name="ln1969">  // The ea.cmd pointer is updated to point to the first character following the</a>
<a name="ln1970">  // range spec. If an initial address is found, but no second, the upper bound</a>
<a name="ln1971">  // is equal to the lower.</a>
<a name="ln1972">  set_cmd_addr_type(&amp;ea, p);</a>
<a name="ln1973"> </a>
<a name="ln1974">  ea.cmd = cmd;</a>
<a name="ln1975">  if (parse_cmd_address(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1976">    goto doend;</a>
<a name="ln1977">  }</a>
<a name="ln1978"> </a>
<a name="ln1979">  // 5. Parse the command.</a>
<a name="ln1980"> </a>
<a name="ln1981">  // Skip ':' and any white space</a>
<a name="ln1982">  ea.cmd = skip_colon_white(ea.cmd, true);</a>
<a name="ln1983"> </a>
<a name="ln1984">  // If we got a line, but no command, then go to the line.</a>
<a name="ln1985">  // If we find a '|' or '\n' we set ea.nextcmd.</a>
<a name="ln1986">  if (*ea.cmd == NUL || *ea.cmd == '&quot;'</a>
<a name="ln1987">      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {</a>
<a name="ln1988">    // strange vi behaviour:</a>
<a name="ln1989">    // &quot;:3&quot;     jumps to line 3</a>
<a name="ln1990">    // &quot;:3|...&quot; prints line 3</a>
<a name="ln1991">    // &quot;:|&quot;     prints current line</a>
<a name="ln1992">    if (ea.skip) {  // skip this if inside :if</a>
<a name="ln1993">      goto doend;</a>
<a name="ln1994">    }</a>
<a name="ln1995">    if (*ea.cmd == '|' || (exmode_active &amp;&amp; ea.line1 != ea.line2)) {</a>
<a name="ln1996">      ea.cmdidx = CMD_print;</a>
<a name="ln1997">      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;</a>
<a name="ln1998">      if ((errormsg = invalid_range(&amp;ea)) == NULL) {</a>
<a name="ln1999">        correct_range(&amp;ea);</a>
<a name="ln2000">        ex_print(&amp;ea);</a>
<a name="ln2001">      }</a>
<a name="ln2002">    } else if (ea.addr_count != 0) {</a>
<a name="ln2003">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2004">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2005">      }</a>
<a name="ln2006"> </a>
<a name="ln2007">      if (ea.line2 &lt; 0) {</a>
<a name="ln2008">        errormsg = _(e_invrange);</a>
<a name="ln2009">      } else {</a>
<a name="ln2010">        if (ea.line2 == 0) {</a>
<a name="ln2011">          curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2012">        } else {</a>
<a name="ln2013">          curwin-&gt;w_cursor.lnum = ea.line2;</a>
<a name="ln2014">        }</a>
<a name="ln2015">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2016">      }</a>
<a name="ln2017">    }</a>
<a name="ln2018">    goto doend;</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  // If this looks like an undefined user command and there are CmdUndefined</a>
<a name="ln2022">  // autocommands defined, trigger the matching autocommands.</a>
<a name="ln2023">  if (p != NULL &amp;&amp; ea.cmdidx == CMD_SIZE &amp;&amp; !ea.skip</a>
<a name="ln2024">      &amp;&amp; ASCII_ISUPPER(*ea.cmd)</a>
<a name="ln2025">      &amp;&amp; has_event(EVENT_CMDUNDEFINED)) {</a>
<a name="ln2026">    p = ea.cmd;</a>
<a name="ln2027">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2028">      p++;</a>
<a name="ln2029">    }</a>
<a name="ln2030">    p = xstrnsave(ea.cmd, (size_t)(p - ea.cmd));</a>
<a name="ln2031">    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, true, NULL);</a>
<a name="ln2032">    xfree(p);</a>
<a name="ln2033">    // If the autocommands did something and didn't cause an error, try</a>
<a name="ln2034">    // finding the command again.</a>
<a name="ln2035">    p = (ret &amp;&amp; !aborting()) ? find_ex_command(&amp;ea, NULL) : ea.cmd;</a>
<a name="ln2036">  }</a>
<a name="ln2037"> </a>
<a name="ln2038">  if (p == NULL) {</a>
<a name="ln2039">    if (!ea.skip) {</a>
<a name="ln2040">      errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln2041">    }</a>
<a name="ln2042">    goto doend;</a>
<a name="ln2043">  }</a>
<a name="ln2044"> </a>
<a name="ln2045">  // Check for wrong commands.</a>
<a name="ln2046">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2047">    if (!ea.skip) {</a>
<a name="ln2048">      xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln2049">      // If the modifier was parsed OK the error must be in the following</a>
<a name="ln2050">      // command</a>
<a name="ln2051">      char *cmdname = after_modifier ? after_modifier : *cmdlinep;</a>
<a name="ln2052">      if (!(flags &amp; DOCMD_VERBOSE)) {</a>
<a name="ln2053">        append_command(cmdname);</a>
<a name="ln2054">      }</a>
<a name="ln2055">      errormsg = IObuff;</a>
<a name="ln2056">      did_emsg_syntax = true;</a>
<a name="ln2057">      verify_command(cmdname);</a>
<a name="ln2058">    }</a>
<a name="ln2059">    goto doend;</a>
<a name="ln2060">  }</a>
<a name="ln2061"> </a>
<a name="ln2062">  // set when Not Implemented</a>
<a name="ln2063">  const int ni = is_cmd_ni(ea.cmdidx);</a>
<a name="ln2064"> </a>
<a name="ln2065">  // Forced commands.</a>
<a name="ln2066">  ea.forceit = *p == '!'</a>
<a name="ln2067">               &amp;&amp; ea.cmdidx != CMD_substitute</a>
<a name="ln2068">               &amp;&amp; ea.cmdidx != CMD_smagic</a>
<a name="ln2069">               &amp;&amp; ea.cmdidx != CMD_snomagic;</a>
<a name="ln2070">  if (ea.forceit) {</a>
<a name="ln2071">    p++;</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">  // 6. Parse arguments.  Then check for errors.</a>
<a name="ln2075">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2076">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln2077">  }</a>
<a name="ln2078"> </a>
<a name="ln2079">  if (!ea.skip) {</a>
<a name="ln2080">    if (sandbox != 0 &amp;&amp; !(ea.argt &amp; EX_SBOXOK)) {</a>
<a name="ln2081">      // Command not allowed in sandbox.</a>
<a name="ln2082">      errormsg = _(e_sandbox);</a>
<a name="ln2083">      goto doend;</a>
<a name="ln2084">    }</a>
<a name="ln2085">    if (!MODIFIABLE(curbuf) &amp;&amp; (ea.argt &amp; EX_MODIFY)</a>
<a name="ln2086">        // allow :put in terminals</a>
<a name="ln2087">        &amp;&amp; (!curbuf-&gt;terminal || ea.cmdidx != CMD_put)) {</a>
<a name="ln2088">      // Command not allowed in non-'modifiable' buffer</a>
<a name="ln2089">      errormsg = _(e_modifiable);</a>
<a name="ln2090">      goto doend;</a>
<a name="ln2091">    }</a>
<a name="ln2092"> </a>
<a name="ln2093">    if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2094">      if (cmdwin_type != 0 &amp;&amp; !(ea.argt &amp; EX_CMDWIN)) {</a>
<a name="ln2095">        // Command not allowed in the command line window</a>
<a name="ln2096">        errormsg = _(e_cmdwin);</a>
<a name="ln2097">        goto doend;</a>
<a name="ln2098">      }</a>
<a name="ln2099">      if (text_locked() &amp;&amp; !(ea.argt &amp; EX_LOCK_OK)) {</a>
<a name="ln2100">        // Command not allowed when text is locked</a>
<a name="ln2101">        errormsg = _(get_text_locked_msg());</a>
<a name="ln2102">        goto doend;</a>
<a name="ln2103">      }</a>
<a name="ln2104">    }</a>
<a name="ln2105"> </a>
<a name="ln2106">    // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln2107">    // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln2108">    // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln2109">    // Do allow &quot;:file&quot; with no arguments (check for an argument later).</a>
<a name="ln2110">    if (!(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln2111">        &amp;&amp; ea.cmdidx != CMD_checktime</a>
<a name="ln2112">        &amp;&amp; ea.cmdidx != CMD_edit</a>
<a name="ln2113">        &amp;&amp; ea.cmdidx != CMD_file</a>
<a name="ln2114">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln2115">        &amp;&amp; curbuf_locked()) {</a>
<a name="ln2116">      goto doend;</a>
<a name="ln2117">    }</a>
<a name="ln2118"> </a>
<a name="ln2119">    if (!ni &amp;&amp; !(ea.argt &amp; EX_RANGE) &amp;&amp; ea.addr_count &gt; 0) {</a>
<a name="ln2120">      // no range allowed</a>
<a name="ln2121">      errormsg = _(e_norange);</a>
<a name="ln2122">      goto doend;</a>
<a name="ln2123">    }</a>
<a name="ln2124">  }</a>
<a name="ln2125"> </a>
<a name="ln2126">  if (!ni &amp;&amp; !(ea.argt &amp; EX_BANG) &amp;&amp; ea.forceit) {  // no &lt;!&gt; allowed</a>
<a name="ln2127">    errormsg = _(e_nobang);</a>
<a name="ln2128">    goto doend;</a>
<a name="ln2129">  }</a>
<a name="ln2130"> </a>
<a name="ln2131">  // Don't complain about the range if it is not used</a>
<a name="ln2132">  // (could happen if line_count is accidentally set to 0).</a>
<a name="ln2133">  if (!ea.skip &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_RANGE)) {</a>
<a name="ln2134">    // If the range is backwards, ask for confirmation and, if given, swap</a>
<a name="ln2135">    // ea.line1 &amp; ea.line2 so it's forwards again.</a>
<a name="ln2136">    // When global command is busy, don't ask, will fail below.</a>
<a name="ln2137">    if (!global_busy &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln2138">      if (msg_silent == 0) {</a>
<a name="ln2139">        if ((flags &amp; DOCMD_VERBOSE) || exmode_active) {</a>
<a name="ln2140">          errormsg = _(&quot;E493: Backwards range given&quot;);</a>
<a name="ln2141">          goto doend;</a>
<a name="ln2142">        }</a>
<a name="ln2143">        if (ask_yesno(_(&quot;Backwards range given, OK to swap&quot;), false) != 'y') {</a>
<a name="ln2144">          goto doend;</a>
<a name="ln2145">        }</a>
<a name="ln2146">      }</a>
<a name="ln2147">      linenr_T lnum = ea.line1;</a>
<a name="ln2148">      ea.line1 = ea.line2;</a>
<a name="ln2149">      ea.line2 = lnum;</a>
<a name="ln2150">    }</a>
<a name="ln2151">    if ((errormsg = invalid_range(&amp;ea)) != NULL) {</a>
<a name="ln2152">      goto doend;</a>
<a name="ln2153">    }</a>
<a name="ln2154">  }</a>
<a name="ln2155"> </a>
<a name="ln2156">  if ((ea.addr_type == ADDR_OTHER) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2157">    // default is 1, not cursor</a>
<a name="ln2158">    ea.line2 = 1;</a>
<a name="ln2159">  }</a>
<a name="ln2160"> </a>
<a name="ln2161">  correct_range(&amp;ea);</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (((ea.argt &amp; EX_WHOLEFOLD) || ea.addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln2164">      &amp;&amp; ea.addr_type == ADDR_LINES) {</a>
<a name="ln2165">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln2166">    // at the end of a closed fold.</a>
<a name="ln2167">    (void)hasFolding(ea.line1, &amp;ea.line1, NULL);</a>
<a name="ln2168">    (void)hasFolding(ea.line2, NULL, &amp;ea.line2);</a>
<a name="ln2169">  }</a>
<a name="ln2170"> </a>
<a name="ln2171">  // For the &quot;:make&quot; and &quot;:grep&quot; commands we insert the 'makeprg'/'grepprg'</a>
<a name="ln2172">  // option here, so things like % get expanded.</a>
<a name="ln2173">  p = replace_makeprg(&amp;ea, p, cmdlinep);</a>
<a name="ln2174">  if (p == NULL) {</a>
<a name="ln2175">    goto doend;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  // Skip to start of argument.</a>
<a name="ln2179">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln2180">  ea.arg = ea.cmdidx == CMD_bang ? p : skipwhite(p);</a>
<a name="ln2181"> </a>
<a name="ln2182">  // &quot;:file&quot; cannot be run with an argument when &quot;curbuf-&gt;b_ro_locked&quot; is set</a>
<a name="ln2183">  if (ea.cmdidx == CMD_file &amp;&amp; *ea.arg != NUL &amp;&amp; curbuf_locked()) {</a>
<a name="ln2184">    goto doend;</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  // Check for &quot;++opt=val&quot; argument.</a>
<a name="ln2188">  // Must be first, allow &quot;:w ++enc=utf8 !cmd&quot;</a>
<a name="ln2189">  if (ea.argt &amp; EX_ARGOPT) {</a>
<a name="ln2190">    while (ea.arg[0] == '+' &amp;&amp; ea.arg[1] == '+') {</a>
<a name="ln2191">      if (getargopt(&amp;ea) == FAIL &amp;&amp; !ni) {</a>
<a name="ln2192">        errormsg = _(e_invarg);</a>
<a name="ln2193">        goto doend;</a>
<a name="ln2194">      }</a>
<a name="ln2195">    }</a>
<a name="ln2196">  }</a>
<a name="ln2197"> </a>
<a name="ln2198">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln2199">    if (*ea.arg == '&gt;') {                       // append</a>
<a name="ln2200">      if (*++ea.arg != '&gt;') {                   // typed wrong</a>
<a name="ln2201">        errormsg = _(&quot;E494: Use w or w&gt;&gt;&quot;);</a>
<a name="ln2202">        goto doend;</a>
<a name="ln2203">      }</a>
<a name="ln2204">      ea.arg = skipwhite(ea.arg + 1);</a>
<a name="ln2205">      ea.append = true;</a>
<a name="ln2206">    } else if (*ea.arg == '!' &amp;&amp; ea.cmdidx == CMD_write) {  // :w !filter</a>
<a name="ln2207">      ea.arg++;</a>
<a name="ln2208">      ea.usefilter = true;</a>
<a name="ln2209">    }</a>
<a name="ln2210">  } else if (ea.cmdidx == CMD_read) {</a>
<a name="ln2211">    if (ea.forceit) {</a>
<a name="ln2212">      ea.usefilter = true;                      // :r! filter if ea.forceit</a>
<a name="ln2213">      ea.forceit = false;</a>
<a name="ln2214">    } else if (*ea.arg == '!') {              // :r !filter</a>
<a name="ln2215">      ea.arg++;</a>
<a name="ln2216">      ea.usefilter = true;</a>
<a name="ln2217">    }</a>
<a name="ln2218">  } else if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln2219">    ea.amount = 1;</a>
<a name="ln2220">    while (*ea.arg == *ea.cmd) {                // count number of '&gt;' or '&lt;'</a>
<a name="ln2221">      ea.arg++;</a>
<a name="ln2222">      ea.amount++;</a>
<a name="ln2223">    }</a>
<a name="ln2224">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln2225">  }</a>
<a name="ln2226"> </a>
<a name="ln2227">  // Check for &quot;+command&quot; argument, before checking for next command.</a>
<a name="ln2228">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2229">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2230">    ea.do_ecmd_cmd = getargcmd(&amp;ea.arg);</a>
<a name="ln2231">  }</a>
<a name="ln2232"> </a>
<a name="ln2233">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln2234">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2235">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2236">    separate_nextcmd(&amp;ea);</a>
<a name="ln2237">  } else if (ea.cmdidx == CMD_bang</a>
<a name="ln2238">             || ea.cmdidx == CMD_terminal</a>
<a name="ln2239">             || ea.cmdidx == CMD_global</a>
<a name="ln2240">             || ea.cmdidx == CMD_vglobal</a>
<a name="ln2241">             || ea.usefilter) {</a>
<a name="ln2242">    // Check for &lt;newline&gt; to end a shell command.</a>
<a name="ln2243">    // Also do this for &quot;:read !cmd&quot;, &quot;:write !cmd&quot; and &quot;:global&quot;.</a>
<a name="ln2244">    // Any others?</a>
<a name="ln2245">    for (char *s = ea.arg; *s; s++) {</a>
<a name="ln2246">      // Remove one backslash before a newline, so that it's possible to</a>
<a name="ln2247">      // pass a newline to the shell and also a newline that is preceded</a>
<a name="ln2248">      // with a backslash.  This makes it impossible to end a shell</a>
<a name="ln2249">      // command in a backslash, but that doesn't appear useful.</a>
<a name="ln2250">      // Halving the number of backslashes is incompatible with previous</a>
<a name="ln2251">      // versions.</a>
<a name="ln2252">      if (*s == '\\' &amp;&amp; s[1] == '\n') {</a>
<a name="ln2253">        STRMOVE(s, s + 1);</a>
<a name="ln2254">      } else if (*s == '\n') {</a>
<a name="ln2255">        ea.nextcmd = s + 1;</a>
<a name="ln2256">        *s = NUL;</a>
<a name="ln2257">        break;</a>
<a name="ln2258">      }</a>
<a name="ln2259">    }</a>
<a name="ln2260">  }</a>
<a name="ln2261"> </a>
<a name="ln2262">  if ((ea.argt &amp; EX_DFLALL) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2263">    set_cmd_dflall_range(&amp;ea);</a>
<a name="ln2264">  }</a>
<a name="ln2265"> </a>
<a name="ln2266">  // Parse register and count</a>
<a name="ln2267">  parse_register(&amp;ea);</a>
<a name="ln2268">  if (parse_count(&amp;ea, &amp;errormsg, true) == FAIL) {</a>
<a name="ln2269">    goto doend;</a>
<a name="ln2270">  }</a>
<a name="ln2271"> </a>
<a name="ln2272">  // Check for flags: 'l', 'p' and '#'.</a>
<a name="ln2273">  if (ea.argt &amp; EX_FLAGS) {</a>
<a name="ln2274">    get_flags(&amp;ea);</a>
<a name="ln2275">  }</a>
<a name="ln2276">  if (!ni &amp;&amp; !(ea.argt &amp; EX_EXTRA) &amp;&amp; *ea.arg != NUL</a>
<a name="ln2277">      &amp;&amp; *ea.arg != '&quot;' &amp;&amp; (*ea.arg != '|' || (ea.argt &amp; EX_TRLBAR) == 0)) {</a>
<a name="ln2278">    // no arguments allowed but there is something</a>
<a name="ln2279">    errormsg = ex_errmsg(e_trailing_arg, ea.arg);</a>
<a name="ln2280">    goto doend;</a>
<a name="ln2281">  }</a>
<a name="ln2282"> </a>
<a name="ln2283">  if (!ni &amp;&amp; (ea.argt &amp; EX_NEEDARG) &amp;&amp; *ea.arg == NUL) {</a>
<a name="ln2284">    errormsg = _(e_argreq);</a>
<a name="ln2285">    goto doend;</a>
<a name="ln2286">  }</a>
<a name="ln2287"> </a>
<a name="ln2288">  if (skip_cmd(&amp;ea)) {</a>
<a name="ln2289">    goto doend;</a>
<a name="ln2290">  }</a>
<a name="ln2291"> </a>
<a name="ln2292">  // 7. Execute the command.</a>
<a name="ln2293">  int retv = 0;</a>
<a name="ln2294">  if (execute_cmd0(&amp;retv, &amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln2295">    goto doend;</a>
<a name="ln2296">  }</a>
<a name="ln2297"> </a>
<a name="ln2298">  // If the command just executed called do_cmdline(), any throw or &quot;:return&quot;</a>
<a name="ln2299">  // or &quot;:finish&quot; encountered there must also check the cstack of the still</a>
<a name="ln2300">  // active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught</a>
<a name="ln2301">  // exception, or reanimate a returned function or finished script file and</a>
<a name="ln2302">  // return or finish it again.</a>
<a name="ln2303">  if (need_rethrow) {</a>
<a name="ln2304">    do_throw(cstack);</a>
<a name="ln2305">  } else if (check_cstack) {</a>
<a name="ln2306">    if (source_finished(fgetline, cookie)) {</a>
<a name="ln2307">      do_finish(&amp;ea, true);</a>
<a name="ln2308">    } else if (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln2309">               &amp;&amp; current_func_returned()) {</a>
<a name="ln2310">      do_return(&amp;ea, true, false, NULL);</a>
<a name="ln2311">    }</a>
<a name="ln2312">  }</a>
<a name="ln2313">  need_rethrow = check_cstack = false;</a>
<a name="ln2314"> </a>
<a name="ln2315">doend:</a>
<a name="ln2316">  // can happen with zero line number</a>
<a name="ln2317">  if (curwin-&gt;w_cursor.lnum == 0) {</a>
<a name="ln2318">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2319">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2320">  }</a>
<a name="ln2321"> </a>
<a name="ln2322">  if (errormsg != NULL &amp;&amp; *errormsg != NUL &amp;&amp; !did_emsg) {</a>
<a name="ln2323">    if (flags &amp; DOCMD_VERBOSE) {</a>
<a name="ln2324">      if (errormsg != IObuff) {</a>
<a name="ln2325">        xstrlcpy(IObuff, errormsg, IOSIZE);</a>
<a name="ln2326">        errormsg = IObuff;</a>
<a name="ln2327">      }</a>
<a name="ln2328">      append_command(*ea.cmdlinep);</a>
<a name="ln2329">    }</a>
<a name="ln2330">    emsg(errormsg);</a>
<a name="ln2331">  }</a>
<a name="ln2332">  do_errthrow(cstack,</a>
<a name="ln2333">              (ea.cmdidx != CMD_SIZE</a>
<a name="ln2334">               &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)) ? cmdnames[(int)ea.cmdidx].cmd_name : NULL);</a>
<a name="ln2335"> </a>
<a name="ln2336">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln2337">  cmdmod = save_cmdmod;</a>
<a name="ln2338">  reg_executing = save_reg_executing;</a>
<a name="ln2339">  pending_end_reg_executing = save_pending_end_reg_executing;</a>
<a name="ln2340"> </a>
<a name="ln2341">  if (ea.nextcmd &amp;&amp; *ea.nextcmd == NUL) {       // not really a next command</a>
<a name="ln2342">    ea.nextcmd = NULL;</a>
<a name="ln2343">  }</a>
<a name="ln2344"> </a>
<a name="ln2345">  ex_nesting_level--;</a>
<a name="ln2346">  xfree(ea.cmdline_tofree);</a>
<a name="ln2347"> </a>
<a name="ln2348">  return ea.nextcmd;</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">static char ex_error_buf[MSG_BUF_LEN];</a>
<a name="ln2352"> </a>
<a name="ln2353">/// @return an error message with argument included.</a>
<a name="ln2354">/// Uses a static buffer, only the last error will be kept.</a>
<a name="ln2355">/// &quot;msg&quot; will be translated, caller should use N_().</a>
<a name="ln2356">char *ex_errmsg(const char *const msg, const char *const arg)</a>
<a name="ln2357">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2358">{</a>
<a name="ln2359">  vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);</a>
<a name="ln2360">  return ex_error_buf;</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">/// Parse and skip over command modifiers:</a>
<a name="ln2364">/// - update eap-&gt;cmd</a>
<a name="ln2365">/// - store flags in &quot;cmod&quot;.</a>
<a name="ln2366">/// - Set ex_pressedreturn for an empty command line.</a>
<a name="ln2367">///</a>
<a name="ln2368">/// @param skip_only      if false, undo_cmdmod() must be called later to free</a>
<a name="ln2369">///                       any cmod_filter_pat and cmod_filter_regmatch.regprog,</a>
<a name="ln2370">///                       and ex_pressedreturn may be set.</a>
<a name="ln2371">/// @param[out] errormsg  potential error message.</a>
<a name="ln2372">///</a>
<a name="ln2373">/// Call apply_cmdmod() to get the side effects of the modifiers:</a>
<a name="ln2374">/// - Increment &quot;sandbox&quot; for &quot;:sandbox&quot;</a>
<a name="ln2375">/// - set p_verbose for &quot;:verbose&quot;</a>
<a name="ln2376">/// - set msg_silent for &quot;:silent&quot;</a>
<a name="ln2377">/// - set 'eventignore' to &quot;all&quot; for &quot;:noautocmd&quot;</a>
<a name="ln2378">///</a>
<a name="ln2379">/// @return  FAIL when the command is not to be executed.</a>
<a name="ln2380">int parse_command_modifiers(exarg_T *eap, const char **errormsg, cmdmod_T *cmod, bool skip_only)</a>
<a name="ln2381">{</a>
<a name="ln2382">  CLEAR_POINTER(cmod);</a>
<a name="ln2383"> </a>
<a name="ln2384">  // Repeat until no more command modifiers are found.</a>
<a name="ln2385">  while (true) {</a>
<a name="ln2386">    while (*eap-&gt;cmd == ' '</a>
<a name="ln2387">           || *eap-&gt;cmd == '\t'</a>
<a name="ln2388">           || *eap-&gt;cmd == ':') {</a>
<a name="ln2389">      eap-&gt;cmd++;</a>
<a name="ln2390">    }</a>
<a name="ln2391"> </a>
<a name="ln2392">    // in ex mode, an empty line works like :+</a>
<a name="ln2393">    if (*eap-&gt;cmd == NUL &amp;&amp; exmode_active</a>
<a name="ln2394">        &amp;&amp; getline_equal(eap-&gt;getline, eap-&gt;cookie, getexline)</a>
<a name="ln2395">        &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2396">      eap-&gt;cmd = &quot;+&quot;;</a>
<a name="ln2397">      if (!skip_only) {</a>
<a name="ln2398">        ex_pressedreturn = true;</a>
<a name="ln2399">      }</a>
<a name="ln2400">    }</a>
<a name="ln2401"> </a>
<a name="ln2402">    // ignore comment and empty lines</a>
<a name="ln2403">    if (*eap-&gt;cmd == '&quot;') {</a>
<a name="ln2404">      return FAIL;</a>
<a name="ln2405">    }</a>
<a name="ln2406">    if (*eap-&gt;cmd == NUL) {</a>
<a name="ln2407">      if (!skip_only) {</a>
<a name="ln2408">        ex_pressedreturn = true;</a>
<a name="ln2409">      }</a>
<a name="ln2410">      return FAIL;</a>
<a name="ln2411">    }</a>
<a name="ln2412"> </a>
<a name="ln2413">    char *p = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln2414">    switch (*p) {</a>
<a name="ln2415">    // When adding an entry, also modify cmdmods[]</a>
<a name="ln2416">    case 'a':</a>
<a name="ln2417">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;aboveleft&quot;, 3)) {</a>
<a name="ln2418">        break;</a>
<a name="ln2419">      }</a>
<a name="ln2420">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2421">      continue;</a>
<a name="ln2422"> </a>
<a name="ln2423">    case 'b':</a>
<a name="ln2424">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;belowright&quot;, 3)) {</a>
<a name="ln2425">        cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2426">        continue;</a>
<a name="ln2427">      }</a>
<a name="ln2428">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;browse&quot;, 3)) {</a>
<a name="ln2429">        cmod-&gt;cmod_flags |= CMOD_BROWSE;</a>
<a name="ln2430">        continue;</a>
<a name="ln2431">      }</a>
<a name="ln2432">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;botright&quot;, 2)) {</a>
<a name="ln2433">        break;</a>
<a name="ln2434">      }</a>
<a name="ln2435">      cmod-&gt;cmod_split |= WSP_BOT;</a>
<a name="ln2436">      continue;</a>
<a name="ln2437"> </a>
<a name="ln2438">    case 'c':</a>
<a name="ln2439">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;confirm&quot;, 4)) {</a>
<a name="ln2440">        break;</a>
<a name="ln2441">      }</a>
<a name="ln2442">      cmod-&gt;cmod_flags |= CMOD_CONFIRM;</a>
<a name="ln2443">      continue;</a>
<a name="ln2444"> </a>
<a name="ln2445">    case 'k':</a>
<a name="ln2446">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepmarks&quot;, 3)) {</a>
<a name="ln2447">        cmod-&gt;cmod_flags |= CMOD_KEEPMARKS;</a>
<a name="ln2448">        continue;</a>
<a name="ln2449">      }</a>
<a name="ln2450">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepalt&quot;, 5)) {</a>
<a name="ln2451">        cmod-&gt;cmod_flags |= CMOD_KEEPALT;</a>
<a name="ln2452">        continue;</a>
<a name="ln2453">      }</a>
<a name="ln2454">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keeppatterns&quot;, 5)) {</a>
<a name="ln2455">        cmod-&gt;cmod_flags |= CMOD_KEEPPATTERNS;</a>
<a name="ln2456">        continue;</a>
<a name="ln2457">      }</a>
<a name="ln2458">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;keepjumps&quot;, 5)) {</a>
<a name="ln2459">        break;</a>
<a name="ln2460">      }</a>
<a name="ln2461">      cmod-&gt;cmod_flags |= CMOD_KEEPJUMPS;</a>
<a name="ln2462">      continue;</a>
<a name="ln2463"> </a>
<a name="ln2464">    case 'f': {  // only accept &quot;:filter {pat} cmd&quot;</a>
<a name="ln2465">      char *reg_pat;</a>
<a name="ln2466"> </a>
<a name="ln2467">      if (!checkforcmd(&amp;p, &quot;filter&quot;, 4) || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2468">        break;</a>
<a name="ln2469">      }</a>
<a name="ln2470">      if (*p == '!') {</a>
<a name="ln2471">        cmod-&gt;cmod_filter_force = true;</a>
<a name="ln2472">        p = skipwhite(p + 1);</a>
<a name="ln2473">        if (*p == NUL || ends_excmd(*p)) {</a>
<a name="ln2474">          break;</a>
<a name="ln2475">        }</a>
<a name="ln2476">      }</a>
<a name="ln2477">      if (skip_only) {</a>
<a name="ln2478">        p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln2479">      } else {</a>
<a name="ln2480">        // NOTE: This puts a NUL after the pattern.</a>
<a name="ln2481">        p = skip_vimgrep_pat(p, &amp;reg_pat, NULL);</a>
<a name="ln2482">      }</a>
<a name="ln2483">      if (p == NULL || *p == NUL) {</a>
<a name="ln2484">        break;</a>
<a name="ln2485">      }</a>
<a name="ln2486">      if (!skip_only) {</a>
<a name="ln2487">        cmod-&gt;cmod_filter_pat = xstrdup(reg_pat);</a>
<a name="ln2488">        cmod-&gt;cmod_filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln2489">        if (cmod-&gt;cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2490">          break;</a>
<a name="ln2491">        }</a>
<a name="ln2492">      }</a>
<a name="ln2493">      eap-&gt;cmd = p;</a>
<a name="ln2494">      continue;</a>
<a name="ln2495">    }</a>
<a name="ln2496"> </a>
<a name="ln2497">    case 'h':</a>
<a name="ln2498">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;horizontal&quot;, 3)) {</a>
<a name="ln2499">        cmod-&gt;cmod_split |= WSP_HOR;</a>
<a name="ln2500">        continue;</a>
<a name="ln2501">      }</a>
<a name="ln2502">      // &quot;:hide&quot; and &quot;:hide | cmd&quot; are not modifiers</a>
<a name="ln2503">      if (p != eap-&gt;cmd || !checkforcmd(&amp;p, &quot;hide&quot;, 3)</a>
<a name="ln2504">          || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2505">        break;</a>
<a name="ln2506">      }</a>
<a name="ln2507">      eap-&gt;cmd = p;</a>
<a name="ln2508">      cmod-&gt;cmod_flags |= CMOD_HIDE;</a>
<a name="ln2509">      continue;</a>
<a name="ln2510"> </a>
<a name="ln2511">    case 'l':</a>
<a name="ln2512">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;lockmarks&quot;, 3)) {</a>
<a name="ln2513">        cmod-&gt;cmod_flags |= CMOD_LOCKMARKS;</a>
<a name="ln2514">        continue;</a>
<a name="ln2515">      }</a>
<a name="ln2516"> </a>
<a name="ln2517">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;leftabove&quot;, 5)) {</a>
<a name="ln2518">        break;</a>
<a name="ln2519">      }</a>
<a name="ln2520">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2521">      continue;</a>
<a name="ln2522"> </a>
<a name="ln2523">    case 'n':</a>
<a name="ln2524">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;noautocmd&quot;, 3)) {</a>
<a name="ln2525">        cmod-&gt;cmod_flags |= CMOD_NOAUTOCMD;</a>
<a name="ln2526">        continue;</a>
<a name="ln2527">      }</a>
<a name="ln2528">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;noswapfile&quot;, 3)) {</a>
<a name="ln2529">        break;</a>
<a name="ln2530">      }</a>
<a name="ln2531">      cmod-&gt;cmod_flags |= CMOD_NOSWAPFILE;</a>
<a name="ln2532">      continue;</a>
<a name="ln2533"> </a>
<a name="ln2534">    case 'r':</a>
<a name="ln2535">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;rightbelow&quot;, 6)) {</a>
<a name="ln2536">        break;</a>
<a name="ln2537">      }</a>
<a name="ln2538">      cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2539">      continue;</a>
<a name="ln2540"> </a>
<a name="ln2541">    case 's':</a>
<a name="ln2542">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;sandbox&quot;, 3)) {</a>
<a name="ln2543">        cmod-&gt;cmod_flags |= CMOD_SANDBOX;</a>
<a name="ln2544">        continue;</a>
<a name="ln2545">      }</a>
<a name="ln2546">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;silent&quot;, 3)) {</a>
<a name="ln2547">        break;</a>
<a name="ln2548">      }</a>
<a name="ln2549">      cmod-&gt;cmod_flags |= CMOD_SILENT;</a>
<a name="ln2550">      if (*eap-&gt;cmd == '!' &amp;&amp; !ascii_iswhite(eap-&gt;cmd[-1])) {</a>
<a name="ln2551">        // &quot;:silent!&quot;, but not &quot;silent !cmd&quot;</a>
<a name="ln2552">        eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln2553">        cmod-&gt;cmod_flags |= CMOD_ERRSILENT;</a>
<a name="ln2554">      }</a>
<a name="ln2555">      continue;</a>
<a name="ln2556"> </a>
<a name="ln2557">    case 't':</a>
<a name="ln2558">      if (checkforcmd(&amp;p, &quot;tab&quot;, 3)) {</a>
<a name="ln2559">        if (!skip_only) {</a>
<a name="ln2560">          int tabnr = (int)get_address(eap, &amp;eap-&gt;cmd, ADDR_TABS, eap-&gt;skip, skip_only,</a>
<a name="ln2561">                                       false, 1, errormsg);</a>
<a name="ln2562">          if (eap-&gt;cmd == NULL) {</a>
<a name="ln2563">            return false;</a>
<a name="ln2564">          }</a>
<a name="ln2565"> </a>
<a name="ln2566">          if (tabnr == MAXLNUM) {</a>
<a name="ln2567">            cmod-&gt;cmod_tab = tabpage_index(curtab) + 1;</a>
<a name="ln2568">          } else {</a>
<a name="ln2569">            if (tabnr &lt; 0 || tabnr &gt; LAST_TAB_NR) {</a>
<a name="ln2570">              *errormsg = _(e_invrange);</a>
<a name="ln2571">              return false;</a>
<a name="ln2572">            }</a>
<a name="ln2573">            cmod-&gt;cmod_tab = tabnr + 1;</a>
<a name="ln2574">          }</a>
<a name="ln2575">        }</a>
<a name="ln2576">        eap-&gt;cmd = p;</a>
<a name="ln2577">        continue;</a>
<a name="ln2578">      }</a>
<a name="ln2579">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;topleft&quot;, 2)) {</a>
<a name="ln2580">        break;</a>
<a name="ln2581">      }</a>
<a name="ln2582">      cmod-&gt;cmod_split |= WSP_TOP;</a>
<a name="ln2583">      continue;</a>
<a name="ln2584"> </a>
<a name="ln2585">    case 'u':</a>
<a name="ln2586">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;unsilent&quot;, 3)) {</a>
<a name="ln2587">        break;</a>
<a name="ln2588">      }</a>
<a name="ln2589">      cmod-&gt;cmod_flags |= CMOD_UNSILENT;</a>
<a name="ln2590">      continue;</a>
<a name="ln2591"> </a>
<a name="ln2592">    case 'v':</a>
<a name="ln2593">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;vertical&quot;, 4)) {</a>
<a name="ln2594">        cmod-&gt;cmod_split |= WSP_VERT;</a>
<a name="ln2595">        continue;</a>
<a name="ln2596">      }</a>
<a name="ln2597">      if (!checkforcmd(&amp;p, &quot;verbose&quot;, 4)) {</a>
<a name="ln2598">        break;</a>
<a name="ln2599">      }</a>
<a name="ln2600">      if (ascii_isdigit(*eap-&gt;cmd)) {</a>
<a name="ln2601">        // zero means not set, one is verbose == 0, etc.</a>
<a name="ln2602">        cmod-&gt;cmod_verbose = atoi(eap-&gt;cmd) + 1;</a>
<a name="ln2603">      } else {</a>
<a name="ln2604">        cmod-&gt;cmod_verbose = 2;  // default: verbose == 1</a>
<a name="ln2605">      }</a>
<a name="ln2606">      eap-&gt;cmd = p;</a>
<a name="ln2607">      continue;</a>
<a name="ln2608">    }</a>
<a name="ln2609">    break;</a>
<a name="ln2610">  }</a>
<a name="ln2611"> </a>
<a name="ln2612">  return OK;</a>
<a name="ln2613">}</a>
<a name="ln2614"> </a>
<a name="ln2615">/// Apply the command modifiers.  Saves current state in &quot;cmdmod&quot;, call</a>
<a name="ln2616">/// undo_cmdmod() later.</a>
<a name="ln2617">static void apply_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2618">{</a>
<a name="ln2619">  if ((cmod-&gt;cmod_flags &amp; CMOD_SANDBOX) &amp;&amp; !cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2620">    sandbox++;</a>
<a name="ln2621">    cmod-&gt;cmod_did_sandbox = true;</a>
<a name="ln2622">  }</a>
<a name="ln2623">  if (cmod-&gt;cmod_verbose &gt; 0) {</a>
<a name="ln2624">    if (cmod-&gt;cmod_verbose_save == 0) {</a>
<a name="ln2625">      cmod-&gt;cmod_verbose_save = p_verbose + 1;</a>
<a name="ln2626">    }</a>
<a name="ln2627">    p_verbose = cmod-&gt;cmod_verbose - 1;</a>
<a name="ln2628">  }</a>
<a name="ln2629"> </a>
<a name="ln2630">  if ((cmod-&gt;cmod_flags &amp; (CMOD_SILENT | CMOD_UNSILENT))</a>
<a name="ln2631">      &amp;&amp; cmod-&gt;cmod_save_msg_silent == 0) {</a>
<a name="ln2632">    cmod-&gt;cmod_save_msg_silent = msg_silent + 1;</a>
<a name="ln2633">    cmod-&gt;cmod_save_msg_scroll = msg_scroll;</a>
<a name="ln2634">  }</a>
<a name="ln2635">  if (cmod-&gt;cmod_flags &amp; CMOD_SILENT) {</a>
<a name="ln2636">    msg_silent++;</a>
<a name="ln2637">  }</a>
<a name="ln2638">  if (cmod-&gt;cmod_flags &amp; CMOD_UNSILENT) {</a>
<a name="ln2639">    msg_silent = 0;</a>
<a name="ln2640">  }</a>
<a name="ln2641"> </a>
<a name="ln2642">  if (cmod-&gt;cmod_flags &amp; CMOD_ERRSILENT) {</a>
<a name="ln2643">    emsg_silent++;</a>
<a name="ln2644">    cmod-&gt;cmod_did_esilent++;</a>
<a name="ln2645">  }</a>
<a name="ln2646"> </a>
<a name="ln2647">  if ((cmod-&gt;cmod_flags &amp; CMOD_NOAUTOCMD) &amp;&amp; cmod-&gt;cmod_save_ei == NULL) {</a>
<a name="ln2648">    // Set 'eventignore' to &quot;all&quot;.</a>
<a name="ln2649">    // First save the existing option value for restoring it later.</a>
<a name="ln2650">    cmod-&gt;cmod_save_ei = xstrdup(p_ei);</a>
<a name="ln2651">    set_string_option_direct(&quot;ei&quot;, -1, &quot;all&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln2652">  }</a>
<a name="ln2653">}</a>
<a name="ln2654"> </a>
<a name="ln2655">/// Undo and free contents of &quot;cmod&quot;.</a>
<a name="ln2656">void undo_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2657">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2658">{</a>
<a name="ln2659">  if (cmod-&gt;cmod_verbose_save &gt; 0) {</a>
<a name="ln2660">    p_verbose = cmod-&gt;cmod_verbose_save - 1;</a>
<a name="ln2661">    cmod-&gt;cmod_verbose_save = 0;</a>
<a name="ln2662">  }</a>
<a name="ln2663"> </a>
<a name="ln2664">  if (cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2665">    sandbox--;</a>
<a name="ln2666">    cmod-&gt;cmod_did_sandbox = false;</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">  if (cmod-&gt;cmod_save_ei != NULL) {</a>
<a name="ln2670">    // Restore 'eventignore' to the value before &quot;:noautocmd&quot;.</a>
<a name="ln2671">    set_string_option_direct(&quot;ei&quot;, -1, cmod-&gt;cmod_save_ei, OPT_FREE, SID_NONE);</a>
<a name="ln2672">    free_string_option(cmod-&gt;cmod_save_ei);</a>
<a name="ln2673">    cmod-&gt;cmod_save_ei = NULL;</a>
<a name="ln2674">  }</a>
<a name="ln2675"> </a>
<a name="ln2676">  xfree(cmod-&gt;cmod_filter_pat);</a>
<a name="ln2677">  vim_regfree(cmod-&gt;cmod_filter_regmatch.regprog);</a>
<a name="ln2678"> </a>
<a name="ln2679">  if (cmod-&gt;cmod_save_msg_silent &gt; 0) {</a>
<a name="ln2680">    // messages could be enabled for a serious error, need to check if the</a>
<a name="ln2681">    // counters don't become negative</a>
<a name="ln2682">    if (!did_emsg || msg_silent &gt; cmod-&gt;cmod_save_msg_silent - 1) {</a>
<a name="ln2683">      msg_silent = cmod-&gt;cmod_save_msg_silent - 1;</a>
<a name="ln2684">    }</a>
<a name="ln2685">    emsg_silent -= cmod-&gt;cmod_did_esilent;</a>
<a name="ln2686">    if (emsg_silent &lt; 0) {</a>
<a name="ln2687">      emsg_silent = 0;</a>
<a name="ln2688">    }</a>
<a name="ln2689">    // Restore msg_scroll, it's set by file I/O commands, even when no</a>
<a name="ln2690">    // message is actually displayed.</a>
<a name="ln2691">    msg_scroll = cmod-&gt;cmod_save_msg_scroll;</a>
<a name="ln2692"> </a>
<a name="ln2693">    // &quot;silent reg&quot; or &quot;silent echo x&quot; inside &quot;redir&quot; leaves msg_col</a>
<a name="ln2694">    // somewhere in the line.  Put it back in the first column.</a>
<a name="ln2695">    if (redirecting()) {</a>
<a name="ln2696">      msg_col = 0;</a>
<a name="ln2697">    }</a>
<a name="ln2698"> </a>
<a name="ln2699">    cmod-&gt;cmod_save_msg_silent = 0;</a>
<a name="ln2700">    cmod-&gt;cmod_did_esilent = 0;</a>
<a name="ln2701">  }</a>
<a name="ln2702">}</a>
<a name="ln2703"> </a>
<a name="ln2704">/// Parse the address range, if any, in &quot;eap&quot;.</a>
<a name="ln2705">/// May set the last search pattern, unless &quot;silent&quot; is true.</a>
<a name="ln2706">///</a>
<a name="ln2707">/// @return  FAIL and set &quot;errormsg&quot; or return OK.</a>
<a name="ln2708">int parse_cmd_address(exarg_T *eap, const char **errormsg, bool silent)</a>
<a name="ln2709">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2710">{</a>
<a name="ln2711">  int address_count = 1;</a>
<a name="ln2712">  linenr_T lnum;</a>
<a name="ln2713">  bool need_check_cursor = false;</a>
<a name="ln2714">  int ret = FAIL;</a>
<a name="ln2715"> </a>
<a name="ln2716">  // Repeat for all ',' or ';' separated addresses.</a>
<a name="ln2717">  while (true) {</a>
<a name="ln2718">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2719">    eap-&gt;line2 = get_cmd_default_range(eap);</a>
<a name="ln2720">    eap-&gt;cmd = skipwhite(eap-&gt;cmd);</a>
<a name="ln2721">    lnum = get_address(eap, &amp;eap-&gt;cmd, eap-&gt;addr_type, eap-&gt;skip, silent,</a>
<a name="ln2722">                       eap-&gt;addr_count == 0, address_count++, errormsg);</a>
<a name="ln2723">    if (eap-&gt;cmd == NULL) {  // error detected</a>
<a name="ln2724">      goto theend;</a>
<a name="ln2725">    }</a>
<a name="ln2726">    if (lnum == MAXLNUM) {</a>
<a name="ln2727">      if (*eap-&gt;cmd == '%') {  // '%' - all lines</a>
<a name="ln2728">        eap-&gt;cmd++;</a>
<a name="ln2729">        switch (eap-&gt;addr_type) {</a>
<a name="ln2730">        case ADDR_LINES:</a>
<a name="ln2731">        case ADDR_OTHER:</a>
<a name="ln2732">          eap-&gt;line1 = 1;</a>
<a name="ln2733">          eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2734">          break;</a>
<a name="ln2735">        case ADDR_LOADED_BUFFERS: {</a>
<a name="ln2736">          buf_T *buf = firstbuf;</a>
<a name="ln2737"> </a>
<a name="ln2738">          while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2739">            buf = buf-&gt;b_next;</a>
<a name="ln2740">          }</a>
<a name="ln2741">          eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln2742">          buf = lastbuf;</a>
<a name="ln2743">          while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2744">            buf = buf-&gt;b_prev;</a>
<a name="ln2745">          }</a>
<a name="ln2746">          eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln2747">          break;</a>
<a name="ln2748">        }</a>
<a name="ln2749">        case ADDR_BUFFERS:</a>
<a name="ln2750">          eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln2751">          eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln2752">          break;</a>
<a name="ln2753">        case ADDR_WINDOWS:</a>
<a name="ln2754">        case ADDR_TABS:</a>
<a name="ln2755">          if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln2756">            eap-&gt;line1 = 1;</a>
<a name="ln2757">            eap-&gt;line2 = eap-&gt;addr_type == ADDR_WINDOWS</a>
<a name="ln2758">                ? LAST_WIN_NR : LAST_TAB_NR;</a>
<a name="ln2759">          } else {</a>
<a name="ln2760">            // there is no Vim command which uses '%' and</a>
<a name="ln2761">            // ADDR_WINDOWS or ADDR_TABS</a>
<a name="ln2762">            *errormsg = _(e_invrange);</a>
<a name="ln2763">            goto theend;</a>
<a name="ln2764">          }</a>
<a name="ln2765">          break;</a>
<a name="ln2766">        case ADDR_TABS_RELATIVE:</a>
<a name="ln2767">        case ADDR_UNSIGNED:</a>
<a name="ln2768">        case ADDR_QUICKFIX:</a>
<a name="ln2769">          *errormsg = _(e_invrange);</a>
<a name="ln2770">          goto theend;</a>
<a name="ln2771">        case ADDR_ARGUMENTS:</a>
<a name="ln2772">          if (ARGCOUNT == 0) {</a>
<a name="ln2773">            eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln2774">          } else {</a>
<a name="ln2775">            eap-&gt;line1 = 1;</a>
<a name="ln2776">            eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2777">          }</a>
<a name="ln2778">          break;</a>
<a name="ln2779">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln2780">          eap-&gt;line1 = 1;</a>
<a name="ln2781">          eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln2782">          if (eap-&gt;line2 == 0) {</a>
<a name="ln2783">            eap-&gt;line2 = 1;</a>
<a name="ln2784">          }</a>
<a name="ln2785">          break;</a>
<a name="ln2786">        case ADDR_NONE:</a>
<a name="ln2787">          // Will give an error later if a range is found.</a>
<a name="ln2788">          break;</a>
<a name="ln2789">        }</a>
<a name="ln2790">        eap-&gt;addr_count++;</a>
<a name="ln2791">      } else if (*eap-&gt;cmd == '*') {</a>
<a name="ln2792">        // '*' - visual area</a>
<a name="ln2793">        if (eap-&gt;addr_type != ADDR_LINES) {</a>
<a name="ln2794">          *errormsg = _(e_invrange);</a>
<a name="ln2795">          goto theend;</a>
<a name="ln2796">        }</a>
<a name="ln2797"> </a>
<a name="ln2798">        eap-&gt;cmd++;</a>
<a name="ln2799">        if (!eap-&gt;skip) {</a>
<a name="ln2800">          fmark_T *fm = mark_get_visual(curbuf, '&lt;');</a>
<a name="ln2801">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2802">            goto theend;</a>
<a name="ln2803">          }</a>
<a name="ln2804">          assert(fm != NULL);</a>
<a name="ln2805">          eap-&gt;line1 = fm-&gt;mark.lnum;</a>
<a name="ln2806">          fm = mark_get_visual(curbuf, '&gt;');</a>
<a name="ln2807">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2808">            goto theend;</a>
<a name="ln2809">          }</a>
<a name="ln2810">          assert(fm != NULL);</a>
<a name="ln2811">          eap-&gt;line2 = fm-&gt;mark.lnum;</a>
<a name="ln2812">          eap-&gt;addr_count++;</a>
<a name="ln2813">        }</a>
<a name="ln2814">      }</a>
<a name="ln2815">    } else {</a>
<a name="ln2816">      eap-&gt;line2 = lnum;</a>
<a name="ln2817">    }</a>
<a name="ln2818">    eap-&gt;addr_count++;</a>
<a name="ln2819"> </a>
<a name="ln2820">    if (*eap-&gt;cmd == ';') {</a>
<a name="ln2821">      if (!eap-&gt;skip) {</a>
<a name="ln2822">        curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln2823"> </a>
<a name="ln2824">        // Don't leave the cursor on an illegal line or column, but do</a>
<a name="ln2825">        // accept zero as address, so 0;/PATTERN/ works correctly</a>
<a name="ln2826">        // (where zero usually means to use the first line).</a>
<a name="ln2827">        // Check the cursor position before returning.</a>
<a name="ln2828">        if (eap-&gt;line2 &gt; 0) {</a>
<a name="ln2829">          check_cursor();</a>
<a name="ln2830">        } else {</a>
<a name="ln2831">          check_cursor_col();</a>
<a name="ln2832">        }</a>
<a name="ln2833">        need_check_cursor = true;</a>
<a name="ln2834">      }</a>
<a name="ln2835">    } else if (*eap-&gt;cmd != ',') {</a>
<a name="ln2836">      break;</a>
<a name="ln2837">    }</a>
<a name="ln2838">    eap-&gt;cmd++;</a>
<a name="ln2839">  }</a>
<a name="ln2840"> </a>
<a name="ln2841">  // One address given: set start and end lines.</a>
<a name="ln2842">  if (eap-&gt;addr_count == 1) {</a>
<a name="ln2843">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2844">    // ... but only implicit: really no address given</a>
<a name="ln2845">    if (lnum == MAXLNUM) {</a>
<a name="ln2846">      eap-&gt;addr_count = 0;</a>
<a name="ln2847">    }</a>
<a name="ln2848">  }</a>
<a name="ln2849">  ret = OK;</a>
<a name="ln2850"> </a>
<a name="ln2851">theend:</a>
<a name="ln2852">  if (need_check_cursor) {</a>
<a name="ln2853">    check_cursor();</a>
<a name="ln2854">  }</a>
<a name="ln2855">  return ret;</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">/// Check for an Ex command with optional tail.</a>
<a name="ln2859">/// If there is a match advance &quot;pp&quot; to the argument and return true.</a>
<a name="ln2860">///</a>
<a name="ln2861">/// @param pp   start of command</a>
<a name="ln2862">/// @param cmd  name of command</a>
<a name="ln2863">/// @param len  required length</a>
<a name="ln2864">bool checkforcmd(char **pp, const char *cmd, int len)</a>
<a name="ln2865">{</a>
<a name="ln2866">  int i;</a>
<a name="ln2867"> </a>
<a name="ln2868">  for (i = 0; cmd[i] != NUL; i++) {</a>
<a name="ln2869">    if ((cmd)[i] != (*pp)[i]) {</a>
<a name="ln2870">      break;</a>
<a name="ln2871">    }</a>
<a name="ln2872">  }</a>
<a name="ln2873">  if (i &gt;= len &amp;&amp; !ASCII_ISALPHA((*pp)[i])) {</a>
<a name="ln2874">    *pp = skipwhite(*pp + i);</a>
<a name="ln2875">    return true;</a>
<a name="ln2876">  }</a>
<a name="ln2877">  return false;</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880">/// Append &quot;cmd&quot; to the error message in IObuff.</a>
<a name="ln2881">/// Takes care of limiting the length and handling 0xa0, which would be</a>
<a name="ln2882">/// invisible otherwise.</a>
<a name="ln2883">static void append_command(const char *cmd)</a>
<a name="ln2884">{</a>
<a name="ln2885">  size_t len = strlen(IObuff);</a>
<a name="ln2886">  const char *s = cmd;</a>
<a name="ln2887">  char *d;</a>
<a name="ln2888"> </a>
<a name="ln2889">  if (len &gt; IOSIZE - 100) {</a>
<a name="ln2890">    // Not enough space, truncate and put in &quot;...&quot;.</a>
<a name="ln2891">    d = IObuff + IOSIZE - 100;</a>
<a name="ln2892">    d -= utf_head_off(IObuff, d);</a>
<a name="ln2893">    STRCPY(d, &quot;...&quot;);</a>
<a name="ln2894">  }</a>
<a name="ln2895">  xstrlcat(IObuff, &quot;: &quot;, IOSIZE);</a>
<a name="ln2896">  d = IObuff + strlen(IObuff);</a>
<a name="ln2897">  while (*s != NUL &amp;&amp; d - IObuff + 5 &lt; IOSIZE) {</a>
<a name="ln2898">    if ((uint8_t)s[0] == 0xc2 &amp;&amp; (uint8_t)s[1] == 0xa0) {</a>
<a name="ln2899">      s += 2;</a>
<a name="ln2900">      STRCPY(d, &quot;&lt;a0&gt;&quot;);</a>
<a name="ln2901">      d += 4;</a>
<a name="ln2902">    } else if (d - IObuff + utfc_ptr2len(s) + 1 &gt;= IOSIZE) {</a>
<a name="ln2903">      break;</a>
<a name="ln2904">    } else {</a>
<a name="ln2905">      mb_copy_char(&amp;s, &amp;d);</a>
<a name="ln2906">    }</a>
<a name="ln2907">  }</a>
<a name="ln2908">  *d = NUL;</a>
<a name="ln2909">}</a>
<a name="ln2910"> </a>
<a name="ln2911">/// Return true and set &quot;*idx&quot; if &quot;p&quot; points to a one letter command.</a>
<a name="ln2912">/// - The 'k' command can directly be followed by any character.</a>
<a name="ln2913">/// - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2914">///          but :sre[wind] is another command, as are :scr[iptnames],</a>
<a name="ln2915">///          :scs[cope], :sim[alt], :sig[ns] and :sil[ent].</a>
<a name="ln2916">static int one_letter_cmd(const char *p, cmdidx_T *idx)</a>
<a name="ln2917">{</a>
<a name="ln2918">  if (*p == 'k') {</a>
<a name="ln2919">    *idx = CMD_k;</a>
<a name="ln2920">    return true;</a>
<a name="ln2921">  }</a>
<a name="ln2922">  if (p[0] == 's'</a>
<a name="ln2923">      &amp;&amp; ((p[1] == 'c'</a>
<a name="ln2924">           &amp;&amp; (p[2] == NUL</a>
<a name="ln2925">               || (p[2] != 's' &amp;&amp; p[2] != 'r'</a>
<a name="ln2926">                   &amp;&amp; (p[3] == NUL</a>
<a name="ln2927">                       || (p[3] != 'i' &amp;&amp; p[4] != 'p')))))</a>
<a name="ln2928">          || p[1] == 'g'</a>
<a name="ln2929">          || (p[1] == 'i' &amp;&amp; p[2] != 'm' &amp;&amp; p[2] != 'l' &amp;&amp; p[2] != 'g')</a>
<a name="ln2930">          || p[1] == 'I'</a>
<a name="ln2931">          || (p[1] == 'r' &amp;&amp; p[2] != 'e'))) {</a>
<a name="ln2932">    *idx = CMD_substitute;</a>
<a name="ln2933">    return true;</a>
<a name="ln2934">  }</a>
<a name="ln2935">  return false;</a>
<a name="ln2936">}</a>
<a name="ln2937"> </a>
<a name="ln2938">/// Find an Ex command by its name, either built-in or user.</a>
<a name="ln2939">/// Start of the name can be found at eap-&gt;cmd.</a>
<a name="ln2940">/// Sets eap-&gt;cmdidx and returns a pointer to char after the command name.</a>
<a name="ln2941">/// &quot;full&quot; is set to true if the whole command name matched.</a>
<a name="ln2942">///</a>
<a name="ln2943">/// @return  NULL for an ambiguous user command.</a>
<a name="ln2944">char *find_ex_command(exarg_T *eap, int *full)</a>
<a name="ln2945">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2946">{</a>
<a name="ln2947">  // Isolate the command and search for it in the command table.</a>
<a name="ln2948">  char *p = eap-&gt;cmd;</a>
<a name="ln2949">  if (one_letter_cmd(p, &amp;eap-&gt;cmdidx)) {</a>
<a name="ln2950">    p++;</a>
<a name="ln2951">  } else {</a>
<a name="ln2952">    while (ASCII_ISALPHA(*p)) {</a>
<a name="ln2953">      p++;</a>
<a name="ln2954">    }</a>
<a name="ln2955">    // for python 3.x support &quot;:py3&quot;, &quot;:python3&quot;, &quot;:py3file&quot;, etc.</a>
<a name="ln2956">    if (eap-&gt;cmd[0] == 'p' &amp;&amp; eap-&gt;cmd[1] == 'y') {</a>
<a name="ln2957">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2958">        p++;</a>
<a name="ln2959">      }</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    // check for non-alpha command</a>
<a name="ln2963">    if (p == eap-&gt;cmd &amp;&amp; vim_strchr(&quot;@!=&gt;&lt;&amp;~#&quot;, (uint8_t)(*p)) != NULL) {</a>
<a name="ln2964">      p++;</a>
<a name="ln2965">    }</a>
<a name="ln2966">    int len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2967">    // The &quot;d&quot; command can directly be followed by 'l' or 'p' flag.</a>
<a name="ln2968">    if (*eap-&gt;cmd == 'd' &amp;&amp; (p[-1] == 'l' || p[-1] == 'p')) {</a>
<a name="ln2969">      // Check for &quot;:dl&quot;, &quot;:dell&quot;, etc. to &quot;:deletel&quot;: that's</a>
<a name="ln2970">      // :delete with the 'l' flag.  Same for 'p'.</a>
<a name="ln2971">      int i;</a>
<a name="ln2972">      for (i = 0; i &lt; len; i++) {</a>
<a name="ln2973">        if (eap-&gt;cmd[i] != (&quot;delete&quot;)[i]) {</a>
<a name="ln2974">          break;</a>
<a name="ln2975">        }</a>
<a name="ln2976">      }</a>
<a name="ln2977">      if (i == len - 1) {</a>
<a name="ln2978">        len--;</a>
<a name="ln2979">        if (p[-1] == 'l') {</a>
<a name="ln2980">          eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln2981">        } else {</a>
<a name="ln2982">          eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln2983">        }</a>
<a name="ln2984">      }</a>
<a name="ln2985">    }</a>
<a name="ln2986"> </a>
<a name="ln2987">    if (ASCII_ISLOWER(eap-&gt;cmd[0])) {</a>
<a name="ln2988">      const int c1 = (uint8_t)eap-&gt;cmd[0];</a>
<a name="ln2989">      const int c2 = len == 1 ? NUL : eap-&gt;cmd[1];</a>
<a name="ln2990"> </a>
<a name="ln2991">      if (command_count != CMD_SIZE) {</a>
<a name="ln2992">        iemsg(_(&quot;E943: Command table needs to be updated, run 'make'&quot;));</a>
<a name="ln2993">        getout(1);</a>
<a name="ln2994">      }</a>
<a name="ln2995"> </a>
<a name="ln2996">      // Use a precomputed index for fast look-up in cmdnames[]</a>
<a name="ln2997">      // taking into account the first 2 letters of eap-&gt;cmd.</a>
<a name="ln2998">      eap-&gt;cmdidx = cmdidxs1[CHAR_ORD_LOW(c1)];</a>
<a name="ln2999">      if (ASCII_ISLOWER(c2)) {</a>
<a name="ln3000">        eap-&gt;cmdidx += cmdidxs2[CHAR_ORD_LOW(c1)][CHAR_ORD_LOW(c2)];</a>
<a name="ln3001">      }</a>
<a name="ln3002">    } else if (ASCII_ISUPPER(eap-&gt;cmd[0])) {</a>
<a name="ln3003">      eap-&gt;cmdidx = CMD_Next;</a>
<a name="ln3004">    } else {</a>
<a name="ln3005">      eap-&gt;cmdidx = CMD_bang;</a>
<a name="ln3006">    }</a>
<a name="ln3007">    assert(eap-&gt;cmdidx &gt;= 0);</a>
<a name="ln3008"> </a>
<a name="ln3009">    if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, eap-&gt;cmd, 3) == 0) {</a>
<a name="ln3010">      // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3011">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3012">    }</a>
<a name="ln3013"> </a>
<a name="ln3014">    for (; (int)eap-&gt;cmdidx &lt; CMD_SIZE;</a>
<a name="ln3015">         eap-&gt;cmdidx = (cmdidx_T)((int)eap-&gt;cmdidx + 1)) {</a>
<a name="ln3016">      if (strncmp(cmdnames[(int)eap-&gt;cmdidx].cmd_name, eap-&gt;cmd,</a>
<a name="ln3017">                  (size_t)len) == 0) {</a>
<a name="ln3018">        if (full != NULL</a>
<a name="ln3019">            &amp;&amp; cmdnames[(int)eap-&gt;cmdidx].cmd_name[len] == NUL) {</a>
<a name="ln3020">          *full = true;</a>
<a name="ln3021">        }</a>
<a name="ln3022">        break;</a>
<a name="ln3023">      }</a>
<a name="ln3024">    }</a>
<a name="ln3025"> </a>
<a name="ln3026">    // Look for a user defined command as a last resort.</a>
<a name="ln3027">    if ((eap-&gt;cmdidx == CMD_SIZE)</a>
<a name="ln3028">        &amp;&amp; *eap-&gt;cmd &gt;= 'A' &amp;&amp; *eap-&gt;cmd &lt;= 'Z') {</a>
<a name="ln3029">      // User defined commands may contain digits.</a>
<a name="ln3030">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln3031">        p++;</a>
<a name="ln3032">      }</a>
<a name="ln3033">      p = find_ucmd(eap, p, full, NULL, NULL);</a>
<a name="ln3034">    }</a>
<a name="ln3035">    if (p == eap-&gt;cmd) {</a>
<a name="ln3036">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3037">    }</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  return p;</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043">static struct cmdmod {</a>
<a name="ln3044">  char *name;</a>
<a name="ln3045">  int minlen;</a>
<a name="ln3046">  int has_count;            // :123verbose  :3tab</a>
<a name="ln3047">} cmdmods[] = {</a>
<a name="ln3048">  { &quot;aboveleft&quot;, 3, false },</a>
<a name="ln3049">  { &quot;belowright&quot;, 3, false },</a>
<a name="ln3050">  { &quot;botright&quot;, 2, false },</a>
<a name="ln3051">  { &quot;browse&quot;, 3, false },</a>
<a name="ln3052">  { &quot;confirm&quot;, 4, false },</a>
<a name="ln3053">  { &quot;filter&quot;, 4, false },</a>
<a name="ln3054">  { &quot;hide&quot;, 3, false },</a>
<a name="ln3055">  { &quot;horizontal&quot;, 3, false },</a>
<a name="ln3056">  { &quot;keepalt&quot;, 5, false },</a>
<a name="ln3057">  { &quot;keepjumps&quot;, 5, false },</a>
<a name="ln3058">  { &quot;keepmarks&quot;, 3, false },</a>
<a name="ln3059">  { &quot;keeppatterns&quot;, 5, false },</a>
<a name="ln3060">  { &quot;leftabove&quot;, 5, false },</a>
<a name="ln3061">  { &quot;lockmarks&quot;, 3, false },</a>
<a name="ln3062">  { &quot;noautocmd&quot;, 3, false },</a>
<a name="ln3063">  { &quot;noswapfile&quot;, 3, false },</a>
<a name="ln3064">  { &quot;rightbelow&quot;, 6, false },</a>
<a name="ln3065">  { &quot;sandbox&quot;, 3, false },</a>
<a name="ln3066">  { &quot;silent&quot;, 3, false },</a>
<a name="ln3067">  { &quot;tab&quot;, 3, true },</a>
<a name="ln3068">  { &quot;topleft&quot;, 2, false },</a>
<a name="ln3069">  { &quot;unsilent&quot;, 3, false },</a>
<a name="ln3070">  { &quot;verbose&quot;, 4, true },</a>
<a name="ln3071">  { &quot;vertical&quot;, 4, false },</a>
<a name="ln3072">};</a>
<a name="ln3073"> </a>
<a name="ln3074">/// @return  length of a command modifier (including optional count) or,</a>
<a name="ln3075">///          zero when it's not a modifier.</a>
<a name="ln3076">int modifier_len(char *cmd)</a>
<a name="ln3077">{</a>
<a name="ln3078">  char *p = cmd;</a>
<a name="ln3079"> </a>
<a name="ln3080">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3081">    p = skipwhite(skipdigits(cmd + 1));</a>
<a name="ln3082">  }</a>
<a name="ln3083">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3084">    int j;</a>
<a name="ln3085">    for (j = 0; p[j] != NUL; j++) {</a>
<a name="ln3086">      if (p[j] != cmdmods[i].name[j]) {</a>
<a name="ln3087">        break;</a>
<a name="ln3088">      }</a>
<a name="ln3089">    }</a>
<a name="ln3090">    if (j &gt;= cmdmods[i].minlen</a>
<a name="ln3091">        &amp;&amp; !ASCII_ISALPHA(p[j])</a>
<a name="ln3092">        &amp;&amp; (p == cmd || cmdmods[i].has_count)) {</a>
<a name="ln3093">      return j + (int)(p - cmd);</a>
<a name="ln3094">    }</a>
<a name="ln3095">  }</a>
<a name="ln3096">  return 0;</a>
<a name="ln3097">}</a>
<a name="ln3098"> </a>
<a name="ln3099">/// @return  &gt; 0 if an Ex command &quot;name&quot; exists or,</a>
<a name="ln3100">///            2 if there is an exact match or,</a>
<a name="ln3101">///            3 if there is an ambiguous match.</a>
<a name="ln3102">int cmd_exists(const char *const name)</a>
<a name="ln3103">{</a>
<a name="ln3104">  // Check command modifiers.</a>
<a name="ln3105">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3106">    int j;</a>
<a name="ln3107">    for (j = 0; name[j] != NUL; j++) {</a>
<a name="ln3108">      if (name[j] != cmdmods[i].name[j]) {</a>
<a name="ln3109">        break;</a>
<a name="ln3110">      }</a>
<a name="ln3111">    }</a>
<a name="ln3112">    if (name[j] == NUL &amp;&amp; j &gt;= cmdmods[i].minlen) {</a>
<a name="ln3113">      return cmdmods[i].name[j] == NUL ? 2 : 1;</a>
<a name="ln3114">    }</a>
<a name="ln3115">  }</a>
<a name="ln3116"> </a>
<a name="ln3117">  // Check built-in commands and user defined commands.</a>
<a name="ln3118">  // For &quot;:2match&quot; and &quot;:3match&quot; we need to skip the number.</a>
<a name="ln3119">  exarg_T ea;</a>
<a name="ln3120">  ea.cmd = (char *)((*name == '2' || *name == '3') ? name + 1 : name);</a>
<a name="ln3121">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3122">  ea.flags = 0;</a>
<a name="ln3123">  int full = false;</a>
<a name="ln3124">  char *p = find_ex_command(&amp;ea, &amp;full);</a>
<a name="ln3125">  if (p == NULL) {</a>
<a name="ln3126">    return 3;</a>
<a name="ln3127">  }</a>
<a name="ln3128">  if (ascii_isdigit(*name) &amp;&amp; ea.cmdidx != CMD_match) {</a>
<a name="ln3129">    return 0;</a>
<a name="ln3130">  }</a>
<a name="ln3131">  if (*skipwhite(p) != NUL) {</a>
<a name="ln3132">    return 0;           // trailing garbage</a>
<a name="ln3133">  }</a>
<a name="ln3134">  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);</a>
<a name="ln3135">}</a>
<a name="ln3136"> </a>
<a name="ln3137">/// &quot;fullcommand&quot; function</a>
<a name="ln3138">void f_fullcommand(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3139">{</a>
<a name="ln3140">  char *name = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3141"> </a>
<a name="ln3142">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3143">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3144">  if (name == NULL) {</a>
<a name="ln3145">    return;</a>
<a name="ln3146">  }</a>
<a name="ln3147"> </a>
<a name="ln3148">  while (*name == ':') {</a>
<a name="ln3149">    name++;</a>
<a name="ln3150">  }</a>
<a name="ln3151">  name = skip_range(name, NULL);</a>
<a name="ln3152"> </a>
<a name="ln3153">  exarg_T ea;</a>
<a name="ln3154">  ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;</a>
<a name="ln3155">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3156">  ea.flags = 0;</a>
<a name="ln3157">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln3158">  if (p == NULL || ea.cmdidx == CMD_SIZE) {</a>
<a name="ln3159">    return;</a>
<a name="ln3160">  }</a>
<a name="ln3161"> </a>
<a name="ln3162">  rettv-&gt;vval.v_string = xstrdup(IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln3163">                                 ? get_user_command_name(ea.useridx, ea.cmdidx)</a>
<a name="ln3164">                                 : cmdnames[ea.cmdidx].cmd_name);</a>
<a name="ln3165">}</a>
<a name="ln3166"> </a>
<a name="ln3167">cmdidx_T excmd_get_cmdidx(const char *cmd, size_t len)</a>
<a name="ln3168">{</a>
<a name="ln3169">  if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, cmd, 3) == 0) {</a>
<a name="ln3170">    // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3171">    return CMD_SIZE;</a>
<a name="ln3172">  }</a>
<a name="ln3173"> </a>
<a name="ln3174">  cmdidx_T idx;</a>
<a name="ln3175"> </a>
<a name="ln3176">  if (!one_letter_cmd(cmd, &amp;idx)) {</a>
<a name="ln3177">    for (idx = (cmdidx_T)0; (int)idx &lt; CMD_SIZE; idx = (cmdidx_T)((int)idx + 1)) {</a>
<a name="ln3178">      if (strncmp(cmdnames[(int)idx].cmd_name, cmd, len) == 0) {</a>
<a name="ln3179">        break;</a>
<a name="ln3180">      }</a>
<a name="ln3181">    }</a>
<a name="ln3182">  }</a>
<a name="ln3183"> </a>
<a name="ln3184">  return idx;</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">uint32_t excmd_get_argt(cmdidx_T idx)</a>
<a name="ln3188">{</a>
<a name="ln3189">  return cmdnames[(int)idx].cmd_argt;</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192">/// Skip a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln3193">///</a>
<a name="ln3194">/// Backslashed delimiters after / or ? will be skipped, and commands will</a>
<a name="ln3195">/// not be expanded between /'s and ?'s or after &quot;'&quot;.</a>
<a name="ln3196">///</a>
<a name="ln3197">/// Also skip white space and &quot;:&quot; characters.</a>
<a name="ln3198">///</a>
<a name="ln3199">/// @param ctx  pointer to xp_context or NULL</a>
<a name="ln3200">///</a>
<a name="ln3201">/// @return the &quot;cmd&quot; pointer advanced to beyond the range.</a>
<a name="ln3202">char *skip_range(const char *cmd, int *ctx)</a>
<a name="ln3203">{</a>
<a name="ln3204">  while (vim_strchr(&quot; \t0123456789.$%'/?-+,;\\&quot;, (uint8_t)(*cmd)) != NULL) {</a>
<a name="ln3205">    if (*cmd == '\\') {</a>
<a name="ln3206">      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&amp;') {</a>
<a name="ln3207">        cmd++;</a>
<a name="ln3208">      } else {</a>
<a name="ln3209">        break;</a>
<a name="ln3210">      }</a>
<a name="ln3211">    } else if (*cmd == '\'') {</a>
<a name="ln3212">      if (*++cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3213">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3214">      }</a>
<a name="ln3215">    } else if (*cmd == '/' || *cmd == '?') {</a>
<a name="ln3216">      unsigned delim = (unsigned)(*cmd++);</a>
<a name="ln3217">      while (*cmd != NUL &amp;&amp; *cmd != (char)delim) {</a>
<a name="ln3218">        if (*cmd++ == '\\' &amp;&amp; *cmd != NUL) {</a>
<a name="ln3219">          cmd++;</a>
<a name="ln3220">        }</a>
<a name="ln3221">      }</a>
<a name="ln3222">      if (*cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3223">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3224">      }</a>
<a name="ln3225">    }</a>
<a name="ln3226">    if (*cmd != NUL) {</a>
<a name="ln3227">      cmd++;</a>
<a name="ln3228">    }</a>
<a name="ln3229">  }</a>
<a name="ln3230"> </a>
<a name="ln3231">  // Skip &quot;:&quot; and white space.</a>
<a name="ln3232">  cmd = skip_colon_white(cmd, false);</a>
<a name="ln3233"> </a>
<a name="ln3234">  return (char *)cmd;</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237">static const char *addr_error(cmd_addr_T addr_type)</a>
<a name="ln3238">{</a>
<a name="ln3239">  if (addr_type == ADDR_NONE) {</a>
<a name="ln3240">    return _(e_norange);</a>
<a name="ln3241">  } else {</a>
<a name="ln3242">    return _(e_invrange);</a>
<a name="ln3243">  }</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">/// Gets a single EX address.</a>
<a name="ln3247">///</a>
<a name="ln3248">/// Sets ptr to the next character after the part that was interpreted.</a>
<a name="ln3249">/// Sets ptr to NULL when an error is encountered (stored in `errormsg`).</a>
<a name="ln3250">/// May set the last used search pattern.</a>
<a name="ln3251">///</a>
<a name="ln3252">/// @param skip           only skip the address, don't use it</a>
<a name="ln3253">/// @param silent         no errors or side effects</a>
<a name="ln3254">/// @param to_other_file  flag: may jump to other file</a>
<a name="ln3255">/// @param address_count  1 for first, &gt;1 after comma</a>
<a name="ln3256">/// @param errormsg       Error message, if any</a>
<a name="ln3257">///</a>
<a name="ln3258">/// @return               MAXLNUM when no Ex address was found.</a>
<a name="ln3259">static linenr_T get_address(exarg_T *eap, char **ptr, cmd_addr_T addr_type, int skip, bool silent,</a>
<a name="ln3260">                            int to_other_file, int address_count, const char **errormsg)</a>
<a name="ln3261">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3262">{</a>
<a name="ln3263">  int c;</a>
<a name="ln3264">  int i;</a>
<a name="ln3265">  linenr_T n;</a>
<a name="ln3266">  pos_T pos;</a>
<a name="ln3267">  buf_T *buf;</a>
<a name="ln3268"> </a>
<a name="ln3269">  char *cmd = skipwhite(*ptr);</a>
<a name="ln3270">  linenr_T lnum = MAXLNUM;</a>
<a name="ln3271">  do {</a>
<a name="ln3272">    switch (*cmd) {</a>
<a name="ln3273">    case '.':                               // '.' - Cursor position</a>
<a name="ln3274">      cmd++;</a>
<a name="ln3275">      switch (addr_type) {</a>
<a name="ln3276">      case ADDR_LINES:</a>
<a name="ln3277">      case ADDR_OTHER:</a>
<a name="ln3278">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3279">        break;</a>
<a name="ln3280">      case ADDR_WINDOWS:</a>
<a name="ln3281">        lnum = CURRENT_WIN_NR;</a>
<a name="ln3282">        break;</a>
<a name="ln3283">      case ADDR_ARGUMENTS:</a>
<a name="ln3284">        lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3285">        break;</a>
<a name="ln3286">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3287">      case ADDR_BUFFERS:</a>
<a name="ln3288">        lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3289">        break;</a>
<a name="ln3290">      case ADDR_TABS:</a>
<a name="ln3291">        lnum = CURRENT_TAB_NR;</a>
<a name="ln3292">        break;</a>
<a name="ln3293">      case ADDR_NONE:</a>
<a name="ln3294">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3295">      case ADDR_UNSIGNED:</a>
<a name="ln3296">        *errormsg = addr_error(addr_type);</a>
<a name="ln3297">        cmd = NULL;</a>
<a name="ln3298">        goto error;</a>
<a name="ln3299">        break;</a>
<a name="ln3300">      case ADDR_QUICKFIX:</a>
<a name="ln3301">        lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3302">        break;</a>
<a name="ln3303">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3304">        lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3305">        break;</a>
<a name="ln3306">      }</a>
<a name="ln3307">      break;</a>
<a name="ln3308"> </a>
<a name="ln3309">    case '$':                               // '$' - last line</a>
<a name="ln3310">      cmd++;</a>
<a name="ln3311">      switch (addr_type) {</a>
<a name="ln3312">      case ADDR_LINES:</a>
<a name="ln3313">      case ADDR_OTHER:</a>
<a name="ln3314">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3315">        break;</a>
<a name="ln3316">      case ADDR_WINDOWS:</a>
<a name="ln3317">        lnum = LAST_WIN_NR;</a>
<a name="ln3318">        break;</a>
<a name="ln3319">      case ADDR_ARGUMENTS:</a>
<a name="ln3320">        lnum = ARGCOUNT;</a>
<a name="ln3321">        break;</a>
<a name="ln3322">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3323">        buf = lastbuf;</a>
<a name="ln3324">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3325">          if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3326">            break;</a>
<a name="ln3327">          }</a>
<a name="ln3328">          buf = buf-&gt;b_prev;</a>
<a name="ln3329">        }</a>
<a name="ln3330">        lnum = buf-&gt;b_fnum;</a>
<a name="ln3331">        break;</a>
<a name="ln3332">      case ADDR_BUFFERS:</a>
<a name="ln3333">        lnum = lastbuf-&gt;b_fnum;</a>
<a name="ln3334">        break;</a>
<a name="ln3335">      case ADDR_TABS:</a>
<a name="ln3336">        lnum = LAST_TAB_NR;</a>
<a name="ln3337">        break;</a>
<a name="ln3338">      case ADDR_NONE:</a>
<a name="ln3339">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3340">      case ADDR_UNSIGNED:</a>
<a name="ln3341">        *errormsg = addr_error(addr_type);</a>
<a name="ln3342">        cmd = NULL;</a>
<a name="ln3343">        goto error;</a>
<a name="ln3344">        break;</a>
<a name="ln3345">      case ADDR_QUICKFIX:</a>
<a name="ln3346">        lnum = (linenr_T)qf_get_size(eap);</a>
<a name="ln3347">        if (lnum == 0) {</a>
<a name="ln3348">          lnum = 1;</a>
<a name="ln3349">        }</a>
<a name="ln3350">        break;</a>
<a name="ln3351">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3352">        lnum = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln3353">        if (lnum == 0) {</a>
<a name="ln3354">          lnum = 1;</a>
<a name="ln3355">        }</a>
<a name="ln3356">        break;</a>
<a name="ln3357">      }</a>
<a name="ln3358">      break;</a>
<a name="ln3359"> </a>
<a name="ln3360">    case '\'':                              // ''' - mark</a>
<a name="ln3361">      if (*++cmd == NUL) {</a>
<a name="ln3362">        cmd = NULL;</a>
<a name="ln3363">        goto error;</a>
<a name="ln3364">      }</a>
<a name="ln3365">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3366">        *errormsg = addr_error(addr_type);</a>
<a name="ln3367">        cmd = NULL;</a>
<a name="ln3368">        goto error;</a>
<a name="ln3369">      }</a>
<a name="ln3370">      if (skip) {</a>
<a name="ln3371">        cmd++;</a>
<a name="ln3372">      } else {</a>
<a name="ln3373">        // Only accept a mark in another file when it is</a>
<a name="ln3374">        // used by itself: &quot;:'M&quot;.</a>
<a name="ln3375">        MarkGet flag = to_other_file &amp;&amp; cmd[1] == NUL ? kMarkAll : kMarkBufLocal;</a>
<a name="ln3376">        fmark_T *fm = mark_get(curbuf, curwin, NULL, flag, *cmd);</a>
<a name="ln3377">        cmd++;</a>
<a name="ln3378">        if (fm != NULL &amp;&amp; fm-&gt;fnum != curbuf-&gt;handle) {</a>
<a name="ln3379">          // Jumped to another file.</a>
<a name="ln3380">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3381">        } else {</a>
<a name="ln3382">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln3383">            cmd = NULL;</a>
<a name="ln3384">            goto error;</a>
<a name="ln3385">          }</a>
<a name="ln3386">          assert(fm != NULL);</a>
<a name="ln3387">          lnum = fm-&gt;mark.lnum;</a>
<a name="ln3388">        }</a>
<a name="ln3389">      }</a>
<a name="ln3390">      break;</a>
<a name="ln3391"> </a>
<a name="ln3392">    case '/':</a>
<a name="ln3393">    case '?':                           // '/' or '?' - search</a>
<a name="ln3394">      c = (uint8_t)(*cmd++);</a>
<a name="ln3395">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3396">        *errormsg = addr_error(addr_type);</a>
<a name="ln3397">        cmd = NULL;</a>
<a name="ln3398">        goto error;</a>
<a name="ln3399">      }</a>
<a name="ln3400">      if (skip) {                       // skip &quot;/pat/&quot;</a>
<a name="ln3401">        cmd = skip_regexp(cmd, c, magic_isset());</a>
<a name="ln3402">        if (*cmd == c) {</a>
<a name="ln3403">          cmd++;</a>
<a name="ln3404">        }</a>
<a name="ln3405">      } else {</a>
<a name="ln3406">        int flags;</a>
<a name="ln3407"> </a>
<a name="ln3408">        pos = curwin-&gt;w_cursor;  // save curwin-&gt;w_cursor</a>
<a name="ln3409"> </a>
<a name="ln3410">        // When '/' or '?' follows another address, start from</a>
<a name="ln3411">        // there.</a>
<a name="ln3412">        if (lnum &gt; 0 &amp;&amp; lnum != MAXLNUM) {</a>
<a name="ln3413">          curwin-&gt;w_cursor.lnum</a>
<a name="ln3414">            = lnum &gt; curbuf-&gt;b_ml.ml_line_count ? curbuf-&gt;b_ml.ml_line_count : lnum;</a>
<a name="ln3415">        }</a>
<a name="ln3416"> </a>
<a name="ln3417">        // Start a forward search at the end of the line (unless</a>
<a name="ln3418">        // before the first line).</a>
<a name="ln3419">        // Start a backward search at the start of the line.</a>
<a name="ln3420">        // This makes sure we never match in the current</a>
<a name="ln3421">        // line, and can match anywhere in the</a>
<a name="ln3422">        // next/previous line.</a>
<a name="ln3423">        if (c == '/' &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 0) {</a>
<a name="ln3424">          curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln3425">        } else {</a>
<a name="ln3426">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3427">        }</a>
<a name="ln3428">        searchcmdlen = 0;</a>
<a name="ln3429">        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;</a>
<a name="ln3430">        if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) {</a>
<a name="ln3431">          curwin-&gt;w_cursor = pos;</a>
<a name="ln3432">          cmd = NULL;</a>
<a name="ln3433">          goto error;</a>
<a name="ln3434">        }</a>
<a name="ln3435">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3436">        curwin-&gt;w_cursor = pos;</a>
<a name="ln3437">        // adjust command string pointer</a>
<a name="ln3438">        cmd += searchcmdlen;</a>
<a name="ln3439">      }</a>
<a name="ln3440">      break;</a>
<a name="ln3441"> </a>
<a name="ln3442">    case '\\':                      // &quot;\?&quot;, &quot;\/&quot; or &quot;\&amp;&quot;, repeat search</a>
<a name="ln3443">      cmd++;</a>
<a name="ln3444">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3445">        *errormsg = addr_error(addr_type);</a>
<a name="ln3446">        cmd = NULL;</a>
<a name="ln3447">        goto error;</a>
<a name="ln3448">      }</a>
<a name="ln3449">      if (*cmd == '&amp;') {</a>
<a name="ln3450">        i = RE_SUBST;</a>
<a name="ln3451">      } else if (*cmd == '?' || *cmd == '/') {</a>
<a name="ln3452">        i = RE_SEARCH;</a>
<a name="ln3453">      } else {</a>
<a name="ln3454">        *errormsg = _(e_backslash);</a>
<a name="ln3455">        cmd = NULL;</a>
<a name="ln3456">        goto error;</a>
<a name="ln3457">      }</a>
<a name="ln3458"> </a>
<a name="ln3459">      if (!skip) {</a>
<a name="ln3460">        // When search follows another address, start from there.</a>
<a name="ln3461">        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin-&gt;w_cursor.lnum;</a>
<a name="ln3462">        // Start the search just like for the above do_search().</a>
<a name="ln3463">        pos.col = (*cmd != '?') ? MAXCOL : 0;</a>
<a name="ln3464">        pos.coladd = 0;</a>
<a name="ln3465">        if (searchit(curwin, curbuf, &amp;pos, NULL,</a>
<a name="ln3466">                     *cmd == '?' ? BACKWARD : FORWARD,</a>
<a name="ln3467">                     &quot;&quot;, 1L, SEARCH_MSG, i, NULL) != FAIL) {</a>
<a name="ln3468">          lnum = pos.lnum;</a>
<a name="ln3469">        } else {</a>
<a name="ln3470">          cmd = NULL;</a>
<a name="ln3471">          goto error;</a>
<a name="ln3472">        }</a>
<a name="ln3473">      }</a>
<a name="ln3474">      cmd++;</a>
<a name="ln3475">      break;</a>
<a name="ln3476"> </a>
<a name="ln3477">    default:</a>
<a name="ln3478">      if (ascii_isdigit(*cmd)) {                // absolute line number</a>
<a name="ln3479">        lnum = (linenr_T)getdigits(&amp;cmd, false, 0);</a>
<a name="ln3480">      }</a>
<a name="ln3481">    }</a>
<a name="ln3482"> </a>
<a name="ln3483">    while (true) {</a>
<a name="ln3484">      cmd = skipwhite(cmd);</a>
<a name="ln3485">      if (*cmd != '-' &amp;&amp; *cmd != '+' &amp;&amp; !ascii_isdigit(*cmd)) {</a>
<a name="ln3486">        break;</a>
<a name="ln3487">      }</a>
<a name="ln3488"> </a>
<a name="ln3489">      if (lnum == MAXLNUM) {</a>
<a name="ln3490">        switch (addr_type) {</a>
<a name="ln3491">        case ADDR_LINES:</a>
<a name="ln3492">        case ADDR_OTHER:</a>
<a name="ln3493">          // &quot;+1&quot; is same as &quot;.+1&quot;</a>
<a name="ln3494">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3495">          break;</a>
<a name="ln3496">        case ADDR_WINDOWS:</a>
<a name="ln3497">          lnum = CURRENT_WIN_NR;</a>
<a name="ln3498">          break;</a>
<a name="ln3499">        case ADDR_ARGUMENTS:</a>
<a name="ln3500">          lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3501">          break;</a>
<a name="ln3502">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3503">        case ADDR_BUFFERS:</a>
<a name="ln3504">          lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3505">          break;</a>
<a name="ln3506">        case ADDR_TABS:</a>
<a name="ln3507">          lnum = CURRENT_TAB_NR;</a>
<a name="ln3508">          break;</a>
<a name="ln3509">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3510">          lnum = 1;</a>
<a name="ln3511">          break;</a>
<a name="ln3512">        case ADDR_QUICKFIX:</a>
<a name="ln3513">          lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3514">          break;</a>
<a name="ln3515">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3516">          lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3517">          break;</a>
<a name="ln3518">        case ADDR_NONE:</a>
<a name="ln3519">        case ADDR_UNSIGNED:</a>
<a name="ln3520">          lnum = 0;</a>
<a name="ln3521">          break;</a>
<a name="ln3522">        }</a>
<a name="ln3523">      }</a>
<a name="ln3524"> </a>
<a name="ln3525">      if (ascii_isdigit(*cmd)) {</a>
<a name="ln3526">        i = '+';                        // &quot;number&quot; is same as &quot;+number&quot;</a>
<a name="ln3527">      } else {</a>
<a name="ln3528">        i = (uint8_t)(*cmd++);</a>
<a name="ln3529">      }</a>
<a name="ln3530">      if (!ascii_isdigit(*cmd)) {       // '+' is '+1'</a>
<a name="ln3531">        n = 1;</a>
<a name="ln3532">      } else {</a>
<a name="ln3533">        // &quot;number&quot;, &quot;+number&quot; or &quot;-number&quot;</a>
<a name="ln3534">        n = getdigits_int32(&amp;cmd, false, MAXLNUM);</a>
<a name="ln3535">        if (n == MAXLNUM) {</a>
<a name="ln3536">          *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3537">          goto error;</a>
<a name="ln3538">        }</a>
<a name="ln3539">      }</a>
<a name="ln3540"> </a>
<a name="ln3541">      if (addr_type == ADDR_TABS_RELATIVE) {</a>
<a name="ln3542">        *errormsg = _(e_invrange);</a>
<a name="ln3543">        cmd = NULL;</a>
<a name="ln3544">        goto error;</a>
<a name="ln3545">      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {</a>
<a name="ln3546">        lnum = compute_buffer_local_count(addr_type, lnum, (i == '-') ? -1 * n : n);</a>
<a name="ln3547">      } else {</a>
<a name="ln3548">        // Relative line addressing: need to adjust for lines in a</a>
<a name="ln3549">        // closed fold after the first address.</a>
<a name="ln3550">        if (addr_type == ADDR_LINES &amp;&amp; (i == '-' || i == '+')</a>
<a name="ln3551">            &amp;&amp; address_count &gt;= 2) {</a>
<a name="ln3552">          (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3553">        }</a>
<a name="ln3554">        if (i == '-') {</a>
<a name="ln3555">          lnum -= n;</a>
<a name="ln3556">        } else {</a>
<a name="ln3557">          if (n &gt;= INT32_MAX - lnum) {</a>
<a name="ln3558">            *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3559">            goto error;</a>
<a name="ln3560">          }</a>
<a name="ln3561">          lnum += n;</a>
<a name="ln3562">        }</a>
<a name="ln3563">      }</a>
<a name="ln3564">    }</a>
<a name="ln3565">  } while (*cmd == '/' || *cmd == '?');</a>
<a name="ln3566"> </a>
<a name="ln3567">error:</a>
<a name="ln3568">  *ptr = cmd;</a>
<a name="ln3569">  return lnum;</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">/// Get flags from an Ex command argument.</a>
<a name="ln3573">static void get_flags(exarg_T *eap)</a>
<a name="ln3574">{</a>
<a name="ln3575">  while (vim_strchr(&quot;lp#&quot;, (uint8_t)(*eap-&gt;arg)) != NULL) {</a>
<a name="ln3576">    if (*eap-&gt;arg == 'l') {</a>
<a name="ln3577">      eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln3578">    } else if (*eap-&gt;arg == 'p') {</a>
<a name="ln3579">      eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln3580">    } else {</a>
<a name="ln3581">      eap-&gt;flags |= EXFLAG_NR;</a>
<a name="ln3582">    }</a>
<a name="ln3583">    eap-&gt;arg = skipwhite(eap-&gt;arg + 1);</a>
<a name="ln3584">  }</a>
<a name="ln3585">}</a>
<a name="ln3586"> </a>
<a name="ln3587">/// Stub function for command which is Not Implemented. NI!</a>
<a name="ln3588">void ex_ni(exarg_T *eap)</a>
<a name="ln3589">{</a>
<a name="ln3590">  if (!eap-&gt;skip) {</a>
<a name="ln3591">    eap-&gt;errmsg = _(&quot;E319: The command is not available in this version&quot;);</a>
<a name="ln3592">  }</a>
<a name="ln3593">}</a>
<a name="ln3594"> </a>
<a name="ln3595">/// Stub function for script command which is Not Implemented. NI!</a>
<a name="ln3596">/// Skips over &quot;:perl &lt;&lt;EOF&quot; constructs.</a>
<a name="ln3597">static void ex_script_ni(exarg_T *eap)</a>
<a name="ln3598">{</a>
<a name="ln3599">  if (!eap-&gt;skip) {</a>
<a name="ln3600">    ex_ni(eap);</a>
<a name="ln3601">  } else {</a>
<a name="ln3602">    size_t len;</a>
<a name="ln3603">    xfree(script_get(eap, &amp;len));</a>
<a name="ln3604">  }</a>
<a name="ln3605">}</a>
<a name="ln3606"> </a>
<a name="ln3607">/// Check range in Ex command for validity.</a>
<a name="ln3608">///</a>
<a name="ln3609">/// @return  NULL when valid, error message when invalid.</a>
<a name="ln3610">char *invalid_range(exarg_T *eap)</a>
<a name="ln3611">{</a>
<a name="ln3612">  buf_T *buf;</a>
<a name="ln3613">  if (eap-&gt;line1 &lt; 0 || eap-&gt;line2 &lt; 0 || eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln3614">    return _(e_invrange);</a>
<a name="ln3615">  }</a>
<a name="ln3616"> </a>
<a name="ln3617">  if (eap-&gt;argt &amp; EX_RANGE) {</a>
<a name="ln3618">    switch (eap-&gt;addr_type) {</a>
<a name="ln3619">    case ADDR_LINES:</a>
<a name="ln3620">      if (eap-&gt;line2 &gt; (curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3621">                        + (eap-&gt;cmdidx == CMD_diffget))) {</a>
<a name="ln3622">        return _(e_invrange);</a>
<a name="ln3623">      }</a>
<a name="ln3624">      break;</a>
<a name="ln3625">    case ADDR_ARGUMENTS:</a>
<a name="ln3626">      // add 1 if ARGCOUNT is 0</a>
<a name="ln3627">      if (eap-&gt;line2 &gt; ARGCOUNT + (!ARGCOUNT)) {</a>
<a name="ln3628">        return _(e_invrange);</a>
<a name="ln3629">      }</a>
<a name="ln3630">      break;</a>
<a name="ln3631">    case ADDR_BUFFERS:</a>
<a name="ln3632">      // Only a boundary check, not whether the buffers actually</a>
<a name="ln3633">      // exist.</a>
<a name="ln3634">      if (eap-&gt;line1 &lt; 1 || eap-&gt;line2 &gt; get_highest_fnum()) {</a>
<a name="ln3635">        return _(e_invrange);</a>
<a name="ln3636">      }</a>
<a name="ln3637">      break;</a>
<a name="ln3638">    case ADDR_LOADED_BUFFERS:</a>
<a name="ln3639">      buf = firstbuf;</a>
<a name="ln3640">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3641">        if (buf-&gt;b_next == NULL) {</a>
<a name="ln3642">          return _(e_invrange);</a>
<a name="ln3643">        }</a>
<a name="ln3644">        buf = buf-&gt;b_next;</a>
<a name="ln3645">      }</a>
<a name="ln3646">      if (eap-&gt;line1 &lt; buf-&gt;b_fnum) {</a>
<a name="ln3647">        return _(e_invrange);</a>
<a name="ln3648">      }</a>
<a name="ln3649">      buf = lastbuf;</a>
<a name="ln3650">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3651">        if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3652">          return _(e_invrange);</a>
<a name="ln3653">        }</a>
<a name="ln3654">        buf = buf-&gt;b_prev;</a>
<a name="ln3655">      }</a>
<a name="ln3656">      if (eap-&gt;line2 &gt; buf-&gt;b_fnum) {</a>
<a name="ln3657">        return _(e_invrange);</a>
<a name="ln3658">      }</a>
<a name="ln3659">      break;</a>
<a name="ln3660">    case ADDR_WINDOWS:</a>
<a name="ln3661">      if (eap-&gt;line2 &gt; LAST_WIN_NR) {</a>
<a name="ln3662">        return _(e_invrange);</a>
<a name="ln3663">      }</a>
<a name="ln3664">      break;</a>
<a name="ln3665">    case ADDR_TABS:</a>
<a name="ln3666">      if (eap-&gt;line2 &gt; LAST_TAB_NR) {</a>
<a name="ln3667">        return _(e_invrange);</a>
<a name="ln3668">      }</a>
<a name="ln3669">      break;</a>
<a name="ln3670">    case ADDR_TABS_RELATIVE:</a>
<a name="ln3671">    case ADDR_OTHER:</a>
<a name="ln3672">      // Any range is OK.</a>
<a name="ln3673">      break;</a>
<a name="ln3674">    case ADDR_QUICKFIX:</a>
<a name="ln3675">      assert(eap-&gt;line2 &gt;= 0);</a>
<a name="ln3676">      // No error for value that is too big, will use the last entry.</a>
<a name="ln3677">      if (eap-&gt;line2 &lt;= 0) {</a>
<a name="ln3678">        if (eap-&gt;addr_count == 0) {</a>
<a name="ln3679">          return _(e_no_errors);</a>
<a name="ln3680">        }</a>
<a name="ln3681">        return _(e_invrange);</a>
<a name="ln3682">      }</a>
<a name="ln3683">      break;</a>
<a name="ln3684">    case ADDR_QUICKFIX_VALID:</a>
<a name="ln3685">      if ((eap-&gt;line2 != 1 &amp;&amp; (size_t)eap-&gt;line2 &gt; qf_get_valid_size(eap))</a>
<a name="ln3686">          || eap-&gt;line2 &lt; 0) {</a>
<a name="ln3687">        return _(e_invrange);</a>
<a name="ln3688">      }</a>
<a name="ln3689">      break;</a>
<a name="ln3690">    case ADDR_UNSIGNED:</a>
<a name="ln3691">    case ADDR_NONE:</a>
<a name="ln3692">      // Will give an error elsewhere.</a>
<a name="ln3693">      break;</a>
<a name="ln3694">    }</a>
<a name="ln3695">  }</a>
<a name="ln3696">  return NULL;</a>
<a name="ln3697">}</a>
<a name="ln3698"> </a>
<a name="ln3699">/// Correct the range for zero line number, if required.</a>
<a name="ln3700">static void correct_range(exarg_T *eap)</a>
<a name="ln3701">{</a>
<a name="ln3702">  if (!(eap-&gt;argt &amp; EX_ZEROR)) {  // zero in range not allowed</a>
<a name="ln3703">    if (eap-&gt;line1 == 0) {</a>
<a name="ln3704">      eap-&gt;line1 = 1;</a>
<a name="ln3705">    }</a>
<a name="ln3706">    if (eap-&gt;line2 == 0) {</a>
<a name="ln3707">      eap-&gt;line2 = 1;</a>
<a name="ln3708">    }</a>
<a name="ln3709">  }</a>
<a name="ln3710">}</a>
<a name="ln3711"> </a>
<a name="ln3712">/// For a &quot;:vimgrep&quot; or &quot;:vimgrepadd&quot; command return a pointer past the</a>
<a name="ln3713">/// pattern.  Otherwise return eap-&gt;arg.</a>
<a name="ln3714">static char *skip_grep_pat(exarg_T *eap)</a>
<a name="ln3715">{</a>
<a name="ln3716">  char *p = eap-&gt;arg;</a>
<a name="ln3717"> </a>
<a name="ln3718">  if (*p != NUL &amp;&amp; (eap-&gt;cmdidx == CMD_vimgrep || eap-&gt;cmdidx == CMD_lvimgrep</a>
<a name="ln3719">                    || eap-&gt;cmdidx == CMD_vimgrepadd</a>
<a name="ln3720">                    || eap-&gt;cmdidx == CMD_lvimgrepadd</a>
<a name="ln3721">                    || grep_internal(eap-&gt;cmdidx))) {</a>
<a name="ln3722">    p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln3723">    if (p == NULL) {</a>
<a name="ln3724">      p = eap-&gt;arg;</a>
<a name="ln3725">    }</a>
<a name="ln3726">  }</a>
<a name="ln3727">  return p;</a>
<a name="ln3728">}</a>
<a name="ln3729"> </a>
<a name="ln3730">/// For the &quot;:make&quot; and &quot;:grep&quot; commands insert the 'makeprg'/'grepprg' option</a>
<a name="ln3731">/// in the command line, so that things like % get expanded.</a>
<a name="ln3732">char *replace_makeprg(exarg_T *eap, char *arg, char **cmdlinep)</a>
<a name="ln3733">{</a>
<a name="ln3734">  bool isgrep = eap-&gt;cmdidx == CMD_grep</a>
<a name="ln3735">                || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln3736">                || eap-&gt;cmdidx == CMD_grepadd</a>
<a name="ln3737">                || eap-&gt;cmdidx == CMD_lgrepadd;</a>
<a name="ln3738"> </a>
<a name="ln3739">  // Don't do it when &quot;:vimgrep&quot; is used for &quot;:grep&quot;.</a>
<a name="ln3740">  if ((eap-&gt;cmdidx == CMD_make || eap-&gt;cmdidx == CMD_lmake || isgrep)</a>
<a name="ln3741">      &amp;&amp; !grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln3742">    const char *program = isgrep ? (*curbuf-&gt;b_p_gp == NUL ? p_gp : curbuf-&gt;b_p_gp)</a>
<a name="ln3743">                                 : (*curbuf-&gt;b_p_mp == NUL ? p_mp : curbuf-&gt;b_p_mp);</a>
<a name="ln3744"> </a>
<a name="ln3745">    arg = skipwhite(arg);</a>
<a name="ln3746"> </a>
<a name="ln3747">    char *new_cmdline;</a>
<a name="ln3748">    // Replace $* by given arguments</a>
<a name="ln3749">    if ((new_cmdline = strrep(program, &quot;$*&quot;, arg)) == NULL) {</a>
<a name="ln3750">      // No $* in arg, build &quot;&lt;makeprg&gt; &lt;arg&gt;&quot; instead</a>
<a name="ln3751">      new_cmdline = xmalloc(strlen(program) + strlen(arg) + 2);</a>
<a name="ln3752">      STRCPY(new_cmdline, program);</a>
<a name="ln3753">      STRCAT(new_cmdline, &quot; &quot;);</a>
<a name="ln3754">      STRCAT(new_cmdline, arg);</a>
<a name="ln3755">    }</a>
<a name="ln3756"> </a>
<a name="ln3757">    msg_make(arg);</a>
<a name="ln3758"> </a>
<a name="ln3759">    // 'eap-&gt;cmd' is not set here, because it is not used at CMD_make</a>
<a name="ln3760">    xfree(*cmdlinep);</a>
<a name="ln3761">    *cmdlinep = new_cmdline;</a>
<a name="ln3762">    arg = new_cmdline;</a>
<a name="ln3763">  }</a>
<a name="ln3764">  return arg;</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">/// Expand file name in Ex command argument.</a>
<a name="ln3768">/// When an error is detected, &quot;errormsgp&quot; is set to a non-NULL pointer.</a>
<a name="ln3769">///</a>
<a name="ln3770">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln3771">int expand_filename(exarg_T *eap, char **cmdlinep, const char **errormsgp)</a>
<a name="ln3772">{</a>
<a name="ln3773">  // Skip a regexp pattern for &quot;:vimgrep[add] pat file...&quot;</a>
<a name="ln3774">  char *p = skip_grep_pat(eap);</a>
<a name="ln3775"> </a>
<a name="ln3776">  // Decide to expand wildcards *before* replacing '%', '#', etc.  If</a>
<a name="ln3777">  // the file name contains a wildcard it should not cause expanding.</a>
<a name="ln3778">  // (it will be expanded anyway if there is a wildcard before replacing).</a>
<a name="ln3779">  int has_wildcards = path_has_wildcard(p);</a>
<a name="ln3780">  while (*p != NUL) {</a>
<a name="ln3781">    // Skip over `=expr`, wildcards in it are not expanded.</a>
<a name="ln3782">    if (p[0] == '`' &amp;&amp; p[1] == '=') {</a>
<a name="ln3783">      p += 2;</a>
<a name="ln3784">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln3785">      if (*p == '`') {</a>
<a name="ln3786">        p++;</a>
<a name="ln3787">      }</a>
<a name="ln3788">      continue;</a>
<a name="ln3789">    }</a>
<a name="ln3790">    // Quick check if this cannot be the start of a special string.</a>
<a name="ln3791">    // Also removes backslash before '%', '#' and '&lt;'.</a>
<a name="ln3792">    if (vim_strchr(&quot;%#&lt;&quot;, (uint8_t)(*p)) == NULL) {</a>
<a name="ln3793">      p++;</a>
<a name="ln3794">      continue;</a>
<a name="ln3795">    }</a>
<a name="ln3796"> </a>
<a name="ln3797">    // Try to find a match at this position.</a>
<a name="ln3798">    size_t srclen;</a>
<a name="ln3799">    int escaped;</a>
<a name="ln3800">    char *repl = eval_vars(p, eap-&gt;arg, &amp;srclen, &amp;(eap-&gt;do_ecmd_lnum),</a>
<a name="ln3801">                           errormsgp, &amp;escaped, true);</a>
<a name="ln3802">    if (*errormsgp != NULL) {           // error detected</a>
<a name="ln3803">      return FAIL;</a>
<a name="ln3804">    }</a>
<a name="ln3805">    if (repl == NULL) {                 // no match found</a>
<a name="ln3806">      p += srclen;</a>
<a name="ln3807">      continue;</a>
<a name="ln3808">    }</a>
<a name="ln3809"> </a>
<a name="ln3810">    // Wildcards won't be expanded below, the replacement is taken</a>
<a name="ln3811">    // literally.  But do expand &quot;~/file&quot;, &quot;~user/file&quot; and &quot;$HOME/file&quot;.</a>
<a name="ln3812">    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {</a>
<a name="ln3813">      char *l = repl;</a>
<a name="ln3814"> </a>
<a name="ln3815">      repl = expand_env_save(repl);</a>
<a name="ln3816">      xfree(l);</a>
<a name="ln3817">    }</a>
<a name="ln3818"> </a>
<a name="ln3819">    // Need to escape white space et al. with a backslash.</a>
<a name="ln3820">    // Don't do this for:</a>
<a name="ln3821">    // - replacement that already has been escaped: &quot;##&quot;</a>
<a name="ln3822">    // - shell commands (may have to use quotes instead).</a>
<a name="ln3823">    if (!eap-&gt;usefilter</a>
<a name="ln3824">        &amp;&amp; !escaped</a>
<a name="ln3825">        &amp;&amp; eap-&gt;cmdidx != CMD_bang</a>
<a name="ln3826">        &amp;&amp; eap-&gt;cmdidx != CMD_grep</a>
<a name="ln3827">        &amp;&amp; eap-&gt;cmdidx != CMD_grepadd</a>
<a name="ln3828">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrep</a>
<a name="ln3829">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln3830">        &amp;&amp; eap-&gt;cmdidx != CMD_lmake</a>
<a name="ln3831">        &amp;&amp; eap-&gt;cmdidx != CMD_make</a>
<a name="ln3832">        &amp;&amp; eap-&gt;cmdidx != CMD_terminal</a>
<a name="ln3833">        &amp;&amp; !(eap-&gt;argt &amp; EX_NOSPC)) {</a>
<a name="ln3834">      char *l;</a>
<a name="ln3835">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3836">      // Don't escape a backslash here, because rem_backslash() doesn't</a>
<a name="ln3837">      // remove it later.</a>
<a name="ln3838">      static char *nobslash = &quot; \t\&quot;|&quot;;</a>
<a name="ln3839"># define ESCAPE_CHARS nobslash</a>
<a name="ln3840">#else</a>
<a name="ln3841"># define ESCAPE_CHARS escape_chars</a>
<a name="ln3842">#endif</a>
<a name="ln3843"> </a>
<a name="ln3844">      for (l = repl; *l; l++) {</a>
<a name="ln3845">        if (vim_strchr(ESCAPE_CHARS, (uint8_t)(*l)) != NULL) {</a>
<a name="ln3846">          l = vim_strsave_escaped(repl, ESCAPE_CHARS);</a>
<a name="ln3847">          xfree(repl);</a>
<a name="ln3848">          repl = l;</a>
<a name="ln3849">          break;</a>
<a name="ln3850">        }</a>
<a name="ln3851">      }</a>
<a name="ln3852">    }</a>
<a name="ln3853"> </a>
<a name="ln3854">    // For a shell command a '!' must be escaped.</a>
<a name="ln3855">    if ((eap-&gt;usefilter</a>
<a name="ln3856">         || eap-&gt;cmdidx == CMD_bang</a>
<a name="ln3857">         || eap-&gt;cmdidx == CMD_terminal)</a>
<a name="ln3858">        &amp;&amp; strpbrk(repl, &quot;!&quot;) != NULL) {</a>
<a name="ln3859">      char *l;</a>
<a name="ln3860"> </a>
<a name="ln3861">      l = vim_strsave_escaped(repl, &quot;!&quot;);</a>
<a name="ln3862">      xfree(repl);</a>
<a name="ln3863">      repl = l;</a>
<a name="ln3864">    }</a>
<a name="ln3865"> </a>
<a name="ln3866">    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);</a>
<a name="ln3867">    xfree(repl);</a>
<a name="ln3868">  }</a>
<a name="ln3869"> </a>
<a name="ln3870">  // One file argument: Expand wildcards.</a>
<a name="ln3871">  // Don't do this with &quot;:r !command&quot; or &quot;:w !command&quot;.</a>
<a name="ln3872">  if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; !eap-&gt;usefilter) {</a>
<a name="ln3873">    // Replace environment variables.</a>
<a name="ln3874">    if (has_wildcards) {</a>
<a name="ln3875">      // May expand environment variables.  This</a>
<a name="ln3876">      // can be done much faster with expand_env() than with</a>
<a name="ln3877">      // something else (e.g., calling a shell).</a>
<a name="ln3878">      // After expanding environment variables, check again</a>
<a name="ln3879">      // if there are still wildcards present.</a>
<a name="ln3880">      if (vim_strchr(eap-&gt;arg, '$') != NULL</a>
<a name="ln3881">          || vim_strchr(eap-&gt;arg, '~') != NULL) {</a>
<a name="ln3882">        expand_env_esc(eap-&gt;arg, NameBuff, MAXPATHL, true, true, NULL);</a>
<a name="ln3883">        has_wildcards = path_has_wildcard(NameBuff);</a>
<a name="ln3884">        p = NameBuff;</a>
<a name="ln3885">      } else {</a>
<a name="ln3886">        p = NULL;</a>
<a name="ln3887">      }</a>
<a name="ln3888">      if (p != NULL) {</a>
<a name="ln3889">        (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3890">      }</a>
<a name="ln3891">    }</a>
<a name="ln3892"> </a>
<a name="ln3893">    // Halve the number of backslashes (this is Vi compatible).</a>
<a name="ln3894">    // For Unix, when wildcards are expanded, this is</a>
<a name="ln3895">    // done by ExpandOne() below.</a>
<a name="ln3896">#ifdef UNIX</a>
<a name="ln3897">    if (!has_wildcards) {</a>
<a name="ln3898">      backslash_halve(eap-&gt;arg);</a>
<a name="ln3899">    }</a>
<a name="ln3900">#else</a>
<a name="ln3901">    backslash_halve(eap-&gt;arg);</a>
<a name="ln3902">#endif</a>
<a name="ln3903"> </a>
<a name="ln3904">    if (has_wildcards) {</a>
<a name="ln3905">      expand_T xpc;</a>
<a name="ln3906">      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;</a>
<a name="ln3907"> </a>
<a name="ln3908">      ExpandInit(&amp;xpc);</a>
<a name="ln3909">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln3910">      if (p_wic) {</a>
<a name="ln3911">        options += WILD_ICASE;</a>
<a name="ln3912">      }</a>
<a name="ln3913">      p = ExpandOne(&amp;xpc, eap-&gt;arg, NULL, options, WILD_EXPAND_FREE);</a>
<a name="ln3914">      if (p == NULL) {</a>
<a name="ln3915">        return FAIL;</a>
<a name="ln3916">      }</a>
<a name="ln3917">      (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3918">      xfree(p);</a>
<a name="ln3919">    }</a>
<a name="ln3920">  }</a>
<a name="ln3921">  return OK;</a>
<a name="ln3922">}</a>
<a name="ln3923"> </a>
<a name="ln3924">/// Replace part of the command line, keeping eap-&gt;cmd, eap-&gt;arg, eap-&gt;args and</a>
<a name="ln3925">/// eap-&gt;nextcmd correct.</a>
<a name="ln3926">/// &quot;src&quot; points to the part that is to be replaced, of length &quot;srclen&quot;.</a>
<a name="ln3927">/// &quot;repl&quot; is the replacement string.</a>
<a name="ln3928">///</a>
<a name="ln3929">/// @return  a pointer to the character after the replaced string.</a>
<a name="ln3930">static char *repl_cmdline(exarg_T *eap, char *src, size_t srclen, char *repl, char **cmdlinep)</a>
<a name="ln3931">{</a>
<a name="ln3932">  // The new command line is build in new_cmdline[].</a>
<a name="ln3933">  // First allocate it.</a>
<a name="ln3934">  // Careful: a &quot;+cmd&quot; argument may have been NUL terminated.</a>
<a name="ln3935">  size_t len = strlen(repl);</a>
<a name="ln3936">  size_t i = (size_t)(src - *cmdlinep) + strlen(src + srclen) + len + 3;</a>
<a name="ln3937">  if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln3938">    i += strlen(eap-&gt;nextcmd);    // add space for next command</a>
<a name="ln3939">  }</a>
<a name="ln3940">  char *new_cmdline = xmalloc(i);</a>
<a name="ln3941">  size_t offset = (size_t)(src - *cmdlinep);</a>
<a name="ln3942"> </a>
<a name="ln3943">  // Copy the stuff before the expanded part.</a>
<a name="ln3944">  // Copy the expanded stuff.</a>
<a name="ln3945">  // Copy what came after the expanded part.</a>
<a name="ln3946">  // Copy the next commands, if there are any.</a>
<a name="ln3947">  i = offset;   // length of part before match</a>
<a name="ln3948">  memmove(new_cmdline, *cmdlinep, i);</a>
<a name="ln3949"> </a>
<a name="ln3950">  memmove(new_cmdline + i, repl, len);</a>
<a name="ln3951">  i += len;                             // remember the end of the string</a>
<a name="ln3952">  STRCPY(new_cmdline + i, src + srclen);</a>
<a name="ln3953">  src = new_cmdline + i;                // remember where to continue</a>
<a name="ln3954"> </a>
<a name="ln3955">  if (eap-&gt;nextcmd != NULL) {           // append next command</a>
<a name="ln3956">    i = strlen(new_cmdline) + 1;</a>
<a name="ln3957">    STRCPY(new_cmdline + i, eap-&gt;nextcmd);</a>
<a name="ln3958">    eap-&gt;nextcmd = new_cmdline + i;</a>
<a name="ln3959">  }</a>
<a name="ln3960">  eap-&gt;cmd = new_cmdline + (eap-&gt;cmd - *cmdlinep);</a>
<a name="ln3961">  eap-&gt;arg = new_cmdline + (eap-&gt;arg - *cmdlinep);</a>
<a name="ln3962"> </a>
<a name="ln3963">  for (size_t j = 0; j &lt; eap-&gt;argc; j++) {</a>
<a name="ln3964">    if (offset &gt;= (size_t)(eap-&gt;args[j] - *cmdlinep)) {</a>
<a name="ln3965">      // If replaced text is after or in the same position as the argument,</a>
<a name="ln3966">      // the argument's position relative to the beginning of the cmdline stays the same.</a>
<a name="ln3967">      eap-&gt;args[j] = new_cmdline + (eap-&gt;args[j] - *cmdlinep);</a>
<a name="ln3968">    } else {</a>
<a name="ln3969">      // Otherwise, argument gets shifted alongside the replaced text.</a>
<a name="ln3970">      // The amount of the shift is equal to the difference of the old and new string length.</a>
<a name="ln3971">      eap-&gt;args[j] = new_cmdline + ((eap-&gt;args[j] - *cmdlinep) + (ptrdiff_t)(len - srclen));</a>
<a name="ln3972">    }</a>
<a name="ln3973">  }</a>
<a name="ln3974"> </a>
<a name="ln3975">  if (eap-&gt;do_ecmd_cmd != NULL &amp;&amp; eap-&gt;do_ecmd_cmd != dollar_command) {</a>
<a name="ln3976">    eap-&gt;do_ecmd_cmd = new_cmdline + (eap-&gt;do_ecmd_cmd - *cmdlinep);</a>
<a name="ln3977">  }</a>
<a name="ln3978">  xfree(*cmdlinep);</a>
<a name="ln3979">  *cmdlinep = new_cmdline;</a>
<a name="ln3980"> </a>
<a name="ln3981">  return src;</a>
<a name="ln3982">}</a>
<a name="ln3983"> </a>
<a name="ln3984">/// Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln3985">void separate_nextcmd(exarg_T *eap)</a>
<a name="ln3986">{</a>
<a name="ln3987">  char *p = skip_grep_pat(eap);</a>
<a name="ln3988"> </a>
<a name="ln3989">  for (; *p; MB_PTR_ADV(p)) {</a>
<a name="ln3990">    if (*p == Ctrl_V) {</a>
<a name="ln3991">      if (eap-&gt;argt &amp; (EX_CTRLV | EX_XFILE)) {</a>
<a name="ln3992">        p++;  // skip CTRL-V and next char</a>
<a name="ln3993">      } else {</a>
<a name="ln3994">        // remove CTRL-V and skip next char</a>
<a name="ln3995">        STRMOVE(p, p + 1);</a>
<a name="ln3996">      }</a>
<a name="ln3997">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln3998">        break;</a>
<a name="ln3999">      }</a>
<a name="ln4000">    } else if (p[0] == '`' &amp;&amp; p[1] == '=' &amp;&amp; (eap-&gt;argt &amp; EX_XFILE)) {</a>
<a name="ln4001">      // Skip over `=expr` when wildcards are expanded.</a>
<a name="ln4002">      p += 2;</a>
<a name="ln4003">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln4004">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4005">        break;</a>
<a name="ln4006">      }</a>
<a name="ln4007">    } else if (</a>
<a name="ln4008">               // Check for '&quot;': start of comment or '|': next command */</a>
<a name="ln4009">               // :@&quot; does not start a comment!</a>
<a name="ln4010">               // :redir @&quot; doesn't either.</a>
<a name="ln4011">               (*p == '&quot;'</a>
<a name="ln4012">                &amp;&amp; !(eap-&gt;argt &amp; EX_NOTRLCOM)</a>
<a name="ln4013">                &amp;&amp; (eap-&gt;cmdidx != CMD_at || p != eap-&gt;arg)</a>
<a name="ln4014">                &amp;&amp; (eap-&gt;cmdidx != CMD_redir</a>
<a name="ln4015">                    || p != eap-&gt;arg + 1 || p[-1] != '@')) || *p == '|' || *p == '\n') {</a>
<a name="ln4016">      // We remove the '\' before the '|', unless EX_CTRLV is used</a>
<a name="ln4017">      // AND 'b' is present in 'cpoptions'.</a>
<a name="ln4018">      if ((vim_strchr(p_cpo, CPO_BAR) == NULL</a>
<a name="ln4019">           || !(eap-&gt;argt &amp; EX_CTRLV)) &amp;&amp; *(p - 1) == '\\') {</a>
<a name="ln4020">        STRMOVE(p - 1, p);  // remove the '\'</a>
<a name="ln4021">        p--;</a>
<a name="ln4022">      } else {</a>
<a name="ln4023">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln4024">        *p = NUL;</a>
<a name="ln4025">        break;</a>
<a name="ln4026">      }</a>
<a name="ln4027">    }</a>
<a name="ln4028">  }</a>
<a name="ln4029"> </a>
<a name="ln4030">  if (!(eap-&gt;argt &amp; EX_NOTRLCOM)) {  // remove trailing spaces</a>
<a name="ln4031">    del_trailing_spaces(eap-&gt;arg);</a>
<a name="ln4032">  }</a>
<a name="ln4033">}</a>
<a name="ln4034"> </a>
<a name="ln4035">/// get + command from ex argument</a>
<a name="ln4036">static char *getargcmd(char **argp)</a>
<a name="ln4037">{</a>
<a name="ln4038">  char *arg = *argp;</a>
<a name="ln4039">  char *command = NULL;</a>
<a name="ln4040"> </a>
<a name="ln4041">  if (*arg == '+') {        // +[command]</a>
<a name="ln4042">    arg++;</a>
<a name="ln4043">    if (ascii_isspace(*arg) || *arg == '\0') {</a>
<a name="ln4044">      command = dollar_command;</a>
<a name="ln4045">    } else {</a>
<a name="ln4046">      command = arg;</a>
<a name="ln4047">      arg = skip_cmd_arg(command, true);</a>
<a name="ln4048">      if (*arg != NUL) {</a>
<a name="ln4049">        *arg++ = NUL;                   // terminate command with NUL</a>
<a name="ln4050">      }</a>
<a name="ln4051">    }</a>
<a name="ln4052"> </a>
<a name="ln4053">    arg = skipwhite(arg);       // skip over spaces</a>
<a name="ln4054">    *argp = arg;</a>
<a name="ln4055">  }</a>
<a name="ln4056">  return command;</a>
<a name="ln4057">}</a>
<a name="ln4058"> </a>
<a name="ln4059">/// Find end of &quot;+command&quot; argument.  Skip over &quot;\ &quot; and &quot;\\&quot;.</a>
<a name="ln4060">///</a>
<a name="ln4061">/// @param rembs  true to halve the number of backslashes</a>
<a name="ln4062">char *skip_cmd_arg(char *p, int rembs)</a>
<a name="ln4063">{</a>
<a name="ln4064">  while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln4065">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4066">      if (rembs) {</a>
<a name="ln4067">        STRMOVE(p, p + 1);</a>
<a name="ln4068">      } else {</a>
<a name="ln4069">        p++;</a>
<a name="ln4070">      }</a>
<a name="ln4071">    }</a>
<a name="ln4072">    MB_PTR_ADV(p);</a>
<a name="ln4073">  }</a>
<a name="ln4074">  return p;</a>
<a name="ln4075">}</a>
<a name="ln4076"> </a>
<a name="ln4077">int get_bad_opt(const char *p, exarg_T *eap)</a>
<a name="ln4078">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4079">{</a>
<a name="ln4080">  if (STRICMP(p, &quot;keep&quot;) == 0) {</a>
<a name="ln4081">    eap-&gt;bad_char = BAD_KEEP;</a>
<a name="ln4082">  } else if (STRICMP(p, &quot;drop&quot;) == 0) {</a>
<a name="ln4083">    eap-&gt;bad_char = BAD_DROP;</a>
<a name="ln4084">  } else if (MB_BYTE2LEN((uint8_t)(*p)) == 1 &amp;&amp; p[1] == NUL) {</a>
<a name="ln4085">    eap-&gt;bad_char = (uint8_t)(*p);</a>
<a name="ln4086">  } else {</a>
<a name="ln4087">    return FAIL;</a>
<a name="ln4088">  }</a>
<a name="ln4089">  return OK;</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">/// Get &quot;++opt=arg&quot; argument.</a>
<a name="ln4093">///</a>
<a name="ln4094">/// @return  FAIL or OK.</a>
<a name="ln4095">static int getargopt(exarg_T *eap)</a>
<a name="ln4096">{</a>
<a name="ln4097">  char *arg = eap-&gt;arg + 2;</a>
<a name="ln4098">  int *pp = NULL;</a>
<a name="ln4099">  int bad_char_idx;</a>
<a name="ln4100"> </a>
<a name="ln4101">  // &quot;:edit ++[no]bin[ary] file&quot;</a>
<a name="ln4102">  if (strncmp(arg, &quot;bin&quot;, 3) == 0 || strncmp(arg, &quot;nobin&quot;, 5) == 0) {</a>
<a name="ln4103">    if (*arg == 'n') {</a>
<a name="ln4104">      arg += 2;</a>
<a name="ln4105">      eap-&gt;force_bin = FORCE_NOBIN;</a>
<a name="ln4106">    } else {</a>
<a name="ln4107">      eap-&gt;force_bin = FORCE_BIN;</a>
<a name="ln4108">    }</a>
<a name="ln4109">    if (!checkforcmd(&amp;arg, &quot;binary&quot;, 3)) {</a>
<a name="ln4110">      return FAIL;</a>
<a name="ln4111">    }</a>
<a name="ln4112">    eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4113">    return OK;</a>
<a name="ln4114">  }</a>
<a name="ln4115"> </a>
<a name="ln4116">  // &quot;:read ++edit file&quot;</a>
<a name="ln4117">  if (strncmp(arg, &quot;edit&quot;, 4) == 0) {</a>
<a name="ln4118">    eap-&gt;read_edit = true;</a>
<a name="ln4119">    eap-&gt;arg = skipwhite(arg + 4);</a>
<a name="ln4120">    return OK;</a>
<a name="ln4121">  }</a>
<a name="ln4122"> </a>
<a name="ln4123">  // &quot;:write ++p foo/bar/file</a>
<a name="ln4124">  if (strncmp(arg, &quot;p&quot;, 1) == 0) {</a>
<a name="ln4125">    eap-&gt;mkdir_p = true;</a>
<a name="ln4126">    eap-&gt;arg = skipwhite(arg + 1);</a>
<a name="ln4127">    return OK;</a>
<a name="ln4128">  }</a>
<a name="ln4129"> </a>
<a name="ln4130">  if (strncmp(arg, &quot;ff&quot;, 2) == 0) {</a>
<a name="ln4131">    arg += 2;</a>
<a name="ln4132">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4133">  } else if (strncmp(arg, &quot;fileformat&quot;, 10) == 0) {</a>
<a name="ln4134">    arg += 10;</a>
<a name="ln4135">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4136">  } else if (strncmp(arg, &quot;enc&quot;, 3) == 0) {</a>
<a name="ln4137">    if (strncmp(arg, &quot;encoding&quot;, 8) == 0) {</a>
<a name="ln4138">      arg += 8;</a>
<a name="ln4139">    } else {</a>
<a name="ln4140">      arg += 3;</a>
<a name="ln4141">    }</a>
<a name="ln4142">    pp = &amp;eap-&gt;force_enc;</a>
<a name="ln4143">  } else if (strncmp(arg, &quot;bad&quot;, 3) == 0) {</a>
<a name="ln4144">    arg += 3;</a>
<a name="ln4145">    pp = &amp;bad_char_idx;</a>
<a name="ln4146">  }</a>
<a name="ln4147"> </a>
<a name="ln4148">  if (pp == NULL || *arg != '=') {</a>
<a name="ln4149">    return FAIL;</a>
<a name="ln4150">  }</a>
<a name="ln4151"> </a>
<a name="ln4152">  arg++;</a>
<a name="ln4153">  *pp = (int)(arg - eap-&gt;cmd);</a>
<a name="ln4154">  arg = skip_cmd_arg(arg, false);</a>
<a name="ln4155">  eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4156">  *arg = NUL;</a>
<a name="ln4157"> </a>
<a name="ln4158">  if (pp == &amp;eap-&gt;force_ff) {</a>
<a name="ln4159">    if (check_ff_value(eap-&gt;cmd + eap-&gt;force_ff) == FAIL) {</a>
<a name="ln4160">      return FAIL;</a>
<a name="ln4161">    }</a>
<a name="ln4162">    eap-&gt;force_ff = (uint8_t)eap-&gt;cmd[eap-&gt;force_ff];</a>
<a name="ln4163">  } else if (pp == &amp;eap-&gt;force_enc) {</a>
<a name="ln4164">    // Make 'fileencoding' lower case.</a>
<a name="ln4165">    for (char *p = eap-&gt;cmd + eap-&gt;force_enc; *p != NUL; p++) {</a>
<a name="ln4166">      *p = (char)TOLOWER_ASC(*p);</a>
<a name="ln4167">    }</a>
<a name="ln4168">  } else {</a>
<a name="ln4169">    // Check ++bad= argument.  Must be a single-byte character, &quot;keep&quot; or</a>
<a name="ln4170">    // &quot;drop&quot;.</a>
<a name="ln4171">    if (get_bad_opt(eap-&gt;cmd + bad_char_idx, eap) == FAIL) {</a>
<a name="ln4172">      return FAIL;</a>
<a name="ln4173">    }</a>
<a name="ln4174">  }</a>
<a name="ln4175"> </a>
<a name="ln4176">  return OK;</a>
<a name="ln4177">}</a>
<a name="ln4178"> </a>
<a name="ln4179">/// Handle the argument for a tabpage related ex command.</a>
<a name="ln4180">/// When an error is encountered then eap-&gt;errmsg is set.</a>
<a name="ln4181">///</a>
<a name="ln4182">/// @return  a tabpage number.</a>
<a name="ln4183">static int get_tabpage_arg(exarg_T *eap)</a>
<a name="ln4184">{</a>
<a name="ln4185">  int tab_number = 0;</a>
<a name="ln4186">  int unaccept_arg0 = (eap-&gt;cmdidx == CMD_tabmove) ? 0 : 1;</a>
<a name="ln4187"> </a>
<a name="ln4188">  if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln4189">    char *p = eap-&gt;arg;</a>
<a name="ln4190">    int relative = 0;  // argument +N/-N means: go to N places to the</a>
<a name="ln4191">                       // right/left relative to the current position.</a>
<a name="ln4192"> </a>
<a name="ln4193">    if (*p == '-') {</a>
<a name="ln4194">      relative = -1;</a>
<a name="ln4195">      p++;</a>
<a name="ln4196">    } else if (*p == '+') {</a>
<a name="ln4197">      relative = 1;</a>
<a name="ln4198">      p++;</a>
<a name="ln4199">    }</a>
<a name="ln4200"> </a>
<a name="ln4201">    char *p_save = p;</a>
<a name="ln4202">    tab_number = (int)getdigits(&amp;p, false, tab_number);</a>
<a name="ln4203"> </a>
<a name="ln4204">    if (relative == 0) {</a>
<a name="ln4205">      if (strcmp(p, &quot;$&quot;) == 0) {</a>
<a name="ln4206">        tab_number = LAST_TAB_NR;</a>
<a name="ln4207">      } else if (strcmp(p, &quot;#&quot;) == 0) {</a>
<a name="ln4208">        if (valid_tabpage(lastused_tabpage)) {</a>
<a name="ln4209">          tab_number = tabpage_index(lastused_tabpage);</a>
<a name="ln4210">        } else {</a>
<a name="ln4211">          eap-&gt;errmsg = ex_errmsg(e_invargval, eap-&gt;arg);</a>
<a name="ln4212">          tab_number = 0;</a>
<a name="ln4213">          goto theend;</a>
<a name="ln4214">        }</a>
<a name="ln4215">      } else if (p == p_save || *p_save == '-' || *p != NUL</a>
<a name="ln4216">                 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4217">        // No numbers as argument.</a>
<a name="ln4218">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4219">        goto theend;</a>
<a name="ln4220">      }</a>
<a name="ln4221">    } else {</a>
<a name="ln4222">      if (*p_save == NUL) {</a>
<a name="ln4223">        tab_number = 1;</a>
<a name="ln4224">      } else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {</a>
<a name="ln4225">        // No numbers as argument.</a>
<a name="ln4226">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4227">        goto theend;</a>
<a name="ln4228">      }</a>
<a name="ln4229">      tab_number = tab_number * relative + tabpage_index(curtab);</a>
<a name="ln4230">      if (!unaccept_arg0 &amp;&amp; relative == -1) {</a>
<a name="ln4231">        tab_number--;</a>
<a name="ln4232">      }</a>
<a name="ln4233">    }</a>
<a name="ln4234">    if (tab_number &lt; unaccept_arg0 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4235">      eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4236">    }</a>
<a name="ln4237">  } else if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4238">    if (unaccept_arg0 &amp;&amp; eap-&gt;line2 == 0) {</a>
<a name="ln4239">      eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4240">      tab_number = 0;</a>
<a name="ln4241">    } else {</a>
<a name="ln4242">      tab_number = (int)eap-&gt;line2;</a>
<a name="ln4243">      char *cmdp = eap-&gt;cmd;</a>
<a name="ln4244">      while (--cmdp &gt; *eap-&gt;cmdlinep &amp;&amp; (*cmdp == ' ' || ascii_isdigit(*cmdp))) {}</a>
<a name="ln4245">      if (!unaccept_arg0 &amp;&amp; *cmdp == '-') {</a>
<a name="ln4246">        tab_number--;</a>
<a name="ln4247">        if (tab_number &lt; unaccept_arg0) {</a>
<a name="ln4248">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4249">        }</a>
<a name="ln4250">      }</a>
<a name="ln4251">    }</a>
<a name="ln4252">  } else {</a>
<a name="ln4253">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4254">    case CMD_tabnext:</a>
<a name="ln4255">      tab_number = tabpage_index(curtab) + 1;</a>
<a name="ln4256">      if (tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4257">        tab_number = 1;</a>
<a name="ln4258">      }</a>
<a name="ln4259">      break;</a>
<a name="ln4260">    case CMD_tabmove:</a>
<a name="ln4261">      tab_number = LAST_TAB_NR;</a>
<a name="ln4262">      break;</a>
<a name="ln4263">    default:</a>
<a name="ln4264">      tab_number = tabpage_index(curtab);</a>
<a name="ln4265">    }</a>
<a name="ln4266">  }</a>
<a name="ln4267"> </a>
<a name="ln4268">theend:</a>
<a name="ln4269">  return tab_number;</a>
<a name="ln4270">}</a>
<a name="ln4271"> </a>
<a name="ln4272">static void ex_autocmd(exarg_T *eap)</a>
<a name="ln4273">{</a>
<a name="ln4274">  // Disallow autocommands in secure mode.</a>
<a name="ln4275">  if (secure) {</a>
<a name="ln4276">    secure = 2;</a>
<a name="ln4277">    eap-&gt;errmsg = _(e_curdir);</a>
<a name="ln4278">  } else if (eap-&gt;cmdidx == CMD_autocmd) {</a>
<a name="ln4279">    do_autocmd(eap, eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4280">  } else {</a>
<a name="ln4281">    do_augroup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4282">  }</a>
<a name="ln4283">}</a>
<a name="ln4284"> </a>
<a name="ln4285">/// &quot;:doautocmd&quot;: Apply the automatic commands to the current buffer.</a>
<a name="ln4286">static void ex_doautocmd(exarg_T *eap)</a>
<a name="ln4287">{</a>
<a name="ln4288">  char *arg = eap-&gt;arg;</a>
<a name="ln4289">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln4290">  bool did_aucmd;</a>
<a name="ln4291"> </a>
<a name="ln4292">  (void)do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln4293">  // Only when there is no &lt;nomodeline&gt;.</a>
<a name="ln4294">  if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln4295">    do_modelines(0);</a>
<a name="ln4296">  }</a>
<a name="ln4297">}</a>
<a name="ln4298"> </a>
<a name="ln4299">/// :[N]bunload[!] [N] [bufname] unload buffer</a>
<a name="ln4300">/// :[N]bdelete[!] [N] [bufname] delete buffer from buffer list</a>
<a name="ln4301">/// :[N]bwipeout[!] [N] [bufname] delete buffer really</a>
<a name="ln4302">static void ex_bunload(exarg_T *eap)</a>
<a name="ln4303">{</a>
<a name="ln4304">  eap-&gt;errmsg = do_bufdel(eap-&gt;cmdidx == CMD_bdelete</a>
<a name="ln4305">                          ? DOBUF_DEL</a>
<a name="ln4306">                          : eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln4307">                          ? DOBUF_WIPE</a>
<a name="ln4308">                          : DOBUF_UNLOAD,</a>
<a name="ln4309">                          eap-&gt;arg, eap-&gt;addr_count, (int)eap-&gt;line1, (int)eap-&gt;line2,</a>
<a name="ln4310">                          eap-&gt;forceit);</a>
<a name="ln4311">}</a>
<a name="ln4312"> </a>
<a name="ln4313">/// :[N]buffer [N]       to buffer N</a>
<a name="ln4314">/// :[N]sbuffer [N]      to buffer N</a>
<a name="ln4315">static void ex_buffer(exarg_T *eap)</a>
<a name="ln4316">{</a>
<a name="ln4317">  if (*eap-&gt;arg) {</a>
<a name="ln4318">    eap-&gt;errmsg = ex_errmsg(e_trailing_arg, eap-&gt;arg);</a>
<a name="ln4319">  } else {</a>
<a name="ln4320">    if (eap-&gt;addr_count == 0) {  // default is current buffer</a>
<a name="ln4321">      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);</a>
<a name="ln4322">    } else {</a>
<a name="ln4323">      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4324">    }</a>
<a name="ln4325">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4326">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4327">    }</a>
<a name="ln4328">  }</a>
<a name="ln4329">}</a>
<a name="ln4330"> </a>
<a name="ln4331">/// :[N]bmodified [N]    to next mod. buffer</a>
<a name="ln4332">/// :[N]sbmodified [N]   to next mod. buffer</a>
<a name="ln4333">static void ex_bmodified(exarg_T *eap)</a>
<a name="ln4334">{</a>
<a name="ln4335">  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4336">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4337">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4338">  }</a>
<a name="ln4339">}</a>
<a name="ln4340"> </a>
<a name="ln4341">/// :[N]bnext [N]        to next buffer</a>
<a name="ln4342">/// :[N]sbnext [N]       split and to next buffer</a>
<a name="ln4343">static void ex_bnext(exarg_T *eap)</a>
<a name="ln4344">{</a>
<a name="ln4345">  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4346">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4347">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4348">  }</a>
<a name="ln4349">}</a>
<a name="ln4350"> </a>
<a name="ln4351">/// :[N]bNext [N]        to previous buffer</a>
<a name="ln4352">/// :[N]bprevious [N]    to previous buffer</a>
<a name="ln4353">/// :[N]sbNext [N]       split and to previous buffer</a>
<a name="ln4354">/// :[N]sbprevious [N]   split and to previous buffer</a>
<a name="ln4355">static void ex_bprevious(exarg_T *eap)</a>
<a name="ln4356">{</a>
<a name="ln4357">  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap-&gt;line2);</a>
<a name="ln4358">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4359">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4360">  }</a>
<a name="ln4361">}</a>
<a name="ln4362"> </a>
<a name="ln4363">/// :brewind             to first buffer</a>
<a name="ln4364">/// :bfirst              to first buffer</a>
<a name="ln4365">/// :sbrewind            split and to first buffer</a>
<a name="ln4366">/// :sbfirst             split and to first buffer</a>
<a name="ln4367">static void ex_brewind(exarg_T *eap)</a>
<a name="ln4368">{</a>
<a name="ln4369">  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);</a>
<a name="ln4370">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4371">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4372">  }</a>
<a name="ln4373">}</a>
<a name="ln4374"> </a>
<a name="ln4375">/// :blast               to last buffer</a>
<a name="ln4376">/// :sblast              split and to last buffer</a>
<a name="ln4377">static void ex_blast(exarg_T *eap)</a>
<a name="ln4378">{</a>
<a name="ln4379">  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);</a>
<a name="ln4380">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4381">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4382">  }</a>
<a name="ln4383">}</a>
<a name="ln4384"> </a>
<a name="ln4385">int ends_excmd(int c) FUNC_ATTR_CONST</a>
<a name="ln4386">{</a>
<a name="ln4387">  return c == NUL || c == '|' || c == '&quot;' || c == '\n';</a>
<a name="ln4388">}</a>
<a name="ln4389"> </a>
<a name="ln4390">/// @return  the next command, after the first '|' or '\n' or,</a>
<a name="ln4391">///          NULL if not found.</a>
<a name="ln4392">char *find_nextcmd(const char *p)</a>
<a name="ln4393">{</a>
<a name="ln4394">  while (*p != '|' &amp;&amp; *p != '\n') {</a>
<a name="ln4395">    if (*p == NUL) {</a>
<a name="ln4396">      return NULL;</a>
<a name="ln4397">    }</a>
<a name="ln4398">    p++;</a>
<a name="ln4399">  }</a>
<a name="ln4400">  return (char *)p + 1;</a>
<a name="ln4401">}</a>
<a name="ln4402"> </a>
<a name="ln4403">/// Check if *p is a separator between Ex commands, skipping over white space.</a>
<a name="ln4404">///</a>
<a name="ln4405">/// @return  NULL if it isn't, the following character if it is.</a>
<a name="ln4406">char *check_nextcmd(char *p)</a>
<a name="ln4407">{</a>
<a name="ln4408">  char *s = skipwhite(p);</a>
<a name="ln4409"> </a>
<a name="ln4410">  if (*s == '|' || *s == '\n') {</a>
<a name="ln4411">    return s + 1;</a>
<a name="ln4412">  }</a>
<a name="ln4413">  return NULL;</a>
<a name="ln4414">}</a>
<a name="ln4415"> </a>
<a name="ln4416">/// - if there are more files to edit</a>
<a name="ln4417">/// - and this is the last window</a>
<a name="ln4418">/// - and forceit not used</a>
<a name="ln4419">/// - and not repeated twice on a row</a>
<a name="ln4420">///</a>
<a name="ln4421">/// @param   message  when false check only, no messages</a>
<a name="ln4422">///</a>
<a name="ln4423">/// @return  FAIL and give error message if 'message' true, return OK otherwise</a>
<a name="ln4424">static int check_more(int message, bool forceit)</a>
<a name="ln4425">{</a>
<a name="ln4426">  int n = ARGCOUNT - curwin-&gt;w_arg_idx - 1;</a>
<a name="ln4427"> </a>
<a name="ln4428">  if (!forceit &amp;&amp; only_one_window()</a>
<a name="ln4429">      &amp;&amp; ARGCOUNT &gt; 1 &amp;&amp; !arg_had_last &amp;&amp; n &gt; 0 &amp;&amp; quitmore == 0) {</a>
<a name="ln4430">    if (message) {</a>
<a name="ln4431">      if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln4432">        char buff[DIALOG_MSG_SIZE];</a>
<a name="ln4433"> </a>
<a name="ln4434">        vim_snprintf(buff, DIALOG_MSG_SIZE,</a>
<a name="ln4435">                     NGETTEXT(&quot;%d more file to edit.  Quit anyway?&quot;,</a>
<a name="ln4436">                              &quot;%d more files to edit.  Quit anyway?&quot;, n), n);</a>
<a name="ln4437">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES) {</a>
<a name="ln4438">          return OK;</a>
<a name="ln4439">        }</a>
<a name="ln4440">        return FAIL;</a>
<a name="ln4441">      }</a>
<a name="ln4442">      semsg(NGETTEXT(&quot;E173: %&quot; PRId64 &quot; more file to edit&quot;,</a>
<a name="ln4443">                     &quot;E173: %&quot; PRId64 &quot; more files to edit&quot;, n), (int64_t)n);</a>
<a name="ln4444">      quitmore = 2;                 // next try to quit is allowed</a>
<a name="ln4445">    }</a>
<a name="ln4446">    return FAIL;</a>
<a name="ln4447">  }</a>
<a name="ln4448">  return OK;</a>
<a name="ln4449">}</a>
<a name="ln4450"> </a>
<a name="ln4451">/// Function given to ExpandGeneric() to obtain the list of command names.</a>
<a name="ln4452">char *get_command_name(expand_T *xp, int idx)</a>
<a name="ln4453">{</a>
<a name="ln4454">  if (idx &gt;= CMD_SIZE) {</a>
<a name="ln4455">    return expand_user_command_name(idx);</a>
<a name="ln4456">  }</a>
<a name="ln4457">  return cmdnames[idx].cmd_name;</a>
<a name="ln4458">}</a>
<a name="ln4459"> </a>
<a name="ln4460">static void ex_colorscheme(exarg_T *eap)</a>
<a name="ln4461">{</a>
<a name="ln4462">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln4463">    char *expr = xstrdup(&quot;g:colors_name&quot;);</a>
<a name="ln4464"> </a>
<a name="ln4465">    emsg_off++;</a>
<a name="ln4466">    char *p = eval_to_string(expr, false);</a>
<a name="ln4467">    emsg_off--;</a>
<a name="ln4468">    xfree(expr);</a>
<a name="ln4469"> </a>
<a name="ln4470">    if (p != NULL) {</a>
<a name="ln4471">      msg(p, 0);</a>
<a name="ln4472">      xfree(p);</a>
<a name="ln4473">    } else {</a>
<a name="ln4474">      msg(&quot;default&quot;, 0);</a>
<a name="ln4475">    }</a>
<a name="ln4476">  } else if (load_colors(eap-&gt;arg) == FAIL) {</a>
<a name="ln4477">    semsg(_(&quot;E185: Cannot find color scheme '%s'&quot;), eap-&gt;arg);</a>
<a name="ln4478">  }</a>
<a name="ln4479">}</a>
<a name="ln4480"> </a>
<a name="ln4481">static void ex_highlight(exarg_T *eap)</a>
<a name="ln4482">{</a>
<a name="ln4483">  if (*eap-&gt;arg == NUL &amp;&amp; eap-&gt;cmd[2] == '!') {</a>
<a name="ln4484">    msg(_(&quot;Greetings, Vim user!&quot;), 0);</a>
<a name="ln4485">  }</a>
<a name="ln4486">  do_highlight(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln4487">}</a>
<a name="ln4488"> </a>
<a name="ln4489">/// Call this function if we thought we were going to exit, but we won't</a>
<a name="ln4490">/// (because of an error).  May need to restore the terminal mode.</a>
<a name="ln4491">void not_exiting(void)</a>
<a name="ln4492">{</a>
<a name="ln4493">  exiting = false;</a>
<a name="ln4494">}</a>
<a name="ln4495"> </a>
<a name="ln4496">bool before_quit_autocmds(win_T *wp, bool quit_all, bool forceit)</a>
<a name="ln4497">{</a>
<a name="ln4498">  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp-&gt;w_buffer);</a>
<a name="ln4499"> </a>
<a name="ln4500">  // Bail out when autocommands closed the window.</a>
<a name="ln4501">  // Refuse to quit when the buffer in the last window is being closed (can</a>
<a name="ln4502">  // only happen in autocommands).</a>
<a name="ln4503">  if (!win_valid(wp)</a>
<a name="ln4504">      || curbuf_locked()</a>
<a name="ln4505">      || (wp-&gt;w_buffer-&gt;b_nwindows == 1 &amp;&amp; wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln4506">    return true;</a>
<a name="ln4507">  }</a>
<a name="ln4508"> </a>
<a name="ln4509">  if (quit_all</a>
<a name="ln4510">      || (check_more(false, forceit) == OK &amp;&amp; only_one_window())) {</a>
<a name="ln4511">    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);</a>
<a name="ln4512">    // Refuse to quit when locked or when the window was closed or the</a>
<a name="ln4513">    // buffer in the last window is being closed (can only happen in</a>
<a name="ln4514">    // autocommands).</a>
<a name="ln4515">    if (!win_valid(wp)</a>
<a name="ln4516">        || curbuf_locked()</a>
<a name="ln4517">        || (curbuf-&gt;b_nwindows == 1 &amp;&amp; curbuf-&gt;b_locked &gt; 0)) {</a>
<a name="ln4518">      return true;</a>
<a name="ln4519">    }</a>
<a name="ln4520">  }</a>
<a name="ln4521"> </a>
<a name="ln4522">  return false;</a>
<a name="ln4523">}</a>
<a name="ln4524"> </a>
<a name="ln4525">/// &quot;:quit&quot;: quit current window, quit Vim if the last window is closed.</a>
<a name="ln4526">/// &quot;:{nr}quit&quot;: quit window {nr}</a>
<a name="ln4527">static void ex_quit(exarg_T *eap)</a>
<a name="ln4528">{</a>
<a name="ln4529">  if (cmdwin_type != 0) {</a>
<a name="ln4530">    cmdwin_result = Ctrl_C;</a>
<a name="ln4531">    return;</a>
<a name="ln4532">  }</a>
<a name="ln4533">  // Don't quit while editing the command line.</a>
<a name="ln4534">  if (text_locked()) {</a>
<a name="ln4535">    text_locked_msg();</a>
<a name="ln4536">    return;</a>
<a name="ln4537">  }</a>
<a name="ln4538"> </a>
<a name="ln4539">  win_T *wp;</a>
<a name="ln4540"> </a>
<a name="ln4541">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4542">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4543"> </a>
<a name="ln4544">    for (wp = firstwin; wp-&gt;w_next != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln4545">      if (--wnr &lt;= 0) {</a>
<a name="ln4546">        break;</a>
<a name="ln4547">      }</a>
<a name="ln4548">    }</a>
<a name="ln4549">  } else {</a>
<a name="ln4550">    wp = curwin;</a>
<a name="ln4551">  }</a>
<a name="ln4552"> </a>
<a name="ln4553">  // Refuse to quit when locked.</a>
<a name="ln4554">  if (curbuf_locked()) {</a>
<a name="ln4555">    return;</a>
<a name="ln4556">  }</a>
<a name="ln4557"> </a>
<a name="ln4558">  // Trigger QuitPre and maybe ExitPre</a>
<a name="ln4559">  if (before_quit_autocmds(wp, false, eap-&gt;forceit)) {</a>
<a name="ln4560">    return;</a>
<a name="ln4561">  }</a>
<a name="ln4562"> </a>
<a name="ln4563">  // If there is only one relevant window we will exit.</a>
<a name="ln4564">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4565">    exiting = true;</a>
<a name="ln4566">  }</a>
<a name="ln4567">  if ((!buf_hide(wp-&gt;w_buffer)</a>
<a name="ln4568">       &amp;&amp; check_changed(wp-&gt;w_buffer, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4569">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4570">                        | CCGD_EXCMD))</a>
<a name="ln4571">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4572">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, true))) {</a>
<a name="ln4573">    not_exiting();</a>
<a name="ln4574">  } else {</a>
<a name="ln4575">    // quit last window</a>
<a name="ln4576">    // Note: only_one_window() returns true, even so a help window is</a>
<a name="ln4577">    // still open. In that case only quit, if no address has been</a>
<a name="ln4578">    // specified. Example:</a>
<a name="ln4579">    // :h|wincmd w|1q     - don't quit</a>
<a name="ln4580">    // :h|wincmd w|q      - quit</a>
<a name="ln4581">    if (only_one_window() &amp;&amp; (ONE_WINDOW || eap-&gt;addr_count == 0)) {</a>
<a name="ln4582">      getout(0);</a>
<a name="ln4583">    }</a>
<a name="ln4584">    not_exiting();</a>
<a name="ln4585">    // close window; may free buffer</a>
<a name="ln4586">    win_close(wp, !buf_hide(wp-&gt;w_buffer) || eap-&gt;forceit, eap-&gt;forceit);</a>
<a name="ln4587">  }</a>
<a name="ln4588">}</a>
<a name="ln4589"> </a>
<a name="ln4590">/// &quot;:cquit&quot;.</a>
<a name="ln4591">static void ex_cquit(exarg_T *eap)</a>
<a name="ln4592">  FUNC_ATTR_NORETURN</a>
<a name="ln4593">{</a>
<a name="ln4594">  // this does not always pass on the exit code to the Manx compiler. why?</a>
<a name="ln4595">  int status = eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : EXIT_FAILURE;</a>
<a name="ln4596">  ui_call_error_exit(status);</a>
<a name="ln4597">  getout(status);</a>
<a name="ln4598">}</a>
<a name="ln4599"> </a>
<a name="ln4600">/// Do preparations for &quot;qall&quot; and &quot;wqall&quot;.</a>
<a name="ln4601">/// Returns FAIL when quitting should be aborted.</a>
<a name="ln4602">int before_quit_all(exarg_T *eap)</a>
<a name="ln4603">{</a>
<a name="ln4604">  if (cmdwin_type != 0) {</a>
<a name="ln4605">    if (eap-&gt;forceit) {</a>
<a name="ln4606">      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this</a>
<a name="ln4607">    } else {</a>
<a name="ln4608">      cmdwin_result = K_XF2;</a>
<a name="ln4609">    }</a>
<a name="ln4610">    return FAIL;</a>
<a name="ln4611">  }</a>
<a name="ln4612"> </a>
<a name="ln4613">  // Don't quit while editing the command line.</a>
<a name="ln4614">  if (text_locked()) {</a>
<a name="ln4615">    text_locked_msg();</a>
<a name="ln4616">    return FAIL;</a>
<a name="ln4617">  }</a>
<a name="ln4618"> </a>
<a name="ln4619">  if (before_quit_autocmds(curwin, true, eap-&gt;forceit)) {</a>
<a name="ln4620">    return FAIL;</a>
<a name="ln4621">  }</a>
<a name="ln4622"> </a>
<a name="ln4623">  return OK;</a>
<a name="ln4624">}</a>
<a name="ln4625"> </a>
<a name="ln4626">/// &quot;:qall&quot;: try to quit all windows</a>
<a name="ln4627">static void ex_quit_all(exarg_T *eap)</a>
<a name="ln4628">{</a>
<a name="ln4629">  if (before_quit_all(eap) == FAIL) {</a>
<a name="ln4630">    return;</a>
<a name="ln4631">  }</a>
<a name="ln4632">  exiting = true;</a>
<a name="ln4633">  if (eap-&gt;forceit || !check_changed_any(false, false)) {</a>
<a name="ln4634">    getout(0);</a>
<a name="ln4635">  }</a>
<a name="ln4636">  not_exiting();</a>
<a name="ln4637">}</a>
<a name="ln4638"> </a>
<a name="ln4639">/// &quot;:close&quot;: close current window, unless it is the last one</a>
<a name="ln4640">static void ex_close(exarg_T *eap)</a>
<a name="ln4641">{</a>
<a name="ln4642">  win_T *win = NULL;</a>
<a name="ln4643">  int winnr = 0;</a>
<a name="ln4644">  if (cmdwin_type != 0) {</a>
<a name="ln4645">    cmdwin_result = Ctrl_C;</a>
<a name="ln4646">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4647">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln4648">      ex_win_close(eap-&gt;forceit, curwin, NULL);</a>
<a name="ln4649">    } else {</a>
<a name="ln4650">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4651">        winnr++;</a>
<a name="ln4652">        if (winnr == eap-&gt;line2) {</a>
<a name="ln4653">          win = wp;</a>
<a name="ln4654">          break;</a>
<a name="ln4655">        }</a>
<a name="ln4656">      }</a>
<a name="ln4657">      if (win == NULL) {</a>
<a name="ln4658">        win = lastwin;</a>
<a name="ln4659">      }</a>
<a name="ln4660">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4661">    }</a>
<a name="ln4662">  }</a>
<a name="ln4663">}</a>
<a name="ln4664"> </a>
<a name="ln4665">/// &quot;:pclose&quot;: Close any preview window.</a>
<a name="ln4666">static void ex_pclose(exarg_T *eap)</a>
<a name="ln4667">{</a>
<a name="ln4668">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln4669">    if (win-&gt;w_p_pvw) {</a>
<a name="ln4670">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4671">      break;</a>
<a name="ln4672">    }</a>
<a name="ln4673">  }</a>
<a name="ln4674">}</a>
<a name="ln4675"> </a>
<a name="ln4676">/// Close window &quot;win&quot; and take care of handling closing the last window for a</a>
<a name="ln4677">/// modified buffer.</a>
<a name="ln4678">///</a>
<a name="ln4679">/// @param tp  NULL or the tab page &quot;win&quot; is in</a>
<a name="ln4680">void ex_win_close(int forceit, win_T *win, tabpage_T *tp)</a>
<a name="ln4681">{</a>
<a name="ln4682">  // Never close the autocommand window.</a>
<a name="ln4683">  if (is_aucmd_win(win)) {</a>
<a name="ln4684">    emsg(_(e_autocmd_close));</a>
<a name="ln4685">    return;</a>
<a name="ln4686">  }</a>
<a name="ln4687"> </a>
<a name="ln4688">  buf_T *buf = win-&gt;w_buffer;</a>
<a name="ln4689"> </a>
<a name="ln4690">  bool need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln4691">  if (need_hide &amp;&amp; !buf_hide(buf) &amp;&amp; !forceit) {</a>
<a name="ln4692">    if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; p_write) {</a>
<a name="ln4693">      bufref_T bufref;</a>
<a name="ln4694">      set_bufref(&amp;bufref, buf);</a>
<a name="ln4695">      dialog_changed(buf, false);</a>
<a name="ln4696">      if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln4697">        return;</a>
<a name="ln4698">      }</a>
<a name="ln4699">      need_hide = false;</a>
<a name="ln4700">    } else {</a>
<a name="ln4701">      no_write_message();</a>
<a name="ln4702">      return;</a>
<a name="ln4703">    }</a>
<a name="ln4704">  }</a>
<a name="ln4705"> </a>
<a name="ln4706">  // free buffer when not hiding it or when it's a scratch buffer</a>
<a name="ln4707">  if (tp == NULL) {</a>
<a name="ln4708">    win_close(win, !need_hide &amp;&amp; !buf_hide(buf), forceit);</a>
<a name="ln4709">  } else {</a>
<a name="ln4710">    win_close_othertab(win, !need_hide &amp;&amp; !buf_hide(buf), tp);</a>
<a name="ln4711">  }</a>
<a name="ln4712">}</a>
<a name="ln4713"> </a>
<a name="ln4714">/// &quot;:tabclose&quot;: close current tab page, unless it is the last one.</a>
<a name="ln4715">/// &quot;:tabclose N&quot;: close tab page N.</a>
<a name="ln4716">static void ex_tabclose(exarg_T *eap)</a>
<a name="ln4717">{</a>
<a name="ln4718">  if (cmdwin_type != 0) {</a>
<a name="ln4719">    cmdwin_result = K_IGNORE;</a>
<a name="ln4720">    return;</a>
<a name="ln4721">  }</a>
<a name="ln4722"> </a>
<a name="ln4723">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4724">    emsg(_(&quot;E784: Cannot close last tab page&quot;));</a>
<a name="ln4725">    return;</a>
<a name="ln4726">  }</a>
<a name="ln4727"> </a>
<a name="ln4728">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4729">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4730">    return;</a>
<a name="ln4731">  }</a>
<a name="ln4732"> </a>
<a name="ln4733">  tabpage_T *tp = find_tabpage(tab_number);</a>
<a name="ln4734">  if (tp == NULL) {</a>
<a name="ln4735">    beep_flush();</a>
<a name="ln4736">    return;</a>
<a name="ln4737">  }</a>
<a name="ln4738">  if (tp != curtab) {</a>
<a name="ln4739">    tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4740">    return;</a>
<a name="ln4741">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4742">    tabpage_close(eap-&gt;forceit);</a>
<a name="ln4743">  }</a>
<a name="ln4744">}</a>
<a name="ln4745"> </a>
<a name="ln4746">/// &quot;:tabonly&quot;: close all tab pages except the current one</a>
<a name="ln4747">static void ex_tabonly(exarg_T *eap)</a>
<a name="ln4748">{</a>
<a name="ln4749">  if (cmdwin_type != 0) {</a>
<a name="ln4750">    cmdwin_result = K_IGNORE;</a>
<a name="ln4751">    return;</a>
<a name="ln4752">  }</a>
<a name="ln4753"> </a>
<a name="ln4754">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4755">    msg(_(&quot;Already only one tab page&quot;), 0);</a>
<a name="ln4756">    return;</a>
<a name="ln4757">  }</a>
<a name="ln4758"> </a>
<a name="ln4759">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4760">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4761">    return;</a>
<a name="ln4762">  }</a>
<a name="ln4763"> </a>
<a name="ln4764">  goto_tabpage(tab_number);</a>
<a name="ln4765">  // Repeat this up to a 1000 times, because autocommands may</a>
<a name="ln4766">  // mess up the lists.</a>
<a name="ln4767">  for (int done = 0; done &lt; 1000; done++) {</a>
<a name="ln4768">    FOR_ALL_TABS(tp) {</a>
<a name="ln4769">      if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln4770">        tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4771">        // if we failed to close it quit</a>
<a name="ln4772">        if (valid_tabpage(tp)) {</a>
<a name="ln4773">          done = 1000;</a>
<a name="ln4774">        }</a>
<a name="ln4775">        // start over, &quot;tp&quot; is now invalid</a>
<a name="ln4776">        break;</a>
<a name="ln4777">      }</a>
<a name="ln4778">    }</a>
<a name="ln4779">    assert(first_tabpage);</a>
<a name="ln4780">    if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4781">      break;</a>
<a name="ln4782">    }</a>
<a name="ln4783">  }</a>
<a name="ln4784">}</a>
<a name="ln4785"> </a>
<a name="ln4786">/// Close the current tab page.</a>
<a name="ln4787">void tabpage_close(int forceit)</a>
<a name="ln4788">{</a>
<a name="ln4789">  // First close all the windows but the current one.  If that worked then</a>
<a name="ln4790">  // close the last window in this tab, that will close it.</a>
<a name="ln4791">  while (curwin-&gt;w_floating) {</a>
<a name="ln4792">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4793">  }</a>
<a name="ln4794">  if (!ONE_WINDOW) {</a>
<a name="ln4795">    close_others(true, forceit);</a>
<a name="ln4796">  }</a>
<a name="ln4797">  if (ONE_WINDOW) {</a>
<a name="ln4798">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4799">  }</a>
<a name="ln4800">}</a>
<a name="ln4801"> </a>
<a name="ln4802">/// Close tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln4803">/// Note that autocommands may make &quot;tp&quot; invalid.</a>
<a name="ln4804">/// Also takes care of the tab pages line disappearing when closing the</a>
<a name="ln4805">/// last-but-one tab page.</a>
<a name="ln4806">void tabpage_close_other(tabpage_T *tp, int forceit)</a>
<a name="ln4807">{</a>
<a name="ln4808">  int done = 0;</a>
<a name="ln4809">  char prev_idx[NUMBUFLEN];</a>
<a name="ln4810"> </a>
<a name="ln4811">  // Limit to 1000 windows, autocommands may add a window while we close</a>
<a name="ln4812">  // one.  OK, so I'm paranoid...</a>
<a name="ln4813">  while (++done &lt; 1000) {</a>
<a name="ln4814">    snprintf(prev_idx, sizeof(prev_idx), &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln4815">    win_T *wp = tp-&gt;tp_lastwin;</a>
<a name="ln4816">    ex_win_close(forceit, wp, tp);</a>
<a name="ln4817"> </a>
<a name="ln4818">    // Autocommands may delete the tab page under our fingers and we may</a>
<a name="ln4819">    // fail to close a window with a modified buffer.</a>
<a name="ln4820">    if (!valid_tabpage(tp) || tp-&gt;tp_lastwin == wp) {</a>
<a name="ln4821">      break;</a>
<a name="ln4822">    }</a>
<a name="ln4823">  }</a>
<a name="ln4824">}</a>
<a name="ln4825"> </a>
<a name="ln4826">/// &quot;:only&quot;.</a>
<a name="ln4827">static void ex_only(exarg_T *eap)</a>
<a name="ln4828">{</a>
<a name="ln4829">  win_T *wp;</a>
<a name="ln4830"> </a>
<a name="ln4831">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4832">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4833">    for (wp = firstwin; --wnr &gt; 0;) {</a>
<a name="ln4834">      if (wp-&gt;w_next == NULL) {</a>
<a name="ln4835">        break;</a>
<a name="ln4836">      }</a>
<a name="ln4837">      wp = wp-&gt;w_next;</a>
<a name="ln4838">    }</a>
<a name="ln4839">  } else {</a>
<a name="ln4840">    wp = curwin;</a>
<a name="ln4841">  }</a>
<a name="ln4842">  if (wp != curwin) {</a>
<a name="ln4843">    win_goto(wp);</a>
<a name="ln4844">  }</a>
<a name="ln4845">  close_others(true, eap-&gt;forceit);</a>
<a name="ln4846">}</a>
<a name="ln4847"> </a>
<a name="ln4848">static void ex_hide(exarg_T *eap)</a>
<a name="ln4849">{</a>
<a name="ln4850">  // &quot;:hide&quot; or &quot;:hide | cmd&quot;: hide current window</a>
<a name="ln4851">  if (eap-&gt;skip) {</a>
<a name="ln4852">    return;</a>
<a name="ln4853">  }</a>
<a name="ln4854"> </a>
<a name="ln4855">  if (eap-&gt;addr_count == 0) {</a>
<a name="ln4856">    win_close(curwin, false, eap-&gt;forceit);  // don't free buffer</a>
<a name="ln4857">  } else {</a>
<a name="ln4858">    int winnr = 0;</a>
<a name="ln4859">    win_T *win = NULL;</a>
<a name="ln4860"> </a>
<a name="ln4861">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4862">      winnr++;</a>
<a name="ln4863">      if (winnr == eap-&gt;line2) {</a>
<a name="ln4864">        win = wp;</a>
<a name="ln4865">        break;</a>
<a name="ln4866">      }</a>
<a name="ln4867">    }</a>
<a name="ln4868">    if (win == NULL) {</a>
<a name="ln4869">      win = lastwin;</a>
<a name="ln4870">    }</a>
<a name="ln4871">    win_close(win, false, eap-&gt;forceit);</a>
<a name="ln4872">  }</a>
<a name="ln4873">}</a>
<a name="ln4874"> </a>
<a name="ln4875">/// &quot;:stop&quot; and &quot;:suspend&quot;: Suspend Vim.</a>
<a name="ln4876">static void ex_stop(exarg_T *eap)</a>
<a name="ln4877">{</a>
<a name="ln4878">  if (!eap-&gt;forceit) {</a>
<a name="ln4879">    autowrite_all();</a>
<a name="ln4880">  }</a>
<a name="ln4881">  may_trigger_vim_suspend_resume(true);</a>
<a name="ln4882">  ui_call_suspend();</a>
<a name="ln4883">  ui_flush();</a>
<a name="ln4884">}</a>
<a name="ln4885"> </a>
<a name="ln4886">/// &quot;:exit&quot;, &quot;:xit&quot; and &quot;:wq&quot;: Write file and quit the current window.</a>
<a name="ln4887">static void ex_exit(exarg_T *eap)</a>
<a name="ln4888">{</a>
<a name="ln4889">  if (cmdwin_type != 0) {</a>
<a name="ln4890">    cmdwin_result = Ctrl_C;</a>
<a name="ln4891">    return;</a>
<a name="ln4892">  }</a>
<a name="ln4893">  // Don't quit while editing the command line.</a>
<a name="ln4894">  if (text_locked()) {</a>
<a name="ln4895">    text_locked_msg();</a>
<a name="ln4896">    return;</a>
<a name="ln4897">  }</a>
<a name="ln4898"> </a>
<a name="ln4899">  // we plan to exit if there is only one relevant window</a>
<a name="ln4900">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4901">    exiting = true;</a>
<a name="ln4902">  }</a>
<a name="ln4903">  // Write the buffer for &quot;:wq&quot; or when it was changed.</a>
<a name="ln4904">  // Trigger QuitPre and ExitPre.</a>
<a name="ln4905">  // Check if we can exit now, after autocommands have changed things.</a>
<a name="ln4906">  if (((eap-&gt;cmdidx == CMD_wq || curbufIsChanged()) &amp;&amp; do_write(eap) == FAIL)</a>
<a name="ln4907">      || before_quit_autocmds(curwin, false, eap-&gt;forceit)</a>
<a name="ln4908">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4909">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, false))) {</a>
<a name="ln4910">    not_exiting();</a>
<a name="ln4911">  } else {</a>
<a name="ln4912">    if (only_one_window()) {</a>
<a name="ln4913">      // quit last window, exit Vim</a>
<a name="ln4914">      getout(0);</a>
<a name="ln4915">    }</a>
<a name="ln4916">    not_exiting();</a>
<a name="ln4917">    // Quit current window, may free the buffer.</a>
<a name="ln4918">    win_close(curwin, !buf_hide(curwin-&gt;w_buffer), eap-&gt;forceit);</a>
<a name="ln4919">  }</a>
<a name="ln4920">}</a>
<a name="ln4921"> </a>
<a name="ln4922">/// &quot;:print&quot;, &quot;:list&quot;, &quot;:number&quot;.</a>
<a name="ln4923">static void ex_print(exarg_T *eap)</a>
<a name="ln4924">{</a>
<a name="ln4925">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln4926">    emsg(_(e_empty_buffer));</a>
<a name="ln4927">  } else {</a>
<a name="ln4928">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln4929">      print_line(eap-&gt;line1,</a>
<a name="ln4930">                 (eap-&gt;cmdidx == CMD_number || eap-&gt;cmdidx == CMD_pound</a>
<a name="ln4931">                  || (eap-&gt;flags &amp; EXFLAG_NR)),</a>
<a name="ln4932">                 eap-&gt;cmdidx == CMD_list || (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln4933">      if (++eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln4934">        break;</a>
<a name="ln4935">      }</a>
<a name="ln4936">    }</a>
<a name="ln4937">    setpcmark();</a>
<a name="ln4938">    // put cursor at last line</a>
<a name="ln4939">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln4940">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln4941">  }</a>
<a name="ln4942"> </a>
<a name="ln4943">  ex_no_reprint = true;</a>
<a name="ln4944">}</a>
<a name="ln4945"> </a>
<a name="ln4946">static void ex_goto(exarg_T *eap)</a>
<a name="ln4947">{</a>
<a name="ln4948">  goto_byte(eap-&gt;line2);</a>
<a name="ln4949">}</a>
<a name="ln4950"> </a>
<a name="ln4951">/// &quot;:preserve&quot;.</a>
<a name="ln4952">static void ex_preserve(exarg_T *eap)</a>
<a name="ln4953">{</a>
<a name="ln4954">  ml_preserve(curbuf, true, true);</a>
<a name="ln4955">}</a>
<a name="ln4956"> </a>
<a name="ln4957">/// &quot;:recover&quot;.</a>
<a name="ln4958">static void ex_recover(exarg_T *eap)</a>
<a name="ln4959">{</a>
<a name="ln4960">  // Set recoverymode right away to avoid the ATTENTION prompt.</a>
<a name="ln4961">  recoverymode = true;</a>
<a name="ln4962">  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4963">                     | CCGD_MULTWIN</a>
<a name="ln4964">                     | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4965">                     | CCGD_EXCMD)</a>
<a name="ln4966"> </a>
<a name="ln4967">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln4968">          || setfname(curbuf, eap-&gt;arg, NULL, true) == OK)) {</a>
<a name="ln4969">    ml_recover(true);</a>
<a name="ln4970">  }</a>
<a name="ln4971">  recoverymode = false;</a>
<a name="ln4972">}</a>
<a name="ln4973"> </a>
<a name="ln4974">/// Command modifier used in a wrong way.</a>
<a name="ln4975">static void ex_wrongmodifier(exarg_T *eap)</a>
<a name="ln4976">{</a>
<a name="ln4977">  eap-&gt;errmsg = _(e_invcmd);</a>
<a name="ln4978">}</a>
<a name="ln4979"> </a>
<a name="ln4980">/// :sview [+command] file       split window with new file, read-only</a>
<a name="ln4981">/// :split [[+command] file]     split window with current or new file</a>
<a name="ln4982">/// :vsplit [[+command] file]    split window vertically with current or new file</a>
<a name="ln4983">/// :new [[+command] file]       split window with no or new file</a>
<a name="ln4984">/// :vnew [[+command] file]      split vertically window with no or new file</a>
<a name="ln4985">/// :sfind [+command] file       split window with file in 'path'</a>
<a name="ln4986">///</a>
<a name="ln4987">/// :tabedit                     open new Tab page with empty window</a>
<a name="ln4988">/// :tabedit [+command] file     open new Tab page and edit &quot;file&quot;</a>
<a name="ln4989">/// :tabnew [[+command] file]    just like :tabedit</a>
<a name="ln4990">/// :tabfind [+command] file     open new Tab page and find &quot;file&quot;</a>
<a name="ln4991">void ex_splitview(exarg_T *eap)</a>
<a name="ln4992">{</a>
<a name="ln4993">  win_T *old_curwin = curwin;</a>
<a name="ln4994">  char *fname = NULL;</a>
<a name="ln4995">  const bool use_tab = eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln4996">                       || eap-&gt;cmdidx == CMD_tabfind</a>
<a name="ln4997">                       || eap-&gt;cmdidx == CMD_tabnew;</a>
<a name="ln4998"> </a>
<a name="ln4999">  // A &quot;:split&quot; in the quickfix window works like &quot;:new&quot;.  Don't want two</a>
<a name="ln5000">  // quickfix windows.  But it's OK when doing &quot;:tab split&quot;.</a>
<a name="ln5001">  if (bt_quickfix(curbuf) &amp;&amp; cmdmod.cmod_tab == 0) {</a>
<a name="ln5002">    if (eap-&gt;cmdidx == CMD_split) {</a>
<a name="ln5003">      eap-&gt;cmdidx = CMD_new;</a>
<a name="ln5004">    }</a>
<a name="ln5005">    if (eap-&gt;cmdidx == CMD_vsplit) {</a>
<a name="ln5006">      eap-&gt;cmdidx = CMD_vnew;</a>
<a name="ln5007">    }</a>
<a name="ln5008">  }</a>
<a name="ln5009"> </a>
<a name="ln5010">  if (eap-&gt;cmdidx == CMD_sfind || eap-&gt;cmdidx == CMD_tabfind) {</a>
<a name="ln5011">    char *file_to_find = NULL;</a>
<a name="ln5012">    char *search_ctx = NULL;</a>
<a name="ln5013">    fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5014">                              FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5015">                              &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5016">    xfree(file_to_find);</a>
<a name="ln5017">    vim_findfile_cleanup(search_ctx);</a>
<a name="ln5018">    if (fname == NULL) {</a>
<a name="ln5019">      goto theend;</a>
<a name="ln5020">    }</a>
<a name="ln5021">    eap-&gt;arg = fname;</a>
<a name="ln5022">  }</a>
<a name="ln5023"> </a>
<a name="ln5024">  // Either open new tab page or split the window.</a>
<a name="ln5025">  if (use_tab) {</a>
<a name="ln5026">    if (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab : eap-&gt;addr_count == 0</a>
<a name="ln5027">                        ? 0 : (int)eap-&gt;line2 + 1, eap-&gt;arg) != FAIL) {</a>
<a name="ln5028">      do_exedit(eap, old_curwin);</a>
<a name="ln5029">      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);</a>
<a name="ln5030"> </a>
<a name="ln5031">      // set the alternate buffer for the window we came from</a>
<a name="ln5032">      if (curwin != old_curwin</a>
<a name="ln5033">          &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5034">          &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5035">          &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5036">        old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5037">      }</a>
<a name="ln5038">    }</a>
<a name="ln5039">  } else if (win_split(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 0,</a>
<a name="ln5040">                       *eap-&gt;cmd == 'v' ? WSP_VERT : 0) != FAIL) {</a>
<a name="ln5041">    // Reset 'scrollbind' when editing another file, but keep it when</a>
<a name="ln5042">    // doing &quot;:split&quot; without arguments.</a>
<a name="ln5043">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln5044">      RESET_BINDING(curwin);</a>
<a name="ln5045">    } else {</a>
<a name="ln5046">      do_check_scrollbind(false);</a>
<a name="ln5047">    }</a>
<a name="ln5048">    do_exedit(eap, old_curwin);</a>
<a name="ln5049">  }</a>
<a name="ln5050"> </a>
<a name="ln5051">theend:</a>
<a name="ln5052">  xfree(fname);</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">/// Open a new tab page.</a>
<a name="ln5056">void tabpage_new(void)</a>
<a name="ln5057">{</a>
<a name="ln5058">  exarg_T ea = {</a>
<a name="ln5059">    .cmdidx = CMD_tabnew,</a>
<a name="ln5060">    .cmd = &quot;tabn&quot;,</a>
<a name="ln5061">    .arg = &quot;&quot;,</a>
<a name="ln5062">  };</a>
<a name="ln5063">  ex_splitview(&amp;ea);</a>
<a name="ln5064">}</a>
<a name="ln5065"> </a>
<a name="ln5066">/// :tabnext command</a>
<a name="ln5067">static void ex_tabnext(exarg_T *eap)</a>
<a name="ln5068">{</a>
<a name="ln5069">  int tab_number;</a>
<a name="ln5070"> </a>
<a name="ln5071">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5072">  case CMD_tabfirst:</a>
<a name="ln5073">  case CMD_tabrewind:</a>
<a name="ln5074">    goto_tabpage(1);</a>
<a name="ln5075">    break;</a>
<a name="ln5076">  case CMD_tablast:</a>
<a name="ln5077">    goto_tabpage(9999);</a>
<a name="ln5078">    break;</a>
<a name="ln5079">  case CMD_tabprevious:</a>
<a name="ln5080">  case CMD_tabNext:</a>
<a name="ln5081">    if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln5082">      char *p = eap-&gt;arg;</a>
<a name="ln5083">      char *p_save = p;</a>
<a name="ln5084">      tab_number = (int)getdigits(&amp;p, false, 0);</a>
<a name="ln5085">      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL</a>
<a name="ln5086">          || tab_number == 0) {</a>
<a name="ln5087">        // No numbers as argument.</a>
<a name="ln5088">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln5089">        return;</a>
<a name="ln5090">      }</a>
<a name="ln5091">    } else {</a>
<a name="ln5092">      if (eap-&gt;addr_count == 0) {</a>
<a name="ln5093">        tab_number = 1;</a>
<a name="ln5094">      } else {</a>
<a name="ln5095">        tab_number = (int)eap-&gt;line2;</a>
<a name="ln5096">        if (tab_number &lt; 1) {</a>
<a name="ln5097">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln5098">          return;</a>
<a name="ln5099">        }</a>
<a name="ln5100">      }</a>
<a name="ln5101">    }</a>
<a name="ln5102">    goto_tabpage(-tab_number);</a>
<a name="ln5103">    break;</a>
<a name="ln5104">  default:       // CMD_tabnext</a>
<a name="ln5105">    tab_number = get_tabpage_arg(eap);</a>
<a name="ln5106">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5107">      goto_tabpage(tab_number);</a>
<a name="ln5108">    }</a>
<a name="ln5109">    break;</a>
<a name="ln5110">  }</a>
<a name="ln5111">}</a>
<a name="ln5112"> </a>
<a name="ln5113">/// :tabmove command</a>
<a name="ln5114">static void ex_tabmove(exarg_T *eap)</a>
<a name="ln5115">{</a>
<a name="ln5116">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln5117">  if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5118">    tabpage_move(tab_number);</a>
<a name="ln5119">  }</a>
<a name="ln5120">}</a>
<a name="ln5121"> </a>
<a name="ln5122">/// :tabs command: List tabs and their contents.</a>
<a name="ln5123">static void ex_tabs(exarg_T *eap)</a>
<a name="ln5124">{</a>
<a name="ln5125">  int tabcount = 1;</a>
<a name="ln5126"> </a>
<a name="ln5127">  msg_start();</a>
<a name="ln5128">  msg_scroll = true;</a>
<a name="ln5129"> </a>
<a name="ln5130">  win_T *lastused_win = valid_tabpage(lastused_tabpage)</a>
<a name="ln5131">    ? lastused_tabpage-&gt;tp_curwin</a>
<a name="ln5132">    : NULL;</a>
<a name="ln5133"> </a>
<a name="ln5134">  FOR_ALL_TABS(tp) {</a>
<a name="ln5135">    if (got_int) {</a>
<a name="ln5136">      break;</a>
<a name="ln5137">    }</a>
<a name="ln5138"> </a>
<a name="ln5139">    msg_putchar('\n');</a>
<a name="ln5140">    vim_snprintf(IObuff, IOSIZE, _(&quot;Tab page %d&quot;), tabcount++);</a>
<a name="ln5141">    msg_outtrans(IObuff, HL_ATTR(HLF_T));</a>
<a name="ln5142">    os_breakcheck();</a>
<a name="ln5143"> </a>
<a name="ln5144">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln5145">      if (got_int) {</a>
<a name="ln5146">        break;</a>
<a name="ln5147">      }</a>
<a name="ln5148"> </a>
<a name="ln5149">      msg_putchar('\n');</a>
<a name="ln5150">      msg_putchar(wp == curwin ? '&gt;' : wp == lastused_win ? '#' : ' ');</a>
<a name="ln5151">      msg_putchar(' ');</a>
<a name="ln5152">      msg_putchar(bufIsChanged(wp-&gt;w_buffer) ? '+' : ' ');</a>
<a name="ln5153">      msg_putchar(' ');</a>
<a name="ln5154">      if (buf_spname(wp-&gt;w_buffer) != NULL) {</a>
<a name="ln5155">        xstrlcpy(IObuff, buf_spname(wp-&gt;w_buffer), IOSIZE);</a>
<a name="ln5156">      } else {</a>
<a name="ln5157">        home_replace(wp-&gt;w_buffer, wp-&gt;w_buffer-&gt;b_fname, IObuff, IOSIZE, true);</a>
<a name="ln5158">      }</a>
<a name="ln5159">      msg_outtrans(IObuff, 0);</a>
<a name="ln5160">      os_breakcheck();</a>
<a name="ln5161">    }</a>
<a name="ln5162">  }</a>
<a name="ln5163">}</a>
<a name="ln5164"> </a>
<a name="ln5165">/// &quot;:mode&quot;:</a>
<a name="ln5166">/// If no argument given, get the screen size and redraw.</a>
<a name="ln5167">static void ex_mode(exarg_T *eap)</a>
<a name="ln5168">{</a>
<a name="ln5169">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5170">    must_redraw = UPD_CLEAR;</a>
<a name="ln5171">    ex_redraw(eap);</a>
<a name="ln5172">  } else {</a>
<a name="ln5173">    emsg(_(e_screenmode));</a>
<a name="ln5174">  }</a>
<a name="ln5175">}</a>
<a name="ln5176"> </a>
<a name="ln5177">/// &quot;:resize&quot;.</a>
<a name="ln5178">/// set, increment or decrement current window height</a>
<a name="ln5179">static void ex_resize(exarg_T *eap)</a>
<a name="ln5180">{</a>
<a name="ln5181">  win_T *wp = curwin;</a>
<a name="ln5182"> </a>
<a name="ln5183">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5184">    int n = (int)eap-&gt;line2;</a>
<a name="ln5185">    for (wp = firstwin; wp-&gt;w_next != NULL &amp;&amp; --n &gt; 0; wp = wp-&gt;w_next) {}</a>
<a name="ln5186">  }</a>
<a name="ln5187"> </a>
<a name="ln5188">  int n = (int)atol(eap-&gt;arg);</a>
<a name="ln5189">  if (cmdmod.cmod_split &amp; WSP_VERT) {</a>
<a name="ln5190">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5191">      n += wp-&gt;w_width;</a>
<a name="ln5192">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very wide</a>
<a name="ln5193">      n = Columns;</a>
<a name="ln5194">    }</a>
<a name="ln5195">    win_setwidth_win(n, wp);</a>
<a name="ln5196">  } else {</a>
<a name="ln5197">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5198">      n += wp-&gt;w_height;</a>
<a name="ln5199">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very high</a>
<a name="ln5200">      n = Rows - 1;</a>
<a name="ln5201">    }</a>
<a name="ln5202">    win_setheight_win(n, wp);</a>
<a name="ln5203">  }</a>
<a name="ln5204">}</a>
<a name="ln5205"> </a>
<a name="ln5206">/// &quot;:find [+command] &lt;file&gt;&quot; command.</a>
<a name="ln5207">static void ex_find(exarg_T *eap)</a>
<a name="ln5208">{</a>
<a name="ln5209">  char *file_to_find = NULL;</a>
<a name="ln5210">  char *search_ctx = NULL;</a>
<a name="ln5211">  char *fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5212">                                  FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5213">                                  &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5214">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5215">    // Repeat finding the file &quot;count&quot; times.  This matters when it appears</a>
<a name="ln5216">    // several times in the path.</a>
<a name="ln5217">    linenr_T count = eap-&gt;line2;</a>
<a name="ln5218">    while (fname != NULL &amp;&amp; --count &gt; 0) {</a>
<a name="ln5219">      xfree(fname);</a>
<a name="ln5220">      fname = find_file_in_path(NULL, 0, FNAME_MESS, false, curbuf-&gt;b_ffname,</a>
<a name="ln5221">                                &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5222">    }</a>
<a name="ln5223">  }</a>
<a name="ln5224">  xfree(file_to_find);</a>
<a name="ln5225">  vim_findfile_cleanup(search_ctx);</a>
<a name="ln5226"> </a>
<a name="ln5227">  if (fname == NULL) {</a>
<a name="ln5228">    return;</a>
<a name="ln5229">  }</a>
<a name="ln5230"> </a>
<a name="ln5231">  eap-&gt;arg = fname;</a>
<a name="ln5232">  do_exedit(eap, NULL);</a>
<a name="ln5233">  xfree(fname);</a>
<a name="ln5234">}</a>
<a name="ln5235"> </a>
<a name="ln5236">/// &quot;:edit&quot;, &quot;:badd&quot;, &quot;:balt&quot;, &quot;:visual&quot;.</a>
<a name="ln5237">static void ex_edit(exarg_T *eap)</a>
<a name="ln5238">{</a>
<a name="ln5239">  do_exedit(eap, NULL);</a>
<a name="ln5240">}</a>
<a name="ln5241"> </a>
<a name="ln5242">/// &quot;:edit &lt;file&gt;&quot; command and alike.</a>
<a name="ln5243">///</a>
<a name="ln5244">/// @param old_curwin  curwin before doing a split or NULL</a>
<a name="ln5245">void do_exedit(exarg_T *eap, win_T *old_curwin)</a>
<a name="ln5246">{</a>
<a name="ln5247">  int n;</a>
<a name="ln5248"> </a>
<a name="ln5249">  // &quot;:vi&quot; command ends Ex mode.</a>
<a name="ln5250">  if (exmode_active &amp;&amp; (eap-&gt;cmdidx == CMD_visual</a>
<a name="ln5251">                        || eap-&gt;cmdidx == CMD_view)) {</a>
<a name="ln5252">    exmode_active = false;</a>
<a name="ln5253">    ex_pressedreturn = false;</a>
<a name="ln5254">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln5255">      // Special case:  &quot;:global/pat/visual\NLvi-commands&quot;</a>
<a name="ln5256">      if (global_busy) {</a>
<a name="ln5257">        if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln5258">          stuffReadbuff(eap-&gt;nextcmd);</a>
<a name="ln5259">          eap-&gt;nextcmd = NULL;</a>
<a name="ln5260">        }</a>
<a name="ln5261"> </a>
<a name="ln5262">        const int save_rd = RedrawingDisabled;</a>
<a name="ln5263">        RedrawingDisabled = 0;</a>
<a name="ln5264">        const int save_nwr = no_wait_return;</a>
<a name="ln5265">        no_wait_return = 0;</a>
<a name="ln5266">        need_wait_return = false;</a>
<a name="ln5267">        const int save_ms = msg_scroll;</a>
<a name="ln5268">        msg_scroll = 0;</a>
<a name="ln5269">        redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln5270">        pending_exmode_active = true;</a>
<a name="ln5271"> </a>
<a name="ln5272">        normal_enter(false, true);</a>
<a name="ln5273"> </a>
<a name="ln5274">        pending_exmode_active = false;</a>
<a name="ln5275">        RedrawingDisabled = save_rd;</a>
<a name="ln5276">        no_wait_return = save_nwr;</a>
<a name="ln5277">        msg_scroll = save_ms;</a>
<a name="ln5278">      }</a>
<a name="ln5279">      return;</a>
<a name="ln5280">    }</a>
<a name="ln5281">  }</a>
<a name="ln5282"> </a>
<a name="ln5283">  if ((eap-&gt;cmdidx == CMD_new</a>
<a name="ln5284">       || eap-&gt;cmdidx == CMD_tabnew</a>
<a name="ln5285">       || eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln5286">       || eap-&gt;cmdidx == CMD_vnew) &amp;&amp; *eap-&gt;arg == NUL) {</a>
<a name="ln5287">    // &quot;:new&quot; or &quot;:tabnew&quot; without argument: edit a new empty buffer</a>
<a name="ln5288">    setpcmark();</a>
<a name="ln5289">    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,</a>
<a name="ln5290">                  ECMD_HIDE + (eap-&gt;forceit ? ECMD_FORCEIT : 0),</a>
<a name="ln5291">                  old_curwin == NULL ? curwin : NULL);</a>
<a name="ln5292">  } else if ((eap-&gt;cmdidx != CMD_split &amp;&amp; eap-&gt;cmdidx != CMD_vsplit)</a>
<a name="ln5293">             || *eap-&gt;arg != NUL) {</a>
<a name="ln5294">    // Can't edit another file when &quot;textlock&quot; or &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln5295">    // Only &quot;:edit&quot; or &quot;:script&quot; can bring us here, others are stopped earlier.</a>
<a name="ln5296">    if (*eap-&gt;arg != NUL &amp;&amp; text_or_buf_locked()) {</a>
<a name="ln5297">      return;</a>
<a name="ln5298">    }</a>
<a name="ln5299">    n = readonlymode;</a>
<a name="ln5300">    if (eap-&gt;cmdidx == CMD_view || eap-&gt;cmdidx == CMD_sview) {</a>
<a name="ln5301">      readonlymode = true;</a>
<a name="ln5302">    } else if (eap-&gt;cmdidx == CMD_enew) {</a>
<a name="ln5303">      readonlymode = false;  // 'readonly' doesn't make sense</a>
<a name="ln5304">                             // in an empty buffer</a>
<a name="ln5305">    }</a>
<a name="ln5306">    if (eap-&gt;cmdidx != CMD_balt &amp;&amp; eap-&gt;cmdidx != CMD_badd) {</a>
<a name="ln5307">      setpcmark();</a>
<a name="ln5308">    }</a>
<a name="ln5309">    if (do_ecmd(0, eap-&gt;cmdidx == CMD_enew ? NULL : eap-&gt;arg,</a>
<a name="ln5310">                NULL, eap, eap-&gt;do_ecmd_lnum,</a>
<a name="ln5311">                (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln5312">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0)</a>
<a name="ln5313">                // After a split we can use an existing buffer.</a>
<a name="ln5314">                + (old_curwin != NULL ? ECMD_OLDBUF : 0)</a>
<a name="ln5315">                + (eap-&gt;cmdidx == CMD_badd ? ECMD_ADDBUF : 0)</a>
<a name="ln5316">                + (eap-&gt;cmdidx == CMD_balt ? ECMD_ALTBUF : 0),</a>
<a name="ln5317">                old_curwin == NULL ? curwin : NULL) == FAIL) {</a>
<a name="ln5318">      // Editing the file failed.  If the window was split, close it.</a>
<a name="ln5319">      if (old_curwin != NULL) {</a>
<a name="ln5320">        bool need_hide = (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln5321">        if (!need_hide || buf_hide(curbuf)) {</a>
<a name="ln5322">          cleanup_T cs;</a>
<a name="ln5323"> </a>
<a name="ln5324">          // Reset the error/interrupt/exception state here so that</a>
<a name="ln5325">          // aborting() returns false when closing a window.</a>
<a name="ln5326">          enter_cleanup(&amp;cs);</a>
<a name="ln5327">          win_close(curwin, !need_hide &amp;&amp; !buf_hide(curbuf), false);</a>
<a name="ln5328"> </a>
<a name="ln5329">          // Restore the error/interrupt/exception state if not</a>
<a name="ln5330">          // discarded by a new aborting error, interrupt, or</a>
<a name="ln5331">          // uncaught exception.</a>
<a name="ln5332">          leave_cleanup(&amp;cs);</a>
<a name="ln5333">        }</a>
<a name="ln5334">      }</a>
<a name="ln5335">    } else if (readonlymode &amp;&amp; curbuf-&gt;b_nwindows == 1) {</a>
<a name="ln5336">      // When editing an already visited buffer, 'readonly' won't be set</a>
<a name="ln5337">      // but the previous value is kept.  With &quot;:view&quot; and &quot;:sview&quot; we</a>
<a name="ln5338">      // want the  file to be readonly, except when another window is</a>
<a name="ln5339">      // editing the same buffer.</a>
<a name="ln5340">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln5341">    }</a>
<a name="ln5342">    readonlymode = n;</a>
<a name="ln5343">  } else {</a>
<a name="ln5344">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln5345">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln5346">    }</a>
<a name="ln5347">    n = curwin-&gt;w_arg_idx_invalid;</a>
<a name="ln5348">    check_arg_idx(curwin);</a>
<a name="ln5349">    if (n != curwin-&gt;w_arg_idx_invalid) {</a>
<a name="ln5350">      maketitle();</a>
<a name="ln5351">    }</a>
<a name="ln5352">  }</a>
<a name="ln5353"> </a>
<a name="ln5354">  // if &quot;:split file&quot; worked, set alternate file name in old window to new</a>
<a name="ln5355">  // file</a>
<a name="ln5356">  if (old_curwin != NULL</a>
<a name="ln5357">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln5358">      &amp;&amp; curwin != old_curwin</a>
<a name="ln5359">      &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5360">      &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5361">      &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5362">    old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5363">  }</a>
<a name="ln5364"> </a>
<a name="ln5365">  ex_no_reprint = true;</a>
<a name="ln5366">}</a>
<a name="ln5367"> </a>
<a name="ln5368">/// &quot;:gui&quot; and &quot;:gvim&quot; when there is no GUI.</a>
<a name="ln5369">static void ex_nogui(exarg_T *eap)</a>
<a name="ln5370">{</a>
<a name="ln5371">  eap-&gt;errmsg = _(&quot;E25: Nvim does not have a built-in GUI&quot;);</a>
<a name="ln5372">}</a>
<a name="ln5373"> </a>
<a name="ln5374">static void ex_popup(exarg_T *eap)</a>
<a name="ln5375">{</a>
<a name="ln5376">  pum_make_popup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln5377">}</a>
<a name="ln5378"> </a>
<a name="ln5379">static void ex_swapname(exarg_T *eap)</a>
<a name="ln5380">{</a>
<a name="ln5381">  if (curbuf-&gt;b_ml.ml_mfp == NULL || curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln5382">    msg(_(&quot;No swap file&quot;), 0);</a>
<a name="ln5383">  } else {</a>
<a name="ln5384">    msg(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname, 0);</a>
<a name="ln5385">  }</a>
<a name="ln5386">}</a>
<a name="ln5387"> </a>
<a name="ln5388">/// &quot;:syncbind&quot; forces all 'scrollbind' windows to have the same relative</a>
<a name="ln5389">/// offset.</a>
<a name="ln5390">/// (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln5391">static void ex_syncbind(exarg_T *eap)</a>
<a name="ln5392">{</a>
<a name="ln5393">  win_T *save_curwin = curwin;</a>
<a name="ln5394">  buf_T *save_curbuf = curbuf;</a>
<a name="ln5395">  linenr_T topline;</a>
<a name="ln5396">  int y;</a>
<a name="ln5397">  linenr_T old_linenr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln5398"> </a>
<a name="ln5399">  setpcmark();</a>
<a name="ln5400"> </a>
<a name="ln5401">  // determine max topline</a>
<a name="ln5402">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5403">    topline = curwin-&gt;w_topline;</a>
<a name="ln5404">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5405">      if (wp-&gt;w_p_scb &amp;&amp; wp-&gt;w_buffer) {</a>
<a name="ln5406">        y = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - get_scrolloff_value(curwin);</a>
<a name="ln5407">        if (topline &gt; y) {</a>
<a name="ln5408">          topline = y;</a>
<a name="ln5409">        }</a>
<a name="ln5410">      }</a>
<a name="ln5411">    }</a>
<a name="ln5412">    if (topline &lt; 1) {</a>
<a name="ln5413">      topline = 1;</a>
<a name="ln5414">    }</a>
<a name="ln5415">  } else {</a>
<a name="ln5416">    topline = 1;</a>
<a name="ln5417">  }</a>
<a name="ln5418"> </a>
<a name="ln5419">  // Set all scrollbind windows to the same topline.</a>
<a name="ln5420">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5421">    curwin = wp;</a>
<a name="ln5422">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln5423">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln5424">      y = topline - curwin-&gt;w_topline;</a>
<a name="ln5425">      if (y &gt; 0) {</a>
<a name="ln5426">        scrollup(y, true);</a>
<a name="ln5427">      } else {</a>
<a name="ln5428">        scrolldown(-y, true);</a>
<a name="ln5429">      }</a>
<a name="ln5430">      curwin-&gt;w_scbind_pos = topline;</a>
<a name="ln5431">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln5432">      cursor_correct();</a>
<a name="ln5433">      curwin-&gt;w_redr_status = true;</a>
<a name="ln5434">    }</a>
<a name="ln5435">  }</a>
<a name="ln5436">  curwin = save_curwin;</a>
<a name="ln5437">  curbuf = save_curbuf;</a>
<a name="ln5438">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5439">    did_syncbind = true;</a>
<a name="ln5440">    checkpcmark();</a>
<a name="ln5441">    if (old_linenr != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5442">      char ctrl_o[2];</a>
<a name="ln5443"> </a>
<a name="ln5444">      ctrl_o[0] = Ctrl_O;</a>
<a name="ln5445">      ctrl_o[1] = 0;</a>
<a name="ln5446">      ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);</a>
<a name="ln5447">    }</a>
<a name="ln5448">  }</a>
<a name="ln5449">}</a>
<a name="ln5450"> </a>
<a name="ln5451">static void ex_read(exarg_T *eap)</a>
<a name="ln5452">{</a>
<a name="ln5453">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln5454"> </a>
<a name="ln5455">  if (eap-&gt;usefilter) {  // :r!cmd</a>
<a name="ln5456">    do_bang(1, eap, false, false, true);</a>
<a name="ln5457">    return;</a>
<a name="ln5458">  }</a>
<a name="ln5459"> </a>
<a name="ln5460">  if (u_save(eap-&gt;line2, (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln5461">    return;</a>
<a name="ln5462">  }</a>
<a name="ln5463"> </a>
<a name="ln5464">  int i;</a>
<a name="ln5465">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5466">    if (check_fname() == FAIL) {       // check for no file name</a>
<a name="ln5467">      return;</a>
<a name="ln5468">    }</a>
<a name="ln5469">    i = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln5470">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5471">  } else {</a>
<a name="ln5472">    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL) {</a>
<a name="ln5473">      (void)setaltfname(eap-&gt;arg, eap-&gt;arg, (linenr_T)1);</a>
<a name="ln5474">    }</a>
<a name="ln5475">    i = readfile(eap-&gt;arg, NULL,</a>
<a name="ln5476">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5477">  }</a>
<a name="ln5478">  if (i != OK) {</a>
<a name="ln5479">    if (!aborting()) {</a>
<a name="ln5480">      semsg(_(e_notopen), eap-&gt;arg);</a>
<a name="ln5481">    }</a>
<a name="ln5482">  } else {</a>
<a name="ln5483">    if (empty &amp;&amp; exmode_active) {</a>
<a name="ln5484">      // Delete the empty line that remains.  Historically ex does</a>
<a name="ln5485">      // this but vi doesn't.</a>
<a name="ln5486">      linenr_T lnum;</a>
<a name="ln5487">      if (eap-&gt;line2 == 0) {</a>
<a name="ln5488">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5489">      } else {</a>
<a name="ln5490">        lnum = 1;</a>
<a name="ln5491">      }</a>
<a name="ln5492">      if (*ml_get(lnum) == NUL &amp;&amp; u_savedel(lnum, 1L) == OK) {</a>
<a name="ln5493">        ml_delete(lnum, false);</a>
<a name="ln5494">        if (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln5495">            &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= lnum) {</a>
<a name="ln5496">          curwin-&gt;w_cursor.lnum--;</a>
<a name="ln5497">        }</a>
<a name="ln5498">        deleted_lines_mark(lnum, 1L);</a>
<a name="ln5499">      }</a>
<a name="ln5500">    }</a>
<a name="ln5501">    redraw_curbuf_later(UPD_VALID);</a>
<a name="ln5502">  }</a>
<a name="ln5503">}</a>
<a name="ln5504"> </a>
<a name="ln5505">static char *prev_dir = NULL;</a>
<a name="ln5506"> </a>
<a name="ln5507">#if defined(EXITFREE)</a>
<a name="ln5508">void free_cd_dir(void)</a>
<a name="ln5509">{</a>
<a name="ln5510">  XFREE_CLEAR(prev_dir);</a>
<a name="ln5511">  XFREE_CLEAR(globaldir);</a>
<a name="ln5512">}</a>
<a name="ln5513"> </a>
<a name="ln5514">#endif</a>
<a name="ln5515"> </a>
<a name="ln5516">/// Get the previous directory for the given chdir scope.</a>
<a name="ln5517">static char *get_prevdir(CdScope scope)</a>
<a name="ln5518">{</a>
<a name="ln5519">  switch (scope) {</a>
<a name="ln5520">  case kCdScopeTabpage:</a>
<a name="ln5521">    return curtab-&gt;tp_prevdir;</a>
<a name="ln5522">    break;</a>
<a name="ln5523">  case kCdScopeWindow:</a>
<a name="ln5524">    return curwin-&gt;w_prevdir;</a>
<a name="ln5525">    break;</a>
<a name="ln5526">  default:</a>
<a name="ln5527">    return prev_dir;</a>
<a name="ln5528">  }</a>
<a name="ln5529">}</a>
<a name="ln5530"> </a>
<a name="ln5531">/// Deal with the side effects of changing the current directory.</a>
<a name="ln5532">///</a>
<a name="ln5533">/// @param scope  Scope of the function call (global, tab or window).</a>
<a name="ln5534">static void post_chdir(CdScope scope, bool trigger_dirchanged)</a>
<a name="ln5535">{</a>
<a name="ln5536">  // Always overwrite the window-local CWD.</a>
<a name="ln5537">  XFREE_CLEAR(curwin-&gt;w_localdir);</a>
<a name="ln5538"> </a>
<a name="ln5539">  // Overwrite the tab-local CWD for :cd, :tcd.</a>
<a name="ln5540">  if (scope &gt;= kCdScopeTabpage) {</a>
<a name="ln5541">    XFREE_CLEAR(curtab-&gt;tp_localdir);</a>
<a name="ln5542">  }</a>
<a name="ln5543"> </a>
<a name="ln5544">  if (scope &lt; kCdScopeGlobal) {</a>
<a name="ln5545">    char *pdir = get_prevdir(scope);</a>
<a name="ln5546">    // If still in global directory, set CWD as the global directory.</a>
<a name="ln5547">    if (globaldir == NULL &amp;&amp; pdir != NULL) {</a>
<a name="ln5548">      globaldir = xstrdup(pdir);</a>
<a name="ln5549">    }</a>
<a name="ln5550">  }</a>
<a name="ln5551"> </a>
<a name="ln5552">  char cwd[MAXPATHL];</a>
<a name="ln5553">  if (os_dirname(cwd, MAXPATHL) != OK) {</a>
<a name="ln5554">    return;</a>
<a name="ln5555">  }</a>
<a name="ln5556">  switch (scope) {</a>
<a name="ln5557">  case kCdScopeGlobal:</a>
<a name="ln5558">    // We are now in the global directory, no need to remember its name.</a>
<a name="ln5559">    XFREE_CLEAR(globaldir);</a>
<a name="ln5560">    break;</a>
<a name="ln5561">  case kCdScopeTabpage:</a>
<a name="ln5562">    curtab-&gt;tp_localdir = xstrdup(cwd);</a>
<a name="ln5563">    break;</a>
<a name="ln5564">  case kCdScopeWindow:</a>
<a name="ln5565">    curwin-&gt;w_localdir = xstrdup(cwd);</a>
<a name="ln5566">    break;</a>
<a name="ln5567">  case kCdScopeInvalid:</a>
<a name="ln5568">    abort();</a>
<a name="ln5569">  }</a>
<a name="ln5570"> </a>
<a name="ln5571">  last_chdir_reason = NULL;</a>
<a name="ln5572">  shorten_fnames(true);</a>
<a name="ln5573"> </a>
<a name="ln5574">  if (trigger_dirchanged) {</a>
<a name="ln5575">    do_autocmd_dirchanged(cwd, scope, kCdCauseManual, false);</a>
<a name="ln5576">  }</a>
<a name="ln5577">}</a>
<a name="ln5578"> </a>
<a name="ln5579">/// Change directory function used by :cd/:tcd/:lcd Ex commands and the chdir() function.</a>
<a name="ln5580">/// @param new_dir  The directory to change to.</a>
<a name="ln5581">/// @param scope    Scope of the function call (global, tab or window).</a>
<a name="ln5582">/// @return true if the directory is successfully changed.</a>
<a name="ln5583">bool changedir_func(char *new_dir, CdScope scope)</a>
<a name="ln5584">{</a>
<a name="ln5585">  if (new_dir == NULL || allbuf_locked()) {</a>
<a name="ln5586">    return false;</a>
<a name="ln5587">  }</a>
<a name="ln5588"> </a>
<a name="ln5589">  char *pdir = NULL;</a>
<a name="ln5590">  // &quot;:cd -&quot;: Change to previous directory</a>
<a name="ln5591">  if (strcmp(new_dir, &quot;-&quot;) == 0) {</a>
<a name="ln5592">    pdir = get_prevdir(scope);</a>
<a name="ln5593">    if (pdir == NULL) {</a>
<a name="ln5594">      emsg(_(&quot;E186: No previous directory&quot;));</a>
<a name="ln5595">      return false;</a>
<a name="ln5596">    }</a>
<a name="ln5597">    new_dir = pdir;</a>
<a name="ln5598">  }</a>
<a name="ln5599"> </a>
<a name="ln5600">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5601">    pdir = xstrdup(NameBuff);</a>
<a name="ln5602">  } else {</a>
<a name="ln5603">    pdir = NULL;</a>
<a name="ln5604">  }</a>
<a name="ln5605"> </a>
<a name="ln5606">  // For UNIX &quot;:cd&quot; means: go to home directory.</a>
<a name="ln5607">  // On other systems too if 'cdhome' is set.</a>
<a name="ln5608">#if defined(UNIX)</a>
<a name="ln5609">  if (*new_dir == NUL) {</a>
<a name="ln5610">#else</a>
<a name="ln5611">  if (*new_dir == NUL &amp;&amp; p_cdh) {</a>
<a name="ln5612">#endif</a>
<a name="ln5613">    // Use NameBuff for home directory name.</a>
<a name="ln5614">    expand_env(&quot;$HOME&quot;, NameBuff, MAXPATHL);</a>
<a name="ln5615">    new_dir = NameBuff;</a>
<a name="ln5616">  }</a>
<a name="ln5617"> </a>
<a name="ln5618">  bool dir_differs = pdir == NULL || pathcmp(pdir, new_dir, -1) != 0;</a>
<a name="ln5619">  if (dir_differs) {</a>
<a name="ln5620">    do_autocmd_dirchanged(new_dir, scope, kCdCauseManual, true);</a>
<a name="ln5621">    if (vim_chdir(new_dir) != 0) {</a>
<a name="ln5622">      emsg(_(e_failed));</a>
<a name="ln5623">      xfree(pdir);</a>
<a name="ln5624">      return false;</a>
<a name="ln5625">    }</a>
<a name="ln5626">  }</a>
<a name="ln5627"> </a>
<a name="ln5628">  char **pp;</a>
<a name="ln5629">  switch (scope) {</a>
<a name="ln5630">  case kCdScopeTabpage:</a>
<a name="ln5631">    pp = &amp;curtab-&gt;tp_prevdir;</a>
<a name="ln5632">    break;</a>
<a name="ln5633">  case kCdScopeWindow:</a>
<a name="ln5634">    pp = &amp;curwin-&gt;w_prevdir;</a>
<a name="ln5635">    break;</a>
<a name="ln5636">  default:</a>
<a name="ln5637">    pp = &amp;prev_dir;</a>
<a name="ln5638">  }</a>
<a name="ln5639">  xfree(*pp);</a>
<a name="ln5640">  *pp = pdir;</a>
<a name="ln5641"> </a>
<a name="ln5642">  post_chdir(scope, dir_differs);</a>
<a name="ln5643"> </a>
<a name="ln5644">  return true;</a>
<a name="ln5645">}</a>
<a name="ln5646"> </a>
<a name="ln5647">/// &quot;:cd&quot;, &quot;:tcd&quot;, &quot;:lcd&quot;, &quot;:chdir&quot;, &quot;tchdir&quot; and &quot;:lchdir&quot;.</a>
<a name="ln5648">void ex_cd(exarg_T *eap)</a>
<a name="ln5649">{</a>
<a name="ln5650">  char *new_dir = eap-&gt;arg;</a>
<a name="ln5651">#if !defined(UNIX)</a>
<a name="ln5652">  // for non-UNIX &quot;:cd&quot; means: print current directory unless 'cdhome' is set</a>
<a name="ln5653">  if (*new_dir == NUL &amp;&amp; !p_cdh) {</a>
<a name="ln5654">    ex_pwd(NULL);</a>
<a name="ln5655">    return;</a>
<a name="ln5656">  }</a>
<a name="ln5657">#endif</a>
<a name="ln5658"> </a>
<a name="ln5659">  CdScope scope = kCdScopeGlobal;</a>
<a name="ln5660">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5661">  case CMD_tcd:</a>
<a name="ln5662">  case CMD_tchdir:</a>
<a name="ln5663">    scope = kCdScopeTabpage;</a>
<a name="ln5664">    break;</a>
<a name="ln5665">  case CMD_lcd:</a>
<a name="ln5666">  case CMD_lchdir:</a>
<a name="ln5667">    scope = kCdScopeWindow;</a>
<a name="ln5668">    break;</a>
<a name="ln5669">  default:</a>
<a name="ln5670">    break;</a>
<a name="ln5671">  }</a>
<a name="ln5672">  if (changedir_func(new_dir, scope)) {</a>
<a name="ln5673">    // Echo the new current directory if the command was typed.</a>
<a name="ln5674">    if (KeyTyped || p_verbose &gt;= 5) {</a>
<a name="ln5675">      ex_pwd(eap);</a>
<a name="ln5676">    }</a>
<a name="ln5677">  }</a>
<a name="ln5678">}</a>
<a name="ln5679"> </a>
<a name="ln5680">/// &quot;:pwd&quot;.</a>
<a name="ln5681">static void ex_pwd(exarg_T *eap)</a>
<a name="ln5682">{</a>
<a name="ln5683">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5684">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5685">    slash_adjust(NameBuff);</a>
<a name="ln5686">#endif</a>
<a name="ln5687">    if (p_verbose &gt; 0) {</a>
<a name="ln5688">      char *context = &quot;global&quot;;</a>
<a name="ln5689">      if (last_chdir_reason != NULL) {</a>
<a name="ln5690">        context = last_chdir_reason;</a>
<a name="ln5691">      } else if (curwin-&gt;w_localdir != NULL) {</a>
<a name="ln5692">        context = &quot;window&quot;;</a>
<a name="ln5693">      } else if (curtab-&gt;tp_localdir != NULL) {</a>
<a name="ln5694">        context = &quot;tabpage&quot;;</a>
<a name="ln5695">      }</a>
<a name="ln5696">      smsg(0, &quot;[%s] %s&quot;, context, NameBuff);</a>
<a name="ln5697">    } else {</a>
<a name="ln5698">      msg(NameBuff, 0);</a>
<a name="ln5699">    }</a>
<a name="ln5700">  } else {</a>
<a name="ln5701">    emsg(_(&quot;E187: Unknown&quot;));</a>
<a name="ln5702">  }</a>
<a name="ln5703">}</a>
<a name="ln5704"> </a>
<a name="ln5705">/// &quot;:=&quot;.</a>
<a name="ln5706">static void ex_equal(exarg_T *eap)</a>
<a name="ln5707">{</a>
<a name="ln5708">  if (*eap-&gt;arg != NUL &amp;&amp; *eap-&gt;arg != '|') {</a>
<a name="ln5709">    // equivalent to :lua= expr</a>
<a name="ln5710">    ex_lua(eap);</a>
<a name="ln5711">  } else {</a>
<a name="ln5712">    eap-&gt;nextcmd = find_nextcmd(eap-&gt;arg);</a>
<a name="ln5713">    smsg(0, &quot;%&quot; PRId64, (int64_t)eap-&gt;line2);</a>
<a name="ln5714">  }</a>
<a name="ln5715">}</a>
<a name="ln5716"> </a>
<a name="ln5717">static void ex_sleep(exarg_T *eap)</a>
<a name="ln5718">{</a>
<a name="ln5719">  if (cursor_valid()) {</a>
<a name="ln5720">    setcursor_mayforce(true);</a>
<a name="ln5721">  }</a>
<a name="ln5722"> </a>
<a name="ln5723">  int64_t len = eap-&gt;line2;</a>
<a name="ln5724">  switch (*eap-&gt;arg) {</a>
<a name="ln5725">  case 'm':</a>
<a name="ln5726">    break;</a>
<a name="ln5727">  case NUL:</a>
<a name="ln5728">    len *= 1000L; break;</a>
<a name="ln5729">  default:</a>
<a name="ln5730">    semsg(_(e_invarg2), eap-&gt;arg); return;</a>
<a name="ln5731">  }</a>
<a name="ln5732">  do_sleep(len);</a>
<a name="ln5733">}</a>
<a name="ln5734"> </a>
<a name="ln5735">/// Sleep for &quot;msec&quot; milliseconds, but return early on CTRL-C.</a>
<a name="ln5736">void do_sleep(int64_t msec)</a>
<a name="ln5737">{</a>
<a name="ln5738">  ui_flush();  // flush before waiting</a>
<a name="ln5739">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, msec, got_int);</a>
<a name="ln5740"> </a>
<a name="ln5741">  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the</a>
<a name="ln5742">  // input buffer, otherwise a following call to input() fails.</a>
<a name="ln5743">  if (got_int) {</a>
<a name="ln5744">    (void)vpeekc();</a>
<a name="ln5745">  }</a>
<a name="ln5746">}</a>
<a name="ln5747"> </a>
<a name="ln5748">/// &quot;:winsize&quot; command (obsolete).</a>
<a name="ln5749">static void ex_winsize(exarg_T *eap)</a>
<a name="ln5750">{</a>
<a name="ln5751">  char *arg = eap-&gt;arg;</a>
<a name="ln5752"> </a>
<a name="ln5753">  if (!ascii_isdigit(*arg)) {</a>
<a name="ln5754">    semsg(_(e_invarg2), arg);</a>
<a name="ln5755">    return;</a>
<a name="ln5756">  }</a>
<a name="ln5757">  int w = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5758">  arg = skipwhite(arg);</a>
<a name="ln5759">  char *p = arg;</a>
<a name="ln5760">  int h = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5761">  if (*p != NUL &amp;&amp; *arg == NUL) {</a>
<a name="ln5762">    screen_resize(w, h);</a>
<a name="ln5763">  } else {</a>
<a name="ln5764">    emsg(_(&quot;E465: :winsize requires two number arguments&quot;));</a>
<a name="ln5765">  }</a>
<a name="ln5766">}</a>
<a name="ln5767"> </a>
<a name="ln5768">static void ex_wincmd(exarg_T *eap)</a>
<a name="ln5769">{</a>
<a name="ln5770">  int xchar = NUL;</a>
<a name="ln5771">  char *p;</a>
<a name="ln5772"> </a>
<a name="ln5773">  if (*eap-&gt;arg == 'g' || *eap-&gt;arg == Ctrl_G) {</a>
<a name="ln5774">    // CTRL-W g and CTRL-W CTRL-G  have an extra command character</a>
<a name="ln5775">    if (eap-&gt;arg[1] == NUL) {</a>
<a name="ln5776">      emsg(_(e_invarg));</a>
<a name="ln5777">      return;</a>
<a name="ln5778">    }</a>
<a name="ln5779">    xchar = (uint8_t)eap-&gt;arg[1];</a>
<a name="ln5780">    p = eap-&gt;arg + 2;</a>
<a name="ln5781">  } else {</a>
<a name="ln5782">    p = eap-&gt;arg + 1;</a>
<a name="ln5783">  }</a>
<a name="ln5784"> </a>
<a name="ln5785">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln5786">  p = skipwhite(p);</a>
<a name="ln5787">  if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; eap-&gt;nextcmd == NULL) {</a>
<a name="ln5788">    emsg(_(e_invarg));</a>
<a name="ln5789">  } else if (!eap-&gt;skip) {</a>
<a name="ln5790">    // Pass flags on for &quot;:vertical wincmd ]&quot;.</a>
<a name="ln5791">    postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln5792">    postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln5793">    do_window(*eap-&gt;arg, eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0L, xchar);</a>
<a name="ln5794">    postponed_split_flags = 0;</a>
<a name="ln5795">    postponed_split_tab = 0;</a>
<a name="ln5796">  }</a>
<a name="ln5797">}</a>
<a name="ln5798"> </a>
<a name="ln5799">/// Handle command that work like operators: &quot;:delete&quot;, &quot;:yank&quot;, &quot;:&gt;&quot; and &quot;:&lt;&quot;.</a>
<a name="ln5800">static void ex_operators(exarg_T *eap)</a>
<a name="ln5801">{</a>
<a name="ln5802">  oparg_T oa;</a>
<a name="ln5803"> </a>
<a name="ln5804">  clear_oparg(&amp;oa);</a>
<a name="ln5805">  oa.regname = eap-&gt;regname;</a>
<a name="ln5806">  oa.start.lnum = eap-&gt;line1;</a>
<a name="ln5807">  oa.end.lnum = eap-&gt;line2;</a>
<a name="ln5808">  oa.line_count = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln5809">  oa.motion_type = kMTLineWise;</a>
<a name="ln5810">  virtual_op = kFalse;</a>
<a name="ln5811">  if (eap-&gt;cmdidx != CMD_yank) {  // position cursor for undo</a>
<a name="ln5812">    setpcmark();</a>
<a name="ln5813">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5814">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln5815">  }</a>
<a name="ln5816"> </a>
<a name="ln5817">  if (VIsual_active) {</a>
<a name="ln5818">    end_visual_mode();</a>
<a name="ln5819">  }</a>
<a name="ln5820"> </a>
<a name="ln5821">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5822">  case CMD_delete:</a>
<a name="ln5823">    oa.op_type = OP_DELETE;</a>
<a name="ln5824">    op_delete(&amp;oa);</a>
<a name="ln5825">    break;</a>
<a name="ln5826"> </a>
<a name="ln5827">  case CMD_yank:</a>
<a name="ln5828">    oa.op_type = OP_YANK;</a>
<a name="ln5829">    (void)op_yank(&amp;oa, true);</a>
<a name="ln5830">    break;</a>
<a name="ln5831"> </a>
<a name="ln5832">  default:          // CMD_rshift or CMD_lshift</a>
<a name="ln5833">    if (</a>
<a name="ln5834">        (eap-&gt;cmdidx == CMD_rshift) ^ curwin-&gt;w_p_rl) {</a>
<a name="ln5835">      oa.op_type = OP_RSHIFT;</a>
<a name="ln5836">    } else {</a>
<a name="ln5837">      oa.op_type = OP_LSHIFT;</a>
<a name="ln5838">    }</a>
<a name="ln5839">    op_shift(&amp;oa, false, eap-&gt;amount);</a>
<a name="ln5840">    break;</a>
<a name="ln5841">  }</a>
<a name="ln5842">  virtual_op = kNone;</a>
<a name="ln5843">  ex_may_print(eap);</a>
<a name="ln5844">}</a>
<a name="ln5845"> </a>
<a name="ln5846">/// &quot;:put&quot;.</a>
<a name="ln5847">static void ex_put(exarg_T *eap)</a>
<a name="ln5848">{</a>
<a name="ln5849">  // &quot;:0put&quot; works like &quot;:1put!&quot;.</a>
<a name="ln5850">  if (eap-&gt;line2 == 0) {</a>
<a name="ln5851">    eap-&gt;line2 = 1;</a>
<a name="ln5852">    eap-&gt;forceit = true;</a>
<a name="ln5853">  }</a>
<a name="ln5854">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5855">  check_cursor_col();</a>
<a name="ln5856">  do_put(eap-&gt;regname, NULL, eap-&gt;forceit ? BACKWARD : FORWARD, 1,</a>
<a name="ln5857">         PUT_LINE|PUT_CURSLINE);</a>
<a name="ln5858">}</a>
<a name="ln5859"> </a>
<a name="ln5860">/// Handle &quot;:copy&quot; and &quot;:move&quot;.</a>
<a name="ln5861">static void ex_copymove(exarg_T *eap)</a>
<a name="ln5862">{</a>
<a name="ln5863">  const char *errormsg = NULL;</a>
<a name="ln5864">  linenr_T n = get_address(eap, &amp;eap-&gt;arg, eap-&gt;addr_type, false, false, false, 1, &amp;errormsg);</a>
<a name="ln5865">  if (eap-&gt;arg == NULL) {  // error detected</a>
<a name="ln5866">    if (errormsg != NULL) {</a>
<a name="ln5867">      emsg(errormsg);</a>
<a name="ln5868">    }</a>
<a name="ln5869">    eap-&gt;nextcmd = NULL;</a>
<a name="ln5870">    return;</a>
<a name="ln5871">  }</a>
<a name="ln5872">  get_flags(eap);</a>
<a name="ln5873"> </a>
<a name="ln5874">  // move or copy lines from 'eap-&gt;line1'-'eap-&gt;line2' to below line 'n'</a>
<a name="ln5875">  if (n == MAXLNUM || n &lt; 0 || n &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5876">    emsg(_(e_invrange));</a>
<a name="ln5877">    return;</a>
<a name="ln5878">  }</a>
<a name="ln5879"> </a>
<a name="ln5880">  if (eap-&gt;cmdidx == CMD_move) {</a>
<a name="ln5881">    if (do_move(eap-&gt;line1, eap-&gt;line2, n) == FAIL) {</a>
<a name="ln5882">      return;</a>
<a name="ln5883">    }</a>
<a name="ln5884">  } else {</a>
<a name="ln5885">    ex_copy(eap-&gt;line1, eap-&gt;line2, n);</a>
<a name="ln5886">  }</a>
<a name="ln5887">  u_clearline(curbuf);</a>
<a name="ln5888">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln5889">  ex_may_print(eap);</a>
<a name="ln5890">}</a>
<a name="ln5891"> </a>
<a name="ln5892">/// Print the current line if flags were given to the Ex command.</a>
<a name="ln5893">void ex_may_print(exarg_T *eap)</a>
<a name="ln5894">{</a>
<a name="ln5895">  if (eap-&gt;flags != 0) {</a>
<a name="ln5896">    print_line(curwin-&gt;w_cursor.lnum, (eap-&gt;flags &amp; EXFLAG_NR),</a>
<a name="ln5897">               (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln5898">    ex_no_reprint = true;</a>
<a name="ln5899">  }</a>
<a name="ln5900">}</a>
<a name="ln5901"> </a>
<a name="ln5902">/// &quot;:smagic&quot; and &quot;:snomagic&quot;.</a>
<a name="ln5903">static void ex_submagic(exarg_T *eap)</a>
<a name="ln5904">{</a>
<a name="ln5905">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5906"> </a>
<a name="ln5907">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5908">  ex_substitute(eap);</a>
<a name="ln5909">  magic_overruled = saved;</a>
<a name="ln5910">}</a>
<a name="ln5911"> </a>
<a name="ln5912">/// &quot;:smagic&quot; and &quot;:snomagic&quot; preview callback.</a>
<a name="ln5913">static int ex_submagic_preview(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln5914">{</a>
<a name="ln5915">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5916"> </a>
<a name="ln5917">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5918">  int retv = ex_substitute_preview(eap, cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln5919">  magic_overruled = saved;</a>
<a name="ln5920"> </a>
<a name="ln5921">  return retv;</a>
<a name="ln5922">}</a>
<a name="ln5923"> </a>
<a name="ln5924">/// &quot;:join&quot;.</a>
<a name="ln5925">static void ex_join(exarg_T *eap)</a>
<a name="ln5926">{</a>
<a name="ln5927">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5928">  if (eap-&gt;line1 == eap-&gt;line2) {</a>
<a name="ln5929">    if (eap-&gt;addr_count &gt;= 2) {     // :2,2join does nothing</a>
<a name="ln5930">      return;</a>
<a name="ln5931">    }</a>
<a name="ln5932">    if (eap-&gt;line2 == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5933">      beep_flush();</a>
<a name="ln5934">      return;</a>
<a name="ln5935">    }</a>
<a name="ln5936">    eap-&gt;line2++;</a>
<a name="ln5937">  }</a>
<a name="ln5938">  do_join((size_t)((ssize_t)eap-&gt;line2 - eap-&gt;line1 + 1), !eap-&gt;forceit, true, true, true);</a>
<a name="ln5939">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5940">  ex_may_print(eap);</a>
<a name="ln5941">}</a>
<a name="ln5942"> </a>
<a name="ln5943">/// &quot;:[addr]@r&quot;: execute register</a>
<a name="ln5944">static void ex_at(exarg_T *eap)</a>
<a name="ln5945">{</a>
<a name="ln5946">  int prev_len = typebuf.tb_len;</a>
<a name="ln5947"> </a>
<a name="ln5948">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5949">  check_cursor_col();</a>
<a name="ln5950"> </a>
<a name="ln5951">  // Get the register name. No name means use the previous one.</a>
<a name="ln5952">  int c = (uint8_t)(*eap-&gt;arg);</a>
<a name="ln5953">  if (c == NUL) {</a>
<a name="ln5954">    c = '@';</a>
<a name="ln5955">  }</a>
<a name="ln5956"> </a>
<a name="ln5957">  // Put the register in the typeahead buffer with the &quot;silent&quot; flag.</a>
<a name="ln5958">  if (do_execreg(c, true, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, true) == FAIL) {</a>
<a name="ln5959">    beep_flush();</a>
<a name="ln5960">    return;</a>
<a name="ln5961">  }</a>
<a name="ln5962"> </a>
<a name="ln5963">  const bool save_efr = exec_from_reg;</a>
<a name="ln5964"> </a>
<a name="ln5965">  exec_from_reg = true;</a>
<a name="ln5966"> </a>
<a name="ln5967">  // Execute from the typeahead buffer.</a>
<a name="ln5968">  // Continue until the stuff buffer is empty and all added characters</a>
<a name="ln5969">  // have been consumed.</a>
<a name="ln5970">  while (!stuff_empty() || typebuf.tb_len &gt; prev_len) {</a>
<a name="ln5971">    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln5972">  }</a>
<a name="ln5973"> </a>
<a name="ln5974">  exec_from_reg = save_efr;</a>
<a name="ln5975">}</a>
<a name="ln5976"> </a>
<a name="ln5977">/// &quot;:!&quot;.</a>
<a name="ln5978">static void ex_bang(exarg_T *eap)</a>
<a name="ln5979">{</a>
<a name="ln5980">  do_bang(eap-&gt;addr_count, eap, eap-&gt;forceit, true, true);</a>
<a name="ln5981">}</a>
<a name="ln5982"> </a>
<a name="ln5983">/// &quot;:undo&quot;.</a>
<a name="ln5984">static void ex_undo(exarg_T *eap)</a>
<a name="ln5985">{</a>
<a name="ln5986">  if (eap-&gt;addr_count != 1) {</a>
<a name="ln5987">    if (eap-&gt;forceit) {</a>
<a name="ln5988">      u_undo_and_forget(1, true);   // :undo!</a>
<a name="ln5989">    } else {</a>
<a name="ln5990">      u_undo(1);                    // :undo</a>
<a name="ln5991">    }</a>
<a name="ln5992">    return;</a>
<a name="ln5993">  }</a>
<a name="ln5994"> </a>
<a name="ln5995">  linenr_T step = eap-&gt;line2;</a>
<a name="ln5996"> </a>
<a name="ln5997">  if (eap-&gt;forceit) {             // undo! 123</a>
<a name="ln5998">    // change number for &quot;undo!&quot; must be lesser than current change number</a>
<a name="ln5999">    if (step &gt;= curbuf-&gt;b_u_seq_cur) {</a>
<a name="ln6000">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln6001">      return;</a>
<a name="ln6002">    }</a>
<a name="ln6003">    // ensure that target change number is in same branch</a>
<a name="ln6004">    // while also counting the amount of undoes it'd take to reach target</a>
<a name="ln6005">    u_header_T *uhp;</a>
<a name="ln6006">    int count = 0;</a>
<a name="ln6007"> </a>
<a name="ln6008">    for (uhp = curbuf-&gt;b_u_curhead ? curbuf-&gt;b_u_curhead : curbuf-&gt;b_u_newhead;</a>
<a name="ln6009">         uhp != NULL &amp;&amp; uhp-&gt;uh_seq &gt; step;</a>
<a name="ln6010">         uhp = uhp-&gt;uh_next.ptr, ++count) {}</a>
<a name="ln6011">    if (step != 0 &amp;&amp; (uhp == NULL || uhp-&gt;uh_seq &lt; step)) {</a>
<a name="ln6012">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln6013">      return;</a>
<a name="ln6014">    }</a>
<a name="ln6015">    u_undo_and_forget(count, true);</a>
<a name="ln6016">  } else {                        // :undo 123</a>
<a name="ln6017">    undo_time(step, false, false, true);</a>
<a name="ln6018">  }</a>
<a name="ln6019">}</a>
<a name="ln6020"> </a>
<a name="ln6021">static void ex_wundo(exarg_T *eap)</a>
<a name="ln6022">{</a>
<a name="ln6023">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6024"> </a>
<a name="ln6025">  u_compute_hash(curbuf, hash);</a>
<a name="ln6026">  u_write_undo(eap-&gt;arg, eap-&gt;forceit, curbuf, hash);</a>
<a name="ln6027">}</a>
<a name="ln6028"> </a>
<a name="ln6029">static void ex_rundo(exarg_T *eap)</a>
<a name="ln6030">{</a>
<a name="ln6031">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6032"> </a>
<a name="ln6033">  u_compute_hash(curbuf, hash);</a>
<a name="ln6034">  u_read_undo(eap-&gt;arg, hash, NULL);</a>
<a name="ln6035">}</a>
<a name="ln6036"> </a>
<a name="ln6037">/// &quot;:redo&quot;.</a>
<a name="ln6038">static void ex_redo(exarg_T *eap)</a>
<a name="ln6039">{</a>
<a name="ln6040">  u_redo(1);</a>
<a name="ln6041">}</a>
<a name="ln6042"> </a>
<a name="ln6043">/// &quot;:earlier&quot; and &quot;:later&quot;.</a>
<a name="ln6044">static void ex_later(exarg_T *eap)</a>
<a name="ln6045">{</a>
<a name="ln6046">  long count = 0;</a>
<a name="ln6047">  bool sec = false;</a>
<a name="ln6048">  bool file = false;</a>
<a name="ln6049">  char *p = eap-&gt;arg;</a>
<a name="ln6050"> </a>
<a name="ln6051">  if (*p == NUL) {</a>
<a name="ln6052">    count = 1;</a>
<a name="ln6053">  } else if (isdigit((uint8_t)(*p))) {</a>
<a name="ln6054">    count = getdigits_long(&amp;p, false, 0);</a>
<a name="ln6055">    switch (*p) {</a>
<a name="ln6056">    case 's':</a>
<a name="ln6057">      p++; sec = true; break;</a>
<a name="ln6058">    case 'm':</a>
<a name="ln6059">      p++; sec = true; count *= 60; break;</a>
<a name="ln6060">    case 'h':</a>
<a name="ln6061">      p++; sec = true; count *= 60 * 60; break;</a>
<a name="ln6062">    case 'd':</a>
<a name="ln6063">      p++; sec = true; count *= 24 * 60 * 60; break;</a>
<a name="ln6064">    case 'f':</a>
<a name="ln6065">      p++; file = true; break;</a>
<a name="ln6066">    }</a>
<a name="ln6067">  }</a>
<a name="ln6068"> </a>
<a name="ln6069">  if (*p != NUL) {</a>
<a name="ln6070">    semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6071">  } else {</a>
<a name="ln6072">    undo_time(eap-&gt;cmdidx == CMD_earlier ? -count : count,</a>
<a name="ln6073">              sec, file, false);</a>
<a name="ln6074">  }</a>
<a name="ln6075">}</a>
<a name="ln6076"> </a>
<a name="ln6077">/// &quot;:redir&quot;: start/stop redirection.</a>
<a name="ln6078">static void ex_redir(exarg_T *eap)</a>
<a name="ln6079">{</a>
<a name="ln6080">  char *arg = eap-&gt;arg;</a>
<a name="ln6081"> </a>
<a name="ln6082">  if (STRICMP(eap-&gt;arg, &quot;END&quot;) == 0) {</a>
<a name="ln6083">    close_redir();</a>
<a name="ln6084">  } else {</a>
<a name="ln6085">    if (*arg == '&gt;') {</a>
<a name="ln6086">      arg++;</a>
<a name="ln6087">      char *mode;</a>
<a name="ln6088">      if (*arg == '&gt;') {</a>
<a name="ln6089">        arg++;</a>
<a name="ln6090">        mode = &quot;a&quot;;</a>
<a name="ln6091">      } else {</a>
<a name="ln6092">        mode = &quot;w&quot;;</a>
<a name="ln6093">      }</a>
<a name="ln6094">      arg = skipwhite(arg);</a>
<a name="ln6095"> </a>
<a name="ln6096">      close_redir();</a>
<a name="ln6097"> </a>
<a name="ln6098">      // Expand environment variables and &quot;~/&quot;.</a>
<a name="ln6099">      char *fname = expand_env_save(arg);</a>
<a name="ln6100">      if (fname == NULL) {</a>
<a name="ln6101">        return;</a>
<a name="ln6102">      }</a>
<a name="ln6103"> </a>
<a name="ln6104">      redir_fd = open_exfile(fname, eap-&gt;forceit, mode);</a>
<a name="ln6105">      xfree(fname);</a>
<a name="ln6106">    } else if (*arg == '@') {</a>
<a name="ln6107">      // redirect to a register a-z (resp. A-Z for appending)</a>
<a name="ln6108">      close_redir();</a>
<a name="ln6109">      arg++;</a>
<a name="ln6110">      if (valid_yank_reg(*arg, true) &amp;&amp; *arg != '_') {</a>
<a name="ln6111">        redir_reg = (uint8_t)(*arg++);</a>
<a name="ln6112">        if (*arg == '&gt;' &amp;&amp; arg[1] == '&gt;') {        // append</a>
<a name="ln6113">          arg += 2;</a>
<a name="ln6114">        } else {</a>
<a name="ln6115">          // Can use both &quot;@a&quot; and &quot;@a&gt;&quot;.</a>
<a name="ln6116">          if (*arg == '&gt;') {</a>
<a name="ln6117">            arg++;</a>
<a name="ln6118">          }</a>
<a name="ln6119">          // Make register empty when not using @A-@Z and the</a>
<a name="ln6120">          // command is valid.</a>
<a name="ln6121">          if (*arg == NUL &amp;&amp; !isupper(redir_reg)) {</a>
<a name="ln6122">            write_reg_contents(redir_reg, &quot;&quot;, 0, false);</a>
<a name="ln6123">          }</a>
<a name="ln6124">        }</a>
<a name="ln6125">      }</a>
<a name="ln6126">      if (*arg != NUL) {</a>
<a name="ln6127">        redir_reg = 0;</a>
<a name="ln6128">        semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6129">      }</a>
<a name="ln6130">    } else if (*arg == '=' &amp;&amp; arg[1] == '&gt;') {</a>
<a name="ln6131">      int append;</a>
<a name="ln6132"> </a>
<a name="ln6133">      // redirect to a variable</a>
<a name="ln6134">      close_redir();</a>
<a name="ln6135">      arg += 2;</a>
<a name="ln6136"> </a>
<a name="ln6137">      if (*arg == '&gt;') {</a>
<a name="ln6138">        arg++;</a>
<a name="ln6139">        append = true;</a>
<a name="ln6140">      } else {</a>
<a name="ln6141">        append = false;</a>
<a name="ln6142">      }</a>
<a name="ln6143"> </a>
<a name="ln6144">      if (var_redir_start(skipwhite(arg), append) == OK) {</a>
<a name="ln6145">        redir_vname = 1;</a>
<a name="ln6146">      }</a>
<a name="ln6147">    } else {  // TODO(vim): redirect to a buffer</a>
<a name="ln6148">      semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6149">    }</a>
<a name="ln6150">  }</a>
<a name="ln6151"> </a>
<a name="ln6152">  // Make sure redirection is not off.  Can happen for cmdline completion</a>
<a name="ln6153">  // that indirectly invokes a command to catch its output.</a>
<a name="ln6154">  if (redir_fd != NULL</a>
<a name="ln6155">      || redir_reg || redir_vname) {</a>
<a name="ln6156">    redir_off = false;</a>
<a name="ln6157">  }</a>
<a name="ln6158">}</a>
<a name="ln6159"> </a>
<a name="ln6160">/// &quot;:redraw&quot;: force redraw</a>
<a name="ln6161">static void ex_redraw(exarg_T *eap)</a>
<a name="ln6162">{</a>
<a name="ln6163">  if (cmdpreview) {</a>
<a name="ln6164">    return;  // Ignore :redraw during 'inccommand' preview. #9777</a>
<a name="ln6165">  }</a>
<a name="ln6166">  int r = RedrawingDisabled;</a>
<a name="ln6167">  int p = p_lz;</a>
<a name="ln6168"> </a>
<a name="ln6169">  RedrawingDisabled = 0;</a>
<a name="ln6170">  p_lz = false;</a>
<a name="ln6171">  validate_cursor();</a>
<a name="ln6172">  update_topline(curwin);</a>
<a name="ln6173">  if (eap-&gt;forceit) {</a>
<a name="ln6174">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln6175">    redraw_cmdline = true;</a>
<a name="ln6176">  } else if (VIsual_active) {</a>
<a name="ln6177">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6178">  }</a>
<a name="ln6179">  update_screen();</a>
<a name="ln6180">  if (need_maketitle) {</a>
<a name="ln6181">    maketitle();</a>
<a name="ln6182">  }</a>
<a name="ln6183">  RedrawingDisabled = r;</a>
<a name="ln6184">  p_lz = p;</a>
<a name="ln6185"> </a>
<a name="ln6186">  // Reset msg_didout, so that a message that's there is overwritten.</a>
<a name="ln6187">  msg_didout = false;</a>
<a name="ln6188">  msg_col = 0;</a>
<a name="ln6189"> </a>
<a name="ln6190">  // No need to wait after an intentional redraw.</a>
<a name="ln6191">  need_wait_return = false;</a>
<a name="ln6192"> </a>
<a name="ln6193">  ui_flush();</a>
<a name="ln6194">}</a>
<a name="ln6195"> </a>
<a name="ln6196">/// &quot;:redrawstatus&quot;: force redraw of status line(s) and window bar(s)</a>
<a name="ln6197">static void ex_redrawstatus(exarg_T *eap)</a>
<a name="ln6198">{</a>
<a name="ln6199">  if (cmdpreview) {</a>
<a name="ln6200">    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777</a>
<a name="ln6201">  }</a>
<a name="ln6202">  int r = RedrawingDisabled;</a>
<a name="ln6203">  int p = p_lz;</a>
<a name="ln6204"> </a>
<a name="ln6205">  if (eap-&gt;forceit) {</a>
<a name="ln6206">    status_redraw_all();</a>
<a name="ln6207">  } else {</a>
<a name="ln6208">    status_redraw_curbuf();</a>
<a name="ln6209">  }</a>
<a name="ln6210"> </a>
<a name="ln6211">  RedrawingDisabled = 0;</a>
<a name="ln6212">  p_lz = false;</a>
<a name="ln6213">  if (State &amp; MODE_CMDLINE) {</a>
<a name="ln6214">    redraw_statuslines();</a>
<a name="ln6215">  } else {</a>
<a name="ln6216">    if (VIsual_active) {</a>
<a name="ln6217">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6218">    }</a>
<a name="ln6219">    update_screen();</a>
<a name="ln6220">  }</a>
<a name="ln6221">  RedrawingDisabled = r;</a>
<a name="ln6222">  p_lz = p;</a>
<a name="ln6223">  ui_flush();</a>
<a name="ln6224">}</a>
<a name="ln6225"> </a>
<a name="ln6226">/// &quot;:redrawtabline&quot;: force redraw of the tabline</a>
<a name="ln6227">static void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)</a>
<a name="ln6228">{</a>
<a name="ln6229">  const int r = RedrawingDisabled;</a>
<a name="ln6230">  const int p = p_lz;</a>
<a name="ln6231"> </a>
<a name="ln6232">  RedrawingDisabled = 0;</a>
<a name="ln6233">  p_lz = false;</a>
<a name="ln6234"> </a>
<a name="ln6235">  draw_tabline();</a>
<a name="ln6236"> </a>
<a name="ln6237">  RedrawingDisabled = r;</a>
<a name="ln6238">  p_lz = p;</a>
<a name="ln6239">  ui_flush();</a>
<a name="ln6240">}</a>
<a name="ln6241"> </a>
<a name="ln6242">static void close_redir(void)</a>
<a name="ln6243">{</a>
<a name="ln6244">  if (redir_fd != NULL) {</a>
<a name="ln6245">    fclose(redir_fd);</a>
<a name="ln6246">    redir_fd = NULL;</a>
<a name="ln6247">  }</a>
<a name="ln6248">  redir_reg = 0;</a>
<a name="ln6249">  if (redir_vname) {</a>
<a name="ln6250">    var_redir_stop();</a>
<a name="ln6251">    redir_vname = 0;</a>
<a name="ln6252">  }</a>
<a name="ln6253">}</a>
<a name="ln6254"> </a>
<a name="ln6255">/// Try creating a directory, give error message on failure</a>
<a name="ln6256">///</a>
<a name="ln6257">/// @param[in]  name  Directory to create.</a>
<a name="ln6258">/// @param[in]  prot  Directory permissions.</a>
<a name="ln6259">///</a>
<a name="ln6260">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln6261">int vim_mkdir_emsg(const char *const name, const int prot)</a>
<a name="ln6262">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6263">{</a>
<a name="ln6264">  int ret;</a>
<a name="ln6265">  if ((ret = os_mkdir(name, prot)) != 0) {</a>
<a name="ln6266">    semsg(_(e_mkdir), name, os_strerror(ret));</a>
<a name="ln6267">    return FAIL;</a>
<a name="ln6268">  }</a>
<a name="ln6269">  return OK;</a>
<a name="ln6270">}</a>
<a name="ln6271"> </a>
<a name="ln6272">/// Open a file for writing for an Ex command, with some checks.</a>
<a name="ln6273">///</a>
<a name="ln6274">/// @param mode  &quot;w&quot; for create new file or &quot;a&quot; for append</a>
<a name="ln6275">///</a>
<a name="ln6276">/// @return  file descriptor, or NULL on failure.</a>
<a name="ln6277">FILE *open_exfile(char *fname, int forceit, char *mode)</a>
<a name="ln6278">{</a>
<a name="ln6279">#ifdef UNIX</a>
<a name="ln6280">  // with Unix it is possible to open a directory</a>
<a name="ln6281">  if (os_isdir(fname)) {</a>
<a name="ln6282">    semsg(_(e_isadir2), fname);</a>
<a name="ln6283">    return NULL;</a>
<a name="ln6284">  }</a>
<a name="ln6285">#endif</a>
<a name="ln6286">  if (!forceit &amp;&amp; *mode != 'a' &amp;&amp; os_path_exists(fname)) {</a>
<a name="ln6287">    semsg(_(&quot;E189: \&quot;%s\&quot; exists (add ! to override)&quot;), fname);</a>
<a name="ln6288">    return NULL;</a>
<a name="ln6289">  }</a>
<a name="ln6290"> </a>
<a name="ln6291">  FILE *fd;</a>
<a name="ln6292">  if ((fd = os_fopen(fname, mode)) == NULL) {</a>
<a name="ln6293">    semsg(_(&quot;E190: Cannot open \&quot;%s\&quot; for writing&quot;), fname);</a>
<a name="ln6294">  }</a>
<a name="ln6295"> </a>
<a name="ln6296">  return fd;</a>
<a name="ln6297">}</a>
<a name="ln6298"> </a>
<a name="ln6299">/// &quot;:mark&quot; and &quot;:k&quot;.</a>
<a name="ln6300">static void ex_mark(exarg_T *eap)</a>
<a name="ln6301">{</a>
<a name="ln6302">  if (*eap-&gt;arg == NUL) {               // No argument?</a>
<a name="ln6303">    emsg(_(e_argreq));</a>
<a name="ln6304">    return;</a>
<a name="ln6305">  }</a>
<a name="ln6306"> </a>
<a name="ln6307">  if (eap-&gt;arg[1] != NUL) {         // more than one character?</a>
<a name="ln6308">    semsg(_(e_trailing_arg), eap-&gt;arg);</a>
<a name="ln6309">    return;</a>
<a name="ln6310">  }</a>
<a name="ln6311"> </a>
<a name="ln6312">  pos_T pos = curwin-&gt;w_cursor;             // save curwin-&gt;w_cursor</a>
<a name="ln6313">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln6314">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln6315">  if (setmark(*eap-&gt;arg) == FAIL) {   // set mark</a>
<a name="ln6316">    emsg(_(&quot;E191: Argument must be a letter or forward/backward quote&quot;));</a>
<a name="ln6317">  }</a>
<a name="ln6318">  curwin-&gt;w_cursor = pos;             // restore curwin-&gt;w_cursor</a>
<a name="ln6319">}</a>
<a name="ln6320"> </a>
<a name="ln6321">/// Update w_topline, w_leftcol and the cursor position.</a>
<a name="ln6322">void update_topline_cursor(void)</a>
<a name="ln6323">{</a>
<a name="ln6324">  check_cursor();               // put cursor on valid line</a>
<a name="ln6325">  update_topline(curwin);</a>
<a name="ln6326">  if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln6327">    validate_cursor();</a>
<a name="ln6328">  }</a>
<a name="ln6329">  update_curswant();</a>
<a name="ln6330">}</a>
<a name="ln6331"> </a>
<a name="ln6332">/// Save the current State and go to Normal mode.</a>
<a name="ln6333">///</a>
<a name="ln6334">/// @return  true if the typeahead could be saved.</a>
<a name="ln6335">bool save_current_state(save_state_T *sst)</a>
<a name="ln6336">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6337">{</a>
<a name="ln6338">  sst-&gt;save_msg_scroll = msg_scroll;</a>
<a name="ln6339">  sst-&gt;save_restart_edit = restart_edit;</a>
<a name="ln6340">  sst-&gt;save_msg_didout = msg_didout;</a>
<a name="ln6341">  sst-&gt;save_State = State;</a>
<a name="ln6342">  sst-&gt;save_finish_op = finish_op;</a>
<a name="ln6343">  sst-&gt;save_opcount = opcount;</a>
<a name="ln6344">  sst-&gt;save_reg_executing = reg_executing;</a>
<a name="ln6345">  sst-&gt;save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln6346"> </a>
<a name="ln6347">  msg_scroll = false;   // no msg scrolling in Normal mode</a>
<a name="ln6348">  restart_edit = 0;     // don't go to Insert mode</a>
<a name="ln6349"> </a>
<a name="ln6350">  // Save the current typeahead.  This is required to allow using &quot;:normal&quot;</a>
<a name="ln6351">  // from an event handler and makes sure we don't hang when the argument</a>
<a name="ln6352">  // ends with half a command.</a>
<a name="ln6353">  save_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6354">  return sst-&gt;tabuf.typebuf_valid;</a>
<a name="ln6355">}</a>
<a name="ln6356"> </a>
<a name="ln6357">void restore_current_state(save_state_T *sst)</a>
<a name="ln6358">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6359">{</a>
<a name="ln6360">  // Restore the previous typeahead.</a>
<a name="ln6361">  restore_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6362"> </a>
<a name="ln6363">  msg_scroll = sst-&gt;save_msg_scroll;</a>
<a name="ln6364">  if (force_restart_edit) {</a>
<a name="ln6365">    force_restart_edit = false;</a>
<a name="ln6366">  } else {</a>
<a name="ln6367">    // Some function (terminal_enter()) was aware of ex_normal and decided to</a>
<a name="ln6368">    // override the value of restart_edit anyway.</a>
<a name="ln6369">    restart_edit = sst-&gt;save_restart_edit;</a>
<a name="ln6370">  }</a>
<a name="ln6371">  finish_op = sst-&gt;save_finish_op;</a>
<a name="ln6372">  opcount = sst-&gt;save_opcount;</a>
<a name="ln6373">  reg_executing = sst-&gt;save_reg_executing;</a>
<a name="ln6374">  pending_end_reg_executing = sst-&gt;save_pending_end_reg_executing;</a>
<a name="ln6375"> </a>
<a name="ln6376">  // don't reset msg_didout now</a>
<a name="ln6377">  msg_didout |= sst-&gt;save_msg_didout;</a>
<a name="ln6378"> </a>
<a name="ln6379">  // Restore the state (needed when called from a function executed for</a>
<a name="ln6380">  // 'indentexpr'). Update the mouse and cursor, they may have changed.</a>
<a name="ln6381">  State = sst-&gt;save_State;</a>
<a name="ln6382">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6383">}</a>
<a name="ln6384"> </a>
<a name="ln6385">bool expr_map_locked(void)</a>
<a name="ln6386">{</a>
<a name="ln6387">  return expr_map_lock &gt; 0 &amp;&amp; !(curbuf-&gt;b_flags &amp; BF_DUMMY);</a>
<a name="ln6388">}</a>
<a name="ln6389"> </a>
<a name="ln6390">/// &quot;:normal[!] {commands}&quot;: Execute normal mode commands.</a>
<a name="ln6391">static void ex_normal(exarg_T *eap)</a>
<a name="ln6392">{</a>
<a name="ln6393">  if (curbuf-&gt;terminal &amp;&amp; State &amp; MODE_TERMINAL) {</a>
<a name="ln6394">    emsg(&quot;Can't re-enter normal mode from terminal mode&quot;);</a>
<a name="ln6395">    return;</a>
<a name="ln6396">  }</a>
<a name="ln6397">  char *arg = NULL;</a>
<a name="ln6398"> </a>
<a name="ln6399">  if (expr_map_locked()) {</a>
<a name="ln6400">    emsg(_(e_secure));</a>
<a name="ln6401">    return;</a>
<a name="ln6402">  }</a>
<a name="ln6403"> </a>
<a name="ln6404">  if (ex_normal_busy &gt;= p_mmd) {</a>
<a name="ln6405">    emsg(_(&quot;E192: Recursive use of :normal too deep&quot;));</a>
<a name="ln6406">    return;</a>
<a name="ln6407">  }</a>
<a name="ln6408"> </a>
<a name="ln6409">  // vgetc() expects K_SPECIAL to have been escaped.  Don't do</a>
<a name="ln6410">  // this for the K_SPECIAL leading byte, otherwise special keys will not</a>
<a name="ln6411">  // work.</a>
<a name="ln6412">  {</a>
<a name="ln6413">    int len = 0;</a>
<a name="ln6414"> </a>
<a name="ln6415">    // Count the number of characters to be escaped.</a>
<a name="ln6416">    int l;</a>
<a name="ln6417">    char *p;</a>
<a name="ln6418">    for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6419">      for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6420">        if (*++p == (char)K_SPECIAL) {  // trailbyte K_SPECIAL</a>
<a name="ln6421">          len += 2;</a>
<a name="ln6422">        }</a>
<a name="ln6423">      }</a>
<a name="ln6424">    }</a>
<a name="ln6425">    if (len &gt; 0) {</a>
<a name="ln6426">      arg = xmalloc(strlen(eap-&gt;arg) + (size_t)len + 1);</a>
<a name="ln6427">      len = 0;</a>
<a name="ln6428">      for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6429">        arg[len++] = *p;</a>
<a name="ln6430">        for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6431">          arg[len++] = *++p;</a>
<a name="ln6432">          if (*p == (char)K_SPECIAL) {</a>
<a name="ln6433">            arg[len++] = (char)KS_SPECIAL;</a>
<a name="ln6434">            arg[len++] = KE_FILLER;</a>
<a name="ln6435">          }</a>
<a name="ln6436">        }</a>
<a name="ln6437">        arg[len] = NUL;</a>
<a name="ln6438">      }</a>
<a name="ln6439">    }</a>
<a name="ln6440">  }</a>
<a name="ln6441"> </a>
<a name="ln6442">  ex_normal_busy++;</a>
<a name="ln6443">  save_state_T save_state;</a>
<a name="ln6444">  if (save_current_state(&amp;save_state)) {</a>
<a name="ln6445">    // Repeat the :normal command for each line in the range.  When no</a>
<a name="ln6446">    // range given, execute it just once, without positioning the cursor</a>
<a name="ln6447">    // first.</a>
<a name="ln6448">    do {</a>
<a name="ln6449">      if (eap-&gt;addr_count != 0) {</a>
<a name="ln6450">        curwin-&gt;w_cursor.lnum = eap-&gt;line1++;</a>
<a name="ln6451">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln6452">        check_cursor_moved(curwin);</a>
<a name="ln6453">      }</a>
<a name="ln6454"> </a>
<a name="ln6455">      exec_normal_cmd((arg != NULL ? arg : eap-&gt;arg),</a>
<a name="ln6456">                      eap-&gt;forceit ? REMAP_NONE : REMAP_YES, false);</a>
<a name="ln6457">    } while (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line1 &lt;= eap-&gt;line2 &amp;&amp; !got_int);</a>
<a name="ln6458">  }</a>
<a name="ln6459"> </a>
<a name="ln6460">  // Might not return to the main loop when in an event handler.</a>
<a name="ln6461">  update_topline_cursor();</a>
<a name="ln6462"> </a>
<a name="ln6463">  restore_current_state(&amp;save_state);</a>
<a name="ln6464"> </a>
<a name="ln6465">  ex_normal_busy--;</a>
<a name="ln6466"> </a>
<a name="ln6467">  setmouse();</a>
<a name="ln6468">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6469">  xfree(arg);</a>
<a name="ln6470">}</a>
<a name="ln6471"> </a>
<a name="ln6472">/// &quot;:startinsert&quot;, &quot;:startreplace&quot; and &quot;:startgreplace&quot;</a>
<a name="ln6473">static void ex_startinsert(exarg_T *eap)</a>
<a name="ln6474">{</a>
<a name="ln6475">  if (eap-&gt;forceit) {</a>
<a name="ln6476">    // cursor line can be zero on startup</a>
<a name="ln6477">    if (!curwin-&gt;w_cursor.lnum) {</a>
<a name="ln6478">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln6479">    }</a>
<a name="ln6480">    set_cursor_for_append_to_line();</a>
<a name="ln6481">  }</a>
<a name="ln6482"> </a>
<a name="ln6483">  // Ignore the command when already in Insert mode.  Inserting an</a>
<a name="ln6484">  // expression register that invokes a function can do this.</a>
<a name="ln6485">  if (State &amp; MODE_INSERT) {</a>
<a name="ln6486">    return;</a>
<a name="ln6487">  }</a>
<a name="ln6488"> </a>
<a name="ln6489">  if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6490">    restart_edit = 'a';</a>
<a name="ln6491">  } else if (eap-&gt;cmdidx == CMD_startreplace) {</a>
<a name="ln6492">    restart_edit = 'R';</a>
<a name="ln6493">  } else {</a>
<a name="ln6494">    restart_edit = 'V';</a>
<a name="ln6495">  }</a>
<a name="ln6496"> </a>
<a name="ln6497">  if (!eap-&gt;forceit) {</a>
<a name="ln6498">    if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6499">      restart_edit = 'i';</a>
<a name="ln6500">    }</a>
<a name="ln6501">    curwin-&gt;w_curswant = 0;  // avoid MAXCOL</a>
<a name="ln6502">  }</a>
<a name="ln6503"> </a>
<a name="ln6504">  if (VIsual_active) {</a>
<a name="ln6505">    showmode();</a>
<a name="ln6506">  }</a>
<a name="ln6507">}</a>
<a name="ln6508"> </a>
<a name="ln6509">/// &quot;:stopinsert&quot;</a>
<a name="ln6510">static void ex_stopinsert(exarg_T *eap)</a>
<a name="ln6511">{</a>
<a name="ln6512">  restart_edit = 0;</a>
<a name="ln6513">  stop_insert_mode = true;</a>
<a name="ln6514">  clearmode();</a>
<a name="ln6515">}</a>
<a name="ln6516"> </a>
<a name="ln6517">/// Execute normal mode command &quot;cmd&quot;.</a>
<a name="ln6518">/// &quot;remap&quot; can be REMAP_NONE or REMAP_YES.</a>
<a name="ln6519">void exec_normal_cmd(char *cmd, int remap, bool silent)</a>
<a name="ln6520">{</a>
<a name="ln6521">  // Stuff the argument into the typeahead buffer.</a>
<a name="ln6522">  ins_typebuf(cmd, remap, 0, true, silent);</a>
<a name="ln6523">  exec_normal(false);</a>
<a name="ln6524">}</a>
<a name="ln6525"> </a>
<a name="ln6526">/// Execute normal_cmd() until there is no typeahead left.</a>
<a name="ln6527">///</a>
<a name="ln6528">/// @param was_typed whether or not something was typed</a>
<a name="ln6529">void exec_normal(bool was_typed)</a>
<a name="ln6530">{</a>
<a name="ln6531">  oparg_T oa;</a>
<a name="ln6532"> </a>
<a name="ln6533">  clear_oparg(&amp;oa);</a>
<a name="ln6534">  finish_op = false;</a>
<a name="ln6535">  while ((!stuff_empty()</a>
<a name="ln6536">          || ((was_typed || !typebuf_typed())</a>
<a name="ln6537">              &amp;&amp; typebuf.tb_len &gt; 0))</a>
<a name="ln6538">         &amp;&amp; !got_int) {</a>
<a name="ln6539">    update_topline_cursor();</a>
<a name="ln6540">    normal_cmd(&amp;oa, true);      // execute a Normal mode cmd</a>
<a name="ln6541">  }</a>
<a name="ln6542">}</a>
<a name="ln6543"> </a>
<a name="ln6544">static void ex_checkpath(exarg_T *eap)</a>
<a name="ln6545">{</a>
<a name="ln6546">  find_pattern_in_path(NULL, 0, 0, false, false, CHECK_PATH, 1L,</a>
<a name="ln6547">                       eap-&gt;forceit ? ACTION_SHOW_ALL : ACTION_SHOW,</a>
<a name="ln6548">                       (linenr_T)1, (linenr_T)MAXLNUM);</a>
<a name="ln6549">}</a>
<a name="ln6550"> </a>
<a name="ln6551">/// &quot;:psearch&quot;</a>
<a name="ln6552">static void ex_psearch(exarg_T *eap)</a>
<a name="ln6553">{</a>
<a name="ln6554">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6555">  ex_findpat(eap);</a>
<a name="ln6556">  g_do_tagpreview = 0;</a>
<a name="ln6557">}</a>
<a name="ln6558"> </a>
<a name="ln6559">static void ex_findpat(exarg_T *eap)</a>
<a name="ln6560">{</a>
<a name="ln6561">  bool whole = true;</a>
<a name="ln6562">  int action;</a>
<a name="ln6563"> </a>
<a name="ln6564">  switch (cmdnames[eap-&gt;cmdidx].cmd_name[2]) {</a>
<a name="ln6565">  case 'e':             // &quot;:psearch&quot;, &quot;:isearch&quot; and &quot;:dsearch&quot;</a>
<a name="ln6566">    if (cmdnames[eap-&gt;cmdidx].cmd_name[0] == 'p') {</a>
<a name="ln6567">      action = ACTION_GOTO;</a>
<a name="ln6568">    } else {</a>
<a name="ln6569">      action = ACTION_SHOW;</a>
<a name="ln6570">    }</a>
<a name="ln6571">    break;</a>
<a name="ln6572">  case 'i':             // &quot;:ilist&quot; and &quot;:dlist&quot;</a>
<a name="ln6573">    action = ACTION_SHOW_ALL;</a>
<a name="ln6574">    break;</a>
<a name="ln6575">  case 'u':             // &quot;:ijump&quot; and &quot;:djump&quot;</a>
<a name="ln6576">    action = ACTION_GOTO;</a>
<a name="ln6577">    break;</a>
<a name="ln6578">  default:              // &quot;:isplit&quot; and &quot;:dsplit&quot;</a>
<a name="ln6579">    action = ACTION_SPLIT;</a>
<a name="ln6580">    break;</a>
<a name="ln6581">  }</a>
<a name="ln6582"> </a>
<a name="ln6583">  int n = 1;</a>
<a name="ln6584">  if (ascii_isdigit(*eap-&gt;arg)) {  // get count</a>
<a name="ln6585">    n = getdigits_int(&amp;eap-&gt;arg, false, 0);</a>
<a name="ln6586">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln6587">  }</a>
<a name="ln6588">  if (*eap-&gt;arg == '/') {   // Match regexp, not just whole words</a>
<a name="ln6589">    whole = false;</a>
<a name="ln6590">    eap-&gt;arg++;</a>
<a name="ln6591">    char *p = skip_regexp(eap-&gt;arg, '/', magic_isset());</a>
<a name="ln6592">    if (*p) {</a>
<a name="ln6593">      *p++ = NUL;</a>
<a name="ln6594">      p = skipwhite(p);</a>
<a name="ln6595"> </a>
<a name="ln6596">      // Check for trailing illegal characters.</a>
<a name="ln6597">      if (!ends_excmd(*p)) {</a>
<a name="ln6598">        eap-&gt;errmsg = ex_errmsg(e_trailing_arg, p);</a>
<a name="ln6599">      } else {</a>
<a name="ln6600">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln6601">      }</a>
<a name="ln6602">    }</a>
<a name="ln6603">  }</a>
<a name="ln6604">  if (!eap-&gt;skip) {</a>
<a name="ln6605">    find_pattern_in_path(eap-&gt;arg, 0, strlen(eap-&gt;arg), whole, !eap-&gt;forceit,</a>
<a name="ln6606">                         *eap-&gt;cmd == 'd' ? FIND_DEFINE : FIND_ANY,</a>
<a name="ln6607">                         n, action, eap-&gt;line1, eap-&gt;line2);</a>
<a name="ln6608">  }</a>
<a name="ln6609">}</a>
<a name="ln6610"> </a>
<a name="ln6611">/// &quot;:ptag&quot;, &quot;:ptselect&quot;, &quot;:ptjump&quot;, &quot;:ptnext&quot;, etc.</a>
<a name="ln6612">static void ex_ptag(exarg_T *eap)</a>
<a name="ln6613">{</a>
<a name="ln6614">  g_do_tagpreview = (int)p_pvh;    // will be reset to 0 in ex_tag_cmd()</a>
<a name="ln6615">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6616">}</a>
<a name="ln6617"> </a>
<a name="ln6618">/// &quot;:pedit&quot;</a>
<a name="ln6619">static void ex_pedit(exarg_T *eap)</a>
<a name="ln6620">{</a>
<a name="ln6621">  win_T *curwin_save = curwin;</a>
<a name="ln6622"> </a>
<a name="ln6623">  // Open the preview window or popup and make it the current window.</a>
<a name="ln6624">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6625">  prepare_tagpreview(true);</a>
<a name="ln6626"> </a>
<a name="ln6627">  // Edit the file.</a>
<a name="ln6628">  do_exedit(eap, NULL);</a>
<a name="ln6629"> </a>
<a name="ln6630">  if (curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln6631">    // Return cursor to where we were</a>
<a name="ln6632">    validate_cursor();</a>
<a name="ln6633">    redraw_later(curwin, UPD_VALID);</a>
<a name="ln6634">    win_enter(curwin_save, true);</a>
<a name="ln6635">  }</a>
<a name="ln6636">  g_do_tagpreview = 0;</a>
<a name="ln6637">}</a>
<a name="ln6638"> </a>
<a name="ln6639">/// &quot;:stag&quot;, &quot;:stselect&quot; and &quot;:stjump&quot;.</a>
<a name="ln6640">static void ex_stag(exarg_T *eap)</a>
<a name="ln6641">{</a>
<a name="ln6642">  postponed_split = -1;</a>
<a name="ln6643">  postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln6644">  postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln6645">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6646">  postponed_split_flags = 0;</a>
<a name="ln6647">  postponed_split_tab = 0;</a>
<a name="ln6648">}</a>
<a name="ln6649"> </a>
<a name="ln6650">/// &quot;:tag&quot;, &quot;:tselect&quot;, &quot;:tjump&quot;, &quot;:tnext&quot;, etc.</a>
<a name="ln6651">static void ex_tag(exarg_T *eap)</a>
<a name="ln6652">{</a>
<a name="ln6653">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name);</a>
<a name="ln6654">}</a>
<a name="ln6655"> </a>
<a name="ln6656">static void ex_tag_cmd(exarg_T *eap, const char *name)</a>
<a name="ln6657">{</a>
<a name="ln6658">  int cmd;</a>
<a name="ln6659"> </a>
<a name="ln6660">  switch (name[1]) {</a>
<a name="ln6661">  case 'j':</a>
<a name="ln6662">    cmd = DT_JUMP;              // &quot;:tjump&quot;</a>
<a name="ln6663">    break;</a>
<a name="ln6664">  case 's':</a>
<a name="ln6665">    cmd = DT_SELECT;            // &quot;:tselect&quot;</a>
<a name="ln6666">    break;</a>
<a name="ln6667">  case 'p':                             // &quot;:tprevious&quot;</a>
<a name="ln6668">  case 'N':</a>
<a name="ln6669">    cmd = DT_PREV;              // &quot;:tNext&quot;</a>
<a name="ln6670">    break;</a>
<a name="ln6671">  case 'n':</a>
<a name="ln6672">    cmd = DT_NEXT;              // &quot;:tnext&quot;</a>
<a name="ln6673">    break;</a>
<a name="ln6674">  case 'o':</a>
<a name="ln6675">    cmd = DT_POP;               // &quot;:pop&quot;</a>
<a name="ln6676">    break;</a>
<a name="ln6677">  case 'f':                             // &quot;:tfirst&quot;</a>
<a name="ln6678">  case 'r':</a>
<a name="ln6679">    cmd = DT_FIRST;             // &quot;:trewind&quot;</a>
<a name="ln6680">    break;</a>
<a name="ln6681">  case 'l':</a>
<a name="ln6682">    cmd = DT_LAST;              // &quot;:tlast&quot;</a>
<a name="ln6683">    break;</a>
<a name="ln6684">  default:                              // &quot;:tag&quot;</a>
<a name="ln6685">    cmd = DT_TAG;</a>
<a name="ln6686">    break;</a>
<a name="ln6687">  }</a>
<a name="ln6688"> </a>
<a name="ln6689">  if (name[0] == 'l') {</a>
<a name="ln6690">    cmd = DT_LTAG;</a>
<a name="ln6691">  }</a>
<a name="ln6692"> </a>
<a name="ln6693">  do_tag(eap-&gt;arg, cmd, eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 1,</a>
<a name="ln6694">         eap-&gt;forceit, true);</a>
<a name="ln6695">}</a>
<a name="ln6696"> </a>
<a name="ln6697">enum {</a>
<a name="ln6698">  SPEC_PERC = 0,</a>
<a name="ln6699">  SPEC_HASH,</a>
<a name="ln6700">  SPEC_CWORD,</a>
<a name="ln6701">  SPEC_CCWORD,</a>
<a name="ln6702">  SPEC_CEXPR,</a>
<a name="ln6703">  SPEC_CFILE,</a>
<a name="ln6704">  SPEC_SFILE,</a>
<a name="ln6705">  SPEC_SLNUM,</a>
<a name="ln6706">  SPEC_STACK,</a>
<a name="ln6707">  SPEC_SCRIPT,</a>
<a name="ln6708">  SPEC_AFILE,</a>
<a name="ln6709">  SPEC_ABUF,</a>
<a name="ln6710">  SPEC_AMATCH,</a>
<a name="ln6711">  SPEC_SFLNUM,</a>
<a name="ln6712">  SPEC_SID,</a>
<a name="ln6713">  // SPEC_CLIENT,</a>
<a name="ln6714">};</a>
<a name="ln6715"> </a>
<a name="ln6716">/// Check &quot;str&quot; for starting with a special cmdline variable.</a>
<a name="ln6717">/// If found return one of the SPEC_ values and set &quot;*usedlen&quot; to the length of</a>
<a name="ln6718">/// the variable.  Otherwise return -1 and &quot;*usedlen&quot; is unchanged.</a>
<a name="ln6719">ssize_t find_cmdline_var(const char *src, size_t *usedlen)</a>
<a name="ln6720">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6721">{</a>
<a name="ln6722">  static char *(spec_str[]) = {</a>
<a name="ln6723">    [SPEC_PERC] = &quot;%&quot;,</a>
<a name="ln6724">    [SPEC_HASH] = &quot;#&quot;,</a>
<a name="ln6725">    [SPEC_CWORD] = &quot;&lt;cword&gt;&quot;,           // cursor word</a>
<a name="ln6726">    [SPEC_CCWORD] = &quot;&lt;cWORD&gt;&quot;,          // cursor WORD</a>
<a name="ln6727">    [SPEC_CEXPR] = &quot;&lt;cexpr&gt;&quot;,           // expr under cursor</a>
<a name="ln6728">    [SPEC_CFILE] = &quot;&lt;cfile&gt;&quot;,           // cursor path name</a>
<a name="ln6729">    [SPEC_SFILE] = &quot;&lt;sfile&gt;&quot;,           // &quot;:so&quot; file name</a>
<a name="ln6730">    [SPEC_SLNUM] = &quot;&lt;slnum&gt;&quot;,           // &quot;:so&quot; file line number</a>
<a name="ln6731">    [SPEC_STACK] = &quot;&lt;stack&gt;&quot;,           // call stack</a>
<a name="ln6732">    [SPEC_SCRIPT] = &quot;&lt;script&gt;&quot;,         // script file name</a>
<a name="ln6733">    [SPEC_AFILE] = &quot;&lt;afile&gt;&quot;,           // autocommand file name</a>
<a name="ln6734">    [SPEC_ABUF] = &quot;&lt;abuf&gt;&quot;,             // autocommand buffer number</a>
<a name="ln6735">    [SPEC_AMATCH] = &quot;&lt;amatch&gt;&quot;,         // autocommand match name</a>
<a name="ln6736">    [SPEC_SFLNUM] = &quot;&lt;sflnum&gt;&quot;,         // script file line number</a>
<a name="ln6737">    [SPEC_SID] = &quot;&lt;SID&gt;&quot;,               // script ID: &lt;SNR&gt;123_</a>
<a name="ln6738">    // [SPEC_CLIENT] = &quot;&lt;client&gt;&quot;,</a>
<a name="ln6739">  };</a>
<a name="ln6740"> </a>
<a name="ln6741">  for (size_t i = 0; i &lt; ARRAY_SIZE(spec_str); i++) {</a>
<a name="ln6742">    size_t len = strlen(spec_str[i]);</a>
<a name="ln6743">    if (strncmp(src, spec_str[i], len) == 0) {</a>
<a name="ln6744">      *usedlen = len;</a>
<a name="ln6745">      assert(i &lt;= SSIZE_MAX);</a>
<a name="ln6746">      return (ssize_t)i;</a>
<a name="ln6747">    }</a>
<a name="ln6748">  }</a>
<a name="ln6749">  return -1;</a>
<a name="ln6750">}</a>
<a name="ln6751"> </a>
<a name="ln6752">/// Evaluate cmdline variables.</a>
<a name="ln6753">///</a>
<a name="ln6754">/// change &quot;%&quot;       to curbuf-&gt;b_ffname</a>
<a name="ln6755">///        &quot;#&quot;       to curwin-&gt;w_alt_fnum</a>
<a name="ln6756">///        &quot;&lt;cword&gt;&quot; to word under the cursor</a>
<a name="ln6757">///        &quot;&lt;cWORD&gt;&quot; to WORD under the cursor</a>
<a name="ln6758">///        &quot;&lt;cexpr&gt;&quot; to C-expression under the cursor</a>
<a name="ln6759">///        &quot;&lt;cfile&gt;&quot; to path name under the cursor</a>
<a name="ln6760">///        &quot;&lt;sfile&gt;&quot; to sourced file name</a>
<a name="ln6761">///        &quot;&lt;stack&gt;&quot; to call stack</a>
<a name="ln6762">///        &quot;&lt;script&gt;&quot; to current script name</a>
<a name="ln6763">///        &quot;&lt;slnum&gt;&quot; to sourced file line number</a>
<a name="ln6764">///        &quot;&lt;afile&gt;&quot; to file name for autocommand</a>
<a name="ln6765">///        &quot;&lt;abuf&gt;&quot;  to buffer number for autocommand</a>
<a name="ln6766">///        &quot;&lt;amatch&gt;&quot; to matching name for autocommand</a>
<a name="ln6767">///</a>
<a name="ln6768">/// When an error is detected, &quot;errormsg&quot; is set to a non-NULL pointer (may be</a>
<a name="ln6769">/// &quot;&quot; for error without a message) and NULL is returned.</a>
<a name="ln6770">///</a>
<a name="ln6771">/// @param src             pointer into commandline</a>
<a name="ln6772">/// @param srcstart        beginning of valid memory for src</a>
<a name="ln6773">/// @param usedlen         characters after src that are used</a>
<a name="ln6774">/// @param lnump           line number for :e command, or NULL</a>
<a name="ln6775">/// @param errormsg        pointer to error message</a>
<a name="ln6776">/// @param escaped         return value has escaped white space (can be NULL)</a>
<a name="ln6777">/// @param empty_is_error  empty result is considered an error</a>
<a name="ln6778">///</a>
<a name="ln6779">/// @return          an allocated string if a valid match was found.</a>
<a name="ln6780">///                  Returns NULL if no match was found.  &quot;usedlen&quot; then still contains the</a>
<a name="ln6781">///                  number of characters to skip.</a>
<a name="ln6782">char *eval_vars(char *src, const char *srcstart, size_t *usedlen, linenr_T *lnump,</a>
<a name="ln6783">                const char **errormsg, int *escaped, bool empty_is_error)</a>
<a name="ln6784">{</a>
<a name="ln6785">  char *result;</a>
<a name="ln6786">  char *resultbuf = NULL;</a>
<a name="ln6787">  size_t resultlen;</a>
<a name="ln6788">  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.</a>
<a name="ln6789">  bool tilde_file = false;</a>
<a name="ln6790">  bool skip_mod = false;</a>
<a name="ln6791">  char strbuf[30];</a>
<a name="ln6792"> </a>
<a name="ln6793">  *errormsg = NULL;</a>
<a name="ln6794">  if (escaped != NULL) {</a>
<a name="ln6795">    *escaped = false;</a>
<a name="ln6796">  }</a>
<a name="ln6797"> </a>
<a name="ln6798">  // Check if there is something to do.</a>
<a name="ln6799">  ssize_t spec_idx = find_cmdline_var(src, usedlen);</a>
<a name="ln6800">  if (spec_idx &lt; 0) {   // no match</a>
<a name="ln6801">    *usedlen = 1;</a>
<a name="ln6802">    return NULL;</a>
<a name="ln6803">  }</a>
<a name="ln6804"> </a>
<a name="ln6805">  // Skip when preceded with a backslash &quot;\%&quot; and &quot;\#&quot;.</a>
<a name="ln6806">  // Note: In &quot;\\%&quot; the % is also not recognized!</a>
<a name="ln6807">  if (src &gt; srcstart &amp;&amp; src[-1] == '\\') {</a>
<a name="ln6808">    *usedlen = 0;</a>
<a name="ln6809">    STRMOVE(src - 1, src);      // remove backslash</a>
<a name="ln6810">    return NULL;</a>
<a name="ln6811">  }</a>
<a name="ln6812"> </a>
<a name="ln6813">  // word or WORD under cursor</a>
<a name="ln6814">  if (spec_idx == SPEC_CWORD</a>
<a name="ln6815">      || spec_idx == SPEC_CCWORD</a>
<a name="ln6816">      || spec_idx == SPEC_CEXPR) {</a>
<a name="ln6817">    resultlen = find_ident_under_cursor(&amp;result,</a>
<a name="ln6818">                                        spec_idx == SPEC_CWORD</a>
<a name="ln6819">                                        ? (FIND_IDENT | FIND_STRING)</a>
<a name="ln6820">                                        : (spec_idx == SPEC_CEXPR</a>
<a name="ln6821">                                           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)</a>
<a name="ln6822">                                           : FIND_STRING));</a>
<a name="ln6823">    if (resultlen == 0) {</a>
<a name="ln6824">      *errormsg = &quot;&quot;;</a>
<a name="ln6825">      return NULL;</a>
<a name="ln6826">    }</a>
<a name="ln6827">    //</a>
<a name="ln6828">    // '#': Alternate file name</a>
<a name="ln6829">    // '%': Current file name</a>
<a name="ln6830">    //        File name under the cursor</a>
<a name="ln6831">    //        File name for autocommand</a>
<a name="ln6832">    //    and following modifiers</a>
<a name="ln6833">    //</a>
<a name="ln6834">  } else {</a>
<a name="ln6835">    switch (spec_idx) {</a>
<a name="ln6836">    case SPEC_PERC:             // '%': current file</a>
<a name="ln6837">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln6838">        result = &quot;&quot;;</a>
<a name="ln6839">        valid = 0;                  // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6840">      } else {</a>
<a name="ln6841">        result = curbuf-&gt;b_fname;</a>
<a name="ln6842">        tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6843">      }</a>
<a name="ln6844">      break;</a>
<a name="ln6845"> </a>
<a name="ln6846">    case SPEC_HASH:             // '#' or &quot;#99&quot;: alternate file</a>
<a name="ln6847">      if (src[1] == '#') {          // &quot;##&quot;: the argument list</a>
<a name="ln6848">        result = arg_all();</a>
<a name="ln6849">        resultbuf = result;</a>
<a name="ln6850">        *usedlen = 2;</a>
<a name="ln6851">        if (escaped != NULL) {</a>
<a name="ln6852">          *escaped = true;</a>
<a name="ln6853">        }</a>
<a name="ln6854">        skip_mod = true;</a>
<a name="ln6855">        break;</a>
<a name="ln6856">      }</a>
<a name="ln6857">      char *s = src + 1;</a>
<a name="ln6858">      if (*s == '&lt;') {                  // &quot;#&lt;99&quot; uses v:oldfiles.</a>
<a name="ln6859">        s++;</a>
<a name="ln6860">      }</a>
<a name="ln6861">      int i = getdigits_int(&amp;s, false, 0);</a>
<a name="ln6862">      if (s == src + 2 &amp;&amp; src[1] == '-') {</a>
<a name="ln6863">        // just a minus sign, don't skip over it</a>
<a name="ln6864">        s--;</a>
<a name="ln6865">      }</a>
<a name="ln6866">      *usedlen = (size_t)(s - src);           // length of what we expand</a>
<a name="ln6867"> </a>
<a name="ln6868">      if (src[1] == '&lt;' &amp;&amp; i != 0) {</a>
<a name="ln6869">        if (*usedlen &lt; 2) {</a>
<a name="ln6870">          // Should we give an error message for #&lt;text?</a>
<a name="ln6871">          *usedlen = 1;</a>
<a name="ln6872">          return NULL;</a>
<a name="ln6873">        }</a>
<a name="ln6874">        result = (char *)tv_list_find_str(get_vim_var_list(VV_OLDFILES), i - 1);</a>
<a name="ln6875">        if (result == NULL) {</a>
<a name="ln6876">          *errormsg = &quot;&quot;;</a>
<a name="ln6877">          return NULL;</a>
<a name="ln6878">        }</a>
<a name="ln6879">      } else {</a>
<a name="ln6880">        if (i == 0 &amp;&amp; src[1] == '&lt;' &amp;&amp; *usedlen &gt; 1) {</a>
<a name="ln6881">          *usedlen = 1;</a>
<a name="ln6882">        }</a>
<a name="ln6883">        buf_T *buf = buflist_findnr(i);</a>
<a name="ln6884">        if (buf == NULL) {</a>
<a name="ln6885">          *errormsg = _(&quot;E194: No alternate file name to substitute for '#'&quot;);</a>
<a name="ln6886">          return NULL;</a>
<a name="ln6887">        }</a>
<a name="ln6888">        if (lnump != NULL) {</a>
<a name="ln6889">          *lnump = ECMD_LAST;</a>
<a name="ln6890">        }</a>
<a name="ln6891">        if (buf-&gt;b_fname == NULL) {</a>
<a name="ln6892">          result = &quot;&quot;;</a>
<a name="ln6893">          valid = 0;                        // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6894">        } else {</a>
<a name="ln6895">          result = buf-&gt;b_fname;</a>
<a name="ln6896">          tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6897">        }</a>
<a name="ln6898">      }</a>
<a name="ln6899">      break;</a>
<a name="ln6900"> </a>
<a name="ln6901">    case SPEC_CFILE:            // file name under cursor</a>
<a name="ln6902">      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);</a>
<a name="ln6903">      if (result == NULL) {</a>
<a name="ln6904">        *errormsg = &quot;&quot;;</a>
<a name="ln6905">        return NULL;</a>
<a name="ln6906">      }</a>
<a name="ln6907">      resultbuf = result;                   // remember allocated string</a>
<a name="ln6908">      break;</a>
<a name="ln6909"> </a>
<a name="ln6910">    case SPEC_AFILE:  // file name for autocommand</a>
<a name="ln6911">      if (autocmd_fname != NULL &amp;&amp; !autocmd_fname_full) {</a>
<a name="ln6912">        // Still need to turn the fname into a full path.  It was</a>
<a name="ln6913">        // postponed to avoid a delay when &lt;afile&gt; is not used.</a>
<a name="ln6914">        autocmd_fname_full = true;</a>
<a name="ln6915">        result = FullName_save(autocmd_fname, false);</a>
<a name="ln6916">        // Copy into `autocmd_fname`, don't reassign it. #8165</a>
<a name="ln6917">        xstrlcpy(autocmd_fname, result, MAXPATHL);</a>
<a name="ln6918">        xfree(result);</a>
<a name="ln6919">      }</a>
<a name="ln6920">      result = autocmd_fname;</a>
<a name="ln6921">      if (result == NULL) {</a>
<a name="ln6922">        *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);</a>
<a name="ln6923">        return NULL;</a>
<a name="ln6924">      }</a>
<a name="ln6925">      result = path_try_shorten_fname(result);</a>
<a name="ln6926">      break;</a>
<a name="ln6927"> </a>
<a name="ln6928">    case SPEC_ABUF:             // buffer number for autocommand</a>
<a name="ln6929">      if (autocmd_bufnr &lt;= 0) {</a>
<a name="ln6930">        *errormsg = _(e_no_autocommand_buffer_number_to_substitute_for_abuf);</a>
<a name="ln6931">        return NULL;</a>
<a name="ln6932">      }</a>
<a name="ln6933">      snprintf(strbuf, sizeof(strbuf), &quot;%d&quot;, autocmd_bufnr);</a>
<a name="ln6934">      result = strbuf;</a>
<a name="ln6935">      break;</a>
<a name="ln6936"> </a>
<a name="ln6937">    case SPEC_AMATCH:           // match name for autocommand</a>
<a name="ln6938">      result = autocmd_match;</a>
<a name="ln6939">      if (result == NULL) {</a>
<a name="ln6940">        *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);</a>
<a name="ln6941">        return NULL;</a>
<a name="ln6942">      }</a>
<a name="ln6943">      break;</a>
<a name="ln6944"> </a>
<a name="ln6945">    case SPEC_SFILE:            // file name for &quot;:so&quot; command</a>
<a name="ln6946">      result = estack_sfile(ESTACK_SFILE);</a>
<a name="ln6947">      if (result == NULL) {</a>
<a name="ln6948">        *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);</a>
<a name="ln6949">        return NULL;</a>
<a name="ln6950">      }</a>
<a name="ln6951">      resultbuf = result;  // remember allocated string</a>
<a name="ln6952">      break;</a>
<a name="ln6953">    case SPEC_STACK:            // call stack</a>
<a name="ln6954">      result = estack_sfile(ESTACK_STACK);</a>
<a name="ln6955">      if (result == NULL) {</a>
<a name="ln6956">        *errormsg = _(e_no_call_stack_to_substitute_for_stack);</a>
<a name="ln6957">        return NULL;</a>
<a name="ln6958">      }</a>
<a name="ln6959">      resultbuf = result;  // remember allocated string</a>
<a name="ln6960">      break;</a>
<a name="ln6961">    case SPEC_SCRIPT:           // script file name</a>
<a name="ln6962">      result = estack_sfile(ESTACK_SCRIPT);</a>
<a name="ln6963">      if (result == NULL) {</a>
<a name="ln6964">        *errormsg = _(e_no_script_file_name_to_substitute_for_script);</a>
<a name="ln6965">        return NULL;</a>
<a name="ln6966">      }</a>
<a name="ln6967">      resultbuf = result;  // remember allocated string</a>
<a name="ln6968">      break;</a>
<a name="ln6969"> </a>
<a name="ln6970">    case SPEC_SLNUM:            // line in file for &quot;:so&quot; command</a>
<a name="ln6971">      if (SOURCING_NAME == NULL || SOURCING_LNUM == 0) {</a>
<a name="ln6972">        *errormsg = _(e_no_line_number_to_use_for_slnum);</a>
<a name="ln6973">        return NULL;</a>
<a name="ln6974">      }</a>
<a name="ln6975">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR, SOURCING_LNUM);</a>
<a name="ln6976">      result = strbuf;</a>
<a name="ln6977">      break;</a>
<a name="ln6978"> </a>
<a name="ln6979">    case SPEC_SFLNUM:  // line in script file</a>
<a name="ln6980">      if (current_sctx.sc_lnum + SOURCING_LNUM == 0) {</a>
<a name="ln6981">        *errormsg = _(e_no_line_number_to_use_for_sflnum);</a>
<a name="ln6982">        return NULL;</a>
<a name="ln6983">      }</a>
<a name="ln6984">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR,</a>
<a name="ln6985">               current_sctx.sc_lnum + SOURCING_LNUM);</a>
<a name="ln6986">      result = strbuf;</a>
<a name="ln6987">      break;</a>
<a name="ln6988"> </a>
<a name="ln6989">    case SPEC_SID:</a>
<a name="ln6990">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln6991">        *errormsg = _(e_usingsid);</a>
<a name="ln6992">        return NULL;</a>
<a name="ln6993">      }</a>
<a name="ln6994">      snprintf(strbuf, sizeof(strbuf), &quot;&lt;SNR&gt;%&quot; PRIdSCID &quot;_&quot;,</a>
<a name="ln6995">               current_sctx.sc_sid);</a>
<a name="ln6996">      result = strbuf;</a>
<a name="ln6997">      break;</a>
<a name="ln6998"> </a>
<a name="ln6999">    default:</a>
<a name="ln7000">      // should not happen</a>
<a name="ln7001">      *errormsg = &quot;&quot;;</a>
<a name="ln7002">      result = &quot;&quot;;    // avoid gcc warning</a>
<a name="ln7003">      break;</a>
<a name="ln7004">    }</a>
<a name="ln7005"> </a>
<a name="ln7006">    // Length of new string.</a>
<a name="ln7007">    resultlen = strlen(result);</a>
<a name="ln7008">    // Remove the file name extension.</a>
<a name="ln7009">    if (src[*usedlen] == '&lt;') {</a>
<a name="ln7010">      (*usedlen)++;</a>
<a name="ln7011">      char *s;</a>
<a name="ln7012">      if ((s = strrchr(result, '.')) != NULL</a>
<a name="ln7013">          &amp;&amp; s &gt;= path_tail(result)) {</a>
<a name="ln7014">        resultlen = (size_t)(s - result);</a>
<a name="ln7015">      }</a>
<a name="ln7016">    } else if (!skip_mod) {</a>
<a name="ln7017">      valid |= modify_fname(src, tilde_file, usedlen, &amp;result,</a>
<a name="ln7018">                            &amp;resultbuf, &amp;resultlen);</a>
<a name="ln7019">      if (result == NULL) {</a>
<a name="ln7020">        *errormsg = &quot;&quot;;</a>
<a name="ln7021">        return NULL;</a>
<a name="ln7022">      }</a>
<a name="ln7023">    }</a>
<a name="ln7024">  }</a>
<a name="ln7025"> </a>
<a name="ln7026">  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7027">    if (empty_is_error) {</a>
<a name="ln7028">      if (valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7029">        // xgettext:no-c-format</a>
<a name="ln7030">        *errormsg = _(&quot;E499: Empty file name for '%' or '#', only works with \&quot;:p:h\&quot;&quot;);</a>
<a name="ln7031">      } else {</a>
<a name="ln7032">        *errormsg = _(&quot;E500: Evaluates to an empty string&quot;);</a>
<a name="ln7033">      }</a>
<a name="ln7034">    }</a>
<a name="ln7035">    result = NULL;</a>
<a name="ln7036">  } else {</a>
<a name="ln7037">    result = xstrnsave(result, resultlen);</a>
<a name="ln7038">  }</a>
<a name="ln7039">  xfree(resultbuf);</a>
<a name="ln7040">  return result;</a>
<a name="ln7041">}</a>
<a name="ln7042"> </a>
<a name="ln7043">/// Expand the &lt;sfile&gt; string in &quot;arg&quot;.</a>
<a name="ln7044">///</a>
<a name="ln7045">/// @return  an allocated string, or NULL for any error.</a>
<a name="ln7046">char *expand_sfile(char *arg)</a>
<a name="ln7047">{</a>
<a name="ln7048">  char *result = xstrdup(arg);</a>
<a name="ln7049"> </a>
<a name="ln7050">  for (char *p = result; *p;) {</a>
<a name="ln7051">    if (strncmp(p, &quot;&lt;sfile&gt;&quot;, 7) != 0) {</a>
<a name="ln7052">      p++;</a>
<a name="ln7053">    } else {</a>
<a name="ln7054">      // replace &quot;&lt;sfile&gt;&quot; with the sourced file name, and do &quot;:&quot; stuff</a>
<a name="ln7055">      size_t srclen;</a>
<a name="ln7056">      const char *errormsg;</a>
<a name="ln7057">      char *repl = eval_vars(p, result, &amp;srclen, NULL, &amp;errormsg, NULL, true);</a>
<a name="ln7058">      if (errormsg != NULL) {</a>
<a name="ln7059">        if (*errormsg) {</a>
<a name="ln7060">          emsg(errormsg);</a>
<a name="ln7061">        }</a>
<a name="ln7062">        xfree(result);</a>
<a name="ln7063">        return NULL;</a>
<a name="ln7064">      }</a>
<a name="ln7065">      if (repl == NULL) {               // no match (cannot happen)</a>
<a name="ln7066">        p += srclen;</a>
<a name="ln7067">        continue;</a>
<a name="ln7068">      }</a>
<a name="ln7069">      size_t len = strlen(result) - srclen + strlen(repl) + 1;</a>
<a name="ln7070">      char *newres = xmalloc(len);</a>
<a name="ln7071">      memmove(newres, result, (size_t)(p - result));</a>
<a name="ln7072">      STRCPY(newres + (p - result), repl);</a>
<a name="ln7073">      len = strlen(newres);</a>
<a name="ln7074">      STRCAT(newres, p + srclen);</a>
<a name="ln7075">      xfree(repl);</a>
<a name="ln7076">      xfree(result);</a>
<a name="ln7077">      result = newres;</a>
<a name="ln7078">      p = newres + len;                 // continue after the match</a>
<a name="ln7079">    }</a>
<a name="ln7080">  }</a>
<a name="ln7081"> </a>
<a name="ln7082">  return result;</a>
<a name="ln7083">}</a>
<a name="ln7084"> </a>
<a name="ln7085">/// &quot;:rshada&quot; and &quot;:wshada&quot;.</a>
<a name="ln7086">static void ex_shada(exarg_T *eap)</a>
<a name="ln7087">{</a>
<a name="ln7088">  char *save_shada = p_shada;</a>
<a name="ln7089">  if (*p_shada == NUL) {</a>
<a name="ln7090">    p_shada = &quot;'100&quot;;</a>
<a name="ln7091">  }</a>
<a name="ln7092">  if (eap-&gt;cmdidx == CMD_rviminfo || eap-&gt;cmdidx == CMD_rshada) {</a>
<a name="ln7093">    (void)shada_read_everything(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln7094">  } else {</a>
<a name="ln7095">    shada_write_file(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln7096">  }</a>
<a name="ln7097">  p_shada = save_shada;</a>
<a name="ln7098">}</a>
<a name="ln7099"> </a>
<a name="ln7100">/// Make a dialog message in &quot;buff[DIALOG_MSG_SIZE]&quot;.</a>
<a name="ln7101">/// &quot;format&quot; must contain &quot;%s&quot;.</a>
<a name="ln7102">void dialog_msg(char *buff, char *format, char *fname)</a>
<a name="ln7103">{</a>
<a name="ln7104">  if (fname == NULL) {</a>
<a name="ln7105">    fname = _(&quot;Untitled&quot;);</a>
<a name="ln7106">  }</a>
<a name="ln7107">  vim_snprintf(buff, DIALOG_MSG_SIZE, format, fname);</a>
<a name="ln7108">}</a>
<a name="ln7109"> </a>
<a name="ln7110">static TriState filetype_detect = kNone;</a>
<a name="ln7111">static TriState filetype_plugin = kNone;</a>
<a name="ln7112">static TriState filetype_indent = kNone;</a>
<a name="ln7113"> </a>
<a name="ln7114">/// &quot;:filetype [plugin] [indent] {on,off,detect}&quot;</a>
<a name="ln7115">/// on: Load the filetype.vim file to install autocommands for file types.</a>
<a name="ln7116">/// off: Load the ftoff.vim file to remove all autocommands for file types.</a>
<a name="ln7117">/// plugin on: load filetype.vim and ftplugin.vim</a>
<a name="ln7118">/// plugin off: load ftplugof.vim</a>
<a name="ln7119">/// indent on: load filetype.vim and indent.vim</a>
<a name="ln7120">/// indent off: load indoff.vim</a>
<a name="ln7121">static void ex_filetype(exarg_T *eap)</a>
<a name="ln7122">{</a>
<a name="ln7123">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln7124">    // Print current status.</a>
<a name="ln7125">    smsg(0, &quot;filetype detection:%s  plugin:%s  indent:%s&quot;,</a>
<a name="ln7126">         filetype_detect == kTrue ? &quot;ON&quot; : &quot;OFF&quot;,</a>
<a name="ln7127">         filetype_plugin == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;,</a>
<a name="ln7128">         filetype_indent == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;);</a>
<a name="ln7129">    return;</a>
<a name="ln7130">  }</a>
<a name="ln7131"> </a>
<a name="ln7132">  char *arg = eap-&gt;arg;</a>
<a name="ln7133">  bool plugin = false;</a>
<a name="ln7134">  bool indent = false;</a>
<a name="ln7135"> </a>
<a name="ln7136">  // Accept &quot;plugin&quot; and &quot;indent&quot; in any order.</a>
<a name="ln7137">  while (true) {</a>
<a name="ln7138">    if (strncmp(arg, &quot;plugin&quot;, 6) == 0) {</a>
<a name="ln7139">      plugin = true;</a>
<a name="ln7140">      arg = skipwhite(arg + 6);</a>
<a name="ln7141">      continue;</a>
<a name="ln7142">    }</a>
<a name="ln7143">    if (strncmp(arg, &quot;indent&quot;, 6) == 0) {</a>
<a name="ln7144">      indent = true;</a>
<a name="ln7145">      arg = skipwhite(arg + 6);</a>
<a name="ln7146">      continue;</a>
<a name="ln7147">    }</a>
<a name="ln7148">    break;</a>
<a name="ln7149">  }</a>
<a name="ln7150">  if (strcmp(arg, &quot;on&quot;) == 0 || strcmp(arg, &quot;detect&quot;) == 0) {</a>
<a name="ln7151">    if (*arg == 'o' || !filetype_detect) {</a>
<a name="ln7152">      source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7153">      filetype_detect = kTrue;</a>
<a name="ln7154">      if (plugin) {</a>
<a name="ln7155">        source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7156">        filetype_plugin = kTrue;</a>
<a name="ln7157">      }</a>
<a name="ln7158">      if (indent) {</a>
<a name="ln7159">        source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7160">        filetype_indent = kTrue;</a>
<a name="ln7161">      }</a>
<a name="ln7162">    }</a>
<a name="ln7163">    if (*arg == 'd') {</a>
<a name="ln7164">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln7165">      do_modelines(0);</a>
<a name="ln7166">    }</a>
<a name="ln7167">  } else if (strcmp(arg, &quot;off&quot;) == 0) {</a>
<a name="ln7168">    if (plugin || indent) {</a>
<a name="ln7169">      if (plugin) {</a>
<a name="ln7170">        source_runtime(FTPLUGOF_FILE, DIP_ALL);</a>
<a name="ln7171">        filetype_plugin = kFalse;</a>
<a name="ln7172">      }</a>
<a name="ln7173">      if (indent) {</a>
<a name="ln7174">        source_runtime(INDOFF_FILE, DIP_ALL);</a>
<a name="ln7175">        filetype_indent = kFalse;</a>
<a name="ln7176">      }</a>
<a name="ln7177">    } else {</a>
<a name="ln7178">      source_runtime(FTOFF_FILE, DIP_ALL);</a>
<a name="ln7179">      filetype_detect = kFalse;</a>
<a name="ln7180">    }</a>
<a name="ln7181">  } else {</a>
<a name="ln7182">    semsg(_(e_invarg2), arg);</a>
<a name="ln7183">  }</a>
<a name="ln7184">}</a>
<a name="ln7185"> </a>
<a name="ln7186">/// Source ftplugin.vim and indent.vim to create the necessary FileType</a>
<a name="ln7187">/// autocommands. We do this separately from filetype.vim so that these</a>
<a name="ln7188">/// autocommands will always fire first (and thus can be overridden) while still</a>
<a name="ln7189">/// allowing general filetype detection to be disabled in the user's init file.</a>
<a name="ln7190">void filetype_plugin_enable(void)</a>
<a name="ln7191">{</a>
<a name="ln7192">  if (filetype_plugin == kNone) {</a>
<a name="ln7193">    source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7194">    filetype_plugin = kTrue;</a>
<a name="ln7195">  }</a>
<a name="ln7196">  if (filetype_indent == kNone) {</a>
<a name="ln7197">    source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7198">    filetype_indent = kTrue;</a>
<a name="ln7199">  }</a>
<a name="ln7200">}</a>
<a name="ln7201"> </a>
<a name="ln7202">/// Enable filetype detection if the user did not explicitly disable it.</a>
<a name="ln7203">void filetype_maybe_enable(void)</a>
<a name="ln7204">{</a>
<a name="ln7205">  if (filetype_detect == kNone) {</a>
<a name="ln7206">    // Normally .vim files are sourced before .lua files when both are</a>
<a name="ln7207">    // supported, but we reverse the order here because we want the Lua</a>
<a name="ln7208">    // autocommand to be defined first so that it runs first</a>
<a name="ln7209">    source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7210">    filetype_detect = kTrue;</a>
<a name="ln7211">  }</a>
<a name="ln7212">}</a>
<a name="ln7213"> </a>
<a name="ln7214">/// &quot;:setfiletype [FALLBACK] {name}&quot;</a>
<a name="ln7215">static void ex_setfiletype(exarg_T *eap)</a>
<a name="ln7216">{</a>
<a name="ln7217">  if (did_filetype) {</a>
<a name="ln7218">    return;</a>
<a name="ln7219">  }</a>
<a name="ln7220"> </a>
<a name="ln7221">  char *arg = eap-&gt;arg;</a>
<a name="ln7222">  if (strncmp(arg, &quot;FALLBACK &quot;, 9) == 0) {</a>
<a name="ln7223">    arg += 9;</a>
<a name="ln7224">  }</a>
<a name="ln7225"> </a>
<a name="ln7226">  set_option_value_give_err(&quot;filetype&quot;, CSTR_AS_OPTVAL(arg), OPT_LOCAL);</a>
<a name="ln7227">  if (arg != eap-&gt;arg) {</a>
<a name="ln7228">    did_filetype = false;</a>
<a name="ln7229">  }</a>
<a name="ln7230">}</a>
<a name="ln7231"> </a>
<a name="ln7232">static void ex_digraphs(exarg_T *eap)</a>
<a name="ln7233">{</a>
<a name="ln7234">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln7235">    putdigraph(eap-&gt;arg);</a>
<a name="ln7236">  } else {</a>
<a name="ln7237">    listdigraphs(eap-&gt;forceit);</a>
<a name="ln7238">  }</a>
<a name="ln7239">}</a>
<a name="ln7240"> </a>
<a name="ln7241">void set_no_hlsearch(bool flag)</a>
<a name="ln7242">{</a>
<a name="ln7243">  no_hlsearch = flag;</a>
<a name="ln7244">  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch &amp;&amp; p_hls);</a>
<a name="ln7245">}</a>
<a name="ln7246"> </a>
<a name="ln7247">/// &quot;:nohlsearch&quot;</a>
<a name="ln7248">static void ex_nohlsearch(exarg_T *eap)</a>
<a name="ln7249">{</a>
<a name="ln7250">  set_no_hlsearch(true);</a>
<a name="ln7251">  redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln7252">}</a>
<a name="ln7253"> </a>
<a name="ln7254">static void ex_fold(exarg_T *eap)</a>
<a name="ln7255">{</a>
<a name="ln7256">  if (foldManualAllowed(true)) {</a>
<a name="ln7257">    pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7258">    pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7259">    foldCreate(curwin, start, end);</a>
<a name="ln7260">  }</a>
<a name="ln7261">}</a>
<a name="ln7262"> </a>
<a name="ln7263">static void ex_foldopen(exarg_T *eap)</a>
<a name="ln7264">{</a>
<a name="ln7265">  pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7266">  pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7267">  opFoldRange(start, end, eap-&gt;cmdidx == CMD_foldopen, eap-&gt;forceit, false);</a>
<a name="ln7268">}</a>
<a name="ln7269"> </a>
<a name="ln7270">static void ex_folddo(exarg_T *eap)</a>
<a name="ln7271">{</a>
<a name="ln7272">  // First set the marks for all lines closed/open.</a>
<a name="ln7273">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln7274">    if (hasFolding(lnum, NULL, NULL) == (eap-&gt;cmdidx == CMD_folddoclosed)) {</a>
<a name="ln7275">      ml_setmarked(lnum);</a>
<a name="ln7276">    }</a>
<a name="ln7277">  }</a>
<a name="ln7278"> </a>
<a name="ln7279">  global_exe(eap-&gt;arg);  // Execute the command on the marked lines.</a>
<a name="ln7280">  ml_clearmarked();      // clear rest of the marks</a>
<a name="ln7281">}</a>
<a name="ln7282"> </a>
<a name="ln7283">/// @return  true if the supplied Ex cmdidx is for a location list command</a>
<a name="ln7284">///          instead of a quickfix command.</a>
<a name="ln7285">bool is_loclist_cmd(int cmdidx)</a>
<a name="ln7286">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7287">{</a>
<a name="ln7288">  if (cmdidx &lt; 0 || cmdidx &gt;= CMD_SIZE) {</a>
<a name="ln7289">    return false;</a>
<a name="ln7290">  }</a>
<a name="ln7291">  return cmdnames[cmdidx].cmd_name[0] == 'l';</a>
<a name="ln7292">}</a>
<a name="ln7293"> </a>
<a name="ln7294">bool get_pressedreturn(void)</a>
<a name="ln7295">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7296">{</a>
<a name="ln7297">  return ex_pressedreturn;</a>
<a name="ln7298">}</a>
<a name="ln7299"> </a>
<a name="ln7300">void set_pressedreturn(bool val)</a>
<a name="ln7301">{</a>
<a name="ln7302">  ex_pressedreturn = val;</a>
<a name="ln7303">}</a>
<a name="ln7304"> </a>
<a name="ln7305">static void ex_terminal(exarg_T *eap)</a>
<a name="ln7306">{</a>
<a name="ln7307">  char ex_cmd[1024];</a>
<a name="ln7308">  size_t len = 0;</a>
<a name="ln7309"> </a>
<a name="ln7310">  if (cmdmod.cmod_tab &gt; 0 || cmdmod.cmod_split != 0) {</a>
<a name="ln7311">    bool multi_mods = false;</a>
<a name="ln7312"> </a>
<a name="ln7313">    // ex_cmd must be a null terminated string before passing to add_win_cmd_modifiers</a>
<a name="ln7314">    ex_cmd[0] = '\0';</a>
<a name="ln7315"> </a>
<a name="ln7316">    len = add_win_cmd_modifiers(ex_cmd, &amp;cmdmod, &amp;multi_mods);</a>
<a name="ln7317">    assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7318">    int result = snprintf(ex_cmd + len, sizeof(ex_cmd) - len, &quot; new&quot;);</a>
<a name="ln7319">    assert(result &gt; 0);</a>
<a name="ln7320">    len += (size_t)result;</a>
<a name="ln7321">  } else {</a>
<a name="ln7322">    int result = snprintf(ex_cmd, sizeof(ex_cmd), &quot;enew%s&quot;, eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;);</a>
<a name="ln7323">    assert(result &gt; 0);</a>
<a name="ln7324">    len += (size_t)result;</a>
<a name="ln7325">  }</a>
<a name="ln7326"> </a>
<a name="ln7327">  assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7328"> </a>
<a name="ln7329">  if (*eap-&gt;arg != NUL) {  // Run {cmd} in 'shell'.</a>
<a name="ln7330">    char *name = vim_strsave_escaped(eap-&gt;arg, &quot;\&quot;\\&quot;);</a>
<a name="ln7331">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7332">             &quot; | call termopen(\&quot;%s\&quot;)&quot;, name);</a>
<a name="ln7333">    xfree(name);</a>
<a name="ln7334">  } else {  // No {cmd}: run the job with tokenized 'shell'.</a>
<a name="ln7335">    if (*p_sh == NUL) {</a>
<a name="ln7336">      emsg(_(e_shellempty));</a>
<a name="ln7337">      return;</a>
<a name="ln7338">    }</a>
<a name="ln7339"> </a>
<a name="ln7340">    char **argv = shell_build_argv(NULL, NULL);</a>
<a name="ln7341">    char **p = argv;</a>
<a name="ln7342">    char tempstring[512];</a>
<a name="ln7343">    char shell_argv[512] = { 0 };</a>
<a name="ln7344"> </a>
<a name="ln7345">    while (*p != NULL) {</a>
<a name="ln7346">      snprintf(tempstring, sizeof(tempstring), &quot;,\&quot;%s\&quot;&quot;, *p);</a>
<a name="ln7347">      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));</a>
<a name="ln7348">      p++;</a>
<a name="ln7349">    }</a>
<a name="ln7350">    shell_free_argv(argv);</a>
<a name="ln7351"> </a>
<a name="ln7352">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7353">             &quot; | call termopen([%s])&quot;, shell_argv + 1);</a>
<a name="ln7354">  }</a>
<a name="ln7355"> </a>
<a name="ln7356">  do_cmdline_cmd(ex_cmd);</a>
<a name="ln7357">}</a>
<a name="ln7358"> </a>
<a name="ln7359">void verify_command(char *cmd)</a>
<a name="ln7360">{</a>
<a name="ln7361">  if (strcmp(&quot;smile&quot;, cmd) != 0) {</a>
<a name="ln7362">    return;  // acceptable non-existing command</a>
<a name="ln7363">  }</a>
<a name="ln7364">  int a = HL_ATTR(HLF_E);</a>
<a name="ln7365">  msg(&quot; #xxn`          #xnxx`        ,+x@##@Mz;`        .xxx&quot;</a>
<a name="ln7366">      &quot;xxxxxxnz+,      znnnnnnnnnnnnnnnn.&quot;, a);</a>
<a name="ln7367">  msg(&quot; n###z          x####`      :x##########W+`      ,###&quot;</a>
<a name="ln7368">      &quot;##########M;    W################.&quot;, a);</a>
<a name="ln7369">  msg(&quot; n####;         x####`    `z##############W:     ,###&quot;</a>
<a name="ln7370">      &quot;#############   W################.&quot;, a);</a>
<a name="ln7371">  msg(&quot; n####W.        x####`   ,W#################+    ,###&quot;</a>
<a name="ln7372">      &quot;##############  W################.&quot;, a);</a>
<a name="ln7373">  msg(&quot; n#####n        x####`   @###################    ,###&quot;</a>
<a name="ln7374">      &quot;##############i W################.&quot;, a);</a>
<a name="ln7375">  msg(&quot; n######i       x####`  .#########@W@########*   ,###&quot;</a>
<a name="ln7376">      &quot;##############W`W################.&quot;, a);</a>
<a name="ln7377">  msg(&quot; n######@.      x####`  x######W*.  `;n#######:  ,###&quot;</a>
<a name="ln7378">      &quot;#x,,,,:*M######iW###@:,,,,,,,,,,,`&quot;, a);</a>
<a name="ln7379">  msg(&quot; n#######n      x####` *######+`       :M#####M  ,###&quot;</a>
<a name="ln7380">      &quot;#n      `x#####xW###@`&quot;, a);</a>
<a name="ln7381">  msg(&quot; n########*     x####``@####@;          `x#####i ,###&quot;</a>
<a name="ln7382">      &quot;#n       ,#####@W###@`&quot;, a);</a>
<a name="ln7383">  msg(&quot; n########@     x####`*#####i            `M####M ,###&quot;</a>
<a name="ln7384">      &quot;#n        x#########@`&quot;, a);</a>
<a name="ln7385">  msg(&quot; n#########     x####`M####z              :#####:,###&quot;</a>
<a name="ln7386">      &quot;#n        z#########@`&quot;, a);</a>
<a name="ln7387">  msg(&quot; n#########*    x####,#####.               n####+,###&quot;</a>
<a name="ln7388">      &quot;#n        n#########@`&quot;, a);</a>
<a name="ln7389">  msg(&quot; n####@####@,   x####i####x                ;####x,###&quot;</a>
<a name="ln7390">      &quot;#n       `W#####@####+++++++++++i&quot;, a);</a>
<a name="ln7391">  msg(&quot; n####*#####M`  x#########*                `####@,###&quot;</a>
<a name="ln7392">      &quot;#n       i#####MW###############W&quot;, a);</a>
<a name="ln7393">  msg(&quot; n####.######+  x####z####;                 W####,###&quot;</a>
<a name="ln7394">      &quot;#n      i@######W###############W&quot;, a);</a>
<a name="ln7395">  msg(&quot; n####.`W#####: x####n####:                 M####:###&quot;</a>
<a name="ln7396">      &quot;#@nnnnnW#######,W###############W&quot;, a);</a>
<a name="ln7397">  msg(&quot; n####. :#####M`x####z####;                 W####,###&quot;</a>
<a name="ln7398">      &quot;##############z W###############W&quot;, a);</a>
<a name="ln7399">  msg(&quot; n####.  #######x#########*                `####W,###&quot;</a>
<a name="ln7400">      &quot;#############W` W###############W&quot;, a);</a>
<a name="ln7401">  msg(&quot; n####.  `M#####W####i####x                ;####x,###&quot;</a>
<a name="ln7402">      &quot;############W,  W####+**********i&quot;, a);</a>
<a name="ln7403">  msg(&quot; n####.   ,##########,#####.               n####+,###&quot;</a>
<a name="ln7404">      &quot;###########n.   W###@`&quot;, a);</a>
<a name="ln7405">  msg(&quot; n####.    ##########`M####z              :#####:,###&quot;</a>
<a name="ln7406">      &quot;########Wz:     W###@`&quot;, a);</a>
<a name="ln7407">  msg(&quot; n####.    x#########`*#####i            `M####M ,###&quot;</a>
<a name="ln7408">      &quot;#x.....`        W###@`&quot;, a);</a>
<a name="ln7409">  msg(&quot; n####.    ,@########``@####@;          `x#####i ,###&quot;</a>
<a name="ln7410">      &quot;#n              W###@`&quot;, a);</a>
<a name="ln7411">  msg(&quot; n####.     *########` *#####@+`       ,M#####M  ,###&quot;</a>
<a name="ln7412">      &quot;#n              W###@`&quot;, a);</a>
<a name="ln7413">  msg(&quot; n####.      x#######`  x######W*.  `;n######@:  ,###&quot;</a>
<a name="ln7414">      &quot;#n              W###@,,,,,,,,,,,,`&quot;, a);</a>
<a name="ln7415">  msg(&quot; n####.      .@######`  .#########@W@########*   ,###&quot;</a>
<a name="ln7416">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7417">  msg(&quot; n####.       i######`   @###################    ,###&quot;</a>
<a name="ln7418">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7419">  msg(&quot; n####.        n#####`   ,W#################+    ,###&quot;</a>
<a name="ln7420">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7421">  msg(&quot; n####.        .@####`    .n##############W;     ,###&quot;</a>
<a name="ln7422">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7423">  msg(&quot; n####.         i####`      :x##########W+`      ,###&quot;</a>
<a name="ln7424">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7425">  msg(&quot; +nnnn`          +nnn`        ,+x@##@Mz;`        .nnn&quot;</a>
<a name="ln7426">      &quot;n+              zxxxxxxxxxxxxxxxx.&quot;, a);</a>
<a name="ln7427">  msg(&quot; &quot;, a);</a>
<a name="ln7428">  msg(&quot;                                                     &quot;</a>
<a name="ln7429">      &quot;                              ,+M@#Mi&quot;, a);</a>
<a name="ln7430">  msg(&quot;                                 &quot;</a>
<a name="ln7431">      &quot;                                                .z########&quot;, a);</a>
<a name="ln7432">  msg(&quot;                                 &quot;</a>
<a name="ln7433">      &quot;                                               i@#########i&quot;, a);</a>
<a name="ln7434">  msg(&quot;                                 &quot;</a>
<a name="ln7435">      &quot;                                             `############W`&quot;, a);</a>
<a name="ln7436">  msg(&quot;                                 &quot;</a>
<a name="ln7437">      &quot;                                            `n#############i&quot;, a);</a>
<a name="ln7438">  msg(&quot;                                 &quot;</a>
<a name="ln7439">      &quot;                                           `n##############n&quot;, a);</a>
<a name="ln7440">  msg(&quot;     ``                          &quot;</a>
<a name="ln7441">      &quot;                                           z###############@`&quot;, a);</a>
<a name="ln7442">  msg(&quot;    `W@z,                        &quot;</a>
<a name="ln7443">      &quot;                                          ##################,&quot;, a);</a>
<a name="ln7444">  msg(&quot;    *#####`                      &quot;</a>
<a name="ln7445">      &quot;                                         i############@x@###i&quot;, a);</a>
<a name="ln7446">  msg(&quot;    ######M.                     &quot;</a>
<a name="ln7447">      &quot;                                        :#############n`,W##+&quot;, a);</a>
<a name="ln7448">  msg(&quot;    +######@:                    &quot;</a>
<a name="ln7449">      &quot;                                       .W#########M@##+  *##z&quot;, a);</a>
<a name="ln7450">  msg(&quot;    :#######@:                   &quot;</a>
<a name="ln7451">      &quot;                                      `x########@#x###*  ,##n&quot;, a);</a>
<a name="ln7452">  msg(&quot;    `@#######@;                  &quot;</a>
<a name="ln7453">      &quot;                                      z#########M*@nW#i  .##x&quot;, a);</a>
<a name="ln7454">  msg(&quot;     z########@i                 &quot;</a>
<a name="ln7455">      &quot;                                     *###########WM#@#,  `##x&quot;, a);</a>
<a name="ln7456">  msg(&quot;     i##########+                &quot;</a>
<a name="ln7457">      &quot;                                    ;###########*n###@   `##x&quot;, a);</a>
<a name="ln7458">  msg(&quot;     `@#MM#######x,              &quot;</a>
<a name="ln7459">      &quot;                                   ,@#########zM,`z##M   `@#x&quot;, a);</a>
<a name="ln7460">  msg(&quot;      n##M#W#######n.            &quot;</a>
<a name="ln7461">      &quot;   `.:i*+#zzzz##+i:.`             ,W#########Wii,`n@#@` n@##n&quot;, a);</a>
<a name="ln7462">  msg(&quot;      ;###@#x#######n         `,i&quot;</a>
<a name="ln7463">      &quot;#nW@#####@@WWW@@####@Mzi.        ,W##########@z.. ;zM#+i####z&quot;, a);</a>
<a name="ln7464">  msg(&quot;       x####nz########    .;#x@##&quot;</a>
<a name="ln7465">      &quot;@Wn#*;,.`      ``,:*#x@##M+,    ;@########xz@WM+#` `n@#######&quot;, a);</a>
<a name="ln7466">  msg(&quot;       ,@####M########xi#@##@Mzi,&quot;</a>
<a name="ln7467">      &quot;`                     .+x###Mi:n##########Mz```.:i  *@######*&quot;, a);</a>
<a name="ln7468">  msg(&quot;        *#####W#########ix+:`    &quot;</a>
<a name="ln7469">      &quot;                         :n#############z:       `*.`M######i&quot;, a);</a>
<a name="ln7470">  msg(&quot;        i#W##nW@+@##@#M@;        &quot;</a>
<a name="ln7471">      &quot;                           ;W@@##########W,        i`x@#####,&quot;, a);</a>
<a name="ln7472">  msg(&quot;        `@@n@Wn#@iMW*#*:         &quot;</a>
<a name="ln7473">      &quot;                            `iz#z@######x.           M######`&quot;, a);</a>
<a name="ln7474">  msg(&quot;         z##zM###x`*, .`         &quot;</a>
<a name="ln7475">      &quot;                                 `iW#####W;:`        +#####M&quot;, a);</a>
<a name="ln7476">  msg(&quot;         ,###nn##n`              &quot;</a>
<a name="ln7477">      &quot;                                  ,#####x;`        ,;@######&quot;, a);</a>
<a name="ln7478">  msg(&quot;          x###xz#.               &quot;</a>
<a name="ln7479">      &quot;                                    in###+        `:######@.&quot;, a);</a>
<a name="ln7480">  msg(&quot;          ;####n+                &quot;</a>
<a name="ln7481">      &quot;                                    `Mnx##xi`   , zM#######&quot;, a);</a>
<a name="ln7482">  msg(&quot;          `W####+                &quot;</a>
<a name="ln7483">      &quot;i.                                   `.+x###@#. :n,z######:&quot;, a);</a>
<a name="ln7484">  msg(&quot;           z####@`              ;&quot;</a>
<a name="ln7485">      &quot;#:                                     .ii@###@;.*M*z####@`&quot;, a);</a>
<a name="ln7486">  msg(&quot;           i####M         `   `i@&quot;</a>
<a name="ln7487">      &quot;#,           ::                           +#n##@+@##W####n&quot;, a);</a>
<a name="ln7488">  msg(&quot;           :####x    ,i. ##xzM###&quot;</a>
<a name="ln7489">      &quot;@`     i.   .@@,                           .z####x#######*&quot;, a);</a>
<a name="ln7490">  msg(&quot;           ,###W;   i##Wz########&quot;</a>
<a name="ln7491">      &quot;#     :##   z##n                           ,@########x###:&quot;, a);</a>
<a name="ln7492">  msg(&quot;            n##n   `W###########M&quot;</a>
<a name="ln7493">      &quot;`;n,  i#x  ,###@i                           *W########W#@`&quot;, a);</a>
<a name="ln7494">  msg(&quot;           .@##+  `x###########@.&quot;</a>
<a name="ln7495">      &quot; z#+ .M#W``x#####n`                         `;#######@z#x&quot;, a);</a>
<a name="ln7496">  msg(&quot;           n###z :W############@ &quot;</a>
<a name="ln7497">      &quot; z#*  @##xM#######@n;                        `########nW+&quot;, a);</a>
<a name="ln7498">  msg(&quot;          ;####nW##############W &quot;</a>
<a name="ln7499">      &quot;:@#* `@#############*                        :########z@i`&quot;, a);</a>
<a name="ln7500">  msg(&quot;          M##################### &quot;</a>
<a name="ln7501">      &quot;M##:  @#############@:                       *W########M#&quot;, a);</a>
<a name="ln7502">  msg(&quot;         ;#####################i.&quot;</a>
<a name="ln7503">      &quot;##x`  W#############W,                       :n########zx&quot;, a);</a>
<a name="ln7504">  msg(&quot;         x####################@.`&quot;</a>
<a name="ln7505">      &quot;x;    @#############z.                       .@########W#&quot;, a);</a>
<a name="ln7506">  msg(&quot;        ,######################` &quot;</a>
<a name="ln7507">      &quot;      W###############x*,`                    W######zM#i&quot;, a);</a>
<a name="ln7508">  msg(&quot;        #######################: &quot;</a>
<a name="ln7509">      &quot;      z##################@x+*#zzi            `@#########.&quot;, a);</a>
<a name="ln7510">  msg(&quot;        W########W#z#M#########; &quot;</a>
<a name="ln7511">      &quot;      *##########################z            :@#######@`&quot;, a);</a>
<a name="ln7512">  msg(&quot;       `@#######x`;#z ,x#######; &quot;</a>
<a name="ln7513">      &quot;      z###########M###xnM@########*            :M######@&quot;, a);</a>
<a name="ln7514">  msg(&quot;       i########, x#@`  z######; &quot;</a>
<a name="ln7515">      &quot;      *##########i *#@`  `+########+`            n######.&quot;, a);</a>
<a name="ln7516">  msg(&quot;       n#######@` M##,  `W#####. &quot;</a>
<a name="ln7517">      &quot;      *#########z  ###;    z########M:           :W####n&quot;, a);</a>
<a name="ln7518">  msg(&quot;       M#######M  n##.   x####x  &quot;</a>
<a name="ln7519">      &quot;      `x########:  z##+    M#########@;           .n###+&quot;, a);</a>
<a name="ln7520">  msg(&quot;       W#######@` :#W   `@####:  &quot;</a>
<a name="ln7521">      &quot;       `@######W   i###   ;###########@.            n##n&quot;, a);</a>
<a name="ln7522">  msg(&quot;       W########z` ,,  .x####z   &quot;</a>
<a name="ln7523">      &quot;        @######@`  `W#;  `W############*            *###;&quot;, a);</a>
<a name="ln7524">  msg(&quot;      `@#########Mi,:*n@####W`   &quot;</a>
<a name="ln7525">      &quot;        W#######*   ..  `n#############i            i###x&quot;, a);</a>
<a name="ln7526">  msg(&quot;      .#####################z    &quot;</a>
<a name="ln7527">      &quot;       `@#######@*`    .x############n:`            ;####.&quot;, a);</a>
<a name="ln7528">  msg(&quot;      :####################x`,,` &quot;</a>
<a name="ln7529">      &quot;       `W#########@x#+#@#############i              ,####:&quot;, a);</a>
<a name="ln7530">  msg(&quot;      ;###################x#@###x&quot;</a>
<a name="ln7531">      &quot;i`      *############################:              `####i&quot;, a);</a>
<a name="ln7532">  msg(&quot;      i##################+#######&quot;</a>
<a name="ln7533">      &quot;#M,      x##########################@`               W###i&quot;, a);</a>
<a name="ln7534">  msg(&quot;      *################@; @######&quot;</a>
<a name="ln7535">      &quot;##@,     .W#########################@                x###:&quot;, a);</a>
<a name="ln7536">  msg(&quot;      .+M#############z.  M######&quot;</a>
<a name="ln7537">      &quot;###x      ,W########################@`               ####.&quot;, a);</a>
<a name="ln7538">  msg(&quot;      *M*;z@########x:    :W#####&quot;</a>
<a name="ln7539">      &quot;##i        .M########################i               i###:&quot;, a);</a>
<a name="ln7540">  msg(&quot;      *##@z;#@####x:        :z###&quot;</a>
<a name="ln7541">      &quot;@i          `########################x               .###;&quot;, a);</a>
<a name="ln7542">  msg(&quot;      *#####n;#@##            ;##&quot;</a>
<a name="ln7543">      &quot;*             ,x#####################@`               W##*&quot;, a);</a>
<a name="ln7544">  msg(&quot;      *#######n;*            :M##&quot;</a>
<a name="ln7545">      &quot;W*,             *W####################`               n##z&quot;, a);</a>
<a name="ln7546">  msg(&quot;      i########@.         ,*n####&quot;</a>
<a name="ln7547">      &quot;###M*`           `###################M                *##M&quot;, a);</a>
<a name="ln7548">  msg(&quot;      i########n        `z#####@@&quot;</a>
<a name="ln7549">      &quot;#####Wi            ,M################;                ,##@`&quot;, a);</a>
<a name="ln7550">  msg(&quot;      ;WMWW@###*       .x##@ni.``&quot;</a>
<a name="ln7551">      &quot;.:+zW##z`           `n##############z                  @##,&quot;, a);</a>
<a name="ln7552">  msg(&quot;      .*++*i;;;.      .M#@+`     &quot;</a>
<a name="ln7553">      &quot;     .##n            `x############x`                  n##i&quot;, a);</a>
<a name="ln7554">  msg(&quot;      :########*      x#W,       &quot;</a>
<a name="ln7555">      &quot;       *#+            *###########M`                   +##+&quot;, a);</a>
<a name="ln7556">  msg(&quot;      ,#########     :#@:        &quot;</a>
<a name="ln7557">      &quot;        ##:           #nzzzzzzzzzz.                    :##x&quot;, a);</a>
<a name="ln7558">  msg(&quot;      .#####Wz+`     ##+         &quot;</a>
<a name="ln7559">      &quot;        `MM`          .znnnnnnnnn.                     `@#@`&quot;, a);</a>
<a name="ln7560">  msg(&quot;      `@@ni;*nMz`    @W`         &quot;</a>
<a name="ln7561">      &quot;         :#+           .x#######n                       x##,&quot;, a);</a>
<a name="ln7562">  msg(&quot;       i;z@#####,   .#*          &quot;</a>
<a name="ln7563">      &quot;          z#:           ;;;*zW##;                       ###i&quot;, a);</a>
<a name="ln7564">  msg(&quot;       z########:   :#;          &quot;</a>
<a name="ln7565">      &quot;          `Wx          +###Wni;n.                       ;##z&quot;, a);</a>
<a name="ln7566">  msg(&quot;       n########W:  .#*          &quot;</a>
<a name="ln7567">      &quot;           ,#,        ;#######@+                        `@#M&quot;, a);</a>
<a name="ln7568">  msg(&quot;      .###########n;.MM          &quot;</a>
<a name="ln7569">      &quot;            n*        ;iM#######*                        x#@`&quot;, a);</a>
<a name="ln7570">  msg(&quot;      :#############@;;          &quot;</a>
<a name="ln7571">      &quot;            .n`      ,#W*iW#####W`                       +##,&quot;, a);</a>
<a name="ln7572">  msg(&quot;      ,##############.           &quot;</a>
<a name="ln7573">      &quot;             ix.    `x###M;#######                       ,##i&quot;, a);</a>
<a name="ln7574">  msg(&quot;      .#############@`           &quot;</a>
<a name="ln7575">      &quot;              x@n**#W######z;M###@.                       W##&quot;, a);</a>
<a name="ln7576">  msg(&quot;      .##############W:          &quot;</a>
<a name="ln7577">      &quot;              .x############@*;zW#;                       z#x&quot;, a);</a>
<a name="ln7578">  msg(&quot;      ,###############@;         &quot;</a>
<a name="ln7579">      &quot;               `##############@n*;.                       i#@&quot;, a);</a>
<a name="ln7580">  msg(&quot;      ,#################i        &quot;</a>
<a name="ln7581">      &quot;                 :n##############W`                       .##,&quot;, a);</a>
<a name="ln7582">  msg(&quot;      ,###################`      &quot;</a>
<a name="ln7583">      &quot;                   .+W##########W,                        `##i&quot;, a);</a>
<a name="ln7584">  msg(&quot;      :###################@zi,`  &quot;</a>
<a name="ln7585">      &quot;                      ;zM@@@WMn*`                          @#z&quot;, a);</a>
<a name="ln7586">  msg(&quot;      :#######################@x+&quot;</a>
<a name="ln7587">      &quot;*i;;:i#M,                 ``                               M#W&quot;, a);</a>
<a name="ln7588">  msg(&quot;      ;##########################&quot;</a>
<a name="ln7589">      &quot;######@x.                                                  n##,&quot;, a);</a>
<a name="ln7590">  msg(&quot;      i#####################@W@@@&quot;</a>
<a name="ln7591">      &quot;@Wxz*:`                                                    *##+&quot;, a);</a>
<a name="ln7592">  msg(&quot;      *######################+```&quot;</a>
<a name="ln7593">      &quot;                                                           :##M&quot;, a);</a>
<a name="ln7594">  msg(&quot;      ########################M; &quot;</a>
<a name="ln7595">      &quot;                                                           `@##,&quot;, a);</a>
<a name="ln7596">  msg(&quot;      z#########################x&quot;</a>
<a name="ln7597">      &quot;,                                                           z###&quot;, a);</a>
<a name="ln7598">  msg(&quot;      n##########################&quot;</a>
<a name="ln7599">      &quot;#n:                                                         ;##W`&quot;, a);</a>
<a name="ln7600">  msg(&quot;      x##########################&quot;</a>
<a name="ln7601">      &quot;###Mz#++##*                                                 `W##i&quot;, a);</a>
<a name="ln7602">  msg(&quot;      M##########################&quot;</a>
<a name="ln7603">      &quot;##########@`                                                 ###x&quot;, a);</a>
<a name="ln7604">  msg(&quot;      W##########################&quot;</a>
<a name="ln7605">      &quot;###########`                                                 .###,&quot;, a);</a>
<a name="ln7606">  msg(&quot;      @##########################&quot;</a>
<a name="ln7607">      &quot;##########M                                                   n##z&quot;, a);</a>
<a name="ln7608">  msg(&quot;      @##################z*i@WMMM&quot;</a>
<a name="ln7609">      &quot;x#x@#####,.                                                   :##@.&quot;, a);</a>
<a name="ln7610">  msg(&quot;     `#####################@xi`  &quot;</a>
<a name="ln7611">      &quot;   `::,*                                                       x##+&quot;, a);</a>
<a name="ln7612">  msg(&quot;     .#####################@#M.  &quot;</a>
<a name="ln7613">      &quot;                                                               ;##@`&quot;, a);</a>
<a name="ln7614">  msg(&quot;     ,#####################:.    &quot;</a>
<a name="ln7615">      &quot;                                                                M##i&quot;, a);</a>
<a name="ln7616">  msg(&quot;     ;###################ni`     &quot;</a>
<a name="ln7617">      &quot;                                                                i##M&quot;, a);</a>
<a name="ln7618">  msg(&quot;     *#################W#`       &quot;</a>
<a name="ln7619">      &quot;                                                                `W##,&quot;, a);</a>
<a name="ln7620">  msg(&quot;     z#################@Wx+.     &quot;</a>
<a name="ln7621">      &quot;                                                                 +###&quot;, a);</a>
<a name="ln7622">  msg(&quot;     x######################z.   &quot;</a>
<a name="ln7623">      &quot;                                                                 .@#@`&quot;, a);</a>
<a name="ln7624">  msg(&quot;    `@#######################@;  &quot;</a>
<a name="ln7625">      &quot;                                                                  z##;&quot;, a);</a>
<a name="ln7626">  msg(&quot;    :##########################: &quot;</a>
<a name="ln7627">      &quot;                                                                  :##z&quot;, a);</a>
<a name="ln7628">  msg(&quot;    +#########################W# &quot;</a>
<a name="ln7629">      &quot;                                                                   M#W&quot;, a);</a>
<a name="ln7630">  msg(&quot;    W################@n+*i;:,`                                &quot;</a>
<a name="ln7631">      &quot;                                      +##,&quot;, a);</a>
<a name="ln7632">  msg(&quot;   :##################WMxz+,                                  &quot;</a>
<a name="ln7633">      &quot;                                      ,##i&quot;, a);</a>
<a name="ln7634">  msg(&quot;   n#######################W..,                               &quot;</a>
<a name="ln7635">      &quot;                                       W##&quot;, a);</a>
<a name="ln7636">  msg(&quot;  +#########################WW@+. .:.                         &quot;</a>
<a name="ln7637">      &quot;                                       z#x&quot;, a);</a>
<a name="ln7638">  msg(&quot; `@#############################@@###:                        &quot;</a>
<a name="ln7639">      &quot;                                       *#W&quot;, a);</a>
<a name="ln7640">  msg(&quot; #################################Wz:                         &quot;</a>
<a name="ln7641">      &quot;                                       :#@&quot;, a);</a>
<a name="ln7642">  msg(&quot;,@###############################i                            &quot;</a>
<a name="ln7643">      &quot;                                       .##&quot;, a);</a>
<a name="ln7644">  msg(&quot;n@@@@@@@#########################+                            &quot;</a>
<a name="ln7645">      &quot;                                       `##&quot;, a);</a>
<a name="ln7646">  msg(&quot;`      `.:.`.,:iii;;;;;;;;iii;;;:`       `.``                 &quot;</a>
<a name="ln7647">      &quot;                                       `nW&quot;, a);</a>
<a name="ln7648">}</a>
<a name="ln7649"> </a>
<a name="ln7650">/// Get argt of command with id</a>
<a name="ln7651">uint32_t get_cmd_argt(cmdidx_T cmdidx)</a>
<a name="ln7652">{</a>
<a name="ln7653">  return cmdnames[(int)cmdidx].cmd_argt;</a>
<a name="ln7654">}</a>
</code></pre>
<div class="balloon" rel="3144"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'name == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>