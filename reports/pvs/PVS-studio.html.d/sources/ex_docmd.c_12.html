<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_docmd.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_docmd.c: functions for executing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;limits.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;stddef.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;string.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;auto/config.h&quot;</a>
<a name="ln17">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/change.h&quot;</a>
<a name="ln23">#include &quot;nvim/charset.h&quot;</a>
<a name="ln24">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln25">#include &quot;nvim/cmdexpand_defs.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/debugger.h&quot;</a>
<a name="ln28">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln29">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln30">#include &quot;nvim/edit.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln33">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln34">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln36">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln37">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln38">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln39">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln40">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln41">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln42">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln43">#include &quot;nvim/fold.h&quot;</a>
<a name="ln44">#include &quot;nvim/garray.h&quot;</a>
<a name="ln45">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln46">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln47">#include &quot;nvim/globals.h&quot;</a>
<a name="ln48">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln49">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln50">#include &quot;nvim/input.h&quot;</a>
<a name="ln51">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln52">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln53">#include &quot;nvim/macros.h&quot;</a>
<a name="ln54">#include &quot;nvim/main.h&quot;</a>
<a name="ln55">#include &quot;nvim/mark.h&quot;</a>
<a name="ln56">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln57">#include &quot;nvim/memline.h&quot;</a>
<a name="ln58">#include &quot;nvim/memory.h&quot;</a>
<a name="ln59">#include &quot;nvim/message.h&quot;</a>
<a name="ln60">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln61">#include &quot;nvim/move.h&quot;</a>
<a name="ln62">#include &quot;nvim/normal.h&quot;</a>
<a name="ln63">#include &quot;nvim/ops.h&quot;</a>
<a name="ln64">#include &quot;nvim/option.h&quot;</a>
<a name="ln65">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln66">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln68">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln70">#include &quot;nvim/path.h&quot;</a>
<a name="ln71">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln72">#include &quot;nvim/pos.h&quot;</a>
<a name="ln73">#include &quot;nvim/profile.h&quot;</a>
<a name="ln74">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln75">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln76">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln77">#include &quot;nvim/search.h&quot;</a>
<a name="ln78">#include &quot;nvim/shada.h&quot;</a>
<a name="ln79">#include &quot;nvim/state.h&quot;</a>
<a name="ln80">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln81">#include &quot;nvim/strings.h&quot;</a>
<a name="ln82">#include &quot;nvim/tag.h&quot;</a>
<a name="ln83">#include &quot;nvim/types.h&quot;</a>
<a name="ln84">#include &quot;nvim/ui.h&quot;</a>
<a name="ln85">#include &quot;nvim/undo.h&quot;</a>
<a name="ln86">#include &quot;nvim/usercmd.h&quot;</a>
<a name="ln87">#include &quot;nvim/vim.h&quot;</a>
<a name="ln88">#include &quot;nvim/window.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">static const char e_ambiguous_use_of_user_defined_command[]</a>
<a name="ln91">  = N_(&quot;E464: Ambiguous use of user-defined command&quot;);</a>
<a name="ln92">static const char e_no_call_stack_to_substitute_for_stack[]</a>
<a name="ln93">  = N_(&quot;E489: No call stack to substitute for \&quot;&lt;stack&gt;\&quot;&quot;);</a>
<a name="ln94">static const char e_not_an_editor_command[]</a>
<a name="ln95">  = N_(&quot;E492: Not an editor command&quot;);</a>
<a name="ln96">static const char e_no_autocommand_file_name_to_substitute_for_afile[]</a>
<a name="ln97">  = N_(&quot;E495: No autocommand file name to substitute for \&quot;&lt;afile&gt;\&quot;&quot;);</a>
<a name="ln98">static const char e_no_autocommand_buffer_number_to_substitute_for_abuf[]</a>
<a name="ln99">  = N_(&quot;E496: No autocommand buffer number to substitute for \&quot;&lt;abuf&gt;\&quot;&quot;);</a>
<a name="ln100">static const char e_no_autocommand_match_name_to_substitute_for_amatch[]</a>
<a name="ln101">  = N_(&quot;E497: No autocommand match name to substitute for \&quot;&lt;amatch&gt;\&quot;&quot;);</a>
<a name="ln102">static const char e_no_source_file_name_to_substitute_for_sfile[]</a>
<a name="ln103">  = N_(&quot;E498: No :source file name to substitute for \&quot;&lt;sfile&gt;\&quot;&quot;);</a>
<a name="ln104">static const char e_no_line_number_to_use_for_slnum[]</a>
<a name="ln105">  = N_(&quot;E842: No line number to use for \&quot;&lt;slnum&gt;\&quot;&quot;);</a>
<a name="ln106">static const char e_no_line_number_to_use_for_sflnum[]</a>
<a name="ln107">  = N_(&quot;E961: No line number to use for \&quot;&lt;sflnum&gt;\&quot;&quot;);</a>
<a name="ln108">static const char e_no_script_file_name_to_substitute_for_script[]</a>
<a name="ln109">  = N_(&quot;E1274: No script file name to substitute for \&quot;&lt;script&gt;\&quot;&quot;);</a>
<a name="ln110"> </a>
<a name="ln111">static int quitmore = 0;</a>
<a name="ln112">static bool ex_pressedreturn = false;</a>
<a name="ln113"> </a>
<a name="ln114">// Struct for storing a line inside a while/for loop</a>
<a name="ln115">typedef struct {</a>
<a name="ln116">  char *line;            // command line</a>
<a name="ln117">  linenr_T lnum;                // sourcing_lnum of the line</a>
<a name="ln118">} wcmd_T;</a>
<a name="ln119"> </a>
<a name="ln120">#define FREE_WCMD(wcmd) xfree((wcmd)-&gt;line)</a>
<a name="ln121"> </a>
<a name="ln122">/// Structure used to store info for line position in a while or for loop.</a>
<a name="ln123">/// This is required, because do_one_cmd() may invoke ex_function(), which</a>
<a name="ln124">/// reads more lines that may come from the while/for loop.</a>
<a name="ln125">struct loop_cookie {</a>
<a name="ln126">  garray_T *lines_gap;               // growarray with line info</a>
<a name="ln127">  int current_line;                     // last read line from growarray</a>
<a name="ln128">  int repeating;                        // true when looping a second time</a>
<a name="ln129">  // When &quot;repeating&quot; is false use &quot;getline&quot; and &quot;cookie&quot; to get lines</a>
<a name="ln130">  char *(*getline)(int, void *, int, bool);</a>
<a name="ln131">  void *cookie;</a>
<a name="ln132">};</a>
<a name="ln133"> </a>
<a name="ln134">// Struct to save a few things while debugging.  Used in do_cmdline() only.</a>
<a name="ln135">struct dbg_stuff {</a>
<a name="ln136">  int trylevel;</a>
<a name="ln137">  int force_abort;</a>
<a name="ln138">  except_T *caught_stack;</a>
<a name="ln139">  char *vv_exception;</a>
<a name="ln140">  char *vv_throwpoint;</a>
<a name="ln141">  int did_emsg;</a>
<a name="ln142">  int got_int;</a>
<a name="ln143">  bool did_throw;</a>
<a name="ln144">  int need_rethrow;</a>
<a name="ln145">  int check_cstack;</a>
<a name="ln146">  except_T *current_exception;</a>
<a name="ln147">};</a>
<a name="ln148"> </a>
<a name="ln149">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln150"># include &quot;ex_docmd.c.generated.h&quot;</a>
<a name="ln151">#endif</a>
<a name="ln152"> </a>
<a name="ln153">#ifndef HAVE_WORKING_LIBINTL</a>
<a name="ln154"># define ex_language            ex_ni</a>
<a name="ln155">#endif</a>
<a name="ln156"> </a>
<a name="ln157">// Declare cmdnames[].</a>
<a name="ln158">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln159"># include &quot;ex_cmds_defs.generated.h&quot;</a>
<a name="ln160">#endif</a>
<a name="ln161"> </a>
<a name="ln162">static char dollar_command[2] = { '$', 0 };</a>
<a name="ln163"> </a>
<a name="ln164">static void save_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln165">{</a>
<a name="ln166">  dsp-&gt;trylevel       = trylevel;             trylevel = 0;</a>
<a name="ln167">  dsp-&gt;force_abort    = force_abort;          force_abort = false;</a>
<a name="ln168">  dsp-&gt;caught_stack   = caught_stack;         caught_stack = NULL;</a>
<a name="ln169">  dsp-&gt;vv_exception   = v_exception(NULL);</a>
<a name="ln170">  dsp-&gt;vv_throwpoint  = v_throwpoint(NULL);</a>
<a name="ln171"> </a>
<a name="ln172">  // Necessary for debugging an inactive &quot;:catch&quot;, &quot;:finally&quot;, &quot;:endtry&quot;.</a>
<a name="ln173">  dsp-&gt;did_emsg       = did_emsg;             did_emsg     = false;</a>
<a name="ln174">  dsp-&gt;got_int        = got_int;              got_int      = false;</a>
<a name="ln175">  dsp-&gt;did_throw      = did_throw;            did_throw    = false;</a>
<a name="ln176">  dsp-&gt;need_rethrow   = need_rethrow;         need_rethrow = false;</a>
<a name="ln177">  dsp-&gt;check_cstack   = check_cstack;         check_cstack = false;</a>
<a name="ln178">  dsp-&gt;current_exception = current_exception; current_exception = NULL;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static void restore_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln182">{</a>
<a name="ln183">  suppress_errthrow = false;</a>
<a name="ln184">  trylevel = dsp-&gt;trylevel;</a>
<a name="ln185">  force_abort = dsp-&gt;force_abort;</a>
<a name="ln186">  caught_stack = dsp-&gt;caught_stack;</a>
<a name="ln187">  (void)v_exception(dsp-&gt;vv_exception);</a>
<a name="ln188">  (void)v_throwpoint(dsp-&gt;vv_throwpoint);</a>
<a name="ln189">  did_emsg = dsp-&gt;did_emsg;</a>
<a name="ln190">  got_int = dsp-&gt;got_int;</a>
<a name="ln191">  did_throw = dsp-&gt;did_throw;</a>
<a name="ln192">  need_rethrow = dsp-&gt;need_rethrow;</a>
<a name="ln193">  check_cstack = dsp-&gt;check_cstack;</a>
<a name="ln194">  current_exception = dsp-&gt;current_exception;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/// Repeatedly get commands for Ex mode, until the &quot;:vi&quot; command is given.</a>
<a name="ln198">void do_exmode(void)</a>
<a name="ln199">{</a>
<a name="ln200">  exmode_active = true;</a>
<a name="ln201">  State = MODE_NORMAL;</a>
<a name="ln202">  may_trigger_modechanged();</a>
<a name="ln203"> </a>
<a name="ln204">  // When using &quot;:global /pat/ visual&quot; and then &quot;Q&quot; we return to continue</a>
<a name="ln205">  // the :global command.</a>
<a name="ln206">  if (global_busy) {</a>
<a name="ln207">    return;</a>
<a name="ln208">  }</a>
<a name="ln209"> </a>
<a name="ln210">  int save_msg_scroll = msg_scroll;</a>
<a name="ln211">  RedrawingDisabled++;  // don't redisplay the window</a>
<a name="ln212">  no_wait_return++;  // don't wait for return</a>
<a name="ln213"> </a>
<a name="ln214">  msg(_(&quot;Entering Ex mode.  Type \&quot;visual\&quot; to go to Normal mode.&quot;), 0);</a>
<a name="ln215">  while (exmode_active) {</a>
<a name="ln216">    // Check for a &quot;:normal&quot; command and no more characters left.</a>
<a name="ln217">    if (ex_normal_busy &gt; 0 &amp;&amp; typebuf.tb_len == 0) {</a>
<a name="ln218">      exmode_active = false;</a>
<a name="ln219">      break;</a>
<a name="ln220">    }</a>
<a name="ln221">    msg_scroll = true;</a>
<a name="ln222">    need_wait_return = false;</a>
<a name="ln223">    ex_pressedreturn = false;</a>
<a name="ln224">    ex_no_reprint = false;</a>
<a name="ln225">    varnumber_T changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln226">    int prev_msg_row = msg_row;</a>
<a name="ln227">    linenr_T prev_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln228">    cmdline_row = msg_row;</a>
<a name="ln229">    do_cmdline(NULL, getexline, NULL, 0);</a>
<a name="ln230">    lines_left = Rows - 1;</a>
<a name="ln231"> </a>
<a name="ln232">    if ((prev_line != curwin-&gt;w_cursor.lnum</a>
<a name="ln233">         || changedtick != buf_get_changedtick(curbuf)) &amp;&amp; !ex_no_reprint) {</a>
<a name="ln234">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln235">        emsg(_(e_empty_buffer));</a>
<a name="ln236">      } else {</a>
<a name="ln237">        if (ex_pressedreturn) {</a>
<a name="ln238">          // Make sure the message overwrites the right line and isn't throttled.</a>
<a name="ln239">          msg_scroll_flush();</a>
<a name="ln240">          // go up one line, to overwrite the &quot;:&lt;CR&gt;&quot; line, so the</a>
<a name="ln241">          // output doesn't contain empty lines.</a>
<a name="ln242">          msg_row = prev_msg_row;</a>
<a name="ln243">          if (prev_msg_row == Rows - 1) {</a>
<a name="ln244">            msg_row--;</a>
<a name="ln245">          }</a>
<a name="ln246">        }</a>
<a name="ln247">        msg_col = 0;</a>
<a name="ln248">        print_line_no_prefix(curwin-&gt;w_cursor.lnum, false, false);</a>
<a name="ln249">        msg_clr_eos();</a>
<a name="ln250">      }</a>
<a name="ln251">    } else if (ex_pressedreturn &amp;&amp; !ex_no_reprint) {  // must be at EOF</a>
<a name="ln252">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln253">        emsg(_(e_empty_buffer));</a>
<a name="ln254">      } else {</a>
<a name="ln255">        emsg(_(&quot;E501: At end-of-file&quot;));</a>
<a name="ln256">      }</a>
<a name="ln257">    }</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  RedrawingDisabled--;</a>
<a name="ln261">  no_wait_return--;</a>
<a name="ln262">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln263">  update_screen();</a>
<a name="ln264">  need_wait_return = false;</a>
<a name="ln265">  msg_scroll = save_msg_scroll;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/// Print the executed command for when 'verbose' is set.</a>
<a name="ln269">///</a>
<a name="ln270">/// @param lnum  if 0, only print the command.</a>
<a name="ln271">static void msg_verbose_cmd(linenr_T lnum, char *cmd)</a>
<a name="ln272">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln273">{</a>
<a name="ln274">  no_wait_return++;</a>
<a name="ln275">  verbose_enter_scroll();</a>
<a name="ln276"> </a>
<a name="ln277">  if (lnum == 0) {</a>
<a name="ln278">    smsg(0, _(&quot;Executing: %s&quot;), cmd);</a>
<a name="ln279">  } else {</a>
<a name="ln280">    smsg(0, _(&quot;line %&quot; PRIdLINENR &quot;: %s&quot;), lnum, cmd);</a>
<a name="ln281">  }</a>
<a name="ln282">  if (msg_silent == 0) {</a>
<a name="ln283">    msg_puts(&quot;\n&quot;);   // don't overwrite this</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  verbose_leave_scroll();</a>
<a name="ln287">  no_wait_return--;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/// Execute a simple command line.  Used for translated commands like &quot;*&quot;.</a>
<a name="ln291">int do_cmdline_cmd(const char *cmd)</a>
<a name="ln292">{</a>
<a name="ln293">  return do_cmdline((char *)cmd, NULL, NULL, DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">/// do_cmdline(): execute one Ex command line</a>
<a name="ln297">///</a>
<a name="ln298">/// 1. Execute &quot;cmdline&quot; when it is not NULL.</a>
<a name="ln299">///    If &quot;cmdline&quot; is NULL, or more lines are needed, fgetline() is used.</a>
<a name="ln300">/// 2. Split up in parts separated with '|'.</a>
<a name="ln301">///</a>
<a name="ln302">/// This function can be called recursively!</a>
<a name="ln303">///</a>
<a name="ln304">/// flags:</a>
<a name="ln305">///   DOCMD_VERBOSE  - The command will be included in the error message.</a>
<a name="ln306">///   DOCMD_NOWAIT   - Don't call wait_return() and friends.</a>
<a name="ln307">///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.</a>
<a name="ln308">///   DOCMD_KEYTYPED - Don't reset KeyTyped.</a>
<a name="ln309">///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).</a>
<a name="ln310">///   DOCMD_KEEPLINE - Store first typed line (for repeating with &quot;.&quot;).</a>
<a name="ln311">///</a>
<a name="ln312">/// @param cookie  argument for fgetline()</a>
<a name="ln313">///</a>
<a name="ln314">/// @return FAIL if cmdline could not be executed, OK otherwise</a>
<a name="ln315">int do_cmdline(char *cmdline, LineGetter fgetline, void *cookie, int flags)</a>
<a name="ln316">{</a>
<a name="ln317">  char *next_cmdline;                   // next cmd to execute</a>
<a name="ln318">  char *cmdline_copy = NULL;            // copy of cmd line</a>
<a name="ln319">  bool used_getline = false;            // used &quot;fgetline&quot; to obtain command</a>
<a name="ln320">  static int recursive = 0;             // recursive depth</a>
<a name="ln321">  bool msg_didout_before_start = false;</a>
<a name="ln322">  int count = 0;                        // line number count</a>
<a name="ln323">  bool did_inc = false;                 // incremented RedrawingDisabled</a>
<a name="ln324">  int retval = OK;</a>
<a name="ln325">  cstack_T cstack = {                   // conditional stack</a>
<a name="ln326">    .cs_idx = -1,</a>
<a name="ln327">  };</a>
<a name="ln328">  garray_T lines_ga;                    // keep lines for &quot;:while&quot;/&quot;:for&quot;</a>
<a name="ln329">  int current_line = 0;                 // active line in lines_ga</a>
<a name="ln330">  char *fname = NULL;                   // function or script name</a>
<a name="ln331">  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie</a>
<a name="ln332">  int *dbg_tick = NULL;                 // ptr to dbg_tick field in cookie</a>
<a name="ln333">  struct dbg_stuff debug_saved;         // saved things for debug mode</a>
<a name="ln334">  int initial_trylevel;</a>
<a name="ln335">  msglist_T **saved_msg_list = NULL;</a>
<a name="ln336">  msglist_T *private_msg_list;</a>
<a name="ln337"> </a>
<a name="ln338">  // &quot;fgetline&quot; and &quot;cookie&quot; passed to do_one_cmd()</a>
<a name="ln339">  char *(*cmd_getline)(int, void *, int, bool);</a>
<a name="ln340">  void *cmd_cookie;</a>
<a name="ln341">  struct loop_cookie cmd_loop_cookie;</a>
<a name="ln342">  void *real_cookie;</a>
<a name="ln343">  int getline_is_func;</a>
<a name="ln344">  static int call_depth = 0;            // recursiveness</a>
<a name="ln345"> </a>
<a name="ln346">  // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory</a>
<a name="ln347">  // location for storing error messages to be converted to an exception.</a>
<a name="ln348">  // This ensures that the do_errthrow() call in do_one_cmd() does not</a>
<a name="ln349">  // combine the messages stored by an earlier invocation of do_one_cmd()</a>
<a name="ln350">  // with the command name of the later one.  This would happen when</a>
<a name="ln351">  // BufWritePost autocommands are executed after a write error.</a>
<a name="ln352">  saved_msg_list = msg_list;</a>
<a name="ln353">  msg_list = &amp;private_msg_list;</a>
<a name="ln354">  private_msg_list = NULL;</a>
<a name="ln355"> </a>
<a name="ln356">  // It's possible to create an endless loop with &quot;:execute&quot;, catch that</a>
<a name="ln357">  // here.  The value of 200 allows nested function calls, &quot;:source&quot;, etc.</a>
<a name="ln358">  // Allow 200 or 'maxfuncdepth', whatever is larger.</a>
<a name="ln359">  if (call_depth &gt;= 200 &amp;&amp; call_depth &gt;= p_mfd) {</a>
<a name="ln360">    emsg(_(e_command_too_recursive));</a>
<a name="ln361">    // When converting to an exception, we do not include the command name</a>
<a name="ln362">    // since this is not an error of the specific command.</a>
<a name="ln363">    do_errthrow((cstack_T *)NULL, NULL);</a>
<a name="ln364">    msg_list = saved_msg_list;</a>
<a name="ln365">    return FAIL;</a>
<a name="ln366">  }</a>
<a name="ln367">  call_depth++;</a>
<a name="ln368">  start_batch_changes();</a>
<a name="ln369"> </a>
<a name="ln370">  ga_init(&amp;lines_ga, (int)sizeof(wcmd_T), 10);</a>
<a name="ln371"> </a>
<a name="ln372">  real_cookie = getline_cookie(fgetline, cookie);</a>
<a name="ln373"> </a>
<a name="ln374">  // Inside a function use a higher nesting level.</a>
<a name="ln375">  getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln376">  if (getline_is_func &amp;&amp; ex_nesting_level == func_level(real_cookie)) {</a>
<a name="ln377">    ex_nesting_level++;</a>
<a name="ln378">  }</a>
<a name="ln379"> </a>
<a name="ln380">  // Get the function or script name and the address where the next breakpoint</a>
<a name="ln381">  // line and the debug tick for a function or script are stored.</a>
<a name="ln382">  if (getline_is_func) {</a>
<a name="ln383">    fname = func_name(real_cookie);</a>
<a name="ln384">    breakpoint = func_breakpoint(real_cookie);</a>
<a name="ln385">    dbg_tick = func_dbg_tick(real_cookie);</a>
<a name="ln386">  } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln387">    fname = SOURCING_NAME;</a>
<a name="ln388">    breakpoint = source_breakpoint(real_cookie);</a>
<a name="ln389">    dbg_tick = source_dbg_tick(real_cookie);</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  // Initialize &quot;force_abort&quot;  and &quot;suppress_errthrow&quot; at the top level.</a>
<a name="ln393">  if (!recursive) {</a>
<a name="ln394">    force_abort = false;</a>
<a name="ln395">    suppress_errthrow = false;</a>
<a name="ln396">  }</a>
<a name="ln397"> </a>
<a name="ln398">  // If requested, store and reset the global values controlling the</a>
<a name="ln399">  // exception handling (used when debugging).  Otherwise clear it to avoid</a>
<a name="ln400">  // a bogus compiler warning when the optimizer uses inline functions...</a>
<a name="ln401">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln402">    save_dbg_stuff(&amp;debug_saved);</a>
<a name="ln403">  } else {</a>
<a name="ln404">    CLEAR_FIELD(debug_saved);</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  initial_trylevel = trylevel;</a>
<a name="ln408"> </a>
<a name="ln409">  // &quot;did_throw&quot; will be set to true when an exception is being thrown.</a>
<a name="ln410">  did_throw = false;</a>
<a name="ln411">  // &quot;did_emsg&quot; will be set to true when emsg() is used, in which case we</a>
<a name="ln412">  // cancel the whole command line, and any if/endif or loop.</a>
<a name="ln413">  // If force_abort is set, we cancel everything.</a>
<a name="ln414">  did_emsg = false;</a>
<a name="ln415"> </a>
<a name="ln416">  // KeyTyped is only set when calling vgetc().  Reset it here when not</a>
<a name="ln417">  // calling vgetc() (sourced command lines).</a>
<a name="ln418">  if (!(flags &amp; DOCMD_KEYTYPED)</a>
<a name="ln419">      &amp;&amp; !getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln420">    KeyTyped = false;</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  // Continue executing command lines:</a>
<a name="ln424">  // - when inside an &quot;:if&quot;, &quot;:while&quot; or &quot;:for&quot;</a>
<a name="ln425">  // - for multiple commands on one line, separated with '|'</a>
<a name="ln426">  // - when repeating until there are no more lines (for &quot;:source&quot;)</a>
<a name="ln427">  next_cmdline = cmdline;</a>
<a name="ln428">  do {</a>
<a name="ln429">    getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln430"> </a>
<a name="ln431">    // stop skipping cmds for an error msg after all endif/while/for</a>
<a name="ln432">    if (next_cmdline == NULL</a>
<a name="ln433">        &amp;&amp; !force_abort</a>
<a name="ln434">        &amp;&amp; cstack.cs_idx &lt; 0</a>
<a name="ln435">        &amp;&amp; !(getline_is_func</a>
<a name="ln436">             &amp;&amp; func_has_abort(real_cookie))) {</a>
<a name="ln437">      did_emsg = false;</a>
<a name="ln438">    }</a>
<a name="ln439"> </a>
<a name="ln440">    // 1. If repeating a line in a loop, get a line from lines_ga.</a>
<a name="ln441">    // 2. If no line given: Get an allocated line with fgetline().</a>
<a name="ln442">    // 3. If a line is given: Make a copy, so we can mess with it.</a>
<a name="ln443"> </a>
<a name="ln444">    // 1. If repeating, get a previous line from lines_ga.</a>
<a name="ln445">    if (cstack.cs_looplevel &gt; 0 &amp;&amp; current_line &lt; lines_ga.ga_len) {</a>
<a name="ln446">      // Each '|' separated command is stored separately in lines_ga, to</a>
<a name="ln447">      // be able to jump to it.  Don't use next_cmdline now.</a>
<a name="ln448">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln449"> </a>
<a name="ln450">      // Check if a function has returned or, unless it has an unclosed</a>
<a name="ln451">      // try conditional, aborted.</a>
<a name="ln452">      if (getline_is_func) {</a>
<a name="ln453">        if (do_profiling == PROF_YES) {</a>
<a name="ln454">          func_line_end(real_cookie);</a>
<a name="ln455">        }</a>
<a name="ln456">        if (func_has_ended(real_cookie)) {</a>
<a name="ln457">          retval = FAIL;</a>
<a name="ln458">          break;</a>
<a name="ln459">        }</a>
<a name="ln460">      } else if (do_profiling == PROF_YES</a>
<a name="ln461">                 &amp;&amp; getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln462">        script_line_end();</a>
<a name="ln463">      }</a>
<a name="ln464"> </a>
<a name="ln465">      // Check if a sourced file hit a &quot;:finish&quot; command.</a>
<a name="ln466">      if (source_finished(fgetline, cookie)) {</a>
<a name="ln467">        retval = FAIL;</a>
<a name="ln468">        break;</a>
<a name="ln469">      }</a>
<a name="ln470"> </a>
<a name="ln471">      // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln472">      if (breakpoint != NULL &amp;&amp; dbg_tick != NULL</a>
<a name="ln473">          &amp;&amp; *dbg_tick != debug_tick) {</a>
<a name="ln474">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln475">                                          fname, SOURCING_LNUM);</a>
<a name="ln476">        *dbg_tick = debug_tick;</a>
<a name="ln477">      }</a>
<a name="ln478"> </a>
<a name="ln479">      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;</a>
<a name="ln480">      SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;</a>
<a name="ln481"> </a>
<a name="ln482">      // Did we encounter a breakpoint?</a>
<a name="ln483">      if (breakpoint != NULL &amp;&amp; *breakpoint != 0 &amp;&amp; *breakpoint &lt;= SOURCING_LNUM) {</a>
<a name="ln484">        dbg_breakpoint(fname, SOURCING_LNUM);</a>
<a name="ln485">        // Find next breakpoint.</a>
<a name="ln486">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln487">                                          fname, SOURCING_LNUM);</a>
<a name="ln488">        *dbg_tick = debug_tick;</a>
<a name="ln489">      }</a>
<a name="ln490">      if (do_profiling == PROF_YES) {</a>
<a name="ln491">        if (getline_is_func) {</a>
<a name="ln492">          func_line_start(real_cookie);</a>
<a name="ln493">        } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln494">          script_line_start();</a>
<a name="ln495">        }</a>
<a name="ln496">      }</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    // 2. If no line given, get an allocated line with fgetline().</a>
<a name="ln500">    if (next_cmdline == NULL) {</a>
<a name="ln501">      // Need to set msg_didout for the first line after an &quot;:if&quot;,</a>
<a name="ln502">      // otherwise the &quot;:if&quot; will be overwritten.</a>
<a name="ln503">      if (count == 1 &amp;&amp; getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln504">        msg_didout = true;</a>
<a name="ln505">      }</a>
<a name="ln506">      if (fgetline == NULL</a>
<a name="ln507">          || (next_cmdline = fgetline(':', cookie,</a>
<a name="ln508">                                      cstack.cs_idx &lt;</a>
<a name="ln509">                                      0 ? 0 : (cstack.cs_idx + 1) * 2,</a>
<a name="ln510">                                      true)) == NULL) {</a>
<a name="ln511">        // Don't call wait_return() for aborted command line.  The NULL</a>
<a name="ln512">        // returned for the end of a sourced file or executed function</a>
<a name="ln513">        // doesn't do this.</a>
<a name="ln514">        if (KeyTyped &amp;&amp; !(flags &amp; DOCMD_REPEAT)) {</a>
<a name="ln515">          need_wait_return = false;</a>
<a name="ln516">        }</a>
<a name="ln517">        retval = FAIL;</a>
<a name="ln518">        break;</a>
<a name="ln519">      }</a>
<a name="ln520">      used_getline = true;</a>
<a name="ln521"> </a>
<a name="ln522">      // Keep the first typed line.  Clear it when more lines are typed.</a>
<a name="ln523">      if (flags &amp; DOCMD_KEEPLINE) {</a>
<a name="ln524">        xfree(repeat_cmdline);</a>
<a name="ln525">        if (count == 0) {</a>
<a name="ln526">          repeat_cmdline = xstrdup(next_cmdline);</a>
<a name="ln527">        } else {</a>
<a name="ln528">          repeat_cmdline = NULL;</a>
<a name="ln529">        }</a>
<a name="ln530">      }</a>
<a name="ln531">    } else if (cmdline_copy == NULL) {</a>
<a name="ln532">      // 3. Make a copy of the command so we can mess with it.</a>
<a name="ln533">      next_cmdline = xstrdup(next_cmdline);</a>
<a name="ln534">    }</a>
<a name="ln535">    cmdline_copy = next_cmdline;</a>
<a name="ln536"> </a>
<a name="ln537">    int current_line_before = 0;</a>
<a name="ln538">    // Inside a while/for loop, and when the command looks like a &quot;:while&quot;</a>
<a name="ln539">    // or &quot;:for&quot;, the line is stored, because we may need it later when</a>
<a name="ln540">    // looping.</a>
<a name="ln541">    //</a>
<a name="ln542">    // When there is a '|' and another command, it is stored separately,</a>
<a name="ln543">    // because we need to be able to jump back to it from an</a>
<a name="ln544">    // :endwhile/:endfor.</a>
<a name="ln545">    //</a>
<a name="ln546">    // Pass a different &quot;fgetline&quot; function to do_one_cmd() below,</a>
<a name="ln547">    // that it stores lines in or reads them from &quot;lines_ga&quot;.  Makes it</a>
<a name="ln548">    // possible to define a function inside a while/for loop.</a>
<a name="ln549">    if ((cstack.cs_looplevel &gt; 0 || has_loop_cmd(next_cmdline))) {</a>
<a name="ln550">      cmd_getline = get_loop_line;</a>
<a name="ln551">      cmd_cookie = (void *)&amp;cmd_loop_cookie;</a>
<a name="ln552">      cmd_loop_cookie.lines_gap = &amp;lines_ga;</a>
<a name="ln553">      cmd_loop_cookie.current_line = current_line;</a>
<a name="ln554">      cmd_loop_cookie.getline = fgetline;</a>
<a name="ln555">      cmd_loop_cookie.cookie = cookie;</a>
<a name="ln556">      cmd_loop_cookie.repeating = (current_line &lt; lines_ga.ga_len);</a>
<a name="ln557"> </a>
<a name="ln558">      // Save the current line when encountering it the first time.</a>
<a name="ln559">      if (current_line == lines_ga.ga_len) {</a>
<a name="ln560">        store_loop_line(&amp;lines_ga, next_cmdline);</a>
<a name="ln561">      }</a>
<a name="ln562">      current_line_before = current_line;</a>
<a name="ln563">    } else {</a>
<a name="ln564">      cmd_getline = fgetline;</a>
<a name="ln565">      cmd_cookie = cookie;</a>
<a name="ln566">    }</a>
<a name="ln567"> </a>
<a name="ln568">    did_endif = false;</a>
<a name="ln569"> </a>
<a name="ln570">    if (count++ == 0) {</a>
<a name="ln571">      // All output from the commands is put below each other, without</a>
<a name="ln572">      // waiting for a return. Don't do this when executing commands</a>
<a name="ln573">      // from a script or when being called recursive (e.g. for &quot;:e</a>
<a name="ln574">      // +command file&quot;).</a>
<a name="ln575">      if (!(flags &amp; DOCMD_NOWAIT) &amp;&amp; !recursive) {</a>
<a name="ln576">        msg_didout_before_start = msg_didout;</a>
<a name="ln577">        msg_didany = false;         // no output yet</a>
<a name="ln578">        msg_start();</a>
<a name="ln579">        msg_scroll = true;          // put messages below each other</a>
<a name="ln580">        no_wait_return++;           // don't wait for return until finished</a>
<a name="ln581">        RedrawingDisabled++;</a>
<a name="ln582">        did_inc = true;</a>
<a name="ln583">      }</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">    if ((p_verbose &gt;= 15 &amp;&amp; SOURCING_NAME != NULL) || p_verbose &gt;= 16) {</a>
<a name="ln587">      msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">    // 2. Execute one '|' separated command.</a>
<a name="ln591">    //    do_one_cmd() will return NULL if there is no trailing '|'.</a>
<a name="ln592">    //    &quot;cmdline_copy&quot; can change, e.g. for '%' and '#' expansion.</a>
<a name="ln593">    recursive++;</a>
<a name="ln594">    next_cmdline = do_one_cmd(&amp;cmdline_copy, flags, &amp;cstack, cmd_getline, cmd_cookie);</a>
<a name="ln595">    recursive--;</a>
<a name="ln596"> </a>
<a name="ln597">    if (cmd_cookie == (void *)&amp;cmd_loop_cookie) {</a>
<a name="ln598">      // Use &quot;current_line&quot; from &quot;cmd_loop_cookie&quot;, it may have been</a>
<a name="ln599">      // incremented when defining a function.</a>
<a name="ln600">      current_line = cmd_loop_cookie.current_line;</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    if (next_cmdline == NULL) {</a>
<a name="ln604">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln605"> </a>
<a name="ln606">      // If the command was typed, remember it for the ':' register.</a>
<a name="ln607">      // Do this AFTER executing the command to make :@: work.</a>
<a name="ln608">      if (getline_equal(fgetline, cookie, getexline)</a>
<a name="ln609">          &amp;&amp; new_last_cmdline != NULL) {</a>
<a name="ln610">        xfree(last_cmdline);</a>
<a name="ln611">        last_cmdline = new_last_cmdline;</a>
<a name="ln612">        new_last_cmdline = NULL;</a>
<a name="ln613">      }</a>
<a name="ln614">    } else {</a>
<a name="ln615">      // need to copy the command after the '|' to cmdline_copy, for the</a>
<a name="ln616">      // next do_one_cmd()</a>
<a name="ln617">      STRMOVE(cmdline_copy, next_cmdline);</a>
<a name="ln618">      next_cmdline = cmdline_copy;</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    // reset did_emsg for a function that is not aborted by an error</a>
<a name="ln622">    if (did_emsg &amp;&amp; !force_abort</a>
<a name="ln623">        &amp;&amp; getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln624">        &amp;&amp; !func_has_abort(real_cookie)) {</a>
<a name="ln625">      did_emsg = false;</a>
<a name="ln626">    }</a>
<a name="ln627"> </a>
<a name="ln628">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln629">      current_line++;</a>
<a name="ln630"> </a>
<a name="ln631">      // An &quot;:endwhile&quot;, &quot;:endfor&quot; and &quot;:continue&quot; is handled here.</a>
<a name="ln632">      // If we were executing commands, jump back to the &quot;:while&quot; or</a>
<a name="ln633">      // &quot;:for&quot;.</a>
<a name="ln634">      // If we were not executing commands, decrement cs_looplevel.</a>
<a name="ln635">      if (cstack.cs_lflags &amp; (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {</a>
<a name="ln636">        cstack.cs_lflags &amp;= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);</a>
<a name="ln637"> </a>
<a name="ln638">        // Jump back to the matching &quot;:while&quot; or &quot;:for&quot;.  Be careful</a>
<a name="ln639">        // not to use a cs_line[] from an entry that isn't a &quot;:while&quot;</a>
<a name="ln640">        // or &quot;:for&quot;: It would make &quot;current_line&quot; invalid and can</a>
<a name="ln641">        // cause a crash.</a>
<a name="ln642">        if (!did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw</a>
<a name="ln643">            &amp;&amp; cstack.cs_idx &gt;= 0</a>
<a name="ln644">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx]</a>
<a name="ln645">                &amp; (CSF_WHILE | CSF_FOR))</a>
<a name="ln646">            &amp;&amp; cstack.cs_line[cstack.cs_idx] &gt;= 0</a>
<a name="ln647">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx] &amp; CSF_ACTIVE)) {</a>
<a name="ln648">          current_line = cstack.cs_line[cstack.cs_idx];</a>
<a name="ln649">          // remember we jumped there</a>
<a name="ln650">          cstack.cs_lflags |= CSL_HAD_LOOP;</a>
<a name="ln651">          line_breakcheck();                    // check if CTRL-C typed</a>
<a name="ln652"> </a>
<a name="ln653">          // Check for the next breakpoint at or after the &quot;:while&quot;</a>
<a name="ln654">          // or &quot;:for&quot;.</a>
<a name="ln655">          if (breakpoint != NULL &amp;&amp; lines_ga.ga_len &gt; current_line) {</a>
<a name="ln656">            *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline), fname,</a>
<a name="ln657">                                              ((wcmd_T *)lines_ga.ga_data)[current_line].lnum - 1);</a>
<a name="ln658">            *dbg_tick = debug_tick;</a>
<a name="ln659">          }</a>
<a name="ln660">        } else {</a>
<a name="ln661">          // can only get here with &quot;:endwhile&quot; or &quot;:endfor&quot;</a>
<a name="ln662">          if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln663">            rewind_conditionals(&amp;cstack, cstack.cs_idx - 1,</a>
<a name="ln664">                                CSF_WHILE | CSF_FOR, &amp;cstack.cs_looplevel);</a>
<a name="ln665">          }</a>
<a name="ln666">        }</a>
<a name="ln667">      } else if (cstack.cs_lflags &amp; CSL_HAD_LOOP) {</a>
<a name="ln668">        // For a &quot;:while&quot; or &quot;:for&quot; we need to remember the line number.</a>
<a name="ln669">        cstack.cs_lflags &amp;= ~CSL_HAD_LOOP;</a>
<a name="ln670">        cstack.cs_line[cstack.cs_idx] = current_line_before;</a>
<a name="ln671">      }</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">    // When not inside any &quot;:while&quot; loop, clear remembered lines.</a>
<a name="ln675">    if (cstack.cs_looplevel == 0) {</a>
<a name="ln676">      if (!GA_EMPTY(&amp;lines_ga)) {</a>
<a name="ln677">        SOURCING_LNUM = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;</a>
<a name="ln678">        GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln679">      }</a>
<a name="ln680">      current_line = 0;</a>
<a name="ln681">    }</a>
<a name="ln682"> </a>
<a name="ln683">    // A &quot;:finally&quot; makes did_emsg, got_int and did_throw pending for</a>
<a name="ln684">    // being restored at the &quot;:endtry&quot;.  Reset them here and set the</a>
<a name="ln685">    // ACTIVE and FINALLY flags, so that the finally clause gets executed.</a>
<a name="ln686">    // This includes the case where a missing &quot;:endif&quot;, &quot;:endwhile&quot; or</a>
<a name="ln687">    // &quot;:endfor&quot; was detected by the &quot;:finally&quot; itself.</a>
<a name="ln688">    if (cstack.cs_lflags &amp; CSL_HAD_FINA) {</a>
<a name="ln689">      cstack.cs_lflags &amp;= ~CSL_HAD_FINA;</a>
<a name="ln690">      report_make_pending((cstack.cs_pending[cstack.cs_idx]</a>
<a name="ln691">                           &amp; (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),</a>
<a name="ln692">                          did_throw ? current_exception : NULL);</a>
<a name="ln693">      did_emsg = got_int = did_throw = false;</a>
<a name="ln694">      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">    // Update global &quot;trylevel&quot; for recursive calls to do_cmdline() from</a>
<a name="ln698">    // within this loop.</a>
<a name="ln699">    trylevel = initial_trylevel + cstack.cs_trylevel;</a>
<a name="ln700"> </a>
<a name="ln701">    // If the outermost try conditional (across function calls and sourced</a>
<a name="ln702">    // files) is aborted because of an error, an interrupt, or an uncaught</a>
<a name="ln703">    // exception, cancel everything.  If it is left normally, reset</a>
<a name="ln704">    // force_abort to get the non-EH compatible abortion behavior for</a>
<a name="ln705">    // the rest of the script.</a>
<a name="ln706">    if (trylevel == 0 &amp;&amp; !did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw) {</a>
<a name="ln707">      force_abort = false;</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">    // Convert an interrupt to an exception if appropriate.</a>
<a name="ln711">    (void)do_intthrow(&amp;cstack);</a>
<a name="ln712"> </a>
<a name="ln713">    // Continue executing command lines when:</a>
<a name="ln714">    // - no CTRL-C typed, no aborting error, no exception thrown or try</a>
<a name="ln715">    //   conditionals need to be checked for executing finally clauses or</a>
<a name="ln716">    //   catching an interrupt exception</a>
<a name="ln717">    // - didn't get an error message or lines are not typed</a>
<a name="ln718">    // - there is a command after '|', inside a :if, :while, :for or :try, or</a>
<a name="ln719">    //   looping for &quot;:source&quot; command or function call.</a>
<a name="ln720">  } while (!((got_int || (did_emsg &amp;&amp; force_abort) || did_throw)</a>
<a name="ln721">             &amp;&amp; cstack.cs_trylevel == 0)</a>
<a name="ln722">           &amp;&amp; !(did_emsg</a>
<a name="ln723">                // Keep going when inside try/catch, so that the error can be</a>
<a name="ln724">                // deal with, except when it is a syntax error, it may cause</a>
<a name="ln725">                // the :endtry to be missed.</a>
<a name="ln726">                &amp;&amp; (cstack.cs_trylevel == 0 || did_emsg_syntax)</a>
<a name="ln727">                &amp;&amp; used_getline</a>
<a name="ln728">                &amp;&amp; getline_equal(fgetline, cookie, getexline))</a>
<a name="ln729">           &amp;&amp; (next_cmdline != NULL</a>
<a name="ln730">               || cstack.cs_idx &gt;= 0</a>
<a name="ln731">               || (flags &amp; DOCMD_REPEAT)));</a>
<a name="ln732"> </a>
<a name="ln733">  xfree(cmdline_copy);</a>
<a name="ln734">  did_emsg_syntax = false;</a>
<a name="ln735">  GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln736"> </a>
<a name="ln737">  if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln738">    // If a sourced file or executed function ran to its end, report the</a>
<a name="ln739">    // unclosed conditional.</a>
<a name="ln740">    if (!got_int &amp;&amp; !did_throw &amp;&amp; !aborting()</a>
<a name="ln741">        &amp;&amp; ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln742">             &amp;&amp; !source_finished(fgetline, cookie))</a>
<a name="ln743">            || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln744">                &amp;&amp; !func_has_ended(real_cookie)))) {</a>
<a name="ln745">      if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_TRY) {</a>
<a name="ln746">        emsg(_(e_endtry));</a>
<a name="ln747">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_WHILE) {</a>
<a name="ln748">        emsg(_(e_endwhile));</a>
<a name="ln749">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_FOR) {</a>
<a name="ln750">        emsg(_(e_endfor));</a>
<a name="ln751">      } else {</a>
<a name="ln752">        emsg(_(e_endif));</a>
<a name="ln753">      }</a>
<a name="ln754">    }</a>
<a name="ln755"> </a>
<a name="ln756">    // Reset &quot;trylevel&quot; in case of a &quot;:finish&quot; or &quot;:return&quot; or a missing</a>
<a name="ln757">    // &quot;:endtry&quot; in a sourced file or executed function.  If the try</a>
<a name="ln758">    // conditional is in its finally clause, ignore anything pending.</a>
<a name="ln759">    // If it is in a catch clause, finish the caught exception.</a>
<a name="ln760">    // Also cleanup any &quot;cs_forinfo&quot; structures.</a>
<a name="ln761">    do {</a>
<a name="ln762">      int idx = cleanup_conditionals(&amp;cstack, 0, true);</a>
<a name="ln763"> </a>
<a name="ln764">      if (idx &gt;= 0) {</a>
<a name="ln765">        idx--;              // remove try block not in its finally clause</a>
<a name="ln766">      }</a>
<a name="ln767">      rewind_conditionals(&amp;cstack, idx, CSF_WHILE | CSF_FOR,</a>
<a name="ln768">                          &amp;cstack.cs_looplevel);</a>
<a name="ln769">    } while (cstack.cs_idx &gt;= 0);</a>
<a name="ln770">    trylevel = initial_trylevel;</a>
<a name="ln771">  }</a>
<a name="ln772"> </a>
<a name="ln773">  // If a missing &quot;:endtry&quot;, &quot;:endwhile&quot;, &quot;:endfor&quot;, or &quot;:endif&quot; or a memory</a>
<a name="ln774">  // lack was reported above and the error message is to be converted to an</a>
<a name="ln775">  // exception, do this now after rewinding the cstack.</a>
<a name="ln776">  do_errthrow(&amp;cstack, getline_equal(fgetline, cookie, get_func_line) ? &quot;endfunction&quot; : NULL);</a>
<a name="ln777"> </a>
<a name="ln778">  if (trylevel == 0) {</a>
<a name="ln779">    // When an exception is being thrown out of the outermost try</a>
<a name="ln780">    // conditional, discard the uncaught exception, disable the conversion</a>
<a name="ln781">    // of interrupts or errors to exceptions, and ensure that no more</a>
<a name="ln782">    // commands are executed.</a>
<a name="ln783">    if (did_throw) {</a>
<a name="ln784">      handle_did_throw();</a>
<a name="ln785">    } else if (got_int || (did_emsg &amp;&amp; force_abort)) {</a>
<a name="ln786">      // On an interrupt or an aborting error not converted to an exception,</a>
<a name="ln787">      // disable the conversion of errors to exceptions.  (Interrupts are not</a>
<a name="ln788">      // converted any more, here.) This enables also the interrupt message</a>
<a name="ln789">      // when force_abort is set and did_emsg unset in case of an interrupt</a>
<a name="ln790">      // from a finally clause after an error.</a>
<a name="ln791">      suppress_errthrow = true;</a>
<a name="ln792">    }</a>
<a name="ln793">  }</a>
<a name="ln794"> </a>
<a name="ln795">  // The current cstack will be freed when do_cmdline() returns.  An uncaught</a>
<a name="ln796">  // exception will have to be rethrown in the previous cstack.  If a function</a>
<a name="ln797">  // has just returned or a script file was just finished and the previous</a>
<a name="ln798">  // cstack belongs to the same function or, respectively, script file, it</a>
<a name="ln799">  // will have to be checked for finally clauses to be executed due to the</a>
<a name="ln800">  // &quot;:return&quot; or &quot;:finish&quot;.  This is done in do_one_cmd().</a>
<a name="ln801">  if (did_throw) {</a>
<a name="ln802">    need_rethrow = true;</a>
<a name="ln803">  }</a>
<a name="ln804">  if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln805">       &amp;&amp; ex_nesting_level &gt; source_level(real_cookie))</a>
<a name="ln806">      || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln807">          &amp;&amp; ex_nesting_level &gt; func_level(real_cookie) + 1)) {</a>
<a name="ln808">    if (!did_throw) {</a>
<a name="ln809">      check_cstack = true;</a>
<a name="ln810">    }</a>
<a name="ln811">  } else {</a>
<a name="ln812">    // When leaving a function, reduce nesting level.</a>
<a name="ln813">    if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln814">      ex_nesting_level--;</a>
<a name="ln815">    }</a>
<a name="ln816">    // Go to debug mode when returning from a function in which we are</a>
<a name="ln817">    // single-stepping.</a>
<a name="ln818">    if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln819">         || getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln820">        &amp;&amp; ex_nesting_level + 1 &lt;= debug_break_level) {</a>
<a name="ln821">      do_debug(getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln822">               ? _(&quot;End of sourced file&quot;)</a>
<a name="ln823">               : _(&quot;End of function&quot;));</a>
<a name="ln824">    }</a>
<a name="ln825">  }</a>
<a name="ln826"> </a>
<a name="ln827">  // Restore the exception environment (done after returning from the</a>
<a name="ln828">  // debugger).</a>
<a name="ln829">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln830">    restore_dbg_stuff(&amp;debug_saved);</a>
<a name="ln831">  }</a>
<a name="ln832"> </a>
<a name="ln833">  msg_list = saved_msg_list;</a>
<a name="ln834"> </a>
<a name="ln835">  // Cleanup if &quot;cs_emsg_silent_list&quot; remains.</a>
<a name="ln836">  if (cstack.cs_emsg_silent_list != NULL) {</a>
<a name="ln837">    eslist_T *elem, *temp;</a>
<a name="ln838">    for (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp) {</a>
<a name="ln839">      temp = elem-&gt;next;</a>
<a name="ln840">      xfree(elem);</a>
<a name="ln841">    }</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  // If there was too much output to fit on the command line, ask the user to</a>
<a name="ln845">  // hit return before redrawing the screen. With the &quot;:global&quot; command we do</a>
<a name="ln846">  // this only once after the command is finished.</a>
<a name="ln847">  if (did_inc) {</a>
<a name="ln848">    RedrawingDisabled--;</a>
<a name="ln849">    no_wait_return--;</a>
<a name="ln850">    msg_scroll = false;</a>
<a name="ln851"> </a>
<a name="ln852">    // When just finished an &quot;:if&quot;-&quot;:else&quot; which was typed, no need to</a>
<a name="ln853">    // wait for hit-return.  Also for an error situation.</a>
<a name="ln854">    if (retval == FAIL</a>
<a name="ln855">        || (did_endif &amp;&amp; KeyTyped &amp;&amp; !did_emsg)) {</a>
<a name="ln856">      need_wait_return = false;</a>
<a name="ln857">      msg_didany = false;               // don't wait when restarting edit</a>
<a name="ln858">    } else if (need_wait_return) {</a>
<a name="ln859">      // The msg_start() above clears msg_didout. The wait_return() we do</a>
<a name="ln860">      // here should not overwrite the command that may be shown before</a>
<a name="ln861">      // doing that.</a>
<a name="ln862">      msg_didout |= msg_didout_before_start;</a>
<a name="ln863">      wait_return(false);</a>
<a name="ln864">    }</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  did_endif = false;    // in case do_cmdline used recursively</a>
<a name="ln868"> </a>
<a name="ln869">  call_depth--;</a>
<a name="ln870">  end_batch_changes();</a>
<a name="ln871">  return retval;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">/// Handle when &quot;did_throw&quot; is set after executing commands.</a>
<a name="ln875">void handle_did_throw(void)</a>
<a name="ln876">{</a>
<a name="ln877">  assert(current_exception != NULL);</a>
<a name="ln878">  char *p = NULL;</a>
<a name="ln879">  msglist_T *messages = NULL;</a>
<a name="ln880"> </a>
<a name="ln881">  // If the uncaught exception is a user exception, report it as an</a>
<a name="ln882">  // error.  If it is an error exception, display the saved error</a>
<a name="ln883">  // message now.  For an interrupt exception, do nothing; the</a>
<a name="ln884">  // interrupt message is given elsewhere.</a>
<a name="ln885">  switch (current_exception-&gt;type) {</a>
<a name="ln886">  case ET_USER:</a>
<a name="ln887">    vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln888">                 _(&quot;E605: Exception not caught: %s&quot;),</a>
<a name="ln889">                 current_exception-&gt;value);</a>
<a name="ln890">    p = xstrdup(IObuff);</a>
<a name="ln891">    break;</a>
<a name="ln892">  case ET_ERROR:</a>
<a name="ln893">    messages = current_exception-&gt;messages;</a>
<a name="ln894">    current_exception-&gt;messages = NULL;</a>
<a name="ln895">    break;</a>
<a name="ln896">  case ET_INTERRUPT:</a>
<a name="ln897">    break;</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  estack_push(ETYPE_EXCEPT, current_exception-&gt;throw_name, current_exception-&gt;throw_lnum);</a>
<a name="ln901">  current_exception-&gt;throw_name = NULL;</a>
<a name="ln902"> </a>
<a name="ln903">  discard_current_exception();              // uses IObuff if 'verbose'</a>
<a name="ln904">  suppress_errthrow = true;</a>
<a name="ln905">  force_abort = true;</a>
<a name="ln906">  msg_ext_set_kind(&quot;emsg&quot;);  // kind=emsg for :throw, exceptions. #9993</a>
<a name="ln907"> </a>
<a name="ln908">  if (messages != NULL) {</a>
<a name="ln909">    do {</a>
<a name="ln910">      msglist_T *next = messages-&gt;next;</a>
<a name="ln911">      emsg_multiline(messages-&gt;msg, messages-&gt;multiline);</a>
<a name="ln912">      xfree(messages-&gt;msg);</a>
<a name="ln913">      xfree(messages-&gt;sfile);</a>
<a name="ln914">      xfree(messages);</a>
<a name="ln915">      messages = next;</a>
<a name="ln916">    } while (messages != NULL);</a>
<a name="ln917">  } else if (p != NULL) {</a>
<a name="ln918">    emsg(p);</a>
<a name="ln919">    xfree(p);</a>
<a name="ln920">  }</a>
<a name="ln921">  xfree(SOURCING_NAME);</a>
<a name="ln922">  estack_pop();</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">/// Obtain a line when inside a &quot;:while&quot; or &quot;:for&quot; loop.</a>
<a name="ln926">static char *get_loop_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln927">{</a>
<a name="ln928">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln929"> </a>
<a name="ln930">  if (cp-&gt;current_line + 1 &gt;= cp-&gt;lines_gap-&gt;ga_len) {</a>
<a name="ln931">    if (cp-&gt;repeating) {</a>
<a name="ln932">      return NULL;              // trying to read past &quot;:endwhile&quot;/&quot;:endfor&quot;</a>
<a name="ln933">    }</a>
<a name="ln934">    char *line;</a>
<a name="ln935">    // First time inside the &quot;:while&quot;/&quot;:for&quot;: get line normally.</a>
<a name="ln936">    if (cp-&gt;getline == NULL) {</a>
<a name="ln937">      line = getcmdline(c, 0L, indent, do_concat);</a>
<a name="ln938">    } else {</a>
<a name="ln939">      line = cp-&gt;getline(c, cp-&gt;cookie, indent, do_concat);</a>
<a name="ln940">    }</a>
<a name="ln941">    if (line != NULL) {</a>
<a name="ln942">      store_loop_line(cp-&gt;lines_gap, line);</a>
<a name="ln943">      cp-&gt;current_line++;</a>
<a name="ln944">    }</a>
<a name="ln945"> </a>
<a name="ln946">    return line;</a>
<a name="ln947">  }</a>
<a name="ln948"> </a>
<a name="ln949">  KeyTyped = false;</a>
<a name="ln950">  cp-&gt;current_line++;</a>
<a name="ln951">  wcmd_T *wp = (wcmd_T *)(cp-&gt;lines_gap-&gt;ga_data) + cp-&gt;current_line;</a>
<a name="ln952">  SOURCING_LNUM = wp-&gt;lnum;</a>
<a name="ln953">  return xstrdup(wp-&gt;line);</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">/// Store a line in &quot;gap&quot; so that a &quot;:while&quot; loop can execute it again.</a>
<a name="ln957">static void store_loop_line(garray_T *gap, char *line)</a>
<a name="ln958">{</a>
<a name="ln959">  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);</a>
<a name="ln960">  p-&gt;line = xstrdup(line);</a>
<a name="ln961">  p-&gt;lnum = SOURCING_LNUM;</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">/// If &quot;fgetline&quot; is get_loop_line(), return true if the getline it uses equals</a>
<a name="ln965">/// &quot;func&quot;.  * Otherwise return true when &quot;fgetline&quot; equals &quot;func&quot;.</a>
<a name="ln966">///</a>
<a name="ln967">/// @param cookie  argument for fgetline()</a>
<a name="ln968">bool getline_equal(LineGetter fgetline, void *cookie, LineGetter func)</a>
<a name="ln969">{</a>
<a name="ln970">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln971">  // function that's originally used to obtain the lines.  This may be</a>
<a name="ln972">  // nested several levels.</a>
<a name="ln973">  LineGetter gp = fgetline;</a>
<a name="ln974">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln975">  while (gp == get_loop_line) {</a>
<a name="ln976">    gp = cp-&gt;getline;</a>
<a name="ln977">    cp = cp-&gt;cookie;</a>
<a name="ln978">  }</a>
<a name="ln979">  return gp == func;</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">/// If &quot;fgetline&quot; is get_loop_line(), return the cookie used by the original</a>
<a name="ln983">/// getline function.  Otherwise return &quot;cookie&quot;.</a>
<a name="ln984">///</a>
<a name="ln985">/// @param cookie  argument for fgetline()</a>
<a name="ln986">void *getline_cookie(LineGetter fgetline, void *cookie)</a>
<a name="ln987">{</a>
<a name="ln988">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln989">  // cookie that's originally used to obtain the lines.  This may be nested</a>
<a name="ln990">  // several levels.</a>
<a name="ln991">  LineGetter gp = fgetline;</a>
<a name="ln992">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln993">  while (gp == get_loop_line) {</a>
<a name="ln994">    gp = cp-&gt;getline;</a>
<a name="ln995">    cp = cp-&gt;cookie;</a>
<a name="ln996">  }</a>
<a name="ln997">  return cp;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">/// Helper function to apply an offset for buffer commands, i.e. &quot;:bdelete&quot;,</a>
<a name="ln1001">/// &quot;:bwipeout&quot;, etc.</a>
<a name="ln1002">///</a>
<a name="ln1003">/// @return  the buffer number.</a>
<a name="ln1004">static int compute_buffer_local_count(cmd_addr_T addr_type, linenr_T lnum, int offset)</a>
<a name="ln1005">{</a>
<a name="ln1006">  buf_T *nextbuf;</a>
<a name="ln1007">  int count = offset;</a>
<a name="ln1008"> </a>
<a name="ln1009">  buf_T *buf = firstbuf;</a>
<a name="ln1010">  while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_fnum &lt; lnum) {</a>
<a name="ln1011">    buf = buf-&gt;b_next;</a>
<a name="ln1012">  }</a>
<a name="ln1013">  while (count != 0) {</a>
<a name="ln1014">    count += (count &lt; 0) ? 1 : -1;</a>
<a name="ln1015">    nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1016">    if (nextbuf == NULL) {</a>
<a name="ln1017">      break;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    buf = nextbuf;</a>
<a name="ln1020">    if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1021">      // skip over unloaded buffers</a>
<a name="ln1022">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1023">        nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1024">        if (nextbuf == NULL) {</a>
<a name="ln1025">          break;</a>
<a name="ln1026">        }</a>
<a name="ln1027">        buf = nextbuf;</a>
<a name="ln1028">      }</a>
<a name="ln1029">    }</a>
<a name="ln1030">  }</a>
<a name="ln1031">  // we might have gone too far, last buffer is not loaded</a>
<a name="ln1032">  if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1033">    while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1034">      nextbuf = (offset &gt;= 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1035">      if (nextbuf == NULL) {</a>
<a name="ln1036">        break;</a>
<a name="ln1037">      }</a>
<a name="ln1038">      buf = nextbuf;</a>
<a name="ln1039">    }</a>
<a name="ln1040">  }</a>
<a name="ln1041">  return buf-&gt;b_fnum;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/// @return  the window number of &quot;win&quot; or,</a>
<a name="ln1045">///          the number of windows if &quot;win&quot; is NULL</a>
<a name="ln1046">static int current_win_nr(const win_T *win)</a>
<a name="ln1047">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1048">{</a>
<a name="ln1049">  int nr = 0;</a>
<a name="ln1050"> </a>
<a name="ln1051">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1052">    nr++;</a>
<a name="ln1053">    if (wp == win) {</a>
<a name="ln1054">      break;</a>
<a name="ln1055">    }</a>
<a name="ln1056">  }</a>
<a name="ln1057">  return nr;</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">static int current_tab_nr(tabpage_T *tab)</a>
<a name="ln1061">{</a>
<a name="ln1062">  int nr = 0;</a>
<a name="ln1063"> </a>
<a name="ln1064">  FOR_ALL_TABS(tp) {</a>
<a name="ln1065">    nr++;</a>
<a name="ln1066">    if (tp == tab) {</a>
<a name="ln1067">      break;</a>
<a name="ln1068">    }</a>
<a name="ln1069">  }</a>
<a name="ln1070">  return nr;</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">#define CURRENT_WIN_NR current_win_nr(curwin)</a>
<a name="ln1074">#define LAST_WIN_NR current_win_nr(NULL)</a>
<a name="ln1075">#define CURRENT_TAB_NR current_tab_nr(curtab)</a>
<a name="ln1076">#define LAST_TAB_NR current_tab_nr(NULL)</a>
<a name="ln1077"> </a>
<a name="ln1078">/// Figure out the address type for &quot;:wincmd&quot;.</a>
<a name="ln1079">static void get_wincmd_addr_type(const char *arg, exarg_T *eap)</a>
<a name="ln1080">{</a>
<a name="ln1081">  switch (*arg) {</a>
<a name="ln1082">  case 'S':</a>
<a name="ln1083">  case Ctrl_S:</a>
<a name="ln1084">  case 's':</a>
<a name="ln1085">  case Ctrl_N:</a>
<a name="ln1086">  case 'n':</a>
<a name="ln1087">  case 'j':</a>
<a name="ln1088">  case Ctrl_J:</a>
<a name="ln1089">  case 'k':</a>
<a name="ln1090">  case Ctrl_K:</a>
<a name="ln1091">  case 'T':</a>
<a name="ln1092">  case Ctrl_R:</a>
<a name="ln1093">  case 'r':</a>
<a name="ln1094">  case 'R':</a>
<a name="ln1095">  case 'K':</a>
<a name="ln1096">  case 'J':</a>
<a name="ln1097">  case '+':</a>
<a name="ln1098">  case '-':</a>
<a name="ln1099">  case Ctrl__:</a>
<a name="ln1100">  case '_':</a>
<a name="ln1101">  case '|':</a>
<a name="ln1102">  case ']':</a>
<a name="ln1103">  case Ctrl_RSB:</a>
<a name="ln1104">  case 'g':</a>
<a name="ln1105">  case Ctrl_G:</a>
<a name="ln1106">  case Ctrl_V:</a>
<a name="ln1107">  case 'v':</a>
<a name="ln1108">  case 'h':</a>
<a name="ln1109">  case Ctrl_H:</a>
<a name="ln1110">  case 'l':</a>
<a name="ln1111">  case Ctrl_L:</a>
<a name="ln1112">  case 'H':</a>
<a name="ln1113">  case 'L':</a>
<a name="ln1114">  case '&gt;':</a>
<a name="ln1115">  case '&lt;':</a>
<a name="ln1116">  case '}':</a>
<a name="ln1117">  case 'f':</a>
<a name="ln1118">  case 'F':</a>
<a name="ln1119">  case Ctrl_F:</a>
<a name="ln1120">  case 'i':</a>
<a name="ln1121">  case Ctrl_I:</a>
<a name="ln1122">  case 'd':</a>
<a name="ln1123">  case Ctrl_D:</a>
<a name="ln1124">    // window size or any count</a>
<a name="ln1125">    eap-&gt;addr_type = ADDR_OTHER;  // -V1037</a>
<a name="ln1126">    break;</a>
<a name="ln1127"> </a>
<a name="ln1128">  case Ctrl_HAT:</a>
<a name="ln1129">  case '^':</a>
<a name="ln1130">    // buffer number</a>
<a name="ln1131">    eap-&gt;addr_type = ADDR_BUFFERS;</a>
<a name="ln1132">    break;</a>
<a name="ln1133"> </a>
<a name="ln1134">  case Ctrl_Q:</a>
<a name="ln1135">  case 'q':</a>
<a name="ln1136">  case Ctrl_C:</a>
<a name="ln1137">  case 'c':</a>
<a name="ln1138">  case Ctrl_O:</a>
<a name="ln1139">  case 'o':</a>
<a name="ln1140">  case Ctrl_W:</a>
<a name="ln1141">  case 'w':</a>
<a name="ln1142">  case 'W':</a>
<a name="ln1143">  case 'x':</a>
<a name="ln1144">  case Ctrl_X:</a>
<a name="ln1145">    // window number</a>
<a name="ln1146">    eap-&gt;addr_type = ADDR_WINDOWS;</a>
<a name="ln1147">    break;</a>
<a name="ln1148"> </a>
<a name="ln1149">  case Ctrl_Z:</a>
<a name="ln1150">  case 'z':</a>
<a name="ln1151">  case 'P':</a>
<a name="ln1152">  case 't':</a>
<a name="ln1153">  case Ctrl_T:</a>
<a name="ln1154">  case 'b':</a>
<a name="ln1155">  case Ctrl_B:</a>
<a name="ln1156">  case 'p':</a>
<a name="ln1157">  case Ctrl_P:</a>
<a name="ln1158">  case '=':</a>
<a name="ln1159">  case CAR:</a>
<a name="ln1160">    // no count</a>
<a name="ln1161">    eap-&gt;addr_type = ADDR_NONE;</a>
<a name="ln1162">    break;</a>
<a name="ln1163">  }</a>
<a name="ln1164">}</a>
<a name="ln1165"> </a>
<a name="ln1166">/// Skip colons and trailing whitespace, returning a pointer to the first</a>
<a name="ln1167">/// non-colon, non-whitespace character.</a>
<a name="ln1168">//</a>
<a name="ln1169">/// @param skipleadingwhite Skip leading whitespace too</a>
<a name="ln1170">static char *skip_colon_white(const char *p, bool skipleadingwhite)</a>
<a name="ln1171">{</a>
<a name="ln1172">  if (skipleadingwhite) {</a>
<a name="ln1173">    p = skipwhite(p);</a>
<a name="ln1174">  }</a>
<a name="ln1175"> </a>
<a name="ln1176">  while (*p == ':') {</a>
<a name="ln1177">    p = skipwhite(p + 1);</a>
<a name="ln1178">  }</a>
<a name="ln1179"> </a>
<a name="ln1180">  return (char *)p;</a>
<a name="ln1181">}</a>
<a name="ln1182"> </a>
<a name="ln1183">/// Set the addr type for command</a>
<a name="ln1184">///</a>
<a name="ln1185">/// @param p pointer to character after command name in cmdline</a>
<a name="ln1186">void set_cmd_addr_type(exarg_T *eap, char *p)</a>
<a name="ln1187">{</a>
<a name="ln1188">  // ea.addr_type for user commands is set by find_ucmd</a>
<a name="ln1189">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1190">    return;</a>
<a name="ln1191">  }</a>
<a name="ln1192">  if (eap-&gt;cmdidx != CMD_SIZE) {</a>
<a name="ln1193">    eap-&gt;addr_type = cmdnames[(int)eap-&gt;cmdidx].cmd_addr_type;</a>
<a name="ln1194">  } else {</a>
<a name="ln1195">    eap-&gt;addr_type = ADDR_LINES;</a>
<a name="ln1196">  }</a>
<a name="ln1197">  // :wincmd range depends on the argument</a>
<a name="ln1198">  if (eap-&gt;cmdidx == CMD_wincmd &amp;&amp; p != NULL) {</a>
<a name="ln1199">    get_wincmd_addr_type(skipwhite(p), eap);</a>
<a name="ln1200">  }</a>
<a name="ln1201">  // :.cc in quickfix window uses line number</a>
<a name="ln1202">  if ((eap-&gt;cmdidx == CMD_cc || eap-&gt;cmdidx == CMD_ll) &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln1203">    eap-&gt;addr_type = ADDR_OTHER;</a>
<a name="ln1204">  }</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">/// Get default range number for command based on its address type</a>
<a name="ln1208">linenr_T get_cmd_default_range(exarg_T *eap)</a>
<a name="ln1209">{</a>
<a name="ln1210">  switch (eap-&gt;addr_type) {</a>
<a name="ln1211">  case ADDR_LINES:</a>
<a name="ln1212">  case ADDR_OTHER:</a>
<a name="ln1213">    // Default is the cursor line number.  Avoid using an invalid</a>
<a name="ln1214">    // line number though.</a>
<a name="ln1215">    return MIN(curwin-&gt;w_cursor.lnum, curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln1216">    break;</a>
<a name="ln1217">  case ADDR_WINDOWS:</a>
<a name="ln1218">    return CURRENT_WIN_NR;</a>
<a name="ln1219">    break;</a>
<a name="ln1220">  case ADDR_ARGUMENTS:</a>
<a name="ln1221">    return MIN(curwin-&gt;w_arg_idx + 1, ARGCOUNT);</a>
<a name="ln1222">    break;</a>
<a name="ln1223">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1224">  case ADDR_BUFFERS:</a>
<a name="ln1225">    return curbuf-&gt;b_fnum;</a>
<a name="ln1226">    break;</a>
<a name="ln1227">  case ADDR_TABS:</a>
<a name="ln1228">    return CURRENT_TAB_NR;</a>
<a name="ln1229">    break;</a>
<a name="ln1230">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1231">  case ADDR_UNSIGNED:</a>
<a name="ln1232">    return 1;</a>
<a name="ln1233">    break;</a>
<a name="ln1234">  case ADDR_QUICKFIX:</a>
<a name="ln1235">    return (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln1236">    break;</a>
<a name="ln1237">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1238">    return qf_get_cur_valid_idx(eap);</a>
<a name="ln1239">    break;</a>
<a name="ln1240">  default:</a>
<a name="ln1241">    return 0;</a>
<a name="ln1242">    // Will give an error later if a range is found.</a>
<a name="ln1243">    break;</a>
<a name="ln1244">  }</a>
<a name="ln1245">}</a>
<a name="ln1246"> </a>
<a name="ln1247">/// Set default command range for -range=% based on the addr type of the command</a>
<a name="ln1248">void set_cmd_dflall_range(exarg_T *eap)</a>
<a name="ln1249">{</a>
<a name="ln1250">  buf_T *buf;</a>
<a name="ln1251"> </a>
<a name="ln1252">  eap-&gt;line1 = 1;</a>
<a name="ln1253">  switch (eap-&gt;addr_type) {</a>
<a name="ln1254">  case ADDR_LINES:</a>
<a name="ln1255">  case ADDR_OTHER:</a>
<a name="ln1256">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1257">    break;</a>
<a name="ln1258">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1259">    buf = firstbuf;</a>
<a name="ln1260">    while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1261">      buf = buf-&gt;b_next;</a>
<a name="ln1262">    }</a>
<a name="ln1263">    eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln1264">    buf = lastbuf;</a>
<a name="ln1265">    while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1266">      buf = buf-&gt;b_prev;</a>
<a name="ln1267">    }</a>
<a name="ln1268">    eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln1269">    break;</a>
<a name="ln1270">  case ADDR_BUFFERS:</a>
<a name="ln1271">    eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln1272">    eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln1273">    break;</a>
<a name="ln1274">  case ADDR_WINDOWS:</a>
<a name="ln1275">    eap-&gt;line2 = LAST_WIN_NR;</a>
<a name="ln1276">    break;</a>
<a name="ln1277">  case ADDR_TABS:</a>
<a name="ln1278">    eap-&gt;line2 = LAST_TAB_NR;</a>
<a name="ln1279">    break;</a>
<a name="ln1280">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1281">    eap-&gt;line2 = 1;</a>
<a name="ln1282">    break;</a>
<a name="ln1283">  case ADDR_ARGUMENTS:</a>
<a name="ln1284">    if (ARGCOUNT == 0) {</a>
<a name="ln1285">      eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln1286">    } else {</a>
<a name="ln1287">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln1288">    }</a>
<a name="ln1289">    break;</a>
<a name="ln1290">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1291">    eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln1292">    if (eap-&gt;line2 == 0) {</a>
<a name="ln1293">      eap-&gt;line2 = 1;</a>
<a name="ln1294">    }</a>
<a name="ln1295">    break;</a>
<a name="ln1296">  case ADDR_NONE:</a>
<a name="ln1297">  case ADDR_UNSIGNED:</a>
<a name="ln1298">  case ADDR_QUICKFIX:</a>
<a name="ln1299">    iemsg(_(&quot;INTERNAL: Cannot use EX_DFLALL &quot;</a>
<a name="ln1300">            &quot;with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX&quot;));</a>
<a name="ln1301">    break;</a>
<a name="ln1302">  }</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">static void parse_register(exarg_T *eap)</a>
<a name="ln1306">{</a>
<a name="ln1307">  // Accept numbered register only when no count allowed (:put)</a>
<a name="ln1308">  if ((eap-&gt;argt &amp; EX_REGSTR)</a>
<a name="ln1309">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln1310">      // Do not allow register = for user commands</a>
<a name="ln1311">      &amp;&amp; (!IS_USER_CMDIDX(eap-&gt;cmdidx) || *eap-&gt;arg != '=')</a>
<a name="ln1312">      &amp;&amp; !((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg))) {</a>
<a name="ln1313">    if (valid_yank_reg(*eap-&gt;arg, (eap-&gt;cmdidx != CMD_put</a>
<a name="ln1314">                                   &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)))) {</a>
<a name="ln1315">      eap-&gt;regname = (uint8_t)(*eap-&gt;arg++);</a>
<a name="ln1316">      // for '=' register: accept the rest of the line as an expression</a>
<a name="ln1317">      if (eap-&gt;arg[-1] == '=' &amp;&amp; eap-&gt;arg[0] != NUL) {</a>
<a name="ln1318">        if (!eap-&gt;skip) {</a>
<a name="ln1319">          set_expr_line(xstrdup(eap-&gt;arg));</a>
<a name="ln1320">        }</a>
<a name="ln1321">        eap-&gt;arg += strlen(eap-&gt;arg);</a>
<a name="ln1322">      }</a>
<a name="ln1323">      eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1324">    }</a>
<a name="ln1325">  }</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">// Change line1 and line2 of Ex command to use count</a>
<a name="ln1329">void set_cmd_count(exarg_T *eap, linenr_T count, bool validate)</a>
<a name="ln1330">{</a>
<a name="ln1331">  if (eap-&gt;addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3</a>
<a name="ln1332">    eap-&gt;line2 = count;</a>
<a name="ln1333">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln1334">      eap-&gt;addr_count = 1;</a>
<a name="ln1335">    }</a>
<a name="ln1336">  } else {</a>
<a name="ln1337">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln1338">    eap-&gt;line2 += count - 1;</a>
<a name="ln1339">    eap-&gt;addr_count++;</a>
<a name="ln1340">    // Be vi compatible: no error message for out of range.</a>
<a name="ln1341">    if (validate &amp;&amp; eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1342">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1343">    }</a>
<a name="ln1344">  }</a>
<a name="ln1345">}</a>
<a name="ln1346"> </a>
<a name="ln1347">static int parse_count(exarg_T *eap, const char **errormsg, bool validate)</a>
<a name="ln1348">{</a>
<a name="ln1349">  // Check for a count.  When accepting a EX_BUFNAME, don't use &quot;123foo&quot; as a</a>
<a name="ln1350">  // count, it's a buffer name.</a>
<a name="ln1351">  char *p;</a>
<a name="ln1352"> </a>
<a name="ln1353">  if ((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg)</a>
<a name="ln1354">      &amp;&amp; (!(eap-&gt;argt &amp; EX_BUFNAME) || *(p = skipdigits(eap-&gt;arg + 1)) == NUL</a>
<a name="ln1355">          || ascii_iswhite(*p))) {</a>
<a name="ln1356">    linenr_T n = getdigits_int32(&amp;eap-&gt;arg, false, -1);</a>
<a name="ln1357">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1358"> </a>
<a name="ln1359">    if (eap-&gt;args != NULL) {</a>
<a name="ln1360">      assert(eap-&gt;argc &gt; 0 &amp;&amp; eap-&gt;arg &gt;= eap-&gt;args[0]);</a>
<a name="ln1361">      // If eap-&gt;arg is still pointing to the first argument, just make eap-&gt;args[0] point to the</a>
<a name="ln1362">      // same location. This is needed for usecases like vim.cmd.sleep('10m'). If eap-&gt;arg is</a>
<a name="ln1363">      // pointing outside the first argument, shift arguments by 1.</a>
<a name="ln1364">      if (eap-&gt;arg &lt; eap-&gt;args[0] + eap-&gt;arglens[0]) {</a>
<a name="ln1365">        eap-&gt;arglens[0] -= (size_t)(eap-&gt;arg - eap-&gt;args[0]);</a>
<a name="ln1366">        eap-&gt;args[0] = eap-&gt;arg;</a>
<a name="ln1367">      } else {</a>
<a name="ln1368">        shift_cmd_args(eap);</a>
<a name="ln1369">      }</a>
<a name="ln1370">    }</a>
<a name="ln1371"> </a>
<a name="ln1372">    if (n &lt;= 0 &amp;&amp; (eap-&gt;argt &amp; EX_ZEROR) == 0) {</a>
<a name="ln1373">      if (errormsg != NULL) {</a>
<a name="ln1374">        *errormsg = _(e_zerocount);</a>
<a name="ln1375">      }</a>
<a name="ln1376">      return FAIL;</a>
<a name="ln1377">    }</a>
<a name="ln1378">    set_cmd_count(eap, n, validate);</a>
<a name="ln1379">  }</a>
<a name="ln1380"> </a>
<a name="ln1381">  return OK;</a>
<a name="ln1382">}</a>
<a name="ln1383"> </a>
<a name="ln1384">/// Check if command is not implemented</a>
<a name="ln1385">bool is_cmd_ni(cmdidx_T cmdidx)</a>
<a name="ln1386">{</a>
<a name="ln1387">  return !IS_USER_CMDIDX(cmdidx) &amp;&amp; (cmdnames[cmdidx].cmd_func == ex_ni</a>
<a name="ln1388">                                     || cmdnames[cmdidx].cmd_func == ex_script_ni);</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">/// Parse command line and return information about the first command.</a>
<a name="ln1392">/// If parsing is done successfully, need to free cmod_filter_pat and cmod_filter_regmatch.regprog</a>
<a name="ln1393">/// after calling, usually done using undo_cmdmod() or execute_cmd().</a>
<a name="ln1394">///</a>
<a name="ln1395">/// @param cmdline Command line string</a>
<a name="ln1396">/// @param[out] eap Ex command arguments</a>
<a name="ln1397">/// @param[out] cmdinfo Command parse information</a>
<a name="ln1398">/// @param[out] errormsg Error message, if any</a>
<a name="ln1399">///</a>
<a name="ln1400">/// @return Success or failure</a>
<a name="ln1401">bool parse_cmdline(char *cmdline, exarg_T *eap, CmdParseInfo *cmdinfo, const char **errormsg)</a>
<a name="ln1402">{</a>
<a name="ln1403">  char *after_modifier = NULL;</a>
<a name="ln1404">  bool retval = false;</a>
<a name="ln1405">  // parsing the command modifiers may set ex_pressedreturn</a>
<a name="ln1406">  const bool save_ex_pressedreturn = ex_pressedreturn;</a>
<a name="ln1407">  // parsing the command range may require moving the cursor</a>
<a name="ln1408">  const pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln1409">  // parsing the command range may set the last search pattern</a>
<a name="ln1410">  save_last_search_pattern();</a>
<a name="ln1411"> </a>
<a name="ln1412">  // Initialize cmdinfo</a>
<a name="ln1413">  CLEAR_POINTER(cmdinfo);</a>
<a name="ln1414"> </a>
<a name="ln1415">  // Initialize eap</a>
<a name="ln1416">  *eap = (exarg_T){</a>
<a name="ln1417">    .line1 = 1,</a>
<a name="ln1418">    .line2 = 1,</a>
<a name="ln1419">    .cmd = cmdline,</a>
<a name="ln1420">    .cmdlinep = &amp;cmdline,</a>
<a name="ln1421">    .getline = NULL,</a>
<a name="ln1422">    .cookie = NULL,</a>
<a name="ln1423">  };</a>
<a name="ln1424"> </a>
<a name="ln1425">  // Parse command modifiers</a>
<a name="ln1426">  if (parse_command_modifiers(eap, errormsg, &amp;cmdinfo-&gt;cmdmod, false) == FAIL) {</a>
<a name="ln1427">    goto end;</a>
<a name="ln1428">  }</a>
<a name="ln1429">  after_modifier = eap-&gt;cmd;</a>
<a name="ln1430"> </a>
<a name="ln1431">  // Save location after command modifiers</a>
<a name="ln1432">  char *cmd = eap-&gt;cmd;</a>
<a name="ln1433">  // Skip ranges to find command name since we need the command to know what kind of range it uses</a>
<a name="ln1434">  eap-&gt;cmd = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln1435">  if (*eap-&gt;cmd == '*') {</a>
<a name="ln1436">    eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln1437">  }</a>
<a name="ln1438">  char *p = find_ex_command(eap, NULL);</a>
<a name="ln1439">  if (p == NULL) {</a>
<a name="ln1440">    *errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln1441">    goto end;</a>
<a name="ln1442">  }</a>
<a name="ln1443"> </a>
<a name="ln1444">  // Set command address type and parse command range</a>
<a name="ln1445">  set_cmd_addr_type(eap, p);</a>
<a name="ln1446">  eap-&gt;cmd = cmd;</a>
<a name="ln1447">  if (parse_cmd_address(eap, errormsg, true) == FAIL) {</a>
<a name="ln1448">    goto end;</a>
<a name="ln1449">  }</a>
<a name="ln1450"> </a>
<a name="ln1451">  // Skip colon and whitespace</a>
<a name="ln1452">  eap-&gt;cmd = skip_colon_white(eap-&gt;cmd, true);</a>
<a name="ln1453">  // Fail if command is a comment or if command doesn't exist</a>
<a name="ln1454">  if (*eap-&gt;cmd == NUL || *eap-&gt;cmd == '&quot;') {</a>
<a name="ln1455">    goto end;</a>
<a name="ln1456">  }</a>
<a name="ln1457">  // Fail if command is invalid</a>
<a name="ln1458">  if (eap-&gt;cmdidx == CMD_SIZE) {</a>
<a name="ln1459">    xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln1460">    // If the modifier was parsed OK the error must be in the following command</a>
<a name="ln1461">    char *cmdname = after_modifier ? after_modifier : cmdline;</a>
<a name="ln1462">    append_command(cmdname);</a>
<a name="ln1463">    *errormsg = IObuff;</a>
<a name="ln1464">    goto end;</a>
<a name="ln1465">  }</a>
<a name="ln1466"> </a>
<a name="ln1467">  // Correctly set 'forceit' for commands</a>
<a name="ln1468">  if (*p == '!' &amp;&amp; eap-&gt;cmdidx != CMD_substitute</a>
<a name="ln1469">      &amp;&amp; eap-&gt;cmdidx != CMD_smagic &amp;&amp; eap-&gt;cmdidx != CMD_snomagic) {</a>
<a name="ln1470">    p++;</a>
<a name="ln1471">    eap-&gt;forceit = true;</a>
<a name="ln1472">  } else {</a>
<a name="ln1473">    eap-&gt;forceit = false;</a>
<a name="ln1474">  }</a>
<a name="ln1475"> </a>
<a name="ln1476">  // Parse arguments.</a>
<a name="ln1477">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1478">    eap-&gt;argt = cmdnames[(int)eap-&gt;cmdidx].cmd_argt;</a>
<a name="ln1479">  }</a>
<a name="ln1480">  // Skip to start of argument.</a>
<a name="ln1481">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln1482">  if (eap-&gt;cmdidx == CMD_bang) {</a>
<a name="ln1483">    eap-&gt;arg = p;</a>
<a name="ln1484">  } else {</a>
<a name="ln1485">    eap-&gt;arg = skipwhite(p);</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  // Don't treat &quot;:r! filter&quot; like a bang</a>
<a name="ln1489">  if (eap-&gt;cmdidx == CMD_read) {</a>
<a name="ln1490">    if (eap-&gt;forceit) {</a>
<a name="ln1491">      eap-&gt;forceit = false;                     // :r! filter</a>
<a name="ln1492">    }</a>
<a name="ln1493">  }</a>
<a name="ln1494"> </a>
<a name="ln1495">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln1496">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1497">  if ((eap-&gt;argt &amp; EX_TRLBAR)) {</a>
<a name="ln1498">    separate_nextcmd(eap);</a>
<a name="ln1499">  }</a>
<a name="ln1500">  // Fail if command doesn't support bang but is used with a bang</a>
<a name="ln1501">  if (!(eap-&gt;argt &amp; EX_BANG) &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln1502">    *errormsg = _(e_nobang);</a>
<a name="ln1503">    goto end;</a>
<a name="ln1504">  }</a>
<a name="ln1505">  // Fail if command doesn't support a range but it is given a range</a>
<a name="ln1506">  if (!(eap-&gt;argt &amp; EX_RANGE) &amp;&amp; eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1507">    *errormsg = _(e_norange);</a>
<a name="ln1508">    goto end;</a>
<a name="ln1509">  }</a>
<a name="ln1510">  // Set default range for command if required</a>
<a name="ln1511">  if ((eap-&gt;argt &amp; EX_DFLALL) &amp;&amp; eap-&gt;addr_count == 0) {</a>
<a name="ln1512">    set_cmd_dflall_range(eap);</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  // Parse register and count</a>
<a name="ln1516">  parse_register(eap);</a>
<a name="ln1517">  if (parse_count(eap, errormsg, false) == FAIL) {</a>
<a name="ln1518">    goto end;</a>
<a name="ln1519">  }</a>
<a name="ln1520"> </a>
<a name="ln1521">  // Remove leading whitespace and colon from next command</a>
<a name="ln1522">  if (eap-&gt;nextcmd) {</a>
<a name="ln1523">    eap-&gt;nextcmd = skip_colon_white(eap-&gt;nextcmd, true);</a>
<a name="ln1524">  }</a>
<a name="ln1525"> </a>
<a name="ln1526">  // Set the &quot;magic&quot; values (characters that get treated specially)</a>
<a name="ln1527">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1528">    cmdinfo-&gt;magic.file = true;</a>
<a name="ln1529">  }</a>
<a name="ln1530">  if (eap-&gt;argt &amp; EX_TRLBAR) {</a>
<a name="ln1531">    cmdinfo-&gt;magic.bar = true;</a>
<a name="ln1532">  }</a>
<a name="ln1533"> </a>
<a name="ln1534">  retval = true;</a>
<a name="ln1535">end:</a>
<a name="ln1536">  if (!retval) {</a>
<a name="ln1537">    undo_cmdmod(&amp;cmdinfo-&gt;cmdmod);</a>
<a name="ln1538">  }</a>
<a name="ln1539">  ex_pressedreturn = save_ex_pressedreturn;</a>
<a name="ln1540">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln1541">  restore_last_search_pattern();</a>
<a name="ln1542">  return retval;</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545">// Shift Ex-command arguments to the right.</a>
<a name="ln1546">static void shift_cmd_args(exarg_T *eap)</a>
<a name="ln1547">{</a>
<a name="ln1548">  assert(eap-&gt;args != NULL &amp;&amp; eap-&gt;argc &gt; 0);</a>
<a name="ln1549"> </a>
<a name="ln1550">  char **oldargs = eap-&gt;args;</a>
<a name="ln1551">  size_t *oldarglens = eap-&gt;arglens;</a>
<a name="ln1552"> </a>
<a name="ln1553">  eap-&gt;argc--;</a>
<a name="ln1554">  eap-&gt;args = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(char *)) : NULL;</a>
<a name="ln1555">  eap-&gt;arglens = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(size_t)) : NULL;</a>
<a name="ln1556"> </a>
<a name="ln1557">  for (size_t i = 0; i &lt; eap-&gt;argc; i++) {</a>
<a name="ln1558">    eap-&gt;args[i] = oldargs[i + 1];</a>
<a name="ln1559">    eap-&gt;arglens[i] = oldarglens[i + 1];</a>
<a name="ln1560">  }</a>
<a name="ln1561"> </a>
<a name="ln1562">  // If there are no arguments, make eap-&gt;arg point to the end of string.</a>
<a name="ln1563">  eap-&gt;arg = (eap-&gt;argc &gt; 0 ? eap-&gt;args[0] : (oldargs[0] + oldarglens[0]));</a>
<a name="ln1564"> </a>
<a name="ln1565">  xfree(oldargs);</a>
<a name="ln1566">  xfree(oldarglens);</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">static int execute_cmd0(int *retv, exarg_T *eap, const char **errormsg, bool preview)</a>
<a name="ln1570">{</a>
<a name="ln1571">  // If filename expansion is enabled, expand filenames</a>
<a name="ln1572">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1573">    if (expand_filename(eap, eap-&gt;cmdlinep, errormsg) == FAIL) {</a>
<a name="ln1574">      return FAIL;</a>
<a name="ln1575">    }</a>
<a name="ln1576">  }</a>
<a name="ln1577"> </a>
<a name="ln1578">  // Accept buffer name.  Cannot be used at the same time with a buffer</a>
<a name="ln1579">  // number.  Don't do this for a user command.</a>
<a name="ln1580">  if ((eap-&gt;argt &amp; EX_BUFNAME) &amp;&amp; *eap-&gt;arg != NUL &amp;&amp; eap-&gt;addr_count == 0</a>
<a name="ln1581">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1582">    if (eap-&gt;args == NULL) {</a>
<a name="ln1583">      // If argument positions are not specified, search the argument for the buffer name.</a>
<a name="ln1584">      // :bdelete, :bwipeout and :bunload take several arguments, separated by spaces:</a>
<a name="ln1585">      // find next space (skipping over escaped characters).</a>
<a name="ln1586">      // The others take one argument: ignore trailing spaces.</a>
<a name="ln1587">      char *p;</a>
<a name="ln1588"> </a>
<a name="ln1589">      if (eap-&gt;cmdidx == CMD_bdelete || eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln1590">          || eap-&gt;cmdidx == CMD_bunload) {</a>
<a name="ln1591">        p = skiptowhite_esc(eap-&gt;arg);</a>
<a name="ln1592">      } else {</a>
<a name="ln1593">        p = eap-&gt;arg + strlen(eap-&gt;arg);</a>
<a name="ln1594">        while (p &gt; eap-&gt;arg &amp;&amp; ascii_iswhite(p[-1])) {</a>
<a name="ln1595">          p--;</a>
<a name="ln1596">        }</a>
<a name="ln1597">      }</a>
<a name="ln1598">      eap-&gt;line2 = buflist_findpat(eap-&gt;arg, p, (eap-&gt;argt &amp; EX_BUFUNL) != 0,</a>
<a name="ln1599">                                   false, false);</a>
<a name="ln1600">      eap-&gt;addr_count = 1;</a>
<a name="ln1601">      eap-&gt;arg = skipwhite(p);</a>
<a name="ln1602">    } else {</a>
<a name="ln1603">      // If argument positions are specified, just use the first argument</a>
<a name="ln1604">      eap-&gt;line2 = buflist_findpat(eap-&gt;args[0],</a>
<a name="ln1605">                                   eap-&gt;args[0] + eap-&gt;arglens[0],</a>
<a name="ln1606">                                   (eap-&gt;argt &amp; EX_BUFUNL) != 0, false, false);</a>
<a name="ln1607">      eap-&gt;addr_count = 1;</a>
<a name="ln1608">      shift_cmd_args(eap);</a>
<a name="ln1609">    }</a>
<a name="ln1610">    if (eap-&gt;line2 &lt; 0) {  // failed</a>
<a name="ln1611">      return FAIL;</a>
<a name="ln1612">    }</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  // The :try command saves the emsg_silent flag, reset it here when</a>
<a name="ln1616">  // &quot;:silent! try&quot; was used, it should only apply to :try itself.</a>
<a name="ln1617">  if (eap-&gt;cmdidx == CMD_try &amp;&amp; cmdmod.cmod_did_esilent &gt; 0) {</a>
<a name="ln1618">    emsg_silent -= cmdmod.cmod_did_esilent;</a>
<a name="ln1619">    if (emsg_silent &lt; 0) {</a>
<a name="ln1620">      emsg_silent = 0;</a>
<a name="ln1621">    }</a>
<a name="ln1622">    cmdmod.cmod_did_esilent = 0;</a>
<a name="ln1623">  }</a>
<a name="ln1624"> </a>
<a name="ln1625">  // Execute the command</a>
<a name="ln1626">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1627">    // Execute a user-defined command.</a>
<a name="ln1628">    *retv = do_ucmd(eap, preview);</a>
<a name="ln1629">  } else {</a>
<a name="ln1630">    // Call the function to execute the builtin command or the preview callback.</a>
<a name="ln1631">    eap-&gt;errmsg = NULL;</a>
<a name="ln1632">    if (preview) {</a>
<a name="ln1633">      *retv = (cmdnames[eap-&gt;cmdidx].cmd_preview_func)(eap, cmdpreview_get_ns(),</a>
<a name="ln1634">                                                       cmdpreview_get_bufnr());</a>
<a name="ln1635">    } else {</a>
<a name="ln1636">      (cmdnames[eap-&gt;cmdidx].cmd_func)(eap);</a>
<a name="ln1637">    }</a>
<a name="ln1638">    if (eap-&gt;errmsg != NULL) {</a>
<a name="ln1639">      *errormsg = eap-&gt;errmsg;</a>
<a name="ln1640">    }</a>
<a name="ln1641">  }</a>
<a name="ln1642"> </a>
<a name="ln1643">  return OK;</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">/// Execute an Ex command using parsed command line information.</a>
<a name="ln1647">/// Does not do any validation of the Ex command arguments.</a>
<a name="ln1648">///</a>
<a name="ln1649">/// @param eap Ex-command arguments</a>
<a name="ln1650">/// @param cmdinfo Command parse information</a>
<a name="ln1651">/// @param preview Execute command preview callback instead of actual command</a>
<a name="ln1652">int execute_cmd(exarg_T *eap, CmdParseInfo *cmdinfo, bool preview)</a>
<a name="ln1653">{</a>
<a name="ln1654">  const char *errormsg = NULL;</a>
<a name="ln1655">  int retv = 0;</a>
<a name="ln1656"> </a>
<a name="ln1657">#undef ERROR</a>
<a name="ln1658">#define ERROR(msg) \</a>
<a name="ln1659">  do { \</a>
<a name="ln1660">    errormsg = msg; \</a>
<a name="ln1661">    goto end; \</a>
<a name="ln1662">  } while (0)</a>
<a name="ln1663"> </a>
<a name="ln1664">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1665">  cmdmod = cmdinfo-&gt;cmdmod;</a>
<a name="ln1666"> </a>
<a name="ln1667">  // Apply command modifiers</a>
<a name="ln1668">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1669"> </a>
<a name="ln1670">  if (!MODIFIABLE(curbuf) &amp;&amp; (eap-&gt;argt &amp; EX_MODIFY)</a>
<a name="ln1671">      // allow :put in terminals</a>
<a name="ln1672">      &amp;&amp; !(curbuf-&gt;terminal &amp;&amp; eap-&gt;cmdidx == CMD_put)) {</a>
<a name="ln1673">    ERROR(_(e_modifiable));</a>
<a name="ln1674">  }</a>
<a name="ln1675">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1676">    if (cmdwin_type != 0 &amp;&amp; !(eap-&gt;argt &amp; EX_CMDWIN)) {</a>
<a name="ln1677">      // Command not allowed in the command line window</a>
<a name="ln1678">      ERROR(_(e_cmdwin));</a>
<a name="ln1679">    }</a>
<a name="ln1680">    if (text_locked() &amp;&amp; !(eap-&gt;argt &amp; EX_LOCK_OK)) {</a>
<a name="ln1681">      // Command not allowed when text is locked</a>
<a name="ln1682">      ERROR(_(get_text_locked_msg()));</a>
<a name="ln1683">    }</a>
<a name="ln1684">  }</a>
<a name="ln1685">  // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln1686">  // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln1687">  // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln1688">  // Do allow &quot;:file&quot; with no arguments</a>
<a name="ln1689">  if (!(eap-&gt;argt &amp; EX_CMDWIN)</a>
<a name="ln1690">      &amp;&amp; eap-&gt;cmdidx != CMD_checktime</a>
<a name="ln1691">      &amp;&amp; eap-&gt;cmdidx != CMD_edit</a>
<a name="ln1692">      &amp;&amp; !(eap-&gt;cmdidx == CMD_file &amp;&amp; *eap-&gt;arg == NUL)</a>
<a name="ln1693">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)</a>
<a name="ln1694">      &amp;&amp; curbuf_locked()) {</a>
<a name="ln1695">    goto end;</a>
<a name="ln1696">  }</a>
<a name="ln1697"> </a>
<a name="ln1698">  correct_range(eap);</a>
<a name="ln1699"> </a>
<a name="ln1700">  if (((eap-&gt;argt &amp; EX_WHOLEFOLD) || eap-&gt;addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln1701">      &amp;&amp; eap-&gt;addr_type == ADDR_LINES) {</a>
<a name="ln1702">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln1703">    // at the end of a closed fold.</a>
<a name="ln1704">    (void)hasFolding(eap-&gt;line1, &amp;eap-&gt;line1, NULL);</a>
<a name="ln1705">    (void)hasFolding(eap-&gt;line2, NULL, &amp;eap-&gt;line2);</a>
<a name="ln1706">  }</a>
<a name="ln1707"> </a>
<a name="ln1708">  // Use first argument as count when possible</a>
<a name="ln1709">  if (parse_count(eap, &amp;errormsg, true) == FAIL) {</a>
<a name="ln1710">    goto end;</a>
<a name="ln1711">  }</a>
<a name="ln1712"> </a>
<a name="ln1713">  // Execute the command</a>
<a name="ln1714">  execute_cmd0(&amp;retv, eap, &amp;errormsg, preview);</a>
<a name="ln1715"> </a>
<a name="ln1716">end:</a>
<a name="ln1717">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln1718">    emsg(errormsg);</a>
<a name="ln1719">  }</a>
<a name="ln1720">  // Undo command modifiers</a>
<a name="ln1721">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln1722">  cmdmod = save_cmdmod;</a>
<a name="ln1723">  return retv;</a>
<a name="ln1724">#undef ERROR</a>
<a name="ln1725">}</a>
<a name="ln1726"> </a>
<a name="ln1727">static void profile_cmd(const exarg_T *eap, cstack_T *cstack, LineGetter fgetline, void *cookie)</a>
<a name="ln1728">{</a>
<a name="ln1729">  // Count this line for profiling if skip is true.</a>
<a name="ln1730">  if (do_profiling == PROF_YES</a>
<a name="ln1731">      &amp;&amp; (!eap-&gt;skip || cstack-&gt;cs_idx == 0</a>
<a name="ln1732">          || (cstack-&gt;cs_idx &gt; 0</a>
<a name="ln1733">              &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx - 1] &amp; CSF_ACTIVE)))) {</a>
<a name="ln1734">    bool skip = did_emsg || got_int || did_throw;</a>
<a name="ln1735"> </a>
<a name="ln1736">    if (eap-&gt;cmdidx == CMD_catch) {</a>
<a name="ln1737">      skip = !skip &amp;&amp; !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1738">                        &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_THROWN)</a>
<a name="ln1739">                        &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_CAUGHT));</a>
<a name="ln1740">    } else if (eap-&gt;cmdidx == CMD_else || eap-&gt;cmdidx == CMD_elseif) {</a>
<a name="ln1741">      skip = skip || !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1742">                       &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx]</a>
<a name="ln1743">                            &amp; (CSF_ACTIVE | CSF_TRUE)));</a>
<a name="ln1744">    } else if (eap-&gt;cmdidx == CMD_finally) {</a>
<a name="ln1745">      skip = false;</a>
<a name="ln1746">    } else if (eap-&gt;cmdidx != CMD_endif</a>
<a name="ln1747">               &amp;&amp; eap-&gt;cmdidx != CMD_endfor</a>
<a name="ln1748">               &amp;&amp; eap-&gt;cmdidx != CMD_endtry</a>
<a name="ln1749">               &amp;&amp; eap-&gt;cmdidx != CMD_endwhile) {</a>
<a name="ln1750">      skip = eap-&gt;skip;</a>
<a name="ln1751">    }</a>
<a name="ln1752"> </a>
<a name="ln1753">    if (!skip) {</a>
<a name="ln1754">      if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln1755">        func_line_exec(getline_cookie(fgetline, cookie));</a>
<a name="ln1756">      } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln1757">        script_line_exec();</a>
<a name="ln1758">      }</a>
<a name="ln1759">    }</a>
<a name="ln1760">  }</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">static bool skip_cmd(const exarg_T *eap)</a>
<a name="ln1764">{</a>
<a name="ln1765">  // Skip the command when it's not going to be executed.</a>
<a name="ln1766">  // The commands like :if, :endif, etc. always need to be executed.</a>
<a name="ln1767">  // Also make an exception for commands that handle a trailing command</a>
<a name="ln1768">  // themselves.</a>
<a name="ln1769">  if (eap-&gt;skip) {</a>
<a name="ln1770">    switch (eap-&gt;cmdidx) {</a>
<a name="ln1771">    // commands that need evaluation</a>
<a name="ln1772">    case CMD_while:</a>
<a name="ln1773">    case CMD_endwhile:</a>
<a name="ln1774">    case CMD_for:</a>
<a name="ln1775">    case CMD_endfor:</a>
<a name="ln1776">    case CMD_if:</a>
<a name="ln1777">    case CMD_elseif:</a>
<a name="ln1778">    case CMD_else:</a>
<a name="ln1779">    case CMD_endif:</a>
<a name="ln1780">    case CMD_try:</a>
<a name="ln1781">    case CMD_catch:</a>
<a name="ln1782">    case CMD_finally:</a>
<a name="ln1783">    case CMD_endtry:</a>
<a name="ln1784">    case CMD_function:</a>
<a name="ln1785">      break;</a>
<a name="ln1786"> </a>
<a name="ln1787">    // Commands that handle '|' themselves.  Check: A command should</a>
<a name="ln1788">    // either have the EX_TRLBAR flag, appear in this list or appear in</a>
<a name="ln1789">    // the list at &quot;:help :bar&quot;.</a>
<a name="ln1790">    case CMD_aboveleft:</a>
<a name="ln1791">    case CMD_and:</a>
<a name="ln1792">    case CMD_belowright:</a>
<a name="ln1793">    case CMD_botright:</a>
<a name="ln1794">    case CMD_browse:</a>
<a name="ln1795">    case CMD_call:</a>
<a name="ln1796">    case CMD_confirm:</a>
<a name="ln1797">    case CMD_const:</a>
<a name="ln1798">    case CMD_delfunction:</a>
<a name="ln1799">    case CMD_djump:</a>
<a name="ln1800">    case CMD_dlist:</a>
<a name="ln1801">    case CMD_dsearch:</a>
<a name="ln1802">    case CMD_dsplit:</a>
<a name="ln1803">    case CMD_echo:</a>
<a name="ln1804">    case CMD_echoerr:</a>
<a name="ln1805">    case CMD_echomsg:</a>
<a name="ln1806">    case CMD_echon:</a>
<a name="ln1807">    case CMD_eval:</a>
<a name="ln1808">    case CMD_execute:</a>
<a name="ln1809">    case CMD_filter:</a>
<a name="ln1810">    case CMD_help:</a>
<a name="ln1811">    case CMD_hide:</a>
<a name="ln1812">    case CMD_horizontal:</a>
<a name="ln1813">    case CMD_ijump:</a>
<a name="ln1814">    case CMD_ilist:</a>
<a name="ln1815">    case CMD_isearch:</a>
<a name="ln1816">    case CMD_isplit:</a>
<a name="ln1817">    case CMD_keepalt:</a>
<a name="ln1818">    case CMD_keepjumps:</a>
<a name="ln1819">    case CMD_keepmarks:</a>
<a name="ln1820">    case CMD_keeppatterns:</a>
<a name="ln1821">    case CMD_leftabove:</a>
<a name="ln1822">    case CMD_let:</a>
<a name="ln1823">    case CMD_lockmarks:</a>
<a name="ln1824">    case CMD_lockvar:</a>
<a name="ln1825">    case CMD_lua:</a>
<a name="ln1826">    case CMD_match:</a>
<a name="ln1827">    case CMD_mzscheme:</a>
<a name="ln1828">    case CMD_noautocmd:</a>
<a name="ln1829">    case CMD_noswapfile:</a>
<a name="ln1830">    case CMD_perl:</a>
<a name="ln1831">    case CMD_psearch:</a>
<a name="ln1832">    case CMD_python:</a>
<a name="ln1833">    case CMD_py3:</a>
<a name="ln1834">    case CMD_python3:</a>
<a name="ln1835">    case CMD_pythonx:</a>
<a name="ln1836">    case CMD_pyx:</a>
<a name="ln1837">    case CMD_return:</a>
<a name="ln1838">    case CMD_rightbelow:</a>
<a name="ln1839">    case CMD_ruby:</a>
<a name="ln1840">    case CMD_silent:</a>
<a name="ln1841">    case CMD_smagic:</a>
<a name="ln1842">    case CMD_snomagic:</a>
<a name="ln1843">    case CMD_substitute:</a>
<a name="ln1844">    case CMD_syntax:</a>
<a name="ln1845">    case CMD_tab:</a>
<a name="ln1846">    case CMD_tcl:</a>
<a name="ln1847">    case CMD_throw:</a>
<a name="ln1848">    case CMD_tilde:</a>
<a name="ln1849">    case CMD_topleft:</a>
<a name="ln1850">    case CMD_trust:</a>
<a name="ln1851">    case CMD_unlet:</a>
<a name="ln1852">    case CMD_unlockvar:</a>
<a name="ln1853">    case CMD_verbose:</a>
<a name="ln1854">    case CMD_vertical:</a>
<a name="ln1855">    case CMD_wincmd:</a>
<a name="ln1856">      break;</a>
<a name="ln1857"> </a>
<a name="ln1858">    default:</a>
<a name="ln1859">      return true;</a>
<a name="ln1860">    }</a>
<a name="ln1861">  }</a>
<a name="ln1862">  return false;</a>
<a name="ln1863">}</a>
<a name="ln1864"> </a>
<a name="ln1865">/// Execute one Ex command.</a>
<a name="ln1866">///</a>
<a name="ln1867">/// If &quot;flags&quot; has DOCMD_VERBOSE, the command will be included in the error</a>
<a name="ln1868">/// message.</a>
<a name="ln1869">///</a>
<a name="ln1870">/// 1. skip comment lines and leading space</a>
<a name="ln1871">/// 2. handle command modifiers</a>
<a name="ln1872">/// 3. skip over the range to find the command</a>
<a name="ln1873">/// 4. parse the range</a>
<a name="ln1874">/// 5. parse the command</a>
<a name="ln1875">/// 6. parse arguments</a>
<a name="ln1876">/// 7. switch on command name</a>
<a name="ln1877">///</a>
<a name="ln1878">/// Note: &quot;fgetline&quot; can be NULL.</a>
<a name="ln1879">///</a>
<a name="ln1880">/// This function may be called recursively!</a>
<a name="ln1881">///</a>
<a name="ln1882">/// @param cookie  argument for fgetline()</a>
<a name="ln1883">static char *do_one_cmd(char **cmdlinep, int flags, cstack_T *cstack, LineGetter fgetline,</a>
<a name="ln1884">                        void *cookie)</a>
<a name="ln1885">{</a>
<a name="ln1886">  const char *errormsg = NULL;  // error message</a>
<a name="ln1887">  const int save_reg_executing = reg_executing;</a>
<a name="ln1888">  const bool save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln1889"> </a>
<a name="ln1890">  exarg_T ea = {</a>
<a name="ln1891">    .line1 = 1,</a>
<a name="ln1892">    .line2 = 1,</a>
<a name="ln1893">  };</a>
<a name="ln1894">  ex_nesting_level++;</a>
<a name="ln1895"> </a>
<a name="ln1896">  // When the last file has not been edited :q has to be typed twice.</a>
<a name="ln1897">  if (quitmore</a>
<a name="ln1898">      // avoid that a function call in 'statusline' does this</a>
<a name="ln1899">      &amp;&amp; !getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1900">      // avoid that an autocommand, e.g. QuitPre, does this</a>
<a name="ln1901">      &amp;&amp; !getline_equal(fgetline, cookie, getnextac)) {</a>
<a name="ln1902">    quitmore--;</a>
<a name="ln1903">  }</a>
<a name="ln1904"> </a>
<a name="ln1905">  // Reset browse, confirm, etc..  They are restored when returning, for</a>
<a name="ln1906">  // recursive calls.</a>
<a name="ln1907">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1908"> </a>
<a name="ln1909">  // &quot;#!anything&quot; is handled like a comment.</a>
<a name="ln1910">  if ((*cmdlinep)[0] == '#' &amp;&amp; (*cmdlinep)[1] == '!') {</a>
<a name="ln1911">    goto doend;</a>
<a name="ln1912">  }</a>
<a name="ln1913"> </a>
<a name="ln1914">  // 1. Skip comment lines and leading white space and colons.</a>
<a name="ln1915">  // 2. Handle command modifiers.</a>
<a name="ln1916"> </a>
<a name="ln1917">  // The &quot;ea&quot; structure holds the arguments that can be used.</a>
<a name="ln1918">  ea.cmd = *cmdlinep;</a>
<a name="ln1919">  ea.cmdlinep = cmdlinep;</a>
<a name="ln1920">  ea.getline = fgetline;</a>
<a name="ln1921">  ea.cookie = cookie;</a>
<a name="ln1922">  ea.cstack = cstack;</a>
<a name="ln1923"> </a>
<a name="ln1924">  if (parse_command_modifiers(&amp;ea, &amp;errormsg, &amp;cmdmod, false) == FAIL) {</a>
<a name="ln1925">    goto doend;</a>
<a name="ln1926">  }</a>
<a name="ln1927">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1928"> </a>
<a name="ln1929">  char *after_modifier = ea.cmd;</a>
<a name="ln1930"> </a>
<a name="ln1931">  ea.skip = (did_emsg</a>
<a name="ln1932">             || got_int</a>
<a name="ln1933">             || did_throw</a>
<a name="ln1934">             || (cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1935">                 &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_ACTIVE)));</a>
<a name="ln1936"> </a>
<a name="ln1937">  // 3. Skip over the range to find the command. Let &quot;p&quot; point to after it.</a>
<a name="ln1938">  //</a>
<a name="ln1939">  // We need the command to know what kind of range it uses.</a>
<a name="ln1940">  char *cmd = ea.cmd;</a>
<a name="ln1941">  ea.cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln1942">  if (*ea.cmd == '*') {</a>
<a name="ln1943">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln1944">  }</a>
<a name="ln1945">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln1946"> </a>
<a name="ln1947">  profile_cmd(&amp;ea, cstack, fgetline, cookie);</a>
<a name="ln1948"> </a>
<a name="ln1949">  if (!exiting) {</a>
<a name="ln1950">    // May go to debug mode.  If this happens and the &quot;&gt;quit&quot; debug command is</a>
<a name="ln1951">    // used, throw an interrupt exception and skip the next command.</a>
<a name="ln1952">    dbg_check_breakpoint(&amp;ea);</a>
<a name="ln1953">  }</a>
<a name="ln1954">  if (!ea.skip &amp;&amp; got_int) {</a>
<a name="ln1955">    ea.skip = true;</a>
<a name="ln1956">    (void)do_intthrow(cstack);</a>
<a name="ln1957">  }</a>
<a name="ln1958"> </a>
<a name="ln1959">  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln1960">  //</a>
<a name="ln1961">  // where 'addr' is:</a>
<a name="ln1962">  //</a>
<a name="ln1963">  // %          (entire file)</a>
<a name="ln1964">  // $  [+-NUM]</a>
<a name="ln1965">  // 'x [+-NUM] (where x denotes a currently defined mark)</a>
<a name="ln1966">  // .  [+-NUM]</a>
<a name="ln1967">  // [+-NUM]..</a>
<a name="ln1968">  // NUM</a>
<a name="ln1969">  //</a>
<a name="ln1970">  // The ea.cmd pointer is updated to point to the first character following the</a>
<a name="ln1971">  // range spec. If an initial address is found, but no second, the upper bound</a>
<a name="ln1972">  // is equal to the lower.</a>
<a name="ln1973">  set_cmd_addr_type(&amp;ea, p);</a>
<a name="ln1974"> </a>
<a name="ln1975">  ea.cmd = cmd;</a>
<a name="ln1976">  if (parse_cmd_address(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1977">    goto doend;</a>
<a name="ln1978">  }</a>
<a name="ln1979"> </a>
<a name="ln1980">  // 5. Parse the command.</a>
<a name="ln1981"> </a>
<a name="ln1982">  // Skip ':' and any white space</a>
<a name="ln1983">  ea.cmd = skip_colon_white(ea.cmd, true);</a>
<a name="ln1984"> </a>
<a name="ln1985">  // If we got a line, but no command, then go to the line.</a>
<a name="ln1986">  // If we find a '|' or '\n' we set ea.nextcmd.</a>
<a name="ln1987">  if (*ea.cmd == NUL || *ea.cmd == '&quot;'</a>
<a name="ln1988">      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {</a>
<a name="ln1989">    // strange vi behaviour:</a>
<a name="ln1990">    // &quot;:3&quot;     jumps to line 3</a>
<a name="ln1991">    // &quot;:3|...&quot; prints line 3</a>
<a name="ln1992">    // &quot;:|&quot;     prints current line</a>
<a name="ln1993">    if (ea.skip) {  // skip this if inside :if</a>
<a name="ln1994">      goto doend;</a>
<a name="ln1995">    }</a>
<a name="ln1996">    if (*ea.cmd == '|' || (exmode_active &amp;&amp; ea.line1 != ea.line2)) {</a>
<a name="ln1997">      ea.cmdidx = CMD_print;</a>
<a name="ln1998">      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;</a>
<a name="ln1999">      if ((errormsg = invalid_range(&amp;ea)) == NULL) {</a>
<a name="ln2000">        correct_range(&amp;ea);</a>
<a name="ln2001">        ex_print(&amp;ea);</a>
<a name="ln2002">      }</a>
<a name="ln2003">    } else if (ea.addr_count != 0) {</a>
<a name="ln2004">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2005">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2006">      }</a>
<a name="ln2007"> </a>
<a name="ln2008">      if (ea.line2 &lt; 0) {</a>
<a name="ln2009">        errormsg = _(e_invrange);</a>
<a name="ln2010">      } else {</a>
<a name="ln2011">        if (ea.line2 == 0) {</a>
<a name="ln2012">          curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2013">        } else {</a>
<a name="ln2014">          curwin-&gt;w_cursor.lnum = ea.line2;</a>
<a name="ln2015">        }</a>
<a name="ln2016">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2017">      }</a>
<a name="ln2018">    }</a>
<a name="ln2019">    goto doend;</a>
<a name="ln2020">  }</a>
<a name="ln2021"> </a>
<a name="ln2022">  // If this looks like an undefined user command and there are CmdUndefined</a>
<a name="ln2023">  // autocommands defined, trigger the matching autocommands.</a>
<a name="ln2024">  if (p != NULL &amp;&amp; ea.cmdidx == CMD_SIZE &amp;&amp; !ea.skip</a>
<a name="ln2025">      &amp;&amp; ASCII_ISUPPER(*ea.cmd)</a>
<a name="ln2026">      &amp;&amp; has_event(EVENT_CMDUNDEFINED)) {</a>
<a name="ln2027">    p = ea.cmd;</a>
<a name="ln2028">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2029">      p++;</a>
<a name="ln2030">    }</a>
<a name="ln2031">    p = xstrnsave(ea.cmd, (size_t)(p - ea.cmd));</a>
<a name="ln2032">    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, true, NULL);</a>
<a name="ln2033">    xfree(p);</a>
<a name="ln2034">    // If the autocommands did something and didn't cause an error, try</a>
<a name="ln2035">    // finding the command again.</a>
<a name="ln2036">    p = (ret &amp;&amp; !aborting()) ? find_ex_command(&amp;ea, NULL) : ea.cmd;</a>
<a name="ln2037">  }</a>
<a name="ln2038"> </a>
<a name="ln2039">  if (p == NULL) {</a>
<a name="ln2040">    if (!ea.skip) {</a>
<a name="ln2041">      errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln2042">    }</a>
<a name="ln2043">    goto doend;</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  // Check for wrong commands.</a>
<a name="ln2047">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2048">    if (!ea.skip) {</a>
<a name="ln2049">      xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln2050">      // If the modifier was parsed OK the error must be in the following</a>
<a name="ln2051">      // command</a>
<a name="ln2052">      char *cmdname = after_modifier ? after_modifier : *cmdlinep;</a>
<a name="ln2053">      if (!(flags &amp; DOCMD_VERBOSE)) {</a>
<a name="ln2054">        append_command(cmdname);</a>
<a name="ln2055">      }</a>
<a name="ln2056">      errormsg = IObuff;</a>
<a name="ln2057">      did_emsg_syntax = true;</a>
<a name="ln2058">      verify_command(cmdname);</a>
<a name="ln2059">    }</a>
<a name="ln2060">    goto doend;</a>
<a name="ln2061">  }</a>
<a name="ln2062"> </a>
<a name="ln2063">  // set when Not Implemented</a>
<a name="ln2064">  const int ni = is_cmd_ni(ea.cmdidx);</a>
<a name="ln2065"> </a>
<a name="ln2066">  // Forced commands.</a>
<a name="ln2067">  ea.forceit = *p == '!'</a>
<a name="ln2068">               &amp;&amp; ea.cmdidx != CMD_substitute</a>
<a name="ln2069">               &amp;&amp; ea.cmdidx != CMD_smagic</a>
<a name="ln2070">               &amp;&amp; ea.cmdidx != CMD_snomagic;</a>
<a name="ln2071">  if (ea.forceit) {</a>
<a name="ln2072">    p++;</a>
<a name="ln2073">  }</a>
<a name="ln2074"> </a>
<a name="ln2075">  // 6. Parse arguments.  Then check for errors.</a>
<a name="ln2076">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2077">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln2078">  }</a>
<a name="ln2079"> </a>
<a name="ln2080">  if (!ea.skip) {</a>
<a name="ln2081">    if (sandbox != 0 &amp;&amp; !(ea.argt &amp; EX_SBOXOK)) {</a>
<a name="ln2082">      // Command not allowed in sandbox.</a>
<a name="ln2083">      errormsg = _(e_sandbox);</a>
<a name="ln2084">      goto doend;</a>
<a name="ln2085">    }</a>
<a name="ln2086">    if (!MODIFIABLE(curbuf) &amp;&amp; (ea.argt &amp; EX_MODIFY)</a>
<a name="ln2087">        // allow :put in terminals</a>
<a name="ln2088">        &amp;&amp; (!curbuf-&gt;terminal || ea.cmdidx != CMD_put)) {</a>
<a name="ln2089">      // Command not allowed in non-'modifiable' buffer</a>
<a name="ln2090">      errormsg = _(e_modifiable);</a>
<a name="ln2091">      goto doend;</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2095">      if (cmdwin_type != 0 &amp;&amp; !(ea.argt &amp; EX_CMDWIN)) {</a>
<a name="ln2096">        // Command not allowed in the command line window</a>
<a name="ln2097">        errormsg = _(e_cmdwin);</a>
<a name="ln2098">        goto doend;</a>
<a name="ln2099">      }</a>
<a name="ln2100">      if (text_locked() &amp;&amp; !(ea.argt &amp; EX_LOCK_OK)) {</a>
<a name="ln2101">        // Command not allowed when text is locked</a>
<a name="ln2102">        errormsg = _(get_text_locked_msg());</a>
<a name="ln2103">        goto doend;</a>
<a name="ln2104">      }</a>
<a name="ln2105">    }</a>
<a name="ln2106"> </a>
<a name="ln2107">    // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln2108">    // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln2109">    // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln2110">    // Do allow &quot;:file&quot; with no arguments (check for an argument later).</a>
<a name="ln2111">    if (!(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln2112">        &amp;&amp; ea.cmdidx != CMD_checktime</a>
<a name="ln2113">        &amp;&amp; ea.cmdidx != CMD_edit</a>
<a name="ln2114">        &amp;&amp; ea.cmdidx != CMD_file</a>
<a name="ln2115">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln2116">        &amp;&amp; curbuf_locked()) {</a>
<a name="ln2117">      goto doend;</a>
<a name="ln2118">    }</a>
<a name="ln2119"> </a>
<a name="ln2120">    if (!ni &amp;&amp; !(ea.argt &amp; EX_RANGE) &amp;&amp; ea.addr_count &gt; 0) {</a>
<a name="ln2121">      // no range allowed</a>
<a name="ln2122">      errormsg = _(e_norange);</a>
<a name="ln2123">      goto doend;</a>
<a name="ln2124">    }</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127">  if (!ni &amp;&amp; !(ea.argt &amp; EX_BANG) &amp;&amp; ea.forceit) {  // no &lt;!&gt; allowed</a>
<a name="ln2128">    errormsg = _(e_nobang);</a>
<a name="ln2129">    goto doend;</a>
<a name="ln2130">  }</a>
<a name="ln2131"> </a>
<a name="ln2132">  // Don't complain about the range if it is not used</a>
<a name="ln2133">  // (could happen if line_count is accidentally set to 0).</a>
<a name="ln2134">  if (!ea.skip &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_RANGE)) {</a>
<a name="ln2135">    // If the range is backwards, ask for confirmation and, if given, swap</a>
<a name="ln2136">    // ea.line1 &amp; ea.line2 so it's forwards again.</a>
<a name="ln2137">    // When global command is busy, don't ask, will fail below.</a>
<a name="ln2138">    if (!global_busy &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln2139">      if (msg_silent == 0) {</a>
<a name="ln2140">        if ((flags &amp; DOCMD_VERBOSE) || exmode_active) {</a>
<a name="ln2141">          errormsg = _(&quot;E493: Backwards range given&quot;);</a>
<a name="ln2142">          goto doend;</a>
<a name="ln2143">        }</a>
<a name="ln2144">        if (ask_yesno(_(&quot;Backwards range given, OK to swap&quot;), false) != 'y') {</a>
<a name="ln2145">          goto doend;</a>
<a name="ln2146">        }</a>
<a name="ln2147">      }</a>
<a name="ln2148">      linenr_T lnum = ea.line1;</a>
<a name="ln2149">      ea.line1 = ea.line2;</a>
<a name="ln2150">      ea.line2 = lnum;</a>
<a name="ln2151">    }</a>
<a name="ln2152">    if ((errormsg = invalid_range(&amp;ea)) != NULL) {</a>
<a name="ln2153">      goto doend;</a>
<a name="ln2154">    }</a>
<a name="ln2155">  }</a>
<a name="ln2156"> </a>
<a name="ln2157">  if ((ea.addr_type == ADDR_OTHER) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2158">    // default is 1, not cursor</a>
<a name="ln2159">    ea.line2 = 1;</a>
<a name="ln2160">  }</a>
<a name="ln2161"> </a>
<a name="ln2162">  correct_range(&amp;ea);</a>
<a name="ln2163"> </a>
<a name="ln2164">  if (((ea.argt &amp; EX_WHOLEFOLD) || ea.addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln2165">      &amp;&amp; ea.addr_type == ADDR_LINES) {</a>
<a name="ln2166">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln2167">    // at the end of a closed fold.</a>
<a name="ln2168">    (void)hasFolding(ea.line1, &amp;ea.line1, NULL);</a>
<a name="ln2169">    (void)hasFolding(ea.line2, NULL, &amp;ea.line2);</a>
<a name="ln2170">  }</a>
<a name="ln2171"> </a>
<a name="ln2172">  // For the &quot;:make&quot; and &quot;:grep&quot; commands we insert the 'makeprg'/'grepprg'</a>
<a name="ln2173">  // option here, so things like % get expanded.</a>
<a name="ln2174">  p = replace_makeprg(&amp;ea, p, cmdlinep);</a>
<a name="ln2175">  if (p == NULL) {</a>
<a name="ln2176">    goto doend;</a>
<a name="ln2177">  }</a>
<a name="ln2178"> </a>
<a name="ln2179">  // Skip to start of argument.</a>
<a name="ln2180">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln2181">  ea.arg = ea.cmdidx == CMD_bang ? p : skipwhite(p);</a>
<a name="ln2182"> </a>
<a name="ln2183">  // &quot;:file&quot; cannot be run with an argument when &quot;curbuf-&gt;b_ro_locked&quot; is set</a>
<a name="ln2184">  if (ea.cmdidx == CMD_file &amp;&amp; *ea.arg != NUL &amp;&amp; curbuf_locked()) {</a>
<a name="ln2185">    goto doend;</a>
<a name="ln2186">  }</a>
<a name="ln2187"> </a>
<a name="ln2188">  // Check for &quot;++opt=val&quot; argument.</a>
<a name="ln2189">  // Must be first, allow &quot;:w ++enc=utf8 !cmd&quot;</a>
<a name="ln2190">  if (ea.argt &amp; EX_ARGOPT) {</a>
<a name="ln2191">    while (ea.arg[0] == '+' &amp;&amp; ea.arg[1] == '+') {</a>
<a name="ln2192">      if (getargopt(&amp;ea) == FAIL &amp;&amp; !ni) {</a>
<a name="ln2193">        errormsg = _(e_invarg);</a>
<a name="ln2194">        goto doend;</a>
<a name="ln2195">      }</a>
<a name="ln2196">    }</a>
<a name="ln2197">  }</a>
<a name="ln2198"> </a>
<a name="ln2199">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln2200">    if (*ea.arg == '&gt;') {                       // append</a>
<a name="ln2201">      if (*++ea.arg != '&gt;') {                   // typed wrong</a>
<a name="ln2202">        errormsg = _(&quot;E494: Use w or w&gt;&gt;&quot;);</a>
<a name="ln2203">        goto doend;</a>
<a name="ln2204">      }</a>
<a name="ln2205">      ea.arg = skipwhite(ea.arg + 1);</a>
<a name="ln2206">      ea.append = true;</a>
<a name="ln2207">    } else if (*ea.arg == '!' &amp;&amp; ea.cmdidx == CMD_write) {  // :w !filter</a>
<a name="ln2208">      ea.arg++;</a>
<a name="ln2209">      ea.usefilter = true;</a>
<a name="ln2210">    }</a>
<a name="ln2211">  } else if (ea.cmdidx == CMD_read) {</a>
<a name="ln2212">    if (ea.forceit) {</a>
<a name="ln2213">      ea.usefilter = true;                      // :r! filter if ea.forceit</a>
<a name="ln2214">      ea.forceit = false;</a>
<a name="ln2215">    } else if (*ea.arg == '!') {              // :r !filter</a>
<a name="ln2216">      ea.arg++;</a>
<a name="ln2217">      ea.usefilter = true;</a>
<a name="ln2218">    }</a>
<a name="ln2219">  } else if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln2220">    ea.amount = 1;</a>
<a name="ln2221">    while (*ea.arg == *ea.cmd) {                // count number of '&gt;' or '&lt;'</a>
<a name="ln2222">      ea.arg++;</a>
<a name="ln2223">      ea.amount++;</a>
<a name="ln2224">    }</a>
<a name="ln2225">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln2226">  }</a>
<a name="ln2227"> </a>
<a name="ln2228">  // Check for &quot;+command&quot; argument, before checking for next command.</a>
<a name="ln2229">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2230">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2231">    ea.do_ecmd_cmd = getargcmd(&amp;ea.arg);</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln2235">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2236">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2237">    separate_nextcmd(&amp;ea);</a>
<a name="ln2238">  } else if (ea.cmdidx == CMD_bang</a>
<a name="ln2239">             || ea.cmdidx == CMD_terminal</a>
<a name="ln2240">             || ea.cmdidx == CMD_global</a>
<a name="ln2241">             || ea.cmdidx == CMD_vglobal</a>
<a name="ln2242">             || ea.usefilter) {</a>
<a name="ln2243">    // Check for &lt;newline&gt; to end a shell command.</a>
<a name="ln2244">    // Also do this for &quot;:read !cmd&quot;, &quot;:write !cmd&quot; and &quot;:global&quot;.</a>
<a name="ln2245">    // Any others?</a>
<a name="ln2246">    for (char *s = ea.arg; *s; s++) {</a>
<a name="ln2247">      // Remove one backslash before a newline, so that it's possible to</a>
<a name="ln2248">      // pass a newline to the shell and also a newline that is preceded</a>
<a name="ln2249">      // with a backslash.  This makes it impossible to end a shell</a>
<a name="ln2250">      // command in a backslash, but that doesn't appear useful.</a>
<a name="ln2251">      // Halving the number of backslashes is incompatible with previous</a>
<a name="ln2252">      // versions.</a>
<a name="ln2253">      if (*s == '\\' &amp;&amp; s[1] == '\n') {</a>
<a name="ln2254">        STRMOVE(s, s + 1);</a>
<a name="ln2255">      } else if (*s == '\n') {</a>
<a name="ln2256">        ea.nextcmd = s + 1;</a>
<a name="ln2257">        *s = NUL;</a>
<a name="ln2258">        break;</a>
<a name="ln2259">      }</a>
<a name="ln2260">    }</a>
<a name="ln2261">  }</a>
<a name="ln2262"> </a>
<a name="ln2263">  if ((ea.argt &amp; EX_DFLALL) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2264">    set_cmd_dflall_range(&amp;ea);</a>
<a name="ln2265">  }</a>
<a name="ln2266"> </a>
<a name="ln2267">  // Parse register and count</a>
<a name="ln2268">  parse_register(&amp;ea);</a>
<a name="ln2269">  if (parse_count(&amp;ea, &amp;errormsg, true) == FAIL) {</a>
<a name="ln2270">    goto doend;</a>
<a name="ln2271">  }</a>
<a name="ln2272"> </a>
<a name="ln2273">  // Check for flags: 'l', 'p' and '#'.</a>
<a name="ln2274">  if (ea.argt &amp; EX_FLAGS) {</a>
<a name="ln2275">    get_flags(&amp;ea);</a>
<a name="ln2276">  }</a>
<a name="ln2277">  if (!ni &amp;&amp; !(ea.argt &amp; EX_EXTRA) &amp;&amp; *ea.arg != NUL</a>
<a name="ln2278">      &amp;&amp; *ea.arg != '&quot;' &amp;&amp; (*ea.arg != '|' || (ea.argt &amp; EX_TRLBAR) == 0)) {</a>
<a name="ln2279">    // no arguments allowed but there is something</a>
<a name="ln2280">    errormsg = ex_errmsg(e_trailing_arg, ea.arg);</a>
<a name="ln2281">    goto doend;</a>
<a name="ln2282">  }</a>
<a name="ln2283"> </a>
<a name="ln2284">  if (!ni &amp;&amp; (ea.argt &amp; EX_NEEDARG) &amp;&amp; *ea.arg == NUL) {</a>
<a name="ln2285">    errormsg = _(e_argreq);</a>
<a name="ln2286">    goto doend;</a>
<a name="ln2287">  }</a>
<a name="ln2288"> </a>
<a name="ln2289">  if (skip_cmd(&amp;ea)) {</a>
<a name="ln2290">    goto doend;</a>
<a name="ln2291">  }</a>
<a name="ln2292"> </a>
<a name="ln2293">  // 7. Execute the command.</a>
<a name="ln2294">  int retv = 0;</a>
<a name="ln2295">  if (execute_cmd0(&amp;retv, &amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln2296">    goto doend;</a>
<a name="ln2297">  }</a>
<a name="ln2298"> </a>
<a name="ln2299">  // If the command just executed called do_cmdline(), any throw or &quot;:return&quot;</a>
<a name="ln2300">  // or &quot;:finish&quot; encountered there must also check the cstack of the still</a>
<a name="ln2301">  // active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught</a>
<a name="ln2302">  // exception, or reanimate a returned function or finished script file and</a>
<a name="ln2303">  // return or finish it again.</a>
<a name="ln2304">  if (need_rethrow) {</a>
<a name="ln2305">    do_throw(cstack);</a>
<a name="ln2306">  } else if (check_cstack) {</a>
<a name="ln2307">    if (source_finished(fgetline, cookie)) {</a>
<a name="ln2308">      do_finish(&amp;ea, true);</a>
<a name="ln2309">    } else if (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln2310">               &amp;&amp; current_func_returned()) {</a>
<a name="ln2311">      do_return(&amp;ea, true, false, NULL);</a>
<a name="ln2312">    }</a>
<a name="ln2313">  }</a>
<a name="ln2314">  need_rethrow = check_cstack = false;</a>
<a name="ln2315"> </a>
<a name="ln2316">doend:</a>
<a name="ln2317">  // can happen with zero line number</a>
<a name="ln2318">  if (curwin-&gt;w_cursor.lnum == 0) {</a>
<a name="ln2319">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2320">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2321">  }</a>
<a name="ln2322"> </a>
<a name="ln2323">  if (errormsg != NULL &amp;&amp; *errormsg != NUL &amp;&amp; !did_emsg) {</a>
<a name="ln2324">    if (flags &amp; DOCMD_VERBOSE) {</a>
<a name="ln2325">      if (errormsg != IObuff) {</a>
<a name="ln2326">        xstrlcpy(IObuff, errormsg, IOSIZE);</a>
<a name="ln2327">        errormsg = IObuff;</a>
<a name="ln2328">      }</a>
<a name="ln2329">      append_command(*ea.cmdlinep);</a>
<a name="ln2330">    }</a>
<a name="ln2331">    emsg(errormsg);</a>
<a name="ln2332">  }</a>
<a name="ln2333">  do_errthrow(cstack,</a>
<a name="ln2334">              (ea.cmdidx != CMD_SIZE</a>
<a name="ln2335">               &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)) ? cmdnames[(int)ea.cmdidx].cmd_name : NULL);</a>
<a name="ln2336"> </a>
<a name="ln2337">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln2338">  cmdmod = save_cmdmod;</a>
<a name="ln2339">  reg_executing = save_reg_executing;</a>
<a name="ln2340">  pending_end_reg_executing = save_pending_end_reg_executing;</a>
<a name="ln2341"> </a>
<a name="ln2342">  if (ea.nextcmd &amp;&amp; *ea.nextcmd == NUL) {       // not really a next command</a>
<a name="ln2343">    ea.nextcmd = NULL;</a>
<a name="ln2344">  }</a>
<a name="ln2345"> </a>
<a name="ln2346">  ex_nesting_level--;</a>
<a name="ln2347">  xfree(ea.cmdline_tofree);</a>
<a name="ln2348"> </a>
<a name="ln2349">  return ea.nextcmd;</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352">static char ex_error_buf[MSG_BUF_LEN];</a>
<a name="ln2353"> </a>
<a name="ln2354">/// @return an error message with argument included.</a>
<a name="ln2355">/// Uses a static buffer, only the last error will be kept.</a>
<a name="ln2356">/// &quot;msg&quot; will be translated, caller should use N_().</a>
<a name="ln2357">char *ex_errmsg(const char *const msg, const char *const arg)</a>
<a name="ln2358">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2359">{</a>
<a name="ln2360">  vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);</a>
<a name="ln2361">  return ex_error_buf;</a>
<a name="ln2362">}</a>
<a name="ln2363"> </a>
<a name="ln2364">/// Parse and skip over command modifiers:</a>
<a name="ln2365">/// - update eap-&gt;cmd</a>
<a name="ln2366">/// - store flags in &quot;cmod&quot;.</a>
<a name="ln2367">/// - Set ex_pressedreturn for an empty command line.</a>
<a name="ln2368">///</a>
<a name="ln2369">/// @param skip_only      if false, undo_cmdmod() must be called later to free</a>
<a name="ln2370">///                       any cmod_filter_pat and cmod_filter_regmatch.regprog,</a>
<a name="ln2371">///                       and ex_pressedreturn may be set.</a>
<a name="ln2372">/// @param[out] errormsg  potential error message.</a>
<a name="ln2373">///</a>
<a name="ln2374">/// Call apply_cmdmod() to get the side effects of the modifiers:</a>
<a name="ln2375">/// - Increment &quot;sandbox&quot; for &quot;:sandbox&quot;</a>
<a name="ln2376">/// - set p_verbose for &quot;:verbose&quot;</a>
<a name="ln2377">/// - set msg_silent for &quot;:silent&quot;</a>
<a name="ln2378">/// - set 'eventignore' to &quot;all&quot; for &quot;:noautocmd&quot;</a>
<a name="ln2379">///</a>
<a name="ln2380">/// @return  FAIL when the command is not to be executed.</a>
<a name="ln2381">int parse_command_modifiers(exarg_T *eap, const char **errormsg, cmdmod_T *cmod, bool skip_only)</a>
<a name="ln2382">{</a>
<a name="ln2383">  CLEAR_POINTER(cmod);</a>
<a name="ln2384"> </a>
<a name="ln2385">  // Repeat until no more command modifiers are found.</a>
<a name="ln2386">  while (true) {</a>
<a name="ln2387">    while (*eap-&gt;cmd == ' '</a>
<a name="ln2388">           || *eap-&gt;cmd == '\t'</a>
<a name="ln2389">           || *eap-&gt;cmd == ':') {</a>
<a name="ln2390">      eap-&gt;cmd++;</a>
<a name="ln2391">    }</a>
<a name="ln2392"> </a>
<a name="ln2393">    // in ex mode, an empty line works like :+</a>
<a name="ln2394">    if (*eap-&gt;cmd == NUL &amp;&amp; exmode_active</a>
<a name="ln2395">        &amp;&amp; getline_equal(eap-&gt;getline, eap-&gt;cookie, getexline)</a>
<a name="ln2396">        &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2397">      eap-&gt;cmd = &quot;+&quot;;</a>
<a name="ln2398">      if (!skip_only) {</a>
<a name="ln2399">        ex_pressedreturn = true;</a>
<a name="ln2400">      }</a>
<a name="ln2401">    }</a>
<a name="ln2402"> </a>
<a name="ln2403">    // ignore comment and empty lines</a>
<a name="ln2404">    if (*eap-&gt;cmd == '&quot;') {</a>
<a name="ln2405">      return FAIL;</a>
<a name="ln2406">    }</a>
<a name="ln2407">    if (*eap-&gt;cmd == NUL) {</a>
<a name="ln2408">      if (!skip_only) {</a>
<a name="ln2409">        ex_pressedreturn = true;</a>
<a name="ln2410">      }</a>
<a name="ln2411">      return FAIL;</a>
<a name="ln2412">    }</a>
<a name="ln2413"> </a>
<a name="ln2414">    char *p = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln2415">    switch (*p) {</a>
<a name="ln2416">    // When adding an entry, also modify cmdmods[]</a>
<a name="ln2417">    case 'a':</a>
<a name="ln2418">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;aboveleft&quot;, 3)) {</a>
<a name="ln2419">        break;</a>
<a name="ln2420">      }</a>
<a name="ln2421">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2422">      continue;</a>
<a name="ln2423"> </a>
<a name="ln2424">    case 'b':</a>
<a name="ln2425">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;belowright&quot;, 3)) {</a>
<a name="ln2426">        cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2427">        continue;</a>
<a name="ln2428">      }</a>
<a name="ln2429">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;browse&quot;, 3)) {</a>
<a name="ln2430">        cmod-&gt;cmod_flags |= CMOD_BROWSE;</a>
<a name="ln2431">        continue;</a>
<a name="ln2432">      }</a>
<a name="ln2433">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;botright&quot;, 2)) {</a>
<a name="ln2434">        break;</a>
<a name="ln2435">      }</a>
<a name="ln2436">      cmod-&gt;cmod_split |= WSP_BOT;</a>
<a name="ln2437">      continue;</a>
<a name="ln2438"> </a>
<a name="ln2439">    case 'c':</a>
<a name="ln2440">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;confirm&quot;, 4)) {</a>
<a name="ln2441">        break;</a>
<a name="ln2442">      }</a>
<a name="ln2443">      cmod-&gt;cmod_flags |= CMOD_CONFIRM;</a>
<a name="ln2444">      continue;</a>
<a name="ln2445"> </a>
<a name="ln2446">    case 'k':</a>
<a name="ln2447">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepmarks&quot;, 3)) {</a>
<a name="ln2448">        cmod-&gt;cmod_flags |= CMOD_KEEPMARKS;</a>
<a name="ln2449">        continue;</a>
<a name="ln2450">      }</a>
<a name="ln2451">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepalt&quot;, 5)) {</a>
<a name="ln2452">        cmod-&gt;cmod_flags |= CMOD_KEEPALT;</a>
<a name="ln2453">        continue;</a>
<a name="ln2454">      }</a>
<a name="ln2455">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keeppatterns&quot;, 5)) {</a>
<a name="ln2456">        cmod-&gt;cmod_flags |= CMOD_KEEPPATTERNS;</a>
<a name="ln2457">        continue;</a>
<a name="ln2458">      }</a>
<a name="ln2459">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;keepjumps&quot;, 5)) {</a>
<a name="ln2460">        break;</a>
<a name="ln2461">      }</a>
<a name="ln2462">      cmod-&gt;cmod_flags |= CMOD_KEEPJUMPS;</a>
<a name="ln2463">      continue;</a>
<a name="ln2464"> </a>
<a name="ln2465">    case 'f': {  // only accept &quot;:filter {pat} cmd&quot;</a>
<a name="ln2466">      char *reg_pat;</a>
<a name="ln2467"> </a>
<a name="ln2468">      if (!checkforcmd(&amp;p, &quot;filter&quot;, 4) || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2469">        break;</a>
<a name="ln2470">      }</a>
<a name="ln2471">      if (*p == '!') {</a>
<a name="ln2472">        cmod-&gt;cmod_filter_force = true;</a>
<a name="ln2473">        p = skipwhite(p + 1);</a>
<a name="ln2474">        if (*p == NUL || ends_excmd(*p)) {</a>
<a name="ln2475">          break;</a>
<a name="ln2476">        }</a>
<a name="ln2477">      }</a>
<a name="ln2478">      if (skip_only) {</a>
<a name="ln2479">        p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln2480">      } else {</a>
<a name="ln2481">        // NOTE: This puts a NUL after the pattern.</a>
<a name="ln2482">        p = skip_vimgrep_pat(p, &amp;reg_pat, NULL);</a>
<a name="ln2483">      }</a>
<a name="ln2484">      if (p == NULL || *p == NUL) {</a>
<a name="ln2485">        break;</a>
<a name="ln2486">      }</a>
<a name="ln2487">      if (!skip_only) {</a>
<a name="ln2488">        cmod-&gt;cmod_filter_pat = xstrdup(reg_pat);</a>
<a name="ln2489">        cmod-&gt;cmod_filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln2490">        if (cmod-&gt;cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2491">          break;</a>
<a name="ln2492">        }</a>
<a name="ln2493">      }</a>
<a name="ln2494">      eap-&gt;cmd = p;</a>
<a name="ln2495">      continue;</a>
<a name="ln2496">    }</a>
<a name="ln2497"> </a>
<a name="ln2498">    case 'h':</a>
<a name="ln2499">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;horizontal&quot;, 3)) {</a>
<a name="ln2500">        cmod-&gt;cmod_split |= WSP_HOR;</a>
<a name="ln2501">        continue;</a>
<a name="ln2502">      }</a>
<a name="ln2503">      // &quot;:hide&quot; and &quot;:hide | cmd&quot; are not modifiers</a>
<a name="ln2504">      if (p != eap-&gt;cmd || !checkforcmd(&amp;p, &quot;hide&quot;, 3)</a>
<a name="ln2505">          || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2506">        break;</a>
<a name="ln2507">      }</a>
<a name="ln2508">      eap-&gt;cmd = p;</a>
<a name="ln2509">      cmod-&gt;cmod_flags |= CMOD_HIDE;</a>
<a name="ln2510">      continue;</a>
<a name="ln2511"> </a>
<a name="ln2512">    case 'l':</a>
<a name="ln2513">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;lockmarks&quot;, 3)) {</a>
<a name="ln2514">        cmod-&gt;cmod_flags |= CMOD_LOCKMARKS;</a>
<a name="ln2515">        continue;</a>
<a name="ln2516">      }</a>
<a name="ln2517"> </a>
<a name="ln2518">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;leftabove&quot;, 5)) {</a>
<a name="ln2519">        break;</a>
<a name="ln2520">      }</a>
<a name="ln2521">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2522">      continue;</a>
<a name="ln2523"> </a>
<a name="ln2524">    case 'n':</a>
<a name="ln2525">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;noautocmd&quot;, 3)) {</a>
<a name="ln2526">        cmod-&gt;cmod_flags |= CMOD_NOAUTOCMD;</a>
<a name="ln2527">        continue;</a>
<a name="ln2528">      }</a>
<a name="ln2529">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;noswapfile&quot;, 3)) {</a>
<a name="ln2530">        break;</a>
<a name="ln2531">      }</a>
<a name="ln2532">      cmod-&gt;cmod_flags |= CMOD_NOSWAPFILE;</a>
<a name="ln2533">      continue;</a>
<a name="ln2534"> </a>
<a name="ln2535">    case 'r':</a>
<a name="ln2536">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;rightbelow&quot;, 6)) {</a>
<a name="ln2537">        break;</a>
<a name="ln2538">      }</a>
<a name="ln2539">      cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2540">      continue;</a>
<a name="ln2541"> </a>
<a name="ln2542">    case 's':</a>
<a name="ln2543">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;sandbox&quot;, 3)) {</a>
<a name="ln2544">        cmod-&gt;cmod_flags |= CMOD_SANDBOX;</a>
<a name="ln2545">        continue;</a>
<a name="ln2546">      }</a>
<a name="ln2547">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;silent&quot;, 3)) {</a>
<a name="ln2548">        break;</a>
<a name="ln2549">      }</a>
<a name="ln2550">      cmod-&gt;cmod_flags |= CMOD_SILENT;</a>
<a name="ln2551">      if (*eap-&gt;cmd == '!' &amp;&amp; !ascii_iswhite(eap-&gt;cmd[-1])) {</a>
<a name="ln2552">        // &quot;:silent!&quot;, but not &quot;silent !cmd&quot;</a>
<a name="ln2553">        eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln2554">        cmod-&gt;cmod_flags |= CMOD_ERRSILENT;</a>
<a name="ln2555">      }</a>
<a name="ln2556">      continue;</a>
<a name="ln2557"> </a>
<a name="ln2558">    case 't':</a>
<a name="ln2559">      if (checkforcmd(&amp;p, &quot;tab&quot;, 3)) {</a>
<a name="ln2560">        if (!skip_only) {</a>
<a name="ln2561">          int tabnr = (int)get_address(eap, &amp;eap-&gt;cmd, ADDR_TABS, eap-&gt;skip, skip_only,</a>
<a name="ln2562">                                       false, 1, errormsg);</a>
<a name="ln2563">          if (eap-&gt;cmd == NULL) {</a>
<a name="ln2564">            return false;</a>
<a name="ln2565">          }</a>
<a name="ln2566"> </a>
<a name="ln2567">          if (tabnr == MAXLNUM) {</a>
<a name="ln2568">            cmod-&gt;cmod_tab = tabpage_index(curtab) + 1;</a>
<a name="ln2569">          } else {</a>
<a name="ln2570">            if (tabnr &lt; 0 || tabnr &gt; LAST_TAB_NR) {</a>
<a name="ln2571">              *errormsg = _(e_invrange);</a>
<a name="ln2572">              return false;</a>
<a name="ln2573">            }</a>
<a name="ln2574">            cmod-&gt;cmod_tab = tabnr + 1;</a>
<a name="ln2575">          }</a>
<a name="ln2576">        }</a>
<a name="ln2577">        eap-&gt;cmd = p;</a>
<a name="ln2578">        continue;</a>
<a name="ln2579">      }</a>
<a name="ln2580">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;topleft&quot;, 2)) {</a>
<a name="ln2581">        break;</a>
<a name="ln2582">      }</a>
<a name="ln2583">      cmod-&gt;cmod_split |= WSP_TOP;</a>
<a name="ln2584">      continue;</a>
<a name="ln2585"> </a>
<a name="ln2586">    case 'u':</a>
<a name="ln2587">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;unsilent&quot;, 3)) {</a>
<a name="ln2588">        break;</a>
<a name="ln2589">      }</a>
<a name="ln2590">      cmod-&gt;cmod_flags |= CMOD_UNSILENT;</a>
<a name="ln2591">      continue;</a>
<a name="ln2592"> </a>
<a name="ln2593">    case 'v':</a>
<a name="ln2594">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;vertical&quot;, 4)) {</a>
<a name="ln2595">        cmod-&gt;cmod_split |= WSP_VERT;</a>
<a name="ln2596">        continue;</a>
<a name="ln2597">      }</a>
<a name="ln2598">      if (!checkforcmd(&amp;p, &quot;verbose&quot;, 4)) {</a>
<a name="ln2599">        break;</a>
<a name="ln2600">      }</a>
<a name="ln2601">      if (ascii_isdigit(*eap-&gt;cmd)) {</a>
<a name="ln2602">        // zero means not set, one is verbose == 0, etc.</a>
<a name="ln2603">        cmod-&gt;cmod_verbose = atoi(eap-&gt;cmd) + 1;</a>
<a name="ln2604">      } else {</a>
<a name="ln2605">        cmod-&gt;cmod_verbose = 2;  // default: verbose == 1</a>
<a name="ln2606">      }</a>
<a name="ln2607">      eap-&gt;cmd = p;</a>
<a name="ln2608">      continue;</a>
<a name="ln2609">    }</a>
<a name="ln2610">    break;</a>
<a name="ln2611">  }</a>
<a name="ln2612"> </a>
<a name="ln2613">  return OK;</a>
<a name="ln2614">}</a>
<a name="ln2615"> </a>
<a name="ln2616">/// Apply the command modifiers.  Saves current state in &quot;cmdmod&quot;, call</a>
<a name="ln2617">/// undo_cmdmod() later.</a>
<a name="ln2618">static void apply_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2619">{</a>
<a name="ln2620">  if ((cmod-&gt;cmod_flags &amp; CMOD_SANDBOX) &amp;&amp; !cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2621">    sandbox++;</a>
<a name="ln2622">    cmod-&gt;cmod_did_sandbox = true;</a>
<a name="ln2623">  }</a>
<a name="ln2624">  if (cmod-&gt;cmod_verbose &gt; 0) {</a>
<a name="ln2625">    if (cmod-&gt;cmod_verbose_save == 0) {</a>
<a name="ln2626">      cmod-&gt;cmod_verbose_save = p_verbose + 1;</a>
<a name="ln2627">    }</a>
<a name="ln2628">    p_verbose = cmod-&gt;cmod_verbose - 1;</a>
<a name="ln2629">  }</a>
<a name="ln2630"> </a>
<a name="ln2631">  if ((cmod-&gt;cmod_flags &amp; (CMOD_SILENT | CMOD_UNSILENT))</a>
<a name="ln2632">      &amp;&amp; cmod-&gt;cmod_save_msg_silent == 0) {</a>
<a name="ln2633">    cmod-&gt;cmod_save_msg_silent = msg_silent + 1;</a>
<a name="ln2634">    cmod-&gt;cmod_save_msg_scroll = msg_scroll;</a>
<a name="ln2635">  }</a>
<a name="ln2636">  if (cmod-&gt;cmod_flags &amp; CMOD_SILENT) {</a>
<a name="ln2637">    msg_silent++;</a>
<a name="ln2638">  }</a>
<a name="ln2639">  if (cmod-&gt;cmod_flags &amp; CMOD_UNSILENT) {</a>
<a name="ln2640">    msg_silent = 0;</a>
<a name="ln2641">  }</a>
<a name="ln2642"> </a>
<a name="ln2643">  if (cmod-&gt;cmod_flags &amp; CMOD_ERRSILENT) {</a>
<a name="ln2644">    emsg_silent++;</a>
<a name="ln2645">    cmod-&gt;cmod_did_esilent++;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  if ((cmod-&gt;cmod_flags &amp; CMOD_NOAUTOCMD) &amp;&amp; cmod-&gt;cmod_save_ei == NULL) {</a>
<a name="ln2649">    // Set 'eventignore' to &quot;all&quot;.</a>
<a name="ln2650">    // First save the existing option value for restoring it later.</a>
<a name="ln2651">    cmod-&gt;cmod_save_ei = xstrdup(p_ei);</a>
<a name="ln2652">    set_string_option_direct(&quot;ei&quot;, -1, &quot;all&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln2653">  }</a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">/// Undo and free contents of &quot;cmod&quot;.</a>
<a name="ln2657">void undo_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2658">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2659">{</a>
<a name="ln2660">  if (cmod-&gt;cmod_verbose_save &gt; 0) {</a>
<a name="ln2661">    p_verbose = cmod-&gt;cmod_verbose_save - 1;</a>
<a name="ln2662">    cmod-&gt;cmod_verbose_save = 0;</a>
<a name="ln2663">  }</a>
<a name="ln2664"> </a>
<a name="ln2665">  if (cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2666">    sandbox--;</a>
<a name="ln2667">    cmod-&gt;cmod_did_sandbox = false;</a>
<a name="ln2668">  }</a>
<a name="ln2669"> </a>
<a name="ln2670">  if (cmod-&gt;cmod_save_ei != NULL) {</a>
<a name="ln2671">    // Restore 'eventignore' to the value before &quot;:noautocmd&quot;.</a>
<a name="ln2672">    set_string_option_direct(&quot;ei&quot;, -1, cmod-&gt;cmod_save_ei, OPT_FREE, SID_NONE);</a>
<a name="ln2673">    free_string_option(cmod-&gt;cmod_save_ei);</a>
<a name="ln2674">    cmod-&gt;cmod_save_ei = NULL;</a>
<a name="ln2675">  }</a>
<a name="ln2676"> </a>
<a name="ln2677">  xfree(cmod-&gt;cmod_filter_pat);</a>
<a name="ln2678">  vim_regfree(cmod-&gt;cmod_filter_regmatch.regprog);</a>
<a name="ln2679"> </a>
<a name="ln2680">  if (cmod-&gt;cmod_save_msg_silent &gt; 0) {</a>
<a name="ln2681">    // messages could be enabled for a serious error, need to check if the</a>
<a name="ln2682">    // counters don't become negative</a>
<a name="ln2683">    if (!did_emsg || msg_silent &gt; cmod-&gt;cmod_save_msg_silent - 1) {</a>
<a name="ln2684">      msg_silent = cmod-&gt;cmod_save_msg_silent - 1;</a>
<a name="ln2685">    }</a>
<a name="ln2686">    emsg_silent -= cmod-&gt;cmod_did_esilent;</a>
<a name="ln2687">    if (emsg_silent &lt; 0) {</a>
<a name="ln2688">      emsg_silent = 0;</a>
<a name="ln2689">    }</a>
<a name="ln2690">    // Restore msg_scroll, it's set by file I/O commands, even when no</a>
<a name="ln2691">    // message is actually displayed.</a>
<a name="ln2692">    msg_scroll = cmod-&gt;cmod_save_msg_scroll;</a>
<a name="ln2693"> </a>
<a name="ln2694">    // &quot;silent reg&quot; or &quot;silent echo x&quot; inside &quot;redir&quot; leaves msg_col</a>
<a name="ln2695">    // somewhere in the line.  Put it back in the first column.</a>
<a name="ln2696">    if (redirecting()) {</a>
<a name="ln2697">      msg_col = 0;</a>
<a name="ln2698">    }</a>
<a name="ln2699"> </a>
<a name="ln2700">    cmod-&gt;cmod_save_msg_silent = 0;</a>
<a name="ln2701">    cmod-&gt;cmod_did_esilent = 0;</a>
<a name="ln2702">  }</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">/// Parse the address range, if any, in &quot;eap&quot;.</a>
<a name="ln2706">/// May set the last search pattern, unless &quot;silent&quot; is true.</a>
<a name="ln2707">///</a>
<a name="ln2708">/// @return  FAIL and set &quot;errormsg&quot; or return OK.</a>
<a name="ln2709">int parse_cmd_address(exarg_T *eap, const char **errormsg, bool silent)</a>
<a name="ln2710">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2711">{</a>
<a name="ln2712">  int address_count = 1;</a>
<a name="ln2713">  linenr_T lnum;</a>
<a name="ln2714">  bool need_check_cursor = false;</a>
<a name="ln2715">  int ret = FAIL;</a>
<a name="ln2716"> </a>
<a name="ln2717">  // Repeat for all ',' or ';' separated addresses.</a>
<a name="ln2718">  while (true) {</a>
<a name="ln2719">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2720">    eap-&gt;line2 = get_cmd_default_range(eap);</a>
<a name="ln2721">    eap-&gt;cmd = skipwhite(eap-&gt;cmd);</a>
<a name="ln2722">    lnum = get_address(eap, &amp;eap-&gt;cmd, eap-&gt;addr_type, eap-&gt;skip, silent,</a>
<a name="ln2723">                       eap-&gt;addr_count == 0, address_count++, errormsg);</a>
<a name="ln2724">    if (eap-&gt;cmd == NULL) {  // error detected</a>
<a name="ln2725">      goto theend;</a>
<a name="ln2726">    }</a>
<a name="ln2727">    if (lnum == MAXLNUM) {</a>
<a name="ln2728">      if (*eap-&gt;cmd == '%') {  // '%' - all lines</a>
<a name="ln2729">        eap-&gt;cmd++;</a>
<a name="ln2730">        switch (eap-&gt;addr_type) {</a>
<a name="ln2731">        case ADDR_LINES:</a>
<a name="ln2732">        case ADDR_OTHER:</a>
<a name="ln2733">          eap-&gt;line1 = 1;</a>
<a name="ln2734">          eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2735">          break;</a>
<a name="ln2736">        case ADDR_LOADED_BUFFERS: {</a>
<a name="ln2737">          buf_T *buf = firstbuf;</a>
<a name="ln2738"> </a>
<a name="ln2739">          while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2740">            buf = buf-&gt;b_next;</a>
<a name="ln2741">          }</a>
<a name="ln2742">          eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln2743">          buf = lastbuf;</a>
<a name="ln2744">          while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2745">            buf = buf-&gt;b_prev;</a>
<a name="ln2746">          }</a>
<a name="ln2747">          eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln2748">          break;</a>
<a name="ln2749">        }</a>
<a name="ln2750">        case ADDR_BUFFERS:</a>
<a name="ln2751">          eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln2752">          eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln2753">          break;</a>
<a name="ln2754">        case ADDR_WINDOWS:</a>
<a name="ln2755">        case ADDR_TABS:</a>
<a name="ln2756">          if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln2757">            eap-&gt;line1 = 1;</a>
<a name="ln2758">            eap-&gt;line2 = eap-&gt;addr_type == ADDR_WINDOWS</a>
<a name="ln2759">                ? LAST_WIN_NR : LAST_TAB_NR;</a>
<a name="ln2760">          } else {</a>
<a name="ln2761">            // there is no Vim command which uses '%' and</a>
<a name="ln2762">            // ADDR_WINDOWS or ADDR_TABS</a>
<a name="ln2763">            *errormsg = _(e_invrange);</a>
<a name="ln2764">            goto theend;</a>
<a name="ln2765">          }</a>
<a name="ln2766">          break;</a>
<a name="ln2767">        case ADDR_TABS_RELATIVE:</a>
<a name="ln2768">        case ADDR_UNSIGNED:</a>
<a name="ln2769">        case ADDR_QUICKFIX:</a>
<a name="ln2770">          *errormsg = _(e_invrange);</a>
<a name="ln2771">          goto theend;</a>
<a name="ln2772">        case ADDR_ARGUMENTS:</a>
<a name="ln2773">          if (ARGCOUNT == 0) {</a>
<a name="ln2774">            eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln2775">          } else {</a>
<a name="ln2776">            eap-&gt;line1 = 1;</a>
<a name="ln2777">            eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2778">          }</a>
<a name="ln2779">          break;</a>
<a name="ln2780">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln2781">          eap-&gt;line1 = 1;</a>
<a name="ln2782">          eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln2783">          if (eap-&gt;line2 == 0) {</a>
<a name="ln2784">            eap-&gt;line2 = 1;</a>
<a name="ln2785">          }</a>
<a name="ln2786">          break;</a>
<a name="ln2787">        case ADDR_NONE:</a>
<a name="ln2788">          // Will give an error later if a range is found.</a>
<a name="ln2789">          break;</a>
<a name="ln2790">        }</a>
<a name="ln2791">        eap-&gt;addr_count++;</a>
<a name="ln2792">      } else if (*eap-&gt;cmd == '*') {</a>
<a name="ln2793">        // '*' - visual area</a>
<a name="ln2794">        if (eap-&gt;addr_type != ADDR_LINES) {</a>
<a name="ln2795">          *errormsg = _(e_invrange);</a>
<a name="ln2796">          goto theend;</a>
<a name="ln2797">        }</a>
<a name="ln2798"> </a>
<a name="ln2799">        eap-&gt;cmd++;</a>
<a name="ln2800">        if (!eap-&gt;skip) {</a>
<a name="ln2801">          fmark_T *fm = mark_get_visual(curbuf, '&lt;');</a>
<a name="ln2802">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2803">            goto theend;</a>
<a name="ln2804">          }</a>
<a name="ln2805">          assert(fm != NULL);</a>
<a name="ln2806">          eap-&gt;line1 = fm-&gt;mark.lnum;</a>
<a name="ln2807">          fm = mark_get_visual(curbuf, '&gt;');</a>
<a name="ln2808">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2809">            goto theend;</a>
<a name="ln2810">          }</a>
<a name="ln2811">          assert(fm != NULL);</a>
<a name="ln2812">          eap-&gt;line2 = fm-&gt;mark.lnum;</a>
<a name="ln2813">          eap-&gt;addr_count++;</a>
<a name="ln2814">        }</a>
<a name="ln2815">      }</a>
<a name="ln2816">    } else {</a>
<a name="ln2817">      eap-&gt;line2 = lnum;</a>
<a name="ln2818">    }</a>
<a name="ln2819">    eap-&gt;addr_count++;</a>
<a name="ln2820"> </a>
<a name="ln2821">    if (*eap-&gt;cmd == ';') {</a>
<a name="ln2822">      if (!eap-&gt;skip) {</a>
<a name="ln2823">        curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln2824"> </a>
<a name="ln2825">        // Don't leave the cursor on an illegal line or column, but do</a>
<a name="ln2826">        // accept zero as address, so 0;/PATTERN/ works correctly</a>
<a name="ln2827">        // (where zero usually means to use the first line).</a>
<a name="ln2828">        // Check the cursor position before returning.</a>
<a name="ln2829">        if (eap-&gt;line2 &gt; 0) {</a>
<a name="ln2830">          check_cursor();</a>
<a name="ln2831">        } else {</a>
<a name="ln2832">          check_cursor_col();</a>
<a name="ln2833">        }</a>
<a name="ln2834">        need_check_cursor = true;</a>
<a name="ln2835">      }</a>
<a name="ln2836">    } else if (*eap-&gt;cmd != ',') {</a>
<a name="ln2837">      break;</a>
<a name="ln2838">    }</a>
<a name="ln2839">    eap-&gt;cmd++;</a>
<a name="ln2840">  }</a>
<a name="ln2841"> </a>
<a name="ln2842">  // One address given: set start and end lines.</a>
<a name="ln2843">  if (eap-&gt;addr_count == 1) {</a>
<a name="ln2844">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2845">    // ... but only implicit: really no address given</a>
<a name="ln2846">    if (lnum == MAXLNUM) {</a>
<a name="ln2847">      eap-&gt;addr_count = 0;</a>
<a name="ln2848">    }</a>
<a name="ln2849">  }</a>
<a name="ln2850">  ret = OK;</a>
<a name="ln2851"> </a>
<a name="ln2852">theend:</a>
<a name="ln2853">  if (need_check_cursor) {</a>
<a name="ln2854">    check_cursor();</a>
<a name="ln2855">  }</a>
<a name="ln2856">  return ret;</a>
<a name="ln2857">}</a>
<a name="ln2858"> </a>
<a name="ln2859">/// Check for an Ex command with optional tail.</a>
<a name="ln2860">/// If there is a match advance &quot;pp&quot; to the argument and return true.</a>
<a name="ln2861">///</a>
<a name="ln2862">/// @param pp   start of command</a>
<a name="ln2863">/// @param cmd  name of command</a>
<a name="ln2864">/// @param len  required length</a>
<a name="ln2865">bool checkforcmd(char **pp, const char *cmd, int len)</a>
<a name="ln2866">{</a>
<a name="ln2867">  int i;</a>
<a name="ln2868"> </a>
<a name="ln2869">  for (i = 0; cmd[i] != NUL; i++) {</a>
<a name="ln2870">    if ((cmd)[i] != (*pp)[i]) {</a>
<a name="ln2871">      break;</a>
<a name="ln2872">    }</a>
<a name="ln2873">  }</a>
<a name="ln2874">  if (i &gt;= len &amp;&amp; !ASCII_ISALPHA((*pp)[i])) {</a>
<a name="ln2875">    *pp = skipwhite(*pp + i);</a>
<a name="ln2876">    return true;</a>
<a name="ln2877">  }</a>
<a name="ln2878">  return false;</a>
<a name="ln2879">}</a>
<a name="ln2880"> </a>
<a name="ln2881">/// Append &quot;cmd&quot; to the error message in IObuff.</a>
<a name="ln2882">/// Takes care of limiting the length and handling 0xa0, which would be</a>
<a name="ln2883">/// invisible otherwise.</a>
<a name="ln2884">static void append_command(const char *cmd)</a>
<a name="ln2885">{</a>
<a name="ln2886">  size_t len = strlen(IObuff);</a>
<a name="ln2887">  const char *s = cmd;</a>
<a name="ln2888">  char *d;</a>
<a name="ln2889"> </a>
<a name="ln2890">  if (len &gt; IOSIZE - 100) {</a>
<a name="ln2891">    // Not enough space, truncate and put in &quot;...&quot;.</a>
<a name="ln2892">    d = IObuff + IOSIZE - 100;</a>
<a name="ln2893">    d -= utf_head_off(IObuff, d);</a>
<a name="ln2894">    STRCPY(d, &quot;...&quot;);</a>
<a name="ln2895">  }</a>
<a name="ln2896">  xstrlcat(IObuff, &quot;: &quot;, IOSIZE);</a>
<a name="ln2897">  d = IObuff + strlen(IObuff);</a>
<a name="ln2898">  while (*s != NUL &amp;&amp; d - IObuff + 5 &lt; IOSIZE) {</a>
<a name="ln2899">    if ((uint8_t)s[0] == 0xc2 &amp;&amp; (uint8_t)s[1] == 0xa0) {</a>
<a name="ln2900">      s += 2;</a>
<a name="ln2901">      STRCPY(d, &quot;&lt;a0&gt;&quot;);</a>
<a name="ln2902">      d += 4;</a>
<a name="ln2903">    } else if (d - IObuff + utfc_ptr2len(s) + 1 &gt;= IOSIZE) {</a>
<a name="ln2904">      break;</a>
<a name="ln2905">    } else {</a>
<a name="ln2906">      mb_copy_char(&amp;s, &amp;d);</a>
<a name="ln2907">    }</a>
<a name="ln2908">  }</a>
<a name="ln2909">  *d = NUL;</a>
<a name="ln2910">}</a>
<a name="ln2911"> </a>
<a name="ln2912">/// Return true and set &quot;*idx&quot; if &quot;p&quot; points to a one letter command.</a>
<a name="ln2913">/// - The 'k' command can directly be followed by any character.</a>
<a name="ln2914">/// - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2915">///          but :sre[wind] is another command, as are :scr[iptnames],</a>
<a name="ln2916">///          :scs[cope], :sim[alt], :sig[ns] and :sil[ent].</a>
<a name="ln2917">static int one_letter_cmd(const char *p, cmdidx_T *idx)</a>
<a name="ln2918">{</a>
<a name="ln2919">  if (*p == 'k') {</a>
<a name="ln2920">    *idx = CMD_k;</a>
<a name="ln2921">    return true;</a>
<a name="ln2922">  }</a>
<a name="ln2923">  if (p[0] == 's'</a>
<a name="ln2924">      &amp;&amp; ((p[1] == 'c'</a>
<a name="ln2925">           &amp;&amp; (p[2] == NUL</a>
<a name="ln2926">               || (p[2] != 's' &amp;&amp; p[2] != 'r'</a>
<a name="ln2927">                   &amp;&amp; (p[3] == NUL</a>
<a name="ln2928">                       || (p[3] != 'i' &amp;&amp; p[4] != 'p')))))</a>
<a name="ln2929">          || p[1] == 'g'</a>
<a name="ln2930">          || (p[1] == 'i' &amp;&amp; p[2] != 'm' &amp;&amp; p[2] != 'l' &amp;&amp; p[2] != 'g')</a>
<a name="ln2931">          || p[1] == 'I'</a>
<a name="ln2932">          || (p[1] == 'r' &amp;&amp; p[2] != 'e'))) {</a>
<a name="ln2933">    *idx = CMD_substitute;</a>
<a name="ln2934">    return true;</a>
<a name="ln2935">  }</a>
<a name="ln2936">  return false;</a>
<a name="ln2937">}</a>
<a name="ln2938"> </a>
<a name="ln2939">/// Find an Ex command by its name, either built-in or user.</a>
<a name="ln2940">/// Start of the name can be found at eap-&gt;cmd.</a>
<a name="ln2941">/// Sets eap-&gt;cmdidx and returns a pointer to char after the command name.</a>
<a name="ln2942">/// &quot;full&quot; is set to true if the whole command name matched.</a>
<a name="ln2943">///</a>
<a name="ln2944">/// @return  NULL for an ambiguous user command.</a>
<a name="ln2945">char *find_ex_command(exarg_T *eap, int *full)</a>
<a name="ln2946">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2947">{</a>
<a name="ln2948">  // Isolate the command and search for it in the command table.</a>
<a name="ln2949">  char *p = eap-&gt;cmd;</a>
<a name="ln2950">  if (one_letter_cmd(p, &amp;eap-&gt;cmdidx)) {</a>
<a name="ln2951">    p++;</a>
<a name="ln2952">  } else {</a>
<a name="ln2953">    while (ASCII_ISALPHA(*p)) {</a>
<a name="ln2954">      p++;</a>
<a name="ln2955">    }</a>
<a name="ln2956">    // for python 3.x support &quot;:py3&quot;, &quot;:python3&quot;, &quot;:py3file&quot;, etc.</a>
<a name="ln2957">    if (eap-&gt;cmd[0] == 'p' &amp;&amp; eap-&gt;cmd[1] == 'y') {</a>
<a name="ln2958">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2959">        p++;</a>
<a name="ln2960">      }</a>
<a name="ln2961">    }</a>
<a name="ln2962"> </a>
<a name="ln2963">    // check for non-alpha command</a>
<a name="ln2964">    if (p == eap-&gt;cmd &amp;&amp; vim_strchr(&quot;@!=&gt;&lt;&amp;~#&quot;, (uint8_t)(*p)) != NULL) {</a>
<a name="ln2965">      p++;</a>
<a name="ln2966">    }</a>
<a name="ln2967">    int len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2968">    // The &quot;d&quot; command can directly be followed by 'l' or 'p' flag.</a>
<a name="ln2969">    if (*eap-&gt;cmd == 'd' &amp;&amp; (p[-1] == 'l' || p[-1] == 'p')) {</a>
<a name="ln2970">      // Check for &quot;:dl&quot;, &quot;:dell&quot;, etc. to &quot;:deletel&quot;: that's</a>
<a name="ln2971">      // :delete with the 'l' flag.  Same for 'p'.</a>
<a name="ln2972">      int i;</a>
<a name="ln2973">      for (i = 0; i &lt; len; i++) {</a>
<a name="ln2974">        if (eap-&gt;cmd[i] != (&quot;delete&quot;)[i]) {</a>
<a name="ln2975">          break;</a>
<a name="ln2976">        }</a>
<a name="ln2977">      }</a>
<a name="ln2978">      if (i == len - 1) {</a>
<a name="ln2979">        len--;</a>
<a name="ln2980">        if (p[-1] == 'l') {</a>
<a name="ln2981">          eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln2982">        } else {</a>
<a name="ln2983">          eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln2984">        }</a>
<a name="ln2985">      }</a>
<a name="ln2986">    }</a>
<a name="ln2987"> </a>
<a name="ln2988">    if (ASCII_ISLOWER(eap-&gt;cmd[0])) {</a>
<a name="ln2989">      const int c1 = (uint8_t)eap-&gt;cmd[0];</a>
<a name="ln2990">      const int c2 = len == 1 ? NUL : eap-&gt;cmd[1];</a>
<a name="ln2991"> </a>
<a name="ln2992">      if (command_count != CMD_SIZE) {</a>
<a name="ln2993">        iemsg(_(&quot;E943: Command table needs to be updated, run 'make'&quot;));</a>
<a name="ln2994">        getout(1);</a>
<a name="ln2995">      }</a>
<a name="ln2996"> </a>
<a name="ln2997">      // Use a precomputed index for fast look-up in cmdnames[]</a>
<a name="ln2998">      // taking into account the first 2 letters of eap-&gt;cmd.</a>
<a name="ln2999">      eap-&gt;cmdidx = cmdidxs1[CHAR_ORD_LOW(c1)];</a>
<a name="ln3000">      if (ASCII_ISLOWER(c2)) {</a>
<a name="ln3001">        eap-&gt;cmdidx += cmdidxs2[CHAR_ORD_LOW(c1)][CHAR_ORD_LOW(c2)];</a>
<a name="ln3002">      }</a>
<a name="ln3003">    } else if (ASCII_ISUPPER(eap-&gt;cmd[0])) {</a>
<a name="ln3004">      eap-&gt;cmdidx = CMD_Next;</a>
<a name="ln3005">    } else {</a>
<a name="ln3006">      eap-&gt;cmdidx = CMD_bang;</a>
<a name="ln3007">    }</a>
<a name="ln3008">    assert(eap-&gt;cmdidx &gt;= 0);</a>
<a name="ln3009"> </a>
<a name="ln3010">    if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, eap-&gt;cmd, 3) == 0) {</a>
<a name="ln3011">      // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3012">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3013">    }</a>
<a name="ln3014"> </a>
<a name="ln3015">    for (; (int)eap-&gt;cmdidx &lt; CMD_SIZE;</a>
<a name="ln3016">         eap-&gt;cmdidx = (cmdidx_T)((int)eap-&gt;cmdidx + 1)) {</a>
<a name="ln3017">      if (strncmp(cmdnames[(int)eap-&gt;cmdidx].cmd_name, eap-&gt;cmd,</a>
<a name="ln3018">                  (size_t)len) == 0) {</a>
<a name="ln3019">        if (full != NULL</a>
<a name="ln3020">            &amp;&amp; cmdnames[(int)eap-&gt;cmdidx].cmd_name[len] == NUL) {</a>
<a name="ln3021">          *full = true;</a>
<a name="ln3022">        }</a>
<a name="ln3023">        break;</a>
<a name="ln3024">      }</a>
<a name="ln3025">    }</a>
<a name="ln3026"> </a>
<a name="ln3027">    // Look for a user defined command as a last resort.</a>
<a name="ln3028">    if ((eap-&gt;cmdidx == CMD_SIZE)</a>
<a name="ln3029">        &amp;&amp; *eap-&gt;cmd &gt;= 'A' &amp;&amp; *eap-&gt;cmd &lt;= 'Z') {</a>
<a name="ln3030">      // User defined commands may contain digits.</a>
<a name="ln3031">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln3032">        p++;</a>
<a name="ln3033">      }</a>
<a name="ln3034">      p = find_ucmd(eap, p, full, NULL, NULL);</a>
<a name="ln3035">    }</a>
<a name="ln3036">    if (p == eap-&gt;cmd) {</a>
<a name="ln3037">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3038">    }</a>
<a name="ln3039">  }</a>
<a name="ln3040"> </a>
<a name="ln3041">  return p;</a>
<a name="ln3042">}</a>
<a name="ln3043"> </a>
<a name="ln3044">static struct cmdmod {</a>
<a name="ln3045">  char *name;</a>
<a name="ln3046">  int minlen;</a>
<a name="ln3047">  int has_count;            // :123verbose  :3tab</a>
<a name="ln3048">} cmdmods[] = {</a>
<a name="ln3049">  { &quot;aboveleft&quot;, 3, false },</a>
<a name="ln3050">  { &quot;belowright&quot;, 3, false },</a>
<a name="ln3051">  { &quot;botright&quot;, 2, false },</a>
<a name="ln3052">  { &quot;browse&quot;, 3, false },</a>
<a name="ln3053">  { &quot;confirm&quot;, 4, false },</a>
<a name="ln3054">  { &quot;filter&quot;, 4, false },</a>
<a name="ln3055">  { &quot;hide&quot;, 3, false },</a>
<a name="ln3056">  { &quot;horizontal&quot;, 3, false },</a>
<a name="ln3057">  { &quot;keepalt&quot;, 5, false },</a>
<a name="ln3058">  { &quot;keepjumps&quot;, 5, false },</a>
<a name="ln3059">  { &quot;keepmarks&quot;, 3, false },</a>
<a name="ln3060">  { &quot;keeppatterns&quot;, 5, false },</a>
<a name="ln3061">  { &quot;leftabove&quot;, 5, false },</a>
<a name="ln3062">  { &quot;lockmarks&quot;, 3, false },</a>
<a name="ln3063">  { &quot;noautocmd&quot;, 3, false },</a>
<a name="ln3064">  { &quot;noswapfile&quot;, 3, false },</a>
<a name="ln3065">  { &quot;rightbelow&quot;, 6, false },</a>
<a name="ln3066">  { &quot;sandbox&quot;, 3, false },</a>
<a name="ln3067">  { &quot;silent&quot;, 3, false },</a>
<a name="ln3068">  { &quot;tab&quot;, 3, true },</a>
<a name="ln3069">  { &quot;topleft&quot;, 2, false },</a>
<a name="ln3070">  { &quot;unsilent&quot;, 3, false },</a>
<a name="ln3071">  { &quot;verbose&quot;, 4, true },</a>
<a name="ln3072">  { &quot;vertical&quot;, 4, false },</a>
<a name="ln3073">};</a>
<a name="ln3074"> </a>
<a name="ln3075">/// @return  length of a command modifier (including optional count) or,</a>
<a name="ln3076">///          zero when it's not a modifier.</a>
<a name="ln3077">int modifier_len(char *cmd)</a>
<a name="ln3078">{</a>
<a name="ln3079">  char *p = cmd;</a>
<a name="ln3080"> </a>
<a name="ln3081">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3082">    p = skipwhite(skipdigits(cmd + 1));</a>
<a name="ln3083">  }</a>
<a name="ln3084">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3085">    int j;</a>
<a name="ln3086">    for (j = 0; p[j] != NUL; j++) {</a>
<a name="ln3087">      if (p[j] != cmdmods[i].name[j]) {</a>
<a name="ln3088">        break;</a>
<a name="ln3089">      }</a>
<a name="ln3090">    }</a>
<a name="ln3091">    if (j &gt;= cmdmods[i].minlen</a>
<a name="ln3092">        &amp;&amp; !ASCII_ISALPHA(p[j])</a>
<a name="ln3093">        &amp;&amp; (p == cmd || cmdmods[i].has_count)) {</a>
<a name="ln3094">      return j + (int)(p - cmd);</a>
<a name="ln3095">    }</a>
<a name="ln3096">  }</a>
<a name="ln3097">  return 0;</a>
<a name="ln3098">}</a>
<a name="ln3099"> </a>
<a name="ln3100">/// @return  &gt; 0 if an Ex command &quot;name&quot; exists or,</a>
<a name="ln3101">///            2 if there is an exact match or,</a>
<a name="ln3102">///            3 if there is an ambiguous match.</a>
<a name="ln3103">int cmd_exists(const char *const name)</a>
<a name="ln3104">{</a>
<a name="ln3105">  // Check command modifiers.</a>
<a name="ln3106">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3107">    int j;</a>
<a name="ln3108">    for (j = 0; name[j] != NUL; j++) {</a>
<a name="ln3109">      if (name[j] != cmdmods[i].name[j]) {</a>
<a name="ln3110">        break;</a>
<a name="ln3111">      }</a>
<a name="ln3112">    }</a>
<a name="ln3113">    if (name[j] == NUL &amp;&amp; j &gt;= cmdmods[i].minlen) {</a>
<a name="ln3114">      return cmdmods[i].name[j] == NUL ? 2 : 1;</a>
<a name="ln3115">    }</a>
<a name="ln3116">  }</a>
<a name="ln3117"> </a>
<a name="ln3118">  // Check built-in commands and user defined commands.</a>
<a name="ln3119">  // For &quot;:2match&quot; and &quot;:3match&quot; we need to skip the number.</a>
<a name="ln3120">  exarg_T ea;</a>
<a name="ln3121">  ea.cmd = (char *)((*name == '2' || *name == '3') ? name + 1 : name);</a>
<a name="ln3122">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3123">  ea.flags = 0;</a>
<a name="ln3124">  int full = false;</a>
<a name="ln3125">  char *p = find_ex_command(&amp;ea, &amp;full);</a>
<a name="ln3126">  if (p == NULL) {</a>
<a name="ln3127">    return 3;</a>
<a name="ln3128">  }</a>
<a name="ln3129">  if (ascii_isdigit(*name) &amp;&amp; ea.cmdidx != CMD_match) {</a>
<a name="ln3130">    return 0;</a>
<a name="ln3131">  }</a>
<a name="ln3132">  if (*skipwhite(p) != NUL) {</a>
<a name="ln3133">    return 0;           // trailing garbage</a>
<a name="ln3134">  }</a>
<a name="ln3135">  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);</a>
<a name="ln3136">}</a>
<a name="ln3137"> </a>
<a name="ln3138">/// &quot;fullcommand&quot; function</a>
<a name="ln3139">void f_fullcommand(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3140">{</a>
<a name="ln3141">  char *name = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3142"> </a>
<a name="ln3143">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3144">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3145">  if (name == NULL) {</a>
<a name="ln3146">    return;</a>
<a name="ln3147">  }</a>
<a name="ln3148"> </a>
<a name="ln3149">  while (*name == ':') {</a>
<a name="ln3150">    name++;</a>
<a name="ln3151">  }</a>
<a name="ln3152">  name = skip_range(name, NULL);</a>
<a name="ln3153"> </a>
<a name="ln3154">  exarg_T ea;</a>
<a name="ln3155">  ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;</a>
<a name="ln3156">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3157">  ea.flags = 0;</a>
<a name="ln3158">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln3159">  if (p == NULL || ea.cmdidx == CMD_SIZE) {</a>
<a name="ln3160">    return;</a>
<a name="ln3161">  }</a>
<a name="ln3162"> </a>
<a name="ln3163">  rettv-&gt;vval.v_string = xstrdup(IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln3164">                                 ? get_user_command_name(ea.useridx, ea.cmdidx)</a>
<a name="ln3165">                                 : cmdnames[ea.cmdidx].cmd_name);</a>
<a name="ln3166">}</a>
<a name="ln3167"> </a>
<a name="ln3168">cmdidx_T excmd_get_cmdidx(const char *cmd, size_t len)</a>
<a name="ln3169">{</a>
<a name="ln3170">  if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, cmd, 3) == 0) {</a>
<a name="ln3171">    // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3172">    return CMD_SIZE;</a>
<a name="ln3173">  }</a>
<a name="ln3174"> </a>
<a name="ln3175">  cmdidx_T idx;</a>
<a name="ln3176"> </a>
<a name="ln3177">  if (!one_letter_cmd(cmd, &amp;idx)) {</a>
<a name="ln3178">    for (idx = (cmdidx_T)0; (int)idx &lt; CMD_SIZE; idx = (cmdidx_T)((int)idx + 1)) {</a>
<a name="ln3179">      if (strncmp(cmdnames[(int)idx].cmd_name, cmd, len) == 0) {</a>
<a name="ln3180">        break;</a>
<a name="ln3181">      }</a>
<a name="ln3182">    }</a>
<a name="ln3183">  }</a>
<a name="ln3184"> </a>
<a name="ln3185">  return idx;</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188">uint32_t excmd_get_argt(cmdidx_T idx)</a>
<a name="ln3189">{</a>
<a name="ln3190">  return cmdnames[(int)idx].cmd_argt;</a>
<a name="ln3191">}</a>
<a name="ln3192"> </a>
<a name="ln3193">/// Skip a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln3194">///</a>
<a name="ln3195">/// Backslashed delimiters after / or ? will be skipped, and commands will</a>
<a name="ln3196">/// not be expanded between /'s and ?'s or after &quot;'&quot;.</a>
<a name="ln3197">///</a>
<a name="ln3198">/// Also skip white space and &quot;:&quot; characters.</a>
<a name="ln3199">///</a>
<a name="ln3200">/// @param ctx  pointer to xp_context or NULL</a>
<a name="ln3201">///</a>
<a name="ln3202">/// @return the &quot;cmd&quot; pointer advanced to beyond the range.</a>
<a name="ln3203">char *skip_range(const char *cmd, int *ctx)</a>
<a name="ln3204">{</a>
<a name="ln3205">  while (vim_strchr(&quot; \t0123456789.$%'/?-+,;\\&quot;, (uint8_t)(*cmd)) != NULL) {</a>
<a name="ln3206">    if (*cmd == '\\') {</a>
<a name="ln3207">      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&amp;') {</a>
<a name="ln3208">        cmd++;</a>
<a name="ln3209">      } else {</a>
<a name="ln3210">        break;</a>
<a name="ln3211">      }</a>
<a name="ln3212">    } else if (*cmd == '\'') {</a>
<a name="ln3213">      if (*++cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3214">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3215">      }</a>
<a name="ln3216">    } else if (*cmd == '/' || *cmd == '?') {</a>
<a name="ln3217">      unsigned delim = (unsigned)(*cmd++);</a>
<a name="ln3218">      while (*cmd != NUL &amp;&amp; *cmd != (char)delim) {</a>
<a name="ln3219">        if (*cmd++ == '\\' &amp;&amp; *cmd != NUL) {</a>
<a name="ln3220">          cmd++;</a>
<a name="ln3221">        }</a>
<a name="ln3222">      }</a>
<a name="ln3223">      if (*cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3224">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3225">      }</a>
<a name="ln3226">    }</a>
<a name="ln3227">    if (*cmd != NUL) {</a>
<a name="ln3228">      cmd++;</a>
<a name="ln3229">    }</a>
<a name="ln3230">  }</a>
<a name="ln3231"> </a>
<a name="ln3232">  // Skip &quot;:&quot; and white space.</a>
<a name="ln3233">  cmd = skip_colon_white(cmd, false);</a>
<a name="ln3234"> </a>
<a name="ln3235">  return (char *)cmd;</a>
<a name="ln3236">}</a>
<a name="ln3237"> </a>
<a name="ln3238">static const char *addr_error(cmd_addr_T addr_type)</a>
<a name="ln3239">{</a>
<a name="ln3240">  if (addr_type == ADDR_NONE) {</a>
<a name="ln3241">    return _(e_norange);</a>
<a name="ln3242">  } else {</a>
<a name="ln3243">    return _(e_invrange);</a>
<a name="ln3244">  }</a>
<a name="ln3245">}</a>
<a name="ln3246"> </a>
<a name="ln3247">/// Gets a single EX address.</a>
<a name="ln3248">///</a>
<a name="ln3249">/// Sets ptr to the next character after the part that was interpreted.</a>
<a name="ln3250">/// Sets ptr to NULL when an error is encountered (stored in `errormsg`).</a>
<a name="ln3251">/// May set the last used search pattern.</a>
<a name="ln3252">///</a>
<a name="ln3253">/// @param skip           only skip the address, don't use it</a>
<a name="ln3254">/// @param silent         no errors or side effects</a>
<a name="ln3255">/// @param to_other_file  flag: may jump to other file</a>
<a name="ln3256">/// @param address_count  1 for first, &gt;1 after comma</a>
<a name="ln3257">/// @param errormsg       Error message, if any</a>
<a name="ln3258">///</a>
<a name="ln3259">/// @return               MAXLNUM when no Ex address was found.</a>
<a name="ln3260">static linenr_T get_address(exarg_T *eap, char **ptr, cmd_addr_T addr_type, int skip, bool silent,</a>
<a name="ln3261">                            int to_other_file, int address_count, const char **errormsg)</a>
<a name="ln3262">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3263">{</a>
<a name="ln3264">  int c;</a>
<a name="ln3265">  int i;</a>
<a name="ln3266">  linenr_T n;</a>
<a name="ln3267">  pos_T pos;</a>
<a name="ln3268">  buf_T *buf;</a>
<a name="ln3269"> </a>
<a name="ln3270">  char *cmd = skipwhite(*ptr);</a>
<a name="ln3271">  linenr_T lnum = MAXLNUM;</a>
<a name="ln3272">  do {</a>
<a name="ln3273">    switch (*cmd) {</a>
<a name="ln3274">    case '.':                               // '.' - Cursor position</a>
<a name="ln3275">      cmd++;</a>
<a name="ln3276">      switch (addr_type) {</a>
<a name="ln3277">      case ADDR_LINES:</a>
<a name="ln3278">      case ADDR_OTHER:</a>
<a name="ln3279">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3280">        break;</a>
<a name="ln3281">      case ADDR_WINDOWS:</a>
<a name="ln3282">        lnum = CURRENT_WIN_NR;</a>
<a name="ln3283">        break;</a>
<a name="ln3284">      case ADDR_ARGUMENTS:</a>
<a name="ln3285">        lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3286">        break;</a>
<a name="ln3287">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3288">      case ADDR_BUFFERS:</a>
<a name="ln3289">        lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3290">        break;</a>
<a name="ln3291">      case ADDR_TABS:</a>
<a name="ln3292">        lnum = CURRENT_TAB_NR;</a>
<a name="ln3293">        break;</a>
<a name="ln3294">      case ADDR_NONE:</a>
<a name="ln3295">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3296">      case ADDR_UNSIGNED:</a>
<a name="ln3297">        *errormsg = addr_error(addr_type);</a>
<a name="ln3298">        cmd = NULL;</a>
<a name="ln3299">        goto error;</a>
<a name="ln3300">        break;</a>
<a name="ln3301">      case ADDR_QUICKFIX:</a>
<a name="ln3302">        lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3303">        break;</a>
<a name="ln3304">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3305">        lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3306">        break;</a>
<a name="ln3307">      }</a>
<a name="ln3308">      break;</a>
<a name="ln3309"> </a>
<a name="ln3310">    case '$':                               // '$' - last line</a>
<a name="ln3311">      cmd++;</a>
<a name="ln3312">      switch (addr_type) {</a>
<a name="ln3313">      case ADDR_LINES:</a>
<a name="ln3314">      case ADDR_OTHER:</a>
<a name="ln3315">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3316">        break;</a>
<a name="ln3317">      case ADDR_WINDOWS:</a>
<a name="ln3318">        lnum = LAST_WIN_NR;</a>
<a name="ln3319">        break;</a>
<a name="ln3320">      case ADDR_ARGUMENTS:</a>
<a name="ln3321">        lnum = ARGCOUNT;</a>
<a name="ln3322">        break;</a>
<a name="ln3323">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3324">        buf = lastbuf;</a>
<a name="ln3325">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3326">          if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3327">            break;</a>
<a name="ln3328">          }</a>
<a name="ln3329">          buf = buf-&gt;b_prev;</a>
<a name="ln3330">        }</a>
<a name="ln3331">        lnum = buf-&gt;b_fnum;</a>
<a name="ln3332">        break;</a>
<a name="ln3333">      case ADDR_BUFFERS:</a>
<a name="ln3334">        lnum = lastbuf-&gt;b_fnum;</a>
<a name="ln3335">        break;</a>
<a name="ln3336">      case ADDR_TABS:</a>
<a name="ln3337">        lnum = LAST_TAB_NR;</a>
<a name="ln3338">        break;</a>
<a name="ln3339">      case ADDR_NONE:</a>
<a name="ln3340">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3341">      case ADDR_UNSIGNED:</a>
<a name="ln3342">        *errormsg = addr_error(addr_type);</a>
<a name="ln3343">        cmd = NULL;</a>
<a name="ln3344">        goto error;</a>
<a name="ln3345">        break;</a>
<a name="ln3346">      case ADDR_QUICKFIX:</a>
<a name="ln3347">        lnum = (linenr_T)qf_get_size(eap);</a>
<a name="ln3348">        if (lnum == 0) {</a>
<a name="ln3349">          lnum = 1;</a>
<a name="ln3350">        }</a>
<a name="ln3351">        break;</a>
<a name="ln3352">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3353">        lnum = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln3354">        if (lnum == 0) {</a>
<a name="ln3355">          lnum = 1;</a>
<a name="ln3356">        }</a>
<a name="ln3357">        break;</a>
<a name="ln3358">      }</a>
<a name="ln3359">      break;</a>
<a name="ln3360"> </a>
<a name="ln3361">    case '\'':                              // ''' - mark</a>
<a name="ln3362">      if (*++cmd == NUL) {</a>
<a name="ln3363">        cmd = NULL;</a>
<a name="ln3364">        goto error;</a>
<a name="ln3365">      }</a>
<a name="ln3366">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3367">        *errormsg = addr_error(addr_type);</a>
<a name="ln3368">        cmd = NULL;</a>
<a name="ln3369">        goto error;</a>
<a name="ln3370">      }</a>
<a name="ln3371">      if (skip) {</a>
<a name="ln3372">        cmd++;</a>
<a name="ln3373">      } else {</a>
<a name="ln3374">        // Only accept a mark in another file when it is</a>
<a name="ln3375">        // used by itself: &quot;:'M&quot;.</a>
<a name="ln3376">        MarkGet flag = to_other_file &amp;&amp; cmd[1] == NUL ? kMarkAll : kMarkBufLocal;</a>
<a name="ln3377">        fmark_T *fm = mark_get(curbuf, curwin, NULL, flag, *cmd);</a>
<a name="ln3378">        cmd++;</a>
<a name="ln3379">        if (fm != NULL &amp;&amp; fm-&gt;fnum != curbuf-&gt;handle) {</a>
<a name="ln3380">          // Jumped to another file.</a>
<a name="ln3381">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3382">        } else {</a>
<a name="ln3383">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln3384">            cmd = NULL;</a>
<a name="ln3385">            goto error;</a>
<a name="ln3386">          }</a>
<a name="ln3387">          assert(fm != NULL);</a>
<a name="ln3388">          lnum = fm-&gt;mark.lnum;</a>
<a name="ln3389">        }</a>
<a name="ln3390">      }</a>
<a name="ln3391">      break;</a>
<a name="ln3392"> </a>
<a name="ln3393">    case '/':</a>
<a name="ln3394">    case '?':                           // '/' or '?' - search</a>
<a name="ln3395">      c = (uint8_t)(*cmd++);</a>
<a name="ln3396">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3397">        *errormsg = addr_error(addr_type);</a>
<a name="ln3398">        cmd = NULL;</a>
<a name="ln3399">        goto error;</a>
<a name="ln3400">      }</a>
<a name="ln3401">      if (skip) {                       // skip &quot;/pat/&quot;</a>
<a name="ln3402">        cmd = skip_regexp(cmd, c, magic_isset());</a>
<a name="ln3403">        if (*cmd == c) {</a>
<a name="ln3404">          cmd++;</a>
<a name="ln3405">        }</a>
<a name="ln3406">      } else {</a>
<a name="ln3407">        int flags;</a>
<a name="ln3408"> </a>
<a name="ln3409">        pos = curwin-&gt;w_cursor;  // save curwin-&gt;w_cursor</a>
<a name="ln3410"> </a>
<a name="ln3411">        // When '/' or '?' follows another address, start from</a>
<a name="ln3412">        // there.</a>
<a name="ln3413">        if (lnum &gt; 0 &amp;&amp; lnum != MAXLNUM) {</a>
<a name="ln3414">          curwin-&gt;w_cursor.lnum</a>
<a name="ln3415">            = lnum &gt; curbuf-&gt;b_ml.ml_line_count ? curbuf-&gt;b_ml.ml_line_count : lnum;</a>
<a name="ln3416">        }</a>
<a name="ln3417"> </a>
<a name="ln3418">        // Start a forward search at the end of the line (unless</a>
<a name="ln3419">        // before the first line).</a>
<a name="ln3420">        // Start a backward search at the start of the line.</a>
<a name="ln3421">        // This makes sure we never match in the current</a>
<a name="ln3422">        // line, and can match anywhere in the</a>
<a name="ln3423">        // next/previous line.</a>
<a name="ln3424">        if (c == '/' &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 0) {</a>
<a name="ln3425">          curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln3426">        } else {</a>
<a name="ln3427">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3428">        }</a>
<a name="ln3429">        searchcmdlen = 0;</a>
<a name="ln3430">        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;</a>
<a name="ln3431">        if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) {</a>
<a name="ln3432">          curwin-&gt;w_cursor = pos;</a>
<a name="ln3433">          cmd = NULL;</a>
<a name="ln3434">          goto error;</a>
<a name="ln3435">        }</a>
<a name="ln3436">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3437">        curwin-&gt;w_cursor = pos;</a>
<a name="ln3438">        // adjust command string pointer</a>
<a name="ln3439">        cmd += searchcmdlen;</a>
<a name="ln3440">      }</a>
<a name="ln3441">      break;</a>
<a name="ln3442"> </a>
<a name="ln3443">    case '\\':                      // &quot;\?&quot;, &quot;\/&quot; or &quot;\&amp;&quot;, repeat search</a>
<a name="ln3444">      cmd++;</a>
<a name="ln3445">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3446">        *errormsg = addr_error(addr_type);</a>
<a name="ln3447">        cmd = NULL;</a>
<a name="ln3448">        goto error;</a>
<a name="ln3449">      }</a>
<a name="ln3450">      if (*cmd == '&amp;') {</a>
<a name="ln3451">        i = RE_SUBST;</a>
<a name="ln3452">      } else if (*cmd == '?' || *cmd == '/') {</a>
<a name="ln3453">        i = RE_SEARCH;</a>
<a name="ln3454">      } else {</a>
<a name="ln3455">        *errormsg = _(e_backslash);</a>
<a name="ln3456">        cmd = NULL;</a>
<a name="ln3457">        goto error;</a>
<a name="ln3458">      }</a>
<a name="ln3459"> </a>
<a name="ln3460">      if (!skip) {</a>
<a name="ln3461">        // When search follows another address, start from there.</a>
<a name="ln3462">        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin-&gt;w_cursor.lnum;</a>
<a name="ln3463">        // Start the search just like for the above do_search().</a>
<a name="ln3464">        pos.col = (*cmd != '?') ? MAXCOL : 0;</a>
<a name="ln3465">        pos.coladd = 0;</a>
<a name="ln3466">        if (searchit(curwin, curbuf, &amp;pos, NULL,</a>
<a name="ln3467">                     *cmd == '?' ? BACKWARD : FORWARD,</a>
<a name="ln3468">                     &quot;&quot;, 1L, SEARCH_MSG, i, NULL) != FAIL) {</a>
<a name="ln3469">          lnum = pos.lnum;</a>
<a name="ln3470">        } else {</a>
<a name="ln3471">          cmd = NULL;</a>
<a name="ln3472">          goto error;</a>
<a name="ln3473">        }</a>
<a name="ln3474">      }</a>
<a name="ln3475">      cmd++;</a>
<a name="ln3476">      break;</a>
<a name="ln3477"> </a>
<a name="ln3478">    default:</a>
<a name="ln3479">      if (ascii_isdigit(*cmd)) {                // absolute line number</a>
<a name="ln3480">        lnum = (linenr_T)getdigits(&amp;cmd, false, 0);</a>
<a name="ln3481">      }</a>
<a name="ln3482">    }</a>
<a name="ln3483"> </a>
<a name="ln3484">    while (true) {</a>
<a name="ln3485">      cmd = skipwhite(cmd);</a>
<a name="ln3486">      if (*cmd != '-' &amp;&amp; *cmd != '+' &amp;&amp; !ascii_isdigit(*cmd)) {</a>
<a name="ln3487">        break;</a>
<a name="ln3488">      }</a>
<a name="ln3489"> </a>
<a name="ln3490">      if (lnum == MAXLNUM) {</a>
<a name="ln3491">        switch (addr_type) {</a>
<a name="ln3492">        case ADDR_LINES:</a>
<a name="ln3493">        case ADDR_OTHER:</a>
<a name="ln3494">          // &quot;+1&quot; is same as &quot;.+1&quot;</a>
<a name="ln3495">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3496">          break;</a>
<a name="ln3497">        case ADDR_WINDOWS:</a>
<a name="ln3498">          lnum = CURRENT_WIN_NR;</a>
<a name="ln3499">          break;</a>
<a name="ln3500">        case ADDR_ARGUMENTS:</a>
<a name="ln3501">          lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3502">          break;</a>
<a name="ln3503">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3504">        case ADDR_BUFFERS:</a>
<a name="ln3505">          lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3506">          break;</a>
<a name="ln3507">        case ADDR_TABS:</a>
<a name="ln3508">          lnum = CURRENT_TAB_NR;</a>
<a name="ln3509">          break;</a>
<a name="ln3510">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3511">          lnum = 1;</a>
<a name="ln3512">          break;</a>
<a name="ln3513">        case ADDR_QUICKFIX:</a>
<a name="ln3514">          lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3515">          break;</a>
<a name="ln3516">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3517">          lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3518">          break;</a>
<a name="ln3519">        case ADDR_NONE:</a>
<a name="ln3520">        case ADDR_UNSIGNED:</a>
<a name="ln3521">          lnum = 0;</a>
<a name="ln3522">          break;</a>
<a name="ln3523">        }</a>
<a name="ln3524">      }</a>
<a name="ln3525"> </a>
<a name="ln3526">      if (ascii_isdigit(*cmd)) {</a>
<a name="ln3527">        i = '+';                        // &quot;number&quot; is same as &quot;+number&quot;</a>
<a name="ln3528">      } else {</a>
<a name="ln3529">        i = (uint8_t)(*cmd++);</a>
<a name="ln3530">      }</a>
<a name="ln3531">      if (!ascii_isdigit(*cmd)) {       // '+' is '+1'</a>
<a name="ln3532">        n = 1;</a>
<a name="ln3533">      } else {</a>
<a name="ln3534">        // &quot;number&quot;, &quot;+number&quot; or &quot;-number&quot;</a>
<a name="ln3535">        n = getdigits_int32(&amp;cmd, false, MAXLNUM);</a>
<a name="ln3536">        if (n == MAXLNUM) {</a>
<a name="ln3537">          *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3538">          goto error;</a>
<a name="ln3539">        }</a>
<a name="ln3540">      }</a>
<a name="ln3541"> </a>
<a name="ln3542">      if (addr_type == ADDR_TABS_RELATIVE) {</a>
<a name="ln3543">        *errormsg = _(e_invrange);</a>
<a name="ln3544">        cmd = NULL;</a>
<a name="ln3545">        goto error;</a>
<a name="ln3546">      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {</a>
<a name="ln3547">        lnum = compute_buffer_local_count(addr_type, lnum, (i == '-') ? -1 * n : n);</a>
<a name="ln3548">      } else {</a>
<a name="ln3549">        // Relative line addressing: need to adjust for lines in a</a>
<a name="ln3550">        // closed fold after the first address.</a>
<a name="ln3551">        if (addr_type == ADDR_LINES &amp;&amp; (i == '-' || i == '+')</a>
<a name="ln3552">            &amp;&amp; address_count &gt;= 2) {</a>
<a name="ln3553">          (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3554">        }</a>
<a name="ln3555">        if (i == '-') {</a>
<a name="ln3556">          lnum -= n;</a>
<a name="ln3557">        } else {</a>
<a name="ln3558">          if (n &gt;= INT32_MAX - lnum) {</a>
<a name="ln3559">            *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3560">            goto error;</a>
<a name="ln3561">          }</a>
<a name="ln3562">          lnum += n;</a>
<a name="ln3563">        }</a>
<a name="ln3564">      }</a>
<a name="ln3565">    }</a>
<a name="ln3566">  } while (*cmd == '/' || *cmd == '?');</a>
<a name="ln3567"> </a>
<a name="ln3568">error:</a>
<a name="ln3569">  *ptr = cmd;</a>
<a name="ln3570">  return lnum;</a>
<a name="ln3571">}</a>
<a name="ln3572"> </a>
<a name="ln3573">/// Get flags from an Ex command argument.</a>
<a name="ln3574">static void get_flags(exarg_T *eap)</a>
<a name="ln3575">{</a>
<a name="ln3576">  while (vim_strchr(&quot;lp#&quot;, (uint8_t)(*eap-&gt;arg)) != NULL) {</a>
<a name="ln3577">    if (*eap-&gt;arg == 'l') {</a>
<a name="ln3578">      eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln3579">    } else if (*eap-&gt;arg == 'p') {</a>
<a name="ln3580">      eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln3581">    } else {</a>
<a name="ln3582">      eap-&gt;flags |= EXFLAG_NR;</a>
<a name="ln3583">    }</a>
<a name="ln3584">    eap-&gt;arg = skipwhite(eap-&gt;arg + 1);</a>
<a name="ln3585">  }</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">/// Stub function for command which is Not Implemented. NI!</a>
<a name="ln3589">void ex_ni(exarg_T *eap)</a>
<a name="ln3590">{</a>
<a name="ln3591">  if (!eap-&gt;skip) {</a>
<a name="ln3592">    eap-&gt;errmsg = _(&quot;E319: The command is not available in this version&quot;);</a>
<a name="ln3593">  }</a>
<a name="ln3594">}</a>
<a name="ln3595"> </a>
<a name="ln3596">/// Stub function for script command which is Not Implemented. NI!</a>
<a name="ln3597">/// Skips over &quot;:perl &lt;&lt;EOF&quot; constructs.</a>
<a name="ln3598">static void ex_script_ni(exarg_T *eap)</a>
<a name="ln3599">{</a>
<a name="ln3600">  if (!eap-&gt;skip) {</a>
<a name="ln3601">    ex_ni(eap);</a>
<a name="ln3602">  } else {</a>
<a name="ln3603">    size_t len;</a>
<a name="ln3604">    xfree(script_get(eap, &amp;len));</a>
<a name="ln3605">  }</a>
<a name="ln3606">}</a>
<a name="ln3607"> </a>
<a name="ln3608">/// Check range in Ex command for validity.</a>
<a name="ln3609">///</a>
<a name="ln3610">/// @return  NULL when valid, error message when invalid.</a>
<a name="ln3611">char *invalid_range(exarg_T *eap)</a>
<a name="ln3612">{</a>
<a name="ln3613">  buf_T *buf;</a>
<a name="ln3614">  if (eap-&gt;line1 &lt; 0 || eap-&gt;line2 &lt; 0 || eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln3615">    return _(e_invrange);</a>
<a name="ln3616">  }</a>
<a name="ln3617"> </a>
<a name="ln3618">  if (eap-&gt;argt &amp; EX_RANGE) {</a>
<a name="ln3619">    switch (eap-&gt;addr_type) {</a>
<a name="ln3620">    case ADDR_LINES:</a>
<a name="ln3621">      if (eap-&gt;line2 &gt; (curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3622">                        + (eap-&gt;cmdidx == CMD_diffget))) {</a>
<a name="ln3623">        return _(e_invrange);</a>
<a name="ln3624">      }</a>
<a name="ln3625">      break;</a>
<a name="ln3626">    case ADDR_ARGUMENTS:</a>
<a name="ln3627">      // add 1 if ARGCOUNT is 0</a>
<a name="ln3628">      if (eap-&gt;line2 &gt; ARGCOUNT + (!ARGCOUNT)) {</a>
<a name="ln3629">        return _(e_invrange);</a>
<a name="ln3630">      }</a>
<a name="ln3631">      break;</a>
<a name="ln3632">    case ADDR_BUFFERS:</a>
<a name="ln3633">      // Only a boundary check, not whether the buffers actually</a>
<a name="ln3634">      // exist.</a>
<a name="ln3635">      if (eap-&gt;line1 &lt; 1 || eap-&gt;line2 &gt; get_highest_fnum()) {</a>
<a name="ln3636">        return _(e_invrange);</a>
<a name="ln3637">      }</a>
<a name="ln3638">      break;</a>
<a name="ln3639">    case ADDR_LOADED_BUFFERS:</a>
<a name="ln3640">      buf = firstbuf;</a>
<a name="ln3641">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3642">        if (buf-&gt;b_next == NULL) {</a>
<a name="ln3643">          return _(e_invrange);</a>
<a name="ln3644">        }</a>
<a name="ln3645">        buf = buf-&gt;b_next;</a>
<a name="ln3646">      }</a>
<a name="ln3647">      if (eap-&gt;line1 &lt; buf-&gt;b_fnum) {</a>
<a name="ln3648">        return _(e_invrange);</a>
<a name="ln3649">      }</a>
<a name="ln3650">      buf = lastbuf;</a>
<a name="ln3651">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3652">        if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3653">          return _(e_invrange);</a>
<a name="ln3654">        }</a>
<a name="ln3655">        buf = buf-&gt;b_prev;</a>
<a name="ln3656">      }</a>
<a name="ln3657">      if (eap-&gt;line2 &gt; buf-&gt;b_fnum) {</a>
<a name="ln3658">        return _(e_invrange);</a>
<a name="ln3659">      }</a>
<a name="ln3660">      break;</a>
<a name="ln3661">    case ADDR_WINDOWS:</a>
<a name="ln3662">      if (eap-&gt;line2 &gt; LAST_WIN_NR) {</a>
<a name="ln3663">        return _(e_invrange);</a>
<a name="ln3664">      }</a>
<a name="ln3665">      break;</a>
<a name="ln3666">    case ADDR_TABS:</a>
<a name="ln3667">      if (eap-&gt;line2 &gt; LAST_TAB_NR) {</a>
<a name="ln3668">        return _(e_invrange);</a>
<a name="ln3669">      }</a>
<a name="ln3670">      break;</a>
<a name="ln3671">    case ADDR_TABS_RELATIVE:</a>
<a name="ln3672">    case ADDR_OTHER:</a>
<a name="ln3673">      // Any range is OK.</a>
<a name="ln3674">      break;</a>
<a name="ln3675">    case ADDR_QUICKFIX:</a>
<a name="ln3676">      assert(eap-&gt;line2 &gt;= 0);</a>
<a name="ln3677">      // No error for value that is too big, will use the last entry.</a>
<a name="ln3678">      if (eap-&gt;line2 &lt;= 0) {</a>
<a name="ln3679">        if (eap-&gt;addr_count == 0) {</a>
<a name="ln3680">          return _(e_no_errors);</a>
<a name="ln3681">        }</a>
<a name="ln3682">        return _(e_invrange);</a>
<a name="ln3683">      }</a>
<a name="ln3684">      break;</a>
<a name="ln3685">    case ADDR_QUICKFIX_VALID:</a>
<a name="ln3686">      if ((eap-&gt;line2 != 1 &amp;&amp; (size_t)eap-&gt;line2 &gt; qf_get_valid_size(eap))</a>
<a name="ln3687">          || eap-&gt;line2 &lt; 0) {</a>
<a name="ln3688">        return _(e_invrange);</a>
<a name="ln3689">      }</a>
<a name="ln3690">      break;</a>
<a name="ln3691">    case ADDR_UNSIGNED:</a>
<a name="ln3692">    case ADDR_NONE:</a>
<a name="ln3693">      // Will give an error elsewhere.</a>
<a name="ln3694">      break;</a>
<a name="ln3695">    }</a>
<a name="ln3696">  }</a>
<a name="ln3697">  return NULL;</a>
<a name="ln3698">}</a>
<a name="ln3699"> </a>
<a name="ln3700">/// Correct the range for zero line number, if required.</a>
<a name="ln3701">static void correct_range(exarg_T *eap)</a>
<a name="ln3702">{</a>
<a name="ln3703">  if (!(eap-&gt;argt &amp; EX_ZEROR)) {  // zero in range not allowed</a>
<a name="ln3704">    if (eap-&gt;line1 == 0) {</a>
<a name="ln3705">      eap-&gt;line1 = 1;</a>
<a name="ln3706">    }</a>
<a name="ln3707">    if (eap-&gt;line2 == 0) {</a>
<a name="ln3708">      eap-&gt;line2 = 1;</a>
<a name="ln3709">    }</a>
<a name="ln3710">  }</a>
<a name="ln3711">}</a>
<a name="ln3712"> </a>
<a name="ln3713">/// For a &quot;:vimgrep&quot; or &quot;:vimgrepadd&quot; command return a pointer past the</a>
<a name="ln3714">/// pattern.  Otherwise return eap-&gt;arg.</a>
<a name="ln3715">static char *skip_grep_pat(exarg_T *eap)</a>
<a name="ln3716">{</a>
<a name="ln3717">  char *p = eap-&gt;arg;</a>
<a name="ln3718"> </a>
<a name="ln3719">  if (*p != NUL &amp;&amp; (eap-&gt;cmdidx == CMD_vimgrep || eap-&gt;cmdidx == CMD_lvimgrep</a>
<a name="ln3720">                    || eap-&gt;cmdidx == CMD_vimgrepadd</a>
<a name="ln3721">                    || eap-&gt;cmdidx == CMD_lvimgrepadd</a>
<a name="ln3722">                    || grep_internal(eap-&gt;cmdidx))) {</a>
<a name="ln3723">    p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln3724">    if (p == NULL) {</a>
<a name="ln3725">      p = eap-&gt;arg;</a>
<a name="ln3726">    }</a>
<a name="ln3727">  }</a>
<a name="ln3728">  return p;</a>
<a name="ln3729">}</a>
<a name="ln3730"> </a>
<a name="ln3731">/// For the &quot;:make&quot; and &quot;:grep&quot; commands insert the 'makeprg'/'grepprg' option</a>
<a name="ln3732">/// in the command line, so that things like % get expanded.</a>
<a name="ln3733">char *replace_makeprg(exarg_T *eap, char *arg, char **cmdlinep)</a>
<a name="ln3734">{</a>
<a name="ln3735">  bool isgrep = eap-&gt;cmdidx == CMD_grep</a>
<a name="ln3736">                || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln3737">                || eap-&gt;cmdidx == CMD_grepadd</a>
<a name="ln3738">                || eap-&gt;cmdidx == CMD_lgrepadd;</a>
<a name="ln3739"> </a>
<a name="ln3740">  // Don't do it when &quot;:vimgrep&quot; is used for &quot;:grep&quot;.</a>
<a name="ln3741">  if ((eap-&gt;cmdidx == CMD_make || eap-&gt;cmdidx == CMD_lmake || isgrep)</a>
<a name="ln3742">      &amp;&amp; !grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln3743">    const char *program = isgrep ? (*curbuf-&gt;b_p_gp == NUL ? p_gp : curbuf-&gt;b_p_gp)</a>
<a name="ln3744">                                 : (*curbuf-&gt;b_p_mp == NUL ? p_mp : curbuf-&gt;b_p_mp);</a>
<a name="ln3745"> </a>
<a name="ln3746">    arg = skipwhite(arg);</a>
<a name="ln3747"> </a>
<a name="ln3748">    char *new_cmdline;</a>
<a name="ln3749">    // Replace $* by given arguments</a>
<a name="ln3750">    if ((new_cmdline = strrep(program, &quot;$*&quot;, arg)) == NULL) {</a>
<a name="ln3751">      // No $* in arg, build &quot;&lt;makeprg&gt; &lt;arg&gt;&quot; instead</a>
<a name="ln3752">      new_cmdline = xmalloc(strlen(program) + strlen(arg) + 2);</a>
<a name="ln3753">      STRCPY(new_cmdline, program);</a>
<a name="ln3754">      STRCAT(new_cmdline, &quot; &quot;);</a>
<a name="ln3755">      STRCAT(new_cmdline, arg);</a>
<a name="ln3756">    }</a>
<a name="ln3757"> </a>
<a name="ln3758">    msg_make(arg);</a>
<a name="ln3759"> </a>
<a name="ln3760">    // 'eap-&gt;cmd' is not set here, because it is not used at CMD_make</a>
<a name="ln3761">    xfree(*cmdlinep);</a>
<a name="ln3762">    *cmdlinep = new_cmdline;</a>
<a name="ln3763">    arg = new_cmdline;</a>
<a name="ln3764">  }</a>
<a name="ln3765">  return arg;</a>
<a name="ln3766">}</a>
<a name="ln3767"> </a>
<a name="ln3768">/// Expand file name in Ex command argument.</a>
<a name="ln3769">/// When an error is detected, &quot;errormsgp&quot; is set to a non-NULL pointer.</a>
<a name="ln3770">///</a>
<a name="ln3771">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln3772">int expand_filename(exarg_T *eap, char **cmdlinep, const char **errormsgp)</a>
<a name="ln3773">{</a>
<a name="ln3774">  // Skip a regexp pattern for &quot;:vimgrep[add] pat file...&quot;</a>
<a name="ln3775">  char *p = skip_grep_pat(eap);</a>
<a name="ln3776"> </a>
<a name="ln3777">  // Decide to expand wildcards *before* replacing '%', '#', etc.  If</a>
<a name="ln3778">  // the file name contains a wildcard it should not cause expanding.</a>
<a name="ln3779">  // (it will be expanded anyway if there is a wildcard before replacing).</a>
<a name="ln3780">  int has_wildcards = path_has_wildcard(p);</a>
<a name="ln3781">  while (*p != NUL) {</a>
<a name="ln3782">    // Skip over `=expr`, wildcards in it are not expanded.</a>
<a name="ln3783">    if (p[0] == '`' &amp;&amp; p[1] == '=') {</a>
<a name="ln3784">      p += 2;</a>
<a name="ln3785">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln3786">      if (*p == '`') {</a>
<a name="ln3787">        p++;</a>
<a name="ln3788">      }</a>
<a name="ln3789">      continue;</a>
<a name="ln3790">    }</a>
<a name="ln3791">    // Quick check if this cannot be the start of a special string.</a>
<a name="ln3792">    // Also removes backslash before '%', '#' and '&lt;'.</a>
<a name="ln3793">    if (vim_strchr(&quot;%#&lt;&quot;, (uint8_t)(*p)) == NULL) {</a>
<a name="ln3794">      p++;</a>
<a name="ln3795">      continue;</a>
<a name="ln3796">    }</a>
<a name="ln3797"> </a>
<a name="ln3798">    // Try to find a match at this position.</a>
<a name="ln3799">    size_t srclen;</a>
<a name="ln3800">    int escaped;</a>
<a name="ln3801">    char *repl = eval_vars(p, eap-&gt;arg, &amp;srclen, &amp;(eap-&gt;do_ecmd_lnum),</a>
<a name="ln3802">                           errormsgp, &amp;escaped, true);</a>
<a name="ln3803">    if (*errormsgp != NULL) {           // error detected</a>
<a name="ln3804">      return FAIL;</a>
<a name="ln3805">    }</a>
<a name="ln3806">    if (repl == NULL) {                 // no match found</a>
<a name="ln3807">      p += srclen;</a>
<a name="ln3808">      continue;</a>
<a name="ln3809">    }</a>
<a name="ln3810"> </a>
<a name="ln3811">    // Wildcards won't be expanded below, the replacement is taken</a>
<a name="ln3812">    // literally.  But do expand &quot;~/file&quot;, &quot;~user/file&quot; and &quot;$HOME/file&quot;.</a>
<a name="ln3813">    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {</a>
<a name="ln3814">      char *l = repl;</a>
<a name="ln3815"> </a>
<a name="ln3816">      repl = expand_env_save(repl);</a>
<a name="ln3817">      xfree(l);</a>
<a name="ln3818">    }</a>
<a name="ln3819"> </a>
<a name="ln3820">    // Need to escape white space et al. with a backslash.</a>
<a name="ln3821">    // Don't do this for:</a>
<a name="ln3822">    // - replacement that already has been escaped: &quot;##&quot;</a>
<a name="ln3823">    // - shell commands (may have to use quotes instead).</a>
<a name="ln3824">    if (!eap-&gt;usefilter</a>
<a name="ln3825">        &amp;&amp; !escaped</a>
<a name="ln3826">        &amp;&amp; eap-&gt;cmdidx != CMD_bang</a>
<a name="ln3827">        &amp;&amp; eap-&gt;cmdidx != CMD_grep</a>
<a name="ln3828">        &amp;&amp; eap-&gt;cmdidx != CMD_grepadd</a>
<a name="ln3829">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrep</a>
<a name="ln3830">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln3831">        &amp;&amp; eap-&gt;cmdidx != CMD_lmake</a>
<a name="ln3832">        &amp;&amp; eap-&gt;cmdidx != CMD_make</a>
<a name="ln3833">        &amp;&amp; eap-&gt;cmdidx != CMD_terminal</a>
<a name="ln3834">        &amp;&amp; !(eap-&gt;argt &amp; EX_NOSPC)) {</a>
<a name="ln3835">      char *l;</a>
<a name="ln3836">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3837">      // Don't escape a backslash here, because rem_backslash() doesn't</a>
<a name="ln3838">      // remove it later.</a>
<a name="ln3839">      static char *nobslash = &quot; \t\&quot;|&quot;;</a>
<a name="ln3840"># define ESCAPE_CHARS nobslash</a>
<a name="ln3841">#else</a>
<a name="ln3842"># define ESCAPE_CHARS escape_chars</a>
<a name="ln3843">#endif</a>
<a name="ln3844"> </a>
<a name="ln3845">      for (l = repl; *l; l++) {</a>
<a name="ln3846">        if (vim_strchr(ESCAPE_CHARS, (uint8_t)(*l)) != NULL) {</a>
<a name="ln3847">          l = vim_strsave_escaped(repl, ESCAPE_CHARS);</a>
<a name="ln3848">          xfree(repl);</a>
<a name="ln3849">          repl = l;</a>
<a name="ln3850">          break;</a>
<a name="ln3851">        }</a>
<a name="ln3852">      }</a>
<a name="ln3853">    }</a>
<a name="ln3854"> </a>
<a name="ln3855">    // For a shell command a '!' must be escaped.</a>
<a name="ln3856">    if ((eap-&gt;usefilter</a>
<a name="ln3857">         || eap-&gt;cmdidx == CMD_bang</a>
<a name="ln3858">         || eap-&gt;cmdidx == CMD_terminal)</a>
<a name="ln3859">        &amp;&amp; strpbrk(repl, &quot;!&quot;) != NULL) {</a>
<a name="ln3860">      char *l;</a>
<a name="ln3861"> </a>
<a name="ln3862">      l = vim_strsave_escaped(repl, &quot;!&quot;);</a>
<a name="ln3863">      xfree(repl);</a>
<a name="ln3864">      repl = l;</a>
<a name="ln3865">    }</a>
<a name="ln3866"> </a>
<a name="ln3867">    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);</a>
<a name="ln3868">    xfree(repl);</a>
<a name="ln3869">  }</a>
<a name="ln3870"> </a>
<a name="ln3871">  // One file argument: Expand wildcards.</a>
<a name="ln3872">  // Don't do this with &quot;:r !command&quot; or &quot;:w !command&quot;.</a>
<a name="ln3873">  if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; !eap-&gt;usefilter) {</a>
<a name="ln3874">    // Replace environment variables.</a>
<a name="ln3875">    if (has_wildcards) {</a>
<a name="ln3876">      // May expand environment variables.  This</a>
<a name="ln3877">      // can be done much faster with expand_env() than with</a>
<a name="ln3878">      // something else (e.g., calling a shell).</a>
<a name="ln3879">      // After expanding environment variables, check again</a>
<a name="ln3880">      // if there are still wildcards present.</a>
<a name="ln3881">      if (vim_strchr(eap-&gt;arg, '$') != NULL</a>
<a name="ln3882">          || vim_strchr(eap-&gt;arg, '~') != NULL) {</a>
<a name="ln3883">        expand_env_esc(eap-&gt;arg, NameBuff, MAXPATHL, true, true, NULL);</a>
<a name="ln3884">        has_wildcards = path_has_wildcard(NameBuff);</a>
<a name="ln3885">        p = NameBuff;</a>
<a name="ln3886">      } else {</a>
<a name="ln3887">        p = NULL;</a>
<a name="ln3888">      }</a>
<a name="ln3889">      if (p != NULL) {</a>
<a name="ln3890">        (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3891">      }</a>
<a name="ln3892">    }</a>
<a name="ln3893"> </a>
<a name="ln3894">    // Halve the number of backslashes (this is Vi compatible).</a>
<a name="ln3895">    // For Unix, when wildcards are expanded, this is</a>
<a name="ln3896">    // done by ExpandOne() below.</a>
<a name="ln3897">#ifdef UNIX</a>
<a name="ln3898">    if (!has_wildcards) {</a>
<a name="ln3899">      backslash_halve(eap-&gt;arg);</a>
<a name="ln3900">    }</a>
<a name="ln3901">#else</a>
<a name="ln3902">    backslash_halve(eap-&gt;arg);</a>
<a name="ln3903">#endif</a>
<a name="ln3904"> </a>
<a name="ln3905">    if (has_wildcards) {</a>
<a name="ln3906">      expand_T xpc;</a>
<a name="ln3907">      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;</a>
<a name="ln3908"> </a>
<a name="ln3909">      ExpandInit(&amp;xpc);</a>
<a name="ln3910">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln3911">      if (p_wic) {</a>
<a name="ln3912">        options += WILD_ICASE;</a>
<a name="ln3913">      }</a>
<a name="ln3914">      p = ExpandOne(&amp;xpc, eap-&gt;arg, NULL, options, WILD_EXPAND_FREE);</a>
<a name="ln3915">      if (p == NULL) {</a>
<a name="ln3916">        return FAIL;</a>
<a name="ln3917">      }</a>
<a name="ln3918">      (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3919">      xfree(p);</a>
<a name="ln3920">    }</a>
<a name="ln3921">  }</a>
<a name="ln3922">  return OK;</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">/// Replace part of the command line, keeping eap-&gt;cmd, eap-&gt;arg, eap-&gt;args and</a>
<a name="ln3926">/// eap-&gt;nextcmd correct.</a>
<a name="ln3927">/// &quot;src&quot; points to the part that is to be replaced, of length &quot;srclen&quot;.</a>
<a name="ln3928">/// &quot;repl&quot; is the replacement string.</a>
<a name="ln3929">///</a>
<a name="ln3930">/// @return  a pointer to the character after the replaced string.</a>
<a name="ln3931">static char *repl_cmdline(exarg_T *eap, char *src, size_t srclen, char *repl, char **cmdlinep)</a>
<a name="ln3932">{</a>
<a name="ln3933">  // The new command line is build in new_cmdline[].</a>
<a name="ln3934">  // First allocate it.</a>
<a name="ln3935">  // Careful: a &quot;+cmd&quot; argument may have been NUL terminated.</a>
<a name="ln3936">  size_t len = strlen(repl);</a>
<a name="ln3937">  size_t i = (size_t)(src - *cmdlinep) + strlen(src + srclen) + len + 3;</a>
<a name="ln3938">  if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln3939">    i += strlen(eap-&gt;nextcmd);    // add space for next command</a>
<a name="ln3940">  }</a>
<a name="ln3941">  char *new_cmdline = xmalloc(i);</a>
<a name="ln3942">  size_t offset = (size_t)(src - *cmdlinep);</a>
<a name="ln3943"> </a>
<a name="ln3944">  // Copy the stuff before the expanded part.</a>
<a name="ln3945">  // Copy the expanded stuff.</a>
<a name="ln3946">  // Copy what came after the expanded part.</a>
<a name="ln3947">  // Copy the next commands, if there are any.</a>
<a name="ln3948">  i = offset;   // length of part before match</a>
<a name="ln3949">  memmove(new_cmdline, *cmdlinep, i);</a>
<a name="ln3950"> </a>
<a name="ln3951">  memmove(new_cmdline + i, repl, len);</a>
<a name="ln3952">  i += len;                             // remember the end of the string</a>
<a name="ln3953">  STRCPY(new_cmdline + i, src + srclen);</a>
<a name="ln3954">  src = new_cmdline + i;                // remember where to continue</a>
<a name="ln3955"> </a>
<a name="ln3956">  if (eap-&gt;nextcmd != NULL) {           // append next command</a>
<a name="ln3957">    i = strlen(new_cmdline) + 1;</a>
<a name="ln3958">    STRCPY(new_cmdline + i, eap-&gt;nextcmd);</a>
<a name="ln3959">    eap-&gt;nextcmd = new_cmdline + i;</a>
<a name="ln3960">  }</a>
<a name="ln3961">  eap-&gt;cmd = new_cmdline + (eap-&gt;cmd - *cmdlinep);</a>
<a name="ln3962">  eap-&gt;arg = new_cmdline + (eap-&gt;arg - *cmdlinep);</a>
<a name="ln3963"> </a>
<a name="ln3964">  for (size_t j = 0; j &lt; eap-&gt;argc; j++) {</a>
<a name="ln3965">    if (offset &gt;= (size_t)(eap-&gt;args[j] - *cmdlinep)) {</a>
<a name="ln3966">      // If replaced text is after or in the same position as the argument,</a>
<a name="ln3967">      // the argument's position relative to the beginning of the cmdline stays the same.</a>
<a name="ln3968">      eap-&gt;args[j] = new_cmdline + (eap-&gt;args[j] - *cmdlinep);</a>
<a name="ln3969">    } else {</a>
<a name="ln3970">      // Otherwise, argument gets shifted alongside the replaced text.</a>
<a name="ln3971">      // The amount of the shift is equal to the difference of the old and new string length.</a>
<a name="ln3972">      eap-&gt;args[j] = new_cmdline + ((eap-&gt;args[j] - *cmdlinep) + (ptrdiff_t)(len - srclen));</a>
<a name="ln3973">    }</a>
<a name="ln3974">  }</a>
<a name="ln3975"> </a>
<a name="ln3976">  if (eap-&gt;do_ecmd_cmd != NULL &amp;&amp; eap-&gt;do_ecmd_cmd != dollar_command) {</a>
<a name="ln3977">    eap-&gt;do_ecmd_cmd = new_cmdline + (eap-&gt;do_ecmd_cmd - *cmdlinep);</a>
<a name="ln3978">  }</a>
<a name="ln3979">  xfree(*cmdlinep);</a>
<a name="ln3980">  *cmdlinep = new_cmdline;</a>
<a name="ln3981"> </a>
<a name="ln3982">  return src;</a>
<a name="ln3983">}</a>
<a name="ln3984"> </a>
<a name="ln3985">/// Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln3986">void separate_nextcmd(exarg_T *eap)</a>
<a name="ln3987">{</a>
<a name="ln3988">  char *p = skip_grep_pat(eap);</a>
<a name="ln3989"> </a>
<a name="ln3990">  for (; *p; MB_PTR_ADV(p)) {</a>
<a name="ln3991">    if (*p == Ctrl_V) {</a>
<a name="ln3992">      if (eap-&gt;argt &amp; (EX_CTRLV | EX_XFILE)) {</a>
<a name="ln3993">        p++;  // skip CTRL-V and next char</a>
<a name="ln3994">      } else {</a>
<a name="ln3995">        // remove CTRL-V and skip next char</a>
<a name="ln3996">        STRMOVE(p, p + 1);</a>
<a name="ln3997">      }</a>
<a name="ln3998">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln3999">        break;</a>
<a name="ln4000">      }</a>
<a name="ln4001">    } else if (p[0] == '`' &amp;&amp; p[1] == '=' &amp;&amp; (eap-&gt;argt &amp; EX_XFILE)) {</a>
<a name="ln4002">      // Skip over `=expr` when wildcards are expanded.</a>
<a name="ln4003">      p += 2;</a>
<a name="ln4004">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln4005">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4006">        break;</a>
<a name="ln4007">      }</a>
<a name="ln4008">    } else if (</a>
<a name="ln4009">               // Check for '&quot;': start of comment or '|': next command */</a>
<a name="ln4010">               // :@&quot; does not start a comment!</a>
<a name="ln4011">               // :redir @&quot; doesn't either.</a>
<a name="ln4012">               (*p == '&quot;'</a>
<a name="ln4013">                &amp;&amp; !(eap-&gt;argt &amp; EX_NOTRLCOM)</a>
<a name="ln4014">                &amp;&amp; (eap-&gt;cmdidx != CMD_at || p != eap-&gt;arg)</a>
<a name="ln4015">                &amp;&amp; (eap-&gt;cmdidx != CMD_redir</a>
<a name="ln4016">                    || p != eap-&gt;arg + 1 || p[-1] != '@')) || *p == '|' || *p == '\n') {</a>
<a name="ln4017">      // We remove the '\' before the '|', unless EX_CTRLV is used</a>
<a name="ln4018">      // AND 'b' is present in 'cpoptions'.</a>
<a name="ln4019">      if ((vim_strchr(p_cpo, CPO_BAR) == NULL</a>
<a name="ln4020">           || !(eap-&gt;argt &amp; EX_CTRLV)) &amp;&amp; *(p - 1) == '\\') {</a>
<a name="ln4021">        STRMOVE(p - 1, p);  // remove the '\'</a>
<a name="ln4022">        p--;</a>
<a name="ln4023">      } else {</a>
<a name="ln4024">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln4025">        *p = NUL;</a>
<a name="ln4026">        break;</a>
<a name="ln4027">      }</a>
<a name="ln4028">    }</a>
<a name="ln4029">  }</a>
<a name="ln4030"> </a>
<a name="ln4031">  if (!(eap-&gt;argt &amp; EX_NOTRLCOM)) {  // remove trailing spaces</a>
<a name="ln4032">    del_trailing_spaces(eap-&gt;arg);</a>
<a name="ln4033">  }</a>
<a name="ln4034">}</a>
<a name="ln4035"> </a>
<a name="ln4036">/// get + command from ex argument</a>
<a name="ln4037">static char *getargcmd(char **argp)</a>
<a name="ln4038">{</a>
<a name="ln4039">  char *arg = *argp;</a>
<a name="ln4040">  char *command = NULL;</a>
<a name="ln4041"> </a>
<a name="ln4042">  if (*arg == '+') {        // +[command]</a>
<a name="ln4043">    arg++;</a>
<a name="ln4044">    if (ascii_isspace(*arg) || *arg == '\0') {</a>
<a name="ln4045">      command = dollar_command;</a>
<a name="ln4046">    } else {</a>
<a name="ln4047">      command = arg;</a>
<a name="ln4048">      arg = skip_cmd_arg(command, true);</a>
<a name="ln4049">      if (*arg != NUL) {</a>
<a name="ln4050">        *arg++ = NUL;                   // terminate command with NUL</a>
<a name="ln4051">      }</a>
<a name="ln4052">    }</a>
<a name="ln4053"> </a>
<a name="ln4054">    arg = skipwhite(arg);       // skip over spaces</a>
<a name="ln4055">    *argp = arg;</a>
<a name="ln4056">  }</a>
<a name="ln4057">  return command;</a>
<a name="ln4058">}</a>
<a name="ln4059"> </a>
<a name="ln4060">/// Find end of &quot;+command&quot; argument.  Skip over &quot;\ &quot; and &quot;\\&quot;.</a>
<a name="ln4061">///</a>
<a name="ln4062">/// @param rembs  true to halve the number of backslashes</a>
<a name="ln4063">char *skip_cmd_arg(char *p, int rembs)</a>
<a name="ln4064">{</a>
<a name="ln4065">  while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln4066">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4067">      if (rembs) {</a>
<a name="ln4068">        STRMOVE(p, p + 1);</a>
<a name="ln4069">      } else {</a>
<a name="ln4070">        p++;</a>
<a name="ln4071">      }</a>
<a name="ln4072">    }</a>
<a name="ln4073">    MB_PTR_ADV(p);</a>
<a name="ln4074">  }</a>
<a name="ln4075">  return p;</a>
<a name="ln4076">}</a>
<a name="ln4077"> </a>
<a name="ln4078">int get_bad_opt(const char *p, exarg_T *eap)</a>
<a name="ln4079">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4080">{</a>
<a name="ln4081">  if (STRICMP(p, &quot;keep&quot;) == 0) {</a>
<a name="ln4082">    eap-&gt;bad_char = BAD_KEEP;</a>
<a name="ln4083">  } else if (STRICMP(p, &quot;drop&quot;) == 0) {</a>
<a name="ln4084">    eap-&gt;bad_char = BAD_DROP;</a>
<a name="ln4085">  } else if (MB_BYTE2LEN((uint8_t)(*p)) == 1 &amp;&amp; p[1] == NUL) {</a>
<a name="ln4086">    eap-&gt;bad_char = (uint8_t)(*p);</a>
<a name="ln4087">  } else {</a>
<a name="ln4088">    return FAIL;</a>
<a name="ln4089">  }</a>
<a name="ln4090">  return OK;</a>
<a name="ln4091">}</a>
<a name="ln4092"> </a>
<a name="ln4093">/// Get &quot;++opt=arg&quot; argument.</a>
<a name="ln4094">///</a>
<a name="ln4095">/// @return  FAIL or OK.</a>
<a name="ln4096">static int getargopt(exarg_T *eap)</a>
<a name="ln4097">{</a>
<a name="ln4098">  char *arg = eap-&gt;arg + 2;</a>
<a name="ln4099">  int *pp = NULL;</a>
<a name="ln4100">  int bad_char_idx;</a>
<a name="ln4101"> </a>
<a name="ln4102">  // &quot;:edit ++[no]bin[ary] file&quot;</a>
<a name="ln4103">  if (strncmp(arg, &quot;bin&quot;, 3) == 0 || strncmp(arg, &quot;nobin&quot;, 5) == 0) {</a>
<a name="ln4104">    if (*arg == 'n') {</a>
<a name="ln4105">      arg += 2;</a>
<a name="ln4106">      eap-&gt;force_bin = FORCE_NOBIN;</a>
<a name="ln4107">    } else {</a>
<a name="ln4108">      eap-&gt;force_bin = FORCE_BIN;</a>
<a name="ln4109">    }</a>
<a name="ln4110">    if (!checkforcmd(&amp;arg, &quot;binary&quot;, 3)) {</a>
<a name="ln4111">      return FAIL;</a>
<a name="ln4112">    }</a>
<a name="ln4113">    eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4114">    return OK;</a>
<a name="ln4115">  }</a>
<a name="ln4116"> </a>
<a name="ln4117">  // &quot;:read ++edit file&quot;</a>
<a name="ln4118">  if (strncmp(arg, &quot;edit&quot;, 4) == 0) {</a>
<a name="ln4119">    eap-&gt;read_edit = true;</a>
<a name="ln4120">    eap-&gt;arg = skipwhite(arg + 4);</a>
<a name="ln4121">    return OK;</a>
<a name="ln4122">  }</a>
<a name="ln4123"> </a>
<a name="ln4124">  // &quot;:write ++p foo/bar/file</a>
<a name="ln4125">  if (strncmp(arg, &quot;p&quot;, 1) == 0) {</a>
<a name="ln4126">    eap-&gt;mkdir_p = true;</a>
<a name="ln4127">    eap-&gt;arg = skipwhite(arg + 1);</a>
<a name="ln4128">    return OK;</a>
<a name="ln4129">  }</a>
<a name="ln4130"> </a>
<a name="ln4131">  if (strncmp(arg, &quot;ff&quot;, 2) == 0) {</a>
<a name="ln4132">    arg += 2;</a>
<a name="ln4133">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4134">  } else if (strncmp(arg, &quot;fileformat&quot;, 10) == 0) {</a>
<a name="ln4135">    arg += 10;</a>
<a name="ln4136">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4137">  } else if (strncmp(arg, &quot;enc&quot;, 3) == 0) {</a>
<a name="ln4138">    if (strncmp(arg, &quot;encoding&quot;, 8) == 0) {</a>
<a name="ln4139">      arg += 8;</a>
<a name="ln4140">    } else {</a>
<a name="ln4141">      arg += 3;</a>
<a name="ln4142">    }</a>
<a name="ln4143">    pp = &amp;eap-&gt;force_enc;</a>
<a name="ln4144">  } else if (strncmp(arg, &quot;bad&quot;, 3) == 0) {</a>
<a name="ln4145">    arg += 3;</a>
<a name="ln4146">    pp = &amp;bad_char_idx;</a>
<a name="ln4147">  }</a>
<a name="ln4148"> </a>
<a name="ln4149">  if (pp == NULL || *arg != '=') {</a>
<a name="ln4150">    return FAIL;</a>
<a name="ln4151">  }</a>
<a name="ln4152"> </a>
<a name="ln4153">  arg++;</a>
<a name="ln4154">  *pp = (int)(arg - eap-&gt;cmd);</a>
<a name="ln4155">  arg = skip_cmd_arg(arg, false);</a>
<a name="ln4156">  eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4157">  *arg = NUL;</a>
<a name="ln4158"> </a>
<a name="ln4159">  if (pp == &amp;eap-&gt;force_ff) {</a>
<a name="ln4160">    if (check_ff_value(eap-&gt;cmd + eap-&gt;force_ff) == FAIL) {</a>
<a name="ln4161">      return FAIL;</a>
<a name="ln4162">    }</a>
<a name="ln4163">    eap-&gt;force_ff = (uint8_t)eap-&gt;cmd[eap-&gt;force_ff];</a>
<a name="ln4164">  } else if (pp == &amp;eap-&gt;force_enc) {</a>
<a name="ln4165">    // Make 'fileencoding' lower case.</a>
<a name="ln4166">    for (char *p = eap-&gt;cmd + eap-&gt;force_enc; *p != NUL; p++) {</a>
<a name="ln4167">      *p = (char)TOLOWER_ASC(*p);</a>
<a name="ln4168">    }</a>
<a name="ln4169">  } else {</a>
<a name="ln4170">    // Check ++bad= argument.  Must be a single-byte character, &quot;keep&quot; or</a>
<a name="ln4171">    // &quot;drop&quot;.</a>
<a name="ln4172">    if (get_bad_opt(eap-&gt;cmd + bad_char_idx, eap) == FAIL) {</a>
<a name="ln4173">      return FAIL;</a>
<a name="ln4174">    }</a>
<a name="ln4175">  }</a>
<a name="ln4176"> </a>
<a name="ln4177">  return OK;</a>
<a name="ln4178">}</a>
<a name="ln4179"> </a>
<a name="ln4180">/// Handle the argument for a tabpage related ex command.</a>
<a name="ln4181">/// When an error is encountered then eap-&gt;errmsg is set.</a>
<a name="ln4182">///</a>
<a name="ln4183">/// @return  a tabpage number.</a>
<a name="ln4184">static int get_tabpage_arg(exarg_T *eap)</a>
<a name="ln4185">{</a>
<a name="ln4186">  int tab_number = 0;</a>
<a name="ln4187">  int unaccept_arg0 = (eap-&gt;cmdidx == CMD_tabmove) ? 0 : 1;</a>
<a name="ln4188"> </a>
<a name="ln4189">  if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln4190">    char *p = eap-&gt;arg;</a>
<a name="ln4191">    int relative = 0;  // argument +N/-N means: go to N places to the</a>
<a name="ln4192">                       // right/left relative to the current position.</a>
<a name="ln4193"> </a>
<a name="ln4194">    if (*p == '-') {</a>
<a name="ln4195">      relative = -1;</a>
<a name="ln4196">      p++;</a>
<a name="ln4197">    } else if (*p == '+') {</a>
<a name="ln4198">      relative = 1;</a>
<a name="ln4199">      p++;</a>
<a name="ln4200">    }</a>
<a name="ln4201"> </a>
<a name="ln4202">    char *p_save = p;</a>
<a name="ln4203">    tab_number = (int)getdigits(&amp;p, false, tab_number);</a>
<a name="ln4204"> </a>
<a name="ln4205">    if (relative == 0) {</a>
<a name="ln4206">      if (strcmp(p, &quot;$&quot;) == 0) {</a>
<a name="ln4207">        tab_number = LAST_TAB_NR;</a>
<a name="ln4208">      } else if (strcmp(p, &quot;#&quot;) == 0) {</a>
<a name="ln4209">        if (valid_tabpage(lastused_tabpage)) {</a>
<a name="ln4210">          tab_number = tabpage_index(lastused_tabpage);</a>
<a name="ln4211">        } else {</a>
<a name="ln4212">          eap-&gt;errmsg = ex_errmsg(e_invargval, eap-&gt;arg);</a>
<a name="ln4213">          tab_number = 0;</a>
<a name="ln4214">          goto theend;</a>
<a name="ln4215">        }</a>
<a name="ln4216">      } else if (p == p_save || *p_save == '-' || *p != NUL</a>
<a name="ln4217">                 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4218">        // No numbers as argument.</a>
<a name="ln4219">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4220">        goto theend;</a>
<a name="ln4221">      }</a>
<a name="ln4222">    } else {</a>
<a name="ln4223">      if (*p_save == NUL) {</a>
<a name="ln4224">        tab_number = 1;</a>
<a name="ln4225">      } else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {</a>
<a name="ln4226">        // No numbers as argument.</a>
<a name="ln4227">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4228">        goto theend;</a>
<a name="ln4229">      }</a>
<a name="ln4230">      tab_number = tab_number * relative + tabpage_index(curtab);</a>
<a name="ln4231">      if (!unaccept_arg0 &amp;&amp; relative == -1) {</a>
<a name="ln4232">        tab_number--;</a>
<a name="ln4233">      }</a>
<a name="ln4234">    }</a>
<a name="ln4235">    if (tab_number &lt; unaccept_arg0 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4236">      eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4237">    }</a>
<a name="ln4238">  } else if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4239">    if (unaccept_arg0 &amp;&amp; eap-&gt;line2 == 0) {</a>
<a name="ln4240">      eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4241">      tab_number = 0;</a>
<a name="ln4242">    } else {</a>
<a name="ln4243">      tab_number = (int)eap-&gt;line2;</a>
<a name="ln4244">      char *cmdp = eap-&gt;cmd;</a>
<a name="ln4245">      while (--cmdp &gt; *eap-&gt;cmdlinep &amp;&amp; (*cmdp == ' ' || ascii_isdigit(*cmdp))) {}</a>
<a name="ln4246">      if (!unaccept_arg0 &amp;&amp; *cmdp == '-') {</a>
<a name="ln4247">        tab_number--;</a>
<a name="ln4248">        if (tab_number &lt; unaccept_arg0) {</a>
<a name="ln4249">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4250">        }</a>
<a name="ln4251">      }</a>
<a name="ln4252">    }</a>
<a name="ln4253">  } else {</a>
<a name="ln4254">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4255">    case CMD_tabnext:</a>
<a name="ln4256">      tab_number = tabpage_index(curtab) + 1;</a>
<a name="ln4257">      if (tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4258">        tab_number = 1;</a>
<a name="ln4259">      }</a>
<a name="ln4260">      break;</a>
<a name="ln4261">    case CMD_tabmove:</a>
<a name="ln4262">      tab_number = LAST_TAB_NR;</a>
<a name="ln4263">      break;</a>
<a name="ln4264">    default:</a>
<a name="ln4265">      tab_number = tabpage_index(curtab);</a>
<a name="ln4266">    }</a>
<a name="ln4267">  }</a>
<a name="ln4268"> </a>
<a name="ln4269">theend:</a>
<a name="ln4270">  return tab_number;</a>
<a name="ln4271">}</a>
<a name="ln4272"> </a>
<a name="ln4273">static void ex_autocmd(exarg_T *eap)</a>
<a name="ln4274">{</a>
<a name="ln4275">  // Disallow autocommands in secure mode.</a>
<a name="ln4276">  if (secure) {</a>
<a name="ln4277">    secure = 2;</a>
<a name="ln4278">    eap-&gt;errmsg = _(e_curdir);</a>
<a name="ln4279">  } else if (eap-&gt;cmdidx == CMD_autocmd) {</a>
<a name="ln4280">    do_autocmd(eap, eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4281">  } else {</a>
<a name="ln4282">    do_augroup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4283">  }</a>
<a name="ln4284">}</a>
<a name="ln4285"> </a>
<a name="ln4286">/// &quot;:doautocmd&quot;: Apply the automatic commands to the current buffer.</a>
<a name="ln4287">static void ex_doautocmd(exarg_T *eap)</a>
<a name="ln4288">{</a>
<a name="ln4289">  char *arg = eap-&gt;arg;</a>
<a name="ln4290">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln4291">  bool did_aucmd;</a>
<a name="ln4292"> </a>
<a name="ln4293">  (void)do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln4294">  // Only when there is no &lt;nomodeline&gt;.</a>
<a name="ln4295">  if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln4296">    do_modelines(0);</a>
<a name="ln4297">  }</a>
<a name="ln4298">}</a>
<a name="ln4299"> </a>
<a name="ln4300">/// :[N]bunload[!] [N] [bufname] unload buffer</a>
<a name="ln4301">/// :[N]bdelete[!] [N] [bufname] delete buffer from buffer list</a>
<a name="ln4302">/// :[N]bwipeout[!] [N] [bufname] delete buffer really</a>
<a name="ln4303">static void ex_bunload(exarg_T *eap)</a>
<a name="ln4304">{</a>
<a name="ln4305">  eap-&gt;errmsg = do_bufdel(eap-&gt;cmdidx == CMD_bdelete</a>
<a name="ln4306">                          ? DOBUF_DEL</a>
<a name="ln4307">                          : eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln4308">                          ? DOBUF_WIPE</a>
<a name="ln4309">                          : DOBUF_UNLOAD,</a>
<a name="ln4310">                          eap-&gt;arg, eap-&gt;addr_count, (int)eap-&gt;line1, (int)eap-&gt;line2,</a>
<a name="ln4311">                          eap-&gt;forceit);</a>
<a name="ln4312">}</a>
<a name="ln4313"> </a>
<a name="ln4314">/// :[N]buffer [N]       to buffer N</a>
<a name="ln4315">/// :[N]sbuffer [N]      to buffer N</a>
<a name="ln4316">static void ex_buffer(exarg_T *eap)</a>
<a name="ln4317">{</a>
<a name="ln4318">  if (*eap-&gt;arg) {</a>
<a name="ln4319">    eap-&gt;errmsg = ex_errmsg(e_trailing_arg, eap-&gt;arg);</a>
<a name="ln4320">  } else {</a>
<a name="ln4321">    if (eap-&gt;addr_count == 0) {  // default is current buffer</a>
<a name="ln4322">      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);</a>
<a name="ln4323">    } else {</a>
<a name="ln4324">      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4325">    }</a>
<a name="ln4326">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4327">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4328">    }</a>
<a name="ln4329">  }</a>
<a name="ln4330">}</a>
<a name="ln4331"> </a>
<a name="ln4332">/// :[N]bmodified [N]    to next mod. buffer</a>
<a name="ln4333">/// :[N]sbmodified [N]   to next mod. buffer</a>
<a name="ln4334">static void ex_bmodified(exarg_T *eap)</a>
<a name="ln4335">{</a>
<a name="ln4336">  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4337">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4338">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4339">  }</a>
<a name="ln4340">}</a>
<a name="ln4341"> </a>
<a name="ln4342">/// :[N]bnext [N]        to next buffer</a>
<a name="ln4343">/// :[N]sbnext [N]       split and to next buffer</a>
<a name="ln4344">static void ex_bnext(exarg_T *eap)</a>
<a name="ln4345">{</a>
<a name="ln4346">  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4347">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4348">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4349">  }</a>
<a name="ln4350">}</a>
<a name="ln4351"> </a>
<a name="ln4352">/// :[N]bNext [N]        to previous buffer</a>
<a name="ln4353">/// :[N]bprevious [N]    to previous buffer</a>
<a name="ln4354">/// :[N]sbNext [N]       split and to previous buffer</a>
<a name="ln4355">/// :[N]sbprevious [N]   split and to previous buffer</a>
<a name="ln4356">static void ex_bprevious(exarg_T *eap)</a>
<a name="ln4357">{</a>
<a name="ln4358">  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap-&gt;line2);</a>
<a name="ln4359">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4360">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4361">  }</a>
<a name="ln4362">}</a>
<a name="ln4363"> </a>
<a name="ln4364">/// :brewind             to first buffer</a>
<a name="ln4365">/// :bfirst              to first buffer</a>
<a name="ln4366">/// :sbrewind            split and to first buffer</a>
<a name="ln4367">/// :sbfirst             split and to first buffer</a>
<a name="ln4368">static void ex_brewind(exarg_T *eap)</a>
<a name="ln4369">{</a>
<a name="ln4370">  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);</a>
<a name="ln4371">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4372">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4373">  }</a>
<a name="ln4374">}</a>
<a name="ln4375"> </a>
<a name="ln4376">/// :blast               to last buffer</a>
<a name="ln4377">/// :sblast              split and to last buffer</a>
<a name="ln4378">static void ex_blast(exarg_T *eap)</a>
<a name="ln4379">{</a>
<a name="ln4380">  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);</a>
<a name="ln4381">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4382">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4383">  }</a>
<a name="ln4384">}</a>
<a name="ln4385"> </a>
<a name="ln4386">int ends_excmd(int c) FUNC_ATTR_CONST</a>
<a name="ln4387">{</a>
<a name="ln4388">  return c == NUL || c == '|' || c == '&quot;' || c == '\n';</a>
<a name="ln4389">}</a>
<a name="ln4390"> </a>
<a name="ln4391">/// @return  the next command, after the first '|' or '\n' or,</a>
<a name="ln4392">///          NULL if not found.</a>
<a name="ln4393">char *find_nextcmd(const char *p)</a>
<a name="ln4394">{</a>
<a name="ln4395">  while (*p != '|' &amp;&amp; *p != '\n') {</a>
<a name="ln4396">    if (*p == NUL) {</a>
<a name="ln4397">      return NULL;</a>
<a name="ln4398">    }</a>
<a name="ln4399">    p++;</a>
<a name="ln4400">  }</a>
<a name="ln4401">  return (char *)p + 1;</a>
<a name="ln4402">}</a>
<a name="ln4403"> </a>
<a name="ln4404">/// Check if *p is a separator between Ex commands, skipping over white space.</a>
<a name="ln4405">///</a>
<a name="ln4406">/// @return  NULL if it isn't, the following character if it is.</a>
<a name="ln4407">char *check_nextcmd(char *p)</a>
<a name="ln4408">{</a>
<a name="ln4409">  char *s = skipwhite(p);</a>
<a name="ln4410"> </a>
<a name="ln4411">  if (*s == '|' || *s == '\n') {</a>
<a name="ln4412">    return s + 1;</a>
<a name="ln4413">  }</a>
<a name="ln4414">  return NULL;</a>
<a name="ln4415">}</a>
<a name="ln4416"> </a>
<a name="ln4417">/// - if there are more files to edit</a>
<a name="ln4418">/// - and this is the last window</a>
<a name="ln4419">/// - and forceit not used</a>
<a name="ln4420">/// - and not repeated twice on a row</a>
<a name="ln4421">///</a>
<a name="ln4422">/// @param   message  when false check only, no messages</a>
<a name="ln4423">///</a>
<a name="ln4424">/// @return  FAIL and give error message if 'message' true, return OK otherwise</a>
<a name="ln4425">static int check_more(int message, bool forceit)</a>
<a name="ln4426">{</a>
<a name="ln4427">  int n = ARGCOUNT - curwin-&gt;w_arg_idx - 1;</a>
<a name="ln4428"> </a>
<a name="ln4429">  if (!forceit &amp;&amp; only_one_window()</a>
<a name="ln4430">      &amp;&amp; ARGCOUNT &gt; 1 &amp;&amp; !arg_had_last &amp;&amp; n &gt; 0 &amp;&amp; quitmore == 0) {</a>
<a name="ln4431">    if (message) {</a>
<a name="ln4432">      if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln4433">        char buff[DIALOG_MSG_SIZE];</a>
<a name="ln4434"> </a>
<a name="ln4435">        vim_snprintf(buff, DIALOG_MSG_SIZE,</a>
<a name="ln4436">                     NGETTEXT(&quot;%d more file to edit.  Quit anyway?&quot;,</a>
<a name="ln4437">                              &quot;%d more files to edit.  Quit anyway?&quot;, n), n);</a>
<a name="ln4438">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES) {</a>
<a name="ln4439">          return OK;</a>
<a name="ln4440">        }</a>
<a name="ln4441">        return FAIL;</a>
<a name="ln4442">      }</a>
<a name="ln4443">      semsg(NGETTEXT(&quot;E173: %&quot; PRId64 &quot; more file to edit&quot;,</a>
<a name="ln4444">                     &quot;E173: %&quot; PRId64 &quot; more files to edit&quot;, n), (int64_t)n);</a>
<a name="ln4445">      quitmore = 2;                 // next try to quit is allowed</a>
<a name="ln4446">    }</a>
<a name="ln4447">    return FAIL;</a>
<a name="ln4448">  }</a>
<a name="ln4449">  return OK;</a>
<a name="ln4450">}</a>
<a name="ln4451"> </a>
<a name="ln4452">/// Function given to ExpandGeneric() to obtain the list of command names.</a>
<a name="ln4453">char *get_command_name(expand_T *xp, int idx)</a>
<a name="ln4454">{</a>
<a name="ln4455">  if (idx &gt;= CMD_SIZE) {</a>
<a name="ln4456">    return expand_user_command_name(idx);</a>
<a name="ln4457">  }</a>
<a name="ln4458">  return cmdnames[idx].cmd_name;</a>
<a name="ln4459">}</a>
<a name="ln4460"> </a>
<a name="ln4461">static void ex_colorscheme(exarg_T *eap)</a>
<a name="ln4462">{</a>
<a name="ln4463">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln4464">    char *expr = xstrdup(&quot;g:colors_name&quot;);</a>
<a name="ln4465"> </a>
<a name="ln4466">    emsg_off++;</a>
<a name="ln4467">    char *p = eval_to_string(expr, false);</a>
<a name="ln4468">    emsg_off--;</a>
<a name="ln4469">    xfree(expr);</a>
<a name="ln4470"> </a>
<a name="ln4471">    if (p != NULL) {</a>
<a name="ln4472">      msg(p, 0);</a>
<a name="ln4473">      xfree(p);</a>
<a name="ln4474">    } else {</a>
<a name="ln4475">      msg(&quot;default&quot;, 0);</a>
<a name="ln4476">    }</a>
<a name="ln4477">  } else if (load_colors(eap-&gt;arg) == FAIL) {</a>
<a name="ln4478">    semsg(_(&quot;E185: Cannot find color scheme '%s'&quot;), eap-&gt;arg);</a>
<a name="ln4479">  }</a>
<a name="ln4480">}</a>
<a name="ln4481"> </a>
<a name="ln4482">static void ex_highlight(exarg_T *eap)</a>
<a name="ln4483">{</a>
<a name="ln4484">  if (*eap-&gt;arg == NUL &amp;&amp; eap-&gt;cmd[2] == '!') {</a>
<a name="ln4485">    msg(_(&quot;Greetings, Vim user!&quot;), 0);</a>
<a name="ln4486">  }</a>
<a name="ln4487">  do_highlight(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln4488">}</a>
<a name="ln4489"> </a>
<a name="ln4490">/// Call this function if we thought we were going to exit, but we won't</a>
<a name="ln4491">/// (because of an error).  May need to restore the terminal mode.</a>
<a name="ln4492">void not_exiting(void)</a>
<a name="ln4493">{</a>
<a name="ln4494">  exiting = false;</a>
<a name="ln4495">}</a>
<a name="ln4496"> </a>
<a name="ln4497">bool before_quit_autocmds(win_T *wp, bool quit_all, bool forceit)</a>
<a name="ln4498">{</a>
<a name="ln4499">  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp-&gt;w_buffer);</a>
<a name="ln4500"> </a>
<a name="ln4501">  // Bail out when autocommands closed the window.</a>
<a name="ln4502">  // Refuse to quit when the buffer in the last window is being closed (can</a>
<a name="ln4503">  // only happen in autocommands).</a>
<a name="ln4504">  if (!win_valid(wp)</a>
<a name="ln4505">      || curbuf_locked()</a>
<a name="ln4506">      || (wp-&gt;w_buffer-&gt;b_nwindows == 1 &amp;&amp; wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln4507">    return true;</a>
<a name="ln4508">  }</a>
<a name="ln4509"> </a>
<a name="ln4510">  if (quit_all</a>
<a name="ln4511">      || (check_more(false, forceit) == OK &amp;&amp; only_one_window())) {</a>
<a name="ln4512">    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);</a>
<a name="ln4513">    // Refuse to quit when locked or when the window was closed or the</a>
<a name="ln4514">    // buffer in the last window is being closed (can only happen in</a>
<a name="ln4515">    // autocommands).</a>
<a name="ln4516">    if (!win_valid(wp)</a>
<a name="ln4517">        || curbuf_locked()</a>
<a name="ln4518">        || (curbuf-&gt;b_nwindows == 1 &amp;&amp; curbuf-&gt;b_locked &gt; 0)) {</a>
<a name="ln4519">      return true;</a>
<a name="ln4520">    }</a>
<a name="ln4521">  }</a>
<a name="ln4522"> </a>
<a name="ln4523">  return false;</a>
<a name="ln4524">}</a>
<a name="ln4525"> </a>
<a name="ln4526">/// &quot;:quit&quot;: quit current window, quit Vim if the last window is closed.</a>
<a name="ln4527">/// &quot;:{nr}quit&quot;: quit window {nr}</a>
<a name="ln4528">static void ex_quit(exarg_T *eap)</a>
<a name="ln4529">{</a>
<a name="ln4530">  if (cmdwin_type != 0) {</a>
<a name="ln4531">    cmdwin_result = Ctrl_C;</a>
<a name="ln4532">    return;</a>
<a name="ln4533">  }</a>
<a name="ln4534">  // Don't quit while editing the command line.</a>
<a name="ln4535">  if (text_locked()) {</a>
<a name="ln4536">    text_locked_msg();</a>
<a name="ln4537">    return;</a>
<a name="ln4538">  }</a>
<a name="ln4539"> </a>
<a name="ln4540">  win_T *wp;</a>
<a name="ln4541"> </a>
<a name="ln4542">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4543">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4544"> </a>
<a name="ln4545">    for (wp = firstwin; wp-&gt;w_next != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln4546">      if (--wnr &lt;= 0) {</a>
<a name="ln4547">        break;</a>
<a name="ln4548">      }</a>
<a name="ln4549">    }</a>
<a name="ln4550">  } else {</a>
<a name="ln4551">    wp = curwin;</a>
<a name="ln4552">  }</a>
<a name="ln4553"> </a>
<a name="ln4554">  // Refuse to quit when locked.</a>
<a name="ln4555">  if (curbuf_locked()) {</a>
<a name="ln4556">    return;</a>
<a name="ln4557">  }</a>
<a name="ln4558"> </a>
<a name="ln4559">  // Trigger QuitPre and maybe ExitPre</a>
<a name="ln4560">  if (before_quit_autocmds(wp, false, eap-&gt;forceit)) {</a>
<a name="ln4561">    return;</a>
<a name="ln4562">  }</a>
<a name="ln4563"> </a>
<a name="ln4564">  // If there is only one relevant window we will exit.</a>
<a name="ln4565">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4566">    exiting = true;</a>
<a name="ln4567">  }</a>
<a name="ln4568">  if ((!buf_hide(wp-&gt;w_buffer)</a>
<a name="ln4569">       &amp;&amp; check_changed(wp-&gt;w_buffer, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4570">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4571">                        | CCGD_EXCMD))</a>
<a name="ln4572">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4573">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, true))) {</a>
<a name="ln4574">    not_exiting();</a>
<a name="ln4575">  } else {</a>
<a name="ln4576">    // quit last window</a>
<a name="ln4577">    // Note: only_one_window() returns true, even so a help window is</a>
<a name="ln4578">    // still open. In that case only quit, if no address has been</a>
<a name="ln4579">    // specified. Example:</a>
<a name="ln4580">    // :h|wincmd w|1q     - don't quit</a>
<a name="ln4581">    // :h|wincmd w|q      - quit</a>
<a name="ln4582">    if (only_one_window() &amp;&amp; (ONE_WINDOW || eap-&gt;addr_count == 0)) {</a>
<a name="ln4583">      getout(0);</a>
<a name="ln4584">    }</a>
<a name="ln4585">    not_exiting();</a>
<a name="ln4586">    // close window; may free buffer</a>
<a name="ln4587">    win_close(wp, !buf_hide(wp-&gt;w_buffer) || eap-&gt;forceit, eap-&gt;forceit);</a>
<a name="ln4588">  }</a>
<a name="ln4589">}</a>
<a name="ln4590"> </a>
<a name="ln4591">/// &quot;:cquit&quot;.</a>
<a name="ln4592">static void ex_cquit(exarg_T *eap)</a>
<a name="ln4593">  FUNC_ATTR_NORETURN</a>
<a name="ln4594">{</a>
<a name="ln4595">  // this does not always pass on the exit code to the Manx compiler. why?</a>
<a name="ln4596">  int status = eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : EXIT_FAILURE;</a>
<a name="ln4597">  ui_call_error_exit(status);</a>
<a name="ln4598">  getout(status);</a>
<a name="ln4599">}</a>
<a name="ln4600"> </a>
<a name="ln4601">/// Do preparations for &quot;qall&quot; and &quot;wqall&quot;.</a>
<a name="ln4602">/// Returns FAIL when quitting should be aborted.</a>
<a name="ln4603">int before_quit_all(exarg_T *eap)</a>
<a name="ln4604">{</a>
<a name="ln4605">  if (cmdwin_type != 0) {</a>
<a name="ln4606">    if (eap-&gt;forceit) {</a>
<a name="ln4607">      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this</a>
<a name="ln4608">    } else {</a>
<a name="ln4609">      cmdwin_result = K_XF2;</a>
<a name="ln4610">    }</a>
<a name="ln4611">    return FAIL;</a>
<a name="ln4612">  }</a>
<a name="ln4613"> </a>
<a name="ln4614">  // Don't quit while editing the command line.</a>
<a name="ln4615">  if (text_locked()) {</a>
<a name="ln4616">    text_locked_msg();</a>
<a name="ln4617">    return FAIL;</a>
<a name="ln4618">  }</a>
<a name="ln4619"> </a>
<a name="ln4620">  if (before_quit_autocmds(curwin, true, eap-&gt;forceit)) {</a>
<a name="ln4621">    return FAIL;</a>
<a name="ln4622">  }</a>
<a name="ln4623"> </a>
<a name="ln4624">  return OK;</a>
<a name="ln4625">}</a>
<a name="ln4626"> </a>
<a name="ln4627">/// &quot;:qall&quot;: try to quit all windows</a>
<a name="ln4628">static void ex_quit_all(exarg_T *eap)</a>
<a name="ln4629">{</a>
<a name="ln4630">  if (before_quit_all(eap) == FAIL) {</a>
<a name="ln4631">    return;</a>
<a name="ln4632">  }</a>
<a name="ln4633">  exiting = true;</a>
<a name="ln4634">  if (eap-&gt;forceit || !check_changed_any(false, false)) {</a>
<a name="ln4635">    getout(0);</a>
<a name="ln4636">  }</a>
<a name="ln4637">  not_exiting();</a>
<a name="ln4638">}</a>
<a name="ln4639"> </a>
<a name="ln4640">/// &quot;:close&quot;: close current window, unless it is the last one</a>
<a name="ln4641">static void ex_close(exarg_T *eap)</a>
<a name="ln4642">{</a>
<a name="ln4643">  win_T *win = NULL;</a>
<a name="ln4644">  int winnr = 0;</a>
<a name="ln4645">  if (cmdwin_type != 0) {</a>
<a name="ln4646">    cmdwin_result = Ctrl_C;</a>
<a name="ln4647">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4648">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln4649">      ex_win_close(eap-&gt;forceit, curwin, NULL);</a>
<a name="ln4650">    } else {</a>
<a name="ln4651">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4652">        winnr++;</a>
<a name="ln4653">        if (winnr == eap-&gt;line2) {</a>
<a name="ln4654">          win = wp;</a>
<a name="ln4655">          break;</a>
<a name="ln4656">        }</a>
<a name="ln4657">      }</a>
<a name="ln4658">      if (win == NULL) {</a>
<a name="ln4659">        win = lastwin;</a>
<a name="ln4660">      }</a>
<a name="ln4661">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4662">    }</a>
<a name="ln4663">  }</a>
<a name="ln4664">}</a>
<a name="ln4665"> </a>
<a name="ln4666">/// &quot;:pclose&quot;: Close any preview window.</a>
<a name="ln4667">static void ex_pclose(exarg_T *eap)</a>
<a name="ln4668">{</a>
<a name="ln4669">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln4670">    if (win-&gt;w_p_pvw) {</a>
<a name="ln4671">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4672">      break;</a>
<a name="ln4673">    }</a>
<a name="ln4674">  }</a>
<a name="ln4675">}</a>
<a name="ln4676"> </a>
<a name="ln4677">/// Close window &quot;win&quot; and take care of handling closing the last window for a</a>
<a name="ln4678">/// modified buffer.</a>
<a name="ln4679">///</a>
<a name="ln4680">/// @param tp  NULL or the tab page &quot;win&quot; is in</a>
<a name="ln4681">void ex_win_close(int forceit, win_T *win, tabpage_T *tp)</a>
<a name="ln4682">{</a>
<a name="ln4683">  // Never close the autocommand window.</a>
<a name="ln4684">  if (is_aucmd_win(win)) {</a>
<a name="ln4685">    emsg(_(e_autocmd_close));</a>
<a name="ln4686">    return;</a>
<a name="ln4687">  }</a>
<a name="ln4688"> </a>
<a name="ln4689">  buf_T *buf = win-&gt;w_buffer;</a>
<a name="ln4690"> </a>
<a name="ln4691">  bool need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln4692">  if (need_hide &amp;&amp; !buf_hide(buf) &amp;&amp; !forceit) {</a>
<a name="ln4693">    if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; p_write) {</a>
<a name="ln4694">      bufref_T bufref;</a>
<a name="ln4695">      set_bufref(&amp;bufref, buf);</a>
<a name="ln4696">      dialog_changed(buf, false);</a>
<a name="ln4697">      if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln4698">        return;</a>
<a name="ln4699">      }</a>
<a name="ln4700">      need_hide = false;</a>
<a name="ln4701">    } else {</a>
<a name="ln4702">      no_write_message();</a>
<a name="ln4703">      return;</a>
<a name="ln4704">    }</a>
<a name="ln4705">  }</a>
<a name="ln4706"> </a>
<a name="ln4707">  // free buffer when not hiding it or when it's a scratch buffer</a>
<a name="ln4708">  if (tp == NULL) {</a>
<a name="ln4709">    win_close(win, !need_hide &amp;&amp; !buf_hide(buf), forceit);</a>
<a name="ln4710">  } else {</a>
<a name="ln4711">    win_close_othertab(win, !need_hide &amp;&amp; !buf_hide(buf), tp);</a>
<a name="ln4712">  }</a>
<a name="ln4713">}</a>
<a name="ln4714"> </a>
<a name="ln4715">/// &quot;:tabclose&quot;: close current tab page, unless it is the last one.</a>
<a name="ln4716">/// &quot;:tabclose N&quot;: close tab page N.</a>
<a name="ln4717">static void ex_tabclose(exarg_T *eap)</a>
<a name="ln4718">{</a>
<a name="ln4719">  if (cmdwin_type != 0) {</a>
<a name="ln4720">    cmdwin_result = K_IGNORE;</a>
<a name="ln4721">    return;</a>
<a name="ln4722">  }</a>
<a name="ln4723"> </a>
<a name="ln4724">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4725">    emsg(_(&quot;E784: Cannot close last tab page&quot;));</a>
<a name="ln4726">    return;</a>
<a name="ln4727">  }</a>
<a name="ln4728"> </a>
<a name="ln4729">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4730">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4731">    return;</a>
<a name="ln4732">  }</a>
<a name="ln4733"> </a>
<a name="ln4734">  tabpage_T *tp = find_tabpage(tab_number);</a>
<a name="ln4735">  if (tp == NULL) {</a>
<a name="ln4736">    beep_flush();</a>
<a name="ln4737">    return;</a>
<a name="ln4738">  }</a>
<a name="ln4739">  if (tp != curtab) {</a>
<a name="ln4740">    tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4741">    return;</a>
<a name="ln4742">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4743">    tabpage_close(eap-&gt;forceit);</a>
<a name="ln4744">  }</a>
<a name="ln4745">}</a>
<a name="ln4746"> </a>
<a name="ln4747">/// &quot;:tabonly&quot;: close all tab pages except the current one</a>
<a name="ln4748">static void ex_tabonly(exarg_T *eap)</a>
<a name="ln4749">{</a>
<a name="ln4750">  if (cmdwin_type != 0) {</a>
<a name="ln4751">    cmdwin_result = K_IGNORE;</a>
<a name="ln4752">    return;</a>
<a name="ln4753">  }</a>
<a name="ln4754"> </a>
<a name="ln4755">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4756">    msg(_(&quot;Already only one tab page&quot;), 0);</a>
<a name="ln4757">    return;</a>
<a name="ln4758">  }</a>
<a name="ln4759"> </a>
<a name="ln4760">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4761">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4762">    return;</a>
<a name="ln4763">  }</a>
<a name="ln4764"> </a>
<a name="ln4765">  goto_tabpage(tab_number);</a>
<a name="ln4766">  // Repeat this up to a 1000 times, because autocommands may</a>
<a name="ln4767">  // mess up the lists.</a>
<a name="ln4768">  for (int done = 0; done &lt; 1000; done++) {</a>
<a name="ln4769">    FOR_ALL_TABS(tp) {</a>
<a name="ln4770">      if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln4771">        tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4772">        // if we failed to close it quit</a>
<a name="ln4773">        if (valid_tabpage(tp)) {</a>
<a name="ln4774">          done = 1000;</a>
<a name="ln4775">        }</a>
<a name="ln4776">        // start over, &quot;tp&quot; is now invalid</a>
<a name="ln4777">        break;</a>
<a name="ln4778">      }</a>
<a name="ln4779">    }</a>
<a name="ln4780">    assert(first_tabpage);</a>
<a name="ln4781">    if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4782">      break;</a>
<a name="ln4783">    }</a>
<a name="ln4784">  }</a>
<a name="ln4785">}</a>
<a name="ln4786"> </a>
<a name="ln4787">/// Close the current tab page.</a>
<a name="ln4788">void tabpage_close(int forceit)</a>
<a name="ln4789">{</a>
<a name="ln4790">  // First close all the windows but the current one.  If that worked then</a>
<a name="ln4791">  // close the last window in this tab, that will close it.</a>
<a name="ln4792">  while (curwin-&gt;w_floating) {</a>
<a name="ln4793">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4794">  }</a>
<a name="ln4795">  if (!ONE_WINDOW) {</a>
<a name="ln4796">    close_others(true, forceit);</a>
<a name="ln4797">  }</a>
<a name="ln4798">  if (ONE_WINDOW) {</a>
<a name="ln4799">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4800">  }</a>
<a name="ln4801">}</a>
<a name="ln4802"> </a>
<a name="ln4803">/// Close tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln4804">/// Note that autocommands may make &quot;tp&quot; invalid.</a>
<a name="ln4805">/// Also takes care of the tab pages line disappearing when closing the</a>
<a name="ln4806">/// last-but-one tab page.</a>
<a name="ln4807">void tabpage_close_other(tabpage_T *tp, int forceit)</a>
<a name="ln4808">{</a>
<a name="ln4809">  int done = 0;</a>
<a name="ln4810">  char prev_idx[NUMBUFLEN];</a>
<a name="ln4811"> </a>
<a name="ln4812">  // Limit to 1000 windows, autocommands may add a window while we close</a>
<a name="ln4813">  // one.  OK, so I'm paranoid...</a>
<a name="ln4814">  while (++done &lt; 1000) {</a>
<a name="ln4815">    snprintf(prev_idx, sizeof(prev_idx), &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln4816">    win_T *wp = tp-&gt;tp_lastwin;</a>
<a name="ln4817">    ex_win_close(forceit, wp, tp);</a>
<a name="ln4818"> </a>
<a name="ln4819">    // Autocommands may delete the tab page under our fingers and we may</a>
<a name="ln4820">    // fail to close a window with a modified buffer.</a>
<a name="ln4821">    if (!valid_tabpage(tp) || tp-&gt;tp_lastwin == wp) {</a>
<a name="ln4822">      break;</a>
<a name="ln4823">    }</a>
<a name="ln4824">  }</a>
<a name="ln4825">}</a>
<a name="ln4826"> </a>
<a name="ln4827">/// &quot;:only&quot;.</a>
<a name="ln4828">static void ex_only(exarg_T *eap)</a>
<a name="ln4829">{</a>
<a name="ln4830">  win_T *wp;</a>
<a name="ln4831"> </a>
<a name="ln4832">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4833">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4834">    for (wp = firstwin; --wnr &gt; 0;) {</a>
<a name="ln4835">      if (wp-&gt;w_next == NULL) {</a>
<a name="ln4836">        break;</a>
<a name="ln4837">      }</a>
<a name="ln4838">      wp = wp-&gt;w_next;</a>
<a name="ln4839">    }</a>
<a name="ln4840">  } else {</a>
<a name="ln4841">    wp = curwin;</a>
<a name="ln4842">  }</a>
<a name="ln4843">  if (wp != curwin) {</a>
<a name="ln4844">    win_goto(wp);</a>
<a name="ln4845">  }</a>
<a name="ln4846">  close_others(true, eap-&gt;forceit);</a>
<a name="ln4847">}</a>
<a name="ln4848"> </a>
<a name="ln4849">static void ex_hide(exarg_T *eap)</a>
<a name="ln4850">{</a>
<a name="ln4851">  // &quot;:hide&quot; or &quot;:hide | cmd&quot;: hide current window</a>
<a name="ln4852">  if (eap-&gt;skip) {</a>
<a name="ln4853">    return;</a>
<a name="ln4854">  }</a>
<a name="ln4855"> </a>
<a name="ln4856">  if (eap-&gt;addr_count == 0) {</a>
<a name="ln4857">    win_close(curwin, false, eap-&gt;forceit);  // don't free buffer</a>
<a name="ln4858">  } else {</a>
<a name="ln4859">    int winnr = 0;</a>
<a name="ln4860">    win_T *win = NULL;</a>
<a name="ln4861"> </a>
<a name="ln4862">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4863">      winnr++;</a>
<a name="ln4864">      if (winnr == eap-&gt;line2) {</a>
<a name="ln4865">        win = wp;</a>
<a name="ln4866">        break;</a>
<a name="ln4867">      }</a>
<a name="ln4868">    }</a>
<a name="ln4869">    if (win == NULL) {</a>
<a name="ln4870">      win = lastwin;</a>
<a name="ln4871">    }</a>
<a name="ln4872">    win_close(win, false, eap-&gt;forceit);</a>
<a name="ln4873">  }</a>
<a name="ln4874">}</a>
<a name="ln4875"> </a>
<a name="ln4876">/// &quot;:stop&quot; and &quot;:suspend&quot;: Suspend Vim.</a>
<a name="ln4877">static void ex_stop(exarg_T *eap)</a>
<a name="ln4878">{</a>
<a name="ln4879">  if (!eap-&gt;forceit) {</a>
<a name="ln4880">    autowrite_all();</a>
<a name="ln4881">  }</a>
<a name="ln4882">  may_trigger_vim_suspend_resume(true);</a>
<a name="ln4883">  ui_call_suspend();</a>
<a name="ln4884">  ui_flush();</a>
<a name="ln4885">}</a>
<a name="ln4886"> </a>
<a name="ln4887">/// &quot;:exit&quot;, &quot;:xit&quot; and &quot;:wq&quot;: Write file and quit the current window.</a>
<a name="ln4888">static void ex_exit(exarg_T *eap)</a>
<a name="ln4889">{</a>
<a name="ln4890">  if (cmdwin_type != 0) {</a>
<a name="ln4891">    cmdwin_result = Ctrl_C;</a>
<a name="ln4892">    return;</a>
<a name="ln4893">  }</a>
<a name="ln4894">  // Don't quit while editing the command line.</a>
<a name="ln4895">  if (text_locked()) {</a>
<a name="ln4896">    text_locked_msg();</a>
<a name="ln4897">    return;</a>
<a name="ln4898">  }</a>
<a name="ln4899"> </a>
<a name="ln4900">  // we plan to exit if there is only one relevant window</a>
<a name="ln4901">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4902">    exiting = true;</a>
<a name="ln4903">  }</a>
<a name="ln4904">  // Write the buffer for &quot;:wq&quot; or when it was changed.</a>
<a name="ln4905">  // Trigger QuitPre and ExitPre.</a>
<a name="ln4906">  // Check if we can exit now, after autocommands have changed things.</a>
<a name="ln4907">  if (((eap-&gt;cmdidx == CMD_wq || curbufIsChanged()) &amp;&amp; do_write(eap) == FAIL)</a>
<a name="ln4908">      || before_quit_autocmds(curwin, false, eap-&gt;forceit)</a>
<a name="ln4909">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4910">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, false))) {</a>
<a name="ln4911">    not_exiting();</a>
<a name="ln4912">  } else {</a>
<a name="ln4913">    if (only_one_window()) {</a>
<a name="ln4914">      // quit last window, exit Vim</a>
<a name="ln4915">      getout(0);</a>
<a name="ln4916">    }</a>
<a name="ln4917">    not_exiting();</a>
<a name="ln4918">    // Quit current window, may free the buffer.</a>
<a name="ln4919">    win_close(curwin, !buf_hide(curwin-&gt;w_buffer), eap-&gt;forceit);</a>
<a name="ln4920">  }</a>
<a name="ln4921">}</a>
<a name="ln4922"> </a>
<a name="ln4923">/// &quot;:print&quot;, &quot;:list&quot;, &quot;:number&quot;.</a>
<a name="ln4924">static void ex_print(exarg_T *eap)</a>
<a name="ln4925">{</a>
<a name="ln4926">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln4927">    emsg(_(e_empty_buffer));</a>
<a name="ln4928">  } else {</a>
<a name="ln4929">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln4930">      print_line(eap-&gt;line1,</a>
<a name="ln4931">                 (eap-&gt;cmdidx == CMD_number || eap-&gt;cmdidx == CMD_pound</a>
<a name="ln4932">                  || (eap-&gt;flags &amp; EXFLAG_NR)),</a>
<a name="ln4933">                 eap-&gt;cmdidx == CMD_list || (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln4934">      if (++eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln4935">        break;</a>
<a name="ln4936">      }</a>
<a name="ln4937">    }</a>
<a name="ln4938">    setpcmark();</a>
<a name="ln4939">    // put cursor at last line</a>
<a name="ln4940">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln4941">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln4942">  }</a>
<a name="ln4943"> </a>
<a name="ln4944">  ex_no_reprint = true;</a>
<a name="ln4945">}</a>
<a name="ln4946"> </a>
<a name="ln4947">static void ex_goto(exarg_T *eap)</a>
<a name="ln4948">{</a>
<a name="ln4949">  goto_byte(eap-&gt;line2);</a>
<a name="ln4950">}</a>
<a name="ln4951"> </a>
<a name="ln4952">/// &quot;:preserve&quot;.</a>
<a name="ln4953">static void ex_preserve(exarg_T *eap)</a>
<a name="ln4954">{</a>
<a name="ln4955">  ml_preserve(curbuf, true, true);</a>
<a name="ln4956">}</a>
<a name="ln4957"> </a>
<a name="ln4958">/// &quot;:recover&quot;.</a>
<a name="ln4959">static void ex_recover(exarg_T *eap)</a>
<a name="ln4960">{</a>
<a name="ln4961">  // Set recoverymode right away to avoid the ATTENTION prompt.</a>
<a name="ln4962">  recoverymode = true;</a>
<a name="ln4963">  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4964">                     | CCGD_MULTWIN</a>
<a name="ln4965">                     | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4966">                     | CCGD_EXCMD)</a>
<a name="ln4967"> </a>
<a name="ln4968">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln4969">          || setfname(curbuf, eap-&gt;arg, NULL, true) == OK)) {</a>
<a name="ln4970">    ml_recover(true);</a>
<a name="ln4971">  }</a>
<a name="ln4972">  recoverymode = false;</a>
<a name="ln4973">}</a>
<a name="ln4974"> </a>
<a name="ln4975">/// Command modifier used in a wrong way.</a>
<a name="ln4976">static void ex_wrongmodifier(exarg_T *eap)</a>
<a name="ln4977">{</a>
<a name="ln4978">  eap-&gt;errmsg = _(e_invcmd);</a>
<a name="ln4979">}</a>
<a name="ln4980"> </a>
<a name="ln4981">/// :sview [+command] file       split window with new file, read-only</a>
<a name="ln4982">/// :split [[+command] file]     split window with current or new file</a>
<a name="ln4983">/// :vsplit [[+command] file]    split window vertically with current or new file</a>
<a name="ln4984">/// :new [[+command] file]       split window with no or new file</a>
<a name="ln4985">/// :vnew [[+command] file]      split vertically window with no or new file</a>
<a name="ln4986">/// :sfind [+command] file       split window with file in 'path'</a>
<a name="ln4987">///</a>
<a name="ln4988">/// :tabedit                     open new Tab page with empty window</a>
<a name="ln4989">/// :tabedit [+command] file     open new Tab page and edit &quot;file&quot;</a>
<a name="ln4990">/// :tabnew [[+command] file]    just like :tabedit</a>
<a name="ln4991">/// :tabfind [+command] file     open new Tab page and find &quot;file&quot;</a>
<a name="ln4992">void ex_splitview(exarg_T *eap)</a>
<a name="ln4993">{</a>
<a name="ln4994">  win_T *old_curwin = curwin;</a>
<a name="ln4995">  char *fname = NULL;</a>
<a name="ln4996">  const bool use_tab = eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln4997">                       || eap-&gt;cmdidx == CMD_tabfind</a>
<a name="ln4998">                       || eap-&gt;cmdidx == CMD_tabnew;</a>
<a name="ln4999"> </a>
<a name="ln5000">  // A &quot;:split&quot; in the quickfix window works like &quot;:new&quot;.  Don't want two</a>
<a name="ln5001">  // quickfix windows.  But it's OK when doing &quot;:tab split&quot;.</a>
<a name="ln5002">  if (bt_quickfix(curbuf) &amp;&amp; cmdmod.cmod_tab == 0) {</a>
<a name="ln5003">    if (eap-&gt;cmdidx == CMD_split) {</a>
<a name="ln5004">      eap-&gt;cmdidx = CMD_new;</a>
<a name="ln5005">    }</a>
<a name="ln5006">    if (eap-&gt;cmdidx == CMD_vsplit) {</a>
<a name="ln5007">      eap-&gt;cmdidx = CMD_vnew;</a>
<a name="ln5008">    }</a>
<a name="ln5009">  }</a>
<a name="ln5010"> </a>
<a name="ln5011">  if (eap-&gt;cmdidx == CMD_sfind || eap-&gt;cmdidx == CMD_tabfind) {</a>
<a name="ln5012">    char *file_to_find = NULL;</a>
<a name="ln5013">    char *search_ctx = NULL;</a>
<a name="ln5014">    fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5015">                              FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5016">                              &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5017">    xfree(file_to_find);</a>
<a name="ln5018">    vim_findfile_cleanup(search_ctx);</a>
<a name="ln5019">    if (fname == NULL) {</a>
<a name="ln5020">      goto theend;</a>
<a name="ln5021">    }</a>
<a name="ln5022">    eap-&gt;arg = fname;</a>
<a name="ln5023">  }</a>
<a name="ln5024"> </a>
<a name="ln5025">  // Either open new tab page or split the window.</a>
<a name="ln5026">  if (use_tab) {</a>
<a name="ln5027">    if (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab : eap-&gt;addr_count == 0</a>
<a name="ln5028">                        ? 0 : (int)eap-&gt;line2 + 1, eap-&gt;arg) != FAIL) {</a>
<a name="ln5029">      do_exedit(eap, old_curwin);</a>
<a name="ln5030">      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);</a>
<a name="ln5031"> </a>
<a name="ln5032">      // set the alternate buffer for the window we came from</a>
<a name="ln5033">      if (curwin != old_curwin</a>
<a name="ln5034">          &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5035">          &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5036">          &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5037">        old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5038">      }</a>
<a name="ln5039">    }</a>
<a name="ln5040">  } else if (win_split(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 0,</a>
<a name="ln5041">                       *eap-&gt;cmd == 'v' ? WSP_VERT : 0) != FAIL) {</a>
<a name="ln5042">    // Reset 'scrollbind' when editing another file, but keep it when</a>
<a name="ln5043">    // doing &quot;:split&quot; without arguments.</a>
<a name="ln5044">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln5045">      RESET_BINDING(curwin);</a>
<a name="ln5046">    } else {</a>
<a name="ln5047">      do_check_scrollbind(false);</a>
<a name="ln5048">    }</a>
<a name="ln5049">    do_exedit(eap, old_curwin);</a>
<a name="ln5050">  }</a>
<a name="ln5051"> </a>
<a name="ln5052">theend:</a>
<a name="ln5053">  xfree(fname);</a>
<a name="ln5054">}</a>
<a name="ln5055"> </a>
<a name="ln5056">/// Open a new tab page.</a>
<a name="ln5057">void tabpage_new(void)</a>
<a name="ln5058">{</a>
<a name="ln5059">  exarg_T ea = {</a>
<a name="ln5060">    .cmdidx = CMD_tabnew,</a>
<a name="ln5061">    .cmd = &quot;tabn&quot;,</a>
<a name="ln5062">    .arg = &quot;&quot;,</a>
<a name="ln5063">  };</a>
<a name="ln5064">  ex_splitview(&amp;ea);</a>
<a name="ln5065">}</a>
<a name="ln5066"> </a>
<a name="ln5067">/// :tabnext command</a>
<a name="ln5068">static void ex_tabnext(exarg_T *eap)</a>
<a name="ln5069">{</a>
<a name="ln5070">  int tab_number;</a>
<a name="ln5071"> </a>
<a name="ln5072">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5073">  case CMD_tabfirst:</a>
<a name="ln5074">  case CMD_tabrewind:</a>
<a name="ln5075">    goto_tabpage(1);</a>
<a name="ln5076">    break;</a>
<a name="ln5077">  case CMD_tablast:</a>
<a name="ln5078">    goto_tabpage(9999);</a>
<a name="ln5079">    break;</a>
<a name="ln5080">  case CMD_tabprevious:</a>
<a name="ln5081">  case CMD_tabNext:</a>
<a name="ln5082">    if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln5083">      char *p = eap-&gt;arg;</a>
<a name="ln5084">      char *p_save = p;</a>
<a name="ln5085">      tab_number = (int)getdigits(&amp;p, false, 0);</a>
<a name="ln5086">      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL</a>
<a name="ln5087">          || tab_number == 0) {</a>
<a name="ln5088">        // No numbers as argument.</a>
<a name="ln5089">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln5090">        return;</a>
<a name="ln5091">      }</a>
<a name="ln5092">    } else {</a>
<a name="ln5093">      if (eap-&gt;addr_count == 0) {</a>
<a name="ln5094">        tab_number = 1;</a>
<a name="ln5095">      } else {</a>
<a name="ln5096">        tab_number = (int)eap-&gt;line2;</a>
<a name="ln5097">        if (tab_number &lt; 1) {</a>
<a name="ln5098">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln5099">          return;</a>
<a name="ln5100">        }</a>
<a name="ln5101">      }</a>
<a name="ln5102">    }</a>
<a name="ln5103">    goto_tabpage(-tab_number);</a>
<a name="ln5104">    break;</a>
<a name="ln5105">  default:       // CMD_tabnext</a>
<a name="ln5106">    tab_number = get_tabpage_arg(eap);</a>
<a name="ln5107">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5108">      goto_tabpage(tab_number);</a>
<a name="ln5109">    }</a>
<a name="ln5110">    break;</a>
<a name="ln5111">  }</a>
<a name="ln5112">}</a>
<a name="ln5113"> </a>
<a name="ln5114">/// :tabmove command</a>
<a name="ln5115">static void ex_tabmove(exarg_T *eap)</a>
<a name="ln5116">{</a>
<a name="ln5117">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln5118">  if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5119">    tabpage_move(tab_number);</a>
<a name="ln5120">  }</a>
<a name="ln5121">}</a>
<a name="ln5122"> </a>
<a name="ln5123">/// :tabs command: List tabs and their contents.</a>
<a name="ln5124">static void ex_tabs(exarg_T *eap)</a>
<a name="ln5125">{</a>
<a name="ln5126">  int tabcount = 1;</a>
<a name="ln5127"> </a>
<a name="ln5128">  msg_start();</a>
<a name="ln5129">  msg_scroll = true;</a>
<a name="ln5130"> </a>
<a name="ln5131">  win_T *lastused_win = valid_tabpage(lastused_tabpage)</a>
<a name="ln5132">    ? lastused_tabpage-&gt;tp_curwin</a>
<a name="ln5133">    : NULL;</a>
<a name="ln5134"> </a>
<a name="ln5135">  FOR_ALL_TABS(tp) {</a>
<a name="ln5136">    if (got_int) {</a>
<a name="ln5137">      break;</a>
<a name="ln5138">    }</a>
<a name="ln5139"> </a>
<a name="ln5140">    msg_putchar('\n');</a>
<a name="ln5141">    vim_snprintf(IObuff, IOSIZE, _(&quot;Tab page %d&quot;), tabcount++);</a>
<a name="ln5142">    msg_outtrans(IObuff, HL_ATTR(HLF_T));</a>
<a name="ln5143">    os_breakcheck();</a>
<a name="ln5144"> </a>
<a name="ln5145">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln5146">      if (got_int) {</a>
<a name="ln5147">        break;</a>
<a name="ln5148">      }</a>
<a name="ln5149"> </a>
<a name="ln5150">      msg_putchar('\n');</a>
<a name="ln5151">      msg_putchar(wp == curwin ? '&gt;' : wp == lastused_win ? '#' : ' ');</a>
<a name="ln5152">      msg_putchar(' ');</a>
<a name="ln5153">      msg_putchar(bufIsChanged(wp-&gt;w_buffer) ? '+' : ' ');</a>
<a name="ln5154">      msg_putchar(' ');</a>
<a name="ln5155">      if (buf_spname(wp-&gt;w_buffer) != NULL) {</a>
<a name="ln5156">        xstrlcpy(IObuff, buf_spname(wp-&gt;w_buffer), IOSIZE);</a>
<a name="ln5157">      } else {</a>
<a name="ln5158">        home_replace(wp-&gt;w_buffer, wp-&gt;w_buffer-&gt;b_fname, IObuff, IOSIZE, true);</a>
<a name="ln5159">      }</a>
<a name="ln5160">      msg_outtrans(IObuff, 0);</a>
<a name="ln5161">      os_breakcheck();</a>
<a name="ln5162">    }</a>
<a name="ln5163">  }</a>
<a name="ln5164">}</a>
<a name="ln5165"> </a>
<a name="ln5166">/// &quot;:mode&quot;:</a>
<a name="ln5167">/// If no argument given, get the screen size and redraw.</a>
<a name="ln5168">static void ex_mode(exarg_T *eap)</a>
<a name="ln5169">{</a>
<a name="ln5170">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5171">    must_redraw = UPD_CLEAR;</a>
<a name="ln5172">    ex_redraw(eap);</a>
<a name="ln5173">  } else {</a>
<a name="ln5174">    emsg(_(e_screenmode));</a>
<a name="ln5175">  }</a>
<a name="ln5176">}</a>
<a name="ln5177"> </a>
<a name="ln5178">/// &quot;:resize&quot;.</a>
<a name="ln5179">/// set, increment or decrement current window height</a>
<a name="ln5180">static void ex_resize(exarg_T *eap)</a>
<a name="ln5181">{</a>
<a name="ln5182">  win_T *wp = curwin;</a>
<a name="ln5183"> </a>
<a name="ln5184">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5185">    int n = (int)eap-&gt;line2;</a>
<a name="ln5186">    for (wp = firstwin; wp-&gt;w_next != NULL &amp;&amp; --n &gt; 0; wp = wp-&gt;w_next) {}</a>
<a name="ln5187">  }</a>
<a name="ln5188"> </a>
<a name="ln5189">  int n = (int)atol(eap-&gt;arg);</a>
<a name="ln5190">  if (cmdmod.cmod_split &amp; WSP_VERT) {</a>
<a name="ln5191">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5192">      n += wp-&gt;w_width;</a>
<a name="ln5193">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very wide</a>
<a name="ln5194">      n = Columns;</a>
<a name="ln5195">    }</a>
<a name="ln5196">    win_setwidth_win(n, wp);</a>
<a name="ln5197">  } else {</a>
<a name="ln5198">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5199">      n += wp-&gt;w_height;</a>
<a name="ln5200">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very high</a>
<a name="ln5201">      n = Rows - 1;</a>
<a name="ln5202">    }</a>
<a name="ln5203">    win_setheight_win(n, wp);</a>
<a name="ln5204">  }</a>
<a name="ln5205">}</a>
<a name="ln5206"> </a>
<a name="ln5207">/// &quot;:find [+command] &lt;file&gt;&quot; command.</a>
<a name="ln5208">static void ex_find(exarg_T *eap)</a>
<a name="ln5209">{</a>
<a name="ln5210">  char *file_to_find = NULL;</a>
<a name="ln5211">  char *search_ctx = NULL;</a>
<a name="ln5212">  char *fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5213">                                  FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5214">                                  &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5215">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5216">    // Repeat finding the file &quot;count&quot; times.  This matters when it appears</a>
<a name="ln5217">    // several times in the path.</a>
<a name="ln5218">    linenr_T count = eap-&gt;line2;</a>
<a name="ln5219">    while (fname != NULL &amp;&amp; --count &gt; 0) {</a>
<a name="ln5220">      xfree(fname);</a>
<a name="ln5221">      fname = find_file_in_path(NULL, 0, FNAME_MESS, false, curbuf-&gt;b_ffname,</a>
<a name="ln5222">                                &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5223">    }</a>
<a name="ln5224">  }</a>
<a name="ln5225">  xfree(file_to_find);</a>
<a name="ln5226">  vim_findfile_cleanup(search_ctx);</a>
<a name="ln5227"> </a>
<a name="ln5228">  if (fname == NULL) {</a>
<a name="ln5229">    return;</a>
<a name="ln5230">  }</a>
<a name="ln5231"> </a>
<a name="ln5232">  eap-&gt;arg = fname;</a>
<a name="ln5233">  do_exedit(eap, NULL);</a>
<a name="ln5234">  xfree(fname);</a>
<a name="ln5235">}</a>
<a name="ln5236"> </a>
<a name="ln5237">/// &quot;:edit&quot;, &quot;:badd&quot;, &quot;:balt&quot;, &quot;:visual&quot;.</a>
<a name="ln5238">static void ex_edit(exarg_T *eap)</a>
<a name="ln5239">{</a>
<a name="ln5240">  do_exedit(eap, NULL);</a>
<a name="ln5241">}</a>
<a name="ln5242"> </a>
<a name="ln5243">/// &quot;:edit &lt;file&gt;&quot; command and alike.</a>
<a name="ln5244">///</a>
<a name="ln5245">/// @param old_curwin  curwin before doing a split or NULL</a>
<a name="ln5246">void do_exedit(exarg_T *eap, win_T *old_curwin)</a>
<a name="ln5247">{</a>
<a name="ln5248">  int n;</a>
<a name="ln5249"> </a>
<a name="ln5250">  // &quot;:vi&quot; command ends Ex mode.</a>
<a name="ln5251">  if (exmode_active &amp;&amp; (eap-&gt;cmdidx == CMD_visual</a>
<a name="ln5252">                        || eap-&gt;cmdidx == CMD_view)) {</a>
<a name="ln5253">    exmode_active = false;</a>
<a name="ln5254">    ex_pressedreturn = false;</a>
<a name="ln5255">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln5256">      // Special case:  &quot;:global/pat/visual\NLvi-commands&quot;</a>
<a name="ln5257">      if (global_busy) {</a>
<a name="ln5258">        if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln5259">          stuffReadbuff(eap-&gt;nextcmd);</a>
<a name="ln5260">          eap-&gt;nextcmd = NULL;</a>
<a name="ln5261">        }</a>
<a name="ln5262"> </a>
<a name="ln5263">        const int save_rd = RedrawingDisabled;</a>
<a name="ln5264">        RedrawingDisabled = 0;</a>
<a name="ln5265">        const int save_nwr = no_wait_return;</a>
<a name="ln5266">        no_wait_return = 0;</a>
<a name="ln5267">        need_wait_return = false;</a>
<a name="ln5268">        const int save_ms = msg_scroll;</a>
<a name="ln5269">        msg_scroll = 0;</a>
<a name="ln5270">        redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln5271">        pending_exmode_active = true;</a>
<a name="ln5272"> </a>
<a name="ln5273">        normal_enter(false, true);</a>
<a name="ln5274"> </a>
<a name="ln5275">        pending_exmode_active = false;</a>
<a name="ln5276">        RedrawingDisabled = save_rd;</a>
<a name="ln5277">        no_wait_return = save_nwr;</a>
<a name="ln5278">        msg_scroll = save_ms;</a>
<a name="ln5279">      }</a>
<a name="ln5280">      return;</a>
<a name="ln5281">    }</a>
<a name="ln5282">  }</a>
<a name="ln5283"> </a>
<a name="ln5284">  if ((eap-&gt;cmdidx == CMD_new</a>
<a name="ln5285">       || eap-&gt;cmdidx == CMD_tabnew</a>
<a name="ln5286">       || eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln5287">       || eap-&gt;cmdidx == CMD_vnew) &amp;&amp; *eap-&gt;arg == NUL) {</a>
<a name="ln5288">    // &quot;:new&quot; or &quot;:tabnew&quot; without argument: edit a new empty buffer</a>
<a name="ln5289">    setpcmark();</a>
<a name="ln5290">    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,</a>
<a name="ln5291">                  ECMD_HIDE + (eap-&gt;forceit ? ECMD_FORCEIT : 0),</a>
<a name="ln5292">                  old_curwin == NULL ? curwin : NULL);</a>
<a name="ln5293">  } else if ((eap-&gt;cmdidx != CMD_split &amp;&amp; eap-&gt;cmdidx != CMD_vsplit)</a>
<a name="ln5294">             || *eap-&gt;arg != NUL) {</a>
<a name="ln5295">    // Can't edit another file when &quot;textlock&quot; or &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln5296">    // Only &quot;:edit&quot; or &quot;:script&quot; can bring us here, others are stopped earlier.</a>
<a name="ln5297">    if (*eap-&gt;arg != NUL &amp;&amp; text_or_buf_locked()) {</a>
<a name="ln5298">      return;</a>
<a name="ln5299">    }</a>
<a name="ln5300">    n = readonlymode;</a>
<a name="ln5301">    if (eap-&gt;cmdidx == CMD_view || eap-&gt;cmdidx == CMD_sview) {</a>
<a name="ln5302">      readonlymode = true;</a>
<a name="ln5303">    } else if (eap-&gt;cmdidx == CMD_enew) {</a>
<a name="ln5304">      readonlymode = false;  // 'readonly' doesn't make sense</a>
<a name="ln5305">                             // in an empty buffer</a>
<a name="ln5306">    }</a>
<a name="ln5307">    if (eap-&gt;cmdidx != CMD_balt &amp;&amp; eap-&gt;cmdidx != CMD_badd) {</a>
<a name="ln5308">      setpcmark();</a>
<a name="ln5309">    }</a>
<a name="ln5310">    if (do_ecmd(0, eap-&gt;cmdidx == CMD_enew ? NULL : eap-&gt;arg,</a>
<a name="ln5311">                NULL, eap, eap-&gt;do_ecmd_lnum,</a>
<a name="ln5312">                (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln5313">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0)</a>
<a name="ln5314">                // After a split we can use an existing buffer.</a>
<a name="ln5315">                + (old_curwin != NULL ? ECMD_OLDBUF : 0)</a>
<a name="ln5316">                + (eap-&gt;cmdidx == CMD_badd ? ECMD_ADDBUF : 0)</a>
<a name="ln5317">                + (eap-&gt;cmdidx == CMD_balt ? ECMD_ALTBUF : 0),</a>
<a name="ln5318">                old_curwin == NULL ? curwin : NULL) == FAIL) {</a>
<a name="ln5319">      // Editing the file failed.  If the window was split, close it.</a>
<a name="ln5320">      if (old_curwin != NULL) {</a>
<a name="ln5321">        bool need_hide = (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln5322">        if (!need_hide || buf_hide(curbuf)) {</a>
<a name="ln5323">          cleanup_T cs;</a>
<a name="ln5324"> </a>
<a name="ln5325">          // Reset the error/interrupt/exception state here so that</a>
<a name="ln5326">          // aborting() returns false when closing a window.</a>
<a name="ln5327">          enter_cleanup(&amp;cs);</a>
<a name="ln5328">          win_close(curwin, !need_hide &amp;&amp; !buf_hide(curbuf), false);</a>
<a name="ln5329"> </a>
<a name="ln5330">          // Restore the error/interrupt/exception state if not</a>
<a name="ln5331">          // discarded by a new aborting error, interrupt, or</a>
<a name="ln5332">          // uncaught exception.</a>
<a name="ln5333">          leave_cleanup(&amp;cs);</a>
<a name="ln5334">        }</a>
<a name="ln5335">      }</a>
<a name="ln5336">    } else if (readonlymode &amp;&amp; curbuf-&gt;b_nwindows == 1) {</a>
<a name="ln5337">      // When editing an already visited buffer, 'readonly' won't be set</a>
<a name="ln5338">      // but the previous value is kept.  With &quot;:view&quot; and &quot;:sview&quot; we</a>
<a name="ln5339">      // want the  file to be readonly, except when another window is</a>
<a name="ln5340">      // editing the same buffer.</a>
<a name="ln5341">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln5342">    }</a>
<a name="ln5343">    readonlymode = n;</a>
<a name="ln5344">  } else {</a>
<a name="ln5345">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln5346">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln5347">    }</a>
<a name="ln5348">    n = curwin-&gt;w_arg_idx_invalid;</a>
<a name="ln5349">    check_arg_idx(curwin);</a>
<a name="ln5350">    if (n != curwin-&gt;w_arg_idx_invalid) {</a>
<a name="ln5351">      maketitle();</a>
<a name="ln5352">    }</a>
<a name="ln5353">  }</a>
<a name="ln5354"> </a>
<a name="ln5355">  // if &quot;:split file&quot; worked, set alternate file name in old window to new</a>
<a name="ln5356">  // file</a>
<a name="ln5357">  if (old_curwin != NULL</a>
<a name="ln5358">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln5359">      &amp;&amp; curwin != old_curwin</a>
<a name="ln5360">      &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5361">      &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5362">      &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5363">    old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5364">  }</a>
<a name="ln5365"> </a>
<a name="ln5366">  ex_no_reprint = true;</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369">/// &quot;:gui&quot; and &quot;:gvim&quot; when there is no GUI.</a>
<a name="ln5370">static void ex_nogui(exarg_T *eap)</a>
<a name="ln5371">{</a>
<a name="ln5372">  eap-&gt;errmsg = _(&quot;E25: Nvim does not have a built-in GUI&quot;);</a>
<a name="ln5373">}</a>
<a name="ln5374"> </a>
<a name="ln5375">static void ex_popup(exarg_T *eap)</a>
<a name="ln5376">{</a>
<a name="ln5377">  pum_make_popup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln5378">}</a>
<a name="ln5379"> </a>
<a name="ln5380">static void ex_swapname(exarg_T *eap)</a>
<a name="ln5381">{</a>
<a name="ln5382">  if (curbuf-&gt;b_ml.ml_mfp == NULL || curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln5383">    msg(_(&quot;No swap file&quot;), 0);</a>
<a name="ln5384">  } else {</a>
<a name="ln5385">    msg(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname, 0);</a>
<a name="ln5386">  }</a>
<a name="ln5387">}</a>
<a name="ln5388"> </a>
<a name="ln5389">/// &quot;:syncbind&quot; forces all 'scrollbind' windows to have the same relative</a>
<a name="ln5390">/// offset.</a>
<a name="ln5391">/// (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln5392">static void ex_syncbind(exarg_T *eap)</a>
<a name="ln5393">{</a>
<a name="ln5394">  win_T *save_curwin = curwin;</a>
<a name="ln5395">  buf_T *save_curbuf = curbuf;</a>
<a name="ln5396">  linenr_T topline;</a>
<a name="ln5397">  int y;</a>
<a name="ln5398">  linenr_T old_linenr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln5399"> </a>
<a name="ln5400">  setpcmark();</a>
<a name="ln5401"> </a>
<a name="ln5402">  // determine max topline</a>
<a name="ln5403">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5404">    topline = curwin-&gt;w_topline;</a>
<a name="ln5405">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5406">      if (wp-&gt;w_p_scb &amp;&amp; wp-&gt;w_buffer) {</a>
<a name="ln5407">        y = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - get_scrolloff_value(curwin);</a>
<a name="ln5408">        if (topline &gt; y) {</a>
<a name="ln5409">          topline = y;</a>
<a name="ln5410">        }</a>
<a name="ln5411">      }</a>
<a name="ln5412">    }</a>
<a name="ln5413">    if (topline &lt; 1) {</a>
<a name="ln5414">      topline = 1;</a>
<a name="ln5415">    }</a>
<a name="ln5416">  } else {</a>
<a name="ln5417">    topline = 1;</a>
<a name="ln5418">  }</a>
<a name="ln5419"> </a>
<a name="ln5420">  // Set all scrollbind windows to the same topline.</a>
<a name="ln5421">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5422">    curwin = wp;</a>
<a name="ln5423">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln5424">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln5425">      y = topline - curwin-&gt;w_topline;</a>
<a name="ln5426">      if (y &gt; 0) {</a>
<a name="ln5427">        scrollup(y, true);</a>
<a name="ln5428">      } else {</a>
<a name="ln5429">        scrolldown(-y, true);</a>
<a name="ln5430">      }</a>
<a name="ln5431">      curwin-&gt;w_scbind_pos = topline;</a>
<a name="ln5432">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln5433">      cursor_correct();</a>
<a name="ln5434">      curwin-&gt;w_redr_status = true;</a>
<a name="ln5435">    }</a>
<a name="ln5436">  }</a>
<a name="ln5437">  curwin = save_curwin;</a>
<a name="ln5438">  curbuf = save_curbuf;</a>
<a name="ln5439">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5440">    did_syncbind = true;</a>
<a name="ln5441">    checkpcmark();</a>
<a name="ln5442">    if (old_linenr != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5443">      char ctrl_o[2];</a>
<a name="ln5444"> </a>
<a name="ln5445">      ctrl_o[0] = Ctrl_O;</a>
<a name="ln5446">      ctrl_o[1] = 0;</a>
<a name="ln5447">      ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);</a>
<a name="ln5448">    }</a>
<a name="ln5449">  }</a>
<a name="ln5450">}</a>
<a name="ln5451"> </a>
<a name="ln5452">static void ex_read(exarg_T *eap)</a>
<a name="ln5453">{</a>
<a name="ln5454">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln5455"> </a>
<a name="ln5456">  if (eap-&gt;usefilter) {  // :r!cmd</a>
<a name="ln5457">    do_bang(1, eap, false, false, true);</a>
<a name="ln5458">    return;</a>
<a name="ln5459">  }</a>
<a name="ln5460"> </a>
<a name="ln5461">  if (u_save(eap-&gt;line2, (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln5462">    return;</a>
<a name="ln5463">  }</a>
<a name="ln5464"> </a>
<a name="ln5465">  int i;</a>
<a name="ln5466">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5467">    if (check_fname() == FAIL) {       // check for no file name</a>
<a name="ln5468">      return;</a>
<a name="ln5469">    }</a>
<a name="ln5470">    i = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln5471">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5472">  } else {</a>
<a name="ln5473">    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL) {</a>
<a name="ln5474">      (void)setaltfname(eap-&gt;arg, eap-&gt;arg, (linenr_T)1);</a>
<a name="ln5475">    }</a>
<a name="ln5476">    i = readfile(eap-&gt;arg, NULL,</a>
<a name="ln5477">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5478">  }</a>
<a name="ln5479">  if (i != OK) {</a>
<a name="ln5480">    if (!aborting()) {</a>
<a name="ln5481">      semsg(_(e_notopen), eap-&gt;arg);</a>
<a name="ln5482">    }</a>
<a name="ln5483">  } else {</a>
<a name="ln5484">    if (empty &amp;&amp; exmode_active) {</a>
<a name="ln5485">      // Delete the empty line that remains.  Historically ex does</a>
<a name="ln5486">      // this but vi doesn't.</a>
<a name="ln5487">      linenr_T lnum;</a>
<a name="ln5488">      if (eap-&gt;line2 == 0) {</a>
<a name="ln5489">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5490">      } else {</a>
<a name="ln5491">        lnum = 1;</a>
<a name="ln5492">      }</a>
<a name="ln5493">      if (*ml_get(lnum) == NUL &amp;&amp; u_savedel(lnum, 1L) == OK) {</a>
<a name="ln5494">        ml_delete(lnum, false);</a>
<a name="ln5495">        if (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln5496">            &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= lnum) {</a>
<a name="ln5497">          curwin-&gt;w_cursor.lnum--;</a>
<a name="ln5498">        }</a>
<a name="ln5499">        deleted_lines_mark(lnum, 1L);</a>
<a name="ln5500">      }</a>
<a name="ln5501">    }</a>
<a name="ln5502">    redraw_curbuf_later(UPD_VALID);</a>
<a name="ln5503">  }</a>
<a name="ln5504">}</a>
<a name="ln5505"> </a>
<a name="ln5506">static char *prev_dir = NULL;</a>
<a name="ln5507"> </a>
<a name="ln5508">#if defined(EXITFREE)</a>
<a name="ln5509">void free_cd_dir(void)</a>
<a name="ln5510">{</a>
<a name="ln5511">  XFREE_CLEAR(prev_dir);</a>
<a name="ln5512">  XFREE_CLEAR(globaldir);</a>
<a name="ln5513">}</a>
<a name="ln5514"> </a>
<a name="ln5515">#endif</a>
<a name="ln5516"> </a>
<a name="ln5517">/// Get the previous directory for the given chdir scope.</a>
<a name="ln5518">static char *get_prevdir(CdScope scope)</a>
<a name="ln5519">{</a>
<a name="ln5520">  switch (scope) {</a>
<a name="ln5521">  case kCdScopeTabpage:</a>
<a name="ln5522">    return curtab-&gt;tp_prevdir;</a>
<a name="ln5523">    break;</a>
<a name="ln5524">  case kCdScopeWindow:</a>
<a name="ln5525">    return curwin-&gt;w_prevdir;</a>
<a name="ln5526">    break;</a>
<a name="ln5527">  default:</a>
<a name="ln5528">    return prev_dir;</a>
<a name="ln5529">  }</a>
<a name="ln5530">}</a>
<a name="ln5531"> </a>
<a name="ln5532">/// Deal with the side effects of changing the current directory.</a>
<a name="ln5533">///</a>
<a name="ln5534">/// @param scope  Scope of the function call (global, tab or window).</a>
<a name="ln5535">static void post_chdir(CdScope scope, bool trigger_dirchanged)</a>
<a name="ln5536">{</a>
<a name="ln5537">  // Always overwrite the window-local CWD.</a>
<a name="ln5538">  XFREE_CLEAR(curwin-&gt;w_localdir);</a>
<a name="ln5539"> </a>
<a name="ln5540">  // Overwrite the tab-local CWD for :cd, :tcd.</a>
<a name="ln5541">  if (scope &gt;= kCdScopeTabpage) {</a>
<a name="ln5542">    XFREE_CLEAR(curtab-&gt;tp_localdir);</a>
<a name="ln5543">  }</a>
<a name="ln5544"> </a>
<a name="ln5545">  if (scope &lt; kCdScopeGlobal) {</a>
<a name="ln5546">    char *pdir = get_prevdir(scope);</a>
<a name="ln5547">    // If still in global directory, set CWD as the global directory.</a>
<a name="ln5548">    if (globaldir == NULL &amp;&amp; pdir != NULL) {</a>
<a name="ln5549">      globaldir = xstrdup(pdir);</a>
<a name="ln5550">    }</a>
<a name="ln5551">  }</a>
<a name="ln5552"> </a>
<a name="ln5553">  char cwd[MAXPATHL];</a>
<a name="ln5554">  if (os_dirname(cwd, MAXPATHL) != OK) {</a>
<a name="ln5555">    return;</a>
<a name="ln5556">  }</a>
<a name="ln5557">  switch (scope) {</a>
<a name="ln5558">  case kCdScopeGlobal:</a>
<a name="ln5559">    // We are now in the global directory, no need to remember its name.</a>
<a name="ln5560">    XFREE_CLEAR(globaldir);</a>
<a name="ln5561">    break;</a>
<a name="ln5562">  case kCdScopeTabpage:</a>
<a name="ln5563">    curtab-&gt;tp_localdir = xstrdup(cwd);</a>
<a name="ln5564">    break;</a>
<a name="ln5565">  case kCdScopeWindow:</a>
<a name="ln5566">    curwin-&gt;w_localdir = xstrdup(cwd);</a>
<a name="ln5567">    break;</a>
<a name="ln5568">  case kCdScopeInvalid:</a>
<a name="ln5569">    abort();</a>
<a name="ln5570">  }</a>
<a name="ln5571"> </a>
<a name="ln5572">  last_chdir_reason = NULL;</a>
<a name="ln5573">  shorten_fnames(true);</a>
<a name="ln5574"> </a>
<a name="ln5575">  if (trigger_dirchanged) {</a>
<a name="ln5576">    do_autocmd_dirchanged(cwd, scope, kCdCauseManual, false);</a>
<a name="ln5577">  }</a>
<a name="ln5578">}</a>
<a name="ln5579"> </a>
<a name="ln5580">/// Change directory function used by :cd/:tcd/:lcd Ex commands and the chdir() function.</a>
<a name="ln5581">/// @param new_dir  The directory to change to.</a>
<a name="ln5582">/// @param scope    Scope of the function call (global, tab or window).</a>
<a name="ln5583">/// @return true if the directory is successfully changed.</a>
<a name="ln5584">bool changedir_func(char *new_dir, CdScope scope)</a>
<a name="ln5585">{</a>
<a name="ln5586">  if (new_dir == NULL || allbuf_locked()) {</a>
<a name="ln5587">    return false;</a>
<a name="ln5588">  }</a>
<a name="ln5589"> </a>
<a name="ln5590">  char *pdir = NULL;</a>
<a name="ln5591">  // &quot;:cd -&quot;: Change to previous directory</a>
<a name="ln5592">  if (strcmp(new_dir, &quot;-&quot;) == 0) {</a>
<a name="ln5593">    pdir = get_prevdir(scope);</a>
<a name="ln5594">    if (pdir == NULL) {</a>
<a name="ln5595">      emsg(_(&quot;E186: No previous directory&quot;));</a>
<a name="ln5596">      return false;</a>
<a name="ln5597">    }</a>
<a name="ln5598">    new_dir = pdir;</a>
<a name="ln5599">  }</a>
<a name="ln5600"> </a>
<a name="ln5601">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5602">    pdir = xstrdup(NameBuff);</a>
<a name="ln5603">  } else {</a>
<a name="ln5604">    pdir = NULL;</a>
<a name="ln5605">  }</a>
<a name="ln5606"> </a>
<a name="ln5607">  // For UNIX &quot;:cd&quot; means: go to home directory.</a>
<a name="ln5608">  // On other systems too if 'cdhome' is set.</a>
<a name="ln5609">#if defined(UNIX)</a>
<a name="ln5610">  if (*new_dir == NUL) {</a>
<a name="ln5611">#else</a>
<a name="ln5612">  if (*new_dir == NUL &amp;&amp; p_cdh) {</a>
<a name="ln5613">#endif</a>
<a name="ln5614">    // Use NameBuff for home directory name.</a>
<a name="ln5615">    expand_env(&quot;$HOME&quot;, NameBuff, MAXPATHL);</a>
<a name="ln5616">    new_dir = NameBuff;</a>
<a name="ln5617">  }</a>
<a name="ln5618"> </a>
<a name="ln5619">  bool dir_differs = pdir == NULL || pathcmp(pdir, new_dir, -1) != 0;</a>
<a name="ln5620">  if (dir_differs) {</a>
<a name="ln5621">    do_autocmd_dirchanged(new_dir, scope, kCdCauseManual, true);</a>
<a name="ln5622">    if (vim_chdir(new_dir) != 0) {</a>
<a name="ln5623">      emsg(_(e_failed));</a>
<a name="ln5624">      xfree(pdir);</a>
<a name="ln5625">      return false;</a>
<a name="ln5626">    }</a>
<a name="ln5627">  }</a>
<a name="ln5628"> </a>
<a name="ln5629">  char **pp;</a>
<a name="ln5630">  switch (scope) {</a>
<a name="ln5631">  case kCdScopeTabpage:</a>
<a name="ln5632">    pp = &amp;curtab-&gt;tp_prevdir;</a>
<a name="ln5633">    break;</a>
<a name="ln5634">  case kCdScopeWindow:</a>
<a name="ln5635">    pp = &amp;curwin-&gt;w_prevdir;</a>
<a name="ln5636">    break;</a>
<a name="ln5637">  default:</a>
<a name="ln5638">    pp = &amp;prev_dir;</a>
<a name="ln5639">  }</a>
<a name="ln5640">  xfree(*pp);</a>
<a name="ln5641">  *pp = pdir;</a>
<a name="ln5642"> </a>
<a name="ln5643">  post_chdir(scope, dir_differs);</a>
<a name="ln5644"> </a>
<a name="ln5645">  return true;</a>
<a name="ln5646">}</a>
<a name="ln5647"> </a>
<a name="ln5648">/// &quot;:cd&quot;, &quot;:tcd&quot;, &quot;:lcd&quot;, &quot;:chdir&quot;, &quot;tchdir&quot; and &quot;:lchdir&quot;.</a>
<a name="ln5649">void ex_cd(exarg_T *eap)</a>
<a name="ln5650">{</a>
<a name="ln5651">  char *new_dir = eap-&gt;arg;</a>
<a name="ln5652">#if !defined(UNIX)</a>
<a name="ln5653">  // for non-UNIX &quot;:cd&quot; means: print current directory unless 'cdhome' is set</a>
<a name="ln5654">  if (*new_dir == NUL &amp;&amp; !p_cdh) {</a>
<a name="ln5655">    ex_pwd(NULL);</a>
<a name="ln5656">    return;</a>
<a name="ln5657">  }</a>
<a name="ln5658">#endif</a>
<a name="ln5659"> </a>
<a name="ln5660">  CdScope scope = kCdScopeGlobal;</a>
<a name="ln5661">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5662">  case CMD_tcd:</a>
<a name="ln5663">  case CMD_tchdir:</a>
<a name="ln5664">    scope = kCdScopeTabpage;</a>
<a name="ln5665">    break;</a>
<a name="ln5666">  case CMD_lcd:</a>
<a name="ln5667">  case CMD_lchdir:</a>
<a name="ln5668">    scope = kCdScopeWindow;</a>
<a name="ln5669">    break;</a>
<a name="ln5670">  default:</a>
<a name="ln5671">    break;</a>
<a name="ln5672">  }</a>
<a name="ln5673">  if (changedir_func(new_dir, scope)) {</a>
<a name="ln5674">    // Echo the new current directory if the command was typed.</a>
<a name="ln5675">    if (KeyTyped || p_verbose &gt;= 5) {</a>
<a name="ln5676">      ex_pwd(eap);</a>
<a name="ln5677">    }</a>
<a name="ln5678">  }</a>
<a name="ln5679">}</a>
<a name="ln5680"> </a>
<a name="ln5681">/// &quot;:pwd&quot;.</a>
<a name="ln5682">static void ex_pwd(exarg_T *eap)</a>
<a name="ln5683">{</a>
<a name="ln5684">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5685">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5686">    slash_adjust(NameBuff);</a>
<a name="ln5687">#endif</a>
<a name="ln5688">    if (p_verbose &gt; 0) {</a>
<a name="ln5689">      char *context = &quot;global&quot;;</a>
<a name="ln5690">      if (last_chdir_reason != NULL) {</a>
<a name="ln5691">        context = last_chdir_reason;</a>
<a name="ln5692">      } else if (curwin-&gt;w_localdir != NULL) {</a>
<a name="ln5693">        context = &quot;window&quot;;</a>
<a name="ln5694">      } else if (curtab-&gt;tp_localdir != NULL) {</a>
<a name="ln5695">        context = &quot;tabpage&quot;;</a>
<a name="ln5696">      }</a>
<a name="ln5697">      smsg(0, &quot;[%s] %s&quot;, context, NameBuff);</a>
<a name="ln5698">    } else {</a>
<a name="ln5699">      msg(NameBuff, 0);</a>
<a name="ln5700">    }</a>
<a name="ln5701">  } else {</a>
<a name="ln5702">    emsg(_(&quot;E187: Unknown&quot;));</a>
<a name="ln5703">  }</a>
<a name="ln5704">}</a>
<a name="ln5705"> </a>
<a name="ln5706">/// &quot;:=&quot;.</a>
<a name="ln5707">static void ex_equal(exarg_T *eap)</a>
<a name="ln5708">{</a>
<a name="ln5709">  if (*eap-&gt;arg != NUL &amp;&amp; *eap-&gt;arg != '|') {</a>
<a name="ln5710">    // equivalent to :lua= expr</a>
<a name="ln5711">    ex_lua(eap);</a>
<a name="ln5712">  } else {</a>
<a name="ln5713">    eap-&gt;nextcmd = find_nextcmd(eap-&gt;arg);</a>
<a name="ln5714">    smsg(0, &quot;%&quot; PRId64, (int64_t)eap-&gt;line2);</a>
<a name="ln5715">  }</a>
<a name="ln5716">}</a>
<a name="ln5717"> </a>
<a name="ln5718">static void ex_sleep(exarg_T *eap)</a>
<a name="ln5719">{</a>
<a name="ln5720">  if (cursor_valid()) {</a>
<a name="ln5721">    setcursor_mayforce(true);</a>
<a name="ln5722">  }</a>
<a name="ln5723"> </a>
<a name="ln5724">  int64_t len = eap-&gt;line2;</a>
<a name="ln5725">  switch (*eap-&gt;arg) {</a>
<a name="ln5726">  case 'm':</a>
<a name="ln5727">    break;</a>
<a name="ln5728">  case NUL:</a>
<a name="ln5729">    len *= 1000L; break;</a>
<a name="ln5730">  default:</a>
<a name="ln5731">    semsg(_(e_invarg2), eap-&gt;arg); return;</a>
<a name="ln5732">  }</a>
<a name="ln5733">  do_sleep(len);</a>
<a name="ln5734">}</a>
<a name="ln5735"> </a>
<a name="ln5736">/// Sleep for &quot;msec&quot; milliseconds, but return early on CTRL-C.</a>
<a name="ln5737">void do_sleep(int64_t msec)</a>
<a name="ln5738">{</a>
<a name="ln5739">  ui_flush();  // flush before waiting</a>
<a name="ln5740">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, msec, got_int);</a>
<a name="ln5741"> </a>
<a name="ln5742">  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the</a>
<a name="ln5743">  // input buffer, otherwise a following call to input() fails.</a>
<a name="ln5744">  if (got_int) {</a>
<a name="ln5745">    (void)vpeekc();</a>
<a name="ln5746">  }</a>
<a name="ln5747">}</a>
<a name="ln5748"> </a>
<a name="ln5749">/// &quot;:winsize&quot; command (obsolete).</a>
<a name="ln5750">static void ex_winsize(exarg_T *eap)</a>
<a name="ln5751">{</a>
<a name="ln5752">  char *arg = eap-&gt;arg;</a>
<a name="ln5753"> </a>
<a name="ln5754">  if (!ascii_isdigit(*arg)) {</a>
<a name="ln5755">    semsg(_(e_invarg2), arg);</a>
<a name="ln5756">    return;</a>
<a name="ln5757">  }</a>
<a name="ln5758">  int w = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5759">  arg = skipwhite(arg);</a>
<a name="ln5760">  char *p = arg;</a>
<a name="ln5761">  int h = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5762">  if (*p != NUL &amp;&amp; *arg == NUL) {</a>
<a name="ln5763">    screen_resize(w, h);</a>
<a name="ln5764">  } else {</a>
<a name="ln5765">    emsg(_(&quot;E465: :winsize requires two number arguments&quot;));</a>
<a name="ln5766">  }</a>
<a name="ln5767">}</a>
<a name="ln5768"> </a>
<a name="ln5769">static void ex_wincmd(exarg_T *eap)</a>
<a name="ln5770">{</a>
<a name="ln5771">  int xchar = NUL;</a>
<a name="ln5772">  char *p;</a>
<a name="ln5773"> </a>
<a name="ln5774">  if (*eap-&gt;arg == 'g' || *eap-&gt;arg == Ctrl_G) {</a>
<a name="ln5775">    // CTRL-W g and CTRL-W CTRL-G  have an extra command character</a>
<a name="ln5776">    if (eap-&gt;arg[1] == NUL) {</a>
<a name="ln5777">      emsg(_(e_invarg));</a>
<a name="ln5778">      return;</a>
<a name="ln5779">    }</a>
<a name="ln5780">    xchar = (uint8_t)eap-&gt;arg[1];</a>
<a name="ln5781">    p = eap-&gt;arg + 2;</a>
<a name="ln5782">  } else {</a>
<a name="ln5783">    p = eap-&gt;arg + 1;</a>
<a name="ln5784">  }</a>
<a name="ln5785"> </a>
<a name="ln5786">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln5787">  p = skipwhite(p);</a>
<a name="ln5788">  if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; eap-&gt;nextcmd == NULL) {</a>
<a name="ln5789">    emsg(_(e_invarg));</a>
<a name="ln5790">  } else if (!eap-&gt;skip) {</a>
<a name="ln5791">    // Pass flags on for &quot;:vertical wincmd ]&quot;.</a>
<a name="ln5792">    postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln5793">    postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln5794">    do_window(*eap-&gt;arg, eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0L, xchar);</a>
<a name="ln5795">    postponed_split_flags = 0;</a>
<a name="ln5796">    postponed_split_tab = 0;</a>
<a name="ln5797">  }</a>
<a name="ln5798">}</a>
<a name="ln5799"> </a>
<a name="ln5800">/// Handle command that work like operators: &quot;:delete&quot;, &quot;:yank&quot;, &quot;:&gt;&quot; and &quot;:&lt;&quot;.</a>
<a name="ln5801">static void ex_operators(exarg_T *eap)</a>
<a name="ln5802">{</a>
<a name="ln5803">  oparg_T oa;</a>
<a name="ln5804"> </a>
<a name="ln5805">  clear_oparg(&amp;oa);</a>
<a name="ln5806">  oa.regname = eap-&gt;regname;</a>
<a name="ln5807">  oa.start.lnum = eap-&gt;line1;</a>
<a name="ln5808">  oa.end.lnum = eap-&gt;line2;</a>
<a name="ln5809">  oa.line_count = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln5810">  oa.motion_type = kMTLineWise;</a>
<a name="ln5811">  virtual_op = kFalse;</a>
<a name="ln5812">  if (eap-&gt;cmdidx != CMD_yank) {  // position cursor for undo</a>
<a name="ln5813">    setpcmark();</a>
<a name="ln5814">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5815">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln5816">  }</a>
<a name="ln5817"> </a>
<a name="ln5818">  if (VIsual_active) {</a>
<a name="ln5819">    end_visual_mode();</a>
<a name="ln5820">  }</a>
<a name="ln5821"> </a>
<a name="ln5822">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5823">  case CMD_delete:</a>
<a name="ln5824">    oa.op_type = OP_DELETE;</a>
<a name="ln5825">    op_delete(&amp;oa);</a>
<a name="ln5826">    break;</a>
<a name="ln5827"> </a>
<a name="ln5828">  case CMD_yank:</a>
<a name="ln5829">    oa.op_type = OP_YANK;</a>
<a name="ln5830">    (void)op_yank(&amp;oa, true);</a>
<a name="ln5831">    break;</a>
<a name="ln5832"> </a>
<a name="ln5833">  default:          // CMD_rshift or CMD_lshift</a>
<a name="ln5834">    if (</a>
<a name="ln5835">        (eap-&gt;cmdidx == CMD_rshift) ^ curwin-&gt;w_p_rl) {</a>
<a name="ln5836">      oa.op_type = OP_RSHIFT;</a>
<a name="ln5837">    } else {</a>
<a name="ln5838">      oa.op_type = OP_LSHIFT;</a>
<a name="ln5839">    }</a>
<a name="ln5840">    op_shift(&amp;oa, false, eap-&gt;amount);</a>
<a name="ln5841">    break;</a>
<a name="ln5842">  }</a>
<a name="ln5843">  virtual_op = kNone;</a>
<a name="ln5844">  ex_may_print(eap);</a>
<a name="ln5845">}</a>
<a name="ln5846"> </a>
<a name="ln5847">/// &quot;:put&quot;.</a>
<a name="ln5848">static void ex_put(exarg_T *eap)</a>
<a name="ln5849">{</a>
<a name="ln5850">  // &quot;:0put&quot; works like &quot;:1put!&quot;.</a>
<a name="ln5851">  if (eap-&gt;line2 == 0) {</a>
<a name="ln5852">    eap-&gt;line2 = 1;</a>
<a name="ln5853">    eap-&gt;forceit = true;</a>
<a name="ln5854">  }</a>
<a name="ln5855">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5856">  check_cursor_col();</a>
<a name="ln5857">  do_put(eap-&gt;regname, NULL, eap-&gt;forceit ? BACKWARD : FORWARD, 1,</a>
<a name="ln5858">         PUT_LINE|PUT_CURSLINE);</a>
<a name="ln5859">}</a>
<a name="ln5860"> </a>
<a name="ln5861">/// Handle &quot;:copy&quot; and &quot;:move&quot;.</a>
<a name="ln5862">static void ex_copymove(exarg_T *eap)</a>
<a name="ln5863">{</a>
<a name="ln5864">  const char *errormsg = NULL;</a>
<a name="ln5865">  linenr_T n = get_address(eap, &amp;eap-&gt;arg, eap-&gt;addr_type, false, false, false, 1, &amp;errormsg);</a>
<a name="ln5866">  if (eap-&gt;arg == NULL) {  // error detected</a>
<a name="ln5867">    if (errormsg != NULL) {</a>
<a name="ln5868">      emsg(errormsg);</a>
<a name="ln5869">    }</a>
<a name="ln5870">    eap-&gt;nextcmd = NULL;</a>
<a name="ln5871">    return;</a>
<a name="ln5872">  }</a>
<a name="ln5873">  get_flags(eap);</a>
<a name="ln5874"> </a>
<a name="ln5875">  // move or copy lines from 'eap-&gt;line1'-'eap-&gt;line2' to below line 'n'</a>
<a name="ln5876">  if (n == MAXLNUM || n &lt; 0 || n &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5877">    emsg(_(e_invrange));</a>
<a name="ln5878">    return;</a>
<a name="ln5879">  }</a>
<a name="ln5880"> </a>
<a name="ln5881">  if (eap-&gt;cmdidx == CMD_move) {</a>
<a name="ln5882">    if (do_move(eap-&gt;line1, eap-&gt;line2, n) == FAIL) {</a>
<a name="ln5883">      return;</a>
<a name="ln5884">    }</a>
<a name="ln5885">  } else {</a>
<a name="ln5886">    ex_copy(eap-&gt;line1, eap-&gt;line2, n);</a>
<a name="ln5887">  }</a>
<a name="ln5888">  u_clearline(curbuf);</a>
<a name="ln5889">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln5890">  ex_may_print(eap);</a>
<a name="ln5891">}</a>
<a name="ln5892"> </a>
<a name="ln5893">/// Print the current line if flags were given to the Ex command.</a>
<a name="ln5894">void ex_may_print(exarg_T *eap)</a>
<a name="ln5895">{</a>
<a name="ln5896">  if (eap-&gt;flags != 0) {</a>
<a name="ln5897">    print_line(curwin-&gt;w_cursor.lnum, (eap-&gt;flags &amp; EXFLAG_NR),</a>
<a name="ln5898">               (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln5899">    ex_no_reprint = true;</a>
<a name="ln5900">  }</a>
<a name="ln5901">}</a>
<a name="ln5902"> </a>
<a name="ln5903">/// &quot;:smagic&quot; and &quot;:snomagic&quot;.</a>
<a name="ln5904">static void ex_submagic(exarg_T *eap)</a>
<a name="ln5905">{</a>
<a name="ln5906">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5907"> </a>
<a name="ln5908">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5909">  ex_substitute(eap);</a>
<a name="ln5910">  magic_overruled = saved;</a>
<a name="ln5911">}</a>
<a name="ln5912"> </a>
<a name="ln5913">/// &quot;:smagic&quot; and &quot;:snomagic&quot; preview callback.</a>
<a name="ln5914">static int ex_submagic_preview(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln5915">{</a>
<a name="ln5916">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5917"> </a>
<a name="ln5918">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5919">  int retv = ex_substitute_preview(eap, cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln5920">  magic_overruled = saved;</a>
<a name="ln5921"> </a>
<a name="ln5922">  return retv;</a>
<a name="ln5923">}</a>
<a name="ln5924"> </a>
<a name="ln5925">/// &quot;:join&quot;.</a>
<a name="ln5926">static void ex_join(exarg_T *eap)</a>
<a name="ln5927">{</a>
<a name="ln5928">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5929">  if (eap-&gt;line1 == eap-&gt;line2) {</a>
<a name="ln5930">    if (eap-&gt;addr_count &gt;= 2) {     // :2,2join does nothing</a>
<a name="ln5931">      return;</a>
<a name="ln5932">    }</a>
<a name="ln5933">    if (eap-&gt;line2 == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5934">      beep_flush();</a>
<a name="ln5935">      return;</a>
<a name="ln5936">    }</a>
<a name="ln5937">    eap-&gt;line2++;</a>
<a name="ln5938">  }</a>
<a name="ln5939">  do_join((size_t)((ssize_t)eap-&gt;line2 - eap-&gt;line1 + 1), !eap-&gt;forceit, true, true, true);</a>
<a name="ln5940">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5941">  ex_may_print(eap);</a>
<a name="ln5942">}</a>
<a name="ln5943"> </a>
<a name="ln5944">/// &quot;:[addr]@r&quot;: execute register</a>
<a name="ln5945">static void ex_at(exarg_T *eap)</a>
<a name="ln5946">{</a>
<a name="ln5947">  int prev_len = typebuf.tb_len;</a>
<a name="ln5948"> </a>
<a name="ln5949">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5950">  check_cursor_col();</a>
<a name="ln5951"> </a>
<a name="ln5952">  // Get the register name. No name means use the previous one.</a>
<a name="ln5953">  int c = (uint8_t)(*eap-&gt;arg);</a>
<a name="ln5954">  if (c == NUL) {</a>
<a name="ln5955">    c = '@';</a>
<a name="ln5956">  }</a>
<a name="ln5957"> </a>
<a name="ln5958">  // Put the register in the typeahead buffer with the &quot;silent&quot; flag.</a>
<a name="ln5959">  if (do_execreg(c, true, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, true) == FAIL) {</a>
<a name="ln5960">    beep_flush();</a>
<a name="ln5961">    return;</a>
<a name="ln5962">  }</a>
<a name="ln5963"> </a>
<a name="ln5964">  const bool save_efr = exec_from_reg;</a>
<a name="ln5965"> </a>
<a name="ln5966">  exec_from_reg = true;</a>
<a name="ln5967"> </a>
<a name="ln5968">  // Execute from the typeahead buffer.</a>
<a name="ln5969">  // Continue until the stuff buffer is empty and all added characters</a>
<a name="ln5970">  // have been consumed.</a>
<a name="ln5971">  while (!stuff_empty() || typebuf.tb_len &gt; prev_len) {</a>
<a name="ln5972">    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln5973">  }</a>
<a name="ln5974"> </a>
<a name="ln5975">  exec_from_reg = save_efr;</a>
<a name="ln5976">}</a>
<a name="ln5977"> </a>
<a name="ln5978">/// &quot;:!&quot;.</a>
<a name="ln5979">static void ex_bang(exarg_T *eap)</a>
<a name="ln5980">{</a>
<a name="ln5981">  do_bang(eap-&gt;addr_count, eap, eap-&gt;forceit, true, true);</a>
<a name="ln5982">}</a>
<a name="ln5983"> </a>
<a name="ln5984">/// &quot;:undo&quot;.</a>
<a name="ln5985">static void ex_undo(exarg_T *eap)</a>
<a name="ln5986">{</a>
<a name="ln5987">  if (eap-&gt;addr_count != 1) {</a>
<a name="ln5988">    if (eap-&gt;forceit) {</a>
<a name="ln5989">      u_undo_and_forget(1, true);   // :undo!</a>
<a name="ln5990">    } else {</a>
<a name="ln5991">      u_undo(1);                    // :undo</a>
<a name="ln5992">    }</a>
<a name="ln5993">    return;</a>
<a name="ln5994">  }</a>
<a name="ln5995"> </a>
<a name="ln5996">  linenr_T step = eap-&gt;line2;</a>
<a name="ln5997"> </a>
<a name="ln5998">  if (eap-&gt;forceit) {             // undo! 123</a>
<a name="ln5999">    // change number for &quot;undo!&quot; must be lesser than current change number</a>
<a name="ln6000">    if (step &gt;= curbuf-&gt;b_u_seq_cur) {</a>
<a name="ln6001">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln6002">      return;</a>
<a name="ln6003">    }</a>
<a name="ln6004">    // ensure that target change number is in same branch</a>
<a name="ln6005">    // while also counting the amount of undoes it'd take to reach target</a>
<a name="ln6006">    u_header_T *uhp;</a>
<a name="ln6007">    int count = 0;</a>
<a name="ln6008"> </a>
<a name="ln6009">    for (uhp = curbuf-&gt;b_u_curhead ? curbuf-&gt;b_u_curhead : curbuf-&gt;b_u_newhead;</a>
<a name="ln6010">         uhp != NULL &amp;&amp; uhp-&gt;uh_seq &gt; step;</a>
<a name="ln6011">         uhp = uhp-&gt;uh_next.ptr, ++count) {}</a>
<a name="ln6012">    if (step != 0 &amp;&amp; (uhp == NULL || uhp-&gt;uh_seq &lt; step)) {</a>
<a name="ln6013">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln6014">      return;</a>
<a name="ln6015">    }</a>
<a name="ln6016">    u_undo_and_forget(count, true);</a>
<a name="ln6017">  } else {                        // :undo 123</a>
<a name="ln6018">    undo_time(step, false, false, true);</a>
<a name="ln6019">  }</a>
<a name="ln6020">}</a>
<a name="ln6021"> </a>
<a name="ln6022">static void ex_wundo(exarg_T *eap)</a>
<a name="ln6023">{</a>
<a name="ln6024">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6025"> </a>
<a name="ln6026">  u_compute_hash(curbuf, hash);</a>
<a name="ln6027">  u_write_undo(eap-&gt;arg, eap-&gt;forceit, curbuf, hash);</a>
<a name="ln6028">}</a>
<a name="ln6029"> </a>
<a name="ln6030">static void ex_rundo(exarg_T *eap)</a>
<a name="ln6031">{</a>
<a name="ln6032">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6033"> </a>
<a name="ln6034">  u_compute_hash(curbuf, hash);</a>
<a name="ln6035">  u_read_undo(eap-&gt;arg, hash, NULL);</a>
<a name="ln6036">}</a>
<a name="ln6037"> </a>
<a name="ln6038">/// &quot;:redo&quot;.</a>
<a name="ln6039">static void ex_redo(exarg_T *eap)</a>
<a name="ln6040">{</a>
<a name="ln6041">  u_redo(1);</a>
<a name="ln6042">}</a>
<a name="ln6043"> </a>
<a name="ln6044">/// &quot;:earlier&quot; and &quot;:later&quot;.</a>
<a name="ln6045">static void ex_later(exarg_T *eap)</a>
<a name="ln6046">{</a>
<a name="ln6047">  long count = 0;</a>
<a name="ln6048">  bool sec = false;</a>
<a name="ln6049">  bool file = false;</a>
<a name="ln6050">  char *p = eap-&gt;arg;</a>
<a name="ln6051"> </a>
<a name="ln6052">  if (*p == NUL) {</a>
<a name="ln6053">    count = 1;</a>
<a name="ln6054">  } else if (isdigit((uint8_t)(*p))) {</a>
<a name="ln6055">    count = getdigits_long(&amp;p, false, 0);</a>
<a name="ln6056">    switch (*p) {</a>
<a name="ln6057">    case 's':</a>
<a name="ln6058">      p++; sec = true; break;</a>
<a name="ln6059">    case 'm':</a>
<a name="ln6060">      p++; sec = true; count *= 60; break;</a>
<a name="ln6061">    case 'h':</a>
<a name="ln6062">      p++; sec = true; count *= 60 * 60; break;</a>
<a name="ln6063">    case 'd':</a>
<a name="ln6064">      p++; sec = true; count *= 24 * 60 * 60; break;</a>
<a name="ln6065">    case 'f':</a>
<a name="ln6066">      p++; file = true; break;</a>
<a name="ln6067">    }</a>
<a name="ln6068">  }</a>
<a name="ln6069"> </a>
<a name="ln6070">  if (*p != NUL) {</a>
<a name="ln6071">    semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6072">  } else {</a>
<a name="ln6073">    undo_time(eap-&gt;cmdidx == CMD_earlier ? -count : count,</a>
<a name="ln6074">              sec, file, false);</a>
<a name="ln6075">  }</a>
<a name="ln6076">}</a>
<a name="ln6077"> </a>
<a name="ln6078">/// &quot;:redir&quot;: start/stop redirection.</a>
<a name="ln6079">static void ex_redir(exarg_T *eap)</a>
<a name="ln6080">{</a>
<a name="ln6081">  char *arg = eap-&gt;arg;</a>
<a name="ln6082"> </a>
<a name="ln6083">  if (STRICMP(eap-&gt;arg, &quot;END&quot;) == 0) {</a>
<a name="ln6084">    close_redir();</a>
<a name="ln6085">  } else {</a>
<a name="ln6086">    if (*arg == '&gt;') {</a>
<a name="ln6087">      arg++;</a>
<a name="ln6088">      char *mode;</a>
<a name="ln6089">      if (*arg == '&gt;') {</a>
<a name="ln6090">        arg++;</a>
<a name="ln6091">        mode = &quot;a&quot;;</a>
<a name="ln6092">      } else {</a>
<a name="ln6093">        mode = &quot;w&quot;;</a>
<a name="ln6094">      }</a>
<a name="ln6095">      arg = skipwhite(arg);</a>
<a name="ln6096"> </a>
<a name="ln6097">      close_redir();</a>
<a name="ln6098"> </a>
<a name="ln6099">      // Expand environment variables and &quot;~/&quot;.</a>
<a name="ln6100">      char *fname = expand_env_save(arg);</a>
<a name="ln6101">      if (fname == NULL) {</a>
<a name="ln6102">        return;</a>
<a name="ln6103">      }</a>
<a name="ln6104"> </a>
<a name="ln6105">      redir_fd = open_exfile(fname, eap-&gt;forceit, mode);</a>
<a name="ln6106">      xfree(fname);</a>
<a name="ln6107">    } else if (*arg == '@') {</a>
<a name="ln6108">      // redirect to a register a-z (resp. A-Z for appending)</a>
<a name="ln6109">      close_redir();</a>
<a name="ln6110">      arg++;</a>
<a name="ln6111">      if (valid_yank_reg(*arg, true) &amp;&amp; *arg != '_') {</a>
<a name="ln6112">        redir_reg = (uint8_t)(*arg++);</a>
<a name="ln6113">        if (*arg == '&gt;' &amp;&amp; arg[1] == '&gt;') {        // append</a>
<a name="ln6114">          arg += 2;</a>
<a name="ln6115">        } else {</a>
<a name="ln6116">          // Can use both &quot;@a&quot; and &quot;@a&gt;&quot;.</a>
<a name="ln6117">          if (*arg == '&gt;') {</a>
<a name="ln6118">            arg++;</a>
<a name="ln6119">          }</a>
<a name="ln6120">          // Make register empty when not using @A-@Z and the</a>
<a name="ln6121">          // command is valid.</a>
<a name="ln6122">          if (*arg == NUL &amp;&amp; !isupper(redir_reg)) {</a>
<a name="ln6123">            write_reg_contents(redir_reg, &quot;&quot;, 0, false);</a>
<a name="ln6124">          }</a>
<a name="ln6125">        }</a>
<a name="ln6126">      }</a>
<a name="ln6127">      if (*arg != NUL) {</a>
<a name="ln6128">        redir_reg = 0;</a>
<a name="ln6129">        semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6130">      }</a>
<a name="ln6131">    } else if (*arg == '=' &amp;&amp; arg[1] == '&gt;') {</a>
<a name="ln6132">      int append;</a>
<a name="ln6133"> </a>
<a name="ln6134">      // redirect to a variable</a>
<a name="ln6135">      close_redir();</a>
<a name="ln6136">      arg += 2;</a>
<a name="ln6137"> </a>
<a name="ln6138">      if (*arg == '&gt;') {</a>
<a name="ln6139">        arg++;</a>
<a name="ln6140">        append = true;</a>
<a name="ln6141">      } else {</a>
<a name="ln6142">        append = false;</a>
<a name="ln6143">      }</a>
<a name="ln6144"> </a>
<a name="ln6145">      if (var_redir_start(skipwhite(arg), append) == OK) {</a>
<a name="ln6146">        redir_vname = 1;</a>
<a name="ln6147">      }</a>
<a name="ln6148">    } else {  // TODO(vim): redirect to a buffer</a>
<a name="ln6149">      semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6150">    }</a>
<a name="ln6151">  }</a>
<a name="ln6152"> </a>
<a name="ln6153">  // Make sure redirection is not off.  Can happen for cmdline completion</a>
<a name="ln6154">  // that indirectly invokes a command to catch its output.</a>
<a name="ln6155">  if (redir_fd != NULL</a>
<a name="ln6156">      || redir_reg || redir_vname) {</a>
<a name="ln6157">    redir_off = false;</a>
<a name="ln6158">  }</a>
<a name="ln6159">}</a>
<a name="ln6160"> </a>
<a name="ln6161">/// &quot;:redraw&quot;: force redraw</a>
<a name="ln6162">static void ex_redraw(exarg_T *eap)</a>
<a name="ln6163">{</a>
<a name="ln6164">  if (cmdpreview) {</a>
<a name="ln6165">    return;  // Ignore :redraw during 'inccommand' preview. #9777</a>
<a name="ln6166">  }</a>
<a name="ln6167">  int r = RedrawingDisabled;</a>
<a name="ln6168">  int p = p_lz;</a>
<a name="ln6169"> </a>
<a name="ln6170">  RedrawingDisabled = 0;</a>
<a name="ln6171">  p_lz = false;</a>
<a name="ln6172">  validate_cursor();</a>
<a name="ln6173">  update_topline(curwin);</a>
<a name="ln6174">  if (eap-&gt;forceit) {</a>
<a name="ln6175">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln6176">    redraw_cmdline = true;</a>
<a name="ln6177">  } else if (VIsual_active) {</a>
<a name="ln6178">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6179">  }</a>
<a name="ln6180">  update_screen();</a>
<a name="ln6181">  if (need_maketitle) {</a>
<a name="ln6182">    maketitle();</a>
<a name="ln6183">  }</a>
<a name="ln6184">  RedrawingDisabled = r;</a>
<a name="ln6185">  p_lz = p;</a>
<a name="ln6186"> </a>
<a name="ln6187">  // Reset msg_didout, so that a message that's there is overwritten.</a>
<a name="ln6188">  msg_didout = false;</a>
<a name="ln6189">  msg_col = 0;</a>
<a name="ln6190"> </a>
<a name="ln6191">  // No need to wait after an intentional redraw.</a>
<a name="ln6192">  need_wait_return = false;</a>
<a name="ln6193"> </a>
<a name="ln6194">  ui_flush();</a>
<a name="ln6195">}</a>
<a name="ln6196"> </a>
<a name="ln6197">/// &quot;:redrawstatus&quot;: force redraw of status line(s) and window bar(s)</a>
<a name="ln6198">static void ex_redrawstatus(exarg_T *eap)</a>
<a name="ln6199">{</a>
<a name="ln6200">  if (cmdpreview) {</a>
<a name="ln6201">    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777</a>
<a name="ln6202">  }</a>
<a name="ln6203">  int r = RedrawingDisabled;</a>
<a name="ln6204">  int p = p_lz;</a>
<a name="ln6205"> </a>
<a name="ln6206">  if (eap-&gt;forceit) {</a>
<a name="ln6207">    status_redraw_all();</a>
<a name="ln6208">  } else {</a>
<a name="ln6209">    status_redraw_curbuf();</a>
<a name="ln6210">  }</a>
<a name="ln6211"> </a>
<a name="ln6212">  RedrawingDisabled = 0;</a>
<a name="ln6213">  p_lz = false;</a>
<a name="ln6214">  if (State &amp; MODE_CMDLINE) {</a>
<a name="ln6215">    redraw_statuslines();</a>
<a name="ln6216">  } else {</a>
<a name="ln6217">    if (VIsual_active) {</a>
<a name="ln6218">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6219">    }</a>
<a name="ln6220">    update_screen();</a>
<a name="ln6221">  }</a>
<a name="ln6222">  RedrawingDisabled = r;</a>
<a name="ln6223">  p_lz = p;</a>
<a name="ln6224">  ui_flush();</a>
<a name="ln6225">}</a>
<a name="ln6226"> </a>
<a name="ln6227">/// &quot;:redrawtabline&quot;: force redraw of the tabline</a>
<a name="ln6228">static void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)</a>
<a name="ln6229">{</a>
<a name="ln6230">  const int r = RedrawingDisabled;</a>
<a name="ln6231">  const int p = p_lz;</a>
<a name="ln6232"> </a>
<a name="ln6233">  RedrawingDisabled = 0;</a>
<a name="ln6234">  p_lz = false;</a>
<a name="ln6235"> </a>
<a name="ln6236">  draw_tabline();</a>
<a name="ln6237"> </a>
<a name="ln6238">  RedrawingDisabled = r;</a>
<a name="ln6239">  p_lz = p;</a>
<a name="ln6240">  ui_flush();</a>
<a name="ln6241">}</a>
<a name="ln6242"> </a>
<a name="ln6243">static void close_redir(void)</a>
<a name="ln6244">{</a>
<a name="ln6245">  if (redir_fd != NULL) {</a>
<a name="ln6246">    fclose(redir_fd);</a>
<a name="ln6247">    redir_fd = NULL;</a>
<a name="ln6248">  }</a>
<a name="ln6249">  redir_reg = 0;</a>
<a name="ln6250">  if (redir_vname) {</a>
<a name="ln6251">    var_redir_stop();</a>
<a name="ln6252">    redir_vname = 0;</a>
<a name="ln6253">  }</a>
<a name="ln6254">}</a>
<a name="ln6255"> </a>
<a name="ln6256">/// Try creating a directory, give error message on failure</a>
<a name="ln6257">///</a>
<a name="ln6258">/// @param[in]  name  Directory to create.</a>
<a name="ln6259">/// @param[in]  prot  Directory permissions.</a>
<a name="ln6260">///</a>
<a name="ln6261">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln6262">int vim_mkdir_emsg(const char *const name, const int prot)</a>
<a name="ln6263">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6264">{</a>
<a name="ln6265">  int ret;</a>
<a name="ln6266">  if ((ret = os_mkdir(name, prot)) != 0) {</a>
<a name="ln6267">    semsg(_(e_mkdir), name, os_strerror(ret));</a>
<a name="ln6268">    return FAIL;</a>
<a name="ln6269">  }</a>
<a name="ln6270">  return OK;</a>
<a name="ln6271">}</a>
<a name="ln6272"> </a>
<a name="ln6273">/// Open a file for writing for an Ex command, with some checks.</a>
<a name="ln6274">///</a>
<a name="ln6275">/// @param mode  &quot;w&quot; for create new file or &quot;a&quot; for append</a>
<a name="ln6276">///</a>
<a name="ln6277">/// @return  file descriptor, or NULL on failure.</a>
<a name="ln6278">FILE *open_exfile(char *fname, int forceit, char *mode)</a>
<a name="ln6279">{</a>
<a name="ln6280">#ifdef UNIX</a>
<a name="ln6281">  // with Unix it is possible to open a directory</a>
<a name="ln6282">  if (os_isdir(fname)) {</a>
<a name="ln6283">    semsg(_(e_isadir2), fname);</a>
<a name="ln6284">    return NULL;</a>
<a name="ln6285">  }</a>
<a name="ln6286">#endif</a>
<a name="ln6287">  if (!forceit &amp;&amp; *mode != 'a' &amp;&amp; os_path_exists(fname)) {</a>
<a name="ln6288">    semsg(_(&quot;E189: \&quot;%s\&quot; exists (add ! to override)&quot;), fname);</a>
<a name="ln6289">    return NULL;</a>
<a name="ln6290">  }</a>
<a name="ln6291"> </a>
<a name="ln6292">  FILE *fd;</a>
<a name="ln6293">  if ((fd = os_fopen(fname, mode)) == NULL) {</a>
<a name="ln6294">    semsg(_(&quot;E190: Cannot open \&quot;%s\&quot; for writing&quot;), fname);</a>
<a name="ln6295">  }</a>
<a name="ln6296"> </a>
<a name="ln6297">  return fd;</a>
<a name="ln6298">}</a>
<a name="ln6299"> </a>
<a name="ln6300">/// &quot;:mark&quot; and &quot;:k&quot;.</a>
<a name="ln6301">static void ex_mark(exarg_T *eap)</a>
<a name="ln6302">{</a>
<a name="ln6303">  if (*eap-&gt;arg == NUL) {               // No argument?</a>
<a name="ln6304">    emsg(_(e_argreq));</a>
<a name="ln6305">    return;</a>
<a name="ln6306">  }</a>
<a name="ln6307"> </a>
<a name="ln6308">  if (eap-&gt;arg[1] != NUL) {         // more than one character?</a>
<a name="ln6309">    semsg(_(e_trailing_arg), eap-&gt;arg);</a>
<a name="ln6310">    return;</a>
<a name="ln6311">  }</a>
<a name="ln6312"> </a>
<a name="ln6313">  pos_T pos = curwin-&gt;w_cursor;             // save curwin-&gt;w_cursor</a>
<a name="ln6314">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln6315">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln6316">  if (setmark(*eap-&gt;arg) == FAIL) {   // set mark</a>
<a name="ln6317">    emsg(_(&quot;E191: Argument must be a letter or forward/backward quote&quot;));</a>
<a name="ln6318">  }</a>
<a name="ln6319">  curwin-&gt;w_cursor = pos;             // restore curwin-&gt;w_cursor</a>
<a name="ln6320">}</a>
<a name="ln6321"> </a>
<a name="ln6322">/// Update w_topline, w_leftcol and the cursor position.</a>
<a name="ln6323">void update_topline_cursor(void)</a>
<a name="ln6324">{</a>
<a name="ln6325">  check_cursor();               // put cursor on valid line</a>
<a name="ln6326">  update_topline(curwin);</a>
<a name="ln6327">  if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln6328">    validate_cursor();</a>
<a name="ln6329">  }</a>
<a name="ln6330">  update_curswant();</a>
<a name="ln6331">}</a>
<a name="ln6332"> </a>
<a name="ln6333">/// Save the current State and go to Normal mode.</a>
<a name="ln6334">///</a>
<a name="ln6335">/// @return  true if the typeahead could be saved.</a>
<a name="ln6336">bool save_current_state(save_state_T *sst)</a>
<a name="ln6337">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6338">{</a>
<a name="ln6339">  sst-&gt;save_msg_scroll = msg_scroll;</a>
<a name="ln6340">  sst-&gt;save_restart_edit = restart_edit;</a>
<a name="ln6341">  sst-&gt;save_msg_didout = msg_didout;</a>
<a name="ln6342">  sst-&gt;save_State = State;</a>
<a name="ln6343">  sst-&gt;save_finish_op = finish_op;</a>
<a name="ln6344">  sst-&gt;save_opcount = opcount;</a>
<a name="ln6345">  sst-&gt;save_reg_executing = reg_executing;</a>
<a name="ln6346">  sst-&gt;save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln6347"> </a>
<a name="ln6348">  msg_scroll = false;   // no msg scrolling in Normal mode</a>
<a name="ln6349">  restart_edit = 0;     // don't go to Insert mode</a>
<a name="ln6350"> </a>
<a name="ln6351">  // Save the current typeahead.  This is required to allow using &quot;:normal&quot;</a>
<a name="ln6352">  // from an event handler and makes sure we don't hang when the argument</a>
<a name="ln6353">  // ends with half a command.</a>
<a name="ln6354">  save_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6355">  return sst-&gt;tabuf.typebuf_valid;</a>
<a name="ln6356">}</a>
<a name="ln6357"> </a>
<a name="ln6358">void restore_current_state(save_state_T *sst)</a>
<a name="ln6359">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6360">{</a>
<a name="ln6361">  // Restore the previous typeahead.</a>
<a name="ln6362">  restore_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6363"> </a>
<a name="ln6364">  msg_scroll = sst-&gt;save_msg_scroll;</a>
<a name="ln6365">  if (force_restart_edit) {</a>
<a name="ln6366">    force_restart_edit = false;</a>
<a name="ln6367">  } else {</a>
<a name="ln6368">    // Some function (terminal_enter()) was aware of ex_normal and decided to</a>
<a name="ln6369">    // override the value of restart_edit anyway.</a>
<a name="ln6370">    restart_edit = sst-&gt;save_restart_edit;</a>
<a name="ln6371">  }</a>
<a name="ln6372">  finish_op = sst-&gt;save_finish_op;</a>
<a name="ln6373">  opcount = sst-&gt;save_opcount;</a>
<a name="ln6374">  reg_executing = sst-&gt;save_reg_executing;</a>
<a name="ln6375">  pending_end_reg_executing = sst-&gt;save_pending_end_reg_executing;</a>
<a name="ln6376"> </a>
<a name="ln6377">  // don't reset msg_didout now</a>
<a name="ln6378">  msg_didout |= sst-&gt;save_msg_didout;</a>
<a name="ln6379"> </a>
<a name="ln6380">  // Restore the state (needed when called from a function executed for</a>
<a name="ln6381">  // 'indentexpr'). Update the mouse and cursor, they may have changed.</a>
<a name="ln6382">  State = sst-&gt;save_State;</a>
<a name="ln6383">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6384">}</a>
<a name="ln6385"> </a>
<a name="ln6386">bool expr_map_locked(void)</a>
<a name="ln6387">{</a>
<a name="ln6388">  return expr_map_lock &gt; 0 &amp;&amp; !(curbuf-&gt;b_flags &amp; BF_DUMMY);</a>
<a name="ln6389">}</a>
<a name="ln6390"> </a>
<a name="ln6391">/// &quot;:normal[!] {commands}&quot;: Execute normal mode commands.</a>
<a name="ln6392">static void ex_normal(exarg_T *eap)</a>
<a name="ln6393">{</a>
<a name="ln6394">  if (curbuf-&gt;terminal &amp;&amp; State &amp; MODE_TERMINAL) {</a>
<a name="ln6395">    emsg(&quot;Can't re-enter normal mode from terminal mode&quot;);</a>
<a name="ln6396">    return;</a>
<a name="ln6397">  }</a>
<a name="ln6398">  char *arg = NULL;</a>
<a name="ln6399"> </a>
<a name="ln6400">  if (expr_map_locked()) {</a>
<a name="ln6401">    emsg(_(e_secure));</a>
<a name="ln6402">    return;</a>
<a name="ln6403">  }</a>
<a name="ln6404"> </a>
<a name="ln6405">  if (ex_normal_busy &gt;= p_mmd) {</a>
<a name="ln6406">    emsg(_(&quot;E192: Recursive use of :normal too deep&quot;));</a>
<a name="ln6407">    return;</a>
<a name="ln6408">  }</a>
<a name="ln6409"> </a>
<a name="ln6410">  // vgetc() expects K_SPECIAL to have been escaped.  Don't do</a>
<a name="ln6411">  // this for the K_SPECIAL leading byte, otherwise special keys will not</a>
<a name="ln6412">  // work.</a>
<a name="ln6413">  {</a>
<a name="ln6414">    int len = 0;</a>
<a name="ln6415"> </a>
<a name="ln6416">    // Count the number of characters to be escaped.</a>
<a name="ln6417">    int l;</a>
<a name="ln6418">    char *p;</a>
<a name="ln6419">    for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6420">      for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6421">        if (*++p == (char)K_SPECIAL) {  // trailbyte K_SPECIAL</a>
<a name="ln6422">          len += 2;</a>
<a name="ln6423">        }</a>
<a name="ln6424">      }</a>
<a name="ln6425">    }</a>
<a name="ln6426">    if (len &gt; 0) {</a>
<a name="ln6427">      arg = xmalloc(strlen(eap-&gt;arg) + (size_t)len + 1);</a>
<a name="ln6428">      len = 0;</a>
<a name="ln6429">      for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6430">        arg[len++] = *p;</a>
<a name="ln6431">        for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6432">          arg[len++] = *++p;</a>
<a name="ln6433">          if (*p == (char)K_SPECIAL) {</a>
<a name="ln6434">            arg[len++] = (char)KS_SPECIAL;</a>
<a name="ln6435">            arg[len++] = KE_FILLER;</a>
<a name="ln6436">          }</a>
<a name="ln6437">        }</a>
<a name="ln6438">        arg[len] = NUL;</a>
<a name="ln6439">      }</a>
<a name="ln6440">    }</a>
<a name="ln6441">  }</a>
<a name="ln6442"> </a>
<a name="ln6443">  ex_normal_busy++;</a>
<a name="ln6444">  save_state_T save_state;</a>
<a name="ln6445">  if (save_current_state(&amp;save_state)) {</a>
<a name="ln6446">    // Repeat the :normal command for each line in the range.  When no</a>
<a name="ln6447">    // range given, execute it just once, without positioning the cursor</a>
<a name="ln6448">    // first.</a>
<a name="ln6449">    do {</a>
<a name="ln6450">      if (eap-&gt;addr_count != 0) {</a>
<a name="ln6451">        curwin-&gt;w_cursor.lnum = eap-&gt;line1++;</a>
<a name="ln6452">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln6453">        check_cursor_moved(curwin);</a>
<a name="ln6454">      }</a>
<a name="ln6455"> </a>
<a name="ln6456">      exec_normal_cmd((arg != NULL ? arg : eap-&gt;arg),</a>
<a name="ln6457">                      eap-&gt;forceit ? REMAP_NONE : REMAP_YES, false);</a>
<a name="ln6458">    } while (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line1 &lt;= eap-&gt;line2 &amp;&amp; !got_int);</a>
<a name="ln6459">  }</a>
<a name="ln6460"> </a>
<a name="ln6461">  // Might not return to the main loop when in an event handler.</a>
<a name="ln6462">  update_topline_cursor();</a>
<a name="ln6463"> </a>
<a name="ln6464">  restore_current_state(&amp;save_state);</a>
<a name="ln6465"> </a>
<a name="ln6466">  ex_normal_busy--;</a>
<a name="ln6467"> </a>
<a name="ln6468">  setmouse();</a>
<a name="ln6469">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6470">  xfree(arg);</a>
<a name="ln6471">}</a>
<a name="ln6472"> </a>
<a name="ln6473">/// &quot;:startinsert&quot;, &quot;:startreplace&quot; and &quot;:startgreplace&quot;</a>
<a name="ln6474">static void ex_startinsert(exarg_T *eap)</a>
<a name="ln6475">{</a>
<a name="ln6476">  if (eap-&gt;forceit) {</a>
<a name="ln6477">    // cursor line can be zero on startup</a>
<a name="ln6478">    if (!curwin-&gt;w_cursor.lnum) {</a>
<a name="ln6479">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln6480">    }</a>
<a name="ln6481">    set_cursor_for_append_to_line();</a>
<a name="ln6482">  }</a>
<a name="ln6483"> </a>
<a name="ln6484">  // Ignore the command when already in Insert mode.  Inserting an</a>
<a name="ln6485">  // expression register that invokes a function can do this.</a>
<a name="ln6486">  if (State &amp; MODE_INSERT) {</a>
<a name="ln6487">    return;</a>
<a name="ln6488">  }</a>
<a name="ln6489"> </a>
<a name="ln6490">  if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6491">    restart_edit = 'a';</a>
<a name="ln6492">  } else if (eap-&gt;cmdidx == CMD_startreplace) {</a>
<a name="ln6493">    restart_edit = 'R';</a>
<a name="ln6494">  } else {</a>
<a name="ln6495">    restart_edit = 'V';</a>
<a name="ln6496">  }</a>
<a name="ln6497"> </a>
<a name="ln6498">  if (!eap-&gt;forceit) {</a>
<a name="ln6499">    if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6500">      restart_edit = 'i';</a>
<a name="ln6501">    }</a>
<a name="ln6502">    curwin-&gt;w_curswant = 0;  // avoid MAXCOL</a>
<a name="ln6503">  }</a>
<a name="ln6504"> </a>
<a name="ln6505">  if (VIsual_active) {</a>
<a name="ln6506">    showmode();</a>
<a name="ln6507">  }</a>
<a name="ln6508">}</a>
<a name="ln6509"> </a>
<a name="ln6510">/// &quot;:stopinsert&quot;</a>
<a name="ln6511">static void ex_stopinsert(exarg_T *eap)</a>
<a name="ln6512">{</a>
<a name="ln6513">  restart_edit = 0;</a>
<a name="ln6514">  stop_insert_mode = true;</a>
<a name="ln6515">  clearmode();</a>
<a name="ln6516">}</a>
<a name="ln6517"> </a>
<a name="ln6518">/// Execute normal mode command &quot;cmd&quot;.</a>
<a name="ln6519">/// &quot;remap&quot; can be REMAP_NONE or REMAP_YES.</a>
<a name="ln6520">void exec_normal_cmd(char *cmd, int remap, bool silent)</a>
<a name="ln6521">{</a>
<a name="ln6522">  // Stuff the argument into the typeahead buffer.</a>
<a name="ln6523">  ins_typebuf(cmd, remap, 0, true, silent);</a>
<a name="ln6524">  exec_normal(false);</a>
<a name="ln6525">}</a>
<a name="ln6526"> </a>
<a name="ln6527">/// Execute normal_cmd() until there is no typeahead left.</a>
<a name="ln6528">///</a>
<a name="ln6529">/// @param was_typed whether or not something was typed</a>
<a name="ln6530">void exec_normal(bool was_typed)</a>
<a name="ln6531">{</a>
<a name="ln6532">  oparg_T oa;</a>
<a name="ln6533"> </a>
<a name="ln6534">  clear_oparg(&amp;oa);</a>
<a name="ln6535">  finish_op = false;</a>
<a name="ln6536">  while ((!stuff_empty()</a>
<a name="ln6537">          || ((was_typed || !typebuf_typed())</a>
<a name="ln6538">              &amp;&amp; typebuf.tb_len &gt; 0))</a>
<a name="ln6539">         &amp;&amp; !got_int) {</a>
<a name="ln6540">    update_topline_cursor();</a>
<a name="ln6541">    normal_cmd(&amp;oa, true);      // execute a Normal mode cmd</a>
<a name="ln6542">  }</a>
<a name="ln6543">}</a>
<a name="ln6544"> </a>
<a name="ln6545">static void ex_checkpath(exarg_T *eap)</a>
<a name="ln6546">{</a>
<a name="ln6547">  find_pattern_in_path(NULL, 0, 0, false, false, CHECK_PATH, 1L,</a>
<a name="ln6548">                       eap-&gt;forceit ? ACTION_SHOW_ALL : ACTION_SHOW,</a>
<a name="ln6549">                       (linenr_T)1, (linenr_T)MAXLNUM);</a>
<a name="ln6550">}</a>
<a name="ln6551"> </a>
<a name="ln6552">/// &quot;:psearch&quot;</a>
<a name="ln6553">static void ex_psearch(exarg_T *eap)</a>
<a name="ln6554">{</a>
<a name="ln6555">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6556">  ex_findpat(eap);</a>
<a name="ln6557">  g_do_tagpreview = 0;</a>
<a name="ln6558">}</a>
<a name="ln6559"> </a>
<a name="ln6560">static void ex_findpat(exarg_T *eap)</a>
<a name="ln6561">{</a>
<a name="ln6562">  bool whole = true;</a>
<a name="ln6563">  int action;</a>
<a name="ln6564"> </a>
<a name="ln6565">  switch (cmdnames[eap-&gt;cmdidx].cmd_name[2]) {</a>
<a name="ln6566">  case 'e':             // &quot;:psearch&quot;, &quot;:isearch&quot; and &quot;:dsearch&quot;</a>
<a name="ln6567">    if (cmdnames[eap-&gt;cmdidx].cmd_name[0] == 'p') {</a>
<a name="ln6568">      action = ACTION_GOTO;</a>
<a name="ln6569">    } else {</a>
<a name="ln6570">      action = ACTION_SHOW;</a>
<a name="ln6571">    }</a>
<a name="ln6572">    break;</a>
<a name="ln6573">  case 'i':             // &quot;:ilist&quot; and &quot;:dlist&quot;</a>
<a name="ln6574">    action = ACTION_SHOW_ALL;</a>
<a name="ln6575">    break;</a>
<a name="ln6576">  case 'u':             // &quot;:ijump&quot; and &quot;:djump&quot;</a>
<a name="ln6577">    action = ACTION_GOTO;</a>
<a name="ln6578">    break;</a>
<a name="ln6579">  default:              // &quot;:isplit&quot; and &quot;:dsplit&quot;</a>
<a name="ln6580">    action = ACTION_SPLIT;</a>
<a name="ln6581">    break;</a>
<a name="ln6582">  }</a>
<a name="ln6583"> </a>
<a name="ln6584">  int n = 1;</a>
<a name="ln6585">  if (ascii_isdigit(*eap-&gt;arg)) {  // get count</a>
<a name="ln6586">    n = getdigits_int(&amp;eap-&gt;arg, false, 0);</a>
<a name="ln6587">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln6588">  }</a>
<a name="ln6589">  if (*eap-&gt;arg == '/') {   // Match regexp, not just whole words</a>
<a name="ln6590">    whole = false;</a>
<a name="ln6591">    eap-&gt;arg++;</a>
<a name="ln6592">    char *p = skip_regexp(eap-&gt;arg, '/', magic_isset());</a>
<a name="ln6593">    if (*p) {</a>
<a name="ln6594">      *p++ = NUL;</a>
<a name="ln6595">      p = skipwhite(p);</a>
<a name="ln6596"> </a>
<a name="ln6597">      // Check for trailing illegal characters.</a>
<a name="ln6598">      if (!ends_excmd(*p)) {</a>
<a name="ln6599">        eap-&gt;errmsg = ex_errmsg(e_trailing_arg, p);</a>
<a name="ln6600">      } else {</a>
<a name="ln6601">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln6602">      }</a>
<a name="ln6603">    }</a>
<a name="ln6604">  }</a>
<a name="ln6605">  if (!eap-&gt;skip) {</a>
<a name="ln6606">    find_pattern_in_path(eap-&gt;arg, 0, strlen(eap-&gt;arg), whole, !eap-&gt;forceit,</a>
<a name="ln6607">                         *eap-&gt;cmd == 'd' ? FIND_DEFINE : FIND_ANY,</a>
<a name="ln6608">                         n, action, eap-&gt;line1, eap-&gt;line2);</a>
<a name="ln6609">  }</a>
<a name="ln6610">}</a>
<a name="ln6611"> </a>
<a name="ln6612">/// &quot;:ptag&quot;, &quot;:ptselect&quot;, &quot;:ptjump&quot;, &quot;:ptnext&quot;, etc.</a>
<a name="ln6613">static void ex_ptag(exarg_T *eap)</a>
<a name="ln6614">{</a>
<a name="ln6615">  g_do_tagpreview = (int)p_pvh;    // will be reset to 0 in ex_tag_cmd()</a>
<a name="ln6616">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6617">}</a>
<a name="ln6618"> </a>
<a name="ln6619">/// &quot;:pedit&quot;</a>
<a name="ln6620">static void ex_pedit(exarg_T *eap)</a>
<a name="ln6621">{</a>
<a name="ln6622">  win_T *curwin_save = curwin;</a>
<a name="ln6623"> </a>
<a name="ln6624">  // Open the preview window or popup and make it the current window.</a>
<a name="ln6625">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6626">  prepare_tagpreview(true);</a>
<a name="ln6627"> </a>
<a name="ln6628">  // Edit the file.</a>
<a name="ln6629">  do_exedit(eap, NULL);</a>
<a name="ln6630"> </a>
<a name="ln6631">  if (curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln6632">    // Return cursor to where we were</a>
<a name="ln6633">    validate_cursor();</a>
<a name="ln6634">    redraw_later(curwin, UPD_VALID);</a>
<a name="ln6635">    win_enter(curwin_save, true);</a>
<a name="ln6636">  }</a>
<a name="ln6637">  g_do_tagpreview = 0;</a>
<a name="ln6638">}</a>
<a name="ln6639"> </a>
<a name="ln6640">/// &quot;:stag&quot;, &quot;:stselect&quot; and &quot;:stjump&quot;.</a>
<a name="ln6641">static void ex_stag(exarg_T *eap)</a>
<a name="ln6642">{</a>
<a name="ln6643">  postponed_split = -1;</a>
<a name="ln6644">  postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln6645">  postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln6646">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6647">  postponed_split_flags = 0;</a>
<a name="ln6648">  postponed_split_tab = 0;</a>
<a name="ln6649">}</a>
<a name="ln6650"> </a>
<a name="ln6651">/// &quot;:tag&quot;, &quot;:tselect&quot;, &quot;:tjump&quot;, &quot;:tnext&quot;, etc.</a>
<a name="ln6652">static void ex_tag(exarg_T *eap)</a>
<a name="ln6653">{</a>
<a name="ln6654">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name);</a>
<a name="ln6655">}</a>
<a name="ln6656"> </a>
<a name="ln6657">static void ex_tag_cmd(exarg_T *eap, const char *name)</a>
<a name="ln6658">{</a>
<a name="ln6659">  int cmd;</a>
<a name="ln6660"> </a>
<a name="ln6661">  switch (name[1]) {</a>
<a name="ln6662">  case 'j':</a>
<a name="ln6663">    cmd = DT_JUMP;              // &quot;:tjump&quot;</a>
<a name="ln6664">    break;</a>
<a name="ln6665">  case 's':</a>
<a name="ln6666">    cmd = DT_SELECT;            // &quot;:tselect&quot;</a>
<a name="ln6667">    break;</a>
<a name="ln6668">  case 'p':                             // &quot;:tprevious&quot;</a>
<a name="ln6669">  case 'N':</a>
<a name="ln6670">    cmd = DT_PREV;              // &quot;:tNext&quot;</a>
<a name="ln6671">    break;</a>
<a name="ln6672">  case 'n':</a>
<a name="ln6673">    cmd = DT_NEXT;              // &quot;:tnext&quot;</a>
<a name="ln6674">    break;</a>
<a name="ln6675">  case 'o':</a>
<a name="ln6676">    cmd = DT_POP;               // &quot;:pop&quot;</a>
<a name="ln6677">    break;</a>
<a name="ln6678">  case 'f':                             // &quot;:tfirst&quot;</a>
<a name="ln6679">  case 'r':</a>
<a name="ln6680">    cmd = DT_FIRST;             // &quot;:trewind&quot;</a>
<a name="ln6681">    break;</a>
<a name="ln6682">  case 'l':</a>
<a name="ln6683">    cmd = DT_LAST;              // &quot;:tlast&quot;</a>
<a name="ln6684">    break;</a>
<a name="ln6685">  default:                              // &quot;:tag&quot;</a>
<a name="ln6686">    cmd = DT_TAG;</a>
<a name="ln6687">    break;</a>
<a name="ln6688">  }</a>
<a name="ln6689"> </a>
<a name="ln6690">  if (name[0] == 'l') {</a>
<a name="ln6691">    cmd = DT_LTAG;</a>
<a name="ln6692">  }</a>
<a name="ln6693"> </a>
<a name="ln6694">  do_tag(eap-&gt;arg, cmd, eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 1,</a>
<a name="ln6695">         eap-&gt;forceit, true);</a>
<a name="ln6696">}</a>
<a name="ln6697"> </a>
<a name="ln6698">enum {</a>
<a name="ln6699">  SPEC_PERC = 0,</a>
<a name="ln6700">  SPEC_HASH,</a>
<a name="ln6701">  SPEC_CWORD,</a>
<a name="ln6702">  SPEC_CCWORD,</a>
<a name="ln6703">  SPEC_CEXPR,</a>
<a name="ln6704">  SPEC_CFILE,</a>
<a name="ln6705">  SPEC_SFILE,</a>
<a name="ln6706">  SPEC_SLNUM,</a>
<a name="ln6707">  SPEC_STACK,</a>
<a name="ln6708">  SPEC_SCRIPT,</a>
<a name="ln6709">  SPEC_AFILE,</a>
<a name="ln6710">  SPEC_ABUF,</a>
<a name="ln6711">  SPEC_AMATCH,</a>
<a name="ln6712">  SPEC_SFLNUM,</a>
<a name="ln6713">  SPEC_SID,</a>
<a name="ln6714">  // SPEC_CLIENT,</a>
<a name="ln6715">};</a>
<a name="ln6716"> </a>
<a name="ln6717">/// Check &quot;str&quot; for starting with a special cmdline variable.</a>
<a name="ln6718">/// If found return one of the SPEC_ values and set &quot;*usedlen&quot; to the length of</a>
<a name="ln6719">/// the variable.  Otherwise return -1 and &quot;*usedlen&quot; is unchanged.</a>
<a name="ln6720">ssize_t find_cmdline_var(const char *src, size_t *usedlen)</a>
<a name="ln6721">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6722">{</a>
<a name="ln6723">  static char *(spec_str[]) = {</a>
<a name="ln6724">    [SPEC_PERC] = &quot;%&quot;,</a>
<a name="ln6725">    [SPEC_HASH] = &quot;#&quot;,</a>
<a name="ln6726">    [SPEC_CWORD] = &quot;&lt;cword&gt;&quot;,           // cursor word</a>
<a name="ln6727">    [SPEC_CCWORD] = &quot;&lt;cWORD&gt;&quot;,          // cursor WORD</a>
<a name="ln6728">    [SPEC_CEXPR] = &quot;&lt;cexpr&gt;&quot;,           // expr under cursor</a>
<a name="ln6729">    [SPEC_CFILE] = &quot;&lt;cfile&gt;&quot;,           // cursor path name</a>
<a name="ln6730">    [SPEC_SFILE] = &quot;&lt;sfile&gt;&quot;,           // &quot;:so&quot; file name</a>
<a name="ln6731">    [SPEC_SLNUM] = &quot;&lt;slnum&gt;&quot;,           // &quot;:so&quot; file line number</a>
<a name="ln6732">    [SPEC_STACK] = &quot;&lt;stack&gt;&quot;,           // call stack</a>
<a name="ln6733">    [SPEC_SCRIPT] = &quot;&lt;script&gt;&quot;,         // script file name</a>
<a name="ln6734">    [SPEC_AFILE] = &quot;&lt;afile&gt;&quot;,           // autocommand file name</a>
<a name="ln6735">    [SPEC_ABUF] = &quot;&lt;abuf&gt;&quot;,             // autocommand buffer number</a>
<a name="ln6736">    [SPEC_AMATCH] = &quot;&lt;amatch&gt;&quot;,         // autocommand match name</a>
<a name="ln6737">    [SPEC_SFLNUM] = &quot;&lt;sflnum&gt;&quot;,         // script file line number</a>
<a name="ln6738">    [SPEC_SID] = &quot;&lt;SID&gt;&quot;,               // script ID: &lt;SNR&gt;123_</a>
<a name="ln6739">    // [SPEC_CLIENT] = &quot;&lt;client&gt;&quot;,</a>
<a name="ln6740">  };</a>
<a name="ln6741"> </a>
<a name="ln6742">  for (size_t i = 0; i &lt; ARRAY_SIZE(spec_str); i++) {</a>
<a name="ln6743">    size_t len = strlen(spec_str[i]);</a>
<a name="ln6744">    if (strncmp(src, spec_str[i], len) == 0) {</a>
<a name="ln6745">      *usedlen = len;</a>
<a name="ln6746">      assert(i &lt;= SSIZE_MAX);</a>
<a name="ln6747">      return (ssize_t)i;</a>
<a name="ln6748">    }</a>
<a name="ln6749">  }</a>
<a name="ln6750">  return -1;</a>
<a name="ln6751">}</a>
<a name="ln6752"> </a>
<a name="ln6753">/// Evaluate cmdline variables.</a>
<a name="ln6754">///</a>
<a name="ln6755">/// change &quot;%&quot;       to curbuf-&gt;b_ffname</a>
<a name="ln6756">///        &quot;#&quot;       to curwin-&gt;w_alt_fnum</a>
<a name="ln6757">///        &quot;&lt;cword&gt;&quot; to word under the cursor</a>
<a name="ln6758">///        &quot;&lt;cWORD&gt;&quot; to WORD under the cursor</a>
<a name="ln6759">///        &quot;&lt;cexpr&gt;&quot; to C-expression under the cursor</a>
<a name="ln6760">///        &quot;&lt;cfile&gt;&quot; to path name under the cursor</a>
<a name="ln6761">///        &quot;&lt;sfile&gt;&quot; to sourced file name</a>
<a name="ln6762">///        &quot;&lt;stack&gt;&quot; to call stack</a>
<a name="ln6763">///        &quot;&lt;script&gt;&quot; to current script name</a>
<a name="ln6764">///        &quot;&lt;slnum&gt;&quot; to sourced file line number</a>
<a name="ln6765">///        &quot;&lt;afile&gt;&quot; to file name for autocommand</a>
<a name="ln6766">///        &quot;&lt;abuf&gt;&quot;  to buffer number for autocommand</a>
<a name="ln6767">///        &quot;&lt;amatch&gt;&quot; to matching name for autocommand</a>
<a name="ln6768">///</a>
<a name="ln6769">/// When an error is detected, &quot;errormsg&quot; is set to a non-NULL pointer (may be</a>
<a name="ln6770">/// &quot;&quot; for error without a message) and NULL is returned.</a>
<a name="ln6771">///</a>
<a name="ln6772">/// @param src             pointer into commandline</a>
<a name="ln6773">/// @param srcstart        beginning of valid memory for src</a>
<a name="ln6774">/// @param usedlen         characters after src that are used</a>
<a name="ln6775">/// @param lnump           line number for :e command, or NULL</a>
<a name="ln6776">/// @param errormsg        pointer to error message</a>
<a name="ln6777">/// @param escaped         return value has escaped white space (can be NULL)</a>
<a name="ln6778">/// @param empty_is_error  empty result is considered an error</a>
<a name="ln6779">///</a>
<a name="ln6780">/// @return          an allocated string if a valid match was found.</a>
<a name="ln6781">///                  Returns NULL if no match was found.  &quot;usedlen&quot; then still contains the</a>
<a name="ln6782">///                  number of characters to skip.</a>
<a name="ln6783">char *eval_vars(char *src, const char *srcstart, size_t *usedlen, linenr_T *lnump,</a>
<a name="ln6784">                const char **errormsg, int *escaped, bool empty_is_error)</a>
<a name="ln6785">{</a>
<a name="ln6786">  char *result;</a>
<a name="ln6787">  char *resultbuf = NULL;</a>
<a name="ln6788">  size_t resultlen;</a>
<a name="ln6789">  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.</a>
<a name="ln6790">  bool tilde_file = false;</a>
<a name="ln6791">  bool skip_mod = false;</a>
<a name="ln6792">  char strbuf[30];</a>
<a name="ln6793"> </a>
<a name="ln6794">  *errormsg = NULL;</a>
<a name="ln6795">  if (escaped != NULL) {</a>
<a name="ln6796">    *escaped = false;</a>
<a name="ln6797">  }</a>
<a name="ln6798"> </a>
<a name="ln6799">  // Check if there is something to do.</a>
<a name="ln6800">  ssize_t spec_idx = find_cmdline_var(src, usedlen);</a>
<a name="ln6801">  if (spec_idx &lt; 0) {   // no match</a>
<a name="ln6802">    *usedlen = 1;</a>
<a name="ln6803">    return NULL;</a>
<a name="ln6804">  }</a>
<a name="ln6805"> </a>
<a name="ln6806">  // Skip when preceded with a backslash &quot;\%&quot; and &quot;\#&quot;.</a>
<a name="ln6807">  // Note: In &quot;\\%&quot; the % is also not recognized!</a>
<a name="ln6808">  if (src &gt; srcstart &amp;&amp; src[-1] == '\\') {</a>
<a name="ln6809">    *usedlen = 0;</a>
<a name="ln6810">    STRMOVE(src - 1, src);      // remove backslash</a>
<a name="ln6811">    return NULL;</a>
<a name="ln6812">  }</a>
<a name="ln6813"> </a>
<a name="ln6814">  // word or WORD under cursor</a>
<a name="ln6815">  if (spec_idx == SPEC_CWORD</a>
<a name="ln6816">      || spec_idx == SPEC_CCWORD</a>
<a name="ln6817">      || spec_idx == SPEC_CEXPR) {</a>
<a name="ln6818">    resultlen = find_ident_under_cursor(&amp;result,</a>
<a name="ln6819">                                        spec_idx == SPEC_CWORD</a>
<a name="ln6820">                                        ? (FIND_IDENT | FIND_STRING)</a>
<a name="ln6821">                                        : (spec_idx == SPEC_CEXPR</a>
<a name="ln6822">                                           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)</a>
<a name="ln6823">                                           : FIND_STRING));</a>
<a name="ln6824">    if (resultlen == 0) {</a>
<a name="ln6825">      *errormsg = &quot;&quot;;</a>
<a name="ln6826">      return NULL;</a>
<a name="ln6827">    }</a>
<a name="ln6828">    //</a>
<a name="ln6829">    // '#': Alternate file name</a>
<a name="ln6830">    // '%': Current file name</a>
<a name="ln6831">    //        File name under the cursor</a>
<a name="ln6832">    //        File name for autocommand</a>
<a name="ln6833">    //    and following modifiers</a>
<a name="ln6834">    //</a>
<a name="ln6835">  } else {</a>
<a name="ln6836">    switch (spec_idx) {</a>
<a name="ln6837">    case SPEC_PERC:             // '%': current file</a>
<a name="ln6838">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln6839">        result = &quot;&quot;;</a>
<a name="ln6840">        valid = 0;                  // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6841">      } else {</a>
<a name="ln6842">        result = curbuf-&gt;b_fname;</a>
<a name="ln6843">        tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6844">      }</a>
<a name="ln6845">      break;</a>
<a name="ln6846"> </a>
<a name="ln6847">    case SPEC_HASH:             // '#' or &quot;#99&quot;: alternate file</a>
<a name="ln6848">      if (src[1] == '#') {          // &quot;##&quot;: the argument list</a>
<a name="ln6849">        result = arg_all();</a>
<a name="ln6850">        resultbuf = result;</a>
<a name="ln6851">        *usedlen = 2;</a>
<a name="ln6852">        if (escaped != NULL) {</a>
<a name="ln6853">          *escaped = true;</a>
<a name="ln6854">        }</a>
<a name="ln6855">        skip_mod = true;</a>
<a name="ln6856">        break;</a>
<a name="ln6857">      }</a>
<a name="ln6858">      char *s = src + 1;</a>
<a name="ln6859">      if (*s == '&lt;') {                  // &quot;#&lt;99&quot; uses v:oldfiles.</a>
<a name="ln6860">        s++;</a>
<a name="ln6861">      }</a>
<a name="ln6862">      int i = getdigits_int(&amp;s, false, 0);</a>
<a name="ln6863">      if (s == src + 2 &amp;&amp; src[1] == '-') {</a>
<a name="ln6864">        // just a minus sign, don't skip over it</a>
<a name="ln6865">        s--;</a>
<a name="ln6866">      }</a>
<a name="ln6867">      *usedlen = (size_t)(s - src);           // length of what we expand</a>
<a name="ln6868"> </a>
<a name="ln6869">      if (src[1] == '&lt;' &amp;&amp; i != 0) {</a>
<a name="ln6870">        if (*usedlen &lt; 2) {</a>
<a name="ln6871">          // Should we give an error message for #&lt;text?</a>
<a name="ln6872">          *usedlen = 1;</a>
<a name="ln6873">          return NULL;</a>
<a name="ln6874">        }</a>
<a name="ln6875">        result = (char *)tv_list_find_str(get_vim_var_list(VV_OLDFILES), i - 1);</a>
<a name="ln6876">        if (result == NULL) {</a>
<a name="ln6877">          *errormsg = &quot;&quot;;</a>
<a name="ln6878">          return NULL;</a>
<a name="ln6879">        }</a>
<a name="ln6880">      } else {</a>
<a name="ln6881">        if (i == 0 &amp;&amp; src[1] == '&lt;' &amp;&amp; *usedlen &gt; 1) {</a>
<a name="ln6882">          *usedlen = 1;</a>
<a name="ln6883">        }</a>
<a name="ln6884">        buf_T *buf = buflist_findnr(i);</a>
<a name="ln6885">        if (buf == NULL) {</a>
<a name="ln6886">          *errormsg = _(&quot;E194: No alternate file name to substitute for '#'&quot;);</a>
<a name="ln6887">          return NULL;</a>
<a name="ln6888">        }</a>
<a name="ln6889">        if (lnump != NULL) {</a>
<a name="ln6890">          *lnump = ECMD_LAST;</a>
<a name="ln6891">        }</a>
<a name="ln6892">        if (buf-&gt;b_fname == NULL) {</a>
<a name="ln6893">          result = &quot;&quot;;</a>
<a name="ln6894">          valid = 0;                        // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6895">        } else {</a>
<a name="ln6896">          result = buf-&gt;b_fname;</a>
<a name="ln6897">          tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6898">        }</a>
<a name="ln6899">      }</a>
<a name="ln6900">      break;</a>
<a name="ln6901"> </a>
<a name="ln6902">    case SPEC_CFILE:            // file name under cursor</a>
<a name="ln6903">      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);</a>
<a name="ln6904">      if (result == NULL) {</a>
<a name="ln6905">        *errormsg = &quot;&quot;;</a>
<a name="ln6906">        return NULL;</a>
<a name="ln6907">      }</a>
<a name="ln6908">      resultbuf = result;                   // remember allocated string</a>
<a name="ln6909">      break;</a>
<a name="ln6910"> </a>
<a name="ln6911">    case SPEC_AFILE:  // file name for autocommand</a>
<a name="ln6912">      if (autocmd_fname != NULL &amp;&amp; !autocmd_fname_full) {</a>
<a name="ln6913">        // Still need to turn the fname into a full path.  It was</a>
<a name="ln6914">        // postponed to avoid a delay when &lt;afile&gt; is not used.</a>
<a name="ln6915">        autocmd_fname_full = true;</a>
<a name="ln6916">        result = FullName_save(autocmd_fname, false);</a>
<a name="ln6917">        // Copy into `autocmd_fname`, don't reassign it. #8165</a>
<a name="ln6918">        xstrlcpy(autocmd_fname, result, MAXPATHL);</a>
<a name="ln6919">        xfree(result);</a>
<a name="ln6920">      }</a>
<a name="ln6921">      result = autocmd_fname;</a>
<a name="ln6922">      if (result == NULL) {</a>
<a name="ln6923">        *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);</a>
<a name="ln6924">        return NULL;</a>
<a name="ln6925">      }</a>
<a name="ln6926">      result = path_try_shorten_fname(result);</a>
<a name="ln6927">      break;</a>
<a name="ln6928"> </a>
<a name="ln6929">    case SPEC_ABUF:             // buffer number for autocommand</a>
<a name="ln6930">      if (autocmd_bufnr &lt;= 0) {</a>
<a name="ln6931">        *errormsg = _(e_no_autocommand_buffer_number_to_substitute_for_abuf);</a>
<a name="ln6932">        return NULL;</a>
<a name="ln6933">      }</a>
<a name="ln6934">      snprintf(strbuf, sizeof(strbuf), &quot;%d&quot;, autocmd_bufnr);</a>
<a name="ln6935">      result = strbuf;</a>
<a name="ln6936">      break;</a>
<a name="ln6937"> </a>
<a name="ln6938">    case SPEC_AMATCH:           // match name for autocommand</a>
<a name="ln6939">      result = autocmd_match;</a>
<a name="ln6940">      if (result == NULL) {</a>
<a name="ln6941">        *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);</a>
<a name="ln6942">        return NULL;</a>
<a name="ln6943">      }</a>
<a name="ln6944">      break;</a>
<a name="ln6945"> </a>
<a name="ln6946">    case SPEC_SFILE:            // file name for &quot;:so&quot; command</a>
<a name="ln6947">      result = estack_sfile(ESTACK_SFILE);</a>
<a name="ln6948">      if (result == NULL) {</a>
<a name="ln6949">        *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);</a>
<a name="ln6950">        return NULL;</a>
<a name="ln6951">      }</a>
<a name="ln6952">      resultbuf = result;  // remember allocated string</a>
<a name="ln6953">      break;</a>
<a name="ln6954">    case SPEC_STACK:            // call stack</a>
<a name="ln6955">      result = estack_sfile(ESTACK_STACK);</a>
<a name="ln6956">      if (result == NULL) {</a>
<a name="ln6957">        *errormsg = _(e_no_call_stack_to_substitute_for_stack);</a>
<a name="ln6958">        return NULL;</a>
<a name="ln6959">      }</a>
<a name="ln6960">      resultbuf = result;  // remember allocated string</a>
<a name="ln6961">      break;</a>
<a name="ln6962">    case SPEC_SCRIPT:           // script file name</a>
<a name="ln6963">      result = estack_sfile(ESTACK_SCRIPT);</a>
<a name="ln6964">      if (result == NULL) {</a>
<a name="ln6965">        *errormsg = _(e_no_script_file_name_to_substitute_for_script);</a>
<a name="ln6966">        return NULL;</a>
<a name="ln6967">      }</a>
<a name="ln6968">      resultbuf = result;  // remember allocated string</a>
<a name="ln6969">      break;</a>
<a name="ln6970"> </a>
<a name="ln6971">    case SPEC_SLNUM:            // line in file for &quot;:so&quot; command</a>
<a name="ln6972">      if (SOURCING_NAME == NULL || SOURCING_LNUM == 0) {</a>
<a name="ln6973">        *errormsg = _(e_no_line_number_to_use_for_slnum);</a>
<a name="ln6974">        return NULL;</a>
<a name="ln6975">      }</a>
<a name="ln6976">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR, SOURCING_LNUM);</a>
<a name="ln6977">      result = strbuf;</a>
<a name="ln6978">      break;</a>
<a name="ln6979"> </a>
<a name="ln6980">    case SPEC_SFLNUM:  // line in script file</a>
<a name="ln6981">      if (current_sctx.sc_lnum + SOURCING_LNUM == 0) {</a>
<a name="ln6982">        *errormsg = _(e_no_line_number_to_use_for_sflnum);</a>
<a name="ln6983">        return NULL;</a>
<a name="ln6984">      }</a>
<a name="ln6985">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR,</a>
<a name="ln6986">               current_sctx.sc_lnum + SOURCING_LNUM);</a>
<a name="ln6987">      result = strbuf;</a>
<a name="ln6988">      break;</a>
<a name="ln6989"> </a>
<a name="ln6990">    case SPEC_SID:</a>
<a name="ln6991">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln6992">        *errormsg = _(e_usingsid);</a>
<a name="ln6993">        return NULL;</a>
<a name="ln6994">      }</a>
<a name="ln6995">      snprintf(strbuf, sizeof(strbuf), &quot;&lt;SNR&gt;%&quot; PRIdSCID &quot;_&quot;,</a>
<a name="ln6996">               current_sctx.sc_sid);</a>
<a name="ln6997">      result = strbuf;</a>
<a name="ln6998">      break;</a>
<a name="ln6999"> </a>
<a name="ln7000">    default:</a>
<a name="ln7001">      // should not happen</a>
<a name="ln7002">      *errormsg = &quot;&quot;;</a>
<a name="ln7003">      result = &quot;&quot;;    // avoid gcc warning</a>
<a name="ln7004">      break;</a>
<a name="ln7005">    }</a>
<a name="ln7006"> </a>
<a name="ln7007">    // Length of new string.</a>
<a name="ln7008">    resultlen = strlen(result);</a>
<a name="ln7009">    // Remove the file name extension.</a>
<a name="ln7010">    if (src[*usedlen] == '&lt;') {</a>
<a name="ln7011">      (*usedlen)++;</a>
<a name="ln7012">      char *s;</a>
<a name="ln7013">      if ((s = strrchr(result, '.')) != NULL</a>
<a name="ln7014">          &amp;&amp; s &gt;= path_tail(result)) {</a>
<a name="ln7015">        resultlen = (size_t)(s - result);</a>
<a name="ln7016">      }</a>
<a name="ln7017">    } else if (!skip_mod) {</a>
<a name="ln7018">      valid |= modify_fname(src, tilde_file, usedlen, &amp;result,</a>
<a name="ln7019">                            &amp;resultbuf, &amp;resultlen);</a>
<a name="ln7020">      if (result == NULL) {</a>
<a name="ln7021">        *errormsg = &quot;&quot;;</a>
<a name="ln7022">        return NULL;</a>
<a name="ln7023">      }</a>
<a name="ln7024">    }</a>
<a name="ln7025">  }</a>
<a name="ln7026"> </a>
<a name="ln7027">  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7028">    if (empty_is_error) {</a>
<a name="ln7029">      if (valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7030">        // xgettext:no-c-format</a>
<a name="ln7031">        *errormsg = _(&quot;E499: Empty file name for '%' or '#', only works with \&quot;:p:h\&quot;&quot;);</a>
<a name="ln7032">      } else {</a>
<a name="ln7033">        *errormsg = _(&quot;E500: Evaluates to an empty string&quot;);</a>
<a name="ln7034">      }</a>
<a name="ln7035">    }</a>
<a name="ln7036">    result = NULL;</a>
<a name="ln7037">  } else {</a>
<a name="ln7038">    result = xstrnsave(result, resultlen);</a>
<a name="ln7039">  }</a>
<a name="ln7040">  xfree(resultbuf);</a>
<a name="ln7041">  return result;</a>
<a name="ln7042">}</a>
<a name="ln7043"> </a>
<a name="ln7044">/// Expand the &lt;sfile&gt; string in &quot;arg&quot;.</a>
<a name="ln7045">///</a>
<a name="ln7046">/// @return  an allocated string, or NULL for any error.</a>
<a name="ln7047">char *expand_sfile(char *arg)</a>
<a name="ln7048">{</a>
<a name="ln7049">  char *result = xstrdup(arg);</a>
<a name="ln7050"> </a>
<a name="ln7051">  for (char *p = result; *p;) {</a>
<a name="ln7052">    if (strncmp(p, &quot;&lt;sfile&gt;&quot;, 7) != 0) {</a>
<a name="ln7053">      p++;</a>
<a name="ln7054">    } else {</a>
<a name="ln7055">      // replace &quot;&lt;sfile&gt;&quot; with the sourced file name, and do &quot;:&quot; stuff</a>
<a name="ln7056">      size_t srclen;</a>
<a name="ln7057">      const char *errormsg;</a>
<a name="ln7058">      char *repl = eval_vars(p, result, &amp;srclen, NULL, &amp;errormsg, NULL, true);</a>
<a name="ln7059">      if (errormsg != NULL) {</a>
<a name="ln7060">        if (*errormsg) {</a>
<a name="ln7061">          emsg(errormsg);</a>
<a name="ln7062">        }</a>
<a name="ln7063">        xfree(result);</a>
<a name="ln7064">        return NULL;</a>
<a name="ln7065">      }</a>
<a name="ln7066">      if (repl == NULL) {               // no match (cannot happen)</a>
<a name="ln7067">        p += srclen;</a>
<a name="ln7068">        continue;</a>
<a name="ln7069">      }</a>
<a name="ln7070">      size_t len = strlen(result) - srclen + strlen(repl) + 1;</a>
<a name="ln7071">      char *newres = xmalloc(len);</a>
<a name="ln7072">      memmove(newres, result, (size_t)(p - result));</a>
<a name="ln7073">      STRCPY(newres + (p - result), repl);</a>
<a name="ln7074">      len = strlen(newres);</a>
<a name="ln7075">      STRCAT(newres, p + srclen);</a>
<a name="ln7076">      xfree(repl);</a>
<a name="ln7077">      xfree(result);</a>
<a name="ln7078">      result = newres;</a>
<a name="ln7079">      p = newres + len;                 // continue after the match</a>
<a name="ln7080">    }</a>
<a name="ln7081">  }</a>
<a name="ln7082"> </a>
<a name="ln7083">  return result;</a>
<a name="ln7084">}</a>
<a name="ln7085"> </a>
<a name="ln7086">/// &quot;:rshada&quot; and &quot;:wshada&quot;.</a>
<a name="ln7087">static void ex_shada(exarg_T *eap)</a>
<a name="ln7088">{</a>
<a name="ln7089">  char *save_shada = p_shada;</a>
<a name="ln7090">  if (*p_shada == NUL) {</a>
<a name="ln7091">    p_shada = &quot;'100&quot;;</a>
<a name="ln7092">  }</a>
<a name="ln7093">  if (eap-&gt;cmdidx == CMD_rviminfo || eap-&gt;cmdidx == CMD_rshada) {</a>
<a name="ln7094">    (void)shada_read_everything(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln7095">  } else {</a>
<a name="ln7096">    shada_write_file(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln7097">  }</a>
<a name="ln7098">  p_shada = save_shada;</a>
<a name="ln7099">}</a>
<a name="ln7100"> </a>
<a name="ln7101">/// Make a dialog message in &quot;buff[DIALOG_MSG_SIZE]&quot;.</a>
<a name="ln7102">/// &quot;format&quot; must contain &quot;%s&quot;.</a>
<a name="ln7103">void dialog_msg(char *buff, char *format, char *fname)</a>
<a name="ln7104">{</a>
<a name="ln7105">  if (fname == NULL) {</a>
<a name="ln7106">    fname = _(&quot;Untitled&quot;);</a>
<a name="ln7107">  }</a>
<a name="ln7108">  vim_snprintf(buff, DIALOG_MSG_SIZE, format, fname);</a>
<a name="ln7109">}</a>
<a name="ln7110"> </a>
<a name="ln7111">static TriState filetype_detect = kNone;</a>
<a name="ln7112">static TriState filetype_plugin = kNone;</a>
<a name="ln7113">static TriState filetype_indent = kNone;</a>
<a name="ln7114"> </a>
<a name="ln7115">/// &quot;:filetype [plugin] [indent] {on,off,detect}&quot;</a>
<a name="ln7116">/// on: Load the filetype.vim file to install autocommands for file types.</a>
<a name="ln7117">/// off: Load the ftoff.vim file to remove all autocommands for file types.</a>
<a name="ln7118">/// plugin on: load filetype.vim and ftplugin.vim</a>
<a name="ln7119">/// plugin off: load ftplugof.vim</a>
<a name="ln7120">/// indent on: load filetype.vim and indent.vim</a>
<a name="ln7121">/// indent off: load indoff.vim</a>
<a name="ln7122">static void ex_filetype(exarg_T *eap)</a>
<a name="ln7123">{</a>
<a name="ln7124">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln7125">    // Print current status.</a>
<a name="ln7126">    smsg(0, &quot;filetype detection:%s  plugin:%s  indent:%s&quot;,</a>
<a name="ln7127">         filetype_detect == kTrue ? &quot;ON&quot; : &quot;OFF&quot;,</a>
<a name="ln7128">         filetype_plugin == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;,</a>
<a name="ln7129">         filetype_indent == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;);</a>
<a name="ln7130">    return;</a>
<a name="ln7131">  }</a>
<a name="ln7132"> </a>
<a name="ln7133">  char *arg = eap-&gt;arg;</a>
<a name="ln7134">  bool plugin = false;</a>
<a name="ln7135">  bool indent = false;</a>
<a name="ln7136"> </a>
<a name="ln7137">  // Accept &quot;plugin&quot; and &quot;indent&quot; in any order.</a>
<a name="ln7138">  while (true) {</a>
<a name="ln7139">    if (strncmp(arg, &quot;plugin&quot;, 6) == 0) {</a>
<a name="ln7140">      plugin = true;</a>
<a name="ln7141">      arg = skipwhite(arg + 6);</a>
<a name="ln7142">      continue;</a>
<a name="ln7143">    }</a>
<a name="ln7144">    if (strncmp(arg, &quot;indent&quot;, 6) == 0) {</a>
<a name="ln7145">      indent = true;</a>
<a name="ln7146">      arg = skipwhite(arg + 6);</a>
<a name="ln7147">      continue;</a>
<a name="ln7148">    }</a>
<a name="ln7149">    break;</a>
<a name="ln7150">  }</a>
<a name="ln7151">  if (strcmp(arg, &quot;on&quot;) == 0 || strcmp(arg, &quot;detect&quot;) == 0) {</a>
<a name="ln7152">    if (*arg == 'o' || !filetype_detect) {</a>
<a name="ln7153">      source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7154">      filetype_detect = kTrue;</a>
<a name="ln7155">      if (plugin) {</a>
<a name="ln7156">        source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7157">        filetype_plugin = kTrue;</a>
<a name="ln7158">      }</a>
<a name="ln7159">      if (indent) {</a>
<a name="ln7160">        source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7161">        filetype_indent = kTrue;</a>
<a name="ln7162">      }</a>
<a name="ln7163">    }</a>
<a name="ln7164">    if (*arg == 'd') {</a>
<a name="ln7165">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln7166">      do_modelines(0);</a>
<a name="ln7167">    }</a>
<a name="ln7168">  } else if (strcmp(arg, &quot;off&quot;) == 0) {</a>
<a name="ln7169">    if (plugin || indent) {</a>
<a name="ln7170">      if (plugin) {</a>
<a name="ln7171">        source_runtime(FTPLUGOF_FILE, DIP_ALL);</a>
<a name="ln7172">        filetype_plugin = kFalse;</a>
<a name="ln7173">      }</a>
<a name="ln7174">      if (indent) {</a>
<a name="ln7175">        source_runtime(INDOFF_FILE, DIP_ALL);</a>
<a name="ln7176">        filetype_indent = kFalse;</a>
<a name="ln7177">      }</a>
<a name="ln7178">    } else {</a>
<a name="ln7179">      source_runtime(FTOFF_FILE, DIP_ALL);</a>
<a name="ln7180">      filetype_detect = kFalse;</a>
<a name="ln7181">    }</a>
<a name="ln7182">  } else {</a>
<a name="ln7183">    semsg(_(e_invarg2), arg);</a>
<a name="ln7184">  }</a>
<a name="ln7185">}</a>
<a name="ln7186"> </a>
<a name="ln7187">/// Source ftplugin.vim and indent.vim to create the necessary FileType</a>
<a name="ln7188">/// autocommands. We do this separately from filetype.vim so that these</a>
<a name="ln7189">/// autocommands will always fire first (and thus can be overridden) while still</a>
<a name="ln7190">/// allowing general filetype detection to be disabled in the user's init file.</a>
<a name="ln7191">void filetype_plugin_enable(void)</a>
<a name="ln7192">{</a>
<a name="ln7193">  if (filetype_plugin == kNone) {</a>
<a name="ln7194">    source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7195">    filetype_plugin = kTrue;</a>
<a name="ln7196">  }</a>
<a name="ln7197">  if (filetype_indent == kNone) {</a>
<a name="ln7198">    source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7199">    filetype_indent = kTrue;</a>
<a name="ln7200">  }</a>
<a name="ln7201">}</a>
<a name="ln7202"> </a>
<a name="ln7203">/// Enable filetype detection if the user did not explicitly disable it.</a>
<a name="ln7204">void filetype_maybe_enable(void)</a>
<a name="ln7205">{</a>
<a name="ln7206">  if (filetype_detect == kNone) {</a>
<a name="ln7207">    // Normally .vim files are sourced before .lua files when both are</a>
<a name="ln7208">    // supported, but we reverse the order here because we want the Lua</a>
<a name="ln7209">    // autocommand to be defined first so that it runs first</a>
<a name="ln7210">    source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7211">    filetype_detect = kTrue;</a>
<a name="ln7212">  }</a>
<a name="ln7213">}</a>
<a name="ln7214"> </a>
<a name="ln7215">/// &quot;:setfiletype [FALLBACK] {name}&quot;</a>
<a name="ln7216">static void ex_setfiletype(exarg_T *eap)</a>
<a name="ln7217">{</a>
<a name="ln7218">  if (did_filetype) {</a>
<a name="ln7219">    return;</a>
<a name="ln7220">  }</a>
<a name="ln7221"> </a>
<a name="ln7222">  char *arg = eap-&gt;arg;</a>
<a name="ln7223">  if (strncmp(arg, &quot;FALLBACK &quot;, 9) == 0) {</a>
<a name="ln7224">    arg += 9;</a>
<a name="ln7225">  }</a>
<a name="ln7226"> </a>
<a name="ln7227">  set_option_value_give_err(&quot;filetype&quot;, CSTR_AS_OPTVAL(arg), OPT_LOCAL);</a>
<a name="ln7228">  if (arg != eap-&gt;arg) {</a>
<a name="ln7229">    did_filetype = false;</a>
<a name="ln7230">  }</a>
<a name="ln7231">}</a>
<a name="ln7232"> </a>
<a name="ln7233">static void ex_digraphs(exarg_T *eap)</a>
<a name="ln7234">{</a>
<a name="ln7235">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln7236">    putdigraph(eap-&gt;arg);</a>
<a name="ln7237">  } else {</a>
<a name="ln7238">    listdigraphs(eap-&gt;forceit);</a>
<a name="ln7239">  }</a>
<a name="ln7240">}</a>
<a name="ln7241"> </a>
<a name="ln7242">void set_no_hlsearch(bool flag)</a>
<a name="ln7243">{</a>
<a name="ln7244">  no_hlsearch = flag;</a>
<a name="ln7245">  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch &amp;&amp; p_hls);</a>
<a name="ln7246">}</a>
<a name="ln7247"> </a>
<a name="ln7248">/// &quot;:nohlsearch&quot;</a>
<a name="ln7249">static void ex_nohlsearch(exarg_T *eap)</a>
<a name="ln7250">{</a>
<a name="ln7251">  set_no_hlsearch(true);</a>
<a name="ln7252">  redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln7253">}</a>
<a name="ln7254"> </a>
<a name="ln7255">static void ex_fold(exarg_T *eap)</a>
<a name="ln7256">{</a>
<a name="ln7257">  if (foldManualAllowed(true)) {</a>
<a name="ln7258">    pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7259">    pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7260">    foldCreate(curwin, start, end);</a>
<a name="ln7261">  }</a>
<a name="ln7262">}</a>
<a name="ln7263"> </a>
<a name="ln7264">static void ex_foldopen(exarg_T *eap)</a>
<a name="ln7265">{</a>
<a name="ln7266">  pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7267">  pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7268">  opFoldRange(start, end, eap-&gt;cmdidx == CMD_foldopen, eap-&gt;forceit, false);</a>
<a name="ln7269">}</a>
<a name="ln7270"> </a>
<a name="ln7271">static void ex_folddo(exarg_T *eap)</a>
<a name="ln7272">{</a>
<a name="ln7273">  // First set the marks for all lines closed/open.</a>
<a name="ln7274">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln7275">    if (hasFolding(lnum, NULL, NULL) == (eap-&gt;cmdidx == CMD_folddoclosed)) {</a>
<a name="ln7276">      ml_setmarked(lnum);</a>
<a name="ln7277">    }</a>
<a name="ln7278">  }</a>
<a name="ln7279"> </a>
<a name="ln7280">  global_exe(eap-&gt;arg);  // Execute the command on the marked lines.</a>
<a name="ln7281">  ml_clearmarked();      // clear rest of the marks</a>
<a name="ln7282">}</a>
<a name="ln7283"> </a>
<a name="ln7284">/// @return  true if the supplied Ex cmdidx is for a location list command</a>
<a name="ln7285">///          instead of a quickfix command.</a>
<a name="ln7286">bool is_loclist_cmd(int cmdidx)</a>
<a name="ln7287">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7288">{</a>
<a name="ln7289">  if (cmdidx &lt; 0 || cmdidx &gt;= CMD_SIZE) {</a>
<a name="ln7290">    return false;</a>
<a name="ln7291">  }</a>
<a name="ln7292">  return cmdnames[cmdidx].cmd_name[0] == 'l';</a>
<a name="ln7293">}</a>
<a name="ln7294"> </a>
<a name="ln7295">bool get_pressedreturn(void)</a>
<a name="ln7296">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7297">{</a>
<a name="ln7298">  return ex_pressedreturn;</a>
<a name="ln7299">}</a>
<a name="ln7300"> </a>
<a name="ln7301">void set_pressedreturn(bool val)</a>
<a name="ln7302">{</a>
<a name="ln7303">  ex_pressedreturn = val;</a>
<a name="ln7304">}</a>
<a name="ln7305"> </a>
<a name="ln7306">static void ex_terminal(exarg_T *eap)</a>
<a name="ln7307">{</a>
<a name="ln7308">  char ex_cmd[1024];</a>
<a name="ln7309">  size_t len = 0;</a>
<a name="ln7310"> </a>
<a name="ln7311">  if (cmdmod.cmod_tab &gt; 0 || cmdmod.cmod_split != 0) {</a>
<a name="ln7312">    bool multi_mods = false;</a>
<a name="ln7313"> </a>
<a name="ln7314">    // ex_cmd must be a null terminated string before passing to add_win_cmd_modifiers</a>
<a name="ln7315">    ex_cmd[0] = '\0';</a>
<a name="ln7316"> </a>
<a name="ln7317">    len = add_win_cmd_modifiers(ex_cmd, &amp;cmdmod, &amp;multi_mods);</a>
<a name="ln7318">    assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7319">    int result = snprintf(ex_cmd + len, sizeof(ex_cmd) - len, &quot; new&quot;);</a>
<a name="ln7320">    assert(result &gt; 0);</a>
<a name="ln7321">    len += (size_t)result;</a>
<a name="ln7322">  } else {</a>
<a name="ln7323">    int result = snprintf(ex_cmd, sizeof(ex_cmd), &quot;enew%s&quot;, eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;);</a>
<a name="ln7324">    assert(result &gt; 0);</a>
<a name="ln7325">    len += (size_t)result;</a>
<a name="ln7326">  }</a>
<a name="ln7327"> </a>
<a name="ln7328">  assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7329"> </a>
<a name="ln7330">  if (*eap-&gt;arg != NUL) {  // Run {cmd} in 'shell'.</a>
<a name="ln7331">    char *name = vim_strsave_escaped(eap-&gt;arg, &quot;\&quot;\\&quot;);</a>
<a name="ln7332">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7333">             &quot; | call termopen(\&quot;%s\&quot;)&quot;, name);</a>
<a name="ln7334">    xfree(name);</a>
<a name="ln7335">  } else {  // No {cmd}: run the job with tokenized 'shell'.</a>
<a name="ln7336">    if (*p_sh == NUL) {</a>
<a name="ln7337">      emsg(_(e_shellempty));</a>
<a name="ln7338">      return;</a>
<a name="ln7339">    }</a>
<a name="ln7340"> </a>
<a name="ln7341">    char **argv = shell_build_argv(NULL, NULL);</a>
<a name="ln7342">    char **p = argv;</a>
<a name="ln7343">    char tempstring[512];</a>
<a name="ln7344">    char shell_argv[512] = { 0 };</a>
<a name="ln7345"> </a>
<a name="ln7346">    while (*p != NULL) {</a>
<a name="ln7347">      snprintf(tempstring, sizeof(tempstring), &quot;,\&quot;%s\&quot;&quot;, *p);</a>
<a name="ln7348">      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));</a>
<a name="ln7349">      p++;</a>
<a name="ln7350">    }</a>
<a name="ln7351">    shell_free_argv(argv);</a>
<a name="ln7352"> </a>
<a name="ln7353">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7354">             &quot; | call termopen([%s])&quot;, shell_argv + 1);</a>
<a name="ln7355">  }</a>
<a name="ln7356"> </a>
<a name="ln7357">  do_cmdline_cmd(ex_cmd);</a>
<a name="ln7358">}</a>
<a name="ln7359"> </a>
<a name="ln7360">void verify_command(char *cmd)</a>
<a name="ln7361">{</a>
<a name="ln7362">  if (strcmp(&quot;smile&quot;, cmd) != 0) {</a>
<a name="ln7363">    return;  // acceptable non-existing command</a>
<a name="ln7364">  }</a>
<a name="ln7365">  int a = HL_ATTR(HLF_E);</a>
<a name="ln7366">  msg(&quot; #xxn`          #xnxx`        ,+x@##@Mz;`        .xxx&quot;</a>
<a name="ln7367">      &quot;xxxxxxnz+,      znnnnnnnnnnnnnnnn.&quot;, a);</a>
<a name="ln7368">  msg(&quot; n###z          x####`      :x##########W+`      ,###&quot;</a>
<a name="ln7369">      &quot;##########M;    W################.&quot;, a);</a>
<a name="ln7370">  msg(&quot; n####;         x####`    `z##############W:     ,###&quot;</a>
<a name="ln7371">      &quot;#############   W################.&quot;, a);</a>
<a name="ln7372">  msg(&quot; n####W.        x####`   ,W#################+    ,###&quot;</a>
<a name="ln7373">      &quot;##############  W################.&quot;, a);</a>
<a name="ln7374">  msg(&quot; n#####n        x####`   @###################    ,###&quot;</a>
<a name="ln7375">      &quot;##############i W################.&quot;, a);</a>
<a name="ln7376">  msg(&quot; n######i       x####`  .#########@W@########*   ,###&quot;</a>
<a name="ln7377">      &quot;##############W`W################.&quot;, a);</a>
<a name="ln7378">  msg(&quot; n######@.      x####`  x######W*.  `;n#######:  ,###&quot;</a>
<a name="ln7379">      &quot;#x,,,,:*M######iW###@:,,,,,,,,,,,`&quot;, a);</a>
<a name="ln7380">  msg(&quot; n#######n      x####` *######+`       :M#####M  ,###&quot;</a>
<a name="ln7381">      &quot;#n      `x#####xW###@`&quot;, a);</a>
<a name="ln7382">  msg(&quot; n########*     x####``@####@;          `x#####i ,###&quot;</a>
<a name="ln7383">      &quot;#n       ,#####@W###@`&quot;, a);</a>
<a name="ln7384">  msg(&quot; n########@     x####`*#####i            `M####M ,###&quot;</a>
<a name="ln7385">      &quot;#n        x#########@`&quot;, a);</a>
<a name="ln7386">  msg(&quot; n#########     x####`M####z              :#####:,###&quot;</a>
<a name="ln7387">      &quot;#n        z#########@`&quot;, a);</a>
<a name="ln7388">  msg(&quot; n#########*    x####,#####.               n####+,###&quot;</a>
<a name="ln7389">      &quot;#n        n#########@`&quot;, a);</a>
<a name="ln7390">  msg(&quot; n####@####@,   x####i####x                ;####x,###&quot;</a>
<a name="ln7391">      &quot;#n       `W#####@####+++++++++++i&quot;, a);</a>
<a name="ln7392">  msg(&quot; n####*#####M`  x#########*                `####@,###&quot;</a>
<a name="ln7393">      &quot;#n       i#####MW###############W&quot;, a);</a>
<a name="ln7394">  msg(&quot; n####.######+  x####z####;                 W####,###&quot;</a>
<a name="ln7395">      &quot;#n      i@######W###############W&quot;, a);</a>
<a name="ln7396">  msg(&quot; n####.`W#####: x####n####:                 M####:###&quot;</a>
<a name="ln7397">      &quot;#@nnnnnW#######,W###############W&quot;, a);</a>
<a name="ln7398">  msg(&quot; n####. :#####M`x####z####;                 W####,###&quot;</a>
<a name="ln7399">      &quot;##############z W###############W&quot;, a);</a>
<a name="ln7400">  msg(&quot; n####.  #######x#########*                `####W,###&quot;</a>
<a name="ln7401">      &quot;#############W` W###############W&quot;, a);</a>
<a name="ln7402">  msg(&quot; n####.  `M#####W####i####x                ;####x,###&quot;</a>
<a name="ln7403">      &quot;############W,  W####+**********i&quot;, a);</a>
<a name="ln7404">  msg(&quot; n####.   ,##########,#####.               n####+,###&quot;</a>
<a name="ln7405">      &quot;###########n.   W###@`&quot;, a);</a>
<a name="ln7406">  msg(&quot; n####.    ##########`M####z              :#####:,###&quot;</a>
<a name="ln7407">      &quot;########Wz:     W###@`&quot;, a);</a>
<a name="ln7408">  msg(&quot; n####.    x#########`*#####i            `M####M ,###&quot;</a>
<a name="ln7409">      &quot;#x.....`        W###@`&quot;, a);</a>
<a name="ln7410">  msg(&quot; n####.    ,@########``@####@;          `x#####i ,###&quot;</a>
<a name="ln7411">      &quot;#n              W###@`&quot;, a);</a>
<a name="ln7412">  msg(&quot; n####.     *########` *#####@+`       ,M#####M  ,###&quot;</a>
<a name="ln7413">      &quot;#n              W###@`&quot;, a);</a>
<a name="ln7414">  msg(&quot; n####.      x#######`  x######W*.  `;n######@:  ,###&quot;</a>
<a name="ln7415">      &quot;#n              W###@,,,,,,,,,,,,`&quot;, a);</a>
<a name="ln7416">  msg(&quot; n####.      .@######`  .#########@W@########*   ,###&quot;</a>
<a name="ln7417">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7418">  msg(&quot; n####.       i######`   @###################    ,###&quot;</a>
<a name="ln7419">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7420">  msg(&quot; n####.        n#####`   ,W#################+    ,###&quot;</a>
<a name="ln7421">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7422">  msg(&quot; n####.        .@####`    .n##############W;     ,###&quot;</a>
<a name="ln7423">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7424">  msg(&quot; n####.         i####`      :x##########W+`      ,###&quot;</a>
<a name="ln7425">      &quot;#n              W################,&quot;, a);</a>
<a name="ln7426">  msg(&quot; +nnnn`          +nnn`        ,+x@##@Mz;`        .nnn&quot;</a>
<a name="ln7427">      &quot;n+              zxxxxxxxxxxxxxxxx.&quot;, a);</a>
<a name="ln7428">  msg(&quot; &quot;, a);</a>
<a name="ln7429">  msg(&quot;                                                     &quot;</a>
<a name="ln7430">      &quot;                              ,+M@#Mi&quot;, a);</a>
<a name="ln7431">  msg(&quot;                                 &quot;</a>
<a name="ln7432">      &quot;                                                .z########&quot;, a);</a>
<a name="ln7433">  msg(&quot;                                 &quot;</a>
<a name="ln7434">      &quot;                                               i@#########i&quot;, a);</a>
<a name="ln7435">  msg(&quot;                                 &quot;</a>
<a name="ln7436">      &quot;                                             `############W`&quot;, a);</a>
<a name="ln7437">  msg(&quot;                                 &quot;</a>
<a name="ln7438">      &quot;                                            `n#############i&quot;, a);</a>
<a name="ln7439">  msg(&quot;                                 &quot;</a>
<a name="ln7440">      &quot;                                           `n##############n&quot;, a);</a>
<a name="ln7441">  msg(&quot;     ``                          &quot;</a>
<a name="ln7442">      &quot;                                           z###############@`&quot;, a);</a>
<a name="ln7443">  msg(&quot;    `W@z,                        &quot;</a>
<a name="ln7444">      &quot;                                          ##################,&quot;, a);</a>
<a name="ln7445">  msg(&quot;    *#####`                      &quot;</a>
<a name="ln7446">      &quot;                                         i############@x@###i&quot;, a);</a>
<a name="ln7447">  msg(&quot;    ######M.                     &quot;</a>
<a name="ln7448">      &quot;                                        :#############n`,W##+&quot;, a);</a>
<a name="ln7449">  msg(&quot;    +######@:                    &quot;</a>
<a name="ln7450">      &quot;                                       .W#########M@##+  *##z&quot;, a);</a>
<a name="ln7451">  msg(&quot;    :#######@:                   &quot;</a>
<a name="ln7452">      &quot;                                      `x########@#x###*  ,##n&quot;, a);</a>
<a name="ln7453">  msg(&quot;    `@#######@;                  &quot;</a>
<a name="ln7454">      &quot;                                      z#########M*@nW#i  .##x&quot;, a);</a>
<a name="ln7455">  msg(&quot;     z########@i                 &quot;</a>
<a name="ln7456">      &quot;                                     *###########WM#@#,  `##x&quot;, a);</a>
<a name="ln7457">  msg(&quot;     i##########+                &quot;</a>
<a name="ln7458">      &quot;                                    ;###########*n###@   `##x&quot;, a);</a>
<a name="ln7459">  msg(&quot;     `@#MM#######x,              &quot;</a>
<a name="ln7460">      &quot;                                   ,@#########zM,`z##M   `@#x&quot;, a);</a>
<a name="ln7461">  msg(&quot;      n##M#W#######n.            &quot;</a>
<a name="ln7462">      &quot;   `.:i*+#zzzz##+i:.`             ,W#########Wii,`n@#@` n@##n&quot;, a);</a>
<a name="ln7463">  msg(&quot;      ;###@#x#######n         `,i&quot;</a>
<a name="ln7464">      &quot;#nW@#####@@WWW@@####@Mzi.        ,W##########@z.. ;zM#+i####z&quot;, a);</a>
<a name="ln7465">  msg(&quot;       x####nz########    .;#x@##&quot;</a>
<a name="ln7466">      &quot;@Wn#*;,.`      ``,:*#x@##M+,    ;@########xz@WM+#` `n@#######&quot;, a);</a>
<a name="ln7467">  msg(&quot;       ,@####M########xi#@##@Mzi,&quot;</a>
<a name="ln7468">      &quot;`                     .+x###Mi:n##########Mz```.:i  *@######*&quot;, a);</a>
<a name="ln7469">  msg(&quot;        *#####W#########ix+:`    &quot;</a>
<a name="ln7470">      &quot;                         :n#############z:       `*.`M######i&quot;, a);</a>
<a name="ln7471">  msg(&quot;        i#W##nW@+@##@#M@;        &quot;</a>
<a name="ln7472">      &quot;                           ;W@@##########W,        i`x@#####,&quot;, a);</a>
<a name="ln7473">  msg(&quot;        `@@n@Wn#@iMW*#*:         &quot;</a>
<a name="ln7474">      &quot;                            `iz#z@######x.           M######`&quot;, a);</a>
<a name="ln7475">  msg(&quot;         z##zM###x`*, .`         &quot;</a>
<a name="ln7476">      &quot;                                 `iW#####W;:`        +#####M&quot;, a);</a>
<a name="ln7477">  msg(&quot;         ,###nn##n`              &quot;</a>
<a name="ln7478">      &quot;                                  ,#####x;`        ,;@######&quot;, a);</a>
<a name="ln7479">  msg(&quot;          x###xz#.               &quot;</a>
<a name="ln7480">      &quot;                                    in###+        `:######@.&quot;, a);</a>
<a name="ln7481">  msg(&quot;          ;####n+                &quot;</a>
<a name="ln7482">      &quot;                                    `Mnx##xi`   , zM#######&quot;, a);</a>
<a name="ln7483">  msg(&quot;          `W####+                &quot;</a>
<a name="ln7484">      &quot;i.                                   `.+x###@#. :n,z######:&quot;, a);</a>
<a name="ln7485">  msg(&quot;           z####@`              ;&quot;</a>
<a name="ln7486">      &quot;#:                                     .ii@###@;.*M*z####@`&quot;, a);</a>
<a name="ln7487">  msg(&quot;           i####M         `   `i@&quot;</a>
<a name="ln7488">      &quot;#,           ::                           +#n##@+@##W####n&quot;, a);</a>
<a name="ln7489">  msg(&quot;           :####x    ,i. ##xzM###&quot;</a>
<a name="ln7490">      &quot;@`     i.   .@@,                           .z####x#######*&quot;, a);</a>
<a name="ln7491">  msg(&quot;           ,###W;   i##Wz########&quot;</a>
<a name="ln7492">      &quot;#     :##   z##n                           ,@########x###:&quot;, a);</a>
<a name="ln7493">  msg(&quot;            n##n   `W###########M&quot;</a>
<a name="ln7494">      &quot;`;n,  i#x  ,###@i                           *W########W#@`&quot;, a);</a>
<a name="ln7495">  msg(&quot;           .@##+  `x###########@.&quot;</a>
<a name="ln7496">      &quot; z#+ .M#W``x#####n`                         `;#######@z#x&quot;, a);</a>
<a name="ln7497">  msg(&quot;           n###z :W############@ &quot;</a>
<a name="ln7498">      &quot; z#*  @##xM#######@n;                        `########nW+&quot;, a);</a>
<a name="ln7499">  msg(&quot;          ;####nW##############W &quot;</a>
<a name="ln7500">      &quot;:@#* `@#############*                        :########z@i`&quot;, a);</a>
<a name="ln7501">  msg(&quot;          M##################### &quot;</a>
<a name="ln7502">      &quot;M##:  @#############@:                       *W########M#&quot;, a);</a>
<a name="ln7503">  msg(&quot;         ;#####################i.&quot;</a>
<a name="ln7504">      &quot;##x`  W#############W,                       :n########zx&quot;, a);</a>
<a name="ln7505">  msg(&quot;         x####################@.`&quot;</a>
<a name="ln7506">      &quot;x;    @#############z.                       .@########W#&quot;, a);</a>
<a name="ln7507">  msg(&quot;        ,######################` &quot;</a>
<a name="ln7508">      &quot;      W###############x*,`                    W######zM#i&quot;, a);</a>
<a name="ln7509">  msg(&quot;        #######################: &quot;</a>
<a name="ln7510">      &quot;      z##################@x+*#zzi            `@#########.&quot;, a);</a>
<a name="ln7511">  msg(&quot;        W########W#z#M#########; &quot;</a>
<a name="ln7512">      &quot;      *##########################z            :@#######@`&quot;, a);</a>
<a name="ln7513">  msg(&quot;       `@#######x`;#z ,x#######; &quot;</a>
<a name="ln7514">      &quot;      z###########M###xnM@########*            :M######@&quot;, a);</a>
<a name="ln7515">  msg(&quot;       i########, x#@`  z######; &quot;</a>
<a name="ln7516">      &quot;      *##########i *#@`  `+########+`            n######.&quot;, a);</a>
<a name="ln7517">  msg(&quot;       n#######@` M##,  `W#####. &quot;</a>
<a name="ln7518">      &quot;      *#########z  ###;    z########M:           :W####n&quot;, a);</a>
<a name="ln7519">  msg(&quot;       M#######M  n##.   x####x  &quot;</a>
<a name="ln7520">      &quot;      `x########:  z##+    M#########@;           .n###+&quot;, a);</a>
<a name="ln7521">  msg(&quot;       W#######@` :#W   `@####:  &quot;</a>
<a name="ln7522">      &quot;       `@######W   i###   ;###########@.            n##n&quot;, a);</a>
<a name="ln7523">  msg(&quot;       W########z` ,,  .x####z   &quot;</a>
<a name="ln7524">      &quot;        @######@`  `W#;  `W############*            *###;&quot;, a);</a>
<a name="ln7525">  msg(&quot;      `@#########Mi,:*n@####W`   &quot;</a>
<a name="ln7526">      &quot;        W#######*   ..  `n#############i            i###x&quot;, a);</a>
<a name="ln7527">  msg(&quot;      .#####################z    &quot;</a>
<a name="ln7528">      &quot;       `@#######@*`    .x############n:`            ;####.&quot;, a);</a>
<a name="ln7529">  msg(&quot;      :####################x`,,` &quot;</a>
<a name="ln7530">      &quot;       `W#########@x#+#@#############i              ,####:&quot;, a);</a>
<a name="ln7531">  msg(&quot;      ;###################x#@###x&quot;</a>
<a name="ln7532">      &quot;i`      *############################:              `####i&quot;, a);</a>
<a name="ln7533">  msg(&quot;      i##################+#######&quot;</a>
<a name="ln7534">      &quot;#M,      x##########################@`               W###i&quot;, a);</a>
<a name="ln7535">  msg(&quot;      *################@; @######&quot;</a>
<a name="ln7536">      &quot;##@,     .W#########################@                x###:&quot;, a);</a>
<a name="ln7537">  msg(&quot;      .+M#############z.  M######&quot;</a>
<a name="ln7538">      &quot;###x      ,W########################@`               ####.&quot;, a);</a>
<a name="ln7539">  msg(&quot;      *M*;z@########x:    :W#####&quot;</a>
<a name="ln7540">      &quot;##i        .M########################i               i###:&quot;, a);</a>
<a name="ln7541">  msg(&quot;      *##@z;#@####x:        :z###&quot;</a>
<a name="ln7542">      &quot;@i          `########################x               .###;&quot;, a);</a>
<a name="ln7543">  msg(&quot;      *#####n;#@##            ;##&quot;</a>
<a name="ln7544">      &quot;*             ,x#####################@`               W##*&quot;, a);</a>
<a name="ln7545">  msg(&quot;      *#######n;*            :M##&quot;</a>
<a name="ln7546">      &quot;W*,             *W####################`               n##z&quot;, a);</a>
<a name="ln7547">  msg(&quot;      i########@.         ,*n####&quot;</a>
<a name="ln7548">      &quot;###M*`           `###################M                *##M&quot;, a);</a>
<a name="ln7549">  msg(&quot;      i########n        `z#####@@&quot;</a>
<a name="ln7550">      &quot;#####Wi            ,M################;                ,##@`&quot;, a);</a>
<a name="ln7551">  msg(&quot;      ;WMWW@###*       .x##@ni.``&quot;</a>
<a name="ln7552">      &quot;.:+zW##z`           `n##############z                  @##,&quot;, a);</a>
<a name="ln7553">  msg(&quot;      .*++*i;;;.      .M#@+`     &quot;</a>
<a name="ln7554">      &quot;     .##n            `x############x`                  n##i&quot;, a);</a>
<a name="ln7555">  msg(&quot;      :########*      x#W,       &quot;</a>
<a name="ln7556">      &quot;       *#+            *###########M`                   +##+&quot;, a);</a>
<a name="ln7557">  msg(&quot;      ,#########     :#@:        &quot;</a>
<a name="ln7558">      &quot;        ##:           #nzzzzzzzzzz.                    :##x&quot;, a);</a>
<a name="ln7559">  msg(&quot;      .#####Wz+`     ##+         &quot;</a>
<a name="ln7560">      &quot;        `MM`          .znnnnnnnnn.                     `@#@`&quot;, a);</a>
<a name="ln7561">  msg(&quot;      `@@ni;*nMz`    @W`         &quot;</a>
<a name="ln7562">      &quot;         :#+           .x#######n                       x##,&quot;, a);</a>
<a name="ln7563">  msg(&quot;       i;z@#####,   .#*          &quot;</a>
<a name="ln7564">      &quot;          z#:           ;;;*zW##;                       ###i&quot;, a);</a>
<a name="ln7565">  msg(&quot;       z########:   :#;          &quot;</a>
<a name="ln7566">      &quot;          `Wx          +###Wni;n.                       ;##z&quot;, a);</a>
<a name="ln7567">  msg(&quot;       n########W:  .#*          &quot;</a>
<a name="ln7568">      &quot;           ,#,        ;#######@+                        `@#M&quot;, a);</a>
<a name="ln7569">  msg(&quot;      .###########n;.MM          &quot;</a>
<a name="ln7570">      &quot;            n*        ;iM#######*                        x#@`&quot;, a);</a>
<a name="ln7571">  msg(&quot;      :#############@;;          &quot;</a>
<a name="ln7572">      &quot;            .n`      ,#W*iW#####W`                       +##,&quot;, a);</a>
<a name="ln7573">  msg(&quot;      ,##############.           &quot;</a>
<a name="ln7574">      &quot;             ix.    `x###M;#######                       ,##i&quot;, a);</a>
<a name="ln7575">  msg(&quot;      .#############@`           &quot;</a>
<a name="ln7576">      &quot;              x@n**#W######z;M###@.                       W##&quot;, a);</a>
<a name="ln7577">  msg(&quot;      .##############W:          &quot;</a>
<a name="ln7578">      &quot;              .x############@*;zW#;                       z#x&quot;, a);</a>
<a name="ln7579">  msg(&quot;      ,###############@;         &quot;</a>
<a name="ln7580">      &quot;               `##############@n*;.                       i#@&quot;, a);</a>
<a name="ln7581">  msg(&quot;      ,#################i        &quot;</a>
<a name="ln7582">      &quot;                 :n##############W`                       .##,&quot;, a);</a>
<a name="ln7583">  msg(&quot;      ,###################`      &quot;</a>
<a name="ln7584">      &quot;                   .+W##########W,                        `##i&quot;, a);</a>
<a name="ln7585">  msg(&quot;      :###################@zi,`  &quot;</a>
<a name="ln7586">      &quot;                      ;zM@@@WMn*`                          @#z&quot;, a);</a>
<a name="ln7587">  msg(&quot;      :#######################@x+&quot;</a>
<a name="ln7588">      &quot;*i;;:i#M,                 ``                               M#W&quot;, a);</a>
<a name="ln7589">  msg(&quot;      ;##########################&quot;</a>
<a name="ln7590">      &quot;######@x.                                                  n##,&quot;, a);</a>
<a name="ln7591">  msg(&quot;      i#####################@W@@@&quot;</a>
<a name="ln7592">      &quot;@Wxz*:`                                                    *##+&quot;, a);</a>
<a name="ln7593">  msg(&quot;      *######################+```&quot;</a>
<a name="ln7594">      &quot;                                                           :##M&quot;, a);</a>
<a name="ln7595">  msg(&quot;      ########################M; &quot;</a>
<a name="ln7596">      &quot;                                                           `@##,&quot;, a);</a>
<a name="ln7597">  msg(&quot;      z#########################x&quot;</a>
<a name="ln7598">      &quot;,                                                           z###&quot;, a);</a>
<a name="ln7599">  msg(&quot;      n##########################&quot;</a>
<a name="ln7600">      &quot;#n:                                                         ;##W`&quot;, a);</a>
<a name="ln7601">  msg(&quot;      x##########################&quot;</a>
<a name="ln7602">      &quot;###Mz#++##*                                                 `W##i&quot;, a);</a>
<a name="ln7603">  msg(&quot;      M##########################&quot;</a>
<a name="ln7604">      &quot;##########@`                                                 ###x&quot;, a);</a>
<a name="ln7605">  msg(&quot;      W##########################&quot;</a>
<a name="ln7606">      &quot;###########`                                                 .###,&quot;, a);</a>
<a name="ln7607">  msg(&quot;      @##########################&quot;</a>
<a name="ln7608">      &quot;##########M                                                   n##z&quot;, a);</a>
<a name="ln7609">  msg(&quot;      @##################z*i@WMMM&quot;</a>
<a name="ln7610">      &quot;x#x@#####,.                                                   :##@.&quot;, a);</a>
<a name="ln7611">  msg(&quot;     `#####################@xi`  &quot;</a>
<a name="ln7612">      &quot;   `::,*                                                       x##+&quot;, a);</a>
<a name="ln7613">  msg(&quot;     .#####################@#M.  &quot;</a>
<a name="ln7614">      &quot;                                                               ;##@`&quot;, a);</a>
<a name="ln7615">  msg(&quot;     ,#####################:.    &quot;</a>
<a name="ln7616">      &quot;                                                                M##i&quot;, a);</a>
<a name="ln7617">  msg(&quot;     ;###################ni`     &quot;</a>
<a name="ln7618">      &quot;                                                                i##M&quot;, a);</a>
<a name="ln7619">  msg(&quot;     *#################W#`       &quot;</a>
<a name="ln7620">      &quot;                                                                `W##,&quot;, a);</a>
<a name="ln7621">  msg(&quot;     z#################@Wx+.     &quot;</a>
<a name="ln7622">      &quot;                                                                 +###&quot;, a);</a>
<a name="ln7623">  msg(&quot;     x######################z.   &quot;</a>
<a name="ln7624">      &quot;                                                                 .@#@`&quot;, a);</a>
<a name="ln7625">  msg(&quot;    `@#######################@;  &quot;</a>
<a name="ln7626">      &quot;                                                                  z##;&quot;, a);</a>
<a name="ln7627">  msg(&quot;    :##########################: &quot;</a>
<a name="ln7628">      &quot;                                                                  :##z&quot;, a);</a>
<a name="ln7629">  msg(&quot;    +#########################W# &quot;</a>
<a name="ln7630">      &quot;                                                                   M#W&quot;, a);</a>
<a name="ln7631">  msg(&quot;    W################@n+*i;:,`                                &quot;</a>
<a name="ln7632">      &quot;                                      +##,&quot;, a);</a>
<a name="ln7633">  msg(&quot;   :##################WMxz+,                                  &quot;</a>
<a name="ln7634">      &quot;                                      ,##i&quot;, a);</a>
<a name="ln7635">  msg(&quot;   n#######################W..,                               &quot;</a>
<a name="ln7636">      &quot;                                       W##&quot;, a);</a>
<a name="ln7637">  msg(&quot;  +#########################WW@+. .:.                         &quot;</a>
<a name="ln7638">      &quot;                                       z#x&quot;, a);</a>
<a name="ln7639">  msg(&quot; `@#############################@@###:                        &quot;</a>
<a name="ln7640">      &quot;                                       *#W&quot;, a);</a>
<a name="ln7641">  msg(&quot; #################################Wz:                         &quot;</a>
<a name="ln7642">      &quot;                                       :#@&quot;, a);</a>
<a name="ln7643">  msg(&quot;,@###############################i                            &quot;</a>
<a name="ln7644">      &quot;                                       .##&quot;, a);</a>
<a name="ln7645">  msg(&quot;n@@@@@@@#########################+                            &quot;</a>
<a name="ln7646">      &quot;                                       `##&quot;, a);</a>
<a name="ln7647">  msg(&quot;`      `.:.`.,:iii;;;;;;;;iii;;;:`       `.``                 &quot;</a>
<a name="ln7648">      &quot;                                       `nW&quot;, a);</a>
<a name="ln7649">}</a>
<a name="ln7650"> </a>
<a name="ln7651">/// Get argt of command with id</a>
<a name="ln7652">uint32_t get_cmd_argt(cmdidx_T cmdidx)</a>
<a name="ln7653">{</a>
<a name="ln7654">  return cmdnames[(int)cmdidx].cmd_argt;</a>
<a name="ln7655">}</a>
</code></pre>
<div class="balloon" rel="3145"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'name == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>