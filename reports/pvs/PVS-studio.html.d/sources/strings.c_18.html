<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>strings.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;math.h&gt;</a>
<a name="ln7">#include &lt;stdarg.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;auto/config.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/assert.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln21">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln22">#include &quot;nvim/garray.h&quot;</a>
<a name="ln23">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln24">#include &quot;nvim/macros.h&quot;</a>
<a name="ln25">#include &quot;nvim/math.h&quot;</a>
<a name="ln26">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln27">#include &quot;nvim/memory.h&quot;</a>
<a name="ln28">#include &quot;nvim/message.h&quot;</a>
<a name="ln29">#include &quot;nvim/option.h&quot;</a>
<a name="ln30">#include &quot;nvim/plines.h&quot;</a>
<a name="ln31">#include &quot;nvim/strings.h&quot;</a>
<a name="ln32">#include &quot;nvim/types.h&quot;</a>
<a name="ln33">#include &quot;nvim/vim.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">/// Copy up to `len` bytes of `string` into newly allocated memory and</a>
<a name="ln36">/// terminate with a NUL. The allocated memory always has size `len + 1`, even</a>
<a name="ln37">/// when `string` is shorter.</a>
<a name="ln38">char *xstrnsave(const char *string, size_t len)</a>
<a name="ln39">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln40">{</a>
<a name="ln41">  return strncpy(xmallocz(len), string, len);  // NOLINT(runtime/printf)</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">// Same as vim_strsave(), but any characters found in esc_chars are preceded</a>
<a name="ln45">// by a backslash.</a>
<a name="ln46">char *vim_strsave_escaped(const char *string, const char *esc_chars)</a>
<a name="ln47">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln48">{</a>
<a name="ln49">  return vim_strsave_escaped_ext(string, esc_chars, '\\', false);</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">// Same as vim_strsave_escaped(), but when &quot;bsl&quot; is true also escape</a>
<a name="ln53">// characters where rem_backslash() would remove the backslash.</a>
<a name="ln54">// Escape the characters with &quot;cc&quot;.</a>
<a name="ln55">char *vim_strsave_escaped_ext(const char *string, const char *esc_chars, char cc, bool bsl)</a>
<a name="ln56">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln57">{</a>
<a name="ln58">  // First count the number of backslashes required.</a>
<a name="ln59">  // Then allocate the memory and insert them.</a>
<a name="ln60">  size_t length = 1;                    // count the trailing NUL</a>
<a name="ln61">  for (const char *p = string; *p; p++) {</a>
<a name="ln62">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln63">    if (l &gt; 1) {</a>
<a name="ln64">      length += l;                      // count a multibyte char</a>
<a name="ln65">      p += l - 1;</a>
<a name="ln66">      continue;</a>
<a name="ln67">    }</a>
<a name="ln68">    if (vim_strchr(esc_chars, (uint8_t)(*p)) != NULL || (bsl &amp;&amp; rem_backslash(p))) {</a>
<a name="ln69">      length++;                         // count a backslash</a>
<a name="ln70">    }</a>
<a name="ln71">    length++;                           // count an ordinary char</a>
<a name="ln72">  }</a>
<a name="ln73"> </a>
<a name="ln74">  char *escaped_string = xmalloc(length);</a>
<a name="ln75">  char *p2 = escaped_string;</a>
<a name="ln76">  for (const char *p = string; *p; p++) {</a>
<a name="ln77">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln78">    if (l &gt; 1) {</a>
<a name="ln79">      memcpy(p2, p, l);</a>
<a name="ln80">      p2 += l;</a>
<a name="ln81">      p += l - 1;                     // skip multibyte char</a>
<a name="ln82">      continue;</a>
<a name="ln83">    }</a>
<a name="ln84">    if (vim_strchr(esc_chars, (uint8_t)(*p)) != NULL || (bsl &amp;&amp; rem_backslash(p))) {</a>
<a name="ln85">      *p2++ = cc;</a>
<a name="ln86">    }</a>
<a name="ln87">    *p2++ = *p;</a>
<a name="ln88">  }</a>
<a name="ln89">  *p2 = NUL;</a>
<a name="ln90"> </a>
<a name="ln91">  return escaped_string;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">/// Save a copy of an unquoted string</a>
<a name="ln95">///</a>
<a name="ln96">/// Turns string like `a\bc&quot;def\&quot;ghi\\\n&quot;jkl` into `a\bcdef&quot;ghi\\njkl`, for use</a>
<a name="ln97">/// in shell_build_argv: the only purpose of backslash is making next character</a>
<a name="ln98">/// be treated literally inside the double quotes, if this character is</a>
<a name="ln99">/// backslash or quote.</a>
<a name="ln100">///</a>
<a name="ln101">/// @param[in]  string  String to copy.</a>
<a name="ln102">/// @param[in]  length  Length of the string to copy.</a>
<a name="ln103">///</a>
<a name="ln104">/// @return [allocated] Copy of the string.</a>
<a name="ln105">char *vim_strnsave_unquoted(const char *const string, const size_t length)</a>
<a name="ln106">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln107">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln108">{</a>
<a name="ln109">#define ESCAPE_COND(p, inquote, string_end) \</a>
<a name="ln110">  (*(p) == '\\' &amp;&amp; (inquote) &amp;&amp; (p) + 1 &lt; (string_end) &amp;&amp; ((p)[1] == '\\' || (p)[1] == '&quot;'))</a>
<a name="ln111">  size_t ret_length = 0;</a>
<a name="ln112">  bool inquote = false;</a>
<a name="ln113">  const char *const string_end = string + length;</a>
<a name="ln114">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln115">    if (*p == '&quot;') {</a>
<a name="ln116">      inquote = !inquote;</a>
<a name="ln117">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln118">      ret_length++;</a>
<a name="ln119">      p++;</a>
<a name="ln120">    } else {</a>
<a name="ln121">      ret_length++;</a>
<a name="ln122">    }</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  char *const ret = xmallocz(ret_length);</a>
<a name="ln126">  char *rp = ret;</a>
<a name="ln127">  inquote = false;</a>
<a name="ln128">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln129">    if (*p == '&quot;') {</a>
<a name="ln130">      inquote = !inquote;</a>
<a name="ln131">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln132">      *rp++ = *(++p);</a>
<a name="ln133">    } else {</a>
<a name="ln134">      *rp++ = *p;</a>
<a name="ln135">    }</a>
<a name="ln136">  }</a>
<a name="ln137">#undef ESCAPE_COND</a>
<a name="ln138"> </a>
<a name="ln139">  return ret;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/// Escape &quot;string&quot; for use as a shell argument with system().</a>
<a name="ln143">/// This uses single quotes, except when we know we need to use double quotes</a>
<a name="ln144">/// (MS-Windows without 'shellslash' set).</a>
<a name="ln145">/// Escape a newline, depending on the 'shell' option.</a>
<a name="ln146">/// When &quot;do_special&quot; is true also replace &quot;!&quot;, &quot;%&quot;, &quot;#&quot; and things starting</a>
<a name="ln147">/// with &quot;&lt;&quot; like &quot;&lt;cfile&gt;&quot;.</a>
<a name="ln148">/// When &quot;do_newline&quot; is false do not escape newline unless it is csh shell.</a>
<a name="ln149">///</a>
<a name="ln150">/// @return  the result in allocated memory.</a>
<a name="ln151">char *vim_strsave_shellescape(const char *string, bool do_special, bool do_newline)</a>
<a name="ln152">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln153">{</a>
<a name="ln154">  char *d;</a>
<a name="ln155">  char *escaped_string;</a>
<a name="ln156">  size_t l;</a>
<a name="ln157">  int csh_like;</a>
<a name="ln158">  bool fish_like;</a>
<a name="ln159"> </a>
<a name="ln160">  // Only csh and similar shells expand '!' within single quotes.  For sh and</a>
<a name="ln161">  // the like we must not put a backslash before it, it will be taken</a>
<a name="ln162">  // literally.  If do_special is set the '!' will be escaped twice.</a>
<a name="ln163">  // Csh also needs to have &quot;\n&quot; escaped twice when do_special is set.</a>
<a name="ln164">  csh_like = csh_like_shell();</a>
<a name="ln165"> </a>
<a name="ln166">  // Fish shell uses '\' as an escape character within single quotes, so '\'</a>
<a name="ln167">  // itself must be escaped to get a literal '\'.</a>
<a name="ln168">  fish_like = fish_like_shell();</a>
<a name="ln169"> </a>
<a name="ln170">  // First count the number of extra bytes required.</a>
<a name="ln171">  size_t length = strlen(string) + 3;       // two quotes and a trailing NUL</a>
<a name="ln172">  for (const char *p = string; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln173">#ifdef MSWIN</a>
<a name="ln174">    if (!p_ssl) {</a>
<a name="ln175">      if (*p == '&quot;') {</a>
<a name="ln176">        length++;                       // &quot; -&gt; &quot;&quot;</a>
<a name="ln177">      }</a>
<a name="ln178">    } else</a>
<a name="ln179">#endif</a>
<a name="ln180">    if (*p == '\'') {</a>
<a name="ln181">      length += 3;                      // ' =&gt; '\''</a>
<a name="ln182">    }</a>
<a name="ln183">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln184">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln185">      length++;                         // insert backslash</a>
<a name="ln186">      if (csh_like &amp;&amp; do_special) {</a>
<a name="ln187">        length++;                       // insert backslash</a>
<a name="ln188">      }</a>
<a name="ln189">    }</a>
<a name="ln190">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln191">      length++;                         // insert backslash</a>
<a name="ln192">      p += l - 1;</a>
<a name="ln193">    }</a>
<a name="ln194">    if (*p == '\\' &amp;&amp; fish_like) {</a>
<a name="ln195">      length++;  // insert backslash</a>
<a name="ln196">    }</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  // Allocate memory for the result and fill it.</a>
<a name="ln200">  escaped_string = xmalloc(length);</a>
<a name="ln201">  d = escaped_string;</a>
<a name="ln202"> </a>
<a name="ln203">  // add opening quote</a>
<a name="ln204">#ifdef MSWIN</a>
<a name="ln205">  if (!p_ssl) {</a>
<a name="ln206">    *d++ = '&quot;';</a>
<a name="ln207">  } else</a>
<a name="ln208">#endif</a>
<a name="ln209">  *d++ = '\'';</a>
<a name="ln210"> </a>
<a name="ln211">  for (const char *p = string; *p != NUL;) {</a>
<a name="ln212">#ifdef MSWIN</a>
<a name="ln213">    if (!p_ssl) {</a>
<a name="ln214">      if (*p == '&quot;') {</a>
<a name="ln215">        *d++ = '&quot;';</a>
<a name="ln216">        *d++ = '&quot;';</a>
<a name="ln217">        p++;</a>
<a name="ln218">        continue;</a>
<a name="ln219">      }</a>
<a name="ln220">    } else</a>
<a name="ln221">#endif</a>
<a name="ln222">    if (*p == '\'') {</a>
<a name="ln223">      *d++ = '\'';</a>
<a name="ln224">      *d++ = '\\';</a>
<a name="ln225">      *d++ = '\'';</a>
<a name="ln226">      *d++ = '\'';</a>
<a name="ln227">      p++;</a>
<a name="ln228">      continue;</a>
<a name="ln229">    }</a>
<a name="ln230">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln231">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln232">      *d++ = '\\';</a>
<a name="ln233">      if (csh_like &amp;&amp; do_special) {</a>
<a name="ln234">        *d++ = '\\';</a>
<a name="ln235">      }</a>
<a name="ln236">      *d++ = *p++;</a>
<a name="ln237">      continue;</a>
<a name="ln238">    }</a>
<a name="ln239">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln240">      *d++ = '\\';                    // insert backslash</a>
<a name="ln241">      while (--l != SIZE_MAX) {  // copy the var</a>
<a name="ln242">        *d++ = *p++;</a>
<a name="ln243">      }</a>
<a name="ln244">      continue;</a>
<a name="ln245">    }</a>
<a name="ln246">    if (*p == '\\' &amp;&amp; fish_like) {</a>
<a name="ln247">      *d++ = '\\';</a>
<a name="ln248">      *d++ = *p++;</a>
<a name="ln249">      continue;</a>
<a name="ln250">    }</a>
<a name="ln251"> </a>
<a name="ln252">    mb_copy_char(&amp;p, &amp;d);</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  // add terminating quote and finish with a NUL</a>
<a name="ln256">#ifdef MSWIN</a>
<a name="ln257">  if (!p_ssl) {</a>
<a name="ln258">    *d++ = '&quot;';</a>
<a name="ln259">  } else</a>
<a name="ln260">#endif</a>
<a name="ln261">  *d++ = '\'';</a>
<a name="ln262">  *d = NUL;</a>
<a name="ln263"> </a>
<a name="ln264">  return escaped_string;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">// Like vim_strsave(), but make all characters uppercase.</a>
<a name="ln268">// This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln269">char *vim_strsave_up(const char *string)</a>
<a name="ln270">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln271">{</a>
<a name="ln272">  char *p1;</a>
<a name="ln273"> </a>
<a name="ln274">  p1 = xstrdup(string);</a>
<a name="ln275">  vim_strup(p1);</a>
<a name="ln276">  return p1;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">/// Like xstrnsave(), but make all characters uppercase.</a>
<a name="ln280">/// This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln281">char *vim_strnsave_up(const char *string, size_t len)</a>
<a name="ln282">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln283">{</a>
<a name="ln284">  char *p1 = xstrnsave(string, len);</a>
<a name="ln285">  vim_strup(p1);</a>
<a name="ln286">  return p1;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">// ASCII lower-to-upper case translation, language independent.</a>
<a name="ln290">void vim_strup(char *p)</a>
<a name="ln291">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln292">{</a>
<a name="ln293">  uint8_t c;</a>
<a name="ln294">  while ((c = (uint8_t)(*p)) != NUL) {</a>
<a name="ln295">    *p++ = (char)(uint8_t)(c &lt; 'a' || c &gt; 'z' ? c : c - 0x20);</a>
<a name="ln296">  }</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">/// Make given string all upper-case or all lower-case</a>
<a name="ln300">///</a>
<a name="ln301">/// Handles multi-byte characters as good as possible.</a>
<a name="ln302">///</a>
<a name="ln303">/// @param[in]  orig  Input string.</a>
<a name="ln304">/// @param[in]  upper If true make uppercase, otherwise lowercase</a>
<a name="ln305">///</a>
<a name="ln306">/// @return [allocated] upper-cased string.</a>
<a name="ln307">char *strcase_save(const char *const orig, bool upper)</a>
<a name="ln308">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln309">{</a>
<a name="ln310">  char *res = xstrdup(orig);</a>
<a name="ln311"> </a>
<a name="ln312">  char *p = res;</a>
<a name="ln313">  while (*p != NUL) {</a>
<a name="ln314">    int c = utf_ptr2char(p);</a>
<a name="ln315">    int l = utf_ptr2len(p);</a>
<a name="ln316">    if (c == 0) {</a>
<a name="ln317">      // overlong sequence, use only the first byte</a>
<a name="ln318">      c = (uint8_t)(*p);</a>
<a name="ln319">      l = 1;</a>
<a name="ln320">    }</a>
<a name="ln321">    int uc = upper ? mb_toupper(c) : mb_tolower(c);</a>
<a name="ln322"> </a>
<a name="ln323">    // Reallocate string when byte count changes.  This is rare,</a>
<a name="ln324">    // thus it's OK to do another malloc()/free().</a>
<a name="ln325">    int newl = utf_char2len(uc);</a>
<a name="ln326">    if (newl != l) {</a>
<a name="ln327">      // TODO(philix): use xrealloc() in strcase_save()</a>
<a name="ln328">      char *s = xmalloc(strlen(res) + (size_t)(1 + newl - l));</a>
<a name="ln329">      memcpy(s, res, (size_t)(p - res));</a>
<a name="ln330">      STRCPY(s + (p - res) + newl, p + l);</a>
<a name="ln331">      p = s + (p - res);</a>
<a name="ln332">      xfree(res);</a>
<a name="ln333">      res = s;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">    utf_char2bytes(uc, p);</a>
<a name="ln337">    p += newl;</a>
<a name="ln338">  }</a>
<a name="ln339"> </a>
<a name="ln340">  return res;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">// delete spaces at the end of a string</a>
<a name="ln344">void del_trailing_spaces(char *ptr)</a>
<a name="ln345">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln346">{</a>
<a name="ln347">  char *q;</a>
<a name="ln348"> </a>
<a name="ln349">  q = ptr + strlen(ptr);</a>
<a name="ln350">  while (--q &gt; ptr &amp;&amp; ascii_iswhite(q[0]) &amp;&amp; q[-1] != '\\' &amp;&amp; q[-1] != Ctrl_V) {</a>
<a name="ln351">    *q = NUL;</a>
<a name="ln352">  }</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">#if !defined(HAVE_STRNLEN)</a>
<a name="ln356">size_t xstrnlen(const char *s, size_t n)</a>
<a name="ln357">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln358">{</a>
<a name="ln359">  const char *end = memchr(s, '\0', n);</a>
<a name="ln360">  if (end == NULL) {</a>
<a name="ln361">    return n;</a>
<a name="ln362">  }</a>
<a name="ln363">  return (size_t)(end - s);</a>
<a name="ln364">}</a>
<a name="ln365">#endif</a>
<a name="ln366"> </a>
<a name="ln367">#if (!defined(HAVE_STRCASECMP) &amp;&amp; !defined(HAVE_STRICMP))</a>
<a name="ln368">// Compare two strings, ignoring case, using current locale.</a>
<a name="ln369">// Doesn't work for multi-byte characters.</a>
<a name="ln370">// return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln371">int vim_stricmp(const char *s1, const char *s2)</a>
<a name="ln372">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln373">{</a>
<a name="ln374">  int i;</a>
<a name="ln375"> </a>
<a name="ln376">  while (true) {</a>
<a name="ln377">    i = (int)TOLOWER_LOC((uint8_t)(*s1)) - (int)TOLOWER_LOC((uint8_t)(*s2));</a>
<a name="ln378">    if (i != 0) {</a>
<a name="ln379">      return i;                             // this character different</a>
<a name="ln380">    }</a>
<a name="ln381">    if (*s1 == NUL) {</a>
<a name="ln382">      break;                                // strings match until NUL</a>
<a name="ln383">    }</a>
<a name="ln384">    s1++;</a>
<a name="ln385">    s2++;</a>
<a name="ln386">  }</a>
<a name="ln387">  return 0;                                 // strings match</a>
<a name="ln388">}</a>
<a name="ln389">#endif</a>
<a name="ln390"> </a>
<a name="ln391">#if (!defined(HAVE_STRNCASECMP) &amp;&amp; !defined(HAVE_STRNICMP))</a>
<a name="ln392">// Compare two strings, for length &quot;len&quot;, ignoring case, using current locale.</a>
<a name="ln393">// Doesn't work for multi-byte characters.</a>
<a name="ln394">// return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln395">int vim_strnicmp(const char *s1, const char *s2, size_t len)</a>
<a name="ln396">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln397">{</a>
<a name="ln398">  int i;</a>
<a name="ln399"> </a>
<a name="ln400">  while (len &gt; 0) {</a>
<a name="ln401">    i = (int)TOLOWER_LOC((uint8_t)(*s1)) - (int)TOLOWER_LOC((uint8_t)(*s2));</a>
<a name="ln402">    if (i != 0) {</a>
<a name="ln403">      return i;                             // this character different</a>
<a name="ln404">    }</a>
<a name="ln405">    if (*s1 == NUL) {</a>
<a name="ln406">      break;                                // strings match until NUL</a>
<a name="ln407">    }</a>
<a name="ln408">    s1++;</a>
<a name="ln409">    s2++;</a>
<a name="ln410">    len--;</a>
<a name="ln411">  }</a>
<a name="ln412">  return 0;                                 // strings match</a>
<a name="ln413">}</a>
<a name="ln414">#endif</a>
<a name="ln415"> </a>
<a name="ln416">/// strchr() version which handles multibyte strings</a>
<a name="ln417">///</a>
<a name="ln418">/// @param[in]  string  String to search in.</a>
<a name="ln419">/// @param[in]  c  Character to search for.</a>
<a name="ln420">///</a>
<a name="ln421">/// @return Pointer to the first byte of the found character in string or NULL</a>
<a name="ln422">///         if it was not found or character is invalid. NUL character is never</a>
<a name="ln423">///         found, use `strlen()` instead.</a>
<a name="ln424">char *vim_strchr(const char *const string, const int c)</a>
<a name="ln425">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln426">{</a>
<a name="ln427">  if (c &lt;= 0) {</a>
<a name="ln428">    return NULL;</a>
<a name="ln429">  } else if (c &lt; 0x80) {</a>
<a name="ln430">    return strchr(string, c);</a>
<a name="ln431">  } else {</a>
<a name="ln432">    char u8char[MB_MAXBYTES + 1];</a>
<a name="ln433">    const int len = utf_char2bytes(c, u8char);</a>
<a name="ln434">    u8char[len] = NUL;</a>
<a name="ln435">    return strstr(string, u8char);</a>
<a name="ln436">  }</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">// Sort an array of strings.</a>
<a name="ln440"> </a>
<a name="ln441">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln442"># include &quot;strings.c.generated.h&quot;</a>
<a name="ln443">#endif</a>
<a name="ln444">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln445">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln446">{</a>
<a name="ln447">  return strcmp(*(char **)s1, *(char **)s2);</a>
<a name="ln448">}</a>
<a name="ln449"> </a>
<a name="ln450">void sort_strings(char **files, int count)</a>
<a name="ln451">{</a>
<a name="ln452">  qsort((void *)files, (size_t)count, sizeof(char *), sort_compare);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">// Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln456">// When &quot;s&quot; is NULL false is returned.</a>
<a name="ln457">bool has_non_ascii(const char *s)</a>
<a name="ln458">  FUNC_ATTR_PURE</a>
<a name="ln459">{</a>
<a name="ln460">  const char *p;</a>
<a name="ln461"> </a>
<a name="ln462">  if (s != NULL) {</a>
<a name="ln463">    for (p = s; *p != NUL; p++) {</a>
<a name="ln464">      if ((uint8_t)(*p) &gt;= 128) {</a>
<a name="ln465">        return true;</a>
<a name="ln466">      }</a>
<a name="ln467">    }</a>
<a name="ln468">  }</a>
<a name="ln469">  return false;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/// Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln473">/// When &quot;s&quot; is NULL false is returned.</a>
<a name="ln474">bool has_non_ascii_len(const char *const s, const size_t len)</a>
<a name="ln475">  FUNC_ATTR_PURE</a>
<a name="ln476">{</a>
<a name="ln477">  if (s != NULL) {</a>
<a name="ln478">    for (size_t i = 0; i &lt; len; i++) {</a>
<a name="ln479">      if ((uint8_t)s[i] &gt;= 128) {</a>
<a name="ln480">        return true;</a>
<a name="ln481">      }</a>
<a name="ln482">    }</a>
<a name="ln483">  }</a>
<a name="ln484">  return false;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/// Concatenate two strings and return the result in allocated memory.</a>
<a name="ln488">char *concat_str(const char *restrict str1, const char *restrict str2)</a>
<a name="ln489">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln490">{</a>
<a name="ln491">  size_t l = strlen(str1);</a>
<a name="ln492">  char *dest = xmalloc(l + strlen(str2) + 1);</a>
<a name="ln493">  STRCPY(dest, str1);</a>
<a name="ln494">  STRCPY(dest + l, str2);</a>
<a name="ln495">  return dest;</a>
<a name="ln496">}</a>
<a name="ln497"> </a>
<a name="ln498">static const char *const e_printf =</a>
<a name="ln499">  N_(&quot;E766: Insufficient arguments for printf()&quot;);</a>
<a name="ln500"> </a>
<a name="ln501">/// Get number argument from idxp entry in tvs</a>
<a name="ln502">///</a>
<a name="ln503">/// Will give an error message for Vimscript entry with invalid type or for insufficient entries.</a>
<a name="ln504">///</a>
<a name="ln505">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.</a>
<a name="ln506">/// @param[in,out]  idxp  Index in a list. Will be incremented. Indexing starts at 1.</a>
<a name="ln507">///</a>
<a name="ln508">/// @return Number value or 0 in case of error.</a>
<a name="ln509">static varnumber_T tv_nr(typval_T *tvs, int *idxp)</a>
<a name="ln510">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln511">{</a>
<a name="ln512">  int idx = *idxp - 1;</a>
<a name="ln513">  varnumber_T n = 0;</a>
<a name="ln514"> </a>
<a name="ln515">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln516">    emsg(_(e_printf));</a>
<a name="ln517">  } else {</a>
<a name="ln518">    (*idxp)++;</a>
<a name="ln519">    bool err = false;</a>
<a name="ln520">    n = tv_get_number_chk(&amp;tvs[idx], &amp;err);</a>
<a name="ln521">    if (err) {</a>
<a name="ln522">      n = 0;</a>
<a name="ln523">    }</a>
<a name="ln524">  }</a>
<a name="ln525">  return n;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">/// Get string argument from idxp entry in tvs</a>
<a name="ln529">///</a>
<a name="ln530">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln531">/// insufficient entries.</a>
<a name="ln532">///</a>
<a name="ln533">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN</a>
<a name="ln534">///                  value.</a>
<a name="ln535">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln536">/// @param[out]  tofree  If the idxp entry in tvs is not a String or a Number,</a>
<a name="ln537">///                      it will be converted to String in the same format</a>
<a name="ln538">///                      as &quot;:echo&quot; and stored in &quot;*tofree&quot;. The caller must</a>
<a name="ln539">///                      free &quot;*tofree&quot;.</a>
<a name="ln540">///</a>
<a name="ln541">/// @return String value or NULL in case of error.</a>
<a name="ln542">static const char *tv_str(typval_T *tvs, int *idxp, char **const tofree)</a>
<a name="ln543">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln544">{</a>
<a name="ln545">  int idx = *idxp - 1;</a>
<a name="ln546">  const char *s = NULL;</a>
<a name="ln547"> </a>
<a name="ln548">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln549">    emsg(_(e_printf));</a>
<a name="ln550">  } else {</a>
<a name="ln551">    (*idxp)++;</a>
<a name="ln552">    if (tvs[idx].v_type == VAR_STRING || tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln553">      s = tv_get_string_chk(&amp;tvs[idx]);</a>
<a name="ln554">      *tofree = NULL;</a>
<a name="ln555">    } else {</a>
<a name="ln556">      s = *tofree = encode_tv2echo(&amp;tvs[idx], NULL);</a>
<a name="ln557">    }</a>
<a name="ln558">  }</a>
<a name="ln559">  return s;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/// Get pointer argument from the next entry in tvs</a>
<a name="ln563">///</a>
<a name="ln564">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln565">/// insufficient entries.</a>
<a name="ln566">///</a>
<a name="ln567">/// @param[in]  tvs  List of typval_T values.</a>
<a name="ln568">/// @param[in,out]  idxp  Pointer to the index of the current value.</a>
<a name="ln569">///</a>
<a name="ln570">/// @return Pointer stored in typval_T or NULL.</a>
<a name="ln571">static const void *tv_ptr(const typval_T *const tvs, int *const idxp)</a>
<a name="ln572">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln573">{</a>
<a name="ln574">#define OFF(attr) offsetof(union typval_vval_union, attr)</a>
<a name="ln575">  STATIC_ASSERT(OFF(v_string) == OFF(v_list)  // -V568</a>
<a name="ln576">                &amp;&amp; OFF(v_string) == OFF(v_dict)</a>
<a name="ln577">                &amp;&amp; OFF(v_string) == OFF(v_partial)</a>
<a name="ln578">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_list)</a>
<a name="ln579">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_dict)</a>
<a name="ln580">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_partial),</a>
<a name="ln581">                &quot;Strings, dictionaries, lists and partials are expected to be pointers, &quot;</a>
<a name="ln582">                &quot;so that all three of them can be accessed via v_string&quot;);</a>
<a name="ln583">#undef OFF</a>
<a name="ln584">  const int idx = *idxp - 1;</a>
<a name="ln585">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln586">    emsg(_(e_printf));</a>
<a name="ln587">    return NULL;</a>
<a name="ln588">  }</a>
<a name="ln589">  (*idxp)++;</a>
<a name="ln590">  return tvs[idx].vval.v_string;</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">/// Get float argument from idxp entry in tvs</a>
<a name="ln594">///</a>
<a name="ln595">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln596">/// insufficient entries.</a>
<a name="ln597">///</a>
<a name="ln598">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.</a>
<a name="ln599">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln600">///</a>
<a name="ln601">/// @return Floating-point value or zero in case of error.</a>
<a name="ln602">static float_T tv_float(typval_T *const tvs, int *const idxp)</a>
<a name="ln603">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln604">{</a>
<a name="ln605">  int idx = *idxp - 1;</a>
<a name="ln606">  float_T f = 0;</a>
<a name="ln607"> </a>
<a name="ln608">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln609">    emsg(_(e_printf));</a>
<a name="ln610">  } else {</a>
<a name="ln611">    (*idxp)++;</a>
<a name="ln612">    if (tvs[idx].v_type == VAR_FLOAT) {</a>
<a name="ln613">      f = tvs[idx].vval.v_float;</a>
<a name="ln614">    } else if (tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln615">      f = (float_T)tvs[idx].vval.v_number;</a>
<a name="ln616">    } else {</a>
<a name="ln617">      emsg(_(&quot;E807: Expected Float argument for printf()&quot;));</a>
<a name="ln618">    }</a>
<a name="ln619">  }</a>
<a name="ln620">  return f;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">// This code was included to provide a portable vsnprintf() and snprintf().</a>
<a name="ln624">// Some systems may provide their own, but we always use this one for</a>
<a name="ln625">// consistency.</a>
<a name="ln626">//</a>
<a name="ln627">// This code is based on snprintf.c - a portable implementation of snprintf</a>
<a name="ln628">// by Mark Martinec &lt;mark.martinec@ijs.si&gt;, Version 2.2, 2000-10-06.</a>
<a name="ln629">// Included with permission.  It was heavily modified to fit in Vim.</a>
<a name="ln630">// The original code, including useful comments, can be found here:</a>
<a name="ln631">//</a>
<a name="ln632">//     http://www.ijs.si/software/snprintf/</a>
<a name="ln633">//</a>
<a name="ln634">// This snprintf() only supports the following conversion specifiers:</a>
<a name="ln635">// s, c, b, B, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)</a>
<a name="ln636">// with flags: '-', '+', ' ', '0' and '#'.</a>
<a name="ln637">// An asterisk is supported for field width as well as precision.</a>
<a name="ln638">//</a>
<a name="ln639">// Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.</a>
<a name="ln640">//</a>
<a name="ln641">// Length modifiers 'h' (short int), 'l' (long int) and &quot;ll&quot; (long long int) are</a>
<a name="ln642">// supported.</a>
<a name="ln643">//</a>
<a name="ln644">// The locale is not used, the string is used as a byte string.  This is only</a>
<a name="ln645">// relevant for double-byte encodings where the second byte may be '%'.</a>
<a name="ln646">//</a>
<a name="ln647">// It is permitted for &quot;str_m&quot; to be zero, and it is permitted to specify NULL</a>
<a name="ln648">// pointer for resulting string argument if &quot;str_m&quot; is zero (as per ISO C99).</a>
<a name="ln649">//</a>
<a name="ln650">// The return value is the number of characters which would be generated</a>
<a name="ln651">// for the given input, excluding the trailing NUL. If this value</a>
<a name="ln652">// is greater or equal to &quot;str_m&quot;, not all characters from the result</a>
<a name="ln653">// have been stored in str, output bytes beyond the (&quot;str_m&quot;-1) -th character</a>
<a name="ln654">// are discarded. If &quot;str_m&quot; is greater than zero it is guaranteed</a>
<a name="ln655">// the resulting string will be NUL-terminated.</a>
<a name="ln656"> </a>
<a name="ln657">// vim_vsnprintf_typval() can be invoked with either &quot;va_list&quot; or a list of</a>
<a name="ln658">// &quot;typval_T&quot;.  When the latter is not used it must be NULL.</a>
<a name="ln659"> </a>
<a name="ln660">/// Append a formatted value to the string</a>
<a name="ln661">///</a>
<a name="ln662">/// @see vim_vsnprintf_typval().</a>
<a name="ln663">int vim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)</a>
<a name="ln664">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln665">{</a>
<a name="ln666">  const size_t len = strlen(str);</a>
<a name="ln667">  size_t space;</a>
<a name="ln668"> </a>
<a name="ln669">  if (str_m &lt;= len) {</a>
<a name="ln670">    space = 0;</a>
<a name="ln671">  } else {</a>
<a name="ln672">    space = str_m - len;</a>
<a name="ln673">  }</a>
<a name="ln674">  va_list ap;</a>
<a name="ln675">  va_start(ap, fmt);</a>
<a name="ln676">  const int str_l = vim_vsnprintf(str + len, space, fmt, ap);</a>
<a name="ln677">  va_end(ap);</a>
<a name="ln678">  return str_l;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">/// Write formatted value to the string</a>
<a name="ln682">///</a>
<a name="ln683">/// @param[out]  str  String to write to.</a>
<a name="ln684">/// @param[in]  str_m  String length.</a>
<a name="ln685">/// @param[in]  fmt  String format.</a>
<a name="ln686">///</a>
<a name="ln687">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln688">///         string if str_m was greater or equal to the return value.</a>
<a name="ln689">int vim_snprintf(char *str, size_t str_m, const char *fmt, ...)</a>
<a name="ln690">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln691">{</a>
<a name="ln692">  va_list ap;</a>
<a name="ln693">  va_start(ap, fmt);</a>
<a name="ln694">  const int str_l = vim_vsnprintf(str, str_m, fmt, ap);</a>
<a name="ln695">  va_end(ap);</a>
<a name="ln696">  return str_l;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">// Return the representation of infinity for printf() function:</a>
<a name="ln700">// &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;, &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot; or &quot; INF&quot;.</a>
<a name="ln701">static const char *infinity_str(bool positive, char fmt_spec, int force_sign,</a>
<a name="ln702">                                int space_for_positive)</a>
<a name="ln703">{</a>
<a name="ln704">  static const char *table[] = {</a>
<a name="ln705">    &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;,</a>
<a name="ln706">    &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot;, &quot; INF&quot;</a>
<a name="ln707">  };</a>
<a name="ln708">  int idx = positive * (1 + force_sign + force_sign * space_for_positive);</a>
<a name="ln709">  if (ASCII_ISUPPER(fmt_spec)) {</a>
<a name="ln710">    idx += 4;</a>
<a name="ln711">  }</a>
<a name="ln712">  return table[idx];</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap)</a>
<a name="ln716">{</a>
<a name="ln717">  return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">/// Write formatted value to the string</a>
<a name="ln721">///</a>
<a name="ln722">/// @param[out]  str  String to write to.</a>
<a name="ln723">/// @param[in]  str_m  String length.</a>
<a name="ln724">/// @param[in]  fmt  String format.</a>
<a name="ln725">/// @param[in]  ap  Values that should be formatted. Ignored if tvs is not NULL.</a>
<a name="ln726">/// @param[in]  tvs  Values that should be formatted, for printf() Vimscript</a>
<a name="ln727">///                  function. Must be NULL in other cases.</a>
<a name="ln728">///</a>
<a name="ln729">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln730">///         string if str_m was greater or equal to the return value.</a>
<a name="ln731">int vim_vsnprintf_typval(char *str, size_t str_m, const char *fmt, va_list ap, typval_T *const tvs)</a>
<a name="ln732">{</a>
<a name="ln733">  size_t str_l = 0;</a>
<a name="ln734">  bool str_avail = str_l &lt; str_m;</a>
<a name="ln735">  const char *p = fmt;</a>
<a name="ln736">  int arg_idx = 1;</a>
<a name="ln737"> </a>
<a name="ln738">  if (!p) {</a>
<a name="ln739">    p = &quot;&quot;;</a>
<a name="ln740">  }</a>
<a name="ln741">  while (*p) {</a>
<a name="ln742">    if (*p != '%') {</a>
<a name="ln743">      // copy up to the next '%' or NUL without any changes</a>
<a name="ln744">      size_t n = (size_t)(xstrchrnul(p + 1, '%') - p);</a>
<a name="ln745">      if (str_avail) {</a>
<a name="ln746">        size_t avail = str_m - str_l;</a>
<a name="ln747">        memmove(str + str_l, p, MIN(n, avail));</a>
<a name="ln748">        str_avail = n &lt; avail;</a>
<a name="ln749">      }</a>
<a name="ln750">      p += n;</a>
<a name="ln751">      assert(n &lt;= SIZE_MAX - str_l);</a>
<a name="ln752">      str_l += n;</a>
<a name="ln753">    } else {</a>
<a name="ln754">      size_t min_field_width = 0, precision = 0;</a>
<a name="ln755">      int zero_padding = 0, precision_specified = 0, justify_left = 0;</a>
<a name="ln756">      int alternate_form = 0, force_sign = 0;</a>
<a name="ln757"> </a>
<a name="ln758">      // if both ' ' and '+' flags appear, ' ' flag should be ignored</a>
<a name="ln759">      int space_for_positive = 1;</a>
<a name="ln760"> </a>
<a name="ln761">      // allowed values: \0, h, l, 2 (for ll), z, L</a>
<a name="ln762">      char length_modifier = '\0';</a>
<a name="ln763"> </a>
<a name="ln764">      // temporary buffer for simple numeric-&gt;string conversion</a>
<a name="ln765">#define TMP_LEN 350    // 1e308 seems reasonable as the maximum printable</a>
<a name="ln766">      char tmp[TMP_LEN];</a>
<a name="ln767"> </a>
<a name="ln768">      // string address in case of string argument</a>
<a name="ln769">      const char *str_arg = NULL;</a>
<a name="ln770"> </a>
<a name="ln771">      // natural field width of arg without padding and sign</a>
<a name="ln772">      size_t str_arg_l;</a>
<a name="ln773"> </a>
<a name="ln774">      // unsigned char argument value (only defined for c conversion);</a>
<a name="ln775">      // standard explicitly states the char argument for the c</a>
<a name="ln776">      // conversion is unsigned</a>
<a name="ln777">      unsigned char uchar_arg;</a>
<a name="ln778"> </a>
<a name="ln779">      // number of zeros to be inserted for numeric conversions as</a>
<a name="ln780">      // required by the precision or minimal field width</a>
<a name="ln781">      size_t number_of_zeros_to_pad = 0;</a>
<a name="ln782"> </a>
<a name="ln783">      // index into tmp where zero padding is to be inserted</a>
<a name="ln784">      size_t zero_padding_insertion_ind = 0;</a>
<a name="ln785"> </a>
<a name="ln786">      // current conversion specifier character</a>
<a name="ln787">      char fmt_spec = '\0';</a>
<a name="ln788"> </a>
<a name="ln789">      // buffer for 's' and 'S' specs</a>
<a name="ln790">      char *tofree = NULL;</a>
<a name="ln791"> </a>
<a name="ln792">      p++;  // skip '%'</a>
<a name="ln793"> </a>
<a name="ln794">      // parse flags</a>
<a name="ln795">      while (true) {</a>
<a name="ln796">        switch (*p) {</a>
<a name="ln797">        case '0':</a>
<a name="ln798">          zero_padding = 1; p++; continue;</a>
<a name="ln799">        case '-':</a>
<a name="ln800">          justify_left = 1; p++; continue;</a>
<a name="ln801">        // if both '0' and '-' flags appear, '0' should be ignored</a>
<a name="ln802">        case '+':</a>
<a name="ln803">          force_sign = 1; space_for_positive = 0; p++; continue;</a>
<a name="ln804">        case ' ':</a>
<a name="ln805">          force_sign = 1; p++; continue;</a>
<a name="ln806">        // if both ' ' and '+' flags appear, ' ' should be ignored</a>
<a name="ln807">        case '#':</a>
<a name="ln808">          alternate_form = 1; p++; continue;</a>
<a name="ln809">        case '\'':</a>
<a name="ln810">          p++; continue;</a>
<a name="ln811">        default:</a>
<a name="ln812">          break;</a>
<a name="ln813">        }</a>
<a name="ln814">        break;</a>
<a name="ln815">      }</a>
<a name="ln816"> </a>
<a name="ln817">      // parse field width</a>
<a name="ln818">      if (*p == '*') {</a>
<a name="ln819">        p++;</a>
<a name="ln820">        const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln821">        if (j &gt;= 0) {</a>
<a name="ln822">          min_field_width = (size_t)j;</a>
<a name="ln823">        } else {</a>
<a name="ln824">          min_field_width = (size_t)-j;</a>
<a name="ln825">          justify_left = 1;</a>
<a name="ln826">        }</a>
<a name="ln827">      } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln828">        // size_t could be wider than unsigned int; make sure we treat</a>
<a name="ln829">        // argument like common implementations do</a>
<a name="ln830">        unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln831"> </a>
<a name="ln832">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln833">          uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln834">        }</a>
<a name="ln835">        min_field_width = uj;</a>
<a name="ln836">      }</a>
<a name="ln837"> </a>
<a name="ln838">      // parse precision</a>
<a name="ln839">      if (*p == '.') {</a>
<a name="ln840">        p++;</a>
<a name="ln841">        precision_specified = 1;</a>
<a name="ln842">        if (*p == '*') {</a>
<a name="ln843">          const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln844">          p++;</a>
<a name="ln845">          if (j &gt;= 0) {</a>
<a name="ln846">            precision = (size_t)j;</a>
<a name="ln847">          } else {</a>
<a name="ln848">            precision_specified = 0;</a>
<a name="ln849">            precision = 0;</a>
<a name="ln850">          }</a>
<a name="ln851">        } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln852">          // size_t could be wider than unsigned int; make sure we</a>
<a name="ln853">          // treat argument like common implementations do</a>
<a name="ln854">          unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln855"> </a>
<a name="ln856">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln857">            uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln858">          }</a>
<a name="ln859">          precision = uj;</a>
<a name="ln860">        }</a>
<a name="ln861">      }</a>
<a name="ln862"> </a>
<a name="ln863">      // parse 'h', 'l', 'll' and 'z' length modifiers</a>
<a name="ln864">      if (*p == 'h' || *p == 'l' || *p == 'z') {</a>
<a name="ln865">        length_modifier = *p;</a>
<a name="ln866">        p++;</a>
<a name="ln867">        if (length_modifier == 'l' &amp;&amp; *p == 'l') {  // ll, encoded as 2</a>
<a name="ln868">          length_modifier = '2';</a>
<a name="ln869">          p++;</a>
<a name="ln870">        }</a>
<a name="ln871">      }</a>
<a name="ln872"> </a>
<a name="ln873">      fmt_spec = *p;</a>
<a name="ln874"> </a>
<a name="ln875">      // common synonyms</a>
<a name="ln876">      switch (fmt_spec) {</a>
<a name="ln877">      case 'i':</a>
<a name="ln878">        fmt_spec = 'd'; break;</a>
<a name="ln879">      case 'D':</a>
<a name="ln880">        fmt_spec = 'd'; length_modifier = 'l'; break;</a>
<a name="ln881">      case 'U':</a>
<a name="ln882">        fmt_spec = 'u'; length_modifier = 'l'; break;</a>
<a name="ln883">      case 'O':</a>
<a name="ln884">        fmt_spec = 'o'; length_modifier = 'l'; break;</a>
<a name="ln885">      default:</a>
<a name="ln886">        break;</a>
<a name="ln887">      }</a>
<a name="ln888"> </a>
<a name="ln889">      switch (fmt_spec) {</a>
<a name="ln890">      case 'b':</a>
<a name="ln891">      case 'B':</a>
<a name="ln892">      case 'd':</a>
<a name="ln893">      case 'u':</a>
<a name="ln894">      case 'o':</a>
<a name="ln895">      case 'x':</a>
<a name="ln896">      case 'X':</a>
<a name="ln897">        if (tvs &amp;&amp; length_modifier == '\0') {</a>
<a name="ln898">          length_modifier = '2';</a>
<a name="ln899">        }</a>
<a name="ln900">      }</a>
<a name="ln901"> </a>
<a name="ln902">      // get parameter value, do initial processing</a>
<a name="ln903">      switch (fmt_spec) {</a>
<a name="ln904">      // '%' and 'c' behave similar to 's' regarding flags and field widths</a>
<a name="ln905">      case '%':</a>
<a name="ln906">      case 'c':</a>
<a name="ln907">      case 's':</a>
<a name="ln908">      case 'S':</a>
<a name="ln909">        str_arg_l = 1;</a>
<a name="ln910">        switch (fmt_spec) {</a>
<a name="ln911">        case '%':</a>
<a name="ln912">          str_arg = p;</a>
<a name="ln913">          break;</a>
<a name="ln914"> </a>
<a name="ln915">        case 'c': {</a>
<a name="ln916">          const int j = tvs ? (int)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int);</a>
<a name="ln917">          // standard demands unsigned char</a>
<a name="ln918">          uchar_arg = (unsigned char)j;</a>
<a name="ln919">          str_arg = (char *)&amp;uchar_arg;</a>
<a name="ln920">          break;</a>
<a name="ln921">        }</a>
<a name="ln922"> </a>
<a name="ln923">        case 's':</a>
<a name="ln924">        case 'S':</a>
<a name="ln925">          str_arg = tvs ? tv_str(tvs, &amp;arg_idx, &amp;tofree)</a>
<a name="ln926">                        : va_arg(ap, const char *);</a>
<a name="ln927">          if (!str_arg) {</a>
<a name="ln928">            str_arg = &quot;[NULL]&quot;;</a>
<a name="ln929">            str_arg_l = 6;</a>
<a name="ln930">          } else if (!precision_specified) {</a>
<a name="ln931">            // make sure not to address string beyond the specified</a>
<a name="ln932">            // precision</a>
<a name="ln933">            str_arg_l = strlen(str_arg);</a>
<a name="ln934">          } else if (precision == 0) {</a>
<a name="ln935">            // truncate string if necessary as requested by precision</a>
<a name="ln936">            str_arg_l = 0;</a>
<a name="ln937">          } else {</a>
<a name="ln938">            // memchr on HP does not like n &gt; 2^31</a>
<a name="ln939">            // TODO(elmart): check if this still holds / is relevant</a>
<a name="ln940">            str_arg_l = (size_t)((char *)xmemscan(str_arg,</a>
<a name="ln941">                                                  NUL,</a>
<a name="ln942">                                                  MIN(precision,</a>
<a name="ln943">                                                      0x7fffffff))</a>
<a name="ln944">                                 - str_arg);</a>
<a name="ln945">          }</a>
<a name="ln946">          if (fmt_spec == 'S') {</a>
<a name="ln947">            const char *p1;</a>
<a name="ln948">            size_t i;</a>
<a name="ln949"> </a>
<a name="ln950">            for (i = 0, p1 = str_arg; *p1; p1 += utfc_ptr2len(p1)) {</a>
<a name="ln951">              size_t cell = (size_t)utf_ptr2cells(p1);</a>
<a name="ln952">              if (precision_specified &amp;&amp; i + cell &gt; precision) {</a>
<a name="ln953">                break;</a>
<a name="ln954">              }</a>
<a name="ln955">              i += cell;</a>
<a name="ln956">            }</a>
<a name="ln957"> </a>
<a name="ln958">            str_arg_l = (size_t)(p1 - str_arg);</a>
<a name="ln959">            if (min_field_width != 0) {</a>
<a name="ln960">              min_field_width += str_arg_l - i;</a>
<a name="ln961">            }</a>
<a name="ln962">          }</a>
<a name="ln963">          break;</a>
<a name="ln964"> </a>
<a name="ln965">        default:</a>
<a name="ln966">          break;</a>
<a name="ln967">        }</a>
<a name="ln968">        break;</a>
<a name="ln969"> </a>
<a name="ln970">      case 'd':</a>
<a name="ln971">      case 'u':</a>
<a name="ln972">      case 'b':</a>
<a name="ln973">      case 'B':</a>
<a name="ln974">      case 'o':</a>
<a name="ln975">      case 'x':</a>
<a name="ln976">      case 'X':</a>
<a name="ln977">      case 'p': {</a>
<a name="ln978">        // u, b, B, o, x, X and p conversion specifiers imply</a>
<a name="ln979">        // the value is unsigned; d implies a signed value</a>
<a name="ln980"> </a>
<a name="ln981">        // 0 if numeric argument is zero (or if pointer is NULL for 'p'),</a>
<a name="ln982">        // +1 if greater than zero (or non NULL for 'p'),</a>
<a name="ln983">        // -1 if negative (unsigned argument is never negative)</a>
<a name="ln984">        int arg_sign = 0;</a>
<a name="ln985"> </a>
<a name="ln986">        intmax_t arg = 0;</a>
<a name="ln987">        uintmax_t uarg = 0;</a>
<a name="ln988"> </a>
<a name="ln989">        // only defined for p conversion</a>
<a name="ln990">        const void *ptr_arg = NULL;</a>
<a name="ln991"> </a>
<a name="ln992">        if (fmt_spec == 'p') {</a>
<a name="ln993">          ptr_arg = tvs ? tv_ptr(tvs, &amp;arg_idx) : va_arg(ap, void *);</a>
<a name="ln994">          if (ptr_arg) {</a>
<a name="ln995">            arg_sign = 1;</a>
<a name="ln996">          }</a>
<a name="ln997">        } else if (fmt_spec == 'd') {</a>
<a name="ln998">          // signed</a>
<a name="ln999">          switch (length_modifier) {</a>
<a name="ln1000">          case '\0':</a>
<a name="ln1001">            arg = (int)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int));</a>
<a name="ln1002">            break;</a>
<a name="ln1003">          case 'h':</a>
<a name="ln1004">            // char and short arguments are passed as int16_t</a>
<a name="ln1005">            arg = (int16_t)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, int));</a>
<a name="ln1006">            break;</a>
<a name="ln1007">          case 'l':</a>
<a name="ln1008">            arg = (tvs ? (long)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, long));</a>
<a name="ln1009">            break;</a>
<a name="ln1010">          case '2':</a>
<a name="ln1011">            arg = (</a>
<a name="ln1012">                   tvs</a>
<a name="ln1013">                    ? (long long)tv_nr(tvs, &amp;arg_idx)  // NOLINT (runtime/int)</a>
<a name="ln1014">                    : va_arg(ap, long long));  // NOLINT (runtime/int)</a>
<a name="ln1015">            break;</a>
<a name="ln1016">          case 'z':</a>
<a name="ln1017">            arg = (tvs ? (ptrdiff_t)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, ptrdiff_t));</a>
<a name="ln1018">            break;</a>
<a name="ln1019">          }</a>
<a name="ln1020">          if (arg &gt; 0) {</a>
<a name="ln1021">            arg_sign = 1;</a>
<a name="ln1022">          } else if (arg &lt; 0) {</a>
<a name="ln1023">            arg_sign = -1;</a>
<a name="ln1024">          }</a>
<a name="ln1025">        } else {</a>
<a name="ln1026">          // unsigned</a>
<a name="ln1027">          switch (length_modifier) {</a>
<a name="ln1028">          case '\0':</a>
<a name="ln1029">            uarg = (unsigned)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, unsigned));</a>
<a name="ln1030">            break;</a>
<a name="ln1031">          case 'h':</a>
<a name="ln1032">            uarg = (uint16_t)(tvs ? tv_nr(tvs, &amp;arg_idx) : va_arg(ap, unsigned));</a>
<a name="ln1033">            break;</a>
<a name="ln1034">          case 'l':</a>
<a name="ln1035">            uarg = (tvs ? (unsigned long)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, unsigned long));</a>
<a name="ln1036">            break;</a>
<a name="ln1037">          case '2':</a>
<a name="ln1038">            uarg = (uintmax_t)(unsigned long long)(  // NOLINT (runtime/int)</a>
<a name="ln1039">                                                     tvs</a>
<a name="ln1040">                    ? ((unsigned long long)  // NOLINT (runtime/int)</a>
<a name="ln1041">                       tv_nr(tvs, &amp;arg_idx))</a>
<a name="ln1042">                    : va_arg(ap, unsigned long long));  // NOLINT (runtime/int)</a>
<a name="ln1043">            break;</a>
<a name="ln1044">          case 'z':</a>
<a name="ln1045">            uarg = (tvs ? (size_t)tv_nr(tvs, &amp;arg_idx) : va_arg(ap, size_t));</a>
<a name="ln1046">            break;</a>
<a name="ln1047">          }</a>
<a name="ln1048">          arg_sign = (uarg != 0);</a>
<a name="ln1049">        }</a>
<a name="ln1050"> </a>
<a name="ln1051">        str_arg = tmp;</a>
<a name="ln1052">        str_arg_l = 0;</a>
<a name="ln1053"> </a>
<a name="ln1054">        // For d, i, u, o, x, and X conversions, if precision is specified,</a>
<a name="ln1055">        // '0' flag should be ignored. This is so with Solaris 2.6, Digital</a>
<a name="ln1056">        // UNIX 4.0, HPUX 10, Linux, FreeBSD, NetBSD; but not with Perl.</a>
<a name="ln1057">        if (precision_specified) {</a>
<a name="ln1058">          zero_padding = 0;</a>
<a name="ln1059">        }</a>
<a name="ln1060"> </a>
<a name="ln1061">        if (fmt_spec == 'd') {</a>
<a name="ln1062">          if (force_sign &amp;&amp; arg_sign &gt;= 0) {</a>
<a name="ln1063">            tmp[str_arg_l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1064">          }</a>
<a name="ln1065">          // leave negative numbers for snprintf to handle, to</a>
<a name="ln1066">          // avoid handling tricky cases like (short int)-32768</a>
<a name="ln1067">        } else if (alternate_form) {</a>
<a name="ln1068">          if (arg_sign != 0 &amp;&amp; (fmt_spec == 'x' || fmt_spec == 'X'</a>
<a name="ln1069">                                || fmt_spec == 'b' || fmt_spec == 'B')) {</a>
<a name="ln1070">            tmp[str_arg_l++] = '0';</a>
<a name="ln1071">            tmp[str_arg_l++] = fmt_spec;</a>
<a name="ln1072">          }</a>
<a name="ln1073">          // alternate form should have no effect for p * conversion, but ...</a>
<a name="ln1074">        }</a>
<a name="ln1075"> </a>
<a name="ln1076">        zero_padding_insertion_ind = str_arg_l;</a>
<a name="ln1077">        if (!precision_specified) {</a>
<a name="ln1078">          precision = 1;  // default precision is 1</a>
<a name="ln1079">        }</a>
<a name="ln1080">        if (precision == 0 &amp;&amp; arg_sign == 0) {</a>
<a name="ln1081">          // when zero value is formatted with an explicit precision 0,</a>
<a name="ln1082">          // resulting formatted string is empty (d, i, u, b, B, o, x, X, p)</a>
<a name="ln1083">        } else {</a>
<a name="ln1084">          switch (fmt_spec) {</a>
<a name="ln1085">          case 'p':    // pointer</a>
<a name="ln1086">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1087">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1088">                                          &quot;%p&quot;, ptr_arg);</a>
<a name="ln1089">            break;</a>
<a name="ln1090">          case 'd':    // signed</a>
<a name="ln1091">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1092">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1093">                                          &quot;%&quot; PRIdMAX, arg);</a>
<a name="ln1094">            break;</a>
<a name="ln1095">          case 'b':</a>
<a name="ln1096">          case 'B': {  // binary</a>
<a name="ln1097">            size_t bits = 0;</a>
<a name="ln1098">            for (bits = sizeof(uintmax_t) * 8; bits &gt; 0; bits--) {</a>
<a name="ln1099">              if ((uarg &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln1100">                break;</a>
<a name="ln1101">              }</a>
<a name="ln1102">            }</a>
<a name="ln1103"> </a>
<a name="ln1104">            while (bits &gt; 0) {</a>
<a name="ln1105">              tmp[str_arg_l++] = ((uarg &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln1106">            }</a>
<a name="ln1107">            break;</a>
<a name="ln1108">          }</a>
<a name="ln1109">          default: {  // unsigned</a>
<a name="ln1110">            // construct a simple format string for snprintf</a>
<a name="ln1111">            char f[] = &quot;%&quot; PRIuMAX;</a>
<a name="ln1112">            f[sizeof(&quot;%&quot; PRIuMAX) - 1 - 1] = fmt_spec;</a>
<a name="ln1113">            assert(PRIuMAX[sizeof(PRIuMAX) - 1 - 1] == 'u');</a>
<a name="ln1114">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1115">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1116">                                          f, uarg);</a>
<a name="ln1117">            break;</a>
<a name="ln1118">          }</a>
<a name="ln1119">          }</a>
<a name="ln1120">          assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1121"> </a>
<a name="ln1122">          // include the optional minus sign and possible &quot;0x&quot; in the region</a>
<a name="ln1123">          // before the zero padding insertion point</a>
<a name="ln1124">          if (zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1125">              &amp;&amp; tmp[zero_padding_insertion_ind] == '-') {</a>
<a name="ln1126">            zero_padding_insertion_ind++;</a>
<a name="ln1127">          }</a>
<a name="ln1128">          if (zero_padding_insertion_ind + 1 &lt; str_arg_l</a>
<a name="ln1129">              &amp;&amp; tmp[zero_padding_insertion_ind] == '0'</a>
<a name="ln1130">              &amp;&amp; (tmp[zero_padding_insertion_ind + 1] == 'x'</a>
<a name="ln1131">                  || tmp[zero_padding_insertion_ind + 1] == 'X'</a>
<a name="ln1132">                  || tmp[zero_padding_insertion_ind + 1] == 'b'</a>
<a name="ln1133">                  || tmp[zero_padding_insertion_ind + 1] == 'B')) {</a>
<a name="ln1134">            zero_padding_insertion_ind += 2;</a>
<a name="ln1135">          }</a>
<a name="ln1136">        }</a>
<a name="ln1137"> </a>
<a name="ln1138">        {</a>
<a name="ln1139">          size_t num_of_digits = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln1140"> </a>
<a name="ln1141">          if (alternate_form &amp;&amp; fmt_spec == 'o'</a>
<a name="ln1142">              // unless zero is already the first character</a>
<a name="ln1143">              &amp;&amp; !(zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1144">                   &amp;&amp; tmp[zero_padding_insertion_ind] == '0')) {</a>
<a name="ln1145">            // assure leading zero for alternate-form octal numbers</a>
<a name="ln1146">            if (!precision_specified</a>
<a name="ln1147">                || precision &lt; num_of_digits + 1) {</a>
<a name="ln1148">              // precision is increased to force the first character to be</a>
<a name="ln1149">              // zero, except if a zero value is formatted with an explicit</a>
<a name="ln1150">              // precision of zero</a>
<a name="ln1151">              precision = num_of_digits + 1;</a>
<a name="ln1152">            }</a>
<a name="ln1153">          }</a>
<a name="ln1154">          // zero padding to specified precision?</a>
<a name="ln1155">          if (num_of_digits &lt; precision) {</a>
<a name="ln1156">            number_of_zeros_to_pad = precision - num_of_digits;</a>
<a name="ln1157">          }</a>
<a name="ln1158">        }</a>
<a name="ln1159">        // zero padding to specified minimal field width?</a>
<a name="ln1160">        if (!justify_left &amp;&amp; zero_padding) {</a>
<a name="ln1161">          const int n = (int)(min_field_width - (str_arg_l</a>
<a name="ln1162">                                                 + number_of_zeros_to_pad));</a>
<a name="ln1163">          if (n &gt; 0) {</a>
<a name="ln1164">            number_of_zeros_to_pad += (size_t)n;</a>
<a name="ln1165">          }</a>
<a name="ln1166">        }</a>
<a name="ln1167">        break;</a>
<a name="ln1168">      }</a>
<a name="ln1169"> </a>
<a name="ln1170">      case 'f':</a>
<a name="ln1171">      case 'F':</a>
<a name="ln1172">      case 'e':</a>
<a name="ln1173">      case 'E':</a>
<a name="ln1174">      case 'g':</a>
<a name="ln1175">      case 'G': {</a>
<a name="ln1176">        // floating point</a>
<a name="ln1177">        char format[40];</a>
<a name="ln1178">        int remove_trailing_zeroes = false;</a>
<a name="ln1179"> </a>
<a name="ln1180">        double f = tvs ? tv_float(tvs, &amp;arg_idx) : va_arg(ap, double);</a>
<a name="ln1181">        double abs_f = f &lt; 0 ? -f : f;</a>
<a name="ln1182"> </a>
<a name="ln1183">        if (fmt_spec == 'g' || fmt_spec == 'G') {</a>
<a name="ln1184">          // can't use %g directly, cause it prints &quot;1.0&quot; as &quot;1&quot;</a>
<a name="ln1185">          if ((abs_f &gt;= 0.001 &amp;&amp; abs_f &lt; 10000000.0) || abs_f == 0.0) {</a>
<a name="ln1186">            fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';</a>
<a name="ln1187">          } else {</a>
<a name="ln1188">            fmt_spec = fmt_spec == 'g' ? 'e' : 'E';</a>
<a name="ln1189">          }</a>
<a name="ln1190">          remove_trailing_zeroes = true;</a>
<a name="ln1191">        }</a>
<a name="ln1192"> </a>
<a name="ln1193">        if (xisinf(f)</a>
<a name="ln1194">            || (strchr(&quot;fF&quot;, fmt_spec) != NULL &amp;&amp; abs_f &gt; 1.0e307)) {</a>
<a name="ln1195">          xstrlcpy(tmp, infinity_str(f &gt; 0.0, fmt_spec,</a>
<a name="ln1196">                                     force_sign, space_for_positive),</a>
<a name="ln1197">                   sizeof(tmp));</a>
<a name="ln1198">          str_arg_l = strlen(tmp);</a>
<a name="ln1199">          zero_padding = 0;</a>
<a name="ln1200">        } else if (xisnan(f)) {</a>
<a name="ln1201">          // Not a number: nan or NAN</a>
<a name="ln1202">          memmove(tmp, ASCII_ISUPPER(fmt_spec) ? &quot;NAN&quot; : &quot;nan&quot;, 4);</a>
<a name="ln1203">          str_arg_l = 3;</a>
<a name="ln1204">          zero_padding = 0;</a>
<a name="ln1205">        } else {</a>
<a name="ln1206">          // Regular float number</a>
<a name="ln1207">          format[0] = '%';</a>
<a name="ln1208">          size_t l = 1;</a>
<a name="ln1209">          if (force_sign) {</a>
<a name="ln1210">            format[l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1211">          }</a>
<a name="ln1212">          if (precision_specified) {</a>
<a name="ln1213">            size_t max_prec = TMP_LEN - 10;</a>
<a name="ln1214"> </a>
<a name="ln1215">            // make sure we don't get more digits than we have room for</a>
<a name="ln1216">            if ((fmt_spec == 'f' || fmt_spec == 'F') &amp;&amp; abs_f &gt; 1.0) {</a>
<a name="ln1217">              max_prec -= (size_t)log10(abs_f);</a>
<a name="ln1218">            }</a>
<a name="ln1219">            if (precision &gt; max_prec) {</a>
<a name="ln1220">              precision = max_prec;</a>
<a name="ln1221">            }</a>
<a name="ln1222">            l += (size_t)snprintf(format + l, sizeof(format) - l, &quot;.%d&quot;,</a>
<a name="ln1223">                                  (int)precision);</a>
<a name="ln1224">          }</a>
<a name="ln1225"> </a>
<a name="ln1226">          // Cast to char to avoid a conversion warning on Ubuntu 12.04.</a>
<a name="ln1227">          assert(l + 1 &lt; sizeof(format));</a>
<a name="ln1228">          format[l] = (char)(fmt_spec == 'F' ? 'f' : fmt_spec);</a>
<a name="ln1229">          format[l + 1] = NUL;</a>
<a name="ln1230"> </a>
<a name="ln1231">          str_arg_l = (size_t)snprintf(tmp, sizeof(tmp), format, f);</a>
<a name="ln1232">          assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1233"> </a>
<a name="ln1234">          if (remove_trailing_zeroes) {</a>
<a name="ln1235">            int i;</a>
<a name="ln1236">            char *tp;</a>
<a name="ln1237"> </a>
<a name="ln1238">            // using %g or %G: remove superfluous zeroes</a>
<a name="ln1239">            if (fmt_spec == 'f' || fmt_spec == 'F') {</a>
<a name="ln1240">              tp = tmp + str_arg_l - 1;</a>
<a name="ln1241">            } else {</a>
<a name="ln1242">              tp = vim_strchr(tmp, fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln1243">              if (tp) {</a>
<a name="ln1244">                // remove superfluous '+' and leading zeroes from exponent</a>
<a name="ln1245">                if (tp[1] == '+') {</a>
<a name="ln1246">                  // change &quot;1.0e+07&quot; to &quot;1.0e07&quot;</a>
<a name="ln1247">                  STRMOVE(tp + 1, tp + 2);</a>
<a name="ln1248">                  str_arg_l--;</a>
<a name="ln1249">                }</a>
<a name="ln1250">                i = (tp[1] == '-') ? 2 : 1;</a>
<a name="ln1251">                while (tp[i] == '0') {</a>
<a name="ln1252">                  // change &quot;1.0e07&quot; to &quot;1.0e7&quot;</a>
<a name="ln1253">                  STRMOVE(tp + i, tp + i + 1);</a>
<a name="ln1254">                  str_arg_l--;</a>
<a name="ln1255">                }</a>
<a name="ln1256">                tp--;</a>
<a name="ln1257">              }</a>
<a name="ln1258">            }</a>
<a name="ln1259"> </a>
<a name="ln1260">            if (tp != NULL &amp;&amp; !precision_specified) {</a>
<a name="ln1261">              // remove trailing zeroes, but keep the one just after a dot</a>
<a name="ln1262">              while (tp &gt; tmp + 2 &amp;&amp; *tp == '0' &amp;&amp; tp[-1] != '.') {</a>
<a name="ln1263">                STRMOVE(tp, tp + 1);</a>
<a name="ln1264">                tp--;</a>
<a name="ln1265">                str_arg_l--;</a>
<a name="ln1266">              }</a>
<a name="ln1267">            }</a>
<a name="ln1268">          } else {</a>
<a name="ln1269">            // Be consistent: some printf(&quot;%e&quot;) use 1.0e+12 and some</a>
<a name="ln1270">            // 1.0e+012; remove one zero in the last case.</a>
<a name="ln1271">            char *tp = vim_strchr(tmp, fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln1272">            if (tp &amp;&amp; (tp[1] == '+' || tp[1] == '-') &amp;&amp; tp[2] == '0'</a>
<a name="ln1273">                &amp;&amp; ascii_isdigit(tp[3]) &amp;&amp; ascii_isdigit(tp[4])) {</a>
<a name="ln1274">              STRMOVE(tp + 2, tp + 3);</a>
<a name="ln1275">              str_arg_l--;</a>
<a name="ln1276">            }</a>
<a name="ln1277">          }</a>
<a name="ln1278">        }</a>
<a name="ln1279">        if (zero_padding &amp;&amp; min_field_width &gt; str_arg_l</a>
<a name="ln1280">            &amp;&amp; (tmp[0] == '-' || force_sign)) {</a>
<a name="ln1281">          // Padding 0's should be inserted after the sign.</a>
<a name="ln1282">          number_of_zeros_to_pad = min_field_width - str_arg_l;</a>
<a name="ln1283">          zero_padding_insertion_ind = 1;</a>
<a name="ln1284">        }</a>
<a name="ln1285">        str_arg = tmp;</a>
<a name="ln1286">        break;</a>
<a name="ln1287">      }</a>
<a name="ln1288"> </a>
<a name="ln1289">      default:</a>
<a name="ln1290">        // unrecognized conversion specifier, keep format string as-is</a>
<a name="ln1291">        zero_padding = 0;  // turn zero padding off for non-numeric conversion</a>
<a name="ln1292">        justify_left = 1;</a>
<a name="ln1293">        min_field_width = 0;  // reset flags</a>
<a name="ln1294"> </a>
<a name="ln1295">        // discard the unrecognized conversion, just keep</a>
<a name="ln1296">        // the unrecognized conversion character</a>
<a name="ln1297">        str_arg = p;</a>
<a name="ln1298">        str_arg_l = 0;</a>
<a name="ln1299">        if (*p) {</a>
<a name="ln1300">          str_arg_l++;  // include invalid conversion specifier</a>
<a name="ln1301">        }</a>
<a name="ln1302">        // unchanged if not at end-of-string</a>
<a name="ln1303">        break;</a>
<a name="ln1304">      }</a>
<a name="ln1305"> </a>
<a name="ln1306">      if (*p) {</a>
<a name="ln1307">        p++;  // step over the just processed conversion specifier</a>
<a name="ln1308">      }</a>
<a name="ln1309"> </a>
<a name="ln1310">      // insert padding to the left as requested by min_field_width;</a>
<a name="ln1311">      // this does not include the zero padding in case of numerical conversions</a>
<a name="ln1312">      if (!justify_left) {</a>
<a name="ln1313">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln1314">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln1315">          // left padding with blank or zero</a>
<a name="ln1316">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln1317">          if (str_avail) {</a>
<a name="ln1318">            size_t avail = str_m - str_l;</a>
<a name="ln1319">            memset(str + str_l, zero_padding ? '0' : ' ', MIN(pn, avail));</a>
<a name="ln1320">            str_avail = pn &lt; avail;</a>
<a name="ln1321">          }</a>
<a name="ln1322">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1323">          str_l += pn;</a>
<a name="ln1324">        }</a>
<a name="ln1325">      }</a>
<a name="ln1326"> </a>
<a name="ln1327">      // zero padding as requested by the precision or by the minimal</a>
<a name="ln1328">      // field width for numeric conversions required?</a>
<a name="ln1329">      if (number_of_zeros_to_pad == 0) {</a>
<a name="ln1330">        // will not copy first part of numeric right now,</a>
<a name="ln1331">        // force it to be copied later in its entirety</a>
<a name="ln1332">        zero_padding_insertion_ind = 0;</a>
<a name="ln1333">      } else {</a>
<a name="ln1334">        // insert first part of numerics (sign or '0x') before zero padding</a>
<a name="ln1335">        if (zero_padding_insertion_ind &gt; 0) {</a>
<a name="ln1336">          size_t zn = zero_padding_insertion_ind;</a>
<a name="ln1337">          if (str_avail) {</a>
<a name="ln1338">            size_t avail = str_m - str_l;</a>
<a name="ln1339">            memmove(str + str_l, str_arg, MIN(zn, avail));</a>
<a name="ln1340">            str_avail = zn &lt; avail;</a>
<a name="ln1341">          }</a>
<a name="ln1342">          assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1343">          str_l += zn;</a>
<a name="ln1344">        }</a>
<a name="ln1345"> </a>
<a name="ln1346">        // insert zero padding as requested by precision or min field width</a>
<a name="ln1347">        size_t zn = number_of_zeros_to_pad;</a>
<a name="ln1348">        if (str_avail) {</a>
<a name="ln1349">          size_t avail = str_m - str_l;</a>
<a name="ln1350">          memset(str + str_l, '0', MIN(zn, avail));</a>
<a name="ln1351">          str_avail = zn &lt; avail;</a>
<a name="ln1352">        }</a>
<a name="ln1353">        assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1354">        str_l += zn;</a>
<a name="ln1355">      }</a>
<a name="ln1356"> </a>
<a name="ln1357">      // insert formatted string</a>
<a name="ln1358">      // (or as-is conversion specifier for unknown conversions)</a>
<a name="ln1359">      if (str_arg_l &gt; zero_padding_insertion_ind) {</a>
<a name="ln1360">        size_t sn = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln1361">        if (str_avail) {</a>
<a name="ln1362">          size_t avail = str_m - str_l;</a>
<a name="ln1363">          memmove(str + str_l,</a>
<a name="ln1364">                  str_arg + zero_padding_insertion_ind,</a>
<a name="ln1365">                  MIN(sn, avail));</a>
<a name="ln1366">          str_avail = sn &lt; avail;</a>
<a name="ln1367">        }</a>
<a name="ln1368">        assert(sn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1369">        str_l += sn;</a>
<a name="ln1370">      }</a>
<a name="ln1371"> </a>
<a name="ln1372">      // insert right padding</a>
<a name="ln1373">      if (justify_left) {</a>
<a name="ln1374">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln1375">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln1376">          // right blank padding to the field width</a>
<a name="ln1377">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln1378">          if (str_avail) {</a>
<a name="ln1379">            size_t avail = str_m - str_l;</a>
<a name="ln1380">            memset(str + str_l, ' ', MIN(pn, avail));</a>
<a name="ln1381">            str_avail = pn &lt; avail;</a>
<a name="ln1382">          }</a>
<a name="ln1383">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln1384">          str_l += pn;</a>
<a name="ln1385">        }</a>
<a name="ln1386">      }</a>
<a name="ln1387"> </a>
<a name="ln1388">      xfree(tofree);</a>
<a name="ln1389">    }</a>
<a name="ln1390">  }</a>
<a name="ln1391"> </a>
<a name="ln1392">  if (str_m &gt; 0) {</a>
<a name="ln1393">    // make sure the string is nul-terminated even at the expense of</a>
<a name="ln1394">    // overwriting the last character (shouldn't happen, but just in case)</a>
<a name="ln1395">    str[str_l &lt;= str_m - 1 ? str_l : str_m - 1] = '\0';</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  if (tvs &amp;&amp; tvs[arg_idx - 1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1399">    emsg(_(&quot;E767: Too many arguments to printf()&quot;));</a>
<a name="ln1400">  }</a>
<a name="ln1401"> </a>
<a name="ln1402">  // return the number of characters formatted (excluding trailing nul</a>
<a name="ln1403">  // character); that is, the number of characters that would have been</a>
<a name="ln1404">  // written to the buffer if it were large enough.</a>
<a name="ln1405">  return (int)str_l;</a>
<a name="ln1406">}</a>
<a name="ln1407"> </a>
<a name="ln1408">int kv_do_printf(StringBuilder *str, const char *fmt, ...)</a>
<a name="ln1409">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln1410">{</a>
<a name="ln1411">  size_t remaining = str-&gt;capacity - str-&gt;size;</a>
<a name="ln1412"> </a>
<a name="ln1413">  va_list ap;</a>
<a name="ln1414">  va_start(ap, fmt);</a>
<a name="ln1415">  int printed = vsnprintf(str-&gt;items ? str-&gt;items + str-&gt;size : NULL, remaining, fmt, ap);</a>
<a name="ln1416">  va_end(ap);</a>
<a name="ln1417"> </a>
<a name="ln1418">  if (printed &lt; 0) {</a>
<a name="ln1419">    return -1;</a>
<a name="ln1420">  }</a>
<a name="ln1421"> </a>
<a name="ln1422">  // printed string didn't fit, resize and try again</a>
<a name="ln1423">  if ((size_t)printed &gt;= remaining) {</a>
<a name="ln1424">    kv_ensure_space(*str, (size_t)printed + 1);  // include space for NUL terminator at the end</a>
<a name="ln1425">    assert(str-&gt;items != NULL);</a>
<a name="ln1426">    va_start(ap, fmt);</a>
<a name="ln1427">    printed = vsnprintf(str-&gt;items + str-&gt;size, str-&gt;capacity - str-&gt;size, fmt, ap);</a>
<a name="ln1428">    va_end(ap);</a>
<a name="ln1429">    if (printed &lt; 0) {</a>
<a name="ln1430">      return -1;</a>
<a name="ln1431">    }</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  str-&gt;size += (size_t)printed;</a>
<a name="ln1435">  return printed;</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">/// Reverse text into allocated memory.</a>
<a name="ln1439">///</a>
<a name="ln1440">/// @return  the allocated string.</a>
<a name="ln1441">char *reverse_text(char *s)</a>
<a name="ln1442">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1443">{</a>
<a name="ln1444">  // Reverse the pattern.</a>
<a name="ln1445">  size_t len = strlen(s);</a>
<a name="ln1446">  char *rev = xmalloc(len + 1);</a>
<a name="ln1447">  size_t rev_i = len;</a>
<a name="ln1448">  for (size_t s_i = 0; s_i &lt; len; s_i++) {</a>
<a name="ln1449">    const int mb_len = utfc_ptr2len(s + s_i);</a>
<a name="ln1450">    rev_i -= (size_t)mb_len;</a>
<a name="ln1451">    memmove(rev + rev_i, s + s_i, (size_t)mb_len);</a>
<a name="ln1452">    s_i += (size_t)mb_len - 1;</a>
<a name="ln1453">  }</a>
<a name="ln1454">  rev[len] = NUL;</a>
<a name="ln1455"> </a>
<a name="ln1456">  return rev;</a>
<a name="ln1457">}</a>
<a name="ln1458"> </a>
<a name="ln1459">/// Replace all occurrences of &quot;what&quot; with &quot;rep&quot; in &quot;src&quot;. If no replacement happens then NULL is</a>
<a name="ln1460">/// returned otherwise return a newly allocated string.</a>
<a name="ln1461">///</a>
<a name="ln1462">/// @param[in] src  Source text</a>
<a name="ln1463">/// @param[in] what Substring to replace</a>
<a name="ln1464">/// @param[in] rep  Substring to replace with</a>
<a name="ln1465">///</a>
<a name="ln1466">/// @return [allocated] Copy of the string.</a>
<a name="ln1467">char *strrep(const char *src, const char *what, const char *rep)</a>
<a name="ln1468">{</a>
<a name="ln1469">  const char *pos = src;</a>
<a name="ln1470">  size_t whatlen = strlen(what);</a>
<a name="ln1471"> </a>
<a name="ln1472">  // Count occurrences</a>
<a name="ln1473">  size_t count = 0;</a>
<a name="ln1474">  while ((pos = strstr(pos, what)) != NULL) {</a>
<a name="ln1475">    count++;</a>
<a name="ln1476">    pos += whatlen;</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479">  if (count == 0) {</a>
<a name="ln1480">    return NULL;</a>
<a name="ln1481">  }</a>
<a name="ln1482"> </a>
<a name="ln1483">  size_t replen = strlen(rep);</a>
<a name="ln1484">  char *ret = xmalloc(strlen(src) + count * (replen - whatlen) + 1);</a>
<a name="ln1485">  char *ptr = ret;</a>
<a name="ln1486">  while ((pos = strstr(src, what)) != NULL) {</a>
<a name="ln1487">    size_t idx = (size_t)(pos - src);</a>
<a name="ln1488">    memcpy(ptr, src, idx);</a>
<a name="ln1489">    ptr += idx;</a>
<a name="ln1490">    STRCPY(ptr, rep);</a>
<a name="ln1491">    ptr += replen;</a>
<a name="ln1492">    src = pos + whatlen;</a>
<a name="ln1493">  }</a>
<a name="ln1494"> </a>
<a name="ln1495">  // Copy remaining</a>
<a name="ln1496">  STRCPY(ptr, src);</a>
<a name="ln1497"> </a>
<a name="ln1498">  return ret;</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/// Implementation of &quot;byteidx()&quot; and &quot;byteidxcomp()&quot; functions</a>
<a name="ln1502">static void byteidx_common(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln1503">{</a>
<a name="ln1504">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1505"> </a>
<a name="ln1506">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1507">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1508">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln1509">    return;</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  varnumber_T utf16idx = false;</a>
<a name="ln1513">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1514">    bool error = false;</a>
<a name="ln1515">    utf16idx = tv_get_bool_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1516">    if (error) {</a>
<a name="ln1517">      return;</a>
<a name="ln1518">    }</a>
<a name="ln1519">    if (utf16idx &lt; 0 || utf16idx &gt; 1) {</a>
<a name="ln1520">      semsg(_(e_using_number_as_bool_nr), utf16idx);</a>
<a name="ln1521">      return;</a>
<a name="ln1522">    }</a>
<a name="ln1523">  }</a>
<a name="ln1524"> </a>
<a name="ln1525">  int (*ptr2len)(const char *);</a>
<a name="ln1526">  if (comp) {</a>
<a name="ln1527">    ptr2len = utf_ptr2len;</a>
<a name="ln1528">  } else {</a>
<a name="ln1529">    ptr2len = utfc_ptr2len;</a>
<a name="ln1530">  }</a>
<a name="ln1531"> </a>
<a name="ln1532">  const char *t = str;</a>
<a name="ln1533">  for (; idx &gt; 0; idx--) {</a>
<a name="ln1534">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln1535">      return;</a>
<a name="ln1536">    }</a>
<a name="ln1537">    if (utf16idx) {</a>
<a name="ln1538">      const int clen = ptr2len(t);</a>
<a name="ln1539">      const int c = (clen &gt; 1) ? utf_ptr2char(t) : *t;</a>
<a name="ln1540">      if (c &gt; 0xFFFF) {</a>
<a name="ln1541">        idx--;</a>
<a name="ln1542">      }</a>
<a name="ln1543">    }</a>
<a name="ln1544">    if (idx &gt; 0) {</a>
<a name="ln1545">      t += ptr2len(t);</a>
<a name="ln1546">    }</a>
<a name="ln1547">  }</a>
<a name="ln1548">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">/// &quot;byteidx()&quot; function</a>
<a name="ln1552">void f_byteidx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1553">{</a>
<a name="ln1554">  byteidx_common(argvars, rettv, false);</a>
<a name="ln1555">}</a>
<a name="ln1556"> </a>
<a name="ln1557">/// &quot;byteidxcomp()&quot; function</a>
<a name="ln1558">void f_byteidxcomp(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1559">{</a>
<a name="ln1560">  byteidx_common(argvars, rettv, true);</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">/// &quot;charidx()&quot; function</a>
<a name="ln1564">void f_charidx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1565">{</a>
<a name="ln1566">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1567"> </a>
<a name="ln1568">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln1569">      || tv_check_for_number_arg(argvars, 1) == FAIL</a>
<a name="ln1570">      || tv_check_for_opt_bool_arg(argvars, 2) == FAIL</a>
<a name="ln1571">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln1572">          &amp;&amp; tv_check_for_opt_bool_arg(argvars, 3) == FAIL)) {</a>
<a name="ln1573">    return;</a>
<a name="ln1574">  }</a>
<a name="ln1575"> </a>
<a name="ln1576">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1577">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln1578">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln1579">    return;</a>
<a name="ln1580">  }</a>
<a name="ln1581"> </a>
<a name="ln1582">  varnumber_T countcc = false;</a>
<a name="ln1583">  varnumber_T utf16idx = false;</a>
<a name="ln1584">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1585">    countcc = tv_get_bool(&amp;argvars[2]);</a>
<a name="ln1586">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1587">      utf16idx = tv_get_bool(&amp;argvars[3]);</a>
<a name="ln1588">    }</a>
<a name="ln1589">  }</a>
<a name="ln1590"> </a>
<a name="ln1591">  int (*ptr2len)(const char *);</a>
<a name="ln1592">  if (countcc) {</a>
<a name="ln1593">    ptr2len = utf_ptr2len;</a>
<a name="ln1594">  } else {</a>
<a name="ln1595">    ptr2len = utfc_ptr2len;</a>
<a name="ln1596">  }</a>
<a name="ln1597"> </a>
<a name="ln1598">  const char *p;</a>
<a name="ln1599">  int len;</a>
<a name="ln1600">  for (p = str, len = 0; utf16idx ? idx &gt;= 0 : p &lt;= str + idx; len++) {</a>
<a name="ln1601">    if (*p == NUL) {</a>
<a name="ln1602">      // If the index is exactly the number of bytes or utf-16 code units</a>
<a name="ln1603">      // in the string then return the length of the string in characters.</a>
<a name="ln1604">      if (utf16idx ? (idx == 0) : (p == (str + idx))) {</a>
<a name="ln1605">        rettv-&gt;vval.v_number = len;</a>
<a name="ln1606">      }</a>
<a name="ln1607">      return;</a>
<a name="ln1608">    }</a>
<a name="ln1609">    if (utf16idx) {</a>
<a name="ln1610">      idx--;</a>
<a name="ln1611">      const int clen = ptr2len(p);</a>
<a name="ln1612">      const int c = (clen &gt; 1) ? utf_ptr2char(p) : *p;</a>
<a name="ln1613">      if (c &gt; 0xFFFF) {</a>
<a name="ln1614">        idx--;</a>
<a name="ln1615">      }</a>
<a name="ln1616">    }</a>
<a name="ln1617">    p += ptr2len(p);</a>
<a name="ln1618">  }</a>
<a name="ln1619"> </a>
<a name="ln1620">  rettv-&gt;vval.v_number = len &gt; 0 ? len - 1 : 0;</a>
<a name="ln1621">}</a>
<a name="ln1622"> </a>
<a name="ln1623">/// &quot;str2list()&quot; function</a>
<a name="ln1624">void f_str2list(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1625">{</a>
<a name="ln1626">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln1627">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1628"> </a>
<a name="ln1629">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln1630">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln1631">  }</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">/// &quot;str2nr()&quot; function</a>
<a name="ln1635">void f_str2nr(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1636">{</a>
<a name="ln1637">  int base = 10;</a>
<a name="ln1638">  int what = 0;</a>
<a name="ln1639"> </a>
<a name="ln1640">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1641">    base = (int)tv_get_number(&amp;argvars[1]);</a>
<a name="ln1642">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln1643">      emsg(_(e_invarg));</a>
<a name="ln1644">      return;</a>
<a name="ln1645">    }</a>
<a name="ln1646">    if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; tv_get_bool(&amp;argvars[2])) {</a>
<a name="ln1647">      what |= STR2NR_QUOTE;</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650"> </a>
<a name="ln1651">  char *p = skipwhite(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1652">  bool isneg = (*p == '-');</a>
<a name="ln1653">  if (*p == '+' || *p == '-') {</a>
<a name="ln1654">    p = skipwhite(p + 1);</a>
<a name="ln1655">  }</a>
<a name="ln1656">  switch (base) {</a>
<a name="ln1657">  case 2:</a>
<a name="ln1658">    what |= STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln1659">    break;</a>
<a name="ln1660">  case 8:</a>
<a name="ln1661">    what |= STR2NR_OCT | STR2NR_OOCT | STR2NR_FORCE;</a>
<a name="ln1662">    break;</a>
<a name="ln1663">  case 16:</a>
<a name="ln1664">    what |= STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln1665">    break;</a>
<a name="ln1666">  }</a>
<a name="ln1667">  varnumber_T n;</a>
<a name="ln1668">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0, false, NULL);</a>
<a name="ln1669">  // Text after the number is silently ignored.</a>
<a name="ln1670">  if (isneg) {</a>
<a name="ln1671">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln1672">  } else {</a>
<a name="ln1673">    rettv-&gt;vval.v_number = n;</a>
<a name="ln1674">  }</a>
<a name="ln1675">}</a>
<a name="ln1676"> </a>
<a name="ln1677">/// &quot;strgetchar()&quot; function</a>
<a name="ln1678">void f_strgetchar(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1679">{</a>
<a name="ln1680">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1681"> </a>
<a name="ln1682">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln1683">  if (str == NULL) {</a>
<a name="ln1684">    return;</a>
<a name="ln1685">  }</a>
<a name="ln1686">  bool error = false;</a>
<a name="ln1687">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1688">  if (error) {</a>
<a name="ln1689">    return;</a>
<a name="ln1690">  }</a>
<a name="ln1691"> </a>
<a name="ln1692">  const size_t len = strlen(str);</a>
<a name="ln1693">  size_t byteidx = 0;</a>
<a name="ln1694"> </a>
<a name="ln1695">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln1696">    if (charidx == 0) {</a>
<a name="ln1697">      rettv-&gt;vval.v_number = utf_ptr2char(str + byteidx);</a>
<a name="ln1698">      break;</a>
<a name="ln1699">    }</a>
<a name="ln1700">    charidx--;</a>
<a name="ln1701">    byteidx += (size_t)utf_ptr2len(str + byteidx);</a>
<a name="ln1702">  }</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">/// &quot;stridx()&quot; function</a>
<a name="ln1706">void f_stridx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1707">{</a>
<a name="ln1708">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1709"> </a>
<a name="ln1710">  char buf[NUMBUFLEN];</a>
<a name="ln1711">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1712">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln1713">  const char *const haystack_start = haystack;</a>
<a name="ln1714">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln1715">    return;  // Type error; errmsg already given.</a>
<a name="ln1716">  }</a>
<a name="ln1717"> </a>
<a name="ln1718">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1719">    bool error = false;</a>
<a name="ln1720"> </a>
<a name="ln1721">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln1722">                                                             &amp;error);</a>
<a name="ln1723">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln1724">      return;</a>
<a name="ln1725">    }</a>
<a name="ln1726">    if (start_idx &gt;= 0) {</a>
<a name="ln1727">      haystack += start_idx;</a>
<a name="ln1728">    }</a>
<a name="ln1729">  }</a>
<a name="ln1730"> </a>
<a name="ln1731">  const char *pos = strstr(haystack, needle);</a>
<a name="ln1732">  if (pos != NULL) {</a>
<a name="ln1733">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln1734">  }</a>
<a name="ln1735">}</a>
<a name="ln1736"> </a>
<a name="ln1737">/// &quot;string()&quot; function</a>
<a name="ln1738">void f_string(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1739">{</a>
<a name="ln1740">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1741">  rettv-&gt;vval.v_string = encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln1742">}</a>
<a name="ln1743"> </a>
<a name="ln1744">/// &quot;strlen()&quot; function</a>
<a name="ln1745">void f_strlen(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1746">{</a>
<a name="ln1747">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">static void strchar_common(typval_T *argvars, typval_T *rettv, bool skipcc)</a>
<a name="ln1751">{</a>
<a name="ln1752">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1753">  varnumber_T len = 0;</a>
<a name="ln1754">  int (*func_mb_ptr2char_adv)(const char **pp);</a>
<a name="ln1755"> </a>
<a name="ln1756">  func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln1757">  while (*s != NUL) {</a>
<a name="ln1758">    func_mb_ptr2char_adv(&amp;s);</a>
<a name="ln1759">    len++;</a>
<a name="ln1760">  }</a>
<a name="ln1761">  rettv-&gt;vval.v_number = len;</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">/// &quot;strcharlen()&quot; function</a>
<a name="ln1765">void f_strcharlen(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1766">{</a>
<a name="ln1767">  strchar_common(argvars, rettv, true);</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">/// &quot;strchars()&quot; function</a>
<a name="ln1771">void f_strchars(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1772">{</a>
<a name="ln1773">  varnumber_T skipcc = false;</a>
<a name="ln1774"> </a>
<a name="ln1775">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1776">    bool error = false;</a>
<a name="ln1777">    skipcc = tv_get_bool_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1778">    if (error) {</a>
<a name="ln1779">      return;</a>
<a name="ln1780">    }</a>
<a name="ln1781">    if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln1782">      semsg(_(e_using_number_as_bool_nr), skipcc);</a>
<a name="ln1783">      return;</a>
<a name="ln1784">    }</a>
<a name="ln1785">  }</a>
<a name="ln1786"> </a>
<a name="ln1787">  strchar_common(argvars, rettv, skipcc);</a>
<a name="ln1788">}</a>
<a name="ln1789"> </a>
<a name="ln1790">/// &quot;strutf16len()&quot; function</a>
<a name="ln1791">void f_strutf16len(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1792">{</a>
<a name="ln1793">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1794"> </a>
<a name="ln1795">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln1796">      || tv_check_for_opt_bool_arg(argvars, 1) == FAIL) {</a>
<a name="ln1797">    return;</a>
<a name="ln1798">  }</a>
<a name="ln1799"> </a>
<a name="ln1800">  varnumber_T countcc = false;</a>
<a name="ln1801">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1802">    countcc = tv_get_bool(&amp;argvars[1]);</a>
<a name="ln1803">  }</a>
<a name="ln1804"> </a>
<a name="ln1805">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1806">  varnumber_T len = 0;</a>
<a name="ln1807">  int (*func_mb_ptr2char_adv)(const char **pp);</a>
<a name="ln1808"> </a>
<a name="ln1809">  func_mb_ptr2char_adv = countcc ? mb_cptr2char_adv : mb_ptr2char_adv;</a>
<a name="ln1810">  while (*s != NUL) {</a>
<a name="ln1811">    const int ch = func_mb_ptr2char_adv(&amp;s);</a>
<a name="ln1812">    if (ch &gt; 0xFFFF) {</a>
<a name="ln1813">      len++;</a>
<a name="ln1814">    }</a>
<a name="ln1815">    len++;</a>
<a name="ln1816">  }</a>
<a name="ln1817">  rettv-&gt;vval.v_number = len;</a>
<a name="ln1818">}</a>
<a name="ln1819"> </a>
<a name="ln1820">/// &quot;strdisplaywidth()&quot; function</a>
<a name="ln1821">void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1822">{</a>
<a name="ln1823">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1824">  int col = 0;</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln1827">    col = (int)tv_get_number(&amp;argvars[1]);</a>
<a name="ln1828">  }</a>
<a name="ln1829"> </a>
<a name="ln1830">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char *)s) - col);</a>
<a name="ln1831">}</a>
<a name="ln1832"> </a>
<a name="ln1833">/// &quot;strwidth()&quot; function</a>
<a name="ln1834">void f_strwidth(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1835">{</a>
<a name="ln1836">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1837"> </a>
<a name="ln1838">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells(s);</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841">/// &quot;strcharpart()&quot; function</a>
<a name="ln1842">void f_strcharpart(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1843">{</a>
<a name="ln1844">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1845">  const size_t slen = strlen(p);</a>
<a name="ln1846"> </a>
<a name="ln1847">  int nbyte = 0;</a>
<a name="ln1848">  varnumber_T skipcc = false;</a>
<a name="ln1849">  bool error = false;</a>
<a name="ln1850">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1851">  if (!error) {</a>
<a name="ln1852">    if (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln1853">        &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1854">      skipcc = tv_get_bool_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln1855">      if (error) {</a>
<a name="ln1856">        return;</a>
<a name="ln1857">      }</a>
<a name="ln1858">      if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln1859">        semsg(_(e_using_number_as_bool_nr), skipcc);</a>
<a name="ln1860">        return;</a>
<a name="ln1861">      }</a>
<a name="ln1862">    }</a>
<a name="ln1863"> </a>
<a name="ln1864">    if (nchar &gt; 0) {</a>
<a name="ln1865">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln1866">        if (skipcc) {</a>
<a name="ln1867">          nbyte += utfc_ptr2len(p + nbyte);</a>
<a name="ln1868">        } else {</a>
<a name="ln1869">          nbyte += utf_ptr2len(p + nbyte);</a>
<a name="ln1870">        }</a>
<a name="ln1871">        nchar--;</a>
<a name="ln1872">      }</a>
<a name="ln1873">    } else {</a>
<a name="ln1874">      nbyte = (int)nchar;</a>
<a name="ln1875">    }</a>
<a name="ln1876">  }</a>
<a name="ln1877">  int len = 0;</a>
<a name="ln1878">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1879">    int charlen = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln1880">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln1881">      int off = nbyte + len;</a>
<a name="ln1882"> </a>
<a name="ln1883">      if (off &lt; 0) {</a>
<a name="ln1884">        len += 1;</a>
<a name="ln1885">      } else {</a>
<a name="ln1886">        if (skipcc) {</a>
<a name="ln1887">          len += utfc_ptr2len(p + off);</a>
<a name="ln1888">        } else {</a>
<a name="ln1889">          len += utf_ptr2len(p + off);</a>
<a name="ln1890">        }</a>
<a name="ln1891">      }</a>
<a name="ln1892">      charlen--;</a>
<a name="ln1893">    }</a>
<a name="ln1894">  } else {</a>
<a name="ln1895">    len = (int)slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln1896">  }</a>
<a name="ln1897"> </a>
<a name="ln1898">  // Only return the overlap between the specified part and the actual</a>
<a name="ln1899">  // string.</a>
<a name="ln1900">  if (nbyte &lt; 0) {</a>
<a name="ln1901">    len += nbyte;</a>
<a name="ln1902">    nbyte = 0;</a>
<a name="ln1903">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln1904">    nbyte = (int)slen;</a>
<a name="ln1905">  }</a>
<a name="ln1906">  if (len &lt; 0) {</a>
<a name="ln1907">    len = 0;</a>
<a name="ln1908">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln1909">    len = (int)slen - nbyte;</a>
<a name="ln1910">  }</a>
<a name="ln1911"> </a>
<a name="ln1912">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1913">  rettv-&gt;vval.v_string = xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">/// &quot;strpart()&quot; function</a>
<a name="ln1917">void f_strpart(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1918">{</a>
<a name="ln1919">  bool error = false;</a>
<a name="ln1920"> </a>
<a name="ln1921">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln1922">  const size_t slen = strlen(p);</a>
<a name="ln1923"> </a>
<a name="ln1924">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1925">  varnumber_T len;</a>
<a name="ln1926">  if (error) {</a>
<a name="ln1927">    len = 0;</a>
<a name="ln1928">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1929">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln1930">  } else {</a>
<a name="ln1931">    len = (varnumber_T)slen - n;  // Default len: all bytes that are available.</a>
<a name="ln1932">  }</a>
<a name="ln1933"> </a>
<a name="ln1934">  // Only return the overlap between the specified part and the actual</a>
<a name="ln1935">  // string.</a>
<a name="ln1936">  if (n &lt; 0) {</a>
<a name="ln1937">    len += n;</a>
<a name="ln1938">    n = 0;</a>
<a name="ln1939">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln1940">    n = (varnumber_T)slen;</a>
<a name="ln1941">  }</a>
<a name="ln1942">  if (len &lt; 0) {</a>
<a name="ln1943">    len = 0;</a>
<a name="ln1944">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln1945">    len = (varnumber_T)slen - n;</a>
<a name="ln1946">  }</a>
<a name="ln1947"> </a>
<a name="ln1948">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln1949">    int off;</a>
<a name="ln1950"> </a>
<a name="ln1951">    // length in characters</a>
<a name="ln1952">    for (off = (int)n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln1953">      off += utfc_ptr2len(p + off);</a>
<a name="ln1954">    }</a>
<a name="ln1955">    len = off - n;</a>
<a name="ln1956">  }</a>
<a name="ln1957"> </a>
<a name="ln1958">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1959">  rettv-&gt;vval.v_string = xmemdupz(p + n, (size_t)len);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">/// &quot;strridx()&quot; function</a>
<a name="ln1963">void f_strridx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1964">{</a>
<a name="ln1965">  char buf[NUMBUFLEN];</a>
<a name="ln1966">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln1967">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln1968"> </a>
<a name="ln1969">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln1970">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln1971">    return;  // Type error; errmsg already given.</a>
<a name="ln1972">  }</a>
<a name="ln1973"> </a>
<a name="ln1974">  const size_t haystack_len = strlen(haystack);</a>
<a name="ln1975">  ptrdiff_t end_idx;</a>
<a name="ln1976">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1977">    // Third argument: upper limit for index.</a>
<a name="ln1978">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln1979">    if (end_idx &lt; 0) {</a>
<a name="ln1980">      return;  // Can never find a match.</a>
<a name="ln1981">    }</a>
<a name="ln1982">  } else {</a>
<a name="ln1983">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln1984">  }</a>
<a name="ln1985"> </a>
<a name="ln1986">  const char *lastmatch = NULL;</a>
<a name="ln1987">  if (*needle == NUL) {</a>
<a name="ln1988">    // Empty string matches past the end.</a>
<a name="ln1989">    lastmatch = haystack + end_idx;</a>
<a name="ln1990">  } else {</a>
<a name="ln1991">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln1992">      rest = strstr(rest, needle);</a>
<a name="ln1993">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln1994">        break;</a>
<a name="ln1995">      }</a>
<a name="ln1996">      lastmatch = rest;</a>
<a name="ln1997">    }</a>
<a name="ln1998">  }</a>
<a name="ln1999"> </a>
<a name="ln2000">  if (lastmatch != NULL) {</a>
<a name="ln2001">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln2002">  }</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">/// &quot;strtrans()&quot; function</a>
<a name="ln2006">void f_strtrans(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2007">{</a>
<a name="ln2008">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2009">  rettv-&gt;vval.v_string = transstr(tv_get_string(&amp;argvars[0]), true);</a>
<a name="ln2010">}</a>
<a name="ln2011"> </a>
<a name="ln2012">/// &quot;utf16idx()&quot; function</a>
<a name="ln2013">///</a>
<a name="ln2014">/// Converts a byte or character offset in a string to the corresponding UTF-16</a>
<a name="ln2015">/// code unit offset.</a>
<a name="ln2016">void f_utf16idx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2017">{</a>
<a name="ln2018">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2019"> </a>
<a name="ln2020">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln2021">      || tv_check_for_opt_number_arg(argvars, 1) == FAIL</a>
<a name="ln2022">      || tv_check_for_opt_bool_arg(argvars, 2) == FAIL</a>
<a name="ln2023">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2024">          &amp;&amp; tv_check_for_opt_bool_arg(argvars, 3) == FAIL)) {</a>
<a name="ln2025">    return;</a>
<a name="ln2026">  }</a>
<a name="ln2027"> </a>
<a name="ln2028">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2029">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln2030">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln2031">    return;</a>
<a name="ln2032">  }</a>
<a name="ln2033"> </a>
<a name="ln2034">  varnumber_T countcc = false;</a>
<a name="ln2035">  varnumber_T charidx = false;</a>
<a name="ln2036">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2037">    countcc = tv_get_bool(&amp;argvars[2]);</a>
<a name="ln2038">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln2039">      charidx = tv_get_bool(&amp;argvars[3]);</a>
<a name="ln2040">    }</a>
<a name="ln2041">  }</a>
<a name="ln2042"> </a>
<a name="ln2043">  int (*ptr2len)(const char *);</a>
<a name="ln2044">  if (countcc) {</a>
<a name="ln2045">    ptr2len = utf_ptr2len;</a>
<a name="ln2046">  } else {</a>
<a name="ln2047">    ptr2len = utfc_ptr2len;</a>
<a name="ln2048">  }</a>
<a name="ln2049"> </a>
<a name="ln2050">  const char *p;</a>
<a name="ln2051">  int len;</a>
<a name="ln2052">  int utf16idx = 0;</a>
<a name="ln2053">  for (p = str, len = 0; charidx ? idx &gt;= 0 : p &lt;= str + idx; len++) {</a>
<a name="ln2054">    if (*p == NUL) {</a>
<a name="ln2055">      // If the index is exactly the number of bytes or characters in the</a>
<a name="ln2056">      // string then return the length of the string in utf-16 code units.</a>
<a name="ln2057">      if (charidx ? (idx == 0) : (p == (str + idx))) {</a>
<a name="ln2058">        rettv-&gt;vval.v_number = len;</a>
<a name="ln2059">      }</a>
<a name="ln2060">      return;</a>
<a name="ln2061">    }</a>
<a name="ln2062">    utf16idx = len;</a>
<a name="ln2063">    const int clen = ptr2len(p);</a>
<a name="ln2064">    const int c = (clen &gt; 1) ? utf_ptr2char(p) : *p;</a>
<a name="ln2065">    if (c &gt; 0xFFFF) {</a>
<a name="ln2066">      len++;</a>
<a name="ln2067">    }</a>
<a name="ln2068">    p += ptr2len(p);</a>
<a name="ln2069">    if (charidx) {</a>
<a name="ln2070">      idx--;</a>
<a name="ln2071">    }</a>
<a name="ln2072">  }</a>
<a name="ln2073"> </a>
<a name="ln2074">  rettv-&gt;vval.v_number = utf16idx;</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">/// &quot;tolower(string)&quot; function</a>
<a name="ln2078">void f_tolower(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2079">{</a>
<a name="ln2080">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2081">  rettv-&gt;vval.v_string = strcase_save(tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2082">}</a>
<a name="ln2083"> </a>
<a name="ln2084">/// &quot;toupper(string)&quot; function</a>
<a name="ln2085">void f_toupper(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2086">{</a>
<a name="ln2087">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2088">  rettv-&gt;vval.v_string = strcase_save(tv_get_string(&amp;argvars[0]), true);</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091">/// &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln2092">void f_tr(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2093">{</a>
<a name="ln2094">  char buf[NUMBUFLEN];</a>
<a name="ln2095">  char buf2[NUMBUFLEN];</a>
<a name="ln2096"> </a>
<a name="ln2097">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2098">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2099">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln2100"> </a>
<a name="ln2101">  // Default return value: empty string.</a>
<a name="ln2102">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2103">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2104">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln2105">    return;  // Type error; errmsg already given.</a>
<a name="ln2106">  }</a>
<a name="ln2107">  garray_T ga;</a>
<a name="ln2108">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln2109"> </a>
<a name="ln2110">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln2111">  bool first = true;</a>
<a name="ln2112">  while (*in_str != NUL) {</a>
<a name="ln2113">    const char *cpstr = in_str;</a>
<a name="ln2114">    const int inlen = utfc_ptr2len(in_str);</a>
<a name="ln2115">    int cplen = inlen;</a>
<a name="ln2116">    int idx = 0;</a>
<a name="ln2117">    int fromlen;</a>
<a name="ln2118">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln2119">      fromlen = utfc_ptr2len(p);</a>
<a name="ln2120">      if (fromlen == inlen &amp;&amp; strncmp(in_str, p, (size_t)inlen) == 0) {</a>
<a name="ln2121">        int tolen;</a>
<a name="ln2122">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln2123">          tolen = utfc_ptr2len(p);</a>
<a name="ln2124">          if (idx-- == 0) {</a>
<a name="ln2125">            cplen = tolen;</a>
<a name="ln2126">            cpstr = p;</a>
<a name="ln2127">            break;</a>
<a name="ln2128">          }</a>
<a name="ln2129">        }</a>
<a name="ln2130">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln2131">          goto error;</a>
<a name="ln2132">        }</a>
<a name="ln2133">        break;</a>
<a name="ln2134">      }</a>
<a name="ln2135">      idx++;</a>
<a name="ln2136">    }</a>
<a name="ln2137"> </a>
<a name="ln2138">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln2139">      // Check that fromstr and tostr have the same number of</a>
<a name="ln2140">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln2141">      // of in_str doesn't appear in fromstr.</a>
<a name="ln2142">      first = false;</a>
<a name="ln2143">      int tolen;</a>
<a name="ln2144">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln2145">        tolen = utfc_ptr2len(p);</a>
<a name="ln2146">        idx--;</a>
<a name="ln2147">      }</a>
<a name="ln2148">      if (idx != 0) {</a>
<a name="ln2149">        goto error;</a>
<a name="ln2150">      }</a>
<a name="ln2151">    }</a>
<a name="ln2152"> </a>
<a name="ln2153">    ga_grow(&amp;ga, cplen);</a>
<a name="ln2154">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln2155">    ga.ga_len += cplen;</a>
<a name="ln2156"> </a>
<a name="ln2157">    in_str += inlen;</a>
<a name="ln2158">  }</a>
<a name="ln2159"> </a>
<a name="ln2160">  // add a terminating NUL</a>
<a name="ln2161">  ga_append(&amp;ga, NUL);</a>
<a name="ln2162"> </a>
<a name="ln2163">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln2164">  return;</a>
<a name="ln2165">error:</a>
<a name="ln2166">  semsg(_(e_invarg2), fromstr);</a>
<a name="ln2167">  ga_clear(&amp;ga);</a>
<a name="ln2168">}</a>
<a name="ln2169"> </a>
<a name="ln2170">/// &quot;trim({expr})&quot; function</a>
<a name="ln2171">void f_trim(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2172">{</a>
<a name="ln2173">  char buf1[NUMBUFLEN];</a>
<a name="ln2174">  char buf2[NUMBUFLEN];</a>
<a name="ln2175">  const char *head = tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln2176">  const char *mask = NULL;</a>
<a name="ln2177">  const char *prev;</a>
<a name="ln2178">  const char *p;</a>
<a name="ln2179">  int dir = 0;</a>
<a name="ln2180"> </a>
<a name="ln2181">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2182">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2183">  if (head == NULL) {</a>
<a name="ln2184">    return;</a>
<a name="ln2185">  }</a>
<a name="ln2186"> </a>
<a name="ln2187">  if (tv_check_for_opt_string_arg(argvars, 1) == FAIL) {</a>
<a name="ln2188">    return;</a>
<a name="ln2189">  }</a>
<a name="ln2190"> </a>
<a name="ln2191">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2192">    mask = tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln2193">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2194">      bool error = false;</a>
<a name="ln2195">      // leading or trailing characters to trim</a>
<a name="ln2196">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2197">      if (error) {</a>
<a name="ln2198">        return;</a>
<a name="ln2199">      }</a>
<a name="ln2200">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln2201">        semsg(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln2202">        return;</a>
<a name="ln2203">      }</a>
<a name="ln2204">    }</a>
<a name="ln2205">  }</a>
<a name="ln2206"> </a>
<a name="ln2207">  int c1;</a>
<a name="ln2208">  if (dir == 0 || dir == 1) {</a>
<a name="ln2209">    // Trim leading characters</a>
<a name="ln2210">    while (*head != NUL) {</a>
<a name="ln2211">      c1 = utf_ptr2char(head);</a>
<a name="ln2212">      if (mask == NULL) {</a>
<a name="ln2213">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln2214">          break;</a>
<a name="ln2215">        }</a>
<a name="ln2216">      } else {</a>
<a name="ln2217">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2218">          if (c1 == utf_ptr2char(p)) {</a>
<a name="ln2219">            break;</a>
<a name="ln2220">          }</a>
<a name="ln2221">        }</a>
<a name="ln2222">        if (*p == NUL) {</a>
<a name="ln2223">          break;</a>
<a name="ln2224">        }</a>
<a name="ln2225">      }</a>
<a name="ln2226">      MB_PTR_ADV(head);</a>
<a name="ln2227">    }</a>
<a name="ln2228">  }</a>
<a name="ln2229"> </a>
<a name="ln2230">  const char *tail = head + strlen(head);</a>
<a name="ln2231">  if (dir == 0 || dir == 2) {</a>
<a name="ln2232">    // Trim trailing characters</a>
<a name="ln2233">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln2234">      prev = tail;</a>
<a name="ln2235">      MB_PTR_BACK(head, prev);</a>
<a name="ln2236">      c1 = utf_ptr2char(prev);</a>
<a name="ln2237">      if (mask == NULL) {</a>
<a name="ln2238">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln2239">          break;</a>
<a name="ln2240">        }</a>
<a name="ln2241">      } else {</a>
<a name="ln2242">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2243">          if (c1 == utf_ptr2char(p)) {</a>
<a name="ln2244">            break;</a>
<a name="ln2245">          }</a>
<a name="ln2246">        }</a>
<a name="ln2247">        if (*p == NUL) {</a>
<a name="ln2248">          break;</a>
<a name="ln2249">        }</a>
<a name="ln2250">      }</a>
<a name="ln2251">    }</a>
<a name="ln2252">  }</a>
<a name="ln2253">  rettv-&gt;vval.v_string = xstrnsave(head, (size_t)(tail - head));</a>
<a name="ln2254">}</a>
</code></pre>
<div class="balloon" rel="675"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="693"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="1414"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="1426"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>