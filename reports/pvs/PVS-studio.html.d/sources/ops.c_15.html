<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ops.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ops.c: implementation of various operators: op_shift, op_delete, op_tilde,</a>
<a name="ln5">//        op_change, op_yank, do_put, do_join</a>
<a name="ln6"> </a>
<a name="ln7">#include &lt;assert.h&gt;</a>
<a name="ln8">#include &lt;ctype.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;limits.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;string.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln17">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln18">#include &quot;nvim/assert.h&quot;</a>
<a name="ln19">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln24">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln25">#include &quot;nvim/edit.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval.h&quot;</a>
<a name="ln27">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln31">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln32">#include &quot;nvim/fold.h&quot;</a>
<a name="ln33">#include &quot;nvim/garray.h&quot;</a>
<a name="ln34">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln35">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln36">#include &quot;nvim/globals.h&quot;</a>
<a name="ln37">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln38">#include &quot;nvim/indent.h&quot;</a>
<a name="ln39">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln40">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln41">#include &quot;nvim/macros.h&quot;</a>
<a name="ln42">#include &quot;nvim/mark.h&quot;</a>
<a name="ln43">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln44">#include &quot;nvim/memline.h&quot;</a>
<a name="ln45">#include &quot;nvim/memory.h&quot;</a>
<a name="ln46">#include &quot;nvim/message.h&quot;</a>
<a name="ln47">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln48">#include &quot;nvim/move.h&quot;</a>
<a name="ln49">#include &quot;nvim/normal.h&quot;</a>
<a name="ln50">#include &quot;nvim/ops.h&quot;</a>
<a name="ln51">#include &quot;nvim/option.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln54">#include &quot;nvim/plines.h&quot;</a>
<a name="ln55">#include &quot;nvim/search.h&quot;</a>
<a name="ln56">#include &quot;nvim/state.h&quot;</a>
<a name="ln57">#include &quot;nvim/strings.h&quot;</a>
<a name="ln58">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln59">#include &quot;nvim/textformat.h&quot;</a>
<a name="ln60">#include &quot;nvim/types.h&quot;</a>
<a name="ln61">#include &quot;nvim/ui.h&quot;</a>
<a name="ln62">#include &quot;nvim/undo.h&quot;</a>
<a name="ln63">#include &quot;nvim/vim.h&quot;</a>
<a name="ln64">#include &quot;nvim/window.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">static yankreg_T y_regs[NUM_REGISTERS] = { 0 };</a>
<a name="ln67"> </a>
<a name="ln68">static yankreg_T *y_previous = NULL;  // ptr to last written yankreg</a>
<a name="ln69"> </a>
<a name="ln70">// for behavior between start_batch_changes() and end_batch_changes())</a>
<a name="ln71">static int batch_change_count = 0;           // inside a script</a>
<a name="ln72">static bool clipboard_delay_update = false;  // delay clipboard update</a>
<a name="ln73">static bool clipboard_needs_update = false;  // clipboard was updated</a>
<a name="ln74">static bool clipboard_didwarn = false;</a>
<a name="ln75"> </a>
<a name="ln76">// structure used by block_prep, op_delete and op_yank for blockwise operators</a>
<a name="ln77">// also op_change, op_shift, op_insert, op_replace - AKelly</a>
<a name="ln78">struct block_def {</a>
<a name="ln79">  int startspaces;              // 'extra' cols before first char</a>
<a name="ln80">  int endspaces;                // 'extra' cols after last char</a>
<a name="ln81">  int textlen;                  // chars in block</a>
<a name="ln82">  char *textstart;              // pointer to 1st char (partially) in block</a>
<a name="ln83">  colnr_T textcol;              // index of chars (partially) in block</a>
<a name="ln84">  colnr_T start_vcol;           // start col of 1st char wholly inside block</a>
<a name="ln85">  colnr_T end_vcol;             // start col of 1st char wholly after block</a>
<a name="ln86">  int is_short;                 // true if line is too short to fit in block</a>
<a name="ln87">  int is_MAX;                   // true if curswant==MAXCOL when starting</a>
<a name="ln88">  int is_oneChar;               // true if block within one character</a>
<a name="ln89">  int pre_whitesp;              // screen cols of ws before block</a>
<a name="ln90">  int pre_whitesp_c;            // chars of ws before block</a>
<a name="ln91">  colnr_T end_char_vcols;       // number of vcols of post-block char</a>
<a name="ln92">  colnr_T start_char_vcols;     // number of vcols of pre-block char</a>
<a name="ln93">};</a>
<a name="ln94"> </a>
<a name="ln95">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln96"># include &quot;ops.c.generated.h&quot;</a>
<a name="ln97">#endif</a>
<a name="ln98"> </a>
<a name="ln99">static const char e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines[]</a>
<a name="ln100">  = N_(&quot;E883: Search pattern and expression register may not contain two or more lines&quot;);</a>
<a name="ln101"> </a>
<a name="ln102">// Flags for third item in &quot;opchars&quot;.</a>
<a name="ln103">#define OPF_LINES  1  // operator always works on lines</a>
<a name="ln104">#define OPF_CHANGE 2  // operator changes text</a>
<a name="ln105"> </a>
<a name="ln106">// The names of operators.</a>
<a name="ln107">// IMPORTANT: Index must correspond with defines in vim.h!!!</a>
<a name="ln108">// The third field indicates whether the operator always works on lines.</a>
<a name="ln109">static char opchars[][3] = {</a>
<a name="ln110">  { NUL, NUL, 0 },                       // OP_NOP</a>
<a name="ln111">  { 'd', NUL, OPF_CHANGE },              // OP_DELETE</a>
<a name="ln112">  { 'y', NUL, 0 },                       // OP_YANK</a>
<a name="ln113">  { 'c', NUL, OPF_CHANGE },              // OP_CHANGE</a>
<a name="ln114">  { '&lt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_LSHIFT</a>
<a name="ln115">  { '&gt;', NUL, OPF_LINES | OPF_CHANGE },  // OP_RSHIFT</a>
<a name="ln116">  { '!', NUL, OPF_LINES | OPF_CHANGE },  // OP_FILTER</a>
<a name="ln117">  { 'g', '~', OPF_CHANGE },              // OP_TILDE</a>
<a name="ln118">  { '=', NUL, OPF_LINES | OPF_CHANGE },  // OP_INDENT</a>
<a name="ln119">  { 'g', 'q', OPF_LINES | OPF_CHANGE },  // OP_FORMAT</a>
<a name="ln120">  { ':', NUL, OPF_LINES },               // OP_COLON</a>
<a name="ln121">  { 'g', 'U', OPF_CHANGE },              // OP_UPPER</a>
<a name="ln122">  { 'g', 'u', OPF_CHANGE },              // OP_LOWER</a>
<a name="ln123">  { 'J', NUL, OPF_LINES | OPF_CHANGE },  // DO_JOIN</a>
<a name="ln124">  { 'g', 'J', OPF_LINES | OPF_CHANGE },  // DO_JOIN_NS</a>
<a name="ln125">  { 'g', '?', OPF_CHANGE },              // OP_ROT13</a>
<a name="ln126">  { 'r', NUL, OPF_CHANGE },              // OP_REPLACE</a>
<a name="ln127">  { 'I', NUL, OPF_CHANGE },              // OP_INSERT</a>
<a name="ln128">  { 'A', NUL, OPF_CHANGE },              // OP_APPEND</a>
<a name="ln129">  { 'z', 'f', 0         },               // OP_FOLD</a>
<a name="ln130">  { 'z', 'o', OPF_LINES },               // OP_FOLDOPEN</a>
<a name="ln131">  { 'z', 'O', OPF_LINES },               // OP_FOLDOPENREC</a>
<a name="ln132">  { 'z', 'c', OPF_LINES },               // OP_FOLDCLOSE</a>
<a name="ln133">  { 'z', 'C', OPF_LINES },               // OP_FOLDCLOSEREC</a>
<a name="ln134">  { 'z', 'd', OPF_LINES },               // OP_FOLDDEL</a>
<a name="ln135">  { 'z', 'D', OPF_LINES },               // OP_FOLDDELREC</a>
<a name="ln136">  { 'g', 'w', OPF_LINES | OPF_CHANGE },  // OP_FORMAT2</a>
<a name="ln137">  { 'g', '@', OPF_CHANGE },              // OP_FUNCTION</a>
<a name="ln138">  { Ctrl_A, NUL, OPF_CHANGE },           // OP_NR_ADD</a>
<a name="ln139">  { Ctrl_X, NUL, OPF_CHANGE },           // OP_NR_SUB</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">yankreg_T *get_y_previous(void)</a>
<a name="ln143">{</a>
<a name="ln144">  return y_previous;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void set_y_previous(yankreg_T *yreg)</a>
<a name="ln148">{</a>
<a name="ln149">  y_previous = yreg;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">/// Translate a command name into an operator type.</a>
<a name="ln153">/// Must only be called with a valid operator name!</a>
<a name="ln154">int get_op_type(int char1, int char2)</a>
<a name="ln155">{</a>
<a name="ln156">  int i;</a>
<a name="ln157"> </a>
<a name="ln158">  if (char1 == 'r') {</a>
<a name="ln159">    // ignore second character</a>
<a name="ln160">    return OP_REPLACE;</a>
<a name="ln161">  }</a>
<a name="ln162">  if (char1 == '~') {</a>
<a name="ln163">    // when tilde is an operator</a>
<a name="ln164">    return OP_TILDE;</a>
<a name="ln165">  }</a>
<a name="ln166">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_A) {</a>
<a name="ln167">    // add</a>
<a name="ln168">    return OP_NR_ADD;</a>
<a name="ln169">  }</a>
<a name="ln170">  if (char1 == 'g' &amp;&amp; char2 == Ctrl_X) {</a>
<a name="ln171">    // subtract</a>
<a name="ln172">    return OP_NR_SUB;</a>
<a name="ln173">  }</a>
<a name="ln174">  if (char1 == 'z' &amp;&amp; char2 == 'y') {  // OP_YANK</a>
<a name="ln175">    return OP_YANK;</a>
<a name="ln176">  }</a>
<a name="ln177">  for (i = 0;; i++) {</a>
<a name="ln178">    if (opchars[i][0] == char1 &amp;&amp; opchars[i][1] == char2) {</a>
<a name="ln179">      break;</a>
<a name="ln180">    }</a>
<a name="ln181">    if (i == (int)(ARRAY_SIZE(opchars) - 1)) {</a>
<a name="ln182">      internal_error(&quot;get_op_type()&quot;);</a>
<a name="ln183">      break;</a>
<a name="ln184">    }</a>
<a name="ln185">  }</a>
<a name="ln186">  return i;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">/// @return  true if operator &quot;op&quot; always works on whole lines.</a>
<a name="ln190">int op_on_lines(int op)</a>
<a name="ln191">{</a>
<a name="ln192">  return opchars[op][2] &amp; OPF_LINES;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">/// @return  true if operator &quot;op&quot; changes text.</a>
<a name="ln196">int op_is_change(int op)</a>
<a name="ln197">{</a>
<a name="ln198">  return opchars[op][2] &amp; OPF_CHANGE;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">/// Get first operator command character.</a>
<a name="ln202">///</a>
<a name="ln203">/// @return  'g' or 'z' if there is another command character.</a>
<a name="ln204">int get_op_char(int optype)</a>
<a name="ln205">{</a>
<a name="ln206">  return opchars[optype][0];</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/// Get second operator command character.</a>
<a name="ln210">int get_extra_op_char(int optype)</a>
<a name="ln211">{</a>
<a name="ln212">  return opchars[optype][1];</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">/// handle a shift operation</a>
<a name="ln216">void op_shift(oparg_T *oap, int curs_top, int amount)</a>
<a name="ln217">{</a>
<a name="ln218">  long i;</a>
<a name="ln219">  int block_col = 0;</a>
<a name="ln220"> </a>
<a name="ln221">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln222">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln223">    return;</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln227">    block_col = curwin-&gt;w_cursor.col;</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  for (i = oap-&gt;line_count - 1; i &gt;= 0; i--) {</a>
<a name="ln231">    int first_char = (uint8_t)(*get_cursor_line_ptr());</a>
<a name="ln232">    if (first_char == NUL) {  // empty line</a>
<a name="ln233">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln234">    } else if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln235">      shift_block(oap, amount);</a>
<a name="ln236">    } else if (first_char != '#' || !preprocs_left()) {</a>
<a name="ln237">      // Move the line right if it doesn't start with '#', 'smartindent'</a>
<a name="ln238">      // isn't set or 'cindent' isn't set or '#' isn't in 'cino'.</a>
<a name="ln239">      shift_line(oap-&gt;op_type == OP_LSHIFT, p_sr, amount, false);</a>
<a name="ln240">    }</a>
<a name="ln241">    curwin-&gt;w_cursor.lnum++;</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln245">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln246">    curwin-&gt;w_cursor.col = block_col;</a>
<a name="ln247">  } else if (curs_top) {  // put cursor on first line, for &quot;&gt;&gt;&quot;</a>
<a name="ln248">    curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln249">    beginline(BL_SOL | BL_FIX);       // shift_line() may have set cursor.col</a>
<a name="ln250">  } else {</a>
<a name="ln251">    curwin-&gt;w_cursor.lnum--;            // put cursor on last line, for &quot;:&gt;&quot;</a>
<a name="ln252">  }</a>
<a name="ln253">  // The cursor line is not in a closed fold</a>
<a name="ln254">  foldOpenCursor();</a>
<a name="ln255"> </a>
<a name="ln256">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln257">    char *op;</a>
<a name="ln258">    if (oap-&gt;op_type == OP_RSHIFT) {</a>
<a name="ln259">      op = &quot;&gt;&quot;;</a>
<a name="ln260">    } else {</a>
<a name="ln261">      op = &quot;&lt;&quot;;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">    char *msg_line_single = NGETTEXT(&quot;%&quot; PRId64 &quot; line %sed %d time&quot;,</a>
<a name="ln265">                                     &quot;%&quot; PRId64 &quot; line %sed %d times&quot;, amount);</a>
<a name="ln266">    char *msg_line_plural = NGETTEXT(&quot;%&quot; PRId64 &quot; lines %sed %d time&quot;,</a>
<a name="ln267">                                     &quot;%&quot; PRId64 &quot; lines %sed %d times&quot;, amount);</a>
<a name="ln268">    vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln269">                 NGETTEXT(msg_line_single, msg_line_plural, oap-&gt;line_count),</a>
<a name="ln270">                 (int64_t)oap-&gt;line_count, op, amount);</a>
<a name="ln271">    msg_attr_keep(IObuff, 0, true, false);</a>
<a name="ln272">  }</a>
<a name="ln273"> </a>
<a name="ln274">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln275">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln276">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln277">    curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln278">    curbuf-&gt;b_op_end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln279">    if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln280">      curbuf-&gt;b_op_end.col--;</a>
<a name="ln281">    }</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">/// Shift the current line one shiftwidth left (if left != 0) or right</a>
<a name="ln288">/// leaves cursor on first blank in the line.</a>
<a name="ln289">///</a>
<a name="ln290">/// @param call_changed_bytes  call changed_bytes()</a>
<a name="ln291">void shift_line(int left, int round, int amount, int call_changed_bytes)</a>
<a name="ln292">{</a>
<a name="ln293">  const int sw_val = (int)get_sw_value_indent(curbuf);</a>
<a name="ln294"> </a>
<a name="ln295">  int count = get_indent();  // get current indent</a>
<a name="ln296"> </a>
<a name="ln297">  if (round) {  // round off indent</a>
<a name="ln298">    int i = count / sw_val;  // number of 'shiftwidth' rounded down</a>
<a name="ln299">    int j = count % sw_val;  // extra spaces</a>
<a name="ln300">    if (j &amp;&amp; left) {  // first remove extra spaces</a>
<a name="ln301">      amount--;</a>
<a name="ln302">    }</a>
<a name="ln303">    if (left) {</a>
<a name="ln304">      i -= amount;</a>
<a name="ln305">      if (i &lt; 0) {</a>
<a name="ln306">        i = 0;</a>
<a name="ln307">      }</a>
<a name="ln308">    } else {</a>
<a name="ln309">      i += amount;</a>
<a name="ln310">    }</a>
<a name="ln311">    count = i * sw_val;</a>
<a name="ln312">  } else {  // original vi indent</a>
<a name="ln313">    if (left) {</a>
<a name="ln314">      count -= sw_val * amount;</a>
<a name="ln315">      if (count &lt; 0) {</a>
<a name="ln316">        count = 0;</a>
<a name="ln317">      }</a>
<a name="ln318">    } else {</a>
<a name="ln319">      count += sw_val * amount;</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  // Set new indent</a>
<a name="ln324">  if (State &amp; VREPLACE_FLAG) {</a>
<a name="ln325">    change_indent(INDENT_SET, count, false, NUL, call_changed_bytes);</a>
<a name="ln326">  } else {</a>
<a name="ln327">    (void)set_indent(count, call_changed_bytes ? SIN_CHANGED : 0);</a>
<a name="ln328">  }</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">/// Shift one line of the current block one shiftwidth right or left.</a>
<a name="ln332">/// Leaves cursor on first character in block.</a>
<a name="ln333">static void shift_block(oparg_T *oap, int amount)</a>
<a name="ln334">{</a>
<a name="ln335">  const bool left = (oap-&gt;op_type == OP_LSHIFT);</a>
<a name="ln336">  const int oldstate = State;</a>
<a name="ln337">  char *newp;</a>
<a name="ln338">  const int oldcol = curwin-&gt;w_cursor.col;</a>
<a name="ln339">  const int sw_val = (int)get_sw_value_indent(curbuf);</a>
<a name="ln340">  const int ts_val = (int)curbuf-&gt;b_p_ts;</a>
<a name="ln341">  struct block_def bd;</a>
<a name="ln342">  int incr;</a>
<a name="ln343">  const int old_p_ri = p_ri;</a>
<a name="ln344"> </a>
<a name="ln345">  p_ri = 0;                     // don't want revins in indent</a>
<a name="ln346"> </a>
<a name="ln347">  State = MODE_INSERT;          // don't want MODE_REPLACE for State</a>
<a name="ln348">  block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln349">  if (bd.is_short) {</a>
<a name="ln350">    return;</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  // total is number of screen columns to be inserted/removed</a>
<a name="ln354">  int total = (int)((unsigned)amount * (unsigned)sw_val);</a>
<a name="ln355">  if ((total / sw_val) != amount) {</a>
<a name="ln356">    return;   // multiplication overflow</a>
<a name="ln357">  }</a>
<a name="ln358"> </a>
<a name="ln359">  char *const oldp = get_cursor_line_ptr();</a>
<a name="ln360"> </a>
<a name="ln361">  int startcol, oldlen, newlen;</a>
<a name="ln362"> </a>
<a name="ln363">  if (!left) {</a>
<a name="ln364">    //  1. Get start vcol</a>
<a name="ln365">    //  2. Total ws vcols</a>
<a name="ln366">    //  3. Divvy into TABs &amp; spp</a>
<a name="ln367">    //  4. Construct new string</a>
<a name="ln368">    total += bd.pre_whitesp;    // all virtual WS up to &amp; incl a split TAB</a>
<a name="ln369">    colnr_T ws_vcol = bd.start_vcol - bd.pre_whitesp;</a>
<a name="ln370">    char *old_textstart = bd.textstart;</a>
<a name="ln371">    if (bd.startspaces) {</a>
<a name="ln372">      if (utfc_ptr2len(bd.textstart) == 1) {</a>
<a name="ln373">        bd.textstart++;</a>
<a name="ln374">      } else {</a>
<a name="ln375">        ws_vcol = 0;</a>
<a name="ln376">        bd.startspaces = 0;</a>
<a name="ln377">      }</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    // TODO(vim): is passing bd.textstart for start of the line OK?</a>
<a name="ln381">    chartabsize_T cts;</a>
<a name="ln382">    init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln383">                         bd.start_vcol, bd.textstart, bd.textstart);</a>
<a name="ln384">    while (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln385">      incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln386">      total += incr;</a>
<a name="ln387">      cts.cts_vcol += incr;</a>
<a name="ln388">    }</a>
<a name="ln389">    bd.textstart = cts.cts_ptr;</a>
<a name="ln390">    bd.start_vcol = cts.cts_vcol;</a>
<a name="ln391">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln392"> </a>
<a name="ln393">    int tabs = 0, spaces = 0;</a>
<a name="ln394">    // OK, now total=all the VWS reqd, and textstart points at the 1st</a>
<a name="ln395">    // non-ws char in the block.</a>
<a name="ln396">    if (!curbuf-&gt;b_p_et) {</a>
<a name="ln397">      tabstop_fromto(ws_vcol, ws_vcol + total,</a>
<a name="ln398">                     ts_val, curbuf-&gt;b_p_vts_array, &amp;tabs, &amp;spaces);</a>
<a name="ln399">    } else {</a>
<a name="ln400">      spaces = total;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    // if we're splitting a TAB, allow for it</a>
<a name="ln404">    const int col_pre = bd.pre_whitesp_c - (bd.startspaces != 0);</a>
<a name="ln405">    bd.textcol -= col_pre;</a>
<a name="ln406"> </a>
<a name="ln407">    const size_t new_line_len  // the length of the line after the block shift</a>
<a name="ln408">      = (size_t)bd.textcol + (size_t)tabs + (size_t)spaces + strlen(bd.textstart);</a>
<a name="ln409">    newp = xmalloc(new_line_len + 1);</a>
<a name="ln410">    memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln411">    startcol = bd.textcol;</a>
<a name="ln412">    oldlen = (int)(bd.textstart - old_textstart) + col_pre;</a>
<a name="ln413">    newlen = tabs + spaces;</a>
<a name="ln414">    memset(newp + bd.textcol, TAB, (size_t)tabs);</a>
<a name="ln415">    memset(newp + bd.textcol + tabs, ' ', (size_t)spaces);</a>
<a name="ln416">    // Note that STRMOVE() copies the trailing NUL.</a>
<a name="ln417">    STRMOVE(newp + bd.textcol + tabs + spaces, bd.textstart);</a>
<a name="ln418">  } else {  // left</a>
<a name="ln419">    char *verbatim_copy_end;      // end of the part of the line which is</a>
<a name="ln420">                                  // copied verbatim</a>
<a name="ln421">    colnr_T verbatim_copy_width;  // the (displayed) width of this part</a>
<a name="ln422">                                  // of line</a>
<a name="ln423">    char *non_white = bd.textstart;</a>
<a name="ln424"> </a>
<a name="ln425">    // Firstly, let's find the first non-whitespace character that is</a>
<a name="ln426">    // displayed after the block's start column and the character's column</a>
<a name="ln427">    // number. Also, let's calculate the width of all the whitespace</a>
<a name="ln428">    // characters that are displayed in the block and precede the searched</a>
<a name="ln429">    // non-whitespace character.</a>
<a name="ln430"> </a>
<a name="ln431">    // If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character,</a>
<a name="ln432">    // the part of which is displayed at the block's beginning. Let's start</a>
<a name="ln433">    // searching from the next character.</a>
<a name="ln434">    if (bd.startspaces) {</a>
<a name="ln435">      MB_PTR_ADV(non_white);</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    // The character's column is in &quot;bd.start_vcol&quot;.</a>
<a name="ln439">    colnr_T non_white_col = bd.start_vcol;</a>
<a name="ln440"> </a>
<a name="ln441">    chartabsize_T cts;</a>
<a name="ln442">    init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum,</a>
<a name="ln443">                         non_white_col, bd.textstart, non_white);</a>
<a name="ln444">    while (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln445">      incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln446">      cts.cts_vcol += incr;</a>
<a name="ln447">    }</a>
<a name="ln448">    non_white_col = cts.cts_vcol;</a>
<a name="ln449">    non_white = cts.cts_ptr;</a>
<a name="ln450">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln451"> </a>
<a name="ln452">    const colnr_T block_space_width = non_white_col - oap-&gt;start_vcol;</a>
<a name="ln453">    // We will shift by &quot;total&quot; or &quot;block_space_width&quot;, whichever is less.</a>
<a name="ln454">    const colnr_T shift_amount = block_space_width &lt; total</a>
<a name="ln455">        ? block_space_width</a>
<a name="ln456">        : total;</a>
<a name="ln457">    // The column to which we will shift the text.</a>
<a name="ln458">    const colnr_T destination_col = non_white_col - shift_amount;</a>
<a name="ln459"> </a>
<a name="ln460">    // Now let's find out how much of the beginning of the line we can</a>
<a name="ln461">    // reuse without modification.</a>
<a name="ln462">    verbatim_copy_end = bd.textstart;</a>
<a name="ln463">    verbatim_copy_width = bd.start_vcol;</a>
<a name="ln464"> </a>
<a name="ln465">    // If &quot;bd.startspaces&quot; is set, &quot;bd.textstart&quot; points to the character</a>
<a name="ln466">    // preceding the block. We have to subtract its width to obtain its</a>
<a name="ln467">    // column number.</a>
<a name="ln468">    if (bd.startspaces) {</a>
<a name="ln469">      verbatim_copy_width -= bd.start_char_vcols;</a>
<a name="ln470">    }</a>
<a name="ln471">    init_chartabsize_arg(&amp;cts, curwin, 0, verbatim_copy_width,</a>
<a name="ln472">                         bd.textstart, verbatim_copy_end);</a>
<a name="ln473">    while (cts.cts_vcol &lt; destination_col) {</a>
<a name="ln474">      incr = lbr_chartabsize(&amp;cts);</a>
<a name="ln475">      if (cts.cts_vcol + incr &gt; destination_col) {</a>
<a name="ln476">        break;</a>
<a name="ln477">      }</a>
<a name="ln478">      cts.cts_vcol += incr;</a>
<a name="ln479">      MB_PTR_ADV(cts.cts_ptr);</a>
<a name="ln480">    }</a>
<a name="ln481">    verbatim_copy_width = cts.cts_vcol;</a>
<a name="ln482">    verbatim_copy_end = cts.cts_ptr;</a>
<a name="ln483">    clear_chartabsize_arg(&amp;cts);</a>
<a name="ln484"> </a>
<a name="ln485">    // If &quot;destination_col&quot; is different from the width of the initial</a>
<a name="ln486">    // part of the line that will be copied, it means we encountered a tab</a>
<a name="ln487">    // character, which we will have to partly replace with spaces.</a>
<a name="ln488">    assert(destination_col - verbatim_copy_width &gt;= 0);</a>
<a name="ln489">    const size_t fill  // nr of spaces that replace a TAB</a>
<a name="ln490">      = (size_t)(destination_col - verbatim_copy_width);</a>
<a name="ln491"> </a>
<a name="ln492">    assert(verbatim_copy_end - oldp &gt;= 0);</a>
<a name="ln493">    const size_t verbatim_diff = (size_t)(verbatim_copy_end - oldp);</a>
<a name="ln494">    // The replacement line will consist of:</a>
<a name="ln495">    // - the beginning of the original line up to &quot;verbatim_copy_end&quot;,</a>
<a name="ln496">    // - &quot;fill&quot; number of spaces,</a>
<a name="ln497">    // - the rest of the line, pointed to by non_white.</a>
<a name="ln498">    const size_t new_line_len  // the length of the line after the block shift</a>
<a name="ln499">      = verbatim_diff + fill + strlen(non_white);</a>
<a name="ln500"> </a>
<a name="ln501">    newp = xmalloc(new_line_len + 1);</a>
<a name="ln502">    startcol = (int)verbatim_diff;</a>
<a name="ln503">    oldlen = bd.textcol + (int)(non_white - bd.textstart) - (int)verbatim_diff;</a>
<a name="ln504">    newlen = (int)fill;</a>
<a name="ln505">    memmove(newp, oldp, verbatim_diff);</a>
<a name="ln506">    memset(newp + verbatim_diff, ' ', fill);</a>
<a name="ln507">    // Note that STRMOVE() copies the trailing NUL.</a>
<a name="ln508">    STRMOVE(newp + verbatim_diff + fill, non_white);</a>
<a name="ln509">  }</a>
<a name="ln510">  // replace the line</a>
<a name="ln511">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln512">  changed_bytes(curwin-&gt;w_cursor.lnum, bd.textcol);</a>
<a name="ln513">  extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, startcol,</a>
<a name="ln514">                      oldlen, newlen,</a>
<a name="ln515">                      kExtmarkUndo);</a>
<a name="ln516">  State = oldstate;</a>
<a name="ln517">  curwin-&gt;w_cursor.col = oldcol;</a>
<a name="ln518">  p_ri = old_p_ri;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">/// Insert string &quot;s&quot; (b_insert ? before : after) block :AKelly</a>
<a name="ln522">/// Caller must prepare for undo.</a>
<a name="ln523">static void block_insert(oparg_T *oap, char *s, int b_insert, struct block_def *bdp)</a>
<a name="ln524">{</a>
<a name="ln525">  int ts_val;</a>
<a name="ln526">  int count = 0;                // extra spaces to replace a cut TAB</a>
<a name="ln527">  int spaces = 0;               // non-zero if cutting a TAB</a>
<a name="ln528">  colnr_T offset;               // pointer along new line</a>
<a name="ln529">  size_t s_len = strlen(s);</a>
<a name="ln530">  char *newp, *oldp;            // new, old lines</a>
<a name="ln531">  linenr_T lnum;                // loop var</a>
<a name="ln532">  int oldstate = State;</a>
<a name="ln533">  State = MODE_INSERT;          // don't want MODE_REPLACE for State</a>
<a name="ln534"> </a>
<a name="ln535">  for (lnum = oap-&gt;start.lnum + 1; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln536">    block_prep(oap, bdp, lnum, true);</a>
<a name="ln537">    if (bdp-&gt;is_short &amp;&amp; b_insert) {</a>
<a name="ln538">      continue;  // OP_INSERT, line ends before block start</a>
<a name="ln539">    }</a>
<a name="ln540"> </a>
<a name="ln541">    oldp = ml_get(lnum);</a>
<a name="ln542"> </a>
<a name="ln543">    if (b_insert) {</a>
<a name="ln544">      ts_val = bdp-&gt;start_char_vcols;</a>
<a name="ln545">      spaces = bdp-&gt;startspaces;</a>
<a name="ln546">      if (spaces != 0) {</a>
<a name="ln547">        count = ts_val - 1;         // we're cutting a TAB</a>
<a name="ln548">      }</a>
<a name="ln549">      offset = bdp-&gt;textcol;</a>
<a name="ln550">    } else {  // append</a>
<a name="ln551">      ts_val = bdp-&gt;end_char_vcols;</a>
<a name="ln552">      if (!bdp-&gt;is_short) {     // spaces = padding after block</a>
<a name="ln553">        spaces = (bdp-&gt;endspaces ? ts_val - bdp-&gt;endspaces : 0);</a>
<a name="ln554">        if (spaces != 0) {</a>
<a name="ln555">          count = ts_val - 1;           // we're cutting a TAB</a>
<a name="ln556">        }</a>
<a name="ln557">        offset = bdp-&gt;textcol + bdp-&gt;textlen - (spaces != 0);</a>
<a name="ln558">      } else {  // spaces = padding to block edge</a>
<a name="ln559">                // if $ used, just append to EOL (ie spaces==0)</a>
<a name="ln560">        if (!bdp-&gt;is_MAX) {</a>
<a name="ln561">          spaces = (oap-&gt;end_vcol - bdp-&gt;end_vcol) + 1;</a>
<a name="ln562">        }</a>
<a name="ln563">        count = spaces;</a>
<a name="ln564">        offset = bdp-&gt;textcol + bdp-&gt;textlen;</a>
<a name="ln565">      }</a>
<a name="ln566">    }</a>
<a name="ln567"> </a>
<a name="ln568">    if (spaces &gt; 0) {</a>
<a name="ln569">      // avoid copying part of a multi-byte character</a>
<a name="ln570">      offset -= utf_head_off(oldp, oldp + offset);</a>
<a name="ln571">    }</a>
<a name="ln572">    if (spaces &lt; 0) {  // can happen when the cursor was moved</a>
<a name="ln573">      spaces = 0;</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">    assert(count &gt;= 0);</a>
<a name="ln577">    // Make sure the allocated size matches what is actually copied below.</a>
<a name="ln578">    newp = xmalloc(strlen(oldp) + (size_t)spaces + s_len</a>
<a name="ln579">                   + (spaces &gt; 0 &amp;&amp; !bdp-&gt;is_short ? (size_t)ts_val - (size_t)spaces : 0)</a>
<a name="ln580">                   + (size_t)count + 1);</a>
<a name="ln581"> </a>
<a name="ln582">    // copy up to shifted part</a>
<a name="ln583">    memmove(newp, oldp, (size_t)offset);</a>
<a name="ln584">    oldp += offset;</a>
<a name="ln585">    int startcol = offset;</a>
<a name="ln586"> </a>
<a name="ln587">    // insert pre-padding</a>
<a name="ln588">    memset(newp + offset, ' ', (size_t)spaces);</a>
<a name="ln589"> </a>
<a name="ln590">    // copy the new text</a>
<a name="ln591">    memmove(newp + offset + spaces, s, s_len);</a>
<a name="ln592">    offset += (int)s_len;</a>
<a name="ln593"> </a>
<a name="ln594">    int skipped = 0;</a>
<a name="ln595">    if (spaces &gt; 0 &amp;&amp; !bdp-&gt;is_short) {</a>
<a name="ln596">      if (*oldp == TAB) {</a>
<a name="ln597">        // insert post-padding</a>
<a name="ln598">        memset(newp + offset + spaces, ' ', (size_t)(ts_val - spaces));</a>
<a name="ln599">        // We're splitting a TAB, don't copy it.</a>
<a name="ln600">        oldp++;</a>
<a name="ln601">        // We allowed for that TAB, remember this now</a>
<a name="ln602">        count++;</a>
<a name="ln603">        skipped = 1;</a>
<a name="ln604">      } else {</a>
<a name="ln605">        // Not a TAB, no extra spaces</a>
<a name="ln606">        count = spaces;</a>
<a name="ln607">      }</a>
<a name="ln608">    }</a>
<a name="ln609"> </a>
<a name="ln610">    if (spaces &gt; 0) {</a>
<a name="ln611">      offset += count;</a>
<a name="ln612">    }</a>
<a name="ln613">    STRMOVE(newp + offset, oldp);</a>
<a name="ln614"> </a>
<a name="ln615">    ml_replace(lnum, newp, false);</a>
<a name="ln616">    extmark_splice_cols(curbuf, (int)lnum - 1, startcol,</a>
<a name="ln617">                        skipped, offset - startcol, kExtmarkUndo);</a>
<a name="ln618"> </a>
<a name="ln619">    if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln620">      // Set &quot;']&quot; mark to the end of the block instead of the end of</a>
<a name="ln621">      // the insert in the first line.</a>
<a name="ln622">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln623">      curbuf-&gt;b_op_end.col = offset;</a>
<a name="ln624">    }</a>
<a name="ln625">  }   // for all lnum</a>
<a name="ln626"> </a>
<a name="ln627">  State = oldstate;</a>
<a name="ln628"> </a>
<a name="ln629">  changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">/// Handle reindenting a block of lines.</a>
<a name="ln633">void op_reindent(oparg_T *oap, Indenter how)</a>
<a name="ln634">{</a>
<a name="ln635">  long i = 0;</a>
<a name="ln636">  linenr_T first_changed = 0;</a>
<a name="ln637">  linenr_T last_changed = 0;</a>
<a name="ln638">  linenr_T start_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln639"> </a>
<a name="ln640">  // Don't even try when 'modifiable' is off.</a>
<a name="ln641">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln642">    emsg(_(e_modifiable));</a>
<a name="ln643">    return;</a>
<a name="ln644">  }</a>
<a name="ln645"> </a>
<a name="ln646">  // Save for undo.  Do this once for all lines, much faster than doing this</a>
<a name="ln647">  // for each line separately, especially when undoing.</a>
<a name="ln648">  if (u_savecommon(curbuf, start_lnum - 1, start_lnum + (linenr_T)oap-&gt;line_count,</a>
<a name="ln649">                   start_lnum + (linenr_T)oap-&gt;line_count, false) == OK) {</a>
<a name="ln650">    char *l;</a>
<a name="ln651">    int amount;</a>
<a name="ln652">    for (i = oap-&gt;line_count - 1; i &gt;= 0 &amp;&amp; !got_int; i--) {</a>
<a name="ln653">      // it's a slow thing to do, so give feedback so there's no worry</a>
<a name="ln654">      // that the computer's just hung.</a>
<a name="ln655"> </a>
<a name="ln656">      if (i &gt; 1</a>
<a name="ln657">          &amp;&amp; (i % 50 == 0 || i == oap-&gt;line_count - 1)</a>
<a name="ln658">          &amp;&amp; oap-&gt;line_count &gt; p_report) {</a>
<a name="ln659">        smsg(_(&quot;%&quot; PRId64 &quot; lines to indent... &quot;), (int64_t)i);</a>
<a name="ln660">      }</a>
<a name="ln661"> </a>
<a name="ln662">      // Be vi-compatible: For lisp indenting the first line is not</a>
<a name="ln663">      // indented, unless there is only one line.</a>
<a name="ln664">      if (i != oap-&gt;line_count - 1 || oap-&gt;line_count == 1</a>
<a name="ln665">          || how != get_lisp_indent) {</a>
<a name="ln666">        l = skipwhite(get_cursor_line_ptr());</a>
<a name="ln667">        if (*l == NUL) {                      // empty or blank line</a>
<a name="ln668">          amount = 0;</a>
<a name="ln669">        } else {</a>
<a name="ln670">          amount = how();                     // get the indent for this line</a>
<a name="ln671">        }</a>
<a name="ln672">        if (amount &gt;= 0 &amp;&amp; set_indent(amount, 0)) {</a>
<a name="ln673">          // did change the indent, call changed_lines() later</a>
<a name="ln674">          if (first_changed == 0) {</a>
<a name="ln675">            first_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln676">          }</a>
<a name="ln677">          last_changed = curwin-&gt;w_cursor.lnum;</a>
<a name="ln678">        }</a>
<a name="ln679">      }</a>
<a name="ln680">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln681">      curwin-&gt;w_cursor.col = 0;      // make sure it's valid</a>
<a name="ln682">    }</a>
<a name="ln683">  }</a>
<a name="ln684"> </a>
<a name="ln685">  // put cursor on first non-blank of indented line</a>
<a name="ln686">  curwin-&gt;w_cursor.lnum = start_lnum;</a>
<a name="ln687">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln688"> </a>
<a name="ln689">  // Mark changed lines so that they will be redrawn.  When Visual</a>
<a name="ln690">  // highlighting was present, need to continue until the last line.  When</a>
<a name="ln691">  // there is no change still need to remove the Visual highlighting.</a>
<a name="ln692">  if (last_changed != 0) {</a>
<a name="ln693">    changed_lines(first_changed, 0,</a>
<a name="ln694">                  oap-&gt;is_VIsual ? start_lnum + (linenr_T)oap-&gt;line_count :</a>
<a name="ln695">                  last_changed + 1, 0L, true);</a>
<a name="ln696">  } else if (oap-&gt;is_VIsual) {</a>
<a name="ln697">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln701">    i = oap-&gt;line_count - (i + 1);</a>
<a name="ln702">    smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line indented &quot;,</a>
<a name="ln703">                  &quot;%&quot; PRId64 &quot; lines indented &quot;, i),</a>
<a name="ln704">         (int64_t)i);</a>
<a name="ln705">  }</a>
<a name="ln706">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln707">    // set '[ and '] marks</a>
<a name="ln708">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln709">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln710">  }</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">// Keep the last expression line here, for repeating.</a>
<a name="ln714">static char *expr_line = NULL;</a>
<a name="ln715"> </a>
<a name="ln716">/// Get an expression for the &quot;\&quot;=expr1&quot; or &quot;CTRL-R =expr1&quot;</a>
<a name="ln717">///</a>
<a name="ln718">/// @return  '=' when OK, NUL otherwise.</a>
<a name="ln719">int get_expr_register(void)</a>
<a name="ln720">{</a>
<a name="ln721">  char *new_line;</a>
<a name="ln722"> </a>
<a name="ln723">  new_line = getcmdline('=', 0L, 0, true);</a>
<a name="ln724">  if (new_line == NULL) {</a>
<a name="ln725">    return NUL;</a>
<a name="ln726">  }</a>
<a name="ln727">  if (*new_line == NUL) {  // use previous line</a>
<a name="ln728">    xfree(new_line);</a>
<a name="ln729">  } else {</a>
<a name="ln730">    set_expr_line(new_line);</a>
<a name="ln731">  }</a>
<a name="ln732">  return '=';</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">/// Set the expression for the '=' register.</a>
<a name="ln736">/// Argument must be an allocated string.</a>
<a name="ln737">void set_expr_line(char *new_line)</a>
<a name="ln738">{</a>
<a name="ln739">  xfree(expr_line);</a>
<a name="ln740">  expr_line = new_line;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// Get the result of the '=' register expression.</a>
<a name="ln744">///</a>
<a name="ln745">/// @return  a pointer to allocated memory, or NULL for failure.</a>
<a name="ln746">char *get_expr_line(void)</a>
<a name="ln747">{</a>
<a name="ln748">  char *expr_copy;</a>
<a name="ln749">  char *rv;</a>
<a name="ln750">  static int nested = 0;</a>
<a name="ln751"> </a>
<a name="ln752">  if (expr_line == NULL) {</a>
<a name="ln753">    return NULL;</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  // Make a copy of the expression, because evaluating it may cause it to be</a>
<a name="ln757">  // changed.</a>
<a name="ln758">  expr_copy = xstrdup(expr_line);</a>
<a name="ln759"> </a>
<a name="ln760">  // When we are invoked recursively limit the evaluation to 10 levels.</a>
<a name="ln761">  // Then return the string as-is.</a>
<a name="ln762">  if (nested &gt;= 10) {</a>
<a name="ln763">    return expr_copy;</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  nested++;</a>
<a name="ln767">  rv = eval_to_string(expr_copy, true);</a>
<a name="ln768">  nested--;</a>
<a name="ln769">  xfree(expr_copy);</a>
<a name="ln770">  return rv;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/// Get the '=' register expression itself, without evaluating it.</a>
<a name="ln774">char *get_expr_line_src(void)</a>
<a name="ln775">{</a>
<a name="ln776">  if (expr_line == NULL) {</a>
<a name="ln777">    return NULL;</a>
<a name="ln778">  }</a>
<a name="ln779">  return xstrdup(expr_line);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">/// @return  whether `regname` is a valid name of a yank register.</a>
<a name="ln783">///</a>
<a name="ln784">/// @note: There is no check for 0 (default register), caller should do this.</a>
<a name="ln785">/// The black hole register '_' is regarded as valid.</a>
<a name="ln786">///</a>
<a name="ln787">/// @param regname name of register</a>
<a name="ln788">/// @param writing allow only writable registers</a>
<a name="ln789">bool valid_yank_reg(int regname, bool writing)</a>
<a name="ln790">{</a>
<a name="ln791">  if ((regname &gt; 0 &amp;&amp; ASCII_ISALNUM(regname))</a>
<a name="ln792">      || (!writing &amp;&amp; vim_strchr(&quot;/.%:=&quot;, regname) != NULL)</a>
<a name="ln793">      || regname == '#'</a>
<a name="ln794">      || regname == '&quot;'</a>
<a name="ln795">      || regname == '-'</a>
<a name="ln796">      || regname == '_'</a>
<a name="ln797">      || regname == '*'</a>
<a name="ln798">      || regname == '+') {</a>
<a name="ln799">    return true;</a>
<a name="ln800">  }</a>
<a name="ln801">  return false;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">/// @return yankreg_T to use, according to the value of `regname`.</a>
<a name="ln805">/// Cannot handle the '_' (black hole) register.</a>
<a name="ln806">/// Must only be called with a valid register name!</a>
<a name="ln807">///</a>
<a name="ln808">/// @param regname The name of the register used or 0 for the unnamed register</a>
<a name="ln809">/// @param mode One of the following three flags:</a>
<a name="ln810">///</a>
<a name="ln811">/// `YREG_PASTE`:</a>
<a name="ln812">/// Prepare for pasting the register `regname`. With no regname specified,</a>
<a name="ln813">/// read from last written register, or from unnamed clipboard (depending on the</a>
<a name="ln814">/// `clipboard=unnamed` option). Queries the clipboard provider if necessary.</a>
<a name="ln815">///</a>
<a name="ln816">/// `YREG_YANK`:</a>
<a name="ln817">/// Preparare for yanking into `regname`. With no regname specified,</a>
<a name="ln818">/// yank into `&quot;0` register. Update `y_previous` for next unnamed paste.</a>
<a name="ln819">///</a>
<a name="ln820">/// `YREG_PUT`:</a>
<a name="ln821">/// Obtain the location that would be read when pasting `regname`.</a>
<a name="ln822">yankreg_T *get_yank_register(int regname, int mode)</a>
<a name="ln823">{</a>
<a name="ln824">  yankreg_T *reg;</a>
<a name="ln825"> </a>
<a name="ln826">  if (mode == YREG_PASTE &amp;&amp; get_clipboard(regname, &amp;reg, false)) {</a>
<a name="ln827">    // reg is set to clipboard contents.</a>
<a name="ln828">    return reg;</a>
<a name="ln829">  } else if (mode != YREG_YANK</a>
<a name="ln830">             &amp;&amp; (regname == 0 || regname == '&quot;' || regname == '*' || regname == '+')</a>
<a name="ln831">             &amp;&amp; y_previous != NULL) {</a>
<a name="ln832">    // in case clipboard not available, paste from previous used register</a>
<a name="ln833">    return y_previous;</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836">  int i = op_reg_index(regname);</a>
<a name="ln837">  // when not 0-9, a-z, A-Z or '-'/'+'/'*': use register 0</a>
<a name="ln838">  if (i == -1) {</a>
<a name="ln839">    i = 0;</a>
<a name="ln840">  }</a>
<a name="ln841">  reg = &amp;y_regs[i];</a>
<a name="ln842"> </a>
<a name="ln843">  if (mode == YREG_YANK) {</a>
<a name="ln844">    // remember the written register for unnamed paste</a>
<a name="ln845">    y_previous = reg;</a>
<a name="ln846">  }</a>
<a name="ln847">  return reg;</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">static bool is_append_register(int regname)</a>
<a name="ln851">{</a>
<a name="ln852">  return ASCII_ISUPPER(regname);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/// @return  a copy of contents in register `name` for use in do_put. Should be</a>
<a name="ln856">///          freed by caller.</a>
<a name="ln857">yankreg_T *copy_register(int name)</a>
<a name="ln858">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln859">{</a>
<a name="ln860">  yankreg_T *reg = get_yank_register(name, YREG_PASTE);</a>
<a name="ln861"> </a>
<a name="ln862">  yankreg_T *copy = xmalloc(sizeof(yankreg_T));</a>
<a name="ln863">  *copy = *reg;</a>
<a name="ln864">  if (copy-&gt;y_size == 0) {</a>
<a name="ln865">    copy-&gt;y_array = NULL;</a>
<a name="ln866">  } else {</a>
<a name="ln867">    copy-&gt;y_array = xcalloc(copy-&gt;y_size, sizeof(char *));</a>
<a name="ln868">    for (size_t i = 0; i &lt; copy-&gt;y_size; i++) {</a>
<a name="ln869">      copy-&gt;y_array[i] = xstrdup(reg-&gt;y_array[i]);</a>
<a name="ln870">    }</a>
<a name="ln871">  }</a>
<a name="ln872">  return copy;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">/// Check if the current yank register has kMTLineWise register type</a>
<a name="ln876">bool yank_register_mline(int regname)</a>
<a name="ln877">{</a>
<a name="ln878">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln879">    return false;</a>
<a name="ln880">  }</a>
<a name="ln881">  if (regname == '_') {  // black hole is always empty</a>
<a name="ln882">    return false;</a>
<a name="ln883">  }</a>
<a name="ln884">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln885">  return reg-&gt;y_type == kMTLineWise;</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">/// Start or stop recording into a yank register.</a>
<a name="ln889">///</a>
<a name="ln890">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln891">int do_record(int c)</a>
<a name="ln892">{</a>
<a name="ln893">  static int regname;</a>
<a name="ln894">  yankreg_T *old_y_previous;</a>
<a name="ln895">  int retval;</a>
<a name="ln896"> </a>
<a name="ln897">  if (reg_recording == 0) {</a>
<a name="ln898">    // start recording</a>
<a name="ln899">    // registers 0-9, a-z and &quot; are allowed</a>
<a name="ln900">    if (c &lt; 0 || (!ASCII_ISALNUM(c) &amp;&amp; c != '&quot;')) {</a>
<a name="ln901">      retval = FAIL;</a>
<a name="ln902">    } else {</a>
<a name="ln903">      reg_recording = c;</a>
<a name="ln904">      // TODO(bfredl): showmode based messaging is currently missing with cmdheight=0</a>
<a name="ln905">      showmode();</a>
<a name="ln906">      regname = c;</a>
<a name="ln907">      retval = OK;</a>
<a name="ln908"> </a>
<a name="ln909">      apply_autocmds(EVENT_RECORDINGENTER, NULL, NULL, false, curbuf);</a>
<a name="ln910">    }</a>
<a name="ln911">  } else {  // stop recording</a>
<a name="ln912">    save_v_event_T save_v_event;</a>
<a name="ln913">    // Set the v:event dictionary with information about the recording.</a>
<a name="ln914">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln915"> </a>
<a name="ln916">    // The recorded text contents.</a>
<a name="ln917">    char *p = get_recorded();</a>
<a name="ln918">    if (p != NULL) {</a>
<a name="ln919">      // Remove escaping for K_SPECIAL in multi-byte chars.</a>
<a name="ln920">      vim_unescape_ks(p);</a>
<a name="ln921">      (void)tv_dict_add_str(dict, S_LEN(&quot;regcontents&quot;), p);</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln925">    char buf[NUMBUFLEN + 2];</a>
<a name="ln926">    buf[0] = (char)regname;</a>
<a name="ln927">    buf[1] = NUL;</a>
<a name="ln928">    (void)tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln929">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln930"> </a>
<a name="ln931">    // Get the recorded key hits.  K_SPECIAL will be escaped, this</a>
<a name="ln932">    // needs to be removed again to put it in a register.  exec_reg then</a>
<a name="ln933">    // adds the escaping back later.</a>
<a name="ln934">    apply_autocmds(EVENT_RECORDINGLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln935">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln936">    reg_recorded = reg_recording;</a>
<a name="ln937">    reg_recording = 0;</a>
<a name="ln938">    if (p_ch == 0 || ui_has(kUIMessages)) {</a>
<a name="ln939">      showmode();</a>
<a name="ln940">    } else {</a>
<a name="ln941">      msg(&quot;&quot;);</a>
<a name="ln942">    }</a>
<a name="ln943">    if (p == NULL) {</a>
<a name="ln944">      retval = FAIL;</a>
<a name="ln945">    } else {</a>
<a name="ln946">      // We don't want to change the default register here, so save and</a>
<a name="ln947">      // restore the current register name.</a>
<a name="ln948">      old_y_previous = y_previous;</a>
<a name="ln949"> </a>
<a name="ln950">      retval = stuff_yank(regname, p);</a>
<a name="ln951"> </a>
<a name="ln952">      y_previous = old_y_previous;</a>
<a name="ln953">    }</a>
<a name="ln954">  }</a>
<a name="ln955">  return retval;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static void set_yreg_additional_data(yankreg_T *reg, dict_T *additional_data)</a>
<a name="ln959">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln960">{</a>
<a name="ln961">  if (reg-&gt;additional_data == additional_data) {</a>
<a name="ln962">    return;</a>
<a name="ln963">  }</a>
<a name="ln964">  tv_dict_unref(reg-&gt;additional_data);</a>
<a name="ln965">  reg-&gt;additional_data = additional_data;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">/// Stuff string &quot;p&quot; into yank register &quot;regname&quot; as a single line (append if</a>
<a name="ln969">/// uppercase). &quot;p&quot; must have been allocated.</a>
<a name="ln970">///</a>
<a name="ln971">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln972">static int stuff_yank(int regname, char *p)</a>
<a name="ln973">{</a>
<a name="ln974">  // check for read-only register</a>
<a name="ln975">  if (regname != 0 &amp;&amp; !valid_yank_reg(regname, true)) {</a>
<a name="ln976">    xfree(p);</a>
<a name="ln977">    return FAIL;</a>
<a name="ln978">  }</a>
<a name="ln979">  if (regname == '_') {             // black hole: don't do anything</a>
<a name="ln980">    xfree(p);</a>
<a name="ln981">    return OK;</a>
<a name="ln982">  }</a>
<a name="ln983">  yankreg_T *reg = get_yank_register(regname, YREG_YANK);</a>
<a name="ln984">  if (is_append_register(regname) &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln985">    char **pp = &amp;(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln986">    char *lp = xmalloc(strlen(*pp) + strlen(p) + 1);</a>
<a name="ln987">    STRCPY(lp, *pp);</a>
<a name="ln988">    // TODO(philix): use xstpcpy() in stuff_yank()</a>
<a name="ln989">    STRCAT(lp, p);</a>
<a name="ln990">    xfree(p);</a>
<a name="ln991">    xfree(*pp);</a>
<a name="ln992">    *pp = lp;</a>
<a name="ln993">  } else {</a>
<a name="ln994">    free_register(reg);</a>
<a name="ln995">    set_yreg_additional_data(reg, NULL);</a>
<a name="ln996">    reg-&gt;y_array = xmalloc(sizeof(char *));</a>
<a name="ln997">    reg-&gt;y_array[0] = p;</a>
<a name="ln998">    reg-&gt;y_size = 1;</a>
<a name="ln999">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln1000">  }</a>
<a name="ln1001">  reg-&gt;timestamp = os_time();</a>
<a name="ln1002">  return OK;</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">static int execreg_lastc = NUL;</a>
<a name="ln1006"> </a>
<a name="ln1007">/// When executing a register as a series of ex-commands, if the</a>
<a name="ln1008">/// line-continuation character is used for a line, then join it with one or</a>
<a name="ln1009">/// more previous lines. Note that lines are processed backwards starting from</a>
<a name="ln1010">/// the last line in the register.</a>
<a name="ln1011">///</a>
<a name="ln1012">/// @param lines list of lines in the register</a>
<a name="ln1013">/// @param idx   index of the line starting with \ or &quot;\. Join this line with all the immediate</a>
<a name="ln1014">///              predecessor lines that start with a \ and the first line that doesn't start</a>
<a name="ln1015">///              with a \. Lines that start with a comment &quot;\ character are ignored.</a>
<a name="ln1016">/// @returns the concatenated line. The index of the line that should be</a>
<a name="ln1017">///          processed next is returned in idx.</a>
<a name="ln1018">static char *execreg_line_continuation(char **lines, size_t *idx)</a>
<a name="ln1019">{</a>
<a name="ln1020">  size_t i = *idx;</a>
<a name="ln1021">  assert(i &gt; 0);</a>
<a name="ln1022">  const size_t cmd_end = i;</a>
<a name="ln1023"> </a>
<a name="ln1024">  garray_T ga;</a>
<a name="ln1025">  ga_init(&amp;ga, (int)sizeof(char), 400);</a>
<a name="ln1026"> </a>
<a name="ln1027">  char *p;</a>
<a name="ln1028"> </a>
<a name="ln1029">  // search backwards to find the first line of this command.</a>
<a name="ln1030">  // Any line not starting with \ or &quot;\ is the start of the</a>
<a name="ln1031">  // command.</a>
<a name="ln1032">  while (--i &gt; 0) {</a>
<a name="ln1033">    p = skipwhite(lines[i]);</a>
<a name="ln1034">    if (*p != '\\' &amp;&amp; (p[0] != '&quot;' || p[1] != '\\' || p[2] != ' ')) {</a>
<a name="ln1035">      break;</a>
<a name="ln1036">    }</a>
<a name="ln1037">  }</a>
<a name="ln1038">  const size_t cmd_start = i;</a>
<a name="ln1039"> </a>
<a name="ln1040">  // join all the lines</a>
<a name="ln1041">  ga_concat(&amp;ga, lines[cmd_start]);</a>
<a name="ln1042">  for (size_t j = cmd_start + 1; j &lt;= cmd_end; j++) {</a>
<a name="ln1043">    p = skipwhite(lines[j]);</a>
<a name="ln1044">    if (*p == '\\') {</a>
<a name="ln1045">      // Adjust the growsize to the current length to</a>
<a name="ln1046">      // speed up concatenating many lines.</a>
<a name="ln1047">      if (ga.ga_len &gt; 400) {</a>
<a name="ln1048">        ga_set_growsize(&amp;ga, MIN(ga.ga_len, 8000));</a>
<a name="ln1049">      }</a>
<a name="ln1050">      ga_concat(&amp;ga, p + 1);</a>
<a name="ln1051">    }</a>
<a name="ln1052">  }</a>
<a name="ln1053">  ga_append(&amp;ga, NUL);</a>
<a name="ln1054">  char *str = xstrdup(ga.ga_data);</a>
<a name="ln1055">  ga_clear(&amp;ga);</a>
<a name="ln1056"> </a>
<a name="ln1057">  *idx = i;</a>
<a name="ln1058">  return str;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/// Execute a yank register: copy it into the stuff buffer</a>
<a name="ln1062">///</a>
<a name="ln1063">/// @param colon   insert ':' before each line</a>
<a name="ln1064">/// @param addcr   always add '\n' to end of line</a>
<a name="ln1065">/// @param silent  set &quot;silent&quot; flag in typeahead buffer</a>
<a name="ln1066">///</a>
<a name="ln1067">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1068">int do_execreg(int regname, int colon, int addcr, int silent)</a>
<a name="ln1069">{</a>
<a name="ln1070">  char *p;</a>
<a name="ln1071">  int retval = OK;</a>
<a name="ln1072"> </a>
<a name="ln1073">  if (regname == '@') {                 // repeat previous one</a>
<a name="ln1074">    if (execreg_lastc == NUL) {</a>
<a name="ln1075">      emsg(_(&quot;E748: No previously used register&quot;));</a>
<a name="ln1076">      return FAIL;</a>
<a name="ln1077">    }</a>
<a name="ln1078">    regname = execreg_lastc;</a>
<a name="ln1079">  }</a>
<a name="ln1080">  // check for valid regname</a>
<a name="ln1081">  if (regname == '%' || regname == '#' || !valid_yank_reg(regname, false)) {</a>
<a name="ln1082">    emsg_invreg(regname);</a>
<a name="ln1083">    return FAIL;</a>
<a name="ln1084">  }</a>
<a name="ln1085">  execreg_lastc = regname;</a>
<a name="ln1086"> </a>
<a name="ln1087">  if (regname == '_') {                 // black hole: don't stuff anything</a>
<a name="ln1088">    return OK;</a>
<a name="ln1089">  }</a>
<a name="ln1090"> </a>
<a name="ln1091">  if (regname == ':') {                 // use last command line</a>
<a name="ln1092">    if (last_cmdline == NULL) {</a>
<a name="ln1093">      emsg(_(e_nolastcmd));</a>
<a name="ln1094">      return FAIL;</a>
<a name="ln1095">    }</a>
<a name="ln1096">    // don't keep the cmdline containing @:</a>
<a name="ln1097">    XFREE_CLEAR(new_last_cmdline);</a>
<a name="ln1098">    // Escape all control characters with a CTRL-V</a>
<a name="ln1099">    p = vim_strsave_escaped_ext(last_cmdline,</a>
<a name="ln1100">                                &quot;\001\002\003\004\005\006\007&quot;</a>
<a name="ln1101">                                &quot;\010\011\012\013\014\015\016\017&quot;</a>
<a name="ln1102">                                &quot;\020\021\022\023\024\025\026\027&quot;</a>
<a name="ln1103">                                &quot;\030\031\032\033\034\035\036\037&quot;,</a>
<a name="ln1104">                                Ctrl_V, false);</a>
<a name="ln1105">    // When in Visual mode &quot;'&lt;,'&gt;&quot; will be prepended to the command.</a>
<a name="ln1106">    // Remove it when it's already there.</a>
<a name="ln1107">    if (VIsual_active &amp;&amp; strncmp(p, &quot;'&lt;,'&gt;&quot;, 5) == 0) {</a>
<a name="ln1108">      retval = put_in_typebuf(p + 5, true, true, silent);</a>
<a name="ln1109">    } else {</a>
<a name="ln1110">      retval = put_in_typebuf(p, true, true, silent);</a>
<a name="ln1111">    }</a>
<a name="ln1112">    xfree(p);</a>
<a name="ln1113">  } else if (regname == '=') {</a>
<a name="ln1114">    p = get_expr_line();</a>
<a name="ln1115">    if (p == NULL) {</a>
<a name="ln1116">      return FAIL;</a>
<a name="ln1117">    }</a>
<a name="ln1118">    retval = put_in_typebuf(p, true, colon, silent);</a>
<a name="ln1119">    xfree(p);</a>
<a name="ln1120">  } else if (regname == '.') {        // use last inserted text</a>
<a name="ln1121">    p = get_last_insert_save();</a>
<a name="ln1122">    if (p == NULL) {</a>
<a name="ln1123">      emsg(_(e_noinstext));</a>
<a name="ln1124">      return FAIL;</a>
<a name="ln1125">    }</a>
<a name="ln1126">    retval = put_in_typebuf(p, false, colon, silent);</a>
<a name="ln1127">    xfree(p);</a>
<a name="ln1128">  } else {</a>
<a name="ln1129">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1130">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1131">      return FAIL;</a>
<a name="ln1132">    }</a>
<a name="ln1133"> </a>
<a name="ln1134">    // Disallow remapping for &quot;:@r&quot;.</a>
<a name="ln1135">    int remap = colon ? REMAP_NONE : REMAP_YES;</a>
<a name="ln1136"> </a>
<a name="ln1137">    // Insert lines into typeahead buffer, from last one to first one.</a>
<a name="ln1138">    put_reedit_in_typebuf(silent);</a>
<a name="ln1139">    for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln1140">      // insert NL between lines and after last line if type is kMTLineWise</a>
<a name="ln1141">      if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1 || addcr) {</a>
<a name="ln1142">        if (ins_typebuf(&quot;\n&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1143">          return FAIL;</a>
<a name="ln1144">        }</a>
<a name="ln1145">      }</a>
<a name="ln1146"> </a>
<a name="ln1147">      // Handle line-continuation for :@&lt;register&gt;</a>
<a name="ln1148">      char *str = reg-&gt;y_array[i];</a>
<a name="ln1149">      bool free_str = false;</a>
<a name="ln1150">      if (colon &amp;&amp; i &gt; 0) {</a>
<a name="ln1151">        p = skipwhite(str);</a>
<a name="ln1152">        if (*p == '\\' || (p[0] == '&quot;' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == ' ')) {</a>
<a name="ln1153">          str = execreg_line_continuation(reg-&gt;y_array, &amp;i);</a>
<a name="ln1154">          free_str = true;</a>
<a name="ln1155">        }</a>
<a name="ln1156">      }</a>
<a name="ln1157">      char *escaped = vim_strsave_escape_ks(str);</a>
<a name="ln1158">      if (free_str) {</a>
<a name="ln1159">        xfree(str);</a>
<a name="ln1160">      }</a>
<a name="ln1161">      retval = ins_typebuf(escaped, remap, 0, true, silent);</a>
<a name="ln1162">      xfree(escaped);</a>
<a name="ln1163">      if (retval == FAIL) {</a>
<a name="ln1164">        return FAIL;</a>
<a name="ln1165">      }</a>
<a name="ln1166">      if (colon</a>
<a name="ln1167">          &amp;&amp; ins_typebuf(&quot;:&quot;, remap, 0, true, silent) == FAIL) {</a>
<a name="ln1168">        return FAIL;</a>
<a name="ln1169">      }</a>
<a name="ln1170">    }</a>
<a name="ln1171">    reg_executing = regname == 0 ? '&quot;' : regname;  // disable the 'q' command</a>
<a name="ln1172">  }</a>
<a name="ln1173">  return retval;</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">/// If &quot;restart_edit&quot; is not zero, put it in the typeahead buffer, so that it's</a>
<a name="ln1177">/// used only after other typeahead has been processed.</a>
<a name="ln1178">static void put_reedit_in_typebuf(int silent)</a>
<a name="ln1179">{</a>
<a name="ln1180">  uint8_t buf[3];</a>
<a name="ln1181"> </a>
<a name="ln1182">  if (restart_edit == NUL) {</a>
<a name="ln1183">    return;</a>
<a name="ln1184">  }</a>
<a name="ln1185"> </a>
<a name="ln1186">  if (restart_edit == 'V') {</a>
<a name="ln1187">    buf[0] = 'g';</a>
<a name="ln1188">    buf[1] = 'R';</a>
<a name="ln1189">    buf[2] = NUL;</a>
<a name="ln1190">  } else {</a>
<a name="ln1191">    buf[0] = (uint8_t)(restart_edit == 'I' ? 'i' : restart_edit);</a>
<a name="ln1192">    buf[1] = NUL;</a>
<a name="ln1193">  }</a>
<a name="ln1194">  if (ins_typebuf((char *)buf, REMAP_NONE, 0, true, silent) == OK) {</a>
<a name="ln1195">    restart_edit = NUL;</a>
<a name="ln1196">  }</a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">/// Insert register contents &quot;s&quot; into the typeahead buffer, so that it will be</a>
<a name="ln1200">/// executed again.</a>
<a name="ln1201">///</a>
<a name="ln1202">/// @param esc    when true then it is to be taken literally: Escape K_SPECIAL</a>
<a name="ln1203">///               characters and no remapping.</a>
<a name="ln1204">/// @param colon  add ':' before the line</a>
<a name="ln1205">static int put_in_typebuf(char *s, bool esc, bool colon, int silent)</a>
<a name="ln1206">{</a>
<a name="ln1207">  int retval = OK;</a>
<a name="ln1208"> </a>
<a name="ln1209">  put_reedit_in_typebuf(silent);</a>
<a name="ln1210">  if (colon) {</a>
<a name="ln1211">    retval = ins_typebuf(&quot;\n&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1212">  }</a>
<a name="ln1213">  if (retval == OK) {</a>
<a name="ln1214">    char *p;</a>
<a name="ln1215"> </a>
<a name="ln1216">    if (esc) {</a>
<a name="ln1217">      p = vim_strsave_escape_ks(s);</a>
<a name="ln1218">    } else {</a>
<a name="ln1219">      p = s;</a>
<a name="ln1220">    }</a>
<a name="ln1221">    if (p == NULL) {</a>
<a name="ln1222">      retval = FAIL;</a>
<a name="ln1223">    } else {</a>
<a name="ln1224">      retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES, 0, true, silent);</a>
<a name="ln1225">    }</a>
<a name="ln1226">    if (esc) {</a>
<a name="ln1227">      xfree(p);</a>
<a name="ln1228">    }</a>
<a name="ln1229">  }</a>
<a name="ln1230">  if (colon &amp;&amp; retval == OK) {</a>
<a name="ln1231">    retval = ins_typebuf(&quot;:&quot;, REMAP_NONE, 0, true, silent);</a>
<a name="ln1232">  }</a>
<a name="ln1233">  return retval;</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/// Insert a yank register: copy it into the Read buffer.</a>
<a name="ln1237">/// Used by CTRL-R command and middle mouse button in insert mode.</a>
<a name="ln1238">///</a>
<a name="ln1239">/// @param literally_arg  insert literally, not as if typed</a>
<a name="ln1240">///</a>
<a name="ln1241">/// @return FAIL for failure, OK otherwise</a>
<a name="ln1242">int insert_reg(int regname, bool literally_arg)</a>
<a name="ln1243">{</a>
<a name="ln1244">  int retval = OK;</a>
<a name="ln1245">  bool allocated;</a>
<a name="ln1246">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1247"> </a>
<a name="ln1248">  // It is possible to get into an endless loop by having CTRL-R a in</a>
<a name="ln1249">  // register a and then, in insert mode, doing CTRL-R a.</a>
<a name="ln1250">  // If you hit CTRL-C, the loop will be broken here.</a>
<a name="ln1251">  os_breakcheck();</a>
<a name="ln1252">  if (got_int) {</a>
<a name="ln1253">    return FAIL;</a>
<a name="ln1254">  }</a>
<a name="ln1255"> </a>
<a name="ln1256">  // check for valid regname</a>
<a name="ln1257">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln1258">    return FAIL;</a>
<a name="ln1259">  }</a>
<a name="ln1260"> </a>
<a name="ln1261">  char *arg;</a>
<a name="ln1262">  if (regname == '.') {  // Insert last inserted text.</a>
<a name="ln1263">    retval = stuff_inserted(NUL, 1L, true);</a>
<a name="ln1264">  } else if (get_spec_reg(regname, &amp;arg, &amp;allocated, true)) {</a>
<a name="ln1265">    if (arg == NULL) {</a>
<a name="ln1266">      return FAIL;</a>
<a name="ln1267">    }</a>
<a name="ln1268">    stuffescaped(arg, literally);</a>
<a name="ln1269">    if (allocated) {</a>
<a name="ln1270">      xfree(arg);</a>
<a name="ln1271">    }</a>
<a name="ln1272">  } else {  // Name or number register.</a>
<a name="ln1273">    yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1274">    if (reg-&gt;y_array == NULL) {</a>
<a name="ln1275">      retval = FAIL;</a>
<a name="ln1276">    } else {</a>
<a name="ln1277">      for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1278">        if (regname == '-') {</a>
<a name="ln1279">          AppendCharToRedobuff(Ctrl_R);</a>
<a name="ln1280">          AppendCharToRedobuff(regname);</a>
<a name="ln1281">          do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);</a>
<a name="ln1282">        } else {</a>
<a name="ln1283">          stuffescaped(reg-&gt;y_array[i], literally);</a>
<a name="ln1284">        }</a>
<a name="ln1285">        // Insert a newline between lines and after last line if</a>
<a name="ln1286">        // y_type is kMTLineWise.</a>
<a name="ln1287">        if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln1288">          stuffcharReadbuff('\n');</a>
<a name="ln1289">        }</a>
<a name="ln1290">      }</a>
<a name="ln1291">    }</a>
<a name="ln1292">  }</a>
<a name="ln1293"> </a>
<a name="ln1294">  return retval;</a>
<a name="ln1295">}</a>
<a name="ln1296"> </a>
<a name="ln1297">/// If &quot;regname&quot; is a special register, return true and store a pointer to its</a>
<a name="ln1298">/// value in &quot;argp&quot;.</a>
<a name="ln1299">///</a>
<a name="ln1300">/// @param allocated  return: true when value was allocated</a>
<a name="ln1301">/// @param errmsg     give error message when failing</a>
<a name="ln1302">///</a>
<a name="ln1303">/// @return  true if &quot;regname&quot; is a special register,</a>
<a name="ln1304">bool get_spec_reg(int regname, char **argp, bool *allocated, bool errmsg)</a>
<a name="ln1305">{</a>
<a name="ln1306">  size_t cnt;</a>
<a name="ln1307"> </a>
<a name="ln1308">  *argp = NULL;</a>
<a name="ln1309">  *allocated = false;</a>
<a name="ln1310">  switch (regname) {</a>
<a name="ln1311">  case '%':                     // file name</a>
<a name="ln1312">    if (errmsg) {</a>
<a name="ln1313">      check_fname();            // will give emsg if not set</a>
<a name="ln1314">    }</a>
<a name="ln1315">    *argp = curbuf-&gt;b_fname;</a>
<a name="ln1316">    return true;</a>
<a name="ln1317"> </a>
<a name="ln1318">  case '#':                       // alternate file name</a>
<a name="ln1319">    *argp = getaltfname(errmsg);  // may give emsg if not set</a>
<a name="ln1320">    return true;</a>
<a name="ln1321"> </a>
<a name="ln1322">  case '=':                     // result of expression</a>
<a name="ln1323">    *argp = get_expr_line();</a>
<a name="ln1324">    *allocated = true;</a>
<a name="ln1325">    return true;</a>
<a name="ln1326"> </a>
<a name="ln1327">  case ':':                     // last command line</a>
<a name="ln1328">    if (last_cmdline == NULL &amp;&amp; errmsg) {</a>
<a name="ln1329">      emsg(_(e_nolastcmd));</a>
<a name="ln1330">    }</a>
<a name="ln1331">    *argp = last_cmdline;</a>
<a name="ln1332">    return true;</a>
<a name="ln1333"> </a>
<a name="ln1334">  case '/':                     // last search-pattern</a>
<a name="ln1335">    if (last_search_pat() == NULL &amp;&amp; errmsg) {</a>
<a name="ln1336">      emsg(_(e_noprevre));</a>
<a name="ln1337">    }</a>
<a name="ln1338">    *argp = last_search_pat();</a>
<a name="ln1339">    return true;</a>
<a name="ln1340"> </a>
<a name="ln1341">  case '.':                     // last inserted text</a>
<a name="ln1342">    *argp = get_last_insert_save();</a>
<a name="ln1343">    *allocated = true;</a>
<a name="ln1344">    if (*argp == NULL &amp;&amp; errmsg) {</a>
<a name="ln1345">      emsg(_(e_noinstext));</a>
<a name="ln1346">    }</a>
<a name="ln1347">    return true;</a>
<a name="ln1348"> </a>
<a name="ln1349">  case Ctrl_F:                  // Filename under cursor</a>
<a name="ln1350">  case Ctrl_P:                  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln1351">    if (!errmsg) {</a>
<a name="ln1352">      return false;</a>
<a name="ln1353">    }</a>
<a name="ln1354">    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP | (regname == Ctrl_P ? FNAME_EXP : 0),</a>
<a name="ln1355">                                1L, NULL);</a>
<a name="ln1356">    *allocated = true;</a>
<a name="ln1357">    return true;</a>
<a name="ln1358"> </a>
<a name="ln1359">  case Ctrl_W:                  // word under cursor</a>
<a name="ln1360">  case Ctrl_A:                  // WORD (mnemonic All) under cursor</a>
<a name="ln1361">    if (!errmsg) {</a>
<a name="ln1362">      return false;</a>
<a name="ln1363">    }</a>
<a name="ln1364">    cnt = find_ident_under_cursor(argp, (regname == Ctrl_W</a>
<a name="ln1365">                                         ? (FIND_IDENT|FIND_STRING)</a>
<a name="ln1366">                                         : FIND_STRING));</a>
<a name="ln1367">    *argp = cnt ? xstrnsave(*argp, cnt) : NULL;</a>
<a name="ln1368">    *allocated = true;</a>
<a name="ln1369">    return true;</a>
<a name="ln1370"> </a>
<a name="ln1371">  case Ctrl_L:                  // Line under cursor</a>
<a name="ln1372">    if (!errmsg) {</a>
<a name="ln1373">      return false;</a>
<a name="ln1374">    }</a>
<a name="ln1375"> </a>
<a name="ln1376">    *argp = ml_get_buf(curwin-&gt;w_buffer, curwin-&gt;w_cursor.lnum, false);</a>
<a name="ln1377">    return true;</a>
<a name="ln1378"> </a>
<a name="ln1379">  case '_':                     // black hole: always empty</a>
<a name="ln1380">    *argp = &quot;&quot;;</a>
<a name="ln1381">    return true;</a>
<a name="ln1382">  }</a>
<a name="ln1383"> </a>
<a name="ln1384">  return false;</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">/// Paste a yank register into the command line.</a>
<a name="ln1388">/// Only for non-special registers.</a>
<a name="ln1389">/// Used by CTRL-R in command-line mode.</a>
<a name="ln1390">/// insert_reg() can't be used here, because special characters from the</a>
<a name="ln1391">/// register contents will be interpreted as commands.</a>
<a name="ln1392">///</a>
<a name="ln1393">/// @param regname   Register name.</a>
<a name="ln1394">/// @param literally_arg Insert text literally instead of &quot;as typed&quot;.</a>
<a name="ln1395">/// @param remcr     When true, don't add CR characters.</a>
<a name="ln1396">///</a>
<a name="ln1397">/// @returns FAIL for failure, OK otherwise</a>
<a name="ln1398">bool cmdline_paste_reg(int regname, bool literally_arg, bool remcr)</a>
<a name="ln1399">{</a>
<a name="ln1400">  const bool literally = literally_arg || is_literal_register(regname);</a>
<a name="ln1401"> </a>
<a name="ln1402">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln1403">  if (reg-&gt;y_array == NULL) {</a>
<a name="ln1404">    return FAIL;</a>
<a name="ln1405">  }</a>
<a name="ln1406"> </a>
<a name="ln1407">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln1408">    cmdline_paste_str(reg-&gt;y_array[i], literally);</a>
<a name="ln1409"> </a>
<a name="ln1410">    // Insert ^M between lines, unless `remcr` is true.</a>
<a name="ln1411">    if (i &lt; reg-&gt;y_size - 1 &amp;&amp; !remcr) {</a>
<a name="ln1412">      cmdline_paste_str(&quot;\r&quot;, literally);</a>
<a name="ln1413">    }</a>
<a name="ln1414"> </a>
<a name="ln1415">    // Check for CTRL-C, in case someone tries to paste a few thousand</a>
<a name="ln1416">    // lines and gets bored.</a>
<a name="ln1417">    os_breakcheck();</a>
<a name="ln1418">    if (got_int) {</a>
<a name="ln1419">      return FAIL;</a>
<a name="ln1420">    }</a>
<a name="ln1421">  }</a>
<a name="ln1422">  return OK;</a>
<a name="ln1423">}</a>
<a name="ln1424"> </a>
<a name="ln1425">/// Shift the delete registers: &quot;9 is cleared, &quot;8 becomes &quot;9, etc.</a>
<a name="ln1426">static void shift_delete_registers(bool y_append)</a>
<a name="ln1427">{</a>
<a name="ln1428">  free_register(&amp;y_regs[9]);  // free register &quot;9</a>
<a name="ln1429">  for (int n = 9; n &gt; 1; n--) {</a>
<a name="ln1430">    y_regs[n] = y_regs[n - 1];</a>
<a name="ln1431">  }</a>
<a name="ln1432">  if (!y_append) {</a>
<a name="ln1433">    y_previous = &amp;y_regs[1];</a>
<a name="ln1434">  }</a>
<a name="ln1435">  y_regs[1].y_array = NULL;  // set register &quot;1 to empty</a>
<a name="ln1436">}</a>
<a name="ln1437"> </a>
<a name="ln1438">/// Handle a delete operation.</a>
<a name="ln1439">///</a>
<a name="ln1440">/// @return  FAIL if undo failed, OK otherwise.</a>
<a name="ln1441">int op_delete(oparg_T *oap)</a>
<a name="ln1442">{</a>
<a name="ln1443">  int n;</a>
<a name="ln1444">  linenr_T lnum;</a>
<a name="ln1445">  char *ptr;</a>
<a name="ln1446">  char *newp, *oldp;</a>
<a name="ln1447">  struct block_def bd = { 0 };</a>
<a name="ln1448">  linenr_T old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1449"> </a>
<a name="ln1450">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {  // nothing to do</a>
<a name="ln1451">    return OK;</a>
<a name="ln1452">  }</a>
<a name="ln1453"> </a>
<a name="ln1454">  // Nothing to delete, return here. Do prepare undo, for op_change().</a>
<a name="ln1455">  if (oap-&gt;empty) {</a>
<a name="ln1456">    return u_save_cursor();</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  if (!MODIFIABLE(curbuf)) {</a>
<a name="ln1460">    emsg(_(e_modifiable));</a>
<a name="ln1461">    return FAIL;</a>
<a name="ln1462">  }</a>
<a name="ln1463"> </a>
<a name="ln1464">  if (VIsual_select &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln1465">    // Use the register given with CTRL_R, defaults to zero</a>
<a name="ln1466">    oap-&gt;regname = VIsual_select_reg;</a>
<a name="ln1467">  }</a>
<a name="ln1468"> </a>
<a name="ln1469">  mb_adjust_opend(oap);</a>
<a name="ln1470"> </a>
<a name="ln1471">  // Imitate the strange Vi behaviour: If the delete spans more than one</a>
<a name="ln1472">  // line and motion_type == kMTCharWise and the result is a blank line, make the</a>
<a name="ln1473">  // delete linewise.  Don't do this for the change command or Visual mode.</a>
<a name="ln1474">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln1475">      &amp;&amp; !oap-&gt;is_VIsual</a>
<a name="ln1476">      &amp;&amp; oap-&gt;line_count &gt; 1</a>
<a name="ln1477">      &amp;&amp; oap-&gt;motion_force == NUL</a>
<a name="ln1478">      &amp;&amp; oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1479">    ptr = ml_get(oap-&gt;end.lnum) + oap-&gt;end.col;</a>
<a name="ln1480">    if (*ptr != NUL) {</a>
<a name="ln1481">      ptr += oap-&gt;inclusive;</a>
<a name="ln1482">    }</a>
<a name="ln1483">    ptr = skipwhite(ptr);</a>
<a name="ln1484">    if (*ptr == NUL &amp;&amp; inindent(0)) {</a>
<a name="ln1485">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln1486">    }</a>
<a name="ln1487">  }</a>
<a name="ln1488"> </a>
<a name="ln1489">  // Check for trying to delete (e.g. &quot;D&quot;) in an empty line.</a>
<a name="ln1490">  // Note: For the change operator it is ok.</a>
<a name="ln1491">  if (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1492">      &amp;&amp; oap-&gt;line_count == 1</a>
<a name="ln1493">      &amp;&amp; oap-&gt;op_type == OP_DELETE</a>
<a name="ln1494">      &amp;&amp; *ml_get(oap-&gt;start.lnum) == NUL) {</a>
<a name="ln1495">    // It's an error to operate on an empty region, when 'E' included in</a>
<a name="ln1496">    // 'cpoptions' (Vi compatible).</a>
<a name="ln1497">    if (virtual_op) {</a>
<a name="ln1498">      // Virtual editing: Nothing gets deleted, but we set the '[ and ']</a>
<a name="ln1499">      // marks as if it happened.</a>
<a name="ln1500">      goto setmarks;</a>
<a name="ln1501">    }</a>
<a name="ln1502">    if (vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL) {</a>
<a name="ln1503">      beep_flush();</a>
<a name="ln1504">    }</a>
<a name="ln1505">    return OK;</a>
<a name="ln1506">  }</a>
<a name="ln1507"> </a>
<a name="ln1508">  // Do a yank of whatever we're about to delete.</a>
<a name="ln1509">  // If a yank register was specified, put the deleted text into that</a>
<a name="ln1510">  // register.  For the black hole register '_' don't yank anything.</a>
<a name="ln1511">  if (oap-&gt;regname != '_') {</a>
<a name="ln1512">    yankreg_T *reg = NULL;</a>
<a name="ln1513">    int did_yank = false;</a>
<a name="ln1514">    if (oap-&gt;regname != 0) {</a>
<a name="ln1515">      // check for read-only register</a>
<a name="ln1516">      if (!valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln1517">        beep_flush();</a>
<a name="ln1518">        return OK;</a>
<a name="ln1519">      }</a>
<a name="ln1520">      reg = get_yank_register(oap-&gt;regname, YREG_YANK);  // yank into specif'd reg</a>
<a name="ln1521">      op_yank_reg(oap, false, reg, is_append_register(oap-&gt;regname));  // yank without message</a>
<a name="ln1522">      did_yank = true;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    // Put deleted text into register 1 and shift number registers if the</a>
<a name="ln1526">    // delete contains a line break, or when using a specific operator (Vi</a>
<a name="ln1527">    // compatible)</a>
<a name="ln1528"> </a>
<a name="ln1529">    if (oap-&gt;motion_type == kMTLineWise || oap-&gt;line_count &gt; 1 || oap-&gt;use_reg_one) {</a>
<a name="ln1530">      shift_delete_registers(is_append_register(oap-&gt;regname));</a>
<a name="ln1531">      reg = &amp;y_regs[1];</a>
<a name="ln1532">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1533">      did_yank = true;</a>
<a name="ln1534">    }</a>
<a name="ln1535"> </a>
<a name="ln1536">    // Yank into small delete register when no named register specified</a>
<a name="ln1537">    // and the delete is within one line.</a>
<a name="ln1538">    if (oap-&gt;regname == 0 &amp;&amp; oap-&gt;motion_type != kMTLineWise</a>
<a name="ln1539">        &amp;&amp; oap-&gt;line_count == 1) {</a>
<a name="ln1540">      reg = get_yank_register('-', YREG_YANK);</a>
<a name="ln1541">      op_yank_reg(oap, false, reg, false);</a>
<a name="ln1542">      did_yank = true;</a>
<a name="ln1543">    }</a>
<a name="ln1544"> </a>
<a name="ln1545">    if (did_yank || oap-&gt;regname == 0) {</a>
<a name="ln1546">      if (reg == NULL) {</a>
<a name="ln1547">        abort();</a>
<a name="ln1548">      }</a>
<a name="ln1549">      set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln1550">      do_autocmd_textyankpost(oap, reg);</a>
<a name="ln1551">    }</a>
<a name="ln1552">  }</a>
<a name="ln1553"> </a>
<a name="ln1554">  // block mode delete</a>
<a name="ln1555">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1556">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1557">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1558">      return FAIL;</a>
<a name="ln1559">    }</a>
<a name="ln1560"> </a>
<a name="ln1561">    for (lnum = curwin-&gt;w_cursor.lnum; lnum &lt;= oap-&gt;end.lnum; lnum++) {</a>
<a name="ln1562">      block_prep(oap, &amp;bd, lnum, true);</a>
<a name="ln1563">      if (bd.textlen == 0) {            // nothing to delete</a>
<a name="ln1564">        continue;</a>
<a name="ln1565">      }</a>
<a name="ln1566"> </a>
<a name="ln1567">      // Adjust cursor position for tab replaced by spaces and 'lbr'.</a>
<a name="ln1568">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln1569">        curwin-&gt;w_cursor.col = bd.textcol + bd.startspaces;</a>
<a name="ln1570">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1571">      }</a>
<a name="ln1572"> </a>
<a name="ln1573">      // n == number of chars deleted</a>
<a name="ln1574">      // If we delete a TAB, it may be replaced by several characters.</a>
<a name="ln1575">      // Thus the number of characters may increase!</a>
<a name="ln1576">      n = bd.textlen - bd.startspaces - bd.endspaces;</a>
<a name="ln1577">      oldp = ml_get(lnum);</a>
<a name="ln1578">      newp = xmalloc(strlen(oldp) - (size_t)n + 1);</a>
<a name="ln1579">      // copy up to deleted part</a>
<a name="ln1580">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1581">      // insert spaces</a>
<a name="ln1582">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces +</a>
<a name="ln1583">             (size_t)bd.endspaces);</a>
<a name="ln1584">      // copy the part after the deleted part</a>
<a name="ln1585">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1586">      STRMOVE(newp + bd.textcol + bd.startspaces + bd.endspaces, oldp);</a>
<a name="ln1587">      // replace the line</a>
<a name="ln1588">      ml_replace(lnum, newp, false);</a>
<a name="ln1589"> </a>
<a name="ln1590">      extmark_splice_cols(curbuf, (int)lnum - 1, bd.textcol,</a>
<a name="ln1591">                          bd.textlen, bd.startspaces + bd.endspaces,</a>
<a name="ln1592">                          kExtmarkUndo);</a>
<a name="ln1593">    }</a>
<a name="ln1594"> </a>
<a name="ln1595">    check_cursor_col();</a>
<a name="ln1596">    changed_lines(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln1597">                  oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln1598">    oap-&gt;line_count = 0;  // no lines deleted</a>
<a name="ln1599">  } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1600">    if (oap-&gt;op_type == OP_CHANGE) {</a>
<a name="ln1601">      // Delete the lines except the first one.  Temporarily move the</a>
<a name="ln1602">      // cursor to the next line.  Save the current line number, if the</a>
<a name="ln1603">      // last line is deleted it may be changed.</a>
<a name="ln1604"> </a>
<a name="ln1605">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1606">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1607">        curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1608">        del_lines(oap-&gt;line_count - 1, true);</a>
<a name="ln1609">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1610">      }</a>
<a name="ln1611">      if (u_save_cursor() == FAIL) {</a>
<a name="ln1612">        return FAIL;</a>
<a name="ln1613">      }</a>
<a name="ln1614">      if (curbuf-&gt;b_p_ai) {                 // don't delete indent</a>
<a name="ln1615">        beginline(BL_WHITE);                // cursor on first non-white</a>
<a name="ln1616">        did_ai = true;                      // delete the indent when ESC hit</a>
<a name="ln1617">        ai_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1618">      } else {</a>
<a name="ln1619">        beginline(0);                       // cursor in column 0</a>
<a name="ln1620">      }</a>
<a name="ln1621"> </a>
<a name="ln1622">      int old_len = (int)strlen(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln1623">      truncate_line(false);         // delete the rest of the line</a>
<a name="ln1624"> </a>
<a name="ln1625">      extmark_splice_cols(curbuf,</a>
<a name="ln1626">                          (int)curwin-&gt;w_cursor.lnum - 1, curwin-&gt;w_cursor.col,</a>
<a name="ln1627">                          old_len - curwin-&gt;w_cursor.col, 0, kExtmarkUndo);</a>
<a name="ln1628"> </a>
<a name="ln1629">      // leave cursor past last char in line</a>
<a name="ln1630">      if (oap-&gt;line_count &gt; 1) {</a>
<a name="ln1631">        u_clearline();              // &quot;U&quot; command not possible after &quot;2cc&quot;</a>
<a name="ln1632">      }</a>
<a name="ln1633">    } else {</a>
<a name="ln1634">      del_lines(oap-&gt;line_count, true);</a>
<a name="ln1635">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln1636">      u_clearline();            // &quot;U&quot; command not possible after &quot;dd&quot;</a>
<a name="ln1637">    }</a>
<a name="ln1638">  } else {</a>
<a name="ln1639">    if (virtual_op) {</a>
<a name="ln1640">      // For virtualedit: break the tabs that are partly included.</a>
<a name="ln1641">      if (gchar_pos(&amp;oap-&gt;start) == '\t') {</a>
<a name="ln1642">        int endcol = 0;</a>
<a name="ln1643">        if (u_save_cursor() == FAIL) {          // save first line for undo</a>
<a name="ln1644">          return FAIL;</a>
<a name="ln1645">        }</a>
<a name="ln1646">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1647">          endcol = getviscol2(oap-&gt;end.col, oap-&gt;end.coladd);</a>
<a name="ln1648">        }</a>
<a name="ln1649">        coladvance_force(getviscol2(oap-&gt;start.col, oap-&gt;start.coladd));</a>
<a name="ln1650">        oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln1651">        if (oap-&gt;line_count == 1) {</a>
<a name="ln1652">          coladvance(endcol);</a>
<a name="ln1653">          oap-&gt;end.col = curwin-&gt;w_cursor.col;</a>
<a name="ln1654">          oap-&gt;end.coladd = curwin-&gt;w_cursor.coladd;</a>
<a name="ln1655">          curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1656">        }</a>
<a name="ln1657">      }</a>
<a name="ln1658"> </a>
<a name="ln1659">      // Break a tab only when it's included in the area.</a>
<a name="ln1660">      if (gchar_pos(&amp;oap-&gt;end) == '\t'</a>
<a name="ln1661">          &amp;&amp; oap-&gt;end.coladd == 0</a>
<a name="ln1662">          &amp;&amp; oap-&gt;inclusive) {</a>
<a name="ln1663">        // save last line for undo</a>
<a name="ln1664">        if (u_save((linenr_T)(oap-&gt;end.lnum - 1),</a>
<a name="ln1665">                   (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1666">          return FAIL;</a>
<a name="ln1667">        }</a>
<a name="ln1668">        curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln1669">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd));</a>
<a name="ln1670">        oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln1671">        curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln1672">      }</a>
<a name="ln1673">      mb_adjust_opend(oap);</a>
<a name="ln1674">    }</a>
<a name="ln1675"> </a>
<a name="ln1676">    if (oap-&gt;line_count == 1) {         // delete characters within one line</a>
<a name="ln1677">      if (u_save_cursor() == FAIL) {            // save line for undo</a>
<a name="ln1678">        return FAIL;</a>
<a name="ln1679">      }</a>
<a name="ln1680"> </a>
<a name="ln1681">      // if 'cpoptions' contains '$', display '$' at end of change</a>
<a name="ln1682">      if (vim_strchr(p_cpo, CPO_DOLLAR) != NULL</a>
<a name="ln1683">          &amp;&amp; oap-&gt;op_type == OP_CHANGE</a>
<a name="ln1684">          &amp;&amp; oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln1685">          &amp;&amp; !oap-&gt;is_VIsual) {</a>
<a name="ln1686">        display_dollar(oap-&gt;end.col - !oap-&gt;inclusive);</a>
<a name="ln1687">      }</a>
<a name="ln1688"> </a>
<a name="ln1689">      n = oap-&gt;end.col - oap-&gt;start.col + 1 - !oap-&gt;inclusive;</a>
<a name="ln1690"> </a>
<a name="ln1691">      if (virtual_op) {</a>
<a name="ln1692">        // fix up things for virtualedit-delete:</a>
<a name="ln1693">        // break the tabs which are going to get in our way</a>
<a name="ln1694">        char *curline = get_cursor_line_ptr();</a>
<a name="ln1695">        int len = (int)strlen(curline);</a>
<a name="ln1696"> </a>
<a name="ln1697">        if (oap-&gt;end.coladd != 0</a>
<a name="ln1698">            &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1</a>
<a name="ln1699">            &amp;&amp; !(oap-&gt;start.coladd &amp;&amp; (int)oap-&gt;end.col &gt;= len - 1)) {</a>
<a name="ln1700">          n++;</a>
<a name="ln1701">        }</a>
<a name="ln1702">        // Delete at least one char (e.g, when on a control char).</a>
<a name="ln1703">        if (n == 0 &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd) {</a>
<a name="ln1704">          n = 1;</a>
<a name="ln1705">        }</a>
<a name="ln1706"> </a>
<a name="ln1707">        // When deleted a char in the line, reset coladd.</a>
<a name="ln1708">        if (gchar_cursor() != NUL) {</a>
<a name="ln1709">          curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln1710">        }</a>
<a name="ln1711">      }</a>
<a name="ln1712"> </a>
<a name="ln1713">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1714">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1715">    } else {</a>
<a name="ln1716">      // delete characters between lines</a>
<a name="ln1717">      pos_T curpos;</a>
<a name="ln1718"> </a>
<a name="ln1719">      // save deleted and changed lines for undo</a>
<a name="ln1720">      if (u_save((linenr_T)(curwin-&gt;w_cursor.lnum - 1),</a>
<a name="ln1721">                 (linenr_T)(curwin-&gt;w_cursor.lnum + oap-&gt;line_count)) == FAIL) {</a>
<a name="ln1722">        return FAIL;</a>
<a name="ln1723">      }</a>
<a name="ln1724"> </a>
<a name="ln1725">      curbuf_splice_pending++;</a>
<a name="ln1726">      pos_T startpos = curwin-&gt;w_cursor;  // start position for delete</a>
<a name="ln1727">      bcount_t deleted_bytes = get_region_bytecount(curbuf, startpos.lnum, oap-&gt;end.lnum,</a>
<a name="ln1728">                                                    startpos.col,</a>
<a name="ln1729">                                                    oap-&gt;end.col) + oap-&gt;inclusive;</a>
<a name="ln1730">      truncate_line(true);        // delete from cursor to end of line</a>
<a name="ln1731"> </a>
<a name="ln1732">      curpos = curwin-&gt;w_cursor;  // remember curwin-&gt;w_cursor</a>
<a name="ln1733">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln1734"> </a>
<a name="ln1735">      del_lines(oap-&gt;line_count - 2, false);</a>
<a name="ln1736"> </a>
<a name="ln1737">      // delete from start of line until op_end</a>
<a name="ln1738">      n = (oap-&gt;end.col + 1 - !oap-&gt;inclusive);</a>
<a name="ln1739">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1740">      (void)del_bytes((colnr_T)n, !virtual_op,</a>
<a name="ln1741">                      oap-&gt;op_type == OP_DELETE &amp;&amp; !oap-&gt;is_VIsual);</a>
<a name="ln1742">      curwin-&gt;w_cursor = curpos;  // restore curwin-&gt;w_cursor</a>
<a name="ln1743">      (void)do_join(2, false, false, false, false);</a>
<a name="ln1744">      curbuf_splice_pending--;</a>
<a name="ln1745">      extmark_splice(curbuf, (int)startpos.lnum - 1, startpos.col,</a>
<a name="ln1746">                     (int)oap-&gt;line_count - 1, n, deleted_bytes,</a>
<a name="ln1747">                     0, 0, 0, kExtmarkUndo);</a>
<a name="ln1748">    }</a>
<a name="ln1749">    if (oap-&gt;op_type == OP_DELETE) {</a>
<a name="ln1750">      auto_format(false, true);</a>
<a name="ln1751">    }</a>
<a name="ln1752">  }</a>
<a name="ln1753"> </a>
<a name="ln1754">  msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln1755"> </a>
<a name="ln1756">setmarks:</a>
<a name="ln1757">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1758">    if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1759">      curbuf-&gt;b_op_end.lnum = oap-&gt;end.lnum;</a>
<a name="ln1760">      curbuf-&gt;b_op_end.col = oap-&gt;start.col;</a>
<a name="ln1761">    } else {</a>
<a name="ln1762">      curbuf-&gt;b_op_end = oap-&gt;start;</a>
<a name="ln1763">    }</a>
<a name="ln1764">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln1765">  }</a>
<a name="ln1766"> </a>
<a name="ln1767">  return OK;</a>
<a name="ln1768">}</a>
<a name="ln1769"> </a>
<a name="ln1770">/// Adjust end of operating area for ending on a multi-byte character.</a>
<a name="ln1771">/// Used for deletion.</a>
<a name="ln1772">static void mb_adjust_opend(oparg_T *oap)</a>
<a name="ln1773">{</a>
<a name="ln1774">  if (!oap-&gt;inclusive) {</a>
<a name="ln1775">    return;</a>
<a name="ln1776">  }</a>
<a name="ln1777"> </a>
<a name="ln1778">  char *p = ml_get(oap-&gt;end.lnum);</a>
<a name="ln1779">  oap-&gt;end.col += utf_cp_tail_off(p, p + oap-&gt;end.col);</a>
<a name="ln1780">}</a>
<a name="ln1781"> </a>
<a name="ln1782">/// Put character 'c' at position 'lp'</a>
<a name="ln1783">static inline void pbyte(pos_T lp, int c)</a>
<a name="ln1784">{</a>
<a name="ln1785">  assert(c &lt;= UCHAR_MAX);</a>
<a name="ln1786">  *(ml_get_buf(curbuf, lp.lnum, true) + lp.col) = (char)c;</a>
<a name="ln1787">  if (!curbuf_splice_pending) {</a>
<a name="ln1788">    extmark_splice_cols(curbuf, (int)lp.lnum - 1, lp.col, 1, 1, kExtmarkUndo);</a>
<a name="ln1789">  }</a>
<a name="ln1790">}</a>
<a name="ln1791"> </a>
<a name="ln1792">/// Replace the character under the cursor with &quot;c&quot;.</a>
<a name="ln1793">/// This takes care of multi-byte characters.</a>
<a name="ln1794">static void replace_character(int c)</a>
<a name="ln1795">{</a>
<a name="ln1796">  const int n = State;</a>
<a name="ln1797"> </a>
<a name="ln1798">  State = MODE_REPLACE;</a>
<a name="ln1799">  ins_char(c);</a>
<a name="ln1800">  State = n;</a>
<a name="ln1801">  // Backup to the replaced character.</a>
<a name="ln1802">  dec_cursor();</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">/// Replace a whole area with one character.</a>
<a name="ln1806">static int op_replace(oparg_T *oap, int c)</a>
<a name="ln1807">{</a>
<a name="ln1808">  int n;</a>
<a name="ln1809">  struct block_def bd;</a>
<a name="ln1810">  char *after_p = NULL;</a>
<a name="ln1811">  int had_ctrl_v_cr = false;</a>
<a name="ln1812"> </a>
<a name="ln1813">  if ((curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) || oap-&gt;empty) {</a>
<a name="ln1814">    return OK;              // nothing to do</a>
<a name="ln1815">  }</a>
<a name="ln1816">  if (c == REPLACE_CR_NCHAR) {</a>
<a name="ln1817">    had_ctrl_v_cr = true;</a>
<a name="ln1818">    c = CAR;</a>
<a name="ln1819">  } else if (c == REPLACE_NL_NCHAR) {</a>
<a name="ln1820">    had_ctrl_v_cr = true;</a>
<a name="ln1821">    c = NL;</a>
<a name="ln1822">  }</a>
<a name="ln1823"> </a>
<a name="ln1824">  mb_adjust_opend(oap);</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln1827">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln1828">    return FAIL;</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  // block mode replace</a>
<a name="ln1832">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln1833">    int numc;</a>
<a name="ln1834">    int num_chars;</a>
<a name="ln1835">    char *newp;</a>
<a name="ln1836">    char *oldp;</a>
<a name="ln1837">    colnr_T oldlen;</a>
<a name="ln1838">    bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln1839">    for (; curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln1840">      curwin-&gt;w_cursor.col = 0;       // make sure cursor position is valid</a>
<a name="ln1841">      block_prep(oap, &amp;bd, curwin-&gt;w_cursor.lnum, true);</a>
<a name="ln1842">      if (bd.textlen == 0 &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1843">        continue;                     // nothing to replace</a>
<a name="ln1844">      }</a>
<a name="ln1845"> </a>
<a name="ln1846">      // n == number of extra chars required</a>
<a name="ln1847">      // If we split a TAB, it may be replaced by several characters.</a>
<a name="ln1848">      // Thus the number of characters may increase!</a>
<a name="ln1849">      // If the range starts in virtual space, count the initial</a>
<a name="ln1850">      // coladd offset as part of &quot;startspaces&quot;</a>
<a name="ln1851">      if (virtual_op &amp;&amp; bd.is_short &amp;&amp; *bd.textstart == NUL) {</a>
<a name="ln1852">        pos_T vpos;</a>
<a name="ln1853"> </a>
<a name="ln1854">        vpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1855">        getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln1856">        bd.startspaces += vpos.coladd;</a>
<a name="ln1857">        n = bd.startspaces;</a>
<a name="ln1858">      } else {</a>
<a name="ln1859">        // allow for pre spaces</a>
<a name="ln1860">        n = (bd.startspaces ? bd.start_char_vcols - 1 : 0);</a>
<a name="ln1861">      }</a>
<a name="ln1862"> </a>
<a name="ln1863">      // allow for post spp</a>
<a name="ln1864">      n += (bd.endspaces</a>
<a name="ln1865">            &amp;&amp; !bd.is_oneChar</a>
<a name="ln1866">            &amp;&amp; bd.end_char_vcols &gt; 0) ? bd.end_char_vcols - 1 : 0;</a>
<a name="ln1867">      // Figure out how many characters to replace.</a>
<a name="ln1868">      numc = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln1869">      if (bd.is_short &amp;&amp; (!virtual_op || bd.is_MAX)) {</a>
<a name="ln1870">        numc -= (oap-&gt;end_vcol - bd.end_vcol) + 1;</a>
<a name="ln1871">      }</a>
<a name="ln1872"> </a>
<a name="ln1873">      // A double-wide character can be replaced only up to half the</a>
<a name="ln1874">      // times.</a>
<a name="ln1875">      if (utf_char2cells(c) &gt; 1) {</a>
<a name="ln1876">        if ((numc &amp; 1) &amp;&amp; !bd.is_short) {</a>
<a name="ln1877">          bd.endspaces++;</a>
<a name="ln1878">          n++;</a>
<a name="ln1879">        }</a>
<a name="ln1880">        numc = numc / 2;</a>
<a name="ln1881">      }</a>
<a name="ln1882"> </a>
<a name="ln1883">      // Compute bytes needed, move character count to num_chars.</a>
<a name="ln1884">      num_chars = numc;</a>
<a name="ln1885">      numc *= utf_char2len(c);</a>
<a name="ln1886"> </a>
<a name="ln1887">      oldp = get_cursor_line_ptr();</a>
<a name="ln1888">      oldlen = (int)strlen(oldp);</a>
<a name="ln1889"> </a>
<a name="ln1890">      size_t newp_size = (size_t)bd.textcol + (size_t)bd.startspaces;</a>
<a name="ln1891">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1892">        newp_size += (size_t)numc;</a>
<a name="ln1893">        if (!bd.is_short) {</a>
<a name="ln1894">          newp_size += (size_t)(bd.endspaces + oldlen</a>
<a name="ln1895">                                - bd.textcol - bd.textlen);</a>
<a name="ln1896">        }</a>
<a name="ln1897">      }</a>
<a name="ln1898">      newp = xmallocz(newp_size);</a>
<a name="ln1899">      // copy up to deleted part</a>
<a name="ln1900">      memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln1901">      oldp += bd.textcol + bd.textlen;</a>
<a name="ln1902">      // insert pre-spaces</a>
<a name="ln1903">      memset(newp + bd.textcol, ' ', (size_t)bd.startspaces);</a>
<a name="ln1904">      // insert replacement chars CHECK FOR ALLOCATED SPACE</a>
<a name="ln1905">      // REPLACE_CR_NCHAR/REPLACE_NL_NCHAR is used for entering CR literally.</a>
<a name="ln1906">      size_t after_p_len = 0;</a>
<a name="ln1907">      int col = oldlen - bd.textcol - bd.textlen + 1;</a>
<a name="ln1908">      assert(col &gt;= 0);</a>
<a name="ln1909">      int newrows = 0, newcols = 0;</a>
<a name="ln1910">      if (had_ctrl_v_cr || (c != '\r' &amp;&amp; c != '\n')) {</a>
<a name="ln1911">        // strlen(newp) at this point</a>
<a name="ln1912">        int newp_len = bd.textcol + bd.startspaces;</a>
<a name="ln1913">        while (--num_chars &gt;= 0) {</a>
<a name="ln1914">          newp_len += utf_char2bytes(c, newp + newp_len);</a>
<a name="ln1915">        }</a>
<a name="ln1916">        if (!bd.is_short) {</a>
<a name="ln1917">          // insert post-spaces</a>
<a name="ln1918">          memset(newp + newp_len, ' ', (size_t)bd.endspaces);</a>
<a name="ln1919">          newp_len += bd.endspaces;</a>
<a name="ln1920">          // copy the part after the changed part</a>
<a name="ln1921">          memmove(newp + newp_len, oldp, (size_t)col);</a>
<a name="ln1922">        }</a>
<a name="ln1923">        newcols = newp_len - bd.textcol;</a>
<a name="ln1924">      } else {</a>
<a name="ln1925">        // Replacing with \r or \n means splitting the line.</a>
<a name="ln1926">        after_p_len = (size_t)col;</a>
<a name="ln1927">        after_p = xmalloc(after_p_len);</a>
<a name="ln1928">        memmove(after_p, oldp, after_p_len);</a>
<a name="ln1929">        newrows = 1;</a>
<a name="ln1930">      }</a>
<a name="ln1931">      // replace the line</a>
<a name="ln1932">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln1933">      curbuf_splice_pending++;</a>
<a name="ln1934">      linenr_T baselnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1935">      if (after_p != NULL) {</a>
<a name="ln1936">        ml_append(curwin-&gt;w_cursor.lnum++, after_p, (int)after_p_len, false);</a>
<a name="ln1937">        appended_lines_mark(curwin-&gt;w_cursor.lnum, 1L);</a>
<a name="ln1938">        oap-&gt;end.lnum++;</a>
<a name="ln1939">        xfree(after_p);</a>
<a name="ln1940">      }</a>
<a name="ln1941">      curbuf_splice_pending--;</a>
<a name="ln1942">      extmark_splice(curbuf, (int)baselnum - 1, bd.textcol,</a>
<a name="ln1943">                     0, bd.textlen, bd.textlen,</a>
<a name="ln1944">                     newrows, newcols, newrows + newcols, kExtmarkUndo);</a>
<a name="ln1945">    }</a>
<a name="ln1946">  } else {</a>
<a name="ln1947">    // Characterwise or linewise motion replace.</a>
<a name="ln1948">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln1949">      oap-&gt;start.col = 0;</a>
<a name="ln1950">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1951">      oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln1952">      if (oap-&gt;end.col) {</a>
<a name="ln1953">        oap-&gt;end.col--;</a>
<a name="ln1954">      }</a>
<a name="ln1955">    } else if (!oap-&gt;inclusive) {</a>
<a name="ln1956">      dec(&amp;(oap-&gt;end));</a>
<a name="ln1957">    }</a>
<a name="ln1958"> </a>
<a name="ln1959">    // TODO(bfredl): we could batch all the splicing</a>
<a name="ln1960">    // done on the same line, at least</a>
<a name="ln1961">    while (ltoreq(curwin-&gt;w_cursor, oap-&gt;end)) {</a>
<a name="ln1962">      bool done = false;</a>
<a name="ln1963"> </a>
<a name="ln1964">      n = gchar_cursor();</a>
<a name="ln1965">      if (n != NUL) {</a>
<a name="ln1966">        int new_byte_len = utf_char2len(c);</a>
<a name="ln1967">        int old_byte_len = utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln1968"> </a>
<a name="ln1969">        if (new_byte_len &gt; 1 || old_byte_len &gt; 1) {</a>
<a name="ln1970">          // This is slow, but it handles replacing a single-byte</a>
<a name="ln1971">          // with a multi-byte and the other way around.</a>
<a name="ln1972">          if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1973">            oap-&gt;end.col += new_byte_len - old_byte_len;</a>
<a name="ln1974">          }</a>
<a name="ln1975">          replace_character(c);</a>
<a name="ln1976">          done = true;</a>
<a name="ln1977">        } else {</a>
<a name="ln1978">          if (n == TAB) {</a>
<a name="ln1979">            int end_vcol = 0;</a>
<a name="ln1980"> </a>
<a name="ln1981">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1982">              // oap-&gt;end has to be recalculated when</a>
<a name="ln1983">              // the tab breaks</a>
<a name="ln1984">              end_vcol = getviscol2(oap-&gt;end.col,</a>
<a name="ln1985">                                    oap-&gt;end.coladd);</a>
<a name="ln1986">            }</a>
<a name="ln1987">            coladvance_force(getviscol());</a>
<a name="ln1988">            if (curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln1989">              getvpos(&amp;oap-&gt;end, end_vcol);</a>
<a name="ln1990">            }</a>
<a name="ln1991">          }</a>
<a name="ln1992">          // with &quot;coladd&quot; set may move to just after a TAB</a>
<a name="ln1993">          if (gchar_cursor() != NUL) {</a>
<a name="ln1994">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln1995">            done = true;</a>
<a name="ln1996">          }</a>
<a name="ln1997">        }</a>
<a name="ln1998">      }</a>
<a name="ln1999">      if (!done &amp;&amp; virtual_op &amp;&amp; curwin-&gt;w_cursor.lnum == oap-&gt;end.lnum) {</a>
<a name="ln2000">        int virtcols = oap-&gt;end.coladd;</a>
<a name="ln2001"> </a>
<a name="ln2002">        if (curwin-&gt;w_cursor.lnum == oap-&gt;start.lnum</a>
<a name="ln2003">            &amp;&amp; oap-&gt;start.col == oap-&gt;end.col &amp;&amp; oap-&gt;start.coladd) {</a>
<a name="ln2004">          virtcols -= oap-&gt;start.coladd;</a>
<a name="ln2005">        }</a>
<a name="ln2006"> </a>
<a name="ln2007">        // oap-&gt;end has been trimmed so it's effectively inclusive;</a>
<a name="ln2008">        // as a result an extra +1 must be counted so we don't</a>
<a name="ln2009">        // trample the NUL byte.</a>
<a name="ln2010">        coladvance_force(getviscol2(oap-&gt;end.col, oap-&gt;end.coladd) + 1);</a>
<a name="ln2011">        curwin-&gt;w_cursor.col -= (virtcols + 1);</a>
<a name="ln2012">        for (; virtcols &gt;= 0; virtcols--) {</a>
<a name="ln2013">          if (utf_char2len(c) &gt; 1) {</a>
<a name="ln2014">            replace_character(c);</a>
<a name="ln2015">          } else {</a>
<a name="ln2016">            pbyte(curwin-&gt;w_cursor, c);</a>
<a name="ln2017">          }</a>
<a name="ln2018">          if (inc(&amp;curwin-&gt;w_cursor) == -1) {</a>
<a name="ln2019">            break;</a>
<a name="ln2020">          }</a>
<a name="ln2021">        }</a>
<a name="ln2022">      }</a>
<a name="ln2023"> </a>
<a name="ln2024">      // Advance to next character, stop at the end of the file.</a>
<a name="ln2025">      if (inc_cursor() == -1) {</a>
<a name="ln2026">        break;</a>
<a name="ln2027">      }</a>
<a name="ln2028">    }</a>
<a name="ln2029">  }</a>
<a name="ln2030"> </a>
<a name="ln2031">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln2032">  check_cursor();</a>
<a name="ln2033">  changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2034"> </a>
<a name="ln2035">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2036">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2037">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2038">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2039">  }</a>
<a name="ln2040"> </a>
<a name="ln2041">  return OK;</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">/// Handle the (non-standard vi) tilde operator.  Also for &quot;gu&quot;, &quot;gU&quot; and &quot;g?&quot;.</a>
<a name="ln2045">void op_tilde(oparg_T *oap)</a>
<a name="ln2046">{</a>
<a name="ln2047">  pos_T pos;</a>
<a name="ln2048">  struct block_def bd;</a>
<a name="ln2049">  int did_change = false;</a>
<a name="ln2050"> </a>
<a name="ln2051">  if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln2052">             (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln2053">    return;</a>
<a name="ln2054">  }</a>
<a name="ln2055"> </a>
<a name="ln2056">  pos = oap-&gt;start;</a>
<a name="ln2057">  if (oap-&gt;motion_type == kMTBlockWise) {  // Visual block mode</a>
<a name="ln2058">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln2059">      int one_change;</a>
<a name="ln2060"> </a>
<a name="ln2061">      block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln2062">      pos.col = bd.textcol;</a>
<a name="ln2063">      one_change = swapchars(oap-&gt;op_type, &amp;pos, bd.textlen);</a>
<a name="ln2064">      did_change |= one_change;</a>
<a name="ln2065">    }</a>
<a name="ln2066">    if (did_change) {</a>
<a name="ln2067">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2068">    }</a>
<a name="ln2069">  } else {  // not block mode</a>
<a name="ln2070">    if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2071">      oap-&gt;start.col = 0;</a>
<a name="ln2072">      pos.col = 0;</a>
<a name="ln2073">      oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln2074">      if (oap-&gt;end.col) {</a>
<a name="ln2075">        oap-&gt;end.col--;</a>
<a name="ln2076">      }</a>
<a name="ln2077">    } else if (!oap-&gt;inclusive) {</a>
<a name="ln2078">      dec(&amp;(oap-&gt;end));</a>
<a name="ln2079">    }</a>
<a name="ln2080"> </a>
<a name="ln2081">    if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln2082">      did_change = swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2083">                             oap-&gt;end.col - pos.col + 1);</a>
<a name="ln2084">    } else {</a>
<a name="ln2085">      while (true) {</a>
<a name="ln2086">        did_change |= swapchars(oap-&gt;op_type, &amp;pos,</a>
<a name="ln2087">                                pos.lnum == oap-&gt;end.lnum ? oap-&gt;end.col + 1 :</a>
<a name="ln2088">                                (int)strlen(ml_get_pos(&amp;pos)));</a>
<a name="ln2089">        if (ltoreq(oap-&gt;end, pos) || inc(&amp;pos) == -1) {</a>
<a name="ln2090">          break;</a>
<a name="ln2091">        }</a>
<a name="ln2092">      }</a>
<a name="ln2093">    }</a>
<a name="ln2094">    if (did_change) {</a>
<a name="ln2095">      changed_lines(oap-&gt;start.lnum, oap-&gt;start.col, oap-&gt;end.lnum + 1,</a>
<a name="ln2096">                    0L, true);</a>
<a name="ln2097">    }</a>
<a name="ln2098">  }</a>
<a name="ln2099"> </a>
<a name="ln2100">  if (!did_change &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln2101">    // No change: need to remove the Visual selection</a>
<a name="ln2102">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln2103">  }</a>
<a name="ln2104"> </a>
<a name="ln2105">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2106">    // Set '[ and '] marks.</a>
<a name="ln2107">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2108">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2109">  }</a>
<a name="ln2110"> </a>
<a name="ln2111">  if (oap-&gt;line_count &gt; p_report) {</a>
<a name="ln2112">    smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line changed&quot;,</a>
<a name="ln2113">                  &quot;%&quot; PRId64 &quot; lines changed&quot;, oap-&gt;line_count),</a>
<a name="ln2114">         (int64_t)oap-&gt;line_count);</a>
<a name="ln2115">  }</a>
<a name="ln2116">}</a>
<a name="ln2117"> </a>
<a name="ln2118">/// Invoke swapchar() on &quot;length&quot; bytes at position &quot;pos&quot;.</a>
<a name="ln2119">///</a>
<a name="ln2120">/// @param pos     is advanced to just after the changed characters.</a>
<a name="ln2121">/// @param length  is rounded up to include the whole last multi-byte character.</a>
<a name="ln2122">/// Also works correctly when the number of bytes changes.</a>
<a name="ln2123">///</a>
<a name="ln2124">/// @return  true if some character was changed.</a>
<a name="ln2125">static int swapchars(int op_type, pos_T *pos, int length)</a>
<a name="ln2126">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2127">{</a>
<a name="ln2128">  int did_change = 0;</a>
<a name="ln2129"> </a>
<a name="ln2130">  for (int todo = length; todo &gt; 0; todo--) {</a>
<a name="ln2131">    const int len = utfc_ptr2len(ml_get_pos(pos));</a>
<a name="ln2132"> </a>
<a name="ln2133">    // we're counting bytes, not characters</a>
<a name="ln2134">    if (len &gt; 0) {</a>
<a name="ln2135">      todo -= len - 1;</a>
<a name="ln2136">    }</a>
<a name="ln2137">    did_change |= swapchar(op_type, pos);</a>
<a name="ln2138">    if (inc(pos) == -1) {      // at end of file</a>
<a name="ln2139">      break;</a>
<a name="ln2140">    }</a>
<a name="ln2141">  }</a>
<a name="ln2142">  return did_change;</a>
<a name="ln2143">}</a>
<a name="ln2144"> </a>
<a name="ln2145">/// @param op_type</a>
<a name="ln2146">///                 == OP_UPPER: make uppercase,</a>
<a name="ln2147">///                 == OP_LOWER: make lowercase,</a>
<a name="ln2148">///                 == OP_ROT13: do rot13 encoding,</a>
<a name="ln2149">///                 else swap case of character at 'pos'</a>
<a name="ln2150">///</a>
<a name="ln2151">/// @return  true when something actually changed.</a>
<a name="ln2152">bool swapchar(int op_type, pos_T *pos)</a>
<a name="ln2153">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2154">{</a>
<a name="ln2155">  const int c = gchar_pos(pos);</a>
<a name="ln2156"> </a>
<a name="ln2157">  // Only do rot13 encoding for ASCII characters.</a>
<a name="ln2158">  if (c &gt;= 0x80 &amp;&amp; op_type == OP_ROT13) {</a>
<a name="ln2159">    return false;</a>
<a name="ln2160">  }</a>
<a name="ln2161"> </a>
<a name="ln2162">  if (op_type == OP_UPPER &amp;&amp; c == 0xdf) {</a>
<a name="ln2163">    pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2164"> </a>
<a name="ln2165">    // Special handling of German sharp s: change to &quot;SS&quot;.</a>
<a name="ln2166">    curwin-&gt;w_cursor = *pos;</a>
<a name="ln2167">    del_char(false);</a>
<a name="ln2168">    ins_char('S');</a>
<a name="ln2169">    ins_char('S');</a>
<a name="ln2170">    curwin-&gt;w_cursor = sp;</a>
<a name="ln2171">    inc(pos);</a>
<a name="ln2172">  }</a>
<a name="ln2173"> </a>
<a name="ln2174">  int nc = c;</a>
<a name="ln2175">  if (mb_islower(c)) {</a>
<a name="ln2176">    if (op_type == OP_ROT13) {</a>
<a name="ln2177">      nc = ROT13(c, 'a');</a>
<a name="ln2178">    } else if (op_type != OP_LOWER) {</a>
<a name="ln2179">      nc = mb_toupper(c);</a>
<a name="ln2180">    }</a>
<a name="ln2181">  } else if (mb_isupper(c)) {</a>
<a name="ln2182">    if (op_type == OP_ROT13) {</a>
<a name="ln2183">      nc = ROT13(c, 'A');</a>
<a name="ln2184">    } else if (op_type != OP_UPPER) {</a>
<a name="ln2185">      nc = mb_tolower(c);</a>
<a name="ln2186">    }</a>
<a name="ln2187">  }</a>
<a name="ln2188">  if (nc != c) {</a>
<a name="ln2189">    if (c &gt;= 0x80 || nc &gt;= 0x80) {</a>
<a name="ln2190">      pos_T sp = curwin-&gt;w_cursor;</a>
<a name="ln2191"> </a>
<a name="ln2192">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln2193">      // don't use del_char(), it also removes composing chars</a>
<a name="ln2194">      del_bytes(utf_ptr2len(get_cursor_pos_ptr()), false, false);</a>
<a name="ln2195">      ins_char(nc);</a>
<a name="ln2196">      curwin-&gt;w_cursor = sp;</a>
<a name="ln2197">    } else {</a>
<a name="ln2198">      pbyte(*pos, nc);</a>
<a name="ln2199">    }</a>
<a name="ln2200">    return true;</a>
<a name="ln2201">  }</a>
<a name="ln2202">  return false;</a>
<a name="ln2203">}</a>
<a name="ln2204"> </a>
<a name="ln2205">/// Insert and append operators for Visual mode.</a>
<a name="ln2206">void op_insert(oparg_T *oap, long count1)</a>
<a name="ln2207">{</a>
<a name="ln2208">  long pre_textlen = 0;</a>
<a name="ln2209">  char *firstline;</a>
<a name="ln2210">  colnr_T ind_pre_col = 0;</a>
<a name="ln2211">  int ind_pre_vcol = 0;</a>
<a name="ln2212">  struct block_def bd;</a>
<a name="ln2213">  pos_T t1;</a>
<a name="ln2214"> </a>
<a name="ln2215">  // edit() changes this - record it for OP_APPEND</a>
<a name="ln2216">  bd.is_MAX = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln2217"> </a>
<a name="ln2218">  // vis block is still marked. Get rid of it now.</a>
<a name="ln2219">  curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln2220">  redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln2221">  update_screen();</a>
<a name="ln2222"> </a>
<a name="ln2223">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2224">    // When 'virtualedit' is used, need to insert the extra spaces before</a>
<a name="ln2225">    // doing block_prep().  When only &quot;block&quot; is used, virtual edit is</a>
<a name="ln2226">    // already disabled, but still need it when calling</a>
<a name="ln2227">    // coladvance_force().</a>
<a name="ln2228">    // coladvance_force() uses get_ve_flags() to get the 'virtualedit'</a>
<a name="ln2229">    // state for the current window.  To override that state, we need to</a>
<a name="ln2230">    // set the window-local value of ve_flags rather than the global value.</a>
<a name="ln2231">    if (curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln2232">      unsigned old_ve_flags = curwin-&gt;w_ve_flags;</a>
<a name="ln2233"> </a>
<a name="ln2234">      if (u_save_cursor() == FAIL) {</a>
<a name="ln2235">        return;</a>
<a name="ln2236">      }</a>
<a name="ln2237">      curwin-&gt;w_ve_flags = VE_ALL;</a>
<a name="ln2238">      coladvance_force(oap-&gt;op_type == OP_APPEND</a>
<a name="ln2239">                       ? oap-&gt;end_vcol + 1 : getviscol());</a>
<a name="ln2240">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2241">        curwin-&gt;w_cursor.col--;</a>
<a name="ln2242">      }</a>
<a name="ln2243">      curwin-&gt;w_ve_flags = old_ve_flags;</a>
<a name="ln2244">    }</a>
<a name="ln2245">    // Get the info about the block before entering the text</a>
<a name="ln2246">    block_prep(oap, &amp;bd, oap-&gt;start.lnum, true);</a>
<a name="ln2247">    // Get indent information</a>
<a name="ln2248">    ind_pre_col = (colnr_T)getwhitecols_curline();</a>
<a name="ln2249">    ind_pre_vcol = get_indent();</a>
<a name="ln2250">    firstline = ml_get(oap-&gt;start.lnum) + bd.textcol;</a>
<a name="ln2251"> </a>
<a name="ln2252">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2253">      firstline += bd.textlen;</a>
<a name="ln2254">    }</a>
<a name="ln2255">    pre_textlen = (long)strlen(firstline);</a>
<a name="ln2256">  }</a>
<a name="ln2257"> </a>
<a name="ln2258">  if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2259">    if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2260">        &amp;&amp; curwin-&gt;w_cursor.coladd == 0) {</a>
<a name="ln2261">      // Move the cursor to the character right of the block.</a>
<a name="ln2262">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln2263">      while (*get_cursor_pos_ptr() != NUL</a>
<a name="ln2264">             &amp;&amp; (curwin-&gt;w_cursor.col &lt; bd.textcol + bd.textlen)) {</a>
<a name="ln2265">        curwin-&gt;w_cursor.col++;</a>
<a name="ln2266">      }</a>
<a name="ln2267">      if (bd.is_short &amp;&amp; !bd.is_MAX) {</a>
<a name="ln2268">        // First line was too short, make it longer and adjust the</a>
<a name="ln2269">        // values in &quot;bd&quot;.</a>
<a name="ln2270">        if (u_save_cursor() == FAIL) {</a>
<a name="ln2271">          return;</a>
<a name="ln2272">        }</a>
<a name="ln2273">        for (int i = 0; i &lt; bd.endspaces; i++) {</a>
<a name="ln2274">          ins_char(' ');</a>
<a name="ln2275">        }</a>
<a name="ln2276">        bd.textlen += bd.endspaces;</a>
<a name="ln2277">      }</a>
<a name="ln2278">    } else {</a>
<a name="ln2279">      curwin-&gt;w_cursor = oap-&gt;end;</a>
<a name="ln2280">      check_cursor_col();</a>
<a name="ln2281"> </a>
<a name="ln2282">      // Works just like an 'i'nsert on the next character.</a>
<a name="ln2283">      if (!LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2284">          &amp;&amp; oap-&gt;start_vcol != oap-&gt;end_vcol) {</a>
<a name="ln2285">        inc_cursor();</a>
<a name="ln2286">      }</a>
<a name="ln2287">    }</a>
<a name="ln2288">  }</a>
<a name="ln2289"> </a>
<a name="ln2290">  t1 = oap-&gt;start;</a>
<a name="ln2291">  const pos_T start_insert = curwin-&gt;w_cursor;</a>
<a name="ln2292">  (void)edit(NUL, false, (linenr_T)count1);</a>
<a name="ln2293"> </a>
<a name="ln2294">  // When a tab was inserted, and the characters in front of the tab</a>
<a name="ln2295">  // have been converted to a tab as well, the column of the cursor</a>
<a name="ln2296">  // might have actually been reduced, so need to adjust here.</a>
<a name="ln2297">  if (t1.lnum == curbuf-&gt;b_op_start_orig.lnum</a>
<a name="ln2298">      &amp;&amp; lt(curbuf-&gt;b_op_start_orig, t1)) {</a>
<a name="ln2299">    oap-&gt;start = curbuf-&gt;b_op_start_orig;</a>
<a name="ln2300">  }</a>
<a name="ln2301"> </a>
<a name="ln2302">  // If user has moved off this line, we don't know what to do, so do</a>
<a name="ln2303">  // nothing.</a>
<a name="ln2304">  // Also don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2305">  if (curwin-&gt;w_cursor.lnum != oap-&gt;start.lnum || got_int) {</a>
<a name="ln2306">    return;</a>
<a name="ln2307">  }</a>
<a name="ln2308"> </a>
<a name="ln2309">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2310">    int ind_post_vcol = 0;</a>
<a name="ln2311">    struct block_def bd2;</a>
<a name="ln2312">    bool did_indent = false;</a>
<a name="ln2313"> </a>
<a name="ln2314">    // if indent kicked in, the firstline might have changed</a>
<a name="ln2315">    // but only do that, if the indent actually increased</a>
<a name="ln2316">    colnr_T ind_post_col = (colnr_T)getwhitecols_curline();</a>
<a name="ln2317">    if (curbuf-&gt;b_op_start.col &gt; ind_pre_col &amp;&amp; ind_post_col &gt; ind_pre_col) {</a>
<a name="ln2318">      bd.textcol += ind_post_col - ind_pre_col;</a>
<a name="ln2319">      ind_post_vcol = get_indent();</a>
<a name="ln2320">      bd.start_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2321">      did_indent = true;</a>
<a name="ln2322">    }</a>
<a name="ln2323"> </a>
<a name="ln2324">    // The user may have moved the cursor before inserting something, try</a>
<a name="ln2325">    // to adjust the block for that.  But only do it, if the difference</a>
<a name="ln2326">    // does not come from indent kicking in.</a>
<a name="ln2327">    if (oap-&gt;start.lnum == curbuf-&gt;b_op_start_orig.lnum &amp;&amp; !bd.is_MAX &amp;&amp; !did_indent) {</a>
<a name="ln2328">      const int t = getviscol2(curbuf-&gt;b_op_start_orig.col, curbuf-&gt;b_op_start_orig.coladd);</a>
<a name="ln2329"> </a>
<a name="ln2330">      if (oap-&gt;op_type == OP_INSERT</a>
<a name="ln2331">          &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2332">          != curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2333">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2334">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2335">        oap-&gt;start_vcol = t;</a>
<a name="ln2336">      } else if (oap-&gt;op_type == OP_APPEND</a>
<a name="ln2337">                 &amp;&amp; oap-&gt;start.col + oap-&gt;start.coladd</a>
<a name="ln2338">                 &gt;= curbuf-&gt;b_op_start_orig.col + curbuf-&gt;b_op_start_orig.coladd) {</a>
<a name="ln2339">        oap-&gt;start.col = curbuf-&gt;b_op_start_orig.col;</a>
<a name="ln2340">        // reset pre_textlen to the value of OP_INSERT</a>
<a name="ln2341">        pre_textlen += bd.textlen;</a>
<a name="ln2342">        pre_textlen -= t - oap-&gt;start_vcol;</a>
<a name="ln2343">        oap-&gt;start_vcol = t;</a>
<a name="ln2344">        oap-&gt;op_type = OP_INSERT;</a>
<a name="ln2345">      }</a>
<a name="ln2346">    }</a>
<a name="ln2347"> </a>
<a name="ln2348">    // Spaces and tabs in the indent may have changed to other spaces and</a>
<a name="ln2349">    // tabs.  Get the starting column again and correct the length.</a>
<a name="ln2350">    // Don't do this when &quot;$&quot; used, end-of-line will have changed.</a>
<a name="ln2351">    //</a>
<a name="ln2352">    // if indent was added and the inserted text was after the indent,</a>
<a name="ln2353">    // correct the selection for the new indent.</a>
<a name="ln2354">    if (did_indent &amp;&amp; bd.textcol - ind_post_col &gt; 0) {</a>
<a name="ln2355">      oap-&gt;start.col += ind_post_col - ind_pre_col;</a>
<a name="ln2356">      oap-&gt;start_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2357">      oap-&gt;end.col += ind_post_col - ind_pre_col;</a>
<a name="ln2358">      oap-&gt;end_vcol += ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2359">    }</a>
<a name="ln2360">    block_prep(oap, &amp;bd2, oap-&gt;start.lnum, true);</a>
<a name="ln2361">    if (did_indent &amp;&amp; bd.textcol - ind_post_col &gt; 0) {</a>
<a name="ln2362">      // undo for where &quot;oap&quot; is used below</a>
<a name="ln2363">      oap-&gt;start.col -= ind_post_col - ind_pre_col;</a>
<a name="ln2364">      oap-&gt;start_vcol -= ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2365">      oap-&gt;end.col -= ind_post_col - ind_pre_col;</a>
<a name="ln2366">      oap-&gt;end_vcol -= ind_post_vcol - ind_pre_vcol;</a>
<a name="ln2367">    }</a>
<a name="ln2368">    if (!bd.is_MAX || bd2.textlen &lt; bd.textlen) {</a>
<a name="ln2369">      if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2370">        pre_textlen += bd2.textlen - bd.textlen;</a>
<a name="ln2371">        if (bd2.endspaces) {</a>
<a name="ln2372">          bd2.textlen--;</a>
<a name="ln2373">        }</a>
<a name="ln2374">      }</a>
<a name="ln2375">      bd.textcol = bd2.textcol;</a>
<a name="ln2376">      bd.textlen = bd2.textlen;</a>
<a name="ln2377">    }</a>
<a name="ln2378"> </a>
<a name="ln2379">    // Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2380">    // copy of the required string.</a>
<a name="ln2381">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2382">    const size_t len = strlen(firstline);</a>
<a name="ln2383">    colnr_T add = bd.textcol;</a>
<a name="ln2384">    colnr_T offset = 0;  // offset when cursor was moved in insert mode</a>
<a name="ln2385">    if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln2386">      add += bd.textlen;</a>
<a name="ln2387">      // account for pressing cursor in insert mode when '$' was used</a>
<a name="ln2388">      if (bd.is_MAX &amp;&amp; start_insert.lnum == Insstart.lnum &amp;&amp; start_insert.col &gt; Insstart.col) {</a>
<a name="ln2389">        offset = start_insert.col - Insstart.col;</a>
<a name="ln2390">        add -= offset;</a>
<a name="ln2391">        if (oap-&gt;end_vcol &gt; offset) {</a>
<a name="ln2392">          oap-&gt;end_vcol -= offset + 1;</a>
<a name="ln2393">        } else {</a>
<a name="ln2394">          // moved outside of the visual block, what to do?</a>
<a name="ln2395">          return;</a>
<a name="ln2396">        }</a>
<a name="ln2397">      }</a>
<a name="ln2398">    }</a>
<a name="ln2399">    if ((size_t)add &gt; len) {</a>
<a name="ln2400">      firstline += len;  // short line, point to the NUL</a>
<a name="ln2401">    } else {</a>
<a name="ln2402">      firstline += add;</a>
<a name="ln2403">    }</a>
<a name="ln2404">    long ins_len = (long)strlen(firstline) - pre_textlen - offset;</a>
<a name="ln2405">    if (pre_textlen &gt;= 0 &amp;&amp; ins_len &gt; 0) {</a>
<a name="ln2406">      char *ins_text = xstrnsave(firstline, (size_t)ins_len);</a>
<a name="ln2407">      // block handled here</a>
<a name="ln2408">      if (u_save(oap-&gt;start.lnum, (linenr_T)(oap-&gt;end.lnum + 1)) == OK) {</a>
<a name="ln2409">        block_insert(oap, ins_text, (oap-&gt;op_type == OP_INSERT), &amp;bd);</a>
<a name="ln2410">      }</a>
<a name="ln2411"> </a>
<a name="ln2412">      curwin-&gt;w_cursor.col = oap-&gt;start.col;</a>
<a name="ln2413">      check_cursor();</a>
<a name="ln2414">      xfree(ins_text);</a>
<a name="ln2415">    }</a>
<a name="ln2416">  }</a>
<a name="ln2417">}</a>
<a name="ln2418"> </a>
<a name="ln2419">/// handle a change operation</a>
<a name="ln2420">///</a>
<a name="ln2421">/// @return  true if edit() returns because of a CTRL-O command</a>
<a name="ln2422">int op_change(oparg_T *oap)</a>
<a name="ln2423">{</a>
<a name="ln2424">  int retval;</a>
<a name="ln2425">  long pre_textlen = 0;</a>
<a name="ln2426">  long pre_indent = 0;</a>
<a name="ln2427">  char *firstline;</a>
<a name="ln2428">  struct block_def bd;</a>
<a name="ln2429"> </a>
<a name="ln2430">  colnr_T l = oap-&gt;start.col;</a>
<a name="ln2431">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2432">    l = 0;</a>
<a name="ln2433">    can_si = may_do_si();  // Like opening a new line, do smart indent</a>
<a name="ln2434">  }</a>
<a name="ln2435"> </a>
<a name="ln2436">  // First delete the text in the region.  In an empty buffer only need to</a>
<a name="ln2437">  // save for undo</a>
<a name="ln2438">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln2439">    if (u_save_cursor() == FAIL) {</a>
<a name="ln2440">      return false;</a>
<a name="ln2441">    }</a>
<a name="ln2442">  } else if (op_delete(oap) == FAIL) {</a>
<a name="ln2443">    return false;</a>
<a name="ln2444">  }</a>
<a name="ln2445"> </a>
<a name="ln2446">  if ((l &gt; curwin-&gt;w_cursor.col) &amp;&amp; !LINEEMPTY(curwin-&gt;w_cursor.lnum)</a>
<a name="ln2447">      &amp;&amp; !virtual_op) {</a>
<a name="ln2448">    inc_cursor();</a>
<a name="ln2449">  }</a>
<a name="ln2450"> </a>
<a name="ln2451">  // check for still on same line (&lt;CR&gt; in inserted text meaningless)</a>
<a name="ln2452">  // skip blank lines too</a>
<a name="ln2453">  if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln2454">    // Add spaces before getting the current line length.</a>
<a name="ln2455">    if (virtual_op &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0</a>
<a name="ln2456">                       || gchar_cursor() == NUL)) {</a>
<a name="ln2457">      coladvance_force(getviscol());</a>
<a name="ln2458">    }</a>
<a name="ln2459">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2460">    pre_textlen = (long)strlen(firstline);</a>
<a name="ln2461">    pre_indent = (long)getwhitecols(firstline);</a>
<a name="ln2462">    bd.textcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2463">  }</a>
<a name="ln2464"> </a>
<a name="ln2465">  if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln2466">    fix_indent();</a>
<a name="ln2467">  }</a>
<a name="ln2468"> </a>
<a name="ln2469">  // Reset finish_op now, don't want it set inside edit().</a>
<a name="ln2470">  const bool save_finish_op = finish_op;</a>
<a name="ln2471">  finish_op = false;</a>
<a name="ln2472"> </a>
<a name="ln2473">  retval = edit(NUL, false, (linenr_T)1);</a>
<a name="ln2474"> </a>
<a name="ln2475">  finish_op = save_finish_op;</a>
<a name="ln2476"> </a>
<a name="ln2477">  // In Visual block mode, handle copying the new text to all lines of the</a>
<a name="ln2478">  // block.</a>
<a name="ln2479">  // Don't repeat the insert when Insert mode ended with CTRL-C.</a>
<a name="ln2480">  if (oap-&gt;motion_type == kMTBlockWise</a>
<a name="ln2481">      &amp;&amp; oap-&gt;start.lnum != oap-&gt;end.lnum &amp;&amp; !got_int) {</a>
<a name="ln2482">    long ins_len;</a>
<a name="ln2483">    // Auto-indenting may have changed the indent.  If the cursor was past</a>
<a name="ln2484">    // the indent, exclude that indent change from the inserted text.</a>
<a name="ln2485">    firstline = ml_get(oap-&gt;start.lnum);</a>
<a name="ln2486">    if (bd.textcol &gt; (colnr_T)pre_indent) {</a>
<a name="ln2487">      long new_indent = (long)getwhitecols(firstline);</a>
<a name="ln2488"> </a>
<a name="ln2489">      pre_textlen += new_indent - pre_indent;</a>
<a name="ln2490">      bd.textcol += (colnr_T)(new_indent - pre_indent);</a>
<a name="ln2491">    }</a>
<a name="ln2492"> </a>
<a name="ln2493">    ins_len = (long)strlen(firstline) - pre_textlen;</a>
<a name="ln2494">    if (ins_len &gt; 0) {</a>
<a name="ln2495">      long offset;</a>
<a name="ln2496">      char *newp;</a>
<a name="ln2497">      char *oldp;</a>
<a name="ln2498">      // Subsequent calls to ml_get() flush the firstline data - take a</a>
<a name="ln2499">      // copy of the inserted text.</a>
<a name="ln2500">      char *ins_text = xmalloc((size_t)(ins_len + 1));</a>
<a name="ln2501">      xstrlcpy(ins_text, firstline + bd.textcol, (size_t)ins_len + 1);</a>
<a name="ln2502">      for (linenr_T linenr = oap-&gt;start.lnum + 1; linenr &lt;= oap-&gt;end.lnum;</a>
<a name="ln2503">           linenr++) {</a>
<a name="ln2504">        block_prep(oap, &amp;bd, linenr, true);</a>
<a name="ln2505">        if (!bd.is_short || virtual_op) {</a>
<a name="ln2506">          pos_T vpos;</a>
<a name="ln2507"> </a>
<a name="ln2508">          // If the block starts in virtual space, count the</a>
<a name="ln2509">          // initial coladd offset as part of &quot;startspaces&quot;</a>
<a name="ln2510">          if (bd.is_short) {</a>
<a name="ln2511">            vpos.lnum = linenr;</a>
<a name="ln2512">            (void)getvpos(&amp;vpos, oap-&gt;start_vcol);</a>
<a name="ln2513">          } else {</a>
<a name="ln2514">            vpos.coladd = 0;</a>
<a name="ln2515">          }</a>
<a name="ln2516">          oldp = ml_get(linenr);</a>
<a name="ln2517">          newp = xmalloc(strlen(oldp) + (size_t)vpos.coladd</a>
<a name="ln2518">                         + (size_t)ins_len + 1);</a>
<a name="ln2519">          // copy up to block start</a>
<a name="ln2520">          memmove(newp, oldp, (size_t)bd.textcol);</a>
<a name="ln2521">          offset = bd.textcol;</a>
<a name="ln2522">          memset(newp + offset, ' ', (size_t)vpos.coladd);</a>
<a name="ln2523">          offset += vpos.coladd;</a>
<a name="ln2524">          memmove(newp + offset, ins_text, (size_t)ins_len);</a>
<a name="ln2525">          offset += ins_len;</a>
<a name="ln2526">          oldp += bd.textcol;</a>
<a name="ln2527">          STRMOVE(newp + offset, oldp);</a>
<a name="ln2528">          ml_replace(linenr, newp, false);</a>
<a name="ln2529">          extmark_splice_cols(curbuf, (int)linenr - 1, bd.textcol,</a>
<a name="ln2530">                              0, vpos.coladd + (int)ins_len, kExtmarkUndo);</a>
<a name="ln2531">        }</a>
<a name="ln2532">      }</a>
<a name="ln2533">      check_cursor();</a>
<a name="ln2534">      changed_lines(oap-&gt;start.lnum + 1, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln2535">      xfree(ins_text);</a>
<a name="ln2536">    }</a>
<a name="ln2537">  }</a>
<a name="ln2538">  auto_format(false, true);</a>
<a name="ln2539"> </a>
<a name="ln2540">  return retval;</a>
<a name="ln2541">}</a>
<a name="ln2542"> </a>
<a name="ln2543">#if defined(EXITFREE)</a>
<a name="ln2544">void clear_registers(void)</a>
<a name="ln2545">{</a>
<a name="ln2546">  int i;</a>
<a name="ln2547"> </a>
<a name="ln2548">  for (i = 0; i &lt; NUM_REGISTERS; i++) {</a>
<a name="ln2549">    free_register(&amp;y_regs[i]);</a>
<a name="ln2550">  }</a>
<a name="ln2551">}</a>
<a name="ln2552"> </a>
<a name="ln2553">#endif</a>
<a name="ln2554"> </a>
<a name="ln2555">/// Free contents of yankreg `reg`.</a>
<a name="ln2556">/// Called for normal freeing and in case of error.</a>
<a name="ln2557">///</a>
<a name="ln2558">/// @param reg  must not be NULL (but `reg-&gt;y_array` might be)</a>
<a name="ln2559">void free_register(yankreg_T *reg)</a>
<a name="ln2560">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2561">{</a>
<a name="ln2562">  set_yreg_additional_data(reg, NULL);</a>
<a name="ln2563">  if (reg-&gt;y_array == NULL) {</a>
<a name="ln2564">    return;</a>
<a name="ln2565">  }</a>
<a name="ln2566"> </a>
<a name="ln2567">  for (size_t i = reg-&gt;y_size; i-- &gt; 0;) {  // from y_size - 1 to 0 included</a>
<a name="ln2568">    xfree(reg-&gt;y_array[i]);</a>
<a name="ln2569">  }</a>
<a name="ln2570">  XFREE_CLEAR(reg-&gt;y_array);</a>
<a name="ln2571">}</a>
<a name="ln2572"> </a>
<a name="ln2573">/// Yanks the text between &quot;oap-&gt;start&quot; and &quot;oap-&gt;end&quot; into a yank register.</a>
<a name="ln2574">/// If we are to append (uppercase register), we first yank into a new yank</a>
<a name="ln2575">/// register and then concatenate the old and the new one.</a>
<a name="ln2576">/// Do not call this from a delete operation. Use op_yank_reg() instead.</a>
<a name="ln2577">///</a>
<a name="ln2578">/// @param oap operator arguments</a>
<a name="ln2579">/// @param message show message when more than `&amp;report` lines are yanked.</a>
<a name="ln2580">/// @returns whether the operation register was writable.</a>
<a name="ln2581">bool op_yank(oparg_T *oap, bool message)</a>
<a name="ln2582">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2583">{</a>
<a name="ln2584">  // check for read-only register</a>
<a name="ln2585">  if (oap-&gt;regname != 0 &amp;&amp; !valid_yank_reg(oap-&gt;regname, true)) {</a>
<a name="ln2586">    beep_flush();</a>
<a name="ln2587">    return false;</a>
<a name="ln2588">  }</a>
<a name="ln2589">  if (oap-&gt;regname == '_') {</a>
<a name="ln2590">    return true;  // black hole: nothing to do</a>
<a name="ln2591">  }</a>
<a name="ln2592"> </a>
<a name="ln2593">  yankreg_T *reg = get_yank_register(oap-&gt;regname, YREG_YANK);</a>
<a name="ln2594">  op_yank_reg(oap, message, reg, is_append_register(oap-&gt;regname));</a>
<a name="ln2595">  set_clipboard(oap-&gt;regname, reg);</a>
<a name="ln2596">  do_autocmd_textyankpost(oap, reg);</a>
<a name="ln2597"> </a>
<a name="ln2598">  return true;</a>
<a name="ln2599">}</a>
<a name="ln2600"> </a>
<a name="ln2601">static void op_yank_reg(oparg_T *oap, bool message, yankreg_T *reg, bool append)</a>
<a name="ln2602">{</a>
<a name="ln2603">  yankreg_T newreg;  // new yank register when appending</a>
<a name="ln2604">  char **new_ptr;</a>
<a name="ln2605">  linenr_T lnum;     // current line number</a>
<a name="ln2606">  MotionType yank_type = oap-&gt;motion_type;</a>
<a name="ln2607">  size_t yanklines = (size_t)oap-&gt;line_count;</a>
<a name="ln2608">  linenr_T yankendlnum = oap-&gt;end.lnum;</a>
<a name="ln2609">  char *p;</a>
<a name="ln2610">  char *pnew;</a>
<a name="ln2611">  struct block_def bd;</a>
<a name="ln2612"> </a>
<a name="ln2613">  yankreg_T *curr = reg;  // copy of current register</a>
<a name="ln2614">  // append to existing contents</a>
<a name="ln2615">  if (append &amp;&amp; reg-&gt;y_array != NULL) {</a>
<a name="ln2616">    reg = &amp;newreg;</a>
<a name="ln2617">  } else {</a>
<a name="ln2618">    free_register(reg);  // free previously yanked lines</a>
<a name="ln2619">  }</a>
<a name="ln2620"> </a>
<a name="ln2621">  // If the cursor was in column 1 before and after the movement, and the</a>
<a name="ln2622">  // operator is not inclusive, the yank is always linewise.</a>
<a name="ln2623">  if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln2624">      &amp;&amp; oap-&gt;start.col == 0</a>
<a name="ln2625">      &amp;&amp; !oap-&gt;inclusive</a>
<a name="ln2626">      &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln2627">      &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln2628">      &amp;&amp; yanklines &gt; 1) {</a>
<a name="ln2629">    yank_type = kMTLineWise;</a>
<a name="ln2630">    yankendlnum--;</a>
<a name="ln2631">    yanklines--;</a>
<a name="ln2632">  }</a>
<a name="ln2633"> </a>
<a name="ln2634">  reg-&gt;y_size = yanklines;</a>
<a name="ln2635">  reg-&gt;y_type = yank_type;  // set the yank register type</a>
<a name="ln2636">  reg-&gt;y_width = 0;</a>
<a name="ln2637">  reg-&gt;y_array = xcalloc(yanklines, sizeof(char *));</a>
<a name="ln2638">  reg-&gt;additional_data = NULL;</a>
<a name="ln2639">  reg-&gt;timestamp = os_time();</a>
<a name="ln2640"> </a>
<a name="ln2641">  size_t y_idx = 0;  // index in y_array[]</a>
<a name="ln2642">  lnum = oap-&gt;start.lnum;</a>
<a name="ln2643"> </a>
<a name="ln2644">  if (yank_type == kMTBlockWise) {</a>
<a name="ln2645">    // Visual block mode</a>
<a name="ln2646">    reg-&gt;y_width = oap-&gt;end_vcol - oap-&gt;start_vcol;</a>
<a name="ln2647"> </a>
<a name="ln2648">    if (curwin-&gt;w_curswant == MAXCOL &amp;&amp; reg-&gt;y_width &gt; 0) {</a>
<a name="ln2649">      reg-&gt;y_width--;</a>
<a name="ln2650">    }</a>
<a name="ln2651">  }</a>
<a name="ln2652"> </a>
<a name="ln2653">  for (; lnum &lt;= yankendlnum; lnum++, y_idx++) {</a>
<a name="ln2654">    switch (reg-&gt;y_type) {</a>
<a name="ln2655">    case kMTBlockWise:</a>
<a name="ln2656">      block_prep(oap, &amp;bd, lnum, false);</a>
<a name="ln2657">      yank_copy_line(reg, &amp;bd, y_idx, oap-&gt;excl_tr_ws);</a>
<a name="ln2658">      break;</a>
<a name="ln2659"> </a>
<a name="ln2660">    case kMTLineWise:</a>
<a name="ln2661">      reg-&gt;y_array[y_idx] = xstrdup(ml_get(lnum));</a>
<a name="ln2662">      break;</a>
<a name="ln2663"> </a>
<a name="ln2664">    case kMTCharWise: {</a>
<a name="ln2665">      colnr_T startcol = 0, endcol = MAXCOL;</a>
<a name="ln2666">      int is_oneChar = false;</a>
<a name="ln2667">      colnr_T cs, ce;</a>
<a name="ln2668">      p = ml_get(lnum);</a>
<a name="ln2669">      bd.startspaces = 0;</a>
<a name="ln2670">      bd.endspaces = 0;</a>
<a name="ln2671"> </a>
<a name="ln2672">      if (lnum == oap-&gt;start.lnum) {</a>
<a name="ln2673">        startcol = oap-&gt;start.col;</a>
<a name="ln2674">        if (virtual_op) {</a>
<a name="ln2675">          getvcol(curwin, &amp;oap-&gt;start, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2676">          if (ce != cs &amp;&amp; oap-&gt;start.coladd &gt; 0) {</a>
<a name="ln2677">            // Part of a tab selected -- but don't double-count it.</a>
<a name="ln2678">            bd.startspaces = (ce - cs + 1) - oap-&gt;start.coladd;</a>
<a name="ln2679">            if (bd.startspaces &lt; 0) {</a>
<a name="ln2680">              bd.startspaces = 0;</a>
<a name="ln2681">            }</a>
<a name="ln2682">            startcol++;</a>
<a name="ln2683">          }</a>
<a name="ln2684">        }</a>
<a name="ln2685">      }</a>
<a name="ln2686"> </a>
<a name="ln2687">      if (lnum == oap-&gt;end.lnum) {</a>
<a name="ln2688">        endcol = oap-&gt;end.col;</a>
<a name="ln2689">        if (virtual_op) {</a>
<a name="ln2690">          getvcol(curwin, &amp;oap-&gt;end, &amp;cs, NULL, &amp;ce);</a>
<a name="ln2691">          if (p[endcol] == NUL || (cs + oap-&gt;end.coladd &lt; ce</a>
<a name="ln2692">                                   // Don't add space for double-wide</a>
<a name="ln2693">                                   // char; endcol will be on last byte</a>
<a name="ln2694">                                   // of multi-byte char.</a>
<a name="ln2695">                                   &amp;&amp; utf_head_off(p, p + endcol) == 0)) {</a>
<a name="ln2696">            if (oap-&gt;start.lnum == oap-&gt;end.lnum</a>
<a name="ln2697">                &amp;&amp; oap-&gt;start.col == oap-&gt;end.col) {</a>
<a name="ln2698">              // Special case: inside a single char</a>
<a name="ln2699">              is_oneChar = true;</a>
<a name="ln2700">              bd.startspaces = oap-&gt;end.coladd</a>
<a name="ln2701">                               - oap-&gt;start.coladd + oap-&gt;inclusive;</a>
<a name="ln2702">              endcol = startcol;</a>
<a name="ln2703">            } else {</a>
<a name="ln2704">              bd.endspaces = oap-&gt;end.coladd</a>
<a name="ln2705">                             + oap-&gt;inclusive;</a>
<a name="ln2706">              endcol -= oap-&gt;inclusive;</a>
<a name="ln2707">            }</a>
<a name="ln2708">          }</a>
<a name="ln2709">        }</a>
<a name="ln2710">      }</a>
<a name="ln2711">      if (endcol == MAXCOL) {</a>
<a name="ln2712">        endcol = (colnr_T)strlen(p);</a>
<a name="ln2713">      }</a>
<a name="ln2714">      if (startcol &gt; endcol</a>
<a name="ln2715">          || is_oneChar) {</a>
<a name="ln2716">        bd.textlen = 0;</a>
<a name="ln2717">      } else {</a>
<a name="ln2718">        bd.textlen = endcol - startcol + oap-&gt;inclusive;</a>
<a name="ln2719">      }</a>
<a name="ln2720">      bd.textstart = p + startcol;</a>
<a name="ln2721">      yank_copy_line(reg, &amp;bd, y_idx, false);</a>
<a name="ln2722">      break;</a>
<a name="ln2723">    }</a>
<a name="ln2724">    // NOTREACHED</a>
<a name="ln2725">    case kMTUnknown:</a>
<a name="ln2726">      abort();</a>
<a name="ln2727">    }</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  if (curr != reg) {      // append the new block to the old block</a>
<a name="ln2731">    size_t j;</a>
<a name="ln2732">    new_ptr = xmalloc(sizeof(char *) * (curr-&gt;y_size + reg-&gt;y_size));</a>
<a name="ln2733">    for (j = 0; j &lt; curr-&gt;y_size; j++) {</a>
<a name="ln2734">      new_ptr[j] = curr-&gt;y_array[j];</a>
<a name="ln2735">    }</a>
<a name="ln2736">    xfree(curr-&gt;y_array);</a>
<a name="ln2737">    curr-&gt;y_array = new_ptr;</a>
<a name="ln2738"> </a>
<a name="ln2739">    if (yank_type == kMTLineWise) {</a>
<a name="ln2740">      // kMTLineWise overrides kMTCharWise and kMTBlockWise</a>
<a name="ln2741">      curr-&gt;y_type = kMTLineWise;</a>
<a name="ln2742">    }</a>
<a name="ln2743"> </a>
<a name="ln2744">    // Concatenate the last line of the old block with the first line of</a>
<a name="ln2745">    // the new block, unless being Vi compatible.</a>
<a name="ln2746">    if (curr-&gt;y_type == kMTCharWise</a>
<a name="ln2747">        &amp;&amp; vim_strchr(p_cpo, CPO_REGAPPEND) == NULL) {</a>
<a name="ln2748">      pnew = xmalloc(strlen(curr-&gt;y_array[curr-&gt;y_size - 1])</a>
<a name="ln2749">                     + strlen(reg-&gt;y_array[0]) + 1);</a>
<a name="ln2750">      STRCPY(pnew, curr-&gt;y_array[--j]);</a>
<a name="ln2751">      STRCAT(pnew, reg-&gt;y_array[0]);</a>
<a name="ln2752">      xfree(curr-&gt;y_array[j]);</a>
<a name="ln2753">      xfree(reg-&gt;y_array[0]);</a>
<a name="ln2754">      curr-&gt;y_array[j++] = pnew;</a>
<a name="ln2755">      y_idx = 1;</a>
<a name="ln2756">    } else {</a>
<a name="ln2757">      y_idx = 0;</a>
<a name="ln2758">    }</a>
<a name="ln2759">    while (y_idx &lt; reg-&gt;y_size) {</a>
<a name="ln2760">      curr-&gt;y_array[j++] = reg-&gt;y_array[y_idx++];</a>
<a name="ln2761">    }</a>
<a name="ln2762">    curr-&gt;y_size = j;</a>
<a name="ln2763">    xfree(reg-&gt;y_array);</a>
<a name="ln2764">  }</a>
<a name="ln2765"> </a>
<a name="ln2766">  if (message) {  // Display message about yank?</a>
<a name="ln2767">    if (yank_type == kMTCharWise &amp;&amp; yanklines == 1) {</a>
<a name="ln2768">      yanklines = 0;</a>
<a name="ln2769">    }</a>
<a name="ln2770">    // Some versions of Vi use &quot;&gt;=&quot; here, some don't...</a>
<a name="ln2771">    if (yanklines &gt; (size_t)p_report) {</a>
<a name="ln2772">      char namebuf[100];</a>
<a name="ln2773"> </a>
<a name="ln2774">      if (oap-&gt;regname == NUL) {</a>
<a name="ln2775">        *namebuf = NUL;</a>
<a name="ln2776">      } else {</a>
<a name="ln2777">        vim_snprintf(namebuf, sizeof(namebuf), _(&quot; into \&quot;%c&quot;), oap-&gt;regname);</a>
<a name="ln2778">      }</a>
<a name="ln2779"> </a>
<a name="ln2780">      // redisplay now, so message is not deleted</a>
<a name="ln2781">      update_topline(curwin);</a>
<a name="ln2782">      if (must_redraw) {</a>
<a name="ln2783">        update_screen();</a>
<a name="ln2784">      }</a>
<a name="ln2785">      if (yank_type == kMTBlockWise) {</a>
<a name="ln2786">        smsg(NGETTEXT(&quot;block of %&quot; PRId64 &quot; line yanked%s&quot;,</a>
<a name="ln2787">                      &quot;block of %&quot; PRId64 &quot; lines yanked%s&quot;, yanklines),</a>
<a name="ln2788">             (int64_t)yanklines, namebuf);</a>
<a name="ln2789">      } else {</a>
<a name="ln2790">        smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line yanked%s&quot;,</a>
<a name="ln2791">                      &quot;%&quot; PRId64 &quot; lines yanked%s&quot;, yanklines),</a>
<a name="ln2792">             (int64_t)yanklines, namebuf);</a>
<a name="ln2793">      }</a>
<a name="ln2794">    }</a>
<a name="ln2795">  }</a>
<a name="ln2796"> </a>
<a name="ln2797">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2798">    // Set &quot;'[&quot; and &quot;']&quot; marks.</a>
<a name="ln2799">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln2800">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln2801">    if (yank_type == kMTLineWise) {</a>
<a name="ln2802">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln2803">      curbuf-&gt;b_op_end.col = MAXCOL;</a>
<a name="ln2804">    }</a>
<a name="ln2805">  }</a>
<a name="ln2806">}</a>
<a name="ln2807"> </a>
<a name="ln2808">/// Copy a block range into a register.</a>
<a name="ln2809">///</a>
<a name="ln2810">/// @param exclude_trailing_space  if true, do not copy trailing whitespaces.</a>
<a name="ln2811">static void yank_copy_line(yankreg_T *reg, struct block_def *bd, size_t y_idx,</a>
<a name="ln2812">                           bool exclude_trailing_space)</a>
<a name="ln2813">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2814">{</a>
<a name="ln2815">  if (exclude_trailing_space) {</a>
<a name="ln2816">    bd-&gt;endspaces = 0;</a>
<a name="ln2817">  }</a>
<a name="ln2818">  int size = bd-&gt;startspaces + bd-&gt;endspaces + bd-&gt;textlen;</a>
<a name="ln2819">  assert(size &gt;= 0);</a>
<a name="ln2820">  char *pnew = xmallocz((size_t)size);</a>
<a name="ln2821">  reg-&gt;y_array[y_idx] = pnew;</a>
<a name="ln2822">  memset(pnew, ' ', (size_t)bd-&gt;startspaces);</a>
<a name="ln2823">  pnew += bd-&gt;startspaces;</a>
<a name="ln2824">  memmove(pnew, bd-&gt;textstart, (size_t)bd-&gt;textlen);</a>
<a name="ln2825">  pnew += bd-&gt;textlen;</a>
<a name="ln2826">  memset(pnew, ' ', (size_t)bd-&gt;endspaces);</a>
<a name="ln2827">  pnew += bd-&gt;endspaces;</a>
<a name="ln2828">  if (exclude_trailing_space) {</a>
<a name="ln2829">    int s = bd-&gt;textlen + bd-&gt;endspaces;</a>
<a name="ln2830"> </a>
<a name="ln2831">    while (s &gt; 0 &amp;&amp; ascii_iswhite(*(bd-&gt;textstart + s - 1))) {</a>
<a name="ln2832">      s = s - utf_head_off(bd-&gt;textstart, bd-&gt;textstart + s - 1) - 1;</a>
<a name="ln2833">      pnew--;</a>
<a name="ln2834">    }</a>
<a name="ln2835">  }</a>
<a name="ln2836">  *pnew = NUL;</a>
<a name="ln2837">}</a>
<a name="ln2838"> </a>
<a name="ln2839">/// Execute autocommands for TextYankPost.</a>
<a name="ln2840">///</a>
<a name="ln2841">/// @param oap Operator arguments.</a>
<a name="ln2842">/// @param reg The yank register used.</a>
<a name="ln2843">static void do_autocmd_textyankpost(oparg_T *oap, yankreg_T *reg)</a>
<a name="ln2844">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2845">{</a>
<a name="ln2846">  static bool recursive = false;</a>
<a name="ln2847"> </a>
<a name="ln2848">  if (recursive || !has_event(EVENT_TEXTYANKPOST)) {</a>
<a name="ln2849">    // No autocommand was defined, or we yanked from this autocommand.</a>
<a name="ln2850">    return;</a>
<a name="ln2851">  }</a>
<a name="ln2852"> </a>
<a name="ln2853">  recursive = true;</a>
<a name="ln2854"> </a>
<a name="ln2855">  save_v_event_T save_v_event;</a>
<a name="ln2856">  // Set the v:event dictionary with information about the yank.</a>
<a name="ln2857">  dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln2858"> </a>
<a name="ln2859">  // The yanked text contents.</a>
<a name="ln2860">  list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln2861">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln2862">    tv_list_append_string(list, reg-&gt;y_array[i], -1);</a>
<a name="ln2863">  }</a>
<a name="ln2864">  tv_list_set_lock(list, VAR_FIXED);</a>
<a name="ln2865">  (void)tv_dict_add_list(dict, S_LEN(&quot;regcontents&quot;), list);</a>
<a name="ln2866"> </a>
<a name="ln2867">  // Register type.</a>
<a name="ln2868">  char buf[NUMBUFLEN + 2];</a>
<a name="ln2869">  format_reg_type(reg-&gt;y_type, reg-&gt;y_width, buf, ARRAY_SIZE(buf));</a>
<a name="ln2870">  (void)tv_dict_add_str(dict, S_LEN(&quot;regtype&quot;), buf);</a>
<a name="ln2871"> </a>
<a name="ln2872">  // Name of requested register, or empty string for unnamed operation.</a>
<a name="ln2873">  buf[0] = (char)oap-&gt;regname;</a>
<a name="ln2874">  buf[1] = NUL;</a>
<a name="ln2875">  (void)tv_dict_add_str(dict, S_LEN(&quot;regname&quot;), buf);</a>
<a name="ln2876"> </a>
<a name="ln2877">  // Motion type: inclusive or exclusive.</a>
<a name="ln2878">  tv_dict_add_bool(dict, S_LEN(&quot;inclusive&quot;),</a>
<a name="ln2879">                   oap-&gt;inclusive ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2880"> </a>
<a name="ln2881">  // Kind of operation: yank, delete, change).</a>
<a name="ln2882">  buf[0] = (char)get_op_char(oap-&gt;op_type);</a>
<a name="ln2883">  buf[1] = NUL;</a>
<a name="ln2884">  (void)tv_dict_add_str(dict, S_LEN(&quot;operator&quot;), buf);</a>
<a name="ln2885"> </a>
<a name="ln2886">  // Selection type: visual or not.</a>
<a name="ln2887">  (void)tv_dict_add_bool(dict, S_LEN(&quot;visual&quot;),</a>
<a name="ln2888">                         oap-&gt;is_VIsual ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln2889"> </a>
<a name="ln2890">  tv_dict_set_keys_readonly(dict);</a>
<a name="ln2891">  textlock++;</a>
<a name="ln2892">  apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, false, curbuf);</a>
<a name="ln2893">  textlock--;</a>
<a name="ln2894">  restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln2895"> </a>
<a name="ln2896">  recursive = false;</a>
<a name="ln2897">}</a>
<a name="ln2898"> </a>
<a name="ln2899">/// Put contents of register &quot;regname&quot; into the text.</a>
<a name="ln2900">/// Caller must check &quot;regname&quot; to be valid!</a>
<a name="ln2901">///</a>
<a name="ln2902">/// @param flags  PUT_FIXINDENT     make indent look nice</a>
<a name="ln2903">///               PUT_CURSEND       leave cursor after end of new text</a>
<a name="ln2904">///               PUT_LINE          force linewise put (&quot;:put&quot;)</a>
<a name="ln2905">///               PUT_BLOCK_INNER   in block mode, do not add trailing spaces</a>
<a name="ln2906">/// @param dir    BACKWARD for 'P', FORWARD for 'p'</a>
<a name="ln2907">void do_put(int regname, yankreg_T *reg, int dir, long count, int flags)</a>
<a name="ln2908">{</a>
<a name="ln2909">  char *ptr;</a>
<a name="ln2910">  char *newp;</a>
<a name="ln2911">  char *oldp;</a>
<a name="ln2912">  int yanklen;</a>
<a name="ln2913">  size_t totlen = 0;  // init for gcc</a>
<a name="ln2914">  linenr_T lnum = 0;</a>
<a name="ln2915">  colnr_T col = 0;</a>
<a name="ln2916">  size_t i;  // index in y_array[]</a>
<a name="ln2917">  MotionType y_type;</a>
<a name="ln2918">  size_t y_size;</a>
<a name="ln2919">  size_t oldlen;</a>
<a name="ln2920">  int y_width = 0;</a>
<a name="ln2921">  colnr_T vcol = 0;</a>
<a name="ln2922">  int delcount;</a>
<a name="ln2923">  int incr = 0;</a>
<a name="ln2924">  struct block_def bd;</a>
<a name="ln2925">  char **y_array = NULL;</a>
<a name="ln2926">  linenr_T nr_lines = 0;</a>
<a name="ln2927">  pos_T new_cursor;</a>
<a name="ln2928">  int indent;</a>
<a name="ln2929">  int orig_indent = 0;                  // init for gcc</a>
<a name="ln2930">  int indent_diff = 0;                  // init for gcc</a>
<a name="ln2931">  bool first_indent = true;</a>
<a name="ln2932">  int lendiff = 0;</a>
<a name="ln2933">  pos_T old_pos;</a>
<a name="ln2934">  char *insert_string = NULL;</a>
<a name="ln2935">  bool allocated = false;</a>
<a name="ln2936">  long cnt;</a>
<a name="ln2937">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln2938">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln2939">  unsigned cur_ve_flags = get_ve_flags();</a>
<a name="ln2940"> </a>
<a name="ln2941">  if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln2942">    orig_indent = get_indent();</a>
<a name="ln2943">  }</a>
<a name="ln2944"> </a>
<a name="ln2945">  curbuf-&gt;b_op_start = curwin-&gt;w_cursor;        // default for '[ mark</a>
<a name="ln2946">  curbuf-&gt;b_op_end = curwin-&gt;w_cursor;          // default for '] mark</a>
<a name="ln2947"> </a>
<a name="ln2948">  // Using inserted text works differently, because the register includes</a>
<a name="ln2949">  // special characters (newlines, etc.).</a>
<a name="ln2950">  if (regname == '.' &amp;&amp; !reg) {</a>
<a name="ln2951">    bool non_linewise_vis = (VIsual_active &amp;&amp; VIsual_mode != 'V');</a>
<a name="ln2952"> </a>
<a name="ln2953">    // PUT_LINE has special handling below which means we use 'i' to start.</a>
<a name="ln2954">    char command_start_char = non_linewise_vis ? 'c' :</a>
<a name="ln2955">                              (flags &amp; PUT_LINE ? 'i' : (dir == FORWARD ? 'a' : 'i'));</a>
<a name="ln2956"> </a>
<a name="ln2957">    // To avoid 'autoindent' on linewise puts, create a new line with `:put _`.</a>
<a name="ln2958">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2959">      do_put('_', NULL, dir, 1, PUT_LINE);</a>
<a name="ln2960">    }</a>
<a name="ln2961"> </a>
<a name="ln2962">    // If given a count when putting linewise, we stuff the readbuf with the</a>
<a name="ln2963">    // dot register 'count' times split by newlines.</a>
<a name="ln2964">    if (flags &amp; PUT_LINE) {</a>
<a name="ln2965">      stuffcharReadbuff(command_start_char);</a>
<a name="ln2966">      for (; count &gt; 0; count--) {</a>
<a name="ln2967">        (void)stuff_inserted(NUL, 1, count != 1);</a>
<a name="ln2968">        if (count != 1) {</a>
<a name="ln2969">          // To avoid 'autoindent' affecting the text, use Ctrl_U to remove any</a>
<a name="ln2970">          // whitespace. Can't just insert Ctrl_U into readbuf1, this would go</a>
<a name="ln2971">          // back to the previous line in the case of 'noautoindent' and</a>
<a name="ln2972">          // 'backspace' includes &quot;eol&quot;. So we insert a dummy space for Ctrl_U</a>
<a name="ln2973">          // to consume.</a>
<a name="ln2974">          stuffReadbuff(&quot;\n &quot;);</a>
<a name="ln2975">          stuffcharReadbuff(Ctrl_U);</a>
<a name="ln2976">        }</a>
<a name="ln2977">      }</a>
<a name="ln2978">    } else {</a>
<a name="ln2979">      (void)stuff_inserted(command_start_char, count, false);</a>
<a name="ln2980">    }</a>
<a name="ln2981"> </a>
<a name="ln2982">    // Putting the text is done later, so can't move the cursor to the next</a>
<a name="ln2983">    // character.  Simulate it with motion commands after the insert.</a>
<a name="ln2984">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln2985">      if (flags &amp; PUT_LINE) {</a>
<a name="ln2986">        stuffReadbuff(&quot;j0&quot;);</a>
<a name="ln2987">      } else {</a>
<a name="ln2988">        // Avoid ringing the bell from attempting to move into the space after</a>
<a name="ln2989">        // the current line. We can stuff the readbuffer with &quot;l&quot; if:</a>
<a name="ln2990">        // 1) 'virtualedit' is &quot;all&quot; or &quot;onemore&quot;</a>
<a name="ln2991">        // 2) We are not at the end of the line</a>
<a name="ln2992">        // 3) We are not  (one past the end of the line &amp;&amp; on the last line)</a>
<a name="ln2993">        //    This allows a visual put over a selection one past the end of the</a>
<a name="ln2994">        //    line joining the current line with the one below.</a>
<a name="ln2995"> </a>
<a name="ln2996">        // curwin-&gt;w_cursor.col marks the byte position of the cursor in the</a>
<a name="ln2997">        // currunt line. It increases up to a max of</a>
<a name="ln2998">        // strlen(ml_get(curwin-&gt;w_cursor.lnum)). With 'virtualedit' and the</a>
<a name="ln2999">        // cursor past the end of the line, curwin-&gt;w_cursor.coladd is</a>
<a name="ln3000">        // incremented instead of curwin-&gt;w_cursor.col.</a>
<a name="ln3001">        char *cursor_pos = get_cursor_pos_ptr();</a>
<a name="ln3002">        bool one_past_line = (*cursor_pos == NUL);</a>
<a name="ln3003">        bool eol = false;</a>
<a name="ln3004">        if (!one_past_line) {</a>
<a name="ln3005">          eol = (*(cursor_pos + utfc_ptr2len(cursor_pos)) == NUL);</a>
<a name="ln3006">        }</a>
<a name="ln3007"> </a>
<a name="ln3008">        bool ve_allows = (cur_ve_flags == VE_ALL || cur_ve_flags == VE_ONEMORE);</a>
<a name="ln3009">        bool eof = curbuf-&gt;b_ml.ml_line_count == curwin-&gt;w_cursor.lnum</a>
<a name="ln3010">                   &amp;&amp; one_past_line;</a>
<a name="ln3011">        if (ve_allows || !(eol || eof)) {</a>
<a name="ln3012">          stuffcharReadbuff('l');</a>
<a name="ln3013">        }</a>
<a name="ln3014">      }</a>
<a name="ln3015">    } else if (flags &amp; PUT_LINE) {</a>
<a name="ln3016">      stuffReadbuff(&quot;g'[&quot;);</a>
<a name="ln3017">    }</a>
<a name="ln3018"> </a>
<a name="ln3019">    // So the 'u' command restores cursor position after &quot;.p, save the cursor</a>
<a name="ln3020">    // position now (though not saving any text).</a>
<a name="ln3021">    if (command_start_char == 'a') {</a>
<a name="ln3022">      if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln3023">        return;</a>
<a name="ln3024">      }</a>
<a name="ln3025">    }</a>
<a name="ln3026">    return;</a>
<a name="ln3027">  }</a>
<a name="ln3028"> </a>
<a name="ln3029">  // For special registers '%' (file name), '#' (alternate file name) and</a>
<a name="ln3030">  // ':' (last command line), etc. we have to create a fake yank register.</a>
<a name="ln3031">  if (!reg &amp;&amp; get_spec_reg(regname, &amp;insert_string, &amp;allocated, true)) {</a>
<a name="ln3032">    if (insert_string == NULL) {</a>
<a name="ln3033">      return;</a>
<a name="ln3034">    }</a>
<a name="ln3035">  }</a>
<a name="ln3036"> </a>
<a name="ln3037">  if (!curbuf-&gt;terminal) {</a>
<a name="ln3038">    // Autocommands may be executed when saving lines for undo.  This might</a>
<a name="ln3039">    // make y_array invalid, so we start undo now to avoid that.</a>
<a name="ln3040">    if (u_save(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.lnum + 1) == FAIL) {</a>
<a name="ln3041">      return;</a>
<a name="ln3042">    }</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  if (insert_string != NULL) {</a>
<a name="ln3046">    y_type = kMTCharWise;</a>
<a name="ln3047">    if (regname == '=') {</a>
<a name="ln3048">      // For the = register we need to split the string at NL</a>
<a name="ln3049">      // characters.</a>
<a name="ln3050">      // Loop twice: count the number of lines and save them.</a>
<a name="ln3051">      while (true) {</a>
<a name="ln3052">        y_size = 0;</a>
<a name="ln3053">        ptr = insert_string;</a>
<a name="ln3054">        while (ptr != NULL) {</a>
<a name="ln3055">          if (y_array != NULL) {</a>
<a name="ln3056">            y_array[y_size] = ptr;</a>
<a name="ln3057">          }</a>
<a name="ln3058">          y_size++;</a>
<a name="ln3059">          ptr = vim_strchr(ptr, '\n');</a>
<a name="ln3060">          if (ptr != NULL) {</a>
<a name="ln3061">            if (y_array != NULL) {</a>
<a name="ln3062">              *ptr = NUL;</a>
<a name="ln3063">            }</a>
<a name="ln3064">            ptr++;</a>
<a name="ln3065">            // A trailing '\n' makes the register linewise.</a>
<a name="ln3066">            if (*ptr == NUL) {</a>
<a name="ln3067">              y_type = kMTLineWise;</a>
<a name="ln3068">              break;</a>
<a name="ln3069">            }</a>
<a name="ln3070">          }</a>
<a name="ln3071">        }</a>
<a name="ln3072">        if (y_array != NULL) {</a>
<a name="ln3073">          break;</a>
<a name="ln3074">        }</a>
<a name="ln3075">        y_array = xmalloc(y_size * sizeof(char *));</a>
<a name="ln3076">      }</a>
<a name="ln3077">    } else {</a>
<a name="ln3078">      y_size = 1;               // use fake one-line yank register</a>
<a name="ln3079">      y_array = &amp;insert_string;</a>
<a name="ln3080">    }</a>
<a name="ln3081">  } else {</a>
<a name="ln3082">    // in case of replacing visually selected text</a>
<a name="ln3083">    // the yankreg might already have been saved to avoid</a>
<a name="ln3084">    // just restoring the deleted text.</a>
<a name="ln3085">    if (reg == NULL) {</a>
<a name="ln3086">      reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln3087">    }</a>
<a name="ln3088"> </a>
<a name="ln3089">    y_type = reg-&gt;y_type;</a>
<a name="ln3090">    y_width = reg-&gt;y_width;</a>
<a name="ln3091">    y_size = reg-&gt;y_size;</a>
<a name="ln3092">    y_array = reg-&gt;y_array;</a>
<a name="ln3093">  }</a>
<a name="ln3094"> </a>
<a name="ln3095">  if (curbuf-&gt;terminal) {</a>
<a name="ln3096">    terminal_paste(count, y_array, y_size);</a>
<a name="ln3097">    return;</a>
<a name="ln3098">  }</a>
<a name="ln3099"> </a>
<a name="ln3100">  if (y_type == kMTLineWise) {</a>
<a name="ln3101">    if (flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3102">      // &quot;p&quot; or &quot;P&quot; in Visual mode: split the lines to put the text in</a>
<a name="ln3103">      // between.</a>
<a name="ln3104">      if (u_save_cursor() == FAIL) {</a>
<a name="ln3105">        goto end;</a>
<a name="ln3106">      }</a>
<a name="ln3107">      char *p = get_cursor_pos_ptr();</a>
<a name="ln3108">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3109">        MB_PTR_ADV(p);</a>
<a name="ln3110">      }</a>
<a name="ln3111">      ptr = xstrdup(p);</a>
<a name="ln3112">      ml_append(curwin-&gt;w_cursor.lnum, ptr, (colnr_T)0, false);</a>
<a name="ln3113">      xfree(ptr);</a>
<a name="ln3114"> </a>
<a name="ln3115">      oldp = get_cursor_line_ptr();</a>
<a name="ln3116">      p = oldp + curwin-&gt;w_cursor.col;</a>
<a name="ln3117">      if (dir == FORWARD &amp;&amp; *p != NUL) {</a>
<a name="ln3118">        MB_PTR_ADV(p);</a>
<a name="ln3119">      }</a>
<a name="ln3120">      ptr = xstrnsave(oldp, (size_t)(p - oldp));</a>
<a name="ln3121">      ml_replace(curwin-&gt;w_cursor.lnum, ptr, false);</a>
<a name="ln3122">      nr_lines++;</a>
<a name="ln3123">      dir = FORWARD;</a>
<a name="ln3124">    }</a>
<a name="ln3125">    if (flags &amp; PUT_LINE_FORWARD) {</a>
<a name="ln3126">      // Must be &quot;p&quot; for a Visual block, put lines below the block.</a>
<a name="ln3127">      curwin-&gt;w_cursor = curbuf-&gt;b_visual.vi_end;</a>
<a name="ln3128">      dir = FORWARD;</a>
<a name="ln3129">    }</a>
<a name="ln3130">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // default for '[ mark</a>
<a name="ln3131">    curbuf-&gt;b_op_end = curwin-&gt;w_cursor;        // default for '] mark</a>
<a name="ln3132">  }</a>
<a name="ln3133"> </a>
<a name="ln3134">  if (flags &amp; PUT_LINE) {  // :put command or &quot;p&quot; in Visual line mode.</a>
<a name="ln3135">    y_type = kMTLineWise;</a>
<a name="ln3136">  }</a>
<a name="ln3137"> </a>
<a name="ln3138">  if (y_size == 0 || y_array == NULL) {</a>
<a name="ln3139">    semsg(_(&quot;E353: Nothing in register %s&quot;),</a>
<a name="ln3140">          regname == 0 ? &quot;\&quot;&quot; : transchar(regname));</a>
<a name="ln3141">    goto end;</a>
<a name="ln3142">  }</a>
<a name="ln3143"> </a>
<a name="ln3144">  if (y_type == kMTBlockWise) {</a>
<a name="ln3145">    lnum = curwin-&gt;w_cursor.lnum + (linenr_T)y_size + 1;</a>
<a name="ln3146">    if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3147">      lnum = curbuf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln3148">    }</a>
<a name="ln3149">    if (u_save(curwin-&gt;w_cursor.lnum - 1, lnum) == FAIL) {</a>
<a name="ln3150">      goto end;</a>
<a name="ln3151">    }</a>
<a name="ln3152">  } else if (y_type == kMTLineWise) {</a>
<a name="ln3153">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3154">    // Correct line number for closed fold.  Don't move the cursor yet,</a>
<a name="ln3155">    // u_save() uses it.</a>
<a name="ln3156">    if (dir == BACKWARD) {</a>
<a name="ln3157">      (void)hasFolding(lnum, &amp;lnum, NULL);</a>
<a name="ln3158">    } else {</a>
<a name="ln3159">      (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3160">    }</a>
<a name="ln3161">    if (dir == FORWARD) {</a>
<a name="ln3162">      lnum++;</a>
<a name="ln3163">    }</a>
<a name="ln3164">    // In an empty buffer the empty line is going to be replaced, include</a>
<a name="ln3165">    // it in the saved lines.</a>
<a name="ln3166">    if ((buf_is_empty(curbuf) ?</a>
<a name="ln3167">         u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL) {</a>
<a name="ln3168">      goto end;</a>
<a name="ln3169">    }</a>
<a name="ln3170">    if (dir == FORWARD) {</a>
<a name="ln3171">      curwin-&gt;w_cursor.lnum = lnum - 1;</a>
<a name="ln3172">    } else {</a>
<a name="ln3173">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3174">    }</a>
<a name="ln3175">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;      // for mark_adjust()</a>
<a name="ln3176">  } else if (u_save_cursor() == FAIL) {</a>
<a name="ln3177">    goto end;</a>
<a name="ln3178">  }</a>
<a name="ln3179"> </a>
<a name="ln3180">  yanklen = (int)strlen(y_array[0]);</a>
<a name="ln3181"> </a>
<a name="ln3182">  if (cur_ve_flags == VE_ALL &amp;&amp; y_type == kMTCharWise) {</a>
<a name="ln3183">    if (gchar_cursor() == TAB) {</a>
<a name="ln3184">      int viscol = getviscol();</a>
<a name="ln3185">      long ts = curbuf-&gt;b_p_ts;</a>
<a name="ln3186">      // Don't need to insert spaces when &quot;p&quot; on the last position of a</a>
<a name="ln3187">      // tab or &quot;P&quot; on the first position.</a>
<a name="ln3188">      if (dir == FORWARD</a>
<a name="ln3189">          ? tabstop_padding(viscol, ts, curbuf-&gt;b_p_vts_array) != 1</a>
<a name="ln3190">          : curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3191">        coladvance_force(viscol);</a>
<a name="ln3192">      } else {</a>
<a name="ln3193">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3194">      }</a>
<a name="ln3195">    } else if (curwin-&gt;w_cursor.coladd &gt; 0 || gchar_cursor() == NUL) {</a>
<a name="ln3196">      coladvance_force(getviscol() + (dir == FORWARD));</a>
<a name="ln3197">    }</a>
<a name="ln3198">  }</a>
<a name="ln3199"> </a>
<a name="ln3200">  lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3201">  col = curwin-&gt;w_cursor.col;</a>
<a name="ln3202"> </a>
<a name="ln3203">  // Block mode</a>
<a name="ln3204">  if (y_type == kMTBlockWise) {</a>
<a name="ln3205">    int c = gchar_cursor();</a>
<a name="ln3206">    colnr_T endcol2 = 0;</a>
<a name="ln3207"> </a>
<a name="ln3208">    if (dir == FORWARD &amp;&amp; c != NUL) {</a>
<a name="ln3209">      if (cur_ve_flags == VE_ALL) {</a>
<a name="ln3210">        getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3211">      } else {</a>
<a name="ln3212">        getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;col);</a>
<a name="ln3213">      }</a>
<a name="ln3214"> </a>
<a name="ln3215">      // move to start of next multi-byte character</a>
<a name="ln3216">      curwin-&gt;w_cursor.col += utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3217">      col++;</a>
<a name="ln3218">    } else {</a>
<a name="ln3219">      getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;col, NULL, &amp;endcol2);</a>
<a name="ln3220">    }</a>
<a name="ln3221"> </a>
<a name="ln3222">    col += curwin-&gt;w_cursor.coladd;</a>
<a name="ln3223">    if (cur_ve_flags == VE_ALL</a>
<a name="ln3224">        &amp;&amp; (curwin-&gt;w_cursor.coladd &gt; 0 || endcol2 == curwin-&gt;w_cursor.col)) {</a>
<a name="ln3225">      if (dir == FORWARD &amp;&amp; c == NUL) {</a>
<a name="ln3226">        col++;</a>
<a name="ln3227">      }</a>
<a name="ln3228">      if (dir != FORWARD &amp;&amp; c != NUL &amp;&amp; curwin-&gt;w_cursor.coladd &gt; 0) {</a>
<a name="ln3229">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3230">      }</a>
<a name="ln3231">      if (c == TAB) {</a>
<a name="ln3232">        if (dir == BACKWARD &amp;&amp; curwin-&gt;w_cursor.col) {</a>
<a name="ln3233">          curwin-&gt;w_cursor.col--;</a>
<a name="ln3234">        }</a>
<a name="ln3235">        if (dir == FORWARD &amp;&amp; col - 1 == endcol2) {</a>
<a name="ln3236">          curwin-&gt;w_cursor.col++;</a>
<a name="ln3237">        }</a>
<a name="ln3238">      }</a>
<a name="ln3239">    }</a>
<a name="ln3240">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3241">    bd.textcol = 0;</a>
<a name="ln3242">    for (i = 0; i &lt; y_size; i++) {</a>
<a name="ln3243">      int spaces = 0;</a>
<a name="ln3244">      char shortline;</a>
<a name="ln3245">      // can just be 0 or 1, needed for blockwise paste beyond the current</a>
<a name="ln3246">      // buffer end</a>
<a name="ln3247">      int lines_appended = 0;</a>
<a name="ln3248"> </a>
<a name="ln3249">      bd.startspaces = 0;</a>
<a name="ln3250">      bd.endspaces = 0;</a>
<a name="ln3251">      vcol = 0;</a>
<a name="ln3252">      delcount = 0;</a>
<a name="ln3253"> </a>
<a name="ln3254">      // add a new line</a>
<a name="ln3255">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3256">        if (ml_append(curbuf-&gt;b_ml.ml_line_count, &quot;&quot;,</a>
<a name="ln3257">                      (colnr_T)1, false) == FAIL) {</a>
<a name="ln3258">          break;</a>
<a name="ln3259">        }</a>
<a name="ln3260">        nr_lines++;</a>
<a name="ln3261">        lines_appended = 1;</a>
<a name="ln3262">      }</a>
<a name="ln3263">      // get the old line and advance to the position to insert at</a>
<a name="ln3264">      oldp = get_cursor_line_ptr();</a>
<a name="ln3265">      oldlen = strlen(oldp);</a>
<a name="ln3266">      chartabsize_T cts;</a>
<a name="ln3267">      init_chartabsize_arg(&amp;cts, curwin, curwin-&gt;w_cursor.lnum, 0, oldp, oldp);</a>
<a name="ln3268"> </a>
<a name="ln3269">      while (cts.cts_vcol &lt; col &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln3270">        // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln3271">        incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln3272">        cts.cts_vcol += incr;</a>
<a name="ln3273">      }</a>
<a name="ln3274">      vcol = cts.cts_vcol;</a>
<a name="ln3275">      ptr = cts.cts_ptr;</a>
<a name="ln3276">      bd.textcol = (colnr_T)(ptr - oldp);</a>
<a name="ln3277">      clear_chartabsize_arg(&amp;cts);</a>
<a name="ln3278"> </a>
<a name="ln3279">      shortline = (vcol &lt; col) || (vcol == col &amp;&amp; !*ptr);</a>
<a name="ln3280"> </a>
<a name="ln3281">      if (vcol &lt; col) {     // line too short, pad with spaces</a>
<a name="ln3282">        bd.startspaces = col - vcol;</a>
<a name="ln3283">      } else if (vcol &gt; col) {</a>
<a name="ln3284">        bd.endspaces = vcol - col;</a>
<a name="ln3285">        bd.startspaces = incr - bd.endspaces;</a>
<a name="ln3286">        bd.textcol--;</a>
<a name="ln3287">        delcount = 1;</a>
<a name="ln3288">        bd.textcol -= utf_head_off(oldp, oldp + bd.textcol);</a>
<a name="ln3289">        if (oldp[bd.textcol] != TAB) {</a>
<a name="ln3290">          // Only a Tab can be split into spaces.  Other</a>
<a name="ln3291">          // characters will have to be moved to after the</a>
<a name="ln3292">          // block, causing misalignment.</a>
<a name="ln3293">          delcount = 0;</a>
<a name="ln3294">          bd.endspaces = 0;</a>
<a name="ln3295">        }</a>
<a name="ln3296">      }</a>
<a name="ln3297"> </a>
<a name="ln3298">      yanklen = (int)strlen(y_array[i]);</a>
<a name="ln3299"> </a>
<a name="ln3300">      if ((flags &amp; PUT_BLOCK_INNER) == 0) {</a>
<a name="ln3301">        // calculate number of spaces required to fill right side of</a>
<a name="ln3302">        // block</a>
<a name="ln3303">        spaces = y_width + 1;</a>
<a name="ln3304">        init_chartabsize_arg(&amp;cts, curwin, 0, 0, y_array[i], y_array[i]);</a>
<a name="ln3305">        for (int j = 0; j &lt; yanklen; j++) {</a>
<a name="ln3306">          spaces -= lbr_chartabsize(&amp;cts);</a>
<a name="ln3307">          cts.cts_ptr++;</a>
<a name="ln3308">          cts.cts_vcol = 0;</a>
<a name="ln3309">        }</a>
<a name="ln3310">        clear_chartabsize_arg(&amp;cts);</a>
<a name="ln3311">        if (spaces &lt; 0) {</a>
<a name="ln3312">          spaces = 0;</a>
<a name="ln3313">        }</a>
<a name="ln3314">      }</a>
<a name="ln3315"> </a>
<a name="ln3316">      // Insert the new text.</a>
<a name="ln3317">      // First check for multiplication overflow.</a>
<a name="ln3318">      if (yanklen + spaces != 0</a>
<a name="ln3319">          &amp;&amp; count &gt; ((INT_MAX - (bd.startspaces + bd.endspaces)) / (yanklen + spaces))) {</a>
<a name="ln3320">        emsg(_(e_resulting_text_too_long));</a>
<a name="ln3321">        break;</a>
<a name="ln3322">      }</a>
<a name="ln3323"> </a>
<a name="ln3324">      totlen = (size_t)(count * (yanklen + spaces) + bd.startspaces + bd.endspaces);</a>
<a name="ln3325">      newp = xmalloc(totlen + oldlen + 1);</a>
<a name="ln3326"> </a>
<a name="ln3327">      // copy part up to cursor to new line</a>
<a name="ln3328">      ptr = newp;</a>
<a name="ln3329">      memmove(ptr, oldp, (size_t)bd.textcol);</a>
<a name="ln3330">      ptr += bd.textcol;</a>
<a name="ln3331"> </a>
<a name="ln3332">      // may insert some spaces before the new text</a>
<a name="ln3333">      memset(ptr, ' ', (size_t)bd.startspaces);</a>
<a name="ln3334">      ptr += bd.startspaces;</a>
<a name="ln3335"> </a>
<a name="ln3336">      // insert the new text</a>
<a name="ln3337">      for (long j = 0; j &lt; count; j++) {</a>
<a name="ln3338">        memmove(ptr, y_array[i], (size_t)yanklen);</a>
<a name="ln3339">        ptr += yanklen;</a>
<a name="ln3340"> </a>
<a name="ln3341">        // insert block's trailing spaces only if there's text behind</a>
<a name="ln3342">        if ((j &lt; count - 1 || !shortline) &amp;&amp; spaces &gt; 0) {</a>
<a name="ln3343">          memset(ptr, ' ', (size_t)spaces);</a>
<a name="ln3344">          ptr += spaces;</a>
<a name="ln3345">        } else {</a>
<a name="ln3346">          totlen -= (size_t)spaces;  // didn't use these spaces</a>
<a name="ln3347">        }</a>
<a name="ln3348">      }</a>
<a name="ln3349"> </a>
<a name="ln3350">      // may insert some spaces after the new text</a>
<a name="ln3351">      memset(ptr, ' ', (size_t)bd.endspaces);</a>
<a name="ln3352">      ptr += bd.endspaces;</a>
<a name="ln3353"> </a>
<a name="ln3354">      // move the text after the cursor to the end of the line.</a>
<a name="ln3355">      int columns = (int)oldlen - bd.textcol - delcount + 1;</a>
<a name="ln3356">      assert(columns &gt;= 0);</a>
<a name="ln3357">      memmove(ptr, oldp + bd.textcol + delcount, (size_t)columns);</a>
<a name="ln3358">      ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln3359">      extmark_splice_cols(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, bd.textcol,</a>
<a name="ln3360">                          delcount, (int)totlen + lines_appended, kExtmarkUndo);</a>
<a name="ln3361"> </a>
<a name="ln3362">      curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3363">      if (i == 0) {</a>
<a name="ln3364">        curwin-&gt;w_cursor.col += bd.startspaces;</a>
<a name="ln3365">      }</a>
<a name="ln3366">    }</a>
<a name="ln3367"> </a>
<a name="ln3368">    changed_lines(lnum, 0, curbuf-&gt;b_op_start.lnum + (linenr_T)y_size</a>
<a name="ln3369">                  - nr_lines, nr_lines, true);</a>
<a name="ln3370"> </a>
<a name="ln3371">    // Set '[ mark.</a>
<a name="ln3372">    curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3373">    curbuf-&gt;b_op_start.lnum = lnum;</a>
<a name="ln3374"> </a>
<a name="ln3375">    // adjust '] mark</a>
<a name="ln3376">    curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum - 1;</a>
<a name="ln3377">    curbuf-&gt;b_op_end.col = bd.textcol + (colnr_T)totlen - 1;</a>
<a name="ln3378">    if (curbuf-&gt;b_op_end.col &lt; 0) {</a>
<a name="ln3379">      curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln3380">    }</a>
<a name="ln3381">    curbuf-&gt;b_op_end.coladd = 0;</a>
<a name="ln3382">    if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3383">      colnr_T len;</a>
<a name="ln3384"> </a>
<a name="ln3385">      curwin-&gt;w_cursor = curbuf-&gt;b_op_end;</a>
<a name="ln3386">      curwin-&gt;w_cursor.col++;</a>
<a name="ln3387"> </a>
<a name="ln3388">      // in Insert mode we might be after the NUL, correct for that</a>
<a name="ln3389">      len = (colnr_T)strlen(get_cursor_line_ptr());</a>
<a name="ln3390">      if (curwin-&gt;w_cursor.col &gt; len) {</a>
<a name="ln3391">        curwin-&gt;w_cursor.col = len;</a>
<a name="ln3392">      }</a>
<a name="ln3393">    } else {</a>
<a name="ln3394">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3395">    }</a>
<a name="ln3396">  } else {</a>
<a name="ln3397">    // Character or Line mode</a>
<a name="ln3398">    if (y_type == kMTCharWise) {</a>
<a name="ln3399">      // if type is kMTCharWise, FORWARD is the same as BACKWARD on the next</a>
<a name="ln3400">      // char</a>
<a name="ln3401">      if (dir == FORWARD &amp;&amp; gchar_cursor() != NUL) {</a>
<a name="ln3402">        int bytelen = utfc_ptr2len(get_cursor_pos_ptr());</a>
<a name="ln3403"> </a>
<a name="ln3404">        // put it on the next of the multi-byte character.</a>
<a name="ln3405">        col += bytelen;</a>
<a name="ln3406">        if (yanklen) {</a>
<a name="ln3407">          curwin-&gt;w_cursor.col += bytelen;</a>
<a name="ln3408">          curbuf-&gt;b_op_end.col += bytelen;</a>
<a name="ln3409">        }</a>
<a name="ln3410">      }</a>
<a name="ln3411">      curbuf-&gt;b_op_start = curwin-&gt;w_cursor;</a>
<a name="ln3412">    } else if (dir == BACKWARD) {</a>
<a name="ln3413">      // Line mode: BACKWARD is the same as FORWARD on the previous line</a>
<a name="ln3414">      lnum--;</a>
<a name="ln3415">    }</a>
<a name="ln3416">    new_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3417"> </a>
<a name="ln3418">    // simple case: insert into one line at a time</a>
<a name="ln3419">    if (y_type == kMTCharWise &amp;&amp; y_size == 1) {</a>
<a name="ln3420">      linenr_T end_lnum = 0;  // init for gcc</a>
<a name="ln3421">      linenr_T start_lnum = lnum;</a>
<a name="ln3422">      int first_byte_off = 0;</a>
<a name="ln3423"> </a>
<a name="ln3424">      if (VIsual_active) {</a>
<a name="ln3425">        end_lnum = curbuf-&gt;b_visual.vi_end.lnum;</a>
<a name="ln3426">        if (end_lnum &lt; curbuf-&gt;b_visual.vi_start.lnum) {</a>
<a name="ln3427">          end_lnum = curbuf-&gt;b_visual.vi_start.lnum;</a>
<a name="ln3428">        }</a>
<a name="ln3429">        if (end_lnum &gt; start_lnum) {</a>
<a name="ln3430">          // &quot;col&quot; is valid for the first line, in following lines</a>
<a name="ln3431">          // the virtual column needs to be used.  Matters for</a>
<a name="ln3432">          // multi-byte characters.</a>
<a name="ln3433">          pos_T pos = {</a>
<a name="ln3434">            .lnum = lnum,</a>
<a name="ln3435">            .col = col,</a>
<a name="ln3436">            .coladd = 0,</a>
<a name="ln3437">          };</a>
<a name="ln3438">          getvcol(curwin, &amp;pos, NULL, &amp;vcol, NULL);</a>
<a name="ln3439">        }</a>
<a name="ln3440">      }</a>
<a name="ln3441"> </a>
<a name="ln3442">      if (count == 0 || yanklen == 0) {</a>
<a name="ln3443">        if (VIsual_active) {</a>
<a name="ln3444">          lnum = end_lnum;</a>
<a name="ln3445">        }</a>
<a name="ln3446">      } else if (count &gt; INT_MAX / yanklen) {</a>
<a name="ln3447">        // multiplication overflow</a>
<a name="ln3448">        emsg(_(e_resulting_text_too_long));</a>
<a name="ln3449">      } else {</a>
<a name="ln3450">        totlen = (size_t)(count * yanklen);</a>
<a name="ln3451">        do {</a>
<a name="ln3452">          oldp = ml_get(lnum);</a>
<a name="ln3453">          oldlen = strlen(oldp);</a>
<a name="ln3454">          if (lnum &gt; start_lnum) {</a>
<a name="ln3455">            pos_T pos = {</a>
<a name="ln3456">              .lnum = lnum,</a>
<a name="ln3457">            };</a>
<a name="ln3458">            if (getvpos(&amp;pos, vcol) == OK) {</a>
<a name="ln3459">              col = pos.col;</a>
<a name="ln3460">            } else {</a>
<a name="ln3461">              col = MAXCOL;</a>
<a name="ln3462">            }</a>
<a name="ln3463">          }</a>
<a name="ln3464">          if (VIsual_active &amp;&amp; col &gt; (colnr_T)oldlen) {</a>
<a name="ln3465">            lnum++;</a>
<a name="ln3466">            continue;</a>
<a name="ln3467">          }</a>
<a name="ln3468">          newp = xmalloc(totlen + oldlen + 1);</a>
<a name="ln3469">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3470">          ptr = newp + col;</a>
<a name="ln3471">          for (i = 0; i &lt; (size_t)count; i++) {</a>
<a name="ln3472">            memmove(ptr, y_array[0], (size_t)yanklen);</a>
<a name="ln3473">            ptr += yanklen;</a>
<a name="ln3474">          }</a>
<a name="ln3475">          STRMOVE(ptr, oldp + col);</a>
<a name="ln3476">          ml_replace(lnum, newp, false);</a>
<a name="ln3477"> </a>
<a name="ln3478">          // compute the byte offset for the last character</a>
<a name="ln3479">          first_byte_off = utf_head_off(newp, ptr - 1);</a>
<a name="ln3480"> </a>
<a name="ln3481">          // Place cursor on last putted char.</a>
<a name="ln3482">          if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3483">            // make sure curwin-&gt;w_virtcol is updated</a>
<a name="ln3484">            changed_cline_bef_curs();</a>
<a name="ln3485">            invalidate_botline();</a>
<a name="ln3486">            curwin-&gt;w_cursor.col += (colnr_T)(totlen - 1);</a>
<a name="ln3487">          }</a>
<a name="ln3488">          changed_bytes(lnum, col);</a>
<a name="ln3489">          extmark_splice_cols(curbuf, (int)lnum - 1, col,</a>
<a name="ln3490">                              0, (int)totlen, kExtmarkUndo);</a>
<a name="ln3491">          if (VIsual_active) {</a>
<a name="ln3492">            lnum++;</a>
<a name="ln3493">          }</a>
<a name="ln3494">        } while (VIsual_active &amp;&amp; lnum &lt;= end_lnum);</a>
<a name="ln3495"> </a>
<a name="ln3496">        if (VIsual_active) {  // reset lnum to the last visual line</a>
<a name="ln3497">          lnum--;</a>
<a name="ln3498">        }</a>
<a name="ln3499">      }</a>
<a name="ln3500"> </a>
<a name="ln3501">      // put '] at the first byte of the last character</a>
<a name="ln3502">      curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3503">      curbuf-&gt;b_op_end.col -= first_byte_off;</a>
<a name="ln3504"> </a>
<a name="ln3505">      // For &quot;CTRL-O p&quot; in Insert mode, put cursor after last char</a>
<a name="ln3506">      if (totlen &amp;&amp; (restart_edit != 0 || (flags &amp; PUT_CURSEND))) {</a>
<a name="ln3507">        curwin-&gt;w_cursor.col++;</a>
<a name="ln3508">      } else {</a>
<a name="ln3509">        curwin-&gt;w_cursor.col -= first_byte_off;</a>
<a name="ln3510">      }</a>
<a name="ln3511">    } else {</a>
<a name="ln3512">      linenr_T new_lnum = new_cursor.lnum;</a>
<a name="ln3513">      size_t len;</a>
<a name="ln3514"> </a>
<a name="ln3515">      // Insert at least one line.  When y_type is kMTCharWise, break the first</a>
<a name="ln3516">      // line in two.</a>
<a name="ln3517">      for (cnt = 1; cnt &lt;= count; cnt++) {</a>
<a name="ln3518">        i = 0;</a>
<a name="ln3519">        if (y_type == kMTCharWise) {</a>
<a name="ln3520">          // Split the current line in two at the insert position.</a>
<a name="ln3521">          // First insert y_array[size - 1] in front of second line.</a>
<a name="ln3522">          // Then append y_array[0] to first line.</a>
<a name="ln3523">          lnum = new_cursor.lnum;</a>
<a name="ln3524">          ptr = ml_get(lnum) + col;</a>
<a name="ln3525">          totlen = strlen(y_array[y_size - 1]);</a>
<a name="ln3526">          newp = xmalloc((size_t)(strlen(ptr) + totlen + 1));</a>
<a name="ln3527">          STRCPY(newp, y_array[y_size - 1]);</a>
<a name="ln3528">          STRCAT(newp, ptr);</a>
<a name="ln3529">          // insert second line</a>
<a name="ln3530">          ml_append(lnum, newp, (colnr_T)0, false);</a>
<a name="ln3531">          new_lnum++;</a>
<a name="ln3532">          xfree(newp);</a>
<a name="ln3533"> </a>
<a name="ln3534">          oldp = ml_get(lnum);</a>
<a name="ln3535">          newp = xmalloc((size_t)col + (size_t)yanklen + 1);</a>
<a name="ln3536">          // copy first part of line</a>
<a name="ln3537">          memmove(newp, oldp, (size_t)col);</a>
<a name="ln3538">          // append to first line</a>
<a name="ln3539">          memmove(newp + col, y_array[0], (size_t)yanklen + 1);</a>
<a name="ln3540">          ml_replace(lnum, newp, false);</a>
<a name="ln3541"> </a>
<a name="ln3542">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3543">          i = 1;</a>
<a name="ln3544">        }</a>
<a name="ln3545"> </a>
<a name="ln3546">        for (; i &lt; y_size; i++) {</a>
<a name="ln3547">          if ((y_type != kMTCharWise || i &lt; y_size - 1)) {</a>
<a name="ln3548">            if (ml_append(lnum, y_array[i], (colnr_T)0, false) == FAIL) {</a>
<a name="ln3549">              goto error;</a>
<a name="ln3550">            }</a>
<a name="ln3551">            new_lnum++;</a>
<a name="ln3552">          }</a>
<a name="ln3553">          lnum++;</a>
<a name="ln3554">          nr_lines++;</a>
<a name="ln3555">          if (flags &amp; PUT_FIXINDENT) {</a>
<a name="ln3556">            old_pos = curwin-&gt;w_cursor;</a>
<a name="ln3557">            curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3558">            ptr = ml_get(lnum);</a>
<a name="ln3559">            if (cnt == count &amp;&amp; i == y_size - 1) {</a>
<a name="ln3560">              lendiff = (int)strlen(ptr);</a>
<a name="ln3561">            }</a>
<a name="ln3562">            if (*ptr == '#' &amp;&amp; preprocs_left()) {</a>
<a name="ln3563">              indent = 0;                   // Leave # lines at start</a>
<a name="ln3564">            } else if (*ptr == NUL) {</a>
<a name="ln3565">              indent = 0;                   // Ignore empty lines</a>
<a name="ln3566">            } else if (first_indent) {</a>
<a name="ln3567">              indent_diff = orig_indent - get_indent();</a>
<a name="ln3568">              indent = orig_indent;</a>
<a name="ln3569">              first_indent = false;</a>
<a name="ln3570">            } else if ((indent = get_indent() + indent_diff) &lt; 0) {</a>
<a name="ln3571">              indent = 0;</a>
<a name="ln3572">            }</a>
<a name="ln3573">            (void)set_indent(indent, SIN_NOMARK);</a>
<a name="ln3574">            curwin-&gt;w_cursor = old_pos;</a>
<a name="ln3575">            // remember how many chars were removed</a>
<a name="ln3576">            if (cnt == count &amp;&amp; i == y_size - 1) {</a>
<a name="ln3577">              lendiff -= (int)strlen(ml_get(lnum));</a>
<a name="ln3578">            }</a>
<a name="ln3579">          }</a>
<a name="ln3580">        }</a>
<a name="ln3581"> </a>
<a name="ln3582">        bcount_t totsize = 0;</a>
<a name="ln3583">        int lastsize = 0;</a>
<a name="ln3584">        if (y_type == kMTCharWise</a>
<a name="ln3585">            || (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT)) {</a>
<a name="ln3586">          for (i = 0; i &lt; y_size - 1; i++) {</a>
<a name="ln3587">            totsize += (bcount_t)strlen(y_array[i]) + 1;</a>
<a name="ln3588">          }</a>
<a name="ln3589">          lastsize = (int)strlen(y_array[y_size - 1]);</a>
<a name="ln3590">          totsize += lastsize;</a>
<a name="ln3591">        }</a>
<a name="ln3592">        if (y_type == kMTCharWise) {</a>
<a name="ln3593">          extmark_splice(curbuf, (int)new_cursor.lnum - 1, col, 0, 0, 0,</a>
<a name="ln3594">                         (int)y_size - 1, lastsize, totsize,</a>
<a name="ln3595">                         kExtmarkUndo);</a>
<a name="ln3596">        } else if (y_type == kMTLineWise &amp;&amp; flags &amp; PUT_LINE_SPLIT) {</a>
<a name="ln3597">          // Account for last pasted NL + last NL</a>
<a name="ln3598">          extmark_splice(curbuf, (int)new_cursor.lnum - 1, col + 1, 0, 0, 0,</a>
<a name="ln3599">                         (int)y_size + 1, 0, totsize + 2, kExtmarkUndo);</a>
<a name="ln3600">        }</a>
<a name="ln3601"> </a>
<a name="ln3602">        if (cnt == 1) {</a>
<a name="ln3603">          new_lnum = lnum;</a>
<a name="ln3604">        }</a>
<a name="ln3605">      }</a>
<a name="ln3606"> </a>
<a name="ln3607">error:</a>
<a name="ln3608">      // Adjust marks.</a>
<a name="ln3609">      if (y_type == kMTLineWise) {</a>
<a name="ln3610">        curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln3611">        if (dir == FORWARD) {</a>
<a name="ln3612">          curbuf-&gt;b_op_start.lnum++;</a>
<a name="ln3613">        }</a>
<a name="ln3614">      }</a>
<a name="ln3615"> </a>
<a name="ln3616">      ExtmarkOp kind = (y_type == kMTLineWise &amp;&amp; !(flags &amp; PUT_LINE_SPLIT))</a>
<a name="ln3617">                       ? kExtmarkUndo : kExtmarkNOOP;</a>
<a name="ln3618">      mark_adjust(curbuf-&gt;b_op_start.lnum + (y_type == kMTCharWise),</a>
<a name="ln3619">                  (linenr_T)MAXLNUM, nr_lines, 0L, kind);</a>
<a name="ln3620"> </a>
<a name="ln3621">      // note changed text for displaying and folding</a>
<a name="ln3622">      if (y_type == kMTCharWise) {</a>
<a name="ln3623">        changed_lines(curwin-&gt;w_cursor.lnum, col,</a>
<a name="ln3624">                      curwin-&gt;w_cursor.lnum + 1, nr_lines, true);</a>
<a name="ln3625">      } else {</a>
<a name="ln3626">        changed_lines(curbuf-&gt;b_op_start.lnum, 0,</a>
<a name="ln3627">                      curbuf-&gt;b_op_start.lnum, nr_lines, true);</a>
<a name="ln3628">      }</a>
<a name="ln3629"> </a>
<a name="ln3630">      // Put the '] mark on the first byte of the last inserted character.</a>
<a name="ln3631">      // Correct the length for change in indent.</a>
<a name="ln3632">      curbuf-&gt;b_op_end.lnum = new_lnum;</a>
<a name="ln3633">      len = strlen(y_array[y_size - 1]);</a>
<a name="ln3634">      col = (colnr_T)len - lendiff;</a>
<a name="ln3635">      if (col &gt; 1) {</a>
<a name="ln3636">        curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3637">        if (len &gt; 0) {</a>
<a name="ln3638">          curbuf-&gt;b_op_end.col -= utf_head_off(y_array[y_size - 1],</a>
<a name="ln3639">                                               y_array[y_size - 1] + len - 1);</a>
<a name="ln3640">        }</a>
<a name="ln3641">      } else {</a>
<a name="ln3642">        curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln3643">      }</a>
<a name="ln3644"> </a>
<a name="ln3645">      if (flags &amp; PUT_CURSLINE) {</a>
<a name="ln3646">        // &quot;:put&quot;: put cursor on last inserted line</a>
<a name="ln3647">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3648">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3649">      } else if (flags &amp; PUT_CURSEND) {</a>
<a name="ln3650">        // put cursor after inserted text</a>
<a name="ln3651">        if (y_type == kMTLineWise) {</a>
<a name="ln3652">          if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3653">            curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3654">          } else {</a>
<a name="ln3655">            curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln3656">          }</a>
<a name="ln3657">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3658">        } else {</a>
<a name="ln3659">          curwin-&gt;w_cursor.lnum = new_lnum;</a>
<a name="ln3660">          curwin-&gt;w_cursor.col = col;</a>
<a name="ln3661">          curbuf-&gt;b_op_end = curwin-&gt;w_cursor;</a>
<a name="ln3662">          if (col &gt; 1) {</a>
<a name="ln3663">            curbuf-&gt;b_op_end.col = col - 1;</a>
<a name="ln3664">          }</a>
<a name="ln3665">        }</a>
<a name="ln3666">      } else if (y_type == kMTLineWise) {</a>
<a name="ln3667">        // put cursor on first non-blank in first inserted line</a>
<a name="ln3668">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3669">        if (dir == FORWARD) {</a>
<a name="ln3670">          curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3671">        }</a>
<a name="ln3672">        beginline(BL_WHITE | BL_FIX);</a>
<a name="ln3673">      } else {  // put cursor on first inserted character</a>
<a name="ln3674">        curwin-&gt;w_cursor = new_cursor;</a>
<a name="ln3675">      }</a>
<a name="ln3676">    }</a>
<a name="ln3677">  }</a>
<a name="ln3678"> </a>
<a name="ln3679">  msgmore(nr_lines);</a>
<a name="ln3680">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln3681"> </a>
<a name="ln3682">  // Make sure the cursor is not after the NUL.</a>
<a name="ln3683">  int len = (int)strlen(get_cursor_line_ptr());</a>
<a name="ln3684">  if (curwin-&gt;w_cursor.col &gt; len) {</a>
<a name="ln3685">    if (cur_ve_flags == VE_ALL) {</a>
<a name="ln3686">      curwin-&gt;w_cursor.coladd = curwin-&gt;w_cursor.col - len;</a>
<a name="ln3687">    }</a>
<a name="ln3688">    curwin-&gt;w_cursor.col = len;</a>
<a name="ln3689">  }</a>
<a name="ln3690"> </a>
<a name="ln3691">end:</a>
<a name="ln3692">  if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln3693">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln3694">    curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln3695">  }</a>
<a name="ln3696">  if (allocated) {</a>
<a name="ln3697">    xfree(insert_string);</a>
<a name="ln3698">  }</a>
<a name="ln3699">  if (regname == '=') {</a>
<a name="ln3700">    xfree(y_array);</a>
<a name="ln3701">  }</a>
<a name="ln3702"> </a>
<a name="ln3703">  VIsual_active = false;</a>
<a name="ln3704"> </a>
<a name="ln3705">  // If the cursor is past the end of the line put it at the end.</a>
<a name="ln3706">  adjust_cursor_eol();</a>
<a name="ln3707">}</a>
<a name="ln3708"> </a>
<a name="ln3709">/// When the cursor is on the NUL past the end of the line and it should not be</a>
<a name="ln3710">/// there move it left.</a>
<a name="ln3711">void adjust_cursor_eol(void)</a>
<a name="ln3712">{</a>
<a name="ln3713">  unsigned cur_ve_flags = get_ve_flags();</a>
<a name="ln3714"> </a>
<a name="ln3715">  const bool adj_cursor = (curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln3716">                           &amp;&amp; gchar_cursor() == NUL</a>
<a name="ln3717">                           &amp;&amp; (cur_ve_flags &amp; VE_ONEMORE) == 0</a>
<a name="ln3718">                           &amp;&amp; !(restart_edit || (State &amp; MODE_INSERT)));</a>
<a name="ln3719">  if (!adj_cursor) {</a>
<a name="ln3720">    return;</a>
<a name="ln3721">  }</a>
<a name="ln3722"> </a>
<a name="ln3723">  // Put the cursor on the last character in the line.</a>
<a name="ln3724">  dec_cursor();</a>
<a name="ln3725"> </a>
<a name="ln3726">  if (cur_ve_flags == VE_ALL) {</a>
<a name="ln3727">    colnr_T scol, ecol;</a>
<a name="ln3728"> </a>
<a name="ln3729">    // Coladd is set to the width of the last character.</a>
<a name="ln3730">    getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;scol, NULL, &amp;ecol);</a>
<a name="ln3731">    curwin-&gt;w_cursor.coladd = ecol - scol + 1;</a>
<a name="ln3732">  }</a>
<a name="ln3733">}</a>
<a name="ln3734"> </a>
<a name="ln3735">/// @return  true if lines starting with '#' should be left aligned.</a>
<a name="ln3736">int preprocs_left(void)</a>
<a name="ln3737">{</a>
<a name="ln3738">  return ((curbuf-&gt;b_p_si &amp;&amp; !curbuf-&gt;b_p_cin)</a>
<a name="ln3739">          || (curbuf-&gt;b_p_cin &amp;&amp; in_cinkeys('#', ' ', true)</a>
<a name="ln3740">              &amp;&amp; curbuf-&gt;b_ind_hash_comment == 0));</a>
<a name="ln3741">}</a>
<a name="ln3742"> </a>
<a name="ln3743">/// @return  the character name of the register with the given number</a>
<a name="ln3744">int get_register_name(int num)</a>
<a name="ln3745">{</a>
<a name="ln3746">  if (num == -1) {</a>
<a name="ln3747">    return '&quot;';</a>
<a name="ln3748">  } else if (num &lt; 10) {</a>
<a name="ln3749">    return num + '0';</a>
<a name="ln3750">  } else if (num == DELETION_REGISTER) {</a>
<a name="ln3751">    return '-';</a>
<a name="ln3752">  } else if (num == STAR_REGISTER) {</a>
<a name="ln3753">    return '*';</a>
<a name="ln3754">  } else if (num == PLUS_REGISTER) {</a>
<a name="ln3755">    return '+';</a>
<a name="ln3756">  } else {</a>
<a name="ln3757">    return num + 'a' - 10;</a>
<a name="ln3758">  }</a>
<a name="ln3759">}</a>
<a name="ln3760"> </a>
<a name="ln3761">/// @return the index of the register &quot;&quot; points to.</a>
<a name="ln3762">int get_unname_register(void)</a>
<a name="ln3763">{</a>
<a name="ln3764">  return y_previous == NULL ? -1 : (int)(y_previous - &amp;y_regs[0]);</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">/// &quot;:dis&quot; and &quot;:registers&quot;: Display the contents of the yank registers.</a>
<a name="ln3768">void ex_display(exarg_T *eap)</a>
<a name="ln3769">{</a>
<a name="ln3770">  char *p;</a>
<a name="ln3771">  yankreg_T *yb;</a>
<a name="ln3772">  char *arg = eap-&gt;arg;</a>
<a name="ln3773">  int clen;</a>
<a name="ln3774">  int type;</a>
<a name="ln3775"> </a>
<a name="ln3776">  if (arg != NULL &amp;&amp; *arg == NUL) {</a>
<a name="ln3777">    arg = NULL;</a>
<a name="ln3778">  }</a>
<a name="ln3779">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln3780"> </a>
<a name="ln3781">  // Highlight title</a>
<a name="ln3782">  msg_puts_title(_(&quot;\nType Name Content&quot;));</a>
<a name="ln3783">  for (int i = -1; i &lt; NUM_REGISTERS &amp;&amp; !got_int; i++) {</a>
<a name="ln3784">    int name = get_register_name(i);</a>
<a name="ln3785">    switch (get_reg_type(name, NULL)) {</a>
<a name="ln3786">    case kMTLineWise:</a>
<a name="ln3787">      type = 'l'; break;</a>
<a name="ln3788">    case kMTCharWise:</a>
<a name="ln3789">      type = 'c'; break;</a>
<a name="ln3790">    default:</a>
<a name="ln3791">      type = 'b'; break;</a>
<a name="ln3792">    }</a>
<a name="ln3793"> </a>
<a name="ln3794">    if (arg != NULL &amp;&amp; vim_strchr(arg, name) == NULL) {</a>
<a name="ln3795">      continue;             // did not ask for this register</a>
<a name="ln3796">    }</a>
<a name="ln3797"> </a>
<a name="ln3798">    if (i == -1) {</a>
<a name="ln3799">      if (y_previous != NULL) {</a>
<a name="ln3800">        yb = y_previous;</a>
<a name="ln3801">      } else {</a>
<a name="ln3802">        yb = &amp;(y_regs[0]);</a>
<a name="ln3803">      }</a>
<a name="ln3804">    } else {</a>
<a name="ln3805">      yb = &amp;(y_regs[i]);</a>
<a name="ln3806">    }</a>
<a name="ln3807"> </a>
<a name="ln3808">    get_clipboard(name, &amp;yb, true);</a>
<a name="ln3809"> </a>
<a name="ln3810">    if (name == mb_tolower(redir_reg)</a>
<a name="ln3811">        || (redir_reg == '&quot;' &amp;&amp; yb == y_previous)) {</a>
<a name="ln3812">      continue;  // do not list register being written to, the</a>
<a name="ln3813">                 // pointer can be freed</a>
<a name="ln3814">    }</a>
<a name="ln3815"> </a>
<a name="ln3816">    if (yb-&gt;y_array != NULL) {</a>
<a name="ln3817">      bool do_show = false;</a>
<a name="ln3818"> </a>
<a name="ln3819">      for (size_t j = 0; !do_show &amp;&amp; j &lt; yb-&gt;y_size; j++) {</a>
<a name="ln3820">        do_show = !message_filtered(yb-&gt;y_array[j]);</a>
<a name="ln3821">      }</a>
<a name="ln3822"> </a>
<a name="ln3823">      if (do_show || yb-&gt;y_size == 0) {</a>
<a name="ln3824">        msg_putchar('\n');</a>
<a name="ln3825">        msg_puts(&quot;  &quot;);</a>
<a name="ln3826">        msg_putchar(type);</a>
<a name="ln3827">        msg_puts(&quot;  &quot;);</a>
<a name="ln3828">        msg_putchar('&quot;');</a>
<a name="ln3829">        msg_putchar(name);</a>
<a name="ln3830">        msg_puts(&quot;   &quot;);</a>
<a name="ln3831"> </a>
<a name="ln3832">        int n = Columns - 11;</a>
<a name="ln3833">        for (size_t j = 0; j &lt; yb-&gt;y_size &amp;&amp; n &gt; 1; j++) {</a>
<a name="ln3834">          if (j) {</a>
<a name="ln3835">            msg_puts_attr(&quot;^J&quot;, attr);</a>
<a name="ln3836">            n -= 2;</a>
<a name="ln3837">          }</a>
<a name="ln3838">          for (p = yb-&gt;y_array[j];</a>
<a name="ln3839">               *p != NUL &amp;&amp; (n -= ptr2cells(p)) &gt;= 0; p++) {  // -V1019</a>
<a name="ln3840">            clen = utfc_ptr2len(p);</a>
<a name="ln3841">            msg_outtrans_len(p, clen);</a>
<a name="ln3842">            p += clen - 1;</a>
<a name="ln3843">          }</a>
<a name="ln3844">        }</a>
<a name="ln3845">        if (n &gt; 1 &amp;&amp; yb-&gt;y_type == kMTLineWise) {</a>
<a name="ln3846">          msg_puts_attr(&quot;^J&quot;, attr);</a>
<a name="ln3847">        }</a>
<a name="ln3848">      }</a>
<a name="ln3849">      os_breakcheck();</a>
<a name="ln3850">    }</a>
<a name="ln3851">  }</a>
<a name="ln3852"> </a>
<a name="ln3853">  // display last inserted text</a>
<a name="ln3854">  if ((p = get_last_insert()) != NULL</a>
<a name="ln3855">      &amp;&amp; (arg == NULL || vim_strchr(arg, '.') != NULL) &amp;&amp; !got_int</a>
<a name="ln3856">      &amp;&amp; !message_filtered(p)) {</a>
<a name="ln3857">    msg_puts(&quot;\n  c  \&quot;.   &quot;);</a>
<a name="ln3858">    dis_msg(p, true);</a>
<a name="ln3859">  }</a>
<a name="ln3860"> </a>
<a name="ln3861">  // display last command line</a>
<a name="ln3862">  if (last_cmdline != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, ':') != NULL)</a>
<a name="ln3863">      &amp;&amp; !got_int &amp;&amp; !message_filtered(last_cmdline)) {</a>
<a name="ln3864">    msg_puts(&quot;\n  c  \&quot;:   &quot;);</a>
<a name="ln3865">    dis_msg(last_cmdline, false);</a>
<a name="ln3866">  }</a>
<a name="ln3867"> </a>
<a name="ln3868">  // display current file name</a>
<a name="ln3869">  if (curbuf-&gt;b_fname != NULL</a>
<a name="ln3870">      &amp;&amp; (arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int</a>
<a name="ln3871">      &amp;&amp; !message_filtered(curbuf-&gt;b_fname)) {</a>
<a name="ln3872">    msg_puts(&quot;\n  c  \&quot;%   &quot;);</a>
<a name="ln3873">    dis_msg(curbuf-&gt;b_fname, false);</a>
<a name="ln3874">  }</a>
<a name="ln3875"> </a>
<a name="ln3876">  // display alternate file name</a>
<a name="ln3877">  if ((arg == NULL || vim_strchr(arg, '%') != NULL) &amp;&amp; !got_int) {</a>
<a name="ln3878">    char *fname;</a>
<a name="ln3879">    linenr_T dummy;</a>
<a name="ln3880"> </a>
<a name="ln3881">    if (buflist_name_nr(0, &amp;fname, &amp;dummy) != FAIL &amp;&amp; !message_filtered(fname)) {</a>
<a name="ln3882">      msg_puts(&quot;\n  c  \&quot;#   &quot;);</a>
<a name="ln3883">      dis_msg(fname, false);</a>
<a name="ln3884">    }</a>
<a name="ln3885">  }</a>
<a name="ln3886"> </a>
<a name="ln3887">  // display last search pattern</a>
<a name="ln3888">  if (last_search_pat() != NULL</a>
<a name="ln3889">      &amp;&amp; (arg == NULL || vim_strchr(arg, '/') != NULL) &amp;&amp; !got_int</a>
<a name="ln3890">      &amp;&amp; !message_filtered(last_search_pat())) {</a>
<a name="ln3891">    msg_puts(&quot;\n  c  \&quot;/   &quot;);</a>
<a name="ln3892">    dis_msg(last_search_pat(), false);</a>
<a name="ln3893">  }</a>
<a name="ln3894"> </a>
<a name="ln3895">  // display last used expression</a>
<a name="ln3896">  if (expr_line != NULL &amp;&amp; (arg == NULL || vim_strchr(arg, '=') != NULL)</a>
<a name="ln3897">      &amp;&amp; !got_int &amp;&amp; !message_filtered(expr_line)) {</a>
<a name="ln3898">    msg_puts(&quot;\n  c  \&quot;=   &quot;);</a>
<a name="ln3899">    dis_msg(expr_line, false);</a>
<a name="ln3900">  }</a>
<a name="ln3901">}</a>
<a name="ln3902"> </a>
<a name="ln3903">/// display a string for do_dis()</a>
<a name="ln3904">/// truncate at end of screen line</a>
<a name="ln3905">///</a>
<a name="ln3906">/// @param skip_esc  if true, ignore trailing ESC</a>
<a name="ln3907">static void dis_msg(const char *p, bool skip_esc)</a>
<a name="ln3908">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3909">{</a>
<a name="ln3910">  int n = Columns - 6;</a>
<a name="ln3911">  while (*p != NUL</a>
<a name="ln3912">         &amp;&amp; !(*p == ESC &amp;&amp; skip_esc &amp;&amp; *(p + 1) == NUL)</a>
<a name="ln3913">         &amp;&amp; (n -= ptr2cells(p)) &gt;= 0) {</a>
<a name="ln3914">    int l;</a>
<a name="ln3915">    if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln3916">      msg_outtrans_len(p, l);</a>
<a name="ln3917">      p += l;</a>
<a name="ln3918">    } else {</a>
<a name="ln3919">      msg_outtrans_len(p++, 1);</a>
<a name="ln3920">    }</a>
<a name="ln3921">  }</a>
<a name="ln3922">  os_breakcheck();</a>
<a name="ln3923">}</a>
<a name="ln3924"> </a>
<a name="ln3925">/// If \p &quot;process&quot; is true and the line begins with a comment leader (possibly</a>
<a name="ln3926">/// after some white space), return a pointer to the text after it.</a>
<a name="ln3927">/// Put a boolean value indicating whether the line ends with an unclosed</a>
<a name="ln3928">/// comment in &quot;is_comment&quot;.</a>
<a name="ln3929">///</a>
<a name="ln3930">/// @param line - line to be processed</a>
<a name="ln3931">/// @param process - if false, will only check whether the line ends</a>
<a name="ln3932">///         with an unclosed comment,</a>
<a name="ln3933">/// @param include_space - whether to skip space following the comment leader</a>
<a name="ln3934">/// @param[out] is_comment - whether the current line ends with an unclosed</a>
<a name="ln3935">///  comment.</a>
<a name="ln3936">char *skip_comment(char *line, bool process, bool include_space, bool *is_comment)</a>
<a name="ln3937">{</a>
<a name="ln3938">  char *comment_flags = NULL;</a>
<a name="ln3939">  int lead_len;</a>
<a name="ln3940">  int leader_offset = get_last_leader_offset(line, &amp;comment_flags);</a>
<a name="ln3941"> </a>
<a name="ln3942">  *is_comment = false;</a>
<a name="ln3943">  if (leader_offset != -1) {</a>
<a name="ln3944">    // Let's check whether the line ends with an unclosed comment.</a>
<a name="ln3945">    // If the last comment leader has COM_END in flags, there's no comment.</a>
<a name="ln3946">    while (*comment_flags) {</a>
<a name="ln3947">      if (*comment_flags == COM_END</a>
<a name="ln3948">          || *comment_flags == ':') {</a>
<a name="ln3949">        break;</a>
<a name="ln3950">      }</a>
<a name="ln3951">      comment_flags++;</a>
<a name="ln3952">    }</a>
<a name="ln3953">    if (*comment_flags != COM_END) {</a>
<a name="ln3954">      *is_comment = true;</a>
<a name="ln3955">    }</a>
<a name="ln3956">  }</a>
<a name="ln3957"> </a>
<a name="ln3958">  if (process == false) {</a>
<a name="ln3959">    return line;</a>
<a name="ln3960">  }</a>
<a name="ln3961"> </a>
<a name="ln3962">  lead_len = get_leader_len(line, &amp;comment_flags, false, include_space);</a>
<a name="ln3963"> </a>
<a name="ln3964">  if (lead_len == 0) {</a>
<a name="ln3965">    return line;</a>
<a name="ln3966">  }</a>
<a name="ln3967"> </a>
<a name="ln3968">  // Find:</a>
<a name="ln3969">  // - COM_END,</a>
<a name="ln3970">  // - colon,</a>
<a name="ln3971">  // whichever comes first.</a>
<a name="ln3972">  while (*comment_flags) {</a>
<a name="ln3973">    if (*comment_flags == COM_END</a>
<a name="ln3974">        || *comment_flags == ':') {</a>
<a name="ln3975">      break;</a>
<a name="ln3976">    }</a>
<a name="ln3977">    comment_flags++;</a>
<a name="ln3978">  }</a>
<a name="ln3979"> </a>
<a name="ln3980">  // If we found a colon, it means that we are not processing a line</a>
<a name="ln3981">  // starting with a closing part of a three-part comment. That's good,</a>
<a name="ln3982">  // because we don't want to remove those as this would be annoying.</a>
<a name="ln3983">  if (*comment_flags == ':' || *comment_flags == NUL) {</a>
<a name="ln3984">    line += lead_len;</a>
<a name="ln3985">  }</a>
<a name="ln3986"> </a>
<a name="ln3987">  return line;</a>
<a name="ln3988">}</a>
<a name="ln3989"> </a>
<a name="ln3990">/// @param count              number of lines (minimal 2) to join at cursor position.</a>
<a name="ln3991">/// @param save_undo          when true, save lines for undo first.</a>
<a name="ln3992">/// @param use_formatoptions  set to false when e.g. processing backspace and comment</a>
<a name="ln3993">///                           leaders should not be removed.</a>
<a name="ln3994">/// @param setmark            when true, sets the '[ and '] mark, else, the caller is expected</a>
<a name="ln3995">///                           to set those marks.</a>
<a name="ln3996">///</a>
<a name="ln3997">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln3998">int do_join(size_t count, int insert_space, int save_undo, int use_formatoptions, bool setmark)</a>
<a name="ln3999">{</a>
<a name="ln4000">  char *curr = NULL;</a>
<a name="ln4001">  char *curr_start = NULL;</a>
<a name="ln4002">  char *cend;</a>
<a name="ln4003">  char *newp;</a>
<a name="ln4004">  char *spaces;          // number of spaces inserted before a line</a>
<a name="ln4005">  int endcurr1 = NUL;</a>
<a name="ln4006">  int endcurr2 = NUL;</a>
<a name="ln4007">  int currsize = 0;             // size of the current line</a>
<a name="ln4008">  int sumsize = 0;              // size of the long new line</a>
<a name="ln4009">  linenr_T t;</a>
<a name="ln4010">  colnr_T col = 0;</a>
<a name="ln4011">  int ret = OK;</a>
<a name="ln4012">  int *comments = NULL;</a>
<a name="ln4013">  int remove_comments = (use_formatoptions == true)</a>
<a name="ln4014">                        &amp;&amp; has_format_option(FO_REMOVE_COMS);</a>
<a name="ln4015">  bool prev_was_comment = false;</a>
<a name="ln4016">  assert(count &gt;= 1);</a>
<a name="ln4017"> </a>
<a name="ln4018">  if (save_undo &amp;&amp; u_save(curwin-&gt;w_cursor.lnum - 1,</a>
<a name="ln4019">                          curwin-&gt;w_cursor.lnum + (linenr_T)count) == FAIL) {</a>
<a name="ln4020">    return FAIL;</a>
<a name="ln4021">  }</a>
<a name="ln4022">  // Allocate an array to store the number of spaces inserted before each</a>
<a name="ln4023">  // line.  We will use it to pre-compute the length of the new line and the</a>
<a name="ln4024">  // proper placement of each original line in the new one.</a>
<a name="ln4025">  spaces = xcalloc(count, 1);</a>
<a name="ln4026">  if (remove_comments) {</a>
<a name="ln4027">    comments = xcalloc(count, sizeof(*comments));</a>
<a name="ln4028">  }</a>
<a name="ln4029"> </a>
<a name="ln4030">  // Don't move anything, just compute the final line length</a>
<a name="ln4031">  // and setup the array of space strings lengths</a>
<a name="ln4032">  for (t = 0; t &lt; (linenr_T)count; t++) {</a>
<a name="ln4033">    curr_start = ml_get(curwin-&gt;w_cursor.lnum + t);</a>
<a name="ln4034">    curr = curr_start;</a>
<a name="ln4035">    if (t == 0 &amp;&amp; setmark &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4036">      // Set the '[ mark.</a>
<a name="ln4037">      curwin-&gt;w_buffer-&gt;b_op_start.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4038">      curwin-&gt;w_buffer-&gt;b_op_start.col = (colnr_T)strlen(curr);</a>
<a name="ln4039">    }</a>
<a name="ln4040">    if (remove_comments) {</a>
<a name="ln4041">      // We don't want to remove the comment leader if the</a>
<a name="ln4042">      // previous line is not a comment.</a>
<a name="ln4043">      if (t &gt; 0 &amp;&amp; prev_was_comment) {</a>
<a name="ln4044">        char *new_curr = skip_comment(curr, true, insert_space, &amp;prev_was_comment);</a>
<a name="ln4045">        comments[t] = (int)(new_curr - curr);</a>
<a name="ln4046">        curr = new_curr;</a>
<a name="ln4047">      } else {</a>
<a name="ln4048">        curr = skip_comment(curr, false, insert_space, &amp;prev_was_comment);</a>
<a name="ln4049">      }</a>
<a name="ln4050">    }</a>
<a name="ln4051"> </a>
<a name="ln4052">    if (insert_space &amp;&amp; t &gt; 0) {</a>
<a name="ln4053">      curr = skipwhite(curr);</a>
<a name="ln4054">      if (*curr != NUL</a>
<a name="ln4055">          &amp;&amp; *curr != ')'</a>
<a name="ln4056">          &amp;&amp; sumsize != 0</a>
<a name="ln4057">          &amp;&amp; endcurr1 != TAB</a>
<a name="ln4058">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN)</a>
<a name="ln4059">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; endcurr1 &lt; 0x100))</a>
<a name="ln4060">          &amp;&amp; (!has_format_option(FO_MBYTE_JOIN2)</a>
<a name="ln4061">              || (utf_ptr2char(curr) &lt; 0x100 &amp;&amp; !utf_eat_space(endcurr1))</a>
<a name="ln4062">              || (endcurr1 &lt; 0x100</a>
<a name="ln4063">                  &amp;&amp; !utf_eat_space(utf_ptr2char(curr))))) {</a>
<a name="ln4064">        // don't add a space if the line is ending in a space</a>
<a name="ln4065">        if (endcurr1 == ' ') {</a>
<a name="ln4066">          endcurr1 = endcurr2;</a>
<a name="ln4067">        } else {</a>
<a name="ln4068">          spaces[t]++;</a>
<a name="ln4069">        }</a>
<a name="ln4070">        // Extra space when 'joinspaces' set and line ends in '.', '?', or '!'.</a>
<a name="ln4071">        if (p_js &amp;&amp; (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {</a>
<a name="ln4072">          spaces[t]++;</a>
<a name="ln4073">        }</a>
<a name="ln4074">      }</a>
<a name="ln4075">    }</a>
<a name="ln4076"> </a>
<a name="ln4077">    if (t &gt; 0 &amp;&amp; curbuf_splice_pending == 0) {</a>
<a name="ln4078">      colnr_T removed = (int)(curr - curr_start);</a>
<a name="ln4079">      extmark_splice(curbuf, (int)curwin-&gt;w_cursor.lnum - 1, sumsize,</a>
<a name="ln4080">                     1, removed, removed + 1,</a>
<a name="ln4081">                     0, spaces[t], spaces[t],</a>
<a name="ln4082">                     kExtmarkUndo);</a>
<a name="ln4083">    }</a>
<a name="ln4084">    currsize = (int)strlen(curr);</a>
<a name="ln4085">    sumsize += currsize + spaces[t];</a>
<a name="ln4086">    endcurr1 = endcurr2 = NUL;</a>
<a name="ln4087">    if (insert_space &amp;&amp; currsize &gt; 0) {</a>
<a name="ln4088">      cend = curr + currsize;</a>
<a name="ln4089">      MB_PTR_BACK(curr, cend);</a>
<a name="ln4090">      endcurr1 = utf_ptr2char(cend);</a>
<a name="ln4091">      if (cend &gt; curr) {</a>
<a name="ln4092">        MB_PTR_BACK(curr, cend);</a>
<a name="ln4093">        endcurr2 = utf_ptr2char(cend);</a>
<a name="ln4094">      }</a>
<a name="ln4095">    }</a>
<a name="ln4096">    line_breakcheck();</a>
<a name="ln4097">    if (got_int) {</a>
<a name="ln4098">      ret = FAIL;</a>
<a name="ln4099">      goto theend;</a>
<a name="ln4100">    }</a>
<a name="ln4101">  }</a>
<a name="ln4102"> </a>
<a name="ln4103">  // store the column position before last line</a>
<a name="ln4104">  col = sumsize - currsize - spaces[count - 1];</a>
<a name="ln4105"> </a>
<a name="ln4106">  // allocate the space for the new line</a>
<a name="ln4107">  newp = xmalloc((size_t)sumsize + 1);</a>
<a name="ln4108">  cend = newp + sumsize;</a>
<a name="ln4109">  *cend = 0;</a>
<a name="ln4110"> </a>
<a name="ln4111">  // Move affected lines to the new long one.</a>
<a name="ln4112">  //</a>
<a name="ln4113">  // Move marks from each deleted line to the joined line, adjusting the</a>
<a name="ln4114">  // column.  This is not Vi compatible, but Vi deletes the marks, thus that</a>
<a name="ln4115">  // should not really be a problem.</a>
<a name="ln4116"> </a>
<a name="ln4117">  curbuf_splice_pending++;</a>
<a name="ln4118"> </a>
<a name="ln4119">  for (t = (linenr_T)count - 1;; t--) {</a>
<a name="ln4120">    cend -= currsize;</a>
<a name="ln4121">    memmove(cend, curr, (size_t)currsize);</a>
<a name="ln4122">    if (spaces[t] &gt; 0) {</a>
<a name="ln4123">      cend -= spaces[t];</a>
<a name="ln4124">      memset(cend, ' ', (size_t)(spaces[t]));</a>
<a name="ln4125">    }</a>
<a name="ln4126"> </a>
<a name="ln4127">    // If deleting more spaces than adding, the cursor moves no more than</a>
<a name="ln4128">    // what is added if it is inside these spaces.</a>
<a name="ln4129">    const int spaces_removed = (int)((curr - curr_start) - spaces[t]);</a>
<a name="ln4130">    linenr_T lnum = curwin-&gt;w_cursor.lnum + t;</a>
<a name="ln4131">    colnr_T mincol = (colnr_T)0;</a>
<a name="ln4132">    linenr_T lnum_amount = -t;</a>
<a name="ln4133">    colnr_T col_amount = (colnr_T)(cend - newp - spaces_removed);</a>
<a name="ln4134"> </a>
<a name="ln4135">    mark_col_adjust(lnum, mincol, lnum_amount, col_amount, spaces_removed);</a>
<a name="ln4136"> </a>
<a name="ln4137">    if (t == 0) {</a>
<a name="ln4138">      break;</a>
<a name="ln4139">    }</a>
<a name="ln4140"> </a>
<a name="ln4141">    curr_start = ml_get((linenr_T)(curwin-&gt;w_cursor.lnum + t - 1));</a>
<a name="ln4142">    curr = curr_start;</a>
<a name="ln4143">    if (remove_comments) {</a>
<a name="ln4144">      curr += comments[t - 1];</a>
<a name="ln4145">    }</a>
<a name="ln4146">    if (insert_space &amp;&amp; t &gt; 1) {</a>
<a name="ln4147">      curr = skipwhite(curr);</a>
<a name="ln4148">    }</a>
<a name="ln4149">    currsize = (int)strlen(curr);</a>
<a name="ln4150">  }</a>
<a name="ln4151"> </a>
<a name="ln4152">  ml_replace(curwin-&gt;w_cursor.lnum, newp, false);</a>
<a name="ln4153"> </a>
<a name="ln4154">  if (setmark &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4155">    // Set the '] mark.</a>
<a name="ln4156">    curwin-&gt;w_buffer-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4157">    curwin-&gt;w_buffer-&gt;b_op_end.col = sumsize;</a>
<a name="ln4158">  }</a>
<a name="ln4159"> </a>
<a name="ln4160">  // Only report the change in the first line here, del_lines() will report</a>
<a name="ln4161">  // the deleted line.</a>
<a name="ln4162">  changed_lines(curwin-&gt;w_cursor.lnum, currsize,</a>
<a name="ln4163">                curwin-&gt;w_cursor.lnum + 1, 0L, true);</a>
<a name="ln4164"> </a>
<a name="ln4165">  // Delete following lines. To do this we move the cursor there</a>
<a name="ln4166">  // briefly, and then move it back. After del_lines() the cursor may</a>
<a name="ln4167">  // have moved up (last line deleted), so the current lnum is kept in t.</a>
<a name="ln4168">  t = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4169">  curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4170">  del_lines((long)count - 1, false);</a>
<a name="ln4171">  curwin-&gt;w_cursor.lnum = t;</a>
<a name="ln4172">  curbuf_splice_pending--;</a>
<a name="ln4173">  curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln4174"> </a>
<a name="ln4175">  // Set the cursor column:</a>
<a name="ln4176">  // Vi compatible: use the column of the first join</a>
<a name="ln4177">  // vim:             use the column of the last join</a>
<a name="ln4178">  curwin-&gt;w_cursor.col =</a>
<a name="ln4179">    (vim_strchr(p_cpo, CPO_JOINCOL) != NULL ? currsize : col);</a>
<a name="ln4180">  check_cursor_col();</a>
<a name="ln4181"> </a>
<a name="ln4182">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln4183">  curwin-&gt;w_set_curswant = true;</a>
<a name="ln4184"> </a>
<a name="ln4185">theend:</a>
<a name="ln4186">  xfree(spaces);</a>
<a name="ln4187">  if (remove_comments) {</a>
<a name="ln4188">    xfree(comments);</a>
<a name="ln4189">  }</a>
<a name="ln4190">  return ret;</a>
<a name="ln4191">}</a>
<a name="ln4192"> </a>
<a name="ln4193">/// Reset 'linebreak' and take care of side effects.</a>
<a name="ln4194">/// @return  the previous value, to be passed to restore_lbr().</a>
<a name="ln4195">static bool reset_lbr(void)</a>
<a name="ln4196">{</a>
<a name="ln4197">  if (!curwin-&gt;w_p_lbr) {</a>
<a name="ln4198">    return false;</a>
<a name="ln4199">  }</a>
<a name="ln4200">  // changing 'linebreak' may require w_virtcol to be updated</a>
<a name="ln4201">  curwin-&gt;w_p_lbr = false;</a>
<a name="ln4202">  curwin-&gt;w_valid &amp;= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);</a>
<a name="ln4203">  return true;</a>
<a name="ln4204">}</a>
<a name="ln4205"> </a>
<a name="ln4206">/// Restore 'linebreak' and take care of side effects.</a>
<a name="ln4207">static void restore_lbr(bool lbr_saved)</a>
<a name="ln4208">{</a>
<a name="ln4209">  if (curwin-&gt;w_p_lbr || !lbr_saved) {</a>
<a name="ln4210">    return;</a>
<a name="ln4211">  }</a>
<a name="ln4212"> </a>
<a name="ln4213">  // changing 'linebreak' may require w_virtcol to be updated</a>
<a name="ln4214">  curwin-&gt;w_p_lbr = true;</a>
<a name="ln4215">  curwin-&gt;w_valid &amp;= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL);</a>
<a name="ln4216">}</a>
<a name="ln4217"> </a>
<a name="ln4218">/// prepare a few things for block mode yank/delete/tilde</a>
<a name="ln4219">///</a>
<a name="ln4220">/// for delete:</a>
<a name="ln4221">/// - textlen includes the first/last char to be (partly) deleted</a>
<a name="ln4222">/// - start/endspaces is the number of columns that are taken by the</a>
<a name="ln4223">///   first/last deleted char minus the number of columns that have to be</a>
<a name="ln4224">///   deleted.</a>
<a name="ln4225">/// for yank and tilde:</a>
<a name="ln4226">/// - textlen includes the first/last char to be wholly yanked</a>
<a name="ln4227">/// - start/endspaces is the number of columns of the first/last yanked char</a>
<a name="ln4228">///   that are to be yanked.</a>
<a name="ln4229">static void block_prep(oparg_T *oap, struct block_def *bdp, linenr_T lnum, bool is_del)</a>
<a name="ln4230">{</a>
<a name="ln4231">  int incr = 0;</a>
<a name="ln4232">  char *pend;</a>
<a name="ln4233">  char *pstart;</a>
<a name="ln4234">  char *line;</a>
<a name="ln4235">  char *prev_pstart;</a>
<a name="ln4236">  char *prev_pend;</a>
<a name="ln4237">  // Avoid a problem with unwanted linebreaks in block mode.</a>
<a name="ln4238">  const bool lbr_saved = reset_lbr();</a>
<a name="ln4239"> </a>
<a name="ln4240">  bdp-&gt;startspaces = 0;</a>
<a name="ln4241">  bdp-&gt;endspaces = 0;</a>
<a name="ln4242">  bdp-&gt;textlen = 0;</a>
<a name="ln4243">  bdp-&gt;start_vcol = 0;</a>
<a name="ln4244">  bdp-&gt;end_vcol = 0;</a>
<a name="ln4245">  bdp-&gt;is_short = false;</a>
<a name="ln4246">  bdp-&gt;is_oneChar = false;</a>
<a name="ln4247">  bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4248">  bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4249">  bdp-&gt;end_char_vcols = 0;</a>
<a name="ln4250">  bdp-&gt;start_char_vcols = 0;</a>
<a name="ln4251"> </a>
<a name="ln4252">  line = ml_get(lnum);</a>
<a name="ln4253">  prev_pstart = line;</a>
<a name="ln4254"> </a>
<a name="ln4255">  chartabsize_T cts;</a>
<a name="ln4256">  init_chartabsize_arg(&amp;cts, curwin, lnum, bdp-&gt;start_vcol, line, line);</a>
<a name="ln4257">  while (cts.cts_vcol &lt; oap-&gt;start_vcol &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln4258">    // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln4259">    incr = lbr_chartabsize(&amp;cts);</a>
<a name="ln4260">    cts.cts_vcol += incr;</a>
<a name="ln4261">    if (ascii_iswhite(*cts.cts_ptr)) {</a>
<a name="ln4262">      bdp-&gt;pre_whitesp += incr;</a>
<a name="ln4263">      bdp-&gt;pre_whitesp_c++;</a>
<a name="ln4264">    } else {</a>
<a name="ln4265">      bdp-&gt;pre_whitesp = 0;</a>
<a name="ln4266">      bdp-&gt;pre_whitesp_c = 0;</a>
<a name="ln4267">    }</a>
<a name="ln4268">    prev_pstart = cts.cts_ptr;</a>
<a name="ln4269">    MB_PTR_ADV(cts.cts_ptr);</a>
<a name="ln4270">  }</a>
<a name="ln4271">  bdp-&gt;start_vcol = cts.cts_vcol;</a>
<a name="ln4272">  pstart = cts.cts_ptr;</a>
<a name="ln4273">  clear_chartabsize_arg(&amp;cts);</a>
<a name="ln4274"> </a>
<a name="ln4275">  bdp-&gt;start_char_vcols = incr;</a>
<a name="ln4276">  if (bdp-&gt;start_vcol &lt; oap-&gt;start_vcol) {      // line too short</a>
<a name="ln4277">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4278">    bdp-&gt;is_short = true;</a>
<a name="ln4279">    if (!is_del || oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4280">      bdp-&gt;endspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4281">    }</a>
<a name="ln4282">  } else {</a>
<a name="ln4283">    // notice: this converts partly selected Multibyte characters to</a>
<a name="ln4284">    // spaces, too.</a>
<a name="ln4285">    bdp-&gt;startspaces = bdp-&gt;start_vcol - oap-&gt;start_vcol;</a>
<a name="ln4286">    if (is_del &amp;&amp; bdp-&gt;startspaces) {</a>
<a name="ln4287">      bdp-&gt;startspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4288">    }</a>
<a name="ln4289">    pend = pstart;</a>
<a name="ln4290">    bdp-&gt;end_vcol = bdp-&gt;start_vcol;</a>
<a name="ln4291">    if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {  // it's all in one character</a>
<a name="ln4292">      bdp-&gt;is_oneChar = true;</a>
<a name="ln4293">      if (oap-&gt;op_type == OP_INSERT) {</a>
<a name="ln4294">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4295">      } else if (oap-&gt;op_type == OP_APPEND) {</a>
<a name="ln4296">        bdp-&gt;startspaces += oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4297">        bdp-&gt;endspaces = bdp-&gt;start_char_vcols - bdp-&gt;startspaces;</a>
<a name="ln4298">      } else {</a>
<a name="ln4299">        bdp-&gt;startspaces = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln4300">        if (is_del &amp;&amp; oap-&gt;op_type != OP_LSHIFT) {</a>
<a name="ln4301">          // just putting the sum of those two into</a>
<a name="ln4302">          // bdp-&gt;startspaces doesn't work for Visual replace,</a>
<a name="ln4303">          // so we have to split the tab in two</a>
<a name="ln4304">          bdp-&gt;startspaces = bdp-&gt;start_char_vcols</a>
<a name="ln4305">                             - (bdp-&gt;start_vcol - oap-&gt;start_vcol);</a>
<a name="ln4306">          bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4307">        }</a>
<a name="ln4308">      }</a>
<a name="ln4309">    } else {</a>
<a name="ln4310">      init_chartabsize_arg(&amp;cts, curwin, lnum, bdp-&gt;end_vcol, line, pend);</a>
<a name="ln4311">      prev_pend = pend;</a>
<a name="ln4312">      while (cts.cts_vcol &lt;= oap-&gt;end_vcol &amp;&amp; *cts.cts_ptr != NUL) {</a>
<a name="ln4313">        // Count a tab for what it's worth (if list mode not on)</a>
<a name="ln4314">        prev_pend = cts.cts_ptr;</a>
<a name="ln4315">        incr = lbr_chartabsize_adv(&amp;cts);</a>
<a name="ln4316">        cts.cts_vcol += incr;</a>
<a name="ln4317">      }</a>
<a name="ln4318">      bdp-&gt;end_vcol = cts.cts_vcol;</a>
<a name="ln4319">      pend = cts.cts_ptr;</a>
<a name="ln4320">      clear_chartabsize_arg(&amp;cts);</a>
<a name="ln4321"> </a>
<a name="ln4322">      if (bdp-&gt;end_vcol &lt;= oap-&gt;end_vcol</a>
<a name="ln4323">          &amp;&amp; (!is_del</a>
<a name="ln4324">              || oap-&gt;op_type == OP_APPEND</a>
<a name="ln4325">              || oap-&gt;op_type == OP_REPLACE)) {  // line too short</a>
<a name="ln4326">        bdp-&gt;is_short = true;</a>
<a name="ln4327">        // Alternative: include spaces to fill up the block.</a>
<a name="ln4328">        // Disadvantage: can lead to trailing spaces when the line is</a>
<a name="ln4329">        // short where the text is put</a>
<a name="ln4330">        // if (!is_del || oap-&gt;op_type == OP_APPEND)</a>
<a name="ln4331">        if (oap-&gt;op_type == OP_APPEND || virtual_op) {</a>
<a name="ln4332">          bdp-&gt;endspaces = oap-&gt;end_vcol - bdp-&gt;end_vcol</a>
<a name="ln4333">                           + oap-&gt;inclusive;</a>
<a name="ln4334">        }</a>
<a name="ln4335">      } else if (bdp-&gt;end_vcol &gt; oap-&gt;end_vcol) {</a>
<a name="ln4336">        bdp-&gt;endspaces = bdp-&gt;end_vcol - oap-&gt;end_vcol - 1;</a>
<a name="ln4337">        if (!is_del &amp;&amp; bdp-&gt;endspaces) {</a>
<a name="ln4338">          bdp-&gt;endspaces = incr - bdp-&gt;endspaces;</a>
<a name="ln4339">          if (pend != pstart) {</a>
<a name="ln4340">            pend = prev_pend;</a>
<a name="ln4341">          }</a>
<a name="ln4342">        }</a>
<a name="ln4343">      }</a>
<a name="ln4344">    }</a>
<a name="ln4345">    bdp-&gt;end_char_vcols = incr;</a>
<a name="ln4346">    if (is_del &amp;&amp; bdp-&gt;startspaces) {</a>
<a name="ln4347">      pstart = prev_pstart;</a>
<a name="ln4348">    }</a>
<a name="ln4349">    bdp-&gt;textlen = (int)(pend - pstart);</a>
<a name="ln4350">  }</a>
<a name="ln4351">  bdp-&gt;textcol = (colnr_T)(pstart - line);</a>
<a name="ln4352">  bdp-&gt;textstart = pstart;</a>
<a name="ln4353">  restore_lbr(lbr_saved);</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">/// Handle the add/subtract operator.</a>
<a name="ln4357">///</a>
<a name="ln4358">/// @param[in]  oap      Arguments of operator.</a>
<a name="ln4359">/// @param[in]  Prenum1  Amount of addition or subtraction.</a>
<a name="ln4360">/// @param[in]  g_cmd    Prefixed with `g`.</a>
<a name="ln4361">void op_addsub(oparg_T *oap, linenr_T Prenum1, bool g_cmd)</a>
<a name="ln4362">{</a>
<a name="ln4363">  pos_T pos;</a>
<a name="ln4364">  struct block_def bd;</a>
<a name="ln4365">  ssize_t change_cnt = 0;</a>
<a name="ln4366">  linenr_T amount = Prenum1;</a>
<a name="ln4367"> </a>
<a name="ln4368">  // do_addsub() might trigger re-evaluation of 'foldexpr' halfway, when the</a>
<a name="ln4369">  // buffer is not completely updated yet. Postpone updating folds until before</a>
<a name="ln4370">  // the call to changed_lines().</a>
<a name="ln4371">  disable_fold_update++;</a>
<a name="ln4372"> </a>
<a name="ln4373">  if (!VIsual_active) {</a>
<a name="ln4374">    pos = curwin-&gt;w_cursor;</a>
<a name="ln4375">    if (u_save_cursor() == FAIL) {</a>
<a name="ln4376">      disable_fold_update--;</a>
<a name="ln4377">      return;</a>
<a name="ln4378">    }</a>
<a name="ln4379">    change_cnt = do_addsub(oap-&gt;op_type, &amp;pos, 0, amount);</a>
<a name="ln4380">    disable_fold_update--;</a>
<a name="ln4381">    if (change_cnt) {</a>
<a name="ln4382">      changed_lines(pos.lnum, 0, pos.lnum + 1, 0L, true);</a>
<a name="ln4383">    }</a>
<a name="ln4384">  } else {</a>
<a name="ln4385">    int length;</a>
<a name="ln4386">    pos_T startpos;</a>
<a name="ln4387"> </a>
<a name="ln4388">    if (u_save((linenr_T)(oap-&gt;start.lnum - 1),</a>
<a name="ln4389">               (linenr_T)(oap-&gt;end.lnum + 1)) == FAIL) {</a>
<a name="ln4390">      disable_fold_update--;</a>
<a name="ln4391">      return;</a>
<a name="ln4392">    }</a>
<a name="ln4393"> </a>
<a name="ln4394">    pos = oap-&gt;start;</a>
<a name="ln4395">    for (; pos.lnum &lt;= oap-&gt;end.lnum; pos.lnum++) {</a>
<a name="ln4396">      if (oap-&gt;motion_type == kMTBlockWise) {</a>
<a name="ln4397">        // Visual block mode</a>
<a name="ln4398">        block_prep(oap, &amp;bd, pos.lnum, false);</a>
<a name="ln4399">        pos.col = bd.textcol;</a>
<a name="ln4400">        length = bd.textlen;</a>
<a name="ln4401">      } else if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln4402">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4403">        pos.col = 0;</a>
<a name="ln4404">        length = (colnr_T)strlen(ml_get(pos.lnum));</a>
<a name="ln4405">      } else {</a>
<a name="ln4406">        // oap-&gt;motion_type == kMTCharWise</a>
<a name="ln4407">        if (pos.lnum == oap-&gt;start.lnum &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln4408">          dec(&amp;(oap-&gt;end));</a>
<a name="ln4409">        }</a>
<a name="ln4410">        length = (colnr_T)strlen(ml_get(pos.lnum));</a>
<a name="ln4411">        pos.col = 0;</a>
<a name="ln4412">        if (pos.lnum == oap-&gt;start.lnum) {</a>
<a name="ln4413">          pos.col += oap-&gt;start.col;</a>
<a name="ln4414">          length -= oap-&gt;start.col;</a>
<a name="ln4415">        }</a>
<a name="ln4416">        if (pos.lnum == oap-&gt;end.lnum) {</a>
<a name="ln4417">          length = (int)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln4418">          if (oap-&gt;end.col &gt;= length) {</a>
<a name="ln4419">            oap-&gt;end.col = length - 1;</a>
<a name="ln4420">          }</a>
<a name="ln4421">          length = oap-&gt;end.col - pos.col + 1;</a>
<a name="ln4422">        }</a>
<a name="ln4423">      }</a>
<a name="ln4424">      int one_change = do_addsub(oap-&gt;op_type, &amp;pos, length, amount);</a>
<a name="ln4425">      if (one_change) {</a>
<a name="ln4426">        // Remember the start position of the first change.</a>
<a name="ln4427">        if (change_cnt == 0) {</a>
<a name="ln4428">          startpos = curbuf-&gt;b_op_start;</a>
<a name="ln4429">        }</a>
<a name="ln4430">        change_cnt++;</a>
<a name="ln4431">      }</a>
<a name="ln4432"> </a>
<a name="ln4433">      if (g_cmd &amp;&amp; one_change) {</a>
<a name="ln4434">        amount += Prenum1;</a>
<a name="ln4435">      }</a>
<a name="ln4436">    }</a>
<a name="ln4437"> </a>
<a name="ln4438">    disable_fold_update--;</a>
<a name="ln4439">    if (change_cnt) {</a>
<a name="ln4440">      changed_lines(oap-&gt;start.lnum, 0, oap-&gt;end.lnum + 1, 0L, true);</a>
<a name="ln4441">    }</a>
<a name="ln4442"> </a>
<a name="ln4443">    if (!change_cnt &amp;&amp; oap-&gt;is_VIsual) {</a>
<a name="ln4444">      // No change: need to remove the Visual selection</a>
<a name="ln4445">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln4446">    }</a>
<a name="ln4447"> </a>
<a name="ln4448">    // Set '[ mark if something changed. Keep the last end</a>
<a name="ln4449">    // position from do_addsub().</a>
<a name="ln4450">    if (change_cnt &gt; 0 &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4451">      curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4452">    }</a>
<a name="ln4453"> </a>
<a name="ln4454">    if (change_cnt &gt; p_report) {</a>
<a name="ln4455">      smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; lines changed&quot;,</a>
<a name="ln4456">                    &quot;%&quot; PRId64 &quot; lines changed&quot;, change_cnt),</a>
<a name="ln4457">           (int64_t)change_cnt);</a>
<a name="ln4458">    }</a>
<a name="ln4459">  }</a>
<a name="ln4460">}</a>
<a name="ln4461"> </a>
<a name="ln4462">/// Add or subtract from a number in a line.</a>
<a name="ln4463">///</a>
<a name="ln4464">/// @param op_type OP_NR_ADD or OP_NR_SUB.</a>
<a name="ln4465">/// @param pos     Cursor position.</a>
<a name="ln4466">/// @param length  Target number length.</a>
<a name="ln4467">/// @param Prenum1 Amount of addition or subtraction.</a>
<a name="ln4468">///</a>
<a name="ln4469">/// @return true if some character was changed.</a>
<a name="ln4470">int do_addsub(int op_type, pos_T *pos, int length, linenr_T Prenum1)</a>
<a name="ln4471">{</a>
<a name="ln4472">  int col;</a>
<a name="ln4473">  char *buf1 = NULL;</a>
<a name="ln4474">  char buf2[NUMBUFLEN];</a>
<a name="ln4475">  int pre;  // 'X' or 'x': hex; '0': octal; 'B' or 'b': bin</a>
<a name="ln4476">  static bool hexupper = false;  // 0xABC</a>
<a name="ln4477">  uvarnumber_T n;</a>
<a name="ln4478">  uvarnumber_T oldn;</a>
<a name="ln4479">  char *ptr;</a>
<a name="ln4480">  int c;</a>
<a name="ln4481">  int todel;</a>
<a name="ln4482">  int firstdigit;</a>
<a name="ln4483">  bool negative = false;</a>
<a name="ln4484">  bool was_positive = true;</a>
<a name="ln4485">  bool visual = VIsual_active;</a>
<a name="ln4486">  bool did_change = false;</a>
<a name="ln4487">  pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4488">  int maxlen = 0;</a>
<a name="ln4489">  pos_T startpos;</a>
<a name="ln4490">  pos_T endpos;</a>
<a name="ln4491">  colnr_T save_coladd = 0;</a>
<a name="ln4492"> </a>
<a name="ln4493">  const bool do_hex = vim_strchr(curbuf-&gt;b_p_nf, 'x') != NULL;    // &quot;heX&quot;</a>
<a name="ln4494">  const bool do_oct = vim_strchr(curbuf-&gt;b_p_nf, 'o') != NULL;    // &quot;Octal&quot;</a>
<a name="ln4495">  const bool do_bin = vim_strchr(curbuf-&gt;b_p_nf, 'b') != NULL;    // &quot;Bin&quot;</a>
<a name="ln4496">  const bool do_alpha = vim_strchr(curbuf-&gt;b_p_nf, 'p') != NULL;  // &quot;alPha&quot;</a>
<a name="ln4497">  // &quot;Unsigned&quot;</a>
<a name="ln4498">  const bool do_unsigned = vim_strchr(curbuf-&gt;b_p_nf, 'u') != NULL;</a>
<a name="ln4499"> </a>
<a name="ln4500">  if (virtual_active()) {</a>
<a name="ln4501">    save_coladd = pos-&gt;coladd;</a>
<a name="ln4502">    pos-&gt;coladd = 0;</a>
<a name="ln4503">  }</a>
<a name="ln4504"> </a>
<a name="ln4505">  curwin-&gt;w_cursor = *pos;</a>
<a name="ln4506">  ptr = ml_get(pos-&gt;lnum);</a>
<a name="ln4507">  col = pos-&gt;col;</a>
<a name="ln4508"> </a>
<a name="ln4509">  if (*ptr == NUL || col + !!save_coladd &gt;= (int)strlen(ptr)) {</a>
<a name="ln4510">    goto theend;</a>
<a name="ln4511">  }</a>
<a name="ln4512"> </a>
<a name="ln4513">  // First check if we are on a hexadecimal number, after the &quot;0x&quot;.</a>
<a name="ln4514">  if (!VIsual_active) {</a>
<a name="ln4515">    if (do_bin) {</a>
<a name="ln4516">      while (col &gt; 0 &amp;&amp; ascii_isbdigit(ptr[col])) {</a>
<a name="ln4517">        col--;</a>
<a name="ln4518">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4519">      }</a>
<a name="ln4520">    }</a>
<a name="ln4521"> </a>
<a name="ln4522">    if (do_hex) {</a>
<a name="ln4523">      while (col &gt; 0 &amp;&amp; ascii_isxdigit(ptr[col])) {</a>
<a name="ln4524">        col--;</a>
<a name="ln4525">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4526">      }</a>
<a name="ln4527">    }</a>
<a name="ln4528">    if (do_bin</a>
<a name="ln4529">        &amp;&amp; do_hex</a>
<a name="ln4530">        &amp;&amp; !((col &gt; 0</a>
<a name="ln4531">              &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4532">              &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4533">              &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4534">              &amp;&amp; ascii_isxdigit(ptr[col + 1])))) {</a>
<a name="ln4535">      // In case of binary/hexadecimal pattern overlap match, rescan</a>
<a name="ln4536"> </a>
<a name="ln4537">      col = curwin-&gt;w_cursor.col;</a>
<a name="ln4538"> </a>
<a name="ln4539">      while (col &gt; 0 &amp;&amp; ascii_isdigit(ptr[col])) {</a>
<a name="ln4540">        col--;</a>
<a name="ln4541">        col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4542">      }</a>
<a name="ln4543">    }</a>
<a name="ln4544"> </a>
<a name="ln4545">    if ((do_hex</a>
<a name="ln4546">         &amp;&amp; col &gt; 0</a>
<a name="ln4547">         &amp;&amp; (ptr[col] == 'X' || ptr[col] == 'x')</a>
<a name="ln4548">         &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4549">         &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4550">         &amp;&amp; ascii_isxdigit(ptr[col + 1]))</a>
<a name="ln4551">        || (do_bin</a>
<a name="ln4552">            &amp;&amp; col &gt; 0</a>
<a name="ln4553">            &amp;&amp; (ptr[col] == 'B' || ptr[col] == 'b')</a>
<a name="ln4554">            &amp;&amp; ptr[col - 1] == '0'</a>
<a name="ln4555">            &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4556">            &amp;&amp; ascii_isbdigit(ptr[col + 1]))) {</a>
<a name="ln4557">      // Found hexadecimal or binary number, move to its start.</a>
<a name="ln4558">      col--;</a>
<a name="ln4559">      col -= utf_head_off(ptr, ptr + col);</a>
<a name="ln4560">    } else {</a>
<a name="ln4561">      // Search forward and then backward to find the start of number.</a>
<a name="ln4562">      col = pos-&gt;col;</a>
<a name="ln4563"> </a>
<a name="ln4564">      while (ptr[col] != NUL</a>
<a name="ln4565">             &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4566">             &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4567">        col++;</a>
<a name="ln4568">      }</a>
<a name="ln4569"> </a>
<a name="ln4570">      while (col &gt; 0</a>
<a name="ln4571">             &amp;&amp; ascii_isdigit(ptr[col - 1])</a>
<a name="ln4572">             &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4573">        col--;</a>
<a name="ln4574">      }</a>
<a name="ln4575">    }</a>
<a name="ln4576">  }</a>
<a name="ln4577"> </a>
<a name="ln4578">  if (visual) {</a>
<a name="ln4579">    while (ptr[col] != NUL &amp;&amp; length &gt; 0 &amp;&amp; !ascii_isdigit(ptr[col])</a>
<a name="ln4580">           &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(ptr[col]))) {</a>
<a name="ln4581">      int mb_len = utfc_ptr2len(ptr + col);</a>
<a name="ln4582"> </a>
<a name="ln4583">      col += mb_len;</a>
<a name="ln4584">      length -= mb_len;</a>
<a name="ln4585">    }</a>
<a name="ln4586"> </a>
<a name="ln4587">    if (length == 0) {</a>
<a name="ln4588">      goto theend;</a>
<a name="ln4589">    }</a>
<a name="ln4590"> </a>
<a name="ln4591">    if (col &gt; pos-&gt;col &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4592">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4593">        &amp;&amp; !do_unsigned) {</a>
<a name="ln4594">      negative = true;</a>
<a name="ln4595">      was_positive = false;</a>
<a name="ln4596">    }</a>
<a name="ln4597">  }</a>
<a name="ln4598"> </a>
<a name="ln4599">  // If a number was found, and saving for undo works, replace the number.</a>
<a name="ln4600">  firstdigit = (uint8_t)ptr[col];</a>
<a name="ln4601">  if (!ascii_isdigit(firstdigit) &amp;&amp; !(do_alpha &amp;&amp; ASCII_ISALPHA(firstdigit))) {</a>
<a name="ln4602">    beep_flush();</a>
<a name="ln4603">    goto theend;</a>
<a name="ln4604">  }</a>
<a name="ln4605"> </a>
<a name="ln4606">  if (do_alpha &amp;&amp; ASCII_ISALPHA(firstdigit)) {</a>
<a name="ln4607">    // decrement or increment alphabetic character</a>
<a name="ln4608">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4609">      if (CHAR_ORD(firstdigit) &lt; Prenum1) {</a>
<a name="ln4610">        if (isupper(firstdigit)) {</a>
<a name="ln4611">          firstdigit = 'A';</a>
<a name="ln4612">        } else {</a>
<a name="ln4613">          firstdigit = 'a';</a>
<a name="ln4614">        }</a>
<a name="ln4615">      } else {</a>
<a name="ln4616">        firstdigit -= (int)Prenum1;</a>
<a name="ln4617">      }</a>
<a name="ln4618">    } else {</a>
<a name="ln4619">      if (26 - CHAR_ORD(firstdigit) - 1 &lt; Prenum1) {</a>
<a name="ln4620">        if (isupper(firstdigit)) {</a>
<a name="ln4621">          firstdigit = 'Z';</a>
<a name="ln4622">        } else {</a>
<a name="ln4623">          firstdigit = 'z';</a>
<a name="ln4624">        }</a>
<a name="ln4625">      } else {</a>
<a name="ln4626">        firstdigit += (int)Prenum1;</a>
<a name="ln4627">      }</a>
<a name="ln4628">    }</a>
<a name="ln4629">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4630">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4631">    did_change = true;</a>
<a name="ln4632">    (void)del_char(false);</a>
<a name="ln4633">    ins_char(firstdigit);</a>
<a name="ln4634">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4635">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4636">  } else {</a>
<a name="ln4637">    if (col &gt; 0 &amp;&amp; ptr[col - 1] == '-'</a>
<a name="ln4638">        &amp;&amp; !utf_head_off(ptr, ptr + col - 1)</a>
<a name="ln4639">        &amp;&amp; !visual</a>
<a name="ln4640">        &amp;&amp; !do_unsigned) {</a>
<a name="ln4641">      // negative number</a>
<a name="ln4642">      col--;</a>
<a name="ln4643">      negative = true;</a>
<a name="ln4644">    }</a>
<a name="ln4645"> </a>
<a name="ln4646">    // get the number value (unsigned)</a>
<a name="ln4647">    if (visual &amp;&amp; VIsual_mode != 'V') {</a>
<a name="ln4648">      maxlen = (curbuf-&gt;b_visual.vi_curswant == MAXCOL</a>
<a name="ln4649">                ? (int)strlen(ptr) - col</a>
<a name="ln4650">                : length);</a>
<a name="ln4651">    }</a>
<a name="ln4652"> </a>
<a name="ln4653">    bool overflow = false;</a>
<a name="ln4654">    vim_str2nr(ptr + col, &amp;pre, &amp;length,</a>
<a name="ln4655">               0 + (do_bin ? STR2NR_BIN : 0)</a>
<a name="ln4656">               + (do_oct ? STR2NR_OCT : 0)</a>
<a name="ln4657">               + (do_hex ? STR2NR_HEX : 0),</a>
<a name="ln4658">               NULL, &amp;n, maxlen, false, &amp;overflow);</a>
<a name="ln4659"> </a>
<a name="ln4660">    // ignore leading '-' for hex, octal and bin numbers</a>
<a name="ln4661">    if (pre &amp;&amp; negative) {</a>
<a name="ln4662">      col++;</a>
<a name="ln4663">      length--;</a>
<a name="ln4664">      negative = false;</a>
<a name="ln4665">    }</a>
<a name="ln4666"> </a>
<a name="ln4667">    // add or subtract</a>
<a name="ln4668">    bool subtract = false;</a>
<a name="ln4669">    if (op_type == OP_NR_SUB) {</a>
<a name="ln4670">      subtract ^= true;</a>
<a name="ln4671">    }</a>
<a name="ln4672">    if (negative) {</a>
<a name="ln4673">      subtract ^= true;</a>
<a name="ln4674">    }</a>
<a name="ln4675"> </a>
<a name="ln4676">    oldn = n;</a>
<a name="ln4677"> </a>
<a name="ln4678">    if (!overflow) {  // if number is too big don't add/subtract</a>
<a name="ln4679">      n = subtract ? n - (uvarnumber_T)Prenum1</a>
<a name="ln4680">                   : n + (uvarnumber_T)Prenum1;</a>
<a name="ln4681">    }</a>
<a name="ln4682"> </a>
<a name="ln4683">    // handle wraparound for decimal numbers</a>
<a name="ln4684">    if (!pre) {</a>
<a name="ln4685">      if (subtract) {</a>
<a name="ln4686">        if (n &gt; oldn) {</a>
<a name="ln4687">          n = 1 + (n ^ (uvarnumber_T) - 1);</a>
<a name="ln4688">          negative ^= true;</a>
<a name="ln4689">        }</a>
<a name="ln4690">      } else {</a>
<a name="ln4691">        // add</a>
<a name="ln4692">        if (n &lt; oldn) {</a>
<a name="ln4693">          n = (n ^ (uvarnumber_T) - 1);</a>
<a name="ln4694">          negative ^= true;</a>
<a name="ln4695">        }</a>
<a name="ln4696">      }</a>
<a name="ln4697">      if (n == 0) {</a>
<a name="ln4698">        negative = false;</a>
<a name="ln4699">      }</a>
<a name="ln4700">    }</a>
<a name="ln4701"> </a>
<a name="ln4702">    if (do_unsigned &amp;&amp; negative) {</a>
<a name="ln4703">      if (subtract) {</a>
<a name="ln4704">        // sticking at zero.</a>
<a name="ln4705">        n = (uvarnumber_T)0;</a>
<a name="ln4706">      } else {</a>
<a name="ln4707">        // sticking at 2^64 - 1.</a>
<a name="ln4708">        n = (uvarnumber_T)(-1);</a>
<a name="ln4709">      }</a>
<a name="ln4710">      negative = false;</a>
<a name="ln4711">    }</a>
<a name="ln4712"> </a>
<a name="ln4713">    if (visual &amp;&amp; !was_positive &amp;&amp; !negative &amp;&amp; col &gt; 0) {</a>
<a name="ln4714">      // need to remove the '-'</a>
<a name="ln4715">      col--;</a>
<a name="ln4716">      length++;</a>
<a name="ln4717">    }</a>
<a name="ln4718"> </a>
<a name="ln4719">    // Delete the old number.</a>
<a name="ln4720">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln4721">    startpos = curwin-&gt;w_cursor;</a>
<a name="ln4722">    did_change = true;</a>
<a name="ln4723">    todel = length;</a>
<a name="ln4724">    c = gchar_cursor();</a>
<a name="ln4725"> </a>
<a name="ln4726">    // Don't include the '-' in the length, only the length of the part</a>
<a name="ln4727">    // after it is kept the same.</a>
<a name="ln4728">    if (c == '-') {</a>
<a name="ln4729">      length--;</a>
<a name="ln4730">    }</a>
<a name="ln4731">    while (todel-- &gt; 0) {</a>
<a name="ln4732">      if (c &lt; 0x100 &amp;&amp; isalpha(c)) {</a>
<a name="ln4733">        if (isupper(c)) {</a>
<a name="ln4734">          hexupper = true;</a>
<a name="ln4735">        } else {</a>
<a name="ln4736">          hexupper = false;</a>
<a name="ln4737">        }</a>
<a name="ln4738">      }</a>
<a name="ln4739">      // del_char() will mark line needing displaying</a>
<a name="ln4740">      (void)del_char(false);</a>
<a name="ln4741">      c = gchar_cursor();</a>
<a name="ln4742">    }</a>
<a name="ln4743"> </a>
<a name="ln4744">    // Prepare the leading characters in buf1[].</a>
<a name="ln4745">    // When there are many leading zeros it could be very long.</a>
<a name="ln4746">    // Allocate a bit too much.</a>
<a name="ln4747">    buf1 = xmalloc((size_t)length + NUMBUFLEN);</a>
<a name="ln4748">    ptr = buf1;</a>
<a name="ln4749">    if (negative &amp;&amp; (!visual || was_positive)) {</a>
<a name="ln4750">      *ptr++ = '-';</a>
<a name="ln4751">    }</a>
<a name="ln4752">    if (pre) {</a>
<a name="ln4753">      *ptr++ = '0';</a>
<a name="ln4754">      length--;</a>
<a name="ln4755">    }</a>
<a name="ln4756">    if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') {</a>
<a name="ln4757">      *ptr++ = (char)pre;</a>
<a name="ln4758">      length--;</a>
<a name="ln4759">    }</a>
<a name="ln4760"> </a>
<a name="ln4761">    // Put the number characters in buf2[].</a>
<a name="ln4762">    if (pre == 'b' || pre == 'B') {</a>
<a name="ln4763">      size_t bits = 0;</a>
<a name="ln4764">      size_t i = 0;</a>
<a name="ln4765"> </a>
<a name="ln4766">      // leading zeros</a>
<a name="ln4767">      for (bits = 8 * sizeof(n); bits &gt; 0; bits--) {</a>
<a name="ln4768">        if ((n &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln4769">          break;</a>
<a name="ln4770">        }</a>
<a name="ln4771">      }</a>
<a name="ln4772"> </a>
<a name="ln4773">      while (bits &gt; 0) {</a>
<a name="ln4774">        buf2[i++] = ((n &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln4775">      }</a>
<a name="ln4776"> </a>
<a name="ln4777">      buf2[i] = '\0';</a>
<a name="ln4778">    } else if (pre == 0) {</a>
<a name="ln4779">      vim_snprintf(buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIu64, (uint64_t)n);</a>
<a name="ln4780">    } else if (pre == '0') {</a>
<a name="ln4781">      vim_snprintf(buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIo64, (uint64_t)n);</a>
<a name="ln4782">    } else if (hexupper) {</a>
<a name="ln4783">      vim_snprintf(buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIX64, (uint64_t)n);</a>
<a name="ln4784">    } else {</a>
<a name="ln4785">      vim_snprintf(buf2, ARRAY_SIZE(buf2), &quot;%&quot; PRIx64, (uint64_t)n);</a>
<a name="ln4786">    }</a>
<a name="ln4787">    length -= (int)strlen(buf2);</a>
<a name="ln4788"> </a>
<a name="ln4789">    // Adjust number of zeros to the new number of digits, so the</a>
<a name="ln4790">    // total length of the number remains the same.</a>
<a name="ln4791">    // Don't do this when</a>
<a name="ln4792">    // the result may look like an octal number.</a>
<a name="ln4793">    if (firstdigit == '0' &amp;&amp; !(do_oct &amp;&amp; pre == 0)) {</a>
<a name="ln4794">      while (length-- &gt; 0) {</a>
<a name="ln4795">        *ptr++ = '0';</a>
<a name="ln4796">      }</a>
<a name="ln4797">    }</a>
<a name="ln4798">    *ptr = NUL;</a>
<a name="ln4799">    STRCAT(buf1, buf2);</a>
<a name="ln4800">    ins_str(buf1);              // insert the new number</a>
<a name="ln4801">    endpos = curwin-&gt;w_cursor;</a>
<a name="ln4802">    if (curwin-&gt;w_cursor.col) {</a>
<a name="ln4803">      curwin-&gt;w_cursor.col--;</a>
<a name="ln4804">    }</a>
<a name="ln4805">  }</a>
<a name="ln4806"> </a>
<a name="ln4807">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4808">    // set the '[ and '] marks</a>
<a name="ln4809">    curbuf-&gt;b_op_start = startpos;</a>
<a name="ln4810">    curbuf-&gt;b_op_end = endpos;</a>
<a name="ln4811">    if (curbuf-&gt;b_op_end.col &gt; 0) {</a>
<a name="ln4812">      curbuf-&gt;b_op_end.col--;</a>
<a name="ln4813">    }</a>
<a name="ln4814">  }</a>
<a name="ln4815"> </a>
<a name="ln4816">theend:</a>
<a name="ln4817">  xfree(buf1);</a>
<a name="ln4818">  if (visual) {</a>
<a name="ln4819">    curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln4820">  } else if (did_change) {</a>
<a name="ln4821">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln4822">  } else if (virtual_active()) {</a>
<a name="ln4823">    curwin-&gt;w_cursor.coladd = save_coladd;</a>
<a name="ln4824">  }</a>
<a name="ln4825"> </a>
<a name="ln4826">  return did_change;</a>
<a name="ln4827">}</a>
<a name="ln4828"> </a>
<a name="ln4829">/// Used for getregtype()</a>
<a name="ln4830">///</a>
<a name="ln4831">/// @return  the type of a register or</a>
<a name="ln4832">///          kMTUnknown for error.</a>
<a name="ln4833">MotionType get_reg_type(int regname, colnr_T *reg_width)</a>
<a name="ln4834">{</a>
<a name="ln4835">  switch (regname) {</a>
<a name="ln4836">  case '%':     // file name</a>
<a name="ln4837">  case '#':     // alternate file name</a>
<a name="ln4838">  case '=':     // expression</a>
<a name="ln4839">  case ':':     // last command line</a>
<a name="ln4840">  case '/':     // last search-pattern</a>
<a name="ln4841">  case '.':     // last inserted text</a>
<a name="ln4842">  case Ctrl_F:  // Filename under cursor</a>
<a name="ln4843">  case Ctrl_P:  // Path under cursor, expand via &quot;path&quot;</a>
<a name="ln4844">  case Ctrl_W:  // word under cursor</a>
<a name="ln4845">  case Ctrl_A:  // WORD (mnemonic All) under cursor</a>
<a name="ln4846">  case '_':     // black hole: always empty</a>
<a name="ln4847">    return kMTCharWise;</a>
<a name="ln4848">  }</a>
<a name="ln4849"> </a>
<a name="ln4850">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln4851">    return kMTUnknown;</a>
<a name="ln4852">  }</a>
<a name="ln4853"> </a>
<a name="ln4854">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln4855"> </a>
<a name="ln4856">  if (reg-&gt;y_array != NULL) {</a>
<a name="ln4857">    if (reg_width != NULL &amp;&amp; reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln4858">      *reg_width = reg-&gt;y_width;</a>
<a name="ln4859">    }</a>
<a name="ln4860">    return reg-&gt;y_type;</a>
<a name="ln4861">  }</a>
<a name="ln4862">  return kMTUnknown;</a>
<a name="ln4863">}</a>
<a name="ln4864"> </a>
<a name="ln4865">/// Format the register type as a string.</a>
<a name="ln4866">///</a>
<a name="ln4867">/// @param reg_type The register type.</a>
<a name="ln4868">/// @param reg_width The width, only used if &quot;reg_type&quot; is kMTBlockWise.</a>
<a name="ln4869">/// @param[out] buf Buffer to store formatted string. The allocated size should</a>
<a name="ln4870">///                 be at least NUMBUFLEN+2 to always fit the value.</a>
<a name="ln4871">/// @param buf_len The allocated size of the buffer.</a>
<a name="ln4872">void format_reg_type(MotionType reg_type, colnr_T reg_width, char *buf, size_t buf_len)</a>
<a name="ln4873">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4874">{</a>
<a name="ln4875">  assert(buf_len &gt; 1);</a>
<a name="ln4876">  switch (reg_type) {</a>
<a name="ln4877">  case kMTLineWise:</a>
<a name="ln4878">    buf[0] = 'V';</a>
<a name="ln4879">    buf[1] = NUL;</a>
<a name="ln4880">    break;</a>
<a name="ln4881">  case kMTCharWise:</a>
<a name="ln4882">    buf[0] = 'v';</a>
<a name="ln4883">    buf[1] = NUL;</a>
<a name="ln4884">    break;</a>
<a name="ln4885">  case kMTBlockWise:</a>
<a name="ln4886">    snprintf(buf, buf_len, CTRL_V_STR &quot;%&quot; PRIdCOLNR, reg_width + 1);</a>
<a name="ln4887">    break;</a>
<a name="ln4888">  case kMTUnknown:</a>
<a name="ln4889">    buf[0] = NUL;</a>
<a name="ln4890">    break;</a>
<a name="ln4891">  }</a>
<a name="ln4892">}</a>
<a name="ln4893"> </a>
<a name="ln4894">/// When `flags` has `kGRegList` return a list with text `s`.</a>
<a name="ln4895">/// Otherwise just return `s`.</a>
<a name="ln4896">///</a>
<a name="ln4897">/// @return  a void * for use in get_reg_contents().</a>
<a name="ln4898">static void *get_reg_wrap_one_line(char *s, int flags)</a>
<a name="ln4899">{</a>
<a name="ln4900">  if (!(flags &amp; kGRegList)) {</a>
<a name="ln4901">    return s;</a>
<a name="ln4902">  }</a>
<a name="ln4903">  list_T *const list = tv_list_alloc(1);</a>
<a name="ln4904">  tv_list_append_allocated_string(list, s);</a>
<a name="ln4905">  return list;</a>
<a name="ln4906">}</a>
<a name="ln4907"> </a>
<a name="ln4908">/// Gets the contents of a register.</a>
<a name="ln4909">/// @remark Used for `@r` in expressions and for `getreg()`.</a>
<a name="ln4910">///</a>
<a name="ln4911">/// @param regname  The register.</a>
<a name="ln4912">/// @param flags    see @ref GRegFlags</a>
<a name="ln4913">///</a>
<a name="ln4914">/// @returns The contents of the register as an allocated string.</a>
<a name="ln4915">/// @returns A linked list when `flags` contains @ref kGRegList.</a>
<a name="ln4916">/// @returns NULL for error.</a>
<a name="ln4917">void *get_reg_contents(int regname, int flags)</a>
<a name="ln4918">{</a>
<a name="ln4919">  // Don't allow using an expression register inside an expression.</a>
<a name="ln4920">  if (regname == '=') {</a>
<a name="ln4921">    if (flags &amp; kGRegNoExpr) {</a>
<a name="ln4922">      return NULL;</a>
<a name="ln4923">    }</a>
<a name="ln4924">    if (flags &amp; kGRegExprSrc) {</a>
<a name="ln4925">      return get_reg_wrap_one_line(get_expr_line_src(), flags);</a>
<a name="ln4926">    }</a>
<a name="ln4927">    return get_reg_wrap_one_line(get_expr_line(), flags);</a>
<a name="ln4928">  }</a>
<a name="ln4929"> </a>
<a name="ln4930">  if (regname == '@') {     // &quot;@@&quot; is used for unnamed register</a>
<a name="ln4931">    regname = '&quot;';</a>
<a name="ln4932">  }</a>
<a name="ln4933"> </a>
<a name="ln4934">  // check for valid regname</a>
<a name="ln4935">  if (regname != NUL &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln4936">    return NULL;</a>
<a name="ln4937">  }</a>
<a name="ln4938"> </a>
<a name="ln4939">  char *retval;</a>
<a name="ln4940">  bool allocated;</a>
<a name="ln4941">  if (get_spec_reg(regname, &amp;retval, &amp;allocated, false)) {</a>
<a name="ln4942">    if (retval == NULL) {</a>
<a name="ln4943">      return NULL;</a>
<a name="ln4944">    }</a>
<a name="ln4945">    if (allocated) {</a>
<a name="ln4946">      return get_reg_wrap_one_line(retval, flags);</a>
<a name="ln4947">    }</a>
<a name="ln4948">    return get_reg_wrap_one_line(xstrdup(retval), flags);</a>
<a name="ln4949">  }</a>
<a name="ln4950"> </a>
<a name="ln4951">  yankreg_T *reg = get_yank_register(regname, YREG_PASTE);</a>
<a name="ln4952">  if (reg-&gt;y_array == NULL) {</a>
<a name="ln4953">    return NULL;</a>
<a name="ln4954">  }</a>
<a name="ln4955"> </a>
<a name="ln4956">  if (flags &amp; kGRegList) {</a>
<a name="ln4957">    list_T *const list = tv_list_alloc((ptrdiff_t)reg-&gt;y_size);</a>
<a name="ln4958">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4959">      tv_list_append_string(list, reg-&gt;y_array[i], -1);</a>
<a name="ln4960">    }</a>
<a name="ln4961"> </a>
<a name="ln4962">    return list;</a>
<a name="ln4963">  }</a>
<a name="ln4964"> </a>
<a name="ln4965">  // Compute length of resulting string.</a>
<a name="ln4966">  size_t len = 0;</a>
<a name="ln4967">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4968">    len += strlen(reg-&gt;y_array[i]);</a>
<a name="ln4969">    // Insert a newline between lines and after last line if</a>
<a name="ln4970">    // y_type is kMTLineWise.</a>
<a name="ln4971">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln4972">      len++;</a>
<a name="ln4973">    }</a>
<a name="ln4974">  }</a>
<a name="ln4975"> </a>
<a name="ln4976">  retval = xmalloc(len + 1);</a>
<a name="ln4977"> </a>
<a name="ln4978">  // Copy the lines of the yank register into the string.</a>
<a name="ln4979">  len = 0;</a>
<a name="ln4980">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln4981">    STRCPY(retval + len, reg-&gt;y_array[i]);</a>
<a name="ln4982">    len += strlen(retval + len);</a>
<a name="ln4983"> </a>
<a name="ln4984">    // Insert a NL between lines and after the last line if y_type is</a>
<a name="ln4985">    // kMTLineWise.</a>
<a name="ln4986">    if (reg-&gt;y_type == kMTLineWise || i &lt; reg-&gt;y_size - 1) {</a>
<a name="ln4987">      retval[len++] = '\n';</a>
<a name="ln4988">    }</a>
<a name="ln4989">  }</a>
<a name="ln4990">  retval[len] = NUL;</a>
<a name="ln4991"> </a>
<a name="ln4992">  return retval;</a>
<a name="ln4993">}</a>
<a name="ln4994"> </a>
<a name="ln4995">static yankreg_T *init_write_reg(int name, yankreg_T **old_y_previous, bool must_append)</a>
<a name="ln4996">{</a>
<a name="ln4997">  if (!valid_yank_reg(name, true)) {  // check for valid reg name</a>
<a name="ln4998">    emsg_invreg(name);</a>
<a name="ln4999">    return NULL;</a>
<a name="ln5000">  }</a>
<a name="ln5001"> </a>
<a name="ln5002">  // Don't want to change the current (unnamed) register.</a>
<a name="ln5003">  *old_y_previous = y_previous;</a>
<a name="ln5004"> </a>
<a name="ln5005">  yankreg_T *reg = get_yank_register(name, YREG_YANK);</a>
<a name="ln5006">  if (!is_append_register(name) &amp;&amp; !must_append) {</a>
<a name="ln5007">    free_register(reg);</a>
<a name="ln5008">  }</a>
<a name="ln5009">  return reg;</a>
<a name="ln5010">}</a>
<a name="ln5011"> </a>
<a name="ln5012">static void finish_write_reg(int name, yankreg_T *reg, yankreg_T *old_y_previous)</a>
<a name="ln5013">{</a>
<a name="ln5014">  // Send text of clipboard register to the clipboard.</a>
<a name="ln5015">  set_clipboard(name, reg);</a>
<a name="ln5016"> </a>
<a name="ln5017">  // ':let @&quot; = &quot;val&quot;' should change the meaning of the &quot;&quot; register</a>
<a name="ln5018">  if (name != '&quot;') {</a>
<a name="ln5019">    y_previous = old_y_previous;</a>
<a name="ln5020">  }</a>
<a name="ln5021">}</a>
<a name="ln5022"> </a>
<a name="ln5023">/// store `str` in register `name`</a>
<a name="ln5024">///</a>
<a name="ln5025">/// @see write_reg_contents_ex</a>
<a name="ln5026">void write_reg_contents(int name, const char *str, ssize_t len, int must_append)</a>
<a name="ln5027">{</a>
<a name="ln5028">  write_reg_contents_ex(name, str, len, must_append, kMTUnknown, 0L);</a>
<a name="ln5029">}</a>
<a name="ln5030"> </a>
<a name="ln5031">void write_reg_contents_lst(int name, char **strings, bool must_append, MotionType yank_type,</a>
<a name="ln5032">                            colnr_T block_len)</a>
<a name="ln5033">{</a>
<a name="ln5034">  if (name == '/' || name == '=') {</a>
<a name="ln5035">    char *s = strings[0];</a>
<a name="ln5036">    if (strings[0] == NULL) {</a>
<a name="ln5037">      s = &quot;&quot;;</a>
<a name="ln5038">    } else if (strings[1] != NULL) {</a>
<a name="ln5039">      emsg(_(e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines));</a>
<a name="ln5040">      return;</a>
<a name="ln5041">    }</a>
<a name="ln5042">    write_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);</a>
<a name="ln5043">    return;</a>
<a name="ln5044">  }</a>
<a name="ln5045"> </a>
<a name="ln5046">  // black hole: nothing to do</a>
<a name="ln5047">  if (name == '_') {</a>
<a name="ln5048">    return;</a>
<a name="ln5049">  }</a>
<a name="ln5050"> </a>
<a name="ln5051">  yankreg_T *old_y_previous, *reg;</a>
<a name="ln5052">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5053">    return;</a>
<a name="ln5054">  }</a>
<a name="ln5055"> </a>
<a name="ln5056">  str_to_reg(reg, yank_type, (char *)strings, strlen((char *)strings),</a>
<a name="ln5057">             block_len, true);</a>
<a name="ln5058">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5059">}</a>
<a name="ln5060"> </a>
<a name="ln5061">/// write_reg_contents_ex - store `str` in register `name`</a>
<a name="ln5062">///</a>
<a name="ln5063">/// If `str` ends in '\n' or '\r', use linewise, otherwise use charwise.</a>
<a name="ln5064">///</a>
<a name="ln5065">/// @warning when `name` is '/', `len` and `must_append` are ignored. This</a>
<a name="ln5066">///          means that `str` MUST be NUL-terminated.</a>
<a name="ln5067">///</a>
<a name="ln5068">/// @param name The name of the register</a>
<a name="ln5069">/// @param str The contents to write</a>
<a name="ln5070">/// @param len If &gt;= 0, write `len` bytes of `str`. Otherwise, write</a>
<a name="ln5071">///               `strlen(str)` bytes. If `len` is larger than the</a>
<a name="ln5072">///               allocated size of `src`, the behaviour is undefined.</a>
<a name="ln5073">/// @param must_append If true, append the contents of `str` to the current</a>
<a name="ln5074">///                    contents of the register. Note that regardless of</a>
<a name="ln5075">///                    `must_append`, this function will append when `name`</a>
<a name="ln5076">///                    is an uppercase letter.</a>
<a name="ln5077">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5078">/// @param block_len width of visual block</a>
<a name="ln5079">void write_reg_contents_ex(int name, const char *str, ssize_t len, bool must_append,</a>
<a name="ln5080">                           MotionType yank_type, colnr_T block_len)</a>
<a name="ln5081">{</a>
<a name="ln5082">  if (len &lt; 0) {</a>
<a name="ln5083">    len = (ssize_t)strlen(str);</a>
<a name="ln5084">  }</a>
<a name="ln5085"> </a>
<a name="ln5086">  // Special case: '/' search pattern</a>
<a name="ln5087">  if (name == '/') {</a>
<a name="ln5088">    set_last_search_pat(str, RE_SEARCH, true, true);</a>
<a name="ln5089">    return;</a>
<a name="ln5090">  }</a>
<a name="ln5091"> </a>
<a name="ln5092">  if (name == '#') {</a>
<a name="ln5093">    buf_T *buf;</a>
<a name="ln5094"> </a>
<a name="ln5095">    if (ascii_isdigit(*str)) {</a>
<a name="ln5096">      int num = atoi(str);</a>
<a name="ln5097"> </a>
<a name="ln5098">      buf = buflist_findnr(num);</a>
<a name="ln5099">      if (buf == NULL) {</a>
<a name="ln5100">        semsg(_(e_nobufnr), (int64_t)num);</a>
<a name="ln5101">      }</a>
<a name="ln5102">    } else {</a>
<a name="ln5103">      buf = buflist_findnr(buflist_findpat(str, str + strlen(str),</a>
<a name="ln5104">                                           true, false, false));</a>
<a name="ln5105">    }</a>
<a name="ln5106">    if (buf == NULL) {</a>
<a name="ln5107">      return;</a>
<a name="ln5108">    }</a>
<a name="ln5109">    curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln5110">    return;</a>
<a name="ln5111">  }</a>
<a name="ln5112"> </a>
<a name="ln5113">  if (name == '=') {</a>
<a name="ln5114">    size_t offset = 0;</a>
<a name="ln5115">    size_t totlen = (size_t)len;</a>
<a name="ln5116"> </a>
<a name="ln5117">    if (must_append &amp;&amp; expr_line) {</a>
<a name="ln5118">      // append has been specified and expr_line already exists, so we'll</a>
<a name="ln5119">      // append the new string to expr_line.</a>
<a name="ln5120">      size_t exprlen = strlen(expr_line);</a>
<a name="ln5121"> </a>
<a name="ln5122">      totlen += exprlen;</a>
<a name="ln5123">      offset = exprlen;</a>
<a name="ln5124">    }</a>
<a name="ln5125"> </a>
<a name="ln5126">    // modify the global expr_line, extend/shrink it if necessary (realloc).</a>
<a name="ln5127">    // Copy the input string into the adjusted memory at the specified</a>
<a name="ln5128">    // offset.</a>
<a name="ln5129">    expr_line = xrealloc(expr_line, totlen + 1);</a>
<a name="ln5130">    memcpy(expr_line + offset, str, (size_t)len);</a>
<a name="ln5131">    expr_line[totlen] = NUL;</a>
<a name="ln5132"> </a>
<a name="ln5133">    return;</a>
<a name="ln5134">  }</a>
<a name="ln5135"> </a>
<a name="ln5136">  if (name == '_') {        // black hole: nothing to do</a>
<a name="ln5137">    return;</a>
<a name="ln5138">  }</a>
<a name="ln5139"> </a>
<a name="ln5140">  yankreg_T *old_y_previous, *reg;</a>
<a name="ln5141">  if (!(reg = init_write_reg(name, &amp;old_y_previous, must_append))) {</a>
<a name="ln5142">    return;</a>
<a name="ln5143">  }</a>
<a name="ln5144">  str_to_reg(reg, yank_type, str, (size_t)len, block_len, false);</a>
<a name="ln5145">  finish_write_reg(name, reg, old_y_previous);</a>
<a name="ln5146">}</a>
<a name="ln5147"> </a>
<a name="ln5148">/// str_to_reg - Put a string into a register.</a>
<a name="ln5149">///</a>
<a name="ln5150">/// When the register is not empty, the string is appended.</a>
<a name="ln5151">///</a>
<a name="ln5152">/// @param y_ptr pointer to yank register</a>
<a name="ln5153">/// @param yank_type The motion type (kMTUnknown to auto detect)</a>
<a name="ln5154">/// @param str string or list of strings to put in register</a>
<a name="ln5155">/// @param len length of the string (Ignored when str_list=true.)</a>
<a name="ln5156">/// @param blocklen width of visual block, or -1 for &quot;I don't know.&quot;</a>
<a name="ln5157">/// @param str_list True if str is `char **`.</a>
<a name="ln5158">static void str_to_reg(yankreg_T *y_ptr, MotionType yank_type, const char *str, size_t len,</a>
<a name="ln5159">                       colnr_T blocklen, bool str_list)</a>
<a name="ln5160">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5161">{</a>
<a name="ln5162">  if (y_ptr-&gt;y_array == NULL) {  // NULL means empty register</a>
<a name="ln5163">    y_ptr-&gt;y_size = 0;</a>
<a name="ln5164">  }</a>
<a name="ln5165"> </a>
<a name="ln5166">  if (yank_type == kMTUnknown) {</a>
<a name="ln5167">    yank_type = ((str_list</a>
<a name="ln5168">                  || (len &gt; 0 &amp;&amp; (str[len - 1] == NL || str[len - 1] == CAR)))</a>
<a name="ln5169">                 ? kMTLineWise : kMTCharWise);</a>
<a name="ln5170">  }</a>
<a name="ln5171"> </a>
<a name="ln5172">  size_t newlines = 0;</a>
<a name="ln5173">  bool extraline = false;  // extra line at the end</a>
<a name="ln5174">  bool append = false;     // append to last line in register</a>
<a name="ln5175"> </a>
<a name="ln5176">  // Count the number of lines within the string</a>
<a name="ln5177">  if (str_list) {</a>
<a name="ln5178">    for (char **ss = (char **)str; *ss != NULL; ss++) {</a>
<a name="ln5179">      newlines++;</a>
<a name="ln5180">    }</a>
<a name="ln5181">  } else {</a>
<a name="ln5182">    newlines = memcnt(str, '\n', len);</a>
<a name="ln5183">    if (yank_type == kMTCharWise || len == 0 || str[len - 1] != '\n') {</a>
<a name="ln5184">      extraline = 1;</a>
<a name="ln5185">      newlines++;         // count extra newline at the end</a>
<a name="ln5186">    }</a>
<a name="ln5187">    if (y_ptr-&gt;y_size &gt; 0 &amp;&amp; y_ptr-&gt;y_type == kMTCharWise) {</a>
<a name="ln5188">      append = true;</a>
<a name="ln5189">      newlines--;         // uncount newline when appending first line</a>
<a name="ln5190">    }</a>
<a name="ln5191">  }</a>
<a name="ln5192"> </a>
<a name="ln5193">  // Without any lines make the register empty.</a>
<a name="ln5194">  if (y_ptr-&gt;y_size + newlines == 0) {</a>
<a name="ln5195">    XFREE_CLEAR(y_ptr-&gt;y_array);</a>
<a name="ln5196">    return;</a>
<a name="ln5197">  }</a>
<a name="ln5198"> </a>
<a name="ln5199">  // Grow the register array to hold the pointers to the new lines.</a>
<a name="ln5200">  char **pp = xrealloc(y_ptr-&gt;y_array, (y_ptr-&gt;y_size + newlines) * sizeof(char *));</a>
<a name="ln5201">  y_ptr-&gt;y_array = pp;</a>
<a name="ln5202"> </a>
<a name="ln5203">  size_t lnum = y_ptr-&gt;y_size;  // The current line number.</a>
<a name="ln5204"> </a>
<a name="ln5205">  // If called with `blocklen &lt; 0`, we have to update the yank reg's width.</a>
<a name="ln5206">  size_t maxlen = 0;</a>
<a name="ln5207"> </a>
<a name="ln5208">  // Find the end of each line and save it into the array.</a>
<a name="ln5209">  if (str_list) {</a>
<a name="ln5210">    for (char **ss = (char **)str; *ss != NULL; ss++, lnum++) {</a>
<a name="ln5211">      size_t ss_len = strlen(*ss);</a>
<a name="ln5212">      pp[lnum] = xmemdupz(*ss, ss_len);</a>
<a name="ln5213">      if (ss_len &gt; maxlen) {</a>
<a name="ln5214">        maxlen = ss_len;</a>
<a name="ln5215">      }</a>
<a name="ln5216">    }</a>
<a name="ln5217">  } else {</a>
<a name="ln5218">    size_t line_len;</a>
<a name="ln5219">    for (const char *start = str, *end = str + len;</a>
<a name="ln5220">         start &lt; end + extraline;</a>
<a name="ln5221">         start += line_len + 1, lnum++) {</a>
<a name="ln5222">      assert(end - start &gt;= 0);</a>
<a name="ln5223">      line_len = (size_t)((char *)xmemscan(start, '\n', (size_t)(end - start)) - start);</a>
<a name="ln5224">      if (line_len &gt; maxlen) {</a>
<a name="ln5225">        maxlen = line_len;</a>
<a name="ln5226">      }</a>
<a name="ln5227"> </a>
<a name="ln5228">      // When appending, copy the previous line and free it after.</a>
<a name="ln5229">      size_t extra = append ? strlen(pp[--lnum]) : 0;</a>
<a name="ln5230">      char *s = xmallocz(line_len + extra);</a>
<a name="ln5231">      if (extra &gt; 0) {</a>
<a name="ln5232">        memcpy(s, pp[lnum], extra);</a>
<a name="ln5233">      }</a>
<a name="ln5234">      memcpy(s + extra, start, line_len);</a>
<a name="ln5235">      size_t s_len = extra + line_len;</a>
<a name="ln5236"> </a>
<a name="ln5237">      if (append) {</a>
<a name="ln5238">        xfree(pp[lnum]);</a>
<a name="ln5239">        append = false;  // only first line is appended</a>
<a name="ln5240">      }</a>
<a name="ln5241">      pp[lnum] = s;</a>
<a name="ln5242"> </a>
<a name="ln5243">      // Convert NULs to '\n' to prevent truncation.</a>
<a name="ln5244">      memchrsub(pp[lnum], NUL, '\n', s_len);</a>
<a name="ln5245">    }</a>
<a name="ln5246">  }</a>
<a name="ln5247">  y_ptr-&gt;y_type = yank_type;</a>
<a name="ln5248">  y_ptr-&gt;y_size = lnum;</a>
<a name="ln5249">  set_yreg_additional_data(y_ptr, NULL);</a>
<a name="ln5250">  y_ptr-&gt;timestamp = os_time();</a>
<a name="ln5251">  if (yank_type == kMTBlockWise) {</a>
<a name="ln5252">    y_ptr-&gt;y_width = (blocklen == -1 ? (colnr_T)maxlen - 1 : blocklen);</a>
<a name="ln5253">  } else {</a>
<a name="ln5254">    y_ptr-&gt;y_width = 0;</a>
<a name="ln5255">  }</a>
<a name="ln5256">}</a>
<a name="ln5257"> </a>
<a name="ln5258">void clear_oparg(oparg_T *oap)</a>
<a name="ln5259">{</a>
<a name="ln5260">  CLEAR_POINTER(oap);</a>
<a name="ln5261">}</a>
<a name="ln5262"> </a>
<a name="ln5263">///  Count the number of bytes, characters and &quot;words&quot; in a line.</a>
<a name="ln5264">///</a>
<a name="ln5265">///  &quot;Words&quot; are counted by looking for boundaries between non-space and</a>
<a name="ln5266">///  space characters.  (it seems to produce results that match 'wc'.)</a>
<a name="ln5267">///</a>
<a name="ln5268">///  Return value is byte count; word count for the line is added to &quot;*wc&quot;.</a>
<a name="ln5269">///  Char count is added to &quot;*cc&quot;.</a>
<a name="ln5270">///</a>
<a name="ln5271">///  The function will only examine the first &quot;limit&quot; characters in the</a>
<a name="ln5272">///  line, stopping if it encounters an end-of-line (NUL byte).  In that</a>
<a name="ln5273">///  case, eol_size will be added to the character count to account for</a>
<a name="ln5274">///  the size of the EOL character.</a>
<a name="ln5275">static varnumber_T line_count_info(char *line, varnumber_T *wc, varnumber_T *cc, varnumber_T limit,</a>
<a name="ln5276">                                   int eol_size)</a>
<a name="ln5277">{</a>
<a name="ln5278">  varnumber_T i;</a>
<a name="ln5279">  varnumber_T words = 0;</a>
<a name="ln5280">  varnumber_T chars = 0;</a>
<a name="ln5281">  int is_word = 0;</a>
<a name="ln5282"> </a>
<a name="ln5283">  for (i = 0; i &lt; limit &amp;&amp; line[i] != NUL;) {</a>
<a name="ln5284">    if (is_word) {</a>
<a name="ln5285">      if (ascii_isspace(line[i])) {</a>
<a name="ln5286">        words++;</a>
<a name="ln5287">        is_word = 0;</a>
<a name="ln5288">      }</a>
<a name="ln5289">    } else if (!ascii_isspace(line[i])) {</a>
<a name="ln5290">      is_word = 1;</a>
<a name="ln5291">    }</a>
<a name="ln5292">    chars++;</a>
<a name="ln5293">    i += utfc_ptr2len(line + i);</a>
<a name="ln5294">  }</a>
<a name="ln5295"> </a>
<a name="ln5296">  if (is_word) {</a>
<a name="ln5297">    words++;</a>
<a name="ln5298">  }</a>
<a name="ln5299">  *wc += words;</a>
<a name="ln5300"> </a>
<a name="ln5301">  // Add eol_size if the end of line was reached before hitting limit.</a>
<a name="ln5302">  if (i &lt; limit &amp;&amp; line[i] == NUL) {</a>
<a name="ln5303">    i += eol_size;</a>
<a name="ln5304">    chars += eol_size;</a>
<a name="ln5305">  }</a>
<a name="ln5306">  *cc += chars;</a>
<a name="ln5307">  return i;</a>
<a name="ln5308">}</a>
<a name="ln5309"> </a>
<a name="ln5310">/// Give some info about the position of the cursor (for &quot;g CTRL-G&quot;).</a>
<a name="ln5311">/// In Visual mode, give some info about the selected region.  (In this case,</a>
<a name="ln5312">/// the *_count_cursor variables store running totals for the selection.)</a>
<a name="ln5313">///</a>
<a name="ln5314">/// @param dict  when not NULL, store the info there instead of showing it.</a>
<a name="ln5315">void cursor_pos_info(dict_T *dict)</a>
<a name="ln5316">{</a>
<a name="ln5317">  char *p;</a>
<a name="ln5318">  char buf1[50];</a>
<a name="ln5319">  char buf2[40];</a>
<a name="ln5320">  varnumber_T byte_count = 0;</a>
<a name="ln5321">  varnumber_T bom_count = 0;</a>
<a name="ln5322">  varnumber_T byte_count_cursor = 0;</a>
<a name="ln5323">  varnumber_T char_count = 0;</a>
<a name="ln5324">  varnumber_T char_count_cursor = 0;</a>
<a name="ln5325">  varnumber_T word_count = 0;</a>
<a name="ln5326">  varnumber_T word_count_cursor = 0;</a>
<a name="ln5327">  pos_T min_pos, max_pos;</a>
<a name="ln5328">  oparg_T oparg;</a>
<a name="ln5329">  struct block_def bd;</a>
<a name="ln5330">  const int l_VIsual_active = VIsual_active;</a>
<a name="ln5331">  const int l_VIsual_mode = VIsual_mode;</a>
<a name="ln5332"> </a>
<a name="ln5333">  // Compute the length of the file in characters.</a>
<a name="ln5334">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln5335">    if (dict == NULL) {</a>
<a name="ln5336">      msg(_(no_lines_msg));</a>
<a name="ln5337">      return;</a>
<a name="ln5338">    }</a>
<a name="ln5339">  } else {</a>
<a name="ln5340">    linenr_T lnum;</a>
<a name="ln5341">    int eol_size;</a>
<a name="ln5342">    varnumber_T last_check = 100000L;</a>
<a name="ln5343">    long line_count_selected = 0;</a>
<a name="ln5344">    if (get_fileformat(curbuf) == EOL_DOS) {</a>
<a name="ln5345">      eol_size = 2;</a>
<a name="ln5346">    } else {</a>
<a name="ln5347">      eol_size = 1;</a>
<a name="ln5348">    }</a>
<a name="ln5349"> </a>
<a name="ln5350">    if (l_VIsual_active) {</a>
<a name="ln5351">      if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5352">        min_pos = VIsual;</a>
<a name="ln5353">        max_pos = curwin-&gt;w_cursor;</a>
<a name="ln5354">      } else {</a>
<a name="ln5355">        min_pos = curwin-&gt;w_cursor;</a>
<a name="ln5356">        max_pos = VIsual;</a>
<a name="ln5357">      }</a>
<a name="ln5358">      if (*p_sel == 'e' &amp;&amp; max_pos.col &gt; 0) {</a>
<a name="ln5359">        max_pos.col--;</a>
<a name="ln5360">      }</a>
<a name="ln5361"> </a>
<a name="ln5362">      if (l_VIsual_mode == Ctrl_V) {</a>
<a name="ln5363">        char *const saved_sbr = p_sbr;</a>
<a name="ln5364">        char *const saved_w_sbr = curwin-&gt;w_p_sbr;</a>
<a name="ln5365"> </a>
<a name="ln5366">        // Make 'sbr' empty for a moment to get the correct size.</a>
<a name="ln5367">        p_sbr = empty_option;</a>
<a name="ln5368">        curwin-&gt;w_p_sbr = empty_option;</a>
<a name="ln5369">        oparg.is_VIsual = true;</a>
<a name="ln5370">        oparg.motion_type = kMTBlockWise;</a>
<a name="ln5371">        oparg.op_type = OP_NOP;</a>
<a name="ln5372">        getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;oparg.start_vcol, &amp;oparg.end_vcol);</a>
<a name="ln5373">        p_sbr = saved_sbr;</a>
<a name="ln5374">        curwin-&gt;w_p_sbr = saved_w_sbr;</a>
<a name="ln5375">        if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5376">          oparg.end_vcol = MAXCOL;</a>
<a name="ln5377">        }</a>
<a name="ln5378">        // Swap the start, end vcol if needed</a>
<a name="ln5379">        if (oparg.end_vcol &lt; oparg.start_vcol) {</a>
<a name="ln5380">          oparg.end_vcol += oparg.start_vcol;</a>
<a name="ln5381">          oparg.start_vcol = oparg.end_vcol - oparg.start_vcol;</a>
<a name="ln5382">          oparg.end_vcol -= oparg.start_vcol;</a>
<a name="ln5383">        }</a>
<a name="ln5384">      }</a>
<a name="ln5385">      line_count_selected = max_pos.lnum - min_pos.lnum + 1;</a>
<a name="ln5386">    }</a>
<a name="ln5387"> </a>
<a name="ln5388">    for (lnum = 1; lnum &lt;= curbuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln5389">      // Check for a CTRL-C every 100000 characters.</a>
<a name="ln5390">      if (byte_count &gt; last_check) {</a>
<a name="ln5391">        os_breakcheck();</a>
<a name="ln5392">        if (got_int) {</a>
<a name="ln5393">          return;</a>
<a name="ln5394">        }</a>
<a name="ln5395">        last_check = byte_count + 100000L;</a>
<a name="ln5396">      }</a>
<a name="ln5397"> </a>
<a name="ln5398">      // Do extra processing for VIsual mode.</a>
<a name="ln5399">      if (l_VIsual_active</a>
<a name="ln5400">          &amp;&amp; lnum &gt;= min_pos.lnum &amp;&amp; lnum &lt;= max_pos.lnum) {</a>
<a name="ln5401">        char *s = NULL;</a>
<a name="ln5402">        long len = 0L;</a>
<a name="ln5403"> </a>
<a name="ln5404">        switch (l_VIsual_mode) {</a>
<a name="ln5405">        case Ctrl_V:</a>
<a name="ln5406">          virtual_op = virtual_active();</a>
<a name="ln5407">          block_prep(&amp;oparg, &amp;bd, lnum, false);</a>
<a name="ln5408">          virtual_op = kNone;</a>
<a name="ln5409">          s = bd.textstart;</a>
<a name="ln5410">          len = (long)bd.textlen;</a>
<a name="ln5411">          break;</a>
<a name="ln5412">        case 'V':</a>
<a name="ln5413">          s = ml_get(lnum);</a>
<a name="ln5414">          len = MAXCOL;</a>
<a name="ln5415">          break;</a>
<a name="ln5416">        case 'v': {</a>
<a name="ln5417">          colnr_T start_col = (lnum == min_pos.lnum)</a>
<a name="ln5418">                              ? min_pos.col : 0;</a>
<a name="ln5419">          colnr_T end_col = (lnum == max_pos.lnum)</a>
<a name="ln5420">                            ? max_pos.col - start_col + 1 : MAXCOL;</a>
<a name="ln5421"> </a>
<a name="ln5422">          s = ml_get(lnum) + start_col;</a>
<a name="ln5423">          len = end_col;</a>
<a name="ln5424">        }</a>
<a name="ln5425">        break;</a>
<a name="ln5426">        }</a>
<a name="ln5427">        if (s != NULL) {</a>
<a name="ln5428">          byte_count_cursor += line_count_info(s, &amp;word_count_cursor,</a>
<a name="ln5429">                                               &amp;char_count_cursor, len, eol_size);</a>
<a name="ln5430">          if (lnum == curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln5431">              &amp;&amp; !curbuf-&gt;b_p_eol</a>
<a name="ln5432">              &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)</a>
<a name="ln5433">              &amp;&amp; (long)strlen(s) &lt; len) {</a>
<a name="ln5434">            byte_count_cursor -= eol_size;</a>
<a name="ln5435">          }</a>
<a name="ln5436">        }</a>
<a name="ln5437">      } else {</a>
<a name="ln5438">        // In non-visual mode, check for the line the cursor is on</a>
<a name="ln5439">        if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5440">          word_count_cursor += word_count;</a>
<a name="ln5441">          char_count_cursor += char_count;</a>
<a name="ln5442">          byte_count_cursor = byte_count</a>
<a name="ln5443">                              + line_count_info(ml_get(lnum), &amp;word_count_cursor,</a>
<a name="ln5444">                                                &amp;char_count_cursor,</a>
<a name="ln5445">                                                (varnumber_T)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5446">                                                eol_size);</a>
<a name="ln5447">        }</a>
<a name="ln5448">      }</a>
<a name="ln5449">      // Add to the running totals</a>
<a name="ln5450">      byte_count += line_count_info(ml_get(lnum), &amp;word_count, &amp;char_count,</a>
<a name="ln5451">                                    (varnumber_T)MAXCOL, eol_size);</a>
<a name="ln5452">    }</a>
<a name="ln5453"> </a>
<a name="ln5454">    // Correction for when last line doesn't have an EOL.</a>
<a name="ln5455">    if (!curbuf-&gt;b_p_eol &amp;&amp; (curbuf-&gt;b_p_bin || !curbuf-&gt;b_p_fixeol)) {</a>
<a name="ln5456">      byte_count -= eol_size;</a>
<a name="ln5457">    }</a>
<a name="ln5458"> </a>
<a name="ln5459">    if (dict == NULL) {</a>
<a name="ln5460">      if (l_VIsual_active) {</a>
<a name="ln5461">        if (l_VIsual_mode == Ctrl_V &amp;&amp; curwin-&gt;w_curswant &lt; MAXCOL) {</a>
<a name="ln5462">          getvcols(curwin, &amp;min_pos, &amp;max_pos, &amp;min_pos.col, &amp;max_pos.col);</a>
<a name="ln5463">          int64_t cols;</a>
<a name="ln5464">          STRICT_SUB(oparg.end_vcol + 1, oparg.start_vcol, &amp;cols, int64_t);</a>
<a name="ln5465">          vim_snprintf(buf1, sizeof(buf1), _(&quot;%&quot; PRId64 &quot; Cols; &quot;),</a>
<a name="ln5466">                       cols);</a>
<a name="ln5467">        } else {</a>
<a name="ln5468">          buf1[0] = NUL;</a>
<a name="ln5469">        }</a>
<a name="ln5470"> </a>
<a name="ln5471">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5472">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5473">          vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln5474">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5475">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5476">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5477">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5478">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5479">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5480">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5481">        } else {</a>
<a name="ln5482">          vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln5483">                       _(&quot;Selected %s%&quot; PRId64 &quot; of %&quot; PRId64 &quot; Lines;&quot;</a>
<a name="ln5484">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Words;&quot;</a>
<a name="ln5485">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Chars;&quot;</a>
<a name="ln5486">                         &quot; %&quot; PRId64 &quot; of %&quot; PRId64 &quot; Bytes&quot;),</a>
<a name="ln5487">                       buf1, (int64_t)line_count_selected,</a>
<a name="ln5488">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5489">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5490">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5491">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5492">        }</a>
<a name="ln5493">      } else {</a>
<a name="ln5494">        p = get_cursor_line_ptr();</a>
<a name="ln5495">        validate_virtcol();</a>
<a name="ln5496">        col_print(buf1, sizeof(buf1), (int)curwin-&gt;w_cursor.col + 1,</a>
<a name="ln5497">                  (int)curwin-&gt;w_virtcol + 1);</a>
<a name="ln5498">        col_print(buf2, sizeof(buf2), (int)strlen(p), linetabsize_str(p));</a>
<a name="ln5499"> </a>
<a name="ln5500">        if (char_count_cursor == byte_count_cursor</a>
<a name="ln5501">            &amp;&amp; char_count == byte_count) {</a>
<a name="ln5502">          vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln5503">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5504">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5505">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5506">                       buf1, buf2,</a>
<a name="ln5507">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5508">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5509">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5510">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5511">        } else {</a>
<a name="ln5512">          vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln5513">                       _(&quot;Col %s of %s; Line %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5514">                         &quot; Word %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5515">                         &quot; Char %&quot; PRId64 &quot; of %&quot; PRId64 &quot;;&quot;</a>
<a name="ln5516">                         &quot; Byte %&quot; PRId64 &quot; of %&quot; PRId64 &quot;&quot;),</a>
<a name="ln5517">                       buf1, buf2,</a>
<a name="ln5518">                       (int64_t)curwin-&gt;w_cursor.lnum,</a>
<a name="ln5519">                       (int64_t)curbuf-&gt;b_ml.ml_line_count,</a>
<a name="ln5520">                       (int64_t)word_count_cursor, (int64_t)word_count,</a>
<a name="ln5521">                       (int64_t)char_count_cursor, (int64_t)char_count,</a>
<a name="ln5522">                       (int64_t)byte_count_cursor, (int64_t)byte_count);</a>
<a name="ln5523">        }</a>
<a name="ln5524">      }</a>
<a name="ln5525">    }</a>
<a name="ln5526"> </a>
<a name="ln5527">    bom_count = bomb_size();</a>
<a name="ln5528">    if (dict == NULL &amp;&amp; bom_count &gt; 0) {</a>
<a name="ln5529">      const size_t len = strlen(IObuff);</a>
<a name="ln5530">      vim_snprintf(IObuff + len, IOSIZE - len,</a>
<a name="ln5531">                   _(&quot;(+%&quot; PRId64 &quot; for BOM)&quot;), (int64_t)bom_count);</a>
<a name="ln5532">    }</a>
<a name="ln5533">    if (dict == NULL) {</a>
<a name="ln5534">      // Don't shorten this message, the user asked for it.</a>
<a name="ln5535">      p = p_shm;</a>
<a name="ln5536">      p_shm = &quot;&quot;;</a>
<a name="ln5537">      if (p_ch &lt; 1) {</a>
<a name="ln5538">        msg_start();</a>
<a name="ln5539">        msg_scroll = true;</a>
<a name="ln5540">      }</a>
<a name="ln5541">      msg(IObuff);</a>
<a name="ln5542">      p_shm = p;</a>
<a name="ln5543">    }</a>
<a name="ln5544">  }</a>
<a name="ln5545"> </a>
<a name="ln5546">  if (dict != NULL) {</a>
<a name="ln5547">    // Don't shorten this message, the user asked for it.</a>
<a name="ln5548">    tv_dict_add_nr(dict, S_LEN(&quot;words&quot;), word_count);</a>
<a name="ln5549">    tv_dict_add_nr(dict, S_LEN(&quot;chars&quot;), char_count);</a>
<a name="ln5550">    tv_dict_add_nr(dict, S_LEN(&quot;bytes&quot;), byte_count + bom_count);</a>
<a name="ln5551"> </a>
<a name="ln5552">    STATIC_ASSERT(sizeof(&quot;visual&quot;) == sizeof(&quot;cursor&quot;),</a>
<a name="ln5553">                  &quot;key_len argument in tv_dict_add_nr is wrong&quot;);</a>
<a name="ln5554">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_bytes&quot; : &quot;cursor_bytes&quot;,</a>
<a name="ln5555">                   sizeof(&quot;visual_bytes&quot;) - 1, byte_count_cursor);</a>
<a name="ln5556">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_chars&quot; : &quot;cursor_chars&quot;,</a>
<a name="ln5557">                   sizeof(&quot;visual_chars&quot;) - 1, char_count_cursor);</a>
<a name="ln5558">    tv_dict_add_nr(dict, l_VIsual_active ? &quot;visual_words&quot; : &quot;cursor_words&quot;,</a>
<a name="ln5559">                   sizeof(&quot;visual_words&quot;) - 1, word_count_cursor);</a>
<a name="ln5560">  }</a>
<a name="ln5561">}</a>
<a name="ln5562"> </a>
<a name="ln5563">/// Handle indent and format operators and visual mode &quot;:&quot;.</a>
<a name="ln5564">static void op_colon(oparg_T *oap)</a>
<a name="ln5565">{</a>
<a name="ln5566">  stuffcharReadbuff(':');</a>
<a name="ln5567">  if (oap-&gt;is_VIsual) {</a>
<a name="ln5568">    stuffReadbuff(&quot;'&lt;,'&gt;&quot;);</a>
<a name="ln5569">  } else {</a>
<a name="ln5570">    // Make the range look nice, so it can be repeated.</a>
<a name="ln5571">    if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5572">      stuffcharReadbuff('.');</a>
<a name="ln5573">    } else {</a>
<a name="ln5574">      stuffnumReadbuff((long)oap-&gt;start.lnum);</a>
<a name="ln5575">    }</a>
<a name="ln5576"> </a>
<a name="ln5577">    // When using !! on a closed fold the range &quot;.!&quot; works best to operate</a>
<a name="ln5578">    // on, it will be made the whole closed fold later.</a>
<a name="ln5579">    linenr_T endOfStartFold = oap-&gt;start.lnum;</a>
<a name="ln5580">    (void)hasFolding(oap-&gt;start.lnum, NULL, &amp;endOfStartFold);</a>
<a name="ln5581">    if (oap-&gt;end.lnum != oap-&gt;start.lnum &amp;&amp; oap-&gt;end.lnum != endOfStartFold) {</a>
<a name="ln5582">      // Make it a range with the end line.</a>
<a name="ln5583">      stuffcharReadbuff(',');</a>
<a name="ln5584">      if (oap-&gt;end.lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5585">        stuffcharReadbuff('.');</a>
<a name="ln5586">      } else if (oap-&gt;end.lnum == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5587">        stuffcharReadbuff('$');</a>
<a name="ln5588">      } else if (oap-&gt;start.lnum == curwin-&gt;w_cursor.lnum</a>
<a name="ln5589">                 // do not use &quot;.+number&quot; for a closed fold, it would count</a>
<a name="ln5590">                 // folded lines twice</a>
<a name="ln5591">                 &amp;&amp; !hasFolding(oap-&gt;end.lnum, NULL, NULL)) {</a>
<a name="ln5592">        stuffReadbuff(&quot;.+&quot;);</a>
<a name="ln5593">        stuffnumReadbuff(oap-&gt;line_count - 1);</a>
<a name="ln5594">      } else {</a>
<a name="ln5595">        stuffnumReadbuff((long)oap-&gt;end.lnum);</a>
<a name="ln5596">      }</a>
<a name="ln5597">    }</a>
<a name="ln5598">  }</a>
<a name="ln5599">  if (oap-&gt;op_type != OP_COLON) {</a>
<a name="ln5600">    stuffReadbuff(&quot;!&quot;);</a>
<a name="ln5601">  }</a>
<a name="ln5602">  if (oap-&gt;op_type == OP_INDENT) {</a>
<a name="ln5603">    stuffReadbuff(get_equalprg());</a>
<a name="ln5604">    stuffReadbuff(&quot;\n&quot;);</a>
<a name="ln5605">  } else if (oap-&gt;op_type == OP_FORMAT) {</a>
<a name="ln5606">    if (*curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln5607">      stuffReadbuff(curbuf-&gt;b_p_fp);</a>
<a name="ln5608">    } else if (*p_fp != NUL) {</a>
<a name="ln5609">      stuffReadbuff(p_fp);</a>
<a name="ln5610">    } else {</a>
<a name="ln5611">      stuffReadbuff(&quot;fmt&quot;);</a>
<a name="ln5612">    }</a>
<a name="ln5613">    stuffReadbuff(&quot;\n']&quot;);</a>
<a name="ln5614">  }</a>
<a name="ln5615"> </a>
<a name="ln5616">  // do_cmdline() does the rest</a>
<a name="ln5617">}</a>
<a name="ln5618"> </a>
<a name="ln5619">/// callback function for 'operatorfunc'</a>
<a name="ln5620">static Callback opfunc_cb;</a>
<a name="ln5621"> </a>
<a name="ln5622">/// Process the 'operatorfunc' option value.</a>
<a name="ln5623">const char *did_set_operatorfunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln5624">{</a>
<a name="ln5625">  if (option_set_callback_func(p_opfunc, &amp;opfunc_cb) == FAIL) {</a>
<a name="ln5626">    return e_invarg;</a>
<a name="ln5627">  }</a>
<a name="ln5628">  return NULL;</a>
<a name="ln5629">}</a>
<a name="ln5630"> </a>
<a name="ln5631">#if defined(EXITFREE)</a>
<a name="ln5632">void free_operatorfunc_option(void)</a>
<a name="ln5633">{</a>
<a name="ln5634">  callback_free(&amp;opfunc_cb);</a>
<a name="ln5635">}</a>
<a name="ln5636">#endif</a>
<a name="ln5637"> </a>
<a name="ln5638">/// Mark the global 'operatorfunc' callback with &quot;copyID&quot; so that it is not</a>
<a name="ln5639">/// garbage collected.</a>
<a name="ln5640">bool set_ref_in_opfunc(int copyID)</a>
<a name="ln5641">{</a>
<a name="ln5642">  return set_ref_in_callback(&amp;opfunc_cb, copyID, NULL, NULL);</a>
<a name="ln5643">}</a>
<a name="ln5644"> </a>
<a name="ln5645">/// Handle the &quot;g@&quot; operator: call 'operatorfunc'.</a>
<a name="ln5646">static void op_function(const oparg_T *oap)</a>
<a name="ln5647">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5648">{</a>
<a name="ln5649">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln5650">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln5651"> </a>
<a name="ln5652">  if (*p_opfunc == NUL) {</a>
<a name="ln5653">    emsg(_(&quot;E774: 'operatorfunc' is empty&quot;));</a>
<a name="ln5654">  } else {</a>
<a name="ln5655">    // Set '[ and '] marks to text to be operated on.</a>
<a name="ln5656">    curbuf-&gt;b_op_start = oap-&gt;start;</a>
<a name="ln5657">    curbuf-&gt;b_op_end = oap-&gt;end;</a>
<a name="ln5658">    if (oap-&gt;motion_type != kMTLineWise &amp;&amp; !oap-&gt;inclusive) {</a>
<a name="ln5659">      // Exclude the end position.</a>
<a name="ln5660">      decl(&amp;curbuf-&gt;b_op_end);</a>
<a name="ln5661">    }</a>
<a name="ln5662"> </a>
<a name="ln5663">    typval_T argv[2];</a>
<a name="ln5664">    argv[0].v_type = VAR_STRING;</a>
<a name="ln5665">    argv[1].v_type = VAR_UNKNOWN;</a>
<a name="ln5666">    argv[0].vval.v_string =</a>
<a name="ln5667">      (char *)(((const char *const[]) {</a>
<a name="ln5668">      [kMTBlockWise] = &quot;block&quot;,</a>
<a name="ln5669">      [kMTLineWise] = &quot;line&quot;,</a>
<a name="ln5670">      [kMTCharWise] = &quot;char&quot;,</a>
<a name="ln5671">    })[oap-&gt;motion_type]);</a>
<a name="ln5672"> </a>
<a name="ln5673">    // Reset virtual_op so that 'virtualedit' can be changed in the</a>
<a name="ln5674">    // function.</a>
<a name="ln5675">    const TriState save_virtual_op = virtual_op;</a>
<a name="ln5676">    virtual_op = kNone;</a>
<a name="ln5677"> </a>
<a name="ln5678">    // Reset finish_op so that mode() returns the right value.</a>
<a name="ln5679">    const bool save_finish_op = finish_op;</a>
<a name="ln5680">    finish_op = false;</a>
<a name="ln5681"> </a>
<a name="ln5682">    typval_T rettv;</a>
<a name="ln5683">    if (callback_call(&amp;opfunc_cb, 1, argv, &amp;rettv)) {</a>
<a name="ln5684">      tv_clear(&amp;rettv);</a>
<a name="ln5685">    }</a>
<a name="ln5686"> </a>
<a name="ln5687">    virtual_op = save_virtual_op;</a>
<a name="ln5688">    finish_op = save_finish_op;</a>
<a name="ln5689">    if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln5690">      curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln5691">      curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln5692">    }</a>
<a name="ln5693">  }</a>
<a name="ln5694">}</a>
<a name="ln5695"> </a>
<a name="ln5696">/// Calculate start/end virtual columns for operating in block mode.</a>
<a name="ln5697">///</a>
<a name="ln5698">/// @param initial  when true: adjust position for 'selectmode'</a>
<a name="ln5699">static void get_op_vcol(oparg_T *oap, colnr_T redo_VIsual_vcol, bool initial)</a>
<a name="ln5700">{</a>
<a name="ln5701">  colnr_T start;</a>
<a name="ln5702">  colnr_T end;</a>
<a name="ln5703"> </a>
<a name="ln5704">  if (VIsual_mode != Ctrl_V</a>
<a name="ln5705">      || (!initial &amp;&amp; oap-&gt;end.col &lt; curwin-&gt;w_width_inner)) {</a>
<a name="ln5706">    return;</a>
<a name="ln5707">  }</a>
<a name="ln5708"> </a>
<a name="ln5709">  oap-&gt;motion_type = kMTBlockWise;</a>
<a name="ln5710"> </a>
<a name="ln5711">  // prevent from moving onto a trail byte</a>
<a name="ln5712">  mark_mb_adjustpos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln5713"> </a>
<a name="ln5714">  getvvcol(curwin, &amp;(oap-&gt;start), &amp;oap-&gt;start_vcol, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln5715">  if (!redo_VIsual_busy) {</a>
<a name="ln5716">    getvvcol(curwin, &amp;(oap-&gt;end), &amp;start, NULL, &amp;end);</a>
<a name="ln5717"> </a>
<a name="ln5718">    if (start &lt; oap-&gt;start_vcol) {</a>
<a name="ln5719">      oap-&gt;start_vcol = start;</a>
<a name="ln5720">    }</a>
<a name="ln5721">    if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln5722">      if (initial &amp;&amp; *p_sel == 'e'</a>
<a name="ln5723">          &amp;&amp; start &gt;= 1</a>
<a name="ln5724">          &amp;&amp; start - 1 &gt;= oap-&gt;end_vcol) {</a>
<a name="ln5725">        oap-&gt;end_vcol = start - 1;</a>
<a name="ln5726">      } else {</a>
<a name="ln5727">        oap-&gt;end_vcol = end;</a>
<a name="ln5728">      }</a>
<a name="ln5729">    }</a>
<a name="ln5730">  }</a>
<a name="ln5731"> </a>
<a name="ln5732">  // if '$' was used, get oap-&gt;end_vcol from longest line</a>
<a name="ln5733">  if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5734">    curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln5735">    oap-&gt;end_vcol = 0;</a>
<a name="ln5736">    for (curwin-&gt;w_cursor.lnum = oap-&gt;start.lnum;</a>
<a name="ln5737">         curwin-&gt;w_cursor.lnum &lt;= oap-&gt;end.lnum; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln5738">      getvvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;end);</a>
<a name="ln5739">      if (end &gt; oap-&gt;end_vcol) {</a>
<a name="ln5740">        oap-&gt;end_vcol = end;</a>
<a name="ln5741">      }</a>
<a name="ln5742">    }</a>
<a name="ln5743">  } else if (redo_VIsual_busy) {</a>
<a name="ln5744">    oap-&gt;end_vcol = oap-&gt;start_vcol + redo_VIsual_vcol - 1;</a>
<a name="ln5745">  }</a>
<a name="ln5746"> </a>
<a name="ln5747">  // Correct oap-&gt;end.col and oap-&gt;start.col to be the</a>
<a name="ln5748">  // upper-left and lower-right corner of the block area.</a>
<a name="ln5749">  //</a>
<a name="ln5750">  // (Actually, this does convert column positions into character</a>
<a name="ln5751">  // positions)</a>
<a name="ln5752">  curwin-&gt;w_cursor.lnum = oap-&gt;end.lnum;</a>
<a name="ln5753">  coladvance(oap-&gt;end_vcol);</a>
<a name="ln5754">  oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln5755"> </a>
<a name="ln5756">  curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln5757">  coladvance(oap-&gt;start_vcol);</a>
<a name="ln5758">  oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5759">}</a>
<a name="ln5760"> </a>
<a name="ln5761">/// Information for redoing the previous Visual selection.</a>
<a name="ln5762">typedef struct {</a>
<a name="ln5763">  int rv_mode;             ///&lt; 'v', 'V', or Ctrl-V</a>
<a name="ln5764">  linenr_T rv_line_count;  ///&lt; number of lines</a>
<a name="ln5765">  colnr_T rv_vcol;         ///&lt; number of cols or end column</a>
<a name="ln5766">  long rv_count;           ///&lt; count for Visual operator</a>
<a name="ln5767">  int rv_arg;              ///&lt; extra argument</a>
<a name="ln5768">} redo_VIsual_T;</a>
<a name="ln5769"> </a>
<a name="ln5770">static bool is_ex_cmdchar(cmdarg_T *cap)</a>
<a name="ln5771">{</a>
<a name="ln5772">  return cap-&gt;cmdchar == ':' || cap-&gt;cmdchar == K_COMMAND;</a>
<a name="ln5773">}</a>
<a name="ln5774"> </a>
<a name="ln5775">/// Handle an operator after Visual mode or when the movement is finished.</a>
<a name="ln5776">/// &quot;gui_yank&quot; is true when yanking text for the clipboard.</a>
<a name="ln5777">void do_pending_operator(cmdarg_T *cap, int old_col, bool gui_yank)</a>
<a name="ln5778">{</a>
<a name="ln5779">  oparg_T *oap = cap-&gt;oap;</a>
<a name="ln5780">  int lbr_saved = curwin-&gt;w_p_lbr;</a>
<a name="ln5781"> </a>
<a name="ln5782">  // The visual area is remembered for redo</a>
<a name="ln5783">  static redo_VIsual_T redo_VIsual = { NUL, 0, 0, 0, 0 };</a>
<a name="ln5784"> </a>
<a name="ln5785">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln5786"> </a>
<a name="ln5787">  // If an operation is pending, handle it...</a>
<a name="ln5788">  if ((finish_op</a>
<a name="ln5789">       || VIsual_active)</a>
<a name="ln5790">      &amp;&amp; oap-&gt;op_type != OP_NOP) {</a>
<a name="ln5791">    bool empty_region_error;</a>
<a name="ln5792">    int restart_edit_save;</a>
<a name="ln5793">    bool include_line_break = false;</a>
<a name="ln5794">    // Yank can be redone when 'y' is in 'cpoptions', but not when yanking</a>
<a name="ln5795">    // for the clipboard.</a>
<a name="ln5796">    const bool redo_yank = vim_strchr(p_cpo, CPO_YANK) != NULL &amp;&amp; !gui_yank;</a>
<a name="ln5797"> </a>
<a name="ln5798">    // Avoid a problem with unwanted linebreaks in block mode</a>
<a name="ln5799">    (void)reset_lbr();</a>
<a name="ln5800">    oap-&gt;is_VIsual = VIsual_active;</a>
<a name="ln5801">    if (oap-&gt;motion_force == 'V') {</a>
<a name="ln5802">      oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln5803">    } else if (oap-&gt;motion_force == 'v') {</a>
<a name="ln5804">      // If the motion was linewise, &quot;inclusive&quot; will not have been set.</a>
<a name="ln5805">      // Use &quot;exclusive&quot; to be consistent.  Makes &quot;dvj&quot; work nice.</a>
<a name="ln5806">      if (oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln5807">        oap-&gt;inclusive = false;</a>
<a name="ln5808">      } else if (oap-&gt;motion_type == kMTCharWise) {</a>
<a name="ln5809">        // If the motion already was charwise, toggle &quot;inclusive&quot;</a>
<a name="ln5810">        oap-&gt;inclusive = !oap-&gt;inclusive;</a>
<a name="ln5811">      }</a>
<a name="ln5812">      oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln5813">    } else if (oap-&gt;motion_force == Ctrl_V) {</a>
<a name="ln5814">      // Change line- or charwise motion into Visual block mode.</a>
<a name="ln5815">      if (!VIsual_active) {</a>
<a name="ln5816">        VIsual_active = true;</a>
<a name="ln5817">        VIsual = oap-&gt;start;</a>
<a name="ln5818">      }</a>
<a name="ln5819">      VIsual_mode = Ctrl_V;</a>
<a name="ln5820">      VIsual_select = false;</a>
<a name="ln5821">      VIsual_reselect = false;</a>
<a name="ln5822">    }</a>
<a name="ln5823"> </a>
<a name="ln5824">    // Only redo yank when 'y' flag is in 'cpoptions'.</a>
<a name="ln5825">    // Never redo &quot;zf&quot; (define fold).</a>
<a name="ln5826">    if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln5827">        &amp;&amp; ((!VIsual_active || oap-&gt;motion_force)</a>
<a name="ln5828">            // Also redo Operator-pending Visual mode mappings.</a>
<a name="ln5829">            || ((is_ex_cmdchar(cap) || cap-&gt;cmdchar == K_LUA)</a>
<a name="ln5830">                &amp;&amp; oap-&gt;op_type != OP_COLON))</a>
<a name="ln5831">        &amp;&amp; cap-&gt;cmdchar != 'D'</a>
<a name="ln5832">        &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln5833">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln5834">        &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln5835">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln5836">        &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln5837">        &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln5838">        &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC) {</a>
<a name="ln5839">      prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln5840">                get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln5841">                oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln5842">      if (cap-&gt;cmdchar == '/' || cap-&gt;cmdchar == '?') {     // was a search</a>
<a name="ln5843">        // If 'cpoptions' does not contain 'r', insert the search</a>
<a name="ln5844">        // pattern to really repeat the same command.</a>
<a name="ln5845">        if (vim_strchr(p_cpo, CPO_REDO) == NULL) {</a>
<a name="ln5846">          AppendToRedobuffLit(cap-&gt;searchbuf, -1);</a>
<a name="ln5847">        }</a>
<a name="ln5848">        AppendToRedobuff(NL_STR);</a>
<a name="ln5849">      } else if (is_ex_cmdchar(cap)) {</a>
<a name="ln5850">        // do_cmdline() has stored the first typed line in</a>
<a name="ln5851">        // &quot;repeat_cmdline&quot;.  When several lines are typed repeating</a>
<a name="ln5852">        // won't be possible.</a>
<a name="ln5853">        if (repeat_cmdline == NULL) {</a>
<a name="ln5854">          ResetRedobuff();</a>
<a name="ln5855">        } else {</a>
<a name="ln5856">          if (cap-&gt;cmdchar == ':') {</a>
<a name="ln5857">            AppendToRedobuffLit(repeat_cmdline, -1);</a>
<a name="ln5858">          } else {</a>
<a name="ln5859">            AppendToRedobuffSpec(repeat_cmdline);</a>
<a name="ln5860">          }</a>
<a name="ln5861">          AppendToRedobuff(NL_STR);</a>
<a name="ln5862">          XFREE_CLEAR(repeat_cmdline);</a>
<a name="ln5863">        }</a>
<a name="ln5864">      } else if (cap-&gt;cmdchar == K_LUA) {</a>
<a name="ln5865">        AppendNumberToRedobuff(repeat_luaref);</a>
<a name="ln5866">        AppendToRedobuff(NL_STR);</a>
<a name="ln5867">      }</a>
<a name="ln5868">    }</a>
<a name="ln5869"> </a>
<a name="ln5870">    if (redo_VIsual_busy) {</a>
<a name="ln5871">      // Redo of an operation on a Visual area. Use the same size from</a>
<a name="ln5872">      // redo_VIsual.rv_line_count and redo_VIsual.rv_vcol.</a>
<a name="ln5873">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5874">      curwin-&gt;w_cursor.lnum += redo_VIsual.rv_line_count - 1;</a>
<a name="ln5875">      if (curwin-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5876">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5877">      }</a>
<a name="ln5878">      VIsual_mode = redo_VIsual.rv_mode;</a>
<a name="ln5879">      if (redo_VIsual.rv_vcol == MAXCOL || VIsual_mode == 'v') {</a>
<a name="ln5880">        if (VIsual_mode == 'v') {</a>
<a name="ln5881">          if (redo_VIsual.rv_line_count &lt;= 1) {</a>
<a name="ln5882">            validate_virtcol();</a>
<a name="ln5883">            curwin-&gt;w_curswant = curwin-&gt;w_virtcol + redo_VIsual.rv_vcol - 1;</a>
<a name="ln5884">          } else {</a>
<a name="ln5885">            curwin-&gt;w_curswant = redo_VIsual.rv_vcol;</a>
<a name="ln5886">          }</a>
<a name="ln5887">        } else {</a>
<a name="ln5888">          curwin-&gt;w_curswant = MAXCOL;</a>
<a name="ln5889">        }</a>
<a name="ln5890">        coladvance(curwin-&gt;w_curswant);</a>
<a name="ln5891">      }</a>
<a name="ln5892">      cap-&gt;count0 = redo_VIsual.rv_count;</a>
<a name="ln5893">      cap-&gt;count1 = (cap-&gt;count0 == 0 ? 1 : cap-&gt;count0);</a>
<a name="ln5894">    } else if (VIsual_active) {</a>
<a name="ln5895">      if (!gui_yank) {</a>
<a name="ln5896">        // Save the current VIsual area for '&lt; and '&gt; marks, and &quot;gv&quot;</a>
<a name="ln5897">        curbuf-&gt;b_visual.vi_start = VIsual;</a>
<a name="ln5898">        curbuf-&gt;b_visual.vi_end = curwin-&gt;w_cursor;</a>
<a name="ln5899">        curbuf-&gt;b_visual.vi_mode = VIsual_mode;</a>
<a name="ln5900">        restore_visual_mode();</a>
<a name="ln5901">        curbuf-&gt;b_visual.vi_curswant = curwin-&gt;w_curswant;</a>
<a name="ln5902">        curbuf-&gt;b_visual_mode_eval = VIsual_mode;</a>
<a name="ln5903">      }</a>
<a name="ln5904"> </a>
<a name="ln5905">      // In Select mode, a linewise selection is operated upon like a</a>
<a name="ln5906">      // charwise selection.</a>
<a name="ln5907">      // Special case: gH&lt;Del&gt; deletes the last line.</a>
<a name="ln5908">      if (VIsual_select &amp;&amp; VIsual_mode == 'V'</a>
<a name="ln5909">          &amp;&amp; cap-&gt;oap-&gt;op_type != OP_DELETE) {</a>
<a name="ln5910">        if (lt(VIsual, curwin-&gt;w_cursor)) {</a>
<a name="ln5911">          VIsual.col = 0;</a>
<a name="ln5912">          curwin-&gt;w_cursor.col =</a>
<a name="ln5913">            (colnr_T)strlen(ml_get(curwin-&gt;w_cursor.lnum));</a>
<a name="ln5914">        } else {</a>
<a name="ln5915">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln5916">          VIsual.col = (colnr_T)strlen(ml_get(VIsual.lnum));</a>
<a name="ln5917">        }</a>
<a name="ln5918">        VIsual_mode = 'v';</a>
<a name="ln5919">      } else if (VIsual_mode == 'v') {</a>
<a name="ln5920">        // If 'selection' is &quot;exclusive&quot;, backup one character for</a>
<a name="ln5921">        // charwise selections.</a>
<a name="ln5922">        include_line_break = unadjust_for_sel();</a>
<a name="ln5923">      }</a>
<a name="ln5924"> </a>
<a name="ln5925">      oap-&gt;start = VIsual;</a>
<a name="ln5926">      if (VIsual_mode == 'V') {</a>
<a name="ln5927">        oap-&gt;start.col = 0;</a>
<a name="ln5928">        oap-&gt;start.coladd = 0;</a>
<a name="ln5929">      }</a>
<a name="ln5930">    }</a>
<a name="ln5931"> </a>
<a name="ln5932">    // Set oap-&gt;start to the first position of the operated text, oap-&gt;end</a>
<a name="ln5933">    // to the end of the operated text.  w_cursor is equal to oap-&gt;start.</a>
<a name="ln5934">    if (lt(oap-&gt;start, curwin-&gt;w_cursor)) {</a>
<a name="ln5935">      // Include folded lines completely.</a>
<a name="ln5936">      if (!VIsual_active) {</a>
<a name="ln5937">        if (hasFolding(oap-&gt;start.lnum, &amp;oap-&gt;start.lnum, NULL)) {</a>
<a name="ln5938">          oap-&gt;start.col = 0;</a>
<a name="ln5939">        }</a>
<a name="ln5940">        if ((curwin-&gt;w_cursor.col &gt; 0</a>
<a name="ln5941">             || oap-&gt;inclusive</a>
<a name="ln5942">             || oap-&gt;motion_type == kMTLineWise)</a>
<a name="ln5943">            &amp;&amp; hasFolding(curwin-&gt;w_cursor.lnum, NULL,</a>
<a name="ln5944">                          &amp;curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln5945">          curwin-&gt;w_cursor.col = (colnr_T)strlen(get_cursor_line_ptr());</a>
<a name="ln5946">        }</a>
<a name="ln5947">      }</a>
<a name="ln5948">      oap-&gt;end = curwin-&gt;w_cursor;</a>
<a name="ln5949">      curwin-&gt;w_cursor = oap-&gt;start;</a>
<a name="ln5950"> </a>
<a name="ln5951">      // w_virtcol may have been updated; if the cursor goes back to its</a>
<a name="ln5952">      // previous position w_virtcol becomes invalid and isn't updated</a>
<a name="ln5953">      // automatically.</a>
<a name="ln5954">      curwin-&gt;w_valid &amp;= ~VALID_VIRTCOL;</a>
<a name="ln5955">    } else {</a>
<a name="ln5956">      // Include folded lines completely.</a>
<a name="ln5957">      if (!VIsual_active &amp;&amp; oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln5958">        if (hasFolding(curwin-&gt;w_cursor.lnum, &amp;curwin-&gt;w_cursor.lnum,</a>
<a name="ln5959">                       NULL)) {</a>
<a name="ln5960">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln5961">        }</a>
<a name="ln5962">        if (hasFolding(oap-&gt;start.lnum, NULL, &amp;oap-&gt;start.lnum)) {</a>
<a name="ln5963">          oap-&gt;start.col = (colnr_T)strlen(ml_get(oap-&gt;start.lnum));</a>
<a name="ln5964">        }</a>
<a name="ln5965">      }</a>
<a name="ln5966">      oap-&gt;end = oap-&gt;start;</a>
<a name="ln5967">      oap-&gt;start = curwin-&gt;w_cursor;</a>
<a name="ln5968">    }</a>
<a name="ln5969"> </a>
<a name="ln5970">    // Just in case lines were deleted that make the position invalid.</a>
<a name="ln5971">    check_pos(curwin-&gt;w_buffer, &amp;oap-&gt;end);</a>
<a name="ln5972">    oap-&gt;line_count = oap-&gt;end.lnum - oap-&gt;start.lnum + 1;</a>
<a name="ln5973"> </a>
<a name="ln5974">    // Set &quot;virtual_op&quot; before resetting VIsual_active.</a>
<a name="ln5975">    virtual_op = virtual_active();</a>
<a name="ln5976"> </a>
<a name="ln5977">    if (VIsual_active || redo_VIsual_busy) {</a>
<a name="ln5978">      get_op_vcol(oap, redo_VIsual.rv_vcol, true);</a>
<a name="ln5979"> </a>
<a name="ln5980">      if (!redo_VIsual_busy &amp;&amp; !gui_yank) {</a>
<a name="ln5981">        // Prepare to reselect and redo Visual: this is based on the</a>
<a name="ln5982">        // size of the Visual text</a>
<a name="ln5983">        resel_VIsual_mode = VIsual_mode;</a>
<a name="ln5984">        if (curwin-&gt;w_curswant == MAXCOL) {</a>
<a name="ln5985">          resel_VIsual_vcol = MAXCOL;</a>
<a name="ln5986">        } else {</a>
<a name="ln5987">          if (VIsual_mode != Ctrl_V) {</a>
<a name="ln5988">            getvvcol(curwin, &amp;(oap-&gt;end),</a>
<a name="ln5989">                     NULL, NULL, &amp;oap-&gt;end_vcol);</a>
<a name="ln5990">          }</a>
<a name="ln5991">          if (VIsual_mode == Ctrl_V || oap-&gt;line_count &lt;= 1) {</a>
<a name="ln5992">            if (VIsual_mode != Ctrl_V) {</a>
<a name="ln5993">              getvvcol(curwin, &amp;(oap-&gt;start),</a>
<a name="ln5994">                       &amp;oap-&gt;start_vcol, NULL, NULL);</a>
<a name="ln5995">            }</a>
<a name="ln5996">            resel_VIsual_vcol = oap-&gt;end_vcol - oap-&gt;start_vcol + 1;</a>
<a name="ln5997">          } else {</a>
<a name="ln5998">            resel_VIsual_vcol = oap-&gt;end_vcol;</a>
<a name="ln5999">          }</a>
<a name="ln6000">        }</a>
<a name="ln6001">        resel_VIsual_line_count = (linenr_T)oap-&gt;line_count;</a>
<a name="ln6002">      }</a>
<a name="ln6003"> </a>
<a name="ln6004">      // can't redo yank (unless 'y' is in 'cpoptions') and &quot;:&quot;</a>
<a name="ln6005">      if ((redo_yank || oap-&gt;op_type != OP_YANK)</a>
<a name="ln6006">          &amp;&amp; oap-&gt;op_type != OP_COLON</a>
<a name="ln6007">          &amp;&amp; oap-&gt;op_type != OP_FOLD</a>
<a name="ln6008">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPEN</a>
<a name="ln6009">          &amp;&amp; oap-&gt;op_type != OP_FOLDOPENREC</a>
<a name="ln6010">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSE</a>
<a name="ln6011">          &amp;&amp; oap-&gt;op_type != OP_FOLDCLOSEREC</a>
<a name="ln6012">          &amp;&amp; oap-&gt;op_type != OP_FOLDDEL</a>
<a name="ln6013">          &amp;&amp; oap-&gt;op_type != OP_FOLDDELREC</a>
<a name="ln6014">          &amp;&amp; oap-&gt;motion_force == NUL) {</a>
<a name="ln6015">        // Prepare for redoing.  Only use the nchar field for &quot;r&quot;,</a>
<a name="ln6016">        // otherwise it might be the second char of the operator.</a>
<a name="ln6017">        if (cap-&gt;cmdchar == 'g' &amp;&amp; (cap-&gt;nchar == 'n'</a>
<a name="ln6018">                                    || cap-&gt;nchar == 'N')) {</a>
<a name="ln6019">          prep_redo(oap-&gt;regname, cap-&gt;count0,</a>
<a name="ln6020">                    get_op_char(oap-&gt;op_type), get_extra_op_char(oap-&gt;op_type),</a>
<a name="ln6021">                    oap-&gt;motion_force, cap-&gt;cmdchar, cap-&gt;nchar);</a>
<a name="ln6022">        } else if (!is_ex_cmdchar(cap) &amp;&amp; cap-&gt;cmdchar != K_LUA) {</a>
<a name="ln6023">          int opchar = get_op_char(oap-&gt;op_type);</a>
<a name="ln6024">          int extra_opchar = get_extra_op_char(oap-&gt;op_type);</a>
<a name="ln6025">          int nchar = oap-&gt;op_type == OP_REPLACE ? cap-&gt;nchar : NUL;</a>
<a name="ln6026"> </a>
<a name="ln6027">          // reverse what nv_replace() did</a>
<a name="ln6028">          if (nchar == REPLACE_CR_NCHAR) {</a>
<a name="ln6029">            nchar = CAR;</a>
<a name="ln6030">          } else if (nchar == REPLACE_NL_NCHAR) {</a>
<a name="ln6031">            nchar = NL;</a>
<a name="ln6032">          }</a>
<a name="ln6033"> </a>
<a name="ln6034">          if (opchar == 'g' &amp;&amp; extra_opchar == '@') {</a>
<a name="ln6035">            // also repeat the count for 'operatorfunc'</a>
<a name="ln6036">            prep_redo_num2(oap-&gt;regname, 0L, NUL, 'v', cap-&gt;count0, opchar, extra_opchar, nchar);</a>
<a name="ln6037">          } else {</a>
<a name="ln6038">            prep_redo(oap-&gt;regname, 0L, NUL, 'v', opchar, extra_opchar, nchar);</a>
<a name="ln6039">          }</a>
<a name="ln6040">        }</a>
<a name="ln6041">        if (!redo_VIsual_busy) {</a>
<a name="ln6042">          redo_VIsual.rv_mode = resel_VIsual_mode;</a>
<a name="ln6043">          redo_VIsual.rv_vcol = resel_VIsual_vcol;</a>
<a name="ln6044">          redo_VIsual.rv_line_count = resel_VIsual_line_count;</a>
<a name="ln6045">          redo_VIsual.rv_count = cap-&gt;count0;</a>
<a name="ln6046">          redo_VIsual.rv_arg = cap-&gt;arg;</a>
<a name="ln6047">        }</a>
<a name="ln6048">      }</a>
<a name="ln6049"> </a>
<a name="ln6050">      // oap-&gt;inclusive defaults to true.</a>
<a name="ln6051">      // If oap-&gt;end is on a NUL (empty line) oap-&gt;inclusive becomes</a>
<a name="ln6052">      // false.  This makes &quot;d}P&quot; and &quot;v}dP&quot; work the same.</a>
<a name="ln6053">      if (oap-&gt;motion_force == NUL || oap-&gt;motion_type == kMTLineWise) {</a>
<a name="ln6054">        oap-&gt;inclusive = true;</a>
<a name="ln6055">      }</a>
<a name="ln6056">      if (VIsual_mode == 'V') {</a>
<a name="ln6057">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6058">      } else if (VIsual_mode == 'v') {</a>
<a name="ln6059">        oap-&gt;motion_type = kMTCharWise;</a>
<a name="ln6060">        if (*ml_get_pos(&amp;(oap-&gt;end)) == NUL</a>
<a name="ln6061">            &amp;&amp; (include_line_break || !virtual_op)) {</a>
<a name="ln6062">          oap-&gt;inclusive = false;</a>
<a name="ln6063">          // Try to include the newline, unless it's an operator</a>
<a name="ln6064">          // that works on lines only.</a>
<a name="ln6065">          if (*p_sel != 'o'</a>
<a name="ln6066">              &amp;&amp; !op_on_lines(oap-&gt;op_type)</a>
<a name="ln6067">              &amp;&amp; oap-&gt;end.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6068">            oap-&gt;end.lnum++;</a>
<a name="ln6069">            oap-&gt;end.col = 0;</a>
<a name="ln6070">            oap-&gt;end.coladd = 0;</a>
<a name="ln6071">            oap-&gt;line_count++;</a>
<a name="ln6072">          }</a>
<a name="ln6073">        }</a>
<a name="ln6074">      }</a>
<a name="ln6075"> </a>
<a name="ln6076">      redo_VIsual_busy = false;</a>
<a name="ln6077"> </a>
<a name="ln6078">      // Switch Visual off now, so screen updating does</a>
<a name="ln6079">      // not show inverted text when the screen is redrawn.</a>
<a name="ln6080">      // With OP_YANK and sometimes with OP_COLON and OP_FILTER there is</a>
<a name="ln6081">      // no screen redraw, so it is done here to remove the inverted</a>
<a name="ln6082">      // part.</a>
<a name="ln6083">      if (!gui_yank) {</a>
<a name="ln6084">        VIsual_active = false;</a>
<a name="ln6085">        setmouse();</a>
<a name="ln6086">        mouse_dragging = 0;</a>
<a name="ln6087">        may_clear_cmdline();</a>
<a name="ln6088">        if ((oap-&gt;op_type == OP_YANK</a>
<a name="ln6089">             || oap-&gt;op_type == OP_COLON</a>
<a name="ln6090">             || oap-&gt;op_type == OP_FUNCTION</a>
<a name="ln6091">             || oap-&gt;op_type == OP_FILTER)</a>
<a name="ln6092">            &amp;&amp; oap-&gt;motion_force == NUL) {</a>
<a name="ln6093">          // Make sure redrawing is correct.</a>
<a name="ln6094">          restore_lbr(lbr_saved);</a>
<a name="ln6095">          redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6096">        }</a>
<a name="ln6097">      }</a>
<a name="ln6098">    }</a>
<a name="ln6099"> </a>
<a name="ln6100">    // Include the trailing byte of a multi-byte char.</a>
<a name="ln6101">    if (oap-&gt;inclusive) {</a>
<a name="ln6102">      const int l = utfc_ptr2len(ml_get_pos(&amp;oap-&gt;end));</a>
<a name="ln6103">      if (l &gt; 1) {</a>
<a name="ln6104">        oap-&gt;end.col += l - 1;</a>
<a name="ln6105">      }</a>
<a name="ln6106">    }</a>
<a name="ln6107">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln6108"> </a>
<a name="ln6109">    // oap-&gt;empty is set when start and end are the same.  The inclusive</a>
<a name="ln6110">    // flag affects this too, unless yanking and the end is on a NUL.</a>
<a name="ln6111">    oap-&gt;empty = (oap-&gt;motion_type != kMTLineWise</a>
<a name="ln6112">                  &amp;&amp; (!oap-&gt;inclusive</a>
<a name="ln6113">                      || (oap-&gt;op_type == OP_YANK</a>
<a name="ln6114">                          &amp;&amp; gchar_pos(&amp;oap-&gt;end) == NUL))</a>
<a name="ln6115">                  &amp;&amp; equalpos(oap-&gt;start, oap-&gt;end)</a>
<a name="ln6116">                  &amp;&amp; !(virtual_op &amp;&amp; oap-&gt;start.coladd != oap-&gt;end.coladd));</a>
<a name="ln6117">    // For delete, change and yank, it's an error to operate on an</a>
<a name="ln6118">    // empty region, when 'E' included in 'cpoptions' (Vi compatible).</a>
<a name="ln6119">    empty_region_error = (oap-&gt;empty</a>
<a name="ln6120">                          &amp;&amp; vim_strchr(p_cpo, CPO_EMPTYREGION) != NULL);</a>
<a name="ln6121"> </a>
<a name="ln6122">    // Force a redraw when operating on an empty Visual region, when</a>
<a name="ln6123">    // 'modifiable is off or creating a fold.</a>
<a name="ln6124">    if (oap-&gt;is_VIsual &amp;&amp; (oap-&gt;empty || !MODIFIABLE(curbuf)</a>
<a name="ln6125">                           || oap-&gt;op_type == OP_FOLD)) {</a>
<a name="ln6126">      restore_lbr(lbr_saved);</a>
<a name="ln6127">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6128">    }</a>
<a name="ln6129"> </a>
<a name="ln6130">    // If the end of an operator is in column one while oap-&gt;motion_type</a>
<a name="ln6131">    // is kMTCharWise and oap-&gt;inclusive is false, we put op_end after the last</a>
<a name="ln6132">    // character in the previous line. If op_start is on or before the</a>
<a name="ln6133">    // first non-blank in the line, the operator becomes linewise</a>
<a name="ln6134">    // (strange, but that's the way vi does it).</a>
<a name="ln6135">    if (oap-&gt;motion_type == kMTCharWise</a>
<a name="ln6136">        &amp;&amp; oap-&gt;inclusive == false</a>
<a name="ln6137">        &amp;&amp; !(cap-&gt;retval &amp; CA_NO_ADJ_OP_END)</a>
<a name="ln6138">        &amp;&amp; oap-&gt;end.col == 0</a>
<a name="ln6139">        &amp;&amp; (!oap-&gt;is_VIsual || *p_sel == 'o')</a>
<a name="ln6140">        &amp;&amp; oap-&gt;line_count &gt; 1) {</a>
<a name="ln6141">      oap-&gt;end_adjusted = true;  // remember that we did this</a>
<a name="ln6142">      oap-&gt;line_count--;</a>
<a name="ln6143">      oap-&gt;end.lnum--;</a>
<a name="ln6144">      if (inindent(0)) {</a>
<a name="ln6145">        oap-&gt;motion_type = kMTLineWise;</a>
<a name="ln6146">      } else {</a>
<a name="ln6147">        oap-&gt;end.col = (colnr_T)strlen(ml_get(oap-&gt;end.lnum));</a>
<a name="ln6148">        if (oap-&gt;end.col) {</a>
<a name="ln6149">          oap-&gt;end.col--;</a>
<a name="ln6150">          oap-&gt;inclusive = true;</a>
<a name="ln6151">        }</a>
<a name="ln6152">      }</a>
<a name="ln6153">    } else {</a>
<a name="ln6154">      oap-&gt;end_adjusted = false;</a>
<a name="ln6155">    }</a>
<a name="ln6156"> </a>
<a name="ln6157">    switch (oap-&gt;op_type) {</a>
<a name="ln6158">    case OP_LSHIFT:</a>
<a name="ln6159">    case OP_RSHIFT:</a>
<a name="ln6160">      op_shift(oap, true, oap-&gt;is_VIsual ? (int)cap-&gt;count1 : 1);</a>
<a name="ln6161">      auto_format(false, true);</a>
<a name="ln6162">      break;</a>
<a name="ln6163"> </a>
<a name="ln6164">    case OP_JOIN_NS:</a>
<a name="ln6165">    case OP_JOIN:</a>
<a name="ln6166">      if (oap-&gt;line_count &lt; 2) {</a>
<a name="ln6167">        oap-&gt;line_count = 2;</a>
<a name="ln6168">      }</a>
<a name="ln6169">      if (curwin-&gt;w_cursor.lnum + oap-&gt;line_count - 1 &gt;</a>
<a name="ln6170">          curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6171">        beep_flush();</a>
<a name="ln6172">      } else {</a>
<a name="ln6173">        do_join((size_t)oap-&gt;line_count, oap-&gt;op_type == OP_JOIN,</a>
<a name="ln6174">                true, true, true);</a>
<a name="ln6175">        auto_format(false, true);</a>
<a name="ln6176">      }</a>
<a name="ln6177">      break;</a>
<a name="ln6178"> </a>
<a name="ln6179">    case OP_DELETE:</a>
<a name="ln6180">      VIsual_reselect = false;              // don't reselect now</a>
<a name="ln6181">      if (empty_region_error) {</a>
<a name="ln6182">        vim_beep(BO_OPER);</a>
<a name="ln6183">        CancelRedo();</a>
<a name="ln6184">      } else {</a>
<a name="ln6185">        (void)op_delete(oap);</a>
<a name="ln6186">        // save cursor line for undo if it wasn't saved yet</a>
<a name="ln6187">        if (oap-&gt;motion_type == kMTLineWise</a>
<a name="ln6188">            &amp;&amp; has_format_option(FO_AUTO)</a>
<a name="ln6189">            &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln6190">          auto_format(false, true);</a>
<a name="ln6191">        }</a>
<a name="ln6192">      }</a>
<a name="ln6193">      break;</a>
<a name="ln6194"> </a>
<a name="ln6195">    case OP_YANK:</a>
<a name="ln6196">      if (empty_region_error) {</a>
<a name="ln6197">        if (!gui_yank) {</a>
<a name="ln6198">          vim_beep(BO_OPER);</a>
<a name="ln6199">          CancelRedo();</a>
<a name="ln6200">        }</a>
<a name="ln6201">      } else {</a>
<a name="ln6202">        restore_lbr(lbr_saved);</a>
<a name="ln6203">        oap-&gt;excl_tr_ws = cap-&gt;cmdchar == 'z';</a>
<a name="ln6204">        (void)op_yank(oap, !gui_yank);</a>
<a name="ln6205">      }</a>
<a name="ln6206">      check_cursor_col();</a>
<a name="ln6207">      break;</a>
<a name="ln6208"> </a>
<a name="ln6209">    case OP_CHANGE:</a>
<a name="ln6210">      VIsual_reselect = false;              // don't reselect now</a>
<a name="ln6211">      if (empty_region_error) {</a>
<a name="ln6212">        vim_beep(BO_OPER);</a>
<a name="ln6213">        CancelRedo();</a>
<a name="ln6214">      } else {</a>
<a name="ln6215">        // This is a new edit command, not a restart.  Need to</a>
<a name="ln6216">        // remember it to make i_CTRL-O work with mappings for</a>
<a name="ln6217">        // Visual mode.  But do this only once and not when typed.</a>
<a name="ln6218">        if (!KeyTyped) {</a>
<a name="ln6219">          restart_edit_save = restart_edit;</a>
<a name="ln6220">        } else {</a>
<a name="ln6221">          restart_edit_save = 0;</a>
<a name="ln6222">        }</a>
<a name="ln6223">        restart_edit = 0;</a>
<a name="ln6224"> </a>
<a name="ln6225">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6226">        restore_lbr(lbr_saved);</a>
<a name="ln6227"> </a>
<a name="ln6228">        if (op_change(oap)) {           // will call edit()</a>
<a name="ln6229">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln6230">        }</a>
<a name="ln6231">        if (restart_edit == 0) {</a>
<a name="ln6232">          restart_edit = restart_edit_save;</a>
<a name="ln6233">        }</a>
<a name="ln6234">      }</a>
<a name="ln6235">      break;</a>
<a name="ln6236"> </a>
<a name="ln6237">    case OP_FILTER:</a>
<a name="ln6238">      if (vim_strchr(p_cpo, CPO_FILTER) != NULL) {</a>
<a name="ln6239">        AppendToRedobuff(&quot;!\r&quot;);  // Use any last used !cmd.</a>
<a name="ln6240">      } else {</a>
<a name="ln6241">        bangredo = true;  // do_bang() will put cmd in redo buffer.</a>
<a name="ln6242">      }</a>
<a name="ln6243">      FALLTHROUGH;</a>
<a name="ln6244"> </a>
<a name="ln6245">    case OP_INDENT:</a>
<a name="ln6246">    case OP_COLON:</a>
<a name="ln6247"> </a>
<a name="ln6248">      // If 'equalprg' is empty, do the indenting internally.</a>
<a name="ln6249">      if (oap-&gt;op_type == OP_INDENT &amp;&amp; *get_equalprg() == NUL) {</a>
<a name="ln6250">        if (curbuf-&gt;b_p_lisp) {</a>
<a name="ln6251">          if (use_indentexpr_for_lisp()) {</a>
<a name="ln6252">            op_reindent(oap, get_expr_indent);</a>
<a name="ln6253">          } else {</a>
<a name="ln6254">            op_reindent(oap, get_lisp_indent);</a>
<a name="ln6255">          }</a>
<a name="ln6256">          break;</a>
<a name="ln6257">        }</a>
<a name="ln6258">        op_reindent(oap,</a>
<a name="ln6259">                    *curbuf-&gt;b_p_inde != NUL ? get_expr_indent :</a>
<a name="ln6260">                    get_c_indent);</a>
<a name="ln6261">        break;</a>
<a name="ln6262">      }</a>
<a name="ln6263"> </a>
<a name="ln6264">      op_colon(oap);</a>
<a name="ln6265">      break;</a>
<a name="ln6266"> </a>
<a name="ln6267">    case OP_TILDE:</a>
<a name="ln6268">    case OP_UPPER:</a>
<a name="ln6269">    case OP_LOWER:</a>
<a name="ln6270">    case OP_ROT13:</a>
<a name="ln6271">      if (empty_region_error) {</a>
<a name="ln6272">        vim_beep(BO_OPER);</a>
<a name="ln6273">        CancelRedo();</a>
<a name="ln6274">      } else {</a>
<a name="ln6275">        op_tilde(oap);</a>
<a name="ln6276">      }</a>
<a name="ln6277">      check_cursor_col();</a>
<a name="ln6278">      break;</a>
<a name="ln6279"> </a>
<a name="ln6280">    case OP_FORMAT:</a>
<a name="ln6281">      if (*curbuf-&gt;b_p_fex != NUL) {</a>
<a name="ln6282">        op_formatexpr(oap);             // use expression</a>
<a name="ln6283">      } else {</a>
<a name="ln6284">        if (*p_fp != NUL || *curbuf-&gt;b_p_fp != NUL) {</a>
<a name="ln6285">          op_colon(oap);                // use external command</a>
<a name="ln6286">        } else {</a>
<a name="ln6287">          op_format(oap, false);        // use internal function</a>
<a name="ln6288">        }</a>
<a name="ln6289">      }</a>
<a name="ln6290">      break;</a>
<a name="ln6291"> </a>
<a name="ln6292">    case OP_FORMAT2:</a>
<a name="ln6293">      op_format(oap, true);             // use internal function</a>
<a name="ln6294">      break;</a>
<a name="ln6295"> </a>
<a name="ln6296">    case OP_FUNCTION: {</a>
<a name="ln6297">      redo_VIsual_T save_redo_VIsual = redo_VIsual;</a>
<a name="ln6298"> </a>
<a name="ln6299">      // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6300">      restore_lbr(lbr_saved);</a>
<a name="ln6301">      // call 'operatorfunc'</a>
<a name="ln6302">      op_function(oap);</a>
<a name="ln6303"> </a>
<a name="ln6304">      // Restore the info for redoing Visual mode, the function may</a>
<a name="ln6305">      // invoke another operator and unintentionally change it.</a>
<a name="ln6306">      redo_VIsual = save_redo_VIsual;</a>
<a name="ln6307">      break;</a>
<a name="ln6308">    }</a>
<a name="ln6309"> </a>
<a name="ln6310">    case OP_INSERT:</a>
<a name="ln6311">    case OP_APPEND:</a>
<a name="ln6312">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6313">      if (empty_region_error) {</a>
<a name="ln6314">        vim_beep(BO_OPER);</a>
<a name="ln6315">        CancelRedo();</a>
<a name="ln6316">      } else {</a>
<a name="ln6317">        // This is a new edit command, not a restart.  Need to</a>
<a name="ln6318">        // remember it to make i_CTRL-O work with mappings for</a>
<a name="ln6319">        // Visual mode.  But do this only once.</a>
<a name="ln6320">        restart_edit_save = restart_edit;</a>
<a name="ln6321">        restart_edit = 0;</a>
<a name="ln6322"> </a>
<a name="ln6323">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6324">        restore_lbr(lbr_saved);</a>
<a name="ln6325"> </a>
<a name="ln6326">        op_insert(oap, cap-&gt;count1);</a>
<a name="ln6327"> </a>
<a name="ln6328">        // Reset linebreak, so that formatting works correctly.</a>
<a name="ln6329">        (void)reset_lbr();</a>
<a name="ln6330"> </a>
<a name="ln6331">        // TODO(brammool): when inserting in several lines, should format all</a>
<a name="ln6332">        // the lines.</a>
<a name="ln6333">        auto_format(false, true);</a>
<a name="ln6334"> </a>
<a name="ln6335">        if (restart_edit == 0) {</a>
<a name="ln6336">          restart_edit = restart_edit_save;</a>
<a name="ln6337">        } else {</a>
<a name="ln6338">          cap-&gt;retval |= CA_COMMAND_BUSY;</a>
<a name="ln6339">        }</a>
<a name="ln6340">      }</a>
<a name="ln6341">      break;</a>
<a name="ln6342"> </a>
<a name="ln6343">    case OP_REPLACE:</a>
<a name="ln6344">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6345">      if (empty_region_error) {</a>
<a name="ln6346">        vim_beep(BO_OPER);</a>
<a name="ln6347">        CancelRedo();</a>
<a name="ln6348">      } else {</a>
<a name="ln6349">        // Restore linebreak, so that when the user edits it looks as before.</a>
<a name="ln6350">        restore_lbr(lbr_saved);</a>
<a name="ln6351"> </a>
<a name="ln6352">        op_replace(oap, cap-&gt;nchar);</a>
<a name="ln6353">      }</a>
<a name="ln6354">      break;</a>
<a name="ln6355"> </a>
<a name="ln6356">    case OP_FOLD:</a>
<a name="ln6357">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6358">      foldCreate(curwin, oap-&gt;start, oap-&gt;end);</a>
<a name="ln6359">      break;</a>
<a name="ln6360"> </a>
<a name="ln6361">    case OP_FOLDOPEN:</a>
<a name="ln6362">    case OP_FOLDOPENREC:</a>
<a name="ln6363">    case OP_FOLDCLOSE:</a>
<a name="ln6364">    case OP_FOLDCLOSEREC:</a>
<a name="ln6365">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6366">      opFoldRange(oap-&gt;start, oap-&gt;end,</a>
<a name="ln6367">                  oap-&gt;op_type == OP_FOLDOPEN</a>
<a name="ln6368">                  || oap-&gt;op_type == OP_FOLDOPENREC,</a>
<a name="ln6369">                  oap-&gt;op_type == OP_FOLDOPENREC</a>
<a name="ln6370">                  || oap-&gt;op_type == OP_FOLDCLOSEREC,</a>
<a name="ln6371">                  oap-&gt;is_VIsual);</a>
<a name="ln6372">      break;</a>
<a name="ln6373"> </a>
<a name="ln6374">    case OP_FOLDDEL:</a>
<a name="ln6375">    case OP_FOLDDELREC:</a>
<a name="ln6376">      VIsual_reselect = false;          // don't reselect now</a>
<a name="ln6377">      deleteFold(curwin, oap-&gt;start.lnum, oap-&gt;end.lnum,</a>
<a name="ln6378">                 oap-&gt;op_type == OP_FOLDDELREC, oap-&gt;is_VIsual);</a>
<a name="ln6379">      break;</a>
<a name="ln6380"> </a>
<a name="ln6381">    case OP_NR_ADD:</a>
<a name="ln6382">    case OP_NR_SUB:</a>
<a name="ln6383">      if (empty_region_error) {</a>
<a name="ln6384">        vim_beep(BO_OPER);</a>
<a name="ln6385">        CancelRedo();</a>
<a name="ln6386">      } else {</a>
<a name="ln6387">        VIsual_active = true;</a>
<a name="ln6388">        restore_lbr(lbr_saved);</a>
<a name="ln6389">        op_addsub(oap, (linenr_T)cap-&gt;count1, redo_VIsual.rv_arg);</a>
<a name="ln6390">        VIsual_active = false;</a>
<a name="ln6391">      }</a>
<a name="ln6392">      check_cursor_col();</a>
<a name="ln6393">      break;</a>
<a name="ln6394">    default:</a>
<a name="ln6395">      clearopbeep(oap);</a>
<a name="ln6396">    }</a>
<a name="ln6397">    virtual_op = kNone;</a>
<a name="ln6398">    if (!gui_yank) {</a>
<a name="ln6399">      // if 'sol' not set, go back to old column for some commands</a>
<a name="ln6400">      if (!p_sol &amp;&amp; oap-&gt;motion_type == kMTLineWise &amp;&amp; !oap-&gt;end_adjusted</a>
<a name="ln6401">          &amp;&amp; (oap-&gt;op_type == OP_LSHIFT || oap-&gt;op_type == OP_RSHIFT</a>
<a name="ln6402">              || oap-&gt;op_type == OP_DELETE)) {</a>
<a name="ln6403">        (void)reset_lbr();</a>
<a name="ln6404">        coladvance(curwin-&gt;w_curswant = old_col);</a>
<a name="ln6405">      }</a>
<a name="ln6406">    } else {</a>
<a name="ln6407">      curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln6408">    }</a>
<a name="ln6409">    clearop(oap);</a>
<a name="ln6410">    motion_force = NUL;</a>
<a name="ln6411">  }</a>
<a name="ln6412">  restore_lbr(lbr_saved);</a>
<a name="ln6413">}</a>
<a name="ln6414"> </a>
<a name="ln6415">/// Check if the default register (used in an unnamed paste) should be a</a>
<a name="ln6416">/// clipboard register. This happens when `clipboard=unnamed[plus]` is set</a>
<a name="ln6417">/// and a provider is available.</a>
<a name="ln6418">///</a>
<a name="ln6419">/// @returns the name of of a clipboard register that should be used, or `NUL` if none.</a>
<a name="ln6420">int get_default_register_name(void)</a>
<a name="ln6421">{</a>
<a name="ln6422">  int name = NUL;</a>
<a name="ln6423">  adjust_clipboard_name(&amp;name, true, false);</a>
<a name="ln6424">  return name;</a>
<a name="ln6425">}</a>
<a name="ln6426"> </a>
<a name="ln6427">/// Determine if register `*name` should be used as a clipboard.</a>
<a name="ln6428">/// In an unnamed operation, `*name` is `NUL` and will be adjusted to */+ if</a>
<a name="ln6429">/// `clipboard=unnamed[plus]` is set.</a>
<a name="ln6430">///</a>
<a name="ln6431">/// @param name The name of register, or `NUL` if unnamed.</a>
<a name="ln6432">/// @param quiet Suppress error messages</a>
<a name="ln6433">/// @param writing if we're setting the contents of the clipboard</a>
<a name="ln6434">///</a>
<a name="ln6435">/// @returns the yankreg that should be written into, or `NULL`</a>
<a name="ln6436">/// if the register isn't a clipboard or provider isn't available.</a>
<a name="ln6437">static yankreg_T *adjust_clipboard_name(int *name, bool quiet, bool writing)</a>
<a name="ln6438">{</a>
<a name="ln6439">#define MSG_NO_CLIP &quot;clipboard: No provider. &quot; \</a>
<a name="ln6440">  &quot;Try \&quot;:checkhealth\&quot; or \&quot;:h clipboard\&quot;.&quot;</a>
<a name="ln6441"> </a>
<a name="ln6442">  yankreg_T *target = NULL;</a>
<a name="ln6443">  bool explicit_cb_reg = (*name == '*' || *name == '+');</a>
<a name="ln6444">  bool implicit_cb_reg = (*name == NUL) &amp;&amp; (cb_flags &amp; CB_UNNAMEDMASK);</a>
<a name="ln6445">  if (!explicit_cb_reg &amp;&amp; !implicit_cb_reg) {</a>
<a name="ln6446">    goto end;</a>
<a name="ln6447">  }</a>
<a name="ln6448"> </a>
<a name="ln6449">  if (!eval_has_provider(&quot;clipboard&quot;)) {</a>
<a name="ln6450">    if (batch_change_count &lt;= 1 &amp;&amp; !quiet</a>
<a name="ln6451">        &amp;&amp; (!clipboard_didwarn || (explicit_cb_reg &amp;&amp; !redirecting()))) {</a>
<a name="ln6452">      clipboard_didwarn = true;</a>
<a name="ln6453">      // Do NOT error (emsg()) here--if it interrupts :redir we get into</a>
<a name="ln6454">      // a weird state, stuck in &quot;redirect mode&quot;.</a>
<a name="ln6455">      msg(MSG_NO_CLIP);</a>
<a name="ln6456">    }</a>
<a name="ln6457">    // ... else, be silent (don't flood during :while, :redir, etc.).</a>
<a name="ln6458">    goto end;</a>
<a name="ln6459">  }</a>
<a name="ln6460"> </a>
<a name="ln6461">  if (explicit_cb_reg) {</a>
<a name="ln6462">    target = &amp;y_regs[*name == '*' ? STAR_REGISTER : PLUS_REGISTER];</a>
<a name="ln6463">    if (writing &amp;&amp; (cb_flags &amp; (*name == '*' ? CB_UNNAMED : CB_UNNAMEDPLUS))) {</a>
<a name="ln6464">      clipboard_needs_update = false;</a>
<a name="ln6465">    }</a>
<a name="ln6466">    goto end;</a>
<a name="ln6467">  } else {  // unnamed register: &quot;implicit&quot; clipboard</a>
<a name="ln6468">    if (writing &amp;&amp; clipboard_delay_update) {</a>
<a name="ln6469">      // For &quot;set&quot; (copy), defer the clipboard call.</a>
<a name="ln6470">      clipboard_needs_update = true;</a>
<a name="ln6471">      goto end;</a>
<a name="ln6472">    } else if (!writing &amp;&amp; clipboard_needs_update) {</a>
<a name="ln6473">      // For &quot;get&quot; (paste), use the internal value.</a>
<a name="ln6474">      goto end;</a>
<a name="ln6475">    }</a>
<a name="ln6476"> </a>
<a name="ln6477">    if (cb_flags &amp; CB_UNNAMEDPLUS) {</a>
<a name="ln6478">      *name = (cb_flags &amp; CB_UNNAMED &amp;&amp; writing) ? '&quot;' : '+';</a>
<a name="ln6479">      target = &amp;y_regs[PLUS_REGISTER];</a>
<a name="ln6480">    } else {</a>
<a name="ln6481">      *name = '*';</a>
<a name="ln6482">      target = &amp;y_regs[STAR_REGISTER];</a>
<a name="ln6483">    }</a>
<a name="ln6484">    goto end;</a>
<a name="ln6485">  }</a>
<a name="ln6486"> </a>
<a name="ln6487">end:</a>
<a name="ln6488">  return target;</a>
<a name="ln6489">}</a>
<a name="ln6490"> </a>
<a name="ln6491">/// @param[out] reg Expected to be empty</a>
<a name="ln6492">bool prepare_yankreg_from_object(yankreg_T *reg, String regtype, size_t lines)</a>
<a name="ln6493">{</a>
<a name="ln6494">  char type = regtype.data ? regtype.data[0] : NUL;</a>
<a name="ln6495"> </a>
<a name="ln6496">  switch (type) {</a>
<a name="ln6497">  case 0:</a>
<a name="ln6498">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6499">    break;</a>
<a name="ln6500">  case 'v':</a>
<a name="ln6501">  case 'c':</a>
<a name="ln6502">    reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6503">    break;</a>
<a name="ln6504">  case 'V':</a>
<a name="ln6505">  case 'l':</a>
<a name="ln6506">    reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6507">    break;</a>
<a name="ln6508">  case 'b':</a>
<a name="ln6509">  case Ctrl_V:</a>
<a name="ln6510">    reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln6511">    break;</a>
<a name="ln6512">  default:</a>
<a name="ln6513">    return false;</a>
<a name="ln6514">  }</a>
<a name="ln6515"> </a>
<a name="ln6516">  reg-&gt;y_width = 0;</a>
<a name="ln6517">  if (regtype.size &gt; 1) {</a>
<a name="ln6518">    if (reg-&gt;y_type != kMTBlockWise) {</a>
<a name="ln6519">      return false;</a>
<a name="ln6520">    }</a>
<a name="ln6521"> </a>
<a name="ln6522">    // allow &quot;b7&quot; for a block at least 7 spaces wide</a>
<a name="ln6523">    if (!ascii_isdigit(regtype.data[1])) {</a>
<a name="ln6524">      return false;</a>
<a name="ln6525">    }</a>
<a name="ln6526">    const char *p = regtype.data + 1;</a>
<a name="ln6527">    reg-&gt;y_width = getdigits_int((char **)&amp;p, false, 1) - 1;</a>
<a name="ln6528">    if (regtype.size &gt; (size_t)(p - regtype.data)) {</a>
<a name="ln6529">      return false;</a>
<a name="ln6530">    }</a>
<a name="ln6531">  }</a>
<a name="ln6532"> </a>
<a name="ln6533">  reg-&gt;y_array = xcalloc(lines, sizeof(uint8_t *));</a>
<a name="ln6534">  reg-&gt;y_size = lines;</a>
<a name="ln6535">  reg-&gt;additional_data = NULL;</a>
<a name="ln6536">  reg-&gt;timestamp = 0;</a>
<a name="ln6537">  return true;</a>
<a name="ln6538">}</a>
<a name="ln6539"> </a>
<a name="ln6540">void finish_yankreg_from_object(yankreg_T *reg, bool clipboard_adjust)</a>
<a name="ln6541">{</a>
<a name="ln6542">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen(reg-&gt;y_array[reg-&gt;y_size - 1]) == 0) {</a>
<a name="ln6543">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6544">    // but otherwise there is no line after the final newline</a>
<a name="ln6545">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6546">      if (reg-&gt;y_type == kMTUnknown || clipboard_adjust) {</a>
<a name="ln6547">        xfree(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln6548">        reg-&gt;y_size--;</a>
<a name="ln6549">      }</a>
<a name="ln6550">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6551">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6552">      }</a>
<a name="ln6553">    }</a>
<a name="ln6554">  } else {</a>
<a name="ln6555">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6556">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6557">    }</a>
<a name="ln6558">  }</a>
<a name="ln6559"> </a>
<a name="ln6560">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6561">    size_t maxlen = 0;</a>
<a name="ln6562">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6563">      size_t rowlen = strlen(reg-&gt;y_array[i]);</a>
<a name="ln6564">      if (rowlen &gt; maxlen) {</a>
<a name="ln6565">        maxlen = rowlen;</a>
<a name="ln6566">      }</a>
<a name="ln6567">    }</a>
<a name="ln6568">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6569">    reg-&gt;y_width = MAX(reg-&gt;y_width, (int)maxlen - 1);</a>
<a name="ln6570">  }</a>
<a name="ln6571">}</a>
<a name="ln6572"> </a>
<a name="ln6573">static bool get_clipboard(int name, yankreg_T **target, bool quiet)</a>
<a name="ln6574">{</a>
<a name="ln6575">  // show message on error</a>
<a name="ln6576">  bool errmsg = true;</a>
<a name="ln6577"> </a>
<a name="ln6578">  yankreg_T *reg = adjust_clipboard_name(&amp;name, quiet, false);</a>
<a name="ln6579">  if (reg == NULL) {</a>
<a name="ln6580">    return false;</a>
<a name="ln6581">  }</a>
<a name="ln6582">  free_register(reg);</a>
<a name="ln6583"> </a>
<a name="ln6584">  list_T *const args = tv_list_alloc(1);</a>
<a name="ln6585">  const char regname = (char)name;</a>
<a name="ln6586">  tv_list_append_string(args, &amp;regname, 1);</a>
<a name="ln6587"> </a>
<a name="ln6588">  typval_T result = eval_call_provider(&quot;clipboard&quot;, &quot;get&quot;, args, false);</a>
<a name="ln6589"> </a>
<a name="ln6590">  if (result.v_type != VAR_LIST) {</a>
<a name="ln6591">    if (result.v_type == VAR_NUMBER &amp;&amp; result.vval.v_number == 0) {</a>
<a name="ln6592">      // failure has already been indicated by provider</a>
<a name="ln6593">      errmsg = false;</a>
<a name="ln6594">    }</a>
<a name="ln6595">    goto err;</a>
<a name="ln6596">  }</a>
<a name="ln6597"> </a>
<a name="ln6598">  list_T *res = result.vval.v_list;</a>
<a name="ln6599">  list_T *lines = NULL;</a>
<a name="ln6600">  if (tv_list_len(res) == 2</a>
<a name="ln6601">      &amp;&amp; TV_LIST_ITEM_TV(tv_list_first(res))-&gt;v_type == VAR_LIST) {</a>
<a name="ln6602">    lines = TV_LIST_ITEM_TV(tv_list_first(res))-&gt;vval.v_list;</a>
<a name="ln6603">    if (TV_LIST_ITEM_TV(tv_list_last(res))-&gt;v_type != VAR_STRING) {</a>
<a name="ln6604">      goto err;</a>
<a name="ln6605">    }</a>
<a name="ln6606">    char *regtype = TV_LIST_ITEM_TV(tv_list_last(res))-&gt;vval.v_string;</a>
<a name="ln6607">    if (regtype == NULL || strlen(regtype) &gt; 1) {</a>
<a name="ln6608">      goto err;</a>
<a name="ln6609">    }</a>
<a name="ln6610">    switch (regtype[0]) {</a>
<a name="ln6611">    case 0:</a>
<a name="ln6612">      reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6613">      break;</a>
<a name="ln6614">    case 'v':</a>
<a name="ln6615">    case 'c':</a>
<a name="ln6616">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6617">      break;</a>
<a name="ln6618">    case 'V':</a>
<a name="ln6619">    case 'l':</a>
<a name="ln6620">      reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6621">      break;</a>
<a name="ln6622">    case 'b':</a>
<a name="ln6623">    case Ctrl_V:</a>
<a name="ln6624">      reg-&gt;y_type = kMTBlockWise;</a>
<a name="ln6625">      break;</a>
<a name="ln6626">    default:</a>
<a name="ln6627">      goto err;</a>
<a name="ln6628">    }</a>
<a name="ln6629">  } else {</a>
<a name="ln6630">    lines = res;</a>
<a name="ln6631">    // provider did not specify regtype, calculate it below</a>
<a name="ln6632">    reg-&gt;y_type = kMTUnknown;</a>
<a name="ln6633">  }</a>
<a name="ln6634"> </a>
<a name="ln6635">  reg-&gt;y_array = xcalloc((size_t)tv_list_len(lines), sizeof(char *));</a>
<a name="ln6636">  reg-&gt;y_size = (size_t)tv_list_len(lines);</a>
<a name="ln6637">  reg-&gt;additional_data = NULL;</a>
<a name="ln6638">  reg-&gt;timestamp = 0;</a>
<a name="ln6639">  // Timestamp is not saved for clipboard registers because clipboard registers</a>
<a name="ln6640">  // are not saved in the ShaDa file.</a>
<a name="ln6641"> </a>
<a name="ln6642">  size_t tv_idx = 0;</a>
<a name="ln6643">  TV_LIST_ITER_CONST(lines, li, {</a>
<a name="ln6644">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_STRING) {</a>
<a name="ln6645">      goto err;</a>
<a name="ln6646">    }</a>
<a name="ln6647">    reg-&gt;y_array[tv_idx++] = xstrdupnul(TV_LIST_ITEM_TV(li)-&gt;vval.v_string);</a>
<a name="ln6648">  });</a>
<a name="ln6649"> </a>
<a name="ln6650">  if (reg-&gt;y_size &gt; 0 &amp;&amp; strlen(reg-&gt;y_array[reg-&gt;y_size - 1]) == 0) {</a>
<a name="ln6651">    // a known-to-be charwise yank might have a final linebreak</a>
<a name="ln6652">    // but otherwise there is no line after the final newline</a>
<a name="ln6653">    if (reg-&gt;y_type != kMTCharWise) {</a>
<a name="ln6654">      xfree(reg-&gt;y_array[reg-&gt;y_size - 1]);</a>
<a name="ln6655">      reg-&gt;y_size--;</a>
<a name="ln6656">      if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6657">        reg-&gt;y_type = kMTLineWise;</a>
<a name="ln6658">      }</a>
<a name="ln6659">    }</a>
<a name="ln6660">  } else {</a>
<a name="ln6661">    if (reg-&gt;y_type == kMTUnknown) {</a>
<a name="ln6662">      reg-&gt;y_type = kMTCharWise;</a>
<a name="ln6663">    }</a>
<a name="ln6664">  }</a>
<a name="ln6665"> </a>
<a name="ln6666">  if (reg-&gt;y_type == kMTBlockWise) {</a>
<a name="ln6667">    size_t maxlen = 0;</a>
<a name="ln6668">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6669">      size_t rowlen = strlen(reg-&gt;y_array[i]);</a>
<a name="ln6670">      if (rowlen &gt; maxlen) {</a>
<a name="ln6671">        maxlen = rowlen;</a>
<a name="ln6672">      }</a>
<a name="ln6673">    }</a>
<a name="ln6674">    assert(maxlen &lt;= INT_MAX);</a>
<a name="ln6675">    reg-&gt;y_width = (int)maxlen - 1;</a>
<a name="ln6676">  }</a>
<a name="ln6677"> </a>
<a name="ln6678">  *target = reg;</a>
<a name="ln6679">  return true;</a>
<a name="ln6680"> </a>
<a name="ln6681">err:</a>
<a name="ln6682">  if (reg-&gt;y_array) {</a>
<a name="ln6683">    for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6684">      xfree(reg-&gt;y_array[i]);</a>
<a name="ln6685">    }</a>
<a name="ln6686">    xfree(reg-&gt;y_array);</a>
<a name="ln6687">  }</a>
<a name="ln6688">  reg-&gt;y_array = NULL;</a>
<a name="ln6689">  reg-&gt;y_size = 0;</a>
<a name="ln6690">  reg-&gt;additional_data = NULL;</a>
<a name="ln6691">  reg-&gt;timestamp = 0;</a>
<a name="ln6692">  if (errmsg) {</a>
<a name="ln6693">    emsg(&quot;clipboard: provider returned invalid data&quot;);</a>
<a name="ln6694">  }</a>
<a name="ln6695">  *target = reg;</a>
<a name="ln6696">  return false;</a>
<a name="ln6697">}</a>
<a name="ln6698"> </a>
<a name="ln6699">static void set_clipboard(int name, yankreg_T *reg)</a>
<a name="ln6700">{</a>
<a name="ln6701">  if (!adjust_clipboard_name(&amp;name, false, true)) {</a>
<a name="ln6702">    return;</a>
<a name="ln6703">  }</a>
<a name="ln6704"> </a>
<a name="ln6705">  list_T *const lines = tv_list_alloc((ptrdiff_t)reg-&gt;y_size + (reg-&gt;y_type != kMTCharWise));</a>
<a name="ln6706"> </a>
<a name="ln6707">  for (size_t i = 0; i &lt; reg-&gt;y_size; i++) {</a>
<a name="ln6708">    tv_list_append_string(lines, reg-&gt;y_array[i], -1);</a>
<a name="ln6709">  }</a>
<a name="ln6710"> </a>
<a name="ln6711">  char regtype;</a>
<a name="ln6712">  switch (reg-&gt;y_type) {</a>
<a name="ln6713">  case kMTLineWise:</a>
<a name="ln6714">    regtype = 'V';</a>
<a name="ln6715">    tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6716">    break;</a>
<a name="ln6717">  case kMTCharWise:</a>
<a name="ln6718">    regtype = 'v';</a>
<a name="ln6719">    break;</a>
<a name="ln6720">  case kMTBlockWise:</a>
<a name="ln6721">    regtype = 'b';</a>
<a name="ln6722">    tv_list_append_string(lines, NULL, 0);</a>
<a name="ln6723">    break;</a>
<a name="ln6724">  case kMTUnknown:</a>
<a name="ln6725">    abort();</a>
<a name="ln6726">  }</a>
<a name="ln6727"> </a>
<a name="ln6728">  list_T *args = tv_list_alloc(3);</a>
<a name="ln6729">  tv_list_append_list(args, lines);</a>
<a name="ln6730">  tv_list_append_string(args, &amp;regtype, 1);  // -V614</a>
<a name="ln6731">  tv_list_append_string(args, ((char[]) { (char)name }), 1);</a>
<a name="ln6732"> </a>
<a name="ln6733">  (void)eval_call_provider(&quot;clipboard&quot;, &quot;set&quot;, args, true);</a>
<a name="ln6734">}</a>
<a name="ln6735"> </a>
<a name="ln6736">/// Avoid slow things (clipboard) during batch operations (while/for-loops).</a>
<a name="ln6737">void start_batch_changes(void)</a>
<a name="ln6738">{</a>
<a name="ln6739">  if (++batch_change_count &gt; 1) {</a>
<a name="ln6740">    return;</a>
<a name="ln6741">  }</a>
<a name="ln6742">  clipboard_delay_update = true;</a>
<a name="ln6743">}</a>
<a name="ln6744"> </a>
<a name="ln6745">/// Counterpart to start_batch_changes().</a>
<a name="ln6746">void end_batch_changes(void)</a>
<a name="ln6747">{</a>
<a name="ln6748">  if (--batch_change_count &gt; 0) {</a>
<a name="ln6749">    // recursive</a>
<a name="ln6750">    return;</a>
<a name="ln6751">  }</a>
<a name="ln6752">  clipboard_delay_update = false;</a>
<a name="ln6753">  if (clipboard_needs_update) {</a>
<a name="ln6754">    // must be before, as set_clipboard will invoke</a>
<a name="ln6755">    // start/end_batch_changes recursively</a>
<a name="ln6756">    clipboard_needs_update = false;</a>
<a name="ln6757">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6758">    set_clipboard(NUL, y_previous);</a>
<a name="ln6759">  }</a>
<a name="ln6760">}</a>
<a name="ln6761"> </a>
<a name="ln6762">int save_batch_count(void)</a>
<a name="ln6763">{</a>
<a name="ln6764">  int save_count = batch_change_count;</a>
<a name="ln6765">  batch_change_count = 0;</a>
<a name="ln6766">  clipboard_delay_update = false;</a>
<a name="ln6767">  if (clipboard_needs_update) {</a>
<a name="ln6768">    clipboard_needs_update = false;</a>
<a name="ln6769">    // unnamed (&quot;implicit&quot; clipboard)</a>
<a name="ln6770">    set_clipboard(NUL, y_previous);</a>
<a name="ln6771">  }</a>
<a name="ln6772">  return save_count;</a>
<a name="ln6773">}</a>
<a name="ln6774"> </a>
<a name="ln6775">void restore_batch_count(int save_count)</a>
<a name="ln6776">{</a>
<a name="ln6777">  assert(batch_change_count == 0);</a>
<a name="ln6778">  batch_change_count = save_count;</a>
<a name="ln6779">  if (batch_change_count &gt; 0) {</a>
<a name="ln6780">    clipboard_delay_update = true;</a>
<a name="ln6781">  }</a>
<a name="ln6782">}</a>
<a name="ln6783"> </a>
<a name="ln6784">/// Check whether register is empty</a>
<a name="ln6785">static inline bool reg_empty(const yankreg_T *const reg)</a>
<a name="ln6786">  FUNC_ATTR_PURE</a>
<a name="ln6787">{</a>
<a name="ln6788">  return (reg-&gt;y_array == NULL</a>
<a name="ln6789">          || reg-&gt;y_size == 0</a>
<a name="ln6790">          || (reg-&gt;y_size == 1</a>
<a name="ln6791">              &amp;&amp; reg-&gt;y_type == kMTCharWise</a>
<a name="ln6792">              &amp;&amp; *(reg-&gt;y_array[0]) == NUL));</a>
<a name="ln6793">}</a>
<a name="ln6794"> </a>
<a name="ln6795">/// Iterate over global registers.</a>
<a name="ln6796">///</a>
<a name="ln6797">/// @see op_register_iter</a>
<a name="ln6798">const void *op_global_reg_iter(const void *const iter, char *const name, yankreg_T *const reg,</a>
<a name="ln6799">                               bool *is_unnamed)</a>
<a name="ln6800">  FUNC_ATTR_NONNULL_ARG(2, 3, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6801">{</a>
<a name="ln6802">  return op_reg_iter(iter, y_regs, name, reg, is_unnamed);</a>
<a name="ln6803">}</a>
<a name="ln6804"> </a>
<a name="ln6805">/// Iterate over registers `regs`.</a>
<a name="ln6806">///</a>
<a name="ln6807">/// @param[in]   iter      Iterator. Pass NULL to start iteration.</a>
<a name="ln6808">/// @param[in]   regs      Registers list to be iterated.</a>
<a name="ln6809">/// @param[out]  name      Register name.</a>
<a name="ln6810">/// @param[out]  reg       Register contents.</a>
<a name="ln6811">///</a>
<a name="ln6812">/// @return Pointer that must be passed to next `op_register_iter` call or</a>
<a name="ln6813">///         NULL if iteration is over.</a>
<a name="ln6814">const void *op_reg_iter(const void *const iter, const yankreg_T *const regs, char *const name,</a>
<a name="ln6815">                        yankreg_T *const reg, bool *is_unnamed)</a>
<a name="ln6816">  FUNC_ATTR_NONNULL_ARG(3, 4, 5) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6817">{</a>
<a name="ln6818">  *name = NUL;</a>
<a name="ln6819">  const yankreg_T *iter_reg = (iter == NULL</a>
<a name="ln6820">                               ? &amp;(regs[0])</a>
<a name="ln6821">                               : (const yankreg_T *const)iter);</a>
<a name="ln6822">  while (iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS &amp;&amp; reg_empty(iter_reg)) {</a>
<a name="ln6823">    iter_reg++;</a>
<a name="ln6824">  }</a>
<a name="ln6825">  if (iter_reg - &amp;(regs[0]) == NUM_SAVED_REGISTERS || reg_empty(iter_reg)) {</a>
<a name="ln6826">    return NULL;</a>
<a name="ln6827">  }</a>
<a name="ln6828">  int iter_off = (int)(iter_reg - &amp;(regs[0]));</a>
<a name="ln6829">  *name = (char)get_register_name(iter_off);</a>
<a name="ln6830">  *reg = *iter_reg;</a>
<a name="ln6831">  *is_unnamed = (iter_reg == y_previous);</a>
<a name="ln6832">  while (++iter_reg - &amp;(regs[0]) &lt; NUM_SAVED_REGISTERS) {</a>
<a name="ln6833">    if (!reg_empty(iter_reg)) {</a>
<a name="ln6834">      return (void *)iter_reg;</a>
<a name="ln6835">    }</a>
<a name="ln6836">  }</a>
<a name="ln6837">  return NULL;</a>
<a name="ln6838">}</a>
<a name="ln6839"> </a>
<a name="ln6840">/// Get a number of non-empty registers</a>
<a name="ln6841">size_t op_reg_amount(void)</a>
<a name="ln6842">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6843">{</a>
<a name="ln6844">  size_t ret = 0;</a>
<a name="ln6845">  for (size_t i = 0; i &lt; NUM_SAVED_REGISTERS; i++) {</a>
<a name="ln6846">    if (!reg_empty(y_regs + i)) {</a>
<a name="ln6847">      ret++;</a>
<a name="ln6848">    }</a>
<a name="ln6849">  }</a>
<a name="ln6850">  return ret;</a>
<a name="ln6851">}</a>
<a name="ln6852"> </a>
<a name="ln6853">/// Set register to a given value</a>
<a name="ln6854">///</a>
<a name="ln6855">/// @param[in]  name  Register name.</a>
<a name="ln6856">/// @param[in]  reg  Register value.</a>
<a name="ln6857">/// @param[in]  is_unnamed  Whether to set the unnamed regiseter to reg</a>
<a name="ln6858">///</a>
<a name="ln6859">/// @return true on success, false on failure.</a>
<a name="ln6860">bool op_reg_set(const char name, const yankreg_T reg, bool is_unnamed)</a>
<a name="ln6861">{</a>
<a name="ln6862">  int i = op_reg_index(name);</a>
<a name="ln6863">  if (i == -1) {</a>
<a name="ln6864">    return false;</a>
<a name="ln6865">  }</a>
<a name="ln6866">  free_register(&amp;y_regs[i]);</a>
<a name="ln6867">  y_regs[i] = reg;</a>
<a name="ln6868"> </a>
<a name="ln6869">  if (is_unnamed) {</a>
<a name="ln6870">    y_previous = &amp;y_regs[i];</a>
<a name="ln6871">  }</a>
<a name="ln6872">  return true;</a>
<a name="ln6873">}</a>
<a name="ln6874"> </a>
<a name="ln6875">/// Get register with the given name</a>
<a name="ln6876">///</a>
<a name="ln6877">/// @param[in]  name  Register name.</a>
<a name="ln6878">///</a>
<a name="ln6879">/// @return Pointer to the register contents or NULL.</a>
<a name="ln6880">const yankreg_T *op_reg_get(const char name)</a>
<a name="ln6881">{</a>
<a name="ln6882">  int i = op_reg_index(name);</a>
<a name="ln6883">  if (i == -1) {</a>
<a name="ln6884">    return NULL;</a>
<a name="ln6885">  }</a>
<a name="ln6886">  return &amp;y_regs[i];</a>
<a name="ln6887">}</a>
<a name="ln6888"> </a>
<a name="ln6889">/// Set the previous yank register</a>
<a name="ln6890">///</a>
<a name="ln6891">/// @param[in]  name  Register name.</a>
<a name="ln6892">///</a>
<a name="ln6893">/// @return true on success, false on failure.</a>
<a name="ln6894">bool op_reg_set_previous(const char name)</a>
<a name="ln6895">{</a>
<a name="ln6896">  int i = op_reg_index(name);</a>
<a name="ln6897">  if (i == -1) {</a>
<a name="ln6898">    return false;</a>
<a name="ln6899">  }</a>
<a name="ln6900"> </a>
<a name="ln6901">  y_previous = &amp;y_regs[i];</a>
<a name="ln6902">  return true;</a>
<a name="ln6903">}</a>
<a name="ln6904"> </a>
<a name="ln6905">/// Get the byte count of buffer region. End-exclusive.</a>
<a name="ln6906">///</a>
<a name="ln6907">/// @return number of bytes</a>
<a name="ln6908">bcount_t get_region_bytecount(buf_T *buf, linenr_T start_lnum, linenr_T end_lnum, colnr_T start_col,</a>
<a name="ln6909">                              colnr_T end_col)</a>
<a name="ln6910">{</a>
<a name="ln6911">  linenr_T max_lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6912">  if (start_lnum &gt; max_lnum) {</a>
<a name="ln6913">    return 0;</a>
<a name="ln6914">  }</a>
<a name="ln6915">  if (start_lnum == end_lnum) {</a>
<a name="ln6916">    return end_col - start_col;</a>
<a name="ln6917">  }</a>
<a name="ln6918">  const char *first = ml_get_buf(buf, start_lnum, false);</a>
<a name="ln6919">  bcount_t deleted_bytes = (bcount_t)strlen(first) - start_col + 1;</a>
<a name="ln6920"> </a>
<a name="ln6921">  for (linenr_T i = 1; i &lt;= end_lnum - start_lnum - 1; i++) {</a>
<a name="ln6922">    if (start_lnum + i &gt; max_lnum) {</a>
<a name="ln6923">      return deleted_bytes;</a>
<a name="ln6924">    }</a>
<a name="ln6925">    deleted_bytes += (bcount_t)strlen(ml_get_buf(buf, start_lnum + i, false)) + 1;</a>
<a name="ln6926">  }</a>
<a name="ln6927">  if (end_lnum &gt; max_lnum) {</a>
<a name="ln6928">    return deleted_bytes;</a>
<a name="ln6929">  }</a>
<a name="ln6930">  return deleted_bytes + end_col;</a>
<a name="ln6931">}</a>
</code></pre>
<div class="balloon" rel="4123"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> The value of 'char' type is implicitly cast to a char pointer.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>