<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>insexpand.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// insexpand.c: functions for Insert mode completion</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;limits.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdint.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln23">#include &quot;nvim/edit.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln32">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln33">#include &quot;nvim/garray.h&quot;</a>
<a name="ln34">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln35">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln36">#include &quot;nvim/globals.h&quot;</a>
<a name="ln37">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln38">#include &quot;nvim/indent.h&quot;</a>
<a name="ln39">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln40">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln41">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln42">#include &quot;nvim/macros.h&quot;</a>
<a name="ln43">#include &quot;nvim/mark.h&quot;</a>
<a name="ln44">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln45">#include &quot;nvim/memline.h&quot;</a>
<a name="ln46">#include &quot;nvim/memory.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/move.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln53">#include &quot;nvim/path.h&quot;</a>
<a name="ln54">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln55">#include &quot;nvim/pos.h&quot;</a>
<a name="ln56">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln57">#include &quot;nvim/search.h&quot;</a>
<a name="ln58">#include &quot;nvim/spell.h&quot;</a>
<a name="ln59">#include &quot;nvim/state.h&quot;</a>
<a name="ln60">#include &quot;nvim/strings.h&quot;</a>
<a name="ln61">#include &quot;nvim/tag.h&quot;</a>
<a name="ln62">#include &quot;nvim/textformat.h&quot;</a>
<a name="ln63">#include &quot;nvim/types.h&quot;</a>
<a name="ln64">#include &quot;nvim/ui.h&quot;</a>
<a name="ln65">#include &quot;nvim/undo.h&quot;</a>
<a name="ln66">#include &quot;nvim/vim.h&quot;</a>
<a name="ln67">#include &quot;nvim/window.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">// Definitions used for CTRL-X submode.</a>
<a name="ln70">// Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[]</a>
<a name="ln71">// and ctrl_x_mode_names[].</a>
<a name="ln72"> </a>
<a name="ln73">#define CTRL_X_WANT_IDENT       0x100</a>
<a name="ln74"> </a>
<a name="ln75">enum {</a>
<a name="ln76">  CTRL_X_NORMAL = 0,  ///&lt; CTRL-N CTRL-P completion, default</a>
<a name="ln77">  CTRL_X_NOT_DEFINED_YET = 1,</a>
<a name="ln78">  CTRL_X_SCROLL = 2,</a>
<a name="ln79">  CTRL_X_WHOLE_LINE = 3,</a>
<a name="ln80">  CTRL_X_FILES = 4,</a>
<a name="ln81">  CTRL_X_TAGS = (5 + CTRL_X_WANT_IDENT),</a>
<a name="ln82">  CTRL_X_PATH_PATTERNS = (6 + CTRL_X_WANT_IDENT),</a>
<a name="ln83">  CTRL_X_PATH_DEFINES = (7 + CTRL_X_WANT_IDENT),</a>
<a name="ln84">  CTRL_X_FINISHED = 8,</a>
<a name="ln85">  CTRL_X_DICTIONARY = (9 + CTRL_X_WANT_IDENT),</a>
<a name="ln86">  CTRL_X_THESAURUS = (10 + CTRL_X_WANT_IDENT),</a>
<a name="ln87">  CTRL_X_CMDLINE = 11,</a>
<a name="ln88">  CTRL_X_FUNCTION = 12,</a>
<a name="ln89">  CTRL_X_OMNI = 13,</a>
<a name="ln90">  CTRL_X_SPELL = 14,</a>
<a name="ln91">  CTRL_X_LOCAL_MSG = 15,       ///&lt; only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln92">  CTRL_X_EVAL = 16,            ///&lt; for builtin function complete()</a>
<a name="ln93">  CTRL_X_CMDLINE_CTRL_X = 17,  ///&lt; CTRL-X typed in CTRL_X_CMDLINE</a>
<a name="ln94">};</a>
<a name="ln95"> </a>
<a name="ln96">#define CTRL_X_MSG(i) ctrl_x_msgs[(i) &amp; ~CTRL_X_WANT_IDENT]</a>
<a name="ln97"> </a>
<a name="ln98">/// Message for CTRL-X mode, index is ctrl_x_mode.</a>
<a name="ln99">static char *ctrl_x_msgs[] = {</a>
<a name="ln100">  N_(&quot; Keyword completion (^N^P)&quot;),  // CTRL_X_NORMAL, ^P/^N compl.</a>
<a name="ln101">  N_(&quot; ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)&quot;),</a>
<a name="ln102">  NULL,  // CTRL_X_SCROLL: depends on state</a>
<a name="ln103">  N_(&quot; Whole line completion (^L^N^P)&quot;),</a>
<a name="ln104">  N_(&quot; File name completion (^F^N^P)&quot;),</a>
<a name="ln105">  N_(&quot; Tag completion (^]^N^P)&quot;),</a>
<a name="ln106">  N_(&quot; Path pattern completion (^N^P)&quot;),</a>
<a name="ln107">  N_(&quot; Definition completion (^D^N^P)&quot;),</a>
<a name="ln108">  NULL,  // CTRL_X_FINISHED</a>
<a name="ln109">  N_(&quot; Dictionary completion (^K^N^P)&quot;),</a>
<a name="ln110">  N_(&quot; Thesaurus completion (^T^N^P)&quot;),</a>
<a name="ln111">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln112">  N_(&quot; User defined completion (^U^N^P)&quot;),</a>
<a name="ln113">  N_(&quot; Omni completion (^O^N^P)&quot;),</a>
<a name="ln114">  N_(&quot; Spelling suggestion (s^N^P)&quot;),</a>
<a name="ln115">  N_(&quot; Keyword Local completion (^N^P)&quot;),</a>
<a name="ln116">  NULL,  // CTRL_X_EVAL doesn't use msg.</a>
<a name="ln117">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">static char *ctrl_x_mode_names[] = {</a>
<a name="ln121">  &quot;keyword&quot;,</a>
<a name="ln122">  &quot;ctrl_x&quot;,</a>
<a name="ln123">  &quot;scroll&quot;,</a>
<a name="ln124">  &quot;whole_line&quot;,</a>
<a name="ln125">  &quot;files&quot;,</a>
<a name="ln126">  &quot;tags&quot;,</a>
<a name="ln127">  &quot;path_patterns&quot;,</a>
<a name="ln128">  &quot;path_defines&quot;,</a>
<a name="ln129">  &quot;unknown&quot;,          // CTRL_X_FINISHED</a>
<a name="ln130">  &quot;dictionary&quot;,</a>
<a name="ln131">  &quot;thesaurus&quot;,</a>
<a name="ln132">  &quot;cmdline&quot;,</a>
<a name="ln133">  &quot;function&quot;,</a>
<a name="ln134">  &quot;omni&quot;,</a>
<a name="ln135">  &quot;spell&quot;,</a>
<a name="ln136">  NULL,               // CTRL_X_LOCAL_MSG only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln137">  &quot;eval&quot;,</a>
<a name="ln138">  &quot;cmdline&quot;,</a>
<a name="ln139">};</a>
<a name="ln140"> </a>
<a name="ln141">// Array indexes used for cp_text[].</a>
<a name="ln142">#define CPT_ABBR        0   ///&lt; &quot;abbr&quot;</a>
<a name="ln143">#define CPT_MENU        1   ///&lt; &quot;menu&quot;</a>
<a name="ln144">#define CPT_KIND        2   ///&lt; &quot;kind&quot;</a>
<a name="ln145">#define CPT_INFO        3   ///&lt; &quot;info&quot;</a>
<a name="ln146">#define CPT_COUNT       4   ///&lt; Number of entries</a>
<a name="ln147"> </a>
<a name="ln148">/// Structure used to store one match for insert completion.</a>
<a name="ln149">typedef struct compl_S compl_T;</a>
<a name="ln150">struct compl_S {</a>
<a name="ln151">  compl_T *cp_next;</a>
<a name="ln152">  compl_T *cp_prev;</a>
<a name="ln153">  char *cp_str;                  ///&lt; matched text</a>
<a name="ln154">  char *(cp_text[CPT_COUNT]);    ///&lt; text for the menu</a>
<a name="ln155">  typval_T cp_user_data;</a>
<a name="ln156">  char *cp_fname;                ///&lt; file containing the match, allocated when</a>
<a name="ln157">                                 ///&lt; cp_flags has CP_FREE_FNAME</a>
<a name="ln158">  int cp_flags;                  ///&lt; CP_ values</a>
<a name="ln159">  int cp_number;                 ///&lt; sequence number</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">/// state information used for getting the next set of insert completion</a>
<a name="ln163">/// matches.</a>
<a name="ln164">typedef struct {</a>
<a name="ln165">  char *e_cpt_copy;       ///&lt; copy of 'complete'</a>
<a name="ln166">  char *e_cpt;            ///&lt; current entry in &quot;e_cpt_copy&quot;</a>
<a name="ln167">  buf_T *ins_buf;         ///&lt; buffer being scanned</a>
<a name="ln168">  pos_T *cur_match_pos;   ///&lt; current match position</a>
<a name="ln169">  pos_T prev_match_pos;   ///&lt; previous match position</a>
<a name="ln170">  bool set_match_pos;     ///&lt; save first_match_pos/last_match_pos</a>
<a name="ln171">  pos_T first_match_pos;  ///&lt; first match position</a>
<a name="ln172">  pos_T last_match_pos;   ///&lt; last match position</a>
<a name="ln173">  bool found_all;         ///&lt; found all matches of a certain type.</a>
<a name="ln174">  char *dict;             ///&lt; dictionary file to search</a>
<a name="ln175">  int dict_f;             ///&lt; &quot;dict&quot; is an exact file name or not</a>
<a name="ln176">} ins_compl_next_state_T;</a>
<a name="ln177"> </a>
<a name="ln178">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln179"># include &quot;insexpand.c.generated.h&quot;</a>
<a name="ln180">#endif</a>
<a name="ln181"> </a>
<a name="ln182">/// values for cp_flags</a>
<a name="ln183">typedef enum {</a>
<a name="ln184">  CP_ORIGINAL_TEXT = 1,  ///&lt; the original text when the expansion begun</a>
<a name="ln185">  CP_FREE_FNAME = 2,     ///&lt; cp_fname is allocated</a>
<a name="ln186">  CP_CONT_S_IPOS = 4,    ///&lt; use CONT_S_IPOS for compl_cont_status</a>
<a name="ln187">  CP_EQUAL = 8,          ///&lt; ins_compl_equal() always returns true</a>
<a name="ln188">  CP_ICASE = 16,         ///&lt; ins_compl_equal ignores case</a>
<a name="ln189">  CP_FAST = 32,          ///&lt; use fast_breakcheck instead of os_breakcheck</a>
<a name="ln190">} cp_flags_T;</a>
<a name="ln191"> </a>
<a name="ln192">static const char e_hitend[] = N_(&quot;Hit end of paragraph&quot;);</a>
<a name="ln193">static const char e_compldel[] = N_(&quot;E840: Completion function deleted text&quot;);</a>
<a name="ln194"> </a>
<a name="ln195">// All the current matches are stored in a list.</a>
<a name="ln196">// &quot;compl_first_match&quot; points to the start of the list.</a>
<a name="ln197">// &quot;compl_curr_match&quot; points to the currently selected entry.</a>
<a name="ln198">// &quot;compl_shown_match&quot; is different from compl_curr_match during</a>
<a name="ln199">// ins_compl_get_exp().</a>
<a name="ln200">// &quot;compl_old_match&quot; points to previous &quot;compl_curr_match&quot;.</a>
<a name="ln201"> </a>
<a name="ln202">static compl_T *compl_first_match = NULL;</a>
<a name="ln203">static compl_T *compl_curr_match = NULL;</a>
<a name="ln204">static compl_T *compl_shown_match = NULL;</a>
<a name="ln205">static compl_T *compl_old_match = NULL;</a>
<a name="ln206"> </a>
<a name="ln207">/// After using a cursor key &lt;Enter&gt; selects a match in the popup menu,</a>
<a name="ln208">/// otherwise it inserts a line break.</a>
<a name="ln209">static bool compl_enter_selects = false;</a>
<a name="ln210"> </a>
<a name="ln211">/// When &quot;compl_leader&quot; is not NULL only matches that start with this string</a>
<a name="ln212">/// are used.</a>
<a name="ln213">static char *compl_leader = NULL;</a>
<a name="ln214"> </a>
<a name="ln215">static bool compl_get_longest = false;  ///&lt; put longest common string in compl_leader</a>
<a name="ln216"> </a>
<a name="ln217">static bool compl_no_insert = false;    ///&lt; false: select &amp; insert</a>
<a name="ln218">                                        ///&lt; true: noinsert</a>
<a name="ln219">static bool compl_no_select = false;    ///&lt; false: select &amp; insert</a>
<a name="ln220">                                        ///&lt; true: noselect</a>
<a name="ln221">static bool compl_longest = false;      ///&lt; false: insert full match</a>
<a name="ln222">                                        ///&lt; true: insert longest prefix</a>
<a name="ln223"> </a>
<a name="ln224">/// Selected one of the matches. When false the match was edited or using the</a>
<a name="ln225">/// longest common string.</a>
<a name="ln226">static bool compl_used_match;</a>
<a name="ln227"> </a>
<a name="ln228">/// didn't finish finding completions.</a>
<a name="ln229">static bool compl_was_interrupted = false;</a>
<a name="ln230"> </a>
<a name="ln231">// Set when character typed while looking for matches and it means we should</a>
<a name="ln232">// stop looking for matches.</a>
<a name="ln233">static bool compl_interrupted = false;</a>
<a name="ln234"> </a>
<a name="ln235">static bool compl_restarting = false;   ///&lt; don't insert match</a>
<a name="ln236"> </a>
<a name="ln237">/// When the first completion is done &quot;compl_started&quot; is set.  When it's</a>
<a name="ln238">/// false the word to be completed must be located.</a>
<a name="ln239">static bool compl_started = false;</a>
<a name="ln240"> </a>
<a name="ln241">/// Which Ctrl-X mode are we in?</a>
<a name="ln242">static int ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln243"> </a>
<a name="ln244">static int compl_matches = 0;           ///&lt; number of completion matches</a>
<a name="ln245">static char *compl_pattern = NULL;</a>
<a name="ln246">static Direction compl_direction = FORWARD;</a>
<a name="ln247">static Direction compl_shows_dir = FORWARD;</a>
<a name="ln248">static int compl_pending = 0;           ///&lt; &gt; 1 for postponed CTRL-N</a>
<a name="ln249">static pos_T compl_startpos;</a>
<a name="ln250">/// Length in bytes of the text being completed (this is deleted to be replaced</a>
<a name="ln251">/// by the match.)</a>
<a name="ln252">static int compl_length = 0;</a>
<a name="ln253">static colnr_T compl_col = 0;           ///&lt; column where the text starts</a>
<a name="ln254">                                        ///&lt; that is being completed</a>
<a name="ln255">static char *compl_orig_text = NULL;    ///&lt; text as it was before</a>
<a name="ln256">                                        ///&lt; completion started</a>
<a name="ln257">static int compl_cont_mode = 0;</a>
<a name="ln258">static expand_T compl_xp;</a>
<a name="ln259"> </a>
<a name="ln260">// List of flags for method of completion.</a>
<a name="ln261">static int compl_cont_status = 0;</a>
<a name="ln262">#define CONT_ADDING    1        ///&lt; &quot;normal&quot; or &quot;adding&quot; expansion</a>
<a name="ln263">#define CONT_INTRPT    (2 + 4)  ///&lt; a ^X interrupted the current expansion</a>
<a name="ln264">                                ///&lt; it's set only iff N_ADDS is set</a>
<a name="ln265">#define CONT_N_ADDS    4        ///&lt; next ^X&lt;&gt; will add-new or expand-current</a>
<a name="ln266">#define CONT_S_IPOS    8        ///&lt; next ^X&lt;&gt; will set initial_pos?</a>
<a name="ln267">                                ///&lt; if so, word-wise-expansion will set SOL</a>
<a name="ln268">#define CONT_SOL       16       ///&lt; pattern includes start of line, just for</a>
<a name="ln269">                                ///&lt; word-wise expansion, not set for ^X^L</a>
<a name="ln270">#define CONT_LOCAL     32       ///&lt; for ctrl_x_mode 0, ^X^P/^X^N do a local</a>
<a name="ln271">                                ///&lt; expansion, (eg use complete=.)</a>
<a name="ln272"> </a>
<a name="ln273">static bool compl_opt_refresh_always = false;</a>
<a name="ln274"> </a>
<a name="ln275">static size_t spell_bad_len = 0;   // length of located bad word</a>
<a name="ln276"> </a>
<a name="ln277">static int pum_selected_item = -1;</a>
<a name="ln278"> </a>
<a name="ln279">/// CTRL-X pressed in Insert mode.</a>
<a name="ln280">void ins_ctrl_x(void)</a>
<a name="ln281">{</a>
<a name="ln282">  if (!ctrl_x_mode_cmdline()) {</a>
<a name="ln283">    // if the next ^X&lt;&gt; won't ADD nothing, then reset compl_cont_status</a>
<a name="ln284">    if (compl_cont_status &amp; CONT_N_ADDS) {</a>
<a name="ln285">      compl_cont_status |= CONT_INTRPT;</a>
<a name="ln286">    } else {</a>
<a name="ln287">      compl_cont_status = 0;</a>
<a name="ln288">    }</a>
<a name="ln289">    // We're not sure which CTRL-X mode it will be yet</a>
<a name="ln290">    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln291">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln292">    edit_submode_pre = NULL;</a>
<a name="ln293">    showmode();</a>
<a name="ln294">  } else {</a>
<a name="ln295">    // CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X</a>
<a name="ln296">    // CTRL-V look like CTRL-N</a>
<a name="ln297">    ctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  may_trigger_modechanged();</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">// Functions to check the current CTRL-X mode.</a>
<a name="ln304"> </a>
<a name="ln305">bool ctrl_x_mode_none(void)</a>
<a name="ln306">  FUNC_ATTR_PURE</a>
<a name="ln307">{</a>
<a name="ln308">  return ctrl_x_mode == 0;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">bool ctrl_x_mode_normal(void)</a>
<a name="ln312">  FUNC_ATTR_PURE</a>
<a name="ln313">{</a>
<a name="ln314">  return ctrl_x_mode == CTRL_X_NORMAL;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">bool ctrl_x_mode_scroll(void)</a>
<a name="ln318">  FUNC_ATTR_PURE</a>
<a name="ln319">{</a>
<a name="ln320">  return ctrl_x_mode == CTRL_X_SCROLL;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">bool ctrl_x_mode_whole_line(void)</a>
<a name="ln324">  FUNC_ATTR_PURE</a>
<a name="ln325">{</a>
<a name="ln326">  return ctrl_x_mode == CTRL_X_WHOLE_LINE;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">bool ctrl_x_mode_files(void)</a>
<a name="ln330">  FUNC_ATTR_PURE</a>
<a name="ln331">{</a>
<a name="ln332">  return ctrl_x_mode == CTRL_X_FILES;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">bool ctrl_x_mode_tags(void)</a>
<a name="ln336">  FUNC_ATTR_PURE</a>
<a name="ln337">{</a>
<a name="ln338">  return ctrl_x_mode == CTRL_X_TAGS;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">bool ctrl_x_mode_path_patterns(void)</a>
<a name="ln342">  FUNC_ATTR_PURE</a>
<a name="ln343">{</a>
<a name="ln344">  return ctrl_x_mode == CTRL_X_PATH_PATTERNS;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">bool ctrl_x_mode_path_defines(void)</a>
<a name="ln348">  FUNC_ATTR_PURE</a>
<a name="ln349">{</a>
<a name="ln350">  return ctrl_x_mode == CTRL_X_PATH_DEFINES;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">bool ctrl_x_mode_dictionary(void)</a>
<a name="ln354">  FUNC_ATTR_PURE</a>
<a name="ln355">{</a>
<a name="ln356">  return ctrl_x_mode == CTRL_X_DICTIONARY;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">bool ctrl_x_mode_thesaurus(void)</a>
<a name="ln360">  FUNC_ATTR_PURE</a>
<a name="ln361">{</a>
<a name="ln362">  return ctrl_x_mode == CTRL_X_THESAURUS;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">bool ctrl_x_mode_cmdline(void)</a>
<a name="ln366">  FUNC_ATTR_PURE</a>
<a name="ln367">{</a>
<a name="ln368">  return ctrl_x_mode == CTRL_X_CMDLINE || ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">bool ctrl_x_mode_function(void)</a>
<a name="ln372">  FUNC_ATTR_PURE</a>
<a name="ln373">{</a>
<a name="ln374">  return ctrl_x_mode == CTRL_X_FUNCTION;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">bool ctrl_x_mode_omni(void)</a>
<a name="ln378">  FUNC_ATTR_PURE</a>
<a name="ln379">{</a>
<a name="ln380">  return ctrl_x_mode == CTRL_X_OMNI;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">bool ctrl_x_mode_spell(void)</a>
<a name="ln384">  FUNC_ATTR_PURE</a>
<a name="ln385">{</a>
<a name="ln386">  return ctrl_x_mode == CTRL_X_SPELL;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">static bool ctrl_x_mode_eval(void)</a>
<a name="ln390">  FUNC_ATTR_PURE</a>
<a name="ln391">{</a>
<a name="ln392">  return ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">bool ctrl_x_mode_line_or_eval(void)</a>
<a name="ln396">  FUNC_ATTR_PURE</a>
<a name="ln397">{</a>
<a name="ln398">  return ctrl_x_mode == CTRL_X_WHOLE_LINE || ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">/// Whether other than default completion has been selected.</a>
<a name="ln402">bool ctrl_x_mode_not_default(void)</a>
<a name="ln403">  FUNC_ATTR_PURE</a>
<a name="ln404">{</a>
<a name="ln405">  return ctrl_x_mode != CTRL_X_NORMAL;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">/// Whether CTRL-X was typed without a following character,</a>
<a name="ln409">/// not including when in CTRL-X CTRL-V mode.</a>
<a name="ln410">bool ctrl_x_mode_not_defined_yet(void)</a>
<a name="ln411">  FUNC_ATTR_PURE</a>
<a name="ln412">{</a>
<a name="ln413">  return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">/// @return  true if currently in &quot;normal&quot; or &quot;adding&quot; insert completion matches state</a>
<a name="ln417">bool compl_status_adding(void)</a>
<a name="ln418">{</a>
<a name="ln419">  return compl_cont_status &amp; CONT_ADDING;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">/// @return  true if the completion pattern includes start of line, just for</a>
<a name="ln423">///          word-wise expansion.</a>
<a name="ln424">bool compl_status_sol(void)</a>
<a name="ln425">{</a>
<a name="ln426">  return compl_cont_status &amp; CONT_SOL;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/// @return  true if ^X^P/^X^N will do a local completion (i.e. use complete=.)</a>
<a name="ln430">bool compl_status_local(void)</a>
<a name="ln431">{</a>
<a name="ln432">  return compl_cont_status &amp; CONT_LOCAL;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">/// Clear the completion status flags</a>
<a name="ln436">void compl_status_clear(void)</a>
<a name="ln437">{</a>
<a name="ln438">  compl_cont_status = 0;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/// @return  true if completion is using the forward direction matches</a>
<a name="ln442">static bool compl_dir_forward(void)</a>
<a name="ln443">{</a>
<a name="ln444">  return compl_direction == FORWARD;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">/// @return  true if currently showing forward completion matches</a>
<a name="ln448">static bool compl_shows_dir_forward(void)</a>
<a name="ln449">{</a>
<a name="ln450">  return compl_shows_dir == FORWARD;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/// @return  true if currently showing backward completion matches</a>
<a name="ln454">static bool compl_shows_dir_backward(void)</a>
<a name="ln455">{</a>
<a name="ln456">  return compl_shows_dir == BACKWARD;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">/// Check that the 'dictionary' or 'thesaurus' option can be used.</a>
<a name="ln460">///</a>
<a name="ln461">/// @param  dict_opt  check 'dictionary' when true, 'thesaurus' when false.</a>
<a name="ln462">bool check_compl_option(bool dict_opt)</a>
<a name="ln463">{</a>
<a name="ln464">  if (dict_opt</a>
<a name="ln465">      ? (*curbuf-&gt;b_p_dict == NUL &amp;&amp; *p_dict == NUL &amp;&amp; !curwin-&gt;w_p_spell)</a>
<a name="ln466">      : (*curbuf-&gt;b_p_tsr == NUL &amp;&amp; *p_tsr == NUL</a>
<a name="ln467">         &amp;&amp; *curbuf-&gt;b_p_tsrfu == NUL &amp;&amp; *p_tsrfu == NUL)) {</a>
<a name="ln468">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln469">    edit_submode = NULL;</a>
<a name="ln470">    msg((dict_opt ? _(&quot;'dictionary' option is empty&quot;) : _(&quot;'thesaurus' option is empty&quot;)),</a>
<a name="ln471">        HL_ATTR(HLF_E));</a>
<a name="ln472">    if (emsg_silent == 0 &amp;&amp; !in_assert_fails) {</a>
<a name="ln473">      vim_beep(BO_COMPL);</a>
<a name="ln474">      setcursor();</a>
<a name="ln475">      ui_flush();</a>
<a name="ln476">      os_delay(2004L, false);</a>
<a name="ln477">    }</a>
<a name="ln478">    return false;</a>
<a name="ln479">  }</a>
<a name="ln480">  return true;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">/// Check that the character &quot;c&quot; a valid key to go to or keep us in CTRL-X mode?</a>
<a name="ln484">/// This depends on the current mode.</a>
<a name="ln485">///</a>
<a name="ln486">/// @param  c  character to check</a>
<a name="ln487">bool vim_is_ctrl_x_key(int c)</a>
<a name="ln488">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln489">{</a>
<a name="ln490">  // Always allow ^R - let its results then be checked</a>
<a name="ln491">  if (c == Ctrl_R) {</a>
<a name="ln492">    return true;</a>
<a name="ln493">  }</a>
<a name="ln494"> </a>
<a name="ln495">  // Accept &lt;PageUp&gt; and &lt;PageDown&gt; if the popup menu is visible.</a>
<a name="ln496">  if (ins_compl_pum_key(c)) {</a>
<a name="ln497">    return true;</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  switch (ctrl_x_mode) {</a>
<a name="ln501">  case 0:  // Not in any CTRL-X mode</a>
<a name="ln502">    return c == Ctrl_N || c == Ctrl_P || c == Ctrl_X;</a>
<a name="ln503">  case CTRL_X_NOT_DEFINED_YET:</a>
<a name="ln504">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln505">    return c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E</a>
<a name="ln506">           || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB</a>
<a name="ln507">           || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P</a>
<a name="ln508">           || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V</a>
<a name="ln509">           || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O</a>
<a name="ln510">           || c == Ctrl_S || c == Ctrl_K || c == 's'</a>
<a name="ln511">           || c == Ctrl_Z;</a>
<a name="ln512">  case CTRL_X_SCROLL:</a>
<a name="ln513">    return c == Ctrl_Y || c == Ctrl_E;</a>
<a name="ln514">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln515">    return c == Ctrl_L || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln516">  case CTRL_X_FILES:</a>
<a name="ln517">    return c == Ctrl_F || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln518">  case CTRL_X_DICTIONARY:</a>
<a name="ln519">    return c == Ctrl_K || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln520">  case CTRL_X_THESAURUS:</a>
<a name="ln521">    return c == Ctrl_T || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln522">  case CTRL_X_TAGS:</a>
<a name="ln523">    return c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln524">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln525">    return c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln526">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln527">    return c == Ctrl_D || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln528">  case CTRL_X_CMDLINE:</a>
<a name="ln529">    return c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N</a>
<a name="ln530">           || c == Ctrl_X;</a>
<a name="ln531">  case CTRL_X_FUNCTION:</a>
<a name="ln532">    return c == Ctrl_U || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln533">  case CTRL_X_OMNI:</a>
<a name="ln534">    return c == Ctrl_O || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln535">  case CTRL_X_SPELL:</a>
<a name="ln536">    return c == Ctrl_S || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln537">  case CTRL_X_EVAL:</a>
<a name="ln538">    return (c == Ctrl_P || c == Ctrl_N);</a>
<a name="ln539">  }</a>
<a name="ln540">  internal_error(&quot;vim_is_ctrl_x_key()&quot;);</a>
<a name="ln541">  return false;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">/// @return  true if &quot;match&quot; is the original text when the completion began.</a>
<a name="ln545">static bool match_at_original_text(const compl_T *const match)</a>
<a name="ln546">{</a>
<a name="ln547">  return match-&gt;cp_flags &amp; CP_ORIGINAL_TEXT;</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">/// @return  true if &quot;match&quot; is the first match in the completion list.</a>
<a name="ln551">static bool is_first_match(const compl_T *const match)</a>
<a name="ln552">{</a>
<a name="ln553">  return match == compl_first_match;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/// Check that character &quot;c&quot; is part of the item currently being</a>
<a name="ln557">/// completed.  Used to decide whether to abandon complete mode when the menu</a>
<a name="ln558">/// is visible.</a>
<a name="ln559">///</a>
<a name="ln560">/// @param  c  character to check</a>
<a name="ln561">bool ins_compl_accept_char(int c)</a>
<a name="ln562">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln563">{</a>
<a name="ln564">  if (ctrl_x_mode &amp; CTRL_X_WANT_IDENT) {</a>
<a name="ln565">    // When expanding an identifier only accept identifier chars.</a>
<a name="ln566">    return vim_isIDc(c);</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  switch (ctrl_x_mode) {</a>
<a name="ln570">  case CTRL_X_FILES:</a>
<a name="ln571">    // When expanding file name only accept file name chars. But not</a>
<a name="ln572">    // path separators, so that &quot;proto/&lt;Tab&gt;&quot; expands files in</a>
<a name="ln573">    // &quot;proto&quot;, not &quot;proto/&quot; as a whole</a>
<a name="ln574">    return vim_isfilec(c) &amp;&amp; !vim_ispathsep(c);</a>
<a name="ln575"> </a>
<a name="ln576">  case CTRL_X_CMDLINE:</a>
<a name="ln577">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln578">  case CTRL_X_OMNI:</a>
<a name="ln579">    // Command line and Omni completion can work with just about any</a>
<a name="ln580">    // printable character, but do stop at white space.</a>
<a name="ln581">    return vim_isprintc(c) &amp;&amp; !ascii_iswhite(c);</a>
<a name="ln582"> </a>
<a name="ln583">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln584">    // For while line completion a space can be part of the line.</a>
<a name="ln585">    return vim_isprintc(c);</a>
<a name="ln586">  }</a>
<a name="ln587">  return vim_iswordc(c);</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">/// Get the completed text by inferring the case of the originally typed text.</a>
<a name="ln591">/// If the result is in allocated memory &quot;tofree&quot; is set to it.</a>
<a name="ln592">static char *ins_compl_infercase_gettext(const char *str, int char_len, int compl_char_len,</a>
<a name="ln593">                                         int min_len, char **tofree)</a>
<a name="ln594">{</a>
<a name="ln595">  bool has_lower = false;</a>
<a name="ln596">  bool was_letter = false;</a>
<a name="ln597"> </a>
<a name="ln598">  // Allocate wide character array for the completion and fill it.</a>
<a name="ln599">  int *const wca = xmalloc((size_t)char_len * sizeof(*wca));</a>
<a name="ln600">  {</a>
<a name="ln601">    const char *p = str;</a>
<a name="ln602">    for (int i = 0; i &lt; char_len; i++) {</a>
<a name="ln603">      wca[i] = mb_ptr2char_adv(&amp;p);</a>
<a name="ln604">    }</a>
<a name="ln605">  }</a>
<a name="ln606"> </a>
<a name="ln607">  // Rule 1: Were any chars converted to lower?</a>
<a name="ln608">  {</a>
<a name="ln609">    const char *p = compl_orig_text;</a>
<a name="ln610">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln611">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln612">      if (mb_islower(c)) {</a>
<a name="ln613">        has_lower = true;</a>
<a name="ln614">        if (mb_isupper(wca[i])) {</a>
<a name="ln615">          // Rule 1 is satisfied.</a>
<a name="ln616">          for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln617">            wca[i] = mb_tolower(wca[i]);</a>
<a name="ln618">          }</a>
<a name="ln619">          break;</a>
<a name="ln620">        }</a>
<a name="ln621">      }</a>
<a name="ln622">    }</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  // Rule 2: No lower case, 2nd consecutive letter converted to</a>
<a name="ln626">  // upper case.</a>
<a name="ln627">  if (!has_lower) {</a>
<a name="ln628">    const char *p = compl_orig_text;</a>
<a name="ln629">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln630">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln631">      if (was_letter &amp;&amp; mb_isupper(c) &amp;&amp; mb_islower(wca[i])) {</a>
<a name="ln632">        // Rule 2 is satisfied.</a>
<a name="ln633">        for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln634">          wca[i] = mb_toupper(wca[i]);</a>
<a name="ln635">        }</a>
<a name="ln636">        break;</a>
<a name="ln637">      }</a>
<a name="ln638">      was_letter = mb_islower(c) || mb_isupper(c);</a>
<a name="ln639">    }</a>
<a name="ln640">  }</a>
<a name="ln641"> </a>
<a name="ln642">  // Copy the original case of the part we typed.</a>
<a name="ln643">  {</a>
<a name="ln644">    const char *p = compl_orig_text;</a>
<a name="ln645">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln646">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln647">      if (mb_islower(c)) {</a>
<a name="ln648">        wca[i] = mb_tolower(wca[i]);</a>
<a name="ln649">      } else if (mb_isupper(c)) {</a>
<a name="ln650">        wca[i] = mb_toupper(wca[i]);</a>
<a name="ln651">      }</a>
<a name="ln652">    }</a>
<a name="ln653">  }</a>
<a name="ln654"> </a>
<a name="ln655">  // Generate encoding specific output from wide character array.</a>
<a name="ln656">  garray_T gap;</a>
<a name="ln657">  char *p = IObuff;</a>
<a name="ln658">  int i = 0;</a>
<a name="ln659">  ga_init(&amp;gap, 1, 500);</a>
<a name="ln660">  while (i &lt; char_len) {</a>
<a name="ln661">    if (gap.ga_data != NULL) {</a>
<a name="ln662">      ga_grow(&amp;gap, 10);</a>
<a name="ln663">      assert(gap.ga_data != NULL);  // suppress clang &quot;Dereference of NULL pointer&quot;</a>
<a name="ln664">      p = (char *)gap.ga_data + gap.ga_len;</a>
<a name="ln665">      gap.ga_len += utf_char2bytes(wca[i++], p);</a>
<a name="ln666">    } else if ((p - IObuff) + 6 &gt;= IOSIZE) {</a>
<a name="ln667">      // Multi-byte characters can occupy up to five bytes more than</a>
<a name="ln668">      // ASCII characters, and we also need one byte for NUL, so when</a>
<a name="ln669">      // getting to six bytes from the edge of IObuff switch to using a</a>
<a name="ln670">      // growarray.  Add the character in the next round.</a>
<a name="ln671">      ga_grow(&amp;gap, IOSIZE);</a>
<a name="ln672">      *p = NUL;</a>
<a name="ln673">      STRCPY(gap.ga_data, IObuff);</a>
<a name="ln674">      gap.ga_len = (int)strlen(IObuff);</a>
<a name="ln675">    } else {</a>
<a name="ln676">      p += utf_char2bytes(wca[i++], p);</a>
<a name="ln677">    }</a>
<a name="ln678">  }</a>
<a name="ln679">  xfree(wca);</a>
<a name="ln680"> </a>
<a name="ln681">  if (gap.ga_data != NULL) {</a>
<a name="ln682">    *tofree = gap.ga_data;</a>
<a name="ln683">    return gap.ga_data;</a>
<a name="ln684">  }</a>
<a name="ln685"> </a>
<a name="ln686">  *p = NUL;</a>
<a name="ln687">  return IObuff;</a>
<a name="ln688">}</a>
<a name="ln689"> </a>
<a name="ln690">/// This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the</a>
<a name="ln691">/// case of the originally typed text is used, and the case of the completed</a>
<a name="ln692">/// text is inferred, ie this tries to work out what case you probably wanted</a>
<a name="ln693">/// the rest of the word to be in -- webb</a>
<a name="ln694">///</a>
<a name="ln695">/// @param[in]  cont_s_ipos  next ^X&lt;&gt; will set initial_pos</a>
<a name="ln696">int ins_compl_add_infercase(char *str_arg, int len, bool icase, char *fname, Direction dir,</a>
<a name="ln697">                            bool cont_s_ipos)</a>
<a name="ln698">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln699">{</a>
<a name="ln700">  char *str = str_arg;</a>
<a name="ln701">  int char_len;  // count multi-byte characters</a>
<a name="ln702">  int compl_char_len;</a>
<a name="ln703">  int flags = 0;</a>
<a name="ln704">  char *tofree = NULL;</a>
<a name="ln705"> </a>
<a name="ln706">  if (p_ic &amp;&amp; curbuf-&gt;b_p_inf &amp;&amp; len &gt; 0) {</a>
<a name="ln707">    // Infer case of completed part.</a>
<a name="ln708"> </a>
<a name="ln709">    // Find actual length of completion.</a>
<a name="ln710">    {</a>
<a name="ln711">      const char *p = str;</a>
<a name="ln712">      char_len = 0;</a>
<a name="ln713">      while (*p != NUL) {</a>
<a name="ln714">        MB_PTR_ADV(p);</a>
<a name="ln715">        char_len++;</a>
<a name="ln716">      }</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    // Find actual length of original text.</a>
<a name="ln720">    {</a>
<a name="ln721">      const char *p = compl_orig_text;</a>
<a name="ln722">      compl_char_len = 0;</a>
<a name="ln723">      while (*p != NUL) {</a>
<a name="ln724">        MB_PTR_ADV(p);</a>
<a name="ln725">        compl_char_len++;</a>
<a name="ln726">      }</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    // &quot;char_len&quot; may be smaller than &quot;compl_char_len&quot; when using</a>
<a name="ln730">    // thesaurus, only use the minimum when comparing.</a>
<a name="ln731">    int min_len = char_len &lt; compl_char_len ? char_len : compl_char_len;</a>
<a name="ln732"> </a>
<a name="ln733">    str = ins_compl_infercase_gettext(str, char_len, compl_char_len, min_len, &amp;tofree);</a>
<a name="ln734">  }</a>
<a name="ln735">  if (cont_s_ipos) {</a>
<a name="ln736">    flags |= CP_CONT_S_IPOS;</a>
<a name="ln737">  }</a>
<a name="ln738">  if (icase) {</a>
<a name="ln739">    flags |= CP_ICASE;</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  int res = ins_compl_add(str, len, fname, NULL, false, NULL, dir, flags, false);</a>
<a name="ln743">  xfree(tofree);</a>
<a name="ln744">  return res;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">/// Add a match to the list of matches</a>
<a name="ln748">///</a>
<a name="ln749">/// @param[in]  str     text of the match to add</a>
<a name="ln750">/// @param[in]  len     length of &quot;str&quot;. If -1, then the length of &quot;str&quot; is computed.</a>
<a name="ln751">/// @param[in]  fname   file name to associate with this match. May be NULL.</a>
<a name="ln752">/// @param[in]  cptext  list of strings to use with this match (for abbr, menu, info</a>
<a name="ln753">///                     and kind). May be NULL.</a>
<a name="ln754">///                     If not NULL, must have exactly #CPT_COUNT items.</a>
<a name="ln755">/// @param[in]  cptext_allocated  If true, will not copy cptext strings.</a>
<a name="ln756">///</a>
<a name="ln757">///                               @note Will free strings in case of error.</a>
<a name="ln758">///                                     cptext itself will not be freed.</a>
<a name="ln759">/// @param[in]  user_data  user supplied data (any vim type) for this match</a>
<a name="ln760">/// @param[in]  cdir       match direction. If 0, use &quot;compl_direction&quot;.</a>
<a name="ln761">/// @param[in]  flags_arg  match flags (cp_flags)</a>
<a name="ln762">/// @param[in]  adup       accept this match even if it is already present.</a>
<a name="ln763">///</a>
<a name="ln764">/// If &quot;cdir&quot; is FORWARD, then the match is added after the current match.</a>
<a name="ln765">/// Otherwise, it is added before the current match.</a>
<a name="ln766">///</a>
<a name="ln767">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln768">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln769">///         returned in case of error.</a>
<a name="ln770">static int ins_compl_add(char *const str, int len, char *const fname, char *const *const cptext,</a>
<a name="ln771">                         const bool cptext_allocated, typval_T *user_data, const Direction cdir,</a>
<a name="ln772">                         int flags_arg, const bool adup)</a>
<a name="ln773">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln774">{</a>
<a name="ln775">  compl_T *match;</a>
<a name="ln776">  const Direction dir = (cdir == kDirectionNotSet ? compl_direction : cdir);</a>
<a name="ln777">  int flags = flags_arg;</a>
<a name="ln778"> </a>
<a name="ln779">  if (flags &amp; CP_FAST) {</a>
<a name="ln780">    fast_breakcheck();</a>
<a name="ln781">  } else {</a>
<a name="ln782">    os_breakcheck();</a>
<a name="ln783">  }</a>
<a name="ln784">#define FREE_CPTEXT(cptext, cptext_allocated) \</a>
<a name="ln785">  do { \</a>
<a name="ln786">    if ((cptext) != NULL &amp;&amp; (cptext_allocated)) { \</a>
<a name="ln787">      for (size_t i = 0; i &lt; CPT_COUNT; i++) { \</a>
<a name="ln788">        xfree((cptext)[i]); \</a>
<a name="ln789">      } \</a>
<a name="ln790">    } \</a>
<a name="ln791">  } while (0)</a>
<a name="ln792">  if (got_int) {</a>
<a name="ln793">    FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln794">    return FAIL;</a>
<a name="ln795">  }</a>
<a name="ln796">  if (len &lt; 0) {</a>
<a name="ln797">    len = (int)strlen(str);</a>
<a name="ln798">  }</a>
<a name="ln799"> </a>
<a name="ln800">  // If the same match is already present, don't add it.</a>
<a name="ln801">  if (compl_first_match != NULL &amp;&amp; !adup) {</a>
<a name="ln802">    match = compl_first_match;</a>
<a name="ln803">    do {</a>
<a name="ln804">      if (!match_at_original_text(match)</a>
<a name="ln805">          &amp;&amp; strncmp(match-&gt;cp_str, str, (size_t)len) == 0</a>
<a name="ln806">          &amp;&amp; ((int)strlen(match-&gt;cp_str) &lt;= len || match-&gt;cp_str[len] == NUL)) {</a>
<a name="ln807">        FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln808">        return NOTDONE;</a>
<a name="ln809">      }</a>
<a name="ln810">      match = match-&gt;cp_next;</a>
<a name="ln811">    } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln812">  }</a>
<a name="ln813"> </a>
<a name="ln814">  // Remove any popup menu before changing the list of matches.</a>
<a name="ln815">  ins_compl_del_pum();</a>
<a name="ln816"> </a>
<a name="ln817">  // Allocate a new match structure.</a>
<a name="ln818">  // Copy the values to the new match structure.</a>
<a name="ln819">  match = xcalloc(1, sizeof(compl_T));</a>
<a name="ln820">  match-&gt;cp_number = -1;</a>
<a name="ln821">  if (flags &amp; CP_ORIGINAL_TEXT) {</a>
<a name="ln822">    match-&gt;cp_number = 0;</a>
<a name="ln823">  }</a>
<a name="ln824">  match-&gt;cp_str = xstrnsave(str, (size_t)len);</a>
<a name="ln825"> </a>
<a name="ln826">  // match-fname is:</a>
<a name="ln827">  // - compl_curr_match-&gt;cp_fname if it is a string equal to fname.</a>
<a name="ln828">  // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.</a>
<a name="ln829">  // - NULL otherwise.  --Acevedo</a>
<a name="ln830">  if (fname != NULL</a>
<a name="ln831">      &amp;&amp; compl_curr_match != NULL</a>
<a name="ln832">      &amp;&amp; compl_curr_match-&gt;cp_fname != NULL</a>
<a name="ln833">      &amp;&amp; strcmp(fname, compl_curr_match-&gt;cp_fname) == 0) {</a>
<a name="ln834">    match-&gt;cp_fname = compl_curr_match-&gt;cp_fname;</a>
<a name="ln835">  } else if (fname != NULL) {</a>
<a name="ln836">    match-&gt;cp_fname = xstrdup(fname);</a>
<a name="ln837">    flags |= CP_FREE_FNAME;</a>
<a name="ln838">  } else {</a>
<a name="ln839">    match-&gt;cp_fname = NULL;</a>
<a name="ln840">  }</a>
<a name="ln841">  match-&gt;cp_flags = flags;</a>
<a name="ln842"> </a>
<a name="ln843">  if (cptext != NULL) {</a>
<a name="ln844">    int i;</a>
<a name="ln845"> </a>
<a name="ln846">    for (i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln847">      if (cptext[i] == NULL) {</a>
<a name="ln848">        continue;</a>
<a name="ln849">      }</a>
<a name="ln850">      if (*cptext[i] != NUL) {</a>
<a name="ln851">        match-&gt;cp_text[i] = (cptext_allocated ? cptext[i] : xstrdup(cptext[i]));</a>
<a name="ln852">      } else if (cptext_allocated) {</a>
<a name="ln853">        xfree(cptext[i]);</a>
<a name="ln854">      }</a>
<a name="ln855">    }</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858">  if (user_data != NULL) {</a>
<a name="ln859">    match-&gt;cp_user_data = *user_data;</a>
<a name="ln860">  }</a>
<a name="ln861"> </a>
<a name="ln862">  // Link the new match structure after (FORWARD) or before (BACKWARD) the</a>
<a name="ln863">  // current match in the list of matches .</a>
<a name="ln864">  if (compl_first_match == NULL) {</a>
<a name="ln865">    match-&gt;cp_next = match-&gt;cp_prev = NULL;</a>
<a name="ln866">  } else if (dir == FORWARD) {</a>
<a name="ln867">    match-&gt;cp_next = compl_curr_match-&gt;cp_next;</a>
<a name="ln868">    match-&gt;cp_prev = compl_curr_match;</a>
<a name="ln869">  } else {    // BACKWARD</a>
<a name="ln870">    match-&gt;cp_next = compl_curr_match;</a>
<a name="ln871">    match-&gt;cp_prev = compl_curr_match-&gt;cp_prev;</a>
<a name="ln872">  }</a>
<a name="ln873">  if (match-&gt;cp_next) {</a>
<a name="ln874">    match-&gt;cp_next-&gt;cp_prev = match;</a>
<a name="ln875">  }</a>
<a name="ln876">  if (match-&gt;cp_prev) {</a>
<a name="ln877">    match-&gt;cp_prev-&gt;cp_next = match;</a>
<a name="ln878">  } else {        // if there's nothing before, it is the first match</a>
<a name="ln879">    compl_first_match = match;</a>
<a name="ln880">  }</a>
<a name="ln881">  compl_curr_match = match;</a>
<a name="ln882"> </a>
<a name="ln883">  // Find the longest common string if still doing that.</a>
<a name="ln884">  if (compl_get_longest &amp;&amp; (flags &amp; CP_ORIGINAL_TEXT) == 0) {</a>
<a name="ln885">    ins_compl_longest_match(match);</a>
<a name="ln886">  }</a>
<a name="ln887"> </a>
<a name="ln888">  return OK;</a>
<a name="ln889">}</a>
<a name="ln890"> </a>
<a name="ln891">/// Check that &quot;str[len]&quot; matches with &quot;match-&gt;cp_str&quot;, considering</a>
<a name="ln892">/// &quot;match-&gt;cp_flags&quot;.</a>
<a name="ln893">///</a>
<a name="ln894">/// @param  match  completion match</a>
<a name="ln895">/// @param  str    character string to check</a>
<a name="ln896">/// @param  len    length of &quot;str&quot;</a>
<a name="ln897">static bool ins_compl_equal(compl_T *match, char *str, size_t len)</a>
<a name="ln898">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln899">{</a>
<a name="ln900">  if (match-&gt;cp_flags &amp; CP_EQUAL) {</a>
<a name="ln901">    return true;</a>
<a name="ln902">  }</a>
<a name="ln903">  if (match-&gt;cp_flags &amp; CP_ICASE) {</a>
<a name="ln904">    return STRNICMP(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln905">  }</a>
<a name="ln906">  return strncmp(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">/// Reduce the longest common string for match &quot;match&quot;.</a>
<a name="ln910">static void ins_compl_longest_match(compl_T *match)</a>
<a name="ln911">{</a>
<a name="ln912">  char *p, *s;</a>
<a name="ln913">  int c1, c2;</a>
<a name="ln914">  int had_match;</a>
<a name="ln915"> </a>
<a name="ln916">  if (compl_leader == NULL) {</a>
<a name="ln917">    // First match, use it as a whole.</a>
<a name="ln918">    compl_leader = xstrdup(match-&gt;cp_str);</a>
<a name="ln919"> </a>
<a name="ln920">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln921">    ins_compl_delete();</a>
<a name="ln922">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln923">    ins_redraw(false);</a>
<a name="ln924"> </a>
<a name="ln925">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln926">    // again after redrawing.</a>
<a name="ln927">    if (!had_match) {</a>
<a name="ln928">      ins_compl_delete();</a>
<a name="ln929">    }</a>
<a name="ln930">    compl_used_match = false;</a>
<a name="ln931"> </a>
<a name="ln932">    return;</a>
<a name="ln933">  }</a>
<a name="ln934"> </a>
<a name="ln935">  // Reduce the text if this match differs from compl_leader.</a>
<a name="ln936">  p = compl_leader;</a>
<a name="ln937">  s = match-&gt;cp_str;</a>
<a name="ln938">  while (*p != NUL) {</a>
<a name="ln939">    c1 = utf_ptr2char(p);</a>
<a name="ln940">    c2 = utf_ptr2char(s);</a>
<a name="ln941"> </a>
<a name="ln942">    if ((match-&gt;cp_flags &amp; CP_ICASE)</a>
<a name="ln943">        ? (mb_tolower(c1) != mb_tolower(c2))</a>
<a name="ln944">        : (c1 != c2)) {</a>
<a name="ln945">      break;</a>
<a name="ln946">    }</a>
<a name="ln947">    MB_PTR_ADV(p);</a>
<a name="ln948">    MB_PTR_ADV(s);</a>
<a name="ln949">  }</a>
<a name="ln950"> </a>
<a name="ln951">  if (*p != NUL) {</a>
<a name="ln952">    // Leader was shortened, need to change the inserted text.</a>
<a name="ln953">    *p = NUL;</a>
<a name="ln954">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln955">    ins_compl_delete();</a>
<a name="ln956">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln957">    ins_redraw(false);</a>
<a name="ln958"> </a>
<a name="ln959">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln960">    // again after redrawing.</a>
<a name="ln961">    if (!had_match) {</a>
<a name="ln962">      ins_compl_delete();</a>
<a name="ln963">    }</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966">  compl_used_match = false;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">/// Add an array of matches to the list of matches.</a>
<a name="ln970">/// Frees matches[].</a>
<a name="ln971">static void ins_compl_add_matches(int num_matches, char **matches, int icase)</a>
<a name="ln972">{</a>
<a name="ln973">  int add_r = OK;</a>
<a name="ln974">  Direction dir = compl_direction;</a>
<a name="ln975"> </a>
<a name="ln976">  for (int i = 0; i &lt; num_matches &amp;&amp; add_r != FAIL; i++) {</a>
<a name="ln977">    if ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, false, NULL, dir,</a>
<a name="ln978">                               CP_FAST | (icase ? CP_ICASE : 0),</a>
<a name="ln979">                               false)) == OK) {</a>
<a name="ln980">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln981">      dir = FORWARD;</a>
<a name="ln982">    }</a>
<a name="ln983">  }</a>
<a name="ln984">  FreeWild(num_matches, matches);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">/// Make the completion list cyclic.</a>
<a name="ln988">/// Return the number of matches (excluding the original).</a>
<a name="ln989">static int ins_compl_make_cyclic(void)</a>
<a name="ln990">{</a>
<a name="ln991">  if (compl_first_match == NULL) {</a>
<a name="ln992">    return 0;</a>
<a name="ln993">  }</a>
<a name="ln994"> </a>
<a name="ln995">  // Find the end of the list.</a>
<a name="ln996">  compl_T *match = compl_first_match;</a>
<a name="ln997">  int count = 0;</a>
<a name="ln998">  // there's always an entry for the compl_orig_text, it doesn't count.</a>
<a name="ln999">  while (match-&gt;cp_next != NULL &amp;&amp; !is_first_match(match-&gt;cp_next)) {</a>
<a name="ln1000">    match = match-&gt;cp_next;</a>
<a name="ln1001">    count++;</a>
<a name="ln1002">  }</a>
<a name="ln1003">  match-&gt;cp_next = compl_first_match;</a>
<a name="ln1004">  compl_first_match-&gt;cp_prev = match;</a>
<a name="ln1005"> </a>
<a name="ln1006">  return count;</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">/// Return whether there currently is a shown match.</a>
<a name="ln1010">bool ins_compl_has_shown_match(void)</a>
<a name="ln1011">{</a>
<a name="ln1012">  return compl_shown_match == NULL || compl_shown_match != compl_shown_match-&gt;cp_next;</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">/// Return whether the shown match is long enough.</a>
<a name="ln1016">bool ins_compl_long_shown_match(void)</a>
<a name="ln1017">{</a>
<a name="ln1018">  return compl_shown_match != NULL &amp;&amp; compl_shown_match-&gt;cp_str != NULL</a>
<a name="ln1019">         &amp;&amp; (colnr_T)strlen(compl_shown_match-&gt;cp_str) &gt; curwin-&gt;w_cursor.col - compl_col;</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">/// Set variables that store noselect and noinsert behavior from the</a>
<a name="ln1023">/// 'completeopt' value.</a>
<a name="ln1024">void completeopt_was_set(void)</a>
<a name="ln1025">{</a>
<a name="ln1026">  compl_no_insert = false;</a>
<a name="ln1027">  compl_no_select = false;</a>
<a name="ln1028">  compl_longest = false;</a>
<a name="ln1029">  if (strstr(p_cot, &quot;noselect&quot;) != NULL) {</a>
<a name="ln1030">    compl_no_select = true;</a>
<a name="ln1031">  }</a>
<a name="ln1032">  if (strstr(p_cot, &quot;noinsert&quot;) != NULL) {</a>
<a name="ln1033">    compl_no_insert = true;</a>
<a name="ln1034">  }</a>
<a name="ln1035">  if (strstr(p_cot, &quot;longest&quot;) != NULL) {</a>
<a name="ln1036">    compl_longest = true;</a>
<a name="ln1037">  }</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">/// &quot;compl_match_array&quot; points the currently displayed list of entries in the</a>
<a name="ln1041">/// popup menu.  It is NULL when there is no popup menu.</a>
<a name="ln1042">static pumitem_T *compl_match_array = NULL;</a>
<a name="ln1043">static int compl_match_arraysize;</a>
<a name="ln1044"> </a>
<a name="ln1045">/// Remove any popup menu.</a>
<a name="ln1046">static void ins_compl_del_pum(void)</a>
<a name="ln1047">{</a>
<a name="ln1048">  if (compl_match_array == NULL) {</a>
<a name="ln1049">    return;</a>
<a name="ln1050">  }</a>
<a name="ln1051"> </a>
<a name="ln1052">  pum_undisplay(false);</a>
<a name="ln1053">  XFREE_CLEAR(compl_match_array);</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">/// Check if the popup menu should be displayed.</a>
<a name="ln1057">bool pum_wanted(void)</a>
<a name="ln1058">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1059">{</a>
<a name="ln1060">  // &quot;completeopt&quot; must contain &quot;menu&quot; or &quot;menuone&quot;</a>
<a name="ln1061">  return vim_strchr(p_cot, 'm') != NULL;</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">/// Check that there are two or more matches to be shown in the popup menu.</a>
<a name="ln1065">/// One if &quot;completopt&quot; contains &quot;menuone&quot;.</a>
<a name="ln1066">static bool pum_enough_matches(void)</a>
<a name="ln1067">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1068">{</a>
<a name="ln1069">  // Don't display the popup menu if there are no matches or there is only</a>
<a name="ln1070">  // one (ignoring the original text).</a>
<a name="ln1071">  compl_T *comp = compl_first_match;</a>
<a name="ln1072">  int i = 0;</a>
<a name="ln1073">  do {</a>
<a name="ln1074">    if (comp == NULL || (!match_at_original_text(comp) &amp;&amp; ++i == 2)) {</a>
<a name="ln1075">      break;</a>
<a name="ln1076">    }</a>
<a name="ln1077">    comp = comp-&gt;cp_next;</a>
<a name="ln1078">  } while (!is_first_match(comp));</a>
<a name="ln1079"> </a>
<a name="ln1080">  if (strstr(p_cot, &quot;menuone&quot;) != NULL) {</a>
<a name="ln1081">    return i &gt;= 1;</a>
<a name="ln1082">  }</a>
<a name="ln1083">  return i &gt;= 2;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">/// Convert to complete item dict</a>
<a name="ln1087">static dict_T *ins_compl_dict_alloc(compl_T *match)</a>
<a name="ln1088">{</a>
<a name="ln1089">  // { word, abbr, menu, kind, info }</a>
<a name="ln1090">  dict_T *dict = tv_dict_alloc_lock(VAR_FIXED);</a>
<a name="ln1091">  tv_dict_add_str(dict, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln1092">  tv_dict_add_str(dict, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln1093">  tv_dict_add_str(dict, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln1094">  tv_dict_add_str(dict, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln1095">  tv_dict_add_str(dict, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln1096">  if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln1097">    tv_dict_add_str(dict, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln1098">  } else {</a>
<a name="ln1099">    tv_dict_add_tv(dict, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln1100">  }</a>
<a name="ln1101">  return dict;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">/// Trigger the CompleteChanged autocmd event. Invoked each time the Insert mode</a>
<a name="ln1105">/// completion menu is changed.</a>
<a name="ln1106">static void trigger_complete_changed_event(int cur)</a>
<a name="ln1107">{</a>
<a name="ln1108">  static bool recursive = false;</a>
<a name="ln1109">  save_v_event_T save_v_event;</a>
<a name="ln1110"> </a>
<a name="ln1111">  if (recursive) {</a>
<a name="ln1112">    return;</a>
<a name="ln1113">  }</a>
<a name="ln1114"> </a>
<a name="ln1115">  dict_T *v_event = get_v_event(&amp;save_v_event);</a>
<a name="ln1116">  if (cur &lt; 0) {</a>
<a name="ln1117">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), tv_dict_alloc());</a>
<a name="ln1118">  } else {</a>
<a name="ln1119">    dict_T *item = ins_compl_dict_alloc(compl_curr_match);</a>
<a name="ln1120">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), item);</a>
<a name="ln1121">  }</a>
<a name="ln1122">  pum_set_event_info(v_event);</a>
<a name="ln1123">  tv_dict_set_keys_readonly(v_event);</a>
<a name="ln1124"> </a>
<a name="ln1125">  recursive = true;</a>
<a name="ln1126">  textlock++;</a>
<a name="ln1127">  apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, false, curbuf);</a>
<a name="ln1128">  textlock--;</a>
<a name="ln1129">  recursive = false;</a>
<a name="ln1130"> </a>
<a name="ln1131">  restore_v_event(v_event, &amp;save_v_event);</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">/// Build a popup menu to show the completion matches.</a>
<a name="ln1135">///</a>
<a name="ln1136">/// @return  the popup menu entry that should be selected,</a>
<a name="ln1137">///          -1 if nothing should be selected.</a>
<a name="ln1138">static int ins_compl_build_pum(void)</a>
<a name="ln1139">{</a>
<a name="ln1140">  // Need to build the popup menu list.</a>
<a name="ln1141">  compl_match_arraysize = 0;</a>
<a name="ln1142">  compl_T *comp = compl_first_match;</a>
<a name="ln1143"> </a>
<a name="ln1144">  // If it's user complete function and refresh_always,</a>
<a name="ln1145">  // do not use &quot;compl_leader&quot; as prefix filter.</a>
<a name="ln1146">  if (ins_compl_need_restart()) {</a>
<a name="ln1147">    XFREE_CLEAR(compl_leader);</a>
<a name="ln1148">  }</a>
<a name="ln1149"> </a>
<a name="ln1150">  const int lead_len = compl_leader != NULL ? (int)strlen(compl_leader) : 0;</a>
<a name="ln1151"> </a>
<a name="ln1152">  do {</a>
<a name="ln1153">    if (!match_at_original_text(comp)</a>
<a name="ln1154">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1155">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1156">      compl_match_arraysize++;</a>
<a name="ln1157">    }</a>
<a name="ln1158">    comp = comp-&gt;cp_next;</a>
<a name="ln1159">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1160"> </a>
<a name="ln1161">  if (compl_match_arraysize == 0) {</a>
<a name="ln1162">    return -1;</a>
<a name="ln1163">  }</a>
<a name="ln1164"> </a>
<a name="ln1165">  assert(compl_match_arraysize &gt;= 0);</a>
<a name="ln1166">  compl_match_array = xcalloc((size_t)compl_match_arraysize, sizeof(pumitem_T));</a>
<a name="ln1167"> </a>
<a name="ln1168">  // If the current match is the original text don't find the first</a>
<a name="ln1169">  // match after it, don't highlight anything.</a>
<a name="ln1170">  bool shown_match_ok = match_at_original_text(compl_shown_match);</a>
<a name="ln1171"> </a>
<a name="ln1172">  compl_T *shown_compl = NULL;</a>
<a name="ln1173">  bool did_find_shown_match = false;</a>
<a name="ln1174">  int cur = -1;</a>
<a name="ln1175">  int i = 0;</a>
<a name="ln1176">  comp = compl_first_match;</a>
<a name="ln1177">  do {</a>
<a name="ln1178">    if (!match_at_original_text(comp)</a>
<a name="ln1179">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1180">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1181">      if (!shown_match_ok) {</a>
<a name="ln1182">        if (comp == compl_shown_match || did_find_shown_match) {</a>
<a name="ln1183">          // This item is the shown match or this is the</a>
<a name="ln1184">          // first displayed item after the shown match.</a>
<a name="ln1185">          compl_shown_match = comp;</a>
<a name="ln1186">          did_find_shown_match = true;</a>
<a name="ln1187">          shown_match_ok = true;</a>
<a name="ln1188">        } else {</a>
<a name="ln1189">          // Remember this displayed match for when the</a>
<a name="ln1190">          // shown match is just below it.</a>
<a name="ln1191">          shown_compl = comp;</a>
<a name="ln1192">        }</a>
<a name="ln1193">        cur = i;</a>
<a name="ln1194">      }</a>
<a name="ln1195"> </a>
<a name="ln1196">      if (comp-&gt;cp_text[CPT_ABBR] != NULL) {</a>
<a name="ln1197">        compl_match_array[i].pum_text = comp-&gt;cp_text[CPT_ABBR];</a>
<a name="ln1198">      } else {</a>
<a name="ln1199">        compl_match_array[i].pum_text = comp-&gt;cp_str;</a>
<a name="ln1200">      }</a>
<a name="ln1201">      compl_match_array[i].pum_kind = comp-&gt;cp_text[CPT_KIND];</a>
<a name="ln1202">      compl_match_array[i].pum_info = comp-&gt;cp_text[CPT_INFO];</a>
<a name="ln1203">      if (comp-&gt;cp_text[CPT_MENU] != NULL) {</a>
<a name="ln1204">        compl_match_array[i++].pum_extra = comp-&gt;cp_text[CPT_MENU];</a>
<a name="ln1205">      } else {</a>
<a name="ln1206">        compl_match_array[i++].pum_extra = comp-&gt;cp_fname;</a>
<a name="ln1207">      }</a>
<a name="ln1208">    }</a>
<a name="ln1209"> </a>
<a name="ln1210">    if (comp == compl_shown_match) {</a>
<a name="ln1211">      did_find_shown_match = true;</a>
<a name="ln1212"> </a>
<a name="ln1213">      // When the original text is the shown match don't set</a>
<a name="ln1214">      // compl_shown_match.</a>
<a name="ln1215">      if (match_at_original_text(comp)) {</a>
<a name="ln1216">        shown_match_ok = true;</a>
<a name="ln1217">      }</a>
<a name="ln1218"> </a>
<a name="ln1219">      if (!shown_match_ok &amp;&amp; shown_compl != NULL) {</a>
<a name="ln1220">        // The shown match isn't displayed, set it to the</a>
<a name="ln1221">        // previously displayed match.</a>
<a name="ln1222">        compl_shown_match = shown_compl;</a>
<a name="ln1223">        shown_match_ok = true;</a>
<a name="ln1224">      }</a>
<a name="ln1225">    }</a>
<a name="ln1226">    comp = comp-&gt;cp_next;</a>
<a name="ln1227">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1228"> </a>
<a name="ln1229">  if (!shown_match_ok) {  // no displayed match at all</a>
<a name="ln1230">    cur = -1;</a>
<a name="ln1231">  }</a>
<a name="ln1232"> </a>
<a name="ln1233">  return cur;</a>
<a name="ln1234">}</a>
<a name="ln1235"> </a>
<a name="ln1236">/// Show the popup menu for the list of matches.</a>
<a name="ln1237">/// Also adjusts &quot;compl_shown_match&quot; to an entry that is actually displayed.</a>
<a name="ln1238">void ins_compl_show_pum(void)</a>
<a name="ln1239">{</a>
<a name="ln1240">  if (!pum_wanted() || !pum_enough_matches()) {</a>
<a name="ln1241">    return;</a>
<a name="ln1242">  }</a>
<a name="ln1243"> </a>
<a name="ln1244">  // Dirty hard-coded hack: remove any matchparen highlighting.</a>
<a name="ln1245">  do_cmdline_cmd(&quot;if exists('g:loaded_matchparen')|3match none|endif&quot;);</a>
<a name="ln1246"> </a>
<a name="ln1247">  // Update the screen before drawing the popup menu over it.</a>
<a name="ln1248">  update_screen();</a>
<a name="ln1249"> </a>
<a name="ln1250">  int cur = -1;</a>
<a name="ln1251">  bool array_changed = false;</a>
<a name="ln1252"> </a>
<a name="ln1253">  if (compl_match_array == NULL) {</a>
<a name="ln1254">    array_changed = true;</a>
<a name="ln1255">    // Need to build the popup menu list.</a>
<a name="ln1256">    cur = ins_compl_build_pum();</a>
<a name="ln1257">  } else {</a>
<a name="ln1258">    // popup menu already exists, only need to find the current item.</a>
<a name="ln1259">    for (int i = 0; i &lt; compl_match_arraysize; i++) {</a>
<a name="ln1260">      if (compl_match_array[i].pum_text == compl_shown_match-&gt;cp_str</a>
<a name="ln1261">          || compl_match_array[i].pum_text == compl_shown_match-&gt;cp_text[CPT_ABBR]) {</a>
<a name="ln1262">        cur = i;</a>
<a name="ln1263">        break;</a>
<a name="ln1264">      }</a>
<a name="ln1265">    }</a>
<a name="ln1266">  }</a>
<a name="ln1267"> </a>
<a name="ln1268">  if (compl_match_array == NULL) {</a>
<a name="ln1269">    return;</a>
<a name="ln1270">  }</a>
<a name="ln1271"> </a>
<a name="ln1272">  // In Replace mode when a $ is displayed at the end of the line only</a>
<a name="ln1273">  // part of the screen would be updated.  We do need to redraw here.</a>
<a name="ln1274">  dollar_vcol = -1;</a>
<a name="ln1275"> </a>
<a name="ln1276">  // Compute the screen column of the start of the completed text.</a>
<a name="ln1277">  // Use the cursor to get all wrapping and other settings right.</a>
<a name="ln1278">  const colnr_T col = curwin-&gt;w_cursor.col;</a>
<a name="ln1279">  curwin-&gt;w_cursor.col = compl_col;</a>
<a name="ln1280">  pum_selected_item = cur;</a>
<a name="ln1281">  pum_display(compl_match_array, compl_match_arraysize, cur, array_changed, 0);</a>
<a name="ln1282">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1283"> </a>
<a name="ln1284">  if (has_event(EVENT_COMPLETECHANGED)) {</a>
<a name="ln1285">    trigger_complete_changed_event(cur);</a>
<a name="ln1286">  }</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">#define DICT_FIRST      (1)     ///&lt; use just first element in &quot;dict&quot;</a>
<a name="ln1290">#define DICT_EXACT      (2)     ///&lt; &quot;dict&quot; is the exact name of a file</a>
<a name="ln1291"> </a>
<a name="ln1292">/// Add any identifiers that match the given pattern &quot;pat&quot; in the list of</a>
<a name="ln1293">/// dictionary files &quot;dict_start&quot; to the list of completions.</a>
<a name="ln1294">///</a>
<a name="ln1295">/// @param flags      DICT_FIRST and/or DICT_EXACT</a>
<a name="ln1296">/// @param thesaurus  Thesaurus completion</a>
<a name="ln1297">static void ins_compl_dictionaries(char *dict_start, char *pat, int flags, int thesaurus)</a>
<a name="ln1298">{</a>
<a name="ln1299">  char *dict = dict_start;</a>
<a name="ln1300">  char *ptr;</a>
<a name="ln1301">  char *buf;</a>
<a name="ln1302">  regmatch_T regmatch;</a>
<a name="ln1303">  char **files;</a>
<a name="ln1304">  int count;</a>
<a name="ln1305">  int save_p_scs;</a>
<a name="ln1306">  Direction dir = compl_direction;</a>
<a name="ln1307"> </a>
<a name="ln1308">  if (*dict == NUL) {</a>
<a name="ln1309">    // When 'dictionary' is empty and spell checking is enabled use</a>
<a name="ln1310">    // &quot;spell&quot;.</a>
<a name="ln1311">    if (!thesaurus &amp;&amp; curwin-&gt;w_p_spell) {</a>
<a name="ln1312">      dict = &quot;spell&quot;;</a>
<a name="ln1313">    } else {</a>
<a name="ln1314">      return;</a>
<a name="ln1315">    }</a>
<a name="ln1316">  }</a>
<a name="ln1317"> </a>
<a name="ln1318">  buf = xmalloc(LSIZE);</a>
<a name="ln1319">  regmatch.regprog = NULL;      // so that we can goto theend</a>
<a name="ln1320"> </a>
<a name="ln1321">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln1322">  save_p_scs = p_scs;</a>
<a name="ln1323">  if (curbuf-&gt;b_p_inf) {</a>
<a name="ln1324">    p_scs = false;</a>
<a name="ln1325">  }</a>
<a name="ln1326"> </a>
<a name="ln1327">  // When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern</a>
<a name="ln1328">  // to only match at the start of a line.  Otherwise just match the</a>
<a name="ln1329">  // pattern. Also need to double backslashes.</a>
<a name="ln1330">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1331">    char *pat_esc = vim_strsave_escaped(pat, &quot;\\&quot;);</a>
<a name="ln1332"> </a>
<a name="ln1333">    size_t len = strlen(pat_esc) + 10;</a>
<a name="ln1334">    ptr = xmalloc(len);</a>
<a name="ln1335">    vim_snprintf(ptr, len, &quot;^\\s*\\zs\\V%s&quot;, pat_esc);</a>
<a name="ln1336">    regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);</a>
<a name="ln1337">    xfree(pat_esc);</a>
<a name="ln1338">    xfree(ptr);</a>
<a name="ln1339">  } else {</a>
<a name="ln1340">    regmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);</a>
<a name="ln1341">    if (regmatch.regprog == NULL) {</a>
<a name="ln1342">      goto theend;</a>
<a name="ln1343">    }</a>
<a name="ln1344">  }</a>
<a name="ln1345"> </a>
<a name="ln1346">  // ignore case depends on 'ignorecase', 'smartcase' and &quot;pat&quot;</a>
<a name="ln1347">  regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln1348">  while (*dict != NUL &amp;&amp; !got_int &amp;&amp; !compl_interrupted) {</a>
<a name="ln1349">    // copy one dictionary file name into buf</a>
<a name="ln1350">    if (flags == DICT_EXACT) {</a>
<a name="ln1351">      count = 1;</a>
<a name="ln1352">      files = &amp;dict;</a>
<a name="ln1353">    } else {</a>
<a name="ln1354">      // Expand wildcards in the dictionary name, but do not allow</a>
<a name="ln1355">      // backticks (for security, the 'dict' option may have been set in</a>
<a name="ln1356">      // a modeline).</a>
<a name="ln1357">      copy_option_part(&amp;dict, buf, LSIZE, &quot;,&quot;);</a>
<a name="ln1358">      if (!thesaurus &amp;&amp; strcmp(buf, &quot;spell&quot;) == 0) {</a>
<a name="ln1359">        count = -1;</a>
<a name="ln1360">      } else if (vim_strchr(buf, '`') != NULL</a>
<a name="ln1361">                 || expand_wildcards(1, &amp;buf, &amp;count, &amp;files,</a>
<a name="ln1362">                                     EW_FILE|EW_SILENT) != OK) {</a>
<a name="ln1363">        count = 0;</a>
<a name="ln1364">      }</a>
<a name="ln1365">    }</a>
<a name="ln1366"> </a>
<a name="ln1367">    if (count == -1) {</a>
<a name="ln1368">      // Complete from active spelling.  Skip &quot;\&lt;&quot; in the pattern, we</a>
<a name="ln1369">      // don't use it as a RE.</a>
<a name="ln1370">      if (pat[0] == '\\' &amp;&amp; pat[1] == '&lt;') {</a>
<a name="ln1371">        ptr = pat + 2;</a>
<a name="ln1372">      } else {</a>
<a name="ln1373">        ptr = pat;</a>
<a name="ln1374">      }</a>
<a name="ln1375">      spell_dump_compl(ptr, regmatch.rm_ic, &amp;dir, 0);</a>
<a name="ln1376">    } else if (count &gt; 0) {  // avoid warning for using &quot;files&quot; uninit</a>
<a name="ln1377">      ins_compl_files(count, files, thesaurus, flags,</a>
<a name="ln1378">                      &amp;regmatch, buf, &amp;dir);</a>
<a name="ln1379">      if (flags != DICT_EXACT) {</a>
<a name="ln1380">        FreeWild(count, files);</a>
<a name="ln1381">      }</a>
<a name="ln1382">    }</a>
<a name="ln1383">    if (flags != 0) {</a>
<a name="ln1384">      break;</a>
<a name="ln1385">    }</a>
<a name="ln1386">  }</a>
<a name="ln1387"> </a>
<a name="ln1388">theend:</a>
<a name="ln1389">  p_scs = save_p_scs;</a>
<a name="ln1390">  vim_regfree(regmatch.regprog);</a>
<a name="ln1391">  xfree(buf);</a>
<a name="ln1392">}</a>
<a name="ln1393"> </a>
<a name="ln1394">/// Add all the words in the line &quot;*buf_arg&quot; from the thesaurus file &quot;fname&quot;</a>
<a name="ln1395">/// skipping the word at 'skip_word'.</a>
<a name="ln1396">///</a>
<a name="ln1397">/// @return  OK on success.</a>
<a name="ln1398">static int thesaurus_add_words_in_line(char *fname, char **buf_arg, int dir, const char *skip_word)</a>
<a name="ln1399">{</a>
<a name="ln1400">  int status = OK;</a>
<a name="ln1401"> </a>
<a name="ln1402">  // Add the other matches on the line</a>
<a name="ln1403">  char *ptr = *buf_arg;</a>
<a name="ln1404">  while (!got_int) {</a>
<a name="ln1405">    // Find start of the next word.  Skip white</a>
<a name="ln1406">    // space and punctuation.</a>
<a name="ln1407">    ptr = find_word_start(ptr);</a>
<a name="ln1408">    if (*ptr == NUL || *ptr == NL) {</a>
<a name="ln1409">      break;</a>
<a name="ln1410">    }</a>
<a name="ln1411">    char *wstart = ptr;</a>
<a name="ln1412"> </a>
<a name="ln1413">    // Find end of the word.</a>
<a name="ln1414">    // Japanese words may have characters in</a>
<a name="ln1415">    // different classes, only separate words</a>
<a name="ln1416">    // with single-byte non-word characters.</a>
<a name="ln1417">    while (*ptr != NUL) {</a>
<a name="ln1418">      const int l = utfc_ptr2len(ptr);</a>
<a name="ln1419"> </a>
<a name="ln1420">      if (l &lt; 2 &amp;&amp; !vim_iswordc((uint8_t)(*ptr))) {</a>
<a name="ln1421">        break;</a>
<a name="ln1422">      }</a>
<a name="ln1423">      ptr += l;</a>
<a name="ln1424">    }</a>
<a name="ln1425"> </a>
<a name="ln1426">    // Add the word. Skip the regexp match.</a>
<a name="ln1427">    if (wstart != skip_word) {</a>
<a name="ln1428">      status = ins_compl_add_infercase(wstart, (int)(ptr - wstart), p_ic,</a>
<a name="ln1429">                                       fname, dir, false);</a>
<a name="ln1430">      if (status == FAIL) {</a>
<a name="ln1431">        break;</a>
<a name="ln1432">      }</a>
<a name="ln1433">    }</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">  *buf_arg = ptr;</a>
<a name="ln1437">  return status;</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">/// Process &quot;count&quot; dictionary/thesaurus &quot;files&quot; and add the text matching</a>
<a name="ln1441">/// &quot;regmatch&quot;.</a>
<a name="ln1442">static void ins_compl_files(int count, char **files, int thesaurus, int flags, regmatch_T *regmatch,</a>
<a name="ln1443">                            char *buf, Direction *dir)</a>
<a name="ln1444">  FUNC_ATTR_NONNULL_ARG(2, 7)</a>
<a name="ln1445">{</a>
<a name="ln1446">  char *ptr;</a>
<a name="ln1447">  int i;</a>
<a name="ln1448">  FILE *fp;</a>
<a name="ln1449">  int add_r;</a>
<a name="ln1450"> </a>
<a name="ln1451">  for (i = 0; i &lt; count &amp;&amp; !got_int &amp;&amp; !compl_interrupted; i++) {</a>
<a name="ln1452">    fp = os_fopen(files[i], &quot;r&quot;);  // open dictionary file</a>
<a name="ln1453">    if (flags != DICT_EXACT &amp;&amp; !shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln1454">      msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln1455">      vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln1456">                   _(&quot;Scanning dictionary: %s&quot;), files[i]);</a>
<a name="ln1457">      (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln1458">    }</a>
<a name="ln1459"> </a>
<a name="ln1460">    if (fp == NULL) {</a>
<a name="ln1461">      continue;</a>
<a name="ln1462">    }</a>
<a name="ln1463"> </a>
<a name="ln1464">    // Read dictionary file line by line.</a>
<a name="ln1465">    // Check each line for a match.</a>
<a name="ln1466">    while (!got_int &amp;&amp; !compl_interrupted &amp;&amp; !vim_fgets(buf, LSIZE, fp)) {</a>
<a name="ln1467">      ptr = buf;</a>
<a name="ln1468">      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf))) {</a>
<a name="ln1469">        ptr = regmatch-&gt;startp[0];</a>
<a name="ln1470">        if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1471">          ptr = find_line_end(ptr);</a>
<a name="ln1472">        } else {</a>
<a name="ln1473">          ptr = find_word_end(ptr);</a>
<a name="ln1474">        }</a>
<a name="ln1475">        add_r = ins_compl_add_infercase(regmatch-&gt;startp[0],</a>
<a name="ln1476">                                        (int)(ptr - regmatch-&gt;startp[0]),</a>
<a name="ln1477">                                        p_ic, files[i], *dir, false);</a>
<a name="ln1478">        if (thesaurus) {</a>
<a name="ln1479">          // For a thesaurus, add all the words in the line</a>
<a name="ln1480">          ptr = buf;</a>
<a name="ln1481">          add_r = thesaurus_add_words_in_line(files[i], &amp;ptr, *dir, regmatch-&gt;startp[0]);</a>
<a name="ln1482">        }</a>
<a name="ln1483">        if (add_r == OK) {</a>
<a name="ln1484">          // if dir was BACKWARD then honor it just once</a>
<a name="ln1485">          *dir = FORWARD;</a>
<a name="ln1486">        } else if (add_r == FAIL) {</a>
<a name="ln1487">          break;</a>
<a name="ln1488">        }</a>
<a name="ln1489">        // avoid expensive call to vim_regexec() when at end</a>
<a name="ln1490">        // of line</a>
<a name="ln1491">        if (*ptr == '\n' || got_int) {</a>
<a name="ln1492">          break;</a>
<a name="ln1493">        }</a>
<a name="ln1494">      }</a>
<a name="ln1495">      line_breakcheck();</a>
<a name="ln1496">      ins_compl_check_keys(50, false);</a>
<a name="ln1497">    }</a>
<a name="ln1498">    fclose(fp);</a>
<a name="ln1499">  }</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">/// Find the start of the next word.</a>
<a name="ln1503">/// Returns a pointer to the first char of the word.  Also stops at a NUL.</a>
<a name="ln1504">char *find_word_start(char *ptr)</a>
<a name="ln1505">  FUNC_ATTR_PURE</a>
<a name="ln1506">{</a>
<a name="ln1507">  while (*ptr != NUL &amp;&amp; *ptr != '\n' &amp;&amp; mb_get_class(ptr) &lt;= 1) {</a>
<a name="ln1508">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1509">  }</a>
<a name="ln1510">  return ptr;</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513">/// Find the end of the word.  Assumes it starts inside a word.</a>
<a name="ln1514">/// Returns a pointer to just after the word.</a>
<a name="ln1515">char *find_word_end(char *ptr)</a>
<a name="ln1516">  FUNC_ATTR_PURE</a>
<a name="ln1517">{</a>
<a name="ln1518">  const int start_class = mb_get_class(ptr);</a>
<a name="ln1519">  if (start_class &gt; 1) {</a>
<a name="ln1520">    while (*ptr != NUL) {</a>
<a name="ln1521">      ptr += utfc_ptr2len(ptr);</a>
<a name="ln1522">      if (mb_get_class(ptr) != start_class) {</a>
<a name="ln1523">        break;</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526">  }</a>
<a name="ln1527">  return ptr;</a>
<a name="ln1528">}</a>
<a name="ln1529"> </a>
<a name="ln1530">/// Find the end of the line, omitting CR and NL at the end.</a>
<a name="ln1531">///</a>
<a name="ln1532">/// @return  a pointer to just after the line.</a>
<a name="ln1533">static char *find_line_end(char *ptr)</a>
<a name="ln1534">{</a>
<a name="ln1535">  char *s;</a>
<a name="ln1536"> </a>
<a name="ln1537">  s = ptr + strlen(ptr);</a>
<a name="ln1538">  while (s &gt; ptr &amp;&amp; (s[-1] == CAR || s[-1] == NL)) {</a>
<a name="ln1539">    s--;</a>
<a name="ln1540">  }</a>
<a name="ln1541">  return s;</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">/// Free the list of completions</a>
<a name="ln1545">static void ins_compl_free(void)</a>
<a name="ln1546">{</a>
<a name="ln1547">  compl_T *match;</a>
<a name="ln1548"> </a>
<a name="ln1549">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1550">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1551"> </a>
<a name="ln1552">  if (compl_first_match == NULL) {</a>
<a name="ln1553">    return;</a>
<a name="ln1554">  }</a>
<a name="ln1555"> </a>
<a name="ln1556">  ins_compl_del_pum();</a>
<a name="ln1557">  pum_clear();</a>
<a name="ln1558"> </a>
<a name="ln1559">  compl_curr_match = compl_first_match;</a>
<a name="ln1560">  do {</a>
<a name="ln1561">    match = compl_curr_match;</a>
<a name="ln1562">    compl_curr_match = compl_curr_match-&gt;cp_next;</a>
<a name="ln1563">    xfree(match-&gt;cp_str);</a>
<a name="ln1564">    // several entries may use the same fname, free it just once.</a>
<a name="ln1565">    if (match-&gt;cp_flags &amp; CP_FREE_FNAME) {</a>
<a name="ln1566">      xfree(match-&gt;cp_fname);</a>
<a name="ln1567">    }</a>
<a name="ln1568">    for (int i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln1569">      xfree(match-&gt;cp_text[i]);</a>
<a name="ln1570">    }</a>
<a name="ln1571">    tv_clear(&amp;match-&gt;cp_user_data);</a>
<a name="ln1572">    xfree(match);</a>
<a name="ln1573">  } while (compl_curr_match != NULL &amp;&amp; !is_first_match(compl_curr_match));</a>
<a name="ln1574">  compl_first_match = compl_curr_match = NULL;</a>
<a name="ln1575">  compl_shown_match = NULL;</a>
<a name="ln1576">  compl_old_match = NULL;</a>
<a name="ln1577">}</a>
<a name="ln1578"> </a>
<a name="ln1579">/// Reset/clear the completion state.</a>
<a name="ln1580">void ins_compl_clear(void)</a>
<a name="ln1581">{</a>
<a name="ln1582">  compl_cont_status = 0;</a>
<a name="ln1583">  compl_started = false;</a>
<a name="ln1584">  compl_matches = 0;</a>
<a name="ln1585">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1586">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1587">  edit_submode_extra = NULL;</a>
<a name="ln1588">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln1589">  compl_enter_selects = false;</a>
<a name="ln1590">  // clear v:completed_item</a>
<a name="ln1591">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln1592">}</a>
<a name="ln1593"> </a>
<a name="ln1594">/// Check that Insert completion is active.</a>
<a name="ln1595">bool ins_compl_active(void)</a>
<a name="ln1596">  FUNC_ATTR_PURE</a>
<a name="ln1597">{</a>
<a name="ln1598">  return compl_started;</a>
<a name="ln1599">}</a>
<a name="ln1600"> </a>
<a name="ln1601">/// Selected one of the matches.  When false the match was edited or using the</a>
<a name="ln1602">/// longest common string.</a>
<a name="ln1603">bool ins_compl_used_match(void)</a>
<a name="ln1604">{</a>
<a name="ln1605">  return compl_used_match;</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608">/// Initialize get longest common string.</a>
<a name="ln1609">void ins_compl_init_get_longest(void)</a>
<a name="ln1610">{</a>
<a name="ln1611">  compl_get_longest = false;</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">/// Returns true when insert completion is interrupted.</a>
<a name="ln1615">bool ins_compl_interrupted(void)</a>
<a name="ln1616">{</a>
<a name="ln1617">  return compl_interrupted;</a>
<a name="ln1618">}</a>
<a name="ln1619"> </a>
<a name="ln1620">/// Returns true if the &lt;Enter&gt; key selects a match in the completion popup</a>
<a name="ln1621">/// menu.</a>
<a name="ln1622">bool ins_compl_enter_selects(void)</a>
<a name="ln1623">{</a>
<a name="ln1624">  return compl_enter_selects;</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">/// Return the column where the text starts that is being completed</a>
<a name="ln1628">colnr_T ins_compl_col(void)</a>
<a name="ln1629">{</a>
<a name="ln1630">  return compl_col;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">/// Return the length in bytes of the text being completed</a>
<a name="ln1634">int ins_compl_len(void)</a>
<a name="ln1635">{</a>
<a name="ln1636">  return compl_length;</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">/// Delete one character before the cursor and show the subset of the matches</a>
<a name="ln1640">/// that match the word that is now before the cursor.</a>
<a name="ln1641">/// Returns the character to be used, NUL if the work is done and another char</a>
<a name="ln1642">/// to be got from the user.</a>
<a name="ln1643">int ins_compl_bs(void)</a>
<a name="ln1644">{</a>
<a name="ln1645">  char *line = get_cursor_line_ptr();</a>
<a name="ln1646">  char *p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln1647">  MB_PTR_BACK(line, p);</a>
<a name="ln1648">  ptrdiff_t p_off = p - line;</a>
<a name="ln1649"> </a>
<a name="ln1650">  // Stop completion when the whole word was deleted.  For Omni completion</a>
<a name="ln1651">  // allow the word to be deleted, we won't match everything.</a>
<a name="ln1652">  // Respect the 'backspace' option.</a>
<a name="ln1653">  if ((int)(p - line) - (int)compl_col &lt; 0</a>
<a name="ln1654">      || ((int)(p - line) - (int)compl_col == 0 &amp;&amp; !ctrl_x_mode_omni())</a>
<a name="ln1655">      || ctrl_x_mode_eval()</a>
<a name="ln1656">      || (!can_bs(BS_START) &amp;&amp; (int)(p - line) - (int)compl_col</a>
<a name="ln1657">          - compl_length &lt; 0)) {</a>
<a name="ln1658">    return K_BS;</a>
<a name="ln1659">  }</a>
<a name="ln1660"> </a>
<a name="ln1661">  // Deleted more than what was used to find matches or didn't finish</a>
<a name="ln1662">  // finding all matches: need to look for matches all over again.</a>
<a name="ln1663">  if (curwin-&gt;w_cursor.col &lt;= compl_col + compl_length</a>
<a name="ln1664">      || ins_compl_need_restart()) {</a>
<a name="ln1665">    ins_compl_restart();</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  // ins_compl_restart() calls update_screen() which may invalidate the pointer</a>
<a name="ln1669">  // TODO(bfredl): get rid of random update_screen() calls deep inside completion logic</a>
<a name="ln1670">  line = get_cursor_line_ptr();</a>
<a name="ln1671"> </a>
<a name="ln1672">  xfree(compl_leader);</a>
<a name="ln1673">  compl_leader = xstrnsave(line + compl_col, (size_t)(p_off - (ptrdiff_t)compl_col));</a>
<a name="ln1674"> </a>
<a name="ln1675">  ins_compl_new_leader();</a>
<a name="ln1676">  if (compl_shown_match != NULL) {</a>
<a name="ln1677">    // Make sure current match is not a hidden item.</a>
<a name="ln1678">    compl_curr_match = compl_shown_match;</a>
<a name="ln1679">  }</a>
<a name="ln1680">  return NUL;</a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">/// Check that we need to find matches again, ins_compl_restart() is to</a>
<a name="ln1684">/// be called.</a>
<a name="ln1685">static bool ins_compl_need_restart(void)</a>
<a name="ln1686">  FUNC_ATTR_PURE</a>
<a name="ln1687">{</a>
<a name="ln1688">  // Return true if we didn't complete finding matches or when the</a>
<a name="ln1689">  // &quot;completefunc&quot; returned &quot;always&quot; in the &quot;refresh&quot; dictionary item.</a>
<a name="ln1690">  return compl_was_interrupted</a>
<a name="ln1691">         || ((ctrl_x_mode_function() || ctrl_x_mode_omni())</a>
<a name="ln1692">             &amp;&amp; compl_opt_refresh_always);</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">/// Called after changing &quot;compl_leader&quot;.</a>
<a name="ln1696">/// Show the popup menu with a different set of matches.</a>
<a name="ln1697">/// May also search for matches again if the previous search was interrupted.</a>
<a name="ln1698">static void ins_compl_new_leader(void)</a>
<a name="ln1699">{</a>
<a name="ln1700">  ins_compl_del_pum();</a>
<a name="ln1701">  ins_compl_delete();</a>
<a name="ln1702">  ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln1703">  compl_used_match = false;</a>
<a name="ln1704"> </a>
<a name="ln1705">  if (compl_started) {</a>
<a name="ln1706">    ins_compl_set_original_text(compl_leader);</a>
<a name="ln1707">  } else {</a>
<a name="ln1708">    spell_bad_len = 0;  // need to redetect bad word</a>
<a name="ln1709">    // Matches were cleared, need to search for them now.</a>
<a name="ln1710">    // Set &quot;compl_restarting&quot; to avoid that the first match is inserted.</a>
<a name="ln1711">    compl_restarting = true;</a>
<a name="ln1712">    if (ins_complete(Ctrl_N, true) == FAIL) {</a>
<a name="ln1713">      compl_cont_status = 0;</a>
<a name="ln1714">    }</a>
<a name="ln1715">    compl_restarting = false;</a>
<a name="ln1716">  }</a>
<a name="ln1717"> </a>
<a name="ln1718">  compl_enter_selects = !compl_used_match;</a>
<a name="ln1719"> </a>
<a name="ln1720">  // Show the popup menu with a different set of matches.</a>
<a name="ln1721">  ins_compl_show_pum();</a>
<a name="ln1722"> </a>
<a name="ln1723">  // Don't let Enter select the original text when there is no popup menu.</a>
<a name="ln1724">  // Don't let Enter select when use user function and refresh_always is set</a>
<a name="ln1725">  if (compl_match_array == NULL || ins_compl_need_restart()) {</a>
<a name="ln1726">    compl_enter_selects = false;</a>
<a name="ln1727">  }</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">/// Return the length of the completion, from the completion start column to</a>
<a name="ln1731">/// the cursor column.  Making sure it never goes below zero.</a>
<a name="ln1732">static int get_compl_len(void)</a>
<a name="ln1733">{</a>
<a name="ln1734">  int off = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1735"> </a>
<a name="ln1736">  if (off &lt; 0) {</a>
<a name="ln1737">    return 0;</a>
<a name="ln1738">  }</a>
<a name="ln1739">  return off;</a>
<a name="ln1740">}</a>
<a name="ln1741"> </a>
<a name="ln1742">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1743">/// matches.</a>
<a name="ln1744">void ins_compl_addleader(int c)</a>
<a name="ln1745">{</a>
<a name="ln1746">  int cc;</a>
<a name="ln1747"> </a>
<a name="ln1748">  if (stop_arrow() == FAIL) {</a>
<a name="ln1749">    return;</a>
<a name="ln1750">  }</a>
<a name="ln1751">  if ((cc = utf_char2len(c)) &gt; 1) {</a>
<a name="ln1752">    char buf[MB_MAXBYTES + 1];</a>
<a name="ln1753"> </a>
<a name="ln1754">    utf_char2bytes(c, buf);</a>
<a name="ln1755">    buf[cc] = NUL;</a>
<a name="ln1756">    ins_char_bytes(buf, (size_t)cc);</a>
<a name="ln1757">  } else {</a>
<a name="ln1758">    ins_char(c);</a>
<a name="ln1759">  }</a>
<a name="ln1760"> </a>
<a name="ln1761">  // If we didn't complete finding matches we must search again.</a>
<a name="ln1762">  if (ins_compl_need_restart()) {</a>
<a name="ln1763">    ins_compl_restart();</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766">  xfree(compl_leader);</a>
<a name="ln1767">  compl_leader = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln1768">                           (size_t)(curwin-&gt;w_cursor.col - compl_col));</a>
<a name="ln1769">  ins_compl_new_leader();</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">/// Setup for finding completions again without leaving CTRL-X mode.  Used when</a>
<a name="ln1773">/// BS or a key was typed while still searching for matches.</a>
<a name="ln1774">static void ins_compl_restart(void)</a>
<a name="ln1775">{</a>
<a name="ln1776">  // update screen before restart.</a>
<a name="ln1777">  // so if complete is blocked,</a>
<a name="ln1778">  // will stay to the last popup menu and reduce flicker</a>
<a name="ln1779">  update_screen();  // TODO(bfredl): no.</a>
<a name="ln1780">  ins_compl_free();</a>
<a name="ln1781">  compl_started = false;</a>
<a name="ln1782">  compl_matches = 0;</a>
<a name="ln1783">  compl_cont_status = 0;</a>
<a name="ln1784">  compl_cont_mode = 0;</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">/// Set the first match, the original text.</a>
<a name="ln1788">static void ins_compl_set_original_text(char *str)</a>
<a name="ln1789">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1790">{</a>
<a name="ln1791">  // Replace the original text entry.</a>
<a name="ln1792">  // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly</a>
<a name="ln1793">  // be at the last item for backward completion</a>
<a name="ln1794">  if (match_at_original_text(compl_first_match)) {  // safety check</a>
<a name="ln1795">    xfree(compl_first_match-&gt;cp_str);</a>
<a name="ln1796">    compl_first_match-&gt;cp_str = xstrdup(str);</a>
<a name="ln1797">  } else if (compl_first_match-&gt;cp_prev != NULL</a>
<a name="ln1798">             &amp;&amp; match_at_original_text(compl_first_match-&gt;cp_prev)) {</a>
<a name="ln1799">    xfree(compl_first_match-&gt;cp_prev-&gt;cp_str);</a>
<a name="ln1800">    compl_first_match-&gt;cp_prev-&gt;cp_str = xstrdup(str);</a>
<a name="ln1801">  }</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1805">/// matches.</a>
<a name="ln1806">void ins_compl_addfrommatch(void)</a>
<a name="ln1807">{</a>
<a name="ln1808">  char *p;</a>
<a name="ln1809">  int len = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1810">  int c;</a>
<a name="ln1811">  compl_T *cp;</a>
<a name="ln1812">  assert(compl_shown_match != NULL);</a>
<a name="ln1813">  p = compl_shown_match-&gt;cp_str;</a>
<a name="ln1814">  if ((int)strlen(p) &lt;= len) {   // the match is too short</a>
<a name="ln1815">    // When still at the original match use the first entry that matches</a>
<a name="ln1816">    // the leader.</a>
<a name="ln1817">    if (!match_at_original_text(compl_shown_match)) {</a>
<a name="ln1818">      return;</a>
<a name="ln1819">    }</a>
<a name="ln1820"> </a>
<a name="ln1821">    p = NULL;</a>
<a name="ln1822">    for (cp = compl_shown_match-&gt;cp_next; cp != NULL</a>
<a name="ln1823">         &amp;&amp; !is_first_match(cp); cp = cp-&gt;cp_next) {</a>
<a name="ln1824">      if (compl_leader == NULL</a>
<a name="ln1825">          || ins_compl_equal(cp, compl_leader, strlen(compl_leader))) {</a>
<a name="ln1826">        p = cp-&gt;cp_str;</a>
<a name="ln1827">        break;</a>
<a name="ln1828">      }</a>
<a name="ln1829">    }</a>
<a name="ln1830">    if (p == NULL || (int)strlen(p) &lt;= len) {</a>
<a name="ln1831">      return;</a>
<a name="ln1832">    }</a>
<a name="ln1833">  }</a>
<a name="ln1834">  p += len;</a>
<a name="ln1835">  c = utf_ptr2char(p);</a>
<a name="ln1836">  ins_compl_addleader(c);</a>
<a name="ln1837">}</a>
<a name="ln1838"> </a>
<a name="ln1839">/// Set the CTRL-X completion mode based on the key &quot;c&quot; typed after a CTRL-X.</a>
<a name="ln1840">/// Uses the global variables: ctrl_x_mode, edit_submode, edit_submode_pre,</a>
<a name="ln1841">/// compl_cont_mode and compl_cont_status.</a>
<a name="ln1842">///</a>
<a name="ln1843">/// @return  true when the character is not to be inserted.</a>
<a name="ln1844">static bool set_ctrl_x_mode(const int c)</a>
<a name="ln1845">{</a>
<a name="ln1846">  bool retval = false;</a>
<a name="ln1847"> </a>
<a name="ln1848">  switch (c) {</a>
<a name="ln1849">  case Ctrl_E:</a>
<a name="ln1850">  case Ctrl_Y:</a>
<a name="ln1851">    // scroll the window one line up or down</a>
<a name="ln1852">    ctrl_x_mode = CTRL_X_SCROLL;</a>
<a name="ln1853">    if (!(State &amp; REPLACE_FLAG)) {</a>
<a name="ln1854">      edit_submode = _(&quot; (insert) Scroll (^E/^Y)&quot;);</a>
<a name="ln1855">    } else {</a>
<a name="ln1856">      edit_submode = _(&quot; (replace) Scroll (^E/^Y)&quot;);</a>
<a name="ln1857">    }</a>
<a name="ln1858">    edit_submode_pre = NULL;</a>
<a name="ln1859">    showmode();</a>
<a name="ln1860">    break;</a>
<a name="ln1861">  case Ctrl_L:</a>
<a name="ln1862">    // complete whole line</a>
<a name="ln1863">    ctrl_x_mode = CTRL_X_WHOLE_LINE;</a>
<a name="ln1864">    break;</a>
<a name="ln1865">  case Ctrl_F:</a>
<a name="ln1866">    // complete filenames</a>
<a name="ln1867">    ctrl_x_mode = CTRL_X_FILES;</a>
<a name="ln1868">    break;</a>
<a name="ln1869">  case Ctrl_K:</a>
<a name="ln1870">    // complete words from a dictionary</a>
<a name="ln1871">    ctrl_x_mode = CTRL_X_DICTIONARY;</a>
<a name="ln1872">    break;</a>
<a name="ln1873">  case Ctrl_R:</a>
<a name="ln1874">    // Register insertion without exiting CTRL-X mode</a>
<a name="ln1875">    // Simply allow ^R to happen without affecting ^X mode</a>
<a name="ln1876">    break;</a>
<a name="ln1877">  case Ctrl_T:</a>
<a name="ln1878">    // complete words from a thesaurus</a>
<a name="ln1879">    ctrl_x_mode = CTRL_X_THESAURUS;</a>
<a name="ln1880">    break;</a>
<a name="ln1881">  case Ctrl_U:</a>
<a name="ln1882">    // user defined completion</a>
<a name="ln1883">    ctrl_x_mode = CTRL_X_FUNCTION;</a>
<a name="ln1884">    break;</a>
<a name="ln1885">  case Ctrl_O:</a>
<a name="ln1886">    // omni completion</a>
<a name="ln1887">    ctrl_x_mode = CTRL_X_OMNI;</a>
<a name="ln1888">    break;</a>
<a name="ln1889">  case 's':</a>
<a name="ln1890">  case Ctrl_S:</a>
<a name="ln1891">    // complete spelling suggestions</a>
<a name="ln1892">    ctrl_x_mode = CTRL_X_SPELL;</a>
<a name="ln1893">    emsg_off++;  // Avoid getting the E756 error twice.</a>
<a name="ln1894">    spell_back_to_badword();</a>
<a name="ln1895">    emsg_off--;</a>
<a name="ln1896">    break;</a>
<a name="ln1897">  case Ctrl_RSB:</a>
<a name="ln1898">    // complete tag names</a>
<a name="ln1899">    ctrl_x_mode = CTRL_X_TAGS;</a>
<a name="ln1900">    break;</a>
<a name="ln1901">  case Ctrl_I:</a>
<a name="ln1902">  case K_S_TAB:</a>
<a name="ln1903">    // complete keywords from included files</a>
<a name="ln1904">    ctrl_x_mode = CTRL_X_PATH_PATTERNS;</a>
<a name="ln1905">    break;</a>
<a name="ln1906">  case Ctrl_D:</a>
<a name="ln1907">    // complete definitions from included files</a>
<a name="ln1908">    ctrl_x_mode = CTRL_X_PATH_DEFINES;</a>
<a name="ln1909">    break;</a>
<a name="ln1910">  case Ctrl_V:</a>
<a name="ln1911">  case Ctrl_Q:</a>
<a name="ln1912">    // complete vim commands</a>
<a name="ln1913">    ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln1914">    break;</a>
<a name="ln1915">  case Ctrl_Z:</a>
<a name="ln1916">    // stop completion</a>
<a name="ln1917">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1918">    edit_submode = NULL;</a>
<a name="ln1919">    showmode();</a>
<a name="ln1920">    retval = true;</a>
<a name="ln1921">    break;</a>
<a name="ln1922">  case Ctrl_P:</a>
<a name="ln1923">  case Ctrl_N:</a>
<a name="ln1924">    // ^X^P means LOCAL expansion if nothing interrupted (eg we</a>
<a name="ln1925">    // just started ^X mode, or there were enough ^X's to cancel</a>
<a name="ln1926">    // the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)</a>
<a name="ln1927">    // do normal expansion when interrupting a different mode (say</a>
<a name="ln1928">    // ^X^F^X^P or ^P^X^X^P, see below)</a>
<a name="ln1929">    // nothing changes if interrupting mode 0, (eg, the flag</a>
<a name="ln1930">    // doesn't change when going to ADDING mode  -- Acevedo</a>
<a name="ln1931">    if (!(compl_cont_status &amp; CONT_INTRPT)) {</a>
<a name="ln1932">      compl_cont_status |= CONT_LOCAL;</a>
<a name="ln1933">    } else if (compl_cont_mode != 0) {</a>
<a name="ln1934">      compl_cont_status &amp;= ~CONT_LOCAL;</a>
<a name="ln1935">    }</a>
<a name="ln1936">    FALLTHROUGH;</a>
<a name="ln1937">  default:</a>
<a name="ln1938">    // If we have typed at least 2 ^X's... for modes != 0, we set</a>
<a name="ln1939">    // compl_cont_status = 0 (eg, as if we had just started ^X</a>
<a name="ln1940">    // mode).</a>
<a name="ln1941">    // For mode 0, we set &quot;compl_cont_mode&quot; to an impossible</a>
<a name="ln1942">    // value, in both cases ^X^X can be used to restart the same</a>
<a name="ln1943">    // mode (avoiding ADDING mode).</a>
<a name="ln1944">    // Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start</a>
<a name="ln1945">    // 'complete' and local ^P expansions respectively.</a>
<a name="ln1946">    // In mode 0 an extra ^X is needed since ^X^P goes to ADDING</a>
<a name="ln1947">    // mode  -- Acevedo</a>
<a name="ln1948">    if (c == Ctrl_X) {</a>
<a name="ln1949">      if (compl_cont_mode != 0) {</a>
<a name="ln1950">        compl_cont_status = 0;</a>
<a name="ln1951">      } else {</a>
<a name="ln1952">        compl_cont_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln1953">      }</a>
<a name="ln1954">    }</a>
<a name="ln1955">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1956">    edit_submode = NULL;</a>
<a name="ln1957">    showmode();</a>
<a name="ln1958">    break;</a>
<a name="ln1959">  }</a>
<a name="ln1960"> </a>
<a name="ln1961">  return retval;</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">/// Stop insert completion mode</a>
<a name="ln1965">static bool ins_compl_stop(const int c, const int prev_mode, bool retval)</a>
<a name="ln1966">{</a>
<a name="ln1967">  // Get here when we have finished typing a sequence of ^N and</a>
<a name="ln1968">  // ^P or other completion characters in CTRL-X mode.  Free up</a>
<a name="ln1969">  // memory that was used, and make sure we can redo the insert.</a>
<a name="ln1970">  if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {</a>
<a name="ln1971">    // If any of the original typed text has been changed, eg when</a>
<a name="ln1972">    // ignorecase is set, we must add back-spaces to the redo</a>
<a name="ln1973">    // buffer.  We add as few as necessary to delete just the part</a>
<a name="ln1974">    // of the original text that has changed.</a>
<a name="ln1975">    // When using the longest match, edited the match or used</a>
<a name="ln1976">    // CTRL-E then don't use the current match.</a>
<a name="ln1977">    char *ptr;</a>
<a name="ln1978">    if (compl_curr_match != NULL &amp;&amp; compl_used_match &amp;&amp; c != Ctrl_E) {</a>
<a name="ln1979">      ptr = compl_curr_match-&gt;cp_str;</a>
<a name="ln1980">    } else {</a>
<a name="ln1981">      ptr = NULL;</a>
<a name="ln1982">    }</a>
<a name="ln1983">    ins_compl_fixRedoBufForLeader(ptr);</a>
<a name="ln1984">  }</a>
<a name="ln1985"> </a>
<a name="ln1986">  bool want_cindent = (get_can_cindent() &amp;&amp; cindent_on());</a>
<a name="ln1987"> </a>
<a name="ln1988">  // When completing whole lines: fix indent for 'cindent'.</a>
<a name="ln1989">  // Otherwise, break line if it's too long.</a>
<a name="ln1990">  if (compl_cont_mode == CTRL_X_WHOLE_LINE) {</a>
<a name="ln1991">    // re-indent the current line</a>
<a name="ln1992">    if (want_cindent) {</a>
<a name="ln1993">      do_c_expr_indent();</a>
<a name="ln1994">      want_cindent = false;                 // don't do it again</a>
<a name="ln1995">    }</a>
<a name="ln1996">  } else {</a>
<a name="ln1997">    const int prev_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1998"> </a>
<a name="ln1999">    // put the cursor on the last char, for 'tw' formatting</a>
<a name="ln2000">    if (prev_col &gt; 0) {</a>
<a name="ln2001">      dec_cursor();</a>
<a name="ln2002">    }</a>
<a name="ln2003"> </a>
<a name="ln2004">    // only format when something was inserted</a>
<a name="ln2005">    if (!arrow_used &amp;&amp; !ins_need_undo_get() &amp;&amp; c != Ctrl_E) {</a>
<a name="ln2006">      insertchar(NUL, 0, -1);</a>
<a name="ln2007">    }</a>
<a name="ln2008"> </a>
<a name="ln2009">    if (prev_col &gt; 0</a>
<a name="ln2010">        &amp;&amp; get_cursor_line_ptr()[curwin-&gt;w_cursor.col] != NUL) {</a>
<a name="ln2011">      inc_cursor();</a>
<a name="ln2012">    }</a>
<a name="ln2013">  }</a>
<a name="ln2014"> </a>
<a name="ln2015">  // If the popup menu is displayed pressing CTRL-Y means accepting</a>
<a name="ln2016">  // the selection without inserting anything.  When</a>
<a name="ln2017">  // compl_enter_selects is set the Enter key does the same.</a>
<a name="ln2018">  if ((c == Ctrl_Y || (compl_enter_selects</a>
<a name="ln2019">                       &amp;&amp; (c == CAR || c == K_KENTER || c == NL)))</a>
<a name="ln2020">      &amp;&amp; pum_visible()) {</a>
<a name="ln2021">    retval = true;</a>
<a name="ln2022">  }</a>
<a name="ln2023"> </a>
<a name="ln2024">  // CTRL-E means completion is Ended, go back to the typed text.</a>
<a name="ln2025">  // but only do this, if the Popup is still visible</a>
<a name="ln2026">  if (c == Ctrl_E) {</a>
<a name="ln2027">    ins_compl_delete();</a>
<a name="ln2028">    char *p = NULL;</a>
<a name="ln2029">    if (compl_leader != NULL) {</a>
<a name="ln2030">      p = compl_leader;</a>
<a name="ln2031">    } else if (compl_first_match != NULL) {</a>
<a name="ln2032">      p = compl_orig_text;</a>
<a name="ln2033">    }</a>
<a name="ln2034">    if (p != NULL) {</a>
<a name="ln2035">      const int compl_len = get_compl_len();</a>
<a name="ln2036">      const int len = (int)strlen(p);</a>
<a name="ln2037">      if (len &gt; compl_len) {</a>
<a name="ln2038">        ins_bytes_len(p + compl_len, (size_t)(len - compl_len));</a>
<a name="ln2039">      }</a>
<a name="ln2040">    }</a>
<a name="ln2041">    retval = true;</a>
<a name="ln2042">  }</a>
<a name="ln2043"> </a>
<a name="ln2044">  auto_format(false, true);</a>
<a name="ln2045"> </a>
<a name="ln2046">  // Trigger the CompleteDonePre event to give scripts a chance to</a>
<a name="ln2047">  // act upon the completion before clearing the info, and restore</a>
<a name="ln2048">  // ctrl_x_mode, so that complete_info() can be used.</a>
<a name="ln2049">  ctrl_x_mode = prev_mode;</a>
<a name="ln2050">  ins_apply_autocmds(EVENT_COMPLETEDONEPRE);</a>
<a name="ln2051"> </a>
<a name="ln2052">  ins_compl_free();</a>
<a name="ln2053">  compl_started = false;</a>
<a name="ln2054">  compl_matches = 0;</a>
<a name="ln2055">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln2056">    msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln2057">  }</a>
<a name="ln2058">  ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2059">  compl_enter_selects = false;</a>
<a name="ln2060">  if (edit_submode != NULL) {</a>
<a name="ln2061">    edit_submode = NULL;</a>
<a name="ln2062">    showmode();</a>
<a name="ln2063">  }</a>
<a name="ln2064"> </a>
<a name="ln2065">  if (c == Ctrl_C &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln2066">    // Avoid the popup menu remains displayed when leaving the</a>
<a name="ln2067">    // command line window.</a>
<a name="ln2068">    update_screen();</a>
<a name="ln2069">  }</a>
<a name="ln2070"> </a>
<a name="ln2071">  // Indent now if a key was typed that is in 'cinkeys'.</a>
<a name="ln2072">  if (want_cindent &amp;&amp; in_cinkeys(KEY_COMPLETE, ' ', inindent(0))) {</a>
<a name="ln2073">    do_c_expr_indent();</a>
<a name="ln2074">  }</a>
<a name="ln2075">  // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2076">  // upon the end of completion.</a>
<a name="ln2077">  ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2078"> </a>
<a name="ln2079">  return retval;</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">/// Prepare for Insert mode completion, or stop it.</a>
<a name="ln2083">/// Called just after typing a character in Insert mode.</a>
<a name="ln2084">///</a>
<a name="ln2085">/// @param  c  character that was typed</a>
<a name="ln2086">///</a>
<a name="ln2087">/// @return true when the character is not to be inserted;</a>
<a name="ln2088">bool ins_compl_prep(int c)</a>
<a name="ln2089">{</a>
<a name="ln2090">  bool retval = false;</a>
<a name="ln2091">  const int prev_mode = ctrl_x_mode;</a>
<a name="ln2092"> </a>
<a name="ln2093">  // Forget any previous 'special' messages if this is actually</a>
<a name="ln2094">  // a ^X mode key - bar ^R, in which case we wait to see what it gives us.</a>
<a name="ln2095">  if (c != Ctrl_R &amp;&amp; vim_is_ctrl_x_key(c)) {</a>
<a name="ln2096">    edit_submode_extra = NULL;</a>
<a name="ln2097">  }</a>
<a name="ln2098"> </a>
<a name="ln2099">  // Ignore end of Select mode mapping and mouse scroll/movement.</a>
<a name="ln2100">  if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln2101">      || c == K_MOUSELEFT || c == K_MOUSERIGHT || c == K_MOUSEMOVE</a>
<a name="ln2102">      || c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln2103">    return retval;</a>
<a name="ln2104">  }</a>
<a name="ln2105"> </a>
<a name="ln2106">  if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X &amp;&amp; c != Ctrl_X) {</a>
<a name="ln2107">    if (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)</a>
<a name="ln2108">        || !vim_is_ctrl_x_key(c)) {</a>
<a name="ln2109">      // Not starting another completion mode.</a>
<a name="ln2110">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2111"> </a>
<a name="ln2112">      // CTRL-X CTRL-Z should stop completion without inserting anything</a>
<a name="ln2113">      if (c == Ctrl_Z) {</a>
<a name="ln2114">        retval = true;</a>
<a name="ln2115">      }</a>
<a name="ln2116">    } else {</a>
<a name="ln2117">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2118"> </a>
<a name="ln2119">      // Other CTRL-X keys first stop completion, then start another</a>
<a name="ln2120">      // completion mode.</a>
<a name="ln2121">      ins_compl_prep(' ');</a>
<a name="ln2122">      ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln2123">    }</a>
<a name="ln2124">  }</a>
<a name="ln2125"> </a>
<a name="ln2126">  // Set &quot;compl_get_longest&quot; when finding the first matches.</a>
<a name="ln2127">  if (ctrl_x_mode_not_defined_yet()</a>
<a name="ln2128">      || (ctrl_x_mode_normal() &amp;&amp; !compl_started)) {</a>
<a name="ln2129">    compl_get_longest = compl_longest;</a>
<a name="ln2130">    compl_used_match = true;</a>
<a name="ln2131">  }</a>
<a name="ln2132"> </a>
<a name="ln2133">  if (ctrl_x_mode_not_defined_yet()) {</a>
<a name="ln2134">    // We have just typed CTRL-X and aren't quite sure which CTRL-X mode</a>
<a name="ln2135">    // it will be yet.  Now we decide.</a>
<a name="ln2136">    retval = set_ctrl_x_mode(c);</a>
<a name="ln2137">  } else if (ctrl_x_mode_not_default()) {</a>
<a name="ln2138">    // We're already in CTRL-X mode, do we stay in it?</a>
<a name="ln2139">    if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2140">      if (ctrl_x_mode_scroll()) {</a>
<a name="ln2141">        ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2142">      } else {</a>
<a name="ln2143">        ctrl_x_mode = CTRL_X_FINISHED;</a>
<a name="ln2144">      }</a>
<a name="ln2145">      edit_submode = NULL;</a>
<a name="ln2146">    }</a>
<a name="ln2147">    showmode();</a>
<a name="ln2148">  }</a>
<a name="ln2149"> </a>
<a name="ln2150">  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2151">    // Show error message from attempted keyword completion (probably</a>
<a name="ln2152">    // 'Pattern not found') until another key is hit, then go back to</a>
<a name="ln2153">    // showing what mode we are in.</a>
<a name="ln2154">    showmode();</a>
<a name="ln2155">    if ((ctrl_x_mode_normal()</a>
<a name="ln2156">         &amp;&amp; c != Ctrl_N</a>
<a name="ln2157">         &amp;&amp; c != Ctrl_P</a>
<a name="ln2158">         &amp;&amp; c != Ctrl_R</a>
<a name="ln2159">         &amp;&amp; !ins_compl_pum_key(c))</a>
<a name="ln2160">        || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2161">      retval = ins_compl_stop(c, prev_mode, retval);</a>
<a name="ln2162">    }</a>
<a name="ln2163">  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {</a>
<a name="ln2164">    // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2165">    // upon the (possibly failed) completion.</a>
<a name="ln2166">    ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2167">  }</a>
<a name="ln2168"> </a>
<a name="ln2169">  may_trigger_modechanged();</a>
<a name="ln2170"> </a>
<a name="ln2171">  // reset continue_* if we left expansion-mode, if we stay they'll be</a>
<a name="ln2172">  // (re)set properly in ins_complete()</a>
<a name="ln2173">  if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2174">    compl_cont_status = 0;</a>
<a name="ln2175">    compl_cont_mode = 0;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  return retval;</a>
<a name="ln2179">}</a>
<a name="ln2180"> </a>
<a name="ln2181">/// Fix the redo buffer for the completion leader replacing some of the typed</a>
<a name="ln2182">/// text.  This inserts backspaces and appends the changed text.</a>
<a name="ln2183">/// &quot;ptr&quot; is the known leader text or NUL.</a>
<a name="ln2184">static void ins_compl_fixRedoBufForLeader(char *ptr_arg)</a>
<a name="ln2185">{</a>
<a name="ln2186">  int len;</a>
<a name="ln2187">  char *p;</a>
<a name="ln2188">  char *ptr = ptr_arg;</a>
<a name="ln2189"> </a>
<a name="ln2190">  if (ptr == NULL) {</a>
<a name="ln2191">    if (compl_leader != NULL) {</a>
<a name="ln2192">      ptr = compl_leader;</a>
<a name="ln2193">    } else {</a>
<a name="ln2194">      return;        // nothing to do</a>
<a name="ln2195">    }</a>
<a name="ln2196">  }</a>
<a name="ln2197">  if (compl_orig_text != NULL) {</a>
<a name="ln2198">    p = compl_orig_text;</a>
<a name="ln2199">    for (len = 0; p[len] != NUL &amp;&amp; p[len] == ptr[len]; len++) {}</a>
<a name="ln2200">    if (len &gt; 0) {</a>
<a name="ln2201">      len -= utf_head_off(p, p + len);</a>
<a name="ln2202">    }</a>
<a name="ln2203">    for (p += len; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2204">      AppendCharToRedobuff(K_BS);</a>
<a name="ln2205">    }</a>
<a name="ln2206">  } else {</a>
<a name="ln2207">    len = 0;</a>
<a name="ln2208">  }</a>
<a name="ln2209">  AppendToRedobuffLit(ptr + len, -1);</a>
<a name="ln2210">}</a>
<a name="ln2211"> </a>
<a name="ln2212">/// Loops through the list of windows, loaded-buffers or non-loaded-buffers</a>
<a name="ln2213">/// (depending on flag) starting from buf and looking for a non-scanned</a>
<a name="ln2214">/// buffer (other than curbuf).  curbuf is special, if it is called with</a>
<a name="ln2215">/// buf=curbuf then it has to be the first call for a given flag/expansion.</a>
<a name="ln2216">///</a>
<a name="ln2217">/// Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo</a>
<a name="ln2218">static buf_T *ins_compl_next_buf(buf_T *buf, int flag)</a>
<a name="ln2219">{</a>
<a name="ln2220">  static win_T *wp = NULL;</a>
<a name="ln2221"> </a>
<a name="ln2222">  if (flag == 'w') {            // just windows</a>
<a name="ln2223">    if (buf == curbuf || !win_valid(wp)) {</a>
<a name="ln2224">      // first call for this flag/expansion or window was closed</a>
<a name="ln2225">      wp = curwin;</a>
<a name="ln2226">    }</a>
<a name="ln2227">    assert(wp);</a>
<a name="ln2228">    while ((wp = (wp-&gt;w_next != NULL ? wp-&gt;w_next : firstwin)) != curwin</a>
<a name="ln2229">           &amp;&amp; wp-&gt;w_buffer-&gt;b_scanned) {}</a>
<a name="ln2230">    buf = wp-&gt;w_buffer;</a>
<a name="ln2231">  } else {</a>
<a name="ln2232">    // 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'</a>
<a name="ln2233">    // (unlisted buffers)</a>
<a name="ln2234">    // When completing whole lines skip unloaded buffers.</a>
<a name="ln2235">    while ((buf = (buf-&gt;b_next != NULL ? buf-&gt;b_next : firstbuf)) != curbuf</a>
<a name="ln2236">           &amp;&amp; ((flag == 'U'</a>
<a name="ln2237">                ? buf-&gt;b_p_bl</a>
<a name="ln2238">                : (!buf-&gt;b_p_bl</a>
<a name="ln2239">                   || (buf-&gt;b_ml.ml_mfp == NULL) != (flag == 'u')))</a>
<a name="ln2240">               || buf-&gt;b_scanned)) {}</a>
<a name="ln2241">  }</a>
<a name="ln2242">  return buf;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">static Callback cfu_cb;    ///&lt; 'completefunc' callback function</a>
<a name="ln2246">static Callback ofu_cb;    ///&lt; 'omnifunc' callback function</a>
<a name="ln2247">static Callback tsrfu_cb;  ///&lt; 'thesaurusfunc' callback function</a>
<a name="ln2248"> </a>
<a name="ln2249">/// Copy a global callback function to a buffer local callback.</a>
<a name="ln2250">static void copy_global_to_buflocal_cb(Callback *globcb, Callback *bufcb)</a>
<a name="ln2251">{</a>
<a name="ln2252">  callback_free(bufcb);</a>
<a name="ln2253">  if (globcb-&gt;type != kCallbackNone) {</a>
<a name="ln2254">    callback_copy(bufcb, globcb);</a>
<a name="ln2255">  }</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">/// Parse the 'completefunc' option value and set the callback function.</a>
<a name="ln2259">/// Invoked when the 'completefunc' option is set. The option value can be a</a>
<a name="ln2260">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2261">/// lambda expression.</a>
<a name="ln2262">const char *did_set_completefunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2263">{</a>
<a name="ln2264">  if (option_set_callback_func(curbuf-&gt;b_p_cfu, &amp;cfu_cb) == FAIL) {</a>
<a name="ln2265">    return e_invarg;</a>
<a name="ln2266">  }</a>
<a name="ln2267"> </a>
<a name="ln2268">  set_buflocal_cfu_callback(curbuf);</a>
<a name="ln2269">  return NULL;</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272">/// Copy the global 'completefunc' callback function to the buffer-local</a>
<a name="ln2273">/// 'completefunc' callback for &quot;buf&quot;.</a>
<a name="ln2274">void set_buflocal_cfu_callback(buf_T *buf)</a>
<a name="ln2275">{</a>
<a name="ln2276">  copy_global_to_buflocal_cb(&amp;cfu_cb, &amp;buf-&gt;b_cfu_cb);</a>
<a name="ln2277">}</a>
<a name="ln2278"> </a>
<a name="ln2279">/// Parse the 'omnifunc' option value and set the callback function.</a>
<a name="ln2280">/// Invoked when the 'omnifunc' option is set. The option value can be a</a>
<a name="ln2281">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2282">/// lambda expression.</a>
<a name="ln2283">const char *did_set_omnifunc(optset_T *args)</a>
<a name="ln2284">{</a>
<a name="ln2285">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2286">  if (option_set_callback_func(buf-&gt;b_p_ofu, &amp;ofu_cb) == FAIL) {</a>
<a name="ln2287">    return e_invarg;</a>
<a name="ln2288">  }</a>
<a name="ln2289">  set_buflocal_ofu_callback(buf);</a>
<a name="ln2290">  return NULL;</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">/// Copy the global 'omnifunc' callback function to the buffer-local 'omnifunc'</a>
<a name="ln2294">/// callback for &quot;buf&quot;.</a>
<a name="ln2295">void set_buflocal_ofu_callback(buf_T *buf)</a>
<a name="ln2296">{</a>
<a name="ln2297">  copy_global_to_buflocal_cb(&amp;ofu_cb, &amp;buf-&gt;b_ofu_cb);</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">/// Parse the 'thesaurusfunc' option value and set the callback function.</a>
<a name="ln2301">/// Invoked when the 'thesaurusfunc' option is set. The option value can be a</a>
<a name="ln2302">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2303">/// lambda expression.</a>
<a name="ln2304">const char *did_set_thesaurusfunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2305">{</a>
<a name="ln2306">  int retval;</a>
<a name="ln2307"> </a>
<a name="ln2308">  if (*curbuf-&gt;b_p_tsrfu != NUL) {</a>
<a name="ln2309">    // buffer-local option set</a>
<a name="ln2310">    retval = option_set_callback_func(curbuf-&gt;b_p_tsrfu, &amp;curbuf-&gt;b_tsrfu_cb);</a>
<a name="ln2311">  } else {</a>
<a name="ln2312">    // global option set</a>
<a name="ln2313">    retval = option_set_callback_func(p_tsrfu, &amp;tsrfu_cb);</a>
<a name="ln2314">  }</a>
<a name="ln2315"> </a>
<a name="ln2316">  return retval == FAIL ? e_invarg : NULL;</a>
<a name="ln2317">}</a>
<a name="ln2318"> </a>
<a name="ln2319">/// Mark the global 'completefunc' 'omnifunc' and 'thesaurusfunc' callbacks with</a>
<a name="ln2320">/// &quot;copyID&quot; so that they are not garbage collected.</a>
<a name="ln2321">bool set_ref_in_insexpand_funcs(int copyID)</a>
<a name="ln2322">{</a>
<a name="ln2323">  bool abort = set_ref_in_callback(&amp;cfu_cb, copyID, NULL, NULL);</a>
<a name="ln2324">  abort = abort || set_ref_in_callback(&amp;ofu_cb, copyID, NULL, NULL);</a>
<a name="ln2325">  abort = abort || set_ref_in_callback(&amp;tsrfu_cb, copyID, NULL, NULL);</a>
<a name="ln2326"> </a>
<a name="ln2327">  return abort;</a>
<a name="ln2328">}</a>
<a name="ln2329"> </a>
<a name="ln2330">/// Get the user-defined completion function name for completion &quot;type&quot;</a>
<a name="ln2331">static char *get_complete_funcname(int type)</a>
<a name="ln2332">{</a>
<a name="ln2333">  switch (type) {</a>
<a name="ln2334">  case CTRL_X_FUNCTION:</a>
<a name="ln2335">    return curbuf-&gt;b_p_cfu;</a>
<a name="ln2336">  case CTRL_X_OMNI:</a>
<a name="ln2337">    return curbuf-&gt;b_p_ofu;</a>
<a name="ln2338">  case CTRL_X_THESAURUS:</a>
<a name="ln2339">    return *curbuf-&gt;b_p_tsrfu == NUL ? p_tsrfu : curbuf-&gt;b_p_tsrfu;</a>
<a name="ln2340">  default:</a>
<a name="ln2341">    return &quot;&quot;;</a>
<a name="ln2342">  }</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345">/// Get the callback to use for insert mode completion.</a>
<a name="ln2346">static Callback *get_insert_callback(int type)</a>
<a name="ln2347">{</a>
<a name="ln2348">  if (type == CTRL_X_FUNCTION) {</a>
<a name="ln2349">    return &amp;curbuf-&gt;b_cfu_cb;</a>
<a name="ln2350">  }</a>
<a name="ln2351">  if (type == CTRL_X_OMNI) {</a>
<a name="ln2352">    return &amp;curbuf-&gt;b_ofu_cb;</a>
<a name="ln2353">  }</a>
<a name="ln2354">  // CTRL_X_THESAURUS</a>
<a name="ln2355">  return (*curbuf-&gt;b_p_tsrfu != NUL) ? &amp;curbuf-&gt;b_tsrfu_cb : &amp;tsrfu_cb;</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358">/// Execute user defined complete function 'completefunc', 'omnifunc' or</a>
<a name="ln2359">/// 'thesaurusfunc', and get matches in &quot;matches&quot;.</a>
<a name="ln2360">///</a>
<a name="ln2361">/// @param type  either CTRL_X_OMNI or CTRL_X_FUNCTION or CTRL_X_THESAURUS</a>
<a name="ln2362">static void expand_by_function(int type, char *base)</a>
<a name="ln2363">{</a>
<a name="ln2364">  list_T *matchlist = NULL;</a>
<a name="ln2365">  dict_T *matchdict = NULL;</a>
<a name="ln2366">  char *funcname;</a>
<a name="ln2367">  pos_T pos;</a>
<a name="ln2368">  typval_T rettv;</a>
<a name="ln2369">  const int save_State = State;</a>
<a name="ln2370"> </a>
<a name="ln2371">  assert(curbuf != NULL);</a>
<a name="ln2372">  funcname = get_complete_funcname(type);</a>
<a name="ln2373">  if (*funcname == NUL) {</a>
<a name="ln2374">    return;</a>
<a name="ln2375">  }</a>
<a name="ln2376"> </a>
<a name="ln2377">  // Call 'completefunc' to obtain the list of matches.</a>
<a name="ln2378">  typval_T args[3];</a>
<a name="ln2379">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln2380">  args[1].v_type = VAR_STRING;</a>
<a name="ln2381">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln2382">  args[0].vval.v_number = 0;</a>
<a name="ln2383">  args[1].vval.v_string = base != NULL ? base : &quot;&quot;;</a>
<a name="ln2384"> </a>
<a name="ln2385">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2386">  // Lock the text to avoid weird things from happening.  Also disallow</a>
<a name="ln2387">  // switching to another window, it should not be needed and may end up in</a>
<a name="ln2388">  // Insert mode in another buffer.</a>
<a name="ln2389">  textlock++;</a>
<a name="ln2390"> </a>
<a name="ln2391">  Callback *cb = get_insert_callback(type);</a>
<a name="ln2392"> </a>
<a name="ln2393">  // Call a function, which returns a list or dict.</a>
<a name="ln2394">  if (callback_call(cb, 2, args, &amp;rettv)) {</a>
<a name="ln2395">    switch (rettv.v_type) {</a>
<a name="ln2396">    case VAR_LIST:</a>
<a name="ln2397">      matchlist = rettv.vval.v_list;</a>
<a name="ln2398">      break;</a>
<a name="ln2399">    case VAR_DICT:</a>
<a name="ln2400">      matchdict = rettv.vval.v_dict;</a>
<a name="ln2401">      break;</a>
<a name="ln2402">    case VAR_SPECIAL:</a>
<a name="ln2403">      FALLTHROUGH;</a>
<a name="ln2404">    default:</a>
<a name="ln2405">      // TODO(brammool): Give error message?</a>
<a name="ln2406">      tv_clear(&amp;rettv);</a>
<a name="ln2407">      break;</a>
<a name="ln2408">    }</a>
<a name="ln2409">  }</a>
<a name="ln2410">  textlock--;</a>
<a name="ln2411"> </a>
<a name="ln2412">  curwin-&gt;w_cursor = pos;       // restore the cursor position</a>
<a name="ln2413">  validate_cursor();</a>
<a name="ln2414">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln2415">    emsg(_(e_compldel));</a>
<a name="ln2416">    goto theend;</a>
<a name="ln2417">  }</a>
<a name="ln2418"> </a>
<a name="ln2419">  if (matchlist != NULL) {</a>
<a name="ln2420">    ins_compl_add_list(matchlist);</a>
<a name="ln2421">  } else if (matchdict != NULL) {</a>
<a name="ln2422">    ins_compl_add_dict(matchdict);</a>
<a name="ln2423">  }</a>
<a name="ln2424"> </a>
<a name="ln2425">theend:</a>
<a name="ln2426">  // Restore State, it might have been changed.</a>
<a name="ln2427">  State = save_State;</a>
<a name="ln2428"> </a>
<a name="ln2429">  if (matchdict != NULL) {</a>
<a name="ln2430">    tv_dict_unref(matchdict);</a>
<a name="ln2431">  }</a>
<a name="ln2432">  if (matchlist != NULL) {</a>
<a name="ln2433">    tv_list_unref(matchlist);</a>
<a name="ln2434">  }</a>
<a name="ln2435">}</a>
<a name="ln2436"> </a>
<a name="ln2437">/// Add a match to the list of matches from Vimscript object</a>
<a name="ln2438">///</a>
<a name="ln2439">/// @param[in]  tv  Object to get matches from.</a>
<a name="ln2440">/// @param[in]  dir  Completion direction.</a>
<a name="ln2441">/// @param[in]  fast  use fast_breakcheck() instead of os_breakcheck().</a>
<a name="ln2442">///</a>
<a name="ln2443">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln2444">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln2445">///         returned in case of error.</a>
<a name="ln2446">static int ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)</a>
<a name="ln2447">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2448">{</a>
<a name="ln2449">  const char *word;</a>
<a name="ln2450">  bool dup = false;</a>
<a name="ln2451">  bool empty = false;</a>
<a name="ln2452">  int flags = fast ? CP_FAST : 0;</a>
<a name="ln2453">  char *(cptext[CPT_COUNT]);</a>
<a name="ln2454">  typval_T user_data;</a>
<a name="ln2455"> </a>
<a name="ln2456">  user_data.v_type = VAR_UNKNOWN;</a>
<a name="ln2457">  if (tv-&gt;v_type == VAR_DICT &amp;&amp; tv-&gt;vval.v_dict != NULL) {</a>
<a name="ln2458">    word = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;word&quot;, false);</a>
<a name="ln2459">    cptext[CPT_ABBR] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;abbr&quot;, true);</a>
<a name="ln2460">    cptext[CPT_MENU] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;menu&quot;, true);</a>
<a name="ln2461">    cptext[CPT_KIND] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;kind&quot;, true);</a>
<a name="ln2462">    cptext[CPT_INFO] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;info&quot;, true);</a>
<a name="ln2463">    tv_dict_get_tv(tv-&gt;vval.v_dict, &quot;user_data&quot;, &amp;user_data);</a>
<a name="ln2464"> </a>
<a name="ln2465">    if (tv_dict_get_number(tv-&gt;vval.v_dict, &quot;icase&quot;)) {</a>
<a name="ln2466">      flags |= CP_ICASE;</a>
<a name="ln2467">    }</a>
<a name="ln2468">    dup = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;dup&quot;);</a>
<a name="ln2469">    empty = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;empty&quot;);</a>
<a name="ln2470">    if (tv_dict_get_string(tv-&gt;vval.v_dict, &quot;equal&quot;, false) != NULL</a>
<a name="ln2471">        &amp;&amp; tv_dict_get_number(tv-&gt;vval.v_dict, &quot;equal&quot;)) {</a>
<a name="ln2472">      flags |= CP_EQUAL;</a>
<a name="ln2473">    }</a>
<a name="ln2474">  } else {</a>
<a name="ln2475">    word = tv_get_string_chk(tv);</a>
<a name="ln2476">    CLEAR_FIELD(cptext);</a>
<a name="ln2477">  }</a>
<a name="ln2478">  if (word == NULL || (!empty &amp;&amp; *word == NUL)) {</a>
<a name="ln2479">    for (size_t i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln2480">      xfree(cptext[i]);</a>
<a name="ln2481">    }</a>
<a name="ln2482">    tv_clear(&amp;user_data);</a>
<a name="ln2483">    return FAIL;</a>
<a name="ln2484">  }</a>
<a name="ln2485">  int status = ins_compl_add((char *)word, -1, NULL, cptext, true,</a>
<a name="ln2486">                             &amp;user_data, dir, flags, dup);</a>
<a name="ln2487">  if (status != OK) {</a>
<a name="ln2488">    tv_clear(&amp;user_data);</a>
<a name="ln2489">  }</a>
<a name="ln2490">  return status;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">/// Add completions from a list.</a>
<a name="ln2494">static void ins_compl_add_list(list_T *const list)</a>
<a name="ln2495">{</a>
<a name="ln2496">  Direction dir = compl_direction;</a>
<a name="ln2497"> </a>
<a name="ln2498">  // Go through the List with matches and add each of them.</a>
<a name="ln2499">  TV_LIST_ITER(list, li, {</a>
<a name="ln2500">    if (ins_compl_add_tv(TV_LIST_ITEM_TV(li), dir, true) == OK) {</a>
<a name="ln2501">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln2502">      dir = FORWARD;</a>
<a name="ln2503">    } else if (did_emsg) {</a>
<a name="ln2504">      break;</a>
<a name="ln2505">    }</a>
<a name="ln2506">  });</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">/// Add completions from a dict.</a>
<a name="ln2510">static void ins_compl_add_dict(dict_T *dict)</a>
<a name="ln2511">{</a>
<a name="ln2512">  dictitem_T *di_refresh;</a>
<a name="ln2513">  dictitem_T *di_words;</a>
<a name="ln2514"> </a>
<a name="ln2515">  // Check for optional &quot;refresh&quot; item.</a>
<a name="ln2516">  compl_opt_refresh_always = false;</a>
<a name="ln2517">  di_refresh = tv_dict_find(dict, S_LEN(&quot;refresh&quot;));</a>
<a name="ln2518">  if (di_refresh != NULL &amp;&amp; di_refresh-&gt;di_tv.v_type == VAR_STRING) {</a>
<a name="ln2519">    const char *v = di_refresh-&gt;di_tv.vval.v_string;</a>
<a name="ln2520"> </a>
<a name="ln2521">    if (v != NULL &amp;&amp; strcmp(v, &quot;always&quot;) == 0) {</a>
<a name="ln2522">      compl_opt_refresh_always = true;</a>
<a name="ln2523">    }</a>
<a name="ln2524">  }</a>
<a name="ln2525"> </a>
<a name="ln2526">  // Add completions from a &quot;words&quot; list.</a>
<a name="ln2527">  di_words = tv_dict_find(dict, S_LEN(&quot;words&quot;));</a>
<a name="ln2528">  if (di_words != NULL &amp;&amp; di_words-&gt;di_tv.v_type == VAR_LIST) {</a>
<a name="ln2529">    ins_compl_add_list(di_words-&gt;di_tv.vval.v_list);</a>
<a name="ln2530">  }</a>
<a name="ln2531">}</a>
<a name="ln2532"> </a>
<a name="ln2533">/// Start completion for the complete() function.</a>
<a name="ln2534">///</a>
<a name="ln2535">/// @param startcol  where the matched text starts (1 is first column).</a>
<a name="ln2536">/// @param list      the list of matches.</a>
<a name="ln2537">static void set_completion(colnr_T startcol, list_T *list)</a>
<a name="ln2538">{</a>
<a name="ln2539">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln2540"> </a>
<a name="ln2541">  // If already doing completions stop it.</a>
<a name="ln2542">  if (ctrl_x_mode_not_default()) {</a>
<a name="ln2543">    ins_compl_prep(' ');</a>
<a name="ln2544">  }</a>
<a name="ln2545">  ins_compl_clear();</a>
<a name="ln2546">  ins_compl_free();</a>
<a name="ln2547">  compl_get_longest = compl_longest;</a>
<a name="ln2548"> </a>
<a name="ln2549">  compl_direction = FORWARD;</a>
<a name="ln2550">  if (startcol &gt; curwin-&gt;w_cursor.col) {</a>
<a name="ln2551">    startcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2552">  }</a>
<a name="ln2553">  compl_col = startcol;</a>
<a name="ln2554">  compl_length = (int)curwin-&gt;w_cursor.col - (int)startcol;</a>
<a name="ln2555">  // compl_pattern doesn't need to be set</a>
<a name="ln2556">  compl_orig_text = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln2557">                              (size_t)compl_length);</a>
<a name="ln2558">  if (p_ic) {</a>
<a name="ln2559">    flags |= CP_ICASE;</a>
<a name="ln2560">  }</a>
<a name="ln2561">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln2562">                    flags | CP_FAST, false) != OK) {</a>
<a name="ln2563">    return;</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  ctrl_x_mode = CTRL_X_EVAL;</a>
<a name="ln2567"> </a>
<a name="ln2568">  ins_compl_add_list(list);</a>
<a name="ln2569">  compl_matches = ins_compl_make_cyclic();</a>
<a name="ln2570">  compl_started = true;</a>
<a name="ln2571">  compl_used_match = true;</a>
<a name="ln2572">  compl_cont_status = 0;</a>
<a name="ln2573">  int save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln2574">  int save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln2575"> </a>
<a name="ln2576">  compl_curr_match = compl_first_match;</a>
<a name="ln2577">  bool no_select = compl_no_select || compl_longest;</a>
<a name="ln2578">  if (compl_no_insert || no_select) {</a>
<a name="ln2579">    ins_complete(K_DOWN, false);</a>
<a name="ln2580">    if (no_select) {</a>
<a name="ln2581">      ins_complete(K_UP, false);</a>
<a name="ln2582">    }</a>
<a name="ln2583">  } else {</a>
<a name="ln2584">    ins_complete(Ctrl_N, false);</a>
<a name="ln2585">  }</a>
<a name="ln2586">  compl_enter_selects = compl_no_insert;</a>
<a name="ln2587"> </a>
<a name="ln2588">  // Lazily show the popup menu, unless we got interrupted.</a>
<a name="ln2589">  if (!compl_interrupted) {</a>
<a name="ln2590">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln2591">  }</a>
<a name="ln2592"> </a>
<a name="ln2593">  may_trigger_modechanged();</a>
<a name="ln2594">  ui_flush();</a>
<a name="ln2595">}</a>
<a name="ln2596"> </a>
<a name="ln2597">/// &quot;complete()&quot; function</a>
<a name="ln2598">void f_complete(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2599">{</a>
<a name="ln2600">  if ((State &amp; MODE_INSERT) == 0) {</a>
<a name="ln2601">    emsg(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln2602">    return;</a>
<a name="ln2603">  }</a>
<a name="ln2604"> </a>
<a name="ln2605">  // Check for undo allowed here, because if something was already inserted</a>
<a name="ln2606">  // the line was already saved for undo and this check isn't done.</a>
<a name="ln2607">  if (!undo_allowed(curbuf)) {</a>
<a name="ln2608">    return;</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln2612">    emsg(_(e_invarg));</a>
<a name="ln2613">  } else {</a>
<a name="ln2614">    const colnr_T startcol = (colnr_T)tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln2615">    if (startcol &gt; 0) {</a>
<a name="ln2616">      set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln2617">    }</a>
<a name="ln2618">  }</a>
<a name="ln2619">}</a>
<a name="ln2620"> </a>
<a name="ln2621">/// &quot;complete_add()&quot; function</a>
<a name="ln2622">void f_complete_add(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2623">{</a>
<a name="ln2624">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln2625">}</a>
<a name="ln2626"> </a>
<a name="ln2627">/// &quot;complete_check()&quot; function</a>
<a name="ln2628">void f_complete_check(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2629">{</a>
<a name="ln2630">  int saved = RedrawingDisabled;</a>
<a name="ln2631"> </a>
<a name="ln2632">  RedrawingDisabled = 0;</a>
<a name="ln2633">  ins_compl_check_keys(0, true);</a>
<a name="ln2634">  rettv-&gt;vval.v_number = ins_compl_interrupted();</a>
<a name="ln2635">  RedrawingDisabled = saved;</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">/// Return Insert completion mode name string</a>
<a name="ln2639">static char *ins_compl_mode(void)</a>
<a name="ln2640">{</a>
<a name="ln2641">  if (ctrl_x_mode_not_defined_yet() || ctrl_x_mode_scroll() || compl_started) {</a>
<a name="ln2642">    return ctrl_x_mode_names[ctrl_x_mode &amp; ~CTRL_X_WANT_IDENT];</a>
<a name="ln2643">  }</a>
<a name="ln2644">  return &quot;&quot;;</a>
<a name="ln2645">}</a>
<a name="ln2646"> </a>
<a name="ln2647">/// Assign the sequence number to all the completion matches which don't have</a>
<a name="ln2648">/// one assigned yet.</a>
<a name="ln2649">static void ins_compl_update_sequence_numbers(void)</a>
<a name="ln2650">{</a>
<a name="ln2651">  int number = 0;</a>
<a name="ln2652">  compl_T *match;</a>
<a name="ln2653"> </a>
<a name="ln2654">  if (compl_dir_forward()) {</a>
<a name="ln2655">    // Search backwards for the first valid (!= -1) number.</a>
<a name="ln2656">    // This should normally succeed already at the first loop</a>
<a name="ln2657">    // cycle, so it's fast!</a>
<a name="ln2658">    for (match = compl_curr_match-&gt;cp_prev;</a>
<a name="ln2659">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_prev) {</a>
<a name="ln2660">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2661">        number = match-&gt;cp_number;</a>
<a name="ln2662">        break;</a>
<a name="ln2663">      }</a>
<a name="ln2664">    }</a>
<a name="ln2665">    if (match != NULL) {</a>
<a name="ln2666">      // go up and assign all numbers which are not assigned yet</a>
<a name="ln2667">      for (match = match-&gt;cp_next;</a>
<a name="ln2668">           match != NULL &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2669">           match = match-&gt;cp_next) {</a>
<a name="ln2670">        match-&gt;cp_number = ++number;</a>
<a name="ln2671">      }</a>
<a name="ln2672">    }</a>
<a name="ln2673">  } else {  // BACKWARD</a>
<a name="ln2674">    assert(compl_direction == BACKWARD);</a>
<a name="ln2675">    // Search forwards (upwards) for the first valid (!= -1)</a>
<a name="ln2676">    // number.  This should normally succeed already at the</a>
<a name="ln2677">    // first loop cycle, so it's fast!</a>
<a name="ln2678">    for (match = compl_curr_match-&gt;cp_next;</a>
<a name="ln2679">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_next) {</a>
<a name="ln2680">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2681">        number = match-&gt;cp_number;</a>
<a name="ln2682">        break;</a>
<a name="ln2683">      }</a>
<a name="ln2684">    }</a>
<a name="ln2685">    if (match != NULL) {</a>
<a name="ln2686">      // go down and assign all numbers which are not assigned yet</a>
<a name="ln2687">      for (match = match-&gt;cp_prev;</a>
<a name="ln2688">           match &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2689">           match = match-&gt;cp_prev) {</a>
<a name="ln2690">        match-&gt;cp_number = ++number;</a>
<a name="ln2691">      }</a>
<a name="ln2692">    }</a>
<a name="ln2693">  }</a>
<a name="ln2694">}</a>
<a name="ln2695"> </a>
<a name="ln2696">/// Get complete information</a>
<a name="ln2697">static void get_complete_info(list_T *what_list, dict_T *retdict)</a>
<a name="ln2698">{</a>
<a name="ln2699">#define CI_WHAT_MODE            0x01</a>
<a name="ln2700">#define CI_WHAT_PUM_VISIBLE     0x02</a>
<a name="ln2701">#define CI_WHAT_ITEMS           0x04</a>
<a name="ln2702">#define CI_WHAT_SELECTED        0x08</a>
<a name="ln2703">#define CI_WHAT_INSERTED        0x10</a>
<a name="ln2704">#define CI_WHAT_ALL             0xff</a>
<a name="ln2705">  int what_flag;</a>
<a name="ln2706"> </a>
<a name="ln2707">  if (what_list == NULL) {</a>
<a name="ln2708">    what_flag = CI_WHAT_ALL;</a>
<a name="ln2709">  } else {</a>
<a name="ln2710">    what_flag = 0;</a>
<a name="ln2711">    for (listitem_T *item = tv_list_first(what_list)</a>
<a name="ln2712">         ; item != NULL</a>
<a name="ln2713">         ; item = TV_LIST_ITEM_NEXT(what_list, item)) {</a>
<a name="ln2714">      const char *what = tv_get_string(TV_LIST_ITEM_TV(item));</a>
<a name="ln2715"> </a>
<a name="ln2716">      if (strcmp(what, &quot;mode&quot;) == 0) {</a>
<a name="ln2717">        what_flag |= CI_WHAT_MODE;</a>
<a name="ln2718">      } else if (strcmp(what, &quot;pum_visible&quot;) == 0) {</a>
<a name="ln2719">        what_flag |= CI_WHAT_PUM_VISIBLE;</a>
<a name="ln2720">      } else if (strcmp(what, &quot;items&quot;) == 0) {</a>
<a name="ln2721">        what_flag |= CI_WHAT_ITEMS;</a>
<a name="ln2722">      } else if (strcmp(what, &quot;selected&quot;) == 0) {</a>
<a name="ln2723">        what_flag |= CI_WHAT_SELECTED;</a>
<a name="ln2724">      } else if (strcmp(what, &quot;inserted&quot;) == 0) {</a>
<a name="ln2725">        what_flag |= CI_WHAT_INSERTED;</a>
<a name="ln2726">      }</a>
<a name="ln2727">    }</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  int ret = OK;</a>
<a name="ln2731">  if (what_flag &amp; CI_WHAT_MODE) {</a>
<a name="ln2732">    ret = tv_dict_add_str(retdict, S_LEN(&quot;mode&quot;), ins_compl_mode());</a>
<a name="ln2733">  }</a>
<a name="ln2734"> </a>
<a name="ln2735">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_PUM_VISIBLE)) {</a>
<a name="ln2736">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;pum_visible&quot;), pum_visible());</a>
<a name="ln2737">  }</a>
<a name="ln2738"> </a>
<a name="ln2739">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_ITEMS)) {</a>
<a name="ln2740">    list_T *li = tv_list_alloc(get_compl_len());</a>
<a name="ln2741"> </a>
<a name="ln2742">    ret = tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), li);</a>
<a name="ln2743">    if (ret == OK &amp;&amp; compl_first_match != NULL) {</a>
<a name="ln2744">      compl_T *match = compl_first_match;</a>
<a name="ln2745">      do {</a>
<a name="ln2746">        if (!match_at_original_text(match)) {</a>
<a name="ln2747">          dict_T *di = tv_dict_alloc();</a>
<a name="ln2748"> </a>
<a name="ln2749">          tv_list_append_dict(li, di);</a>
<a name="ln2750">          tv_dict_add_str(di, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln2751">          tv_dict_add_str(di, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln2752">          tv_dict_add_str(di, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln2753">          tv_dict_add_str(di, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln2754">          tv_dict_add_str(di, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln2755">          if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln2756">            // Add an empty string for backwards compatibility</a>
<a name="ln2757">            tv_dict_add_str(di, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln2758">          } else {</a>
<a name="ln2759">            tv_dict_add_tv(di, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln2760">          }</a>
<a name="ln2761">        }</a>
<a name="ln2762">        match = match-&gt;cp_next;</a>
<a name="ln2763">      } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln2764">    }</a>
<a name="ln2765">  }</a>
<a name="ln2766"> </a>
<a name="ln2767">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_SELECTED)) {</a>
<a name="ln2768">    if (compl_curr_match != NULL &amp;&amp; compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln2769">      ins_compl_update_sequence_numbers();</a>
<a name="ln2770">    }</a>
<a name="ln2771">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;selected&quot;),</a>
<a name="ln2772">                         (compl_curr_match != NULL)</a>
<a name="ln2773">                         ? compl_curr_match-&gt;cp_number - 1 : -1);</a>
<a name="ln2774">  }</a>
<a name="ln2775"> </a>
<a name="ln2776">  (void)ret;</a>
<a name="ln2777">  // TODO(vim):</a>
<a name="ln2778">  // if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_INSERTED))</a>
<a name="ln2779">}</a>
<a name="ln2780"> </a>
<a name="ln2781">/// &quot;complete_info()&quot; function</a>
<a name="ln2782">void f_complete_info(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2783">{</a>
<a name="ln2784">  tv_dict_alloc_ret(rettv);</a>
<a name="ln2785"> </a>
<a name="ln2786">  list_T *what_list = NULL;</a>
<a name="ln2787"> </a>
<a name="ln2788">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2789">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2790">      emsg(_(e_listreq));</a>
<a name="ln2791">      return;</a>
<a name="ln2792">    }</a>
<a name="ln2793">    what_list = argvars[0].vval.v_list;</a>
<a name="ln2794">  }</a>
<a name="ln2795">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln2796">}</a>
<a name="ln2797"> </a>
<a name="ln2798">/// Returns true when using a user-defined function for thesaurus completion.</a>
<a name="ln2799">static bool thesaurus_func_complete(int type)</a>
<a name="ln2800">{</a>
<a name="ln2801">  return type == CTRL_X_THESAURUS</a>
<a name="ln2802">         &amp;&amp; (*curbuf-&gt;b_p_tsrfu != NUL || *p_tsrfu != NUL);</a>
<a name="ln2803">}</a>
<a name="ln2804"> </a>
<a name="ln2805">/// Return value of process_next_cpt_value()</a>
<a name="ln2806">enum {</a>
<a name="ln2807">  INS_COMPL_CPT_OK = 1,</a>
<a name="ln2808">  INS_COMPL_CPT_CONT,</a>
<a name="ln2809">  INS_COMPL_CPT_END,</a>
<a name="ln2810">};</a>
<a name="ln2811"> </a>
<a name="ln2812">/// Process the next 'complete' option value in st-&gt;e_cpt.</a>
<a name="ln2813">///</a>
<a name="ln2814">/// If successful, the arguments are set as below:</a>
<a name="ln2815">///   st-&gt;cpt - pointer to the next option value in &quot;st-&gt;cpt&quot;</a>
<a name="ln2816">///   compl_type_arg - type of insert mode completion to use</a>
<a name="ln2817">///   st-&gt;found_all - all matches of this type are found</a>
<a name="ln2818">///   st-&gt;ins_buf - search for completions in this buffer</a>
<a name="ln2819">///   st-&gt;first_match_pos - position of the first completion match</a>
<a name="ln2820">///   st-&gt;last_match_pos - position of the last completion match</a>
<a name="ln2821">///   st-&gt;set_match_pos - true if the first match position should be saved to</a>
<a name="ln2822">///                       avoid loops after the search wraps around.</a>
<a name="ln2823">///   st-&gt;dict - name of the dictionary or thesaurus file to search</a>
<a name="ln2824">///   st-&gt;dict_f - flag specifying whether &quot;dict&quot; is an exact file name or not</a>
<a name="ln2825">///</a>
<a name="ln2826">/// @return  INS_COMPL_CPT_OK if the next value is processed successfully.</a>
<a name="ln2827">///          INS_COMPL_CPT_CONT to skip the current completion source matching</a>
<a name="ln2828">///          the &quot;st-&gt;e_cpt&quot; option value and process the next matching source.</a>
<a name="ln2829">///          INS_COMPL_CPT_END if all the values in &quot;st-&gt;e_cpt&quot; are processed.</a>
<a name="ln2830">static int process_next_cpt_value(ins_compl_next_state_T *st, int *compl_type_arg,</a>
<a name="ln2831">                                  pos_T *start_match_pos)</a>
<a name="ln2832">{</a>
<a name="ln2833">  int compl_type = -1;</a>
<a name="ln2834">  int status = INS_COMPL_CPT_OK;</a>
<a name="ln2835"> </a>
<a name="ln2836">  st-&gt;found_all = false;</a>
<a name="ln2837"> </a>
<a name="ln2838">  while (*st-&gt;e_cpt == ',' || *st-&gt;e_cpt == ' ') {</a>
<a name="ln2839">    st-&gt;e_cpt++;</a>
<a name="ln2840">  }</a>
<a name="ln2841"> </a>
<a name="ln2842">  if (*st-&gt;e_cpt == '.' &amp;&amp; !curbuf-&gt;b_scanned) {</a>
<a name="ln2843">    st-&gt;ins_buf = curbuf;</a>
<a name="ln2844">    st-&gt;first_match_pos = *start_match_pos;</a>
<a name="ln2845">    // Move the cursor back one character so that ^N can match the</a>
<a name="ln2846">    // word immediately after the cursor.</a>
<a name="ln2847">    if (ctrl_x_mode_normal() &amp;&amp; dec(&amp;st-&gt;first_match_pos) &lt; 0) {</a>
<a name="ln2848">      // Move the cursor to after the last character in the</a>
<a name="ln2849">      // buffer, so that word at start of buffer is found</a>
<a name="ln2850">      // correctly.</a>
<a name="ln2851">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2852">      st-&gt;first_match_pos.col = (colnr_T)strlen(ml_get(st-&gt;first_match_pos.lnum));</a>
<a name="ln2853">    }</a>
<a name="ln2854">    st-&gt;last_match_pos = st-&gt;first_match_pos;</a>
<a name="ln2855">    compl_type = 0;</a>
<a name="ln2856"> </a>
<a name="ln2857">    // Remember the first match so that the loop stops when we</a>
<a name="ln2858">    // wrap and come back there a second time.</a>
<a name="ln2859">    st-&gt;set_match_pos = true;</a>
<a name="ln2860">  } else if (vim_strchr(&quot;buwU&quot;, (uint8_t)(*st-&gt;e_cpt)) != NULL</a>
<a name="ln2861">             &amp;&amp; (st-&gt;ins_buf = ins_compl_next_buf(st-&gt;ins_buf, *st-&gt;e_cpt)) != curbuf) {</a>
<a name="ln2862">    // Scan a buffer, but not the current one.</a>
<a name="ln2863">    if (st-&gt;ins_buf-&gt;b_ml.ml_mfp != NULL) {  // loaded buffer</a>
<a name="ln2864">      compl_started = true;</a>
<a name="ln2865">      st-&gt;first_match_pos.col = st-&gt;last_match_pos.col = 0;</a>
<a name="ln2866">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln2867">      st-&gt;last_match_pos.lnum = 0;</a>
<a name="ln2868">      compl_type = 0;</a>
<a name="ln2869">    } else {  // unloaded buffer, scan like dictionary</a>
<a name="ln2870">      st-&gt;found_all = true;</a>
<a name="ln2871">      if (st-&gt;ins_buf-&gt;b_fname == NULL) {</a>
<a name="ln2872">        status = INS_COMPL_CPT_CONT;</a>
<a name="ln2873">        goto done;</a>
<a name="ln2874">      }</a>
<a name="ln2875">      compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2876">      st-&gt;dict = st-&gt;ins_buf-&gt;b_fname;</a>
<a name="ln2877">      st-&gt;dict_f = DICT_EXACT;</a>
<a name="ln2878">    }</a>
<a name="ln2879">    if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2880">      msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln2881">      vim_snprintf(IObuff, IOSIZE, _(&quot;Scanning: %s&quot;),</a>
<a name="ln2882">                   st-&gt;ins_buf-&gt;b_fname == NULL</a>
<a name="ln2883">                   ? buf_spname(st-&gt;ins_buf)</a>
<a name="ln2884">                   : st-&gt;ins_buf-&gt;b_sfname == NULL</a>
<a name="ln2885">                   ? st-&gt;ins_buf-&gt;b_fname</a>
<a name="ln2886">                   : st-&gt;ins_buf-&gt;b_sfname);</a>
<a name="ln2887">      (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2888">    }</a>
<a name="ln2889">  } else if (*st-&gt;e_cpt == NUL) {</a>
<a name="ln2890">    status = INS_COMPL_CPT_END;</a>
<a name="ln2891">  } else {</a>
<a name="ln2892">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln2893">      // compl_type = -1;</a>
<a name="ln2894">    } else if (*st-&gt;e_cpt == 'k' || *st-&gt;e_cpt == 's') {</a>
<a name="ln2895">      if (*st-&gt;e_cpt == 'k') {</a>
<a name="ln2896">        compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2897">      } else {</a>
<a name="ln2898">        compl_type = CTRL_X_THESAURUS;</a>
<a name="ln2899">      }</a>
<a name="ln2900">      if (*++st-&gt;e_cpt != ',' &amp;&amp; *st-&gt;e_cpt != NUL) {</a>
<a name="ln2901">        st-&gt;dict = st-&gt;e_cpt;</a>
<a name="ln2902">        st-&gt;dict_f = DICT_FIRST;</a>
<a name="ln2903">      }</a>
<a name="ln2904">    } else if (*st-&gt;e_cpt == 'i') {</a>
<a name="ln2905">      compl_type = CTRL_X_PATH_PATTERNS;</a>
<a name="ln2906">    } else if (*st-&gt;e_cpt == 'd') {</a>
<a name="ln2907">      compl_type = CTRL_X_PATH_DEFINES;</a>
<a name="ln2908">    } else if (*st-&gt;e_cpt == ']' || *st-&gt;e_cpt == 't') {</a>
<a name="ln2909">      compl_type = CTRL_X_TAGS;</a>
<a name="ln2910">      if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2911">        msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln2912">        vim_snprintf(IObuff, IOSIZE, &quot;%s&quot;, _(&quot;Scanning tags.&quot;));</a>
<a name="ln2913">        (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2914">      }</a>
<a name="ln2915">    }</a>
<a name="ln2916"> </a>
<a name="ln2917">    // in any case e_cpt is advanced to the next entry</a>
<a name="ln2918">    (void)copy_option_part(&amp;st-&gt;e_cpt, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2919"> </a>
<a name="ln2920">    st-&gt;found_all = true;</a>
<a name="ln2921">    if (compl_type == -1) {</a>
<a name="ln2922">      status = INS_COMPL_CPT_CONT;</a>
<a name="ln2923">    }</a>
<a name="ln2924">  }</a>
<a name="ln2925"> </a>
<a name="ln2926">done:</a>
<a name="ln2927">  *compl_type_arg = compl_type;</a>
<a name="ln2928">  return status;</a>
<a name="ln2929">}</a>
<a name="ln2930"> </a>
<a name="ln2931">/// Get the next set of identifiers or defines matching &quot;compl_pattern&quot; in</a>
<a name="ln2932">/// included files.</a>
<a name="ln2933">static void get_next_include_file_completion(int compl_type)</a>
<a name="ln2934">{</a>
<a name="ln2935">  find_pattern_in_path(compl_pattern, compl_direction,</a>
<a name="ln2936">                       strlen(compl_pattern), false, false,</a>
<a name="ln2937">                       ((compl_type == CTRL_X_PATH_DEFINES</a>
<a name="ln2938">                         &amp;&amp; !(compl_cont_status &amp; CONT_SOL))</a>
<a name="ln2939">                        ? FIND_DEFINE : FIND_ANY),</a>
<a name="ln2940">                       1L, ACTION_EXPAND, 1, MAXLNUM);</a>
<a name="ln2941">}</a>
<a name="ln2942"> </a>
<a name="ln2943">/// Get the next set of words matching &quot;compl_pattern&quot; in dictionary or</a>
<a name="ln2944">/// thesaurus files.</a>
<a name="ln2945">static void get_next_dict_tsr_completion(int compl_type, char *dict, int dict_f)</a>
<a name="ln2946">{</a>
<a name="ln2947">  if (thesaurus_func_complete(compl_type)) {</a>
<a name="ln2948">    expand_by_function(compl_type, compl_pattern);</a>
<a name="ln2949">  } else {</a>
<a name="ln2950">    ins_compl_dictionaries(dict != NULL ? dict</a>
<a name="ln2951">                           : (compl_type == CTRL_X_THESAURUS</a>
<a name="ln2952">                              ? (*curbuf-&gt;b_p_tsr == NUL ? p_tsr : curbuf-&gt;b_p_tsr)</a>
<a name="ln2953">                              : (*curbuf-&gt;b_p_dict ==</a>
<a name="ln2954">                                 NUL ? p_dict : curbuf-&gt;b_p_dict)),</a>
<a name="ln2955">                           compl_pattern,</a>
<a name="ln2956">                           dict != NULL ? dict_f : 0,</a>
<a name="ln2957">                           compl_type == CTRL_X_THESAURUS);</a>
<a name="ln2958">  }</a>
<a name="ln2959">}</a>
<a name="ln2960"> </a>
<a name="ln2961">/// Get the next set of tag names matching &quot;compl_pattern&quot;.</a>
<a name="ln2962">static void get_next_tag_completion(void)</a>
<a name="ln2963">{</a>
<a name="ln2964">  // set p_ic according to p_ic, p_scs and pat for find_tags().</a>
<a name="ln2965">  const int save_p_ic = p_ic;</a>
<a name="ln2966">  p_ic = ignorecase(compl_pattern);</a>
<a name="ln2967"> </a>
<a name="ln2968">  // Find up to TAG_MANY matches.  Avoids that an enormous number</a>
<a name="ln2969">  // of matches is found when compl_pattern is empty</a>
<a name="ln2970">  g_tag_at_cursor = true;</a>
<a name="ln2971">  char **matches;</a>
<a name="ln2972">  int num_matches;</a>
<a name="ln2973">  if (find_tags(compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2974">                TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP</a>
<a name="ln2975">                | (ctrl_x_mode_not_default() ? TAG_VERBOSE : 0),</a>
<a name="ln2976">                TAG_MANY, curbuf-&gt;b_ffname) == OK &amp;&amp; num_matches &gt; 0) {</a>
<a name="ln2977">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln2978">  }</a>
<a name="ln2979">  g_tag_at_cursor = false;</a>
<a name="ln2980">  p_ic = save_p_ic;</a>
<a name="ln2981">}</a>
<a name="ln2982"> </a>
<a name="ln2983">/// Get the next set of filename matching &quot;compl_pattern&quot;.</a>
<a name="ln2984">static void get_next_filename_completion(void)</a>
<a name="ln2985">{</a>
<a name="ln2986">  char **matches;</a>
<a name="ln2987">  int num_matches;</a>
<a name="ln2988">  if (expand_wildcards(1, &amp;compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2989">                       EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK) {</a>
<a name="ln2990">    return;</a>
<a name="ln2991">  }</a>
<a name="ln2992"> </a>
<a name="ln2993">  // May change home directory back to &quot;~&quot;.</a>
<a name="ln2994">  tilde_replace(compl_pattern, num_matches, matches);</a>
<a name="ln2995">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2996">  if (curbuf-&gt;b_p_csl[0] != NUL) {</a>
<a name="ln2997">    for (int i = 0; i &lt; num_matches; i++) {</a>
<a name="ln2998">      char *ptr = matches[i];</a>
<a name="ln2999">      while (*ptr != NUL) {</a>
<a name="ln3000">        if (curbuf-&gt;b_p_csl[0] == 's' &amp;&amp; *ptr == '\\') {</a>
<a name="ln3001">          *ptr = '/';</a>
<a name="ln3002">        } else if (curbuf-&gt;b_p_csl[0] == 'b' &amp;&amp; *ptr == '/') {</a>
<a name="ln3003">          *ptr = '\\';</a>
<a name="ln3004">        }</a>
<a name="ln3005">        ptr += utfc_ptr2len(ptr);</a>
<a name="ln3006">      }</a>
<a name="ln3007">    }</a>
<a name="ln3008">  }</a>
<a name="ln3009">#endif</a>
<a name="ln3010">  ins_compl_add_matches(num_matches, matches, p_fic || p_wic);</a>
<a name="ln3011">}</a>
<a name="ln3012"> </a>
<a name="ln3013">/// Get the next set of command-line completions matching &quot;compl_pattern&quot;.</a>
<a name="ln3014">static void get_next_cmdline_completion(void)</a>
<a name="ln3015">{</a>
<a name="ln3016">  char **matches;</a>
<a name="ln3017">  int num_matches;</a>
<a name="ln3018">  if (expand_cmdline(&amp;compl_xp, compl_pattern,</a>
<a name="ln3019">                     (int)strlen(compl_pattern),</a>
<a name="ln3020">                     &amp;num_matches, &amp;matches) == EXPAND_OK) {</a>
<a name="ln3021">    ins_compl_add_matches(num_matches, matches, false);</a>
<a name="ln3022">  }</a>
<a name="ln3023">}</a>
<a name="ln3024"> </a>
<a name="ln3025">/// Get the next set of spell suggestions matching &quot;compl_pattern&quot;.</a>
<a name="ln3026">static void get_next_spell_completion(linenr_T lnum)</a>
<a name="ln3027">{</a>
<a name="ln3028">  char **matches;</a>
<a name="ln3029">  int num_matches = expand_spelling(lnum, compl_pattern, &amp;matches);</a>
<a name="ln3030">  if (num_matches &gt; 0) {</a>
<a name="ln3031">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln3032">  } else {</a>
<a name="ln3033">    xfree(matches);</a>
<a name="ln3034">  }</a>
<a name="ln3035">}</a>
<a name="ln3036"> </a>
<a name="ln3037">/// Return the next word or line from buffer &quot;ins_buf&quot; at position</a>
<a name="ln3038">/// &quot;cur_match_pos&quot; for completion.  The length of the match is set in &quot;len&quot;.</a>
<a name="ln3039">/// @param ins_buf        buffer being scanned</a>
<a name="ln3040">/// @param cur_match_pos  current match position</a>
<a name="ln3041">/// @param match_len</a>
<a name="ln3042">/// @param cont_s_ipos    next ^X&lt;&gt; will set initial_pos</a>
<a name="ln3043">static char *ins_compl_get_next_word_or_line(buf_T *ins_buf, pos_T *cur_match_pos, int *match_len,</a>
<a name="ln3044">                                             bool *cont_s_ipos)</a>
<a name="ln3045">{</a>
<a name="ln3046">  *match_len = 0;</a>
<a name="ln3047">  char *ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum) + cur_match_pos-&gt;col;</a>
<a name="ln3048">  int len;</a>
<a name="ln3049">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln3050">    if (compl_status_adding()) {</a>
<a name="ln3051">      if (cur_match_pos-&gt;lnum &gt;= ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3052">        return NULL;</a>
<a name="ln3053">      }</a>
<a name="ln3054">      ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3055">      if (!p_paste) {</a>
<a name="ln3056">        ptr = skipwhite(ptr);</a>
<a name="ln3057">      }</a>
<a name="ln3058">    }</a>
<a name="ln3059">    len = (int)strlen(ptr);</a>
<a name="ln3060">  } else {</a>
<a name="ln3061">    char *tmp_ptr = ptr;</a>
<a name="ln3062"> </a>
<a name="ln3063">    if (compl_status_adding() &amp;&amp; compl_length &lt;= (int)strlen(tmp_ptr)) {</a>
<a name="ln3064">      tmp_ptr += compl_length;</a>
<a name="ln3065">      // Skip if already inside a word.</a>
<a name="ln3066">      if (vim_iswordp(tmp_ptr)) {</a>
<a name="ln3067">        return NULL;</a>
<a name="ln3068">      }</a>
<a name="ln3069">      // Find start of next word.</a>
<a name="ln3070">      tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3071">    }</a>
<a name="ln3072">    // Find end of this word.</a>
<a name="ln3073">    tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3074">    len = (int)(tmp_ptr - ptr);</a>
<a name="ln3075"> </a>
<a name="ln3076">    if (compl_status_adding() &amp;&amp; len == compl_length) {</a>
<a name="ln3077">      if (cur_match_pos-&gt;lnum &lt; ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3078">        // Try next line, if any. the new word will be &quot;join&quot; as if the</a>
<a name="ln3079">        // normal command &quot;J&quot; was used. IOSIZE is always greater than</a>
<a name="ln3080">        // compl_length, so the next strncpy always works -- Acevedo</a>
<a name="ln3081">        strncpy(IObuff, ptr, (size_t)len);  // NOLINT(runtime/printf)</a>
<a name="ln3082">        ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3083">        tmp_ptr = ptr = skipwhite(ptr);</a>
<a name="ln3084">        // Find start of next word.</a>
<a name="ln3085">        tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3086">        // Find end of next word.</a>
<a name="ln3087">        tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3088">        if (tmp_ptr &gt; ptr) {</a>
<a name="ln3089">          if (*ptr != ')' &amp;&amp; IObuff[len - 1] != TAB) {</a>
<a name="ln3090">            if (IObuff[len - 1] != ' ') {</a>
<a name="ln3091">              IObuff[len++] = ' ';</a>
<a name="ln3092">            }</a>
<a name="ln3093">            // IObuf =~ &quot;\k.* &quot;, thus len &gt;= 2</a>
<a name="ln3094">            if (p_js</a>
<a name="ln3095">                &amp;&amp; (IObuff[len - 2] == '.'</a>
<a name="ln3096">                    || IObuff[len - 2] == '?'</a>
<a name="ln3097">                    || IObuff[len - 2] == '!')) {</a>
<a name="ln3098">              IObuff[len++] = ' ';</a>
<a name="ln3099">            }</a>
<a name="ln3100">          }</a>
<a name="ln3101">          // copy as much as possible of the new word</a>
<a name="ln3102">          if (tmp_ptr - ptr &gt;= IOSIZE - len) {</a>
<a name="ln3103">            tmp_ptr = ptr + IOSIZE - len - 1;</a>
<a name="ln3104">          }</a>
<a name="ln3105">          xstrlcpy(IObuff + len, ptr, (size_t)(IOSIZE - len));</a>
<a name="ln3106">          len += (int)(tmp_ptr - ptr);</a>
<a name="ln3107">          *cont_s_ipos = true;</a>
<a name="ln3108">        }</a>
<a name="ln3109">        IObuff[len] = NUL;</a>
<a name="ln3110">        ptr = IObuff;</a>
<a name="ln3111">      }</a>
<a name="ln3112">      if (len == compl_length) {</a>
<a name="ln3113">        return NULL;</a>
<a name="ln3114">      }</a>
<a name="ln3115">    }</a>
<a name="ln3116">  }</a>
<a name="ln3117"> </a>
<a name="ln3118">  *match_len = len;</a>
<a name="ln3119">  return ptr;</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122">/// Get the next set of words matching &quot;compl_pattern&quot; for default completion(s)</a>
<a name="ln3123">/// (normal ^P/^N and ^X^L).</a>
<a name="ln3124">/// Search for &quot;compl_pattern&quot; in the buffer &quot;st-&gt;ins_buf&quot; starting from the</a>
<a name="ln3125">/// position &quot;st-&gt;start_pos&quot; in the &quot;compl_direction&quot; direction. If</a>
<a name="ln3126">/// &quot;st-&gt;set_match_pos&quot; is true, then set the &quot;st-&gt;first_match_pos&quot; and</a>
<a name="ln3127">/// &quot;st-&gt;last_match_pos&quot;.</a>
<a name="ln3128">///</a>
<a name="ln3129">/// @return  OK if a new next match is found, otherwise FAIL.</a>
<a name="ln3130">static int get_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)</a>
<a name="ln3131">{</a>
<a name="ln3132">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln3133">  const int save_p_scs = p_scs;</a>
<a name="ln3134">  assert(st-&gt;ins_buf);</a>
<a name="ln3135">  if (st-&gt;ins_buf-&gt;b_p_inf) {</a>
<a name="ln3136">    p_scs = false;</a>
<a name="ln3137">  }</a>
<a name="ln3138"> </a>
<a name="ln3139">  // Buffers other than curbuf are scanned from the beginning or the</a>
<a name="ln3140">  // end but never from the middle, thus setting nowrapscan in this</a>
<a name="ln3141">  // buffers is a good idea, on the other hand, we always set</a>
<a name="ln3142">  // wrapscan for curbuf to avoid missing matches -- Acevedo,Webb</a>
<a name="ln3143">  const int save_p_ws = p_ws;</a>
<a name="ln3144">  if (st-&gt;ins_buf != curbuf) {</a>
<a name="ln3145">    p_ws = false;</a>
<a name="ln3146">  } else if (*st-&gt;e_cpt == '.') {</a>
<a name="ln3147">    p_ws = true;</a>
<a name="ln3148">  }</a>
<a name="ln3149">  bool looped_around = false;</a>
<a name="ln3150">  int found_new_match = FAIL;</a>
<a name="ln3151">  while (true) {</a>
<a name="ln3152">    bool cont_s_ipos = false;</a>
<a name="ln3153"> </a>
<a name="ln3154">    msg_silent++;  // Don't want messages for wrapscan.</a>
<a name="ln3155">    // ctrl_x_mode_line_or_eval() || word-wise search that</a>
<a name="ln3156">    // has added a word that was at the beginning of the line.</a>
<a name="ln3157">    if (ctrl_x_mode_line_or_eval() || (compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln3158">      found_new_match = search_for_exact_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3159">                                              compl_direction, compl_pattern);</a>
<a name="ln3160">    } else {</a>
<a name="ln3161">      found_new_match = searchit(NULL, st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3162">                                 NULL, compl_direction, compl_pattern, 1L,</a>
<a name="ln3163">                                 SEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);</a>
<a name="ln3164">    }</a>
<a name="ln3165">    msg_silent--;</a>
<a name="ln3166">    if (!compl_started || st-&gt;set_match_pos) {</a>
<a name="ln3167">      // set &quot;compl_started&quot; even on fail</a>
<a name="ln3168">      compl_started = true;</a>
<a name="ln3169">      st-&gt;first_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3170">      st-&gt;last_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3171">      st-&gt;set_match_pos = false;</a>
<a name="ln3172">    } else if (st-&gt;first_match_pos.lnum == st-&gt;last_match_pos.lnum</a>
<a name="ln3173">               &amp;&amp; st-&gt;first_match_pos.col == st-&gt;last_match_pos.col) {</a>
<a name="ln3174">      found_new_match = FAIL;</a>
<a name="ln3175">    } else if (compl_dir_forward()</a>
<a name="ln3176">               &amp;&amp; (st-&gt;prev_match_pos.lnum &gt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3177">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3178">                       &amp;&amp; st-&gt;prev_match_pos.col &gt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3179">      if (looped_around) {</a>
<a name="ln3180">        found_new_match = FAIL;</a>
<a name="ln3181">      } else {</a>
<a name="ln3182">        looped_around = true;</a>
<a name="ln3183">      }</a>
<a name="ln3184">    } else if (!compl_dir_forward()</a>
<a name="ln3185">               &amp;&amp; (st-&gt;prev_match_pos.lnum &lt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3186">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3187">                       &amp;&amp; st-&gt;prev_match_pos.col &lt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3188">      if (looped_around) {</a>
<a name="ln3189">        found_new_match = FAIL;</a>
<a name="ln3190">      } else {</a>
<a name="ln3191">        looped_around = true;</a>
<a name="ln3192">      }</a>
<a name="ln3193">    }</a>
<a name="ln3194">    st-&gt;prev_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3195">    if (found_new_match == FAIL) {</a>
<a name="ln3196">      break;</a>
<a name="ln3197">    }</a>
<a name="ln3198"> </a>
<a name="ln3199">    // when ADDING, the text before the cursor matches, skip it</a>
<a name="ln3200">    if (compl_status_adding() &amp;&amp; st-&gt;ins_buf == curbuf</a>
<a name="ln3201">        &amp;&amp; start_pos-&gt;lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3202">        &amp;&amp; start_pos-&gt;col == st-&gt;cur_match_pos-&gt;col) {</a>
<a name="ln3203">      continue;</a>
<a name="ln3204">    }</a>
<a name="ln3205">    int len;</a>
<a name="ln3206">    char *ptr = ins_compl_get_next_word_or_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3207">                                                &amp;len, &amp;cont_s_ipos);</a>
<a name="ln3208">    if (ptr == NULL) {</a>
<a name="ln3209">      continue;</a>
<a name="ln3210">    }</a>
<a name="ln3211">    if (ins_compl_add_infercase(ptr, len, p_ic,</a>
<a name="ln3212">                                st-&gt;ins_buf == curbuf ? NULL : st-&gt;ins_buf-&gt;b_sfname,</a>
<a name="ln3213">                                0, cont_s_ipos) != NOTDONE) {</a>
<a name="ln3214">      found_new_match = OK;</a>
<a name="ln3215">      break;</a>
<a name="ln3216">    }</a>
<a name="ln3217">  }</a>
<a name="ln3218">  p_scs = save_p_scs;</a>
<a name="ln3219">  p_ws = save_p_ws;</a>
<a name="ln3220"> </a>
<a name="ln3221">  return found_new_match;</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224">/// get the next set of completion matches for &quot;type&quot;.</a>
<a name="ln3225">/// @return  true if a new match is found, otherwise false.</a>
<a name="ln3226">static bool get_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)</a>
<a name="ln3227">{</a>
<a name="ln3228">  int found_new_match = FAIL;</a>
<a name="ln3229"> </a>
<a name="ln3230">  switch (type) {</a>
<a name="ln3231">  case -1:</a>
<a name="ln3232">    break;</a>
<a name="ln3233">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln3234">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln3235">    get_next_include_file_completion(type);</a>
<a name="ln3236">    break;</a>
<a name="ln3237"> </a>
<a name="ln3238">  case CTRL_X_DICTIONARY:</a>
<a name="ln3239">  case CTRL_X_THESAURUS:</a>
<a name="ln3240">    get_next_dict_tsr_completion(type, st-&gt;dict, st-&gt;dict_f);</a>
<a name="ln3241">    st-&gt;dict = NULL;</a>
<a name="ln3242">    break;</a>
<a name="ln3243"> </a>
<a name="ln3244">  case CTRL_X_TAGS:</a>
<a name="ln3245">    get_next_tag_completion();</a>
<a name="ln3246">    break;</a>
<a name="ln3247"> </a>
<a name="ln3248">  case CTRL_X_FILES:</a>
<a name="ln3249">    get_next_filename_completion();</a>
<a name="ln3250">    break;</a>
<a name="ln3251"> </a>
<a name="ln3252">  case CTRL_X_CMDLINE:</a>
<a name="ln3253">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln3254">    get_next_cmdline_completion();</a>
<a name="ln3255">    break;</a>
<a name="ln3256"> </a>
<a name="ln3257">  case CTRL_X_FUNCTION:</a>
<a name="ln3258">  case CTRL_X_OMNI:</a>
<a name="ln3259">    expand_by_function(type, compl_pattern);</a>
<a name="ln3260">    break;</a>
<a name="ln3261"> </a>
<a name="ln3262">  case CTRL_X_SPELL:</a>
<a name="ln3263">    get_next_spell_completion(st-&gt;first_match_pos.lnum);</a>
<a name="ln3264">    break;</a>
<a name="ln3265"> </a>
<a name="ln3266">  default:            // normal ^P/^N and ^X^L</a>
<a name="ln3267">    found_new_match = get_next_default_completion(st, ini);</a>
<a name="ln3268">    if (found_new_match == FAIL &amp;&amp; st-&gt;ins_buf == curbuf) {</a>
<a name="ln3269">      st-&gt;found_all = true;</a>
<a name="ln3270">    }</a>
<a name="ln3271">  }</a>
<a name="ln3272"> </a>
<a name="ln3273">  // check if compl_curr_match has changed, (e.g. other type of</a>
<a name="ln3274">  // expansion added something)</a>
<a name="ln3275">  if (type != 0 &amp;&amp; compl_curr_match != compl_old_match) {</a>
<a name="ln3276">    found_new_match = OK;</a>
<a name="ln3277">  }</a>
<a name="ln3278"> </a>
<a name="ln3279">  return found_new_match;</a>
<a name="ln3280">}</a>
<a name="ln3281"> </a>
<a name="ln3282">/// Get the next expansion(s), using &quot;compl_pattern&quot;.</a>
<a name="ln3283">/// The search starts at position &quot;ini&quot; in curbuf and in the direction</a>
<a name="ln3284">/// compl_direction.</a>
<a name="ln3285">/// When &quot;compl_started&quot; is false start at that position, otherwise continue</a>
<a name="ln3286">/// where we stopped searching before.</a>
<a name="ln3287">/// This may return before finding all the matches.</a>
<a name="ln3288">/// Return the total number of matches or -1 if still unknown -- Acevedo</a>
<a name="ln3289">static int ins_compl_get_exp(pos_T *ini)</a>
<a name="ln3290">{</a>
<a name="ln3291">  static ins_compl_next_state_T st;</a>
<a name="ln3292">  static bool st_cleared = false;</a>
<a name="ln3293">  int i;</a>
<a name="ln3294">  int found_new_match;</a>
<a name="ln3295">  int type = ctrl_x_mode;</a>
<a name="ln3296"> </a>
<a name="ln3297">  assert(curbuf != NULL);</a>
<a name="ln3298"> </a>
<a name="ln3299">  if (!compl_started) {</a>
<a name="ln3300">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln3301">      buf-&gt;b_scanned = false;</a>
<a name="ln3302">    }</a>
<a name="ln3303">    if (!st_cleared) {</a>
<a name="ln3304">      CLEAR_FIELD(st);</a>
<a name="ln3305">      st_cleared = true;</a>
<a name="ln3306">    }</a>
<a name="ln3307">    st.found_all = false;</a>
<a name="ln3308">    st.ins_buf = curbuf;</a>
<a name="ln3309">    xfree(st.e_cpt_copy);</a>
<a name="ln3310">    // Make a copy of 'complete', in case the buffer is wiped out.</a>
<a name="ln3311">    st.e_cpt_copy = xstrdup((compl_cont_status &amp; CONT_LOCAL) ? &quot;.&quot; : curbuf-&gt;b_p_cpt);</a>
<a name="ln3312">    st.e_cpt = st.e_cpt_copy == NULL ? &quot;&quot; : st.e_cpt_copy;</a>
<a name="ln3313">    st.last_match_pos = st.first_match_pos = *ini;</a>
<a name="ln3314">  } else if (st.ins_buf != curbuf &amp;&amp; !buf_valid(st.ins_buf)) {</a>
<a name="ln3315">    st.ins_buf = curbuf;  // In case the buffer was wiped out.</a>
<a name="ln3316">  }</a>
<a name="ln3317">  assert(st.ins_buf != NULL);</a>
<a name="ln3318"> </a>
<a name="ln3319">  compl_old_match = compl_curr_match;   // remember the last current match</a>
<a name="ln3320">  st.cur_match_pos = compl_dir_forward() ? &amp;st.last_match_pos : &amp;st.first_match_pos;</a>
<a name="ln3321"> </a>
<a name="ln3322">  // For ^N/^P loop over all the flags/windows/buffers in 'complete'</a>
<a name="ln3323">  while (true) {</a>
<a name="ln3324">    found_new_match = FAIL;</a>
<a name="ln3325">    st.set_match_pos = false;</a>
<a name="ln3326"> </a>
<a name="ln3327">    // For ^N/^P pick a new entry from e_cpt if compl_started is off,</a>
<a name="ln3328">    // or if found_all says this entry is done.  For ^X^L only use the</a>
<a name="ln3329">    // entries from 'complete' that look in loaded buffers.</a>
<a name="ln3330">    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3331">        &amp;&amp; (!compl_started || st.found_all)) {</a>
<a name="ln3332">      int status = process_next_cpt_value(&amp;st, &amp;type, ini);</a>
<a name="ln3333">      if (status == INS_COMPL_CPT_END) {</a>
<a name="ln3334">        break;</a>
<a name="ln3335">      }</a>
<a name="ln3336">      if (status == INS_COMPL_CPT_CONT) {</a>
<a name="ln3337">        continue;</a>
<a name="ln3338">      }</a>
<a name="ln3339">    }</a>
<a name="ln3340"> </a>
<a name="ln3341">    // If complete() was called then compl_pattern has been reset.</a>
<a name="ln3342">    // The following won't work then, bail out.</a>
<a name="ln3343">    if (compl_pattern == NULL) {</a>
<a name="ln3344">      break;</a>
<a name="ln3345">    }</a>
<a name="ln3346"> </a>
<a name="ln3347">    // get the next set of completion matches</a>
<a name="ln3348">    found_new_match = get_next_completion_match(type, &amp;st, ini);</a>
<a name="ln3349"> </a>
<a name="ln3350">    // break the loop for specialized modes (use 'complete' just for the</a>
<a name="ln3351">    // generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new match</a>
<a name="ln3352">    if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3353">        || found_new_match != FAIL) {</a>
<a name="ln3354">      if (got_int) {</a>
<a name="ln3355">        break;</a>
<a name="ln3356">      }</a>
<a name="ln3357">      // Fill the popup menu as soon as possible.</a>
<a name="ln3358">      if (type != -1) {</a>
<a name="ln3359">        ins_compl_check_keys(0, false);</a>
<a name="ln3360">      }</a>
<a name="ln3361"> </a>
<a name="ln3362">      if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3363">          || compl_interrupted) {</a>
<a name="ln3364">        break;</a>
<a name="ln3365">      }</a>
<a name="ln3366">      compl_started = true;</a>
<a name="ln3367">    } else {</a>
<a name="ln3368">      // Mark a buffer scanned when it has been scanned completely</a>
<a name="ln3369">      if (type == 0 || type == CTRL_X_PATH_PATTERNS) {</a>
<a name="ln3370">        assert(st.ins_buf);</a>
<a name="ln3371">        st.ins_buf-&gt;b_scanned = true;</a>
<a name="ln3372">      }</a>
<a name="ln3373"> </a>
<a name="ln3374">      compl_started = false;</a>
<a name="ln3375">    }</a>
<a name="ln3376">  }</a>
<a name="ln3377">  compl_started = true;</a>
<a name="ln3378"> </a>
<a name="ln3379">  if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3380">      &amp;&amp; *st.e_cpt == NUL) {  // Got to end of 'complete'</a>
<a name="ln3381">    found_new_match = FAIL;</a>
<a name="ln3382">  }</a>
<a name="ln3383"> </a>
<a name="ln3384">  i = -1;               // total of matches, unknown</a>
<a name="ln3385">  if (found_new_match == FAIL</a>
<a name="ln3386">      || (ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())) {</a>
<a name="ln3387">    i = ins_compl_make_cyclic();</a>
<a name="ln3388">  }</a>
<a name="ln3389"> </a>
<a name="ln3390">  if (compl_old_match != NULL) {</a>
<a name="ln3391">    // If several matches were added (FORWARD) or the search failed and has</a>
<a name="ln3392">    // just been made cyclic then we have to move compl_curr_match to the</a>
<a name="ln3393">    // next or previous entry (if any) -- Acevedo</a>
<a name="ln3394">    compl_curr_match = compl_dir_forward()</a>
<a name="ln3395">                        ? compl_old_match-&gt;cp_next</a>
<a name="ln3396">                        : compl_old_match-&gt;cp_prev;</a>
<a name="ln3397">    if (compl_curr_match == NULL) {</a>
<a name="ln3398">      compl_curr_match = compl_old_match;</a>
<a name="ln3399">    }</a>
<a name="ln3400">  }</a>
<a name="ln3401">  may_trigger_modechanged();</a>
<a name="ln3402"> </a>
<a name="ln3403">  return i;</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406">/// Update &quot;compl_shown_match&quot; to the actually shown match, it may differ when</a>
<a name="ln3407">/// &quot;compl_leader&quot; is used to omit some of the matches.</a>
<a name="ln3408">static void ins_compl_update_shown_match(void)</a>
<a name="ln3409">{</a>
<a name="ln3410">  while (!ins_compl_equal(compl_shown_match,</a>
<a name="ln3411">                          compl_leader, strlen(compl_leader))</a>
<a name="ln3412">         &amp;&amp; compl_shown_match-&gt;cp_next != NULL</a>
<a name="ln3413">         &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_next)) {</a>
<a name="ln3414">    compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3415">  }</a>
<a name="ln3416"> </a>
<a name="ln3417">  // If we didn't find it searching forward, and compl_shows_dir is</a>
<a name="ln3418">  // backward, find the last match.</a>
<a name="ln3419">  if (compl_shows_dir_backward()</a>
<a name="ln3420">      &amp;&amp; !ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3421">      &amp;&amp; (compl_shown_match-&gt;cp_next == NULL</a>
<a name="ln3422">          || is_first_match(compl_shown_match-&gt;cp_next))) {</a>
<a name="ln3423">    while (!ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3424">           &amp;&amp; compl_shown_match-&gt;cp_prev != NULL</a>
<a name="ln3425">           &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_prev)) {</a>
<a name="ln3426">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3427">    }</a>
<a name="ln3428">  }</a>
<a name="ln3429">}</a>
<a name="ln3430"> </a>
<a name="ln3431">/// Delete the old text being completed.</a>
<a name="ln3432">void ins_compl_delete(void)</a>
<a name="ln3433">{</a>
<a name="ln3434">  int col;</a>
<a name="ln3435"> </a>
<a name="ln3436">  // In insert mode: Delete the typed part.</a>
<a name="ln3437">  // In replace mode: Put the old characters back, if any.</a>
<a name="ln3438">  col = compl_col + (compl_status_adding() ? compl_length : 0);</a>
<a name="ln3439">  if ((int)curwin-&gt;w_cursor.col &gt; col) {</a>
<a name="ln3440">    if (stop_arrow() == FAIL) {</a>
<a name="ln3441">      return;</a>
<a name="ln3442">    }</a>
<a name="ln3443">    backspace_until_column(col);</a>
<a name="ln3444">  }</a>
<a name="ln3445"> </a>
<a name="ln3446">  // TODO(vim): is this sufficient for redrawing?  Redrawing everything</a>
<a name="ln3447">  // causes flicker, thus we can't do that.</a>
<a name="ln3448">  changed_cline_bef_curs(curwin);</a>
<a name="ln3449">  // clear v:completed_item</a>
<a name="ln3450">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln3451">}</a>
<a name="ln3452"> </a>
<a name="ln3453">/// Insert the new text being completed.</a>
<a name="ln3454">/// &quot;in_compl_func&quot; is true when called from complete_check().</a>
<a name="ln3455">void ins_compl_insert(bool in_compl_func)</a>
<a name="ln3456">{</a>
<a name="ln3457">  ins_bytes(compl_shown_match-&gt;cp_str + get_compl_len());</a>
<a name="ln3458">  compl_used_match = !match_at_original_text(compl_shown_match);</a>
<a name="ln3459"> </a>
<a name="ln3460">  dict_T *dict = ins_compl_dict_alloc(compl_shown_match);</a>
<a name="ln3461">  set_vim_var_dict(VV_COMPLETED_ITEM, dict);</a>
<a name="ln3462">  if (!in_compl_func) {</a>
<a name="ln3463">    compl_curr_match = compl_shown_match;</a>
<a name="ln3464">  }</a>
<a name="ln3465">}</a>
<a name="ln3466"> </a>
<a name="ln3467">/// show the file name for the completion match (if any).  Truncate the file</a>
<a name="ln3468">/// name to avoid a wait for return.</a>
<a name="ln3469">static void ins_compl_show_filename(void)</a>
<a name="ln3470">{</a>
<a name="ln3471">  char *const lead = _(&quot;match in file&quot;);</a>
<a name="ln3472">  int space = sc_col - vim_strsize(lead) - 2;</a>
<a name="ln3473">  if (space &lt;= 0) {</a>
<a name="ln3474">    return;</a>
<a name="ln3475">  }</a>
<a name="ln3476"> </a>
<a name="ln3477">  // We need the tail that fits.  With double-byte encoding going</a>
<a name="ln3478">  // back from the end is very slow, thus go from the start and keep</a>
<a name="ln3479">  // the text that fits in &quot;space&quot; between &quot;s&quot; and &quot;e&quot;.</a>
<a name="ln3480">  char *s;</a>
<a name="ln3481">  char *e;</a>
<a name="ln3482">  for (s = e = compl_shown_match-&gt;cp_fname; *e != NUL; MB_PTR_ADV(e)) {</a>
<a name="ln3483">    space -= ptr2cells(e);</a>
<a name="ln3484">    while (space &lt; 0) {</a>
<a name="ln3485">      space += ptr2cells(s);</a>
<a name="ln3486">      MB_PTR_ADV(s);</a>
<a name="ln3487">    }</a>
<a name="ln3488">  }</a>
<a name="ln3489">  msg_hist_off = true;</a>
<a name="ln3490">  vim_snprintf(IObuff, IOSIZE, &quot;%s %s%s&quot;, lead,</a>
<a name="ln3491">               s &gt; compl_shown_match-&gt;cp_fname ? &quot;&lt;&quot; : &quot;&quot;, s);</a>
<a name="ln3492">  msg(IObuff, 0);</a>
<a name="ln3493">  msg_hist_off = false;</a>
<a name="ln3494">  redraw_cmdline = false;  // don't overwrite!</a>
<a name="ln3495">}</a>
<a name="ln3496"> </a>
<a name="ln3497">/// Find the next set of matches for completion. Repeat the completion &quot;todo&quot;</a>
<a name="ln3498">/// times.  The number of matches found is returned in 'num_matches'.</a>
<a name="ln3499">///</a>
<a name="ln3500">/// @param allow_get_expansion  If true, then ins_compl_get_exp() may be called to</a>
<a name="ln3501">///                             get more completions.</a>
<a name="ln3502">///                             If false, then do nothing when there are no more</a>
<a name="ln3503">///                             completions in the given direction.</a>
<a name="ln3504">/// @param todo  repeat completion this many times</a>
<a name="ln3505">/// @param advance  If true, then completion will move to the first match.</a>
<a name="ln3506">///                 Otherwise, the original text will be shown.</a>
<a name="ln3507">///</a>
<a name="ln3508">/// @return  OK on success and -1 if the number of matches are unknown.</a>
<a name="ln3509">static int find_next_completion_match(bool allow_get_expansion, int todo, bool advance,</a>
<a name="ln3510">                                      int *num_matches)</a>
<a name="ln3511">{</a>
<a name="ln3512">  bool found_end = false;</a>
<a name="ln3513">  compl_T *found_compl = NULL;</a>
<a name="ln3514"> </a>
<a name="ln3515">  while (--todo &gt;= 0) {</a>
<a name="ln3516">    if (compl_shows_dir_forward() &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3517">      compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3518">      found_end = (compl_first_match != NULL</a>
<a name="ln3519">                   &amp;&amp; (is_first_match(compl_shown_match-&gt;cp_next)</a>
<a name="ln3520">                       || is_first_match(compl_shown_match)));</a>
<a name="ln3521">    } else if (compl_shows_dir_backward()</a>
<a name="ln3522">               &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3523">      found_end = is_first_match(compl_shown_match);</a>
<a name="ln3524">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3525">      found_end |= is_first_match(compl_shown_match);</a>
<a name="ln3526">    } else {</a>
<a name="ln3527">      if (!allow_get_expansion) {</a>
<a name="ln3528">        if (advance) {</a>
<a name="ln3529">          if (compl_shows_dir_backward()) {</a>
<a name="ln3530">            compl_pending -= todo + 1;</a>
<a name="ln3531">          } else {</a>
<a name="ln3532">            compl_pending += todo + 1;</a>
<a name="ln3533">          }</a>
<a name="ln3534">        }</a>
<a name="ln3535">        return -1;</a>
<a name="ln3536">      }</a>
<a name="ln3537"> </a>
<a name="ln3538">      if (!compl_no_select &amp;&amp; advance) {</a>
<a name="ln3539">        if (compl_shows_dir_backward()) {</a>
<a name="ln3540">          compl_pending--;</a>
<a name="ln3541">        } else {</a>
<a name="ln3542">          compl_pending++;</a>
<a name="ln3543">        }</a>
<a name="ln3544">      }</a>
<a name="ln3545"> </a>
<a name="ln3546">      // Find matches.</a>
<a name="ln3547">      *num_matches = ins_compl_get_exp(&amp;compl_startpos);</a>
<a name="ln3548"> </a>
<a name="ln3549">      // handle any pending completions</a>
<a name="ln3550">      while (compl_pending != 0 &amp;&amp; compl_direction == compl_shows_dir</a>
<a name="ln3551">             &amp;&amp; advance) {</a>
<a name="ln3552">        if (compl_pending &gt; 0 &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3553">          compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3554">          compl_pending--;</a>
<a name="ln3555">        }</a>
<a name="ln3556">        if (compl_pending &lt; 0 &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3557">          compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3558">          compl_pending++;</a>
<a name="ln3559">        } else {</a>
<a name="ln3560">          break;</a>
<a name="ln3561">        }</a>
<a name="ln3562">      }</a>
<a name="ln3563">      found_end = false;</a>
<a name="ln3564">    }</a>
<a name="ln3565">    if (!match_at_original_text(compl_shown_match)</a>
<a name="ln3566">        &amp;&amp; compl_leader != NULL</a>
<a name="ln3567">        &amp;&amp; !ins_compl_equal(compl_shown_match,</a>
<a name="ln3568">                            compl_leader, strlen(compl_leader))) {</a>
<a name="ln3569">      todo++;</a>
<a name="ln3570">    } else {</a>
<a name="ln3571">      // Remember a matching item.</a>
<a name="ln3572">      found_compl = compl_shown_match;</a>
<a name="ln3573">    }</a>
<a name="ln3574"> </a>
<a name="ln3575">    // Stop at the end of the list when we found a usable match.</a>
<a name="ln3576">    if (found_end) {</a>
<a name="ln3577">      if (found_compl != NULL) {</a>
<a name="ln3578">        compl_shown_match = found_compl;</a>
<a name="ln3579">        break;</a>
<a name="ln3580">      }</a>
<a name="ln3581">      todo = 1;             // use first usable match after wrapping around</a>
<a name="ln3582">    }</a>
<a name="ln3583">  }</a>
<a name="ln3584"> </a>
<a name="ln3585">  return OK;</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">/// Fill in the next completion in the current direction.</a>
<a name="ln3589">/// If &quot;allow_get_expansion&quot; is true, then we may call ins_compl_get_exp() to</a>
<a name="ln3590">/// get more completions.  If it is false, then we just do nothing when there</a>
<a name="ln3591">/// are no more completions in a given direction.  The latter case is used when</a>
<a name="ln3592">/// we are still in the middle of finding completions, to allow browsing</a>
<a name="ln3593">/// through the ones found so far.</a>
<a name="ln3594">/// @return  the total number of matches, or -1 if still unknown -- webb.</a>
<a name="ln3595">///</a>
<a name="ln3596">/// compl_curr_match is currently being used by ins_compl_get_exp(), so we use</a>
<a name="ln3597">/// compl_shown_match here.</a>
<a name="ln3598">///</a>
<a name="ln3599">/// Note that this function may be called recursively once only.  First with</a>
<a name="ln3600">/// &quot;allow_get_expansion&quot; true, which calls ins_compl_get_exp(), which in turn</a>
<a name="ln3601">/// calls this function with &quot;allow_get_expansion&quot; false.</a>
<a name="ln3602">///</a>
<a name="ln3603">/// @param count          Repeat completion this many times; should be at least 1</a>
<a name="ln3604">/// @param insert_match   Insert the newly selected match</a>
<a name="ln3605">/// @param in_compl_func  Called from complete_check()</a>
<a name="ln3606">static int ins_compl_next(bool allow_get_expansion, int count, bool insert_match,</a>
<a name="ln3607">                          bool in_compl_func)</a>
<a name="ln3608">{</a>
<a name="ln3609">  int num_matches = -1;</a>
<a name="ln3610">  int todo = count;</a>
<a name="ln3611">  const bool started = compl_started;</a>
<a name="ln3612">  buf_T *const orig_curbuf = curbuf;</a>
<a name="ln3613"> </a>
<a name="ln3614">  // When user complete function return -1 for findstart which is next</a>
<a name="ln3615">  // time of 'always', compl_shown_match become NULL.</a>
<a name="ln3616">  if (compl_shown_match == NULL) {</a>
<a name="ln3617">    return -1;</a>
<a name="ln3618">  }</a>
<a name="ln3619"> </a>
<a name="ln3620">  if (compl_leader != NULL &amp;&amp; !match_at_original_text(compl_shown_match)) {</a>
<a name="ln3621">    // Update &quot;compl_shown_match&quot; to the actually shown match</a>
<a name="ln3622">    ins_compl_update_shown_match();</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  if (allow_get_expansion &amp;&amp; insert_match</a>
<a name="ln3626">      &amp;&amp; (!(compl_get_longest || compl_restarting) || compl_used_match)) {</a>
<a name="ln3627">    // Delete old text to be replaced</a>
<a name="ln3628">    ins_compl_delete();</a>
<a name="ln3629">  }</a>
<a name="ln3630"> </a>
<a name="ln3631">  // When finding the longest common text we stick at the original text,</a>
<a name="ln3632">  // don't let CTRL-N or CTRL-P move to the first match.</a>
<a name="ln3633">  bool advance = count != 1 || !allow_get_expansion || !compl_get_longest;</a>
<a name="ln3634"> </a>
<a name="ln3635">  // When restarting the search don't insert the first match either.</a>
<a name="ln3636">  if (compl_restarting) {</a>
<a name="ln3637">    advance = false;</a>
<a name="ln3638">    compl_restarting = false;</a>
<a name="ln3639">  }</a>
<a name="ln3640"> </a>
<a name="ln3641">  // Repeat this for when &lt;PageUp&gt; or &lt;PageDown&gt; is typed.  But don't wrap</a>
<a name="ln3642">  // around.</a>
<a name="ln3643">  if (find_next_completion_match(allow_get_expansion, todo, advance,</a>
<a name="ln3644">                                 &amp;num_matches) == -1) {</a>
<a name="ln3645">    return -1;</a>
<a name="ln3646">  }</a>
<a name="ln3647"> </a>
<a name="ln3648">  if (curbuf != orig_curbuf) {</a>
<a name="ln3649">    // In case some completion function switched buffer, don't want to</a>
<a name="ln3650">    // insert the completion elsewhere.</a>
<a name="ln3651">    return -1;</a>
<a name="ln3652">  }</a>
<a name="ln3653"> </a>
<a name="ln3654">  // Insert the text of the new completion, or the compl_leader.</a>
<a name="ln3655">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3656">    ins_bytes(compl_orig_text + get_compl_len());</a>
<a name="ln3657">    compl_used_match = false;</a>
<a name="ln3658">  } else if (insert_match) {</a>
<a name="ln3659">    if (!compl_get_longest || compl_used_match) {</a>
<a name="ln3660">      ins_compl_insert(in_compl_func);</a>
<a name="ln3661">    } else {</a>
<a name="ln3662">      ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln3663">    }</a>
<a name="ln3664">  } else {</a>
<a name="ln3665">    compl_used_match = false;</a>
<a name="ln3666">  }</a>
<a name="ln3667"> </a>
<a name="ln3668">  if (!allow_get_expansion) {</a>
<a name="ln3669">    // redraw to show the user what was inserted</a>
<a name="ln3670">    update_screen();  // TODO(bfredl): no!</a>
<a name="ln3671"> </a>
<a name="ln3672">    // display the updated popup menu</a>
<a name="ln3673">    ins_compl_show_pum();</a>
<a name="ln3674"> </a>
<a name="ln3675">    // Delete old text to be replaced, since we're still searching and</a>
<a name="ln3676">    // don't want to match ourselves!</a>
<a name="ln3677">    ins_compl_delete();</a>
<a name="ln3678">  }</a>
<a name="ln3679"> </a>
<a name="ln3680">  // Enter will select a match when the match wasn't inserted and the popup</a>
<a name="ln3681">  // menu is visible.</a>
<a name="ln3682">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3683">    compl_enter_selects = true;</a>
<a name="ln3684">  } else {</a>
<a name="ln3685">    compl_enter_selects = !insert_match &amp;&amp; compl_match_array != NULL;</a>
<a name="ln3686">  }</a>
<a name="ln3687"> </a>
<a name="ln3688">  // Show the file name for the match (if any)</a>
<a name="ln3689">  if (compl_shown_match-&gt;cp_fname != NULL) {</a>
<a name="ln3690">    ins_compl_show_filename();</a>
<a name="ln3691">  }</a>
<a name="ln3692"> </a>
<a name="ln3693">  return num_matches;</a>
<a name="ln3694">}</a>
<a name="ln3695"> </a>
<a name="ln3696">/// Call this while finding completions, to check whether the user has hit a key</a>
<a name="ln3697">/// that should change the currently displayed completion, or exit completion</a>
<a name="ln3698">/// mode.  Also, when compl_pending is not zero, show a completion as soon as</a>
<a name="ln3699">/// possible. -- webb</a>
<a name="ln3700">///</a>
<a name="ln3701">/// @param frequency      specifies out of how many calls we actually check.</a>
<a name="ln3702">/// @param in_compl_func  true when called from complete_check(), don't set</a>
<a name="ln3703">///                       compl_curr_match.</a>
<a name="ln3704">void ins_compl_check_keys(int frequency, bool in_compl_func)</a>
<a name="ln3705">{</a>
<a name="ln3706">  static int count = 0;</a>
<a name="ln3707"> </a>
<a name="ln3708">  // Don't check when reading keys from a script, :normal or feedkeys().</a>
<a name="ln3709">  // That would break the test scripts.  But do check for keys when called</a>
<a name="ln3710">  // from complete_check().</a>
<a name="ln3711">  if (!in_compl_func &amp;&amp; (using_script() || ex_normal_busy)) {</a>
<a name="ln3712">    return;</a>
<a name="ln3713">  }</a>
<a name="ln3714"> </a>
<a name="ln3715">  // Only do this at regular intervals</a>
<a name="ln3716">  if (++count &lt; frequency) {</a>
<a name="ln3717">    return;</a>
<a name="ln3718">  }</a>
<a name="ln3719">  count = 0;</a>
<a name="ln3720"> </a>
<a name="ln3721">  // Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()</a>
<a name="ln3722">  // can't do its work correctly.</a>
<a name="ln3723">  int c = vpeekc_any();</a>
<a name="ln3724">  if (c != NUL) {</a>
<a name="ln3725">    if (vim_is_ctrl_x_key(c) &amp;&amp; c != Ctrl_X &amp;&amp; c != Ctrl_R) {</a>
<a name="ln3726">      c = safe_vgetc();         // Eat the character</a>
<a name="ln3727">      compl_shows_dir = ins_compl_key2dir(c);</a>
<a name="ln3728">      (void)ins_compl_next(false, ins_compl_key2count(c),</a>
<a name="ln3729">                           c != K_UP &amp;&amp; c != K_DOWN, in_compl_func);</a>
<a name="ln3730">    } else {</a>
<a name="ln3731">      // Need to get the character to have KeyTyped set.  We'll put it</a>
<a name="ln3732">      // back with vungetc() below.  But skip K_IGNORE.</a>
<a name="ln3733">      c = safe_vgetc();</a>
<a name="ln3734">      if (c != K_IGNORE) {</a>
<a name="ln3735">        // Don't interrupt completion when the character wasn't typed,</a>
<a name="ln3736">        // e.g., when doing @q to replay keys.</a>
<a name="ln3737">        if (c != Ctrl_R &amp;&amp; KeyTyped) {</a>
<a name="ln3738">          compl_interrupted = true;</a>
<a name="ln3739">        }</a>
<a name="ln3740"> </a>
<a name="ln3741">        vungetc(c);</a>
<a name="ln3742">      }</a>
<a name="ln3743">    }</a>
<a name="ln3744">  }</a>
<a name="ln3745">  if (compl_pending != 0 &amp;&amp; !got_int &amp;&amp; !compl_no_insert) {</a>
<a name="ln3746">    int todo = compl_pending &gt; 0 ? compl_pending : -compl_pending;</a>
<a name="ln3747"> </a>
<a name="ln3748">    compl_pending = 0;</a>
<a name="ln3749">    (void)ins_compl_next(false, todo, true, in_compl_func);</a>
<a name="ln3750">  }</a>
<a name="ln3751">}</a>
<a name="ln3752"> </a>
<a name="ln3753">/// Decide the direction of Insert mode complete from the key typed.</a>
<a name="ln3754">/// Returns BACKWARD or FORWARD.</a>
<a name="ln3755">static int ins_compl_key2dir(int c)</a>
<a name="ln3756">{</a>
<a name="ln3757">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3758">    return pum_want.item &lt; pum_selected_item ? BACKWARD : FORWARD;</a>
<a name="ln3759">  }</a>
<a name="ln3760">  if (c == Ctrl_P || c == Ctrl_L</a>
<a name="ln3761">      || c == K_PAGEUP || c == K_KPAGEUP</a>
<a name="ln3762">      || c == K_S_UP || c == K_UP) {</a>
<a name="ln3763">    return BACKWARD;</a>
<a name="ln3764">  }</a>
<a name="ln3765">  return FORWARD;</a>
<a name="ln3766">}</a>
<a name="ln3767"> </a>
<a name="ln3768">/// Check that &quot;c&quot; is a valid completion key only while the popup menu is shown</a>
<a name="ln3769">///</a>
<a name="ln3770">/// @param  c  character to check</a>
<a name="ln3771">static bool ins_compl_pum_key(int c)</a>
<a name="ln3772">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3773">{</a>
<a name="ln3774">  return pum_visible() &amp;&amp; (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP</a>
<a name="ln3775">                           || c == K_PAGEDOWN || c == K_KPAGEDOWN</a>
<a name="ln3776">                           || c == K_S_DOWN || c == K_UP || c == K_DOWN);</a>
<a name="ln3777">}</a>
<a name="ln3778"> </a>
<a name="ln3779">/// Decide the number of completions to move forward.</a>
<a name="ln3780">/// Returns 1 for most keys, height of the popup menu for page-up/down keys.</a>
<a name="ln3781">static int ins_compl_key2count(int c)</a>
<a name="ln3782">{</a>
<a name="ln3783">  int h;</a>
<a name="ln3784"> </a>
<a name="ln3785">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3786">    int offset = pum_want.item - pum_selected_item;</a>
<a name="ln3787">    return abs(offset);</a>
<a name="ln3788">  }</a>
<a name="ln3789"> </a>
<a name="ln3790">  if (ins_compl_pum_key(c) &amp;&amp; c != K_UP &amp;&amp; c != K_DOWN) {</a>
<a name="ln3791">    h = pum_get_height();</a>
<a name="ln3792">    if (h &gt; 3) {</a>
<a name="ln3793">      h -= 2;       // keep some context</a>
<a name="ln3794">    }</a>
<a name="ln3795">    return h;</a>
<a name="ln3796">  }</a>
<a name="ln3797">  return 1;</a>
<a name="ln3798">}</a>
<a name="ln3799"> </a>
<a name="ln3800">/// Check that completion with &quot;c&quot; should insert the match, false if only</a>
<a name="ln3801">/// to change the currently selected completion.</a>
<a name="ln3802">///</a>
<a name="ln3803">/// @param  c  character to check</a>
<a name="ln3804">static bool ins_compl_use_match(int c)</a>
<a name="ln3805">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3806">{</a>
<a name="ln3807">  switch (c) {</a>
<a name="ln3808">  case K_UP:</a>
<a name="ln3809">  case K_DOWN:</a>
<a name="ln3810">  case K_PAGEDOWN:</a>
<a name="ln3811">  case K_KPAGEDOWN:</a>
<a name="ln3812">  case K_S_DOWN:</a>
<a name="ln3813">  case K_PAGEUP:</a>
<a name="ln3814">  case K_KPAGEUP:</a>
<a name="ln3815">  case K_S_UP:</a>
<a name="ln3816">    return false;</a>
<a name="ln3817">  case K_EVENT:</a>
<a name="ln3818">  case K_COMMAND:</a>
<a name="ln3819">  case K_LUA:</a>
<a name="ln3820">    return pum_want.active &amp;&amp; pum_want.insert;</a>
<a name="ln3821">  }</a>
<a name="ln3822">  return true;</a>
<a name="ln3823">}</a>
<a name="ln3824"> </a>
<a name="ln3825">/// Get the pattern, column and length for normal completion (CTRL-N CTRL-P</a>
<a name="ln3826">/// completion)</a>
<a name="ln3827">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3828">/// Uses the global variables: compl_cont_status and ctrl_x_mode</a>
<a name="ln3829">static int get_normal_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3830">{</a>
<a name="ln3831">  if ((compl_cont_status &amp; CONT_SOL) || ctrl_x_mode_path_defines()) {</a>
<a name="ln3832">    if (!compl_status_adding()) {</a>
<a name="ln3833">      while (--startcol &gt;= 0 &amp;&amp; vim_isIDc((uint8_t)line[startcol])) {}</a>
<a name="ln3834">      compl_col += ++startcol;</a>
<a name="ln3835">      compl_length = curs_col - startcol;</a>
<a name="ln3836">    }</a>
<a name="ln3837">    if (p_ic) {</a>
<a name="ln3838">      compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3839">    } else {</a>
<a name="ln3840">      compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3841">    }</a>
<a name="ln3842">  } else if (compl_status_adding()) {</a>
<a name="ln3843">    char *prefix = &quot;\\&lt;&quot;;</a>
<a name="ln3844"> </a>
<a name="ln3845">    // we need up to 2 extra chars for the prefix</a>
<a name="ln3846">    compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3847">    if (!vim_iswordp(line + compl_col)</a>
<a name="ln3848">        || (compl_col &gt; 0</a>
<a name="ln3849">            &amp;&amp; (vim_iswordp(mb_prevptr(line, line + compl_col))))) {</a>
<a name="ln3850">      prefix = &quot;&quot;;</a>
<a name="ln3851">    }</a>
<a name="ln3852">    STRCPY(compl_pattern, prefix);</a>
<a name="ln3853">    (void)quote_meta(compl_pattern + strlen(prefix),</a>
<a name="ln3854">                     line + compl_col, compl_length);</a>
<a name="ln3855">  } else if (--startcol &lt; 0</a>
<a name="ln3856">             || !vim_iswordp(mb_prevptr(line, line + startcol + 1))) {</a>
<a name="ln3857">    // Match any word of at least two chars</a>
<a name="ln3858">    compl_pattern = xstrdup(&quot;\\&lt;\\k\\k&quot;);</a>
<a name="ln3859">    compl_col += curs_col;</a>
<a name="ln3860">    compl_length = 0;</a>
<a name="ln3861">  } else {</a>
<a name="ln3862">    // Search the point of change class of multibyte character</a>
<a name="ln3863">    // or not a word single byte character backward.</a>
<a name="ln3864">    startcol -= utf_head_off(line, line + startcol);</a>
<a name="ln3865">    int base_class = mb_get_class(line + startcol);</a>
<a name="ln3866">    while (--startcol &gt;= 0) {</a>
<a name="ln3867">      int head_off = utf_head_off(line, line + startcol);</a>
<a name="ln3868">      if (base_class != mb_get_class(line + startcol - head_off)) {</a>
<a name="ln3869">        break;</a>
<a name="ln3870">      }</a>
<a name="ln3871">      startcol -= head_off;</a>
<a name="ln3872">    }</a>
<a name="ln3873">    compl_col += ++startcol;</a>
<a name="ln3874">    compl_length = (int)curs_col - startcol;</a>
<a name="ln3875">    if (compl_length == 1) {</a>
<a name="ln3876">      // Only match word with at least two chars -- webb</a>
<a name="ln3877">      // there's no need to call quote_meta,</a>
<a name="ln3878">      // xmalloc(7) is enough  -- Acevedo</a>
<a name="ln3879">      compl_pattern = xmalloc(7);</a>
<a name="ln3880">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3881">      (void)quote_meta(compl_pattern + 2, line + compl_col, 1);</a>
<a name="ln3882">      STRCAT(compl_pattern, &quot;\\k&quot;);</a>
<a name="ln3883">    } else {</a>
<a name="ln3884">      compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3885">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3886">      (void)quote_meta(compl_pattern + 2, line + compl_col, compl_length);</a>
<a name="ln3887">    }</a>
<a name="ln3888">  }</a>
<a name="ln3889"> </a>
<a name="ln3890">  return OK;</a>
<a name="ln3891">}</a>
<a name="ln3892"> </a>
<a name="ln3893">/// Get the pattern, column and length for whole line completion or for the</a>
<a name="ln3894">/// complete() function.</a>
<a name="ln3895">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3896">static int get_wholeline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3897">{</a>
<a name="ln3898">  compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln3899">  compl_length = (int)curs_col - (int)compl_col;</a>
<a name="ln3900">  if (compl_length &lt; 0) {  // cursor in indent: empty pattern</a>
<a name="ln3901">    compl_length = 0;</a>
<a name="ln3902">  }</a>
<a name="ln3903">  if (p_ic) {</a>
<a name="ln3904">    compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3905">  } else {</a>
<a name="ln3906">    compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3907">  }</a>
<a name="ln3908"> </a>
<a name="ln3909">  return OK;</a>
<a name="ln3910">}</a>
<a name="ln3911"> </a>
<a name="ln3912">/// Get the pattern, column and length for filename completion.</a>
<a name="ln3913">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3914">static int get_filename_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3915">{</a>
<a name="ln3916">  // Go back to just before the first filename character.</a>
<a name="ln3917">  if (startcol &gt; 0) {</a>
<a name="ln3918">    char *p = line + startcol;</a>
<a name="ln3919"> </a>
<a name="ln3920">    MB_PTR_BACK(line, p);</a>
<a name="ln3921">    while (p &gt; line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3922">      MB_PTR_BACK(line, p);</a>
<a name="ln3923">    }</a>
<a name="ln3924">    if (p == line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3925">      startcol = 0;</a>
<a name="ln3926">    } else {</a>
<a name="ln3927">      startcol = (int)(p - line) + 1;</a>
<a name="ln3928">    }</a>
<a name="ln3929">  }</a>
<a name="ln3930"> </a>
<a name="ln3931">  compl_col += startcol;</a>
<a name="ln3932">  compl_length = (int)curs_col - startcol;</a>
<a name="ln3933">  compl_pattern = addstar(line + compl_col, (size_t)compl_length, EXPAND_FILES);</a>
<a name="ln3934"> </a>
<a name="ln3935">  return OK;</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">/// Get the pattern, column and length for command-line completion.</a>
<a name="ln3939">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3940">static int get_cmdline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3941">{</a>
<a name="ln3942">  compl_pattern = xstrnsave(line, (size_t)curs_col);</a>
<a name="ln3943">  set_cmd_context(&amp;compl_xp, compl_pattern, (int)strlen(compl_pattern), curs_col, false);</a>
<a name="ln3944">  if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL</a>
<a name="ln3945">      || compl_xp.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3946">    // No completion possible, use an empty pattern to get a</a>
<a name="ln3947">    // &quot;pattern not found&quot; message.</a>
<a name="ln3948">    compl_col = curs_col;</a>
<a name="ln3949">  } else {</a>
<a name="ln3950">    compl_col = (int)(compl_xp.xp_pattern - compl_pattern);</a>
<a name="ln3951">  }</a>
<a name="ln3952">  compl_length = curs_col - compl_col;</a>
<a name="ln3953"> </a>
<a name="ln3954">  return OK;</a>
<a name="ln3955">}</a>
<a name="ln3956"> </a>
<a name="ln3957">/// Get the pattern, column and length for user defined completion ('omnifunc',</a>
<a name="ln3958">/// 'completefunc' and 'thesaurusfunc')</a>
<a name="ln3959">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3960">/// Uses the global variable: spell_bad_len</a>
<a name="ln3961">static int get_userdefined_compl_info(colnr_T curs_col)</a>
<a name="ln3962">{</a>
<a name="ln3963">  // Call user defined function 'completefunc' with &quot;a:findstart&quot;</a>
<a name="ln3964">  // set to 1 to obtain the length of text to use for completion.</a>
<a name="ln3965">  const int save_State = State;</a>
<a name="ln3966"> </a>
<a name="ln3967">  // Call 'completefunc' or 'omnifunc' and get pattern length as a string</a>
<a name="ln3968">  char *funcname = get_complete_funcname(ctrl_x_mode);</a>
<a name="ln3969">  if (*funcname == NUL) {</a>
<a name="ln3970">    semsg(_(e_notset), ctrl_x_mode_function() ? &quot;completefunc&quot; : &quot;omnifunc&quot;);</a>
<a name="ln3971">    return FAIL;</a>
<a name="ln3972">  }</a>
<a name="ln3973"> </a>
<a name="ln3974">  typval_T args[3];</a>
<a name="ln3975">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln3976">  args[1].v_type = VAR_STRING;</a>
<a name="ln3977">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln3978">  args[0].vval.v_number = 1;</a>
<a name="ln3979">  args[1].vval.v_string = &quot;&quot;;</a>
<a name="ln3980"> </a>
<a name="ln3981">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3982">  textlock++;</a>
<a name="ln3983">  Callback *cb = get_insert_callback(ctrl_x_mode);</a>
<a name="ln3984">  colnr_T col = (colnr_T)callback_call_retnr(cb, 2, args);</a>
<a name="ln3985">  textlock--;</a>
<a name="ln3986"> </a>
<a name="ln3987">  State = save_State;</a>
<a name="ln3988">  curwin-&gt;w_cursor = pos;  // restore the cursor position</a>
<a name="ln3989">  validate_cursor();</a>
<a name="ln3990">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln3991">    emsg(_(e_compldel));</a>
<a name="ln3992">    return FAIL;</a>
<a name="ln3993">  }</a>
<a name="ln3994"> </a>
<a name="ln3995">  // Return value -2 means the user complete function wants to cancel the</a>
<a name="ln3996">  // complete without an error, do the same if the function did not execute</a>
<a name="ln3997">  // successfully.</a>
<a name="ln3998">  if (col == -2 || aborting()) {</a>
<a name="ln3999">    return FAIL;</a>
<a name="ln4000">  }</a>
<a name="ln4001">  // Return value -3 does the same as -2 and leaves CTRL-X mode.</a>
<a name="ln4002">  if (col == -3) {</a>
<a name="ln4003">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln4004">    edit_submode = NULL;</a>
<a name="ln4005">    if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4006">      msg_clr_cmdline();</a>
<a name="ln4007">    }</a>
<a name="ln4008">    return FAIL;</a>
<a name="ln4009">  }</a>
<a name="ln4010"> </a>
<a name="ln4011">  // Reset extended parameters of completion, when starting new</a>
<a name="ln4012">  // completion.</a>
<a name="ln4013">  compl_opt_refresh_always = false;</a>
<a name="ln4014"> </a>
<a name="ln4015">  if (col &lt; 0) {</a>
<a name="ln4016">    col = curs_col;</a>
<a name="ln4017">  }</a>
<a name="ln4018">  compl_col = col;</a>
<a name="ln4019">  if (compl_col &gt; curs_col) {</a>
<a name="ln4020">    compl_col = curs_col;</a>
<a name="ln4021">  }</a>
<a name="ln4022"> </a>
<a name="ln4023">  // Setup variables for completion.  Need to obtain &quot;line&quot; again,</a>
<a name="ln4024">  // it may have become invalid.</a>
<a name="ln4025">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4026">  compl_length = curs_col - compl_col;</a>
<a name="ln4027">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4028"> </a>
<a name="ln4029">  return OK;</a>
<a name="ln4030">}</a>
<a name="ln4031"> </a>
<a name="ln4032">/// Get the pattern, column and length for spell completion.</a>
<a name="ln4033">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln4034">/// Uses the global variable: spell_bad_len</a>
<a name="ln4035">static int get_spell_compl_info(int startcol, colnr_T curs_col)</a>
<a name="ln4036">{</a>
<a name="ln4037">  if (spell_bad_len &gt; 0) {</a>
<a name="ln4038">    assert(spell_bad_len &lt;= INT_MAX);</a>
<a name="ln4039">    compl_col = curs_col - (int)spell_bad_len;</a>
<a name="ln4040">  } else {</a>
<a name="ln4041">    compl_col = spell_word_start(startcol);</a>
<a name="ln4042">  }</a>
<a name="ln4043">  if (compl_col &gt;= (colnr_T)startcol) {</a>
<a name="ln4044">    compl_length = 0;</a>
<a name="ln4045">    compl_col = curs_col;</a>
<a name="ln4046">  } else {</a>
<a name="ln4047">    spell_expand_check_cap(compl_col);</a>
<a name="ln4048">    compl_length = (int)curs_col - compl_col;</a>
<a name="ln4049">  }</a>
<a name="ln4050">  // Need to obtain &quot;line&quot; again, it may have become invalid.</a>
<a name="ln4051">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4052">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4053"> </a>
<a name="ln4054">  return OK;</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">/// Get the completion pattern, column and length.</a>
<a name="ln4058">///</a>
<a name="ln4059">/// @param startcol  start column number of the completion pattern/text</a>
<a name="ln4060">/// @param cur_col   current cursor column</a>
<a name="ln4061">///</a>
<a name="ln4062">/// On return, &quot;line_invalid&quot; is set to true, if the current line may have</a>
<a name="ln4063">/// become invalid and needs to be fetched again.</a>
<a name="ln4064">///</a>
<a name="ln4065">/// @return  OK on success.</a>
<a name="ln4066">static int compl_get_info(char *line, int startcol, colnr_T curs_col, bool *line_invalid)</a>
<a name="ln4067">{</a>
<a name="ln4068">  if (ctrl_x_mode_normal()</a>
<a name="ln4069">      || ((ctrl_x_mode &amp; CTRL_X_WANT_IDENT)</a>
<a name="ln4070">          &amp;&amp; !thesaurus_func_complete(ctrl_x_mode))) {</a>
<a name="ln4071">    return get_normal_compl_info(line, startcol, curs_col);</a>
<a name="ln4072">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4073">    return get_wholeline_compl_info(line, curs_col);</a>
<a name="ln4074">  } else if (ctrl_x_mode_files()) {</a>
<a name="ln4075">    return get_filename_compl_info(line, startcol, curs_col);</a>
<a name="ln4076">  } else if (ctrl_x_mode == CTRL_X_CMDLINE) {</a>
<a name="ln4077">    return get_cmdline_compl_info(line, curs_col);</a>
<a name="ln4078">  } else if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4079">             || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4080">    if (get_userdefined_compl_info(curs_col) == FAIL) {</a>
<a name="ln4081">      return FAIL;</a>
<a name="ln4082">    }</a>
<a name="ln4083">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4084">  } else if (ctrl_x_mode_spell()) {</a>
<a name="ln4085">    if (get_spell_compl_info(startcol, curs_col) == FAIL) {</a>
<a name="ln4086">      return FAIL;</a>
<a name="ln4087">    }</a>
<a name="ln4088">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4089">  } else {</a>
<a name="ln4090">    internal_error(&quot;ins_complete()&quot;);</a>
<a name="ln4091">    return FAIL;</a>
<a name="ln4092">  }</a>
<a name="ln4093"> </a>
<a name="ln4094">  return OK;</a>
<a name="ln4095">}</a>
<a name="ln4096"> </a>
<a name="ln4097">/// Continue an interrupted completion mode search in &quot;line&quot;.</a>
<a name="ln4098">///</a>
<a name="ln4099">/// If this same ctrl_x_mode has been interrupted use the text from</a>
<a name="ln4100">/// &quot;compl_startpos&quot; to the cursor as a pattern to add a new word instead of</a>
<a name="ln4101">/// expand the one before the cursor, in word-wise if &quot;compl_startpos&quot; is not in</a>
<a name="ln4102">/// the same line as the cursor then fix it (the line has been split because it</a>
<a name="ln4103">/// was longer than 'tw').  if SOL is set then skip the previous pattern, a word</a>
<a name="ln4104">/// at the beginning of the line has been inserted, we'll look for that.</a>
<a name="ln4105">static void ins_compl_continue_search(char *line)</a>
<a name="ln4106">{</a>
<a name="ln4107">  // it is a continued search</a>
<a name="ln4108">  compl_cont_status &amp;= ~CONT_INTRPT;  // remove INTRPT</a>
<a name="ln4109">  if (ctrl_x_mode_normal()</a>
<a name="ln4110">      || ctrl_x_mode_path_patterns()</a>
<a name="ln4111">      || ctrl_x_mode_path_defines()) {</a>
<a name="ln4112">    if (compl_startpos.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln4113">      // line (probably) wrapped, set compl_startpos to the</a>
<a name="ln4114">      // first non_blank in the line, if it is not a wordchar</a>
<a name="ln4115">      // include it to get a better pattern, but then we don't</a>
<a name="ln4116">      // want the &quot;\\&lt;&quot; prefix, check it below.</a>
<a name="ln4117">      compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln4118">      compl_startpos.col = compl_col;</a>
<a name="ln4119">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4120">      compl_cont_status &amp;= ~CONT_SOL;  // clear SOL if present</a>
<a name="ln4121">    } else {</a>
<a name="ln4122">      // S_IPOS was set when we inserted a word that was at the</a>
<a name="ln4123">      // beginning of the line, which means that we'll go to SOL</a>
<a name="ln4124">      // mode but first we need to redefine compl_startpos</a>
<a name="ln4125">      if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4126">        compl_cont_status |= CONT_SOL;</a>
<a name="ln4127">        compl_startpos.col = (colnr_T)(skipwhite(line + compl_length + compl_startpos.col) - line);</a>
<a name="ln4128">      }</a>
<a name="ln4129">      compl_col = compl_startpos.col;</a>
<a name="ln4130">    }</a>
<a name="ln4131">    compl_length = curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln4132">    // IObuff is used to add a &quot;word from the next line&quot; would we</a>
<a name="ln4133">    // have enough space?  just being paranoid</a>
<a name="ln4134">#define MIN_SPACE 75</a>
<a name="ln4135">    if (compl_length &gt; (IOSIZE - MIN_SPACE)) {</a>
<a name="ln4136">      compl_cont_status &amp;= ~CONT_SOL;</a>
<a name="ln4137">      compl_length = (IOSIZE - MIN_SPACE);</a>
<a name="ln4138">      compl_col = curwin-&gt;w_cursor.col - compl_length;</a>
<a name="ln4139">    }</a>
<a name="ln4140">    compl_cont_status |= CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4141">    if (compl_length &lt; 1) {</a>
<a name="ln4142">      compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4143">    }</a>
<a name="ln4144">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4145">    compl_cont_status = CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4146">  } else {</a>
<a name="ln4147">    compl_cont_status = 0;</a>
<a name="ln4148">  }</a>
<a name="ln4149">}</a>
<a name="ln4150"> </a>
<a name="ln4151">/// start insert mode completion</a>
<a name="ln4152">static int ins_compl_start(void)</a>
<a name="ln4153">{</a>
<a name="ln4154">  const bool save_did_ai = did_ai;</a>
<a name="ln4155"> </a>
<a name="ln4156">  // First time we hit ^N or ^P (in a row, I mean)</a>
<a name="ln4157"> </a>
<a name="ln4158">  did_ai = false;</a>
<a name="ln4159">  did_si = false;</a>
<a name="ln4160">  can_si = false;</a>
<a name="ln4161">  can_si_back = false;</a>
<a name="ln4162">  if (stop_arrow() == FAIL) {</a>
<a name="ln4163">    return FAIL;</a>
<a name="ln4164">  }</a>
<a name="ln4165"> </a>
<a name="ln4166">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4167">  colnr_T curs_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4168">  compl_pending = 0;</a>
<a name="ln4169"> </a>
<a name="ln4170">  if ((compl_cont_status &amp; CONT_INTRPT) == CONT_INTRPT</a>
<a name="ln4171">      &amp;&amp; compl_cont_mode == ctrl_x_mode) {</a>
<a name="ln4172">    // this same ctrl-x_mode was interrupted previously. Continue the</a>
<a name="ln4173">    // completion.</a>
<a name="ln4174">    ins_compl_continue_search(line);</a>
<a name="ln4175">  } else {</a>
<a name="ln4176">    compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4177">  }</a>
<a name="ln4178"> </a>
<a name="ln4179">  int startcol = 0;  // column where searched text starts</a>
<a name="ln4180">  if (!compl_status_adding()) {   // normal expansion</a>
<a name="ln4181">    compl_cont_mode = ctrl_x_mode;</a>
<a name="ln4182">    if (ctrl_x_mode_not_default()) {</a>
<a name="ln4183">      // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL</a>
<a name="ln4184">      compl_cont_status = 0;</a>
<a name="ln4185">    }</a>
<a name="ln4186">    compl_cont_status |= CONT_N_ADDS;</a>
<a name="ln4187">    compl_startpos = curwin-&gt;w_cursor;</a>
<a name="ln4188">    startcol = (int)curs_col;</a>
<a name="ln4189">    compl_col = 0;</a>
<a name="ln4190">  }</a>
<a name="ln4191"> </a>
<a name="ln4192">  // Work out completion pattern and original text -- webb</a>
<a name="ln4193">  bool line_invalid = false;</a>
<a name="ln4194">  if (compl_get_info(line, startcol, curs_col, &amp;line_invalid) == FAIL) {</a>
<a name="ln4195">    if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4196">        || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4197">      // restore did_ai, so that adding comment leader works</a>
<a name="ln4198">      did_ai = save_did_ai;</a>
<a name="ln4199">    }</a>
<a name="ln4200">    return FAIL;</a>
<a name="ln4201">  }</a>
<a name="ln4202">  // If &quot;line&quot; was changed while getting completion info get it again.</a>
<a name="ln4203">  if (line_invalid) {</a>
<a name="ln4204">    line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4205">  }</a>
<a name="ln4206"> </a>
<a name="ln4207">  if (compl_status_adding()) {</a>
<a name="ln4208">    edit_submode_pre = _(&quot; Adding&quot;);</a>
<a name="ln4209">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4210">      // Insert a new line, keep indentation but ignore 'comments'.</a>
<a name="ln4211">      char *old = curbuf-&gt;b_p_com;</a>
<a name="ln4212"> </a>
<a name="ln4213">      curbuf-&gt;b_p_com = &quot;&quot;;</a>
<a name="ln4214">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4215">      compl_startpos.col = compl_col;</a>
<a name="ln4216">      ins_eol('\r');</a>
<a name="ln4217">      curbuf-&gt;b_p_com = old;</a>
<a name="ln4218">      compl_length = 0;</a>
<a name="ln4219">      compl_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4220">    }</a>
<a name="ln4221">  } else {</a>
<a name="ln4222">    edit_submode_pre = NULL;</a>
<a name="ln4223">    compl_startpos.col = compl_col;</a>
<a name="ln4224">  }</a>
<a name="ln4225"> </a>
<a name="ln4226">  if (compl_cont_status &amp; CONT_LOCAL) {</a>
<a name="ln4227">    edit_submode = _(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);</a>
<a name="ln4228">  } else {</a>
<a name="ln4229">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln4230">  }</a>
<a name="ln4231"> </a>
<a name="ln4232">  // If any of the original typed text has been changed we need to fix</a>
<a name="ln4233">  // the redo buffer.</a>
<a name="ln4234">  ins_compl_fixRedoBufForLeader(NULL);</a>
<a name="ln4235"> </a>
<a name="ln4236">  // Always add completion for the original text.</a>
<a name="ln4237">  xfree(compl_orig_text);</a>
<a name="ln4238">  compl_orig_text = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4239">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln4240">  if (p_ic) {</a>
<a name="ln4241">    flags |= CP_ICASE;</a>
<a name="ln4242">  }</a>
<a name="ln4243">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln4244">                    flags, false) != OK) {</a>
<a name="ln4245">    XFREE_CLEAR(compl_pattern);</a>
<a name="ln4246">    XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4247">    return FAIL;</a>
<a name="ln4248">  }</a>
<a name="ln4249"> </a>
<a name="ln4250">  // showmode might reset the internal line pointers, so it must</a>
<a name="ln4251">  // be called before line = ml_get(), or when this address is no</a>
<a name="ln4252">  // longer needed.  -- Acevedo.</a>
<a name="ln4253">  edit_submode_extra = _(&quot;-- Searching...&quot;);</a>
<a name="ln4254">  edit_submode_highl = HLF_COUNT;</a>
<a name="ln4255">  showmode();</a>
<a name="ln4256">  edit_submode_extra = NULL;</a>
<a name="ln4257">  ui_flush();</a>
<a name="ln4258"> </a>
<a name="ln4259">  return OK;</a>
<a name="ln4260">}</a>
<a name="ln4261"> </a>
<a name="ln4262">/// display the completion status message</a>
<a name="ln4263">static void ins_compl_show_statusmsg(void)</a>
<a name="ln4264">{</a>
<a name="ln4265">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4266">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4267">    edit_submode_extra = compl_status_adding() &amp;&amp; compl_length &gt; 1 ? _(e_hitend) : _(e_patnotf);</a>
<a name="ln4268">    edit_submode_highl = HLF_E;</a>
<a name="ln4269">  }</a>
<a name="ln4270"> </a>
<a name="ln4271">  if (edit_submode_extra == NULL) {</a>
<a name="ln4272">    if (match_at_original_text(compl_curr_match)) {</a>
<a name="ln4273">      edit_submode_extra = _(&quot;Back at original&quot;);</a>
<a name="ln4274">      edit_submode_highl = HLF_W;</a>
<a name="ln4275">    } else if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4276">      edit_submode_extra = _(&quot;Word from other line&quot;);</a>
<a name="ln4277">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4278">    } else if (compl_curr_match-&gt;cp_next == compl_curr_match-&gt;cp_prev) {</a>
<a name="ln4279">      edit_submode_extra = _(&quot;The only match&quot;);</a>
<a name="ln4280">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4281">      compl_curr_match-&gt;cp_number = 1;</a>
<a name="ln4282">    } else {</a>
<a name="ln4283">      // Update completion sequence number when needed.</a>
<a name="ln4284">      if (compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln4285">        ins_compl_update_sequence_numbers();</a>
<a name="ln4286">      }</a>
<a name="ln4287"> </a>
<a name="ln4288">      // The match should always have a sequence number now, this is</a>
<a name="ln4289">      // just a safety check.</a>
<a name="ln4290">      if (compl_curr_match-&gt;cp_number != -1) {</a>
<a name="ln4291">        // Space for 10 text chars. + 2x10-digit no.s = 31.</a>
<a name="ln4292">        // Translations may need more than twice that.</a>
<a name="ln4293">        static char match_ref[81];</a>
<a name="ln4294"> </a>
<a name="ln4295">        if (compl_matches &gt; 0) {</a>
<a name="ln4296">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4297">                       _(&quot;match %d of %d&quot;),</a>
<a name="ln4298">                       compl_curr_match-&gt;cp_number, compl_matches);</a>
<a name="ln4299">        } else {</a>
<a name="ln4300">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4301">                       _(&quot;match %d&quot;),</a>
<a name="ln4302">                       compl_curr_match-&gt;cp_number);</a>
<a name="ln4303">        }</a>
<a name="ln4304">        edit_submode_extra = match_ref;</a>
<a name="ln4305">        edit_submode_highl = HLF_R;</a>
<a name="ln4306">        if (dollar_vcol &gt;= 0) {</a>
<a name="ln4307">          curs_columns(curwin, false);</a>
<a name="ln4308">        }</a>
<a name="ln4309">      }</a>
<a name="ln4310">    }</a>
<a name="ln4311">  }</a>
<a name="ln4312"> </a>
<a name="ln4313">  // Show a message about what (completion) mode we're in.</a>
<a name="ln4314">  showmode();</a>
<a name="ln4315">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4316">    if (edit_submode_extra != NULL) {</a>
<a name="ln4317">      if (!p_smd) {</a>
<a name="ln4318">        msg_hist_off = true;</a>
<a name="ln4319">        msg(edit_submode_extra, (edit_submode_highl &lt; HLF_COUNT</a>
<a name="ln4320">                                 ? HL_ATTR(edit_submode_highl) : 0));</a>
<a name="ln4321">        msg_hist_off = false;</a>
<a name="ln4322">      }</a>
<a name="ln4323">    } else {</a>
<a name="ln4324">      msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln4325">    }</a>
<a name="ln4326">  }</a>
<a name="ln4327">}</a>
<a name="ln4328"> </a>
<a name="ln4329">/// Do Insert mode completion.</a>
<a name="ln4330">/// Called when character &quot;c&quot; was typed, which has a meaning for completion.</a>
<a name="ln4331">/// Returns OK if completion was done, FAIL if something failed.</a>
<a name="ln4332">int ins_complete(int c, bool enable_pum)</a>
<a name="ln4333">{</a>
<a name="ln4334">  int n;</a>
<a name="ln4335">  int save_w_wrow;</a>
<a name="ln4336">  int save_w_leftcol;</a>
<a name="ln4337">  int insert_match;</a>
<a name="ln4338"> </a>
<a name="ln4339">  compl_direction = ins_compl_key2dir(c);</a>
<a name="ln4340">  insert_match = ins_compl_use_match(c);</a>
<a name="ln4341"> </a>
<a name="ln4342">  if (!compl_started) {</a>
<a name="ln4343">    if (ins_compl_start() == FAIL) {</a>
<a name="ln4344">      return FAIL;</a>
<a name="ln4345">    }</a>
<a name="ln4346">  } else if (insert_match &amp;&amp; stop_arrow() == FAIL) {</a>
<a name="ln4347">    return FAIL;</a>
<a name="ln4348">  }</a>
<a name="ln4349"> </a>
<a name="ln4350">  compl_shown_match = compl_curr_match;</a>
<a name="ln4351">  compl_shows_dir = compl_direction;</a>
<a name="ln4352"> </a>
<a name="ln4353">  // Find next match (and following matches).</a>
<a name="ln4354">  save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln4355">  save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln4356">  n = ins_compl_next(true, ins_compl_key2count(c), insert_match, false);</a>
<a name="ln4357"> </a>
<a name="ln4358">  if (n &gt; 1) {          // all matches have been found</a>
<a name="ln4359">    compl_matches = n;</a>
<a name="ln4360">  }</a>
<a name="ln4361">  compl_curr_match = compl_shown_match;</a>
<a name="ln4362">  compl_direction = compl_shows_dir;</a>
<a name="ln4363"> </a>
<a name="ln4364">  // Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert</a>
<a name="ln4365">  // mode.</a>
<a name="ln4366">  if (got_int &amp;&amp; !global_busy) {</a>
<a name="ln4367">    (void)vgetc();</a>
<a name="ln4368">    got_int = false;</a>
<a name="ln4369">  }</a>
<a name="ln4370"> </a>
<a name="ln4371">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4372">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4373">    // remove N_ADDS flag, so next ^X&lt;&gt; won't try to go to ADDING mode,</a>
<a name="ln4374">    // because we couldn't expand anything at first place, but if we used</a>
<a name="ln4375">    // ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word</a>
<a name="ln4376">    // (such as M in M'exico) if not tried already.  -- Acevedo</a>
<a name="ln4377">    if (compl_length &gt; 1</a>
<a name="ln4378">        || compl_status_adding()</a>
<a name="ln4379">        || (ctrl_x_mode_not_default()</a>
<a name="ln4380">            &amp;&amp; !ctrl_x_mode_path_patterns()</a>
<a name="ln4381">            &amp;&amp; !ctrl_x_mode_path_defines())) {</a>
<a name="ln4382">      compl_cont_status &amp;= ~CONT_N_ADDS;</a>
<a name="ln4383">    }</a>
<a name="ln4384">  }</a>
<a name="ln4385"> </a>
<a name="ln4386">  if (compl_curr_match-&gt;cp_flags &amp; CP_CONT_S_IPOS) {</a>
<a name="ln4387">    compl_cont_status |= CONT_S_IPOS;</a>
<a name="ln4388">  } else {</a>
<a name="ln4389">    compl_cont_status &amp;= ~CONT_S_IPOS;</a>
<a name="ln4390">  }</a>
<a name="ln4391"> </a>
<a name="ln4392">  ins_compl_show_statusmsg();</a>
<a name="ln4393"> </a>
<a name="ln4394">  // Show the popup menu, unless we got interrupted.</a>
<a name="ln4395">  if (enable_pum &amp;&amp; !compl_interrupted) {</a>
<a name="ln4396">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln4397">  }</a>
<a name="ln4398">  compl_was_interrupted = compl_interrupted;</a>
<a name="ln4399">  compl_interrupted = false;</a>
<a name="ln4400"> </a>
<a name="ln4401">  return OK;</a>
<a name="ln4402">}</a>
<a name="ln4403"> </a>
<a name="ln4404">/// Remove (if needed) and show the popup menu</a>
<a name="ln4405">static void show_pum(int prev_w_wrow, int prev_w_leftcol)</a>
<a name="ln4406">{</a>
<a name="ln4407">  // RedrawingDisabled may be set when invoked through complete().</a>
<a name="ln4408">  int n = RedrawingDisabled;</a>
<a name="ln4409">  RedrawingDisabled = 0;</a>
<a name="ln4410"> </a>
<a name="ln4411">  // If the cursor moved or the display scrolled we need to remove the pum</a>
<a name="ln4412">  // first.</a>
<a name="ln4413">  setcursor();</a>
<a name="ln4414">  if (prev_w_wrow != curwin-&gt;w_wrow || prev_w_leftcol != curwin-&gt;w_leftcol) {</a>
<a name="ln4415">    ins_compl_del_pum();</a>
<a name="ln4416">  }</a>
<a name="ln4417"> </a>
<a name="ln4418">  ins_compl_show_pum();</a>
<a name="ln4419">  setcursor();</a>
<a name="ln4420">  RedrawingDisabled = n;</a>
<a name="ln4421">}</a>
<a name="ln4422"> </a>
<a name="ln4423">// Looks in the first &quot;len&quot; chars. of &quot;src&quot; for search-metachars.</a>
<a name="ln4424">// If dest is not NULL the chars. are copied there quoting (with</a>
<a name="ln4425">// a backslash) the metachars, and dest would be NUL terminated.</a>
<a name="ln4426">// Returns the length (needed) of dest</a>
<a name="ln4427">static unsigned quote_meta(char *dest, char *src, int len)</a>
<a name="ln4428">{</a>
<a name="ln4429">  unsigned m = (unsigned)len + 1;       // one extra for the NUL</a>
<a name="ln4430"> </a>
<a name="ln4431">  for (; --len &gt;= 0; src++) {</a>
<a name="ln4432">    switch (*src) {</a>
<a name="ln4433">    case '.':</a>
<a name="ln4434">    case '*':</a>
<a name="ln4435">    case '[':</a>
<a name="ln4436">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4437">        break;</a>
<a name="ln4438">      }</a>
<a name="ln4439">      FALLTHROUGH;</a>
<a name="ln4440">    case '~':</a>
<a name="ln4441">      if (!magic_isset()) {  // quote these only if magic is set</a>
<a name="ln4442">        break;</a>
<a name="ln4443">      }</a>
<a name="ln4444">      FALLTHROUGH;</a>
<a name="ln4445">    case '\\':</a>
<a name="ln4446">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4447">        break;</a>
<a name="ln4448">      }</a>
<a name="ln4449">      FALLTHROUGH;</a>
<a name="ln4450">    case '^':                   // currently it's not needed.</a>
<a name="ln4451">    case '$':</a>
<a name="ln4452">      m++;</a>
<a name="ln4453">      if (dest != NULL) {</a>
<a name="ln4454">        *dest++ = '\\';</a>
<a name="ln4455">      }</a>
<a name="ln4456">      break;</a>
<a name="ln4457">    }</a>
<a name="ln4458">    if (dest != NULL) {</a>
<a name="ln4459">      *dest++ = *src;</a>
<a name="ln4460">    }</a>
<a name="ln4461">    // Copy remaining bytes of a multibyte character.</a>
<a name="ln4462">    const int mb_len = utfc_ptr2len(src) - 1;</a>
<a name="ln4463">    if (mb_len &gt; 0 &amp;&amp; len &gt;= mb_len) {</a>
<a name="ln4464">      for (int i = 0; i &lt; mb_len; i++) {</a>
<a name="ln4465">        len--;</a>
<a name="ln4466">        src++;</a>
<a name="ln4467">        if (dest != NULL) {</a>
<a name="ln4468">          *dest++ = *src;</a>
<a name="ln4469">        }</a>
<a name="ln4470">      }</a>
<a name="ln4471">    }</a>
<a name="ln4472">  }</a>
<a name="ln4473">  if (dest != NULL) {</a>
<a name="ln4474">    *dest = NUL;</a>
<a name="ln4475">  }</a>
<a name="ln4476"> </a>
<a name="ln4477">  return m;</a>
<a name="ln4478">}</a>
<a name="ln4479"> </a>
<a name="ln4480">#if defined(EXITFREE)</a>
<a name="ln4481">void free_insexpand_stuff(void)</a>
<a name="ln4482">{</a>
<a name="ln4483">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4484">  callback_free(&amp;cfu_cb);</a>
<a name="ln4485">  callback_free(&amp;ofu_cb);</a>
<a name="ln4486">  callback_free(&amp;tsrfu_cb);</a>
<a name="ln4487">}</a>
<a name="ln4488">#endif</a>
<a name="ln4489"> </a>
<a name="ln4490">/// Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly</a>
<a name="ln4491">/// spelled word, if there is one.</a>
<a name="ln4492">static void spell_back_to_badword(void)</a>
<a name="ln4493">{</a>
<a name="ln4494">  pos_T tpos = curwin-&gt;w_cursor;</a>
<a name="ln4495">  spell_bad_len = spell_move_to(curwin, BACKWARD, true, true, NULL);</a>
<a name="ln4496">  if (curwin-&gt;w_cursor.col != tpos.col) {</a>
<a name="ln4497">    start_arrow(&amp;tpos);</a>
<a name="ln4498">  }</a>
<a name="ln4499">}</a>
</code></pre>
<div class="balloon" rel="3312"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'st.e_cpt_copy == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>