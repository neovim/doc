<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>insexpand.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// insexpand.c: functions for Insert mode completion</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;limits.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdint.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln23">#include &quot;nvim/edit.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln31">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln32">#include &quot;nvim/garray.h&quot;</a>
<a name="ln33">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln34">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln35">#include &quot;nvim/globals.h&quot;</a>
<a name="ln36">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln37">#include &quot;nvim/indent.h&quot;</a>
<a name="ln38">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln39">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln40">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln41">#include &quot;nvim/macros.h&quot;</a>
<a name="ln42">#include &quot;nvim/mark.h&quot;</a>
<a name="ln43">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln44">#include &quot;nvim/memline.h&quot;</a>
<a name="ln45">#include &quot;nvim/memory.h&quot;</a>
<a name="ln46">#include &quot;nvim/message.h&quot;</a>
<a name="ln47">#include &quot;nvim/move.h&quot;</a>
<a name="ln48">#include &quot;nvim/option.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln52">#include &quot;nvim/path.h&quot;</a>
<a name="ln53">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln54">#include &quot;nvim/pos.h&quot;</a>
<a name="ln55">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln56">#include &quot;nvim/search.h&quot;</a>
<a name="ln57">#include &quot;nvim/spell.h&quot;</a>
<a name="ln58">#include &quot;nvim/state.h&quot;</a>
<a name="ln59">#include &quot;nvim/strings.h&quot;</a>
<a name="ln60">#include &quot;nvim/tag.h&quot;</a>
<a name="ln61">#include &quot;nvim/textformat.h&quot;</a>
<a name="ln62">#include &quot;nvim/types.h&quot;</a>
<a name="ln63">#include &quot;nvim/ui.h&quot;</a>
<a name="ln64">#include &quot;nvim/undo.h&quot;</a>
<a name="ln65">#include &quot;nvim/vim.h&quot;</a>
<a name="ln66">#include &quot;nvim/window.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">// Definitions used for CTRL-X submode.</a>
<a name="ln69">// Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[]</a>
<a name="ln70">// and ctrl_x_mode_names[].</a>
<a name="ln71"> </a>
<a name="ln72">#define CTRL_X_WANT_IDENT       0x100</a>
<a name="ln73"> </a>
<a name="ln74">enum {</a>
<a name="ln75">  CTRL_X_NORMAL = 0,  ///&lt; CTRL-N CTRL-P completion, default</a>
<a name="ln76">  CTRL_X_NOT_DEFINED_YET = 1,</a>
<a name="ln77">  CTRL_X_SCROLL = 2,</a>
<a name="ln78">  CTRL_X_WHOLE_LINE = 3,</a>
<a name="ln79">  CTRL_X_FILES = 4,</a>
<a name="ln80">  CTRL_X_TAGS = (5 + CTRL_X_WANT_IDENT),</a>
<a name="ln81">  CTRL_X_PATH_PATTERNS = (6 + CTRL_X_WANT_IDENT),</a>
<a name="ln82">  CTRL_X_PATH_DEFINES = (7 + CTRL_X_WANT_IDENT),</a>
<a name="ln83">  CTRL_X_FINISHED = 8,</a>
<a name="ln84">  CTRL_X_DICTIONARY = (9 + CTRL_X_WANT_IDENT),</a>
<a name="ln85">  CTRL_X_THESAURUS = (10 + CTRL_X_WANT_IDENT),</a>
<a name="ln86">  CTRL_X_CMDLINE = 11,</a>
<a name="ln87">  CTRL_X_FUNCTION = 12,</a>
<a name="ln88">  CTRL_X_OMNI = 13,</a>
<a name="ln89">  CTRL_X_SPELL = 14,</a>
<a name="ln90">  CTRL_X_LOCAL_MSG = 15,       ///&lt; only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln91">  CTRL_X_EVAL = 16,            ///&lt; for builtin function complete()</a>
<a name="ln92">  CTRL_X_CMDLINE_CTRL_X = 17,  ///&lt; CTRL-X typed in CTRL_X_CMDLINE</a>
<a name="ln93">};</a>
<a name="ln94"> </a>
<a name="ln95">#define CTRL_X_MSG(i) ctrl_x_msgs[(i) &amp; ~CTRL_X_WANT_IDENT]</a>
<a name="ln96"> </a>
<a name="ln97">/// Message for CTRL-X mode, index is ctrl_x_mode.</a>
<a name="ln98">static char *ctrl_x_msgs[] = {</a>
<a name="ln99">  N_(&quot; Keyword completion (^N^P)&quot;),  // CTRL_X_NORMAL, ^P/^N compl.</a>
<a name="ln100">  N_(&quot; ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)&quot;),</a>
<a name="ln101">  NULL,  // CTRL_X_SCROLL: depends on state</a>
<a name="ln102">  N_(&quot; Whole line completion (^L^N^P)&quot;),</a>
<a name="ln103">  N_(&quot; File name completion (^F^N^P)&quot;),</a>
<a name="ln104">  N_(&quot; Tag completion (^]^N^P)&quot;),</a>
<a name="ln105">  N_(&quot; Path pattern completion (^N^P)&quot;),</a>
<a name="ln106">  N_(&quot; Definition completion (^D^N^P)&quot;),</a>
<a name="ln107">  NULL,  // CTRL_X_FINISHED</a>
<a name="ln108">  N_(&quot; Dictionary completion (^K^N^P)&quot;),</a>
<a name="ln109">  N_(&quot; Thesaurus completion (^T^N^P)&quot;),</a>
<a name="ln110">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln111">  N_(&quot; User defined completion (^U^N^P)&quot;),</a>
<a name="ln112">  N_(&quot; Omni completion (^O^N^P)&quot;),</a>
<a name="ln113">  N_(&quot; Spelling suggestion (s^N^P)&quot;),</a>
<a name="ln114">  N_(&quot; Keyword Local completion (^N^P)&quot;),</a>
<a name="ln115">  NULL,  // CTRL_X_EVAL doesn't use msg.</a>
<a name="ln116">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln117">};</a>
<a name="ln118"> </a>
<a name="ln119">static char *ctrl_x_mode_names[] = {</a>
<a name="ln120">  &quot;keyword&quot;,</a>
<a name="ln121">  &quot;ctrl_x&quot;,</a>
<a name="ln122">  &quot;scroll&quot;,</a>
<a name="ln123">  &quot;whole_line&quot;,</a>
<a name="ln124">  &quot;files&quot;,</a>
<a name="ln125">  &quot;tags&quot;,</a>
<a name="ln126">  &quot;path_patterns&quot;,</a>
<a name="ln127">  &quot;path_defines&quot;,</a>
<a name="ln128">  &quot;unknown&quot;,          // CTRL_X_FINISHED</a>
<a name="ln129">  &quot;dictionary&quot;,</a>
<a name="ln130">  &quot;thesaurus&quot;,</a>
<a name="ln131">  &quot;cmdline&quot;,</a>
<a name="ln132">  &quot;function&quot;,</a>
<a name="ln133">  &quot;omni&quot;,</a>
<a name="ln134">  &quot;spell&quot;,</a>
<a name="ln135">  NULL,               // CTRL_X_LOCAL_MSG only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln136">  &quot;eval&quot;,</a>
<a name="ln137">  &quot;cmdline&quot;,</a>
<a name="ln138">};</a>
<a name="ln139"> </a>
<a name="ln140">// Array indexes used for cp_text[].</a>
<a name="ln141">#define CPT_ABBR        0   ///&lt; &quot;abbr&quot;</a>
<a name="ln142">#define CPT_MENU        1   ///&lt; &quot;menu&quot;</a>
<a name="ln143">#define CPT_KIND        2   ///&lt; &quot;kind&quot;</a>
<a name="ln144">#define CPT_INFO        3   ///&lt; &quot;info&quot;</a>
<a name="ln145">#define CPT_COUNT       4   ///&lt; Number of entries</a>
<a name="ln146"> </a>
<a name="ln147">/// Structure used to store one match for insert completion.</a>
<a name="ln148">typedef struct compl_S compl_T;</a>
<a name="ln149">struct compl_S {</a>
<a name="ln150">  compl_T *cp_next;</a>
<a name="ln151">  compl_T *cp_prev;</a>
<a name="ln152">  char *cp_str;                  ///&lt; matched text</a>
<a name="ln153">  char *(cp_text[CPT_COUNT]);    ///&lt; text for the menu</a>
<a name="ln154">  typval_T cp_user_data;</a>
<a name="ln155">  char *cp_fname;                ///&lt; file containing the match, allocated when</a>
<a name="ln156">                                 ///&lt; cp_flags has CP_FREE_FNAME</a>
<a name="ln157">  int cp_flags;                  ///&lt; CP_ values</a>
<a name="ln158">  int cp_number;                 ///&lt; sequence number</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161">/// state information used for getting the next set of insert completion</a>
<a name="ln162">/// matches.</a>
<a name="ln163">typedef struct {</a>
<a name="ln164">  char *e_cpt_copy;       ///&lt; copy of 'complete'</a>
<a name="ln165">  char *e_cpt;            ///&lt; current entry in &quot;e_cpt_copy&quot;</a>
<a name="ln166">  buf_T *ins_buf;         ///&lt; buffer being scanned</a>
<a name="ln167">  pos_T *cur_match_pos;   ///&lt; current match position</a>
<a name="ln168">  pos_T prev_match_pos;   ///&lt; previous match position</a>
<a name="ln169">  bool set_match_pos;     ///&lt; save first_match_pos/last_match_pos</a>
<a name="ln170">  pos_T first_match_pos;  ///&lt; first match position</a>
<a name="ln171">  pos_T last_match_pos;   ///&lt; last match position</a>
<a name="ln172">  bool found_all;         ///&lt; found all matches of a certain type.</a>
<a name="ln173">  char *dict;             ///&lt; dictionary file to search</a>
<a name="ln174">  int dict_f;             ///&lt; &quot;dict&quot; is an exact file name or not</a>
<a name="ln175">} ins_compl_next_state_T;</a>
<a name="ln176"> </a>
<a name="ln177">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln178"># include &quot;insexpand.c.generated.h&quot;</a>
<a name="ln179">#endif</a>
<a name="ln180"> </a>
<a name="ln181">/// values for cp_flags</a>
<a name="ln182">typedef enum {</a>
<a name="ln183">  CP_ORIGINAL_TEXT = 1,  ///&lt; the original text when the expansion begun</a>
<a name="ln184">  CP_FREE_FNAME = 2,     ///&lt; cp_fname is allocated</a>
<a name="ln185">  CP_CONT_S_IPOS = 4,    ///&lt; use CONT_S_IPOS for compl_cont_status</a>
<a name="ln186">  CP_EQUAL = 8,          ///&lt; ins_compl_equal() always returns true</a>
<a name="ln187">  CP_ICASE = 16,         ///&lt; ins_compl_equal ignores case</a>
<a name="ln188">  CP_FAST = 32,          ///&lt; use fast_breakcheck instead of os_breakcheck</a>
<a name="ln189">} cp_flags_T;</a>
<a name="ln190"> </a>
<a name="ln191">static const char e_hitend[] = N_(&quot;Hit end of paragraph&quot;);</a>
<a name="ln192">static const char e_compldel[] = N_(&quot;E840: Completion function deleted text&quot;);</a>
<a name="ln193"> </a>
<a name="ln194">// All the current matches are stored in a list.</a>
<a name="ln195">// &quot;compl_first_match&quot; points to the start of the list.</a>
<a name="ln196">// &quot;compl_curr_match&quot; points to the currently selected entry.</a>
<a name="ln197">// &quot;compl_shown_match&quot; is different from compl_curr_match during</a>
<a name="ln198">// ins_compl_get_exp().</a>
<a name="ln199">// &quot;compl_old_match&quot; points to previous &quot;compl_curr_match&quot;.</a>
<a name="ln200"> </a>
<a name="ln201">static compl_T *compl_first_match = NULL;</a>
<a name="ln202">static compl_T *compl_curr_match = NULL;</a>
<a name="ln203">static compl_T *compl_shown_match = NULL;</a>
<a name="ln204">static compl_T *compl_old_match = NULL;</a>
<a name="ln205"> </a>
<a name="ln206">/// After using a cursor key &lt;Enter&gt; selects a match in the popup menu,</a>
<a name="ln207">/// otherwise it inserts a line break.</a>
<a name="ln208">static bool compl_enter_selects = false;</a>
<a name="ln209"> </a>
<a name="ln210">/// When &quot;compl_leader&quot; is not NULL only matches that start with this string</a>
<a name="ln211">/// are used.</a>
<a name="ln212">static char *compl_leader = NULL;</a>
<a name="ln213"> </a>
<a name="ln214">static bool compl_get_longest = false;  ///&lt; put longest common string in compl_leader</a>
<a name="ln215"> </a>
<a name="ln216">static bool compl_no_insert = false;    ///&lt; false: select &amp; insert</a>
<a name="ln217">                                        ///&lt; true: noinsert</a>
<a name="ln218">static bool compl_no_select = false;    ///&lt; false: select &amp; insert</a>
<a name="ln219">                                        ///&lt; true: noselect</a>
<a name="ln220">static bool compl_longest = false;      ///&lt; false: insert full match</a>
<a name="ln221">                                        ///&lt; true: insert longest prefix</a>
<a name="ln222"> </a>
<a name="ln223">/// Selected one of the matches. When false the match was edited or using the</a>
<a name="ln224">/// longest common string.</a>
<a name="ln225">static bool compl_used_match;</a>
<a name="ln226"> </a>
<a name="ln227">/// didn't finish finding completions.</a>
<a name="ln228">static bool compl_was_interrupted = false;</a>
<a name="ln229"> </a>
<a name="ln230">// Set when character typed while looking for matches and it means we should</a>
<a name="ln231">// stop looking for matches.</a>
<a name="ln232">static bool compl_interrupted = false;</a>
<a name="ln233"> </a>
<a name="ln234">static bool compl_restarting = false;   ///&lt; don't insert match</a>
<a name="ln235"> </a>
<a name="ln236">/// When the first completion is done &quot;compl_started&quot; is set.  When it's</a>
<a name="ln237">/// false the word to be completed must be located.</a>
<a name="ln238">static bool compl_started = false;</a>
<a name="ln239"> </a>
<a name="ln240">/// Which Ctrl-X mode are we in?</a>
<a name="ln241">static int ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln242"> </a>
<a name="ln243">static int compl_matches = 0;           ///&lt; number of completion matches</a>
<a name="ln244">static char *compl_pattern = NULL;</a>
<a name="ln245">static Direction compl_direction = FORWARD;</a>
<a name="ln246">static Direction compl_shows_dir = FORWARD;</a>
<a name="ln247">static int compl_pending = 0;           ///&lt; &gt; 1 for postponed CTRL-N</a>
<a name="ln248">static pos_T compl_startpos;</a>
<a name="ln249">/// Length in bytes of the text being completed (this is deleted to be replaced</a>
<a name="ln250">/// by the match.)</a>
<a name="ln251">static int compl_length = 0;</a>
<a name="ln252">static colnr_T compl_col = 0;           ///&lt; column where the text starts</a>
<a name="ln253">                                        ///&lt; that is being completed</a>
<a name="ln254">static char *compl_orig_text = NULL;    ///&lt; text as it was before</a>
<a name="ln255">                                        ///&lt; completion started</a>
<a name="ln256">static int compl_cont_mode = 0;</a>
<a name="ln257">static expand_T compl_xp;</a>
<a name="ln258"> </a>
<a name="ln259">// List of flags for method of completion.</a>
<a name="ln260">static int compl_cont_status = 0;</a>
<a name="ln261">#define CONT_ADDING    1        ///&lt; &quot;normal&quot; or &quot;adding&quot; expansion</a>
<a name="ln262">#define CONT_INTRPT    (2 + 4)  ///&lt; a ^X interrupted the current expansion</a>
<a name="ln263">                                ///&lt; it's set only iff N_ADDS is set</a>
<a name="ln264">#define CONT_N_ADDS    4        ///&lt; next ^X&lt;&gt; will add-new or expand-current</a>
<a name="ln265">#define CONT_S_IPOS    8        ///&lt; next ^X&lt;&gt; will set initial_pos?</a>
<a name="ln266">                                ///&lt; if so, word-wise-expansion will set SOL</a>
<a name="ln267">#define CONT_SOL       16       ///&lt; pattern includes start of line, just for</a>
<a name="ln268">                                ///&lt; word-wise expansion, not set for ^X^L</a>
<a name="ln269">#define CONT_LOCAL     32       ///&lt; for ctrl_x_mode 0, ^X^P/^X^N do a local</a>
<a name="ln270">                                ///&lt; expansion, (eg use complete=.)</a>
<a name="ln271"> </a>
<a name="ln272">static bool compl_opt_refresh_always = false;</a>
<a name="ln273"> </a>
<a name="ln274">static size_t spell_bad_len = 0;   // length of located bad word</a>
<a name="ln275"> </a>
<a name="ln276">static int pum_selected_item = -1;</a>
<a name="ln277"> </a>
<a name="ln278">/// CTRL-X pressed in Insert mode.</a>
<a name="ln279">void ins_ctrl_x(void)</a>
<a name="ln280">{</a>
<a name="ln281">  if (!ctrl_x_mode_cmdline()) {</a>
<a name="ln282">    // if the next ^X&lt;&gt; won't ADD nothing, then reset compl_cont_status</a>
<a name="ln283">    if (compl_cont_status &amp; CONT_N_ADDS) {</a>
<a name="ln284">      compl_cont_status |= CONT_INTRPT;</a>
<a name="ln285">    } else {</a>
<a name="ln286">      compl_cont_status = 0;</a>
<a name="ln287">    }</a>
<a name="ln288">    // We're not sure which CTRL-X mode it will be yet</a>
<a name="ln289">    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln290">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln291">    edit_submode_pre = NULL;</a>
<a name="ln292">    showmode();</a>
<a name="ln293">  } else {</a>
<a name="ln294">    // CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X</a>
<a name="ln295">    // CTRL-V look like CTRL-N</a>
<a name="ln296">    ctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln297">  }</a>
<a name="ln298"> </a>
<a name="ln299">  may_trigger_modechanged();</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">// Functions to check the current CTRL-X mode.</a>
<a name="ln303"> </a>
<a name="ln304">bool ctrl_x_mode_none(void)</a>
<a name="ln305">  FUNC_ATTR_PURE</a>
<a name="ln306">{</a>
<a name="ln307">  return ctrl_x_mode == 0;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">bool ctrl_x_mode_normal(void)</a>
<a name="ln311">  FUNC_ATTR_PURE</a>
<a name="ln312">{</a>
<a name="ln313">  return ctrl_x_mode == CTRL_X_NORMAL;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">bool ctrl_x_mode_scroll(void)</a>
<a name="ln317">  FUNC_ATTR_PURE</a>
<a name="ln318">{</a>
<a name="ln319">  return ctrl_x_mode == CTRL_X_SCROLL;</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">bool ctrl_x_mode_whole_line(void)</a>
<a name="ln323">  FUNC_ATTR_PURE</a>
<a name="ln324">{</a>
<a name="ln325">  return ctrl_x_mode == CTRL_X_WHOLE_LINE;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">bool ctrl_x_mode_files(void)</a>
<a name="ln329">  FUNC_ATTR_PURE</a>
<a name="ln330">{</a>
<a name="ln331">  return ctrl_x_mode == CTRL_X_FILES;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">bool ctrl_x_mode_tags(void)</a>
<a name="ln335">  FUNC_ATTR_PURE</a>
<a name="ln336">{</a>
<a name="ln337">  return ctrl_x_mode == CTRL_X_TAGS;</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">bool ctrl_x_mode_path_patterns(void)</a>
<a name="ln341">  FUNC_ATTR_PURE</a>
<a name="ln342">{</a>
<a name="ln343">  return ctrl_x_mode == CTRL_X_PATH_PATTERNS;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">bool ctrl_x_mode_path_defines(void)</a>
<a name="ln347">  FUNC_ATTR_PURE</a>
<a name="ln348">{</a>
<a name="ln349">  return ctrl_x_mode == CTRL_X_PATH_DEFINES;</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">bool ctrl_x_mode_dictionary(void)</a>
<a name="ln353">  FUNC_ATTR_PURE</a>
<a name="ln354">{</a>
<a name="ln355">  return ctrl_x_mode == CTRL_X_DICTIONARY;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">bool ctrl_x_mode_thesaurus(void)</a>
<a name="ln359">  FUNC_ATTR_PURE</a>
<a name="ln360">{</a>
<a name="ln361">  return ctrl_x_mode == CTRL_X_THESAURUS;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">bool ctrl_x_mode_cmdline(void)</a>
<a name="ln365">  FUNC_ATTR_PURE</a>
<a name="ln366">{</a>
<a name="ln367">  return ctrl_x_mode == CTRL_X_CMDLINE || ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">bool ctrl_x_mode_function(void)</a>
<a name="ln371">  FUNC_ATTR_PURE</a>
<a name="ln372">{</a>
<a name="ln373">  return ctrl_x_mode == CTRL_X_FUNCTION;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">bool ctrl_x_mode_omni(void)</a>
<a name="ln377">  FUNC_ATTR_PURE</a>
<a name="ln378">{</a>
<a name="ln379">  return ctrl_x_mode == CTRL_X_OMNI;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">bool ctrl_x_mode_spell(void)</a>
<a name="ln383">  FUNC_ATTR_PURE</a>
<a name="ln384">{</a>
<a name="ln385">  return ctrl_x_mode == CTRL_X_SPELL;</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">static bool ctrl_x_mode_eval(void)</a>
<a name="ln389">  FUNC_ATTR_PURE</a>
<a name="ln390">{</a>
<a name="ln391">  return ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">bool ctrl_x_mode_line_or_eval(void)</a>
<a name="ln395">  FUNC_ATTR_PURE</a>
<a name="ln396">{</a>
<a name="ln397">  return ctrl_x_mode == CTRL_X_WHOLE_LINE || ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/// Whether other than default completion has been selected.</a>
<a name="ln401">bool ctrl_x_mode_not_default(void)</a>
<a name="ln402">  FUNC_ATTR_PURE</a>
<a name="ln403">{</a>
<a name="ln404">  return ctrl_x_mode != CTRL_X_NORMAL;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">/// Whether CTRL-X was typed without a following character,</a>
<a name="ln408">/// not including when in CTRL-X CTRL-V mode.</a>
<a name="ln409">bool ctrl_x_mode_not_defined_yet(void)</a>
<a name="ln410">  FUNC_ATTR_PURE</a>
<a name="ln411">{</a>
<a name="ln412">  return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/// @return  true if currently in &quot;normal&quot; or &quot;adding&quot; insert completion matches state</a>
<a name="ln416">bool compl_status_adding(void)</a>
<a name="ln417">{</a>
<a name="ln418">  return compl_cont_status &amp; CONT_ADDING;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">/// @return  true if the completion pattern includes start of line, just for</a>
<a name="ln422">///          word-wise expansion.</a>
<a name="ln423">bool compl_status_sol(void)</a>
<a name="ln424">{</a>
<a name="ln425">  return compl_cont_status &amp; CONT_SOL;</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/// @return  true if ^X^P/^X^N will do a local completion (i.e. use complete=.)</a>
<a name="ln429">bool compl_status_local(void)</a>
<a name="ln430">{</a>
<a name="ln431">  return compl_cont_status &amp; CONT_LOCAL;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">/// Clear the completion status flags</a>
<a name="ln435">void compl_status_clear(void)</a>
<a name="ln436">{</a>
<a name="ln437">  compl_cont_status = 0;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/// @return  true if completion is using the forward direction matches</a>
<a name="ln441">static bool compl_dir_forward(void)</a>
<a name="ln442">{</a>
<a name="ln443">  return compl_direction == FORWARD;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">/// @return  true if currently showing forward completion matches</a>
<a name="ln447">static bool compl_shows_dir_forward(void)</a>
<a name="ln448">{</a>
<a name="ln449">  return compl_shows_dir == FORWARD;</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">/// @return  true if currently showing backward completion matches</a>
<a name="ln453">static bool compl_shows_dir_backward(void)</a>
<a name="ln454">{</a>
<a name="ln455">  return compl_shows_dir == BACKWARD;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">/// Check that the 'dictionary' or 'thesaurus' option can be used.</a>
<a name="ln459">///</a>
<a name="ln460">/// @param  dict_opt  check 'dictionary' when true, 'thesaurus' when false.</a>
<a name="ln461">bool check_compl_option(bool dict_opt)</a>
<a name="ln462">{</a>
<a name="ln463">  if (dict_opt</a>
<a name="ln464">      ? (*curbuf-&gt;b_p_dict == NUL &amp;&amp; *p_dict == NUL &amp;&amp; !curwin-&gt;w_p_spell)</a>
<a name="ln465">      : (*curbuf-&gt;b_p_tsr == NUL &amp;&amp; *p_tsr == NUL</a>
<a name="ln466">         &amp;&amp; *curbuf-&gt;b_p_tsrfu == NUL &amp;&amp; *p_tsrfu == NUL)) {</a>
<a name="ln467">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln468">    edit_submode = NULL;</a>
<a name="ln469">    msg((dict_opt ? _(&quot;'dictionary' option is empty&quot;) : _(&quot;'thesaurus' option is empty&quot;)),</a>
<a name="ln470">        HL_ATTR(HLF_E));</a>
<a name="ln471">    if (emsg_silent == 0 &amp;&amp; !in_assert_fails) {</a>
<a name="ln472">      vim_beep(BO_COMPL);</a>
<a name="ln473">      setcursor();</a>
<a name="ln474">      ui_flush();</a>
<a name="ln475">      os_delay(2004L, false);</a>
<a name="ln476">    }</a>
<a name="ln477">    return false;</a>
<a name="ln478">  }</a>
<a name="ln479">  return true;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/// Check that the character &quot;c&quot; a valid key to go to or keep us in CTRL-X mode?</a>
<a name="ln483">/// This depends on the current mode.</a>
<a name="ln484">///</a>
<a name="ln485">/// @param  c  character to check</a>
<a name="ln486">bool vim_is_ctrl_x_key(int c)</a>
<a name="ln487">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln488">{</a>
<a name="ln489">  // Always allow ^R - let its results then be checked</a>
<a name="ln490">  if (c == Ctrl_R) {</a>
<a name="ln491">    return true;</a>
<a name="ln492">  }</a>
<a name="ln493"> </a>
<a name="ln494">  // Accept &lt;PageUp&gt; and &lt;PageDown&gt; if the popup menu is visible.</a>
<a name="ln495">  if (ins_compl_pum_key(c)) {</a>
<a name="ln496">    return true;</a>
<a name="ln497">  }</a>
<a name="ln498"> </a>
<a name="ln499">  switch (ctrl_x_mode) {</a>
<a name="ln500">  case 0:  // Not in any CTRL-X mode</a>
<a name="ln501">    return c == Ctrl_N || c == Ctrl_P || c == Ctrl_X;</a>
<a name="ln502">  case CTRL_X_NOT_DEFINED_YET:</a>
<a name="ln503">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln504">    return c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E</a>
<a name="ln505">           || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB</a>
<a name="ln506">           || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P</a>
<a name="ln507">           || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V</a>
<a name="ln508">           || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O</a>
<a name="ln509">           || c == Ctrl_S || c == Ctrl_K || c == 's'</a>
<a name="ln510">           || c == Ctrl_Z;</a>
<a name="ln511">  case CTRL_X_SCROLL:</a>
<a name="ln512">    return c == Ctrl_Y || c == Ctrl_E;</a>
<a name="ln513">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln514">    return c == Ctrl_L || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln515">  case CTRL_X_FILES:</a>
<a name="ln516">    return c == Ctrl_F || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln517">  case CTRL_X_DICTIONARY:</a>
<a name="ln518">    return c == Ctrl_K || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln519">  case CTRL_X_THESAURUS:</a>
<a name="ln520">    return c == Ctrl_T || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln521">  case CTRL_X_TAGS:</a>
<a name="ln522">    return c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln523">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln524">    return c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln525">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln526">    return c == Ctrl_D || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln527">  case CTRL_X_CMDLINE:</a>
<a name="ln528">    return c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N</a>
<a name="ln529">           || c == Ctrl_X;</a>
<a name="ln530">  case CTRL_X_FUNCTION:</a>
<a name="ln531">    return c == Ctrl_U || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln532">  case CTRL_X_OMNI:</a>
<a name="ln533">    return c == Ctrl_O || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln534">  case CTRL_X_SPELL:</a>
<a name="ln535">    return c == Ctrl_S || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln536">  case CTRL_X_EVAL:</a>
<a name="ln537">    return (c == Ctrl_P || c == Ctrl_N);</a>
<a name="ln538">  }</a>
<a name="ln539">  internal_error(&quot;vim_is_ctrl_x_key()&quot;);</a>
<a name="ln540">  return false;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">/// @return  true if &quot;match&quot; is the original text when the completion began.</a>
<a name="ln544">static bool match_at_original_text(const compl_T *const match)</a>
<a name="ln545">{</a>
<a name="ln546">  return match-&gt;cp_flags &amp; CP_ORIGINAL_TEXT;</a>
<a name="ln547">}</a>
<a name="ln548"> </a>
<a name="ln549">/// @return  true if &quot;match&quot; is the first match in the completion list.</a>
<a name="ln550">static bool is_first_match(const compl_T *const match)</a>
<a name="ln551">{</a>
<a name="ln552">  return match == compl_first_match;</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">/// Check that character &quot;c&quot; is part of the item currently being</a>
<a name="ln556">/// completed.  Used to decide whether to abandon complete mode when the menu</a>
<a name="ln557">/// is visible.</a>
<a name="ln558">///</a>
<a name="ln559">/// @param  c  character to check</a>
<a name="ln560">bool ins_compl_accept_char(int c)</a>
<a name="ln561">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln562">{</a>
<a name="ln563">  if (ctrl_x_mode &amp; CTRL_X_WANT_IDENT) {</a>
<a name="ln564">    // When expanding an identifier only accept identifier chars.</a>
<a name="ln565">    return vim_isIDc(c);</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  switch (ctrl_x_mode) {</a>
<a name="ln569">  case CTRL_X_FILES:</a>
<a name="ln570">    // When expanding file name only accept file name chars. But not</a>
<a name="ln571">    // path separators, so that &quot;proto/&lt;Tab&gt;&quot; expands files in</a>
<a name="ln572">    // &quot;proto&quot;, not &quot;proto/&quot; as a whole</a>
<a name="ln573">    return vim_isfilec(c) &amp;&amp; !vim_ispathsep(c);</a>
<a name="ln574"> </a>
<a name="ln575">  case CTRL_X_CMDLINE:</a>
<a name="ln576">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln577">  case CTRL_X_OMNI:</a>
<a name="ln578">    // Command line and Omni completion can work with just about any</a>
<a name="ln579">    // printable character, but do stop at white space.</a>
<a name="ln580">    return vim_isprintc(c) &amp;&amp; !ascii_iswhite(c);</a>
<a name="ln581"> </a>
<a name="ln582">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln583">    // For while line completion a space can be part of the line.</a>
<a name="ln584">    return vim_isprintc(c);</a>
<a name="ln585">  }</a>
<a name="ln586">  return vim_iswordc(c);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">/// Get the completed text by inferring the case of the originally typed text.</a>
<a name="ln590">/// If the result is in allocated memory &quot;tofree&quot; is set to it.</a>
<a name="ln591">static char *ins_compl_infercase_gettext(const char *str, int char_len, int compl_char_len,</a>
<a name="ln592">                                         int min_len, char **tofree)</a>
<a name="ln593">{</a>
<a name="ln594">  bool has_lower = false;</a>
<a name="ln595">  bool was_letter = false;</a>
<a name="ln596"> </a>
<a name="ln597">  // Allocate wide character array for the completion and fill it.</a>
<a name="ln598">  int *const wca = xmalloc((size_t)char_len * sizeof(*wca));</a>
<a name="ln599">  {</a>
<a name="ln600">    const char *p = str;</a>
<a name="ln601">    for (int i = 0; i &lt; char_len; i++) {</a>
<a name="ln602">      wca[i] = mb_ptr2char_adv(&amp;p);</a>
<a name="ln603">    }</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  // Rule 1: Were any chars converted to lower?</a>
<a name="ln607">  {</a>
<a name="ln608">    const char *p = compl_orig_text;</a>
<a name="ln609">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln610">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln611">      if (mb_islower(c)) {</a>
<a name="ln612">        has_lower = true;</a>
<a name="ln613">        if (mb_isupper(wca[i])) {</a>
<a name="ln614">          // Rule 1 is satisfied.</a>
<a name="ln615">          for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln616">            wca[i] = mb_tolower(wca[i]);</a>
<a name="ln617">          }</a>
<a name="ln618">          break;</a>
<a name="ln619">        }</a>
<a name="ln620">      }</a>
<a name="ln621">    }</a>
<a name="ln622">  }</a>
<a name="ln623"> </a>
<a name="ln624">  // Rule 2: No lower case, 2nd consecutive letter converted to</a>
<a name="ln625">  // upper case.</a>
<a name="ln626">  if (!has_lower) {</a>
<a name="ln627">    const char *p = compl_orig_text;</a>
<a name="ln628">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln629">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln630">      if (was_letter &amp;&amp; mb_isupper(c) &amp;&amp; mb_islower(wca[i])) {</a>
<a name="ln631">        // Rule 2 is satisfied.</a>
<a name="ln632">        for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln633">          wca[i] = mb_toupper(wca[i]);</a>
<a name="ln634">        }</a>
<a name="ln635">        break;</a>
<a name="ln636">      }</a>
<a name="ln637">      was_letter = mb_islower(c) || mb_isupper(c);</a>
<a name="ln638">    }</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641">  // Copy the original case of the part we typed.</a>
<a name="ln642">  {</a>
<a name="ln643">    const char *p = compl_orig_text;</a>
<a name="ln644">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln645">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln646">      if (mb_islower(c)) {</a>
<a name="ln647">        wca[i] = mb_tolower(wca[i]);</a>
<a name="ln648">      } else if (mb_isupper(c)) {</a>
<a name="ln649">        wca[i] = mb_toupper(wca[i]);</a>
<a name="ln650">      }</a>
<a name="ln651">    }</a>
<a name="ln652">  }</a>
<a name="ln653"> </a>
<a name="ln654">  // Generate encoding specific output from wide character array.</a>
<a name="ln655">  garray_T gap;</a>
<a name="ln656">  char *p = IObuff;</a>
<a name="ln657">  int i = 0;</a>
<a name="ln658">  ga_init(&amp;gap, 1, 500);</a>
<a name="ln659">  while (i &lt; char_len) {</a>
<a name="ln660">    if (gap.ga_data != NULL) {</a>
<a name="ln661">      ga_grow(&amp;gap, 10);</a>
<a name="ln662">      assert(gap.ga_data != NULL);  // suppress clang &quot;Dereference of NULL pointer&quot;</a>
<a name="ln663">      p = (char *)gap.ga_data + gap.ga_len;</a>
<a name="ln664">      gap.ga_len += utf_char2bytes(wca[i++], p);</a>
<a name="ln665">    } else if ((p - IObuff) + 6 &gt;= IOSIZE) {</a>
<a name="ln666">      // Multi-byte characters can occupy up to five bytes more than</a>
<a name="ln667">      // ASCII characters, and we also need one byte for NUL, so when</a>
<a name="ln668">      // getting to six bytes from the edge of IObuff switch to using a</a>
<a name="ln669">      // growarray.  Add the character in the next round.</a>
<a name="ln670">      ga_grow(&amp;gap, IOSIZE);</a>
<a name="ln671">      *p = NUL;</a>
<a name="ln672">      STRCPY(gap.ga_data, IObuff);</a>
<a name="ln673">      gap.ga_len = (int)strlen(IObuff);</a>
<a name="ln674">    } else {</a>
<a name="ln675">      p += utf_char2bytes(wca[i++], p);</a>
<a name="ln676">    }</a>
<a name="ln677">  }</a>
<a name="ln678">  xfree(wca);</a>
<a name="ln679"> </a>
<a name="ln680">  if (gap.ga_data != NULL) {</a>
<a name="ln681">    *tofree = gap.ga_data;</a>
<a name="ln682">    return gap.ga_data;</a>
<a name="ln683">  }</a>
<a name="ln684"> </a>
<a name="ln685">  *p = NUL;</a>
<a name="ln686">  return IObuff;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">/// This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the</a>
<a name="ln690">/// case of the originally typed text is used, and the case of the completed</a>
<a name="ln691">/// text is inferred, ie this tries to work out what case you probably wanted</a>
<a name="ln692">/// the rest of the word to be in -- webb</a>
<a name="ln693">///</a>
<a name="ln694">/// @param[in]  cont_s_ipos  next ^X&lt;&gt; will set initial_pos</a>
<a name="ln695">int ins_compl_add_infercase(char *str_arg, int len, bool icase, char *fname, Direction dir,</a>
<a name="ln696">                            bool cont_s_ipos)</a>
<a name="ln697">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln698">{</a>
<a name="ln699">  char *str = str_arg;</a>
<a name="ln700">  int char_len;  // count multi-byte characters</a>
<a name="ln701">  int compl_char_len;</a>
<a name="ln702">  int flags = 0;</a>
<a name="ln703">  char *tofree = NULL;</a>
<a name="ln704"> </a>
<a name="ln705">  if (p_ic &amp;&amp; curbuf-&gt;b_p_inf &amp;&amp; len &gt; 0) {</a>
<a name="ln706">    // Infer case of completed part.</a>
<a name="ln707"> </a>
<a name="ln708">    // Find actual length of completion.</a>
<a name="ln709">    {</a>
<a name="ln710">      const char *p = str;</a>
<a name="ln711">      char_len = 0;</a>
<a name="ln712">      while (*p != NUL) {</a>
<a name="ln713">        MB_PTR_ADV(p);</a>
<a name="ln714">        char_len++;</a>
<a name="ln715">      }</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">    // Find actual length of original text.</a>
<a name="ln719">    {</a>
<a name="ln720">      const char *p = compl_orig_text;</a>
<a name="ln721">      compl_char_len = 0;</a>
<a name="ln722">      while (*p != NUL) {</a>
<a name="ln723">        MB_PTR_ADV(p);</a>
<a name="ln724">        compl_char_len++;</a>
<a name="ln725">      }</a>
<a name="ln726">    }</a>
<a name="ln727"> </a>
<a name="ln728">    // &quot;char_len&quot; may be smaller than &quot;compl_char_len&quot; when using</a>
<a name="ln729">    // thesaurus, only use the minimum when comparing.</a>
<a name="ln730">    int min_len = char_len &lt; compl_char_len ? char_len : compl_char_len;</a>
<a name="ln731"> </a>
<a name="ln732">    str = ins_compl_infercase_gettext(str, char_len, compl_char_len, min_len, &amp;tofree);</a>
<a name="ln733">  }</a>
<a name="ln734">  if (cont_s_ipos) {</a>
<a name="ln735">    flags |= CP_CONT_S_IPOS;</a>
<a name="ln736">  }</a>
<a name="ln737">  if (icase) {</a>
<a name="ln738">    flags |= CP_ICASE;</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  int res = ins_compl_add(str, len, fname, NULL, false, NULL, dir, flags, false);</a>
<a name="ln742">  xfree(tofree);</a>
<a name="ln743">  return res;</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">/// Add a match to the list of matches</a>
<a name="ln747">///</a>
<a name="ln748">/// @param[in]  str     text of the match to add</a>
<a name="ln749">/// @param[in]  len     length of &quot;str&quot;. If -1, then the length of &quot;str&quot; is computed.</a>
<a name="ln750">/// @param[in]  fname   file name to associate with this match. May be NULL.</a>
<a name="ln751">/// @param[in]  cptext  list of strings to use with this match (for abbr, menu, info</a>
<a name="ln752">///                     and kind). May be NULL.</a>
<a name="ln753">///                     If not NULL, must have exactly #CPT_COUNT items.</a>
<a name="ln754">/// @param[in]  cptext_allocated  If true, will not copy cptext strings.</a>
<a name="ln755">///</a>
<a name="ln756">///                               @note Will free strings in case of error.</a>
<a name="ln757">///                                     cptext itself will not be freed.</a>
<a name="ln758">/// @param[in]  user_data  user supplied data (any vim type) for this match</a>
<a name="ln759">/// @param[in]  cdir       match direction. If 0, use &quot;compl_direction&quot;.</a>
<a name="ln760">/// @param[in]  flags_arg  match flags (cp_flags)</a>
<a name="ln761">/// @param[in]  adup       accept this match even if it is already present.</a>
<a name="ln762">///</a>
<a name="ln763">/// If &quot;cdir&quot; is FORWARD, then the match is added after the current match.</a>
<a name="ln764">/// Otherwise, it is added before the current match.</a>
<a name="ln765">///</a>
<a name="ln766">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln767">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln768">///         returned in case of error.</a>
<a name="ln769">static int ins_compl_add(char *const str, int len, char *const fname, char *const *const cptext,</a>
<a name="ln770">                         const bool cptext_allocated, typval_T *user_data, const Direction cdir,</a>
<a name="ln771">                         int flags_arg, const bool adup)</a>
<a name="ln772">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln773">{</a>
<a name="ln774">  compl_T *match;</a>
<a name="ln775">  const Direction dir = (cdir == kDirectionNotSet ? compl_direction : cdir);</a>
<a name="ln776">  int flags = flags_arg;</a>
<a name="ln777"> </a>
<a name="ln778">  if (flags &amp; CP_FAST) {</a>
<a name="ln779">    fast_breakcheck();</a>
<a name="ln780">  } else {</a>
<a name="ln781">    os_breakcheck();</a>
<a name="ln782">  }</a>
<a name="ln783">#define FREE_CPTEXT(cptext, cptext_allocated) \</a>
<a name="ln784">  do { \</a>
<a name="ln785">    if ((cptext) != NULL &amp;&amp; (cptext_allocated)) { \</a>
<a name="ln786">      for (size_t i = 0; i &lt; CPT_COUNT; i++) { \</a>
<a name="ln787">        xfree((cptext)[i]); \</a>
<a name="ln788">      } \</a>
<a name="ln789">    } \</a>
<a name="ln790">  } while (0)</a>
<a name="ln791">  if (got_int) {</a>
<a name="ln792">    FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln793">    return FAIL;</a>
<a name="ln794">  }</a>
<a name="ln795">  if (len &lt; 0) {</a>
<a name="ln796">    len = (int)strlen(str);</a>
<a name="ln797">  }</a>
<a name="ln798"> </a>
<a name="ln799">  // If the same match is already present, don't add it.</a>
<a name="ln800">  if (compl_first_match != NULL &amp;&amp; !adup) {</a>
<a name="ln801">    match = compl_first_match;</a>
<a name="ln802">    do {</a>
<a name="ln803">      if (!match_at_original_text(match)</a>
<a name="ln804">          &amp;&amp; strncmp(match-&gt;cp_str, str, (size_t)len) == 0</a>
<a name="ln805">          &amp;&amp; ((int)strlen(match-&gt;cp_str) &lt;= len || match-&gt;cp_str[len] == NUL)) {</a>
<a name="ln806">        FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln807">        return NOTDONE;</a>
<a name="ln808">      }</a>
<a name="ln809">      match = match-&gt;cp_next;</a>
<a name="ln810">    } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln811">  }</a>
<a name="ln812"> </a>
<a name="ln813">  // Remove any popup menu before changing the list of matches.</a>
<a name="ln814">  ins_compl_del_pum();</a>
<a name="ln815"> </a>
<a name="ln816">  // Allocate a new match structure.</a>
<a name="ln817">  // Copy the values to the new match structure.</a>
<a name="ln818">  match = xcalloc(1, sizeof(compl_T));</a>
<a name="ln819">  match-&gt;cp_number = -1;</a>
<a name="ln820">  if (flags &amp; CP_ORIGINAL_TEXT) {</a>
<a name="ln821">    match-&gt;cp_number = 0;</a>
<a name="ln822">  }</a>
<a name="ln823">  match-&gt;cp_str = xstrnsave(str, (size_t)len);</a>
<a name="ln824"> </a>
<a name="ln825">  // match-fname is:</a>
<a name="ln826">  // - compl_curr_match-&gt;cp_fname if it is a string equal to fname.</a>
<a name="ln827">  // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.</a>
<a name="ln828">  // - NULL otherwise.  --Acevedo</a>
<a name="ln829">  if (fname != NULL</a>
<a name="ln830">      &amp;&amp; compl_curr_match != NULL</a>
<a name="ln831">      &amp;&amp; compl_curr_match-&gt;cp_fname != NULL</a>
<a name="ln832">      &amp;&amp; strcmp(fname, compl_curr_match-&gt;cp_fname) == 0) {</a>
<a name="ln833">    match-&gt;cp_fname = compl_curr_match-&gt;cp_fname;</a>
<a name="ln834">  } else if (fname != NULL) {</a>
<a name="ln835">    match-&gt;cp_fname = xstrdup(fname);</a>
<a name="ln836">    flags |= CP_FREE_FNAME;</a>
<a name="ln837">  } else {</a>
<a name="ln838">    match-&gt;cp_fname = NULL;</a>
<a name="ln839">  }</a>
<a name="ln840">  match-&gt;cp_flags = flags;</a>
<a name="ln841"> </a>
<a name="ln842">  if (cptext != NULL) {</a>
<a name="ln843">    int i;</a>
<a name="ln844"> </a>
<a name="ln845">    for (i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln846">      if (cptext[i] == NULL) {</a>
<a name="ln847">        continue;</a>
<a name="ln848">      }</a>
<a name="ln849">      if (*cptext[i] != NUL) {</a>
<a name="ln850">        match-&gt;cp_text[i] = (cptext_allocated ? cptext[i] : xstrdup(cptext[i]));</a>
<a name="ln851">      } else if (cptext_allocated) {</a>
<a name="ln852">        xfree(cptext[i]);</a>
<a name="ln853">      }</a>
<a name="ln854">    }</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  if (user_data != NULL) {</a>
<a name="ln858">    match-&gt;cp_user_data = *user_data;</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  // Link the new match structure after (FORWARD) or before (BACKWARD) the</a>
<a name="ln862">  // current match in the list of matches .</a>
<a name="ln863">  if (compl_first_match == NULL) {</a>
<a name="ln864">    match-&gt;cp_next = match-&gt;cp_prev = NULL;</a>
<a name="ln865">  } else if (dir == FORWARD) {</a>
<a name="ln866">    match-&gt;cp_next = compl_curr_match-&gt;cp_next;</a>
<a name="ln867">    match-&gt;cp_prev = compl_curr_match;</a>
<a name="ln868">  } else {    // BACKWARD</a>
<a name="ln869">    match-&gt;cp_next = compl_curr_match;</a>
<a name="ln870">    match-&gt;cp_prev = compl_curr_match-&gt;cp_prev;</a>
<a name="ln871">  }</a>
<a name="ln872">  if (match-&gt;cp_next) {</a>
<a name="ln873">    match-&gt;cp_next-&gt;cp_prev = match;</a>
<a name="ln874">  }</a>
<a name="ln875">  if (match-&gt;cp_prev) {</a>
<a name="ln876">    match-&gt;cp_prev-&gt;cp_next = match;</a>
<a name="ln877">  } else {        // if there's nothing before, it is the first match</a>
<a name="ln878">    compl_first_match = match;</a>
<a name="ln879">  }</a>
<a name="ln880">  compl_curr_match = match;</a>
<a name="ln881"> </a>
<a name="ln882">  // Find the longest common string if still doing that.</a>
<a name="ln883">  if (compl_get_longest &amp;&amp; (flags &amp; CP_ORIGINAL_TEXT) == 0) {</a>
<a name="ln884">    ins_compl_longest_match(match);</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  return OK;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">/// Check that &quot;str[len]&quot; matches with &quot;match-&gt;cp_str&quot;, considering</a>
<a name="ln891">/// &quot;match-&gt;cp_flags&quot;.</a>
<a name="ln892">///</a>
<a name="ln893">/// @param  match  completion match</a>
<a name="ln894">/// @param  str    character string to check</a>
<a name="ln895">/// @param  len    length of &quot;str&quot;</a>
<a name="ln896">static bool ins_compl_equal(compl_T *match, char *str, size_t len)</a>
<a name="ln897">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln898">{</a>
<a name="ln899">  if (match-&gt;cp_flags &amp; CP_EQUAL) {</a>
<a name="ln900">    return true;</a>
<a name="ln901">  }</a>
<a name="ln902">  if (match-&gt;cp_flags &amp; CP_ICASE) {</a>
<a name="ln903">    return STRNICMP(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln904">  }</a>
<a name="ln905">  return strncmp(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln906">}</a>
<a name="ln907"> </a>
<a name="ln908">/// Reduce the longest common string for match &quot;match&quot;.</a>
<a name="ln909">static void ins_compl_longest_match(compl_T *match)</a>
<a name="ln910">{</a>
<a name="ln911">  char *p, *s;</a>
<a name="ln912">  int c1, c2;</a>
<a name="ln913">  int had_match;</a>
<a name="ln914"> </a>
<a name="ln915">  if (compl_leader == NULL) {</a>
<a name="ln916">    // First match, use it as a whole.</a>
<a name="ln917">    compl_leader = xstrdup(match-&gt;cp_str);</a>
<a name="ln918"> </a>
<a name="ln919">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln920">    ins_compl_delete();</a>
<a name="ln921">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln922">    ins_redraw(false);</a>
<a name="ln923"> </a>
<a name="ln924">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln925">    // again after redrawing.</a>
<a name="ln926">    if (!had_match) {</a>
<a name="ln927">      ins_compl_delete();</a>
<a name="ln928">    }</a>
<a name="ln929">    compl_used_match = false;</a>
<a name="ln930"> </a>
<a name="ln931">    return;</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  // Reduce the text if this match differs from compl_leader.</a>
<a name="ln935">  p = compl_leader;</a>
<a name="ln936">  s = match-&gt;cp_str;</a>
<a name="ln937">  while (*p != NUL) {</a>
<a name="ln938">    c1 = utf_ptr2char(p);</a>
<a name="ln939">    c2 = utf_ptr2char(s);</a>
<a name="ln940"> </a>
<a name="ln941">    if ((match-&gt;cp_flags &amp; CP_ICASE)</a>
<a name="ln942">        ? (mb_tolower(c1) != mb_tolower(c2))</a>
<a name="ln943">        : (c1 != c2)) {</a>
<a name="ln944">      break;</a>
<a name="ln945">    }</a>
<a name="ln946">    MB_PTR_ADV(p);</a>
<a name="ln947">    MB_PTR_ADV(s);</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  if (*p != NUL) {</a>
<a name="ln951">    // Leader was shortened, need to change the inserted text.</a>
<a name="ln952">    *p = NUL;</a>
<a name="ln953">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln954">    ins_compl_delete();</a>
<a name="ln955">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln956">    ins_redraw(false);</a>
<a name="ln957"> </a>
<a name="ln958">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln959">    // again after redrawing.</a>
<a name="ln960">    if (!had_match) {</a>
<a name="ln961">      ins_compl_delete();</a>
<a name="ln962">    }</a>
<a name="ln963">  }</a>
<a name="ln964"> </a>
<a name="ln965">  compl_used_match = false;</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">/// Add an array of matches to the list of matches.</a>
<a name="ln969">/// Frees matches[].</a>
<a name="ln970">static void ins_compl_add_matches(int num_matches, char **matches, int icase)</a>
<a name="ln971">{</a>
<a name="ln972">  int add_r = OK;</a>
<a name="ln973">  Direction dir = compl_direction;</a>
<a name="ln974"> </a>
<a name="ln975">  for (int i = 0; i &lt; num_matches &amp;&amp; add_r != FAIL; i++) {</a>
<a name="ln976">    if ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, false, NULL, dir,</a>
<a name="ln977">                               CP_FAST | (icase ? CP_ICASE : 0),</a>
<a name="ln978">                               false)) == OK) {</a>
<a name="ln979">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln980">      dir = FORWARD;</a>
<a name="ln981">    }</a>
<a name="ln982">  }</a>
<a name="ln983">  FreeWild(num_matches, matches);</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">/// Make the completion list cyclic.</a>
<a name="ln987">/// Return the number of matches (excluding the original).</a>
<a name="ln988">static int ins_compl_make_cyclic(void)</a>
<a name="ln989">{</a>
<a name="ln990">  if (compl_first_match == NULL) {</a>
<a name="ln991">    return 0;</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  // Find the end of the list.</a>
<a name="ln995">  compl_T *match = compl_first_match;</a>
<a name="ln996">  int count = 0;</a>
<a name="ln997">  // there's always an entry for the compl_orig_text, it doesn't count.</a>
<a name="ln998">  while (match-&gt;cp_next != NULL &amp;&amp; !is_first_match(match-&gt;cp_next)) {</a>
<a name="ln999">    match = match-&gt;cp_next;</a>
<a name="ln1000">    count++;</a>
<a name="ln1001">  }</a>
<a name="ln1002">  match-&gt;cp_next = compl_first_match;</a>
<a name="ln1003">  compl_first_match-&gt;cp_prev = match;</a>
<a name="ln1004"> </a>
<a name="ln1005">  return count;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">/// Return whether there currently is a shown match.</a>
<a name="ln1009">bool ins_compl_has_shown_match(void)</a>
<a name="ln1010">{</a>
<a name="ln1011">  return compl_shown_match == NULL || compl_shown_match != compl_shown_match-&gt;cp_next;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">/// Return whether the shown match is long enough.</a>
<a name="ln1015">bool ins_compl_long_shown_match(void)</a>
<a name="ln1016">{</a>
<a name="ln1017">  return compl_shown_match != NULL &amp;&amp; compl_shown_match-&gt;cp_str != NULL</a>
<a name="ln1018">         &amp;&amp; (colnr_T)strlen(compl_shown_match-&gt;cp_str) &gt; curwin-&gt;w_cursor.col - compl_col;</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">/// Set variables that store noselect and noinsert behavior from the</a>
<a name="ln1022">/// 'completeopt' value.</a>
<a name="ln1023">void completeopt_was_set(void)</a>
<a name="ln1024">{</a>
<a name="ln1025">  compl_no_insert = false;</a>
<a name="ln1026">  compl_no_select = false;</a>
<a name="ln1027">  compl_longest = false;</a>
<a name="ln1028">  if (strstr(p_cot, &quot;noselect&quot;) != NULL) {</a>
<a name="ln1029">    compl_no_select = true;</a>
<a name="ln1030">  }</a>
<a name="ln1031">  if (strstr(p_cot, &quot;noinsert&quot;) != NULL) {</a>
<a name="ln1032">    compl_no_insert = true;</a>
<a name="ln1033">  }</a>
<a name="ln1034">  if (strstr(p_cot, &quot;longest&quot;) != NULL) {</a>
<a name="ln1035">    compl_longest = true;</a>
<a name="ln1036">  }</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">/// &quot;compl_match_array&quot; points the currently displayed list of entries in the</a>
<a name="ln1040">/// popup menu.  It is NULL when there is no popup menu.</a>
<a name="ln1041">static pumitem_T *compl_match_array = NULL;</a>
<a name="ln1042">static int compl_match_arraysize;</a>
<a name="ln1043"> </a>
<a name="ln1044">/// Remove any popup menu.</a>
<a name="ln1045">static void ins_compl_del_pum(void)</a>
<a name="ln1046">{</a>
<a name="ln1047">  if (compl_match_array == NULL) {</a>
<a name="ln1048">    return;</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  pum_undisplay(false);</a>
<a name="ln1052">  XFREE_CLEAR(compl_match_array);</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">/// Check if the popup menu should be displayed.</a>
<a name="ln1056">bool pum_wanted(void)</a>
<a name="ln1057">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1058">{</a>
<a name="ln1059">  // &quot;completeopt&quot; must contain &quot;menu&quot; or &quot;menuone&quot;</a>
<a name="ln1060">  return vim_strchr(p_cot, 'm') != NULL;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">/// Check that there are two or more matches to be shown in the popup menu.</a>
<a name="ln1064">/// One if &quot;completopt&quot; contains &quot;menuone&quot;.</a>
<a name="ln1065">static bool pum_enough_matches(void)</a>
<a name="ln1066">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1067">{</a>
<a name="ln1068">  // Don't display the popup menu if there are no matches or there is only</a>
<a name="ln1069">  // one (ignoring the original text).</a>
<a name="ln1070">  compl_T *comp = compl_first_match;</a>
<a name="ln1071">  int i = 0;</a>
<a name="ln1072">  do {</a>
<a name="ln1073">    if (comp == NULL || (!match_at_original_text(comp) &amp;&amp; ++i == 2)) {</a>
<a name="ln1074">      break;</a>
<a name="ln1075">    }</a>
<a name="ln1076">    comp = comp-&gt;cp_next;</a>
<a name="ln1077">  } while (!is_first_match(comp));</a>
<a name="ln1078"> </a>
<a name="ln1079">  if (strstr(p_cot, &quot;menuone&quot;) != NULL) {</a>
<a name="ln1080">    return i &gt;= 1;</a>
<a name="ln1081">  }</a>
<a name="ln1082">  return i &gt;= 2;</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/// Convert to complete item dict</a>
<a name="ln1086">static dict_T *ins_compl_dict_alloc(compl_T *match)</a>
<a name="ln1087">{</a>
<a name="ln1088">  // { word, abbr, menu, kind, info }</a>
<a name="ln1089">  dict_T *dict = tv_dict_alloc_lock(VAR_FIXED);</a>
<a name="ln1090">  tv_dict_add_str(dict, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln1091">  tv_dict_add_str(dict, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln1092">  tv_dict_add_str(dict, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln1093">  tv_dict_add_str(dict, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln1094">  tv_dict_add_str(dict, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln1095">  if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln1096">    tv_dict_add_str(dict, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln1097">  } else {</a>
<a name="ln1098">    tv_dict_add_tv(dict, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln1099">  }</a>
<a name="ln1100">  return dict;</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">/// Trigger the CompleteChanged autocmd event. Invoked each time the Insert mode</a>
<a name="ln1104">/// completion menu is changed.</a>
<a name="ln1105">static void trigger_complete_changed_event(int cur)</a>
<a name="ln1106">{</a>
<a name="ln1107">  static bool recursive = false;</a>
<a name="ln1108">  save_v_event_T save_v_event;</a>
<a name="ln1109"> </a>
<a name="ln1110">  if (recursive) {</a>
<a name="ln1111">    return;</a>
<a name="ln1112">  }</a>
<a name="ln1113"> </a>
<a name="ln1114">  dict_T *v_event = get_v_event(&amp;save_v_event);</a>
<a name="ln1115">  if (cur &lt; 0) {</a>
<a name="ln1116">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), tv_dict_alloc());</a>
<a name="ln1117">  } else {</a>
<a name="ln1118">    dict_T *item = ins_compl_dict_alloc(compl_curr_match);</a>
<a name="ln1119">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), item);</a>
<a name="ln1120">  }</a>
<a name="ln1121">  pum_set_event_info(v_event);</a>
<a name="ln1122">  tv_dict_set_keys_readonly(v_event);</a>
<a name="ln1123"> </a>
<a name="ln1124">  recursive = true;</a>
<a name="ln1125">  textlock++;</a>
<a name="ln1126">  apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, false, curbuf);</a>
<a name="ln1127">  textlock--;</a>
<a name="ln1128">  recursive = false;</a>
<a name="ln1129"> </a>
<a name="ln1130">  restore_v_event(v_event, &amp;save_v_event);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">/// Build a popup menu to show the completion matches.</a>
<a name="ln1134">///</a>
<a name="ln1135">/// @return  the popup menu entry that should be selected,</a>
<a name="ln1136">///          -1 if nothing should be selected.</a>
<a name="ln1137">static int ins_compl_build_pum(void)</a>
<a name="ln1138">{</a>
<a name="ln1139">  // Need to build the popup menu list.</a>
<a name="ln1140">  compl_match_arraysize = 0;</a>
<a name="ln1141">  compl_T *comp = compl_first_match;</a>
<a name="ln1142"> </a>
<a name="ln1143">  // If it's user complete function and refresh_always,</a>
<a name="ln1144">  // do not use &quot;compl_leader&quot; as prefix filter.</a>
<a name="ln1145">  if (ins_compl_need_restart()) {</a>
<a name="ln1146">    XFREE_CLEAR(compl_leader);</a>
<a name="ln1147">  }</a>
<a name="ln1148"> </a>
<a name="ln1149">  const int lead_len = compl_leader != NULL ? (int)strlen(compl_leader) : 0;</a>
<a name="ln1150"> </a>
<a name="ln1151">  do {</a>
<a name="ln1152">    if (!match_at_original_text(comp)</a>
<a name="ln1153">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1154">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1155">      compl_match_arraysize++;</a>
<a name="ln1156">    }</a>
<a name="ln1157">    comp = comp-&gt;cp_next;</a>
<a name="ln1158">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1159"> </a>
<a name="ln1160">  if (compl_match_arraysize == 0) {</a>
<a name="ln1161">    return -1;</a>
<a name="ln1162">  }</a>
<a name="ln1163"> </a>
<a name="ln1164">  assert(compl_match_arraysize &gt;= 0);</a>
<a name="ln1165">  compl_match_array = xcalloc((size_t)compl_match_arraysize, sizeof(pumitem_T));</a>
<a name="ln1166"> </a>
<a name="ln1167">  // If the current match is the original text don't find the first</a>
<a name="ln1168">  // match after it, don't highlight anything.</a>
<a name="ln1169">  bool shown_match_ok = match_at_original_text(compl_shown_match);</a>
<a name="ln1170"> </a>
<a name="ln1171">  compl_T *shown_compl = NULL;</a>
<a name="ln1172">  bool did_find_shown_match = false;</a>
<a name="ln1173">  int cur = -1;</a>
<a name="ln1174">  int i = 0;</a>
<a name="ln1175">  comp = compl_first_match;</a>
<a name="ln1176">  do {</a>
<a name="ln1177">    if (!match_at_original_text(comp)</a>
<a name="ln1178">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1179">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1180">      if (!shown_match_ok) {</a>
<a name="ln1181">        if (comp == compl_shown_match || did_find_shown_match) {</a>
<a name="ln1182">          // This item is the shown match or this is the</a>
<a name="ln1183">          // first displayed item after the shown match.</a>
<a name="ln1184">          compl_shown_match = comp;</a>
<a name="ln1185">          did_find_shown_match = true;</a>
<a name="ln1186">          shown_match_ok = true;</a>
<a name="ln1187">        } else {</a>
<a name="ln1188">          // Remember this displayed match for when the</a>
<a name="ln1189">          // shown match is just below it.</a>
<a name="ln1190">          shown_compl = comp;</a>
<a name="ln1191">        }</a>
<a name="ln1192">        cur = i;</a>
<a name="ln1193">      }</a>
<a name="ln1194"> </a>
<a name="ln1195">      if (comp-&gt;cp_text[CPT_ABBR] != NULL) {</a>
<a name="ln1196">        compl_match_array[i].pum_text = comp-&gt;cp_text[CPT_ABBR];</a>
<a name="ln1197">      } else {</a>
<a name="ln1198">        compl_match_array[i].pum_text = comp-&gt;cp_str;</a>
<a name="ln1199">      }</a>
<a name="ln1200">      compl_match_array[i].pum_kind = comp-&gt;cp_text[CPT_KIND];</a>
<a name="ln1201">      compl_match_array[i].pum_info = comp-&gt;cp_text[CPT_INFO];</a>
<a name="ln1202">      if (comp-&gt;cp_text[CPT_MENU] != NULL) {</a>
<a name="ln1203">        compl_match_array[i++].pum_extra = comp-&gt;cp_text[CPT_MENU];</a>
<a name="ln1204">      } else {</a>
<a name="ln1205">        compl_match_array[i++].pum_extra = comp-&gt;cp_fname;</a>
<a name="ln1206">      }</a>
<a name="ln1207">    }</a>
<a name="ln1208"> </a>
<a name="ln1209">    if (comp == compl_shown_match) {</a>
<a name="ln1210">      did_find_shown_match = true;</a>
<a name="ln1211"> </a>
<a name="ln1212">      // When the original text is the shown match don't set</a>
<a name="ln1213">      // compl_shown_match.</a>
<a name="ln1214">      if (match_at_original_text(comp)) {</a>
<a name="ln1215">        shown_match_ok = true;</a>
<a name="ln1216">      }</a>
<a name="ln1217"> </a>
<a name="ln1218">      if (!shown_match_ok &amp;&amp; shown_compl != NULL) {</a>
<a name="ln1219">        // The shown match isn't displayed, set it to the</a>
<a name="ln1220">        // previously displayed match.</a>
<a name="ln1221">        compl_shown_match = shown_compl;</a>
<a name="ln1222">        shown_match_ok = true;</a>
<a name="ln1223">      }</a>
<a name="ln1224">    }</a>
<a name="ln1225">    comp = comp-&gt;cp_next;</a>
<a name="ln1226">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1227"> </a>
<a name="ln1228">  if (!shown_match_ok) {  // no displayed match at all</a>
<a name="ln1229">    cur = -1;</a>
<a name="ln1230">  }</a>
<a name="ln1231"> </a>
<a name="ln1232">  return cur;</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">/// Show the popup menu for the list of matches.</a>
<a name="ln1236">/// Also adjusts &quot;compl_shown_match&quot; to an entry that is actually displayed.</a>
<a name="ln1237">void ins_compl_show_pum(void)</a>
<a name="ln1238">{</a>
<a name="ln1239">  if (!pum_wanted() || !pum_enough_matches()) {</a>
<a name="ln1240">    return;</a>
<a name="ln1241">  }</a>
<a name="ln1242"> </a>
<a name="ln1243">  // Dirty hard-coded hack: remove any matchparen highlighting.</a>
<a name="ln1244">  do_cmdline_cmd(&quot;if exists('g:loaded_matchparen')|3match none|endif&quot;);</a>
<a name="ln1245"> </a>
<a name="ln1246">  // Update the screen before drawing the popup menu over it.</a>
<a name="ln1247">  update_screen();</a>
<a name="ln1248"> </a>
<a name="ln1249">  int cur = -1;</a>
<a name="ln1250">  bool array_changed = false;</a>
<a name="ln1251"> </a>
<a name="ln1252">  if (compl_match_array == NULL) {</a>
<a name="ln1253">    array_changed = true;</a>
<a name="ln1254">    // Need to build the popup menu list.</a>
<a name="ln1255">    cur = ins_compl_build_pum();</a>
<a name="ln1256">  } else {</a>
<a name="ln1257">    // popup menu already exists, only need to find the current item.</a>
<a name="ln1258">    for (int i = 0; i &lt; compl_match_arraysize; i++) {</a>
<a name="ln1259">      if (compl_match_array[i].pum_text == compl_shown_match-&gt;cp_str</a>
<a name="ln1260">          || compl_match_array[i].pum_text == compl_shown_match-&gt;cp_text[CPT_ABBR]) {</a>
<a name="ln1261">        cur = i;</a>
<a name="ln1262">        break;</a>
<a name="ln1263">      }</a>
<a name="ln1264">    }</a>
<a name="ln1265">  }</a>
<a name="ln1266"> </a>
<a name="ln1267">  if (compl_match_array == NULL) {</a>
<a name="ln1268">    return;</a>
<a name="ln1269">  }</a>
<a name="ln1270"> </a>
<a name="ln1271">  // In Replace mode when a $ is displayed at the end of the line only</a>
<a name="ln1272">  // part of the screen would be updated.  We do need to redraw here.</a>
<a name="ln1273">  dollar_vcol = -1;</a>
<a name="ln1274"> </a>
<a name="ln1275">  // Compute the screen column of the start of the completed text.</a>
<a name="ln1276">  // Use the cursor to get all wrapping and other settings right.</a>
<a name="ln1277">  const colnr_T col = curwin-&gt;w_cursor.col;</a>
<a name="ln1278">  curwin-&gt;w_cursor.col = compl_col;</a>
<a name="ln1279">  pum_selected_item = cur;</a>
<a name="ln1280">  pum_display(compl_match_array, compl_match_arraysize, cur, array_changed, 0);</a>
<a name="ln1281">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1282"> </a>
<a name="ln1283">  if (has_event(EVENT_COMPLETECHANGED)) {</a>
<a name="ln1284">    trigger_complete_changed_event(cur);</a>
<a name="ln1285">  }</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">#define DICT_FIRST      (1)     ///&lt; use just first element in &quot;dict&quot;</a>
<a name="ln1289">#define DICT_EXACT      (2)     ///&lt; &quot;dict&quot; is the exact name of a file</a>
<a name="ln1290"> </a>
<a name="ln1291">/// Add any identifiers that match the given pattern &quot;pat&quot; in the list of</a>
<a name="ln1292">/// dictionary files &quot;dict_start&quot; to the list of completions.</a>
<a name="ln1293">///</a>
<a name="ln1294">/// @param flags      DICT_FIRST and/or DICT_EXACT</a>
<a name="ln1295">/// @param thesaurus  Thesaurus completion</a>
<a name="ln1296">static void ins_compl_dictionaries(char *dict_start, char *pat, int flags, int thesaurus)</a>
<a name="ln1297">{</a>
<a name="ln1298">  char *dict = dict_start;</a>
<a name="ln1299">  char *ptr;</a>
<a name="ln1300">  char *buf;</a>
<a name="ln1301">  regmatch_T regmatch;</a>
<a name="ln1302">  char **files;</a>
<a name="ln1303">  int count;</a>
<a name="ln1304">  int save_p_scs;</a>
<a name="ln1305">  Direction dir = compl_direction;</a>
<a name="ln1306"> </a>
<a name="ln1307">  if (*dict == NUL) {</a>
<a name="ln1308">    // When 'dictionary' is empty and spell checking is enabled use</a>
<a name="ln1309">    // &quot;spell&quot;.</a>
<a name="ln1310">    if (!thesaurus &amp;&amp; curwin-&gt;w_p_spell) {</a>
<a name="ln1311">      dict = &quot;spell&quot;;</a>
<a name="ln1312">    } else {</a>
<a name="ln1313">      return;</a>
<a name="ln1314">    }</a>
<a name="ln1315">  }</a>
<a name="ln1316"> </a>
<a name="ln1317">  buf = xmalloc(LSIZE);</a>
<a name="ln1318">  regmatch.regprog = NULL;      // so that we can goto theend</a>
<a name="ln1319"> </a>
<a name="ln1320">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln1321">  save_p_scs = p_scs;</a>
<a name="ln1322">  if (curbuf-&gt;b_p_inf) {</a>
<a name="ln1323">    p_scs = false;</a>
<a name="ln1324">  }</a>
<a name="ln1325"> </a>
<a name="ln1326">  // When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern</a>
<a name="ln1327">  // to only match at the start of a line.  Otherwise just match the</a>
<a name="ln1328">  // pattern. Also need to double backslashes.</a>
<a name="ln1329">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1330">    char *pat_esc = vim_strsave_escaped(pat, &quot;\\&quot;);</a>
<a name="ln1331"> </a>
<a name="ln1332">    size_t len = strlen(pat_esc) + 10;</a>
<a name="ln1333">    ptr = xmalloc(len);</a>
<a name="ln1334">    vim_snprintf(ptr, len, &quot;^\\s*\\zs\\V%s&quot;, pat_esc);</a>
<a name="ln1335">    regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);</a>
<a name="ln1336">    xfree(pat_esc);</a>
<a name="ln1337">    xfree(ptr);</a>
<a name="ln1338">  } else {</a>
<a name="ln1339">    regmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);</a>
<a name="ln1340">    if (regmatch.regprog == NULL) {</a>
<a name="ln1341">      goto theend;</a>
<a name="ln1342">    }</a>
<a name="ln1343">  }</a>
<a name="ln1344"> </a>
<a name="ln1345">  // ignore case depends on 'ignorecase', 'smartcase' and &quot;pat&quot;</a>
<a name="ln1346">  regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln1347">  while (*dict != NUL &amp;&amp; !got_int &amp;&amp; !compl_interrupted) {</a>
<a name="ln1348">    // copy one dictionary file name into buf</a>
<a name="ln1349">    if (flags == DICT_EXACT) {</a>
<a name="ln1350">      count = 1;</a>
<a name="ln1351">      files = &amp;dict;</a>
<a name="ln1352">    } else {</a>
<a name="ln1353">      // Expand wildcards in the dictionary name, but do not allow</a>
<a name="ln1354">      // backticks (for security, the 'dict' option may have been set in</a>
<a name="ln1355">      // a modeline).</a>
<a name="ln1356">      copy_option_part(&amp;dict, buf, LSIZE, &quot;,&quot;);</a>
<a name="ln1357">      if (!thesaurus &amp;&amp; strcmp(buf, &quot;spell&quot;) == 0) {</a>
<a name="ln1358">        count = -1;</a>
<a name="ln1359">      } else if (vim_strchr(buf, '`') != NULL</a>
<a name="ln1360">                 || expand_wildcards(1, &amp;buf, &amp;count, &amp;files,</a>
<a name="ln1361">                                     EW_FILE|EW_SILENT) != OK) {</a>
<a name="ln1362">        count = 0;</a>
<a name="ln1363">      }</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">    if (count == -1) {</a>
<a name="ln1367">      // Complete from active spelling.  Skip &quot;\&lt;&quot; in the pattern, we</a>
<a name="ln1368">      // don't use it as a RE.</a>
<a name="ln1369">      if (pat[0] == '\\' &amp;&amp; pat[1] == '&lt;') {</a>
<a name="ln1370">        ptr = pat + 2;</a>
<a name="ln1371">      } else {</a>
<a name="ln1372">        ptr = pat;</a>
<a name="ln1373">      }</a>
<a name="ln1374">      spell_dump_compl(ptr, regmatch.rm_ic, &amp;dir, 0);</a>
<a name="ln1375">    } else if (count &gt; 0) {  // avoid warning for using &quot;files&quot; uninit</a>
<a name="ln1376">      ins_compl_files(count, files, thesaurus, flags,</a>
<a name="ln1377">                      &amp;regmatch, buf, &amp;dir);</a>
<a name="ln1378">      if (flags != DICT_EXACT) {</a>
<a name="ln1379">        FreeWild(count, files);</a>
<a name="ln1380">      }</a>
<a name="ln1381">    }</a>
<a name="ln1382">    if (flags != 0) {</a>
<a name="ln1383">      break;</a>
<a name="ln1384">    }</a>
<a name="ln1385">  }</a>
<a name="ln1386"> </a>
<a name="ln1387">theend:</a>
<a name="ln1388">  p_scs = save_p_scs;</a>
<a name="ln1389">  vim_regfree(regmatch.regprog);</a>
<a name="ln1390">  xfree(buf);</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">/// Add all the words in the line &quot;*buf_arg&quot; from the thesaurus file &quot;fname&quot;</a>
<a name="ln1394">/// skipping the word at 'skip_word'.</a>
<a name="ln1395">///</a>
<a name="ln1396">/// @return  OK on success.</a>
<a name="ln1397">static int thesaurus_add_words_in_line(char *fname, char **buf_arg, int dir, const char *skip_word)</a>
<a name="ln1398">{</a>
<a name="ln1399">  int status = OK;</a>
<a name="ln1400"> </a>
<a name="ln1401">  // Add the other matches on the line</a>
<a name="ln1402">  char *ptr = *buf_arg;</a>
<a name="ln1403">  while (!got_int) {</a>
<a name="ln1404">    // Find start of the next word.  Skip white</a>
<a name="ln1405">    // space and punctuation.</a>
<a name="ln1406">    ptr = find_word_start(ptr);</a>
<a name="ln1407">    if (*ptr == NUL || *ptr == NL) {</a>
<a name="ln1408">      break;</a>
<a name="ln1409">    }</a>
<a name="ln1410">    char *wstart = ptr;</a>
<a name="ln1411"> </a>
<a name="ln1412">    // Find end of the word.</a>
<a name="ln1413">    // Japanese words may have characters in</a>
<a name="ln1414">    // different classes, only separate words</a>
<a name="ln1415">    // with single-byte non-word characters.</a>
<a name="ln1416">    while (*ptr != NUL) {</a>
<a name="ln1417">      const int l = utfc_ptr2len(ptr);</a>
<a name="ln1418"> </a>
<a name="ln1419">      if (l &lt; 2 &amp;&amp; !vim_iswordc((uint8_t)(*ptr))) {</a>
<a name="ln1420">        break;</a>
<a name="ln1421">      }</a>
<a name="ln1422">      ptr += l;</a>
<a name="ln1423">    }</a>
<a name="ln1424"> </a>
<a name="ln1425">    // Add the word. Skip the regexp match.</a>
<a name="ln1426">    if (wstart != skip_word) {</a>
<a name="ln1427">      status = ins_compl_add_infercase(wstart, (int)(ptr - wstart), p_ic,</a>
<a name="ln1428">                                       fname, dir, false);</a>
<a name="ln1429">      if (status == FAIL) {</a>
<a name="ln1430">        break;</a>
<a name="ln1431">      }</a>
<a name="ln1432">    }</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  *buf_arg = ptr;</a>
<a name="ln1436">  return status;</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">/// Process &quot;count&quot; dictionary/thesaurus &quot;files&quot; and add the text matching</a>
<a name="ln1440">/// &quot;regmatch&quot;.</a>
<a name="ln1441">static void ins_compl_files(int count, char **files, int thesaurus, int flags, regmatch_T *regmatch,</a>
<a name="ln1442">                            char *buf, Direction *dir)</a>
<a name="ln1443">  FUNC_ATTR_NONNULL_ARG(2, 7)</a>
<a name="ln1444">{</a>
<a name="ln1445">  char *ptr;</a>
<a name="ln1446">  int i;</a>
<a name="ln1447">  FILE *fp;</a>
<a name="ln1448">  int add_r;</a>
<a name="ln1449"> </a>
<a name="ln1450">  for (i = 0; i &lt; count &amp;&amp; !got_int &amp;&amp; !compl_interrupted; i++) {</a>
<a name="ln1451">    fp = os_fopen(files[i], &quot;r&quot;);  // open dictionary file</a>
<a name="ln1452">    if (flags != DICT_EXACT &amp;&amp; !shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln1453">      msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln1454">      vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln1455">                   _(&quot;Scanning dictionary: %s&quot;), files[i]);</a>
<a name="ln1456">      (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln1457">    }</a>
<a name="ln1458"> </a>
<a name="ln1459">    if (fp == NULL) {</a>
<a name="ln1460">      continue;</a>
<a name="ln1461">    }</a>
<a name="ln1462"> </a>
<a name="ln1463">    // Read dictionary file line by line.</a>
<a name="ln1464">    // Check each line for a match.</a>
<a name="ln1465">    while (!got_int &amp;&amp; !compl_interrupted &amp;&amp; !vim_fgets(buf, LSIZE, fp)) {</a>
<a name="ln1466">      ptr = buf;</a>
<a name="ln1467">      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf))) {</a>
<a name="ln1468">        ptr = regmatch-&gt;startp[0];</a>
<a name="ln1469">        if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1470">          ptr = find_line_end(ptr);</a>
<a name="ln1471">        } else {</a>
<a name="ln1472">          ptr = find_word_end(ptr);</a>
<a name="ln1473">        }</a>
<a name="ln1474">        add_r = ins_compl_add_infercase(regmatch-&gt;startp[0],</a>
<a name="ln1475">                                        (int)(ptr - regmatch-&gt;startp[0]),</a>
<a name="ln1476">                                        p_ic, files[i], *dir, false);</a>
<a name="ln1477">        if (thesaurus) {</a>
<a name="ln1478">          // For a thesaurus, add all the words in the line</a>
<a name="ln1479">          ptr = buf;</a>
<a name="ln1480">          add_r = thesaurus_add_words_in_line(files[i], &amp;ptr, *dir, regmatch-&gt;startp[0]);</a>
<a name="ln1481">        }</a>
<a name="ln1482">        if (add_r == OK) {</a>
<a name="ln1483">          // if dir was BACKWARD then honor it just once</a>
<a name="ln1484">          *dir = FORWARD;</a>
<a name="ln1485">        } else if (add_r == FAIL) {</a>
<a name="ln1486">          break;</a>
<a name="ln1487">        }</a>
<a name="ln1488">        // avoid expensive call to vim_regexec() when at end</a>
<a name="ln1489">        // of line</a>
<a name="ln1490">        if (*ptr == '\n' || got_int) {</a>
<a name="ln1491">          break;</a>
<a name="ln1492">        }</a>
<a name="ln1493">      }</a>
<a name="ln1494">      line_breakcheck();</a>
<a name="ln1495">      ins_compl_check_keys(50, false);</a>
<a name="ln1496">    }</a>
<a name="ln1497">    fclose(fp);</a>
<a name="ln1498">  }</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">/// Find the start of the next word.</a>
<a name="ln1502">/// Returns a pointer to the first char of the word.  Also stops at a NUL.</a>
<a name="ln1503">char *find_word_start(char *ptr)</a>
<a name="ln1504">  FUNC_ATTR_PURE</a>
<a name="ln1505">{</a>
<a name="ln1506">  while (*ptr != NUL &amp;&amp; *ptr != '\n' &amp;&amp; mb_get_class(ptr) &lt;= 1) {</a>
<a name="ln1507">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1508">  }</a>
<a name="ln1509">  return ptr;</a>
<a name="ln1510">}</a>
<a name="ln1511"> </a>
<a name="ln1512">/// Find the end of the word.  Assumes it starts inside a word.</a>
<a name="ln1513">/// Returns a pointer to just after the word.</a>
<a name="ln1514">char *find_word_end(char *ptr)</a>
<a name="ln1515">  FUNC_ATTR_PURE</a>
<a name="ln1516">{</a>
<a name="ln1517">  const int start_class = mb_get_class(ptr);</a>
<a name="ln1518">  if (start_class &gt; 1) {</a>
<a name="ln1519">    while (*ptr != NUL) {</a>
<a name="ln1520">      ptr += utfc_ptr2len(ptr);</a>
<a name="ln1521">      if (mb_get_class(ptr) != start_class) {</a>
<a name="ln1522">        break;</a>
<a name="ln1523">      }</a>
<a name="ln1524">    }</a>
<a name="ln1525">  }</a>
<a name="ln1526">  return ptr;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">/// Find the end of the line, omitting CR and NL at the end.</a>
<a name="ln1530">///</a>
<a name="ln1531">/// @return  a pointer to just after the line.</a>
<a name="ln1532">static char *find_line_end(char *ptr)</a>
<a name="ln1533">{</a>
<a name="ln1534">  char *s;</a>
<a name="ln1535"> </a>
<a name="ln1536">  s = ptr + strlen(ptr);</a>
<a name="ln1537">  while (s &gt; ptr &amp;&amp; (s[-1] == CAR || s[-1] == NL)) {</a>
<a name="ln1538">    s--;</a>
<a name="ln1539">  }</a>
<a name="ln1540">  return s;</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">/// Free the list of completions</a>
<a name="ln1544">static void ins_compl_free(void)</a>
<a name="ln1545">{</a>
<a name="ln1546">  compl_T *match;</a>
<a name="ln1547"> </a>
<a name="ln1548">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1549">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1550"> </a>
<a name="ln1551">  if (compl_first_match == NULL) {</a>
<a name="ln1552">    return;</a>
<a name="ln1553">  }</a>
<a name="ln1554"> </a>
<a name="ln1555">  ins_compl_del_pum();</a>
<a name="ln1556">  pum_clear();</a>
<a name="ln1557"> </a>
<a name="ln1558">  compl_curr_match = compl_first_match;</a>
<a name="ln1559">  do {</a>
<a name="ln1560">    match = compl_curr_match;</a>
<a name="ln1561">    compl_curr_match = compl_curr_match-&gt;cp_next;</a>
<a name="ln1562">    xfree(match-&gt;cp_str);</a>
<a name="ln1563">    // several entries may use the same fname, free it just once.</a>
<a name="ln1564">    if (match-&gt;cp_flags &amp; CP_FREE_FNAME) {</a>
<a name="ln1565">      xfree(match-&gt;cp_fname);</a>
<a name="ln1566">    }</a>
<a name="ln1567">    for (int i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln1568">      xfree(match-&gt;cp_text[i]);</a>
<a name="ln1569">    }</a>
<a name="ln1570">    tv_clear(&amp;match-&gt;cp_user_data);</a>
<a name="ln1571">    xfree(match);</a>
<a name="ln1572">  } while (compl_curr_match != NULL &amp;&amp; !is_first_match(compl_curr_match));</a>
<a name="ln1573">  compl_first_match = compl_curr_match = NULL;</a>
<a name="ln1574">  compl_shown_match = NULL;</a>
<a name="ln1575">  compl_old_match = NULL;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">/// Reset/clear the completion state.</a>
<a name="ln1579">void ins_compl_clear(void)</a>
<a name="ln1580">{</a>
<a name="ln1581">  compl_cont_status = 0;</a>
<a name="ln1582">  compl_started = false;</a>
<a name="ln1583">  compl_matches = 0;</a>
<a name="ln1584">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1585">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1586">  edit_submode_extra = NULL;</a>
<a name="ln1587">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln1588">  compl_enter_selects = false;</a>
<a name="ln1589">  // clear v:completed_item</a>
<a name="ln1590">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">/// Check that Insert completion is active.</a>
<a name="ln1594">bool ins_compl_active(void)</a>
<a name="ln1595">  FUNC_ATTR_PURE</a>
<a name="ln1596">{</a>
<a name="ln1597">  return compl_started;</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">/// Selected one of the matches.  When false the match was edited or using the</a>
<a name="ln1601">/// longest common string.</a>
<a name="ln1602">bool ins_compl_used_match(void)</a>
<a name="ln1603">{</a>
<a name="ln1604">  return compl_used_match;</a>
<a name="ln1605">}</a>
<a name="ln1606"> </a>
<a name="ln1607">/// Initialize get longest common string.</a>
<a name="ln1608">void ins_compl_init_get_longest(void)</a>
<a name="ln1609">{</a>
<a name="ln1610">  compl_get_longest = false;</a>
<a name="ln1611">}</a>
<a name="ln1612"> </a>
<a name="ln1613">/// Returns true when insert completion is interrupted.</a>
<a name="ln1614">bool ins_compl_interrupted(void)</a>
<a name="ln1615">{</a>
<a name="ln1616">  return compl_interrupted;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">/// Returns true if the &lt;Enter&gt; key selects a match in the completion popup</a>
<a name="ln1620">/// menu.</a>
<a name="ln1621">bool ins_compl_enter_selects(void)</a>
<a name="ln1622">{</a>
<a name="ln1623">  return compl_enter_selects;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">/// Return the column where the text starts that is being completed</a>
<a name="ln1627">colnr_T ins_compl_col(void)</a>
<a name="ln1628">{</a>
<a name="ln1629">  return compl_col;</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">/// Return the length in bytes of the text being completed</a>
<a name="ln1633">int ins_compl_len(void)</a>
<a name="ln1634">{</a>
<a name="ln1635">  return compl_length;</a>
<a name="ln1636">}</a>
<a name="ln1637"> </a>
<a name="ln1638">/// Delete one character before the cursor and show the subset of the matches</a>
<a name="ln1639">/// that match the word that is now before the cursor.</a>
<a name="ln1640">/// Returns the character to be used, NUL if the work is done and another char</a>
<a name="ln1641">/// to be got from the user.</a>
<a name="ln1642">int ins_compl_bs(void)</a>
<a name="ln1643">{</a>
<a name="ln1644">  char *line = get_cursor_line_ptr();</a>
<a name="ln1645">  char *p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln1646">  MB_PTR_BACK(line, p);</a>
<a name="ln1647">  ptrdiff_t p_off = p - line;</a>
<a name="ln1648"> </a>
<a name="ln1649">  // Stop completion when the whole word was deleted.  For Omni completion</a>
<a name="ln1650">  // allow the word to be deleted, we won't match everything.</a>
<a name="ln1651">  // Respect the 'backspace' option.</a>
<a name="ln1652">  if ((int)(p - line) - (int)compl_col &lt; 0</a>
<a name="ln1653">      || ((int)(p - line) - (int)compl_col == 0 &amp;&amp; !ctrl_x_mode_omni())</a>
<a name="ln1654">      || ctrl_x_mode_eval()</a>
<a name="ln1655">      || (!can_bs(BS_START) &amp;&amp; (int)(p - line) - (int)compl_col</a>
<a name="ln1656">          - compl_length &lt; 0)) {</a>
<a name="ln1657">    return K_BS;</a>
<a name="ln1658">  }</a>
<a name="ln1659"> </a>
<a name="ln1660">  // Deleted more than what was used to find matches or didn't finish</a>
<a name="ln1661">  // finding all matches: need to look for matches all over again.</a>
<a name="ln1662">  if (curwin-&gt;w_cursor.col &lt;= compl_col + compl_length</a>
<a name="ln1663">      || ins_compl_need_restart()) {</a>
<a name="ln1664">    ins_compl_restart();</a>
<a name="ln1665">  }</a>
<a name="ln1666"> </a>
<a name="ln1667">  // ins_compl_restart() calls update_screen() which may invalidate the pointer</a>
<a name="ln1668">  // TODO(bfredl): get rid of random update_screen() calls deep inside completion logic</a>
<a name="ln1669">  line = get_cursor_line_ptr();</a>
<a name="ln1670"> </a>
<a name="ln1671">  xfree(compl_leader);</a>
<a name="ln1672">  compl_leader = xstrnsave(line + compl_col, (size_t)(p_off - (ptrdiff_t)compl_col));</a>
<a name="ln1673"> </a>
<a name="ln1674">  ins_compl_new_leader();</a>
<a name="ln1675">  if (compl_shown_match != NULL) {</a>
<a name="ln1676">    // Make sure current match is not a hidden item.</a>
<a name="ln1677">    compl_curr_match = compl_shown_match;</a>
<a name="ln1678">  }</a>
<a name="ln1679">  return NUL;</a>
<a name="ln1680">}</a>
<a name="ln1681"> </a>
<a name="ln1682">/// Check that we need to find matches again, ins_compl_restart() is to</a>
<a name="ln1683">/// be called.</a>
<a name="ln1684">static bool ins_compl_need_restart(void)</a>
<a name="ln1685">  FUNC_ATTR_PURE</a>
<a name="ln1686">{</a>
<a name="ln1687">  // Return true if we didn't complete finding matches or when the</a>
<a name="ln1688">  // &quot;completefunc&quot; returned &quot;always&quot; in the &quot;refresh&quot; dictionary item.</a>
<a name="ln1689">  return compl_was_interrupted</a>
<a name="ln1690">         || ((ctrl_x_mode_function() || ctrl_x_mode_omni())</a>
<a name="ln1691">             &amp;&amp; compl_opt_refresh_always);</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694">/// Called after changing &quot;compl_leader&quot;.</a>
<a name="ln1695">/// Show the popup menu with a different set of matches.</a>
<a name="ln1696">/// May also search for matches again if the previous search was interrupted.</a>
<a name="ln1697">static void ins_compl_new_leader(void)</a>
<a name="ln1698">{</a>
<a name="ln1699">  ins_compl_del_pum();</a>
<a name="ln1700">  ins_compl_delete();</a>
<a name="ln1701">  ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln1702">  compl_used_match = false;</a>
<a name="ln1703"> </a>
<a name="ln1704">  if (compl_started) {</a>
<a name="ln1705">    ins_compl_set_original_text(compl_leader);</a>
<a name="ln1706">  } else {</a>
<a name="ln1707">    spell_bad_len = 0;  // need to redetect bad word</a>
<a name="ln1708">    // Matches were cleared, need to search for them now.</a>
<a name="ln1709">    // Set &quot;compl_restarting&quot; to avoid that the first match is inserted.</a>
<a name="ln1710">    compl_restarting = true;</a>
<a name="ln1711">    if (ins_complete(Ctrl_N, true) == FAIL) {</a>
<a name="ln1712">      compl_cont_status = 0;</a>
<a name="ln1713">    }</a>
<a name="ln1714">    compl_restarting = false;</a>
<a name="ln1715">  }</a>
<a name="ln1716"> </a>
<a name="ln1717">  compl_enter_selects = !compl_used_match;</a>
<a name="ln1718"> </a>
<a name="ln1719">  // Show the popup menu with a different set of matches.</a>
<a name="ln1720">  ins_compl_show_pum();</a>
<a name="ln1721"> </a>
<a name="ln1722">  // Don't let Enter select the original text when there is no popup menu.</a>
<a name="ln1723">  // Don't let Enter select when use user function and refresh_always is set</a>
<a name="ln1724">  if (compl_match_array == NULL || ins_compl_need_restart()) {</a>
<a name="ln1725">    compl_enter_selects = false;</a>
<a name="ln1726">  }</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">/// Return the length of the completion, from the completion start column to</a>
<a name="ln1730">/// the cursor column.  Making sure it never goes below zero.</a>
<a name="ln1731">static int get_compl_len(void)</a>
<a name="ln1732">{</a>
<a name="ln1733">  int off = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1734"> </a>
<a name="ln1735">  if (off &lt; 0) {</a>
<a name="ln1736">    return 0;</a>
<a name="ln1737">  }</a>
<a name="ln1738">  return off;</a>
<a name="ln1739">}</a>
<a name="ln1740"> </a>
<a name="ln1741">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1742">/// matches.</a>
<a name="ln1743">void ins_compl_addleader(int c)</a>
<a name="ln1744">{</a>
<a name="ln1745">  int cc;</a>
<a name="ln1746"> </a>
<a name="ln1747">  if (stop_arrow() == FAIL) {</a>
<a name="ln1748">    return;</a>
<a name="ln1749">  }</a>
<a name="ln1750">  if ((cc = utf_char2len(c)) &gt; 1) {</a>
<a name="ln1751">    char buf[MB_MAXBYTES + 1];</a>
<a name="ln1752"> </a>
<a name="ln1753">    utf_char2bytes(c, buf);</a>
<a name="ln1754">    buf[cc] = NUL;</a>
<a name="ln1755">    ins_char_bytes(buf, (size_t)cc);</a>
<a name="ln1756">  } else {</a>
<a name="ln1757">    ins_char(c);</a>
<a name="ln1758">  }</a>
<a name="ln1759"> </a>
<a name="ln1760">  // If we didn't complete finding matches we must search again.</a>
<a name="ln1761">  if (ins_compl_need_restart()) {</a>
<a name="ln1762">    ins_compl_restart();</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  xfree(compl_leader);</a>
<a name="ln1766">  compl_leader = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln1767">                           (size_t)(curwin-&gt;w_cursor.col - compl_col));</a>
<a name="ln1768">  ins_compl_new_leader();</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">/// Setup for finding completions again without leaving CTRL-X mode.  Used when</a>
<a name="ln1772">/// BS or a key was typed while still searching for matches.</a>
<a name="ln1773">static void ins_compl_restart(void)</a>
<a name="ln1774">{</a>
<a name="ln1775">  // update screen before restart.</a>
<a name="ln1776">  // so if complete is blocked,</a>
<a name="ln1777">  // will stay to the last popup menu and reduce flicker</a>
<a name="ln1778">  update_screen();  // TODO(bfredl): no.</a>
<a name="ln1779">  ins_compl_free();</a>
<a name="ln1780">  compl_started = false;</a>
<a name="ln1781">  compl_matches = 0;</a>
<a name="ln1782">  compl_cont_status = 0;</a>
<a name="ln1783">  compl_cont_mode = 0;</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">/// Set the first match, the original text.</a>
<a name="ln1787">static void ins_compl_set_original_text(char *str)</a>
<a name="ln1788">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1789">{</a>
<a name="ln1790">  // Replace the original text entry.</a>
<a name="ln1791">  // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly</a>
<a name="ln1792">  // be at the last item for backward completion</a>
<a name="ln1793">  if (match_at_original_text(compl_first_match)) {  // safety check</a>
<a name="ln1794">    xfree(compl_first_match-&gt;cp_str);</a>
<a name="ln1795">    compl_first_match-&gt;cp_str = xstrdup(str);</a>
<a name="ln1796">  } else if (compl_first_match-&gt;cp_prev != NULL</a>
<a name="ln1797">             &amp;&amp; match_at_original_text(compl_first_match-&gt;cp_prev)) {</a>
<a name="ln1798">    xfree(compl_first_match-&gt;cp_prev-&gt;cp_str);</a>
<a name="ln1799">    compl_first_match-&gt;cp_prev-&gt;cp_str = xstrdup(str);</a>
<a name="ln1800">  }</a>
<a name="ln1801">}</a>
<a name="ln1802"> </a>
<a name="ln1803">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1804">/// matches.</a>
<a name="ln1805">void ins_compl_addfrommatch(void)</a>
<a name="ln1806">{</a>
<a name="ln1807">  char *p;</a>
<a name="ln1808">  int len = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1809">  int c;</a>
<a name="ln1810">  compl_T *cp;</a>
<a name="ln1811">  assert(compl_shown_match != NULL);</a>
<a name="ln1812">  p = compl_shown_match-&gt;cp_str;</a>
<a name="ln1813">  if ((int)strlen(p) &lt;= len) {   // the match is too short</a>
<a name="ln1814">    // When still at the original match use the first entry that matches</a>
<a name="ln1815">    // the leader.</a>
<a name="ln1816">    if (!match_at_original_text(compl_shown_match)) {</a>
<a name="ln1817">      return;</a>
<a name="ln1818">    }</a>
<a name="ln1819"> </a>
<a name="ln1820">    p = NULL;</a>
<a name="ln1821">    for (cp = compl_shown_match-&gt;cp_next; cp != NULL</a>
<a name="ln1822">         &amp;&amp; !is_first_match(cp); cp = cp-&gt;cp_next) {</a>
<a name="ln1823">      if (compl_leader == NULL</a>
<a name="ln1824">          || ins_compl_equal(cp, compl_leader, strlen(compl_leader))) {</a>
<a name="ln1825">        p = cp-&gt;cp_str;</a>
<a name="ln1826">        break;</a>
<a name="ln1827">      }</a>
<a name="ln1828">    }</a>
<a name="ln1829">    if (p == NULL || (int)strlen(p) &lt;= len) {</a>
<a name="ln1830">      return;</a>
<a name="ln1831">    }</a>
<a name="ln1832">  }</a>
<a name="ln1833">  p += len;</a>
<a name="ln1834">  c = utf_ptr2char(p);</a>
<a name="ln1835">  ins_compl_addleader(c);</a>
<a name="ln1836">}</a>
<a name="ln1837"> </a>
<a name="ln1838">/// Set the CTRL-X completion mode based on the key &quot;c&quot; typed after a CTRL-X.</a>
<a name="ln1839">/// Uses the global variables: ctrl_x_mode, edit_submode, edit_submode_pre,</a>
<a name="ln1840">/// compl_cont_mode and compl_cont_status.</a>
<a name="ln1841">///</a>
<a name="ln1842">/// @return  true when the character is not to be inserted.</a>
<a name="ln1843">static bool set_ctrl_x_mode(const int c)</a>
<a name="ln1844">{</a>
<a name="ln1845">  bool retval = false;</a>
<a name="ln1846"> </a>
<a name="ln1847">  switch (c) {</a>
<a name="ln1848">  case Ctrl_E:</a>
<a name="ln1849">  case Ctrl_Y:</a>
<a name="ln1850">    // scroll the window one line up or down</a>
<a name="ln1851">    ctrl_x_mode = CTRL_X_SCROLL;</a>
<a name="ln1852">    if (!(State &amp; REPLACE_FLAG)) {</a>
<a name="ln1853">      edit_submode = _(&quot; (insert) Scroll (^E/^Y)&quot;);</a>
<a name="ln1854">    } else {</a>
<a name="ln1855">      edit_submode = _(&quot; (replace) Scroll (^E/^Y)&quot;);</a>
<a name="ln1856">    }</a>
<a name="ln1857">    edit_submode_pre = NULL;</a>
<a name="ln1858">    showmode();</a>
<a name="ln1859">    break;</a>
<a name="ln1860">  case Ctrl_L:</a>
<a name="ln1861">    // complete whole line</a>
<a name="ln1862">    ctrl_x_mode = CTRL_X_WHOLE_LINE;</a>
<a name="ln1863">    break;</a>
<a name="ln1864">  case Ctrl_F:</a>
<a name="ln1865">    // complete filenames</a>
<a name="ln1866">    ctrl_x_mode = CTRL_X_FILES;</a>
<a name="ln1867">    break;</a>
<a name="ln1868">  case Ctrl_K:</a>
<a name="ln1869">    // complete words from a dictionary</a>
<a name="ln1870">    ctrl_x_mode = CTRL_X_DICTIONARY;</a>
<a name="ln1871">    break;</a>
<a name="ln1872">  case Ctrl_R:</a>
<a name="ln1873">    // Register insertion without exiting CTRL-X mode</a>
<a name="ln1874">    // Simply allow ^R to happen without affecting ^X mode</a>
<a name="ln1875">    break;</a>
<a name="ln1876">  case Ctrl_T:</a>
<a name="ln1877">    // complete words from a thesaurus</a>
<a name="ln1878">    ctrl_x_mode = CTRL_X_THESAURUS;</a>
<a name="ln1879">    break;</a>
<a name="ln1880">  case Ctrl_U:</a>
<a name="ln1881">    // user defined completion</a>
<a name="ln1882">    ctrl_x_mode = CTRL_X_FUNCTION;</a>
<a name="ln1883">    break;</a>
<a name="ln1884">  case Ctrl_O:</a>
<a name="ln1885">    // omni completion</a>
<a name="ln1886">    ctrl_x_mode = CTRL_X_OMNI;</a>
<a name="ln1887">    break;</a>
<a name="ln1888">  case 's':</a>
<a name="ln1889">  case Ctrl_S:</a>
<a name="ln1890">    // complete spelling suggestions</a>
<a name="ln1891">    ctrl_x_mode = CTRL_X_SPELL;</a>
<a name="ln1892">    emsg_off++;  // Avoid getting the E756 error twice.</a>
<a name="ln1893">    spell_back_to_badword();</a>
<a name="ln1894">    emsg_off--;</a>
<a name="ln1895">    break;</a>
<a name="ln1896">  case Ctrl_RSB:</a>
<a name="ln1897">    // complete tag names</a>
<a name="ln1898">    ctrl_x_mode = CTRL_X_TAGS;</a>
<a name="ln1899">    break;</a>
<a name="ln1900">  case Ctrl_I:</a>
<a name="ln1901">  case K_S_TAB:</a>
<a name="ln1902">    // complete keywords from included files</a>
<a name="ln1903">    ctrl_x_mode = CTRL_X_PATH_PATTERNS;</a>
<a name="ln1904">    break;</a>
<a name="ln1905">  case Ctrl_D:</a>
<a name="ln1906">    // complete definitions from included files</a>
<a name="ln1907">    ctrl_x_mode = CTRL_X_PATH_DEFINES;</a>
<a name="ln1908">    break;</a>
<a name="ln1909">  case Ctrl_V:</a>
<a name="ln1910">  case Ctrl_Q:</a>
<a name="ln1911">    // complete vim commands</a>
<a name="ln1912">    ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln1913">    break;</a>
<a name="ln1914">  case Ctrl_Z:</a>
<a name="ln1915">    // stop completion</a>
<a name="ln1916">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1917">    edit_submode = NULL;</a>
<a name="ln1918">    showmode();</a>
<a name="ln1919">    retval = true;</a>
<a name="ln1920">    break;</a>
<a name="ln1921">  case Ctrl_P:</a>
<a name="ln1922">  case Ctrl_N:</a>
<a name="ln1923">    // ^X^P means LOCAL expansion if nothing interrupted (eg we</a>
<a name="ln1924">    // just started ^X mode, or there were enough ^X's to cancel</a>
<a name="ln1925">    // the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)</a>
<a name="ln1926">    // do normal expansion when interrupting a different mode (say</a>
<a name="ln1927">    // ^X^F^X^P or ^P^X^X^P, see below)</a>
<a name="ln1928">    // nothing changes if interrupting mode 0, (eg, the flag</a>
<a name="ln1929">    // doesn't change when going to ADDING mode  -- Acevedo</a>
<a name="ln1930">    if (!(compl_cont_status &amp; CONT_INTRPT)) {</a>
<a name="ln1931">      compl_cont_status |= CONT_LOCAL;</a>
<a name="ln1932">    } else if (compl_cont_mode != 0) {</a>
<a name="ln1933">      compl_cont_status &amp;= ~CONT_LOCAL;</a>
<a name="ln1934">    }</a>
<a name="ln1935">    FALLTHROUGH;</a>
<a name="ln1936">  default:</a>
<a name="ln1937">    // If we have typed at least 2 ^X's... for modes != 0, we set</a>
<a name="ln1938">    // compl_cont_status = 0 (eg, as if we had just started ^X</a>
<a name="ln1939">    // mode).</a>
<a name="ln1940">    // For mode 0, we set &quot;compl_cont_mode&quot; to an impossible</a>
<a name="ln1941">    // value, in both cases ^X^X can be used to restart the same</a>
<a name="ln1942">    // mode (avoiding ADDING mode).</a>
<a name="ln1943">    // Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start</a>
<a name="ln1944">    // 'complete' and local ^P expansions respectively.</a>
<a name="ln1945">    // In mode 0 an extra ^X is needed since ^X^P goes to ADDING</a>
<a name="ln1946">    // mode  -- Acevedo</a>
<a name="ln1947">    if (c == Ctrl_X) {</a>
<a name="ln1948">      if (compl_cont_mode != 0) {</a>
<a name="ln1949">        compl_cont_status = 0;</a>
<a name="ln1950">      } else {</a>
<a name="ln1951">        compl_cont_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln1952">      }</a>
<a name="ln1953">    }</a>
<a name="ln1954">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1955">    edit_submode = NULL;</a>
<a name="ln1956">    showmode();</a>
<a name="ln1957">    break;</a>
<a name="ln1958">  }</a>
<a name="ln1959"> </a>
<a name="ln1960">  return retval;</a>
<a name="ln1961">}</a>
<a name="ln1962"> </a>
<a name="ln1963">/// Stop insert completion mode</a>
<a name="ln1964">static bool ins_compl_stop(const int c, const int prev_mode, bool retval)</a>
<a name="ln1965">{</a>
<a name="ln1966">  // Get here when we have finished typing a sequence of ^N and</a>
<a name="ln1967">  // ^P or other completion characters in CTRL-X mode.  Free up</a>
<a name="ln1968">  // memory that was used, and make sure we can redo the insert.</a>
<a name="ln1969">  if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {</a>
<a name="ln1970">    // If any of the original typed text has been changed, eg when</a>
<a name="ln1971">    // ignorecase is set, we must add back-spaces to the redo</a>
<a name="ln1972">    // buffer.  We add as few as necessary to delete just the part</a>
<a name="ln1973">    // of the original text that has changed.</a>
<a name="ln1974">    // When using the longest match, edited the match or used</a>
<a name="ln1975">    // CTRL-E then don't use the current match.</a>
<a name="ln1976">    char *ptr;</a>
<a name="ln1977">    if (compl_curr_match != NULL &amp;&amp; compl_used_match &amp;&amp; c != Ctrl_E) {</a>
<a name="ln1978">      ptr = compl_curr_match-&gt;cp_str;</a>
<a name="ln1979">    } else {</a>
<a name="ln1980">      ptr = NULL;</a>
<a name="ln1981">    }</a>
<a name="ln1982">    ins_compl_fixRedoBufForLeader(ptr);</a>
<a name="ln1983">  }</a>
<a name="ln1984"> </a>
<a name="ln1985">  bool want_cindent = (get_can_cindent() &amp;&amp; cindent_on());</a>
<a name="ln1986"> </a>
<a name="ln1987">  // When completing whole lines: fix indent for 'cindent'.</a>
<a name="ln1988">  // Otherwise, break line if it's too long.</a>
<a name="ln1989">  if (compl_cont_mode == CTRL_X_WHOLE_LINE) {</a>
<a name="ln1990">    // re-indent the current line</a>
<a name="ln1991">    if (want_cindent) {</a>
<a name="ln1992">      do_c_expr_indent();</a>
<a name="ln1993">      want_cindent = false;                 // don't do it again</a>
<a name="ln1994">    }</a>
<a name="ln1995">  } else {</a>
<a name="ln1996">    const int prev_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1997"> </a>
<a name="ln1998">    // put the cursor on the last char, for 'tw' formatting</a>
<a name="ln1999">    if (prev_col &gt; 0) {</a>
<a name="ln2000">      dec_cursor();</a>
<a name="ln2001">    }</a>
<a name="ln2002"> </a>
<a name="ln2003">    // only format when something was inserted</a>
<a name="ln2004">    if (!arrow_used &amp;&amp; !ins_need_undo_get() &amp;&amp; c != Ctrl_E) {</a>
<a name="ln2005">      insertchar(NUL, 0, -1);</a>
<a name="ln2006">    }</a>
<a name="ln2007"> </a>
<a name="ln2008">    if (prev_col &gt; 0</a>
<a name="ln2009">        &amp;&amp; get_cursor_line_ptr()[curwin-&gt;w_cursor.col] != NUL) {</a>
<a name="ln2010">      inc_cursor();</a>
<a name="ln2011">    }</a>
<a name="ln2012">  }</a>
<a name="ln2013"> </a>
<a name="ln2014">  // If the popup menu is displayed pressing CTRL-Y means accepting</a>
<a name="ln2015">  // the selection without inserting anything.  When</a>
<a name="ln2016">  // compl_enter_selects is set the Enter key does the same.</a>
<a name="ln2017">  if ((c == Ctrl_Y || (compl_enter_selects</a>
<a name="ln2018">                       &amp;&amp; (c == CAR || c == K_KENTER || c == NL)))</a>
<a name="ln2019">      &amp;&amp; pum_visible()) {</a>
<a name="ln2020">    retval = true;</a>
<a name="ln2021">  }</a>
<a name="ln2022"> </a>
<a name="ln2023">  // CTRL-E means completion is Ended, go back to the typed text.</a>
<a name="ln2024">  // but only do this, if the Popup is still visible</a>
<a name="ln2025">  if (c == Ctrl_E) {</a>
<a name="ln2026">    ins_compl_delete();</a>
<a name="ln2027">    char *p = NULL;</a>
<a name="ln2028">    if (compl_leader != NULL) {</a>
<a name="ln2029">      p = compl_leader;</a>
<a name="ln2030">    } else if (compl_first_match != NULL) {</a>
<a name="ln2031">      p = compl_orig_text;</a>
<a name="ln2032">    }</a>
<a name="ln2033">    if (p != NULL) {</a>
<a name="ln2034">      const int compl_len = get_compl_len();</a>
<a name="ln2035">      const int len = (int)strlen(p);</a>
<a name="ln2036">      if (len &gt; compl_len) {</a>
<a name="ln2037">        ins_bytes_len(p + compl_len, (size_t)(len - compl_len));</a>
<a name="ln2038">      }</a>
<a name="ln2039">    }</a>
<a name="ln2040">    retval = true;</a>
<a name="ln2041">  }</a>
<a name="ln2042"> </a>
<a name="ln2043">  auto_format(false, true);</a>
<a name="ln2044"> </a>
<a name="ln2045">  // Trigger the CompleteDonePre event to give scripts a chance to</a>
<a name="ln2046">  // act upon the completion before clearing the info, and restore</a>
<a name="ln2047">  // ctrl_x_mode, so that complete_info() can be used.</a>
<a name="ln2048">  ctrl_x_mode = prev_mode;</a>
<a name="ln2049">  ins_apply_autocmds(EVENT_COMPLETEDONEPRE);</a>
<a name="ln2050"> </a>
<a name="ln2051">  ins_compl_free();</a>
<a name="ln2052">  compl_started = false;</a>
<a name="ln2053">  compl_matches = 0;</a>
<a name="ln2054">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln2055">    msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln2056">  }</a>
<a name="ln2057">  ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2058">  compl_enter_selects = false;</a>
<a name="ln2059">  if (edit_submode != NULL) {</a>
<a name="ln2060">    edit_submode = NULL;</a>
<a name="ln2061">    showmode();</a>
<a name="ln2062">  }</a>
<a name="ln2063"> </a>
<a name="ln2064">  if (c == Ctrl_C &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln2065">    // Avoid the popup menu remains displayed when leaving the</a>
<a name="ln2066">    // command line window.</a>
<a name="ln2067">    update_screen();</a>
<a name="ln2068">  }</a>
<a name="ln2069"> </a>
<a name="ln2070">  // Indent now if a key was typed that is in 'cinkeys'.</a>
<a name="ln2071">  if (want_cindent &amp;&amp; in_cinkeys(KEY_COMPLETE, ' ', inindent(0))) {</a>
<a name="ln2072">    do_c_expr_indent();</a>
<a name="ln2073">  }</a>
<a name="ln2074">  // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2075">  // upon the end of completion.</a>
<a name="ln2076">  ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2077"> </a>
<a name="ln2078">  return retval;</a>
<a name="ln2079">}</a>
<a name="ln2080"> </a>
<a name="ln2081">/// Prepare for Insert mode completion, or stop it.</a>
<a name="ln2082">/// Called just after typing a character in Insert mode.</a>
<a name="ln2083">///</a>
<a name="ln2084">/// @param  c  character that was typed</a>
<a name="ln2085">///</a>
<a name="ln2086">/// @return true when the character is not to be inserted;</a>
<a name="ln2087">bool ins_compl_prep(int c)</a>
<a name="ln2088">{</a>
<a name="ln2089">  bool retval = false;</a>
<a name="ln2090">  const int prev_mode = ctrl_x_mode;</a>
<a name="ln2091"> </a>
<a name="ln2092">  // Forget any previous 'special' messages if this is actually</a>
<a name="ln2093">  // a ^X mode key - bar ^R, in which case we wait to see what it gives us.</a>
<a name="ln2094">  if (c != Ctrl_R &amp;&amp; vim_is_ctrl_x_key(c)) {</a>
<a name="ln2095">    edit_submode_extra = NULL;</a>
<a name="ln2096">  }</a>
<a name="ln2097"> </a>
<a name="ln2098">  // Ignore end of Select mode mapping and mouse scroll/movement.</a>
<a name="ln2099">  if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln2100">      || c == K_MOUSELEFT || c == K_MOUSERIGHT || c == K_MOUSEMOVE</a>
<a name="ln2101">      || c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln2102">    return retval;</a>
<a name="ln2103">  }</a>
<a name="ln2104"> </a>
<a name="ln2105">  if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X &amp;&amp; c != Ctrl_X) {</a>
<a name="ln2106">    if (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)</a>
<a name="ln2107">        || !vim_is_ctrl_x_key(c)) {</a>
<a name="ln2108">      // Not starting another completion mode.</a>
<a name="ln2109">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2110"> </a>
<a name="ln2111">      // CTRL-X CTRL-Z should stop completion without inserting anything</a>
<a name="ln2112">      if (c == Ctrl_Z) {</a>
<a name="ln2113">        retval = true;</a>
<a name="ln2114">      }</a>
<a name="ln2115">    } else {</a>
<a name="ln2116">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2117"> </a>
<a name="ln2118">      // Other CTRL-X keys first stop completion, then start another</a>
<a name="ln2119">      // completion mode.</a>
<a name="ln2120">      ins_compl_prep(' ');</a>
<a name="ln2121">      ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln2122">    }</a>
<a name="ln2123">  }</a>
<a name="ln2124"> </a>
<a name="ln2125">  // Set &quot;compl_get_longest&quot; when finding the first matches.</a>
<a name="ln2126">  if (ctrl_x_mode_not_defined_yet()</a>
<a name="ln2127">      || (ctrl_x_mode_normal() &amp;&amp; !compl_started)) {</a>
<a name="ln2128">    compl_get_longest = compl_longest;</a>
<a name="ln2129">    compl_used_match = true;</a>
<a name="ln2130">  }</a>
<a name="ln2131"> </a>
<a name="ln2132">  if (ctrl_x_mode_not_defined_yet()) {</a>
<a name="ln2133">    // We have just typed CTRL-X and aren't quite sure which CTRL-X mode</a>
<a name="ln2134">    // it will be yet.  Now we decide.</a>
<a name="ln2135">    retval = set_ctrl_x_mode(c);</a>
<a name="ln2136">  } else if (ctrl_x_mode_not_default()) {</a>
<a name="ln2137">    // We're already in CTRL-X mode, do we stay in it?</a>
<a name="ln2138">    if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2139">      if (ctrl_x_mode_scroll()) {</a>
<a name="ln2140">        ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2141">      } else {</a>
<a name="ln2142">        ctrl_x_mode = CTRL_X_FINISHED;</a>
<a name="ln2143">      }</a>
<a name="ln2144">      edit_submode = NULL;</a>
<a name="ln2145">    }</a>
<a name="ln2146">    showmode();</a>
<a name="ln2147">  }</a>
<a name="ln2148"> </a>
<a name="ln2149">  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2150">    // Show error message from attempted keyword completion (probably</a>
<a name="ln2151">    // 'Pattern not found') until another key is hit, then go back to</a>
<a name="ln2152">    // showing what mode we are in.</a>
<a name="ln2153">    showmode();</a>
<a name="ln2154">    if ((ctrl_x_mode_normal()</a>
<a name="ln2155">         &amp;&amp; c != Ctrl_N</a>
<a name="ln2156">         &amp;&amp; c != Ctrl_P</a>
<a name="ln2157">         &amp;&amp; c != Ctrl_R</a>
<a name="ln2158">         &amp;&amp; !ins_compl_pum_key(c))</a>
<a name="ln2159">        || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2160">      retval = ins_compl_stop(c, prev_mode, retval);</a>
<a name="ln2161">    }</a>
<a name="ln2162">  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {</a>
<a name="ln2163">    // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2164">    // upon the (possibly failed) completion.</a>
<a name="ln2165">    ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2166">  }</a>
<a name="ln2167"> </a>
<a name="ln2168">  may_trigger_modechanged();</a>
<a name="ln2169"> </a>
<a name="ln2170">  // reset continue_* if we left expansion-mode, if we stay they'll be</a>
<a name="ln2171">  // (re)set properly in ins_complete()</a>
<a name="ln2172">  if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2173">    compl_cont_status = 0;</a>
<a name="ln2174">    compl_cont_mode = 0;</a>
<a name="ln2175">  }</a>
<a name="ln2176"> </a>
<a name="ln2177">  return retval;</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">/// Fix the redo buffer for the completion leader replacing some of the typed</a>
<a name="ln2181">/// text.  This inserts backspaces and appends the changed text.</a>
<a name="ln2182">/// &quot;ptr&quot; is the known leader text or NUL.</a>
<a name="ln2183">static void ins_compl_fixRedoBufForLeader(char *ptr_arg)</a>
<a name="ln2184">{</a>
<a name="ln2185">  int len;</a>
<a name="ln2186">  char *p;</a>
<a name="ln2187">  char *ptr = ptr_arg;</a>
<a name="ln2188"> </a>
<a name="ln2189">  if (ptr == NULL) {</a>
<a name="ln2190">    if (compl_leader != NULL) {</a>
<a name="ln2191">      ptr = compl_leader;</a>
<a name="ln2192">    } else {</a>
<a name="ln2193">      return;        // nothing to do</a>
<a name="ln2194">    }</a>
<a name="ln2195">  }</a>
<a name="ln2196">  if (compl_orig_text != NULL) {</a>
<a name="ln2197">    p = compl_orig_text;</a>
<a name="ln2198">    for (len = 0; p[len] != NUL &amp;&amp; p[len] == ptr[len]; len++) {}</a>
<a name="ln2199">    if (len &gt; 0) {</a>
<a name="ln2200">      len -= utf_head_off(p, p + len);</a>
<a name="ln2201">    }</a>
<a name="ln2202">    for (p += len; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2203">      AppendCharToRedobuff(K_BS);</a>
<a name="ln2204">    }</a>
<a name="ln2205">  } else {</a>
<a name="ln2206">    len = 0;</a>
<a name="ln2207">  }</a>
<a name="ln2208">  AppendToRedobuffLit(ptr + len, -1);</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">/// Loops through the list of windows, loaded-buffers or non-loaded-buffers</a>
<a name="ln2212">/// (depending on flag) starting from buf and looking for a non-scanned</a>
<a name="ln2213">/// buffer (other than curbuf).  curbuf is special, if it is called with</a>
<a name="ln2214">/// buf=curbuf then it has to be the first call for a given flag/expansion.</a>
<a name="ln2215">///</a>
<a name="ln2216">/// Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo</a>
<a name="ln2217">static buf_T *ins_compl_next_buf(buf_T *buf, int flag)</a>
<a name="ln2218">{</a>
<a name="ln2219">  static win_T *wp = NULL;</a>
<a name="ln2220"> </a>
<a name="ln2221">  if (flag == 'w') {            // just windows</a>
<a name="ln2222">    if (buf == curbuf || !win_valid(wp)) {</a>
<a name="ln2223">      // first call for this flag/expansion or window was closed</a>
<a name="ln2224">      wp = curwin;</a>
<a name="ln2225">    }</a>
<a name="ln2226">    assert(wp);</a>
<a name="ln2227">    while ((wp = (wp-&gt;w_next != NULL ? wp-&gt;w_next : firstwin)) != curwin</a>
<a name="ln2228">           &amp;&amp; wp-&gt;w_buffer-&gt;b_scanned) {}</a>
<a name="ln2229">    buf = wp-&gt;w_buffer;</a>
<a name="ln2230">  } else {</a>
<a name="ln2231">    // 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'</a>
<a name="ln2232">    // (unlisted buffers)</a>
<a name="ln2233">    // When completing whole lines skip unloaded buffers.</a>
<a name="ln2234">    while ((buf = (buf-&gt;b_next != NULL ? buf-&gt;b_next : firstbuf)) != curbuf</a>
<a name="ln2235">           &amp;&amp; ((flag == 'U'</a>
<a name="ln2236">                ? buf-&gt;b_p_bl</a>
<a name="ln2237">                : (!buf-&gt;b_p_bl</a>
<a name="ln2238">                   || (buf-&gt;b_ml.ml_mfp == NULL) != (flag == 'u')))</a>
<a name="ln2239">               || buf-&gt;b_scanned)) {}</a>
<a name="ln2240">  }</a>
<a name="ln2241">  return buf;</a>
<a name="ln2242">}</a>
<a name="ln2243"> </a>
<a name="ln2244">static Callback cfu_cb;    ///&lt; 'completefunc' callback function</a>
<a name="ln2245">static Callback ofu_cb;    ///&lt; 'omnifunc' callback function</a>
<a name="ln2246">static Callback tsrfu_cb;  ///&lt; 'thesaurusfunc' callback function</a>
<a name="ln2247"> </a>
<a name="ln2248">/// Copy a global callback function to a buffer local callback.</a>
<a name="ln2249">static void copy_global_to_buflocal_cb(Callback *globcb, Callback *bufcb)</a>
<a name="ln2250">{</a>
<a name="ln2251">  callback_free(bufcb);</a>
<a name="ln2252">  if (globcb-&gt;type != kCallbackNone) {</a>
<a name="ln2253">    callback_copy(bufcb, globcb);</a>
<a name="ln2254">  }</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">/// Parse the 'completefunc' option value and set the callback function.</a>
<a name="ln2258">/// Invoked when the 'completefunc' option is set. The option value can be a</a>
<a name="ln2259">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2260">/// lambda expression.</a>
<a name="ln2261">const char *did_set_completefunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2262">{</a>
<a name="ln2263">  if (option_set_callback_func(curbuf-&gt;b_p_cfu, &amp;cfu_cb) == FAIL) {</a>
<a name="ln2264">    return e_invarg;</a>
<a name="ln2265">  }</a>
<a name="ln2266"> </a>
<a name="ln2267">  set_buflocal_cfu_callback(curbuf);</a>
<a name="ln2268">  return NULL;</a>
<a name="ln2269">}</a>
<a name="ln2270"> </a>
<a name="ln2271">/// Copy the global 'completefunc' callback function to the buffer-local</a>
<a name="ln2272">/// 'completefunc' callback for &quot;buf&quot;.</a>
<a name="ln2273">void set_buflocal_cfu_callback(buf_T *buf)</a>
<a name="ln2274">{</a>
<a name="ln2275">  copy_global_to_buflocal_cb(&amp;cfu_cb, &amp;buf-&gt;b_cfu_cb);</a>
<a name="ln2276">}</a>
<a name="ln2277"> </a>
<a name="ln2278">/// Parse the 'omnifunc' option value and set the callback function.</a>
<a name="ln2279">/// Invoked when the 'omnifunc' option is set. The option value can be a</a>
<a name="ln2280">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2281">/// lambda expression.</a>
<a name="ln2282">const char *did_set_omnifunc(optset_T *args)</a>
<a name="ln2283">{</a>
<a name="ln2284">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2285">  if (option_set_callback_func(buf-&gt;b_p_ofu, &amp;ofu_cb) == FAIL) {</a>
<a name="ln2286">    return e_invarg;</a>
<a name="ln2287">  }</a>
<a name="ln2288">  set_buflocal_ofu_callback(buf);</a>
<a name="ln2289">  return NULL;</a>
<a name="ln2290">}</a>
<a name="ln2291"> </a>
<a name="ln2292">/// Copy the global 'omnifunc' callback function to the buffer-local 'omnifunc'</a>
<a name="ln2293">/// callback for &quot;buf&quot;.</a>
<a name="ln2294">void set_buflocal_ofu_callback(buf_T *buf)</a>
<a name="ln2295">{</a>
<a name="ln2296">  copy_global_to_buflocal_cb(&amp;ofu_cb, &amp;buf-&gt;b_ofu_cb);</a>
<a name="ln2297">}</a>
<a name="ln2298"> </a>
<a name="ln2299">/// Parse the 'thesaurusfunc' option value and set the callback function.</a>
<a name="ln2300">/// Invoked when the 'thesaurusfunc' option is set. The option value can be a</a>
<a name="ln2301">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2302">/// lambda expression.</a>
<a name="ln2303">const char *did_set_thesaurusfunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2304">{</a>
<a name="ln2305">  int retval;</a>
<a name="ln2306"> </a>
<a name="ln2307">  if (*curbuf-&gt;b_p_tsrfu != NUL) {</a>
<a name="ln2308">    // buffer-local option set</a>
<a name="ln2309">    retval = option_set_callback_func(curbuf-&gt;b_p_tsrfu, &amp;curbuf-&gt;b_tsrfu_cb);</a>
<a name="ln2310">  } else {</a>
<a name="ln2311">    // global option set</a>
<a name="ln2312">    retval = option_set_callback_func(p_tsrfu, &amp;tsrfu_cb);</a>
<a name="ln2313">  }</a>
<a name="ln2314"> </a>
<a name="ln2315">  return retval == FAIL ? e_invarg : NULL;</a>
<a name="ln2316">}</a>
<a name="ln2317"> </a>
<a name="ln2318">/// Mark the global 'completefunc' 'omnifunc' and 'thesaurusfunc' callbacks with</a>
<a name="ln2319">/// &quot;copyID&quot; so that they are not garbage collected.</a>
<a name="ln2320">bool set_ref_in_insexpand_funcs(int copyID)</a>
<a name="ln2321">{</a>
<a name="ln2322">  bool abort = set_ref_in_callback(&amp;cfu_cb, copyID, NULL, NULL);</a>
<a name="ln2323">  abort = abort || set_ref_in_callback(&amp;ofu_cb, copyID, NULL, NULL);</a>
<a name="ln2324">  abort = abort || set_ref_in_callback(&amp;tsrfu_cb, copyID, NULL, NULL);</a>
<a name="ln2325"> </a>
<a name="ln2326">  return abort;</a>
<a name="ln2327">}</a>
<a name="ln2328"> </a>
<a name="ln2329">/// Get the user-defined completion function name for completion &quot;type&quot;</a>
<a name="ln2330">static char *get_complete_funcname(int type)</a>
<a name="ln2331">{</a>
<a name="ln2332">  switch (type) {</a>
<a name="ln2333">  case CTRL_X_FUNCTION:</a>
<a name="ln2334">    return curbuf-&gt;b_p_cfu;</a>
<a name="ln2335">  case CTRL_X_OMNI:</a>
<a name="ln2336">    return curbuf-&gt;b_p_ofu;</a>
<a name="ln2337">  case CTRL_X_THESAURUS:</a>
<a name="ln2338">    return *curbuf-&gt;b_p_tsrfu == NUL ? p_tsrfu : curbuf-&gt;b_p_tsrfu;</a>
<a name="ln2339">  default:</a>
<a name="ln2340">    return &quot;&quot;;</a>
<a name="ln2341">  }</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344">/// Get the callback to use for insert mode completion.</a>
<a name="ln2345">static Callback *get_insert_callback(int type)</a>
<a name="ln2346">{</a>
<a name="ln2347">  if (type == CTRL_X_FUNCTION) {</a>
<a name="ln2348">    return &amp;curbuf-&gt;b_cfu_cb;</a>
<a name="ln2349">  }</a>
<a name="ln2350">  if (type == CTRL_X_OMNI) {</a>
<a name="ln2351">    return &amp;curbuf-&gt;b_ofu_cb;</a>
<a name="ln2352">  }</a>
<a name="ln2353">  // CTRL_X_THESAURUS</a>
<a name="ln2354">  return (*curbuf-&gt;b_p_tsrfu != NUL) ? &amp;curbuf-&gt;b_tsrfu_cb : &amp;tsrfu_cb;</a>
<a name="ln2355">}</a>
<a name="ln2356"> </a>
<a name="ln2357">/// Execute user defined complete function 'completefunc', 'omnifunc' or</a>
<a name="ln2358">/// 'thesaurusfunc', and get matches in &quot;matches&quot;.</a>
<a name="ln2359">///</a>
<a name="ln2360">/// @param type  either CTRL_X_OMNI or CTRL_X_FUNCTION or CTRL_X_THESAURUS</a>
<a name="ln2361">static void expand_by_function(int type, char *base)</a>
<a name="ln2362">{</a>
<a name="ln2363">  list_T *matchlist = NULL;</a>
<a name="ln2364">  dict_T *matchdict = NULL;</a>
<a name="ln2365">  char *funcname;</a>
<a name="ln2366">  pos_T pos;</a>
<a name="ln2367">  typval_T rettv;</a>
<a name="ln2368">  const int save_State = State;</a>
<a name="ln2369"> </a>
<a name="ln2370">  assert(curbuf != NULL);</a>
<a name="ln2371">  funcname = get_complete_funcname(type);</a>
<a name="ln2372">  if (*funcname == NUL) {</a>
<a name="ln2373">    return;</a>
<a name="ln2374">  }</a>
<a name="ln2375"> </a>
<a name="ln2376">  // Call 'completefunc' to obtain the list of matches.</a>
<a name="ln2377">  typval_T args[3];</a>
<a name="ln2378">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln2379">  args[1].v_type = VAR_STRING;</a>
<a name="ln2380">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln2381">  args[0].vval.v_number = 0;</a>
<a name="ln2382">  args[1].vval.v_string = base != NULL ? base : &quot;&quot;;</a>
<a name="ln2383"> </a>
<a name="ln2384">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2385">  // Lock the text to avoid weird things from happening.  Also disallow</a>
<a name="ln2386">  // switching to another window, it should not be needed and may end up in</a>
<a name="ln2387">  // Insert mode in another buffer.</a>
<a name="ln2388">  textlock++;</a>
<a name="ln2389"> </a>
<a name="ln2390">  Callback *cb = get_insert_callback(type);</a>
<a name="ln2391"> </a>
<a name="ln2392">  // Call a function, which returns a list or dict.</a>
<a name="ln2393">  if (callback_call(cb, 2, args, &amp;rettv)) {</a>
<a name="ln2394">    switch (rettv.v_type) {</a>
<a name="ln2395">    case VAR_LIST:</a>
<a name="ln2396">      matchlist = rettv.vval.v_list;</a>
<a name="ln2397">      break;</a>
<a name="ln2398">    case VAR_DICT:</a>
<a name="ln2399">      matchdict = rettv.vval.v_dict;</a>
<a name="ln2400">      break;</a>
<a name="ln2401">    case VAR_SPECIAL:</a>
<a name="ln2402">      FALLTHROUGH;</a>
<a name="ln2403">    default:</a>
<a name="ln2404">      // TODO(brammool): Give error message?</a>
<a name="ln2405">      tv_clear(&amp;rettv);</a>
<a name="ln2406">      break;</a>
<a name="ln2407">    }</a>
<a name="ln2408">  }</a>
<a name="ln2409">  textlock--;</a>
<a name="ln2410"> </a>
<a name="ln2411">  curwin-&gt;w_cursor = pos;       // restore the cursor position</a>
<a name="ln2412">  validate_cursor();</a>
<a name="ln2413">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln2414">    emsg(_(e_compldel));</a>
<a name="ln2415">    goto theend;</a>
<a name="ln2416">  }</a>
<a name="ln2417"> </a>
<a name="ln2418">  if (matchlist != NULL) {</a>
<a name="ln2419">    ins_compl_add_list(matchlist);</a>
<a name="ln2420">  } else if (matchdict != NULL) {</a>
<a name="ln2421">    ins_compl_add_dict(matchdict);</a>
<a name="ln2422">  }</a>
<a name="ln2423"> </a>
<a name="ln2424">theend:</a>
<a name="ln2425">  // Restore State, it might have been changed.</a>
<a name="ln2426">  State = save_State;</a>
<a name="ln2427"> </a>
<a name="ln2428">  if (matchdict != NULL) {</a>
<a name="ln2429">    tv_dict_unref(matchdict);</a>
<a name="ln2430">  }</a>
<a name="ln2431">  if (matchlist != NULL) {</a>
<a name="ln2432">    tv_list_unref(matchlist);</a>
<a name="ln2433">  }</a>
<a name="ln2434">}</a>
<a name="ln2435"> </a>
<a name="ln2436">/// Add a match to the list of matches from Vimscript object</a>
<a name="ln2437">///</a>
<a name="ln2438">/// @param[in]  tv  Object to get matches from.</a>
<a name="ln2439">/// @param[in]  dir  Completion direction.</a>
<a name="ln2440">/// @param[in]  fast  use fast_breakcheck() instead of os_breakcheck().</a>
<a name="ln2441">///</a>
<a name="ln2442">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln2443">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln2444">///         returned in case of error.</a>
<a name="ln2445">static int ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)</a>
<a name="ln2446">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2447">{</a>
<a name="ln2448">  const char *word;</a>
<a name="ln2449">  bool dup = false;</a>
<a name="ln2450">  bool empty = false;</a>
<a name="ln2451">  int flags = fast ? CP_FAST : 0;</a>
<a name="ln2452">  char *(cptext[CPT_COUNT]);</a>
<a name="ln2453">  typval_T user_data;</a>
<a name="ln2454"> </a>
<a name="ln2455">  user_data.v_type = VAR_UNKNOWN;</a>
<a name="ln2456">  if (tv-&gt;v_type == VAR_DICT &amp;&amp; tv-&gt;vval.v_dict != NULL) {</a>
<a name="ln2457">    word = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;word&quot;, false);</a>
<a name="ln2458">    cptext[CPT_ABBR] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;abbr&quot;, true);</a>
<a name="ln2459">    cptext[CPT_MENU] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;menu&quot;, true);</a>
<a name="ln2460">    cptext[CPT_KIND] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;kind&quot;, true);</a>
<a name="ln2461">    cptext[CPT_INFO] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;info&quot;, true);</a>
<a name="ln2462">    tv_dict_get_tv(tv-&gt;vval.v_dict, &quot;user_data&quot;, &amp;user_data);</a>
<a name="ln2463"> </a>
<a name="ln2464">    if (tv_dict_get_number(tv-&gt;vval.v_dict, &quot;icase&quot;)) {</a>
<a name="ln2465">      flags |= CP_ICASE;</a>
<a name="ln2466">    }</a>
<a name="ln2467">    dup = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;dup&quot;);</a>
<a name="ln2468">    empty = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;empty&quot;);</a>
<a name="ln2469">    if (tv_dict_get_string(tv-&gt;vval.v_dict, &quot;equal&quot;, false) != NULL</a>
<a name="ln2470">        &amp;&amp; tv_dict_get_number(tv-&gt;vval.v_dict, &quot;equal&quot;)) {</a>
<a name="ln2471">      flags |= CP_EQUAL;</a>
<a name="ln2472">    }</a>
<a name="ln2473">  } else {</a>
<a name="ln2474">    word = tv_get_string_chk(tv);</a>
<a name="ln2475">    CLEAR_FIELD(cptext);</a>
<a name="ln2476">  }</a>
<a name="ln2477">  if (word == NULL || (!empty &amp;&amp; *word == NUL)) {</a>
<a name="ln2478">    for (size_t i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln2479">      xfree(cptext[i]);</a>
<a name="ln2480">    }</a>
<a name="ln2481">    tv_clear(&amp;user_data);</a>
<a name="ln2482">    return FAIL;</a>
<a name="ln2483">  }</a>
<a name="ln2484">  int status = ins_compl_add((char *)word, -1, NULL, cptext, true,</a>
<a name="ln2485">                             &amp;user_data, dir, flags, dup);</a>
<a name="ln2486">  if (status != OK) {</a>
<a name="ln2487">    tv_clear(&amp;user_data);</a>
<a name="ln2488">  }</a>
<a name="ln2489">  return status;</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">/// Add completions from a list.</a>
<a name="ln2493">static void ins_compl_add_list(list_T *const list)</a>
<a name="ln2494">{</a>
<a name="ln2495">  Direction dir = compl_direction;</a>
<a name="ln2496"> </a>
<a name="ln2497">  // Go through the List with matches and add each of them.</a>
<a name="ln2498">  TV_LIST_ITER(list, li, {</a>
<a name="ln2499">    if (ins_compl_add_tv(TV_LIST_ITEM_TV(li), dir, true) == OK) {</a>
<a name="ln2500">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln2501">      dir = FORWARD;</a>
<a name="ln2502">    } else if (did_emsg) {</a>
<a name="ln2503">      break;</a>
<a name="ln2504">    }</a>
<a name="ln2505">  });</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/// Add completions from a dict.</a>
<a name="ln2509">static void ins_compl_add_dict(dict_T *dict)</a>
<a name="ln2510">{</a>
<a name="ln2511">  dictitem_T *di_refresh;</a>
<a name="ln2512">  dictitem_T *di_words;</a>
<a name="ln2513"> </a>
<a name="ln2514">  // Check for optional &quot;refresh&quot; item.</a>
<a name="ln2515">  compl_opt_refresh_always = false;</a>
<a name="ln2516">  di_refresh = tv_dict_find(dict, S_LEN(&quot;refresh&quot;));</a>
<a name="ln2517">  if (di_refresh != NULL &amp;&amp; di_refresh-&gt;di_tv.v_type == VAR_STRING) {</a>
<a name="ln2518">    const char *v = di_refresh-&gt;di_tv.vval.v_string;</a>
<a name="ln2519"> </a>
<a name="ln2520">    if (v != NULL &amp;&amp; strcmp(v, &quot;always&quot;) == 0) {</a>
<a name="ln2521">      compl_opt_refresh_always = true;</a>
<a name="ln2522">    }</a>
<a name="ln2523">  }</a>
<a name="ln2524"> </a>
<a name="ln2525">  // Add completions from a &quot;words&quot; list.</a>
<a name="ln2526">  di_words = tv_dict_find(dict, S_LEN(&quot;words&quot;));</a>
<a name="ln2527">  if (di_words != NULL &amp;&amp; di_words-&gt;di_tv.v_type == VAR_LIST) {</a>
<a name="ln2528">    ins_compl_add_list(di_words-&gt;di_tv.vval.v_list);</a>
<a name="ln2529">  }</a>
<a name="ln2530">}</a>
<a name="ln2531"> </a>
<a name="ln2532">/// Start completion for the complete() function.</a>
<a name="ln2533">///</a>
<a name="ln2534">/// @param startcol  where the matched text starts (1 is first column).</a>
<a name="ln2535">/// @param list      the list of matches.</a>
<a name="ln2536">static void set_completion(colnr_T startcol, list_T *list)</a>
<a name="ln2537">{</a>
<a name="ln2538">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln2539"> </a>
<a name="ln2540">  // If already doing completions stop it.</a>
<a name="ln2541">  if (ctrl_x_mode_not_default()) {</a>
<a name="ln2542">    ins_compl_prep(' ');</a>
<a name="ln2543">  }</a>
<a name="ln2544">  ins_compl_clear();</a>
<a name="ln2545">  ins_compl_free();</a>
<a name="ln2546">  compl_get_longest = compl_longest;</a>
<a name="ln2547"> </a>
<a name="ln2548">  compl_direction = FORWARD;</a>
<a name="ln2549">  if (startcol &gt; curwin-&gt;w_cursor.col) {</a>
<a name="ln2550">    startcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2551">  }</a>
<a name="ln2552">  compl_col = startcol;</a>
<a name="ln2553">  compl_length = (int)curwin-&gt;w_cursor.col - (int)startcol;</a>
<a name="ln2554">  // compl_pattern doesn't need to be set</a>
<a name="ln2555">  compl_orig_text = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln2556">                              (size_t)compl_length);</a>
<a name="ln2557">  if (p_ic) {</a>
<a name="ln2558">    flags |= CP_ICASE;</a>
<a name="ln2559">  }</a>
<a name="ln2560">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln2561">                    flags | CP_FAST, false) != OK) {</a>
<a name="ln2562">    return;</a>
<a name="ln2563">  }</a>
<a name="ln2564"> </a>
<a name="ln2565">  ctrl_x_mode = CTRL_X_EVAL;</a>
<a name="ln2566"> </a>
<a name="ln2567">  ins_compl_add_list(list);</a>
<a name="ln2568">  compl_matches = ins_compl_make_cyclic();</a>
<a name="ln2569">  compl_started = true;</a>
<a name="ln2570">  compl_used_match = true;</a>
<a name="ln2571">  compl_cont_status = 0;</a>
<a name="ln2572">  int save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln2573">  int save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln2574"> </a>
<a name="ln2575">  compl_curr_match = compl_first_match;</a>
<a name="ln2576">  bool no_select = compl_no_select || compl_longest;</a>
<a name="ln2577">  if (compl_no_insert || no_select) {</a>
<a name="ln2578">    ins_complete(K_DOWN, false);</a>
<a name="ln2579">    if (no_select) {</a>
<a name="ln2580">      ins_complete(K_UP, false);</a>
<a name="ln2581">    }</a>
<a name="ln2582">  } else {</a>
<a name="ln2583">    ins_complete(Ctrl_N, false);</a>
<a name="ln2584">  }</a>
<a name="ln2585">  compl_enter_selects = compl_no_insert;</a>
<a name="ln2586"> </a>
<a name="ln2587">  // Lazily show the popup menu, unless we got interrupted.</a>
<a name="ln2588">  if (!compl_interrupted) {</a>
<a name="ln2589">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln2590">  }</a>
<a name="ln2591"> </a>
<a name="ln2592">  may_trigger_modechanged();</a>
<a name="ln2593">  ui_flush();</a>
<a name="ln2594">}</a>
<a name="ln2595"> </a>
<a name="ln2596">/// &quot;complete()&quot; function</a>
<a name="ln2597">void f_complete(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2598">{</a>
<a name="ln2599">  if ((State &amp; MODE_INSERT) == 0) {</a>
<a name="ln2600">    emsg(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln2601">    return;</a>
<a name="ln2602">  }</a>
<a name="ln2603"> </a>
<a name="ln2604">  // Check for undo allowed here, because if something was already inserted</a>
<a name="ln2605">  // the line was already saved for undo and this check isn't done.</a>
<a name="ln2606">  if (!undo_allowed(curbuf)) {</a>
<a name="ln2607">    return;</a>
<a name="ln2608">  }</a>
<a name="ln2609"> </a>
<a name="ln2610">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln2611">    emsg(_(e_invarg));</a>
<a name="ln2612">  } else {</a>
<a name="ln2613">    const colnr_T startcol = (colnr_T)tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln2614">    if (startcol &gt; 0) {</a>
<a name="ln2615">      set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln2616">    }</a>
<a name="ln2617">  }</a>
<a name="ln2618">}</a>
<a name="ln2619"> </a>
<a name="ln2620">/// &quot;complete_add()&quot; function</a>
<a name="ln2621">void f_complete_add(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2622">{</a>
<a name="ln2623">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln2624">}</a>
<a name="ln2625"> </a>
<a name="ln2626">/// &quot;complete_check()&quot; function</a>
<a name="ln2627">void f_complete_check(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2628">{</a>
<a name="ln2629">  int saved = RedrawingDisabled;</a>
<a name="ln2630"> </a>
<a name="ln2631">  RedrawingDisabled = 0;</a>
<a name="ln2632">  ins_compl_check_keys(0, true);</a>
<a name="ln2633">  rettv-&gt;vval.v_number = ins_compl_interrupted();</a>
<a name="ln2634">  RedrawingDisabled = saved;</a>
<a name="ln2635">}</a>
<a name="ln2636"> </a>
<a name="ln2637">/// Return Insert completion mode name string</a>
<a name="ln2638">static char *ins_compl_mode(void)</a>
<a name="ln2639">{</a>
<a name="ln2640">  if (ctrl_x_mode_not_defined_yet() || ctrl_x_mode_scroll() || compl_started) {</a>
<a name="ln2641">    return ctrl_x_mode_names[ctrl_x_mode &amp; ~CTRL_X_WANT_IDENT];</a>
<a name="ln2642">  }</a>
<a name="ln2643">  return &quot;&quot;;</a>
<a name="ln2644">}</a>
<a name="ln2645"> </a>
<a name="ln2646">/// Assign the sequence number to all the completion matches which don't have</a>
<a name="ln2647">/// one assigned yet.</a>
<a name="ln2648">static void ins_compl_update_sequence_numbers(void)</a>
<a name="ln2649">{</a>
<a name="ln2650">  int number = 0;</a>
<a name="ln2651">  compl_T *match;</a>
<a name="ln2652"> </a>
<a name="ln2653">  if (compl_dir_forward()) {</a>
<a name="ln2654">    // Search backwards for the first valid (!= -1) number.</a>
<a name="ln2655">    // This should normally succeed already at the first loop</a>
<a name="ln2656">    // cycle, so it's fast!</a>
<a name="ln2657">    for (match = compl_curr_match-&gt;cp_prev;</a>
<a name="ln2658">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_prev) {</a>
<a name="ln2659">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2660">        number = match-&gt;cp_number;</a>
<a name="ln2661">        break;</a>
<a name="ln2662">      }</a>
<a name="ln2663">    }</a>
<a name="ln2664">    if (match != NULL) {</a>
<a name="ln2665">      // go up and assign all numbers which are not assigned yet</a>
<a name="ln2666">      for (match = match-&gt;cp_next;</a>
<a name="ln2667">           match != NULL &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2668">           match = match-&gt;cp_next) {</a>
<a name="ln2669">        match-&gt;cp_number = ++number;</a>
<a name="ln2670">      }</a>
<a name="ln2671">    }</a>
<a name="ln2672">  } else {  // BACKWARD</a>
<a name="ln2673">    assert(compl_direction == BACKWARD);</a>
<a name="ln2674">    // Search forwards (upwards) for the first valid (!= -1)</a>
<a name="ln2675">    // number.  This should normally succeed already at the</a>
<a name="ln2676">    // first loop cycle, so it's fast!</a>
<a name="ln2677">    for (match = compl_curr_match-&gt;cp_next;</a>
<a name="ln2678">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_next) {</a>
<a name="ln2679">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2680">        number = match-&gt;cp_number;</a>
<a name="ln2681">        break;</a>
<a name="ln2682">      }</a>
<a name="ln2683">    }</a>
<a name="ln2684">    if (match != NULL) {</a>
<a name="ln2685">      // go down and assign all numbers which are not assigned yet</a>
<a name="ln2686">      for (match = match-&gt;cp_prev;</a>
<a name="ln2687">           match &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2688">           match = match-&gt;cp_prev) {</a>
<a name="ln2689">        match-&gt;cp_number = ++number;</a>
<a name="ln2690">      }</a>
<a name="ln2691">    }</a>
<a name="ln2692">  }</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695">/// Get complete information</a>
<a name="ln2696">static void get_complete_info(list_T *what_list, dict_T *retdict)</a>
<a name="ln2697">{</a>
<a name="ln2698">#define CI_WHAT_MODE            0x01</a>
<a name="ln2699">#define CI_WHAT_PUM_VISIBLE     0x02</a>
<a name="ln2700">#define CI_WHAT_ITEMS           0x04</a>
<a name="ln2701">#define CI_WHAT_SELECTED        0x08</a>
<a name="ln2702">#define CI_WHAT_INSERTED        0x10</a>
<a name="ln2703">#define CI_WHAT_ALL             0xff</a>
<a name="ln2704">  int what_flag;</a>
<a name="ln2705"> </a>
<a name="ln2706">  if (what_list == NULL) {</a>
<a name="ln2707">    what_flag = CI_WHAT_ALL;</a>
<a name="ln2708">  } else {</a>
<a name="ln2709">    what_flag = 0;</a>
<a name="ln2710">    for (listitem_T *item = tv_list_first(what_list)</a>
<a name="ln2711">         ; item != NULL</a>
<a name="ln2712">         ; item = TV_LIST_ITEM_NEXT(what_list, item)) {</a>
<a name="ln2713">      const char *what = tv_get_string(TV_LIST_ITEM_TV(item));</a>
<a name="ln2714"> </a>
<a name="ln2715">      if (strcmp(what, &quot;mode&quot;) == 0) {</a>
<a name="ln2716">        what_flag |= CI_WHAT_MODE;</a>
<a name="ln2717">      } else if (strcmp(what, &quot;pum_visible&quot;) == 0) {</a>
<a name="ln2718">        what_flag |= CI_WHAT_PUM_VISIBLE;</a>
<a name="ln2719">      } else if (strcmp(what, &quot;items&quot;) == 0) {</a>
<a name="ln2720">        what_flag |= CI_WHAT_ITEMS;</a>
<a name="ln2721">      } else if (strcmp(what, &quot;selected&quot;) == 0) {</a>
<a name="ln2722">        what_flag |= CI_WHAT_SELECTED;</a>
<a name="ln2723">      } else if (strcmp(what, &quot;inserted&quot;) == 0) {</a>
<a name="ln2724">        what_flag |= CI_WHAT_INSERTED;</a>
<a name="ln2725">      }</a>
<a name="ln2726">    }</a>
<a name="ln2727">  }</a>
<a name="ln2728"> </a>
<a name="ln2729">  int ret = OK;</a>
<a name="ln2730">  if (what_flag &amp; CI_WHAT_MODE) {</a>
<a name="ln2731">    ret = tv_dict_add_str(retdict, S_LEN(&quot;mode&quot;), ins_compl_mode());</a>
<a name="ln2732">  }</a>
<a name="ln2733"> </a>
<a name="ln2734">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_PUM_VISIBLE)) {</a>
<a name="ln2735">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;pum_visible&quot;), pum_visible());</a>
<a name="ln2736">  }</a>
<a name="ln2737"> </a>
<a name="ln2738">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_ITEMS)) {</a>
<a name="ln2739">    list_T *li = tv_list_alloc(get_compl_len());</a>
<a name="ln2740"> </a>
<a name="ln2741">    ret = tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), li);</a>
<a name="ln2742">    if (ret == OK &amp;&amp; compl_first_match != NULL) {</a>
<a name="ln2743">      compl_T *match = compl_first_match;</a>
<a name="ln2744">      do {</a>
<a name="ln2745">        if (!match_at_original_text(match)) {</a>
<a name="ln2746">          dict_T *di = tv_dict_alloc();</a>
<a name="ln2747"> </a>
<a name="ln2748">          tv_list_append_dict(li, di);</a>
<a name="ln2749">          tv_dict_add_str(di, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln2750">          tv_dict_add_str(di, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln2751">          tv_dict_add_str(di, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln2752">          tv_dict_add_str(di, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln2753">          tv_dict_add_str(di, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln2754">          if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln2755">            // Add an empty string for backwards compatibility</a>
<a name="ln2756">            tv_dict_add_str(di, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln2757">          } else {</a>
<a name="ln2758">            tv_dict_add_tv(di, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln2759">          }</a>
<a name="ln2760">        }</a>
<a name="ln2761">        match = match-&gt;cp_next;</a>
<a name="ln2762">      } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln2763">    }</a>
<a name="ln2764">  }</a>
<a name="ln2765"> </a>
<a name="ln2766">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_SELECTED)) {</a>
<a name="ln2767">    if (compl_curr_match != NULL &amp;&amp; compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln2768">      ins_compl_update_sequence_numbers();</a>
<a name="ln2769">    }</a>
<a name="ln2770">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;selected&quot;),</a>
<a name="ln2771">                         (compl_curr_match != NULL)</a>
<a name="ln2772">                         ? compl_curr_match-&gt;cp_number - 1 : -1);</a>
<a name="ln2773">  }</a>
<a name="ln2774"> </a>
<a name="ln2775">  (void)ret;</a>
<a name="ln2776">  // TODO(vim):</a>
<a name="ln2777">  // if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_INSERTED))</a>
<a name="ln2778">}</a>
<a name="ln2779"> </a>
<a name="ln2780">/// &quot;complete_info()&quot; function</a>
<a name="ln2781">void f_complete_info(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2782">{</a>
<a name="ln2783">  tv_dict_alloc_ret(rettv);</a>
<a name="ln2784"> </a>
<a name="ln2785">  list_T *what_list = NULL;</a>
<a name="ln2786"> </a>
<a name="ln2787">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2788">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2789">      emsg(_(e_listreq));</a>
<a name="ln2790">      return;</a>
<a name="ln2791">    }</a>
<a name="ln2792">    what_list = argvars[0].vval.v_list;</a>
<a name="ln2793">  }</a>
<a name="ln2794">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln2795">}</a>
<a name="ln2796"> </a>
<a name="ln2797">/// Returns true when using a user-defined function for thesaurus completion.</a>
<a name="ln2798">static bool thesaurus_func_complete(int type)</a>
<a name="ln2799">{</a>
<a name="ln2800">  return type == CTRL_X_THESAURUS</a>
<a name="ln2801">         &amp;&amp; (*curbuf-&gt;b_p_tsrfu != NUL || *p_tsrfu != NUL);</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">/// Return value of process_next_cpt_value()</a>
<a name="ln2805">enum {</a>
<a name="ln2806">  INS_COMPL_CPT_OK = 1,</a>
<a name="ln2807">  INS_COMPL_CPT_CONT,</a>
<a name="ln2808">  INS_COMPL_CPT_END,</a>
<a name="ln2809">};</a>
<a name="ln2810"> </a>
<a name="ln2811">/// Process the next 'complete' option value in st-&gt;e_cpt.</a>
<a name="ln2812">///</a>
<a name="ln2813">/// If successful, the arguments are set as below:</a>
<a name="ln2814">///   st-&gt;cpt - pointer to the next option value in &quot;st-&gt;cpt&quot;</a>
<a name="ln2815">///   compl_type_arg - type of insert mode completion to use</a>
<a name="ln2816">///   st-&gt;found_all - all matches of this type are found</a>
<a name="ln2817">///   st-&gt;ins_buf - search for completions in this buffer</a>
<a name="ln2818">///   st-&gt;first_match_pos - position of the first completion match</a>
<a name="ln2819">///   st-&gt;last_match_pos - position of the last completion match</a>
<a name="ln2820">///   st-&gt;set_match_pos - true if the first match position should be saved to</a>
<a name="ln2821">///                       avoid loops after the search wraps around.</a>
<a name="ln2822">///   st-&gt;dict - name of the dictionary or thesaurus file to search</a>
<a name="ln2823">///   st-&gt;dict_f - flag specifying whether &quot;dict&quot; is an exact file name or not</a>
<a name="ln2824">///</a>
<a name="ln2825">/// @return  INS_COMPL_CPT_OK if the next value is processed successfully.</a>
<a name="ln2826">///          INS_COMPL_CPT_CONT to skip the current completion source matching</a>
<a name="ln2827">///          the &quot;st-&gt;e_cpt&quot; option value and process the next matching source.</a>
<a name="ln2828">///          INS_COMPL_CPT_END if all the values in &quot;st-&gt;e_cpt&quot; are processed.</a>
<a name="ln2829">static int process_next_cpt_value(ins_compl_next_state_T *st, int *compl_type_arg,</a>
<a name="ln2830">                                  pos_T *start_match_pos)</a>
<a name="ln2831">{</a>
<a name="ln2832">  int compl_type = -1;</a>
<a name="ln2833">  int status = INS_COMPL_CPT_OK;</a>
<a name="ln2834"> </a>
<a name="ln2835">  st-&gt;found_all = false;</a>
<a name="ln2836"> </a>
<a name="ln2837">  while (*st-&gt;e_cpt == ',' || *st-&gt;e_cpt == ' ') {</a>
<a name="ln2838">    st-&gt;e_cpt++;</a>
<a name="ln2839">  }</a>
<a name="ln2840"> </a>
<a name="ln2841">  if (*st-&gt;e_cpt == '.' &amp;&amp; !curbuf-&gt;b_scanned) {</a>
<a name="ln2842">    st-&gt;ins_buf = curbuf;</a>
<a name="ln2843">    st-&gt;first_match_pos = *start_match_pos;</a>
<a name="ln2844">    // Move the cursor back one character so that ^N can match the</a>
<a name="ln2845">    // word immediately after the cursor.</a>
<a name="ln2846">    if (ctrl_x_mode_normal() &amp;&amp; dec(&amp;st-&gt;first_match_pos) &lt; 0) {</a>
<a name="ln2847">      // Move the cursor to after the last character in the</a>
<a name="ln2848">      // buffer, so that word at start of buffer is found</a>
<a name="ln2849">      // correctly.</a>
<a name="ln2850">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2851">      st-&gt;first_match_pos.col = (colnr_T)strlen(ml_get(st-&gt;first_match_pos.lnum));</a>
<a name="ln2852">    }</a>
<a name="ln2853">    st-&gt;last_match_pos = st-&gt;first_match_pos;</a>
<a name="ln2854">    compl_type = 0;</a>
<a name="ln2855"> </a>
<a name="ln2856">    // Remember the first match so that the loop stops when we</a>
<a name="ln2857">    // wrap and come back there a second time.</a>
<a name="ln2858">    st-&gt;set_match_pos = true;</a>
<a name="ln2859">  } else if (vim_strchr(&quot;buwU&quot;, (uint8_t)(*st-&gt;e_cpt)) != NULL</a>
<a name="ln2860">             &amp;&amp; (st-&gt;ins_buf = ins_compl_next_buf(st-&gt;ins_buf, *st-&gt;e_cpt)) != curbuf) {</a>
<a name="ln2861">    // Scan a buffer, but not the current one.</a>
<a name="ln2862">    if (st-&gt;ins_buf-&gt;b_ml.ml_mfp != NULL) {  // loaded buffer</a>
<a name="ln2863">      compl_started = true;</a>
<a name="ln2864">      st-&gt;first_match_pos.col = st-&gt;last_match_pos.col = 0;</a>
<a name="ln2865">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln2866">      st-&gt;last_match_pos.lnum = 0;</a>
<a name="ln2867">      compl_type = 0;</a>
<a name="ln2868">    } else {  // unloaded buffer, scan like dictionary</a>
<a name="ln2869">      st-&gt;found_all = true;</a>
<a name="ln2870">      if (st-&gt;ins_buf-&gt;b_fname == NULL) {</a>
<a name="ln2871">        status = INS_COMPL_CPT_CONT;</a>
<a name="ln2872">        goto done;</a>
<a name="ln2873">      }</a>
<a name="ln2874">      compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2875">      st-&gt;dict = st-&gt;ins_buf-&gt;b_fname;</a>
<a name="ln2876">      st-&gt;dict_f = DICT_EXACT;</a>
<a name="ln2877">    }</a>
<a name="ln2878">    if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2879">      msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln2880">      vim_snprintf(IObuff, IOSIZE, _(&quot;Scanning: %s&quot;),</a>
<a name="ln2881">                   st-&gt;ins_buf-&gt;b_fname == NULL</a>
<a name="ln2882">                   ? buf_spname(st-&gt;ins_buf)</a>
<a name="ln2883">                   : st-&gt;ins_buf-&gt;b_sfname == NULL</a>
<a name="ln2884">                   ? st-&gt;ins_buf-&gt;b_fname</a>
<a name="ln2885">                   : st-&gt;ins_buf-&gt;b_sfname);</a>
<a name="ln2886">      (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2887">    }</a>
<a name="ln2888">  } else if (*st-&gt;e_cpt == NUL) {</a>
<a name="ln2889">    status = INS_COMPL_CPT_END;</a>
<a name="ln2890">  } else {</a>
<a name="ln2891">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln2892">      // compl_type = -1;</a>
<a name="ln2893">    } else if (*st-&gt;e_cpt == 'k' || *st-&gt;e_cpt == 's') {</a>
<a name="ln2894">      if (*st-&gt;e_cpt == 'k') {</a>
<a name="ln2895">        compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2896">      } else {</a>
<a name="ln2897">        compl_type = CTRL_X_THESAURUS;</a>
<a name="ln2898">      }</a>
<a name="ln2899">      if (*++st-&gt;e_cpt != ',' &amp;&amp; *st-&gt;e_cpt != NUL) {</a>
<a name="ln2900">        st-&gt;dict = st-&gt;e_cpt;</a>
<a name="ln2901">        st-&gt;dict_f = DICT_FIRST;</a>
<a name="ln2902">      }</a>
<a name="ln2903">    } else if (*st-&gt;e_cpt == 'i') {</a>
<a name="ln2904">      compl_type = CTRL_X_PATH_PATTERNS;</a>
<a name="ln2905">    } else if (*st-&gt;e_cpt == 'd') {</a>
<a name="ln2906">      compl_type = CTRL_X_PATH_DEFINES;</a>
<a name="ln2907">    } else if (*st-&gt;e_cpt == ']' || *st-&gt;e_cpt == 't') {</a>
<a name="ln2908">      compl_type = CTRL_X_TAGS;</a>
<a name="ln2909">      if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2910">        msg_hist_off = true;  // reset in msg_trunc()</a>
<a name="ln2911">        vim_snprintf(IObuff, IOSIZE, &quot;%s&quot;, _(&quot;Scanning tags.&quot;));</a>
<a name="ln2912">        (void)msg_trunc(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2913">      }</a>
<a name="ln2914">    }</a>
<a name="ln2915"> </a>
<a name="ln2916">    // in any case e_cpt is advanced to the next entry</a>
<a name="ln2917">    (void)copy_option_part(&amp;st-&gt;e_cpt, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2918"> </a>
<a name="ln2919">    st-&gt;found_all = true;</a>
<a name="ln2920">    if (compl_type == -1) {</a>
<a name="ln2921">      status = INS_COMPL_CPT_CONT;</a>
<a name="ln2922">    }</a>
<a name="ln2923">  }</a>
<a name="ln2924"> </a>
<a name="ln2925">done:</a>
<a name="ln2926">  *compl_type_arg = compl_type;</a>
<a name="ln2927">  return status;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">/// Get the next set of identifiers or defines matching &quot;compl_pattern&quot; in</a>
<a name="ln2931">/// included files.</a>
<a name="ln2932">static void get_next_include_file_completion(int compl_type)</a>
<a name="ln2933">{</a>
<a name="ln2934">  find_pattern_in_path(compl_pattern, compl_direction,</a>
<a name="ln2935">                       strlen(compl_pattern), false, false,</a>
<a name="ln2936">                       ((compl_type == CTRL_X_PATH_DEFINES</a>
<a name="ln2937">                         &amp;&amp; !(compl_cont_status &amp; CONT_SOL))</a>
<a name="ln2938">                        ? FIND_DEFINE : FIND_ANY),</a>
<a name="ln2939">                       1L, ACTION_EXPAND, 1, MAXLNUM);</a>
<a name="ln2940">}</a>
<a name="ln2941"> </a>
<a name="ln2942">/// Get the next set of words matching &quot;compl_pattern&quot; in dictionary or</a>
<a name="ln2943">/// thesaurus files.</a>
<a name="ln2944">static void get_next_dict_tsr_completion(int compl_type, char *dict, int dict_f)</a>
<a name="ln2945">{</a>
<a name="ln2946">  if (thesaurus_func_complete(compl_type)) {</a>
<a name="ln2947">    expand_by_function(compl_type, compl_pattern);</a>
<a name="ln2948">  } else {</a>
<a name="ln2949">    ins_compl_dictionaries(dict != NULL ? dict</a>
<a name="ln2950">                           : (compl_type == CTRL_X_THESAURUS</a>
<a name="ln2951">                              ? (*curbuf-&gt;b_p_tsr == NUL ? p_tsr : curbuf-&gt;b_p_tsr)</a>
<a name="ln2952">                              : (*curbuf-&gt;b_p_dict ==</a>
<a name="ln2953">                                 NUL ? p_dict : curbuf-&gt;b_p_dict)),</a>
<a name="ln2954">                           compl_pattern,</a>
<a name="ln2955">                           dict != NULL ? dict_f : 0,</a>
<a name="ln2956">                           compl_type == CTRL_X_THESAURUS);</a>
<a name="ln2957">  }</a>
<a name="ln2958">}</a>
<a name="ln2959"> </a>
<a name="ln2960">/// Get the next set of tag names matching &quot;compl_pattern&quot;.</a>
<a name="ln2961">static void get_next_tag_completion(void)</a>
<a name="ln2962">{</a>
<a name="ln2963">  // set p_ic according to p_ic, p_scs and pat for find_tags().</a>
<a name="ln2964">  const int save_p_ic = p_ic;</a>
<a name="ln2965">  p_ic = ignorecase(compl_pattern);</a>
<a name="ln2966"> </a>
<a name="ln2967">  // Find up to TAG_MANY matches.  Avoids that an enormous number</a>
<a name="ln2968">  // of matches is found when compl_pattern is empty</a>
<a name="ln2969">  g_tag_at_cursor = true;</a>
<a name="ln2970">  char **matches;</a>
<a name="ln2971">  int num_matches;</a>
<a name="ln2972">  if (find_tags(compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2973">                TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP</a>
<a name="ln2974">                | (ctrl_x_mode_not_default() ? TAG_VERBOSE : 0),</a>
<a name="ln2975">                TAG_MANY, curbuf-&gt;b_ffname) == OK &amp;&amp; num_matches &gt; 0) {</a>
<a name="ln2976">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln2977">  }</a>
<a name="ln2978">  g_tag_at_cursor = false;</a>
<a name="ln2979">  p_ic = save_p_ic;</a>
<a name="ln2980">}</a>
<a name="ln2981"> </a>
<a name="ln2982">/// Get the next set of filename matching &quot;compl_pattern&quot;.</a>
<a name="ln2983">static void get_next_filename_completion(void)</a>
<a name="ln2984">{</a>
<a name="ln2985">  char **matches;</a>
<a name="ln2986">  int num_matches;</a>
<a name="ln2987">  if (expand_wildcards(1, &amp;compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2988">                       EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK) {</a>
<a name="ln2989">    return;</a>
<a name="ln2990">  }</a>
<a name="ln2991"> </a>
<a name="ln2992">  // May change home directory back to &quot;~&quot;.</a>
<a name="ln2993">  tilde_replace(compl_pattern, num_matches, matches);</a>
<a name="ln2994">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2995">  if (curbuf-&gt;b_p_csl[0] != NUL) {</a>
<a name="ln2996">    for (int i = 0; i &lt; num_matches; i++) {</a>
<a name="ln2997">      char *ptr = matches[i];</a>
<a name="ln2998">      while (*ptr != NUL) {</a>
<a name="ln2999">        if (curbuf-&gt;b_p_csl[0] == 's' &amp;&amp; *ptr == '\\') {</a>
<a name="ln3000">          *ptr = '/';</a>
<a name="ln3001">        } else if (curbuf-&gt;b_p_csl[0] == 'b' &amp;&amp; *ptr == '/') {</a>
<a name="ln3002">          *ptr = '\\';</a>
<a name="ln3003">        }</a>
<a name="ln3004">        ptr += utfc_ptr2len(ptr);</a>
<a name="ln3005">      }</a>
<a name="ln3006">    }</a>
<a name="ln3007">  }</a>
<a name="ln3008">#endif</a>
<a name="ln3009">  ins_compl_add_matches(num_matches, matches, p_fic || p_wic);</a>
<a name="ln3010">}</a>
<a name="ln3011"> </a>
<a name="ln3012">/// Get the next set of command-line completions matching &quot;compl_pattern&quot;.</a>
<a name="ln3013">static void get_next_cmdline_completion(void)</a>
<a name="ln3014">{</a>
<a name="ln3015">  char **matches;</a>
<a name="ln3016">  int num_matches;</a>
<a name="ln3017">  if (expand_cmdline(&amp;compl_xp, compl_pattern,</a>
<a name="ln3018">                     (int)strlen(compl_pattern),</a>
<a name="ln3019">                     &amp;num_matches, &amp;matches) == EXPAND_OK) {</a>
<a name="ln3020">    ins_compl_add_matches(num_matches, matches, false);</a>
<a name="ln3021">  }</a>
<a name="ln3022">}</a>
<a name="ln3023"> </a>
<a name="ln3024">/// Get the next set of spell suggestions matching &quot;compl_pattern&quot;.</a>
<a name="ln3025">static void get_next_spell_completion(linenr_T lnum)</a>
<a name="ln3026">{</a>
<a name="ln3027">  char **matches;</a>
<a name="ln3028">  int num_matches = expand_spelling(lnum, compl_pattern, &amp;matches);</a>
<a name="ln3029">  if (num_matches &gt; 0) {</a>
<a name="ln3030">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln3031">  } else {</a>
<a name="ln3032">    xfree(matches);</a>
<a name="ln3033">  }</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036">/// Return the next word or line from buffer &quot;ins_buf&quot; at position</a>
<a name="ln3037">/// &quot;cur_match_pos&quot; for completion.  The length of the match is set in &quot;len&quot;.</a>
<a name="ln3038">/// @param ins_buf        buffer being scanned</a>
<a name="ln3039">/// @param cur_match_pos  current match position</a>
<a name="ln3040">/// @param match_len</a>
<a name="ln3041">/// @param cont_s_ipos    next ^X&lt;&gt; will set initial_pos</a>
<a name="ln3042">static char *ins_compl_get_next_word_or_line(buf_T *ins_buf, pos_T *cur_match_pos, int *match_len,</a>
<a name="ln3043">                                             bool *cont_s_ipos)</a>
<a name="ln3044">{</a>
<a name="ln3045">  *match_len = 0;</a>
<a name="ln3046">  char *ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum) + cur_match_pos-&gt;col;</a>
<a name="ln3047">  int len;</a>
<a name="ln3048">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln3049">    if (compl_status_adding()) {</a>
<a name="ln3050">      if (cur_match_pos-&gt;lnum &gt;= ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3051">        return NULL;</a>
<a name="ln3052">      }</a>
<a name="ln3053">      ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3054">      if (!p_paste) {</a>
<a name="ln3055">        ptr = skipwhite(ptr);</a>
<a name="ln3056">      }</a>
<a name="ln3057">    }</a>
<a name="ln3058">    len = (int)strlen(ptr);</a>
<a name="ln3059">  } else {</a>
<a name="ln3060">    char *tmp_ptr = ptr;</a>
<a name="ln3061"> </a>
<a name="ln3062">    if (compl_status_adding() &amp;&amp; compl_length &lt;= (int)strlen(tmp_ptr)) {</a>
<a name="ln3063">      tmp_ptr += compl_length;</a>
<a name="ln3064">      // Skip if already inside a word.</a>
<a name="ln3065">      if (vim_iswordp(tmp_ptr)) {</a>
<a name="ln3066">        return NULL;</a>
<a name="ln3067">      }</a>
<a name="ln3068">      // Find start of next word.</a>
<a name="ln3069">      tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3070">    }</a>
<a name="ln3071">    // Find end of this word.</a>
<a name="ln3072">    tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3073">    len = (int)(tmp_ptr - ptr);</a>
<a name="ln3074"> </a>
<a name="ln3075">    if (compl_status_adding() &amp;&amp; len == compl_length) {</a>
<a name="ln3076">      if (cur_match_pos-&gt;lnum &lt; ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3077">        // Try next line, if any. the new word will be &quot;join&quot; as if the</a>
<a name="ln3078">        // normal command &quot;J&quot; was used. IOSIZE is always greater than</a>
<a name="ln3079">        // compl_length, so the next strncpy always works -- Acevedo</a>
<a name="ln3080">        strncpy(IObuff, ptr, (size_t)len);  // NOLINT(runtime/printf)</a>
<a name="ln3081">        ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3082">        tmp_ptr = ptr = skipwhite(ptr);</a>
<a name="ln3083">        // Find start of next word.</a>
<a name="ln3084">        tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3085">        // Find end of next word.</a>
<a name="ln3086">        tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3087">        if (tmp_ptr &gt; ptr) {</a>
<a name="ln3088">          if (*ptr != ')' &amp;&amp; IObuff[len - 1] != TAB) {</a>
<a name="ln3089">            if (IObuff[len - 1] != ' ') {</a>
<a name="ln3090">              IObuff[len++] = ' ';</a>
<a name="ln3091">            }</a>
<a name="ln3092">            // IObuf =~ &quot;\k.* &quot;, thus len &gt;= 2</a>
<a name="ln3093">            if (p_js</a>
<a name="ln3094">                &amp;&amp; (IObuff[len - 2] == '.'</a>
<a name="ln3095">                    || IObuff[len - 2] == '?'</a>
<a name="ln3096">                    || IObuff[len - 2] == '!')) {</a>
<a name="ln3097">              IObuff[len++] = ' ';</a>
<a name="ln3098">            }</a>
<a name="ln3099">          }</a>
<a name="ln3100">          // copy as much as possible of the new word</a>
<a name="ln3101">          if (tmp_ptr - ptr &gt;= IOSIZE - len) {</a>
<a name="ln3102">            tmp_ptr = ptr + IOSIZE - len - 1;</a>
<a name="ln3103">          }</a>
<a name="ln3104">          xstrlcpy(IObuff + len, ptr, (size_t)(IOSIZE - len));</a>
<a name="ln3105">          len += (int)(tmp_ptr - ptr);</a>
<a name="ln3106">          *cont_s_ipos = true;</a>
<a name="ln3107">        }</a>
<a name="ln3108">        IObuff[len] = NUL;</a>
<a name="ln3109">        ptr = IObuff;</a>
<a name="ln3110">      }</a>
<a name="ln3111">      if (len == compl_length) {</a>
<a name="ln3112">        return NULL;</a>
<a name="ln3113">      }</a>
<a name="ln3114">    }</a>
<a name="ln3115">  }</a>
<a name="ln3116"> </a>
<a name="ln3117">  *match_len = len;</a>
<a name="ln3118">  return ptr;</a>
<a name="ln3119">}</a>
<a name="ln3120"> </a>
<a name="ln3121">/// Get the next set of words matching &quot;compl_pattern&quot; for default completion(s)</a>
<a name="ln3122">/// (normal ^P/^N and ^X^L).</a>
<a name="ln3123">/// Search for &quot;compl_pattern&quot; in the buffer &quot;st-&gt;ins_buf&quot; starting from the</a>
<a name="ln3124">/// position &quot;st-&gt;start_pos&quot; in the &quot;compl_direction&quot; direction. If</a>
<a name="ln3125">/// &quot;st-&gt;set_match_pos&quot; is true, then set the &quot;st-&gt;first_match_pos&quot; and</a>
<a name="ln3126">/// &quot;st-&gt;last_match_pos&quot;.</a>
<a name="ln3127">///</a>
<a name="ln3128">/// @return  OK if a new next match is found, otherwise FAIL.</a>
<a name="ln3129">static int get_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)</a>
<a name="ln3130">{</a>
<a name="ln3131">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln3132">  const int save_p_scs = p_scs;</a>
<a name="ln3133">  assert(st-&gt;ins_buf);</a>
<a name="ln3134">  if (st-&gt;ins_buf-&gt;b_p_inf) {</a>
<a name="ln3135">    p_scs = false;</a>
<a name="ln3136">  }</a>
<a name="ln3137"> </a>
<a name="ln3138">  // Buffers other than curbuf are scanned from the beginning or the</a>
<a name="ln3139">  // end but never from the middle, thus setting nowrapscan in this</a>
<a name="ln3140">  // buffers is a good idea, on the other hand, we always set</a>
<a name="ln3141">  // wrapscan for curbuf to avoid missing matches -- Acevedo,Webb</a>
<a name="ln3142">  const int save_p_ws = p_ws;</a>
<a name="ln3143">  if (st-&gt;ins_buf != curbuf) {</a>
<a name="ln3144">    p_ws = false;</a>
<a name="ln3145">  } else if (*st-&gt;e_cpt == '.') {</a>
<a name="ln3146">    p_ws = true;</a>
<a name="ln3147">  }</a>
<a name="ln3148">  bool looped_around = false;</a>
<a name="ln3149">  int found_new_match = FAIL;</a>
<a name="ln3150">  while (true) {</a>
<a name="ln3151">    bool cont_s_ipos = false;</a>
<a name="ln3152"> </a>
<a name="ln3153">    msg_silent++;  // Don't want messages for wrapscan.</a>
<a name="ln3154">    // ctrl_x_mode_line_or_eval() || word-wise search that</a>
<a name="ln3155">    // has added a word that was at the beginning of the line.</a>
<a name="ln3156">    if (ctrl_x_mode_line_or_eval() || (compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln3157">      found_new_match = search_for_exact_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3158">                                              compl_direction, compl_pattern);</a>
<a name="ln3159">    } else {</a>
<a name="ln3160">      found_new_match = searchit(NULL, st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3161">                                 NULL, compl_direction, compl_pattern, 1L,</a>
<a name="ln3162">                                 SEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);</a>
<a name="ln3163">    }</a>
<a name="ln3164">    msg_silent--;</a>
<a name="ln3165">    if (!compl_started || st-&gt;set_match_pos) {</a>
<a name="ln3166">      // set &quot;compl_started&quot; even on fail</a>
<a name="ln3167">      compl_started = true;</a>
<a name="ln3168">      st-&gt;first_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3169">      st-&gt;last_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3170">      st-&gt;set_match_pos = false;</a>
<a name="ln3171">    } else if (st-&gt;first_match_pos.lnum == st-&gt;last_match_pos.lnum</a>
<a name="ln3172">               &amp;&amp; st-&gt;first_match_pos.col == st-&gt;last_match_pos.col) {</a>
<a name="ln3173">      found_new_match = FAIL;</a>
<a name="ln3174">    } else if (compl_dir_forward()</a>
<a name="ln3175">               &amp;&amp; (st-&gt;prev_match_pos.lnum &gt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3176">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3177">                       &amp;&amp; st-&gt;prev_match_pos.col &gt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3178">      if (looped_around) {</a>
<a name="ln3179">        found_new_match = FAIL;</a>
<a name="ln3180">      } else {</a>
<a name="ln3181">        looped_around = true;</a>
<a name="ln3182">      }</a>
<a name="ln3183">    } else if (!compl_dir_forward()</a>
<a name="ln3184">               &amp;&amp; (st-&gt;prev_match_pos.lnum &lt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3185">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3186">                       &amp;&amp; st-&gt;prev_match_pos.col &lt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3187">      if (looped_around) {</a>
<a name="ln3188">        found_new_match = FAIL;</a>
<a name="ln3189">      } else {</a>
<a name="ln3190">        looped_around = true;</a>
<a name="ln3191">      }</a>
<a name="ln3192">    }</a>
<a name="ln3193">    st-&gt;prev_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3194">    if (found_new_match == FAIL) {</a>
<a name="ln3195">      break;</a>
<a name="ln3196">    }</a>
<a name="ln3197"> </a>
<a name="ln3198">    // when ADDING, the text before the cursor matches, skip it</a>
<a name="ln3199">    if (compl_status_adding() &amp;&amp; st-&gt;ins_buf == curbuf</a>
<a name="ln3200">        &amp;&amp; start_pos-&gt;lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3201">        &amp;&amp; start_pos-&gt;col == st-&gt;cur_match_pos-&gt;col) {</a>
<a name="ln3202">      continue;</a>
<a name="ln3203">    }</a>
<a name="ln3204">    int len;</a>
<a name="ln3205">    char *ptr = ins_compl_get_next_word_or_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3206">                                                &amp;len, &amp;cont_s_ipos);</a>
<a name="ln3207">    if (ptr == NULL) {</a>
<a name="ln3208">      continue;</a>
<a name="ln3209">    }</a>
<a name="ln3210">    if (ins_compl_add_infercase(ptr, len, p_ic,</a>
<a name="ln3211">                                st-&gt;ins_buf == curbuf ? NULL : st-&gt;ins_buf-&gt;b_sfname,</a>
<a name="ln3212">                                0, cont_s_ipos) != NOTDONE) {</a>
<a name="ln3213">      found_new_match = OK;</a>
<a name="ln3214">      break;</a>
<a name="ln3215">    }</a>
<a name="ln3216">  }</a>
<a name="ln3217">  p_scs = save_p_scs;</a>
<a name="ln3218">  p_ws = save_p_ws;</a>
<a name="ln3219"> </a>
<a name="ln3220">  return found_new_match;</a>
<a name="ln3221">}</a>
<a name="ln3222"> </a>
<a name="ln3223">/// get the next set of completion matches for &quot;type&quot;.</a>
<a name="ln3224">/// @return  true if a new match is found, otherwise false.</a>
<a name="ln3225">static bool get_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)</a>
<a name="ln3226">{</a>
<a name="ln3227">  int found_new_match = FAIL;</a>
<a name="ln3228"> </a>
<a name="ln3229">  switch (type) {</a>
<a name="ln3230">  case -1:</a>
<a name="ln3231">    break;</a>
<a name="ln3232">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln3233">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln3234">    get_next_include_file_completion(type);</a>
<a name="ln3235">    break;</a>
<a name="ln3236"> </a>
<a name="ln3237">  case CTRL_X_DICTIONARY:</a>
<a name="ln3238">  case CTRL_X_THESAURUS:</a>
<a name="ln3239">    get_next_dict_tsr_completion(type, st-&gt;dict, st-&gt;dict_f);</a>
<a name="ln3240">    st-&gt;dict = NULL;</a>
<a name="ln3241">    break;</a>
<a name="ln3242"> </a>
<a name="ln3243">  case CTRL_X_TAGS:</a>
<a name="ln3244">    get_next_tag_completion();</a>
<a name="ln3245">    break;</a>
<a name="ln3246"> </a>
<a name="ln3247">  case CTRL_X_FILES:</a>
<a name="ln3248">    get_next_filename_completion();</a>
<a name="ln3249">    break;</a>
<a name="ln3250"> </a>
<a name="ln3251">  case CTRL_X_CMDLINE:</a>
<a name="ln3252">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln3253">    get_next_cmdline_completion();</a>
<a name="ln3254">    break;</a>
<a name="ln3255"> </a>
<a name="ln3256">  case CTRL_X_FUNCTION:</a>
<a name="ln3257">  case CTRL_X_OMNI:</a>
<a name="ln3258">    expand_by_function(type, compl_pattern);</a>
<a name="ln3259">    break;</a>
<a name="ln3260"> </a>
<a name="ln3261">  case CTRL_X_SPELL:</a>
<a name="ln3262">    get_next_spell_completion(st-&gt;first_match_pos.lnum);</a>
<a name="ln3263">    break;</a>
<a name="ln3264"> </a>
<a name="ln3265">  default:            // normal ^P/^N and ^X^L</a>
<a name="ln3266">    found_new_match = get_next_default_completion(st, ini);</a>
<a name="ln3267">    if (found_new_match == FAIL &amp;&amp; st-&gt;ins_buf == curbuf) {</a>
<a name="ln3268">      st-&gt;found_all = true;</a>
<a name="ln3269">    }</a>
<a name="ln3270">  }</a>
<a name="ln3271"> </a>
<a name="ln3272">  // check if compl_curr_match has changed, (e.g. other type of</a>
<a name="ln3273">  // expansion added something)</a>
<a name="ln3274">  if (type != 0 &amp;&amp; compl_curr_match != compl_old_match) {</a>
<a name="ln3275">    found_new_match = OK;</a>
<a name="ln3276">  }</a>
<a name="ln3277"> </a>
<a name="ln3278">  return found_new_match;</a>
<a name="ln3279">}</a>
<a name="ln3280"> </a>
<a name="ln3281">/// Get the next expansion(s), using &quot;compl_pattern&quot;.</a>
<a name="ln3282">/// The search starts at position &quot;ini&quot; in curbuf and in the direction</a>
<a name="ln3283">/// compl_direction.</a>
<a name="ln3284">/// When &quot;compl_started&quot; is false start at that position, otherwise continue</a>
<a name="ln3285">/// where we stopped searching before.</a>
<a name="ln3286">/// This may return before finding all the matches.</a>
<a name="ln3287">/// Return the total number of matches or -1 if still unknown -- Acevedo</a>
<a name="ln3288">static int ins_compl_get_exp(pos_T *ini)</a>
<a name="ln3289">{</a>
<a name="ln3290">  static ins_compl_next_state_T st;</a>
<a name="ln3291">  static bool st_cleared = false;</a>
<a name="ln3292">  int i;</a>
<a name="ln3293">  int found_new_match;</a>
<a name="ln3294">  int type = ctrl_x_mode;</a>
<a name="ln3295"> </a>
<a name="ln3296">  assert(curbuf != NULL);</a>
<a name="ln3297"> </a>
<a name="ln3298">  if (!compl_started) {</a>
<a name="ln3299">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln3300">      buf-&gt;b_scanned = false;</a>
<a name="ln3301">    }</a>
<a name="ln3302">    if (!st_cleared) {</a>
<a name="ln3303">      CLEAR_FIELD(st);</a>
<a name="ln3304">      st_cleared = true;</a>
<a name="ln3305">    }</a>
<a name="ln3306">    st.found_all = false;</a>
<a name="ln3307">    st.ins_buf = curbuf;</a>
<a name="ln3308">    xfree(st.e_cpt_copy);</a>
<a name="ln3309">    // Make a copy of 'complete', in case the buffer is wiped out.</a>
<a name="ln3310">    st.e_cpt_copy = xstrdup((compl_cont_status &amp; CONT_LOCAL) ? &quot;.&quot; : curbuf-&gt;b_p_cpt);</a>
<a name="ln3311">    st.e_cpt = st.e_cpt_copy == NULL ? &quot;&quot; : st.e_cpt_copy;</a>
<a name="ln3312">    st.last_match_pos = st.first_match_pos = *ini;</a>
<a name="ln3313">  } else if (st.ins_buf != curbuf &amp;&amp; !buf_valid(st.ins_buf)) {</a>
<a name="ln3314">    st.ins_buf = curbuf;  // In case the buffer was wiped out.</a>
<a name="ln3315">  }</a>
<a name="ln3316">  assert(st.ins_buf != NULL);</a>
<a name="ln3317"> </a>
<a name="ln3318">  compl_old_match = compl_curr_match;   // remember the last current match</a>
<a name="ln3319">  st.cur_match_pos = compl_dir_forward() ? &amp;st.last_match_pos : &amp;st.first_match_pos;</a>
<a name="ln3320"> </a>
<a name="ln3321">  // For ^N/^P loop over all the flags/windows/buffers in 'complete'</a>
<a name="ln3322">  while (true) {</a>
<a name="ln3323">    found_new_match = FAIL;</a>
<a name="ln3324">    st.set_match_pos = false;</a>
<a name="ln3325"> </a>
<a name="ln3326">    // For ^N/^P pick a new entry from e_cpt if compl_started is off,</a>
<a name="ln3327">    // or if found_all says this entry is done.  For ^X^L only use the</a>
<a name="ln3328">    // entries from 'complete' that look in loaded buffers.</a>
<a name="ln3329">    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3330">        &amp;&amp; (!compl_started || st.found_all)) {</a>
<a name="ln3331">      int status = process_next_cpt_value(&amp;st, &amp;type, ini);</a>
<a name="ln3332">      if (status == INS_COMPL_CPT_END) {</a>
<a name="ln3333">        break;</a>
<a name="ln3334">      }</a>
<a name="ln3335">      if (status == INS_COMPL_CPT_CONT) {</a>
<a name="ln3336">        continue;</a>
<a name="ln3337">      }</a>
<a name="ln3338">    }</a>
<a name="ln3339"> </a>
<a name="ln3340">    // If complete() was called then compl_pattern has been reset.</a>
<a name="ln3341">    // The following won't work then, bail out.</a>
<a name="ln3342">    if (compl_pattern == NULL) {</a>
<a name="ln3343">      break;</a>
<a name="ln3344">    }</a>
<a name="ln3345"> </a>
<a name="ln3346">    // get the next set of completion matches</a>
<a name="ln3347">    found_new_match = get_next_completion_match(type, &amp;st, ini);</a>
<a name="ln3348"> </a>
<a name="ln3349">    // break the loop for specialized modes (use 'complete' just for the</a>
<a name="ln3350">    // generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new match</a>
<a name="ln3351">    if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3352">        || found_new_match != FAIL) {</a>
<a name="ln3353">      if (got_int) {</a>
<a name="ln3354">        break;</a>
<a name="ln3355">      }</a>
<a name="ln3356">      // Fill the popup menu as soon as possible.</a>
<a name="ln3357">      if (type != -1) {</a>
<a name="ln3358">        ins_compl_check_keys(0, false);</a>
<a name="ln3359">      }</a>
<a name="ln3360"> </a>
<a name="ln3361">      if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3362">          || compl_interrupted) {</a>
<a name="ln3363">        break;</a>
<a name="ln3364">      }</a>
<a name="ln3365">      compl_started = true;</a>
<a name="ln3366">    } else {</a>
<a name="ln3367">      // Mark a buffer scanned when it has been scanned completely</a>
<a name="ln3368">      if (type == 0 || type == CTRL_X_PATH_PATTERNS) {</a>
<a name="ln3369">        assert(st.ins_buf);</a>
<a name="ln3370">        st.ins_buf-&gt;b_scanned = true;</a>
<a name="ln3371">      }</a>
<a name="ln3372"> </a>
<a name="ln3373">      compl_started = false;</a>
<a name="ln3374">    }</a>
<a name="ln3375">  }</a>
<a name="ln3376">  compl_started = true;</a>
<a name="ln3377"> </a>
<a name="ln3378">  if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3379">      &amp;&amp; *st.e_cpt == NUL) {  // Got to end of 'complete'</a>
<a name="ln3380">    found_new_match = FAIL;</a>
<a name="ln3381">  }</a>
<a name="ln3382"> </a>
<a name="ln3383">  i = -1;               // total of matches, unknown</a>
<a name="ln3384">  if (found_new_match == FAIL</a>
<a name="ln3385">      || (ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())) {</a>
<a name="ln3386">    i = ins_compl_make_cyclic();</a>
<a name="ln3387">  }</a>
<a name="ln3388"> </a>
<a name="ln3389">  if (compl_old_match != NULL) {</a>
<a name="ln3390">    // If several matches were added (FORWARD) or the search failed and has</a>
<a name="ln3391">    // just been made cyclic then we have to move compl_curr_match to the</a>
<a name="ln3392">    // next or previous entry (if any) -- Acevedo</a>
<a name="ln3393">    compl_curr_match = compl_dir_forward()</a>
<a name="ln3394">                        ? compl_old_match-&gt;cp_next</a>
<a name="ln3395">                        : compl_old_match-&gt;cp_prev;</a>
<a name="ln3396">    if (compl_curr_match == NULL) {</a>
<a name="ln3397">      compl_curr_match = compl_old_match;</a>
<a name="ln3398">    }</a>
<a name="ln3399">  }</a>
<a name="ln3400">  may_trigger_modechanged();</a>
<a name="ln3401"> </a>
<a name="ln3402">  return i;</a>
<a name="ln3403">}</a>
<a name="ln3404"> </a>
<a name="ln3405">/// Update &quot;compl_shown_match&quot; to the actually shown match, it may differ when</a>
<a name="ln3406">/// &quot;compl_leader&quot; is used to omit some of the matches.</a>
<a name="ln3407">static void ins_compl_update_shown_match(void)</a>
<a name="ln3408">{</a>
<a name="ln3409">  while (!ins_compl_equal(compl_shown_match,</a>
<a name="ln3410">                          compl_leader, strlen(compl_leader))</a>
<a name="ln3411">         &amp;&amp; compl_shown_match-&gt;cp_next != NULL</a>
<a name="ln3412">         &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_next)) {</a>
<a name="ln3413">    compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3414">  }</a>
<a name="ln3415"> </a>
<a name="ln3416">  // If we didn't find it searching forward, and compl_shows_dir is</a>
<a name="ln3417">  // backward, find the last match.</a>
<a name="ln3418">  if (compl_shows_dir_backward()</a>
<a name="ln3419">      &amp;&amp; !ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3420">      &amp;&amp; (compl_shown_match-&gt;cp_next == NULL</a>
<a name="ln3421">          || is_first_match(compl_shown_match-&gt;cp_next))) {</a>
<a name="ln3422">    while (!ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3423">           &amp;&amp; compl_shown_match-&gt;cp_prev != NULL</a>
<a name="ln3424">           &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_prev)) {</a>
<a name="ln3425">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3426">    }</a>
<a name="ln3427">  }</a>
<a name="ln3428">}</a>
<a name="ln3429"> </a>
<a name="ln3430">/// Delete the old text being completed.</a>
<a name="ln3431">void ins_compl_delete(void)</a>
<a name="ln3432">{</a>
<a name="ln3433">  int col;</a>
<a name="ln3434"> </a>
<a name="ln3435">  // In insert mode: Delete the typed part.</a>
<a name="ln3436">  // In replace mode: Put the old characters back, if any.</a>
<a name="ln3437">  col = compl_col + (compl_status_adding() ? compl_length : 0);</a>
<a name="ln3438">  if ((int)curwin-&gt;w_cursor.col &gt; col) {</a>
<a name="ln3439">    if (stop_arrow() == FAIL) {</a>
<a name="ln3440">      return;</a>
<a name="ln3441">    }</a>
<a name="ln3442">    backspace_until_column(col);</a>
<a name="ln3443">  }</a>
<a name="ln3444"> </a>
<a name="ln3445">  // TODO(vim): is this sufficient for redrawing?  Redrawing everything</a>
<a name="ln3446">  // causes flicker, thus we can't do that.</a>
<a name="ln3447">  changed_cline_bef_curs(curwin);</a>
<a name="ln3448">  // clear v:completed_item</a>
<a name="ln3449">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln3450">}</a>
<a name="ln3451"> </a>
<a name="ln3452">/// Insert the new text being completed.</a>
<a name="ln3453">/// &quot;in_compl_func&quot; is true when called from complete_check().</a>
<a name="ln3454">void ins_compl_insert(bool in_compl_func)</a>
<a name="ln3455">{</a>
<a name="ln3456">  ins_bytes(compl_shown_match-&gt;cp_str + get_compl_len());</a>
<a name="ln3457">  compl_used_match = !match_at_original_text(compl_shown_match);</a>
<a name="ln3458"> </a>
<a name="ln3459">  dict_T *dict = ins_compl_dict_alloc(compl_shown_match);</a>
<a name="ln3460">  set_vim_var_dict(VV_COMPLETED_ITEM, dict);</a>
<a name="ln3461">  if (!in_compl_func) {</a>
<a name="ln3462">    compl_curr_match = compl_shown_match;</a>
<a name="ln3463">  }</a>
<a name="ln3464">}</a>
<a name="ln3465"> </a>
<a name="ln3466">/// show the file name for the completion match (if any).  Truncate the file</a>
<a name="ln3467">/// name to avoid a wait for return.</a>
<a name="ln3468">static void ins_compl_show_filename(void)</a>
<a name="ln3469">{</a>
<a name="ln3470">  char *const lead = _(&quot;match in file&quot;);</a>
<a name="ln3471">  int space = sc_col - vim_strsize(lead) - 2;</a>
<a name="ln3472">  if (space &lt;= 0) {</a>
<a name="ln3473">    return;</a>
<a name="ln3474">  }</a>
<a name="ln3475"> </a>
<a name="ln3476">  // We need the tail that fits.  With double-byte encoding going</a>
<a name="ln3477">  // back from the end is very slow, thus go from the start and keep</a>
<a name="ln3478">  // the text that fits in &quot;space&quot; between &quot;s&quot; and &quot;e&quot;.</a>
<a name="ln3479">  char *s;</a>
<a name="ln3480">  char *e;</a>
<a name="ln3481">  for (s = e = compl_shown_match-&gt;cp_fname; *e != NUL; MB_PTR_ADV(e)) {</a>
<a name="ln3482">    space -= ptr2cells(e);</a>
<a name="ln3483">    while (space &lt; 0) {</a>
<a name="ln3484">      space += ptr2cells(s);</a>
<a name="ln3485">      MB_PTR_ADV(s);</a>
<a name="ln3486">    }</a>
<a name="ln3487">  }</a>
<a name="ln3488">  msg_hist_off = true;</a>
<a name="ln3489">  vim_snprintf(IObuff, IOSIZE, &quot;%s %s%s&quot;, lead,</a>
<a name="ln3490">               s &gt; compl_shown_match-&gt;cp_fname ? &quot;&lt;&quot; : &quot;&quot;, s);</a>
<a name="ln3491">  msg(IObuff, 0);</a>
<a name="ln3492">  msg_hist_off = false;</a>
<a name="ln3493">  redraw_cmdline = false;  // don't overwrite!</a>
<a name="ln3494">}</a>
<a name="ln3495"> </a>
<a name="ln3496">/// Find the next set of matches for completion. Repeat the completion &quot;todo&quot;</a>
<a name="ln3497">/// times.  The number of matches found is returned in 'num_matches'.</a>
<a name="ln3498">///</a>
<a name="ln3499">/// @param allow_get_expansion  If true, then ins_compl_get_exp() may be called to</a>
<a name="ln3500">///                             get more completions.</a>
<a name="ln3501">///                             If false, then do nothing when there are no more</a>
<a name="ln3502">///                             completions in the given direction.</a>
<a name="ln3503">/// @param todo  repeat completion this many times</a>
<a name="ln3504">/// @param advance  If true, then completion will move to the first match.</a>
<a name="ln3505">///                 Otherwise, the original text will be shown.</a>
<a name="ln3506">///</a>
<a name="ln3507">/// @return  OK on success and -1 if the number of matches are unknown.</a>
<a name="ln3508">static int find_next_completion_match(bool allow_get_expansion, int todo, bool advance,</a>
<a name="ln3509">                                      int *num_matches)</a>
<a name="ln3510">{</a>
<a name="ln3511">  bool found_end = false;</a>
<a name="ln3512">  compl_T *found_compl = NULL;</a>
<a name="ln3513"> </a>
<a name="ln3514">  while (--todo &gt;= 0) {</a>
<a name="ln3515">    if (compl_shows_dir_forward() &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3516">      compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3517">      found_end = (compl_first_match != NULL</a>
<a name="ln3518">                   &amp;&amp; (is_first_match(compl_shown_match-&gt;cp_next)</a>
<a name="ln3519">                       || is_first_match(compl_shown_match)));</a>
<a name="ln3520">    } else if (compl_shows_dir_backward()</a>
<a name="ln3521">               &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3522">      found_end = is_first_match(compl_shown_match);</a>
<a name="ln3523">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3524">      found_end |= is_first_match(compl_shown_match);</a>
<a name="ln3525">    } else {</a>
<a name="ln3526">      if (!allow_get_expansion) {</a>
<a name="ln3527">        if (advance) {</a>
<a name="ln3528">          if (compl_shows_dir_backward()) {</a>
<a name="ln3529">            compl_pending -= todo + 1;</a>
<a name="ln3530">          } else {</a>
<a name="ln3531">            compl_pending += todo + 1;</a>
<a name="ln3532">          }</a>
<a name="ln3533">        }</a>
<a name="ln3534">        return -1;</a>
<a name="ln3535">      }</a>
<a name="ln3536"> </a>
<a name="ln3537">      if (!compl_no_select &amp;&amp; advance) {</a>
<a name="ln3538">        if (compl_shows_dir_backward()) {</a>
<a name="ln3539">          compl_pending--;</a>
<a name="ln3540">        } else {</a>
<a name="ln3541">          compl_pending++;</a>
<a name="ln3542">        }</a>
<a name="ln3543">      }</a>
<a name="ln3544"> </a>
<a name="ln3545">      // Find matches.</a>
<a name="ln3546">      *num_matches = ins_compl_get_exp(&amp;compl_startpos);</a>
<a name="ln3547"> </a>
<a name="ln3548">      // handle any pending completions</a>
<a name="ln3549">      while (compl_pending != 0 &amp;&amp; compl_direction == compl_shows_dir</a>
<a name="ln3550">             &amp;&amp; advance) {</a>
<a name="ln3551">        if (compl_pending &gt; 0 &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3552">          compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3553">          compl_pending--;</a>
<a name="ln3554">        }</a>
<a name="ln3555">        if (compl_pending &lt; 0 &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3556">          compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3557">          compl_pending++;</a>
<a name="ln3558">        } else {</a>
<a name="ln3559">          break;</a>
<a name="ln3560">        }</a>
<a name="ln3561">      }</a>
<a name="ln3562">      found_end = false;</a>
<a name="ln3563">    }</a>
<a name="ln3564">    if (!match_at_original_text(compl_shown_match)</a>
<a name="ln3565">        &amp;&amp; compl_leader != NULL</a>
<a name="ln3566">        &amp;&amp; !ins_compl_equal(compl_shown_match,</a>
<a name="ln3567">                            compl_leader, strlen(compl_leader))) {</a>
<a name="ln3568">      todo++;</a>
<a name="ln3569">    } else {</a>
<a name="ln3570">      // Remember a matching item.</a>
<a name="ln3571">      found_compl = compl_shown_match;</a>
<a name="ln3572">    }</a>
<a name="ln3573"> </a>
<a name="ln3574">    // Stop at the end of the list when we found a usable match.</a>
<a name="ln3575">    if (found_end) {</a>
<a name="ln3576">      if (found_compl != NULL) {</a>
<a name="ln3577">        compl_shown_match = found_compl;</a>
<a name="ln3578">        break;</a>
<a name="ln3579">      }</a>
<a name="ln3580">      todo = 1;             // use first usable match after wrapping around</a>
<a name="ln3581">    }</a>
<a name="ln3582">  }</a>
<a name="ln3583"> </a>
<a name="ln3584">  return OK;</a>
<a name="ln3585">}</a>
<a name="ln3586"> </a>
<a name="ln3587">/// Fill in the next completion in the current direction.</a>
<a name="ln3588">/// If &quot;allow_get_expansion&quot; is true, then we may call ins_compl_get_exp() to</a>
<a name="ln3589">/// get more completions.  If it is false, then we just do nothing when there</a>
<a name="ln3590">/// are no more completions in a given direction.  The latter case is used when</a>
<a name="ln3591">/// we are still in the middle of finding completions, to allow browsing</a>
<a name="ln3592">/// through the ones found so far.</a>
<a name="ln3593">/// @return  the total number of matches, or -1 if still unknown -- webb.</a>
<a name="ln3594">///</a>
<a name="ln3595">/// compl_curr_match is currently being used by ins_compl_get_exp(), so we use</a>
<a name="ln3596">/// compl_shown_match here.</a>
<a name="ln3597">///</a>
<a name="ln3598">/// Note that this function may be called recursively once only.  First with</a>
<a name="ln3599">/// &quot;allow_get_expansion&quot; true, which calls ins_compl_get_exp(), which in turn</a>
<a name="ln3600">/// calls this function with &quot;allow_get_expansion&quot; false.</a>
<a name="ln3601">///</a>
<a name="ln3602">/// @param count          Repeat completion this many times; should be at least 1</a>
<a name="ln3603">/// @param insert_match   Insert the newly selected match</a>
<a name="ln3604">/// @param in_compl_func  Called from complete_check()</a>
<a name="ln3605">static int ins_compl_next(bool allow_get_expansion, int count, bool insert_match,</a>
<a name="ln3606">                          bool in_compl_func)</a>
<a name="ln3607">{</a>
<a name="ln3608">  int num_matches = -1;</a>
<a name="ln3609">  int todo = count;</a>
<a name="ln3610">  const bool started = compl_started;</a>
<a name="ln3611">  buf_T *const orig_curbuf = curbuf;</a>
<a name="ln3612"> </a>
<a name="ln3613">  // When user complete function return -1 for findstart which is next</a>
<a name="ln3614">  // time of 'always', compl_shown_match become NULL.</a>
<a name="ln3615">  if (compl_shown_match == NULL) {</a>
<a name="ln3616">    return -1;</a>
<a name="ln3617">  }</a>
<a name="ln3618"> </a>
<a name="ln3619">  if (compl_leader != NULL &amp;&amp; !match_at_original_text(compl_shown_match)) {</a>
<a name="ln3620">    // Update &quot;compl_shown_match&quot; to the actually shown match</a>
<a name="ln3621">    ins_compl_update_shown_match();</a>
<a name="ln3622">  }</a>
<a name="ln3623"> </a>
<a name="ln3624">  if (allow_get_expansion &amp;&amp; insert_match</a>
<a name="ln3625">      &amp;&amp; (!(compl_get_longest || compl_restarting) || compl_used_match)) {</a>
<a name="ln3626">    // Delete old text to be replaced</a>
<a name="ln3627">    ins_compl_delete();</a>
<a name="ln3628">  }</a>
<a name="ln3629"> </a>
<a name="ln3630">  // When finding the longest common text we stick at the original text,</a>
<a name="ln3631">  // don't let CTRL-N or CTRL-P move to the first match.</a>
<a name="ln3632">  bool advance = count != 1 || !allow_get_expansion || !compl_get_longest;</a>
<a name="ln3633"> </a>
<a name="ln3634">  // When restarting the search don't insert the first match either.</a>
<a name="ln3635">  if (compl_restarting) {</a>
<a name="ln3636">    advance = false;</a>
<a name="ln3637">    compl_restarting = false;</a>
<a name="ln3638">  }</a>
<a name="ln3639"> </a>
<a name="ln3640">  // Repeat this for when &lt;PageUp&gt; or &lt;PageDown&gt; is typed.  But don't wrap</a>
<a name="ln3641">  // around.</a>
<a name="ln3642">  if (find_next_completion_match(allow_get_expansion, todo, advance,</a>
<a name="ln3643">                                 &amp;num_matches) == -1) {</a>
<a name="ln3644">    return -1;</a>
<a name="ln3645">  }</a>
<a name="ln3646"> </a>
<a name="ln3647">  if (curbuf != orig_curbuf) {</a>
<a name="ln3648">    // In case some completion function switched buffer, don't want to</a>
<a name="ln3649">    // insert the completion elsewhere.</a>
<a name="ln3650">    return -1;</a>
<a name="ln3651">  }</a>
<a name="ln3652"> </a>
<a name="ln3653">  // Insert the text of the new completion, or the compl_leader.</a>
<a name="ln3654">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3655">    ins_bytes(compl_orig_text + get_compl_len());</a>
<a name="ln3656">    compl_used_match = false;</a>
<a name="ln3657">  } else if (insert_match) {</a>
<a name="ln3658">    if (!compl_get_longest || compl_used_match) {</a>
<a name="ln3659">      ins_compl_insert(in_compl_func);</a>
<a name="ln3660">    } else {</a>
<a name="ln3661">      ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln3662">    }</a>
<a name="ln3663">  } else {</a>
<a name="ln3664">    compl_used_match = false;</a>
<a name="ln3665">  }</a>
<a name="ln3666"> </a>
<a name="ln3667">  if (!allow_get_expansion) {</a>
<a name="ln3668">    // redraw to show the user what was inserted</a>
<a name="ln3669">    update_screen();  // TODO(bfredl): no!</a>
<a name="ln3670"> </a>
<a name="ln3671">    // display the updated popup menu</a>
<a name="ln3672">    ins_compl_show_pum();</a>
<a name="ln3673"> </a>
<a name="ln3674">    // Delete old text to be replaced, since we're still searching and</a>
<a name="ln3675">    // don't want to match ourselves!</a>
<a name="ln3676">    ins_compl_delete();</a>
<a name="ln3677">  }</a>
<a name="ln3678"> </a>
<a name="ln3679">  // Enter will select a match when the match wasn't inserted and the popup</a>
<a name="ln3680">  // menu is visible.</a>
<a name="ln3681">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3682">    compl_enter_selects = true;</a>
<a name="ln3683">  } else {</a>
<a name="ln3684">    compl_enter_selects = !insert_match &amp;&amp; compl_match_array != NULL;</a>
<a name="ln3685">  }</a>
<a name="ln3686"> </a>
<a name="ln3687">  // Show the file name for the match (if any)</a>
<a name="ln3688">  if (compl_shown_match-&gt;cp_fname != NULL) {</a>
<a name="ln3689">    ins_compl_show_filename();</a>
<a name="ln3690">  }</a>
<a name="ln3691"> </a>
<a name="ln3692">  return num_matches;</a>
<a name="ln3693">}</a>
<a name="ln3694"> </a>
<a name="ln3695">/// Call this while finding completions, to check whether the user has hit a key</a>
<a name="ln3696">/// that should change the currently displayed completion, or exit completion</a>
<a name="ln3697">/// mode.  Also, when compl_pending is not zero, show a completion as soon as</a>
<a name="ln3698">/// possible. -- webb</a>
<a name="ln3699">///</a>
<a name="ln3700">/// @param frequency      specifies out of how many calls we actually check.</a>
<a name="ln3701">/// @param in_compl_func  true when called from complete_check(), don't set</a>
<a name="ln3702">///                       compl_curr_match.</a>
<a name="ln3703">void ins_compl_check_keys(int frequency, bool in_compl_func)</a>
<a name="ln3704">{</a>
<a name="ln3705">  static int count = 0;</a>
<a name="ln3706"> </a>
<a name="ln3707">  // Don't check when reading keys from a script, :normal or feedkeys().</a>
<a name="ln3708">  // That would break the test scripts.  But do check for keys when called</a>
<a name="ln3709">  // from complete_check().</a>
<a name="ln3710">  if (!in_compl_func &amp;&amp; (using_script() || ex_normal_busy)) {</a>
<a name="ln3711">    return;</a>
<a name="ln3712">  }</a>
<a name="ln3713"> </a>
<a name="ln3714">  // Only do this at regular intervals</a>
<a name="ln3715">  if (++count &lt; frequency) {</a>
<a name="ln3716">    return;</a>
<a name="ln3717">  }</a>
<a name="ln3718">  count = 0;</a>
<a name="ln3719"> </a>
<a name="ln3720">  // Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()</a>
<a name="ln3721">  // can't do its work correctly.</a>
<a name="ln3722">  int c = vpeekc_any();</a>
<a name="ln3723">  if (c != NUL) {</a>
<a name="ln3724">    if (vim_is_ctrl_x_key(c) &amp;&amp; c != Ctrl_X &amp;&amp; c != Ctrl_R) {</a>
<a name="ln3725">      c = safe_vgetc();         // Eat the character</a>
<a name="ln3726">      compl_shows_dir = ins_compl_key2dir(c);</a>
<a name="ln3727">      (void)ins_compl_next(false, ins_compl_key2count(c),</a>
<a name="ln3728">                           c != K_UP &amp;&amp; c != K_DOWN, in_compl_func);</a>
<a name="ln3729">    } else {</a>
<a name="ln3730">      // Need to get the character to have KeyTyped set.  We'll put it</a>
<a name="ln3731">      // back with vungetc() below.  But skip K_IGNORE.</a>
<a name="ln3732">      c = safe_vgetc();</a>
<a name="ln3733">      if (c != K_IGNORE) {</a>
<a name="ln3734">        // Don't interrupt completion when the character wasn't typed,</a>
<a name="ln3735">        // e.g., when doing @q to replay keys.</a>
<a name="ln3736">        if (c != Ctrl_R &amp;&amp; KeyTyped) {</a>
<a name="ln3737">          compl_interrupted = true;</a>
<a name="ln3738">        }</a>
<a name="ln3739"> </a>
<a name="ln3740">        vungetc(c);</a>
<a name="ln3741">      }</a>
<a name="ln3742">    }</a>
<a name="ln3743">  }</a>
<a name="ln3744">  if (compl_pending != 0 &amp;&amp; !got_int &amp;&amp; !compl_no_insert) {</a>
<a name="ln3745">    int todo = compl_pending &gt; 0 ? compl_pending : -compl_pending;</a>
<a name="ln3746"> </a>
<a name="ln3747">    compl_pending = 0;</a>
<a name="ln3748">    (void)ins_compl_next(false, todo, true, in_compl_func);</a>
<a name="ln3749">  }</a>
<a name="ln3750">}</a>
<a name="ln3751"> </a>
<a name="ln3752">/// Decide the direction of Insert mode complete from the key typed.</a>
<a name="ln3753">/// Returns BACKWARD or FORWARD.</a>
<a name="ln3754">static int ins_compl_key2dir(int c)</a>
<a name="ln3755">{</a>
<a name="ln3756">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3757">    return pum_want.item &lt; pum_selected_item ? BACKWARD : FORWARD;</a>
<a name="ln3758">  }</a>
<a name="ln3759">  if (c == Ctrl_P || c == Ctrl_L</a>
<a name="ln3760">      || c == K_PAGEUP || c == K_KPAGEUP</a>
<a name="ln3761">      || c == K_S_UP || c == K_UP) {</a>
<a name="ln3762">    return BACKWARD;</a>
<a name="ln3763">  }</a>
<a name="ln3764">  return FORWARD;</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">/// Check that &quot;c&quot; is a valid completion key only while the popup menu is shown</a>
<a name="ln3768">///</a>
<a name="ln3769">/// @param  c  character to check</a>
<a name="ln3770">static bool ins_compl_pum_key(int c)</a>
<a name="ln3771">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3772">{</a>
<a name="ln3773">  return pum_visible() &amp;&amp; (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP</a>
<a name="ln3774">                           || c == K_PAGEDOWN || c == K_KPAGEDOWN</a>
<a name="ln3775">                           || c == K_S_DOWN || c == K_UP || c == K_DOWN);</a>
<a name="ln3776">}</a>
<a name="ln3777"> </a>
<a name="ln3778">/// Decide the number of completions to move forward.</a>
<a name="ln3779">/// Returns 1 for most keys, height of the popup menu for page-up/down keys.</a>
<a name="ln3780">static int ins_compl_key2count(int c)</a>
<a name="ln3781">{</a>
<a name="ln3782">  int h;</a>
<a name="ln3783"> </a>
<a name="ln3784">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3785">    int offset = pum_want.item - pum_selected_item;</a>
<a name="ln3786">    return abs(offset);</a>
<a name="ln3787">  }</a>
<a name="ln3788"> </a>
<a name="ln3789">  if (ins_compl_pum_key(c) &amp;&amp; c != K_UP &amp;&amp; c != K_DOWN) {</a>
<a name="ln3790">    h = pum_get_height();</a>
<a name="ln3791">    if (h &gt; 3) {</a>
<a name="ln3792">      h -= 2;       // keep some context</a>
<a name="ln3793">    }</a>
<a name="ln3794">    return h;</a>
<a name="ln3795">  }</a>
<a name="ln3796">  return 1;</a>
<a name="ln3797">}</a>
<a name="ln3798"> </a>
<a name="ln3799">/// Check that completion with &quot;c&quot; should insert the match, false if only</a>
<a name="ln3800">/// to change the currently selected completion.</a>
<a name="ln3801">///</a>
<a name="ln3802">/// @param  c  character to check</a>
<a name="ln3803">static bool ins_compl_use_match(int c)</a>
<a name="ln3804">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3805">{</a>
<a name="ln3806">  switch (c) {</a>
<a name="ln3807">  case K_UP:</a>
<a name="ln3808">  case K_DOWN:</a>
<a name="ln3809">  case K_PAGEDOWN:</a>
<a name="ln3810">  case K_KPAGEDOWN:</a>
<a name="ln3811">  case K_S_DOWN:</a>
<a name="ln3812">  case K_PAGEUP:</a>
<a name="ln3813">  case K_KPAGEUP:</a>
<a name="ln3814">  case K_S_UP:</a>
<a name="ln3815">    return false;</a>
<a name="ln3816">  case K_EVENT:</a>
<a name="ln3817">  case K_COMMAND:</a>
<a name="ln3818">  case K_LUA:</a>
<a name="ln3819">    return pum_want.active &amp;&amp; pum_want.insert;</a>
<a name="ln3820">  }</a>
<a name="ln3821">  return true;</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824">/// Get the pattern, column and length for normal completion (CTRL-N CTRL-P</a>
<a name="ln3825">/// completion)</a>
<a name="ln3826">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3827">/// Uses the global variables: compl_cont_status and ctrl_x_mode</a>
<a name="ln3828">static int get_normal_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3829">{</a>
<a name="ln3830">  if ((compl_cont_status &amp; CONT_SOL) || ctrl_x_mode_path_defines()) {</a>
<a name="ln3831">    if (!compl_status_adding()) {</a>
<a name="ln3832">      while (--startcol &gt;= 0 &amp;&amp; vim_isIDc((uint8_t)line[startcol])) {}</a>
<a name="ln3833">      compl_col += ++startcol;</a>
<a name="ln3834">      compl_length = curs_col - startcol;</a>
<a name="ln3835">    }</a>
<a name="ln3836">    if (p_ic) {</a>
<a name="ln3837">      compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3838">    } else {</a>
<a name="ln3839">      compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3840">    }</a>
<a name="ln3841">  } else if (compl_status_adding()) {</a>
<a name="ln3842">    char *prefix = &quot;\\&lt;&quot;;</a>
<a name="ln3843"> </a>
<a name="ln3844">    // we need up to 2 extra chars for the prefix</a>
<a name="ln3845">    compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3846">    if (!vim_iswordp(line + compl_col)</a>
<a name="ln3847">        || (compl_col &gt; 0</a>
<a name="ln3848">            &amp;&amp; (vim_iswordp(mb_prevptr(line, line + compl_col))))) {</a>
<a name="ln3849">      prefix = &quot;&quot;;</a>
<a name="ln3850">    }</a>
<a name="ln3851">    STRCPY(compl_pattern, prefix);</a>
<a name="ln3852">    (void)quote_meta(compl_pattern + strlen(prefix),</a>
<a name="ln3853">                     line + compl_col, compl_length);</a>
<a name="ln3854">  } else if (--startcol &lt; 0</a>
<a name="ln3855">             || !vim_iswordp(mb_prevptr(line, line + startcol + 1))) {</a>
<a name="ln3856">    // Match any word of at least two chars</a>
<a name="ln3857">    compl_pattern = xstrdup(&quot;\\&lt;\\k\\k&quot;);</a>
<a name="ln3858">    compl_col += curs_col;</a>
<a name="ln3859">    compl_length = 0;</a>
<a name="ln3860">  } else {</a>
<a name="ln3861">    // Search the point of change class of multibyte character</a>
<a name="ln3862">    // or not a word single byte character backward.</a>
<a name="ln3863">    startcol -= utf_head_off(line, line + startcol);</a>
<a name="ln3864">    int base_class = mb_get_class(line + startcol);</a>
<a name="ln3865">    while (--startcol &gt;= 0) {</a>
<a name="ln3866">      int head_off = utf_head_off(line, line + startcol);</a>
<a name="ln3867">      if (base_class != mb_get_class(line + startcol - head_off)) {</a>
<a name="ln3868">        break;</a>
<a name="ln3869">      }</a>
<a name="ln3870">      startcol -= head_off;</a>
<a name="ln3871">    }</a>
<a name="ln3872">    compl_col += ++startcol;</a>
<a name="ln3873">    compl_length = (int)curs_col - startcol;</a>
<a name="ln3874">    if (compl_length == 1) {</a>
<a name="ln3875">      // Only match word with at least two chars -- webb</a>
<a name="ln3876">      // there's no need to call quote_meta,</a>
<a name="ln3877">      // xmalloc(7) is enough  -- Acevedo</a>
<a name="ln3878">      compl_pattern = xmalloc(7);</a>
<a name="ln3879">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3880">      (void)quote_meta(compl_pattern + 2, line + compl_col, 1);</a>
<a name="ln3881">      STRCAT(compl_pattern, &quot;\\k&quot;);</a>
<a name="ln3882">    } else {</a>
<a name="ln3883">      compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3884">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3885">      (void)quote_meta(compl_pattern + 2, line + compl_col, compl_length);</a>
<a name="ln3886">    }</a>
<a name="ln3887">  }</a>
<a name="ln3888"> </a>
<a name="ln3889">  return OK;</a>
<a name="ln3890">}</a>
<a name="ln3891"> </a>
<a name="ln3892">/// Get the pattern, column and length for whole line completion or for the</a>
<a name="ln3893">/// complete() function.</a>
<a name="ln3894">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3895">static int get_wholeline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3896">{</a>
<a name="ln3897">  compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln3898">  compl_length = (int)curs_col - (int)compl_col;</a>
<a name="ln3899">  if (compl_length &lt; 0) {  // cursor in indent: empty pattern</a>
<a name="ln3900">    compl_length = 0;</a>
<a name="ln3901">  }</a>
<a name="ln3902">  if (p_ic) {</a>
<a name="ln3903">    compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3904">  } else {</a>
<a name="ln3905">    compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3906">  }</a>
<a name="ln3907"> </a>
<a name="ln3908">  return OK;</a>
<a name="ln3909">}</a>
<a name="ln3910"> </a>
<a name="ln3911">/// Get the pattern, column and length for filename completion.</a>
<a name="ln3912">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3913">static int get_filename_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3914">{</a>
<a name="ln3915">  // Go back to just before the first filename character.</a>
<a name="ln3916">  if (startcol &gt; 0) {</a>
<a name="ln3917">    char *p = line + startcol;</a>
<a name="ln3918"> </a>
<a name="ln3919">    MB_PTR_BACK(line, p);</a>
<a name="ln3920">    while (p &gt; line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3921">      MB_PTR_BACK(line, p);</a>
<a name="ln3922">    }</a>
<a name="ln3923">    if (p == line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3924">      startcol = 0;</a>
<a name="ln3925">    } else {</a>
<a name="ln3926">      startcol = (int)(p - line) + 1;</a>
<a name="ln3927">    }</a>
<a name="ln3928">  }</a>
<a name="ln3929"> </a>
<a name="ln3930">  compl_col += startcol;</a>
<a name="ln3931">  compl_length = (int)curs_col - startcol;</a>
<a name="ln3932">  compl_pattern = addstar(line + compl_col, (size_t)compl_length, EXPAND_FILES);</a>
<a name="ln3933"> </a>
<a name="ln3934">  return OK;</a>
<a name="ln3935">}</a>
<a name="ln3936"> </a>
<a name="ln3937">/// Get the pattern, column and length for command-line completion.</a>
<a name="ln3938">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3939">static int get_cmdline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3940">{</a>
<a name="ln3941">  compl_pattern = xstrnsave(line, (size_t)curs_col);</a>
<a name="ln3942">  set_cmd_context(&amp;compl_xp, compl_pattern, (int)strlen(compl_pattern), curs_col, false);</a>
<a name="ln3943">  if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL</a>
<a name="ln3944">      || compl_xp.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3945">    // No completion possible, use an empty pattern to get a</a>
<a name="ln3946">    // &quot;pattern not found&quot; message.</a>
<a name="ln3947">    compl_col = curs_col;</a>
<a name="ln3948">  } else {</a>
<a name="ln3949">    compl_col = (int)(compl_xp.xp_pattern - compl_pattern);</a>
<a name="ln3950">  }</a>
<a name="ln3951">  compl_length = curs_col - compl_col;</a>
<a name="ln3952"> </a>
<a name="ln3953">  return OK;</a>
<a name="ln3954">}</a>
<a name="ln3955"> </a>
<a name="ln3956">/// Get the pattern, column and length for user defined completion ('omnifunc',</a>
<a name="ln3957">/// 'completefunc' and 'thesaurusfunc')</a>
<a name="ln3958">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3959">/// Uses the global variable: spell_bad_len</a>
<a name="ln3960">static int get_userdefined_compl_info(colnr_T curs_col)</a>
<a name="ln3961">{</a>
<a name="ln3962">  // Call user defined function 'completefunc' with &quot;a:findstart&quot;</a>
<a name="ln3963">  // set to 1 to obtain the length of text to use for completion.</a>
<a name="ln3964">  const int save_State = State;</a>
<a name="ln3965"> </a>
<a name="ln3966">  // Call 'completefunc' or 'omnifunc' and get pattern length as a string</a>
<a name="ln3967">  char *funcname = get_complete_funcname(ctrl_x_mode);</a>
<a name="ln3968">  if (*funcname == NUL) {</a>
<a name="ln3969">    semsg(_(e_notset), ctrl_x_mode_function() ? &quot;completefunc&quot; : &quot;omnifunc&quot;);</a>
<a name="ln3970">    return FAIL;</a>
<a name="ln3971">  }</a>
<a name="ln3972"> </a>
<a name="ln3973">  typval_T args[3];</a>
<a name="ln3974">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln3975">  args[1].v_type = VAR_STRING;</a>
<a name="ln3976">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln3977">  args[0].vval.v_number = 1;</a>
<a name="ln3978">  args[1].vval.v_string = &quot;&quot;;</a>
<a name="ln3979"> </a>
<a name="ln3980">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3981">  textlock++;</a>
<a name="ln3982">  Callback *cb = get_insert_callback(ctrl_x_mode);</a>
<a name="ln3983">  colnr_T col = (colnr_T)callback_call_retnr(cb, 2, args);</a>
<a name="ln3984">  textlock--;</a>
<a name="ln3985"> </a>
<a name="ln3986">  State = save_State;</a>
<a name="ln3987">  curwin-&gt;w_cursor = pos;  // restore the cursor position</a>
<a name="ln3988">  validate_cursor();</a>
<a name="ln3989">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln3990">    emsg(_(e_compldel));</a>
<a name="ln3991">    return FAIL;</a>
<a name="ln3992">  }</a>
<a name="ln3993"> </a>
<a name="ln3994">  // Return value -2 means the user complete function wants to cancel the</a>
<a name="ln3995">  // complete without an error, do the same if the function did not execute</a>
<a name="ln3996">  // successfully.</a>
<a name="ln3997">  if (col == -2 || aborting()) {</a>
<a name="ln3998">    return FAIL;</a>
<a name="ln3999">  }</a>
<a name="ln4000">  // Return value -3 does the same as -2 and leaves CTRL-X mode.</a>
<a name="ln4001">  if (col == -3) {</a>
<a name="ln4002">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln4003">    edit_submode = NULL;</a>
<a name="ln4004">    if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4005">      msg_clr_cmdline();</a>
<a name="ln4006">    }</a>
<a name="ln4007">    return FAIL;</a>
<a name="ln4008">  }</a>
<a name="ln4009"> </a>
<a name="ln4010">  // Reset extended parameters of completion, when starting new</a>
<a name="ln4011">  // completion.</a>
<a name="ln4012">  compl_opt_refresh_always = false;</a>
<a name="ln4013"> </a>
<a name="ln4014">  if (col &lt; 0) {</a>
<a name="ln4015">    col = curs_col;</a>
<a name="ln4016">  }</a>
<a name="ln4017">  compl_col = col;</a>
<a name="ln4018">  if (compl_col &gt; curs_col) {</a>
<a name="ln4019">    compl_col = curs_col;</a>
<a name="ln4020">  }</a>
<a name="ln4021"> </a>
<a name="ln4022">  // Setup variables for completion.  Need to obtain &quot;line&quot; again,</a>
<a name="ln4023">  // it may have become invalid.</a>
<a name="ln4024">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4025">  compl_length = curs_col - compl_col;</a>
<a name="ln4026">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4027"> </a>
<a name="ln4028">  return OK;</a>
<a name="ln4029">}</a>
<a name="ln4030"> </a>
<a name="ln4031">/// Get the pattern, column and length for spell completion.</a>
<a name="ln4032">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln4033">/// Uses the global variable: spell_bad_len</a>
<a name="ln4034">static int get_spell_compl_info(int startcol, colnr_T curs_col)</a>
<a name="ln4035">{</a>
<a name="ln4036">  if (spell_bad_len &gt; 0) {</a>
<a name="ln4037">    assert(spell_bad_len &lt;= INT_MAX);</a>
<a name="ln4038">    compl_col = curs_col - (int)spell_bad_len;</a>
<a name="ln4039">  } else {</a>
<a name="ln4040">    compl_col = spell_word_start(startcol);</a>
<a name="ln4041">  }</a>
<a name="ln4042">  if (compl_col &gt;= (colnr_T)startcol) {</a>
<a name="ln4043">    compl_length = 0;</a>
<a name="ln4044">    compl_col = curs_col;</a>
<a name="ln4045">  } else {</a>
<a name="ln4046">    spell_expand_check_cap(compl_col);</a>
<a name="ln4047">    compl_length = (int)curs_col - compl_col;</a>
<a name="ln4048">  }</a>
<a name="ln4049">  // Need to obtain &quot;line&quot; again, it may have become invalid.</a>
<a name="ln4050">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4051">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4052"> </a>
<a name="ln4053">  return OK;</a>
<a name="ln4054">}</a>
<a name="ln4055"> </a>
<a name="ln4056">/// Get the completion pattern, column and length.</a>
<a name="ln4057">///</a>
<a name="ln4058">/// @param startcol  start column number of the completion pattern/text</a>
<a name="ln4059">/// @param cur_col   current cursor column</a>
<a name="ln4060">///</a>
<a name="ln4061">/// On return, &quot;line_invalid&quot; is set to true, if the current line may have</a>
<a name="ln4062">/// become invalid and needs to be fetched again.</a>
<a name="ln4063">///</a>
<a name="ln4064">/// @return  OK on success.</a>
<a name="ln4065">static int compl_get_info(char *line, int startcol, colnr_T curs_col, bool *line_invalid)</a>
<a name="ln4066">{</a>
<a name="ln4067">  if (ctrl_x_mode_normal()</a>
<a name="ln4068">      || ((ctrl_x_mode &amp; CTRL_X_WANT_IDENT)</a>
<a name="ln4069">          &amp;&amp; !thesaurus_func_complete(ctrl_x_mode))) {</a>
<a name="ln4070">    return get_normal_compl_info(line, startcol, curs_col);</a>
<a name="ln4071">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4072">    return get_wholeline_compl_info(line, curs_col);</a>
<a name="ln4073">  } else if (ctrl_x_mode_files()) {</a>
<a name="ln4074">    return get_filename_compl_info(line, startcol, curs_col);</a>
<a name="ln4075">  } else if (ctrl_x_mode == CTRL_X_CMDLINE) {</a>
<a name="ln4076">    return get_cmdline_compl_info(line, curs_col);</a>
<a name="ln4077">  } else if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4078">             || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4079">    if (get_userdefined_compl_info(curs_col) == FAIL) {</a>
<a name="ln4080">      return FAIL;</a>
<a name="ln4081">    }</a>
<a name="ln4082">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4083">  } else if (ctrl_x_mode_spell()) {</a>
<a name="ln4084">    if (get_spell_compl_info(startcol, curs_col) == FAIL) {</a>
<a name="ln4085">      return FAIL;</a>
<a name="ln4086">    }</a>
<a name="ln4087">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4088">  } else {</a>
<a name="ln4089">    internal_error(&quot;ins_complete()&quot;);</a>
<a name="ln4090">    return FAIL;</a>
<a name="ln4091">  }</a>
<a name="ln4092"> </a>
<a name="ln4093">  return OK;</a>
<a name="ln4094">}</a>
<a name="ln4095"> </a>
<a name="ln4096">/// Continue an interrupted completion mode search in &quot;line&quot;.</a>
<a name="ln4097">///</a>
<a name="ln4098">/// If this same ctrl_x_mode has been interrupted use the text from</a>
<a name="ln4099">/// &quot;compl_startpos&quot; to the cursor as a pattern to add a new word instead of</a>
<a name="ln4100">/// expand the one before the cursor, in word-wise if &quot;compl_startpos&quot; is not in</a>
<a name="ln4101">/// the same line as the cursor then fix it (the line has been split because it</a>
<a name="ln4102">/// was longer than 'tw').  if SOL is set then skip the previous pattern, a word</a>
<a name="ln4103">/// at the beginning of the line has been inserted, we'll look for that.</a>
<a name="ln4104">static void ins_compl_continue_search(char *line)</a>
<a name="ln4105">{</a>
<a name="ln4106">  // it is a continued search</a>
<a name="ln4107">  compl_cont_status &amp;= ~CONT_INTRPT;  // remove INTRPT</a>
<a name="ln4108">  if (ctrl_x_mode_normal()</a>
<a name="ln4109">      || ctrl_x_mode_path_patterns()</a>
<a name="ln4110">      || ctrl_x_mode_path_defines()) {</a>
<a name="ln4111">    if (compl_startpos.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln4112">      // line (probably) wrapped, set compl_startpos to the</a>
<a name="ln4113">      // first non_blank in the line, if it is not a wordchar</a>
<a name="ln4114">      // include it to get a better pattern, but then we don't</a>
<a name="ln4115">      // want the &quot;\\&lt;&quot; prefix, check it below.</a>
<a name="ln4116">      compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln4117">      compl_startpos.col = compl_col;</a>
<a name="ln4118">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4119">      compl_cont_status &amp;= ~CONT_SOL;  // clear SOL if present</a>
<a name="ln4120">    } else {</a>
<a name="ln4121">      // S_IPOS was set when we inserted a word that was at the</a>
<a name="ln4122">      // beginning of the line, which means that we'll go to SOL</a>
<a name="ln4123">      // mode but first we need to redefine compl_startpos</a>
<a name="ln4124">      if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4125">        compl_cont_status |= CONT_SOL;</a>
<a name="ln4126">        compl_startpos.col = (colnr_T)(skipwhite(line + compl_length + compl_startpos.col) - line);</a>
<a name="ln4127">      }</a>
<a name="ln4128">      compl_col = compl_startpos.col;</a>
<a name="ln4129">    }</a>
<a name="ln4130">    compl_length = curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln4131">    // IObuff is used to add a &quot;word from the next line&quot; would we</a>
<a name="ln4132">    // have enough space?  just being paranoid</a>
<a name="ln4133">#define MIN_SPACE 75</a>
<a name="ln4134">    if (compl_length &gt; (IOSIZE - MIN_SPACE)) {</a>
<a name="ln4135">      compl_cont_status &amp;= ~CONT_SOL;</a>
<a name="ln4136">      compl_length = (IOSIZE - MIN_SPACE);</a>
<a name="ln4137">      compl_col = curwin-&gt;w_cursor.col - compl_length;</a>
<a name="ln4138">    }</a>
<a name="ln4139">    compl_cont_status |= CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4140">    if (compl_length &lt; 1) {</a>
<a name="ln4141">      compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4142">    }</a>
<a name="ln4143">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4144">    compl_cont_status = CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4145">  } else {</a>
<a name="ln4146">    compl_cont_status = 0;</a>
<a name="ln4147">  }</a>
<a name="ln4148">}</a>
<a name="ln4149"> </a>
<a name="ln4150">/// start insert mode completion</a>
<a name="ln4151">static int ins_compl_start(void)</a>
<a name="ln4152">{</a>
<a name="ln4153">  const bool save_did_ai = did_ai;</a>
<a name="ln4154"> </a>
<a name="ln4155">  // First time we hit ^N or ^P (in a row, I mean)</a>
<a name="ln4156"> </a>
<a name="ln4157">  did_ai = false;</a>
<a name="ln4158">  did_si = false;</a>
<a name="ln4159">  can_si = false;</a>
<a name="ln4160">  can_si_back = false;</a>
<a name="ln4161">  if (stop_arrow() == FAIL) {</a>
<a name="ln4162">    return FAIL;</a>
<a name="ln4163">  }</a>
<a name="ln4164"> </a>
<a name="ln4165">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4166">  colnr_T curs_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4167">  compl_pending = 0;</a>
<a name="ln4168"> </a>
<a name="ln4169">  if ((compl_cont_status &amp; CONT_INTRPT) == CONT_INTRPT</a>
<a name="ln4170">      &amp;&amp; compl_cont_mode == ctrl_x_mode) {</a>
<a name="ln4171">    // this same ctrl-x_mode was interrupted previously. Continue the</a>
<a name="ln4172">    // completion.</a>
<a name="ln4173">    ins_compl_continue_search(line);</a>
<a name="ln4174">  } else {</a>
<a name="ln4175">    compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4176">  }</a>
<a name="ln4177"> </a>
<a name="ln4178">  int startcol = 0;  // column where searched text starts</a>
<a name="ln4179">  if (!compl_status_adding()) {   // normal expansion</a>
<a name="ln4180">    compl_cont_mode = ctrl_x_mode;</a>
<a name="ln4181">    if (ctrl_x_mode_not_default()) {</a>
<a name="ln4182">      // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL</a>
<a name="ln4183">      compl_cont_status = 0;</a>
<a name="ln4184">    }</a>
<a name="ln4185">    compl_cont_status |= CONT_N_ADDS;</a>
<a name="ln4186">    compl_startpos = curwin-&gt;w_cursor;</a>
<a name="ln4187">    startcol = (int)curs_col;</a>
<a name="ln4188">    compl_col = 0;</a>
<a name="ln4189">  }</a>
<a name="ln4190"> </a>
<a name="ln4191">  // Work out completion pattern and original text -- webb</a>
<a name="ln4192">  bool line_invalid = false;</a>
<a name="ln4193">  if (compl_get_info(line, startcol, curs_col, &amp;line_invalid) == FAIL) {</a>
<a name="ln4194">    if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4195">        || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4196">      // restore did_ai, so that adding comment leader works</a>
<a name="ln4197">      did_ai = save_did_ai;</a>
<a name="ln4198">    }</a>
<a name="ln4199">    return FAIL;</a>
<a name="ln4200">  }</a>
<a name="ln4201">  // If &quot;line&quot; was changed while getting completion info get it again.</a>
<a name="ln4202">  if (line_invalid) {</a>
<a name="ln4203">    line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4204">  }</a>
<a name="ln4205"> </a>
<a name="ln4206">  if (compl_status_adding()) {</a>
<a name="ln4207">    edit_submode_pre = _(&quot; Adding&quot;);</a>
<a name="ln4208">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4209">      // Insert a new line, keep indentation but ignore 'comments'.</a>
<a name="ln4210">      char *old = curbuf-&gt;b_p_com;</a>
<a name="ln4211"> </a>
<a name="ln4212">      curbuf-&gt;b_p_com = &quot;&quot;;</a>
<a name="ln4213">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4214">      compl_startpos.col = compl_col;</a>
<a name="ln4215">      ins_eol('\r');</a>
<a name="ln4216">      curbuf-&gt;b_p_com = old;</a>
<a name="ln4217">      compl_length = 0;</a>
<a name="ln4218">      compl_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4219">    }</a>
<a name="ln4220">  } else {</a>
<a name="ln4221">    edit_submode_pre = NULL;</a>
<a name="ln4222">    compl_startpos.col = compl_col;</a>
<a name="ln4223">  }</a>
<a name="ln4224"> </a>
<a name="ln4225">  if (compl_cont_status &amp; CONT_LOCAL) {</a>
<a name="ln4226">    edit_submode = _(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);</a>
<a name="ln4227">  } else {</a>
<a name="ln4228">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln4229">  }</a>
<a name="ln4230"> </a>
<a name="ln4231">  // If any of the original typed text has been changed we need to fix</a>
<a name="ln4232">  // the redo buffer.</a>
<a name="ln4233">  ins_compl_fixRedoBufForLeader(NULL);</a>
<a name="ln4234"> </a>
<a name="ln4235">  // Always add completion for the original text.</a>
<a name="ln4236">  xfree(compl_orig_text);</a>
<a name="ln4237">  compl_orig_text = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4238">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln4239">  if (p_ic) {</a>
<a name="ln4240">    flags |= CP_ICASE;</a>
<a name="ln4241">  }</a>
<a name="ln4242">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln4243">                    flags, false) != OK) {</a>
<a name="ln4244">    XFREE_CLEAR(compl_pattern);</a>
<a name="ln4245">    XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4246">    return FAIL;</a>
<a name="ln4247">  }</a>
<a name="ln4248"> </a>
<a name="ln4249">  // showmode might reset the internal line pointers, so it must</a>
<a name="ln4250">  // be called before line = ml_get(), or when this address is no</a>
<a name="ln4251">  // longer needed.  -- Acevedo.</a>
<a name="ln4252">  edit_submode_extra = _(&quot;-- Searching...&quot;);</a>
<a name="ln4253">  edit_submode_highl = HLF_COUNT;</a>
<a name="ln4254">  showmode();</a>
<a name="ln4255">  edit_submode_extra = NULL;</a>
<a name="ln4256">  ui_flush();</a>
<a name="ln4257"> </a>
<a name="ln4258">  return OK;</a>
<a name="ln4259">}</a>
<a name="ln4260"> </a>
<a name="ln4261">/// display the completion status message</a>
<a name="ln4262">static void ins_compl_show_statusmsg(void)</a>
<a name="ln4263">{</a>
<a name="ln4264">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4265">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4266">    edit_submode_extra = compl_status_adding() &amp;&amp; compl_length &gt; 1 ? _(e_hitend) : _(e_patnotf);</a>
<a name="ln4267">    edit_submode_highl = HLF_E;</a>
<a name="ln4268">  }</a>
<a name="ln4269"> </a>
<a name="ln4270">  if (edit_submode_extra == NULL) {</a>
<a name="ln4271">    if (match_at_original_text(compl_curr_match)) {</a>
<a name="ln4272">      edit_submode_extra = _(&quot;Back at original&quot;);</a>
<a name="ln4273">      edit_submode_highl = HLF_W;</a>
<a name="ln4274">    } else if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4275">      edit_submode_extra = _(&quot;Word from other line&quot;);</a>
<a name="ln4276">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4277">    } else if (compl_curr_match-&gt;cp_next == compl_curr_match-&gt;cp_prev) {</a>
<a name="ln4278">      edit_submode_extra = _(&quot;The only match&quot;);</a>
<a name="ln4279">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4280">      compl_curr_match-&gt;cp_number = 1;</a>
<a name="ln4281">    } else {</a>
<a name="ln4282">      // Update completion sequence number when needed.</a>
<a name="ln4283">      if (compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln4284">        ins_compl_update_sequence_numbers();</a>
<a name="ln4285">      }</a>
<a name="ln4286"> </a>
<a name="ln4287">      // The match should always have a sequence number now, this is</a>
<a name="ln4288">      // just a safety check.</a>
<a name="ln4289">      if (compl_curr_match-&gt;cp_number != -1) {</a>
<a name="ln4290">        // Space for 10 text chars. + 2x10-digit no.s = 31.</a>
<a name="ln4291">        // Translations may need more than twice that.</a>
<a name="ln4292">        static char match_ref[81];</a>
<a name="ln4293"> </a>
<a name="ln4294">        if (compl_matches &gt; 0) {</a>
<a name="ln4295">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4296">                       _(&quot;match %d of %d&quot;),</a>
<a name="ln4297">                       compl_curr_match-&gt;cp_number, compl_matches);</a>
<a name="ln4298">        } else {</a>
<a name="ln4299">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4300">                       _(&quot;match %d&quot;),</a>
<a name="ln4301">                       compl_curr_match-&gt;cp_number);</a>
<a name="ln4302">        }</a>
<a name="ln4303">        edit_submode_extra = match_ref;</a>
<a name="ln4304">        edit_submode_highl = HLF_R;</a>
<a name="ln4305">        if (dollar_vcol &gt;= 0) {</a>
<a name="ln4306">          curs_columns(curwin, false);</a>
<a name="ln4307">        }</a>
<a name="ln4308">      }</a>
<a name="ln4309">    }</a>
<a name="ln4310">  }</a>
<a name="ln4311"> </a>
<a name="ln4312">  // Show a message about what (completion) mode we're in.</a>
<a name="ln4313">  showmode();</a>
<a name="ln4314">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4315">    if (edit_submode_extra != NULL) {</a>
<a name="ln4316">      if (!p_smd) {</a>
<a name="ln4317">        msg_hist_off = true;</a>
<a name="ln4318">        msg(edit_submode_extra, (edit_submode_highl &lt; HLF_COUNT</a>
<a name="ln4319">                                 ? HL_ATTR(edit_submode_highl) : 0));</a>
<a name="ln4320">        msg_hist_off = false;</a>
<a name="ln4321">      }</a>
<a name="ln4322">    } else {</a>
<a name="ln4323">      msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln4324">    }</a>
<a name="ln4325">  }</a>
<a name="ln4326">}</a>
<a name="ln4327"> </a>
<a name="ln4328">/// Do Insert mode completion.</a>
<a name="ln4329">/// Called when character &quot;c&quot; was typed, which has a meaning for completion.</a>
<a name="ln4330">/// Returns OK if completion was done, FAIL if something failed.</a>
<a name="ln4331">int ins_complete(int c, bool enable_pum)</a>
<a name="ln4332">{</a>
<a name="ln4333">  int n;</a>
<a name="ln4334">  int save_w_wrow;</a>
<a name="ln4335">  int save_w_leftcol;</a>
<a name="ln4336">  int insert_match;</a>
<a name="ln4337"> </a>
<a name="ln4338">  compl_direction = ins_compl_key2dir(c);</a>
<a name="ln4339">  insert_match = ins_compl_use_match(c);</a>
<a name="ln4340"> </a>
<a name="ln4341">  if (!compl_started) {</a>
<a name="ln4342">    if (ins_compl_start() == FAIL) {</a>
<a name="ln4343">      return FAIL;</a>
<a name="ln4344">    }</a>
<a name="ln4345">  } else if (insert_match &amp;&amp; stop_arrow() == FAIL) {</a>
<a name="ln4346">    return FAIL;</a>
<a name="ln4347">  }</a>
<a name="ln4348"> </a>
<a name="ln4349">  compl_shown_match = compl_curr_match;</a>
<a name="ln4350">  compl_shows_dir = compl_direction;</a>
<a name="ln4351"> </a>
<a name="ln4352">  // Find next match (and following matches).</a>
<a name="ln4353">  save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln4354">  save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln4355">  n = ins_compl_next(true, ins_compl_key2count(c), insert_match, false);</a>
<a name="ln4356"> </a>
<a name="ln4357">  if (n &gt; 1) {          // all matches have been found</a>
<a name="ln4358">    compl_matches = n;</a>
<a name="ln4359">  }</a>
<a name="ln4360">  compl_curr_match = compl_shown_match;</a>
<a name="ln4361">  compl_direction = compl_shows_dir;</a>
<a name="ln4362"> </a>
<a name="ln4363">  // Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert</a>
<a name="ln4364">  // mode.</a>
<a name="ln4365">  if (got_int &amp;&amp; !global_busy) {</a>
<a name="ln4366">    (void)vgetc();</a>
<a name="ln4367">    got_int = false;</a>
<a name="ln4368">  }</a>
<a name="ln4369"> </a>
<a name="ln4370">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4371">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4372">    // remove N_ADDS flag, so next ^X&lt;&gt; won't try to go to ADDING mode,</a>
<a name="ln4373">    // because we couldn't expand anything at first place, but if we used</a>
<a name="ln4374">    // ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word</a>
<a name="ln4375">    // (such as M in M'exico) if not tried already.  -- Acevedo</a>
<a name="ln4376">    if (compl_length &gt; 1</a>
<a name="ln4377">        || compl_status_adding()</a>
<a name="ln4378">        || (ctrl_x_mode_not_default()</a>
<a name="ln4379">            &amp;&amp; !ctrl_x_mode_path_patterns()</a>
<a name="ln4380">            &amp;&amp; !ctrl_x_mode_path_defines())) {</a>
<a name="ln4381">      compl_cont_status &amp;= ~CONT_N_ADDS;</a>
<a name="ln4382">    }</a>
<a name="ln4383">  }</a>
<a name="ln4384"> </a>
<a name="ln4385">  if (compl_curr_match-&gt;cp_flags &amp; CP_CONT_S_IPOS) {</a>
<a name="ln4386">    compl_cont_status |= CONT_S_IPOS;</a>
<a name="ln4387">  } else {</a>
<a name="ln4388">    compl_cont_status &amp;= ~CONT_S_IPOS;</a>
<a name="ln4389">  }</a>
<a name="ln4390"> </a>
<a name="ln4391">  ins_compl_show_statusmsg();</a>
<a name="ln4392"> </a>
<a name="ln4393">  // Show the popup menu, unless we got interrupted.</a>
<a name="ln4394">  if (enable_pum &amp;&amp; !compl_interrupted) {</a>
<a name="ln4395">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln4396">  }</a>
<a name="ln4397">  compl_was_interrupted = compl_interrupted;</a>
<a name="ln4398">  compl_interrupted = false;</a>
<a name="ln4399"> </a>
<a name="ln4400">  return OK;</a>
<a name="ln4401">}</a>
<a name="ln4402"> </a>
<a name="ln4403">/// Remove (if needed) and show the popup menu</a>
<a name="ln4404">static void show_pum(int prev_w_wrow, int prev_w_leftcol)</a>
<a name="ln4405">{</a>
<a name="ln4406">  // RedrawingDisabled may be set when invoked through complete().</a>
<a name="ln4407">  int n = RedrawingDisabled;</a>
<a name="ln4408">  RedrawingDisabled = 0;</a>
<a name="ln4409"> </a>
<a name="ln4410">  // If the cursor moved or the display scrolled we need to remove the pum</a>
<a name="ln4411">  // first.</a>
<a name="ln4412">  setcursor();</a>
<a name="ln4413">  if (prev_w_wrow != curwin-&gt;w_wrow || prev_w_leftcol != curwin-&gt;w_leftcol) {</a>
<a name="ln4414">    ins_compl_del_pum();</a>
<a name="ln4415">  }</a>
<a name="ln4416"> </a>
<a name="ln4417">  ins_compl_show_pum();</a>
<a name="ln4418">  setcursor();</a>
<a name="ln4419">  RedrawingDisabled = n;</a>
<a name="ln4420">}</a>
<a name="ln4421"> </a>
<a name="ln4422">// Looks in the first &quot;len&quot; chars. of &quot;src&quot; for search-metachars.</a>
<a name="ln4423">// If dest is not NULL the chars. are copied there quoting (with</a>
<a name="ln4424">// a backslash) the metachars, and dest would be NUL terminated.</a>
<a name="ln4425">// Returns the length (needed) of dest</a>
<a name="ln4426">static unsigned quote_meta(char *dest, char *src, int len)</a>
<a name="ln4427">{</a>
<a name="ln4428">  unsigned m = (unsigned)len + 1;       // one extra for the NUL</a>
<a name="ln4429"> </a>
<a name="ln4430">  for (; --len &gt;= 0; src++) {</a>
<a name="ln4431">    switch (*src) {</a>
<a name="ln4432">    case '.':</a>
<a name="ln4433">    case '*':</a>
<a name="ln4434">    case '[':</a>
<a name="ln4435">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4436">        break;</a>
<a name="ln4437">      }</a>
<a name="ln4438">      FALLTHROUGH;</a>
<a name="ln4439">    case '~':</a>
<a name="ln4440">      if (!magic_isset()) {  // quote these only if magic is set</a>
<a name="ln4441">        break;</a>
<a name="ln4442">      }</a>
<a name="ln4443">      FALLTHROUGH;</a>
<a name="ln4444">    case '\\':</a>
<a name="ln4445">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4446">        break;</a>
<a name="ln4447">      }</a>
<a name="ln4448">      FALLTHROUGH;</a>
<a name="ln4449">    case '^':                   // currently it's not needed.</a>
<a name="ln4450">    case '$':</a>
<a name="ln4451">      m++;</a>
<a name="ln4452">      if (dest != NULL) {</a>
<a name="ln4453">        *dest++ = '\\';</a>
<a name="ln4454">      }</a>
<a name="ln4455">      break;</a>
<a name="ln4456">    }</a>
<a name="ln4457">    if (dest != NULL) {</a>
<a name="ln4458">      *dest++ = *src;</a>
<a name="ln4459">    }</a>
<a name="ln4460">    // Copy remaining bytes of a multibyte character.</a>
<a name="ln4461">    const int mb_len = utfc_ptr2len(src) - 1;</a>
<a name="ln4462">    if (mb_len &gt; 0 &amp;&amp; len &gt;= mb_len) {</a>
<a name="ln4463">      for (int i = 0; i &lt; mb_len; i++) {</a>
<a name="ln4464">        len--;</a>
<a name="ln4465">        src++;</a>
<a name="ln4466">        if (dest != NULL) {</a>
<a name="ln4467">          *dest++ = *src;</a>
<a name="ln4468">        }</a>
<a name="ln4469">      }</a>
<a name="ln4470">    }</a>
<a name="ln4471">  }</a>
<a name="ln4472">  if (dest != NULL) {</a>
<a name="ln4473">    *dest = NUL;</a>
<a name="ln4474">  }</a>
<a name="ln4475"> </a>
<a name="ln4476">  return m;</a>
<a name="ln4477">}</a>
<a name="ln4478"> </a>
<a name="ln4479">#if defined(EXITFREE)</a>
<a name="ln4480">void free_insexpand_stuff(void)</a>
<a name="ln4481">{</a>
<a name="ln4482">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4483">  callback_free(&amp;cfu_cb);</a>
<a name="ln4484">  callback_free(&amp;ofu_cb);</a>
<a name="ln4485">  callback_free(&amp;tsrfu_cb);</a>
<a name="ln4486">}</a>
<a name="ln4487">#endif</a>
<a name="ln4488"> </a>
<a name="ln4489">/// Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly</a>
<a name="ln4490">/// spelled word, if there is one.</a>
<a name="ln4491">static void spell_back_to_badword(void)</a>
<a name="ln4492">{</a>
<a name="ln4493">  pos_T tpos = curwin-&gt;w_cursor;</a>
<a name="ln4494">  spell_bad_len = spell_move_to(curwin, BACKWARD, true, true, NULL);</a>
<a name="ln4495">  if (curwin-&gt;w_cursor.col != tpos.col) {</a>
<a name="ln4496">    start_arrow(&amp;tpos);</a>
<a name="ln4497">  }</a>
<a name="ln4498">}</a>
</code></pre>
<div class="balloon" rel="3311"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'st.e_cpt_copy == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>