<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>eval.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// eval.c: Expression evaluation.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;math.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;sys/stat.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;auto/config.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln19">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/channel.h&quot;</a>
<a name="ln23">#include &quot;nvim/charset.h&quot;</a>
<a name="ln24">#include &quot;nvim/cmdexpand_defs.h&quot;</a>
<a name="ln25">#include &quot;nvim/cmdhist.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/edit.h&quot;</a>
<a name="ln28">#include &quot;nvim/eval.h&quot;</a>
<a name="ln29">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln33">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln34">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln35">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln36">#include &quot;nvim/event/process.h&quot;</a>
<a name="ln37">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln38">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln39">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln40">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln41">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln42">#include &quot;nvim/garray.h&quot;</a>
<a name="ln43">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln44">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln45">#include &quot;nvim/globals.h&quot;</a>
<a name="ln46">#include &quot;nvim/grid_defs.h&quot;</a>
<a name="ln47">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln48">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln49">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln50">#include &quot;nvim/lib/queue.h&quot;</a>
<a name="ln51">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln52">#include &quot;nvim/macros.h&quot;</a>
<a name="ln53">#include &quot;nvim/main.h&quot;</a>
<a name="ln54">#include &quot;nvim/map.h&quot;</a>
<a name="ln55">#include &quot;nvim/mark.h&quot;</a>
<a name="ln56">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln57">#include &quot;nvim/memline.h&quot;</a>
<a name="ln58">#include &quot;nvim/memory.h&quot;</a>
<a name="ln59">#include &quot;nvim/message.h&quot;</a>
<a name="ln60">#include &quot;nvim/move.h&quot;</a>
<a name="ln61">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln62">#include &quot;nvim/ops.h&quot;</a>
<a name="ln63">#include &quot;nvim/option.h&quot;</a>
<a name="ln64">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln65">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln66">#include &quot;nvim/os/fileio.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln68">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln69">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln70">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln71">#include &quot;nvim/os/stdpaths_defs.h&quot;</a>
<a name="ln72">#include &quot;nvim/path.h&quot;</a>
<a name="ln73">#include &quot;nvim/pos.h&quot;</a>
<a name="ln74">#include &quot;nvim/profile.h&quot;</a>
<a name="ln75">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln76">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln77">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln78">#include &quot;nvim/search.h&quot;</a>
<a name="ln79">#include &quot;nvim/strings.h&quot;</a>
<a name="ln80">#include &quot;nvim/tag.h&quot;</a>
<a name="ln81">#include &quot;nvim/types.h&quot;</a>
<a name="ln82">#include &quot;nvim/ui.h&quot;</a>
<a name="ln83">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln84">#include &quot;nvim/usercmd.h&quot;</a>
<a name="ln85">#include &quot;nvim/version.h&quot;</a>
<a name="ln86">#include &quot;nvim/vim.h&quot;</a>
<a name="ln87">#include &quot;nvim/window.h&quot;</a>
<a name="ln88"> </a>
<a name="ln89">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln90"> </a>
<a name="ln91">#define DICT_MAXNEST 100        // maximum nesting of lists and dicts</a>
<a name="ln92"> </a>
<a name="ln93">static const char *e_missbrac = N_(&quot;E111: Missing ']'&quot;);</a>
<a name="ln94">static const char *e_list_end = N_(&quot;E697: Missing end of List ']': %s&quot;);</a>
<a name="ln95">static const char e_cannot_slice_dictionary[]</a>
<a name="ln96">  = N_(&quot;E719: Cannot slice a Dictionary&quot;);</a>
<a name="ln97">static const char e_cannot_index_special_variable[]</a>
<a name="ln98">  = N_(&quot;E909: Cannot index a special variable&quot;);</a>
<a name="ln99">static const char *e_nowhitespace</a>
<a name="ln100">  = N_(&quot;E274: No white space allowed before parenthesis&quot;);</a>
<a name="ln101">static const char *e_write2 = N_(&quot;E80: Error while writing: %s&quot;);</a>
<a name="ln102">static const char e_cannot_index_a_funcref[]</a>
<a name="ln103">  = N_(&quot;E695: Cannot index a Funcref&quot;);</a>
<a name="ln104">static const char e_variable_nested_too_deep_for_making_copy[]</a>
<a name="ln105">  = N_(&quot;E698: Variable nested too deep for making a copy&quot;);</a>
<a name="ln106">static const char e_string_list_or_blob_required[]</a>
<a name="ln107">  = N_(&quot;E1098: String, List or Blob required&quot;);</a>
<a name="ln108">static const char e_expression_too_recursive_str[]</a>
<a name="ln109">  = N_(&quot;E1169: Expression too recursive: %s&quot;);</a>
<a name="ln110">static const char e_dot_can_only_be_used_on_dictionary_str[]</a>
<a name="ln111">  = N_(&quot;E1203: Dot can only be used on a dictionary: %s&quot;);</a>
<a name="ln112">static const char e_empty_function_name[]</a>
<a name="ln113">  = N_(&quot;E1192: Empty function name&quot;);</a>
<a name="ln114">static const char e_argument_of_str_must_be_list_string_dictionary_or_blob[]</a>
<a name="ln115">  = N_(&quot;E1250: Argument of %s must be a List, String, Dictionary or Blob&quot;);</a>
<a name="ln116"> </a>
<a name="ln117">static char * const namespace_char = &quot;abglstvw&quot;;</a>
<a name="ln118"> </a>
<a name="ln119">/// Variable used for g:</a>
<a name="ln120">static ScopeDictDictItem globvars_var;</a>
<a name="ln121"> </a>
<a name="ln122">/// Old Vim variables such as &quot;v:version&quot; are also available without the &quot;v:&quot;.</a>
<a name="ln123">/// Also in functions.  We need a special hashtable for them.</a>
<a name="ln124">static hashtab_T compat_hashtab;</a>
<a name="ln125"> </a>
<a name="ln126">/// Used for checking if local variables or arguments used in a lambda.</a>
<a name="ln127">bool *eval_lavars_used = NULL;</a>
<a name="ln128"> </a>
<a name="ln129">#define SCRIPT_SV(id) (SCRIPT_ITEM(id)-&gt;sn_vars)</a>
<a name="ln130">#define SCRIPT_VARS(id) (SCRIPT_SV(id)-&gt;sv_dict.dv_hashtab)</a>
<a name="ln131"> </a>
<a name="ln132">static int echo_attr = 0;   // attributes used for &quot;:echo&quot;</a>
<a name="ln133"> </a>
<a name="ln134">/// Info used by a &quot;:for&quot; loop.</a>
<a name="ln135">typedef struct {</a>
<a name="ln136">  int fi_semicolon;             // true if ending in '; var]'</a>
<a name="ln137">  int fi_varcount;              // nr of variables in the list</a>
<a name="ln138">  listwatch_T fi_lw;            // keep an eye on the item used.</a>
<a name="ln139">  list_T *fi_list;              // list being used</a>
<a name="ln140">  int fi_bi;                    // index of blob</a>
<a name="ln141">  blob_T *fi_blob;              // blob being used</a>
<a name="ln142">  char *fi_string;            // copy of string being used</a>
<a name="ln143">  int fi_byte_idx;              // byte index in fi_string</a>
<a name="ln144">} forinfo_T;</a>
<a name="ln145"> </a>
<a name="ln146">// values for vv_flags:</a>
<a name="ln147">#define VV_COMPAT       1       // compatible, also used without &quot;v:&quot;</a>
<a name="ln148">#define VV_RO           2       // read-only</a>
<a name="ln149">#define VV_RO_SBX       4       // read-only in the sandbox</a>
<a name="ln150"> </a>
<a name="ln151">#define VV(idx, name, type, flags) \</a>
<a name="ln152">  [idx] = { \</a>
<a name="ln153">    .vv_name = (name), \</a>
<a name="ln154">    .vv_di = { \</a>
<a name="ln155">      .di_tv = { .v_type = (type) }, \</a>
<a name="ln156">      .di_flags = 0, \</a>
<a name="ln157">      .di_key = { 0 }, \</a>
<a name="ln158">    }, \</a>
<a name="ln159">    .vv_flags = (flags), \</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">#define VIMVAR_KEY_LEN 16  // Maximum length of the key of v:variables</a>
<a name="ln163"> </a>
<a name="ln164">// Array to hold the value of v: variables.</a>
<a name="ln165">// The value is in a dictitem, so that it can also be used in the v: scope.</a>
<a name="ln166">// The reason to use this table anyway is for very quick access to the</a>
<a name="ln167">// variables with the VV_ defines.</a>
<a name="ln168">static struct vimvar {</a>
<a name="ln169">  char *vv_name;  ///&lt; Name of the variable, without v:.</a>
<a name="ln170">  TV_DICTITEM_STRUCT(VIMVAR_KEY_LEN + 1) vv_di;  ///&lt; Value and name for key (max 16 chars).</a>
<a name="ln171">  char vv_flags;  ///&lt; Flags: #VV_COMPAT, #VV_RO, #VV_RO_SBX.</a>
<a name="ln172">} vimvars[] = {</a>
<a name="ln173">  // VV_ tails differing from upcased string literals:</a>
<a name="ln174">  // VV_CC_FROM &quot;charconvert_from&quot;</a>
<a name="ln175">  // VV_CC_TO &quot;charconvert_to&quot;</a>
<a name="ln176">  // VV_SEND_SERVER &quot;servername&quot;</a>
<a name="ln177">  // VV_REG &quot;register&quot;</a>
<a name="ln178">  // VV_OP &quot;operator&quot;</a>
<a name="ln179">  VV(VV_COUNT,            &quot;count&quot;,            VAR_NUMBER, VV_RO),</a>
<a name="ln180">  VV(VV_COUNT1,           &quot;count1&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln181">  VV(VV_PREVCOUNT,        &quot;prevcount&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln182">  VV(VV_ERRMSG,           &quot;errmsg&quot;,           VAR_STRING, 0),</a>
<a name="ln183">  VV(VV_WARNINGMSG,       &quot;warningmsg&quot;,       VAR_STRING, 0),</a>
<a name="ln184">  VV(VV_STATUSMSG,        &quot;statusmsg&quot;,        VAR_STRING, 0),</a>
<a name="ln185">  VV(VV_SHELL_ERROR,      &quot;shell_error&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln186">  VV(VV_THIS_SESSION,     &quot;this_session&quot;,     VAR_STRING, 0),</a>
<a name="ln187">  VV(VV_VERSION,          &quot;version&quot;,          VAR_NUMBER, VV_COMPAT + VV_RO),</a>
<a name="ln188">  VV(VV_LNUM,             &quot;lnum&quot;,             VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln189">  VV(VV_TERMRESPONSE,     &quot;termresponse&quot;,     VAR_STRING, VV_RO),</a>
<a name="ln190">  VV(VV_FNAME,            &quot;fname&quot;,            VAR_STRING, VV_RO),</a>
<a name="ln191">  VV(VV_LANG,             &quot;lang&quot;,             VAR_STRING, VV_RO),</a>
<a name="ln192">  VV(VV_LC_TIME,          &quot;lc_time&quot;,          VAR_STRING, VV_RO),</a>
<a name="ln193">  VV(VV_CTYPE,            &quot;ctype&quot;,            VAR_STRING, VV_RO),</a>
<a name="ln194">  VV(VV_CC_FROM,          &quot;charconvert_from&quot;, VAR_STRING, VV_RO),</a>
<a name="ln195">  VV(VV_CC_TO,            &quot;charconvert_to&quot;,   VAR_STRING, VV_RO),</a>
<a name="ln196">  VV(VV_FNAME_IN,         &quot;fname_in&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln197">  VV(VV_FNAME_OUT,        &quot;fname_out&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln198">  VV(VV_FNAME_NEW,        &quot;fname_new&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln199">  VV(VV_FNAME_DIFF,       &quot;fname_diff&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln200">  VV(VV_CMDARG,           &quot;cmdarg&quot;,           VAR_STRING, VV_RO),</a>
<a name="ln201">  VV(VV_FOLDSTART,        &quot;foldstart&quot;,        VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln202">  VV(VV_FOLDEND,          &quot;foldend&quot;,          VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln203">  VV(VV_FOLDDASHES,       &quot;folddashes&quot;,       VAR_STRING, VV_RO_SBX),</a>
<a name="ln204">  VV(VV_FOLDLEVEL,        &quot;foldlevel&quot;,        VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln205">  VV(VV_PROGNAME,         &quot;progname&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln206">  VV(VV_SEND_SERVER,      &quot;servername&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln207">  VV(VV_DYING,            &quot;dying&quot;,            VAR_NUMBER, VV_RO),</a>
<a name="ln208">  VV(VV_EXCEPTION,        &quot;exception&quot;,        VAR_STRING, VV_RO),</a>
<a name="ln209">  VV(VV_THROWPOINT,       &quot;throwpoint&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln210">  VV(VV_REG,              &quot;register&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln211">  VV(VV_CMDBANG,          &quot;cmdbang&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln212">  VV(VV_INSERTMODE,       &quot;insertmode&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln213">  VV(VV_VAL,              &quot;val&quot;,              VAR_UNKNOWN, VV_RO),</a>
<a name="ln214">  VV(VV_KEY,              &quot;key&quot;,              VAR_UNKNOWN, VV_RO),</a>
<a name="ln215">  VV(VV_PROFILING,        &quot;profiling&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln216">  VV(VV_FCS_REASON,       &quot;fcs_reason&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln217">  VV(VV_FCS_CHOICE,       &quot;fcs_choice&quot;,       VAR_STRING, 0),</a>
<a name="ln218">  VV(VV_BEVAL_BUFNR,      &quot;beval_bufnr&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln219">  VV(VV_BEVAL_WINNR,      &quot;beval_winnr&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln220">  VV(VV_BEVAL_WINID,      &quot;beval_winid&quot;,      VAR_NUMBER, VV_RO),</a>
<a name="ln221">  VV(VV_BEVAL_LNUM,       &quot;beval_lnum&quot;,       VAR_NUMBER, VV_RO),</a>
<a name="ln222">  VV(VV_BEVAL_COL,        &quot;beval_col&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln223">  VV(VV_BEVAL_TEXT,       &quot;beval_text&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln224">  VV(VV_SCROLLSTART,      &quot;scrollstart&quot;,      VAR_STRING, 0),</a>
<a name="ln225">  VV(VV_SWAPNAME,         &quot;swapname&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln226">  VV(VV_SWAPCHOICE,       &quot;swapchoice&quot;,       VAR_STRING, 0),</a>
<a name="ln227">  VV(VV_SWAPCOMMAND,      &quot;swapcommand&quot;,      VAR_STRING, VV_RO),</a>
<a name="ln228">  VV(VV_CHAR,             &quot;char&quot;,             VAR_STRING, 0),</a>
<a name="ln229">  VV(VV_MOUSE_WIN,        &quot;mouse_win&quot;,        VAR_NUMBER, 0),</a>
<a name="ln230">  VV(VV_MOUSE_WINID,      &quot;mouse_winid&quot;,      VAR_NUMBER, 0),</a>
<a name="ln231">  VV(VV_MOUSE_LNUM,       &quot;mouse_lnum&quot;,       VAR_NUMBER, 0),</a>
<a name="ln232">  VV(VV_MOUSE_COL,        &quot;mouse_col&quot;,        VAR_NUMBER, 0),</a>
<a name="ln233">  VV(VV_OP,               &quot;operator&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln234">  VV(VV_SEARCHFORWARD,    &quot;searchforward&quot;,    VAR_NUMBER, 0),</a>
<a name="ln235">  VV(VV_HLSEARCH,         &quot;hlsearch&quot;,         VAR_NUMBER, 0),</a>
<a name="ln236">  VV(VV_OLDFILES,         &quot;oldfiles&quot;,         VAR_LIST, 0),</a>
<a name="ln237">  VV(VV_WINDOWID,         &quot;windowid&quot;,         VAR_NUMBER, VV_RO_SBX),</a>
<a name="ln238">  VV(VV_PROGPATH,         &quot;progpath&quot;,         VAR_STRING, VV_RO),</a>
<a name="ln239">  VV(VV_COMPLETED_ITEM,   &quot;completed_item&quot;,   VAR_DICT, 0),</a>
<a name="ln240">  VV(VV_OPTION_NEW,       &quot;option_new&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln241">  VV(VV_OPTION_OLD,       &quot;option_old&quot;,       VAR_STRING, VV_RO),</a>
<a name="ln242">  VV(VV_OPTION_OLDLOCAL,  &quot;option_oldlocal&quot;,  VAR_STRING, VV_RO),</a>
<a name="ln243">  VV(VV_OPTION_OLDGLOBAL, &quot;option_oldglobal&quot;, VAR_STRING, VV_RO),</a>
<a name="ln244">  VV(VV_OPTION_COMMAND,   &quot;option_command&quot;,   VAR_STRING, VV_RO),</a>
<a name="ln245">  VV(VV_OPTION_TYPE,      &quot;option_type&quot;,      VAR_STRING, VV_RO),</a>
<a name="ln246">  VV(VV_ERRORS,           &quot;errors&quot;,           VAR_LIST, 0),</a>
<a name="ln247">  VV(VV_FALSE,            &quot;false&quot;,            VAR_BOOL, VV_RO),</a>
<a name="ln248">  VV(VV_TRUE,             &quot;true&quot;,             VAR_BOOL, VV_RO),</a>
<a name="ln249">  VV(VV_NULL,             &quot;null&quot;,             VAR_SPECIAL, VV_RO),</a>
<a name="ln250">  VV(VV_NUMBERMAX,        &quot;numbermax&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln251">  VV(VV_NUMBERMIN,        &quot;numbermin&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln252">  VV(VV_NUMBERSIZE,       &quot;numbersize&quot;,       VAR_NUMBER, VV_RO),</a>
<a name="ln253">  VV(VV_VIM_DID_ENTER,    &quot;vim_did_enter&quot;,    VAR_NUMBER, VV_RO),</a>
<a name="ln254">  VV(VV_TESTING,          &quot;testing&quot;,          VAR_NUMBER, 0),</a>
<a name="ln255">  VV(VV_TYPE_NUMBER,      &quot;t_number&quot;,         VAR_NUMBER, VV_RO),</a>
<a name="ln256">  VV(VV_TYPE_STRING,      &quot;t_string&quot;,         VAR_NUMBER, VV_RO),</a>
<a name="ln257">  VV(VV_TYPE_FUNC,        &quot;t_func&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln258">  VV(VV_TYPE_LIST,        &quot;t_list&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln259">  VV(VV_TYPE_DICT,        &quot;t_dict&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln260">  VV(VV_TYPE_FLOAT,       &quot;t_float&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln261">  VV(VV_TYPE_BOOL,        &quot;t_bool&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln262">  VV(VV_TYPE_BLOB,        &quot;t_blob&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln263">  VV(VV_EVENT,            &quot;event&quot;,            VAR_DICT, VV_RO),</a>
<a name="ln264">  VV(VV_ECHOSPACE,        &quot;echospace&quot;,        VAR_NUMBER, VV_RO),</a>
<a name="ln265">  VV(VV_ARGV,             &quot;argv&quot;,             VAR_LIST, VV_RO),</a>
<a name="ln266">  VV(VV_COLLATE,          &quot;collate&quot;,          VAR_STRING, VV_RO),</a>
<a name="ln267">  VV(VV_EXITING,          &quot;exiting&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln268">  VV(VV_MAXCOL,           &quot;maxcol&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln269">  // Neovim</a>
<a name="ln270">  VV(VV_STDERR,           &quot;stderr&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln271">  VV(VV_MSGPACK_TYPES,    &quot;msgpack_types&quot;,    VAR_DICT, VV_RO),</a>
<a name="ln272">  VV(VV__NULL_STRING,     &quot;_null_string&quot;,     VAR_STRING, VV_RO),</a>
<a name="ln273">  VV(VV__NULL_LIST,       &quot;_null_list&quot;,       VAR_LIST, VV_RO),</a>
<a name="ln274">  VV(VV__NULL_DICT,       &quot;_null_dict&quot;,       VAR_DICT, VV_RO),</a>
<a name="ln275">  VV(VV__NULL_BLOB,       &quot;_null_blob&quot;,       VAR_BLOB, VV_RO),</a>
<a name="ln276">  VV(VV_LUA,              &quot;lua&quot;,              VAR_PARTIAL, VV_RO),</a>
<a name="ln277">  VV(VV_RELNUM,           &quot;relnum&quot;,           VAR_NUMBER, VV_RO),</a>
<a name="ln278">  VV(VV_VIRTNUM,          &quot;virtnum&quot;,          VAR_NUMBER, VV_RO),</a>
<a name="ln279">};</a>
<a name="ln280">#undef VV</a>
<a name="ln281"> </a>
<a name="ln282">// shorthand</a>
<a name="ln283">#define vv_type         vv_di.di_tv.v_type</a>
<a name="ln284">#define vv_nr           vv_di.di_tv.vval.v_number</a>
<a name="ln285">#define vv_bool         vv_di.di_tv.vval.v_bool</a>
<a name="ln286">#define vv_special      vv_di.di_tv.vval.v_special</a>
<a name="ln287">#define vv_float        vv_di.di_tv.vval.v_float</a>
<a name="ln288">#define vv_str          vv_di.di_tv.vval.v_string</a>
<a name="ln289">#define vv_list         vv_di.di_tv.vval.v_list</a>
<a name="ln290">#define vv_dict         vv_di.di_tv.vval.v_dict</a>
<a name="ln291">#define vv_blob         vv_di.di_tv.vval.v_blob</a>
<a name="ln292">#define vv_partial      vv_di.di_tv.vval.v_partial</a>
<a name="ln293">#define vv_tv           vv_di.di_tv</a>
<a name="ln294"> </a>
<a name="ln295">/// Variable used for v:</a>
<a name="ln296">static ScopeDictDictItem vimvars_var;</a>
<a name="ln297"> </a>
<a name="ln298">static partial_T *vvlua_partial;</a>
<a name="ln299"> </a>
<a name="ln300">/// v: hashtab</a>
<a name="ln301">#define vimvarht  vimvardict.dv_hashtab</a>
<a name="ln302"> </a>
<a name="ln303">/// Enum used by filter(), map() and mapnew()</a>
<a name="ln304">typedef enum {</a>
<a name="ln305">  FILTERMAP_FILTER,</a>
<a name="ln306">  FILTERMAP_MAP,</a>
<a name="ln307">  FILTERMAP_MAPNEW,</a>
<a name="ln308">} filtermap_T;</a>
<a name="ln309"> </a>
<a name="ln310">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln311"># include &quot;eval.c.generated.h&quot;</a>
<a name="ln312">#endif</a>
<a name="ln313"> </a>
<a name="ln314">static uint64_t last_timer_id = 1;</a>
<a name="ln315">static PMap(uint64_t) timers = MAP_INIT;</a>
<a name="ln316"> </a>
<a name="ln317">static const char *const msgpack_type_names[] = {</a>
<a name="ln318">  [kMPNil] = &quot;nil&quot;,</a>
<a name="ln319">  [kMPBoolean] = &quot;boolean&quot;,</a>
<a name="ln320">  [kMPInteger] = &quot;integer&quot;,</a>
<a name="ln321">  [kMPFloat] = &quot;float&quot;,</a>
<a name="ln322">  [kMPString] = &quot;string&quot;,</a>
<a name="ln323">  [kMPBinary] = &quot;binary&quot;,</a>
<a name="ln324">  [kMPArray] = &quot;array&quot;,</a>
<a name="ln325">  [kMPMap] = &quot;map&quot;,</a>
<a name="ln326">  [kMPExt] = &quot;ext&quot;,</a>
<a name="ln327">};</a>
<a name="ln328">const list_T *eval_msgpack_type_lists[] = {</a>
<a name="ln329">  [kMPNil] = NULL,</a>
<a name="ln330">  [kMPBoolean] = NULL,</a>
<a name="ln331">  [kMPInteger] = NULL,</a>
<a name="ln332">  [kMPFloat] = NULL,</a>
<a name="ln333">  [kMPString] = NULL,</a>
<a name="ln334">  [kMPBinary] = NULL,</a>
<a name="ln335">  [kMPArray] = NULL,</a>
<a name="ln336">  [kMPMap] = NULL,</a>
<a name="ln337">  [kMPExt] = NULL,</a>
<a name="ln338">};</a>
<a name="ln339"> </a>
<a name="ln340">dict_T *get_v_event(save_v_event_T *sve)</a>
<a name="ln341">{</a>
<a name="ln342">  dict_T *v_event = get_vim_var_dict(VV_EVENT);</a>
<a name="ln343"> </a>
<a name="ln344">  if (v_event-&gt;dv_hashtab.ht_used &gt; 0) {</a>
<a name="ln345">    // recursive use of v:event, save, make empty and restore later</a>
<a name="ln346">    sve-&gt;sve_did_save = true;</a>
<a name="ln347">    sve-&gt;sve_hashtab = v_event-&gt;dv_hashtab;</a>
<a name="ln348">    hash_init(&amp;v_event-&gt;dv_hashtab);</a>
<a name="ln349">  } else {</a>
<a name="ln350">    sve-&gt;sve_did_save = false;</a>
<a name="ln351">  }</a>
<a name="ln352">  return v_event;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">void restore_v_event(dict_T *v_event, save_v_event_T *sve)</a>
<a name="ln356">{</a>
<a name="ln357">  tv_dict_free_contents(v_event);</a>
<a name="ln358">  if (sve-&gt;sve_did_save) {</a>
<a name="ln359">    v_event-&gt;dv_hashtab = sve-&gt;sve_hashtab;</a>
<a name="ln360">  } else {</a>
<a name="ln361">    hash_init(&amp;v_event-&gt;dv_hashtab);</a>
<a name="ln362">  }</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">/// @return  &quot;n1&quot; divided by &quot;n2&quot;, taking care of dividing by zero.</a>
<a name="ln366">varnumber_T num_divide(varnumber_T n1, varnumber_T n2)</a>
<a name="ln367">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln368">{</a>
<a name="ln369">  varnumber_T result;</a>
<a name="ln370"> </a>
<a name="ln371">  if (n2 == 0) {  // give an error message?</a>
<a name="ln372">    if (n1 == 0) {</a>
<a name="ln373">      result = VARNUMBER_MIN;  // similar to NaN</a>
<a name="ln374">    } else if (n1 &lt; 0) {</a>
<a name="ln375">      result = -VARNUMBER_MAX;</a>
<a name="ln376">    } else {</a>
<a name="ln377">      result = VARNUMBER_MAX;</a>
<a name="ln378">    }</a>
<a name="ln379">  } else if (n1 == VARNUMBER_MIN &amp;&amp; n2 == -1) {</a>
<a name="ln380">    // specific case: trying to do VARNUMBAR_MIN / -1 results in a positive</a>
<a name="ln381">    // number that doesn't fit in varnumber_T and causes an FPE</a>
<a name="ln382">    result = VARNUMBER_MAX;</a>
<a name="ln383">  } else {</a>
<a name="ln384">    result = n1 / n2;</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  return result;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/// @return  &quot;n1&quot; modulus &quot;n2&quot;, taking care of dividing by zero.</a>
<a name="ln391">varnumber_T num_modulus(varnumber_T n1, varnumber_T n2)</a>
<a name="ln392">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln393">{</a>
<a name="ln394">  // Give an error when n2 is 0?</a>
<a name="ln395">  return (n2 == 0) ? 0 : (n1 % n2);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">/// Initialize the global and v: variables.</a>
<a name="ln399">void eval_init(void)</a>
<a name="ln400">{</a>
<a name="ln401">  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;</a>
<a name="ln402"> </a>
<a name="ln403">  init_var_dict(&amp;globvardict, &amp;globvars_var, VAR_DEF_SCOPE);</a>
<a name="ln404">  init_var_dict(&amp;vimvardict, &amp;vimvars_var, VAR_SCOPE);</a>
<a name="ln405">  vimvardict.dv_lock = VAR_FIXED;</a>
<a name="ln406">  hash_init(&amp;compat_hashtab);</a>
<a name="ln407">  func_init();</a>
<a name="ln408"> </a>
<a name="ln409">  for (size_t i = 0; i &lt; ARRAY_SIZE(vimvars); i++) {</a>
<a name="ln410">    struct vimvar *p = &amp;vimvars[i];</a>
<a name="ln411">    assert(strlen(p-&gt;vv_name) &lt;= VIMVAR_KEY_LEN);</a>
<a name="ln412">    STRCPY(p-&gt;vv_di.di_key, p-&gt;vv_name);</a>
<a name="ln413">    if (p-&gt;vv_flags &amp; VV_RO) {</a>
<a name="ln414">      p-&gt;vv_di.di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln415">    } else if (p-&gt;vv_flags &amp; VV_RO_SBX) {</a>
<a name="ln416">      p-&gt;vv_di.di_flags = DI_FLAGS_RO_SBX | DI_FLAGS_FIX;</a>
<a name="ln417">    } else {</a>
<a name="ln418">      p-&gt;vv_di.di_flags = DI_FLAGS_FIX;</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    // add to v: scope dict, unless the value is not always available</a>
<a name="ln422">    if (p-&gt;vv_type != VAR_UNKNOWN) {</a>
<a name="ln423">      hash_add(&amp;vimvarht, p-&gt;vv_di.di_key);</a>
<a name="ln424">    }</a>
<a name="ln425">    if (p-&gt;vv_flags &amp; VV_COMPAT) {</a>
<a name="ln426">      // add to compat scope dict</a>
<a name="ln427">      hash_add(&amp;compat_hashtab, p-&gt;vv_di.di_key);</a>
<a name="ln428">    }</a>
<a name="ln429">  }</a>
<a name="ln430">  vimvars[VV_VERSION].vv_nr = VIM_VERSION_100;</a>
<a name="ln431"> </a>
<a name="ln432">  dict_T *const msgpack_types_dict = tv_dict_alloc();</a>
<a name="ln433">  for (size_t i = 0; i &lt; ARRAY_SIZE(msgpack_type_names); i++) {</a>
<a name="ln434">    list_T *const type_list = tv_list_alloc(0);</a>
<a name="ln435">    tv_list_set_lock(type_list, VAR_FIXED);</a>
<a name="ln436">    tv_list_ref(type_list);</a>
<a name="ln437">    dictitem_T *const di = tv_dict_item_alloc(msgpack_type_names[i]);</a>
<a name="ln438">    di-&gt;di_flags |= DI_FLAGS_RO|DI_FLAGS_FIX;</a>
<a name="ln439">    di-&gt;di_tv = (typval_T) {</a>
<a name="ln440">      .v_type = VAR_LIST,</a>
<a name="ln441">      .vval = { .v_list = type_list, },</a>
<a name="ln442">    };</a>
<a name="ln443">    eval_msgpack_type_lists[i] = type_list;</a>
<a name="ln444">    if (tv_dict_add(msgpack_types_dict, di) == FAIL) {</a>
<a name="ln445">      // There must not be duplicate items in this dictionary by definition.</a>
<a name="ln446">      abort();</a>
<a name="ln447">    }</a>
<a name="ln448">  }</a>
<a name="ln449">  msgpack_types_dict-&gt;dv_lock = VAR_FIXED;</a>
<a name="ln450"> </a>
<a name="ln451">  set_vim_var_dict(VV_MSGPACK_TYPES, msgpack_types_dict);</a>
<a name="ln452">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln453"> </a>
<a name="ln454">  set_vim_var_dict(VV_EVENT, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln455">  set_vim_var_list(VV_ERRORS, tv_list_alloc(kListLenUnknown));</a>
<a name="ln456">  set_vim_var_nr(VV_STDERR,   CHAN_STDERR);</a>
<a name="ln457">  set_vim_var_nr(VV_SEARCHFORWARD, 1);</a>
<a name="ln458">  set_vim_var_nr(VV_HLSEARCH, 1);</a>
<a name="ln459">  set_vim_var_nr(VV_COUNT1, 1);</a>
<a name="ln460">  set_vim_var_nr(VV_TYPE_NUMBER, VAR_TYPE_NUMBER);</a>
<a name="ln461">  set_vim_var_nr(VV_TYPE_STRING, VAR_TYPE_STRING);</a>
<a name="ln462">  set_vim_var_nr(VV_TYPE_FUNC,   VAR_TYPE_FUNC);</a>
<a name="ln463">  set_vim_var_nr(VV_TYPE_LIST,   VAR_TYPE_LIST);</a>
<a name="ln464">  set_vim_var_nr(VV_TYPE_DICT,   VAR_TYPE_DICT);</a>
<a name="ln465">  set_vim_var_nr(VV_TYPE_FLOAT,  VAR_TYPE_FLOAT);</a>
<a name="ln466">  set_vim_var_nr(VV_TYPE_BOOL,   VAR_TYPE_BOOL);</a>
<a name="ln467">  set_vim_var_nr(VV_TYPE_BLOB,   VAR_TYPE_BLOB);</a>
<a name="ln468"> </a>
<a name="ln469">  set_vim_var_bool(VV_FALSE, kBoolVarFalse);</a>
<a name="ln470">  set_vim_var_bool(VV_TRUE, kBoolVarTrue);</a>
<a name="ln471">  set_vim_var_special(VV_NULL, kSpecialVarNull);</a>
<a name="ln472">  set_vim_var_nr(VV_NUMBERMAX, VARNUMBER_MAX);</a>
<a name="ln473">  set_vim_var_nr(VV_NUMBERMIN, VARNUMBER_MIN);</a>
<a name="ln474">  set_vim_var_nr(VV_NUMBERSIZE, sizeof(varnumber_T) * 8);</a>
<a name="ln475">  set_vim_var_special(VV_EXITING, kSpecialVarNull);</a>
<a name="ln476">  set_vim_var_nr(VV_MAXCOL, MAXCOL);</a>
<a name="ln477"> </a>
<a name="ln478">  set_vim_var_nr(VV_ECHOSPACE,    sc_col - 1);</a>
<a name="ln479"> </a>
<a name="ln480">  vimvars[VV_LUA].vv_type = VAR_PARTIAL;</a>
<a name="ln481">  vvlua_partial = xcalloc(1, sizeof(partial_T));</a>
<a name="ln482">  vimvars[VV_LUA].vv_partial = vvlua_partial;</a>
<a name="ln483">  // this value shouldn't be printed, but if it is, do not crash</a>
<a name="ln484">  vvlua_partial-&gt;pt_name = xmallocz(0);</a>
<a name="ln485">  vvlua_partial-&gt;pt_refcount++;</a>
<a name="ln486"> </a>
<a name="ln487">  set_reg_var(0);  // default for v:register is not 0 but '&quot;'</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">#if defined(EXITFREE)</a>
<a name="ln491">static void evalvars_clear(void)</a>
<a name="ln492">{</a>
<a name="ln493">  for (size_t i = 0; i &lt; ARRAY_SIZE(vimvars); i++) {</a>
<a name="ln494">    struct vimvar *p = &amp;vimvars[i];</a>
<a name="ln495">    if (p-&gt;vv_di.di_tv.v_type == VAR_STRING) {</a>
<a name="ln496">      XFREE_CLEAR(p-&gt;vv_str);</a>
<a name="ln497">    } else if (p-&gt;vv_di.di_tv.v_type == VAR_LIST) {</a>
<a name="ln498">      tv_list_unref(p-&gt;vv_list);</a>
<a name="ln499">      p-&gt;vv_list = NULL;</a>
<a name="ln500">    }</a>
<a name="ln501">  }</a>
<a name="ln502">  hash_clear(&amp;vimvarht);</a>
<a name="ln503">  hash_init(&amp;vimvarht);    // garbage_collect() will access it</a>
<a name="ln504">  hash_clear(&amp;compat_hashtab);</a>
<a name="ln505"> </a>
<a name="ln506">  // global variables</a>
<a name="ln507">  vars_clear(&amp;globvarht);</a>
<a name="ln508"> </a>
<a name="ln509">  // Script-local variables. Clear all the variables here.</a>
<a name="ln510">  // The scriptvar_T is cleared later in free_scriptnames(), because a</a>
<a name="ln511">  // variable in one script might hold a reference to the whole scope of</a>
<a name="ln512">  // another script.</a>
<a name="ln513">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln514">    vars_clear(&amp;SCRIPT_VARS(i));</a>
<a name="ln515">  }</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">void eval_clear(void)</a>
<a name="ln519">{</a>
<a name="ln520">  evalvars_clear();</a>
<a name="ln521">  free_scriptnames();  // must come after evalvars_clear().</a>
<a name="ln522"># ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln523">  free_locales();</a>
<a name="ln524"># endif</a>
<a name="ln525"> </a>
<a name="ln526">  // autoloaded script names</a>
<a name="ln527">  free_autoload_scriptnames();</a>
<a name="ln528"> </a>
<a name="ln529">  // unreferenced lists and dicts</a>
<a name="ln530">  (void)garbage_collect(false);</a>
<a name="ln531"> </a>
<a name="ln532">  // functions not garbage collected</a>
<a name="ln533">  free_all_functions();</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">#endif</a>
<a name="ln537"> </a>
<a name="ln538">/// Set an internal variable to a string value. Creates the variable if it does</a>
<a name="ln539">/// not already exist.</a>
<a name="ln540">void set_internal_string_var(const char *name, char *value)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln541">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln542">{</a>
<a name="ln543">  typval_T tv = {</a>
<a name="ln544">    .v_type = VAR_STRING,</a>
<a name="ln545">    .vval.v_string = value,</a>
<a name="ln546">  };</a>
<a name="ln547"> </a>
<a name="ln548">  set_var(name, strlen(name), &amp;tv, true);</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">static lval_T *redir_lval = NULL;</a>
<a name="ln552">static garray_T redir_ga;  // Only valid when redir_lval is not NULL.</a>
<a name="ln553">static char *redir_endp = NULL;</a>
<a name="ln554">static char *redir_varname = NULL;</a>
<a name="ln555"> </a>
<a name="ln556">/// Start recording command output to a variable</a>
<a name="ln557">///</a>
<a name="ln558">/// @param append  append to an existing variable</a>
<a name="ln559">///</a>
<a name="ln560">/// @return  OK if successfully completed the setup.  FAIL otherwise.</a>
<a name="ln561">int var_redir_start(char *name, int append)</a>
<a name="ln562">{</a>
<a name="ln563">  // Catch a bad name early.</a>
<a name="ln564">  if (!eval_isnamec1(*name)) {</a>
<a name="ln565">    emsg(_(e_invarg));</a>
<a name="ln566">    return FAIL;</a>
<a name="ln567">  }</a>
<a name="ln568"> </a>
<a name="ln569">  // Make a copy of the name, it is used in redir_lval until redir ends.</a>
<a name="ln570">  redir_varname = xstrdup(name);</a>
<a name="ln571"> </a>
<a name="ln572">  redir_lval = xcalloc(1, sizeof(lval_T));</a>
<a name="ln573"> </a>
<a name="ln574">  // The output is stored in growarray &quot;redir_ga&quot; until redirection ends.</a>
<a name="ln575">  ga_init(&amp;redir_ga, (int)sizeof(char), 500);</a>
<a name="ln576"> </a>
<a name="ln577">  // Parse the variable name (can be a dict or list entry).</a>
<a name="ln578">  redir_endp = get_lval(redir_varname, NULL, redir_lval, false, false,</a>
<a name="ln579">                        0, FNE_CHECK_START);</a>
<a name="ln580">  if (redir_endp == NULL || redir_lval-&gt;ll_name == NULL</a>
<a name="ln581">      || *redir_endp != NUL) {</a>
<a name="ln582">    clear_lval(redir_lval);</a>
<a name="ln583">    if (redir_endp != NULL &amp;&amp; *redir_endp != NUL) {</a>
<a name="ln584">      // Trailing characters are present after the variable name</a>
<a name="ln585">      semsg(_(e_trailing_arg), redir_endp);</a>
<a name="ln586">    } else {</a>
<a name="ln587">      semsg(_(e_invarg2), name);</a>
<a name="ln588">    }</a>
<a name="ln589">    redir_endp = NULL;      // don't store a value, only cleanup</a>
<a name="ln590">    var_redir_stop();</a>
<a name="ln591">    return FAIL;</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  // check if we can write to the variable: set it to or append an empty</a>
<a name="ln595">  // string</a>
<a name="ln596">  const int called_emsg_before = called_emsg;</a>
<a name="ln597">  did_emsg = false;</a>
<a name="ln598">  typval_T tv;</a>
<a name="ln599">  tv.v_type = VAR_STRING;</a>
<a name="ln600">  tv.vval.v_string = &quot;&quot;;</a>
<a name="ln601">  if (append) {</a>
<a name="ln602">    set_var_lval(redir_lval, redir_endp, &amp;tv, true, false, &quot;.&quot;);</a>
<a name="ln603">  } else {</a>
<a name="ln604">    set_var_lval(redir_lval, redir_endp, &amp;tv, true, false, &quot;=&quot;);</a>
<a name="ln605">  }</a>
<a name="ln606">  clear_lval(redir_lval);</a>
<a name="ln607">  if (called_emsg &gt; called_emsg_before) {</a>
<a name="ln608">    redir_endp = NULL;      // don't store a value, only cleanup</a>
<a name="ln609">    var_redir_stop();</a>
<a name="ln610">    return FAIL;</a>
<a name="ln611">  }</a>
<a name="ln612"> </a>
<a name="ln613">  return OK;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/// Append &quot;value[value_len]&quot; to the variable set by var_redir_start().</a>
<a name="ln617">/// The actual appending is postponed until redirection ends, because the value</a>
<a name="ln618">/// appended may in fact be the string we write to, changing it may cause freed</a>
<a name="ln619">/// memory to be used:</a>
<a name="ln620">///   :redir =&gt; foo</a>
<a name="ln621">///   :let foo</a>
<a name="ln622">///   :redir END</a>
<a name="ln623">void var_redir_str(const char *value, int value_len)</a>
<a name="ln624">{</a>
<a name="ln625">  if (redir_lval == NULL) {</a>
<a name="ln626">    return;</a>
<a name="ln627">  }</a>
<a name="ln628"> </a>
<a name="ln629">  int len;</a>
<a name="ln630">  if (value_len == -1) {</a>
<a name="ln631">    len = (int)strlen(value);           // Append the entire string</a>
<a name="ln632">  } else {</a>
<a name="ln633">    len = value_len;                    // Append only &quot;value_len&quot; characters</a>
<a name="ln634">  }</a>
<a name="ln635"> </a>
<a name="ln636">  ga_grow(&amp;redir_ga, len);</a>
<a name="ln637">  memmove((char *)redir_ga.ga_data + redir_ga.ga_len, value, (size_t)len);</a>
<a name="ln638">  redir_ga.ga_len += len;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">/// Stop redirecting command output to a variable.</a>
<a name="ln642">/// Frees the allocated memory.</a>
<a name="ln643">void var_redir_stop(void)</a>
<a name="ln644">{</a>
<a name="ln645">  if (redir_lval != NULL) {</a>
<a name="ln646">    // If there was no error: assign the text to the variable.</a>
<a name="ln647">    if (redir_endp != NULL) {</a>
<a name="ln648">      ga_append(&amp;redir_ga, NUL);        // Append the trailing NUL.</a>
<a name="ln649">      typval_T tv;</a>
<a name="ln650">      tv.v_type = VAR_STRING;</a>
<a name="ln651">      tv.vval.v_string = redir_ga.ga_data;</a>
<a name="ln652">      // Call get_lval() again, if it's inside a Dict or List it may</a>
<a name="ln653">      // have changed.</a>
<a name="ln654">      redir_endp = get_lval(redir_varname, NULL, redir_lval,</a>
<a name="ln655">                            false, false, 0, FNE_CHECK_START);</a>
<a name="ln656">      if (redir_endp != NULL &amp;&amp; redir_lval-&gt;ll_name != NULL) {</a>
<a name="ln657">        set_var_lval(redir_lval, redir_endp, &amp;tv, false, false, &quot;.&quot;);</a>
<a name="ln658">      }</a>
<a name="ln659">      clear_lval(redir_lval);</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    // free the collected output</a>
<a name="ln663">    XFREE_CLEAR(redir_ga.ga_data);</a>
<a name="ln664"> </a>
<a name="ln665">    XFREE_CLEAR(redir_lval);</a>
<a name="ln666">  }</a>
<a name="ln667">  XFREE_CLEAR(redir_varname);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">int eval_charconvert(const char *const enc_from, const char *const enc_to,</a>
<a name="ln671">                     const char *const fname_from, const char *const fname_to)</a>
<a name="ln672">{</a>
<a name="ln673">  const sctx_T saved_sctx = current_sctx;</a>
<a name="ln674"> </a>
<a name="ln675">  set_vim_var_string(VV_CC_FROM, enc_from, -1);</a>
<a name="ln676">  set_vim_var_string(VV_CC_TO, enc_to, -1);</a>
<a name="ln677">  set_vim_var_string(VV_FNAME_IN, fname_from, -1);</a>
<a name="ln678">  set_vim_var_string(VV_FNAME_OUT, fname_to, -1);</a>
<a name="ln679">  sctx_T *ctx = get_option_sctx(&quot;charconvert&quot;);</a>
<a name="ln680">  if (ctx != NULL) {</a>
<a name="ln681">    current_sctx = *ctx;</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  bool err = false;</a>
<a name="ln685">  if (eval_to_bool(p_ccv, &amp;err, NULL, false)) {</a>
<a name="ln686">    err = true;</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">  set_vim_var_string(VV_CC_FROM, NULL, -1);</a>
<a name="ln690">  set_vim_var_string(VV_CC_TO, NULL, -1);</a>
<a name="ln691">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln692">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln693">  current_sctx = saved_sctx;</a>
<a name="ln694"> </a>
<a name="ln695">  if (err) {</a>
<a name="ln696">    return FAIL;</a>
<a name="ln697">  }</a>
<a name="ln698">  return OK;</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">void eval_diff(const char *const origfile, const char *const newfile, const char *const outfile)</a>
<a name="ln702">{</a>
<a name="ln703">  const sctx_T saved_sctx = current_sctx;</a>
<a name="ln704">  set_vim_var_string(VV_FNAME_IN, origfile, -1);</a>
<a name="ln705">  set_vim_var_string(VV_FNAME_NEW, newfile, -1);</a>
<a name="ln706">  set_vim_var_string(VV_FNAME_OUT, outfile, -1);</a>
<a name="ln707"> </a>
<a name="ln708">  sctx_T *ctx = get_option_sctx(&quot;diffexpr&quot;);</a>
<a name="ln709">  if (ctx != NULL) {</a>
<a name="ln710">    current_sctx = *ctx;</a>
<a name="ln711">  }</a>
<a name="ln712"> </a>
<a name="ln713">  // errors are ignored</a>
<a name="ln714">  typval_T *tv = eval_expr(p_dex, NULL);</a>
<a name="ln715">  tv_free(tv);</a>
<a name="ln716"> </a>
<a name="ln717">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln718">  set_vim_var_string(VV_FNAME_NEW, NULL, -1);</a>
<a name="ln719">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln720">  current_sctx = saved_sctx;</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">void eval_patch(const char *const origfile, const char *const difffile, const char *const outfile)</a>
<a name="ln724">{</a>
<a name="ln725">  const sctx_T saved_sctx = current_sctx;</a>
<a name="ln726">  set_vim_var_string(VV_FNAME_IN, origfile, -1);</a>
<a name="ln727">  set_vim_var_string(VV_FNAME_DIFF, difffile, -1);</a>
<a name="ln728">  set_vim_var_string(VV_FNAME_OUT, outfile, -1);</a>
<a name="ln729"> </a>
<a name="ln730">  sctx_T *ctx = get_option_sctx(&quot;patchexpr&quot;);</a>
<a name="ln731">  if (ctx != NULL) {</a>
<a name="ln732">    current_sctx = *ctx;</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  // errors are ignored</a>
<a name="ln736">  typval_T *tv = eval_expr(p_pex, NULL);</a>
<a name="ln737">  tv_free(tv);</a>
<a name="ln738"> </a>
<a name="ln739">  set_vim_var_string(VV_FNAME_IN, NULL, -1);</a>
<a name="ln740">  set_vim_var_string(VV_FNAME_DIFF, NULL, -1);</a>
<a name="ln741">  set_vim_var_string(VV_FNAME_OUT, NULL, -1);</a>
<a name="ln742">  current_sctx = saved_sctx;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">void fill_evalarg_from_eap(evalarg_T *evalarg, exarg_T *eap, bool skip)</a>
<a name="ln746">{</a>
<a name="ln747">  *evalarg = (evalarg_T){ .eval_flags = skip ? 0 : EVAL_EVALUATE };</a>
<a name="ln748">  if (eap != NULL) {</a>
<a name="ln749">    if (getline_equal(eap-&gt;getline, eap-&gt;cookie, getsourceline)) {</a>
<a name="ln750">      evalarg-&gt;eval_getline = eap-&gt;getline;</a>
<a name="ln751">      evalarg-&gt;eval_cookie = eap-&gt;cookie;</a>
<a name="ln752">    }</a>
<a name="ln753">  }</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/// Top level evaluation function, returning a boolean.</a>
<a name="ln757">/// Sets &quot;error&quot; to true if there was an error.</a>
<a name="ln758">///</a>
<a name="ln759">/// @param skip  only parse, don't execute</a>
<a name="ln760">///</a>
<a name="ln761">/// @return  true or false.</a>
<a name="ln762">int eval_to_bool(char *arg, bool *error, exarg_T *eap, int skip)</a>
<a name="ln763">{</a>
<a name="ln764">  typval_T tv;</a>
<a name="ln765">  bool retval = false;</a>
<a name="ln766">  evalarg_T evalarg;</a>
<a name="ln767"> </a>
<a name="ln768">  fill_evalarg_from_eap(&amp;evalarg, eap, skip);</a>
<a name="ln769"> </a>
<a name="ln770">  if (skip) {</a>
<a name="ln771">    emsg_skip++;</a>
<a name="ln772">  }</a>
<a name="ln773">  if (eval0(arg, &amp;tv, eap, &amp;evalarg) == FAIL) {</a>
<a name="ln774">    *error = true;</a>
<a name="ln775">  } else {</a>
<a name="ln776">    *error = false;</a>
<a name="ln777">    if (!skip) {</a>
<a name="ln778">      retval = (tv_get_number_chk(&amp;tv, error) != 0);</a>
<a name="ln779">      tv_clear(&amp;tv);</a>
<a name="ln780">    }</a>
<a name="ln781">  }</a>
<a name="ln782">  if (skip) {</a>
<a name="ln783">    emsg_skip--;</a>
<a name="ln784">  }</a>
<a name="ln785">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln786"> </a>
<a name="ln787">  return retval;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">/// Call eval1() and give an error message if not done at a lower level.</a>
<a name="ln791">static int eval1_emsg(char **arg, typval_T *rettv, exarg_T *eap)</a>
<a name="ln792">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln793">{</a>
<a name="ln794">  const char *const start = *arg;</a>
<a name="ln795">  const int did_emsg_before = did_emsg;</a>
<a name="ln796">  const int called_emsg_before = called_emsg;</a>
<a name="ln797">  evalarg_T evalarg;</a>
<a name="ln798"> </a>
<a name="ln799">  fill_evalarg_from_eap(&amp;evalarg, eap, eap != NULL &amp;&amp; eap-&gt;skip);</a>
<a name="ln800"> </a>
<a name="ln801">  const int ret = eval1(arg, rettv, &amp;evalarg);</a>
<a name="ln802">  if (ret == FAIL) {</a>
<a name="ln803">    // Report the invalid expression unless the expression evaluation has</a>
<a name="ln804">    // been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln805">    // exception, or we already gave a more specific error.</a>
<a name="ln806">    // Also check called_emsg for when using assert_fails().</a>
<a name="ln807">    if (!aborting()</a>
<a name="ln808">        &amp;&amp; did_emsg == did_emsg_before</a>
<a name="ln809">        &amp;&amp; called_emsg == called_emsg_before) {</a>
<a name="ln810">      semsg(_(e_invexpr2), start);</a>
<a name="ln811">    }</a>
<a name="ln812">  }</a>
<a name="ln813">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln814">  return ret;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">/// @return  whether a typval is a valid expression to pass to eval_expr_typval()</a>
<a name="ln818">///          or eval_expr_to_bool().  An empty string returns false;</a>
<a name="ln819">bool eval_expr_valid_arg(const typval_T *const tv)</a>
<a name="ln820">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_CONST</a>
<a name="ln821">{</a>
<a name="ln822">  return tv-&gt;v_type != VAR_UNKNOWN</a>
<a name="ln823">         &amp;&amp; (tv-&gt;v_type != VAR_STRING || (tv-&gt;vval.v_string != NULL &amp;&amp; *tv-&gt;vval.v_string != NUL));</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">/// Evaluate an expression, which can be a function, partial or string.</a>
<a name="ln827">/// Pass arguments &quot;argv[argc]&quot;.</a>
<a name="ln828">/// Return the result in &quot;rettv&quot; and OK or FAIL.</a>
<a name="ln829">///</a>
<a name="ln830">/// @param want_func  if true, treat a string as a function name, not an expression</a>
<a name="ln831">int eval_expr_typval(const typval_T *expr, bool want_func, typval_T *argv, int argc,</a>
<a name="ln832">                     typval_T *rettv)</a>
<a name="ln833">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln834">{</a>
<a name="ln835">  char buf[NUMBUFLEN];</a>
<a name="ln836">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln837"> </a>
<a name="ln838">  if (expr-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln839">    partial_T *const partial = expr-&gt;vval.v_partial;</a>
<a name="ln840">    if (partial == NULL) {</a>
<a name="ln841">      return FAIL;</a>
<a name="ln842">    }</a>
<a name="ln843">    const char *const s = partial_name(partial);</a>
<a name="ln844">    if (s == NULL || *s == NUL) {</a>
<a name="ln845">      return FAIL;</a>
<a name="ln846">    }</a>
<a name="ln847">    funcexe.fe_evaluate = true;</a>
<a name="ln848">    funcexe.fe_partial = partial;</a>
<a name="ln849">    if (call_func(s, -1, rettv, argc, argv, &amp;funcexe) == FAIL) {</a>
<a name="ln850">      return FAIL;</a>
<a name="ln851">    }</a>
<a name="ln852">  } else if (expr-&gt;v_type == VAR_FUNC || want_func) {</a>
<a name="ln853">    const char *const s = (expr-&gt;v_type == VAR_FUNC</a>
<a name="ln854">                           ? expr-&gt;vval.v_string</a>
<a name="ln855">                           : tv_get_string_buf_chk(expr, buf));</a>
<a name="ln856">    if (s == NULL || *s == NUL) {</a>
<a name="ln857">      return FAIL;</a>
<a name="ln858">    }</a>
<a name="ln859">    funcexe.fe_evaluate = true;</a>
<a name="ln860">    if (call_func(s, -1, rettv, argc, argv, &amp;funcexe) == FAIL) {</a>
<a name="ln861">      return FAIL;</a>
<a name="ln862">    }</a>
<a name="ln863">  } else {</a>
<a name="ln864">    char *s = (char *)tv_get_string_buf_chk(expr, buf);</a>
<a name="ln865">    if (s == NULL) {</a>
<a name="ln866">      return FAIL;</a>
<a name="ln867">    }</a>
<a name="ln868">    s = skipwhite(s);</a>
<a name="ln869">    if (eval1_emsg(&amp;s, rettv, NULL) == FAIL) {</a>
<a name="ln870">      return FAIL;</a>
<a name="ln871">    }</a>
<a name="ln872">    if (*skipwhite(s) != NUL) {  // check for trailing chars after expr</a>
<a name="ln873">      tv_clear(rettv);</a>
<a name="ln874">      semsg(_(e_invexpr2), s);</a>
<a name="ln875">      return FAIL;</a>
<a name="ln876">    }</a>
<a name="ln877">  }</a>
<a name="ln878">  return OK;</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">/// Like eval_to_bool() but using a typval_T instead of a string.</a>
<a name="ln882">/// Works for string, funcref and partial.</a>
<a name="ln883">bool eval_expr_to_bool(const typval_T *expr, bool *error)</a>
<a name="ln884">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln885">{</a>
<a name="ln886">  typval_T argv, rettv;</a>
<a name="ln887"> </a>
<a name="ln888">  if (eval_expr_typval(expr, false, &amp;argv, 0, &amp;rettv) == FAIL) {</a>
<a name="ln889">    *error = true;</a>
<a name="ln890">    return false;</a>
<a name="ln891">  }</a>
<a name="ln892">  const bool res = (tv_get_number_chk(&amp;rettv, error) != 0);</a>
<a name="ln893">  tv_clear(&amp;rettv);</a>
<a name="ln894">  return res;</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">/// Top level evaluation function, returning a string</a>
<a name="ln898">///</a>
<a name="ln899">/// @param[in]  arg  String to evaluate.</a>
<a name="ln900">/// @param[in]  skip  If true, only do parsing to nextcmd without reporting</a>
<a name="ln901">///                   errors or actually evaluating anything.</a>
<a name="ln902">///</a>
<a name="ln903">/// @return [allocated] string result of evaluation or NULL in case of error or</a>
<a name="ln904">///                     when skipping.</a>
<a name="ln905">char *eval_to_string_skip(char *arg, exarg_T *eap, const bool skip)</a>
<a name="ln906">  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln907">{</a>
<a name="ln908">  typval_T tv;</a>
<a name="ln909">  char *retval;</a>
<a name="ln910">  evalarg_T evalarg;</a>
<a name="ln911"> </a>
<a name="ln912">  fill_evalarg_from_eap(&amp;evalarg, eap, skip);</a>
<a name="ln913">  if (skip) {</a>
<a name="ln914">    emsg_skip++;</a>
<a name="ln915">  }</a>
<a name="ln916">  if (eval0(arg, &amp;tv, eap, &amp;evalarg) == FAIL || skip) {</a>
<a name="ln917">    retval = NULL;</a>
<a name="ln918">  } else {</a>
<a name="ln919">    retval = xstrdup(tv_get_string(&amp;tv));</a>
<a name="ln920">    tv_clear(&amp;tv);</a>
<a name="ln921">  }</a>
<a name="ln922">  if (skip) {</a>
<a name="ln923">    emsg_skip--;</a>
<a name="ln924">  }</a>
<a name="ln925">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln926"> </a>
<a name="ln927">  return retval;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">/// Skip over an expression at &quot;*pp&quot;.</a>
<a name="ln931">///</a>
<a name="ln932">/// @return  FAIL for an error, OK otherwise.</a>
<a name="ln933">int skip_expr(char **pp, evalarg_T *const evalarg)</a>
<a name="ln934">{</a>
<a name="ln935">  const int save_flags = evalarg == NULL ? 0 : evalarg-&gt;eval_flags;</a>
<a name="ln936"> </a>
<a name="ln937">  // Don't evaluate the expression.</a>
<a name="ln938">  if (evalarg != NULL) {</a>
<a name="ln939">    evalarg-&gt;eval_flags &amp;= ~EVAL_EVALUATE;</a>
<a name="ln940">  }</a>
<a name="ln941"> </a>
<a name="ln942">  *pp = skipwhite(*pp);</a>
<a name="ln943">  typval_T rettv;</a>
<a name="ln944">  int res = eval1(pp, &amp;rettv, NULL);</a>
<a name="ln945"> </a>
<a name="ln946">  if (evalarg != NULL) {</a>
<a name="ln947">    evalarg-&gt;eval_flags = save_flags;</a>
<a name="ln948">  }</a>
<a name="ln949"> </a>
<a name="ln950">  return res;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">/// Convert &quot;tv&quot; to a string.</a>
<a name="ln954">///</a>
<a name="ln955">/// @param convert  when true convert a List into a sequence of lines.</a>
<a name="ln956">///</a>
<a name="ln957">/// @return  an allocated string.</a>
<a name="ln958">static char *typval2string(typval_T *tv, bool convert)</a>
<a name="ln959">{</a>
<a name="ln960">  if (convert &amp;&amp; tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln961">    garray_T ga;</a>
<a name="ln962">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln963">    if (tv-&gt;vval.v_list != NULL) {</a>
<a name="ln964">      tv_list_join(&amp;ga, tv-&gt;vval.v_list, &quot;\n&quot;);</a>
<a name="ln965">      if (tv_list_len(tv-&gt;vval.v_list) &gt; 0) {</a>
<a name="ln966">        ga_append(&amp;ga, NL);</a>
<a name="ln967">      }</a>
<a name="ln968">    }</a>
<a name="ln969">    ga_append(&amp;ga, NUL);</a>
<a name="ln970">    return (char *)ga.ga_data;</a>
<a name="ln971">  }</a>
<a name="ln972">  return xstrdup(tv_get_string(tv));</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">/// Top level evaluation function, returning a string.</a>
<a name="ln976">///</a>
<a name="ln977">/// @param convert  when true convert a List into a sequence of lines.</a>
<a name="ln978">///</a>
<a name="ln979">/// @return  pointer to allocated memory, or NULL for failure.</a>
<a name="ln980">char *eval_to_string(char *arg, bool convert)</a>
<a name="ln981">{</a>
<a name="ln982">  typval_T tv;</a>
<a name="ln983">  char *retval;</a>
<a name="ln984"> </a>
<a name="ln985">  if (eval0(arg, &amp;tv, NULL, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln986">    retval = NULL;</a>
<a name="ln987">  } else {</a>
<a name="ln988">    retval = typval2string(&amp;tv, convert);</a>
<a name="ln989">    tv_clear(&amp;tv);</a>
<a name="ln990">  }</a>
<a name="ln991">  clear_evalarg(&amp;EVALARG_EVALUATE, NULL);</a>
<a name="ln992"> </a>
<a name="ln993">  return retval;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">/// Call eval_to_string() without using current local variables and using</a>
<a name="ln997">/// textlock.</a>
<a name="ln998">///</a>
<a name="ln999">/// @param use_sandbox  when true, use the sandbox.</a>
<a name="ln1000">char *eval_to_string_safe(char *arg, const bool use_sandbox)</a>
<a name="ln1001">{</a>
<a name="ln1002">  char *retval;</a>
<a name="ln1003">  funccal_entry_T funccal_entry;</a>
<a name="ln1004"> </a>
<a name="ln1005">  save_funccal(&amp;funccal_entry);</a>
<a name="ln1006">  if (use_sandbox) {</a>
<a name="ln1007">    sandbox++;</a>
<a name="ln1008">  }</a>
<a name="ln1009">  textlock++;</a>
<a name="ln1010">  retval = eval_to_string(arg, false);</a>
<a name="ln1011">  if (use_sandbox) {</a>
<a name="ln1012">    sandbox--;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  textlock--;</a>
<a name="ln1015">  restore_funccal();</a>
<a name="ln1016">  return retval;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">/// Top level evaluation function, returning a number.</a>
<a name="ln1020">/// Evaluates &quot;expr&quot; silently.</a>
<a name="ln1021">///</a>
<a name="ln1022">/// @return  -1 for an error.</a>
<a name="ln1023">varnumber_T eval_to_number(char *expr)</a>
<a name="ln1024">{</a>
<a name="ln1025">  typval_T rettv;</a>
<a name="ln1026">  varnumber_T retval;</a>
<a name="ln1027">  char *p = skipwhite(expr);</a>
<a name="ln1028"> </a>
<a name="ln1029">  emsg_off++;</a>
<a name="ln1030"> </a>
<a name="ln1031">  if (eval1(&amp;p, &amp;rettv, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln1032">    retval = -1;</a>
<a name="ln1033">  } else {</a>
<a name="ln1034">    retval = tv_get_number_chk(&amp;rettv, NULL);</a>
<a name="ln1035">    tv_clear(&amp;rettv);</a>
<a name="ln1036">  }</a>
<a name="ln1037">  emsg_off--;</a>
<a name="ln1038"> </a>
<a name="ln1039">  return retval;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">/// Top level evaluation function.</a>
<a name="ln1043">///</a>
<a name="ln1044">/// @return  an allocated typval_T with the result or</a>
<a name="ln1045">///          NULL when there is an error.</a>
<a name="ln1046">typval_T *eval_expr(char *arg, exarg_T *eap)</a>
<a name="ln1047">{</a>
<a name="ln1048">  typval_T *tv = xmalloc(sizeof(*tv));</a>
<a name="ln1049">  evalarg_T evalarg;</a>
<a name="ln1050"> </a>
<a name="ln1051">  fill_evalarg_from_eap(&amp;evalarg, eap, eap != NULL &amp;&amp; eap-&gt;skip);</a>
<a name="ln1052"> </a>
<a name="ln1053">  if (eval0(arg, tv, eap, &amp;evalarg) == FAIL) {</a>
<a name="ln1054">    XFREE_CLEAR(tv);</a>
<a name="ln1055">  }</a>
<a name="ln1056"> </a>
<a name="ln1057">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln1058">  return tv;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/// List Vim variables.</a>
<a name="ln1062">void list_vim_vars(int *first)</a>
<a name="ln1063">{</a>
<a name="ln1064">  list_hashtable_vars(&amp;vimvarht, &quot;v:&quot;, false, first);</a>
<a name="ln1065">}</a>
<a name="ln1066"> </a>
<a name="ln1067">/// List script-local variables, if there is a script.</a>
<a name="ln1068">void list_script_vars(int *first)</a>
<a name="ln1069">{</a>
<a name="ln1070">  if (current_sctx.sc_sid &gt; 0 &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln1071">    list_hashtable_vars(&amp;SCRIPT_VARS(current_sctx.sc_sid), &quot;s:&quot;, false, first);</a>
<a name="ln1072">  }</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">bool is_vimvarht(const hashtab_T *ht)</a>
<a name="ln1076">{</a>
<a name="ln1077">  return ht == &amp;vimvarht;</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">bool is_compatht(const hashtab_T *ht)</a>
<a name="ln1081">{</a>
<a name="ln1082">  return ht == &amp;compat_hashtab;</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/// Prepare v: variable &quot;idx&quot; to be used.</a>
<a name="ln1086">/// Save the current typeval in &quot;save_tv&quot;.</a>
<a name="ln1087">/// When not used yet add the variable to the v: hashtable.</a>
<a name="ln1088">void prepare_vimvar(int idx, typval_T *save_tv)</a>
<a name="ln1089">{</a>
<a name="ln1090">  *save_tv = vimvars[idx].vv_tv;</a>
<a name="ln1091">  if (vimvars[idx].vv_type == VAR_UNKNOWN) {</a>
<a name="ln1092">    hash_add(&amp;vimvarht, vimvars[idx].vv_di.di_key);</a>
<a name="ln1093">  }</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">/// Restore v: variable &quot;idx&quot; to typeval &quot;save_tv&quot;.</a>
<a name="ln1097">/// When no longer defined, remove the variable from the v: hashtable.</a>
<a name="ln1098">void restore_vimvar(int idx, typval_T *save_tv)</a>
<a name="ln1099">{</a>
<a name="ln1100">  vimvars[idx].vv_tv = *save_tv;</a>
<a name="ln1101">  if (vimvars[idx].vv_type != VAR_UNKNOWN) {</a>
<a name="ln1102">    return;</a>
<a name="ln1103">  }</a>
<a name="ln1104"> </a>
<a name="ln1105">  hashitem_T *hi = hash_find(&amp;vimvarht, vimvars[idx].vv_di.di_key);</a>
<a name="ln1106">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1107">    internal_error(&quot;restore_vimvar()&quot;);</a>
<a name="ln1108">  } else {</a>
<a name="ln1109">    hash_remove(&amp;vimvarht, hi);</a>
<a name="ln1110">  }</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">/// Evaluate an expression to a list with suggestions.</a>
<a name="ln1114">/// For the &quot;expr:&quot; part of 'spellsuggest'.</a>
<a name="ln1115">///</a>
<a name="ln1116">/// @return  NULL when there is an error.</a>
<a name="ln1117">list_T *eval_spell_expr(char *badword, char *expr)</a>
<a name="ln1118">{</a>
<a name="ln1119">  typval_T save_val;</a>
<a name="ln1120">  typval_T rettv;</a>
<a name="ln1121">  list_T *list = NULL;</a>
<a name="ln1122">  char *p = skipwhite(expr);</a>
<a name="ln1123">  const sctx_T saved_sctx = current_sctx;</a>
<a name="ln1124"> </a>
<a name="ln1125">  // Set &quot;v:val&quot; to the bad word.</a>
<a name="ln1126">  prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln1127">  vimvars[VV_VAL].vv_type = VAR_STRING;</a>
<a name="ln1128">  vimvars[VV_VAL].vv_str = badword;</a>
<a name="ln1129">  if (p_verbose == 0) {</a>
<a name="ln1130">    emsg_off++;</a>
<a name="ln1131">  }</a>
<a name="ln1132">  sctx_T *ctx = get_option_sctx(&quot;spellsuggest&quot;);</a>
<a name="ln1133">  if (ctx != NULL) {</a>
<a name="ln1134">    current_sctx = *ctx;</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  if (eval1(&amp;p, &amp;rettv, &amp;EVALARG_EVALUATE) == OK) {</a>
<a name="ln1138">    if (rettv.v_type != VAR_LIST) {</a>
<a name="ln1139">      tv_clear(&amp;rettv);</a>
<a name="ln1140">    } else {</a>
<a name="ln1141">      list = rettv.vval.v_list;</a>
<a name="ln1142">    }</a>
<a name="ln1143">  }</a>
<a name="ln1144"> </a>
<a name="ln1145">  if (p_verbose == 0) {</a>
<a name="ln1146">    emsg_off--;</a>
<a name="ln1147">  }</a>
<a name="ln1148">  restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln1149">  current_sctx = saved_sctx;</a>
<a name="ln1150"> </a>
<a name="ln1151">  return list;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">/// Get spell word from an entry from spellsuggest=expr:</a>
<a name="ln1155">///</a>
<a name="ln1156">/// Entry in question is supposed to be a list (to be checked by the caller)</a>
<a name="ln1157">/// with two items: a word and a score represented as an unsigned number</a>
<a name="ln1158">/// (whether it actually is unsigned is not checked).</a>
<a name="ln1159">///</a>
<a name="ln1160">/// Used to get the good word and score from the eval_spell_expr() result.</a>
<a name="ln1161">///</a>
<a name="ln1162">/// @param[in]  list  List to get values from.</a>
<a name="ln1163">/// @param[out]  ret_word  Suggested word. Not initialized if return value is</a>
<a name="ln1164">///                        -1.</a>
<a name="ln1165">///</a>
<a name="ln1166">/// @return -1 in case of error, score otherwise.</a>
<a name="ln1167">int get_spellword(list_T *const list, const char **ret_word)</a>
<a name="ln1168">{</a>
<a name="ln1169">  if (tv_list_len(list) != 2) {</a>
<a name="ln1170">    emsg(_(&quot;E5700: Expression from 'spellsuggest' must yield lists with &quot;</a>
<a name="ln1171">           &quot;exactly two values&quot;));</a>
<a name="ln1172">    return -1;</a>
<a name="ln1173">  }</a>
<a name="ln1174">  *ret_word = tv_list_find_str(list, 0);</a>
<a name="ln1175">  if (*ret_word == NULL) {</a>
<a name="ln1176">    return -1;</a>
<a name="ln1177">  }</a>
<a name="ln1178">  return (int)tv_list_find_nr(list, -1, NULL);</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181">/// Call some Vim script function and return the result in &quot;*rettv&quot;.</a>
<a name="ln1182">/// Uses argv[0] to argv[argc - 1] for the function arguments. argv[argc]</a>
<a name="ln1183">/// should have type VAR_UNKNOWN.</a>
<a name="ln1184">///</a>
<a name="ln1185">/// @return  OK or FAIL.</a>
<a name="ln1186">int call_vim_function(const char *func, int argc, typval_T *argv, typval_T *rettv)</a>
<a name="ln1187">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1188">{</a>
<a name="ln1189">  int ret;</a>
<a name="ln1190">  int len = (int)strlen(func);</a>
<a name="ln1191">  partial_T *pt = NULL;</a>
<a name="ln1192"> </a>
<a name="ln1193">  if (len &gt;= 6 &amp;&amp; !memcmp(func, &quot;v:lua.&quot;, 6)) {</a>
<a name="ln1194">    func += 6;</a>
<a name="ln1195">    len = check_luafunc_name(func, false);</a>
<a name="ln1196">    if (len == 0) {</a>
<a name="ln1197">      ret = FAIL;</a>
<a name="ln1198">      goto fail;</a>
<a name="ln1199">    }</a>
<a name="ln1200">    pt = vvlua_partial;</a>
<a name="ln1201">  }</a>
<a name="ln1202"> </a>
<a name="ln1203">  rettv-&gt;v_type = VAR_UNKNOWN;  // tv_clear() uses this.</a>
<a name="ln1204">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln1205">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1206">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1207">  funcexe.fe_evaluate = true;</a>
<a name="ln1208">  funcexe.fe_partial = pt;</a>
<a name="ln1209">  ret = call_func(func, len, rettv, argc, argv, &amp;funcexe);</a>
<a name="ln1210"> </a>
<a name="ln1211">fail:</a>
<a name="ln1212">  if (ret == FAIL) {</a>
<a name="ln1213">    tv_clear(rettv);</a>
<a name="ln1214">  }</a>
<a name="ln1215"> </a>
<a name="ln1216">  return ret;</a>
<a name="ln1217">}</a>
<a name="ln1218"> </a>
<a name="ln1219">/// Call Vim script function and return the result as a string.</a>
<a name="ln1220">/// Uses &quot;argv[0]&quot; to &quot;argv[argc - 1]&quot; for the function arguments. &quot;argv[argc]&quot;</a>
<a name="ln1221">/// should have type VAR_UNKNOWN.</a>
<a name="ln1222">///</a>
<a name="ln1223">/// @param[in]  func  Function name.</a>
<a name="ln1224">/// @param[in]  argc  Number of arguments.</a>
<a name="ln1225">/// @param[in]  argv  Array with typval_T arguments.</a>
<a name="ln1226">///</a>
<a name="ln1227">/// @return [allocated] NULL when calling function fails, allocated string</a>
<a name="ln1228">///                     otherwise.</a>
<a name="ln1229">void *call_func_retstr(const char *const func, int argc, typval_T *argv)</a>
<a name="ln1230">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1231">{</a>
<a name="ln1232">  typval_T rettv;</a>
<a name="ln1233">  // All arguments are passed as strings, no conversion to number.</a>
<a name="ln1234">  if (call_vim_function(func, argc, argv, &amp;rettv)</a>
<a name="ln1235">      == FAIL) {</a>
<a name="ln1236">    return NULL;</a>
<a name="ln1237">  }</a>
<a name="ln1238"> </a>
<a name="ln1239">  char *const retval = xstrdup(tv_get_string(&amp;rettv));</a>
<a name="ln1240">  tv_clear(&amp;rettv);</a>
<a name="ln1241">  return retval;</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">/// Call Vim script function and return the result as a List.</a>
<a name="ln1245">/// Uses &quot;argv&quot; and &quot;argc&quot; as call_func_retstr().</a>
<a name="ln1246">///</a>
<a name="ln1247">/// @param[in]  func  Function name.</a>
<a name="ln1248">/// @param[in]  argc  Number of arguments.</a>
<a name="ln1249">/// @param[in]  argv  Array with typval_T arguments.</a>
<a name="ln1250">///</a>
<a name="ln1251">/// @return [allocated] NULL when calling function fails or return tv is not a</a>
<a name="ln1252">///                     List, allocated List otherwise.</a>
<a name="ln1253">void *call_func_retlist(const char *func, int argc, typval_T *argv)</a>
<a name="ln1254">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1255">{</a>
<a name="ln1256">  typval_T rettv;</a>
<a name="ln1257"> </a>
<a name="ln1258">  // All arguments are passed as strings, no conversion to number.</a>
<a name="ln1259">  if (call_vim_function(func, argc, argv, &amp;rettv) == FAIL) {</a>
<a name="ln1260">    return NULL;</a>
<a name="ln1261">  }</a>
<a name="ln1262"> </a>
<a name="ln1263">  if (rettv.v_type != VAR_LIST) {</a>
<a name="ln1264">    tv_clear(&amp;rettv);</a>
<a name="ln1265">    return NULL;</a>
<a name="ln1266">  }</a>
<a name="ln1267"> </a>
<a name="ln1268">  return rettv.vval.v_list;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">/// Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding</a>
<a name="ln1272">/// it in &quot;*cp&quot;.  Doesn't give error messages.</a>
<a name="ln1273">int eval_foldexpr(win_T *wp, int *cp)</a>
<a name="ln1274">{</a>
<a name="ln1275">  const sctx_T saved_sctx = current_sctx;</a>
<a name="ln1276">  const bool use_sandbox = was_set_insecurely(wp, &quot;foldexpr&quot;, OPT_LOCAL);</a>
<a name="ln1277"> </a>
<a name="ln1278">  char *arg = wp-&gt;w_p_fde;</a>
<a name="ln1279">  current_sctx = wp-&gt;w_p_script_ctx[WV_FDE].script_ctx;</a>
<a name="ln1280"> </a>
<a name="ln1281">  emsg_off++;</a>
<a name="ln1282">  if (use_sandbox) {</a>
<a name="ln1283">    sandbox++;</a>
<a name="ln1284">  }</a>
<a name="ln1285">  textlock++;</a>
<a name="ln1286">  *cp = NUL;</a>
<a name="ln1287"> </a>
<a name="ln1288">  typval_T tv;</a>
<a name="ln1289">  varnumber_T retval;</a>
<a name="ln1290">  if (eval0(arg, &amp;tv, NULL, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln1291">    retval = 0;</a>
<a name="ln1292">  } else {</a>
<a name="ln1293">    // If the result is a number, just return the number.</a>
<a name="ln1294">    if (tv.v_type == VAR_NUMBER) {</a>
<a name="ln1295">      retval = tv.vval.v_number;</a>
<a name="ln1296">    } else if (tv.v_type != VAR_STRING || tv.vval.v_string == NULL) {</a>
<a name="ln1297">      retval = 0;</a>
<a name="ln1298">    } else {</a>
<a name="ln1299">      // If the result is a string, check if there is a non-digit before</a>
<a name="ln1300">      // the number.</a>
<a name="ln1301">      char *s = tv.vval.v_string;</a>
<a name="ln1302">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s) &amp;&amp; *s != '-') {</a>
<a name="ln1303">        *cp = (uint8_t)(*s++);</a>
<a name="ln1304">      }</a>
<a name="ln1305">      retval = atol(s);</a>
<a name="ln1306">    }</a>
<a name="ln1307">    tv_clear(&amp;tv);</a>
<a name="ln1308">  }</a>
<a name="ln1309"> </a>
<a name="ln1310">  emsg_off--;</a>
<a name="ln1311">  if (use_sandbox) {</a>
<a name="ln1312">    sandbox--;</a>
<a name="ln1313">  }</a>
<a name="ln1314">  textlock--;</a>
<a name="ln1315">  clear_evalarg(&amp;EVALARG_EVALUATE, NULL);</a>
<a name="ln1316">  current_sctx = saved_sctx;</a>
<a name="ln1317"> </a>
<a name="ln1318">  return (int)retval;</a>
<a name="ln1319">}</a>
<a name="ln1320"> </a>
<a name="ln1321">/// Evaluate 'foldtext', returning an Array or a String (NULL_STRING on failure).</a>
<a name="ln1322">Object eval_foldtext(win_T *wp)</a>
<a name="ln1323">{</a>
<a name="ln1324">  const bool use_sandbox = was_set_insecurely(wp, &quot;foldtext&quot;, OPT_LOCAL);</a>
<a name="ln1325">  char *arg = wp-&gt;w_p_fdt;</a>
<a name="ln1326">  funccal_entry_T funccal_entry;</a>
<a name="ln1327"> </a>
<a name="ln1328">  save_funccal(&amp;funccal_entry);</a>
<a name="ln1329">  if (use_sandbox) {</a>
<a name="ln1330">    sandbox++;</a>
<a name="ln1331">  }</a>
<a name="ln1332">  textlock++;</a>
<a name="ln1333"> </a>
<a name="ln1334">  typval_T tv;</a>
<a name="ln1335">  Object retval;</a>
<a name="ln1336">  if (eval0(arg, &amp;tv, NULL, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln1337">    retval = STRING_OBJ(NULL_STRING);</a>
<a name="ln1338">  } else {</a>
<a name="ln1339">    if (tv.v_type == VAR_LIST) {</a>
<a name="ln1340">      retval = vim_to_object(&amp;tv);</a>
<a name="ln1341">    } else {</a>
<a name="ln1342">      retval = STRING_OBJ(cstr_to_string(tv_get_string(&amp;tv)));</a>
<a name="ln1343">    }</a>
<a name="ln1344">    tv_clear(&amp;tv);</a>
<a name="ln1345">  }</a>
<a name="ln1346">  clear_evalarg(&amp;EVALARG_EVALUATE, NULL);</a>
<a name="ln1347"> </a>
<a name="ln1348">  if (use_sandbox) {</a>
<a name="ln1349">    sandbox--;</a>
<a name="ln1350">  }</a>
<a name="ln1351">  textlock--;</a>
<a name="ln1352">  restore_funccal();</a>
<a name="ln1353"> </a>
<a name="ln1354">  return retval;</a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>
<a name="ln1357">/// Get an lvalue</a>
<a name="ln1358">///</a>
<a name="ln1359">/// Lvalue may be</a>
<a name="ln1360">/// - variable: &quot;name&quot;, &quot;na{me}&quot;</a>
<a name="ln1361">/// - dictionary item: &quot;dict.key&quot;, &quot;dict['key']&quot;</a>
<a name="ln1362">/// - list item: &quot;list[expr]&quot;</a>
<a name="ln1363">/// - list slice: &quot;list[expr:expr]&quot;</a>
<a name="ln1364">///</a>
<a name="ln1365">/// Indexing only works if trying to use it with an existing List or Dictionary.</a>
<a name="ln1366">///</a>
<a name="ln1367">/// @param[in]  name  Name to parse.</a>
<a name="ln1368">/// @param  rettv  Pointer to the value to be assigned or NULL.</a>
<a name="ln1369">/// @param[out]  lp  Lvalue definition. When evaluation errors occur `-&gt;ll_name`</a>
<a name="ln1370">///                  is NULL.</a>
<a name="ln1371">/// @param[in]  unlet  True if using `:unlet`. This results in slightly</a>
<a name="ln1372">///                    different behaviour when something is wrong; must end in</a>
<a name="ln1373">///                    space or cmd separator.</a>
<a name="ln1374">/// @param[in]  skip  True when skipping.</a>
<a name="ln1375">/// @param[in]  flags  @see GetLvalFlags.</a>
<a name="ln1376">/// @param[in]  fne_flags  Flags for find_name_end().</a>
<a name="ln1377">///</a>
<a name="ln1378">/// @return A pointer to just after the name, including indexes. Returns NULL</a>
<a name="ln1379">///         for a parsing error, but it is still needed to free items in lp.</a>
<a name="ln1380">char *get_lval(char *const name, typval_T *const rettv, lval_T *const lp, const bool unlet,</a>
<a name="ln1381">               const bool skip, const int flags, const int fne_flags)</a>
<a name="ln1382">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln1383">{</a>
<a name="ln1384">  bool empty1 = false;</a>
<a name="ln1385">  int quiet = flags &amp; GLV_QUIET;</a>
<a name="ln1386"> </a>
<a name="ln1387">  // Clear everything in &quot;lp&quot;.</a>
<a name="ln1388">  CLEAR_POINTER(lp);</a>
<a name="ln1389"> </a>
<a name="ln1390">  if (skip) {</a>
<a name="ln1391">    // When skipping just find the end of the name.</a>
<a name="ln1392">    lp-&gt;ll_name = name;</a>
<a name="ln1393">    return (char *)find_name_end(name, NULL, NULL, FNE_INCL_BR | fne_flags);</a>
<a name="ln1394">  }</a>
<a name="ln1395"> </a>
<a name="ln1396">  // Find the end of the name.</a>
<a name="ln1397">  char *expr_start;</a>
<a name="ln1398">  char *expr_end;</a>
<a name="ln1399">  char *p = (char *)find_name_end(name, (const char **)&amp;expr_start,</a>
<a name="ln1400">                                  (const char **)&amp;expr_end,</a>
<a name="ln1401">                                  fne_flags);</a>
<a name="ln1402">  if (expr_start != NULL) {</a>
<a name="ln1403">    // Don't expand the name when we already know there is an error.</a>
<a name="ln1404">    if (unlet &amp;&amp; !ascii_iswhite(*p) &amp;&amp; !ends_excmd(*p)</a>
<a name="ln1405">        &amp;&amp; *p != '[' &amp;&amp; *p != '.') {</a>
<a name="ln1406">      semsg(_(e_trailing_arg), p);</a>
<a name="ln1407">      return NULL;</a>
<a name="ln1408">    }</a>
<a name="ln1409"> </a>
<a name="ln1410">    lp-&gt;ll_exp_name = make_expanded_name(name, expr_start, expr_end, p);</a>
<a name="ln1411">    lp-&gt;ll_name = lp-&gt;ll_exp_name;</a>
<a name="ln1412">    if (lp-&gt;ll_exp_name == NULL) {</a>
<a name="ln1413">      // Report an invalid expression in braces, unless the</a>
<a name="ln1414">      // expression evaluation has been cancelled due to an</a>
<a name="ln1415">      // aborting error, an interrupt, or an exception.</a>
<a name="ln1416">      if (!aborting() &amp;&amp; !quiet) {</a>
<a name="ln1417">        emsg_severe = true;</a>
<a name="ln1418">        semsg(_(e_invarg2), name);</a>
<a name="ln1419">        return NULL;</a>
<a name="ln1420">      }</a>
<a name="ln1421">      lp-&gt;ll_name_len = 0;</a>
<a name="ln1422">    } else {</a>
<a name="ln1423">      lp-&gt;ll_name_len = strlen(lp-&gt;ll_name);</a>
<a name="ln1424">    }</a>
<a name="ln1425">  } else {</a>
<a name="ln1426">    lp-&gt;ll_name = name;</a>
<a name="ln1427">    lp-&gt;ll_name_len = (size_t)(p - lp-&gt;ll_name);</a>
<a name="ln1428">  }</a>
<a name="ln1429"> </a>
<a name="ln1430">  // Without [idx] or .key we are done.</a>
<a name="ln1431">  if ((*p != '[' &amp;&amp; *p != '.') || lp-&gt;ll_name == NULL) {</a>
<a name="ln1432">    return p;</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  hashtab_T *ht = NULL;</a>
<a name="ln1436"> </a>
<a name="ln1437">  // Only pass &amp;ht when we would write to the variable, it prevents autoload</a>
<a name="ln1438">  // as well.</a>
<a name="ln1439">  dictitem_T *v = find_var(lp-&gt;ll_name, lp-&gt;ll_name_len,</a>
<a name="ln1440">                           (flags &amp; GLV_READ_ONLY) ? NULL : &amp;ht,</a>
<a name="ln1441">                           flags &amp; GLV_NO_AUTOLOAD);</a>
<a name="ln1442">  if (v == NULL &amp;&amp; !quiet) {</a>
<a name="ln1443">    semsg(_(&quot;E121: Undefined variable: %.*s&quot;),</a>
<a name="ln1444">          (int)lp-&gt;ll_name_len, lp-&gt;ll_name);</a>
<a name="ln1445">  }</a>
<a name="ln1446">  if (v == NULL) {</a>
<a name="ln1447">    return NULL;</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  lp-&gt;ll_tv = &amp;v-&gt;di_tv;</a>
<a name="ln1451"> </a>
<a name="ln1452">  if (tv_is_luafunc(lp-&gt;ll_tv)) {</a>
<a name="ln1453">    // For v:lua just return a pointer to the &quot;.&quot; after the &quot;v:lua&quot;.</a>
<a name="ln1454">    // If the caller is trans_function_name() it will check for a Lua function name.</a>
<a name="ln1455">    return p;</a>
<a name="ln1456">  }</a>
<a name="ln1457"> </a>
<a name="ln1458">  // Loop until no more [idx] or .key is following.</a>
<a name="ln1459">  typval_T var1;</a>
<a name="ln1460">  var1.v_type = VAR_UNKNOWN;</a>
<a name="ln1461">  typval_T var2;</a>
<a name="ln1462">  var2.v_type = VAR_UNKNOWN;</a>
<a name="ln1463">  while (*p == '[' || (*p == '.' &amp;&amp; p[1] != '=' &amp;&amp; p[1] != '.')) {</a>
<a name="ln1464">    if (*p == '.' &amp;&amp; lp-&gt;ll_tv-&gt;v_type != VAR_DICT) {</a>
<a name="ln1465">      if (!quiet) {</a>
<a name="ln1466">        semsg(_(e_dot_can_only_be_used_on_dictionary_str), name);</a>
<a name="ln1467">      }</a>
<a name="ln1468">      return NULL;</a>
<a name="ln1469">    }</a>
<a name="ln1470">    if (lp-&gt;ll_tv-&gt;v_type != VAR_LIST</a>
<a name="ln1471">        &amp;&amp; lp-&gt;ll_tv-&gt;v_type != VAR_DICT</a>
<a name="ln1472">        &amp;&amp; lp-&gt;ll_tv-&gt;v_type != VAR_BLOB) {</a>
<a name="ln1473">      if (!quiet) {</a>
<a name="ln1474">        emsg(_(&quot;E689: Can only index a List, Dictionary or Blob&quot;));</a>
<a name="ln1475">      }</a>
<a name="ln1476">      return NULL;</a>
<a name="ln1477">    }</a>
<a name="ln1478"> </a>
<a name="ln1479">    // a NULL list/blob works like an empty list/blob, allocate one now.</a>
<a name="ln1480">    if (lp-&gt;ll_tv-&gt;v_type == VAR_LIST &amp;&amp; lp-&gt;ll_tv-&gt;vval.v_list == NULL) {</a>
<a name="ln1481">      tv_list_alloc_ret(lp-&gt;ll_tv, kListLenUnknown);</a>
<a name="ln1482">    } else if (lp-&gt;ll_tv-&gt;v_type == VAR_BLOB &amp;&amp; lp-&gt;ll_tv-&gt;vval.v_blob == NULL) {</a>
<a name="ln1483">      tv_blob_alloc_ret(lp-&gt;ll_tv);</a>
<a name="ln1484">    }</a>
<a name="ln1485"> </a>
<a name="ln1486">    if (lp-&gt;ll_range) {</a>
<a name="ln1487">      if (!quiet) {</a>
<a name="ln1488">        emsg(_(&quot;E708: [:] must come last&quot;));</a>
<a name="ln1489">      }</a>
<a name="ln1490">      return NULL;</a>
<a name="ln1491">    }</a>
<a name="ln1492"> </a>
<a name="ln1493">    int len = -1;</a>
<a name="ln1494">    char *key = NULL;</a>
<a name="ln1495">    if (*p == '.') {</a>
<a name="ln1496">      key = p + 1;</a>
<a name="ln1497">      for (len = 0; ASCII_ISALNUM(key[len]) || key[len] == '_'; len++) {}</a>
<a name="ln1498">      if (len == 0) {</a>
<a name="ln1499">        if (!quiet) {</a>
<a name="ln1500">          emsg(_(&quot;E713: Cannot use empty key after .&quot;));</a>
<a name="ln1501">        }</a>
<a name="ln1502">        return NULL;</a>
<a name="ln1503">      }</a>
<a name="ln1504">      p = key + len;</a>
<a name="ln1505">    } else {</a>
<a name="ln1506">      // Get the index [expr] or the first index [expr: ].</a>
<a name="ln1507">      p = skipwhite(p + 1);</a>
<a name="ln1508">      if (*p == ':') {</a>
<a name="ln1509">        empty1 = true;</a>
<a name="ln1510">      } else {</a>
<a name="ln1511">        empty1 = false;</a>
<a name="ln1512">        if (eval1(&amp;p, &amp;var1, &amp;EVALARG_EVALUATE) == FAIL) {  // Recursive!</a>
<a name="ln1513">          return NULL;</a>
<a name="ln1514">        }</a>
<a name="ln1515">        if (!tv_check_str(&amp;var1)) {</a>
<a name="ln1516">          // Not a number or string.</a>
<a name="ln1517">          tv_clear(&amp;var1);</a>
<a name="ln1518">          return NULL;</a>
<a name="ln1519">        }</a>
<a name="ln1520">        p = skipwhite(p);</a>
<a name="ln1521">      }</a>
<a name="ln1522"> </a>
<a name="ln1523">      // Optionally get the second index [ :expr].</a>
<a name="ln1524">      if (*p == ':') {</a>
<a name="ln1525">        if (lp-&gt;ll_tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln1526">          if (!quiet) {</a>
<a name="ln1527">            emsg(_(e_cannot_slice_dictionary));</a>
<a name="ln1528">          }</a>
<a name="ln1529">          tv_clear(&amp;var1);</a>
<a name="ln1530">          return NULL;</a>
<a name="ln1531">        }</a>
<a name="ln1532">        if (rettv != NULL</a>
<a name="ln1533">            &amp;&amp; !(rettv-&gt;v_type == VAR_LIST &amp;&amp; rettv-&gt;vval.v_list != NULL)</a>
<a name="ln1534">            &amp;&amp; !(rettv-&gt;v_type == VAR_BLOB &amp;&amp; rettv-&gt;vval.v_blob != NULL)) {</a>
<a name="ln1535">          if (!quiet) {</a>
<a name="ln1536">            emsg(_(&quot;E709: [:] requires a List or Blob value&quot;));</a>
<a name="ln1537">          }</a>
<a name="ln1538">          tv_clear(&amp;var1);</a>
<a name="ln1539">          return NULL;</a>
<a name="ln1540">        }</a>
<a name="ln1541">        p = skipwhite(p + 1);</a>
<a name="ln1542">        if (*p == ']') {</a>
<a name="ln1543">          lp-&gt;ll_empty2 = true;</a>
<a name="ln1544">        } else {</a>
<a name="ln1545">          lp-&gt;ll_empty2 = false;</a>
<a name="ln1546">          // Recursive!</a>
<a name="ln1547">          if (eval1(&amp;p, &amp;var2, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln1548">            tv_clear(&amp;var1);</a>
<a name="ln1549">            return NULL;</a>
<a name="ln1550">          }</a>
<a name="ln1551">          if (!tv_check_str(&amp;var2)) {</a>
<a name="ln1552">            // Not a number or string.</a>
<a name="ln1553">            tv_clear(&amp;var1);</a>
<a name="ln1554">            tv_clear(&amp;var2);</a>
<a name="ln1555">            return NULL;</a>
<a name="ln1556">          }</a>
<a name="ln1557">        }</a>
<a name="ln1558">        lp-&gt;ll_range = true;</a>
<a name="ln1559">      } else {</a>
<a name="ln1560">        lp-&gt;ll_range = false;</a>
<a name="ln1561">      }</a>
<a name="ln1562"> </a>
<a name="ln1563">      if (*p != ']') {</a>
<a name="ln1564">        if (!quiet) {</a>
<a name="ln1565">          emsg(_(e_missbrac));</a>
<a name="ln1566">        }</a>
<a name="ln1567">        tv_clear(&amp;var1);</a>
<a name="ln1568">        tv_clear(&amp;var2);</a>
<a name="ln1569">        return NULL;</a>
<a name="ln1570">      }</a>
<a name="ln1571"> </a>
<a name="ln1572">      // Skip to past ']'.</a>
<a name="ln1573">      p++;</a>
<a name="ln1574">    }</a>
<a name="ln1575"> </a>
<a name="ln1576">    if (lp-&gt;ll_tv-&gt;v_type == VAR_DICT) {</a>
<a name="ln1577">      if (len == -1) {</a>
<a name="ln1578">        // &quot;[key]&quot;: get key from &quot;var1&quot;</a>
<a name="ln1579">        key = (char *)tv_get_string(&amp;var1);  // is number or string</a>
<a name="ln1580">      }</a>
<a name="ln1581">      lp-&gt;ll_list = NULL;</a>
<a name="ln1582">      lp-&gt;ll_dict = lp-&gt;ll_tv-&gt;vval.v_dict;</a>
<a name="ln1583">      lp-&gt;ll_di = tv_dict_find(lp-&gt;ll_dict, key, len);</a>
<a name="ln1584"> </a>
<a name="ln1585">      // When assigning to a scope dictionary check that a function and</a>
<a name="ln1586">      // variable name is valid (only variable name unless it is l: or</a>
<a name="ln1587">      // g: dictionary). Disallow overwriting a builtin function.</a>
<a name="ln1588">      if (rettv != NULL &amp;&amp; lp-&gt;ll_dict-&gt;dv_scope != 0) {</a>
<a name="ln1589">        char prevval;</a>
<a name="ln1590">        if (len != -1) {</a>
<a name="ln1591">          prevval = key[len];</a>
<a name="ln1592">          key[len] = NUL;</a>
<a name="ln1593">        } else {</a>
<a name="ln1594">          prevval = 0;  // Avoid compiler warning.</a>
<a name="ln1595">        }</a>
<a name="ln1596">        bool wrong = ((lp-&gt;ll_dict-&gt;dv_scope == VAR_DEF_SCOPE</a>
<a name="ln1597">                       &amp;&amp; tv_is_func(*rettv)</a>
<a name="ln1598">                       &amp;&amp; var_wrong_func_name(key, lp-&gt;ll_di == NULL))</a>
<a name="ln1599">                      || !valid_varname(key));</a>
<a name="ln1600">        if (len != -1) {</a>
<a name="ln1601">          key[len] = prevval;</a>
<a name="ln1602">        }</a>
<a name="ln1603">        if (wrong) {</a>
<a name="ln1604">          tv_clear(&amp;var1);</a>
<a name="ln1605">          return NULL;</a>
<a name="ln1606">        }</a>
<a name="ln1607">      }</a>
<a name="ln1608"> </a>
<a name="ln1609">      if (lp-&gt;ll_di != NULL &amp;&amp; tv_is_luafunc(&amp;lp-&gt;ll_di-&gt;di_tv)</a>
<a name="ln1610">          &amp;&amp; len == -1 &amp;&amp; rettv == NULL) {</a>
<a name="ln1611">        tv_clear(&amp;var1);</a>
<a name="ln1612">        semsg(e_illvar, &quot;v:['lua']&quot;);</a>
<a name="ln1613">        return NULL;</a>
<a name="ln1614">      }</a>
<a name="ln1615"> </a>
<a name="ln1616">      if (lp-&gt;ll_di == NULL) {</a>
<a name="ln1617">        // Can't add &quot;v:&quot; or &quot;a:&quot; variable.</a>
<a name="ln1618">        if (lp-&gt;ll_dict == &amp;vimvardict</a>
<a name="ln1619">            || &amp;lp-&gt;ll_dict-&gt;dv_hashtab == get_funccal_args_ht()) {</a>
<a name="ln1620">          semsg(_(e_illvar), name);</a>
<a name="ln1621">          tv_clear(&amp;var1);</a>
<a name="ln1622">          return NULL;</a>
<a name="ln1623">        }</a>
<a name="ln1624"> </a>
<a name="ln1625">        // Key does not exist in dict: may need to add it.</a>
<a name="ln1626">        if (*p == '[' || *p == '.' || unlet) {</a>
<a name="ln1627">          if (!quiet) {</a>
<a name="ln1628">            semsg(_(e_dictkey), key);</a>
<a name="ln1629">          }</a>
<a name="ln1630">          tv_clear(&amp;var1);</a>
<a name="ln1631">          return NULL;</a>
<a name="ln1632">        }</a>
<a name="ln1633">        if (len == -1) {</a>
<a name="ln1634">          lp-&gt;ll_newkey = xstrdup(key);</a>
<a name="ln1635">        } else {</a>
<a name="ln1636">          lp-&gt;ll_newkey = xmemdupz(key, (size_t)len);</a>
<a name="ln1637">        }</a>
<a name="ln1638">        tv_clear(&amp;var1);</a>
<a name="ln1639">        break;</a>
<a name="ln1640">        // existing variable, need to check if it can be changed</a>
<a name="ln1641">      } else if (!(flags &amp; GLV_READ_ONLY)</a>
<a name="ln1642">                 &amp;&amp; (var_check_ro(lp-&gt;ll_di-&gt;di_flags, name, (size_t)(p - name))</a>
<a name="ln1643">                     || var_check_lock(lp-&gt;ll_di-&gt;di_flags, name, (size_t)(p - name)))) {</a>
<a name="ln1644">        tv_clear(&amp;var1);</a>
<a name="ln1645">        return NULL;</a>
<a name="ln1646">      }</a>
<a name="ln1647"> </a>
<a name="ln1648">      tv_clear(&amp;var1);</a>
<a name="ln1649">      lp-&gt;ll_tv = &amp;lp-&gt;ll_di-&gt;di_tv;</a>
<a name="ln1650">    } else if (lp-&gt;ll_tv-&gt;v_type == VAR_BLOB) {</a>
<a name="ln1651">      // Get the number and item for the only or first index of the List.</a>
<a name="ln1652">      if (empty1) {</a>
<a name="ln1653">        lp-&gt;ll_n1 = 0;</a>
<a name="ln1654">      } else {</a>
<a name="ln1655">        // Is number or string.</a>
<a name="ln1656">        lp-&gt;ll_n1 = (int)tv_get_number(&amp;var1);</a>
<a name="ln1657">      }</a>
<a name="ln1658">      tv_clear(&amp;var1);</a>
<a name="ln1659"> </a>
<a name="ln1660">      const int bloblen = tv_blob_len(lp-&gt;ll_tv-&gt;vval.v_blob);</a>
<a name="ln1661">      if (tv_blob_check_index(bloblen, lp-&gt;ll_n1, quiet) == FAIL) {</a>
<a name="ln1662">        tv_clear(&amp;var2);</a>
<a name="ln1663">        return NULL;</a>
<a name="ln1664">      }</a>
<a name="ln1665">      if (lp-&gt;ll_range &amp;&amp; !lp-&gt;ll_empty2) {</a>
<a name="ln1666">        lp-&gt;ll_n2 = (int)tv_get_number(&amp;var2);</a>
<a name="ln1667">        tv_clear(&amp;var2);</a>
<a name="ln1668">        if (tv_blob_check_range(bloblen, lp-&gt;ll_n1, lp-&gt;ll_n2, quiet) == FAIL) {</a>
<a name="ln1669">          return NULL;</a>
<a name="ln1670">        }</a>
<a name="ln1671">      }</a>
<a name="ln1672">      lp-&gt;ll_blob = lp-&gt;ll_tv-&gt;vval.v_blob;</a>
<a name="ln1673">      lp-&gt;ll_tv = NULL;</a>
<a name="ln1674">      break;</a>
<a name="ln1675">    } else {</a>
<a name="ln1676">      // Get the number and item for the only or first index of the List.</a>
<a name="ln1677">      if (empty1) {</a>
<a name="ln1678">        lp-&gt;ll_n1 = 0;</a>
<a name="ln1679">      } else {</a>
<a name="ln1680">        // Is number or string.</a>
<a name="ln1681">        lp-&gt;ll_n1 = (int)tv_get_number(&amp;var1);</a>
<a name="ln1682">      }</a>
<a name="ln1683">      tv_clear(&amp;var1);</a>
<a name="ln1684"> </a>
<a name="ln1685">      lp-&gt;ll_dict = NULL;</a>
<a name="ln1686">      lp-&gt;ll_list = lp-&gt;ll_tv-&gt;vval.v_list;</a>
<a name="ln1687">      lp-&gt;ll_li = tv_list_check_range_index_one(lp-&gt;ll_list, &amp;lp-&gt;ll_n1, quiet);</a>
<a name="ln1688">      if (lp-&gt;ll_li == NULL) {</a>
<a name="ln1689">        tv_clear(&amp;var2);</a>
<a name="ln1690">        return NULL;</a>
<a name="ln1691">      }</a>
<a name="ln1692"> </a>
<a name="ln1693">      // May need to find the item or absolute index for the second</a>
<a name="ln1694">      // index of a range.</a>
<a name="ln1695">      // When no index given: &quot;lp-&gt;ll_empty2&quot; is true.</a>
<a name="ln1696">      // Otherwise &quot;lp-&gt;ll_n2&quot; is set to the second index.</a>
<a name="ln1697">      if (lp-&gt;ll_range &amp;&amp; !lp-&gt;ll_empty2) {</a>
<a name="ln1698">        lp-&gt;ll_n2 = (int)tv_get_number(&amp;var2);  // Is number or string.</a>
<a name="ln1699">        tv_clear(&amp;var2);</a>
<a name="ln1700">        if (tv_list_check_range_index_two(lp-&gt;ll_list,</a>
<a name="ln1701">                                          &amp;lp-&gt;ll_n1, lp-&gt;ll_li,</a>
<a name="ln1702">                                          &amp;lp-&gt;ll_n2, quiet) == FAIL) {</a>
<a name="ln1703">          return NULL;</a>
<a name="ln1704">        }</a>
<a name="ln1705">      }</a>
<a name="ln1706"> </a>
<a name="ln1707">      lp-&gt;ll_tv = TV_LIST_ITEM_TV(lp-&gt;ll_li);</a>
<a name="ln1708">    }</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  tv_clear(&amp;var1);</a>
<a name="ln1712">  return p;</a>
<a name="ln1713">}</a>
<a name="ln1714"> </a>
<a name="ln1715">/// Clear lval &quot;lp&quot; that was filled by get_lval().</a>
<a name="ln1716">void clear_lval(lval_T *lp)</a>
<a name="ln1717">{</a>
<a name="ln1718">  xfree(lp-&gt;ll_exp_name);</a>
<a name="ln1719">  xfree(lp-&gt;ll_newkey);</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">/// Set a variable that was parsed by get_lval() to &quot;rettv&quot;.</a>
<a name="ln1723">///</a>
<a name="ln1724">/// @param endp  points to just after the parsed name.</a>
<a name="ln1725">/// @param op    NULL, &quot;+&quot; for &quot;+=&quot;, &quot;-&quot; for &quot;-=&quot;, &quot;*&quot; for &quot;*=&quot;, &quot;/&quot; for &quot;/=&quot;,</a>
<a name="ln1726">///              &quot;%&quot; for &quot;%=&quot;, &quot;.&quot; for &quot;.=&quot; or &quot;=&quot; for &quot;=&quot;.</a>
<a name="ln1727">void set_var_lval(lval_T *lp, char *endp, typval_T *rettv, int copy, const bool is_const,</a>
<a name="ln1728">                  const char *op)</a>
<a name="ln1729">{</a>
<a name="ln1730">  int cc;</a>
<a name="ln1731">  dictitem_T *di;</a>
<a name="ln1732"> </a>
<a name="ln1733">  if (lp-&gt;ll_tv == NULL) {</a>
<a name="ln1734">    cc = (uint8_t)(*endp);</a>
<a name="ln1735">    *endp = NUL;</a>
<a name="ln1736">    if (lp-&gt;ll_blob != NULL) {</a>
<a name="ln1737">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln1738">        semsg(_(e_letwrong), op);</a>
<a name="ln1739">        return;</a>
<a name="ln1740">      }</a>
<a name="ln1741">      if (value_check_lock(lp-&gt;ll_blob-&gt;bv_lock, lp-&gt;ll_name, TV_CSTRING)) {</a>
<a name="ln1742">        return;</a>
<a name="ln1743">      }</a>
<a name="ln1744"> </a>
<a name="ln1745">      if (lp-&gt;ll_range &amp;&amp; rettv-&gt;v_type == VAR_BLOB) {</a>
<a name="ln1746">        if (lp-&gt;ll_empty2) {</a>
<a name="ln1747">          lp-&gt;ll_n2 = tv_blob_len(lp-&gt;ll_blob) - 1;</a>
<a name="ln1748">        }</a>
<a name="ln1749"> </a>
<a name="ln1750">        if (tv_blob_set_range(lp-&gt;ll_blob, lp-&gt;ll_n1, lp-&gt;ll_n2, rettv) == FAIL) {</a>
<a name="ln1751">          return;</a>
<a name="ln1752">        }</a>
<a name="ln1753">      } else {</a>
<a name="ln1754">        bool error = false;</a>
<a name="ln1755">        const char val = (char)tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln1756">        if (!error) {</a>
<a name="ln1757">          tv_blob_set_append(lp-&gt;ll_blob, lp-&gt;ll_n1, (uint8_t)val);</a>
<a name="ln1758">        }</a>
<a name="ln1759">      }</a>
<a name="ln1760">    } else if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln1761">      typval_T tv;</a>
<a name="ln1762"> </a>
<a name="ln1763">      if (is_const) {</a>
<a name="ln1764">        emsg(_(e_cannot_mod));</a>
<a name="ln1765">        *endp = (char)cc;</a>
<a name="ln1766">        return;</a>
<a name="ln1767">      }</a>
<a name="ln1768"> </a>
<a name="ln1769">      // handle +=, -=, *=, /=, %= and .=</a>
<a name="ln1770">      di = NULL;</a>
<a name="ln1771">      if (eval_variable(lp-&gt;ll_name, (int)strlen(lp-&gt;ll_name),</a>
<a name="ln1772">                        &amp;tv, &amp;di, true, false) == OK) {</a>
<a name="ln1773">        if ((di == NULL</a>
<a name="ln1774">             || (!var_check_ro(di-&gt;di_flags, lp-&gt;ll_name, TV_CSTRING)</a>
<a name="ln1775">                 &amp;&amp; !tv_check_lock(&amp;di-&gt;di_tv, lp-&gt;ll_name, TV_CSTRING)))</a>
<a name="ln1776">            &amp;&amp; eexe_mod_op(&amp;tv, rettv, op) == OK) {</a>
<a name="ln1777">          set_var(lp-&gt;ll_name, lp-&gt;ll_name_len, &amp;tv, false);</a>
<a name="ln1778">        }</a>
<a name="ln1779">        tv_clear(&amp;tv);</a>
<a name="ln1780">      }</a>
<a name="ln1781">    } else {</a>
<a name="ln1782">      set_var_const(lp-&gt;ll_name, lp-&gt;ll_name_len, rettv, copy, is_const);</a>
<a name="ln1783">    }</a>
<a name="ln1784">    *endp = (char)cc;</a>
<a name="ln1785">  } else if (value_check_lock(lp-&gt;ll_newkey == NULL</a>
<a name="ln1786">                              ? lp-&gt;ll_tv-&gt;v_lock</a>
<a name="ln1787">                              : lp-&gt;ll_tv-&gt;vval.v_dict-&gt;dv_lock,</a>
<a name="ln1788">                              lp-&gt;ll_name, TV_CSTRING)) {</a>
<a name="ln1789">    // Skip</a>
<a name="ln1790">  } else if (lp-&gt;ll_range) {</a>
<a name="ln1791">    if (is_const) {</a>
<a name="ln1792">      emsg(_(&quot;E996: Cannot lock a range&quot;));</a>
<a name="ln1793">      return;</a>
<a name="ln1794">    }</a>
<a name="ln1795"> </a>
<a name="ln1796">    (void)tv_list_assign_range(lp-&gt;ll_list, rettv-&gt;vval.v_list,</a>
<a name="ln1797">                               lp-&gt;ll_n1, lp-&gt;ll_n2, lp-&gt;ll_empty2, op, lp-&gt;ll_name);</a>
<a name="ln1798">  } else {</a>
<a name="ln1799">    typval_T oldtv = TV_INITIAL_VALUE;</a>
<a name="ln1800">    dict_T *dict = lp-&gt;ll_dict;</a>
<a name="ln1801">    bool watched = tv_dict_is_watched(dict);</a>
<a name="ln1802"> </a>
<a name="ln1803">    if (is_const) {</a>
<a name="ln1804">      emsg(_(&quot;E996: Cannot lock a list or dict&quot;));</a>
<a name="ln1805">      return;</a>
<a name="ln1806">    }</a>
<a name="ln1807"> </a>
<a name="ln1808">    // Assign to a List or Dictionary item.</a>
<a name="ln1809">    if (lp-&gt;ll_newkey != NULL) {</a>
<a name="ln1810">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln1811">        semsg(_(e_dictkey), lp-&gt;ll_newkey);</a>
<a name="ln1812">        return;</a>
<a name="ln1813">      }</a>
<a name="ln1814">      if (tv_dict_wrong_func_name(lp-&gt;ll_tv-&gt;vval.v_dict, rettv, lp-&gt;ll_newkey)) {</a>
<a name="ln1815">        return;</a>
<a name="ln1816">      }</a>
<a name="ln1817"> </a>
<a name="ln1818">      // Need to add an item to the Dictionary.</a>
<a name="ln1819">      di = tv_dict_item_alloc(lp-&gt;ll_newkey);</a>
<a name="ln1820">      if (tv_dict_add(lp-&gt;ll_tv-&gt;vval.v_dict, di) == FAIL) {</a>
<a name="ln1821">        xfree(di);</a>
<a name="ln1822">        return;</a>
<a name="ln1823">      }</a>
<a name="ln1824">      lp-&gt;ll_tv = &amp;di-&gt;di_tv;</a>
<a name="ln1825">    } else {</a>
<a name="ln1826">      if (watched) {</a>
<a name="ln1827">        tv_copy(lp-&gt;ll_tv, &amp;oldtv);</a>
<a name="ln1828">      }</a>
<a name="ln1829"> </a>
<a name="ln1830">      if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln1831">        eexe_mod_op(lp-&gt;ll_tv, rettv, op);</a>
<a name="ln1832">        goto notify;</a>
<a name="ln1833">      } else {</a>
<a name="ln1834">        tv_clear(lp-&gt;ll_tv);</a>
<a name="ln1835">      }</a>
<a name="ln1836">    }</a>
<a name="ln1837"> </a>
<a name="ln1838">    // Assign the value to the variable or list item.</a>
<a name="ln1839">    if (copy) {</a>
<a name="ln1840">      tv_copy(rettv, lp-&gt;ll_tv);</a>
<a name="ln1841">    } else {</a>
<a name="ln1842">      *lp-&gt;ll_tv = *rettv;</a>
<a name="ln1843">      lp-&gt;ll_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln1844">      tv_init(rettv);</a>
<a name="ln1845">    }</a>
<a name="ln1846"> </a>
<a name="ln1847">notify:</a>
<a name="ln1848">    if (watched) {</a>
<a name="ln1849">      if (oldtv.v_type == VAR_UNKNOWN) {</a>
<a name="ln1850">        assert(lp-&gt;ll_newkey != NULL);</a>
<a name="ln1851">        tv_dict_watcher_notify(dict, lp-&gt;ll_newkey, lp-&gt;ll_tv, NULL);</a>
<a name="ln1852">      } else {</a>
<a name="ln1853">        dictitem_T *di_ = lp-&gt;ll_di;</a>
<a name="ln1854">        assert(di_-&gt;di_key != NULL);</a>
<a name="ln1855">        tv_dict_watcher_notify(dict, di_-&gt;di_key, lp-&gt;ll_tv, &amp;oldtv);</a>
<a name="ln1856">        tv_clear(&amp;oldtv);</a>
<a name="ln1857">      }</a>
<a name="ln1858">    }</a>
<a name="ln1859">  }</a>
<a name="ln1860">}</a>
<a name="ln1861"> </a>
<a name="ln1862">/// Evaluate the expression used in a &quot;:for var in expr&quot; command.</a>
<a name="ln1863">/// &quot;arg&quot; points to &quot;var&quot;.</a>
<a name="ln1864">///</a>
<a name="ln1865">/// @param[out] *errp  set to true for an error, false otherwise;</a>
<a name="ln1866">///</a>
<a name="ln1867">/// @return  a pointer that holds the info.  Null when there is an error.</a>
<a name="ln1868">void *eval_for_line(const char *arg, bool *errp, exarg_T *eap, evalarg_T *const evalarg)</a>
<a name="ln1869">{</a>
<a name="ln1870">  forinfo_T *fi = xcalloc(1, sizeof(forinfo_T));</a>
<a name="ln1871">  const char *expr;</a>
<a name="ln1872">  typval_T tv;</a>
<a name="ln1873">  list_T *l;</a>
<a name="ln1874">  const bool skip = !(evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln1875"> </a>
<a name="ln1876">  *errp = true;  // Default: there is an error.</a>
<a name="ln1877"> </a>
<a name="ln1878">  expr = skip_var_list(arg, &amp;fi-&gt;fi_varcount, &amp;fi-&gt;fi_semicolon);</a>
<a name="ln1879">  if (expr == NULL) {</a>
<a name="ln1880">    return fi;</a>
<a name="ln1881">  }</a>
<a name="ln1882"> </a>
<a name="ln1883">  expr = skipwhite(expr);</a>
<a name="ln1884">  if (expr[0] != 'i' || expr[1] != 'n'</a>
<a name="ln1885">      || !(expr[2] == NUL || ascii_iswhite(expr[2]))) {</a>
<a name="ln1886">    emsg(_(&quot;E690: Missing \&quot;in\&quot; after :for&quot;));</a>
<a name="ln1887">    return fi;</a>
<a name="ln1888">  }</a>
<a name="ln1889"> </a>
<a name="ln1890">  if (skip) {</a>
<a name="ln1891">    emsg_skip++;</a>
<a name="ln1892">  }</a>
<a name="ln1893">  expr = skipwhite(expr + 2);</a>
<a name="ln1894">  if (eval0((char *)expr, &amp;tv, eap, evalarg) == OK) {</a>
<a name="ln1895">    *errp = false;</a>
<a name="ln1896">    if (!skip) {</a>
<a name="ln1897">      if (tv.v_type == VAR_LIST) {</a>
<a name="ln1898">        l = tv.vval.v_list;</a>
<a name="ln1899">        if (l == NULL) {</a>
<a name="ln1900">          // a null list is like an empty list: do nothing</a>
<a name="ln1901">          tv_clear(&amp;tv);</a>
<a name="ln1902">        } else {</a>
<a name="ln1903">          // No need to increment the refcount, it's already set for</a>
<a name="ln1904">          // the list being used in &quot;tv&quot;.</a>
<a name="ln1905">          fi-&gt;fi_list = l;</a>
<a name="ln1906">          tv_list_watch_add(l, &amp;fi-&gt;fi_lw);</a>
<a name="ln1907">          fi-&gt;fi_lw.lw_item = tv_list_first(l);</a>
<a name="ln1908">        }</a>
<a name="ln1909">      } else if (tv.v_type == VAR_BLOB) {</a>
<a name="ln1910">        fi-&gt;fi_bi = 0;</a>
<a name="ln1911">        if (tv.vval.v_blob != NULL) {</a>
<a name="ln1912">          typval_T btv;</a>
<a name="ln1913"> </a>
<a name="ln1914">          // Make a copy, so that the iteration still works when the</a>
<a name="ln1915">          // blob is changed.</a>
<a name="ln1916">          tv_blob_copy(tv.vval.v_blob, &amp;btv);</a>
<a name="ln1917">          fi-&gt;fi_blob = btv.vval.v_blob;</a>
<a name="ln1918">        }</a>
<a name="ln1919">        tv_clear(&amp;tv);</a>
<a name="ln1920">      } else if (tv.v_type == VAR_STRING) {</a>
<a name="ln1921">        fi-&gt;fi_byte_idx = 0;</a>
<a name="ln1922">        fi-&gt;fi_string = tv.vval.v_string;</a>
<a name="ln1923">        tv.vval.v_string = NULL;</a>
<a name="ln1924">        if (fi-&gt;fi_string == NULL) {</a>
<a name="ln1925">          fi-&gt;fi_string = xstrdup(&quot;&quot;);</a>
<a name="ln1926">        }</a>
<a name="ln1927">      } else {</a>
<a name="ln1928">        emsg(_(e_string_list_or_blob_required));</a>
<a name="ln1929">        tv_clear(&amp;tv);</a>
<a name="ln1930">      }</a>
<a name="ln1931">    }</a>
<a name="ln1932">  }</a>
<a name="ln1933">  if (skip) {</a>
<a name="ln1934">    emsg_skip--;</a>
<a name="ln1935">  }</a>
<a name="ln1936"> </a>
<a name="ln1937">  return fi;</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">/// Use the first item in a &quot;:for&quot; list.  Advance to the next.</a>
<a name="ln1941">/// Assign the values to the variable (list).  &quot;arg&quot; points to the first one.</a>
<a name="ln1942">///</a>
<a name="ln1943">/// @return  true when a valid item was found, false when at end of list or</a>
<a name="ln1944">///          something wrong.</a>
<a name="ln1945">bool next_for_item(void *fi_void, char *arg)</a>
<a name="ln1946">{</a>
<a name="ln1947">  forinfo_T *fi = (forinfo_T *)fi_void;</a>
<a name="ln1948"> </a>
<a name="ln1949">  if (fi-&gt;fi_blob != NULL) {</a>
<a name="ln1950">    if (fi-&gt;fi_bi &gt;= tv_blob_len(fi-&gt;fi_blob)) {</a>
<a name="ln1951">      return false;</a>
<a name="ln1952">    }</a>
<a name="ln1953">    typval_T tv;</a>
<a name="ln1954">    tv.v_type = VAR_NUMBER;</a>
<a name="ln1955">    tv.v_lock = VAR_FIXED;</a>
<a name="ln1956">    tv.vval.v_number = tv_blob_get(fi-&gt;fi_blob, fi-&gt;fi_bi);</a>
<a name="ln1957">    fi-&gt;fi_bi++;</a>
<a name="ln1958">    return ex_let_vars(arg, &amp;tv, true, fi-&gt;fi_semicolon, fi-&gt;fi_varcount, false, NULL) == OK;</a>
<a name="ln1959">  }</a>
<a name="ln1960"> </a>
<a name="ln1961">  if (fi-&gt;fi_string != NULL) {</a>
<a name="ln1962">    const int len = utfc_ptr2len(fi-&gt;fi_string + fi-&gt;fi_byte_idx);</a>
<a name="ln1963">    if (len == 0) {</a>
<a name="ln1964">      return false;</a>
<a name="ln1965">    }</a>
<a name="ln1966">    typval_T tv;</a>
<a name="ln1967">    tv.v_type = VAR_STRING;</a>
<a name="ln1968">    tv.v_lock = VAR_FIXED;</a>
<a name="ln1969">    tv.vval.v_string = xmemdupz(fi-&gt;fi_string + fi-&gt;fi_byte_idx, (size_t)len);</a>
<a name="ln1970">    fi-&gt;fi_byte_idx += len;</a>
<a name="ln1971">    const int result</a>
<a name="ln1972">      = ex_let_vars(arg, &amp;tv, true, fi-&gt;fi_semicolon, fi-&gt;fi_varcount, false, NULL) == OK;</a>
<a name="ln1973">    xfree(tv.vval.v_string);</a>
<a name="ln1974">    return result;</a>
<a name="ln1975">  }</a>
<a name="ln1976"> </a>
<a name="ln1977">  listitem_T *item = fi-&gt;fi_lw.lw_item;</a>
<a name="ln1978">  if (item == NULL) {</a>
<a name="ln1979">    return false;</a>
<a name="ln1980">  }</a>
<a name="ln1981">  fi-&gt;fi_lw.lw_item = TV_LIST_ITEM_NEXT(fi-&gt;fi_list, item);</a>
<a name="ln1982">  return (ex_let_vars(arg, TV_LIST_ITEM_TV(item), true,</a>
<a name="ln1983">                      fi-&gt;fi_semicolon, fi-&gt;fi_varcount, false, NULL) == OK);</a>
<a name="ln1984">}</a>
<a name="ln1985"> </a>
<a name="ln1986">/// Free the structure used to store info used by &quot;:for&quot;.</a>
<a name="ln1987">void free_for_info(void *fi_void)</a>
<a name="ln1988">{</a>
<a name="ln1989">  forinfo_T *fi = (forinfo_T *)fi_void;</a>
<a name="ln1990"> </a>
<a name="ln1991">  if (fi == NULL) {</a>
<a name="ln1992">    return;</a>
<a name="ln1993">  }</a>
<a name="ln1994">  if (fi-&gt;fi_list != NULL) {</a>
<a name="ln1995">    tv_list_watch_remove(fi-&gt;fi_list, &amp;fi-&gt;fi_lw);</a>
<a name="ln1996">    tv_list_unref(fi-&gt;fi_list);</a>
<a name="ln1997">  } else if (fi-&gt;fi_blob != NULL) {</a>
<a name="ln1998">    tv_blob_unref(fi-&gt;fi_blob);</a>
<a name="ln1999">  } else {</a>
<a name="ln2000">    xfree(fi-&gt;fi_string);</a>
<a name="ln2001">  }</a>
<a name="ln2002">  xfree(fi);</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">void set_context_for_expression(expand_T *xp, char *arg, cmdidx_T cmdidx)</a>
<a name="ln2006">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2007">{</a>
<a name="ln2008">  bool got_eq = false;</a>
<a name="ln2009">  char *p;</a>
<a name="ln2010"> </a>
<a name="ln2011">  if (cmdidx == CMD_let || cmdidx == CMD_const) {</a>
<a name="ln2012">    xp-&gt;xp_context = EXPAND_USER_VARS;</a>
<a name="ln2013">    if (strpbrk(arg, &quot;\&quot;'+-*/%.=!?~|&amp;$([&lt;&gt;,#&quot;) == NULL) {</a>
<a name="ln2014">      // &quot;:let var1 var2 ...&quot;: find last space.</a>
<a name="ln2015">      for (p = arg + strlen(arg); p &gt;= arg;) {</a>
<a name="ln2016">        xp-&gt;xp_pattern = p;</a>
<a name="ln2017">        MB_PTR_BACK(arg, p);</a>
<a name="ln2018">        if (ascii_iswhite(*p)) {</a>
<a name="ln2019">          break;</a>
<a name="ln2020">        }</a>
<a name="ln2021">      }</a>
<a name="ln2022">      return;</a>
<a name="ln2023">    }</a>
<a name="ln2024">  } else {</a>
<a name="ln2025">    xp-&gt;xp_context = cmdidx == CMD_call ? EXPAND_FUNCTIONS</a>
<a name="ln2026">                                        : EXPAND_EXPRESSION;</a>
<a name="ln2027">  }</a>
<a name="ln2028">  while ((xp-&gt;xp_pattern = strpbrk(arg, &quot;\&quot;'+-*/%.=!?~|&amp;$([&lt;&gt;,#&quot;)) != NULL) {</a>
<a name="ln2029">    int c = (uint8_t)(*xp-&gt;xp_pattern);</a>
<a name="ln2030">    if (c == '&amp;') {</a>
<a name="ln2031">      c = (uint8_t)xp-&gt;xp_pattern[1];</a>
<a name="ln2032">      if (c == '&amp;') {</a>
<a name="ln2033">        xp-&gt;xp_pattern++;</a>
<a name="ln2034">        xp-&gt;xp_context = cmdidx != CMD_let || got_eq</a>
<a name="ln2035">                         ? EXPAND_EXPRESSION : EXPAND_NOTHING;</a>
<a name="ln2036">      } else if (c != ' ') {</a>
<a name="ln2037">        xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln2038">        if ((c == 'l' || c == 'g') &amp;&amp; xp-&gt;xp_pattern[2] == ':') {</a>
<a name="ln2039">          xp-&gt;xp_pattern += 2;</a>
<a name="ln2040">        }</a>
<a name="ln2041">      }</a>
<a name="ln2042">    } else if (c == '$') {</a>
<a name="ln2043">      // environment variable</a>
<a name="ln2044">      xp-&gt;xp_context = EXPAND_ENV_VARS;</a>
<a name="ln2045">    } else if (c == '=') {</a>
<a name="ln2046">      got_eq = true;</a>
<a name="ln2047">      xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2048">    } else if (c == '#'</a>
<a name="ln2049">               &amp;&amp; xp-&gt;xp_context == EXPAND_EXPRESSION) {</a>
<a name="ln2050">      // Autoload function/variable contains '#'</a>
<a name="ln2051">      break;</a>
<a name="ln2052">    } else if ((c == '&lt;' || c == '#')</a>
<a name="ln2053">               &amp;&amp; xp-&gt;xp_context == EXPAND_FUNCTIONS</a>
<a name="ln2054">               &amp;&amp; vim_strchr(xp-&gt;xp_pattern, '(') == NULL) {</a>
<a name="ln2055">      // Function name can start with &quot;&lt;SNR&gt;&quot; and contain '#'.</a>
<a name="ln2056">      break;</a>
<a name="ln2057">    } else if (cmdidx != CMD_let || got_eq) {</a>
<a name="ln2058">      if (c == '&quot;') {               // string</a>
<a name="ln2059">        while ((c = (uint8_t)(*++xp-&gt;xp_pattern)) != NUL &amp;&amp; c != '&quot;') {</a>
<a name="ln2060">          if (c == '\\' &amp;&amp; xp-&gt;xp_pattern[1] != NUL) {</a>
<a name="ln2061">            xp-&gt;xp_pattern++;</a>
<a name="ln2062">          }</a>
<a name="ln2063">        }</a>
<a name="ln2064">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2065">      } else if (c == '\'') {     // literal string</a>
<a name="ln2066">        // Trick: '' is like stopping and starting a literal string.</a>
<a name="ln2067">        while ((c = (uint8_t)(*++xp-&gt;xp_pattern)) != NUL &amp;&amp; c != '\'') {}</a>
<a name="ln2068">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln2069">      } else if (c == '|') {</a>
<a name="ln2070">        if (xp-&gt;xp_pattern[1] == '|') {</a>
<a name="ln2071">          xp-&gt;xp_pattern++;</a>
<a name="ln2072">          xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2073">        } else {</a>
<a name="ln2074">          xp-&gt;xp_context = EXPAND_COMMANDS;</a>
<a name="ln2075">        }</a>
<a name="ln2076">      } else {</a>
<a name="ln2077">        xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2078">      }</a>
<a name="ln2079">    } else {</a>
<a name="ln2080">      // Doesn't look like something valid, expand as an expression</a>
<a name="ln2081">      // anyway.</a>
<a name="ln2082">      xp-&gt;xp_context = EXPAND_EXPRESSION;</a>
<a name="ln2083">    }</a>
<a name="ln2084">    arg = xp-&gt;xp_pattern;</a>
<a name="ln2085">    if (*arg != NUL) {</a>
<a name="ln2086">      while ((c = (uint8_t)(*++arg)) != NUL &amp;&amp; (c == ' ' || c == '\t')) {}</a>
<a name="ln2087">    }</a>
<a name="ln2088">  }</a>
<a name="ln2089"> </a>
<a name="ln2090">  // &quot;:exe one two&quot; completes &quot;two&quot;</a>
<a name="ln2091">  if ((cmdidx == CMD_execute</a>
<a name="ln2092">       || cmdidx == CMD_echo</a>
<a name="ln2093">       || cmdidx == CMD_echon</a>
<a name="ln2094">       || cmdidx == CMD_echomsg)</a>
<a name="ln2095">      &amp;&amp; xp-&gt;xp_context == EXPAND_EXPRESSION) {</a>
<a name="ln2096">    while (true) {</a>
<a name="ln2097">      char *const n = skiptowhite(arg);</a>
<a name="ln2098"> </a>
<a name="ln2099">      if (n == arg || ascii_iswhite_or_nul(*skipwhite(n))) {</a>
<a name="ln2100">        break;</a>
<a name="ln2101">      }</a>
<a name="ln2102">      arg = skipwhite(n);</a>
<a name="ln2103">    }</a>
<a name="ln2104">  }</a>
<a name="ln2105"> </a>
<a name="ln2106">  xp-&gt;xp_pattern = arg;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">/// Delete all &quot;menutrans_&quot; variables.</a>
<a name="ln2110">void del_menutrans_vars(void)</a>
<a name="ln2111">{</a>
<a name="ln2112">  hash_lock(&amp;globvarht);</a>
<a name="ln2113">  HASHTAB_ITER(&amp;globvarht, hi, {</a>
<a name="ln2114">    if (strncmp(hi-&gt;hi_key, &quot;menutrans_&quot;, 10) == 0) {</a>
<a name="ln2115">      delete_var(&amp;globvarht, hi);</a>
<a name="ln2116">    }</a>
<a name="ln2117">  });</a>
<a name="ln2118">  hash_unlock(&amp;globvarht);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">/// Local string buffer for the next two functions to store a variable name</a>
<a name="ln2122">/// with its prefix. Allocated in cat_prefix_varname(), freed later in</a>
<a name="ln2123">/// get_user_var_name().</a>
<a name="ln2124"> </a>
<a name="ln2125">static char *varnamebuf = NULL;</a>
<a name="ln2126">static size_t varnamebuflen = 0;</a>
<a name="ln2127"> </a>
<a name="ln2128">/// Function to concatenate a prefix and a variable name.</a>
<a name="ln2129">char *cat_prefix_varname(int prefix, const char *name)</a>
<a name="ln2130">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2131">{</a>
<a name="ln2132">  size_t len = strlen(name) + 3;</a>
<a name="ln2133"> </a>
<a name="ln2134">  if (len &gt; varnamebuflen) {</a>
<a name="ln2135">    xfree(varnamebuf);</a>
<a name="ln2136">    len += 10;                          // some additional space</a>
<a name="ln2137">    varnamebuf = xmalloc(len);</a>
<a name="ln2138">    varnamebuflen = len;</a>
<a name="ln2139">  }</a>
<a name="ln2140">  *varnamebuf = (char)prefix;</a>
<a name="ln2141">  varnamebuf[1] = ':';</a>
<a name="ln2142">  STRCPY(varnamebuf + 2, name);</a>
<a name="ln2143">  return varnamebuf;</a>
<a name="ln2144">}</a>
<a name="ln2145"> </a>
<a name="ln2146">/// Function given to ExpandGeneric() to obtain the list of user defined</a>
<a name="ln2147">/// (global/buffer/window/built-in) variable names.</a>
<a name="ln2148">char *get_user_var_name(expand_T *xp, int idx)</a>
<a name="ln2149">{</a>
<a name="ln2150">  static size_t gdone;</a>
<a name="ln2151">  static size_t bdone;</a>
<a name="ln2152">  static size_t wdone;</a>
<a name="ln2153">  static size_t tdone;</a>
<a name="ln2154">  static size_t vidx;</a>
<a name="ln2155">  static hashitem_T *hi;</a>
<a name="ln2156"> </a>
<a name="ln2157">  if (idx == 0) {</a>
<a name="ln2158">    gdone = bdone = wdone = vidx = 0;</a>
<a name="ln2159">    tdone = 0;</a>
<a name="ln2160">  }</a>
<a name="ln2161"> </a>
<a name="ln2162">  // Global variables</a>
<a name="ln2163">  if (gdone &lt; globvarht.ht_used) {</a>
<a name="ln2164">    if (gdone++ == 0) {</a>
<a name="ln2165">      hi = globvarht.ht_array;</a>
<a name="ln2166">    } else {</a>
<a name="ln2167">      hi++;</a>
<a name="ln2168">    }</a>
<a name="ln2169">    while (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2170">      hi++;</a>
<a name="ln2171">    }</a>
<a name="ln2172">    if (strncmp(&quot;g:&quot;, xp-&gt;xp_pattern, 2) == 0) {</a>
<a name="ln2173">      return cat_prefix_varname('g', hi-&gt;hi_key);</a>
<a name="ln2174">    }</a>
<a name="ln2175">    return hi-&gt;hi_key;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  // b: variables</a>
<a name="ln2179">  const hashtab_T *ht = &amp;prevwin_curwin()-&gt;w_buffer-&gt;b_vars-&gt;dv_hashtab;</a>
<a name="ln2180">  if (bdone &lt; ht-&gt;ht_used) {</a>
<a name="ln2181">    if (bdone++ == 0) {</a>
<a name="ln2182">      hi = ht-&gt;ht_array;</a>
<a name="ln2183">    } else {</a>
<a name="ln2184">      hi++;</a>
<a name="ln2185">    }</a>
<a name="ln2186">    while (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2187">      hi++;</a>
<a name="ln2188">    }</a>
<a name="ln2189">    return cat_prefix_varname('b', hi-&gt;hi_key);</a>
<a name="ln2190">  }</a>
<a name="ln2191"> </a>
<a name="ln2192">  // w: variables</a>
<a name="ln2193">  ht = &amp;prevwin_curwin()-&gt;w_vars-&gt;dv_hashtab;</a>
<a name="ln2194">  if (wdone &lt; ht-&gt;ht_used) {</a>
<a name="ln2195">    if (wdone++ == 0) {</a>
<a name="ln2196">      hi = ht-&gt;ht_array;</a>
<a name="ln2197">    } else {</a>
<a name="ln2198">      hi++;</a>
<a name="ln2199">    }</a>
<a name="ln2200">    while (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2201">      hi++;</a>
<a name="ln2202">    }</a>
<a name="ln2203">    return cat_prefix_varname('w', hi-&gt;hi_key);</a>
<a name="ln2204">  }</a>
<a name="ln2205"> </a>
<a name="ln2206">  // t: variables</a>
<a name="ln2207">  ht = &amp;curtab-&gt;tp_vars-&gt;dv_hashtab;</a>
<a name="ln2208">  if (tdone &lt; ht-&gt;ht_used) {</a>
<a name="ln2209">    if (tdone++ == 0) {</a>
<a name="ln2210">      hi = ht-&gt;ht_array;</a>
<a name="ln2211">    } else {</a>
<a name="ln2212">      hi++;</a>
<a name="ln2213">    }</a>
<a name="ln2214">    while (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2215">      hi++;</a>
<a name="ln2216">    }</a>
<a name="ln2217">    return cat_prefix_varname('t', hi-&gt;hi_key);</a>
<a name="ln2218">  }</a>
<a name="ln2219"> </a>
<a name="ln2220">  // v: variables</a>
<a name="ln2221">  if (vidx &lt; ARRAY_SIZE(vimvars)) {</a>
<a name="ln2222">    return cat_prefix_varname('v', vimvars[vidx++].vv_name);</a>
<a name="ln2223">  }</a>
<a name="ln2224"> </a>
<a name="ln2225">  XFREE_CLEAR(varnamebuf);</a>
<a name="ln2226">  varnamebuflen = 0;</a>
<a name="ln2227">  return NULL;</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230">/// Does not use 'cpo' and always uses 'magic'.</a>
<a name="ln2231">///</a>
<a name="ln2232">/// @return  true if &quot;pat&quot; matches &quot;text&quot;.</a>
<a name="ln2233">int pattern_match(const char *pat, const char *text, bool ic)</a>
<a name="ln2234">{</a>
<a name="ln2235">  int matches = 0;</a>
<a name="ln2236">  regmatch_T regmatch;</a>
<a name="ln2237"> </a>
<a name="ln2238">  // avoid 'l' flag in 'cpoptions'</a>
<a name="ln2239">  char *save_cpo = p_cpo;</a>
<a name="ln2240">  p_cpo = empty_string_option;</a>
<a name="ln2241">  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln2242">  if (regmatch.regprog != NULL) {</a>
<a name="ln2243">    regmatch.rm_ic = ic;</a>
<a name="ln2244">    matches = vim_regexec_nl(&amp;regmatch, text, 0);</a>
<a name="ln2245">    vim_regfree(regmatch.regprog);</a>
<a name="ln2246">  }</a>
<a name="ln2247">  p_cpo = save_cpo;</a>
<a name="ln2248">  return matches;</a>
<a name="ln2249">}</a>
<a name="ln2250"> </a>
<a name="ln2251">/// Handle a name followed by &quot;(&quot;.  Both for just &quot;name(arg)&quot; and for</a>
<a name="ln2252">/// &quot;expr-&gt;name(arg)&quot;.</a>
<a name="ln2253">///</a>
<a name="ln2254">/// @param arg  Points to &quot;(&quot;, will be advanced</a>
<a name="ln2255">/// @param basetv  &quot;expr&quot; for &quot;expr-&gt;name(arg)&quot;</a>
<a name="ln2256">///</a>
<a name="ln2257">/// @return OK or FAIL.</a>
<a name="ln2258">static int eval_func(char **const arg, evalarg_T *const evalarg, char *const name,</a>
<a name="ln2259">                     const int name_len, typval_T *const rettv, const int flags,</a>
<a name="ln2260">                     typval_T *const basetv)</a>
<a name="ln2261">  FUNC_ATTR_NONNULL_ARG(1, 3, 5)</a>
<a name="ln2262">{</a>
<a name="ln2263">  const bool evaluate = flags &amp; EVAL_EVALUATE;</a>
<a name="ln2264">  char *s = name;</a>
<a name="ln2265">  int len = name_len;</a>
<a name="ln2266">  bool found_var = false;</a>
<a name="ln2267"> </a>
<a name="ln2268">  if (!evaluate) {</a>
<a name="ln2269">    check_vars(s, (size_t)len);</a>
<a name="ln2270">  }</a>
<a name="ln2271"> </a>
<a name="ln2272">  // If &quot;s&quot; is the name of a variable of type VAR_FUNC</a>
<a name="ln2273">  // use its contents.</a>
<a name="ln2274">  partial_T *partial;</a>
<a name="ln2275">  s = deref_func_name(s, &amp;len, &amp;partial, !evaluate, &amp;found_var);</a>
<a name="ln2276"> </a>
<a name="ln2277">  // Need to make a copy, in case evaluating the arguments makes</a>
<a name="ln2278">  // the name invalid.</a>
<a name="ln2279">  s = xmemdupz(s, (size_t)len);</a>
<a name="ln2280"> </a>
<a name="ln2281">  // Invoke the function.</a>
<a name="ln2282">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln2283">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2284">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2285">  funcexe.fe_evaluate = evaluate;</a>
<a name="ln2286">  funcexe.fe_partial = partial;</a>
<a name="ln2287">  funcexe.fe_basetv = basetv;</a>
<a name="ln2288">  funcexe.fe_found_var = found_var;</a>
<a name="ln2289">  int ret = get_func_tv(s, len, rettv, arg, evalarg, &amp;funcexe);</a>
<a name="ln2290"> </a>
<a name="ln2291">  xfree(s);</a>
<a name="ln2292"> </a>
<a name="ln2293">  // If evaluate is false rettv-&gt;v_type was not set in</a>
<a name="ln2294">  // get_func_tv, but it's needed in handle_subscript() to parse</a>
<a name="ln2295">  // what follows. So set it here.</a>
<a name="ln2296">  if (rettv-&gt;v_type == VAR_UNKNOWN &amp;&amp; !evaluate &amp;&amp; **arg == '(') {</a>
<a name="ln2297">    rettv-&gt;vval.v_string = (char *)tv_empty_string;</a>
<a name="ln2298">    rettv-&gt;v_type = VAR_FUNC;</a>
<a name="ln2299">  }</a>
<a name="ln2300"> </a>
<a name="ln2301">  // Stop the expression evaluation when immediately</a>
<a name="ln2302">  // aborting on error, or when an interrupt occurred or</a>
<a name="ln2303">  // an exception was thrown but not caught.</a>
<a name="ln2304">  if (evaluate &amp;&amp; aborting()) {</a>
<a name="ln2305">    if (ret == OK) {</a>
<a name="ln2306">      tv_clear(rettv);</a>
<a name="ln2307">    }</a>
<a name="ln2308">    ret = FAIL;</a>
<a name="ln2309">  }</a>
<a name="ln2310">  return ret;</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">/// After using &quot;evalarg&quot; filled from &quot;eap&quot;: free the memory.</a>
<a name="ln2314">void clear_evalarg(evalarg_T *evalarg, exarg_T *eap)</a>
<a name="ln2315">{</a>
<a name="ln2316">  if (evalarg != NULL) {</a>
<a name="ln2317">    if (evalarg-&gt;eval_tofree != NULL) {</a>
<a name="ln2318">      if (eap != NULL) {</a>
<a name="ln2319">        // We may need to keep the original command line, e.g. for</a>
<a name="ln2320">        // &quot;:let&quot; it has the variable names.  But we may also need the</a>
<a name="ln2321">        // new one, &quot;nextcmd&quot; points into it.  Keep both.</a>
<a name="ln2322">        xfree(eap-&gt;cmdline_tofree);</a>
<a name="ln2323">        eap-&gt;cmdline_tofree = *eap-&gt;cmdlinep;</a>
<a name="ln2324">        *eap-&gt;cmdlinep = evalarg-&gt;eval_tofree;</a>
<a name="ln2325">      } else {</a>
<a name="ln2326">        xfree(evalarg-&gt;eval_tofree);</a>
<a name="ln2327">      }</a>
<a name="ln2328">      evalarg-&gt;eval_tofree = NULL;</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331">}</a>
<a name="ln2332"> </a>
<a name="ln2333">/// The &quot;evaluate&quot; argument: When false, the argument is only parsed but not</a>
<a name="ln2334">/// executed.  The function may return OK, but the rettv will be of type</a>
<a name="ln2335">/// VAR_UNKNOWN.  The function still returns FAIL for a syntax error.</a>
<a name="ln2336"> </a>
<a name="ln2337">/// Handle zero level expression.</a>
<a name="ln2338">/// This calls eval1() and handles error message and nextcmd.</a>
<a name="ln2339">/// Put the result in &quot;rettv&quot; when returning OK and &quot;evaluate&quot; is true.</a>
<a name="ln2340">/// Note: &quot;rettv.v_lock&quot; is not set.</a>
<a name="ln2341">///</a>
<a name="ln2342">/// @param evalarg  can be NULL, &amp;EVALARG_EVALUATE or a pointer.</a>
<a name="ln2343">///</a>
<a name="ln2344">/// @return OK or FAIL.</a>
<a name="ln2345">int eval0(char *arg, typval_T *rettv, exarg_T *eap, evalarg_T *const evalarg)</a>
<a name="ln2346">{</a>
<a name="ln2347">  int ret;</a>
<a name="ln2348">  char *p;</a>
<a name="ln2349">  const int did_emsg_before = did_emsg;</a>
<a name="ln2350">  const int called_emsg_before = called_emsg;</a>
<a name="ln2351">  bool end_error = false;</a>
<a name="ln2352"> </a>
<a name="ln2353">  p = skipwhite(arg);</a>
<a name="ln2354">  ret = eval1(&amp;p, rettv, evalarg);</a>
<a name="ln2355"> </a>
<a name="ln2356">  if (ret != FAIL) {</a>
<a name="ln2357">    end_error = !ends_excmd(*p);</a>
<a name="ln2358">  }</a>
<a name="ln2359">  if (ret == FAIL || end_error) {</a>
<a name="ln2360">    if (ret != FAIL) {</a>
<a name="ln2361">      tv_clear(rettv);</a>
<a name="ln2362">    }</a>
<a name="ln2363">    // Report the invalid expression unless the expression evaluation has</a>
<a name="ln2364">    // been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln2365">    // exception, or we already gave a more specific error.</a>
<a name="ln2366">    // Also check called_emsg for when using assert_fails().</a>
<a name="ln2367">    if (!aborting()</a>
<a name="ln2368">        &amp;&amp; did_emsg == did_emsg_before</a>
<a name="ln2369">        &amp;&amp; called_emsg == called_emsg_before) {</a>
<a name="ln2370">      if (end_error) {</a>
<a name="ln2371">        semsg(_(e_trailing_arg), p);</a>
<a name="ln2372">      } else {</a>
<a name="ln2373">        semsg(_(e_invexpr2), arg);</a>
<a name="ln2374">      }</a>
<a name="ln2375">    }</a>
<a name="ln2376"> </a>
<a name="ln2377">    if (eap != NULL &amp;&amp; p != NULL) {</a>
<a name="ln2378">      // Some of the expression may not have been consumed.</a>
<a name="ln2379">      // Only execute a next command if it cannot be a &quot;||&quot; operator.</a>
<a name="ln2380">      // The next command may be &quot;catch&quot;.</a>
<a name="ln2381">      char *nextcmd = check_nextcmd(p);</a>
<a name="ln2382">      if (nextcmd != NULL &amp;&amp; *nextcmd != '|') {</a>
<a name="ln2383">        eap-&gt;nextcmd = nextcmd;</a>
<a name="ln2384">      }</a>
<a name="ln2385">    }</a>
<a name="ln2386">    return FAIL;</a>
<a name="ln2387">  }</a>
<a name="ln2388"> </a>
<a name="ln2389">  if (eap != NULL) {</a>
<a name="ln2390">    eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln2391">  }</a>
<a name="ln2392"> </a>
<a name="ln2393">  return ret;</a>
<a name="ln2394">}</a>
<a name="ln2395"> </a>
<a name="ln2396">/// Handle top level expression:</a>
<a name="ln2397">///      expr2 ? expr1 : expr1</a>
<a name="ln2398">///      expr2 ?? expr1</a>
<a name="ln2399">///</a>
<a name="ln2400">/// &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln2401">/// &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln2402">///</a>
<a name="ln2403">/// Note: &quot;rettv.v_lock&quot; is not set.</a>
<a name="ln2404">///</a>
<a name="ln2405">/// @return  OK or FAIL.</a>
<a name="ln2406">int eval1(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln2407">{</a>
<a name="ln2408">  // Get the first variable.</a>
<a name="ln2409">  if (eval2(arg, rettv, evalarg) == FAIL) {</a>
<a name="ln2410">    return FAIL;</a>
<a name="ln2411">  }</a>
<a name="ln2412"> </a>
<a name="ln2413">  char *p = *arg;</a>
<a name="ln2414">  if (*p == '?') {</a>
<a name="ln2415">    const bool op_falsy = p[1] == '?';</a>
<a name="ln2416">    evalarg_T *evalarg_used = evalarg;</a>
<a name="ln2417">    evalarg_T local_evalarg;</a>
<a name="ln2418">    if (evalarg == NULL) {</a>
<a name="ln2419">      local_evalarg = (evalarg_T){ .eval_flags = 0 };</a>
<a name="ln2420">      evalarg_used = &amp;local_evalarg;</a>
<a name="ln2421">    }</a>
<a name="ln2422">    const int orig_flags = evalarg_used-&gt;eval_flags;</a>
<a name="ln2423">    const bool evaluate = evalarg_used-&gt;eval_flags &amp; EVAL_EVALUATE;</a>
<a name="ln2424"> </a>
<a name="ln2425">    bool result = false;</a>
<a name="ln2426">    if (evaluate) {</a>
<a name="ln2427">      bool error = false;</a>
<a name="ln2428"> </a>
<a name="ln2429">      if (op_falsy) {</a>
<a name="ln2430">        result = tv2bool(rettv);</a>
<a name="ln2431">      } else if (tv_get_number_chk(rettv, &amp;error) != 0) {</a>
<a name="ln2432">        result = true;</a>
<a name="ln2433">      }</a>
<a name="ln2434">      if (error || !op_falsy || !result) {</a>
<a name="ln2435">        tv_clear(rettv);</a>
<a name="ln2436">      }</a>
<a name="ln2437">      if (error) {</a>
<a name="ln2438">        return FAIL;</a>
<a name="ln2439">      }</a>
<a name="ln2440">    }</a>
<a name="ln2441"> </a>
<a name="ln2442">    // Get the second variable.  Recursive!</a>
<a name="ln2443">    if (op_falsy) {</a>
<a name="ln2444">      (*arg)++;</a>
<a name="ln2445">    }</a>
<a name="ln2446">    *arg = skipwhite(*arg + 1);</a>
<a name="ln2447">    evalarg_used-&gt;eval_flags = (op_falsy ? !result : result)</a>
<a name="ln2448">                                  ? orig_flags : (orig_flags &amp; ~EVAL_EVALUATE);</a>
<a name="ln2449">    typval_T var2;</a>
<a name="ln2450">    if (eval1(arg, &amp;var2, evalarg_used) == FAIL) {</a>
<a name="ln2451">      evalarg_used-&gt;eval_flags = orig_flags;</a>
<a name="ln2452">      return FAIL;</a>
<a name="ln2453">    }</a>
<a name="ln2454">    if (!op_falsy || !result) {</a>
<a name="ln2455">      *rettv = var2;</a>
<a name="ln2456">    }</a>
<a name="ln2457"> </a>
<a name="ln2458">    if (!op_falsy) {</a>
<a name="ln2459">      // Check for the &quot;:&quot;.</a>
<a name="ln2460">      p = *arg;</a>
<a name="ln2461">      if (*p != ':') {</a>
<a name="ln2462">        emsg(_(&quot;E109: Missing ':' after '?'&quot;));</a>
<a name="ln2463">        if (evaluate &amp;&amp; result) {</a>
<a name="ln2464">          tv_clear(rettv);</a>
<a name="ln2465">        }</a>
<a name="ln2466">        evalarg_used-&gt;eval_flags = orig_flags;</a>
<a name="ln2467">        return FAIL;</a>
<a name="ln2468">      }</a>
<a name="ln2469"> </a>
<a name="ln2470">      // Get the third variable.  Recursive!</a>
<a name="ln2471">      *arg = skipwhite(*arg + 1);</a>
<a name="ln2472">      evalarg_used-&gt;eval_flags = !result ? orig_flags : (orig_flags &amp; ~EVAL_EVALUATE);</a>
<a name="ln2473">      if (eval1(arg, &amp;var2, evalarg_used) == FAIL) {</a>
<a name="ln2474">        if (evaluate &amp;&amp; result) {</a>
<a name="ln2475">          tv_clear(rettv);</a>
<a name="ln2476">        }</a>
<a name="ln2477">        evalarg_used-&gt;eval_flags = orig_flags;</a>
<a name="ln2478">        return FAIL;</a>
<a name="ln2479">      }</a>
<a name="ln2480">      if (evaluate &amp;&amp; !result) {</a>
<a name="ln2481">        *rettv = var2;</a>
<a name="ln2482">      }</a>
<a name="ln2483">    }</a>
<a name="ln2484"> </a>
<a name="ln2485">    if (evalarg == NULL) {</a>
<a name="ln2486">      clear_evalarg(&amp;local_evalarg, NULL);</a>
<a name="ln2487">    } else {</a>
<a name="ln2488">      evalarg-&gt;eval_flags = orig_flags;</a>
<a name="ln2489">    }</a>
<a name="ln2490">  }</a>
<a name="ln2491"> </a>
<a name="ln2492">  return OK;</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495">/// Handle first level expression:</a>
<a name="ln2496">///      expr2 || expr2 || expr2     logical OR</a>
<a name="ln2497">///</a>
<a name="ln2498">/// &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln2499">/// &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln2500">///</a>
<a name="ln2501">/// @return  OK or FAIL.</a>
<a name="ln2502">static int eval2(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln2503">{</a>
<a name="ln2504">  // Get the first variable.</a>
<a name="ln2505">  if (eval3(arg, rettv, evalarg) == FAIL) {</a>
<a name="ln2506">    return FAIL;</a>
<a name="ln2507">  }</a>
<a name="ln2508"> </a>
<a name="ln2509">  // Handle the  &quot;||&quot; operator.</a>
<a name="ln2510">  char *p = *arg;</a>
<a name="ln2511">  if (p[0] == '|' &amp;&amp; p[1] == '|') {</a>
<a name="ln2512">    evalarg_T *evalarg_used = evalarg;</a>
<a name="ln2513">    evalarg_T local_evalarg;</a>
<a name="ln2514">    if (evalarg == NULL) {</a>
<a name="ln2515">      local_evalarg = (evalarg_T){ .eval_flags = 0 };</a>
<a name="ln2516">      evalarg_used = &amp;local_evalarg;</a>
<a name="ln2517">    }</a>
<a name="ln2518">    const int orig_flags = evalarg_used-&gt;eval_flags;</a>
<a name="ln2519">    const bool evaluate = evalarg_used-&gt;eval_flags &amp; EVAL_EVALUATE;</a>
<a name="ln2520"> </a>
<a name="ln2521">    bool result = false;</a>
<a name="ln2522"> </a>
<a name="ln2523">    if (evaluate) {</a>
<a name="ln2524">      bool error = false;</a>
<a name="ln2525">      if (tv_get_number_chk(rettv, &amp;error) != 0) {</a>
<a name="ln2526">        result = true;</a>
<a name="ln2527">      }</a>
<a name="ln2528">      tv_clear(rettv);</a>
<a name="ln2529">      if (error) {</a>
<a name="ln2530">        return FAIL;</a>
<a name="ln2531">      }</a>
<a name="ln2532">    }</a>
<a name="ln2533"> </a>
<a name="ln2534">    // Repeat until there is no following &quot;||&quot;.</a>
<a name="ln2535">    while (p[0] == '|' &amp;&amp; p[1] == '|') {</a>
<a name="ln2536">      // Get the second variable.</a>
<a name="ln2537">      *arg = skipwhite(*arg + 2);</a>
<a name="ln2538">      evalarg_used-&gt;eval_flags = !result ? orig_flags : (orig_flags &amp; ~EVAL_EVALUATE);</a>
<a name="ln2539">      typval_T var2;</a>
<a name="ln2540">      if (eval3(arg, &amp;var2, evalarg_used) == FAIL) {</a>
<a name="ln2541">        return FAIL;</a>
<a name="ln2542">      }</a>
<a name="ln2543"> </a>
<a name="ln2544">      // Compute the result.</a>
<a name="ln2545">      if (evaluate &amp;&amp; !result) {</a>
<a name="ln2546">        bool error = false;</a>
<a name="ln2547">        if (tv_get_number_chk(&amp;var2, &amp;error) != 0) {</a>
<a name="ln2548">          result = true;</a>
<a name="ln2549">        }</a>
<a name="ln2550">        tv_clear(&amp;var2);</a>
<a name="ln2551">        if (error) {</a>
<a name="ln2552">          return FAIL;</a>
<a name="ln2553">        }</a>
<a name="ln2554">      }</a>
<a name="ln2555">      if (evaluate) {</a>
<a name="ln2556">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln2557">        rettv-&gt;vval.v_number = result;</a>
<a name="ln2558">      }</a>
<a name="ln2559"> </a>
<a name="ln2560">      p = *arg;</a>
<a name="ln2561">    }</a>
<a name="ln2562"> </a>
<a name="ln2563">    if (evalarg == NULL) {</a>
<a name="ln2564">      clear_evalarg(&amp;local_evalarg, NULL);</a>
<a name="ln2565">    } else {</a>
<a name="ln2566">      evalarg-&gt;eval_flags = orig_flags;</a>
<a name="ln2567">    }</a>
<a name="ln2568">  }</a>
<a name="ln2569"> </a>
<a name="ln2570">  return OK;</a>
<a name="ln2571">}</a>
<a name="ln2572"> </a>
<a name="ln2573">/// Handle second level expression:</a>
<a name="ln2574">///      expr3 &amp;&amp; expr3 &amp;&amp; expr3     logical AND</a>
<a name="ln2575">///</a>
<a name="ln2576">/// @param arg  must point to the first non-white of the expression.</a>
<a name="ln2577">///             `arg` is advanced to the next non-white after the recognized expression.</a>
<a name="ln2578">///</a>
<a name="ln2579">/// @return  OK or FAIL.</a>
<a name="ln2580">static int eval3(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln2581">{</a>
<a name="ln2582">  // Get the first variable.</a>
<a name="ln2583">  if (eval4(arg, rettv, evalarg) == FAIL) {</a>
<a name="ln2584">    return FAIL;</a>
<a name="ln2585">  }</a>
<a name="ln2586"> </a>
<a name="ln2587">  char *p = *arg;</a>
<a name="ln2588">  // Handle the &quot;&amp;&amp;&quot; operator.</a>
<a name="ln2589">  if (p[0] == '&amp;' &amp;&amp; p[1] == '&amp;') {</a>
<a name="ln2590">    evalarg_T *evalarg_used = evalarg;</a>
<a name="ln2591">    evalarg_T local_evalarg;</a>
<a name="ln2592">    if (evalarg == NULL) {</a>
<a name="ln2593">      local_evalarg = (evalarg_T){ .eval_flags = 0 };</a>
<a name="ln2594">      evalarg_used = &amp;local_evalarg;</a>
<a name="ln2595">    }</a>
<a name="ln2596">    const int orig_flags = evalarg_used-&gt;eval_flags;</a>
<a name="ln2597">    const bool evaluate = evalarg_used-&gt;eval_flags &amp; EVAL_EVALUATE;</a>
<a name="ln2598"> </a>
<a name="ln2599">    bool result = true;</a>
<a name="ln2600"> </a>
<a name="ln2601">    if (evaluate) {</a>
<a name="ln2602">      bool error = false;</a>
<a name="ln2603">      if (tv_get_number_chk(rettv, &amp;error) == 0) {</a>
<a name="ln2604">        result = false;</a>
<a name="ln2605">      }</a>
<a name="ln2606">      tv_clear(rettv);</a>
<a name="ln2607">      if (error) {</a>
<a name="ln2608">        return FAIL;</a>
<a name="ln2609">      }</a>
<a name="ln2610">    }</a>
<a name="ln2611"> </a>
<a name="ln2612">    // Repeat until there is no following &quot;&amp;&amp;&quot;.</a>
<a name="ln2613">    while (p[0] == '&amp;' &amp;&amp; p[1] == '&amp;') {</a>
<a name="ln2614">      // Get the second variable.</a>
<a name="ln2615">      *arg = skipwhite(*arg + 2);</a>
<a name="ln2616">      evalarg_used-&gt;eval_flags = result ? orig_flags : (orig_flags &amp; ~EVAL_EVALUATE);</a>
<a name="ln2617">      typval_T var2;</a>
<a name="ln2618">      if (eval4(arg, &amp;var2, evalarg_used) == FAIL) {</a>
<a name="ln2619">        return FAIL;</a>
<a name="ln2620">      }</a>
<a name="ln2621"> </a>
<a name="ln2622">      // Compute the result.</a>
<a name="ln2623">      if (evaluate &amp;&amp; result) {</a>
<a name="ln2624">        bool error = false;</a>
<a name="ln2625">        if (tv_get_number_chk(&amp;var2, &amp;error) == 0) {</a>
<a name="ln2626">          result = false;</a>
<a name="ln2627">        }</a>
<a name="ln2628">        tv_clear(&amp;var2);</a>
<a name="ln2629">        if (error) {</a>
<a name="ln2630">          return FAIL;</a>
<a name="ln2631">        }</a>
<a name="ln2632">      }</a>
<a name="ln2633">      if (evaluate) {</a>
<a name="ln2634">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln2635">        rettv-&gt;vval.v_number = result;</a>
<a name="ln2636">      }</a>
<a name="ln2637"> </a>
<a name="ln2638">      p = *arg;</a>
<a name="ln2639">    }</a>
<a name="ln2640"> </a>
<a name="ln2641">    if (evalarg == NULL) {</a>
<a name="ln2642">      clear_evalarg(&amp;local_evalarg, NULL);</a>
<a name="ln2643">    } else {</a>
<a name="ln2644">      evalarg-&gt;eval_flags = orig_flags;</a>
<a name="ln2645">    }</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  return OK;</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">/// Handle third level expression:</a>
<a name="ln2652">///      var1 == var2</a>
<a name="ln2653">///      var1 =~ var2</a>
<a name="ln2654">///      var1 != var2</a>
<a name="ln2655">///      var1 !~ var2</a>
<a name="ln2656">///      var1 &gt; var2</a>
<a name="ln2657">///      var1 &gt;= var2</a>
<a name="ln2658">///      var1 &lt; var2</a>
<a name="ln2659">///      var1 &lt;= var2</a>
<a name="ln2660">///      var1 is var2</a>
<a name="ln2661">///      var1 isnot var2</a>
<a name="ln2662">///</a>
<a name="ln2663">/// &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln2664">/// &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln2665">///</a>
<a name="ln2666">/// @return  OK or FAIL.</a>
<a name="ln2667">static int eval4(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln2668">{</a>
<a name="ln2669">  typval_T var2;</a>
<a name="ln2670">  exprtype_T type = EXPR_UNKNOWN;</a>
<a name="ln2671">  int len = 2;</a>
<a name="ln2672"> </a>
<a name="ln2673">  // Get the first variable.</a>
<a name="ln2674">  if (eval5(arg, rettv, evalarg) == FAIL) {</a>
<a name="ln2675">    return FAIL;</a>
<a name="ln2676">  }</a>
<a name="ln2677"> </a>
<a name="ln2678">  char *p = *arg;</a>
<a name="ln2679">  switch (p[0]) {</a>
<a name="ln2680">  case '=':</a>
<a name="ln2681">    if (p[1] == '=') {</a>
<a name="ln2682">      type = EXPR_EQUAL;</a>
<a name="ln2683">    } else if (p[1] == '~') {</a>
<a name="ln2684">      type = EXPR_MATCH;</a>
<a name="ln2685">    }</a>
<a name="ln2686">    break;</a>
<a name="ln2687">  case '!':</a>
<a name="ln2688">    if (p[1] == '=') {</a>
<a name="ln2689">      type = EXPR_NEQUAL;</a>
<a name="ln2690">    } else if (p[1] == '~') {</a>
<a name="ln2691">      type = EXPR_NOMATCH;</a>
<a name="ln2692">    }</a>
<a name="ln2693">    break;</a>
<a name="ln2694">  case '&gt;':</a>
<a name="ln2695">    if (p[1] != '=') {</a>
<a name="ln2696">      type = EXPR_GREATER;</a>
<a name="ln2697">      len = 1;</a>
<a name="ln2698">    } else {</a>
<a name="ln2699">      type = EXPR_GEQUAL;</a>
<a name="ln2700">    }</a>
<a name="ln2701">    break;</a>
<a name="ln2702">  case '&lt;':</a>
<a name="ln2703">    if (p[1] != '=') {</a>
<a name="ln2704">      type = EXPR_SMALLER;</a>
<a name="ln2705">      len = 1;</a>
<a name="ln2706">    } else {</a>
<a name="ln2707">      type = EXPR_SEQUAL;</a>
<a name="ln2708">    }</a>
<a name="ln2709">    break;</a>
<a name="ln2710">  case 'i':</a>
<a name="ln2711">    if (p[1] == 's') {</a>
<a name="ln2712">      if (p[2] == 'n' &amp;&amp; p[3] == 'o' &amp;&amp; p[4] == 't') {</a>
<a name="ln2713">        len = 5;</a>
<a name="ln2714">      }</a>
<a name="ln2715">      if (!isalnum((uint8_t)p[len]) &amp;&amp; p[len] != '_') {</a>
<a name="ln2716">        type = len == 2 ? EXPR_IS : EXPR_ISNOT;</a>
<a name="ln2717">      }</a>
<a name="ln2718">    }</a>
<a name="ln2719">    break;</a>
<a name="ln2720">  }</a>
<a name="ln2721"> </a>
<a name="ln2722">  // If there is a comparative operator, use it.</a>
<a name="ln2723">  if (type != EXPR_UNKNOWN) {</a>
<a name="ln2724">    bool ic;</a>
<a name="ln2725">    // extra question mark appended: ignore case</a>
<a name="ln2726">    if (p[len] == '?') {</a>
<a name="ln2727">      ic = true;</a>
<a name="ln2728">      len++;</a>
<a name="ln2729">    } else if (p[len] == '#') {  // extra '#' appended: match case</a>
<a name="ln2730">      ic = false;</a>
<a name="ln2731">      len++;</a>
<a name="ln2732">    } else {  // nothing appended: use 'ignorecase'</a>
<a name="ln2733">      ic = p_ic;</a>
<a name="ln2734">    }</a>
<a name="ln2735"> </a>
<a name="ln2736">    // Get the second variable.</a>
<a name="ln2737">    *arg = skipwhite(p + len);</a>
<a name="ln2738">    if (eval5(arg, &amp;var2, evalarg) == FAIL) {</a>
<a name="ln2739">      tv_clear(rettv);</a>
<a name="ln2740">      return FAIL;</a>
<a name="ln2741">    }</a>
<a name="ln2742">    if (evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE)) {</a>
<a name="ln2743">      const int ret = typval_compare(rettv, &amp;var2, type, ic);</a>
<a name="ln2744"> </a>
<a name="ln2745">      tv_clear(&amp;var2);</a>
<a name="ln2746">      return ret;</a>
<a name="ln2747">    }</a>
<a name="ln2748">  }</a>
<a name="ln2749"> </a>
<a name="ln2750">  return OK;</a>
<a name="ln2751">}</a>
<a name="ln2752"> </a>
<a name="ln2753">/// Make a copy of blob &quot;tv1&quot; and append blob &quot;tv2&quot;.</a>
<a name="ln2754">static void eval_addblob(typval_T *tv1, typval_T *tv2)</a>
<a name="ln2755">{</a>
<a name="ln2756">  const blob_T *const b1 = tv1-&gt;vval.v_blob;</a>
<a name="ln2757">  const blob_T *const b2 = tv2-&gt;vval.v_blob;</a>
<a name="ln2758">  blob_T *const b = tv_blob_alloc();</a>
<a name="ln2759"> </a>
<a name="ln2760">  for (int i = 0; i &lt; tv_blob_len(b1); i++) {</a>
<a name="ln2761">    ga_append(&amp;b-&gt;bv_ga, tv_blob_get(b1, i));</a>
<a name="ln2762">  }</a>
<a name="ln2763">  for (int i = 0; i &lt; tv_blob_len(b2); i++) {</a>
<a name="ln2764">    ga_append(&amp;b-&gt;bv_ga, tv_blob_get(b2, i));</a>
<a name="ln2765">  }</a>
<a name="ln2766"> </a>
<a name="ln2767">  tv_clear(tv1);</a>
<a name="ln2768">  tv_blob_set_ret(tv1, b);</a>
<a name="ln2769">}</a>
<a name="ln2770"> </a>
<a name="ln2771">/// Make a copy of list &quot;tv1&quot; and append list &quot;tv2&quot;.</a>
<a name="ln2772">static int eval_addlist(typval_T *tv1, typval_T *tv2)</a>
<a name="ln2773">{</a>
<a name="ln2774">  typval_T var3;</a>
<a name="ln2775">  // Concatenate Lists.</a>
<a name="ln2776">  if (tv_list_concat(tv1-&gt;vval.v_list, tv2-&gt;vval.v_list, &amp;var3) == FAIL) {</a>
<a name="ln2777">    tv_clear(tv1);</a>
<a name="ln2778">    tv_clear(tv2);</a>
<a name="ln2779">    return FAIL;</a>
<a name="ln2780">  }</a>
<a name="ln2781">  tv_clear(tv1);</a>
<a name="ln2782">  *tv1 = var3;</a>
<a name="ln2783">  return OK;</a>
<a name="ln2784">}</a>
<a name="ln2785"> </a>
<a name="ln2786">/// Handle fourth level expression:</a>
<a name="ln2787">///      +       number addition, concatenation of list or blob</a>
<a name="ln2788">///      -       number subtraction</a>
<a name="ln2789">///      .       string concatenation</a>
<a name="ln2790">///      ..      string concatenation</a>
<a name="ln2791">///</a>
<a name="ln2792">/// @param arg  must point to the first non-white of the expression.</a>
<a name="ln2793">///             `arg` is advanced to the next non-white after the recognized expression.</a>
<a name="ln2794">///</a>
<a name="ln2795">/// @return  OK or FAIL.</a>
<a name="ln2796">static int eval5(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln2797">{</a>
<a name="ln2798">  // Get the first variable.</a>
<a name="ln2799">  if (eval6(arg, rettv, evalarg, false) == FAIL) {</a>
<a name="ln2800">    return FAIL;</a>
<a name="ln2801">  }</a>
<a name="ln2802"> </a>
<a name="ln2803">  // Repeat computing, until no '+', '-' or '.' is following.</a>
<a name="ln2804">  while (true) {</a>
<a name="ln2805">    int op = (uint8_t)(**arg);</a>
<a name="ln2806">    bool concat = op == '.';</a>
<a name="ln2807">    if (op != '+' &amp;&amp; op != '-' &amp;&amp; !concat) {</a>
<a name="ln2808">      break;</a>
<a name="ln2809">    }</a>
<a name="ln2810"> </a>
<a name="ln2811">    const bool evaluate = evalarg == NULL ? 0 : (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln2812">    if ((op != '+' || (rettv-&gt;v_type != VAR_LIST &amp;&amp; rettv-&gt;v_type != VAR_BLOB))</a>
<a name="ln2813">        &amp;&amp; (op == '.' || rettv-&gt;v_type != VAR_FLOAT) &amp;&amp; evaluate) {</a>
<a name="ln2814">      // For &quot;list + ...&quot;, an illegal use of the first operand as</a>
<a name="ln2815">      // a number cannot be determined before evaluating the 2nd</a>
<a name="ln2816">      // operand: if this is also a list, all is ok.</a>
<a name="ln2817">      // For &quot;something . ...&quot;, &quot;something - ...&quot; or &quot;non-list + ...&quot;,</a>
<a name="ln2818">      // we know that the first operand needs to be a string or number</a>
<a name="ln2819">      // without evaluating the 2nd operand.  So check before to avoid</a>
<a name="ln2820">      // side effects after an error.</a>
<a name="ln2821">      if ((op == '.' &amp;&amp; !tv_check_str(rettv)) || (op != '.' &amp;&amp; !tv_check_num(rettv))) {</a>
<a name="ln2822">        tv_clear(rettv);</a>
<a name="ln2823">        return FAIL;</a>
<a name="ln2824">      }</a>
<a name="ln2825">    }</a>
<a name="ln2826"> </a>
<a name="ln2827">    // Get the second variable.</a>
<a name="ln2828">    if (op == '.' &amp;&amp; *(*arg + 1) == '.') {  // ..string concatenation</a>
<a name="ln2829">      (*arg)++;</a>
<a name="ln2830">    }</a>
<a name="ln2831">    *arg = skipwhite(*arg + 1);</a>
<a name="ln2832">    typval_T var2;</a>
<a name="ln2833">    if (eval6(arg, &amp;var2, evalarg, op == '.') == FAIL) {</a>
<a name="ln2834">      tv_clear(rettv);</a>
<a name="ln2835">      return FAIL;</a>
<a name="ln2836">    }</a>
<a name="ln2837"> </a>
<a name="ln2838">    if (evaluate) {</a>
<a name="ln2839">      // Compute the result.</a>
<a name="ln2840">      if (op == '.') {</a>
<a name="ln2841">        char buf1[NUMBUFLEN];</a>
<a name="ln2842">        char buf2[NUMBUFLEN];</a>
<a name="ln2843">        // s1 already checked</a>
<a name="ln2844">        const char *const s1 = tv_get_string_buf(rettv, buf1);</a>
<a name="ln2845">        const char *const s2 = tv_get_string_buf_chk(&amp;var2, buf2);</a>
<a name="ln2846">        if (s2 == NULL) {  // Type error?</a>
<a name="ln2847">          tv_clear(rettv);</a>
<a name="ln2848">          tv_clear(&amp;var2);</a>
<a name="ln2849">          return FAIL;</a>
<a name="ln2850">        }</a>
<a name="ln2851">        char *p = concat_str(s1, s2);</a>
<a name="ln2852">        tv_clear(rettv);</a>
<a name="ln2853">        rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2854">        rettv-&gt;vval.v_string = p;</a>
<a name="ln2855">      } else if (op == '+' &amp;&amp; rettv-&gt;v_type == VAR_BLOB &amp;&amp; var2.v_type == VAR_BLOB) {</a>
<a name="ln2856">        eval_addblob(rettv, &amp;var2);</a>
<a name="ln2857">      } else if (op == '+' &amp;&amp; rettv-&gt;v_type == VAR_LIST &amp;&amp; var2.v_type == VAR_LIST) {</a>
<a name="ln2858">        if (eval_addlist(rettv, &amp;var2) == FAIL) {</a>
<a name="ln2859">          return FAIL;</a>
<a name="ln2860">        }</a>
<a name="ln2861">      } else {</a>
<a name="ln2862">        bool error = false;</a>
<a name="ln2863">        varnumber_T n1, n2;</a>
<a name="ln2864">        float_T f1 = 0, f2 = 0;</a>
<a name="ln2865"> </a>
<a name="ln2866">        if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln2867">          f1 = rettv-&gt;vval.v_float;</a>
<a name="ln2868">          n1 = 0;</a>
<a name="ln2869">        } else {</a>
<a name="ln2870">          n1 = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln2871">          if (error) {</a>
<a name="ln2872">            // This can only happen for &quot;list + non-list&quot; or</a>
<a name="ln2873">            // &quot;blob + non-blob&quot;.  For &quot;non-list + ...&quot; or</a>
<a name="ln2874">            // &quot;something - ...&quot;, we returned before evaluating the</a>
<a name="ln2875">            // 2nd operand.</a>
<a name="ln2876">            tv_clear(rettv);</a>
<a name="ln2877">            tv_clear(&amp;var2);</a>
<a name="ln2878">            return FAIL;</a>
<a name="ln2879">          }</a>
<a name="ln2880">          if (var2.v_type == VAR_FLOAT) {</a>
<a name="ln2881">            f1 = (float_T)n1;</a>
<a name="ln2882">          }</a>
<a name="ln2883">        }</a>
<a name="ln2884">        if (var2.v_type == VAR_FLOAT) {</a>
<a name="ln2885">          f2 = var2.vval.v_float;</a>
<a name="ln2886">          n2 = 0;</a>
<a name="ln2887">        } else {</a>
<a name="ln2888">          n2 = tv_get_number_chk(&amp;var2, &amp;error);</a>
<a name="ln2889">          if (error) {</a>
<a name="ln2890">            tv_clear(rettv);</a>
<a name="ln2891">            tv_clear(&amp;var2);</a>
<a name="ln2892">            return FAIL;</a>
<a name="ln2893">          }</a>
<a name="ln2894">          if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln2895">            f2 = (float_T)n2;</a>
<a name="ln2896">          }</a>
<a name="ln2897">        }</a>
<a name="ln2898">        tv_clear(rettv);</a>
<a name="ln2899"> </a>
<a name="ln2900">        // If there is a float on either side the result is a float.</a>
<a name="ln2901">        if (rettv-&gt;v_type == VAR_FLOAT || var2.v_type == VAR_FLOAT) {</a>
<a name="ln2902">          if (op == '+') {</a>
<a name="ln2903">            f1 = f1 + f2;</a>
<a name="ln2904">          } else {</a>
<a name="ln2905">            f1 = f1 - f2;</a>
<a name="ln2906">          }</a>
<a name="ln2907">          rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln2908">          rettv-&gt;vval.v_float = f1;</a>
<a name="ln2909">        } else {</a>
<a name="ln2910">          if (op == '+') {</a>
<a name="ln2911">            n1 = n1 + n2;</a>
<a name="ln2912">          } else {</a>
<a name="ln2913">            n1 = n1 - n2;</a>
<a name="ln2914">          }</a>
<a name="ln2915">          rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln2916">          rettv-&gt;vval.v_number = n1;</a>
<a name="ln2917">        }</a>
<a name="ln2918">      }</a>
<a name="ln2919">      tv_clear(&amp;var2);</a>
<a name="ln2920">    }</a>
<a name="ln2921">  }</a>
<a name="ln2922">  return OK;</a>
<a name="ln2923">}</a>
<a name="ln2924"> </a>
<a name="ln2925">/// Handle fifth level expression:</a>
<a name="ln2926">///  - *  number multiplication</a>
<a name="ln2927">///  - /  number division</a>
<a name="ln2928">///  - %  number modulo</a>
<a name="ln2929">///</a>
<a name="ln2930">/// @param[in,out]  arg  Points to the first non-whitespace character of the</a>
<a name="ln2931">///                      expression.  Is advanced to the next non-whitespace</a>
<a name="ln2932">///                      character after the recognized expression.</a>
<a name="ln2933">/// @param[out]  rettv  Location where result is saved.</a>
<a name="ln2934">/// @param[in]  want_string  True if &quot;.&quot; is string_concatenation, otherwise</a>
<a name="ln2935">///                          float</a>
<a name="ln2936">/// @return  OK or FAIL.</a>
<a name="ln2937">static int eval6(char **arg, typval_T *rettv, evalarg_T *const evalarg, bool want_string)</a>
<a name="ln2938">  FUNC_ATTR_NO_SANITIZE_UNDEFINED</a>
<a name="ln2939">{</a>
<a name="ln2940">  bool use_float = false;</a>
<a name="ln2941"> </a>
<a name="ln2942">  // Get the first variable.</a>
<a name="ln2943">  if (eval7(arg, rettv, evalarg, want_string) == FAIL) {</a>
<a name="ln2944">    return FAIL;</a>
<a name="ln2945">  }</a>
<a name="ln2946"> </a>
<a name="ln2947">  // Repeat computing, until no '*', '/' or '%' is following.</a>
<a name="ln2948">  while (true) {</a>
<a name="ln2949">    int op = (uint8_t)(**arg);</a>
<a name="ln2950">    if (op != '*' &amp;&amp; op != '/' &amp;&amp; op != '%') {</a>
<a name="ln2951">      break;</a>
<a name="ln2952">    }</a>
<a name="ln2953"> </a>
<a name="ln2954">    varnumber_T n1, n2;</a>
<a name="ln2955">    float_T f1 = 0, f2 = 0;</a>
<a name="ln2956">    bool error = false;</a>
<a name="ln2957">    const bool evaluate = evalarg == NULL ? 0 : (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln2958">    if (evaluate) {</a>
<a name="ln2959">      if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln2960">        f1 = rettv-&gt;vval.v_float;</a>
<a name="ln2961">        use_float = true;</a>
<a name="ln2962">        n1 = 0;</a>
<a name="ln2963">      } else {</a>
<a name="ln2964">        n1 = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln2965">      }</a>
<a name="ln2966">      tv_clear(rettv);</a>
<a name="ln2967">      if (error) {</a>
<a name="ln2968">        return FAIL;</a>
<a name="ln2969">      }</a>
<a name="ln2970">    } else {</a>
<a name="ln2971">      n1 = 0;</a>
<a name="ln2972">    }</a>
<a name="ln2973"> </a>
<a name="ln2974">    // Get the second variable.</a>
<a name="ln2975">    *arg = skipwhite(*arg + 1);</a>
<a name="ln2976">    typval_T var2;</a>
<a name="ln2977">    if (eval7(arg, &amp;var2, evalarg, false) == FAIL) {</a>
<a name="ln2978">      return FAIL;</a>
<a name="ln2979">    }</a>
<a name="ln2980"> </a>
<a name="ln2981">    if (evaluate) {</a>
<a name="ln2982">      if (var2.v_type == VAR_FLOAT) {</a>
<a name="ln2983">        if (!use_float) {</a>
<a name="ln2984">          f1 = (float_T)n1;</a>
<a name="ln2985">          use_float = true;</a>
<a name="ln2986">        }</a>
<a name="ln2987">        f2 = var2.vval.v_float;</a>
<a name="ln2988">        n2 = 0;</a>
<a name="ln2989">      } else {</a>
<a name="ln2990">        n2 = tv_get_number_chk(&amp;var2, &amp;error);</a>
<a name="ln2991">        tv_clear(&amp;var2);</a>
<a name="ln2992">        if (error) {</a>
<a name="ln2993">          return FAIL;</a>
<a name="ln2994">        }</a>
<a name="ln2995">        if (use_float) {</a>
<a name="ln2996">          f2 = (float_T)n2;</a>
<a name="ln2997">        }</a>
<a name="ln2998">      }</a>
<a name="ln2999"> </a>
<a name="ln3000">      // Compute the result.</a>
<a name="ln3001">      // When either side is a float the result is a float.</a>
<a name="ln3002">      if (use_float) {</a>
<a name="ln3003">        if (op == '*') {</a>
<a name="ln3004">          f1 = f1 * f2;</a>
<a name="ln3005">        } else if (op == '/') {</a>
<a name="ln3006">          // uncrustify:off</a>
<a name="ln3007"> </a>
<a name="ln3008">          // Division by zero triggers error from AddressSanitizer</a>
<a name="ln3009">          f1 = (f2 == 0 ? (</a>
<a name="ln3010">#ifdef NAN</a>
<a name="ln3011">              f1 == 0 ? (float_T)NAN :</a>
<a name="ln3012">#endif</a>
<a name="ln3013">              (f1 &gt; 0 ? (float_T)INFINITY : (float_T)-INFINITY)) : f1 / f2);</a>
<a name="ln3014"> </a>
<a name="ln3015">          // uncrustify:on</a>
<a name="ln3016">        } else {</a>
<a name="ln3017">          emsg(_(&quot;E804: Cannot use '%' with Float&quot;));</a>
<a name="ln3018">          return FAIL;</a>
<a name="ln3019">        }</a>
<a name="ln3020">        rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln3021">        rettv-&gt;vval.v_float = f1;</a>
<a name="ln3022">      } else {</a>
<a name="ln3023">        if (op == '*') {</a>
<a name="ln3024">          n1 = n1 * n2;</a>
<a name="ln3025">        } else if (op == '/') {</a>
<a name="ln3026">          n1 = num_divide(n1, n2);</a>
<a name="ln3027">        } else {</a>
<a name="ln3028">          n1 = num_modulus(n1, n2);</a>
<a name="ln3029">        }</a>
<a name="ln3030">        rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3031">        rettv-&gt;vval.v_number = n1;</a>
<a name="ln3032">      }</a>
<a name="ln3033">    }</a>
<a name="ln3034">  }</a>
<a name="ln3035"> </a>
<a name="ln3036">  return OK;</a>
<a name="ln3037">}</a>
<a name="ln3038"> </a>
<a name="ln3039">/// Handle sixth level expression:</a>
<a name="ln3040">///  number  number constant</a>
<a name="ln3041">///  0zFFFFFFFF  Blob constant</a>
<a name="ln3042">///  &quot;string&quot;  string constant</a>
<a name="ln3043">///  'string'  literal string constant</a>
<a name="ln3044">///  &amp;option-name option value</a>
<a name="ln3045">///  @r   register contents</a>
<a name="ln3046">///  identifier  variable value</a>
<a name="ln3047">///  function()  function call</a>
<a name="ln3048">///  $VAR  environment variable</a>
<a name="ln3049">///  (expression) nested expression</a>
<a name="ln3050">///  [expr, expr] List</a>
<a name="ln3051">///  {key: val, key: val}  Dictionary</a>
<a name="ln3052">///  #{key: val, key: val}  Dictionary with literal keys</a>
<a name="ln3053">///</a>
<a name="ln3054">///  Also handle:</a>
<a name="ln3055">///  ! in front  logical NOT</a>
<a name="ln3056">///  - in front  unary minus</a>
<a name="ln3057">///  + in front  unary plus (ignored)</a>
<a name="ln3058">///  trailing []  subscript in String or List</a>
<a name="ln3059">///  trailing .name entry in Dictionary</a>
<a name="ln3060">///  trailing -&gt;name()  method call</a>
<a name="ln3061">///</a>
<a name="ln3062">/// &quot;arg&quot; must point to the first non-white of the expression.</a>
<a name="ln3063">/// &quot;arg&quot; is advanced to the next non-white after the recognized expression.</a>
<a name="ln3064">///</a>
<a name="ln3065">/// @param want_string  after &quot;.&quot; operator</a>
<a name="ln3066">///</a>
<a name="ln3067">/// @return  OK or FAIL.</a>
<a name="ln3068">static int eval7(char **arg, typval_T *rettv, evalarg_T *const evalarg, bool want_string)</a>
<a name="ln3069">{</a>
<a name="ln3070">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln3071">  int ret = OK;</a>
<a name="ln3072">  static int recurse = 0;</a>
<a name="ln3073"> </a>
<a name="ln3074">  // Initialise variable so that tv_clear() can't mistake this for a</a>
<a name="ln3075">  // string and free a string that isn't there.</a>
<a name="ln3076">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln3077"> </a>
<a name="ln3078">  // Skip '!', '-' and '+' characters.  They are handled later.</a>
<a name="ln3079">  const char *start_leader = *arg;</a>
<a name="ln3080">  while (**arg == '!' || **arg == '-' || **arg == '+') {</a>
<a name="ln3081">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3082">  }</a>
<a name="ln3083">  const char *end_leader = *arg;</a>
<a name="ln3084"> </a>
<a name="ln3085">  // Limit recursion to 1000 levels.  At least at 10000 we run out of stack</a>
<a name="ln3086">  // and crash.  With MSVC the stack is smaller.</a>
<a name="ln3087">  if (recurse ==</a>
<a name="ln3088">#ifdef _MSC_VER</a>
<a name="ln3089">      300</a>
<a name="ln3090">#else</a>
<a name="ln3091">      1000</a>
<a name="ln3092">#endif</a>
<a name="ln3093">      ) {</a>
<a name="ln3094">    semsg(_(e_expression_too_recursive_str), *arg);</a>
<a name="ln3095">    return FAIL;</a>
<a name="ln3096">  }</a>
<a name="ln3097">  recurse++;</a>
<a name="ln3098"> </a>
<a name="ln3099">  switch (**arg) {</a>
<a name="ln3100">  // Number constant.</a>
<a name="ln3101">  case '0':</a>
<a name="ln3102">  case '1':</a>
<a name="ln3103">  case '2':</a>
<a name="ln3104">  case '3':</a>
<a name="ln3105">  case '4':</a>
<a name="ln3106">  case '5':</a>
<a name="ln3107">  case '6':</a>
<a name="ln3108">  case '7':</a>
<a name="ln3109">  case '8':</a>
<a name="ln3110">  case '9':</a>
<a name="ln3111">    ret = eval_number(arg, rettv, evaluate, want_string);</a>
<a name="ln3112"> </a>
<a name="ln3113">    // Apply prefixed &quot;-&quot; and &quot;+&quot; now.  Matters especially when</a>
<a name="ln3114">    // &quot;-&gt;&quot; follows.</a>
<a name="ln3115">    if (ret == OK &amp;&amp; evaluate &amp;&amp; end_leader &gt; start_leader) {</a>
<a name="ln3116">      ret = eval7_leader(rettv, true, start_leader, &amp;end_leader);</a>
<a name="ln3117">    }</a>
<a name="ln3118">    break;</a>
<a name="ln3119"> </a>
<a name="ln3120">  // String constant: &quot;string&quot;.</a>
<a name="ln3121">  case '&quot;':</a>
<a name="ln3122">    ret = eval_string(arg, rettv, evaluate, false);</a>
<a name="ln3123">    break;</a>
<a name="ln3124"> </a>
<a name="ln3125">  // Literal string constant: 'str''ing'.</a>
<a name="ln3126">  case '\'':</a>
<a name="ln3127">    ret = eval_lit_string(arg, rettv, evaluate, false);</a>
<a name="ln3128">    break;</a>
<a name="ln3129"> </a>
<a name="ln3130">  // List: [expr, expr]</a>
<a name="ln3131">  case '[':</a>
<a name="ln3132">    ret = eval_list(arg, rettv, evalarg);</a>
<a name="ln3133">    break;</a>
<a name="ln3134"> </a>
<a name="ln3135">  // Dictionary: #{key: val, key: val}</a>
<a name="ln3136">  case '#':</a>
<a name="ln3137">    if ((*arg)[1] == '{') {</a>
<a name="ln3138">      (*arg)++;</a>
<a name="ln3139">      ret = eval_dict(arg, rettv, evalarg, true);</a>
<a name="ln3140">    } else {</a>
<a name="ln3141">      ret = NOTDONE;</a>
<a name="ln3142">    }</a>
<a name="ln3143">    break;</a>
<a name="ln3144"> </a>
<a name="ln3145">  // Lambda: {arg, arg -&gt; expr}</a>
<a name="ln3146">  // Dictionary: {'key': val, 'key': val}</a>
<a name="ln3147">  case '{':</a>
<a name="ln3148">    ret = get_lambda_tv(arg, rettv, evalarg);</a>
<a name="ln3149">    if (ret == NOTDONE) {</a>
<a name="ln3150">      ret = eval_dict(arg, rettv, evalarg, false);</a>
<a name="ln3151">    }</a>
<a name="ln3152">    break;</a>
<a name="ln3153"> </a>
<a name="ln3154">  // Option value: &amp;name</a>
<a name="ln3155">  case '&amp;':</a>
<a name="ln3156">    ret = eval_option((const char **)arg, rettv, evaluate);</a>
<a name="ln3157">    break;</a>
<a name="ln3158">  // Environment variable: $VAR.</a>
<a name="ln3159">  // Interpolated string: $&quot;string&quot; or $'string'.</a>
<a name="ln3160">  case '$':</a>
<a name="ln3161">    if ((*arg)[1] == '&quot;' || (*arg)[1] == '\'') {</a>
<a name="ln3162">      ret = eval_interp_string(arg, rettv, evaluate);</a>
<a name="ln3163">    } else {</a>
<a name="ln3164">      ret = eval_env_var(arg, rettv, evaluate);</a>
<a name="ln3165">    }</a>
<a name="ln3166">    break;</a>
<a name="ln3167"> </a>
<a name="ln3168">  // Register contents: @r.</a>
<a name="ln3169">  case '@':</a>
<a name="ln3170">    (*arg)++;</a>
<a name="ln3171">    if (evaluate) {</a>
<a name="ln3172">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3173">      rettv-&gt;vval.v_string = get_reg_contents(**arg, kGRegExprSrc);</a>
<a name="ln3174">    }</a>
<a name="ln3175">    if (**arg != NUL) {</a>
<a name="ln3176">      (*arg)++;</a>
<a name="ln3177">    }</a>
<a name="ln3178">    break;</a>
<a name="ln3179"> </a>
<a name="ln3180">  // nested expression: (expression).</a>
<a name="ln3181">  case '(':</a>
<a name="ln3182">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3183"> </a>
<a name="ln3184">    ret = eval1(arg, rettv, evalarg);  // recursive!</a>
<a name="ln3185">    if (**arg == ')') {</a>
<a name="ln3186">      (*arg)++;</a>
<a name="ln3187">    } else if (ret == OK) {</a>
<a name="ln3188">      emsg(_(&quot;E110: Missing ')'&quot;));</a>
<a name="ln3189">      tv_clear(rettv);</a>
<a name="ln3190">      ret = FAIL;</a>
<a name="ln3191">    }</a>
<a name="ln3192">    break;</a>
<a name="ln3193"> </a>
<a name="ln3194">  default:</a>
<a name="ln3195">    ret = NOTDONE;</a>
<a name="ln3196">    break;</a>
<a name="ln3197">  }</a>
<a name="ln3198"> </a>
<a name="ln3199">  if (ret == NOTDONE) {</a>
<a name="ln3200">    // Must be a variable or function name.</a>
<a name="ln3201">    // Can also be a curly-braces kind of name: {expr}.</a>
<a name="ln3202">    char *s = *arg;</a>
<a name="ln3203">    char *alias;</a>
<a name="ln3204">    int len = get_name_len((const char **)arg, &amp;alias, evaluate, true);</a>
<a name="ln3205">    if (alias != NULL) {</a>
<a name="ln3206">      s = alias;</a>
<a name="ln3207">    }</a>
<a name="ln3208"> </a>
<a name="ln3209">    if (len &lt;= 0) {</a>
<a name="ln3210">      ret = FAIL;</a>
<a name="ln3211">    } else {</a>
<a name="ln3212">      const int flags = evalarg == NULL ? 0 : evalarg-&gt;eval_flags;</a>
<a name="ln3213">      if (*skipwhite(*arg) == '(') {</a>
<a name="ln3214">        // &quot;name(...&quot;  recursive!</a>
<a name="ln3215">        *arg = skipwhite(*arg);</a>
<a name="ln3216">        ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL);</a>
<a name="ln3217">      } else if (evaluate) {</a>
<a name="ln3218">        // get value of variable</a>
<a name="ln3219">        ret = eval_variable(s, len, rettv, NULL, true, false);</a>
<a name="ln3220">      } else {</a>
<a name="ln3221">        // skip the name</a>
<a name="ln3222">        check_vars(s, (size_t)len);</a>
<a name="ln3223">        ret = OK;</a>
<a name="ln3224">      }</a>
<a name="ln3225">    }</a>
<a name="ln3226">    xfree(alias);</a>
<a name="ln3227">  }</a>
<a name="ln3228"> </a>
<a name="ln3229">  *arg = skipwhite(*arg);</a>
<a name="ln3230"> </a>
<a name="ln3231">  // Handle following '[', '(' and '.' for expr[expr], expr.name,</a>
<a name="ln3232">  // expr(expr), expr-&gt;name(expr)</a>
<a name="ln3233">  if (ret == OK) {</a>
<a name="ln3234">    ret = handle_subscript((const char **)arg, rettv, evalarg, true);</a>
<a name="ln3235">  }</a>
<a name="ln3236"> </a>
<a name="ln3237">  // Apply logical NOT and unary '-', from right to left, ignore '+'.</a>
<a name="ln3238">  if (ret == OK &amp;&amp; evaluate &amp;&amp; end_leader &gt; start_leader) {</a>
<a name="ln3239">    ret = eval7_leader(rettv, false, start_leader, &amp;end_leader);</a>
<a name="ln3240">  }</a>
<a name="ln3241"> </a>
<a name="ln3242">  recurse--;</a>
<a name="ln3243">  return ret;</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">/// Apply the leading &quot;!&quot; and &quot;-&quot; before an eval7 expression to &quot;rettv&quot;.</a>
<a name="ln3247">/// Adjusts &quot;end_leaderp&quot; until it is at &quot;start_leader&quot;.</a>
<a name="ln3248">///</a>
<a name="ln3249">/// @param numeric_only  if true only handle &quot;+&quot; and &quot;-&quot;.</a>
<a name="ln3250">///</a>
<a name="ln3251">/// @return  OK on success, FAIL on failure.</a>
<a name="ln3252">static int eval7_leader(typval_T *const rettv, const bool numeric_only,</a>
<a name="ln3253">                        const char *const start_leader, const char **const end_leaderp)</a>
<a name="ln3254">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3255">{</a>
<a name="ln3256">  const char *end_leader = *end_leaderp;</a>
<a name="ln3257">  int ret = OK;</a>
<a name="ln3258">  bool error = false;</a>
<a name="ln3259">  varnumber_T val = 0;</a>
<a name="ln3260">  float_T f = 0.0;</a>
<a name="ln3261"> </a>
<a name="ln3262">  if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3263">    f = rettv-&gt;vval.v_float;</a>
<a name="ln3264">  } else {</a>
<a name="ln3265">    val = tv_get_number_chk(rettv, &amp;error);</a>
<a name="ln3266">  }</a>
<a name="ln3267">  if (error) {</a>
<a name="ln3268">    tv_clear(rettv);</a>
<a name="ln3269">    ret = FAIL;</a>
<a name="ln3270">  } else {</a>
<a name="ln3271">    while (end_leader &gt; start_leader) {</a>
<a name="ln3272">      end_leader--;</a>
<a name="ln3273">      if (*end_leader == '!') {</a>
<a name="ln3274">        if (numeric_only) {</a>
<a name="ln3275">          end_leader++;</a>
<a name="ln3276">          break;</a>
<a name="ln3277">        }</a>
<a name="ln3278">        if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3279">          f = !(bool)f;</a>
<a name="ln3280">        } else {</a>
<a name="ln3281">          val = !val;</a>
<a name="ln3282">        }</a>
<a name="ln3283">      } else if (*end_leader == '-') {</a>
<a name="ln3284">        if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3285">          f = -f;</a>
<a name="ln3286">        } else {</a>
<a name="ln3287">          val = -val;</a>
<a name="ln3288">        }</a>
<a name="ln3289">      }</a>
<a name="ln3290">    }</a>
<a name="ln3291">    if (rettv-&gt;v_type == VAR_FLOAT) {</a>
<a name="ln3292">      tv_clear(rettv);</a>
<a name="ln3293">      rettv-&gt;vval.v_float = f;</a>
<a name="ln3294">    } else {</a>
<a name="ln3295">      tv_clear(rettv);</a>
<a name="ln3296">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3297">      rettv-&gt;vval.v_number = val;</a>
<a name="ln3298">    }</a>
<a name="ln3299">  }</a>
<a name="ln3300"> </a>
<a name="ln3301">  *end_leaderp = end_leader;</a>
<a name="ln3302">  return ret;</a>
<a name="ln3303">}</a>
<a name="ln3304"> </a>
<a name="ln3305">/// Call the function referred to in &quot;rettv&quot;.</a>
<a name="ln3306">/// @param lua_funcname  If `rettv` refers to a v:lua function, this must point</a>
<a name="ln3307">///                      to the name of the Lua function to call (after the</a>
<a name="ln3308">///                      &quot;v:lua.&quot; prefix).</a>
<a name="ln3309">/// @return  OK on success, FAIL on failure.</a>
<a name="ln3310">static int call_func_rettv(char **const arg, evalarg_T *const evalarg, typval_T *const rettv,</a>
<a name="ln3311">                           const bool evaluate, dict_T *const selfdict, typval_T *const basetv,</a>
<a name="ln3312">                           const char *const lua_funcname)</a>
<a name="ln3313">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln3314">{</a>
<a name="ln3315">  partial_T *pt = NULL;</a>
<a name="ln3316">  typval_T functv;</a>
<a name="ln3317">  const char *funcname;</a>
<a name="ln3318">  bool is_lua = false;</a>
<a name="ln3319">  int ret;</a>
<a name="ln3320"> </a>
<a name="ln3321">  // need to copy the funcref so that we can clear rettv</a>
<a name="ln3322">  if (evaluate) {</a>
<a name="ln3323">    functv = *rettv;</a>
<a name="ln3324">    rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln3325"> </a>
<a name="ln3326">    // Invoke the function.  Recursive!</a>
<a name="ln3327">    if (functv.v_type == VAR_PARTIAL) {</a>
<a name="ln3328">      pt = functv.vval.v_partial;</a>
<a name="ln3329">      is_lua = is_luafunc(pt);</a>
<a name="ln3330">      funcname = is_lua ? lua_funcname : partial_name(pt);</a>
<a name="ln3331">    } else {</a>
<a name="ln3332">      funcname = functv.vval.v_string;</a>
<a name="ln3333">      if (funcname == NULL || *funcname == NUL) {</a>
<a name="ln3334">        emsg(_(e_empty_function_name));</a>
<a name="ln3335">        ret = FAIL;</a>
<a name="ln3336">        goto theend;</a>
<a name="ln3337">      }</a>
<a name="ln3338">    }</a>
<a name="ln3339">  } else {</a>
<a name="ln3340">    funcname = &quot;&quot;;</a>
<a name="ln3341">  }</a>
<a name="ln3342"> </a>
<a name="ln3343">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln3344">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3345">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3346">  funcexe.fe_evaluate = evaluate;</a>
<a name="ln3347">  funcexe.fe_partial = pt;</a>
<a name="ln3348">  funcexe.fe_selfdict = selfdict;</a>
<a name="ln3349">  funcexe.fe_basetv = basetv;</a>
<a name="ln3350">  ret = get_func_tv(funcname, is_lua ? (int)(*arg - funcname) : -1, rettv,</a>
<a name="ln3351">                    arg, evalarg, &amp;funcexe);</a>
<a name="ln3352"> </a>
<a name="ln3353">theend:</a>
<a name="ln3354">  // Clear the funcref afterwards, so that deleting it while</a>
<a name="ln3355">  // evaluating the arguments is possible (see test55).</a>
<a name="ln3356">  if (evaluate) {</a>
<a name="ln3357">    tv_clear(&amp;functv);</a>
<a name="ln3358">  }</a>
<a name="ln3359"> </a>
<a name="ln3360">  return ret;</a>
<a name="ln3361">}</a>
<a name="ln3362"> </a>
<a name="ln3363">/// Evaluate &quot;-&gt;method()&quot;.</a>
<a name="ln3364">///</a>
<a name="ln3365">/// @param verbose  if true, give error messages.</a>
<a name="ln3366">/// @param *arg     points to the '-'.</a>
<a name="ln3367">///</a>
<a name="ln3368">/// @return  FAIL or OK.</a>
<a name="ln3369">///</a>
<a name="ln3370">/// @note &quot;*arg&quot; is advanced to after the ')'.</a>
<a name="ln3371">static int eval_lambda(char **const arg, typval_T *const rettv, evalarg_T *const evalarg,</a>
<a name="ln3372">                       const bool verbose)</a>
<a name="ln3373">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln3374">{</a>
<a name="ln3375">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln3376">  // Skip over the -&gt;.</a>
<a name="ln3377">  *arg += 2;</a>
<a name="ln3378">  typval_T base = *rettv;</a>
<a name="ln3379">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln3380"> </a>
<a name="ln3381">  int ret = get_lambda_tv(arg, rettv, evalarg);</a>
<a name="ln3382">  if (ret != OK) {</a>
<a name="ln3383">    return FAIL;</a>
<a name="ln3384">  } else if (**arg != '(') {</a>
<a name="ln3385">    if (verbose) {</a>
<a name="ln3386">      if (*skipwhite(*arg) == '(') {</a>
<a name="ln3387">        emsg(_(e_nowhitespace));</a>
<a name="ln3388">      } else {</a>
<a name="ln3389">        semsg(_(e_missingparen), &quot;lambda&quot;);</a>
<a name="ln3390">      }</a>
<a name="ln3391">    }</a>
<a name="ln3392">    tv_clear(rettv);</a>
<a name="ln3393">    ret = FAIL;</a>
<a name="ln3394">  } else {</a>
<a name="ln3395">    ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &amp;base, NULL);</a>
<a name="ln3396">  }</a>
<a name="ln3397"> </a>
<a name="ln3398">  // Clear the funcref afterwards, so that deleting it while</a>
<a name="ln3399">  // evaluating the arguments is possible (see test55).</a>
<a name="ln3400">  if (evaluate) {</a>
<a name="ln3401">    tv_clear(&amp;base);</a>
<a name="ln3402">  }</a>
<a name="ln3403"> </a>
<a name="ln3404">  return ret;</a>
<a name="ln3405">}</a>
<a name="ln3406"> </a>
<a name="ln3407">/// Evaluate &quot;-&gt;method()&quot; or &quot;-&gt;v:lua.method()&quot;.</a>
<a name="ln3408">///</a>
<a name="ln3409">/// @param *arg  points to the '-'.</a>
<a name="ln3410">///</a>
<a name="ln3411">/// @return  FAIL or OK. &quot;*arg&quot; is advanced to after the ')'.</a>
<a name="ln3412">static int eval_method(char **const arg, typval_T *const rettv, evalarg_T *const evalarg,</a>
<a name="ln3413">                       const bool verbose)</a>
<a name="ln3414">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln3415">{</a>
<a name="ln3416">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln3417"> </a>
<a name="ln3418">  // Skip over the -&gt;.</a>
<a name="ln3419">  *arg += 2;</a>
<a name="ln3420">  typval_T base = *rettv;</a>
<a name="ln3421">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln3422"> </a>
<a name="ln3423">  // Locate the method name.</a>
<a name="ln3424">  int len;</a>
<a name="ln3425">  char *name = *arg;</a>
<a name="ln3426">  char *lua_funcname = NULL;</a>
<a name="ln3427">  if (strncmp(name, &quot;v:lua.&quot;, 6) == 0) {</a>
<a name="ln3428">    lua_funcname = name + 6;</a>
<a name="ln3429">    *arg = (char *)skip_luafunc_name(lua_funcname);</a>
<a name="ln3430">    *arg = skipwhite(*arg);  // to detect trailing whitespace later</a>
<a name="ln3431">    len = (int)(*arg - lua_funcname);</a>
<a name="ln3432">  } else {</a>
<a name="ln3433">    char *alias;</a>
<a name="ln3434">    len = get_name_len((const char **)arg, &amp;alias, evaluate, true);</a>
<a name="ln3435">    if (alias != NULL) {</a>
<a name="ln3436">      name = alias;</a>
<a name="ln3437">    }</a>
<a name="ln3438">  }</a>
<a name="ln3439"> </a>
<a name="ln3440">  int ret;</a>
<a name="ln3441">  if (len &lt;= 0) {</a>
<a name="ln3442">    if (verbose) {</a>
<a name="ln3443">      if (lua_funcname == NULL) {</a>
<a name="ln3444">        emsg(_(&quot;E260: Missing name after -&gt;&quot;));</a>
<a name="ln3445">      } else {</a>
<a name="ln3446">        semsg(_(e_invexpr2), name);</a>
<a name="ln3447">      }</a>
<a name="ln3448">    }</a>
<a name="ln3449">    ret = FAIL;</a>
<a name="ln3450">  } else {</a>
<a name="ln3451">    if (**arg != '(') {</a>
<a name="ln3452">      if (verbose) {</a>
<a name="ln3453">        semsg(_(e_missingparen), name);</a>
<a name="ln3454">      }</a>
<a name="ln3455">      ret = FAIL;</a>
<a name="ln3456">    } else if (ascii_iswhite((*arg)[-1])) {</a>
<a name="ln3457">      if (verbose) {</a>
<a name="ln3458">        emsg(_(e_nowhitespace));</a>
<a name="ln3459">      }</a>
<a name="ln3460">      ret = FAIL;</a>
<a name="ln3461">    } else if (lua_funcname != NULL) {</a>
<a name="ln3462">      if (evaluate) {</a>
<a name="ln3463">        rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln3464">        rettv-&gt;vval.v_partial = vvlua_partial;</a>
<a name="ln3465">        rettv-&gt;vval.v_partial-&gt;pt_refcount++;</a>
<a name="ln3466">      }</a>
<a name="ln3467">      ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &amp;base, lua_funcname);</a>
<a name="ln3468">    } else {</a>
<a name="ln3469">      ret = eval_func(arg, evalarg, name, len, rettv, evaluate ? EVAL_EVALUATE : 0, &amp;base);</a>
<a name="ln3470">    }</a>
<a name="ln3471">  }</a>
<a name="ln3472"> </a>
<a name="ln3473">  // Clear the funcref afterwards, so that deleting it while</a>
<a name="ln3474">  // evaluating the arguments is possible (see test55).</a>
<a name="ln3475">  if (evaluate) {</a>
<a name="ln3476">    tv_clear(&amp;base);</a>
<a name="ln3477">  }</a>
<a name="ln3478"> </a>
<a name="ln3479">  return ret;</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">/// Evaluate an &quot;[expr]&quot; or &quot;[expr:expr]&quot; index.  Also &quot;dict.key&quot;.</a>
<a name="ln3483">/// &quot;*arg&quot; points to the '[' or '.'.</a>
<a name="ln3484">///</a>
<a name="ln3485">/// @param verbose  give error messages</a>
<a name="ln3486">///</a>
<a name="ln3487">/// @returns FAIL or OK. &quot;*arg&quot; is advanced to after the ']'.</a>
<a name="ln3488">static int eval_index(char **arg, typval_T *rettv, evalarg_T *const evalarg, bool verbose)</a>
<a name="ln3489">{</a>
<a name="ln3490">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln3491">  bool empty1 = false;</a>
<a name="ln3492">  bool empty2 = false;</a>
<a name="ln3493">  bool range = false;</a>
<a name="ln3494">  const char *key = NULL;</a>
<a name="ln3495">  ptrdiff_t keylen = -1;</a>
<a name="ln3496"> </a>
<a name="ln3497">  if (check_can_index(rettv, evaluate, verbose) == FAIL) {</a>
<a name="ln3498">    return FAIL;</a>
<a name="ln3499">  }</a>
<a name="ln3500"> </a>
<a name="ln3501">  typval_T var1 = TV_INITIAL_VALUE;</a>
<a name="ln3502">  typval_T var2 = TV_INITIAL_VALUE;</a>
<a name="ln3503">  if (**arg == '.') {</a>
<a name="ln3504">    // dict.name</a>
<a name="ln3505">    key = *arg + 1;</a>
<a name="ln3506">    for (keylen = 0; eval_isdictc(key[keylen]); keylen++) {}</a>
<a name="ln3507">    if (keylen == 0) {</a>
<a name="ln3508">      return FAIL;</a>
<a name="ln3509">    }</a>
<a name="ln3510">    *arg = skipwhite(key + keylen);</a>
<a name="ln3511">  } else {</a>
<a name="ln3512">    // something[idx]</a>
<a name="ln3513">    //</a>
<a name="ln3514">    // Get the (first) variable from inside the [].</a>
<a name="ln3515">    *arg = skipwhite(*arg + 1);</a>
<a name="ln3516">    if (**arg == ':') {</a>
<a name="ln3517">      empty1 = true;</a>
<a name="ln3518">    } else if (eval1(arg, &amp;var1, evalarg) == FAIL) {  // Recursive!</a>
<a name="ln3519">      return FAIL;</a>
<a name="ln3520">    } else if (evaluate &amp;&amp; !tv_check_str(&amp;var1)) {</a>
<a name="ln3521">      // Not a number or string.</a>
<a name="ln3522">      tv_clear(&amp;var1);</a>
<a name="ln3523">      return FAIL;</a>
<a name="ln3524">    }</a>
<a name="ln3525"> </a>
<a name="ln3526">    // Get the second variable from inside the [:].</a>
<a name="ln3527">    if (**arg == ':') {</a>
<a name="ln3528">      range = true;</a>
<a name="ln3529">      *arg = skipwhite(*arg + 1);</a>
<a name="ln3530">      if (**arg == ']') {</a>
<a name="ln3531">        empty2 = true;</a>
<a name="ln3532">      } else if (eval1(arg, &amp;var2, evalarg) == FAIL) {  // Recursive!</a>
<a name="ln3533">        if (!empty1) {</a>
<a name="ln3534">          tv_clear(&amp;var1);</a>
<a name="ln3535">        }</a>
<a name="ln3536">        return FAIL;</a>
<a name="ln3537">      } else if (evaluate &amp;&amp; !tv_check_str(&amp;var2)) {</a>
<a name="ln3538">        // Not a number or string.</a>
<a name="ln3539">        if (!empty1) {</a>
<a name="ln3540">          tv_clear(&amp;var1);</a>
<a name="ln3541">        }</a>
<a name="ln3542">        tv_clear(&amp;var2);</a>
<a name="ln3543">        return FAIL;</a>
<a name="ln3544">      }</a>
<a name="ln3545">    }</a>
<a name="ln3546"> </a>
<a name="ln3547">    // Check for the ']'.</a>
<a name="ln3548">    if (**arg != ']') {</a>
<a name="ln3549">      if (verbose) {</a>
<a name="ln3550">        emsg(_(e_missbrac));</a>
<a name="ln3551">      }</a>
<a name="ln3552">      tv_clear(&amp;var1);</a>
<a name="ln3553">      if (range) {</a>
<a name="ln3554">        tv_clear(&amp;var2);</a>
<a name="ln3555">      }</a>
<a name="ln3556">      return FAIL;</a>
<a name="ln3557">    }</a>
<a name="ln3558">    *arg = skipwhite(*arg + 1);         // skip the ']'</a>
<a name="ln3559">  }</a>
<a name="ln3560"> </a>
<a name="ln3561">  if (evaluate) {</a>
<a name="ln3562">    int res = eval_index_inner(rettv, range,</a>
<a name="ln3563">                               empty1 ? NULL : &amp;var1, empty2 ? NULL : &amp;var2, false,</a>
<a name="ln3564">                               key, keylen, verbose);</a>
<a name="ln3565">    if (!empty1) {</a>
<a name="ln3566">      tv_clear(&amp;var1);</a>
<a name="ln3567">    }</a>
<a name="ln3568">    if (range) {</a>
<a name="ln3569">      tv_clear(&amp;var2);</a>
<a name="ln3570">    }</a>
<a name="ln3571">    return res;</a>
<a name="ln3572">  }</a>
<a name="ln3573">  return OK;</a>
<a name="ln3574">}</a>
<a name="ln3575"> </a>
<a name="ln3576">/// Check if &quot;rettv&quot; can have an [index] or [sli:ce]</a>
<a name="ln3577">static int check_can_index(typval_T *rettv, bool evaluate, bool verbose)</a>
<a name="ln3578">{</a>
<a name="ln3579">  switch (rettv-&gt;v_type) {</a>
<a name="ln3580">  case VAR_FUNC:</a>
<a name="ln3581">  case VAR_PARTIAL:</a>
<a name="ln3582">    if (verbose) {</a>
<a name="ln3583">      emsg(_(e_cannot_index_a_funcref));</a>
<a name="ln3584">    }</a>
<a name="ln3585">    return FAIL;</a>
<a name="ln3586">  case VAR_FLOAT:</a>
<a name="ln3587">    if (verbose) {</a>
<a name="ln3588">      emsg(_(e_using_float_as_string));</a>
<a name="ln3589">    }</a>
<a name="ln3590">    return FAIL;</a>
<a name="ln3591">  case VAR_BOOL:</a>
<a name="ln3592">  case VAR_SPECIAL:</a>
<a name="ln3593">    if (verbose) {</a>
<a name="ln3594">      emsg(_(e_cannot_index_special_variable));</a>
<a name="ln3595">    }</a>
<a name="ln3596">    return FAIL;</a>
<a name="ln3597">  case VAR_UNKNOWN:</a>
<a name="ln3598">    if (evaluate) {</a>
<a name="ln3599">      emsg(_(e_cannot_index_special_variable));</a>
<a name="ln3600">      return FAIL;</a>
<a name="ln3601">    }</a>
<a name="ln3602">    FALLTHROUGH;</a>
<a name="ln3603">  case VAR_STRING:</a>
<a name="ln3604">  case VAR_NUMBER:</a>
<a name="ln3605">  case VAR_LIST:</a>
<a name="ln3606">  case VAR_DICT:</a>
<a name="ln3607">  case VAR_BLOB:</a>
<a name="ln3608">    break;</a>
<a name="ln3609">  }</a>
<a name="ln3610">  return OK;</a>
<a name="ln3611">}</a>
<a name="ln3612"> </a>
<a name="ln3613">/// slice() function</a>
<a name="ln3614">void f_slice(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3615">{</a>
<a name="ln3616">  if (check_can_index(argvars, true, false) == OK) {</a>
<a name="ln3617">    tv_copy(argvars, rettv);</a>
<a name="ln3618">    eval_index_inner(rettv, true, argvars + 1,</a>
<a name="ln3619">                     argvars[2].v_type == VAR_UNKNOWN ? NULL : argvars + 2,</a>
<a name="ln3620">                     true, NULL, 0, false);</a>
<a name="ln3621">  }</a>
<a name="ln3622">}</a>
<a name="ln3623"> </a>
<a name="ln3624">/// Apply index or range to &quot;rettv&quot;.</a>
<a name="ln3625">///</a>
<a name="ln3626">/// @param var1  the first index, NULL for [:expr].</a>
<a name="ln3627">/// @param var2  the second index, NULL for [expr] and [expr: ]</a>
<a name="ln3628">/// @param exclusive  true for slice(): second index is exclusive, use character</a>
<a name="ln3629">///                                     index for string.</a>
<a name="ln3630">/// Alternatively, &quot;key&quot; is not NULL, then key[keylen] is the dict index.</a>
<a name="ln3631">static int eval_index_inner(typval_T *rettv, bool is_range, typval_T *var1, typval_T *var2,</a>
<a name="ln3632">                            bool exclusive, const char *key, ptrdiff_t keylen, bool verbose)</a>
<a name="ln3633">{</a>
<a name="ln3634">  varnumber_T n1 = 0;</a>
<a name="ln3635">  varnumber_T n2 = 0;</a>
<a name="ln3636">  if (var1 != NULL &amp;&amp; rettv-&gt;v_type != VAR_DICT) {</a>
<a name="ln3637">    n1 = tv_get_number(var1);</a>
<a name="ln3638">  }</a>
<a name="ln3639"> </a>
<a name="ln3640">  if (is_range) {</a>
<a name="ln3641">    if (rettv-&gt;v_type == VAR_DICT) {</a>
<a name="ln3642">      if (verbose) {</a>
<a name="ln3643">        emsg(_(e_cannot_slice_dictionary));</a>
<a name="ln3644">      }</a>
<a name="ln3645">      return FAIL;</a>
<a name="ln3646">    }</a>
<a name="ln3647">    if (var2 != NULL) {</a>
<a name="ln3648">      n2 = tv_get_number(var2);</a>
<a name="ln3649">    } else {</a>
<a name="ln3650">      n2 = VARNUMBER_MAX;</a>
<a name="ln3651">    }</a>
<a name="ln3652">  }</a>
<a name="ln3653"> </a>
<a name="ln3654">  switch (rettv-&gt;v_type) {</a>
<a name="ln3655">  case VAR_BOOL:</a>
<a name="ln3656">  case VAR_SPECIAL:</a>
<a name="ln3657">  case VAR_FUNC:</a>
<a name="ln3658">  case VAR_FLOAT:</a>
<a name="ln3659">  case VAR_PARTIAL:</a>
<a name="ln3660">  case VAR_UNKNOWN:</a>
<a name="ln3661">    break;  // Not evaluating, skipping over subscript</a>
<a name="ln3662"> </a>
<a name="ln3663">  case VAR_NUMBER:</a>
<a name="ln3664">  case VAR_STRING: {</a>
<a name="ln3665">    const char *const s = tv_get_string(rettv);</a>
<a name="ln3666">    char *v;</a>
<a name="ln3667">    int len = (int)strlen(s);</a>
<a name="ln3668">    if (exclusive) {</a>
<a name="ln3669">      if (is_range) {</a>
<a name="ln3670">        v = string_slice(s, n1, n2, exclusive);</a>
<a name="ln3671">      } else {</a>
<a name="ln3672">        v = char_from_string(s, n1);</a>
<a name="ln3673">      }</a>
<a name="ln3674">    } else if (is_range) {</a>
<a name="ln3675">      // The resulting variable is a substring.  If the indexes</a>
<a name="ln3676">      // are out of range the result is empty.</a>
<a name="ln3677">      if (n1 &lt; 0) {</a>
<a name="ln3678">        n1 = len + n1;</a>
<a name="ln3679">        if (n1 &lt; 0) {</a>
<a name="ln3680">          n1 = 0;</a>
<a name="ln3681">        }</a>
<a name="ln3682">      }</a>
<a name="ln3683">      if (n2 &lt; 0) {</a>
<a name="ln3684">        n2 = len + n2;</a>
<a name="ln3685">      } else if (n2 &gt;= len) {</a>
<a name="ln3686">        n2 = len;</a>
<a name="ln3687">      }</a>
<a name="ln3688">      if (n1 &gt;= len || n2 &lt; 0 || n1 &gt; n2) {</a>
<a name="ln3689">        v = NULL;</a>
<a name="ln3690">      } else {</a>
<a name="ln3691">        v = xmemdupz(s + n1, (size_t)n2 - (size_t)n1 + 1);</a>
<a name="ln3692">      }</a>
<a name="ln3693">    } else {</a>
<a name="ln3694">      // The resulting variable is a string of a single</a>
<a name="ln3695">      // character.  If the index is too big or negative the</a>
<a name="ln3696">      // result is empty.</a>
<a name="ln3697">      if (n1 &gt;= len || n1 &lt; 0) {</a>
<a name="ln3698">        v = NULL;</a>
<a name="ln3699">      } else {</a>
<a name="ln3700">        v = xmemdupz(s + n1, 1);</a>
<a name="ln3701">      }</a>
<a name="ln3702">    }</a>
<a name="ln3703">    tv_clear(rettv);</a>
<a name="ln3704">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3705">    rettv-&gt;vval.v_string = v;</a>
<a name="ln3706">    break;</a>
<a name="ln3707">  }</a>
<a name="ln3708"> </a>
<a name="ln3709">  case VAR_BLOB:</a>
<a name="ln3710">    tv_blob_slice_or_index(rettv-&gt;vval.v_blob, is_range, n1, n2, exclusive, rettv);</a>
<a name="ln3711">    break;</a>
<a name="ln3712"> </a>
<a name="ln3713">  case VAR_LIST:</a>
<a name="ln3714">    if (var1 == NULL) {</a>
<a name="ln3715">      n1 = 0;</a>
<a name="ln3716">    }</a>
<a name="ln3717">    if (var2 == NULL) {</a>
<a name="ln3718">      n2 = VARNUMBER_MAX;</a>
<a name="ln3719">    }</a>
<a name="ln3720">    if (tv_list_slice_or_index(rettv-&gt;vval.v_list,</a>
<a name="ln3721">                               is_range, n1, n2, exclusive, rettv, verbose) == FAIL) {</a>
<a name="ln3722">      return FAIL;</a>
<a name="ln3723">    }</a>
<a name="ln3724">    break;</a>
<a name="ln3725"> </a>
<a name="ln3726">  case VAR_DICT: {</a>
<a name="ln3727">    if (key == NULL) {</a>
<a name="ln3728">      key = tv_get_string_chk(var1);</a>
<a name="ln3729">      if (key == NULL) {</a>
<a name="ln3730">        return FAIL;</a>
<a name="ln3731">      }</a>
<a name="ln3732">    }</a>
<a name="ln3733"> </a>
<a name="ln3734">    dictitem_T *const item = tv_dict_find(rettv-&gt;vval.v_dict, key, keylen);</a>
<a name="ln3735"> </a>
<a name="ln3736">    if (item == NULL &amp;&amp; verbose) {</a>
<a name="ln3737">      semsg(_(e_dictkey), key);</a>
<a name="ln3738">    }</a>
<a name="ln3739">    if (item == NULL || tv_is_luafunc(&amp;item-&gt;di_tv)) {</a>
<a name="ln3740">      return FAIL;</a>
<a name="ln3741">    }</a>
<a name="ln3742"> </a>
<a name="ln3743">    typval_T tmp;</a>
<a name="ln3744">    tv_copy(&amp;item-&gt;di_tv, &amp;tmp);</a>
<a name="ln3745">    tv_clear(rettv);</a>
<a name="ln3746">    *rettv = tmp;</a>
<a name="ln3747">    break;</a>
<a name="ln3748">  }</a>
<a name="ln3749">  }</a>
<a name="ln3750">  return OK;</a>
<a name="ln3751">}</a>
<a name="ln3752"> </a>
<a name="ln3753">/// Get an option value</a>
<a name="ln3754">///</a>
<a name="ln3755">/// @param[in,out] arg  Points to the '&amp;' or '+' before the option name. Is</a>
<a name="ln3756">///                      advanced to the character after the option name.</a>
<a name="ln3757">/// @param[out] rettv  Location where result is saved.</a>
<a name="ln3758">/// @param[in] evaluate  If not true, rettv is not populated.</a>
<a name="ln3759">///</a>
<a name="ln3760">/// @return  OK or FAIL.</a>
<a name="ln3761">int eval_option(const char **const arg, typval_T *const rettv, const bool evaluate)</a>
<a name="ln3762">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3763">{</a>
<a name="ln3764">  const bool working = (**arg == '+');  // has(&quot;+option&quot;)</a>
<a name="ln3765">  int scope;</a>
<a name="ln3766"> </a>
<a name="ln3767">  // Isolate the option name and find its value.</a>
<a name="ln3768">  char *option_end = (char *)find_option_end(arg, &amp;scope);</a>
<a name="ln3769">  if (option_end == NULL) {</a>
<a name="ln3770">    if (rettv != NULL) {</a>
<a name="ln3771">      semsg(_(&quot;E112: Option name missing: %s&quot;), *arg);</a>
<a name="ln3772">    }</a>
<a name="ln3773">    return FAIL;</a>
<a name="ln3774">  }</a>
<a name="ln3775"> </a>
<a name="ln3776">  if (!evaluate) {</a>
<a name="ln3777">    *arg = option_end;</a>
<a name="ln3778">    return OK;</a>
<a name="ln3779">  }</a>
<a name="ln3780"> </a>
<a name="ln3781">  int ret = OK;</a>
<a name="ln3782">  bool hidden;</a>
<a name="ln3783">  char c = *option_end;</a>
<a name="ln3784">  *option_end = NUL;</a>
<a name="ln3785">  OptVal value = get_option_value(*arg, NULL, scope, &amp;hidden);</a>
<a name="ln3786"> </a>
<a name="ln3787">  if (rettv != NULL) {</a>
<a name="ln3788">    switch (value.type) {</a>
<a name="ln3789">    case kOptValTypeNil:</a>
<a name="ln3790">      semsg(_(&quot;E113: Unknown option: %s&quot;), *arg);</a>
<a name="ln3791">      ret = FAIL;</a>
<a name="ln3792">      break;</a>
<a name="ln3793">    case kOptValTypeBoolean:</a>
<a name="ln3794">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3795">      rettv-&gt;vval.v_number = value.data.boolean;</a>
<a name="ln3796">      break;</a>
<a name="ln3797">    case kOptValTypeNumber:</a>
<a name="ln3798">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3799">      rettv-&gt;vval.v_number = value.data.number;</a>
<a name="ln3800">      break;</a>
<a name="ln3801">    case kOptValTypeString:</a>
<a name="ln3802">      rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3803">      rettv-&gt;vval.v_string = value.data.string.data;</a>
<a name="ln3804">      break;</a>
<a name="ln3805">    }</a>
<a name="ln3806">  } else {</a>
<a name="ln3807">    // Value isn't being used, free it.</a>
<a name="ln3808">    optval_free(value);</a>
<a name="ln3809"> </a>
<a name="ln3810">    if (value.type == kOptValTypeNil || (working &amp;&amp; hidden)) {</a>
<a name="ln3811">      ret = FAIL;</a>
<a name="ln3812">    }</a>
<a name="ln3813">  }</a>
<a name="ln3814"> </a>
<a name="ln3815">  *option_end = c;                  // put back for error messages</a>
<a name="ln3816">  *arg = option_end;</a>
<a name="ln3817"> </a>
<a name="ln3818">  return ret;</a>
<a name="ln3819">}</a>
<a name="ln3820"> </a>
<a name="ln3821">/// Allocate a variable for a number constant.  Also deals with &quot;0z&quot; for blob.</a>
<a name="ln3822">///</a>
<a name="ln3823">/// @return  OK or FAIL.</a>
<a name="ln3824">static int eval_number(char **arg, typval_T *rettv, bool evaluate, bool want_string)</a>
<a name="ln3825">{</a>
<a name="ln3826">  char *p = skipdigits(*arg + 1);</a>
<a name="ln3827">  bool get_float = false;</a>
<a name="ln3828"> </a>
<a name="ln3829">  // We accept a float when the format matches</a>
<a name="ln3830">  // &quot;[0-9]\+\.[0-9]\+\([eE][+-]\?[0-9]\+\)\?&quot;.  This is very</a>
<a name="ln3831">  // strict to avoid backwards compatibility problems.</a>
<a name="ln3832">  // Don't look for a float after the &quot;.&quot; operator, so that</a>
<a name="ln3833">  // &quot;:let vers = 1.2.3&quot; doesn't fail.</a>
<a name="ln3834">  if (!want_string &amp;&amp; p[0] == '.' &amp;&amp; ascii_isdigit(p[1])) {</a>
<a name="ln3835">    get_float = true;</a>
<a name="ln3836">    p = skipdigits(p + 2);</a>
<a name="ln3837">    if (*p == 'e' || *p == 'E') {</a>
<a name="ln3838">      p++;</a>
<a name="ln3839">      if (*p == '-' || *p == '+') {</a>
<a name="ln3840">        p++;</a>
<a name="ln3841">      }</a>
<a name="ln3842">      if (!ascii_isdigit(*p)) {</a>
<a name="ln3843">        get_float = false;</a>
<a name="ln3844">      } else {</a>
<a name="ln3845">        p = skipdigits(p + 1);</a>
<a name="ln3846">      }</a>
<a name="ln3847">    }</a>
<a name="ln3848">    if (ASCII_ISALPHA(*p) || *p == '.') {</a>
<a name="ln3849">      get_float = false;</a>
<a name="ln3850">    }</a>
<a name="ln3851">  }</a>
<a name="ln3852">  if (get_float) {</a>
<a name="ln3853">    float_T f;</a>
<a name="ln3854">    *arg += string2float(*arg, &amp;f);</a>
<a name="ln3855">    if (evaluate) {</a>
<a name="ln3856">      rettv-&gt;v_type = VAR_FLOAT;</a>
<a name="ln3857">      rettv-&gt;vval.v_float = f;</a>
<a name="ln3858">    }</a>
<a name="ln3859">  } else if (**arg == '0' &amp;&amp; ((*arg)[1] == 'z' || (*arg)[1] == 'Z')) {</a>
<a name="ln3860">    // Blob constant: 0z0123456789abcdef</a>
<a name="ln3861">    blob_T *blob = NULL;</a>
<a name="ln3862">    if (evaluate) {</a>
<a name="ln3863">      blob = tv_blob_alloc();</a>
<a name="ln3864">    }</a>
<a name="ln3865">    char *bp;</a>
<a name="ln3866">    for (bp = *arg + 2; ascii_isxdigit(bp[0]); bp += 2) {</a>
<a name="ln3867">      if (!ascii_isxdigit(bp[1])) {</a>
<a name="ln3868">        if (blob != NULL) {</a>
<a name="ln3869">          emsg(_(&quot;E973: Blob literal should have an even number of hex characters&quot;));</a>
<a name="ln3870">          ga_clear(&amp;blob-&gt;bv_ga);</a>
<a name="ln3871">          XFREE_CLEAR(blob);</a>
<a name="ln3872">        }</a>
<a name="ln3873">        return FAIL;</a>
<a name="ln3874">      }</a>
<a name="ln3875">      if (blob != NULL) {</a>
<a name="ln3876">        ga_append(&amp;blob-&gt;bv_ga, (uint8_t)((hex2nr(*bp) &lt;&lt; 4) + hex2nr(*(bp + 1))));</a>
<a name="ln3877">      }</a>
<a name="ln3878">      if (bp[2] == '.' &amp;&amp; ascii_isxdigit(bp[3])) {</a>
<a name="ln3879">        bp++;</a>
<a name="ln3880">      }</a>
<a name="ln3881">    }</a>
<a name="ln3882">    if (blob != NULL) {</a>
<a name="ln3883">      tv_blob_set_ret(rettv, blob);</a>
<a name="ln3884">    }</a>
<a name="ln3885">    *arg = bp;</a>
<a name="ln3886">  } else {</a>
<a name="ln3887">    // decimal, hex or octal number</a>
<a name="ln3888">    int len;</a>
<a name="ln3889">    varnumber_T n;</a>
<a name="ln3890">    vim_str2nr(*arg, NULL, &amp;len, STR2NR_ALL, &amp;n, NULL, 0, true, NULL);</a>
<a name="ln3891">    if (len == 0) {</a>
<a name="ln3892">      if (evaluate) {</a>
<a name="ln3893">        semsg(_(e_invexpr2), *arg);</a>
<a name="ln3894">      }</a>
<a name="ln3895">      return FAIL;</a>
<a name="ln3896">    }</a>
<a name="ln3897">    *arg += len;</a>
<a name="ln3898">    if (evaluate) {</a>
<a name="ln3899">      rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3900">      rettv-&gt;vval.v_number = n;</a>
<a name="ln3901">    }</a>
<a name="ln3902">  }</a>
<a name="ln3903">  return OK;</a>
<a name="ln3904">}</a>
<a name="ln3905"> </a>
<a name="ln3906">/// Evaluate a string constant and put the result in &quot;rettv&quot;.</a>
<a name="ln3907">/// &quot;*arg&quot; points to the double quote or to after it when &quot;interpolate&quot; is true.</a>
<a name="ln3908">/// When &quot;interpolate&quot; is true reduce &quot;{{&quot; to &quot;{&quot;, reduce &quot;}}&quot; to &quot;}&quot; and stop</a>
<a name="ln3909">/// at a single &quot;{&quot;.</a>
<a name="ln3910">///</a>
<a name="ln3911">/// @return  OK or FAIL.</a>
<a name="ln3912">static int eval_string(char **arg, typval_T *rettv, bool evaluate, bool interpolate)</a>
<a name="ln3913">{</a>
<a name="ln3914">  char *p;</a>
<a name="ln3915">  const char *const arg_end = *arg + strlen(*arg);</a>
<a name="ln3916">  unsigned extra = interpolate ? 1 : 0;</a>
<a name="ln3917">  const int off = interpolate ? 0 : 1;</a>
<a name="ln3918"> </a>
<a name="ln3919">  // Find the end of the string, skipping backslashed characters.</a>
<a name="ln3920">  for (p = *arg + off; *p != NUL &amp;&amp; *p != '&quot;'; MB_PTR_ADV(p)) {</a>
<a name="ln3921">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln3922">      p++;</a>
<a name="ln3923">      // A &quot;\&lt;x&gt;&quot; form occupies at least 4 characters, and produces up</a>
<a name="ln3924">      // to 9 characters (6 for the char and 3 for a modifier):</a>
<a name="ln3925">      // reserve space for 5 extra.</a>
<a name="ln3926">      if (*p == '&lt;') {</a>
<a name="ln3927">        int modifiers = 0;</a>
<a name="ln3928">        int flags = FSK_KEYCODE | FSK_IN_STRING;</a>
<a name="ln3929"> </a>
<a name="ln3930">        extra += 5;</a>
<a name="ln3931"> </a>
<a name="ln3932">        // Skip to the '&gt;' to avoid using '{' inside for string</a>
<a name="ln3933">        // interpolation.</a>
<a name="ln3934">        if (p[1] != '*') {</a>
<a name="ln3935">          flags |= FSK_SIMPLIFY;</a>
<a name="ln3936">        }</a>
<a name="ln3937">        if (find_special_key((const char **)&amp;p, (size_t)(arg_end - p),</a>
<a name="ln3938">                             &amp;modifiers, flags, NULL) != 0) {</a>
<a name="ln3939">          p--;  // leave &quot;p&quot; on the &quot;&gt;&quot;</a>
<a name="ln3940">        }</a>
<a name="ln3941">      }</a>
<a name="ln3942">    } else if (interpolate &amp;&amp; (*p == '{' || *p == '}')) {</a>
<a name="ln3943">      if (*p == '{' &amp;&amp; p[1] != '{') {  // start of expression</a>
<a name="ln3944">        break;</a>
<a name="ln3945">      }</a>
<a name="ln3946">      p++;</a>
<a name="ln3947">      if (p[-1] == '}' &amp;&amp; *p != '}') {  // single '}' is an error</a>
<a name="ln3948">        semsg(_(e_stray_closing_curly_str), *arg);</a>
<a name="ln3949">        return FAIL;</a>
<a name="ln3950">      }</a>
<a name="ln3951">      extra--;  // &quot;{{&quot; becomes &quot;{&quot;, &quot;}}&quot; becomes &quot;}&quot;</a>
<a name="ln3952">    }</a>
<a name="ln3953">  }</a>
<a name="ln3954"> </a>
<a name="ln3955">  if (*p != '&quot;' &amp;&amp; !(interpolate &amp;&amp; *p == '{')) {</a>
<a name="ln3956">    semsg(_(&quot;E114: Missing quote: %s&quot;), *arg);</a>
<a name="ln3957">    return FAIL;</a>
<a name="ln3958">  }</a>
<a name="ln3959"> </a>
<a name="ln3960">  // If only parsing, set *arg and return here</a>
<a name="ln3961">  if (!evaluate) {</a>
<a name="ln3962">    *arg = p + off;</a>
<a name="ln3963">    return OK;</a>
<a name="ln3964">  }</a>
<a name="ln3965"> </a>
<a name="ln3966">  // Copy the string into allocated memory, handling backslashed</a>
<a name="ln3967">  // characters.</a>
<a name="ln3968">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3969">  const int len = (int)(p - *arg + extra);</a>
<a name="ln3970">  rettv-&gt;vval.v_string = xmalloc((size_t)len);</a>
<a name="ln3971">  char *end = rettv-&gt;vval.v_string;</a>
<a name="ln3972"> </a>
<a name="ln3973">  for (p = *arg + off; *p != NUL &amp;&amp; *p != '&quot;';) {</a>
<a name="ln3974">    if (*p == '\\') {</a>
<a name="ln3975">      switch (*++p) {</a>
<a name="ln3976">      case 'b':</a>
<a name="ln3977">        *end++ = BS; ++p; break;</a>
<a name="ln3978">      case 'e':</a>
<a name="ln3979">        *end++ = ESC; ++p; break;</a>
<a name="ln3980">      case 'f':</a>
<a name="ln3981">        *end++ = FF; ++p; break;</a>
<a name="ln3982">      case 'n':</a>
<a name="ln3983">        *end++ = NL; ++p; break;</a>
<a name="ln3984">      case 'r':</a>
<a name="ln3985">        *end++ = CAR; ++p; break;</a>
<a name="ln3986">      case 't':</a>
<a name="ln3987">        *end++ = TAB; ++p; break;</a>
<a name="ln3988"> </a>
<a name="ln3989">      case 'X':           // hex: &quot;\x1&quot;, &quot;\x12&quot;</a>
<a name="ln3990">      case 'x':</a>
<a name="ln3991">      case 'u':           // Unicode: &quot;\u0023&quot;</a>
<a name="ln3992">      case 'U':</a>
<a name="ln3993">        if (ascii_isxdigit(p[1])) {</a>
<a name="ln3994">          int n, nr;</a>
<a name="ln3995">          int c = toupper((uint8_t)(*p));</a>
<a name="ln3996"> </a>
<a name="ln3997">          if (c == 'X') {</a>
<a name="ln3998">            n = 2;</a>
<a name="ln3999">          } else if (*p == 'u') {</a>
<a name="ln4000">            n = 4;</a>
<a name="ln4001">          } else {</a>
<a name="ln4002">            n = 8;</a>
<a name="ln4003">          }</a>
<a name="ln4004">          nr = 0;</a>
<a name="ln4005">          while (--n &gt;= 0 &amp;&amp; ascii_isxdigit(p[1])) {</a>
<a name="ln4006">            p++;</a>
<a name="ln4007">            nr = (nr &lt;&lt; 4) + hex2nr(*p);</a>
<a name="ln4008">          }</a>
<a name="ln4009">          p++;</a>
<a name="ln4010">          // For &quot;\u&quot; store the number according to</a>
<a name="ln4011">          // 'encoding'.</a>
<a name="ln4012">          if (c != 'X') {</a>
<a name="ln4013">            end += utf_char2bytes(nr, end);</a>
<a name="ln4014">          } else {</a>
<a name="ln4015">            *end++ = (char)nr;</a>
<a name="ln4016">          }</a>
<a name="ln4017">        }</a>
<a name="ln4018">        break;</a>
<a name="ln4019"> </a>
<a name="ln4020">      // octal: &quot;\1&quot;, &quot;\12&quot;, &quot;\123&quot;</a>
<a name="ln4021">      case '0':</a>
<a name="ln4022">      case '1':</a>
<a name="ln4023">      case '2':</a>
<a name="ln4024">      case '3':</a>
<a name="ln4025">      case '4':</a>
<a name="ln4026">      case '5':</a>
<a name="ln4027">      case '6':</a>
<a name="ln4028">      case '7':</a>
<a name="ln4029">        *end = (char)(*p++ - '0');</a>
<a name="ln4030">        if (*p &gt;= '0' &amp;&amp; *p &lt;= '7') {</a>
<a name="ln4031">          *end = (char)((*end &lt;&lt; 3) + *p++ - '0');</a>
<a name="ln4032">          if (*p &gt;= '0' &amp;&amp; *p &lt;= '7') {</a>
<a name="ln4033">            *end = (char)((*end &lt;&lt; 3) + *p++ - '0');</a>
<a name="ln4034">          }</a>
<a name="ln4035">        }</a>
<a name="ln4036">        end++;</a>
<a name="ln4037">        break;</a>
<a name="ln4038"> </a>
<a name="ln4039">      // Special key, e.g.: &quot;\&lt;C-W&gt;&quot;</a>
<a name="ln4040">      case '&lt;': {</a>
<a name="ln4041">        int flags = FSK_KEYCODE | FSK_IN_STRING;</a>
<a name="ln4042"> </a>
<a name="ln4043">        if (p[1] != '*') {</a>
<a name="ln4044">          flags |= FSK_SIMPLIFY;</a>
<a name="ln4045">        }</a>
<a name="ln4046">        extra = trans_special((const char **)&amp;p, (size_t)(arg_end - p),</a>
<a name="ln4047">                              end, flags, false, NULL);</a>
<a name="ln4048">        if (extra != 0) {</a>
<a name="ln4049">          end += extra;</a>
<a name="ln4050">          if (end &gt;= rettv-&gt;vval.v_string + len) {</a>
<a name="ln4051">            iemsg(&quot;eval_string() used more space than allocated&quot;);</a>
<a name="ln4052">          }</a>
<a name="ln4053">          break;</a>
<a name="ln4054">        }</a>
<a name="ln4055">      }</a>
<a name="ln4056">        FALLTHROUGH;</a>
<a name="ln4057"> </a>
<a name="ln4058">      default:</a>
<a name="ln4059">        mb_copy_char((const char **)&amp;p, &amp;end);</a>
<a name="ln4060">        break;</a>
<a name="ln4061">      }</a>
<a name="ln4062">    } else {</a>
<a name="ln4063">      if (interpolate &amp;&amp; (*p == '{' || *p == '}')) {</a>
<a name="ln4064">        if (*p == '{' &amp;&amp; p[1] != '{') {  // start of expression</a>
<a name="ln4065">          break;</a>
<a name="ln4066">        }</a>
<a name="ln4067">        p++;  // reduce &quot;{{&quot; to &quot;{&quot; and &quot;}}&quot; to &quot;}&quot;</a>
<a name="ln4068">      }</a>
<a name="ln4069">      mb_copy_char((const char **)&amp;p, &amp;end);</a>
<a name="ln4070">    }</a>
<a name="ln4071">  }</a>
<a name="ln4072">  *end = NUL;</a>
<a name="ln4073">  if (*p == '&quot;' &amp;&amp; !interpolate) {</a>
<a name="ln4074">    p++;</a>
<a name="ln4075">  }</a>
<a name="ln4076">  *arg = p;</a>
<a name="ln4077"> </a>
<a name="ln4078">  return OK;</a>
<a name="ln4079">}</a>
<a name="ln4080"> </a>
<a name="ln4081">/// Allocate a variable for a 'str''ing' constant.</a>
<a name="ln4082">/// When &quot;interpolate&quot; is true reduce &quot;{{&quot; to &quot;{&quot; and stop at a single &quot;{&quot;.</a>
<a name="ln4083">///</a>
<a name="ln4084">/// @return  OK when a &quot;rettv&quot; was set to the string.</a>
<a name="ln4085">///          FAIL on error, &quot;rettv&quot; is not set.</a>
<a name="ln4086">static int eval_lit_string(char **arg, typval_T *rettv, bool evaluate, bool interpolate)</a>
<a name="ln4087">{</a>
<a name="ln4088">  char *p;</a>
<a name="ln4089">  int reduce = interpolate ? -1 : 0;</a>
<a name="ln4090">  const int off = interpolate ? 0 : 1;</a>
<a name="ln4091"> </a>
<a name="ln4092">  // Find the end of the string, skipping ''.</a>
<a name="ln4093">  for (p = *arg + off; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln4094">    if (*p == '\'') {</a>
<a name="ln4095">      if (p[1] != '\'') {</a>
<a name="ln4096">        break;</a>
<a name="ln4097">      }</a>
<a name="ln4098">      reduce++;</a>
<a name="ln4099">      p++;</a>
<a name="ln4100">    } else if (interpolate) {</a>
<a name="ln4101">      if (*p == '{') {</a>
<a name="ln4102">        if (p[1] != '{') {</a>
<a name="ln4103">          break;</a>
<a name="ln4104">        }</a>
<a name="ln4105">        p++;</a>
<a name="ln4106">        reduce++;</a>
<a name="ln4107">      } else if (*p == '}') {</a>
<a name="ln4108">        p++;</a>
<a name="ln4109">        if (*p != '}') {</a>
<a name="ln4110">          semsg(_(e_stray_closing_curly_str), *arg);</a>
<a name="ln4111">          return FAIL;</a>
<a name="ln4112">        }</a>
<a name="ln4113">        reduce++;</a>
<a name="ln4114">      }</a>
<a name="ln4115">    }</a>
<a name="ln4116">  }</a>
<a name="ln4117"> </a>
<a name="ln4118">  if (*p != '\'' &amp;&amp; !(interpolate &amp;&amp; *p == '{')) {</a>
<a name="ln4119">    semsg(_(&quot;E115: Missing quote: %s&quot;), *arg);</a>
<a name="ln4120">    return FAIL;</a>
<a name="ln4121">  }</a>
<a name="ln4122"> </a>
<a name="ln4123">  // If only parsing return after setting &quot;*arg&quot;</a>
<a name="ln4124">  if (!evaluate) {</a>
<a name="ln4125">    *arg = p + off;</a>
<a name="ln4126">    return OK;</a>
<a name="ln4127">  }</a>
<a name="ln4128"> </a>
<a name="ln4129">  // Copy the string into allocated memory, handling '' to ' reduction and</a>
<a name="ln4130">  // any expressions.</a>
<a name="ln4131">  char *str = xmalloc((size_t)((p - *arg) - reduce));</a>
<a name="ln4132">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4133">  rettv-&gt;vval.v_string = str;</a>
<a name="ln4134"> </a>
<a name="ln4135">  for (p = *arg + off; *p != NUL;) {</a>
<a name="ln4136">    if (*p == '\'') {</a>
<a name="ln4137">      if (p[1] != '\'') {</a>
<a name="ln4138">        break;</a>
<a name="ln4139">      }</a>
<a name="ln4140">      p++;</a>
<a name="ln4141">    } else if (interpolate &amp;&amp; (*p == '{' || *p == '}')) {</a>
<a name="ln4142">      if (*p == '{' &amp;&amp; p[1] != '{') {</a>
<a name="ln4143">        break;</a>
<a name="ln4144">      }</a>
<a name="ln4145">      p++;</a>
<a name="ln4146">    }</a>
<a name="ln4147">    mb_copy_char((const char **)&amp;p, &amp;str);</a>
<a name="ln4148">  }</a>
<a name="ln4149">  *str = NUL;</a>
<a name="ln4150">  *arg = p + off;</a>
<a name="ln4151"> </a>
<a name="ln4152">  return OK;</a>
<a name="ln4153">}</a>
<a name="ln4154"> </a>
<a name="ln4155">/// Evaluate a single or double quoted string possibly containing expressions.</a>
<a name="ln4156">/// &quot;arg&quot; points to the '$'.  The result is put in &quot;rettv&quot;.</a>
<a name="ln4157">///</a>
<a name="ln4158">/// @return  OK or FAIL.</a>
<a name="ln4159">int eval_interp_string(char **arg, typval_T *rettv, bool evaluate)</a>
<a name="ln4160">{</a>
<a name="ln4161">  int ret = OK;</a>
<a name="ln4162"> </a>
<a name="ln4163">  garray_T ga;</a>
<a name="ln4164">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln4165"> </a>
<a name="ln4166">  // *arg is on the '$' character, move it to the first string character.</a>
<a name="ln4167">  (*arg)++;</a>
<a name="ln4168">  const int quote = (uint8_t)(**arg);</a>
<a name="ln4169">  (*arg)++;</a>
<a name="ln4170"> </a>
<a name="ln4171">  while (true) {</a>
<a name="ln4172">    typval_T tv;</a>
<a name="ln4173">    // Get the string up to the matching quote or to a single '{'.</a>
<a name="ln4174">    // &quot;arg&quot; is advanced to either the quote or the '{'.</a>
<a name="ln4175">    if (quote == '&quot;') {</a>
<a name="ln4176">      ret = eval_string(arg, &amp;tv, evaluate, true);</a>
<a name="ln4177">    } else {</a>
<a name="ln4178">      ret = eval_lit_string(arg, &amp;tv, evaluate, true);</a>
<a name="ln4179">    }</a>
<a name="ln4180">    if (ret == FAIL) {</a>
<a name="ln4181">      break;</a>
<a name="ln4182">    }</a>
<a name="ln4183">    if (evaluate) {</a>
<a name="ln4184">      ga_concat(&amp;ga, tv.vval.v_string);</a>
<a name="ln4185">      tv_clear(&amp;tv);</a>
<a name="ln4186">    }</a>
<a name="ln4187"> </a>
<a name="ln4188">    if (**arg != '{') {</a>
<a name="ln4189">      // found terminating quote</a>
<a name="ln4190">      (*arg)++;</a>
<a name="ln4191">      break;</a>
<a name="ln4192">    }</a>
<a name="ln4193">    char *p = eval_one_expr_in_str(*arg, &amp;ga, evaluate);</a>
<a name="ln4194">    if (p == NULL) {</a>
<a name="ln4195">      ret = FAIL;</a>
<a name="ln4196">      break;</a>
<a name="ln4197">    }</a>
<a name="ln4198">    *arg = p;</a>
<a name="ln4199">  }</a>
<a name="ln4200"> </a>
<a name="ln4201">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4202">  if (ret != FAIL &amp;&amp; evaluate) {</a>
<a name="ln4203">    ga_append(&amp;ga, NUL);</a>
<a name="ln4204">  }</a>
<a name="ln4205">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln4206">  return OK;</a>
<a name="ln4207">}</a>
<a name="ln4208"> </a>
<a name="ln4209">/// @return  the function name of the partial.</a>
<a name="ln4210">char *partial_name(partial_T *pt)</a>
<a name="ln4211">  FUNC_ATTR_PURE</a>
<a name="ln4212">{</a>
<a name="ln4213">  if (pt != NULL) {</a>
<a name="ln4214">    if (pt-&gt;pt_name != NULL) {</a>
<a name="ln4215">      return pt-&gt;pt_name;</a>
<a name="ln4216">    }</a>
<a name="ln4217">    if (pt-&gt;pt_func != NULL) {</a>
<a name="ln4218">      return pt-&gt;pt_func-&gt;uf_name;</a>
<a name="ln4219">    }</a>
<a name="ln4220">  }</a>
<a name="ln4221">  return &quot;&quot;;</a>
<a name="ln4222">}</a>
<a name="ln4223"> </a>
<a name="ln4224">static void partial_free(partial_T *pt)</a>
<a name="ln4225">{</a>
<a name="ln4226">  for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln4227">    tv_clear(&amp;pt-&gt;pt_argv[i]);</a>
<a name="ln4228">  }</a>
<a name="ln4229">  xfree(pt-&gt;pt_argv);</a>
<a name="ln4230">  tv_dict_unref(pt-&gt;pt_dict);</a>
<a name="ln4231">  if (pt-&gt;pt_name != NULL) {</a>
<a name="ln4232">    func_unref(pt-&gt;pt_name);</a>
<a name="ln4233">    xfree(pt-&gt;pt_name);</a>
<a name="ln4234">  } else {</a>
<a name="ln4235">    func_ptr_unref(pt-&gt;pt_func);</a>
<a name="ln4236">  }</a>
<a name="ln4237">  xfree(pt);</a>
<a name="ln4238">}</a>
<a name="ln4239"> </a>
<a name="ln4240">/// Unreference a closure: decrement the reference count and free it when it</a>
<a name="ln4241">/// becomes zero.</a>
<a name="ln4242">void partial_unref(partial_T *pt)</a>
<a name="ln4243">{</a>
<a name="ln4244">  if (pt != NULL &amp;&amp; --pt-&gt;pt_refcount &lt;= 0) {</a>
<a name="ln4245">    partial_free(pt);</a>
<a name="ln4246">  }</a>
<a name="ln4247">}</a>
<a name="ln4248"> </a>
<a name="ln4249">/// Allocate a variable for a List and fill it from &quot;*arg&quot;.</a>
<a name="ln4250">///</a>
<a name="ln4251">/// @param arg  &quot;*arg&quot; points to the &quot;[&quot;.</a>
<a name="ln4252">/// @return  OK or FAIL.</a>
<a name="ln4253">static int eval_list(char **arg, typval_T *rettv, evalarg_T *const evalarg)</a>
<a name="ln4254">{</a>
<a name="ln4255">  const bool evaluate = evalarg == NULL ? false : evalarg-&gt;eval_flags &amp; EVAL_EVALUATE;</a>
<a name="ln4256">  list_T *l = NULL;</a>
<a name="ln4257"> </a>
<a name="ln4258">  if (evaluate) {</a>
<a name="ln4259">    l = tv_list_alloc(kListLenShouldKnow);</a>
<a name="ln4260">  }</a>
<a name="ln4261"> </a>
<a name="ln4262">  *arg = skipwhite(*arg + 1);</a>
<a name="ln4263">  while (**arg != ']' &amp;&amp; **arg != NUL) {</a>
<a name="ln4264">    typval_T tv;</a>
<a name="ln4265">    if (eval1(arg, &amp;tv, evalarg) == FAIL) {  // Recursive!</a>
<a name="ln4266">      goto failret;</a>
<a name="ln4267">    }</a>
<a name="ln4268">    if (evaluate) {</a>
<a name="ln4269">      tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln4270">      tv_list_append_owned_tv(l, tv);</a>
<a name="ln4271">    }</a>
<a name="ln4272"> </a>
<a name="ln4273">    // the comma must come after the value</a>
<a name="ln4274">    bool had_comma = **arg == ',';</a>
<a name="ln4275">    if (had_comma) {</a>
<a name="ln4276">      *arg = skipwhite(*arg + 1);</a>
<a name="ln4277">    }</a>
<a name="ln4278"> </a>
<a name="ln4279">    if (**arg == ']') {</a>
<a name="ln4280">      break;</a>
<a name="ln4281">    }</a>
<a name="ln4282"> </a>
<a name="ln4283">    if (!had_comma) {</a>
<a name="ln4284">      semsg(_(&quot;E696: Missing comma in List: %s&quot;), *arg);</a>
<a name="ln4285">      goto failret;</a>
<a name="ln4286">    }</a>
<a name="ln4287">  }</a>
<a name="ln4288"> </a>
<a name="ln4289">  if (**arg != ']') {</a>
<a name="ln4290">    semsg(_(e_list_end), *arg);</a>
<a name="ln4291">failret:</a>
<a name="ln4292">    if (evaluate) {</a>
<a name="ln4293">      tv_list_free(l);</a>
<a name="ln4294">    }</a>
<a name="ln4295">    return FAIL;</a>
<a name="ln4296">  }</a>
<a name="ln4297"> </a>
<a name="ln4298">  *arg = skipwhite(*arg + 1);</a>
<a name="ln4299">  if (evaluate) {</a>
<a name="ln4300">    tv_list_set_ret(rettv, l);</a>
<a name="ln4301">  }</a>
<a name="ln4302"> </a>
<a name="ln4303">  return OK;</a>
<a name="ln4304">}</a>
<a name="ln4305"> </a>
<a name="ln4306">/// @param ic  ignore case</a>
<a name="ln4307">bool func_equal(typval_T *tv1, typval_T *tv2, bool ic)</a>
<a name="ln4308">{</a>
<a name="ln4309">  // empty and NULL function name considered the same</a>
<a name="ln4310">  char *s1 = tv1-&gt;v_type == VAR_FUNC ? tv1-&gt;vval.v_string : partial_name(tv1-&gt;vval.v_partial);</a>
<a name="ln4311">  if (s1 != NULL &amp;&amp; *s1 == NUL) {</a>
<a name="ln4312">    s1 = NULL;</a>
<a name="ln4313">  }</a>
<a name="ln4314">  char *s2 = tv2-&gt;v_type == VAR_FUNC ? tv2-&gt;vval.v_string : partial_name(tv2-&gt;vval.v_partial);</a>
<a name="ln4315">  if (s2 != NULL &amp;&amp; *s2 == NUL) {</a>
<a name="ln4316">    s2 = NULL;</a>
<a name="ln4317">  }</a>
<a name="ln4318">  if (s1 == NULL || s2 == NULL) {</a>
<a name="ln4319">    if (s1 != s2) {</a>
<a name="ln4320">      return false;</a>
<a name="ln4321">    }</a>
<a name="ln4322">  } else if (strcmp(s1, s2) != 0) {</a>
<a name="ln4323">    return false;</a>
<a name="ln4324">  }</a>
<a name="ln4325"> </a>
<a name="ln4326">  // empty dict and NULL dict is different</a>
<a name="ln4327">  dict_T *d1 = tv1-&gt;v_type == VAR_FUNC ? NULL : tv1-&gt;vval.v_partial-&gt;pt_dict;</a>
<a name="ln4328">  dict_T *d2 = tv2-&gt;v_type == VAR_FUNC ? NULL : tv2-&gt;vval.v_partial-&gt;pt_dict;</a>
<a name="ln4329">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln4330">    if (d1 != d2) {</a>
<a name="ln4331">      return false;</a>
<a name="ln4332">    }</a>
<a name="ln4333">  } else if (!tv_dict_equal(d1, d2, ic, true)) {</a>
<a name="ln4334">    return false;</a>
<a name="ln4335">  }</a>
<a name="ln4336"> </a>
<a name="ln4337">  // empty list and no list considered the same</a>
<a name="ln4338">  int a1 = tv1-&gt;v_type == VAR_FUNC ? 0 : tv1-&gt;vval.v_partial-&gt;pt_argc;</a>
<a name="ln4339">  int a2 = tv2-&gt;v_type == VAR_FUNC ? 0 : tv2-&gt;vval.v_partial-&gt;pt_argc;</a>
<a name="ln4340">  if (a1 != a2) {</a>
<a name="ln4341">    return false;</a>
<a name="ln4342">  }</a>
<a name="ln4343">  for (int i = 0; i &lt; a1; i++) {</a>
<a name="ln4344">    if (!tv_equal(tv1-&gt;vval.v_partial-&gt;pt_argv + i,</a>
<a name="ln4345">                  tv2-&gt;vval.v_partial-&gt;pt_argv + i, ic, true)) {</a>
<a name="ln4346">      return false;</a>
<a name="ln4347">    }</a>
<a name="ln4348">  }</a>
<a name="ln4349">  return true;</a>
<a name="ln4350">}</a>
<a name="ln4351"> </a>
<a name="ln4352">/// Get next (unique) copy ID</a>
<a name="ln4353">///</a>
<a name="ln4354">/// Used for traversing nested structures e.g. when serializing them or garbage</a>
<a name="ln4355">/// collecting.</a>
<a name="ln4356">int get_copyID(void)</a>
<a name="ln4357">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4358">{</a>
<a name="ln4359">  // CopyID for recursively traversing lists and dicts</a>
<a name="ln4360">  //</a>
<a name="ln4361">  // This value is needed to avoid endless recursiveness. Last bit is used for</a>
<a name="ln4362">  // previous_funccal and normally ignored when comparing.</a>
<a name="ln4363">  static int current_copyID = 0;</a>
<a name="ln4364">  current_copyID += COPYID_INC;</a>
<a name="ln4365">  return current_copyID;</a>
<a name="ln4366">}</a>
<a name="ln4367"> </a>
<a name="ln4368">/// Garbage collection for lists and dictionaries.</a>
<a name="ln4369">///</a>
<a name="ln4370">/// We use reference counts to be able to free most items right away when they</a>
<a name="ln4371">/// are no longer used.  But for composite items it's possible that it becomes</a>
<a name="ln4372">/// unused while the reference count is &gt; 0: When there is a recursive</a>
<a name="ln4373">/// reference.  Example:</a>
<a name="ln4374">///      :let l = [1, 2, 3]</a>
<a name="ln4375">///      :let d = {9: l}</a>
<a name="ln4376">///      :let l[1] = d</a>
<a name="ln4377">///</a>
<a name="ln4378">/// Since this is quite unusual we handle this with garbage collection: every</a>
<a name="ln4379">/// once in a while find out which lists and dicts are not referenced from any</a>
<a name="ln4380">/// variable.</a>
<a name="ln4381">///</a>
<a name="ln4382">/// Here is a good reference text about garbage collection (refers to Python</a>
<a name="ln4383">/// but it applies to all reference-counting mechanisms):</a>
<a name="ln4384">///      http://python.ca/nas/python/gc/</a>
<a name="ln4385"> </a>
<a name="ln4386">/// Do garbage collection for lists and dicts.</a>
<a name="ln4387">///</a>
<a name="ln4388">/// @param testing  true if called from test_garbagecollect_now().</a>
<a name="ln4389">///</a>
<a name="ln4390">/// @return  true if some memory was freed.</a>
<a name="ln4391">bool garbage_collect(bool testing)</a>
<a name="ln4392">{</a>
<a name="ln4393">  bool abort = false;</a>
<a name="ln4394">#define ABORTING(func) abort = abort || func</a>
<a name="ln4395"> </a>
<a name="ln4396">  if (!testing) {</a>
<a name="ln4397">    // Only do this once.</a>
<a name="ln4398">    want_garbage_collect = false;</a>
<a name="ln4399">    may_garbage_collect = false;</a>
<a name="ln4400">    garbage_collect_at_exit = false;</a>
<a name="ln4401">  }</a>
<a name="ln4402"> </a>
<a name="ln4403">  // The execution stack can grow big, limit the size.</a>
<a name="ln4404">  if (exestack.ga_maxlen - exestack.ga_len &gt; 500) {</a>
<a name="ln4405">    // Keep 150% of the current size, with a minimum of the growth size.</a>
<a name="ln4406">    int n = exestack.ga_len / 2;</a>
<a name="ln4407">    if (n &lt; exestack.ga_growsize) {</a>
<a name="ln4408">      n = exestack.ga_growsize;</a>
<a name="ln4409">    }</a>
<a name="ln4410"> </a>
<a name="ln4411">    // Don't make it bigger though.</a>
<a name="ln4412">    if (exestack.ga_len + n &lt; exestack.ga_maxlen) {</a>
<a name="ln4413">      size_t new_len = (size_t)exestack.ga_itemsize * (size_t)(exestack.ga_len + n);</a>
<a name="ln4414">      char *pp = xrealloc(exestack.ga_data, new_len);</a>
<a name="ln4415">      exestack.ga_maxlen = exestack.ga_len + n;</a>
<a name="ln4416">      exestack.ga_data = pp;</a>
<a name="ln4417">    }</a>
<a name="ln4418">  }</a>
<a name="ln4419"> </a>
<a name="ln4420">  // We advance by two (COPYID_INC) because we add one for items referenced</a>
<a name="ln4421">  // through previous_funccal.</a>
<a name="ln4422">  const int copyID = get_copyID();</a>
<a name="ln4423"> </a>
<a name="ln4424">  // 1. Go through all accessible variables and mark all lists and dicts</a>
<a name="ln4425">  // with copyID.</a>
<a name="ln4426"> </a>
<a name="ln4427">  // Don't free variables in the previous_funccal list unless they are only</a>
<a name="ln4428">  // referenced through previous_funccal.  This must be first, because if</a>
<a name="ln4429">  // the item is referenced elsewhere the funccal must not be freed.</a>
<a name="ln4430">  ABORTING(set_ref_in_previous_funccal)(copyID);</a>
<a name="ln4431"> </a>
<a name="ln4432">  // script-local variables</a>
<a name="ln4433">  for (int i = 1; i &lt;= script_items.ga_len; i++) {</a>
<a name="ln4434">    ABORTING(set_ref_in_ht)(&amp;SCRIPT_VARS(i), copyID, NULL);</a>
<a name="ln4435">  }</a>
<a name="ln4436"> </a>
<a name="ln4437">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln4438">    // buffer-local variables</a>
<a name="ln4439">    ABORTING(set_ref_in_item)(&amp;buf-&gt;b_bufvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4440">    // buffer marks (ShaDa additional data)</a>
<a name="ln4441">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_cursor, copyID);</a>
<a name="ln4442">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_insert, copyID);</a>
<a name="ln4443">    ABORTING(set_ref_in_fmark)(buf-&gt;b_last_change, copyID);</a>
<a name="ln4444">    for (size_t i = 0; i &lt; NMARKS; i++) {</a>
<a name="ln4445">      ABORTING(set_ref_in_fmark)(buf-&gt;b_namedm[i], copyID);</a>
<a name="ln4446">    }</a>
<a name="ln4447">    // buffer change list (ShaDa additional data)</a>
<a name="ln4448">    for (int i = 0; i &lt; buf-&gt;b_changelistlen; i++) {</a>
<a name="ln4449">      ABORTING(set_ref_in_fmark)(buf-&gt;b_changelist[i], copyID);</a>
<a name="ln4450">    }</a>
<a name="ln4451">    // buffer ShaDa additional data</a>
<a name="ln4452">    ABORTING(set_ref_dict)(buf-&gt;additional_data, copyID);</a>
<a name="ln4453"> </a>
<a name="ln4454">    // buffer callback functions</a>
<a name="ln4455">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_prompt_callback, copyID, NULL, NULL);</a>
<a name="ln4456">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_prompt_interrupt, copyID, NULL, NULL);</a>
<a name="ln4457">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_cfu_cb, copyID, NULL, NULL);</a>
<a name="ln4458">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_ofu_cb, copyID, NULL, NULL);</a>
<a name="ln4459">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_tsrfu_cb, copyID, NULL, NULL);</a>
<a name="ln4460">    ABORTING(set_ref_in_callback)(&amp;buf-&gt;b_tfu_cb, copyID, NULL, NULL);</a>
<a name="ln4461">  }</a>
<a name="ln4462"> </a>
<a name="ln4463">  // 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks</a>
<a name="ln4464">  ABORTING(set_ref_in_insexpand_funcs)(copyID);</a>
<a name="ln4465"> </a>
<a name="ln4466">  // 'operatorfunc' callback</a>
<a name="ln4467">  ABORTING(set_ref_in_opfunc)(copyID);</a>
<a name="ln4468"> </a>
<a name="ln4469">  // 'tagfunc' callback</a>
<a name="ln4470">  ABORTING(set_ref_in_tagfunc)(copyID);</a>
<a name="ln4471"> </a>
<a name="ln4472">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4473">    // window-local variables</a>
<a name="ln4474">    ABORTING(set_ref_in_item)(&amp;wp-&gt;w_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4475">    // window jump list (ShaDa additional data)</a>
<a name="ln4476">    for (int i = 0; i &lt; wp-&gt;w_jumplistlen; i++) {</a>
<a name="ln4477">      ABORTING(set_ref_in_fmark)(wp-&gt;w_jumplist[i].fmark, copyID);</a>
<a name="ln4478">    }</a>
<a name="ln4479">  }</a>
<a name="ln4480">  // window-local variables in autocmd windows</a>
<a name="ln4481">  for (int i = 0; i &lt; AUCMD_WIN_COUNT; i++) {</a>
<a name="ln4482">    if (aucmd_win[i].auc_win != NULL) {</a>
<a name="ln4483">      ABORTING(set_ref_in_item)(&amp;aucmd_win[i].auc_win-&gt;w_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4484">    }</a>
<a name="ln4485">  }</a>
<a name="ln4486"> </a>
<a name="ln4487">  // registers (ShaDa additional data)</a>
<a name="ln4488">  {</a>
<a name="ln4489">    const void *reg_iter = NULL;</a>
<a name="ln4490">    do {</a>
<a name="ln4491">      yankreg_T reg;</a>
<a name="ln4492">      char name = NUL;</a>
<a name="ln4493">      bool is_unnamed = false;</a>
<a name="ln4494">      reg_iter = op_global_reg_iter(reg_iter, &amp;name, &amp;reg, &amp;is_unnamed);</a>
<a name="ln4495">      if (name != NUL) {</a>
<a name="ln4496">        ABORTING(set_ref_dict)(reg.additional_data, copyID);</a>
<a name="ln4497">      }</a>
<a name="ln4498">    } while (reg_iter != NULL);</a>
<a name="ln4499">  }</a>
<a name="ln4500"> </a>
<a name="ln4501">  // global marks (ShaDa additional data)</a>
<a name="ln4502">  {</a>
<a name="ln4503">    const void *mark_iter = NULL;</a>
<a name="ln4504">    do {</a>
<a name="ln4505">      xfmark_T fm;</a>
<a name="ln4506">      char name = NUL;</a>
<a name="ln4507">      mark_iter = mark_global_iter(mark_iter, &amp;name, &amp;fm);</a>
<a name="ln4508">      if (name != NUL) {</a>
<a name="ln4509">        ABORTING(set_ref_dict)(fm.fmark.additional_data, copyID);</a>
<a name="ln4510">      }</a>
<a name="ln4511">    } while (mark_iter != NULL);</a>
<a name="ln4512">  }</a>
<a name="ln4513"> </a>
<a name="ln4514">  // tabpage-local variables</a>
<a name="ln4515">  FOR_ALL_TABS(tp) {</a>
<a name="ln4516">    ABORTING(set_ref_in_item)(&amp;tp-&gt;tp_winvar.di_tv, copyID, NULL, NULL);</a>
<a name="ln4517">  }</a>
<a name="ln4518"> </a>
<a name="ln4519">  // global variables</a>
<a name="ln4520">  ABORTING(set_ref_in_ht)(&amp;globvarht, copyID, NULL);</a>
<a name="ln4521"> </a>
<a name="ln4522">  // function-local variables</a>
<a name="ln4523">  ABORTING(set_ref_in_call_stack)(copyID);</a>
<a name="ln4524"> </a>
<a name="ln4525">  // named functions (matters for closures)</a>
<a name="ln4526">  ABORTING(set_ref_in_functions)(copyID);</a>
<a name="ln4527"> </a>
<a name="ln4528">  // Channels</a>
<a name="ln4529">  {</a>
<a name="ln4530">    Channel *data;</a>
<a name="ln4531">    map_foreach_value(&amp;channels, data, {</a>
<a name="ln4532">      set_ref_in_callback_reader(&amp;data-&gt;on_data, copyID, NULL, NULL);</a>
<a name="ln4533">      set_ref_in_callback_reader(&amp;data-&gt;on_stderr, copyID, NULL, NULL);</a>
<a name="ln4534">      set_ref_in_callback(&amp;data-&gt;on_exit, copyID, NULL, NULL);</a>
<a name="ln4535">    })</a>
<a name="ln4536">  }</a>
<a name="ln4537"> </a>
<a name="ln4538">  // Timers</a>
<a name="ln4539">  {</a>
<a name="ln4540">    timer_T *timer;</a>
<a name="ln4541">    map_foreach_value(&amp;timers, timer, {</a>
<a name="ln4542">      set_ref_in_callback(&amp;timer-&gt;callback, copyID, NULL, NULL);</a>
<a name="ln4543">    })</a>
<a name="ln4544">  }</a>
<a name="ln4545"> </a>
<a name="ln4546">  // function call arguments, if v:testing is set.</a>
<a name="ln4547">  ABORTING(set_ref_in_func_args)(copyID);</a>
<a name="ln4548"> </a>
<a name="ln4549">  // v: vars</a>
<a name="ln4550">  ABORTING(set_ref_in_ht)(&amp;vimvarht, copyID, NULL);</a>
<a name="ln4551"> </a>
<a name="ln4552">  // history items (ShaDa additional elements)</a>
<a name="ln4553">  if (p_hi) {</a>
<a name="ln4554">    for (HistoryType i = 0; i &lt; HIST_COUNT; i++) {</a>
<a name="ln4555">      const void *iter = NULL;</a>
<a name="ln4556">      do {</a>
<a name="ln4557">        histentry_T hist;</a>
<a name="ln4558">        iter = hist_iter(iter, (uint8_t)i, false, &amp;hist);</a>
<a name="ln4559">        if (hist.hisstr != NULL) {</a>
<a name="ln4560">          ABORTING(set_ref_list)(hist.additional_elements, copyID);</a>
<a name="ln4561">        }</a>
<a name="ln4562">      } while (iter != NULL);</a>
<a name="ln4563">    }</a>
<a name="ln4564">  }</a>
<a name="ln4565"> </a>
<a name="ln4566">  // previously used search/substitute patterns (ShaDa additional data)</a>
<a name="ln4567">  {</a>
<a name="ln4568">    SearchPattern pat;</a>
<a name="ln4569">    get_search_pattern(&amp;pat);</a>
<a name="ln4570">    ABORTING(set_ref_dict)(pat.additional_data, copyID);</a>
<a name="ln4571">    get_substitute_pattern(&amp;pat);</a>
<a name="ln4572">    ABORTING(set_ref_dict)(pat.additional_data, copyID);</a>
<a name="ln4573">  }</a>
<a name="ln4574"> </a>
<a name="ln4575">  // previously used replacement string</a>
<a name="ln4576">  {</a>
<a name="ln4577">    SubReplacementString sub;</a>
<a name="ln4578">    sub_get_replacement(&amp;sub);</a>
<a name="ln4579">    ABORTING(set_ref_list)(sub.additional_elements, copyID);</a>
<a name="ln4580">  }</a>
<a name="ln4581"> </a>
<a name="ln4582">  ABORTING(set_ref_in_quickfix)(copyID);</a>
<a name="ln4583"> </a>
<a name="ln4584">  bool did_free = false;</a>
<a name="ln4585">  if (!abort) {</a>
<a name="ln4586">    // 2. Free lists and dictionaries that are not referenced.</a>
<a name="ln4587">    did_free = free_unref_items(copyID);</a>
<a name="ln4588"> </a>
<a name="ln4589">    // 3. Check if any funccal can be freed now.</a>
<a name="ln4590">    //    This may call us back recursively.</a>
<a name="ln4591">    did_free = free_unref_funccal(copyID, testing) || did_free;</a>
<a name="ln4592">  } else if (p_verbose &gt; 0) {</a>
<a name="ln4593">    verb_msg(_(&quot;Not enough memory to set references, garbage collection aborted!&quot;));</a>
<a name="ln4594">  }</a>
<a name="ln4595">#undef ABORTING</a>
<a name="ln4596">  return did_free;</a>
<a name="ln4597">}</a>
<a name="ln4598"> </a>
<a name="ln4599">/// Free lists and dictionaries that are no longer referenced.</a>
<a name="ln4600">///</a>
<a name="ln4601">/// @note  This function may only be called from garbage_collect().</a>
<a name="ln4602">///</a>
<a name="ln4603">/// @param copyID  Free lists/dictionaries that don't have this ID.</a>
<a name="ln4604">///</a>
<a name="ln4605">/// @return  true, if something was freed.</a>
<a name="ln4606">static int free_unref_items(int copyID)</a>
<a name="ln4607">{</a>
<a name="ln4608">  bool did_free = false;</a>
<a name="ln4609"> </a>
<a name="ln4610">  // Let all &quot;free&quot; functions know that we are here. This means no</a>
<a name="ln4611">  // dictionaries, lists, or jobs are to be freed, because we will</a>
<a name="ln4612">  // do that here.</a>
<a name="ln4613">  tv_in_free_unref_items = true;</a>
<a name="ln4614"> </a>
<a name="ln4615">  // PASS 1: free the contents of the items. We don't free the items</a>
<a name="ln4616">  // themselves yet, so that it is possible to decrement refcount counters.</a>
<a name="ln4617"> </a>
<a name="ln4618">  // Go through the list of dicts and free items without the copyID.</a>
<a name="ln4619">  // Don't free dicts that are referenced internally.</a>
<a name="ln4620">  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd-&gt;dv_used_next) {</a>
<a name="ln4621">    if ((dd-&gt;dv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)) {</a>
<a name="ln4622">      // Free the Dictionary and ordinary items it contains, but don't</a>
<a name="ln4623">      // recurse into Lists and Dictionaries, they will be in the list</a>
<a name="ln4624">      // of dicts or list of lists.</a>
<a name="ln4625">      tv_dict_free_contents(dd);</a>
<a name="ln4626">      did_free = true;</a>
<a name="ln4627">    }</a>
<a name="ln4628">  }</a>
<a name="ln4629"> </a>
<a name="ln4630">  // Go through the list of lists and free items without the copyID.</a>
<a name="ln4631">  // But don't free a list that has a watcher (used in a for loop), these</a>
<a name="ln4632">  // are not referenced anywhere.</a>
<a name="ln4633">  for (list_T *ll = gc_first_list; ll != NULL; ll = ll-&gt;lv_used_next) {</a>
<a name="ln4634">    if ((tv_list_copyid(ll) &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)</a>
<a name="ln4635">        &amp;&amp; !tv_list_has_watchers(ll)) {</a>
<a name="ln4636">      // Free the List and ordinary items it contains, but don't recurse</a>
<a name="ln4637">      // into Lists and Dictionaries, they will be in the list of dicts</a>
<a name="ln4638">      // or list of lists.</a>
<a name="ln4639">      tv_list_free_contents(ll);</a>
<a name="ln4640">      did_free = true;</a>
<a name="ln4641">    }</a>
<a name="ln4642">  }</a>
<a name="ln4643"> </a>
<a name="ln4644">  // PASS 2: free the items themselves.</a>
<a name="ln4645">  dict_T *dd_next;</a>
<a name="ln4646">  for (dict_T *dd = gc_first_dict; dd != NULL; dd = dd_next) {</a>
<a name="ln4647">    dd_next = dd-&gt;dv_used_next;</a>
<a name="ln4648">    if ((dd-&gt;dv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)) {</a>
<a name="ln4649">      tv_dict_free_dict(dd);</a>
<a name="ln4650">    }</a>
<a name="ln4651">  }</a>
<a name="ln4652"> </a>
<a name="ln4653">  list_T *ll_next;</a>
<a name="ln4654">  for (list_T *ll = gc_first_list; ll != NULL; ll = ll_next) {</a>
<a name="ln4655">    ll_next = ll-&gt;lv_used_next;</a>
<a name="ln4656">    if ((ll-&gt;lv_copyID &amp; COPYID_MASK) != (copyID &amp; COPYID_MASK)</a>
<a name="ln4657">        &amp;&amp; !tv_list_has_watchers(ll)) {</a>
<a name="ln4658">      // Free the List and ordinary items it contains, but don't recurse</a>
<a name="ln4659">      // into Lists and Dictionaries, they will be in the list of dicts</a>
<a name="ln4660">      // or list of lists.</a>
<a name="ln4661">      tv_list_free_list(ll);</a>
<a name="ln4662">    }</a>
<a name="ln4663">  }</a>
<a name="ln4664">  tv_in_free_unref_items = false;</a>
<a name="ln4665">  return did_free;</a>
<a name="ln4666">}</a>
<a name="ln4667"> </a>
<a name="ln4668">/// Mark all lists and dicts referenced through hashtab &quot;ht&quot; with &quot;copyID&quot;.</a>
<a name="ln4669">///</a>
<a name="ln4670">/// @param ht            Hashtab content will be marked.</a>
<a name="ln4671">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln4672">/// @param list_stack    Used to add lists to be marked. Can be NULL.</a>
<a name="ln4673">///</a>
<a name="ln4674">/// @returns             true if setting references failed somehow.</a>
<a name="ln4675">bool set_ref_in_ht(hashtab_T *ht, int copyID, list_stack_T **list_stack)</a>
<a name="ln4676">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4677">{</a>
<a name="ln4678">  bool abort = false;</a>
<a name="ln4679">  ht_stack_T *ht_stack = NULL;</a>
<a name="ln4680"> </a>
<a name="ln4681">  hashtab_T *cur_ht = ht;</a>
<a name="ln4682">  while (true) {</a>
<a name="ln4683">    if (!abort) {</a>
<a name="ln4684">      // Mark each item in the hashtab.  If the item contains a hashtab</a>
<a name="ln4685">      // it is added to ht_stack, if it contains a list it is added to</a>
<a name="ln4686">      // list_stack.</a>
<a name="ln4687">      HASHTAB_ITER(cur_ht, hi, {</a>
<a name="ln4688">        abort = abort || set_ref_in_item(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, copyID, &amp;ht_stack, list_stack);</a>
<a name="ln4689">      });</a>
<a name="ln4690">    }</a>
<a name="ln4691"> </a>
<a name="ln4692">    if (ht_stack == NULL) {</a>
<a name="ln4693">      break;</a>
<a name="ln4694">    }</a>
<a name="ln4695"> </a>
<a name="ln4696">    // take an item from the stack</a>
<a name="ln4697">    cur_ht = ht_stack-&gt;ht;</a>
<a name="ln4698">    ht_stack_T *tempitem = ht_stack;</a>
<a name="ln4699">    ht_stack = ht_stack-&gt;prev;</a>
<a name="ln4700">    xfree(tempitem);</a>
<a name="ln4701">  }</a>
<a name="ln4702"> </a>
<a name="ln4703">  return abort;</a>
<a name="ln4704">}</a>
<a name="ln4705"> </a>
<a name="ln4706">/// Mark all lists and dicts referenced through list &quot;l&quot; with &quot;copyID&quot;.</a>
<a name="ln4707">///</a>
<a name="ln4708">/// @param l             List content will be marked.</a>
<a name="ln4709">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln4710">/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.</a>
<a name="ln4711">///</a>
<a name="ln4712">/// @returns             true if setting references failed somehow.</a>
<a name="ln4713">bool set_ref_in_list(list_T *l, int copyID, ht_stack_T **ht_stack)</a>
<a name="ln4714">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4715">{</a>
<a name="ln4716">  bool abort = false;</a>
<a name="ln4717">  list_stack_T *list_stack = NULL;</a>
<a name="ln4718"> </a>
<a name="ln4719">  list_T *cur_l = l;</a>
<a name="ln4720">  while (true) {</a>
<a name="ln4721">    // Mark each item in the list.  If the item contains a hashtab</a>
<a name="ln4722">    // it is added to ht_stack, if it contains a list it is added to</a>
<a name="ln4723">    // list_stack.</a>
<a name="ln4724">    TV_LIST_ITER(cur_l, li, {</a>
<a name="ln4725">      if (abort) {</a>
<a name="ln4726">        break;</a>
<a name="ln4727">      }</a>
<a name="ln4728">      abort = set_ref_in_item(TV_LIST_ITEM_TV(li), copyID, ht_stack,</a>
<a name="ln4729">                              &amp;list_stack);</a>
<a name="ln4730">    });</a>
<a name="ln4731"> </a>
<a name="ln4732">    if (list_stack == NULL) {</a>
<a name="ln4733">      break;</a>
<a name="ln4734">    }</a>
<a name="ln4735"> </a>
<a name="ln4736">    // take an item from the stack</a>
<a name="ln4737">    cur_l = list_stack-&gt;list;</a>
<a name="ln4738">    list_stack_T *tempitem = list_stack;</a>
<a name="ln4739">    list_stack = list_stack-&gt;prev;</a>
<a name="ln4740">    xfree(tempitem);</a>
<a name="ln4741">  }</a>
<a name="ln4742"> </a>
<a name="ln4743">  return abort;</a>
<a name="ln4744">}</a>
<a name="ln4745"> </a>
<a name="ln4746">/// Mark all lists and dicts referenced through typval &quot;tv&quot; with &quot;copyID&quot;.</a>
<a name="ln4747">///</a>
<a name="ln4748">/// @param tv            Typval content will be marked.</a>
<a name="ln4749">/// @param copyID        New mark for lists and dicts.</a>
<a name="ln4750">/// @param ht_stack      Used to add hashtabs to be marked. Can be NULL.</a>
<a name="ln4751">/// @param list_stack    Used to add lists to be marked. Can be NULL.</a>
<a name="ln4752">///</a>
<a name="ln4753">/// @returns             true if setting references failed somehow.</a>
<a name="ln4754">bool set_ref_in_item(typval_T *tv, int copyID, ht_stack_T **ht_stack, list_stack_T **list_stack)</a>
<a name="ln4755">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4756">{</a>
<a name="ln4757">  bool abort = false;</a>
<a name="ln4758"> </a>
<a name="ln4759">  switch (tv-&gt;v_type) {</a>
<a name="ln4760">  case VAR_DICT: {</a>
<a name="ln4761">    dict_T *dd = tv-&gt;vval.v_dict;</a>
<a name="ln4762">    if (dd != NULL &amp;&amp; dd-&gt;dv_copyID != copyID) {</a>
<a name="ln4763">      // Didn't see this dict yet.</a>
<a name="ln4764">      dd-&gt;dv_copyID = copyID;</a>
<a name="ln4765">      if (ht_stack == NULL) {</a>
<a name="ln4766">        abort = set_ref_in_ht(&amp;dd-&gt;dv_hashtab, copyID, list_stack);</a>
<a name="ln4767">      } else {</a>
<a name="ln4768">        ht_stack_T *const newitem = xmalloc(sizeof(ht_stack_T));</a>
<a name="ln4769">        newitem-&gt;ht = &amp;dd-&gt;dv_hashtab;</a>
<a name="ln4770">        newitem-&gt;prev = *ht_stack;</a>
<a name="ln4771">        *ht_stack = newitem;</a>
<a name="ln4772">      }</a>
<a name="ln4773"> </a>
<a name="ln4774">      QUEUE *w = NULL;</a>
<a name="ln4775">      DictWatcher *watcher = NULL;</a>
<a name="ln4776">      QUEUE_FOREACH(w, &amp;dd-&gt;watchers, {</a>
<a name="ln4777">          watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln4778">          set_ref_in_callback(&amp;watcher-&gt;callback, copyID, ht_stack, list_stack);</a>
<a name="ln4779">        })</a>
<a name="ln4780">    }</a>
<a name="ln4781">    break;</a>
<a name="ln4782">  }</a>
<a name="ln4783"> </a>
<a name="ln4784">  case VAR_LIST: {</a>
<a name="ln4785">    list_T *ll = tv-&gt;vval.v_list;</a>
<a name="ln4786">    if (ll != NULL &amp;&amp; ll-&gt;lv_copyID != copyID) {</a>
<a name="ln4787">      // Didn't see this list yet.</a>
<a name="ln4788">      ll-&gt;lv_copyID = copyID;</a>
<a name="ln4789">      if (list_stack == NULL) {</a>
<a name="ln4790">        abort = set_ref_in_list(ll, copyID, ht_stack);</a>
<a name="ln4791">      } else {</a>
<a name="ln4792">        list_stack_T *const newitem = xmalloc(sizeof(list_stack_T));</a>
<a name="ln4793">        newitem-&gt;list = ll;</a>
<a name="ln4794">        newitem-&gt;prev = *list_stack;</a>
<a name="ln4795">        *list_stack = newitem;</a>
<a name="ln4796">      }</a>
<a name="ln4797">    }</a>
<a name="ln4798">    break;</a>
<a name="ln4799">  }</a>
<a name="ln4800"> </a>
<a name="ln4801">  case VAR_PARTIAL: {</a>
<a name="ln4802">    partial_T *pt = tv-&gt;vval.v_partial;</a>
<a name="ln4803"> </a>
<a name="ln4804">    // A partial does not have a copyID, because it cannot contain itself.</a>
<a name="ln4805">    if (pt != NULL) {</a>
<a name="ln4806">      abort = set_ref_in_func(pt-&gt;pt_name, pt-&gt;pt_func, copyID);</a>
<a name="ln4807">      if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln4808">        typval_T dtv;</a>
<a name="ln4809"> </a>
<a name="ln4810">        dtv.v_type = VAR_DICT;</a>
<a name="ln4811">        dtv.vval.v_dict = pt-&gt;pt_dict;</a>
<a name="ln4812">        abort = abort || set_ref_in_item(&amp;dtv, copyID, ht_stack, list_stack);</a>
<a name="ln4813">      }</a>
<a name="ln4814"> </a>
<a name="ln4815">      for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln4816">        abort = abort || set_ref_in_item(&amp;pt-&gt;pt_argv[i], copyID,</a>
<a name="ln4817">                                         ht_stack, list_stack);</a>
<a name="ln4818">      }</a>
<a name="ln4819">    }</a>
<a name="ln4820">    break;</a>
<a name="ln4821">  }</a>
<a name="ln4822">  case VAR_FUNC:</a>
<a name="ln4823">    abort = set_ref_in_func(tv-&gt;vval.v_string, NULL, copyID);</a>
<a name="ln4824">    break;</a>
<a name="ln4825">  case VAR_UNKNOWN:</a>
<a name="ln4826">  case VAR_BOOL:</a>
<a name="ln4827">  case VAR_SPECIAL:</a>
<a name="ln4828">  case VAR_FLOAT:</a>
<a name="ln4829">  case VAR_NUMBER:</a>
<a name="ln4830">  case VAR_STRING:</a>
<a name="ln4831">  case VAR_BLOB:</a>
<a name="ln4832">    break;</a>
<a name="ln4833">  }</a>
<a name="ln4834">  return abort;</a>
<a name="ln4835">}</a>
<a name="ln4836"> </a>
<a name="ln4837">/// Mark all lists and dicts referenced in given mark</a>
<a name="ln4838">///</a>
<a name="ln4839">/// @return  true if setting references failed somehow.</a>
<a name="ln4840">static inline bool set_ref_in_fmark(fmark_T fm, int copyID)</a>
<a name="ln4841">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4842">{</a>
<a name="ln4843">  if (fm.additional_data != NULL</a>
<a name="ln4844">      &amp;&amp; fm.additional_data-&gt;dv_copyID != copyID) {</a>
<a name="ln4845">    fm.additional_data-&gt;dv_copyID = copyID;</a>
<a name="ln4846">    return set_ref_in_ht(&amp;fm.additional_data-&gt;dv_hashtab, copyID, NULL);</a>
<a name="ln4847">  }</a>
<a name="ln4848">  return false;</a>
<a name="ln4849">}</a>
<a name="ln4850"> </a>
<a name="ln4851">/// Mark all lists and dicts referenced in given list and the list itself</a>
<a name="ln4852">///</a>
<a name="ln4853">/// @return  true if setting references failed somehow.</a>
<a name="ln4854">static inline bool set_ref_list(list_T *list, int copyID)</a>
<a name="ln4855">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4856">{</a>
<a name="ln4857">  if (list != NULL) {</a>
<a name="ln4858">    typval_T tv = (typval_T) {</a>
<a name="ln4859">      .v_type = VAR_LIST,</a>
<a name="ln4860">      .vval = { .v_list = list }</a>
<a name="ln4861">    };</a>
<a name="ln4862">    return set_ref_in_item(&amp;tv, copyID, NULL, NULL);</a>
<a name="ln4863">  }</a>
<a name="ln4864">  return false;</a>
<a name="ln4865">}</a>
<a name="ln4866"> </a>
<a name="ln4867">/// Mark all lists and dicts referenced in given dict and the dict itself</a>
<a name="ln4868">///</a>
<a name="ln4869">/// @return  true if setting references failed somehow.</a>
<a name="ln4870">static inline bool set_ref_dict(dict_T *dict, int copyID)</a>
<a name="ln4871">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4872">{</a>
<a name="ln4873">  if (dict != NULL) {</a>
<a name="ln4874">    typval_T tv = (typval_T) {</a>
<a name="ln4875">      .v_type = VAR_DICT,</a>
<a name="ln4876">      .vval = { .v_dict = dict }</a>
<a name="ln4877">    };</a>
<a name="ln4878">    return set_ref_in_item(&amp;tv, copyID, NULL, NULL);</a>
<a name="ln4879">  }</a>
<a name="ln4880">  return false;</a>
<a name="ln4881">}</a>
<a name="ln4882"> </a>
<a name="ln4883">/// Get the key for #{key: val} into &quot;tv&quot; and advance &quot;arg&quot;.</a>
<a name="ln4884">///</a>
<a name="ln4885">/// @return  FAIL when there is no valid key.</a>
<a name="ln4886">static int get_literal_key(char **arg, typval_T *tv)</a>
<a name="ln4887">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4888">{</a>
<a name="ln4889">  char *p;</a>
<a name="ln4890"> </a>
<a name="ln4891">  if (!ASCII_ISALNUM(**arg) &amp;&amp; **arg != '_' &amp;&amp; **arg != '-') {</a>
<a name="ln4892">    return FAIL;</a>
<a name="ln4893">  }</a>
<a name="ln4894">  for (p = *arg; ASCII_ISALNUM(*p) || *p == '_' || *p == '-'; p++) {}</a>
<a name="ln4895">  tv-&gt;v_type = VAR_STRING;</a>
<a name="ln4896">  tv-&gt;vval.v_string = xmemdupz(*arg, (size_t)(p - *arg));</a>
<a name="ln4897"> </a>
<a name="ln4898">  *arg = skipwhite(p);</a>
<a name="ln4899">  return OK;</a>
<a name="ln4900">}</a>
<a name="ln4901"> </a>
<a name="ln4902">/// Allocate a variable for a Dictionary and fill it from &quot;*arg&quot;.</a>
<a name="ln4903">///</a>
<a name="ln4904">/// @param arg  &quot;*arg&quot; points to the &quot;{&quot;.</a>
<a name="ln4905">/// @param literal  true for #{key: val}</a>
<a name="ln4906">///</a>
<a name="ln4907">/// @return  OK or FAIL.  Returns NOTDONE for {expr}.</a>
<a name="ln4908">static int eval_dict(char **arg, typval_T *rettv, evalarg_T *const evalarg, bool literal)</a>
<a name="ln4909">{</a>
<a name="ln4910">  const bool evaluate = evalarg == NULL ? false : evalarg-&gt;eval_flags &amp; EVAL_EVALUATE;</a>
<a name="ln4911">  typval_T tv;</a>
<a name="ln4912">  char *key = NULL;</a>
<a name="ln4913">  char *curly_expr = skipwhite(*arg + 1);</a>
<a name="ln4914">  char buf[NUMBUFLEN];</a>
<a name="ln4915"> </a>
<a name="ln4916">  // First check if it's not a curly-braces expression: {expr}.</a>
<a name="ln4917">  // Must do this without evaluating, otherwise a function may be called</a>
<a name="ln4918">  // twice.  Unfortunately this means we need to call eval1() twice for the</a>
<a name="ln4919">  // first item.</a>
<a name="ln4920">  // &quot;{}&quot; is an empty Dictionary.</a>
<a name="ln4921">  // &quot;#{abc}&quot; is never a curly-braces expression.</a>
<a name="ln4922">  if (*curly_expr != '}'</a>
<a name="ln4923">      &amp;&amp; !literal</a>
<a name="ln4924">      &amp;&amp; eval1(&amp;curly_expr, &amp;tv, NULL) == OK</a>
<a name="ln4925">      &amp;&amp; *skipwhite(curly_expr) == '}') {</a>
<a name="ln4926">    return NOTDONE;</a>
<a name="ln4927">  }</a>
<a name="ln4928"> </a>
<a name="ln4929">  dict_T *d = NULL;</a>
<a name="ln4930">  if (evaluate) {</a>
<a name="ln4931">    d = tv_dict_alloc();</a>
<a name="ln4932">  }</a>
<a name="ln4933">  typval_T tvkey;</a>
<a name="ln4934">  tvkey.v_type = VAR_UNKNOWN;</a>
<a name="ln4935">  tv.v_type = VAR_UNKNOWN;</a>
<a name="ln4936"> </a>
<a name="ln4937">  *arg = skipwhite(*arg + 1);</a>
<a name="ln4938">  while (**arg != '}' &amp;&amp; **arg != NUL) {</a>
<a name="ln4939">    if ((literal</a>
<a name="ln4940">         ? get_literal_key(arg, &amp;tvkey)</a>
<a name="ln4941">         : eval1(arg, &amp;tvkey, evalarg)) == FAIL) {  // recursive!</a>
<a name="ln4942">      goto failret;</a>
<a name="ln4943">    }</a>
<a name="ln4944">    if (**arg != ':') {</a>
<a name="ln4945">      semsg(_(&quot;E720: Missing colon in Dictionary: %s&quot;), *arg);</a>
<a name="ln4946">      tv_clear(&amp;tvkey);</a>
<a name="ln4947">      goto failret;</a>
<a name="ln4948">    }</a>
<a name="ln4949">    if (evaluate) {</a>
<a name="ln4950">      key = (char *)tv_get_string_buf_chk(&amp;tvkey, buf);</a>
<a name="ln4951">      if (key == NULL) {</a>
<a name="ln4952">        // &quot;key&quot; is NULL when tv_get_string_buf_chk() gave an errmsg</a>
<a name="ln4953">        tv_clear(&amp;tvkey);</a>
<a name="ln4954">        goto failret;</a>
<a name="ln4955">      }</a>
<a name="ln4956">    }</a>
<a name="ln4957"> </a>
<a name="ln4958">    *arg = skipwhite(*arg + 1);</a>
<a name="ln4959">    if (eval1(arg, &amp;tv, evalarg) == FAIL) {  // Recursive!</a>
<a name="ln4960">      if (evaluate) {</a>
<a name="ln4961">        tv_clear(&amp;tvkey);</a>
<a name="ln4962">      }</a>
<a name="ln4963">      goto failret;</a>
<a name="ln4964">    }</a>
<a name="ln4965">    if (evaluate) {</a>
<a name="ln4966">      dictitem_T *item = tv_dict_find(d, key, -1);</a>
<a name="ln4967">      if (item != NULL) {</a>
<a name="ln4968">        semsg(_(&quot;E721: Duplicate key in Dictionary: \&quot;%s\&quot;&quot;), key);</a>
<a name="ln4969">        tv_clear(&amp;tvkey);</a>
<a name="ln4970">        tv_clear(&amp;tv);</a>
<a name="ln4971">        goto failret;</a>
<a name="ln4972">      }</a>
<a name="ln4973">      item = tv_dict_item_alloc(key);</a>
<a name="ln4974">      item-&gt;di_tv = tv;</a>
<a name="ln4975">      item-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln4976">      if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln4977">        tv_dict_item_free(item);</a>
<a name="ln4978">      }</a>
<a name="ln4979">    }</a>
<a name="ln4980">    tv_clear(&amp;tvkey);</a>
<a name="ln4981"> </a>
<a name="ln4982">    // the comma must come after the value</a>
<a name="ln4983">    bool had_comma = **arg == ',';</a>
<a name="ln4984">    if (had_comma) {</a>
<a name="ln4985">      *arg = skipwhite(*arg + 1);</a>
<a name="ln4986">    }</a>
<a name="ln4987"> </a>
<a name="ln4988">    if (**arg == '}') {</a>
<a name="ln4989">      break;</a>
<a name="ln4990">    }</a>
<a name="ln4991">    if (!had_comma) {</a>
<a name="ln4992">      semsg(_(&quot;E722: Missing comma in Dictionary: %s&quot;), *arg);</a>
<a name="ln4993">      goto failret;</a>
<a name="ln4994">    }</a>
<a name="ln4995">  }</a>
<a name="ln4996"> </a>
<a name="ln4997">  if (**arg != '}') {</a>
<a name="ln4998">    semsg(_(&quot;E723: Missing end of Dictionary '}': %s&quot;), *arg);</a>
<a name="ln4999">failret:</a>
<a name="ln5000">    if (d != NULL) {</a>
<a name="ln5001">      tv_dict_free(d);</a>
<a name="ln5002">    }</a>
<a name="ln5003">    return FAIL;</a>
<a name="ln5004">  }</a>
<a name="ln5005"> </a>
<a name="ln5006">  *arg = skipwhite(*arg + 1);</a>
<a name="ln5007">  if (evaluate) {</a>
<a name="ln5008">    tv_dict_set_ret(rettv, d);</a>
<a name="ln5009">  }</a>
<a name="ln5010"> </a>
<a name="ln5011">  return OK;</a>
<a name="ln5012">}</a>
<a name="ln5013"> </a>
<a name="ln5014">/// Convert the string to a floating point number</a>
<a name="ln5015">///</a>
<a name="ln5016">/// This uses strtod().  setlocale(LC_NUMERIC, &quot;C&quot;) has been used earlier to</a>
<a name="ln5017">/// make sure this always uses a decimal point.</a>
<a name="ln5018">///</a>
<a name="ln5019">/// @param[in] text  String to convert.</a>
<a name="ln5020">/// @param[out] ret_value  Location where conversion result is saved.</a>
<a name="ln5021">///</a>
<a name="ln5022">/// @return  Length of the text that was consumed.</a>
<a name="ln5023">size_t string2float(const char *const text, float_T *const ret_value)</a>
<a name="ln5024">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5025">{</a>
<a name="ln5026">  // MS-Windows does not deal with &quot;inf&quot; and &quot;nan&quot; properly</a>
<a name="ln5027">  if (STRNICMP(text, &quot;inf&quot;, 3) == 0) {</a>
<a name="ln5028">    *ret_value = (float_T)INFINITY;</a>
<a name="ln5029">    return 3;</a>
<a name="ln5030">  }</a>
<a name="ln5031">  if (STRNICMP(text, &quot;-inf&quot;, 3) == 0) {</a>
<a name="ln5032">    *ret_value = (float_T) - INFINITY;</a>
<a name="ln5033">    return 4;</a>
<a name="ln5034">  }</a>
<a name="ln5035">  if (STRNICMP(text, &quot;nan&quot;, 3) == 0) {</a>
<a name="ln5036">    *ret_value = (float_T)NAN;</a>
<a name="ln5037">    return 3;</a>
<a name="ln5038">  }</a>
<a name="ln5039">  char *s = NULL;</a>
<a name="ln5040">  *ret_value = strtod(text, &amp;s);</a>
<a name="ln5041">  return (size_t)(s - text);</a>
<a name="ln5042">}</a>
<a name="ln5043"> </a>
<a name="ln5044">/// Get the value of an environment variable.</a>
<a name="ln5045">///</a>
<a name="ln5046">/// If the environment variable was not set, silently assume it is empty.</a>
<a name="ln5047">///</a>
<a name="ln5048">/// @param arg  Points to the '$'.  It is advanced to after the name.</a>
<a name="ln5049">///</a>
<a name="ln5050">/// @return  FAIL if the name is invalid.</a>
<a name="ln5051">static int eval_env_var(char **arg, typval_T *rettv, int evaluate)</a>
<a name="ln5052">{</a>
<a name="ln5053">  (*arg)++;</a>
<a name="ln5054">  char *name = *arg;</a>
<a name="ln5055">  int len = get_env_len((const char **)arg);</a>
<a name="ln5056"> </a>
<a name="ln5057">  if (evaluate) {</a>
<a name="ln5058">    if (len == 0) {</a>
<a name="ln5059">      return FAIL;  // Invalid empty name.</a>
<a name="ln5060">    }</a>
<a name="ln5061">    int cc = (int)name[len];</a>
<a name="ln5062">    name[len] = NUL;</a>
<a name="ln5063">    // First try vim_getenv(), fast for normal environment vars.</a>
<a name="ln5064">    char *string = vim_getenv(name);</a>
<a name="ln5065">    if (string == NULL || *string == NUL) {</a>
<a name="ln5066">      xfree(string);</a>
<a name="ln5067"> </a>
<a name="ln5068">      // Next try expanding things like $VIM and ${HOME}.</a>
<a name="ln5069">      string = expand_env_save(name - 1);</a>
<a name="ln5070">      if (string != NULL &amp;&amp; *string == '$') {</a>
<a name="ln5071">        XFREE_CLEAR(string);</a>
<a name="ln5072">      }</a>
<a name="ln5073">    }</a>
<a name="ln5074">    name[len] = (char)cc;</a>
<a name="ln5075">    rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5076">    rettv-&gt;vval.v_string = string;</a>
<a name="ln5077">    rettv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln5078">  }</a>
<a name="ln5079"> </a>
<a name="ln5080">  return OK;</a>
<a name="ln5081">}</a>
<a name="ln5082"> </a>
<a name="ln5083">/// Add an assert error to v:errors.</a>
<a name="ln5084">void assert_error(garray_T *gap)</a>
<a name="ln5085">{</a>
<a name="ln5086">  struct vimvar *vp = &amp;vimvars[VV_ERRORS];</a>
<a name="ln5087"> </a>
<a name="ln5088">  if (vp-&gt;vv_type != VAR_LIST || vimvars[VV_ERRORS].vv_list == NULL) {</a>
<a name="ln5089">    // Make sure v:errors is a list.</a>
<a name="ln5090">    set_vim_var_list(VV_ERRORS, tv_list_alloc(1));</a>
<a name="ln5091">  }</a>
<a name="ln5092">  tv_list_append_string(vimvars[VV_ERRORS].vv_list, gap-&gt;ga_data, (ptrdiff_t)gap-&gt;ga_len);</a>
<a name="ln5093">}</a>
<a name="ln5094"> </a>
<a name="ln5095">/// Implementation of map() and filter() for a Dict.</a>
<a name="ln5096">static void filter_map_dict(dict_T *d, filtermap_T filtermap, const char *func_name,</a>
<a name="ln5097">                            const char *arg_errmsg, typval_T *expr, typval_T *rettv)</a>
<a name="ln5098">{</a>
<a name="ln5099">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5100">    rettv-&gt;v_type = VAR_DICT;</a>
<a name="ln5101">    rettv-&gt;vval.v_dict = NULL;</a>
<a name="ln5102">  }</a>
<a name="ln5103">  if (d == NULL</a>
<a name="ln5104">      || (filtermap == FILTERMAP_FILTER</a>
<a name="ln5105">          &amp;&amp; value_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5106">    return;</a>
<a name="ln5107">  }</a>
<a name="ln5108"> </a>
<a name="ln5109">  dict_T *d_ret = NULL;</a>
<a name="ln5110"> </a>
<a name="ln5111">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5112">    tv_dict_alloc_ret(rettv);</a>
<a name="ln5113">    d_ret = rettv-&gt;vval.v_dict;</a>
<a name="ln5114">  }</a>
<a name="ln5115"> </a>
<a name="ln5116">  vimvars[VV_KEY].vv_type = VAR_STRING;</a>
<a name="ln5117"> </a>
<a name="ln5118">  const VarLockStatus prev_lock = d-&gt;dv_lock;</a>
<a name="ln5119">  if (d-&gt;dv_lock == VAR_UNLOCKED) {</a>
<a name="ln5120">    d-&gt;dv_lock = VAR_LOCKED;</a>
<a name="ln5121">  }</a>
<a name="ln5122">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln5123">  TV_DICT_ITER(d, di, {</a>
<a name="ln5124">    if (filtermap == FILTERMAP_MAP</a>
<a name="ln5125">        &amp;&amp; (value_check_lock(di-&gt;di_tv.v_lock, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln5126">            || var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5127">      break;</a>
<a name="ln5128">    }</a>
<a name="ln5129">    vimvars[VV_KEY].vv_str = xstrdup(di-&gt;di_key);</a>
<a name="ln5130">    typval_T newtv;</a>
<a name="ln5131">    bool rem;</a>
<a name="ln5132">    int r = filter_map_one(&amp;di-&gt;di_tv, expr, filtermap, &amp;newtv, &amp;rem);</a>
<a name="ln5133">    tv_clear(&amp;vimvars[VV_KEY].vv_tv);</a>
<a name="ln5134">    if (r == FAIL || did_emsg) {</a>
<a name="ln5135">      tv_clear(&amp;newtv);</a>
<a name="ln5136">      break;</a>
<a name="ln5137">    }</a>
<a name="ln5138">    if (filtermap == FILTERMAP_MAP) {</a>
<a name="ln5139">      // map(): replace the dict item value</a>
<a name="ln5140">      tv_clear(&amp;di-&gt;di_tv);</a>
<a name="ln5141">      newtv.v_lock = VAR_UNLOCKED;</a>
<a name="ln5142">      di-&gt;di_tv = newtv;</a>
<a name="ln5143">    } else if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5144">      // mapnew(): add the item value to the new dict</a>
<a name="ln5145">      r = tv_dict_add_tv(d_ret, di-&gt;di_key, strlen(di-&gt;di_key), &amp;newtv);</a>
<a name="ln5146">      tv_clear(&amp;newtv);</a>
<a name="ln5147">      if (r == FAIL) {</a>
<a name="ln5148">        break;</a>
<a name="ln5149">      }</a>
<a name="ln5150">    } else if (filtermap == FILTERMAP_FILTER &amp;&amp; rem) {</a>
<a name="ln5151">      // filter(false): remove the item from the dict</a>
<a name="ln5152">      if (var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln5153">          || var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln5154">        break;</a>
<a name="ln5155">      }</a>
<a name="ln5156">      tv_dict_item_remove(d, di);</a>
<a name="ln5157">    }</a>
<a name="ln5158">  });</a>
<a name="ln5159">  hash_unlock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln5160">  d-&gt;dv_lock = prev_lock;</a>
<a name="ln5161">}</a>
<a name="ln5162"> </a>
<a name="ln5163">/// Implementation of map() and filter() for a Blob.</a>
<a name="ln5164">static void filter_map_blob(blob_T *blob_arg, filtermap_T filtermap, typval_T *expr,</a>
<a name="ln5165">                            const char *arg_errmsg, typval_T *rettv)</a>
<a name="ln5166">{</a>
<a name="ln5167">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5168">    rettv-&gt;v_type = VAR_BLOB;</a>
<a name="ln5169">    rettv-&gt;vval.v_blob = NULL;</a>
<a name="ln5170">  }</a>
<a name="ln5171">  blob_T *b = blob_arg;</a>
<a name="ln5172">  if (b == NULL</a>
<a name="ln5173">      || (filtermap == FILTERMAP_FILTER</a>
<a name="ln5174">          &amp;&amp; value_check_lock(b-&gt;bv_lock, arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5175">    return;</a>
<a name="ln5176">  }</a>
<a name="ln5177"> </a>
<a name="ln5178">  blob_T *b_ret = b;</a>
<a name="ln5179"> </a>
<a name="ln5180">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5181">    tv_blob_copy(b, rettv);</a>
<a name="ln5182">    b_ret = rettv-&gt;vval.v_blob;</a>
<a name="ln5183">  }</a>
<a name="ln5184"> </a>
<a name="ln5185">  vimvars[VV_KEY].vv_type = VAR_NUMBER;</a>
<a name="ln5186"> </a>
<a name="ln5187">  const VarLockStatus prev_lock = b-&gt;bv_lock;</a>
<a name="ln5188">  if (b-&gt;bv_lock == 0) {</a>
<a name="ln5189">    b-&gt;bv_lock = VAR_LOCKED;</a>
<a name="ln5190">  }</a>
<a name="ln5191"> </a>
<a name="ln5192">  for (int i = 0, idx = 0; i &lt; b-&gt;bv_ga.ga_len; i++) {</a>
<a name="ln5193">    const varnumber_T val = tv_blob_get(b, i);</a>
<a name="ln5194">    typval_T tv = {</a>
<a name="ln5195">      .v_type = VAR_NUMBER,</a>
<a name="ln5196">      .v_lock = VAR_UNLOCKED,</a>
<a name="ln5197">      .vval.v_number = val,</a>
<a name="ln5198">    };</a>
<a name="ln5199">    vimvars[VV_KEY].vv_nr = idx;</a>
<a name="ln5200">    typval_T newtv;</a>
<a name="ln5201">    bool rem;</a>
<a name="ln5202">    if (filter_map_one(&amp;tv, expr, filtermap, &amp;newtv, &amp;rem) == FAIL</a>
<a name="ln5203">        || did_emsg) {</a>
<a name="ln5204">      break;</a>
<a name="ln5205">    }</a>
<a name="ln5206">    if (newtv.v_type != VAR_NUMBER &amp;&amp; newtv.v_type != VAR_BOOL) {</a>
<a name="ln5207">      tv_clear(&amp;newtv);</a>
<a name="ln5208">      emsg(_(e_invalblob));</a>
<a name="ln5209">      break;</a>
<a name="ln5210">    }</a>
<a name="ln5211">    if (filtermap != FILTERMAP_FILTER) {</a>
<a name="ln5212">      if (newtv.vval.v_number != val) {</a>
<a name="ln5213">        tv_blob_set(b_ret, i, (uint8_t)newtv.vval.v_number);</a>
<a name="ln5214">      }</a>
<a name="ln5215">    } else if (rem) {</a>
<a name="ln5216">      char *const p = (char *)blob_arg-&gt;bv_ga.ga_data;</a>
<a name="ln5217">      memmove(p + i, p + i + 1, (size_t)(b-&gt;bv_ga.ga_len - i - 1));</a>
<a name="ln5218">      b-&gt;bv_ga.ga_len--;</a>
<a name="ln5219">      i--;</a>
<a name="ln5220">    }</a>
<a name="ln5221">    idx++;</a>
<a name="ln5222">  }</a>
<a name="ln5223"> </a>
<a name="ln5224">  b-&gt;bv_lock = prev_lock;</a>
<a name="ln5225">}</a>
<a name="ln5226"> </a>
<a name="ln5227">/// Implementation of map() and filter() for a String.</a>
<a name="ln5228">static void filter_map_string(const char *str, filtermap_T filtermap, typval_T *expr,</a>
<a name="ln5229">                              typval_T *rettv)</a>
<a name="ln5230">{</a>
<a name="ln5231">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5232">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5233"> </a>
<a name="ln5234">  vimvars[VV_KEY].vv_type = VAR_NUMBER;</a>
<a name="ln5235"> </a>
<a name="ln5236">  garray_T ga;</a>
<a name="ln5237">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln5238">  int len = 0;</a>
<a name="ln5239">  int idx = 0;</a>
<a name="ln5240">  for (const char *p = str; *p != NUL; p += len) {</a>
<a name="ln5241">    len = utfc_ptr2len(p);</a>
<a name="ln5242">    typval_T tv = {</a>
<a name="ln5243">      .v_type = VAR_STRING,</a>
<a name="ln5244">      .v_lock = VAR_UNLOCKED,</a>
<a name="ln5245">      .vval.v_string = xmemdupz(p, (size_t)len),</a>
<a name="ln5246">    };</a>
<a name="ln5247"> </a>
<a name="ln5248">    vimvars[VV_KEY].vv_nr = idx;</a>
<a name="ln5249">    typval_T newtv;</a>
<a name="ln5250">    bool rem;</a>
<a name="ln5251">    if (filter_map_one(&amp;tv, expr, filtermap, &amp;newtv, &amp;rem) == FAIL</a>
<a name="ln5252">        || did_emsg) {</a>
<a name="ln5253">      tv_clear(&amp;newtv);</a>
<a name="ln5254">      tv_clear(&amp;tv);</a>
<a name="ln5255">      break;</a>
<a name="ln5256">    } else if (filtermap != FILTERMAP_FILTER) {</a>
<a name="ln5257">      if (newtv.v_type != VAR_STRING) {</a>
<a name="ln5258">        tv_clear(&amp;newtv);</a>
<a name="ln5259">        tv_clear(&amp;tv);</a>
<a name="ln5260">        emsg(_(e_stringreq));</a>
<a name="ln5261">        break;</a>
<a name="ln5262">      } else {</a>
<a name="ln5263">        ga_concat(&amp;ga, newtv.vval.v_string);</a>
<a name="ln5264">      }</a>
<a name="ln5265">    } else if (!rem) {</a>
<a name="ln5266">      ga_concat(&amp;ga, tv.vval.v_string);</a>
<a name="ln5267">    }</a>
<a name="ln5268"> </a>
<a name="ln5269">    tv_clear(&amp;newtv);</a>
<a name="ln5270">    tv_clear(&amp;tv);</a>
<a name="ln5271"> </a>
<a name="ln5272">    idx++;</a>
<a name="ln5273">  }</a>
<a name="ln5274">  ga_append(&amp;ga, NUL);</a>
<a name="ln5275">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln5276">}</a>
<a name="ln5277"> </a>
<a name="ln5278">/// Implementation of map() and filter() for a List.</a>
<a name="ln5279">static void filter_map_list(list_T *l, filtermap_T filtermap, const char *func_name,</a>
<a name="ln5280">                            const char *arg_errmsg, typval_T *expr, typval_T *rettv)</a>
<a name="ln5281">{</a>
<a name="ln5282">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5283">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5284">    rettv-&gt;vval.v_list = NULL;</a>
<a name="ln5285">  }</a>
<a name="ln5286">  if (l == NULL</a>
<a name="ln5287">      || (filtermap == FILTERMAP_FILTER</a>
<a name="ln5288">          &amp;&amp; value_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE))) {</a>
<a name="ln5289">    return;</a>
<a name="ln5290">  }</a>
<a name="ln5291"> </a>
<a name="ln5292">  list_T *l_ret = NULL;</a>
<a name="ln5293"> </a>
<a name="ln5294">  if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5295">    tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln5296">    l_ret = rettv-&gt;vval.v_list;</a>
<a name="ln5297">  }</a>
<a name="ln5298"> </a>
<a name="ln5299">  vimvars[VV_KEY].vv_type = VAR_NUMBER;</a>
<a name="ln5300"> </a>
<a name="ln5301">  const VarLockStatus prev_lock = tv_list_locked(l);</a>
<a name="ln5302">  if (tv_list_locked(l) == VAR_UNLOCKED) {</a>
<a name="ln5303">    tv_list_set_lock(l, VAR_LOCKED);</a>
<a name="ln5304">  }</a>
<a name="ln5305"> </a>
<a name="ln5306">  int idx = 0;</a>
<a name="ln5307">  for (listitem_T *li = tv_list_first(l); li != NULL;) {</a>
<a name="ln5308">    if (filtermap == FILTERMAP_MAP</a>
<a name="ln5309">        &amp;&amp; value_check_lock(TV_LIST_ITEM_TV(li)-&gt;v_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln5310">      break;</a>
<a name="ln5311">    }</a>
<a name="ln5312">    vimvars[VV_KEY].vv_nr = idx;</a>
<a name="ln5313">    typval_T newtv;</a>
<a name="ln5314">    bool rem;</a>
<a name="ln5315">    if (filter_map_one(TV_LIST_ITEM_TV(li), expr, filtermap, &amp;newtv, &amp;rem) == FAIL) {</a>
<a name="ln5316">      break;</a>
<a name="ln5317">    }</a>
<a name="ln5318">    if (did_emsg) {</a>
<a name="ln5319">      tv_clear(&amp;newtv);</a>
<a name="ln5320">      break;</a>
<a name="ln5321">    }</a>
<a name="ln5322">    if (filtermap == FILTERMAP_MAP) {</a>
<a name="ln5323">      // map(): replace the list item value</a>
<a name="ln5324">      tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln5325">      newtv.v_lock = VAR_UNLOCKED;</a>
<a name="ln5326">      *TV_LIST_ITEM_TV(li) = newtv;</a>
<a name="ln5327">    } else if (filtermap == FILTERMAP_MAPNEW) {</a>
<a name="ln5328">      // mapnew(): append the list item value</a>
<a name="ln5329">      tv_list_append_owned_tv(l_ret, newtv);</a>
<a name="ln5330">    }</a>
<a name="ln5331">    if (filtermap == FILTERMAP_FILTER &amp;&amp; rem) {</a>
<a name="ln5332">      li = tv_list_item_remove(l, li);</a>
<a name="ln5333">    } else {</a>
<a name="ln5334">      li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln5335">    }</a>
<a name="ln5336">    idx++;</a>
<a name="ln5337">  }</a>
<a name="ln5338"> </a>
<a name="ln5339">  tv_list_set_lock(l, prev_lock);</a>
<a name="ln5340">}</a>
<a name="ln5341"> </a>
<a name="ln5342">/// Implementation of map() and filter().</a>
<a name="ln5343">static void filter_map(typval_T *argvars, typval_T *rettv, filtermap_T filtermap)</a>
<a name="ln5344">{</a>
<a name="ln5345">  const char *const func_name = (filtermap == FILTERMAP_MAP</a>
<a name="ln5346">                                 ? &quot;map()&quot;</a>
<a name="ln5347">                                 : (filtermap == FILTERMAP_MAPNEW</a>
<a name="ln5348">                                    ? &quot;mapnew()&quot;</a>
<a name="ln5349">                                    : &quot;filter()&quot;));</a>
<a name="ln5350">  const char *const arg_errmsg = (filtermap == FILTERMAP_MAP</a>
<a name="ln5351">                                  ? N_(&quot;map() argument&quot;)</a>
<a name="ln5352">                                  : (filtermap == FILTERMAP_MAPNEW</a>
<a name="ln5353">                                     ? N_(&quot;mapnew() argument&quot;)</a>
<a name="ln5354">                                     : N_(&quot;filter() argument&quot;)));</a>
<a name="ln5355"> </a>
<a name="ln5356">  // map() and filter() return the first argument, also on failure.</a>
<a name="ln5357">  if (filtermap != FILTERMAP_MAPNEW &amp;&amp; argvars[0].v_type != VAR_STRING) {</a>
<a name="ln5358">    tv_copy(&amp;argvars[0], rettv);</a>
<a name="ln5359">  }</a>
<a name="ln5360"> </a>
<a name="ln5361">  if (argvars[0].v_type != VAR_BLOB</a>
<a name="ln5362">      &amp;&amp; argvars[0].v_type != VAR_LIST</a>
<a name="ln5363">      &amp;&amp; argvars[0].v_type != VAR_DICT</a>
<a name="ln5364">      &amp;&amp; argvars[0].v_type != VAR_STRING) {</a>
<a name="ln5365">    semsg(_(e_argument_of_str_must_be_list_string_dictionary_or_blob), func_name);</a>
<a name="ln5366">    return;</a>
<a name="ln5367">  }</a>
<a name="ln5368"> </a>
<a name="ln5369">  typval_T *expr = &amp;argvars[1];</a>
<a name="ln5370">  // On type errors, the preceding call has already displayed an error</a>
<a name="ln5371">  // message.  Avoid a misleading error message for an empty string that</a>
<a name="ln5372">  // was not passed as argument.</a>
<a name="ln5373">  if (expr-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln5374">    typval_T save_val;</a>
<a name="ln5375">    prepare_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln5376"> </a>
<a name="ln5377">    // We reset &quot;did_emsg&quot; to be able to detect whether an error</a>
<a name="ln5378">    // occurred during evaluation of the expression.</a>
<a name="ln5379">    int save_did_emsg = did_emsg;</a>
<a name="ln5380">    did_emsg = false;</a>
<a name="ln5381"> </a>
<a name="ln5382">    typval_T save_key;</a>
<a name="ln5383">    prepare_vimvar(VV_KEY, &amp;save_key);</a>
<a name="ln5384">    if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln5385">      filter_map_dict(argvars[0].vval.v_dict, filtermap, func_name,</a>
<a name="ln5386">                      arg_errmsg, expr, rettv);</a>
<a name="ln5387">    } else if (argvars[0].v_type == VAR_BLOB) {</a>
<a name="ln5388">      filter_map_blob(argvars[0].vval.v_blob, filtermap, expr, arg_errmsg, rettv);</a>
<a name="ln5389">    } else if (argvars[0].v_type == VAR_STRING) {</a>
<a name="ln5390">      filter_map_string(tv_get_string(&amp;argvars[0]), filtermap, expr, rettv);</a>
<a name="ln5391">    } else {</a>
<a name="ln5392">      assert(argvars[0].v_type == VAR_LIST);</a>
<a name="ln5393">      filter_map_list(argvars[0].vval.v_list, filtermap, func_name,</a>
<a name="ln5394">                      arg_errmsg, expr, rettv);</a>
<a name="ln5395">    }</a>
<a name="ln5396"> </a>
<a name="ln5397">    restore_vimvar(VV_KEY, &amp;save_key);</a>
<a name="ln5398">    restore_vimvar(VV_VAL, &amp;save_val);</a>
<a name="ln5399"> </a>
<a name="ln5400">    did_emsg |= save_did_emsg;</a>
<a name="ln5401">  }</a>
<a name="ln5402">}</a>
<a name="ln5403"> </a>
<a name="ln5404">/// Handle one item for map() and filter().</a>
<a name="ln5405">/// Sets v:val to &quot;tv&quot;.  Caller must set v:key.</a>
<a name="ln5406">///</a>
<a name="ln5407">/// @param tv     original value</a>
<a name="ln5408">/// @param expr   callback</a>
<a name="ln5409">/// @param newtv  for map() an mapnew(): new value</a>
<a name="ln5410">/// @param remp   for filter(): remove flag</a>
<a name="ln5411">static int filter_map_one(typval_T *tv, typval_T *expr, const filtermap_T filtermap,</a>
<a name="ln5412">                          typval_T *newtv, bool *remp)</a>
<a name="ln5413">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5414">{</a>
<a name="ln5415">  typval_T argv[3];</a>
<a name="ln5416">  int retval = FAIL;</a>
<a name="ln5417"> </a>
<a name="ln5418">  tv_copy(tv, &amp;vimvars[VV_VAL].vv_tv);</a>
<a name="ln5419">  argv[0] = vimvars[VV_KEY].vv_tv;</a>
<a name="ln5420">  argv[1] = vimvars[VV_VAL].vv_tv;</a>
<a name="ln5421">  if (eval_expr_typval(expr, false, argv, 2, newtv) == FAIL) {</a>
<a name="ln5422">    goto theend;</a>
<a name="ln5423">  }</a>
<a name="ln5424">  if (filtermap == FILTERMAP_FILTER) {</a>
<a name="ln5425">    bool error = false;</a>
<a name="ln5426"> </a>
<a name="ln5427">    // filter(): when expr is zero remove the item</a>
<a name="ln5428">    *remp = (tv_get_number_chk(newtv, &amp;error) == 0);</a>
<a name="ln5429">    tv_clear(newtv);</a>
<a name="ln5430">    // On type error, nothing has been removed; return FAIL to stop the</a>
<a name="ln5431">    // loop.  The error message was given by tv_get_number_chk().</a>
<a name="ln5432">    if (error) {</a>
<a name="ln5433">      goto theend;</a>
<a name="ln5434">    }</a>
<a name="ln5435">  }</a>
<a name="ln5436">  retval = OK;</a>
<a name="ln5437">theend:</a>
<a name="ln5438">  tv_clear(&amp;vimvars[VV_VAL].vv_tv);</a>
<a name="ln5439">  return retval;</a>
<a name="ln5440">}</a>
<a name="ln5441"> </a>
<a name="ln5442">/// &quot;filter()&quot; function</a>
<a name="ln5443">void f_filter(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln5444">{</a>
<a name="ln5445">  filter_map(argvars, rettv, FILTERMAP_FILTER);</a>
<a name="ln5446">}</a>
<a name="ln5447"> </a>
<a name="ln5448">/// &quot;map()&quot; function</a>
<a name="ln5449">void f_map(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln5450">{</a>
<a name="ln5451">  filter_map(argvars, rettv, FILTERMAP_MAP);</a>
<a name="ln5452">}</a>
<a name="ln5453"> </a>
<a name="ln5454">/// &quot;mapnew()&quot; function</a>
<a name="ln5455">void f_mapnew(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln5456">{</a>
<a name="ln5457">  filter_map(argvars, rettv, FILTERMAP_MAPNEW);</a>
<a name="ln5458">}</a>
<a name="ln5459"> </a>
<a name="ln5460">/// &quot;function()&quot; function</a>
<a name="ln5461">/// &quot;funcref()&quot; function</a>
<a name="ln5462">void common_function(typval_T *argvars, typval_T *rettv, bool is_funcref)</a>
<a name="ln5463">{</a>
<a name="ln5464">  char *s;</a>
<a name="ln5465">  char *name;</a>
<a name="ln5466">  bool use_string = false;</a>
<a name="ln5467">  partial_T *arg_pt = NULL;</a>
<a name="ln5468">  char *trans_name = NULL;</a>
<a name="ln5469"> </a>
<a name="ln5470">  if (argvars[0].v_type == VAR_FUNC) {</a>
<a name="ln5471">    // function(MyFunc, [arg], dict)</a>
<a name="ln5472">    s = argvars[0].vval.v_string;</a>
<a name="ln5473">  } else if (argvars[0].v_type == VAR_PARTIAL</a>
<a name="ln5474">             &amp;&amp; argvars[0].vval.v_partial != NULL) {</a>
<a name="ln5475">    // function(dict.MyFunc, [arg])</a>
<a name="ln5476">    arg_pt = argvars[0].vval.v_partial;</a>
<a name="ln5477">    s = partial_name(arg_pt);</a>
<a name="ln5478">    // TODO(bfredl): do the entire nlua_is_table_from_lua dance</a>
<a name="ln5479">  } else {</a>
<a name="ln5480">    // function('MyFunc', [arg], dict)</a>
<a name="ln5481">    s = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln5482">    use_string = true;</a>
<a name="ln5483">  }</a>
<a name="ln5484"> </a>
<a name="ln5485">  if ((use_string &amp;&amp; vim_strchr(s, AUTOLOAD_CHAR) == NULL) || is_funcref) {</a>
<a name="ln5486">    name = s;</a>
<a name="ln5487">    trans_name = save_function_name(&amp;name, false,</a>
<a name="ln5488">                                    TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD | TFN_NO_DEREF, NULL);</a>
<a name="ln5489">    if (*name != NUL) {</a>
<a name="ln5490">      s = NULL;</a>
<a name="ln5491">    }</a>
<a name="ln5492">  }</a>
<a name="ln5493">  if (s == NULL || *s == NUL || (use_string &amp;&amp; ascii_isdigit(*s))</a>
<a name="ln5494">      || (is_funcref &amp;&amp; trans_name == NULL)) {</a>
<a name="ln5495">    semsg(_(e_invarg2), (use_string ? tv_get_string(&amp;argvars[0]) : s));</a>
<a name="ln5496">    // Don't check an autoload name for existence here.</a>
<a name="ln5497">  } else if (trans_name != NULL</a>
<a name="ln5498">             &amp;&amp; (is_funcref</a>
<a name="ln5499">                 ? find_func(trans_name) == NULL</a>
<a name="ln5500">                 : !translated_function_exists(trans_name))) {</a>
<a name="ln5501">    semsg(_(&quot;E700: Unknown function: %s&quot;), s);</a>
<a name="ln5502">  } else {</a>
<a name="ln5503">    int dict_idx = 0;</a>
<a name="ln5504">    int arg_idx = 0;</a>
<a name="ln5505">    list_T *list = NULL;</a>
<a name="ln5506">    if (strncmp(s, &quot;s:&quot;, 2) == 0 || strncmp(s, &quot;&lt;SID&gt;&quot;, 5) == 0) {</a>
<a name="ln5507">      // Expand s: and &lt;SID&gt; into &lt;SNR&gt;nr_, so that the function can</a>
<a name="ln5508">      // also be called from another script. Using trans_function_name()</a>
<a name="ln5509">      // would also work, but some plugins depend on the name being</a>
<a name="ln5510">      // printable text.</a>
<a name="ln5511">      name = get_scriptlocal_funcname(s);</a>
<a name="ln5512">    } else {</a>
<a name="ln5513">      name = xstrdup(s);</a>
<a name="ln5514">    }</a>
<a name="ln5515"> </a>
<a name="ln5516">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5517">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5518">        // function(name, [args], dict)</a>
<a name="ln5519">        arg_idx = 1;</a>
<a name="ln5520">        dict_idx = 2;</a>
<a name="ln5521">      } else if (argvars[1].v_type == VAR_DICT) {</a>
<a name="ln5522">        // function(name, dict)</a>
<a name="ln5523">        dict_idx = 1;</a>
<a name="ln5524">      } else {</a>
<a name="ln5525">        // function(name, [args])</a>
<a name="ln5526">        arg_idx = 1;</a>
<a name="ln5527">      }</a>
<a name="ln5528">      if (dict_idx &gt; 0) {</a>
<a name="ln5529">        if (tv_check_for_dict_arg(argvars, dict_idx) == FAIL) {</a>
<a name="ln5530">          xfree(name);</a>
<a name="ln5531">          goto theend;</a>
<a name="ln5532">        }</a>
<a name="ln5533">        if (argvars[dict_idx].vval.v_dict == NULL) {</a>
<a name="ln5534">          dict_idx = 0;</a>
<a name="ln5535">        }</a>
<a name="ln5536">      }</a>
<a name="ln5537">      if (arg_idx &gt; 0) {</a>
<a name="ln5538">        if (argvars[arg_idx].v_type != VAR_LIST) {</a>
<a name="ln5539">          emsg(_(&quot;E923: Second argument of function() must be &quot;</a>
<a name="ln5540">                 &quot;a list or a dict&quot;));</a>
<a name="ln5541">          xfree(name);</a>
<a name="ln5542">          goto theend;</a>
<a name="ln5543">        }</a>
<a name="ln5544">        list = argvars[arg_idx].vval.v_list;</a>
<a name="ln5545">        if (tv_list_len(list) == 0) {</a>
<a name="ln5546">          arg_idx = 0;</a>
<a name="ln5547">        } else if (tv_list_len(list) &gt; MAX_FUNC_ARGS) {</a>
<a name="ln5548">          emsg_funcname(e_toomanyarg, s);</a>
<a name="ln5549">          xfree(name);</a>
<a name="ln5550">          goto theend;</a>
<a name="ln5551">        }</a>
<a name="ln5552">      }</a>
<a name="ln5553">    }</a>
<a name="ln5554">    if (dict_idx &gt; 0 || arg_idx &gt; 0 || arg_pt != NULL || is_funcref) {</a>
<a name="ln5555">      partial_T *const pt = xcalloc(1, sizeof(*pt));</a>
<a name="ln5556"> </a>
<a name="ln5557">      // result is a VAR_PARTIAL</a>
<a name="ln5558">      if (arg_idx &gt; 0 || (arg_pt != NULL &amp;&amp; arg_pt-&gt;pt_argc &gt; 0)) {</a>
<a name="ln5559">        const int arg_len = (arg_pt == NULL ? 0 : arg_pt-&gt;pt_argc);</a>
<a name="ln5560">        const int lv_len = tv_list_len(list);</a>
<a name="ln5561"> </a>
<a name="ln5562">        pt-&gt;pt_argc = arg_len + lv_len;</a>
<a name="ln5563">        pt-&gt;pt_argv = xmalloc(sizeof(pt-&gt;pt_argv[0]) * (size_t)pt-&gt;pt_argc);</a>
<a name="ln5564">        int i = 0;</a>
<a name="ln5565">        for (; i &lt; arg_len; i++) {</a>
<a name="ln5566">          tv_copy(&amp;arg_pt-&gt;pt_argv[i], &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln5567">        }</a>
<a name="ln5568">        if (lv_len &gt; 0) {</a>
<a name="ln5569">          TV_LIST_ITER(list, li, {</a>
<a name="ln5570">            tv_copy(TV_LIST_ITEM_TV(li), &amp;pt-&gt;pt_argv[i++]);</a>
<a name="ln5571">          });</a>
<a name="ln5572">        }</a>
<a name="ln5573">      }</a>
<a name="ln5574"> </a>
<a name="ln5575">      // For &quot;function(dict.func, [], dict)&quot; and &quot;func&quot; is a partial</a>
<a name="ln5576">      // use &quot;dict&quot;. That is backwards compatible.</a>
<a name="ln5577">      if (dict_idx &gt; 0) {</a>
<a name="ln5578">        // The dict is bound explicitly, pt_auto is false</a>
<a name="ln5579">        pt-&gt;pt_dict = argvars[dict_idx].vval.v_dict;</a>
<a name="ln5580">        (pt-&gt;pt_dict-&gt;dv_refcount)++;</a>
<a name="ln5581">      } else if (arg_pt != NULL) {</a>
<a name="ln5582">        // If the dict was bound automatically the result is also</a>
<a name="ln5583">        // bound automatically.</a>
<a name="ln5584">        pt-&gt;pt_dict = arg_pt-&gt;pt_dict;</a>
<a name="ln5585">        pt-&gt;pt_auto = arg_pt-&gt;pt_auto;</a>
<a name="ln5586">        if (pt-&gt;pt_dict != NULL) {</a>
<a name="ln5587">          (pt-&gt;pt_dict-&gt;dv_refcount)++;</a>
<a name="ln5588">        }</a>
<a name="ln5589">      }</a>
<a name="ln5590"> </a>
<a name="ln5591">      pt-&gt;pt_refcount = 1;</a>
<a name="ln5592">      if (arg_pt != NULL &amp;&amp; arg_pt-&gt;pt_func != NULL) {</a>
<a name="ln5593">        pt-&gt;pt_func = arg_pt-&gt;pt_func;</a>
<a name="ln5594">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln5595">        xfree(name);</a>
<a name="ln5596">      } else if (is_funcref) {</a>
<a name="ln5597">        pt-&gt;pt_func = find_func(trans_name);</a>
<a name="ln5598">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln5599">        xfree(name);</a>
<a name="ln5600">      } else {</a>
<a name="ln5601">        pt-&gt;pt_name = name;</a>
<a name="ln5602">        func_ref(name);</a>
<a name="ln5603">      }</a>
<a name="ln5604"> </a>
<a name="ln5605">      rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln5606">      rettv-&gt;vval.v_partial = pt;</a>
<a name="ln5607">    } else {</a>
<a name="ln5608">      // result is a VAR_FUNC</a>
<a name="ln5609">      rettv-&gt;v_type = VAR_FUNC;</a>
<a name="ln5610">      rettv-&gt;vval.v_string = name;</a>
<a name="ln5611">      func_ref(name);</a>
<a name="ln5612">    }</a>
<a name="ln5613">  }</a>
<a name="ln5614">theend:</a>
<a name="ln5615">  xfree(trans_name);</a>
<a name="ln5616">}</a>
<a name="ln5617"> </a>
<a name="ln5618">/// Get the line number from Vimscript object</a>
<a name="ln5619">///</a>
<a name="ln5620">/// @note Unlike tv_get_lnum(), this one supports only &quot;$&quot; special string.</a>
<a name="ln5621">///</a>
<a name="ln5622">/// @param[in] tv   Object to get value from. Is expected to be a number or</a>
<a name="ln5623">///                 a special string &quot;$&quot;.</a>
<a name="ln5624">/// @param[in] buf  Buffer to take last line number from in case tv is &quot;$&quot;. May</a>
<a name="ln5625">///                 be NULL, in this case &quot;$&quot; results in zero return.</a>
<a name="ln5626">///</a>
<a name="ln5627">/// @return  Line number or 0 in case of error.</a>
<a name="ln5628">linenr_T tv_get_lnum_buf(const typval_T *const tv, const buf_T *const buf)</a>
<a name="ln5629">  FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5630">{</a>
<a name="ln5631">  if (tv-&gt;v_type == VAR_STRING</a>
<a name="ln5632">      &amp;&amp; tv-&gt;vval.v_string != NULL</a>
<a name="ln5633">      &amp;&amp; tv-&gt;vval.v_string[0] == '$'</a>
<a name="ln5634">      &amp;&amp; tv-&gt;vval.v_string[1] == NUL</a>
<a name="ln5635">      &amp;&amp; buf != NULL) {</a>
<a name="ln5636">    return buf-&gt;b_ml.ml_line_count;</a>
<a name="ln5637">  }</a>
<a name="ln5638">  return (linenr_T)tv_get_number_chk(tv, NULL);</a>
<a name="ln5639">}</a>
<a name="ln5640"> </a>
<a name="ln5641">/// This function is used by f_input() and f_inputdialog() functions. The third</a>
<a name="ln5642">/// argument to f_input() specifies the type of completion to use at the</a>
<a name="ln5643">/// prompt. The third argument to f_inputdialog() specifies the value to return</a>
<a name="ln5644">/// when the user cancels the prompt.</a>
<a name="ln5645">void get_user_input(const typval_T *const argvars, typval_T *const rettv, const bool inputdialog,</a>
<a name="ln5646">                    const bool secret)</a>
<a name="ln5647">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5648">{</a>
<a name="ln5649">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5650">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5651"> </a>
<a name="ln5652">  const char *prompt;</a>
<a name="ln5653">  const char *defstr = &quot;&quot;;</a>
<a name="ln5654">  typval_T *cancelreturn = NULL;</a>
<a name="ln5655">  typval_T cancelreturn_strarg2 = TV_INITIAL_VALUE;</a>
<a name="ln5656">  const char *xp_name = NULL;</a>
<a name="ln5657">  Callback input_callback = { .type = kCallbackNone };</a>
<a name="ln5658">  char prompt_buf[NUMBUFLEN];</a>
<a name="ln5659">  char defstr_buf[NUMBUFLEN];</a>
<a name="ln5660">  char cancelreturn_buf[NUMBUFLEN];</a>
<a name="ln5661">  char xp_name_buf[NUMBUFLEN];</a>
<a name="ln5662">  char def[1] = { 0 };</a>
<a name="ln5663">  if (argvars[0].v_type == VAR_DICT) {</a>
<a name="ln5664">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5665">      emsg(_(&quot;E5050: {opts} must be the only argument&quot;));</a>
<a name="ln5666">      return;</a>
<a name="ln5667">    }</a>
<a name="ln5668">    dict_T *const dict = argvars[0].vval.v_dict;</a>
<a name="ln5669">    prompt = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;prompt&quot;), prompt_buf, &quot;&quot;);</a>
<a name="ln5670">    if (prompt == NULL) {</a>
<a name="ln5671">      return;</a>
<a name="ln5672">    }</a>
<a name="ln5673">    defstr = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;default&quot;), defstr_buf, &quot;&quot;);</a>
<a name="ln5674">    if (defstr == NULL) {</a>
<a name="ln5675">      return;</a>
<a name="ln5676">    }</a>
<a name="ln5677">    dictitem_T *cancelreturn_di = tv_dict_find(dict, S_LEN(&quot;cancelreturn&quot;));</a>
<a name="ln5678">    if (cancelreturn_di != NULL) {</a>
<a name="ln5679">      cancelreturn = &amp;cancelreturn_di-&gt;di_tv;</a>
<a name="ln5680">    }</a>
<a name="ln5681">    xp_name = tv_dict_get_string_buf_chk(dict, S_LEN(&quot;completion&quot;),</a>
<a name="ln5682">                                         xp_name_buf, def);</a>
<a name="ln5683">    if (xp_name == NULL) {  // error</a>
<a name="ln5684">      return;</a>
<a name="ln5685">    }</a>
<a name="ln5686">    if (xp_name == def) {  // default to NULL</a>
<a name="ln5687">      xp_name = NULL;</a>
<a name="ln5688">    }</a>
<a name="ln5689">    if (!tv_dict_get_callback(dict, S_LEN(&quot;highlight&quot;), &amp;input_callback)) {</a>
<a name="ln5690">      return;</a>
<a name="ln5691">    }</a>
<a name="ln5692">  } else {</a>
<a name="ln5693">    prompt = tv_get_string_buf_chk(&amp;argvars[0], prompt_buf);</a>
<a name="ln5694">    if (prompt == NULL) {</a>
<a name="ln5695">      return;</a>
<a name="ln5696">    }</a>
<a name="ln5697">    if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln5698">      defstr = tv_get_string_buf_chk(&amp;argvars[1], defstr_buf);</a>
<a name="ln5699">      if (defstr == NULL) {</a>
<a name="ln5700">        return;</a>
<a name="ln5701">      }</a>
<a name="ln5702">      if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5703">        const char *const strarg2 = tv_get_string_buf_chk(&amp;argvars[2], cancelreturn_buf);</a>
<a name="ln5704">        if (strarg2 == NULL) {</a>
<a name="ln5705">          return;</a>
<a name="ln5706">        }</a>
<a name="ln5707">        if (inputdialog) {</a>
<a name="ln5708">          cancelreturn_strarg2.v_type = VAR_STRING;</a>
<a name="ln5709">          cancelreturn_strarg2.vval.v_string = (char *)strarg2;</a>
<a name="ln5710">          cancelreturn = &amp;cancelreturn_strarg2;</a>
<a name="ln5711">        } else {</a>
<a name="ln5712">          xp_name = strarg2;</a>
<a name="ln5713">        }</a>
<a name="ln5714">      }</a>
<a name="ln5715">    }</a>
<a name="ln5716">  }</a>
<a name="ln5717"> </a>
<a name="ln5718">  int xp_type = EXPAND_NOTHING;</a>
<a name="ln5719">  char *xp_arg = NULL;</a>
<a name="ln5720">  if (xp_name != NULL) {</a>
<a name="ln5721">    // input() with a third argument: completion</a>
<a name="ln5722">    const int xp_namelen = (int)strlen(xp_name);</a>
<a name="ln5723"> </a>
<a name="ln5724">    uint32_t argt = 0;</a>
<a name="ln5725">    if (parse_compl_arg(xp_name, xp_namelen, &amp;xp_type,</a>
<a name="ln5726">                        &amp;argt, &amp;xp_arg) == FAIL) {</a>
<a name="ln5727">      return;</a>
<a name="ln5728">    }</a>
<a name="ln5729">  }</a>
<a name="ln5730"> </a>
<a name="ln5731">  const bool cmd_silent_save = cmd_silent;</a>
<a name="ln5732"> </a>
<a name="ln5733">  cmd_silent = false;  // Want to see the prompt.</a>
<a name="ln5734">  // Only the part of the message after the last NL is considered as</a>
<a name="ln5735">  // prompt for the command line, unlsess cmdline is externalized</a>
<a name="ln5736">  const char *p = prompt;</a>
<a name="ln5737">  if (!ui_has(kUICmdline)) {</a>
<a name="ln5738">    const char *lastnl = strrchr(prompt, '\n');</a>
<a name="ln5739">    if (lastnl != NULL) {</a>
<a name="ln5740">      p = lastnl + 1;</a>
<a name="ln5741">      msg_start();</a>
<a name="ln5742">      msg_clr_eos();</a>
<a name="ln5743">      msg_puts_len(prompt, p - prompt, echo_attr);</a>
<a name="ln5744">      msg_didout = false;</a>
<a name="ln5745">      msg_starthere();</a>
<a name="ln5746">    }</a>
<a name="ln5747">  }</a>
<a name="ln5748">  cmdline_row = msg_row;</a>
<a name="ln5749"> </a>
<a name="ln5750">  stuffReadbuffSpec(defstr);</a>
<a name="ln5751"> </a>
<a name="ln5752">  const int save_ex_normal_busy = ex_normal_busy;</a>
<a name="ln5753">  ex_normal_busy = 0;</a>
<a name="ln5754">  rettv-&gt;vval.v_string = getcmdline_prompt(secret ? NUL : '@', p, echo_attr, xp_type, xp_arg,</a>
<a name="ln5755">                                           input_callback);</a>
<a name="ln5756">  ex_normal_busy = save_ex_normal_busy;</a>
<a name="ln5757">  callback_free(&amp;input_callback);</a>
<a name="ln5758"> </a>
<a name="ln5759">  if (rettv-&gt;vval.v_string == NULL &amp;&amp; cancelreturn != NULL) {</a>
<a name="ln5760">    tv_copy(cancelreturn, rettv);</a>
<a name="ln5761">  }</a>
<a name="ln5762"> </a>
<a name="ln5763">  xfree(xp_arg);</a>
<a name="ln5764"> </a>
<a name="ln5765">  // Since the user typed this, no need to wait for return.</a>
<a name="ln5766">  need_wait_return = false;</a>
<a name="ln5767">  msg_didout = false;</a>
<a name="ln5768">  cmd_silent = cmd_silent_save;</a>
<a name="ln5769">}</a>
<a name="ln5770"> </a>
<a name="ln5771">/// Builds a process argument vector from a Vimscript object (typval_T).</a>
<a name="ln5772">///</a>
<a name="ln5773">/// @param[in]  cmd_tv      Vimscript object</a>
<a name="ln5774">/// @param[out] cmd         Returns the command or executable name.</a>
<a name="ln5775">/// @param[out] executable  Returns `false` if argv[0] is not executable.</a>
<a name="ln5776">///</a>
<a name="ln5777">/// @return  Result of `shell_build_argv()` if `cmd_tv` is a String.</a>
<a name="ln5778">///          Else, string values of `cmd_tv` copied to a (char **) list with</a>
<a name="ln5779">///          argv[0] resolved to full path ($PATHEXT-resolved on Windows).</a>
<a name="ln5780">char **tv_to_argv(typval_T *cmd_tv, const char **cmd, bool *executable)</a>
<a name="ln5781">{</a>
<a name="ln5782">  if (cmd_tv-&gt;v_type == VAR_STRING) {  // String =&gt; &quot;shell semantics&quot;.</a>
<a name="ln5783">    const char *cmd_str = tv_get_string(cmd_tv);</a>
<a name="ln5784">    if (cmd) {</a>
<a name="ln5785">      *cmd = cmd_str;</a>
<a name="ln5786">    }</a>
<a name="ln5787">    return shell_build_argv(cmd_str, NULL);</a>
<a name="ln5788">  }</a>
<a name="ln5789"> </a>
<a name="ln5790">  if (cmd_tv-&gt;v_type != VAR_LIST) {</a>
<a name="ln5791">    semsg(_(e_invarg2), &quot;expected String or List&quot;);</a>
<a name="ln5792">    return NULL;</a>
<a name="ln5793">  }</a>
<a name="ln5794"> </a>
<a name="ln5795">  list_T *argl = cmd_tv-&gt;vval.v_list;</a>
<a name="ln5796">  int argc = tv_list_len(argl);</a>
<a name="ln5797">  if (!argc) {</a>
<a name="ln5798">    emsg(_(e_invarg));  // List must have at least one item.</a>
<a name="ln5799">    return NULL;</a>
<a name="ln5800">  }</a>
<a name="ln5801"> </a>
<a name="ln5802">  const char *arg0 = tv_get_string_chk(TV_LIST_ITEM_TV(tv_list_first(argl)));</a>
<a name="ln5803">  char *exe_resolved = NULL;</a>
<a name="ln5804">  if (!arg0 || !os_can_exe(arg0, &amp;exe_resolved, true)) {</a>
<a name="ln5805">    if (arg0 &amp;&amp; executable) {</a>
<a name="ln5806">      char buf[IOSIZE];</a>
<a name="ln5807">      snprintf(buf, sizeof(buf), &quot;'%s' is not executable&quot;, arg0);</a>
<a name="ln5808">      semsg(_(e_invargNval), &quot;cmd&quot;, buf);</a>
<a name="ln5809">      *executable = false;</a>
<a name="ln5810">    }</a>
<a name="ln5811">    return NULL;</a>
<a name="ln5812">  }</a>
<a name="ln5813"> </a>
<a name="ln5814">  if (cmd) {</a>
<a name="ln5815">    *cmd = exe_resolved;</a>
<a name="ln5816">  }</a>
<a name="ln5817"> </a>
<a name="ln5818">  // Build the argument vector</a>
<a name="ln5819">  int i = 0;</a>
<a name="ln5820">  char **argv = xcalloc((size_t)argc + 1, sizeof(char *));</a>
<a name="ln5821">  TV_LIST_ITER_CONST(argl, arg, {</a>
<a name="ln5822">    const char *a = tv_get_string_chk(TV_LIST_ITEM_TV(arg));</a>
<a name="ln5823">    if (!a) {</a>
<a name="ln5824">      // Did emsg in tv_get_string_chk; just deallocate argv.</a>
<a name="ln5825">      shell_free_argv(argv);</a>
<a name="ln5826">      xfree(exe_resolved);</a>
<a name="ln5827">      return NULL;</a>
<a name="ln5828">    }</a>
<a name="ln5829">    argv[i++] = xstrdup(a);</a>
<a name="ln5830">  });</a>
<a name="ln5831">  // Replace argv[0] with absolute path. The only reason for this is to make</a>
<a name="ln5832">  // $PATHEXT work on Windows with jobstart([]). #9569</a>
<a name="ln5833">  xfree(argv[0]);</a>
<a name="ln5834">  argv[0] = exe_resolved;</a>
<a name="ln5835"> </a>
<a name="ln5836">  return argv;</a>
<a name="ln5837">}</a>
<a name="ln5838"> </a>
<a name="ln5839">void return_register(int regname, typval_T *rettv)</a>
<a name="ln5840">{</a>
<a name="ln5841">  char buf[2] = { (char)regname, 0 };</a>
<a name="ln5842"> </a>
<a name="ln5843">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5844">  rettv-&gt;vval.v_string = xstrdup(buf);</a>
<a name="ln5845">}</a>
<a name="ln5846"> </a>
<a name="ln5847">void screenchar_adjust(ScreenGrid **grid, int *row, int *col)</a>
<a name="ln5848">{</a>
<a name="ln5849">  // TODO(bfredl): this is a hack for legacy tests which use screenchar()</a>
<a name="ln5850">  // to check printed messages on the screen (but not floats etc</a>
<a name="ln5851">  // as these are not legacy features). If the compositor is refactored to</a>
<a name="ln5852">  // have its own buffer, this should just read from it instead.</a>
<a name="ln5853">  msg_scroll_flush();</a>
<a name="ln5854"> </a>
<a name="ln5855">  *grid = ui_comp_get_grid_at_coord(*row, *col);</a>
<a name="ln5856"> </a>
<a name="ln5857">  // Make `row` and `col` relative to the grid</a>
<a name="ln5858">  *row -= (*grid)-&gt;comp_row;</a>
<a name="ln5859">  *col -= (*grid)-&gt;comp_col;</a>
<a name="ln5860">}</a>
<a name="ln5861"> </a>
<a name="ln5862">/// &quot;stdpath()&quot; helper for list results</a>
<a name="ln5863">void get_xdg_var_list(const XDGVarType xdg, typval_T *rettv)</a>
<a name="ln5864">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5865">{</a>
<a name="ln5866">  list_T *const list = tv_list_alloc(kListLenShouldKnow);</a>
<a name="ln5867">  rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5868">  rettv-&gt;vval.v_list = list;</a>
<a name="ln5869">  tv_list_ref(list);</a>
<a name="ln5870">  char *const dirs = stdpaths_get_xdg_var(xdg);</a>
<a name="ln5871">  if (dirs == NULL) {</a>
<a name="ln5872">    return;</a>
<a name="ln5873">  }</a>
<a name="ln5874">  const void *iter = NULL;</a>
<a name="ln5875">  const char *appname = get_appname();</a>
<a name="ln5876">  do {</a>
<a name="ln5877">    size_t dir_len;</a>
<a name="ln5878">    const char *dir;</a>
<a name="ln5879">    iter = vim_env_iter(ENV_SEPCHAR, dirs, iter, &amp;dir, &amp;dir_len);</a>
<a name="ln5880">    if (dir != NULL &amp;&amp; dir_len &gt; 0) {</a>
<a name="ln5881">      char *dir_with_nvim = xmemdupz(dir, dir_len);</a>
<a name="ln5882">      dir_with_nvim = concat_fnames_realloc(dir_with_nvim, appname, true);</a>
<a name="ln5883">      tv_list_append_allocated_string(list, dir_with_nvim);</a>
<a name="ln5884">    }</a>
<a name="ln5885">  } while (iter != NULL);</a>
<a name="ln5886">  xfree(dirs);</a>
<a name="ln5887">}</a>
<a name="ln5888"> </a>
<a name="ln5889">static list_T *string_to_list(const char *str, size_t len, const bool keepempty)</a>
<a name="ln5890">{</a>
<a name="ln5891">  if (!keepempty &amp;&amp; str[len - 1] == NL) {</a>
<a name="ln5892">    len--;</a>
<a name="ln5893">  }</a>
<a name="ln5894">  list_T *const list = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln5895">  encode_list_write(list, str, len);</a>
<a name="ln5896">  return list;</a>
<a name="ln5897">}</a>
<a name="ln5898"> </a>
<a name="ln5899">/// os_system wrapper. Handles 'verbose', :profile, and v:shell_error.</a>
<a name="ln5900">void get_system_output_as_rettv(typval_T *argvars, typval_T *rettv, bool retlist)</a>
<a name="ln5901">{</a>
<a name="ln5902">  proftime_T wait_time;</a>
<a name="ln5903">  bool profiling = do_profiling == PROF_YES;</a>
<a name="ln5904"> </a>
<a name="ln5905">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln5906">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln5907"> </a>
<a name="ln5908">  if (check_secure()) {</a>
<a name="ln5909">    return;</a>
<a name="ln5910">  }</a>
<a name="ln5911"> </a>
<a name="ln5912">  // get input to the shell command (if any), and its length</a>
<a name="ln5913">  ptrdiff_t input_len;</a>
<a name="ln5914">  char *input = save_tv_as_string(&amp;argvars[1], &amp;input_len, false, false);</a>
<a name="ln5915">  if (input_len &lt; 0) {</a>
<a name="ln5916">    assert(input == NULL);</a>
<a name="ln5917">    return;</a>
<a name="ln5918">  }</a>
<a name="ln5919"> </a>
<a name="ln5920">  // get shell command to execute</a>
<a name="ln5921">  bool executable = true;</a>
<a name="ln5922">  char **argv = tv_to_argv(&amp;argvars[0], NULL, &amp;executable);</a>
<a name="ln5923">  if (!argv) {</a>
<a name="ln5924">    if (!executable) {</a>
<a name="ln5925">      set_vim_var_nr(VV_SHELL_ERROR, -1);</a>
<a name="ln5926">    }</a>
<a name="ln5927">    xfree(input);</a>
<a name="ln5928">    return;  // Already did emsg.</a>
<a name="ln5929">  }</a>
<a name="ln5930"> </a>
<a name="ln5931">  if (p_verbose &gt; 3) {</a>
<a name="ln5932">    char *cmdstr = shell_argv_to_str(argv);</a>
<a name="ln5933">    verbose_enter_scroll();</a>
<a name="ln5934">    smsg(0, _(&quot;Executing command: \&quot;%s\&quot;&quot;), cmdstr);</a>
<a name="ln5935">    msg_puts(&quot;\n\n&quot;);</a>
<a name="ln5936">    verbose_leave_scroll();</a>
<a name="ln5937">    xfree(cmdstr);</a>
<a name="ln5938">  }</a>
<a name="ln5939"> </a>
<a name="ln5940">  if (profiling) {</a>
<a name="ln5941">    prof_child_enter(&amp;wait_time);</a>
<a name="ln5942">  }</a>
<a name="ln5943"> </a>
<a name="ln5944">  // execute the command</a>
<a name="ln5945">  size_t nread = 0;</a>
<a name="ln5946">  char *res = NULL;</a>
<a name="ln5947">  int status = os_system(argv, input, (size_t)input_len, &amp;res, &amp;nread);</a>
<a name="ln5948"> </a>
<a name="ln5949">  if (profiling) {</a>
<a name="ln5950">    prof_child_exit(&amp;wait_time);</a>
<a name="ln5951">  }</a>
<a name="ln5952"> </a>
<a name="ln5953">  xfree(input);</a>
<a name="ln5954"> </a>
<a name="ln5955">  set_vim_var_nr(VV_SHELL_ERROR, status);</a>
<a name="ln5956"> </a>
<a name="ln5957">  if (res == NULL) {</a>
<a name="ln5958">    if (retlist) {</a>
<a name="ln5959">      // return an empty list when there's no output</a>
<a name="ln5960">      tv_list_alloc_ret(rettv, 0);</a>
<a name="ln5961">    } else {</a>
<a name="ln5962">      rettv-&gt;vval.v_string = xstrdup(&quot;&quot;);</a>
<a name="ln5963">    }</a>
<a name="ln5964">    return;</a>
<a name="ln5965">  }</a>
<a name="ln5966"> </a>
<a name="ln5967">  if (retlist) {</a>
<a name="ln5968">    int keepempty = 0;</a>
<a name="ln5969">    if (argvars[1].v_type != VAR_UNKNOWN &amp;&amp; argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln5970">      keepempty = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln5971">    }</a>
<a name="ln5972">    rettv-&gt;vval.v_list = string_to_list(res, nread, (bool)keepempty);</a>
<a name="ln5973">    tv_list_ref(rettv-&gt;vval.v_list);</a>
<a name="ln5974">    rettv-&gt;v_type = VAR_LIST;</a>
<a name="ln5975"> </a>
<a name="ln5976">    xfree(res);</a>
<a name="ln5977">  } else {</a>
<a name="ln5978">    // res may contain several NULs before the final terminating one.</a>
<a name="ln5979">    // Replace them with SOH (1) like in get_cmd_output() to avoid truncation.</a>
<a name="ln5980">    memchrsub(res, NUL, 1, nread);</a>
<a name="ln5981">#ifdef USE_CRNL</a>
<a name="ln5982">    // translate &lt;CR&gt;&lt;NL&gt; into &lt;NL&gt;</a>
<a name="ln5983">    char *d = res;</a>
<a name="ln5984">    for (char *s = res; *s; s++) {</a>
<a name="ln5985">      if (s[0] == CAR &amp;&amp; s[1] == NL) {</a>
<a name="ln5986">        s++;</a>
<a name="ln5987">      }</a>
<a name="ln5988"> </a>
<a name="ln5989">      *d++ = *s;</a>
<a name="ln5990">    }</a>
<a name="ln5991"> </a>
<a name="ln5992">    *d = NUL;</a>
<a name="ln5993">#endif</a>
<a name="ln5994">    rettv-&gt;vval.v_string = res;</a>
<a name="ln5995">  }</a>
<a name="ln5996">}</a>
<a name="ln5997"> </a>
<a name="ln5998">/// Get a callback from &quot;arg&quot;.  It can be a Funcref or a function name.</a>
<a name="ln5999">bool callback_from_typval(Callback *const callback, const typval_T *const arg)</a>
<a name="ln6000">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6001">{</a>
<a name="ln6002">  int r = OK;</a>
<a name="ln6003"> </a>
<a name="ln6004">  if (arg-&gt;v_type == VAR_PARTIAL &amp;&amp; arg-&gt;vval.v_partial != NULL) {</a>
<a name="ln6005">    callback-&gt;data.partial = arg-&gt;vval.v_partial;</a>
<a name="ln6006">    callback-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln6007">    callback-&gt;type = kCallbackPartial;</a>
<a name="ln6008">  } else if (arg-&gt;v_type == VAR_STRING</a>
<a name="ln6009">             &amp;&amp; arg-&gt;vval.v_string != NULL</a>
<a name="ln6010">             &amp;&amp; ascii_isdigit(*arg-&gt;vval.v_string)) {</a>
<a name="ln6011">    r = FAIL;</a>
<a name="ln6012">  } else if (arg-&gt;v_type == VAR_FUNC || arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln6013">    char *name = arg-&gt;vval.v_string;</a>
<a name="ln6014">    if (name == NULL) {</a>
<a name="ln6015">      r = FAIL;</a>
<a name="ln6016">    } else if (*name == NUL) {</a>
<a name="ln6017">      callback-&gt;type = kCallbackNone;</a>
<a name="ln6018">      callback-&gt;data.funcref = NULL;</a>
<a name="ln6019">    } else {</a>
<a name="ln6020">      callback-&gt;data.funcref = NULL;</a>
<a name="ln6021">      if (arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln6022">        callback-&gt;data.funcref = get_scriptlocal_funcname(name);</a>
<a name="ln6023">      }</a>
<a name="ln6024">      if (callback-&gt;data.funcref == NULL) {</a>
<a name="ln6025">        callback-&gt;data.funcref = xstrdup(name);</a>
<a name="ln6026">      }</a>
<a name="ln6027">      func_ref(callback-&gt;data.funcref);</a>
<a name="ln6028">      callback-&gt;type = kCallbackFuncref;</a>
<a name="ln6029">    }</a>
<a name="ln6030">  } else if (nlua_is_table_from_lua(arg)) {</a>
<a name="ln6031">    // TODO(tjdvries): UnifiedCallback</a>
<a name="ln6032">    char *name = nlua_register_table_as_callable(arg);</a>
<a name="ln6033"> </a>
<a name="ln6034">    if (name != NULL) {</a>
<a name="ln6035">      callback-&gt;data.funcref = xstrdup(name);</a>
<a name="ln6036">      callback-&gt;type = kCallbackFuncref;</a>
<a name="ln6037">    } else {</a>
<a name="ln6038">      r = FAIL;</a>
<a name="ln6039">    }</a>
<a name="ln6040">  } else if (arg-&gt;v_type == VAR_SPECIAL</a>
<a name="ln6041">             || (arg-&gt;v_type == VAR_NUMBER &amp;&amp; arg-&gt;vval.v_number == 0)) {</a>
<a name="ln6042">    callback-&gt;type = kCallbackNone;</a>
<a name="ln6043">    callback-&gt;data.funcref = NULL;</a>
<a name="ln6044">  } else {</a>
<a name="ln6045">    r = FAIL;</a>
<a name="ln6046">  }</a>
<a name="ln6047"> </a>
<a name="ln6048">  if (r == FAIL) {</a>
<a name="ln6049">    emsg(_(&quot;E921: Invalid callback argument&quot;));</a>
<a name="ln6050">    return false;</a>
<a name="ln6051">  }</a>
<a name="ln6052">  return true;</a>
<a name="ln6053">}</a>
<a name="ln6054"> </a>
<a name="ln6055">static int callback_depth = 0;</a>
<a name="ln6056"> </a>
<a name="ln6057">int get_callback_depth(void)</a>
<a name="ln6058">{</a>
<a name="ln6059">  return callback_depth;</a>
<a name="ln6060">}</a>
<a name="ln6061"> </a>
<a name="ln6062">/// @return  whether the callback could be called.</a>
<a name="ln6063">bool callback_call(Callback *const callback, const int argcount_in, typval_T *const argvars_in,</a>
<a name="ln6064">                   typval_T *const rettv)</a>
<a name="ln6065">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6066">{</a>
<a name="ln6067">  if (callback_depth &gt; p_mfd) {</a>
<a name="ln6068">    emsg(_(e_command_too_recursive));</a>
<a name="ln6069">    return false;</a>
<a name="ln6070">  }</a>
<a name="ln6071"> </a>
<a name="ln6072">  partial_T *partial;</a>
<a name="ln6073">  char *name;</a>
<a name="ln6074">  Array args = ARRAY_DICT_INIT;</a>
<a name="ln6075">  Object rv;</a>
<a name="ln6076">  switch (callback-&gt;type) {</a>
<a name="ln6077">  case kCallbackFuncref:</a>
<a name="ln6078">    name = callback-&gt;data.funcref;</a>
<a name="ln6079">    int len = (int)strlen(name);</a>
<a name="ln6080">    if (len &gt;= 6 &amp;&amp; !memcmp(name, &quot;v:lua.&quot;, 6)) {</a>
<a name="ln6081">      name += 6;</a>
<a name="ln6082">      len = check_luafunc_name(name, false);</a>
<a name="ln6083">      if (len == 0) {</a>
<a name="ln6084">        return false;</a>
<a name="ln6085">      }</a>
<a name="ln6086">      partial = vvlua_partial;</a>
<a name="ln6087">    } else {</a>
<a name="ln6088">      partial = NULL;</a>
<a name="ln6089">    }</a>
<a name="ln6090">    break;</a>
<a name="ln6091"> </a>
<a name="ln6092">  case kCallbackPartial:</a>
<a name="ln6093">    partial = callback-&gt;data.partial;</a>
<a name="ln6094">    name = partial_name(partial);</a>
<a name="ln6095">    break;</a>
<a name="ln6096"> </a>
<a name="ln6097">  case kCallbackLua:</a>
<a name="ln6098">    rv = nlua_call_ref(callback-&gt;data.luaref, NULL, args, false, NULL);</a>
<a name="ln6099">    return (rv.type == kObjectTypeBoolean &amp;&amp; rv.data.boolean == true);</a>
<a name="ln6100"> </a>
<a name="ln6101">  case kCallbackNone:</a>
<a name="ln6102">    return false;</a>
<a name="ln6103">    break;</a>
<a name="ln6104">  }</a>
<a name="ln6105"> </a>
<a name="ln6106">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln6107">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6108">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6109">  funcexe.fe_evaluate = true;</a>
<a name="ln6110">  funcexe.fe_partial = partial;</a>
<a name="ln6111"> </a>
<a name="ln6112">  callback_depth++;</a>
<a name="ln6113">  int ret = call_func(name, -1, rettv, argcount_in, argvars_in, &amp;funcexe);</a>
<a name="ln6114">  callback_depth--;</a>
<a name="ln6115">  return ret;</a>
<a name="ln6116">}</a>
<a name="ln6117"> </a>
<a name="ln6118">bool set_ref_in_callback(Callback *callback, int copyID, ht_stack_T **ht_stack,</a>
<a name="ln6119">                         list_stack_T **list_stack)</a>
<a name="ln6120">{</a>
<a name="ln6121">  typval_T tv;</a>
<a name="ln6122">  switch (callback-&gt;type) {</a>
<a name="ln6123">  case kCallbackFuncref:</a>
<a name="ln6124">  case kCallbackNone:</a>
<a name="ln6125">    break;</a>
<a name="ln6126"> </a>
<a name="ln6127">  case kCallbackPartial:</a>
<a name="ln6128">    tv.v_type = VAR_PARTIAL;</a>
<a name="ln6129">    tv.vval.v_partial = callback-&gt;data.partial;</a>
<a name="ln6130">    return set_ref_in_item(&amp;tv, copyID, ht_stack, list_stack);</a>
<a name="ln6131">    break;</a>
<a name="ln6132"> </a>
<a name="ln6133">  case kCallbackLua:</a>
<a name="ln6134">    abort();</a>
<a name="ln6135">  }</a>
<a name="ln6136">  return false;</a>
<a name="ln6137">}</a>
<a name="ln6138"> </a>
<a name="ln6139">static bool set_ref_in_callback_reader(CallbackReader *reader, int copyID, ht_stack_T **ht_stack,</a>
<a name="ln6140">                                       list_stack_T **list_stack)</a>
<a name="ln6141">{</a>
<a name="ln6142">  if (set_ref_in_callback(&amp;reader-&gt;cb, copyID, ht_stack, list_stack)) {</a>
<a name="ln6143">    return true;</a>
<a name="ln6144">  }</a>
<a name="ln6145"> </a>
<a name="ln6146">  if (reader-&gt;self) {</a>
<a name="ln6147">    typval_T tv;</a>
<a name="ln6148">    tv.v_type = VAR_DICT;</a>
<a name="ln6149">    tv.vval.v_dict = reader-&gt;self;</a>
<a name="ln6150">    return set_ref_in_item(&amp;tv, copyID, ht_stack, list_stack);</a>
<a name="ln6151">  }</a>
<a name="ln6152">  return false;</a>
<a name="ln6153">}</a>
<a name="ln6154"> </a>
<a name="ln6155">timer_T *find_timer_by_nr(varnumber_T xx)</a>
<a name="ln6156">{</a>
<a name="ln6157">  return pmap_get(uint64_t)(&amp;timers, (uint64_t)xx);</a>
<a name="ln6158">}</a>
<a name="ln6159"> </a>
<a name="ln6160">void add_timer_info(typval_T *rettv, timer_T *timer)</a>
<a name="ln6161">{</a>
<a name="ln6162">  list_T *list = rettv-&gt;vval.v_list;</a>
<a name="ln6163">  dict_T *dict = tv_dict_alloc();</a>
<a name="ln6164"> </a>
<a name="ln6165">  tv_list_append_dict(list, dict);</a>
<a name="ln6166">  tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), timer-&gt;timer_id);</a>
<a name="ln6167">  tv_dict_add_nr(dict, S_LEN(&quot;time&quot;), timer-&gt;timeout);</a>
<a name="ln6168">  tv_dict_add_nr(dict, S_LEN(&quot;paused&quot;), timer-&gt;paused);</a>
<a name="ln6169"> </a>
<a name="ln6170">  tv_dict_add_nr(dict, S_LEN(&quot;repeat&quot;),</a>
<a name="ln6171">                 (timer-&gt;repeat_count &lt; 0 ? -1 : timer-&gt;repeat_count));</a>
<a name="ln6172"> </a>
<a name="ln6173">  dictitem_T *di = tv_dict_item_alloc(&quot;callback&quot;);</a>
<a name="ln6174">  if (tv_dict_add(dict, di) == FAIL) {</a>
<a name="ln6175">    xfree(di);</a>
<a name="ln6176">    return;</a>
<a name="ln6177">  }</a>
<a name="ln6178"> </a>
<a name="ln6179">  callback_put(&amp;timer-&gt;callback, &amp;di-&gt;di_tv);</a>
<a name="ln6180">}</a>
<a name="ln6181"> </a>
<a name="ln6182">void add_timer_info_all(typval_T *rettv)</a>
<a name="ln6183">{</a>
<a name="ln6184">  tv_list_alloc_ret(rettv, map_size(&amp;timers));</a>
<a name="ln6185">  timer_T *timer;</a>
<a name="ln6186">  map_foreach_value(&amp;timers, timer, {</a>
<a name="ln6187">    if (!timer-&gt;stopped || timer-&gt;refcount &gt; 1) {</a>
<a name="ln6188">      add_timer_info(rettv, timer);</a>
<a name="ln6189">    }</a>
<a name="ln6190">  })</a>
<a name="ln6191">}</a>
<a name="ln6192"> </a>
<a name="ln6193">/// invoked on the main loop</a>
<a name="ln6194">void timer_due_cb(TimeWatcher *tw, void *data)</a>
<a name="ln6195">{</a>
<a name="ln6196">  timer_T *timer = (timer_T *)data;</a>
<a name="ln6197">  int save_did_emsg = did_emsg;</a>
<a name="ln6198">  const int called_emsg_before = called_emsg;</a>
<a name="ln6199">  const bool save_ex_pressedreturn = get_pressedreturn();</a>
<a name="ln6200"> </a>
<a name="ln6201">  if (timer-&gt;stopped || timer-&gt;paused) {</a>
<a name="ln6202">    return;</a>
<a name="ln6203">  }</a>
<a name="ln6204"> </a>
<a name="ln6205">  timer-&gt;refcount++;</a>
<a name="ln6206">  // if repeat was negative repeat forever</a>
<a name="ln6207">  if (timer-&gt;repeat_count &gt;= 0 &amp;&amp; --timer-&gt;repeat_count == 0) {</a>
<a name="ln6208">    timer_stop(timer);</a>
<a name="ln6209">  }</a>
<a name="ln6210"> </a>
<a name="ln6211">  typval_T argv[2] = { TV_INITIAL_VALUE, TV_INITIAL_VALUE };</a>
<a name="ln6212">  argv[0].v_type = VAR_NUMBER;</a>
<a name="ln6213">  argv[0].vval.v_number = timer-&gt;timer_id;</a>
<a name="ln6214">  typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln6215"> </a>
<a name="ln6216">  callback_call(&amp;timer-&gt;callback, 1, argv, &amp;rettv);</a>
<a name="ln6217"> </a>
<a name="ln6218">  // Handle error message</a>
<a name="ln6219">  if (called_emsg &gt; called_emsg_before &amp;&amp; did_emsg) {</a>
<a name="ln6220">    timer-&gt;emsg_count++;</a>
<a name="ln6221">    if (did_throw) {</a>
<a name="ln6222">      discard_current_exception();</a>
<a name="ln6223">    }</a>
<a name="ln6224">  }</a>
<a name="ln6225">  did_emsg = save_did_emsg;</a>
<a name="ln6226">  set_pressedreturn(save_ex_pressedreturn);</a>
<a name="ln6227"> </a>
<a name="ln6228">  if (timer-&gt;emsg_count &gt;= 3) {</a>
<a name="ln6229">    timer_stop(timer);</a>
<a name="ln6230">  }</a>
<a name="ln6231"> </a>
<a name="ln6232">  tv_clear(&amp;rettv);</a>
<a name="ln6233"> </a>
<a name="ln6234">  if (!timer-&gt;stopped &amp;&amp; timer-&gt;timeout == 0) {</a>
<a name="ln6235">    // special case: timeout=0 means the callback will be</a>
<a name="ln6236">    // invoked again on the next event loop tick.</a>
<a name="ln6237">    // we don't use uv_idle_t to not spin the event loop</a>
<a name="ln6238">    // when the main loop is blocked.</a>
<a name="ln6239">    time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, 0, 0);</a>
<a name="ln6240">  }</a>
<a name="ln6241">  timer_decref(timer);</a>
<a name="ln6242">}</a>
<a name="ln6243"> </a>
<a name="ln6244">uint64_t timer_start(const int64_t timeout, const int repeat_count, const Callback *const callback)</a>
<a name="ln6245">{</a>
<a name="ln6246">  timer_T *timer = xmalloc(sizeof *timer);</a>
<a name="ln6247">  timer-&gt;refcount = 1;</a>
<a name="ln6248">  timer-&gt;stopped = false;</a>
<a name="ln6249">  timer-&gt;paused = false;</a>
<a name="ln6250">  timer-&gt;emsg_count = 0;</a>
<a name="ln6251">  timer-&gt;repeat_count = repeat_count;</a>
<a name="ln6252">  timer-&gt;timeout = timeout;</a>
<a name="ln6253">  timer-&gt;timer_id = (int)last_timer_id++;</a>
<a name="ln6254">  timer-&gt;callback = *callback;</a>
<a name="ln6255"> </a>
<a name="ln6256">  time_watcher_init(&amp;main_loop, &amp;timer-&gt;tw, timer);</a>
<a name="ln6257">  timer-&gt;tw.events = multiqueue_new_child(main_loop.events);</a>
<a name="ln6258">  // if main loop is blocked, don't queue up multiple events</a>
<a name="ln6259">  timer-&gt;tw.blockable = true;</a>
<a name="ln6260">  time_watcher_start(&amp;timer-&gt;tw, timer_due_cb, (uint64_t)timeout, (uint64_t)timeout);</a>
<a name="ln6261"> </a>
<a name="ln6262">  pmap_put(uint64_t)(&amp;timers, (uint64_t)timer-&gt;timer_id, timer);</a>
<a name="ln6263">  return (uint64_t)timer-&gt;timer_id;</a>
<a name="ln6264">}</a>
<a name="ln6265"> </a>
<a name="ln6266">void timer_stop(timer_T *timer)</a>
<a name="ln6267">{</a>
<a name="ln6268">  if (timer-&gt;stopped) {</a>
<a name="ln6269">    // avoid double free</a>
<a name="ln6270">    return;</a>
<a name="ln6271">  }</a>
<a name="ln6272">  timer-&gt;stopped = true;</a>
<a name="ln6273">  time_watcher_stop(&amp;timer-&gt;tw);</a>
<a name="ln6274">  time_watcher_close(&amp;timer-&gt;tw, timer_close_cb);</a>
<a name="ln6275">}</a>
<a name="ln6276"> </a>
<a name="ln6277">/// This will be run on the main loop after the last timer_due_cb, so at this</a>
<a name="ln6278">/// point it is safe to free the callback.</a>
<a name="ln6279">static void timer_close_cb(TimeWatcher *tw, void *data)</a>
<a name="ln6280">{</a>
<a name="ln6281">  timer_T *timer = (timer_T *)data;</a>
<a name="ln6282">  multiqueue_free(timer-&gt;tw.events);</a>
<a name="ln6283">  callback_free(&amp;timer-&gt;callback);</a>
<a name="ln6284">  pmap_del(uint64_t)(&amp;timers, (uint64_t)timer-&gt;timer_id, NULL);</a>
<a name="ln6285">  timer_decref(timer);</a>
<a name="ln6286">}</a>
<a name="ln6287"> </a>
<a name="ln6288">static void timer_decref(timer_T *timer)</a>
<a name="ln6289">{</a>
<a name="ln6290">  if (--timer-&gt;refcount == 0) {</a>
<a name="ln6291">    xfree(timer);</a>
<a name="ln6292">  }</a>
<a name="ln6293">}</a>
<a name="ln6294"> </a>
<a name="ln6295">void timer_stop_all(void)</a>
<a name="ln6296">{</a>
<a name="ln6297">  timer_T *timer;</a>
<a name="ln6298">  map_foreach_value(&amp;timers, timer, {</a>
<a name="ln6299">    timer_stop(timer);</a>
<a name="ln6300">  })</a>
<a name="ln6301">}</a>
<a name="ln6302"> </a>
<a name="ln6303">void timer_teardown(void)</a>
<a name="ln6304">{</a>
<a name="ln6305">  timer_stop_all();</a>
<a name="ln6306">}</a>
<a name="ln6307"> </a>
<a name="ln6308">/// Write &quot;list&quot; of strings to file &quot;fd&quot;.</a>
<a name="ln6309">///</a>
<a name="ln6310">/// @param  fp  File to write to.</a>
<a name="ln6311">/// @param[in]  list  List to write.</a>
<a name="ln6312">/// @param[in]  binary  Whether to write in binary mode.</a>
<a name="ln6313">///</a>
<a name="ln6314">/// @return true in case of success, false otherwise.</a>
<a name="ln6315">bool write_list(FileDescriptor *const fp, const list_T *const list, const bool binary)</a>
<a name="ln6316">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln6317">{</a>
<a name="ln6318">  int error = 0;</a>
<a name="ln6319">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln6320">    const char *const s = tv_get_string_chk(TV_LIST_ITEM_TV(li));</a>
<a name="ln6321">    if (s == NULL) {</a>
<a name="ln6322">      return false;</a>
<a name="ln6323">    }</a>
<a name="ln6324">    const char *hunk_start = s;</a>
<a name="ln6325">    for (const char *p = hunk_start;; p++) {</a>
<a name="ln6326">      if (*p == NUL || *p == NL) {</a>
<a name="ln6327">        if (p != hunk_start) {</a>
<a name="ln6328">          const ptrdiff_t written = file_write(fp, hunk_start,</a>
<a name="ln6329">                                               (size_t)(p - hunk_start));</a>
<a name="ln6330">          if (written &lt; 0) {</a>
<a name="ln6331">            error = (int)written;</a>
<a name="ln6332">            goto write_list_error;</a>
<a name="ln6333">          }</a>
<a name="ln6334">        }</a>
<a name="ln6335">        if (*p == NUL) {</a>
<a name="ln6336">          break;</a>
<a name="ln6337">        } else {</a>
<a name="ln6338">          hunk_start = p + 1;</a>
<a name="ln6339">          const ptrdiff_t written = file_write(fp, (char[]){ NUL }, 1);</a>
<a name="ln6340">          if (written &lt; 0) {</a>
<a name="ln6341">            error = (int)written;</a>
<a name="ln6342">            break;</a>
<a name="ln6343">          }</a>
<a name="ln6344">        }</a>
<a name="ln6345">      }</a>
<a name="ln6346">    }</a>
<a name="ln6347">    if (!binary || TV_LIST_ITEM_NEXT(list, li) != NULL) {</a>
<a name="ln6348">      const ptrdiff_t written = file_write(fp, &quot;\n&quot;, 1);</a>
<a name="ln6349">      if (written &lt; 0) {</a>
<a name="ln6350">        error = (int)written;</a>
<a name="ln6351">        goto write_list_error;</a>
<a name="ln6352">      }</a>
<a name="ln6353">    }</a>
<a name="ln6354">  });</a>
<a name="ln6355">  if ((error = file_flush(fp)) != 0) {</a>
<a name="ln6356">    goto write_list_error;</a>
<a name="ln6357">  }</a>
<a name="ln6358">  return true;</a>
<a name="ln6359">write_list_error:</a>
<a name="ln6360">  semsg(_(e_write2), os_strerror(error));</a>
<a name="ln6361">  return false;</a>
<a name="ln6362">}</a>
<a name="ln6363"> </a>
<a name="ln6364">/// Write a blob to file with descriptor `fp`.</a>
<a name="ln6365">///</a>
<a name="ln6366">/// @param[in]  fp  File to write to.</a>
<a name="ln6367">/// @param[in]  blob  Blob to write.</a>
<a name="ln6368">///</a>
<a name="ln6369">/// @return true on success, or false on failure.</a>
<a name="ln6370">bool write_blob(FileDescriptor *const fp, const blob_T *const blob)</a>
<a name="ln6371">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln6372">{</a>
<a name="ln6373">  int error = 0;</a>
<a name="ln6374">  const int len = tv_blob_len(blob);</a>
<a name="ln6375">  if (len &gt; 0) {</a>
<a name="ln6376">    const ptrdiff_t written = file_write(fp, blob-&gt;bv_ga.ga_data, (size_t)len);</a>
<a name="ln6377">    if (written &lt; (ptrdiff_t)len) {</a>
<a name="ln6378">      error = (int)written;</a>
<a name="ln6379">      goto write_blob_error;</a>
<a name="ln6380">    }</a>
<a name="ln6381">  }</a>
<a name="ln6382">  error = file_flush(fp);</a>
<a name="ln6383">  if (error != 0) {</a>
<a name="ln6384">    goto write_blob_error;</a>
<a name="ln6385">  }</a>
<a name="ln6386">  return true;</a>
<a name="ln6387">write_blob_error:</a>
<a name="ln6388">  semsg(_(e_write2), os_strerror(error));</a>
<a name="ln6389">  return false;</a>
<a name="ln6390">}</a>
<a name="ln6391"> </a>
<a name="ln6392">/// Read blob from file &quot;fd&quot;.</a>
<a name="ln6393">/// Caller has allocated a blob in &quot;rettv&quot;.</a>
<a name="ln6394">///</a>
<a name="ln6395">/// @param[in]  fd  File to read from.</a>
<a name="ln6396">/// @param[in,out]  rettv  Blob to write to.</a>
<a name="ln6397">/// @param[in]  offset  Read the file from the specified offset.</a>
<a name="ln6398">/// @param[in]  size  Read the specified size, or -1 if no limit.</a>
<a name="ln6399">///</a>
<a name="ln6400">/// @return  OK on success, or FAIL on failure.</a>
<a name="ln6401">int read_blob(FILE *const fd, typval_T *rettv, off_T offset, off_T size_arg)</a>
<a name="ln6402">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6403">{</a>
<a name="ln6404">  blob_T *const blob = rettv-&gt;vval.v_blob;</a>
<a name="ln6405">  FileInfo file_info;</a>
<a name="ln6406">  if (!os_fileinfo_fd(fileno(fd), &amp;file_info)) {</a>
<a name="ln6407">    return FAIL;  // can't read the file, error</a>
<a name="ln6408">  }</a>
<a name="ln6409"> </a>
<a name="ln6410">  int whence;</a>
<a name="ln6411">  off_T size = size_arg;</a>
<a name="ln6412">  const off_T file_size = (off_T)os_fileinfo_size(&amp;file_info);</a>
<a name="ln6413">  if (offset &gt;= 0) {</a>
<a name="ln6414">    // The size defaults to the whole file.  If a size is given it is</a>
<a name="ln6415">    // limited to not go past the end of the file.</a>
<a name="ln6416">    if (size == -1 || (size &gt; file_size - offset &amp;&amp; !S_ISCHR(file_info.stat.st_mode))) {</a>
<a name="ln6417">      // size may become negative, checked below</a>
<a name="ln6418">      size = (off_T)os_fileinfo_size(&amp;file_info) - offset;</a>
<a name="ln6419">    }</a>
<a name="ln6420">    whence = SEEK_SET;</a>
<a name="ln6421">  } else {</a>
<a name="ln6422">    // limit the offset to not go before the start of the file</a>
<a name="ln6423">    if (-offset &gt; file_size &amp;&amp; !S_ISCHR(file_info.stat.st_mode)) {</a>
<a name="ln6424">      offset = -file_size;</a>
<a name="ln6425">    }</a>
<a name="ln6426">    // Size defaults to reading until the end of the file.</a>
<a name="ln6427">    if (size == -1 || size &gt; -offset) {</a>
<a name="ln6428">      size = -offset;</a>
<a name="ln6429">    }</a>
<a name="ln6430">    whence = SEEK_END;</a>
<a name="ln6431">  }</a>
<a name="ln6432">  if (size &lt;= 0) {</a>
<a name="ln6433">    return OK;</a>
<a name="ln6434">  }</a>
<a name="ln6435">  if (offset != 0 &amp;&amp; vim_fseek(fd, offset, whence) != 0) {</a>
<a name="ln6436">    return OK;</a>
<a name="ln6437">  }</a>
<a name="ln6438"> </a>
<a name="ln6439">  ga_grow(&amp;blob-&gt;bv_ga, (int)size);</a>
<a name="ln6440">  blob-&gt;bv_ga.ga_len = (int)size;</a>
<a name="ln6441">  if (fread(blob-&gt;bv_ga.ga_data, 1, (size_t)blob-&gt;bv_ga.ga_len, fd)</a>
<a name="ln6442">      &lt; (size_t)blob-&gt;bv_ga.ga_len) {</a>
<a name="ln6443">    // An empty blob is returned on error.</a>
<a name="ln6444">    tv_blob_free(rettv-&gt;vval.v_blob);</a>
<a name="ln6445">    rettv-&gt;vval.v_blob = NULL;</a>
<a name="ln6446">    return FAIL;</a>
<a name="ln6447">  }</a>
<a name="ln6448">  return OK;</a>
<a name="ln6449">}</a>
<a name="ln6450"> </a>
<a name="ln6451">/// Saves a typval_T as a string.</a>
<a name="ln6452">///</a>
<a name="ln6453">/// For lists or buffers, replaces NLs with NUL and separates items with NLs.</a>
<a name="ln6454">///</a>
<a name="ln6455">/// @param[in]  tv   Value to store as a string.</a>
<a name="ln6456">/// @param[out] len  Length of the resulting string or -1 on error.</a>
<a name="ln6457">/// @param[in]  endnl If true, the output will end in a newline (if a list).</a>
<a name="ln6458">/// @param[in]  crlf  If true, list items will be joined with CRLF (if a list).</a>
<a name="ln6459">/// @returns an allocated string if `tv` represents a Vimscript string, list, or</a>
<a name="ln6460">///          number; NULL otherwise.</a>
<a name="ln6461">char *save_tv_as_string(typval_T *tv, ptrdiff_t *const len, bool endnl, bool crlf)</a>
<a name="ln6462">  FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6463">{</a>
<a name="ln6464">  *len = 0;</a>
<a name="ln6465">  if (tv-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln6466">    return NULL;</a>
<a name="ln6467">  }</a>
<a name="ln6468"> </a>
<a name="ln6469">  // For other types, let tv_get_string_buf_chk() get the value or</a>
<a name="ln6470">  // print an error.</a>
<a name="ln6471">  if (tv-&gt;v_type != VAR_LIST &amp;&amp; tv-&gt;v_type != VAR_NUMBER) {</a>
<a name="ln6472">    const char *ret = tv_get_string_chk(tv);</a>
<a name="ln6473">    if (ret) {</a>
<a name="ln6474">      *len = (ptrdiff_t)strlen(ret);</a>
<a name="ln6475">      return xmemdupz(ret, (size_t)(*len));</a>
<a name="ln6476">    } else {</a>
<a name="ln6477">      *len = -1;</a>
<a name="ln6478">      return NULL;</a>
<a name="ln6479">    }</a>
<a name="ln6480">  }</a>
<a name="ln6481"> </a>
<a name="ln6482">  if (tv-&gt;v_type == VAR_NUMBER) {  // Treat number as a buffer-id.</a>
<a name="ln6483">    buf_T *buf = buflist_findnr((int)tv-&gt;vval.v_number);</a>
<a name="ln6484">    if (buf) {</a>
<a name="ln6485">      for (linenr_T lnum = 1; lnum &lt;= buf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln6486">        for (char *p = ml_get_buf(buf, lnum); *p != NUL; p++) {</a>
<a name="ln6487">          *len += 1;</a>
<a name="ln6488">        }</a>
<a name="ln6489">        *len += 1;</a>
<a name="ln6490">      }</a>
<a name="ln6491">    } else {</a>
<a name="ln6492">      semsg(_(e_nobufnr), tv-&gt;vval.v_number);</a>
<a name="ln6493">      *len = -1;</a>
<a name="ln6494">      return NULL;</a>
<a name="ln6495">    }</a>
<a name="ln6496"> </a>
<a name="ln6497">    if (*len == 0) {</a>
<a name="ln6498">      return NULL;</a>
<a name="ln6499">    }</a>
<a name="ln6500"> </a>
<a name="ln6501">    char *ret = xmalloc((size_t)(*len) + 1);</a>
<a name="ln6502">    char *end = ret;</a>
<a name="ln6503">    for (linenr_T lnum = 1; lnum &lt;= buf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln6504">      for (char *p = ml_get_buf(buf, lnum); *p != NUL; p++) {</a>
<a name="ln6505">        *end++ = (*p == '\n') ? NUL : *p;</a>
<a name="ln6506">      }</a>
<a name="ln6507">      *end++ = '\n';</a>
<a name="ln6508">    }</a>
<a name="ln6509">    *end = NUL;</a>
<a name="ln6510">    *len = end - ret;</a>
<a name="ln6511">    return ret;</a>
<a name="ln6512">  }</a>
<a name="ln6513"> </a>
<a name="ln6514">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln6515">  // Pre-calculate the resulting length.</a>
<a name="ln6516">  list_T *list = tv-&gt;vval.v_list;</a>
<a name="ln6517">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln6518">    *len += (ptrdiff_t)strlen(tv_get_string(TV_LIST_ITEM_TV(li))) + (crlf ? 2 : 1);</a>
<a name="ln6519">  });</a>
<a name="ln6520"> </a>
<a name="ln6521">  if (*len == 0) {</a>
<a name="ln6522">    return NULL;</a>
<a name="ln6523">  }</a>
<a name="ln6524"> </a>
<a name="ln6525">  char *ret = xmalloc((size_t)(*len) + (endnl ? (crlf ? 2 : 1) : 0));</a>
<a name="ln6526">  char *end = ret;</a>
<a name="ln6527">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln6528">    for (const char *s = tv_get_string(TV_LIST_ITEM_TV(li)); *s != NUL; s++) {</a>
<a name="ln6529">      *end++ = (*s == '\n') ? NUL : *s;</a>
<a name="ln6530">    }</a>
<a name="ln6531">    if (endnl || TV_LIST_ITEM_NEXT(list, li) != NULL) {</a>
<a name="ln6532">      if (crlf) {</a>
<a name="ln6533">        *end++ = '\r';</a>
<a name="ln6534">      }</a>
<a name="ln6535">      *end++ = '\n';</a>
<a name="ln6536">    }</a>
<a name="ln6537">  });</a>
<a name="ln6538">  *end = NUL;</a>
<a name="ln6539">  *len = end - ret;</a>
<a name="ln6540">  return ret;</a>
<a name="ln6541">}</a>
<a name="ln6542"> </a>
<a name="ln6543">/// Convert the specified byte index of line 'lnum' in buffer 'buf' to a</a>
<a name="ln6544">/// character index.  Works only for loaded buffers. Returns -1 on failure.</a>
<a name="ln6545">/// The index of the first byte and the first character is zero.</a>
<a name="ln6546">int buf_byteidx_to_charidx(buf_T *buf, linenr_T lnum, int byteidx)</a>
<a name="ln6547">{</a>
<a name="ln6548">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln6549">    return -1;</a>
<a name="ln6550">  }</a>
<a name="ln6551"> </a>
<a name="ln6552">  if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6553">    lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6554">  }</a>
<a name="ln6555"> </a>
<a name="ln6556">  char *str = ml_get_buf(buf, lnum);</a>
<a name="ln6557"> </a>
<a name="ln6558">  if (*str == NUL) {</a>
<a name="ln6559">    return 0;</a>
<a name="ln6560">  }</a>
<a name="ln6561"> </a>
<a name="ln6562">  // count the number of characters</a>
<a name="ln6563">  char *t = str;</a>
<a name="ln6564">  int count;</a>
<a name="ln6565">  for (count = 0; *t != NUL &amp;&amp; t &lt;= str + byteidx; count++) {</a>
<a name="ln6566">    t += utfc_ptr2len(t);</a>
<a name="ln6567">  }</a>
<a name="ln6568"> </a>
<a name="ln6569">  // In insert mode, when the cursor is at the end of a non-empty line,</a>
<a name="ln6570">  // byteidx points to the NUL character immediately past the end of the</a>
<a name="ln6571">  // string. In this case, add one to the character count.</a>
<a name="ln6572">  if (*t == NUL &amp;&amp; byteidx != 0 &amp;&amp; t == str + byteidx) {</a>
<a name="ln6573">    count++;</a>
<a name="ln6574">  }</a>
<a name="ln6575"> </a>
<a name="ln6576">  return count - 1;</a>
<a name="ln6577">}</a>
<a name="ln6578"> </a>
<a name="ln6579">/// Convert the specified character index of line 'lnum' in buffer 'buf' to a</a>
<a name="ln6580">/// byte index.  Works only for loaded buffers.</a>
<a name="ln6581">/// The index of the first byte and the first character is zero.</a>
<a name="ln6582">///</a>
<a name="ln6583">/// @return  -1 on failure.</a>
<a name="ln6584">int buf_charidx_to_byteidx(buf_T *buf, linenr_T lnum, int charidx)</a>
<a name="ln6585">{</a>
<a name="ln6586">  if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln6587">    return -1;</a>
<a name="ln6588">  }</a>
<a name="ln6589"> </a>
<a name="ln6590">  if (lnum &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6591">    lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6592">  }</a>
<a name="ln6593"> </a>
<a name="ln6594">  char *str = ml_get_buf(buf, lnum);</a>
<a name="ln6595"> </a>
<a name="ln6596">  // Convert the character offset to a byte offset</a>
<a name="ln6597">  char *t = str;</a>
<a name="ln6598">  while (*t != NUL &amp;&amp; --charidx &gt; 0) {</a>
<a name="ln6599">    t += utfc_ptr2len(t);</a>
<a name="ln6600">  }</a>
<a name="ln6601"> </a>
<a name="ln6602">  return (int)(t - str);</a>
<a name="ln6603">}</a>
<a name="ln6604"> </a>
<a name="ln6605">/// Translate a Vimscript object into a position</a>
<a name="ln6606">///</a>
<a name="ln6607">/// Accepts VAR_LIST and VAR_STRING objects. Does not give an error for invalid</a>
<a name="ln6608">/// type.</a>
<a name="ln6609">///</a>
<a name="ln6610">/// @param[in]  tv  Object to translate.</a>
<a name="ln6611">/// @param[in]  dollar_lnum  True when &quot;$&quot; is last line.</a>
<a name="ln6612">/// @param[out]  ret_fnum  Set to fnum for marks.</a>
<a name="ln6613">/// @param[in]  charcol  True to return character column.</a>
<a name="ln6614">///</a>
<a name="ln6615">/// @return Pointer to position or NULL in case of error (e.g. invalid type).</a>
<a name="ln6616">pos_T *var2fpos(const typval_T *const tv, const bool dollar_lnum, int *const ret_fnum,</a>
<a name="ln6617">                const bool charcol)</a>
<a name="ln6618">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6619">{</a>
<a name="ln6620">  static pos_T pos;</a>
<a name="ln6621"> </a>
<a name="ln6622">  // Argument can be [lnum, col, coladd].</a>
<a name="ln6623">  if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln6624">    bool error = false;</a>
<a name="ln6625"> </a>
<a name="ln6626">    list_T *l = tv-&gt;vval.v_list;</a>
<a name="ln6627">    if (l == NULL) {</a>
<a name="ln6628">      return NULL;</a>
<a name="ln6629">    }</a>
<a name="ln6630"> </a>
<a name="ln6631">    // Get the line number.</a>
<a name="ln6632">    pos.lnum = (linenr_T)tv_list_find_nr(l, 0, &amp;error);</a>
<a name="ln6633">    if (error || pos.lnum &lt;= 0 || pos.lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6634">      // Invalid line number.</a>
<a name="ln6635">      return NULL;</a>
<a name="ln6636">    }</a>
<a name="ln6637"> </a>
<a name="ln6638">    // Get the column number.</a>
<a name="ln6639">    pos.col = (colnr_T)tv_list_find_nr(l, 1, &amp;error);</a>
<a name="ln6640">    if (error) {</a>
<a name="ln6641">      return NULL;</a>
<a name="ln6642">    }</a>
<a name="ln6643">    int len;</a>
<a name="ln6644">    if (charcol) {</a>
<a name="ln6645">      len = mb_charlen(ml_get(pos.lnum));</a>
<a name="ln6646">    } else {</a>
<a name="ln6647">      len = (int)strlen(ml_get(pos.lnum));</a>
<a name="ln6648">    }</a>
<a name="ln6649"> </a>
<a name="ln6650">    // We accept &quot;$&quot; for the column number: last column.</a>
<a name="ln6651">    listitem_T *li = tv_list_find(l, 1);</a>
<a name="ln6652">    if (li != NULL &amp;&amp; TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_STRING</a>
<a name="ln6653">        &amp;&amp; TV_LIST_ITEM_TV(li)-&gt;vval.v_string != NULL</a>
<a name="ln6654">        &amp;&amp; strcmp(TV_LIST_ITEM_TV(li)-&gt;vval.v_string, &quot;$&quot;) == 0) {</a>
<a name="ln6655">      pos.col = len + 1;</a>
<a name="ln6656">    }</a>
<a name="ln6657"> </a>
<a name="ln6658">    // Accept a position up to the NUL after the line.</a>
<a name="ln6659">    if (pos.col == 0 || (int)pos.col &gt; len + 1) {</a>
<a name="ln6660">      // Invalid column number.</a>
<a name="ln6661">      return NULL;</a>
<a name="ln6662">    }</a>
<a name="ln6663">    pos.col--;</a>
<a name="ln6664"> </a>
<a name="ln6665">    // Get the virtual offset.  Defaults to zero.</a>
<a name="ln6666">    pos.coladd = (colnr_T)tv_list_find_nr(l, 2, &amp;error);</a>
<a name="ln6667">    if (error) {</a>
<a name="ln6668">      pos.coladd = 0;</a>
<a name="ln6669">    }</a>
<a name="ln6670"> </a>
<a name="ln6671">    return &amp;pos;</a>
<a name="ln6672">  }</a>
<a name="ln6673"> </a>
<a name="ln6674">  const char *const name = tv_get_string_chk(tv);</a>
<a name="ln6675">  if (name == NULL) {</a>
<a name="ln6676">    return NULL;</a>
<a name="ln6677">  }</a>
<a name="ln6678"> </a>
<a name="ln6679">  pos.lnum = 0;</a>
<a name="ln6680">  if (name[0] == '.') {</a>
<a name="ln6681">    // cursor</a>
<a name="ln6682">    pos = curwin-&gt;w_cursor;</a>
<a name="ln6683">  } else if (name[0] == 'v' &amp;&amp; name[1] == NUL) {</a>
<a name="ln6684">    // Visual start</a>
<a name="ln6685">    if (VIsual_active) {</a>
<a name="ln6686">      pos = VIsual;</a>
<a name="ln6687">    } else {</a>
<a name="ln6688">      pos = curwin-&gt;w_cursor;</a>
<a name="ln6689">    }</a>
<a name="ln6690">  } else if (name[0] == '\'') {</a>
<a name="ln6691">    // mark</a>
<a name="ln6692">    int mname = (uint8_t)name[1];</a>
<a name="ln6693">    const fmark_T *const fm = mark_get(curbuf, curwin, NULL, kMarkAll, mname);</a>
<a name="ln6694">    if (fm == NULL || fm-&gt;mark.lnum &lt;= 0) {</a>
<a name="ln6695">      return NULL;</a>
<a name="ln6696">    }</a>
<a name="ln6697">    pos = fm-&gt;mark;</a>
<a name="ln6698">    // Vimscript behavior, only provide fnum if mark is global.</a>
<a name="ln6699">    *ret_fnum = ASCII_ISUPPER(mname) || ascii_isdigit(mname) ? fm-&gt;fnum : *ret_fnum;</a>
<a name="ln6700">  }</a>
<a name="ln6701">  if (pos.lnum != 0) {</a>
<a name="ln6702">    if (charcol) {</a>
<a name="ln6703">      pos.col = buf_byteidx_to_charidx(curbuf, pos.lnum, pos.col);</a>
<a name="ln6704">    }</a>
<a name="ln6705">    return &amp;pos;</a>
<a name="ln6706">  }</a>
<a name="ln6707"> </a>
<a name="ln6708">  pos.coladd = 0;</a>
<a name="ln6709"> </a>
<a name="ln6710">  if (name[0] == 'w' &amp;&amp; dollar_lnum) {</a>
<a name="ln6711">    // the &quot;w_valid&quot; flags are not reset when moving the cursor, but they</a>
<a name="ln6712">    // do matter for update_topline() and validate_botline().</a>
<a name="ln6713">    check_cursor_moved(curwin);</a>
<a name="ln6714"> </a>
<a name="ln6715">    pos.col = 0;</a>
<a name="ln6716">    if (name[1] == '0') {               // &quot;w0&quot;: first visible line</a>
<a name="ln6717">      update_topline(curwin);</a>
<a name="ln6718">      // In silent Ex mode topline is zero, but that's not a valid line</a>
<a name="ln6719">      // number; use one instead.</a>
<a name="ln6720">      pos.lnum = curwin-&gt;w_topline &gt; 0 ? curwin-&gt;w_topline : 1;</a>
<a name="ln6721">      return &amp;pos;</a>
<a name="ln6722">    } else if (name[1] == '$') {      // &quot;w$&quot;: last visible line</a>
<a name="ln6723">      validate_botline(curwin);</a>
<a name="ln6724">      // In silent Ex mode botline is zero, return zero then.</a>
<a name="ln6725">      pos.lnum = curwin-&gt;w_botline &gt; 0 ? curwin-&gt;w_botline - 1 : 0;</a>
<a name="ln6726">      return &amp;pos;</a>
<a name="ln6727">    }</a>
<a name="ln6728">  } else if (name[0] == '$') {        // last column or line</a>
<a name="ln6729">    if (dollar_lnum) {</a>
<a name="ln6730">      pos.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln6731">      pos.col = 0;</a>
<a name="ln6732">    } else {</a>
<a name="ln6733">      pos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln6734">      if (charcol) {</a>
<a name="ln6735">        pos.col = (colnr_T)mb_charlen(get_cursor_line_ptr());</a>
<a name="ln6736">      } else {</a>
<a name="ln6737">        pos.col = (colnr_T)strlen(get_cursor_line_ptr());</a>
<a name="ln6738">      }</a>
<a name="ln6739">    }</a>
<a name="ln6740">    return &amp;pos;</a>
<a name="ln6741">  }</a>
<a name="ln6742">  return NULL;</a>
<a name="ln6743">}</a>
<a name="ln6744"> </a>
<a name="ln6745">/// Convert list in &quot;arg&quot; into position &quot;posp&quot; and optional file number &quot;fnump&quot;.</a>
<a name="ln6746">/// When &quot;fnump&quot; is NULL there is no file number, only 3 items: [lnum, col, off]</a>
<a name="ln6747">/// Note that the column is passed on as-is, the caller may want to decrement</a>
<a name="ln6748">/// it to use 1 for the first column.</a>
<a name="ln6749">///</a>
<a name="ln6750">/// @param charcol  if true, use the column as the character index instead of the</a>
<a name="ln6751">///                 byte index.</a>
<a name="ln6752">///</a>
<a name="ln6753">/// @return  FAIL when conversion is not possible, doesn't check the position for</a>
<a name="ln6754">///          validity.</a>
<a name="ln6755">int list2fpos(typval_T *arg, pos_T *posp, int *fnump, colnr_T *curswantp, bool charcol)</a>
<a name="ln6756">{</a>
<a name="ln6757">  list_T *l;</a>
<a name="ln6758"> </a>
<a name="ln6759">  // List must be: [fnum, lnum, col, coladd, curswant], where &quot;fnum&quot; is only</a>
<a name="ln6760">  // there when &quot;fnump&quot; isn't NULL; &quot;coladd&quot; and &quot;curswant&quot; are optional.</a>
<a name="ln6761">  if (arg-&gt;v_type != VAR_LIST</a>
<a name="ln6762">      || (l = arg-&gt;vval.v_list) == NULL</a>
<a name="ln6763">      || tv_list_len(l) &lt; (fnump == NULL ? 2 : 3)</a>
<a name="ln6764">      || tv_list_len(l) &gt; (fnump == NULL ? 4 : 5)) {</a>
<a name="ln6765">    return FAIL;</a>
<a name="ln6766">  }</a>
<a name="ln6767"> </a>
<a name="ln6768">  int i = 0;</a>
<a name="ln6769">  int n;</a>
<a name="ln6770">  if (fnump != NULL) {</a>
<a name="ln6771">    n = (int)tv_list_find_nr(l, i++, NULL);  // fnum</a>
<a name="ln6772">    if (n &lt; 0) {</a>
<a name="ln6773">      return FAIL;</a>
<a name="ln6774">    }</a>
<a name="ln6775">    if (n == 0) {</a>
<a name="ln6776">      n = curbuf-&gt;b_fnum;  // Current buffer.</a>
<a name="ln6777">    }</a>
<a name="ln6778">    *fnump = n;</a>
<a name="ln6779">  }</a>
<a name="ln6780"> </a>
<a name="ln6781">  n = (int)tv_list_find_nr(l, i++, NULL);  // lnum</a>
<a name="ln6782">  if (n &lt; 0) {</a>
<a name="ln6783">    return FAIL;</a>
<a name="ln6784">  }</a>
<a name="ln6785">  posp-&gt;lnum = n;</a>
<a name="ln6786"> </a>
<a name="ln6787">  n = (int)tv_list_find_nr(l, i++, NULL);  // col</a>
<a name="ln6788">  if (n &lt; 0) {</a>
<a name="ln6789">    return FAIL;</a>
<a name="ln6790">  }</a>
<a name="ln6791">  // If character position is specified, then convert to byte position</a>
<a name="ln6792">  // If the line number is zero use the cursor line.</a>
<a name="ln6793">  if (charcol) {</a>
<a name="ln6794">    // Get the text for the specified line in a loaded buffer</a>
<a name="ln6795">    buf_T *buf = buflist_findnr(fnump == NULL ? curbuf-&gt;b_fnum : *fnump);</a>
<a name="ln6796">    if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln6797">      return FAIL;</a>
<a name="ln6798">    }</a>
<a name="ln6799">    n = buf_charidx_to_byteidx(buf,</a>
<a name="ln6800">                               posp-&gt;lnum == 0 ? curwin-&gt;w_cursor.lnum : posp-&gt;lnum,</a>
<a name="ln6801">                               n) + 1;</a>
<a name="ln6802">  }</a>
<a name="ln6803">  posp-&gt;col = n;</a>
<a name="ln6804"> </a>
<a name="ln6805">  n = (int)tv_list_find_nr(l, i, NULL);  // off</a>
<a name="ln6806">  if (n &lt; 0) {</a>
<a name="ln6807">    posp-&gt;coladd = 0;</a>
<a name="ln6808">  } else {</a>
<a name="ln6809">    posp-&gt;coladd = n;</a>
<a name="ln6810">  }</a>
<a name="ln6811"> </a>
<a name="ln6812">  if (curswantp != NULL) {</a>
<a name="ln6813">    *curswantp = (colnr_T)tv_list_find_nr(l, i + 1, NULL);  // curswant</a>
<a name="ln6814">  }</a>
<a name="ln6815"> </a>
<a name="ln6816">  return OK;</a>
<a name="ln6817">}</a>
<a name="ln6818"> </a>
<a name="ln6819">/// Get the length of an environment variable name.</a>
<a name="ln6820">/// Advance &quot;arg&quot; to the first character after the name.</a>
<a name="ln6821">///</a>
<a name="ln6822">/// @return  0 for error.</a>
<a name="ln6823">int get_env_len(const char **arg)</a>
<a name="ln6824">{</a>
<a name="ln6825">  const char *p;</a>
<a name="ln6826">  for (p = *arg; vim_isIDc((uint8_t)(*p)); p++) {}</a>
<a name="ln6827">  if (p == *arg) {  // No name found.</a>
<a name="ln6828">    return 0;</a>
<a name="ln6829">  }</a>
<a name="ln6830"> </a>
<a name="ln6831">  int len = (int)(p - *arg);</a>
<a name="ln6832">  *arg = p;</a>
<a name="ln6833">  return len;</a>
<a name="ln6834">}</a>
<a name="ln6835"> </a>
<a name="ln6836">/// Get the length of the name of a function or internal variable.</a>
<a name="ln6837">///</a>
<a name="ln6838">/// @param arg  is advanced to the first non-white character after the name.</a>
<a name="ln6839">///</a>
<a name="ln6840">/// @return  0 if something is wrong.</a>
<a name="ln6841">int get_id_len(const char **const arg)</a>
<a name="ln6842">{</a>
<a name="ln6843">  int len;</a>
<a name="ln6844"> </a>
<a name="ln6845">  // Find the end of the name.</a>
<a name="ln6846">  const char *p;</a>
<a name="ln6847">  for (p = *arg; eval_isnamec(*p); p++) {</a>
<a name="ln6848">    if (*p == ':') {</a>
<a name="ln6849">      // &quot;s:&quot; is start of &quot;s:var&quot;, but &quot;n:&quot; is not and can be used in</a>
<a name="ln6850">      // slice &quot;[n:]&quot;. Also &quot;xx:&quot; is not a namespace.</a>
<a name="ln6851">      len = (int)(p - *arg);</a>
<a name="ln6852">      if (len &gt; 1</a>
<a name="ln6853">          || (len == 1 &amp;&amp; vim_strchr(namespace_char, (uint8_t)(**arg)) == NULL)) {</a>
<a name="ln6854">        break;</a>
<a name="ln6855">      }</a>
<a name="ln6856">    }</a>
<a name="ln6857">  }</a>
<a name="ln6858">  if (p == *arg) {  // no name found</a>
<a name="ln6859">    return 0;</a>
<a name="ln6860">  }</a>
<a name="ln6861"> </a>
<a name="ln6862">  len = (int)(p - *arg);</a>
<a name="ln6863">  *arg = skipwhite(p);</a>
<a name="ln6864"> </a>
<a name="ln6865">  return len;</a>
<a name="ln6866">}</a>
<a name="ln6867"> </a>
<a name="ln6868">/// Get the length of the name of a variable or function.</a>
<a name="ln6869">/// Only the name is recognized, does not handle &quot;.key&quot; or &quot;[idx]&quot;.</a>
<a name="ln6870">///</a>
<a name="ln6871">/// @param arg  is advanced to the first non-white character after the name.</a>
<a name="ln6872">///             If the name contains 'magic' {}'s, expand them and return the</a>
<a name="ln6873">///             expanded name in an allocated string via 'alias' - caller must free.</a>
<a name="ln6874">///</a>
<a name="ln6875">/// @return  -1 if curly braces expansion failed or</a>
<a name="ln6876">///           0 if something else is wrong.</a>
<a name="ln6877">int get_name_len(const char **const arg, char **alias, bool evaluate, bool verbose)</a>
<a name="ln6878">{</a>
<a name="ln6879">  *alias = NULL;    // default to no alias</a>
<a name="ln6880"> </a>
<a name="ln6881">  if ((*arg)[0] == (char)K_SPECIAL &amp;&amp; (*arg)[1] == (char)KS_EXTRA</a>
<a name="ln6882">      &amp;&amp; (*arg)[2] == (char)KE_SNR) {</a>
<a name="ln6883">    // Hard coded &lt;SNR&gt;, already translated.</a>
<a name="ln6884">    *arg += 3;</a>
<a name="ln6885">    return get_id_len(arg) + 3;</a>
<a name="ln6886">  }</a>
<a name="ln6887">  int len = eval_fname_script(*arg);</a>
<a name="ln6888">  if (len &gt; 0) {</a>
<a name="ln6889">    // literal &quot;&lt;SID&gt;&quot;, &quot;s:&quot; or &quot;&lt;SNR&gt;&quot;</a>
<a name="ln6890">    *arg += len;</a>
<a name="ln6891">  }</a>
<a name="ln6892"> </a>
<a name="ln6893">  // Find the end of the name; check for {} construction.</a>
<a name="ln6894">  char *expr_start;</a>
<a name="ln6895">  char *expr_end;</a>
<a name="ln6896">  const char *p = find_name_end((*arg), (const char **)&amp;expr_start, (const char **)&amp;expr_end,</a>
<a name="ln6897">                                len &gt; 0 ? 0 : FNE_CHECK_START);</a>
<a name="ln6898">  if (expr_start != NULL) {</a>
<a name="ln6899">    if (!evaluate) {</a>
<a name="ln6900">      len += (int)(p - *arg);</a>
<a name="ln6901">      *arg = skipwhite(p);</a>
<a name="ln6902">      return len;</a>
<a name="ln6903">    }</a>
<a name="ln6904"> </a>
<a name="ln6905">    // Include any &lt;SID&gt; etc in the expanded string:</a>
<a name="ln6906">    // Thus the -len here.</a>
<a name="ln6907">    char *temp_string = make_expanded_name(*arg - len, expr_start, expr_end, (char *)p);</a>
<a name="ln6908">    if (temp_string == NULL) {</a>
<a name="ln6909">      return -1;</a>
<a name="ln6910">    }</a>
<a name="ln6911">    *alias = temp_string;</a>
<a name="ln6912">    *arg = skipwhite(p);</a>
<a name="ln6913">    return (int)strlen(temp_string);</a>
<a name="ln6914">  }</a>
<a name="ln6915"> </a>
<a name="ln6916">  len += get_id_len(arg);</a>
<a name="ln6917">  // Only give an error when there is something, otherwise it will be</a>
<a name="ln6918">  // reported at a higher level.</a>
<a name="ln6919">  if (len == 0 &amp;&amp; verbose &amp;&amp; **arg != NUL) {</a>
<a name="ln6920">    semsg(_(e_invexpr2), *arg);</a>
<a name="ln6921">  }</a>
<a name="ln6922"> </a>
<a name="ln6923">  return len;</a>
<a name="ln6924">}</a>
<a name="ln6925"> </a>
<a name="ln6926">/// Find the end of a variable or function name, taking care of magic braces.</a>
<a name="ln6927">///</a>
<a name="ln6928">/// @param expr_start  if not NULL, then `expr_start` and `expr_end` are set to the</a>
<a name="ln6929">///                    start and end of the first magic braces item.</a>
<a name="ln6930">///</a>
<a name="ln6931">/// @param flags  can have FNE_INCL_BR and FNE_CHECK_START.</a>
<a name="ln6932">///</a>
<a name="ln6933">/// @return  a pointer to just after the name.  Equal to &quot;arg&quot; if there is no</a>
<a name="ln6934">///          valid name.</a>
<a name="ln6935">const char *find_name_end(const char *arg, const char **expr_start, const char **expr_end,</a>
<a name="ln6936">                          int flags)</a>
<a name="ln6937">{</a>
<a name="ln6938">  if (expr_start != NULL) {</a>
<a name="ln6939">    *expr_start = NULL;</a>
<a name="ln6940">    *expr_end = NULL;</a>
<a name="ln6941">  }</a>
<a name="ln6942"> </a>
<a name="ln6943">  // Quick check for valid starting character.</a>
<a name="ln6944">  if ((flags &amp; FNE_CHECK_START) &amp;&amp; !eval_isnamec1(*arg) &amp;&amp; *arg != '{') {</a>
<a name="ln6945">    return arg;</a>
<a name="ln6946">  }</a>
<a name="ln6947"> </a>
<a name="ln6948">  int mb_nest = 0;</a>
<a name="ln6949">  int br_nest = 0;</a>
<a name="ln6950">  int len;</a>
<a name="ln6951"> </a>
<a name="ln6952">  const char *p;</a>
<a name="ln6953">  for (p = arg; *p != NUL</a>
<a name="ln6954">       &amp;&amp; (eval_isnamec(*p)</a>
<a name="ln6955">           || *p == '{'</a>
<a name="ln6956">           || ((flags &amp; FNE_INCL_BR) &amp;&amp; (*p == '['</a>
<a name="ln6957">                                         || (*p == '.' &amp;&amp; eval_isdictc(p[1]))))</a>
<a name="ln6958">           || mb_nest != 0</a>
<a name="ln6959">           || br_nest != 0); MB_PTR_ADV(p)) {</a>
<a name="ln6960">    if (*p == '\'') {</a>
<a name="ln6961">      // skip over 'string' to avoid counting [ and ] inside it.</a>
<a name="ln6962">      for (p = p + 1; *p != NUL &amp;&amp; *p != '\''; MB_PTR_ADV(p)) {}</a>
<a name="ln6963">      if (*p == NUL) {</a>
<a name="ln6964">        break;</a>
<a name="ln6965">      }</a>
<a name="ln6966">    } else if (*p == '&quot;') {</a>
<a name="ln6967">      // skip over &quot;str\&quot;ing&quot; to avoid counting [ and ] inside it.</a>
<a name="ln6968">      for (p = p + 1; *p != NUL &amp;&amp; *p != '&quot;'; MB_PTR_ADV(p)) {</a>
<a name="ln6969">        if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln6970">          p++;</a>
<a name="ln6971">        }</a>
<a name="ln6972">      }</a>
<a name="ln6973">      if (*p == NUL) {</a>
<a name="ln6974">        break;</a>
<a name="ln6975">      }</a>
<a name="ln6976">    } else if (br_nest == 0 &amp;&amp; mb_nest == 0 &amp;&amp; *p == ':') {</a>
<a name="ln6977">      // &quot;s:&quot; is start of &quot;s:var&quot;, but &quot;n:&quot; is not and can be used in</a>
<a name="ln6978">      // slice &quot;[n:]&quot;.  Also &quot;xx:&quot; is not a namespace. But {ns}: is.</a>
<a name="ln6979">      len = (int)(p - arg);</a>
<a name="ln6980">      if ((len &gt; 1 &amp;&amp; p[-1] != '}')</a>
<a name="ln6981">          || (len == 1 &amp;&amp; vim_strchr(namespace_char, (uint8_t)(*arg)) == NULL)) {</a>
<a name="ln6982">        break;</a>
<a name="ln6983">      }</a>
<a name="ln6984">    }</a>
<a name="ln6985"> </a>
<a name="ln6986">    if (mb_nest == 0) {</a>
<a name="ln6987">      if (*p == '[') {</a>
<a name="ln6988">        br_nest++;</a>
<a name="ln6989">      } else if (*p == ']') {</a>
<a name="ln6990">        br_nest--;</a>
<a name="ln6991">      }</a>
<a name="ln6992">    }</a>
<a name="ln6993"> </a>
<a name="ln6994">    if (br_nest == 0) {</a>
<a name="ln6995">      if (*p == '{') {</a>
<a name="ln6996">        mb_nest++;</a>
<a name="ln6997">        if (expr_start != NULL &amp;&amp; *expr_start == NULL) {</a>
<a name="ln6998">          *expr_start = p;</a>
<a name="ln6999">        }</a>
<a name="ln7000">      } else if (*p == '}') {</a>
<a name="ln7001">        mb_nest--;</a>
<a name="ln7002">        if (expr_start != NULL &amp;&amp; mb_nest == 0 &amp;&amp; *expr_end == NULL) {</a>
<a name="ln7003">          *expr_end = p;</a>
<a name="ln7004">        }</a>
<a name="ln7005">      }</a>
<a name="ln7006">    }</a>
<a name="ln7007">  }</a>
<a name="ln7008"> </a>
<a name="ln7009">  return p;</a>
<a name="ln7010">}</a>
<a name="ln7011"> </a>
<a name="ln7012">/// Expands out the 'magic' {}'s in a variable/function name.</a>
<a name="ln7013">/// Note that this can call itself recursively, to deal with</a>
<a name="ln7014">/// constructs like foo{bar}{baz}{bam}</a>
<a name="ln7015">/// The four pointer arguments point to &quot;foo{expre}ss{ion}bar&quot;</a>
<a name="ln7016">///                      &quot;in_start&quot;      ^</a>
<a name="ln7017">///                      &quot;expr_start&quot;       ^</a>
<a name="ln7018">///                      &quot;expr_end&quot;               ^</a>
<a name="ln7019">///                      &quot;in_end&quot;                            ^</a>
<a name="ln7020">///</a>
<a name="ln7021">/// @return  a new allocated string, which the caller must free or</a>
<a name="ln7022">///          NULL for failure.</a>
<a name="ln7023">static char *make_expanded_name(const char *in_start, char *expr_start, char *expr_end,</a>
<a name="ln7024">                                char *in_end)</a>
<a name="ln7025">{</a>
<a name="ln7026">  if (expr_end == NULL || in_end == NULL) {</a>
<a name="ln7027">    return NULL;</a>
<a name="ln7028">  }</a>
<a name="ln7029"> </a>
<a name="ln7030">  char *retval = NULL;</a>
<a name="ln7031"> </a>
<a name="ln7032">  *expr_start = NUL;</a>
<a name="ln7033">  *expr_end = NUL;</a>
<a name="ln7034">  char c1 = *in_end;</a>
<a name="ln7035">  *in_end = NUL;</a>
<a name="ln7036"> </a>
<a name="ln7037">  char *temp_result = eval_to_string(expr_start + 1, false);</a>
<a name="ln7038">  if (temp_result != NULL) {</a>
<a name="ln7039">    retval = xmalloc(strlen(temp_result) + (size_t)(expr_start - in_start)</a>
<a name="ln7040">                     + (size_t)(in_end - expr_end) + 1);</a>
<a name="ln7041">    STRCPY(retval, in_start);</a>
<a name="ln7042">    STRCAT(retval, temp_result);</a>
<a name="ln7043">    STRCAT(retval, expr_end + 1);</a>
<a name="ln7044">  }</a>
<a name="ln7045">  xfree(temp_result);</a>
<a name="ln7046"> </a>
<a name="ln7047">  *in_end = c1;                 // put char back for error messages</a>
<a name="ln7048">  *expr_start = '{';</a>
<a name="ln7049">  *expr_end = '}';</a>
<a name="ln7050"> </a>
<a name="ln7051">  if (retval != NULL) {</a>
<a name="ln7052">    temp_result = (char *)find_name_end(retval,</a>
<a name="ln7053">                                        (const char **)&amp;expr_start,</a>
<a name="ln7054">                                        (const char **)&amp;expr_end, 0);</a>
<a name="ln7055">    if (expr_start != NULL) {</a>
<a name="ln7056">      // Further expansion!</a>
<a name="ln7057">      temp_result = make_expanded_name(retval, expr_start,</a>
<a name="ln7058">                                       expr_end, temp_result);</a>
<a name="ln7059">      xfree(retval);</a>
<a name="ln7060">      retval = temp_result;</a>
<a name="ln7061">    }</a>
<a name="ln7062">  }</a>
<a name="ln7063"> </a>
<a name="ln7064">  return retval;</a>
<a name="ln7065">}</a>
<a name="ln7066"> </a>
<a name="ln7067">/// @return  true if character &quot;c&quot; can be used in a variable or function name.</a>
<a name="ln7068">///          Does not include '{' or '}' for magic braces.</a>
<a name="ln7069">bool eval_isnamec(int c)</a>
<a name="ln7070">{</a>
<a name="ln7071">  return ASCII_ISALNUM(c) || c == '_' || c == ':' || c == AUTOLOAD_CHAR;</a>
<a name="ln7072">}</a>
<a name="ln7073"> </a>
<a name="ln7074">/// @return  true if character &quot;c&quot; can be used as the first character in a</a>
<a name="ln7075">///          variable or function name (excluding '{' and '}').</a>
<a name="ln7076">bool eval_isnamec1(int c)</a>
<a name="ln7077">{</a>
<a name="ln7078">  return ASCII_ISALPHA(c) || c == '_';</a>
<a name="ln7079">}</a>
<a name="ln7080"> </a>
<a name="ln7081">/// @return  true if character &quot;c&quot; can be used as the first character of a</a>
<a name="ln7082">///          dictionary key.</a>
<a name="ln7083">bool eval_isdictc(int c)</a>
<a name="ln7084">{</a>
<a name="ln7085">  return ASCII_ISALNUM(c) || c == '_';</a>
<a name="ln7086">}</a>
<a name="ln7087"> </a>
<a name="ln7088">/// Get typval_T v: variable value.</a>
<a name="ln7089">typval_T *get_vim_var_tv(int idx)</a>
<a name="ln7090">{</a>
<a name="ln7091">  return &amp;vimvars[idx].vv_tv;</a>
<a name="ln7092">}</a>
<a name="ln7093"> </a>
<a name="ln7094">/// Get number v: variable value.</a>
<a name="ln7095">varnumber_T get_vim_var_nr(int idx) FUNC_ATTR_PURE</a>
<a name="ln7096">{</a>
<a name="ln7097">  return vimvars[idx].vv_nr;</a>
<a name="ln7098">}</a>
<a name="ln7099"> </a>
<a name="ln7100">/// Get string v: variable value.  Uses a static buffer, can only be used once.</a>
<a name="ln7101">/// If the String variable has never been set, return an empty string.</a>
<a name="ln7102">/// Never returns NULL.</a>
<a name="ln7103">char *get_vim_var_str(int idx)</a>
<a name="ln7104">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_RET</a>
<a name="ln7105">{</a>
<a name="ln7106">  return (char *)tv_get_string(&amp;vimvars[idx].vv_tv);</a>
<a name="ln7107">}</a>
<a name="ln7108"> </a>
<a name="ln7109">/// Get List v: variable value.  Caller must take care of reference count when</a>
<a name="ln7110">/// needed.</a>
<a name="ln7111">list_T *get_vim_var_list(int idx) FUNC_ATTR_PURE</a>
<a name="ln7112">{</a>
<a name="ln7113">  return vimvars[idx].vv_list;</a>
<a name="ln7114">}</a>
<a name="ln7115"> </a>
<a name="ln7116">/// Get Dictionary v: variable value.  Caller must take care of reference count</a>
<a name="ln7117">/// when needed.</a>
<a name="ln7118">dict_T *get_vim_var_dict(int idx) FUNC_ATTR_PURE</a>
<a name="ln7119">{</a>
<a name="ln7120">  return vimvars[idx].vv_dict;</a>
<a name="ln7121">}</a>
<a name="ln7122"> </a>
<a name="ln7123">/// Set v:char to character &quot;c&quot;.</a>
<a name="ln7124">void set_vim_var_char(int c)</a>
<a name="ln7125">{</a>
<a name="ln7126">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln7127"> </a>
<a name="ln7128">  buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln7129">  set_vim_var_string(VV_CHAR, buf, -1);</a>
<a name="ln7130">}</a>
<a name="ln7131"> </a>
<a name="ln7132">/// Set v:count to &quot;count&quot; and v:count1 to &quot;count1&quot;.</a>
<a name="ln7133">///</a>
<a name="ln7134">/// @param set_prevcount  if true, first set v:prevcount from v:count.</a>
<a name="ln7135">void set_vcount(int64_t count, int64_t count1, bool set_prevcount)</a>
<a name="ln7136">{</a>
<a name="ln7137">  if (set_prevcount) {</a>
<a name="ln7138">    vimvars[VV_PREVCOUNT].vv_nr = vimvars[VV_COUNT].vv_nr;</a>
<a name="ln7139">  }</a>
<a name="ln7140">  vimvars[VV_COUNT].vv_nr = count;</a>
<a name="ln7141">  vimvars[VV_COUNT1].vv_nr = count1;</a>
<a name="ln7142">}</a>
<a name="ln7143"> </a>
<a name="ln7144">/// Set number v: variable to the given value</a>
<a name="ln7145">///</a>
<a name="ln7146">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7147">/// @param[in]  val  Value to set to.</a>
<a name="ln7148">void set_vim_var_nr(const VimVarIndex idx, const varnumber_T val)</a>
<a name="ln7149">{</a>
<a name="ln7150">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln7151">  vimvars[idx].vv_type = VAR_NUMBER;</a>
<a name="ln7152">  vimvars[idx].vv_nr = val;</a>
<a name="ln7153">}</a>
<a name="ln7154"> </a>
<a name="ln7155">/// Set boolean v: {true, false} to the given value</a>
<a name="ln7156">///</a>
<a name="ln7157">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7158">/// @param[in]  val  Value to set to.</a>
<a name="ln7159">void set_vim_var_bool(const VimVarIndex idx, const BoolVarValue val)</a>
<a name="ln7160">{</a>
<a name="ln7161">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln7162">  vimvars[idx].vv_type = VAR_BOOL;</a>
<a name="ln7163">  vimvars[idx].vv_bool = val;</a>
<a name="ln7164">}</a>
<a name="ln7165"> </a>
<a name="ln7166">/// Set special v: variable to the given value</a>
<a name="ln7167">///</a>
<a name="ln7168">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7169">/// @param[in]  val  Value to set to.</a>
<a name="ln7170">void set_vim_var_special(const VimVarIndex idx, const SpecialVarValue val)</a>
<a name="ln7171">{</a>
<a name="ln7172">  tv_clear(&amp;vimvars[idx].vv_tv);</a>
<a name="ln7173">  vimvars[idx].vv_type = VAR_SPECIAL;</a>
<a name="ln7174">  vimvars[idx].vv_special = val;</a>
<a name="ln7175">}</a>
<a name="ln7176"> </a>
<a name="ln7177">/// Set string v: variable to the given string</a>
<a name="ln7178">///</a>
<a name="ln7179">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7180">/// @param[in]  val  Value to set to. Will be copied.</a>
<a name="ln7181">/// @param[in]  len  Length of that value or -1 in which case strlen() will be</a>
<a name="ln7182">///                  used.</a>
<a name="ln7183">void set_vim_var_string(const VimVarIndex idx, const char *const val, const ptrdiff_t len)</a>
<a name="ln7184">{</a>
<a name="ln7185">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln7186">  vimvars[idx].vv_type = VAR_STRING;</a>
<a name="ln7187">  if (val == NULL) {</a>
<a name="ln7188">    vimvars[idx].vv_str = NULL;</a>
<a name="ln7189">  } else if (len == -1) {</a>
<a name="ln7190">    vimvars[idx].vv_str = xstrdup(val);</a>
<a name="ln7191">  } else {</a>
<a name="ln7192">    vimvars[idx].vv_str = xstrndup(val, (size_t)len);</a>
<a name="ln7193">  }</a>
<a name="ln7194">}</a>
<a name="ln7195"> </a>
<a name="ln7196">/// Set list v: variable to the given list</a>
<a name="ln7197">///</a>
<a name="ln7198">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7199">/// @param[in,out]  val  Value to set to. Reference count will be incremented.</a>
<a name="ln7200">void set_vim_var_list(const VimVarIndex idx, list_T *const val)</a>
<a name="ln7201">{</a>
<a name="ln7202">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln7203">  vimvars[idx].vv_type = VAR_LIST;</a>
<a name="ln7204">  vimvars[idx].vv_list = val;</a>
<a name="ln7205">  if (val != NULL) {</a>
<a name="ln7206">    tv_list_ref(val);</a>
<a name="ln7207">  }</a>
<a name="ln7208">}</a>
<a name="ln7209"> </a>
<a name="ln7210">/// Set Dictionary v: variable to the given dictionary</a>
<a name="ln7211">///</a>
<a name="ln7212">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7213">/// @param[in,out]  val  Value to set to. Reference count will be incremented.</a>
<a name="ln7214">///                      Also keys of the dictionary will be made read-only.</a>
<a name="ln7215">void set_vim_var_dict(const VimVarIndex idx, dict_T *const val)</a>
<a name="ln7216">{</a>
<a name="ln7217">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln7218">  vimvars[idx].vv_type = VAR_DICT;</a>
<a name="ln7219">  vimvars[idx].vv_dict = val;</a>
<a name="ln7220">  if (val == NULL) {</a>
<a name="ln7221">    return;</a>
<a name="ln7222">  }</a>
<a name="ln7223"> </a>
<a name="ln7224">  val-&gt;dv_refcount++;</a>
<a name="ln7225">  // Set readonly</a>
<a name="ln7226">  tv_dict_set_keys_readonly(val);</a>
<a name="ln7227">}</a>
<a name="ln7228"> </a>
<a name="ln7229">/// Set v:variable to tv.</a>
<a name="ln7230">///</a>
<a name="ln7231">/// @param[in]  idx  Index of variable to set.</a>
<a name="ln7232">/// @param[in]  val  Value to set to. Will be copied.</a>
<a name="ln7233">void set_vim_var_tv(const VimVarIndex idx, typval_T *const tv)</a>
<a name="ln7234">{</a>
<a name="ln7235">  tv_clear(&amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln7236">  tv_copy(tv, &amp;vimvars[idx].vv_di.di_tv);</a>
<a name="ln7237">}</a>
<a name="ln7238"> </a>
<a name="ln7239">/// Set the v:argv list.</a>
<a name="ln7240">void set_argv_var(char **argv, int argc)</a>
<a name="ln7241">{</a>
<a name="ln7242">  list_T *l = tv_list_alloc(argc);</a>
<a name="ln7243">  int i;</a>
<a name="ln7244"> </a>
<a name="ln7245">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln7246">  for (i = 0; i &lt; argc; i++) {</a>
<a name="ln7247">    tv_list_append_string(l, (const char *const)argv[i], -1);</a>
<a name="ln7248">    TV_LIST_ITEM_TV(tv_list_last(l))-&gt;v_lock = VAR_FIXED;</a>
<a name="ln7249">  }</a>
<a name="ln7250">  set_vim_var_list(VV_ARGV, l);</a>
<a name="ln7251">}</a>
<a name="ln7252"> </a>
<a name="ln7253">/// Set v:register if needed.</a>
<a name="ln7254">void set_reg_var(int c)</a>
<a name="ln7255">{</a>
<a name="ln7256">  char regname;</a>
<a name="ln7257"> </a>
<a name="ln7258">  if (c == 0 || c == ' ') {</a>
<a name="ln7259">    regname = '&quot;';</a>
<a name="ln7260">  } else {</a>
<a name="ln7261">    regname = (char)c;</a>
<a name="ln7262">  }</a>
<a name="ln7263">  // Avoid free/alloc when the value is already right.</a>
<a name="ln7264">  if (vimvars[VV_REG].vv_str == NULL || vimvars[VV_REG].vv_str[0] != c) {</a>
<a name="ln7265">    set_vim_var_string(VV_REG, &amp;regname, 1);</a>
<a name="ln7266">  }</a>
<a name="ln7267">}</a>
<a name="ln7268"> </a>
<a name="ln7269">/// Get or set v:exception.  If &quot;oldval&quot; == NULL, return the current value.</a>
<a name="ln7270">/// Otherwise, restore the value to &quot;oldval&quot; and return NULL.</a>
<a name="ln7271">/// Must always be called in pairs to save and restore v:exception!  Does not</a>
<a name="ln7272">/// take care of memory allocations.</a>
<a name="ln7273">char *v_exception(char *oldval)</a>
<a name="ln7274">{</a>
<a name="ln7275">  if (oldval == NULL) {</a>
<a name="ln7276">    return vimvars[VV_EXCEPTION].vv_str;</a>
<a name="ln7277">  }</a>
<a name="ln7278"> </a>
<a name="ln7279">  vimvars[VV_EXCEPTION].vv_str = oldval;</a>
<a name="ln7280">  return NULL;</a>
<a name="ln7281">}</a>
<a name="ln7282"> </a>
<a name="ln7283">/// Get or set v:throwpoint.  If &quot;oldval&quot; == NULL, return the current value.</a>
<a name="ln7284">/// Otherwise, restore the value to &quot;oldval&quot; and return NULL.</a>
<a name="ln7285">/// Must always be called in pairs to save and restore v:throwpoint!  Does not</a>
<a name="ln7286">/// take care of memory allocations.</a>
<a name="ln7287">char *v_throwpoint(char *oldval)</a>
<a name="ln7288">{</a>
<a name="ln7289">  if (oldval == NULL) {</a>
<a name="ln7290">    return vimvars[VV_THROWPOINT].vv_str;</a>
<a name="ln7291">  }</a>
<a name="ln7292"> </a>
<a name="ln7293">  vimvars[VV_THROWPOINT].vv_str = oldval;</a>
<a name="ln7294">  return NULL;</a>
<a name="ln7295">}</a>
<a name="ln7296"> </a>
<a name="ln7297">/// Set v:cmdarg.</a>
<a name="ln7298">/// If &quot;eap&quot; != NULL, use &quot;eap&quot; to generate the value and return the old value.</a>
<a name="ln7299">/// If &quot;oldarg&quot; != NULL, restore the value to &quot;oldarg&quot; and return NULL.</a>
<a name="ln7300">/// Must always be called in pairs!</a>
<a name="ln7301">char *set_cmdarg(exarg_T *eap, char *oldarg)</a>
<a name="ln7302">{</a>
<a name="ln7303">  char *oldval = vimvars[VV_CMDARG].vv_str;</a>
<a name="ln7304">  if (eap == NULL) {</a>
<a name="ln7305">    goto error;</a>
<a name="ln7306">  }</a>
<a name="ln7307"> </a>
<a name="ln7308">  size_t len = 0;</a>
<a name="ln7309">  if (eap-&gt;force_bin == FORCE_BIN) {</a>
<a name="ln7310">    len += 6;  // &quot; ++bin&quot;</a>
<a name="ln7311">  } else if (eap-&gt;force_bin == FORCE_NOBIN) {</a>
<a name="ln7312">    len += 8;  // &quot; ++nobin&quot;</a>
<a name="ln7313">  }</a>
<a name="ln7314"> </a>
<a name="ln7315">  if (eap-&gt;read_edit) {</a>
<a name="ln7316">    len += 7;  // &quot; ++edit&quot;</a>
<a name="ln7317">  }</a>
<a name="ln7318"> </a>
<a name="ln7319">  if (eap-&gt;force_ff != 0) {</a>
<a name="ln7320">    len += 10;  // &quot; ++ff=unix&quot;</a>
<a name="ln7321">  }</a>
<a name="ln7322">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln7323">    len += strlen(eap-&gt;cmd + eap-&gt;force_enc) + 7;</a>
<a name="ln7324">  }</a>
<a name="ln7325">  if (eap-&gt;bad_char != 0) {</a>
<a name="ln7326">    len += 7 + 4;  // &quot; ++bad=&quot; + &quot;keep&quot; or &quot;drop&quot;</a>
<a name="ln7327">  }</a>
<a name="ln7328">  if (eap-&gt;mkdir_p != 0) {</a>
<a name="ln7329">    len += 4;  // &quot; ++p&quot;</a>
<a name="ln7330">  }</a>
<a name="ln7331"> </a>
<a name="ln7332">  const size_t newval_len = len + 1;</a>
<a name="ln7333">  char *newval = xmalloc(newval_len);</a>
<a name="ln7334">  size_t xlen = 0;</a>
<a name="ln7335">  int rc = 0;</a>
<a name="ln7336"> </a>
<a name="ln7337">  if (eap-&gt;force_bin == FORCE_BIN) {</a>
<a name="ln7338">    rc = snprintf(newval, newval_len, &quot; ++bin&quot;);</a>
<a name="ln7339">  } else if (eap-&gt;force_bin == FORCE_NOBIN) {</a>
<a name="ln7340">    rc = snprintf(newval, newval_len, &quot; ++nobin&quot;);</a>
<a name="ln7341">  } else {</a>
<a name="ln7342">    *newval = NUL;</a>
<a name="ln7343">  }</a>
<a name="ln7344">  if (rc &lt; 0) {</a>
<a name="ln7345">    goto error;</a>
<a name="ln7346">  }</a>
<a name="ln7347">  xlen += (size_t)rc;</a>
<a name="ln7348"> </a>
<a name="ln7349">  if (eap-&gt;read_edit) {</a>
<a name="ln7350">    rc = snprintf(newval + xlen, newval_len - xlen, &quot; ++edit&quot;);</a>
<a name="ln7351">    if (rc &lt; 0) {</a>
<a name="ln7352">      goto error;</a>
<a name="ln7353">    }</a>
<a name="ln7354">    xlen += (size_t)rc;</a>
<a name="ln7355">  }</a>
<a name="ln7356"> </a>
<a name="ln7357">  if (eap-&gt;force_ff != 0) {</a>
<a name="ln7358">    rc = snprintf(newval + xlen,</a>
<a name="ln7359">                  newval_len - xlen,</a>
<a name="ln7360">                  &quot; ++ff=%s&quot;,</a>
<a name="ln7361">                  eap-&gt;force_ff == 'u' ? &quot;unix&quot;</a>
<a name="ln7362">                  : eap-&gt;force_ff == 'd' ? &quot;dos&quot; : &quot;mac&quot;);</a>
<a name="ln7363">    if (rc &lt; 0) {</a>
<a name="ln7364">      goto error;</a>
<a name="ln7365">    }</a>
<a name="ln7366">    xlen += (size_t)rc;</a>
<a name="ln7367">  }</a>
<a name="ln7368">  if (eap-&gt;force_enc != 0) {</a>
<a name="ln7369">    rc = snprintf(newval + (xlen), newval_len - xlen, &quot; ++enc=%s&quot;, eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln7370">    if (rc &lt; 0) {</a>
<a name="ln7371">      goto error;</a>
<a name="ln7372">    }</a>
<a name="ln7373">    xlen += (size_t)rc;</a>
<a name="ln7374">  }</a>
<a name="ln7375"> </a>
<a name="ln7376">  if (eap-&gt;bad_char == BAD_KEEP) {</a>
<a name="ln7377">    rc = snprintf(newval + xlen, newval_len - xlen, &quot; ++bad=keep&quot;);</a>
<a name="ln7378">    if (rc &lt; 0) {</a>
<a name="ln7379">      goto error;</a>
<a name="ln7380">    }</a>
<a name="ln7381">    xlen += (size_t)rc;</a>
<a name="ln7382">  } else if (eap-&gt;bad_char == BAD_DROP) {</a>
<a name="ln7383">    rc = snprintf(newval + xlen, newval_len - xlen, &quot; ++bad=drop&quot;);</a>
<a name="ln7384">    if (rc &lt; 0) {</a>
<a name="ln7385">      goto error;</a>
<a name="ln7386">    }</a>
<a name="ln7387">    xlen += (size_t)rc;</a>
<a name="ln7388">  } else if (eap-&gt;bad_char != 0) {</a>
<a name="ln7389">    rc = snprintf(newval + xlen, newval_len - xlen, &quot; ++bad=%c&quot;, eap-&gt;bad_char);</a>
<a name="ln7390">    if (rc &lt; 0) {</a>
<a name="ln7391">      goto error;</a>
<a name="ln7392">    }</a>
<a name="ln7393">    xlen += (size_t)rc;</a>
<a name="ln7394">  }</a>
<a name="ln7395"> </a>
<a name="ln7396">  if (eap-&gt;mkdir_p != 0) {</a>
<a name="ln7397">    rc = snprintf(newval + xlen, newval_len - xlen, &quot; ++p&quot;);</a>
<a name="ln7398">    if (rc &lt; 0) {</a>
<a name="ln7399">      goto error;</a>
<a name="ln7400">    }</a>
<a name="ln7401">    xlen += (size_t)rc;</a>
<a name="ln7402">  }</a>
<a name="ln7403">  assert(xlen &lt;= newval_len);</a>
<a name="ln7404"> </a>
<a name="ln7405">  vimvars[VV_CMDARG].vv_str = newval;</a>
<a name="ln7406">  return oldval;</a>
<a name="ln7407"> </a>
<a name="ln7408">error:</a>
<a name="ln7409">  xfree(oldval);</a>
<a name="ln7410">  vimvars[VV_CMDARG].vv_str = oldarg;</a>
<a name="ln7411">  return NULL;</a>
<a name="ln7412">}</a>
<a name="ln7413"> </a>
<a name="ln7414">/// Check if variable &quot;name[len]&quot; is a local variable or an argument.</a>
<a name="ln7415">/// If so, &quot;*eval_lavars_used&quot; is set to true.</a>
<a name="ln7416">static void check_vars(const char *name, size_t len)</a>
<a name="ln7417">{</a>
<a name="ln7418">  if (eval_lavars_used == NULL) {</a>
<a name="ln7419">    return;</a>
<a name="ln7420">  }</a>
<a name="ln7421"> </a>
<a name="ln7422">  const char *varname;</a>
<a name="ln7423">  hashtab_T *ht = find_var_ht(name, len, &amp;varname);</a>
<a name="ln7424"> </a>
<a name="ln7425">  if (ht == get_funccal_local_ht() || ht == get_funccal_args_ht()) {</a>
<a name="ln7426">    if (find_var(name, len, NULL, true) != NULL) {</a>
<a name="ln7427">      *eval_lavars_used = true;</a>
<a name="ln7428">    }</a>
<a name="ln7429">  }</a>
<a name="ln7430">}</a>
<a name="ln7431"> </a>
<a name="ln7432">/// check if special v:lua value for calling lua functions</a>
<a name="ln7433">bool is_luafunc(partial_T *partial)</a>
<a name="ln7434">  FUNC_ATTR_PURE</a>
<a name="ln7435">{</a>
<a name="ln7436">  return partial == vvlua_partial;</a>
<a name="ln7437">}</a>
<a name="ln7438"> </a>
<a name="ln7439">/// check if special v:lua value for calling lua functions</a>
<a name="ln7440">static bool tv_is_luafunc(typval_T *tv)</a>
<a name="ln7441">{</a>
<a name="ln7442">  return tv-&gt;v_type == VAR_PARTIAL &amp;&amp; is_luafunc(tv-&gt;vval.v_partial);</a>
<a name="ln7443">}</a>
<a name="ln7444"> </a>
<a name="ln7445">/// Skips one character past the end of the name of a v:lua function.</a>
<a name="ln7446">/// @param p  Pointer to the char AFTER the &quot;v:lua.&quot; prefix.</a>
<a name="ln7447">/// @return Pointer to the char one past the end of the function's name.</a>
<a name="ln7448">const char *skip_luafunc_name(const char *p)</a>
<a name="ln7449">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7450">{</a>
<a name="ln7451">  while (ASCII_ISALNUM(*p) || *p == '_' || *p == '-' || *p == '.' || *p == '\'') {</a>
<a name="ln7452">    p++;</a>
<a name="ln7453">  }</a>
<a name="ln7454">  return p;</a>
<a name="ln7455">}</a>
<a name="ln7456"> </a>
<a name="ln7457">/// check the function name after &quot;v:lua.&quot;</a>
<a name="ln7458">int check_luafunc_name(const char *const str, const bool paren)</a>
<a name="ln7459">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7460">{</a>
<a name="ln7461">  const char *const p = skip_luafunc_name(str);</a>
<a name="ln7462">  if (*p != (paren ? '(' : NUL)) {</a>
<a name="ln7463">    return 0;</a>
<a name="ln7464">  }</a>
<a name="ln7465">  return (int)(p - str);</a>
<a name="ln7466">}</a>
<a name="ln7467"> </a>
<a name="ln7468">/// Return the character &quot;str[index]&quot; where &quot;index&quot; is the character index.  If</a>
<a name="ln7469">/// &quot;index&quot; is out of range NULL is returned.</a>
<a name="ln7470">char *char_from_string(const char *str, varnumber_T index)</a>
<a name="ln7471">{</a>
<a name="ln7472">  size_t nbyte = 0;</a>
<a name="ln7473">  varnumber_T nchar = index;</a>
<a name="ln7474"> </a>
<a name="ln7475">  if (str == NULL || index &lt; 0) {</a>
<a name="ln7476">    return NULL;</a>
<a name="ln7477">  }</a>
<a name="ln7478">  size_t slen = strlen(str);</a>
<a name="ln7479">  while (nchar &gt; 0 &amp;&amp; nbyte &lt; slen) {</a>
<a name="ln7480">    nbyte += (size_t)utf_ptr2len(str + nbyte);</a>
<a name="ln7481">    nchar--;</a>
<a name="ln7482">  }</a>
<a name="ln7483">  if (nbyte &gt;= slen) {</a>
<a name="ln7484">    return NULL;</a>
<a name="ln7485">  }</a>
<a name="ln7486">  return xmemdupz(str + nbyte, (size_t)utf_ptr2len(str + nbyte));</a>
<a name="ln7487">}</a>
<a name="ln7488"> </a>
<a name="ln7489">/// Get the byte index for character index &quot;idx&quot; in string &quot;str&quot; with length</a>
<a name="ln7490">/// &quot;str_len&quot;.</a>
<a name="ln7491">/// If going over the end return &quot;str_len&quot;.</a>
<a name="ln7492">/// If &quot;idx&quot; is negative count from the end, -1 is the last character.</a>
<a name="ln7493">/// When going over the start return -1.</a>
<a name="ln7494">static ssize_t char_idx2byte(const char *str, size_t str_len, varnumber_T idx)</a>
<a name="ln7495">{</a>
<a name="ln7496">  varnumber_T nchar = idx;</a>
<a name="ln7497">  size_t nbyte = 0;</a>
<a name="ln7498"> </a>
<a name="ln7499">  if (nchar &gt;= 0) {</a>
<a name="ln7500">    while (nchar &gt; 0 &amp;&amp; nbyte &lt; str_len) {</a>
<a name="ln7501">      nbyte += (size_t)utf_ptr2len(str + nbyte);</a>
<a name="ln7502">      nchar--;</a>
<a name="ln7503">    }</a>
<a name="ln7504">  } else {</a>
<a name="ln7505">    nbyte = str_len;</a>
<a name="ln7506">    while (nchar &lt; 0 &amp;&amp; nbyte &gt; 0) {</a>
<a name="ln7507">      nbyte--;</a>
<a name="ln7508">      nbyte -= (size_t)utf_head_off(str, str + nbyte);</a>
<a name="ln7509">      nchar++;</a>
<a name="ln7510">    }</a>
<a name="ln7511">    if (nchar &lt; 0) {</a>
<a name="ln7512">      return -1;</a>
<a name="ln7513">    }</a>
<a name="ln7514">  }</a>
<a name="ln7515">  return (ssize_t)nbyte;</a>
<a name="ln7516">}</a>
<a name="ln7517"> </a>
<a name="ln7518">/// Return the slice &quot;str[first:last]&quot; using character indexes.</a>
<a name="ln7519">///</a>
<a name="ln7520">/// @param exclusive  true for slice().</a>
<a name="ln7521">///</a>
<a name="ln7522">/// Return NULL when the result is empty.</a>
<a name="ln7523">char *string_slice(const char *str, varnumber_T first, varnumber_T last, bool exclusive)</a>
<a name="ln7524">{</a>
<a name="ln7525">  if (str == NULL) {</a>
<a name="ln7526">    return NULL;</a>
<a name="ln7527">  }</a>
<a name="ln7528">  size_t slen = strlen(str);</a>
<a name="ln7529">  ssize_t start_byte = char_idx2byte(str, slen, first);</a>
<a name="ln7530">  if (start_byte &lt; 0) {</a>
<a name="ln7531">    start_byte = 0;  // first index very negative: use zero</a>
<a name="ln7532">  }</a>
<a name="ln7533">  ssize_t end_byte;</a>
<a name="ln7534">  if ((last == -1 &amp;&amp; !exclusive) || last == VARNUMBER_MAX) {</a>
<a name="ln7535">    end_byte = (ssize_t)slen;</a>
<a name="ln7536">  } else {</a>
<a name="ln7537">    end_byte = char_idx2byte(str, slen, last);</a>
<a name="ln7538">    if (!exclusive &amp;&amp; end_byte &gt;= 0 &amp;&amp; end_byte &lt; (ssize_t)slen) {</a>
<a name="ln7539">      // end index is inclusive</a>
<a name="ln7540">      end_byte += utf_ptr2len(str + end_byte);</a>
<a name="ln7541">    }</a>
<a name="ln7542">  }</a>
<a name="ln7543"> </a>
<a name="ln7544">  if (start_byte &gt;= (ssize_t)slen || end_byte &lt;= start_byte) {</a>
<a name="ln7545">    return NULL;</a>
<a name="ln7546">  }</a>
<a name="ln7547">  return xmemdupz(str + start_byte, (size_t)(end_byte - start_byte));</a>
<a name="ln7548">}</a>
<a name="ln7549"> </a>
<a name="ln7550">/// Handle:</a>
<a name="ln7551">/// - expr[expr], expr[expr:expr] subscript</a>
<a name="ln7552">/// - &quot;.name&quot; lookup</a>
<a name="ln7553">/// - function call with Funcref variable: func(expr)</a>
<a name="ln7554">/// - method call: var-&gt;method()</a>
<a name="ln7555">///</a>
<a name="ln7556">/// Can all be combined in any order: dict.func(expr)[idx]['func'](expr)-&gt;len()</a>
<a name="ln7557">///</a>
<a name="ln7558">/// @param verbose  give error messages</a>
<a name="ln7559">/// @param start_leader  start of '!' and '-' prefixes</a>
<a name="ln7560">/// @param end_leaderp  end of '!' and '-' prefixes</a>
<a name="ln7561">int handle_subscript(const char **const arg, typval_T *rettv, evalarg_T *const evalarg,</a>
<a name="ln7562">                     bool verbose)</a>
<a name="ln7563">{</a>
<a name="ln7564">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln7565">  int ret = OK;</a>
<a name="ln7566">  dict_T *selfdict = NULL;</a>
<a name="ln7567">  const char *lua_funcname = NULL;</a>
<a name="ln7568"> </a>
<a name="ln7569">  if (tv_is_luafunc(rettv)) {</a>
<a name="ln7570">    if (**arg != '.') {</a>
<a name="ln7571">      tv_clear(rettv);</a>
<a name="ln7572">      ret = FAIL;</a>
<a name="ln7573">    } else {</a>
<a name="ln7574">      (*arg)++;</a>
<a name="ln7575"> </a>
<a name="ln7576">      lua_funcname = *arg;</a>
<a name="ln7577">      const int len = check_luafunc_name(*arg, true);</a>
<a name="ln7578">      if (len == 0) {</a>
<a name="ln7579">        tv_clear(rettv);</a>
<a name="ln7580">        ret = FAIL;</a>
<a name="ln7581">      }</a>
<a name="ln7582">      (*arg) += len;</a>
<a name="ln7583">    }</a>
<a name="ln7584">  }</a>
<a name="ln7585"> </a>
<a name="ln7586">  // &quot;.&quot; is &quot;.name&quot; lookup when we found a dict.</a>
<a name="ln7587">  while (ret == OK</a>
<a name="ln7588">         &amp;&amp; (((**arg == '[' || (**arg == '.' &amp;&amp; rettv-&gt;v_type == VAR_DICT)</a>
<a name="ln7589">               || (**arg == '(' &amp;&amp; (!evaluate || tv_is_func(*rettv))))</a>
<a name="ln7590">              &amp;&amp; !ascii_iswhite(*(*arg - 1)))</a>
<a name="ln7591">             || (**arg == '-' &amp;&amp; (*arg)[1] == '&gt;'))) {</a>
<a name="ln7592">    if (**arg == '(') {</a>
<a name="ln7593">      ret = call_func_rettv((char **)arg, evalarg, rettv, evaluate, selfdict, NULL, lua_funcname);</a>
<a name="ln7594"> </a>
<a name="ln7595">      // Stop the expression evaluation when immediately aborting on</a>
<a name="ln7596">      // error, or when an interrupt occurred or an exception was thrown</a>
<a name="ln7597">      // but not caught.</a>
<a name="ln7598">      if (aborting()) {</a>
<a name="ln7599">        if (ret == OK) {</a>
<a name="ln7600">          tv_clear(rettv);</a>
<a name="ln7601">        }</a>
<a name="ln7602">        ret = FAIL;</a>
<a name="ln7603">      }</a>
<a name="ln7604">      tv_dict_unref(selfdict);</a>
<a name="ln7605">      selfdict = NULL;</a>
<a name="ln7606">    } else if (**arg == '-') {</a>
<a name="ln7607">      if ((*arg)[2] == '{') {</a>
<a name="ln7608">        // expr-&gt;{lambda}()</a>
<a name="ln7609">        ret = eval_lambda((char **)arg, rettv, evalarg, verbose);</a>
<a name="ln7610">      } else {</a>
<a name="ln7611">        // expr-&gt;name()</a>
<a name="ln7612">        ret = eval_method((char **)arg, rettv, evalarg, verbose);</a>
<a name="ln7613">      }</a>
<a name="ln7614">    } else {  // **arg == '[' || **arg == '.'</a>
<a name="ln7615">      tv_dict_unref(selfdict);</a>
<a name="ln7616">      if (rettv-&gt;v_type == VAR_DICT) {</a>
<a name="ln7617">        selfdict = rettv-&gt;vval.v_dict;</a>
<a name="ln7618">        if (selfdict != NULL) {</a>
<a name="ln7619">          selfdict-&gt;dv_refcount++;</a>
<a name="ln7620">        }</a>
<a name="ln7621">      } else {</a>
<a name="ln7622">        selfdict = NULL;</a>
<a name="ln7623">      }</a>
<a name="ln7624">      if (eval_index((char **)arg, rettv, evalarg, verbose) == FAIL) {</a>
<a name="ln7625">        tv_clear(rettv);</a>
<a name="ln7626">        ret = FAIL;</a>
<a name="ln7627">      }</a>
<a name="ln7628">    }</a>
<a name="ln7629">  }</a>
<a name="ln7630"> </a>
<a name="ln7631">  // Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; bound to &quot;dict&quot;.</a>
<a name="ln7632">  if (selfdict != NULL &amp;&amp; tv_is_func(*rettv)) {</a>
<a name="ln7633">    set_selfdict(rettv, selfdict);</a>
<a name="ln7634">  }</a>
<a name="ln7635"> </a>
<a name="ln7636">  tv_dict_unref(selfdict);</a>
<a name="ln7637">  return ret;</a>
<a name="ln7638">}</a>
<a name="ln7639"> </a>
<a name="ln7640">void set_selfdict(typval_T *const rettv, dict_T *const selfdict)</a>
<a name="ln7641">{</a>
<a name="ln7642">  // Don't do this when &quot;dict.Func&quot; is already a partial that was bound</a>
<a name="ln7643">  // explicitly (pt_auto is false).</a>
<a name="ln7644">  if (rettv-&gt;v_type == VAR_PARTIAL &amp;&amp; !rettv-&gt;vval.v_partial-&gt;pt_auto</a>
<a name="ln7645">      &amp;&amp; rettv-&gt;vval.v_partial-&gt;pt_dict != NULL) {</a>
<a name="ln7646">    return;</a>
<a name="ln7647">  }</a>
<a name="ln7648">  make_partial(selfdict, rettv);</a>
<a name="ln7649">}</a>
<a name="ln7650"> </a>
<a name="ln7651">/// Find variable &quot;name&quot; in the list of variables.</a>
<a name="ln7652">/// Careful: &quot;a:0&quot; variables don't have a name.</a>
<a name="ln7653">/// When &quot;htp&quot; is not NULL we are writing to the variable, set &quot;htp&quot; to the</a>
<a name="ln7654">/// hashtab_T used.</a>
<a name="ln7655">///</a>
<a name="ln7656">/// @return  a pointer to it if found, NULL if not found.</a>
<a name="ln7657">dictitem_T *find_var(const char *const name, const size_t name_len, hashtab_T **htp,</a>
<a name="ln7658">                     int no_autoload)</a>
<a name="ln7659">{</a>
<a name="ln7660">  const char *varname;</a>
<a name="ln7661">  hashtab_T *const ht = find_var_ht(name, name_len, &amp;varname);</a>
<a name="ln7662">  if (htp != NULL) {</a>
<a name="ln7663">    *htp = ht;</a>
<a name="ln7664">  }</a>
<a name="ln7665">  if (ht == NULL) {</a>
<a name="ln7666">    return NULL;</a>
<a name="ln7667">  }</a>
<a name="ln7668">  dictitem_T *const ret = find_var_in_ht(ht, *name,</a>
<a name="ln7669">                                         varname,</a>
<a name="ln7670">                                         name_len - (size_t)(varname - name),</a>
<a name="ln7671">                                         no_autoload || htp != NULL);</a>
<a name="ln7672">  if (ret != NULL) {</a>
<a name="ln7673">    return ret;</a>
<a name="ln7674">  }</a>
<a name="ln7675"> </a>
<a name="ln7676">  // Search in parent scope for lambda</a>
<a name="ln7677">  return find_var_in_scoped_ht(name, name_len, no_autoload || htp != NULL);</a>
<a name="ln7678">}</a>
<a name="ln7679"> </a>
<a name="ln7680">/// Find variable in hashtab.</a>
<a name="ln7681">/// When &quot;varname&quot; is empty returns curwin/curtab/etc vars dictionary.</a>
<a name="ln7682">///</a>
<a name="ln7683">/// @param[in]  ht  Hashtab to find variable in.</a>
<a name="ln7684">/// @param[in]  htname  Hashtab name (first character).</a>
<a name="ln7685">/// @param[in]  varname  Variable name.</a>
<a name="ln7686">/// @param[in]  varname_len  Variable name length.</a>
<a name="ln7687">/// @param[in]  no_autoload  If true then autoload scripts will not be sourced</a>
<a name="ln7688">///                          if autoload variable was not found.</a>
<a name="ln7689">///</a>
<a name="ln7690">/// @return pointer to the dictionary item with the found variable or NULL if it</a>
<a name="ln7691">///         was not found.</a>
<a name="ln7692">dictitem_T *find_var_in_ht(hashtab_T *const ht, int htname, const char *const varname,</a>
<a name="ln7693">                           const size_t varname_len, int no_autoload)</a>
<a name="ln7694">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7695">{</a>
<a name="ln7696">  if (varname_len == 0) {</a>
<a name="ln7697">    // Must be something like &quot;s:&quot;, otherwise &quot;ht&quot; would be NULL.</a>
<a name="ln7698">    switch (htname) {</a>
<a name="ln7699">    case 's':</a>
<a name="ln7700">      return (dictitem_T *)&amp;SCRIPT_SV(current_sctx.sc_sid)-&gt;sv_var;</a>
<a name="ln7701">    case 'g':</a>
<a name="ln7702">      return (dictitem_T *)&amp;globvars_var;</a>
<a name="ln7703">    case 'v':</a>
<a name="ln7704">      return (dictitem_T *)&amp;vimvars_var;</a>
<a name="ln7705">    case 'b':</a>
<a name="ln7706">      return (dictitem_T *)&amp;curbuf-&gt;b_bufvar;</a>
<a name="ln7707">    case 'w':</a>
<a name="ln7708">      return (dictitem_T *)&amp;curwin-&gt;w_winvar;</a>
<a name="ln7709">    case 't':</a>
<a name="ln7710">      return (dictitem_T *)&amp;curtab-&gt;tp_winvar;</a>
<a name="ln7711">    case 'l':</a>
<a name="ln7712">      return get_funccal_local_var();</a>
<a name="ln7713">    case 'a':</a>
<a name="ln7714">      return get_funccal_args_var();</a>
<a name="ln7715">    }</a>
<a name="ln7716">    return NULL;</a>
<a name="ln7717">  }</a>
<a name="ln7718"> </a>
<a name="ln7719">  hashitem_T *hi = hash_find_len(ht, varname, varname_len);</a>
<a name="ln7720">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln7721">    // For global variables we may try auto-loading the script.  If it</a>
<a name="ln7722">    // worked find the variable again.  Don't auto-load a script if it was</a>
<a name="ln7723">    // loaded already, otherwise it would be loaded every time when</a>
<a name="ln7724">    // checking if a function name is a Funcref variable.</a>
<a name="ln7725">    if (ht == &amp;globvarht &amp;&amp; !no_autoload) {</a>
<a name="ln7726">      // Note: script_autoload() may make &quot;hi&quot; invalid. It must either</a>
<a name="ln7727">      // be obtained again or not used.</a>
<a name="ln7728">      if (!script_autoload(varname, varname_len, false) || aborting()) {</a>
<a name="ln7729">        return NULL;</a>
<a name="ln7730">      }</a>
<a name="ln7731">      hi = hash_find_len(ht, varname, varname_len);</a>
<a name="ln7732">    }</a>
<a name="ln7733">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln7734">      return NULL;</a>
<a name="ln7735">    }</a>
<a name="ln7736">  }</a>
<a name="ln7737">  return TV_DICT_HI2DI(hi);</a>
<a name="ln7738">}</a>
<a name="ln7739"> </a>
<a name="ln7740">/// Finds the dict (g:, l:, s:, ) and hashtable used for a variable.</a>
<a name="ln7741">///</a>
<a name="ln7742">/// Assigns SID if s: scope is accessed from Lua or anonymous Vimscript. #15994</a>
<a name="ln7743">///</a>
<a name="ln7744">/// @param[in]  name  Variable name, possibly with scope prefix.</a>
<a name="ln7745">/// @param[in]  name_len  Variable name length.</a>
<a name="ln7746">/// @param[out]  varname  Will be set to the start of the name without scope</a>
<a name="ln7747">///                       prefix.</a>
<a name="ln7748">/// @param[out]  d  Scope dictionary.</a>
<a name="ln7749">///</a>
<a name="ln7750">/// @return Scope hashtab, NULL if name is not valid.</a>
<a name="ln7751">hashtab_T *find_var_ht_dict(const char *name, const size_t name_len, const char **varname,</a>
<a name="ln7752">                            dict_T **d)</a>
<a name="ln7753">{</a>
<a name="ln7754">  funccall_T *funccal = get_funccal();</a>
<a name="ln7755">  *d = NULL;</a>
<a name="ln7756"> </a>
<a name="ln7757">  if (name_len == 0) {</a>
<a name="ln7758">    return NULL;</a>
<a name="ln7759">  }</a>
<a name="ln7760">  if (name_len == 1 || name[1] != ':') {</a>
<a name="ln7761">    // name has implicit scope</a>
<a name="ln7762">    if (name[0] == ':' || name[0] == AUTOLOAD_CHAR) {</a>
<a name="ln7763">      // The name must not start with a colon or #.</a>
<a name="ln7764">      return NULL;</a>
<a name="ln7765">    }</a>
<a name="ln7766">    *varname = name;</a>
<a name="ln7767"> </a>
<a name="ln7768">    // &quot;version&quot; is &quot;v:version&quot; in all scopes</a>
<a name="ln7769">    hashitem_T *hi = hash_find_len(&amp;compat_hashtab, name, name_len);</a>
<a name="ln7770">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln7771">      return &amp;compat_hashtab;</a>
<a name="ln7772">    }</a>
<a name="ln7773"> </a>
<a name="ln7774">    if (funccal == NULL) {  // global variable</a>
<a name="ln7775">      *d = &amp;globvardict;</a>
<a name="ln7776">    } else {  // l: variable</a>
<a name="ln7777">      *d = &amp;funccal-&gt;fc_l_vars;</a>
<a name="ln7778">    }</a>
<a name="ln7779">    goto end;</a>
<a name="ln7780">  }</a>
<a name="ln7781"> </a>
<a name="ln7782">  *varname = name + 2;</a>
<a name="ln7783">  if (*name == 'g') {  // global variable</a>
<a name="ln7784">    *d = &amp;globvardict;</a>
<a name="ln7785">  } else if (name_len &gt; 2</a>
<a name="ln7786">             &amp;&amp; (memchr(name + 2, ':', name_len - 2) != NULL</a>
<a name="ln7787">                 || memchr(name + 2, AUTOLOAD_CHAR, name_len - 2) != NULL)) {</a>
<a name="ln7788">    // There must be no ':' or '#' in the rest of the name if g: was not used</a>
<a name="ln7789">    return NULL;</a>
<a name="ln7790">  }</a>
<a name="ln7791"> </a>
<a name="ln7792">  if (*name == 'b') {  // buffer variable</a>
<a name="ln7793">    *d = curbuf-&gt;b_vars;</a>
<a name="ln7794">  } else if (*name == 'w') {  // window variable</a>
<a name="ln7795">    *d = curwin-&gt;w_vars;</a>
<a name="ln7796">  } else if (*name == 't') {  // tab page variable</a>
<a name="ln7797">    *d = curtab-&gt;tp_vars;</a>
<a name="ln7798">  } else if (*name == 'v') {  // v: variable</a>
<a name="ln7799">    *d = &amp;vimvardict;</a>
<a name="ln7800">  } else if (*name == 'a' &amp;&amp; funccal != NULL) {  // function argument</a>
<a name="ln7801">    *d = &amp;funccal-&gt;fc_l_avars;</a>
<a name="ln7802">  } else if (*name == 'l' &amp;&amp; funccal != NULL) {  // local variable</a>
<a name="ln7803">    *d = &amp;funccal-&gt;fc_l_vars;</a>
<a name="ln7804">  } else if (*name == 's'  // script variable</a>
<a name="ln7805">             &amp;&amp; (current_sctx.sc_sid &gt; 0 || current_sctx.sc_sid == SID_STR</a>
<a name="ln7806">                 || current_sctx.sc_sid == SID_LUA)</a>
<a name="ln7807">             &amp;&amp; current_sctx.sc_sid &lt;= script_items.ga_len) {</a>
<a name="ln7808">    // For anonymous scripts without a script item, create one now so script vars can be used</a>
<a name="ln7809">    if (current_sctx.sc_sid == SID_LUA) {</a>
<a name="ln7810">      // try to resolve lua filename &amp; line no so it can be shown in lastset messages.</a>
<a name="ln7811">      nlua_set_sctx(&amp;current_sctx);</a>
<a name="ln7812">      if (current_sctx.sc_sid != SID_LUA) {</a>
<a name="ln7813">        // Great we have valid location. Now here this out we'll create a new</a>
<a name="ln7814">        // script context with the name and lineno of this one. why ?</a>
<a name="ln7815">        // for behavioral consistency. With this different anonymous exec from</a>
<a name="ln7816">        // same file can't access each others script local stuff. We need to do</a>
<a name="ln7817">        // this all other cases except this will act like that otherwise.</a>
<a name="ln7818">        const LastSet last_set = (LastSet){</a>
<a name="ln7819">          .script_ctx = current_sctx,</a>
<a name="ln7820">          .channel_id = LUA_INTERNAL_CALL,</a>
<a name="ln7821">        };</a>
<a name="ln7822">        bool should_free;</a>
<a name="ln7823">        // should_free is ignored as script_sctx will be resolved to a fnmae</a>
<a name="ln7824">        // &amp; new_script_item will consume it.</a>
<a name="ln7825">        char *sc_name = get_scriptname(last_set, &amp;should_free);</a>
<a name="ln7826">        new_script_item(sc_name, &amp;current_sctx.sc_sid);</a>
<a name="ln7827">      }</a>
<a name="ln7828">    }</a>
<a name="ln7829">    if (current_sctx.sc_sid == SID_STR || current_sctx.sc_sid == SID_LUA) {</a>
<a name="ln7830">      // Create SID if s: scope is accessed from Lua or anon Vimscript. #15994</a>
<a name="ln7831">      new_script_item(NULL, &amp;current_sctx.sc_sid);</a>
<a name="ln7832">    }</a>
<a name="ln7833">    *d = &amp;SCRIPT_SV(current_sctx.sc_sid)-&gt;sv_dict;</a>
<a name="ln7834">  }</a>
<a name="ln7835"> </a>
<a name="ln7836">end:</a>
<a name="ln7837">  return *d ? &amp;(*d)-&gt;dv_hashtab : NULL;</a>
<a name="ln7838">}</a>
<a name="ln7839"> </a>
<a name="ln7840">/// Find the hashtable used for a variable</a>
<a name="ln7841">///</a>
<a name="ln7842">/// @param[in]  name  Variable name, possibly with scope prefix.</a>
<a name="ln7843">/// @param[in]  name_len  Variable name length.</a>
<a name="ln7844">/// @param[out]  varname  Will be set to the start of the name without scope</a>
<a name="ln7845">///                       prefix.</a>
<a name="ln7846">///</a>
<a name="ln7847">/// @return Scope hashtab, NULL if name is not valid.</a>
<a name="ln7848">hashtab_T *find_var_ht(const char *name, const size_t name_len, const char **varname)</a>
<a name="ln7849">{</a>
<a name="ln7850">  dict_T *d;</a>
<a name="ln7851">  return find_var_ht_dict(name, name_len, varname, &amp;d);</a>
<a name="ln7852">}</a>
<a name="ln7853"> </a>
<a name="ln7854">/// Allocate a new hashtab for a sourced script.  It will be used while</a>
<a name="ln7855">/// sourcing this script and when executing functions defined in the script.</a>
<a name="ln7856">void new_script_vars(scid_T id)</a>
<a name="ln7857">{</a>
<a name="ln7858">  scriptvar_T *sv = xcalloc(1, sizeof(scriptvar_T));</a>
<a name="ln7859">  init_var_dict(&amp;sv-&gt;sv_dict, &amp;sv-&gt;sv_var, VAR_SCOPE);</a>
<a name="ln7860">  SCRIPT_ITEM(id)-&gt;sn_vars = sv;</a>
<a name="ln7861">}</a>
<a name="ln7862"> </a>
<a name="ln7863">/// Initialize dictionary &quot;dict&quot; as a scope and set variable &quot;dict_var&quot; to</a>
<a name="ln7864">/// point to it.</a>
<a name="ln7865">void init_var_dict(dict_T *dict, ScopeDictDictItem *dict_var, ScopeType scope)</a>
<a name="ln7866">{</a>
<a name="ln7867">  hash_init(&amp;dict-&gt;dv_hashtab);</a>
<a name="ln7868">  dict-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln7869">  dict-&gt;dv_scope = scope;</a>
<a name="ln7870">  dict-&gt;dv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln7871">  dict-&gt;dv_copyID = 0;</a>
<a name="ln7872">  dict_var-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln7873">  dict_var-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln7874">  dict_var-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln7875">  dict_var-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln7876">  dict_var-&gt;di_key[0] = NUL;</a>
<a name="ln7877">  QUEUE_INIT(&amp;dict-&gt;watchers);</a>
<a name="ln7878">}</a>
<a name="ln7879"> </a>
<a name="ln7880">/// Unreference a dictionary initialized by init_var_dict().</a>
<a name="ln7881">void unref_var_dict(dict_T *dict)</a>
<a name="ln7882">{</a>
<a name="ln7883">  // Now the dict needs to be freed if no one else is using it, go back to</a>
<a name="ln7884">  // normal reference counting.</a>
<a name="ln7885">  dict-&gt;dv_refcount -= DO_NOT_FREE_CNT - 1;</a>
<a name="ln7886">  tv_dict_unref(dict);</a>
<a name="ln7887">}</a>
<a name="ln7888"> </a>
<a name="ln7889">/// Make a copy of an item</a>
<a name="ln7890">///</a>
<a name="ln7891">/// Lists and Dictionaries are also copied.</a>
<a name="ln7892">///</a>
<a name="ln7893">/// @param[in]  conv  If not NULL, convert all copied strings.</a>
<a name="ln7894">/// @param[in]  from  Value to copy.</a>
<a name="ln7895">/// @param[out]  to  Location where to copy to.</a>
<a name="ln7896">/// @param[in]  deep  If true, use copy the container and all of the contained</a>
<a name="ln7897">///                   containers (nested).</a>
<a name="ln7898">/// @param[in]  copyID  If non-zero then when container is referenced more then</a>
<a name="ln7899">///                     once then copy of it that was already done is used. E.g.</a>
<a name="ln7900">///                     when copying list `list = [list2, list2]` (`list[0] is</a>
<a name="ln7901">///                     list[1]`) var_item_copy with zero copyID will emit</a>
<a name="ln7902">///                     a copy with (`copy[0] isnot copy[1]`), with non-zero it</a>
<a name="ln7903">///                     will emit a copy with (`copy[0] is copy[1]`) like in the</a>
<a name="ln7904">///                     original list. Not used when deep is false.</a>
<a name="ln7905">int var_item_copy(const vimconv_T *const conv, typval_T *const from, typval_T *const to,</a>
<a name="ln7906">                  const bool deep, const int copyID)</a>
<a name="ln7907">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln7908">{</a>
<a name="ln7909">  static int recurse = 0;</a>
<a name="ln7910">  int ret = OK;</a>
<a name="ln7911"> </a>
<a name="ln7912">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln7913">    emsg(_(e_variable_nested_too_deep_for_making_copy));</a>
<a name="ln7914">    return FAIL;</a>
<a name="ln7915">  }</a>
<a name="ln7916">  recurse++;</a>
<a name="ln7917"> </a>
<a name="ln7918">  switch (from-&gt;v_type) {</a>
<a name="ln7919">  case VAR_NUMBER:</a>
<a name="ln7920">  case VAR_FLOAT:</a>
<a name="ln7921">  case VAR_FUNC:</a>
<a name="ln7922">  case VAR_PARTIAL:</a>
<a name="ln7923">  case VAR_BOOL:</a>
<a name="ln7924">  case VAR_SPECIAL:</a>
<a name="ln7925">    tv_copy(from, to);</a>
<a name="ln7926">    break;</a>
<a name="ln7927">  case VAR_STRING:</a>
<a name="ln7928">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE</a>
<a name="ln7929">        || from-&gt;vval.v_string == NULL) {</a>
<a name="ln7930">      tv_copy(from, to);</a>
<a name="ln7931">    } else {</a>
<a name="ln7932">      to-&gt;v_type = VAR_STRING;</a>
<a name="ln7933">      to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln7934">      if ((to-&gt;vval.v_string = string_convert((vimconv_T *)conv,</a>
<a name="ln7935">                                              from-&gt;vval.v_string,</a>
<a name="ln7936">                                              NULL))</a>
<a name="ln7937">          == NULL) {</a>
<a name="ln7938">        to-&gt;vval.v_string = xstrdup(from-&gt;vval.v_string);</a>
<a name="ln7939">      }</a>
<a name="ln7940">    }</a>
<a name="ln7941">    break;</a>
<a name="ln7942">  case VAR_LIST:</a>
<a name="ln7943">    to-&gt;v_type = VAR_LIST;</a>
<a name="ln7944">    to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln7945">    if (from-&gt;vval.v_list == NULL) {</a>
<a name="ln7946">      to-&gt;vval.v_list = NULL;</a>
<a name="ln7947">    } else if (copyID != 0 &amp;&amp; tv_list_copyid(from-&gt;vval.v_list) == copyID) {</a>
<a name="ln7948">      // Use the copy made earlier.</a>
<a name="ln7949">      to-&gt;vval.v_list = tv_list_latest_copy(from-&gt;vval.v_list);</a>
<a name="ln7950">      tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln7951">    } else {</a>
<a name="ln7952">      to-&gt;vval.v_list = tv_list_copy(conv, from-&gt;vval.v_list, deep, copyID);</a>
<a name="ln7953">    }</a>
<a name="ln7954">    if (to-&gt;vval.v_list == NULL &amp;&amp; from-&gt;vval.v_list != NULL) {</a>
<a name="ln7955">      ret = FAIL;</a>
<a name="ln7956">    }</a>
<a name="ln7957">    break;</a>
<a name="ln7958">  case VAR_BLOB:</a>
<a name="ln7959">    tv_blob_copy(from-&gt;vval.v_blob, to);</a>
<a name="ln7960">    break;</a>
<a name="ln7961">  case VAR_DICT:</a>
<a name="ln7962">    to-&gt;v_type = VAR_DICT;</a>
<a name="ln7963">    to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln7964">    if (from-&gt;vval.v_dict == NULL) {</a>
<a name="ln7965">      to-&gt;vval.v_dict = NULL;</a>
<a name="ln7966">    } else if (copyID != 0 &amp;&amp; from-&gt;vval.v_dict-&gt;dv_copyID == copyID) {</a>
<a name="ln7967">      // use the copy made earlier</a>
<a name="ln7968">      to-&gt;vval.v_dict = from-&gt;vval.v_dict-&gt;dv_copydict;</a>
<a name="ln7969">      to-&gt;vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln7970">    } else {</a>
<a name="ln7971">      to-&gt;vval.v_dict = tv_dict_copy(conv, from-&gt;vval.v_dict, deep, copyID);</a>
<a name="ln7972">    }</a>
<a name="ln7973">    if (to-&gt;vval.v_dict == NULL &amp;&amp; from-&gt;vval.v_dict != NULL) {</a>
<a name="ln7974">      ret = FAIL;</a>
<a name="ln7975">    }</a>
<a name="ln7976">    break;</a>
<a name="ln7977">  case VAR_UNKNOWN:</a>
<a name="ln7978">    internal_error(&quot;var_item_copy(UNKNOWN)&quot;);</a>
<a name="ln7979">    ret = FAIL;</a>
<a name="ln7980">  }</a>
<a name="ln7981">  recurse--;</a>
<a name="ln7982">  return ret;</a>
<a name="ln7983">}</a>
<a name="ln7984"> </a>
<a name="ln7985">/// &quot;:echo expr1 ...&quot;    print each argument separated with a space, add a</a>
<a name="ln7986">///                      newline at the end.</a>
<a name="ln7987">/// &quot;:echon expr1 ...&quot;   print each argument plain.</a>
<a name="ln7988">void ex_echo(exarg_T *eap)</a>
<a name="ln7989">{</a>
<a name="ln7990">  char *arg = eap-&gt;arg;</a>
<a name="ln7991">  typval_T rettv;</a>
<a name="ln7992">  bool atstart = true;</a>
<a name="ln7993">  bool need_clear = true;</a>
<a name="ln7994">  const int did_emsg_before = did_emsg;</a>
<a name="ln7995">  const int called_emsg_before = called_emsg;</a>
<a name="ln7996">  evalarg_T evalarg;</a>
<a name="ln7997"> </a>
<a name="ln7998">  fill_evalarg_from_eap(&amp;evalarg, eap, eap-&gt;skip);</a>
<a name="ln7999"> </a>
<a name="ln8000">  if (eap-&gt;skip) {</a>
<a name="ln8001">    emsg_skip++;</a>
<a name="ln8002">  }</a>
<a name="ln8003">  while (*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n' &amp;&amp; !got_int) {</a>
<a name="ln8004">    // If eval1() causes an error message the text from the command may</a>
<a name="ln8005">    // still need to be cleared. E.g., &quot;echo 22,44&quot;.</a>
<a name="ln8006">    need_clr_eos = true;</a>
<a name="ln8007"> </a>
<a name="ln8008">    {</a>
<a name="ln8009">      char *p = arg;</a>
<a name="ln8010">      if (eval1(&amp;arg, &amp;rettv, &amp;evalarg) == FAIL) {</a>
<a name="ln8011">        // Report the invalid expression unless the expression evaluation</a>
<a name="ln8012">        // has been cancelled due to an aborting error, an interrupt, or an</a>
<a name="ln8013">        // exception.</a>
<a name="ln8014">        if (!aborting() &amp;&amp; did_emsg == did_emsg_before</a>
<a name="ln8015">            &amp;&amp; called_emsg == called_emsg_before) {</a>
<a name="ln8016">          semsg(_(e_invexpr2), p);</a>
<a name="ln8017">        }</a>
<a name="ln8018">        need_clr_eos = false;</a>
<a name="ln8019">        break;</a>
<a name="ln8020">      }</a>
<a name="ln8021">      need_clr_eos = false;</a>
<a name="ln8022">    }</a>
<a name="ln8023"> </a>
<a name="ln8024">    if (!eap-&gt;skip) {</a>
<a name="ln8025">      if (atstart) {</a>
<a name="ln8026">        atstart = false;</a>
<a name="ln8027">        // Call msg_start() after eval1(), evaluating the expression</a>
<a name="ln8028">        // may cause a message to appear.</a>
<a name="ln8029">        if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln8030">          // Mark the saved text as finishing the line, so that what</a>
<a name="ln8031">          // follows is displayed on a new line when scrolling back</a>
<a name="ln8032">          // at the more prompt.</a>
<a name="ln8033">          msg_sb_eol();</a>
<a name="ln8034">          msg_start();</a>
<a name="ln8035">        }</a>
<a name="ln8036">      } else if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln8037">        msg_puts_attr(&quot; &quot;, echo_attr);</a>
<a name="ln8038">      }</a>
<a name="ln8039">      char *tofree = encode_tv2echo(&amp;rettv, NULL);</a>
<a name="ln8040">      if (*tofree != NUL) {</a>
<a name="ln8041">        msg_ext_set_kind(&quot;echo&quot;);</a>
<a name="ln8042">        msg_multiline(tofree, echo_attr, true, &amp;need_clear);</a>
<a name="ln8043">      }</a>
<a name="ln8044">      xfree(tofree);</a>
<a name="ln8045">    }</a>
<a name="ln8046">    tv_clear(&amp;rettv);</a>
<a name="ln8047">    arg = skipwhite(arg);</a>
<a name="ln8048">  }</a>
<a name="ln8049">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln8050">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln8051"> </a>
<a name="ln8052">  if (eap-&gt;skip) {</a>
<a name="ln8053">    emsg_skip--;</a>
<a name="ln8054">  } else {</a>
<a name="ln8055">    // remove text that may still be there from the command</a>
<a name="ln8056">    if (need_clear) {</a>
<a name="ln8057">      msg_clr_eos();</a>
<a name="ln8058">    }</a>
<a name="ln8059">    if (eap-&gt;cmdidx == CMD_echo) {</a>
<a name="ln8060">      msg_end();</a>
<a name="ln8061">    }</a>
<a name="ln8062">  }</a>
<a name="ln8063">}</a>
<a name="ln8064"> </a>
<a name="ln8065">/// &quot;:echohl {name}&quot;.</a>
<a name="ln8066">void ex_echohl(exarg_T *eap)</a>
<a name="ln8067">{</a>
<a name="ln8068">  echo_attr = syn_name2attr(eap-&gt;arg);</a>
<a name="ln8069">}</a>
<a name="ln8070"> </a>
<a name="ln8071">/// &quot;:execute expr1 ...&quot; execute the result of an expression.</a>
<a name="ln8072">/// &quot;:echomsg expr1 ...&quot; Print a message</a>
<a name="ln8073">/// &quot;:echoerr expr1 ...&quot; Print an error</a>
<a name="ln8074">/// Each gets spaces around each argument and a newline at the end for</a>
<a name="ln8075">/// echo commands</a>
<a name="ln8076">void ex_execute(exarg_T *eap)</a>
<a name="ln8077">{</a>
<a name="ln8078">  char *arg = eap-&gt;arg;</a>
<a name="ln8079">  typval_T rettv;</a>
<a name="ln8080">  int ret = OK;</a>
<a name="ln8081">  garray_T ga;</a>
<a name="ln8082"> </a>
<a name="ln8083">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln8084"> </a>
<a name="ln8085">  if (eap-&gt;skip) {</a>
<a name="ln8086">    emsg_skip++;</a>
<a name="ln8087">  }</a>
<a name="ln8088">  while (*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n') {</a>
<a name="ln8089">    ret = eval1_emsg(&amp;arg, &amp;rettv, eap);</a>
<a name="ln8090">    if (ret == FAIL) {</a>
<a name="ln8091">      break;</a>
<a name="ln8092">    }</a>
<a name="ln8093"> </a>
<a name="ln8094">    if (!eap-&gt;skip) {</a>
<a name="ln8095">      const char *const argstr = eap-&gt;cmdidx == CMD_execute</a>
<a name="ln8096">        ? tv_get_string(&amp;rettv)</a>
<a name="ln8097">        : rettv.v_type == VAR_STRING</a>
<a name="ln8098">        ? encode_tv2echo(&amp;rettv, NULL)</a>
<a name="ln8099">        : encode_tv2string(&amp;rettv, NULL);</a>
<a name="ln8100">      const size_t len = strlen(argstr);</a>
<a name="ln8101">      ga_grow(&amp;ga, (int)len + 2);</a>
<a name="ln8102">      if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln8103">        ((char *)(ga.ga_data))[ga.ga_len++] = ' ';</a>
<a name="ln8104">      }</a>
<a name="ln8105">      memcpy((char *)(ga.ga_data) + ga.ga_len, argstr, len + 1);</a>
<a name="ln8106">      if (eap-&gt;cmdidx != CMD_execute) {</a>
<a name="ln8107">        xfree((void *)argstr);</a>
<a name="ln8108">      }</a>
<a name="ln8109">      ga.ga_len += (int)len;</a>
<a name="ln8110">    }</a>
<a name="ln8111"> </a>
<a name="ln8112">    tv_clear(&amp;rettv);</a>
<a name="ln8113">    arg = skipwhite(arg);</a>
<a name="ln8114">  }</a>
<a name="ln8115"> </a>
<a name="ln8116">  if (ret != FAIL &amp;&amp; ga.ga_data != NULL) {</a>
<a name="ln8117">    if (eap-&gt;cmdidx == CMD_echomsg) {</a>
<a name="ln8118">      msg_ext_set_kind(&quot;echomsg&quot;);</a>
<a name="ln8119">      msg(ga.ga_data, echo_attr);</a>
<a name="ln8120">    } else if (eap-&gt;cmdidx == CMD_echoerr) {</a>
<a name="ln8121">      // We don't want to abort following commands, restore did_emsg.</a>
<a name="ln8122">      int save_did_emsg = did_emsg;</a>
<a name="ln8123">      msg_ext_set_kind(&quot;echoerr&quot;);</a>
<a name="ln8124">      emsg_multiline(ga.ga_data, true);</a>
<a name="ln8125">      if (!force_abort) {</a>
<a name="ln8126">        did_emsg = save_did_emsg;</a>
<a name="ln8127">      }</a>
<a name="ln8128">    } else if (eap-&gt;cmdidx == CMD_execute) {</a>
<a name="ln8129">      do_cmdline(ga.ga_data, eap-&gt;getline, eap-&gt;cookie, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln8130">    }</a>
<a name="ln8131">  }</a>
<a name="ln8132"> </a>
<a name="ln8133">  ga_clear(&amp;ga);</a>
<a name="ln8134"> </a>
<a name="ln8135">  if (eap-&gt;skip) {</a>
<a name="ln8136">    emsg_skip--;</a>
<a name="ln8137">  }</a>
<a name="ln8138"> </a>
<a name="ln8139">  eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln8140">}</a>
<a name="ln8141"> </a>
<a name="ln8142">/// Skip over the name of an option: &quot;&amp;option&quot;, &quot;&amp;g:option&quot; or &quot;&amp;l:option&quot;.</a>
<a name="ln8143">///</a>
<a name="ln8144">/// @param arg  points to the &quot;&amp;&quot; or '+' when called, to &quot;option&quot; when returning.</a>
<a name="ln8145">///</a>
<a name="ln8146">/// @return  NULL when no option name found.  Otherwise pointer to the char</a>
<a name="ln8147">///          after the option name.</a>
<a name="ln8148">const char *find_option_end(const char **const arg, int *const scope)</a>
<a name="ln8149">{</a>
<a name="ln8150">  const char *p = *arg;</a>
<a name="ln8151"> </a>
<a name="ln8152">  p++;</a>
<a name="ln8153">  if (*p == 'g' &amp;&amp; p[1] == ':') {</a>
<a name="ln8154">    *scope = OPT_GLOBAL;</a>
<a name="ln8155">    p += 2;</a>
<a name="ln8156">  } else if (*p == 'l' &amp;&amp; p[1] == ':') {</a>
<a name="ln8157">    *scope = OPT_LOCAL;</a>
<a name="ln8158">    p += 2;</a>
<a name="ln8159">  } else {</a>
<a name="ln8160">    *scope = 0;</a>
<a name="ln8161">  }</a>
<a name="ln8162"> </a>
<a name="ln8163">  if (!ASCII_ISALPHA(*p)) {</a>
<a name="ln8164">    return NULL;</a>
<a name="ln8165">  }</a>
<a name="ln8166">  *arg = p;</a>
<a name="ln8167"> </a>
<a name="ln8168">  if (p[0] == 't' &amp;&amp; p[1] == '_' &amp;&amp; p[2] != NUL &amp;&amp; p[3] != NUL) {</a>
<a name="ln8169">    p += 4;  // t_xx/termcap option</a>
<a name="ln8170">  } else {</a>
<a name="ln8171">    while (ASCII_ISALPHA(*p)) {</a>
<a name="ln8172">      p++;</a>
<a name="ln8173">    }</a>
<a name="ln8174">  }</a>
<a name="ln8175">  return p;</a>
<a name="ln8176">}</a>
<a name="ln8177"> </a>
<a name="ln8178">static var_flavour_T var_flavour(char *varname)</a>
<a name="ln8179">  FUNC_ATTR_PURE</a>
<a name="ln8180">{</a>
<a name="ln8181">  char *p = varname;</a>
<a name="ln8182"> </a>
<a name="ln8183">  if (ASCII_ISUPPER(*p)) {</a>
<a name="ln8184">    while (*(++p)) {</a>
<a name="ln8185">      if (ASCII_ISLOWER(*p)) {</a>
<a name="ln8186">        return VAR_FLAVOUR_SESSION;</a>
<a name="ln8187">      }</a>
<a name="ln8188">    }</a>
<a name="ln8189">    return VAR_FLAVOUR_SHADA;</a>
<a name="ln8190">  }</a>
<a name="ln8191">  return VAR_FLAVOUR_DEFAULT;</a>
<a name="ln8192">}</a>
<a name="ln8193"> </a>
<a name="ln8194">/// Iterate over global variables</a>
<a name="ln8195">///</a>
<a name="ln8196">/// @warning No modifications to global variable dictionary must be performed</a>
<a name="ln8197">///          while iteration is in progress.</a>
<a name="ln8198">///</a>
<a name="ln8199">/// @param[in]   iter   Iterator. Pass NULL to start iteration.</a>
<a name="ln8200">/// @param[out]  name   Variable name.</a>
<a name="ln8201">/// @param[out]  rettv  Variable value.</a>
<a name="ln8202">///</a>
<a name="ln8203">/// @return Pointer that needs to be passed to next `var_shada_iter` invocation</a>
<a name="ln8204">///         or NULL to indicate that iteration is over.</a>
<a name="ln8205">const void *var_shada_iter(const void *const iter, const char **const name, typval_T *rettv,</a>
<a name="ln8206">                           var_flavour_T flavour)</a>
<a name="ln8207">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln8208">{</a>
<a name="ln8209">  const hashitem_T *hi;</a>
<a name="ln8210">  const hashitem_T *hifirst = globvarht.ht_array;</a>
<a name="ln8211">  const size_t hinum = (size_t)globvarht.ht_mask + 1;</a>
<a name="ln8212">  *name = NULL;</a>
<a name="ln8213">  if (iter == NULL) {</a>
<a name="ln8214">    hi = globvarht.ht_array;</a>
<a name="ln8215">    while ((size_t)(hi - hifirst) &lt; hinum</a>
<a name="ln8216">           &amp;&amp; (HASHITEM_EMPTY(hi)</a>
<a name="ln8217">               || !(var_flavour(hi-&gt;hi_key) &amp; flavour))) {</a>
<a name="ln8218">      hi++;</a>
<a name="ln8219">    }</a>
<a name="ln8220">    if ((size_t)(hi - hifirst) == hinum) {</a>
<a name="ln8221">      return NULL;</a>
<a name="ln8222">    }</a>
<a name="ln8223">  } else {</a>
<a name="ln8224">    hi = (const hashitem_T *)iter;</a>
<a name="ln8225">  }</a>
<a name="ln8226">  *name = TV_DICT_HI2DI(hi)-&gt;di_key;</a>
<a name="ln8227">  tv_copy(&amp;TV_DICT_HI2DI(hi)-&gt;di_tv, rettv);</a>
<a name="ln8228">  while ((size_t)(++hi - hifirst) &lt; hinum) {</a>
<a name="ln8229">    if (!HASHITEM_EMPTY(hi) &amp;&amp; (var_flavour(hi-&gt;hi_key) &amp; flavour)) {</a>
<a name="ln8230">      return hi;</a>
<a name="ln8231">    }</a>
<a name="ln8232">  }</a>
<a name="ln8233">  return NULL;</a>
<a name="ln8234">}</a>
<a name="ln8235"> </a>
<a name="ln8236">void var_set_global(const char *const name, typval_T vartv)</a>
<a name="ln8237">{</a>
<a name="ln8238">  funccal_entry_T funccall_entry;</a>
<a name="ln8239"> </a>
<a name="ln8240">  save_funccal(&amp;funccall_entry);</a>
<a name="ln8241">  set_var(name, strlen(name), &amp;vartv, false);</a>
<a name="ln8242">  restore_funccal();</a>
<a name="ln8243">}</a>
<a name="ln8244"> </a>
<a name="ln8245">int store_session_globals(FILE *fd)</a>
<a name="ln8246">{</a>
<a name="ln8247">  TV_DICT_ITER(&amp;globvardict, this_var, {</a>
<a name="ln8248">    if ((this_var-&gt;di_tv.v_type == VAR_NUMBER</a>
<a name="ln8249">         || this_var-&gt;di_tv.v_type == VAR_STRING)</a>
<a name="ln8250">        &amp;&amp; var_flavour(this_var-&gt;di_key) == VAR_FLAVOUR_SESSION) {</a>
<a name="ln8251">      // Escape special characters with a backslash.  Turn a LF and</a>
<a name="ln8252">      // CR into \n and \r.</a>
<a name="ln8253">      char *const p = vim_strsave_escaped(tv_get_string(&amp;this_var-&gt;di_tv), &quot;\\\&quot;\n\r&quot;);</a>
<a name="ln8254">      for (char *t = p; *t != NUL; t++) {</a>
<a name="ln8255">        if (*t == '\n') {</a>
<a name="ln8256">          *t = 'n';</a>
<a name="ln8257">        } else if (*t == '\r') {</a>
<a name="ln8258">          *t = 'r';</a>
<a name="ln8259">        }</a>
<a name="ln8260">      }</a>
<a name="ln8261">      if ((fprintf(fd, &quot;let %s = %c%s%c&quot;,</a>
<a name="ln8262">                   this_var-&gt;di_key,</a>
<a name="ln8263">                   ((this_var-&gt;di_tv.v_type == VAR_STRING) ? '&quot;' : ' '),</a>
<a name="ln8264">                   p,</a>
<a name="ln8265">                   ((this_var-&gt;di_tv.v_type == VAR_STRING) ? '&quot;' : ' ')) &lt; 0)</a>
<a name="ln8266">          || put_eol(fd) == FAIL) {</a>
<a name="ln8267">        xfree(p);</a>
<a name="ln8268">        return FAIL;</a>
<a name="ln8269">      }</a>
<a name="ln8270">      xfree(p);</a>
<a name="ln8271">    } else if (this_var-&gt;di_tv.v_type == VAR_FLOAT</a>
<a name="ln8272">               &amp;&amp; var_flavour(this_var-&gt;di_key) == VAR_FLAVOUR_SESSION) {</a>
<a name="ln8273">      float_T f = this_var-&gt;di_tv.vval.v_float;</a>
<a name="ln8274">      int sign = ' ';</a>
<a name="ln8275"> </a>
<a name="ln8276">      if (f &lt; 0) {</a>
<a name="ln8277">        f = -f;</a>
<a name="ln8278">        sign = '-';</a>
<a name="ln8279">      }</a>
<a name="ln8280">      if ((fprintf(fd, &quot;let %s = %c%f&quot;, this_var-&gt;di_key, sign, f) &lt; 0)</a>
<a name="ln8281">          || put_eol(fd) == FAIL) {</a>
<a name="ln8282">        return FAIL;</a>
<a name="ln8283">      }</a>
<a name="ln8284">    }</a>
<a name="ln8285">  });</a>
<a name="ln8286">  return OK;</a>
<a name="ln8287">}</a>
<a name="ln8288"> </a>
<a name="ln8289">/// Display script name where an item was last set.</a>
<a name="ln8290">/// Should only be invoked when 'verbose' is non-zero.</a>
<a name="ln8291">void last_set_msg(sctx_T script_ctx)</a>
<a name="ln8292">{</a>
<a name="ln8293">  const LastSet last_set = (LastSet){</a>
<a name="ln8294">    .script_ctx = script_ctx,</a>
<a name="ln8295">    .channel_id = 0,</a>
<a name="ln8296">  };</a>
<a name="ln8297">  option_last_set_msg(last_set);</a>
<a name="ln8298">}</a>
<a name="ln8299"> </a>
<a name="ln8300">/// Displays where an option was last set.</a>
<a name="ln8301">///</a>
<a name="ln8302">/// Should only be invoked when 'verbose' is non-zero.</a>
<a name="ln8303">void option_last_set_msg(LastSet last_set)</a>
<a name="ln8304">{</a>
<a name="ln8305">  if (last_set.script_ctx.sc_sid != 0) {</a>
<a name="ln8306">    bool should_free;</a>
<a name="ln8307">    char *p = get_scriptname(last_set, &amp;should_free);</a>
<a name="ln8308">    verbose_enter();</a>
<a name="ln8309">    msg_puts(_(&quot;\n\tLast set from &quot;));</a>
<a name="ln8310">    msg_puts(p);</a>
<a name="ln8311">    if (last_set.script_ctx.sc_lnum &gt; 0) {</a>
<a name="ln8312">      msg_puts(_(line_msg));</a>
<a name="ln8313">      msg_outnum(last_set.script_ctx.sc_lnum);</a>
<a name="ln8314">    }</a>
<a name="ln8315">    if (should_free) {</a>
<a name="ln8316">      xfree(p);</a>
<a name="ln8317">    }</a>
<a name="ln8318">    verbose_leave();</a>
<a name="ln8319">  }</a>
<a name="ln8320">}</a>
<a name="ln8321"> </a>
<a name="ln8322">// reset v:option_new, v:option_old, v:option_oldlocal, v:option_oldglobal,</a>
<a name="ln8323">// v:option_type, and v:option_command.</a>
<a name="ln8324">void reset_v_option_vars(void)</a>
<a name="ln8325">{</a>
<a name="ln8326">  set_vim_var_string(VV_OPTION_NEW, NULL, -1);</a>
<a name="ln8327">  set_vim_var_string(VV_OPTION_OLD, NULL, -1);</a>
<a name="ln8328">  set_vim_var_string(VV_OPTION_OLDLOCAL, NULL, -1);</a>
<a name="ln8329">  set_vim_var_string(VV_OPTION_OLDGLOBAL, NULL, -1);</a>
<a name="ln8330">  set_vim_var_string(VV_OPTION_COMMAND, NULL, -1);</a>
<a name="ln8331">  set_vim_var_string(VV_OPTION_TYPE, NULL, -1);</a>
<a name="ln8332">}</a>
<a name="ln8333"> </a>
<a name="ln8334">/// Adjust a filename, according to a string of modifiers.</a>
<a name="ln8335">/// *fnamep must be NUL terminated when called.  When returning, the length is</a>
<a name="ln8336">/// determined by *fnamelen.</a>
<a name="ln8337">/// Returns VALID_ flags or -1 for failure.</a>
<a name="ln8338">/// When there is an error, *fnamep is set to NULL.</a>
<a name="ln8339">///</a>
<a name="ln8340">/// @param src  string with modifiers</a>
<a name="ln8341">/// @param tilde_file  &quot;~&quot; is a file name, not $HOME</a>
<a name="ln8342">/// @param usedlen  characters after src that are used</a>
<a name="ln8343">/// @param fnamep  file name so far</a>
<a name="ln8344">/// @param bufp  buffer for allocated file name or NULL</a>
<a name="ln8345">/// @param fnamelen  length of fnamep</a>
<a name="ln8346">int modify_fname(char *src, bool tilde_file, size_t *usedlen, char **fnamep, char **bufp,</a>
<a name="ln8347">                 size_t *fnamelen)</a>
<a name="ln8348">{</a>
<a name="ln8349">  int valid = 0;</a>
<a name="ln8350">  char *s, *p, *pbuf;</a>
<a name="ln8351">  char dirname[MAXPATHL];</a>
<a name="ln8352">  bool has_fullname = false;</a>
<a name="ln8353">  bool has_homerelative = false;</a>
<a name="ln8354"> </a>
<a name="ln8355">repeat:</a>
<a name="ln8356">  // &quot;:p&quot; - full path/file_name</a>
<a name="ln8357">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'p') {</a>
<a name="ln8358">    has_fullname = true;</a>
<a name="ln8359"> </a>
<a name="ln8360">    valid |= VALID_PATH;</a>
<a name="ln8361">    *usedlen += 2;</a>
<a name="ln8362"> </a>
<a name="ln8363">    // Expand &quot;~/path&quot; for all systems and &quot;~user/path&quot; for Unix</a>
<a name="ln8364">    if ((*fnamep)[0] == '~'</a>
<a name="ln8365">#if !defined(UNIX)</a>
<a name="ln8366">        &amp;&amp; ((*fnamep)[1] == '/'</a>
<a name="ln8367"># ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln8368">            || (*fnamep)[1] == '\\'</a>
<a name="ln8369"># endif</a>
<a name="ln8370">            || (*fnamep)[1] == NUL)</a>
<a name="ln8371">#endif</a>
<a name="ln8372">        &amp;&amp; !(tilde_file &amp;&amp; (*fnamep)[1] == NUL)) {</a>
<a name="ln8373">      *fnamep = expand_env_save(*fnamep);</a>
<a name="ln8374">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln8375">      *bufp = *fnamep;</a>
<a name="ln8376">      if (*fnamep == NULL) {</a>
<a name="ln8377">        return -1;</a>
<a name="ln8378">      }</a>
<a name="ln8379">    }</a>
<a name="ln8380"> </a>
<a name="ln8381">    // When &quot;/.&quot; or &quot;/..&quot; is used: force expansion to get rid of it.</a>
<a name="ln8382">    for (p = *fnamep; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln8383">      if (vim_ispathsep(*p)</a>
<a name="ln8384">          &amp;&amp; p[1] == '.'</a>
<a name="ln8385">          &amp;&amp; (p[2] == NUL</a>
<a name="ln8386">              || vim_ispathsep(p[2])</a>
<a name="ln8387">              || (p[2] == '.'</a>
<a name="ln8388">                  &amp;&amp; (p[3] == NUL || vim_ispathsep(p[3]))))) {</a>
<a name="ln8389">        break;</a>
<a name="ln8390">      }</a>
<a name="ln8391">    }</a>
<a name="ln8392"> </a>
<a name="ln8393">    // FullName_save() is slow, don't use it when not needed.</a>
<a name="ln8394">    if (*p != NUL || !vim_isAbsName(*fnamep)) {</a>
<a name="ln8395">      *fnamep = FullName_save(*fnamep, *p != NUL);</a>
<a name="ln8396">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln8397">      *bufp = *fnamep;</a>
<a name="ln8398">      if (*fnamep == NULL) {</a>
<a name="ln8399">        return -1;</a>
<a name="ln8400">      }</a>
<a name="ln8401">    }</a>
<a name="ln8402"> </a>
<a name="ln8403">    // Append a path separator to a directory.</a>
<a name="ln8404">    if (os_isdir(*fnamep)) {</a>
<a name="ln8405">      // Make room for one or two extra characters.</a>
<a name="ln8406">      *fnamep = xstrnsave(*fnamep, strlen(*fnamep) + 2);</a>
<a name="ln8407">      xfree(*bufp);          // free any allocated file name</a>
<a name="ln8408">      *bufp = *fnamep;</a>
<a name="ln8409">      add_pathsep(*fnamep);</a>
<a name="ln8410">    }</a>
<a name="ln8411">  }</a>
<a name="ln8412"> </a>
<a name="ln8413">  int c;</a>
<a name="ln8414"> </a>
<a name="ln8415">  // &quot;:.&quot; - path relative to the current directory</a>
<a name="ln8416">  // &quot;:~&quot; - path relative to the home directory</a>
<a name="ln8417">  // &quot;:8&quot; - shortname path - postponed till after</a>
<a name="ln8418">  while (src[*usedlen] == ':'</a>
<a name="ln8419">         &amp;&amp; ((c = (uint8_t)src[*usedlen + 1]) == '.' || c == '~' || c == '8')) {</a>
<a name="ln8420">    *usedlen += 2;</a>
<a name="ln8421">    if (c == '8') {</a>
<a name="ln8422">      continue;</a>
<a name="ln8423">    }</a>
<a name="ln8424">    pbuf = NULL;</a>
<a name="ln8425">    // Need full path first (use expand_env() to remove a &quot;~/&quot;)</a>
<a name="ln8426">    if (!has_fullname &amp;&amp; !has_homerelative) {</a>
<a name="ln8427">      if (**fnamep == '~') {</a>
<a name="ln8428">        p = pbuf = expand_env_save(*fnamep);</a>
<a name="ln8429">      } else {</a>
<a name="ln8430">        p = pbuf = FullName_save(*fnamep, false);</a>
<a name="ln8431">      }</a>
<a name="ln8432">    } else {</a>
<a name="ln8433">      p = *fnamep;</a>
<a name="ln8434">    }</a>
<a name="ln8435"> </a>
<a name="ln8436">    has_fullname = false;</a>
<a name="ln8437"> </a>
<a name="ln8438">    if (p != NULL) {</a>
<a name="ln8439">      if (c == '.') {</a>
<a name="ln8440">        os_dirname(dirname, MAXPATHL);</a>
<a name="ln8441">        if (has_homerelative) {</a>
<a name="ln8442">          s = xstrdup(dirname);</a>
<a name="ln8443">          home_replace(NULL, s, dirname, MAXPATHL, true);</a>
<a name="ln8444">          xfree(s);</a>
<a name="ln8445">        }</a>
<a name="ln8446">        size_t namelen = strlen(dirname);</a>
<a name="ln8447"> </a>
<a name="ln8448">        // Do not call shorten_fname() here since it removes the prefix</a>
<a name="ln8449">        // even though the path does not have a prefix.</a>
<a name="ln8450">        if (path_fnamencmp(p, dirname, namelen) == 0) {</a>
<a name="ln8451">          p += namelen;</a>
<a name="ln8452">          if (vim_ispathsep(*p)) {</a>
<a name="ln8453">            while (*p &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln8454">              p++;</a>
<a name="ln8455">            }</a>
<a name="ln8456">            *fnamep = p;</a>
<a name="ln8457">            if (pbuf != NULL) {</a>
<a name="ln8458">              // free any allocated file name</a>
<a name="ln8459">              xfree(*bufp);</a>
<a name="ln8460">              *bufp = pbuf;</a>
<a name="ln8461">              pbuf = NULL;</a>
<a name="ln8462">            }</a>
<a name="ln8463">          }</a>
<a name="ln8464">        }</a>
<a name="ln8465">      } else {</a>
<a name="ln8466">        home_replace(NULL, p, dirname, MAXPATHL, true);</a>
<a name="ln8467">        // Only replace it when it starts with '~'</a>
<a name="ln8468">        if (*dirname == '~') {</a>
<a name="ln8469">          s = xstrdup(dirname);</a>
<a name="ln8470">          assert(s != NULL);  // suppress clang &quot;Argument with 'nonnull' attribute passed null&quot;</a>
<a name="ln8471">          *fnamep = s;</a>
<a name="ln8472">          xfree(*bufp);</a>
<a name="ln8473">          *bufp = s;</a>
<a name="ln8474">          has_homerelative = true;</a>
<a name="ln8475">        }</a>
<a name="ln8476">      }</a>
<a name="ln8477">      xfree(pbuf);</a>
<a name="ln8478">    }</a>
<a name="ln8479">  }</a>
<a name="ln8480"> </a>
<a name="ln8481">  char *tail = path_tail(*fnamep);</a>
<a name="ln8482">  *fnamelen = strlen(*fnamep);</a>
<a name="ln8483"> </a>
<a name="ln8484">  // &quot;:h&quot; - head, remove &quot;/file_name&quot;, can be repeated</a>
<a name="ln8485">  // Don't remove the first &quot;/&quot; or &quot;c:\&quot;</a>
<a name="ln8486">  while (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'h') {</a>
<a name="ln8487">    valid |= VALID_HEAD;</a>
<a name="ln8488">    *usedlen += 2;</a>
<a name="ln8489">    s = get_past_head(*fnamep);</a>
<a name="ln8490">    while (tail &gt; s &amp;&amp; after_pathsep(s, tail)) {</a>
<a name="ln8491">      MB_PTR_BACK(*fnamep, tail);</a>
<a name="ln8492">    }</a>
<a name="ln8493">    *fnamelen = (size_t)(tail - *fnamep);</a>
<a name="ln8494">    if (*fnamelen == 0) {</a>
<a name="ln8495">      // Result is empty.  Turn it into &quot;.&quot; to make &quot;:cd %:h&quot; work.</a>
<a name="ln8496">      xfree(*bufp);</a>
<a name="ln8497">      *bufp = *fnamep = tail = xstrdup(&quot;.&quot;);</a>
<a name="ln8498">      *fnamelen = 1;</a>
<a name="ln8499">    } else {</a>
<a name="ln8500">      while (tail &gt; s &amp;&amp; !after_pathsep(s, tail)) {</a>
<a name="ln8501">        MB_PTR_BACK(*fnamep, tail);</a>
<a name="ln8502">      }</a>
<a name="ln8503">    }</a>
<a name="ln8504">  }</a>
<a name="ln8505"> </a>
<a name="ln8506">  // &quot;:8&quot; - shortname</a>
<a name="ln8507">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == '8') {</a>
<a name="ln8508">    *usedlen += 2;</a>
<a name="ln8509">  }</a>
<a name="ln8510"> </a>
<a name="ln8511">  // &quot;:t&quot; - tail, just the basename</a>
<a name="ln8512">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 't') {</a>
<a name="ln8513">    *usedlen += 2;</a>
<a name="ln8514">    *fnamelen -= (size_t)(tail - *fnamep);</a>
<a name="ln8515">    *fnamep = tail;</a>
<a name="ln8516">  }</a>
<a name="ln8517"> </a>
<a name="ln8518">  // &quot;:e&quot; - extension, can be repeated</a>
<a name="ln8519">  // &quot;:r&quot; - root, without extension, can be repeated</a>
<a name="ln8520">  while (src[*usedlen] == ':'</a>
<a name="ln8521">         &amp;&amp; (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {</a>
<a name="ln8522">    // find a '.' in the tail:</a>
<a name="ln8523">    // - for second :e: before the current fname</a>
<a name="ln8524">    // - otherwise: The last '.'</a>
<a name="ln8525">    const bool is_second_e = *fnamep &gt; tail;</a>
<a name="ln8526">    if (src[*usedlen + 1] == 'e' &amp;&amp; is_second_e) {</a>
<a name="ln8527">      s = (*fnamep) - 2;</a>
<a name="ln8528">    } else {</a>
<a name="ln8529">      s = (*fnamep) + *fnamelen - 1;</a>
<a name="ln8530">    }</a>
<a name="ln8531"> </a>
<a name="ln8532">    for (; s &gt; tail; s--) {</a>
<a name="ln8533">      if (s[0] == '.') {</a>
<a name="ln8534">        break;</a>
<a name="ln8535">      }</a>
<a name="ln8536">    }</a>
<a name="ln8537">    if (src[*usedlen + 1] == 'e') {</a>
<a name="ln8538">      if (s &gt; tail || (0 &amp;&amp; is_second_e &amp;&amp; s == tail)) {</a>
<a name="ln8539">        // we stopped at a '.' (so anchor to &amp;'.' + 1)</a>
<a name="ln8540">        char *newstart = s + 1;</a>
<a name="ln8541">        size_t distance_stepped_back = (size_t)(*fnamep - newstart);</a>
<a name="ln8542">        *fnamelen += distance_stepped_back;</a>
<a name="ln8543">        *fnamep = newstart;</a>
<a name="ln8544">      } else if (*fnamep &lt;= tail) {</a>
<a name="ln8545">        *fnamelen = 0;</a>
<a name="ln8546">      }</a>
<a name="ln8547">    } else {</a>
<a name="ln8548">      // :r - Remove one extension</a>
<a name="ln8549">      //</a>
<a name="ln8550">      // Ensure that `s` doesn't go before `*fnamep`,</a>
<a name="ln8551">      // since then we're taking too many roots:</a>
<a name="ln8552">      //</a>
<a name="ln8553">      // &quot;path/to/this.file.ext&quot; :e:e:r:r</a>
<a name="ln8554">      //          ^    ^-------- *fnamep</a>
<a name="ln8555">      //          +------------- tail</a>
<a name="ln8556">      //</a>
<a name="ln8557">      // Also ensure `s` doesn't go before `tail`,</a>
<a name="ln8558">      // since then we're taking too many roots again:</a>
<a name="ln8559">      //</a>
<a name="ln8560">      // &quot;path/to/this.file.ext&quot; :r:r:r</a>
<a name="ln8561">      //  ^       ^------------- tail</a>
<a name="ln8562">      //  +--------------------- *fnamep</a>
<a name="ln8563">      if (s &gt; MAX(tail, *fnamep)) {</a>
<a name="ln8564">        *fnamelen = (size_t)(s - *fnamep);</a>
<a name="ln8565">      }</a>
<a name="ln8566">    }</a>
<a name="ln8567">    *usedlen += 2;</a>
<a name="ln8568">  }</a>
<a name="ln8569"> </a>
<a name="ln8570">  // &quot;:s?pat?foo?&quot; - substitute</a>
<a name="ln8571">  // &quot;:gs?pat?foo?&quot; - global substitute</a>
<a name="ln8572">  if (src[*usedlen] == ':'</a>
<a name="ln8573">      &amp;&amp; (src[*usedlen + 1] == 's'</a>
<a name="ln8574">          || (src[*usedlen + 1] == 'g' &amp;&amp; src[*usedlen + 2] == 's'))) {</a>
<a name="ln8575">    bool didit = false;</a>
<a name="ln8576"> </a>
<a name="ln8577">    char *flags = &quot;&quot;;</a>
<a name="ln8578">    s = src + *usedlen + 2;</a>
<a name="ln8579">    if (src[*usedlen + 1] == 'g') {</a>
<a name="ln8580">      flags = &quot;g&quot;;</a>
<a name="ln8581">      s++;</a>
<a name="ln8582">    }</a>
<a name="ln8583"> </a>
<a name="ln8584">    int sep = (uint8_t)(*s++);</a>
<a name="ln8585">    if (sep) {</a>
<a name="ln8586">      // find end of pattern</a>
<a name="ln8587">      p = vim_strchr(s, sep);</a>
<a name="ln8588">      if (p != NULL) {</a>
<a name="ln8589">        char *const pat = xmemdupz(s, (size_t)(p - s));</a>
<a name="ln8590">        s = p + 1;</a>
<a name="ln8591">        // find end of substitution</a>
<a name="ln8592">        p = vim_strchr(s, sep);</a>
<a name="ln8593">        if (p != NULL) {</a>
<a name="ln8594">          char *const sub = xmemdupz(s, (size_t)(p - s));</a>
<a name="ln8595">          char *const str = xmemdupz(*fnamep, *fnamelen);</a>
<a name="ln8596">          *usedlen = (size_t)(p + 1 - src);</a>
<a name="ln8597">          s = do_string_sub(str, pat, sub, NULL, flags);</a>
<a name="ln8598">          *fnamep = s;</a>
<a name="ln8599">          *fnamelen = strlen(s);</a>
<a name="ln8600">          xfree(*bufp);</a>
<a name="ln8601">          *bufp = s;</a>
<a name="ln8602">          didit = true;</a>
<a name="ln8603">          xfree(sub);</a>
<a name="ln8604">          xfree(str);</a>
<a name="ln8605">        }</a>
<a name="ln8606">        xfree(pat);</a>
<a name="ln8607">      }</a>
<a name="ln8608">      // after using &quot;:s&quot;, repeat all the modifiers</a>
<a name="ln8609">      if (didit) {</a>
<a name="ln8610">        goto repeat;</a>
<a name="ln8611">      }</a>
<a name="ln8612">    }</a>
<a name="ln8613">  }</a>
<a name="ln8614"> </a>
<a name="ln8615">  if (src[*usedlen] == ':' &amp;&amp; src[*usedlen + 1] == 'S') {</a>
<a name="ln8616">    // vim_strsave_shellescape() needs a NUL terminated string.</a>
<a name="ln8617">    c = (uint8_t)(*fnamep)[*fnamelen];</a>
<a name="ln8618">    if (c != NUL) {</a>
<a name="ln8619">      (*fnamep)[*fnamelen] = NUL;</a>
<a name="ln8620">    }</a>
<a name="ln8621">    p = vim_strsave_shellescape(*fnamep, false, false);</a>
<a name="ln8622">    if (c != NUL) {</a>
<a name="ln8623">      (*fnamep)[*fnamelen] = (char)c;</a>
<a name="ln8624">    }</a>
<a name="ln8625">    xfree(*bufp);</a>
<a name="ln8626">    *bufp = *fnamep = p;</a>
<a name="ln8627">    *fnamelen = strlen(p);</a>
<a name="ln8628">    *usedlen += 2;</a>
<a name="ln8629">  }</a>
<a name="ln8630"> </a>
<a name="ln8631">  return valid;</a>
<a name="ln8632">}</a>
<a name="ln8633"> </a>
<a name="ln8634">/// Perform a substitution on &quot;str&quot; with pattern &quot;pat&quot; and substitute &quot;sub&quot;.</a>
<a name="ln8635">/// When &quot;sub&quot; is NULL &quot;expr&quot; is used, must be a VAR_FUNC or VAR_PARTIAL.</a>
<a name="ln8636">/// &quot;flags&quot; can be &quot;g&quot; to do a global substitute.</a>
<a name="ln8637">///</a>
<a name="ln8638">/// @return  an allocated string, NULL for error.</a>
<a name="ln8639">char *do_string_sub(char *str, char *pat, char *sub, typval_T *expr, const char *flags)</a>
<a name="ln8640">{</a>
<a name="ln8641">  regmatch_T regmatch;</a>
<a name="ln8642">  garray_T ga;</a>
<a name="ln8643">  char *zero_width = NULL;</a>
<a name="ln8644"> </a>
<a name="ln8645">  // Make 'cpoptions' empty, so that the 'l' flag doesn't work here</a>
<a name="ln8646">  char *save_cpo = p_cpo;</a>
<a name="ln8647">  p_cpo = empty_string_option;</a>
<a name="ln8648"> </a>
<a name="ln8649">  ga_init(&amp;ga, 1, 200);</a>
<a name="ln8650"> </a>
<a name="ln8651">  int do_all = (flags[0] == 'g');</a>
<a name="ln8652"> </a>
<a name="ln8653">  regmatch.rm_ic = p_ic;</a>
<a name="ln8654">  regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);</a>
<a name="ln8655">  if (regmatch.regprog != NULL) {</a>
<a name="ln8656">    int sublen;</a>
<a name="ln8657">    char *tail = str;</a>
<a name="ln8658">    char *end = str + strlen(str);</a>
<a name="ln8659">    while (vim_regexec_nl(&amp;regmatch, str, (colnr_T)(tail - str))) {</a>
<a name="ln8660">      // Skip empty match except for first match.</a>
<a name="ln8661">      if (regmatch.startp[0] == regmatch.endp[0]) {</a>
<a name="ln8662">        if (zero_width == regmatch.startp[0]) {</a>
<a name="ln8663">          // avoid getting stuck on a match with an empty string</a>
<a name="ln8664">          int i = utfc_ptr2len(tail);</a>
<a name="ln8665">          memmove((char *)ga.ga_data + ga.ga_len, tail, (size_t)i);</a>
<a name="ln8666">          ga.ga_len += i;</a>
<a name="ln8667">          tail += i;</a>
<a name="ln8668">          continue;</a>
<a name="ln8669">        }</a>
<a name="ln8670">        zero_width = regmatch.startp[0];</a>
<a name="ln8671">      }</a>
<a name="ln8672"> </a>
<a name="ln8673">      // Get some space for a temporary buffer to do the substitution</a>
<a name="ln8674">      // into.  It will contain:</a>
<a name="ln8675">      // - The text up to where the match is.</a>
<a name="ln8676">      // - The substituted text.</a>
<a name="ln8677">      // - The text after the match.</a>
<a name="ln8678">      sublen = vim_regsub(&amp;regmatch, sub, expr, tail, 0, REGSUB_MAGIC);</a>
<a name="ln8679">      if (sublen &lt;= 0) {</a>
<a name="ln8680">        ga_clear(&amp;ga);</a>
<a name="ln8681">        break;</a>
<a name="ln8682">      }</a>
<a name="ln8683">      ga_grow(&amp;ga, (int)((end - tail) + sublen -</a>
<a name="ln8684">                         (regmatch.endp[0] - regmatch.startp[0])));</a>
<a name="ln8685"> </a>
<a name="ln8686">      // copy the text up to where the match is</a>
<a name="ln8687">      int i = (int)(regmatch.startp[0] - tail);</a>
<a name="ln8688">      memmove((char *)ga.ga_data + ga.ga_len, tail, (size_t)i);</a>
<a name="ln8689">      // add the substituted text</a>
<a name="ln8690">      (void)vim_regsub(&amp;regmatch, sub, expr,</a>
<a name="ln8691">                       (char *)ga.ga_data + ga.ga_len + i, sublen,</a>
<a name="ln8692">                       REGSUB_COPY | REGSUB_MAGIC);</a>
<a name="ln8693">      ga.ga_len += i + sublen - 1;</a>
<a name="ln8694">      tail = regmatch.endp[0];</a>
<a name="ln8695">      if (*tail == NUL) {</a>
<a name="ln8696">        break;</a>
<a name="ln8697">      }</a>
<a name="ln8698">      if (!do_all) {</a>
<a name="ln8699">        break;</a>
<a name="ln8700">      }</a>
<a name="ln8701">    }</a>
<a name="ln8702"> </a>
<a name="ln8703">    if (ga.ga_data != NULL) {</a>
<a name="ln8704">      STRCPY((char *)ga.ga_data + ga.ga_len, tail);</a>
<a name="ln8705">    }</a>
<a name="ln8706"> </a>
<a name="ln8707">    vim_regfree(regmatch.regprog);</a>
<a name="ln8708">  }</a>
<a name="ln8709"> </a>
<a name="ln8710">  char *ret = xstrdup(ga.ga_data == NULL ? str : ga.ga_data);</a>
<a name="ln8711">  ga_clear(&amp;ga);</a>
<a name="ln8712">  if (p_cpo == empty_string_option) {</a>
<a name="ln8713">    p_cpo = save_cpo;</a>
<a name="ln8714">  } else {</a>
<a name="ln8715">    // Darn, evaluating {sub} expression or {expr} changed the value.</a>
<a name="ln8716">    // If it's still empty it was changed and restored, need to restore in</a>
<a name="ln8717">    // the complicated way.</a>
<a name="ln8718">    if (*p_cpo == NUL) {</a>
<a name="ln8719">      set_option_value_give_err(&quot;cpo&quot;, CSTR_AS_OPTVAL(save_cpo), 0);</a>
<a name="ln8720">    }</a>
<a name="ln8721">    free_string_option(save_cpo);</a>
<a name="ln8722">  }</a>
<a name="ln8723"> </a>
<a name="ln8724">  return ret;</a>
<a name="ln8725">}</a>
<a name="ln8726"> </a>
<a name="ln8727">/// common code for getting job callbacks for jobstart, termopen and rpcstart</a>
<a name="ln8728">///</a>
<a name="ln8729">/// @return true/false on success/failure.</a>
<a name="ln8730">bool common_job_callbacks(dict_T *vopts, CallbackReader *on_stdout, CallbackReader *on_stderr,</a>
<a name="ln8731">                          Callback *on_exit)</a>
<a name="ln8732">{</a>
<a name="ln8733">  if (tv_dict_get_callback(vopts, S_LEN(&quot;on_stdout&quot;), &amp;on_stdout-&gt;cb)</a>
<a name="ln8734">      &amp;&amp; tv_dict_get_callback(vopts, S_LEN(&quot;on_stderr&quot;), &amp;on_stderr-&gt;cb)</a>
<a name="ln8735">      &amp;&amp; tv_dict_get_callback(vopts, S_LEN(&quot;on_exit&quot;), on_exit)) {</a>
<a name="ln8736">    on_stdout-&gt;buffered = tv_dict_get_number(vopts, &quot;stdout_buffered&quot;);</a>
<a name="ln8737">    on_stderr-&gt;buffered = tv_dict_get_number(vopts, &quot;stderr_buffered&quot;);</a>
<a name="ln8738">    if (on_stdout-&gt;buffered &amp;&amp; on_stdout-&gt;cb.type == kCallbackNone) {</a>
<a name="ln8739">      on_stdout-&gt;self = vopts;</a>
<a name="ln8740">    }</a>
<a name="ln8741">    if (on_stderr-&gt;buffered &amp;&amp; on_stderr-&gt;cb.type == kCallbackNone) {</a>
<a name="ln8742">      on_stderr-&gt;self = vopts;</a>
<a name="ln8743">    }</a>
<a name="ln8744">    vopts-&gt;dv_refcount++;</a>
<a name="ln8745">    return true;</a>
<a name="ln8746">  }</a>
<a name="ln8747"> </a>
<a name="ln8748">  callback_reader_free(on_stdout);</a>
<a name="ln8749">  callback_reader_free(on_stderr);</a>
<a name="ln8750">  callback_free(on_exit);</a>
<a name="ln8751">  return false;</a>
<a name="ln8752">}</a>
<a name="ln8753"> </a>
<a name="ln8754">Channel *find_job(uint64_t id, bool show_error)</a>
<a name="ln8755">{</a>
<a name="ln8756">  Channel *data = find_channel(id);</a>
<a name="ln8757">  if (!data || data-&gt;streamtype != kChannelStreamProc</a>
<a name="ln8758">      || process_is_stopped(&amp;data-&gt;stream.proc)) {</a>
<a name="ln8759">    if (show_error) {</a>
<a name="ln8760">      if (data &amp;&amp; data-&gt;streamtype != kChannelStreamProc) {</a>
<a name="ln8761">        emsg(_(e_invchanjob));</a>
<a name="ln8762">      } else {</a>
<a name="ln8763">        emsg(_(e_invchan));</a>
<a name="ln8764">      }</a>
<a name="ln8765">    }</a>
<a name="ln8766">    return NULL;</a>
<a name="ln8767">  }</a>
<a name="ln8768">  return data;</a>
<a name="ln8769">}</a>
<a name="ln8770"> </a>
<a name="ln8771">void script_host_eval(char *name, typval_T *argvars, typval_T *rettv)</a>
<a name="ln8772">{</a>
<a name="ln8773">  if (check_secure()) {</a>
<a name="ln8774">    return;</a>
<a name="ln8775">  }</a>
<a name="ln8776"> </a>
<a name="ln8777">  if (argvars[0].v_type != VAR_STRING) {</a>
<a name="ln8778">    emsg(_(e_invarg));</a>
<a name="ln8779">    return;</a>
<a name="ln8780">  }</a>
<a name="ln8781"> </a>
<a name="ln8782">  list_T *args = tv_list_alloc(1);</a>
<a name="ln8783">  tv_list_append_string(args, argvars[0].vval.v_string, -1);</a>
<a name="ln8784">  *rettv = eval_call_provider(name, &quot;eval&quot;, args, false);</a>
<a name="ln8785">}</a>
<a name="ln8786"> </a>
<a name="ln8787">/// @param discard  Clears the value returned by the provider and returns</a>
<a name="ln8788">///                 an empty typval_T.</a>
<a name="ln8789">typval_T eval_call_provider(char *provider, char *method, list_T *arguments, bool discard)</a>
<a name="ln8790">{</a>
<a name="ln8791">  if (!eval_has_provider(provider)) {</a>
<a name="ln8792">    semsg(&quot;E319: No \&quot;%s\&quot; provider found. Run \&quot;:checkhealth provider\&quot;&quot;,</a>
<a name="ln8793">          provider);</a>
<a name="ln8794">    return (typval_T){</a>
<a name="ln8795">      .v_type = VAR_NUMBER,</a>
<a name="ln8796">      .v_lock = VAR_UNLOCKED,</a>
<a name="ln8797">      .vval.v_number = 0</a>
<a name="ln8798">    };</a>
<a name="ln8799">  }</a>
<a name="ln8800"> </a>
<a name="ln8801">  char func[256];</a>
<a name="ln8802">  int name_len = snprintf(func, sizeof(func), &quot;provider#%s#Call&quot;, provider);</a>
<a name="ln8803"> </a>
<a name="ln8804">  // Save caller scope information</a>
<a name="ln8805">  struct caller_scope saved_provider_caller_scope = provider_caller_scope;</a>
<a name="ln8806">  provider_caller_scope = (struct caller_scope) {</a>
<a name="ln8807">    .script_ctx = current_sctx,</a>
<a name="ln8808">    .es_entry = ((estack_T *)exestack.ga_data)[exestack.ga_len - 1],</a>
<a name="ln8809">    .autocmd_fname = autocmd_fname,</a>
<a name="ln8810">    .autocmd_match = autocmd_match,</a>
<a name="ln8811">    .autocmd_fname_full = autocmd_fname_full,</a>
<a name="ln8812">    .autocmd_bufnr = autocmd_bufnr,</a>
<a name="ln8813">    .funccalp = (void *)get_current_funccal()</a>
<a name="ln8814">  };</a>
<a name="ln8815">  funccal_entry_T funccal_entry;</a>
<a name="ln8816">  save_funccal(&amp;funccal_entry);</a>
<a name="ln8817">  provider_call_nesting++;</a>
<a name="ln8818"> </a>
<a name="ln8819">  typval_T argvars[3] = {</a>
<a name="ln8820">    { .v_type = VAR_STRING, .vval.v_string = method,</a>
<a name="ln8821">      .v_lock = VAR_UNLOCKED },</a>
<a name="ln8822">    { .v_type = VAR_LIST, .vval.v_list = arguments, .v_lock = VAR_UNLOCKED },</a>
<a name="ln8823">    { .v_type = VAR_UNKNOWN }</a>
<a name="ln8824">  };</a>
<a name="ln8825">  typval_T rettv = { .v_type = VAR_UNKNOWN, .v_lock = VAR_UNLOCKED };</a>
<a name="ln8826">  tv_list_ref(arguments);</a>
<a name="ln8827"> </a>
<a name="ln8828">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln8829">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln8830">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln8831">  funcexe.fe_evaluate = true;</a>
<a name="ln8832">  (void)call_func(func, name_len, &amp;rettv, 2, argvars, &amp;funcexe);</a>
<a name="ln8833"> </a>
<a name="ln8834">  tv_list_unref(arguments);</a>
<a name="ln8835">  // Restore caller scope information</a>
<a name="ln8836">  restore_funccal();</a>
<a name="ln8837">  provider_caller_scope = saved_provider_caller_scope;</a>
<a name="ln8838">  provider_call_nesting--;</a>
<a name="ln8839">  assert(provider_call_nesting &gt;= 0);</a>
<a name="ln8840"> </a>
<a name="ln8841">  if (discard) {</a>
<a name="ln8842">    tv_clear(&amp;rettv);</a>
<a name="ln8843">  }</a>
<a name="ln8844"> </a>
<a name="ln8845">  return rettv;</a>
<a name="ln8846">}</a>
<a name="ln8847"> </a>
<a name="ln8848">/// Checks if provider for feature `feat` is enabled.</a>
<a name="ln8849">bool eval_has_provider(const char *feat)</a>
<a name="ln8850">{</a>
<a name="ln8851">  if (!strequal(feat, &quot;clipboard&quot;)</a>
<a name="ln8852">      &amp;&amp; !strequal(feat, &quot;python3&quot;)</a>
<a name="ln8853">      &amp;&amp; !strequal(feat, &quot;python3_compiled&quot;)</a>
<a name="ln8854">      &amp;&amp; !strequal(feat, &quot;python3_dynamic&quot;)</a>
<a name="ln8855">      &amp;&amp; !strequal(feat, &quot;perl&quot;)</a>
<a name="ln8856">      &amp;&amp; !strequal(feat, &quot;ruby&quot;)</a>
<a name="ln8857">      &amp;&amp; !strequal(feat, &quot;node&quot;)) {</a>
<a name="ln8858">    // Avoid autoload for non-provider has() features.</a>
<a name="ln8859">    return false;</a>
<a name="ln8860">  }</a>
<a name="ln8861"> </a>
<a name="ln8862">  char name[32];  // Normalized: &quot;python3_compiled&quot; =&gt; &quot;python3&quot;.</a>
<a name="ln8863">  snprintf(name, sizeof(name), &quot;%s&quot;, feat);</a>
<a name="ln8864">  strchrsub(name, '_', '\0');  // Chop any &quot;_xx&quot; suffix.</a>
<a name="ln8865"> </a>
<a name="ln8866">  char buf[256];</a>
<a name="ln8867">  typval_T tv;</a>
<a name="ln8868">  // Get the g:loaded_xx_provider variable.</a>
<a name="ln8869">  int len = snprintf(buf, sizeof(buf), &quot;g:loaded_%s_provider&quot;, name);</a>
<a name="ln8870">  if (eval_variable(buf, len, &amp;tv, NULL, false, true) == FAIL) {</a>
<a name="ln8871">    // Trigger autoload once.</a>
<a name="ln8872">    len = snprintf(buf, sizeof(buf), &quot;provider#%s#bogus&quot;, name);</a>
<a name="ln8873">    script_autoload(buf, (size_t)len, false);</a>
<a name="ln8874"> </a>
<a name="ln8875">    // Retry the (non-autoload-style) variable.</a>
<a name="ln8876">    len = snprintf(buf, sizeof(buf), &quot;g:loaded_%s_provider&quot;, name);</a>
<a name="ln8877">    if (eval_variable(buf, len, &amp;tv, NULL, false, true) == FAIL) {</a>
<a name="ln8878">      // Show a hint if Call() is defined but g:loaded_xx_provider is missing.</a>
<a name="ln8879">      snprintf(buf, sizeof(buf), &quot;provider#%s#Call&quot;, name);</a>
<a name="ln8880">      if (!!find_func(buf) &amp;&amp; p_lpl) {</a>
<a name="ln8881">        semsg(&quot;provider: %s: missing required variable g:loaded_%s_provider&quot;,</a>
<a name="ln8882">              name, name);</a>
<a name="ln8883">      }</a>
<a name="ln8884">      return false;</a>
<a name="ln8885">    }</a>
<a name="ln8886">  }</a>
<a name="ln8887"> </a>
<a name="ln8888">  bool ok = (tv.v_type == VAR_NUMBER)</a>
<a name="ln8889">    ? 2 == tv.vval.v_number  // Value of 2 means &quot;loaded and working&quot;.</a>
<a name="ln8890">    : false;</a>
<a name="ln8891"> </a>
<a name="ln8892">  if (ok) {</a>
<a name="ln8893">    // Call() must be defined if provider claims to be working.</a>
<a name="ln8894">    snprintf(buf, sizeof(buf), &quot;provider#%s#Call&quot;, name);</a>
<a name="ln8895">    if (!find_func(buf)) {</a>
<a name="ln8896">      semsg(&quot;provider: %s: g:loaded_%s_provider=2 but %s is not defined&quot;,</a>
<a name="ln8897">            name, name, buf);</a>
<a name="ln8898">      ok = false;</a>
<a name="ln8899">    }</a>
<a name="ln8900">  }</a>
<a name="ln8901"> </a>
<a name="ln8902">  return ok;</a>
<a name="ln8903">}</a>
<a name="ln8904"> </a>
<a name="ln8905">/// Writes &quot;&lt;sourcing_name&gt;:&lt;sourcing_lnum&gt;&quot; to `buf[bufsize]`.</a>
<a name="ln8906">void eval_fmt_source_name_line(char *buf, size_t bufsize)</a>
<a name="ln8907">{</a>
<a name="ln8908">  if (SOURCING_NAME) {</a>
<a name="ln8909">    snprintf(buf, bufsize, &quot;%s:%&quot; PRIdLINENR, SOURCING_NAME, SOURCING_LNUM);</a>
<a name="ln8910">  } else {</a>
<a name="ln8911">    snprintf(buf, bufsize, &quot;?&quot;);</a>
<a name="ln8912">  }</a>
<a name="ln8913">}</a>
<a name="ln8914"> </a>
<a name="ln8915">/// &quot;:checkhealth [plugins]&quot;</a>
<a name="ln8916">void ex_checkhealth(exarg_T *eap)</a>
<a name="ln8917">{</a>
<a name="ln8918">  Error err = ERROR_INIT;</a>
<a name="ln8919">  MAXSIZE_TEMP_ARRAY(args, 1);</a>
<a name="ln8920">  ADD_C(args, CSTR_AS_OBJ(eap-&gt;arg));</a>
<a name="ln8921">  NLUA_EXEC_STATIC(&quot;return vim.health._check(...)&quot;, args, &amp;err);</a>
<a name="ln8922">  if (!ERROR_SET(&amp;err)) {</a>
<a name="ln8923">    return;</a>
<a name="ln8924">  }</a>
<a name="ln8925"> </a>
<a name="ln8926">  const char *vimruntime_env = os_getenv(&quot;VIMRUNTIME&quot;);</a>
<a name="ln8927">  if (vimruntime_env == NULL) {</a>
<a name="ln8928">    emsg(_(&quot;E5009: $VIMRUNTIME is empty or unset&quot;));</a>
<a name="ln8929">  } else {</a>
<a name="ln8930">    bool rtp_ok = NULL != strstr(p_rtp, vimruntime_env);</a>
<a name="ln8931">    if (rtp_ok) {</a>
<a name="ln8932">      semsg(_(&quot;E5009: Invalid $VIMRUNTIME: %s&quot;), vimruntime_env);</a>
<a name="ln8933">    } else {</a>
<a name="ln8934">      emsg(_(&quot;E5009: Invalid 'runtimepath'&quot;));</a>
<a name="ln8935">    }</a>
<a name="ln8936">  }</a>
<a name="ln8937">  semsg_multiline(err.msg);</a>
<a name="ln8938">  api_clear_error(&amp;err);</a>
<a name="ln8939">}</a>
<a name="ln8940"> </a>
<a name="ln8941">void invoke_prompt_callback(void)</a>
<a name="ln8942">{</a>
<a name="ln8943">  typval_T rettv;</a>
<a name="ln8944">  typval_T argv[2];</a>
<a name="ln8945">  linenr_T lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln8946"> </a>
<a name="ln8947">  // Add a new line for the prompt before invoking the callback, so that</a>
<a name="ln8948">  // text can always be inserted above the last line.</a>
<a name="ln8949">  ml_append(lnum, &quot;&quot;, 0, false);</a>
<a name="ln8950">  curwin-&gt;w_cursor.lnum = lnum + 1;</a>
<a name="ln8951">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln8952"> </a>
<a name="ln8953">  if (curbuf-&gt;b_prompt_callback.type == kCallbackNone) {</a>
<a name="ln8954">    return;</a>
<a name="ln8955">  }</a>
<a name="ln8956">  char *text = ml_get(lnum);</a>
<a name="ln8957">  char *prompt = prompt_text();</a>
<a name="ln8958">  if (strlen(text) &gt;= strlen(prompt)) {</a>
<a name="ln8959">    text += strlen(prompt);</a>
<a name="ln8960">  }</a>
<a name="ln8961">  argv[0].v_type = VAR_STRING;</a>
<a name="ln8962">  argv[0].vval.v_string = xstrdup(text);</a>
<a name="ln8963">  argv[1].v_type = VAR_UNKNOWN;</a>
<a name="ln8964"> </a>
<a name="ln8965">  callback_call(&amp;curbuf-&gt;b_prompt_callback, 1, argv, &amp;rettv);</a>
<a name="ln8966">  tv_clear(&amp;argv[0]);</a>
<a name="ln8967">  tv_clear(&amp;rettv);</a>
<a name="ln8968">}</a>
<a name="ln8969"> </a>
<a name="ln8970">/// @return  true when the interrupt callback was invoked.</a>
<a name="ln8971">bool invoke_prompt_interrupt(void)</a>
<a name="ln8972">{</a>
<a name="ln8973">  typval_T rettv;</a>
<a name="ln8974">  typval_T argv[1];</a>
<a name="ln8975"> </a>
<a name="ln8976">  if (curbuf-&gt;b_prompt_interrupt.type == kCallbackNone) {</a>
<a name="ln8977">    return false;</a>
<a name="ln8978">  }</a>
<a name="ln8979">  argv[0].v_type = VAR_UNKNOWN;</a>
<a name="ln8980"> </a>
<a name="ln8981">  got_int = false;  // don't skip executing commands</a>
<a name="ln8982">  int ret = callback_call(&amp;curbuf-&gt;b_prompt_interrupt, 0, argv, &amp;rettv);</a>
<a name="ln8983">  tv_clear(&amp;rettv);</a>
<a name="ln8984">  return ret != FAIL;</a>
<a name="ln8985">}</a>
<a name="ln8986"> </a>
<a name="ln8987">/// Compare &quot;typ1&quot; and &quot;typ2&quot;.  Put the result in &quot;typ1&quot;.</a>
<a name="ln8988">///</a>
<a name="ln8989">/// @param typ1  first operand</a>
<a name="ln8990">/// @param typ2  second operand</a>
<a name="ln8991">/// @param type  operator</a>
<a name="ln8992">/// @param ic  ignore case</a>
<a name="ln8993">int typval_compare(typval_T *typ1, typval_T *typ2, exprtype_T type, bool ic)</a>
<a name="ln8994">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln8995">{</a>
<a name="ln8996">  varnumber_T n1, n2;</a>
<a name="ln8997">  const bool type_is = type == EXPR_IS || type == EXPR_ISNOT;</a>
<a name="ln8998"> </a>
<a name="ln8999">  if (type_is &amp;&amp; typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln9000">    // For &quot;is&quot; a different type always means false, for &quot;isnot&quot;</a>
<a name="ln9001">    // it means true.</a>
<a name="ln9002">    n1 = type == EXPR_ISNOT;</a>
<a name="ln9003">  } else if (typ1-&gt;v_type == VAR_BLOB || typ2-&gt;v_type == VAR_BLOB) {</a>
<a name="ln9004">    if (type_is) {</a>
<a name="ln9005">      n1 = typ1-&gt;v_type == typ2-&gt;v_type</a>
<a name="ln9006">           &amp;&amp; typ1-&gt;vval.v_blob == typ2-&gt;vval.v_blob;</a>
<a name="ln9007">      if (type == EXPR_ISNOT) {</a>
<a name="ln9008">        n1 = !n1;</a>
<a name="ln9009">      }</a>
<a name="ln9010">    } else if (typ1-&gt;v_type != typ2-&gt;v_type</a>
<a name="ln9011">               || (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL)) {</a>
<a name="ln9012">      if (typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln9013">        emsg(_(&quot;E977: Can only compare Blob with Blob&quot;));</a>
<a name="ln9014">      } else {</a>
<a name="ln9015">        emsg(_(e_invalblob));</a>
<a name="ln9016">      }</a>
<a name="ln9017">      tv_clear(typ1);</a>
<a name="ln9018">      return FAIL;</a>
<a name="ln9019">    } else {</a>
<a name="ln9020">      // Compare two Blobs for being equal or unequal.</a>
<a name="ln9021">      n1 = tv_blob_equal(typ1-&gt;vval.v_blob, typ2-&gt;vval.v_blob);</a>
<a name="ln9022">      if (type == EXPR_NEQUAL) {</a>
<a name="ln9023">        n1 = !n1;</a>
<a name="ln9024">      }</a>
<a name="ln9025">    }</a>
<a name="ln9026">  } else if (typ1-&gt;v_type == VAR_LIST || typ2-&gt;v_type == VAR_LIST) {</a>
<a name="ln9027">    if (type_is) {</a>
<a name="ln9028">      n1 = typ1-&gt;v_type == typ2-&gt;v_type</a>
<a name="ln9029">           &amp;&amp; typ1-&gt;vval.v_list == typ2-&gt;vval.v_list;</a>
<a name="ln9030">      if (type == EXPR_ISNOT) {</a>
<a name="ln9031">        n1 = !n1;</a>
<a name="ln9032">      }</a>
<a name="ln9033">    } else if (typ1-&gt;v_type != typ2-&gt;v_type</a>
<a name="ln9034">               || (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL)) {</a>
<a name="ln9035">      if (typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln9036">        emsg(_(&quot;E691: Can only compare List with List&quot;));</a>
<a name="ln9037">      } else {</a>
<a name="ln9038">        emsg(_(&quot;E692: Invalid operation for List&quot;));</a>
<a name="ln9039">      }</a>
<a name="ln9040">      tv_clear(typ1);</a>
<a name="ln9041">      return FAIL;</a>
<a name="ln9042">    } else {</a>
<a name="ln9043">      // Compare two Lists for being equal or unequal.</a>
<a name="ln9044">      n1 = tv_list_equal(typ1-&gt;vval.v_list, typ2-&gt;vval.v_list, ic, false);</a>
<a name="ln9045">      if (type == EXPR_NEQUAL) {</a>
<a name="ln9046">        n1 = !n1;</a>
<a name="ln9047">      }</a>
<a name="ln9048">    }</a>
<a name="ln9049">  } else if (typ1-&gt;v_type == VAR_DICT || typ2-&gt;v_type == VAR_DICT) {</a>
<a name="ln9050">    if (type_is) {</a>
<a name="ln9051">      n1 = typ1-&gt;v_type == typ2-&gt;v_type</a>
<a name="ln9052">           &amp;&amp; typ1-&gt;vval.v_dict == typ2-&gt;vval.v_dict;</a>
<a name="ln9053">      if (type == EXPR_ISNOT) {</a>
<a name="ln9054">        n1 = !n1;</a>
<a name="ln9055">      }</a>
<a name="ln9056">    } else if (typ1-&gt;v_type != typ2-&gt;v_type</a>
<a name="ln9057">               || (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL)) {</a>
<a name="ln9058">      if (typ1-&gt;v_type != typ2-&gt;v_type) {</a>
<a name="ln9059">        emsg(_(&quot;E735: Can only compare Dictionary with Dictionary&quot;));</a>
<a name="ln9060">      } else {</a>
<a name="ln9061">        emsg(_(&quot;E736: Invalid operation for Dictionary&quot;));</a>
<a name="ln9062">      }</a>
<a name="ln9063">      tv_clear(typ1);</a>
<a name="ln9064">      return FAIL;</a>
<a name="ln9065">    } else {</a>
<a name="ln9066">      // Compare two Dictionaries for being equal or unequal.</a>
<a name="ln9067">      n1 = tv_dict_equal(typ1-&gt;vval.v_dict, typ2-&gt;vval.v_dict, ic, false);</a>
<a name="ln9068">      if (type == EXPR_NEQUAL) {</a>
<a name="ln9069">        n1 = !n1;</a>
<a name="ln9070">      }</a>
<a name="ln9071">    }</a>
<a name="ln9072">  } else if (tv_is_func(*typ1) || tv_is_func(*typ2)) {</a>
<a name="ln9073">    if (type != EXPR_EQUAL &amp;&amp; type != EXPR_NEQUAL</a>
<a name="ln9074">        &amp;&amp; type != EXPR_IS &amp;&amp; type != EXPR_ISNOT) {</a>
<a name="ln9075">      emsg(_(&quot;E694: Invalid operation for Funcrefs&quot;));</a>
<a name="ln9076">      tv_clear(typ1);</a>
<a name="ln9077">      return FAIL;</a>
<a name="ln9078">    }</a>
<a name="ln9079">    if ((typ1-&gt;v_type == VAR_PARTIAL &amp;&amp; typ1-&gt;vval.v_partial == NULL)</a>
<a name="ln9080">        || (typ2-&gt;v_type == VAR_PARTIAL &amp;&amp; typ2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln9081">      // When both partials are NULL, then they are equal.</a>
<a name="ln9082">      // Otherwise they are not equal.</a>
<a name="ln9083">      n1 = (typ1-&gt;vval.v_partial == typ2-&gt;vval.v_partial);</a>
<a name="ln9084">    } else if (type_is) {</a>
<a name="ln9085">      if (typ1-&gt;v_type == VAR_FUNC &amp;&amp; typ2-&gt;v_type == VAR_FUNC) {</a>
<a name="ln9086">        // strings are considered the same if their value is</a>
<a name="ln9087">        // the same</a>
<a name="ln9088">        n1 = tv_equal(typ1, typ2, ic, false);</a>
<a name="ln9089">      } else if (typ1-&gt;v_type == VAR_PARTIAL &amp;&amp; typ2-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln9090">        n1 = typ1-&gt;vval.v_partial == typ2-&gt;vval.v_partial;</a>
<a name="ln9091">      } else {</a>
<a name="ln9092">        n1 = false;</a>
<a name="ln9093">      }</a>
<a name="ln9094">    } else {</a>
<a name="ln9095">      n1 = tv_equal(typ1, typ2, ic, false);</a>
<a name="ln9096">    }</a>
<a name="ln9097">    if (type == EXPR_NEQUAL || type == EXPR_ISNOT) {</a>
<a name="ln9098">      n1 = !n1;</a>
<a name="ln9099">    }</a>
<a name="ln9100">  } else if ((typ1-&gt;v_type == VAR_FLOAT || typ2-&gt;v_type == VAR_FLOAT)</a>
<a name="ln9101">             &amp;&amp; type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln9102">    // If one of the two variables is a float, compare as a float.</a>
<a name="ln9103">    // When using &quot;=~&quot; or &quot;!~&quot;, always compare as string.</a>
<a name="ln9104">    const float_T f1 = tv_get_float(typ1);</a>
<a name="ln9105">    const float_T f2 = tv_get_float(typ2);</a>
<a name="ln9106">    n1 = false;</a>
<a name="ln9107">    switch (type) {</a>
<a name="ln9108">    case EXPR_IS:</a>
<a name="ln9109">    case EXPR_EQUAL:</a>
<a name="ln9110">      n1 = f1 == f2; break;</a>
<a name="ln9111">    case EXPR_ISNOT:</a>
<a name="ln9112">    case EXPR_NEQUAL:</a>
<a name="ln9113">      n1 = f1 != f2; break;</a>
<a name="ln9114">    case EXPR_GREATER:</a>
<a name="ln9115">      n1 = f1 &gt; f2; break;</a>
<a name="ln9116">    case EXPR_GEQUAL:</a>
<a name="ln9117">      n1 = f1 &gt;= f2; break;</a>
<a name="ln9118">    case EXPR_SMALLER:</a>
<a name="ln9119">      n1 = f1 &lt; f2; break;</a>
<a name="ln9120">    case EXPR_SEQUAL:</a>
<a name="ln9121">      n1 = f1 &lt;= f2; break;</a>
<a name="ln9122">    case EXPR_UNKNOWN:</a>
<a name="ln9123">    case EXPR_MATCH:</a>
<a name="ln9124">    case EXPR_NOMATCH:</a>
<a name="ln9125">      break;  // avoid gcc warning</a>
<a name="ln9126">    }</a>
<a name="ln9127">  } else if ((typ1-&gt;v_type == VAR_NUMBER || typ2-&gt;v_type == VAR_NUMBER)</a>
<a name="ln9128">             &amp;&amp; type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln9129">    // If one of the two variables is a number, compare as a number.</a>
<a name="ln9130">    // When using &quot;=~&quot; or &quot;!~&quot;, always compare as string.</a>
<a name="ln9131">    n1 = tv_get_number(typ1);</a>
<a name="ln9132">    n2 = tv_get_number(typ2);</a>
<a name="ln9133">    switch (type) {</a>
<a name="ln9134">    case EXPR_IS:</a>
<a name="ln9135">    case EXPR_EQUAL:</a>
<a name="ln9136">      n1 = n1 == n2; break;</a>
<a name="ln9137">    case EXPR_ISNOT:</a>
<a name="ln9138">    case EXPR_NEQUAL:</a>
<a name="ln9139">      n1 = n1 != n2; break;</a>
<a name="ln9140">    case EXPR_GREATER:</a>
<a name="ln9141">      n1 = n1 &gt; n2; break;</a>
<a name="ln9142">    case EXPR_GEQUAL:</a>
<a name="ln9143">      n1 = n1 &gt;= n2; break;</a>
<a name="ln9144">    case EXPR_SMALLER:</a>
<a name="ln9145">      n1 = n1 &lt; n2; break;</a>
<a name="ln9146">    case EXPR_SEQUAL:</a>
<a name="ln9147">      n1 = n1 &lt;= n2; break;</a>
<a name="ln9148">    case EXPR_UNKNOWN:</a>
<a name="ln9149">    case EXPR_MATCH:</a>
<a name="ln9150">    case EXPR_NOMATCH:</a>
<a name="ln9151">      break;  // avoid gcc warning</a>
<a name="ln9152">    }</a>
<a name="ln9153">  } else {</a>
<a name="ln9154">    char buf1[NUMBUFLEN];</a>
<a name="ln9155">    char buf2[NUMBUFLEN];</a>
<a name="ln9156">    const char *const s1 = tv_get_string_buf(typ1, buf1);</a>
<a name="ln9157">    const char *const s2 = tv_get_string_buf(typ2, buf2);</a>
<a name="ln9158">    int i;</a>
<a name="ln9159">    if (type != EXPR_MATCH &amp;&amp; type != EXPR_NOMATCH) {</a>
<a name="ln9160">      i = mb_strcmp_ic(ic, s1, s2);</a>
<a name="ln9161">    } else {</a>
<a name="ln9162">      i = 0;</a>
<a name="ln9163">    }</a>
<a name="ln9164">    n1 = false;</a>
<a name="ln9165">    switch (type) {</a>
<a name="ln9166">    case EXPR_IS:</a>
<a name="ln9167">    case EXPR_EQUAL:</a>
<a name="ln9168">      n1 = i == 0; break;</a>
<a name="ln9169">    case EXPR_ISNOT:</a>
<a name="ln9170">    case EXPR_NEQUAL:</a>
<a name="ln9171">      n1 = i != 0; break;</a>
<a name="ln9172">    case EXPR_GREATER:</a>
<a name="ln9173">      n1 = i &gt; 0; break;</a>
<a name="ln9174">    case EXPR_GEQUAL:</a>
<a name="ln9175">      n1 = i &gt;= 0; break;</a>
<a name="ln9176">    case EXPR_SMALLER:</a>
<a name="ln9177">      n1 = i &lt; 0; break;</a>
<a name="ln9178">    case EXPR_SEQUAL:</a>
<a name="ln9179">      n1 = i &lt;= 0; break;</a>
<a name="ln9180"> </a>
<a name="ln9181">    case EXPR_MATCH:</a>
<a name="ln9182">    case EXPR_NOMATCH:</a>
<a name="ln9183">      n1 = pattern_match(s2, s1, ic);</a>
<a name="ln9184">      if (type == EXPR_NOMATCH) {</a>
<a name="ln9185">        n1 = !n1;</a>
<a name="ln9186">      }</a>
<a name="ln9187">      break;</a>
<a name="ln9188">    case EXPR_UNKNOWN:</a>
<a name="ln9189">      break;  // avoid gcc warning</a>
<a name="ln9190">    }</a>
<a name="ln9191">  }</a>
<a name="ln9192">  tv_clear(typ1);</a>
<a name="ln9193">  typ1-&gt;v_type = VAR_NUMBER;</a>
<a name="ln9194">  typ1-&gt;vval.v_number = n1;</a>
<a name="ln9195">  return OK;</a>
<a name="ln9196">}</a>
<a name="ln9197"> </a>
<a name="ln9198">/// Convert any type to a string, never give an error.</a>
<a name="ln9199">/// When &quot;quotes&quot; is true add quotes to a string.</a>
<a name="ln9200">/// Returns an allocated string.</a>
<a name="ln9201">char *typval_tostring(typval_T *arg, bool quotes)</a>
<a name="ln9202">{</a>
<a name="ln9203">  if (arg == NULL) {</a>
<a name="ln9204">    return xstrdup(&quot;(does not exist)&quot;);</a>
<a name="ln9205">  }</a>
<a name="ln9206">  if (!quotes &amp;&amp; arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln9207">    return xstrdup(arg-&gt;vval.v_string == NULL ? &quot;&quot; : arg-&gt;vval.v_string);</a>
<a name="ln9208">  }</a>
<a name="ln9209">  return encode_tv2string(arg, NULL);</a>
<a name="ln9210">}</a>
</code></pre>
<div class="balloon" rel="2357"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'p' pointer was utilized before it was verified against nullptr. Check lines: 2357, 2377.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>