<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>quickfix.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// quickfix.c: functions for quickfix mode, using a file with error messages</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;limits.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14">#include &lt;time.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln17">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln18">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln19">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln20">#include &quot;nvim/charset.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln23">#include &quot;nvim/edit.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval/window.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln33">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln34">#include &quot;nvim/fold.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln37">#include &quot;nvim/globals.h&quot;</a>
<a name="ln38">#include &quot;nvim/help.h&quot;</a>
<a name="ln39">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln40">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln41">#include &quot;nvim/macros.h&quot;</a>
<a name="ln42">#include &quot;nvim/mark.h&quot;</a>
<a name="ln43">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln44">#include &quot;nvim/memline.h&quot;</a>
<a name="ln45">#include &quot;nvim/memory.h&quot;</a>
<a name="ln46">#include &quot;nvim/message.h&quot;</a>
<a name="ln47">#include &quot;nvim/move.h&quot;</a>
<a name="ln48">#include &quot;nvim/normal.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/option_defs.h&quot;</a>
<a name="ln51">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln52">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln55">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln56">#include &quot;nvim/path.h&quot;</a>
<a name="ln57">#include &quot;nvim/pos.h&quot;</a>
<a name="ln58">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln59">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln60">#include &quot;nvim/search.h&quot;</a>
<a name="ln61">#include &quot;nvim/strings.h&quot;</a>
<a name="ln62">#include &quot;nvim/types.h&quot;</a>
<a name="ln63">#include &quot;nvim/ui.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65">#include &quot;nvim/window.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">struct dir_stack_T {</a>
<a name="ln68">  struct dir_stack_T *next;</a>
<a name="ln69">  char *dirname;</a>
<a name="ln70">};</a>
<a name="ln71"> </a>
<a name="ln72">// For each error the next struct is allocated and linked in a list.</a>
<a name="ln73">typedef struct qfline_S qfline_T;</a>
<a name="ln74">struct qfline_S {</a>
<a name="ln75">  qfline_T *qf_next;      ///&lt; pointer to next error in the list</a>
<a name="ln76">  qfline_T *qf_prev;      ///&lt; pointer to previous error in the list</a>
<a name="ln77">  linenr_T qf_lnum;       ///&lt; line number where the error occurred</a>
<a name="ln78">  linenr_T qf_end_lnum;   ///&lt; line number when the error has range or zero</a>
<a name="ln79"> </a>
<a name="ln80">  int qf_fnum;            ///&lt; file number for the line</a>
<a name="ln81">  int qf_col;             ///&lt; column where the error occurred</a>
<a name="ln82">  int qf_end_col;         ///&lt; column when the error has range or zero</a>
<a name="ln83">  int qf_nr;              ///&lt; error number</a>
<a name="ln84">  char *qf_module;        ///&lt; module name for this error</a>
<a name="ln85">  char *qf_pattern;       ///&lt; search pattern for the error</a>
<a name="ln86">  char *qf_text;          ///&lt; description of the error</a>
<a name="ln87">  char qf_viscol;         ///&lt; set to true if qf_col and qf_end_col is screen column</a>
<a name="ln88">  char qf_cleared;        ///&lt; set to true if line has been deleted</a>
<a name="ln89">  char qf_type;           ///&lt; type of the error (mostly 'E'); 1 for :helpgrep</a>
<a name="ln90">  typval_T qf_user_data;  ///&lt; custom user data associated with this item</a>
<a name="ln91">  char qf_valid;          ///&lt; valid error message detected</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">// There is a stack of error lists.</a>
<a name="ln95">#define LISTCOUNT   10</a>
<a name="ln96">#define INVALID_QFIDX (-1)</a>
<a name="ln97">#define INVALID_QFBUFNR (0)</a>
<a name="ln98"> </a>
<a name="ln99">/// Quickfix list type.</a>
<a name="ln100">typedef enum {</a>
<a name="ln101">  QFLT_QUICKFIX,  ///&lt; Quickfix list - global list</a>
<a name="ln102">  QFLT_LOCATION,  ///&lt; Location list - per window list</a>
<a name="ln103">  QFLT_INTERNAL,  ///&lt; Internal - Temporary list used by</a>
<a name="ln104">  //   getqflist()/getloclist()</a>
<a name="ln105">} qfltype_T;</a>
<a name="ln106"> </a>
<a name="ln107">/// Quickfix/Location list definition</a>
<a name="ln108">///</a>
<a name="ln109">/// Usually the list contains one or more entries. But an empty list can be</a>
<a name="ln110">/// created using setqflist()/setloclist() with a title and/or user context</a>
<a name="ln111">/// information and entries can be added later using setqflist()/setloclist().</a>
<a name="ln112">typedef struct qf_list_S {</a>
<a name="ln113">  unsigned qf_id;         ///&lt; Unique identifier for this list</a>
<a name="ln114">  qfltype_T qfl_type;</a>
<a name="ln115">  qfline_T *qf_start;     ///&lt; pointer to the first error</a>
<a name="ln116">  qfline_T *qf_last;      ///&lt; pointer to the last error</a>
<a name="ln117">  qfline_T *qf_ptr;       ///&lt; pointer to the current error</a>
<a name="ln118">  int qf_count;           ///&lt; number of errors (0 means empty list)</a>
<a name="ln119">  int qf_index;           ///&lt; current index in the error list</a>
<a name="ln120">  bool qf_nonevalid;      ///&lt; true if not a single valid entry found</a>
<a name="ln121">  bool qf_has_user_data;  ///&lt; true if at least one item has user_data attached</a>
<a name="ln122">  char *qf_title;         ///&lt; title derived from the command that created</a>
<a name="ln123">                          ///&lt; the error list or set by setqflist</a>
<a name="ln124">  typval_T *qf_ctx;       ///&lt; context set by setqflist/setloclist</a>
<a name="ln125">  Callback qf_qftf_cb;    ///&lt; 'quickfixtextfunc' callback function</a>
<a name="ln126"> </a>
<a name="ln127">  struct dir_stack_T *qf_dir_stack;</a>
<a name="ln128">  char *qf_directory;</a>
<a name="ln129">  struct dir_stack_T *qf_file_stack;</a>
<a name="ln130">  char *qf_currfile;</a>
<a name="ln131">  bool qf_multiline;</a>
<a name="ln132">  bool qf_multiignore;</a>
<a name="ln133">  bool qf_multiscan;</a>
<a name="ln134">  int qf_changedtick;</a>
<a name="ln135">} qf_list_T;</a>
<a name="ln136"> </a>
<a name="ln137">/// Quickfix/Location list stack definition</a>
<a name="ln138">/// Contains a list of quickfix/location lists (qf_list_T)</a>
<a name="ln139">struct qf_info_S {</a>
<a name="ln140">  // Count of references to this list. Used only for location lists.</a>
<a name="ln141">  // When a location list window reference this list, qf_refcount</a>
<a name="ln142">  // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount</a>
<a name="ln143">  // reaches 0, the list is freed.</a>
<a name="ln144">  int qf_refcount;</a>
<a name="ln145">  int qf_listcount;                 // current number of lists</a>
<a name="ln146">  int qf_curlist;                   // current error list</a>
<a name="ln147">  qf_list_T qf_lists[LISTCOUNT];</a>
<a name="ln148">  qfltype_T qfl_type;  // type of list</a>
<a name="ln149">  int qf_bufnr;                     // quickfix window buffer number</a>
<a name="ln150">};</a>
<a name="ln151"> </a>
<a name="ln152">static qf_info_T ql_info;         // global quickfix list</a>
<a name="ln153">static unsigned last_qf_id = 0;   // Last Used quickfix list id</a>
<a name="ln154"> </a>
<a name="ln155">#define FMT_PATTERNS 14           // maximum number of % recognized</a>
<a name="ln156"> </a>
<a name="ln157">// Structure used to hold the info of one part of 'errorformat'</a>
<a name="ln158">typedef struct efm_S efm_T;</a>
<a name="ln159">struct efm_S {</a>
<a name="ln160">  regprog_T *prog;        // pre-formatted part of 'errorformat'</a>
<a name="ln161">  efm_T *next;        // pointer to next (NULL if last)</a>
<a name="ln162">  char addr[FMT_PATTERNS];    // indices of used % patterns</a>
<a name="ln163">  char prefix;                // prefix of this format line:</a>
<a name="ln164">                              // 'D' enter directory</a>
<a name="ln165">                              // 'X' leave directory</a>
<a name="ln166">                              // 'A' start of multi-line message</a>
<a name="ln167">                              // 'E' error message</a>
<a name="ln168">                              // 'W' warning message</a>
<a name="ln169">                              // 'I' informational message</a>
<a name="ln170">                              // 'N' note message</a>
<a name="ln171">                              // 'C' continuation line</a>
<a name="ln172">                              // 'Z' end of multi-line message</a>
<a name="ln173">                              // 'G' general, unspecific message</a>
<a name="ln174">                              // 'P' push file (partial) message</a>
<a name="ln175">                              // 'Q' pop/quit file (partial) message</a>
<a name="ln176">                              // 'O' overread (partial) message</a>
<a name="ln177">  char flags;                 // additional flags given in prefix</a>
<a name="ln178">                              // '-' do not include this line</a>
<a name="ln179">                              // '+' include whole line in message</a>
<a name="ln180">  int conthere;                 // %&gt; used</a>
<a name="ln181">};</a>
<a name="ln182"> </a>
<a name="ln183">/// List of location lists to be deleted.</a>
<a name="ln184">/// Used to delay the deletion of locations lists by autocmds.</a>
<a name="ln185">typedef struct qf_delq_S {</a>
<a name="ln186">  struct qf_delq_S *next;</a>
<a name="ln187">  qf_info_T *qi;</a>
<a name="ln188">} qf_delq_T;</a>
<a name="ln189"> </a>
<a name="ln190">enum {</a>
<a name="ln191">  QF_FAIL = 0,</a>
<a name="ln192">  QF_OK = 1,</a>
<a name="ln193">  QF_END_OF_INPUT = 2,</a>
<a name="ln194">  QF_NOMEM = 3,</a>
<a name="ln195">  QF_IGNORE_LINE = 4,</a>
<a name="ln196">  QF_MULTISCAN = 5,</a>
<a name="ln197">  QF_ABORT = 6,</a>
<a name="ln198">};</a>
<a name="ln199"> </a>
<a name="ln200">/// State information used to parse lines and add entries to a quickfix/location</a>
<a name="ln201">/// list.</a>
<a name="ln202">typedef struct {</a>
<a name="ln203">  char *linebuf;</a>
<a name="ln204">  size_t linelen;</a>
<a name="ln205">  char *growbuf;</a>
<a name="ln206">  size_t growbufsiz;</a>
<a name="ln207">  FILE *fd;</a>
<a name="ln208">  typval_T *tv;</a>
<a name="ln209">  char *p_str;</a>
<a name="ln210">  list_T *p_list;</a>
<a name="ln211">  listitem_T *p_li;</a>
<a name="ln212">  buf_T *buf;</a>
<a name="ln213">  linenr_T buflnum;</a>
<a name="ln214">  linenr_T lnumlast;</a>
<a name="ln215">  vimconv_T vc;</a>
<a name="ln216">} qfstate_T;</a>
<a name="ln217"> </a>
<a name="ln218">typedef struct {</a>
<a name="ln219">  char *namebuf;</a>
<a name="ln220">  int bnr;</a>
<a name="ln221">  char *module;</a>
<a name="ln222">  char *errmsg;</a>
<a name="ln223">  size_t errmsglen;</a>
<a name="ln224">  linenr_T lnum;</a>
<a name="ln225">  linenr_T end_lnum;</a>
<a name="ln226">  int col;</a>
<a name="ln227">  int end_col;</a>
<a name="ln228">  bool use_viscol;</a>
<a name="ln229">  char *pattern;</a>
<a name="ln230">  int enr;</a>
<a name="ln231">  char type;</a>
<a name="ln232">  typval_T *user_data;</a>
<a name="ln233">  bool valid;</a>
<a name="ln234">} qffields_T;</a>
<a name="ln235"> </a>
<a name="ln236">/// :vimgrep command arguments</a>
<a name="ln237">typedef struct vgr_args_S {</a>
<a name="ln238">  int tomatch;          ///&lt; maximum number of matches to find</a>
<a name="ln239">  char *spat;          ///&lt; search pattern</a>
<a name="ln240">  int flags;             ///&lt; search modifier</a>
<a name="ln241">  char **fnames;       ///&lt; list of files to search</a>
<a name="ln242">  int fcount;            ///&lt; number of files</a>
<a name="ln243">  regmmatch_T regmatch;  ///&lt; compiled search pattern</a>
<a name="ln244">  char *qf_title;      ///&lt; quickfix list title</a>
<a name="ln245">} vgr_args_T;</a>
<a name="ln246"> </a>
<a name="ln247">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln248"># include &quot;quickfix.c.generated.h&quot;</a>
<a name="ln249">#endif</a>
<a name="ln250"> </a>
<a name="ln251">static const char *e_no_more_items = N_(&quot;E553: No more items&quot;);</a>
<a name="ln252">static const char *e_current_quickfix_list_was_changed =</a>
<a name="ln253">  N_(&quot;E925: Current quickfix list was changed&quot;);</a>
<a name="ln254">static const char *e_current_location_list_was_changed =</a>
<a name="ln255">  N_(&quot;E926: Current location list was changed&quot;);</a>
<a name="ln256"> </a>
<a name="ln257">// Quickfix window check helper macro</a>
<a name="ln258">#define IS_QF_WINDOW(wp) (bt_quickfix((wp)-&gt;w_buffer) &amp;&amp; (wp)-&gt;w_llist_ref == NULL)</a>
<a name="ln259">// Location list window check helper macro</a>
<a name="ln260">#define IS_LL_WINDOW(wp) (bt_quickfix((wp)-&gt;w_buffer) &amp;&amp; (wp)-&gt;w_llist_ref != NULL)</a>
<a name="ln261"> </a>
<a name="ln262">// Quickfix and location list stack check helper macros</a>
<a name="ln263">#define IS_QF_STACK(qi)       ((qi)-&gt;qfl_type == QFLT_QUICKFIX)</a>
<a name="ln264">#define IS_LL_STACK(qi)       ((qi)-&gt;qfl_type == QFLT_LOCATION)</a>
<a name="ln265">#define IS_QF_LIST(qfl)       ((qfl)-&gt;qfl_type == QFLT_QUICKFIX)</a>
<a name="ln266">#define IS_LL_LIST(qfl)       ((qfl)-&gt;qfl_type == QFLT_LOCATION)</a>
<a name="ln267"> </a>
<a name="ln268">//</a>
<a name="ln269">// Return location list for window 'wp'</a>
<a name="ln270">// For location list window, return the referenced location list</a>
<a name="ln271">//</a>
<a name="ln272">#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? (wp)-&gt;w_llist_ref : (wp)-&gt;w_llist)</a>
<a name="ln273"> </a>
<a name="ln274">// Macro to loop through all the items in a quickfix list</a>
<a name="ln275">// Quickfix item index starts from 1, so i below starts at 1</a>
<a name="ln276">#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \</a>
<a name="ln277">  for ((i) = 1, (qfp) = (qfl)-&gt;qf_start;  /* NOLINT(readability/braces) */ \</a>
<a name="ln278">       !got_int &amp;&amp; (i) &lt;= (qfl)-&gt;qf_count &amp;&amp; (qfp) != NULL; \</a>
<a name="ln279">       (i)++, (qfp) = (qfp)-&gt;qf_next)</a>
<a name="ln280"> </a>
<a name="ln281">// Looking up a buffer can be slow if there are many.  Remember the last one</a>
<a name="ln282">// to make this a lot faster if there are multiple matches in the same file.</a>
<a name="ln283">static char *qf_last_bufname = NULL;</a>
<a name="ln284">static bufref_T qf_last_bufref = { NULL, 0, 0 };</a>
<a name="ln285"> </a>
<a name="ln286">static garray_T qfga;</a>
<a name="ln287"> </a>
<a name="ln288">/// Get a growarray to buffer text in.  Shared between various commands to avoid</a>
<a name="ln289">/// many alloc/free calls.</a>
<a name="ln290">static garray_T *qfga_get(void)</a>
<a name="ln291">{</a>
<a name="ln292">  static bool initialized = false;</a>
<a name="ln293"> </a>
<a name="ln294">  if (!initialized) {</a>
<a name="ln295">    initialized = true;</a>
<a name="ln296">    ga_init(&amp;qfga, 1, 256);</a>
<a name="ln297">  }</a>
<a name="ln298"> </a>
<a name="ln299">  // Reset the length to zero.  Retain ga_data from previous use to avoid</a>
<a name="ln300">  // many alloc/free calls.</a>
<a name="ln301">  qfga.ga_len = 0;</a>
<a name="ln302"> </a>
<a name="ln303">  return &amp;qfga;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">/// The &quot;qfga&quot; grow array buffer is reused across multiple quickfix commands as</a>
<a name="ln307">/// a temporary buffer to reduce the number of alloc/free calls.  But if the</a>
<a name="ln308">/// buffer size is large, then to avoid holding on to that memory, clear the</a>
<a name="ln309">/// grow array.  Otherwise just reset the grow array length.</a>
<a name="ln310">static void qfga_clear(void)</a>
<a name="ln311">{</a>
<a name="ln312">  if (qfga.ga_maxlen &gt; 1000) {</a>
<a name="ln313">    ga_clear(&amp;qfga);</a>
<a name="ln314">  } else {</a>
<a name="ln315">    qfga.ga_len = 0;</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">// Counter to prevent autocmds from freeing up location lists when they are</a>
<a name="ln320">// still being used.</a>
<a name="ln321">static int quickfix_busy = 0;</a>
<a name="ln322">static qf_delq_T *qf_delq_head = NULL;</a>
<a name="ln323"> </a>
<a name="ln324">/// Process the next line from a file/buffer/list/string and add it</a>
<a name="ln325">/// to the quickfix list 'qfl'.</a>
<a name="ln326">static int qf_init_process_nextline(qf_list_T *qfl, efm_T *fmt_first, qfstate_T *state,</a>
<a name="ln327">                                    qffields_T *fields)</a>
<a name="ln328">{</a>
<a name="ln329">  // Get the next line from a file/buffer/list/string</a>
<a name="ln330">  int status = qf_get_nextline(state);</a>
<a name="ln331">  if (status != QF_OK) {</a>
<a name="ln332">    return status;</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  status = qf_parse_line(qfl, state-&gt;linebuf, state-&gt;linelen,</a>
<a name="ln336">                         fmt_first, fields);</a>
<a name="ln337">  if (status != QF_OK) {</a>
<a name="ln338">    return status;</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  return qf_add_entry(qfl,</a>
<a name="ln342">                      qfl-&gt;qf_directory,</a>
<a name="ln343">                      (*fields-&gt;namebuf || qfl-&gt;qf_directory != NULL)</a>
<a name="ln344">                      ? fields-&gt;namebuf</a>
<a name="ln345">                      : ((qfl-&gt;qf_currfile != NULL &amp;&amp; fields-&gt;valid)</a>
<a name="ln346">                         ? qfl-&gt;qf_currfile : NULL),</a>
<a name="ln347">                      fields-&gt;module,</a>
<a name="ln348">                      fields-&gt;bnr,</a>
<a name="ln349">                      fields-&gt;errmsg,</a>
<a name="ln350">                      fields-&gt;lnum,</a>
<a name="ln351">                      fields-&gt;end_lnum,</a>
<a name="ln352">                      fields-&gt;col,</a>
<a name="ln353">                      fields-&gt;end_col,</a>
<a name="ln354">                      fields-&gt;use_viscol,</a>
<a name="ln355">                      fields-&gt;pattern,</a>
<a name="ln356">                      fields-&gt;enr,</a>
<a name="ln357">                      fields-&gt;type,</a>
<a name="ln358">                      fields-&gt;user_data,</a>
<a name="ln359">                      fields-&gt;valid);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/// Read the errorfile &quot;efile&quot; into memory, line by line, building the error</a>
<a name="ln363">/// list. Set the error list's title to qf_title.</a>
<a name="ln364">///</a>
<a name="ln365">/// @params  wp  If non-NULL, make a location list</a>
<a name="ln366">/// @params  efile  If non-NULL, errorfile to parse</a>
<a name="ln367">/// @params  errorformat  'errorformat' string used to parse the error lines</a>
<a name="ln368">/// @params  newlist  If true, create a new error list</a>
<a name="ln369">/// @params  qf_title  If non-NULL, title of the error list</a>
<a name="ln370">/// @params  enc  If non-NULL, encoding used to parse errors</a>
<a name="ln371">///</a>
<a name="ln372">/// @returns -1 for error, number of errors for success.</a>
<a name="ln373">int qf_init(win_T *wp, const char *restrict efile, char *restrict errorformat, int newlist,</a>
<a name="ln374">            const char *restrict qf_title, char *restrict enc)</a>
<a name="ln375">{</a>
<a name="ln376">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln377"> </a>
<a name="ln378">  if (wp != NULL) {</a>
<a name="ln379">    qi = ll_get_or_alloc_list(wp);</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  return qf_init_ext(qi, qi-&gt;qf_curlist, efile, curbuf, NULL, errorformat,</a>
<a name="ln383">                     newlist, 0, 0, qf_title, enc);</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">// Maximum number of bytes allowed per line while reading an errorfile.</a>
<a name="ln387">static const size_t LINE_MAXLEN = 4096;</a>
<a name="ln388"> </a>
<a name="ln389">/// Patterns used.  Keep in sync with qf_parse_fmt[].</a>
<a name="ln390">static struct fmtpattern {</a>
<a name="ln391">  char convchar;</a>
<a name="ln392">  char *pattern;</a>
<a name="ln393">} fmt_pat[FMT_PATTERNS] = {</a>
<a name="ln394">  { 'f', &quot;.\\+&quot; },      // only used when at end</a>
<a name="ln395">  { 'b', &quot;\\d\\+&quot; },    // 1</a>
<a name="ln396">  { 'n', &quot;\\d\\+&quot; },    // 2</a>
<a name="ln397">  { 'l', &quot;\\d\\+&quot; },    // 3</a>
<a name="ln398">  { 'e', &quot;\\d\\+&quot; },    // 4</a>
<a name="ln399">  { 'c', &quot;\\d\\+&quot; },    // 5</a>
<a name="ln400">  { 'k', &quot;\\d\\+&quot; },    // 6</a>
<a name="ln401">  { 't', &quot;.&quot; },         // 7</a>
<a name="ln402">#define FMT_PATTERN_M 8</a>
<a name="ln403">  { 'm', &quot;.\\+&quot; },      // 8</a>
<a name="ln404">#define FMT_PATTERN_R 9</a>
<a name="ln405">  { 'r', &quot;.*&quot; },        // 9</a>
<a name="ln406">  { 'p', &quot;[-\t .]*&quot; },  // 10</a>
<a name="ln407">  { 'v', &quot;\\d\\+&quot; },    // 11</a>
<a name="ln408">  { 's', &quot;.\\+&quot; },      // 12</a>
<a name="ln409">  { 'o', &quot;.\\+&quot; }       // 13</a>
<a name="ln410">};</a>
<a name="ln411"> </a>
<a name="ln412">/// Convert an errorformat pattern to a regular expression pattern.</a>
<a name="ln413">/// See fmt_pat definition above for the list of supported patterns.  The</a>
<a name="ln414">/// pattern specifier is supplied in &quot;efmpat&quot;.  The converted pattern is stored</a>
<a name="ln415">/// in &quot;regpat&quot;.  Returns a pointer to the location after the pattern.</a>
<a name="ln416">static char *efmpat_to_regpat(const char *efmpat, char *regpat, efm_T *efminfo, int idx, int round)</a>
<a name="ln417">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln418">{</a>
<a name="ln419">  if (efminfo-&gt;addr[idx]) {</a>
<a name="ln420">    // Each errorformat pattern can occur only once</a>
<a name="ln421">    semsg(_(&quot;E372: Too many %%%c in format string&quot;), *efmpat);</a>
<a name="ln422">    return NULL;</a>
<a name="ln423">  }</a>
<a name="ln424">  if ((idx &amp;&amp; idx &lt; FMT_PATTERN_R</a>
<a name="ln425">       &amp;&amp; vim_strchr(&quot;DXOPQ&quot;, (uint8_t)efminfo-&gt;prefix) != NULL)</a>
<a name="ln426">      || (idx == FMT_PATTERN_R</a>
<a name="ln427">          &amp;&amp; vim_strchr(&quot;OPQ&quot;, (uint8_t)efminfo-&gt;prefix) == NULL)) {</a>
<a name="ln428">    semsg(_(&quot;E373: Unexpected %%%c in format string&quot;), *efmpat);</a>
<a name="ln429">    return NULL;</a>
<a name="ln430">  }</a>
<a name="ln431">  efminfo-&gt;addr[idx] = (char)++round;</a>
<a name="ln432">  *regpat++ = '\\';</a>
<a name="ln433">  *regpat++ = '(';</a>
<a name="ln434">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln435">  if (*efmpat == 'f') {</a>
<a name="ln436">    // Also match &quot;c:&quot; in the file name, even when</a>
<a name="ln437">    // checking for a colon next: &quot;%f:&quot;.</a>
<a name="ln438">    // &quot;\%(\a:\)\=&quot;</a>
<a name="ln439">    STRCPY(regpat, &quot;\\%(\\a:\\)\\=&quot;);</a>
<a name="ln440">    regpat += 10;</a>
<a name="ln441">  }</a>
<a name="ln442">#endif</a>
<a name="ln443">  if (*efmpat == 'f' &amp;&amp; efmpat[1] != NUL) {</a>
<a name="ln444">    if (efmpat[1] != '\\' &amp;&amp; efmpat[1] != '%') {</a>
<a name="ln445">      // A file name may contain spaces, but this isn't</a>
<a name="ln446">      // in &quot;\f&quot;.  For &quot;%f:%l:%m&quot; there may be a &quot;:&quot; in</a>
<a name="ln447">      // the file name.  Use &quot;.\{-1,}x&quot; instead (x is</a>
<a name="ln448">      // the next character), the requirement that :999:</a>
<a name="ln449">      // follows should work.</a>
<a name="ln450">      STRCPY(regpat, &quot;.\\{-1,}&quot;);</a>
<a name="ln451">      regpat += 7;</a>
<a name="ln452">    } else {</a>
<a name="ln453">      // File name followed by '\\' or '%': include as</a>
<a name="ln454">      // many file name chars as possible.</a>
<a name="ln455">      STRCPY(regpat, &quot;\\f\\+&quot;);</a>
<a name="ln456">      regpat += 4;</a>
<a name="ln457">    }</a>
<a name="ln458">  } else {</a>
<a name="ln459">    char *srcptr = fmt_pat[idx].pattern;</a>
<a name="ln460">    while ((*regpat = *srcptr++) != NUL) {</a>
<a name="ln461">      regpat++;</a>
<a name="ln462">    }</a>
<a name="ln463">  }</a>
<a name="ln464">  *regpat++ = '\\';</a>
<a name="ln465">  *regpat++ = ')';</a>
<a name="ln466"> </a>
<a name="ln467">  return regpat;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">/// Convert a scanf like format in 'errorformat' to a regular expression.</a>
<a name="ln471">/// Returns a pointer to the location after the pattern.</a>
<a name="ln472">static char *scanf_fmt_to_regpat(const char **pefmp, const char *efm, int len, char *regpat)</a>
<a name="ln473">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln474">{</a>
<a name="ln475">  const char *efmp = *pefmp;</a>
<a name="ln476"> </a>
<a name="ln477">  if (*efmp == '[' || *efmp == '\\') {</a>
<a name="ln478">    if ((*regpat++ = *efmp) == '[') {  // %*[^a-z0-9] etc.</a>
<a name="ln479">      if (efmp[1] == '^') {</a>
<a name="ln480">        *regpat++ = *++efmp;</a>
<a name="ln481">      }</a>
<a name="ln482">      if (efmp &lt; efm + len) {</a>
<a name="ln483">        *regpat++ = *++efmp;  // could be ']'</a>
<a name="ln484">        while (efmp &lt; efm + len &amp;&amp; (*regpat++ = *++efmp) != ']') {}</a>
<a name="ln485">        if (efmp == efm + len) {</a>
<a name="ln486">          emsg(_(&quot;E374: Missing ] in format string&quot;));</a>
<a name="ln487">          return NULL;</a>
<a name="ln488">        }</a>
<a name="ln489">      }</a>
<a name="ln490">    } else if (efmp &lt; efm + len) {  // %*\D, %*\s etc.</a>
<a name="ln491">      *regpat++ = *++efmp;</a>
<a name="ln492">    }</a>
<a name="ln493">    *regpat++ = '\\';</a>
<a name="ln494">    *regpat++ = '+';</a>
<a name="ln495">  } else {</a>
<a name="ln496">    semsg(_(&quot;E375: Unsupported %%%c in format string&quot;), *efmp);</a>
<a name="ln497">    return NULL;</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  *pefmp = efmp;</a>
<a name="ln501"> </a>
<a name="ln502">  return regpat;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">/// Analyze/parse an errorformat prefix.</a>
<a name="ln506">static const char *efm_analyze_prefix(const char *efmp, efm_T *efminfo)</a>
<a name="ln507">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln508">{</a>
<a name="ln509">  if (vim_strchr(&quot;+-&quot;, (uint8_t)(*efmp)) != NULL) {</a>
<a name="ln510">    efminfo-&gt;flags = *efmp++;</a>
<a name="ln511">  }</a>
<a name="ln512">  if (vim_strchr(&quot;DXAEWINCZGOPQ&quot;, (uint8_t)(*efmp)) != NULL) {</a>
<a name="ln513">    efminfo-&gt;prefix = *efmp;</a>
<a name="ln514">  } else {</a>
<a name="ln515">    semsg(_(&quot;E376: Invalid %%%c in format string prefix&quot;), *efmp);</a>
<a name="ln516">    return NULL;</a>
<a name="ln517">  }</a>
<a name="ln518"> </a>
<a name="ln519">  return efmp;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">// Converts a 'errorformat' string to regular expression pattern</a>
<a name="ln523">static int efm_to_regpat(const char *efm, int len, efm_T *fmt_ptr, char *regpat)</a>
<a name="ln524">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln525">{</a>
<a name="ln526">  // Build regexp pattern from current 'errorformat' option</a>
<a name="ln527">  char *ptr = regpat;</a>
<a name="ln528">  *ptr++ = '^';</a>
<a name="ln529">  int round = 0;</a>
<a name="ln530">  for (const char *efmp = efm; efmp &lt; efm + len; efmp++) {</a>
<a name="ln531">    if (*efmp == '%') {</a>
<a name="ln532">      efmp++;</a>
<a name="ln533">      int idx;</a>
<a name="ln534">      for (idx = 0; idx &lt; FMT_PATTERNS; idx++) {</a>
<a name="ln535">        if (fmt_pat[idx].convchar == *efmp) {</a>
<a name="ln536">          break;</a>
<a name="ln537">        }</a>
<a name="ln538">      }</a>
<a name="ln539">      if (idx &lt; FMT_PATTERNS) {</a>
<a name="ln540">        ptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);</a>
<a name="ln541">        if (ptr == NULL) {</a>
<a name="ln542">          return FAIL;</a>
<a name="ln543">        }</a>
<a name="ln544">        round++;</a>
<a name="ln545">      } else if (*efmp == '*') {</a>
<a name="ln546">        efmp++;</a>
<a name="ln547">        ptr = scanf_fmt_to_regpat(&amp;efmp, efm, len, ptr);</a>
<a name="ln548">        if (ptr == NULL) {</a>
<a name="ln549">          return FAIL;</a>
<a name="ln550">        }</a>
<a name="ln551">      } else if (vim_strchr(&quot;%\\.^$~[&quot;, (uint8_t)(*efmp)) != NULL) {</a>
<a name="ln552">        *ptr++ = *efmp;  // regexp magic characters</a>
<a name="ln553">      } else if (*efmp == '#') {</a>
<a name="ln554">        *ptr++ = '*';</a>
<a name="ln555">      } else if (*efmp == '&gt;') {</a>
<a name="ln556">        fmt_ptr-&gt;conthere = true;</a>
<a name="ln557">      } else if (efmp == efm + 1) {             // analyse prefix</a>
<a name="ln558">        // prefix is allowed only at the beginning of the errorformat</a>
<a name="ln559">        // option part</a>
<a name="ln560">        efmp = efm_analyze_prefix(efmp, fmt_ptr);</a>
<a name="ln561">        if (efmp == NULL) {</a>
<a name="ln562">          return FAIL;</a>
<a name="ln563">        }</a>
<a name="ln564">      } else {</a>
<a name="ln565">        semsg(_(&quot;E377: Invalid %%%c in format string&quot;), *efmp);</a>
<a name="ln566">        return FAIL;</a>
<a name="ln567">      }</a>
<a name="ln568">    } else {                    // copy normal character</a>
<a name="ln569">      if (*efmp == '\\' &amp;&amp; efmp + 1 &lt; efm + len) {</a>
<a name="ln570">        efmp++;</a>
<a name="ln571">      } else if (vim_strchr(&quot;.*^$~[&quot;, (uint8_t)(*efmp)) != NULL) {</a>
<a name="ln572">        *ptr++ = '\\';  // escape regexp atoms</a>
<a name="ln573">      }</a>
<a name="ln574">      if (*efmp) {</a>
<a name="ln575">        *ptr++ = *efmp;</a>
<a name="ln576">      }</a>
<a name="ln577">    }</a>
<a name="ln578">  }</a>
<a name="ln579">  *ptr++ = '$';</a>
<a name="ln580">  *ptr = NUL;</a>
<a name="ln581"> </a>
<a name="ln582">  return OK;</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">static efm_T *fmt_start = NULL;  // cached across qf_parse_line() calls</a>
<a name="ln586"> </a>
<a name="ln587">// callback function for 'quickfixtextfunc'</a>
<a name="ln588">static Callback qftf_cb;</a>
<a name="ln589"> </a>
<a name="ln590">static void free_efm_list(efm_T **efm_first)</a>
<a name="ln591">{</a>
<a name="ln592">  for (efm_T *efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first) {</a>
<a name="ln593">    *efm_first = efm_ptr-&gt;next;</a>
<a name="ln594">    vim_regfree(efm_ptr-&gt;prog);</a>
<a name="ln595">    xfree(efm_ptr);</a>
<a name="ln596">  }</a>
<a name="ln597"> </a>
<a name="ln598">  fmt_start = NULL;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">/// Compute the size of the buffer used to convert a 'errorformat' pattern into</a>
<a name="ln602">/// a regular expression pattern.</a>
<a name="ln603">static size_t efm_regpat_bufsz(char *efm)</a>
<a name="ln604">{</a>
<a name="ln605">  size_t sz = (FMT_PATTERNS * 3) + (strlen(efm) &lt;&lt; 2);</a>
<a name="ln606">  for (int i = FMT_PATTERNS - 1; i &gt;= 0;) {</a>
<a name="ln607">    sz += strlen(fmt_pat[i--].pattern);</a>
<a name="ln608">  }</a>
<a name="ln609">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln610">  sz += 12;  // &quot;%f&quot; can become twelve chars longer (see efm_to_regpat)</a>
<a name="ln611">#else</a>
<a name="ln612">  sz += 2;  // &quot;%f&quot; can become two chars longer</a>
<a name="ln613">#endif</a>
<a name="ln614"> </a>
<a name="ln615">  return sz;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">/// Return the length of a 'errorformat' option part (separated by &quot;,&quot;).</a>
<a name="ln619">static int efm_option_part_len(const char *efm)</a>
<a name="ln620">{</a>
<a name="ln621">  int len;</a>
<a name="ln622"> </a>
<a name="ln623">  for (len = 0; efm[len] != NUL &amp;&amp; efm[len] != ','; len++) {</a>
<a name="ln624">    if (efm[len] == '\\' &amp;&amp; efm[len + 1] != NUL) {</a>
<a name="ln625">      len++;</a>
<a name="ln626">    }</a>
<a name="ln627">  }</a>
<a name="ln628"> </a>
<a name="ln629">  return len;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">/// Parse the 'errorformat' option. Multiple parts in the 'errorformat' option</a>
<a name="ln633">/// are parsed and converted to regular expressions. Returns information about</a>
<a name="ln634">/// the parsed 'errorformat' option.</a>
<a name="ln635">static efm_T *parse_efm_option(char *efm)</a>
<a name="ln636">{</a>
<a name="ln637">  efm_T *fmt_first = NULL;</a>
<a name="ln638">  efm_T *fmt_last = NULL;</a>
<a name="ln639"> </a>
<a name="ln640">  // Get some space to modify the format string into.</a>
<a name="ln641">  size_t sz = efm_regpat_bufsz(efm);</a>
<a name="ln642">  char *fmtstr = xmalloc(sz);</a>
<a name="ln643"> </a>
<a name="ln644">  while (efm[0] != NUL) {</a>
<a name="ln645">    // Allocate a new eformat structure and put it at the end of the list</a>
<a name="ln646">    efm_T *fmt_ptr = (efm_T *)xcalloc(1, sizeof(efm_T));</a>
<a name="ln647">    if (fmt_first == NULL) {        // first one</a>
<a name="ln648">      fmt_first = fmt_ptr;</a>
<a name="ln649">    } else {</a>
<a name="ln650">      fmt_last-&gt;next = fmt_ptr;</a>
<a name="ln651">    }</a>
<a name="ln652">    fmt_last = fmt_ptr;</a>
<a name="ln653"> </a>
<a name="ln654">    // Isolate one part in the 'errorformat' option</a>
<a name="ln655">    int len = efm_option_part_len(efm);</a>
<a name="ln656"> </a>
<a name="ln657">    if (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL) {</a>
<a name="ln658">      goto parse_efm_error;</a>
<a name="ln659">    }</a>
<a name="ln660">    if ((fmt_ptr-&gt;prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL) {</a>
<a name="ln661">      goto parse_efm_error;</a>
<a name="ln662">    }</a>
<a name="ln663">    // Advance to next part</a>
<a name="ln664">    efm = skip_to_option_part(efm + len);       // skip comma and spaces</a>
<a name="ln665">  }</a>
<a name="ln666"> </a>
<a name="ln667">  if (fmt_first == NULL) {      // nothing found</a>
<a name="ln668">    emsg(_(&quot;E378: 'errorformat' contains no pattern&quot;));</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  goto parse_efm_end;</a>
<a name="ln672"> </a>
<a name="ln673">parse_efm_error:</a>
<a name="ln674">  free_efm_list(&amp;fmt_first);</a>
<a name="ln675"> </a>
<a name="ln676">parse_efm_end:</a>
<a name="ln677">  xfree(fmtstr);</a>
<a name="ln678"> </a>
<a name="ln679">  return fmt_first;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">/// Allocate more memory for the line buffer used for parsing lines.</a>
<a name="ln683">static char *qf_grow_linebuf(qfstate_T *state, size_t newsz)</a>
<a name="ln684">{</a>
<a name="ln685">  // If the line exceeds LINE_MAXLEN exclude the last</a>
<a name="ln686">  // byte since it's not a NL character.</a>
<a name="ln687">  state-&gt;linelen = newsz &gt; LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;</a>
<a name="ln688">  if (state-&gt;growbuf == NULL) {</a>
<a name="ln689">    state-&gt;growbuf = xmalloc(state-&gt;linelen + 1);</a>
<a name="ln690">    state-&gt;growbufsiz = state-&gt;linelen;</a>
<a name="ln691">  } else if (state-&gt;linelen &gt; state-&gt;growbufsiz) {</a>
<a name="ln692">    state-&gt;growbuf = xrealloc(state-&gt;growbuf, state-&gt;linelen + 1);</a>
<a name="ln693">    state-&gt;growbufsiz = state-&gt;linelen;</a>
<a name="ln694">  }</a>
<a name="ln695">  return state-&gt;growbuf;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/// Get the next string (separated by newline) from state-&gt;p_str.</a>
<a name="ln699">static int qf_get_next_str_line(qfstate_T *state)</a>
<a name="ln700">{</a>
<a name="ln701">  // Get the next line from the supplied string</a>
<a name="ln702">  char *p_str = state-&gt;p_str;</a>
<a name="ln703"> </a>
<a name="ln704">  if (*p_str == NUL) {  // Reached the end of the string</a>
<a name="ln705">    return QF_END_OF_INPUT;</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  char *p = vim_strchr(p_str, '\n');</a>
<a name="ln709">  size_t len = (p != NULL) ? (size_t)(p - p_str) + 1 : strlen(p_str);</a>
<a name="ln710"> </a>
<a name="ln711">  if (len &gt; IOSIZE - 2) {</a>
<a name="ln712">    state-&gt;linebuf = qf_grow_linebuf(state, len);</a>
<a name="ln713">  } else {</a>
<a name="ln714">    state-&gt;linebuf = IObuff;</a>
<a name="ln715">    state-&gt;linelen = len;</a>
<a name="ln716">  }</a>
<a name="ln717">  memcpy(state-&gt;linebuf, p_str, state-&gt;linelen);</a>
<a name="ln718">  state-&gt;linebuf[state-&gt;linelen] = '\0';</a>
<a name="ln719"> </a>
<a name="ln720">  // Increment using len in order to discard the rest of the line if it</a>
<a name="ln721">  // exceeds LINE_MAXLEN.</a>
<a name="ln722">  p_str += len;</a>
<a name="ln723">  state-&gt;p_str = p_str;</a>
<a name="ln724"> </a>
<a name="ln725">  return QF_OK;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">/// Get the next string from state-&gt;p_Li.</a>
<a name="ln729">static int qf_get_next_list_line(qfstate_T *state)</a>
<a name="ln730">{</a>
<a name="ln731">  listitem_T *p_li = state-&gt;p_li;</a>
<a name="ln732"> </a>
<a name="ln733">  // Get the next line from the supplied list</a>
<a name="ln734">  while (p_li != NULL</a>
<a name="ln735">         &amp;&amp; (TV_LIST_ITEM_TV(p_li)-&gt;v_type != VAR_STRING</a>
<a name="ln736">             || TV_LIST_ITEM_TV(p_li)-&gt;vval.v_string == NULL)) {</a>
<a name="ln737">    p_li = TV_LIST_ITEM_NEXT(state-&gt;p_list, p_li);  // Skip non-string items.</a>
<a name="ln738">  }</a>
<a name="ln739"> </a>
<a name="ln740">  if (p_li == NULL) {  // End of the list.</a>
<a name="ln741">    state-&gt;p_li = NULL;</a>
<a name="ln742">    return QF_END_OF_INPUT;</a>
<a name="ln743">  }</a>
<a name="ln744"> </a>
<a name="ln745">  size_t len = strlen(TV_LIST_ITEM_TV(p_li)-&gt;vval.v_string);</a>
<a name="ln746">  if (len &gt; IOSIZE - 2) {</a>
<a name="ln747">    state-&gt;linebuf = qf_grow_linebuf(state, len);</a>
<a name="ln748">  } else {</a>
<a name="ln749">    state-&gt;linebuf = IObuff;</a>
<a name="ln750">    state-&gt;linelen = len;</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  xstrlcpy(state-&gt;linebuf, TV_LIST_ITEM_TV(p_li)-&gt;vval.v_string,</a>
<a name="ln754">           state-&gt;linelen + 1);</a>
<a name="ln755"> </a>
<a name="ln756">  state-&gt;p_li = TV_LIST_ITEM_NEXT(state-&gt;p_list, p_li);</a>
<a name="ln757">  return QF_OK;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">/// Get the next string from state-&gt;buf.</a>
<a name="ln761">static int qf_get_next_buf_line(qfstate_T *state)</a>
<a name="ln762">{</a>
<a name="ln763">  // Get the next line from the supplied buffer</a>
<a name="ln764">  if (state-&gt;buflnum &gt; state-&gt;lnumlast) {</a>
<a name="ln765">    return QF_END_OF_INPUT;</a>
<a name="ln766">  }</a>
<a name="ln767">  char *p_buf = ml_get_buf(state-&gt;buf, state-&gt;buflnum);</a>
<a name="ln768">  state-&gt;buflnum += 1;</a>
<a name="ln769"> </a>
<a name="ln770">  size_t len = strlen(p_buf);</a>
<a name="ln771">  if (len &gt; IOSIZE - 2) {</a>
<a name="ln772">    state-&gt;linebuf = qf_grow_linebuf(state, len);</a>
<a name="ln773">  } else {</a>
<a name="ln774">    state-&gt;linebuf = IObuff;</a>
<a name="ln775">    state-&gt;linelen = len;</a>
<a name="ln776">  }</a>
<a name="ln777">  xstrlcpy(state-&gt;linebuf, p_buf, state-&gt;linelen + 1);</a>
<a name="ln778"> </a>
<a name="ln779">  return QF_OK;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">/// Get the next string from file state-&gt;fd.</a>
<a name="ln783">static int qf_get_next_file_line(qfstate_T *state)</a>
<a name="ln784">{</a>
<a name="ln785">retry:</a>
<a name="ln786">  errno = 0;</a>
<a name="ln787">  if (fgets(IObuff, IOSIZE, state-&gt;fd) == NULL) {</a>
<a name="ln788">    if (errno == EINTR) {</a>
<a name="ln789">      goto retry;</a>
<a name="ln790">    }</a>
<a name="ln791">    return QF_END_OF_INPUT;</a>
<a name="ln792">  }</a>
<a name="ln793"> </a>
<a name="ln794">  bool discard = false;</a>
<a name="ln795">  state-&gt;linelen = strlen(IObuff);</a>
<a name="ln796">  if (state-&gt;linelen == IOSIZE - 1</a>
<a name="ln797">      &amp;&amp; !(IObuff[state-&gt;linelen - 1] == '\n')) {</a>
<a name="ln798">    // The current line exceeds IObuff, continue reading using growbuf</a>
<a name="ln799">    // until EOL or LINE_MAXLEN bytes is read.</a>
<a name="ln800">    if (state-&gt;growbuf == NULL) {</a>
<a name="ln801">      state-&gt;growbufsiz = 2 * (IOSIZE - 1);</a>
<a name="ln802">      state-&gt;growbuf = xmalloc(state-&gt;growbufsiz);</a>
<a name="ln803">    }</a>
<a name="ln804"> </a>
<a name="ln805">    // Copy the read part of the line, excluding null-terminator</a>
<a name="ln806">    memcpy(state-&gt;growbuf, IObuff, IOSIZE - 1);</a>
<a name="ln807">    size_t growbuflen = state-&gt;linelen;</a>
<a name="ln808"> </a>
<a name="ln809">    while (true) {</a>
<a name="ln810">      errno = 0;</a>
<a name="ln811">      if (fgets(state-&gt;growbuf + growbuflen,</a>
<a name="ln812">                (int)(state-&gt;growbufsiz - growbuflen), state-&gt;fd) == NULL) {</a>
<a name="ln813">        if (errno == EINTR) {</a>
<a name="ln814">          continue;</a>
<a name="ln815">        }</a>
<a name="ln816">        break;</a>
<a name="ln817">      }</a>
<a name="ln818">      state-&gt;linelen = strlen(state-&gt;growbuf + growbuflen);</a>
<a name="ln819">      growbuflen += state-&gt;linelen;</a>
<a name="ln820">      if (state-&gt;growbuf[growbuflen - 1] == '\n') {</a>
<a name="ln821">        break;</a>
<a name="ln822">      }</a>
<a name="ln823">      if (state-&gt;growbufsiz == LINE_MAXLEN) {</a>
<a name="ln824">        discard = true;</a>
<a name="ln825">        break;</a>
<a name="ln826">      }</a>
<a name="ln827"> </a>
<a name="ln828">      state-&gt;growbufsiz = (2 * state-&gt;growbufsiz &lt; LINE_MAXLEN)</a>
<a name="ln829">        ? 2 * state-&gt;growbufsiz : LINE_MAXLEN;</a>
<a name="ln830">      state-&gt;growbuf = xrealloc(state-&gt;growbuf, state-&gt;growbufsiz);</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">    while (discard) {</a>
<a name="ln834">      // The current line is longer than LINE_MAXLEN, continue reading but</a>
<a name="ln835">      // discard everything until EOL or EOF is reached.</a>
<a name="ln836">      errno = 0;</a>
<a name="ln837">      if (fgets(IObuff, IOSIZE, state-&gt;fd) == NULL) {</a>
<a name="ln838">        if (errno == EINTR) {</a>
<a name="ln839">          continue;</a>
<a name="ln840">        }</a>
<a name="ln841">        break;</a>
<a name="ln842">      }</a>
<a name="ln843">      if (strlen(IObuff) &lt; IOSIZE - 1 || IObuff[IOSIZE - 2] == '\n') {</a>
<a name="ln844">        break;</a>
<a name="ln845">      }</a>
<a name="ln846">    }</a>
<a name="ln847"> </a>
<a name="ln848">    state-&gt;linebuf = state-&gt;growbuf;</a>
<a name="ln849">    state-&gt;linelen = growbuflen;</a>
<a name="ln850">  } else {</a>
<a name="ln851">    state-&gt;linebuf = IObuff;</a>
<a name="ln852">  }</a>
<a name="ln853"> </a>
<a name="ln854">  // Convert a line if it contains a non-ASCII character</a>
<a name="ln855">  if (state-&gt;vc.vc_type != CONV_NONE &amp;&amp; has_non_ascii(state-&gt;linebuf)) {</a>
<a name="ln856">    char *line = string_convert(&amp;state-&gt;vc, state-&gt;linebuf, &amp;state-&gt;linelen);</a>
<a name="ln857">    if (line != NULL) {</a>
<a name="ln858">      if (state-&gt;linelen &lt; IOSIZE) {</a>
<a name="ln859">        xstrlcpy(state-&gt;linebuf, line, state-&gt;linelen + 1);</a>
<a name="ln860">        xfree(line);</a>
<a name="ln861">      } else {</a>
<a name="ln862">        xfree(state-&gt;growbuf);</a>
<a name="ln863">        state-&gt;linebuf = line;</a>
<a name="ln864">        state-&gt;growbuf = line;</a>
<a name="ln865">        state-&gt;growbufsiz = state-&gt;linelen &lt; LINE_MAXLEN</a>
<a name="ln866">          ? state-&gt;linelen : LINE_MAXLEN;</a>
<a name="ln867">      }</a>
<a name="ln868">    }</a>
<a name="ln869">  }</a>
<a name="ln870">  return QF_OK;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// Get the next string from a file/buffer/list/string.</a>
<a name="ln874">static int qf_get_nextline(qfstate_T *state)</a>
<a name="ln875">{</a>
<a name="ln876">  int status = QF_FAIL;</a>
<a name="ln877"> </a>
<a name="ln878">  if (state-&gt;fd == NULL) {</a>
<a name="ln879">    if (state-&gt;tv != NULL) {</a>
<a name="ln880">      if (state-&gt;tv-&gt;v_type == VAR_STRING) {</a>
<a name="ln881">        // Get the next line from the supplied string</a>
<a name="ln882">        status = qf_get_next_str_line(state);</a>
<a name="ln883">      } else if (state-&gt;tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln884">        // Get the next line from the supplied list</a>
<a name="ln885">        status = qf_get_next_list_line(state);</a>
<a name="ln886">      }</a>
<a name="ln887">    } else {</a>
<a name="ln888">      // Get the next line from the supplied buffer</a>
<a name="ln889">      status = qf_get_next_buf_line(state);</a>
<a name="ln890">    }</a>
<a name="ln891">  } else {</a>
<a name="ln892">    // Get the next line from the supplied file</a>
<a name="ln893">    status = qf_get_next_file_line(state);</a>
<a name="ln894">  }</a>
<a name="ln895"> </a>
<a name="ln896">  if (status != QF_OK) {</a>
<a name="ln897">    return status;</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  if (state-&gt;linelen &gt; 0 &amp;&amp; state-&gt;linebuf[state-&gt;linelen - 1] == '\n') {</a>
<a name="ln901">    state-&gt;linebuf[state-&gt;linelen - 1] = NUL;</a>
<a name="ln902">#ifdef USE_CRNL</a>
<a name="ln903">    if (state-&gt;linelen &gt; 1 &amp;&amp; state-&gt;linebuf[state-&gt;linelen - 2] == '\r') {</a>
<a name="ln904">      state-&gt;linebuf[state-&gt;linelen - 2] = NUL;</a>
<a name="ln905">    }</a>
<a name="ln906">#endif</a>
<a name="ln907">  }</a>
<a name="ln908"> </a>
<a name="ln909">  remove_bom(state-&gt;linebuf);</a>
<a name="ln910"> </a>
<a name="ln911">  return QF_OK;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">/// Returns true if the specified quickfix/location stack is empty</a>
<a name="ln915">static bool qf_stack_empty(const qf_info_T *qi)</a>
<a name="ln916">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln917">{</a>
<a name="ln918">  return qi == NULL || qi-&gt;qf_listcount &lt;= 0;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">/// Returns true if the specified quickfix/location list is empty.</a>
<a name="ln922">static bool qf_list_empty(qf_list_T *qfl)</a>
<a name="ln923">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln924">{</a>
<a name="ln925">  return qfl == NULL || qfl-&gt;qf_count &lt;= 0;</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">/// Returns true if the specified quickfix/location list is not empty and</a>
<a name="ln929">/// has valid entries.</a>
<a name="ln930">static bool qf_list_has_valid_entries(qf_list_T *qfl)</a>
<a name="ln931">{</a>
<a name="ln932">  return !qf_list_empty(qfl) &amp;&amp; !qfl-&gt;qf_nonevalid;</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">/// Return a pointer to a list in the specified quickfix stack</a>
<a name="ln936">static qf_list_T *qf_get_list(qf_info_T *qi, int idx)</a>
<a name="ln937">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln938">{</a>
<a name="ln939">  return &amp;qi-&gt;qf_lists[idx];</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">/// Parse a line and get the quickfix fields.</a>
<a name="ln943">/// Return the QF_ status.</a>
<a name="ln944">static int qf_parse_line(qf_list_T *qfl, char *linebuf, size_t linelen, efm_T *fmt_first,</a>
<a name="ln945">                         qffields_T *fields)</a>
<a name="ln946">{</a>
<a name="ln947">  efm_T *fmt_ptr;</a>
<a name="ln948">  int idx = 0;</a>
<a name="ln949">  char *tail = NULL;</a>
<a name="ln950">  int status;</a>
<a name="ln951"> </a>
<a name="ln952">restofline:</a>
<a name="ln953">  // If there was no %&gt; item start at the first pattern</a>
<a name="ln954">  if (fmt_start == NULL) {</a>
<a name="ln955">    fmt_ptr = fmt_first;</a>
<a name="ln956">  } else {</a>
<a name="ln957">    // Otherwise start from the last used pattern.</a>
<a name="ln958">    fmt_ptr = fmt_start;</a>
<a name="ln959">    fmt_start = NULL;</a>
<a name="ln960">  }</a>
<a name="ln961"> </a>
<a name="ln962">  // Try to match each part of 'errorformat' until we find a complete</a>
<a name="ln963">  // match or no match.</a>
<a name="ln964">  fields-&gt;valid = true;</a>
<a name="ln965">  for (; fmt_ptr != NULL; fmt_ptr = fmt_ptr-&gt;next) {</a>
<a name="ln966">    idx = (uint8_t)fmt_ptr-&gt;prefix;</a>
<a name="ln967">    status = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,</a>
<a name="ln968">                                 qfl-&gt;qf_multiline, qfl-&gt;qf_multiscan,</a>
<a name="ln969">                                 &amp;tail);</a>
<a name="ln970">    if (status == QF_NOMEM) {</a>
<a name="ln971">      return status;</a>
<a name="ln972">    }</a>
<a name="ln973">    if (status == QF_OK) {</a>
<a name="ln974">      break;</a>
<a name="ln975">    }</a>
<a name="ln976">  }</a>
<a name="ln977">  qfl-&gt;qf_multiscan = false;</a>
<a name="ln978"> </a>
<a name="ln979">  if (fmt_ptr == NULL || idx == 'D' || idx == 'X') {</a>
<a name="ln980">    if (fmt_ptr != NULL) {</a>
<a name="ln981">      // 'D' and 'X' directory specifiers.</a>
<a name="ln982">      status = qf_parse_dir_pfx(idx, fields, qfl);</a>
<a name="ln983">      if (status != QF_OK) {</a>
<a name="ln984">        return status;</a>
<a name="ln985">      }</a>
<a name="ln986">    }</a>
<a name="ln987">    status = qf_parse_line_nomatch(linebuf, linelen, fields);</a>
<a name="ln988">    if (status != QF_OK) {</a>
<a name="ln989">      return status;</a>
<a name="ln990">    }</a>
<a name="ln991">    if (fmt_ptr == NULL) {</a>
<a name="ln992">      qfl-&gt;qf_multiline = qfl-&gt;qf_multiignore = false;</a>
<a name="ln993">    }</a>
<a name="ln994">  } else {</a>
<a name="ln995">    // honor %&gt; item</a>
<a name="ln996">    if (fmt_ptr-&gt;conthere) {</a>
<a name="ln997">      fmt_start = fmt_ptr;</a>
<a name="ln998">    }</a>
<a name="ln999"> </a>
<a name="ln1000">    if (vim_strchr(&quot;AEWIN&quot;, idx) != NULL) {</a>
<a name="ln1001">      qfl-&gt;qf_multiline = true;     // start of a multi-line message</a>
<a name="ln1002">      qfl-&gt;qf_multiignore = false;  // reset continuation</a>
<a name="ln1003">    } else if (vim_strchr(&quot;CZ&quot;, idx) != NULL) {</a>
<a name="ln1004">      // continuation of multi-line msg</a>
<a name="ln1005">      status = qf_parse_multiline_pfx(idx, qfl, fields);</a>
<a name="ln1006">      if (status != QF_OK) {</a>
<a name="ln1007">        return status;</a>
<a name="ln1008">      }</a>
<a name="ln1009">    } else if (vim_strchr(&quot;OPQ&quot;, idx) != NULL) {</a>
<a name="ln1010">      // global file names</a>
<a name="ln1011">      status = qf_parse_file_pfx(idx, fields, qfl, tail);</a>
<a name="ln1012">      if (status == QF_MULTISCAN) {</a>
<a name="ln1013">        goto restofline;</a>
<a name="ln1014">      }</a>
<a name="ln1015">    }</a>
<a name="ln1016">    if (fmt_ptr-&gt;flags == '-') {  // generally exclude this line</a>
<a name="ln1017">      if (qfl-&gt;qf_multiline) {</a>
<a name="ln1018">        // also exclude continuation lines</a>
<a name="ln1019">        qfl-&gt;qf_multiignore = true;</a>
<a name="ln1020">      }</a>
<a name="ln1021">      return QF_IGNORE_LINE;</a>
<a name="ln1022">    }</a>
<a name="ln1023">  }</a>
<a name="ln1024"> </a>
<a name="ln1025">  return QF_OK;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">// Allocate the fields used for parsing lines and populating a quickfix list.</a>
<a name="ln1029">static void qf_alloc_fields(qffields_T *pfields)</a>
<a name="ln1030">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1031">{</a>
<a name="ln1032">  pfields-&gt;namebuf = xmalloc(CMDBUFFSIZE + 1);</a>
<a name="ln1033">  pfields-&gt;module = xmalloc(CMDBUFFSIZE + 1);</a>
<a name="ln1034">  pfields-&gt;errmsglen = CMDBUFFSIZE + 1;</a>
<a name="ln1035">  pfields-&gt;errmsg = xmalloc(pfields-&gt;errmsglen);</a>
<a name="ln1036">  pfields-&gt;pattern = xmalloc(CMDBUFFSIZE + 1);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">// Free the fields used for parsing lines and populating a quickfix list.</a>
<a name="ln1040">static void qf_free_fields(qffields_T *pfields)</a>
<a name="ln1041">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1042">{</a>
<a name="ln1043">  xfree(pfields-&gt;namebuf);</a>
<a name="ln1044">  xfree(pfields-&gt;module);</a>
<a name="ln1045">  xfree(pfields-&gt;errmsg);</a>
<a name="ln1046">  xfree(pfields-&gt;pattern);</a>
<a name="ln1047">}</a>
<a name="ln1048"> </a>
<a name="ln1049">// Setup the state information used for parsing lines and populating a</a>
<a name="ln1050">// quickfix list.</a>
<a name="ln1051">static int qf_setup_state(qfstate_T *pstate, char *restrict enc, const char *restrict efile,</a>
<a name="ln1052">                          typval_T *tv, buf_T *buf, linenr_T lnumfirst, linenr_T lnumlast)</a>
<a name="ln1053">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1054">{</a>
<a name="ln1055">  pstate-&gt;vc.vc_type = CONV_NONE;</a>
<a name="ln1056">  if (enc != NULL &amp;&amp; *enc != NUL) {</a>
<a name="ln1057">    convert_setup(&amp;pstate-&gt;vc, enc, p_enc);</a>
<a name="ln1058">  }</a>
<a name="ln1059"> </a>
<a name="ln1060">  if (efile != NULL</a>
<a name="ln1061">      &amp;&amp; (pstate-&gt;fd = os_fopen(efile, &quot;r&quot;)) == NULL) {</a>
<a name="ln1062">    semsg(_(e_openerrf), efile);</a>
<a name="ln1063">    return FAIL;</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066">  if (tv != NULL) {</a>
<a name="ln1067">    if (tv-&gt;v_type == VAR_STRING) {</a>
<a name="ln1068">      pstate-&gt;p_str = tv-&gt;vval.v_string;</a>
<a name="ln1069">    } else if (tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln1070">      pstate-&gt;p_li = tv_list_first(tv-&gt;vval.v_list);</a>
<a name="ln1071">    }</a>
<a name="ln1072">    pstate-&gt;tv = tv;</a>
<a name="ln1073">  }</a>
<a name="ln1074">  pstate-&gt;buf = buf;</a>
<a name="ln1075">  pstate-&gt;buflnum = lnumfirst;</a>
<a name="ln1076">  pstate-&gt;lnumlast = lnumlast;</a>
<a name="ln1077"> </a>
<a name="ln1078">  return OK;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">// Cleanup the state information used for parsing lines and populating a</a>
<a name="ln1082">// quickfix list.</a>
<a name="ln1083">static void qf_cleanup_state(qfstate_T *pstate)</a>
<a name="ln1084">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1085">{</a>
<a name="ln1086">  if (pstate-&gt;fd != NULL) {</a>
<a name="ln1087">    fclose(pstate-&gt;fd);</a>
<a name="ln1088">  }</a>
<a name="ln1089">  xfree(pstate-&gt;growbuf);</a>
<a name="ln1090">  if (pstate-&gt;vc.vc_type != CONV_NONE) {</a>
<a name="ln1091">    convert_setup(&amp;pstate-&gt;vc, NULL, NULL);</a>
<a name="ln1092">  }</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">/// Read the errorfile &quot;efile&quot; into memory, line by line, building the error</a>
<a name="ln1096">/// list.</a>
<a name="ln1097">/// Alternative: when &quot;efile&quot; is NULL read errors from buffer &quot;buf&quot;.</a>
<a name="ln1098">/// Alternative: when &quot;tv&quot; is not NULL get errors from the string or list.</a>
<a name="ln1099">/// Always use 'errorformat' from &quot;buf&quot; if there is a local value.</a>
<a name="ln1100">/// Then &quot;lnumfirst&quot; and &quot;lnumlast&quot; specify the range of lines to use.</a>
<a name="ln1101">/// Set the title of the list to &quot;qf_title&quot;.</a>
<a name="ln1102">///</a>
<a name="ln1103">/// @param newlist  true: start a new error list</a>
<a name="ln1104">/// @param lnumfirst  first line number to use</a>
<a name="ln1105">/// @param lnumlast  last line number to use</a>
<a name="ln1106">///</a>
<a name="ln1107">/// @return  -1 for error, number of errors for success.</a>
<a name="ln1108">static int qf_init_ext(qf_info_T *qi, int qf_idx, const char *restrict efile, buf_T *buf,</a>
<a name="ln1109">                       typval_T *tv, char *restrict errorformat, bool newlist, linenr_T lnumfirst,</a>
<a name="ln1110">                       linenr_T lnumlast, const char *restrict qf_title, char *restrict enc)</a>
<a name="ln1111">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1112">{</a>
<a name="ln1113">  qfstate_T state = { 0 };</a>
<a name="ln1114">  qffields_T fields = { 0 };</a>
<a name="ln1115">  qfline_T *old_last = NULL;</a>
<a name="ln1116">  static efm_T *fmt_first = NULL;</a>
<a name="ln1117">  static char *last_efm = NULL;</a>
<a name="ln1118">  int retval = -1;                      // default: return error flag</a>
<a name="ln1119"> </a>
<a name="ln1120">  // Do not used the cached buffer, it may have been wiped out.</a>
<a name="ln1121">  XFREE_CLEAR(qf_last_bufname);</a>
<a name="ln1122"> </a>
<a name="ln1123">  qf_alloc_fields(&amp;fields);</a>
<a name="ln1124">  if (qf_setup_state(&amp;state, enc, efile, tv, buf, lnumfirst, lnumlast) == FAIL) {</a>
<a name="ln1125">    goto qf_init_end;</a>
<a name="ln1126">  }</a>
<a name="ln1127"> </a>
<a name="ln1128">  qf_list_T *qfl;</a>
<a name="ln1129">  bool adding = false;</a>
<a name="ln1130">  if (newlist || qf_idx == qi-&gt;qf_listcount) {</a>
<a name="ln1131">    // make place for a new list</a>
<a name="ln1132">    qf_new_list(qi, qf_title);</a>
<a name="ln1133">    qf_idx = qi-&gt;qf_curlist;</a>
<a name="ln1134">    qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln1135">  } else {</a>
<a name="ln1136">    // Adding to existing list, use last entry.</a>
<a name="ln1137">    adding = true;</a>
<a name="ln1138">    qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln1139">    if (!qf_list_empty(qfl)) {</a>
<a name="ln1140">      old_last = qfl-&gt;qf_last;</a>
<a name="ln1141">    }</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  char *efm;</a>
<a name="ln1145"> </a>
<a name="ln1146">  // Use the local value of 'errorformat' if it's set.</a>
<a name="ln1147">  if (errorformat == p_efm &amp;&amp; tv == NULL &amp;&amp; buf &amp;&amp; *buf-&gt;b_p_efm != NUL) {</a>
<a name="ln1148">    efm = buf-&gt;b_p_efm;</a>
<a name="ln1149">  } else {</a>
<a name="ln1150">    efm = errorformat;</a>
<a name="ln1151">  }</a>
<a name="ln1152"> </a>
<a name="ln1153">  // If the errorformat didn't change between calls, then reuse the previously</a>
<a name="ln1154">  // parsed values.</a>
<a name="ln1155">  if (last_efm == NULL || (strcmp(last_efm, efm) != 0)) {</a>
<a name="ln1156">    // free the previously parsed data</a>
<a name="ln1157">    XFREE_CLEAR(last_efm);</a>
<a name="ln1158">    free_efm_list(&amp;fmt_first);</a>
<a name="ln1159"> </a>
<a name="ln1160">    // parse the current 'efm'</a>
<a name="ln1161">    fmt_first = parse_efm_option(efm);</a>
<a name="ln1162">    if (fmt_first != NULL) {</a>
<a name="ln1163">      last_efm = xstrdup(efm);</a>
<a name="ln1164">    }</a>
<a name="ln1165">  }</a>
<a name="ln1166"> </a>
<a name="ln1167">  if (fmt_first == NULL) {      // nothing found</a>
<a name="ln1168">    goto error2;</a>
<a name="ln1169">  }</a>
<a name="ln1170"> </a>
<a name="ln1171">  // got_int is reset here, because it was probably set when killing the</a>
<a name="ln1172">  // &quot;:make&quot; command, but we still want to read the errorfile then.</a>
<a name="ln1173">  got_int = false;</a>
<a name="ln1174"> </a>
<a name="ln1175">  // Read the lines in the error file one by one.</a>
<a name="ln1176">  // Try to recognize one of the error formats in each line.</a>
<a name="ln1177">  while (!got_int) {</a>
<a name="ln1178">    int status = qf_init_process_nextline(qfl, fmt_first, &amp;state, &amp;fields);</a>
<a name="ln1179">    if (status == QF_END_OF_INPUT) {  // end of input</a>
<a name="ln1180">      break;</a>
<a name="ln1181">    }</a>
<a name="ln1182">    if (status == QF_FAIL) {</a>
<a name="ln1183">      goto error2;</a>
<a name="ln1184">    }</a>
<a name="ln1185"> </a>
<a name="ln1186">    line_breakcheck();</a>
<a name="ln1187">  }</a>
<a name="ln1188">  if (state.fd == NULL || !ferror(state.fd)) {</a>
<a name="ln1189">    if (qfl-&gt;qf_index == 0) {</a>
<a name="ln1190">      // no valid entry found</a>
<a name="ln1191">      qfl-&gt;qf_ptr = qfl-&gt;qf_start;</a>
<a name="ln1192">      qfl-&gt;qf_index = 1;</a>
<a name="ln1193">      qfl-&gt;qf_nonevalid = true;</a>
<a name="ln1194">    } else {</a>
<a name="ln1195">      qfl-&gt;qf_nonevalid = false;</a>
<a name="ln1196">      if (qfl-&gt;qf_ptr == NULL) {</a>
<a name="ln1197">        qfl-&gt;qf_ptr = qfl-&gt;qf_start;</a>
<a name="ln1198">      }</a>
<a name="ln1199">    }</a>
<a name="ln1200">    // return number of matches</a>
<a name="ln1201">    retval = qfl-&gt;qf_count;</a>
<a name="ln1202">    goto qf_init_end;</a>
<a name="ln1203">  }</a>
<a name="ln1204">  emsg(_(e_readerrf));</a>
<a name="ln1205">error2:</a>
<a name="ln1206">  if (!adding) {</a>
<a name="ln1207">    // Error when creating a new list. Free the new list</a>
<a name="ln1208">    qf_free(qfl);</a>
<a name="ln1209">    qi-&gt;qf_listcount--;</a>
<a name="ln1210">    if (qi-&gt;qf_curlist &gt; 0) {</a>
<a name="ln1211">      qi-&gt;qf_curlist--;</a>
<a name="ln1212">    }</a>
<a name="ln1213">  }</a>
<a name="ln1214">qf_init_end:</a>
<a name="ln1215">  if (qf_idx == qi-&gt;qf_curlist) {</a>
<a name="ln1216">    qf_update_buffer(qi, old_last);</a>
<a name="ln1217">  }</a>
<a name="ln1218">  qf_cleanup_state(&amp;state);</a>
<a name="ln1219">  qf_free_fields(&amp;fields);</a>
<a name="ln1220"> </a>
<a name="ln1221">  return retval;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">/// Set the title of the specified quickfix list. Frees the previous title.</a>
<a name="ln1225">/// Prepends ':' to the title.</a>
<a name="ln1226">static void qf_store_title(qf_list_T *qfl, const char *title)</a>
<a name="ln1227">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1228">{</a>
<a name="ln1229">  XFREE_CLEAR(qfl-&gt;qf_title);</a>
<a name="ln1230"> </a>
<a name="ln1231">  if (title == NULL) {</a>
<a name="ln1232">    return;</a>
<a name="ln1233">  }</a>
<a name="ln1234"> </a>
<a name="ln1235">  size_t len = strlen(title) + 1;</a>
<a name="ln1236">  char *p = xmallocz(len);</a>
<a name="ln1237"> </a>
<a name="ln1238">  qfl-&gt;qf_title = p;</a>
<a name="ln1239">  xstrlcpy(p, title, len + 1);</a>
<a name="ln1240">}</a>
<a name="ln1241"> </a>
<a name="ln1242">/// The title of a quickfix/location list is set, by default, to the command</a>
<a name="ln1243">/// that created the quickfix list with the &quot;:&quot; prefix.</a>
<a name="ln1244">/// Create a quickfix list title string by prepending &quot;:&quot; to a user command.</a>
<a name="ln1245">/// Returns a pointer to a static buffer with the title.</a>
<a name="ln1246">static char *qf_cmdtitle(char *cmd)</a>
<a name="ln1247">{</a>
<a name="ln1248">  static char qftitle_str[IOSIZE];</a>
<a name="ln1249"> </a>
<a name="ln1250">  snprintf(qftitle_str, IOSIZE, &quot;:%s&quot;, cmd);</a>
<a name="ln1251"> </a>
<a name="ln1252">  return qftitle_str;</a>
<a name="ln1253">}</a>
<a name="ln1254"> </a>
<a name="ln1255">/// Return a pointer to the current list in the specified quickfix stack</a>
<a name="ln1256">static qf_list_T *qf_get_curlist(qf_info_T *qi)</a>
<a name="ln1257">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1258">{</a>
<a name="ln1259">  return qf_get_list(qi, qi-&gt;qf_curlist);</a>
<a name="ln1260">}</a>
<a name="ln1261"> </a>
<a name="ln1262">/// Prepare for adding a new quickfix list. If the current list is in the</a>
<a name="ln1263">/// middle of the stack, then all the following lists are freed and then</a>
<a name="ln1264">/// the new list is added.</a>
<a name="ln1265">static void qf_new_list(qf_info_T *qi, const char *qf_title)</a>
<a name="ln1266">{</a>
<a name="ln1267">  // If the current entry is not the last entry, delete entries beyond</a>
<a name="ln1268">  // the current entry.  This makes it possible to browse in a tree-like</a>
<a name="ln1269">  // way with &quot;:grep&quot;.</a>
<a name="ln1270">  while (qi-&gt;qf_listcount &gt; qi-&gt;qf_curlist + 1) {</a>
<a name="ln1271">    qf_free(&amp;qi-&gt;qf_lists[--qi-&gt;qf_listcount]);</a>
<a name="ln1272">  }</a>
<a name="ln1273"> </a>
<a name="ln1274">  // When the stack is full, remove to oldest entry</a>
<a name="ln1275">  // Otherwise, add a new entry.</a>
<a name="ln1276">  if (qi-&gt;qf_listcount == LISTCOUNT) {</a>
<a name="ln1277">    qf_free(&amp;qi-&gt;qf_lists[0]);</a>
<a name="ln1278">    for (int i = 1; i &lt; LISTCOUNT; i++) {</a>
<a name="ln1279">      qi-&gt;qf_lists[i - 1] = qi-&gt;qf_lists[i];</a>
<a name="ln1280">    }</a>
<a name="ln1281">    qi-&gt;qf_curlist = LISTCOUNT - 1;</a>
<a name="ln1282">  } else {</a>
<a name="ln1283">    qi-&gt;qf_curlist = qi-&gt;qf_listcount++;</a>
<a name="ln1284">  }</a>
<a name="ln1285">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln1286">  CLEAR_POINTER(qfl);</a>
<a name="ln1287">  qf_store_title(qfl, qf_title);</a>
<a name="ln1288">  qfl-&gt;qfl_type = qi-&gt;qfl_type;</a>
<a name="ln1289">  qfl-&gt;qf_id = ++last_qf_id;</a>
<a name="ln1290">  qfl-&gt;qf_has_user_data = false;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">/// Parse the match for filename ('%f') pattern in regmatch.</a>
<a name="ln1294">/// Return the matched value in &quot;fields-&gt;namebuf&quot;.</a>
<a name="ln1295">static int qf_parse_fmt_f(regmatch_T *rmp, int midx, qffields_T *fields, int prefix)</a>
<a name="ln1296">{</a>
<a name="ln1297">  if (rmp-&gt;startp[midx] == NULL || rmp-&gt;endp[midx] == NULL) {</a>
<a name="ln1298">    return QF_FAIL;</a>
<a name="ln1299">  }</a>
<a name="ln1300"> </a>
<a name="ln1301">  // Expand ~/file and $HOME/file to full path.</a>
<a name="ln1302">  char c = *rmp-&gt;endp[midx];</a>
<a name="ln1303">  *rmp-&gt;endp[midx] = NUL;</a>
<a name="ln1304">  expand_env(rmp-&gt;startp[midx], fields-&gt;namebuf, CMDBUFFSIZE);</a>
<a name="ln1305">  *rmp-&gt;endp[midx] = c;</a>
<a name="ln1306"> </a>
<a name="ln1307">  // For separate filename patterns (%O, %P and %Q), the specified file</a>
<a name="ln1308">  // should exist.</a>
<a name="ln1309">  if (vim_strchr(&quot;OPQ&quot;, prefix) != NULL</a>
<a name="ln1310">      &amp;&amp; !os_path_exists(fields-&gt;namebuf)) {</a>
<a name="ln1311">    return QF_FAIL;</a>
<a name="ln1312">  }</a>
<a name="ln1313"> </a>
<a name="ln1314">  return QF_OK;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">/// Parse the match for buffer number ('%b') pattern in regmatch.</a>
<a name="ln1318">/// Return the matched value in &quot;fields-&gt;bnr&quot;.</a>
<a name="ln1319">static int qf_parse_fmt_b(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1320">{</a>
<a name="ln1321">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1322">    return QF_FAIL;</a>
<a name="ln1323">  }</a>
<a name="ln1324">  int bnr = (int)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1325">  if (buflist_findnr(bnr) == NULL) {</a>
<a name="ln1326">    return QF_FAIL;</a>
<a name="ln1327">  }</a>
<a name="ln1328">  fields-&gt;bnr = bnr;</a>
<a name="ln1329">  return QF_OK;</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">/// Parse the match for error number ('%n') pattern in regmatch.</a>
<a name="ln1333">/// Return the matched value in &quot;fields-&gt;enr&quot;.</a>
<a name="ln1334">static int qf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1335">{</a>
<a name="ln1336">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1337">    return QF_FAIL;</a>
<a name="ln1338">  }</a>
<a name="ln1339">  fields-&gt;enr = (int)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1340">  return QF_OK;</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">/// Parse the match for line number ('%l') pattern in regmatch.</a>
<a name="ln1344">/// Return the matched value in &quot;fields-&gt;lnum&quot;.</a>
<a name="ln1345">static int qf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1346">{</a>
<a name="ln1347">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1348">    return QF_FAIL;</a>
<a name="ln1349">  }</a>
<a name="ln1350">  fields-&gt;lnum = (linenr_T)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1351">  return QF_OK;</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354">/// Parse the match for end line number ('%e') pattern in regmatch.</a>
<a name="ln1355">/// Return the matched value in &quot;fields-&gt;end_lnum&quot;.</a>
<a name="ln1356">static int qf_parse_fmt_e(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1357">{</a>
<a name="ln1358">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1359">    return QF_FAIL;</a>
<a name="ln1360">  }</a>
<a name="ln1361">  fields-&gt;end_lnum = (linenr_T)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1362">  return QF_OK;</a>
<a name="ln1363">}</a>
<a name="ln1364"> </a>
<a name="ln1365">/// Parse the match for column number ('%c') pattern in regmatch.</a>
<a name="ln1366">/// Return the matched value in &quot;fields-&gt;col&quot;.</a>
<a name="ln1367">static int qf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1368">{</a>
<a name="ln1369">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1370">    return QF_FAIL;</a>
<a name="ln1371">  }</a>
<a name="ln1372">  fields-&gt;col = (int)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1373">  return QF_OK;</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">/// Parse the match for end line number ('%e') pattern in regmatch.</a>
<a name="ln1377">/// Return the matched value in &quot;fields-&gt;end_lnum&quot;.</a>
<a name="ln1378">static int qf_parse_fmt_k(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1379">{</a>
<a name="ln1380">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1381">    return QF_FAIL;</a>
<a name="ln1382">  }</a>
<a name="ln1383">  fields-&gt;end_col = (int)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1384">  return QF_OK;</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">/// Parse the match for error type ('%t') pattern in regmatch.</a>
<a name="ln1388">/// Return the matched value in &quot;fields-&gt;type&quot;.</a>
<a name="ln1389">static int qf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1390">{</a>
<a name="ln1391">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1392">    return QF_FAIL;</a>
<a name="ln1393">  }</a>
<a name="ln1394">  fields-&gt;type = *rmp-&gt;startp[midx];</a>
<a name="ln1395">  return QF_OK;</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">/// Copy a non-error line into the error string.  Return the matched line in</a>
<a name="ln1399">/// &quot;fields-&gt;errmsg&quot;.</a>
<a name="ln1400">static int copy_nonerror_line(const char *linebuf, size_t linelen, qffields_T *fields)</a>
<a name="ln1401">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1402">{</a>
<a name="ln1403">  if (linelen &gt;= fields-&gt;errmsglen) {</a>
<a name="ln1404">    // linelen + null terminator</a>
<a name="ln1405">    fields-&gt;errmsg = xrealloc(fields-&gt;errmsg, linelen + 1);</a>
<a name="ln1406">    fields-&gt;errmsglen = linelen + 1;</a>
<a name="ln1407">  }</a>
<a name="ln1408">  // copy whole line to error message</a>
<a name="ln1409">  xstrlcpy(fields-&gt;errmsg, linebuf, linelen + 1);</a>
<a name="ln1410"> </a>
<a name="ln1411">  return QF_OK;</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414">/// Parse the match for error message ('%m') pattern in regmatch.</a>
<a name="ln1415">/// Return the matched value in &quot;fields-&gt;errmsg&quot;.</a>
<a name="ln1416">static int qf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1417">{</a>
<a name="ln1418">  if (rmp-&gt;startp[midx] == NULL || rmp-&gt;endp[midx] == NULL) {</a>
<a name="ln1419">    return QF_FAIL;</a>
<a name="ln1420">  }</a>
<a name="ln1421">  size_t len = (size_t)(rmp-&gt;endp[midx] - rmp-&gt;startp[midx]);</a>
<a name="ln1422">  if (len &gt;= fields-&gt;errmsglen) {</a>
<a name="ln1423">    // len + null terminator</a>
<a name="ln1424">    fields-&gt;errmsg = xrealloc(fields-&gt;errmsg, len + 1);</a>
<a name="ln1425">    fields-&gt;errmsglen = len + 1;</a>
<a name="ln1426">  }</a>
<a name="ln1427">  xstrlcpy(fields-&gt;errmsg, rmp-&gt;startp[midx], len + 1);</a>
<a name="ln1428">  return QF_OK;</a>
<a name="ln1429">}</a>
<a name="ln1430"> </a>
<a name="ln1431">/// Parse the match for rest of a single-line file message ('%r') pattern.</a>
<a name="ln1432">/// Return the matched value in &quot;tail&quot;.</a>
<a name="ln1433">static int qf_parse_fmt_r(regmatch_T *rmp, int midx, char **tail)</a>
<a name="ln1434">{</a>
<a name="ln1435">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1436">    return QF_FAIL;</a>
<a name="ln1437">  }</a>
<a name="ln1438">  *tail = rmp-&gt;startp[midx];</a>
<a name="ln1439">  return QF_OK;</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">/// Parse the match for the pointer line ('%p') pattern in regmatch.</a>
<a name="ln1443">/// Return the matched value in &quot;fields-&gt;col&quot;.</a>
<a name="ln1444">static int qf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1445">{</a>
<a name="ln1446">  if (rmp-&gt;startp[midx] == NULL || rmp-&gt;endp[midx] == NULL) {</a>
<a name="ln1447">    return QF_FAIL;</a>
<a name="ln1448">  }</a>
<a name="ln1449">  fields-&gt;col = 0;</a>
<a name="ln1450">  for (char *match_ptr = rmp-&gt;startp[midx]; match_ptr != rmp-&gt;endp[midx];</a>
<a name="ln1451">       match_ptr++) {</a>
<a name="ln1452">    fields-&gt;col++;</a>
<a name="ln1453">    if (*match_ptr == TAB) {</a>
<a name="ln1454">      fields-&gt;col += 7;</a>
<a name="ln1455">      fields-&gt;col -= fields-&gt;col % 8;</a>
<a name="ln1456">    }</a>
<a name="ln1457">  }</a>
<a name="ln1458">  fields-&gt;col++;</a>
<a name="ln1459">  fields-&gt;use_viscol = true;</a>
<a name="ln1460">  return QF_OK;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">/// Parse the match for the virtual column number ('%v') pattern in regmatch.</a>
<a name="ln1464">/// Return the matched value in &quot;fields-&gt;col&quot;.</a>
<a name="ln1465">static int qf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1466">{</a>
<a name="ln1467">  if (rmp-&gt;startp[midx] == NULL) {</a>
<a name="ln1468">    return QF_FAIL;</a>
<a name="ln1469">  }</a>
<a name="ln1470">  fields-&gt;col = (int)atol(rmp-&gt;startp[midx]);</a>
<a name="ln1471">  fields-&gt;use_viscol = true;</a>
<a name="ln1472">  return QF_OK;</a>
<a name="ln1473">}</a>
<a name="ln1474"> </a>
<a name="ln1475">/// Parse the match for the search text ('%s') pattern in regmatch.</a>
<a name="ln1476">/// Return the matched value in &quot;fields-&gt;pattern&quot;.</a>
<a name="ln1477">static int qf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1478">{</a>
<a name="ln1479">  if (rmp-&gt;startp[midx] == NULL || rmp-&gt;endp[midx] == NULL) {</a>
<a name="ln1480">    return QF_FAIL;</a>
<a name="ln1481">  }</a>
<a name="ln1482">  size_t len = (size_t)(rmp-&gt;endp[midx] - rmp-&gt;startp[midx]);</a>
<a name="ln1483">  if (len &gt; CMDBUFFSIZE - 5) {</a>
<a name="ln1484">    len = CMDBUFFSIZE - 5;</a>
<a name="ln1485">  }</a>
<a name="ln1486">  STRCPY(fields-&gt;pattern, &quot;^\\V&quot;);</a>
<a name="ln1487">  xstrlcat(fields-&gt;pattern, rmp-&gt;startp[midx], len + 4);</a>
<a name="ln1488">  fields-&gt;pattern[len + 3] = '\\';</a>
<a name="ln1489">  fields-&gt;pattern[len + 4] = '$';</a>
<a name="ln1490">  fields-&gt;pattern[len + 5] = NUL;</a>
<a name="ln1491">  return QF_OK;</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494">/// Parse the match for the module ('%o') pattern in regmatch.</a>
<a name="ln1495">/// Return the matched value in &quot;fields-&gt;module&quot;.</a>
<a name="ln1496">static int qf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)</a>
<a name="ln1497">{</a>
<a name="ln1498">  if (rmp-&gt;startp[midx] == NULL || rmp-&gt;endp[midx] == NULL) {</a>
<a name="ln1499">    return QF_FAIL;</a>
<a name="ln1500">  }</a>
<a name="ln1501">  size_t len = (size_t)(rmp-&gt;endp[midx] - rmp-&gt;startp[midx]);</a>
<a name="ln1502">  size_t dsize = strlen(fields-&gt;module) + len + 1;</a>
<a name="ln1503">  if (dsize &gt; CMDBUFFSIZE) {</a>
<a name="ln1504">    dsize = CMDBUFFSIZE;</a>
<a name="ln1505">  }</a>
<a name="ln1506">  xstrlcat(fields-&gt;module, rmp-&gt;startp[midx], dsize);</a>
<a name="ln1507">  return QF_OK;</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510">/// 'errorformat' format pattern parser functions.</a>
<a name="ln1511">/// The '%f' and '%r' formats are parsed differently from other formats.</a>
<a name="ln1512">/// See qf_parse_match() for details.</a>
<a name="ln1513">/// Keep in sync with fmt_pat[].</a>
<a name="ln1514">static int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) = {</a>
<a name="ln1515">  NULL,  // %f</a>
<a name="ln1516">  qf_parse_fmt_b,</a>
<a name="ln1517">  qf_parse_fmt_n,</a>
<a name="ln1518">  qf_parse_fmt_l,</a>
<a name="ln1519">  qf_parse_fmt_e,</a>
<a name="ln1520">  qf_parse_fmt_c,</a>
<a name="ln1521">  qf_parse_fmt_k,</a>
<a name="ln1522">  qf_parse_fmt_t,</a>
<a name="ln1523">  qf_parse_fmt_m,</a>
<a name="ln1524">  NULL,  // %r</a>
<a name="ln1525">  qf_parse_fmt_p,</a>
<a name="ln1526">  qf_parse_fmt_v,</a>
<a name="ln1527">  qf_parse_fmt_s,</a>
<a name="ln1528">  qf_parse_fmt_o</a>
<a name="ln1529">};</a>
<a name="ln1530"> </a>
<a name="ln1531">/// Parse the error format matches in 'regmatch' and set the values in 'fields'.</a>
<a name="ln1532">/// fmt_ptr contains the 'efm' format specifiers/prefixes that have a match.</a>
<a name="ln1533">/// Returns QF_OK if all the matches are successfully parsed. On failure,</a>
<a name="ln1534">/// returns QF_FAIL or QF_NOMEM.</a>
<a name="ln1535">static int qf_parse_match(char *linebuf, size_t linelen, efm_T *fmt_ptr, regmatch_T *regmatch,</a>
<a name="ln1536">                          qffields_T *fields, int qf_multiline, int qf_multiscan, char **tail)</a>
<a name="ln1537">{</a>
<a name="ln1538">  char idx = fmt_ptr-&gt;prefix;</a>
<a name="ln1539"> </a>
<a name="ln1540">  if ((idx == 'C' || idx == 'Z') &amp;&amp; !qf_multiline) {</a>
<a name="ln1541">    return QF_FAIL;</a>
<a name="ln1542">  }</a>
<a name="ln1543">  if (vim_strchr(&quot;EWIN&quot;, (uint8_t)idx) != NULL) {</a>
<a name="ln1544">    fields-&gt;type = idx;</a>
<a name="ln1545">  } else {</a>
<a name="ln1546">    fields-&gt;type = 0;</a>
<a name="ln1547">  }</a>
<a name="ln1548"> </a>
<a name="ln1549">  // Extract error message data from matched line.</a>
<a name="ln1550">  // We check for an actual submatch, because &quot;\[&quot; and &quot;\]&quot; in</a>
<a name="ln1551">  // the 'errorformat' may cause the wrong submatch to be used.</a>
<a name="ln1552">  for (int i = 0; i &lt; FMT_PATTERNS; i++) {</a>
<a name="ln1553">    int status = QF_OK;</a>
<a name="ln1554">    int midx = (int)fmt_ptr-&gt;addr[i];</a>
<a name="ln1555">    if (i == 0 &amp;&amp; midx &gt; 0) {  // %f</a>
<a name="ln1556">      status = qf_parse_fmt_f(regmatch, midx, fields, idx);</a>
<a name="ln1557">    } else if (i == FMT_PATTERN_M) {</a>
<a name="ln1558">      if (fmt_ptr-&gt;flags == '+' &amp;&amp; !qf_multiscan) {  // %+</a>
<a name="ln1559">        status = copy_nonerror_line(linebuf, linelen, fields);</a>
<a name="ln1560">      } else if (midx &gt; 0) {  // %m</a>
<a name="ln1561">        status = qf_parse_fmt_m(regmatch, midx, fields);</a>
<a name="ln1562">      }</a>
<a name="ln1563">    } else if (i == FMT_PATTERN_R &amp;&amp; midx &gt; 0) {  // %r</a>
<a name="ln1564">      status = qf_parse_fmt_r(regmatch, midx, tail);</a>
<a name="ln1565">    } else if (midx &gt; 0) {  // others</a>
<a name="ln1566">      status = (qf_parse_fmt[i])(regmatch, midx, fields);</a>
<a name="ln1567">    }</a>
<a name="ln1568"> </a>
<a name="ln1569">    if (status != QF_OK) {</a>
<a name="ln1570">      return status;</a>
<a name="ln1571">    }</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  return QF_OK;</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577">/// Parse an error line in 'linebuf' using a single error format string in</a>
<a name="ln1578">/// 'fmt_ptr-&gt;prog' and return the matching values in 'fields'.</a>
<a name="ln1579">/// Returns QF_OK if the efm format matches completely and the fields are</a>
<a name="ln1580">/// successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.</a>
<a name="ln1581">static int qf_parse_get_fields(char *linebuf, size_t linelen, efm_T *fmt_ptr, qffields_T *fields,</a>
<a name="ln1582">                               int qf_multiline, int qf_multiscan, char **tail)</a>
<a name="ln1583">{</a>
<a name="ln1584">  if (qf_multiscan &amp;&amp; vim_strchr(&quot;OPQ&quot;, (uint8_t)fmt_ptr-&gt;prefix) == NULL) {</a>
<a name="ln1585">    return QF_FAIL;</a>
<a name="ln1586">  }</a>
<a name="ln1587"> </a>
<a name="ln1588">  fields-&gt;namebuf[0] = NUL;</a>
<a name="ln1589">  fields-&gt;bnr = 0;</a>
<a name="ln1590">  fields-&gt;module[0] = NUL;</a>
<a name="ln1591">  fields-&gt;pattern[0] = NUL;</a>
<a name="ln1592">  if (!qf_multiscan) {</a>
<a name="ln1593">    fields-&gt;errmsg[0] = NUL;</a>
<a name="ln1594">  }</a>
<a name="ln1595">  fields-&gt;lnum = 0;</a>
<a name="ln1596">  fields-&gt;end_lnum = 0;</a>
<a name="ln1597">  fields-&gt;col = 0;</a>
<a name="ln1598">  fields-&gt;end_col = 0;</a>
<a name="ln1599">  fields-&gt;use_viscol = false;</a>
<a name="ln1600">  fields-&gt;enr = -1;</a>
<a name="ln1601">  fields-&gt;type = 0;</a>
<a name="ln1602">  *tail = NULL;</a>
<a name="ln1603"> </a>
<a name="ln1604">  regmatch_T regmatch;</a>
<a name="ln1605">  // Always ignore case when looking for a matching error.</a>
<a name="ln1606">  regmatch.rm_ic = true;</a>
<a name="ln1607">  regmatch.regprog = fmt_ptr-&gt;prog;</a>
<a name="ln1608">  int r = vim_regexec(&amp;regmatch, linebuf, 0);</a>
<a name="ln1609">  fmt_ptr-&gt;prog = regmatch.regprog;</a>
<a name="ln1610">  int status = QF_FAIL;</a>
<a name="ln1611">  if (r) {</a>
<a name="ln1612">    status = qf_parse_match(linebuf, linelen, fmt_ptr, &amp;regmatch, fields,</a>
<a name="ln1613">                            qf_multiline, qf_multiscan, tail);</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  return status;</a>
<a name="ln1617">}</a>
<a name="ln1618"> </a>
<a name="ln1619">/// Parse directory error format prefixes (%D and %X).</a>
<a name="ln1620">/// Push and pop directories from the directory stack when scanning directory</a>
<a name="ln1621">/// names.</a>
<a name="ln1622">static int qf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)</a>
<a name="ln1623">{</a>
<a name="ln1624">  if (idx == 'D') {  // enter directory</a>
<a name="ln1625">    if (*fields-&gt;namebuf == NUL) {</a>
<a name="ln1626">      emsg(_(&quot;E379: Missing or empty directory name&quot;));</a>
<a name="ln1627">      return QF_FAIL;</a>
<a name="ln1628">    }</a>
<a name="ln1629">    qfl-&gt;qf_directory = qf_push_dir(fields-&gt;namebuf, &amp;qfl-&gt;qf_dir_stack, false);</a>
<a name="ln1630">    if (qfl-&gt;qf_directory == NULL) {</a>
<a name="ln1631">      return QF_FAIL;</a>
<a name="ln1632">    }</a>
<a name="ln1633">  } else if (idx == 'X') {  // leave directory</a>
<a name="ln1634">    qfl-&gt;qf_directory = qf_pop_dir(&amp;qfl-&gt;qf_dir_stack);</a>
<a name="ln1635">  }</a>
<a name="ln1636"> </a>
<a name="ln1637">  return QF_OK;</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">/// Parse global file name error format prefixes (%O, %P and %Q).</a>
<a name="ln1641">static int qf_parse_file_pfx(int idx, qffields_T *fields, qf_list_T *qfl, char *tail)</a>
<a name="ln1642">{</a>
<a name="ln1643">  fields-&gt;valid = false;</a>
<a name="ln1644">  if (*fields-&gt;namebuf == NUL || os_path_exists(fields-&gt;namebuf)) {</a>
<a name="ln1645">    if (*fields-&gt;namebuf &amp;&amp; idx == 'P') {</a>
<a name="ln1646">      qfl-&gt;qf_currfile = qf_push_dir(fields-&gt;namebuf, &amp;qfl-&gt;qf_file_stack, true);</a>
<a name="ln1647">    } else if (idx == 'Q') {</a>
<a name="ln1648">      qfl-&gt;qf_currfile = qf_pop_dir(&amp;qfl-&gt;qf_file_stack);</a>
<a name="ln1649">    }</a>
<a name="ln1650">    *fields-&gt;namebuf = NUL;</a>
<a name="ln1651">    if (tail &amp;&amp; *tail) {</a>
<a name="ln1652">      STRMOVE(IObuff, skipwhite(tail));</a>
<a name="ln1653">      qfl-&gt;qf_multiscan = true;</a>
<a name="ln1654">      return QF_MULTISCAN;</a>
<a name="ln1655">    }</a>
<a name="ln1656">  }</a>
<a name="ln1657"> </a>
<a name="ln1658">  return QF_OK;</a>
<a name="ln1659">}</a>
<a name="ln1660"> </a>
<a name="ln1661">/// Parse a non-error line (a line which doesn't match any of the error</a>
<a name="ln1662">/// format in 'efm').</a>
<a name="ln1663">static int qf_parse_line_nomatch(char *linebuf, size_t linelen, qffields_T *fields)</a>
<a name="ln1664">{</a>
<a name="ln1665">  fields-&gt;namebuf[0] = NUL;   // no match found, remove file name</a>
<a name="ln1666">  fields-&gt;lnum = 0;           // don't jump to this line</a>
<a name="ln1667">  fields-&gt;valid = false;</a>
<a name="ln1668"> </a>
<a name="ln1669">  return copy_nonerror_line(linebuf, linelen, fields);</a>
<a name="ln1670">}</a>
<a name="ln1671"> </a>
<a name="ln1672">/// Parse multi-line error format prefixes (%C and %Z)</a>
<a name="ln1673">static int qf_parse_multiline_pfx(int idx, qf_list_T *qfl, qffields_T *fields)</a>
<a name="ln1674">{</a>
<a name="ln1675">  if (!qfl-&gt;qf_multiignore) {</a>
<a name="ln1676">    qfline_T *qfprev = qfl-&gt;qf_last;</a>
<a name="ln1677"> </a>
<a name="ln1678">    if (qfprev == NULL) {</a>
<a name="ln1679">      return QF_FAIL;</a>
<a name="ln1680">    }</a>
<a name="ln1681">    if (*fields-&gt;errmsg) {</a>
<a name="ln1682">      size_t textlen = strlen(qfprev-&gt;qf_text);</a>
<a name="ln1683">      size_t errlen = strlen(fields-&gt;errmsg);</a>
<a name="ln1684">      qfprev-&gt;qf_text = xrealloc(qfprev-&gt;qf_text, textlen + errlen + 2);</a>
<a name="ln1685">      qfprev-&gt;qf_text[textlen] = '\n';</a>
<a name="ln1686">      STRCPY(qfprev-&gt;qf_text + textlen + 1, fields-&gt;errmsg);</a>
<a name="ln1687">    }</a>
<a name="ln1688">    if (qfprev-&gt;qf_nr == -1) {</a>
<a name="ln1689">      qfprev-&gt;qf_nr = fields-&gt;enr;</a>
<a name="ln1690">    }</a>
<a name="ln1691">    if (vim_isprintc(fields-&gt;type) &amp;&amp; !qfprev-&gt;qf_type) {</a>
<a name="ln1692">      // only printable chars allowed</a>
<a name="ln1693">      qfprev-&gt;qf_type = fields-&gt;type;</a>
<a name="ln1694">    }</a>
<a name="ln1695"> </a>
<a name="ln1696">    if (!qfprev-&gt;qf_lnum) {</a>
<a name="ln1697">      qfprev-&gt;qf_lnum = fields-&gt;lnum;</a>
<a name="ln1698">    }</a>
<a name="ln1699">    if (!qfprev-&gt;qf_end_lnum) {</a>
<a name="ln1700">      qfprev-&gt;qf_end_lnum = fields-&gt;end_lnum;</a>
<a name="ln1701">    }</a>
<a name="ln1702">    if (!qfprev-&gt;qf_col) {</a>
<a name="ln1703">      qfprev-&gt;qf_col = fields-&gt;col;</a>
<a name="ln1704">      qfprev-&gt;qf_viscol = fields-&gt;use_viscol;</a>
<a name="ln1705">    }</a>
<a name="ln1706">    if (!qfprev-&gt;qf_end_col) {</a>
<a name="ln1707">      qfprev-&gt;qf_end_col = fields-&gt;end_col;</a>
<a name="ln1708">    }</a>
<a name="ln1709">    if (!qfprev-&gt;qf_fnum) {</a>
<a name="ln1710">      qfprev-&gt;qf_fnum = qf_get_fnum(qfl, qfl-&gt;qf_directory,</a>
<a name="ln1711">                                    *fields-&gt;namebuf || qfl-&gt;qf_directory</a>
<a name="ln1712">                                    ? fields-&gt;namebuf</a>
<a name="ln1713">                                    : qfl-&gt;qf_currfile &amp;&amp; fields-&gt;valid</a>
<a name="ln1714">                                    ? qfl-&gt;qf_currfile : 0);</a>
<a name="ln1715">    }</a>
<a name="ln1716">  }</a>
<a name="ln1717">  if (idx == 'Z') {</a>
<a name="ln1718">    qfl-&gt;qf_multiline = qfl-&gt;qf_multiignore = false;</a>
<a name="ln1719">  }</a>
<a name="ln1720">  line_breakcheck();</a>
<a name="ln1721"> </a>
<a name="ln1722">  return QF_IGNORE_LINE;</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">/// Queue location list stack delete request.</a>
<a name="ln1726">static void locstack_queue_delreq(qf_info_T *qi)</a>
<a name="ln1727">{</a>
<a name="ln1728">  qf_delq_T *q = xmalloc(sizeof(qf_delq_T));</a>
<a name="ln1729">  q-&gt;qi = qi;</a>
<a name="ln1730">  q-&gt;next = qf_delq_head;</a>
<a name="ln1731">  qf_delq_head = q;</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">/// Return the global quickfix stack window buffer number.</a>
<a name="ln1735">int qf_stack_get_bufnr(void)</a>
<a name="ln1736">{</a>
<a name="ln1737">  return ql_info.qf_bufnr;</a>
<a name="ln1738">}</a>
<a name="ln1739"> </a>
<a name="ln1740">/// Wipe the quickfix window buffer (if present) for the specified</a>
<a name="ln1741">/// quickfix/location list.</a>
<a name="ln1742">static void wipe_qf_buffer(qf_info_T *qi)</a>
<a name="ln1743">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1744">{</a>
<a name="ln1745">  if (qi-&gt;qf_bufnr == INVALID_QFBUFNR) {</a>
<a name="ln1746">    return;</a>
<a name="ln1747">  }</a>
<a name="ln1748"> </a>
<a name="ln1749">  buf_T *const qfbuf = buflist_findnr(qi-&gt;qf_bufnr);</a>
<a name="ln1750">  if (qfbuf != NULL &amp;&amp; qfbuf-&gt;b_nwindows == 0) {</a>
<a name="ln1751">    // If the quickfix buffer is not loaded in any window, then</a>
<a name="ln1752">    // wipe the buffer.</a>
<a name="ln1753">    close_buffer(NULL, qfbuf, DOBUF_WIPE, false, false);</a>
<a name="ln1754">    qi-&gt;qf_bufnr = INVALID_QFBUFNR;</a>
<a name="ln1755">  }</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758">/// Free a location list stack</a>
<a name="ln1759">static void ll_free_all(qf_info_T **pqi)</a>
<a name="ln1760">{</a>
<a name="ln1761">  qf_info_T *qi = *pqi;</a>
<a name="ln1762">  if (qi == NULL) {</a>
<a name="ln1763">    return;</a>
<a name="ln1764">  }</a>
<a name="ln1765">  *pqi = NULL;          // Remove reference to this list</a>
<a name="ln1766"> </a>
<a name="ln1767">  // If the location list is still in use, then queue the delete request</a>
<a name="ln1768">  // to be processed later.</a>
<a name="ln1769">  if (quickfix_busy &gt; 0) {</a>
<a name="ln1770">    locstack_queue_delreq(qi);</a>
<a name="ln1771">    return;</a>
<a name="ln1772">  }</a>
<a name="ln1773"> </a>
<a name="ln1774">  qi-&gt;qf_refcount--;</a>
<a name="ln1775">  if (qi-&gt;qf_refcount &lt; 1) {</a>
<a name="ln1776">    // No references to this location list.</a>
<a name="ln1777">    // If the quickfix window buffer is loaded, then wipe it</a>
<a name="ln1778">    wipe_qf_buffer(qi);</a>
<a name="ln1779"> </a>
<a name="ln1780">    for (int i = 0; i &lt; qi-&gt;qf_listcount; i++) {</a>
<a name="ln1781">      qf_free(qf_get_list(qi, i));</a>
<a name="ln1782">    }</a>
<a name="ln1783">    xfree(qi);</a>
<a name="ln1784">  }</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">/// Free all the quickfix/location lists in the stack.</a>
<a name="ln1788">void qf_free_all(win_T *wp)</a>
<a name="ln1789">{</a>
<a name="ln1790">  if (wp != NULL) {</a>
<a name="ln1791">    // location list</a>
<a name="ln1792">    ll_free_all(&amp;wp-&gt;w_llist);</a>
<a name="ln1793">    ll_free_all(&amp;wp-&gt;w_llist_ref);</a>
<a name="ln1794">  } else {</a>
<a name="ln1795">    // quickfix list</a>
<a name="ln1796">    qf_info_T *qi = &amp;ql_info;</a>
<a name="ln1797">    for (int i = 0; i &lt; qi-&gt;qf_listcount; i++) {</a>
<a name="ln1798">      qf_free(qf_get_list(qi, i));</a>
<a name="ln1799">    }</a>
<a name="ln1800">  }</a>
<a name="ln1801">}</a>
<a name="ln1802"> </a>
<a name="ln1803">/// Delay freeing of location list stacks when the quickfix code is running.</a>
<a name="ln1804">/// Used to avoid problems with autocmds freeing location list stacks when the</a>
<a name="ln1805">/// quickfix code is still referencing the stack.</a>
<a name="ln1806">/// Must always call decr_quickfix_busy() exactly once after this.</a>
<a name="ln1807">static void incr_quickfix_busy(void)</a>
<a name="ln1808">{</a>
<a name="ln1809">  quickfix_busy++;</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">/// Safe to free location list stacks. Process any delayed delete requests.</a>
<a name="ln1813">static void decr_quickfix_busy(void)</a>
<a name="ln1814">{</a>
<a name="ln1815">  quickfix_busy--;</a>
<a name="ln1816">  if (quickfix_busy == 0) {</a>
<a name="ln1817">    // No longer referencing the location lists. Process all the pending</a>
<a name="ln1818">    // delete requests.</a>
<a name="ln1819">    while (qf_delq_head != NULL) {</a>
<a name="ln1820">      qf_delq_T *q = qf_delq_head;</a>
<a name="ln1821"> </a>
<a name="ln1822">      qf_delq_head = q-&gt;next;</a>
<a name="ln1823">      ll_free_all(&amp;q-&gt;qi);</a>
<a name="ln1824">      xfree(q);</a>
<a name="ln1825">    }</a>
<a name="ln1826">  }</a>
<a name="ln1827">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln1828">  if (quickfix_busy &lt; 0) {</a>
<a name="ln1829">    emsg(&quot;quickfix_busy has become negative&quot;);</a>
<a name="ln1830">    abort();</a>
<a name="ln1831">  }</a>
<a name="ln1832">#endif</a>
<a name="ln1833">}</a>
<a name="ln1834"> </a>
<a name="ln1835">#if defined(EXITFREE)</a>
<a name="ln1836">void check_quickfix_busy(void)</a>
<a name="ln1837">{</a>
<a name="ln1838">  if (quickfix_busy != 0) {</a>
<a name="ln1839">    semsg(&quot;quickfix_busy not zero on exit: %&quot; PRId64, (int64_t)quickfix_busy);</a>
<a name="ln1840"># ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln1841">    abort();</a>
<a name="ln1842"># endif</a>
<a name="ln1843">  }</a>
<a name="ln1844">}</a>
<a name="ln1845">#endif</a>
<a name="ln1846"> </a>
<a name="ln1847">/// Add an entry to the end of the list of errors.</a>
<a name="ln1848">///</a>
<a name="ln1849">/// @param  qfl      quickfix list entry</a>
<a name="ln1850">/// @param  dir      optional directory name</a>
<a name="ln1851">/// @param  fname    file name or NULL</a>
<a name="ln1852">/// @param  module   module name or NULL</a>
<a name="ln1853">/// @param  bufnum   buffer number or zero</a>
<a name="ln1854">/// @param  mesg     message</a>
<a name="ln1855">/// @param  lnum     line number</a>
<a name="ln1856">/// @param  end_lnum  line number for end</a>
<a name="ln1857">/// @param  col      column</a>
<a name="ln1858">/// @param  end_col  column for end</a>
<a name="ln1859">/// @param  vis_col  using visual column</a>
<a name="ln1860">/// @param  pattern  search pattern</a>
<a name="ln1861">/// @param  nr       error number</a>
<a name="ln1862">/// @param  type     type character</a>
<a name="ln1863">/// @param  user_data  custom user data or NULL</a>
<a name="ln1864">/// @param  valid    valid entry</a>
<a name="ln1865">///</a>
<a name="ln1866">/// @return  QF_OK on success or QF_FAIL on failure.</a>
<a name="ln1867">static int qf_add_entry(qf_list_T *qfl, char *dir, char *fname, char *module, int bufnum,</a>
<a name="ln1868">                        char *mesg, linenr_T lnum, linenr_T end_lnum, int col, int end_col,</a>
<a name="ln1869">                        char vis_col, char *pattern, int nr, char type, typval_T *user_data,</a>
<a name="ln1870">                        char valid)</a>
<a name="ln1871">{</a>
<a name="ln1872">  qfline_T *qfp = xmalloc(sizeof(qfline_T));</a>
<a name="ln1873"> </a>
<a name="ln1874">  if (bufnum != 0) {</a>
<a name="ln1875">    buf_T *buf = buflist_findnr(bufnum);</a>
<a name="ln1876"> </a>
<a name="ln1877">    qfp-&gt;qf_fnum = bufnum;</a>
<a name="ln1878">    if (buf != NULL) {</a>
<a name="ln1879">      buf-&gt;b_has_qf_entry |=</a>
<a name="ln1880">        IS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;</a>
<a name="ln1881">    }</a>
<a name="ln1882">  } else {</a>
<a name="ln1883">    qfp-&gt;qf_fnum = qf_get_fnum(qfl, dir, fname);</a>
<a name="ln1884">  }</a>
<a name="ln1885">  qfp-&gt;qf_text = xstrdup(mesg);</a>
<a name="ln1886">  qfp-&gt;qf_lnum = lnum;</a>
<a name="ln1887">  qfp-&gt;qf_end_lnum = end_lnum;</a>
<a name="ln1888">  qfp-&gt;qf_col = col;</a>
<a name="ln1889">  qfp-&gt;qf_end_col = end_col;</a>
<a name="ln1890">  qfp-&gt;qf_viscol = vis_col;</a>
<a name="ln1891">  if (user_data == NULL || user_data-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln1892">    qfp-&gt;qf_user_data.v_type = VAR_UNKNOWN;</a>
<a name="ln1893">  } else {</a>
<a name="ln1894">    tv_copy(user_data, &amp;qfp-&gt;qf_user_data);</a>
<a name="ln1895">    qfl-&gt;qf_has_user_data = true;</a>
<a name="ln1896">  }</a>
<a name="ln1897">  if (pattern == NULL || *pattern == NUL) {</a>
<a name="ln1898">    qfp-&gt;qf_pattern = NULL;</a>
<a name="ln1899">  } else {</a>
<a name="ln1900">    qfp-&gt;qf_pattern = xstrdup(pattern);</a>
<a name="ln1901">  }</a>
<a name="ln1902">  if (module == NULL || *module == NUL) {</a>
<a name="ln1903">    qfp-&gt;qf_module = NULL;</a>
<a name="ln1904">  } else {</a>
<a name="ln1905">    qfp-&gt;qf_module = xstrdup(module);</a>
<a name="ln1906">  }</a>
<a name="ln1907">  qfp-&gt;qf_nr = nr;</a>
<a name="ln1908">  if (type != 1 &amp;&amp; !vim_isprintc(type)) {  // only printable chars allowed</a>
<a name="ln1909">    type = 0;</a>
<a name="ln1910">  }</a>
<a name="ln1911">  qfp-&gt;qf_type = type;</a>
<a name="ln1912">  qfp-&gt;qf_valid = valid;</a>
<a name="ln1913"> </a>
<a name="ln1914">  qfline_T **lastp = &amp;qfl-&gt;qf_last;</a>
<a name="ln1915">  if (qf_list_empty(qfl)) {</a>
<a name="ln1916">    // first element in the list</a>
<a name="ln1917">    qfl-&gt;qf_start = qfp;</a>
<a name="ln1918">    qfl-&gt;qf_ptr = qfp;</a>
<a name="ln1919">    qfl-&gt;qf_index = 0;</a>
<a name="ln1920">    qfp-&gt;qf_prev = NULL;</a>
<a name="ln1921">  } else {</a>
<a name="ln1922">    assert(*lastp);</a>
<a name="ln1923">    qfp-&gt;qf_prev = *lastp;</a>
<a name="ln1924">    (*lastp)-&gt;qf_next = qfp;</a>
<a name="ln1925">  }</a>
<a name="ln1926">  qfp-&gt;qf_next = NULL;</a>
<a name="ln1927">  qfp-&gt;qf_cleared = false;</a>
<a name="ln1928">  *lastp = qfp;</a>
<a name="ln1929">  qfl-&gt;qf_count++;</a>
<a name="ln1930">  if (qfl-&gt;qf_index == 0 &amp;&amp; qfp-&gt;qf_valid) {</a>
<a name="ln1931">    // first valid entry</a>
<a name="ln1932">    qfl-&gt;qf_index = qfl-&gt;qf_count;</a>
<a name="ln1933">    qfl-&gt;qf_ptr = qfp;</a>
<a name="ln1934">  }</a>
<a name="ln1935"> </a>
<a name="ln1936">  return QF_OK;</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939">/// Allocate a new quickfix/location list stack</a>
<a name="ln1940">static qf_info_T *qf_alloc_stack(qfltype_T qfltype)</a>
<a name="ln1941">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1942">{</a>
<a name="ln1943">  qf_info_T *qi = xcalloc(1, sizeof(qf_info_T));</a>
<a name="ln1944">  qi-&gt;qf_refcount++;</a>
<a name="ln1945">  qi-&gt;qfl_type = qfltype;</a>
<a name="ln1946">  qi-&gt;qf_bufnr = INVALID_QFBUFNR;</a>
<a name="ln1947"> </a>
<a name="ln1948">  return qi;</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951">/// Return the location list stack for window 'wp'.</a>
<a name="ln1952">/// If not present, allocate a location list stack</a>
<a name="ln1953">static qf_info_T *ll_get_or_alloc_list(win_T *wp)</a>
<a name="ln1954">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln1955">{</a>
<a name="ln1956">  if (IS_LL_WINDOW(wp)) {</a>
<a name="ln1957">    // For a location list window, use the referenced location list</a>
<a name="ln1958">    return wp-&gt;w_llist_ref;</a>
<a name="ln1959">  }</a>
<a name="ln1960"> </a>
<a name="ln1961">  // For a non-location list window, w_llist_ref should not point to a</a>
<a name="ln1962">  // location list.</a>
<a name="ln1963">  ll_free_all(&amp;wp-&gt;w_llist_ref);</a>
<a name="ln1964"> </a>
<a name="ln1965">  if (wp-&gt;w_llist == NULL) {</a>
<a name="ln1966">    wp-&gt;w_llist = qf_alloc_stack(QFLT_LOCATION);  // new location list</a>
<a name="ln1967">  }</a>
<a name="ln1968">  return wp-&gt;w_llist;</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">/// Get the quickfix/location list stack to use for the specified Ex command.</a>
<a name="ln1972">/// For a location list command, returns the stack for the current window.  If</a>
<a name="ln1973">/// the location list is not found, then returns NULL and prints an error</a>
<a name="ln1974">/// message if 'print_emsg' is true.</a>
<a name="ln1975">static qf_info_T *qf_cmd_get_stack(exarg_T *eap, int print_emsg)</a>
<a name="ln1976">{</a>
<a name="ln1977">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln1978"> </a>
<a name="ln1979">  if (is_loclist_cmd(eap-&gt;cmdidx)) {</a>
<a name="ln1980">    qi = GET_LOC_LIST(curwin);</a>
<a name="ln1981">    if (qi == NULL) {</a>
<a name="ln1982">      if (print_emsg) {</a>
<a name="ln1983">        emsg(_(e_loclist));</a>
<a name="ln1984">      }</a>
<a name="ln1985">      return NULL;</a>
<a name="ln1986">    }</a>
<a name="ln1987">  }</a>
<a name="ln1988"> </a>
<a name="ln1989">  return qi;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">/// Get the quickfix/location list stack to use for the specified Ex command.</a>
<a name="ln1993">/// For a location list command, returns the stack for the current window.</a>
<a name="ln1994">/// If the location list is not present, then allocates a new one.</a>
<a name="ln1995">/// For a location list command, sets 'pwinp' to curwin.</a>
<a name="ln1996">static qf_info_T *qf_cmd_get_or_alloc_stack(const exarg_T *eap, win_T **pwinp)</a>
<a name="ln1997">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln1998">{</a>
<a name="ln1999">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln2000"> </a>
<a name="ln2001">  if (is_loclist_cmd(eap-&gt;cmdidx)) {</a>
<a name="ln2002">    qi = ll_get_or_alloc_list(curwin);</a>
<a name="ln2003">    *pwinp = curwin;</a>
<a name="ln2004">  }</a>
<a name="ln2005"> </a>
<a name="ln2006">  return qi;</a>
<a name="ln2007">}</a>
<a name="ln2008"> </a>
<a name="ln2009">/// Copy location list entries from 'from_qfl' to 'to_qfl'.</a>
<a name="ln2010">static int copy_loclist_entries(const qf_list_T *from_qfl, qf_list_T *to_qfl)</a>
<a name="ln2011">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2012">{</a>
<a name="ln2013">  int i;</a>
<a name="ln2014">  qfline_T *from_qfp;</a>
<a name="ln2015"> </a>
<a name="ln2016">  // copy all the location entries in this list</a>
<a name="ln2017">  FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i) {</a>
<a name="ln2018">    if (qf_add_entry(to_qfl,</a>
<a name="ln2019">                     NULL,</a>
<a name="ln2020">                     NULL,</a>
<a name="ln2021">                     from_qfp-&gt;qf_module,</a>
<a name="ln2022">                     0,</a>
<a name="ln2023">                     from_qfp-&gt;qf_text,</a>
<a name="ln2024">                     from_qfp-&gt;qf_lnum,</a>
<a name="ln2025">                     from_qfp-&gt;qf_end_lnum,</a>
<a name="ln2026">                     from_qfp-&gt;qf_col,</a>
<a name="ln2027">                     from_qfp-&gt;qf_end_col,</a>
<a name="ln2028">                     from_qfp-&gt;qf_viscol,</a>
<a name="ln2029">                     from_qfp-&gt;qf_pattern,</a>
<a name="ln2030">                     from_qfp-&gt;qf_nr,</a>
<a name="ln2031">                     0,</a>
<a name="ln2032">                     &amp;from_qfp-&gt;qf_user_data,</a>
<a name="ln2033">                     from_qfp-&gt;qf_valid) == QF_FAIL) {</a>
<a name="ln2034">      return FAIL;</a>
<a name="ln2035">    }</a>
<a name="ln2036"> </a>
<a name="ln2037">    // qf_add_entry() will not set the qf_num field, as the</a>
<a name="ln2038">    // directory and file names are not supplied. So the qf_fnum</a>
<a name="ln2039">    // field is copied here.</a>
<a name="ln2040">    qfline_T *const prevp = to_qfl-&gt;qf_last;</a>
<a name="ln2041">    prevp-&gt;qf_fnum = from_qfp-&gt;qf_fnum;  // file number</a>
<a name="ln2042">    prevp-&gt;qf_type = from_qfp-&gt;qf_type;  // error type</a>
<a name="ln2043">    if (from_qfl-&gt;qf_ptr == from_qfp) {</a>
<a name="ln2044">      to_qfl-&gt;qf_ptr = prevp;  // current location</a>
<a name="ln2045">    }</a>
<a name="ln2046">  }</a>
<a name="ln2047"> </a>
<a name="ln2048">  return OK;</a>
<a name="ln2049">}</a>
<a name="ln2050"> </a>
<a name="ln2051">/// Copy the specified location list 'from_qfl' to 'to_qfl'.</a>
<a name="ln2052">static int copy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)</a>
<a name="ln2053">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2054">{</a>
<a name="ln2055">  // Some of the fields are populated by qf_add_entry()</a>
<a name="ln2056">  to_qfl-&gt;qfl_type = from_qfl-&gt;qfl_type;</a>
<a name="ln2057">  to_qfl-&gt;qf_nonevalid = from_qfl-&gt;qf_nonevalid;</a>
<a name="ln2058">  to_qfl-&gt;qf_has_user_data = from_qfl-&gt;qf_has_user_data;</a>
<a name="ln2059">  to_qfl-&gt;qf_count = 0;</a>
<a name="ln2060">  to_qfl-&gt;qf_index = 0;</a>
<a name="ln2061">  to_qfl-&gt;qf_start = NULL;</a>
<a name="ln2062">  to_qfl-&gt;qf_last = NULL;</a>
<a name="ln2063">  to_qfl-&gt;qf_ptr = NULL;</a>
<a name="ln2064">  if (from_qfl-&gt;qf_title != NULL) {</a>
<a name="ln2065">    to_qfl-&gt;qf_title = xstrdup(from_qfl-&gt;qf_title);</a>
<a name="ln2066">  } else {</a>
<a name="ln2067">    to_qfl-&gt;qf_title = NULL;</a>
<a name="ln2068">  }</a>
<a name="ln2069">  if (from_qfl-&gt;qf_ctx != NULL) {</a>
<a name="ln2070">    to_qfl-&gt;qf_ctx = xcalloc(1, sizeof(*to_qfl-&gt;qf_ctx));</a>
<a name="ln2071">    tv_copy(from_qfl-&gt;qf_ctx, to_qfl-&gt;qf_ctx);</a>
<a name="ln2072">  } else {</a>
<a name="ln2073">    to_qfl-&gt;qf_ctx = NULL;</a>
<a name="ln2074">  }</a>
<a name="ln2075">  callback_copy(&amp;to_qfl-&gt;qf_qftf_cb, &amp;from_qfl-&gt;qf_qftf_cb);</a>
<a name="ln2076"> </a>
<a name="ln2077">  if (from_qfl-&gt;qf_count) {</a>
<a name="ln2078">    if (copy_loclist_entries(from_qfl, to_qfl) == FAIL) {</a>
<a name="ln2079">      return FAIL;</a>
<a name="ln2080">    }</a>
<a name="ln2081">  }</a>
<a name="ln2082"> </a>
<a name="ln2083">  to_qfl-&gt;qf_index = from_qfl-&gt;qf_index;  // current index in the list</a>
<a name="ln2084"> </a>
<a name="ln2085">  // Assign a new ID for the location list</a>
<a name="ln2086">  to_qfl-&gt;qf_id = ++last_qf_id;</a>
<a name="ln2087">  to_qfl-&gt;qf_changedtick = 0;</a>
<a name="ln2088"> </a>
<a name="ln2089">  // When no valid entries are present in the list, qf_ptr points to</a>
<a name="ln2090">  // the first item in the list</a>
<a name="ln2091">  if (to_qfl-&gt;qf_nonevalid) {</a>
<a name="ln2092">    to_qfl-&gt;qf_ptr = to_qfl-&gt;qf_start;</a>
<a name="ln2093">    to_qfl-&gt;qf_index = 1;</a>
<a name="ln2094">  }</a>
<a name="ln2095"> </a>
<a name="ln2096">  return OK;</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">// Copy the location list stack 'from' window to 'to' window.</a>
<a name="ln2100">void copy_loclist_stack(win_T *from, win_T *to)</a>
<a name="ln2101">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2102">{</a>
<a name="ln2103">  // When copying from a location list window, copy the referenced</a>
<a name="ln2104">  // location list. For other windows, copy the location list for</a>
<a name="ln2105">  // that window.</a>
<a name="ln2106">  qf_info_T *qi = IS_LL_WINDOW(from) ? from-&gt;w_llist_ref : from-&gt;w_llist;</a>
<a name="ln2107"> </a>
<a name="ln2108">  if (qi == NULL) {                 // no location list to copy</a>
<a name="ln2109">    return;</a>
<a name="ln2110">  }</a>
<a name="ln2111"> </a>
<a name="ln2112">  // allocate a new location list</a>
<a name="ln2113">  to-&gt;w_llist = qf_alloc_stack(QFLT_LOCATION);</a>
<a name="ln2114"> </a>
<a name="ln2115">  to-&gt;w_llist-&gt;qf_listcount = qi-&gt;qf_listcount;</a>
<a name="ln2116"> </a>
<a name="ln2117">  // Copy the location lists one at a time</a>
<a name="ln2118">  for (int idx = 0; idx &lt; qi-&gt;qf_listcount; idx++) {</a>
<a name="ln2119">    to-&gt;w_llist-&gt;qf_curlist = idx;</a>
<a name="ln2120"> </a>
<a name="ln2121">    if (copy_loclist(qf_get_list(qi, idx),</a>
<a name="ln2122">                     qf_get_list(to-&gt;w_llist, idx)) == FAIL) {</a>
<a name="ln2123">      qf_free_all(to);</a>
<a name="ln2124">      return;</a>
<a name="ln2125">    }</a>
<a name="ln2126">  }</a>
<a name="ln2127"> </a>
<a name="ln2128">  to-&gt;w_llist-&gt;qf_curlist = qi-&gt;qf_curlist;  // current list</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131">/// Get buffer number for file &quot;directory/fname&quot;.</a>
<a name="ln2132">/// Also sets the b_has_qf_entry flag.</a>
<a name="ln2133">static int qf_get_fnum(qf_list_T *qfl, char *directory, char *fname)</a>
<a name="ln2134">{</a>
<a name="ln2135">  char *ptr = NULL;</a>
<a name="ln2136">  char *bufname;</a>
<a name="ln2137">  buf_T *buf;</a>
<a name="ln2138">  if (fname == NULL || *fname == NUL) {         // no file name</a>
<a name="ln2139">    return 0;</a>
<a name="ln2140">  }</a>
<a name="ln2141"> </a>
<a name="ln2142">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2143">  if (directory != NULL) {</a>
<a name="ln2144">    slash_adjust(directory);</a>
<a name="ln2145">  }</a>
<a name="ln2146">  slash_adjust(fname);</a>
<a name="ln2147">#endif</a>
<a name="ln2148">  if (directory != NULL &amp;&amp; !vim_isAbsName(fname)) {</a>
<a name="ln2149">    ptr = concat_fnames(directory, fname, true);</a>
<a name="ln2150">    // Here we check if the file really exists.</a>
<a name="ln2151">    // This should normally be true, but if make works without</a>
<a name="ln2152">    // &quot;leaving directory&quot;-messages we might have missed a</a>
<a name="ln2153">    // directory change.</a>
<a name="ln2154">    if (!os_path_exists(ptr)) {</a>
<a name="ln2155">      xfree(ptr);</a>
<a name="ln2156">      directory = qf_guess_filepath(qfl, fname);</a>
<a name="ln2157">      if (directory) {</a>
<a name="ln2158">        ptr = concat_fnames(directory, fname, true);</a>
<a name="ln2159">      } else {</a>
<a name="ln2160">        ptr = xstrdup(fname);</a>
<a name="ln2161">      }</a>
<a name="ln2162">    }</a>
<a name="ln2163">    // Use concatenated directory name and file name.</a>
<a name="ln2164">    bufname = ptr;</a>
<a name="ln2165">  } else {</a>
<a name="ln2166">    bufname = fname;</a>
<a name="ln2167">  }</a>
<a name="ln2168"> </a>
<a name="ln2169">  if (qf_last_bufname != NULL</a>
<a name="ln2170">      &amp;&amp; strcmp(bufname, qf_last_bufname) == 0</a>
<a name="ln2171">      &amp;&amp; bufref_valid(&amp;qf_last_bufref)) {</a>
<a name="ln2172">    buf = qf_last_bufref.br_buf;</a>
<a name="ln2173">    xfree(ptr);</a>
<a name="ln2174">  } else {</a>
<a name="ln2175">    xfree(qf_last_bufname);</a>
<a name="ln2176">    buf = buflist_new(bufname, NULL, 0, BLN_NOOPT);</a>
<a name="ln2177">    qf_last_bufname = (bufname == ptr) ? bufname : xstrdup(bufname);</a>
<a name="ln2178">    set_bufref(&amp;qf_last_bufref, buf);</a>
<a name="ln2179">  }</a>
<a name="ln2180">  if (buf == NULL) {</a>
<a name="ln2181">    return 0;</a>
<a name="ln2182">  }</a>
<a name="ln2183">  buf-&gt;b_has_qf_entry =</a>
<a name="ln2184">    IS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;</a>
<a name="ln2185">  return buf-&gt;b_fnum;</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">// Push dirbuf onto the directory stack and return pointer to actual dir or</a>
<a name="ln2189">// NULL on error.</a>
<a name="ln2190">static char *qf_push_dir(char *dirbuf, struct dir_stack_T **stackptr, bool is_file_stack)</a>
<a name="ln2191">{</a>
<a name="ln2192">  struct dir_stack_T *ds_ptr;</a>
<a name="ln2193"> </a>
<a name="ln2194">  // allocate new stack element and hook it in</a>
<a name="ln2195">  struct dir_stack_T *ds_new = xmalloc(sizeof(struct dir_stack_T));</a>
<a name="ln2196"> </a>
<a name="ln2197">  ds_new-&gt;next = *stackptr;</a>
<a name="ln2198">  *stackptr = ds_new;</a>
<a name="ln2199"> </a>
<a name="ln2200">  // store directory on the stack</a>
<a name="ln2201">  if (vim_isAbsName(dirbuf)</a>
<a name="ln2202">      || (*stackptr)-&gt;next == NULL</a>
<a name="ln2203">      || is_file_stack) {</a>
<a name="ln2204">    (*stackptr)-&gt;dirname = xstrdup(dirbuf);</a>
<a name="ln2205">  } else {</a>
<a name="ln2206">    // Okay we don't have an absolute path.</a>
<a name="ln2207">    // dirbuf must be a subdir of one of the directories on the stack.</a>
<a name="ln2208">    // Let's search...</a>
<a name="ln2209">    ds_new = (*stackptr)-&gt;next;</a>
<a name="ln2210">    (*stackptr)-&gt;dirname = NULL;</a>
<a name="ln2211">    while (ds_new) {</a>
<a name="ln2212">      xfree((*stackptr)-&gt;dirname);</a>
<a name="ln2213">      (*stackptr)-&gt;dirname = concat_fnames(ds_new-&gt;dirname, dirbuf, true);</a>
<a name="ln2214">      if (os_isdir((*stackptr)-&gt;dirname)) {</a>
<a name="ln2215">        break;</a>
<a name="ln2216">      }</a>
<a name="ln2217"> </a>
<a name="ln2218">      ds_new = ds_new-&gt;next;</a>
<a name="ln2219">    }</a>
<a name="ln2220"> </a>
<a name="ln2221">    // clean up all dirs we already left</a>
<a name="ln2222">    while ((*stackptr)-&gt;next != ds_new) {</a>
<a name="ln2223">      ds_ptr = (*stackptr)-&gt;next;</a>
<a name="ln2224">      (*stackptr)-&gt;next = (*stackptr)-&gt;next-&gt;next;</a>
<a name="ln2225">      xfree(ds_ptr-&gt;dirname);</a>
<a name="ln2226">      xfree(ds_ptr);</a>
<a name="ln2227">    }</a>
<a name="ln2228"> </a>
<a name="ln2229">    // Nothing found -&gt; it must be on top level</a>
<a name="ln2230">    if (ds_new == NULL) {</a>
<a name="ln2231">      xfree((*stackptr)-&gt;dirname);</a>
<a name="ln2232">      (*stackptr)-&gt;dirname = xstrdup(dirbuf);</a>
<a name="ln2233">    }</a>
<a name="ln2234">  }</a>
<a name="ln2235"> </a>
<a name="ln2236">  if ((*stackptr)-&gt;dirname != NULL) {</a>
<a name="ln2237">    return (*stackptr)-&gt;dirname;</a>
<a name="ln2238">  }</a>
<a name="ln2239">  ds_ptr = *stackptr;</a>
<a name="ln2240">  *stackptr = (*stackptr)-&gt;next;</a>
<a name="ln2241">  xfree(ds_ptr);</a>
<a name="ln2242">  return NULL;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">// pop dirbuf from the directory stack and return previous directory or NULL if</a>
<a name="ln2246">// stack is empty</a>
<a name="ln2247">static char *qf_pop_dir(struct dir_stack_T **stackptr)</a>
<a name="ln2248">{</a>
<a name="ln2249">  // TODO(vim): Should we check if dirbuf is the directory on top of the stack?</a>
<a name="ln2250">  // What to do if it isn't?</a>
<a name="ln2251"> </a>
<a name="ln2252">  // pop top element and free it</a>
<a name="ln2253">  if (*stackptr != NULL) {</a>
<a name="ln2254">    struct dir_stack_T *ds_ptr = *stackptr;</a>
<a name="ln2255">    *stackptr = (*stackptr)-&gt;next;</a>
<a name="ln2256">    xfree(ds_ptr-&gt;dirname);</a>
<a name="ln2257">    xfree(ds_ptr);</a>
<a name="ln2258">  }</a>
<a name="ln2259"> </a>
<a name="ln2260">  // return NEW top element as current dir or NULL if stack is empty</a>
<a name="ln2261">  return *stackptr ? (*stackptr)-&gt;dirname : NULL;</a>
<a name="ln2262">}</a>
<a name="ln2263"> </a>
<a name="ln2264">// clean up directory stack</a>
<a name="ln2265">static void qf_clean_dir_stack(struct dir_stack_T **stackptr)</a>
<a name="ln2266">{</a>
<a name="ln2267">  struct dir_stack_T *ds_ptr;</a>
<a name="ln2268"> </a>
<a name="ln2269">  while ((ds_ptr = *stackptr) != NULL) {</a>
<a name="ln2270">    *stackptr = (*stackptr)-&gt;next;</a>
<a name="ln2271">    xfree(ds_ptr-&gt;dirname);</a>
<a name="ln2272">    xfree(ds_ptr);</a>
<a name="ln2273">  }</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276">/// Check in which directory of the directory stack the given file can be</a>
<a name="ln2277">/// found.</a>
<a name="ln2278">/// Returns a pointer to the directory name or NULL if not found.</a>
<a name="ln2279">/// Cleans up intermediate directory entries.</a>
<a name="ln2280">///</a>
<a name="ln2281">/// TODO(vim): How to solve the following problem?</a>
<a name="ln2282">/// If we have this directory tree:</a>
<a name="ln2283">///     ./</a>
<a name="ln2284">///     ./aa</a>
<a name="ln2285">///     ./aa/bb</a>
<a name="ln2286">///     ./bb</a>
<a name="ln2287">///     ./bb/x.c</a>
<a name="ln2288">/// and make says:</a>
<a name="ln2289">///     making all in aa</a>
<a name="ln2290">///     making all in bb</a>
<a name="ln2291">///     x.c:9: Error</a>
<a name="ln2292">/// Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.</a>
<a name="ln2293">/// qf_guess_filepath will return NULL.</a>
<a name="ln2294">static char *qf_guess_filepath(qf_list_T *qfl, char *filename)</a>
<a name="ln2295">{</a>
<a name="ln2296">  // no dirs on the stack - there's nothing we can do</a>
<a name="ln2297">  if (qfl-&gt;qf_dir_stack == NULL) {</a>
<a name="ln2298">    return NULL;</a>
<a name="ln2299">  }</a>
<a name="ln2300"> </a>
<a name="ln2301">  struct dir_stack_T *ds_ptr = qfl-&gt;qf_dir_stack-&gt;next;</a>
<a name="ln2302">  char *fullname = NULL;</a>
<a name="ln2303">  while (ds_ptr) {</a>
<a name="ln2304">    xfree(fullname);</a>
<a name="ln2305">    fullname = concat_fnames(ds_ptr-&gt;dirname, filename, true);</a>
<a name="ln2306"> </a>
<a name="ln2307">    if (os_path_exists(fullname)) {</a>
<a name="ln2308">      break;</a>
<a name="ln2309">    }</a>
<a name="ln2310"> </a>
<a name="ln2311">    ds_ptr = ds_ptr-&gt;next;</a>
<a name="ln2312">  }</a>
<a name="ln2313"> </a>
<a name="ln2314">  xfree(fullname);</a>
<a name="ln2315"> </a>
<a name="ln2316">  // clean up all dirs we already left</a>
<a name="ln2317">  while (qfl-&gt;qf_dir_stack-&gt;next != ds_ptr) {</a>
<a name="ln2318">    struct dir_stack_T *ds_tmp = qfl-&gt;qf_dir_stack-&gt;next;</a>
<a name="ln2319">    qfl-&gt;qf_dir_stack-&gt;next = qfl-&gt;qf_dir_stack-&gt;next-&gt;next;</a>
<a name="ln2320">    xfree(ds_tmp-&gt;dirname);</a>
<a name="ln2321">    xfree(ds_tmp);</a>
<a name="ln2322">  }</a>
<a name="ln2323"> </a>
<a name="ln2324">  return ds_ptr == NULL ? NULL : ds_ptr-&gt;dirname;</a>
<a name="ln2325">}</a>
<a name="ln2326"> </a>
<a name="ln2327">/// Returns true, if a quickfix/location list with the given identifier exists.</a>
<a name="ln2328">static bool qflist_valid(win_T *wp, unsigned qf_id)</a>
<a name="ln2329">{</a>
<a name="ln2330">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln2331"> </a>
<a name="ln2332">  if (wp) {</a>
<a name="ln2333">    if (!win_valid(wp)) {</a>
<a name="ln2334">      return false;</a>
<a name="ln2335">    }</a>
<a name="ln2336">    qi = GET_LOC_LIST(wp);  // Location list</a>
<a name="ln2337">    if (!qi) {</a>
<a name="ln2338">      return false;</a>
<a name="ln2339">    }</a>
<a name="ln2340">  }</a>
<a name="ln2341"> </a>
<a name="ln2342">  for (int i = 0; i &lt; qi-&gt;qf_listcount; i++) {</a>
<a name="ln2343">    if (qi-&gt;qf_lists[i].qf_id == qf_id) {</a>
<a name="ln2344">      return true;</a>
<a name="ln2345">    }</a>
<a name="ln2346">  }</a>
<a name="ln2347"> </a>
<a name="ln2348">  return false;</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">/// When loading a file from the quickfix, the autocommands may modify it.</a>
<a name="ln2352">/// This may invalidate the current quickfix entry.  This function checks</a>
<a name="ln2353">/// whether an entry is still present in the quickfix list.</a>
<a name="ln2354">/// Similar to location list.</a>
<a name="ln2355">static bool is_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)</a>
<a name="ln2356">{</a>
<a name="ln2357">  qfline_T *qfp;</a>
<a name="ln2358">  int i;</a>
<a name="ln2359"> </a>
<a name="ln2360">  // Search for the entry in the current list</a>
<a name="ln2361">  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln2362">    if (qfp == qf_ptr) {</a>
<a name="ln2363">      break;</a>
<a name="ln2364">    }</a>
<a name="ln2365">  }</a>
<a name="ln2366"> </a>
<a name="ln2367">  if (i &gt; qfl-&gt;qf_count) {  // Entry is not found</a>
<a name="ln2368">    return false;</a>
<a name="ln2369">  }</a>
<a name="ln2370"> </a>
<a name="ln2371">  return true;</a>
<a name="ln2372">}</a>
<a name="ln2373"> </a>
<a name="ln2374">/// Get the next valid entry in the current quickfix/location list. The search</a>
<a name="ln2375">/// starts from the current entry. Returns NULL on failure.</a>
<a name="ln2376">static qfline_T *get_next_valid_entry(qf_list_T *qfl, qfline_T *qf_ptr, int *qf_index, int dir)</a>
<a name="ln2377">{</a>
<a name="ln2378">  int idx = *qf_index;</a>
<a name="ln2379">  int old_qf_fnum = qf_ptr-&gt;qf_fnum;</a>
<a name="ln2380"> </a>
<a name="ln2381">  do {</a>
<a name="ln2382">    if (idx == qfl-&gt;qf_count || qf_ptr-&gt;qf_next == NULL) {</a>
<a name="ln2383">      return NULL;</a>
<a name="ln2384">    }</a>
<a name="ln2385">    idx++;</a>
<a name="ln2386">    qf_ptr = qf_ptr-&gt;qf_next;</a>
<a name="ln2387">  } while ((!qfl-&gt;qf_nonevalid &amp;&amp; !qf_ptr-&gt;qf_valid)</a>
<a name="ln2388">           || (dir == FORWARD_FILE &amp;&amp; qf_ptr-&gt;qf_fnum == old_qf_fnum));</a>
<a name="ln2389"> </a>
<a name="ln2390">  *qf_index = idx;</a>
<a name="ln2391">  return qf_ptr;</a>
<a name="ln2392">}</a>
<a name="ln2393"> </a>
<a name="ln2394">/// Get the previous valid entry in the current quickfix/location list. The</a>
<a name="ln2395">/// search starts from the current entry. Returns NULL on failure.</a>
<a name="ln2396">static qfline_T *get_prev_valid_entry(qf_list_T *qfl, qfline_T *qf_ptr, int *qf_index, int dir)</a>
<a name="ln2397">{</a>
<a name="ln2398">  int idx = *qf_index;</a>
<a name="ln2399">  int old_qf_fnum = qf_ptr-&gt;qf_fnum;</a>
<a name="ln2400"> </a>
<a name="ln2401">  do {</a>
<a name="ln2402">    if (idx == 1 || qf_ptr-&gt;qf_prev == NULL) {</a>
<a name="ln2403">      return NULL;</a>
<a name="ln2404">    }</a>
<a name="ln2405">    idx--;</a>
<a name="ln2406">    qf_ptr = qf_ptr-&gt;qf_prev;</a>
<a name="ln2407">  } while ((!qfl-&gt;qf_nonevalid &amp;&amp; !qf_ptr-&gt;qf_valid)</a>
<a name="ln2408">           || (dir == BACKWARD_FILE &amp;&amp; qf_ptr-&gt;qf_fnum == old_qf_fnum));</a>
<a name="ln2409"> </a>
<a name="ln2410">  *qf_index = idx;</a>
<a name="ln2411">  return qf_ptr;</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">/// Get the n'th (errornr) previous/next valid entry from the current entry in</a>
<a name="ln2415">/// the quickfix list.</a>
<a name="ln2416">///   dir == FORWARD or FORWARD_FILE: next valid entry</a>
<a name="ln2417">///   dir == BACKWARD or BACKWARD_FILE: previous valid entry</a>
<a name="ln2418">static qfline_T *get_nth_valid_entry(qf_list_T *qfl, int errornr, int dir, int *new_qfidx)</a>
<a name="ln2419">{</a>
<a name="ln2420">  qfline_T *qf_ptr = qfl-&gt;qf_ptr;</a>
<a name="ln2421">  int qf_idx = qfl-&gt;qf_index;</a>
<a name="ln2422">  const char *err = e_no_more_items;</a>
<a name="ln2423"> </a>
<a name="ln2424">  while (errornr--) {</a>
<a name="ln2425">    qfline_T *prev_qf_ptr = qf_ptr;</a>
<a name="ln2426">    int prev_index = qf_idx;</a>
<a name="ln2427"> </a>
<a name="ln2428">    if (dir == FORWARD || dir == FORWARD_FILE) {</a>
<a name="ln2429">      qf_ptr = get_next_valid_entry(qfl, qf_ptr, &amp;qf_idx, dir);</a>
<a name="ln2430">    } else {</a>
<a name="ln2431">      qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &amp;qf_idx, dir);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    if (qf_ptr == NULL) {</a>
<a name="ln2435">      qf_ptr = prev_qf_ptr;</a>
<a name="ln2436">      qf_idx = prev_index;</a>
<a name="ln2437">      if (err != NULL) {</a>
<a name="ln2438">        emsg(_(err));</a>
<a name="ln2439">        return NULL;</a>
<a name="ln2440">      }</a>
<a name="ln2441">      break;</a>
<a name="ln2442">    }</a>
<a name="ln2443"> </a>
<a name="ln2444">    err = NULL;</a>
<a name="ln2445">  }</a>
<a name="ln2446"> </a>
<a name="ln2447">  *new_qfidx = qf_idx;</a>
<a name="ln2448">  return qf_ptr;</a>
<a name="ln2449">}</a>
<a name="ln2450"> </a>
<a name="ln2451">/// Get n'th (errornr) quickfix entry from the current entry in the quickfix</a>
<a name="ln2452">/// list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'</a>
<a name="ln2453">static qfline_T *get_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)</a>
<a name="ln2454">{</a>
<a name="ln2455">  qfline_T *qf_ptr = qfl-&gt;qf_ptr;</a>
<a name="ln2456">  int qf_idx = qfl-&gt;qf_index;</a>
<a name="ln2457"> </a>
<a name="ln2458">  // New error number is less than the current error number</a>
<a name="ln2459">  while (errornr &lt; qf_idx &amp;&amp; qf_idx &gt; 1 &amp;&amp; qf_ptr-&gt;qf_prev != NULL) {</a>
<a name="ln2460">    qf_idx--;</a>
<a name="ln2461">    qf_ptr = qf_ptr-&gt;qf_prev;</a>
<a name="ln2462">  }</a>
<a name="ln2463"> </a>
<a name="ln2464">  // New error number is greater than the current error number</a>
<a name="ln2465">  while (errornr &gt; qf_idx</a>
<a name="ln2466">         &amp;&amp; qf_idx &lt; qfl-&gt;qf_count</a>
<a name="ln2467">         &amp;&amp; qf_ptr-&gt;qf_next != NULL) {</a>
<a name="ln2468">    qf_idx++;</a>
<a name="ln2469">    qf_ptr = qf_ptr-&gt;qf_next;</a>
<a name="ln2470">  }</a>
<a name="ln2471"> </a>
<a name="ln2472">  *new_qfidx = qf_idx;</a>
<a name="ln2473">  return qf_ptr;</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">/// Get a entry specified by 'errornr' and 'dir' from the current</a>
<a name="ln2477">/// quickfix/location list. 'errornr' specifies the index of the entry and 'dir'</a>
<a name="ln2478">/// specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).</a>
<a name="ln2479">/// Returns a pointer to the entry and the index of the new entry is stored in</a>
<a name="ln2480">/// 'new_qfidx'.</a>
<a name="ln2481">static qfline_T *qf_get_entry(qf_list_T *qfl, int errornr, int dir, int *new_qfidx)</a>
<a name="ln2482">{</a>
<a name="ln2483">  qfline_T *qf_ptr = qfl-&gt;qf_ptr;</a>
<a name="ln2484">  int qfidx = qfl-&gt;qf_index;</a>
<a name="ln2485"> </a>
<a name="ln2486">  if (dir != 0) {  // next/prev valid entry</a>
<a name="ln2487">    qf_ptr = get_nth_valid_entry(qfl, errornr, dir, &amp;qfidx);</a>
<a name="ln2488">  } else if (errornr != 0) {  // go to specified number</a>
<a name="ln2489">    qf_ptr = get_nth_entry(qfl, errornr, &amp;qfidx);</a>
<a name="ln2490">  }</a>
<a name="ln2491"> </a>
<a name="ln2492">  *new_qfidx = qfidx;</a>
<a name="ln2493">  return qf_ptr;</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496">// Find a window displaying a Vim help file in the current tab page.</a>
<a name="ln2497">static win_T *qf_find_help_win(void)</a>
<a name="ln2498">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2499">{</a>
<a name="ln2500">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2501">    if (bt_help(wp-&gt;w_buffer)) {</a>
<a name="ln2502">      return wp;</a>
<a name="ln2503">    }</a>
<a name="ln2504">  }</a>
<a name="ln2505">  return NULL;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/// Set the location list for the specified window to 'qi'.</a>
<a name="ln2509">static void win_set_loclist(win_T *wp, qf_info_T *qi)</a>
<a name="ln2510">{</a>
<a name="ln2511">  wp-&gt;w_llist = qi;</a>
<a name="ln2512">  qi-&gt;qf_refcount++;</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">/// Find a help window or open one. If 'newwin' is true, then open a new help</a>
<a name="ln2516">/// window.</a>
<a name="ln2517">static int jump_to_help_window(qf_info_T *qi, bool newwin, int *opened_window)</a>
<a name="ln2518">{</a>
<a name="ln2519">  win_T *wp = NULL;</a>
<a name="ln2520"> </a>
<a name="ln2521">  if (cmdmod.cmod_tab != 0 || newwin) {</a>
<a name="ln2522">    wp = NULL;</a>
<a name="ln2523">  } else {</a>
<a name="ln2524">    wp = qf_find_help_win();</a>
<a name="ln2525">  }</a>
<a name="ln2526"> </a>
<a name="ln2527">  if (wp != NULL &amp;&amp; wp-&gt;w_buffer-&gt;b_nwindows &gt; 0) {</a>
<a name="ln2528">    win_enter(wp, true);</a>
<a name="ln2529">  } else {</a>
<a name="ln2530">    // Split off help window; put it at far top if no position</a>
<a name="ln2531">    // specified, the current window is vertically split and narrow.</a>
<a name="ln2532">    int flags = WSP_HELP;</a>
<a name="ln2533">    if (cmdmod.cmod_split == 0</a>
<a name="ln2534">        &amp;&amp; curwin-&gt;w_width != Columns</a>
<a name="ln2535">        &amp;&amp; curwin-&gt;w_width &lt; 80) {</a>
<a name="ln2536">      flags |= WSP_TOP;</a>
<a name="ln2537">    }</a>
<a name="ln2538"> </a>
<a name="ln2539">    // If the user asks to open a new window, then copy the location list.</a>
<a name="ln2540">    // Otherwise, don't copy the location list.</a>
<a name="ln2541">    if (IS_LL_STACK(qi) &amp;&amp; !newwin) {</a>
<a name="ln2542">      flags |= WSP_NEWLOC;</a>
<a name="ln2543">    }</a>
<a name="ln2544"> </a>
<a name="ln2545">    if (win_split(0, flags) == FAIL) {</a>
<a name="ln2546">      return FAIL;</a>
<a name="ln2547">    }</a>
<a name="ln2548"> </a>
<a name="ln2549">    *opened_window = true;</a>
<a name="ln2550"> </a>
<a name="ln2551">    if (curwin-&gt;w_height &lt; p_hh) {</a>
<a name="ln2552">      win_setheight((int)p_hh);</a>
<a name="ln2553">    }</a>
<a name="ln2554"> </a>
<a name="ln2555">    // When using location list, the new window should use the supplied</a>
<a name="ln2556">    // location list. If the user asks to open a new window, then the new</a>
<a name="ln2557">    // window will get a copy of the location list.</a>
<a name="ln2558">    if (IS_LL_STACK(qi) &amp;&amp; !newwin) {</a>
<a name="ln2559">      win_set_loclist(curwin, qi);</a>
<a name="ln2560">    }</a>
<a name="ln2561">  }</a>
<a name="ln2562"> </a>
<a name="ln2563">  restart_edit = 0;  // don't want insert mode in help file</a>
<a name="ln2564"> </a>
<a name="ln2565">  return OK;</a>
<a name="ln2566">}</a>
<a name="ln2567"> </a>
<a name="ln2568">/// Find a non-quickfix window using the given location list stack in the</a>
<a name="ln2569">/// current tabpage.</a>
<a name="ln2570">/// Returns NULL if a matching window is not found.</a>
<a name="ln2571">static win_T *qf_find_win_with_loclist(const qf_info_T *ll)</a>
<a name="ln2572">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2573">{</a>
<a name="ln2574">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2575">    if (wp-&gt;w_llist == ll &amp;&amp; !bt_quickfix(wp-&gt;w_buffer)) {</a>
<a name="ln2576">      return wp;</a>
<a name="ln2577">    }</a>
<a name="ln2578">  }</a>
<a name="ln2579">  return NULL;</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582">/// Find a window containing a normal buffer in the current tab page.</a>
<a name="ln2583">static win_T *qf_find_win_with_normal_buf(void)</a>
<a name="ln2584">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2585">{</a>
<a name="ln2586">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2587">    if (bt_normal(wp-&gt;w_buffer)) {</a>
<a name="ln2588">      return wp;</a>
<a name="ln2589">    }</a>
<a name="ln2590">  }</a>
<a name="ln2591">  return NULL;</a>
<a name="ln2592">}</a>
<a name="ln2593"> </a>
<a name="ln2594">// Go to a window in any tabpage containing the specified file.  Returns true</a>
<a name="ln2595">// if successfully jumped to the window. Otherwise returns false.</a>
<a name="ln2596">static bool qf_goto_tabwin_with_file(int fnum)</a>
<a name="ln2597">{</a>
<a name="ln2598">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2599">    if (wp-&gt;w_buffer-&gt;b_fnum == fnum) {</a>
<a name="ln2600">      goto_tabpage_win(tp, wp);</a>
<a name="ln2601">      return true;</a>
<a name="ln2602">    }</a>
<a name="ln2603">  }</a>
<a name="ln2604">  return false;</a>
<a name="ln2605">}</a>
<a name="ln2606"> </a>
<a name="ln2607">// Create a new window to show a file above the quickfix window. Called when</a>
<a name="ln2608">// only the quickfix window is present.</a>
<a name="ln2609">static int qf_open_new_file_win(qf_info_T *ll_ref)</a>
<a name="ln2610">{</a>
<a name="ln2611">  int flags = WSP_ABOVE;</a>
<a name="ln2612">  if (ll_ref != NULL) {</a>
<a name="ln2613">    flags |= WSP_NEWLOC;</a>
<a name="ln2614">  }</a>
<a name="ln2615">  if (win_split(0, flags) == FAIL) {</a>
<a name="ln2616">    return FAIL;  // not enough room for window</a>
<a name="ln2617">  }</a>
<a name="ln2618">  p_swb = empty_string_option;  // don't split again</a>
<a name="ln2619">  swb_flags = 0;</a>
<a name="ln2620">  RESET_BINDING(curwin);</a>
<a name="ln2621">  if (ll_ref != NULL) {</a>
<a name="ln2622">    // The new window should use the location list from the</a>
<a name="ln2623">    // location list window</a>
<a name="ln2624">    win_set_loclist(curwin, ll_ref);</a>
<a name="ln2625">  }</a>
<a name="ln2626">  return OK;</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">// Go to a window that shows the right buffer. If the window is not found, go</a>
<a name="ln2630">// to the window just above the location list window. This is used for opening</a>
<a name="ln2631">// a file from a location window and not from a quickfix window. If some usable</a>
<a name="ln2632">// window is previously found, then it is supplied in 'use_win'.</a>
<a name="ln2633">static void qf_goto_win_with_ll_file(win_T *use_win, int qf_fnum, qf_info_T *ll_ref)</a>
<a name="ln2634">{</a>
<a name="ln2635">  win_T *win = use_win;</a>
<a name="ln2636"> </a>
<a name="ln2637">  if (win == NULL) {</a>
<a name="ln2638">    // Find the window showing the selected file in the current tab page.</a>
<a name="ln2639">    FOR_ALL_WINDOWS_IN_TAB(win2, curtab) {</a>
<a name="ln2640">      if (win2-&gt;w_buffer-&gt;b_fnum == qf_fnum) {</a>
<a name="ln2641">        win = win2;</a>
<a name="ln2642">        break;</a>
<a name="ln2643">      }</a>
<a name="ln2644">    }</a>
<a name="ln2645">    if (win == NULL) {</a>
<a name="ln2646">      // Find a previous usable window</a>
<a name="ln2647">      win = curwin;</a>
<a name="ln2648">      do {</a>
<a name="ln2649">        if (bt_normal(win-&gt;w_buffer)) {</a>
<a name="ln2650">          break;</a>
<a name="ln2651">        }</a>
<a name="ln2652">        if (win-&gt;w_prev == NULL) {</a>
<a name="ln2653">          win = lastwin;      // wrap around the top</a>
<a name="ln2654">        } else {</a>
<a name="ln2655">          win = win-&gt;w_prev;  // go to previous window</a>
<a name="ln2656">        }</a>
<a name="ln2657">      } while (win != curwin);</a>
<a name="ln2658">    }</a>
<a name="ln2659">  }</a>
<a name="ln2660">  win_goto(win);</a>
<a name="ln2661"> </a>
<a name="ln2662">  // If the location list for the window is not set, then set it</a>
<a name="ln2663">  // to the location list from the location window</a>
<a name="ln2664">  if (win-&gt;w_llist == NULL &amp;&amp; ll_ref != NULL) {</a>
<a name="ln2665">    // The new window should use the location list from the</a>
<a name="ln2666">    // location list window</a>
<a name="ln2667">    win_set_loclist(win, ll_ref);</a>
<a name="ln2668">  }</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">// Go to a window that shows the specified file. If a window is not found, go</a>
<a name="ln2672">// to the window just above the quickfix window. This is used for opening a</a>
<a name="ln2673">// file from a quickfix window and not from a location window.</a>
<a name="ln2674">static void qf_goto_win_with_qfl_file(int qf_fnum)</a>
<a name="ln2675">{</a>
<a name="ln2676">  win_T *win = curwin;</a>
<a name="ln2677">  win_T *altwin = NULL;</a>
<a name="ln2678">  while (true) {</a>
<a name="ln2679">    if (win-&gt;w_buffer-&gt;b_fnum == qf_fnum) {</a>
<a name="ln2680">      break;</a>
<a name="ln2681">    }</a>
<a name="ln2682">    if (win-&gt;w_prev == NULL) {</a>
<a name="ln2683">      win = lastwin;      // wrap around the top</a>
<a name="ln2684">    } else {</a>
<a name="ln2685">      win = win-&gt;w_prev;  // go to previous window</a>
<a name="ln2686">    }</a>
<a name="ln2687"> </a>
<a name="ln2688">    if (IS_QF_WINDOW(win)) {</a>
<a name="ln2689">      // Didn't find it, go to the window before the quickfix</a>
<a name="ln2690">      // window, unless 'switchbuf' contains 'uselast': in this case we</a>
<a name="ln2691">      // try to jump to the previously used window first.</a>
<a name="ln2692">      if ((swb_flags &amp; SWB_USELAST) &amp;&amp; win_valid(prevwin)) {</a>
<a name="ln2693">        win = prevwin;</a>
<a name="ln2694">      } else if (altwin != NULL) {</a>
<a name="ln2695">        win = altwin;</a>
<a name="ln2696">      } else if (curwin-&gt;w_prev != NULL) {</a>
<a name="ln2697">        win = curwin-&gt;w_prev;</a>
<a name="ln2698">      } else {</a>
<a name="ln2699">        win = curwin-&gt;w_next;</a>
<a name="ln2700">      }</a>
<a name="ln2701">      break;</a>
<a name="ln2702">    }</a>
<a name="ln2703"> </a>
<a name="ln2704">    // Remember a usable window.</a>
<a name="ln2705">    if (altwin == NULL</a>
<a name="ln2706">        &amp;&amp; !win-&gt;w_p_pvw</a>
<a name="ln2707">        &amp;&amp; bt_normal(win-&gt;w_buffer)) {</a>
<a name="ln2708">      altwin = win;</a>
<a name="ln2709">    }</a>
<a name="ln2710">  }</a>
<a name="ln2711"> </a>
<a name="ln2712">  win_goto(win);</a>
<a name="ln2713">}</a>
<a name="ln2714"> </a>
<a name="ln2715">// Find a suitable window for opening a file (qf_fnum) from the</a>
<a name="ln2716">// quickfix/location list and jump to it.  If the file is already opened in a</a>
<a name="ln2717">// window, jump to it. Otherwise open a new window to display the file. If</a>
<a name="ln2718">// 'newwin' is true, then always open a new window. This is called from either</a>
<a name="ln2719">// a quickfix or a location list window.</a>
<a name="ln2720">static int qf_jump_to_usable_window(int qf_fnum, bool newwin, int *opened_window)</a>
<a name="ln2721">{</a>
<a name="ln2722">  win_T *usable_wp = NULL;</a>
<a name="ln2723">  bool usable_win = false;</a>
<a name="ln2724"> </a>
<a name="ln2725">  // If opening a new window, then don't use the location list referred by</a>
<a name="ln2726">  // the current window.  Otherwise two windows will refer to the same</a>
<a name="ln2727">  // location list.</a>
<a name="ln2728">  qf_info_T *ll_ref = newwin ? NULL : curwin-&gt;w_llist_ref;</a>
<a name="ln2729">  if (ll_ref != NULL) {</a>
<a name="ln2730">    // Find a non-quickfix window with this location list</a>
<a name="ln2731">    usable_wp = qf_find_win_with_loclist(ll_ref);</a>
<a name="ln2732">    if (usable_wp != NULL) {</a>
<a name="ln2733">      usable_win = true;</a>
<a name="ln2734">    }</a>
<a name="ln2735">  }</a>
<a name="ln2736"> </a>
<a name="ln2737">  if (!usable_win) {</a>
<a name="ln2738">    // Locate a window showing a normal buffer</a>
<a name="ln2739">    win_T *win = qf_find_win_with_normal_buf();</a>
<a name="ln2740">    if (win != NULL) {</a>
<a name="ln2741">      usable_win = true;</a>
<a name="ln2742">    }</a>
<a name="ln2743">  }</a>
<a name="ln2744"> </a>
<a name="ln2745">  // If no usable window is found and 'switchbuf' contains &quot;usetab&quot;</a>
<a name="ln2746">  // then search in other tabs.</a>
<a name="ln2747">  if (!usable_win &amp;&amp; (swb_flags &amp; SWB_USETAB)) {</a>
<a name="ln2748">    usable_win = qf_goto_tabwin_with_file(qf_fnum);</a>
<a name="ln2749">  }</a>
<a name="ln2750"> </a>
<a name="ln2751">  // If there is only one window and it is the quickfix window, create a</a>
<a name="ln2752">  // new one above the quickfix window.</a>
<a name="ln2753">  if ((ONE_WINDOW &amp;&amp; bt_quickfix(curbuf)) || !usable_win || newwin) {</a>
<a name="ln2754">    if (qf_open_new_file_win(ll_ref) != OK) {</a>
<a name="ln2755">      return FAIL;</a>
<a name="ln2756">    }</a>
<a name="ln2757">    *opened_window = true;  // close it when fail</a>
<a name="ln2758">  } else {</a>
<a name="ln2759">    if (curwin-&gt;w_llist_ref != NULL) {  // In a location window</a>
<a name="ln2760">      qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);</a>
<a name="ln2761">    } else {  // In a quickfix window</a>
<a name="ln2762">      qf_goto_win_with_qfl_file(qf_fnum);</a>
<a name="ln2763">    }</a>
<a name="ln2764">  }</a>
<a name="ln2765"> </a>
<a name="ln2766">  return OK;</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">/// Edit the selected file or help file.</a>
<a name="ln2770">/// @return  OK if successfully edited the file.</a>
<a name="ln2771">///          FAIL on failing to open the buffer.</a>
<a name="ln2772">///          QF_ABORT if the quickfix/location list was freed by an autocmd</a>
<a name="ln2773">///          when opening the buffer.</a>
<a name="ln2774">static int qf_jump_edit_buffer(qf_info_T *qi, qfline_T *qf_ptr, int forceit, int prev_winid,</a>
<a name="ln2775">                               int *opened_window)</a>
<a name="ln2776">{</a>
<a name="ln2777">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln2778">  int old_changetick = qfl-&gt;qf_changedtick;</a>
<a name="ln2779">  int old_qf_curlist = qi-&gt;qf_curlist;</a>
<a name="ln2780">  qfltype_T qfl_type = qfl-&gt;qfl_type;</a>
<a name="ln2781">  int retval = OK;</a>
<a name="ln2782">  unsigned save_qfid = qfl-&gt;qf_id;</a>
<a name="ln2783"> </a>
<a name="ln2784">  if (qf_ptr-&gt;qf_type == 1) {</a>
<a name="ln2785">    // Open help file (do_ecmd() will set b_help flag, readfile() will</a>
<a name="ln2786">    // set b_p_ro flag).</a>
<a name="ln2787">    if (!can_abandon(curbuf, forceit)) {</a>
<a name="ln2788">      no_write_message();</a>
<a name="ln2789">      return FAIL;</a>
<a name="ln2790">    }</a>
<a name="ln2791">    retval = do_ecmd(qf_ptr-&gt;qf_fnum, NULL, NULL, NULL, 1,</a>
<a name="ln2792">                     ECMD_HIDE + ECMD_SET_HELP,</a>
<a name="ln2793">                     prev_winid == curwin-&gt;handle ? curwin : NULL);</a>
<a name="ln2794">  } else {</a>
<a name="ln2795">    retval = buflist_getfile(qf_ptr-&gt;qf_fnum, 1,</a>
<a name="ln2796">                             GETF_SETMARK | GETF_SWITCH, forceit);</a>
<a name="ln2797">  }</a>
<a name="ln2798">  // If a location list, check whether the associated window is still</a>
<a name="ln2799">  // present.</a>
<a name="ln2800">  if (qfl_type == QFLT_LOCATION) {</a>
<a name="ln2801">    win_T *wp = win_id2wp(prev_winid);</a>
<a name="ln2802"> </a>
<a name="ln2803">    if (wp == NULL &amp;&amp; curwin-&gt;w_llist != qi) {</a>
<a name="ln2804">      emsg(_(&quot;E924: Current window was closed&quot;));</a>
<a name="ln2805">      *opened_window = false;</a>
<a name="ln2806">      return QF_ABORT;</a>
<a name="ln2807">    }</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  if (qfl_type == QFLT_QUICKFIX &amp;&amp; !qflist_valid(NULL, save_qfid)) {</a>
<a name="ln2811">    emsg(_(e_current_quickfix_list_was_changed));</a>
<a name="ln2812">    return QF_ABORT;</a>
<a name="ln2813">  }</a>
<a name="ln2814"> </a>
<a name="ln2815">  if (old_qf_curlist != qi-&gt;qf_curlist  // -V560</a>
<a name="ln2816">      || old_changetick != qfl-&gt;qf_changedtick  // -V560</a>
<a name="ln2817">      || !is_qf_entry_present(qfl, qf_ptr)) {</a>
<a name="ln2818">    if (qfl_type == QFLT_QUICKFIX) {</a>
<a name="ln2819">      emsg(_(e_current_quickfix_list_was_changed));</a>
<a name="ln2820">    } else {</a>
<a name="ln2821">      emsg(_(e_current_location_list_was_changed));</a>
<a name="ln2822">    }</a>
<a name="ln2823">    return QF_ABORT;</a>
<a name="ln2824">  }</a>
<a name="ln2825"> </a>
<a name="ln2826">  return retval;</a>
<a name="ln2827">}</a>
<a name="ln2828"> </a>
<a name="ln2829">/// Go to the error line in the current file using either line/column number or</a>
<a name="ln2830">/// a search pattern.</a>
<a name="ln2831">static void qf_jump_goto_line(linenr_T qf_lnum, int qf_col, char qf_viscol, char *qf_pattern)</a>
<a name="ln2832">{</a>
<a name="ln2833">  if (qf_pattern == NULL) {</a>
<a name="ln2834">    // Go to line with error, unless qf_lnum is 0.</a>
<a name="ln2835">    linenr_T i = qf_lnum;</a>
<a name="ln2836">    if (i &gt; 0) {</a>
<a name="ln2837">      if (i &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2838">        i = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2839">      }</a>
<a name="ln2840">      curwin-&gt;w_cursor.lnum = i;</a>
<a name="ln2841">    }</a>
<a name="ln2842">    if (qf_col &gt; 0) {</a>
<a name="ln2843">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2844">      if (qf_viscol == true) {</a>
<a name="ln2845">        coladvance(qf_col - 1);</a>
<a name="ln2846">      } else {</a>
<a name="ln2847">        curwin-&gt;w_cursor.col = qf_col - 1;</a>
<a name="ln2848">      }</a>
<a name="ln2849">      curwin-&gt;w_set_curswant = true;</a>
<a name="ln2850">      check_cursor();</a>
<a name="ln2851">    } else {</a>
<a name="ln2852">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln2853">    }</a>
<a name="ln2854">  } else {</a>
<a name="ln2855">    // Move the cursor to the first line in the buffer</a>
<a name="ln2856">    pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2857">    curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln2858">    if (!do_search(NULL, '/', '/', qf_pattern, 1, SEARCH_KEEP, NULL)) {</a>
<a name="ln2859">      curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln2860">    }</a>
<a name="ln2861">  }</a>
<a name="ln2862">}</a>
<a name="ln2863"> </a>
<a name="ln2864">/// Display quickfix list index and size message</a>
<a name="ln2865">static void qf_jump_print_msg(qf_info_T *qi, int qf_index, qfline_T *qf_ptr, buf_T *old_curbuf,</a>
<a name="ln2866">                              linenr_T old_lnum)</a>
<a name="ln2867">{</a>
<a name="ln2868">  garray_T *const gap = qfga_get();</a>
<a name="ln2869"> </a>
<a name="ln2870">  // Update the screen before showing the message, unless the screen</a>
<a name="ln2871">  // scrolled up.</a>
<a name="ln2872">  if (!msg_scrolled) {</a>
<a name="ln2873">    update_topline(curwin);</a>
<a name="ln2874">    if (must_redraw) {</a>
<a name="ln2875">      update_screen();</a>
<a name="ln2876">    }</a>
<a name="ln2877">  }</a>
<a name="ln2878">  vim_snprintf(IObuff, IOSIZE, _(&quot;(%d of %d)%s%s: &quot;), qf_index,</a>
<a name="ln2879">               qf_get_curlist(qi)-&gt;qf_count,</a>
<a name="ln2880">               qf_ptr-&gt;qf_cleared ? _(&quot; (line deleted)&quot;) : &quot;&quot;,</a>
<a name="ln2881">               qf_types(qf_ptr-&gt;qf_type, qf_ptr-&gt;qf_nr));</a>
<a name="ln2882">  // Add the message, skipping leading whitespace and newlines.</a>
<a name="ln2883">  ga_concat(gap, IObuff);</a>
<a name="ln2884">  qf_fmt_text(gap, skipwhite(qf_ptr-&gt;qf_text));</a>
<a name="ln2885">  ga_append(gap, NUL);</a>
<a name="ln2886"> </a>
<a name="ln2887">  // Output the message.  Overwrite to avoid scrolling when the 'O'</a>
<a name="ln2888">  // flag is present in 'shortmess'; But when not jumping, print the</a>
<a name="ln2889">  // whole message.</a>
<a name="ln2890">  linenr_T i = msg_scroll;</a>
<a name="ln2891">  if (curbuf == old_curbuf &amp;&amp; curwin-&gt;w_cursor.lnum == old_lnum) {</a>
<a name="ln2892">    msg_scroll = true;</a>
<a name="ln2893">  } else if (!msg_scrolled &amp;&amp; shortmess(SHM_OVERALL)) {</a>
<a name="ln2894">    msg_scroll = false;</a>
<a name="ln2895">  }</a>
<a name="ln2896">  msg_ext_set_kind(&quot;quickfix&quot;);</a>
<a name="ln2897">  msg_attr_keep(gap-&gt;ga_data, 0, true, false);</a>
<a name="ln2898">  msg_scroll = (int)i;</a>
<a name="ln2899"> </a>
<a name="ln2900">  qfga_clear();</a>
<a name="ln2901">}</a>
<a name="ln2902"> </a>
<a name="ln2903">/// Find a usable window for opening a file from the quickfix/location list. If</a>
<a name="ln2904">/// a window is not found then open a new window. If 'newwin' is true, then open</a>
<a name="ln2905">/// a new window.</a>
<a name="ln2906">/// @return  OK if successfully jumped or opened a window.</a>
<a name="ln2907">///          FAIL if not able to jump/open a window.</a>
<a name="ln2908">///          NOTDONE if a file is not associated with the entry.</a>
<a name="ln2909">///          QF_ABORT if the quickfix/location list was modified by an autocmd.</a>
<a name="ln2910">static int qf_jump_open_window(qf_info_T *qi, qfline_T *qf_ptr, bool newwin, int *opened_window)</a>
<a name="ln2911">{</a>
<a name="ln2912">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln2913">  int old_changetick = qfl-&gt;qf_changedtick;</a>
<a name="ln2914">  int old_qf_curlist = qi-&gt;qf_curlist;</a>
<a name="ln2915">  qfltype_T qfl_type = qfl-&gt;qfl_type;</a>
<a name="ln2916"> </a>
<a name="ln2917">  // For &quot;:helpgrep&quot; find a help window or open one.</a>
<a name="ln2918">  if (qf_ptr-&gt;qf_type == 1 &amp;&amp; (!bt_help(curwin-&gt;w_buffer) || cmdmod.cmod_tab != 0)) {</a>
<a name="ln2919">    if (jump_to_help_window(qi, newwin, opened_window) == FAIL) {</a>
<a name="ln2920">      return FAIL;</a>
<a name="ln2921">    }</a>
<a name="ln2922">  }</a>
<a name="ln2923">  if (old_qf_curlist != qi-&gt;qf_curlist</a>
<a name="ln2924">      || old_changetick != qfl-&gt;qf_changedtick  // -V560</a>
<a name="ln2925">      || !is_qf_entry_present(qfl, qf_ptr)) {</a>
<a name="ln2926">    if (qfl_type == QFLT_QUICKFIX) {</a>
<a name="ln2927">      emsg(_(e_current_quickfix_list_was_changed));</a>
<a name="ln2928">    } else {</a>
<a name="ln2929">      emsg(_(e_current_location_list_was_changed));</a>
<a name="ln2930">    }</a>
<a name="ln2931">    return QF_ABORT;</a>
<a name="ln2932">  }</a>
<a name="ln2933"> </a>
<a name="ln2934">  // If currently in the quickfix window, find another window to show the</a>
<a name="ln2935">  // file in.</a>
<a name="ln2936">  if (bt_quickfix(curbuf) &amp;&amp; !*opened_window) {</a>
<a name="ln2937">    // If there is no file specified, we don't know where to go.</a>
<a name="ln2938">    // But do advance, otherwise &quot;:cn&quot; gets stuck.</a>
<a name="ln2939">    if (qf_ptr-&gt;qf_fnum == 0) {</a>
<a name="ln2940">      return NOTDONE;</a>
<a name="ln2941">    }</a>
<a name="ln2942"> </a>
<a name="ln2943">    if (qf_jump_to_usable_window(qf_ptr-&gt;qf_fnum, newwin, opened_window)</a>
<a name="ln2944">        == FAIL) {</a>
<a name="ln2945">      return FAIL;</a>
<a name="ln2946">    }</a>
<a name="ln2947">  }</a>
<a name="ln2948">  if (old_qf_curlist != qi-&gt;qf_curlist</a>
<a name="ln2949">      || old_changetick != qfl-&gt;qf_changedtick</a>
<a name="ln2950">      || !is_qf_entry_present(qfl, qf_ptr)) {</a>
<a name="ln2951">    if (qfl_type == QFLT_QUICKFIX) {</a>
<a name="ln2952">      emsg(_(e_current_quickfix_list_was_changed));</a>
<a name="ln2953">    } else {</a>
<a name="ln2954">      emsg(_(e_current_location_list_was_changed));</a>
<a name="ln2955">    }</a>
<a name="ln2956">    return QF_ABORT;</a>
<a name="ln2957">  }</a>
<a name="ln2958"> </a>
<a name="ln2959">  return OK;</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962">/// Edit a selected file from the quickfix/location list and jump to a</a>
<a name="ln2963">/// particular line/column, adjust the folds and display a message about the</a>
<a name="ln2964">/// jump.</a>
<a name="ln2965">/// @return  OK on success and FAIL on failing to open the file/buffer.</a>
<a name="ln2966">///          QF_ABORT if the quickfix/location list is freed by an autocmd when opening</a>
<a name="ln2967">///          the file.</a>
<a name="ln2968">static int qf_jump_to_buffer(qf_info_T *qi, int qf_index, qfline_T *qf_ptr, int forceit,</a>
<a name="ln2969">                             int prev_winid, int *opened_window, int openfold, int print_message)</a>
<a name="ln2970">{</a>
<a name="ln2971">  // If there is a file name, read the wanted file if needed, and check</a>
<a name="ln2972">  // autowrite etc.</a>
<a name="ln2973">  buf_T *old_curbuf = curbuf;</a>
<a name="ln2974">  linenr_T old_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2975">  int retval = OK;</a>
<a name="ln2976"> </a>
<a name="ln2977">  if (qf_ptr-&gt;qf_fnum != 0) {</a>
<a name="ln2978">    retval = qf_jump_edit_buffer(qi, qf_ptr, forceit, prev_winid,</a>
<a name="ln2979">                                 opened_window);</a>
<a name="ln2980">    if (retval != OK) {</a>
<a name="ln2981">      return retval;</a>
<a name="ln2982">    }</a>
<a name="ln2983">  }</a>
<a name="ln2984"> </a>
<a name="ln2985">  // When not switched to another buffer, still need to set pc mark</a>
<a name="ln2986">  if (curbuf == old_curbuf) {</a>
<a name="ln2987">    setpcmark();</a>
<a name="ln2988">  }</a>
<a name="ln2989"> </a>
<a name="ln2990">  qf_jump_goto_line(qf_ptr-&gt;qf_lnum, qf_ptr-&gt;qf_col, qf_ptr-&gt;qf_viscol, qf_ptr-&gt;qf_pattern);</a>
<a name="ln2991"> </a>
<a name="ln2992">  if ((fdo_flags &amp; FDO_QUICKFIX) &amp;&amp; openfold) {</a>
<a name="ln2993">    foldOpenCursor();</a>
<a name="ln2994">  }</a>
<a name="ln2995">  if (print_message) {</a>
<a name="ln2996">    qf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);</a>
<a name="ln2997">  }</a>
<a name="ln2998"> </a>
<a name="ln2999">  return retval;</a>
<a name="ln3000">}</a>
<a name="ln3001"> </a>
<a name="ln3002">/// Jump to a quickfix line and try to use an existing window.</a>
<a name="ln3003">void qf_jump(qf_info_T *qi, int dir, int errornr, int forceit)</a>
<a name="ln3004">{</a>
<a name="ln3005">  qf_jump_newwin(qi, dir, errornr, forceit, false);</a>
<a name="ln3006">}</a>
<a name="ln3007"> </a>
<a name="ln3008">// Jump to a quickfix line.</a>
<a name="ln3009">// If dir == 0 go to entry &quot;errornr&quot;.</a>
<a name="ln3010">// If dir == FORWARD go &quot;errornr&quot; valid entries forward.</a>
<a name="ln3011">// If dir == BACKWARD go &quot;errornr&quot; valid entries backward.</a>
<a name="ln3012">// If dir == FORWARD_FILE go &quot;errornr&quot; valid entries files backward.</a>
<a name="ln3013">// If dir == BACKWARD_FILE go &quot;errornr&quot; valid entries files backward</a>
<a name="ln3014">// else if &quot;errornr&quot; is zero, redisplay the same line</a>
<a name="ln3015">// If 'forceit' is true, then can discard changes to the current buffer.</a>
<a name="ln3016">// If 'newwin' is true, then open the file in a new window.</a>
<a name="ln3017">static void qf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit, bool newwin)</a>
<a name="ln3018">{</a>
<a name="ln3019">  char *old_swb = p_swb;</a>
<a name="ln3020">  unsigned old_swb_flags = swb_flags;</a>
<a name="ln3021">  const bool old_KeyTyped = KeyTyped;           // getting file may reset it</a>
<a name="ln3022"> </a>
<a name="ln3023">  if (qi == NULL) {</a>
<a name="ln3024">    qi = &amp;ql_info;</a>
<a name="ln3025">  }</a>
<a name="ln3026"> </a>
<a name="ln3027">  if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln3028">    emsg(_(e_no_errors));</a>
<a name="ln3029">    return;</a>
<a name="ln3030">  }</a>
<a name="ln3031"> </a>
<a name="ln3032">  incr_quickfix_busy();</a>
<a name="ln3033"> </a>
<a name="ln3034">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln3035"> </a>
<a name="ln3036">  qfline_T *qf_ptr = qfl-&gt;qf_ptr;</a>
<a name="ln3037">  qfline_T *old_qf_ptr = qf_ptr;</a>
<a name="ln3038">  int qf_index = qfl-&gt;qf_index;</a>
<a name="ln3039">  int old_qf_index = qf_index;</a>
<a name="ln3040"> </a>
<a name="ln3041">  qf_ptr = qf_get_entry(qfl, errornr, dir, &amp;qf_index);</a>
<a name="ln3042">  if (qf_ptr == NULL) {</a>
<a name="ln3043">    qf_ptr = old_qf_ptr;</a>
<a name="ln3044">    qf_index = old_qf_index;</a>
<a name="ln3045">    goto theend;</a>
<a name="ln3046">  }</a>
<a name="ln3047"> </a>
<a name="ln3048">  qfl-&gt;qf_index = qf_index;</a>
<a name="ln3049">  qfl-&gt;qf_ptr = qf_ptr;</a>
<a name="ln3050"> </a>
<a name="ln3051">  // No need to print the error message if it's visible in the error window</a>
<a name="ln3052">  bool print_message = !qf_win_pos_update(qi, old_qf_index);</a>
<a name="ln3053"> </a>
<a name="ln3054">  int prev_winid = curwin-&gt;handle;</a>
<a name="ln3055"> </a>
<a name="ln3056">  int opened_window = false;</a>
<a name="ln3057">  int retval = qf_jump_open_window(qi, qf_ptr, newwin, &amp;opened_window);</a>
<a name="ln3058">  if (retval == FAIL) {</a>
<a name="ln3059">    goto failed;</a>
<a name="ln3060">  }</a>
<a name="ln3061">  if (retval == QF_ABORT) {</a>
<a name="ln3062">    qi = NULL;</a>
<a name="ln3063">    qf_ptr = NULL;</a>
<a name="ln3064">    goto theend;</a>
<a name="ln3065">  }</a>
<a name="ln3066">  if (retval == NOTDONE) {</a>
<a name="ln3067">    goto theend;</a>
<a name="ln3068">  }</a>
<a name="ln3069"> </a>
<a name="ln3070">  retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,</a>
<a name="ln3071">                             &amp;opened_window, old_KeyTyped, print_message);</a>
<a name="ln3072">  if (retval == QF_ABORT) {</a>
<a name="ln3073">    // Quickfix/location list was modified by an autocmd</a>
<a name="ln3074">    qi = NULL;</a>
<a name="ln3075">    qf_ptr = NULL;</a>
<a name="ln3076">  }</a>
<a name="ln3077"> </a>
<a name="ln3078">  if (retval != OK) {</a>
<a name="ln3079">    if (opened_window) {</a>
<a name="ln3080">      win_close(curwin, true, false);          // Close opened window</a>
<a name="ln3081">    }</a>
<a name="ln3082">    if (qf_ptr != NULL &amp;&amp; qf_ptr-&gt;qf_fnum != 0) {</a>
<a name="ln3083">      // Couldn't open file, so put index back where it was.  This could</a>
<a name="ln3084">      // happen if the file was readonly and we changed something.</a>
<a name="ln3085">failed:</a>
<a name="ln3086">      qf_ptr = old_qf_ptr;</a>
<a name="ln3087">      qf_index = old_qf_index;</a>
<a name="ln3088">    }</a>
<a name="ln3089">  }</a>
<a name="ln3090">theend:</a>
<a name="ln3091">  if (qi != NULL) {</a>
<a name="ln3092">    qfl-&gt;qf_ptr = qf_ptr;</a>
<a name="ln3093">    qfl-&gt;qf_index = qf_index;</a>
<a name="ln3094">  }</a>
<a name="ln3095">  if (p_swb != old_swb &amp;&amp; p_swb == empty_string_option) {</a>
<a name="ln3096">    // Restore old 'switchbuf' value, but not when an autocommand or</a>
<a name="ln3097">    // modeline has changed the value.</a>
<a name="ln3098">    p_swb = old_swb;</a>
<a name="ln3099">    swb_flags = old_swb_flags;</a>
<a name="ln3100">  }</a>
<a name="ln3101">  decr_quickfix_busy();</a>
<a name="ln3102">}</a>
<a name="ln3103"> </a>
<a name="ln3104">// Highlight attributes used for displaying entries from the quickfix list.</a>
<a name="ln3105">static int qfFileAttr;</a>
<a name="ln3106">static int qfSepAttr;</a>
<a name="ln3107">static int qfLineAttr;</a>
<a name="ln3108"> </a>
<a name="ln3109">/// Display information about a single entry from the quickfix/location list.</a>
<a name="ln3110">/// Used by &quot;:clist/:llist&quot; commands.</a>
<a name="ln3111">/// 'cursel' will be set to true for the currently selected entry in the</a>
<a name="ln3112">/// quickfix list.</a>
<a name="ln3113">static void qf_list_entry(qfline_T *qfp, int qf_idx, bool cursel)</a>
<a name="ln3114">{</a>
<a name="ln3115">  char *fname = NULL;</a>
<a name="ln3116">  if (qfp-&gt;qf_module != NULL &amp;&amp; *qfp-&gt;qf_module != NUL) {</a>
<a name="ln3117">    vim_snprintf(IObuff, IOSIZE, &quot;%2d %s&quot;, qf_idx, qfp-&gt;qf_module);</a>
<a name="ln3118">  } else {</a>
<a name="ln3119">    buf_T *buf;</a>
<a name="ln3120">    if (qfp-&gt;qf_fnum != 0</a>
<a name="ln3121">        &amp;&amp; (buf = buflist_findnr(qfp-&gt;qf_fnum)) != NULL) {</a>
<a name="ln3122">      fname = buf-&gt;b_fname;</a>
<a name="ln3123">      if (qfp-&gt;qf_type == 1) {  // :helpgrep</a>
<a name="ln3124">        fname = path_tail(fname);</a>
<a name="ln3125">      }</a>
<a name="ln3126">    }</a>
<a name="ln3127">    if (fname == NULL) {</a>
<a name="ln3128">      snprintf(IObuff, IOSIZE, &quot;%2d&quot;, qf_idx);</a>
<a name="ln3129">    } else {</a>
<a name="ln3130">      vim_snprintf(IObuff, IOSIZE, &quot;%2d %s&quot;, qf_idx, fname);</a>
<a name="ln3131">    }</a>
<a name="ln3132">  }</a>
<a name="ln3133"> </a>
<a name="ln3134">  // Support for filtering entries using :filter /pat/ clist</a>
<a name="ln3135">  // Match against the module name, file name, search pattern and</a>
<a name="ln3136">  // text of the entry.</a>
<a name="ln3137">  bool filter_entry = true;</a>
<a name="ln3138">  if (qfp-&gt;qf_module != NULL &amp;&amp; *qfp-&gt;qf_module != NUL) {</a>
<a name="ln3139">    filter_entry &amp;= message_filtered(qfp-&gt;qf_module);</a>
<a name="ln3140">  }</a>
<a name="ln3141">  if (filter_entry &amp;&amp; fname != NULL) {</a>
<a name="ln3142">    filter_entry &amp;= message_filtered(fname);</a>
<a name="ln3143">  }</a>
<a name="ln3144">  if (filter_entry &amp;&amp; qfp-&gt;qf_pattern != NULL) {</a>
<a name="ln3145">    filter_entry &amp;= message_filtered(qfp-&gt;qf_pattern);</a>
<a name="ln3146">  }</a>
<a name="ln3147">  if (filter_entry) {</a>
<a name="ln3148">    filter_entry &amp;= message_filtered(qfp-&gt;qf_text);</a>
<a name="ln3149">  }</a>
<a name="ln3150">  if (filter_entry) {</a>
<a name="ln3151">    return;</a>
<a name="ln3152">  }</a>
<a name="ln3153"> </a>
<a name="ln3154">  msg_putchar('\n');</a>
<a name="ln3155">  msg_outtrans(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);</a>
<a name="ln3156"> </a>
<a name="ln3157">  if (qfp-&gt;qf_lnum != 0) {</a>
<a name="ln3158">    msg_puts_attr(&quot;:&quot;, qfSepAttr);</a>
<a name="ln3159">  }</a>
<a name="ln3160">  garray_T *gap = qfga_get();</a>
<a name="ln3161">  if (qfp-&gt;qf_lnum != 0) {</a>
<a name="ln3162">    qf_range_text(gap, qfp);</a>
<a name="ln3163">  }</a>
<a name="ln3164">  ga_concat(gap, qf_types(qfp-&gt;qf_type, qfp-&gt;qf_nr));</a>
<a name="ln3165">  ga_append(gap, NUL);</a>
<a name="ln3166">  msg_puts_attr(gap-&gt;ga_data, qfLineAttr);</a>
<a name="ln3167">  msg_puts_attr(&quot;:&quot;, qfSepAttr);</a>
<a name="ln3168">  if (qfp-&gt;qf_pattern != NULL) {</a>
<a name="ln3169">    gap = qfga_get();</a>
<a name="ln3170">    qf_fmt_text(gap, qfp-&gt;qf_pattern);</a>
<a name="ln3171">    ga_append(gap, NUL);</a>
<a name="ln3172">    msg_puts(gap-&gt;ga_data);</a>
<a name="ln3173">    msg_puts_attr(&quot;:&quot;, qfSepAttr);</a>
<a name="ln3174">  }</a>
<a name="ln3175">  msg_puts(&quot; &quot;);</a>
<a name="ln3176"> </a>
<a name="ln3177">  // Remove newlines and leading whitespace from the text.  For an</a>
<a name="ln3178">  // unrecognized line keep the indent, the compiler may mark a word</a>
<a name="ln3179">  // with ^^^^.</a>
<a name="ln3180">  gap = qfga_get();</a>
<a name="ln3181">  qf_fmt_text(gap, (fname != NULL || qfp-&gt;qf_lnum != 0) ? skipwhite(qfp-&gt;qf_text) : qfp-&gt;qf_text);</a>
<a name="ln3182">  ga_append(gap, NUL);</a>
<a name="ln3183">  msg_prt_line(gap-&gt;ga_data, false);</a>
<a name="ln3184">}</a>
<a name="ln3185"> </a>
<a name="ln3186">// &quot;:clist&quot;: list all errors</a>
<a name="ln3187">// &quot;:llist&quot;: list all locations</a>
<a name="ln3188">void qf_list(exarg_T *eap)</a>
<a name="ln3189">{</a>
<a name="ln3190">  char *arg = eap-&gt;arg;</a>
<a name="ln3191">  int all = eap-&gt;forceit;     // if not :cl!, only show recognised errors</a>
<a name="ln3192">  qf_info_T *qi = qf_cmd_get_stack(eap, true);</a>
<a name="ln3193"> </a>
<a name="ln3194">  if (qi == NULL) {</a>
<a name="ln3195">    return;</a>
<a name="ln3196">  }</a>
<a name="ln3197"> </a>
<a name="ln3198">  if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln3199">    emsg(_(e_no_errors));</a>
<a name="ln3200">    return;</a>
<a name="ln3201">  }</a>
<a name="ln3202"> </a>
<a name="ln3203">  bool plus = false;</a>
<a name="ln3204">  if (*arg == '+') {</a>
<a name="ln3205">    arg++;</a>
<a name="ln3206">    plus = true;</a>
<a name="ln3207">  }</a>
<a name="ln3208">  int idx1 = 1;</a>
<a name="ln3209">  int idx2 = -1;</a>
<a name="ln3210">  if (!get_list_range(&amp;arg, &amp;idx1, &amp;idx2) || *arg != NUL) {</a>
<a name="ln3211">    semsg(_(e_trailing_arg), arg);</a>
<a name="ln3212">    return;</a>
<a name="ln3213">  }</a>
<a name="ln3214">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln3215">  int i;</a>
<a name="ln3216">  if (plus) {</a>
<a name="ln3217">    i = qfl-&gt;qf_index;</a>
<a name="ln3218">    idx2 = i + idx1;</a>
<a name="ln3219">    idx1 = i;</a>
<a name="ln3220">  } else {</a>
<a name="ln3221">    i = qfl-&gt;qf_count;</a>
<a name="ln3222">    if (idx1 &lt; 0) {</a>
<a name="ln3223">      idx1 = (-idx1 &gt; i) ? 0 : idx1 + i + 1;</a>
<a name="ln3224">    }</a>
<a name="ln3225">    if (idx2 &lt; 0) {</a>
<a name="ln3226">      idx2 = (-idx2 &gt; i) ? 0 : idx2 + i + 1;</a>
<a name="ln3227">    }</a>
<a name="ln3228">  }</a>
<a name="ln3229"> </a>
<a name="ln3230">  // Shorten all the file names, so that it is easy to read.</a>
<a name="ln3231">  shorten_fnames(false);</a>
<a name="ln3232"> </a>
<a name="ln3233">  // Get the attributes for the different quickfix highlight items.  Note</a>
<a name="ln3234">  // that this depends on syntax items defined in the qf.vim syntax file</a>
<a name="ln3235">  qfFileAttr = syn_name2attr(&quot;qfFileName&quot;);</a>
<a name="ln3236">  if (qfFileAttr == 0) {</a>
<a name="ln3237">    qfFileAttr = HL_ATTR(HLF_D);</a>
<a name="ln3238">  }</a>
<a name="ln3239">  qfSepAttr = syn_name2attr(&quot;qfSeparator&quot;);</a>
<a name="ln3240">  if (qfSepAttr == 0) {</a>
<a name="ln3241">    qfSepAttr = HL_ATTR(HLF_D);</a>
<a name="ln3242">  }</a>
<a name="ln3243">  qfLineAttr = syn_name2attr(&quot;qfLineNr&quot;);</a>
<a name="ln3244">  if (qfLineAttr == 0) {</a>
<a name="ln3245">    qfLineAttr = HL_ATTR(HLF_N);</a>
<a name="ln3246">  }</a>
<a name="ln3247"> </a>
<a name="ln3248">  if (qfl-&gt;qf_nonevalid) {</a>
<a name="ln3249">    all = true;</a>
<a name="ln3250">  }</a>
<a name="ln3251">  qfline_T *qfp;</a>
<a name="ln3252">  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln3253">    if ((qfp-&gt;qf_valid || all) &amp;&amp; idx1 &lt;= i &amp;&amp; i &lt;= idx2) {</a>
<a name="ln3254">      qf_list_entry(qfp, i, i == qfl-&gt;qf_index);</a>
<a name="ln3255">    }</a>
<a name="ln3256">    os_breakcheck();</a>
<a name="ln3257">  }</a>
<a name="ln3258">  qfga_clear();</a>
<a name="ln3259">}</a>
<a name="ln3260"> </a>
<a name="ln3261">/// Remove newlines and leading whitespace from an error message.</a>
<a name="ln3262">/// Add the result to the grow array &quot;gap&quot;.</a>
<a name="ln3263">static void qf_fmt_text(garray_T *gap, const char *restrict text)</a>
<a name="ln3264">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3265">{</a>
<a name="ln3266">  const char *p = text;</a>
<a name="ln3267">  while (*p != NUL) {</a>
<a name="ln3268">    if (*p == '\n') {</a>
<a name="ln3269">      ga_append(gap, ' ');</a>
<a name="ln3270">      while (*++p != NUL) {</a>
<a name="ln3271">        if (!ascii_iswhite(*p) &amp;&amp; *p != '\n') {</a>
<a name="ln3272">          break;</a>
<a name="ln3273">        }</a>
<a name="ln3274">      }</a>
<a name="ln3275">    } else {</a>
<a name="ln3276">      ga_append(gap, (uint8_t)(*p++));</a>
<a name="ln3277">    }</a>
<a name="ln3278">  }</a>
<a name="ln3279">}</a>
<a name="ln3280"> </a>
<a name="ln3281">/// Add the range information from the lnum, col, end_lnum, and end_col values</a>
<a name="ln3282">/// of a quickfix entry to the grow array &quot;gap&quot;.</a>
<a name="ln3283">static void qf_range_text(garray_T *gap, const qfline_T *qfp)</a>
<a name="ln3284">{</a>
<a name="ln3285">  char *const buf = IObuff;</a>
<a name="ln3286">  const size_t bufsize = IOSIZE;</a>
<a name="ln3287"> </a>
<a name="ln3288">  vim_snprintf(buf, bufsize, &quot;%&quot; PRIdLINENR, qfp-&gt;qf_lnum);</a>
<a name="ln3289">  size_t len = strlen(buf);</a>
<a name="ln3290"> </a>
<a name="ln3291">  if (qfp-&gt;qf_end_lnum &gt; 0 &amp;&amp; qfp-&gt;qf_lnum != qfp-&gt;qf_end_lnum) {</a>
<a name="ln3292">    vim_snprintf(buf + len, bufsize - len, &quot;-%&quot; PRIdLINENR, qfp-&gt;qf_end_lnum);</a>
<a name="ln3293">    len += strlen(buf + len);</a>
<a name="ln3294">  }</a>
<a name="ln3295">  if (qfp-&gt;qf_col &gt; 0) {</a>
<a name="ln3296">    vim_snprintf(buf + len, bufsize - len, &quot; col %d&quot;, qfp-&gt;qf_col);</a>
<a name="ln3297">    len += strlen(buf + len);</a>
<a name="ln3298">    if (qfp-&gt;qf_end_col &gt; 0 &amp;&amp; qfp-&gt;qf_col != qfp-&gt;qf_end_col) {</a>
<a name="ln3299">      vim_snprintf(buf + len, bufsize - len, &quot;-%d&quot;, qfp-&gt;qf_end_col);</a>
<a name="ln3300">      len += strlen(buf + len);</a>
<a name="ln3301">    }</a>
<a name="ln3302">  }</a>
<a name="ln3303"> </a>
<a name="ln3304">  ga_concat_len(gap, buf, len);</a>
<a name="ln3305">}</a>
<a name="ln3306"> </a>
<a name="ln3307">/// Display information (list number, list size and the title) about a</a>
<a name="ln3308">/// quickfix/location list.</a>
<a name="ln3309">static void qf_msg(qf_info_T *qi, int which, char *lead)</a>
<a name="ln3310">{</a>
<a name="ln3311">  char *title = qi-&gt;qf_lists[which].qf_title;</a>
<a name="ln3312">  int count = qi-&gt;qf_lists[which].qf_count;</a>
<a name="ln3313">  char buf[IOSIZE];</a>
<a name="ln3314"> </a>
<a name="ln3315">  vim_snprintf(buf, IOSIZE, _(&quot;%serror list %d of %d; %d errors &quot;),</a>
<a name="ln3316">               lead,</a>
<a name="ln3317">               which + 1,</a>
<a name="ln3318">               qi-&gt;qf_listcount,</a>
<a name="ln3319">               count);</a>
<a name="ln3320"> </a>
<a name="ln3321">  if (title != NULL) {</a>
<a name="ln3322">    size_t len = strlen(buf);</a>
<a name="ln3323"> </a>
<a name="ln3324">    if (len &lt; 34) {</a>
<a name="ln3325">      memset(buf + len, ' ', 34 - len);</a>
<a name="ln3326">      buf[34] = NUL;</a>
<a name="ln3327">    }</a>
<a name="ln3328">    xstrlcat(buf, title, IOSIZE);</a>
<a name="ln3329">  }</a>
<a name="ln3330">  trunc_string(buf, buf, Columns - 1, IOSIZE);</a>
<a name="ln3331">  msg(buf, 0);</a>
<a name="ln3332">}</a>
<a name="ln3333"> </a>
<a name="ln3334">/// &quot;:colder [count]&quot;: Up in the quickfix stack.</a>
<a name="ln3335">/// &quot;:cnewer [count]&quot;: Down in the quickfix stack.</a>
<a name="ln3336">/// &quot;:lolder [count]&quot;: Up in the location list stack.</a>
<a name="ln3337">/// &quot;:lnewer [count]&quot;: Down in the location list stack.</a>
<a name="ln3338">void qf_age(exarg_T *eap)</a>
<a name="ln3339">{</a>
<a name="ln3340">  qf_info_T *qi;</a>
<a name="ln3341"> </a>
<a name="ln3342">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln3343">    return;</a>
<a name="ln3344">  }</a>
<a name="ln3345"> </a>
<a name="ln3346">  int count = (eap-&gt;addr_count != 0) ? (int)eap-&gt;line2 : 1;</a>
<a name="ln3347">  while (count--) {</a>
<a name="ln3348">    if (eap-&gt;cmdidx == CMD_colder || eap-&gt;cmdidx == CMD_lolder) {</a>
<a name="ln3349">      if (qi-&gt;qf_curlist == 0) {</a>
<a name="ln3350">        emsg(_(&quot;E380: At bottom of quickfix stack&quot;));</a>
<a name="ln3351">        break;</a>
<a name="ln3352">      }</a>
<a name="ln3353">      qi-&gt;qf_curlist--;</a>
<a name="ln3354">    } else {</a>
<a name="ln3355">      if (qi-&gt;qf_curlist &gt;= qi-&gt;qf_listcount - 1) {</a>
<a name="ln3356">        emsg(_(&quot;E381: At top of quickfix stack&quot;));</a>
<a name="ln3357">        break;</a>
<a name="ln3358">      }</a>
<a name="ln3359">      qi-&gt;qf_curlist++;</a>
<a name="ln3360">    }</a>
<a name="ln3361">  }</a>
<a name="ln3362">  qf_msg(qi, qi-&gt;qf_curlist, &quot;&quot;);</a>
<a name="ln3363">  qf_update_buffer(qi, NULL);</a>
<a name="ln3364">}</a>
<a name="ln3365"> </a>
<a name="ln3366">/// Display the information about all the quickfix/location lists in the stack.</a>
<a name="ln3367">void qf_history(exarg_T *eap)</a>
<a name="ln3368">{</a>
<a name="ln3369">  qf_info_T *qi = qf_cmd_get_stack(eap, false);</a>
<a name="ln3370"> </a>
<a name="ln3371">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln3372">    if (qi == NULL) {</a>
<a name="ln3373">      emsg(_(e_loclist));</a>
<a name="ln3374">      return;</a>
<a name="ln3375">    }</a>
<a name="ln3376"> </a>
<a name="ln3377">    // Jump to the specified quickfix list</a>
<a name="ln3378">    if (eap-&gt;line2 &gt; 0 &amp;&amp; eap-&gt;line2 &lt;= qi-&gt;qf_listcount) {</a>
<a name="ln3379">      qi-&gt;qf_curlist = eap-&gt;line2 - 1;</a>
<a name="ln3380">      qf_msg(qi, qi-&gt;qf_curlist, &quot;&quot;);</a>
<a name="ln3381">      qf_update_buffer(qi, NULL);</a>
<a name="ln3382">    } else {</a>
<a name="ln3383">      emsg(_(e_invrange));</a>
<a name="ln3384">    }</a>
<a name="ln3385"> </a>
<a name="ln3386">    return;</a>
<a name="ln3387">  }</a>
<a name="ln3388"> </a>
<a name="ln3389">  if (qf_stack_empty(qi)) {</a>
<a name="ln3390">    msg(_(&quot;No entries&quot;), 0);</a>
<a name="ln3391">  } else {</a>
<a name="ln3392">    for (int i = 0; i &lt; qi-&gt;qf_listcount; i++) {</a>
<a name="ln3393">      qf_msg(qi, i, i == qi-&gt;qf_curlist ? &quot;&gt; &quot; : &quot;  &quot;);</a>
<a name="ln3394">    }</a>
<a name="ln3395">  }</a>
<a name="ln3396">}</a>
<a name="ln3397"> </a>
<a name="ln3398">/// Free all the entries in the error list &quot;idx&quot;. Note that other information</a>
<a name="ln3399">/// associated with the list like context and title are not freed.</a>
<a name="ln3400">static void qf_free_items(qf_list_T *qfl)</a>
<a name="ln3401">{</a>
<a name="ln3402">  bool stop = false;</a>
<a name="ln3403"> </a>
<a name="ln3404">  while (qfl-&gt;qf_count &amp;&amp; qfl-&gt;qf_start != NULL) {</a>
<a name="ln3405">    qfline_T *qfp = qfl-&gt;qf_start;</a>
<a name="ln3406">    qfline_T *qfpnext = qfp-&gt;qf_next;</a>
<a name="ln3407">    if (!stop) {</a>
<a name="ln3408">      xfree(qfp-&gt;qf_module);</a>
<a name="ln3409">      xfree(qfp-&gt;qf_text);</a>
<a name="ln3410">      xfree(qfp-&gt;qf_pattern);</a>
<a name="ln3411">      tv_clear(&amp;qfp-&gt;qf_user_data);</a>
<a name="ln3412">      stop = (qfp == qfpnext);</a>
<a name="ln3413">      xfree(qfp);</a>
<a name="ln3414">      if (stop) {</a>
<a name="ln3415">        // Somehow qf_count may have an incorrect value, set it to 1</a>
<a name="ln3416">        // to avoid crashing when it's wrong.</a>
<a name="ln3417">        // TODO(vim): Avoid qf_count being incorrect.</a>
<a name="ln3418">        qfl-&gt;qf_count = 1;</a>
<a name="ln3419">      }</a>
<a name="ln3420">    }</a>
<a name="ln3421">    qfl-&gt;qf_start = qfpnext;</a>
<a name="ln3422">    qfl-&gt;qf_count--;</a>
<a name="ln3423">  }</a>
<a name="ln3424"> </a>
<a name="ln3425">  qfl-&gt;qf_start = NULL;</a>
<a name="ln3426">  qfl-&gt;qf_ptr = NULL;</a>
<a name="ln3427">  qfl-&gt;qf_index = 0;</a>
<a name="ln3428">  qfl-&gt;qf_start = NULL;</a>
<a name="ln3429">  qfl-&gt;qf_last = NULL;</a>
<a name="ln3430">  qfl-&gt;qf_ptr = NULL;</a>
<a name="ln3431">  qfl-&gt;qf_nonevalid = true;</a>
<a name="ln3432"> </a>
<a name="ln3433">  qf_clean_dir_stack(&amp;qfl-&gt;qf_dir_stack);</a>
<a name="ln3434">  qfl-&gt;qf_directory = NULL;</a>
<a name="ln3435">  qf_clean_dir_stack(&amp;qfl-&gt;qf_file_stack);</a>
<a name="ln3436">  qfl-&gt;qf_currfile = NULL;</a>
<a name="ln3437">  qfl-&gt;qf_multiline = false;</a>
<a name="ln3438">  qfl-&gt;qf_multiignore = false;</a>
<a name="ln3439">  qfl-&gt;qf_multiscan = false;</a>
<a name="ln3440">}</a>
<a name="ln3441"> </a>
<a name="ln3442">/// Free error list &quot;idx&quot;. Frees all the entries in the quickfix list,</a>
<a name="ln3443">/// associated context information and the title.</a>
<a name="ln3444">static void qf_free(qf_list_T *qfl)</a>
<a name="ln3445">{</a>
<a name="ln3446">  qf_free_items(qfl);</a>
<a name="ln3447"> </a>
<a name="ln3448">  XFREE_CLEAR(qfl-&gt;qf_title);</a>
<a name="ln3449">  tv_free(qfl-&gt;qf_ctx);</a>
<a name="ln3450">  qfl-&gt;qf_ctx = NULL;</a>
<a name="ln3451">  callback_free(&amp;qfl-&gt;qf_qftf_cb);</a>
<a name="ln3452">  qfl-&gt;qf_id = 0;</a>
<a name="ln3453">  qfl-&gt;qf_changedtick = 0;</a>
<a name="ln3454">}</a>
<a name="ln3455"> </a>
<a name="ln3456">/// Adjust error list entries for changed line numbers</a>
<a name="ln3457">///</a>
<a name="ln3458">/// Note: `buf` is the changed buffer, but `wp` is a potential location list</a>
<a name="ln3459">/// into that buffer, or NULL to check the quickfix list.</a>
<a name="ln3460">bool qf_mark_adjust(buf_T *buf, win_T *wp, linenr_T line1, linenr_T line2, linenr_T amount,</a>
<a name="ln3461">                    linenr_T amount_after)</a>
<a name="ln3462">{</a>
<a name="ln3463">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln3464">  int buf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;</a>
<a name="ln3465"> </a>
<a name="ln3466">  if (!(buf-&gt;b_has_qf_entry &amp; buf_has_flag)) {</a>
<a name="ln3467">    return false;</a>
<a name="ln3468">  }</a>
<a name="ln3469">  if (wp != NULL) {</a>
<a name="ln3470">    if (wp-&gt;w_llist == NULL) {</a>
<a name="ln3471">      return false;</a>
<a name="ln3472">    }</a>
<a name="ln3473">    qi = wp-&gt;w_llist;</a>
<a name="ln3474">  }</a>
<a name="ln3475"> </a>
<a name="ln3476">  int i;</a>
<a name="ln3477">  qfline_T *qfp;</a>
<a name="ln3478">  bool found_one = false;</a>
<a name="ln3479">  for (int idx = 0; idx &lt; qi-&gt;qf_listcount; idx++) {</a>
<a name="ln3480">    qf_list_T *qfl = qf_get_list(qi, idx);</a>
<a name="ln3481">    if (!qf_list_empty(qfl)) {</a>
<a name="ln3482">      FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln3483">        if (qfp-&gt;qf_fnum == buf-&gt;b_fnum) {</a>
<a name="ln3484">          found_one = true;</a>
<a name="ln3485">          if (qfp-&gt;qf_lnum &gt;= line1 &amp;&amp; qfp-&gt;qf_lnum &lt;= line2) {</a>
<a name="ln3486">            if (amount == MAXLNUM) {</a>
<a name="ln3487">              qfp-&gt;qf_cleared = true;</a>
<a name="ln3488">            } else {</a>
<a name="ln3489">              qfp-&gt;qf_lnum += amount;</a>
<a name="ln3490">            }</a>
<a name="ln3491">          } else if (amount_after &amp;&amp; qfp-&gt;qf_lnum &gt; line2) {</a>
<a name="ln3492">            qfp-&gt;qf_lnum += amount_after;</a>
<a name="ln3493">          }</a>
<a name="ln3494">        }</a>
<a name="ln3495">      }</a>
<a name="ln3496">    }</a>
<a name="ln3497">  }</a>
<a name="ln3498"> </a>
<a name="ln3499">  return found_one;</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">// Make a nice message out of the error character and the error number:</a>
<a name="ln3503">//  char    number  message</a>
<a name="ln3504">//  e or E    0     &quot; error&quot;</a>
<a name="ln3505">//  w or W    0     &quot; warning&quot;</a>
<a name="ln3506">//  i or I    0     &quot; info&quot;</a>
<a name="ln3507">//  n or N    0     &quot; note&quot;</a>
<a name="ln3508">//  0         0     &quot;&quot;</a>
<a name="ln3509">//  other     0     &quot; c&quot;</a>
<a name="ln3510">//  e or E    n     &quot; error n&quot;</a>
<a name="ln3511">//  w or W    n     &quot; warning n&quot;</a>
<a name="ln3512">//  i or I    n     &quot; info n&quot;</a>
<a name="ln3513">//  n or N    n     &quot; note n&quot;</a>
<a name="ln3514">//  0         n     &quot; error n&quot;</a>
<a name="ln3515">//  other     n     &quot; c n&quot;</a>
<a name="ln3516">//  1         x     &quot;&quot;          :helpgrep</a>
<a name="ln3517">static char *qf_types(int c, int nr)</a>
<a name="ln3518">{</a>
<a name="ln3519">  static char cc[3];</a>
<a name="ln3520">  char *p;</a>
<a name="ln3521"> </a>
<a name="ln3522">  if (c == 'W' || c == 'w') {</a>
<a name="ln3523">    p = &quot; warning&quot;;</a>
<a name="ln3524">  } else if (c == 'I' || c == 'i') {</a>
<a name="ln3525">    p = &quot; info&quot;;</a>
<a name="ln3526">  } else if (c == 'N' || c == 'n') {</a>
<a name="ln3527">    p = &quot; note&quot;;</a>
<a name="ln3528">  } else if (c == 'E' || c == 'e' || (c == 0 &amp;&amp; nr &gt; 0)) {</a>
<a name="ln3529">    p = &quot; error&quot;;</a>
<a name="ln3530">  } else if (c == 0 || c == 1) {</a>
<a name="ln3531">    p = &quot;&quot;;</a>
<a name="ln3532">  } else {</a>
<a name="ln3533">    cc[0] = ' ';</a>
<a name="ln3534">    cc[1] = (char)c;</a>
<a name="ln3535">    cc[2] = NUL;</a>
<a name="ln3536">    p = cc;</a>
<a name="ln3537">  }</a>
<a name="ln3538"> </a>
<a name="ln3539">  if (nr &lt;= 0) {</a>
<a name="ln3540">    return p;</a>
<a name="ln3541">  }</a>
<a name="ln3542"> </a>
<a name="ln3543">  static char buf[20];</a>
<a name="ln3544">  snprintf(buf, sizeof(buf), &quot;%s %3d&quot;, p, nr);</a>
<a name="ln3545">  return buf;</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548">// When &quot;split&quot; is false: Open the entry/result under the cursor.</a>
<a name="ln3549">// When &quot;split&quot; is true: Open the entry/result under the cursor in a new window.</a>
<a name="ln3550">void qf_view_result(bool split)</a>
<a name="ln3551">{</a>
<a name="ln3552">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln3553"> </a>
<a name="ln3554">  if (IS_LL_WINDOW(curwin)) {</a>
<a name="ln3555">    qi = GET_LOC_LIST(curwin);</a>
<a name="ln3556">  }</a>
<a name="ln3557"> </a>
<a name="ln3558">  if (qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln3559">    emsg(_(e_no_errors));</a>
<a name="ln3560">    return;</a>
<a name="ln3561">  }</a>
<a name="ln3562"> </a>
<a name="ln3563">  if (split) {</a>
<a name="ln3564">    // Open the selected entry in a new window</a>
<a name="ln3565">    qf_jump_newwin(qi, 0, (int)curwin-&gt;w_cursor.lnum, false, true);</a>
<a name="ln3566">    do_cmdline_cmd(&quot;clearjumps&quot;);</a>
<a name="ln3567">    return;</a>
<a name="ln3568">  }</a>
<a name="ln3569"> </a>
<a name="ln3570">  do_cmdline_cmd((IS_LL_WINDOW(curwin) ? &quot;.ll&quot; : &quot;.cc&quot;));</a>
<a name="ln3571">}</a>
<a name="ln3572"> </a>
<a name="ln3573">// &quot;:cwindow&quot;: open the quickfix window if we have errors to display,</a>
<a name="ln3574">//             close it if not.</a>
<a name="ln3575">// &quot;:lwindow&quot;: open the location list window if we have locations to display,</a>
<a name="ln3576">//             close it if not.</a>
<a name="ln3577">void ex_cwindow(exarg_T *eap)</a>
<a name="ln3578">{</a>
<a name="ln3579">  qf_info_T *qi;</a>
<a name="ln3580"> </a>
<a name="ln3581">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln3582">    return;</a>
<a name="ln3583">  }</a>
<a name="ln3584"> </a>
<a name="ln3585">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln3586"> </a>
<a name="ln3587">  // Look for an existing quickfix window.</a>
<a name="ln3588">  win_T *win = qf_find_win(qi);</a>
<a name="ln3589"> </a>
<a name="ln3590">  // If a quickfix window is open but we have no errors to display,</a>
<a name="ln3591">  // close the window.  If a quickfix window is not open, then open</a>
<a name="ln3592">  // it if we have errors; otherwise, leave it closed.</a>
<a name="ln3593">  if (qf_stack_empty(qi)</a>
<a name="ln3594">      || qfl-&gt;qf_nonevalid</a>
<a name="ln3595">      || qf_list_empty(qfl)) {</a>
<a name="ln3596">    if (win != NULL) {</a>
<a name="ln3597">      ex_cclose(eap);</a>
<a name="ln3598">    }</a>
<a name="ln3599">  } else if (win == NULL) {</a>
<a name="ln3600">    ex_copen(eap);</a>
<a name="ln3601">  }</a>
<a name="ln3602">}</a>
<a name="ln3603"> </a>
<a name="ln3604">// &quot;:cclose&quot;: close the window showing the list of errors.</a>
<a name="ln3605">// &quot;:lclose&quot;: close the window showing the location list</a>
<a name="ln3606">void ex_cclose(exarg_T *eap)</a>
<a name="ln3607">{</a>
<a name="ln3608">  qf_info_T *qi;</a>
<a name="ln3609"> </a>
<a name="ln3610">  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {</a>
<a name="ln3611">    return;</a>
<a name="ln3612">  }</a>
<a name="ln3613"> </a>
<a name="ln3614">  // Find existing quickfix window and close it.</a>
<a name="ln3615">  win_T *win = qf_find_win(qi);</a>
<a name="ln3616">  if (win != NULL) {</a>
<a name="ln3617">    win_close(win, false, false);</a>
<a name="ln3618">  }</a>
<a name="ln3619">}</a>
<a name="ln3620"> </a>
<a name="ln3621">// Goto a quickfix or location list window (if present).</a>
<a name="ln3622">// Returns OK if the window is found, FAIL otherwise.</a>
<a name="ln3623">static int qf_goto_cwindow(const qf_info_T *qi, bool resize, int sz, bool vertsplit)</a>
<a name="ln3624">{</a>
<a name="ln3625">  win_T *const win = qf_find_win(qi);</a>
<a name="ln3626">  if (win == NULL) {</a>
<a name="ln3627">    return FAIL;</a>
<a name="ln3628">  }</a>
<a name="ln3629"> </a>
<a name="ln3630">  win_goto(win);</a>
<a name="ln3631">  if (resize) {</a>
<a name="ln3632">    if (vertsplit) {</a>
<a name="ln3633">      if (sz != win-&gt;w_width) {</a>
<a name="ln3634">        win_setwidth(sz);</a>
<a name="ln3635">      }</a>
<a name="ln3636">    } else if (sz != win-&gt;w_height</a>
<a name="ln3637">               &amp;&amp; (win-&gt;w_height + win-&gt;w_hsep_height + win-&gt;w_status_height + tabline_height()</a>
<a name="ln3638">                   &lt; cmdline_row)) {</a>
<a name="ln3639">      win_setheight(sz);</a>
<a name="ln3640">    }</a>
<a name="ln3641">  }</a>
<a name="ln3642"> </a>
<a name="ln3643">  return OK;</a>
<a name="ln3644">}</a>
<a name="ln3645"> </a>
<a name="ln3646">// Set options for the buffer in the quickfix or location list window.</a>
<a name="ln3647">static void qf_set_cwindow_options(void)</a>
<a name="ln3648">{</a>
<a name="ln3649">  // switch off 'swapfile'</a>
<a name="ln3650">  set_option_value_give_err(&quot;swf&quot;, BOOLEAN_OPTVAL(false), OPT_LOCAL);</a>
<a name="ln3651">  set_option_value_give_err(&quot;bt&quot;, STATIC_CSTR_AS_OPTVAL(&quot;quickfix&quot;), OPT_LOCAL);</a>
<a name="ln3652">  set_option_value_give_err(&quot;bh&quot;, STATIC_CSTR_AS_OPTVAL(&quot;hide&quot;), OPT_LOCAL);</a>
<a name="ln3653">  RESET_BINDING(curwin);</a>
<a name="ln3654">  curwin-&gt;w_p_diff = false;</a>
<a name="ln3655">  set_option_value_give_err(&quot;fdm&quot;, STATIC_CSTR_AS_OPTVAL(&quot;manual&quot;), OPT_LOCAL);</a>
<a name="ln3656">}</a>
<a name="ln3657"> </a>
<a name="ln3658">// Open a new quickfix or location list window, load the quickfix buffer and</a>
<a name="ln3659">// set the appropriate options for the window.</a>
<a name="ln3660">// Returns FAIL if the window could not be opened.</a>
<a name="ln3661">static int qf_open_new_cwindow(qf_info_T *qi, int height)</a>
<a name="ln3662">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3663">{</a>
<a name="ln3664">  win_T *oldwin = curwin;</a>
<a name="ln3665">  const tabpage_T *const prevtab = curtab;</a>
<a name="ln3666">  int flags = 0;</a>
<a name="ln3667"> </a>
<a name="ln3668">  const buf_T *const qf_buf = qf_find_buf(qi);</a>
<a name="ln3669"> </a>
<a name="ln3670">  // The current window becomes the previous window afterwards.</a>
<a name="ln3671">  win_T *const win = curwin;</a>
<a name="ln3672"> </a>
<a name="ln3673">  if (IS_QF_STACK(qi) &amp;&amp; cmdmod.cmod_split == 0) {</a>
<a name="ln3674">    // Create the new quickfix window at the very bottom, except when</a>
<a name="ln3675">    // :belowright or :aboveleft is used.</a>
<a name="ln3676">    win_goto(lastwin);</a>
<a name="ln3677">  }</a>
<a name="ln3678">  // Default is to open the window below the current window</a>
<a name="ln3679">  if (cmdmod.cmod_split == 0) {</a>
<a name="ln3680">    flags = WSP_BELOW;</a>
<a name="ln3681">  }</a>
<a name="ln3682">  flags |= WSP_NEWLOC;</a>
<a name="ln3683">  if (win_split(height, flags) == FAIL) {</a>
<a name="ln3684">    return FAIL;  // not enough room for window</a>
<a name="ln3685">  }</a>
<a name="ln3686">  RESET_BINDING(curwin);</a>
<a name="ln3687"> </a>
<a name="ln3688">  if (IS_LL_STACK(qi)) {</a>
<a name="ln3689">    // For the location list window, create a reference to the</a>
<a name="ln3690">    // location list stack from the window 'win'.</a>
<a name="ln3691">    curwin-&gt;w_llist_ref = qi;</a>
<a name="ln3692">    qi-&gt;qf_refcount++;</a>
<a name="ln3693">  }</a>
<a name="ln3694"> </a>
<a name="ln3695">  if (oldwin != curwin) {</a>
<a name="ln3696">    oldwin = NULL;  // don't store info when in another window</a>
<a name="ln3697">  }</a>
<a name="ln3698">  if (qf_buf != NULL) {</a>
<a name="ln3699">    // Use the existing quickfix buffer</a>
<a name="ln3700">    if (do_ecmd(qf_buf-&gt;b_fnum, NULL, NULL, NULL, ECMD_ONE,</a>
<a name="ln3701">                ECMD_HIDE + ECMD_OLDBUF + ECMD_NOWINENTER, oldwin) == FAIL) {</a>
<a name="ln3702">      return FAIL;</a>
<a name="ln3703">    }</a>
<a name="ln3704">  } else {</a>
<a name="ln3705">    // Create a new quickfix buffer</a>
<a name="ln3706">    if (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE + ECMD_NOWINENTER, oldwin) == FAIL) {</a>
<a name="ln3707">      return FAIL;</a>
<a name="ln3708">    }</a>
<a name="ln3709">    // save the number of the new buffer</a>
<a name="ln3710">    qi-&gt;qf_bufnr = curbuf-&gt;b_fnum;</a>
<a name="ln3711">  }</a>
<a name="ln3712"> </a>
<a name="ln3713">  // Set the options for the quickfix buffer/window (if not already done)</a>
<a name="ln3714">  // Do this even if the quickfix buffer was already present, as an autocmd</a>
<a name="ln3715">  // might have previously deleted (:bdelete) the quickfix buffer.</a>
<a name="ln3716">  if (!bt_quickfix(curbuf)) {</a>
<a name="ln3717">    qf_set_cwindow_options();</a>
<a name="ln3718">  }</a>
<a name="ln3719"> </a>
<a name="ln3720">  // Only set the height when still in the same tab page and there is no</a>
<a name="ln3721">  // window to the side.</a>
<a name="ln3722">  if (curtab == prevtab &amp;&amp; curwin-&gt;w_width == Columns) {</a>
<a name="ln3723">    win_setheight(height);</a>
<a name="ln3724">  }</a>
<a name="ln3725">  curwin-&gt;w_p_wfh = true;  // set 'winfixheight'</a>
<a name="ln3726">  if (win_valid(win)) {</a>
<a name="ln3727">    prevwin = win;</a>
<a name="ln3728">  }</a>
<a name="ln3729">  return OK;</a>
<a name="ln3730">}</a>
<a name="ln3731"> </a>
<a name="ln3732">/// Set &quot;w:quickfix_title&quot; if &quot;qi&quot; has a title.</a>
<a name="ln3733">static void qf_set_title_var(qf_list_T *qfl)</a>
<a name="ln3734">{</a>
<a name="ln3735">  if (qfl-&gt;qf_title != NULL) {</a>
<a name="ln3736">    set_internal_string_var(&quot;w:quickfix_title&quot;, qfl-&gt;qf_title);</a>
<a name="ln3737">  }</a>
<a name="ln3738">}</a>
<a name="ln3739"> </a>
<a name="ln3740">/// &quot;:copen&quot;: open a window that shows the list of errors.</a>
<a name="ln3741">/// &quot;:lopen&quot;: open a window that shows the location list.</a>
<a name="ln3742">void ex_copen(exarg_T *eap)</a>
<a name="ln3743">{</a>
<a name="ln3744">  qf_info_T *qi;</a>
<a name="ln3745"> </a>
<a name="ln3746">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln3747">    return;</a>
<a name="ln3748">  }</a>
<a name="ln3749"> </a>
<a name="ln3750">  incr_quickfix_busy();</a>
<a name="ln3751"> </a>
<a name="ln3752">  int height;</a>
<a name="ln3753">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln3754">    height = (int)eap-&gt;line2;</a>
<a name="ln3755">  } else {</a>
<a name="ln3756">    height = QF_WINHEIGHT;</a>
<a name="ln3757">  }</a>
<a name="ln3758">  reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln3759"> </a>
<a name="ln3760">  // Find an existing quickfix window, or open a new one.</a>
<a name="ln3761">  int status = FAIL;</a>
<a name="ln3762">  if (cmdmod.cmod_tab == 0) {</a>
<a name="ln3763">    status = qf_goto_cwindow(qi, eap-&gt;addr_count != 0, height,</a>
<a name="ln3764">                             cmdmod.cmod_split &amp; WSP_VERT);</a>
<a name="ln3765">  }</a>
<a name="ln3766">  if (status == FAIL) {</a>
<a name="ln3767">    if (qf_open_new_cwindow(qi, height) == FAIL) {</a>
<a name="ln3768">      decr_quickfix_busy();</a>
<a name="ln3769">      return;</a>
<a name="ln3770">    }</a>
<a name="ln3771">  }</a>
<a name="ln3772"> </a>
<a name="ln3773">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln3774">  qf_set_title_var(qfl);</a>
<a name="ln3775">  // Save the current index here, as updating the quickfix buffer may free</a>
<a name="ln3776">  // the quickfix list</a>
<a name="ln3777">  int lnum = qfl-&gt;qf_index;</a>
<a name="ln3778"> </a>
<a name="ln3779">  // Fill the buffer with the quickfix list.</a>
<a name="ln3780">  qf_fill_buffer(qfl, curbuf, NULL, curwin-&gt;handle);</a>
<a name="ln3781"> </a>
<a name="ln3782">  decr_quickfix_busy();</a>
<a name="ln3783"> </a>
<a name="ln3784">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3785">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3786">  check_cursor();</a>
<a name="ln3787">  update_topline(curwin);             // scroll to show the line</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">// Move the cursor in the quickfix window to &quot;lnum&quot;.</a>
<a name="ln3791">static void qf_win_goto(win_T *win, linenr_T lnum)</a>
<a name="ln3792">{</a>
<a name="ln3793">  win_T *old_curwin = curwin;</a>
<a name="ln3794"> </a>
<a name="ln3795">  curwin = win;</a>
<a name="ln3796">  curbuf = win-&gt;w_buffer;</a>
<a name="ln3797">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3798">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3799">  curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3800">  curwin-&gt;w_curswant = 0;</a>
<a name="ln3801">  update_topline(curwin);              // scroll to show the line</a>
<a name="ln3802">  redraw_later(curwin, UPD_VALID);</a>
<a name="ln3803">  curwin-&gt;w_redr_status = true;  // update ruler</a>
<a name="ln3804">  curwin = old_curwin;</a>
<a name="ln3805">  curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3806">}</a>
<a name="ln3807"> </a>
<a name="ln3808">/// :cbottom/:lbottom command.</a>
<a name="ln3809">void ex_cbottom(exarg_T *eap)</a>
<a name="ln3810">{</a>
<a name="ln3811">  qf_info_T *qi;</a>
<a name="ln3812"> </a>
<a name="ln3813">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln3814">    return;</a>
<a name="ln3815">  }</a>
<a name="ln3816"> </a>
<a name="ln3817">  win_T *win = qf_find_win(qi);</a>
<a name="ln3818"> </a>
<a name="ln3819">  if (win != NULL &amp;&amp; win-&gt;w_cursor.lnum != win-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln3820">    qf_win_goto(win, win-&gt;w_buffer-&gt;b_ml.ml_line_count);</a>
<a name="ln3821">  }</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824">// Return the number of the current entry (line number in the quickfix</a>
<a name="ln3825">// window).</a>
<a name="ln3826">linenr_T qf_current_entry(win_T *wp)</a>
<a name="ln3827">{</a>
<a name="ln3828">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln3829"> </a>
<a name="ln3830">  if (IS_LL_WINDOW(wp)) {</a>
<a name="ln3831">    // In the location list window, use the referenced location list</a>
<a name="ln3832">    qi = wp-&gt;w_llist_ref;</a>
<a name="ln3833">  }</a>
<a name="ln3834"> </a>
<a name="ln3835">  return qf_get_curlist(qi)-&gt;qf_index;</a>
<a name="ln3836">}</a>
<a name="ln3837"> </a>
<a name="ln3838">/// Update the cursor position in the quickfix window to the current error.</a>
<a name="ln3839">/// Return true if there is a quickfix window.</a>
<a name="ln3840">///</a>
<a name="ln3841">/// @param old_qf_index  previous qf_index or zero</a>
<a name="ln3842">static bool qf_win_pos_update(qf_info_T *qi, int old_qf_index)</a>
<a name="ln3843">{</a>
<a name="ln3844">  int qf_index = qf_get_curlist(qi)-&gt;qf_index;</a>
<a name="ln3845"> </a>
<a name="ln3846">  // Put the cursor on the current error in the quickfix window, so that</a>
<a name="ln3847">  // it's viewable.</a>
<a name="ln3848">  win_T *win = qf_find_win(qi);</a>
<a name="ln3849">  if (win != NULL</a>
<a name="ln3850">      &amp;&amp; qf_index &lt;= win-&gt;w_buffer-&gt;b_ml.ml_line_count</a>
<a name="ln3851">      &amp;&amp; old_qf_index != qf_index) {</a>
<a name="ln3852">    if (qf_index &gt; old_qf_index) {</a>
<a name="ln3853">      win-&gt;w_redraw_top = old_qf_index;</a>
<a name="ln3854">      win-&gt;w_redraw_bot = qf_index;</a>
<a name="ln3855">    } else {</a>
<a name="ln3856">      win-&gt;w_redraw_top = qf_index;</a>
<a name="ln3857">      win-&gt;w_redraw_bot = old_qf_index;</a>
<a name="ln3858">    }</a>
<a name="ln3859">    qf_win_goto(win, qf_index);</a>
<a name="ln3860">  }</a>
<a name="ln3861">  return win != NULL;</a>
<a name="ln3862">}</a>
<a name="ln3863"> </a>
<a name="ln3864">/// Checks whether the given window is displaying the specified</a>
<a name="ln3865">/// quickfix/location stack.</a>
<a name="ln3866">static int is_qf_win(const win_T *win, const qf_info_T *qi)</a>
<a name="ln3867">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3868">{</a>
<a name="ln3869">  //</a>
<a name="ln3870">  // A window displaying the quickfix buffer will have the w_llist_ref field</a>
<a name="ln3871">  // set to NULL.</a>
<a name="ln3872">  // A window displaying a location list buffer will have the w_llist_ref</a>
<a name="ln3873">  // pointing to the location list.</a>
<a name="ln3874">  //</a>
<a name="ln3875">  if (bt_quickfix(win-&gt;w_buffer)) {</a>
<a name="ln3876">    if ((IS_QF_STACK(qi) &amp;&amp; win-&gt;w_llist_ref == NULL)</a>
<a name="ln3877">        || (IS_LL_STACK(qi) &amp;&amp; win-&gt;w_llist_ref == qi)) {</a>
<a name="ln3878">      return true;</a>
<a name="ln3879">    }</a>
<a name="ln3880">  }</a>
<a name="ln3881"> </a>
<a name="ln3882">  return false;</a>
<a name="ln3883">}</a>
<a name="ln3884"> </a>
<a name="ln3885">/// Find a window displaying the quickfix/location stack 'qi' in the current tab</a>
<a name="ln3886">/// page.</a>
<a name="ln3887">static win_T *qf_find_win(const qf_info_T *qi)</a>
<a name="ln3888">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3889">{</a>
<a name="ln3890">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln3891">    if (is_qf_win(win, qi)) {</a>
<a name="ln3892">      return win;</a>
<a name="ln3893">    }</a>
<a name="ln3894">  }</a>
<a name="ln3895"> </a>
<a name="ln3896">  return NULL;</a>
<a name="ln3897">}</a>
<a name="ln3898"> </a>
<a name="ln3899">/// Find a quickfix buffer.</a>
<a name="ln3900">/// Searches in windows opened in all the tab pages.</a>
<a name="ln3901">static buf_T *qf_find_buf(qf_info_T *qi)</a>
<a name="ln3902">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3903">{</a>
<a name="ln3904">  if (qi-&gt;qf_bufnr != INVALID_QFBUFNR) {</a>
<a name="ln3905">    buf_T *const qfbuf = buflist_findnr(qi-&gt;qf_bufnr);</a>
<a name="ln3906">    if (qfbuf != NULL) {</a>
<a name="ln3907">      return qfbuf;</a>
<a name="ln3908">    }</a>
<a name="ln3909">    // buffer is no longer present</a>
<a name="ln3910">    qi-&gt;qf_bufnr = INVALID_QFBUFNR;</a>
<a name="ln3911">  }</a>
<a name="ln3912"> </a>
<a name="ln3913">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln3914">    if (is_qf_win(win, qi)) {</a>
<a name="ln3915">      return win-&gt;w_buffer;</a>
<a name="ln3916">    }</a>
<a name="ln3917">  }</a>
<a name="ln3918"> </a>
<a name="ln3919">  return NULL;</a>
<a name="ln3920">}</a>
<a name="ln3921"> </a>
<a name="ln3922">/// Process the 'quickfixtextfunc' option value.</a>
<a name="ln3923">const char *did_set_quickfixtextfunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln3924">{</a>
<a name="ln3925">  if (option_set_callback_func(p_qftf, &amp;qftf_cb) == FAIL) {</a>
<a name="ln3926">    return e_invarg;</a>
<a name="ln3927">  }</a>
<a name="ln3928">  return NULL;</a>
<a name="ln3929">}</a>
<a name="ln3930"> </a>
<a name="ln3931">/// Update the w:quickfix_title variable in the quickfix/location list window in</a>
<a name="ln3932">/// all the tab pages.</a>
<a name="ln3933">static void qf_update_win_titlevar(qf_info_T *qi)</a>
<a name="ln3934">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3935">{</a>
<a name="ln3936">  qf_list_T *const qfl = qf_get_curlist(qi);</a>
<a name="ln3937">  win_T *const save_curwin = curwin;</a>
<a name="ln3938"> </a>
<a name="ln3939">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln3940">    if (is_qf_win(win, qi)) {</a>
<a name="ln3941">      curwin = win;</a>
<a name="ln3942">      qf_set_title_var(qfl);</a>
<a name="ln3943">    }</a>
<a name="ln3944">  }</a>
<a name="ln3945">  curwin = save_curwin;</a>
<a name="ln3946">}</a>
<a name="ln3947"> </a>
<a name="ln3948">// Find the quickfix buffer.  If it exists, update the contents.</a>
<a name="ln3949">static void qf_update_buffer(qf_info_T *qi, qfline_T *old_last)</a>
<a name="ln3950">{</a>
<a name="ln3951">  // Check if a buffer for the quickfix list exists.  Update it.</a>
<a name="ln3952">  buf_T *buf = qf_find_buf(qi);</a>
<a name="ln3953">  if (buf == NULL) {</a>
<a name="ln3954">    return;</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">  linenr_T old_line_count = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln3958">  int qf_winid = 0;</a>
<a name="ln3959"> </a>
<a name="ln3960">  win_T *win;</a>
<a name="ln3961">  if (IS_LL_STACK(qi)) {</a>
<a name="ln3962">    if (curwin-&gt;w_llist == qi) {</a>
<a name="ln3963">      win = curwin;</a>
<a name="ln3964">    } else {</a>
<a name="ln3965">      // Find the file window (non-quickfix) with this location list</a>
<a name="ln3966">      win = qf_find_win_with_loclist(qi);</a>
<a name="ln3967">      if (win == NULL) {</a>
<a name="ln3968">        // File window is not found. Find the location list window.</a>
<a name="ln3969">        win = qf_find_win(qi);</a>
<a name="ln3970">      }</a>
<a name="ln3971">      if (win == NULL) {</a>
<a name="ln3972">        return;</a>
<a name="ln3973">      }</a>
<a name="ln3974">    }</a>
<a name="ln3975">    qf_winid = (int)win-&gt;handle;</a>
<a name="ln3976">  }</a>
<a name="ln3977"> </a>
<a name="ln3978">  // autocommands may cause trouble</a>
<a name="ln3979">  incr_quickfix_busy();</a>
<a name="ln3980"> </a>
<a name="ln3981">  aco_save_T aco;</a>
<a name="ln3982"> </a>
<a name="ln3983">  if (old_last == NULL) {</a>
<a name="ln3984">    // set curwin/curbuf to buf and save a few things</a>
<a name="ln3985">    aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3986">  }</a>
<a name="ln3987"> </a>
<a name="ln3988">  qf_update_win_titlevar(qi);</a>
<a name="ln3989"> </a>
<a name="ln3990">  qf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);</a>
<a name="ln3991">  buf_inc_changedtick(buf);</a>
<a name="ln3992"> </a>
<a name="ln3993">  if (old_last == NULL) {</a>
<a name="ln3994">    (void)qf_win_pos_update(qi, 0);</a>
<a name="ln3995"> </a>
<a name="ln3996">    // restore curwin/curbuf and a few other things</a>
<a name="ln3997">    aucmd_restbuf(&amp;aco);</a>
<a name="ln3998">  }</a>
<a name="ln3999"> </a>
<a name="ln4000">  // Only redraw when added lines are visible.  This avoids flickering when</a>
<a name="ln4001">  // the added lines are not visible.</a>
<a name="ln4002">  if ((win = qf_find_win(qi)) != NULL &amp;&amp; old_line_count &lt; win-&gt;w_botline) {</a>
<a name="ln4003">    redraw_buf_later(buf, UPD_NOT_VALID);</a>
<a name="ln4004">  }</a>
<a name="ln4005"> </a>
<a name="ln4006">  // always called after incr_quickfix_busy()</a>
<a name="ln4007">  decr_quickfix_busy();</a>
<a name="ln4008">}</a>
<a name="ln4009"> </a>
<a name="ln4010">// Add an error line to the quickfix buffer.</a>
<a name="ln4011">static int qf_buf_add_line(qf_list_T *qfl, buf_T *buf, linenr_T lnum, const qfline_T *qfp,</a>
<a name="ln4012">                           char *dirname, char *qftf_str, bool first_bufline)</a>
<a name="ln4013">  FUNC_ATTR_NONNULL_ARG(1, 2, 4, 5)</a>
<a name="ln4014">{</a>
<a name="ln4015">  garray_T *gap = qfga_get();</a>
<a name="ln4016"> </a>
<a name="ln4017">  // If the 'quickfixtextfunc' function returned a non-empty custom string</a>
<a name="ln4018">  // for this entry, then use it.</a>
<a name="ln4019">  if (qftf_str != NULL &amp;&amp; *qftf_str != NUL) {</a>
<a name="ln4020">    ga_concat(gap, qftf_str);</a>
<a name="ln4021">  } else {</a>
<a name="ln4022">    buf_T *errbuf;</a>
<a name="ln4023">    if (qfp-&gt;qf_module != NULL) {</a>
<a name="ln4024">      ga_concat(gap, qfp-&gt;qf_module);</a>
<a name="ln4025">    } else if (qfp-&gt;qf_fnum != 0</a>
<a name="ln4026">               &amp;&amp; (errbuf = buflist_findnr(qfp-&gt;qf_fnum)) != NULL</a>
<a name="ln4027">               &amp;&amp; errbuf-&gt;b_fname != NULL) {</a>
<a name="ln4028">      if (qfp-&gt;qf_type == 1) {  // :helpgrep</a>
<a name="ln4029">        ga_concat(gap, path_tail(errbuf-&gt;b_fname));</a>
<a name="ln4030">      } else {</a>
<a name="ln4031">        // Shorten the file name if not done already.</a>
<a name="ln4032">        // For optimization, do this only for the first entry in a</a>
<a name="ln4033">        // buffer.</a>
<a name="ln4034">        if (first_bufline</a>
<a name="ln4035">            &amp;&amp; (errbuf-&gt;b_sfname == NULL</a>
<a name="ln4036">                || path_is_absolute(errbuf-&gt;b_sfname))) {</a>
<a name="ln4037">          if (*dirname == NUL) {</a>
<a name="ln4038">            os_dirname(dirname, MAXPATHL);</a>
<a name="ln4039">          }</a>
<a name="ln4040">          shorten_buf_fname(errbuf, dirname, false);</a>
<a name="ln4041">        }</a>
<a name="ln4042">        ga_concat(gap, errbuf-&gt;b_fname);</a>
<a name="ln4043">      }</a>
<a name="ln4044">    }</a>
<a name="ln4045"> </a>
<a name="ln4046">    ga_append(gap, '|');</a>
<a name="ln4047"> </a>
<a name="ln4048">    if (qfp-&gt;qf_lnum &gt; 0) {</a>
<a name="ln4049">      qf_range_text(gap, qfp);</a>
<a name="ln4050">      ga_concat(gap, qf_types(qfp-&gt;qf_type, qfp-&gt;qf_nr));</a>
<a name="ln4051">    } else if (qfp-&gt;qf_pattern != NULL) {</a>
<a name="ln4052">      qf_fmt_text(gap, qfp-&gt;qf_pattern);</a>
<a name="ln4053">    }</a>
<a name="ln4054">    ga_append(gap, '|');</a>
<a name="ln4055">    ga_append(gap, ' ');</a>
<a name="ln4056"> </a>
<a name="ln4057">    // Remove newlines and leading whitespace from the text.</a>
<a name="ln4058">    // For an unrecognized line keep the indent, the compiler may</a>
<a name="ln4059">    // mark a word with ^^^^.</a>
<a name="ln4060">    qf_fmt_text(gap, gap-&gt;ga_len &gt; 3 ? skipwhite(qfp-&gt;qf_text) : qfp-&gt;qf_text);</a>
<a name="ln4061">  }</a>
<a name="ln4062"> </a>
<a name="ln4063">  ga_append(gap, NUL);</a>
<a name="ln4064">  if (ml_append_buf(buf, lnum, gap-&gt;ga_data, gap-&gt;ga_len, false) == FAIL) {</a>
<a name="ln4065">    return FAIL;</a>
<a name="ln4066">  }</a>
<a name="ln4067"> </a>
<a name="ln4068">  return OK;</a>
<a name="ln4069">}</a>
<a name="ln4070"> </a>
<a name="ln4071">// Call the 'quickfixtextfunc' function to get the list of lines to display in</a>
<a name="ln4072">// the quickfix window for the entries 'start_idx' to 'end_idx'.</a>
<a name="ln4073">static list_T *call_qftf_func(qf_list_T *qfl, int qf_winid, int start_idx, int end_idx)</a>
<a name="ln4074">{</a>
<a name="ln4075">  Callback *cb = &amp;qftf_cb;</a>
<a name="ln4076">  list_T *qftf_list = NULL;</a>
<a name="ln4077">  static bool recursive = false;</a>
<a name="ln4078"> </a>
<a name="ln4079">  if (recursive) {</a>
<a name="ln4080">    return NULL;  // this doesn't work properly recursively</a>
<a name="ln4081">  }</a>
<a name="ln4082">  recursive = true;</a>
<a name="ln4083"> </a>
<a name="ln4084">  // If 'quickfixtextfunc' is set, then use the user-supplied function to get</a>
<a name="ln4085">  // the text to display. Use the local value of 'quickfixtextfunc' if it is</a>
<a name="ln4086">  // set.</a>
<a name="ln4087">  if (qfl-&gt;qf_qftf_cb.type != kCallbackNone) {</a>
<a name="ln4088">    cb = &amp;qfl-&gt;qf_qftf_cb;</a>
<a name="ln4089">  }</a>
<a name="ln4090">  if (cb-&gt;type != kCallbackNone) {</a>
<a name="ln4091">    typval_T args[1];</a>
<a name="ln4092">    typval_T rettv;</a>
<a name="ln4093"> </a>
<a name="ln4094">    // create the dict argument</a>
<a name="ln4095">    dict_T *const dict = tv_dict_alloc_lock(VAR_FIXED);</a>
<a name="ln4096"> </a>
<a name="ln4097">    tv_dict_add_nr(dict, S_LEN(&quot;quickfix&quot;), IS_QF_LIST(qfl));</a>
<a name="ln4098">    tv_dict_add_nr(dict, S_LEN(&quot;winid&quot;), qf_winid);</a>
<a name="ln4099">    tv_dict_add_nr(dict, S_LEN(&quot;id&quot;), qfl-&gt;qf_id);</a>
<a name="ln4100">    tv_dict_add_nr(dict, S_LEN(&quot;start_idx&quot;), start_idx);</a>
<a name="ln4101">    tv_dict_add_nr(dict, S_LEN(&quot;end_idx&quot;), end_idx);</a>
<a name="ln4102">    dict-&gt;dv_refcount++;</a>
<a name="ln4103">    args[0].v_type = VAR_DICT;</a>
<a name="ln4104">    args[0].vval.v_dict = dict;</a>
<a name="ln4105"> </a>
<a name="ln4106">    if (callback_call(cb, 1, args, &amp;rettv)) {</a>
<a name="ln4107">      if (rettv.v_type == VAR_LIST) {</a>
<a name="ln4108">        qftf_list = rettv.vval.v_list;</a>
<a name="ln4109">        tv_list_ref(qftf_list);</a>
<a name="ln4110">      }</a>
<a name="ln4111">      tv_clear(&amp;rettv);</a>
<a name="ln4112">    }</a>
<a name="ln4113">    tv_dict_unref(dict);</a>
<a name="ln4114">  }</a>
<a name="ln4115"> </a>
<a name="ln4116">  recursive = false;</a>
<a name="ln4117">  return qftf_list;</a>
<a name="ln4118">}</a>
<a name="ln4119"> </a>
<a name="ln4120">/// Fill current buffer with quickfix errors, replacing any previous contents.</a>
<a name="ln4121">/// curbuf must be the quickfix buffer!</a>
<a name="ln4122">/// If &quot;old_last&quot; is not NULL append the items after this one.</a>
<a name="ln4123">/// When &quot;old_last&quot; is NULL then &quot;buf&quot; must equal &quot;curbuf&quot;!  Because ml_delete()</a>
<a name="ln4124">/// is used and autocommands will be triggered.</a>
<a name="ln4125">static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)</a>
<a name="ln4126">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln4127">{</a>
<a name="ln4128">  const bool old_KeyTyped = KeyTyped;</a>
<a name="ln4129"> </a>
<a name="ln4130">  if (old_last == NULL) {</a>
<a name="ln4131">    if (buf != curbuf) {</a>
<a name="ln4132">      internal_error(&quot;qf_fill_buffer()&quot;);</a>
<a name="ln4133">      return;</a>
<a name="ln4134">    }</a>
<a name="ln4135"> </a>
<a name="ln4136">    // delete all existing lines</a>
<a name="ln4137">    while ((curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) == 0) {</a>
<a name="ln4138">      // If deletion fails, this loop may run forever, so</a>
<a name="ln4139">      // signal error and return.</a>
<a name="ln4140">      if (ml_delete(1, false) == FAIL) {</a>
<a name="ln4141">        internal_error(&quot;qf_fill_buffer()&quot;);</a>
<a name="ln4142">        return;</a>
<a name="ln4143">      }</a>
<a name="ln4144">    }</a>
<a name="ln4145">  }</a>
<a name="ln4146"> </a>
<a name="ln4147">  // Check if there is anything to display</a>
<a name="ln4148">  if (qfl != NULL &amp;&amp; qfl-&gt;qf_start != NULL) {</a>
<a name="ln4149">    char dirname[MAXPATHL];</a>
<a name="ln4150"> </a>
<a name="ln4151">    *dirname = NUL;</a>
<a name="ln4152"> </a>
<a name="ln4153">    linenr_T lnum;</a>
<a name="ln4154">    qfline_T *qfp;</a>
<a name="ln4155"> </a>
<a name="ln4156">    // Add one line for each error</a>
<a name="ln4157">    if (old_last == NULL) {</a>
<a name="ln4158">      qfp = qfl-&gt;qf_start;</a>
<a name="ln4159">      lnum = 0;</a>
<a name="ln4160">    } else {</a>
<a name="ln4161">      if (old_last-&gt;qf_next != NULL) {</a>
<a name="ln4162">        qfp = old_last-&gt;qf_next;</a>
<a name="ln4163">      } else {</a>
<a name="ln4164">        qfp = old_last;</a>
<a name="ln4165">      }</a>
<a name="ln4166">      lnum = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln4167">    }</a>
<a name="ln4168"> </a>
<a name="ln4169">    list_T *qftf_list = call_qftf_func(qfl, qf_winid, lnum + 1, qfl-&gt;qf_count);</a>
<a name="ln4170">    listitem_T *qftf_li = tv_list_first(qftf_list);</a>
<a name="ln4171"> </a>
<a name="ln4172">    int prev_bufnr = -1;</a>
<a name="ln4173">    bool invalid_val = false;</a>
<a name="ln4174"> </a>
<a name="ln4175">    while (lnum &lt; qfl-&gt;qf_count) {</a>
<a name="ln4176">      char *qftf_str = NULL;</a>
<a name="ln4177"> </a>
<a name="ln4178">      // Use the text supplied by the user defined function (if any).</a>
<a name="ln4179">      // If the returned value is not string, then ignore the rest</a>
<a name="ln4180">      // of the returned values and use the default.</a>
<a name="ln4181">      if (qftf_li != NULL &amp;&amp; !invalid_val) {</a>
<a name="ln4182">        qftf_str = (char *)tv_get_string_chk(TV_LIST_ITEM_TV(qftf_li));</a>
<a name="ln4183">        if (qftf_str == NULL) {</a>
<a name="ln4184">          invalid_val = true;</a>
<a name="ln4185">        }</a>
<a name="ln4186">      }</a>
<a name="ln4187"> </a>
<a name="ln4188">      if (qf_buf_add_line(qfl, buf, lnum, qfp, dirname, qftf_str,</a>
<a name="ln4189">                          prev_bufnr != qfp-&gt;qf_fnum) == FAIL) {</a>
<a name="ln4190">        break;</a>
<a name="ln4191">      }</a>
<a name="ln4192">      prev_bufnr = qfp-&gt;qf_fnum;</a>
<a name="ln4193">      lnum++;</a>
<a name="ln4194">      qfp = qfp-&gt;qf_next;</a>
<a name="ln4195">      if (qfp == NULL) {</a>
<a name="ln4196">        break;</a>
<a name="ln4197">      }</a>
<a name="ln4198"> </a>
<a name="ln4199">      if (qftf_li != NULL) {</a>
<a name="ln4200">        qftf_li = TV_LIST_ITEM_NEXT(qftf_list, qftf_li);</a>
<a name="ln4201">      }</a>
<a name="ln4202">    }</a>
<a name="ln4203">    if (old_last == NULL) {</a>
<a name="ln4204">      // Delete the empty line which is now at the end</a>
<a name="ln4205">      (void)ml_delete(lnum + 1, false);</a>
<a name="ln4206">    }</a>
<a name="ln4207"> </a>
<a name="ln4208">    qfga_clear();</a>
<a name="ln4209">  }</a>
<a name="ln4210"> </a>
<a name="ln4211">  // Correct cursor position.</a>
<a name="ln4212">  check_lnums(true);</a>
<a name="ln4213"> </a>
<a name="ln4214">  if (old_last == NULL) {</a>
<a name="ln4215">    // Set the 'filetype' to &quot;qf&quot; each time after filling the buffer.  This</a>
<a name="ln4216">    // resembles reading a file into a buffer, it's more logical when using</a>
<a name="ln4217">    // autocommands.</a>
<a name="ln4218">    curbuf-&gt;b_ro_locked++;</a>
<a name="ln4219">    set_option_value_give_err(&quot;ft&quot;, STATIC_CSTR_AS_OPTVAL(&quot;qf&quot;), OPT_LOCAL);</a>
<a name="ln4220">    curbuf-&gt;b_p_ma = false;</a>
<a name="ln4221"> </a>
<a name="ln4222">    keep_filetype = true;                 // don't detect 'filetype'</a>
<a name="ln4223">    apply_autocmds(EVENT_BUFREADPOST, &quot;quickfix&quot;, NULL, false, curbuf);</a>
<a name="ln4224">    apply_autocmds(EVENT_BUFWINENTER, &quot;quickfix&quot;, NULL, false, curbuf);</a>
<a name="ln4225">    keep_filetype = false;</a>
<a name="ln4226">    curbuf-&gt;b_ro_locked--;</a>
<a name="ln4227"> </a>
<a name="ln4228">    // make sure it will be redrawn</a>
<a name="ln4229">    redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln4230">  }</a>
<a name="ln4231"> </a>
<a name="ln4232">  // Restore KeyTyped, setting 'filetype' may reset it.</a>
<a name="ln4233">  KeyTyped = old_KeyTyped;</a>
<a name="ln4234">}</a>
<a name="ln4235"> </a>
<a name="ln4236">static void qf_list_changed(qf_list_T *qfl)</a>
<a name="ln4237">{</a>
<a name="ln4238">  qfl-&gt;qf_changedtick++;</a>
<a name="ln4239">}</a>
<a name="ln4240"> </a>
<a name="ln4241">/// Return the quickfix/location list number with the given identifier.</a>
<a name="ln4242">///</a>
<a name="ln4243">/// @returns -1 if list is not found.</a>
<a name="ln4244">static int qf_id2nr(const qf_info_T *const qi, const unsigned qfid)</a>
<a name="ln4245">{</a>
<a name="ln4246">  for (int qf_idx = 0; qf_idx &lt; qi-&gt;qf_listcount; qf_idx++) {</a>
<a name="ln4247">    if (qi-&gt;qf_lists[qf_idx].qf_id == qfid) {</a>
<a name="ln4248">      return qf_idx;</a>
<a name="ln4249">    }</a>
<a name="ln4250">  }</a>
<a name="ln4251">  return INVALID_QFIDX;</a>
<a name="ln4252">}</a>
<a name="ln4253"> </a>
<a name="ln4254">/// If the current list is not &quot;save_qfid&quot; and we can find the list with that ID</a>
<a name="ln4255">/// then make it the current list.</a>
<a name="ln4256">/// This is used when autocommands may have changed the current list.</a>
<a name="ln4257">/// Returns OK if successfully restored the list. Returns FAIL if the list with</a>
<a name="ln4258">/// the specified identifier (save_qfid) is not found in the stack.</a>
<a name="ln4259">static int qf_restore_list(qf_info_T *qi, unsigned save_qfid)</a>
<a name="ln4260">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4261">{</a>
<a name="ln4262">  if (qf_get_curlist(qi)-&gt;qf_id == save_qfid) {</a>
<a name="ln4263">    return OK;</a>
<a name="ln4264">  }</a>
<a name="ln4265"> </a>
<a name="ln4266">  const int curlist = qf_id2nr(qi, save_qfid);</a>
<a name="ln4267">  if (curlist &lt; 0) {</a>
<a name="ln4268">    // list is not present</a>
<a name="ln4269">    return FAIL;</a>
<a name="ln4270">  }</a>
<a name="ln4271">  qi-&gt;qf_curlist = curlist;</a>
<a name="ln4272">  return OK;</a>
<a name="ln4273">}</a>
<a name="ln4274"> </a>
<a name="ln4275">// Jump to the first entry if there is one.</a>
<a name="ln4276">static void qf_jump_first(qf_info_T *qi, unsigned save_qfid, int forceit)</a>
<a name="ln4277">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4278">{</a>
<a name="ln4279">  if (qf_restore_list(qi, save_qfid) == FAIL) {</a>
<a name="ln4280">    return;</a>
<a name="ln4281">  }</a>
<a name="ln4282">  // Autocommands might have cleared the list, check for that</a>
<a name="ln4283">  if (!qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln4284">    qf_jump(qi, 0, 0, forceit);</a>
<a name="ln4285">  }</a>
<a name="ln4286">}</a>
<a name="ln4287"> </a>
<a name="ln4288">// Return true when using &quot;:vimgrep&quot; for &quot;:grep&quot;.</a>
<a name="ln4289">int grep_internal(cmdidx_T cmdidx)</a>
<a name="ln4290">{</a>
<a name="ln4291">  return (cmdidx == CMD_grep</a>
<a name="ln4292">          || cmdidx == CMD_lgrep</a>
<a name="ln4293">          || cmdidx == CMD_grepadd</a>
<a name="ln4294">          || cmdidx == CMD_lgrepadd)</a>
<a name="ln4295">         &amp;&amp; strcmp(&quot;internal&quot;, *curbuf-&gt;b_p_gp == NUL ? p_gp : curbuf-&gt;b_p_gp) == 0;</a>
<a name="ln4296">}</a>
<a name="ln4297"> </a>
<a name="ln4298">// Return the make/grep autocmd name.</a>
<a name="ln4299">static char *make_get_auname(cmdidx_T cmdidx)</a>
<a name="ln4300">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4301">{</a>
<a name="ln4302">  switch (cmdidx) {</a>
<a name="ln4303">  case CMD_make:</a>
<a name="ln4304">    return &quot;make&quot;;</a>
<a name="ln4305">  case CMD_lmake:</a>
<a name="ln4306">    return &quot;lmake&quot;;</a>
<a name="ln4307">  case CMD_grep:</a>
<a name="ln4308">    return &quot;grep&quot;;</a>
<a name="ln4309">  case CMD_lgrep:</a>
<a name="ln4310">    return &quot;lgrep&quot;;</a>
<a name="ln4311">  case CMD_grepadd:</a>
<a name="ln4312">    return &quot;grepadd&quot;;</a>
<a name="ln4313">  case CMD_lgrepadd:</a>
<a name="ln4314">    return &quot;lgrepadd&quot;;</a>
<a name="ln4315">  default:</a>
<a name="ln4316">    return NULL;</a>
<a name="ln4317">  }</a>
<a name="ln4318">}</a>
<a name="ln4319"> </a>
<a name="ln4320">// Form the complete command line to invoke 'make'/'grep'. Quote the command</a>
<a name="ln4321">// using 'shellquote' and append 'shellpipe'. Echo the fully formed command.</a>
<a name="ln4322">static char *make_get_fullcmd(const char *makecmd, const char *fname)</a>
<a name="ln4323">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln4324">{</a>
<a name="ln4325">  size_t len = strlen(p_shq) * 2 + strlen(makecmd) + 1;</a>
<a name="ln4326">  if (*p_sp != NUL) {</a>
<a name="ln4327">    len += strlen(p_sp) + strlen(fname) + 3;</a>
<a name="ln4328">  }</a>
<a name="ln4329">  char *const cmd = xmalloc(len);</a>
<a name="ln4330">  snprintf(cmd, len, &quot;%s%s%s&quot;, p_shq, makecmd, p_shq);</a>
<a name="ln4331"> </a>
<a name="ln4332">  // If 'shellpipe' empty: don't redirect to 'errorfile'.</a>
<a name="ln4333">  if (*p_sp != NUL) {</a>
<a name="ln4334">    append_redir(cmd, len, p_sp, fname);</a>
<a name="ln4335">  }</a>
<a name="ln4336"> </a>
<a name="ln4337">  // Display the fully formed command.  Output a newline if there's something</a>
<a name="ln4338">  // else than the :make command that was typed (in which case the cursor is</a>
<a name="ln4339">  // in column 0).</a>
<a name="ln4340">  if (msg_col == 0) {</a>
<a name="ln4341">    msg_didout = false;</a>
<a name="ln4342">  }</a>
<a name="ln4343">  msg_start();</a>
<a name="ln4344">  msg_puts(&quot;:!&quot;);</a>
<a name="ln4345">  msg_outtrans(cmd, 0);  // show what we are doing</a>
<a name="ln4346"> </a>
<a name="ln4347">  return cmd;</a>
<a name="ln4348">}</a>
<a name="ln4349"> </a>
<a name="ln4350">// Used for &quot;:make&quot;, &quot;:lmake&quot;, &quot;:grep&quot;, &quot;:lgrep&quot;, &quot;:grepadd&quot;, and &quot;:lgrepadd&quot;</a>
<a name="ln4351">void ex_make(exarg_T *eap)</a>
<a name="ln4352">{</a>
<a name="ln4353">  char *enc = (*curbuf-&gt;b_p_menc != NUL) ? curbuf-&gt;b_p_menc : p_menc;</a>
<a name="ln4354"> </a>
<a name="ln4355">  // Redirect &quot;:grep&quot; to &quot;:vimgrep&quot; if 'grepprg' is &quot;internal&quot;.</a>
<a name="ln4356">  if (grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln4357">    ex_vimgrep(eap);</a>
<a name="ln4358">    return;</a>
<a name="ln4359">  }</a>
<a name="ln4360"> </a>
<a name="ln4361">  char *const au_name = make_get_auname(eap-&gt;cmdidx);</a>
<a name="ln4362">  if (au_name != NULL &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,</a>
<a name="ln4363">                                        curbuf-&gt;b_fname, true, curbuf)) {</a>
<a name="ln4364">    if (aborting()) {</a>
<a name="ln4365">      return;</a>
<a name="ln4366">    }</a>
<a name="ln4367">  }</a>
<a name="ln4368"> </a>
<a name="ln4369">  win_T *wp = NULL;</a>
<a name="ln4370">  if (is_loclist_cmd(eap-&gt;cmdidx)) {</a>
<a name="ln4371">    wp = curwin;</a>
<a name="ln4372">  }</a>
<a name="ln4373"> </a>
<a name="ln4374">  autowrite_all();</a>
<a name="ln4375">  char *fname = get_mef_name();</a>
<a name="ln4376">  if (fname == NULL) {</a>
<a name="ln4377">    return;</a>
<a name="ln4378">  }</a>
<a name="ln4379">  os_remove(fname);  // in case it's not unique</a>
<a name="ln4380"> </a>
<a name="ln4381">  char *const cmd = make_get_fullcmd(eap-&gt;arg, fname);</a>
<a name="ln4382"> </a>
<a name="ln4383">  do_shell(cmd, 0);</a>
<a name="ln4384"> </a>
<a name="ln4385">  incr_quickfix_busy();</a>
<a name="ln4386"> </a>
<a name="ln4387">  char *errorformat = p_efm;</a>
<a name="ln4388">  bool newlist = true;</a>
<a name="ln4389"> </a>
<a name="ln4390">  if (eap-&gt;cmdidx != CMD_make &amp;&amp; eap-&gt;cmdidx != CMD_lmake) {</a>
<a name="ln4391">    errorformat = p_gefm;</a>
<a name="ln4392">  }</a>
<a name="ln4393">  if (eap-&gt;cmdidx == CMD_grepadd || eap-&gt;cmdidx == CMD_lgrepadd) {</a>
<a name="ln4394">    newlist = false;</a>
<a name="ln4395">  }</a>
<a name="ln4396"> </a>
<a name="ln4397">  int res = qf_init(wp, fname, errorformat, newlist, qf_cmdtitle(*eap-&gt;cmdlinep), enc);</a>
<a name="ln4398"> </a>
<a name="ln4399">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln4400">  if (wp != NULL) {</a>
<a name="ln4401">    qi = GET_LOC_LIST(wp);</a>
<a name="ln4402">    if (qi == NULL) {</a>
<a name="ln4403">      goto cleanup;</a>
<a name="ln4404">    }</a>
<a name="ln4405">  }</a>
<a name="ln4406">  if (res &gt;= 0) {</a>
<a name="ln4407">    qf_list_changed(qf_get_curlist(qi));</a>
<a name="ln4408">  }</a>
<a name="ln4409">  // Remember the current quickfix list identifier, so that we can</a>
<a name="ln4410">  // check for autocommands changing the current quickfix list.</a>
<a name="ln4411">  unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln4412">  if (au_name != NULL) {</a>
<a name="ln4413">    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf-&gt;b_fname, true,</a>
<a name="ln4414">                   curbuf);</a>
<a name="ln4415">  }</a>
<a name="ln4416">  if (res &gt; 0 &amp;&amp; !eap-&gt;forceit &amp;&amp; qflist_valid(wp, save_qfid)) {</a>
<a name="ln4417">    // display the first error</a>
<a name="ln4418">    qf_jump_first(qi, save_qfid, false);</a>
<a name="ln4419">  }</a>
<a name="ln4420"> </a>
<a name="ln4421">cleanup:</a>
<a name="ln4422">  decr_quickfix_busy();</a>
<a name="ln4423">  os_remove(fname);</a>
<a name="ln4424">  xfree(fname);</a>
<a name="ln4425">  xfree(cmd);</a>
<a name="ln4426">}</a>
<a name="ln4427"> </a>
<a name="ln4428">// Return the name for the errorfile, in allocated memory.</a>
<a name="ln4429">// Find a new unique name when 'makeef' contains &quot;##&quot;.</a>
<a name="ln4430">// Returns NULL for error.</a>
<a name="ln4431">static char *get_mef_name(void)</a>
<a name="ln4432">{</a>
<a name="ln4433">  char *name;</a>
<a name="ln4434">  static int start = -1;</a>
<a name="ln4435">  static int off = 0;</a>
<a name="ln4436"> </a>
<a name="ln4437">  if (*p_mef == NUL) {</a>
<a name="ln4438">    name = vim_tempname();</a>
<a name="ln4439">    if (name == NULL) {</a>
<a name="ln4440">      emsg(_(e_notmp));</a>
<a name="ln4441">    }</a>
<a name="ln4442">    return name;</a>
<a name="ln4443">  }</a>
<a name="ln4444"> </a>
<a name="ln4445">  char *p;</a>
<a name="ln4446"> </a>
<a name="ln4447">  for (p = p_mef; *p; p++) {</a>
<a name="ln4448">    if (p[0] == '#' &amp;&amp; p[1] == '#') {</a>
<a name="ln4449">      break;</a>
<a name="ln4450">    }</a>
<a name="ln4451">  }</a>
<a name="ln4452"> </a>
<a name="ln4453">  if (*p == NUL) {</a>
<a name="ln4454">    return xstrdup(p_mef);</a>
<a name="ln4455">  }</a>
<a name="ln4456"> </a>
<a name="ln4457">  // Keep trying until the name doesn't exist yet.</a>
<a name="ln4458">  while (true) {</a>
<a name="ln4459">    if (start == -1) {</a>
<a name="ln4460">      start = (int)os_get_pid();</a>
<a name="ln4461">    } else {</a>
<a name="ln4462">      off += 19;</a>
<a name="ln4463">    }</a>
<a name="ln4464">    name = xmalloc(strlen(p_mef) + 30);</a>
<a name="ln4465">    STRCPY(name, p_mef);</a>
<a name="ln4466">    snprintf(name + (p - p_mef), strlen(name), &quot;%d%d&quot;, start, off);</a>
<a name="ln4467">    STRCAT(name, p + 2);</a>
<a name="ln4468">    // Don't accept a symbolic link, it's a security risk.</a>
<a name="ln4469">    FileInfo file_info;</a>
<a name="ln4470">    bool file_or_link_found = os_fileinfo_link(name, &amp;file_info);</a>
<a name="ln4471">    if (!file_or_link_found) {</a>
<a name="ln4472">      break;</a>
<a name="ln4473">    }</a>
<a name="ln4474">    xfree(name);</a>
<a name="ln4475">  }</a>
<a name="ln4476">  return name;</a>
<a name="ln4477">}</a>
<a name="ln4478"> </a>
<a name="ln4479">/// Returns the number of entries in the current quickfix/location list.</a>
<a name="ln4480">size_t qf_get_size(exarg_T *eap)</a>
<a name="ln4481">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4482">{</a>
<a name="ln4483">  qf_info_T *qi;</a>
<a name="ln4484"> </a>
<a name="ln4485">  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {</a>
<a name="ln4486">    return 0;</a>
<a name="ln4487">  }</a>
<a name="ln4488">  return (size_t)qf_get_curlist(qi)-&gt;qf_count;</a>
<a name="ln4489">}</a>
<a name="ln4490"> </a>
<a name="ln4491">/// Returns the number of valid entries in the current quickfix/location list.</a>
<a name="ln4492">size_t qf_get_valid_size(exarg_T *eap)</a>
<a name="ln4493">{</a>
<a name="ln4494">  qf_info_T *qi;</a>
<a name="ln4495"> </a>
<a name="ln4496">  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {</a>
<a name="ln4497">    return 0;</a>
<a name="ln4498">  }</a>
<a name="ln4499"> </a>
<a name="ln4500">  int prev_fnum = 0;</a>
<a name="ln4501">  size_t sz = 0;</a>
<a name="ln4502">  qfline_T *qfp;</a>
<a name="ln4503">  int i;</a>
<a name="ln4504">  assert(qf_get_curlist(qi)-&gt;qf_count &gt;= 0);</a>
<a name="ln4505">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln4506">  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln4507">    if (!qfp-&gt;qf_valid) {</a>
<a name="ln4508">      continue;</a>
<a name="ln4509">    }</a>
<a name="ln4510"> </a>
<a name="ln4511">    if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo) {</a>
<a name="ln4512">      // Count all valid entries.</a>
<a name="ln4513">      sz++;</a>
<a name="ln4514">    } else if (qfp-&gt;qf_fnum &gt; 0 &amp;&amp; qfp-&gt;qf_fnum != prev_fnum) {</a>
<a name="ln4515">      // Count the number of files.</a>
<a name="ln4516">      sz++;</a>
<a name="ln4517">      prev_fnum = qfp-&gt;qf_fnum;</a>
<a name="ln4518">    }</a>
<a name="ln4519">  }</a>
<a name="ln4520"> </a>
<a name="ln4521">  return sz;</a>
<a name="ln4522">}</a>
<a name="ln4523"> </a>
<a name="ln4524">/// Returns the current index of the quickfix/location list.</a>
<a name="ln4525">/// Returns 0 if there is an error.</a>
<a name="ln4526">size_t qf_get_cur_idx(exarg_T *eap)</a>
<a name="ln4527">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4528">{</a>
<a name="ln4529">  qf_info_T *qi;</a>
<a name="ln4530"> </a>
<a name="ln4531">  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {</a>
<a name="ln4532">    return 0;</a>
<a name="ln4533">  }</a>
<a name="ln4534"> </a>
<a name="ln4535">  assert(qf_get_curlist(qi)-&gt;qf_index &gt;= 0);</a>
<a name="ln4536">  return (size_t)qf_get_curlist(qi)-&gt;qf_index;</a>
<a name="ln4537">}</a>
<a name="ln4538"> </a>
<a name="ln4539">/// Returns the current index in the quickfix/location list,</a>
<a name="ln4540">/// counting only valid entries.</a>
<a name="ln4541">/// Returns 1 if there are no valid entries.</a>
<a name="ln4542">int qf_get_cur_valid_idx(exarg_T *eap)</a>
<a name="ln4543">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4544">{</a>
<a name="ln4545">  qf_info_T *qi;</a>
<a name="ln4546"> </a>
<a name="ln4547">  if ((qi = qf_cmd_get_stack(eap, false)) == NULL) {</a>
<a name="ln4548">    return 1;</a>
<a name="ln4549">  }</a>
<a name="ln4550"> </a>
<a name="ln4551">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln4552"> </a>
<a name="ln4553">  // Check if the list has valid errors.</a>
<a name="ln4554">  if (!qf_list_has_valid_entries(qfl)) {</a>
<a name="ln4555">    return 1;</a>
<a name="ln4556">  }</a>
<a name="ln4557"> </a>
<a name="ln4558">  int prev_fnum = 0;</a>
<a name="ln4559">  int eidx = 0;</a>
<a name="ln4560">  qfline_T *qfp;</a>
<a name="ln4561">  size_t i;</a>
<a name="ln4562">  assert(qfl-&gt;qf_index &gt;= 0);</a>
<a name="ln4563">  for (i = 1, qfp = qfl-&gt;qf_start;</a>
<a name="ln4564">       i &lt;= (size_t)qfl-&gt;qf_index &amp;&amp; qfp != NULL;</a>
<a name="ln4565">       i++, qfp = qfp-&gt;qf_next) {</a>
<a name="ln4566">    if (!qfp-&gt;qf_valid) {</a>
<a name="ln4567">      continue;</a>
<a name="ln4568">    }</a>
<a name="ln4569"> </a>
<a name="ln4570">    if (eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln4571">      if (qfp-&gt;qf_fnum &gt; 0 &amp;&amp; qfp-&gt;qf_fnum != prev_fnum) {</a>
<a name="ln4572">        // Count the number of files.</a>
<a name="ln4573">        eidx++;</a>
<a name="ln4574">        prev_fnum = qfp-&gt;qf_fnum;</a>
<a name="ln4575">      }</a>
<a name="ln4576">    } else {</a>
<a name="ln4577">      eidx++;</a>
<a name="ln4578">    }</a>
<a name="ln4579">  }</a>
<a name="ln4580"> </a>
<a name="ln4581">  return eidx != 0 ? eidx : 1;</a>
<a name="ln4582">}</a>
<a name="ln4583"> </a>
<a name="ln4584">/// Get the 'n'th valid error entry in the quickfix or location list.</a>
<a name="ln4585">///</a>
<a name="ln4586">/// Used by :cdo, :ldo, :cfdo and :lfdo commands.</a>
<a name="ln4587">/// For :cdo and :ldo, returns the 'n'th valid error entry.</a>
<a name="ln4588">/// For :cfdo and :lfdo, returns the 'n'th valid file entry.</a>
<a name="ln4589">static size_t qf_get_nth_valid_entry(qf_list_T *qfl, size_t n, int fdo)</a>
<a name="ln4590">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4591">{</a>
<a name="ln4592">  // Check if the list has valid errors.</a>
<a name="ln4593">  if (!qf_list_has_valid_entries(qfl)) {</a>
<a name="ln4594">    return 1;</a>
<a name="ln4595">  }</a>
<a name="ln4596"> </a>
<a name="ln4597">  int prev_fnum = 0;</a>
<a name="ln4598">  size_t eidx = 0;</a>
<a name="ln4599">  int i;</a>
<a name="ln4600">  qfline_T *qfp;</a>
<a name="ln4601">  assert(qfl-&gt;qf_count &gt;= 0);</a>
<a name="ln4602">  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln4603">    if (qfp-&gt;qf_valid) {</a>
<a name="ln4604">      if (fdo) {</a>
<a name="ln4605">        if (qfp-&gt;qf_fnum &gt; 0 &amp;&amp; qfp-&gt;qf_fnum != prev_fnum) {</a>
<a name="ln4606">          // Count the number of files.</a>
<a name="ln4607">          eidx++;</a>
<a name="ln4608">          prev_fnum = qfp-&gt;qf_fnum;</a>
<a name="ln4609">        }</a>
<a name="ln4610">      } else {</a>
<a name="ln4611">        eidx++;</a>
<a name="ln4612">      }</a>
<a name="ln4613">    }</a>
<a name="ln4614"> </a>
<a name="ln4615">    if (eidx == n) {</a>
<a name="ln4616">      break;</a>
<a name="ln4617">    }</a>
<a name="ln4618">  }</a>
<a name="ln4619"> </a>
<a name="ln4620">  return i &lt;= qfl-&gt;qf_count ? (size_t)i : 1;</a>
<a name="ln4621">}</a>
<a name="ln4622"> </a>
<a name="ln4623">/// &quot;:cc&quot;, &quot;:crewind&quot;, &quot;:cfirst&quot; and &quot;:clast&quot;.</a>
<a name="ln4624">/// &quot;:ll&quot;, &quot;:lrewind&quot;, &quot;:lfirst&quot; and &quot;:llast&quot;.</a>
<a name="ln4625">/// &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;.</a>
<a name="ln4626">void ex_cc(exarg_T *eap)</a>
<a name="ln4627">{</a>
<a name="ln4628">  qf_info_T *qi;</a>
<a name="ln4629"> </a>
<a name="ln4630">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln4631">    return;</a>
<a name="ln4632">  }</a>
<a name="ln4633"> </a>
<a name="ln4634">  int errornr;</a>
<a name="ln4635">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4636">    errornr = (int)eap-&gt;line2;</a>
<a name="ln4637">  } else {</a>
<a name="ln4638">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4639">    case CMD_cc:</a>
<a name="ln4640">    case CMD_ll:</a>
<a name="ln4641">      errornr = 0;</a>
<a name="ln4642">      break;</a>
<a name="ln4643">    case CMD_crewind:</a>
<a name="ln4644">    case CMD_lrewind:</a>
<a name="ln4645">    case CMD_cfirst:</a>
<a name="ln4646">    case CMD_lfirst:</a>
<a name="ln4647">      errornr = 1;</a>
<a name="ln4648">      break;</a>
<a name="ln4649">    default:</a>
<a name="ln4650">      errornr = 32767;</a>
<a name="ln4651">      break;</a>
<a name="ln4652">    }</a>
<a name="ln4653">  }</a>
<a name="ln4654"> </a>
<a name="ln4655">  // For cdo and ldo commands, jump to the nth valid error.</a>
<a name="ln4656">  // For cfdo and lfdo commands, jump to the nth valid file entry.</a>
<a name="ln4657">  if (eap-&gt;cmdidx == CMD_cdo || eap-&gt;cmdidx == CMD_ldo</a>
<a name="ln4658">      || eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo) {</a>
<a name="ln4659">    size_t n;</a>
<a name="ln4660">    if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4661">      assert(eap-&gt;line1 &gt;= 0);</a>
<a name="ln4662">      n = (size_t)eap-&gt;line1;</a>
<a name="ln4663">    } else {</a>
<a name="ln4664">      n = 1;</a>
<a name="ln4665">    }</a>
<a name="ln4666">    size_t valid_entry = qf_get_nth_valid_entry(qf_get_curlist(qi), n,</a>
<a name="ln4667">                                                eap-&gt;cmdidx == CMD_cfdo || eap-&gt;cmdidx == CMD_lfdo);</a>
<a name="ln4668">    assert(valid_entry &lt;= INT_MAX);</a>
<a name="ln4669">    errornr = (int)valid_entry;</a>
<a name="ln4670">  }</a>
<a name="ln4671"> </a>
<a name="ln4672">  qf_jump(qi, 0, errornr, eap-&gt;forceit);</a>
<a name="ln4673">}</a>
<a name="ln4674"> </a>
<a name="ln4675">/// &quot;:cnext&quot;, &quot;:cnfile&quot;, &quot;:cNext&quot; and &quot;:cprevious&quot;.</a>
<a name="ln4676">/// &quot;:lnext&quot;, &quot;:lNext&quot;, &quot;:lprevious&quot;, &quot;:lnfile&quot;, &quot;:lNfile&quot; and &quot;:lpfile&quot;.</a>
<a name="ln4677">/// &quot;:cdo&quot;, &quot;:ldo&quot;, &quot;:cfdo&quot; and &quot;:lfdo&quot;.</a>
<a name="ln4678">void ex_cnext(exarg_T *eap)</a>
<a name="ln4679">{</a>
<a name="ln4680">  qf_info_T *qi;</a>
<a name="ln4681"> </a>
<a name="ln4682">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln4683">    return;</a>
<a name="ln4684">  }</a>
<a name="ln4685"> </a>
<a name="ln4686">  int errornr;</a>
<a name="ln4687">  if (eap-&gt;addr_count &gt; 0</a>
<a name="ln4688">      &amp;&amp; (eap-&gt;cmdidx != CMD_cdo &amp;&amp; eap-&gt;cmdidx != CMD_ldo</a>
<a name="ln4689">          &amp;&amp; eap-&gt;cmdidx != CMD_cfdo &amp;&amp; eap-&gt;cmdidx != CMD_lfdo)) {</a>
<a name="ln4690">    errornr = (int)eap-&gt;line2;</a>
<a name="ln4691">  } else {</a>
<a name="ln4692">    errornr = 1;</a>
<a name="ln4693">  }</a>
<a name="ln4694"> </a>
<a name="ln4695">  // Depending on the command jump to either next or previous entry/file.</a>
<a name="ln4696">  Direction dir;</a>
<a name="ln4697">  switch (eap-&gt;cmdidx) {</a>
<a name="ln4698">  case CMD_cprevious:</a>
<a name="ln4699">  case CMD_lprevious:</a>
<a name="ln4700">  case CMD_cNext:</a>
<a name="ln4701">  case CMD_lNext:</a>
<a name="ln4702">    dir = BACKWARD;</a>
<a name="ln4703">    break;</a>
<a name="ln4704">  case CMD_cnfile:</a>
<a name="ln4705">  case CMD_lnfile:</a>
<a name="ln4706">  case CMD_cfdo:</a>
<a name="ln4707">  case CMD_lfdo:</a>
<a name="ln4708">    dir = FORWARD_FILE;</a>
<a name="ln4709">    break;</a>
<a name="ln4710">  case CMD_cpfile:</a>
<a name="ln4711">  case CMD_lpfile:</a>
<a name="ln4712">  case CMD_cNfile:</a>
<a name="ln4713">  case CMD_lNfile:</a>
<a name="ln4714">    dir = BACKWARD_FILE;</a>
<a name="ln4715">    break;</a>
<a name="ln4716">  case CMD_cnext:</a>
<a name="ln4717">  case CMD_lnext:</a>
<a name="ln4718">  case CMD_cdo:</a>
<a name="ln4719">  case CMD_ldo:</a>
<a name="ln4720">  default:</a>
<a name="ln4721">    dir = FORWARD;</a>
<a name="ln4722">    break;</a>
<a name="ln4723">  }</a>
<a name="ln4724"> </a>
<a name="ln4725">  qf_jump(qi, dir, errornr, eap-&gt;forceit);</a>
<a name="ln4726">}</a>
<a name="ln4727"> </a>
<a name="ln4728">/// Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.</a>
<a name="ln4729">/// The index of the entry is stored in 'errornr'.</a>
<a name="ln4730">/// Returns NULL if an entry is not found.</a>
<a name="ln4731">static qfline_T *qf_find_first_entry_in_buf(qf_list_T *qfl, int bnr, int *errornr)</a>
<a name="ln4732">{</a>
<a name="ln4733">  qfline_T *qfp = NULL;</a>
<a name="ln4734">  int idx = 0;</a>
<a name="ln4735"> </a>
<a name="ln4736">  // Find the first entry in this file</a>
<a name="ln4737">  FOR_ALL_QFL_ITEMS(qfl, qfp, idx) {</a>
<a name="ln4738">    if (qfp-&gt;qf_fnum == bnr) {</a>
<a name="ln4739">      break;</a>
<a name="ln4740">    }</a>
<a name="ln4741">  }</a>
<a name="ln4742"> </a>
<a name="ln4743">  *errornr = idx;</a>
<a name="ln4744">  return qfp;</a>
<a name="ln4745">}</a>
<a name="ln4746"> </a>
<a name="ln4747">/// Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'</a>
<a name="ln4748">/// with the error number for the first entry. Assumes the entries are sorted in</a>
<a name="ln4749">/// the quickfix list by line number.</a>
<a name="ln4750">static qfline_T *qf_find_first_entry_on_line(qfline_T *entry, int *errornr)</a>
<a name="ln4751">{</a>
<a name="ln4752">  while (!got_int</a>
<a name="ln4753">         &amp;&amp; entry-&gt;qf_prev != NULL</a>
<a name="ln4754">         &amp;&amp; entry-&gt;qf_fnum == entry-&gt;qf_prev-&gt;qf_fnum</a>
<a name="ln4755">         &amp;&amp; entry-&gt;qf_lnum == entry-&gt;qf_prev-&gt;qf_lnum) {</a>
<a name="ln4756">    entry = entry-&gt;qf_prev;</a>
<a name="ln4757">    (*errornr)--;</a>
<a name="ln4758">  }</a>
<a name="ln4759"> </a>
<a name="ln4760">  return entry;</a>
<a name="ln4761">}</a>
<a name="ln4762"> </a>
<a name="ln4763">/// Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'</a>
<a name="ln4764">/// with the error number for the last entry. Assumes the entries are sorted in</a>
<a name="ln4765">/// the quickfix list by line number.</a>
<a name="ln4766">static qfline_T *qf_find_last_entry_on_line(qfline_T *entry, int *errornr)</a>
<a name="ln4767">{</a>
<a name="ln4768">  while (!got_int</a>
<a name="ln4769">         &amp;&amp; entry-&gt;qf_next != NULL</a>
<a name="ln4770">         &amp;&amp; entry-&gt;qf_fnum == entry-&gt;qf_next-&gt;qf_fnum</a>
<a name="ln4771">         &amp;&amp; entry-&gt;qf_lnum == entry-&gt;qf_next-&gt;qf_lnum) {</a>
<a name="ln4772">    entry = entry-&gt;qf_next;</a>
<a name="ln4773">    (*errornr)++;</a>
<a name="ln4774">  }</a>
<a name="ln4775"> </a>
<a name="ln4776">  return entry;</a>
<a name="ln4777">}</a>
<a name="ln4778"> </a>
<a name="ln4779">// Returns true if the specified quickfix entry is</a>
<a name="ln4780">// after the given line (linewise is true)</a>
<a name="ln4781">// or after the line and column.</a>
<a name="ln4782">static bool qf_entry_after_pos(const qfline_T *qfp, const pos_T *pos, bool linewise)</a>
<a name="ln4783">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4784">{</a>
<a name="ln4785">  if (linewise) {</a>
<a name="ln4786">    return qfp-&gt;qf_lnum &gt; pos-&gt;lnum;</a>
<a name="ln4787">  }</a>
<a name="ln4788">  return qfp-&gt;qf_lnum &gt; pos-&gt;lnum</a>
<a name="ln4789">         || (qfp-&gt;qf_lnum == pos-&gt;lnum &amp;&amp; qfp-&gt;qf_col &gt; pos-&gt;col);</a>
<a name="ln4790">}</a>
<a name="ln4791"> </a>
<a name="ln4792">// Returns true if the specified quickfix entry is</a>
<a name="ln4793">// before the given line (linewise is true)</a>
<a name="ln4794">// or before the line and column.</a>
<a name="ln4795">static bool qf_entry_before_pos(const qfline_T *qfp, const pos_T *pos, bool linewise)</a>
<a name="ln4796">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4797">{</a>
<a name="ln4798">  if (linewise) {</a>
<a name="ln4799">    return qfp-&gt;qf_lnum &lt; pos-&gt;lnum;</a>
<a name="ln4800">  }</a>
<a name="ln4801">  return qfp-&gt;qf_lnum &lt; pos-&gt;lnum</a>
<a name="ln4802">         || (qfp-&gt;qf_lnum == pos-&gt;lnum &amp;&amp; qfp-&gt;qf_col &lt; pos-&gt;col);</a>
<a name="ln4803">}</a>
<a name="ln4804"> </a>
<a name="ln4805">// Returns true if the specified quickfix entry is</a>
<a name="ln4806">// on or after the given line (linewise is true)</a>
<a name="ln4807">// or on or after the line and column.</a>
<a name="ln4808">static bool qf_entry_on_or_after_pos(const qfline_T *qfp, const pos_T *pos, bool linewise)</a>
<a name="ln4809">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4810">{</a>
<a name="ln4811">  if (linewise) {</a>
<a name="ln4812">    return qfp-&gt;qf_lnum &gt;= pos-&gt;lnum;</a>
<a name="ln4813">  }</a>
<a name="ln4814">  return qfp-&gt;qf_lnum &gt; pos-&gt;lnum</a>
<a name="ln4815">         || (qfp-&gt;qf_lnum == pos-&gt;lnum &amp;&amp; qfp-&gt;qf_col &gt;= pos-&gt;col);</a>
<a name="ln4816">}</a>
<a name="ln4817"> </a>
<a name="ln4818">// Returns true if the specified quickfix entry is</a>
<a name="ln4819">// on or before the given line (linewise is true)</a>
<a name="ln4820">// or on or before the line and column.</a>
<a name="ln4821">static bool qf_entry_on_or_before_pos(const qfline_T *qfp, const pos_T *pos, bool linewise)</a>
<a name="ln4822">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4823">{</a>
<a name="ln4824">  if (linewise) {</a>
<a name="ln4825">    return qfp-&gt;qf_lnum &lt;= pos-&gt;lnum;</a>
<a name="ln4826">  }</a>
<a name="ln4827">  return qfp-&gt;qf_lnum &lt; pos-&gt;lnum</a>
<a name="ln4828">         || (qfp-&gt;qf_lnum == pos-&gt;lnum &amp;&amp; qfp-&gt;qf_col &lt;= pos-&gt;col);</a>
<a name="ln4829">}</a>
<a name="ln4830"> </a>
<a name="ln4831">/// Find the first quickfix entry after position 'pos' in buffer 'bnr'.</a>
<a name="ln4832">/// If 'linewise' is true, returns the entry after the specified line and treats</a>
<a name="ln4833">/// multiple entries on a single line as one. Otherwise returns the entry after</a>
<a name="ln4834">/// the specified line and column.</a>
<a name="ln4835">/// 'qfp' points to the very first entry in the buffer and 'errornr' is the</a>
<a name="ln4836">/// index of the very first entry in the quickfix list.</a>
<a name="ln4837">/// Returns NULL if an entry is not found after 'pos'.</a>
<a name="ln4838">static qfline_T *qf_find_entry_after_pos(int bnr, const pos_T *pos, bool linewise, qfline_T *qfp,</a>
<a name="ln4839">                                         int *errornr)</a>
<a name="ln4840">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4841">{</a>
<a name="ln4842">  if (qf_entry_after_pos(qfp, pos, linewise)) {</a>
<a name="ln4843">    // First entry is after position 'pos'</a>
<a name="ln4844">    return qfp;</a>
<a name="ln4845">  }</a>
<a name="ln4846"> </a>
<a name="ln4847">  // Find the entry just before or at the position 'pos'</a>
<a name="ln4848">  while (qfp-&gt;qf_next != NULL</a>
<a name="ln4849">         &amp;&amp; qfp-&gt;qf_next-&gt;qf_fnum == bnr</a>
<a name="ln4850">         &amp;&amp; qf_entry_on_or_before_pos(qfp-&gt;qf_next, pos, linewise)) {</a>
<a name="ln4851">    qfp = qfp-&gt;qf_next;</a>
<a name="ln4852">    (*errornr)++;</a>
<a name="ln4853">  }</a>
<a name="ln4854"> </a>
<a name="ln4855">  if (qfp-&gt;qf_next == NULL || qfp-&gt;qf_next-&gt;qf_fnum != bnr) {</a>
<a name="ln4856">    // No entries found after position 'pos'</a>
<a name="ln4857">    return NULL;</a>
<a name="ln4858">  }</a>
<a name="ln4859"> </a>
<a name="ln4860">  // Use the entry just after position 'pos'</a>
<a name="ln4861">  qfp = qfp-&gt;qf_next;</a>
<a name="ln4862">  (*errornr)++;</a>
<a name="ln4863"> </a>
<a name="ln4864">  return qfp;</a>
<a name="ln4865">}</a>
<a name="ln4866"> </a>
<a name="ln4867">/// Find the first quickfix entry before position 'pos' in buffer 'bnr'.</a>
<a name="ln4868">/// If 'linewise' is true, returns the entry before the specified line and</a>
<a name="ln4869">/// treats multiple entries on a single line as one. Otherwise returns the entry</a>
<a name="ln4870">/// before the specified line and column.</a>
<a name="ln4871">/// 'qfp' points to the very first entry in the buffer and 'errornr' is the</a>
<a name="ln4872">/// index of the very first entry in the quickfix list.</a>
<a name="ln4873">/// Returns NULL if an entry is not found before 'pos'.</a>
<a name="ln4874">static qfline_T *qf_find_entry_before_pos(int bnr, const pos_T *pos, bool linewise, qfline_T *qfp,</a>
<a name="ln4875">                                          int *errornr)</a>
<a name="ln4876">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4877">{</a>
<a name="ln4878">  // Find the entry just before the position 'pos'</a>
<a name="ln4879">  while (qfp-&gt;qf_next != NULL</a>
<a name="ln4880">         &amp;&amp; qfp-&gt;qf_next-&gt;qf_fnum == bnr</a>
<a name="ln4881">         &amp;&amp; qf_entry_before_pos(qfp-&gt;qf_next, pos, linewise)) {</a>
<a name="ln4882">    qfp = qfp-&gt;qf_next;</a>
<a name="ln4883">    (*errornr)++;</a>
<a name="ln4884">  }</a>
<a name="ln4885"> </a>
<a name="ln4886">  if (qf_entry_on_or_after_pos(qfp, pos, linewise)) {</a>
<a name="ln4887">    return NULL;</a>
<a name="ln4888">  }</a>
<a name="ln4889"> </a>
<a name="ln4890">  if (linewise) {</a>
<a name="ln4891">    // If multiple entries are on the same line, then use the first entry</a>
<a name="ln4892">    qfp = qf_find_first_entry_on_line(qfp, errornr);</a>
<a name="ln4893">  }</a>
<a name="ln4894"> </a>
<a name="ln4895">  return qfp;</a>
<a name="ln4896">}</a>
<a name="ln4897"> </a>
<a name="ln4898">/// Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in</a>
<a name="ln4899">/// the direction 'dir'.</a>
<a name="ln4900">static qfline_T *qf_find_closest_entry(qf_list_T *qfl, int bnr, const pos_T *pos, Direction dir,</a>
<a name="ln4901">                                       bool linewise, int *errornr)</a>
<a name="ln4902">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4903">{</a>
<a name="ln4904">  *errornr = 0;</a>
<a name="ln4905"> </a>
<a name="ln4906">  // Find the first entry in this file</a>
<a name="ln4907">  qfline_T *qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);</a>
<a name="ln4908">  if (qfp == NULL) {</a>
<a name="ln4909">    return NULL;  // no entry in this file</a>
<a name="ln4910">  }</a>
<a name="ln4911"> </a>
<a name="ln4912">  if (dir == FORWARD) {</a>
<a name="ln4913">    qfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);</a>
<a name="ln4914">  } else {</a>
<a name="ln4915">    qfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);</a>
<a name="ln4916">  }</a>
<a name="ln4917"> </a>
<a name="ln4918">  return qfp;</a>
<a name="ln4919">}</a>
<a name="ln4920"> </a>
<a name="ln4921">/// Get the nth quickfix entry below the specified entry.  Searches forward in</a>
<a name="ln4922">/// the list. If linewise is true, then treat multiple entries on a single line</a>
<a name="ln4923">/// as one.</a>
<a name="ln4924">static void qf_get_nth_below_entry(qfline_T *entry_arg, linenr_T n, bool linewise, int *errornr)</a>
<a name="ln4925">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4926">{</a>
<a name="ln4927">  qfline_T *entry = entry_arg;</a>
<a name="ln4928"> </a>
<a name="ln4929">  while (n-- &gt; 0 &amp;&amp; !got_int) {</a>
<a name="ln4930">    int first_errornr = *errornr;</a>
<a name="ln4931"> </a>
<a name="ln4932">    if (linewise) {</a>
<a name="ln4933">      // Treat all the entries on the same line in this file as one</a>
<a name="ln4934">      entry = qf_find_last_entry_on_line(entry, errornr);</a>
<a name="ln4935">    }</a>
<a name="ln4936"> </a>
<a name="ln4937">    if (entry-&gt;qf_next == NULL</a>
<a name="ln4938">        || entry-&gt;qf_next-&gt;qf_fnum != entry-&gt;qf_fnum) {</a>
<a name="ln4939">      if (linewise) {</a>
<a name="ln4940">        *errornr = first_errornr;</a>
<a name="ln4941">      }</a>
<a name="ln4942">      break;</a>
<a name="ln4943">    }</a>
<a name="ln4944"> </a>
<a name="ln4945">    entry = entry-&gt;qf_next;</a>
<a name="ln4946">    (*errornr)++;</a>
<a name="ln4947">  }</a>
<a name="ln4948">}</a>
<a name="ln4949"> </a>
<a name="ln4950">/// Get the nth quickfix entry above the specified entry.  Searches backwards in</a>
<a name="ln4951">/// the list. If linewise is true, then treat multiple entries on a single line</a>
<a name="ln4952">/// as one.</a>
<a name="ln4953">static void qf_get_nth_above_entry(qfline_T *entry, linenr_T n, bool linewise, int *errornr)</a>
<a name="ln4954">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4955">{</a>
<a name="ln4956">  while (n-- &gt; 0 &amp;&amp; !got_int) {</a>
<a name="ln4957">    if (entry-&gt;qf_prev == NULL</a>
<a name="ln4958">        || entry-&gt;qf_prev-&gt;qf_fnum != entry-&gt;qf_fnum) {</a>
<a name="ln4959">      break;</a>
<a name="ln4960">    }</a>
<a name="ln4961"> </a>
<a name="ln4962">    entry = entry-&gt;qf_prev;</a>
<a name="ln4963">    (*errornr)--;</a>
<a name="ln4964"> </a>
<a name="ln4965">    if (linewise) {</a>
<a name="ln4966">      entry = qf_find_first_entry_on_line(entry, errornr);</a>
<a name="ln4967">    }</a>
<a name="ln4968">  }</a>
<a name="ln4969">}</a>
<a name="ln4970"> </a>
<a name="ln4971">/// Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in</a>
<a name="ln4972">/// the specified direction.  Returns the error number in the quickfix list or 0</a>
<a name="ln4973">/// if an entry is not found.</a>
<a name="ln4974">static int qf_find_nth_adj_entry(qf_list_T *qfl, int bnr, pos_T *pos, linenr_T n, Direction dir,</a>
<a name="ln4975">                                 bool linewise)</a>
<a name="ln4976">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4977">{</a>
<a name="ln4978">  int errornr;</a>
<a name="ln4979"> </a>
<a name="ln4980">  // Find an entry closest to the specified position</a>
<a name="ln4981">  qfline_T *const adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir,</a>
<a name="ln4982">                                                    linewise, &amp;errornr);</a>
<a name="ln4983">  if (adj_entry == NULL) {</a>
<a name="ln4984">    return 0;</a>
<a name="ln4985">  }</a>
<a name="ln4986"> </a>
<a name="ln4987">  if (--n &gt; 0) {</a>
<a name="ln4988">    // Go to the n'th entry in the current buffer</a>
<a name="ln4989">    if (dir == FORWARD) {</a>
<a name="ln4990">      qf_get_nth_below_entry(adj_entry, n, linewise, &amp;errornr);</a>
<a name="ln4991">    } else {</a>
<a name="ln4992">      qf_get_nth_above_entry(adj_entry, n, linewise, &amp;errornr);</a>
<a name="ln4993">    }</a>
<a name="ln4994">  }</a>
<a name="ln4995"> </a>
<a name="ln4996">  return errornr;</a>
<a name="ln4997">}</a>
<a name="ln4998"> </a>
<a name="ln4999">/// Jump to a quickfix entry in the current file nearest to the current line or</a>
<a name="ln5000">/// current line/col.</a>
<a name="ln5001">/// &quot;:cabove&quot;, &quot;:cbelow&quot;, &quot;:labove&quot;, &quot;:lbelow&quot;, &quot;:cafter&quot;, &quot;:cbefore&quot;,</a>
<a name="ln5002">/// &quot;:lafter&quot; and &quot;:lbefore&quot; commands</a>
<a name="ln5003">void ex_cbelow(exarg_T *eap)</a>
<a name="ln5004">{</a>
<a name="ln5005">  if (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line2 &lt;= 0) {</a>
<a name="ln5006">    emsg(_(e_invrange));</a>
<a name="ln5007">    return;</a>
<a name="ln5008">  }</a>
<a name="ln5009"> </a>
<a name="ln5010">  // Check whether the current buffer has any quickfix entries</a>
<a name="ln5011">  int buf_has_flag = (eap-&gt;cmdidx == CMD_cabove</a>
<a name="ln5012">                      || eap-&gt;cmdidx == CMD_cbelow</a>
<a name="ln5013">                      || eap-&gt;cmdidx == CMD_cbefore</a>
<a name="ln5014">                      || eap-&gt;cmdidx == CMD_cafter) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;</a>
<a name="ln5015"> </a>
<a name="ln5016">  if (!(curbuf-&gt;b_has_qf_entry &amp; buf_has_flag)) {</a>
<a name="ln5017">    emsg(_(e_no_errors));</a>
<a name="ln5018">    return;</a>
<a name="ln5019">  }</a>
<a name="ln5020"> </a>
<a name="ln5021">  qf_info_T *qi;</a>
<a name="ln5022">  if ((qi = qf_cmd_get_stack(eap, true)) == NULL) {</a>
<a name="ln5023">    return;</a>
<a name="ln5024">  }</a>
<a name="ln5025"> </a>
<a name="ln5026">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln5027">  // check if the list has valid errors</a>
<a name="ln5028">  if (!qf_list_has_valid_entries(qfl)) {</a>
<a name="ln5029">    emsg(_(e_no_errors));</a>
<a name="ln5030">    return;</a>
<a name="ln5031">  }</a>
<a name="ln5032"> </a>
<a name="ln5033">  // Forward motion commands</a>
<a name="ln5034">  int dir = (eap-&gt;cmdidx == CMD_cbelow</a>
<a name="ln5035">             || eap-&gt;cmdidx == CMD_lbelow</a>
<a name="ln5036">             || eap-&gt;cmdidx == CMD_cafter</a>
<a name="ln5037">             || eap-&gt;cmdidx == CMD_lafter) ? FORWARD : BACKWARD;</a>
<a name="ln5038"> </a>
<a name="ln5039">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln5040">  // A quickfix entry column number is 1 based whereas cursor column</a>
<a name="ln5041">  // number is 0 based. Adjust the column number.</a>
<a name="ln5042">  pos.col++;</a>
<a name="ln5043">  const int errornr = qf_find_nth_adj_entry(qfl,</a>
<a name="ln5044">                                            curbuf-&gt;b_fnum,</a>
<a name="ln5045">                                            &amp;pos,</a>
<a name="ln5046">                                            eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0,</a>
<a name="ln5047">                                            dir,</a>
<a name="ln5048">                                            eap-&gt;cmdidx == CMD_cbelow</a>
<a name="ln5049">                                            || eap-&gt;cmdidx == CMD_lbelow</a>
<a name="ln5050">                                            || eap-&gt;cmdidx == CMD_cabove</a>
<a name="ln5051">                                            || eap-&gt;cmdidx == CMD_labove);</a>
<a name="ln5052"> </a>
<a name="ln5053">  if (errornr &gt; 0) {</a>
<a name="ln5054">    qf_jump(qi, 0, errornr, false);</a>
<a name="ln5055">  } else {</a>
<a name="ln5056">    emsg(_(e_no_more_items));</a>
<a name="ln5057">  }</a>
<a name="ln5058">}</a>
<a name="ln5059"> </a>
<a name="ln5060">/// Return the autocmd name for the :cfile Ex commands</a>
<a name="ln5061">static char *cfile_get_auname(cmdidx_T cmdidx)</a>
<a name="ln5062">{</a>
<a name="ln5063">  switch (cmdidx) {</a>
<a name="ln5064">  case CMD_cfile:</a>
<a name="ln5065">    return &quot;cfile&quot;;</a>
<a name="ln5066">  case CMD_cgetfile:</a>
<a name="ln5067">    return &quot;cgetfile&quot;;</a>
<a name="ln5068">  case CMD_caddfile:</a>
<a name="ln5069">    return &quot;caddfile&quot;;</a>
<a name="ln5070">  case CMD_lfile:</a>
<a name="ln5071">    return &quot;lfile&quot;;</a>
<a name="ln5072">  case CMD_lgetfile:</a>
<a name="ln5073">    return &quot;lgetfile&quot;;</a>
<a name="ln5074">  case CMD_laddfile:</a>
<a name="ln5075">    return &quot;laddfile&quot;;</a>
<a name="ln5076">  default:</a>
<a name="ln5077">    return NULL;</a>
<a name="ln5078">  }</a>
<a name="ln5079">}</a>
<a name="ln5080"> </a>
<a name="ln5081">// &quot;:cfile&quot;/&quot;:cgetfile&quot;/&quot;:caddfile&quot; commands.</a>
<a name="ln5082">// &quot;:lfile&quot;/&quot;:lgetfile&quot;/&quot;:laddfile&quot; commands.</a>
<a name="ln5083">void ex_cfile(exarg_T *eap)</a>
<a name="ln5084">{</a>
<a name="ln5085">  win_T *wp = NULL;</a>
<a name="ln5086">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln5087">  char *au_name = NULL;</a>
<a name="ln5088"> </a>
<a name="ln5089">  au_name = cfile_get_auname(eap-&gt;cmdidx);</a>
<a name="ln5090">  if (au_name != NULL</a>
<a name="ln5091">      &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name, NULL, false, curbuf)) {</a>
<a name="ln5092">    if (aborting()) {</a>
<a name="ln5093">      return;</a>
<a name="ln5094">    }</a>
<a name="ln5095">  }</a>
<a name="ln5096">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln5097">    set_string_option_direct(&quot;ef&quot;, -1, eap-&gt;arg, OPT_FREE, 0);</a>
<a name="ln5098">  }</a>
<a name="ln5099"> </a>
<a name="ln5100">  char *enc = (*curbuf-&gt;b_p_menc != NUL) ? curbuf-&gt;b_p_menc : p_menc;</a>
<a name="ln5101"> </a>
<a name="ln5102">  if (is_loclist_cmd(eap-&gt;cmdidx)) {</a>
<a name="ln5103">    wp = curwin;</a>
<a name="ln5104">  }</a>
<a name="ln5105"> </a>
<a name="ln5106">  incr_quickfix_busy();</a>
<a name="ln5107"> </a>
<a name="ln5108">  // This function is used by the :cfile, :cgetfile and :caddfile</a>
<a name="ln5109">  // commands.</a>
<a name="ln5110">  // :cfile always creates a new quickfix list and jumps to the</a>
<a name="ln5111">  // first error.</a>
<a name="ln5112">  // :cgetfile creates a new quickfix list but doesn't jump to the</a>
<a name="ln5113">  // first error.</a>
<a name="ln5114">  // :caddfile adds to an existing quickfix list. If there is no</a>
<a name="ln5115">  // quickfix list then a new list is created.</a>
<a name="ln5116">  int res = qf_init(wp, p_ef, p_efm, (eap-&gt;cmdidx != CMD_caddfile</a>
<a name="ln5117">                                      &amp;&amp; eap-&gt;cmdidx != CMD_laddfile),</a>
<a name="ln5118">                    qf_cmdtitle(*eap-&gt;cmdlinep), enc);</a>
<a name="ln5119">  if (wp != NULL) {</a>
<a name="ln5120">    qi = GET_LOC_LIST(wp);</a>
<a name="ln5121">    if (qi == NULL) {</a>
<a name="ln5122">      decr_quickfix_busy();</a>
<a name="ln5123">      return;</a>
<a name="ln5124">    }</a>
<a name="ln5125">  }</a>
<a name="ln5126">  if (res &gt;= 0) {</a>
<a name="ln5127">    qf_list_changed(qf_get_curlist(qi));</a>
<a name="ln5128">  }</a>
<a name="ln5129">  unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln5130">  if (au_name != NULL) {</a>
<a name="ln5131">    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, false, curbuf);</a>
<a name="ln5132">  }</a>
<a name="ln5133">  // Jump to the first error for a new list and if autocmds didn't free the</a>
<a name="ln5134">  // list.</a>
<a name="ln5135">  if (res &gt; 0 &amp;&amp; (eap-&gt;cmdidx == CMD_cfile || eap-&gt;cmdidx == CMD_lfile)</a>
<a name="ln5136">      &amp;&amp; qflist_valid(wp, save_qfid)) {</a>
<a name="ln5137">    // display the first error</a>
<a name="ln5138">    qf_jump_first(qi, save_qfid, eap-&gt;forceit);</a>
<a name="ln5139">  }</a>
<a name="ln5140"> </a>
<a name="ln5141">  decr_quickfix_busy();</a>
<a name="ln5142">}</a>
<a name="ln5143"> </a>
<a name="ln5144">/// Return the vimgrep autocmd name.</a>
<a name="ln5145">static char *vgr_get_auname(cmdidx_T cmdidx)</a>
<a name="ln5146">{</a>
<a name="ln5147">  switch (cmdidx) {</a>
<a name="ln5148">  case CMD_vimgrep:</a>
<a name="ln5149">    return &quot;vimgrep&quot;;</a>
<a name="ln5150">  case CMD_lvimgrep:</a>
<a name="ln5151">    return &quot;lvimgrep&quot;;</a>
<a name="ln5152">  case CMD_vimgrepadd:</a>
<a name="ln5153">    return &quot;vimgrepadd&quot;;</a>
<a name="ln5154">  case CMD_lvimgrepadd:</a>
<a name="ln5155">    return &quot;lvimgrepadd&quot;;</a>
<a name="ln5156">  case CMD_grep:</a>
<a name="ln5157">    return &quot;grep&quot;;</a>
<a name="ln5158">  case CMD_lgrep:</a>
<a name="ln5159">    return &quot;lgrep&quot;;</a>
<a name="ln5160">  case CMD_grepadd:</a>
<a name="ln5161">    return &quot;grepadd&quot;;</a>
<a name="ln5162">  case CMD_lgrepadd:</a>
<a name="ln5163">    return &quot;lgrepadd&quot;;</a>
<a name="ln5164">  default:</a>
<a name="ln5165">    return NULL;</a>
<a name="ln5166">  }</a>
<a name="ln5167">}</a>
<a name="ln5168"> </a>
<a name="ln5169">/// Initialize the regmatch used by vimgrep for pattern &quot;s&quot;.</a>
<a name="ln5170">static void vgr_init_regmatch(regmmatch_T *regmatch, char *s)</a>
<a name="ln5171">{</a>
<a name="ln5172">  // Get the search pattern: either white-separated or enclosed in //.</a>
<a name="ln5173">  regmatch-&gt;regprog = NULL;</a>
<a name="ln5174"> </a>
<a name="ln5175">  if (s == NULL || *s == NUL) {</a>
<a name="ln5176">    // Pattern is empty, use last search pattern.</a>
<a name="ln5177">    if (last_search_pat() == NULL) {</a>
<a name="ln5178">      emsg(_(e_noprevre));</a>
<a name="ln5179">      return;</a>
<a name="ln5180">    }</a>
<a name="ln5181">    regmatch-&gt;regprog = vim_regcomp(last_search_pat(), RE_MAGIC);</a>
<a name="ln5182">  } else {</a>
<a name="ln5183">    regmatch-&gt;regprog = vim_regcomp(s, RE_MAGIC);</a>
<a name="ln5184">  }</a>
<a name="ln5185"> </a>
<a name="ln5186">  regmatch-&gt;rmm_ic = p_ic;</a>
<a name="ln5187">  regmatch-&gt;rmm_maxcol = 0;</a>
<a name="ln5188">}</a>
<a name="ln5189"> </a>
<a name="ln5190">/// Display a file name when vimgrep is running.</a>
<a name="ln5191">static void vgr_display_fname(char *fname)</a>
<a name="ln5192">{</a>
<a name="ln5193">  msg_start();</a>
<a name="ln5194">  char *p = msg_strtrunc(fname, true);</a>
<a name="ln5195">  if (p == NULL) {</a>
<a name="ln5196">    msg_outtrans(fname, 0);</a>
<a name="ln5197">  } else {</a>
<a name="ln5198">    msg_outtrans(p, 0);</a>
<a name="ln5199">    xfree(p);</a>
<a name="ln5200">  }</a>
<a name="ln5201">  msg_clr_eos();</a>
<a name="ln5202">  msg_didout = false;  // overwrite this message</a>
<a name="ln5203">  msg_nowait = true;   // don't wait for this message</a>
<a name="ln5204">  msg_col = 0;</a>
<a name="ln5205">  ui_flush();</a>
<a name="ln5206">}</a>
<a name="ln5207"> </a>
<a name="ln5208">/// Load a dummy buffer to search for a pattern using vimgrep.</a>
<a name="ln5209">static buf_T *vgr_load_dummy_buf(char *fname, char *dirname_start, char *dirname_now)</a>
<a name="ln5210">{</a>
<a name="ln5211">  // Don't do Filetype autocommands to avoid loading syntax and</a>
<a name="ln5212">  // indent scripts, a great speed improvement.</a>
<a name="ln5213">  char *save_ei = au_event_disable(&quot;,Filetype&quot;);</a>
<a name="ln5214"> </a>
<a name="ln5215">  OptInt save_mls = p_mls;</a>
<a name="ln5216">  p_mls = 0;</a>
<a name="ln5217"> </a>
<a name="ln5218">  // Load file into a buffer, so that 'fileencoding' is detected,</a>
<a name="ln5219">  // autocommands applied, etc.</a>
<a name="ln5220">  buf_T *buf = load_dummy_buffer(fname, dirname_start, dirname_now);</a>
<a name="ln5221"> </a>
<a name="ln5222">  p_mls = save_mls;</a>
<a name="ln5223">  au_event_restore(save_ei);</a>
<a name="ln5224"> </a>
<a name="ln5225">  return buf;</a>
<a name="ln5226">}</a>
<a name="ln5227"> </a>
<a name="ln5228">/// Check whether a quickfix/location list is valid. Autocmds may remove or</a>
<a name="ln5229">/// change a quickfix list when vimgrep is running. If the list is not found,</a>
<a name="ln5230">/// create a new list.</a>
<a name="ln5231">static bool vgr_qflist_valid(win_T *wp, qf_info_T *qi, unsigned qfid, char *title)</a>
<a name="ln5232">{</a>
<a name="ln5233">  // Verify that the quickfix/location list was not freed by an autocmd</a>
<a name="ln5234">  if (!qflist_valid(wp, qfid)) {</a>
<a name="ln5235">    if (wp != NULL) {</a>
<a name="ln5236">      // An autocmd has freed the location list</a>
<a name="ln5237">      emsg(_(e_current_location_list_was_changed));</a>
<a name="ln5238">      return false;</a>
<a name="ln5239">    }</a>
<a name="ln5240">    // Quickfix list is not found, create a new one.</a>
<a name="ln5241">    qf_new_list(qi, title);</a>
<a name="ln5242">    return true;</a>
<a name="ln5243">  }</a>
<a name="ln5244">  if (qf_restore_list(qi, qfid) == FAIL) {</a>
<a name="ln5245">    return false;</a>
<a name="ln5246">  }</a>
<a name="ln5247"> </a>
<a name="ln5248">  return true;</a>
<a name="ln5249">}</a>
<a name="ln5250"> </a>
<a name="ln5251">/// Search for a pattern in all the lines in a buffer and add the matching lines</a>
<a name="ln5252">/// to a quickfix list.</a>
<a name="ln5253">static bool vgr_match_buflines(qf_list_T *qfl, char *fname, buf_T *buf, char *spat,</a>
<a name="ln5254">                               regmmatch_T *regmatch, int *tomatch, int duplicate_name, int flags)</a>
<a name="ln5255">  FUNC_ATTR_NONNULL_ARG(1, 3, 4, 5, 6)</a>
<a name="ln5256">{</a>
<a name="ln5257">  bool found_match = false;</a>
<a name="ln5258">  size_t pat_len = strlen(spat);</a>
<a name="ln5259">  if (pat_len &gt; MAX_FUZZY_MATCHES) {</a>
<a name="ln5260">    pat_len = MAX_FUZZY_MATCHES;</a>
<a name="ln5261">  }</a>
<a name="ln5262"> </a>
<a name="ln5263">  for (linenr_T lnum = 1; lnum &lt;= buf-&gt;b_ml.ml_line_count &amp;&amp; *tomatch &gt; 0; lnum++) {</a>
<a name="ln5264">    colnr_T col = 0;</a>
<a name="ln5265">    if (!(flags &amp; VGR_FUZZY)) {</a>
<a name="ln5266">      // Regular expression match</a>
<a name="ln5267">      while (vim_regexec_multi(regmatch, curwin, buf, lnum, col, NULL, NULL) &gt; 0) {</a>
<a name="ln5268">        // Pass the buffer number so that it gets used even for a</a>
<a name="ln5269">        // dummy buffer, unless duplicate_name is set, then the</a>
<a name="ln5270">        // buffer will be wiped out below.</a>
<a name="ln5271">        if (qf_add_entry(qfl,</a>
<a name="ln5272">                         NULL,   // dir</a>
<a name="ln5273">                         fname,</a>
<a name="ln5274">                         NULL,</a>
<a name="ln5275">                         duplicate_name ? 0 : buf-&gt;b_fnum,</a>
<a name="ln5276">                         ml_get_buf(buf, regmatch-&gt;startpos[0].lnum + lnum),</a>
<a name="ln5277">                         regmatch-&gt;startpos[0].lnum + lnum,</a>
<a name="ln5278">                         regmatch-&gt;endpos[0].lnum + lnum,</a>
<a name="ln5279">                         regmatch-&gt;startpos[0].col + 1,</a>
<a name="ln5280">                         regmatch-&gt;endpos[0].col + 1,</a>
<a name="ln5281">                         false,  // vis_col</a>
<a name="ln5282">                         NULL,   // search pattern</a>
<a name="ln5283">                         0,      // nr</a>
<a name="ln5284">                         0,      // type</a>
<a name="ln5285">                         NULL,   // user_data</a>
<a name="ln5286">                         true)   // valid</a>
<a name="ln5287">            == QF_FAIL) {</a>
<a name="ln5288">          got_int = true;</a>
<a name="ln5289">          break;</a>
<a name="ln5290">        }</a>
<a name="ln5291">        found_match = true;</a>
<a name="ln5292">        if (--*tomatch == 0) {</a>
<a name="ln5293">          break;</a>
<a name="ln5294">        }</a>
<a name="ln5295">        if ((flags &amp; VGR_GLOBAL) == 0 || regmatch-&gt;endpos[0].lnum &gt; 0) {</a>
<a name="ln5296">          break;</a>
<a name="ln5297">        }</a>
<a name="ln5298">        col = regmatch-&gt;endpos[0].col + (col == regmatch-&gt;endpos[0].col);</a>
<a name="ln5299">        if (col &gt; (colnr_T)strlen(ml_get_buf(buf, lnum))) {</a>
<a name="ln5300">          break;</a>
<a name="ln5301">        }</a>
<a name="ln5302">      }</a>
<a name="ln5303">    } else {</a>
<a name="ln5304">      char *const str = ml_get_buf(buf, lnum);</a>
<a name="ln5305">      int score;</a>
<a name="ln5306">      uint32_t matches[MAX_FUZZY_MATCHES];</a>
<a name="ln5307">      const size_t sz = sizeof(matches) / sizeof(matches[0]);</a>
<a name="ln5308"> </a>
<a name="ln5309">      // Fuzzy string match</a>
<a name="ln5310">      CLEAR_FIELD(matches);</a>
<a name="ln5311">      while (fuzzy_match(str + col, spat, false, &amp;score, matches, (int)sz) &gt; 0) {</a>
<a name="ln5312">        // Pass the buffer number so that it gets used even for a</a>
<a name="ln5313">        // dummy buffer, unless duplicate_name is set, then the</a>
<a name="ln5314">        // buffer will be wiped out below.</a>
<a name="ln5315">        if (qf_add_entry(qfl,</a>
<a name="ln5316">                         NULL,   // dir</a>
<a name="ln5317">                         fname,</a>
<a name="ln5318">                         NULL,</a>
<a name="ln5319">                         duplicate_name ? 0 : buf-&gt;b_fnum,</a>
<a name="ln5320">                         str,</a>
<a name="ln5321">                         lnum,</a>
<a name="ln5322">                         0,</a>
<a name="ln5323">                         (colnr_T)matches[0] + col + 1,</a>
<a name="ln5324">                         0,</a>
<a name="ln5325">                         false,  // vis_col</a>
<a name="ln5326">                         NULL,   // search pattern</a>
<a name="ln5327">                         0,      // nr</a>
<a name="ln5328">                         0,      // type</a>
<a name="ln5329">                         NULL,   // user_data</a>
<a name="ln5330">                         true)   // valid</a>
<a name="ln5331">            == QF_FAIL) {</a>
<a name="ln5332">          got_int = true;</a>
<a name="ln5333">          break;</a>
<a name="ln5334">        }</a>
<a name="ln5335">        found_match = true;</a>
<a name="ln5336">        if (--*tomatch == 0) {</a>
<a name="ln5337">          break;</a>
<a name="ln5338">        }</a>
<a name="ln5339">        if ((flags &amp; VGR_GLOBAL) == 0) {</a>
<a name="ln5340">          break;</a>
<a name="ln5341">        }</a>
<a name="ln5342">        col = (colnr_T)matches[pat_len - 1] + col + 1;</a>
<a name="ln5343">        if (col &gt; (colnr_T)strlen(str)) {</a>
<a name="ln5344">          break;</a>
<a name="ln5345">        }</a>
<a name="ln5346">      }</a>
<a name="ln5347">    }</a>
<a name="ln5348">    line_breakcheck();</a>
<a name="ln5349">    if (got_int) {</a>
<a name="ln5350">      break;</a>
<a name="ln5351">    }</a>
<a name="ln5352">  }</a>
<a name="ln5353"> </a>
<a name="ln5354">  return found_match;</a>
<a name="ln5355">}</a>
<a name="ln5356"> </a>
<a name="ln5357">/// Jump to the first match and update the directory.</a>
<a name="ln5358">static void vgr_jump_to_match(qf_info_T *qi, int forceit, bool *redraw_for_dummy,</a>
<a name="ln5359">                              buf_T *first_match_buf, char *target_dir)  // NOLINT(readability-non-const-parameter)</a>
<a name="ln5360">{</a>
<a name="ln5361">  buf_T *buf = curbuf;</a>
<a name="ln5362">  qf_jump(qi, 0, 0, forceit);</a>
<a name="ln5363">  if (buf != curbuf) {</a>
<a name="ln5364">    // If we jumped to another buffer redrawing will already be</a>
<a name="ln5365">    // taken care of.</a>
<a name="ln5366">    *redraw_for_dummy = false;</a>
<a name="ln5367">  }</a>
<a name="ln5368"> </a>
<a name="ln5369">  // Jump to the directory used after loading the buffer.</a>
<a name="ln5370">  if (curbuf == first_match_buf &amp;&amp; target_dir != NULL) {</a>
<a name="ln5371">    exarg_T ea = {</a>
<a name="ln5372">      .arg = target_dir,</a>
<a name="ln5373">      .cmdidx = CMD_lcd,</a>
<a name="ln5374">    };</a>
<a name="ln5375">    ex_cd(&amp;ea);</a>
<a name="ln5376">  }</a>
<a name="ln5377">}</a>
<a name="ln5378"> </a>
<a name="ln5379">// Return true if &quot;buf&quot; had an existing swap file, the current swap file does</a>
<a name="ln5380">// not end in &quot;.swp&quot;.</a>
<a name="ln5381">static bool existing_swapfile(const buf_T *buf)</a>
<a name="ln5382">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln5383">{</a>
<a name="ln5384">  if (buf-&gt;b_ml.ml_mfp != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln5385">    const char *const fname = buf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln5386">    const size_t len = strlen(fname);</a>
<a name="ln5387"> </a>
<a name="ln5388">    return fname[len - 1] != 'p' || fname[len - 2] != 'w';</a>
<a name="ln5389">  }</a>
<a name="ln5390">  return false;</a>
<a name="ln5391">}</a>
<a name="ln5392"> </a>
<a name="ln5393">/// Process :vimgrep command arguments. The command syntax is:</a>
<a name="ln5394">///</a>
<a name="ln5395">/// :{count}vimgrep /{pattern}/[g][j] {file} ...</a>
<a name="ln5396">static int vgr_process_args(exarg_T *eap, vgr_args_T *args)</a>
<a name="ln5397">{</a>
<a name="ln5398">  CLEAR_POINTER(args);</a>
<a name="ln5399"> </a>
<a name="ln5400">  args-&gt;regmatch.regprog = NULL;</a>
<a name="ln5401">  args-&gt;qf_title = xstrdup(qf_cmdtitle(*eap-&gt;cmdlinep));</a>
<a name="ln5402"> </a>
<a name="ln5403">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5404">    args-&gt;tomatch = eap-&gt;line2;</a>
<a name="ln5405">  } else {</a>
<a name="ln5406">    args-&gt;tomatch = MAXLNUM;</a>
<a name="ln5407">  }</a>
<a name="ln5408"> </a>
<a name="ln5409">  // Get the search pattern: either white-separated or enclosed in //</a>
<a name="ln5410">  char *p = skip_vimgrep_pat(eap-&gt;arg, &amp;args-&gt;spat, &amp;args-&gt;flags);</a>
<a name="ln5411">  if (p == NULL) {</a>
<a name="ln5412">    emsg(_(e_invalpat));</a>
<a name="ln5413">    return FAIL;</a>
<a name="ln5414">  }</a>
<a name="ln5415"> </a>
<a name="ln5416">  vgr_init_regmatch(&amp;args-&gt;regmatch, args-&gt;spat);</a>
<a name="ln5417">  if (args-&gt;regmatch.regprog == NULL) {</a>
<a name="ln5418">    return FAIL;</a>
<a name="ln5419">  }</a>
<a name="ln5420"> </a>
<a name="ln5421">  p = skipwhite(p);</a>
<a name="ln5422">  if (*p == NUL) {</a>
<a name="ln5423">    emsg(_(&quot;E683: File name missing or invalid pattern&quot;));</a>
<a name="ln5424">    return FAIL;</a>
<a name="ln5425">  }</a>
<a name="ln5426"> </a>
<a name="ln5427">  // Parse the list of arguments, wildcards have already been expanded.</a>
<a name="ln5428">  if (get_arglist_exp(p, &amp;args-&gt;fcount, &amp;args-&gt;fnames, true) == FAIL</a>
<a name="ln5429">      || args-&gt;fcount == 0) {</a>
<a name="ln5430">    emsg(_(e_nomatch));</a>
<a name="ln5431">    return FAIL;</a>
<a name="ln5432">  }</a>
<a name="ln5433"> </a>
<a name="ln5434">  return OK;</a>
<a name="ln5435">}</a>
<a name="ln5436"> </a>
<a name="ln5437">/// Search for a pattern in a list of files and populate the quickfix list with</a>
<a name="ln5438">/// the matches.</a>
<a name="ln5439">static int vgr_process_files(win_T *wp, qf_info_T *qi, vgr_args_T *cmd_args, bool *redraw_for_dummy,</a>
<a name="ln5440">                             buf_T **first_match_buf, char **target_dir)</a>
<a name="ln5441">{</a>
<a name="ln5442">  int status = FAIL;</a>
<a name="ln5443">  unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln5444">  bool duplicate_name = false;</a>
<a name="ln5445"> </a>
<a name="ln5446">  char *dirname_start = xmalloc(MAXPATHL);</a>
<a name="ln5447">  char *dirname_now = xmalloc(MAXPATHL);</a>
<a name="ln5448"> </a>
<a name="ln5449">  // Remember the current directory, because a BufRead autocommand that does</a>
<a name="ln5450">  // &quot;:lcd %:p:h&quot; changes the meaning of short path names.</a>
<a name="ln5451">  os_dirname(dirname_start, MAXPATHL);</a>
<a name="ln5452"> </a>
<a name="ln5453">  time_t seconds = 0;</a>
<a name="ln5454">  for (int fi = 0; fi &lt; cmd_args-&gt;fcount &amp;&amp; !got_int &amp;&amp; cmd_args-&gt;tomatch &gt; 0; fi++) {</a>
<a name="ln5455">    char *fname = path_try_shorten_fname(cmd_args-&gt;fnames[fi]);</a>
<a name="ln5456">    if (time(NULL) &gt; seconds) {</a>
<a name="ln5457">      // Display the file name every second or so, show the user we are</a>
<a name="ln5458">      // working on it.</a>
<a name="ln5459">      seconds = time(NULL);</a>
<a name="ln5460">      vgr_display_fname(fname);</a>
<a name="ln5461">    }</a>
<a name="ln5462"> </a>
<a name="ln5463">    buf_T *buf = buflist_findname_exp(cmd_args-&gt;fnames[fi]);</a>
<a name="ln5464">    bool using_dummy;</a>
<a name="ln5465">    if (buf == NULL || buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln5466">      // Remember that a buffer with this name already exists.</a>
<a name="ln5467">      duplicate_name = (buf != NULL);</a>
<a name="ln5468">      using_dummy = true;</a>
<a name="ln5469">      *redraw_for_dummy = true;</a>
<a name="ln5470">      buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);</a>
<a name="ln5471">    } else {</a>
<a name="ln5472">      // Use existing, loaded buffer.</a>
<a name="ln5473">      using_dummy = false;</a>
<a name="ln5474">    }</a>
<a name="ln5475"> </a>
<a name="ln5476">    // Check whether the quickfix list is still valid. When loading a</a>
<a name="ln5477">    // buffer above, autocommands might have changed the quickfix list.</a>
<a name="ln5478">    if (!vgr_qflist_valid(wp, qi, save_qfid, cmd_args-&gt;qf_title)) {</a>
<a name="ln5479">      goto theend;</a>
<a name="ln5480">    }</a>
<a name="ln5481"> </a>
<a name="ln5482">    save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln5483"> </a>
<a name="ln5484">    if (buf == NULL) {</a>
<a name="ln5485">      if (!got_int) {</a>
<a name="ln5486">        smsg(0, _(&quot;Cannot open file \&quot;%s\&quot;&quot;), fname);</a>
<a name="ln5487">      }</a>
<a name="ln5488">    } else {</a>
<a name="ln5489">      // Try for a match in all lines of the buffer.</a>
<a name="ln5490">      // For &quot;:1vimgrep&quot; look for first match only.</a>
<a name="ln5491">      bool found_match = vgr_match_buflines(qf_get_curlist(qi),</a>
<a name="ln5492">                                            fname,</a>
<a name="ln5493">                                            buf,</a>
<a name="ln5494">                                            cmd_args-&gt;spat,</a>
<a name="ln5495">                                            &amp;cmd_args-&gt;regmatch,</a>
<a name="ln5496">                                            &amp;cmd_args-&gt;tomatch,</a>
<a name="ln5497">                                            duplicate_name,</a>
<a name="ln5498">                                            cmd_args-&gt;flags);</a>
<a name="ln5499"> </a>
<a name="ln5500">      if (using_dummy) {</a>
<a name="ln5501">        if (found_match &amp;&amp; *first_match_buf == NULL) {</a>
<a name="ln5502">          *first_match_buf = buf;</a>
<a name="ln5503">        }</a>
<a name="ln5504">        if (duplicate_name) {</a>
<a name="ln5505">          // Never keep a dummy buffer if there is another buffer</a>
<a name="ln5506">          // with the same name.</a>
<a name="ln5507">          wipe_dummy_buffer(buf, dirname_start);</a>
<a name="ln5508">          buf = NULL;</a>
<a name="ln5509">        } else if ((cmdmod.cmod_flags &amp; CMOD_HIDE) == 0</a>
<a name="ln5510">                   || buf-&gt;b_p_bh[0] == 'u'             // &quot;unload&quot;</a>
<a name="ln5511">                   || buf-&gt;b_p_bh[0] == 'w'             // &quot;wipe&quot;</a>
<a name="ln5512">                   || buf-&gt;b_p_bh[0] == 'd') {          // &quot;delete&quot;</a>
<a name="ln5513">          // When no match was found we don't need to remember the</a>
<a name="ln5514">          // buffer, wipe it out.  If there was a match and it</a>
<a name="ln5515">          // wasn't the first one or we won't jump there: only</a>
<a name="ln5516">          // unload the buffer.</a>
<a name="ln5517">          // Ignore 'hidden' here, because it may lead to having too</a>
<a name="ln5518">          // many swap files.</a>
<a name="ln5519">          if (!found_match) {</a>
<a name="ln5520">            wipe_dummy_buffer(buf, dirname_start);</a>
<a name="ln5521">            buf = NULL;</a>
<a name="ln5522">          } else if (buf != *first_match_buf</a>
<a name="ln5523">                     || (cmd_args-&gt;flags &amp; VGR_NOJUMP)</a>
<a name="ln5524">                     || existing_swapfile(buf)) {</a>
<a name="ln5525">            unload_dummy_buffer(buf, dirname_start);</a>
<a name="ln5526">            // Keeping the buffer, remove the dummy flag.</a>
<a name="ln5527">            buf-&gt;b_flags &amp;= ~BF_DUMMY;</a>
<a name="ln5528">            buf = NULL;</a>
<a name="ln5529">          }</a>
<a name="ln5530">        }</a>
<a name="ln5531"> </a>
<a name="ln5532">        if (buf != NULL) {</a>
<a name="ln5533">          // Keeping the buffer, remove the dummy flag.</a>
<a name="ln5534">          buf-&gt;b_flags &amp;= ~BF_DUMMY;</a>
<a name="ln5535"> </a>
<a name="ln5536">          // If the buffer is still loaded we need to use the</a>
<a name="ln5537">          // directory we jumped to below.</a>
<a name="ln5538">          if (buf == *first_match_buf</a>
<a name="ln5539">              &amp;&amp; *target_dir == NULL</a>
<a name="ln5540">              &amp;&amp; strcmp(dirname_start, dirname_now) != 0) {</a>
<a name="ln5541">            *target_dir = xstrdup(dirname_now);</a>
<a name="ln5542">          }</a>
<a name="ln5543"> </a>
<a name="ln5544">          // The buffer is still loaded, the Filetype autocommands</a>
<a name="ln5545">          // need to be done now, in that buffer.  And the modelines</a>
<a name="ln5546">          // need to be done (again).  But not the window-local</a>
<a name="ln5547">          // options!</a>
<a name="ln5548">          aco_save_T aco;</a>
<a name="ln5549">          aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln5550">          apply_autocmds(EVENT_FILETYPE, buf-&gt;b_p_ft, buf-&gt;b_fname, true, buf);</a>
<a name="ln5551">          do_modelines(OPT_NOWIN);</a>
<a name="ln5552">          aucmd_restbuf(&amp;aco);</a>
<a name="ln5553">        }</a>
<a name="ln5554">      }</a>
<a name="ln5555">    }</a>
<a name="ln5556">  }</a>
<a name="ln5557"> </a>
<a name="ln5558">  status = OK;</a>
<a name="ln5559"> </a>
<a name="ln5560">theend:</a>
<a name="ln5561">  xfree(dirname_now);</a>
<a name="ln5562">  xfree(dirname_start);</a>
<a name="ln5563">  return status;</a>
<a name="ln5564">}</a>
<a name="ln5565"> </a>
<a name="ln5566">/// &quot;:vimgrep {pattern} file(s)&quot;</a>
<a name="ln5567">/// &quot;:vimgrepadd {pattern} file(s)&quot;</a>
<a name="ln5568">/// &quot;:lvimgrep {pattern} file(s)&quot;</a>
<a name="ln5569">/// &quot;:lvimgrepadd {pattern} file(s)&quot;</a>
<a name="ln5570">void ex_vimgrep(exarg_T *eap)</a>
<a name="ln5571">{</a>
<a name="ln5572">  char *au_name = vgr_get_auname(eap-&gt;cmdidx);</a>
<a name="ln5573">  if (au_name != NULL &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,</a>
<a name="ln5574">                                        curbuf-&gt;b_fname, true, curbuf)) {</a>
<a name="ln5575">    if (aborting()) {</a>
<a name="ln5576">      return;</a>
<a name="ln5577">    }</a>
<a name="ln5578">  }</a>
<a name="ln5579"> </a>
<a name="ln5580">  win_T *wp = NULL;</a>
<a name="ln5581">  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &amp;wp);</a>
<a name="ln5582">  char *target_dir = NULL;</a>
<a name="ln5583">  vgr_args_T args;</a>
<a name="ln5584">  if (vgr_process_args(eap, &amp;args) == FAIL) {</a>
<a name="ln5585">    goto theend;</a>
<a name="ln5586">  }</a>
<a name="ln5587"> </a>
<a name="ln5588">  if ((eap-&gt;cmdidx != CMD_grepadd &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln5589">       &amp;&amp; eap-&gt;cmdidx != CMD_vimgrepadd &amp;&amp; eap-&gt;cmdidx != CMD_lvimgrepadd)</a>
<a name="ln5590">      || qf_stack_empty(qi)) {</a>
<a name="ln5591">    // make place for a new list</a>
<a name="ln5592">    qf_new_list(qi, args.qf_title);</a>
<a name="ln5593">  }</a>
<a name="ln5594"> </a>
<a name="ln5595">  incr_quickfix_busy();</a>
<a name="ln5596"> </a>
<a name="ln5597">  bool redraw_for_dummy = false;</a>
<a name="ln5598">  buf_T *first_match_buf = NULL;</a>
<a name="ln5599">  int status = vgr_process_files(wp, qi, &amp;args, &amp;redraw_for_dummy, &amp;first_match_buf, &amp;target_dir);</a>
<a name="ln5600"> </a>
<a name="ln5601">  if (status != OK) {</a>
<a name="ln5602">    FreeWild(args.fcount, args.fnames);</a>
<a name="ln5603">    decr_quickfix_busy();</a>
<a name="ln5604">    goto theend;</a>
<a name="ln5605">  }</a>
<a name="ln5606"> </a>
<a name="ln5607">  FreeWild(args.fcount, args.fnames);</a>
<a name="ln5608"> </a>
<a name="ln5609">  qf_list_T *qfl = qf_get_curlist(qi);</a>
<a name="ln5610">  qfl-&gt;qf_nonevalid = false;</a>
<a name="ln5611">  qfl-&gt;qf_ptr = qfl-&gt;qf_start;</a>
<a name="ln5612">  qfl-&gt;qf_index = 1;</a>
<a name="ln5613">  qf_list_changed(qfl);</a>
<a name="ln5614"> </a>
<a name="ln5615">  qf_update_buffer(qi, NULL);</a>
<a name="ln5616"> </a>
<a name="ln5617">  // Remember the current quickfix list identifier, so that we can check for</a>
<a name="ln5618">  // autocommands changing the current quickfix list.</a>
<a name="ln5619">  unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln5620"> </a>
<a name="ln5621">  if (au_name != NULL) {</a>
<a name="ln5622">    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln5623">  }</a>
<a name="ln5624"> </a>
<a name="ln5625">  // The QuickFixCmdPost autocmd may free the quickfix list. Check the list</a>
<a name="ln5626">  // is still valid.</a>
<a name="ln5627">  if (!qflist_valid(wp, save_qfid) || qf_restore_list(qi, save_qfid) == FAIL) {</a>
<a name="ln5628">    decr_quickfix_busy();</a>
<a name="ln5629">    goto theend;</a>
<a name="ln5630">  }</a>
<a name="ln5631"> </a>
<a name="ln5632">  // Jump to first match.</a>
<a name="ln5633">  if (!qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln5634">    if ((args.flags &amp; VGR_NOJUMP) == 0) {</a>
<a name="ln5635">      vgr_jump_to_match(qi, eap-&gt;forceit, &amp;redraw_for_dummy, first_match_buf, target_dir);</a>
<a name="ln5636">    }</a>
<a name="ln5637">  } else {</a>
<a name="ln5638">    semsg(_(e_nomatch2), args.spat);</a>
<a name="ln5639">  }</a>
<a name="ln5640"> </a>
<a name="ln5641">  decr_quickfix_busy();</a>
<a name="ln5642"> </a>
<a name="ln5643">  // If we loaded a dummy buffer into the current window, the autocommands</a>
<a name="ln5644">  // may have messed up things, need to redraw and recompute folds.</a>
<a name="ln5645">  if (redraw_for_dummy) {</a>
<a name="ln5646">    foldUpdateAll(curwin);</a>
<a name="ln5647">  }</a>
<a name="ln5648"> </a>
<a name="ln5649">theend:</a>
<a name="ln5650">  xfree(args.qf_title);</a>
<a name="ln5651">  xfree(target_dir);</a>
<a name="ln5652">  vim_regfree(args.regmatch.regprog);</a>
<a name="ln5653">}</a>
<a name="ln5654"> </a>
<a name="ln5655">// Restore current working directory to &quot;dirname_start&quot; if they differ, taking</a>
<a name="ln5656">// into account whether it is set locally or globally.</a>
<a name="ln5657">static void restore_start_dir(char *dirname_start)</a>
<a name="ln5658">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5659">{</a>
<a name="ln5660">  char *dirname_now = xmalloc(MAXPATHL);</a>
<a name="ln5661"> </a>
<a name="ln5662">  os_dirname(dirname_now, MAXPATHL);</a>
<a name="ln5663">  if (strcmp(dirname_start, dirname_now) != 0) {</a>
<a name="ln5664">    // If the directory has changed, change it back by building up an</a>
<a name="ln5665">    // appropriate ex command and executing it.</a>
<a name="ln5666">    exarg_T ea = {</a>
<a name="ln5667">      .arg = dirname_start,</a>
<a name="ln5668">      .cmdidx = (curwin-&gt;w_localdir == NULL) ? CMD_cd : CMD_lcd,</a>
<a name="ln5669">    };</a>
<a name="ln5670">    ex_cd(&amp;ea);</a>
<a name="ln5671">  }</a>
<a name="ln5672">  xfree(dirname_now);</a>
<a name="ln5673">}</a>
<a name="ln5674"> </a>
<a name="ln5675">/// Load file &quot;fname&quot; into a dummy buffer and return the buffer pointer,</a>
<a name="ln5676">/// placing the directory resulting from the buffer load into the</a>
<a name="ln5677">/// &quot;resulting_dir&quot; pointer. &quot;resulting_dir&quot; must be allocated by the caller</a>
<a name="ln5678">/// prior to calling this function. Restores directory to &quot;dirname_start&quot; prior</a>
<a name="ln5679">/// to returning, if autocmds or the 'autochdir' option have changed it.</a>
<a name="ln5680">///</a>
<a name="ln5681">/// If creating the dummy buffer does not fail, must call unload_dummy_buffer()</a>
<a name="ln5682">/// or wipe_dummy_buffer() later!</a>
<a name="ln5683">///</a>
<a name="ln5684">/// @param dirname_start  in: old directory</a>
<a name="ln5685">/// @param resulting_dir  out: new directory</a>
<a name="ln5686">///</a>
<a name="ln5687">/// @return  NULL if it fails.</a>
<a name="ln5688">static buf_T *load_dummy_buffer(char *fname, char *dirname_start, char *resulting_dir)</a>
<a name="ln5689">{</a>
<a name="ln5690">  // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln5691">  buf_T *newbuf = buflist_new(NULL, NULL, 1, BLN_DUMMY);</a>
<a name="ln5692">  if (newbuf == NULL) {</a>
<a name="ln5693">    return NULL;</a>
<a name="ln5694">  }</a>
<a name="ln5695"> </a>
<a name="ln5696">  int failed = true;</a>
<a name="ln5697">  bufref_T newbufref;</a>
<a name="ln5698">  set_bufref(&amp;newbufref, newbuf);</a>
<a name="ln5699"> </a>
<a name="ln5700">  // Init the options.</a>
<a name="ln5701">  buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln5702"> </a>
<a name="ln5703">  // need to open the memfile before putting the buffer in a window</a>
<a name="ln5704">  if (ml_open(newbuf) == OK) {</a>
<a name="ln5705">    // Make sure this buffer isn't wiped out by autocommands.</a>
<a name="ln5706">    newbuf-&gt;b_locked++;</a>
<a name="ln5707">    // set curwin/curbuf to buf and save a few things</a>
<a name="ln5708">    aco_save_T aco;</a>
<a name="ln5709">    aucmd_prepbuf(&amp;aco, newbuf);</a>
<a name="ln5710"> </a>
<a name="ln5711">    // Need to set the filename for autocommands.</a>
<a name="ln5712">    (void)setfname(curbuf, fname, NULL, false);</a>
<a name="ln5713"> </a>
<a name="ln5714">    // Create swap file now to avoid the ATTENTION message.</a>
<a name="ln5715">    check_need_swap(true);</a>
<a name="ln5716"> </a>
<a name="ln5717">    // Remove the &quot;dummy&quot; flag, otherwise autocommands may not</a>
<a name="ln5718">    // work.</a>
<a name="ln5719">    curbuf-&gt;b_flags &amp;= ~BF_DUMMY;</a>
<a name="ln5720"> </a>
<a name="ln5721">    bufref_T newbuf_to_wipe;</a>
<a name="ln5722">    newbuf_to_wipe.br_buf = NULL;</a>
<a name="ln5723">    int readfile_result = readfile(fname, NULL, 0, 0,</a>
<a name="ln5724">                                   (linenr_T)MAXLNUM, NULL,</a>
<a name="ln5725">                                   READ_NEW | READ_DUMMY, false);</a>
<a name="ln5726">    newbuf-&gt;b_locked--;</a>
<a name="ln5727">    if (readfile_result == OK</a>
<a name="ln5728">        &amp;&amp; !got_int</a>
<a name="ln5729">        &amp;&amp; !(curbuf-&gt;b_flags &amp; BF_NEW)) {</a>
<a name="ln5730">      failed = false;</a>
<a name="ln5731">      if (curbuf != newbuf) {</a>
<a name="ln5732">        // Bloody autocommands changed the buffer!  Can happen when</a>
<a name="ln5733">        // using netrw and editing a remote file.  Use the current</a>
<a name="ln5734">        // buffer instead, delete the dummy one after restoring the</a>
<a name="ln5735">        // window stuff.</a>
<a name="ln5736">        set_bufref(&amp;newbuf_to_wipe, newbuf);</a>
<a name="ln5737">        newbuf = curbuf;</a>
<a name="ln5738">      }</a>
<a name="ln5739">    }</a>
<a name="ln5740"> </a>
<a name="ln5741">    // Restore curwin/curbuf and a few other things.</a>
<a name="ln5742">    aucmd_restbuf(&amp;aco);</a>
<a name="ln5743"> </a>
<a name="ln5744">    if (newbuf_to_wipe.br_buf != NULL &amp;&amp; bufref_valid(&amp;newbuf_to_wipe)) {</a>
<a name="ln5745">      wipe_buffer(newbuf_to_wipe.br_buf, false);</a>
<a name="ln5746">    }</a>
<a name="ln5747"> </a>
<a name="ln5748">    // Add back the &quot;dummy&quot; flag, otherwise buflist_findname_file_id()</a>
<a name="ln5749">    // won't skip it.</a>
<a name="ln5750">    newbuf-&gt;b_flags |= BF_DUMMY;</a>
<a name="ln5751">  }</a>
<a name="ln5752"> </a>
<a name="ln5753">  // When autocommands/'autochdir' option changed directory: go back.</a>
<a name="ln5754">  // Let the caller know what the resulting dir was first, in case it is</a>
<a name="ln5755">  // important.</a>
<a name="ln5756">  os_dirname(resulting_dir, MAXPATHL);</a>
<a name="ln5757">  restore_start_dir(dirname_start);</a>
<a name="ln5758"> </a>
<a name="ln5759">  if (!bufref_valid(&amp;newbufref)) {</a>
<a name="ln5760">    return NULL;</a>
<a name="ln5761">  }</a>
<a name="ln5762">  if (failed) {</a>
<a name="ln5763">    wipe_dummy_buffer(newbuf, dirname_start);</a>
<a name="ln5764">    return NULL;</a>
<a name="ln5765">  }</a>
<a name="ln5766">  return newbuf;</a>
<a name="ln5767">}</a>
<a name="ln5768"> </a>
<a name="ln5769">// Wipe out the dummy buffer that load_dummy_buffer() created. Restores</a>
<a name="ln5770">// directory to &quot;dirname_start&quot; prior to returning, if autocmds or the</a>
<a name="ln5771">// 'autochdir' option have changed it.</a>
<a name="ln5772">static void wipe_dummy_buffer(buf_T *buf, char *dirname_start)</a>
<a name="ln5773">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5774">{</a>
<a name="ln5775">  // If any autocommand opened a window on the dummy buffer, close that</a>
<a name="ln5776">  // window.  If we can't close them all then give up.</a>
<a name="ln5777">  while (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln5778">    bool did_one = false;</a>
<a name="ln5779"> </a>
<a name="ln5780">    if (firstwin-&gt;w_next != NULL) {</a>
<a name="ln5781">      for (win_T *wp = firstwin; wp != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln5782">        if (wp-&gt;w_buffer == buf) {</a>
<a name="ln5783">          if (win_close(wp, false, false) == OK) {</a>
<a name="ln5784">            did_one = true;</a>
<a name="ln5785">          }</a>
<a name="ln5786">          break;</a>
<a name="ln5787">        }</a>
<a name="ln5788">      }</a>
<a name="ln5789">    }</a>
<a name="ln5790">    if (!did_one) {</a>
<a name="ln5791">      return;</a>
<a name="ln5792">    }</a>
<a name="ln5793">  }</a>
<a name="ln5794"> </a>
<a name="ln5795">  if (curbuf != buf &amp;&amp; buf-&gt;b_nwindows == 0) {  // safety check</a>
<a name="ln5796">    cleanup_T cs;</a>
<a name="ln5797"> </a>
<a name="ln5798">    // Reset the error/interrupt/exception state here so that aborting()</a>
<a name="ln5799">    // returns false when wiping out the buffer.  Otherwise it doesn't</a>
<a name="ln5800">    // work when got_int is set.</a>
<a name="ln5801">    enter_cleanup(&amp;cs);</a>
<a name="ln5802"> </a>
<a name="ln5803">    wipe_buffer(buf, true);</a>
<a name="ln5804"> </a>
<a name="ln5805">    // Restore the error/interrupt/exception state if not discarded by a</a>
<a name="ln5806">    // new aborting error, interrupt, or uncaught exception.</a>
<a name="ln5807">    leave_cleanup(&amp;cs);</a>
<a name="ln5808">    // When autocommands/'autochdir' option changed directory: go back.</a>
<a name="ln5809">    restore_start_dir(dirname_start);</a>
<a name="ln5810">  }</a>
<a name="ln5811">}</a>
<a name="ln5812"> </a>
<a name="ln5813">// Unload the dummy buffer that load_dummy_buffer() created. Restores</a>
<a name="ln5814">// directory to &quot;dirname_start&quot; prior to returning, if autocmds or the</a>
<a name="ln5815">// 'autochdir' option have changed it.</a>
<a name="ln5816">static void unload_dummy_buffer(buf_T *buf, char *dirname_start)</a>
<a name="ln5817">{</a>
<a name="ln5818">  if (curbuf == buf) {          // safety check</a>
<a name="ln5819">    return;</a>
<a name="ln5820">  }</a>
<a name="ln5821"> </a>
<a name="ln5822">  close_buffer(NULL, buf, DOBUF_UNLOAD, false, true);</a>
<a name="ln5823"> </a>
<a name="ln5824">  // When autocommands/'autochdir' option changed directory: go back.</a>
<a name="ln5825">  restore_start_dir(dirname_start);</a>
<a name="ln5826">}</a>
<a name="ln5827"> </a>
<a name="ln5828">/// Copy the specified quickfix entry items into a new dict and append the dict</a>
<a name="ln5829">/// to 'list'.  Returns OK on success.</a>
<a name="ln5830">static int get_qfline_items(qfline_T *qfp, list_T *list)</a>
<a name="ln5831">{</a>
<a name="ln5832">  // Handle entries with a non-existing buffer number.</a>
<a name="ln5833">  int bufnum = qfp-&gt;qf_fnum;</a>
<a name="ln5834">  if (bufnum != 0 &amp;&amp; (buflist_findnr(bufnum) == NULL)) {</a>
<a name="ln5835">    bufnum = 0;</a>
<a name="ln5836">  }</a>
<a name="ln5837"> </a>
<a name="ln5838">  dict_T *const dict = tv_dict_alloc();</a>
<a name="ln5839">  tv_list_append_dict(list, dict);</a>
<a name="ln5840"> </a>
<a name="ln5841">  char buf[2];</a>
<a name="ln5842">  buf[0] = qfp-&gt;qf_type;</a>
<a name="ln5843">  buf[1] = NUL;</a>
<a name="ln5844">  if (tv_dict_add_nr(dict, S_LEN(&quot;bufnr&quot;), (varnumber_T)bufnum) == FAIL</a>
<a name="ln5845">      || (tv_dict_add_nr(dict, S_LEN(&quot;lnum&quot;), (varnumber_T)qfp-&gt;qf_lnum) == FAIL)</a>
<a name="ln5846">      || (tv_dict_add_nr(dict, S_LEN(&quot;end_lnum&quot;), (varnumber_T)qfp-&gt;qf_end_lnum) == FAIL)</a>
<a name="ln5847">      || (tv_dict_add_nr(dict, S_LEN(&quot;col&quot;), (varnumber_T)qfp-&gt;qf_col) == FAIL)</a>
<a name="ln5848">      || (tv_dict_add_nr(dict, S_LEN(&quot;end_col&quot;), (varnumber_T)qfp-&gt;qf_end_col) == FAIL)</a>
<a name="ln5849">      || (tv_dict_add_nr(dict, S_LEN(&quot;vcol&quot;), (varnumber_T)qfp-&gt;qf_viscol) == FAIL)</a>
<a name="ln5850">      || (tv_dict_add_nr(dict, S_LEN(&quot;nr&quot;), (varnumber_T)qfp-&gt;qf_nr) == FAIL)</a>
<a name="ln5851">      || (tv_dict_add_str(dict, S_LEN(&quot;module&quot;), (qfp-&gt;qf_module == NULL ? &quot;&quot; : qfp-&gt;qf_module))</a>
<a name="ln5852">          == FAIL)</a>
<a name="ln5853">      || (tv_dict_add_str(dict, S_LEN(&quot;pattern&quot;), (qfp-&gt;qf_pattern == NULL ? &quot;&quot; : qfp-&gt;qf_pattern))</a>
<a name="ln5854">          == FAIL)</a>
<a name="ln5855">      || (tv_dict_add_str(dict, S_LEN(&quot;text&quot;), (qfp-&gt;qf_text == NULL ? &quot;&quot; : qfp-&gt;qf_text)) == FAIL)</a>
<a name="ln5856">      || (tv_dict_add_str(dict, S_LEN(&quot;type&quot;), buf) == FAIL)</a>
<a name="ln5857">      || (qfp-&gt;qf_user_data.v_type != VAR_UNKNOWN</a>
<a name="ln5858">          &amp;&amp; tv_dict_add_tv(dict, S_LEN(&quot;user_data&quot;), &amp;qfp-&gt;qf_user_data) == FAIL)</a>
<a name="ln5859">      || (tv_dict_add_nr(dict, S_LEN(&quot;valid&quot;), (varnumber_T)qfp-&gt;qf_valid) == FAIL)) {</a>
<a name="ln5860">    // tv_dict_add* fail only if key already exist, but this is a newly</a>
<a name="ln5861">    // allocated dictionary which is thus guaranteed to have no existing keys.</a>
<a name="ln5862">    abort();</a>
<a name="ln5863">  }</a>
<a name="ln5864"> </a>
<a name="ln5865">  return OK;</a>
<a name="ln5866">}</a>
<a name="ln5867"> </a>
<a name="ln5868">/// Add each quickfix error to list &quot;list&quot; as a dictionary.</a>
<a name="ln5869">/// If qf_idx is -1, use the current list. Otherwise, use the specified list.</a>
<a name="ln5870">/// If eidx is not 0, then return only the specified entry. Otherwise return</a>
<a name="ln5871">/// all the entries.</a>
<a name="ln5872">static int get_errorlist(qf_info_T *qi_arg, win_T *wp, int qf_idx, int eidx, list_T *list)</a>
<a name="ln5873">{</a>
<a name="ln5874">  qf_info_T *qi = qi_arg;</a>
<a name="ln5875"> </a>
<a name="ln5876">  if (qi == NULL) {</a>
<a name="ln5877">    qi = &amp;ql_info;</a>
<a name="ln5878">    if (wp != NULL) {</a>
<a name="ln5879">      qi = GET_LOC_LIST(wp);</a>
<a name="ln5880">      if (qi == NULL) {</a>
<a name="ln5881">        return FAIL;</a>
<a name="ln5882">      }</a>
<a name="ln5883">    }</a>
<a name="ln5884">  }</a>
<a name="ln5885"> </a>
<a name="ln5886">  if (eidx &lt; 0) {</a>
<a name="ln5887">    return OK;</a>
<a name="ln5888">  }</a>
<a name="ln5889"> </a>
<a name="ln5890">  if (qf_idx == INVALID_QFIDX) {</a>
<a name="ln5891">    qf_idx = qi-&gt;qf_curlist;</a>
<a name="ln5892">  }</a>
<a name="ln5893"> </a>
<a name="ln5894">  if (qf_idx &gt;= qi-&gt;qf_listcount) {</a>
<a name="ln5895">    return FAIL;</a>
<a name="ln5896">  }</a>
<a name="ln5897"> </a>
<a name="ln5898">  qf_list_T *qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln5899">  if (qf_list_empty(qfl)) {</a>
<a name="ln5900">    return FAIL;</a>
<a name="ln5901">  }</a>
<a name="ln5902"> </a>
<a name="ln5903">  qfline_T *qfp;</a>
<a name="ln5904">  int i;</a>
<a name="ln5905">  FOR_ALL_QFL_ITEMS(qfl, qfp, i) {</a>
<a name="ln5906">    if (eidx &gt; 0) {</a>
<a name="ln5907">      if (eidx == i) {</a>
<a name="ln5908">        return get_qfline_items(qfp, list);</a>
<a name="ln5909">      }</a>
<a name="ln5910">    } else if (get_qfline_items(qfp, list) == FAIL) {</a>
<a name="ln5911">      return FAIL;</a>
<a name="ln5912">    }</a>
<a name="ln5913">  }</a>
<a name="ln5914"> </a>
<a name="ln5915">  return OK;</a>
<a name="ln5916">}</a>
<a name="ln5917"> </a>
<a name="ln5918">/// Flags used by getqflist()/getloclist() to determine which fields to return.</a>
<a name="ln5919">enum {</a>
<a name="ln5920">  QF_GETLIST_NONE = 0x0,</a>
<a name="ln5921">  QF_GETLIST_TITLE = 0x1,</a>
<a name="ln5922">  QF_GETLIST_ITEMS = 0x2,</a>
<a name="ln5923">  QF_GETLIST_NR = 0x4,</a>
<a name="ln5924">  QF_GETLIST_WINID = 0x8,</a>
<a name="ln5925">  QF_GETLIST_CONTEXT = 0x10,</a>
<a name="ln5926">  QF_GETLIST_ID = 0x20,</a>
<a name="ln5927">  QF_GETLIST_IDX = 0x40,</a>
<a name="ln5928">  QF_GETLIST_SIZE = 0x80,</a>
<a name="ln5929">  QF_GETLIST_TICK = 0x100,</a>
<a name="ln5930">  QF_GETLIST_FILEWINID = 0x200,</a>
<a name="ln5931">  QF_GETLIST_QFBUFNR = 0x400,</a>
<a name="ln5932">  QF_GETLIST_QFTF = 0x800,</a>
<a name="ln5933">  QF_GETLIST_ALL = 0xFFF,</a>
<a name="ln5934">};</a>
<a name="ln5935"> </a>
<a name="ln5936">/// Parse text from 'di' and return the quickfix list items.</a>
<a name="ln5937">/// Existing quickfix lists are not modified.</a>
<a name="ln5938">static int qf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)</a>
<a name="ln5939">{</a>
<a name="ln5940">  int status = FAIL;</a>
<a name="ln5941"> </a>
<a name="ln5942">  // Only a List value is supported</a>
<a name="ln5943">  if (di-&gt;di_tv.v_type != VAR_LIST || di-&gt;di_tv.vval.v_list == NULL) {</a>
<a name="ln5944">    return FAIL;</a>
<a name="ln5945">  }</a>
<a name="ln5946"> </a>
<a name="ln5947">  char *errorformat = p_efm;</a>
<a name="ln5948">  dictitem_T *efm_di;</a>
<a name="ln5949">  // If errorformat is supplied then use it, otherwise use the 'efm'</a>
<a name="ln5950">  // option setting</a>
<a name="ln5951">  if ((efm_di = tv_dict_find(what, S_LEN(&quot;efm&quot;))) != NULL) {</a>
<a name="ln5952">    if (efm_di-&gt;di_tv.v_type != VAR_STRING</a>
<a name="ln5953">        || efm_di-&gt;di_tv.vval.v_string == NULL) {</a>
<a name="ln5954">      return FAIL;</a>
<a name="ln5955">    }</a>
<a name="ln5956">    errorformat = efm_di-&gt;di_tv.vval.v_string;</a>
<a name="ln5957">  }</a>
<a name="ln5958"> </a>
<a name="ln5959">  list_T *l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln5960">  qf_info_T *const qi = qf_alloc_stack(QFLT_INTERNAL);</a>
<a name="ln5961"> </a>
<a name="ln5962">  if (qf_init_ext(qi, 0, NULL, NULL, &amp;di-&gt;di_tv, errorformat,</a>
<a name="ln5963">                  true, 0, 0, NULL, NULL) &gt; 0) {</a>
<a name="ln5964">    (void)get_errorlist(qi, NULL, 0, 0, l);</a>
<a name="ln5965">    qf_free(&amp;qi-&gt;qf_lists[0]);</a>
<a name="ln5966">  }</a>
<a name="ln5967">  xfree(qi);</a>
<a name="ln5968"> </a>
<a name="ln5969">  tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), l);</a>
<a name="ln5970">  status = OK;</a>
<a name="ln5971"> </a>
<a name="ln5972">  return status;</a>
<a name="ln5973">}</a>
<a name="ln5974"> </a>
<a name="ln5975">/// Return the quickfix/location list window identifier in the current tabpage.</a>
<a name="ln5976">static int qf_winid(qf_info_T *qi)</a>
<a name="ln5977">{</a>
<a name="ln5978">  // The quickfix window can be opened even if the quickfix list is not set</a>
<a name="ln5979">  // using &quot;:copen&quot;. This is not true for location lists.</a>
<a name="ln5980">  if (qi == NULL) {</a>
<a name="ln5981">    return 0;</a>
<a name="ln5982">  }</a>
<a name="ln5983">  win_T *win = qf_find_win(qi);</a>
<a name="ln5984">  if (win != NULL) {</a>
<a name="ln5985">    return win-&gt;handle;</a>
<a name="ln5986">  }</a>
<a name="ln5987">  return 0;</a>
<a name="ln5988">}</a>
<a name="ln5989"> </a>
<a name="ln5990">/// Returns the number of the buffer displayed in the quickfix/location list</a>
<a name="ln5991">/// window. If there is no buffer associated with the list or the buffer is</a>
<a name="ln5992">/// wiped out, then returns 0.</a>
<a name="ln5993">static int qf_getprop_qfbufnr(const qf_info_T *qi, dict_T *retdict)</a>
<a name="ln5994">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln5995">{</a>
<a name="ln5996">  int bufnum = 0;</a>
<a name="ln5997"> </a>
<a name="ln5998">  if (qi != NULL &amp;&amp; buflist_findnr(qi-&gt;qf_bufnr) != NULL) {</a>
<a name="ln5999">    bufnum = qi-&gt;qf_bufnr;</a>
<a name="ln6000">  }</a>
<a name="ln6001"> </a>
<a name="ln6002">  return tv_dict_add_nr(retdict, S_LEN(&quot;qfbufnr&quot;), bufnum);</a>
<a name="ln6003">}</a>
<a name="ln6004"> </a>
<a name="ln6005">/// Convert the keys in 'what' to quickfix list property flags.</a>
<a name="ln6006">static int qf_getprop_keys2flags(const dict_T *what, bool loclist)</a>
<a name="ln6007">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6008">{</a>
<a name="ln6009">  int flags = QF_GETLIST_NONE;</a>
<a name="ln6010"> </a>
<a name="ln6011">  if (tv_dict_find(what, S_LEN(&quot;all&quot;)) != NULL) {</a>
<a name="ln6012">    flags |= QF_GETLIST_ALL;</a>
<a name="ln6013">    if (!loclist) {</a>
<a name="ln6014">      // File window ID is applicable only to location list windows</a>
<a name="ln6015">      flags &amp;= ~QF_GETLIST_FILEWINID;</a>
<a name="ln6016">    }</a>
<a name="ln6017">  }</a>
<a name="ln6018">  if (tv_dict_find(what, S_LEN(&quot;title&quot;)) != NULL) {</a>
<a name="ln6019">    flags |= QF_GETLIST_TITLE;</a>
<a name="ln6020">  }</a>
<a name="ln6021">  if (tv_dict_find(what, S_LEN(&quot;nr&quot;)) != NULL) {</a>
<a name="ln6022">    flags |= QF_GETLIST_NR;</a>
<a name="ln6023">  }</a>
<a name="ln6024">  if (tv_dict_find(what, S_LEN(&quot;winid&quot;)) != NULL) {</a>
<a name="ln6025">    flags |= QF_GETLIST_WINID;</a>
<a name="ln6026">  }</a>
<a name="ln6027">  if (tv_dict_find(what, S_LEN(&quot;context&quot;)) != NULL) {</a>
<a name="ln6028">    flags |= QF_GETLIST_CONTEXT;</a>
<a name="ln6029">  }</a>
<a name="ln6030">  if (tv_dict_find(what, S_LEN(&quot;id&quot;)) != NULL) {</a>
<a name="ln6031">    flags |= QF_GETLIST_ID;</a>
<a name="ln6032">  }</a>
<a name="ln6033">  if (tv_dict_find(what, S_LEN(&quot;items&quot;)) != NULL) {</a>
<a name="ln6034">    flags |= QF_GETLIST_ITEMS;</a>
<a name="ln6035">  }</a>
<a name="ln6036">  if (tv_dict_find(what, S_LEN(&quot;idx&quot;)) != NULL) {</a>
<a name="ln6037">    flags |= QF_GETLIST_IDX;</a>
<a name="ln6038">  }</a>
<a name="ln6039">  if (tv_dict_find(what, S_LEN(&quot;size&quot;)) != NULL) {</a>
<a name="ln6040">    flags |= QF_GETLIST_SIZE;</a>
<a name="ln6041">  }</a>
<a name="ln6042">  if (tv_dict_find(what, S_LEN(&quot;changedtick&quot;)) != NULL) {</a>
<a name="ln6043">    flags |= QF_GETLIST_TICK;</a>
<a name="ln6044">  }</a>
<a name="ln6045">  if (loclist &amp;&amp; tv_dict_find(what, S_LEN(&quot;filewinid&quot;)) != NULL) {</a>
<a name="ln6046">    flags |= QF_GETLIST_FILEWINID;</a>
<a name="ln6047">  }</a>
<a name="ln6048">  if (tv_dict_find(what, S_LEN(&quot;qfbufnr&quot;)) != NULL) {</a>
<a name="ln6049">    flags |= QF_GETLIST_QFBUFNR;</a>
<a name="ln6050">  }</a>
<a name="ln6051">  if (tv_dict_find(what, S_LEN(&quot;quickfixtextfunc&quot;)) != NULL) {</a>
<a name="ln6052">    flags |= QF_GETLIST_QFTF;</a>
<a name="ln6053">  }</a>
<a name="ln6054"> </a>
<a name="ln6055">  return flags;</a>
<a name="ln6056">}</a>
<a name="ln6057"> </a>
<a name="ln6058">/// Return the quickfix list index based on 'nr' or 'id' in 'what'.</a>
<a name="ln6059">///</a>
<a name="ln6060">/// If 'nr' and 'id' are not present in 'what' then return the current</a>
<a name="ln6061">/// quickfix list index.</a>
<a name="ln6062">/// If 'nr' is zero then return the current quickfix list index.</a>
<a name="ln6063">/// If 'nr' is '$' then return the last quickfix list index.</a>
<a name="ln6064">/// If 'id' is present then return the index of the quickfix list with that id.</a>
<a name="ln6065">/// If 'id' is zero then return the quickfix list index specified by 'nr'.</a>
<a name="ln6066">/// Return -1, if quickfix list is not present or if the stack is empty.</a>
<a name="ln6067">static int qf_getprop_qfidx(qf_info_T *qi, dict_T *what)</a>
<a name="ln6068">{</a>
<a name="ln6069">  dictitem_T *di = NULL;</a>
<a name="ln6070"> </a>
<a name="ln6071">  int qf_idx = qi-&gt;qf_curlist;  // default is the current list</a>
<a name="ln6072">  if ((di = tv_dict_find(what, S_LEN(&quot;nr&quot;))) != NULL) {</a>
<a name="ln6073">    // Use the specified quickfix/location list</a>
<a name="ln6074">    if (di-&gt;di_tv.v_type == VAR_NUMBER) {</a>
<a name="ln6075">      // for zero use the current list</a>
<a name="ln6076">      if (di-&gt;di_tv.vval.v_number != 0) {</a>
<a name="ln6077">        qf_idx = (int)di-&gt;di_tv.vval.v_number - 1;</a>
<a name="ln6078">        if (qf_idx &lt; 0 || qf_idx &gt;= qi-&gt;qf_listcount) {</a>
<a name="ln6079">          qf_idx = INVALID_QFIDX;</a>
<a name="ln6080">        }</a>
<a name="ln6081">      }</a>
<a name="ln6082">    } else if (di-&gt;di_tv.v_type == VAR_STRING &amp;&amp; strequal(di-&gt;di_tv.vval.v_string, &quot;$&quot;)) {</a>
<a name="ln6083">      // Get the last quickfix list number</a>
<a name="ln6084">      qf_idx = qi-&gt;qf_listcount - 1;</a>
<a name="ln6085">    } else {</a>
<a name="ln6086">      qf_idx = INVALID_QFIDX;</a>
<a name="ln6087">    }</a>
<a name="ln6088">  }</a>
<a name="ln6089"> </a>
<a name="ln6090">  if ((di = tv_dict_find(what, S_LEN(&quot;id&quot;))) != NULL) {</a>
<a name="ln6091">    // Look for a list with the specified id</a>
<a name="ln6092">    if (di-&gt;di_tv.v_type == VAR_NUMBER) {</a>
<a name="ln6093">      // For zero, use the current list or the list specified by 'nr'</a>
<a name="ln6094">      if (di-&gt;di_tv.vval.v_number != 0) {</a>
<a name="ln6095">        qf_idx = qf_id2nr(qi, (unsigned)di-&gt;di_tv.vval.v_number);</a>
<a name="ln6096">      }</a>
<a name="ln6097">    } else {</a>
<a name="ln6098">      qf_idx = INVALID_QFIDX;</a>
<a name="ln6099">    }</a>
<a name="ln6100">  }</a>
<a name="ln6101"> </a>
<a name="ln6102">  return qf_idx;</a>
<a name="ln6103">}</a>
<a name="ln6104"> </a>
<a name="ln6105">/// Return default values for quickfix list properties in retdict.</a>
<a name="ln6106">static int qf_getprop_defaults(qf_info_T *qi, int flags, int locstack, dict_T *retdict)</a>
<a name="ln6107">{</a>
<a name="ln6108">  int status = OK;</a>
<a name="ln6109"> </a>
<a name="ln6110">  if (flags &amp; QF_GETLIST_TITLE) {</a>
<a name="ln6111">    status = tv_dict_add_str(retdict, S_LEN(&quot;title&quot;), &quot;&quot;);</a>
<a name="ln6112">  }</a>
<a name="ln6113">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_ITEMS)) {</a>
<a name="ln6114">    list_T *l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln6115">    status = tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), l);</a>
<a name="ln6116">  }</a>
<a name="ln6117">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_NR)) {</a>
<a name="ln6118">    status = tv_dict_add_nr(retdict, S_LEN(&quot;nr&quot;), 0);</a>
<a name="ln6119">  }</a>
<a name="ln6120">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_WINID)) {</a>
<a name="ln6121">    status = tv_dict_add_nr(retdict, S_LEN(&quot;winid&quot;), qf_winid(qi));</a>
<a name="ln6122">  }</a>
<a name="ln6123">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_CONTEXT)) {</a>
<a name="ln6124">    status = tv_dict_add_str(retdict, S_LEN(&quot;context&quot;), &quot;&quot;);</a>
<a name="ln6125">  }</a>
<a name="ln6126">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_ID)) {</a>
<a name="ln6127">    status = tv_dict_add_nr(retdict, S_LEN(&quot;id&quot;), 0);</a>
<a name="ln6128">  }</a>
<a name="ln6129">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_IDX)) {</a>
<a name="ln6130">    status = tv_dict_add_nr(retdict, S_LEN(&quot;idx&quot;), 0);</a>
<a name="ln6131">  }</a>
<a name="ln6132">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_SIZE)) {</a>
<a name="ln6133">    status = tv_dict_add_nr(retdict, S_LEN(&quot;size&quot;), 0);</a>
<a name="ln6134">  }</a>
<a name="ln6135">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_TICK)) {</a>
<a name="ln6136">    status = tv_dict_add_nr(retdict, S_LEN(&quot;changedtick&quot;), 0);</a>
<a name="ln6137">  }</a>
<a name="ln6138">  if ((status == OK) &amp;&amp; locstack &amp;&amp; (flags &amp; QF_GETLIST_FILEWINID)) {</a>
<a name="ln6139">    status = tv_dict_add_nr(retdict, S_LEN(&quot;filewinid&quot;), 0);</a>
<a name="ln6140">  }</a>
<a name="ln6141">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_QFBUFNR)) {</a>
<a name="ln6142">    status = qf_getprop_qfbufnr(qi, retdict);</a>
<a name="ln6143">  }</a>
<a name="ln6144">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_QFTF)) {</a>
<a name="ln6145">    status = tv_dict_add_str(retdict, S_LEN(&quot;quickfixtextfunc&quot;), &quot;&quot;);</a>
<a name="ln6146">  }</a>
<a name="ln6147"> </a>
<a name="ln6148">  return status;</a>
<a name="ln6149">}</a>
<a name="ln6150"> </a>
<a name="ln6151">/// Return the quickfix list title as 'title' in retdict</a>
<a name="ln6152">static int qf_getprop_title(qf_list_T *qfl, dict_T *retdict)</a>
<a name="ln6153">{</a>
<a name="ln6154">  return tv_dict_add_str(retdict, S_LEN(&quot;title&quot;), qfl-&gt;qf_title);</a>
<a name="ln6155">}</a>
<a name="ln6156"> </a>
<a name="ln6157">// Returns the identifier of the window used to display files from a location</a>
<a name="ln6158">// list.  If there is no associated window, then returns 0. Useful only when</a>
<a name="ln6159">// called from a location list window.</a>
<a name="ln6160">static int qf_getprop_filewinid(const win_T *wp, const qf_info_T *qi, dict_T *retdict)</a>
<a name="ln6161">  FUNC_ATTR_NONNULL_ARG(3)</a>
<a name="ln6162">{</a>
<a name="ln6163">  handle_T winid = 0;</a>
<a name="ln6164"> </a>
<a name="ln6165">  if (wp != NULL &amp;&amp; IS_LL_WINDOW(wp)) {</a>
<a name="ln6166">    win_T *ll_wp = qf_find_win_with_loclist(qi);</a>
<a name="ln6167">    if (ll_wp != NULL) {</a>
<a name="ln6168">      winid = ll_wp-&gt;handle;</a>
<a name="ln6169">    }</a>
<a name="ln6170">  }</a>
<a name="ln6171"> </a>
<a name="ln6172">  return tv_dict_add_nr(retdict, S_LEN(&quot;filewinid&quot;), winid);</a>
<a name="ln6173">}</a>
<a name="ln6174"> </a>
<a name="ln6175">/// Return the quickfix list items/entries as 'items' in retdict.</a>
<a name="ln6176">/// If eidx is not 0, then return the item at the specified index.</a>
<a name="ln6177">static int qf_getprop_items(qf_info_T *qi, int qf_idx, int eidx, dict_T *retdict)</a>
<a name="ln6178">{</a>
<a name="ln6179">  list_T *l = tv_list_alloc(kListLenMayKnow);</a>
<a name="ln6180">  get_errorlist(qi, NULL, qf_idx, eidx, l);</a>
<a name="ln6181">  tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), l);</a>
<a name="ln6182"> </a>
<a name="ln6183">  return OK;</a>
<a name="ln6184">}</a>
<a name="ln6185"> </a>
<a name="ln6186">/// Return the quickfix list context (if any) as 'context' in retdict.</a>
<a name="ln6187">static int qf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)</a>
<a name="ln6188">{</a>
<a name="ln6189">  int status;</a>
<a name="ln6190"> </a>
<a name="ln6191">  if (qfl-&gt;qf_ctx != NULL) {</a>
<a name="ln6192">    dictitem_T *di = tv_dict_item_alloc_len(S_LEN(&quot;context&quot;));</a>
<a name="ln6193">    tv_copy(qfl-&gt;qf_ctx, &amp;di-&gt;di_tv);</a>
<a name="ln6194">    status = tv_dict_add(retdict, di);</a>
<a name="ln6195">    if (status == FAIL) {</a>
<a name="ln6196">      tv_dict_item_free(di);</a>
<a name="ln6197">    }</a>
<a name="ln6198">  } else {</a>
<a name="ln6199">    status = tv_dict_add_str(retdict, S_LEN(&quot;context&quot;), &quot;&quot;);</a>
<a name="ln6200">  }</a>
<a name="ln6201"> </a>
<a name="ln6202">  return status;</a>
<a name="ln6203">}</a>
<a name="ln6204"> </a>
<a name="ln6205">/// Return the current quickfix list index as 'idx' in retdict.</a>
<a name="ln6206">/// If a specific entry index (eidx) is supplied, then use that.</a>
<a name="ln6207">static int qf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)</a>
<a name="ln6208">{</a>
<a name="ln6209">  if (eidx == 0) {</a>
<a name="ln6210">    eidx = qfl-&gt;qf_index;</a>
<a name="ln6211">    if (qf_list_empty(qfl)) {</a>
<a name="ln6212">      // For empty lists, current index is set to 0</a>
<a name="ln6213">      eidx = 0;</a>
<a name="ln6214">    }</a>
<a name="ln6215">  }</a>
<a name="ln6216">  return tv_dict_add_nr(retdict, S_LEN(&quot;idx&quot;), eidx);</a>
<a name="ln6217">}</a>
<a name="ln6218"> </a>
<a name="ln6219">/// Return the 'quickfixtextfunc' function of a quickfix/location list</a>
<a name="ln6220">/// @return OK or FAIL</a>
<a name="ln6221">static int qf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)</a>
<a name="ln6222">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6223">{</a>
<a name="ln6224">  int status;</a>
<a name="ln6225"> </a>
<a name="ln6226">  if (qfl-&gt;qf_qftf_cb.type != kCallbackNone) {</a>
<a name="ln6227">    typval_T tv;</a>
<a name="ln6228"> </a>
<a name="ln6229">    callback_put(&amp;qfl-&gt;qf_qftf_cb, &amp;tv);</a>
<a name="ln6230">    status = tv_dict_add_tv(retdict, S_LEN(&quot;quickfixtextfunc&quot;), &amp;tv);</a>
<a name="ln6231">    tv_clear(&amp;tv);</a>
<a name="ln6232">  } else {</a>
<a name="ln6233">    status = tv_dict_add_str(retdict, S_LEN(&quot;quickfixtextfunc&quot;), &quot;&quot;);</a>
<a name="ln6234">  }</a>
<a name="ln6235"> </a>
<a name="ln6236">  return status;</a>
<a name="ln6237">}</a>
<a name="ln6238"> </a>
<a name="ln6239">/// Return quickfix/location list details (title) as a dictionary.</a>
<a name="ln6240">/// 'what' contains the details to return. If 'list_idx' is -1,</a>
<a name="ln6241">/// then current list is used. Otherwise the specified list is used.</a>
<a name="ln6242">static int qf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)</a>
<a name="ln6243">{</a>
<a name="ln6244">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln6245">  dictitem_T *di = NULL;</a>
<a name="ln6246">  int status = OK;</a>
<a name="ln6247">  int qf_idx = INVALID_QFIDX;</a>
<a name="ln6248"> </a>
<a name="ln6249">  if ((di = tv_dict_find(what, S_LEN(&quot;lines&quot;))) != NULL) {</a>
<a name="ln6250">    return qf_get_list_from_lines(what, di, retdict);</a>
<a name="ln6251">  }</a>
<a name="ln6252"> </a>
<a name="ln6253">  if (wp != NULL) {</a>
<a name="ln6254">    qi = GET_LOC_LIST(wp);</a>
<a name="ln6255">  }</a>
<a name="ln6256"> </a>
<a name="ln6257">  const int flags = qf_getprop_keys2flags(what, wp != NULL);</a>
<a name="ln6258"> </a>
<a name="ln6259">  if (!qf_stack_empty(qi)) {</a>
<a name="ln6260">    qf_idx = qf_getprop_qfidx(qi, what);</a>
<a name="ln6261">  }</a>
<a name="ln6262"> </a>
<a name="ln6263">  // List is not present or is empty</a>
<a name="ln6264">  if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX) {</a>
<a name="ln6265">    return qf_getprop_defaults(qi, flags, wp != NULL, retdict);</a>
<a name="ln6266">  }</a>
<a name="ln6267"> </a>
<a name="ln6268">  qf_list_T *qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln6269">  int eidx = 0;</a>
<a name="ln6270"> </a>
<a name="ln6271">  // If an entry index is specified, use that</a>
<a name="ln6272">  if ((di = tv_dict_find(what, S_LEN(&quot;idx&quot;))) != NULL) {</a>
<a name="ln6273">    if (di-&gt;di_tv.v_type != VAR_NUMBER) {</a>
<a name="ln6274">      return FAIL;</a>
<a name="ln6275">    }</a>
<a name="ln6276">    eidx = (int)di-&gt;di_tv.vval.v_number;</a>
<a name="ln6277">  }</a>
<a name="ln6278"> </a>
<a name="ln6279">  if (flags &amp; QF_GETLIST_TITLE) {</a>
<a name="ln6280">    status = qf_getprop_title(qfl, retdict);</a>
<a name="ln6281">  }</a>
<a name="ln6282">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_NR)) {</a>
<a name="ln6283">    status = tv_dict_add_nr(retdict, S_LEN(&quot;nr&quot;), qf_idx + 1);</a>
<a name="ln6284">  }</a>
<a name="ln6285">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_WINID)) {</a>
<a name="ln6286">    status = tv_dict_add_nr(retdict, S_LEN(&quot;winid&quot;), qf_winid(qi));</a>
<a name="ln6287">  }</a>
<a name="ln6288">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_ITEMS)) {</a>
<a name="ln6289">    status = qf_getprop_items(qi, qf_idx, eidx, retdict);</a>
<a name="ln6290">  }</a>
<a name="ln6291">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_CONTEXT)) {</a>
<a name="ln6292">    status = qf_getprop_ctx(qfl, retdict);</a>
<a name="ln6293">  }</a>
<a name="ln6294">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_ID)) {</a>
<a name="ln6295">    status = tv_dict_add_nr(retdict, S_LEN(&quot;id&quot;), qfl-&gt;qf_id);</a>
<a name="ln6296">  }</a>
<a name="ln6297">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_IDX)) {</a>
<a name="ln6298">    status = qf_getprop_idx(qfl, eidx, retdict);</a>
<a name="ln6299">  }</a>
<a name="ln6300">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_SIZE)) {</a>
<a name="ln6301">    status = tv_dict_add_nr(retdict, S_LEN(&quot;size&quot;),</a>
<a name="ln6302">                            qfl-&gt;qf_count);</a>
<a name="ln6303">  }</a>
<a name="ln6304">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_TICK)) {</a>
<a name="ln6305">    status = tv_dict_add_nr(retdict, S_LEN(&quot;changedtick&quot;),</a>
<a name="ln6306">                            qfl-&gt;qf_changedtick);</a>
<a name="ln6307">  }</a>
<a name="ln6308">  if ((status == OK) &amp;&amp; (wp != NULL) &amp;&amp; (flags &amp; QF_GETLIST_FILEWINID)) {</a>
<a name="ln6309">    status = qf_getprop_filewinid(wp, qi, retdict);</a>
<a name="ln6310">  }</a>
<a name="ln6311">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_QFBUFNR)) {</a>
<a name="ln6312">    status = qf_getprop_qfbufnr(qi, retdict);</a>
<a name="ln6313">  }</a>
<a name="ln6314">  if ((status == OK) &amp;&amp; (flags &amp; QF_GETLIST_QFTF)) {</a>
<a name="ln6315">    status = qf_getprop_qftf(qfl, retdict);</a>
<a name="ln6316">  }</a>
<a name="ln6317"> </a>
<a name="ln6318">  return status;</a>
<a name="ln6319">}</a>
<a name="ln6320"> </a>
<a name="ln6321">/// Set the current index in the specified quickfix list</a>
<a name="ln6322">/// @return OK</a>
<a name="ln6323">static int qf_setprop_qftf(qf_list_T *qfl, dictitem_T *di)</a>
<a name="ln6324">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6325">{</a>
<a name="ln6326">  Callback cb;</a>
<a name="ln6327"> </a>
<a name="ln6328">  callback_free(&amp;qfl-&gt;qf_qftf_cb);</a>
<a name="ln6329">  if (callback_from_typval(&amp;cb, &amp;di-&gt;di_tv)) {</a>
<a name="ln6330">    qfl-&gt;qf_qftf_cb = cb;</a>
<a name="ln6331">  }</a>
<a name="ln6332">  return OK;</a>
<a name="ln6333">}</a>
<a name="ln6334"> </a>
<a name="ln6335">/// Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the</a>
<a name="ln6336">/// items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'</a>
<a name="ln6337">/// to true.</a>
<a name="ln6338">static int qf_add_entry_from_dict(qf_list_T *qfl, dict_T *d, bool first_entry, bool *valid_entry)</a>
<a name="ln6339">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6340">{</a>
<a name="ln6341">  static bool did_bufnr_emsg;</a>
<a name="ln6342"> </a>
<a name="ln6343">  if (first_entry) {</a>
<a name="ln6344">    did_bufnr_emsg = false;</a>
<a name="ln6345">  }</a>
<a name="ln6346"> </a>
<a name="ln6347">  char *const filename = tv_dict_get_string(d, &quot;filename&quot;, true);</a>
<a name="ln6348">  char *const module = tv_dict_get_string(d, &quot;module&quot;, true);</a>
<a name="ln6349">  int bufnum = (int)tv_dict_get_number(d, &quot;bufnr&quot;);</a>
<a name="ln6350">  const linenr_T lnum = (linenr_T)tv_dict_get_number(d, &quot;lnum&quot;);</a>
<a name="ln6351">  const linenr_T end_lnum = (linenr_T)tv_dict_get_number(d, &quot;end_lnum&quot;);</a>
<a name="ln6352">  const int col = (int)tv_dict_get_number(d, &quot;col&quot;);</a>
<a name="ln6353">  const int end_col = (int)tv_dict_get_number(d, &quot;end_col&quot;);</a>
<a name="ln6354">  const char vcol = (char)tv_dict_get_number(d, &quot;vcol&quot;);</a>
<a name="ln6355">  const int nr = (int)tv_dict_get_number(d, &quot;nr&quot;);</a>
<a name="ln6356">  const char *const type = tv_dict_get_string(d, &quot;type&quot;, false);</a>
<a name="ln6357">  char *const pattern = tv_dict_get_string(d, &quot;pattern&quot;, true);</a>
<a name="ln6358">  char *text = tv_dict_get_string(d, &quot;text&quot;, true);</a>
<a name="ln6359">  if (text == NULL) {</a>
<a name="ln6360">    text = xcalloc(1, 1);</a>
<a name="ln6361">  }</a>
<a name="ln6362">  typval_T user_data = { .v_type = VAR_UNKNOWN };</a>
<a name="ln6363">  tv_dict_get_tv(d, &quot;user_data&quot;, &amp;user_data);</a>
<a name="ln6364"> </a>
<a name="ln6365">  bool valid = true;</a>
<a name="ln6366">  if ((filename == NULL &amp;&amp; bufnum == 0)</a>
<a name="ln6367">      || (lnum == 0 &amp;&amp; pattern == NULL)) {</a>
<a name="ln6368">    valid = false;</a>
<a name="ln6369">  }</a>
<a name="ln6370"> </a>
<a name="ln6371">  // Mark entries with non-existing buffer number as not valid. Give the</a>
<a name="ln6372">  // error message only once.</a>
<a name="ln6373">  if (bufnum != 0 &amp;&amp; (buflist_findnr(bufnum) == NULL)) {</a>
<a name="ln6374">    if (!did_bufnr_emsg) {</a>
<a name="ln6375">      did_bufnr_emsg = true;</a>
<a name="ln6376">      semsg(_(&quot;E92: Buffer %&quot; PRId64 &quot; not found&quot;), (int64_t)bufnum);</a>
<a name="ln6377">    }</a>
<a name="ln6378">    valid = false;</a>
<a name="ln6379">    bufnum = 0;</a>
<a name="ln6380">  }</a>
<a name="ln6381"> </a>
<a name="ln6382">  // If the 'valid' field is present it overrules the detected value.</a>
<a name="ln6383">  if (tv_dict_find(d, &quot;valid&quot;, -1) != NULL) {</a>
<a name="ln6384">    valid = tv_dict_get_number(d, &quot;valid&quot;);</a>
<a name="ln6385">  }</a>
<a name="ln6386"> </a>
<a name="ln6387">  const int status = qf_add_entry(qfl,</a>
<a name="ln6388">                                  NULL,      // dir</a>
<a name="ln6389">                                  filename,</a>
<a name="ln6390">                                  module,</a>
<a name="ln6391">                                  bufnum,</a>
<a name="ln6392">                                  text,</a>
<a name="ln6393">                                  lnum,</a>
<a name="ln6394">                                  end_lnum,</a>
<a name="ln6395">                                  col,</a>
<a name="ln6396">                                  end_col,</a>
<a name="ln6397">                                  vcol,      // vis_col</a>
<a name="ln6398">                                  pattern,   // search pattern</a>
<a name="ln6399">                                  nr,</a>
<a name="ln6400">                                  type == NULL ? NUL : *type,</a>
<a name="ln6401">                                  &amp;user_data,</a>
<a name="ln6402">                                  valid);</a>
<a name="ln6403"> </a>
<a name="ln6404">  xfree(filename);</a>
<a name="ln6405">  xfree(module);</a>
<a name="ln6406">  xfree(pattern);</a>
<a name="ln6407">  xfree(text);</a>
<a name="ln6408">  tv_clear(&amp;user_data);</a>
<a name="ln6409"> </a>
<a name="ln6410">  if (valid) {</a>
<a name="ln6411">    *valid_entry = true;</a>
<a name="ln6412">  }</a>
<a name="ln6413"> </a>
<a name="ln6414">  return status;</a>
<a name="ln6415">}</a>
<a name="ln6416"> </a>
<a name="ln6417">/// Add list of entries to quickfix/location list. Each list entry is</a>
<a name="ln6418">/// a dictionary with item information.</a>
<a name="ln6419">static int qf_add_entries(qf_info_T *qi, int qf_idx, list_T *list, char *title, int action)</a>
<a name="ln6420">{</a>
<a name="ln6421">  qf_list_T *qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln6422">  qfline_T *old_last = NULL;</a>
<a name="ln6423">  int retval = OK;</a>
<a name="ln6424">  bool valid_entry = false;</a>
<a name="ln6425"> </a>
<a name="ln6426">  if (action == ' ' || qf_idx == qi-&gt;qf_listcount) {</a>
<a name="ln6427">    // make place for a new list</a>
<a name="ln6428">    qf_new_list(qi, title);</a>
<a name="ln6429">    qf_idx = qi-&gt;qf_curlist;</a>
<a name="ln6430">    qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln6431">  } else if (action == 'a' &amp;&amp; !qf_list_empty(qfl)) {</a>
<a name="ln6432">    // Adding to existing list, use last entry.</a>
<a name="ln6433">    old_last = qfl-&gt;qf_last;</a>
<a name="ln6434">  } else if (action == 'r') {</a>
<a name="ln6435">    qf_free_items(qfl);</a>
<a name="ln6436">    qf_store_title(qfl, title);</a>
<a name="ln6437">  }</a>
<a name="ln6438"> </a>
<a name="ln6439">  TV_LIST_ITER_CONST(list, li, {</a>
<a name="ln6440">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_DICT) {</a>
<a name="ln6441">      continue;  // Skip non-dict items.</a>
<a name="ln6442">    }</a>
<a name="ln6443"> </a>
<a name="ln6444">    dict_T *const d = TV_LIST_ITEM_TV(li)-&gt;vval.v_dict;</a>
<a name="ln6445">    if (d == NULL) {</a>
<a name="ln6446">      continue;</a>
<a name="ln6447">    }</a>
<a name="ln6448"> </a>
<a name="ln6449">    retval = qf_add_entry_from_dict(qfl, d, li == tv_list_first(list), &amp;valid_entry);</a>
<a name="ln6450">    if (retval == QF_FAIL) {</a>
<a name="ln6451">      break;</a>
<a name="ln6452">    }</a>
<a name="ln6453">  });</a>
<a name="ln6454"> </a>
<a name="ln6455">  // Check if any valid error entries are added to the list.</a>
<a name="ln6456">  if (valid_entry) {</a>
<a name="ln6457">    qfl-&gt;qf_nonevalid = false;</a>
<a name="ln6458">  } else if (qfl-&gt;qf_index == 0) {</a>
<a name="ln6459">    qfl-&gt;qf_nonevalid = true;</a>
<a name="ln6460">  }</a>
<a name="ln6461"> </a>
<a name="ln6462">  // If not appending to the list, set the current error to the first entry</a>
<a name="ln6463">  if (action != 'a') {</a>
<a name="ln6464">    qfl-&gt;qf_ptr = qfl-&gt;qf_start;</a>
<a name="ln6465">  }</a>
<a name="ln6466"> </a>
<a name="ln6467">  // Update the current error index if not appending to the list or if the</a>
<a name="ln6468">  // list was empty before and it is not empty now.</a>
<a name="ln6469">  if ((action != 'a' || qfl-&gt;qf_index == 0)</a>
<a name="ln6470">      &amp;&amp; !qf_list_empty(qfl)) {</a>
<a name="ln6471">    qfl-&gt;qf_index = 1;</a>
<a name="ln6472">  }</a>
<a name="ln6473"> </a>
<a name="ln6474">  // Don't update the cursor in quickfix window when appending entries</a>
<a name="ln6475">  qf_update_buffer(qi, old_last);</a>
<a name="ln6476"> </a>
<a name="ln6477">  return retval;</a>
<a name="ln6478">}</a>
<a name="ln6479"> </a>
<a name="ln6480">/// Get the quickfix list index from 'nr' or 'id'</a>
<a name="ln6481">static int qf_setprop_get_qfidx(const qf_info_T *qi, const dict_T *what, int action, bool *newlist)</a>
<a name="ln6482">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6483">{</a>
<a name="ln6484">  dictitem_T *di;</a>
<a name="ln6485">  int qf_idx = qi-&gt;qf_curlist;  // default is the current list</a>
<a name="ln6486"> </a>
<a name="ln6487">  if ((di = tv_dict_find(what, S_LEN(&quot;nr&quot;))) != NULL) {</a>
<a name="ln6488">    // Use the specified quickfix/location list</a>
<a name="ln6489">    if (di-&gt;di_tv.v_type == VAR_NUMBER) {</a>
<a name="ln6490">      // for zero use the current list</a>
<a name="ln6491">      if (di-&gt;di_tv.vval.v_number != 0) {</a>
<a name="ln6492">        qf_idx = (int)di-&gt;di_tv.vval.v_number - 1;</a>
<a name="ln6493">      }</a>
<a name="ln6494"> </a>
<a name="ln6495">      if ((action == ' ' || action == 'a') &amp;&amp; qf_idx == qi-&gt;qf_listcount) {</a>
<a name="ln6496">        // When creating a new list, accept qf_idx pointing to the next</a>
<a name="ln6497">        // non-available list and add the new list at the end of the</a>
<a name="ln6498">        // stack.</a>
<a name="ln6499">        *newlist = true;</a>
<a name="ln6500">        qf_idx = qf_stack_empty(qi) ? 0 : qi-&gt;qf_listcount - 1;</a>
<a name="ln6501">      } else if (qf_idx &lt; 0 || qf_idx &gt;= qi-&gt;qf_listcount) {</a>
<a name="ln6502">        return INVALID_QFIDX;</a>
<a name="ln6503">      } else if (action != ' ') {</a>
<a name="ln6504">        *newlist = false;  // use the specified list</a>
<a name="ln6505">      }</a>
<a name="ln6506">    } else if (di-&gt;di_tv.v_type == VAR_STRING &amp;&amp; strequal(di-&gt;di_tv.vval.v_string, &quot;$&quot;)) {</a>
<a name="ln6507">      if (!qf_stack_empty(qi)) {</a>
<a name="ln6508">        qf_idx = qi-&gt;qf_listcount - 1;</a>
<a name="ln6509">      } else if (*newlist) {</a>
<a name="ln6510">        qf_idx = 0;</a>
<a name="ln6511">      } else {</a>
<a name="ln6512">        return INVALID_QFIDX;</a>
<a name="ln6513">      }</a>
<a name="ln6514">    } else {</a>
<a name="ln6515">      return INVALID_QFIDX;</a>
<a name="ln6516">    }</a>
<a name="ln6517">  }</a>
<a name="ln6518"> </a>
<a name="ln6519">  if (!*newlist &amp;&amp; (di = tv_dict_find(what, S_LEN(&quot;id&quot;))) != NULL) {</a>
<a name="ln6520">    // Use the quickfix/location list with the specified id</a>
<a name="ln6521">    if (di-&gt;di_tv.v_type != VAR_NUMBER) {</a>
<a name="ln6522">      return INVALID_QFIDX;</a>
<a name="ln6523">    }</a>
<a name="ln6524">    return qf_id2nr(qi, (unsigned)di-&gt;di_tv.vval.v_number);</a>
<a name="ln6525">  }</a>
<a name="ln6526"> </a>
<a name="ln6527">  return qf_idx;</a>
<a name="ln6528">}</a>
<a name="ln6529"> </a>
<a name="ln6530">// Set the quickfix list title.</a>
<a name="ln6531">static int qf_setprop_title(qf_info_T *qi, int qf_idx, const dict_T *what, const dictitem_T *di)</a>
<a name="ln6532">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6533">{</a>
<a name="ln6534">  qf_list_T *qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln6535">  if (di-&gt;di_tv.v_type != VAR_STRING) {</a>
<a name="ln6536">    return FAIL;</a>
<a name="ln6537">  }</a>
<a name="ln6538"> </a>
<a name="ln6539">  xfree(qfl-&gt;qf_title);</a>
<a name="ln6540">  qfl-&gt;qf_title = tv_dict_get_string(what, &quot;title&quot;, true);</a>
<a name="ln6541">  if (qf_idx == qi-&gt;qf_curlist) {</a>
<a name="ln6542">    qf_update_win_titlevar(qi);</a>
<a name="ln6543">  }</a>
<a name="ln6544"> </a>
<a name="ln6545">  return OK;</a>
<a name="ln6546">}</a>
<a name="ln6547"> </a>
<a name="ln6548">// Set quickfix list items/entries.</a>
<a name="ln6549">static int qf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di, int action)</a>
<a name="ln6550">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6551">{</a>
<a name="ln6552">  if (di-&gt;di_tv.v_type != VAR_LIST) {</a>
<a name="ln6553">    return FAIL;</a>
<a name="ln6554">  }</a>
<a name="ln6555"> </a>
<a name="ln6556">  char *title_save = xstrdup(qi-&gt;qf_lists[qf_idx].qf_title);</a>
<a name="ln6557">  const int retval = qf_add_entries(qi, qf_idx, di-&gt;di_tv.vval.v_list, title_save,</a>
<a name="ln6558">                                    action == ' ' ? 'a' : action);</a>
<a name="ln6559">  xfree(title_save);</a>
<a name="ln6560"> </a>
<a name="ln6561">  return retval;</a>
<a name="ln6562">}</a>
<a name="ln6563"> </a>
<a name="ln6564">// Set quickfix list items/entries from a list of lines.</a>
<a name="ln6565">static int qf_setprop_items_from_lines(qf_info_T *qi, int qf_idx, const dict_T *what,</a>
<a name="ln6566">                                       dictitem_T *di, int action)</a>
<a name="ln6567">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6568">{</a>
<a name="ln6569">  char *errorformat = p_efm;</a>
<a name="ln6570">  dictitem_T *efm_di;</a>
<a name="ln6571">  int retval = FAIL;</a>
<a name="ln6572"> </a>
<a name="ln6573">  // Use the user supplied errorformat settings (if present)</a>
<a name="ln6574">  if ((efm_di = tv_dict_find(what, S_LEN(&quot;efm&quot;))) != NULL) {</a>
<a name="ln6575">    if (efm_di-&gt;di_tv.v_type != VAR_STRING</a>
<a name="ln6576">        || efm_di-&gt;di_tv.vval.v_string == NULL) {</a>
<a name="ln6577">      return FAIL;</a>
<a name="ln6578">    }</a>
<a name="ln6579">    errorformat = efm_di-&gt;di_tv.vval.v_string;</a>
<a name="ln6580">  }</a>
<a name="ln6581"> </a>
<a name="ln6582">  // Only a List value is supported</a>
<a name="ln6583">  if (di-&gt;di_tv.v_type != VAR_LIST || di-&gt;di_tv.vval.v_list == NULL) {</a>
<a name="ln6584">    return FAIL;</a>
<a name="ln6585">  }</a>
<a name="ln6586"> </a>
<a name="ln6587">  if (action == 'r') {</a>
<a name="ln6588">    qf_free_items(&amp;qi-&gt;qf_lists[qf_idx]);</a>
<a name="ln6589">  }</a>
<a name="ln6590">  if (qf_init_ext(qi, qf_idx, NULL, NULL, &amp;di-&gt;di_tv, errorformat,</a>
<a name="ln6591">                  false, 0, 0, NULL, NULL) &gt;= 0) {</a>
<a name="ln6592">    retval = OK;</a>
<a name="ln6593">  }</a>
<a name="ln6594"> </a>
<a name="ln6595">  return retval;</a>
<a name="ln6596">}</a>
<a name="ln6597"> </a>
<a name="ln6598">// Set quickfix list context.</a>
<a name="ln6599">static int qf_setprop_context(qf_list_T *qfl, dictitem_T *di)</a>
<a name="ln6600">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6601">{</a>
<a name="ln6602">  tv_free(qfl-&gt;qf_ctx);</a>
<a name="ln6603">  typval_T *ctx = xcalloc(1, sizeof(typval_T));</a>
<a name="ln6604">  tv_copy(&amp;di-&gt;di_tv, ctx);</a>
<a name="ln6605">  qfl-&gt;qf_ctx = ctx;</a>
<a name="ln6606"> </a>
<a name="ln6607">  return OK;</a>
<a name="ln6608">}</a>
<a name="ln6609"> </a>
<a name="ln6610">// Set the current index in the specified quickfix list</a>
<a name="ln6611">static int qf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl, const dictitem_T *di)</a>
<a name="ln6612">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6613">{</a>
<a name="ln6614">  int newidx;</a>
<a name="ln6615"> </a>
<a name="ln6616">  // If the specified index is '$', then use the last entry</a>
<a name="ln6617">  if (di-&gt;di_tv.v_type == VAR_STRING</a>
<a name="ln6618">      &amp;&amp; di-&gt;di_tv.vval.v_string != NULL</a>
<a name="ln6619">      &amp;&amp; strcmp(di-&gt;di_tv.vval.v_string, &quot;$&quot;) == 0) {</a>
<a name="ln6620">    newidx = qfl-&gt;qf_count;</a>
<a name="ln6621">  } else {</a>
<a name="ln6622">    // Otherwise use the specified index</a>
<a name="ln6623">    bool denote = false;</a>
<a name="ln6624">    newidx = (int)tv_get_number_chk(&amp;di-&gt;di_tv, &amp;denote);</a>
<a name="ln6625">    if (denote) {</a>
<a name="ln6626">      return FAIL;</a>
<a name="ln6627">    }</a>
<a name="ln6628">  }</a>
<a name="ln6629"> </a>
<a name="ln6630">  if (newidx &lt; 1) {  // sanity check</a>
<a name="ln6631">    return FAIL;</a>
<a name="ln6632">  }</a>
<a name="ln6633">  if (newidx &gt; qfl-&gt;qf_count) {</a>
<a name="ln6634">    newidx = qfl-&gt;qf_count;</a>
<a name="ln6635">  }</a>
<a name="ln6636">  const int old_qfidx = qfl-&gt;qf_index;</a>
<a name="ln6637">  qfline_T *const qf_ptr = get_nth_entry(qfl, newidx, &amp;newidx);</a>
<a name="ln6638">  if (qf_ptr == NULL) {</a>
<a name="ln6639">    return FAIL;</a>
<a name="ln6640">  }</a>
<a name="ln6641">  qfl-&gt;qf_ptr = qf_ptr;</a>
<a name="ln6642">  qfl-&gt;qf_index = newidx;</a>
<a name="ln6643"> </a>
<a name="ln6644">  // If the current list is modified and it is displayed in the quickfix</a>
<a name="ln6645">  // window, then Update it.</a>
<a name="ln6646">  if (qi-&gt;qf_lists[qi-&gt;qf_curlist].qf_id == qfl-&gt;qf_id) {</a>
<a name="ln6647">    qf_win_pos_update(qi, old_qfidx);</a>
<a name="ln6648">  }</a>
<a name="ln6649">  return OK;</a>
<a name="ln6650">}</a>
<a name="ln6651"> </a>
<a name="ln6652">/// Set quickfix/location list properties (title, items, context).</a>
<a name="ln6653">/// Also used to add items from parsing a list of lines.</a>
<a name="ln6654">/// Used by the setqflist() and setloclist() Vim script functions.</a>
<a name="ln6655">static int qf_set_properties(qf_info_T *qi, const dict_T *what, int action, char *title)</a>
<a name="ln6656">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6657">{</a>
<a name="ln6658">  bool newlist = action == ' ' || qf_stack_empty(qi);</a>
<a name="ln6659">  int qf_idx = qf_setprop_get_qfidx(qi, what, action, &amp;newlist);</a>
<a name="ln6660">  if (qf_idx == INVALID_QFIDX) {  // List not found</a>
<a name="ln6661">    return FAIL;</a>
<a name="ln6662">  }</a>
<a name="ln6663"> </a>
<a name="ln6664">  if (newlist) {</a>
<a name="ln6665">    qi-&gt;qf_curlist = qf_idx;</a>
<a name="ln6666">    qf_new_list(qi, title);</a>
<a name="ln6667">    qf_idx = qi-&gt;qf_curlist;</a>
<a name="ln6668">  }</a>
<a name="ln6669"> </a>
<a name="ln6670">  qf_list_T *qfl = qf_get_list(qi, qf_idx);</a>
<a name="ln6671">  dictitem_T *di;</a>
<a name="ln6672">  int retval = FAIL;</a>
<a name="ln6673">  if ((di = tv_dict_find(what, S_LEN(&quot;title&quot;))) != NULL) {</a>
<a name="ln6674">    retval = qf_setprop_title(qi, qf_idx, what, di);</a>
<a name="ln6675">  }</a>
<a name="ln6676">  if ((di = tv_dict_find(what, S_LEN(&quot;items&quot;))) != NULL) {</a>
<a name="ln6677">    retval = qf_setprop_items(qi, qf_idx, di, action);</a>
<a name="ln6678">  }</a>
<a name="ln6679">  if ((di = tv_dict_find(what, S_LEN(&quot;lines&quot;))) != NULL) {</a>
<a name="ln6680">    retval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);</a>
<a name="ln6681">  }</a>
<a name="ln6682">  if ((di = tv_dict_find(what, S_LEN(&quot;context&quot;))) != NULL) {</a>
<a name="ln6683">    retval = qf_setprop_context(qfl, di);</a>
<a name="ln6684">  }</a>
<a name="ln6685">  if ((di = tv_dict_find(what, S_LEN(&quot;idx&quot;))) != NULL) {</a>
<a name="ln6686">    retval = qf_setprop_curidx(qi, qfl, di);</a>
<a name="ln6687">  }</a>
<a name="ln6688">  if ((di = tv_dict_find(what, S_LEN(&quot;quickfixtextfunc&quot;))) != NULL) {</a>
<a name="ln6689">    retval = qf_setprop_qftf(qfl, di);</a>
<a name="ln6690">  }</a>
<a name="ln6691"> </a>
<a name="ln6692">  if (newlist || retval == OK) {</a>
<a name="ln6693">    qf_list_changed(qfl);</a>
<a name="ln6694">  }</a>
<a name="ln6695">  if (newlist) {</a>
<a name="ln6696">    qf_update_buffer(qi, NULL);</a>
<a name="ln6697">  }</a>
<a name="ln6698"> </a>
<a name="ln6699">  return retval;</a>
<a name="ln6700">}</a>
<a name="ln6701"> </a>
<a name="ln6702">// Free the entire quickfix/location list stack.</a>
<a name="ln6703">// If the quickfix/location list window is open, then clear it.</a>
<a name="ln6704">static void qf_free_stack(win_T *wp, qf_info_T *qi)</a>
<a name="ln6705">{</a>
<a name="ln6706">  win_T *qfwin = qf_find_win(qi);</a>
<a name="ln6707"> </a>
<a name="ln6708">  if (qfwin != NULL) {</a>
<a name="ln6709">    // If the quickfix/location list window is open, then clear it</a>
<a name="ln6710">    if (qi-&gt;qf_curlist &lt; qi-&gt;qf_listcount) {</a>
<a name="ln6711">      qf_free(qf_get_curlist(qi));</a>
<a name="ln6712">    }</a>
<a name="ln6713">    qf_update_buffer(qi, NULL);</a>
<a name="ln6714">  }</a>
<a name="ln6715"> </a>
<a name="ln6716">  if (wp != NULL &amp;&amp; IS_LL_WINDOW(wp)) {</a>
<a name="ln6717">    // If in the location list window, then use the non-location list</a>
<a name="ln6718">    // window with this location list (if present)</a>
<a name="ln6719">    win_T *const llwin = qf_find_win_with_loclist(qi);</a>
<a name="ln6720">    if (llwin != NULL) {</a>
<a name="ln6721">      wp = llwin;</a>
<a name="ln6722">    }</a>
<a name="ln6723">  }</a>
<a name="ln6724"> </a>
<a name="ln6725">  qf_free_all(wp);</a>
<a name="ln6726">  if (wp == NULL) {</a>
<a name="ln6727">    // quickfix list</a>
<a name="ln6728">    qi-&gt;qf_curlist = 0;</a>
<a name="ln6729">    qi-&gt;qf_listcount = 0;</a>
<a name="ln6730">  } else if (qfwin != NULL) {</a>
<a name="ln6731">    // If the location list window is open, then create a new empty location</a>
<a name="ln6732">    // list</a>
<a name="ln6733">    qf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);</a>
<a name="ln6734">    new_ll-&gt;qf_bufnr = qfwin-&gt;w_buffer-&gt;b_fnum;</a>
<a name="ln6735"> </a>
<a name="ln6736">    // first free the list reference in the location list window</a>
<a name="ln6737">    ll_free_all(&amp;qfwin-&gt;w_llist_ref);</a>
<a name="ln6738"> </a>
<a name="ln6739">    qfwin-&gt;w_llist_ref = new_ll;</a>
<a name="ln6740">    if (wp != qfwin) {</a>
<a name="ln6741">      win_set_loclist(wp, new_ll);</a>
<a name="ln6742">    }</a>
<a name="ln6743">  }</a>
<a name="ln6744">}</a>
<a name="ln6745"> </a>
<a name="ln6746">// Populate the quickfix list with the items supplied in the list</a>
<a name="ln6747">// of dictionaries. &quot;title&quot; will be copied to w:quickfix_title</a>
<a name="ln6748">// &quot;action&quot; is 'a' for add, 'r' for replace.  Otherwise create a new list.</a>
<a name="ln6749">// When &quot;what&quot; is not NULL then only set some properties.</a>
<a name="ln6750">int set_errorlist(win_T *wp, list_T *list, int action, char *title, dict_T *what)</a>
<a name="ln6751">{</a>
<a name="ln6752">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln6753"> </a>
<a name="ln6754">  if (wp != NULL) {</a>
<a name="ln6755">    qi = ll_get_or_alloc_list(wp);</a>
<a name="ln6756">  }</a>
<a name="ln6757"> </a>
<a name="ln6758">  if (action == 'f') {</a>
<a name="ln6759">    // Free the entire quickfix or location list stack</a>
<a name="ln6760">    qf_free_stack(wp, qi);</a>
<a name="ln6761">    return OK;</a>
<a name="ln6762">  }</a>
<a name="ln6763"> </a>
<a name="ln6764">  // A dict argument cannot be specified with a non-empty list argument</a>
<a name="ln6765">  if (list != NULL &amp;&amp; tv_list_len(list) != 0 &amp;&amp; what != NULL) {</a>
<a name="ln6766">    semsg(_(e_invarg2), _(&quot;cannot have both a list and a \&quot;what\&quot; argument&quot;));</a>
<a name="ln6767">    return FAIL;</a>
<a name="ln6768">  }</a>
<a name="ln6769"> </a>
<a name="ln6770">  incr_quickfix_busy();</a>
<a name="ln6771"> </a>
<a name="ln6772">  int retval = OK;</a>
<a name="ln6773">  if (what != NULL) {</a>
<a name="ln6774">    retval = qf_set_properties(qi, what, action, title);</a>
<a name="ln6775">  } else {</a>
<a name="ln6776">    retval = qf_add_entries(qi, qi-&gt;qf_curlist, list, title, action);</a>
<a name="ln6777">    if (retval == OK) {</a>
<a name="ln6778">      qf_list_changed(qf_get_curlist(qi));</a>
<a name="ln6779">    }</a>
<a name="ln6780">  }</a>
<a name="ln6781"> </a>
<a name="ln6782">  decr_quickfix_busy();</a>
<a name="ln6783"> </a>
<a name="ln6784">  return retval;</a>
<a name="ln6785">}</a>
<a name="ln6786"> </a>
<a name="ln6787">static bool mark_quickfix_user_data(qf_info_T *qi, int copyID)</a>
<a name="ln6788">{</a>
<a name="ln6789">  bool abort = false;</a>
<a name="ln6790">  for (int i = 0; i &lt; LISTCOUNT &amp;&amp; !abort; i++) {</a>
<a name="ln6791">    qf_list_T *qfl = &amp;qi-&gt;qf_lists[i];</a>
<a name="ln6792">    if (!qfl-&gt;qf_has_user_data) {</a>
<a name="ln6793">      continue;</a>
<a name="ln6794">    }</a>
<a name="ln6795">    qfline_T *qfp;</a>
<a name="ln6796">    int j;</a>
<a name="ln6797">    FOR_ALL_QFL_ITEMS(qfl, qfp, j) {</a>
<a name="ln6798">      typval_T *user_data = &amp;qfp-&gt;qf_user_data;</a>
<a name="ln6799">      if (user_data != NULL &amp;&amp; user_data-&gt;v_type != VAR_NUMBER</a>
<a name="ln6800">          &amp;&amp; user_data-&gt;v_type != VAR_STRING &amp;&amp; user_data-&gt;v_type != VAR_FLOAT) {</a>
<a name="ln6801">        abort = abort || set_ref_in_item(user_data, copyID, NULL, NULL);</a>
<a name="ln6802">      }</a>
<a name="ln6803">    }</a>
<a name="ln6804">  }</a>
<a name="ln6805">  return abort;</a>
<a name="ln6806">}</a>
<a name="ln6807"> </a>
<a name="ln6808">/// Mark the quickfix context and callback function as in use for all the lists</a>
<a name="ln6809">/// in a quickfix stack.</a>
<a name="ln6810">static bool mark_quickfix_ctx(qf_info_T *qi, int copyID)</a>
<a name="ln6811">{</a>
<a name="ln6812">  bool abort = false;</a>
<a name="ln6813"> </a>
<a name="ln6814">  for (int i = 0; i &lt; LISTCOUNT &amp;&amp; !abort; i++) {</a>
<a name="ln6815">    typval_T *ctx = qi-&gt;qf_lists[i].qf_ctx;</a>
<a name="ln6816">    if (ctx != NULL &amp;&amp; ctx-&gt;v_type != VAR_NUMBER</a>
<a name="ln6817">        &amp;&amp; ctx-&gt;v_type != VAR_STRING &amp;&amp; ctx-&gt;v_type != VAR_FLOAT) {</a>
<a name="ln6818">      abort = set_ref_in_item(ctx, copyID, NULL, NULL);</a>
<a name="ln6819">    }</a>
<a name="ln6820"> </a>
<a name="ln6821">    Callback *cb = &amp;qi-&gt;qf_lists[i].qf_qftf_cb;</a>
<a name="ln6822">    abort = abort || set_ref_in_callback(cb, copyID, NULL, NULL);</a>
<a name="ln6823">  }</a>
<a name="ln6824"> </a>
<a name="ln6825">  return abort;</a>
<a name="ln6826">}</a>
<a name="ln6827"> </a>
<a name="ln6828">/// Mark the context of the quickfix list and the location lists (if present) as</a>
<a name="ln6829">/// &quot;in use&quot;. So that garbage collection doesn't free the context.</a>
<a name="ln6830">bool set_ref_in_quickfix(int copyID)</a>
<a name="ln6831">{</a>
<a name="ln6832">  bool abort = mark_quickfix_ctx(&amp;ql_info, copyID);</a>
<a name="ln6833">  if (abort) {</a>
<a name="ln6834">    return abort;</a>
<a name="ln6835">  }</a>
<a name="ln6836"> </a>
<a name="ln6837">  abort = mark_quickfix_user_data(&amp;ql_info, copyID);</a>
<a name="ln6838">  if (abort) {</a>
<a name="ln6839">    return abort;</a>
<a name="ln6840">  }</a>
<a name="ln6841"> </a>
<a name="ln6842">  abort = set_ref_in_callback(&amp;qftf_cb, copyID, NULL, NULL);</a>
<a name="ln6843">  if (abort) {</a>
<a name="ln6844">    return abort;</a>
<a name="ln6845">  }</a>
<a name="ln6846"> </a>
<a name="ln6847">  FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln6848">    if (win-&gt;w_llist != NULL) {</a>
<a name="ln6849">      abort = mark_quickfix_ctx(win-&gt;w_llist, copyID);</a>
<a name="ln6850">      if (abort) {</a>
<a name="ln6851">        return abort;</a>
<a name="ln6852">      }</a>
<a name="ln6853"> </a>
<a name="ln6854">      abort = mark_quickfix_user_data(win-&gt;w_llist, copyID);</a>
<a name="ln6855">      if (abort) {</a>
<a name="ln6856">        return abort;</a>
<a name="ln6857">      }</a>
<a name="ln6858">    }</a>
<a name="ln6859"> </a>
<a name="ln6860">    if (IS_LL_WINDOW(win) &amp;&amp; (win-&gt;w_llist_ref-&gt;qf_refcount == 1)) {</a>
<a name="ln6861">      // In a location list window and none of the other windows is</a>
<a name="ln6862">      // referring to this location list. Mark the location list</a>
<a name="ln6863">      // context as still in use.</a>
<a name="ln6864">      abort = mark_quickfix_ctx(win-&gt;w_llist_ref, copyID);</a>
<a name="ln6865">      if (abort) {</a>
<a name="ln6866">        return abort;</a>
<a name="ln6867">      }</a>
<a name="ln6868">    }</a>
<a name="ln6869">  }</a>
<a name="ln6870"> </a>
<a name="ln6871">  return abort;</a>
<a name="ln6872">}</a>
<a name="ln6873"> </a>
<a name="ln6874">/// Return the autocmd name for the :cbuffer Ex commands</a>
<a name="ln6875">static char *cbuffer_get_auname(cmdidx_T cmdidx)</a>
<a name="ln6876">{</a>
<a name="ln6877">  switch (cmdidx) {</a>
<a name="ln6878">  case CMD_cbuffer:</a>
<a name="ln6879">    return &quot;cbuffer&quot;;</a>
<a name="ln6880">  case CMD_cgetbuffer:</a>
<a name="ln6881">    return &quot;cgetbuffer&quot;;</a>
<a name="ln6882">  case CMD_caddbuffer:</a>
<a name="ln6883">    return &quot;caddbuffer&quot;;</a>
<a name="ln6884">  case CMD_lbuffer:</a>
<a name="ln6885">    return &quot;lbuffer&quot;;</a>
<a name="ln6886">  case CMD_lgetbuffer:</a>
<a name="ln6887">    return &quot;lgetbuffer&quot;;</a>
<a name="ln6888">  case CMD_laddbuffer:</a>
<a name="ln6889">    return &quot;laddbuffer&quot;;</a>
<a name="ln6890">  default:</a>
<a name="ln6891">    return NULL;</a>
<a name="ln6892">  }</a>
<a name="ln6893">}</a>
<a name="ln6894"> </a>
<a name="ln6895">/// Process and validate the arguments passed to the :cbuffer, :caddbuffer,</a>
<a name="ln6896">/// :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.</a>
<a name="ln6897">static int cbuffer_process_args(exarg_T *eap, buf_T **bufp, linenr_T *line1, linenr_T *line2)</a>
<a name="ln6898">{</a>
<a name="ln6899">  buf_T *buf = NULL;</a>
<a name="ln6900"> </a>
<a name="ln6901">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln6902">    buf = curbuf;</a>
<a name="ln6903">  } else if (*skipwhite(skipdigits(eap-&gt;arg)) == NUL) {</a>
<a name="ln6904">    buf = buflist_findnr(atoi(eap-&gt;arg));</a>
<a name="ln6905">  }</a>
<a name="ln6906"> </a>
<a name="ln6907">  if (buf == NULL) {</a>
<a name="ln6908">    emsg(_(e_invarg));</a>
<a name="ln6909">    return FAIL;</a>
<a name="ln6910">  }</a>
<a name="ln6911"> </a>
<a name="ln6912">  if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln6913">    emsg(_(&quot;E681: Buffer is not loaded&quot;));</a>
<a name="ln6914">    return FAIL;</a>
<a name="ln6915">  }</a>
<a name="ln6916"> </a>
<a name="ln6917">  if (eap-&gt;addr_count == 0) {</a>
<a name="ln6918">    eap-&gt;line1 = 1;</a>
<a name="ln6919">    eap-&gt;line2 = buf-&gt;b_ml.ml_line_count;</a>
<a name="ln6920">  }</a>
<a name="ln6921"> </a>
<a name="ln6922">  if (eap-&gt;line1 &lt; 1 || eap-&gt;line1 &gt; buf-&gt;b_ml.ml_line_count</a>
<a name="ln6923">      || eap-&gt;line2 &lt; 1 || eap-&gt;line2 &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln6924">    emsg(_(e_invrange));</a>
<a name="ln6925">    return FAIL;</a>
<a name="ln6926">  }</a>
<a name="ln6927"> </a>
<a name="ln6928">  *line1 = eap-&gt;line1;</a>
<a name="ln6929">  *line2 = eap-&gt;line2;</a>
<a name="ln6930">  *bufp = buf;</a>
<a name="ln6931"> </a>
<a name="ln6932">  return OK;</a>
<a name="ln6933">}</a>
<a name="ln6934"> </a>
<a name="ln6935">// &quot;:[range]cbuffer [bufnr]&quot; command.</a>
<a name="ln6936">// &quot;:[range]caddbuffer [bufnr]&quot; command.</a>
<a name="ln6937">// &quot;:[range]cgetbuffer [bufnr]&quot; command.</a>
<a name="ln6938">// &quot;:[range]lbuffer [bufnr]&quot; command.</a>
<a name="ln6939">// &quot;:[range]laddbuffer [bufnr]&quot; command.</a>
<a name="ln6940">// &quot;:[range]lgetbuffer [bufnr]&quot; command.</a>
<a name="ln6941">void ex_cbuffer(exarg_T *eap)</a>
<a name="ln6942">{</a>
<a name="ln6943">  char *au_name = cbuffer_get_auname(eap-&gt;cmdidx);</a>
<a name="ln6944">  if (au_name != NULL &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,</a>
<a name="ln6945">                                        curbuf-&gt;b_fname, true, curbuf)) {</a>
<a name="ln6946">    if (aborting()) {</a>
<a name="ln6947">      return;</a>
<a name="ln6948">    }</a>
<a name="ln6949">  }</a>
<a name="ln6950"> </a>
<a name="ln6951">  // Must come after autocommands.</a>
<a name="ln6952">  win_T *wp = NULL;</a>
<a name="ln6953">  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &amp;wp);</a>
<a name="ln6954"> </a>
<a name="ln6955">  buf_T *buf = NULL;</a>
<a name="ln6956">  linenr_T line1;</a>
<a name="ln6957">  linenr_T line2;</a>
<a name="ln6958">  if (cbuffer_process_args(eap, &amp;buf, &amp;line1, &amp;line2) == FAIL) {</a>
<a name="ln6959">    return;</a>
<a name="ln6960">  }</a>
<a name="ln6961"> </a>
<a name="ln6962">  char *qf_title = qf_cmdtitle(*eap-&gt;cmdlinep);</a>
<a name="ln6963"> </a>
<a name="ln6964">  if (buf-&gt;b_sfname) {</a>
<a name="ln6965">    vim_snprintf(IObuff, IOSIZE, &quot;%s (%s)&quot;, qf_title, buf-&gt;b_sfname);</a>
<a name="ln6966">    qf_title = IObuff;</a>
<a name="ln6967">  }</a>
<a name="ln6968"> </a>
<a name="ln6969">  incr_quickfix_busy();</a>
<a name="ln6970"> </a>
<a name="ln6971">  int res = qf_init_ext(qi, qi-&gt;qf_curlist, NULL, buf, NULL, p_efm,</a>
<a name="ln6972">                        (eap-&gt;cmdidx != CMD_caddbuffer</a>
<a name="ln6973">                         &amp;&amp; eap-&gt;cmdidx != CMD_laddbuffer),</a>
<a name="ln6974">                        eap-&gt;line1, eap-&gt;line2, qf_title, NULL);</a>
<a name="ln6975">  if (qf_stack_empty(qi)) {</a>
<a name="ln6976">    decr_quickfix_busy();</a>
<a name="ln6977">    return;</a>
<a name="ln6978">  }</a>
<a name="ln6979">  if (res &gt;= 0) {</a>
<a name="ln6980">    qf_list_changed(qf_get_curlist(qi));</a>
<a name="ln6981">  }</a>
<a name="ln6982">  // Remember the current quickfix list identifier, so that we can</a>
<a name="ln6983">  // check for autocommands changing the current quickfix list.</a>
<a name="ln6984">  unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln6985">  if (au_name != NULL) {</a>
<a name="ln6986">    const buf_T *const curbuf_old = curbuf;</a>
<a name="ln6987">    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln6988">    if (curbuf != curbuf_old) {</a>
<a name="ln6989">      // Autocommands changed buffer, don't jump now, &quot;qi&quot; may</a>
<a name="ln6990">      // be invalid.</a>
<a name="ln6991">      res = 0;</a>
<a name="ln6992">    }</a>
<a name="ln6993">  }</a>
<a name="ln6994">  // Jump to the first error for new list and if autocmds didn't</a>
<a name="ln6995">  // free the list.</a>
<a name="ln6996">  if (res &gt; 0 &amp;&amp; (eap-&gt;cmdidx == CMD_cbuffer || eap-&gt;cmdidx == CMD_lbuffer)</a>
<a name="ln6997">      &amp;&amp; qflist_valid(wp, save_qfid)) {</a>
<a name="ln6998">    // display the first error</a>
<a name="ln6999">    qf_jump_first(qi, save_qfid, eap-&gt;forceit);</a>
<a name="ln7000">  }</a>
<a name="ln7001"> </a>
<a name="ln7002">  decr_quickfix_busy();</a>
<a name="ln7003">}</a>
<a name="ln7004"> </a>
<a name="ln7005">/// Return the autocmd name for the :cexpr Ex commands.</a>
<a name="ln7006">static char *cexpr_get_auname(cmdidx_T cmdidx)</a>
<a name="ln7007">{</a>
<a name="ln7008">  switch (cmdidx) {</a>
<a name="ln7009">  case CMD_cexpr:</a>
<a name="ln7010">    return &quot;cexpr&quot;;</a>
<a name="ln7011">  case CMD_cgetexpr:</a>
<a name="ln7012">    return &quot;cgetexpr&quot;;</a>
<a name="ln7013">  case CMD_caddexpr:</a>
<a name="ln7014">    return &quot;caddexpr&quot;;</a>
<a name="ln7015">  case CMD_lexpr:</a>
<a name="ln7016">    return &quot;lexpr&quot;;</a>
<a name="ln7017">  case CMD_lgetexpr:</a>
<a name="ln7018">    return &quot;lgetexpr&quot;;</a>
<a name="ln7019">  case CMD_laddexpr:</a>
<a name="ln7020">    return &quot;laddexpr&quot;;</a>
<a name="ln7021">  default:</a>
<a name="ln7022">    return NULL;</a>
<a name="ln7023">  }</a>
<a name="ln7024">}</a>
<a name="ln7025"> </a>
<a name="ln7026">/// &quot;:cexpr {expr}&quot;, &quot;:cgetexpr {expr}&quot;, &quot;:caddexpr {expr}&quot; command.</a>
<a name="ln7027">/// &quot;:lexpr {expr}&quot;, &quot;:lgetexpr {expr}&quot;, &quot;:laddexpr {expr}&quot; command.</a>
<a name="ln7028">void ex_cexpr(exarg_T *eap)</a>
<a name="ln7029">{</a>
<a name="ln7030">  char *au_name = cexpr_get_auname(eap-&gt;cmdidx);</a>
<a name="ln7031">  if (au_name != NULL &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,</a>
<a name="ln7032">                                        curbuf-&gt;b_fname, true, curbuf)) {</a>
<a name="ln7033">    if (aborting()) {</a>
<a name="ln7034">      return;</a>
<a name="ln7035">    }</a>
<a name="ln7036">  }</a>
<a name="ln7037"> </a>
<a name="ln7038">  win_T *wp = NULL;</a>
<a name="ln7039">  qf_info_T *qi = qf_cmd_get_or_alloc_stack(eap, &amp;wp);</a>
<a name="ln7040"> </a>
<a name="ln7041">  // Evaluate the expression.  When the result is a string or a list we can</a>
<a name="ln7042">  // use it to fill the errorlist.</a>
<a name="ln7043">  typval_T *tv = eval_expr(eap-&gt;arg, eap);</a>
<a name="ln7044">  if (tv == NULL) {</a>
<a name="ln7045">    return;</a>
<a name="ln7046">  }</a>
<a name="ln7047"> </a>
<a name="ln7048">  if ((tv-&gt;v_type == VAR_STRING &amp;&amp; tv-&gt;vval.v_string != NULL)</a>
<a name="ln7049">      || tv-&gt;v_type == VAR_LIST) {</a>
<a name="ln7050">    incr_quickfix_busy();</a>
<a name="ln7051">    int res = qf_init_ext(qi, qi-&gt;qf_curlist, NULL, NULL, tv, p_efm,</a>
<a name="ln7052">                          (eap-&gt;cmdidx != CMD_caddexpr</a>
<a name="ln7053">                           &amp;&amp; eap-&gt;cmdidx != CMD_laddexpr),</a>
<a name="ln7054">                          0, 0,</a>
<a name="ln7055">                          qf_cmdtitle(*eap-&gt;cmdlinep), NULL);</a>
<a name="ln7056">    if (qf_stack_empty(qi)) {</a>
<a name="ln7057">      decr_quickfix_busy();</a>
<a name="ln7058">      goto cleanup;</a>
<a name="ln7059">    }</a>
<a name="ln7060">    if (res &gt;= 0) {</a>
<a name="ln7061">      qf_list_changed(qf_get_curlist(qi));</a>
<a name="ln7062">    }</a>
<a name="ln7063">    // Remember the current quickfix list identifier, so that we can</a>
<a name="ln7064">    // check for autocommands changing the current quickfix list.</a>
<a name="ln7065">    unsigned save_qfid = qf_get_curlist(qi)-&gt;qf_id;</a>
<a name="ln7066">    if (au_name != NULL) {</a>
<a name="ln7067">      apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln7068">    }</a>
<a name="ln7069">    // Jump to the first error for a new list and if autocmds didn't</a>
<a name="ln7070">    // free the list.</a>
<a name="ln7071">    if (res &gt; 0</a>
<a name="ln7072">        &amp;&amp; (eap-&gt;cmdidx == CMD_cexpr || eap-&gt;cmdidx == CMD_lexpr)</a>
<a name="ln7073">        &amp;&amp; qflist_valid(wp, save_qfid)) {</a>
<a name="ln7074">      // display the first error</a>
<a name="ln7075">      qf_jump_first(qi, save_qfid, eap-&gt;forceit);</a>
<a name="ln7076">    }</a>
<a name="ln7077">    decr_quickfix_busy();</a>
<a name="ln7078">  } else {</a>
<a name="ln7079">    emsg(_(&quot;E777: String or List expected&quot;));</a>
<a name="ln7080">  }</a>
<a name="ln7081">cleanup:</a>
<a name="ln7082">  tv_free(tv);</a>
<a name="ln7083">}</a>
<a name="ln7084"> </a>
<a name="ln7085">// Get the location list for &quot;:lhelpgrep&quot;</a>
<a name="ln7086">static qf_info_T *hgr_get_ll(bool *new_ll)</a>
<a name="ln7087">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln7088">{</a>
<a name="ln7089">  // If the current window is a help window, then use it, else find an existing help window</a>
<a name="ln7090">  win_T *wp = bt_help(curwin-&gt;w_buffer) ? curwin : qf_find_help_win();</a>
<a name="ln7091"> </a>
<a name="ln7092">  qf_info_T *qi = wp == NULL ? NULL : wp-&gt;w_llist;</a>
<a name="ln7093">  if (qi == NULL) {</a>
<a name="ln7094">    // Allocate a new location list for help text matches</a>
<a name="ln7095">    qi = qf_alloc_stack(QFLT_LOCATION);</a>
<a name="ln7096">    *new_ll = true;</a>
<a name="ln7097">  }</a>
<a name="ln7098"> </a>
<a name="ln7099">  return qi;</a>
<a name="ln7100">}</a>
<a name="ln7101"> </a>
<a name="ln7102">// Search for a pattern in a help file.</a>
<a name="ln7103">static void hgr_search_file(qf_list_T *qfl, char *fname, regmatch_T *p_regmatch)</a>
<a name="ln7104">  FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln7105">{</a>
<a name="ln7106">  FILE *const fd = os_fopen(fname, &quot;r&quot;);</a>
<a name="ln7107">  if (fd == NULL) {</a>
<a name="ln7108">    return;</a>
<a name="ln7109">  }</a>
<a name="ln7110"> </a>
<a name="ln7111">  linenr_T lnum = 1;</a>
<a name="ln7112">  while (!vim_fgets(IObuff, IOSIZE, fd) &amp;&amp; !got_int) {</a>
<a name="ln7113">    char *line = IObuff;</a>
<a name="ln7114"> </a>
<a name="ln7115">    if (vim_regexec(p_regmatch, line, 0)) {</a>
<a name="ln7116">      int l = (int)strlen(line);</a>
<a name="ln7117"> </a>
<a name="ln7118">      // remove trailing CR, LF, spaces, etc.</a>
<a name="ln7119">      while (l &gt; 0 &amp;&amp; line[l - 1] &lt;= ' ') {</a>
<a name="ln7120">        line[--l] = NUL;</a>
<a name="ln7121">      }</a>
<a name="ln7122"> </a>
<a name="ln7123">      if (qf_add_entry(qfl,</a>
<a name="ln7124">                       NULL,   // dir</a>
<a name="ln7125">                       fname,</a>
<a name="ln7126">                       NULL,</a>
<a name="ln7127">                       0,</a>
<a name="ln7128">                       line,</a>
<a name="ln7129">                       lnum,</a>
<a name="ln7130">                       0,</a>
<a name="ln7131">                       (int)(p_regmatch-&gt;startp[0] - line) + 1,  // col</a>
<a name="ln7132">                       (int)(p_regmatch-&gt;endp[0] - line)</a>
<a name="ln7133">                       + 1,    // end_col</a>
<a name="ln7134">                       false,  // vis_col</a>
<a name="ln7135">                       NULL,   // search pattern</a>
<a name="ln7136">                       0,      // nr</a>
<a name="ln7137">                       1,      // type</a>
<a name="ln7138">                       NULL,   // user_data</a>
<a name="ln7139">                       true)   // valid</a>
<a name="ln7140">          == QF_FAIL) {</a>
<a name="ln7141">        got_int = true;</a>
<a name="ln7142">        if (line != IObuff) {</a>
<a name="ln7143">          xfree(line);</a>
<a name="ln7144">        }</a>
<a name="ln7145">        break;</a>
<a name="ln7146">      }</a>
<a name="ln7147">    }</a>
<a name="ln7148">    if (line != IObuff) {</a>
<a name="ln7149">      xfree(line);</a>
<a name="ln7150">    }</a>
<a name="ln7151">    lnum++;</a>
<a name="ln7152">    line_breakcheck();</a>
<a name="ln7153">  }</a>
<a name="ln7154">  fclose(fd);</a>
<a name="ln7155">}</a>
<a name="ln7156"> </a>
<a name="ln7157">// Search for a pattern in all the help files in the doc directory under</a>
<a name="ln7158">// the given directory.</a>
<a name="ln7159">static void hgr_search_files_in_dir(qf_list_T *qfl, char *dirname, regmatch_T *p_regmatch,</a>
<a name="ln7160">                                    const char *lang)</a>
<a name="ln7161">  FUNC_ATTR_NONNULL_ARG(1, 2, 3)</a>
<a name="ln7162">{</a>
<a name="ln7163">  int fcount;</a>
<a name="ln7164">  char **fnames;</a>
<a name="ln7165"> </a>
<a name="ln7166">  // Find all &quot;*.txt&quot; and &quot;*.??x&quot; files in the &quot;doc&quot; directory.</a>
<a name="ln7167">  add_pathsep(dirname);</a>
<a name="ln7168">  STRCAT(dirname, &quot;doc/*.\\(txt\\|??x\\)&quot;);  // NOLINT</a>
<a name="ln7169">  if (gen_expand_wildcards(1, &amp;dirname, &amp;fcount, &amp;fnames, EW_FILE|EW_SILENT) == OK</a>
<a name="ln7170">      &amp;&amp; fcount &gt; 0) {</a>
<a name="ln7171">    for (int fi = 0; fi &lt; fcount &amp;&amp; !got_int; fi++) {</a>
<a name="ln7172">      // Skip files for a different language.</a>
<a name="ln7173">      if (lang != NULL</a>
<a name="ln7174">          &amp;&amp; STRNICMP(lang, fnames[fi] + strlen(fnames[fi]) - 3, 2) != 0</a>
<a name="ln7175">          &amp;&amp; !(STRNICMP(lang, &quot;en&quot;, 2) == 0</a>
<a name="ln7176">               &amp;&amp; STRNICMP(&quot;txt&quot;, fnames[fi] + strlen(fnames[fi]) - 3, 3)</a>
<a name="ln7177">               == 0)) {</a>
<a name="ln7178">        continue;</a>
<a name="ln7179">      }</a>
<a name="ln7180"> </a>
<a name="ln7181">      hgr_search_file(qfl, fnames[fi], p_regmatch);</a>
<a name="ln7182">    }</a>
<a name="ln7183">    FreeWild(fcount, fnames);</a>
<a name="ln7184">  }</a>
<a name="ln7185">}</a>
<a name="ln7186"> </a>
<a name="ln7187">// Search for a pattern in all the help files in the 'runtimepath'</a>
<a name="ln7188">// and add the matches to a quickfix list.</a>
<a name="ln7189">// 'lang' is the language specifier.  If supplied, then only matches in the</a>
<a name="ln7190">// specified language are found.</a>
<a name="ln7191">static void hgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch, const char *lang)</a>
<a name="ln7192">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln7193">{</a>
<a name="ln7194">  // Go through all directories in 'runtimepath'</a>
<a name="ln7195">  char *p = p_rtp;</a>
<a name="ln7196">  while (*p != NUL &amp;&amp; !got_int) {</a>
<a name="ln7197">    copy_option_part(&amp;p, NameBuff, MAXPATHL, &quot;,&quot;);</a>
<a name="ln7198"> </a>
<a name="ln7199">    hgr_search_files_in_dir(qfl, NameBuff, p_regmatch, lang);</a>
<a name="ln7200">  }</a>
<a name="ln7201">}</a>
<a name="ln7202"> </a>
<a name="ln7203">// &quot;:helpgrep {pattern}&quot;</a>
<a name="ln7204">void ex_helpgrep(exarg_T *eap)</a>
<a name="ln7205">{</a>
<a name="ln7206">  qf_info_T *qi = &amp;ql_info;</a>
<a name="ln7207">  char *au_name = NULL;</a>
<a name="ln7208"> </a>
<a name="ln7209">  switch (eap-&gt;cmdidx) {</a>
<a name="ln7210">  case CMD_helpgrep:</a>
<a name="ln7211">    au_name = &quot;helpgrep&quot;; break;</a>
<a name="ln7212">  case CMD_lhelpgrep:</a>
<a name="ln7213">    au_name = &quot;lhelpgrep&quot;; break;</a>
<a name="ln7214">  default:</a>
<a name="ln7215">    break;</a>
<a name="ln7216">  }</a>
<a name="ln7217">  if (au_name != NULL &amp;&amp; apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,</a>
<a name="ln7218">                                        curbuf-&gt;b_fname, true, curbuf)) {</a>
<a name="ln7219">    if (aborting()) {</a>
<a name="ln7220">      return;</a>
<a name="ln7221">    }</a>
<a name="ln7222">  }</a>
<a name="ln7223"> </a>
<a name="ln7224">  bool updated = false;</a>
<a name="ln7225">  // Make 'cpoptions' empty, the 'l' flag should not be used here.</a>
<a name="ln7226">  char *const save_cpo = p_cpo;</a>
<a name="ln7227">  const bool save_cpo_allocated = is_option_allocated(&quot;cpo&quot;);</a>
<a name="ln7228">  p_cpo = empty_string_option;</a>
<a name="ln7229"> </a>
<a name="ln7230">  bool new_qi = false;</a>
<a name="ln7231">  if (is_loclist_cmd(eap-&gt;cmdidx)) {</a>
<a name="ln7232">    qi = hgr_get_ll(&amp;new_qi);</a>
<a name="ln7233">  }</a>
<a name="ln7234"> </a>
<a name="ln7235">  incr_quickfix_busy();</a>
<a name="ln7236"> </a>
<a name="ln7237">  // Check for a specified language</a>
<a name="ln7238">  char *const lang = check_help_lang(eap-&gt;arg);</a>
<a name="ln7239">  regmatch_T regmatch = {</a>
<a name="ln7240">    .regprog = vim_regcomp(eap-&gt;arg, RE_MAGIC + RE_STRING),</a>
<a name="ln7241">    .rm_ic = false,</a>
<a name="ln7242">  };</a>
<a name="ln7243">  if (regmatch.regprog != NULL) {</a>
<a name="ln7244">    // Create a new quickfix list.</a>
<a name="ln7245">    qf_new_list(qi, qf_cmdtitle(*eap-&gt;cmdlinep));</a>
<a name="ln7246">    qf_list_T *const qfl = qf_get_curlist(qi);</a>
<a name="ln7247"> </a>
<a name="ln7248">    hgr_search_in_rtp(qfl, &amp;regmatch, lang);</a>
<a name="ln7249"> </a>
<a name="ln7250">    vim_regfree(regmatch.regprog);</a>
<a name="ln7251"> </a>
<a name="ln7252">    qfl-&gt;qf_nonevalid = false;</a>
<a name="ln7253">    qfl-&gt;qf_ptr = qfl-&gt;qf_start;</a>
<a name="ln7254">    qfl-&gt;qf_index = 1;</a>
<a name="ln7255">    qf_list_changed(qfl);</a>
<a name="ln7256">    updated = true;</a>
<a name="ln7257">  }</a>
<a name="ln7258"> </a>
<a name="ln7259">  if (p_cpo == empty_string_option) {</a>
<a name="ln7260">    p_cpo = save_cpo;</a>
<a name="ln7261">  } else {</a>
<a name="ln7262">    // Darn, some plugin changed the value.  If it's still empty it was</a>
<a name="ln7263">    // changed and restored, need to restore in the complicated way.</a>
<a name="ln7264">    if (*p_cpo == NUL) {</a>
<a name="ln7265">      set_option_value_give_err(&quot;cpo&quot;, CSTR_AS_OPTVAL(save_cpo), 0);</a>
<a name="ln7266">    }</a>
<a name="ln7267">    if (save_cpo_allocated) {</a>
<a name="ln7268">      free_string_option(save_cpo);</a>
<a name="ln7269">    }</a>
<a name="ln7270">  }</a>
<a name="ln7271"> </a>
<a name="ln7272">  if (updated) {</a>
<a name="ln7273">    // This may open a window and source scripts, do this after 'cpo' was</a>
<a name="ln7274">    // restored.</a>
<a name="ln7275">    qf_update_buffer(qi, NULL);</a>
<a name="ln7276">  }</a>
<a name="ln7277"> </a>
<a name="ln7278">  if (au_name != NULL) {</a>
<a name="ln7279">    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln7280">    // When adding a location list to an existing location list stack,</a>
<a name="ln7281">    // if the autocmd made the stack invalid, then just return.</a>
<a name="ln7282">    if (!new_qi &amp;&amp; IS_LL_STACK(qi) &amp;&amp; qf_find_win_with_loclist(qi) == NULL) {</a>
<a name="ln7283">      decr_quickfix_busy();</a>
<a name="ln7284">      return;</a>
<a name="ln7285">    }</a>
<a name="ln7286">  }</a>
<a name="ln7287"> </a>
<a name="ln7288">  // Jump to first match.</a>
<a name="ln7289">  if (!qf_list_empty(qf_get_curlist(qi))) {</a>
<a name="ln7290">    qf_jump(qi, 0, 0, false);</a>
<a name="ln7291">  } else {</a>
<a name="ln7292">    semsg(_(e_nomatch2), eap-&gt;arg);</a>
<a name="ln7293">  }</a>
<a name="ln7294"> </a>
<a name="ln7295">  decr_quickfix_busy();</a>
<a name="ln7296"> </a>
<a name="ln7297">  if (eap-&gt;cmdidx == CMD_lhelpgrep) {</a>
<a name="ln7298">    // If the help window is not opened or if it already points to the</a>
<a name="ln7299">    // correct location list, then free the new location list.</a>
<a name="ln7300">    if (!bt_help(curwin-&gt;w_buffer) || curwin-&gt;w_llist == qi) {</a>
<a name="ln7301">      if (new_qi) {</a>
<a name="ln7302">        ll_free_all(&amp;qi);</a>
<a name="ln7303">      }</a>
<a name="ln7304">    } else if (curwin-&gt;w_llist == NULL &amp;&amp; new_qi) {</a>
<a name="ln7305">      // current window didn't have a location list associated with it</a>
<a name="ln7306">      // before. Associate the new location list now.</a>
<a name="ln7307">      curwin-&gt;w_llist = qi;</a>
<a name="ln7308">    }</a>
<a name="ln7309">  }</a>
<a name="ln7310">}</a>
<a name="ln7311"> </a>
<a name="ln7312">#if defined(EXITFREE)</a>
<a name="ln7313">void free_quickfix(void)</a>
<a name="ln7314">{</a>
<a name="ln7315">  qf_free_all(NULL);</a>
<a name="ln7316">  // Free all location lists</a>
<a name="ln7317">  FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln7318">    qf_free_all(win);</a>
<a name="ln7319">  }</a>
<a name="ln7320"> </a>
<a name="ln7321">  ga_clear(&amp;qfga);</a>
<a name="ln7322">}</a>
<a name="ln7323">#endif</a>
<a name="ln7324"> </a>
<a name="ln7325">static void get_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)</a>
<a name="ln7326">{</a>
<a name="ln7327">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln7328">    tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln7329">    if (is_qf || wp != NULL) {</a>
<a name="ln7330">      (void)get_errorlist(NULL, wp, -1, 0, rettv-&gt;vval.v_list);</a>
<a name="ln7331">    }</a>
<a name="ln7332">  } else {</a>
<a name="ln7333">    tv_dict_alloc_ret(rettv);</a>
<a name="ln7334">    if (is_qf || wp != NULL) {</a>
<a name="ln7335">      if (what_arg-&gt;v_type == VAR_DICT) {</a>
<a name="ln7336">        dict_T *d = what_arg-&gt;vval.v_dict;</a>
<a name="ln7337"> </a>
<a name="ln7338">        if (d != NULL) {</a>
<a name="ln7339">          qf_get_properties(wp, d, rettv-&gt;vval.v_dict);</a>
<a name="ln7340">        }</a>
<a name="ln7341">      } else {</a>
<a name="ln7342">        emsg(_(e_dictreq));</a>
<a name="ln7343">      }</a>
<a name="ln7344">    }</a>
<a name="ln7345">  }</a>
<a name="ln7346">}</a>
<a name="ln7347"> </a>
<a name="ln7348">/// &quot;getloclist()&quot; function</a>
<a name="ln7349">void f_getloclist(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln7350">{</a>
<a name="ln7351">  win_T *wp = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7352">  get_qf_loc_list(false, wp, &amp;argvars[1], rettv);</a>
<a name="ln7353">}</a>
<a name="ln7354"> </a>
<a name="ln7355">/// &quot;getqflist()&quot; functions</a>
<a name="ln7356">void f_getqflist(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln7357">{</a>
<a name="ln7358">  get_qf_loc_list(true, NULL, &amp;argvars[0], rettv);</a>
<a name="ln7359">}</a>
<a name="ln7360"> </a>
<a name="ln7361">/// Create quickfix/location list from Vimscript values</a>
<a name="ln7362">///</a>
<a name="ln7363">/// Used by `setqflist()` and `setloclist()` functions. Accepts invalid</a>
<a name="ln7364">/// args argument in which case errors out, including VAR_UNKNOWN parameters.</a>
<a name="ln7365">///</a>
<a name="ln7366">/// @param[in,out]  wp  Window to create location list for. May be NULL in</a>
<a name="ln7367">///                     which case quickfix list will be created.</a>
<a name="ln7368">/// @param[in]  args  [list, action, what]</a>
<a name="ln7369">/// @param[in]  args[0]  Quickfix list contents.</a>
<a name="ln7370">/// @param[in]  args[1]  Optional. Action to perform:</a>
<a name="ln7371">///                      append to an existing list, replace its content,</a>
<a name="ln7372">///                      or create a new one.</a>
<a name="ln7373">/// @param[in]  args[2]  Optional. Quickfix list properties or title.</a>
<a name="ln7374">///                      Defaults to caller function name.</a>
<a name="ln7375">/// @param[out]  rettv  Return value: 0 in case of success, -1 otherwise.</a>
<a name="ln7376">static void set_qf_ll_list(win_T *wp, typval_T *args, typval_T *rettv)</a>
<a name="ln7377">  FUNC_ATTR_NONNULL_ARG(2, 3)</a>
<a name="ln7378">{</a>
<a name="ln7379">  static const char *e_invact = N_(&quot;E927: Invalid action: '%s'&quot;);</a>
<a name="ln7380">  const char *title = NULL;</a>
<a name="ln7381">  char action = ' ';</a>
<a name="ln7382">  static int recursive = 0;</a>
<a name="ln7383">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln7384">  dict_T *what = NULL;</a>
<a name="ln7385"> </a>
<a name="ln7386">  typval_T *list_arg = &amp;args[0];</a>
<a name="ln7387">  if (list_arg-&gt;v_type != VAR_LIST) {</a>
<a name="ln7388">    emsg(_(e_listreq));</a>
<a name="ln7389">    return;</a>
<a name="ln7390">  } else if (recursive != 0) {</a>
<a name="ln7391">    emsg(_(e_au_recursive));</a>
<a name="ln7392">    return;</a>
<a name="ln7393">  }</a>
<a name="ln7394"> </a>
<a name="ln7395">  typval_T *action_arg = &amp;args[1];</a>
<a name="ln7396">  if (action_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln7397">    // Option argument was not given.</a>
<a name="ln7398">    goto skip_args;</a>
<a name="ln7399">  } else if (action_arg-&gt;v_type != VAR_STRING) {</a>
<a name="ln7400">    emsg(_(e_stringreq));</a>
<a name="ln7401">    return;</a>
<a name="ln7402">  }</a>
<a name="ln7403">  const char *const act = tv_get_string_chk(action_arg);</a>
<a name="ln7404">  if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f')</a>
<a name="ln7405">      &amp;&amp; act[1] == NUL) {</a>
<a name="ln7406">    action = *act;</a>
<a name="ln7407">  } else {</a>
<a name="ln7408">    semsg(_(e_invact), act);</a>
<a name="ln7409">    return;</a>
<a name="ln7410">  }</a>
<a name="ln7411"> </a>
<a name="ln7412">  typval_T *const what_arg = &amp;args[2];</a>
<a name="ln7413">  if (what_arg-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln7414">    // Option argument was not given.</a>
<a name="ln7415">    goto skip_args;</a>
<a name="ln7416">  } else if (what_arg-&gt;v_type == VAR_STRING) {</a>
<a name="ln7417">    title = tv_get_string_chk(what_arg);</a>
<a name="ln7418">    if (!title) {</a>
<a name="ln7419">      // Type error. Error already printed by tv_get_string_chk().</a>
<a name="ln7420">      return;</a>
<a name="ln7421">    }</a>
<a name="ln7422">  } else if (what_arg-&gt;v_type == VAR_DICT &amp;&amp; what_arg-&gt;vval.v_dict != NULL) {</a>
<a name="ln7423">    what = what_arg-&gt;vval.v_dict;</a>
<a name="ln7424">  } else {</a>
<a name="ln7425">    emsg(_(e_dictreq));</a>
<a name="ln7426">    return;</a>
<a name="ln7427">  }</a>
<a name="ln7428"> </a>
<a name="ln7429">skip_args:</a>
<a name="ln7430">  if (!title) {</a>
<a name="ln7431">    title = (wp ? &quot;:setloclist()&quot; : &quot;:setqflist()&quot;);</a>
<a name="ln7432">  }</a>
<a name="ln7433"> </a>
<a name="ln7434">  recursive++;</a>
<a name="ln7435">  list_T *const l = list_arg-&gt;vval.v_list;</a>
<a name="ln7436">  if (set_errorlist(wp, l, action, (char *)title, what) == OK) {</a>
<a name="ln7437">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln7438">  }</a>
<a name="ln7439">  recursive--;</a>
<a name="ln7440">}</a>
<a name="ln7441"> </a>
<a name="ln7442">/// &quot;setloclist()&quot; function</a>
<a name="ln7443">void f_setloclist(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln7444">{</a>
<a name="ln7445">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln7446"> </a>
<a name="ln7447">  win_T *win = find_win_by_nr_or_id(&amp;argvars[0]);</a>
<a name="ln7448">  if (win != NULL) {</a>
<a name="ln7449">    set_qf_ll_list(win, &amp;argvars[1], rettv);</a>
<a name="ln7450">  }</a>
<a name="ln7451">}</a>
<a name="ln7452"> </a>
<a name="ln7453">/// &quot;setqflist()&quot; function</a>
<a name="ln7454">void f_setqflist(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln7455">{</a>
<a name="ln7456">  set_qf_ll_list(NULL, argvars, rettv);</a>
<a name="ln7457">}</a>
</code></pre>
<div class="balloon" rel="1559"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'status' variable was assigned the same value.</p></div>
<div class="balloon" rel="6289"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'status' variable was assigned the same value.</p></div>
<div class="balloon" rel="6799"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: user_data != NULL.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>