<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>option.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User-settable options. Checklist for adding a new option:</a>
<a name="ln5">// - Put it in options.lua</a>
<a name="ln6">// - For a global option: Add a variable for it in option_defs.h.</a>
<a name="ln7">// - For a buffer or window local option:</a>
<a name="ln8">//   - Add a BV_XX or WV_XX entry to option_defs.h</a>
<a name="ln9">//   - Add a variable to the window or buffer struct in buffer_defs.h.</a>
<a name="ln10">//   - For a window option, add some code to copy_winopt().</a>
<a name="ln11">//   - For a window string option, add code to check_winopt()</a>
<a name="ln12">//     and clear_winopt(). If setting the option needs parsing,</a>
<a name="ln13">//     add some code to didset_window_options().</a>
<a name="ln14">//   - For a buffer option, add some code to buf_copy_options().</a>
<a name="ln15">//   - For a buffer string option, add code to check_buf_options().</a>
<a name="ln16">// - If it's a numeric option, add any necessary bounds checks to</a>
<a name="ln17">//   set_num_option().</a>
<a name="ln18">// - If it's a list of flags, add some code in do_set(), search for WW_ALL.</a>
<a name="ln19">// - Add documentation! doc/options.txt, and any other related places.</a>
<a name="ln20">// - Add an entry in runtime/optwin.vim.</a>
<a name="ln21"> </a>
<a name="ln22">#define IN_OPTION_C</a>
<a name="ln23">#include &lt;assert.h&gt;</a>
<a name="ln24">#include &lt;inttypes.h&gt;</a>
<a name="ln25">#include &lt;limits.h&gt;</a>
<a name="ln26">#include &lt;stdbool.h&gt;</a>
<a name="ln27">#include &lt;stdio.h&gt;</a>
<a name="ln28">#include &lt;stdlib.h&gt;</a>
<a name="ln29">#include &lt;string.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;auto/config.h&quot;</a>
<a name="ln32">#include &quot;klib/kvec.h&quot;</a>
<a name="ln33">#include &quot;nvim/api/extmark.h&quot;</a>
<a name="ln34">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln35">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln36">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln37">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln38">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln39">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln40">#include &quot;nvim/change.h&quot;</a>
<a name="ln41">#include &quot;nvim/charset.h&quot;</a>
<a name="ln42">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln43">#include &quot;nvim/cmdexpand_defs.h&quot;</a>
<a name="ln44">#include &quot;nvim/cursor_shape.h&quot;</a>
<a name="ln45">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln46">#include &quot;nvim/diff.h&quot;</a>
<a name="ln47">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln48">#include &quot;nvim/eval.h&quot;</a>
<a name="ln49">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln50">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln51">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln52">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln53">#include &quot;nvim/ex_session.h&quot;</a>
<a name="ln54">#include &quot;nvim/fold.h&quot;</a>
<a name="ln55">#include &quot;nvim/garray.h&quot;</a>
<a name="ln56">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln57">#include &quot;nvim/globals.h&quot;</a>
<a name="ln58">#include &quot;nvim/grid_defs.h&quot;</a>
<a name="ln59">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln60">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln61">#include &quot;nvim/indent.h&quot;</a>
<a name="ln62">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln63">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln64">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln65">#include &quot;nvim/log.h&quot;</a>
<a name="ln66">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln67">#include &quot;nvim/macros.h&quot;</a>
<a name="ln68">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln69">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln70">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln71">#include &quot;nvim/memline.h&quot;</a>
<a name="ln72">#include &quot;nvim/memory.h&quot;</a>
<a name="ln73">#include &quot;nvim/message.h&quot;</a>
<a name="ln74">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln75">#include &quot;nvim/move.h&quot;</a>
<a name="ln76">#include &quot;nvim/normal.h&quot;</a>
<a name="ln77">#include &quot;nvim/ops.h&quot;</a>
<a name="ln78">#include &quot;nvim/option.h&quot;</a>
<a name="ln79">#include &quot;nvim/option_defs.h&quot;</a>
<a name="ln80">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln81">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln82">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln83">#include &quot;nvim/os/lang.h&quot;</a>
<a name="ln84">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln85">#include &quot;nvim/path.h&quot;</a>
<a name="ln86">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln87">#include &quot;nvim/pos.h&quot;</a>
<a name="ln88">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln89">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln90">#include &quot;nvim/search.h&quot;</a>
<a name="ln91">#include &quot;nvim/sign_defs.h&quot;</a>
<a name="ln92">#include &quot;nvim/spell.h&quot;</a>
<a name="ln93">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln94">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln95">#include &quot;nvim/strings.h&quot;</a>
<a name="ln96">#include &quot;nvim/tag.h&quot;</a>
<a name="ln97">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln98">#include &quot;nvim/types.h&quot;</a>
<a name="ln99">#include &quot;nvim/ui.h&quot;</a>
<a name="ln100">#include &quot;nvim/undo.h&quot;</a>
<a name="ln101">#include &quot;nvim/vim.h&quot;</a>
<a name="ln102">#include &quot;nvim/window.h&quot;</a>
<a name="ln103"> </a>
<a name="ln104">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln105"># include &quot;nvim/arglist.h&quot;</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108">static const char e_unknown_option[]</a>
<a name="ln109">  = N_(&quot;E518: Unknown option&quot;);</a>
<a name="ln110">static const char e_not_allowed_in_modeline[]</a>
<a name="ln111">  = N_(&quot;E520: Not allowed in a modeline&quot;);</a>
<a name="ln112">static const char e_not_allowed_in_modeline_when_modelineexpr_is_off[]</a>
<a name="ln113">  = N_(&quot;E992: Not allowed in a modeline when 'modelineexpr' is off&quot;);</a>
<a name="ln114">static const char e_key_code_not_set[]</a>
<a name="ln115">  = N_(&quot;E846: Key code not set&quot;);</a>
<a name="ln116">static const char e_number_required_after_equal[]</a>
<a name="ln117">  = N_(&quot;E521: Number required after =&quot;);</a>
<a name="ln118">static const char e_preview_window_already_exists[]</a>
<a name="ln119">  = N_(&quot;E590: A preview window already exists&quot;);</a>
<a name="ln120"> </a>
<a name="ln121">static char *p_term = NULL;</a>
<a name="ln122">static char *p_ttytype = NULL;</a>
<a name="ln123"> </a>
<a name="ln124">// Saved values for when 'bin' is set.</a>
<a name="ln125">static int p_et_nobin;</a>
<a name="ln126">static int p_ml_nobin;</a>
<a name="ln127">static OptInt p_tw_nobin;</a>
<a name="ln128">static OptInt p_wm_nobin;</a>
<a name="ln129"> </a>
<a name="ln130">// Saved values for when 'paste' is set.</a>
<a name="ln131">static int p_ai_nopaste;</a>
<a name="ln132">static int p_et_nopaste;</a>
<a name="ln133">static OptInt p_sts_nopaste;</a>
<a name="ln134">static OptInt p_tw_nopaste;</a>
<a name="ln135">static OptInt p_wm_nopaste;</a>
<a name="ln136">static char *p_vsts_nopaste;</a>
<a name="ln137"> </a>
<a name="ln138">#define OPTION_COUNT ARRAY_SIZE(options)</a>
<a name="ln139"> </a>
<a name="ln140">typedef enum {</a>
<a name="ln141">  PREFIX_NO = 0,  ///&lt; &quot;no&quot; prefix</a>
<a name="ln142">  PREFIX_NONE,    ///&lt; no prefix</a>
<a name="ln143">  PREFIX_INV,     ///&lt; &quot;inv&quot; prefix</a>
<a name="ln144">} set_prefix_T;</a>
<a name="ln145"> </a>
<a name="ln146">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln147"># include &quot;option.c.generated.h&quot;</a>
<a name="ln148">#endif</a>
<a name="ln149"> </a>
<a name="ln150">// options[] is initialized here.</a>
<a name="ln151">// The order of the options MUST be alphabetic for &quot;:set all&quot; and findoption().</a>
<a name="ln152">// All option names MUST start with a lowercase letter (for findoption()).</a>
<a name="ln153">// Exception: &quot;t_&quot; options are at the end.</a>
<a name="ln154">// The options with a NULL variable are 'hidden': a set command for them is</a>
<a name="ln155">// ignored and they are not printed.</a>
<a name="ln156"> </a>
<a name="ln157">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln158"># include &quot;options.generated.h&quot;</a>
<a name="ln159">#endif</a>
<a name="ln160"> </a>
<a name="ln161">static char *(p_bin_dep_opts[]) = {</a>
<a name="ln162">  &quot;textwidth&quot;, &quot;wrapmargin&quot;, &quot;modeline&quot;, &quot;expandtab&quot;, NULL</a>
<a name="ln163">};</a>
<a name="ln164">static char *(p_paste_dep_opts[]) = {</a>
<a name="ln165">  &quot;autoindent&quot;, &quot;expandtab&quot;, &quot;ruler&quot;, &quot;showmatch&quot;, &quot;smarttab&quot;,</a>
<a name="ln166">  &quot;softtabstop&quot;, &quot;textwidth&quot;, &quot;wrapmargin&quot;, &quot;revins&quot;, &quot;varsofttabstop&quot;, NULL</a>
<a name="ln167">};</a>
<a name="ln168"> </a>
<a name="ln169">void set_init_tablocal(void)</a>
<a name="ln170">{</a>
<a name="ln171">  // susy baka: cmdheight calls itself OPT_GLOBAL but is really tablocal!</a>
<a name="ln172">  int ch_idx = findoption(&quot;cmdheight&quot;);</a>
<a name="ln173">  p_ch = (OptInt)(intptr_t)options[ch_idx].def_val;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/// Initialize the 'shell' option to a default value.</a>
<a name="ln177">static void set_init_default_shell(void)</a>
<a name="ln178">{</a>
<a name="ln179">  // Find default value for 'shell' option.</a>
<a name="ln180">  // Don't use it if it is empty.</a>
<a name="ln181">  const char *shell = os_getenv(&quot;SHELL&quot;);</a>
<a name="ln182">  if (shell != NULL) {</a>
<a name="ln183">    if (vim_strchr(shell, ' ') != NULL) {</a>
<a name="ln184">      const size_t len = strlen(shell) + 3;  // two quotes and a trailing NUL</a>
<a name="ln185">      char *const cmd = xmalloc(len);</a>
<a name="ln186">      snprintf(cmd, len, &quot;\&quot;%s\&quot;&quot;, shell);</a>
<a name="ln187">      set_string_default(&quot;sh&quot;, cmd, true);</a>
<a name="ln188">    } else {</a>
<a name="ln189">      set_string_default(&quot;sh&quot;, (char *)shell, false);</a>
<a name="ln190">    }</a>
<a name="ln191">  }</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/// Set the default for 'backupskip' to include environment variables for</a>
<a name="ln195">/// temp files.</a>
<a name="ln196">static void set_init_default_backupskip(void)</a>
<a name="ln197">{</a>
<a name="ln198">#ifdef UNIX</a>
<a name="ln199">  static char *(names[4]) = { &quot;&quot;, &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot; };</a>
<a name="ln200">#else</a>
<a name="ln201">  static char *(names[3]) = { &quot;TMPDIR&quot;, &quot;TEMP&quot;, &quot;TMP&quot; };</a>
<a name="ln202">#endif</a>
<a name="ln203">  garray_T ga;</a>
<a name="ln204">  int opt_idx = findoption(&quot;backupskip&quot;);</a>
<a name="ln205"> </a>
<a name="ln206">  ga_init(&amp;ga, 1, 100);</a>
<a name="ln207">  for (size_t n = 0; n &lt; ARRAY_SIZE(names); n++) {</a>
<a name="ln208">    bool mustfree = true;</a>
<a name="ln209">    char *p;</a>
<a name="ln210">#ifdef UNIX</a>
<a name="ln211">    if (*names[n] == NUL) {</a>
<a name="ln212"># ifdef __APPLE__</a>
<a name="ln213">      p = &quot;/private/tmp&quot;;</a>
<a name="ln214"># else</a>
<a name="ln215">      p = &quot;/tmp&quot;;</a>
<a name="ln216"># endif</a>
<a name="ln217">      mustfree = false;</a>
<a name="ln218">    } else  // NOLINT(readability/braces)</a>
<a name="ln219">#endif</a>
<a name="ln220">    {</a>
<a name="ln221">      p = vim_getenv(names[n]);</a>
<a name="ln222">    }</a>
<a name="ln223">    if (p != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln224">      // First time count the NUL, otherwise count the ','.</a>
<a name="ln225">      const size_t len = strlen(p) + 3;</a>
<a name="ln226">      char *item = xmalloc(len);</a>
<a name="ln227">      xstrlcpy(item, p, len);</a>
<a name="ln228">      add_pathsep(item);</a>
<a name="ln229">      xstrlcat(item, &quot;*&quot;, len);</a>
<a name="ln230">      if (find_dup_item(ga.ga_data, item, options[opt_idx].flags)</a>
<a name="ln231">          == NULL) {</a>
<a name="ln232">        ga_grow(&amp;ga, (int)len);</a>
<a name="ln233">        if (!GA_EMPTY(&amp;ga)) {</a>
<a name="ln234">          STRCAT(ga.ga_data, &quot;,&quot;);</a>
<a name="ln235">        }</a>
<a name="ln236">        STRCAT(ga.ga_data, p);</a>
<a name="ln237">        add_pathsep(ga.ga_data);</a>
<a name="ln238">        STRCAT(ga.ga_data, &quot;*&quot;);</a>
<a name="ln239">        ga.ga_len += (int)len;</a>
<a name="ln240">      }</a>
<a name="ln241">      xfree(item);</a>
<a name="ln242">    }</a>
<a name="ln243">    if (mustfree) {</a>
<a name="ln244">      xfree(p);</a>
<a name="ln245">    }</a>
<a name="ln246">  }</a>
<a name="ln247">  if (ga.ga_data != NULL) {</a>
<a name="ln248">    set_string_default(&quot;bsk&quot;, ga.ga_data, true);</a>
<a name="ln249">  }</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">/// Initialize the 'cdpath' option to a default value.</a>
<a name="ln253">static void set_init_default_cdpath(void)</a>
<a name="ln254">{</a>
<a name="ln255">  char *cdpath = vim_getenv(&quot;CDPATH&quot;);</a>
<a name="ln256">  if (cdpath == NULL) {</a>
<a name="ln257">    return;</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  char *buf = xmalloc(2 * strlen(cdpath) + 2);</a>
<a name="ln261">  buf[0] = ',';               // start with &quot;,&quot;, current dir first</a>
<a name="ln262">  int j = 1;</a>
<a name="ln263">  for (int i = 0; cdpath[i] != NUL; i++) {</a>
<a name="ln264">    if (vim_ispathlistsep(cdpath[i])) {</a>
<a name="ln265">      buf[j++] = ',';</a>
<a name="ln266">    } else {</a>
<a name="ln267">      if (cdpath[i] == ' ' || cdpath[i] == ',') {</a>
<a name="ln268">        buf[j++] = '\\';</a>
<a name="ln269">      }</a>
<a name="ln270">      buf[j++] = cdpath[i];</a>
<a name="ln271">    }</a>
<a name="ln272">  }</a>
<a name="ln273">  buf[j] = NUL;</a>
<a name="ln274">  int opt_idx = findoption(&quot;cdpath&quot;);</a>
<a name="ln275">  if (opt_idx &gt;= 0) {</a>
<a name="ln276">    options[opt_idx].def_val = buf;</a>
<a name="ln277">    options[opt_idx].flags |= P_DEF_ALLOCED;</a>
<a name="ln278">  } else {</a>
<a name="ln279">    xfree(buf);           // cannot happen</a>
<a name="ln280">  }</a>
<a name="ln281">  xfree(cdpath);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">/// Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln285">/// If option_expand() returns non-NULL the variable is expanded.  This can</a>
<a name="ln286">/// only happen for non-indirect options.</a>
<a name="ln287">/// Also set the default to the expanded value, so &quot;:set&quot; does not list</a>
<a name="ln288">/// them.</a>
<a name="ln289">/// Don't set the P_ALLOCED flag, because we don't want to free the</a>
<a name="ln290">/// default.</a>
<a name="ln291">static void set_init_expand_env(void)</a>
<a name="ln292">{</a>
<a name="ln293">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln294">    vimoption_T *opt = &amp;options[opt_idx];</a>
<a name="ln295">    if (opt-&gt;flags &amp; P_NO_DEF_EXP) {</a>
<a name="ln296">      continue;</a>
<a name="ln297">    }</a>
<a name="ln298">    char *p;</a>
<a name="ln299">    if ((opt-&gt;flags &amp; P_GETTEXT) &amp;&amp; opt-&gt;var != NULL) {</a>
<a name="ln300">      p = _(*(char **)opt-&gt;var);</a>
<a name="ln301">    } else {</a>
<a name="ln302">      p = option_expand(opt_idx, NULL);</a>
<a name="ln303">    }</a>
<a name="ln304">    if (p != NULL) {</a>
<a name="ln305">      p = xstrdup(p);</a>
<a name="ln306">      *(char **)opt-&gt;var = p;</a>
<a name="ln307">      if (opt-&gt;flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln308">        xfree(opt-&gt;def_val);</a>
<a name="ln309">      }</a>
<a name="ln310">      opt-&gt;def_val = p;</a>
<a name="ln311">      opt-&gt;flags |= P_DEF_ALLOCED;</a>
<a name="ln312">    }</a>
<a name="ln313">  }</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">/// Initialize the encoding used for &quot;default&quot; in 'fileencodings'.</a>
<a name="ln317">static void set_init_fenc_default(void)</a>
<a name="ln318">{</a>
<a name="ln319">  // enc_locale() will try to find the encoding of the current locale.</a>
<a name="ln320">  // This will be used when &quot;default&quot; is used as encoding specifier</a>
<a name="ln321">  // in 'fileencodings'.</a>
<a name="ln322">  char *p = enc_locale();</a>
<a name="ln323">  if (p == NULL) {</a>
<a name="ln324">    // Use utf-8 as &quot;default&quot; if locale encoding can't be detected.</a>
<a name="ln325">    p = xmemdupz(S_LEN(&quot;utf-8&quot;));</a>
<a name="ln326">  }</a>
<a name="ln327">  fenc_default = p;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/// Initialize the options, first part.</a>
<a name="ln331">///</a>
<a name="ln332">/// Called only once from main(), just after creating the first buffer.</a>
<a name="ln333">/// If &quot;clean_arg&quot; is true, Nvim was started with --clean.</a>
<a name="ln334">///</a>
<a name="ln335">/// NOTE: ELOG() etc calls are not allowed here, as log location depends on</a>
<a name="ln336">/// env var expansion which depends on expression evaluation and other</a>
<a name="ln337">/// editor state initialized here. Do logging in set_init_2 or later.</a>
<a name="ln338">void set_init_1(bool clean_arg)</a>
<a name="ln339">{</a>
<a name="ln340">  langmap_init();</a>
<a name="ln341"> </a>
<a name="ln342">  set_init_default_shell();</a>
<a name="ln343">  set_init_default_backupskip();</a>
<a name="ln344">  set_init_default_cdpath();</a>
<a name="ln345"> </a>
<a name="ln346">  char *backupdir = stdpaths_user_state_subpath(&quot;backup&quot;, 2, true);</a>
<a name="ln347">  const size_t backupdir_len = strlen(backupdir);</a>
<a name="ln348">  backupdir = xrealloc(backupdir, backupdir_len + 3);</a>
<a name="ln349">  memmove(backupdir + 2, backupdir, backupdir_len + 1);</a>
<a name="ln350">  memmove(backupdir, &quot;.,&quot;, 2);</a>
<a name="ln351">  set_string_default(&quot;backupdir&quot;, backupdir, true);</a>
<a name="ln352">  set_string_default(&quot;viewdir&quot;, stdpaths_user_state_subpath(&quot;view&quot;, 2, true),</a>
<a name="ln353">                     true);</a>
<a name="ln354">  set_string_default(&quot;directory&quot;, stdpaths_user_state_subpath(&quot;swap&quot;, 2, true),</a>
<a name="ln355">                     true);</a>
<a name="ln356">  set_string_default(&quot;undodir&quot;, stdpaths_user_state_subpath(&quot;undo&quot;, 2, true),</a>
<a name="ln357">                     true);</a>
<a name="ln358">  // Set default for &amp;runtimepath. All necessary expansions are performed in</a>
<a name="ln359">  // this function.</a>
<a name="ln360">  char *rtp = runtimepath_default(clean_arg);</a>
<a name="ln361">  if (rtp) {</a>
<a name="ln362">    set_string_default(&quot;runtimepath&quot;, rtp, true);</a>
<a name="ln363">    // Make a copy of 'rtp' for 'packpath'</a>
<a name="ln364">    set_string_default(&quot;packpath&quot;, rtp, false);</a>
<a name="ln365">    rtp = NULL;  // ownership taken</a>
<a name="ln366">  }</a>
<a name="ln367"> </a>
<a name="ln368">  // Set all the options (except the terminal options) to their default</a>
<a name="ln369">  // value.  Also set the global value for local options.</a>
<a name="ln370">  set_options_default(0);</a>
<a name="ln371"> </a>
<a name="ln372">  curbuf-&gt;b_p_initialized = true;</a>
<a name="ln373">  curbuf-&gt;b_p_ar = -1;          // no local 'autoread' value</a>
<a name="ln374">  curbuf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln375">  check_buf_options(curbuf);</a>
<a name="ln376">  check_win_options(curwin);</a>
<a name="ln377">  check_options();</a>
<a name="ln378"> </a>
<a name="ln379">  // Set all options to their default value</a>
<a name="ln380">  set_options_default(OPT_FREE);</a>
<a name="ln381"> </a>
<a name="ln382">  // set 'laststatus'</a>
<a name="ln383">  last_status(false);</a>
<a name="ln384"> </a>
<a name="ln385">  // Must be before option_expand(), because that one needs vim_isIDc()</a>
<a name="ln386">  didset_options();</a>
<a name="ln387"> </a>
<a name="ln388">  // Use the current chartab for the generic chartab. This is not in</a>
<a name="ln389">  // didset_options() because it only depends on 'encoding'.</a>
<a name="ln390">  init_spell_chartab();</a>
<a name="ln391"> </a>
<a name="ln392">  // Expand environment variables and things like &quot;~&quot; for the defaults.</a>
<a name="ln393">  set_init_expand_env();</a>
<a name="ln394"> </a>
<a name="ln395">  save_file_ff(curbuf);         // Buffer is unchanged</a>
<a name="ln396"> </a>
<a name="ln397">  // Detect use of mlterm.</a>
<a name="ln398">  // Mlterm is a terminal emulator akin to xterm that has some special</a>
<a name="ln399">  // abilities (bidi namely).</a>
<a name="ln400">  // NOTE: mlterm's author is being asked to 'set' a variable</a>
<a name="ln401">  //       instead of an environment variable due to inheritance.</a>
<a name="ln402">  if (os_env_exists(&quot;MLTERM&quot;)) {</a>
<a name="ln403">    set_option_value_give_err(&quot;tbidi&quot;, BOOLEAN_OPTVAL(true), 0);</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  didset_options2();</a>
<a name="ln407"> </a>
<a name="ln408">  lang_init();</a>
<a name="ln409">  set_init_fenc_default();</a>
<a name="ln410"> </a>
<a name="ln411">#ifdef HAVE_WORKING_LIBINTL</a>
<a name="ln412">  // GNU gettext 0.10.37 supports this feature: set the codeset used for</a>
<a name="ln413">  // translated messages independently from the current locale.</a>
<a name="ln414">  (void)bind_textdomain_codeset(PROJECT_NAME, p_enc);</a>
<a name="ln415">#endif</a>
<a name="ln416"> </a>
<a name="ln417">  // Set the default for 'helplang'.</a>
<a name="ln418">  set_helplang_default(get_mess_lang());</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">/// Set an option to its default value.</a>
<a name="ln422">/// This does not take care of side effects!</a>
<a name="ln423">///</a>
<a name="ln424">/// @param opt_flags OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln425">static void set_option_default(const int opt_idx, int opt_flags)</a>
<a name="ln426">{</a>
<a name="ln427">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln428"> </a>
<a name="ln429">  // pointer to variable for current option</a>
<a name="ln430">  vimoption_T *opt = &amp;options[opt_idx];</a>
<a name="ln431">  void *varp = get_varp_scope(opt, both ? OPT_LOCAL : opt_flags);</a>
<a name="ln432">  uint32_t flags = opt-&gt;flags;</a>
<a name="ln433">  if (varp != NULL) {       // skip hidden option, nothing to do for it</a>
<a name="ln434">    if (flags &amp; P_STRING) {</a>
<a name="ln435">      // Use set_string_option_direct() for local options to handle</a>
<a name="ln436">      // freeing and allocating the value.</a>
<a name="ln437">      if (opt-&gt;indir != PV_NONE) {</a>
<a name="ln438">        set_string_option_direct(NULL, opt_idx, opt-&gt;def_val, opt_flags, 0);</a>
<a name="ln439">      } else {</a>
<a name="ln440">        if ((opt_flags &amp; OPT_FREE) &amp;&amp; (flags &amp; P_ALLOCED)) {</a>
<a name="ln441">          free_string_option(*(char **)(varp));</a>
<a name="ln442">        }</a>
<a name="ln443">        *(char **)varp = opt-&gt;def_val;</a>
<a name="ln444">        opt-&gt;flags &amp;= ~P_ALLOCED;</a>
<a name="ln445">      }</a>
<a name="ln446">    } else if (flags &amp; P_NUM) {</a>
<a name="ln447">      if (opt-&gt;indir == PV_SCROLL) {</a>
<a name="ln448">        win_comp_scroll(curwin);</a>
<a name="ln449">      } else {</a>
<a name="ln450">        OptInt def_val = (OptInt)(intptr_t)opt-&gt;def_val;</a>
<a name="ln451">        if ((OptInt *)varp == &amp;curwin-&gt;w_p_so</a>
<a name="ln452">            || (OptInt *)varp == &amp;curwin-&gt;w_p_siso) {</a>
<a name="ln453">          // 'scrolloff' and 'sidescrolloff' local values have a</a>
<a name="ln454">          // different default value than the global default.</a>
<a name="ln455">          *(OptInt *)varp = -1;</a>
<a name="ln456">        } else {</a>
<a name="ln457">          *(OptInt *)varp = def_val;</a>
<a name="ln458">        }</a>
<a name="ln459">        // May also set global value for local option.</a>
<a name="ln460">        if (both) {</a>
<a name="ln461">          *(OptInt *)get_varp_scope(opt, OPT_GLOBAL) = def_val;</a>
<a name="ln462">        }</a>
<a name="ln463">      }</a>
<a name="ln464">    } else {  // P_BOOL</a>
<a name="ln465">      *(int *)varp = (int)(intptr_t)opt-&gt;def_val;</a>
<a name="ln466">#ifdef UNIX</a>
<a name="ln467">      // 'modeline' defaults to off for root</a>
<a name="ln468">      if (opt-&gt;indir == PV_ML &amp;&amp; getuid() == ROOT_UID) {</a>
<a name="ln469">        *(int *)varp = false;</a>
<a name="ln470">      }</a>
<a name="ln471">#endif</a>
<a name="ln472">      // May also set global value for local option.</a>
<a name="ln473">      if (both) {</a>
<a name="ln474">        *(int *)get_varp_scope(opt, OPT_GLOBAL) =</a>
<a name="ln475">          *(int *)varp;</a>
<a name="ln476">      }</a>
<a name="ln477">    }</a>
<a name="ln478"> </a>
<a name="ln479">    // The default value is not insecure.</a>
<a name="ln480">    uint32_t *flagsp = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln481">    *flagsp = *flagsp &amp; ~P_INSECURE;</a>
<a name="ln482">  }</a>
<a name="ln483"> </a>
<a name="ln484">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/// Set all options (except terminal options) to their default value.</a>
<a name="ln488">///</a>
<a name="ln489">/// @param opt_flags  OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln490">static void set_options_default(int opt_flags)</a>
<a name="ln491">{</a>
<a name="ln492">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln493">    if (!(options[i].flags &amp; P_NODEFAULT)) {</a>
<a name="ln494">      set_option_default(i, opt_flags);</a>
<a name="ln495">    }</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  // The 'scroll' option must be computed for all windows.</a>
<a name="ln499">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln500">    win_comp_scroll(wp);</a>
<a name="ln501">  }</a>
<a name="ln502"> </a>
<a name="ln503">  parse_cino(curbuf);</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">/// Set the Vi-default value of a string option.</a>
<a name="ln507">/// Used for 'sh', 'backupskip' and 'term'.</a>
<a name="ln508">///</a>
<a name="ln509">/// @param name The name of the option</a>
<a name="ln510">/// @param val The value of the option</a>
<a name="ln511">/// @param allocated If true, do not copy default as it was already allocated.</a>
<a name="ln512">static void set_string_default(const char *name, char *val, bool allocated)</a>
<a name="ln513">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln514">{</a>
<a name="ln515">  int opt_idx = findoption(name);</a>
<a name="ln516">  if (opt_idx &gt;= 0) {</a>
<a name="ln517">    vimoption_T *opt = &amp;options[opt_idx];</a>
<a name="ln518">    if (opt-&gt;flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln519">      xfree(opt-&gt;def_val);</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">    opt-&gt;def_val = allocated ? val : xstrdup(val);</a>
<a name="ln523">    opt-&gt;flags |= P_DEF_ALLOCED;</a>
<a name="ln524">  }</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">/// For an option value that contains comma separated items, find &quot;newval&quot; in</a>
<a name="ln528">/// &quot;origval&quot;.  Return NULL if not found.</a>
<a name="ln529">static char *find_dup_item(char *origval, const char *newval, uint32_t flags)</a>
<a name="ln530">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln531">{</a>
<a name="ln532">  if (origval == NULL) {</a>
<a name="ln533">    return NULL;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  int bs = 0;</a>
<a name="ln537"> </a>
<a name="ln538">  const size_t newlen = strlen(newval);</a>
<a name="ln539">  for (char *s = origval; *s != NUL; s++) {</a>
<a name="ln540">    if ((!(flags &amp; P_COMMA) || s == origval || (s[-1] == ',' &amp;&amp; !(bs &amp; 1)))</a>
<a name="ln541">        &amp;&amp; strncmp(s, newval, newlen) == 0</a>
<a name="ln542">        &amp;&amp; (!(flags &amp; P_COMMA) || s[newlen] == ',' || s[newlen] == NUL)) {</a>
<a name="ln543">      return s;</a>
<a name="ln544">    }</a>
<a name="ln545">    // Count backslashes.  Only a comma with an even number of backslashes</a>
<a name="ln546">    // or a single backslash preceded by a comma before it is recognized as</a>
<a name="ln547">    // a separator.</a>
<a name="ln548">    if ((s &gt; origval + 1 &amp;&amp; s[-1] == '\\' &amp;&amp; s[-2] != ',')</a>
<a name="ln549">        || (s == origval + 1 &amp;&amp; s[-1] == '\\')) {</a>
<a name="ln550">      bs++;</a>
<a name="ln551">    } else {</a>
<a name="ln552">      bs = 0;</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555">  return NULL;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/// Set the Vi-default value of a number option.</a>
<a name="ln559">/// Used for 'lines' and 'columns'.</a>
<a name="ln560">void set_number_default(char *name, long val)</a>
<a name="ln561">{</a>
<a name="ln562">  int opt_idx = findoption(name);</a>
<a name="ln563">  if (opt_idx &gt;= 0) {</a>
<a name="ln564">    options[opt_idx].def_val = (void *)(intptr_t)val;</a>
<a name="ln565">  }</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">#if defined(EXITFREE)</a>
<a name="ln569">/// Free all options.</a>
<a name="ln570">void free_all_options(void)</a>
<a name="ln571">{</a>
<a name="ln572">  for (int i = 0; options[i].fullname; i++) {</a>
<a name="ln573">    if (options[i].indir == PV_NONE) {</a>
<a name="ln574">      // global option: free value and default value.</a>
<a name="ln575">      if ((options[i].flags &amp; P_ALLOCED) &amp;&amp; options[i].var != NULL) {</a>
<a name="ln576">        free_string_option(*(char **)options[i].var);</a>
<a name="ln577">      }</a>
<a name="ln578">      if (options[i].flags &amp; P_DEF_ALLOCED) {</a>
<a name="ln579">        free_string_option(options[i].def_val);</a>
<a name="ln580">      }</a>
<a name="ln581">    } else if (options[i].var != VAR_WIN &amp;&amp; (options[i].flags &amp; P_STRING)) {</a>
<a name="ln582">      // buffer-local option: free global value</a>
<a name="ln583">      clear_string_option((char **)options[i].var);</a>
<a name="ln584">    }</a>
<a name="ln585">  }</a>
<a name="ln586">  free_operatorfunc_option();</a>
<a name="ln587">  free_tagfunc_option();</a>
<a name="ln588">}</a>
<a name="ln589">#endif</a>
<a name="ln590"> </a>
<a name="ln591">/// Initialize the options, part two: After getting Rows and Columns.</a>
<a name="ln592">void set_init_2(bool headless)</a>
<a name="ln593">{</a>
<a name="ln594">  // set in set_init_1 but logging is not allowed there</a>
<a name="ln595">  ILOG(&quot;startup runtimepath/packpath value: %s&quot;, p_rtp);</a>
<a name="ln596"> </a>
<a name="ln597">  // 'scroll' defaults to half the window height. The stored default is zero,</a>
<a name="ln598">  // which results in the actual value computed from the window height.</a>
<a name="ln599">  int idx = findoption(&quot;scroll&quot;);</a>
<a name="ln600">  if (idx &gt;= 0 &amp;&amp; !(options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln601">    set_option_default(idx, OPT_LOCAL);</a>
<a name="ln602">  }</a>
<a name="ln603">  comp_col();</a>
<a name="ln604"> </a>
<a name="ln605">  // 'window' is only for backwards compatibility with Vi.</a>
<a name="ln606">  // Default is Rows - 1.</a>
<a name="ln607">  if (!option_was_set(&quot;window&quot;)) {</a>
<a name="ln608">    p_window = Rows - 1;</a>
<a name="ln609">  }</a>
<a name="ln610">  set_number_default(&quot;window&quot;, Rows - 1);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/// Initialize the options, part three: After reading the .vimrc</a>
<a name="ln614">void set_init_3(void)</a>
<a name="ln615">{</a>
<a name="ln616">  parse_shape_opt(SHAPE_CURSOR);   // set cursor shapes from 'guicursor'</a>
<a name="ln617"> </a>
<a name="ln618">  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.</a>
<a name="ln619">  // This is done after other initializations, where 'shell' might have been</a>
<a name="ln620">  // set, but only if they have not been set before.</a>
<a name="ln621">  int idx_srr = findoption(&quot;srr&quot;);</a>
<a name="ln622">  int do_srr = (idx_srr &lt; 0)</a>
<a name="ln623">    ? false</a>
<a name="ln624">    : !(options[idx_srr].flags &amp; P_WAS_SET);</a>
<a name="ln625">  int idx_sp = findoption(&quot;sp&quot;);</a>
<a name="ln626">  int do_sp = (idx_sp &lt; 0)</a>
<a name="ln627">    ? false</a>
<a name="ln628">    : !(options[idx_sp].flags &amp; P_WAS_SET);</a>
<a name="ln629"> </a>
<a name="ln630">  size_t len = 0;</a>
<a name="ln631">  char *p = (char *)invocation_path_tail(p_sh, &amp;len);</a>
<a name="ln632">  p = xstrnsave(p, len);</a>
<a name="ln633"> </a>
<a name="ln634">  {</a>
<a name="ln635">    //</a>
<a name="ln636">    // Default for p_sp is &quot;| tee&quot;, for p_srr is &quot;&gt;&quot;.</a>
<a name="ln637">    // For known shells it is changed here to include stderr.</a>
<a name="ln638">    //</a>
<a name="ln639">    if (path_fnamecmp(p, &quot;csh&quot;) == 0</a>
<a name="ln640">        || path_fnamecmp(p, &quot;tcsh&quot;) == 0) {</a>
<a name="ln641">      if (do_sp) {</a>
<a name="ln642">        p_sp = &quot;|&amp; tee&quot;;</a>
<a name="ln643">        options[idx_sp].def_val = p_sp;</a>
<a name="ln644">      }</a>
<a name="ln645">      if (do_srr) {</a>
<a name="ln646">        p_srr = &quot;&gt;&amp;&quot;;</a>
<a name="ln647">        options[idx_srr].def_val = p_srr;</a>
<a name="ln648">      }</a>
<a name="ln649">    } else if (path_fnamecmp(p, &quot;sh&quot;) == 0</a>
<a name="ln650">               || path_fnamecmp(p, &quot;ksh&quot;) == 0</a>
<a name="ln651">               || path_fnamecmp(p, &quot;mksh&quot;) == 0</a>
<a name="ln652">               || path_fnamecmp(p, &quot;pdksh&quot;) == 0</a>
<a name="ln653">               || path_fnamecmp(p, &quot;zsh&quot;) == 0</a>
<a name="ln654">               || path_fnamecmp(p, &quot;zsh-beta&quot;) == 0</a>
<a name="ln655">               || path_fnamecmp(p, &quot;bash&quot;) == 0</a>
<a name="ln656">               || path_fnamecmp(p, &quot;fish&quot;) == 0</a>
<a name="ln657">               || path_fnamecmp(p, &quot;ash&quot;) == 0</a>
<a name="ln658">               || path_fnamecmp(p, &quot;dash&quot;) == 0) {</a>
<a name="ln659">      // Always use POSIX shell style redirection if we reach this</a>
<a name="ln660">      if (do_sp) {</a>
<a name="ln661">        p_sp = &quot;2&gt;&amp;1| tee&quot;;</a>
<a name="ln662">        options[idx_sp].def_val = p_sp;</a>
<a name="ln663">      }</a>
<a name="ln664">      if (do_srr) {</a>
<a name="ln665">        p_srr = &quot;&gt;%s 2&gt;&amp;1&quot;;</a>
<a name="ln666">        options[idx_srr].def_val = p_srr;</a>
<a name="ln667">      }</a>
<a name="ln668">    }</a>
<a name="ln669">    xfree(p);</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  if (buf_is_empty(curbuf)) {</a>
<a name="ln673">    int idx_ffs = findoption_len(S_LEN(&quot;ffs&quot;));</a>
<a name="ln674"> </a>
<a name="ln675">    // Apply the first entry of 'fileformats' to the initial buffer.</a>
<a name="ln676">    if (idx_ffs &gt;= 0 &amp;&amp; (options[idx_ffs].flags &amp; P_WAS_SET)) {</a>
<a name="ln677">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln678">    }</a>
<a name="ln679">  }</a>
<a name="ln680"> </a>
<a name="ln681">  set_title_defaults();  // 'title', 'icon'</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/// When 'helplang' is still at its default value, set it to &quot;lang&quot;.</a>
<a name="ln685">/// Only the first two characters of &quot;lang&quot; are used.</a>
<a name="ln686">void set_helplang_default(const char *lang)</a>
<a name="ln687">{</a>
<a name="ln688">  if (lang == NULL) {</a>
<a name="ln689">    return;</a>
<a name="ln690">  }</a>
<a name="ln691"> </a>
<a name="ln692">  const size_t lang_len = strlen(lang);</a>
<a name="ln693">  if (lang_len &lt; 2) {  // safety check</a>
<a name="ln694">    return;</a>
<a name="ln695">  }</a>
<a name="ln696">  int idx = findoption(&quot;hlg&quot;);</a>
<a name="ln697">  if (idx &lt; 0 || (options[idx].flags &amp; P_WAS_SET)) {</a>
<a name="ln698">    return;</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">  if (options[idx].flags &amp; P_ALLOCED) {</a>
<a name="ln702">    free_string_option(p_hlg);</a>
<a name="ln703">  }</a>
<a name="ln704">  p_hlg = xmemdupz(lang, lang_len);</a>
<a name="ln705">  // zh_CN becomes &quot;cn&quot;, zh_TW becomes &quot;tw&quot;.</a>
<a name="ln706">  if (STRNICMP(p_hlg, &quot;zh_&quot;, 3) == 0 &amp;&amp; strlen(p_hlg) &gt;= 5) {</a>
<a name="ln707">    p_hlg[0] = (char)TOLOWER_ASC(p_hlg[3]);</a>
<a name="ln708">    p_hlg[1] = (char)TOLOWER_ASC(p_hlg[4]);</a>
<a name="ln709">  } else if (strlen(p_hlg) &gt;= 1 &amp;&amp; *p_hlg == 'C') {</a>
<a name="ln710">    // any C like setting, such as C.UTF-8, becomes &quot;en&quot;</a>
<a name="ln711">    p_hlg[0] = 'e';</a>
<a name="ln712">    p_hlg[1] = 'n';</a>
<a name="ln713">  }</a>
<a name="ln714">  p_hlg[2] = NUL;</a>
<a name="ln715">  options[idx].flags |= P_ALLOCED;</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">/// 'title' and 'icon' only default to true if they have not been set or reset</a>
<a name="ln719">/// in .vimrc and we can read the old value.</a>
<a name="ln720">/// When 'title' and 'icon' have been reset in .vimrc, we won't even check if</a>
<a name="ln721">/// they can be reset.  This reduces startup time when using X on a remote</a>
<a name="ln722">/// machine.</a>
<a name="ln723">void set_title_defaults(void)</a>
<a name="ln724">{</a>
<a name="ln725">  // If GUI is (going to be) used, we can always set the window title and</a>
<a name="ln726">  // icon name.  Saves a bit of time, because the X11 display server does</a>
<a name="ln727">  // not need to be contacted.</a>
<a name="ln728">  int idx1 = findoption(&quot;title&quot;);</a>
<a name="ln729">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln730">    options[idx1].def_val = 0;</a>
<a name="ln731">    p_title = 0;</a>
<a name="ln732">  }</a>
<a name="ln733">  idx1 = findoption(&quot;icon&quot;);</a>
<a name="ln734">  if (idx1 &gt;= 0 &amp;&amp; !(options[idx1].flags &amp; P_WAS_SET)) {</a>
<a name="ln735">    options[idx1].def_val = 0;</a>
<a name="ln736">    p_icon = 0;</a>
<a name="ln737">  }</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">void ex_set(exarg_T *eap)</a>
<a name="ln741">{</a>
<a name="ln742">  int flags = 0;</a>
<a name="ln743"> </a>
<a name="ln744">  if (eap-&gt;cmdidx == CMD_setlocal) {</a>
<a name="ln745">    flags = OPT_LOCAL;</a>
<a name="ln746">  } else if (eap-&gt;cmdidx == CMD_setglobal) {</a>
<a name="ln747">    flags = OPT_GLOBAL;</a>
<a name="ln748">  }</a>
<a name="ln749">  if (eap-&gt;forceit) {</a>
<a name="ln750">    flags |= OPT_ONECOLUMN;</a>
<a name="ln751">  }</a>
<a name="ln752">  (void)do_set(eap-&gt;arg, flags);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">static void do_set_bool(int opt_idx, int opt_flags, set_prefix_T prefix, int nextchar,</a>
<a name="ln756">                        const void *varp, const char **errmsg)</a>
<a name="ln757">{</a>
<a name="ln758">  varnumber_T value;</a>
<a name="ln759"> </a>
<a name="ln760">  // &quot;:set opt!&quot;: invert</a>
<a name="ln761">  // &quot;:set opt&amp;&quot;: reset to default value</a>
<a name="ln762">  // &quot;:set opt&lt;&quot;: reset to global value</a>
<a name="ln763">  if (nextchar == '!') {</a>
<a name="ln764">    value = *(int *)(varp) ^ 1;</a>
<a name="ln765">  } else if (nextchar == '&amp;') {</a>
<a name="ln766">    value = (int)(intptr_t)options[opt_idx].def_val;</a>
<a name="ln767">  } else if (nextchar == '&lt;') {</a>
<a name="ln768">    // For 'autoread' -1 means to use global value.</a>
<a name="ln769">    if ((int *)varp == &amp;curbuf-&gt;b_p_ar &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln770">      value = -1;</a>
<a name="ln771">    } else {</a>
<a name="ln772">      value = *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln773">    }</a>
<a name="ln774">  } else {</a>
<a name="ln775">    // &quot;:set invopt&quot;: invert</a>
<a name="ln776">    // &quot;:set opt&quot; or &quot;:set noopt&quot;: set or reset</a>
<a name="ln777">    if (prefix == PREFIX_INV) {</a>
<a name="ln778">      value = *(int *)varp ^ 1;</a>
<a name="ln779">    } else {</a>
<a name="ln780">      value = prefix == PREFIX_NO ? 0 : 1;</a>
<a name="ln781">    }</a>
<a name="ln782">  }</a>
<a name="ln783"> </a>
<a name="ln784">  *errmsg = set_bool_option(opt_idx, (void *)varp, (int)value, opt_flags);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static void do_set_num(int opt_idx, int opt_flags, char **argp, int nextchar, const set_op_T op,</a>
<a name="ln788">                       const void *varp, char *errbuf, size_t errbuflen, const char **errmsg)</a>
<a name="ln789">{</a>
<a name="ln790">  varnumber_T value;</a>
<a name="ln791">  char *arg = *argp;</a>
<a name="ln792"> </a>
<a name="ln793">  // Different ways to set a number option:</a>
<a name="ln794">  // &amp;            set to default value</a>
<a name="ln795">  // &lt;            set to global value</a>
<a name="ln796">  // &lt;xx&gt;         accept special key codes for 'wildchar'</a>
<a name="ln797">  // c            accept any non-digit for 'wildchar'</a>
<a name="ln798">  // [-]0-9       set number</a>
<a name="ln799">  // other        error</a>
<a name="ln800">  arg++;</a>
<a name="ln801">  if (nextchar == '&amp;') {</a>
<a name="ln802">    value = (long)(intptr_t)options[opt_idx].def_val;</a>
<a name="ln803">  } else if (nextchar == '&lt;') {</a>
<a name="ln804">    if ((OptInt *)varp == &amp;curbuf-&gt;b_p_ul &amp;&amp; opt_flags == OPT_LOCAL) {</a>
<a name="ln805">      // for 'undolevels' NO_LOCAL_UNDOLEVEL means using the global value</a>
<a name="ln806">      value = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln807">    } else if (opt_flags == OPT_LOCAL</a>
<a name="ln808">               &amp;&amp; ((OptInt *)varp == &amp;curwin-&gt;w_p_siso</a>
<a name="ln809">                   || (OptInt *)varp == &amp;curwin-&gt;w_p_so)) {</a>
<a name="ln810">      // for 'scrolloff'/'sidescrolloff' -1 means using the global value</a>
<a name="ln811">      value = -1;</a>
<a name="ln812">    } else {</a>
<a name="ln813">      value = *(OptInt *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln814">    }</a>
<a name="ln815">  } else if (((OptInt *)varp == &amp;p_wc</a>
<a name="ln816">              || (OptInt *)varp == &amp;p_wcm)</a>
<a name="ln817">             &amp;&amp; (*arg == '&lt;'</a>
<a name="ln818">                 || *arg == '^'</a>
<a name="ln819">                 || (*arg != NUL &amp;&amp; (!arg[1] || ascii_iswhite(arg[1]))</a>
<a name="ln820">                     &amp;&amp; !ascii_isdigit(*arg)))) {</a>
<a name="ln821">    value = string_to_key(arg);</a>
<a name="ln822">    if (value == 0 &amp;&amp; (OptInt *)varp != &amp;p_wcm) {</a>
<a name="ln823">      *errmsg = e_invarg;</a>
<a name="ln824">      return;</a>
<a name="ln825">    }</a>
<a name="ln826">  } else if (*arg == '-' || ascii_isdigit(*arg)) {</a>
<a name="ln827">    int i;</a>
<a name="ln828">    // Allow negative, octal and hex numbers.</a>
<a name="ln829">    vim_str2nr(arg, NULL, &amp;i, STR2NR_ALL, &amp;value, NULL, 0, true, NULL);</a>
<a name="ln830">    if (i == 0 || (arg[i] != NUL &amp;&amp; !ascii_iswhite(arg[i]))) {</a>
<a name="ln831">      *errmsg = e_number_required_after_equal;</a>
<a name="ln832">      return;</a>
<a name="ln833">    }</a>
<a name="ln834">  } else {</a>
<a name="ln835">    *errmsg = e_number_required_after_equal;</a>
<a name="ln836">    return;</a>
<a name="ln837">  }</a>
<a name="ln838"> </a>
<a name="ln839">  if (op == OP_ADDING) {</a>
<a name="ln840">    value = *(OptInt *)varp + value;</a>
<a name="ln841">  }</a>
<a name="ln842">  if (op == OP_PREPENDING) {</a>
<a name="ln843">    value = *(OptInt *)varp * value;</a>
<a name="ln844">  }</a>
<a name="ln845">  if (op == OP_REMOVING) {</a>
<a name="ln846">    value = *(OptInt *)varp - value;</a>
<a name="ln847">  }</a>
<a name="ln848">  *errmsg = set_num_option(opt_idx, (void *)varp, (long)value,</a>
<a name="ln849">                           errbuf, errbuflen, opt_flags);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">/// Get the default value for a string option.</a>
<a name="ln853">static char *stropt_get_default_val(int opt_idx, uint64_t flags)</a>
<a name="ln854">{</a>
<a name="ln855">  char *newval = options[opt_idx].def_val;</a>
<a name="ln856">  // expand environment variables and ~ since the default value was</a>
<a name="ln857">  // already expanded, only required when an environment variable was set</a>
<a name="ln858">  // later</a>
<a name="ln859">  if (newval == NULL) {</a>
<a name="ln860">    newval = empty_option;</a>
<a name="ln861">  } else if (!(options[opt_idx].flags &amp; P_NO_DEF_EXP)) {</a>
<a name="ln862">    char *s = option_expand(opt_idx, newval);</a>
<a name="ln863">    if (s == NULL) {</a>
<a name="ln864">      s = newval;</a>
<a name="ln865">    }</a>
<a name="ln866">    newval = xstrdup(s);</a>
<a name="ln867">  } else {</a>
<a name="ln868">    newval = xstrdup(newval);</a>
<a name="ln869">  }</a>
<a name="ln870">  return newval;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// Copy the new string value into allocated memory for the option.</a>
<a name="ln874">/// Can't use set_string_option_direct(), because we need to remove the</a>
<a name="ln875">/// backslashes.</a>
<a name="ln876">static char *stropt_copy_value(char *origval, char **argp, set_op_T op,</a>
<a name="ln877">                               uint32_t flags FUNC_ATTR_UNUSED)</a>
<a name="ln878">{</a>
<a name="ln879">  char *arg = *argp;</a>
<a name="ln880"> </a>
<a name="ln881">  // get a bit too much</a>
<a name="ln882">  size_t newlen = strlen(arg) + 1;</a>
<a name="ln883">  if (op != OP_NONE) {</a>
<a name="ln884">    newlen += strlen(origval) + 1;</a>
<a name="ln885">  }</a>
<a name="ln886">  char *newval = xmalloc(newlen);</a>
<a name="ln887">  char *s = newval;</a>
<a name="ln888"> </a>
<a name="ln889">  // Copy the string, skip over escaped chars.</a>
<a name="ln890">  // For MS-Windows backslashes before normal file name characters</a>
<a name="ln891">  // are not removed, and keep backslash at start, for &quot;\\machine\path&quot;,</a>
<a name="ln892">  // but do remove it for &quot;\\\\machine\\path&quot;.</a>
<a name="ln893">  // The reverse is found in escape_option_str_cmdline().</a>
<a name="ln894">  while (*arg != NUL &amp;&amp; !ascii_iswhite(*arg)) {</a>
<a name="ln895">    if (*arg == '\\' &amp;&amp; arg[1] != NUL</a>
<a name="ln896">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln897">        &amp;&amp; !((flags &amp; P_EXPAND)</a>
<a name="ln898">             &amp;&amp; vim_isfilec((uint8_t)arg[1])</a>
<a name="ln899">             &amp;&amp; !ascii_iswhite(arg[1])</a>
<a name="ln900">             &amp;&amp; (arg[1] != '\\'</a>
<a name="ln901">                 || (s == newval &amp;&amp; arg[2] != '\\')))</a>
<a name="ln902">#endif</a>
<a name="ln903">        ) {</a>
<a name="ln904">      arg++;  // remove backslash</a>
<a name="ln905">    }</a>
<a name="ln906">    int i = utfc_ptr2len(arg);</a>
<a name="ln907">    if (i &gt; 1) {</a>
<a name="ln908">      // copy multibyte char</a>
<a name="ln909">      memmove(s, arg, (size_t)i);</a>
<a name="ln910">      arg += i;</a>
<a name="ln911">      s += i;</a>
<a name="ln912">    } else {</a>
<a name="ln913">      *s++ = *arg++;</a>
<a name="ln914">    }</a>
<a name="ln915">  }</a>
<a name="ln916">  *s = NUL;</a>
<a name="ln917"> </a>
<a name="ln918">  *argp = arg;</a>
<a name="ln919">  return newval;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">/// Expand environment variables and ~ in string option value 'newval'.</a>
<a name="ln923">static char *stropt_expand_envvar(int opt_idx, char *origval, char *newval, set_op_T op)</a>
<a name="ln924">{</a>
<a name="ln925">  char *s = option_expand(opt_idx, newval);</a>
<a name="ln926">  if (s == NULL) {</a>
<a name="ln927">    return newval;</a>
<a name="ln928">  }</a>
<a name="ln929"> </a>
<a name="ln930">  xfree(newval);</a>
<a name="ln931">  uint32_t newlen = (unsigned)strlen(s) + 1;</a>
<a name="ln932">  if (op != OP_NONE) {</a>
<a name="ln933">    newlen += (unsigned)strlen(origval) + 1;</a>
<a name="ln934">  }</a>
<a name="ln935">  newval = xmalloc(newlen);</a>
<a name="ln936">  STRCPY(newval, s);</a>
<a name="ln937"> </a>
<a name="ln938">  return newval;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">/// Concatenate the original and new values of a string option, adding a &quot;,&quot; if</a>
<a name="ln942">/// needed.</a>
<a name="ln943">static void stropt_concat_with_comma(char *origval, char *newval, set_op_T op, uint32_t flags)</a>
<a name="ln944">{</a>
<a name="ln945">  int len = 0;</a>
<a name="ln946">  int comma = ((flags &amp; P_COMMA) &amp;&amp; *origval != NUL &amp;&amp; *newval != NUL);</a>
<a name="ln947">  if (op == OP_ADDING) {</a>
<a name="ln948">    len = (int)strlen(origval);</a>
<a name="ln949">    // Strip a trailing comma, would get 2.</a>
<a name="ln950">    if (comma &amp;&amp; len &gt; 1</a>
<a name="ln951">        &amp;&amp; (flags &amp; P_ONECOMMA) == P_ONECOMMA</a>
<a name="ln952">        &amp;&amp; origval[len - 1] == ','</a>
<a name="ln953">        &amp;&amp; origval[len - 2] != '\\') {</a>
<a name="ln954">      len--;</a>
<a name="ln955">    }</a>
<a name="ln956">    memmove(newval + len + comma, newval, strlen(newval) + 1);</a>
<a name="ln957">    memmove(newval, origval, (size_t)len);</a>
<a name="ln958">  } else {</a>
<a name="ln959">    len = (int)strlen(newval);</a>
<a name="ln960">    STRMOVE(newval + len + comma, origval);</a>
<a name="ln961">  }</a>
<a name="ln962">  if (comma) {</a>
<a name="ln963">    newval[len] = ',';</a>
<a name="ln964">  }</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">/// Remove a value from a string option.  Copy string option value in &quot;origval&quot;</a>
<a name="ln968">/// to &quot;newval&quot; and then remove the string &quot;strval&quot; of length &quot;len&quot;.</a>
<a name="ln969">static void stropt_remove_val(char *origval, char *newval, uint32_t flags, char *strval, int len)</a>
<a name="ln970">{</a>
<a name="ln971">  // Remove newval[] from origval[]. (Note: &quot;len&quot; has been set above</a>
<a name="ln972">  // and is used here).</a>
<a name="ln973">  STRCPY(newval, origval);</a>
<a name="ln974">  if (*strval) {</a>
<a name="ln975">    // may need to remove a comma</a>
<a name="ln976">    if (flags &amp; P_COMMA) {</a>
<a name="ln977">      if (strval == origval) {</a>
<a name="ln978">        // include comma after string</a>
<a name="ln979">        if (strval[len] == ',') {</a>
<a name="ln980">          len++;</a>
<a name="ln981">        }</a>
<a name="ln982">      } else {</a>
<a name="ln983">        // include comma before string</a>
<a name="ln984">        strval--;</a>
<a name="ln985">        len++;</a>
<a name="ln986">      }</a>
<a name="ln987">    }</a>
<a name="ln988">    STRMOVE(newval + (strval - origval), strval + len);</a>
<a name="ln989">  }</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">/// Remove flags that appear twice in the string option value 'newval'.</a>
<a name="ln993">static void stropt_remove_dupflags(char *newval, uint32_t flags)</a>
<a name="ln994">{</a>
<a name="ln995">  char *s = newval;</a>
<a name="ln996">  // Remove flags that appear twice.</a>
<a name="ln997">  for (s = newval; *s;) {</a>
<a name="ln998">    // if options have P_FLAGLIST and P_ONECOMMA such as 'whichwrap'</a>
<a name="ln999">    if (flags &amp; P_ONECOMMA) {</a>
<a name="ln1000">      if (*s != ',' &amp;&amp; *(s + 1) == ','</a>
<a name="ln1001">          &amp;&amp; vim_strchr(s + 2, (uint8_t)(*s)) != NULL) {</a>
<a name="ln1002">        // Remove the duplicated value and the next comma.</a>
<a name="ln1003">        STRMOVE(s, s + 2);</a>
<a name="ln1004">        continue;</a>
<a name="ln1005">      }</a>
<a name="ln1006">    } else {</a>
<a name="ln1007">      if ((!(flags &amp; P_COMMA) || *s != ',')</a>
<a name="ln1008">          &amp;&amp; vim_strchr(s + 1, (uint8_t)(*s)) != NULL) {</a>
<a name="ln1009">        STRMOVE(s, s + 1);</a>
<a name="ln1010">        continue;</a>
<a name="ln1011">      }</a>
<a name="ln1012">    }</a>
<a name="ln1013">    s++;</a>
<a name="ln1014">  }</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">/// Get the string value specified for a &quot;:set&quot; command.  The following set</a>
<a name="ln1018">/// options are supported:</a>
<a name="ln1019">///     set {opt}&amp;</a>
<a name="ln1020">///     set {opt}&lt;</a>
<a name="ln1021">///     set {opt}={val}</a>
<a name="ln1022">///     set {opt}:{val}</a>
<a name="ln1023">static char *stropt_get_newval(int nextchar, int opt_idx, char **argp, void *varp, char *origval,</a>
<a name="ln1024">                               set_op_T *op_arg, uint32_t flags)</a>
<a name="ln1025">{</a>
<a name="ln1026">  char *arg = *argp;</a>
<a name="ln1027">  set_op_T op = *op_arg;</a>
<a name="ln1028">  char *save_arg = NULL;</a>
<a name="ln1029">  char *newval;</a>
<a name="ln1030">  char *s = NULL;</a>
<a name="ln1031">  if (nextchar == '&amp;') {  // set to default val</a>
<a name="ln1032">    newval = stropt_get_default_val(opt_idx, flags);</a>
<a name="ln1033">  } else if (nextchar == '&lt;') {  // set to global val</a>
<a name="ln1034">    newval = xstrdup(*(char **)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL));</a>
<a name="ln1035">  } else {</a>
<a name="ln1036">    arg++;  // jump to after the '=' or ':'</a>
<a name="ln1037"> </a>
<a name="ln1038">    // Set 'keywordprg' to &quot;:help&quot; if an empty</a>
<a name="ln1039">    // value was passed to :set by the user.</a>
<a name="ln1040">    if (varp == &amp;p_kp &amp;&amp; (*arg == NUL || *arg == ' ')) {</a>
<a name="ln1041">      save_arg = arg;</a>
<a name="ln1042">      arg = &quot;:help&quot;;</a>
<a name="ln1043">    }</a>
<a name="ln1044"> </a>
<a name="ln1045">    // Copy the new string into allocated memory.</a>
<a name="ln1046">    newval = stropt_copy_value(origval, &amp;arg, op, flags);</a>
<a name="ln1047"> </a>
<a name="ln1048">    // Expand environment variables and ~.</a>
<a name="ln1049">    // Don't do it when adding without inserting a comma.</a>
<a name="ln1050">    if (op == OP_NONE || (flags &amp; P_COMMA)) {</a>
<a name="ln1051">      newval = stropt_expand_envvar(opt_idx, origval, newval, op);</a>
<a name="ln1052">    }</a>
<a name="ln1053"> </a>
<a name="ln1054">    // locate newval[] in origval[] when removing it</a>
<a name="ln1055">    // and when adding to avoid duplicates</a>
<a name="ln1056">    int len = 0;</a>
<a name="ln1057">    if (op == OP_REMOVING || (flags &amp; P_NODUP)) {</a>
<a name="ln1058">      len = (int)strlen(newval);</a>
<a name="ln1059">      s = find_dup_item(origval, newval, flags);</a>
<a name="ln1060"> </a>
<a name="ln1061">      // do not add if already there</a>
<a name="ln1062">      if ((op == OP_ADDING || op == OP_PREPENDING) &amp;&amp; s != NULL) {</a>
<a name="ln1063">        op = OP_NONE;</a>
<a name="ln1064">        STRCPY(newval, origval);</a>
<a name="ln1065">      }</a>
<a name="ln1066"> </a>
<a name="ln1067">      // if no duplicate, move pointer to end of original value</a>
<a name="ln1068">      if (s == NULL) {</a>
<a name="ln1069">        s = origval + (int)strlen(origval);</a>
<a name="ln1070">      }</a>
<a name="ln1071">    }</a>
<a name="ln1072"> </a>
<a name="ln1073">    // concatenate the two strings; add a ',' if needed</a>
<a name="ln1074">    if (op == OP_ADDING || op == OP_PREPENDING) {</a>
<a name="ln1075">      stropt_concat_with_comma(origval, newval, op, flags);</a>
<a name="ln1076">    } else if (op == OP_REMOVING) {</a>
<a name="ln1077">      // Remove newval[] from origval[]. (Note: &quot;len&quot; has been set above</a>
<a name="ln1078">      // and is used here).</a>
<a name="ln1079">      stropt_remove_val(origval, newval, flags, s, len);</a>
<a name="ln1080">    }</a>
<a name="ln1081"> </a>
<a name="ln1082">    if (flags &amp; P_FLAGLIST) {</a>
<a name="ln1083">      // Remove flags that appear twice.</a>
<a name="ln1084">      stropt_remove_dupflags(newval, flags);</a>
<a name="ln1085">    }</a>
<a name="ln1086">  }</a>
<a name="ln1087"> </a>
<a name="ln1088">  if (save_arg != NULL) {</a>
<a name="ln1089">    arg = save_arg;  // arg was temporarily changed, restore it</a>
<a name="ln1090">  }</a>
<a name="ln1091">  *argp = arg;</a>
<a name="ln1092">  *op_arg = op;</a>
<a name="ln1093"> </a>
<a name="ln1094">  return newval;</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/// Part of do_set() for string options.</a>
<a name="ln1098">static void do_set_option_string(int opt_idx, int opt_flags, char **argp, int nextchar,</a>
<a name="ln1099">                                 set_op_T op_arg, uint32_t flags, void *varp_arg, char *errbuf,</a>
<a name="ln1100">                                 size_t errbuflen, bool *value_checked, const char **errmsg)</a>
<a name="ln1101">{</a>
<a name="ln1102">  vimoption_T *opt = get_option(opt_idx);</a>
<a name="ln1103"> </a>
<a name="ln1104">  set_op_T op = op_arg;</a>
<a name="ln1105">  void *varp = varp_arg;</a>
<a name="ln1106">  char *origval_l = NULL;</a>
<a name="ln1107">  char *origval_g = NULL;</a>
<a name="ln1108"> </a>
<a name="ln1109">  // When using &quot;:set opt=val&quot; for a global option</a>
<a name="ln1110">  // with a local value the local value will be</a>
<a name="ln1111">  // reset, use the global value here.</a>
<a name="ln1112">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0</a>
<a name="ln1113">      &amp;&amp; ((int)opt-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln1114">    varp = opt-&gt;var;</a>
<a name="ln1115">  }</a>
<a name="ln1116"> </a>
<a name="ln1117">  // The old value is kept until we are sure that the new value is valid.</a>
<a name="ln1118">  char *oldval = *(char **)varp;</a>
<a name="ln1119"> </a>
<a name="ln1120">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln1121">    origval_l = *(char **)get_varp_scope(opt, OPT_LOCAL);</a>
<a name="ln1122">    origval_g = *(char **)get_varp_scope(opt, OPT_GLOBAL);</a>
<a name="ln1123"> </a>
<a name="ln1124">    // A global-local string option might have an empty option as value to</a>
<a name="ln1125">    // indicate that the global value should be used.</a>
<a name="ln1126">    if (((int)opt-&gt;indir &amp; PV_BOTH) &amp;&amp; origval_l == empty_option) {</a>
<a name="ln1127">      origval_l = origval_g;</a>
<a name="ln1128">    }</a>
<a name="ln1129">  }</a>
<a name="ln1130"> </a>
<a name="ln1131">  char *origval;</a>
<a name="ln1132">  // When setting the local value of a global option, the old value may be</a>
<a name="ln1133">  // the global value.</a>
<a name="ln1134">  if (((int)opt-&gt;indir &amp; PV_BOTH) &amp;&amp; (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1135">    origval = *(char **)get_varp(opt);</a>
<a name="ln1136">  } else {</a>
<a name="ln1137">    origval = oldval;</a>
<a name="ln1138">  }</a>
<a name="ln1139"> </a>
<a name="ln1140">  // Get the new value for the option</a>
<a name="ln1141">  char *newval = stropt_get_newval(nextchar, opt_idx, argp, varp, origval, &amp;op, flags);</a>
<a name="ln1142"> </a>
<a name="ln1143">  // Set the new value.</a>
<a name="ln1144">  *(char **)(varp) = newval != NULL ? newval : empty_option;</a>
<a name="ln1145"> </a>
<a name="ln1146">  // origval may be freed by did_set_string_option(), make a copy.</a>
<a name="ln1147">  char *const saved_origval = (origval != NULL) ? xstrdup(origval) : NULL;</a>
<a name="ln1148">  char *const saved_origval_l = (origval_l != NULL) ? xstrdup(origval_l) : NULL;</a>
<a name="ln1149">  char *const saved_origval_g = (origval_g != NULL) ? xstrdup(origval_g) : NULL;</a>
<a name="ln1150"> </a>
<a name="ln1151">  // newval (and varp) may become invalid if the buffer is closed by</a>
<a name="ln1152">  // autocommands.</a>
<a name="ln1153">  char *const saved_newval = (newval != NULL) ? xstrdup(newval) : NULL;</a>
<a name="ln1154"> </a>
<a name="ln1155">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1156">  const int secure_saved = secure;</a>
<a name="ln1157"> </a>
<a name="ln1158">  // When an option is set in the sandbox, from a modeline or in secure</a>
<a name="ln1159">  // mode, then deal with side effects in secure mode.  Also when the</a>
<a name="ln1160">  // value was set with the P_INSECURE flag and is not completely</a>
<a name="ln1161">  // replaced.</a>
<a name="ln1162">  if ((opt_flags &amp; OPT_MODELINE)</a>
<a name="ln1163">      || sandbox != 0</a>
<a name="ln1164">      || (op != OP_NONE &amp;&amp; (*p &amp; P_INSECURE))) {</a>
<a name="ln1165">    secure = 1;</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  // Handle side effects, and set the global value for &quot;:set&quot; on local</a>
<a name="ln1169">  // options. Note: when setting 'syntax' or 'filetype' autocommands may</a>
<a name="ln1170">  // be triggered that can cause havoc.</a>
<a name="ln1171">  *errmsg = did_set_string_option(curbuf, curwin, opt_idx, (char **)varp, oldval,</a>
<a name="ln1172">                                  errbuf, errbuflen,</a>
<a name="ln1173">                                  opt_flags, op, value_checked);</a>
<a name="ln1174"> </a>
<a name="ln1175">  secure = secure_saved;</a>
<a name="ln1176"> </a>
<a name="ln1177">  // call autocommand after handling side effects</a>
<a name="ln1178">  if (*errmsg == NULL) {</a>
<a name="ln1179">    if (!starting) {</a>
<a name="ln1180">      trigger_optionset_string(opt_idx, opt_flags, saved_origval, saved_origval_l,</a>
<a name="ln1181">                               saved_origval_g, saved_newval);</a>
<a name="ln1182">    }</a>
<a name="ln1183">    if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln1184">      ui_call_option_set(cstr_as_string(opt-&gt;fullname),</a>
<a name="ln1185">                         CSTR_AS_OBJ(saved_newval));</a>
<a name="ln1186">    }</a>
<a name="ln1187">  }</a>
<a name="ln1188">  xfree(saved_origval);</a>
<a name="ln1189">  xfree(saved_origval_l);</a>
<a name="ln1190">  xfree(saved_origval_g);</a>
<a name="ln1191">  xfree(saved_newval);</a>
<a name="ln1192">}</a>
<a name="ln1193"> </a>
<a name="ln1194">static set_op_T get_op(const char *arg)</a>
<a name="ln1195">{</a>
<a name="ln1196">  set_op_T op = OP_NONE;</a>
<a name="ln1197">  if (*arg != NUL &amp;&amp; *(arg + 1) == '=') {</a>
<a name="ln1198">    if (*arg == '+') {</a>
<a name="ln1199">      op = OP_ADDING;          // &quot;+=&quot;</a>
<a name="ln1200">    } else if (*arg == '^') {</a>
<a name="ln1201">      op = OP_PREPENDING;      // &quot;^=&quot;</a>
<a name="ln1202">    } else if (*arg == '-') {</a>
<a name="ln1203">      op = OP_REMOVING;        // &quot;-=&quot;</a>
<a name="ln1204">    }</a>
<a name="ln1205">  }</a>
<a name="ln1206">  return op;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">static set_prefix_T get_option_prefix(char **argp)</a>
<a name="ln1210">{</a>
<a name="ln1211">  if (strncmp(*argp, &quot;no&quot;, 2) == 0) {</a>
<a name="ln1212">    *argp += 2;</a>
<a name="ln1213">    return PREFIX_NO;</a>
<a name="ln1214">  } else if (strncmp(*argp, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln1215">    *argp += 3;</a>
<a name="ln1216">    return PREFIX_INV;</a>
<a name="ln1217">  }</a>
<a name="ln1218"> </a>
<a name="ln1219">  return PREFIX_NONE;</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">/// @param[in]   arg       Pointer to start option name</a>
<a name="ln1223">/// @param[out]  opt_idxp  Option index in options[] table.</a>
<a name="ln1224">/// @param[out]  keyp</a>
<a name="ln1225">/// @param[out]  len       Length of option name</a>
<a name="ln1226">/// @return  FAIL if an error is detected, OK otherwise</a>
<a name="ln1227">static int parse_option_name(char *arg, int *keyp, int *lenp, int *opt_idxp)</a>
<a name="ln1228">{</a>
<a name="ln1229">  // find end of name</a>
<a name="ln1230">  int key = 0;</a>
<a name="ln1231">  int len;</a>
<a name="ln1232">  int opt_idx;</a>
<a name="ln1233"> </a>
<a name="ln1234">  if (*arg == '&lt;') {</a>
<a name="ln1235">    opt_idx = -1;</a>
<a name="ln1236">    // look out for &lt;t_&gt;;&gt;</a>
<a name="ln1237">    if (arg[1] == 't' &amp;&amp; arg[2] == '_' &amp;&amp; arg[3] &amp;&amp; arg[4]) {</a>
<a name="ln1238">      len = 5;</a>
<a name="ln1239">    } else {</a>
<a name="ln1240">      len = 1;</a>
<a name="ln1241">      while (arg[len] != NUL &amp;&amp; arg[len] != '&gt;') {</a>
<a name="ln1242">        len++;</a>
<a name="ln1243">      }</a>
<a name="ln1244">    }</a>
<a name="ln1245">    if (arg[len] != '&gt;') {</a>
<a name="ln1246">      return FAIL;</a>
<a name="ln1247">    }</a>
<a name="ln1248">    if (arg[1] == 't' &amp;&amp; arg[2] == '_') {  // could be term code</a>
<a name="ln1249">      opt_idx = findoption_len(arg + 1, (size_t)(len - 1));</a>
<a name="ln1250">    }</a>
<a name="ln1251">    len++;</a>
<a name="ln1252">    if (opt_idx == -1) {</a>
<a name="ln1253">      key = find_key_option(arg + 1, true);</a>
<a name="ln1254">    }</a>
<a name="ln1255">  } else {</a>
<a name="ln1256">    // The two characters after &quot;t_&quot; may not be alphanumeric.</a>
<a name="ln1257">    if (arg[0] == 't' &amp;&amp; arg[1] == '_' &amp;&amp; arg[2] &amp;&amp; arg[3]) {</a>
<a name="ln1258">      len = 4;</a>
<a name="ln1259">    } else {</a>
<a name="ln1260">      len = 0;</a>
<a name="ln1261">      while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {</a>
<a name="ln1262">        len++;</a>
<a name="ln1263">      }</a>
<a name="ln1264">    }</a>
<a name="ln1265">    opt_idx = findoption_len(arg, (size_t)len);</a>
<a name="ln1266">    if (opt_idx == -1) {</a>
<a name="ln1267">      key = find_key_option(arg, false);</a>
<a name="ln1268">    }</a>
<a name="ln1269">  }</a>
<a name="ln1270"> </a>
<a name="ln1271">  *keyp = key;</a>
<a name="ln1272">  *lenp = len;</a>
<a name="ln1273">  *opt_idxp = opt_idx;</a>
<a name="ln1274"> </a>
<a name="ln1275">  return OK;</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">static int validate_opt_idx(win_T *win, int opt_idx, int opt_flags, uint32_t flags,</a>
<a name="ln1279">                            set_prefix_T prefix, const char **errmsg)</a>
<a name="ln1280">{</a>
<a name="ln1281">  // Only bools can have a prefix of 'inv' or 'no'</a>
<a name="ln1282">  if (!(flags &amp; P_BOOL) &amp;&amp; prefix != PREFIX_NONE) {</a>
<a name="ln1283">    *errmsg = e_invarg;</a>
<a name="ln1284">    return FAIL;</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  // Skip all options that are not window-local (used when showing</a>
<a name="ln1288">  // an already loaded buffer in a window).</a>
<a name="ln1289">  if ((opt_flags &amp; OPT_WINONLY)</a>
<a name="ln1290">      &amp;&amp; (opt_idx &lt; 0 || options[opt_idx].var != VAR_WIN)) {</a>
<a name="ln1291">    return FAIL;</a>
<a name="ln1292">  }</a>
<a name="ln1293"> </a>
<a name="ln1294">  // Skip all options that are window-local (used for :vimgrep).</a>
<a name="ln1295">  if ((opt_flags &amp; OPT_NOWIN) &amp;&amp; opt_idx &gt;= 0</a>
<a name="ln1296">      &amp;&amp; options[opt_idx].var == VAR_WIN) {</a>
<a name="ln1297">    return FAIL;</a>
<a name="ln1298">  }</a>
<a name="ln1299"> </a>
<a name="ln1300">  // Disallow changing some options from modelines.</a>
<a name="ln1301">  if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln1302">    if (flags &amp; (P_SECURE | P_NO_ML)) {</a>
<a name="ln1303">      *errmsg = e_not_allowed_in_modeline;</a>
<a name="ln1304">      return FAIL;</a>
<a name="ln1305">    }</a>
<a name="ln1306">    if ((flags &amp; P_MLE) &amp;&amp; !p_mle) {</a>
<a name="ln1307">      *errmsg = e_not_allowed_in_modeline_when_modelineexpr_is_off;</a>
<a name="ln1308">      return FAIL;</a>
<a name="ln1309">    }</a>
<a name="ln1310">    // In diff mode some options are overruled.  This avoids that</a>
<a name="ln1311">    // 'foldmethod' becomes &quot;marker&quot; instead of &quot;diff&quot; and that</a>
<a name="ln1312">    // &quot;wrap&quot; gets set.</a>
<a name="ln1313">    if (win-&gt;w_p_diff</a>
<a name="ln1314">        &amp;&amp; opt_idx &gt;= 0              // shut up coverity warning</a>
<a name="ln1315">        &amp;&amp; (options[opt_idx].indir == PV_FDM</a>
<a name="ln1316">            || options[opt_idx].indir == PV_WRAP)) {</a>
<a name="ln1317">      return FAIL;</a>
<a name="ln1318">    }</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  // Disallow changing some options in the sandbox</a>
<a name="ln1322">  if (sandbox != 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln1323">    *errmsg = e_sandbox;</a>
<a name="ln1324">    return FAIL;</a>
<a name="ln1325">  }</a>
<a name="ln1326"> </a>
<a name="ln1327">  return OK;</a>
<a name="ln1328">}</a>
<a name="ln1329"> </a>
<a name="ln1330">static void do_set_option_value(int opt_idx, int opt_flags, char **argp, set_prefix_T prefix,</a>
<a name="ln1331">                                int nextchar, set_op_T op, uint32_t flags, void *varp, char *errbuf,</a>
<a name="ln1332">                                size_t errbuflen, const char **errmsg)</a>
<a name="ln1333">{</a>
<a name="ln1334">  bool value_checked = false;</a>
<a name="ln1335">  if (flags &amp; P_BOOL) {        // boolean</a>
<a name="ln1336">    do_set_bool(opt_idx, opt_flags, prefix, nextchar, varp, errmsg);</a>
<a name="ln1337">  } else if (flags &amp; P_NUM) {  // numeric</a>
<a name="ln1338">    do_set_num(opt_idx, opt_flags, argp, nextchar, op, varp, errbuf, errbuflen, errmsg);</a>
<a name="ln1339">  } else if (opt_idx &gt;= 0) {   // string.</a>
<a name="ln1340">    do_set_option_string(opt_idx, opt_flags, argp, nextchar, op, flags, varp, errbuf,</a>
<a name="ln1341">                         errbuflen, &amp;value_checked, errmsg);</a>
<a name="ln1342">  } else {</a>
<a name="ln1343">    // key code option(FIXME(tarruda): Show a warning or something</a>
<a name="ln1344">    // similar)</a>
<a name="ln1345">  }</a>
<a name="ln1346"> </a>
<a name="ln1347">  if (*errmsg != NULL) {</a>
<a name="ln1348">    return;</a>
<a name="ln1349">  }</a>
<a name="ln1350"> </a>
<a name="ln1351">  if (opt_idx &gt;= 0) {</a>
<a name="ln1352">    did_set_option(opt_idx, opt_flags, op == OP_NONE, value_checked);</a>
<a name="ln1353">  }</a>
<a name="ln1354">}</a>
<a name="ln1355"> </a>
<a name="ln1356">static void do_set_option(int opt_flags, char **argp, bool *did_show, char *errbuf,</a>
<a name="ln1357">                          size_t errbuflen, const char **errmsg)</a>
<a name="ln1358">{</a>
<a name="ln1359">  // 1: nothing, 0: &quot;no&quot;, 2: &quot;inv&quot; in front of name</a>
<a name="ln1360">  set_prefix_T prefix = get_option_prefix(argp);</a>
<a name="ln1361"> </a>
<a name="ln1362">  char *arg = *argp;</a>
<a name="ln1363"> </a>
<a name="ln1364">  // find end of name</a>
<a name="ln1365">  int key = 0;</a>
<a name="ln1366">  int len;</a>
<a name="ln1367">  int opt_idx;</a>
<a name="ln1368">  if (parse_option_name(arg, &amp;key, &amp;len, &amp;opt_idx) == FAIL) {</a>
<a name="ln1369">    *errmsg = e_invarg;</a>
<a name="ln1370">    return;</a>
<a name="ln1371">  }</a>
<a name="ln1372"> </a>
<a name="ln1373">  // remember character after option name</a>
<a name="ln1374">  int afterchar = (uint8_t)arg[len];</a>
<a name="ln1375"> </a>
<a name="ln1376">  // skip white space, allow &quot;:set ai  ?&quot;</a>
<a name="ln1377">  while (ascii_iswhite(arg[len])) {</a>
<a name="ln1378">    len++;</a>
<a name="ln1379">  }</a>
<a name="ln1380"> </a>
<a name="ln1381">  set_op_T op = get_op(arg + len);</a>
<a name="ln1382">  if (op != OP_NONE) {</a>
<a name="ln1383">    len++;</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">  uint8_t nextchar = (uint8_t)arg[len];  // next non-white char after option name</a>
<a name="ln1387"> </a>
<a name="ln1388">  if (opt_idx == -1 &amp;&amp; key == 0) {          // found a mismatch: skip</a>
<a name="ln1389">    *errmsg = e_unknown_option;</a>
<a name="ln1390">    return;</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  uint32_t flags;  // flags for current option</a>
<a name="ln1394">  void *varp = NULL;  // pointer to variable for current option</a>
<a name="ln1395"> </a>
<a name="ln1396">  if (opt_idx &gt;= 0) {</a>
<a name="ln1397">    if (options[opt_idx].var == NULL) {         // hidden option: skip</a>
<a name="ln1398">      // Only give an error message when requesting the value of</a>
<a name="ln1399">      // a hidden option, ignore setting it.</a>
<a name="ln1400">      if (vim_strchr(&quot;=:!&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1401">          &amp;&amp; (!(options[opt_idx].flags &amp; P_BOOL)</a>
<a name="ln1402">              || nextchar == '?')) {</a>
<a name="ln1403">        *errmsg = e_unsupportedoption;</a>
<a name="ln1404">      }</a>
<a name="ln1405">      return;</a>
<a name="ln1406">    }</a>
<a name="ln1407"> </a>
<a name="ln1408">    flags = options[opt_idx].flags;</a>
<a name="ln1409">    varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln1410">  } else {</a>
<a name="ln1411">    flags = P_STRING;</a>
<a name="ln1412">  }</a>
<a name="ln1413"> </a>
<a name="ln1414">  if (validate_opt_idx(curwin, opt_idx, opt_flags, flags, prefix, errmsg) == FAIL) {</a>
<a name="ln1415">    return;</a>
<a name="ln1416">  }</a>
<a name="ln1417"> </a>
<a name="ln1418">  if (vim_strchr(&quot;?=:!&amp;&lt;&quot;, nextchar) != NULL) {</a>
<a name="ln1419">    *argp += len;</a>
<a name="ln1420">    if (nextchar == '&amp;' &amp;&amp; (*argp)[1] == 'v' &amp;&amp; (*argp)[2] == 'i') {</a>
<a name="ln1421">      if ((*argp)[3] == 'm') {  // &quot;opt&amp;vim&quot;: set to Vim default</a>
<a name="ln1422">        *argp += 3;</a>
<a name="ln1423">      } else {  // &quot;opt&amp;vi&quot;: set to Vi default</a>
<a name="ln1424">        *argp += 2;</a>
<a name="ln1425">      }</a>
<a name="ln1426">    }</a>
<a name="ln1427">    if (vim_strchr(&quot;?!&amp;&lt;&quot;, nextchar) != NULL</a>
<a name="ln1428">        &amp;&amp; (*argp)[1] != NUL &amp;&amp; !ascii_iswhite((*argp)[1])) {</a>
<a name="ln1429">      *errmsg = e_trailing;</a>
<a name="ln1430">      return;</a>
<a name="ln1431">    }</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  //</a>
<a name="ln1435">  // allow '=' and ':' as MS-DOS command.com allows only one</a>
<a name="ln1436">  // '=' character per &quot;set&quot; command line. grrr. (jw)</a>
<a name="ln1437">  //</a>
<a name="ln1438">  if (nextchar == '?'</a>
<a name="ln1439">      || (prefix == PREFIX_NONE</a>
<a name="ln1440">          &amp;&amp; vim_strchr(&quot;=:&amp;&lt;&quot;, nextchar) == NULL</a>
<a name="ln1441">          &amp;&amp; !(flags &amp; P_BOOL))) {</a>
<a name="ln1442">    // print value</a>
<a name="ln1443">    if (*did_show) {</a>
<a name="ln1444">      msg_putchar('\n');                // cursor below last one</a>
<a name="ln1445">    } else {</a>
<a name="ln1446">      gotocmdline(true);                // cursor at status line</a>
<a name="ln1447">      *did_show = true;                 // remember that we did a line</a>
<a name="ln1448">    }</a>
<a name="ln1449">    if (opt_idx &gt;= 0) {</a>
<a name="ln1450">      showoneopt(&amp;options[opt_idx], opt_flags);</a>
<a name="ln1451">      if (p_verbose &gt; 0) {</a>
<a name="ln1452">        // Mention where the option was last set.</a>
<a name="ln1453">        if (varp == options[opt_idx].var) {</a>
<a name="ln1454">          option_last_set_msg(options[opt_idx].last_set);</a>
<a name="ln1455">        } else if ((int)options[opt_idx].indir &amp; PV_WIN) {</a>
<a name="ln1456">          option_last_set_msg(curwin-&gt;w_p_script_ctx[(int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1457">        } else if ((int)options[opt_idx].indir &amp; PV_BUF) {</a>
<a name="ln1458">          option_last_set_msg(curbuf-&gt;b_p_script_ctx[(int)options[opt_idx].indir &amp; PV_MASK]);</a>
<a name="ln1459">        }</a>
<a name="ln1460">      }</a>
<a name="ln1461">    } else {</a>
<a name="ln1462">      *errmsg = e_key_code_not_set;</a>
<a name="ln1463">      return;</a>
<a name="ln1464">    }</a>
<a name="ln1465">    if (nextchar != '?' &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1466">      *errmsg = e_trailing;</a>
<a name="ln1467">    }</a>
<a name="ln1468">    return;</a>
<a name="ln1469">  }</a>
<a name="ln1470"> </a>
<a name="ln1471">  if (flags &amp; P_BOOL) {</a>
<a name="ln1472">    if (vim_strchr(&quot;=:&quot;, nextchar) != NULL) {</a>
<a name="ln1473">      *errmsg = e_invarg;</a>
<a name="ln1474">      return;</a>
<a name="ln1475">    }</a>
<a name="ln1476"> </a>
<a name="ln1477">    if (vim_strchr(&quot;!&amp;&lt;&quot;, nextchar) == NULL &amp;&amp; nextchar != NUL &amp;&amp; !ascii_iswhite(afterchar)) {</a>
<a name="ln1478">      *errmsg = e_trailing;</a>
<a name="ln1479">      return;</a>
<a name="ln1480">    }</a>
<a name="ln1481">  } else {</a>
<a name="ln1482">    if (vim_strchr(&quot;=:&amp;&lt;&quot;, nextchar) == NULL) {</a>
<a name="ln1483">      *errmsg = e_invarg;</a>
<a name="ln1484">      return;</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  do_set_option_value(opt_idx, opt_flags, argp, prefix, nextchar, op, flags, varp,</a>
<a name="ln1489">                      errbuf, errbuflen, errmsg);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">/// Parse 'arg' for option settings.</a>
<a name="ln1493">///</a>
<a name="ln1494">/// 'arg' may be IObuff, but only when no errors can be present and option</a>
<a name="ln1495">/// does not need to be expanded with option_expand().</a>
<a name="ln1496">/// &quot;opt_flags&quot;:</a>
<a name="ln1497">/// 0 for &quot;:set&quot;</a>
<a name="ln1498">/// OPT_GLOBAL   for &quot;:setglobal&quot;</a>
<a name="ln1499">/// OPT_LOCAL    for &quot;:setlocal&quot; and a modeline</a>
<a name="ln1500">/// OPT_MODELINE for a modeline</a>
<a name="ln1501">/// OPT_WINONLY  to only set window-local options</a>
<a name="ln1502">/// OPT_NOWIN    to skip setting window-local options</a>
<a name="ln1503">///</a>
<a name="ln1504">/// @param arg  option string (may be written to!)</a>
<a name="ln1505">///</a>
<a name="ln1506">/// @return  FAIL if an error is detected, OK otherwise</a>
<a name="ln1507">int do_set(char *arg, int opt_flags)</a>
<a name="ln1508">{</a>
<a name="ln1509">  bool did_show = false;             // already showed one value</a>
<a name="ln1510"> </a>
<a name="ln1511">  if (*arg == NUL) {</a>
<a name="ln1512">    showoptions(false, opt_flags);</a>
<a name="ln1513">    did_show = true;</a>
<a name="ln1514">  } else {</a>
<a name="ln1515">    while (*arg != NUL) {         // loop to process all options</a>
<a name="ln1516">      if (strncmp(arg, &quot;all&quot;, 3) == 0 &amp;&amp; !ASCII_ISALPHA(arg[3])</a>
<a name="ln1517">          &amp;&amp; !(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln1518">        // &quot;:set all&quot;  show all options.</a>
<a name="ln1519">        // &quot;:set all&amp;&quot; set all options to their default value.</a>
<a name="ln1520">        arg += 3;</a>
<a name="ln1521">        if (*arg == '&amp;') {</a>
<a name="ln1522">          arg++;</a>
<a name="ln1523">          // Only for :set command set global value of local options.</a>
<a name="ln1524">          set_options_default(OPT_FREE | opt_flags);</a>
<a name="ln1525">          didset_options();</a>
<a name="ln1526">          didset_options2();</a>
<a name="ln1527">          ui_refresh_options();</a>
<a name="ln1528">          redraw_all_later(UPD_CLEAR);</a>
<a name="ln1529">        } else {</a>
<a name="ln1530">          showoptions(true, opt_flags);</a>
<a name="ln1531">          did_show = true;</a>
<a name="ln1532">        }</a>
<a name="ln1533">      } else {</a>
<a name="ln1534">        char *startarg = arg;             // remember for error message</a>
<a name="ln1535">        const char *errmsg = NULL;</a>
<a name="ln1536">        char errbuf[80];</a>
<a name="ln1537"> </a>
<a name="ln1538">        do_set_option(opt_flags, &amp;arg, &amp;did_show, errbuf, sizeof(errbuf), &amp;errmsg);</a>
<a name="ln1539"> </a>
<a name="ln1540">        // Advance to next argument.</a>
<a name="ln1541">        // - skip until a blank found, taking care of backslashes</a>
<a name="ln1542">        // - skip blanks</a>
<a name="ln1543">        // - skip one &quot;=val&quot; argument (for hidden options &quot;:set gfn =xx&quot;)</a>
<a name="ln1544">        for (int i = 0; i &lt; 2; i++) {</a>
<a name="ln1545">          arg = skiptowhite_esc(arg);</a>
<a name="ln1546">          arg = skipwhite(arg);</a>
<a name="ln1547">          if (*arg != '=') {</a>
<a name="ln1548">            break;</a>
<a name="ln1549">          }</a>
<a name="ln1550">        }</a>
<a name="ln1551"> </a>
<a name="ln1552">        if (errmsg != NULL) {</a>
<a name="ln1553">          xstrlcpy(IObuff, _(errmsg), IOSIZE);</a>
<a name="ln1554">          int i = (int)strlen(IObuff) + 2;</a>
<a name="ln1555">          if (i + (arg - startarg) &lt; IOSIZE) {</a>
<a name="ln1556">            // append the argument with the error</a>
<a name="ln1557">            xstrlcat(IObuff, &quot;: &quot;, IOSIZE);</a>
<a name="ln1558">            assert(arg &gt;= startarg);</a>
<a name="ln1559">            memmove(IObuff + i, startarg, (size_t)(arg - startarg));</a>
<a name="ln1560">            IObuff[i + (arg - startarg)] = NUL;</a>
<a name="ln1561">          }</a>
<a name="ln1562">          // make sure all characters are printable</a>
<a name="ln1563">          trans_characters(IObuff, IOSIZE);</a>
<a name="ln1564"> </a>
<a name="ln1565">          no_wait_return++;         // wait_return() done later</a>
<a name="ln1566">          emsg(IObuff);             // show error highlighted</a>
<a name="ln1567">          no_wait_return--;</a>
<a name="ln1568"> </a>
<a name="ln1569">          return FAIL;</a>
<a name="ln1570">        }</a>
<a name="ln1571">      }</a>
<a name="ln1572"> </a>
<a name="ln1573">      arg = skipwhite(arg);</a>
<a name="ln1574">    }</a>
<a name="ln1575">  }</a>
<a name="ln1576"> </a>
<a name="ln1577">  if (silent_mode &amp;&amp; did_show) {</a>
<a name="ln1578">    // After displaying option values in silent mode.</a>
<a name="ln1579">    silent_mode = false;</a>
<a name="ln1580">    info_message = true;        // use os_msg(), not os_errmsg()</a>
<a name="ln1581">    msg_putchar('\n');</a>
<a name="ln1582">    silent_mode = true;</a>
<a name="ln1583">    info_message = false;       // use os_msg(), not os_errmsg()</a>
<a name="ln1584">  }</a>
<a name="ln1585"> </a>
<a name="ln1586">  return OK;</a>
<a name="ln1587">}</a>
<a name="ln1588"> </a>
<a name="ln1589">/// Call this when an option has been given a new value through a user command.</a>
<a name="ln1590">/// Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.</a>
<a name="ln1591">///</a>
<a name="ln1592">/// @param opt_flags  possibly with OPT_MODELINE</a>
<a name="ln1593">/// @param new_value  value was replaced completely</a>
<a name="ln1594">/// @param value_checked  value was checked to be safe, no need to set P_INSECURE</a>
<a name="ln1595">void did_set_option(int opt_idx, int opt_flags, bool new_value, bool value_checked)</a>
<a name="ln1596">{</a>
<a name="ln1597">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln1598"> </a>
<a name="ln1599">  // When an option is set in the sandbox, from a modeline or in secure mode</a>
<a name="ln1600">  // set the P_INSECURE flag.  Otherwise, if a new value is stored reset the</a>
<a name="ln1601">  // flag.</a>
<a name="ln1602">  uint32_t *p = insecure_flag(curwin, opt_idx, opt_flags);</a>
<a name="ln1603">  if (!value_checked &amp;&amp; (secure</a>
<a name="ln1604">                         || sandbox != 0</a>
<a name="ln1605">                         || (opt_flags &amp; OPT_MODELINE))) {</a>
<a name="ln1606">    *p = *p | P_INSECURE;</a>
<a name="ln1607">  } else if (new_value) {</a>
<a name="ln1608">    *p = *p &amp; ~P_INSECURE;</a>
<a name="ln1609">  }</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">/// Convert a key name or string into a key value.</a>
<a name="ln1613">/// Used for 'wildchar' and 'cedit' options.</a>
<a name="ln1614">int string_to_key(char *arg)</a>
<a name="ln1615">{</a>
<a name="ln1616">  if (*arg == '&lt;') {</a>
<a name="ln1617">    return find_key_option(arg + 1, true);</a>
<a name="ln1618">  }</a>
<a name="ln1619">  if (*arg == '^') {</a>
<a name="ln1620">    return CTRL_CHR((uint8_t)arg[1]);</a>
<a name="ln1621">  }</a>
<a name="ln1622">  return (uint8_t)(*arg);</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">// When changing 'title', 'titlestring', 'icon' or 'iconstring', call</a>
<a name="ln1626">// maketitle() to create and display it.</a>
<a name="ln1627">// When switching the title or icon off, call ui_set_{icon,title}(NULL) to get</a>
<a name="ln1628">// the old value back.</a>
<a name="ln1629">void did_set_title(void)</a>
<a name="ln1630">{</a>
<a name="ln1631">  if (starting != NO_SCREEN) {</a>
<a name="ln1632">    maketitle();</a>
<a name="ln1633">  }</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636">/// set_options_bin -  called when 'bin' changes value.</a>
<a name="ln1637">///</a>
<a name="ln1638">/// @param opt_flags  OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln1639">void set_options_bin(int oldval, int newval, int opt_flags)</a>
<a name="ln1640">{</a>
<a name="ln1641">  // The option values that are changed when 'bin' changes are</a>
<a name="ln1642">  // copied when 'bin is set and restored when 'bin' is reset.</a>
<a name="ln1643">  if (newval) {</a>
<a name="ln1644">    if (!oldval) {              // switched on</a>
<a name="ln1645">      if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1646">        curbuf-&gt;b_p_tw_nobin = curbuf-&gt;b_p_tw;</a>
<a name="ln1647">        curbuf-&gt;b_p_wm_nobin = curbuf-&gt;b_p_wm;</a>
<a name="ln1648">        curbuf-&gt;b_p_ml_nobin = curbuf-&gt;b_p_ml;</a>
<a name="ln1649">        curbuf-&gt;b_p_et_nobin = curbuf-&gt;b_p_et;</a>
<a name="ln1650">      }</a>
<a name="ln1651">      if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1652">        p_tw_nobin = p_tw;</a>
<a name="ln1653">        p_wm_nobin = p_wm;</a>
<a name="ln1654">        p_ml_nobin = p_ml;</a>
<a name="ln1655">        p_et_nobin = p_et;</a>
<a name="ln1656">      }</a>
<a name="ln1657">    }</a>
<a name="ln1658"> </a>
<a name="ln1659">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1660">      curbuf-&gt;b_p_tw = 0;       // no automatic line wrap</a>
<a name="ln1661">      curbuf-&gt;b_p_wm = 0;       // no automatic line wrap</a>
<a name="ln1662">      curbuf-&gt;b_p_ml = 0;       // no modelines</a>
<a name="ln1663">      curbuf-&gt;b_p_et = 0;       // no expandtab</a>
<a name="ln1664">    }</a>
<a name="ln1665">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1666">      p_tw = 0;</a>
<a name="ln1667">      p_wm = 0;</a>
<a name="ln1668">      p_ml = false;</a>
<a name="ln1669">      p_et = false;</a>
<a name="ln1670">      p_bin = true;             // needed when called for the &quot;-b&quot; argument</a>
<a name="ln1671">    }</a>
<a name="ln1672">  } else if (oldval) {        // switched off</a>
<a name="ln1673">    if (!(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln1674">      curbuf-&gt;b_p_tw = curbuf-&gt;b_p_tw_nobin;</a>
<a name="ln1675">      curbuf-&gt;b_p_wm = curbuf-&gt;b_p_wm_nobin;</a>
<a name="ln1676">      curbuf-&gt;b_p_ml = curbuf-&gt;b_p_ml_nobin;</a>
<a name="ln1677">      curbuf-&gt;b_p_et = curbuf-&gt;b_p_et_nobin;</a>
<a name="ln1678">    }</a>
<a name="ln1679">    if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1680">      p_tw = p_tw_nobin;</a>
<a name="ln1681">      p_wm = p_wm_nobin;</a>
<a name="ln1682">      p_ml = p_ml_nobin;</a>
<a name="ln1683">      p_et = p_et_nobin;</a>
<a name="ln1684">    }</a>
<a name="ln1685">  }</a>
<a name="ln1686"> </a>
<a name="ln1687">  // Remember where the dependent option were reset</a>
<a name="ln1688">  didset_options_sctx(opt_flags, p_bin_dep_opts);</a>
<a name="ln1689">}</a>
<a name="ln1690"> </a>
<a name="ln1691">/// Find the parameter represented by the given character (eg ', :, &quot;, or /),</a>
<a name="ln1692">/// and return its associated value in the 'shada' string.</a>
<a name="ln1693">/// Only works for number parameters, not for 'r' or 'n'.</a>
<a name="ln1694">/// If the parameter is not specified in the string or there is no following</a>
<a name="ln1695">/// number, return -1.</a>
<a name="ln1696">int get_shada_parameter(int type)</a>
<a name="ln1697">{</a>
<a name="ln1698">  char *p = find_shada_parameter(type);</a>
<a name="ln1699">  if (p != NULL &amp;&amp; ascii_isdigit(*p)) {</a>
<a name="ln1700">    return atoi(p);</a>
<a name="ln1701">  }</a>
<a name="ln1702">  return -1;</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">/// Find the parameter represented by the given character (eg ''', ':', '&quot;', or</a>
<a name="ln1706">/// '/') in the 'shada' option and return a pointer to the string after it.</a>
<a name="ln1707">/// Return NULL if the parameter is not specified in the string.</a>
<a name="ln1708">char *find_shada_parameter(int type)</a>
<a name="ln1709">{</a>
<a name="ln1710">  for (char *p = p_shada; *p; p++) {</a>
<a name="ln1711">    if (*p == type) {</a>
<a name="ln1712">      return p + 1;</a>
<a name="ln1713">    }</a>
<a name="ln1714">    if (*p == 'n') {                // 'n' is always the last one</a>
<a name="ln1715">      break;</a>
<a name="ln1716">    }</a>
<a name="ln1717">    p = vim_strchr(p, ',');         // skip until next ','</a>
<a name="ln1718">    if (p == NULL) {                // hit the end without finding parameter</a>
<a name="ln1719">      break;</a>
<a name="ln1720">    }</a>
<a name="ln1721">  }</a>
<a name="ln1722">  return NULL;</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">/// Expand environment variables for some string options.</a>
<a name="ln1726">/// These string options cannot be indirect!</a>
<a name="ln1727">/// If &quot;val&quot; is NULL expand the current value of the option.</a>
<a name="ln1728">/// Return pointer to NameBuff, or NULL when not expanded.</a>
<a name="ln1729">static char *option_expand(int opt_idx, char *val)</a>
<a name="ln1730">{</a>
<a name="ln1731">  // if option doesn't need expansion nothing to do</a>
<a name="ln1732">  if (!(options[opt_idx].flags &amp; P_EXPAND) || options[opt_idx].var == NULL) {</a>
<a name="ln1733">    return NULL;</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">  if (val == NULL) {</a>
<a name="ln1737">    val = *(char **)options[opt_idx].var;</a>
<a name="ln1738">  }</a>
<a name="ln1739"> </a>
<a name="ln1740">  // If val is longer than MAXPATHL no meaningful expansion can be done,</a>
<a name="ln1741">  // expand_env() would truncate the string.</a>
<a name="ln1742">  if (val == NULL || strlen(val) &gt; MAXPATHL) {</a>
<a name="ln1743">    return NULL;</a>
<a name="ln1744">  }</a>
<a name="ln1745"> </a>
<a name="ln1746">  // Expanding this with NameBuff, expand_env() must not be passed IObuff.</a>
<a name="ln1747">  // Escape spaces when expanding 'tags', they are used to separate file</a>
<a name="ln1748">  // names.</a>
<a name="ln1749">  // For 'spellsuggest' expand after &quot;file:&quot;.</a>
<a name="ln1750">  expand_env_esc(val, NameBuff, MAXPATHL,</a>
<a name="ln1751">                 (char **)options[opt_idx].var == &amp;p_tags, false,</a>
<a name="ln1752">                 (char **)options[opt_idx].var == &amp;p_sps ? &quot;file:&quot; :</a>
<a name="ln1753">                 NULL);</a>
<a name="ln1754">  if (strcmp(NameBuff, val) == 0) {   // they are the same</a>
<a name="ln1755">    return NULL;</a>
<a name="ln1756">  }</a>
<a name="ln1757"> </a>
<a name="ln1758">  return NameBuff;</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">/// After setting various option values: recompute variables that depend on</a>
<a name="ln1762">/// option values.</a>
<a name="ln1763">static void didset_options(void)</a>
<a name="ln1764">{</a>
<a name="ln1765">  // initialize the table for 'iskeyword' et.al.</a>
<a name="ln1766">  (void)init_chartab();</a>
<a name="ln1767"> </a>
<a name="ln1768">  didset_string_options();</a>
<a name="ln1769"> </a>
<a name="ln1770">  (void)spell_check_msm();</a>
<a name="ln1771">  (void)spell_check_sps();</a>
<a name="ln1772">  (void)compile_cap_prog(curwin-&gt;w_s);</a>
<a name="ln1773">  (void)did_set_spell_option(true);</a>
<a name="ln1774">  // set cedit_key</a>
<a name="ln1775">  (void)did_set_cedit(NULL);</a>
<a name="ln1776">  // initialize the table for 'breakat'.</a>
<a name="ln1777">  (void)did_set_breakat(NULL);</a>
<a name="ln1778">  didset_window_options(curwin, true);</a>
<a name="ln1779">}</a>
<a name="ln1780"> </a>
<a name="ln1781">// More side effects of setting options.</a>
<a name="ln1782">static void didset_options2(void)</a>
<a name="ln1783">{</a>
<a name="ln1784">  // Initialize the highlight_attr[] table.</a>
<a name="ln1785">  highlight_changed();</a>
<a name="ln1786"> </a>
<a name="ln1787">  // Parse default for 'fillchars'.</a>
<a name="ln1788">  (void)set_fillchars_option(curwin, curwin-&gt;w_p_fcs, true);</a>
<a name="ln1789"> </a>
<a name="ln1790">  // Parse default for 'listchars'.</a>
<a name="ln1791">  (void)set_listchars_option(curwin, curwin-&gt;w_p_lcs, true);</a>
<a name="ln1792"> </a>
<a name="ln1793">  // Parse default for 'wildmode'.</a>
<a name="ln1794">  check_opt_wim();</a>
<a name="ln1795">  xfree(curbuf-&gt;b_p_vsts_array);</a>
<a name="ln1796">  (void)tabstop_set(curbuf-&gt;b_p_vsts, &amp;curbuf-&gt;b_p_vsts_array);</a>
<a name="ln1797">  xfree(curbuf-&gt;b_p_vts_array);</a>
<a name="ln1798">  (void)tabstop_set(curbuf-&gt;b_p_vts,  &amp;curbuf-&gt;b_p_vts_array);</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">/// Check for string options that are NULL (normally only termcap options).</a>
<a name="ln1802">void check_options(void)</a>
<a name="ln1803">{</a>
<a name="ln1804">  for (int opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln1805">    if ((options[opt_idx].flags &amp; P_STRING) &amp;&amp; options[opt_idx].var != NULL) {</a>
<a name="ln1806">      check_string_option((char **)get_varp(&amp;(options[opt_idx])));</a>
<a name="ln1807">    }</a>
<a name="ln1808">  }</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">/// Return true when option &quot;opt&quot; was set from a modeline or in secure mode.</a>
<a name="ln1812">/// Return false when it wasn't.</a>
<a name="ln1813">/// Return -1 for an unknown option.</a>
<a name="ln1814">int was_set_insecurely(win_T *const wp, char *opt, int opt_flags)</a>
<a name="ln1815">{</a>
<a name="ln1816">  int idx = findoption(opt);</a>
<a name="ln1817"> </a>
<a name="ln1818">  if (idx &gt;= 0) {</a>
<a name="ln1819">    uint32_t *flagp = insecure_flag(wp, idx, opt_flags);</a>
<a name="ln1820">    return (*flagp &amp; P_INSECURE) != 0;</a>
<a name="ln1821">  }</a>
<a name="ln1822">  internal_error(&quot;was_set_insecurely()&quot;);</a>
<a name="ln1823">  return -1;</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">/// Get a pointer to the flags used for the P_INSECURE flag of option</a>
<a name="ln1827">/// &quot;opt_idx&quot;.  For some local options a local flags field is used.</a>
<a name="ln1828">/// NOTE: Caller must make sure that &quot;wp&quot; is set to the window from which</a>
<a name="ln1829">/// the option is used.</a>
<a name="ln1830">static uint32_t *insecure_flag(win_T *const wp, int opt_idx, int opt_flags)</a>
<a name="ln1831">{</a>
<a name="ln1832">  if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln1833">    assert(wp != NULL);</a>
<a name="ln1834">    switch ((int)options[opt_idx].indir) {</a>
<a name="ln1835">    case PV_STL:</a>
<a name="ln1836">      return &amp;wp-&gt;w_p_stl_flags;</a>
<a name="ln1837">    case PV_WBR:</a>
<a name="ln1838">      return &amp;wp-&gt;w_p_wbr_flags;</a>
<a name="ln1839">    case PV_FDE:</a>
<a name="ln1840">      return &amp;wp-&gt;w_p_fde_flags;</a>
<a name="ln1841">    case PV_FDT:</a>
<a name="ln1842">      return &amp;wp-&gt;w_p_fdt_flags;</a>
<a name="ln1843">    case PV_INDE:</a>
<a name="ln1844">      return &amp;wp-&gt;w_buffer-&gt;b_p_inde_flags;</a>
<a name="ln1845">    case PV_FEX:</a>
<a name="ln1846">      return &amp;wp-&gt;w_buffer-&gt;b_p_fex_flags;</a>
<a name="ln1847">    case PV_INEX:</a>
<a name="ln1848">      return &amp;wp-&gt;w_buffer-&gt;b_p_inex_flags;</a>
<a name="ln1849">    }</a>
<a name="ln1850">  }</a>
<a name="ln1851"> </a>
<a name="ln1852">  // Nothing special, return global flags field.</a>
<a name="ln1853">  return &amp;options[opt_idx].flags;</a>
<a name="ln1854">}</a>
<a name="ln1855"> </a>
<a name="ln1856">/// Redraw the window title and/or tab page text later.</a>
<a name="ln1857">void redraw_titles(void)</a>
<a name="ln1858">{</a>
<a name="ln1859">  need_maketitle = true;</a>
<a name="ln1860">  redraw_tabline = true;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/// Return true if &quot;val&quot; is a valid name: only consists of alphanumeric ASCII</a>
<a name="ln1864">/// characters or characters in &quot;allowed&quot;.</a>
<a name="ln1865">bool valid_name(const char *val, const char *allowed)</a>
<a name="ln1866">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1867">{</a>
<a name="ln1868">  for (const char *s = val; *s != NUL; s++) {</a>
<a name="ln1869">    if (!ASCII_ISALNUM(*s)</a>
<a name="ln1870">        &amp;&amp; vim_strchr(allowed, (uint8_t)(*s)) == NULL) {</a>
<a name="ln1871">      return false;</a>
<a name="ln1872">    }</a>
<a name="ln1873">  }</a>
<a name="ln1874">  return true;</a>
<a name="ln1875">}</a>
<a name="ln1876"> </a>
<a name="ln1877">void check_blending(win_T *wp)</a>
<a name="ln1878">{</a>
<a name="ln1879">  wp-&gt;w_grid_alloc.blending =</a>
<a name="ln1880">    wp-&gt;w_p_winbl &gt; 0 || (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.shadow);</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">/// Handle setting `winhighlight' in window &quot;wp&quot;</a>
<a name="ln1884">bool parse_winhl_opt(win_T *wp)</a>
<a name="ln1885">{</a>
<a name="ln1886">  const char *p = wp-&gt;w_p_winhl;</a>
<a name="ln1887"> </a>
<a name="ln1888">  if (!*p) {</a>
<a name="ln1889">    if (wp-&gt;w_ns_hl_winhl &amp;&amp; wp-&gt;w_ns_hl == wp-&gt;w_ns_hl_winhl) {</a>
<a name="ln1890">      wp-&gt;w_ns_hl = 0;</a>
<a name="ln1891">      wp-&gt;w_hl_needs_update = true;</a>
<a name="ln1892">    }</a>
<a name="ln1893"> </a>
<a name="ln1894">    return true;</a>
<a name="ln1895">  }</a>
<a name="ln1896"> </a>
<a name="ln1897">  if (wp-&gt;w_ns_hl_winhl == 0) {</a>
<a name="ln1898">    wp-&gt;w_ns_hl_winhl = (int)nvim_create_namespace(NULL_STRING);</a>
<a name="ln1899">  } else {</a>
<a name="ln1900">    // namespace already exist. invalidate existing items</a>
<a name="ln1901">    DecorProvider *dp = get_decor_provider(wp-&gt;w_ns_hl_winhl, true);</a>
<a name="ln1902">    dp-&gt;hl_valid++;</a>
<a name="ln1903">  }</a>
<a name="ln1904">  wp-&gt;w_ns_hl = wp-&gt;w_ns_hl_winhl;</a>
<a name="ln1905">  int ns_hl = wp-&gt;w_ns_hl;</a>
<a name="ln1906"> </a>
<a name="ln1907">  while (*p) {</a>
<a name="ln1908">    char *colon = strchr(p, ':');</a>
<a name="ln1909">    if (!colon) {</a>
<a name="ln1910">      return false;</a>
<a name="ln1911">    }</a>
<a name="ln1912">    size_t nlen = (size_t)(colon - p);</a>
<a name="ln1913">    char *hi = colon + 1;</a>
<a name="ln1914">    char *commap = xstrchrnul(hi, ',');</a>
<a name="ln1915">    size_t len = (size_t)(commap - hi);</a>
<a name="ln1916">    int hl_id = len ? syn_check_group(hi, len) : -1;</a>
<a name="ln1917">    if (hl_id == 0) {</a>
<a name="ln1918">      return false;</a>
<a name="ln1919">    }</a>
<a name="ln1920">    int hl_id_link = nlen ? syn_check_group(p, nlen) : 0;</a>
<a name="ln1921"> </a>
<a name="ln1922">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln1923">    attrs.rgb_ae_attr |= HL_GLOBAL;</a>
<a name="ln1924">    ns_hl_def(ns_hl, hl_id_link, attrs, hl_id, NULL);</a>
<a name="ln1925"> </a>
<a name="ln1926">    p = *commap ? commap + 1 : &quot;&quot;;</a>
<a name="ln1927">  }</a>
<a name="ln1928"> </a>
<a name="ln1929">  wp-&gt;w_hl_needs_update = true;</a>
<a name="ln1930">  return true;</a>
<a name="ln1931">}</a>
<a name="ln1932"> </a>
<a name="ln1933">/// Get the script context of global option &quot;name&quot;.</a>
<a name="ln1934">sctx_T *get_option_sctx(const char *const name)</a>
<a name="ln1935">{</a>
<a name="ln1936">  int idx = findoption(name);</a>
<a name="ln1937"> </a>
<a name="ln1938">  if (idx &gt;= 0) {</a>
<a name="ln1939">    return &amp;options[idx].last_set.script_ctx;</a>
<a name="ln1940">  }</a>
<a name="ln1941">  siemsg(&quot;no such option: %s&quot;, name);</a>
<a name="ln1942">  return NULL;</a>
<a name="ln1943">}</a>
<a name="ln1944"> </a>
<a name="ln1945">/// Set the script_ctx for an option, taking care of setting the buffer- or</a>
<a name="ln1946">/// window-local value.</a>
<a name="ln1947">void set_option_sctx_idx(int opt_idx, int opt_flags, sctx_T script_ctx)</a>
<a name="ln1948">{</a>
<a name="ln1949">  int both = (opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0;</a>
<a name="ln1950">  int indir = (int)options[opt_idx].indir;</a>
<a name="ln1951">  nlua_set_sctx(&amp;script_ctx);</a>
<a name="ln1952">  LastSet last_set = {</a>
<a name="ln1953">    .script_ctx = script_ctx,</a>
<a name="ln1954">    .channel_id = current_channel_id,</a>
<a name="ln1955">  };</a>
<a name="ln1956"> </a>
<a name="ln1957">  // Modeline already has the line number set.</a>
<a name="ln1958">  if (!(opt_flags &amp; OPT_MODELINE)) {</a>
<a name="ln1959">    last_set.script_ctx.sc_lnum += SOURCING_LNUM;</a>
<a name="ln1960">  }</a>
<a name="ln1961"> </a>
<a name="ln1962">  // Remember where the option was set.  For local options need to do that</a>
<a name="ln1963">  // in the buffer or window structure.</a>
<a name="ln1964">  if (both || (opt_flags &amp; OPT_GLOBAL) || (indir &amp; (PV_BUF|PV_WIN)) == 0) {</a>
<a name="ln1965">    options[opt_idx].last_set = last_set;</a>
<a name="ln1966">  }</a>
<a name="ln1967">  if (both || (opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln1968">    if (indir &amp; PV_BUF) {</a>
<a name="ln1969">      curbuf-&gt;b_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln1970">    } else if (indir &amp; PV_WIN) {</a>
<a name="ln1971">      curwin-&gt;w_p_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln1972">      if (both) {</a>
<a name="ln1973">        // also setting the &quot;all buffers&quot; value</a>
<a name="ln1974">        curwin-&gt;w_allbuf_opt.wo_script_ctx[indir &amp; PV_MASK] = last_set;</a>
<a name="ln1975">      }</a>
<a name="ln1976">    }</a>
<a name="ln1977">  }</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">/// Apply the OptionSet autocommand.</a>
<a name="ln1981">static void apply_optionset_autocmd(int opt_idx, long opt_flags, OptInt oldval, OptInt oldval_g,</a>
<a name="ln1982">                                    long newval, const char *errmsg)</a>
<a name="ln1983">{</a>
<a name="ln1984">  // Don't do this while starting up, failure or recursively.</a>
<a name="ln1985">  if (starting || errmsg != NULL || *get_vim_var_str(VV_OPTION_TYPE) != NUL) {</a>
<a name="ln1986">    return;</a>
<a name="ln1987">  }</a>
<a name="ln1988"> </a>
<a name="ln1989">  char buf_old[12], buf_old_global[12], buf_new[12], buf_type[12];</a>
<a name="ln1990"> </a>
<a name="ln1991">  vim_snprintf(buf_old, sizeof(buf_old), &quot;%&quot; PRId64, oldval);</a>
<a name="ln1992">  vim_snprintf(buf_old_global, sizeof(buf_old_global), &quot;%&quot; PRId64, oldval_g);</a>
<a name="ln1993">  vim_snprintf(buf_new, sizeof(buf_new), &quot;%ld&quot;, newval);</a>
<a name="ln1994">  vim_snprintf(buf_type, sizeof(buf_type), &quot;%s&quot;,</a>
<a name="ln1995">               (opt_flags &amp; OPT_LOCAL) ? &quot;local&quot; : &quot;global&quot;);</a>
<a name="ln1996">  set_vim_var_string(VV_OPTION_NEW, buf_new, -1);</a>
<a name="ln1997">  set_vim_var_string(VV_OPTION_OLD, buf_old, -1);</a>
<a name="ln1998">  set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);</a>
<a name="ln1999">  if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln2000">    set_vim_var_string(VV_OPTION_COMMAND, &quot;setlocal&quot;, -1);</a>
<a name="ln2001">    set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2002">  }</a>
<a name="ln2003">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln2004">    set_vim_var_string(VV_OPTION_COMMAND, &quot;setglobal&quot;, -1);</a>
<a name="ln2005">    set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old, -1);</a>
<a name="ln2006">  }</a>
<a name="ln2007">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2008">    set_vim_var_string(VV_OPTION_COMMAND, &quot;set&quot;, -1);</a>
<a name="ln2009">    set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2010">    set_vim_var_string(VV_OPTION_OLDGLOBAL, buf_old_global, -1);</a>
<a name="ln2011">  }</a>
<a name="ln2012">  if (opt_flags &amp; OPT_MODELINE) {</a>
<a name="ln2013">    set_vim_var_string(VV_OPTION_COMMAND, &quot;modeline&quot;, -1);</a>
<a name="ln2014">    set_vim_var_string(VV_OPTION_OLDLOCAL, buf_old, -1);</a>
<a name="ln2015">  }</a>
<a name="ln2016">  apply_autocmds(EVENT_OPTIONSET, options[opt_idx].fullname, NULL, false, NULL);</a>
<a name="ln2017">  reset_v_option_vars();</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">/// Ensure that options set to p_force_on cannot be disabled.</a>
<a name="ln2021">static const char *did_set_force_on(bool *doskip)</a>
<a name="ln2022">{</a>
<a name="ln2023">  if (p_force_on == false) {</a>
<a name="ln2024">    p_force_on = true;</a>
<a name="ln2025">    *doskip = true;</a>
<a name="ln2026">    return e_unsupportedoption;</a>
<a name="ln2027">  }</a>
<a name="ln2028">  return NULL;</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">/// Ensure that options set to p_force_off cannot be enabled.</a>
<a name="ln2032">static const char *did_set_force_off(bool *doskip)</a>
<a name="ln2033">{</a>
<a name="ln2034">  if (p_force_off == true) {</a>
<a name="ln2035">    p_force_off = false;</a>
<a name="ln2036">    *doskip = true;</a>
<a name="ln2037">    return e_unsupportedoption;</a>
<a name="ln2038">  }</a>
<a name="ln2039">  return NULL;</a>
<a name="ln2040">}</a>
<a name="ln2041"> </a>
<a name="ln2042">/// Process the updated 'arabic' option value.</a>
<a name="ln2043">static const char *did_set_arabic(optset_T *args)</a>
<a name="ln2044">{</a>
<a name="ln2045">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2046">  const char *errmsg = NULL;</a>
<a name="ln2047"> </a>
<a name="ln2048">  if (win-&gt;w_p_arab) {</a>
<a name="ln2049">    // 'arabic' is set, handle various sub-settings.</a>
<a name="ln2050">    if (!p_tbidi) {</a>
<a name="ln2051">      // set rightleft mode</a>
<a name="ln2052">      if (!win-&gt;w_p_rl) {</a>
<a name="ln2053">        win-&gt;w_p_rl = true;</a>
<a name="ln2054">        changed_window_setting();</a>
<a name="ln2055">      }</a>
<a name="ln2056"> </a>
<a name="ln2057">      // Enable Arabic shaping (major part of what Arabic requires)</a>
<a name="ln2058">      if (!p_arshape) {</a>
<a name="ln2059">        p_arshape = true;</a>
<a name="ln2060">        redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln2061">      }</a>
<a name="ln2062">    }</a>
<a name="ln2063"> </a>
<a name="ln2064">    // Arabic requires a utf-8 encoding, inform the user if it's not</a>
<a name="ln2065">    // set.</a>
<a name="ln2066">    if (strcmp(p_enc, &quot;utf-8&quot;) != 0) {</a>
<a name="ln2067">      static char *w_arabic = N_(&quot;W17: Arabic requires UTF-8, do ':set encoding=utf-8'&quot;);</a>
<a name="ln2068"> </a>
<a name="ln2069">      msg_source(HL_ATTR(HLF_W));</a>
<a name="ln2070">      msg(_(w_arabic), HL_ATTR(HLF_W));</a>
<a name="ln2071">      set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);</a>
<a name="ln2072">    }</a>
<a name="ln2073"> </a>
<a name="ln2074">    // set 'delcombine'</a>
<a name="ln2075">    p_deco = true;</a>
<a name="ln2076"> </a>
<a name="ln2077">    // Force-set the necessary keymap for arabic.</a>
<a name="ln2078">    errmsg = set_option_value(&quot;keymap&quot;, STATIC_CSTR_AS_OPTVAL(&quot;arabic&quot;), OPT_LOCAL);</a>
<a name="ln2079">  } else {</a>
<a name="ln2080">    // 'arabic' is reset, handle various sub-settings.</a>
<a name="ln2081">    if (!p_tbidi) {</a>
<a name="ln2082">      // reset rightleft mode</a>
<a name="ln2083">      if (win-&gt;w_p_rl) {</a>
<a name="ln2084">        win-&gt;w_p_rl = false;</a>
<a name="ln2085">        changed_window_setting();</a>
<a name="ln2086">      }</a>
<a name="ln2087"> </a>
<a name="ln2088">      // 'arabicshape' isn't reset, it is a global option and</a>
<a name="ln2089">      // another window may still need it &quot;on&quot;.</a>
<a name="ln2090">    }</a>
<a name="ln2091"> </a>
<a name="ln2092">    // 'delcombine' isn't reset, it is a global option and another</a>
<a name="ln2093">    // window may still want it &quot;on&quot;.</a>
<a name="ln2094"> </a>
<a name="ln2095">    // Revert to the default keymap</a>
<a name="ln2096">    curbuf-&gt;b_p_iminsert = B_IMODE_NONE;</a>
<a name="ln2097">    curbuf-&gt;b_p_imsearch = B_IMODE_USE_INSERT;</a>
<a name="ln2098">  }</a>
<a name="ln2099"> </a>
<a name="ln2100">  return errmsg;</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">/// Process the updated 'autochdir' option value.</a>
<a name="ln2104">static const char *did_set_autochdir(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2105">{</a>
<a name="ln2106">  // Change directories when the 'acd' option is set now.</a>
<a name="ln2107">  do_autochdir();</a>
<a name="ln2108">  return NULL;</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">/// Process the updated 'binary' option value.</a>
<a name="ln2112">static const char *did_set_binary(optset_T *args)</a>
<a name="ln2113">{</a>
<a name="ln2114">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2115"> </a>
<a name="ln2116">  // when 'bin' is set also set some other options</a>
<a name="ln2117">  set_options_bin((int)args-&gt;os_oldval.boolean, buf-&gt;b_p_bin, args-&gt;os_flags);</a>
<a name="ln2118">  redraw_titles();</a>
<a name="ln2119"> </a>
<a name="ln2120">  return NULL;</a>
<a name="ln2121">}</a>
<a name="ln2122"> </a>
<a name="ln2123">/// Called when the 'breakat' option changes value.</a>
<a name="ln2124">static const char *did_set_breakat(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2125">{</a>
<a name="ln2126">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln2127">    breakat_flags[i] = false;</a>
<a name="ln2128">  }</a>
<a name="ln2129"> </a>
<a name="ln2130">  if (p_breakat != NULL) {</a>
<a name="ln2131">    for (char *p = p_breakat; *p; p++) {</a>
<a name="ln2132">      breakat_flags[(uint8_t)(*p)] = true;</a>
<a name="ln2133">    }</a>
<a name="ln2134">  }</a>
<a name="ln2135"> </a>
<a name="ln2136">  return NULL;</a>
<a name="ln2137">}</a>
<a name="ln2138"> </a>
<a name="ln2139">/// Process the updated 'buflisted' option value.</a>
<a name="ln2140">static const char *did_set_buflisted(optset_T *args)</a>
<a name="ln2141">{</a>
<a name="ln2142">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2143"> </a>
<a name="ln2144">  // when 'buflisted' changes, trigger autocommands</a>
<a name="ln2145">  if (args-&gt;os_oldval.boolean != buf-&gt;b_p_bl) {</a>
<a name="ln2146">    apply_autocmds(buf-&gt;b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,</a>
<a name="ln2147">                   NULL, NULL, true, buf);</a>
<a name="ln2148">  }</a>
<a name="ln2149">  return NULL;</a>
<a name="ln2150">}</a>
<a name="ln2151"> </a>
<a name="ln2152">/// Process the new 'cmdheight' option value.</a>
<a name="ln2153">static const char *did_set_cmdheight(optset_T *args)</a>
<a name="ln2154">{</a>
<a name="ln2155">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2156"> </a>
<a name="ln2157">  if (ui_has(kUIMessages)) {</a>
<a name="ln2158">    p_ch = 0;</a>
<a name="ln2159">  }</a>
<a name="ln2160">  if (p_ch &gt; Rows - min_rows() + 1) {</a>
<a name="ln2161">    p_ch = Rows - min_rows() + 1;</a>
<a name="ln2162">  }</a>
<a name="ln2163"> </a>
<a name="ln2164">  // if p_ch changed value, change the command line height</a>
<a name="ln2165">  // Only compute the new window layout when startup has been</a>
<a name="ln2166">  // completed. Otherwise the frame sizes may be wrong.</a>
<a name="ln2167">  if ((p_ch != old_value</a>
<a name="ln2168">       || tabline_height() + global_stl_height() + topframe-&gt;fr_height != Rows - p_ch)</a>
<a name="ln2169">      &amp;&amp; full_screen) {</a>
<a name="ln2170">    command_height();</a>
<a name="ln2171">  }</a>
<a name="ln2172"> </a>
<a name="ln2173">  return NULL;</a>
<a name="ln2174">}</a>
<a name="ln2175"> </a>
<a name="ln2176">/// Process the updated 'diff' option value.</a>
<a name="ln2177">static const char *did_set_diff(optset_T *args)</a>
<a name="ln2178">{</a>
<a name="ln2179">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2180">  // May add or remove the buffer from the list of diff buffers.</a>
<a name="ln2181">  diff_buf_adjust(win);</a>
<a name="ln2182">  if (foldmethodIsDiff(win)) {</a>
<a name="ln2183">    foldUpdateAll(win);</a>
<a name="ln2184">  }</a>
<a name="ln2185">  return NULL;</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">/// Process the updated 'endoffile' or 'endofline' or 'fixendofline' or 'bomb'</a>
<a name="ln2189">/// option value.</a>
<a name="ln2190">static const char *did_set_eof_eol_fixeol_bomb(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2191">{</a>
<a name="ln2192">  // redraw the window title and tab page text</a>
<a name="ln2193">  redraw_titles();</a>
<a name="ln2194">  return NULL;</a>
<a name="ln2195">}</a>
<a name="ln2196"> </a>
<a name="ln2197">/// Process the updated 'equalalways' option value.</a>
<a name="ln2198">static const char *did_set_equalalways(optset_T *args)</a>
<a name="ln2199">{</a>
<a name="ln2200">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2201">  if (p_ea &amp;&amp; !args-&gt;os_oldval.boolean) {</a>
<a name="ln2202">    win_equal(win, false, 0);</a>
<a name="ln2203">  }</a>
<a name="ln2204"> </a>
<a name="ln2205">  return NULL;</a>
<a name="ln2206">}</a>
<a name="ln2207"> </a>
<a name="ln2208">/// Process the new 'foldlevel' option value.</a>
<a name="ln2209">static const char *did_set_foldlevel(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2210">{</a>
<a name="ln2211">  newFoldLevel();</a>
<a name="ln2212">  return NULL;</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">/// Process the new 'foldminlines' option value.</a>
<a name="ln2216">static const char *did_set_foldminlines(optset_T *args)</a>
<a name="ln2217">{</a>
<a name="ln2218">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2219">  foldUpdateAll(win);</a>
<a name="ln2220">  return NULL;</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">/// Process the new 'foldnestmax' option value.</a>
<a name="ln2224">static const char *did_set_foldnestmax(optset_T *args)</a>
<a name="ln2225">{</a>
<a name="ln2226">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2227">  if (foldmethodIsSyntax(win) || foldmethodIsIndent(win)) {</a>
<a name="ln2228">    foldUpdateAll(win);</a>
<a name="ln2229">  }</a>
<a name="ln2230">  return NULL;</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">/// Process the new 'helpheight' option value.</a>
<a name="ln2234">static const char *did_set_helpheight(optset_T *args)</a>
<a name="ln2235">{</a>
<a name="ln2236">  // Change window height NOW</a>
<a name="ln2237">  if (!ONE_WINDOW) {</a>
<a name="ln2238">    buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2239">    win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2240">    if (buf-&gt;b_help &amp;&amp; win-&gt;w_height &lt; p_hh) {</a>
<a name="ln2241">      win_setheight((int)p_hh);</a>
<a name="ln2242">    }</a>
<a name="ln2243">  }</a>
<a name="ln2244"> </a>
<a name="ln2245">  return NULL;</a>
<a name="ln2246">}</a>
<a name="ln2247"> </a>
<a name="ln2248">/// Process the updated 'hlsearch' option value.</a>
<a name="ln2249">static const char *did_set_hlsearch(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2250">{</a>
<a name="ln2251">  // when 'hlsearch' is set or reset: reset no_hlsearch</a>
<a name="ln2252">  set_no_hlsearch(false);</a>
<a name="ln2253">  return NULL;</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256">/// Process the updated 'ignorecase' option value.</a>
<a name="ln2257">static const char *did_set_ignorecase(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2258">{</a>
<a name="ln2259">  // when 'ignorecase' is set or reset and 'hlsearch' is set, redraw</a>
<a name="ln2260">  if (p_hls) {</a>
<a name="ln2261">    redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln2262">  }</a>
<a name="ln2263">  return NULL;</a>
<a name="ln2264">}</a>
<a name="ln2265"> </a>
<a name="ln2266">/// Process the new 'iminset' option value.</a>
<a name="ln2267">static const char *did_set_iminsert(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2268">{</a>
<a name="ln2269">  showmode();</a>
<a name="ln2270">  // Show/unshow value of 'keymap' in status lines.</a>
<a name="ln2271">  status_redraw_curbuf();</a>
<a name="ln2272"> </a>
<a name="ln2273">  return NULL;</a>
<a name="ln2274">}</a>
<a name="ln2275"> </a>
<a name="ln2276">/// Process the updated 'langnoremap' option value.</a>
<a name="ln2277">static const char *did_set_langnoremap(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2278">{</a>
<a name="ln2279">  // 'langnoremap' -&gt; !'langremap'</a>
<a name="ln2280">  p_lrm = !p_lnr;</a>
<a name="ln2281">  return NULL;</a>
<a name="ln2282">}</a>
<a name="ln2283"> </a>
<a name="ln2284">/// Process the updated 'langremap' option value.</a>
<a name="ln2285">static const char *did_set_langremap(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2286">{</a>
<a name="ln2287">  // 'langremap' -&gt; !'langnoremap'</a>
<a name="ln2288">  p_lnr = !p_lrm;</a>
<a name="ln2289">  return NULL;</a>
<a name="ln2290">}</a>
<a name="ln2291"> </a>
<a name="ln2292">/// Process the new 'laststatus' option value.</a>
<a name="ln2293">static const char *did_set_laststatus(optset_T *args)</a>
<a name="ln2294">{</a>
<a name="ln2295">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2296">  OptInt value = args-&gt;os_newval.number;</a>
<a name="ln2297"> </a>
<a name="ln2298">  // When switching to global statusline, decrease topframe height</a>
<a name="ln2299">  // Also clear the cmdline to remove the ruler if there is one</a>
<a name="ln2300">  if (value == 3 &amp;&amp; old_value != 3) {</a>
<a name="ln2301">    frame_new_height(topframe, topframe-&gt;fr_height - STATUS_HEIGHT, false, false);</a>
<a name="ln2302">    (void)win_comp_pos();</a>
<a name="ln2303">    clear_cmdline = true;</a>
<a name="ln2304">  }</a>
<a name="ln2305">  // When switching from global statusline, increase height of topframe by STATUS_HEIGHT</a>
<a name="ln2306">  // in order to to re-add the space that was previously taken by the global statusline</a>
<a name="ln2307">  if (old_value == 3 &amp;&amp; value != 3) {</a>
<a name="ln2308">    frame_new_height(topframe, topframe-&gt;fr_height + STATUS_HEIGHT, false, false);</a>
<a name="ln2309">    (void)win_comp_pos();</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  last_status(false);  // (re)set last window status line.</a>
<a name="ln2313">  return NULL;</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316">/// Process the updated 'lisp' option value.</a>
<a name="ln2317">static const char *did_set_lisp(optset_T *args)</a>
<a name="ln2318">{</a>
<a name="ln2319">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2320">  // When 'lisp' option changes include/exclude '-' in keyword characters.</a>
<a name="ln2321">  (void)buf_init_chartab(buf, false);          // ignore errors</a>
<a name="ln2322">  return NULL;</a>
<a name="ln2323">}</a>
<a name="ln2324"> </a>
<a name="ln2325">/// Process the updated 'modifiable' option value.</a>
<a name="ln2326">static const char *did_set_modifiable(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2327">{</a>
<a name="ln2328">  // when 'modifiable' is changed, redraw the window title</a>
<a name="ln2329">  redraw_titles();</a>
<a name="ln2330"> </a>
<a name="ln2331">  return NULL;</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">/// Process the updated 'modified' option value.</a>
<a name="ln2335">static const char *did_set_modified(optset_T *args)</a>
<a name="ln2336">{</a>
<a name="ln2337">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2338">  if (!args-&gt;os_newval.boolean) {</a>
<a name="ln2339">    save_file_ff(buf);  // Buffer is unchanged</a>
<a name="ln2340">  }</a>
<a name="ln2341">  redraw_titles();</a>
<a name="ln2342">  modified_was_set = (int)args-&gt;os_newval.boolean;</a>
<a name="ln2343">  return NULL;</a>
<a name="ln2344">}</a>
<a name="ln2345"> </a>
<a name="ln2346">/// Process the updated 'number' or 'relativenumber' option value.</a>
<a name="ln2347">static const char *did_set_number_relativenumber(optset_T *args)</a>
<a name="ln2348">{</a>
<a name="ln2349">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2350">  if (*win-&gt;w_p_stc != NUL) {</a>
<a name="ln2351">    // When 'relativenumber'/'number' is changed and 'statuscolumn' is set, reset width.</a>
<a name="ln2352">    win-&gt;w_nrwidth_line_count = 0;</a>
<a name="ln2353">  }</a>
<a name="ln2354">  return NULL;</a>
<a name="ln2355">}</a>
<a name="ln2356"> </a>
<a name="ln2357">/// Process the new 'numberwidth' option value.</a>
<a name="ln2358">static const char *did_set_numberwidth(optset_T *args)</a>
<a name="ln2359">{</a>
<a name="ln2360">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2361">  win-&gt;w_nrwidth_line_count = 0;  // trigger a redraw</a>
<a name="ln2362"> </a>
<a name="ln2363">  return NULL;</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366">/// Process the updated 'paste' option value.</a>
<a name="ln2367">static const char *did_set_paste(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2368">{</a>
<a name="ln2369">  static int old_p_paste = false;</a>
<a name="ln2370">  static int save_sm = 0;</a>
<a name="ln2371">  static int save_sta = 0;</a>
<a name="ln2372">  static int save_ru = 0;</a>
<a name="ln2373">  static int save_ri = 0;</a>
<a name="ln2374"> </a>
<a name="ln2375">  if (p_paste) {</a>
<a name="ln2376">    // Paste switched from off to on.</a>
<a name="ln2377">    // Save the current values, so they can be restored later.</a>
<a name="ln2378">    if (!old_p_paste) {</a>
<a name="ln2379">      // save options for each buffer</a>
<a name="ln2380">      FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2381">        buf-&gt;b_p_tw_nopaste = buf-&gt;b_p_tw;</a>
<a name="ln2382">        buf-&gt;b_p_wm_nopaste = buf-&gt;b_p_wm;</a>
<a name="ln2383">        buf-&gt;b_p_sts_nopaste = buf-&gt;b_p_sts;</a>
<a name="ln2384">        buf-&gt;b_p_ai_nopaste = buf-&gt;b_p_ai;</a>
<a name="ln2385">        buf-&gt;b_p_et_nopaste = buf-&gt;b_p_et;</a>
<a name="ln2386">        if (buf-&gt;b_p_vsts_nopaste) {</a>
<a name="ln2387">          xfree(buf-&gt;b_p_vsts_nopaste);</a>
<a name="ln2388">        }</a>
<a name="ln2389">        buf-&gt;b_p_vsts_nopaste = buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option</a>
<a name="ln2390">                                    ? xstrdup(buf-&gt;b_p_vsts)</a>
<a name="ln2391">                                    : NULL;</a>
<a name="ln2392">      }</a>
<a name="ln2393"> </a>
<a name="ln2394">      // save global options</a>
<a name="ln2395">      save_sm = p_sm;</a>
<a name="ln2396">      save_sta = p_sta;</a>
<a name="ln2397">      save_ru = p_ru;</a>
<a name="ln2398">      save_ri = p_ri;</a>
<a name="ln2399">      // save global values for local buffer options</a>
<a name="ln2400">      p_ai_nopaste = p_ai;</a>
<a name="ln2401">      p_et_nopaste = p_et;</a>
<a name="ln2402">      p_sts_nopaste = p_sts;</a>
<a name="ln2403">      p_tw_nopaste = p_tw;</a>
<a name="ln2404">      p_wm_nopaste = p_wm;</a>
<a name="ln2405">      if (p_vsts_nopaste) {</a>
<a name="ln2406">        xfree(p_vsts_nopaste);</a>
<a name="ln2407">      }</a>
<a name="ln2408">      p_vsts_nopaste = p_vsts &amp;&amp; p_vsts != empty_option ? xstrdup(p_vsts) : NULL;</a>
<a name="ln2409">    }</a>
<a name="ln2410"> </a>
<a name="ln2411">    // Always set the option values, also when 'paste' is set when it is</a>
<a name="ln2412">    // already on.</a>
<a name="ln2413">    // set options for each buffer</a>
<a name="ln2414">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2415">      buf-&gt;b_p_tw = 0;              // textwidth is 0</a>
<a name="ln2416">      buf-&gt;b_p_wm = 0;              // wrapmargin is 0</a>
<a name="ln2417">      buf-&gt;b_p_sts = 0;             // softtabstop is 0</a>
<a name="ln2418">      buf-&gt;b_p_ai = 0;              // no auto-indent</a>
<a name="ln2419">      buf-&gt;b_p_et = 0;              // no expandtab</a>
<a name="ln2420">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln2421">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln2422">      }</a>
<a name="ln2423">      buf-&gt;b_p_vsts = empty_option;</a>
<a name="ln2424">      XFREE_CLEAR(buf-&gt;b_p_vsts_array);</a>
<a name="ln2425">    }</a>
<a name="ln2426"> </a>
<a name="ln2427">    // set global options</a>
<a name="ln2428">    p_sm = 0;                       // no showmatch</a>
<a name="ln2429">    p_sta = 0;                      // no smarttab</a>
<a name="ln2430">    if (p_ru) {</a>
<a name="ln2431">      status_redraw_all();          // redraw to remove the ruler</a>
<a name="ln2432">    }</a>
<a name="ln2433">    p_ru = 0;                       // no ruler</a>
<a name="ln2434">    p_ri = 0;                       // no reverse insert</a>
<a name="ln2435">    // set global values for local buffer options</a>
<a name="ln2436">    p_tw = 0;</a>
<a name="ln2437">    p_wm = 0;</a>
<a name="ln2438">    p_sts = 0;</a>
<a name="ln2439">    p_ai = 0;</a>
<a name="ln2440">    p_et = 0;</a>
<a name="ln2441">    if (p_vsts) {</a>
<a name="ln2442">      free_string_option(p_vsts);</a>
<a name="ln2443">    }</a>
<a name="ln2444">    p_vsts = empty_option;</a>
<a name="ln2445">  } else if (old_p_paste) {</a>
<a name="ln2446">    // Paste switched from on to off: Restore saved values.</a>
<a name="ln2447"> </a>
<a name="ln2448">    // restore options for each buffer</a>
<a name="ln2449">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2450">      buf-&gt;b_p_tw = buf-&gt;b_p_tw_nopaste;</a>
<a name="ln2451">      buf-&gt;b_p_wm = buf-&gt;b_p_wm_nopaste;</a>
<a name="ln2452">      buf-&gt;b_p_sts = buf-&gt;b_p_sts_nopaste;</a>
<a name="ln2453">      buf-&gt;b_p_ai = buf-&gt;b_p_ai_nopaste;</a>
<a name="ln2454">      buf-&gt;b_p_et = buf-&gt;b_p_et_nopaste;</a>
<a name="ln2455">      if (buf-&gt;b_p_vsts) {</a>
<a name="ln2456">        free_string_option(buf-&gt;b_p_vsts);</a>
<a name="ln2457">      }</a>
<a name="ln2458">      buf-&gt;b_p_vsts = buf-&gt;b_p_vsts_nopaste ? xstrdup(buf-&gt;b_p_vsts_nopaste) : empty_option;</a>
<a name="ln2459">      xfree(buf-&gt;b_p_vsts_array);</a>
<a name="ln2460">      if (buf-&gt;b_p_vsts &amp;&amp; buf-&gt;b_p_vsts != empty_option) {</a>
<a name="ln2461">        (void)tabstop_set(buf-&gt;b_p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln2462">      } else {</a>
<a name="ln2463">        buf-&gt;b_p_vsts_array = NULL;</a>
<a name="ln2464">      }</a>
<a name="ln2465">    }</a>
<a name="ln2466"> </a>
<a name="ln2467">    // restore global options</a>
<a name="ln2468">    p_sm = save_sm;</a>
<a name="ln2469">    p_sta = save_sta;</a>
<a name="ln2470">    if (p_ru != save_ru) {</a>
<a name="ln2471">      status_redraw_all();          // redraw to draw the ruler</a>
<a name="ln2472">    }</a>
<a name="ln2473">    p_ru = save_ru;</a>
<a name="ln2474">    p_ri = save_ri;</a>
<a name="ln2475">    // set global values for local buffer options</a>
<a name="ln2476">    p_ai = p_ai_nopaste;</a>
<a name="ln2477">    p_et = p_et_nopaste;</a>
<a name="ln2478">    p_sts = p_sts_nopaste;</a>
<a name="ln2479">    p_tw = p_tw_nopaste;</a>
<a name="ln2480">    p_wm = p_wm_nopaste;</a>
<a name="ln2481">    if (p_vsts) {</a>
<a name="ln2482">      free_string_option(p_vsts);</a>
<a name="ln2483">    }</a>
<a name="ln2484">    p_vsts = p_vsts_nopaste ? xstrdup(p_vsts_nopaste) : empty_option;</a>
<a name="ln2485">  }</a>
<a name="ln2486"> </a>
<a name="ln2487">  old_p_paste = p_paste;</a>
<a name="ln2488"> </a>
<a name="ln2489">  // Remember where the dependent options were reset</a>
<a name="ln2490">  didset_options_sctx((OPT_LOCAL | OPT_GLOBAL), p_paste_dep_opts);</a>
<a name="ln2491"> </a>
<a name="ln2492">  return NULL;</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495">/// Process the updated 'previewwindow' option value.</a>
<a name="ln2496">static const char *did_set_previewwindow(optset_T *args)</a>
<a name="ln2497">{</a>
<a name="ln2498">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2499"> </a>
<a name="ln2500">  if (!win-&gt;w_p_pvw) {</a>
<a name="ln2501">    return NULL;</a>
<a name="ln2502">  }</a>
<a name="ln2503"> </a>
<a name="ln2504">  // There can be only one window with 'previewwindow' set.</a>
<a name="ln2505">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2506">    if (wp-&gt;w_p_pvw &amp;&amp; wp != win) {</a>
<a name="ln2507">      win-&gt;w_p_pvw = false;</a>
<a name="ln2508">      args-&gt;os_doskip = true;</a>
<a name="ln2509">      return e_preview_window_already_exists;</a>
<a name="ln2510">    }</a>
<a name="ln2511">  }</a>
<a name="ln2512"> </a>
<a name="ln2513">  return NULL;</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">/// Process the new 'pumblend' option value.</a>
<a name="ln2517">static const char *did_set_pumblend(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2518">{</a>
<a name="ln2519">  p_pb = MAX(MIN(p_pb, 100), 0);</a>
<a name="ln2520">  hl_invalidate_blends();</a>
<a name="ln2521">  pum_grid.blending = (p_pb &gt; 0);</a>
<a name="ln2522">  if (pum_drawn()) {</a>
<a name="ln2523">    pum_redraw();</a>
<a name="ln2524">  }</a>
<a name="ln2525"> </a>
<a name="ln2526">  return NULL;</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">/// Process the updated 'readonly' option value.</a>
<a name="ln2530">static const char *did_set_readonly(optset_T *args)</a>
<a name="ln2531">{</a>
<a name="ln2532">  // when 'readonly' is reset globally, also reset readonlymode</a>
<a name="ln2533">  if (!curbuf-&gt;b_p_ro &amp;&amp; (args-&gt;os_flags &amp; OPT_LOCAL) == 0) {</a>
<a name="ln2534">    readonlymode = false;</a>
<a name="ln2535">  }</a>
<a name="ln2536"> </a>
<a name="ln2537">  // when 'readonly' is set may give W10 again</a>
<a name="ln2538">  if (curbuf-&gt;b_p_ro) {</a>
<a name="ln2539">    curbuf-&gt;b_did_warn = false;</a>
<a name="ln2540">  }</a>
<a name="ln2541"> </a>
<a name="ln2542">  redraw_titles();</a>
<a name="ln2543"> </a>
<a name="ln2544">  return NULL;</a>
<a name="ln2545">}</a>
<a name="ln2546"> </a>
<a name="ln2547">/// Process the new 'scrollback' option value.</a>
<a name="ln2548">static const char *did_set_scrollback(optset_T *args)</a>
<a name="ln2549">{</a>
<a name="ln2550">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2551">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2552">  OptInt value = args-&gt;os_newval.number;</a>
<a name="ln2553"> </a>
<a name="ln2554">  if (buf-&gt;terminal &amp;&amp; value &lt; old_value) {</a>
<a name="ln2555">    // Force the scrollback to take immediate effect only when decreasing it.</a>
<a name="ln2556">    on_scrollback_option_changed(buf-&gt;terminal);</a>
<a name="ln2557">  }</a>
<a name="ln2558">  return NULL;</a>
<a name="ln2559">}</a>
<a name="ln2560"> </a>
<a name="ln2561">/// Process the updated 'scrollbind' option value.</a>
<a name="ln2562">static const char *did_set_scrollbind(optset_T *args)</a>
<a name="ln2563">{</a>
<a name="ln2564">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2565"> </a>
<a name="ln2566">  // when 'scrollbind' is set: snapshot the current position to avoid a jump</a>
<a name="ln2567">  // at the end of normal_cmd()</a>
<a name="ln2568">  if (!win-&gt;w_p_scb) {</a>
<a name="ln2569">    return NULL;</a>
<a name="ln2570">  }</a>
<a name="ln2571">  do_check_scrollbind(false);</a>
<a name="ln2572">  win-&gt;w_scbind_pos = win-&gt;w_topline;</a>
<a name="ln2573">  return NULL;</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2577">/// Process the updated 'shellslash' option value.</a>
<a name="ln2578">static const char *did_set_shellslash(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2579">{</a>
<a name="ln2580">  if (p_ssl) {</a>
<a name="ln2581">    psepc = '/';</a>
<a name="ln2582">    psepcN = '\\';</a>
<a name="ln2583">    pseps[0] = '/';</a>
<a name="ln2584">  } else {</a>
<a name="ln2585">    psepc = '\\';</a>
<a name="ln2586">    psepcN = '/';</a>
<a name="ln2587">    pseps[0] = '\\';</a>
<a name="ln2588">  }</a>
<a name="ln2589"> </a>
<a name="ln2590">  // need to adjust the file name arguments and buffer names.</a>
<a name="ln2591">  buflist_slash_adjust();</a>
<a name="ln2592">  alist_slash_adjust();</a>
<a name="ln2593">  scriptnames_slash_adjust();</a>
<a name="ln2594">  return NULL;</a>
<a name="ln2595">}</a>
<a name="ln2596">#endif</a>
<a name="ln2597"> </a>
<a name="ln2598">/// Process the new 'shiftwidth' or the 'tabstop' option value.</a>
<a name="ln2599">static const char *did_set_shiftwidth_tabstop(optset_T *args)</a>
<a name="ln2600">{</a>
<a name="ln2601">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2602">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2603">  OptInt *pp = (OptInt *)args-&gt;os_varp;</a>
<a name="ln2604"> </a>
<a name="ln2605">  if (foldmethodIsIndent(win)) {</a>
<a name="ln2606">    foldUpdateAll(win);</a>
<a name="ln2607">  }</a>
<a name="ln2608">  // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:</a>
<a name="ln2609">  // parse 'cinoptions'.</a>
<a name="ln2610">  if (pp == &amp;buf-&gt;b_p_sw || buf-&gt;b_p_sw == 0) {</a>
<a name="ln2611">    parse_cino(buf);</a>
<a name="ln2612">  }</a>
<a name="ln2613"> </a>
<a name="ln2614">  return NULL;</a>
<a name="ln2615">}</a>
<a name="ln2616"> </a>
<a name="ln2617">/// Process the new 'showtabline' option value.</a>
<a name="ln2618">static const char *did_set_showtabline(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2619">{</a>
<a name="ln2620">  // (re)set tab page line</a>
<a name="ln2621">  win_new_screen_rows();  // recompute window positions and heights</a>
<a name="ln2622">  return NULL;</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625">/// Process the updated 'smoothscroll' option value.</a>
<a name="ln2626">static const char *did_set_smoothscroll(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2627">{</a>
<a name="ln2628">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2629">  if (win-&gt;w_p_sms) {</a>
<a name="ln2630">    return NULL;</a>
<a name="ln2631">  }</a>
<a name="ln2632"> </a>
<a name="ln2633">  win-&gt;w_skipcol = 0;</a>
<a name="ln2634">  changed_line_abv_curs_win(win);</a>
<a name="ln2635">  return NULL;</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">/// Process the updated 'spell' option value.</a>
<a name="ln2639">static const char *did_set_spell(optset_T *args)</a>
<a name="ln2640">{</a>
<a name="ln2641">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2642">  if (win-&gt;w_p_spell) {</a>
<a name="ln2643">    return parse_spelllang(win);</a>
<a name="ln2644">  }</a>
<a name="ln2645"> </a>
<a name="ln2646">  return NULL;</a>
<a name="ln2647">}</a>
<a name="ln2648"> </a>
<a name="ln2649">/// Process the updated 'swapfile' option value.</a>
<a name="ln2650">static const char *did_set_swapfile(optset_T *args)</a>
<a name="ln2651">{</a>
<a name="ln2652">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2653">  // when 'swf' is set, create swapfile, when reset remove swapfile</a>
<a name="ln2654">  if (buf-&gt;b_p_swf &amp;&amp; p_uc) {</a>
<a name="ln2655">    ml_open_file(buf);                     // create the swap file</a>
<a name="ln2656">  } else {</a>
<a name="ln2657">    // no need to reset curbuf-&gt;b_may_swap, ml_open_file() will check</a>
<a name="ln2658">    // buf-&gt;b_p_swf</a>
<a name="ln2659">    mf_close_file(buf, true);              // remove the swap file</a>
<a name="ln2660">  }</a>
<a name="ln2661">  return NULL;</a>
<a name="ln2662">}</a>
<a name="ln2663"> </a>
<a name="ln2664">/// Process the new 'textwidth' option value.</a>
<a name="ln2665">static const char *did_set_textwidth(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2666">{</a>
<a name="ln2667">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln2668">    check_colorcolumn(wp);</a>
<a name="ln2669">  }</a>
<a name="ln2670"> </a>
<a name="ln2671">  return NULL;</a>
<a name="ln2672">}</a>
<a name="ln2673"> </a>
<a name="ln2674">/// Process the updated 'title' or the 'icon' option value.</a>
<a name="ln2675">static const char *did_set_title_icon(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2676">{</a>
<a name="ln2677">  // when 'title' changed, may need to change the title; same for 'icon'</a>
<a name="ln2678">  did_set_title();</a>
<a name="ln2679">  return NULL;</a>
<a name="ln2680">}</a>
<a name="ln2681"> </a>
<a name="ln2682">/// Process the new 'titlelen' option value.</a>
<a name="ln2683">static const char *did_set_titlelen(optset_T *args)</a>
<a name="ln2684">{</a>
<a name="ln2685">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2686"> </a>
<a name="ln2687">  // if 'titlelen' has changed, redraw the title</a>
<a name="ln2688">  if (starting != NO_SCREEN &amp;&amp; old_value != p_titlelen) {</a>
<a name="ln2689">    need_maketitle = true;</a>
<a name="ln2690">  }</a>
<a name="ln2691"> </a>
<a name="ln2692">  return NULL;</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695">/// Process the updated 'undofile' option value.</a>
<a name="ln2696">static const char *did_set_undofile(optset_T *args)</a>
<a name="ln2697">{</a>
<a name="ln2698">  // Only take action when the option was set.</a>
<a name="ln2699">  if (!curbuf-&gt;b_p_udf &amp;&amp; !p_udf) {</a>
<a name="ln2700">    return NULL;</a>
<a name="ln2701">  }</a>
<a name="ln2702"> </a>
<a name="ln2703">  // When reset we do not delete the undo file, the option may be set again</a>
<a name="ln2704">  // without making any changes in between.</a>
<a name="ln2705">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln2706"> </a>
<a name="ln2707">  FOR_ALL_BUFFERS(bp) {</a>
<a name="ln2708">    // When 'undofile' is set globally: for every buffer, otherwise</a>
<a name="ln2709">    // only for the current buffer: Try to read in the undofile,</a>
<a name="ln2710">    // if one exists, the buffer wasn't changed and the buffer was</a>
<a name="ln2711">    // loaded</a>
<a name="ln2712">    if ((curbuf == bp</a>
<a name="ln2713">         || (args-&gt;os_flags &amp; OPT_GLOBAL) || args-&gt;os_flags == 0)</a>
<a name="ln2714">        &amp;&amp; !bufIsChanged(bp) &amp;&amp; bp-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln2715">      u_compute_hash(bp, hash);</a>
<a name="ln2716">      u_read_undo(NULL, hash, bp-&gt;b_fname);</a>
<a name="ln2717">    }</a>
<a name="ln2718">  }</a>
<a name="ln2719"> </a>
<a name="ln2720">  return NULL;</a>
<a name="ln2721">}</a>
<a name="ln2722"> </a>
<a name="ln2723">/// Process the new global 'undolevels' option value.</a>
<a name="ln2724">const char *did_set_global_undolevels(OptInt value, OptInt old_value)</a>
<a name="ln2725">{</a>
<a name="ln2726">  // sync undo before 'undolevels' changes</a>
<a name="ln2727">  // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln2728">  p_ul = old_value;</a>
<a name="ln2729">  u_sync(true);</a>
<a name="ln2730">  p_ul = value;</a>
<a name="ln2731">  return NULL;</a>
<a name="ln2732">}</a>
<a name="ln2733"> </a>
<a name="ln2734">/// Process the new buffer local 'undolevels' option value.</a>
<a name="ln2735">const char *did_set_buflocal_undolevels(buf_T *buf, OptInt value, OptInt old_value)</a>
<a name="ln2736">{</a>
<a name="ln2737">  // use the old value, otherwise u_sync() may not work properly</a>
<a name="ln2738">  buf-&gt;b_p_ul = old_value;</a>
<a name="ln2739">  u_sync(true);</a>
<a name="ln2740">  buf-&gt;b_p_ul = value;</a>
<a name="ln2741">  return NULL;</a>
<a name="ln2742">}</a>
<a name="ln2743"> </a>
<a name="ln2744">/// Process the new 'undolevels' option value.</a>
<a name="ln2745">static const char *did_set_undolevels(optset_T *args)</a>
<a name="ln2746">{</a>
<a name="ln2747">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2748">  OptInt *pp = (OptInt *)args-&gt;os_varp;</a>
<a name="ln2749"> </a>
<a name="ln2750">  if (pp == &amp;p_ul) {                  // global 'undolevels'</a>
<a name="ln2751">    did_set_global_undolevels(args-&gt;os_newval.number, args-&gt;os_oldval.number);</a>
<a name="ln2752">  } else if (pp == &amp;curbuf-&gt;b_p_ul) {      // buffer local 'undolevels'</a>
<a name="ln2753">    did_set_buflocal_undolevels(buf, args-&gt;os_newval.number, args-&gt;os_oldval.number);</a>
<a name="ln2754">  }</a>
<a name="ln2755"> </a>
<a name="ln2756">  return NULL;</a>
<a name="ln2757">}</a>
<a name="ln2758"> </a>
<a name="ln2759">/// Process the new 'updatecount' option value.</a>
<a name="ln2760">static const char *did_set_updatecount(optset_T *args)</a>
<a name="ln2761">{</a>
<a name="ln2762">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2763"> </a>
<a name="ln2764">  // when 'updatecount' changes from zero to non-zero, open swap files</a>
<a name="ln2765">  if (p_uc &amp;&amp; !old_value) {</a>
<a name="ln2766">    ml_open_files();</a>
<a name="ln2767">  }</a>
<a name="ln2768"> </a>
<a name="ln2769">  return NULL;</a>
<a name="ln2770">}</a>
<a name="ln2771"> </a>
<a name="ln2772">/// Process the new 'winblend' option value.</a>
<a name="ln2773">static const char *did_set_winblend(optset_T *args)</a>
<a name="ln2774">{</a>
<a name="ln2775">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2776">  OptInt old_value = args-&gt;os_oldval.number;</a>
<a name="ln2777">  OptInt value = args-&gt;os_newval.number;</a>
<a name="ln2778"> </a>
<a name="ln2779">  if (value != old_value) {</a>
<a name="ln2780">    win-&gt;w_p_winbl = MAX(MIN(win-&gt;w_p_winbl, 100), 0);</a>
<a name="ln2781">    win-&gt;w_hl_needs_update = true;</a>
<a name="ln2782">    check_blending(curwin);</a>
<a name="ln2783">  }</a>
<a name="ln2784"> </a>
<a name="ln2785">  return NULL;</a>
<a name="ln2786">}</a>
<a name="ln2787"> </a>
<a name="ln2788">/// Process the new 'window' option value.</a>
<a name="ln2789">static const char *did_set_window(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2790">{</a>
<a name="ln2791">  if (p_window &lt; 1) {</a>
<a name="ln2792">    p_window = Rows - 1;</a>
<a name="ln2793">  } else if (p_window &gt;= Rows) {</a>
<a name="ln2794">    p_window = Rows - 1;</a>
<a name="ln2795">  }</a>
<a name="ln2796">  return NULL;</a>
<a name="ln2797">}</a>
<a name="ln2798"> </a>
<a name="ln2799">/// Process the new 'winheight' value.</a>
<a name="ln2800">static const char *did_set_winheight(optset_T *args)</a>
<a name="ln2801">{</a>
<a name="ln2802">  // Change window height NOW</a>
<a name="ln2803">  if (!ONE_WINDOW) {</a>
<a name="ln2804">    win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2805">    if (win-&gt;w_height &lt; p_wh) {</a>
<a name="ln2806">      win_setheight((int)p_wh);</a>
<a name="ln2807">    }</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  return NULL;</a>
<a name="ln2811">}</a>
<a name="ln2812"> </a>
<a name="ln2813">/// Process the new 'winwidth' option value.</a>
<a name="ln2814">static const char *did_set_winwidth(optset_T *args)</a>
<a name="ln2815">{</a>
<a name="ln2816">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2817"> </a>
<a name="ln2818">  if (!ONE_WINDOW &amp;&amp; win-&gt;w_width &lt; p_wiw) {</a>
<a name="ln2819">    win_setwidth((int)p_wiw);</a>
<a name="ln2820">  }</a>
<a name="ln2821">  return NULL;</a>
<a name="ln2822">}</a>
<a name="ln2823"> </a>
<a name="ln2824">/// Process the updated 'wrap' option value.</a>
<a name="ln2825">static const char *did_set_wrap(optset_T *args)</a>
<a name="ln2826">{</a>
<a name="ln2827">  win_T *win = (win_T *)args-&gt;os_win;</a>
<a name="ln2828"> </a>
<a name="ln2829">  // If 'wrap' is set, set w_leftcol to zero.</a>
<a name="ln2830">  if (win-&gt;w_p_wrap) {</a>
<a name="ln2831">    win-&gt;w_leftcol = 0;</a>
<a name="ln2832">  }</a>
<a name="ln2833">  return NULL;</a>
<a name="ln2834">}</a>
<a name="ln2835"> </a>
<a name="ln2836">/// Set the value of a boolean option, taking care of side effects</a>
<a name="ln2837">///</a>
<a name="ln2838">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln2839">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln2840">/// @param[in]  value  New value.</a>
<a name="ln2841">/// @param[in]  opt_flags  OPT_LOCAL and/or OPT_GLOBAL.</a>
<a name="ln2842">///</a>
<a name="ln2843">/// @return NULL on success, error message on error.</a>
<a name="ln2844">static const char *set_bool_option(const int opt_idx, char *const varp, const int value,</a>
<a name="ln2845">                                   const int opt_flags)</a>
<a name="ln2846">{</a>
<a name="ln2847">  int old_value = *(int *)varp;</a>
<a name="ln2848">  int old_global_value = 0;</a>
<a name="ln2849"> </a>
<a name="ln2850">  // Disallow changing some options from secure mode</a>
<a name="ln2851">  if ((secure || sandbox != 0)</a>
<a name="ln2852">      &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln2853">    return e_secure;</a>
<a name="ln2854">  }</a>
<a name="ln2855"> </a>
<a name="ln2856">  // Save the global value before changing anything. This is needed as for</a>
<a name="ln2857">  // a global-only option setting the &quot;local value&quot; in fact sets the global</a>
<a name="ln2858">  // value (since there is only one value).</a>
<a name="ln2859">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2860">    old_global_value = *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln2861">  }</a>
<a name="ln2862"> </a>
<a name="ln2863">  *(int *)varp = value;             // set the new value</a>
<a name="ln2864">  // Remember where the option was set.</a>
<a name="ln2865">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln2866"> </a>
<a name="ln2867">  // May set global value for local option.</a>
<a name="ln2868">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln2869">    *(int *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = value;</a>
<a name="ln2870">  }</a>
<a name="ln2871"> </a>
<a name="ln2872">  // Handle side effects for changing a bool option.</a>
<a name="ln2873">  const char *errmsg = NULL;</a>
<a name="ln2874">  bool doskip = false;</a>
<a name="ln2875">  if ((int *)varp == &amp;p_force_on) {</a>
<a name="ln2876">    errmsg = did_set_force_on(&amp;doskip);</a>
<a name="ln2877">  } else if ((int *)varp == &amp;p_force_off) {</a>
<a name="ln2878">    errmsg = did_set_force_off(&amp;doskip);</a>
<a name="ln2879">  } else if (options[opt_idx].opt_did_set_cb != NULL) {</a>
<a name="ln2880">    optset_T args = {</a>
<a name="ln2881">      .os_varp = varp,</a>
<a name="ln2882">      .os_flags = opt_flags,</a>
<a name="ln2883">      .os_oldval.boolean = old_value,</a>
<a name="ln2884">      .os_newval.boolean = value,</a>
<a name="ln2885">      .os_doskip = false,</a>
<a name="ln2886">      .os_errbuf = NULL,</a>
<a name="ln2887">      .os_errbuflen = 0,</a>
<a name="ln2888">      .os_buf = curbuf,</a>
<a name="ln2889">      .os_win = curwin</a>
<a name="ln2890">    };</a>
<a name="ln2891"> </a>
<a name="ln2892">    errmsg = options[opt_idx].opt_did_set_cb(&amp;args);</a>
<a name="ln2893">    doskip = args.os_doskip;</a>
<a name="ln2894">  }</a>
<a name="ln2895">  if (doskip) {</a>
<a name="ln2896">    return errmsg;</a>
<a name="ln2897">  }</a>
<a name="ln2898"> </a>
<a name="ln2899">  // after handling side effects, call autocommand</a>
<a name="ln2900"> </a>
<a name="ln2901">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln2902"> </a>
<a name="ln2903">  apply_optionset_autocmd(opt_idx, opt_flags,</a>
<a name="ln2904">                          (long)(old_value ? true : false),</a>
<a name="ln2905">                          (long)(old_global_value ? true : false),</a>
<a name="ln2906">                          (long)(value ? true : false), NULL);</a>
<a name="ln2907"> </a>
<a name="ln2908">  if (options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln2909">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln2910">                       BOOLEAN_OBJ(*varp));</a>
<a name="ln2911">  }</a>
<a name="ln2912">  if ((int *)varp == &amp;p_ru || (int *)varp == &amp;p_sc) {</a>
<a name="ln2913">    // in case 'ruler' or 'showcmd' changed</a>
<a name="ln2914">    comp_col();</a>
<a name="ln2915">  }</a>
<a name="ln2916">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln2917">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln2918">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln2919">  }</a>
<a name="ln2920">  check_redraw(options[opt_idx].flags);</a>
<a name="ln2921"> </a>
<a name="ln2922">  return errmsg;</a>
<a name="ln2923">}</a>
<a name="ln2924"> </a>
<a name="ln2925">/// Check the bounds of numeric options.</a>
<a name="ln2926">static const char *check_num_option_bounds(OptInt *pp, OptInt old_value, long old_Rows,</a>
<a name="ln2927">                                           char *errbuf, size_t errbuflen, const char *errmsg)</a>
<a name="ln2928">{</a>
<a name="ln2929">  // Check the (new) bounds for Rows and Columns here.</a>
<a name="ln2930">  if (p_lines &lt; min_rows() &amp;&amp; full_screen) {</a>
<a name="ln2931">    if (errbuf != NULL) {</a>
<a name="ln2932">      vim_snprintf(errbuf, errbuflen, _(&quot;E593: Need at least %d lines&quot;), min_rows());</a>
<a name="ln2933">      errmsg = errbuf;</a>
<a name="ln2934">    }</a>
<a name="ln2935">    p_lines = min_rows();</a>
<a name="ln2936">  }</a>
<a name="ln2937">  if (p_columns &lt; MIN_COLUMNS &amp;&amp; full_screen) {</a>
<a name="ln2938">    if (errbuf != NULL) {</a>
<a name="ln2939">      vim_snprintf(errbuf, errbuflen, _(&quot;E594: Need at least %d columns&quot;), MIN_COLUMNS);</a>
<a name="ln2940">      errmsg = errbuf;</a>
<a name="ln2941">    }</a>
<a name="ln2942">    p_columns = MIN_COLUMNS;</a>
<a name="ln2943">  }</a>
<a name="ln2944"> </a>
<a name="ln2945">  // True max size is defined by check_screensize()</a>
<a name="ln2946">  p_lines = MIN(p_lines, INT_MAX);</a>
<a name="ln2947">  p_columns = MIN(p_columns, INT_MAX);</a>
<a name="ln2948"> </a>
<a name="ln2949">  // If the screen (shell) height has been changed, assume it is the</a>
<a name="ln2950">  // physical screenheight.</a>
<a name="ln2951">  if (p_lines != Rows || p_columns != Columns) {</a>
<a name="ln2952">    // Changing the screen size is not allowed while updating the screen.</a>
<a name="ln2953">    if (updating_screen) {</a>
<a name="ln2954">      *pp = old_value;</a>
<a name="ln2955">    } else if (full_screen) {</a>
<a name="ln2956">      screen_resize((int)p_columns, (int)p_lines);</a>
<a name="ln2957">    } else {</a>
<a name="ln2958">      // TODO(bfredl): is this branch ever needed?</a>
<a name="ln2959">      // Postpone the resizing; check the size and cmdline position for</a>
<a name="ln2960">      // messages.</a>
<a name="ln2961">      Rows = (int)p_lines;</a>
<a name="ln2962">      Columns = (int)p_columns;</a>
<a name="ln2963">      check_screensize();</a>
<a name="ln2964">      int new_row = (int)(Rows - MAX(p_ch, 1));</a>
<a name="ln2965">      if (cmdline_row &gt; new_row &amp;&amp; Rows &gt; p_ch) {</a>
<a name="ln2966">        assert(p_ch &gt;= 0 &amp;&amp; new_row &lt;= INT_MAX);</a>
<a name="ln2967">        cmdline_row = new_row;</a>
<a name="ln2968">      }</a>
<a name="ln2969">    }</a>
<a name="ln2970">    if (p_window &gt;= Rows || !option_was_set(&quot;window&quot;)) {</a>
<a name="ln2971">      p_window = Rows - 1;</a>
<a name="ln2972">    }</a>
<a name="ln2973">  }</a>
<a name="ln2974"> </a>
<a name="ln2975">  if ((curwin-&gt;w_p_scr &lt;= 0 || (curwin-&gt;w_p_scr &gt; curwin-&gt;w_height &amp;&amp; curwin-&gt;w_height &gt; 0))</a>
<a name="ln2976">      &amp;&amp; full_screen) {</a>
<a name="ln2977">    if (pp == &amp;(curwin-&gt;w_p_scr)) {</a>
<a name="ln2978">      if (curwin-&gt;w_p_scr != 0) {</a>
<a name="ln2979">        errmsg = e_scroll;</a>
<a name="ln2980">      }</a>
<a name="ln2981">      win_comp_scroll(curwin);</a>
<a name="ln2982">    } else if (curwin-&gt;w_p_scr &lt;= 0) {</a>
<a name="ln2983">      // If 'scroll' became invalid because of a side effect silently adjust it.</a>
<a name="ln2984">      curwin-&gt;w_p_scr = 1;</a>
<a name="ln2985">    } else {  // curwin-&gt;w_p_scr &gt; curwin-&gt;w_height</a>
<a name="ln2986">      curwin-&gt;w_p_scr = curwin-&gt;w_height;</a>
<a name="ln2987">    }</a>
<a name="ln2988">  }</a>
<a name="ln2989">  if ((p_sj &lt; -100 || p_sj &gt;= Rows) &amp;&amp; full_screen) {</a>
<a name="ln2990">    if (Rows != old_Rows) {  // Rows changed, just adjust p_sj</a>
<a name="ln2991">      p_sj = Rows / 2;</a>
<a name="ln2992">    } else {</a>
<a name="ln2993">      errmsg = e_scroll;</a>
<a name="ln2994">      p_sj = 1;</a>
<a name="ln2995">    }</a>
<a name="ln2996">  }</a>
<a name="ln2997"> </a>
<a name="ln2998">  return errmsg;</a>
<a name="ln2999">}</a>
<a name="ln3000"> </a>
<a name="ln3001">/// Options that need some validation.</a>
<a name="ln3002">static const char *validate_num_option(const OptInt *pp, long *valuep)</a>
<a name="ln3003">{</a>
<a name="ln3004">  long value = *valuep;</a>
<a name="ln3005"> </a>
<a name="ln3006">  // Many number options assume their value is in the signed int range.</a>
<a name="ln3007">  if (value &lt; INT_MIN || value &gt; INT_MAX) {</a>
<a name="ln3008">    return e_invarg;</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">  if (pp == &amp;p_wh) {</a>
<a name="ln3012">    if (value &lt; 1) {</a>
<a name="ln3013">      return e_positive;</a>
<a name="ln3014">    } else if (p_wmh &gt; value) {</a>
<a name="ln3015">      return e_winheight;</a>
<a name="ln3016">    }</a>
<a name="ln3017">  } else if (pp == &amp;p_hh) {</a>
<a name="ln3018">    if (value &lt; 0) {</a>
<a name="ln3019">      return e_positive;</a>
<a name="ln3020">    }</a>
<a name="ln3021">  } else if (pp == &amp;p_wmh) {</a>
<a name="ln3022">    if (value &lt; 0) {</a>
<a name="ln3023">      return e_positive;</a>
<a name="ln3024">    } else if (value &gt; p_wh) {</a>
<a name="ln3025">      return e_winheight;</a>
<a name="ln3026">    }</a>
<a name="ln3027">  } else if (pp == &amp;p_wiw) {</a>
<a name="ln3028">    if (value &lt; 1) {</a>
<a name="ln3029">      return e_positive;</a>
<a name="ln3030">    } else if (p_wmw &gt; value) {</a>
<a name="ln3031">      return e_winwidth;</a>
<a name="ln3032">    }</a>
<a name="ln3033">  } else if (pp == &amp;p_wmw) {</a>
<a name="ln3034">    if (value &lt; 0) {</a>
<a name="ln3035">      return e_positive;</a>
<a name="ln3036">    } else if (value &gt; p_wiw) {</a>
<a name="ln3037">      return e_winwidth;</a>
<a name="ln3038">    }</a>
<a name="ln3039">  } else if (pp == &amp;p_mco) {</a>
<a name="ln3040">    *valuep = MAX_MCO;</a>
<a name="ln3041">  } else if (pp == &amp;p_titlelen) {</a>
<a name="ln3042">    if (value &lt; 0) {</a>
<a name="ln3043">      return e_positive;</a>
<a name="ln3044">    }</a>
<a name="ln3045">  } else if (pp == &amp;p_uc) {</a>
<a name="ln3046">    if (value &lt; 0) {</a>
<a name="ln3047">      return e_positive;</a>
<a name="ln3048">    }</a>
<a name="ln3049">  } else if (pp == &amp;p_ch) {</a>
<a name="ln3050">    if (value &lt; 0) {</a>
<a name="ln3051">      return e_positive;</a>
<a name="ln3052">    } else {</a>
<a name="ln3053">      p_ch_was_zero = value == 0;</a>
<a name="ln3054">    }</a>
<a name="ln3055">  } else if (pp == &amp;p_tm) {</a>
<a name="ln3056">    if (value &lt; 0) {</a>
<a name="ln3057">      return e_positive;</a>
<a name="ln3058">    }</a>
<a name="ln3059">  } else if (pp == &amp;p_hi) {</a>
<a name="ln3060">    if (value &lt; 0) {</a>
<a name="ln3061">      return e_positive;</a>
<a name="ln3062">    } else if (value &gt; 10000) {</a>
<a name="ln3063">      return e_invarg;</a>
<a name="ln3064">    }</a>
<a name="ln3065">  } else if (pp == &amp;p_pyx) {</a>
<a name="ln3066">    if (value == 0) {</a>
<a name="ln3067">      *valuep = 3;</a>
<a name="ln3068">    } else if (value != 3) {</a>
<a name="ln3069">      return e_invarg;</a>
<a name="ln3070">    }</a>
<a name="ln3071">  } else if (pp == &amp;p_re) {</a>
<a name="ln3072">    if (value &lt; 0 || value &gt; 2) {</a>
<a name="ln3073">      return e_invarg;</a>
<a name="ln3074">    }</a>
<a name="ln3075">  } else if (pp == &amp;p_report) {</a>
<a name="ln3076">    if (value &lt; 0) {</a>
<a name="ln3077">      return e_positive;</a>
<a name="ln3078">    }</a>
<a name="ln3079">  } else if (pp == &amp;p_so) {</a>
<a name="ln3080">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln3081">      return e_positive;</a>
<a name="ln3082">    }</a>
<a name="ln3083">  } else if (pp == &amp;p_siso) {</a>
<a name="ln3084">    if (value &lt; 0 &amp;&amp; full_screen) {</a>
<a name="ln3085">      return e_positive;</a>
<a name="ln3086">    }</a>
<a name="ln3087">  } else if (pp == &amp;p_cwh) {</a>
<a name="ln3088">    if (value &lt; 1) {</a>
<a name="ln3089">      return e_positive;</a>
<a name="ln3090">    }</a>
<a name="ln3091">  } else if (pp == &amp;p_ut) {</a>
<a name="ln3092">    if (value &lt; 0) {</a>
<a name="ln3093">      return e_positive;</a>
<a name="ln3094">    }</a>
<a name="ln3095">  } else if (pp == &amp;p_ss) {</a>
<a name="ln3096">    if (value &lt; 0) {</a>
<a name="ln3097">      return e_positive;</a>
<a name="ln3098">    }</a>
<a name="ln3099">  } else if (pp == &amp;curwin-&gt;w_p_fdl || pp == &amp;curwin-&gt;w_allbuf_opt.wo_fdl) {</a>
<a name="ln3100">    if (value &lt; 0) {</a>
<a name="ln3101">      return e_positive;</a>
<a name="ln3102">    }</a>
<a name="ln3103">  } else if (pp == &amp;curwin-&gt;w_p_cole || pp == &amp;curwin-&gt;w_allbuf_opt.wo_cole) {</a>
<a name="ln3104">    if (value &lt; 0) {</a>
<a name="ln3105">      return e_positive;</a>
<a name="ln3106">    } else if (value &gt; 3) {</a>
<a name="ln3107">      return e_invarg;</a>
<a name="ln3108">    }</a>
<a name="ln3109">  } else if (pp == &amp;curwin-&gt;w_p_nuw || pp == &amp;curwin-&gt;w_allbuf_opt.wo_nuw) {</a>
<a name="ln3110">    if (value &lt; 1) {</a>
<a name="ln3111">      return e_positive;</a>
<a name="ln3112">    } else if (value &gt; MAX_NUMBERWIDTH) {</a>
<a name="ln3113">      return e_invarg;</a>
<a name="ln3114">    }</a>
<a name="ln3115">  } else if (pp == &amp;curbuf-&gt;b_p_iminsert || pp == &amp;p_iminsert) {</a>
<a name="ln3116">    if (value &lt; 0 || value &gt; B_IMODE_LAST) {</a>
<a name="ln3117">      return e_invarg;</a>
<a name="ln3118">    }</a>
<a name="ln3119">  } else if (pp == &amp;curbuf-&gt;b_p_imsearch || pp == &amp;p_imsearch) {</a>
<a name="ln3120">    if (value &lt; -1 || value &gt; B_IMODE_LAST) {</a>
<a name="ln3121">      return e_invarg;</a>
<a name="ln3122">    }</a>
<a name="ln3123">  } else if (pp == &amp;curbuf-&gt;b_p_channel || pp == &amp;p_channel) {</a>
<a name="ln3124">    return e_invarg;</a>
<a name="ln3125">  } else if (pp == &amp;curbuf-&gt;b_p_scbk || pp == &amp;p_scbk) {</a>
<a name="ln3126">    if (value &lt; -1 || value &gt; SB_MAX) {</a>
<a name="ln3127">      return e_invarg;</a>
<a name="ln3128">    }</a>
<a name="ln3129">  } else if (pp == &amp;curbuf-&gt;b_p_sw || pp == &amp;p_sw) {</a>
<a name="ln3130">    if (value &lt; 0) {</a>
<a name="ln3131">      return e_positive;</a>
<a name="ln3132">    }</a>
<a name="ln3133">  } else if (pp == &amp;curbuf-&gt;b_p_ts || pp == &amp;p_ts) {</a>
<a name="ln3134">    if (value &lt; 1) {</a>
<a name="ln3135">      return e_positive;</a>
<a name="ln3136">    } else if (value &gt; TABSTOP_MAX) {</a>
<a name="ln3137">      return e_invarg;</a>
<a name="ln3138">    }</a>
<a name="ln3139">  } else if (pp == &amp;curbuf-&gt;b_p_tw || pp == &amp;p_tw) {</a>
<a name="ln3140">    if (value &lt; 0) {</a>
<a name="ln3141">      return e_positive;</a>
<a name="ln3142">    }</a>
<a name="ln3143">  } else if (pp == &amp;p_wd) {</a>
<a name="ln3144">    if (value &lt; 0) {</a>
<a name="ln3145">      return e_positive;</a>
<a name="ln3146">    }</a>
<a name="ln3147">  }</a>
<a name="ln3148"> </a>
<a name="ln3149">  return NULL;</a>
<a name="ln3150">}</a>
<a name="ln3151"> </a>
<a name="ln3152">/// Set the value of a number option, taking care of side effects</a>
<a name="ln3153">///</a>
<a name="ln3154">/// @param[in]  opt_idx  Option index in options[] table.</a>
<a name="ln3155">/// @param[out]  varp  Pointer to the option variable.</a>
<a name="ln3156">/// @param[in]  value  New value.</a>
<a name="ln3157">/// @param  errbuf  Buffer for error messages.</a>
<a name="ln3158">/// @param[in]  errbuflen  Length of `errbuf`.</a>
<a name="ln3159">/// @param[in]  opt_flags  OPT_LOCAL, OPT_GLOBAL or OPT_MODELINE.</a>
<a name="ln3160">///</a>
<a name="ln3161">/// @return NULL on success, error message on error.</a>
<a name="ln3162">static const char *set_num_option(int opt_idx, void *varp, long value, char *errbuf,</a>
<a name="ln3163">                                  size_t errbuflen, int opt_flags)</a>
<a name="ln3164">{</a>
<a name="ln3165">  OptInt old_value = *(OptInt *)varp;</a>
<a name="ln3166">  OptInt old_global_value = 0;  // only used when setting a local and global option</a>
<a name="ln3167">  long old_Rows = Rows;       // remember old Rows</a>
<a name="ln3168">  OptInt *pp = (OptInt *)varp;</a>
<a name="ln3169"> </a>
<a name="ln3170">  // Disallow changing some options from secure mode.</a>
<a name="ln3171">  if ((secure || sandbox != 0) &amp;&amp; (options[opt_idx].flags &amp; P_SECURE)) {</a>
<a name="ln3172">    return e_secure;</a>
<a name="ln3173">  }</a>
<a name="ln3174"> </a>
<a name="ln3175">  // Save the global value before changing anything. This is needed as for</a>
<a name="ln3176">  // a global-only option setting the &quot;local value&quot; in fact sets the global</a>
<a name="ln3177">  // value (since there is only one value).</a>
<a name="ln3178">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln3179">    old_global_value = *(OptInt *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL);</a>
<a name="ln3180">  }</a>
<a name="ln3181"> </a>
<a name="ln3182">  const char *errmsg = validate_num_option(pp, &amp;value);</a>
<a name="ln3183"> </a>
<a name="ln3184">  // Don't change the value and return early if validation failed.</a>
<a name="ln3185">  if (errmsg != NULL) {</a>
<a name="ln3186">    return errmsg;</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189">  *pp = (OptInt)value;</a>
<a name="ln3190">  // Remember where the option was set.</a>
<a name="ln3191">  set_option_sctx_idx(opt_idx, opt_flags, current_sctx);</a>
<a name="ln3192"> </a>
<a name="ln3193">  // Invoke the option specific callback function to validate and apply the</a>
<a name="ln3194">  // new value.</a>
<a name="ln3195">  if (options[opt_idx].opt_did_set_cb != NULL) {</a>
<a name="ln3196">    optset_T args = {</a>
<a name="ln3197">      .os_varp = varp,</a>
<a name="ln3198">      .os_flags = opt_flags,</a>
<a name="ln3199">      .os_oldval.number = old_value,</a>
<a name="ln3200">      .os_newval.number = (OptInt)value,</a>
<a name="ln3201">      .os_errbuf = NULL,</a>
<a name="ln3202">      .os_errbuflen = 0,</a>
<a name="ln3203">      .os_buf = curbuf,</a>
<a name="ln3204">      .os_win = curwin</a>
<a name="ln3205">    };</a>
<a name="ln3206">    errmsg = options[opt_idx].opt_did_set_cb(&amp;args);</a>
<a name="ln3207">  }</a>
<a name="ln3208"> </a>
<a name="ln3209">  // Check the bounds for numeric options here</a>
<a name="ln3210">  errmsg = check_num_option_bounds(pp, old_value, old_Rows, errbuf, errbuflen, errmsg);</a>
<a name="ln3211"> </a>
<a name="ln3212">  // May set global value for local option.</a>
<a name="ln3213">  if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) == 0) {</a>
<a name="ln3214">    *(OptInt *)get_varp_scope(&amp;(options[opt_idx]), OPT_GLOBAL) = *pp;</a>
<a name="ln3215">  }</a>
<a name="ln3216"> </a>
<a name="ln3217">  options[opt_idx].flags |= P_WAS_SET;</a>
<a name="ln3218"> </a>
<a name="ln3219">  apply_optionset_autocmd(opt_idx, opt_flags, old_value, old_global_value,</a>
<a name="ln3220">                          value, errmsg);</a>
<a name="ln3221"> </a>
<a name="ln3222">  if (errmsg == NULL &amp;&amp; options[opt_idx].flags &amp; P_UI_OPTION) {</a>
<a name="ln3223">    ui_call_option_set(cstr_as_string(options[opt_idx].fullname),</a>
<a name="ln3224">                       INTEGER_OBJ(*pp));</a>
<a name="ln3225">  }</a>
<a name="ln3226"> </a>
<a name="ln3227">  comp_col();                       // in case 'columns' or 'ls' changed</a>
<a name="ln3228">  if (curwin-&gt;w_curswant != MAXCOL</a>
<a name="ln3229">      &amp;&amp; (options[opt_idx].flags &amp; (P_CURSWANT | P_RALL)) != 0) {</a>
<a name="ln3230">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln3231">  }</a>
<a name="ln3232">  check_redraw(options[opt_idx].flags);</a>
<a name="ln3233"> </a>
<a name="ln3234">  return errmsg;</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237">/// Called after an option changed: check if something needs to be redrawn.</a>
<a name="ln3238">void check_redraw_for(buf_T *buf, win_T *win, uint32_t flags)</a>
<a name="ln3239">{</a>
<a name="ln3240">  // Careful: P_RALL is a combination of other P_ flags</a>
<a name="ln3241">  bool all = (flags &amp; P_RALL) == P_RALL;</a>
<a name="ln3242"> </a>
<a name="ln3243">  if ((flags &amp; P_RSTAT) || all) {  // mark all status lines and window bars dirty</a>
<a name="ln3244">    status_redraw_all();</a>
<a name="ln3245">  }</a>
<a name="ln3246"> </a>
<a name="ln3247">  if ((flags &amp; P_RTABL) || all) {  // mark tablines dirty</a>
<a name="ln3248">    redraw_tabline = true;</a>
<a name="ln3249">  }</a>
<a name="ln3250"> </a>
<a name="ln3251">  if ((flags &amp; P_RBUF) || (flags &amp; P_RWIN) || all) {</a>
<a name="ln3252">    changed_window_setting_win(win);</a>
<a name="ln3253">  }</a>
<a name="ln3254">  if (flags &amp; P_RBUF) {</a>
<a name="ln3255">    redraw_buf_later(buf, UPD_NOT_VALID);</a>
<a name="ln3256">  }</a>
<a name="ln3257">  if (flags &amp; P_RWINONLY) {</a>
<a name="ln3258">    redraw_later(win, UPD_NOT_VALID);</a>
<a name="ln3259">  }</a>
<a name="ln3260">  if (all) {</a>
<a name="ln3261">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln3262">  }</a>
<a name="ln3263">}</a>
<a name="ln3264"> </a>
<a name="ln3265">void check_redraw(uint32_t flags)</a>
<a name="ln3266">{</a>
<a name="ln3267">  check_redraw_for(curbuf, curwin, flags);</a>
<a name="ln3268">}</a>
<a name="ln3269"> </a>
<a name="ln3270">/// Find index for named option</a>
<a name="ln3271">///</a>
<a name="ln3272">/// @param[in]  arg  Option to find index for.</a>
<a name="ln3273">/// @param[in]  len  Length of the option.</a>
<a name="ln3274">///</a>
<a name="ln3275">/// @return Index of the option or -1 if option was not found.</a>
<a name="ln3276">int findoption_len(const char *const arg, const size_t len)</a>
<a name="ln3277">{</a>
<a name="ln3278">  const char *s;</a>
<a name="ln3279">  static int quick_tab[27] = { 0, 0 };  // quick access table</a>
<a name="ln3280"> </a>
<a name="ln3281">  // For first call: Initialize the quick-access table.</a>
<a name="ln3282">  // It contains the index for the first option that starts with a certain</a>
<a name="ln3283">  // letter.  There are 26 letters, plus the first &quot;t_&quot; option.</a>
<a name="ln3284">  if (quick_tab[1] == 0) {</a>
<a name="ln3285">    const char *p = options[0].fullname;</a>
<a name="ln3286">    for (uint16_t i = 1; (s = options[i].fullname) != NULL; i++) {</a>
<a name="ln3287">      if (s[0] != p[0]) {</a>
<a name="ln3288">        if (s[0] == 't' &amp;&amp; s[1] == '_') {</a>
<a name="ln3289">          quick_tab[26] = i;</a>
<a name="ln3290">        } else {</a>
<a name="ln3291">          quick_tab[CHAR_ORD_LOW(s[0])] = i;</a>
<a name="ln3292">        }</a>
<a name="ln3293">      }</a>
<a name="ln3294">      p = s;</a>
<a name="ln3295">    }</a>
<a name="ln3296">  }</a>
<a name="ln3297"> </a>
<a name="ln3298">  // Check for name starting with an illegal character.</a>
<a name="ln3299">  if (len == 0 || arg[0] &lt; 'a' || arg[0] &gt; 'z') {</a>
<a name="ln3300">    return -1;</a>
<a name="ln3301">  }</a>
<a name="ln3302"> </a>
<a name="ln3303">  int opt_idx;</a>
<a name="ln3304">  const bool is_term_opt = (len &gt; 2 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_');</a>
<a name="ln3305">  if (is_term_opt) {</a>
<a name="ln3306">    opt_idx = quick_tab[26];</a>
<a name="ln3307">  } else {</a>
<a name="ln3308">    opt_idx = quick_tab[CHAR_ORD_LOW(arg[0])];</a>
<a name="ln3309">  }</a>
<a name="ln3310">  // Match full name</a>
<a name="ln3311">  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {</a>
<a name="ln3312">    if (strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln3313">      break;</a>
<a name="ln3314">    }</a>
<a name="ln3315">  }</a>
<a name="ln3316">  if (s == NULL &amp;&amp; !is_term_opt) {</a>
<a name="ln3317">    opt_idx = quick_tab[CHAR_ORD_LOW(arg[0])];</a>
<a name="ln3318">    // Match short name</a>
<a name="ln3319">    for (; options[opt_idx].fullname != NULL; opt_idx++) {</a>
<a name="ln3320">      s = options[opt_idx].shortname;</a>
<a name="ln3321">      if (s != NULL &amp;&amp; strncmp(arg, s, len) == 0 &amp;&amp; s[len] == NUL) {</a>
<a name="ln3322">        break;</a>
<a name="ln3323">      }</a>
<a name="ln3324">      s = NULL;</a>
<a name="ln3325">    }</a>
<a name="ln3326">  }</a>
<a name="ln3327">  if (s == NULL) {</a>
<a name="ln3328">    opt_idx = -1;</a>
<a name="ln3329">  } else {</a>
<a name="ln3330">    // Nvim: handle option aliases.</a>
<a name="ln3331">    if (strncmp(options[opt_idx].fullname, &quot;viminfo&quot;, 7) == 0) {</a>
<a name="ln3332">      if (strlen(options[opt_idx].fullname) == 7) {</a>
<a name="ln3333">        return findoption_len(&quot;shada&quot;, 5);</a>
<a name="ln3334">      }</a>
<a name="ln3335">      assert(strcmp(options[opt_idx].fullname, &quot;viminfofile&quot;) == 0);</a>
<a name="ln3336">      return findoption_len(&quot;shadafile&quot;, 9);</a>
<a name="ln3337">    }</a>
<a name="ln3338">  }</a>
<a name="ln3339">  return opt_idx;</a>
<a name="ln3340">}</a>
<a name="ln3341"> </a>
<a name="ln3342">bool is_tty_option(const char *name)</a>
<a name="ln3343">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3344">{</a>
<a name="ln3345">  return (name[0] == 't' &amp;&amp; name[1] == '_')</a>
<a name="ln3346">         || strequal(name, &quot;term&quot;)</a>
<a name="ln3347">         || strequal(name, &quot;ttytype&quot;);</a>
<a name="ln3348">}</a>
<a name="ln3349"> </a>
<a name="ln3350">#define TCO_BUFFER_SIZE 8</a>
<a name="ln3351">/// @param name TUI-related option</a>
<a name="ln3352">/// @param[out,allocated] value option string value</a>
<a name="ln3353">bool get_tty_option(const char *name, char **value)</a>
<a name="ln3354">{</a>
<a name="ln3355">  if (strequal(name, &quot;t_Co&quot;)) {</a>
<a name="ln3356">    if (value) {</a>
<a name="ln3357">      if (t_colors &lt;= 1) {</a>
<a name="ln3358">        *value = xstrdup(&quot;&quot;);</a>
<a name="ln3359">      } else {</a>
<a name="ln3360">        *value = xmalloc(TCO_BUFFER_SIZE);</a>
<a name="ln3361">        snprintf(*value, TCO_BUFFER_SIZE, &quot;%d&quot;, t_colors);</a>
<a name="ln3362">      }</a>
<a name="ln3363">    }</a>
<a name="ln3364">    return true;</a>
<a name="ln3365">  }</a>
<a name="ln3366"> </a>
<a name="ln3367">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln3368">    if (value) {</a>
<a name="ln3369">      *value = p_term ? xstrdup(p_term) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln3370">    }</a>
<a name="ln3371">    return true;</a>
<a name="ln3372">  }</a>
<a name="ln3373"> </a>
<a name="ln3374">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln3375">    if (value) {</a>
<a name="ln3376">      *value = p_ttytype ? xstrdup(p_ttytype) : xstrdup(&quot;nvim&quot;);</a>
<a name="ln3377">    }</a>
<a name="ln3378">    return true;</a>
<a name="ln3379">  }</a>
<a name="ln3380"> </a>
<a name="ln3381">  if (is_tty_option(name)) {</a>
<a name="ln3382">    if (value) {</a>
<a name="ln3383">      // XXX: All other t_* options were removed in 3baba1e7.</a>
<a name="ln3384">      *value = xstrdup(&quot;&quot;);</a>
<a name="ln3385">    }</a>
<a name="ln3386">    return true;</a>
<a name="ln3387">  }</a>
<a name="ln3388"> </a>
<a name="ln3389">  return false;</a>
<a name="ln3390">}</a>
<a name="ln3391"> </a>
<a name="ln3392">bool set_tty_option(const char *name, char *value)</a>
<a name="ln3393">{</a>
<a name="ln3394">  if (strequal(name, &quot;term&quot;)) {</a>
<a name="ln3395">    if (p_term) {</a>
<a name="ln3396">      xfree(p_term);</a>
<a name="ln3397">    }</a>
<a name="ln3398">    p_term = value;</a>
<a name="ln3399">    return true;</a>
<a name="ln3400">  }</a>
<a name="ln3401"> </a>
<a name="ln3402">  if (strequal(name, &quot;ttytype&quot;)) {</a>
<a name="ln3403">    if (p_ttytype) {</a>
<a name="ln3404">      xfree(p_ttytype);</a>
<a name="ln3405">    }</a>
<a name="ln3406">    p_ttytype = value;</a>
<a name="ln3407">    return true;</a>
<a name="ln3408">  }</a>
<a name="ln3409"> </a>
<a name="ln3410">  return false;</a>
<a name="ln3411">}</a>
<a name="ln3412"> </a>
<a name="ln3413">void set_tty_background(const char *value)</a>
<a name="ln3414">{</a>
<a name="ln3415">  if (option_was_set(&quot;bg&quot;) || strequal(p_bg, value)) {</a>
<a name="ln3416">    // background is already set... ignore</a>
<a name="ln3417">    return;</a>
<a name="ln3418">  }</a>
<a name="ln3419">  if (starting) {</a>
<a name="ln3420">    // Wait until after startup, so OptionSet is triggered.</a>
<a name="ln3421">    do_cmdline_cmd((value[0] == 'l')</a>
<a name="ln3422">                   ? &quot;autocmd VimEnter * ++once ++nested :lua if not vim.api.nvim_get_option_info2('bg', {}).was_set then vim.o.bg = 'light' end&quot;</a>
<a name="ln3423">                   : &quot;autocmd VimEnter * ++once ++nested :lua if not vim.api.nvim_get_option_info2('bg', {}).was_set then vim.o.bg = 'dark' end&quot;);</a>
<a name="ln3424">  } else {</a>
<a name="ln3425">    set_option_value_give_err(&quot;bg&quot;, CSTR_AS_OPTVAL((char *)value), 0);</a>
<a name="ln3426">    reset_option_was_set(&quot;bg&quot;);</a>
<a name="ln3427">  }</a>
<a name="ln3428">}</a>
<a name="ln3429"> </a>
<a name="ln3430">/// Find index for an option</a>
<a name="ln3431">///</a>
<a name="ln3432">/// @param[in]  arg  Option name.</a>
<a name="ln3433">///</a>
<a name="ln3434">/// @return Option index or -1 if option was not found.</a>
<a name="ln3435">int findoption(const char *const arg)</a>
<a name="ln3436">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3437">{</a>
<a name="ln3438">  return findoption_len(arg, strlen(arg));</a>
<a name="ln3439">}</a>
<a name="ln3440"> </a>
<a name="ln3441">void optval_free(OptVal o)</a>
<a name="ln3442">{</a>
<a name="ln3443">  switch (o.type) {</a>
<a name="ln3444">  case kOptValTypeNil:</a>
<a name="ln3445">  case kOptValTypeBoolean:</a>
<a name="ln3446">  case kOptValTypeNumber:</a>
<a name="ln3447">    break;</a>
<a name="ln3448">  case kOptValTypeString:</a>
<a name="ln3449">    api_free_string(o.data.string);</a>
<a name="ln3450">    break;</a>
<a name="ln3451">  }</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454">OptVal optval_copy(OptVal o)</a>
<a name="ln3455">{</a>
<a name="ln3456">  switch (o.type) {</a>
<a name="ln3457">  case kOptValTypeNil:</a>
<a name="ln3458">  case kOptValTypeBoolean:</a>
<a name="ln3459">  case kOptValTypeNumber:</a>
<a name="ln3460">    return o;</a>
<a name="ln3461">  case kOptValTypeString:</a>
<a name="ln3462">    return STRING_OPTVAL(copy_string(o.data.string, NULL));</a>
<a name="ln3463">  default:</a>
<a name="ln3464">    abort();</a>
<a name="ln3465">  }</a>
<a name="ln3466">}</a>
<a name="ln3467"> </a>
<a name="ln3468">// Match type of OptVal with the type of the target option. Returns true if the types match and</a>
<a name="ln3469">// false otherwise.</a>
<a name="ln3470">static bool optval_match_type(OptVal o, int opt_idx)</a>
<a name="ln3471">{</a>
<a name="ln3472">  assert(opt_idx &gt;= 0);</a>
<a name="ln3473">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln3474"> </a>
<a name="ln3475">  switch (o.type) {</a>
<a name="ln3476">  case kOptValTypeNil:</a>
<a name="ln3477">    return false;</a>
<a name="ln3478">  case kOptValTypeBoolean:</a>
<a name="ln3479">    return flags &amp; P_BOOL;</a>
<a name="ln3480">  case kOptValTypeNumber:</a>
<a name="ln3481">    return flags &amp; P_NUM;</a>
<a name="ln3482">  case kOptValTypeString:</a>
<a name="ln3483">    return flags &amp; P_STRING;</a>
<a name="ln3484">  default:</a>
<a name="ln3485">    abort();</a>
<a name="ln3486">  }</a>
<a name="ln3487">}</a>
<a name="ln3488"> </a>
<a name="ln3489">// Return C-string representation of OptVal. Caller must free the returned C-string.</a>
<a name="ln3490">static char *optval_to_cstr(OptVal o)</a>
<a name="ln3491">{</a>
<a name="ln3492">  switch (o.type) {</a>
<a name="ln3493">  case kOptValTypeNil:</a>
<a name="ln3494">    return xstrdup(&quot;&quot;);</a>
<a name="ln3495">  case kOptValTypeBoolean:</a>
<a name="ln3496">    return xstrdup(o.data.boolean ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3497">  case kOptValTypeNumber: {</a>
<a name="ln3498">    char *buf = xmalloc(NUMBUFLEN);</a>
<a name="ln3499">    snprintf(buf, NUMBUFLEN, &quot;%&quot; PRId64, o.data.number);</a>
<a name="ln3500">    return buf;</a>
<a name="ln3501">  }</a>
<a name="ln3502">  case kOptValTypeString: {</a>
<a name="ln3503">    char *buf = xmalloc(o.data.string.size + 3);</a>
<a name="ln3504">    snprintf(buf, o.data.string.size + 3, &quot;\&quot;%s\&quot;&quot;, o.data.string.data);</a>
<a name="ln3505">    return buf;</a>
<a name="ln3506">  }</a>
<a name="ln3507">  default:</a>
<a name="ln3508">    abort();</a>
<a name="ln3509">  }</a>
<a name="ln3510">}</a>
<a name="ln3511"> </a>
<a name="ln3512">// Get an allocated string containing a list of valid types for an option.</a>
<a name="ln3513">// For options with a singular type, it returns the name of the type. For options with multiple</a>
<a name="ln3514">// possible types, it returns a slash separated list of types. For example, if an option can be a</a>
<a name="ln3515">// number, boolean or string, the function returns &quot;Number/Boolean/String&quot;</a>
<a name="ln3516">static char *option_get_valid_types(int opt_idx)</a>
<a name="ln3517">{</a>
<a name="ln3518">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln3519">  uint32_t type_count = 0;</a>
<a name="ln3520"> </a>
<a name="ln3521">  StringBuilder str = KV_INITIAL_VALUE;</a>
<a name="ln3522">  kv_resize(str, 32);</a>
<a name="ln3523"> </a>
<a name="ln3524">#define OPTION_ADD_TYPE(typename) \</a>
<a name="ln3525">  do { \</a>
<a name="ln3526">    if (type_count == 0) { \</a>
<a name="ln3527">      kv_concat(str, typename); \</a>
<a name="ln3528">    } else { \</a>
<a name="ln3529">      kv_printf(str, &quot;/%s&quot;, typename); \</a>
<a name="ln3530">    } \</a>
<a name="ln3531">    type_count++; \</a>
<a name="ln3532">  } while (0);</a>
<a name="ln3533"> </a>
<a name="ln3534">  if (flags &amp; P_NUM) {</a>
<a name="ln3535">    OPTION_ADD_TYPE(&quot;Number&quot;);</a>
<a name="ln3536">  }</a>
<a name="ln3537">  if (flags &amp; P_BOOL) {</a>
<a name="ln3538">    OPTION_ADD_TYPE(&quot;Boolean&quot;);</a>
<a name="ln3539">  }</a>
<a name="ln3540">  if (flags &amp; P_STRING) {</a>
<a name="ln3541">    OPTION_ADD_TYPE(&quot;String&quot;);</a>
<a name="ln3542">  }</a>
<a name="ln3543"> </a>
<a name="ln3544">  if (type_count == 0) {</a>
<a name="ln3545">    abort();</a>
<a name="ln3546">  }</a>
<a name="ln3547"> </a>
<a name="ln3548">  // Ensure that the string is NUL-terminated.</a>
<a name="ln3549">  kv_push(str, NUL);</a>
<a name="ln3550">  return str.items;</a>
<a name="ln3551"> </a>
<a name="ln3552">#undef OPTION_ADD_TYPE</a>
<a name="ln3553">}</a>
<a name="ln3554"> </a>
<a name="ln3555">/// Gets the value for an option.</a>
<a name="ln3556">///</a>
<a name="ln3557">/// @param[in]   name    Option name.</a>
<a name="ln3558">/// @param[out]  flagsp  Set to the option flags (P_xxxx) (if not NULL).</a>
<a name="ln3559">/// @param[in]   scope   Option scope (can be OPT_LOCAL, OPT_GLOBAL or a combination).</a>
<a name="ln3560">/// @param[out]  hidden  Whether option is hidden.</a>
<a name="ln3561">///</a>
<a name="ln3562">/// @return  Option value. Returns NIL_OPTVAL for invalid options. Return value must be freed by</a>
<a name="ln3563">///          caller.</a>
<a name="ln3564">OptVal get_option_value(const char *name, uint32_t *flagsp, int scope, bool *hidden)</a>
<a name="ln3565">{</a>
<a name="ln3566">  // Make sure that hidden and flagsp are never returned uninitialized</a>
<a name="ln3567">  if (hidden != NULL) {</a>
<a name="ln3568">    *hidden = false;</a>
<a name="ln3569">  }</a>
<a name="ln3570">  if (flagsp != NULL) {</a>
<a name="ln3571">    *flagsp = 0;</a>
<a name="ln3572">  }</a>
<a name="ln3573"> </a>
<a name="ln3574">  char *str;</a>
<a name="ln3575">  if (get_tty_option(name, &amp;str)) {</a>
<a name="ln3576">    return CSTR_AS_OPTVAL(str);</a>
<a name="ln3577">  }</a>
<a name="ln3578"> </a>
<a name="ln3579">  int opt_idx = findoption(name);</a>
<a name="ln3580">  if (opt_idx &lt; 0) {  // option not in the table</a>
<a name="ln3581">    return NIL_OPTVAL;</a>
<a name="ln3582">  }</a>
<a name="ln3583"> </a>
<a name="ln3584">  void *varp = get_varp_scope(&amp;(options[opt_idx]), scope);</a>
<a name="ln3585">  if (hidden != NULL) {</a>
<a name="ln3586">    *hidden = varp == NULL;</a>
<a name="ln3587">  }</a>
<a name="ln3588"> </a>
<a name="ln3589">  if (flagsp != NULL) {</a>
<a name="ln3590">    // Return the P_xxxx option flags.</a>
<a name="ln3591">    *flagsp = options[opt_idx].flags;</a>
<a name="ln3592">  }</a>
<a name="ln3593"> </a>
<a name="ln3594">  if (options[opt_idx].flags &amp; P_STRING) {</a>
<a name="ln3595">    return varp == NULL ? STRING_OPTVAL(STRING_INIT) : CSTR_TO_OPTVAL(*(char **)(varp));</a>
<a name="ln3596">  }</a>
<a name="ln3597"> </a>
<a name="ln3598">  if (options[opt_idx].flags &amp; P_NUM) {</a>
<a name="ln3599">    return NUMBER_OPTVAL(varp == NULL ? 0 : (*(OptInt *)varp));</a>
<a name="ln3600">  } else {</a>
<a name="ln3601">    // Special case: 'modified' is b_changed, but we also want to consider</a>
<a name="ln3602">    // it set when 'ff' or 'fenc' changed.</a>
<a name="ln3603">    if (varp == NULL) {</a>
<a name="ln3604">      return BOOLEAN_OPTVAL(false);</a>
<a name="ln3605">    } else if ((int *)varp == &amp;curbuf-&gt;b_changed) {</a>
<a name="ln3606">      return BOOLEAN_OPTVAL(curbufIsChanged());</a>
<a name="ln3607">    } else {</a>
<a name="ln3608">      int n = *(int *)varp;</a>
<a name="ln3609">      return BOOLEAN_OPTVAL(n == 0 ? kFalse : (n &gt;= 1 ? kTrue : kNone));</a>
<a name="ln3610">    }</a>
<a name="ln3611">  }</a>
<a name="ln3612">}</a>
<a name="ln3613"> </a>
<a name="ln3614">// Returns the option attributes and its value. Unlike the above function it</a>
<a name="ln3615">// will return either global value or local value of the option depending on</a>
<a name="ln3616">// what was requested, but it will never return global value if it was</a>
<a name="ln3617">// requested to return local one and vice versa. Neither it will return</a>
<a name="ln3618">// buffer-local value if it was requested to return window-local one.</a>
<a name="ln3619">//</a>
<a name="ln3620">// Pretends that option is absent if it is not present in the requested scope</a>
<a name="ln3621">// (i.e. has no global, window-local or buffer-local value depending on</a>
<a name="ln3622">// opt_type).</a>
<a name="ln3623">//</a>
<a name="ln3624">// Returned flags:</a>
<a name="ln3625">//       0 hidden or unknown option, also option that does not have requested</a>
<a name="ln3626">//         type (see SREQ_* in option_defs.h)</a>
<a name="ln3627">//  see SOPT_* in option_defs.h for other flags</a>
<a name="ln3628">//</a>
<a name="ln3629">// Possible opt_type values: see SREQ_* in option_defs.h</a>
<a name="ln3630">int get_option_value_strict(char *name, int64_t *numval, char **stringval, int opt_type, void *from)</a>
<a name="ln3631">{</a>
<a name="ln3632">  if (get_tty_option(name, stringval)) {</a>
<a name="ln3633">    return SOPT_STRING | SOPT_GLOBAL;</a>
<a name="ln3634">  }</a>
<a name="ln3635"> </a>
<a name="ln3636">  int rv = 0;</a>
<a name="ln3637">  int opt_idx = findoption(name);</a>
<a name="ln3638">  if (opt_idx &lt; 0) {</a>
<a name="ln3639">    return 0;</a>
<a name="ln3640">  }</a>
<a name="ln3641"> </a>
<a name="ln3642">  vimoption_T *p = &amp;options[opt_idx];</a>
<a name="ln3643"> </a>
<a name="ln3644">  // Hidden option</a>
<a name="ln3645">  if (p-&gt;var == NULL) {</a>
<a name="ln3646">    return 0;</a>
<a name="ln3647">  }</a>
<a name="ln3648"> </a>
<a name="ln3649">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln3650">    rv |= SOPT_BOOL;</a>
<a name="ln3651">  } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln3652">    rv |= SOPT_NUM;</a>
<a name="ln3653">  } else if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln3654">    rv |= SOPT_STRING;</a>
<a name="ln3655">  }</a>
<a name="ln3656"> </a>
<a name="ln3657">  if (p-&gt;indir == PV_NONE) {</a>
<a name="ln3658">    if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln3659">      rv |= SOPT_GLOBAL;</a>
<a name="ln3660">    } else {</a>
<a name="ln3661">      return 0;  // Did not request global-only option</a>
<a name="ln3662">    }</a>
<a name="ln3663">  } else {</a>
<a name="ln3664">    if (p-&gt;indir &amp; PV_BOTH) {</a>
<a name="ln3665">      rv |= SOPT_GLOBAL;</a>
<a name="ln3666">    }</a>
<a name="ln3667"> </a>
<a name="ln3668">    if (p-&gt;indir &amp; PV_WIN) {</a>
<a name="ln3669">      if (opt_type == SREQ_BUF) {</a>
<a name="ln3670">        return 0;  // Requested buffer-local, not window-local option</a>
<a name="ln3671">      }</a>
<a name="ln3672">      rv |= SOPT_WIN;</a>
<a name="ln3673">    } else if (p-&gt;indir &amp; PV_BUF) {</a>
<a name="ln3674">      if (opt_type == SREQ_WIN) {</a>
<a name="ln3675">        return 0;  // Requested window-local, not buffer-local option</a>
<a name="ln3676">      }</a>
<a name="ln3677">      rv |= SOPT_BUF;</a>
<a name="ln3678">    }</a>
<a name="ln3679">  }</a>
<a name="ln3680"> </a>
<a name="ln3681">  if (stringval == NULL) {</a>
<a name="ln3682">    return rv;</a>
<a name="ln3683">  }</a>
<a name="ln3684"> </a>
<a name="ln3685">  void *varp = NULL;</a>
<a name="ln3686"> </a>
<a name="ln3687">  if (opt_type == SREQ_GLOBAL) {</a>
<a name="ln3688">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln3689">      return 0;</a>
<a name="ln3690">    }</a>
<a name="ln3691">    varp = p-&gt;var;</a>
<a name="ln3692">  } else {</a>
<a name="ln3693">    if (opt_type == SREQ_BUF) {</a>
<a name="ln3694">      // Special case: 'modified' is b_changed, but we also want to</a>
<a name="ln3695">      // consider it set when 'ff' or 'fenc' changed.</a>
<a name="ln3696">      if (p-&gt;indir == PV_MOD) {</a>
<a name="ln3697">        *numval = bufIsChanged((buf_T *)from);</a>
<a name="ln3698">        varp = NULL;</a>
<a name="ln3699">      } else {</a>
<a name="ln3700">        buf_T *save_curbuf = curbuf;</a>
<a name="ln3701"> </a>
<a name="ln3702">        // only getting a pointer, no need to use aucmd_prepbuf()</a>
<a name="ln3703">        curbuf = (buf_T *)from;</a>
<a name="ln3704">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln3705">        varp = get_varp_scope(p, OPT_LOCAL);</a>
<a name="ln3706">        curbuf = save_curbuf;</a>
<a name="ln3707">        curwin-&gt;w_buffer = curbuf;</a>
<a name="ln3708">      }</a>
<a name="ln3709">    } else if (opt_type == SREQ_WIN) {</a>
<a name="ln3710">      win_T *save_curwin = curwin;</a>
<a name="ln3711">      curwin = (win_T *)from;</a>
<a name="ln3712">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3713">      varp = get_varp_scope(p, OPT_LOCAL);</a>
<a name="ln3714">      curwin = save_curwin;</a>
<a name="ln3715">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3716">    }</a>
<a name="ln3717"> </a>
<a name="ln3718">    if (varp == p-&gt;var) {</a>
<a name="ln3719">      return (rv | SOPT_UNSET);</a>
<a name="ln3720">    }</a>
<a name="ln3721">  }</a>
<a name="ln3722"> </a>
<a name="ln3723">  if (varp != NULL) {</a>
<a name="ln3724">    if (p-&gt;flags &amp; P_STRING) {</a>
<a name="ln3725">      *stringval = *(char **)(varp);</a>
<a name="ln3726">    } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln3727">      *numval = *(OptInt *)varp;</a>
<a name="ln3728">    } else {</a>
<a name="ln3729">      *numval = *(int *)varp;</a>
<a name="ln3730">    }</a>
<a name="ln3731">  }</a>
<a name="ln3732"> </a>
<a name="ln3733">  return rv;</a>
<a name="ln3734">}</a>
<a name="ln3735"> </a>
<a name="ln3736">// Return information for option at 'opt_idx'</a>
<a name="ln3737">vimoption_T *get_option(int opt_idx)</a>
<a name="ln3738">{</a>
<a name="ln3739">  return &amp;options[opt_idx];</a>
<a name="ln3740">}</a>
<a name="ln3741"> </a>
<a name="ln3742">/// Clear an option</a>
<a name="ln3743">///</a>
<a name="ln3744">/// The exact semantics of this depend on the option.</a>
<a name="ln3745">static OptVal clear_optval(const char *name, uint32_t flags, void *varp, buf_T *buf, win_T *win)</a>
<a name="ln3746">{</a>
<a name="ln3747">  OptVal v = NIL_OPTVAL;</a>
<a name="ln3748"> </a>
<a name="ln3749">  // Change the type of the OptVal to the type used by the option so that it can be cleared.</a>
<a name="ln3750">  // TODO(famiu): Clean up all of this after set_(num|bool|string)_option() is unified.</a>
<a name="ln3751"> </a>
<a name="ln3752">  if (flags &amp; P_BOOL) {</a>
<a name="ln3753">    v.type = kOptValTypeBoolean;</a>
<a name="ln3754">    if ((int *)varp == &amp;buf-&gt;b_p_ar) {</a>
<a name="ln3755">      // TODO(lewis6991): replace this with a more general condition that</a>
<a name="ln3756">      // indicates we are setting the local value of a global-local option</a>
<a name="ln3757">      v.data.boolean = kNone;</a>
<a name="ln3758">    } else {</a>
<a name="ln3759">      v = get_option_value(name, NULL, OPT_GLOBAL, NULL);</a>
<a name="ln3760">    }</a>
<a name="ln3761">  } else if (flags &amp; P_NUM) {</a>
<a name="ln3762">    v.type = kOptValTypeNumber;</a>
<a name="ln3763">    if ((OptInt *)varp == &amp;curbuf-&gt;b_p_ul) {</a>
<a name="ln3764">      // The one true special case</a>
<a name="ln3765">      v.data.number = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln3766">    } else if ((OptInt *)varp == &amp;win-&gt;w_p_so || (OptInt *)varp == &amp;win-&gt;w_p_siso) {</a>
<a name="ln3767">      // TODO(lewis6991): replace this with a more general condition that</a>
<a name="ln3768">      // indicates we are setting the local value of a global-local option</a>
<a name="ln3769">      v.data.number = -1;</a>
<a name="ln3770">    } else {</a>
<a name="ln3771">      v = get_option_value(name, NULL, OPT_GLOBAL, NULL);</a>
<a name="ln3772">    }</a>
<a name="ln3773">  } else if (flags &amp; P_STRING) {</a>
<a name="ln3774">    v.type = kOptValTypeString;</a>
<a name="ln3775">    v.data.string.data = NULL;</a>
<a name="ln3776">  }</a>
<a name="ln3777"> </a>
<a name="ln3778">  return v;</a>
<a name="ln3779">}</a>
<a name="ln3780"> </a>
<a name="ln3781">static const char *set_option(int opt_idx, void *varp, OptVal *v, int opt_flags, char *errbuf,</a>
<a name="ln3782">                              size_t errbuflen)</a>
<a name="ln3783">{</a>
<a name="ln3784">  const char *errmsg = NULL;</a>
<a name="ln3785"> </a>
<a name="ln3786">  bool value_checked = false;</a>
<a name="ln3787"> </a>
<a name="ln3788">  if (v-&gt;type == kOptValTypeBoolean) {</a>
<a name="ln3789">    errmsg = set_bool_option(opt_idx, varp, (int)v-&gt;data.boolean, opt_flags);</a>
<a name="ln3790">  } else if (v-&gt;type == kOptValTypeNumber) {</a>
<a name="ln3791">    errmsg = set_num_option(opt_idx, varp, (long)v-&gt;data.number, errbuf, errbuflen, opt_flags);</a>
<a name="ln3792">  } else if (v-&gt;type == kOptValTypeString) {</a>
<a name="ln3793">    errmsg = set_string_option(opt_idx, varp, v-&gt;data.string.data, opt_flags, &amp;value_checked,</a>
<a name="ln3794">                               errbuf, errbuflen);</a>
<a name="ln3795">  }</a>
<a name="ln3796"> </a>
<a name="ln3797">  if (errmsg == NULL) {</a>
<a name="ln3798">    did_set_option(opt_idx, opt_flags, true, value_checked);</a>
<a name="ln3799">  }</a>
<a name="ln3800"> </a>
<a name="ln3801">  return errmsg;</a>
<a name="ln3802">}</a>
<a name="ln3803"> </a>
<a name="ln3804">/// Set the value of an option</a>
<a name="ln3805">///</a>
<a name="ln3806">/// @param[in]  name       Option name.</a>
<a name="ln3807">/// @param[in]  value      Option value. If NIL_OPTVAL, the option value is cleared.</a>
<a name="ln3808">/// @param[in]  opt_flags  Flags: OPT_LOCAL, OPT_GLOBAL, or 0 (both).</a>
<a name="ln3809">///</a>
<a name="ln3810">/// @return NULL on success, an untranslated error message on error.</a>
<a name="ln3811">const char *set_option_value(const char *const name, const OptVal value, int opt_flags)</a>
<a name="ln3812">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3813">{</a>
<a name="ln3814">  static const char *optval_type_names[] = {</a>
<a name="ln3815">    [kOptValTypeNil] = &quot;Nil&quot;,</a>
<a name="ln3816">    [kOptValTypeBoolean] = &quot;Boolean&quot;,</a>
<a name="ln3817">    [kOptValTypeNumber] = &quot;Number&quot;,</a>
<a name="ln3818">    [kOptValTypeString] = &quot;String&quot;</a>
<a name="ln3819">  };</a>
<a name="ln3820"> </a>
<a name="ln3821">  static char errbuf[IOSIZE];</a>
<a name="ln3822"> </a>
<a name="ln3823">  if (is_tty_option(name)) {</a>
<a name="ln3824">    return NULL;  // Fail silently; many old vimrcs set t_xx options.</a>
<a name="ln3825">  }</a>
<a name="ln3826"> </a>
<a name="ln3827">  int opt_idx = findoption(name);</a>
<a name="ln3828">  if (opt_idx &lt; 0) {</a>
<a name="ln3829">    snprintf(errbuf, IOSIZE, _(e_unknown_option2), name);</a>
<a name="ln3830">    return errbuf;</a>
<a name="ln3831">  }</a>
<a name="ln3832"> </a>
<a name="ln3833">  uint32_t flags = options[opt_idx].flags;</a>
<a name="ln3834">  // Disallow changing some options in the sandbox</a>
<a name="ln3835">  if (sandbox &gt; 0 &amp;&amp; (flags &amp; P_SECURE)) {</a>
<a name="ln3836">    return _(e_sandbox);</a>
<a name="ln3837">  }</a>
<a name="ln3838"> </a>
<a name="ln3839">  void *varp = get_varp_scope(&amp;(options[opt_idx]), opt_flags);</a>
<a name="ln3840">  if (varp == NULL) {</a>
<a name="ln3841">    // hidden option is not changed</a>
<a name="ln3842">    return NULL;</a>
<a name="ln3843">  }</a>
<a name="ln3844"> </a>
<a name="ln3845">  const char *errmsg = NULL;</a>
<a name="ln3846">  // Copy the value so we can modify the copy.</a>
<a name="ln3847">  OptVal v = optval_copy(value);</a>
<a name="ln3848"> </a>
<a name="ln3849">  if (v.type == kOptValTypeNil) {</a>
<a name="ln3850">    v = clear_optval(name, flags, varp, curbuf, curwin);</a>
<a name="ln3851">  } else if (!optval_match_type(v, opt_idx)) {</a>
<a name="ln3852">    char *rep = optval_to_cstr(v);</a>
<a name="ln3853">    char *valid_types = option_get_valid_types(opt_idx);</a>
<a name="ln3854">    snprintf(errbuf, IOSIZE, _(&quot;Invalid value for option '%s': expected %s, got %s %s&quot;),</a>
<a name="ln3855">             name, valid_types, optval_type_names[v.type], rep);</a>
<a name="ln3856">    xfree(rep);</a>
<a name="ln3857">    xfree(valid_types);</a>
<a name="ln3858">    errmsg = errbuf;</a>
<a name="ln3859">    goto end;</a>
<a name="ln3860">  }</a>
<a name="ln3861"> </a>
<a name="ln3862">  errmsg = set_option(opt_idx, varp, &amp;v, opt_flags, errbuf, sizeof(errbuf));</a>
<a name="ln3863"> </a>
<a name="ln3864">end:</a>
<a name="ln3865">  optval_free(v);  // Free the copied OptVal.</a>
<a name="ln3866">  return errmsg;</a>
<a name="ln3867">}</a>
<a name="ln3868"> </a>
<a name="ln3869">/// Call set_option_value() and when an error is returned report it.</a>
<a name="ln3870">///</a>
<a name="ln3871">/// @param opt_flags  OPT_LOCAL or 0 (both)</a>
<a name="ln3872">void set_option_value_give_err(const char *name, OptVal value, int opt_flags)</a>
<a name="ln3873">{</a>
<a name="ln3874">  const char *errmsg = set_option_value(name, value, opt_flags);</a>
<a name="ln3875"> </a>
<a name="ln3876">  if (errmsg != NULL) {</a>
<a name="ln3877">    emsg(_(errmsg));</a>
<a name="ln3878">  }</a>
<a name="ln3879">}</a>
<a name="ln3880"> </a>
<a name="ln3881">bool is_option_allocated(const char *name)</a>
<a name="ln3882">{</a>
<a name="ln3883">  int idx = findoption(name);</a>
<a name="ln3884">  return idx &gt;= 0 &amp;&amp; (options[idx].flags &amp; P_ALLOCED);</a>
<a name="ln3885">}</a>
<a name="ln3886"> </a>
<a name="ln3887">// Translate a string like &quot;t_xx&quot;, &quot;&lt;t_xx&gt;&quot; or &quot;&lt;S-Tab&gt;&quot; to a key number.</a>
<a name="ln3888">// When &quot;has_lt&quot; is true there is a '&lt;' before &quot;*arg_arg&quot;.</a>
<a name="ln3889">// Returns 0 when the key is not recognized.</a>
<a name="ln3890">int find_key_option_len(const char *arg_arg, size_t len, bool has_lt)</a>
<a name="ln3891">{</a>
<a name="ln3892">  int key = 0;</a>
<a name="ln3893">  const char *arg = arg_arg;</a>
<a name="ln3894"> </a>
<a name="ln3895">  // Don't use get_special_key_code() for t_xx, we don't want it to call</a>
<a name="ln3896">  // add_termcap_entry().</a>
<a name="ln3897">  if (len &gt;= 4 &amp;&amp; arg[0] == 't' &amp;&amp; arg[1] == '_') {</a>
<a name="ln3898">    key = TERMCAP2KEY((uint8_t)arg[2], (uint8_t)arg[3]);</a>
<a name="ln3899">  } else if (has_lt) {</a>
<a name="ln3900">    arg--;  // put arg at the '&lt;'</a>
<a name="ln3901">    int modifiers = 0;</a>
<a name="ln3902">    key = find_special_key(&amp;arg, len + 1, &amp;modifiers,</a>
<a name="ln3903">                           FSK_KEYCODE | FSK_KEEP_X_KEY | FSK_SIMPLIFY, NULL);</a>
<a name="ln3904">    if (modifiers) {  // can't handle modifiers here</a>
<a name="ln3905">      key = 0;</a>
<a name="ln3906">    }</a>
<a name="ln3907">  }</a>
<a name="ln3908">  return key;</a>
<a name="ln3909">}</a>
<a name="ln3910"> </a>
<a name="ln3911">static int find_key_option(const char *arg, bool has_lt)</a>
<a name="ln3912">{</a>
<a name="ln3913">  return find_key_option_len(arg, strlen(arg), has_lt);</a>
<a name="ln3914">}</a>
<a name="ln3915"> </a>
<a name="ln3916">/// if 'all' == false: show changed options</a>
<a name="ln3917">/// if 'all' == true: show all normal options</a>
<a name="ln3918">///</a>
<a name="ln3919">/// @param opt_flags  OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln3920">static void showoptions(bool all, int opt_flags)</a>
<a name="ln3921">{</a>
<a name="ln3922">#define INC 20</a>
<a name="ln3923">#define GAP 3</a>
<a name="ln3924"> </a>
<a name="ln3925">  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * OPTION_COUNT);</a>
<a name="ln3926"> </a>
<a name="ln3927">  // Highlight title</a>
<a name="ln3928">  if (opt_flags &amp; OPT_GLOBAL) {</a>
<a name="ln3929">    msg_puts_title(_(&quot;\n--- Global option values ---&quot;));</a>
<a name="ln3930">  } else if (opt_flags &amp; OPT_LOCAL) {</a>
<a name="ln3931">    msg_puts_title(_(&quot;\n--- Local option values ---&quot;));</a>
<a name="ln3932">  } else {</a>
<a name="ln3933">    msg_puts_title(_(&quot;\n--- Options ---&quot;));</a>
<a name="ln3934">  }</a>
<a name="ln3935"> </a>
<a name="ln3936">  // Do the loop two times:</a>
<a name="ln3937">  // 1. display the short items</a>
<a name="ln3938">  // 2. display the long items (only strings and numbers)</a>
<a name="ln3939">  // When &quot;opt_flags&quot; has OPT_ONECOLUMN do everything in run 2.</a>
<a name="ln3940">  for (int run = 1; run &lt;= 2 &amp;&amp; !got_int; run++) {</a>
<a name="ln3941">    // collect the items in items[]</a>
<a name="ln3942">    int item_count = 0;</a>
<a name="ln3943">    for (vimoption_T *p = &amp;options[0]; p-&gt;fullname != NULL; p++) {</a>
<a name="ln3944">      // apply :filter /pat/</a>
<a name="ln3945">      if (message_filtered(p-&gt;fullname)) {</a>
<a name="ln3946">        continue;</a>
<a name="ln3947">      }</a>
<a name="ln3948"> </a>
<a name="ln3949">      void *varp = NULL;</a>
<a name="ln3950">      if ((opt_flags &amp; (OPT_LOCAL | OPT_GLOBAL)) != 0) {</a>
<a name="ln3951">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln3952">          varp = get_varp_scope(p, opt_flags);</a>
<a name="ln3953">        }</a>
<a name="ln3954">      } else {</a>
<a name="ln3955">        varp = get_varp(p);</a>
<a name="ln3956">      }</a>
<a name="ln3957">      if (varp != NULL &amp;&amp; (all || !optval_default(p, varp))) {</a>
<a name="ln3958">        int len;</a>
<a name="ln3959">        if (opt_flags &amp; OPT_ONECOLUMN) {</a>
<a name="ln3960">          len = Columns;</a>
<a name="ln3961">        } else if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln3962">          len = 1;                      // a toggle option fits always</a>
<a name="ln3963">        } else {</a>
<a name="ln3964">          option_value2string(p, opt_flags);</a>
<a name="ln3965">          len = (int)strlen(p-&gt;fullname) + vim_strsize(NameBuff) + 1;</a>
<a name="ln3966">        }</a>
<a name="ln3967">        if ((len &lt;= INC - GAP &amp;&amp; run == 1)</a>
<a name="ln3968">            || (len &gt; INC - GAP &amp;&amp; run == 2)) {</a>
<a name="ln3969">          items[item_count++] = p;</a>
<a name="ln3970">        }</a>
<a name="ln3971">      }</a>
<a name="ln3972">    }</a>
<a name="ln3973"> </a>
<a name="ln3974">    int rows;</a>
<a name="ln3975"> </a>
<a name="ln3976">    // display the items</a>
<a name="ln3977">    if (run == 1) {</a>
<a name="ln3978">      assert(Columns &lt;= INT_MAX - GAP</a>
<a name="ln3979">             &amp;&amp; Columns + GAP &gt;= INT_MIN + 3</a>
<a name="ln3980">             &amp;&amp; (Columns + GAP - 3) / INC &gt;= INT_MIN</a>
<a name="ln3981">             &amp;&amp; (Columns + GAP - 3) / INC &lt;= INT_MAX);</a>
<a name="ln3982">      int cols = (Columns + GAP - 3) / INC;</a>
<a name="ln3983">      if (cols == 0) {</a>
<a name="ln3984">        cols = 1;</a>
<a name="ln3985">      }</a>
<a name="ln3986">      rows = (item_count + cols - 1) / cols;</a>
<a name="ln3987">    } else {    // run == 2</a>
<a name="ln3988">      rows = item_count;</a>
<a name="ln3989">    }</a>
<a name="ln3990">    for (int row = 0; row &lt; rows &amp;&amp; !got_int; row++) {</a>
<a name="ln3991">      msg_putchar('\n');                        // go to next line</a>
<a name="ln3992">      if (got_int) {                            // 'q' typed in more</a>
<a name="ln3993">        break;</a>
<a name="ln3994">      }</a>
<a name="ln3995">      int col = 0;</a>
<a name="ln3996">      for (int i = row; i &lt; item_count; i += rows) {</a>
<a name="ln3997">        msg_col = col;                          // make columns</a>
<a name="ln3998">        showoneopt(items[i], opt_flags);</a>
<a name="ln3999">        col += INC;</a>
<a name="ln4000">      }</a>
<a name="ln4001">      os_breakcheck();</a>
<a name="ln4002">    }</a>
<a name="ln4003">  }</a>
<a name="ln4004">  xfree(items);</a>
<a name="ln4005">}</a>
<a name="ln4006"> </a>
<a name="ln4007">/// Return true if option &quot;p&quot; has its default value.</a>
<a name="ln4008">static int optval_default(vimoption_T *p, const void *varp)</a>
<a name="ln4009">{</a>
<a name="ln4010">  if (varp == NULL) {</a>
<a name="ln4011">    return true;            // hidden option is always at default</a>
<a name="ln4012">  }</a>
<a name="ln4013">  if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4014">    return *(OptInt *)varp == (OptInt)(intptr_t)p-&gt;def_val;</a>
<a name="ln4015">  }</a>
<a name="ln4016">  if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4017">    return *(int *)varp == (int)(intptr_t)p-&gt;def_val;</a>
<a name="ln4018">  }</a>
<a name="ln4019">  // P_STRING</a>
<a name="ln4020">  return strcmp(*(char **)varp, p-&gt;def_val) == 0;</a>
<a name="ln4021">}</a>
<a name="ln4022"> </a>
<a name="ln4023">/// Send update to UIs with values of UI relevant options</a>
<a name="ln4024">void ui_refresh_options(void)</a>
<a name="ln4025">{</a>
<a name="ln4026">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln4027">    uint32_t flags = options[opt_idx].flags;</a>
<a name="ln4028">    if (!(flags &amp; P_UI_OPTION)) {</a>
<a name="ln4029">      continue;</a>
<a name="ln4030">    }</a>
<a name="ln4031">    String name = cstr_as_string(options[opt_idx].fullname);</a>
<a name="ln4032">    void *varp = options[opt_idx].var;</a>
<a name="ln4033">    Object value = OBJECT_INIT;</a>
<a name="ln4034">    if (flags &amp; P_BOOL) {</a>
<a name="ln4035">      value = BOOLEAN_OBJ(*(int *)varp);</a>
<a name="ln4036">    } else if (flags &amp; P_NUM) {</a>
<a name="ln4037">      value = INTEGER_OBJ(*(OptInt *)varp);</a>
<a name="ln4038">    } else if (flags &amp; P_STRING) {</a>
<a name="ln4039">      // cstr_as_string handles NULL string</a>
<a name="ln4040">      value = CSTR_AS_OBJ(*(char **)varp);</a>
<a name="ln4041">    }</a>
<a name="ln4042">    ui_call_option_set(name, value);</a>
<a name="ln4043">  }</a>
<a name="ln4044">  if (p_mouse != NULL) {</a>
<a name="ln4045">    setmouse();</a>
<a name="ln4046">  }</a>
<a name="ln4047">}</a>
<a name="ln4048"> </a>
<a name="ln4049">/// showoneopt: show the value of one option</a>
<a name="ln4050">/// must not be called with a hidden option!</a>
<a name="ln4051">///</a>
<a name="ln4052">/// @param opt_flags  OPT_LOCAL or OPT_GLOBAL</a>
<a name="ln4053">static void showoneopt(vimoption_T *p, int opt_flags)</a>
<a name="ln4054">{</a>
<a name="ln4055">  int save_silent = silent_mode;</a>
<a name="ln4056"> </a>
<a name="ln4057">  silent_mode = false;</a>
<a name="ln4058">  info_message = true;          // use os_msg(), not os_errmsg()</a>
<a name="ln4059"> </a>
<a name="ln4060">  void *varp = get_varp_scope(p, opt_flags);</a>
<a name="ln4061"> </a>
<a name="ln4062">  // for 'modified' we also need to check if 'ff' or 'fenc' changed.</a>
<a name="ln4063">  if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; ((int *)varp == &amp;curbuf-&gt;b_changed</a>
<a name="ln4064">                              ? !curbufIsChanged() : !*(int *)varp)) {</a>
<a name="ln4065">    msg_puts(&quot;no&quot;);</a>
<a name="ln4066">  } else if ((p-&gt;flags &amp; P_BOOL) &amp;&amp; *(int *)varp &lt; 0) {</a>
<a name="ln4067">    msg_puts(&quot;--&quot;);</a>
<a name="ln4068">  } else {</a>
<a name="ln4069">    msg_puts(&quot;  &quot;);</a>
<a name="ln4070">  }</a>
<a name="ln4071">  msg_puts(p-&gt;fullname);</a>
<a name="ln4072">  if (!(p-&gt;flags &amp; P_BOOL)) {</a>
<a name="ln4073">    msg_putchar('=');</a>
<a name="ln4074">    // put value string in NameBuff</a>
<a name="ln4075">    option_value2string(p, opt_flags);</a>
<a name="ln4076">    msg_outtrans(NameBuff, 0);</a>
<a name="ln4077">  }</a>
<a name="ln4078"> </a>
<a name="ln4079">  silent_mode = save_silent;</a>
<a name="ln4080">  info_message = false;</a>
<a name="ln4081">}</a>
<a name="ln4082"> </a>
<a name="ln4083">/// Write modified options as &quot;:set&quot; commands to a file.</a>
<a name="ln4084">///</a>
<a name="ln4085">/// There are three values for &quot;opt_flags&quot;:</a>
<a name="ln4086">/// OPT_GLOBAL:         Write global option values and fresh values of</a>
<a name="ln4087">///             buffer-local options (used for start of a session</a>
<a name="ln4088">///             file).</a>
<a name="ln4089">/// OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for</a>
<a name="ln4090">///             curwin (used for a vimrc file).</a>
<a name="ln4091">/// OPT_LOCAL:          Write buffer-local option values for curbuf, fresh</a>
<a name="ln4092">///             and local values for window-local options of</a>
<a name="ln4093">///             curwin.  Local values are also written when at the</a>
<a name="ln4094">///             default value, because a modeline or autocommand</a>
<a name="ln4095">///             may have set them when doing &quot;:edit file&quot; and the</a>
<a name="ln4096">///             user has set them back at the default or fresh</a>
<a name="ln4097">///             value.</a>
<a name="ln4098">///             When &quot;local_only&quot; is true, don't write fresh</a>
<a name="ln4099">///             values, only local values (for &quot;:mkview&quot;).</a>
<a name="ln4100">/// (fresh value = value used for a new buffer or window for a local option).</a>
<a name="ln4101">///</a>
<a name="ln4102">/// Return FAIL on error, OK otherwise.</a>
<a name="ln4103">int makeset(FILE *fd, int opt_flags, int local_only)</a>
<a name="ln4104">{</a>
<a name="ln4105">  // Some options are never written:</a>
<a name="ln4106">  // - Options that don't have a default (terminal name, columns, lines).</a>
<a name="ln4107">  // - Terminal options.</a>
<a name="ln4108">  // - Hidden options.</a>
<a name="ln4109">  //</a>
<a name="ln4110">  // Do the loop over &quot;options[]&quot; twice: once for options with the</a>
<a name="ln4111">  // P_PRI_MKRC flag and once without.</a>
<a name="ln4112">  for (int pri = 1; pri &gt;= 0; pri--) {</a>
<a name="ln4113">    for (vimoption_T *p = &amp;options[0]; p-&gt;fullname; p++) {</a>
<a name="ln4114">      if (!(p-&gt;flags &amp; P_NO_MKRC)</a>
<a name="ln4115">          &amp;&amp; ((pri == 1) == ((p-&gt;flags &amp; P_PRI_MKRC) != 0))) {</a>
<a name="ln4116">        // skip global option when only doing locals</a>
<a name="ln4117">        if (p-&gt;indir == PV_NONE &amp;&amp; !(opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln4118">          continue;</a>
<a name="ln4119">        }</a>
<a name="ln4120"> </a>
<a name="ln4121">        // Do not store options like 'bufhidden' and 'syntax' in a vimrc</a>
<a name="ln4122">        // file, they are always buffer-specific.</a>
<a name="ln4123">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; (p-&gt;flags &amp; P_NOGLOB)) {</a>
<a name="ln4124">          continue;</a>
<a name="ln4125">        }</a>
<a name="ln4126"> </a>
<a name="ln4127">        void *varp = get_varp_scope(p, opt_flags);  // currently used value</a>
<a name="ln4128">        // Hidden options are never written.</a>
<a name="ln4129">        if (!varp) {</a>
<a name="ln4130">          continue;</a>
<a name="ln4131">        }</a>
<a name="ln4132">        // Global values are only written when not at the default value.</a>
<a name="ln4133">        if ((opt_flags &amp; OPT_GLOBAL) &amp;&amp; optval_default(p, varp)) {</a>
<a name="ln4134">          continue;</a>
<a name="ln4135">        }</a>
<a name="ln4136"> </a>
<a name="ln4137">        if ((opt_flags &amp; OPT_SKIPRTP)</a>
<a name="ln4138">            &amp;&amp; (p-&gt;var == &amp;p_rtp || p-&gt;var == &amp;p_pp)) {</a>
<a name="ln4139">          continue;</a>
<a name="ln4140">        }</a>
<a name="ln4141"> </a>
<a name="ln4142">        int round = 2;</a>
<a name="ln4143">        void *varp_local = NULL;  // fresh value</a>
<a name="ln4144">        if (p-&gt;indir != PV_NONE) {</a>
<a name="ln4145">          if (p-&gt;var == VAR_WIN) {</a>
<a name="ln4146">            // skip window-local option when only doing globals</a>
<a name="ln4147">            if (!(opt_flags &amp; OPT_LOCAL)) {</a>
<a name="ln4148">              continue;</a>
<a name="ln4149">            }</a>
<a name="ln4150">            // When fresh value of window-local option is not at the</a>
<a name="ln4151">            // default, need to write it too.</a>
<a name="ln4152">            if (!(opt_flags &amp; OPT_GLOBAL) &amp;&amp; !local_only) {</a>
<a name="ln4153">              void *varp_fresh = get_varp_scope(p, OPT_GLOBAL);  // local value</a>
<a name="ln4154">              if (!optval_default(p, varp_fresh)) {</a>
<a name="ln4155">                round = 1;</a>
<a name="ln4156">                varp_local = varp;</a>
<a name="ln4157">                varp = varp_fresh;</a>
<a name="ln4158">              }</a>
<a name="ln4159">            }</a>
<a name="ln4160">          }</a>
<a name="ln4161">        }</a>
<a name="ln4162"> </a>
<a name="ln4163">        // Round 1: fresh value for window-local options.</a>
<a name="ln4164">        // Round 2: other values</a>
<a name="ln4165">        for (; round &lt;= 2; varp = varp_local, round++) {</a>
<a name="ln4166">          char *cmd;</a>
<a name="ln4167">          if (round == 1 || (opt_flags &amp; OPT_GLOBAL)) {</a>
<a name="ln4168">            cmd = &quot;set&quot;;</a>
<a name="ln4169">          } else {</a>
<a name="ln4170">            cmd = &quot;setlocal&quot;;</a>
<a name="ln4171">          }</a>
<a name="ln4172"> </a>
<a name="ln4173">          if (p-&gt;flags &amp; P_BOOL) {</a>
<a name="ln4174">            if (put_setbool(fd, cmd, p-&gt;fullname, *(int *)varp) == FAIL) {</a>
<a name="ln4175">              return FAIL;</a>
<a name="ln4176">            }</a>
<a name="ln4177">          } else if (p-&gt;flags &amp; P_NUM) {</a>
<a name="ln4178">            if (put_setnum(fd, cmd, p-&gt;fullname, (OptInt *)varp) == FAIL) {</a>
<a name="ln4179">              return FAIL;</a>
<a name="ln4180">            }</a>
<a name="ln4181">          } else {    // P_STRING</a>
<a name="ln4182">            int do_endif = false;</a>
<a name="ln4183"> </a>
<a name="ln4184">            // Don't set 'syntax' and 'filetype' again if the value is</a>
<a name="ln4185">            // already right, avoids reloading the syntax file.</a>
<a name="ln4186">            if (p-&gt;indir == PV_SYN || p-&gt;indir == PV_FT) {</a>
<a name="ln4187">              if (fprintf(fd, &quot;if &amp;%s != '%s'&quot;, p-&gt;fullname,</a>
<a name="ln4188">                          *(char **)(varp)) &lt; 0</a>
<a name="ln4189">                  || put_eol(fd) &lt; 0) {</a>
<a name="ln4190">                return FAIL;</a>
<a name="ln4191">              }</a>
<a name="ln4192">              do_endif = true;</a>
<a name="ln4193">            }</a>
<a name="ln4194">            if (put_setstring(fd, cmd, p-&gt;fullname, (char **)varp, p-&gt;flags) == FAIL) {</a>
<a name="ln4195">              return FAIL;</a>
<a name="ln4196">            }</a>
<a name="ln4197">            if (do_endif) {</a>
<a name="ln4198">              if (put_line(fd, &quot;endif&quot;) == FAIL) {</a>
<a name="ln4199">                return FAIL;</a>
<a name="ln4200">              }</a>
<a name="ln4201">            }</a>
<a name="ln4202">          }</a>
<a name="ln4203">        }</a>
<a name="ln4204">      }</a>
<a name="ln4205">    }</a>
<a name="ln4206">  }</a>
<a name="ln4207">  return OK;</a>
<a name="ln4208">}</a>
<a name="ln4209"> </a>
<a name="ln4210">/// Generate set commands for the local fold options only.  Used when</a>
<a name="ln4211">/// 'sessionoptions' or 'viewoptions' contains &quot;folds&quot; but not &quot;options&quot;.</a>
<a name="ln4212">int makefoldset(FILE *fd)</a>
<a name="ln4213">{</a>
<a name="ln4214">  if (put_setstring(fd, &quot;setlocal&quot;, &quot;fdm&quot;, &amp;curwin-&gt;w_p_fdm, 0) == FAIL</a>
<a name="ln4215">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fde&quot;, &amp;curwin-&gt;w_p_fde, 0) == FAIL</a>
<a name="ln4216">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fmr&quot;, &amp;curwin-&gt;w_p_fmr, 0) == FAIL</a>
<a name="ln4217">      || put_setstring(fd, &quot;setlocal&quot;, &quot;fdi&quot;, &amp;curwin-&gt;w_p_fdi, 0) == FAIL</a>
<a name="ln4218">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdl&quot;, &amp;curwin-&gt;w_p_fdl) == FAIL</a>
<a name="ln4219">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fml&quot;, &amp;curwin-&gt;w_p_fml) == FAIL</a>
<a name="ln4220">      || put_setnum(fd, &quot;setlocal&quot;, &quot;fdn&quot;, &amp;curwin-&gt;w_p_fdn) == FAIL</a>
<a name="ln4221">      || put_setbool(fd, &quot;setlocal&quot;, &quot;fen&quot;, curwin-&gt;w_p_fen) == FAIL) {</a>
<a name="ln4222">    return FAIL;</a>
<a name="ln4223">  }</a>
<a name="ln4224"> </a>
<a name="ln4225">  return OK;</a>
<a name="ln4226">}</a>
<a name="ln4227"> </a>
<a name="ln4228">static int put_setstring(FILE *fd, char *cmd, char *name, char **valuep, uint64_t flags)</a>
<a name="ln4229">{</a>
<a name="ln4230">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln4231">    return FAIL;</a>
<a name="ln4232">  }</a>
<a name="ln4233"> </a>
<a name="ln4234">  char *buf = NULL;</a>
<a name="ln4235">  char *part = NULL;</a>
<a name="ln4236"> </a>
<a name="ln4237">  if (*valuep != NULL) {</a>
<a name="ln4238">    if ((flags &amp; P_EXPAND) != 0) {</a>
<a name="ln4239">      size_t size = (size_t)strlen(*valuep) + 1;</a>
<a name="ln4240"> </a>
<a name="ln4241">      // replace home directory in the whole option value into &quot;buf&quot;</a>
<a name="ln4242">      buf = xmalloc(size);</a>
<a name="ln4243">      home_replace(NULL, *valuep, buf, size, false);</a>
<a name="ln4244"> </a>
<a name="ln4245">      // If the option value is longer than MAXPATHL, we need to append</a>
<a name="ln4246">      // each comma separated part of the option separately, so that it</a>
<a name="ln4247">      // can be expanded when read back.</a>
<a name="ln4248">      if (size &gt;= MAXPATHL &amp;&amp; (flags &amp; P_COMMA) != 0</a>
<a name="ln4249">          &amp;&amp; vim_strchr(*valuep, ',') != NULL) {</a>
<a name="ln4250">        part = xmalloc(size);</a>
<a name="ln4251"> </a>
<a name="ln4252">        // write line break to clear the option, e.g. ':set rtp='</a>
<a name="ln4253">        if (put_eol(fd) == FAIL) {</a>
<a name="ln4254">          goto fail;</a>
<a name="ln4255">        }</a>
<a name="ln4256">        char *p = buf;</a>
<a name="ln4257">        while (*p != NUL) {</a>
<a name="ln4258">          // for each comma separated option part, append value to</a>
<a name="ln4259">          // the option, :set rtp+=value</a>
<a name="ln4260">          if (fprintf(fd, &quot;%s %s+=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln4261">            goto fail;</a>
<a name="ln4262">          }</a>
<a name="ln4263">          (void)copy_option_part(&amp;p, part, size, &quot;,&quot;);</a>
<a name="ln4264">          if (put_escstr(fd, part, 2) == FAIL || put_eol(fd) == FAIL) {</a>
<a name="ln4265">            goto fail;</a>
<a name="ln4266">          }</a>
<a name="ln4267">        }</a>
<a name="ln4268">        xfree(buf);</a>
<a name="ln4269">        xfree(part);</a>
<a name="ln4270">        return OK;</a>
<a name="ln4271">      }</a>
<a name="ln4272">      if (put_escstr(fd, buf, 2) == FAIL) {</a>
<a name="ln4273">        xfree(buf);</a>
<a name="ln4274">        return FAIL;</a>
<a name="ln4275">      }</a>
<a name="ln4276">      xfree(buf);</a>
<a name="ln4277">    } else if (put_escstr(fd, *valuep, 2) == FAIL) {</a>
<a name="ln4278">      return FAIL;</a>
<a name="ln4279">    }</a>
<a name="ln4280">  }</a>
<a name="ln4281">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln4282">    return FAIL;</a>
<a name="ln4283">  }</a>
<a name="ln4284">  return OK;</a>
<a name="ln4285">fail:</a>
<a name="ln4286">  xfree(buf);</a>
<a name="ln4287">  xfree(part);</a>
<a name="ln4288">  return FAIL;</a>
<a name="ln4289">}</a>
<a name="ln4290"> </a>
<a name="ln4291">static int put_setnum(FILE *fd, char *cmd, char *name, OptInt *valuep)</a>
<a name="ln4292">{</a>
<a name="ln4293">  if (fprintf(fd, &quot;%s %s=&quot;, cmd, name) &lt; 0) {</a>
<a name="ln4294">    return FAIL;</a>
<a name="ln4295">  }</a>
<a name="ln4296">  OptInt wc;</a>
<a name="ln4297">  if (wc_use_keyname(valuep, &amp;wc)) {</a>
<a name="ln4298">    // print 'wildchar' and 'wildcharm' as a key name</a>
<a name="ln4299">    if (fputs(get_special_key_name((int)wc, 0), fd) &lt; 0) {</a>
<a name="ln4300">      return FAIL;</a>
<a name="ln4301">    }</a>
<a name="ln4302">  } else if (fprintf(fd, &quot;%&quot; PRId64, (int64_t)(*valuep)) &lt; 0) {</a>
<a name="ln4303">    return FAIL;</a>
<a name="ln4304">  }</a>
<a name="ln4305">  if (put_eol(fd) &lt; 0) {</a>
<a name="ln4306">    return FAIL;</a>
<a name="ln4307">  }</a>
<a name="ln4308">  return OK;</a>
<a name="ln4309">}</a>
<a name="ln4310"> </a>
<a name="ln4311">static int put_setbool(FILE *fd, char *cmd, char *name, int value)</a>
<a name="ln4312">{</a>
<a name="ln4313">  if (value &lt; 0) {      // global/local option using global value</a>
<a name="ln4314">    return OK;</a>
<a name="ln4315">  }</a>
<a name="ln4316">  if (fprintf(fd, &quot;%s %s%s&quot;, cmd, value ? &quot;&quot; : &quot;no&quot;, name) &lt; 0</a>
<a name="ln4317">      || put_eol(fd) &lt; 0) {</a>
<a name="ln4318">    return FAIL;</a>
<a name="ln4319">  }</a>
<a name="ln4320">  return OK;</a>
<a name="ln4321">}</a>
<a name="ln4322"> </a>
<a name="ln4323">// Unset local option value, similar to &quot;:set opt&lt;&quot;.</a>
<a name="ln4324">void unset_global_local_option(char *name, void *from)</a>
<a name="ln4325">{</a>
<a name="ln4326">  vimoption_T *p;</a>
<a name="ln4327">  buf_T *buf = (buf_T *)from;</a>
<a name="ln4328"> </a>
<a name="ln4329">  int opt_idx = findoption(name);</a>
<a name="ln4330">  if (opt_idx &lt; 0) {</a>
<a name="ln4331">    semsg(_(&quot;E355: Unknown option: %s&quot;), name);</a>
<a name="ln4332">    return;</a>
<a name="ln4333">  }</a>
<a name="ln4334">  p = &amp;(options[opt_idx]);</a>
<a name="ln4335"> </a>
<a name="ln4336">  switch ((int)p-&gt;indir) {</a>
<a name="ln4337">  // global option with local value: use local value if it's been set</a>
<a name="ln4338">  case PV_EP:</a>
<a name="ln4339">    clear_string_option(&amp;buf-&gt;b_p_ep);</a>
<a name="ln4340">    break;</a>
<a name="ln4341">  case PV_KP:</a>
<a name="ln4342">    clear_string_option(&amp;buf-&gt;b_p_kp);</a>
<a name="ln4343">    break;</a>
<a name="ln4344">  case PV_PATH:</a>
<a name="ln4345">    clear_string_option(&amp;buf-&gt;b_p_path);</a>
<a name="ln4346">    break;</a>
<a name="ln4347">  case PV_AR:</a>
<a name="ln4348">    buf-&gt;b_p_ar = -1;</a>
<a name="ln4349">    break;</a>
<a name="ln4350">  case PV_BKC:</a>
<a name="ln4351">    clear_string_option(&amp;buf-&gt;b_p_bkc);</a>
<a name="ln4352">    buf-&gt;b_bkc_flags = 0;</a>
<a name="ln4353">    break;</a>
<a name="ln4354">  case PV_TAGS:</a>
<a name="ln4355">    clear_string_option(&amp;buf-&gt;b_p_tags);</a>
<a name="ln4356">    break;</a>
<a name="ln4357">  case PV_TC:</a>
<a name="ln4358">    clear_string_option(&amp;buf-&gt;b_p_tc);</a>
<a name="ln4359">    buf-&gt;b_tc_flags = 0;</a>
<a name="ln4360">    break;</a>
<a name="ln4361">  case PV_SISO:</a>
<a name="ln4362">    curwin-&gt;w_p_siso = -1;</a>
<a name="ln4363">    break;</a>
<a name="ln4364">  case PV_SO:</a>
<a name="ln4365">    curwin-&gt;w_p_so = -1;</a>
<a name="ln4366">    break;</a>
<a name="ln4367">  case PV_DEF:</a>
<a name="ln4368">    clear_string_option(&amp;buf-&gt;b_p_def);</a>
<a name="ln4369">    break;</a>
<a name="ln4370">  case PV_INC:</a>
<a name="ln4371">    clear_string_option(&amp;buf-&gt;b_p_inc);</a>
<a name="ln4372">    break;</a>
<a name="ln4373">  case PV_DICT:</a>
<a name="ln4374">    clear_string_option(&amp;buf-&gt;b_p_dict);</a>
<a name="ln4375">    break;</a>
<a name="ln4376">  case PV_TSR:</a>
<a name="ln4377">    clear_string_option(&amp;buf-&gt;b_p_tsr);</a>
<a name="ln4378">    break;</a>
<a name="ln4379">  case PV_TSRFU:</a>
<a name="ln4380">    clear_string_option(&amp;buf-&gt;b_p_tsrfu);</a>
<a name="ln4381">    break;</a>
<a name="ln4382">  case PV_FP:</a>
<a name="ln4383">    clear_string_option(&amp;buf-&gt;b_p_fp);</a>
<a name="ln4384">    break;</a>
<a name="ln4385">  case PV_EFM:</a>
<a name="ln4386">    clear_string_option(&amp;buf-&gt;b_p_efm);</a>
<a name="ln4387">    break;</a>
<a name="ln4388">  case PV_GP:</a>
<a name="ln4389">    clear_string_option(&amp;buf-&gt;b_p_gp);</a>
<a name="ln4390">    break;</a>
<a name="ln4391">  case PV_MP:</a>
<a name="ln4392">    clear_string_option(&amp;buf-&gt;b_p_mp);</a>
<a name="ln4393">    break;</a>
<a name="ln4394">  case PV_SBR:</a>
<a name="ln4395">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_sbr);</a>
<a name="ln4396">    break;</a>
<a name="ln4397">  case PV_STL:</a>
<a name="ln4398">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_stl);</a>
<a name="ln4399">    break;</a>
<a name="ln4400">  case PV_WBR:</a>
<a name="ln4401">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_wbr);</a>
<a name="ln4402">    break;</a>
<a name="ln4403">  case PV_UL:</a>
<a name="ln4404">    buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln4405">    break;</a>
<a name="ln4406">  case PV_LW:</a>
<a name="ln4407">    clear_string_option(&amp;buf-&gt;b_p_lw);</a>
<a name="ln4408">    break;</a>
<a name="ln4409">  case PV_MENC:</a>
<a name="ln4410">    clear_string_option(&amp;buf-&gt;b_p_menc);</a>
<a name="ln4411">    break;</a>
<a name="ln4412">  case PV_LCS:</a>
<a name="ln4413">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_lcs);</a>
<a name="ln4414">    set_listchars_option((win_T *)from, ((win_T *)from)-&gt;w_p_lcs, true);</a>
<a name="ln4415">    redraw_later((win_T *)from, UPD_NOT_VALID);</a>
<a name="ln4416">    break;</a>
<a name="ln4417">  case PV_FCS:</a>
<a name="ln4418">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_fcs);</a>
<a name="ln4419">    set_fillchars_option((win_T *)from, ((win_T *)from)-&gt;w_p_fcs, true);</a>
<a name="ln4420">    redraw_later((win_T *)from, UPD_NOT_VALID);</a>
<a name="ln4421">    break;</a>
<a name="ln4422">  case PV_VE:</a>
<a name="ln4423">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_ve);</a>
<a name="ln4424">    ((win_T *)from)-&gt;w_ve_flags = 0;</a>
<a name="ln4425">    break;</a>
<a name="ln4426">  case PV_STC:</a>
<a name="ln4427">    clear_string_option(&amp;((win_T *)from)-&gt;w_p_stc);</a>
<a name="ln4428">    break;</a>
<a name="ln4429">  }</a>
<a name="ln4430">}</a>
<a name="ln4431"> </a>
<a name="ln4432">void *get_varp_scope_from(vimoption_T *p, int scope, buf_T *buf, win_T *win)</a>
<a name="ln4433">{</a>
<a name="ln4434">  if ((scope &amp; OPT_GLOBAL) &amp;&amp; p-&gt;indir != PV_NONE) {</a>
<a name="ln4435">    if (p-&gt;var == VAR_WIN) {</a>
<a name="ln4436">      return GLOBAL_WO(get_varp_from(p, buf, win));</a>
<a name="ln4437">    }</a>
<a name="ln4438">    return p-&gt;var;</a>
<a name="ln4439">  }</a>
<a name="ln4440">  if ((scope &amp; OPT_LOCAL) &amp;&amp; ((int)p-&gt;indir &amp; PV_BOTH)) {</a>
<a name="ln4441">    switch ((int)p-&gt;indir) {</a>
<a name="ln4442">    case PV_FP:</a>
<a name="ln4443">      return &amp;(buf-&gt;b_p_fp);</a>
<a name="ln4444">    case PV_EFM:</a>
<a name="ln4445">      return &amp;(buf-&gt;b_p_efm);</a>
<a name="ln4446">    case PV_GP:</a>
<a name="ln4447">      return &amp;(buf-&gt;b_p_gp);</a>
<a name="ln4448">    case PV_MP:</a>
<a name="ln4449">      return &amp;(buf-&gt;b_p_mp);</a>
<a name="ln4450">    case PV_EP:</a>
<a name="ln4451">      return &amp;(buf-&gt;b_p_ep);</a>
<a name="ln4452">    case PV_KP:</a>
<a name="ln4453">      return &amp;(buf-&gt;b_p_kp);</a>
<a name="ln4454">    case PV_PATH:</a>
<a name="ln4455">      return &amp;(buf-&gt;b_p_path);</a>
<a name="ln4456">    case PV_AR:</a>
<a name="ln4457">      return &amp;(buf-&gt;b_p_ar);</a>
<a name="ln4458">    case PV_TAGS:</a>
<a name="ln4459">      return &amp;(buf-&gt;b_p_tags);</a>
<a name="ln4460">    case PV_TC:</a>
<a name="ln4461">      return &amp;(buf-&gt;b_p_tc);</a>
<a name="ln4462">    case PV_SISO:</a>
<a name="ln4463">      return &amp;(win-&gt;w_p_siso);</a>
<a name="ln4464">    case PV_SO:</a>
<a name="ln4465">      return &amp;(win-&gt;w_p_so);</a>
<a name="ln4466">    case PV_DEF:</a>
<a name="ln4467">      return &amp;(buf-&gt;b_p_def);</a>
<a name="ln4468">    case PV_INC:</a>
<a name="ln4469">      return &amp;(buf-&gt;b_p_inc);</a>
<a name="ln4470">    case PV_DICT:</a>
<a name="ln4471">      return &amp;(buf-&gt;b_p_dict);</a>
<a name="ln4472">    case PV_TSR:</a>
<a name="ln4473">      return &amp;(buf-&gt;b_p_tsr);</a>
<a name="ln4474">    case PV_TSRFU:</a>
<a name="ln4475">      return &amp;(buf-&gt;b_p_tsrfu);</a>
<a name="ln4476">    case PV_TFU:</a>
<a name="ln4477">      return &amp;(buf-&gt;b_p_tfu);</a>
<a name="ln4478">    case PV_SBR:</a>
<a name="ln4479">      return &amp;(win-&gt;w_p_sbr);</a>
<a name="ln4480">    case PV_STL:</a>
<a name="ln4481">      return &amp;(win-&gt;w_p_stl);</a>
<a name="ln4482">    case PV_WBR:</a>
<a name="ln4483">      return &amp;(win-&gt;w_p_wbr);</a>
<a name="ln4484">    case PV_UL:</a>
<a name="ln4485">      return &amp;(buf-&gt;b_p_ul);</a>
<a name="ln4486">    case PV_LW:</a>
<a name="ln4487">      return &amp;(buf-&gt;b_p_lw);</a>
<a name="ln4488">    case PV_BKC:</a>
<a name="ln4489">      return &amp;(buf-&gt;b_p_bkc);</a>
<a name="ln4490">    case PV_MENC:</a>
<a name="ln4491">      return &amp;(buf-&gt;b_p_menc);</a>
<a name="ln4492">    case PV_FCS:</a>
<a name="ln4493">      return &amp;(win-&gt;w_p_fcs);</a>
<a name="ln4494">    case PV_LCS:</a>
<a name="ln4495">      return &amp;(win-&gt;w_p_lcs);</a>
<a name="ln4496">    case PV_VE:</a>
<a name="ln4497">      return &amp;(win-&gt;w_p_ve);</a>
<a name="ln4498">    }</a>
<a name="ln4499">    return NULL;     // &quot;cannot happen&quot;</a>
<a name="ln4500">  }</a>
<a name="ln4501">  return get_varp_from(p, buf, win);</a>
<a name="ln4502">}</a>
<a name="ln4503"> </a>
<a name="ln4504">/// Get pointer to option variable, depending on local or global scope.</a>
<a name="ln4505">///</a>
<a name="ln4506">/// @param scope  can be OPT_LOCAL, OPT_GLOBAL or a combination.</a>
<a name="ln4507">void *get_varp_scope(vimoption_T *p, int scope)</a>
<a name="ln4508">{</a>
<a name="ln4509">  return get_varp_scope_from(p, scope, curbuf, curwin);</a>
<a name="ln4510">}</a>
<a name="ln4511"> </a>
<a name="ln4512">/// Get pointer to option variable at 'opt_idx', depending on local or global</a>
<a name="ln4513">/// scope.</a>
<a name="ln4514">void *get_option_varp_scope_from(int opt_idx, int scope, buf_T *buf, win_T *win)</a>
<a name="ln4515">{</a>
<a name="ln4516">  return get_varp_scope_from(&amp;(options[opt_idx]), scope, buf, win);</a>
<a name="ln4517">}</a>
<a name="ln4518"> </a>
<a name="ln4519">void *get_varp_from(vimoption_T *p, buf_T *buf, win_T *win)</a>
<a name="ln4520">{</a>
<a name="ln4521">  // hidden option, always return NULL</a>
<a name="ln4522">  if (p-&gt;var == NULL) {</a>
<a name="ln4523">    return NULL;</a>
<a name="ln4524">  }</a>
<a name="ln4525"> </a>
<a name="ln4526">  switch ((int)p-&gt;indir) {</a>
<a name="ln4527">  case PV_NONE:</a>
<a name="ln4528">    return p-&gt;var;</a>
<a name="ln4529"> </a>
<a name="ln4530">  // global option with local value: use local value if it's been set</a>
<a name="ln4531">  case PV_EP:</a>
<a name="ln4532">    return *buf-&gt;b_p_ep != NUL ? &amp;buf-&gt;b_p_ep : p-&gt;var;</a>
<a name="ln4533">  case PV_KP:</a>
<a name="ln4534">    return *buf-&gt;b_p_kp != NUL ? &amp;buf-&gt;b_p_kp : p-&gt;var;</a>
<a name="ln4535">  case PV_PATH:</a>
<a name="ln4536">    return *buf-&gt;b_p_path != NUL ? &amp;(buf-&gt;b_p_path) : p-&gt;var;</a>
<a name="ln4537">  case PV_AR:</a>
<a name="ln4538">    return buf-&gt;b_p_ar &gt;= 0 ? &amp;(buf-&gt;b_p_ar) : p-&gt;var;</a>
<a name="ln4539">  case PV_TAGS:</a>
<a name="ln4540">    return *buf-&gt;b_p_tags != NUL ? &amp;(buf-&gt;b_p_tags) : p-&gt;var;</a>
<a name="ln4541">  case PV_TC:</a>
<a name="ln4542">    return *buf-&gt;b_p_tc != NUL ? &amp;(buf-&gt;b_p_tc) : p-&gt;var;</a>
<a name="ln4543">  case PV_SISO:</a>
<a name="ln4544">    return win-&gt;w_p_siso &gt;= 0 ? &amp;(win-&gt;w_p_siso) : p-&gt;var;</a>
<a name="ln4545">  case PV_SO:</a>
<a name="ln4546">    return win-&gt;w_p_so &gt;= 0 ? &amp;(win-&gt;w_p_so) : p-&gt;var;</a>
<a name="ln4547">  case PV_BKC:</a>
<a name="ln4548">    return *buf-&gt;b_p_bkc != NUL ? &amp;(buf-&gt;b_p_bkc) : p-&gt;var;</a>
<a name="ln4549">  case PV_DEF:</a>
<a name="ln4550">    return *buf-&gt;b_p_def != NUL ? &amp;(buf-&gt;b_p_def) : p-&gt;var;</a>
<a name="ln4551">  case PV_INC:</a>
<a name="ln4552">    return *buf-&gt;b_p_inc != NUL ? &amp;(buf-&gt;b_p_inc) : p-&gt;var;</a>
<a name="ln4553">  case PV_DICT:</a>
<a name="ln4554">    return *buf-&gt;b_p_dict != NUL ? &amp;(buf-&gt;b_p_dict) : p-&gt;var;</a>
<a name="ln4555">  case PV_TSR:</a>
<a name="ln4556">    return *buf-&gt;b_p_tsr != NUL ? &amp;(buf-&gt;b_p_tsr) : p-&gt;var;</a>
<a name="ln4557">  case PV_TSRFU:</a>
<a name="ln4558">    return *buf-&gt;b_p_tsrfu != NUL ? &amp;(buf-&gt;b_p_tsrfu) : p-&gt;var;</a>
<a name="ln4559">  case PV_FP:</a>
<a name="ln4560">    return *buf-&gt;b_p_fp != NUL ? &amp;(buf-&gt;b_p_fp) : p-&gt;var;</a>
<a name="ln4561">  case PV_EFM:</a>
<a name="ln4562">    return *buf-&gt;b_p_efm != NUL ? &amp;(buf-&gt;b_p_efm) : p-&gt;var;</a>
<a name="ln4563">  case PV_GP:</a>
<a name="ln4564">    return *buf-&gt;b_p_gp != NUL ? &amp;(buf-&gt;b_p_gp) : p-&gt;var;</a>
<a name="ln4565">  case PV_MP:</a>
<a name="ln4566">    return *buf-&gt;b_p_mp != NUL ? &amp;(buf-&gt;b_p_mp) : p-&gt;var;</a>
<a name="ln4567">  case PV_SBR:</a>
<a name="ln4568">    return *win-&gt;w_p_sbr != NUL ? &amp;(win-&gt;w_p_sbr) : p-&gt;var;</a>
<a name="ln4569">  case PV_STL:</a>
<a name="ln4570">    return *win-&gt;w_p_stl != NUL ? &amp;(win-&gt;w_p_stl) : p-&gt;var;</a>
<a name="ln4571">  case PV_WBR:</a>
<a name="ln4572">    return *win-&gt;w_p_wbr != NUL ? &amp;(win-&gt;w_p_wbr) : p-&gt;var;</a>
<a name="ln4573">  case PV_UL:</a>
<a name="ln4574">    return buf-&gt;b_p_ul != NO_LOCAL_UNDOLEVEL ? &amp;(buf-&gt;b_p_ul) : p-&gt;var;</a>
<a name="ln4575">  case PV_LW:</a>
<a name="ln4576">    return *buf-&gt;b_p_lw != NUL ? &amp;(buf-&gt;b_p_lw) : p-&gt;var;</a>
<a name="ln4577">  case PV_MENC:</a>
<a name="ln4578">    return *buf-&gt;b_p_menc != NUL ? &amp;(buf-&gt;b_p_menc) : p-&gt;var;</a>
<a name="ln4579">  case PV_FCS:</a>
<a name="ln4580">    return *win-&gt;w_p_fcs != NUL ? &amp;(win-&gt;w_p_fcs) : p-&gt;var;</a>
<a name="ln4581">  case PV_LCS:</a>
<a name="ln4582">    return *win-&gt;w_p_lcs != NUL ? &amp;(win-&gt;w_p_lcs) : p-&gt;var;</a>
<a name="ln4583">  case PV_VE:</a>
<a name="ln4584">    return *win-&gt;w_p_ve != NUL ? &amp;win-&gt;w_p_ve : p-&gt;var;</a>
<a name="ln4585"> </a>
<a name="ln4586">  case PV_ARAB:</a>
<a name="ln4587">    return &amp;(win-&gt;w_p_arab);</a>
<a name="ln4588">  case PV_LIST:</a>
<a name="ln4589">    return &amp;(win-&gt;w_p_list);</a>
<a name="ln4590">  case PV_SPELL:</a>
<a name="ln4591">    return &amp;(win-&gt;w_p_spell);</a>
<a name="ln4592">  case PV_CUC:</a>
<a name="ln4593">    return &amp;(win-&gt;w_p_cuc);</a>
<a name="ln4594">  case PV_CUL:</a>
<a name="ln4595">    return &amp;(win-&gt;w_p_cul);</a>
<a name="ln4596">  case PV_CULOPT:</a>
<a name="ln4597">    return &amp;(win-&gt;w_p_culopt);</a>
<a name="ln4598">  case PV_CC:</a>
<a name="ln4599">    return &amp;(win-&gt;w_p_cc);</a>
<a name="ln4600">  case PV_DIFF:</a>
<a name="ln4601">    return &amp;(win-&gt;w_p_diff);</a>
<a name="ln4602">  case PV_FDC:</a>
<a name="ln4603">    return &amp;(win-&gt;w_p_fdc);</a>
<a name="ln4604">  case PV_FEN:</a>
<a name="ln4605">    return &amp;(win-&gt;w_p_fen);</a>
<a name="ln4606">  case PV_FDI:</a>
<a name="ln4607">    return &amp;(win-&gt;w_p_fdi);</a>
<a name="ln4608">  case PV_FDL:</a>
<a name="ln4609">    return &amp;(win-&gt;w_p_fdl);</a>
<a name="ln4610">  case PV_FDM:</a>
<a name="ln4611">    return &amp;(win-&gt;w_p_fdm);</a>
<a name="ln4612">  case PV_FML:</a>
<a name="ln4613">    return &amp;(win-&gt;w_p_fml);</a>
<a name="ln4614">  case PV_FDN:</a>
<a name="ln4615">    return &amp;(win-&gt;w_p_fdn);</a>
<a name="ln4616">  case PV_FDE:</a>
<a name="ln4617">    return &amp;(win-&gt;w_p_fde);</a>
<a name="ln4618">  case PV_FDT:</a>
<a name="ln4619">    return &amp;(win-&gt;w_p_fdt);</a>
<a name="ln4620">  case PV_FMR:</a>
<a name="ln4621">    return &amp;(win-&gt;w_p_fmr);</a>
<a name="ln4622">  case PV_NU:</a>
<a name="ln4623">    return &amp;(win-&gt;w_p_nu);</a>
<a name="ln4624">  case PV_RNU:</a>
<a name="ln4625">    return &amp;(win-&gt;w_p_rnu);</a>
<a name="ln4626">  case PV_NUW:</a>
<a name="ln4627">    return &amp;(win-&gt;w_p_nuw);</a>
<a name="ln4628">  case PV_WFH:</a>
<a name="ln4629">    return &amp;(win-&gt;w_p_wfh);</a>
<a name="ln4630">  case PV_WFW:</a>
<a name="ln4631">    return &amp;(win-&gt;w_p_wfw);</a>
<a name="ln4632">  case PV_PVW:</a>
<a name="ln4633">    return &amp;(win-&gt;w_p_pvw);</a>
<a name="ln4634">  case PV_RL:</a>
<a name="ln4635">    return &amp;(win-&gt;w_p_rl);</a>
<a name="ln4636">  case PV_RLC:</a>
<a name="ln4637">    return &amp;(win-&gt;w_p_rlc);</a>
<a name="ln4638">  case PV_SCROLL:</a>
<a name="ln4639">    return &amp;(win-&gt;w_p_scr);</a>
<a name="ln4640">  case PV_SMS:</a>
<a name="ln4641">    return &amp;(win-&gt;w_p_sms);</a>
<a name="ln4642">  case PV_WRAP:</a>
<a name="ln4643">    return &amp;(win-&gt;w_p_wrap);</a>
<a name="ln4644">  case PV_LBR:</a>
<a name="ln4645">    return &amp;(win-&gt;w_p_lbr);</a>
<a name="ln4646">  case PV_BRI:</a>
<a name="ln4647">    return &amp;(win-&gt;w_p_bri);</a>
<a name="ln4648">  case PV_BRIOPT:</a>
<a name="ln4649">    return &amp;(win-&gt;w_p_briopt);</a>
<a name="ln4650">  case PV_SCBIND:</a>
<a name="ln4651">    return &amp;(win-&gt;w_p_scb);</a>
<a name="ln4652">  case PV_CRBIND:</a>
<a name="ln4653">    return &amp;(win-&gt;w_p_crb);</a>
<a name="ln4654">  case PV_COCU:</a>
<a name="ln4655">    return &amp;(win-&gt;w_p_cocu);</a>
<a name="ln4656">  case PV_COLE:</a>
<a name="ln4657">    return &amp;(win-&gt;w_p_cole);</a>
<a name="ln4658"> </a>
<a name="ln4659">  case PV_AI:</a>
<a name="ln4660">    return &amp;(buf-&gt;b_p_ai);</a>
<a name="ln4661">  case PV_BIN:</a>
<a name="ln4662">    return &amp;(buf-&gt;b_p_bin);</a>
<a name="ln4663">  case PV_BOMB:</a>
<a name="ln4664">    return &amp;(buf-&gt;b_p_bomb);</a>
<a name="ln4665">  case PV_BH:</a>
<a name="ln4666">    return &amp;(buf-&gt;b_p_bh);</a>
<a name="ln4667">  case PV_BT:</a>
<a name="ln4668">    return &amp;(buf-&gt;b_p_bt);</a>
<a name="ln4669">  case PV_BL:</a>
<a name="ln4670">    return &amp;(buf-&gt;b_p_bl);</a>
<a name="ln4671">  case PV_CHANNEL:</a>
<a name="ln4672">    return &amp;(buf-&gt;b_p_channel);</a>
<a name="ln4673">  case PV_CI:</a>
<a name="ln4674">    return &amp;(buf-&gt;b_p_ci);</a>
<a name="ln4675">  case PV_CIN:</a>
<a name="ln4676">    return &amp;(buf-&gt;b_p_cin);</a>
<a name="ln4677">  case PV_CINK:</a>
<a name="ln4678">    return &amp;(buf-&gt;b_p_cink);</a>
<a name="ln4679">  case PV_CINO:</a>
<a name="ln4680">    return &amp;(buf-&gt;b_p_cino);</a>
<a name="ln4681">  case PV_CINSD:</a>
<a name="ln4682">    return &amp;(buf-&gt;b_p_cinsd);</a>
<a name="ln4683">  case PV_CINW:</a>
<a name="ln4684">    return &amp;(buf-&gt;b_p_cinw);</a>
<a name="ln4685">  case PV_COM:</a>
<a name="ln4686">    return &amp;(buf-&gt;b_p_com);</a>
<a name="ln4687">  case PV_CMS:</a>
<a name="ln4688">    return &amp;(buf-&gt;b_p_cms);</a>
<a name="ln4689">  case PV_CPT:</a>
<a name="ln4690">    return &amp;(buf-&gt;b_p_cpt);</a>
<a name="ln4691">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4692">  case PV_CSL:</a>
<a name="ln4693">    return &amp;(buf-&gt;b_p_csl);</a>
<a name="ln4694">#endif</a>
<a name="ln4695">  case PV_CFU:</a>
<a name="ln4696">    return &amp;(buf-&gt;b_p_cfu);</a>
<a name="ln4697">  case PV_OFU:</a>
<a name="ln4698">    return &amp;(buf-&gt;b_p_ofu);</a>
<a name="ln4699">  case PV_EOF:</a>
<a name="ln4700">    return &amp;(buf-&gt;b_p_eof);</a>
<a name="ln4701">  case PV_EOL:</a>
<a name="ln4702">    return &amp;(buf-&gt;b_p_eol);</a>
<a name="ln4703">  case PV_FIXEOL:</a>
<a name="ln4704">    return &amp;(buf-&gt;b_p_fixeol);</a>
<a name="ln4705">  case PV_ET:</a>
<a name="ln4706">    return &amp;(buf-&gt;b_p_et);</a>
<a name="ln4707">  case PV_FENC:</a>
<a name="ln4708">    return &amp;(buf-&gt;b_p_fenc);</a>
<a name="ln4709">  case PV_FF:</a>
<a name="ln4710">    return &amp;(buf-&gt;b_p_ff);</a>
<a name="ln4711">  case PV_FT:</a>
<a name="ln4712">    return &amp;(buf-&gt;b_p_ft);</a>
<a name="ln4713">  case PV_FO:</a>
<a name="ln4714">    return &amp;(buf-&gt;b_p_fo);</a>
<a name="ln4715">  case PV_FLP:</a>
<a name="ln4716">    return &amp;(buf-&gt;b_p_flp);</a>
<a name="ln4717">  case PV_IMI:</a>
<a name="ln4718">    return &amp;(buf-&gt;b_p_iminsert);</a>
<a name="ln4719">  case PV_IMS:</a>
<a name="ln4720">    return &amp;(buf-&gt;b_p_imsearch);</a>
<a name="ln4721">  case PV_INF:</a>
<a name="ln4722">    return &amp;(buf-&gt;b_p_inf);</a>
<a name="ln4723">  case PV_ISK:</a>
<a name="ln4724">    return &amp;(buf-&gt;b_p_isk);</a>
<a name="ln4725">  case PV_INEX:</a>
<a name="ln4726">    return &amp;(buf-&gt;b_p_inex);</a>
<a name="ln4727">  case PV_INDE:</a>
<a name="ln4728">    return &amp;(buf-&gt;b_p_inde);</a>
<a name="ln4729">  case PV_INDK:</a>
<a name="ln4730">    return &amp;(buf-&gt;b_p_indk);</a>
<a name="ln4731">  case PV_FEX:</a>
<a name="ln4732">    return &amp;(buf-&gt;b_p_fex);</a>
<a name="ln4733">  case PV_LISP:</a>
<a name="ln4734">    return &amp;(buf-&gt;b_p_lisp);</a>
<a name="ln4735">  case PV_LOP:</a>
<a name="ln4736">    return &amp;(buf-&gt;b_p_lop);</a>
<a name="ln4737">  case PV_ML:</a>
<a name="ln4738">    return &amp;(buf-&gt;b_p_ml);</a>
<a name="ln4739">  case PV_MPS:</a>
<a name="ln4740">    return &amp;(buf-&gt;b_p_mps);</a>
<a name="ln4741">  case PV_MA:</a>
<a name="ln4742">    return &amp;(buf-&gt;b_p_ma);</a>
<a name="ln4743">  case PV_MOD:</a>
<a name="ln4744">    return &amp;(buf-&gt;b_changed);</a>
<a name="ln4745">  case PV_NF:</a>
<a name="ln4746">    return &amp;(buf-&gt;b_p_nf);</a>
<a name="ln4747">  case PV_PI:</a>
<a name="ln4748">    return &amp;(buf-&gt;b_p_pi);</a>
<a name="ln4749">  case PV_QE:</a>
<a name="ln4750">    return &amp;(buf-&gt;b_p_qe);</a>
<a name="ln4751">  case PV_RO:</a>
<a name="ln4752">    return &amp;(buf-&gt;b_p_ro);</a>
<a name="ln4753">  case PV_SCBK:</a>
<a name="ln4754">    return &amp;(buf-&gt;b_p_scbk);</a>
<a name="ln4755">  case PV_SI:</a>
<a name="ln4756">    return &amp;(buf-&gt;b_p_si);</a>
<a name="ln4757">  case PV_STS:</a>
<a name="ln4758">    return &amp;(buf-&gt;b_p_sts);</a>
<a name="ln4759">  case PV_SUA:</a>
<a name="ln4760">    return &amp;(buf-&gt;b_p_sua);</a>
<a name="ln4761">  case PV_SWF:</a>
<a name="ln4762">    return &amp;(buf-&gt;b_p_swf);</a>
<a name="ln4763">  case PV_SMC:</a>
<a name="ln4764">    return &amp;(buf-&gt;b_p_smc);</a>
<a name="ln4765">  case PV_SYN:</a>
<a name="ln4766">    return &amp;(buf-&gt;b_p_syn);</a>
<a name="ln4767">  case PV_SPC:</a>
<a name="ln4768">    return &amp;(win-&gt;w_s-&gt;b_p_spc);</a>
<a name="ln4769">  case PV_SPF:</a>
<a name="ln4770">    return &amp;(win-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln4771">  case PV_SPL:</a>
<a name="ln4772">    return &amp;(win-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln4773">  case PV_SPO:</a>
<a name="ln4774">    return &amp;(win-&gt;w_s-&gt;b_p_spo);</a>
<a name="ln4775">  case PV_SW:</a>
<a name="ln4776">    return &amp;(buf-&gt;b_p_sw);</a>
<a name="ln4777">  case PV_TFU:</a>
<a name="ln4778">    return &amp;(buf-&gt;b_p_tfu);</a>
<a name="ln4779">  case PV_TS:</a>
<a name="ln4780">    return &amp;(buf-&gt;b_p_ts);</a>
<a name="ln4781">  case PV_TW:</a>
<a name="ln4782">    return &amp;(buf-&gt;b_p_tw);</a>
<a name="ln4783">  case PV_UDF:</a>
<a name="ln4784">    return &amp;(buf-&gt;b_p_udf);</a>
<a name="ln4785">  case PV_WM:</a>
<a name="ln4786">    return &amp;(buf-&gt;b_p_wm);</a>
<a name="ln4787">  case PV_VSTS:</a>
<a name="ln4788">    return &amp;(buf-&gt;b_p_vsts);</a>
<a name="ln4789">  case PV_VTS:</a>
<a name="ln4790">    return &amp;(buf-&gt;b_p_vts);</a>
<a name="ln4791">  case PV_KMAP:</a>
<a name="ln4792">    return &amp;(buf-&gt;b_p_keymap);</a>
<a name="ln4793">  case PV_SCL:</a>
<a name="ln4794">    return &amp;(win-&gt;w_p_scl);</a>
<a name="ln4795">  case PV_WINHL:</a>
<a name="ln4796">    return &amp;(win-&gt;w_p_winhl);</a>
<a name="ln4797">  case PV_WINBL:</a>
<a name="ln4798">    return &amp;(win-&gt;w_p_winbl);</a>
<a name="ln4799">  case PV_STC:</a>
<a name="ln4800">    return &amp;(win-&gt;w_p_stc);</a>
<a name="ln4801">  default:</a>
<a name="ln4802">    iemsg(_(&quot;E356: get_varp ERROR&quot;));</a>
<a name="ln4803">  }</a>
<a name="ln4804">  // always return a valid pointer to avoid a crash!</a>
<a name="ln4805">  return &amp;(buf-&gt;b_p_wm);</a>
<a name="ln4806">}</a>
<a name="ln4807"> </a>
<a name="ln4808">/// Get pointer to option variable.</a>
<a name="ln4809">static inline void *get_varp(vimoption_T *p)</a>
<a name="ln4810">{</a>
<a name="ln4811">  return get_varp_from(p, curbuf, curwin);</a>
<a name="ln4812">}</a>
<a name="ln4813"> </a>
<a name="ln4814">/// Return the did_set callback function for the option at 'opt_idx'</a>
<a name="ln4815">opt_did_set_cb_T get_option_did_set_cb(int opt_idx)</a>
<a name="ln4816">{</a>
<a name="ln4817">  return options[opt_idx].opt_did_set_cb;</a>
<a name="ln4818">}</a>
<a name="ln4819"> </a>
<a name="ln4820">/// Get the value of 'equalprg', either the buffer-local one or the global one.</a>
<a name="ln4821">char *get_equalprg(void)</a>
<a name="ln4822">{</a>
<a name="ln4823">  if (*curbuf-&gt;b_p_ep == NUL) {</a>
<a name="ln4824">    return p_ep;</a>
<a name="ln4825">  }</a>
<a name="ln4826">  return curbuf-&gt;b_p_ep;</a>
<a name="ln4827">}</a>
<a name="ln4828"> </a>
<a name="ln4829">/// Copy options from one window to another.</a>
<a name="ln4830">/// Used when splitting a window.</a>
<a name="ln4831">void win_copy_options(win_T *wp_from, win_T *wp_to)</a>
<a name="ln4832">{</a>
<a name="ln4833">  copy_winopt(&amp;wp_from-&gt;w_onebuf_opt, &amp;wp_to-&gt;w_onebuf_opt);</a>
<a name="ln4834">  copy_winopt(&amp;wp_from-&gt;w_allbuf_opt, &amp;wp_to-&gt;w_allbuf_opt);</a>
<a name="ln4835">  didset_window_options(wp_to, true);</a>
<a name="ln4836">}</a>
<a name="ln4837"> </a>
<a name="ln4838">static char *copy_option_val(const char *val)</a>
<a name="ln4839">{</a>
<a name="ln4840">  if (val == empty_option) {</a>
<a name="ln4841">    return empty_option;  // no need to allocate memory</a>
<a name="ln4842">  }</a>
<a name="ln4843">  return xstrdup(val);</a>
<a name="ln4844">}</a>
<a name="ln4845"> </a>
<a name="ln4846">/// Copy the options from one winopt_T to another.</a>
<a name="ln4847">/// Doesn't free the old option values in &quot;to&quot;, use clear_winopt() for that.</a>
<a name="ln4848">/// The 'scroll' option is not copied, because it depends on the window height.</a>
<a name="ln4849">/// The 'previewwindow' option is reset, there can be only one preview window.</a>
<a name="ln4850">void copy_winopt(winopt_T *from, winopt_T *to)</a>
<a name="ln4851">{</a>
<a name="ln4852">  to-&gt;wo_arab = from-&gt;wo_arab;</a>
<a name="ln4853">  to-&gt;wo_list = from-&gt;wo_list;</a>
<a name="ln4854">  to-&gt;wo_lcs = copy_option_val(from-&gt;wo_lcs);</a>
<a name="ln4855">  to-&gt;wo_fcs = copy_option_val(from-&gt;wo_fcs);</a>
<a name="ln4856">  to-&gt;wo_nu = from-&gt;wo_nu;</a>
<a name="ln4857">  to-&gt;wo_rnu = from-&gt;wo_rnu;</a>
<a name="ln4858">  to-&gt;wo_ve = copy_option_val(from-&gt;wo_ve);</a>
<a name="ln4859">  to-&gt;wo_ve_flags = from-&gt;wo_ve_flags;</a>
<a name="ln4860">  to-&gt;wo_nuw = from-&gt;wo_nuw;</a>
<a name="ln4861">  to-&gt;wo_rl  = from-&gt;wo_rl;</a>
<a name="ln4862">  to-&gt;wo_rlc = copy_option_val(from-&gt;wo_rlc);</a>
<a name="ln4863">  to-&gt;wo_sbr = copy_option_val(from-&gt;wo_sbr);</a>
<a name="ln4864">  to-&gt;wo_stl = copy_option_val(from-&gt;wo_stl);</a>
<a name="ln4865">  to-&gt;wo_wbr = copy_option_val(from-&gt;wo_wbr);</a>
<a name="ln4866">  to-&gt;wo_wrap = from-&gt;wo_wrap;</a>
<a name="ln4867">  to-&gt;wo_wrap_save = from-&gt;wo_wrap_save;</a>
<a name="ln4868">  to-&gt;wo_lbr = from-&gt;wo_lbr;</a>
<a name="ln4869">  to-&gt;wo_bri = from-&gt;wo_bri;</a>
<a name="ln4870">  to-&gt;wo_briopt = copy_option_val(from-&gt;wo_briopt);</a>
<a name="ln4871">  to-&gt;wo_scb = from-&gt;wo_scb;</a>
<a name="ln4872">  to-&gt;wo_scb_save = from-&gt;wo_scb_save;</a>
<a name="ln4873">  to-&gt;wo_sms = from-&gt;wo_sms;</a>
<a name="ln4874">  to-&gt;wo_crb = from-&gt;wo_crb;</a>
<a name="ln4875">  to-&gt;wo_crb_save = from-&gt;wo_crb_save;</a>
<a name="ln4876">  to-&gt;wo_siso = from-&gt;wo_siso;</a>
<a name="ln4877">  to-&gt;wo_so = from-&gt;wo_so;</a>
<a name="ln4878">  to-&gt;wo_spell = from-&gt;wo_spell;</a>
<a name="ln4879">  to-&gt;wo_cuc = from-&gt;wo_cuc;</a>
<a name="ln4880">  to-&gt;wo_cul = from-&gt;wo_cul;</a>
<a name="ln4881">  to-&gt;wo_culopt = copy_option_val(from-&gt;wo_culopt);</a>
<a name="ln4882">  to-&gt;wo_cc = copy_option_val(from-&gt;wo_cc);</a>
<a name="ln4883">  to-&gt;wo_diff = from-&gt;wo_diff;</a>
<a name="ln4884">  to-&gt;wo_diff_saved = from-&gt;wo_diff_saved;</a>
<a name="ln4885">  to-&gt;wo_cocu = copy_option_val(from-&gt;wo_cocu);</a>
<a name="ln4886">  to-&gt;wo_cole = from-&gt;wo_cole;</a>
<a name="ln4887">  to-&gt;wo_fdc = copy_option_val(from-&gt;wo_fdc);</a>
<a name="ln4888">  to-&gt;wo_fdc_save = from-&gt;wo_diff_saved ? xstrdup(from-&gt;wo_fdc_save) : empty_option;</a>
<a name="ln4889">  to-&gt;wo_fen = from-&gt;wo_fen;</a>
<a name="ln4890">  to-&gt;wo_fen_save = from-&gt;wo_fen_save;</a>
<a name="ln4891">  to-&gt;wo_fdi = copy_option_val(from-&gt;wo_fdi);</a>
<a name="ln4892">  to-&gt;wo_fml = from-&gt;wo_fml;</a>
<a name="ln4893">  to-&gt;wo_fdl = from-&gt;wo_fdl;</a>
<a name="ln4894">  to-&gt;wo_fdl_save = from-&gt;wo_fdl_save;</a>
<a name="ln4895">  to-&gt;wo_fdm = copy_option_val(from-&gt;wo_fdm);</a>
<a name="ln4896">  to-&gt;wo_fdm_save = from-&gt;wo_diff_saved ? xstrdup(from-&gt;wo_fdm_save) : empty_option;</a>
<a name="ln4897">  to-&gt;wo_fdn = from-&gt;wo_fdn;</a>
<a name="ln4898">  to-&gt;wo_fde = copy_option_val(from-&gt;wo_fde);</a>
<a name="ln4899">  to-&gt;wo_fdt = copy_option_val(from-&gt;wo_fdt);</a>
<a name="ln4900">  to-&gt;wo_fmr = copy_option_val(from-&gt;wo_fmr);</a>
<a name="ln4901">  to-&gt;wo_scl = copy_option_val(from-&gt;wo_scl);</a>
<a name="ln4902">  to-&gt;wo_winhl = copy_option_val(from-&gt;wo_winhl);</a>
<a name="ln4903">  to-&gt;wo_winbl = from-&gt;wo_winbl;</a>
<a name="ln4904">  to-&gt;wo_stc = copy_option_val(from-&gt;wo_stc);</a>
<a name="ln4905"> </a>
<a name="ln4906">  // Copy the script context so that we know were the value was last set.</a>
<a name="ln4907">  memmove(to-&gt;wo_script_ctx, from-&gt;wo_script_ctx, sizeof(to-&gt;wo_script_ctx));</a>
<a name="ln4908">  check_winopt(to);             // don't want NULL pointers</a>
<a name="ln4909">}</a>
<a name="ln4910"> </a>
<a name="ln4911">/// Check string options in a window for a NULL value.</a>
<a name="ln4912">void check_win_options(win_T *win)</a>
<a name="ln4913">{</a>
<a name="ln4914">  check_winopt(&amp;win-&gt;w_onebuf_opt);</a>
<a name="ln4915">  check_winopt(&amp;win-&gt;w_allbuf_opt);</a>
<a name="ln4916">}</a>
<a name="ln4917"> </a>
<a name="ln4918">/// Check for NULL pointers in a winopt_T and replace them with empty_option.</a>
<a name="ln4919">static void check_winopt(winopt_T *wop)</a>
<a name="ln4920">{</a>
<a name="ln4921">  check_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln4922">  check_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln4923">  check_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln4924">  check_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln4925">  check_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln4926">  check_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln4927">  check_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln4928">  check_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln4929">  check_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln4930">  check_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln4931">  check_string_option(&amp;wop-&gt;wo_sbr);</a>
<a name="ln4932">  check_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln4933">  check_string_option(&amp;wop-&gt;wo_culopt);</a>
<a name="ln4934">  check_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln4935">  check_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln4936">  check_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln4937">  check_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln4938">  check_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln4939">  check_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln4940">  check_string_option(&amp;wop-&gt;wo_ve);</a>
<a name="ln4941">  check_string_option(&amp;wop-&gt;wo_wbr);</a>
<a name="ln4942">  check_string_option(&amp;wop-&gt;wo_stc);</a>
<a name="ln4943">}</a>
<a name="ln4944"> </a>
<a name="ln4945">/// Free the allocated memory inside a winopt_T.</a>
<a name="ln4946">void clear_winopt(winopt_T *wop)</a>
<a name="ln4947">{</a>
<a name="ln4948">  clear_string_option(&amp;wop-&gt;wo_fdc);</a>
<a name="ln4949">  clear_string_option(&amp;wop-&gt;wo_fdc_save);</a>
<a name="ln4950">  clear_string_option(&amp;wop-&gt;wo_fdi);</a>
<a name="ln4951">  clear_string_option(&amp;wop-&gt;wo_fdm);</a>
<a name="ln4952">  clear_string_option(&amp;wop-&gt;wo_fdm_save);</a>
<a name="ln4953">  clear_string_option(&amp;wop-&gt;wo_fde);</a>
<a name="ln4954">  clear_string_option(&amp;wop-&gt;wo_fdt);</a>
<a name="ln4955">  clear_string_option(&amp;wop-&gt;wo_fmr);</a>
<a name="ln4956">  clear_string_option(&amp;wop-&gt;wo_scl);</a>
<a name="ln4957">  clear_string_option(&amp;wop-&gt;wo_rlc);</a>
<a name="ln4958">  clear_string_option(&amp;wop-&gt;wo_sbr);</a>
<a name="ln4959">  clear_string_option(&amp;wop-&gt;wo_stl);</a>
<a name="ln4960">  clear_string_option(&amp;wop-&gt;wo_culopt);</a>
<a name="ln4961">  clear_string_option(&amp;wop-&gt;wo_cc);</a>
<a name="ln4962">  clear_string_option(&amp;wop-&gt;wo_cocu);</a>
<a name="ln4963">  clear_string_option(&amp;wop-&gt;wo_briopt);</a>
<a name="ln4964">  clear_string_option(&amp;wop-&gt;wo_winhl);</a>
<a name="ln4965">  clear_string_option(&amp;wop-&gt;wo_lcs);</a>
<a name="ln4966">  clear_string_option(&amp;wop-&gt;wo_fcs);</a>
<a name="ln4967">  clear_string_option(&amp;wop-&gt;wo_ve);</a>
<a name="ln4968">  clear_string_option(&amp;wop-&gt;wo_wbr);</a>
<a name="ln4969">  clear_string_option(&amp;wop-&gt;wo_stc);</a>
<a name="ln4970">}</a>
<a name="ln4971"> </a>
<a name="ln4972">void didset_window_options(win_T *wp, bool valid_cursor)</a>
<a name="ln4973">{</a>
<a name="ln4974">  check_colorcolumn(wp);</a>
<a name="ln4975">  briopt_check(wp);</a>
<a name="ln4976">  fill_culopt_flags(NULL, wp);</a>
<a name="ln4977">  set_fillchars_option(wp, wp-&gt;w_p_fcs, true);</a>
<a name="ln4978">  set_listchars_option(wp, wp-&gt;w_p_lcs, true);</a>
<a name="ln4979">  parse_winhl_opt(wp);  // sets w_hl_needs_update also for w_p_winbl</a>
<a name="ln4980">  check_blending(wp);</a>
<a name="ln4981">  set_winbar_win(wp, false, valid_cursor);</a>
<a name="ln4982">  wp-&gt;w_grid_alloc.blending = wp-&gt;w_p_winbl &gt; 0;</a>
<a name="ln4983">}</a>
<a name="ln4984"> </a>
<a name="ln4985">/// Index into the options table for a buffer-local option enum.</a>
<a name="ln4986">static int buf_opt_idx[BV_COUNT];</a>
<a name="ln4987">#define COPY_OPT_SCTX(buf, bv) buf-&gt;b_p_script_ctx[bv] = options[buf_opt_idx[bv]].last_set</a>
<a name="ln4988"> </a>
<a name="ln4989">/// Initialize buf_opt_idx[] if not done already.</a>
<a name="ln4990">static void init_buf_opt_idx(void)</a>
<a name="ln4991">{</a>
<a name="ln4992">  static int did_init_buf_opt_idx = false;</a>
<a name="ln4993"> </a>
<a name="ln4994">  if (did_init_buf_opt_idx) {</a>
<a name="ln4995">    return;</a>
<a name="ln4996">  }</a>
<a name="ln4997">  did_init_buf_opt_idx = true;</a>
<a name="ln4998">  for (int i = 0; options[i].fullname != NULL; i++) {</a>
<a name="ln4999">    if (options[i].indir &amp; PV_BUF) {</a>
<a name="ln5000">      buf_opt_idx[options[i].indir &amp; PV_MASK] = i;</a>
<a name="ln5001">    }</a>
<a name="ln5002">  }</a>
<a name="ln5003">}</a>
<a name="ln5004"> </a>
<a name="ln5005">/// Copy global option values to local options for one buffer.</a>
<a name="ln5006">/// Used when creating a new buffer and sometimes when entering a buffer.</a>
<a name="ln5007">/// flags:</a>
<a name="ln5008">/// BCO_ENTER    We will enter the buffer &quot;buf&quot;.</a>
<a name="ln5009">/// BCO_ALWAYS   Always copy the options, but only set b_p_initialized when</a>
<a name="ln5010">///      appropriate.</a>
<a name="ln5011">/// BCO_NOHELP   Don't copy the values to a help buffer.</a>
<a name="ln5012">void buf_copy_options(buf_T *buf, int flags)</a>
<a name="ln5013">{</a>
<a name="ln5014">  int should_copy = true;</a>
<a name="ln5015">  char *save_p_isk = NULL;           // init for GCC</a>
<a name="ln5016">  int did_isk = false;</a>
<a name="ln5017"> </a>
<a name="ln5018">  // Skip this when the option defaults have not been set yet.  Happens when</a>
<a name="ln5019">  // main() allocates the first buffer.</a>
<a name="ln5020">  if (p_cpo != NULL) {</a>
<a name="ln5021">    //</a>
<a name="ln5022">    // Always copy when entering and 'cpo' contains 'S'.</a>
<a name="ln5023">    // Don't copy when already initialized.</a>
<a name="ln5024">    // Don't copy when 'cpo' contains 's' and not entering.</a>
<a name="ln5025">    //    'S'      BCO_ENTER  initialized  's'  should_copy</a>
<a name="ln5026">    //    yes        yes          X         X      true</a>
<a name="ln5027">    //    yes        no          yes        X      false</a>
<a name="ln5028">    //    no          X          yes        X      false</a>
<a name="ln5029">    //     X         no          no        yes     false</a>
<a name="ln5030">    //     X         no          no        no      true</a>
<a name="ln5031">    //    no         yes         no         X      true</a>
<a name="ln5032">    ///</a>
<a name="ln5033">    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags &amp; BCO_ENTER))</a>
<a name="ln5034">        &amp;&amp; (buf-&gt;b_p_initialized</a>
<a name="ln5035">            || (!(flags &amp; BCO_ENTER)</a>
<a name="ln5036">                &amp;&amp; vim_strchr(p_cpo, CPO_BUFOPT) != NULL))) {</a>
<a name="ln5037">      should_copy = false;</a>
<a name="ln5038">    }</a>
<a name="ln5039"> </a>
<a name="ln5040">    if (should_copy || (flags &amp; BCO_ALWAYS)) {</a>
<a name="ln5041">      CLEAR_FIELD(buf-&gt;b_p_script_ctx);</a>
<a name="ln5042">      init_buf_opt_idx();</a>
<a name="ln5043">      // Don't copy the options specific to a help buffer when</a>
<a name="ln5044">      // BCO_NOHELP is given or the options were initialized already</a>
<a name="ln5045">      // (jumping back to a help file with CTRL-T or CTRL-O)</a>
<a name="ln5046">      bool dont_do_help = ((flags &amp; BCO_NOHELP) &amp;&amp; buf-&gt;b_help) || buf-&gt;b_p_initialized;</a>
<a name="ln5047">      if (dont_do_help) {               // don't free b_p_isk</a>
<a name="ln5048">        save_p_isk = buf-&gt;b_p_isk;</a>
<a name="ln5049">        buf-&gt;b_p_isk = NULL;</a>
<a name="ln5050">      }</a>
<a name="ln5051">      // Always free the allocated strings.  If not already initialized,</a>
<a name="ln5052">      // reset 'readonly' and copy 'fileformat'.</a>
<a name="ln5053">      if (!buf-&gt;b_p_initialized) {</a>
<a name="ln5054">        free_buf_options(buf, true);</a>
<a name="ln5055">        buf-&gt;b_p_ro = false;                    // don't copy readonly</a>
<a name="ln5056">        buf-&gt;b_p_fenc = xstrdup(p_fenc);</a>
<a name="ln5057">        switch (*p_ffs) {</a>
<a name="ln5058">        case 'm':</a>
<a name="ln5059">          buf-&gt;b_p_ff = xstrdup(FF_MAC);</a>
<a name="ln5060">          break;</a>
<a name="ln5061">        case 'd':</a>
<a name="ln5062">          buf-&gt;b_p_ff = xstrdup(FF_DOS);</a>
<a name="ln5063">          break;</a>
<a name="ln5064">        case 'u':</a>
<a name="ln5065">          buf-&gt;b_p_ff = xstrdup(FF_UNIX);</a>
<a name="ln5066">          break;</a>
<a name="ln5067">        default:</a>
<a name="ln5068">          buf-&gt;b_p_ff = xstrdup(p_ff);</a>
<a name="ln5069">          break;</a>
<a name="ln5070">        }</a>
<a name="ln5071">        buf-&gt;b_p_bh = empty_option;</a>
<a name="ln5072">        buf-&gt;b_p_bt = empty_option;</a>
<a name="ln5073">      } else {</a>
<a name="ln5074">        free_buf_options(buf, false);</a>
<a name="ln5075">      }</a>
<a name="ln5076"> </a>
<a name="ln5077">      buf-&gt;b_p_ai = p_ai;</a>
<a name="ln5078">      COPY_OPT_SCTX(buf, BV_AI);</a>
<a name="ln5079">      buf-&gt;b_p_ai_nopaste = p_ai_nopaste;</a>
<a name="ln5080">      buf-&gt;b_p_sw = p_sw;</a>
<a name="ln5081">      COPY_OPT_SCTX(buf, BV_SW);</a>
<a name="ln5082">      buf-&gt;b_p_scbk = p_scbk;</a>
<a name="ln5083">      COPY_OPT_SCTX(buf, BV_SCBK);</a>
<a name="ln5084">      buf-&gt;b_p_tw = p_tw;</a>
<a name="ln5085">      COPY_OPT_SCTX(buf, BV_TW);</a>
<a name="ln5086">      buf-&gt;b_p_tw_nopaste = p_tw_nopaste;</a>
<a name="ln5087">      buf-&gt;b_p_tw_nobin = p_tw_nobin;</a>
<a name="ln5088">      buf-&gt;b_p_wm = p_wm;</a>
<a name="ln5089">      COPY_OPT_SCTX(buf, BV_WM);</a>
<a name="ln5090">      buf-&gt;b_p_wm_nopaste = p_wm_nopaste;</a>
<a name="ln5091">      buf-&gt;b_p_wm_nobin = p_wm_nobin;</a>
<a name="ln5092">      buf-&gt;b_p_bin = p_bin;</a>
<a name="ln5093">      COPY_OPT_SCTX(buf, BV_BIN);</a>
<a name="ln5094">      buf-&gt;b_p_bomb = p_bomb;</a>
<a name="ln5095">      COPY_OPT_SCTX(buf, BV_BOMB);</a>
<a name="ln5096">      buf-&gt;b_p_et = p_et;</a>
<a name="ln5097">      COPY_OPT_SCTX(buf, BV_ET);</a>
<a name="ln5098">      buf-&gt;b_p_fixeol = p_fixeol;</a>
<a name="ln5099">      COPY_OPT_SCTX(buf, BV_FIXEOL);</a>
<a name="ln5100">      buf-&gt;b_p_et_nobin = p_et_nobin;</a>
<a name="ln5101">      buf-&gt;b_p_et_nopaste = p_et_nopaste;</a>
<a name="ln5102">      buf-&gt;b_p_ml = p_ml;</a>
<a name="ln5103">      COPY_OPT_SCTX(buf, BV_ML);</a>
<a name="ln5104">      buf-&gt;b_p_ml_nobin = p_ml_nobin;</a>
<a name="ln5105">      buf-&gt;b_p_inf = p_inf;</a>
<a name="ln5106">      COPY_OPT_SCTX(buf, BV_INF);</a>
<a name="ln5107">      if (cmdmod.cmod_flags &amp; CMOD_NOSWAPFILE) {</a>
<a name="ln5108">        buf-&gt;b_p_swf = false;</a>
<a name="ln5109">      } else {</a>
<a name="ln5110">        buf-&gt;b_p_swf = p_swf;</a>
<a name="ln5111">        COPY_OPT_SCTX(buf, BV_SWF);</a>
<a name="ln5112">      }</a>
<a name="ln5113">      buf-&gt;b_p_cpt = xstrdup(p_cpt);</a>
<a name="ln5114">      COPY_OPT_SCTX(buf, BV_CPT);</a>
<a name="ln5115">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5116">      buf-&gt;b_p_csl = xstrdup(p_csl);</a>
<a name="ln5117">      COPY_OPT_SCTX(buf, BV_CSL);</a>
<a name="ln5118">#endif</a>
<a name="ln5119">      buf-&gt;b_p_cfu = xstrdup(p_cfu);</a>
<a name="ln5120">      COPY_OPT_SCTX(buf, BV_CFU);</a>
<a name="ln5121">      set_buflocal_cfu_callback(buf);</a>
<a name="ln5122">      buf-&gt;b_p_ofu = xstrdup(p_ofu);</a>
<a name="ln5123">      COPY_OPT_SCTX(buf, BV_OFU);</a>
<a name="ln5124">      set_buflocal_ofu_callback(buf);</a>
<a name="ln5125">      buf-&gt;b_p_tfu = xstrdup(p_tfu);</a>
<a name="ln5126">      COPY_OPT_SCTX(buf, BV_TFU);</a>
<a name="ln5127">      set_buflocal_tfu_callback(buf);</a>
<a name="ln5128">      buf-&gt;b_p_sts = p_sts;</a>
<a name="ln5129">      COPY_OPT_SCTX(buf, BV_STS);</a>
<a name="ln5130">      buf-&gt;b_p_sts_nopaste = p_sts_nopaste;</a>
<a name="ln5131">      buf-&gt;b_p_vsts = xstrdup(p_vsts);</a>
<a name="ln5132">      COPY_OPT_SCTX(buf, BV_VSTS);</a>
<a name="ln5133">      if (p_vsts &amp;&amp; p_vsts != empty_option) {</a>
<a name="ln5134">        (void)tabstop_set(p_vsts, &amp;buf-&gt;b_p_vsts_array);</a>
<a name="ln5135">      } else {</a>
<a name="ln5136">        buf-&gt;b_p_vsts_array = NULL;</a>
<a name="ln5137">      }</a>
<a name="ln5138">      buf-&gt;b_p_vsts_nopaste = p_vsts_nopaste ? xstrdup(p_vsts_nopaste) : NULL;</a>
<a name="ln5139">      buf-&gt;b_p_com = xstrdup(p_com);</a>
<a name="ln5140">      COPY_OPT_SCTX(buf, BV_COM);</a>
<a name="ln5141">      buf-&gt;b_p_cms = xstrdup(p_cms);</a>
<a name="ln5142">      COPY_OPT_SCTX(buf, BV_CMS);</a>
<a name="ln5143">      buf-&gt;b_p_fo = xstrdup(p_fo);</a>
<a name="ln5144">      COPY_OPT_SCTX(buf, BV_FO);</a>
<a name="ln5145">      buf-&gt;b_p_flp = xstrdup(p_flp);</a>
<a name="ln5146">      COPY_OPT_SCTX(buf, BV_FLP);</a>
<a name="ln5147">      buf-&gt;b_p_nf = xstrdup(p_nf);</a>
<a name="ln5148">      COPY_OPT_SCTX(buf, BV_NF);</a>
<a name="ln5149">      buf-&gt;b_p_mps = xstrdup(p_mps);</a>
<a name="ln5150">      COPY_OPT_SCTX(buf, BV_MPS);</a>
<a name="ln5151">      buf-&gt;b_p_si = p_si;</a>
<a name="ln5152">      COPY_OPT_SCTX(buf, BV_SI);</a>
<a name="ln5153">      buf-&gt;b_p_channel = 0;</a>
<a name="ln5154">      buf-&gt;b_p_ci = p_ci;</a>
<a name="ln5155"> </a>
<a name="ln5156">      COPY_OPT_SCTX(buf, BV_CI);</a>
<a name="ln5157">      buf-&gt;b_p_cin = p_cin;</a>
<a name="ln5158">      COPY_OPT_SCTX(buf, BV_CIN);</a>
<a name="ln5159">      buf-&gt;b_p_cink = xstrdup(p_cink);</a>
<a name="ln5160">      COPY_OPT_SCTX(buf, BV_CINK);</a>
<a name="ln5161">      buf-&gt;b_p_cino = xstrdup(p_cino);</a>
<a name="ln5162">      COPY_OPT_SCTX(buf, BV_CINO);</a>
<a name="ln5163">      buf-&gt;b_p_cinsd = xstrdup(p_cinsd);</a>
<a name="ln5164">      COPY_OPT_SCTX(buf, BV_CINSD);</a>
<a name="ln5165">      buf-&gt;b_p_lop = xstrdup(p_lop);</a>
<a name="ln5166">      COPY_OPT_SCTX(buf, BV_LOP);</a>
<a name="ln5167"> </a>
<a name="ln5168">      // Don't copy 'filetype', it must be detected</a>
<a name="ln5169">      buf-&gt;b_p_ft = empty_option;</a>
<a name="ln5170">      buf-&gt;b_p_pi = p_pi;</a>
<a name="ln5171">      COPY_OPT_SCTX(buf, BV_PI);</a>
<a name="ln5172">      buf-&gt;b_p_cinw = xstrdup(p_cinw);</a>
<a name="ln5173">      COPY_OPT_SCTX(buf, BV_CINW);</a>
<a name="ln5174">      buf-&gt;b_p_lisp = p_lisp;</a>
<a name="ln5175">      COPY_OPT_SCTX(buf, BV_LISP);</a>
<a name="ln5176">      // Don't copy 'syntax', it must be set</a>
<a name="ln5177">      buf-&gt;b_p_syn = empty_option;</a>
<a name="ln5178">      buf-&gt;b_p_smc = p_smc;</a>
<a name="ln5179">      COPY_OPT_SCTX(buf, BV_SMC);</a>
<a name="ln5180">      buf-&gt;b_s.b_syn_isk = empty_option;</a>
<a name="ln5181">      buf-&gt;b_s.b_p_spc = xstrdup(p_spc);</a>
<a name="ln5182">      COPY_OPT_SCTX(buf, BV_SPC);</a>
<a name="ln5183">      (void)compile_cap_prog(&amp;buf-&gt;b_s);</a>
<a name="ln5184">      buf-&gt;b_s.b_p_spf = xstrdup(p_spf);</a>
<a name="ln5185">      COPY_OPT_SCTX(buf, BV_SPF);</a>
<a name="ln5186">      buf-&gt;b_s.b_p_spl = xstrdup(p_spl);</a>
<a name="ln5187">      COPY_OPT_SCTX(buf, BV_SPL);</a>
<a name="ln5188">      buf-&gt;b_s.b_p_spo = xstrdup(p_spo);</a>
<a name="ln5189">      COPY_OPT_SCTX(buf, BV_SPO);</a>
<a name="ln5190">      buf-&gt;b_p_inde = xstrdup(p_inde);</a>
<a name="ln5191">      COPY_OPT_SCTX(buf, BV_INDE);</a>
<a name="ln5192">      buf-&gt;b_p_indk = xstrdup(p_indk);</a>
<a name="ln5193">      COPY_OPT_SCTX(buf, BV_INDK);</a>
<a name="ln5194">      buf-&gt;b_p_fp = empty_option;</a>
<a name="ln5195">      buf-&gt;b_p_fex = xstrdup(p_fex);</a>
<a name="ln5196">      COPY_OPT_SCTX(buf, BV_FEX);</a>
<a name="ln5197">      buf-&gt;b_p_sua = xstrdup(p_sua);</a>
<a name="ln5198">      COPY_OPT_SCTX(buf, BV_SUA);</a>
<a name="ln5199">      buf-&gt;b_p_keymap = xstrdup(p_keymap);</a>
<a name="ln5200">      COPY_OPT_SCTX(buf, BV_KMAP);</a>
<a name="ln5201">      buf-&gt;b_kmap_state |= KEYMAP_INIT;</a>
<a name="ln5202">      // This isn't really an option, but copying the langmap and IME</a>
<a name="ln5203">      // state from the current buffer is better than resetting it.</a>
<a name="ln5204">      buf-&gt;b_p_iminsert = p_iminsert;</a>
<a name="ln5205">      COPY_OPT_SCTX(buf, BV_IMI);</a>
<a name="ln5206">      buf-&gt;b_p_imsearch = p_imsearch;</a>
<a name="ln5207">      COPY_OPT_SCTX(buf, BV_IMS);</a>
<a name="ln5208"> </a>
<a name="ln5209">      // options that are normally global but also have a local value</a>
<a name="ln5210">      // are not copied, start using the global value</a>
<a name="ln5211">      buf-&gt;b_p_ar = -1;</a>
<a name="ln5212">      buf-&gt;b_p_ul = NO_LOCAL_UNDOLEVEL;</a>
<a name="ln5213">      buf-&gt;b_p_bkc = empty_option;</a>
<a name="ln5214">      buf-&gt;b_bkc_flags = 0;</a>
<a name="ln5215">      buf-&gt;b_p_gp = empty_option;</a>
<a name="ln5216">      buf-&gt;b_p_mp = empty_option;</a>
<a name="ln5217">      buf-&gt;b_p_efm = empty_option;</a>
<a name="ln5218">      buf-&gt;b_p_ep = empty_option;</a>
<a name="ln5219">      buf-&gt;b_p_kp = empty_option;</a>
<a name="ln5220">      buf-&gt;b_p_path = empty_option;</a>
<a name="ln5221">      buf-&gt;b_p_tags = empty_option;</a>
<a name="ln5222">      buf-&gt;b_p_tc = empty_option;</a>
<a name="ln5223">      buf-&gt;b_tc_flags = 0;</a>
<a name="ln5224">      buf-&gt;b_p_def = empty_option;</a>
<a name="ln5225">      buf-&gt;b_p_inc = empty_option;</a>
<a name="ln5226">      buf-&gt;b_p_inex = xstrdup(p_inex);</a>
<a name="ln5227">      COPY_OPT_SCTX(buf, BV_INEX);</a>
<a name="ln5228">      buf-&gt;b_p_dict = empty_option;</a>
<a name="ln5229">      buf-&gt;b_p_tsr = empty_option;</a>
<a name="ln5230">      buf-&gt;b_p_tsrfu = empty_option;</a>
<a name="ln5231">      buf-&gt;b_p_qe = xstrdup(p_qe);</a>
<a name="ln5232">      COPY_OPT_SCTX(buf, BV_QE);</a>
<a name="ln5233">      buf-&gt;b_p_udf = p_udf;</a>
<a name="ln5234">      COPY_OPT_SCTX(buf, BV_UDF);</a>
<a name="ln5235">      buf-&gt;b_p_lw = empty_option;</a>
<a name="ln5236">      buf-&gt;b_p_menc = empty_option;</a>
<a name="ln5237"> </a>
<a name="ln5238">      // Don't copy the options set by ex_help(), use the saved values,</a>
<a name="ln5239">      // when going from a help buffer to a non-help buffer.</a>
<a name="ln5240">      // Don't touch these at all when BCO_NOHELP is used and going from</a>
<a name="ln5241">      // or to a help buffer.</a>
<a name="ln5242">      if (dont_do_help) {</a>
<a name="ln5243">        buf-&gt;b_p_isk = save_p_isk;</a>
<a name="ln5244">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln5245">          (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln5246">        } else {</a>
<a name="ln5247">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln5248">        }</a>
<a name="ln5249">      } else {</a>
<a name="ln5250">        buf-&gt;b_p_isk = xstrdup(p_isk);</a>
<a name="ln5251">        COPY_OPT_SCTX(buf, BV_ISK);</a>
<a name="ln5252">        did_isk = true;</a>
<a name="ln5253">        buf-&gt;b_p_ts = p_ts;</a>
<a name="ln5254">        COPY_OPT_SCTX(buf, BV_TS);</a>
<a name="ln5255">        buf-&gt;b_p_vts = xstrdup(p_vts);</a>
<a name="ln5256">        COPY_OPT_SCTX(buf, BV_VTS);</a>
<a name="ln5257">        if (p_vts &amp;&amp; p_vts != empty_option &amp;&amp; !buf-&gt;b_p_vts_array) {</a>
<a name="ln5258">          (void)tabstop_set(p_vts, &amp;buf-&gt;b_p_vts_array);</a>
<a name="ln5259">        } else {</a>
<a name="ln5260">          buf-&gt;b_p_vts_array = NULL;</a>
<a name="ln5261">        }</a>
<a name="ln5262">        buf-&gt;b_help = false;</a>
<a name="ln5263">        if (buf-&gt;b_p_bt[0] == 'h') {</a>
<a name="ln5264">          clear_string_option(&amp;buf-&gt;b_p_bt);</a>
<a name="ln5265">        }</a>
<a name="ln5266">        buf-&gt;b_p_ma = p_ma;</a>
<a name="ln5267">        COPY_OPT_SCTX(buf, BV_MA);</a>
<a name="ln5268">      }</a>
<a name="ln5269">    }</a>
<a name="ln5270"> </a>
<a name="ln5271">    // When the options should be copied (ignoring BCO_ALWAYS), set the</a>
<a name="ln5272">    // flag that indicates that the options have been initialized.</a>
<a name="ln5273">    if (should_copy) {</a>
<a name="ln5274">      buf-&gt;b_p_initialized = true;</a>
<a name="ln5275">    }</a>
<a name="ln5276">  }</a>
<a name="ln5277"> </a>
<a name="ln5278">  check_buf_options(buf);           // make sure we don't have NULLs</a>
<a name="ln5279">  if (did_isk) {</a>
<a name="ln5280">    (void)buf_init_chartab(buf, false);</a>
<a name="ln5281">  }</a>
<a name="ln5282">}</a>
<a name="ln5283"> </a>
<a name="ln5284">/// Reset the 'modifiable' option and its default value.</a>
<a name="ln5285">void reset_modifiable(void)</a>
<a name="ln5286">{</a>
<a name="ln5287">  int opt_idx;</a>
<a name="ln5288"> </a>
<a name="ln5289">  curbuf-&gt;b_p_ma = false;</a>
<a name="ln5290">  p_ma = false;</a>
<a name="ln5291">  opt_idx = findoption(&quot;ma&quot;);</a>
<a name="ln5292">  if (opt_idx &gt;= 0) {</a>
<a name="ln5293">    options[opt_idx].def_val = false;</a>
<a name="ln5294">  }</a>
<a name="ln5295">}</a>
<a name="ln5296"> </a>
<a name="ln5297">/// Set the global value for 'iminsert' to the local value.</a>
<a name="ln5298">void set_iminsert_global(buf_T *buf)</a>
<a name="ln5299">{</a>
<a name="ln5300">  p_iminsert = buf-&gt;b_p_iminsert;</a>
<a name="ln5301">}</a>
<a name="ln5302"> </a>
<a name="ln5303">/// Set the global value for 'imsearch' to the local value.</a>
<a name="ln5304">void set_imsearch_global(buf_T *buf)</a>
<a name="ln5305">{</a>
<a name="ln5306">  p_imsearch = buf-&gt;b_p_imsearch;</a>
<a name="ln5307">}</a>
<a name="ln5308"> </a>
<a name="ln5309">static int expand_option_idx = -1;</a>
<a name="ln5310">static int expand_option_start_col = 0;</a>
<a name="ln5311">static char expand_option_name[5] = { 't', '_', NUL, NUL, NUL };</a>
<a name="ln5312">static int expand_option_flags = 0;</a>
<a name="ln5313">static bool expand_option_append = false;</a>
<a name="ln5314"> </a>
<a name="ln5315">/// @param opt_flags  OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln5316">void set_context_in_set_cmd(expand_T *xp, char *arg, int opt_flags)</a>
<a name="ln5317">{</a>
<a name="ln5318">  expand_option_flags = opt_flags;</a>
<a name="ln5319"> </a>
<a name="ln5320">  xp-&gt;xp_context = EXPAND_SETTINGS;</a>
<a name="ln5321">  if (*arg == NUL) {</a>
<a name="ln5322">    xp-&gt;xp_pattern = arg;</a>
<a name="ln5323">    return;</a>
<a name="ln5324">  }</a>
<a name="ln5325">  char *p = arg + strlen(arg) - 1;</a>
<a name="ln5326">  if (*p == ' ' &amp;&amp; *(p - 1) != '\\') {</a>
<a name="ln5327">    xp-&gt;xp_pattern = p + 1;</a>
<a name="ln5328">    return;</a>
<a name="ln5329">  }</a>
<a name="ln5330">  while (p &gt; arg) {</a>
<a name="ln5331">    char *s = p;</a>
<a name="ln5332">    // count number of backslashes before ' ' or ','</a>
<a name="ln5333">    if (*p == ' ' || *p == ',') {</a>
<a name="ln5334">      while (s &gt; arg &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln5335">        s--;</a>
<a name="ln5336">      }</a>
<a name="ln5337">    }</a>
<a name="ln5338">    // break at a space with an even number of backslashes</a>
<a name="ln5339">    if (*p == ' ' &amp;&amp; ((p - s) &amp; 1) == 0) {</a>
<a name="ln5340">      p++;</a>
<a name="ln5341">      break;</a>
<a name="ln5342">    }</a>
<a name="ln5343">    p--;</a>
<a name="ln5344">  }</a>
<a name="ln5345">  if (strncmp(p, &quot;no&quot;, 2) == 0) {</a>
<a name="ln5346">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln5347">    xp-&gt;xp_prefix = XP_PREFIX_NO;</a>
<a name="ln5348">    p += 2;</a>
<a name="ln5349">  } else if (strncmp(p, &quot;inv&quot;, 3) == 0) {</a>
<a name="ln5350">    xp-&gt;xp_context = EXPAND_BOOL_SETTINGS;</a>
<a name="ln5351">    xp-&gt;xp_prefix = XP_PREFIX_INV;</a>
<a name="ln5352">    p += 3;</a>
<a name="ln5353">  }</a>
<a name="ln5354">  xp-&gt;xp_pattern = p;</a>
<a name="ln5355">  arg = p;</a>
<a name="ln5356"> </a>
<a name="ln5357">  char nextchar;</a>
<a name="ln5358">  uint32_t flags = 0;</a>
<a name="ln5359">  int opt_idx = 0;</a>
<a name="ln5360">  int is_term_option = false;</a>
<a name="ln5361"> </a>
<a name="ln5362">  if (*arg == '&lt;') {</a>
<a name="ln5363">    while (*p != '&gt;') {</a>
<a name="ln5364">      if (*p++ == NUL) {            // expand terminal option name</a>
<a name="ln5365">        return;</a>
<a name="ln5366">      }</a>
<a name="ln5367">    }</a>
<a name="ln5368">    int key = get_special_key_code(arg + 1);</a>
<a name="ln5369">    if (key == 0) {                 // unknown name</a>
<a name="ln5370">      xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5371">      return;</a>
<a name="ln5372">    }</a>
<a name="ln5373">    nextchar = *++p;</a>
<a name="ln5374">    is_term_option = true;</a>
<a name="ln5375">    expand_option_name[2] = (char)(uint8_t)KEY2TERMCAP0(key);</a>
<a name="ln5376">    expand_option_name[3] = (char)(uint8_t)KEY2TERMCAP1(key);</a>
<a name="ln5377">  } else {</a>
<a name="ln5378">    if (p[0] == 't' &amp;&amp; p[1] == '_') {</a>
<a name="ln5379">      p += 2;</a>
<a name="ln5380">      if (*p != NUL) {</a>
<a name="ln5381">        p++;</a>
<a name="ln5382">      }</a>
<a name="ln5383">      if (*p == NUL) {</a>
<a name="ln5384">        return;                 // expand option name</a>
<a name="ln5385">      }</a>
<a name="ln5386">      nextchar = *++p;</a>
<a name="ln5387">      is_term_option = true;</a>
<a name="ln5388">      expand_option_name[2] = p[-2];</a>
<a name="ln5389">      expand_option_name[3] = p[-1];</a>
<a name="ln5390">    } else {</a>
<a name="ln5391">      // Allow * wildcard.</a>
<a name="ln5392">      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*') {</a>
<a name="ln5393">        p++;</a>
<a name="ln5394">      }</a>
<a name="ln5395">      if (*p == NUL) {</a>
<a name="ln5396">        return;</a>
<a name="ln5397">      }</a>
<a name="ln5398">      nextchar = *p;</a>
<a name="ln5399">      opt_idx = findoption_len(arg, (size_t)(p - arg));</a>
<a name="ln5400">      if (opt_idx == -1 || options[opt_idx].var == NULL) {</a>
<a name="ln5401">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5402">        return;</a>
<a name="ln5403">      }</a>
<a name="ln5404">      flags = options[opt_idx].flags;</a>
<a name="ln5405">      if (flags &amp; P_BOOL) {</a>
<a name="ln5406">        xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5407">        return;</a>
<a name="ln5408">      }</a>
<a name="ln5409">    }</a>
<a name="ln5410">  }</a>
<a name="ln5411">  // handle &quot;-=&quot; and &quot;+=&quot;</a>
<a name="ln5412">  expand_option_append = false;</a>
<a name="ln5413">  bool expand_option_subtract = false;</a>
<a name="ln5414">  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') &amp;&amp; p[1] == '=') {</a>
<a name="ln5415">    if (nextchar == '-') {</a>
<a name="ln5416">      expand_option_subtract = true;</a>
<a name="ln5417">    }</a>
<a name="ln5418">    if (nextchar == '+' || nextchar == '^') {</a>
<a name="ln5419">      expand_option_append = true;</a>
<a name="ln5420">    }</a>
<a name="ln5421">    p++;</a>
<a name="ln5422">    nextchar = '=';</a>
<a name="ln5423">  }</a>
<a name="ln5424">  if ((nextchar != '=' &amp;&amp; nextchar != ':')</a>
<a name="ln5425">      || xp-&gt;xp_context == EXPAND_BOOL_SETTINGS) {</a>
<a name="ln5426">    xp-&gt;xp_context = EXPAND_UNSUCCESSFUL;</a>
<a name="ln5427">    return;</a>
<a name="ln5428">  }</a>
<a name="ln5429"> </a>
<a name="ln5430">  // Below are for handling expanding a specific option's value after the '=' or ':'</a>
<a name="ln5431"> </a>
<a name="ln5432">  if (is_term_option) {</a>
<a name="ln5433">    expand_option_idx = -1;</a>
<a name="ln5434">  } else {</a>
<a name="ln5435">    expand_option_idx = opt_idx;</a>
<a name="ln5436">  }</a>
<a name="ln5437"> </a>
<a name="ln5438">  xp-&gt;xp_pattern = p + 1;</a>
<a name="ln5439">  expand_option_start_col = (int)(p + 1 - xp-&gt;xp_line);</a>
<a name="ln5440"> </a>
<a name="ln5441">  // Certain options currently have special case handling to reuse the</a>
<a name="ln5442">  // expansion logic with other commands.</a>
<a name="ln5443">  if (options[opt_idx].var == &amp;p_syn) {</a>
<a name="ln5444">    xp-&gt;xp_context = EXPAND_OWNSYNTAX;</a>
<a name="ln5445">    return;</a>
<a name="ln5446">  }</a>
<a name="ln5447">  if (options[opt_idx].var == &amp;p_ft) {</a>
<a name="ln5448">    xp-&gt;xp_context = EXPAND_FILETYPE;</a>
<a name="ln5449">    return;</a>
<a name="ln5450">  }</a>
<a name="ln5451"> </a>
<a name="ln5452">  // Now pick. If the option has a custom expander, use that. Otherwise, just</a>
<a name="ln5453">  // fill with the existing option value.</a>
<a name="ln5454">  if (expand_option_subtract) {</a>
<a name="ln5455">    xp-&gt;xp_context = EXPAND_SETTING_SUBTRACT;</a>
<a name="ln5456">    return;</a>
<a name="ln5457">  } else if (expand_option_idx &gt;= 0</a>
<a name="ln5458">             &amp;&amp; options[expand_option_idx].opt_expand_cb != NULL) {</a>
<a name="ln5459">    xp-&gt;xp_context = EXPAND_STRING_SETTING;</a>
<a name="ln5460">  } else if (*xp-&gt;xp_pattern == NUL) {</a>
<a name="ln5461">    xp-&gt;xp_context = EXPAND_OLD_SETTING;</a>
<a name="ln5462">    return;</a>
<a name="ln5463">  } else {</a>
<a name="ln5464">    xp-&gt;xp_context = EXPAND_NOTHING;</a>
<a name="ln5465">  }</a>
<a name="ln5466"> </a>
<a name="ln5467">  if (is_term_option || (flags &amp; P_NUM)) {</a>
<a name="ln5468">    return;</a>
<a name="ln5469">  }</a>
<a name="ln5470"> </a>
<a name="ln5471">  // Only string options below</a>
<a name="ln5472"> </a>
<a name="ln5473">  // Options that have P_EXPAND are considered to all use file/dir expansion.</a>
<a name="ln5474">  if (flags &amp; P_EXPAND) {</a>
<a name="ln5475">    p = options[opt_idx].var;</a>
<a name="ln5476">    if (p == (char *)&amp;p_bdir</a>
<a name="ln5477">        || p == (char *)&amp;p_dir</a>
<a name="ln5478">        || p == (char *)&amp;p_path</a>
<a name="ln5479">        || p == (char *)&amp;p_pp</a>
<a name="ln5480">        || p == (char *)&amp;p_rtp</a>
<a name="ln5481">        || p == (char *)&amp;p_cdpath</a>
<a name="ln5482">        || p == (char *)&amp;p_vdir) {</a>
<a name="ln5483">      xp-&gt;xp_context = EXPAND_DIRECTORIES;</a>
<a name="ln5484">      if (p == (char *)&amp;p_path || p == (char *)&amp;p_cdpath) {</a>
<a name="ln5485">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln5486">      } else {</a>
<a name="ln5487">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln5488">      }</a>
<a name="ln5489">    } else {</a>
<a name="ln5490">      xp-&gt;xp_context = EXPAND_FILES;</a>
<a name="ln5491">      // for 'tags' need three backslashes for a space</a>
<a name="ln5492">      if (p == (char *)&amp;p_tags) {</a>
<a name="ln5493">        xp-&gt;xp_backslash = XP_BS_THREE;</a>
<a name="ln5494">      } else {</a>
<a name="ln5495">        xp-&gt;xp_backslash = XP_BS_ONE;</a>
<a name="ln5496">      }</a>
<a name="ln5497">    }</a>
<a name="ln5498">  }</a>
<a name="ln5499"> </a>
<a name="ln5500">  // For an option that is a list of file names, or comma/colon-separated</a>
<a name="ln5501">  // values, split it by the delimiter and find the start of the current</a>
<a name="ln5502">  // pattern, while accounting for backslash-escaped space/commas/colons.</a>
<a name="ln5503">  // Triple-backslashed escaped file names (e.g. 'path') can also be</a>
<a name="ln5504">  // delimited by space.</a>
<a name="ln5505">  if ((flags &amp; P_EXPAND) || (flags &amp; P_COMMA) || (flags &amp; P_COLON)) {</a>
<a name="ln5506">    for (p = arg + strlen(arg) - 1; p &gt; xp-&gt;xp_pattern; p--) {</a>
<a name="ln5507">      // count number of backslashes before ' ' or ','</a>
<a name="ln5508">      if (*p == ' ' || *p == ',' || (*p == ':' &amp;&amp; (flags &amp; P_COLON))) {</a>
<a name="ln5509">        char *s = p;</a>
<a name="ln5510">        while (s &gt; xp-&gt;xp_pattern &amp;&amp; *(s - 1) == '\\') {</a>
<a name="ln5511">          s--;</a>
<a name="ln5512">        }</a>
<a name="ln5513">        if ((*p == ' ' &amp;&amp; (xp-&gt;xp_backslash == XP_BS_THREE &amp;&amp; (p - s) &lt; 3))</a>
<a name="ln5514">            || (*p == ',' &amp;&amp; (flags &amp; P_COMMA) &amp;&amp; ((p - s) % 1) == 0)</a>
<a name="ln5515">            || (*p == ':' &amp;&amp; (flags &amp; P_COLON))) {</a>
<a name="ln5516">          xp-&gt;xp_pattern = p + 1;</a>
<a name="ln5517">          break;</a>
<a name="ln5518">        }</a>
<a name="ln5519">      }</a>
<a name="ln5520">    }</a>
<a name="ln5521">  }</a>
<a name="ln5522"> </a>
<a name="ln5523">  // An option that is a list of single-character flags should always start</a>
<a name="ln5524">  // at the end as we don't complete words.</a>
<a name="ln5525">  if (flags &amp; P_FLAGLIST) {</a>
<a name="ln5526">    xp-&gt;xp_pattern = arg + strlen(arg);</a>
<a name="ln5527">  }</a>
<a name="ln5528"> </a>
<a name="ln5529">  // Some options can either be using file/dir expansions, or custom value</a>
<a name="ln5530">  // expansion depending on what the user typed. Unfortunately we have to</a>
<a name="ln5531">  // manually handle it here to make sure we have the correct xp_context set.</a>
<a name="ln5532">  // for 'spellsuggest' start at &quot;file:&quot;</a>
<a name="ln5533">  if (options[opt_idx].var == &amp;p_sps) {</a>
<a name="ln5534">    if (strncmp(xp-&gt;xp_pattern, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln5535">      xp-&gt;xp_pattern += 5;</a>
<a name="ln5536">      return;</a>
<a name="ln5537">    } else if (options[expand_option_idx].opt_expand_cb != NULL) {</a>
<a name="ln5538">      xp-&gt;xp_context = EXPAND_STRING_SETTING;</a>
<a name="ln5539">    }</a>
<a name="ln5540">  }</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543">/// Returns true if &quot;str&quot; either matches &quot;regmatch&quot; or fuzzy matches &quot;pat&quot;.</a>
<a name="ln5544">///</a>
<a name="ln5545">/// If &quot;test_only&quot; is true and &quot;fuzzy&quot; is false and if &quot;str&quot; matches the regular</a>
<a name="ln5546">/// expression &quot;regmatch&quot;, then returns true.  Otherwise returns false.</a>
<a name="ln5547">///</a>
<a name="ln5548">/// If &quot;test_only&quot; is false and &quot;fuzzy&quot; is false and if &quot;str&quot; matches the</a>
<a name="ln5549">/// regular expression &quot;regmatch&quot;, then stores the match in matches[idx] and</a>
<a name="ln5550">/// returns true.</a>
<a name="ln5551">///</a>
<a name="ln5552">/// If &quot;test_only&quot; is true and &quot;fuzzy&quot; is true and if &quot;str&quot; fuzzy matches</a>
<a name="ln5553">/// &quot;fuzzystr&quot;, then returns true. Otherwise returns false.</a>
<a name="ln5554">///</a>
<a name="ln5555">/// If &quot;test_only&quot; is false and &quot;fuzzy&quot; is true and if &quot;str&quot; fuzzy matches</a>
<a name="ln5556">/// &quot;fuzzystr&quot;, then stores the match details in fuzmatch[idx] and returns true.</a>
<a name="ln5557">static bool match_str(char *const str, regmatch_T *const regmatch, char **const matches,</a>
<a name="ln5558">                      const int idx, const bool test_only, const bool fuzzy,</a>
<a name="ln5559">                      const char *const fuzzystr, fuzmatch_str_T *const fuzmatch)</a>
<a name="ln5560">{</a>
<a name="ln5561">  if (!fuzzy) {</a>
<a name="ln5562">    if (vim_regexec(regmatch, str, (colnr_T)0)) {</a>
<a name="ln5563">      if (!test_only) {</a>
<a name="ln5564">        matches[idx] = xstrdup(str);</a>
<a name="ln5565">      }</a>
<a name="ln5566">      return true;</a>
<a name="ln5567">    }</a>
<a name="ln5568">  } else {</a>
<a name="ln5569">    const int score = fuzzy_match_str(str, fuzzystr);</a>
<a name="ln5570">    if (score != 0) {</a>
<a name="ln5571">      if (!test_only) {</a>
<a name="ln5572">        fuzmatch[idx].idx = idx;</a>
<a name="ln5573">        fuzmatch[idx].str = xstrdup(str);</a>
<a name="ln5574">        fuzmatch[idx].score = score;</a>
<a name="ln5575">      }</a>
<a name="ln5576">      return true;</a>
<a name="ln5577">    }</a>
<a name="ln5578">  }</a>
<a name="ln5579">  return false;</a>
<a name="ln5580">}</a>
<a name="ln5581"> </a>
<a name="ln5582">int ExpandSettings(expand_T *xp, regmatch_T *regmatch, char *fuzzystr, int *numMatches,</a>
<a name="ln5583">                   char ***matches, const bool can_fuzzy)</a>
<a name="ln5584">{</a>
<a name="ln5585">  int num_normal = 0;  // Nr of matching non-term-code settings</a>
<a name="ln5586">  int count = 0;</a>
<a name="ln5587">  static char *(names[]) = { &quot;all&quot; };</a>
<a name="ln5588">  int ic = regmatch-&gt;rm_ic;  // remember the ignore-case flag</a>
<a name="ln5589"> </a>
<a name="ln5590">  fuzmatch_str_T *fuzmatch = NULL;</a>
<a name="ln5591">  const bool fuzzy = can_fuzzy &amp;&amp; cmdline_fuzzy_complete(fuzzystr);</a>
<a name="ln5592"> </a>
<a name="ln5593">  // do this loop twice:</a>
<a name="ln5594">  // loop == 0: count the number of matching options</a>
<a name="ln5595">  // loop == 1: copy the matching options into allocated memory</a>
<a name="ln5596">  for (int loop = 0; loop &lt;= 1; loop++) {</a>
<a name="ln5597">    regmatch-&gt;rm_ic = ic;</a>
<a name="ln5598">    if (xp-&gt;xp_context != EXPAND_BOOL_SETTINGS) {</a>
<a name="ln5599">      for (int match = 0; match &lt; (int)ARRAY_SIZE(names);</a>
<a name="ln5600">           match++) {</a>
<a name="ln5601">        if (match_str(names[match], regmatch, *matches,</a>
<a name="ln5602">                      count, (loop == 0), fuzzy, fuzzystr, fuzmatch)) {</a>
<a name="ln5603">          if (loop == 0) {</a>
<a name="ln5604">            num_normal++;</a>
<a name="ln5605">          } else {</a>
<a name="ln5606">            count++;</a>
<a name="ln5607">          }</a>
<a name="ln5608">        }</a>
<a name="ln5609">      }</a>
<a name="ln5610">    }</a>
<a name="ln5611">    char *str;</a>
<a name="ln5612">    for (size_t opt_idx = 0; (str = options[opt_idx].fullname) != NULL;</a>
<a name="ln5613">         opt_idx++) {</a>
<a name="ln5614">      if (options[opt_idx].var == NULL) {</a>
<a name="ln5615">        continue;</a>
<a name="ln5616">      }</a>
<a name="ln5617">      if (xp-&gt;xp_context == EXPAND_BOOL_SETTINGS</a>
<a name="ln5618">          &amp;&amp; !(options[opt_idx].flags &amp; P_BOOL)) {</a>
<a name="ln5619">        continue;</a>
<a name="ln5620">      }</a>
<a name="ln5621"> </a>
<a name="ln5622">      if (match_str(str, regmatch, *matches, count, (loop == 0),</a>
<a name="ln5623">                    fuzzy, fuzzystr, fuzmatch)) {</a>
<a name="ln5624">        if (loop == 0) {</a>
<a name="ln5625">          num_normal++;</a>
<a name="ln5626">        } else {</a>
<a name="ln5627">          count++;</a>
<a name="ln5628">        }</a>
<a name="ln5629">      } else if (!fuzzy &amp;&amp; options[opt_idx].shortname != NULL</a>
<a name="ln5630">                 &amp;&amp; vim_regexec(regmatch, options[opt_idx].shortname, (colnr_T)0)) {</a>
<a name="ln5631">        // Compare against the abbreviated option name (for regular</a>
<a name="ln5632">        // expression match). Fuzzy matching (previous if) already</a>
<a name="ln5633">        // matches against both the expanded and abbreviated names.</a>
<a name="ln5634">        if (loop == 0) {</a>
<a name="ln5635">          num_normal++;</a>
<a name="ln5636">        } else {</a>
<a name="ln5637">          (*matches)[count++] = xstrdup(str);</a>
<a name="ln5638">        }</a>
<a name="ln5639">      }</a>
<a name="ln5640">    }</a>
<a name="ln5641"> </a>
<a name="ln5642">    if (loop == 0) {</a>
<a name="ln5643">      if (num_normal &gt; 0) {</a>
<a name="ln5644">        *numMatches = num_normal;</a>
<a name="ln5645">      } else {</a>
<a name="ln5646">        return OK;</a>
<a name="ln5647">      }</a>
<a name="ln5648">      if (!fuzzy) {</a>
<a name="ln5649">        *matches = xmalloc((size_t)(*numMatches) * sizeof(char *));</a>
<a name="ln5650">      } else {</a>
<a name="ln5651">        fuzmatch = xmalloc((size_t)(*numMatches) * sizeof(fuzmatch_str_T));</a>
<a name="ln5652">      }</a>
<a name="ln5653">    }</a>
<a name="ln5654">  }</a>
<a name="ln5655"> </a>
<a name="ln5656">  if (fuzzy) {</a>
<a name="ln5657">    fuzzymatches_to_strmatches(fuzmatch, matches, count, false);</a>
<a name="ln5658">  }</a>
<a name="ln5659"> </a>
<a name="ln5660">  return OK;</a>
<a name="ln5661">}</a>
<a name="ln5662"> </a>
<a name="ln5663">/// Escape an option value that can be used on the command-line with :set.</a>
<a name="ln5664">/// Caller needs to free the returned string, unless NULL is returned.</a>
<a name="ln5665">static char *escape_option_str_cmdline(char *var)</a>
<a name="ln5666">{</a>
<a name="ln5667">  // A backslash is required before some characters.  This is the reverse of</a>
<a name="ln5668">  // what happens in do_set().</a>
<a name="ln5669">  char *buf = vim_strsave_escaped(var, escape_chars);</a>
<a name="ln5670"> </a>
<a name="ln5671">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5672">  // For MS-Windows et al. we don't double backslashes at the start and</a>
<a name="ln5673">  // before a file name character.</a>
<a name="ln5674">  // The reverse is found at stropt_copy_value().</a>
<a name="ln5675">  for (var = buf; *var != NUL; MB_PTR_ADV(var)) {</a>
<a name="ln5676">    if (var[0] == '\\' &amp;&amp; var[1] == '\\'</a>
<a name="ln5677">        &amp;&amp; expand_option_idx &gt;= 0</a>
<a name="ln5678">        &amp;&amp; (options[expand_option_idx].flags &amp; P_EXPAND)</a>
<a name="ln5679">        &amp;&amp; vim_isfilec((uint8_t)var[2])</a>
<a name="ln5680">        &amp;&amp; (var[2] != '\\' || (var == buf &amp;&amp; var[4] != '\\'))) {</a>
<a name="ln5681">      STRMOVE(var, var + 1);</a>
<a name="ln5682">    }</a>
<a name="ln5683">  }</a>
<a name="ln5684">#endif</a>
<a name="ln5685">  return buf;</a>
<a name="ln5686">}</a>
<a name="ln5687"> </a>
<a name="ln5688">/// Expansion handler for :set= when we just want to fill in with the existing value.</a>
<a name="ln5689">int ExpandOldSetting(int *numMatches, char ***matches)</a>
<a name="ln5690">{</a>
<a name="ln5691">  char *var = NULL;</a>
<a name="ln5692"> </a>
<a name="ln5693">  *numMatches = 0;</a>
<a name="ln5694">  *matches = xmalloc(sizeof(char *));</a>
<a name="ln5695"> </a>
<a name="ln5696">  // For a terminal key code expand_option_idx is &lt; 0.</a>
<a name="ln5697">  if (expand_option_idx &lt; 0) {</a>
<a name="ln5698">    expand_option_idx = findoption(expand_option_name);</a>
<a name="ln5699">  }</a>
<a name="ln5700"> </a>
<a name="ln5701">  if (expand_option_idx &gt;= 0) {</a>
<a name="ln5702">    // Put string of option value in NameBuff.</a>
<a name="ln5703">    option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln5704">    var = NameBuff;</a>
<a name="ln5705">  } else {</a>
<a name="ln5706">    var = &quot;&quot;;</a>
<a name="ln5707">  }</a>
<a name="ln5708"> </a>
<a name="ln5709">  char *buf = escape_option_str_cmdline(var);</a>
<a name="ln5710"> </a>
<a name="ln5711">  (*matches)[0] = buf;</a>
<a name="ln5712">  *numMatches = 1;</a>
<a name="ln5713">  return OK;</a>
<a name="ln5714">}</a>
<a name="ln5715"> </a>
<a name="ln5716">/// Expansion handler for :set=/:set+= when the option has a custom expansion handler.</a>
<a name="ln5717">int ExpandStringSetting(expand_T *xp, regmatch_T *regmatch, int *numMatches, char ***matches)</a>
<a name="ln5718">{</a>
<a name="ln5719">  if (expand_option_idx &lt; 0</a>
<a name="ln5720">      || options[expand_option_idx].opt_expand_cb == NULL) {</a>
<a name="ln5721">    // Not supposed to reach this. This function is only for options with</a>
<a name="ln5722">    // custom expansion callbacks.</a>
<a name="ln5723">    return FAIL;</a>
<a name="ln5724">  }</a>
<a name="ln5725"> </a>
<a name="ln5726">  optexpand_T args = {</a>
<a name="ln5727">    .oe_varp = get_varp_scope(&amp;options[expand_option_idx], expand_option_flags),</a>
<a name="ln5728">    .oe_append = expand_option_append,</a>
<a name="ln5729">    .oe_regmatch = regmatch,</a>
<a name="ln5730">    .oe_xp = xp,</a>
<a name="ln5731">    .oe_set_arg = xp-&gt;xp_line + expand_option_start_col,</a>
<a name="ln5732">  };</a>
<a name="ln5733">  args.oe_include_orig_val = !expand_option_append &amp;&amp; (*args.oe_set_arg == NUL);</a>
<a name="ln5734"> </a>
<a name="ln5735">  // Retrieve the existing value, but escape it as a reverse of setting it.</a>
<a name="ln5736">  // We technically only need to do this when oe_append or</a>
<a name="ln5737">  // oe_include_orig_val is true.</a>
<a name="ln5738">  option_value2string(&amp;options[expand_option_idx], expand_option_flags);</a>
<a name="ln5739">  char *var = NameBuff;</a>
<a name="ln5740">  char *buf = escape_option_str_cmdline(var);</a>
<a name="ln5741">  args.oe_opt_value = buf;</a>
<a name="ln5742"> </a>
<a name="ln5743">  int num_ret = options[expand_option_idx].opt_expand_cb(&amp;args, numMatches, matches);</a>
<a name="ln5744"> </a>
<a name="ln5745">  xfree(buf);</a>
<a name="ln5746">  return num_ret;</a>
<a name="ln5747">}</a>
<a name="ln5748"> </a>
<a name="ln5749">/// Expansion handler for :set-=</a>
<a name="ln5750">int ExpandSettingSubtract(expand_T *xp, regmatch_T *regmatch, int *numMatches, char ***matches)</a>
<a name="ln5751">{</a>
<a name="ln5752">  if (expand_option_idx &lt; 0) {</a>
<a name="ln5753">    // term option</a>
<a name="ln5754">    return ExpandOldSetting(numMatches, matches);</a>
<a name="ln5755">  }</a>
<a name="ln5756"> </a>
<a name="ln5757">  char *option_val = *(char **)get_option_varp_scope_from(expand_option_idx,</a>
<a name="ln5758">                                                          expand_option_flags,</a>
<a name="ln5759">                                                          curbuf, curwin);</a>
<a name="ln5760"> </a>
<a name="ln5761">  uint32_t option_flags = options[expand_option_idx].flags;</a>
<a name="ln5762"> </a>
<a name="ln5763">  if (option_flags &amp; P_NUM) {</a>
<a name="ln5764">    return ExpandOldSetting(numMatches, matches);</a>
<a name="ln5765">  } else if (option_flags &amp; P_COMMA) {</a>
<a name="ln5766">    // Split the option by comma, then present each option to the user if</a>
<a name="ln5767">    // it matches the pattern.</a>
<a name="ln5768">    // This condition needs to go first, because 'whichwrap' has both</a>
<a name="ln5769">    // P_COMMA and P_FLAGLIST.</a>
<a name="ln5770"> </a>
<a name="ln5771">    if (*option_val == NUL) {</a>
<a name="ln5772">      return FAIL;</a>
<a name="ln5773">    }</a>
<a name="ln5774"> </a>
<a name="ln5775">    // Make a copy as we need to inject null characters destructively.</a>
<a name="ln5776">    char *option_copy = xstrdup(option_val);</a>
<a name="ln5777">    char *next_val = option_copy;</a>
<a name="ln5778"> </a>
<a name="ln5779">    garray_T ga;</a>
<a name="ln5780">    ga_init(&amp;ga, sizeof(char *), 10);</a>
<a name="ln5781"> </a>
<a name="ln5782">    do {</a>
<a name="ln5783">      char *item = next_val;</a>
<a name="ln5784">      char *comma = vim_strchr(next_val, ',');</a>
<a name="ln5785">      while (comma != NULL &amp;&amp; comma != next_val &amp;&amp; *(comma - 1) == '\\') {</a>
<a name="ln5786">        // &quot;\,&quot; is interpreted as a literal comma rather than option</a>
<a name="ln5787">        // separator when reading options in copy_option_part(). Skip</a>
<a name="ln5788">        // it.</a>
<a name="ln5789">        comma = vim_strchr(comma + 1, ',');</a>
<a name="ln5790">      }</a>
<a name="ln5791">      if (comma != NULL) {</a>
<a name="ln5792">        *comma = NUL;  // null-terminate this value, required by later functions</a>
<a name="ln5793">        next_val = comma + 1;</a>
<a name="ln5794">      } else {</a>
<a name="ln5795">        next_val = NULL;</a>
<a name="ln5796">      }</a>
<a name="ln5797"> </a>
<a name="ln5798">      if (*item == NUL) {</a>
<a name="ln5799">        // empty value, don't add to list</a>
<a name="ln5800">        continue;</a>
<a name="ln5801">      }</a>
<a name="ln5802"> </a>
<a name="ln5803">      if (!vim_regexec(regmatch, item, (colnr_T)0)) {</a>
<a name="ln5804">        continue;</a>
<a name="ln5805">      }</a>
<a name="ln5806"> </a>
<a name="ln5807">      char *buf = escape_option_str_cmdline(item);</a>
<a name="ln5808">      GA_APPEND(char *, &amp;ga, buf);</a>
<a name="ln5809">    } while (next_val != NULL);</a>
<a name="ln5810"> </a>
<a name="ln5811">    xfree(option_copy);</a>
<a name="ln5812"> </a>
<a name="ln5813">    *matches = ga.ga_data;</a>
<a name="ln5814">    *numMatches = ga.ga_len;</a>
<a name="ln5815">    return OK;</a>
<a name="ln5816">  } else if (option_flags &amp; P_FLAGLIST) {</a>
<a name="ln5817">    // Only present the flags that are set on the option as the other flags</a>
<a name="ln5818">    // are not meaningful to do set-= on.</a>
<a name="ln5819"> </a>
<a name="ln5820">    if (*xp-&gt;xp_pattern != NUL) {</a>
<a name="ln5821">      // Don't suggest anything if cmdline is non-empty. Vim's set-=</a>
<a name="ln5822">      // behavior requires consecutive strings and it's usually</a>
<a name="ln5823">      // unintuitive to users if ther try to subtract multiple flags at</a>
<a name="ln5824">      // once.</a>
<a name="ln5825">      return FAIL;</a>
<a name="ln5826">    }</a>
<a name="ln5827"> </a>
<a name="ln5828">    size_t num_flags = strlen(option_val);</a>
<a name="ln5829">    if (num_flags == 0) {</a>
<a name="ln5830">      return FAIL;</a>
<a name="ln5831">    }</a>
<a name="ln5832"> </a>
<a name="ln5833">    *matches = xmalloc(sizeof(char *) * (num_flags + 1));</a>
<a name="ln5834"> </a>
<a name="ln5835">    int count = 0;</a>
<a name="ln5836"> </a>
<a name="ln5837">    (*matches)[count++] = xstrdup(option_val);</a>
<a name="ln5838"> </a>
<a name="ln5839">    if (num_flags &gt; 1) {</a>
<a name="ln5840">      // If more than one flags, split the flags up and expose each</a>
<a name="ln5841">      // character as individual choice.</a>
<a name="ln5842">      for (char *flag = option_val; *flag != NUL; flag++) {</a>
<a name="ln5843">        (*matches)[count++] = xstrnsave(flag, 1);</a>
<a name="ln5844">      }</a>
<a name="ln5845">    }</a>
<a name="ln5846"> </a>
<a name="ln5847">    *numMatches = count;</a>
<a name="ln5848">    return OK;</a>
<a name="ln5849">  }</a>
<a name="ln5850"> </a>
<a name="ln5851">  return ExpandOldSetting(numMatches, matches);</a>
<a name="ln5852">}</a>
<a name="ln5853"> </a>
<a name="ln5854">/// Get the value for the numeric or string option///opp in a nice format into</a>
<a name="ln5855">/// NameBuff[].  Must not be called with a hidden option!</a>
<a name="ln5856">///</a>
<a name="ln5857">/// @param opt_flags  OPT_GLOBAL and/or OPT_LOCAL</a>
<a name="ln5858">static void option_value2string(vimoption_T *opp, int scope)</a>
<a name="ln5859">{</a>
<a name="ln5860">  void *varp = get_varp_scope(opp, scope);</a>
<a name="ln5861"> </a>
<a name="ln5862">  if (opp-&gt;flags &amp; P_NUM) {</a>
<a name="ln5863">    OptInt wc = 0;</a>
<a name="ln5864"> </a>
<a name="ln5865">    if (wc_use_keyname(varp, &amp;wc)) {</a>
<a name="ln5866">      xstrlcpy(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));</a>
<a name="ln5867">    } else if (wc != 0) {</a>
<a name="ln5868">      xstrlcpy(NameBuff, transchar((int)wc), sizeof(NameBuff));</a>
<a name="ln5869">    } else {</a>
<a name="ln5870">      snprintf(NameBuff,</a>
<a name="ln5871">               sizeof(NameBuff),</a>
<a name="ln5872">               &quot;%&quot; PRId64,</a>
<a name="ln5873">               (int64_t)(*(OptInt *)varp));</a>
<a name="ln5874">    }</a>
<a name="ln5875">  } else {  // P_STRING</a>
<a name="ln5876">    varp = *(char **)(varp);</a>
<a name="ln5877">    if (varp == NULL) {  // Just in case.</a>
<a name="ln5878">      NameBuff[0] = NUL;</a>
<a name="ln5879">    } else if (opp-&gt;flags &amp; P_EXPAND) {</a>
<a name="ln5880">      home_replace(NULL, varp, NameBuff, MAXPATHL, false);</a>
<a name="ln5881">    } else {</a>
<a name="ln5882">      xstrlcpy(NameBuff, varp, MAXPATHL);</a>
<a name="ln5883">    }</a>
<a name="ln5884">  }</a>
<a name="ln5885">}</a>
<a name="ln5886"> </a>
<a name="ln5887">/// Return true if &quot;varp&quot; points to 'wildchar' or 'wildcharm' and it can be</a>
<a name="ln5888">/// printed as a keyname.</a>
<a name="ln5889">/// &quot;*wcp&quot; is set to the value of the option if it's 'wildchar' or 'wildcharm'.</a>
<a name="ln5890">static int wc_use_keyname(const void *varp, OptInt *wcp)</a>
<a name="ln5891">{</a>
<a name="ln5892">  if (((OptInt *)varp == &amp;p_wc) || ((OptInt *)varp == &amp;p_wcm)) {</a>
<a name="ln5893">    *wcp = *(OptInt *)varp;</a>
<a name="ln5894">    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)(*wcp)) &gt;= 0) {</a>
<a name="ln5895">      return true;</a>
<a name="ln5896">    }</a>
<a name="ln5897">  }</a>
<a name="ln5898">  return false;</a>
<a name="ln5899">}</a>
<a name="ln5900"> </a>
<a name="ln5901">/// @returns true if &quot;x&quot; is present in 'shortmess' option, or</a>
<a name="ln5902">/// 'shortmess' contains 'a' and &quot;x&quot; is present in SHM_ALL_ABBREVIATIONS.</a>
<a name="ln5903">bool shortmess(int x)</a>
<a name="ln5904">{</a>
<a name="ln5905">  return (p_shm != NULL</a>
<a name="ln5906">          &amp;&amp; (vim_strchr(p_shm, x) != NULL</a>
<a name="ln5907">              || (vim_strchr(p_shm, 'a') != NULL</a>
<a name="ln5908">                  &amp;&amp; vim_strchr(SHM_ALL_ABBREVIATIONS, x) != NULL)));</a>
<a name="ln5909">}</a>
<a name="ln5910"> </a>
<a name="ln5911">/// vimrc_found() - Called when a vimrc or &quot;VIMINIT&quot; has been found.</a>
<a name="ln5912">///</a>
<a name="ln5913">/// Set the values for options that didn't get set yet to the defaults.</a>
<a name="ln5914">/// When &quot;fname&quot; is not NULL, use it to set $&quot;envname&quot; when it wasn't set yet.</a>
<a name="ln5915">void vimrc_found(char *fname, char *envname)</a>
<a name="ln5916">{</a>
<a name="ln5917">  if (fname != NULL &amp;&amp; envname != NULL) {</a>
<a name="ln5918">    char *p = vim_getenv(envname);</a>
<a name="ln5919">    if (p == NULL) {</a>
<a name="ln5920">      // Set $MYVIMRC to the first vimrc file found.</a>
<a name="ln5921">      p = FullName_save(fname, false);</a>
<a name="ln5922">      if (p != NULL) {</a>
<a name="ln5923">        os_setenv(envname, p, 1);</a>
<a name="ln5924">        xfree(p);</a>
<a name="ln5925">      }</a>
<a name="ln5926">    } else {</a>
<a name="ln5927">      xfree(p);</a>
<a name="ln5928">    }</a>
<a name="ln5929">  }</a>
<a name="ln5930">}</a>
<a name="ln5931"> </a>
<a name="ln5932">/// Check whether global option has been set</a>
<a name="ln5933">///</a>
<a name="ln5934">/// @param[in]  name  Option name.</a>
<a name="ln5935">///</a>
<a name="ln5936">/// @return True if it was set.</a>
<a name="ln5937">bool option_was_set(const char *name)</a>
<a name="ln5938">{</a>
<a name="ln5939">  int idx;</a>
<a name="ln5940"> </a>
<a name="ln5941">  idx = findoption(name);</a>
<a name="ln5942">  if (idx &lt; 0) {  // Unknown option.</a>
<a name="ln5943">    return false;</a>
<a name="ln5944">  } else if (options[idx].flags &amp; P_WAS_SET) {</a>
<a name="ln5945">    return true;</a>
<a name="ln5946">  }</a>
<a name="ln5947">  return false;</a>
<a name="ln5948">}</a>
<a name="ln5949"> </a>
<a name="ln5950">/// Reset the flag indicating option &quot;name&quot; was set.</a>
<a name="ln5951">///</a>
<a name="ln5952">/// @param[in]  name  Option name.</a>
<a name="ln5953">void reset_option_was_set(const char *name)</a>
<a name="ln5954">{</a>
<a name="ln5955">  const int idx = findoption(name);</a>
<a name="ln5956">  if (idx &lt; 0) {</a>
<a name="ln5957">    return;</a>
<a name="ln5958">  }</a>
<a name="ln5959"> </a>
<a name="ln5960">  options[idx].flags &amp;= ~P_WAS_SET;</a>
<a name="ln5961">}</a>
<a name="ln5962"> </a>
<a name="ln5963">/// fill_culopt_flags() -- called when 'culopt' changes value</a>
<a name="ln5964">int fill_culopt_flags(char *val, win_T *wp)</a>
<a name="ln5965">{</a>
<a name="ln5966">  char *p;</a>
<a name="ln5967">  uint8_t culopt_flags_new = 0;</a>
<a name="ln5968"> </a>
<a name="ln5969">  if (val == NULL) {</a>
<a name="ln5970">    p = wp-&gt;w_p_culopt;</a>
<a name="ln5971">  } else {</a>
<a name="ln5972">    p = val;</a>
<a name="ln5973">  }</a>
<a name="ln5974">  while (*p != NUL) {</a>
<a name="ln5975">    // Note: Keep this in sync with p_culopt_values.</a>
<a name="ln5976">    if (strncmp(p, &quot;line&quot;, 4) == 0) {</a>
<a name="ln5977">      p += 4;</a>
<a name="ln5978">      culopt_flags_new |= CULOPT_LINE;</a>
<a name="ln5979">    } else if (strncmp(p, &quot;both&quot;, 4) == 0) {</a>
<a name="ln5980">      p += 4;</a>
<a name="ln5981">      culopt_flags_new |= CULOPT_LINE | CULOPT_NBR;</a>
<a name="ln5982">    } else if (strncmp(p, &quot;number&quot;, 6) == 0) {</a>
<a name="ln5983">      p += 6;</a>
<a name="ln5984">      culopt_flags_new |= CULOPT_NBR;</a>
<a name="ln5985">    } else if (strncmp(p, &quot;screenline&quot;, 10) == 0) {</a>
<a name="ln5986">      p += 10;</a>
<a name="ln5987">      culopt_flags_new |= CULOPT_SCRLINE;</a>
<a name="ln5988">    }</a>
<a name="ln5989"> </a>
<a name="ln5990">    if (*p != ',' &amp;&amp; *p != NUL) {</a>
<a name="ln5991">      return FAIL;</a>
<a name="ln5992">    }</a>
<a name="ln5993">    if (*p == ',') {</a>
<a name="ln5994">      p++;</a>
<a name="ln5995">    }</a>
<a name="ln5996">  }</a>
<a name="ln5997"> </a>
<a name="ln5998">  // Can't have both &quot;line&quot; and &quot;screenline&quot;.</a>
<a name="ln5999">  if ((culopt_flags_new &amp; CULOPT_LINE) &amp;&amp; (culopt_flags_new &amp; CULOPT_SCRLINE)) {</a>
<a name="ln6000">    return FAIL;</a>
<a name="ln6001">  }</a>
<a name="ln6002">  wp-&gt;w_p_culopt_flags = culopt_flags_new;</a>
<a name="ln6003"> </a>
<a name="ln6004">  return OK;</a>
<a name="ln6005">}</a>
<a name="ln6006"> </a>
<a name="ln6007">/// Get the value of 'magic' taking &quot;magic_overruled&quot; into account.</a>
<a name="ln6008">bool magic_isset(void)</a>
<a name="ln6009">{</a>
<a name="ln6010">  switch (magic_overruled) {</a>
<a name="ln6011">  case OPTION_MAGIC_ON:</a>
<a name="ln6012">    return true;</a>
<a name="ln6013">  case OPTION_MAGIC_OFF:</a>
<a name="ln6014">    return false;</a>
<a name="ln6015">  case OPTION_MAGIC_NOT_SET:</a>
<a name="ln6016">    break;</a>
<a name="ln6017">  }</a>
<a name="ln6018">  return p_magic;</a>
<a name="ln6019">}</a>
<a name="ln6020"> </a>
<a name="ln6021">/// Set the callback function value for an option that accepts a function name,</a>
<a name="ln6022">/// lambda, et al. (e.g. 'operatorfunc', 'tagfunc', etc.)</a>
<a name="ln6023">/// @return  OK if the option is successfully set to a function, otherwise FAIL</a>
<a name="ln6024">int option_set_callback_func(char *optval, Callback *optcb)</a>
<a name="ln6025">{</a>
<a name="ln6026">  if (optval == NULL || *optval == NUL) {</a>
<a name="ln6027">    callback_free(optcb);</a>
<a name="ln6028">    return OK;</a>
<a name="ln6029">  }</a>
<a name="ln6030"> </a>
<a name="ln6031">  typval_T *tv;</a>
<a name="ln6032">  if (*optval == '{'</a>
<a name="ln6033">      || (strncmp(optval, &quot;function(&quot;, 9) == 0)</a>
<a name="ln6034">      || (strncmp(optval, &quot;funcref(&quot;, 8) == 0)) {</a>
<a name="ln6035">    // Lambda expression or a funcref</a>
<a name="ln6036">    tv = eval_expr(optval, NULL);</a>
<a name="ln6037">    if (tv == NULL) {</a>
<a name="ln6038">      return FAIL;</a>
<a name="ln6039">    }</a>
<a name="ln6040">  } else {</a>
<a name="ln6041">    // treat everything else as a function name string</a>
<a name="ln6042">    tv = xcalloc(1, sizeof(*tv));</a>
<a name="ln6043">    tv-&gt;v_type = VAR_STRING;</a>
<a name="ln6044">    tv-&gt;vval.v_string = xstrdup(optval);</a>
<a name="ln6045">  }</a>
<a name="ln6046"> </a>
<a name="ln6047">  Callback cb;</a>
<a name="ln6048">  if (!callback_from_typval(&amp;cb, tv) || cb.type == kCallbackNone) {</a>
<a name="ln6049">    tv_free(tv);</a>
<a name="ln6050">    return FAIL;</a>
<a name="ln6051">  }</a>
<a name="ln6052"> </a>
<a name="ln6053">  callback_free(optcb);</a>
<a name="ln6054">  *optcb = cb;</a>
<a name="ln6055">  tv_free(tv);</a>
<a name="ln6056">  return OK;</a>
<a name="ln6057">}</a>
<a name="ln6058"> </a>
<a name="ln6059">static void didset_options_sctx(int opt_flags, char **buf)</a>
<a name="ln6060">{</a>
<a name="ln6061">  for (int i = 0;; i++) {</a>
<a name="ln6062">    if (buf[i] == NULL) {</a>
<a name="ln6063">      break;</a>
<a name="ln6064">    }</a>
<a name="ln6065"> </a>
<a name="ln6066">    int idx = findoption(buf[i]);</a>
<a name="ln6067">    if (idx &gt;= 0) {</a>
<a name="ln6068">      set_option_sctx_idx(idx, opt_flags, current_sctx);</a>
<a name="ln6069">    }</a>
<a name="ln6070">  }</a>
<a name="ln6071">}</a>
<a name="ln6072"> </a>
<a name="ln6073">/// Check if backspacing over something is allowed.</a>
<a name="ln6074">/// @param  what  BS_INDENT, BS_EOL, BS_START, or BS_NOSTOP</a>
<a name="ln6075">bool can_bs(int what)</a>
<a name="ln6076">{</a>
<a name="ln6077">  if (what == BS_START &amp;&amp; bt_prompt(curbuf)) {</a>
<a name="ln6078">    return false;</a>
<a name="ln6079">  }</a>
<a name="ln6080"> </a>
<a name="ln6081">  // support for number values was removed but we keep '2' since it is used in</a>
<a name="ln6082">  // legacy tests</a>
<a name="ln6083">  if (*p_bs == '2') {</a>
<a name="ln6084">    return what != BS_NOSTOP;</a>
<a name="ln6085">  }</a>
<a name="ln6086"> </a>
<a name="ln6087">  return vim_strchr(p_bs, what) != NULL;</a>
<a name="ln6088">}</a>
<a name="ln6089"> </a>
<a name="ln6090">/// Get the local or global value of 'backupcopy'.</a>
<a name="ln6091">///</a>
<a name="ln6092">/// @param buf The buffer.</a>
<a name="ln6093">unsigned get_bkc_value(buf_T *buf)</a>
<a name="ln6094">{</a>
<a name="ln6095">  return buf-&gt;b_bkc_flags ? buf-&gt;b_bkc_flags : bkc_flags;</a>
<a name="ln6096">}</a>
<a name="ln6097"> </a>
<a name="ln6098">/// Get the local or global value of 'formatlistpat'.</a>
<a name="ln6099">///</a>
<a name="ln6100">/// @param buf The buffer.</a>
<a name="ln6101">char *get_flp_value(buf_T *buf)</a>
<a name="ln6102">{</a>
<a name="ln6103">  if (buf-&gt;b_p_flp == NULL || *buf-&gt;b_p_flp == NUL) {</a>
<a name="ln6104">    return p_flp;</a>
<a name="ln6105">  }</a>
<a name="ln6106">  return buf-&gt;b_p_flp;</a>
<a name="ln6107">}</a>
<a name="ln6108"> </a>
<a name="ln6109">/// Get the local or global value of the 'virtualedit' flags.</a>
<a name="ln6110">unsigned get_ve_flags(void)</a>
<a name="ln6111">{</a>
<a name="ln6112">  return (curwin-&gt;w_ve_flags ? curwin-&gt;w_ve_flags : ve_flags) &amp; ~(VE_NONE | VE_NONEU);</a>
<a name="ln6113">}</a>
<a name="ln6114"> </a>
<a name="ln6115">/// Get the local or global value of 'showbreak'.</a>
<a name="ln6116">///</a>
<a name="ln6117">/// @param win  If not NULL, the window to get the local option from; global</a>
<a name="ln6118">///             otherwise.</a>
<a name="ln6119">char *get_showbreak_value(win_T *const win)</a>
<a name="ln6120">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6121">{</a>
<a name="ln6122">  if (win-&gt;w_p_sbr == NULL || *win-&gt;w_p_sbr == NUL) {</a>
<a name="ln6123">    return p_sbr;</a>
<a name="ln6124">  }</a>
<a name="ln6125">  if (strcmp(win-&gt;w_p_sbr, &quot;NONE&quot;) == 0) {</a>
<a name="ln6126">    return empty_option;</a>
<a name="ln6127">  }</a>
<a name="ln6128">  return win-&gt;w_p_sbr;</a>
<a name="ln6129">}</a>
<a name="ln6130"> </a>
<a name="ln6131">/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.</a>
<a name="ln6132">int get_fileformat(const buf_T *buf)</a>
<a name="ln6133">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6134">{</a>
<a name="ln6135">  int c = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln6136"> </a>
<a name="ln6137">  if (buf-&gt;b_p_bin || c == 'u') {</a>
<a name="ln6138">    return EOL_UNIX;</a>
<a name="ln6139">  }</a>
<a name="ln6140">  if (c == 'm') {</a>
<a name="ln6141">    return EOL_MAC;</a>
<a name="ln6142">  }</a>
<a name="ln6143">  return EOL_DOS;</a>
<a name="ln6144">}</a>
<a name="ln6145"> </a>
<a name="ln6146">/// Like get_fileformat(), but override 'fileformat' with &quot;p&quot; for &quot;++opt=val&quot;</a>
<a name="ln6147">/// argument.</a>
<a name="ln6148">///</a>
<a name="ln6149">/// @param eap  can be NULL!</a>
<a name="ln6150">int get_fileformat_force(const buf_T *buf, const exarg_T *eap)</a>
<a name="ln6151">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln6152">{</a>
<a name="ln6153">  int c;</a>
<a name="ln6154"> </a>
<a name="ln6155">  if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln6156">    c = eap-&gt;force_ff;</a>
<a name="ln6157">  } else {</a>
<a name="ln6158">    if ((eap != NULL &amp;&amp; eap-&gt;force_bin != 0)</a>
<a name="ln6159">        ? (eap-&gt;force_bin == FORCE_BIN) : buf-&gt;b_p_bin) {</a>
<a name="ln6160">      return EOL_UNIX;</a>
<a name="ln6161">    }</a>
<a name="ln6162">    c = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln6163">  }</a>
<a name="ln6164">  if (c == 'u') {</a>
<a name="ln6165">    return EOL_UNIX;</a>
<a name="ln6166">  }</a>
<a name="ln6167">  if (c == 'm') {</a>
<a name="ln6168">    return EOL_MAC;</a>
<a name="ln6169">  }</a>
<a name="ln6170">  return EOL_DOS;</a>
<a name="ln6171">}</a>
<a name="ln6172"> </a>
<a name="ln6173">/// Return the default fileformat from 'fileformats'.</a>
<a name="ln6174">int default_fileformat(void)</a>
<a name="ln6175">{</a>
<a name="ln6176">  switch (*p_ffs) {</a>
<a name="ln6177">  case 'm':</a>
<a name="ln6178">    return EOL_MAC;</a>
<a name="ln6179">  case 'd':</a>
<a name="ln6180">    return EOL_DOS;</a>
<a name="ln6181">  }</a>
<a name="ln6182">  return EOL_UNIX;</a>
<a name="ln6183">}</a>
<a name="ln6184"> </a>
<a name="ln6185">/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.</a>
<a name="ln6186">///</a>
<a name="ln6187">/// Sets 'fileformat'.</a>
<a name="ln6188">///</a>
<a name="ln6189">/// @param eol_style End-of-line style.</a>
<a name="ln6190">/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL</a>
<a name="ln6191">void set_fileformat(int eol_style, int opt_flags)</a>
<a name="ln6192">{</a>
<a name="ln6193">  char *p = NULL;</a>
<a name="ln6194"> </a>
<a name="ln6195">  switch (eol_style) {</a>
<a name="ln6196">  case EOL_UNIX:</a>
<a name="ln6197">    p = FF_UNIX;</a>
<a name="ln6198">    break;</a>
<a name="ln6199">  case EOL_MAC:</a>
<a name="ln6200">    p = FF_MAC;</a>
<a name="ln6201">    break;</a>
<a name="ln6202">  case EOL_DOS:</a>
<a name="ln6203">    p = FF_DOS;</a>
<a name="ln6204">    break;</a>
<a name="ln6205">  }</a>
<a name="ln6206"> </a>
<a name="ln6207">  // p is NULL if &quot;eol_style&quot; is EOL_UNKNOWN.</a>
<a name="ln6208">  if (p != NULL) {</a>
<a name="ln6209">    set_string_option_direct(&quot;ff&quot;, -1, p, OPT_FREE | opt_flags, 0);</a>
<a name="ln6210">  }</a>
<a name="ln6211"> </a>
<a name="ln6212">  // This may cause the buffer to become (un)modified.</a>
<a name="ln6213">  redraw_buf_status_later(curbuf);</a>
<a name="ln6214">  redraw_tabline = true;</a>
<a name="ln6215">  need_maketitle = true;  // Set window title later.</a>
<a name="ln6216">}</a>
<a name="ln6217"> </a>
<a name="ln6218">/// Skip to next part of an option argument: skip space and comma</a>
<a name="ln6219">char *skip_to_option_part(const char *p)</a>
<a name="ln6220">{</a>
<a name="ln6221">  if (*p == ',') {</a>
<a name="ln6222">    p++;</a>
<a name="ln6223">  }</a>
<a name="ln6224">  while (*p == ' ') {</a>
<a name="ln6225">    p++;</a>
<a name="ln6226">  }</a>
<a name="ln6227">  return (char *)p;</a>
<a name="ln6228">}</a>
<a name="ln6229"> </a>
<a name="ln6230">/// Isolate one part of a string option separated by `sep_chars`.</a>
<a name="ln6231">///</a>
<a name="ln6232">/// @param[in,out]  option    advanced to the next part</a>
<a name="ln6233">/// @param[in,out]  buf       copy of the isolated part</a>
<a name="ln6234">/// @param[in]      maxlen    length of `buf`</a>
<a name="ln6235">/// @param[in]      sep_chars chars that separate the option parts</a>
<a name="ln6236">///</a>
<a name="ln6237">/// @return length of `*option`</a>
<a name="ln6238">size_t copy_option_part(char **option, char *buf, size_t maxlen, char *sep_chars)</a>
<a name="ln6239">{</a>
<a name="ln6240">  size_t len = 0;</a>
<a name="ln6241">  char *p = *option;</a>
<a name="ln6242"> </a>
<a name="ln6243">  // skip '.' at start of option part, for 'suffixes'</a>
<a name="ln6244">  if (*p == '.') {</a>
<a name="ln6245">    buf[len++] = *p++;</a>
<a name="ln6246">  }</a>
<a name="ln6247">  while (*p != NUL &amp;&amp; vim_strchr(sep_chars, (uint8_t)(*p)) == NULL) {</a>
<a name="ln6248">    // Skip backslash before a separator character and space.</a>
<a name="ln6249">    if (p[0] == '\\' &amp;&amp; vim_strchr(sep_chars, (uint8_t)p[1]) != NULL) {</a>
<a name="ln6250">      p++;</a>
<a name="ln6251">    }</a>
<a name="ln6252">    if (len &lt; maxlen - 1) {</a>
<a name="ln6253">      buf[len++] = *p;</a>
<a name="ln6254">    }</a>
<a name="ln6255">    p++;</a>
<a name="ln6256">  }</a>
<a name="ln6257">  buf[len] = NUL;</a>
<a name="ln6258"> </a>
<a name="ln6259">  if (*p != NUL &amp;&amp; *p != ',') {  // skip non-standard separator</a>
<a name="ln6260">    p++;</a>
<a name="ln6261">  }</a>
<a name="ln6262">  p = skip_to_option_part(p);    // p points to next file name</a>
<a name="ln6263"> </a>
<a name="ln6264">  *option = p;</a>
<a name="ln6265">  return len;</a>
<a name="ln6266">}</a>
<a name="ln6267"> </a>
<a name="ln6268">/// Return true when 'shell' has &quot;csh&quot; in the tail.</a>
<a name="ln6269">int csh_like_shell(void)</a>
<a name="ln6270">{</a>
<a name="ln6271">  return strstr(path_tail(p_sh), &quot;csh&quot;) != NULL;</a>
<a name="ln6272">}</a>
<a name="ln6273"> </a>
<a name="ln6274">/// Return true when 'shell' has &quot;fish&quot; in the tail.</a>
<a name="ln6275">bool fish_like_shell(void)</a>
<a name="ln6276">{</a>
<a name="ln6277">  return strstr(path_tail(p_sh), &quot;fish&quot;) != NULL;</a>
<a name="ln6278">}</a>
<a name="ln6279"> </a>
<a name="ln6280">/// Return the number of requested sign columns, based on current</a>
<a name="ln6281">/// buffer signs and on user configuration.</a>
<a name="ln6282">int win_signcol_count(win_T *wp)</a>
<a name="ln6283">{</a>
<a name="ln6284">  return win_signcol_configured(wp, NULL);</a>
<a name="ln6285">}</a>
<a name="ln6286"> </a>
<a name="ln6287">/// Return true when window &quot;wp&quot; has no sign column.</a>
<a name="ln6288">bool win_no_signcol(win_T *wp)</a>
<a name="ln6289">{</a>
<a name="ln6290">  const char *scl = wp-&gt;w_p_scl;</a>
<a name="ln6291">  return (*scl == 'n' &amp;&amp; (*(scl + 1) == 'o' || (*(scl + 1) == 'u'</a>
<a name="ln6292">                                                &amp;&amp; (wp-&gt;w_p_nu || wp-&gt;w_p_rnu))));</a>
<a name="ln6293">}</a>
<a name="ln6294"> </a>
<a name="ln6295">/// Return the number of requested sign columns, based on user / configuration.</a>
<a name="ln6296">int win_signcol_configured(win_T *wp, int *is_fixed)</a>
<a name="ln6297">{</a>
<a name="ln6298">  const char *scl = wp-&gt;w_p_scl;</a>
<a name="ln6299"> </a>
<a name="ln6300">  if (is_fixed) {</a>
<a name="ln6301">    *is_fixed = 1;</a>
<a name="ln6302">  }</a>
<a name="ln6303"> </a>
<a name="ln6304">  if (win_no_signcol(wp)) {</a>
<a name="ln6305">    return 0;</a>
<a name="ln6306">  }</a>
<a name="ln6307"> </a>
<a name="ln6308">  // yes or yes</a>
<a name="ln6309">  if (!strncmp(scl, &quot;yes:&quot;, 4)) {</a>
<a name="ln6310">    // Fixed amount of columns</a>
<a name="ln6311">    return scl[4] - '0';</a>
<a name="ln6312">  }</a>
<a name="ln6313">  if (*scl == 'y') {</a>
<a name="ln6314">    return 1;</a>
<a name="ln6315">  }</a>
<a name="ln6316"> </a>
<a name="ln6317">  if (is_fixed) {</a>
<a name="ln6318">    // auto or auto:&lt;NUM&gt;</a>
<a name="ln6319">    *is_fixed = 0;</a>
<a name="ln6320">  }</a>
<a name="ln6321"> </a>
<a name="ln6322">  int minimum = 0, maximum = 1;</a>
<a name="ln6323"> </a>
<a name="ln6324">  if (!strncmp(scl, &quot;auto:&quot;, 5)) {</a>
<a name="ln6325">    // Variable depending on a configuration</a>
<a name="ln6326">    maximum = scl[5] - '0';</a>
<a name="ln6327">    // auto:&lt;NUM&gt;-&lt;NUM&gt;</a>
<a name="ln6328">    if (strlen(scl) == 8 &amp;&amp; *(scl + 6) == '-') {</a>
<a name="ln6329">      minimum = maximum;</a>
<a name="ln6330">      maximum = scl[7] - '0';</a>
<a name="ln6331">    }</a>
<a name="ln6332">  }</a>
<a name="ln6333"> </a>
<a name="ln6334">  int needed_signcols = buf_signcols(wp-&gt;w_buffer, maximum);</a>
<a name="ln6335">  int ret = MAX(minimum, MIN(maximum, needed_signcols));</a>
<a name="ln6336">  assert(ret &lt;= SIGN_SHOW_MAX);</a>
<a name="ln6337">  return ret;</a>
<a name="ln6338">}</a>
<a name="ln6339"> </a>
<a name="ln6340">/// Get window or buffer local options</a>
<a name="ln6341">dict_T *get_winbuf_options(const int bufopt)</a>
<a name="ln6342">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln6343">{</a>
<a name="ln6344">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln6345"> </a>
<a name="ln6346">  for (int opt_idx = 0; options[opt_idx].fullname; opt_idx++) {</a>
<a name="ln6347">    struct vimoption *opt = &amp;options[opt_idx];</a>
<a name="ln6348"> </a>
<a name="ln6349">    if ((bufopt &amp;&amp; (opt-&gt;indir &amp; PV_BUF))</a>
<a name="ln6350">        || (!bufopt &amp;&amp; (opt-&gt;indir &amp; PV_WIN))) {</a>
<a name="ln6351">      void *varp = get_varp(opt);</a>
<a name="ln6352"> </a>
<a name="ln6353">      if (varp != NULL) {</a>
<a name="ln6354">        if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln6355">          tv_dict_add_str(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln6356">                          *(const char **)varp);</a>
<a name="ln6357">        } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln6358">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname),</a>
<a name="ln6359">                         *(OptInt *)varp);</a>
<a name="ln6360">        } else {</a>
<a name="ln6361">          tv_dict_add_nr(d, opt-&gt;fullname, strlen(opt-&gt;fullname), *(int *)varp);</a>
<a name="ln6362">        }</a>
<a name="ln6363">      }</a>
<a name="ln6364">    }</a>
<a name="ln6365">  }</a>
<a name="ln6366"> </a>
<a name="ln6367">  return d;</a>
<a name="ln6368">}</a>
<a name="ln6369"> </a>
<a name="ln6370">/// Return the effective 'scrolloff' value for the current window, using the</a>
<a name="ln6371">/// global value when appropriate.</a>
<a name="ln6372">int get_scrolloff_value(win_T *wp)</a>
<a name="ln6373">{</a>
<a name="ln6374">  // Disallow scrolloff in terminal-mode. #11915</a>
<a name="ln6375">  if (State &amp; MODE_TERMINAL) {</a>
<a name="ln6376">    return 0;</a>
<a name="ln6377">  }</a>
<a name="ln6378">  return (int)(wp-&gt;w_p_so &lt; 0 ? p_so : wp-&gt;w_p_so);</a>
<a name="ln6379">}</a>
<a name="ln6380"> </a>
<a name="ln6381">/// Return the effective 'sidescrolloff' value for the current window, using the</a>
<a name="ln6382">/// global value when appropriate.</a>
<a name="ln6383">int get_sidescrolloff_value(win_T *wp)</a>
<a name="ln6384">{</a>
<a name="ln6385">  return (int)(wp-&gt;w_p_siso &lt; 0 ? p_siso : wp-&gt;w_p_siso);</a>
<a name="ln6386">}</a>
<a name="ln6387"> </a>
<a name="ln6388">Dictionary get_vimoption(String name, int scope, buf_T *buf, win_T *win, Error *err)</a>
<a name="ln6389">{</a>
<a name="ln6390">  int opt_idx = findoption_len(name.data, name.size);</a>
<a name="ln6391">  VALIDATE_S(opt_idx &gt;= 0, &quot;option (not found)&quot;, name.data, {</a>
<a name="ln6392">    return (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln6393">  });</a>
<a name="ln6394"> </a>
<a name="ln6395">  return vimoption2dict(&amp;options[opt_idx], scope, buf, win);</a>
<a name="ln6396">}</a>
<a name="ln6397"> </a>
<a name="ln6398">Dictionary get_all_vimoptions(void)</a>
<a name="ln6399">{</a>
<a name="ln6400">  Dictionary retval = ARRAY_DICT_INIT;</a>
<a name="ln6401">  for (size_t i = 0; options[i].fullname != NULL; i++) {</a>
<a name="ln6402">    Dictionary opt_dict = vimoption2dict(&amp;options[i], OPT_GLOBAL, curbuf, curwin);</a>
<a name="ln6403">    PUT(retval, options[i].fullname, DICTIONARY_OBJ(opt_dict));</a>
<a name="ln6404">  }</a>
<a name="ln6405">  return retval;</a>
<a name="ln6406">}</a>
<a name="ln6407"> </a>
<a name="ln6408">static Dictionary vimoption2dict(vimoption_T *opt, int req_scope, buf_T *buf, win_T *win)</a>
<a name="ln6409">{</a>
<a name="ln6410">  Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln6411"> </a>
<a name="ln6412">  PUT(dict, &quot;name&quot;, CSTR_TO_OBJ(opt-&gt;fullname));</a>
<a name="ln6413">  PUT(dict, &quot;shortname&quot;, CSTR_TO_OBJ(opt-&gt;shortname));</a>
<a name="ln6414"> </a>
<a name="ln6415">  const char *scope;</a>
<a name="ln6416">  if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln6417">    scope = &quot;buf&quot;;</a>
<a name="ln6418">  } else if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln6419">    scope = &quot;win&quot;;</a>
<a name="ln6420">  } else {</a>
<a name="ln6421">    scope = &quot;global&quot;;</a>
<a name="ln6422">  }</a>
<a name="ln6423"> </a>
<a name="ln6424">  PUT(dict, &quot;scope&quot;, CSTR_TO_OBJ(scope));</a>
<a name="ln6425"> </a>
<a name="ln6426">  // welcome to the jungle</a>
<a name="ln6427">  PUT(dict, &quot;global_local&quot;, BOOLEAN_OBJ(opt-&gt;indir &amp; PV_BOTH));</a>
<a name="ln6428">  PUT(dict, &quot;commalist&quot;, BOOLEAN_OBJ(opt-&gt;flags &amp; P_COMMA));</a>
<a name="ln6429">  PUT(dict, &quot;flaglist&quot;, BOOLEAN_OBJ(opt-&gt;flags &amp; P_FLAGLIST));</a>
<a name="ln6430"> </a>
<a name="ln6431">  PUT(dict, &quot;was_set&quot;, BOOLEAN_OBJ(opt-&gt;flags &amp; P_WAS_SET));</a>
<a name="ln6432"> </a>
<a name="ln6433">  LastSet last_set = { .channel_id = 0 };</a>
<a name="ln6434">  if (req_scope == OPT_GLOBAL) {</a>
<a name="ln6435">    last_set = opt-&gt;last_set;</a>
<a name="ln6436">  } else {</a>
<a name="ln6437">    // Scope is either OPT_LOCAL or a fallback mode was requested.</a>
<a name="ln6438">    if (opt-&gt;indir &amp; PV_BUF) {</a>
<a name="ln6439">      last_set = buf-&gt;b_p_script_ctx[opt-&gt;indir &amp; PV_MASK];</a>
<a name="ln6440">    }</a>
<a name="ln6441">    if (opt-&gt;indir &amp; PV_WIN) {</a>
<a name="ln6442">      last_set = win-&gt;w_p_script_ctx[opt-&gt;indir &amp; PV_MASK];</a>
<a name="ln6443">    }</a>
<a name="ln6444">    if (req_scope != OPT_LOCAL &amp;&amp; last_set.script_ctx.sc_sid == 0) {</a>
<a name="ln6445">      last_set = opt-&gt;last_set;</a>
<a name="ln6446">    }</a>
<a name="ln6447">  }</a>
<a name="ln6448"> </a>
<a name="ln6449">  PUT(dict, &quot;last_set_sid&quot;, INTEGER_OBJ(last_set.script_ctx.sc_sid));</a>
<a name="ln6450">  PUT(dict, &quot;last_set_linenr&quot;, INTEGER_OBJ(last_set.script_ctx.sc_lnum));</a>
<a name="ln6451">  PUT(dict, &quot;last_set_chan&quot;, INTEGER_OBJ((int64_t)last_set.channel_id));</a>
<a name="ln6452"> </a>
<a name="ln6453">  const char *type;</a>
<a name="ln6454">  Object def;</a>
<a name="ln6455">  // TODO(bfredl): do you even nocp?</a>
<a name="ln6456">  char *def_val = opt-&gt;def_val;</a>
<a name="ln6457">  if (opt-&gt;flags &amp; P_STRING) {</a>
<a name="ln6458">    type = &quot;string&quot;;</a>
<a name="ln6459">    def = CSTR_TO_OBJ(def_val ? def_val : &quot;&quot;);</a>
<a name="ln6460">  } else if (opt-&gt;flags &amp; P_NUM) {</a>
<a name="ln6461">    type = &quot;number&quot;;</a>
<a name="ln6462">    def = INTEGER_OBJ((Integer)(intptr_t)def_val);</a>
<a name="ln6463">  } else if (opt-&gt;flags &amp; P_BOOL) {</a>
<a name="ln6464">    type = &quot;boolean&quot;;</a>
<a name="ln6465">    def = BOOLEAN_OBJ((intptr_t)def_val);</a>
<a name="ln6466">  } else {</a>
<a name="ln6467">    type = &quot;&quot;; def = NIL;</a>
<a name="ln6468">  }</a>
<a name="ln6469">  PUT(dict, &quot;type&quot;, CSTR_TO_OBJ(type));</a>
<a name="ln6470">  PUT(dict, &quot;default&quot;, def);</a>
<a name="ln6471">  PUT(dict, &quot;allows_duplicates&quot;, BOOLEAN_OBJ(!(opt-&gt;flags &amp; P_NODUP)));</a>
<a name="ln6472"> </a>
<a name="ln6473">  return dict;</a>
<a name="ln6474">}</a>
</code></pre>
<div class="balloon" rel="5514"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1063/" target="_blank">V1063</a> The modulo by 1 operation is meaningless. The result will always be zero.</p></div>
<div class="balloon" rel="5514"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: ((p - s) % 1) == 0.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>