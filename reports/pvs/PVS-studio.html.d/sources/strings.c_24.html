<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>strings.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;math.h&gt;</a>
<a name="ln7">#include &lt;stdarg.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;auto/config.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/assert.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln21">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln22">#include &quot;nvim/garray.h&quot;</a>
<a name="ln23">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln24">#include &quot;nvim/globals.h&quot;</a>
<a name="ln25">#include &quot;nvim/macros.h&quot;</a>
<a name="ln26">#include &quot;nvim/math.h&quot;</a>
<a name="ln27">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln28">#include &quot;nvim/memory.h&quot;</a>
<a name="ln29">#include &quot;nvim/message.h&quot;</a>
<a name="ln30">#include &quot;nvim/option.h&quot;</a>
<a name="ln31">#include &quot;nvim/plines.h&quot;</a>
<a name="ln32">#include &quot;nvim/strings.h&quot;</a>
<a name="ln33">#include &quot;nvim/types.h&quot;</a>
<a name="ln34">#include &quot;nvim/vim.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">static const char e_cannot_mix_positional_and_non_positional_str[]</a>
<a name="ln37">  = N_(&quot;E1500: Cannot mix positional and non-positional arguments: %s&quot;);</a>
<a name="ln38">static const char e_fmt_arg_nr_unused_str[]</a>
<a name="ln39">  = N_(&quot;E1501: format argument %d unused in $-style format: %s&quot;);</a>
<a name="ln40">static const char e_positional_num_field_spec_reused_str_str[]</a>
<a name="ln41">  = N_(&quot;E1502: Positional argument %d used as field width reused as different type: %s/%s&quot;);</a>
<a name="ln42">static const char e_positional_nr_out_of_bounds_str[]</a>
<a name="ln43">  = N_(&quot;E1503: Positional argument %d out of bounds: %s&quot;);</a>
<a name="ln44">static const char e_positional_arg_num_type_inconsistent_str_str[]</a>
<a name="ln45">  = N_(&quot;E1504: Positional argument %d type used inconsistently: %s/%s&quot;);</a>
<a name="ln46">static const char e_invalid_format_specifier_str[]</a>
<a name="ln47">  = N_(&quot;E1505: Invalid format specifier: %s&quot;);</a>
<a name="ln48">static const char e_aptypes_is_null_nr_str[]</a>
<a name="ln49">  = &quot;E1507: Internal error: ap_types or ap_types[idx] is NULL: %d: %s&quot;;</a>
<a name="ln50"> </a>
<a name="ln51">static const char typename_unknown[] = N_(&quot;unknown&quot;);</a>
<a name="ln52">static const char typename_int[] = N_(&quot;int&quot;);</a>
<a name="ln53">static const char typename_longint[] = N_(&quot;long int&quot;);</a>
<a name="ln54">static const char typename_longlongint[] = N_(&quot;long long int&quot;);</a>
<a name="ln55">static const char typename_signedsizet[] = N_(&quot;signed size_t&quot;);</a>
<a name="ln56">static const char typename_unsignedint[] = N_(&quot;unsigned int&quot;);</a>
<a name="ln57">static const char typename_unsignedlongint[] = N_(&quot;unsigned long int&quot;);</a>
<a name="ln58">static const char typename_unsignedlonglongint[] = N_(&quot;unsigned long long int&quot;);</a>
<a name="ln59">static const char typename_sizet[] = N_(&quot;size_t&quot;);</a>
<a name="ln60">static const char typename_pointer[] = N_(&quot;pointer&quot;);</a>
<a name="ln61">static const char typename_percent[] = N_(&quot;percent&quot;);</a>
<a name="ln62">static const char typename_char[] = N_(&quot;char&quot;);</a>
<a name="ln63">static const char typename_string[] = N_(&quot;string&quot;);</a>
<a name="ln64">static const char typename_float[] = N_(&quot;float&quot;);</a>
<a name="ln65"> </a>
<a name="ln66">/// Copy up to `len` bytes of `string` into newly allocated memory and</a>
<a name="ln67">/// terminate with a NUL. The allocated memory always has size `len + 1`, even</a>
<a name="ln68">/// when `string` is shorter.</a>
<a name="ln69">char *xstrnsave(const char *string, size_t len)</a>
<a name="ln70">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln71">{</a>
<a name="ln72">  return strncpy(xmallocz(len), string, len);  // NOLINT(runtime/printf)</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">// Same as vim_strsave(), but any characters found in esc_chars are preceded</a>
<a name="ln76">// by a backslash.</a>
<a name="ln77">char *vim_strsave_escaped(const char *string, const char *esc_chars)</a>
<a name="ln78">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln79">{</a>
<a name="ln80">  return vim_strsave_escaped_ext(string, esc_chars, '\\', false);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">// Same as vim_strsave_escaped(), but when &quot;bsl&quot; is true also escape</a>
<a name="ln84">// characters where rem_backslash() would remove the backslash.</a>
<a name="ln85">// Escape the characters with &quot;cc&quot;.</a>
<a name="ln86">char *vim_strsave_escaped_ext(const char *string, const char *esc_chars, char cc, bool bsl)</a>
<a name="ln87">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln88">{</a>
<a name="ln89">  // First count the number of backslashes required.</a>
<a name="ln90">  // Then allocate the memory and insert them.</a>
<a name="ln91">  size_t length = 1;                    // count the trailing NUL</a>
<a name="ln92">  for (const char *p = string; *p; p++) {</a>
<a name="ln93">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln94">    if (l &gt; 1) {</a>
<a name="ln95">      length += l;                      // count a multibyte char</a>
<a name="ln96">      p += l - 1;</a>
<a name="ln97">      continue;</a>
<a name="ln98">    }</a>
<a name="ln99">    if (vim_strchr(esc_chars, (uint8_t)(*p)) != NULL || (bsl &amp;&amp; rem_backslash(p))) {</a>
<a name="ln100">      length++;                         // count a backslash</a>
<a name="ln101">    }</a>
<a name="ln102">    length++;                           // count an ordinary char</a>
<a name="ln103">  }</a>
<a name="ln104"> </a>
<a name="ln105">  char *escaped_string = xmalloc(length);</a>
<a name="ln106">  char *p2 = escaped_string;</a>
<a name="ln107">  for (const char *p = string; *p; p++) {</a>
<a name="ln108">    const size_t l = (size_t)(utfc_ptr2len(p));</a>
<a name="ln109">    if (l &gt; 1) {</a>
<a name="ln110">      memcpy(p2, p, l);</a>
<a name="ln111">      p2 += l;</a>
<a name="ln112">      p += l - 1;                     // skip multibyte char</a>
<a name="ln113">      continue;</a>
<a name="ln114">    }</a>
<a name="ln115">    if (vim_strchr(esc_chars, (uint8_t)(*p)) != NULL || (bsl &amp;&amp; rem_backslash(p))) {</a>
<a name="ln116">      *p2++ = cc;</a>
<a name="ln117">    }</a>
<a name="ln118">    *p2++ = *p;</a>
<a name="ln119">  }</a>
<a name="ln120">  *p2 = NUL;</a>
<a name="ln121"> </a>
<a name="ln122">  return escaped_string;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">/// Save a copy of an unquoted string</a>
<a name="ln126">///</a>
<a name="ln127">/// Turns string like `a\bc&quot;def\&quot;ghi\\\n&quot;jkl` into `a\bcdef&quot;ghi\\njkl`, for use</a>
<a name="ln128">/// in shell_build_argv: the only purpose of backslash is making next character</a>
<a name="ln129">/// be treated literally inside the double quotes, if this character is</a>
<a name="ln130">/// backslash or quote.</a>
<a name="ln131">///</a>
<a name="ln132">/// @param[in]  string  String to copy.</a>
<a name="ln133">/// @param[in]  length  Length of the string to copy.</a>
<a name="ln134">///</a>
<a name="ln135">/// @return [allocated] Copy of the string.</a>
<a name="ln136">char *vim_strnsave_unquoted(const char *const string, const size_t length)</a>
<a name="ln137">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln138">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln139">{</a>
<a name="ln140">#define ESCAPE_COND(p, inquote, string_end) \</a>
<a name="ln141">  (*(p) == '\\' &amp;&amp; (inquote) &amp;&amp; (p) + 1 &lt; (string_end) &amp;&amp; ((p)[1] == '\\' || (p)[1] == '&quot;'))</a>
<a name="ln142">  size_t ret_length = 0;</a>
<a name="ln143">  bool inquote = false;</a>
<a name="ln144">  const char *const string_end = string + length;</a>
<a name="ln145">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln146">    if (*p == '&quot;') {</a>
<a name="ln147">      inquote = !inquote;</a>
<a name="ln148">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln149">      ret_length++;</a>
<a name="ln150">      p++;</a>
<a name="ln151">    } else {</a>
<a name="ln152">      ret_length++;</a>
<a name="ln153">    }</a>
<a name="ln154">  }</a>
<a name="ln155"> </a>
<a name="ln156">  char *const ret = xmallocz(ret_length);</a>
<a name="ln157">  char *rp = ret;</a>
<a name="ln158">  inquote = false;</a>
<a name="ln159">  for (const char *p = string; p &lt; string_end; p++) {</a>
<a name="ln160">    if (*p == '&quot;') {</a>
<a name="ln161">      inquote = !inquote;</a>
<a name="ln162">    } else if (ESCAPE_COND(p, inquote, string_end)) {</a>
<a name="ln163">      *rp++ = *(++p);</a>
<a name="ln164">    } else {</a>
<a name="ln165">      *rp++ = *p;</a>
<a name="ln166">    }</a>
<a name="ln167">  }</a>
<a name="ln168">#undef ESCAPE_COND</a>
<a name="ln169"> </a>
<a name="ln170">  return ret;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/// Escape &quot;string&quot; for use as a shell argument with system().</a>
<a name="ln174">/// This uses single quotes, except when we know we need to use double quotes</a>
<a name="ln175">/// (MS-Windows without 'shellslash' set).</a>
<a name="ln176">/// Escape a newline, depending on the 'shell' option.</a>
<a name="ln177">/// When &quot;do_special&quot; is true also replace &quot;!&quot;, &quot;%&quot;, &quot;#&quot; and things starting</a>
<a name="ln178">/// with &quot;&lt;&quot; like &quot;&lt;cfile&gt;&quot;.</a>
<a name="ln179">/// When &quot;do_newline&quot; is false do not escape newline unless it is csh shell.</a>
<a name="ln180">///</a>
<a name="ln181">/// @return  the result in allocated memory.</a>
<a name="ln182">char *vim_strsave_shellescape(const char *string, bool do_special, bool do_newline)</a>
<a name="ln183">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln184">{</a>
<a name="ln185">  char *d;</a>
<a name="ln186">  char *escaped_string;</a>
<a name="ln187">  size_t l;</a>
<a name="ln188">  int csh_like;</a>
<a name="ln189">  bool fish_like;</a>
<a name="ln190"> </a>
<a name="ln191">  // Only csh and similar shells expand '!' within single quotes.  For sh and</a>
<a name="ln192">  // the like we must not put a backslash before it, it will be taken</a>
<a name="ln193">  // literally.  If do_special is set the '!' will be escaped twice.</a>
<a name="ln194">  // Csh also needs to have &quot;\n&quot; escaped twice when do_special is set.</a>
<a name="ln195">  csh_like = csh_like_shell();</a>
<a name="ln196"> </a>
<a name="ln197">  // Fish shell uses '\' as an escape character within single quotes, so '\'</a>
<a name="ln198">  // itself must be escaped to get a literal '\'.</a>
<a name="ln199">  fish_like = fish_like_shell();</a>
<a name="ln200"> </a>
<a name="ln201">  // First count the number of extra bytes required.</a>
<a name="ln202">  size_t length = strlen(string) + 3;       // two quotes and a trailing NUL</a>
<a name="ln203">  for (const char *p = string; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln204">#ifdef MSWIN</a>
<a name="ln205">    if (!p_ssl) {</a>
<a name="ln206">      if (*p == '&quot;') {</a>
<a name="ln207">        length++;                       // &quot; -&gt; &quot;&quot;</a>
<a name="ln208">      }</a>
<a name="ln209">    } else</a>
<a name="ln210">#endif</a>
<a name="ln211">    if (*p == '\'') {</a>
<a name="ln212">      length += 3;                      // ' =&gt; '\''</a>
<a name="ln213">    }</a>
<a name="ln214">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln215">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln216">      length++;                         // insert backslash</a>
<a name="ln217">      if (csh_like &amp;&amp; do_special) {</a>
<a name="ln218">        length++;                       // insert backslash</a>
<a name="ln219">      }</a>
<a name="ln220">    }</a>
<a name="ln221">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln222">      length++;                         // insert backslash</a>
<a name="ln223">      p += l - 1;</a>
<a name="ln224">    }</a>
<a name="ln225">    if (*p == '\\' &amp;&amp; fish_like) {</a>
<a name="ln226">      length++;  // insert backslash</a>
<a name="ln227">    }</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  // Allocate memory for the result and fill it.</a>
<a name="ln231">  escaped_string = xmalloc(length);</a>
<a name="ln232">  d = escaped_string;</a>
<a name="ln233"> </a>
<a name="ln234">  // add opening quote</a>
<a name="ln235">#ifdef MSWIN</a>
<a name="ln236">  if (!p_ssl) {</a>
<a name="ln237">    *d++ = '&quot;';</a>
<a name="ln238">  } else</a>
<a name="ln239">#endif</a>
<a name="ln240">  *d++ = '\'';</a>
<a name="ln241"> </a>
<a name="ln242">  for (const char *p = string; *p != NUL;) {</a>
<a name="ln243">#ifdef MSWIN</a>
<a name="ln244">    if (!p_ssl) {</a>
<a name="ln245">      if (*p == '&quot;') {</a>
<a name="ln246">        *d++ = '&quot;';</a>
<a name="ln247">        *d++ = '&quot;';</a>
<a name="ln248">        p++;</a>
<a name="ln249">        continue;</a>
<a name="ln250">      }</a>
<a name="ln251">    } else</a>
<a name="ln252">#endif</a>
<a name="ln253">    if (*p == '\'') {</a>
<a name="ln254">      *d++ = '\'';</a>
<a name="ln255">      *d++ = '\\';</a>
<a name="ln256">      *d++ = '\'';</a>
<a name="ln257">      *d++ = '\'';</a>
<a name="ln258">      p++;</a>
<a name="ln259">      continue;</a>
<a name="ln260">    }</a>
<a name="ln261">    if ((*p == '\n' &amp;&amp; (csh_like || do_newline))</a>
<a name="ln262">        || (*p == '!' &amp;&amp; (csh_like || do_special))) {</a>
<a name="ln263">      *d++ = '\\';</a>
<a name="ln264">      if (csh_like &amp;&amp; do_special) {</a>
<a name="ln265">        *d++ = '\\';</a>
<a name="ln266">      }</a>
<a name="ln267">      *d++ = *p++;</a>
<a name="ln268">      continue;</a>
<a name="ln269">    }</a>
<a name="ln270">    if (do_special &amp;&amp; find_cmdline_var(p, &amp;l) &gt;= 0) {</a>
<a name="ln271">      *d++ = '\\';                    // insert backslash</a>
<a name="ln272">      while (--l != SIZE_MAX) {  // copy the var</a>
<a name="ln273">        *d++ = *p++;</a>
<a name="ln274">      }</a>
<a name="ln275">      continue;</a>
<a name="ln276">    }</a>
<a name="ln277">    if (*p == '\\' &amp;&amp; fish_like) {</a>
<a name="ln278">      *d++ = '\\';</a>
<a name="ln279">      *d++ = *p++;</a>
<a name="ln280">      continue;</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">    mb_copy_char(&amp;p, &amp;d);</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  // add terminating quote and finish with a NUL</a>
<a name="ln287">#ifdef MSWIN</a>
<a name="ln288">  if (!p_ssl) {</a>
<a name="ln289">    *d++ = '&quot;';</a>
<a name="ln290">  } else</a>
<a name="ln291">#endif</a>
<a name="ln292">  *d++ = '\'';</a>
<a name="ln293">  *d = NUL;</a>
<a name="ln294"> </a>
<a name="ln295">  return escaped_string;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">// Like vim_strsave(), but make all characters uppercase.</a>
<a name="ln299">// This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln300">char *vim_strsave_up(const char *string)</a>
<a name="ln301">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln302">{</a>
<a name="ln303">  char *p1;</a>
<a name="ln304"> </a>
<a name="ln305">  p1 = xstrdup(string);</a>
<a name="ln306">  vim_strup(p1);</a>
<a name="ln307">  return p1;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/// Like xstrnsave(), but make all characters uppercase.</a>
<a name="ln311">/// This uses ASCII lower-to-upper case translation, language independent.</a>
<a name="ln312">char *vim_strnsave_up(const char *string, size_t len)</a>
<a name="ln313">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln314">{</a>
<a name="ln315">  char *p1 = xstrnsave(string, len);</a>
<a name="ln316">  vim_strup(p1);</a>
<a name="ln317">  return p1;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">// ASCII lower-to-upper case translation, language independent.</a>
<a name="ln321">void vim_strup(char *p)</a>
<a name="ln322">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln323">{</a>
<a name="ln324">  uint8_t c;</a>
<a name="ln325">  while ((c = (uint8_t)(*p)) != NUL) {</a>
<a name="ln326">    *p++ = (char)(uint8_t)(c &lt; 'a' || c &gt; 'z' ? c : c - 0x20);</a>
<a name="ln327">  }</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/// Make given string all upper-case or all lower-case</a>
<a name="ln331">///</a>
<a name="ln332">/// Handles multi-byte characters as good as possible.</a>
<a name="ln333">///</a>
<a name="ln334">/// @param[in]  orig  Input string.</a>
<a name="ln335">/// @param[in]  upper If true make uppercase, otherwise lowercase</a>
<a name="ln336">///</a>
<a name="ln337">/// @return [allocated] upper-cased string.</a>
<a name="ln338">char *strcase_save(const char *const orig, bool upper)</a>
<a name="ln339">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln340">{</a>
<a name="ln341">  char *res = xstrdup(orig);</a>
<a name="ln342"> </a>
<a name="ln343">  char *p = res;</a>
<a name="ln344">  while (*p != NUL) {</a>
<a name="ln345">    int c = utf_ptr2char(p);</a>
<a name="ln346">    int l = utf_ptr2len(p);</a>
<a name="ln347">    if (c == 0) {</a>
<a name="ln348">      // overlong sequence, use only the first byte</a>
<a name="ln349">      c = (uint8_t)(*p);</a>
<a name="ln350">      l = 1;</a>
<a name="ln351">    }</a>
<a name="ln352">    int uc = upper ? mb_toupper(c) : mb_tolower(c);</a>
<a name="ln353"> </a>
<a name="ln354">    // Reallocate string when byte count changes.  This is rare,</a>
<a name="ln355">    // thus it's OK to do another malloc()/free().</a>
<a name="ln356">    int newl = utf_char2len(uc);</a>
<a name="ln357">    if (newl != l) {</a>
<a name="ln358">      // TODO(philix): use xrealloc() in strcase_save()</a>
<a name="ln359">      char *s = xmalloc(strlen(res) + (size_t)(1 + newl - l));</a>
<a name="ln360">      memcpy(s, res, (size_t)(p - res));</a>
<a name="ln361">      STRCPY(s + (p - res) + newl, p + l);</a>
<a name="ln362">      p = s + (p - res);</a>
<a name="ln363">      xfree(res);</a>
<a name="ln364">      res = s;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    utf_char2bytes(uc, p);</a>
<a name="ln368">    p += newl;</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  return res;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">// delete spaces at the end of a string</a>
<a name="ln375">void del_trailing_spaces(char *ptr)</a>
<a name="ln376">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln377">{</a>
<a name="ln378">  char *q;</a>
<a name="ln379"> </a>
<a name="ln380">  q = ptr + strlen(ptr);</a>
<a name="ln381">  while (--q &gt; ptr &amp;&amp; ascii_iswhite(q[0]) &amp;&amp; q[-1] != '\\' &amp;&amp; q[-1] != Ctrl_V) {</a>
<a name="ln382">    *q = NUL;</a>
<a name="ln383">  }</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">#if !defined(HAVE_STRNLEN)</a>
<a name="ln387">size_t xstrnlen(const char *s, size_t n)</a>
<a name="ln388">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln389">{</a>
<a name="ln390">  const char *end = memchr(s, '\0', n);</a>
<a name="ln391">  if (end == NULL) {</a>
<a name="ln392">    return n;</a>
<a name="ln393">  }</a>
<a name="ln394">  return (size_t)(end - s);</a>
<a name="ln395">}</a>
<a name="ln396">#endif</a>
<a name="ln397"> </a>
<a name="ln398">#if (!defined(HAVE_STRCASECMP) &amp;&amp; !defined(HAVE_STRICMP))</a>
<a name="ln399">// Compare two strings, ignoring case, using current locale.</a>
<a name="ln400">// Doesn't work for multi-byte characters.</a>
<a name="ln401">// return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln402">int vim_stricmp(const char *s1, const char *s2)</a>
<a name="ln403">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln404">{</a>
<a name="ln405">  int i;</a>
<a name="ln406"> </a>
<a name="ln407">  while (true) {</a>
<a name="ln408">    i = (int)TOLOWER_LOC((uint8_t)(*s1)) - (int)TOLOWER_LOC((uint8_t)(*s2));</a>
<a name="ln409">    if (i != 0) {</a>
<a name="ln410">      return i;                             // this character different</a>
<a name="ln411">    }</a>
<a name="ln412">    if (*s1 == NUL) {</a>
<a name="ln413">      break;                                // strings match until NUL</a>
<a name="ln414">    }</a>
<a name="ln415">    s1++;</a>
<a name="ln416">    s2++;</a>
<a name="ln417">  }</a>
<a name="ln418">  return 0;                                 // strings match</a>
<a name="ln419">}</a>
<a name="ln420">#endif</a>
<a name="ln421"> </a>
<a name="ln422">#if (!defined(HAVE_STRNCASECMP) &amp;&amp; !defined(HAVE_STRNICMP))</a>
<a name="ln423">// Compare two strings, for length &quot;len&quot;, ignoring case, using current locale.</a>
<a name="ln424">// Doesn't work for multi-byte characters.</a>
<a name="ln425">// return 0 for match, &lt; 0 for smaller, &gt; 0 for bigger</a>
<a name="ln426">int vim_strnicmp(const char *s1, const char *s2, size_t len)</a>
<a name="ln427">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE</a>
<a name="ln428">{</a>
<a name="ln429">  int i;</a>
<a name="ln430"> </a>
<a name="ln431">  while (len &gt; 0) {</a>
<a name="ln432">    i = (int)TOLOWER_LOC((uint8_t)(*s1)) - (int)TOLOWER_LOC((uint8_t)(*s2));</a>
<a name="ln433">    if (i != 0) {</a>
<a name="ln434">      return i;                             // this character different</a>
<a name="ln435">    }</a>
<a name="ln436">    if (*s1 == NUL) {</a>
<a name="ln437">      break;                                // strings match until NUL</a>
<a name="ln438">    }</a>
<a name="ln439">    s1++;</a>
<a name="ln440">    s2++;</a>
<a name="ln441">    len--;</a>
<a name="ln442">  }</a>
<a name="ln443">  return 0;                                 // strings match</a>
<a name="ln444">}</a>
<a name="ln445">#endif</a>
<a name="ln446"> </a>
<a name="ln447">/// strchr() version which handles multibyte strings</a>
<a name="ln448">///</a>
<a name="ln449">/// @param[in]  string  String to search in.</a>
<a name="ln450">/// @param[in]  c  Character to search for.</a>
<a name="ln451">///</a>
<a name="ln452">/// @return Pointer to the first byte of the found character in string or NULL</a>
<a name="ln453">///         if it was not found or character is invalid. NUL character is never</a>
<a name="ln454">///         found, use `strlen()` instead.</a>
<a name="ln455">char *vim_strchr(const char *const string, const int c)</a>
<a name="ln456">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln457">{</a>
<a name="ln458">  if (c &lt;= 0) {</a>
<a name="ln459">    return NULL;</a>
<a name="ln460">  } else if (c &lt; 0x80) {</a>
<a name="ln461">    return strchr(string, c);</a>
<a name="ln462">  } else {</a>
<a name="ln463">    char u8char[MB_MAXBYTES + 1];</a>
<a name="ln464">    const int len = utf_char2bytes(c, u8char);</a>
<a name="ln465">    u8char[len] = NUL;</a>
<a name="ln466">    return strstr(string, u8char);</a>
<a name="ln467">  }</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">// Sort an array of strings.</a>
<a name="ln471"> </a>
<a name="ln472">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln473"># include &quot;strings.c.generated.h&quot;</a>
<a name="ln474">#endif</a>
<a name="ln475">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln476">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln477">{</a>
<a name="ln478">  return strcmp(*(char **)s1, *(char **)s2);</a>
<a name="ln479">}</a>
<a name="ln480"> </a>
<a name="ln481">void sort_strings(char **files, int count)</a>
<a name="ln482">{</a>
<a name="ln483">  qsort((void *)files, (size_t)count, sizeof(char *), sort_compare);</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">// Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln487">// When &quot;s&quot; is NULL false is returned.</a>
<a name="ln488">bool has_non_ascii(const char *s)</a>
<a name="ln489">  FUNC_ATTR_PURE</a>
<a name="ln490">{</a>
<a name="ln491">  const char *p;</a>
<a name="ln492"> </a>
<a name="ln493">  if (s != NULL) {</a>
<a name="ln494">    for (p = s; *p != NUL; p++) {</a>
<a name="ln495">      if ((uint8_t)(*p) &gt;= 128) {</a>
<a name="ln496">        return true;</a>
<a name="ln497">      }</a>
<a name="ln498">    }</a>
<a name="ln499">  }</a>
<a name="ln500">  return false;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/// Return true if string &quot;s&quot; contains a non-ASCII character (128 or higher).</a>
<a name="ln504">/// When &quot;s&quot; is NULL false is returned.</a>
<a name="ln505">bool has_non_ascii_len(const char *const s, const size_t len)</a>
<a name="ln506">  FUNC_ATTR_PURE</a>
<a name="ln507">{</a>
<a name="ln508">  if (s != NULL) {</a>
<a name="ln509">    for (size_t i = 0; i &lt; len; i++) {</a>
<a name="ln510">      if ((uint8_t)s[i] &gt;= 128) {</a>
<a name="ln511">        return true;</a>
<a name="ln512">      }</a>
<a name="ln513">    }</a>
<a name="ln514">  }</a>
<a name="ln515">  return false;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">/// Concatenate two strings and return the result in allocated memory.</a>
<a name="ln519">char *concat_str(const char *restrict str1, const char *restrict str2)</a>
<a name="ln520">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln521">{</a>
<a name="ln522">  size_t l = strlen(str1);</a>
<a name="ln523">  char *dest = xmalloc(l + strlen(str2) + 1);</a>
<a name="ln524">  STRCPY(dest, str1);</a>
<a name="ln525">  STRCPY(dest + l, str2);</a>
<a name="ln526">  return dest;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">static const char *const e_printf =</a>
<a name="ln530">  N_(&quot;E766: Insufficient arguments for printf()&quot;);</a>
<a name="ln531"> </a>
<a name="ln532">/// Get number argument from idxp entry in tvs</a>
<a name="ln533">///</a>
<a name="ln534">/// Will give an error message for Vimscript entry with invalid type or for insufficient entries.</a>
<a name="ln535">///</a>
<a name="ln536">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.</a>
<a name="ln537">/// @param[in,out]  idxp  Index in a list. Will be incremented. Indexing starts at 1.</a>
<a name="ln538">///</a>
<a name="ln539">/// @return Number value or 0 in case of error.</a>
<a name="ln540">static varnumber_T tv_nr(typval_T *tvs, int *idxp)</a>
<a name="ln541">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln542">{</a>
<a name="ln543">  int idx = *idxp - 1;</a>
<a name="ln544">  varnumber_T n = 0;</a>
<a name="ln545"> </a>
<a name="ln546">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln547">    emsg(_(e_printf));</a>
<a name="ln548">  } else {</a>
<a name="ln549">    (*idxp)++;</a>
<a name="ln550">    bool err = false;</a>
<a name="ln551">    n = tv_get_number_chk(&amp;tvs[idx], &amp;err);</a>
<a name="ln552">    if (err) {</a>
<a name="ln553">      n = 0;</a>
<a name="ln554">    }</a>
<a name="ln555">  }</a>
<a name="ln556">  return n;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/// Get string argument from idxp entry in tvs</a>
<a name="ln560">///</a>
<a name="ln561">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln562">/// insufficient entries.</a>
<a name="ln563">///</a>
<a name="ln564">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN</a>
<a name="ln565">///                  value.</a>
<a name="ln566">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln567">/// @param[out]  tofree  If the idxp entry in tvs is not a String or a Number,</a>
<a name="ln568">///                      it will be converted to String in the same format</a>
<a name="ln569">///                      as &quot;:echo&quot; and stored in &quot;*tofree&quot;. The caller must</a>
<a name="ln570">///                      free &quot;*tofree&quot;.</a>
<a name="ln571">///</a>
<a name="ln572">/// @return String value or NULL in case of error.</a>
<a name="ln573">static const char *tv_str(typval_T *tvs, int *idxp, char **const tofree)</a>
<a name="ln574">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln575">{</a>
<a name="ln576">  int idx = *idxp - 1;</a>
<a name="ln577">  const char *s = NULL;</a>
<a name="ln578"> </a>
<a name="ln579">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln580">    emsg(_(e_printf));</a>
<a name="ln581">  } else {</a>
<a name="ln582">    (*idxp)++;</a>
<a name="ln583">    if (tvs[idx].v_type == VAR_STRING || tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln584">      s = tv_get_string_chk(&amp;tvs[idx]);</a>
<a name="ln585">      *tofree = NULL;</a>
<a name="ln586">    } else {</a>
<a name="ln587">      s = *tofree = encode_tv2echo(&amp;tvs[idx], NULL);</a>
<a name="ln588">    }</a>
<a name="ln589">  }</a>
<a name="ln590">  return s;</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">/// Get pointer argument from the next entry in tvs</a>
<a name="ln594">///</a>
<a name="ln595">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln596">/// insufficient entries.</a>
<a name="ln597">///</a>
<a name="ln598">/// @param[in]  tvs  List of typval_T values.</a>
<a name="ln599">/// @param[in,out]  idxp  Pointer to the index of the current value.</a>
<a name="ln600">///</a>
<a name="ln601">/// @return Pointer stored in typval_T or NULL.</a>
<a name="ln602">static const void *tv_ptr(const typval_T *const tvs, int *const idxp)</a>
<a name="ln603">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln604">{</a>
<a name="ln605">#define OFF(attr) offsetof(union typval_vval_union, attr)</a>
<a name="ln606">  STATIC_ASSERT(OFF(v_string) == OFF(v_list)  // -V568</a>
<a name="ln607">                &amp;&amp; OFF(v_string) == OFF(v_dict)</a>
<a name="ln608">                &amp;&amp; OFF(v_string) == OFF(v_partial)</a>
<a name="ln609">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_list)</a>
<a name="ln610">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_dict)</a>
<a name="ln611">                &amp;&amp; sizeof(tvs[0].vval.v_string) == sizeof(tvs[0].vval.v_partial),</a>
<a name="ln612">                &quot;Strings, dictionaries, lists and partials are expected to be pointers, &quot;</a>
<a name="ln613">                &quot;so that all three of them can be accessed via v_string&quot;);</a>
<a name="ln614">#undef OFF</a>
<a name="ln615">  const int idx = *idxp - 1;</a>
<a name="ln616">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln617">    emsg(_(e_printf));</a>
<a name="ln618">    return NULL;</a>
<a name="ln619">  }</a>
<a name="ln620">  (*idxp)++;</a>
<a name="ln621">  return tvs[idx].vval.v_string;</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">/// Get float argument from idxp entry in tvs</a>
<a name="ln625">///</a>
<a name="ln626">/// Will give an error message for Vimscript entry with invalid type or for</a>
<a name="ln627">/// insufficient entries.</a>
<a name="ln628">///</a>
<a name="ln629">/// @param[in]  tvs  List of Vimscript values. List is terminated by VAR_UNKNOWN value.</a>
<a name="ln630">/// @param[in,out]  idxp  Index in a list. Will be incremented.</a>
<a name="ln631">///</a>
<a name="ln632">/// @return Floating-point value or zero in case of error.</a>
<a name="ln633">static float_T tv_float(typval_T *const tvs, int *const idxp)</a>
<a name="ln634">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln635">{</a>
<a name="ln636">  int idx = *idxp - 1;</a>
<a name="ln637">  float_T f = 0;</a>
<a name="ln638"> </a>
<a name="ln639">  if (tvs[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln640">    emsg(_(e_printf));</a>
<a name="ln641">  } else {</a>
<a name="ln642">    (*idxp)++;</a>
<a name="ln643">    if (tvs[idx].v_type == VAR_FLOAT) {</a>
<a name="ln644">      f = tvs[idx].vval.v_float;</a>
<a name="ln645">    } else if (tvs[idx].v_type == VAR_NUMBER) {</a>
<a name="ln646">      f = (float_T)tvs[idx].vval.v_number;</a>
<a name="ln647">    } else {</a>
<a name="ln648">      emsg(_(&quot;E807: Expected Float argument for printf()&quot;));</a>
<a name="ln649">    }</a>
<a name="ln650">  }</a>
<a name="ln651">  return f;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">// This code was included to provide a portable vsnprintf() and snprintf().</a>
<a name="ln655">// Some systems may provide their own, but we always use this one for</a>
<a name="ln656">// consistency.</a>
<a name="ln657">//</a>
<a name="ln658">// This code is based on snprintf.c - a portable implementation of snprintf</a>
<a name="ln659">// by Mark Martinec &lt;mark.martinec@ijs.si&gt;, Version 2.2, 2000-10-06.</a>
<a name="ln660">// Included with permission.  It was heavily modified to fit in Vim.</a>
<a name="ln661">// The original code, including useful comments, can be found here:</a>
<a name="ln662">//</a>
<a name="ln663">//     http://www.ijs.si/software/snprintf/</a>
<a name="ln664">//</a>
<a name="ln665">// This snprintf() only supports the following conversion specifiers:</a>
<a name="ln666">// s, c, b, B, d, u, o, x, X, p  (and synonyms: i, D, U, O - see below)</a>
<a name="ln667">// with flags: '-', '+', ' ', '0' and '#'.</a>
<a name="ln668">// An asterisk is supported for field width as well as precision.</a>
<a name="ln669">//</a>
<a name="ln670">// Limited support for floating point was added: 'f', 'e', 'E', 'g', 'G'.</a>
<a name="ln671">//</a>
<a name="ln672">// Length modifiers 'h' (short int), 'l' (long int) and &quot;ll&quot; (long long int) are</a>
<a name="ln673">// supported.</a>
<a name="ln674">//</a>
<a name="ln675">// The locale is not used, the string is used as a byte string.  This is only</a>
<a name="ln676">// relevant for double-byte encodings where the second byte may be '%'.</a>
<a name="ln677">//</a>
<a name="ln678">// It is permitted for &quot;str_m&quot; to be zero, and it is permitted to specify NULL</a>
<a name="ln679">// pointer for resulting string argument if &quot;str_m&quot; is zero (as per ISO C99).</a>
<a name="ln680">//</a>
<a name="ln681">// The return value is the number of characters which would be generated</a>
<a name="ln682">// for the given input, excluding the trailing NUL. If this value</a>
<a name="ln683">// is greater or equal to &quot;str_m&quot;, not all characters from the result</a>
<a name="ln684">// have been stored in str, output bytes beyond the (&quot;str_m&quot;-1) -th character</a>
<a name="ln685">// are discarded. If &quot;str_m&quot; is greater than zero it is guaranteed</a>
<a name="ln686">// the resulting string will be NUL-terminated.</a>
<a name="ln687"> </a>
<a name="ln688">// vim_vsnprintf_typval() can be invoked with either &quot;va_list&quot; or a list of</a>
<a name="ln689">// &quot;typval_T&quot;.  When the latter is not used it must be NULL.</a>
<a name="ln690"> </a>
<a name="ln691">/// Append a formatted value to the string</a>
<a name="ln692">///</a>
<a name="ln693">/// @see vim_vsnprintf_typval().</a>
<a name="ln694">int vim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)</a>
<a name="ln695">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln696">{</a>
<a name="ln697">  const size_t len = strlen(str);</a>
<a name="ln698">  size_t space;</a>
<a name="ln699"> </a>
<a name="ln700">  if (str_m &lt;= len) {</a>
<a name="ln701">    space = 0;</a>
<a name="ln702">  } else {</a>
<a name="ln703">    space = str_m - len;</a>
<a name="ln704">  }</a>
<a name="ln705">  va_list ap;</a>
<a name="ln706">  va_start(ap, fmt);</a>
<a name="ln707">  const int str_l = vim_vsnprintf(str + len, space, fmt, ap);</a>
<a name="ln708">  va_end(ap);</a>
<a name="ln709">  return str_l;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">/// Write formatted value to the string</a>
<a name="ln713">///</a>
<a name="ln714">/// @param[out]  str  String to write to.</a>
<a name="ln715">/// @param[in]  str_m  String length.</a>
<a name="ln716">/// @param[in]  fmt  String format.</a>
<a name="ln717">///</a>
<a name="ln718">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln719">///         string if str_m was greater or equal to the return value.</a>
<a name="ln720">int vim_snprintf(char *str, size_t str_m, const char *fmt, ...)</a>
<a name="ln721">  FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln722">{</a>
<a name="ln723">  va_list ap;</a>
<a name="ln724">  va_start(ap, fmt);</a>
<a name="ln725">  const int str_l = vim_vsnprintf(str, str_m, fmt, ap);</a>
<a name="ln726">  va_end(ap);</a>
<a name="ln727">  return str_l;</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">// Return the representation of infinity for printf() function:</a>
<a name="ln731">// &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;, &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot; or &quot; INF&quot;.</a>
<a name="ln732">static const char *infinity_str(bool positive, char fmt_spec, int force_sign,</a>
<a name="ln733">                                int space_for_positive)</a>
<a name="ln734">{</a>
<a name="ln735">  static const char *table[] = {</a>
<a name="ln736">    &quot;-inf&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot; inf&quot;,</a>
<a name="ln737">    &quot;-INF&quot;, &quot;INF&quot;, &quot;+INF&quot;, &quot; INF&quot;</a>
<a name="ln738">  };</a>
<a name="ln739">  int idx = positive * (1 + force_sign + force_sign * space_for_positive);</a>
<a name="ln740">  if (ASCII_ISUPPER(fmt_spec)) {</a>
<a name="ln741">    idx += 4;</a>
<a name="ln742">  }</a>
<a name="ln743">  return table[idx];</a>
<a name="ln744">}</a>
<a name="ln745"> </a>
<a name="ln746">int vim_vsnprintf(char *str, size_t str_m, const char *fmt, va_list ap)</a>
<a name="ln747">{</a>
<a name="ln748">  return vim_vsnprintf_typval(str, str_m, fmt, ap, NULL);</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">enum {</a>
<a name="ln752">  TYPE_UNKNOWN = -1,</a>
<a name="ln753">  TYPE_INT,</a>
<a name="ln754">  TYPE_LONGINT,</a>
<a name="ln755">  TYPE_LONGLONGINT,</a>
<a name="ln756">  TYPE_SIGNEDSIZET,</a>
<a name="ln757">  TYPE_UNSIGNEDINT,</a>
<a name="ln758">  TYPE_UNSIGNEDLONGINT,</a>
<a name="ln759">  TYPE_UNSIGNEDLONGLONGINT,</a>
<a name="ln760">  TYPE_SIZET,</a>
<a name="ln761">  TYPE_POINTER,</a>
<a name="ln762">  TYPE_PERCENT,</a>
<a name="ln763">  TYPE_CHAR,</a>
<a name="ln764">  TYPE_STRING,</a>
<a name="ln765">  TYPE_FLOAT,</a>
<a name="ln766">};</a>
<a name="ln767"> </a>
<a name="ln768">/// Types that can be used in a format string</a>
<a name="ln769">static int format_typeof(const char *type)</a>
<a name="ln770">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln771">{</a>
<a name="ln772">  // allowed values: \0, h, l, L</a>
<a name="ln773">  char length_modifier = '\0';</a>
<a name="ln774"> </a>
<a name="ln775">  // current conversion specifier character</a>
<a name="ln776">  char fmt_spec = '\0';</a>
<a name="ln777"> </a>
<a name="ln778">  // parse 'h', 'l', 'll' and 'z' length modifiers</a>
<a name="ln779">  if (*type == 'h' || *type == 'l' || *type == 'z') {</a>
<a name="ln780">    length_modifier = *type;</a>
<a name="ln781">    type++;</a>
<a name="ln782">    if (length_modifier == 'l' &amp;&amp; *type == 'l') {</a>
<a name="ln783">      // double l = long long</a>
<a name="ln784">      length_modifier = 'L';</a>
<a name="ln785">      type++;</a>
<a name="ln786">    }</a>
<a name="ln787">  }</a>
<a name="ln788">  fmt_spec = *type;</a>
<a name="ln789"> </a>
<a name="ln790">  // common synonyms:</a>
<a name="ln791">  switch (fmt_spec) {</a>
<a name="ln792">  case 'i':</a>
<a name="ln793">    fmt_spec = 'd'; break;</a>
<a name="ln794">  case '*':</a>
<a name="ln795">    fmt_spec = 'd'; length_modifier = 'h'; break;</a>
<a name="ln796">  case 'D':</a>
<a name="ln797">    fmt_spec = 'd'; length_modifier = 'l'; break;</a>
<a name="ln798">  case 'U':</a>
<a name="ln799">    fmt_spec = 'u'; length_modifier = 'l'; break;</a>
<a name="ln800">  case 'O':</a>
<a name="ln801">    fmt_spec = 'o'; length_modifier = 'l'; break;</a>
<a name="ln802">  default:</a>
<a name="ln803">    break;</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  // get parameter value, do initial processing</a>
<a name="ln807">  switch (fmt_spec) {</a>
<a name="ln808">  // '%' and 'c' behave similar to 's' regarding flags and field</a>
<a name="ln809">  // widths</a>
<a name="ln810">  case '%':</a>
<a name="ln811">    return TYPE_PERCENT;</a>
<a name="ln812"> </a>
<a name="ln813">  case 'c':</a>
<a name="ln814">    return TYPE_CHAR;</a>
<a name="ln815"> </a>
<a name="ln816">  case 's':</a>
<a name="ln817">  case 'S':</a>
<a name="ln818">    return TYPE_STRING;</a>
<a name="ln819"> </a>
<a name="ln820">  case 'd':</a>
<a name="ln821">  case 'u':</a>
<a name="ln822">  case 'b':</a>
<a name="ln823">  case 'B':</a>
<a name="ln824">  case 'o':</a>
<a name="ln825">  case 'x':</a>
<a name="ln826">  case 'X':</a>
<a name="ln827">  case 'p':</a>
<a name="ln828">    // NOTE: the u, b, o, x, X and p conversion specifiers</a>
<a name="ln829">    // imply the value is unsigned;  d implies a signed</a>
<a name="ln830">    // value</a>
<a name="ln831"> </a>
<a name="ln832">    // 0 if numeric argument is zero (or if pointer is</a>
<a name="ln833">    // NULL for 'p'), +1 if greater than zero (or nonzero</a>
<a name="ln834">    // for unsigned arguments), -1 if negative (unsigned</a>
<a name="ln835">    // argument is never negative)</a>
<a name="ln836"> </a>
<a name="ln837">    if (fmt_spec == 'p') {</a>
<a name="ln838">      return TYPE_POINTER;</a>
<a name="ln839">    } else if (fmt_spec == 'b' || fmt_spec == 'B') {</a>
<a name="ln840">      return TYPE_UNSIGNEDLONGLONGINT;</a>
<a name="ln841">    } else if (fmt_spec == 'd') {</a>
<a name="ln842">      // signed</a>
<a name="ln843">      switch (length_modifier) {</a>
<a name="ln844">      case '\0':</a>
<a name="ln845">      case 'h':</a>
<a name="ln846">        // char and short arguments are passed as int.</a>
<a name="ln847">        return TYPE_INT;</a>
<a name="ln848">      case 'l':</a>
<a name="ln849">        return TYPE_LONGINT;</a>
<a name="ln850">      case 'L':</a>
<a name="ln851">        return TYPE_LONGLONGINT;</a>
<a name="ln852">      case 'z':</a>
<a name="ln853">        return TYPE_SIGNEDSIZET;</a>
<a name="ln854">      }</a>
<a name="ln855">    } else {</a>
<a name="ln856">      // unsigned</a>
<a name="ln857">      switch (length_modifier) {</a>
<a name="ln858">      case '\0':</a>
<a name="ln859">      case 'h':</a>
<a name="ln860">        return TYPE_UNSIGNEDINT;</a>
<a name="ln861">      case 'l':</a>
<a name="ln862">        return TYPE_UNSIGNEDLONGINT;</a>
<a name="ln863">      case 'L':</a>
<a name="ln864">        return TYPE_UNSIGNEDLONGLONGINT;</a>
<a name="ln865">      case 'z':</a>
<a name="ln866">        return TYPE_SIZET;</a>
<a name="ln867">      }</a>
<a name="ln868">    }</a>
<a name="ln869">    break;</a>
<a name="ln870"> </a>
<a name="ln871">  case 'f':</a>
<a name="ln872">  case 'F':</a>
<a name="ln873">  case 'e':</a>
<a name="ln874">  case 'E':</a>
<a name="ln875">  case 'g':</a>
<a name="ln876">  case 'G':</a>
<a name="ln877">    return TYPE_FLOAT;</a>
<a name="ln878">  }</a>
<a name="ln879"> </a>
<a name="ln880">  return TYPE_UNKNOWN;</a>
<a name="ln881">}</a>
<a name="ln882"> </a>
<a name="ln883">static char *format_typename(const char *type)</a>
<a name="ln884">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln885">{</a>
<a name="ln886">  switch (format_typeof(type)) {</a>
<a name="ln887">  case TYPE_INT:</a>
<a name="ln888">    return _(typename_int);</a>
<a name="ln889">  case TYPE_LONGINT:</a>
<a name="ln890">    return _(typename_longint);</a>
<a name="ln891">  case TYPE_LONGLONGINT:</a>
<a name="ln892">    return _(typename_longlongint);</a>
<a name="ln893">  case TYPE_UNSIGNEDINT:</a>
<a name="ln894">    return _(typename_unsignedint);</a>
<a name="ln895">  case TYPE_SIGNEDSIZET:</a>
<a name="ln896">    return _(typename_signedsizet);</a>
<a name="ln897">  case TYPE_UNSIGNEDLONGINT:</a>
<a name="ln898">    return _(typename_unsignedlongint);</a>
<a name="ln899">  case TYPE_UNSIGNEDLONGLONGINT:</a>
<a name="ln900">    return _(typename_unsignedlonglongint);</a>
<a name="ln901">  case TYPE_SIZET:</a>
<a name="ln902">    return _(typename_sizet);</a>
<a name="ln903">  case TYPE_POINTER:</a>
<a name="ln904">    return _(typename_pointer);</a>
<a name="ln905">  case TYPE_PERCENT:</a>
<a name="ln906">    return _(typename_percent);</a>
<a name="ln907">  case TYPE_CHAR:</a>
<a name="ln908">    return _(typename_char);</a>
<a name="ln909">  case TYPE_STRING:</a>
<a name="ln910">    return _(typename_string);</a>
<a name="ln911">  case TYPE_FLOAT:</a>
<a name="ln912">    return _(typename_float);</a>
<a name="ln913">  }</a>
<a name="ln914"> </a>
<a name="ln915">  return _(typename_unknown);</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">static int adjust_types(const char ***ap_types, int arg, int *num_posarg, const char *type)</a>
<a name="ln919">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln920">{</a>
<a name="ln921">  if (*ap_types == NULL || *num_posarg &lt; arg) {</a>
<a name="ln922">    const char **new_types = *ap_types == NULL</a>
<a name="ln923">      ? xcalloc(sizeof(const char *), (size_t)arg)</a>
<a name="ln924">      : xrealloc(*ap_types, (size_t)arg * sizeof(const char *));</a>
<a name="ln925"> </a>
<a name="ln926">    for (int idx = *num_posarg; idx &lt; arg; idx++) {</a>
<a name="ln927">      new_types[idx] = NULL;</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    *ap_types = new_types;</a>
<a name="ln931">    *num_posarg = arg;</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  if ((*ap_types)[arg - 1] != NULL) {</a>
<a name="ln935">    if ((*ap_types)[arg - 1][0] == '*' || type[0] == '*') {</a>
<a name="ln936">      const char *pt = type;</a>
<a name="ln937">      if (pt[0] == '*') {</a>
<a name="ln938">        pt = (*ap_types)[arg - 1];</a>
<a name="ln939">      }</a>
<a name="ln940"> </a>
<a name="ln941">      if (pt[0] != '*') {</a>
<a name="ln942">        switch (pt[0]) {</a>
<a name="ln943">        case 'd':</a>
<a name="ln944">        case 'i':</a>
<a name="ln945">          break;</a>
<a name="ln946">        default:</a>
<a name="ln947">          semsg(_(e_positional_num_field_spec_reused_str_str), arg,</a>
<a name="ln948">                format_typename((*ap_types)[arg - 1]), format_typename(type));</a>
<a name="ln949">          return FAIL;</a>
<a name="ln950">        }</a>
<a name="ln951">      }</a>
<a name="ln952">    } else {</a>
<a name="ln953">      if (format_typeof(type) != format_typeof((*ap_types)[arg - 1])) {</a>
<a name="ln954">        semsg(_(e_positional_arg_num_type_inconsistent_str_str), arg,</a>
<a name="ln955">              format_typename(type), format_typename((*ap_types)[arg - 1]));</a>
<a name="ln956">        return FAIL;</a>
<a name="ln957">      }</a>
<a name="ln958">    }</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  (*ap_types)[arg - 1] = type;</a>
<a name="ln962"> </a>
<a name="ln963">  return OK;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">static int parse_fmt_types(const char ***ap_types, int *num_posarg, const char *fmt, typval_T *tvs)</a>
<a name="ln967">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln968">{</a>
<a name="ln969">  const char *p = fmt;</a>
<a name="ln970">  const char *arg = NULL;</a>
<a name="ln971"> </a>
<a name="ln972">  int any_pos = 0;</a>
<a name="ln973">  int any_arg = 0;</a>
<a name="ln974"> </a>
<a name="ln975">#define CHECK_POS_ARG \</a>
<a name="ln976">  do { \</a>
<a name="ln977">    if (any_pos &amp;&amp; any_arg) { \</a>
<a name="ln978">      semsg(_(e_cannot_mix_positional_and_non_positional_str), fmt); \</a>
<a name="ln979">      goto error; \</a>
<a name="ln980">    } \</a>
<a name="ln981">  } while (0);</a>
<a name="ln982"> </a>
<a name="ln983">  if (p == NULL) {</a>
<a name="ln984">    return OK;</a>
<a name="ln985">  }</a>
<a name="ln986"> </a>
<a name="ln987">  while (*p != NUL) {</a>
<a name="ln988">    if (*p != '%') {</a>
<a name="ln989">      char *q = strchr(p + 1, '%');</a>
<a name="ln990">      size_t n = (q == NULL) ? strlen(p) : (size_t)(q - p);</a>
<a name="ln991"> </a>
<a name="ln992">      p += n;</a>
<a name="ln993">    } else {</a>
<a name="ln994">      // allowed values: \0, h, l, L</a>
<a name="ln995">      char length_modifier = '\0';</a>
<a name="ln996"> </a>
<a name="ln997">      // variable for positional arg</a>
<a name="ln998">      int pos_arg = -1;</a>
<a name="ln999"> </a>
<a name="ln1000">      p++;  // skip '%'</a>
<a name="ln1001"> </a>
<a name="ln1002">      // First check to see if we find a positional</a>
<a name="ln1003">      // argument specifier</a>
<a name="ln1004">      const char *ptype = p;</a>
<a name="ln1005"> </a>
<a name="ln1006">      while (ascii_isdigit(*ptype)) {</a>
<a name="ln1007">        ptype++;</a>
<a name="ln1008">      }</a>
<a name="ln1009"> </a>
<a name="ln1010">      if (*ptype == '$') {</a>
<a name="ln1011">        if (*p == '0') {</a>
<a name="ln1012">          // 0 flag at the wrong place</a>
<a name="ln1013">          semsg(_(e_invalid_format_specifier_str), fmt);</a>
<a name="ln1014">          goto error;</a>
<a name="ln1015">        }</a>
<a name="ln1016"> </a>
<a name="ln1017">        // Positional argument</a>
<a name="ln1018">        unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1019"> </a>
<a name="ln1020">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1021">          uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1022">        }</a>
<a name="ln1023">        pos_arg = (int)uj;</a>
<a name="ln1024"> </a>
<a name="ln1025">        any_pos = 1;</a>
<a name="ln1026">        CHECK_POS_ARG;</a>
<a name="ln1027"> </a>
<a name="ln1028">        p++;</a>
<a name="ln1029">      }</a>
<a name="ln1030"> </a>
<a name="ln1031">      // parse flags</a>
<a name="ln1032">      while (*p == '0' || *p == '-' || *p == '+' || *p == ' '</a>
<a name="ln1033">             || *p == '#' || *p == '\'') {</a>
<a name="ln1034">        switch (*p) {</a>
<a name="ln1035">        case '0':</a>
<a name="ln1036">          break;</a>
<a name="ln1037">        case '-':</a>
<a name="ln1038">          break;</a>
<a name="ln1039">        case '+':</a>
<a name="ln1040">          break;</a>
<a name="ln1041">        case ' ':  // If both the ' ' and '+' flags appear, the ' '</a>
<a name="ln1042">                   // flag should be ignored</a>
<a name="ln1043">          break;</a>
<a name="ln1044">        case '#':</a>
<a name="ln1045">          break;</a>
<a name="ln1046">        case '\'':</a>
<a name="ln1047">          break;</a>
<a name="ln1048">        }</a>
<a name="ln1049">        p++;</a>
<a name="ln1050">      }</a>
<a name="ln1051">      // If the '0' and '-' flags both appear, the '0' flag should be</a>
<a name="ln1052">      // ignored.</a>
<a name="ln1053"> </a>
<a name="ln1054">      // parse field width</a>
<a name="ln1055">      if (*(arg = p) == '*') {</a>
<a name="ln1056">        p++;</a>
<a name="ln1057"> </a>
<a name="ln1058">        if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1059">          // Positional argument field width</a>
<a name="ln1060">          unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1061"> </a>
<a name="ln1062">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1063">            uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1064">          }</a>
<a name="ln1065"> </a>
<a name="ln1066">          if (*p != '$') {</a>
<a name="ln1067">            semsg(_(e_invalid_format_specifier_str), fmt);</a>
<a name="ln1068">            goto error;</a>
<a name="ln1069">          } else {</a>
<a name="ln1070">            p++;</a>
<a name="ln1071">            any_pos = 1;</a>
<a name="ln1072">            CHECK_POS_ARG;</a>
<a name="ln1073"> </a>
<a name="ln1074">            if (adjust_types(ap_types, (int)uj, num_posarg, arg) == FAIL) {</a>
<a name="ln1075">              goto error;</a>
<a name="ln1076">            }</a>
<a name="ln1077">          }</a>
<a name="ln1078">        } else {</a>
<a name="ln1079">          any_arg = 1;</a>
<a name="ln1080">          CHECK_POS_ARG;</a>
<a name="ln1081">        }</a>
<a name="ln1082">      } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1083">        // size_t could be wider than unsigned int; make sure we treat</a>
<a name="ln1084">        // argument like common implementations do</a>
<a name="ln1085">        unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1086"> </a>
<a name="ln1087">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1088">          uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1089">        }</a>
<a name="ln1090"> </a>
<a name="ln1091">        if (*p == '$') {</a>
<a name="ln1092">          semsg(_(e_invalid_format_specifier_str), fmt);</a>
<a name="ln1093">          goto error;</a>
<a name="ln1094">        }</a>
<a name="ln1095">      }</a>
<a name="ln1096"> </a>
<a name="ln1097">      // parse precision</a>
<a name="ln1098">      if (*p == '.') {</a>
<a name="ln1099">        p++;</a>
<a name="ln1100"> </a>
<a name="ln1101">        if (*(arg = p) == '*') {</a>
<a name="ln1102">          p++;</a>
<a name="ln1103"> </a>
<a name="ln1104">          if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1105">            // Parse precision</a>
<a name="ln1106">            unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1107"> </a>
<a name="ln1108">            while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1109">              uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1110">            }</a>
<a name="ln1111"> </a>
<a name="ln1112">            if (*p == '$') {</a>
<a name="ln1113">              any_pos = 1;</a>
<a name="ln1114">              CHECK_POS_ARG;</a>
<a name="ln1115"> </a>
<a name="ln1116">              p++;</a>
<a name="ln1117"> </a>
<a name="ln1118">              if (adjust_types(ap_types, (int)uj, num_posarg, arg) == FAIL) {</a>
<a name="ln1119">                goto error;</a>
<a name="ln1120">              }</a>
<a name="ln1121">            } else {</a>
<a name="ln1122">              semsg(_(e_invalid_format_specifier_str), fmt);</a>
<a name="ln1123">              goto error;</a>
<a name="ln1124">            }</a>
<a name="ln1125">          } else {</a>
<a name="ln1126">            any_arg = 1;</a>
<a name="ln1127">            CHECK_POS_ARG;</a>
<a name="ln1128">          }</a>
<a name="ln1129">        } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1130">          // size_t could be wider than unsigned int; make sure we</a>
<a name="ln1131">          // treat argument like common implementations do</a>
<a name="ln1132">          unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1133"> </a>
<a name="ln1134">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1135">            uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1136">          }</a>
<a name="ln1137"> </a>
<a name="ln1138">          if (*p == '$') {</a>
<a name="ln1139">            semsg(_(e_invalid_format_specifier_str), fmt);</a>
<a name="ln1140">            goto error;</a>
<a name="ln1141">          }</a>
<a name="ln1142">        }</a>
<a name="ln1143">      }</a>
<a name="ln1144"> </a>
<a name="ln1145">      if (pos_arg != -1) {</a>
<a name="ln1146">        any_pos = 1;</a>
<a name="ln1147">        CHECK_POS_ARG;</a>
<a name="ln1148"> </a>
<a name="ln1149">        ptype = p;</a>
<a name="ln1150">      }</a>
<a name="ln1151"> </a>
<a name="ln1152">      // parse 'h', 'l', 'll' and 'z' length modifiers</a>
<a name="ln1153">      if (*p == 'h' || *p == 'l' || *p == 'z') {</a>
<a name="ln1154">        length_modifier = *p;</a>
<a name="ln1155">        p++;</a>
<a name="ln1156">        if (length_modifier == 'l' &amp;&amp; *p == 'l') {</a>
<a name="ln1157">          // double l = long long</a>
<a name="ln1158">          // length_modifier = 'L';</a>
<a name="ln1159">          p++;</a>
<a name="ln1160">        }</a>
<a name="ln1161">      }</a>
<a name="ln1162"> </a>
<a name="ln1163">      switch (*p) {</a>
<a name="ln1164">      // Check for known format specifiers. % is special!</a>
<a name="ln1165">      case 'i':</a>
<a name="ln1166">      case '*':</a>
<a name="ln1167">      case 'd':</a>
<a name="ln1168">      case 'u':</a>
<a name="ln1169">      case 'o':</a>
<a name="ln1170">      case 'D':</a>
<a name="ln1171">      case 'U':</a>
<a name="ln1172">      case 'O':</a>
<a name="ln1173">      case 'x':</a>
<a name="ln1174">      case 'X':</a>
<a name="ln1175">      case 'b':</a>
<a name="ln1176">      case 'B':</a>
<a name="ln1177">      case 'c':</a>
<a name="ln1178">      case 's':</a>
<a name="ln1179">      case 'S':</a>
<a name="ln1180">      case 'p':</a>
<a name="ln1181">      case 'f':</a>
<a name="ln1182">      case 'F':</a>
<a name="ln1183">      case 'e':</a>
<a name="ln1184">      case 'E':</a>
<a name="ln1185">      case 'g':</a>
<a name="ln1186">      case 'G':</a>
<a name="ln1187">        if (pos_arg != -1) {</a>
<a name="ln1188">          if (adjust_types(ap_types, pos_arg, num_posarg, ptype) == FAIL) {</a>
<a name="ln1189">            goto error;</a>
<a name="ln1190">          }</a>
<a name="ln1191">        } else {</a>
<a name="ln1192">          any_arg = 1;</a>
<a name="ln1193">          CHECK_POS_ARG;</a>
<a name="ln1194">        }</a>
<a name="ln1195">        break;</a>
<a name="ln1196"> </a>
<a name="ln1197">      default:</a>
<a name="ln1198">        if (pos_arg != -1) {</a>
<a name="ln1199">          semsg(_(e_cannot_mix_positional_and_non_positional_str), fmt);</a>
<a name="ln1200">          goto error;</a>
<a name="ln1201">        }</a>
<a name="ln1202">      }</a>
<a name="ln1203"> </a>
<a name="ln1204">      if (*p != NUL) {</a>
<a name="ln1205">        p++;     // step over the just processed conversion specifier</a>
<a name="ln1206">      }</a>
<a name="ln1207">    }</a>
<a name="ln1208">  }</a>
<a name="ln1209"> </a>
<a name="ln1210">  for (int arg_idx = 0; arg_idx &lt; *num_posarg; arg_idx++) {</a>
<a name="ln1211">    if ((*ap_types)[arg_idx] == NULL) {</a>
<a name="ln1212">      semsg(_(e_fmt_arg_nr_unused_str), arg_idx + 1, fmt);</a>
<a name="ln1213">      goto error;</a>
<a name="ln1214">    }</a>
<a name="ln1215"> </a>
<a name="ln1216">    if (tvs != NULL &amp;&amp; tvs[arg_idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln1217">      semsg(_(e_positional_nr_out_of_bounds_str), arg_idx + 1, fmt);</a>
<a name="ln1218">      goto error;</a>
<a name="ln1219">    }</a>
<a name="ln1220">  }</a>
<a name="ln1221"> </a>
<a name="ln1222">  return OK;</a>
<a name="ln1223"> </a>
<a name="ln1224">error:</a>
<a name="ln1225">  xfree(*ap_types);</a>
<a name="ln1226">  *ap_types = NULL;</a>
<a name="ln1227">  *num_posarg = 0;</a>
<a name="ln1228">  return FAIL;</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231">static void skip_to_arg(const char **ap_types, va_list ap_start, va_list *ap, int *arg_idx,</a>
<a name="ln1232">                        int *arg_cur, const char *fmt)</a>
<a name="ln1233">  FUNC_ATTR_NONNULL_ARG(3, 4, 5)</a>
<a name="ln1234">{</a>
<a name="ln1235">  int arg_min = 0;</a>
<a name="ln1236"> </a>
<a name="ln1237">  if (*arg_cur + 1 == *arg_idx) {</a>
<a name="ln1238">    (*arg_cur)++;</a>
<a name="ln1239">    (*arg_idx)++;</a>
<a name="ln1240">    return;</a>
<a name="ln1241">  }</a>
<a name="ln1242"> </a>
<a name="ln1243">  if (*arg_cur &gt;= *arg_idx) {</a>
<a name="ln1244">    // Reset ap to ap_start and skip arg_idx - 1 types</a>
<a name="ln1245">    va_end(*ap);</a>
<a name="ln1246">    va_copy(*ap, ap_start);</a>
<a name="ln1247">  } else {</a>
<a name="ln1248">    // Skip over any we should skip</a>
<a name="ln1249">    arg_min = *arg_cur;</a>
<a name="ln1250">  }</a>
<a name="ln1251"> </a>
<a name="ln1252">  for (*arg_cur = arg_min; *arg_cur &lt; *arg_idx - 1; (*arg_cur)++) {</a>
<a name="ln1253">    if (ap_types == NULL || ap_types[*arg_cur] == NULL) {</a>
<a name="ln1254">      siemsg(e_aptypes_is_null_nr_str, fmt, *arg_cur);</a>
<a name="ln1255">      return;</a>
<a name="ln1256">    }</a>
<a name="ln1257"> </a>
<a name="ln1258">    const char *p = ap_types[*arg_cur];</a>
<a name="ln1259"> </a>
<a name="ln1260">    int fmt_type = format_typeof(p);</a>
<a name="ln1261"> </a>
<a name="ln1262">    // get parameter value, do initial processing</a>
<a name="ln1263">    switch (fmt_type) {</a>
<a name="ln1264">    case TYPE_PERCENT:</a>
<a name="ln1265">    case TYPE_UNKNOWN:</a>
<a name="ln1266">      break;</a>
<a name="ln1267"> </a>
<a name="ln1268">    case TYPE_CHAR:</a>
<a name="ln1269">      va_arg(*ap, int);</a>
<a name="ln1270">      break;</a>
<a name="ln1271"> </a>
<a name="ln1272">    case TYPE_STRING:</a>
<a name="ln1273">      va_arg(*ap, const char *);</a>
<a name="ln1274">      break;</a>
<a name="ln1275"> </a>
<a name="ln1276">    case TYPE_POINTER:</a>
<a name="ln1277">      va_arg(*ap, void *);</a>
<a name="ln1278">      break;</a>
<a name="ln1279"> </a>
<a name="ln1280">    case TYPE_INT:</a>
<a name="ln1281">      va_arg(*ap, int);</a>
<a name="ln1282">      break;</a>
<a name="ln1283"> </a>
<a name="ln1284">    case TYPE_LONGINT:</a>
<a name="ln1285">      va_arg(*ap, long);</a>
<a name="ln1286">      break;</a>
<a name="ln1287"> </a>
<a name="ln1288">    case TYPE_LONGLONGINT:</a>
<a name="ln1289">      va_arg(*ap, long long);  // NOLINT(runtime/int)</a>
<a name="ln1290">      break;</a>
<a name="ln1291"> </a>
<a name="ln1292">    case TYPE_SIGNEDSIZET:  // implementation-defined, usually ptrdiff_t</a>
<a name="ln1293">      va_arg(*ap, ptrdiff_t);</a>
<a name="ln1294">      break;</a>
<a name="ln1295"> </a>
<a name="ln1296">    case TYPE_UNSIGNEDINT:</a>
<a name="ln1297">      va_arg(*ap, unsigned);</a>
<a name="ln1298">      break;</a>
<a name="ln1299"> </a>
<a name="ln1300">    case TYPE_UNSIGNEDLONGINT:</a>
<a name="ln1301">      va_arg(*ap, unsigned long);</a>
<a name="ln1302">      break;</a>
<a name="ln1303"> </a>
<a name="ln1304">    case TYPE_UNSIGNEDLONGLONGINT:</a>
<a name="ln1305">      va_arg(*ap, unsigned long long);  // NOLINT(runtime/int)</a>
<a name="ln1306">      break;</a>
<a name="ln1307"> </a>
<a name="ln1308">    case TYPE_SIZET:</a>
<a name="ln1309">      va_arg(*ap, size_t);</a>
<a name="ln1310">      break;</a>
<a name="ln1311"> </a>
<a name="ln1312">    case TYPE_FLOAT:</a>
<a name="ln1313">      va_arg(*ap, double);</a>
<a name="ln1314">      break;</a>
<a name="ln1315">    }</a>
<a name="ln1316">  }</a>
<a name="ln1317"> </a>
<a name="ln1318">  // Because we know that after we return from this call,</a>
<a name="ln1319">  // a va_arg() call is made, we can pre-emptively</a>
<a name="ln1320">  // increment the current argument index.</a>
<a name="ln1321">  (*arg_cur)++;</a>
<a name="ln1322">  (*arg_idx)++;</a>
<a name="ln1323">}</a>
<a name="ln1324"> </a>
<a name="ln1325">/// Write formatted value to the string</a>
<a name="ln1326">///</a>
<a name="ln1327">/// @param[out]  str  String to write to.</a>
<a name="ln1328">/// @param[in]  str_m  String length.</a>
<a name="ln1329">/// @param[in]  fmt  String format.</a>
<a name="ln1330">/// @param[in]  ap  Values that should be formatted. Ignored if tvs is not NULL.</a>
<a name="ln1331">/// @param[in]  tvs  Values that should be formatted, for printf() Vimscript</a>
<a name="ln1332">///                  function. Must be NULL in other cases.</a>
<a name="ln1333">///</a>
<a name="ln1334">/// @return Number of bytes excluding NUL byte that would be written to the</a>
<a name="ln1335">///         string if str_m was greater or equal to the return value.</a>
<a name="ln1336">int vim_vsnprintf_typval(char *str, size_t str_m, const char *fmt, va_list ap_start,</a>
<a name="ln1337">                         typval_T *const tvs)</a>
<a name="ln1338">{</a>
<a name="ln1339">  size_t str_l = 0;</a>
<a name="ln1340">  bool str_avail = str_l &lt; str_m;</a>
<a name="ln1341">  const char *p = fmt;</a>
<a name="ln1342">  int arg_cur = 0;</a>
<a name="ln1343">  int num_posarg = 0;</a>
<a name="ln1344">  int arg_idx = 1;</a>
<a name="ln1345">  va_list ap;</a>
<a name="ln1346">  const char **ap_types = NULL;</a>
<a name="ln1347"> </a>
<a name="ln1348">  if (parse_fmt_types(&amp;ap_types, &amp;num_posarg, fmt, tvs) == FAIL) {</a>
<a name="ln1349">    return 0;</a>
<a name="ln1350">  }</a>
<a name="ln1351"> </a>
<a name="ln1352">  va_copy(ap, ap_start);</a>
<a name="ln1353"> </a>
<a name="ln1354">  if (!p) {</a>
<a name="ln1355">    p = &quot;&quot;;</a>
<a name="ln1356">  }</a>
<a name="ln1357">  while (*p) {</a>
<a name="ln1358">    if (*p != '%') {</a>
<a name="ln1359">      // copy up to the next '%' or NUL without any changes</a>
<a name="ln1360">      size_t n = (size_t)(xstrchrnul(p + 1, '%') - p);</a>
<a name="ln1361">      if (str_avail) {</a>
<a name="ln1362">        size_t avail = str_m - str_l;</a>
<a name="ln1363">        memmove(str + str_l, p, MIN(n, avail));</a>
<a name="ln1364">        str_avail = n &lt; avail;</a>
<a name="ln1365">      }</a>
<a name="ln1366">      p += n;</a>
<a name="ln1367">      assert(n &lt;= SIZE_MAX - str_l);</a>
<a name="ln1368">      str_l += n;</a>
<a name="ln1369">    } else {</a>
<a name="ln1370">      size_t min_field_width = 0, precision = 0;</a>
<a name="ln1371">      int zero_padding = 0, precision_specified = 0, justify_left = 0;</a>
<a name="ln1372">      int alternate_form = 0, force_sign = 0;</a>
<a name="ln1373"> </a>
<a name="ln1374">      // if both ' ' and '+' flags appear, ' ' flag should be ignored</a>
<a name="ln1375">      int space_for_positive = 1;</a>
<a name="ln1376"> </a>
<a name="ln1377">      // allowed values: \0, h, l, 2 (for ll), z, L</a>
<a name="ln1378">      char length_modifier = '\0';</a>
<a name="ln1379"> </a>
<a name="ln1380">      // temporary buffer for simple numeric-&gt;string conversion</a>
<a name="ln1381">#define TMP_LEN 350    // 1e308 seems reasonable as the maximum printable</a>
<a name="ln1382">      char tmp[TMP_LEN];</a>
<a name="ln1383"> </a>
<a name="ln1384">      // string address in case of string argument</a>
<a name="ln1385">      const char *str_arg = NULL;</a>
<a name="ln1386"> </a>
<a name="ln1387">      // natural field width of arg without padding and sign</a>
<a name="ln1388">      size_t str_arg_l;</a>
<a name="ln1389"> </a>
<a name="ln1390">      // unsigned char argument value (only defined for c conversion);</a>
<a name="ln1391">      // standard explicitly states the char argument for the c</a>
<a name="ln1392">      // conversion is unsigned</a>
<a name="ln1393">      unsigned char uchar_arg;</a>
<a name="ln1394"> </a>
<a name="ln1395">      // number of zeros to be inserted for numeric conversions as</a>
<a name="ln1396">      // required by the precision or minimal field width</a>
<a name="ln1397">      size_t number_of_zeros_to_pad = 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">      // index into tmp where zero padding is to be inserted</a>
<a name="ln1400">      size_t zero_padding_insertion_ind = 0;</a>
<a name="ln1401"> </a>
<a name="ln1402">      // current conversion specifier character</a>
<a name="ln1403">      char fmt_spec = '\0';</a>
<a name="ln1404"> </a>
<a name="ln1405">      // buffer for 's' and 'S' specs</a>
<a name="ln1406">      char *tofree = NULL;</a>
<a name="ln1407"> </a>
<a name="ln1408">      // variable for positional arg</a>
<a name="ln1409">      int pos_arg = -1;</a>
<a name="ln1410"> </a>
<a name="ln1411">      p++;  // skip '%'</a>
<a name="ln1412"> </a>
<a name="ln1413">      // First check to see if we find a positional</a>
<a name="ln1414">      // argument specifier</a>
<a name="ln1415">      const char *ptype = p;</a>
<a name="ln1416"> </a>
<a name="ln1417">      while (ascii_isdigit(*ptype)) {</a>
<a name="ln1418">        ptype++;</a>
<a name="ln1419">      }</a>
<a name="ln1420"> </a>
<a name="ln1421">      if (*ptype == '$') {</a>
<a name="ln1422">        // Positional argument</a>
<a name="ln1423">        unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1424"> </a>
<a name="ln1425">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1426">          uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1427">        }</a>
<a name="ln1428">        pos_arg = (int)uj;</a>
<a name="ln1429"> </a>
<a name="ln1430">        p++;</a>
<a name="ln1431">      }</a>
<a name="ln1432"> </a>
<a name="ln1433">      // parse flags</a>
<a name="ln1434">      while (true) {</a>
<a name="ln1435">        switch (*p) {</a>
<a name="ln1436">        case '0':</a>
<a name="ln1437">          zero_padding = 1; p++; continue;</a>
<a name="ln1438">        case '-':</a>
<a name="ln1439">          justify_left = 1; p++; continue;</a>
<a name="ln1440">        // if both '0' and '-' flags appear, '0' should be ignored</a>
<a name="ln1441">        case '+':</a>
<a name="ln1442">          force_sign = 1; space_for_positive = 0; p++; continue;</a>
<a name="ln1443">        case ' ':</a>
<a name="ln1444">          force_sign = 1; p++; continue;</a>
<a name="ln1445">        // if both ' ' and '+' flags appear, ' ' should be ignored</a>
<a name="ln1446">        case '#':</a>
<a name="ln1447">          alternate_form = 1; p++; continue;</a>
<a name="ln1448">        case '\'':</a>
<a name="ln1449">          p++; continue;</a>
<a name="ln1450">        default:</a>
<a name="ln1451">          break;</a>
<a name="ln1452">        }</a>
<a name="ln1453">        break;</a>
<a name="ln1454">      }</a>
<a name="ln1455"> </a>
<a name="ln1456">      // parse field width</a>
<a name="ln1457">      if (*p == '*') {</a>
<a name="ln1458">        p++;</a>
<a name="ln1459"> </a>
<a name="ln1460">        if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1461">          // Positional argument field width</a>
<a name="ln1462">          unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1463"> </a>
<a name="ln1464">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1465">            uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1466">          }</a>
<a name="ln1467">          arg_idx = (int)uj;</a>
<a name="ln1468"> </a>
<a name="ln1469">          p++;</a>
<a name="ln1470">        }</a>
<a name="ln1471"> </a>
<a name="ln1472">        const int j = (tvs</a>
<a name="ln1473">                       ? (int)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1474">                       : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1475">                                      &amp;arg_cur, fmt),</a>
<a name="ln1476">                          va_arg(ap, int)));</a>
<a name="ln1477"> </a>
<a name="ln1478">        if (j &gt;= 0) {</a>
<a name="ln1479">          min_field_width = (size_t)j;</a>
<a name="ln1480">        } else {</a>
<a name="ln1481">          min_field_width = (size_t)-j;</a>
<a name="ln1482">          justify_left = 1;</a>
<a name="ln1483">        }</a>
<a name="ln1484">      } else if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1485">        // size_t could be wider than unsigned int; make sure we treat</a>
<a name="ln1486">        // argument like common implementations do</a>
<a name="ln1487">        unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1488"> </a>
<a name="ln1489">        while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1490">          uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1491">        }</a>
<a name="ln1492">        min_field_width = uj;</a>
<a name="ln1493">      }</a>
<a name="ln1494"> </a>
<a name="ln1495">      // parse precision</a>
<a name="ln1496">      if (*p == '.') {</a>
<a name="ln1497">        p++;</a>
<a name="ln1498">        precision_specified = 1;</a>
<a name="ln1499"> </a>
<a name="ln1500">        if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1501">          // size_t could be wider than unsigned int; make sure we</a>
<a name="ln1502">          // treat argument like common implementations do</a>
<a name="ln1503">          unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1504"> </a>
<a name="ln1505">          while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1506">            uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1507">          }</a>
<a name="ln1508">          precision = uj;</a>
<a name="ln1509">        } else if (*p == '*') {</a>
<a name="ln1510">          p++;</a>
<a name="ln1511"> </a>
<a name="ln1512">          if (ascii_isdigit((int)(*p))) {</a>
<a name="ln1513">            // positional argument</a>
<a name="ln1514">            unsigned uj = (unsigned)(*p++ - '0');</a>
<a name="ln1515"> </a>
<a name="ln1516">            while (ascii_isdigit((int)(*p))) {</a>
<a name="ln1517">              uj = 10 * uj + (unsigned)(*p++ - '0');</a>
<a name="ln1518">            }</a>
<a name="ln1519">            arg_idx = (int)uj;</a>
<a name="ln1520"> </a>
<a name="ln1521">            p++;</a>
<a name="ln1522">          }</a>
<a name="ln1523"> </a>
<a name="ln1524">          const int j = (tvs</a>
<a name="ln1525">                         ? (int)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1526">                         : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1527">                                        &amp;arg_cur, fmt),</a>
<a name="ln1528">                            va_arg(ap, int)));</a>
<a name="ln1529"> </a>
<a name="ln1530">          if (j &gt;= 0) {</a>
<a name="ln1531">            precision = (size_t)j;</a>
<a name="ln1532">          } else {</a>
<a name="ln1533">            precision_specified = 0;</a>
<a name="ln1534">            precision = 0;</a>
<a name="ln1535">          }</a>
<a name="ln1536">        }</a>
<a name="ln1537">      }</a>
<a name="ln1538"> </a>
<a name="ln1539">      // parse 'h', 'l', 'll' and 'z' length modifiers</a>
<a name="ln1540">      if (*p == 'h' || *p == 'l' || *p == 'z') {</a>
<a name="ln1541">        length_modifier = *p;</a>
<a name="ln1542">        p++;</a>
<a name="ln1543">        if (length_modifier == 'l' &amp;&amp; *p == 'l') {</a>
<a name="ln1544">          // double l = long long</a>
<a name="ln1545">          length_modifier = 'L';</a>
<a name="ln1546">          p++;</a>
<a name="ln1547">        }</a>
<a name="ln1548">      }</a>
<a name="ln1549"> </a>
<a name="ln1550">      fmt_spec = *p;</a>
<a name="ln1551"> </a>
<a name="ln1552">      // common synonyms</a>
<a name="ln1553">      switch (fmt_spec) {</a>
<a name="ln1554">      case 'i':</a>
<a name="ln1555">        fmt_spec = 'd'; break;</a>
<a name="ln1556">      case 'D':</a>
<a name="ln1557">        fmt_spec = 'd'; length_modifier = 'l'; break;</a>
<a name="ln1558">      case 'U':</a>
<a name="ln1559">        fmt_spec = 'u'; length_modifier = 'l'; break;</a>
<a name="ln1560">      case 'O':</a>
<a name="ln1561">        fmt_spec = 'o'; length_modifier = 'l'; break;</a>
<a name="ln1562">      default:</a>
<a name="ln1563">        break;</a>
<a name="ln1564">      }</a>
<a name="ln1565"> </a>
<a name="ln1566">      switch (fmt_spec) {</a>
<a name="ln1567">      case 'b':</a>
<a name="ln1568">      case 'B':</a>
<a name="ln1569">      case 'd':</a>
<a name="ln1570">      case 'u':</a>
<a name="ln1571">      case 'o':</a>
<a name="ln1572">      case 'x':</a>
<a name="ln1573">      case 'X':</a>
<a name="ln1574">        if (tvs &amp;&amp; length_modifier == '\0') {</a>
<a name="ln1575">          length_modifier = 'L';</a>
<a name="ln1576">        }</a>
<a name="ln1577">      }</a>
<a name="ln1578"> </a>
<a name="ln1579">      if (pos_arg != -1) {</a>
<a name="ln1580">        arg_idx = pos_arg;</a>
<a name="ln1581">      }</a>
<a name="ln1582"> </a>
<a name="ln1583">      // get parameter value, do initial processing</a>
<a name="ln1584">      switch (fmt_spec) {</a>
<a name="ln1585">      // '%' and 'c' behave similar to 's' regarding flags and field widths</a>
<a name="ln1586">      case '%':</a>
<a name="ln1587">      case 'c':</a>
<a name="ln1588">      case 's':</a>
<a name="ln1589">      case 'S':</a>
<a name="ln1590">        str_arg_l = 1;</a>
<a name="ln1591">        switch (fmt_spec) {</a>
<a name="ln1592">        case '%':</a>
<a name="ln1593">          str_arg = p;</a>
<a name="ln1594">          break;</a>
<a name="ln1595"> </a>
<a name="ln1596">        case 'c': {</a>
<a name="ln1597">          const int j = (tvs</a>
<a name="ln1598">                         ? (int)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1599">                         : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1600">                                        &amp;arg_cur, fmt),</a>
<a name="ln1601">                            va_arg(ap, int)));</a>
<a name="ln1602"> </a>
<a name="ln1603">          // standard demands unsigned char</a>
<a name="ln1604">          uchar_arg = (unsigned char)j;</a>
<a name="ln1605">          str_arg = (char *)&amp;uchar_arg;</a>
<a name="ln1606">          break;</a>
<a name="ln1607">        }</a>
<a name="ln1608"> </a>
<a name="ln1609">        case 's':</a>
<a name="ln1610">        case 'S':</a>
<a name="ln1611">          str_arg = (tvs</a>
<a name="ln1612">                     ? tv_str(tvs, &amp;arg_idx, &amp;tofree)</a>
<a name="ln1613">                     : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1614">                                    &amp;arg_cur, fmt),</a>
<a name="ln1615">                        va_arg(ap, const char *)));</a>
<a name="ln1616"> </a>
<a name="ln1617">          if (!str_arg) {</a>
<a name="ln1618">            str_arg = &quot;[NULL]&quot;;</a>
<a name="ln1619">            str_arg_l = 6;</a>
<a name="ln1620">          } else if (!precision_specified) {</a>
<a name="ln1621">            // make sure not to address string beyond the specified</a>
<a name="ln1622">            // precision</a>
<a name="ln1623">            str_arg_l = strlen(str_arg);</a>
<a name="ln1624">          } else if (precision == 0) {</a>
<a name="ln1625">            // truncate string if necessary as requested by precision</a>
<a name="ln1626">            str_arg_l = 0;</a>
<a name="ln1627">          } else {</a>
<a name="ln1628">            // memchr on HP does not like n &gt; 2^31</a>
<a name="ln1629">            // TODO(elmart): check if this still holds / is relevant</a>
<a name="ln1630">            str_arg_l = (size_t)((char *)xmemscan(str_arg,</a>
<a name="ln1631">                                                  NUL,</a>
<a name="ln1632">                                                  MIN(precision,</a>
<a name="ln1633">                                                      0x7fffffff))</a>
<a name="ln1634">                                 - str_arg);</a>
<a name="ln1635">          }</a>
<a name="ln1636">          if (fmt_spec == 'S') {</a>
<a name="ln1637">            const char *p1;</a>
<a name="ln1638">            size_t i;</a>
<a name="ln1639"> </a>
<a name="ln1640">            for (i = 0, p1 = str_arg; *p1; p1 += utfc_ptr2len(p1)) {</a>
<a name="ln1641">              size_t cell = (size_t)utf_ptr2cells(p1);</a>
<a name="ln1642">              if (precision_specified &amp;&amp; i + cell &gt; precision) {</a>
<a name="ln1643">                break;</a>
<a name="ln1644">              }</a>
<a name="ln1645">              i += cell;</a>
<a name="ln1646">            }</a>
<a name="ln1647"> </a>
<a name="ln1648">            str_arg_l = (size_t)(p1 - str_arg);</a>
<a name="ln1649">            if (min_field_width != 0) {</a>
<a name="ln1650">              min_field_width += str_arg_l - i;</a>
<a name="ln1651">            }</a>
<a name="ln1652">          }</a>
<a name="ln1653">          break;</a>
<a name="ln1654"> </a>
<a name="ln1655">        default:</a>
<a name="ln1656">          break;</a>
<a name="ln1657">        }</a>
<a name="ln1658">        break;</a>
<a name="ln1659"> </a>
<a name="ln1660">      case 'd':</a>
<a name="ln1661">      case 'u':</a>
<a name="ln1662">      case 'b':</a>
<a name="ln1663">      case 'B':</a>
<a name="ln1664">      case 'o':</a>
<a name="ln1665">      case 'x':</a>
<a name="ln1666">      case 'X':</a>
<a name="ln1667">      case 'p': {</a>
<a name="ln1668">        // u, b, B, o, x, X and p conversion specifiers imply</a>
<a name="ln1669">        // the value is unsigned; d implies a signed value</a>
<a name="ln1670"> </a>
<a name="ln1671">        // 0 if numeric argument is zero (or if pointer is NULL for 'p'),</a>
<a name="ln1672">        // +1 if greater than zero (or non NULL for 'p'),</a>
<a name="ln1673">        // -1 if negative (unsigned argument is never negative)</a>
<a name="ln1674">        int arg_sign = 0;</a>
<a name="ln1675"> </a>
<a name="ln1676">        intmax_t arg = 0;</a>
<a name="ln1677">        uintmax_t uarg = 0;</a>
<a name="ln1678"> </a>
<a name="ln1679">        // only defined for p conversion</a>
<a name="ln1680">        const void *ptr_arg = NULL;</a>
<a name="ln1681"> </a>
<a name="ln1682">        if (fmt_spec == 'p') {</a>
<a name="ln1683">          ptr_arg = (tvs</a>
<a name="ln1684">                     ? tv_ptr(tvs, &amp;arg_idx)</a>
<a name="ln1685">                     : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1686">                                    &amp;arg_cur, fmt),</a>
<a name="ln1687">                        va_arg(ap, void *)));</a>
<a name="ln1688"> </a>
<a name="ln1689">          if (ptr_arg) {</a>
<a name="ln1690">            arg_sign = 1;</a>
<a name="ln1691">          }</a>
<a name="ln1692">        } else if (fmt_spec == 'd') {</a>
<a name="ln1693">          // signed</a>
<a name="ln1694">          switch (length_modifier) {</a>
<a name="ln1695">          case '\0':</a>
<a name="ln1696">            arg = (tvs</a>
<a name="ln1697">                   ? (int)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1698">                   : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1699">                                  &amp;arg_cur, fmt),</a>
<a name="ln1700">                      va_arg(ap, int)));</a>
<a name="ln1701">            break;</a>
<a name="ln1702">          case 'h':</a>
<a name="ln1703">            // char and short arguments are passed as int16_t</a>
<a name="ln1704">            arg = (int16_t)</a>
<a name="ln1705">                  (tvs</a>
<a name="ln1706">                   ? (int)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1707">                   : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1708">                                  &amp;arg_cur, fmt),</a>
<a name="ln1709">                      va_arg(ap, int)));</a>
<a name="ln1710">            break;</a>
<a name="ln1711">          case 'l':</a>
<a name="ln1712">            arg = (tvs</a>
<a name="ln1713">                   ? (long)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1714">                   : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1715">                                  &amp;arg_cur, fmt),</a>
<a name="ln1716">                      va_arg(ap, long)));</a>
<a name="ln1717">            break;</a>
<a name="ln1718">          case 'L':</a>
<a name="ln1719">            arg = (tvs</a>
<a name="ln1720">                   ? (long long)tv_nr(tvs, &amp;arg_idx)  // NOLINT(runtime/int)</a>
<a name="ln1721">                   : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1722">                                  &amp;arg_cur, fmt),</a>
<a name="ln1723">                      va_arg(ap, long long)));  // NOLINT(runtime/int)</a>
<a name="ln1724">            break;</a>
<a name="ln1725">          case 'z':  // implementation-defined, usually ptrdiff_t</a>
<a name="ln1726">            arg = (tvs</a>
<a name="ln1727">                   ? (ptrdiff_t)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1728">                   : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1729">                                  &amp;arg_cur, fmt),</a>
<a name="ln1730">                      va_arg(ap, ptrdiff_t)));</a>
<a name="ln1731">            break;</a>
<a name="ln1732">          }</a>
<a name="ln1733">          if (arg &gt; 0) {</a>
<a name="ln1734">            arg_sign = 1;</a>
<a name="ln1735">          } else if (arg &lt; 0) {</a>
<a name="ln1736">            arg_sign = -1;</a>
<a name="ln1737">          }</a>
<a name="ln1738">        } else {</a>
<a name="ln1739">          // unsigned</a>
<a name="ln1740">          switch (length_modifier) {</a>
<a name="ln1741">          case '\0':</a>
<a name="ln1742">            uarg = (tvs</a>
<a name="ln1743">                    ? (unsigned)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1744">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1745">                                   &amp;arg_cur, fmt),</a>
<a name="ln1746">                       va_arg(ap, unsigned)));</a>
<a name="ln1747">            break;</a>
<a name="ln1748">          case 'h':</a>
<a name="ln1749">            uarg = (uint16_t)</a>
<a name="ln1750">                   (tvs</a>
<a name="ln1751">                    ? (unsigned)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1752">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1753">                                   &amp;arg_cur, fmt),</a>
<a name="ln1754">                       va_arg(ap, unsigned)));</a>
<a name="ln1755">            break;</a>
<a name="ln1756">          case 'l':</a>
<a name="ln1757">            uarg = (tvs</a>
<a name="ln1758">                    ? (unsigned long)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1759">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1760">                                   &amp;arg_cur, fmt),</a>
<a name="ln1761">                       va_arg(ap, unsigned long)));</a>
<a name="ln1762">            break;</a>
<a name="ln1763">          case 'L':</a>
<a name="ln1764">            uarg = (tvs</a>
<a name="ln1765">                    ? (unsigned long long)tv_nr(tvs, &amp;arg_idx)  // NOLINT(runtime/int)</a>
<a name="ln1766">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1767">                                   &amp;arg_cur, fmt),</a>
<a name="ln1768">                       va_arg(ap, unsigned long long)));  // NOLINT(runtime/int)</a>
<a name="ln1769">            break;</a>
<a name="ln1770">          case 'z':</a>
<a name="ln1771">            uarg = (tvs</a>
<a name="ln1772">                    ? (size_t)tv_nr(tvs, &amp;arg_idx)</a>
<a name="ln1773">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1774">                                   &amp;arg_cur, fmt),</a>
<a name="ln1775">                       va_arg(ap, size_t)));</a>
<a name="ln1776">            break;</a>
<a name="ln1777">          }</a>
<a name="ln1778">          arg_sign = (uarg != 0);</a>
<a name="ln1779">        }</a>
<a name="ln1780"> </a>
<a name="ln1781">        str_arg = tmp;</a>
<a name="ln1782">        str_arg_l = 0;</a>
<a name="ln1783"> </a>
<a name="ln1784">        // For d, i, u, o, x, and X conversions, if precision is specified,</a>
<a name="ln1785">        // '0' flag should be ignored. This is so with Solaris 2.6, Digital</a>
<a name="ln1786">        // UNIX 4.0, HPUX 10, Linux, FreeBSD, NetBSD; but not with Perl.</a>
<a name="ln1787">        if (precision_specified) {</a>
<a name="ln1788">          zero_padding = 0;</a>
<a name="ln1789">        }</a>
<a name="ln1790"> </a>
<a name="ln1791">        if (fmt_spec == 'd') {</a>
<a name="ln1792">          if (force_sign &amp;&amp; arg_sign &gt;= 0) {</a>
<a name="ln1793">            tmp[str_arg_l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1794">          }</a>
<a name="ln1795">          // leave negative numbers for snprintf to handle, to</a>
<a name="ln1796">          // avoid handling tricky cases like (short int)-32768</a>
<a name="ln1797">        } else if (alternate_form) {</a>
<a name="ln1798">          if (arg_sign != 0 &amp;&amp; (fmt_spec == 'x' || fmt_spec == 'X'</a>
<a name="ln1799">                                || fmt_spec == 'b' || fmt_spec == 'B')) {</a>
<a name="ln1800">            tmp[str_arg_l++] = '0';</a>
<a name="ln1801">            tmp[str_arg_l++] = fmt_spec;</a>
<a name="ln1802">          }</a>
<a name="ln1803">          // alternate form should have no effect for p * conversion, but ...</a>
<a name="ln1804">        }</a>
<a name="ln1805"> </a>
<a name="ln1806">        zero_padding_insertion_ind = str_arg_l;</a>
<a name="ln1807">        if (!precision_specified) {</a>
<a name="ln1808">          precision = 1;  // default precision is 1</a>
<a name="ln1809">        }</a>
<a name="ln1810">        if (precision == 0 &amp;&amp; arg_sign == 0) {</a>
<a name="ln1811">          // when zero value is formatted with an explicit precision 0,</a>
<a name="ln1812">          // resulting formatted string is empty (d, i, u, b, B, o, x, X, p)</a>
<a name="ln1813">        } else {</a>
<a name="ln1814">          switch (fmt_spec) {</a>
<a name="ln1815">          case 'p':    // pointer</a>
<a name="ln1816">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1817">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1818">                                          &quot;%p&quot;, ptr_arg);</a>
<a name="ln1819">            break;</a>
<a name="ln1820">          case 'd':    // signed</a>
<a name="ln1821">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1822">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1823">                                          &quot;%&quot; PRIdMAX, arg);</a>
<a name="ln1824">            break;</a>
<a name="ln1825">          case 'b':</a>
<a name="ln1826">          case 'B': {  // binary</a>
<a name="ln1827">            size_t bits = 0;</a>
<a name="ln1828">            for (bits = sizeof(uintmax_t) * 8; bits &gt; 0; bits--) {</a>
<a name="ln1829">              if ((uarg &gt;&gt; (bits - 1)) &amp; 0x1) {</a>
<a name="ln1830">                break;</a>
<a name="ln1831">              }</a>
<a name="ln1832">            }</a>
<a name="ln1833"> </a>
<a name="ln1834">            while (bits &gt; 0) {</a>
<a name="ln1835">              tmp[str_arg_l++] = ((uarg &gt;&gt; --bits) &amp; 0x1) ? '1' : '0';</a>
<a name="ln1836">            }</a>
<a name="ln1837">            break;</a>
<a name="ln1838">          }</a>
<a name="ln1839">          default: {  // unsigned</a>
<a name="ln1840">            // construct a simple format string for snprintf</a>
<a name="ln1841">            char f[] = &quot;%&quot; PRIuMAX;</a>
<a name="ln1842">            f[sizeof(&quot;%&quot; PRIuMAX) - 1 - 1] = fmt_spec;</a>
<a name="ln1843">            assert(PRIuMAX[sizeof(PRIuMAX) - 1 - 1] == 'u');</a>
<a name="ln1844">            str_arg_l += (size_t)snprintf(tmp + str_arg_l,</a>
<a name="ln1845">                                          sizeof(tmp) - str_arg_l,</a>
<a name="ln1846">                                          f, uarg);</a>
<a name="ln1847">            break;</a>
<a name="ln1848">          }</a>
<a name="ln1849">          }</a>
<a name="ln1850">          assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1851"> </a>
<a name="ln1852">          // include the optional minus sign and possible &quot;0x&quot; in the region</a>
<a name="ln1853">          // before the zero padding insertion point</a>
<a name="ln1854">          if (zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1855">              &amp;&amp; tmp[zero_padding_insertion_ind] == '-') {</a>
<a name="ln1856">            zero_padding_insertion_ind++;</a>
<a name="ln1857">          }</a>
<a name="ln1858">          if (zero_padding_insertion_ind + 1 &lt; str_arg_l</a>
<a name="ln1859">              &amp;&amp; tmp[zero_padding_insertion_ind] == '0'</a>
<a name="ln1860">              &amp;&amp; (tmp[zero_padding_insertion_ind + 1] == 'x'</a>
<a name="ln1861">                  || tmp[zero_padding_insertion_ind + 1] == 'X'</a>
<a name="ln1862">                  || tmp[zero_padding_insertion_ind + 1] == 'b'</a>
<a name="ln1863">                  || tmp[zero_padding_insertion_ind + 1] == 'B')) {</a>
<a name="ln1864">            zero_padding_insertion_ind += 2;</a>
<a name="ln1865">          }</a>
<a name="ln1866">        }</a>
<a name="ln1867"> </a>
<a name="ln1868">        {</a>
<a name="ln1869">          size_t num_of_digits = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln1870"> </a>
<a name="ln1871">          if (alternate_form &amp;&amp; fmt_spec == 'o'</a>
<a name="ln1872">              // unless zero is already the first character</a>
<a name="ln1873">              &amp;&amp; !(zero_padding_insertion_ind &lt; str_arg_l</a>
<a name="ln1874">                   &amp;&amp; tmp[zero_padding_insertion_ind] == '0')) {</a>
<a name="ln1875">            // assure leading zero for alternate-form octal numbers</a>
<a name="ln1876">            if (!precision_specified</a>
<a name="ln1877">                || precision &lt; num_of_digits + 1) {</a>
<a name="ln1878">              // precision is increased to force the first character to be</a>
<a name="ln1879">              // zero, except if a zero value is formatted with an explicit</a>
<a name="ln1880">              // precision of zero</a>
<a name="ln1881">              precision = num_of_digits + 1;</a>
<a name="ln1882">            }</a>
<a name="ln1883">          }</a>
<a name="ln1884">          // zero padding to specified precision?</a>
<a name="ln1885">          if (num_of_digits &lt; precision) {</a>
<a name="ln1886">            number_of_zeros_to_pad = precision - num_of_digits;</a>
<a name="ln1887">          }</a>
<a name="ln1888">        }</a>
<a name="ln1889">        // zero padding to specified minimal field width?</a>
<a name="ln1890">        if (!justify_left &amp;&amp; zero_padding) {</a>
<a name="ln1891">          const int n = (int)(min_field_width - (str_arg_l</a>
<a name="ln1892">                                                 + number_of_zeros_to_pad));</a>
<a name="ln1893">          if (n &gt; 0) {</a>
<a name="ln1894">            number_of_zeros_to_pad += (size_t)n;</a>
<a name="ln1895">          }</a>
<a name="ln1896">        }</a>
<a name="ln1897">        break;</a>
<a name="ln1898">      }</a>
<a name="ln1899"> </a>
<a name="ln1900">      case 'f':</a>
<a name="ln1901">      case 'F':</a>
<a name="ln1902">      case 'e':</a>
<a name="ln1903">      case 'E':</a>
<a name="ln1904">      case 'g':</a>
<a name="ln1905">      case 'G': {</a>
<a name="ln1906">        // floating point</a>
<a name="ln1907">        char format[40];</a>
<a name="ln1908">        int remove_trailing_zeroes = false;</a>
<a name="ln1909"> </a>
<a name="ln1910">        double f = (tvs</a>
<a name="ln1911">                    ? tv_float(tvs, &amp;arg_idx)</a>
<a name="ln1912">                    : (skip_to_arg(ap_types, ap_start, &amp;ap, &amp;arg_idx,</a>
<a name="ln1913">                                   &amp;arg_cur, fmt),</a>
<a name="ln1914">                       va_arg(ap, double)));</a>
<a name="ln1915"> </a>
<a name="ln1916">        double abs_f = f &lt; 0 ? -f : f;</a>
<a name="ln1917"> </a>
<a name="ln1918">        if (fmt_spec == 'g' || fmt_spec == 'G') {</a>
<a name="ln1919">          // can't use %g directly, cause it prints &quot;1.0&quot; as &quot;1&quot;</a>
<a name="ln1920">          if ((abs_f &gt;= 0.001 &amp;&amp; abs_f &lt; 10000000.0) || abs_f == 0.0) {</a>
<a name="ln1921">            fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';</a>
<a name="ln1922">          } else {</a>
<a name="ln1923">            fmt_spec = fmt_spec == 'g' ? 'e' : 'E';</a>
<a name="ln1924">          }</a>
<a name="ln1925">          remove_trailing_zeroes = true;</a>
<a name="ln1926">        }</a>
<a name="ln1927"> </a>
<a name="ln1928">        if (xisinf(f)</a>
<a name="ln1929">            || (strchr(&quot;fF&quot;, fmt_spec) != NULL &amp;&amp; abs_f &gt; 1.0e307)) {</a>
<a name="ln1930">          xstrlcpy(tmp, infinity_str(f &gt; 0.0, fmt_spec,</a>
<a name="ln1931">                                     force_sign, space_for_positive),</a>
<a name="ln1932">                   sizeof(tmp));</a>
<a name="ln1933">          str_arg_l = strlen(tmp);</a>
<a name="ln1934">          zero_padding = 0;</a>
<a name="ln1935">        } else if (xisnan(f)) {</a>
<a name="ln1936">          // Not a number: nan or NAN</a>
<a name="ln1937">          memmove(tmp, ASCII_ISUPPER(fmt_spec) ? &quot;NAN&quot; : &quot;nan&quot;, 4);</a>
<a name="ln1938">          str_arg_l = 3;</a>
<a name="ln1939">          zero_padding = 0;</a>
<a name="ln1940">        } else {</a>
<a name="ln1941">          // Regular float number</a>
<a name="ln1942">          format[0] = '%';</a>
<a name="ln1943">          size_t l = 1;</a>
<a name="ln1944">          if (force_sign) {</a>
<a name="ln1945">            format[l++] = space_for_positive ? ' ' : '+';</a>
<a name="ln1946">          }</a>
<a name="ln1947">          if (precision_specified) {</a>
<a name="ln1948">            size_t max_prec = TMP_LEN - 10;</a>
<a name="ln1949"> </a>
<a name="ln1950">            // make sure we don't get more digits than we have room for</a>
<a name="ln1951">            if ((fmt_spec == 'f' || fmt_spec == 'F') &amp;&amp; abs_f &gt; 1.0) {</a>
<a name="ln1952">              max_prec -= (size_t)log10(abs_f);</a>
<a name="ln1953">            }</a>
<a name="ln1954">            if (precision &gt; max_prec) {</a>
<a name="ln1955">              precision = max_prec;</a>
<a name="ln1956">            }</a>
<a name="ln1957">            l += (size_t)snprintf(format + l, sizeof(format) - l, &quot;.%d&quot;,</a>
<a name="ln1958">                                  (int)precision);</a>
<a name="ln1959">          }</a>
<a name="ln1960"> </a>
<a name="ln1961">          // Cast to char to avoid a conversion warning on Ubuntu 12.04.</a>
<a name="ln1962">          assert(l + 1 &lt; sizeof(format));</a>
<a name="ln1963">          format[l] = (char)(fmt_spec == 'F' ? 'f' : fmt_spec);</a>
<a name="ln1964">          format[l + 1] = NUL;</a>
<a name="ln1965"> </a>
<a name="ln1966">          str_arg_l = (size_t)snprintf(tmp, sizeof(tmp), format, f);</a>
<a name="ln1967">          assert(str_arg_l &lt; sizeof(tmp));</a>
<a name="ln1968"> </a>
<a name="ln1969">          if (remove_trailing_zeroes) {</a>
<a name="ln1970">            int i;</a>
<a name="ln1971">            char *tp;</a>
<a name="ln1972"> </a>
<a name="ln1973">            // using %g or %G: remove superfluous zeroes</a>
<a name="ln1974">            if (fmt_spec == 'f' || fmt_spec == 'F') {</a>
<a name="ln1975">              tp = tmp + str_arg_l - 1;</a>
<a name="ln1976">            } else {</a>
<a name="ln1977">              tp = vim_strchr(tmp, fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln1978">              if (tp) {</a>
<a name="ln1979">                // remove superfluous '+' and leading zeroes from exponent</a>
<a name="ln1980">                if (tp[1] == '+') {</a>
<a name="ln1981">                  // change &quot;1.0e+07&quot; to &quot;1.0e07&quot;</a>
<a name="ln1982">                  STRMOVE(tp + 1, tp + 2);</a>
<a name="ln1983">                  str_arg_l--;</a>
<a name="ln1984">                }</a>
<a name="ln1985">                i = (tp[1] == '-') ? 2 : 1;</a>
<a name="ln1986">                while (tp[i] == '0') {</a>
<a name="ln1987">                  // change &quot;1.0e07&quot; to &quot;1.0e7&quot;</a>
<a name="ln1988">                  STRMOVE(tp + i, tp + i + 1);</a>
<a name="ln1989">                  str_arg_l--;</a>
<a name="ln1990">                }</a>
<a name="ln1991">                tp--;</a>
<a name="ln1992">              }</a>
<a name="ln1993">            }</a>
<a name="ln1994"> </a>
<a name="ln1995">            if (tp != NULL &amp;&amp; !precision_specified) {</a>
<a name="ln1996">              // remove trailing zeroes, but keep the one just after a dot</a>
<a name="ln1997">              while (tp &gt; tmp + 2 &amp;&amp; *tp == '0' &amp;&amp; tp[-1] != '.') {</a>
<a name="ln1998">                STRMOVE(tp, tp + 1);</a>
<a name="ln1999">                tp--;</a>
<a name="ln2000">                str_arg_l--;</a>
<a name="ln2001">              }</a>
<a name="ln2002">            }</a>
<a name="ln2003">          } else {</a>
<a name="ln2004">            // Be consistent: some printf(&quot;%e&quot;) use 1.0e+12 and some</a>
<a name="ln2005">            // 1.0e+012; remove one zero in the last case.</a>
<a name="ln2006">            char *tp = vim_strchr(tmp, fmt_spec == 'e' ? 'e' : 'E');</a>
<a name="ln2007">            if (tp &amp;&amp; (tp[1] == '+' || tp[1] == '-') &amp;&amp; tp[2] == '0'</a>
<a name="ln2008">                &amp;&amp; ascii_isdigit(tp[3]) &amp;&amp; ascii_isdigit(tp[4])) {</a>
<a name="ln2009">              STRMOVE(tp + 2, tp + 3);</a>
<a name="ln2010">              str_arg_l--;</a>
<a name="ln2011">            }</a>
<a name="ln2012">          }</a>
<a name="ln2013">        }</a>
<a name="ln2014">        if (zero_padding &amp;&amp; min_field_width &gt; str_arg_l</a>
<a name="ln2015">            &amp;&amp; (tmp[0] == '-' || force_sign)) {</a>
<a name="ln2016">          // Padding 0's should be inserted after the sign.</a>
<a name="ln2017">          number_of_zeros_to_pad = min_field_width - str_arg_l;</a>
<a name="ln2018">          zero_padding_insertion_ind = 1;</a>
<a name="ln2019">        }</a>
<a name="ln2020">        str_arg = tmp;</a>
<a name="ln2021">        break;</a>
<a name="ln2022">      }</a>
<a name="ln2023"> </a>
<a name="ln2024">      default:</a>
<a name="ln2025">        // unrecognized conversion specifier, keep format string as-is</a>
<a name="ln2026">        zero_padding = 0;  // turn zero padding off for non-numeric conversion</a>
<a name="ln2027">        justify_left = 1;</a>
<a name="ln2028">        min_field_width = 0;  // reset flags</a>
<a name="ln2029"> </a>
<a name="ln2030">        // discard the unrecognized conversion, just keep</a>
<a name="ln2031">        // the unrecognized conversion character</a>
<a name="ln2032">        str_arg = p;</a>
<a name="ln2033">        str_arg_l = 0;</a>
<a name="ln2034">        if (*p) {</a>
<a name="ln2035">          str_arg_l++;  // include invalid conversion specifier</a>
<a name="ln2036">        }</a>
<a name="ln2037">        // unchanged if not at end-of-string</a>
<a name="ln2038">        break;</a>
<a name="ln2039">      }</a>
<a name="ln2040"> </a>
<a name="ln2041">      if (*p) {</a>
<a name="ln2042">        p++;  // step over the just processed conversion specifier</a>
<a name="ln2043">      }</a>
<a name="ln2044"> </a>
<a name="ln2045">      // insert padding to the left as requested by min_field_width;</a>
<a name="ln2046">      // this does not include the zero padding in case of numerical conversions</a>
<a name="ln2047">      if (!justify_left) {</a>
<a name="ln2048">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln2049">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln2050">          // left padding with blank or zero</a>
<a name="ln2051">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln2052">          if (str_avail) {</a>
<a name="ln2053">            size_t avail = str_m - str_l;</a>
<a name="ln2054">            memset(str + str_l, zero_padding ? '0' : ' ', MIN(pn, avail));</a>
<a name="ln2055">            str_avail = pn &lt; avail;</a>
<a name="ln2056">          }</a>
<a name="ln2057">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln2058">          str_l += pn;</a>
<a name="ln2059">        }</a>
<a name="ln2060">      }</a>
<a name="ln2061"> </a>
<a name="ln2062">      // zero padding as requested by the precision or by the minimal</a>
<a name="ln2063">      // field width for numeric conversions required?</a>
<a name="ln2064">      if (number_of_zeros_to_pad == 0) {</a>
<a name="ln2065">        // will not copy first part of numeric right now,</a>
<a name="ln2066">        // force it to be copied later in its entirety</a>
<a name="ln2067">        zero_padding_insertion_ind = 0;</a>
<a name="ln2068">      } else {</a>
<a name="ln2069">        // insert first part of numerics (sign or '0x') before zero padding</a>
<a name="ln2070">        if (zero_padding_insertion_ind &gt; 0) {</a>
<a name="ln2071">          size_t zn = zero_padding_insertion_ind;</a>
<a name="ln2072">          if (str_avail) {</a>
<a name="ln2073">            size_t avail = str_m - str_l;</a>
<a name="ln2074">            memmove(str + str_l, str_arg, MIN(zn, avail));</a>
<a name="ln2075">            str_avail = zn &lt; avail;</a>
<a name="ln2076">          }</a>
<a name="ln2077">          assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln2078">          str_l += zn;</a>
<a name="ln2079">        }</a>
<a name="ln2080"> </a>
<a name="ln2081">        // insert zero padding as requested by precision or min field width</a>
<a name="ln2082">        size_t zn = number_of_zeros_to_pad;</a>
<a name="ln2083">        if (str_avail) {</a>
<a name="ln2084">          size_t avail = str_m - str_l;</a>
<a name="ln2085">          memset(str + str_l, '0', MIN(zn, avail));</a>
<a name="ln2086">          str_avail = zn &lt; avail;</a>
<a name="ln2087">        }</a>
<a name="ln2088">        assert(zn &lt;= SIZE_MAX - str_l);</a>
<a name="ln2089">        str_l += zn;</a>
<a name="ln2090">      }</a>
<a name="ln2091"> </a>
<a name="ln2092">      // insert formatted string</a>
<a name="ln2093">      // (or as-is conversion specifier for unknown conversions)</a>
<a name="ln2094">      if (str_arg_l &gt; zero_padding_insertion_ind) {</a>
<a name="ln2095">        size_t sn = str_arg_l - zero_padding_insertion_ind;</a>
<a name="ln2096">        if (str_avail) {</a>
<a name="ln2097">          size_t avail = str_m - str_l;</a>
<a name="ln2098">          memmove(str + str_l,</a>
<a name="ln2099">                  str_arg + zero_padding_insertion_ind,</a>
<a name="ln2100">                  MIN(sn, avail));</a>
<a name="ln2101">          str_avail = sn &lt; avail;</a>
<a name="ln2102">        }</a>
<a name="ln2103">        assert(sn &lt;= SIZE_MAX - str_l);</a>
<a name="ln2104">        str_l += sn;</a>
<a name="ln2105">      }</a>
<a name="ln2106"> </a>
<a name="ln2107">      // insert right padding</a>
<a name="ln2108">      if (justify_left) {</a>
<a name="ln2109">        assert(str_arg_l &lt;= SIZE_MAX - number_of_zeros_to_pad);</a>
<a name="ln2110">        if (min_field_width &gt; str_arg_l + number_of_zeros_to_pad) {</a>
<a name="ln2111">          // right blank padding to the field width</a>
<a name="ln2112">          size_t pn = min_field_width - (str_arg_l + number_of_zeros_to_pad);</a>
<a name="ln2113">          if (str_avail) {</a>
<a name="ln2114">            size_t avail = str_m - str_l;</a>
<a name="ln2115">            memset(str + str_l, ' ', MIN(pn, avail));</a>
<a name="ln2116">            str_avail = pn &lt; avail;</a>
<a name="ln2117">          }</a>
<a name="ln2118">          assert(pn &lt;= SIZE_MAX - str_l);</a>
<a name="ln2119">          str_l += pn;</a>
<a name="ln2120">        }</a>
<a name="ln2121">      }</a>
<a name="ln2122"> </a>
<a name="ln2123">      xfree(tofree);</a>
<a name="ln2124">    }</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127">  if (str_m &gt; 0) {</a>
<a name="ln2128">    // make sure the string is nul-terminated even at the expense of</a>
<a name="ln2129">    // overwriting the last character (shouldn't happen, but just in case)</a>
<a name="ln2130">    str[str_l &lt;= str_m - 1 ? str_l : str_m - 1] = '\0';</a>
<a name="ln2131">  }</a>
<a name="ln2132"> </a>
<a name="ln2133">  if (tvs != NULL</a>
<a name="ln2134">      &amp;&amp; tvs[num_posarg != 0 ? num_posarg : arg_idx - 1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2135">    emsg(_(&quot;E767: Too many arguments to printf()&quot;));</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  xfree(ap_types);</a>
<a name="ln2139">  va_end(ap);</a>
<a name="ln2140"> </a>
<a name="ln2141">  // return the number of characters formatted (excluding trailing nul</a>
<a name="ln2142">  // character); that is, the number of characters that would have been</a>
<a name="ln2143">  // written to the buffer if it were large enough.</a>
<a name="ln2144">  return (int)str_l;</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">int kv_do_printf(StringBuilder *str, const char *fmt, ...)</a>
<a name="ln2148">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2149">{</a>
<a name="ln2150">  size_t remaining = str-&gt;capacity - str-&gt;size;</a>
<a name="ln2151"> </a>
<a name="ln2152">  va_list ap;</a>
<a name="ln2153">  va_start(ap, fmt);</a>
<a name="ln2154">  int printed = vsnprintf(str-&gt;items ? str-&gt;items + str-&gt;size : NULL, remaining, fmt, ap);</a>
<a name="ln2155">  va_end(ap);</a>
<a name="ln2156"> </a>
<a name="ln2157">  if (printed &lt; 0) {</a>
<a name="ln2158">    return -1;</a>
<a name="ln2159">  }</a>
<a name="ln2160"> </a>
<a name="ln2161">  // printed string didn't fit, resize and try again</a>
<a name="ln2162">  if ((size_t)printed &gt;= remaining) {</a>
<a name="ln2163">    kv_ensure_space(*str, (size_t)printed + 1);  // include space for NUL terminator at the end</a>
<a name="ln2164">    assert(str-&gt;items != NULL);</a>
<a name="ln2165">    va_start(ap, fmt);</a>
<a name="ln2166">    printed = vsnprintf(str-&gt;items + str-&gt;size, str-&gt;capacity - str-&gt;size, fmt, ap);</a>
<a name="ln2167">    va_end(ap);</a>
<a name="ln2168">    if (printed &lt; 0) {</a>
<a name="ln2169">      return -1;</a>
<a name="ln2170">    }</a>
<a name="ln2171">  }</a>
<a name="ln2172"> </a>
<a name="ln2173">  str-&gt;size += (size_t)printed;</a>
<a name="ln2174">  return printed;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">/// Reverse text into allocated memory.</a>
<a name="ln2178">///</a>
<a name="ln2179">/// @return  the allocated string.</a>
<a name="ln2180">char *reverse_text(char *s)</a>
<a name="ln2181">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln2182">{</a>
<a name="ln2183">  size_t len = strlen(s);</a>
<a name="ln2184">  char *rev = xmalloc(len + 1);</a>
<a name="ln2185">  for (size_t s_i = 0, rev_i = len; s_i &lt; len; s_i++) {</a>
<a name="ln2186">    const int mb_len = utfc_ptr2len(s + s_i);</a>
<a name="ln2187">    rev_i -= (size_t)mb_len;</a>
<a name="ln2188">    memmove(rev + rev_i, s + s_i, (size_t)mb_len);</a>
<a name="ln2189">    s_i += (size_t)mb_len - 1;</a>
<a name="ln2190">  }</a>
<a name="ln2191">  rev[len] = NUL;</a>
<a name="ln2192">  return rev;</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">/// Replace all occurrences of &quot;what&quot; with &quot;rep&quot; in &quot;src&quot;. If no replacement happens then NULL is</a>
<a name="ln2196">/// returned otherwise return a newly allocated string.</a>
<a name="ln2197">///</a>
<a name="ln2198">/// @param[in] src  Source text</a>
<a name="ln2199">/// @param[in] what Substring to replace</a>
<a name="ln2200">/// @param[in] rep  Substring to replace with</a>
<a name="ln2201">///</a>
<a name="ln2202">/// @return [allocated] Copy of the string.</a>
<a name="ln2203">char *strrep(const char *src, const char *what, const char *rep)</a>
<a name="ln2204">{</a>
<a name="ln2205">  const char *pos = src;</a>
<a name="ln2206">  size_t whatlen = strlen(what);</a>
<a name="ln2207"> </a>
<a name="ln2208">  // Count occurrences</a>
<a name="ln2209">  size_t count = 0;</a>
<a name="ln2210">  while ((pos = strstr(pos, what)) != NULL) {</a>
<a name="ln2211">    count++;</a>
<a name="ln2212">    pos += whatlen;</a>
<a name="ln2213">  }</a>
<a name="ln2214"> </a>
<a name="ln2215">  if (count == 0) {</a>
<a name="ln2216">    return NULL;</a>
<a name="ln2217">  }</a>
<a name="ln2218"> </a>
<a name="ln2219">  size_t replen = strlen(rep);</a>
<a name="ln2220">  char *ret = xmalloc(strlen(src) + count * (replen - whatlen) + 1);</a>
<a name="ln2221">  char *ptr = ret;</a>
<a name="ln2222">  while ((pos = strstr(src, what)) != NULL) {</a>
<a name="ln2223">    size_t idx = (size_t)(pos - src);</a>
<a name="ln2224">    memcpy(ptr, src, idx);</a>
<a name="ln2225">    ptr += idx;</a>
<a name="ln2226">    STRCPY(ptr, rep);</a>
<a name="ln2227">    ptr += replen;</a>
<a name="ln2228">    src = pos + whatlen;</a>
<a name="ln2229">  }</a>
<a name="ln2230"> </a>
<a name="ln2231">  // Copy remaining</a>
<a name="ln2232">  STRCPY(ptr, src);</a>
<a name="ln2233"> </a>
<a name="ln2234">  return ret;</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">/// Implementation of &quot;byteidx()&quot; and &quot;byteidxcomp()&quot; functions</a>
<a name="ln2238">static void byteidx_common(typval_T *argvars, typval_T *rettv, int comp)</a>
<a name="ln2239">{</a>
<a name="ln2240">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2241"> </a>
<a name="ln2242">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2243">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln2244">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln2245">    return;</a>
<a name="ln2246">  }</a>
<a name="ln2247"> </a>
<a name="ln2248">  varnumber_T utf16idx = false;</a>
<a name="ln2249">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2250">    bool error = false;</a>
<a name="ln2251">    utf16idx = tv_get_bool_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2252">    if (error) {</a>
<a name="ln2253">      return;</a>
<a name="ln2254">    }</a>
<a name="ln2255">    if (utf16idx &lt; 0 || utf16idx &gt; 1) {</a>
<a name="ln2256">      semsg(_(e_using_number_as_bool_nr), utf16idx);</a>
<a name="ln2257">      return;</a>
<a name="ln2258">    }</a>
<a name="ln2259">  }</a>
<a name="ln2260"> </a>
<a name="ln2261">  int (*ptr2len)(const char *);</a>
<a name="ln2262">  if (comp) {</a>
<a name="ln2263">    ptr2len = utf_ptr2len;</a>
<a name="ln2264">  } else {</a>
<a name="ln2265">    ptr2len = utfc_ptr2len;</a>
<a name="ln2266">  }</a>
<a name="ln2267"> </a>
<a name="ln2268">  const char *t = str;</a>
<a name="ln2269">  for (; idx &gt; 0; idx--) {</a>
<a name="ln2270">    if (*t == NUL) {  // EOL reached.</a>
<a name="ln2271">      return;</a>
<a name="ln2272">    }</a>
<a name="ln2273">    if (utf16idx) {</a>
<a name="ln2274">      const int clen = ptr2len(t);</a>
<a name="ln2275">      const int c = (clen &gt; 1) ? utf_ptr2char(t) : *t;</a>
<a name="ln2276">      if (c &gt; 0xFFFF) {</a>
<a name="ln2277">        idx--;</a>
<a name="ln2278">      }</a>
<a name="ln2279">    }</a>
<a name="ln2280">    if (idx &gt; 0) {</a>
<a name="ln2281">      t += ptr2len(t);</a>
<a name="ln2282">    }</a>
<a name="ln2283">  }</a>
<a name="ln2284">  rettv-&gt;vval.v_number = (varnumber_T)(t - str);</a>
<a name="ln2285">}</a>
<a name="ln2286"> </a>
<a name="ln2287">/// &quot;byteidx()&quot; function</a>
<a name="ln2288">void f_byteidx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2289">{</a>
<a name="ln2290">  byteidx_common(argvars, rettv, false);</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">/// &quot;byteidxcomp()&quot; function</a>
<a name="ln2294">void f_byteidxcomp(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2295">{</a>
<a name="ln2296">  byteidx_common(argvars, rettv, true);</a>
<a name="ln2297">}</a>
<a name="ln2298"> </a>
<a name="ln2299">/// &quot;charidx()&quot; function</a>
<a name="ln2300">void f_charidx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2301">{</a>
<a name="ln2302">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2303"> </a>
<a name="ln2304">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln2305">      || tv_check_for_number_arg(argvars, 1) == FAIL</a>
<a name="ln2306">      || tv_check_for_opt_bool_arg(argvars, 2) == FAIL</a>
<a name="ln2307">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2308">          &amp;&amp; tv_check_for_opt_bool_arg(argvars, 3) == FAIL)) {</a>
<a name="ln2309">    return;</a>
<a name="ln2310">  }</a>
<a name="ln2311"> </a>
<a name="ln2312">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2313">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln2314">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln2315">    return;</a>
<a name="ln2316">  }</a>
<a name="ln2317"> </a>
<a name="ln2318">  varnumber_T countcc = false;</a>
<a name="ln2319">  varnumber_T utf16idx = false;</a>
<a name="ln2320">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2321">    countcc = tv_get_bool(&amp;argvars[2]);</a>
<a name="ln2322">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln2323">      utf16idx = tv_get_bool(&amp;argvars[3]);</a>
<a name="ln2324">    }</a>
<a name="ln2325">  }</a>
<a name="ln2326"> </a>
<a name="ln2327">  int (*ptr2len)(const char *);</a>
<a name="ln2328">  if (countcc) {</a>
<a name="ln2329">    ptr2len = utf_ptr2len;</a>
<a name="ln2330">  } else {</a>
<a name="ln2331">    ptr2len = utfc_ptr2len;</a>
<a name="ln2332">  }</a>
<a name="ln2333"> </a>
<a name="ln2334">  const char *p;</a>
<a name="ln2335">  int len;</a>
<a name="ln2336">  for (p = str, len = 0; utf16idx ? idx &gt;= 0 : p &lt;= str + idx; len++) {</a>
<a name="ln2337">    if (*p == NUL) {</a>
<a name="ln2338">      // If the index is exactly the number of bytes or utf-16 code units</a>
<a name="ln2339">      // in the string then return the length of the string in characters.</a>
<a name="ln2340">      if (utf16idx ? (idx == 0) : (p == (str + idx))) {</a>
<a name="ln2341">        rettv-&gt;vval.v_number = len;</a>
<a name="ln2342">      }</a>
<a name="ln2343">      return;</a>
<a name="ln2344">    }</a>
<a name="ln2345">    if (utf16idx) {</a>
<a name="ln2346">      idx--;</a>
<a name="ln2347">      const int clen = ptr2len(p);</a>
<a name="ln2348">      const int c = (clen &gt; 1) ? utf_ptr2char(p) : *p;</a>
<a name="ln2349">      if (c &gt; 0xFFFF) {</a>
<a name="ln2350">        idx--;</a>
<a name="ln2351">      }</a>
<a name="ln2352">    }</a>
<a name="ln2353">    p += ptr2len(p);</a>
<a name="ln2354">  }</a>
<a name="ln2355"> </a>
<a name="ln2356">  rettv-&gt;vval.v_number = len &gt; 0 ? len - 1 : 0;</a>
<a name="ln2357">}</a>
<a name="ln2358"> </a>
<a name="ln2359">/// &quot;str2list()&quot; function</a>
<a name="ln2360">void f_str2list(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2361">{</a>
<a name="ln2362">  tv_list_alloc_ret(rettv, kListLenUnknown);</a>
<a name="ln2363">  const char *p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2364"> </a>
<a name="ln2365">  for (; *p != NUL; p += utf_ptr2len(p)) {</a>
<a name="ln2366">    tv_list_append_number(rettv-&gt;vval.v_list, utf_ptr2char(p));</a>
<a name="ln2367">  }</a>
<a name="ln2368">}</a>
<a name="ln2369"> </a>
<a name="ln2370">/// &quot;str2nr()&quot; function</a>
<a name="ln2371">void f_str2nr(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2372">{</a>
<a name="ln2373">  int base = 10;</a>
<a name="ln2374">  int what = 0;</a>
<a name="ln2375"> </a>
<a name="ln2376">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2377">    base = (int)tv_get_number(&amp;argvars[1]);</a>
<a name="ln2378">    if (base != 2 &amp;&amp; base != 8 &amp;&amp; base != 10 &amp;&amp; base != 16) {</a>
<a name="ln2379">      emsg(_(e_invarg));</a>
<a name="ln2380">      return;</a>
<a name="ln2381">    }</a>
<a name="ln2382">    if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; tv_get_bool(&amp;argvars[2])) {</a>
<a name="ln2383">      what |= STR2NR_QUOTE;</a>
<a name="ln2384">    }</a>
<a name="ln2385">  }</a>
<a name="ln2386"> </a>
<a name="ln2387">  char *p = skipwhite(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2388">  bool isneg = (*p == '-');</a>
<a name="ln2389">  if (*p == '+' || *p == '-') {</a>
<a name="ln2390">    p = skipwhite(p + 1);</a>
<a name="ln2391">  }</a>
<a name="ln2392">  switch (base) {</a>
<a name="ln2393">  case 2:</a>
<a name="ln2394">    what |= STR2NR_BIN | STR2NR_FORCE;</a>
<a name="ln2395">    break;</a>
<a name="ln2396">  case 8:</a>
<a name="ln2397">    what |= STR2NR_OCT | STR2NR_OOCT | STR2NR_FORCE;</a>
<a name="ln2398">    break;</a>
<a name="ln2399">  case 16:</a>
<a name="ln2400">    what |= STR2NR_HEX | STR2NR_FORCE;</a>
<a name="ln2401">    break;</a>
<a name="ln2402">  }</a>
<a name="ln2403">  varnumber_T n;</a>
<a name="ln2404">  vim_str2nr(p, NULL, NULL, what, &amp;n, NULL, 0, false, NULL);</a>
<a name="ln2405">  // Text after the number is silently ignored.</a>
<a name="ln2406">  if (isneg) {</a>
<a name="ln2407">    rettv-&gt;vval.v_number = -n;</a>
<a name="ln2408">  } else {</a>
<a name="ln2409">    rettv-&gt;vval.v_number = n;</a>
<a name="ln2410">  }</a>
<a name="ln2411">}</a>
<a name="ln2412"> </a>
<a name="ln2413">/// &quot;strgetchar()&quot; function</a>
<a name="ln2414">void f_strgetchar(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2415">{</a>
<a name="ln2416">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2417"> </a>
<a name="ln2418">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2419">  if (str == NULL) {</a>
<a name="ln2420">    return;</a>
<a name="ln2421">  }</a>
<a name="ln2422">  bool error = false;</a>
<a name="ln2423">  varnumber_T charidx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2424">  if (error) {</a>
<a name="ln2425">    return;</a>
<a name="ln2426">  }</a>
<a name="ln2427"> </a>
<a name="ln2428">  const size_t len = strlen(str);</a>
<a name="ln2429">  size_t byteidx = 0;</a>
<a name="ln2430"> </a>
<a name="ln2431">  while (charidx &gt;= 0 &amp;&amp; byteidx &lt; len) {</a>
<a name="ln2432">    if (charidx == 0) {</a>
<a name="ln2433">      rettv-&gt;vval.v_number = utf_ptr2char(str + byteidx);</a>
<a name="ln2434">      break;</a>
<a name="ln2435">    }</a>
<a name="ln2436">    charidx--;</a>
<a name="ln2437">    byteidx += (size_t)utf_ptr2len(str + byteidx);</a>
<a name="ln2438">  }</a>
<a name="ln2439">}</a>
<a name="ln2440"> </a>
<a name="ln2441">/// &quot;stridx()&quot; function</a>
<a name="ln2442">void f_stridx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2443">{</a>
<a name="ln2444">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2445"> </a>
<a name="ln2446">  char buf[NUMBUFLEN];</a>
<a name="ln2447">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2448">  const char *haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln2449">  const char *const haystack_start = haystack;</a>
<a name="ln2450">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln2451">    return;  // Type error; errmsg already given.</a>
<a name="ln2452">  }</a>
<a name="ln2453"> </a>
<a name="ln2454">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2455">    bool error = false;</a>
<a name="ln2456"> </a>
<a name="ln2457">    const ptrdiff_t start_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2],</a>
<a name="ln2458">                                                             &amp;error);</a>
<a name="ln2459">    if (error || start_idx &gt;= (ptrdiff_t)strlen(haystack)) {</a>
<a name="ln2460">      return;</a>
<a name="ln2461">    }</a>
<a name="ln2462">    if (start_idx &gt;= 0) {</a>
<a name="ln2463">      haystack += start_idx;</a>
<a name="ln2464">    }</a>
<a name="ln2465">  }</a>
<a name="ln2466"> </a>
<a name="ln2467">  const char *pos = strstr(haystack, needle);</a>
<a name="ln2468">  if (pos != NULL) {</a>
<a name="ln2469">    rettv-&gt;vval.v_number = (varnumber_T)(pos - haystack_start);</a>
<a name="ln2470">  }</a>
<a name="ln2471">}</a>
<a name="ln2472"> </a>
<a name="ln2473">/// &quot;string()&quot; function</a>
<a name="ln2474">void f_string(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2475">{</a>
<a name="ln2476">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2477">  rettv-&gt;vval.v_string = encode_tv2string(&amp;argvars[0], NULL);</a>
<a name="ln2478">}</a>
<a name="ln2479"> </a>
<a name="ln2480">/// &quot;strlen()&quot; function</a>
<a name="ln2481">void f_strlen(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2482">{</a>
<a name="ln2483">  rettv-&gt;vval.v_number = (varnumber_T)strlen(tv_get_string(&amp;argvars[0]));</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">static void strchar_common(typval_T *argvars, typval_T *rettv, bool skipcc)</a>
<a name="ln2487">{</a>
<a name="ln2488">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2489">  varnumber_T len = 0;</a>
<a name="ln2490">  int (*func_mb_ptr2char_adv)(const char **pp);</a>
<a name="ln2491"> </a>
<a name="ln2492">  func_mb_ptr2char_adv = skipcc ? mb_ptr2char_adv : mb_cptr2char_adv;</a>
<a name="ln2493">  while (*s != NUL) {</a>
<a name="ln2494">    func_mb_ptr2char_adv(&amp;s);</a>
<a name="ln2495">    len++;</a>
<a name="ln2496">  }</a>
<a name="ln2497">  rettv-&gt;vval.v_number = len;</a>
<a name="ln2498">}</a>
<a name="ln2499"> </a>
<a name="ln2500">/// &quot;strcharlen()&quot; function</a>
<a name="ln2501">void f_strcharlen(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2502">{</a>
<a name="ln2503">  strchar_common(argvars, rettv, true);</a>
<a name="ln2504">}</a>
<a name="ln2505"> </a>
<a name="ln2506">/// &quot;strchars()&quot; function</a>
<a name="ln2507">void f_strchars(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2508">{</a>
<a name="ln2509">  varnumber_T skipcc = false;</a>
<a name="ln2510"> </a>
<a name="ln2511">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2512">    bool error = false;</a>
<a name="ln2513">    skipcc = tv_get_bool_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2514">    if (error) {</a>
<a name="ln2515">      return;</a>
<a name="ln2516">    }</a>
<a name="ln2517">    if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln2518">      semsg(_(e_using_number_as_bool_nr), skipcc);</a>
<a name="ln2519">      return;</a>
<a name="ln2520">    }</a>
<a name="ln2521">  }</a>
<a name="ln2522"> </a>
<a name="ln2523">  strchar_common(argvars, rettv, skipcc);</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">/// &quot;strutf16len()&quot; function</a>
<a name="ln2527">void f_strutf16len(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2528">{</a>
<a name="ln2529">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2530"> </a>
<a name="ln2531">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln2532">      || tv_check_for_opt_bool_arg(argvars, 1) == FAIL) {</a>
<a name="ln2533">    return;</a>
<a name="ln2534">  }</a>
<a name="ln2535"> </a>
<a name="ln2536">  varnumber_T countcc = false;</a>
<a name="ln2537">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2538">    countcc = tv_get_bool(&amp;argvars[1]);</a>
<a name="ln2539">  }</a>
<a name="ln2540"> </a>
<a name="ln2541">  const char *s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2542">  varnumber_T len = 0;</a>
<a name="ln2543">  int (*func_mb_ptr2char_adv)(const char **pp);</a>
<a name="ln2544"> </a>
<a name="ln2545">  func_mb_ptr2char_adv = countcc ? mb_cptr2char_adv : mb_ptr2char_adv;</a>
<a name="ln2546">  while (*s != NUL) {</a>
<a name="ln2547">    const int ch = func_mb_ptr2char_adv(&amp;s);</a>
<a name="ln2548">    if (ch &gt; 0xFFFF) {</a>
<a name="ln2549">      len++;</a>
<a name="ln2550">    }</a>
<a name="ln2551">    len++;</a>
<a name="ln2552">  }</a>
<a name="ln2553">  rettv-&gt;vval.v_number = len;</a>
<a name="ln2554">}</a>
<a name="ln2555"> </a>
<a name="ln2556">/// &quot;strdisplaywidth()&quot; function</a>
<a name="ln2557">void f_strdisplaywidth(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2558">{</a>
<a name="ln2559">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2560">  int col = 0;</a>
<a name="ln2561"> </a>
<a name="ln2562">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln2563">    col = (int)tv_get_number(&amp;argvars[1]);</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  rettv-&gt;vval.v_number = (varnumber_T)(linetabsize_col(col, (char *)s) - col);</a>
<a name="ln2567">}</a>
<a name="ln2568"> </a>
<a name="ln2569">/// &quot;strwidth()&quot; function</a>
<a name="ln2570">void f_strwidth(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2571">{</a>
<a name="ln2572">  const char *const s = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2573"> </a>
<a name="ln2574">  rettv-&gt;vval.v_number = (varnumber_T)mb_string2cells(s);</a>
<a name="ln2575">}</a>
<a name="ln2576"> </a>
<a name="ln2577">/// &quot;strcharpart()&quot; function</a>
<a name="ln2578">void f_strcharpart(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2579">{</a>
<a name="ln2580">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2581">  const size_t slen = strlen(p);</a>
<a name="ln2582"> </a>
<a name="ln2583">  int nbyte = 0;</a>
<a name="ln2584">  varnumber_T skipcc = false;</a>
<a name="ln2585">  bool error = false;</a>
<a name="ln2586">  varnumber_T nchar = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2587">  if (!error) {</a>
<a name="ln2588">    if (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2589">        &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln2590">      skipcc = tv_get_bool_chk(&amp;argvars[3], &amp;error);</a>
<a name="ln2591">      if (error) {</a>
<a name="ln2592">        return;</a>
<a name="ln2593">      }</a>
<a name="ln2594">      if (skipcc &lt; 0 || skipcc &gt; 1) {</a>
<a name="ln2595">        semsg(_(e_using_number_as_bool_nr), skipcc);</a>
<a name="ln2596">        return;</a>
<a name="ln2597">      }</a>
<a name="ln2598">    }</a>
<a name="ln2599"> </a>
<a name="ln2600">    if (nchar &gt; 0) {</a>
<a name="ln2601">      while (nchar &gt; 0 &amp;&amp; (size_t)nbyte &lt; slen) {</a>
<a name="ln2602">        if (skipcc) {</a>
<a name="ln2603">          nbyte += utfc_ptr2len(p + nbyte);</a>
<a name="ln2604">        } else {</a>
<a name="ln2605">          nbyte += utf_ptr2len(p + nbyte);</a>
<a name="ln2606">        }</a>
<a name="ln2607">        nchar--;</a>
<a name="ln2608">      }</a>
<a name="ln2609">    } else {</a>
<a name="ln2610">      nbyte = (int)nchar;</a>
<a name="ln2611">    }</a>
<a name="ln2612">  }</a>
<a name="ln2613">  int len = 0;</a>
<a name="ln2614">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2615">    int charlen = (int)tv_get_number(&amp;argvars[2]);</a>
<a name="ln2616">    while (charlen &gt; 0 &amp;&amp; nbyte + len &lt; (int)slen) {</a>
<a name="ln2617">      int off = nbyte + len;</a>
<a name="ln2618"> </a>
<a name="ln2619">      if (off &lt; 0) {</a>
<a name="ln2620">        len += 1;</a>
<a name="ln2621">      } else {</a>
<a name="ln2622">        if (skipcc) {</a>
<a name="ln2623">          len += utfc_ptr2len(p + off);</a>
<a name="ln2624">        } else {</a>
<a name="ln2625">          len += utf_ptr2len(p + off);</a>
<a name="ln2626">        }</a>
<a name="ln2627">      }</a>
<a name="ln2628">      charlen--;</a>
<a name="ln2629">    }</a>
<a name="ln2630">  } else {</a>
<a name="ln2631">    len = (int)slen - nbyte;    // default: all bytes that are available.</a>
<a name="ln2632">  }</a>
<a name="ln2633"> </a>
<a name="ln2634">  // Only return the overlap between the specified part and the actual</a>
<a name="ln2635">  // string.</a>
<a name="ln2636">  if (nbyte &lt; 0) {</a>
<a name="ln2637">    len += nbyte;</a>
<a name="ln2638">    nbyte = 0;</a>
<a name="ln2639">  } else if ((size_t)nbyte &gt; slen) {</a>
<a name="ln2640">    nbyte = (int)slen;</a>
<a name="ln2641">  }</a>
<a name="ln2642">  if (len &lt; 0) {</a>
<a name="ln2643">    len = 0;</a>
<a name="ln2644">  } else if (nbyte + len &gt; (int)slen) {</a>
<a name="ln2645">    len = (int)slen - nbyte;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2649">  rettv-&gt;vval.v_string = xstrndup(p + nbyte, (size_t)len);</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">/// &quot;strpart()&quot; function</a>
<a name="ln2653">void f_strpart(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2654">{</a>
<a name="ln2655">  bool error = false;</a>
<a name="ln2656"> </a>
<a name="ln2657">  const char *const p = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2658">  const size_t slen = strlen(p);</a>
<a name="ln2659"> </a>
<a name="ln2660">  varnumber_T n = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2661">  varnumber_T len;</a>
<a name="ln2662">  if (error) {</a>
<a name="ln2663">    len = 0;</a>
<a name="ln2664">  } else if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2665">    len = tv_get_number(&amp;argvars[2]);</a>
<a name="ln2666">  } else {</a>
<a name="ln2667">    len = (varnumber_T)slen - n;  // Default len: all bytes that are available.</a>
<a name="ln2668">  }</a>
<a name="ln2669"> </a>
<a name="ln2670">  // Only return the overlap between the specified part and the actual</a>
<a name="ln2671">  // string.</a>
<a name="ln2672">  if (n &lt; 0) {</a>
<a name="ln2673">    len += n;</a>
<a name="ln2674">    n = 0;</a>
<a name="ln2675">  } else if (n &gt; (varnumber_T)slen) {</a>
<a name="ln2676">    n = (varnumber_T)slen;</a>
<a name="ln2677">  }</a>
<a name="ln2678">  if (len &lt; 0) {</a>
<a name="ln2679">    len = 0;</a>
<a name="ln2680">  } else if (n + len &gt; (varnumber_T)slen) {</a>
<a name="ln2681">    len = (varnumber_T)slen - n;</a>
<a name="ln2682">  }</a>
<a name="ln2683"> </a>
<a name="ln2684">  if (argvars[2].v_type != VAR_UNKNOWN &amp;&amp; argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln2685">    int off;</a>
<a name="ln2686"> </a>
<a name="ln2687">    // length in characters</a>
<a name="ln2688">    for (off = (int)n; off &lt; (int)slen &amp;&amp; len &gt; 0; len--) {</a>
<a name="ln2689">      off += utfc_ptr2len(p + off);</a>
<a name="ln2690">    }</a>
<a name="ln2691">    len = off - n;</a>
<a name="ln2692">  }</a>
<a name="ln2693"> </a>
<a name="ln2694">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2695">  rettv-&gt;vval.v_string = xmemdupz(p + n, (size_t)len);</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698">/// &quot;strridx()&quot; function</a>
<a name="ln2699">void f_strridx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2700">{</a>
<a name="ln2701">  char buf[NUMBUFLEN];</a>
<a name="ln2702">  const char *const needle = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln2703">  const char *const haystack = tv_get_string_buf_chk(&amp;argvars[0], buf);</a>
<a name="ln2704"> </a>
<a name="ln2705">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2706">  if (needle == NULL || haystack == NULL) {</a>
<a name="ln2707">    return;  // Type error; errmsg already given.</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  const size_t haystack_len = strlen(haystack);</a>
<a name="ln2711">  ptrdiff_t end_idx;</a>
<a name="ln2712">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2713">    // Third argument: upper limit for index.</a>
<a name="ln2714">    end_idx = (ptrdiff_t)tv_get_number_chk(&amp;argvars[2], NULL);</a>
<a name="ln2715">    if (end_idx &lt; 0) {</a>
<a name="ln2716">      return;  // Can never find a match.</a>
<a name="ln2717">    }</a>
<a name="ln2718">  } else {</a>
<a name="ln2719">    end_idx = (ptrdiff_t)haystack_len;</a>
<a name="ln2720">  }</a>
<a name="ln2721"> </a>
<a name="ln2722">  const char *lastmatch = NULL;</a>
<a name="ln2723">  if (*needle == NUL) {</a>
<a name="ln2724">    // Empty string matches past the end.</a>
<a name="ln2725">    lastmatch = haystack + end_idx;</a>
<a name="ln2726">  } else {</a>
<a name="ln2727">    for (const char *rest = haystack; *rest != NUL; rest++) {</a>
<a name="ln2728">      rest = strstr(rest, needle);</a>
<a name="ln2729">      if (rest == NULL || rest &gt; haystack + end_idx) {</a>
<a name="ln2730">        break;</a>
<a name="ln2731">      }</a>
<a name="ln2732">      lastmatch = rest;</a>
<a name="ln2733">    }</a>
<a name="ln2734">  }</a>
<a name="ln2735"> </a>
<a name="ln2736">  if (lastmatch != NULL) {</a>
<a name="ln2737">    rettv-&gt;vval.v_number = (varnumber_T)(lastmatch - haystack);</a>
<a name="ln2738">  }</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">/// &quot;strtrans()&quot; function</a>
<a name="ln2742">void f_strtrans(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2743">{</a>
<a name="ln2744">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2745">  rettv-&gt;vval.v_string = transstr(tv_get_string(&amp;argvars[0]), true);</a>
<a name="ln2746">}</a>
<a name="ln2747"> </a>
<a name="ln2748">/// &quot;utf16idx()&quot; function</a>
<a name="ln2749">///</a>
<a name="ln2750">/// Converts a byte or character offset in a string to the corresponding UTF-16</a>
<a name="ln2751">/// code unit offset.</a>
<a name="ln2752">void f_utf16idx(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2753">{</a>
<a name="ln2754">  rettv-&gt;vval.v_number = -1;</a>
<a name="ln2755"> </a>
<a name="ln2756">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln2757">      || tv_check_for_opt_number_arg(argvars, 1) == FAIL</a>
<a name="ln2758">      || tv_check_for_opt_bool_arg(argvars, 2) == FAIL</a>
<a name="ln2759">      || (argvars[2].v_type != VAR_UNKNOWN</a>
<a name="ln2760">          &amp;&amp; tv_check_for_opt_bool_arg(argvars, 3) == FAIL)) {</a>
<a name="ln2761">    return;</a>
<a name="ln2762">  }</a>
<a name="ln2763"> </a>
<a name="ln2764">  const char *const str = tv_get_string_chk(&amp;argvars[0]);</a>
<a name="ln2765">  varnumber_T idx = tv_get_number_chk(&amp;argvars[1], NULL);</a>
<a name="ln2766">  if (str == NULL || idx &lt; 0) {</a>
<a name="ln2767">    return;</a>
<a name="ln2768">  }</a>
<a name="ln2769"> </a>
<a name="ln2770">  varnumber_T countcc = false;</a>
<a name="ln2771">  varnumber_T charidx = false;</a>
<a name="ln2772">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2773">    countcc = tv_get_bool(&amp;argvars[2]);</a>
<a name="ln2774">    if (argvars[3].v_type != VAR_UNKNOWN) {</a>
<a name="ln2775">      charidx = tv_get_bool(&amp;argvars[3]);</a>
<a name="ln2776">    }</a>
<a name="ln2777">  }</a>
<a name="ln2778"> </a>
<a name="ln2779">  int (*ptr2len)(const char *);</a>
<a name="ln2780">  if (countcc) {</a>
<a name="ln2781">    ptr2len = utf_ptr2len;</a>
<a name="ln2782">  } else {</a>
<a name="ln2783">    ptr2len = utfc_ptr2len;</a>
<a name="ln2784">  }</a>
<a name="ln2785"> </a>
<a name="ln2786">  const char *p;</a>
<a name="ln2787">  int len;</a>
<a name="ln2788">  int utf16idx = 0;</a>
<a name="ln2789">  for (p = str, len = 0; charidx ? idx &gt;= 0 : p &lt;= str + idx; len++) {</a>
<a name="ln2790">    if (*p == NUL) {</a>
<a name="ln2791">      // If the index is exactly the number of bytes or characters in the</a>
<a name="ln2792">      // string then return the length of the string in utf-16 code units.</a>
<a name="ln2793">      if (charidx ? (idx == 0) : (p == (str + idx))) {</a>
<a name="ln2794">        rettv-&gt;vval.v_number = len;</a>
<a name="ln2795">      }</a>
<a name="ln2796">      return;</a>
<a name="ln2797">    }</a>
<a name="ln2798">    utf16idx = len;</a>
<a name="ln2799">    const int clen = ptr2len(p);</a>
<a name="ln2800">    const int c = (clen &gt; 1) ? utf_ptr2char(p) : *p;</a>
<a name="ln2801">    if (c &gt; 0xFFFF) {</a>
<a name="ln2802">      len++;</a>
<a name="ln2803">    }</a>
<a name="ln2804">    p += ptr2len(p);</a>
<a name="ln2805">    if (charidx) {</a>
<a name="ln2806">      idx--;</a>
<a name="ln2807">    }</a>
<a name="ln2808">  }</a>
<a name="ln2809"> </a>
<a name="ln2810">  rettv-&gt;vval.v_number = utf16idx;</a>
<a name="ln2811">}</a>
<a name="ln2812"> </a>
<a name="ln2813">/// &quot;tolower(string)&quot; function</a>
<a name="ln2814">void f_tolower(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2815">{</a>
<a name="ln2816">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2817">  rettv-&gt;vval.v_string = strcase_save(tv_get_string(&amp;argvars[0]), false);</a>
<a name="ln2818">}</a>
<a name="ln2819"> </a>
<a name="ln2820">/// &quot;toupper(string)&quot; function</a>
<a name="ln2821">void f_toupper(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2822">{</a>
<a name="ln2823">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2824">  rettv-&gt;vval.v_string = strcase_save(tv_get_string(&amp;argvars[0]), true);</a>
<a name="ln2825">}</a>
<a name="ln2826"> </a>
<a name="ln2827">/// &quot;tr(string, fromstr, tostr)&quot; function</a>
<a name="ln2828">void f_tr(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2829">{</a>
<a name="ln2830">  char buf[NUMBUFLEN];</a>
<a name="ln2831">  char buf2[NUMBUFLEN];</a>
<a name="ln2832"> </a>
<a name="ln2833">  const char *in_str = tv_get_string(&amp;argvars[0]);</a>
<a name="ln2834">  const char *fromstr = tv_get_string_buf_chk(&amp;argvars[1], buf);</a>
<a name="ln2835">  const char *tostr = tv_get_string_buf_chk(&amp;argvars[2], buf2);</a>
<a name="ln2836"> </a>
<a name="ln2837">  // Default return value: empty string.</a>
<a name="ln2838">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2839">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2840">  if (fromstr == NULL || tostr == NULL) {</a>
<a name="ln2841">    return;  // Type error; errmsg already given.</a>
<a name="ln2842">  }</a>
<a name="ln2843">  garray_T ga;</a>
<a name="ln2844">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln2845"> </a>
<a name="ln2846">  // fromstr and tostr have to contain the same number of chars.</a>
<a name="ln2847">  bool first = true;</a>
<a name="ln2848">  while (*in_str != NUL) {</a>
<a name="ln2849">    const char *cpstr = in_str;</a>
<a name="ln2850">    const int inlen = utfc_ptr2len(in_str);</a>
<a name="ln2851">    int cplen = inlen;</a>
<a name="ln2852">    int idx = 0;</a>
<a name="ln2853">    int fromlen;</a>
<a name="ln2854">    for (const char *p = fromstr; *p != NUL; p += fromlen) {</a>
<a name="ln2855">      fromlen = utfc_ptr2len(p);</a>
<a name="ln2856">      if (fromlen == inlen &amp;&amp; strncmp(in_str, p, (size_t)inlen) == 0) {</a>
<a name="ln2857">        int tolen;</a>
<a name="ln2858">        for (p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln2859">          tolen = utfc_ptr2len(p);</a>
<a name="ln2860">          if (idx-- == 0) {</a>
<a name="ln2861">            cplen = tolen;</a>
<a name="ln2862">            cpstr = p;</a>
<a name="ln2863">            break;</a>
<a name="ln2864">          }</a>
<a name="ln2865">        }</a>
<a name="ln2866">        if (*p == NUL) {  // tostr is shorter than fromstr.</a>
<a name="ln2867">          goto error;</a>
<a name="ln2868">        }</a>
<a name="ln2869">        break;</a>
<a name="ln2870">      }</a>
<a name="ln2871">      idx++;</a>
<a name="ln2872">    }</a>
<a name="ln2873"> </a>
<a name="ln2874">    if (first &amp;&amp; cpstr == in_str) {</a>
<a name="ln2875">      // Check that fromstr and tostr have the same number of</a>
<a name="ln2876">      // (multi-byte) characters.  Done only once when a character</a>
<a name="ln2877">      // of in_str doesn't appear in fromstr.</a>
<a name="ln2878">      first = false;</a>
<a name="ln2879">      int tolen;</a>
<a name="ln2880">      for (const char *p = tostr; *p != NUL; p += tolen) {</a>
<a name="ln2881">        tolen = utfc_ptr2len(p);</a>
<a name="ln2882">        idx--;</a>
<a name="ln2883">      }</a>
<a name="ln2884">      if (idx != 0) {</a>
<a name="ln2885">        goto error;</a>
<a name="ln2886">      }</a>
<a name="ln2887">    }</a>
<a name="ln2888"> </a>
<a name="ln2889">    ga_grow(&amp;ga, cplen);</a>
<a name="ln2890">    memmove((char *)ga.ga_data + ga.ga_len, cpstr, (size_t)cplen);</a>
<a name="ln2891">    ga.ga_len += cplen;</a>
<a name="ln2892"> </a>
<a name="ln2893">    in_str += inlen;</a>
<a name="ln2894">  }</a>
<a name="ln2895"> </a>
<a name="ln2896">  // add a terminating NUL</a>
<a name="ln2897">  ga_append(&amp;ga, NUL);</a>
<a name="ln2898"> </a>
<a name="ln2899">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln2900">  return;</a>
<a name="ln2901">error:</a>
<a name="ln2902">  semsg(_(e_invarg2), fromstr);</a>
<a name="ln2903">  ga_clear(&amp;ga);</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">/// &quot;trim({expr})&quot; function</a>
<a name="ln2907">void f_trim(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2908">{</a>
<a name="ln2909">  char buf1[NUMBUFLEN];</a>
<a name="ln2910">  char buf2[NUMBUFLEN];</a>
<a name="ln2911">  const char *head = tv_get_string_buf_chk(&amp;argvars[0], buf1);</a>
<a name="ln2912">  const char *mask = NULL;</a>
<a name="ln2913">  const char *prev;</a>
<a name="ln2914">  const char *p;</a>
<a name="ln2915">  int dir = 0;</a>
<a name="ln2916"> </a>
<a name="ln2917">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln2918">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln2919">  if (head == NULL) {</a>
<a name="ln2920">    return;</a>
<a name="ln2921">  }</a>
<a name="ln2922"> </a>
<a name="ln2923">  if (tv_check_for_opt_string_arg(argvars, 1) == FAIL) {</a>
<a name="ln2924">    return;</a>
<a name="ln2925">  }</a>
<a name="ln2926"> </a>
<a name="ln2927">  if (argvars[1].v_type == VAR_STRING) {</a>
<a name="ln2928">    mask = tv_get_string_buf_chk(&amp;argvars[1], buf2);</a>
<a name="ln2929">    if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln2930">      bool error = false;</a>
<a name="ln2931">      // leading or trailing characters to trim</a>
<a name="ln2932">      dir = (int)tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln2933">      if (error) {</a>
<a name="ln2934">        return;</a>
<a name="ln2935">      }</a>
<a name="ln2936">      if (dir &lt; 0 || dir &gt; 2) {</a>
<a name="ln2937">        semsg(_(e_invarg2), tv_get_string(&amp;argvars[2]));</a>
<a name="ln2938">        return;</a>
<a name="ln2939">      }</a>
<a name="ln2940">    }</a>
<a name="ln2941">  }</a>
<a name="ln2942"> </a>
<a name="ln2943">  int c1;</a>
<a name="ln2944">  if (dir == 0 || dir == 1) {</a>
<a name="ln2945">    // Trim leading characters</a>
<a name="ln2946">    while (*head != NUL) {</a>
<a name="ln2947">      c1 = utf_ptr2char(head);</a>
<a name="ln2948">      if (mask == NULL) {</a>
<a name="ln2949">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln2950">          break;</a>
<a name="ln2951">        }</a>
<a name="ln2952">      } else {</a>
<a name="ln2953">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2954">          if (c1 == utf_ptr2char(p)) {</a>
<a name="ln2955">            break;</a>
<a name="ln2956">          }</a>
<a name="ln2957">        }</a>
<a name="ln2958">        if (*p == NUL) {</a>
<a name="ln2959">          break;</a>
<a name="ln2960">        }</a>
<a name="ln2961">      }</a>
<a name="ln2962">      MB_PTR_ADV(head);</a>
<a name="ln2963">    }</a>
<a name="ln2964">  }</a>
<a name="ln2965"> </a>
<a name="ln2966">  const char *tail = head + strlen(head);</a>
<a name="ln2967">  if (dir == 0 || dir == 2) {</a>
<a name="ln2968">    // Trim trailing characters</a>
<a name="ln2969">    for (; tail &gt; head; tail = prev) {</a>
<a name="ln2970">      prev = tail;</a>
<a name="ln2971">      MB_PTR_BACK(head, prev);</a>
<a name="ln2972">      c1 = utf_ptr2char(prev);</a>
<a name="ln2973">      if (mask == NULL) {</a>
<a name="ln2974">        if (c1 &gt; ' ' &amp;&amp; c1 != 0xa0) {</a>
<a name="ln2975">          break;</a>
<a name="ln2976">        }</a>
<a name="ln2977">      } else {</a>
<a name="ln2978">        for (p = mask; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2979">          if (c1 == utf_ptr2char(p)) {</a>
<a name="ln2980">            break;</a>
<a name="ln2981">          }</a>
<a name="ln2982">        }</a>
<a name="ln2983">        if (*p == NUL) {</a>
<a name="ln2984">          break;</a>
<a name="ln2985">        }</a>
<a name="ln2986">      }</a>
<a name="ln2987">    }</a>
<a name="ln2988">  }</a>
<a name="ln2989">  rettv-&gt;vval.v_string = xstrnsave(head, (size_t)(tail - head));</a>
<a name="ln2990">}</a>
</code></pre>
<div class="balloon" rel="706"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="724"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2153"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2165"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>