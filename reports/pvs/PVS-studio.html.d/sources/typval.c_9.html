<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>typval.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;stdbool.h&gt;</a>
<a name="ln6">#include &lt;stddef.h&gt;</a>
<a name="ln7">#include &lt;stdio.h&gt;</a>
<a name="ln8">#include &lt;stdlib.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;lauxlib.h&quot;</a>
<a name="ln12">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln13">#include &quot;nvim/assert.h&quot;</a>
<a name="ln14">#include &quot;nvim/charset.h&quot;</a>
<a name="ln15">#include &quot;nvim/eval.h&quot;</a>
<a name="ln16">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln17">#include &quot;nvim/eval/executor.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval/gc.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/typval_encode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln23">#include &quot;nvim/garray.h&quot;</a>
<a name="ln24">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln25">#include &quot;nvim/globals.h&quot;</a>
<a name="ln26">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln27">#include &quot;nvim/lib/queue.h&quot;</a>
<a name="ln28">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln29">#include &quot;nvim/macros.h&quot;</a>
<a name="ln30">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte_defs.h&quot;</a>
<a name="ln32">#include &quot;nvim/memory.h&quot;</a>
<a name="ln33">#include &quot;nvim/message.h&quot;</a>
<a name="ln34">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln35">#include &quot;nvim/pos.h&quot;</a>
<a name="ln36">#include &quot;nvim/strings.h&quot;</a>
<a name="ln37">#include &quot;nvim/types.h&quot;</a>
<a name="ln38">#include &quot;nvim/vim.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">/// struct storing information about current sort</a>
<a name="ln41">typedef struct {</a>
<a name="ln42">  int item_compare_ic;</a>
<a name="ln43">  bool item_compare_lc;</a>
<a name="ln44">  bool item_compare_numeric;</a>
<a name="ln45">  bool item_compare_numbers;</a>
<a name="ln46">  bool item_compare_float;</a>
<a name="ln47">  const char *item_compare_func;</a>
<a name="ln48">  partial_T *item_compare_partial;</a>
<a name="ln49">  dict_T *item_compare_selfdict;</a>
<a name="ln50">  bool item_compare_func_err;</a>
<a name="ln51">} sortinfo_T;</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln54"># include &quot;eval/typval.c.generated.h&quot;</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">static const char e_variable_nested_too_deep_for_unlock[]</a>
<a name="ln58">  = N_(&quot;E743: Variable nested too deep for (un)lock&quot;);</a>
<a name="ln59">static const char e_using_invalid_value_as_string[]</a>
<a name="ln60">  = N_(&quot;E908: Using an invalid value as a String&quot;);</a>
<a name="ln61">static const char e_string_required_for_argument_nr[]</a>
<a name="ln62">  = N_(&quot;E1174: String required for argument %d&quot;);</a>
<a name="ln63">static const char e_non_empty_string_required_for_argument_nr[]</a>
<a name="ln64">  = N_(&quot;E1175: Non-empty string required for argument %d&quot;);</a>
<a name="ln65">static const char e_dict_required_for_argument_nr[]</a>
<a name="ln66">  = N_(&quot;E1206: Dictionary required for argument %d&quot;);</a>
<a name="ln67">static const char e_number_required_for_argument_nr[]</a>
<a name="ln68">  = N_(&quot;E1210: Number required for argument %d&quot;);</a>
<a name="ln69">static const char e_list_required_for_argument_nr[]</a>
<a name="ln70">  = N_(&quot;E1211: List required for argument %d&quot;);</a>
<a name="ln71">static const char e_bool_required_for_argument_nr[]</a>
<a name="ln72">  = N_(&quot;E1212: Bool required for argument %d&quot;);</a>
<a name="ln73">static const char e_float_or_number_required_for_argument_nr[]</a>
<a name="ln74">  = N_(&quot;E1219: Float or Number required for argument %d&quot;);</a>
<a name="ln75">static const char e_string_or_number_required_for_argument_nr[]</a>
<a name="ln76">  = N_(&quot;E1220: String or Number required for argument %d&quot;);</a>
<a name="ln77">static const char e_string_or_list_required_for_argument_nr[]</a>
<a name="ln78">  = N_(&quot;E1222: String or List required for argument %d&quot;);</a>
<a name="ln79">static const char e_list_or_blob_required_for_argument_nr[]</a>
<a name="ln80">  = N_(&quot;E1226: List or Blob required for argument %d&quot;);</a>
<a name="ln81">static const char e_blob_required_for_argument_nr[]</a>
<a name="ln82">  = N_(&quot;E1238: Blob required for argument %d&quot;);</a>
<a name="ln83">static const char e_invalid_value_for_blob_nr[]</a>
<a name="ln84">  = N_(&quot;E1239: Invalid value for blob: %d&quot;);</a>
<a name="ln85">static const char e_string_list_or_blob_required_for_argument_nr[]</a>
<a name="ln86">  = N_(&quot;E1252: String, List or Blob required for argument %d&quot;);</a>
<a name="ln87">static const char e_string_or_function_required_for_argument_nr[]</a>
<a name="ln88">  = N_(&quot;E1256: String or function required for argument %d&quot;);</a>
<a name="ln89">static const char e_non_null_dict_required_for_argument_nr[]</a>
<a name="ln90">  = N_(&quot;E1297: Non-NULL Dictionary required for argument %d&quot;);</a>
<a name="ln91"> </a>
<a name="ln92">bool tv_in_free_unref_items = false;</a>
<a name="ln93"> </a>
<a name="ln94">// TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead</a>
<a name="ln95"> </a>
<a name="ln96">#define DICT_MAXNEST 100</a>
<a name="ln97"> </a>
<a name="ln98">const char *const tv_empty_string = &quot;&quot;;</a>
<a name="ln99"> </a>
<a name="ln100">//{{{1 Lists</a>
<a name="ln101">//{{{2 List item</a>
<a name="ln102"> </a>
<a name="ln103">/// Allocate a list item</a>
<a name="ln104">///</a>
<a name="ln105">/// @warning Allocated item is not initialized, do not forget to initialize it</a>
<a name="ln106">///          and specifically set lv_lock.</a>
<a name="ln107">///</a>
<a name="ln108">/// @return [allocated] new list item.</a>
<a name="ln109">static listitem_T *tv_list_item_alloc(void)</a>
<a name="ln110">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC</a>
<a name="ln111">{</a>
<a name="ln112">  return xmalloc(sizeof(listitem_T));</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/// Remove a list item from a List and free it</a>
<a name="ln116">///</a>
<a name="ln117">/// Also clears the value.</a>
<a name="ln118">///</a>
<a name="ln119">/// @param[out]  l  List to remove item from.</a>
<a name="ln120">/// @param[in,out]  item  Item to remove.</a>
<a name="ln121">///</a>
<a name="ln122">/// @return Pointer to the list item just after removed one, NULL if removed</a>
<a name="ln123">///         item was the last one.</a>
<a name="ln124">listitem_T *tv_list_item_remove(list_T *const l, listitem_T *const item)</a>
<a name="ln125">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln126">{</a>
<a name="ln127">  listitem_T *const next_item = TV_LIST_ITEM_NEXT(l, item);</a>
<a name="ln128">  tv_list_drop_items(l, item, item);</a>
<a name="ln129">  tv_clear(TV_LIST_ITEM_TV(item));</a>
<a name="ln130">  xfree(item);</a>
<a name="ln131">  return next_item;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">//{{{2 List watchers</a>
<a name="ln135"> </a>
<a name="ln136">/// Add a watcher to a list</a>
<a name="ln137">///</a>
<a name="ln138">/// @param[out]  l  List to add watcher to.</a>
<a name="ln139">/// @param[in]  lw  Watcher to add.</a>
<a name="ln140">void tv_list_watch_add(list_T *const l, listwatch_T *const lw)</a>
<a name="ln141">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln142">{</a>
<a name="ln143">  lw-&gt;lw_next = l-&gt;lv_watch;</a>
<a name="ln144">  l-&gt;lv_watch = lw;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">/// Remove a watcher from a list</a>
<a name="ln148">///</a>
<a name="ln149">/// Does not give a warning if watcher was not found.</a>
<a name="ln150">///</a>
<a name="ln151">/// @param[out]  l  List to remove watcher from.</a>
<a name="ln152">/// @param[in]  lwrem  Watcher to remove.</a>
<a name="ln153">void tv_list_watch_remove(list_T *const l, listwatch_T *const lwrem)</a>
<a name="ln154">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln155">{</a>
<a name="ln156">  listwatch_T **lwp = &amp;l-&gt;lv_watch;</a>
<a name="ln157">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln158">    if (lw == lwrem) {</a>
<a name="ln159">      *lwp = lw-&gt;lw_next;</a>
<a name="ln160">      break;</a>
<a name="ln161">    }</a>
<a name="ln162">    lwp = &amp;lw-&gt;lw_next;</a>
<a name="ln163">  }</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">/// Advance watchers to the next item</a>
<a name="ln167">///</a>
<a name="ln168">/// Used just before removing an item from a list.</a>
<a name="ln169">///</a>
<a name="ln170">/// @param[out]  l  List from which item is removed.</a>
<a name="ln171">/// @param[in]  item  List item being removed.</a>
<a name="ln172">void tv_list_watch_fix(list_T *const l, const listitem_T *const item)</a>
<a name="ln173">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln174">{</a>
<a name="ln175">  for (listwatch_T *lw = l-&gt;lv_watch; lw != NULL; lw = lw-&gt;lw_next) {</a>
<a name="ln176">    if (lw-&gt;lw_item == item) {</a>
<a name="ln177">      lw-&gt;lw_item = item-&gt;li_next;</a>
<a name="ln178">    }</a>
<a name="ln179">  }</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">//{{{2 Alloc/free</a>
<a name="ln183"> </a>
<a name="ln184">/// Allocate an empty list</a>
<a name="ln185">///</a>
<a name="ln186">/// Caller should take care of the reference count.</a>
<a name="ln187">///</a>
<a name="ln188">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln189">///                  becomes accessible from Vimscript. It is still valid to</a>
<a name="ln190">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln191">///                  will be allocated in advance. Currently does nothing.</a>
<a name="ln192">///                  @see ListLenSpecials.</a>
<a name="ln193">///</a>
<a name="ln194">/// @return [allocated] new list.</a>
<a name="ln195">list_T *tv_list_alloc(const ptrdiff_t len)</a>
<a name="ln196">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln197">{</a>
<a name="ln198">  list_T *const list = xcalloc(1, sizeof(list_T));</a>
<a name="ln199"> </a>
<a name="ln200">  // Prepend the list to the list of lists for garbage collection.</a>
<a name="ln201">  if (gc_first_list != NULL) {</a>
<a name="ln202">    gc_first_list-&gt;lv_used_prev = list;</a>
<a name="ln203">  }</a>
<a name="ln204">  list-&gt;lv_used_prev = NULL;</a>
<a name="ln205">  list-&gt;lv_used_next = gc_first_list;</a>
<a name="ln206">  gc_first_list = list;</a>
<a name="ln207">  list-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln208">  return list;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">/// Initialize a static list with 10 items</a>
<a name="ln212">///</a>
<a name="ln213">/// @param[out]  sl  Static list to initialize.</a>
<a name="ln214">void tv_list_init_static10(staticList10_T *const sl)</a>
<a name="ln215">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln216">{</a>
<a name="ln217">#define SL_SIZE ARRAY_SIZE(sl-&gt;sl_items)</a>
<a name="ln218">  list_T *const l = &amp;sl-&gt;sl_list;</a>
<a name="ln219"> </a>
<a name="ln220">  CLEAR_POINTER(sl);</a>
<a name="ln221">  l-&gt;lv_first = &amp;sl-&gt;sl_items[0];</a>
<a name="ln222">  l-&gt;lv_last = &amp;sl-&gt;sl_items[SL_SIZE - 1];</a>
<a name="ln223">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln224">  tv_list_set_lock(l, VAR_FIXED);</a>
<a name="ln225">  sl-&gt;sl_list.lv_len = 10;</a>
<a name="ln226"> </a>
<a name="ln227">  sl-&gt;sl_items[0].li_prev = NULL;</a>
<a name="ln228">  sl-&gt;sl_items[0].li_next = &amp;sl-&gt;sl_items[1];</a>
<a name="ln229">  sl-&gt;sl_items[SL_SIZE - 1].li_prev = &amp;sl-&gt;sl_items[SL_SIZE - 2];</a>
<a name="ln230">  sl-&gt;sl_items[SL_SIZE - 1].li_next = NULL;</a>
<a name="ln231"> </a>
<a name="ln232">  for (size_t i = 1; i &lt; SL_SIZE - 1; i++) {</a>
<a name="ln233">    listitem_T *const li = &amp;sl-&gt;sl_items[i];</a>
<a name="ln234">    li-&gt;li_prev = li - 1;</a>
<a name="ln235">    li-&gt;li_next = li + 1;</a>
<a name="ln236">  }</a>
<a name="ln237">#undef SL_SIZE</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/// Initialize static list with undefined number of elements</a>
<a name="ln241">///</a>
<a name="ln242">/// @param[out]  l  List to initialize.</a>
<a name="ln243">void tv_list_init_static(list_T *const l)</a>
<a name="ln244">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln245">{</a>
<a name="ln246">  CLEAR_POINTER(l);</a>
<a name="ln247">  l-&gt;lv_refcount = DO_NOT_FREE_CNT;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">/// Free items contained in a list</a>
<a name="ln251">///</a>
<a name="ln252">/// @param[in,out]  l  List to clear.</a>
<a name="ln253">void tv_list_free_contents(list_T *const l)</a>
<a name="ln254">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln255">{</a>
<a name="ln256">  for (listitem_T *item = l-&gt;lv_first; item != NULL; item = l-&gt;lv_first) {</a>
<a name="ln257">    // Remove the item before deleting it.</a>
<a name="ln258">    l-&gt;lv_first = item-&gt;li_next;</a>
<a name="ln259">    tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln260">    xfree(item);</a>
<a name="ln261">  }</a>
<a name="ln262">  l-&gt;lv_len = 0;</a>
<a name="ln263">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln264">  l-&gt;lv_last = NULL;</a>
<a name="ln265">  assert(l-&gt;lv_watch == NULL);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/// Free a list itself, ignoring items it contains</a>
<a name="ln269">///</a>
<a name="ln270">/// Ignores the reference count.</a>
<a name="ln271">///</a>
<a name="ln272">/// @param[in,out]  l  List to free.</a>
<a name="ln273">void tv_list_free_list(list_T *const l)</a>
<a name="ln274">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln275">{</a>
<a name="ln276">  // Remove the list from the list of lists for garbage collection.</a>
<a name="ln277">  if (l-&gt;lv_used_prev == NULL) {</a>
<a name="ln278">    gc_first_list = l-&gt;lv_used_next;</a>
<a name="ln279">  } else {</a>
<a name="ln280">    l-&gt;lv_used_prev-&gt;lv_used_next = l-&gt;lv_used_next;</a>
<a name="ln281">  }</a>
<a name="ln282">  if (l-&gt;lv_used_next != NULL) {</a>
<a name="ln283">    l-&gt;lv_used_next-&gt;lv_used_prev = l-&gt;lv_used_prev;</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  NLUA_CLEAR_REF(l-&gt;lua_table_ref);</a>
<a name="ln287">  xfree(l);</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/// Free a list, including all items it points to</a>
<a name="ln291">///</a>
<a name="ln292">/// Ignores the reference count. Does not do anything if</a>
<a name="ln293">/// tv_in_free_unref_items is true.</a>
<a name="ln294">///</a>
<a name="ln295">/// @param[in,out]  l  List to free.</a>
<a name="ln296">void tv_list_free(list_T *const l)</a>
<a name="ln297">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln298">{</a>
<a name="ln299">  if (tv_in_free_unref_items) {</a>
<a name="ln300">    return;</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  tv_list_free_contents(l);</a>
<a name="ln304">  tv_list_free_list(l);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/// Unreference a list</a>
<a name="ln308">///</a>
<a name="ln309">/// Decrements the reference count and frees when it becomes zero or less.</a>
<a name="ln310">///</a>
<a name="ln311">/// @param[in,out]  l  List to unreference.</a>
<a name="ln312">void tv_list_unref(list_T *const l)</a>
<a name="ln313">{</a>
<a name="ln314">  if (l != NULL &amp;&amp; --l-&gt;lv_refcount &lt;= 0) {</a>
<a name="ln315">    tv_list_free(l);</a>
<a name="ln316">  }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">//{{{2 Add/remove</a>
<a name="ln320"> </a>
<a name="ln321">/// Remove items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot;</a>
<a name="ln322">///</a>
<a name="ln323">/// @warning Does not free the listitem or the value!</a>
<a name="ln324">///</a>
<a name="ln325">/// @param[out]  l  List to remove from.</a>
<a name="ln326">/// @param[in]  item  First item to remove.</a>
<a name="ln327">/// @param[in]  item2  Last item to remove.</a>
<a name="ln328">void tv_list_drop_items(list_T *const l, listitem_T *const item, listitem_T *const item2)</a>
<a name="ln329">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln330">{</a>
<a name="ln331">  // Notify watchers.</a>
<a name="ln332">  for (listitem_T *ip = item; ip != item2-&gt;li_next; ip = ip-&gt;li_next) {</a>
<a name="ln333">    l-&gt;lv_len--;</a>
<a name="ln334">    tv_list_watch_fix(l, ip);</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  if (item2-&gt;li_next == NULL) {</a>
<a name="ln338">    l-&gt;lv_last = item-&gt;li_prev;</a>
<a name="ln339">  } else {</a>
<a name="ln340">    item2-&gt;li_next-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln341">  }</a>
<a name="ln342">  if (item-&gt;li_prev == NULL) {</a>
<a name="ln343">    l-&gt;lv_first = item2-&gt;li_next;</a>
<a name="ln344">  } else {</a>
<a name="ln345">    item-&gt;li_prev-&gt;li_next = item2-&gt;li_next;</a>
<a name="ln346">  }</a>
<a name="ln347">  l-&gt;lv_idx_item = NULL;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">/// Like tv_list_drop_items, but also frees all removed items</a>
<a name="ln351">void tv_list_remove_items(list_T *const l, listitem_T *const item, listitem_T *const item2)</a>
<a name="ln352">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln353">{</a>
<a name="ln354">  tv_list_drop_items(l, item, item2);</a>
<a name="ln355">  for (listitem_T *li = item;;) {</a>
<a name="ln356">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln357">    listitem_T *const nli = li-&gt;li_next;</a>
<a name="ln358">    xfree(li);</a>
<a name="ln359">    if (li == item2) {</a>
<a name="ln360">      break;</a>
<a name="ln361">    }</a>
<a name="ln362">    li = nli;</a>
<a name="ln363">  }</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">/// Move items &quot;item&quot; to &quot;item2&quot; from list &quot;l&quot; to the end of the list &quot;tgt_l&quot;</a>
<a name="ln367">///</a>
<a name="ln368">/// @param[out]  l  List to move from.</a>
<a name="ln369">/// @param[in]  item  First item to move.</a>
<a name="ln370">/// @param[in]  item2  Last item to move.</a>
<a name="ln371">/// @param[out]  tgt_l  List to move to.</a>
<a name="ln372">/// @param[in]  cnt  Number of items moved.</a>
<a name="ln373">void tv_list_move_items(list_T *const l, listitem_T *const item, listitem_T *const item2,</a>
<a name="ln374">                        list_T *const tgt_l, const int cnt)</a>
<a name="ln375">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln376">{</a>
<a name="ln377">  tv_list_drop_items(l, item, item2);</a>
<a name="ln378">  item-&gt;li_prev = tgt_l-&gt;lv_last;</a>
<a name="ln379">  item2-&gt;li_next = NULL;</a>
<a name="ln380">  if (tgt_l-&gt;lv_last == NULL) {</a>
<a name="ln381">    tgt_l-&gt;lv_first = item;</a>
<a name="ln382">  } else {</a>
<a name="ln383">    tgt_l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln384">  }</a>
<a name="ln385">  tgt_l-&gt;lv_last = item2;</a>
<a name="ln386">  tgt_l-&gt;lv_len += cnt;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">/// Insert list item</a>
<a name="ln390">///</a>
<a name="ln391">/// @param[out]  l  List to insert to.</a>
<a name="ln392">/// @param[in,out]  ni  Item to insert.</a>
<a name="ln393">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln394">///                   list.</a>
<a name="ln395">void tv_list_insert(list_T *const l, listitem_T *const ni, listitem_T *const item)</a>
<a name="ln396">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln397">{</a>
<a name="ln398">  if (item == NULL) {</a>
<a name="ln399">    // Append new item at end of list.</a>
<a name="ln400">    tv_list_append(l, ni);</a>
<a name="ln401">  } else {</a>
<a name="ln402">    // Insert new item before existing item.</a>
<a name="ln403">    ni-&gt;li_prev = item-&gt;li_prev;</a>
<a name="ln404">    ni-&gt;li_next = item;</a>
<a name="ln405">    if (item-&gt;li_prev == NULL) {</a>
<a name="ln406">      l-&gt;lv_first = ni;</a>
<a name="ln407">      l-&gt;lv_idx++;</a>
<a name="ln408">    } else {</a>
<a name="ln409">      item-&gt;li_prev-&gt;li_next = ni;</a>
<a name="ln410">      l-&gt;lv_idx_item = NULL;</a>
<a name="ln411">    }</a>
<a name="ln412">    item-&gt;li_prev = ni;</a>
<a name="ln413">    l-&gt;lv_len++;</a>
<a name="ln414">  }</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">/// Insert Vimscript value into a list</a>
<a name="ln418">///</a>
<a name="ln419">/// @param[out]  l  List to insert to.</a>
<a name="ln420">/// @param[in,out]  tv  Value to insert. Is copied (@see tv_copy()) to an</a>
<a name="ln421">///                     allocated listitem_T and inserted.</a>
<a name="ln422">/// @param[in]  item  Item to insert before. If NULL, inserts at the end of the</a>
<a name="ln423">///                   list.</a>
<a name="ln424">void tv_list_insert_tv(list_T *const l, typval_T *const tv, listitem_T *const item)</a>
<a name="ln425">{</a>
<a name="ln426">  listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln427"> </a>
<a name="ln428">  tv_copy(tv, &amp;ni-&gt;li_tv);</a>
<a name="ln429">  tv_list_insert(l, ni, item);</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">/// Append item to the end of list</a>
<a name="ln433">///</a>
<a name="ln434">/// @param[out]  l  List to append to.</a>
<a name="ln435">/// @param[in,out]  item  Item to append.</a>
<a name="ln436">void tv_list_append(list_T *const l, listitem_T *const item)</a>
<a name="ln437">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln438">{</a>
<a name="ln439">  if (l-&gt;lv_last == NULL) {</a>
<a name="ln440">    // empty list</a>
<a name="ln441">    l-&gt;lv_first = item;</a>
<a name="ln442">    l-&gt;lv_last = item;</a>
<a name="ln443">    item-&gt;li_prev = NULL;</a>
<a name="ln444">  } else {</a>
<a name="ln445">    l-&gt;lv_last-&gt;li_next = item;</a>
<a name="ln446">    item-&gt;li_prev = l-&gt;lv_last;</a>
<a name="ln447">    l-&gt;lv_last = item;</a>
<a name="ln448">  }</a>
<a name="ln449">  l-&gt;lv_len++;</a>
<a name="ln450">  item-&gt;li_next = NULL;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/// Append Vimscript value to the end of list</a>
<a name="ln454">///</a>
<a name="ln455">/// @param[out]  l  List to append to.</a>
<a name="ln456">/// @param[in,out]  tv  Value to append. Is copied (@see tv_copy()) to an</a>
<a name="ln457">///                     allocated listitem_T.</a>
<a name="ln458">void tv_list_append_tv(list_T *const l, typval_T *const tv)</a>
<a name="ln459">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln460">{</a>
<a name="ln461">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln462">  tv_copy(tv, TV_LIST_ITEM_TV(li));</a>
<a name="ln463">  tv_list_append(l, li);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">/// Like tv_list_append_tv(), but tv is moved to a list</a>
<a name="ln467">///</a>
<a name="ln468">/// This means that it is no longer valid to use contents of the typval_T after</a>
<a name="ln469">/// function exits.</a>
<a name="ln470">void tv_list_append_owned_tv(list_T *const l, typval_T tv)</a>
<a name="ln471">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln472">{</a>
<a name="ln473">  listitem_T *const li = tv_list_item_alloc();</a>
<a name="ln474">  *TV_LIST_ITEM_TV(li) = tv;</a>
<a name="ln475">  tv_list_append(l, li);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">/// Append a list to a list as one item</a>
<a name="ln479">///</a>
<a name="ln480">/// @param[out]  l  List to append to.</a>
<a name="ln481">/// @param[in,out]  itemlist  List to append. Reference count is increased.</a>
<a name="ln482">void tv_list_append_list(list_T *const l, list_T *const itemlist)</a>
<a name="ln483">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln484">{</a>
<a name="ln485">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln486">    .v_type = VAR_LIST,</a>
<a name="ln487">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln488">    .vval.v_list = itemlist,</a>
<a name="ln489">  });</a>
<a name="ln490">  tv_list_ref(itemlist);</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">/// Append a dictionary to a list</a>
<a name="ln494">///</a>
<a name="ln495">/// @param[out]  l  List to append to.</a>
<a name="ln496">/// @param[in,out]  dict  Dictionary to append. Reference count is increased.</a>
<a name="ln497">void tv_list_append_dict(list_T *const l, dict_T *const dict)</a>
<a name="ln498">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln499">{</a>
<a name="ln500">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln501">    .v_type = VAR_DICT,</a>
<a name="ln502">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln503">    .vval.v_dict = dict,</a>
<a name="ln504">  });</a>
<a name="ln505">  if (dict != NULL) {</a>
<a name="ln506">    dict-&gt;dv_refcount++;</a>
<a name="ln507">  }</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">/// Make a copy of &quot;str&quot; and append it as an item to list &quot;l&quot;</a>
<a name="ln511">///</a>
<a name="ln512">/// @param[out]  l  List to append to.</a>
<a name="ln513">/// @param[in]  str  String to append.</a>
<a name="ln514">/// @param[in]  len  Length of the appended string. May be -1, in this</a>
<a name="ln515">///                  case string is considered to be usual zero-terminated</a>
<a name="ln516">///                  string or NULL “empty” string.</a>
<a name="ln517">void tv_list_append_string(list_T *const l, const char *const str, const ssize_t len)</a>
<a name="ln518">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln519">{</a>
<a name="ln520">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln521">    .v_type = VAR_STRING,</a>
<a name="ln522">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln523">    .vval.v_string = (str == NULL</a>
<a name="ln524">                      ? NULL</a>
<a name="ln525">                      : (len &gt;= 0</a>
<a name="ln526">                         ? xmemdupz(str, (size_t)len)</a>
<a name="ln527">                         : xstrdup(str))),</a>
<a name="ln528">  });</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">/// Append given string to the list</a>
<a name="ln532">///</a>
<a name="ln533">/// Unlike list_append_string this function does not copy the string.</a>
<a name="ln534">///</a>
<a name="ln535">/// @param[out]  l    List to append to.</a>
<a name="ln536">/// @param[in]   str  String to append.</a>
<a name="ln537">void tv_list_append_allocated_string(list_T *const l, char *const str)</a>
<a name="ln538">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln539">{</a>
<a name="ln540">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln541">    .v_type = VAR_STRING,</a>
<a name="ln542">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln543">    .vval.v_string = str,</a>
<a name="ln544">  });</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">/// Append number to the list</a>
<a name="ln548">///</a>
<a name="ln549">/// @param[out]  l  List to append to.</a>
<a name="ln550">/// @param[in]  n  Number to append. Will be recorded in the allocated</a>
<a name="ln551">///                listitem_T.</a>
<a name="ln552">void tv_list_append_number(list_T *const l, const varnumber_T n)</a>
<a name="ln553">{</a>
<a name="ln554">  tv_list_append_owned_tv(l, (typval_T) {</a>
<a name="ln555">    .v_type = VAR_NUMBER,</a>
<a name="ln556">    .v_lock = VAR_UNLOCKED,</a>
<a name="ln557">    .vval.v_number = n,</a>
<a name="ln558">  });</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">//{{{2 Operations on the whole list</a>
<a name="ln562"> </a>
<a name="ln563">/// Make a copy of list</a>
<a name="ln564">///</a>
<a name="ln565">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln566">///                   Only used when `deep` is true.</a>
<a name="ln567">/// @param[in]  orig  Original list to copy.</a>
<a name="ln568">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln569">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln570">///</a>
<a name="ln571">/// @return Copied list. May be NULL in case original list is NULL or some</a>
<a name="ln572">///         failure happens. The refcount of the new list is set to 1.</a>
<a name="ln573">list_T *tv_list_copy(const vimconv_T *const conv, list_T *const orig, const bool deep,</a>
<a name="ln574">                     const int copyID)</a>
<a name="ln575">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln576">{</a>
<a name="ln577">  if (orig == NULL) {</a>
<a name="ln578">    return NULL;</a>
<a name="ln579">  }</a>
<a name="ln580"> </a>
<a name="ln581">  list_T *copy = tv_list_alloc(tv_list_len(orig));</a>
<a name="ln582">  tv_list_ref(copy);</a>
<a name="ln583">  if (copyID != 0) {</a>
<a name="ln584">    // Do this before adding the items, because one of the items may</a>
<a name="ln585">    // refer back to this list.</a>
<a name="ln586">    orig-&gt;lv_copyID = copyID;</a>
<a name="ln587">    orig-&gt;lv_copylist = copy;</a>
<a name="ln588">  }</a>
<a name="ln589">  TV_LIST_ITER(orig, item, {</a>
<a name="ln590">    if (got_int) {</a>
<a name="ln591">      break;</a>
<a name="ln592">    }</a>
<a name="ln593">    listitem_T *const ni = tv_list_item_alloc();</a>
<a name="ln594">    if (deep) {</a>
<a name="ln595">      if (var_item_copy(conv, TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni),</a>
<a name="ln596">                        deep, copyID) == FAIL) {</a>
<a name="ln597">        xfree(ni);</a>
<a name="ln598">        goto tv_list_copy_error;</a>
<a name="ln599">      }</a>
<a name="ln600">    } else {</a>
<a name="ln601">      tv_copy(TV_LIST_ITEM_TV(item), TV_LIST_ITEM_TV(ni));</a>
<a name="ln602">    }</a>
<a name="ln603">    tv_list_append(copy, ni);</a>
<a name="ln604">  });</a>
<a name="ln605"> </a>
<a name="ln606">  return copy;</a>
<a name="ln607"> </a>
<a name="ln608">tv_list_copy_error:</a>
<a name="ln609">  tv_list_unref(copy);</a>
<a name="ln610">  return NULL;</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/// Get the list item in &quot;l&quot; with index &quot;n1&quot;.  &quot;n1&quot; is adjusted if needed.</a>
<a name="ln614">/// Return NULL if there is no such item.</a>
<a name="ln615">listitem_T *tv_list_check_range_index_one(list_T *const l, long *const n1, const bool quiet)</a>
<a name="ln616">{</a>
<a name="ln617">  listitem_T *li = tv_list_find_index(l, n1);</a>
<a name="ln618">  if (li == NULL) {</a>
<a name="ln619">    if (!quiet) {</a>
<a name="ln620">      semsg(_(e_list_index_out_of_range_nr), (int64_t)n1);</a>
<a name="ln621">    }</a>
<a name="ln622">    return NULL;</a>
<a name="ln623">  }</a>
<a name="ln624">  return li;</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">/// Check that &quot;n2&quot; can be used as the second index in a range of list &quot;l&quot;.</a>
<a name="ln628">/// If &quot;n1&quot; or &quot;n2&quot; is negative it is changed to the positive index.</a>
<a name="ln629">/// &quot;li1&quot; is the item for item &quot;n1&quot;.</a>
<a name="ln630">/// Return OK or FAIL.</a>
<a name="ln631">int tv_list_check_range_index_two(list_T *const l, long *const n1, const listitem_T *const li1,</a>
<a name="ln632">                                  long *const n2, const bool quiet)</a>
<a name="ln633">{</a>
<a name="ln634">  if (*n2 &lt; 0) {</a>
<a name="ln635">    listitem_T *ni = tv_list_find(l, (int)(*n2));</a>
<a name="ln636">    if (ni == NULL) {</a>
<a name="ln637">      if (!quiet) {</a>
<a name="ln638">        semsg(_(e_list_index_out_of_range_nr), (int64_t)(*n2));</a>
<a name="ln639">      }</a>
<a name="ln640">      return FAIL;</a>
<a name="ln641">    }</a>
<a name="ln642">    *n2 = tv_list_idx_of_item(l, ni);</a>
<a name="ln643">  }</a>
<a name="ln644"> </a>
<a name="ln645">  // Check that n2 isn't before n1.</a>
<a name="ln646">  if (*n1 &lt; 0) {</a>
<a name="ln647">    *n1 = tv_list_idx_of_item(l, li1);</a>
<a name="ln648">  }</a>
<a name="ln649">  if (*n2 &lt; *n1) {</a>
<a name="ln650">    if (!quiet) {</a>
<a name="ln651">      semsg(_(e_list_index_out_of_range_nr), (int64_t)(*n2));</a>
<a name="ln652">    }</a>
<a name="ln653">    return FAIL;</a>
<a name="ln654">  }</a>
<a name="ln655">  return OK;</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">/// Assign values from list &quot;src&quot; into a range of &quot;dest&quot;.</a>
<a name="ln659">/// &quot;idx1_arg&quot; is the index of the first item in &quot;dest&quot; to be replaced.</a>
<a name="ln660">/// &quot;idx2&quot; is the index of last item to be replaced, but when &quot;empty_idx2&quot; is</a>
<a name="ln661">/// true then replace all items after &quot;idx1&quot;.</a>
<a name="ln662">/// &quot;op&quot; is the operator, normally &quot;=&quot; but can be &quot;+=&quot; and the like.</a>
<a name="ln663">/// &quot;varname&quot; is used for error messages.</a>
<a name="ln664">/// Returns OK or FAIL.</a>
<a name="ln665">int tv_list_assign_range(list_T *const dest, list_T *const src, const long idx1_arg,</a>
<a name="ln666">                         const long idx2, const bool empty_idx2, const char *const op,</a>
<a name="ln667">                         const char *const varname)</a>
<a name="ln668">{</a>
<a name="ln669">  long idx1 = idx1_arg;</a>
<a name="ln670">  listitem_T *const first_li = tv_list_find_index(dest, &amp;idx1);</a>
<a name="ln671">  listitem_T *src_li;</a>
<a name="ln672"> </a>
<a name="ln673">  // Check whether any of the list items is locked before making any changes.</a>
<a name="ln674">  long idx = idx1;</a>
<a name="ln675">  listitem_T *dest_li = first_li;</a>
<a name="ln676">  for (src_li = tv_list_first(src); src_li != NULL &amp;&amp; dest_li != NULL;) {</a>
<a name="ln677">    if (value_check_lock(TV_LIST_ITEM_TV(dest_li)-&gt;v_lock, varname, TV_CSTRING)) {</a>
<a name="ln678">      return FAIL;</a>
<a name="ln679">    }</a>
<a name="ln680">    src_li = TV_LIST_ITEM_NEXT(src, src_li);</a>
<a name="ln681">    if (src_li == NULL || (!empty_idx2 &amp;&amp; idx2 == idx)) {</a>
<a name="ln682">      break;</a>
<a name="ln683">    }</a>
<a name="ln684">    dest_li = TV_LIST_ITEM_NEXT(dest, dest_li);</a>
<a name="ln685">    idx++;</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">  // Assign the List values to the list items.</a>
<a name="ln689">  idx = idx1;</a>
<a name="ln690">  dest_li = first_li;</a>
<a name="ln691">  for (src_li = tv_list_first(src); src_li != NULL;) {</a>
<a name="ln692">    assert(dest_li != NULL);</a>
<a name="ln693">    if (op != NULL &amp;&amp; *op != '=') {</a>
<a name="ln694">      eexe_mod_op(TV_LIST_ITEM_TV(dest_li), TV_LIST_ITEM_TV(src_li), op);</a>
<a name="ln695">    } else {</a>
<a name="ln696">      tv_clear(TV_LIST_ITEM_TV(dest_li));</a>
<a name="ln697">      tv_copy(TV_LIST_ITEM_TV(src_li), TV_LIST_ITEM_TV(dest_li));</a>
<a name="ln698">    }</a>
<a name="ln699">    src_li = TV_LIST_ITEM_NEXT(src, src_li);</a>
<a name="ln700">    if (src_li == NULL || (!empty_idx2 &amp;&amp; idx2 == idx)) {</a>
<a name="ln701">      break;</a>
<a name="ln702">    }</a>
<a name="ln703">    if (TV_LIST_ITEM_NEXT(dest, dest_li) == NULL) {</a>
<a name="ln704">      // Need to add an empty item.</a>
<a name="ln705">      tv_list_append_number(dest, 0);</a>
<a name="ln706">      // &quot;dest_li&quot; may have become invalid after append, don’t use it.</a>
<a name="ln707">      dest_li = tv_list_last(dest);  // Valid again.</a>
<a name="ln708">    } else {</a>
<a name="ln709">      dest_li = TV_LIST_ITEM_NEXT(dest, dest_li);</a>
<a name="ln710">    }</a>
<a name="ln711">    idx++;</a>
<a name="ln712">  }</a>
<a name="ln713">  if (src_li != NULL) {</a>
<a name="ln714">    emsg(_(&quot;E710: List value has more items than target&quot;));</a>
<a name="ln715">    return FAIL;</a>
<a name="ln716">  }</a>
<a name="ln717">  if (empty_idx2</a>
<a name="ln718">      ? (dest_li != NULL &amp;&amp; TV_LIST_ITEM_NEXT(dest, dest_li) != NULL)</a>
<a name="ln719">      : idx != idx2) {</a>
<a name="ln720">    emsg(_(&quot;E711: List value has not enough items&quot;));</a>
<a name="ln721">    return FAIL;</a>
<a name="ln722">  }</a>
<a name="ln723">  return OK;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">/// Flatten up to &quot;maxitems&quot; in &quot;list&quot;, starting at &quot;first&quot; to depth &quot;maxdepth&quot;.</a>
<a name="ln727">/// When &quot;first&quot; is NULL use the first item.</a>
<a name="ln728">/// Does nothing if &quot;maxdepth&quot; is 0.</a>
<a name="ln729">///</a>
<a name="ln730">/// @param[in,out] list   List to flatten</a>
<a name="ln731">/// @param[in] maxdepth   Maximum depth that will be flattened</a>
<a name="ln732">///</a>
<a name="ln733">/// @return OK or FAIL</a>
<a name="ln734">void tv_list_flatten(list_T *list, listitem_T *first, long maxitems, long maxdepth)</a>
<a name="ln735">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln736">{</a>
<a name="ln737">  listitem_T *item;</a>
<a name="ln738">  int done = 0;</a>
<a name="ln739">  if (maxdepth == 0) {</a>
<a name="ln740">    return;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  if (first == NULL) {</a>
<a name="ln744">    item = list-&gt;lv_first;</a>
<a name="ln745">  } else {</a>
<a name="ln746">    item = first;</a>
<a name="ln747">  }</a>
<a name="ln748"> </a>
<a name="ln749">  while (item != NULL &amp;&amp; done &lt; maxitems) {</a>
<a name="ln750">    listitem_T *next = item-&gt;li_next;</a>
<a name="ln751"> </a>
<a name="ln752">    fast_breakcheck();</a>
<a name="ln753">    if (got_int) {</a>
<a name="ln754">      return;</a>
<a name="ln755">    }</a>
<a name="ln756">    if (item-&gt;li_tv.v_type == VAR_LIST) {</a>
<a name="ln757">      list_T *itemlist = item-&gt;li_tv.vval.v_list;</a>
<a name="ln758"> </a>
<a name="ln759">      tv_list_drop_items(list, item, item);</a>
<a name="ln760">      tv_list_extend(list, itemlist, next);</a>
<a name="ln761"> </a>
<a name="ln762">      if (maxdepth &gt; 0) {</a>
<a name="ln763">        tv_list_flatten(list,</a>
<a name="ln764">                        item-&gt;li_prev == NULL ? list-&gt;lv_first : item-&gt;li_prev-&gt;li_next,</a>
<a name="ln765">                        itemlist-&gt;lv_len, maxdepth - 1);</a>
<a name="ln766">      }</a>
<a name="ln767">      tv_clear(&amp;item-&gt;li_tv);</a>
<a name="ln768">      xfree(item);</a>
<a name="ln769">    }</a>
<a name="ln770"> </a>
<a name="ln771">    done++;</a>
<a name="ln772">    item = next;</a>
<a name="ln773">  }</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">/// Extend first list with the second</a>
<a name="ln777">///</a>
<a name="ln778">/// @param[out]  l1  List to extend.</a>
<a name="ln779">/// @param[in]  l2  List to extend with.</a>
<a name="ln780">/// @param[in]  bef  If not NULL, extends before this item.</a>
<a name="ln781">void tv_list_extend(list_T *const l1, list_T *const l2, listitem_T *const bef)</a>
<a name="ln782">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln783">{</a>
<a name="ln784">  int todo = tv_list_len(l2);</a>
<a name="ln785">  listitem_T *const befbef = (bef == NULL ? NULL : bef-&gt;li_prev);</a>
<a name="ln786">  listitem_T *const saved_next = (befbef == NULL ? NULL : befbef-&gt;li_next);</a>
<a name="ln787">  // We also quit the loop when we have inserted the original item count of</a>
<a name="ln788">  // the list, avoid a hang when we extend a list with itself.</a>
<a name="ln789">  for (listitem_T *item = tv_list_first(l2)</a>
<a name="ln790">       ; item != NULL &amp;&amp; todo--</a>
<a name="ln791">       ; item = (item == befbef ? saved_next : item-&gt;li_next)) {</a>
<a name="ln792">    tv_list_insert_tv(l1, TV_LIST_ITEM_TV(item), bef);</a>
<a name="ln793">  }</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">/// Concatenate lists into a new list</a>
<a name="ln797">///</a>
<a name="ln798">/// @param[in]  l1  First list.</a>
<a name="ln799">/// @param[in]  l2  Second list.</a>
<a name="ln800">/// @param[out]  ret_tv  Location where new list is saved.</a>
<a name="ln801">///</a>
<a name="ln802">/// @return OK or FAIL.</a>
<a name="ln803">int tv_list_concat(list_T *const l1, list_T *const l2, typval_T *const tv)</a>
<a name="ln804">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln805">{</a>
<a name="ln806">  list_T *l;</a>
<a name="ln807"> </a>
<a name="ln808">  tv-&gt;v_type = VAR_LIST;</a>
<a name="ln809">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln810">  if (l1 == NULL &amp;&amp; l2 == NULL) {</a>
<a name="ln811">    l = NULL;</a>
<a name="ln812">  } else if (l1 == NULL) {</a>
<a name="ln813">    l = tv_list_copy(NULL, l2, false, 0);</a>
<a name="ln814">  } else {</a>
<a name="ln815">    l = tv_list_copy(NULL, l1, false, 0);</a>
<a name="ln816">    if (l != NULL &amp;&amp; l2 != NULL) {</a>
<a name="ln817">      tv_list_extend(l, l2, NULL);</a>
<a name="ln818">    }</a>
<a name="ln819">  }</a>
<a name="ln820">  if (l == NULL &amp;&amp; !(l1 == NULL &amp;&amp; l2 == NULL)) {</a>
<a name="ln821">    return FAIL;</a>
<a name="ln822">  }</a>
<a name="ln823"> </a>
<a name="ln824">  tv-&gt;vval.v_list = l;</a>
<a name="ln825">  return OK;</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">static list_T *tv_list_slice(list_T *ol, varnumber_T n1, varnumber_T n2)</a>
<a name="ln829">{</a>
<a name="ln830">  list_T *l = tv_list_alloc(n2 - n1 + 1);</a>
<a name="ln831">  listitem_T *item = tv_list_find(ol, (int)n1);</a>
<a name="ln832">  for (; n1 &lt;= n2; n1++) {</a>
<a name="ln833">    tv_list_append_tv(l, TV_LIST_ITEM_TV(item));</a>
<a name="ln834">    item = TV_LIST_ITEM_NEXT(rettv-&gt;vval.v_list, item);</a>
<a name="ln835">  }</a>
<a name="ln836">  return l;</a>
<a name="ln837">}</a>
<a name="ln838"> </a>
<a name="ln839">int tv_list_slice_or_index(list_T *list, bool range, varnumber_T n1_arg, varnumber_T n2_arg,</a>
<a name="ln840">                           bool exclusive, typval_T *rettv, bool verbose)</a>
<a name="ln841">{</a>
<a name="ln842">  int len = tv_list_len(rettv-&gt;vval.v_list);</a>
<a name="ln843">  varnumber_T n1 = n1_arg;</a>
<a name="ln844">  varnumber_T n2 = n2_arg;</a>
<a name="ln845"> </a>
<a name="ln846">  if (n1 &lt; 0) {</a>
<a name="ln847">    n1 = len + n1;</a>
<a name="ln848">  }</a>
<a name="ln849">  if (n1 &lt; 0 || n1 &gt;= len) {</a>
<a name="ln850">    // For a range we allow invalid values and return an empty list.</a>
<a name="ln851">    // A list index out of range is an error.</a>
<a name="ln852">    if (!range) {</a>
<a name="ln853">      if (verbose) {</a>
<a name="ln854">        semsg(_(e_list_index_out_of_range_nr), (int64_t)n1);</a>
<a name="ln855">      }</a>
<a name="ln856">      return FAIL;</a>
<a name="ln857">    }</a>
<a name="ln858">    n1 = len;</a>
<a name="ln859">  }</a>
<a name="ln860">  if (range) {</a>
<a name="ln861">    if (n2 &lt; 0) {</a>
<a name="ln862">      n2 = len + n2;</a>
<a name="ln863">    } else if (n2 &gt;= len) {</a>
<a name="ln864">      n2 = len - (exclusive ? 0 : 1);</a>
<a name="ln865">    }</a>
<a name="ln866">    if (exclusive) {</a>
<a name="ln867">      n2--;</a>
<a name="ln868">    }</a>
<a name="ln869">    if (n2 &lt; 0 || n2 + 1 &lt; n1) {</a>
<a name="ln870">      n2 = -1;</a>
<a name="ln871">    }</a>
<a name="ln872">    list_T *l = tv_list_slice(rettv-&gt;vval.v_list, n1, n2);</a>
<a name="ln873">    tv_clear(rettv);</a>
<a name="ln874">    tv_list_set_ret(rettv, l);</a>
<a name="ln875">  } else {</a>
<a name="ln876">    // copy the item to &quot;var1&quot; to avoid that freeing the list makes it</a>
<a name="ln877">    // invalid.</a>
<a name="ln878">    typval_T var1;</a>
<a name="ln879">    tv_copy(TV_LIST_ITEM_TV(tv_list_find(rettv-&gt;vval.v_list, (int)n1)), &amp;var1);</a>
<a name="ln880">    tv_clear(rettv);</a>
<a name="ln881">    *rettv = var1;</a>
<a name="ln882">  }</a>
<a name="ln883">  return OK;</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">typedef struct {</a>
<a name="ln887">  char *s;</a>
<a name="ln888">  char *tofree;</a>
<a name="ln889">} Join;</a>
<a name="ln890"> </a>
<a name="ln891">/// Join list into a string, helper function</a>
<a name="ln892">///</a>
<a name="ln893">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln894">/// @param[in]  l  List to join.</a>
<a name="ln895">/// @param[in]  sep  Used separator.</a>
<a name="ln896">/// @param[in]  join_gap  Garray to keep each list item string.</a>
<a name="ln897">///</a>
<a name="ln898">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln899">static int list_join_inner(garray_T *const gap, list_T *const l, const char *const sep,</a>
<a name="ln900">                           garray_T *const join_gap)</a>
<a name="ln901">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln902">{</a>
<a name="ln903">  size_t sumlen = 0;</a>
<a name="ln904">  bool first = true;</a>
<a name="ln905"> </a>
<a name="ln906">  // Stringify each item in the list.</a>
<a name="ln907">  TV_LIST_ITER(l, item, {</a>
<a name="ln908">    if (got_int) {</a>
<a name="ln909">      break;</a>
<a name="ln910">    }</a>
<a name="ln911">    char *s;</a>
<a name="ln912">    size_t len;</a>
<a name="ln913">    s = encode_tv2echo(TV_LIST_ITEM_TV(item), &amp;len);</a>
<a name="ln914">    if (s == NULL) {</a>
<a name="ln915">      return FAIL;</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">    sumlen += len;</a>
<a name="ln919"> </a>
<a name="ln920">    Join *const p = GA_APPEND_VIA_PTR(Join, join_gap);</a>
<a name="ln921">    p-&gt;tofree = p-&gt;s = s;</a>
<a name="ln922"> </a>
<a name="ln923">    line_breakcheck();</a>
<a name="ln924">  });</a>
<a name="ln925"> </a>
<a name="ln926">  // Allocate result buffer with its total size, avoid re-allocation and</a>
<a name="ln927">  // multiple copy operations.  Add 2 for a tailing ']' and NUL.</a>
<a name="ln928">  if (join_gap-&gt;ga_len &gt;= 2) {</a>
<a name="ln929">    sumlen += strlen(sep) * (size_t)(join_gap-&gt;ga_len - 1);</a>
<a name="ln930">  }</a>
<a name="ln931">  ga_grow(gap, (int)sumlen + 2);</a>
<a name="ln932"> </a>
<a name="ln933">  for (int i = 0; i &lt; join_gap-&gt;ga_len &amp;&amp; !got_int; i++) {</a>
<a name="ln934">    if (first) {</a>
<a name="ln935">      first = false;</a>
<a name="ln936">    } else {</a>
<a name="ln937">      ga_concat(gap, sep);</a>
<a name="ln938">    }</a>
<a name="ln939">    const Join *const p = ((const Join *)join_gap-&gt;ga_data) + i;</a>
<a name="ln940"> </a>
<a name="ln941">    if (p-&gt;s != NULL) {</a>
<a name="ln942">      ga_concat(gap, p-&gt;s);</a>
<a name="ln943">    }</a>
<a name="ln944">    line_breakcheck();</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  return OK;</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">/// Join list into a string using given separator</a>
<a name="ln951">///</a>
<a name="ln952">/// @param[out]  gap  Garray where result will be saved.</a>
<a name="ln953">/// @param[in]  l  Joined list.</a>
<a name="ln954">/// @param[in]  sep  Separator.</a>
<a name="ln955">///</a>
<a name="ln956">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln957">int tv_list_join(garray_T *const gap, list_T *const l, const char *const sep)</a>
<a name="ln958">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln959">{</a>
<a name="ln960">  if (!tv_list_len(l)) {</a>
<a name="ln961">    return OK;</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  garray_T join_ga;</a>
<a name="ln965">  int retval;</a>
<a name="ln966"> </a>
<a name="ln967">  ga_init(&amp;join_ga, (int)sizeof(Join), tv_list_len(l));</a>
<a name="ln968">  retval = list_join_inner(gap, l, sep, &amp;join_ga);</a>
<a name="ln969"> </a>
<a name="ln970">#define FREE_JOIN_TOFREE(join) xfree((join)-&gt;tofree)</a>
<a name="ln971">  GA_DEEP_CLEAR(&amp;join_ga, Join, FREE_JOIN_TOFREE);</a>
<a name="ln972">#undef FREE_JOIN_TOFREE</a>
<a name="ln973"> </a>
<a name="ln974">  return retval;</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">/// &quot;join()&quot; function</a>
<a name="ln978">void f_join(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln979">{</a>
<a name="ln980">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln981">    emsg(_(e_listreq));</a>
<a name="ln982">    return;</a>
<a name="ln983">  }</a>
<a name="ln984">  const char *const sep = (argvars[1].v_type == VAR_UNKNOWN</a>
<a name="ln985">                           ? &quot; &quot;</a>
<a name="ln986">                           : tv_get_string_chk(&amp;argvars[1]));</a>
<a name="ln987"> </a>
<a name="ln988">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln989"> </a>
<a name="ln990">  if (sep != NULL) {</a>
<a name="ln991">    garray_T ga;</a>
<a name="ln992">    ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln993">    tv_list_join(&amp;ga, argvars[0].vval.v_list, sep);</a>
<a name="ln994">    ga_append(&amp;ga, NUL);</a>
<a name="ln995">    rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln996">  } else {</a>
<a name="ln997">    rettv-&gt;vval.v_string = NULL;</a>
<a name="ln998">  }</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/// &quot;list2str()&quot; function</a>
<a name="ln1002">void f_list2str(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1003">{</a>
<a name="ln1004">  garray_T ga;</a>
<a name="ln1005"> </a>
<a name="ln1006">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln1007">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln1008">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1009">    emsg(_(e_invarg));</a>
<a name="ln1010">    return;</a>
<a name="ln1011">  }</a>
<a name="ln1012"> </a>
<a name="ln1013">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln1014">  if (l == NULL) {</a>
<a name="ln1015">    return;  // empty list results in empty string</a>
<a name="ln1016">  }</a>
<a name="ln1017"> </a>
<a name="ln1018">  ga_init(&amp;ga, 1, 80);</a>
<a name="ln1019">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln1020"> </a>
<a name="ln1021">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1022">    buf[utf_char2bytes((int)tv_get_number(TV_LIST_ITEM_TV(li)), buf)] = NUL;</a>
<a name="ln1023">    ga_concat(&amp;ga, buf);</a>
<a name="ln1024">  });</a>
<a name="ln1025">  ga_append(&amp;ga, NUL);</a>
<a name="ln1026"> </a>
<a name="ln1027">  rettv-&gt;vval.v_string = ga.ga_data;</a>
<a name="ln1028">}</a>
<a name="ln1029"> </a>
<a name="ln1030">/// &quot;remove({list})&quot; function</a>
<a name="ln1031">void tv_list_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln1032">{</a>
<a name="ln1033">  list_T *l;</a>
<a name="ln1034">  bool error = false;</a>
<a name="ln1035"> </a>
<a name="ln1036">  if (value_check_lock(tv_list_locked((l = argvars[0].vval.v_list)),</a>
<a name="ln1037">                       arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln1038">    return;</a>
<a name="ln1039">  }</a>
<a name="ln1040"> </a>
<a name="ln1041">  int64_t idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1042"> </a>
<a name="ln1043">  listitem_T *item;</a>
<a name="ln1044"> </a>
<a name="ln1045">  if (error) {</a>
<a name="ln1046">    // Type error: do nothing, errmsg already given.</a>
<a name="ln1047">  } else if ((item = tv_list_find(l, (int)idx)) == NULL) {</a>
<a name="ln1048">    semsg(_(e_list_index_out_of_range_nr), idx);</a>
<a name="ln1049">  } else {</a>
<a name="ln1050">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln1051">      // Remove one item, return its value.</a>
<a name="ln1052">      tv_list_drop_items(l, item, item);</a>
<a name="ln1053">      *rettv = *TV_LIST_ITEM_TV(item);</a>
<a name="ln1054">      xfree(item);</a>
<a name="ln1055">    } else {</a>
<a name="ln1056">      listitem_T *item2;</a>
<a name="ln1057">      // Remove range of items, return list with values.</a>
<a name="ln1058">      int64_t end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln1059">      if (error) {</a>
<a name="ln1060">        // Type error: do nothing.</a>
<a name="ln1061">      } else if ((item2 = tv_list_find(l, (int)end)) == NULL) {</a>
<a name="ln1062">        semsg(_(e_list_index_out_of_range_nr), end);</a>
<a name="ln1063">      } else {</a>
<a name="ln1064">        int cnt = 0;</a>
<a name="ln1065"> </a>
<a name="ln1066">        listitem_T *li;</a>
<a name="ln1067">        for (li = item; li != NULL; li = TV_LIST_ITEM_NEXT(l, li)) {</a>
<a name="ln1068">          cnt++;</a>
<a name="ln1069">          if (li == item2) {</a>
<a name="ln1070">            break;</a>
<a name="ln1071">          }</a>
<a name="ln1072">        }</a>
<a name="ln1073">        if (li == NULL) {  // Didn't find &quot;item2&quot; after &quot;item&quot;.</a>
<a name="ln1074">          emsg(_(e_invrange));</a>
<a name="ln1075">        } else {</a>
<a name="ln1076">          tv_list_move_items(l, item, item2, tv_list_alloc_ret(rettv, cnt),</a>
<a name="ln1077">                             cnt);</a>
<a name="ln1078">        }</a>
<a name="ln1079">      }</a>
<a name="ln1080">    }</a>
<a name="ln1081">  }</a>
<a name="ln1082">}</a>
<a name="ln1083"> </a>
<a name="ln1084">static sortinfo_T *sortinfo = NULL;</a>
<a name="ln1085"> </a>
<a name="ln1086">#define ITEM_COMPARE_FAIL 999</a>
<a name="ln1087"> </a>
<a name="ln1088">/// Compare functions for f_sort() and f_uniq() below.</a>
<a name="ln1089">static int item_compare(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln1090">{</a>
<a name="ln1091">  ListSortItem *const si1 = (ListSortItem *)s1;</a>
<a name="ln1092">  ListSortItem *const si2 = (ListSortItem *)s2;</a>
<a name="ln1093"> </a>
<a name="ln1094">  typval_T *const tv1 = TV_LIST_ITEM_TV(si1-&gt;item);</a>
<a name="ln1095">  typval_T *const tv2 = TV_LIST_ITEM_TV(si2-&gt;item);</a>
<a name="ln1096"> </a>
<a name="ln1097">  int res;</a>
<a name="ln1098"> </a>
<a name="ln1099">  if (sortinfo-&gt;item_compare_numbers) {</a>
<a name="ln1100">    const varnumber_T v1 = tv_get_number(tv1);</a>
<a name="ln1101">    const varnumber_T v2 = tv_get_number(tv2);</a>
<a name="ln1102"> </a>
<a name="ln1103">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln1104">    goto item_compare_end;</a>
<a name="ln1105">  }</a>
<a name="ln1106"> </a>
<a name="ln1107">  if (sortinfo-&gt;item_compare_float) {</a>
<a name="ln1108">    const float_T v1 = tv_get_float(tv1);</a>
<a name="ln1109">    const float_T v2 = tv_get_float(tv2);</a>
<a name="ln1110"> </a>
<a name="ln1111">    res = v1 == v2 ? 0 : v1 &gt; v2 ? 1 : -1;</a>
<a name="ln1112">    goto item_compare_end;</a>
<a name="ln1113">  }</a>
<a name="ln1114"> </a>
<a name="ln1115">  char *tofree1 = NULL;</a>
<a name="ln1116">  char *tofree2 = NULL;</a>
<a name="ln1117">  char *p1;</a>
<a name="ln1118">  char *p2;</a>
<a name="ln1119"> </a>
<a name="ln1120">  // encode_tv2string() puts quotes around a string and allocates memory.  Don't</a>
<a name="ln1121">  // do that for string variables. Use a single quote when comparing with</a>
<a name="ln1122">  // a non-string to do what the docs promise.</a>
<a name="ln1123">  if (tv1-&gt;v_type == VAR_STRING) {</a>
<a name="ln1124">    if (tv2-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1125">      p1 = &quot;'&quot;;</a>
<a name="ln1126">    } else {</a>
<a name="ln1127">      p1 = tv1-&gt;vval.v_string;</a>
<a name="ln1128">    }</a>
<a name="ln1129">  } else {</a>
<a name="ln1130">    tofree1 = p1 = encode_tv2string(tv1, NULL);</a>
<a name="ln1131">  }</a>
<a name="ln1132">  if (tv2-&gt;v_type == VAR_STRING) {</a>
<a name="ln1133">    if (tv1-&gt;v_type != VAR_STRING || sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1134">      p2 = &quot;'&quot;;</a>
<a name="ln1135">    } else {</a>
<a name="ln1136">      p2 = tv2-&gt;vval.v_string;</a>
<a name="ln1137">    }</a>
<a name="ln1138">  } else {</a>
<a name="ln1139">    tofree2 = p2 = encode_tv2string(tv2, NULL);</a>
<a name="ln1140">  }</a>
<a name="ln1141">  if (p1 == NULL) {</a>
<a name="ln1142">    p1 = &quot;&quot;;</a>
<a name="ln1143">  }</a>
<a name="ln1144">  if (p2 == NULL) {</a>
<a name="ln1145">    p2 = &quot;&quot;;</a>
<a name="ln1146">  }</a>
<a name="ln1147">  if (!sortinfo-&gt;item_compare_numeric) {</a>
<a name="ln1148">    if (sortinfo-&gt;item_compare_lc) {</a>
<a name="ln1149">      res = strcoll(p1, p2);</a>
<a name="ln1150">    } else {</a>
<a name="ln1151">      res = sortinfo-&gt;item_compare_ic ? STRICMP(p1, p2) : strcmp(p1, p2);</a>
<a name="ln1152">    }</a>
<a name="ln1153">  } else {</a>
<a name="ln1154">    double n1, n2;</a>
<a name="ln1155">    n1 = strtod(p1, &amp;p1);</a>
<a name="ln1156">    n2 = strtod(p2, &amp;p2);</a>
<a name="ln1157">    res = n1 == n2 ? 0 : n1 &gt; n2 ? 1 : -1;</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  xfree(tofree1);</a>
<a name="ln1161">  xfree(tofree2);</a>
<a name="ln1162"> </a>
<a name="ln1163">item_compare_end:</a>
<a name="ln1164">  // When the result would be zero, compare the item indexes.  Makes the</a>
<a name="ln1165">  // sort stable.</a>
<a name="ln1166">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln1167">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln1168">    // indexes are there.</a>
<a name="ln1169">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln1170">  }</a>
<a name="ln1171">  return res;</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">static int item_compare_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1175">{</a>
<a name="ln1176">  return item_compare(s1, s2, true);</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">static int item_compare_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1180">{</a>
<a name="ln1181">  return item_compare(s1, s2, false);</a>
<a name="ln1182">}</a>
<a name="ln1183"> </a>
<a name="ln1184">static int item_compare2(const void *s1, const void *s2, bool keep_zero)</a>
<a name="ln1185">{</a>
<a name="ln1186">  ListSortItem *si1, *si2;</a>
<a name="ln1187">  int res;</a>
<a name="ln1188">  typval_T rettv;</a>
<a name="ln1189">  typval_T argv[3];</a>
<a name="ln1190">  const char *func_name;</a>
<a name="ln1191">  partial_T *partial = sortinfo-&gt;item_compare_partial;</a>
<a name="ln1192"> </a>
<a name="ln1193">  // shortcut after failure in previous call; compare all items equal</a>
<a name="ln1194">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln1195">    return 0;</a>
<a name="ln1196">  }</a>
<a name="ln1197"> </a>
<a name="ln1198">  si1 = (ListSortItem *)s1;</a>
<a name="ln1199">  si2 = (ListSortItem *)s2;</a>
<a name="ln1200"> </a>
<a name="ln1201">  if (partial == NULL) {</a>
<a name="ln1202">    func_name = sortinfo-&gt;item_compare_func;</a>
<a name="ln1203">  } else {</a>
<a name="ln1204">    func_name = partial_name(partial);</a>
<a name="ln1205">  }</a>
<a name="ln1206"> </a>
<a name="ln1207">  // Copy the values.  This is needed to be able to set v_lock to VAR_FIXED</a>
<a name="ln1208">  // in the copy without changing the original list items.</a>
<a name="ln1209">  tv_copy(TV_LIST_ITEM_TV(si1-&gt;item), &amp;argv[0]);</a>
<a name="ln1210">  tv_copy(TV_LIST_ITEM_TV(si2-&gt;item), &amp;argv[1]);</a>
<a name="ln1211"> </a>
<a name="ln1212">  rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln1213">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln1214">  funcexe.fe_evaluate = true;</a>
<a name="ln1215">  funcexe.fe_partial = partial;</a>
<a name="ln1216">  funcexe.fe_selfdict = sortinfo-&gt;item_compare_selfdict;</a>
<a name="ln1217">  res = call_func(func_name, -1, &amp;rettv, 2, argv, &amp;funcexe);</a>
<a name="ln1218">  tv_clear(&amp;argv[0]);</a>
<a name="ln1219">  tv_clear(&amp;argv[1]);</a>
<a name="ln1220"> </a>
<a name="ln1221">  if (res == FAIL) {</a>
<a name="ln1222">    // XXX: ITEM_COMPARE_FAIL is unused</a>
<a name="ln1223">    res = ITEM_COMPARE_FAIL;</a>
<a name="ln1224">    sortinfo-&gt;item_compare_func_err = true;</a>
<a name="ln1225">  } else {</a>
<a name="ln1226">    res = (int)tv_get_number_chk(&amp;rettv, &amp;sortinfo-&gt;item_compare_func_err);</a>
<a name="ln1227">    if (res &gt; 0) {</a>
<a name="ln1228">      res = 1;</a>
<a name="ln1229">    } else if (res &lt; 0) {</a>
<a name="ln1230">      res = -1;</a>
<a name="ln1231">    }</a>
<a name="ln1232">  }</a>
<a name="ln1233">  if (sortinfo-&gt;item_compare_func_err) {</a>
<a name="ln1234">    res = ITEM_COMPARE_FAIL;  // return value has wrong type</a>
<a name="ln1235">  }</a>
<a name="ln1236">  tv_clear(&amp;rettv);</a>
<a name="ln1237"> </a>
<a name="ln1238">  // When the result would be zero, compare the pointers themselves.  Makes</a>
<a name="ln1239">  // the sort stable.</a>
<a name="ln1240">  if (res == 0 &amp;&amp; !keep_zero) {</a>
<a name="ln1241">    // WARNING: When using uniq si1 and si2 are actually listitem_T **, no</a>
<a name="ln1242">    // indexes are there.</a>
<a name="ln1243">    res = si1-&gt;idx &gt; si2-&gt;idx ? 1 : -1;</a>
<a name="ln1244">  }</a>
<a name="ln1245"> </a>
<a name="ln1246">  return res;</a>
<a name="ln1247">}</a>
<a name="ln1248"> </a>
<a name="ln1249">static int item_compare2_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1250">{</a>
<a name="ln1251">  return item_compare2(s1, s2, true);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">static int item_compare2_not_keeping_zero(const void *s1, const void *s2)</a>
<a name="ln1255">{</a>
<a name="ln1256">  return item_compare2(s1, s2, false);</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">/// sort() List &quot;l&quot;</a>
<a name="ln1260">static void do_sort(list_T *l, sortinfo_T *info)</a>
<a name="ln1261">{</a>
<a name="ln1262">  const int len = tv_list_len(l);</a>
<a name="ln1263"> </a>
<a name="ln1264">  // Make an array with each entry pointing to an item in the List.</a>
<a name="ln1265">  ListSortItem *ptrs = xmalloc((size_t)((unsigned)len * sizeof(ListSortItem)));</a>
<a name="ln1266"> </a>
<a name="ln1267">  // f_sort(): ptrs will be the list to sort</a>
<a name="ln1268">  int i = 0;</a>
<a name="ln1269">  TV_LIST_ITER(l, li, {</a>
<a name="ln1270">    ptrs[i].item = li;</a>
<a name="ln1271">    ptrs[i].idx = i;</a>
<a name="ln1272">    i++;</a>
<a name="ln1273">  });</a>
<a name="ln1274"> </a>
<a name="ln1275">  info-&gt;item_compare_func_err = false;</a>
<a name="ln1276">  ListSorter item_compare_func = ((info-&gt;item_compare_func == NULL</a>
<a name="ln1277">                                   &amp;&amp; info-&gt;item_compare_partial == NULL)</a>
<a name="ln1278">                                  ? item_compare_not_keeping_zero</a>
<a name="ln1279">                                  : item_compare2_not_keeping_zero);</a>
<a name="ln1280"> </a>
<a name="ln1281">  // Sort the array with item pointers.</a>
<a name="ln1282">  qsort(ptrs, (size_t)len, sizeof(ListSortItem), item_compare_func);</a>
<a name="ln1283">  if (!info-&gt;item_compare_func_err) {</a>
<a name="ln1284">    // Clear the list and append the items in the sorted order.</a>
<a name="ln1285">    l-&gt;lv_first = NULL;</a>
<a name="ln1286">    l-&gt;lv_last = NULL;</a>
<a name="ln1287">    l-&gt;lv_idx_item = NULL;</a>
<a name="ln1288">    l-&gt;lv_len = 0;</a>
<a name="ln1289">    for (i = 0; i &lt; len; i++) {</a>
<a name="ln1290">      tv_list_append(l, ptrs[i].item);</a>
<a name="ln1291">    }</a>
<a name="ln1292">  }</a>
<a name="ln1293">  if (info-&gt;item_compare_func_err) {</a>
<a name="ln1294">    emsg(_(&quot;E702: Sort compare function failed&quot;));</a>
<a name="ln1295">  }</a>
<a name="ln1296"> </a>
<a name="ln1297">  xfree(ptrs);</a>
<a name="ln1298">}</a>
<a name="ln1299"> </a>
<a name="ln1300">/// uniq() List &quot;l&quot;</a>
<a name="ln1301">static void do_uniq(list_T *l, sortinfo_T *info)</a>
<a name="ln1302">{</a>
<a name="ln1303">  const int len = tv_list_len(l);</a>
<a name="ln1304"> </a>
<a name="ln1305">  // Make an array with each entry pointing to an item in the List.</a>
<a name="ln1306">  ListSortItem *ptrs = xmalloc((size_t)((unsigned)len * sizeof(ListSortItem)));</a>
<a name="ln1307"> </a>
<a name="ln1308">  // f_uniq(): ptrs will be a stack of items to remove.</a>
<a name="ln1309"> </a>
<a name="ln1310">  info-&gt;item_compare_func_err = false;</a>
<a name="ln1311">  ListSorter item_compare_func = ((info-&gt;item_compare_func == NULL</a>
<a name="ln1312">                                   &amp;&amp; info-&gt;item_compare_partial == NULL)</a>
<a name="ln1313">                                  ? item_compare_keeping_zero</a>
<a name="ln1314">                                  : item_compare2_keeping_zero);</a>
<a name="ln1315"> </a>
<a name="ln1316">  for (listitem_T *li = TV_LIST_ITEM_NEXT(l, tv_list_first(l)); li != NULL;) {</a>
<a name="ln1317">    listitem_T *const prev_li = TV_LIST_ITEM_PREV(l, li);</a>
<a name="ln1318">    if (item_compare_func(&amp;prev_li, &amp;li) == 0) {</a>
<a name="ln1319">      li = tv_list_item_remove(l, li);</a>
<a name="ln1320">    } else {</a>
<a name="ln1321">      li = TV_LIST_ITEM_NEXT(l, li);</a>
<a name="ln1322">    }</a>
<a name="ln1323">    if (info-&gt;item_compare_func_err) {</a>
<a name="ln1324">      emsg(_(&quot;E882: Uniq compare function failed&quot;));</a>
<a name="ln1325">      break;</a>
<a name="ln1326">    }</a>
<a name="ln1327">  }</a>
<a name="ln1328"> </a>
<a name="ln1329">  xfree(ptrs);</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">/// Parse the optional arguments to sort() and uniq() and return the values in &quot;info&quot;.</a>
<a name="ln1333">static int parse_sort_uniq_args(typval_T *argvars, sortinfo_T *info)</a>
<a name="ln1334">{</a>
<a name="ln1335">  info-&gt;item_compare_ic = false;</a>
<a name="ln1336">  info-&gt;item_compare_lc = false;</a>
<a name="ln1337">  info-&gt;item_compare_numeric = false;</a>
<a name="ln1338">  info-&gt;item_compare_numbers = false;</a>
<a name="ln1339">  info-&gt;item_compare_float = false;</a>
<a name="ln1340">  info-&gt;item_compare_func = NULL;</a>
<a name="ln1341">  info-&gt;item_compare_partial = NULL;</a>
<a name="ln1342">  info-&gt;item_compare_selfdict = NULL;</a>
<a name="ln1343"> </a>
<a name="ln1344">  if (argvars[1].v_type == VAR_UNKNOWN) {</a>
<a name="ln1345">    return OK;</a>
<a name="ln1346">  }</a>
<a name="ln1347"> </a>
<a name="ln1348">  // optional second argument: {func}</a>
<a name="ln1349">  if (argvars[1].v_type == VAR_FUNC) {</a>
<a name="ln1350">    info-&gt;item_compare_func = argvars[1].vval.v_string;</a>
<a name="ln1351">  } else if (argvars[1].v_type == VAR_PARTIAL) {</a>
<a name="ln1352">    info-&gt;item_compare_partial = argvars[1].vval.v_partial;</a>
<a name="ln1353">  } else {</a>
<a name="ln1354">    bool error = false;</a>
<a name="ln1355">    int nr = (int)tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln1356">    if (error) {</a>
<a name="ln1357">      return FAIL;  // type error; errmsg already given</a>
<a name="ln1358">    }</a>
<a name="ln1359">    if (nr == 1) {</a>
<a name="ln1360">      info-&gt;item_compare_ic = true;</a>
<a name="ln1361">    } else if (argvars[1].v_type != VAR_NUMBER) {</a>
<a name="ln1362">      info-&gt;item_compare_func = tv_get_string(&amp;argvars[1]);</a>
<a name="ln1363">    } else if (nr != 0) {</a>
<a name="ln1364">      emsg(_(e_invarg));</a>
<a name="ln1365">      return FAIL;</a>
<a name="ln1366">    }</a>
<a name="ln1367">    if (info-&gt;item_compare_func != NULL) {</a>
<a name="ln1368">      if (*info-&gt;item_compare_func == NUL) {</a>
<a name="ln1369">        // empty string means default sort</a>
<a name="ln1370">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1371">      } else if (strcmp(info-&gt;item_compare_func, &quot;n&quot;) == 0) {</a>
<a name="ln1372">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1373">        info-&gt;item_compare_numeric = true;</a>
<a name="ln1374">      } else if (strcmp(info-&gt;item_compare_func, &quot;N&quot;) == 0) {</a>
<a name="ln1375">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1376">        info-&gt;item_compare_numbers = true;</a>
<a name="ln1377">      } else if (strcmp(info-&gt;item_compare_func, &quot;f&quot;) == 0) {</a>
<a name="ln1378">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1379">        info-&gt;item_compare_float = true;</a>
<a name="ln1380">      } else if (strcmp(info-&gt;item_compare_func, &quot;i&quot;) == 0) {</a>
<a name="ln1381">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1382">        info-&gt;item_compare_ic = true;</a>
<a name="ln1383">      } else if (strcmp(info-&gt;item_compare_func, &quot;l&quot;) == 0) {</a>
<a name="ln1384">        info-&gt;item_compare_func = NULL;</a>
<a name="ln1385">        info-&gt;item_compare_lc = true;</a>
<a name="ln1386">      }</a>
<a name="ln1387">    }</a>
<a name="ln1388">  }</a>
<a name="ln1389"> </a>
<a name="ln1390">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln1391">    // optional third argument: {dict}</a>
<a name="ln1392">    if (tv_check_for_dict_arg(argvars, 2) == FAIL) {</a>
<a name="ln1393">      return FAIL;</a>
<a name="ln1394">    }</a>
<a name="ln1395">    info-&gt;item_compare_selfdict = argvars[2].vval.v_dict;</a>
<a name="ln1396">  }</a>
<a name="ln1397"> </a>
<a name="ln1398">  return OK;</a>
<a name="ln1399">}</a>
<a name="ln1400"> </a>
<a name="ln1401">/// &quot;sort()&quot; or &quot;uniq()&quot; function</a>
<a name="ln1402">static void do_sort_uniq(typval_T *argvars, typval_T *rettv, bool sort)</a>
<a name="ln1403">{</a>
<a name="ln1404">  if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln1405">    semsg(_(e_listarg), sort ? &quot;sort()&quot; : &quot;uniq()&quot;);</a>
<a name="ln1406">    return;</a>
<a name="ln1407">  }</a>
<a name="ln1408"> </a>
<a name="ln1409">  // Pointer to current info struct used in compare function. Save and restore</a>
<a name="ln1410">  // the current one for nested calls.</a>
<a name="ln1411">  sortinfo_T info;</a>
<a name="ln1412">  sortinfo_T *old_sortinfo = sortinfo;</a>
<a name="ln1413">  sortinfo = &amp;info;</a>
<a name="ln1414"> </a>
<a name="ln1415">  const char *const arg_errmsg = (sort ? N_(&quot;sort() argument&quot;) : N_(&quot;uniq() argument&quot;));</a>
<a name="ln1416">  list_T *const l = argvars[0].vval.v_list;</a>
<a name="ln1417">  if (value_check_lock(tv_list_locked(l), arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln1418">    goto theend;</a>
<a name="ln1419">  }</a>
<a name="ln1420">  tv_list_set_ret(rettv, l);</a>
<a name="ln1421"> </a>
<a name="ln1422">  const int len = tv_list_len(l);</a>
<a name="ln1423">  if (len &lt;= 1) {</a>
<a name="ln1424">    goto theend;  // short list sorts pretty quickly</a>
<a name="ln1425">  }</a>
<a name="ln1426">  if (parse_sort_uniq_args(argvars, &amp;info) == FAIL) {</a>
<a name="ln1427">    goto theend;</a>
<a name="ln1428">  }</a>
<a name="ln1429"> </a>
<a name="ln1430">  if (sort) {</a>
<a name="ln1431">    do_sort(l, &amp;info);</a>
<a name="ln1432">  } else {</a>
<a name="ln1433">    do_uniq(l, &amp;info);</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">theend:</a>
<a name="ln1437">  sortinfo = old_sortinfo;</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">/// &quot;sort({list})&quot; function</a>
<a name="ln1441">void f_sort(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1442">{</a>
<a name="ln1443">  do_sort_uniq(argvars, rettv, true);</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446">/// &quot;uniq({list})&quot; function</a>
<a name="ln1447">void f_uniq(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln1448">{</a>
<a name="ln1449">  do_sort_uniq(argvars, rettv, false);</a>
<a name="ln1450">}</a>
<a name="ln1451"> </a>
<a name="ln1452">/// Check whether two lists are equal</a>
<a name="ln1453">///</a>
<a name="ln1454">/// @param[in]  l1  First list to compare.</a>
<a name="ln1455">/// @param[in]  l2  Second list to compare.</a>
<a name="ln1456">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln1457">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln1458">///</a>
<a name="ln1459">/// @return True if lists are equal, false otherwise.</a>
<a name="ln1460">bool tv_list_equal(list_T *const l1, list_T *const l2, const bool ic, const bool recursive)</a>
<a name="ln1461">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1462">{</a>
<a name="ln1463">  if (l1 == l2) {</a>
<a name="ln1464">    return true;</a>
<a name="ln1465">  }</a>
<a name="ln1466">  if (tv_list_len(l1) != tv_list_len(l2)) {</a>
<a name="ln1467">    return false;</a>
<a name="ln1468">  }</a>
<a name="ln1469">  if (tv_list_len(l1) == 0) {</a>
<a name="ln1470">    // empty and NULL list are considered equal</a>
<a name="ln1471">    return true;</a>
<a name="ln1472">  }</a>
<a name="ln1473">  if (l1 == NULL || l2 == NULL) {</a>
<a name="ln1474">    return false;</a>
<a name="ln1475">  }</a>
<a name="ln1476"> </a>
<a name="ln1477">  listitem_T *item1 = tv_list_first(l1);</a>
<a name="ln1478">  listitem_T *item2 = tv_list_first(l2);</a>
<a name="ln1479">  for (; item1 != NULL &amp;&amp; item2 != NULL</a>
<a name="ln1480">       ; (item1 = TV_LIST_ITEM_NEXT(l1, item1),</a>
<a name="ln1481">          item2 = TV_LIST_ITEM_NEXT(l2, item2))) {</a>
<a name="ln1482">    if (!tv_equal(TV_LIST_ITEM_TV(item1), TV_LIST_ITEM_TV(item2), ic,</a>
<a name="ln1483">                  recursive)) {</a>
<a name="ln1484">      return false;</a>
<a name="ln1485">    }</a>
<a name="ln1486">  }</a>
<a name="ln1487">  assert(item1 == NULL &amp;&amp; item2 == NULL);</a>
<a name="ln1488">  return true;</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">/// Reverse list in-place</a>
<a name="ln1492">///</a>
<a name="ln1493">/// @param[in,out]  l  List to reverse.</a>
<a name="ln1494">void tv_list_reverse(list_T *const l)</a>
<a name="ln1495">{</a>
<a name="ln1496">  if (tv_list_len(l) &lt;= 1) {</a>
<a name="ln1497">    return;</a>
<a name="ln1498">  }</a>
<a name="ln1499">#define SWAP(a, b) \</a>
<a name="ln1500">  do { \</a>
<a name="ln1501">    tmp = (a); \</a>
<a name="ln1502">    (a) = (b); \</a>
<a name="ln1503">    (b) = tmp; \</a>
<a name="ln1504">  } while (0)</a>
<a name="ln1505">  listitem_T *tmp;</a>
<a name="ln1506"> </a>
<a name="ln1507">  SWAP(l-&gt;lv_first, l-&gt;lv_last);</a>
<a name="ln1508">  for (listitem_T *li = l-&gt;lv_first; li != NULL; li = li-&gt;li_next) {</a>
<a name="ln1509">    SWAP(li-&gt;li_next, li-&gt;li_prev);</a>
<a name="ln1510">  }</a>
<a name="ln1511">#undef SWAP</a>
<a name="ln1512"> </a>
<a name="ln1513">  l-&gt;lv_idx = l-&gt;lv_len - l-&gt;lv_idx - 1;</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">//{{{2 Indexing/searching</a>
<a name="ln1517"> </a>
<a name="ln1518">/// Locate item with a given index in a list and return it</a>
<a name="ln1519">///</a>
<a name="ln1520">/// @param[in]  l  List to index.</a>
<a name="ln1521">/// @param[in]  n  Index. Negative index is counted from the end, -1 is the last</a>
<a name="ln1522">///                item.</a>
<a name="ln1523">///</a>
<a name="ln1524">/// @return Item at the given index or NULL if `n` is out of range.</a>
<a name="ln1525">listitem_T *tv_list_find(list_T *const l, int n)</a>
<a name="ln1526">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1527">{</a>
<a name="ln1528">  STATIC_ASSERT(sizeof(n) == sizeof(l-&gt;lv_idx),</a>
<a name="ln1529">                &quot;n and lv_idx sizes do not match&quot;);</a>
<a name="ln1530">  if (l == NULL) {</a>
<a name="ln1531">    return NULL;</a>
<a name="ln1532">  }</a>
<a name="ln1533"> </a>
<a name="ln1534">  n = tv_list_uidx(l, n);</a>
<a name="ln1535">  if (n == -1) {</a>
<a name="ln1536">    return NULL;</a>
<a name="ln1537">  }</a>
<a name="ln1538"> </a>
<a name="ln1539">  int idx;</a>
<a name="ln1540">  listitem_T *item;</a>
<a name="ln1541"> </a>
<a name="ln1542">  // When there is a cached index may start search from there.</a>
<a name="ln1543">  if (l-&gt;lv_idx_item != NULL) {</a>
<a name="ln1544">    if (n &lt; l-&gt;lv_idx / 2) {</a>
<a name="ln1545">      // Closest to the start of the list.</a>
<a name="ln1546">      item = l-&gt;lv_first;</a>
<a name="ln1547">      idx = 0;</a>
<a name="ln1548">    } else if (n &gt; (l-&gt;lv_idx + l-&gt;lv_len) / 2) {</a>
<a name="ln1549">      // Closest to the end of the list.</a>
<a name="ln1550">      item = l-&gt;lv_last;</a>
<a name="ln1551">      idx = l-&gt;lv_len - 1;</a>
<a name="ln1552">    } else {</a>
<a name="ln1553">      // Closest to the cached index.</a>
<a name="ln1554">      item = l-&gt;lv_idx_item;</a>
<a name="ln1555">      idx = l-&gt;lv_idx;</a>
<a name="ln1556">    }</a>
<a name="ln1557">  } else {</a>
<a name="ln1558">    if (n &lt; l-&gt;lv_len / 2) {</a>
<a name="ln1559">      // Closest to the start of the list.</a>
<a name="ln1560">      item = l-&gt;lv_first;</a>
<a name="ln1561">      idx = 0;</a>
<a name="ln1562">    } else {</a>
<a name="ln1563">      // Closest to the end of the list.</a>
<a name="ln1564">      item = l-&gt;lv_last;</a>
<a name="ln1565">      idx = l-&gt;lv_len - 1;</a>
<a name="ln1566">    }</a>
<a name="ln1567">  }</a>
<a name="ln1568"> </a>
<a name="ln1569">  while (n &gt; idx) {</a>
<a name="ln1570">    // Search forward.</a>
<a name="ln1571">    item = item-&gt;li_next;</a>
<a name="ln1572">    idx++;</a>
<a name="ln1573">  }</a>
<a name="ln1574">  while (n &lt; idx) {</a>
<a name="ln1575">    // Search backward.</a>
<a name="ln1576">    item = item-&gt;li_prev;</a>
<a name="ln1577">    idx--;</a>
<a name="ln1578">  }</a>
<a name="ln1579"> </a>
<a name="ln1580">  assert(idx == n);</a>
<a name="ln1581">  // Cache the used index.</a>
<a name="ln1582">  l-&gt;lv_idx = idx;</a>
<a name="ln1583">  l-&gt;lv_idx_item = item;</a>
<a name="ln1584"> </a>
<a name="ln1585">  return item;</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">/// Get list item l[n] as a number</a>
<a name="ln1589">///</a>
<a name="ln1590">/// @param[in]  l  List to index.</a>
<a name="ln1591">/// @param[in]  n  Index in a list.</a>
<a name="ln1592">/// @param[out]  ret_error  Location where 1 will be saved if index was not</a>
<a name="ln1593">///                         found. May be NULL. If everything is OK,</a>
<a name="ln1594">///                         `*ret_error` is not touched.</a>
<a name="ln1595">///</a>
<a name="ln1596">/// @return Integer value at the given index or -1.</a>
<a name="ln1597">varnumber_T tv_list_find_nr(list_T *const l, const int n, bool *const ret_error)</a>
<a name="ln1598">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1599">{</a>
<a name="ln1600">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1601">  if (li == NULL) {</a>
<a name="ln1602">    if (ret_error != NULL) {</a>
<a name="ln1603">      *ret_error = true;</a>
<a name="ln1604">    }</a>
<a name="ln1605">    return -1;</a>
<a name="ln1606">  }</a>
<a name="ln1607">  return tv_get_number_chk(TV_LIST_ITEM_TV(li), ret_error);</a>
<a name="ln1608">}</a>
<a name="ln1609"> </a>
<a name="ln1610">/// Get list item l[n] as a string</a>
<a name="ln1611">///</a>
<a name="ln1612">/// @param[in]  l  List to index.</a>
<a name="ln1613">/// @param[in]  n  Index in a list.</a>
<a name="ln1614">///</a>
<a name="ln1615">/// @return List item string value or NULL in case of error.</a>
<a name="ln1616">const char *tv_list_find_str(list_T *const l, const int n)</a>
<a name="ln1617">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1618">{</a>
<a name="ln1619">  const listitem_T *const li = tv_list_find(l, n);</a>
<a name="ln1620">  if (li == NULL) {</a>
<a name="ln1621">    semsg(_(e_list_index_out_of_range_nr), (int64_t)n);</a>
<a name="ln1622">    return NULL;</a>
<a name="ln1623">  }</a>
<a name="ln1624">  return tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">/// Like tv_list_find() but when a negative index is used that is not found use</a>
<a name="ln1628">/// zero and set &quot;idx&quot; to zero.  Used for first index of a range.</a>
<a name="ln1629">static listitem_T *tv_list_find_index(list_T *const l, long *const idx)</a>
<a name="ln1630">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1631">{</a>
<a name="ln1632">  listitem_T *li = tv_list_find(l, (int)(*idx));</a>
<a name="ln1633">  if (li == NULL) {</a>
<a name="ln1634">    if (*idx &lt; 0) {</a>
<a name="ln1635">      *idx = 0;</a>
<a name="ln1636">      li = tv_list_find(l, (int)(*idx));</a>
<a name="ln1637">    }</a>
<a name="ln1638">  }</a>
<a name="ln1639">  return li;</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">/// Locate item in a list and return its index</a>
<a name="ln1643">///</a>
<a name="ln1644">/// @param[in]  l  List to search.</a>
<a name="ln1645">/// @param[in]  item  Item to search for.</a>
<a name="ln1646">///</a>
<a name="ln1647">/// @return Index of an item or -1 if item is not in the list.</a>
<a name="ln1648">long tv_list_idx_of_item(const list_T *const l, const listitem_T *const item)</a>
<a name="ln1649">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1650">{</a>
<a name="ln1651">  if (l == NULL) {</a>
<a name="ln1652">    return -1;</a>
<a name="ln1653">  }</a>
<a name="ln1654">  int idx = 0;</a>
<a name="ln1655">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln1656">    if (li == item) {</a>
<a name="ln1657">      return idx;</a>
<a name="ln1658">    }</a>
<a name="ln1659">    idx++;</a>
<a name="ln1660">  });</a>
<a name="ln1661">  return -1;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">//{{{1 Dictionaries</a>
<a name="ln1665">//{{{2 Dictionary watchers</a>
<a name="ln1666"> </a>
<a name="ln1667">/// Perform all necessary cleanup for a `DictWatcher` instance</a>
<a name="ln1668">///</a>
<a name="ln1669">/// @param  watcher  Watcher to free.</a>
<a name="ln1670">static void tv_dict_watcher_free(DictWatcher *watcher)</a>
<a name="ln1671">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1672">{</a>
<a name="ln1673">  callback_free(&amp;watcher-&gt;callback);</a>
<a name="ln1674">  xfree(watcher-&gt;key_pattern);</a>
<a name="ln1675">  xfree(watcher);</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678">/// Add watcher to a dictionary</a>
<a name="ln1679">///</a>
<a name="ln1680">/// @param[in]  dict  Dictionary to add watcher to.</a>
<a name="ln1681">/// @param[in]  key_pattern  Pattern to watch for.</a>
<a name="ln1682">/// @param[in]  key_pattern_len  Key pattern length.</a>
<a name="ln1683">/// @param  callback  Function to be called on events.</a>
<a name="ln1684">void tv_dict_watcher_add(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1685">                         const size_t key_pattern_len, Callback callback)</a>
<a name="ln1686">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1687">{</a>
<a name="ln1688">  if (dict == NULL) {</a>
<a name="ln1689">    return;</a>
<a name="ln1690">  }</a>
<a name="ln1691">  DictWatcher *const watcher = xmalloc(sizeof(DictWatcher));</a>
<a name="ln1692">  watcher-&gt;key_pattern = xmemdupz(key_pattern, key_pattern_len);</a>
<a name="ln1693">  watcher-&gt;key_pattern_len = key_pattern_len;</a>
<a name="ln1694">  watcher-&gt;callback = callback;</a>
<a name="ln1695">  watcher-&gt;busy = false;</a>
<a name="ln1696">  watcher-&gt;needs_free = false;</a>
<a name="ln1697">  QUEUE_INSERT_TAIL(&amp;dict-&gt;watchers, &amp;watcher-&gt;node);</a>
<a name="ln1698">}</a>
<a name="ln1699"> </a>
<a name="ln1700">/// Check whether two callbacks are equal</a>
<a name="ln1701">///</a>
<a name="ln1702">/// @param[in]  cb1  First callback to check.</a>
<a name="ln1703">/// @param[in]  cb2  Second callback to check.</a>
<a name="ln1704">///</a>
<a name="ln1705">/// @return True if they are equal, false otherwise.</a>
<a name="ln1706">bool tv_callback_equal(const Callback *cb1, const Callback *cb2)</a>
<a name="ln1707">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1708">{</a>
<a name="ln1709">  if (cb1-&gt;type != cb2-&gt;type) {</a>
<a name="ln1710">    return false;</a>
<a name="ln1711">  }</a>
<a name="ln1712">  switch (cb1-&gt;type) {</a>
<a name="ln1713">  case kCallbackFuncref:</a>
<a name="ln1714">    return strcmp(cb1-&gt;data.funcref, cb2-&gt;data.funcref) == 0;</a>
<a name="ln1715">  case kCallbackPartial:</a>
<a name="ln1716">    // FIXME: this is inconsistent with tv_equal but is needed for precision</a>
<a name="ln1717">    // maybe change dictwatcheradd to return a watcher id instead?</a>
<a name="ln1718">    return cb1-&gt;data.partial == cb2-&gt;data.partial;</a>
<a name="ln1719">  case kCallbackLua:</a>
<a name="ln1720">    return cb1-&gt;data.luaref == cb2-&gt;data.luaref;</a>
<a name="ln1721">  case kCallbackNone:</a>
<a name="ln1722">    return true;</a>
<a name="ln1723">  }</a>
<a name="ln1724">  abort();</a>
<a name="ln1725">  return false;</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">/// Unref/free callback</a>
<a name="ln1729">void callback_free(Callback *callback)</a>
<a name="ln1730">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1731">{</a>
<a name="ln1732">  switch (callback-&gt;type) {</a>
<a name="ln1733">  case kCallbackFuncref:</a>
<a name="ln1734">    func_unref(callback-&gt;data.funcref);</a>
<a name="ln1735">    xfree(callback-&gt;data.funcref);</a>
<a name="ln1736">    break;</a>
<a name="ln1737">  case kCallbackPartial:</a>
<a name="ln1738">    partial_unref(callback-&gt;data.partial);</a>
<a name="ln1739">    break;</a>
<a name="ln1740">  case kCallbackLua:</a>
<a name="ln1741">    NLUA_CLEAR_REF(callback-&gt;data.luaref);</a>
<a name="ln1742">    break;</a>
<a name="ln1743">  case kCallbackNone:</a>
<a name="ln1744">    break;</a>
<a name="ln1745">  }</a>
<a name="ln1746">  callback-&gt;type = kCallbackNone;</a>
<a name="ln1747">  callback-&gt;data.funcref = NULL;</a>
<a name="ln1748">}</a>
<a name="ln1749"> </a>
<a name="ln1750">/// Copy a callback into a typval_T.</a>
<a name="ln1751">void callback_put(Callback *cb, typval_T *tv)</a>
<a name="ln1752">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1753">{</a>
<a name="ln1754">  switch (cb-&gt;type) {</a>
<a name="ln1755">  case kCallbackPartial:</a>
<a name="ln1756">    tv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln1757">    tv-&gt;vval.v_partial = cb-&gt;data.partial;</a>
<a name="ln1758">    cb-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln1759">    break;</a>
<a name="ln1760">  case kCallbackFuncref:</a>
<a name="ln1761">    tv-&gt;v_type = VAR_FUNC;</a>
<a name="ln1762">    tv-&gt;vval.v_string = xstrdup(cb-&gt;data.funcref);</a>
<a name="ln1763">    func_ref(cb-&gt;data.funcref);</a>
<a name="ln1764">    break;</a>
<a name="ln1765">  case kCallbackLua:</a>
<a name="ln1766">  // TODO(tjdevries): Unified Callback.</a>
<a name="ln1767">  // At this point this isn't possible, but it'd be nice to put</a>
<a name="ln1768">  // these handled more neatly in one place.</a>
<a name="ln1769">  // So instead, we just do the default and put nil</a>
<a name="ln1770">  default:</a>
<a name="ln1771">    tv-&gt;v_type = VAR_SPECIAL;</a>
<a name="ln1772">    tv-&gt;vval.v_special = kSpecialVarNull;</a>
<a name="ln1773">    break;</a>
<a name="ln1774">  }</a>
<a name="ln1775">}</a>
<a name="ln1776"> </a>
<a name="ln1777">// Copy callback from &quot;src&quot; to &quot;dest&quot;, incrementing the refcounts.</a>
<a name="ln1778">void callback_copy(Callback *dest, Callback *src)</a>
<a name="ln1779">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1780">{</a>
<a name="ln1781">  dest-&gt;type = src-&gt;type;</a>
<a name="ln1782">  switch (src-&gt;type) {</a>
<a name="ln1783">  case kCallbackPartial:</a>
<a name="ln1784">    dest-&gt;data.partial = src-&gt;data.partial;</a>
<a name="ln1785">    dest-&gt;data.partial-&gt;pt_refcount++;</a>
<a name="ln1786">    break;</a>
<a name="ln1787">  case kCallbackFuncref:</a>
<a name="ln1788">    dest-&gt;data.funcref = xstrdup(src-&gt;data.funcref);</a>
<a name="ln1789">    func_ref(src-&gt;data.funcref);</a>
<a name="ln1790">    break;</a>
<a name="ln1791">  case kCallbackLua:</a>
<a name="ln1792">    dest-&gt;data.luaref = api_new_luaref(src-&gt;data.luaref);</a>
<a name="ln1793">    break;</a>
<a name="ln1794">  default:</a>
<a name="ln1795">    dest-&gt;data.funcref = NULL;</a>
<a name="ln1796">    break;</a>
<a name="ln1797">  }</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">/// Generate a string description of a callback</a>
<a name="ln1801">char *callback_to_string(Callback *cb)</a>
<a name="ln1802">{</a>
<a name="ln1803">  if (cb-&gt;type == kCallbackLua) {</a>
<a name="ln1804">    return nlua_funcref_str(cb-&gt;data.luaref);</a>
<a name="ln1805">  }</a>
<a name="ln1806"> </a>
<a name="ln1807">  const size_t msglen = 100;</a>
<a name="ln1808">  char *msg = xmallocz(msglen);</a>
<a name="ln1809"> </a>
<a name="ln1810">  switch (cb-&gt;type) {</a>
<a name="ln1811">  case kCallbackFuncref:</a>
<a name="ln1812">    // TODO(tjdevries): Is this enough space for this?</a>
<a name="ln1813">    snprintf(msg, msglen, &quot;&lt;vim function: %s&gt;&quot;, cb-&gt;data.funcref);</a>
<a name="ln1814">    break;</a>
<a name="ln1815">  case kCallbackPartial:</a>
<a name="ln1816">    snprintf(msg, msglen, &quot;&lt;vim partial: %s&gt;&quot;, cb-&gt;data.partial-&gt;pt_name);</a>
<a name="ln1817">    break;</a>
<a name="ln1818">  default:</a>
<a name="ln1819">    *msg = '\0';</a>
<a name="ln1820">    break;</a>
<a name="ln1821">  }</a>
<a name="ln1822">  return msg;</a>
<a name="ln1823">}</a>
<a name="ln1824"> </a>
<a name="ln1825">/// Remove watcher from a dictionary</a>
<a name="ln1826">///</a>
<a name="ln1827">/// @param  dict  Dictionary to remove watcher from.</a>
<a name="ln1828">/// @param[in]  key_pattern  Pattern to remove watcher for.</a>
<a name="ln1829">/// @param[in]  key_pattern_len  Pattern length.</a>
<a name="ln1830">/// @param  callback  Callback to remove watcher for.</a>
<a name="ln1831">///</a>
<a name="ln1832">/// @return True on success, false if relevant watcher was not found.</a>
<a name="ln1833">bool tv_dict_watcher_remove(dict_T *const dict, const char *const key_pattern,</a>
<a name="ln1834">                            const size_t key_pattern_len, Callback callback)</a>
<a name="ln1835">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1836">{</a>
<a name="ln1837">  if (dict == NULL) {</a>
<a name="ln1838">    return false;</a>
<a name="ln1839">  }</a>
<a name="ln1840"> </a>
<a name="ln1841">  QUEUE *w = NULL;</a>
<a name="ln1842">  DictWatcher *watcher = NULL;</a>
<a name="ln1843">  bool matched = false;</a>
<a name="ln1844">  bool queue_is_busy = false;</a>
<a name="ln1845">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1846">    watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1847">    if (watcher-&gt;busy) {</a>
<a name="ln1848">      queue_is_busy = true;</a>
<a name="ln1849">    }</a>
<a name="ln1850">    if (tv_callback_equal(&amp;watcher-&gt;callback, &amp;callback)</a>
<a name="ln1851">        &amp;&amp; watcher-&gt;key_pattern_len == key_pattern_len</a>
<a name="ln1852">        &amp;&amp; memcmp(watcher-&gt;key_pattern, key_pattern, key_pattern_len) == 0) {</a>
<a name="ln1853">      matched = true;</a>
<a name="ln1854">      break;</a>
<a name="ln1855">    }</a>
<a name="ln1856">  })</a>
<a name="ln1857"> </a>
<a name="ln1858">  if (!matched) {</a>
<a name="ln1859">    return false;</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  if (queue_is_busy) {</a>
<a name="ln1863">    watcher-&gt;needs_free = true;</a>
<a name="ln1864">  } else {</a>
<a name="ln1865">    QUEUE_REMOVE(w);</a>
<a name="ln1866">    tv_dict_watcher_free(watcher);</a>
<a name="ln1867">  }</a>
<a name="ln1868">  return true;</a>
<a name="ln1869">}</a>
<a name="ln1870"> </a>
<a name="ln1871">/// Test if `key` matches with with `watcher-&gt;key_pattern`</a>
<a name="ln1872">///</a>
<a name="ln1873">/// @param[in]  watcher  Watcher to check key pattern from.</a>
<a name="ln1874">/// @param[in]  key  Key to check.</a>
<a name="ln1875">///</a>
<a name="ln1876">/// @return true if key matches, false otherwise.</a>
<a name="ln1877">static bool tv_dict_watcher_matches(DictWatcher *watcher, const char *const key)</a>
<a name="ln1878">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln1879">{</a>
<a name="ln1880">  // For now only allow very simple globbing in key patterns: a '*' at the end</a>
<a name="ln1881">  // of the string means it should match everything up to the '*' instead of the</a>
<a name="ln1882">  // whole string.</a>
<a name="ln1883">  const size_t len = watcher-&gt;key_pattern_len;</a>
<a name="ln1884">  if (len &amp;&amp; watcher-&gt;key_pattern[len - 1] == '*') {</a>
<a name="ln1885">    return strncmp(key, watcher-&gt;key_pattern, len - 1) == 0;</a>
<a name="ln1886">  }</a>
<a name="ln1887">  return strcmp(key, watcher-&gt;key_pattern) == 0;</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">/// Send a change notification to all dictionary watchers that match given key</a>
<a name="ln1891">///</a>
<a name="ln1892">/// @param[in]  dict  Dictionary which was modified.</a>
<a name="ln1893">/// @param[in]  key  Key which was modified.</a>
<a name="ln1894">/// @param[in]  newtv  New key value.</a>
<a name="ln1895">/// @param[in]  oldtv  Old key value.</a>
<a name="ln1896">void tv_dict_watcher_notify(dict_T *const dict, const char *const key, typval_T *const newtv,</a>
<a name="ln1897">                            typval_T *const oldtv)</a>
<a name="ln1898">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln1899">{</a>
<a name="ln1900">  typval_T argv[3];</a>
<a name="ln1901"> </a>
<a name="ln1902">  argv[0].v_type = VAR_DICT;</a>
<a name="ln1903">  argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln1904">  argv[0].vval.v_dict = dict;</a>
<a name="ln1905">  argv[1].v_type = VAR_STRING;</a>
<a name="ln1906">  argv[1].v_lock = VAR_UNLOCKED;</a>
<a name="ln1907">  argv[1].vval.v_string = xstrdup(key);</a>
<a name="ln1908">  argv[2].v_type = VAR_DICT;</a>
<a name="ln1909">  argv[2].v_lock = VAR_UNLOCKED;</a>
<a name="ln1910">  argv[2].vval.v_dict = tv_dict_alloc();</a>
<a name="ln1911">  argv[2].vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln1912"> </a>
<a name="ln1913">  if (newtv) {</a>
<a name="ln1914">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;new&quot;));</a>
<a name="ln1915">    tv_copy(newtv, &amp;v-&gt;di_tv);</a>
<a name="ln1916">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1917">  }</a>
<a name="ln1918"> </a>
<a name="ln1919">  if (oldtv &amp;&amp; oldtv-&gt;v_type != VAR_UNKNOWN) {</a>
<a name="ln1920">    dictitem_T *const v = tv_dict_item_alloc_len(S_LEN(&quot;old&quot;));</a>
<a name="ln1921">    tv_copy(oldtv, &amp;v-&gt;di_tv);</a>
<a name="ln1922">    tv_dict_add(argv[2].vval.v_dict, v);</a>
<a name="ln1923">  }</a>
<a name="ln1924"> </a>
<a name="ln1925">  typval_T rettv;</a>
<a name="ln1926"> </a>
<a name="ln1927">  bool any_needs_free = false;</a>
<a name="ln1928">  dict-&gt;dv_refcount++;</a>
<a name="ln1929">  QUEUE *w;</a>
<a name="ln1930">  QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1931">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1932">    if (!watcher-&gt;busy &amp;&amp; tv_dict_watcher_matches(watcher, key)) {</a>
<a name="ln1933">      rettv = TV_INITIAL_VALUE;</a>
<a name="ln1934">      watcher-&gt;busy = true;</a>
<a name="ln1935">      callback_call(&amp;watcher-&gt;callback, 3, argv, &amp;rettv);</a>
<a name="ln1936">      watcher-&gt;busy = false;</a>
<a name="ln1937">      tv_clear(&amp;rettv);</a>
<a name="ln1938">      if (watcher-&gt;needs_free) {</a>
<a name="ln1939">        any_needs_free = true;</a>
<a name="ln1940">      }</a>
<a name="ln1941">    }</a>
<a name="ln1942">  })</a>
<a name="ln1943">  if (any_needs_free) {</a>
<a name="ln1944">    QUEUE_FOREACH(w, &amp;dict-&gt;watchers, {</a>
<a name="ln1945">      DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln1946">      if (watcher-&gt;needs_free) {</a>
<a name="ln1947">        QUEUE_REMOVE(w);</a>
<a name="ln1948">        tv_dict_watcher_free(watcher);</a>
<a name="ln1949">      }</a>
<a name="ln1950">    })</a>
<a name="ln1951">  }</a>
<a name="ln1952">  tv_dict_unref(dict);</a>
<a name="ln1953"> </a>
<a name="ln1954">  for (size_t i = 1; i &lt; ARRAY_SIZE(argv); i++) {</a>
<a name="ln1955">    tv_clear(argv + i);</a>
<a name="ln1956">  }</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959">//{{{2 Dictionary item</a>
<a name="ln1960"> </a>
<a name="ln1961">/// Allocate a dictionary item</a>
<a name="ln1962">///</a>
<a name="ln1963">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1964">///       be initialized.</a>
<a name="ln1965">///</a>
<a name="ln1966">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1967">/// @param[in]  key_len  Key length.</a>
<a name="ln1968">///</a>
<a name="ln1969">/// @return [allocated] new dictionary item.</a>
<a name="ln1970">dictitem_T *tv_dict_item_alloc_len(const char *const key, const size_t key_len)</a>
<a name="ln1971">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1972">  FUNC_ATTR_MALLOC</a>
<a name="ln1973">{</a>
<a name="ln1974">  dictitem_T *const di = xmalloc(offsetof(dictitem_T, di_key) + key_len + 1);</a>
<a name="ln1975">  memcpy(di-&gt;di_key, key, key_len);</a>
<a name="ln1976">  di-&gt;di_key[key_len] = NUL;</a>
<a name="ln1977">  di-&gt;di_flags = DI_FLAGS_ALLOC;</a>
<a name="ln1978">  di-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln1979">  di-&gt;di_tv.v_type = VAR_UNKNOWN;</a>
<a name="ln1980">  return di;</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">/// Allocate a dictionary item</a>
<a name="ln1984">///</a>
<a name="ln1985">/// @note that the type and value of the item (-&gt;di_tv) still needs to</a>
<a name="ln1986">///       be initialized.</a>
<a name="ln1987">///</a>
<a name="ln1988">/// @param[in]  key  Key, is copied to the new item.</a>
<a name="ln1989">///</a>
<a name="ln1990">/// @return [allocated] new dictionary item.</a>
<a name="ln1991">dictitem_T *tv_dict_item_alloc(const char *const key)</a>
<a name="ln1992">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1993">  FUNC_ATTR_MALLOC</a>
<a name="ln1994">{</a>
<a name="ln1995">  return tv_dict_item_alloc_len(key, strlen(key));</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/// Free a dictionary item, also clearing the value</a>
<a name="ln1999">///</a>
<a name="ln2000">/// @param  item  Item to free.</a>
<a name="ln2001">void tv_dict_item_free(dictitem_T *const item)</a>
<a name="ln2002">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2003">{</a>
<a name="ln2004">  tv_clear(&amp;item-&gt;di_tv);</a>
<a name="ln2005">  if (item-&gt;di_flags &amp; DI_FLAGS_ALLOC) {</a>
<a name="ln2006">    xfree(item);</a>
<a name="ln2007">  }</a>
<a name="ln2008">}</a>
<a name="ln2009"> </a>
<a name="ln2010">/// Make a copy of a dictionary item</a>
<a name="ln2011">///</a>
<a name="ln2012">/// @param[in]  di  Item to copy.</a>
<a name="ln2013">///</a>
<a name="ln2014">/// @return [allocated] new dictionary item.</a>
<a name="ln2015">dictitem_T *tv_dict_item_copy(dictitem_T *const di)</a>
<a name="ln2016">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2017">{</a>
<a name="ln2018">  dictitem_T *const new_di = tv_dict_item_alloc(di-&gt;di_key);</a>
<a name="ln2019">  tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln2020">  return new_di;</a>
<a name="ln2021">}</a>
<a name="ln2022"> </a>
<a name="ln2023">/// Remove item from dictionary and free it</a>
<a name="ln2024">///</a>
<a name="ln2025">/// @param  dict  Dictionary to remove item from.</a>
<a name="ln2026">/// @param  item  Item to remove.</a>
<a name="ln2027">void tv_dict_item_remove(dict_T *const dict, dictitem_T *const item)</a>
<a name="ln2028">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2029">{</a>
<a name="ln2030">  hashitem_T *const hi = hash_find(&amp;dict-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln2031">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2032">    semsg(_(e_intern2), &quot;tv_dict_item_remove()&quot;);</a>
<a name="ln2033">  } else {</a>
<a name="ln2034">    hash_remove(&amp;dict-&gt;dv_hashtab, hi);</a>
<a name="ln2035">  }</a>
<a name="ln2036">  tv_dict_item_free(item);</a>
<a name="ln2037">}</a>
<a name="ln2038"> </a>
<a name="ln2039">//{{{2 Alloc/free</a>
<a name="ln2040"> </a>
<a name="ln2041">/// Allocate an empty dictionary.</a>
<a name="ln2042">/// Caller should take care of the reference count.</a>
<a name="ln2043">///</a>
<a name="ln2044">/// @return [allocated] new dictionary.</a>
<a name="ln2045">dict_T *tv_dict_alloc(void)</a>
<a name="ln2046">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2047">{</a>
<a name="ln2048">  dict_T *const d = xcalloc(1, sizeof(dict_T));</a>
<a name="ln2049"> </a>
<a name="ln2050">  // Add the dict to the list of dicts for garbage collection.</a>
<a name="ln2051">  if (gc_first_dict != NULL) {</a>
<a name="ln2052">    gc_first_dict-&gt;dv_used_prev = d;</a>
<a name="ln2053">  }</a>
<a name="ln2054">  d-&gt;dv_used_next = gc_first_dict;</a>
<a name="ln2055">  d-&gt;dv_used_prev = NULL;</a>
<a name="ln2056">  gc_first_dict = d;</a>
<a name="ln2057"> </a>
<a name="ln2058">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2059">  d-&gt;dv_lock = VAR_UNLOCKED;</a>
<a name="ln2060">  d-&gt;dv_scope = VAR_NO_SCOPE;</a>
<a name="ln2061">  d-&gt;dv_refcount = 0;</a>
<a name="ln2062">  d-&gt;dv_copyID = 0;</a>
<a name="ln2063">  QUEUE_INIT(&amp;d-&gt;watchers);</a>
<a name="ln2064"> </a>
<a name="ln2065">  d-&gt;lua_table_ref = LUA_NOREF;</a>
<a name="ln2066"> </a>
<a name="ln2067">  return d;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">/// Free items contained in a dictionary</a>
<a name="ln2071">///</a>
<a name="ln2072">/// @param[in,out]  d  Dictionary to clear.</a>
<a name="ln2073">void tv_dict_free_contents(dict_T *const d)</a>
<a name="ln2074">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2075">{</a>
<a name="ln2076">  // Lock the hashtab, we don't want it to resize while freeing items.</a>
<a name="ln2077">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2078">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln2079">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln2080">    // Remove the item before deleting it, just in case there is</a>
<a name="ln2081">    // something recursive causing trouble.</a>
<a name="ln2082">    dictitem_T *const di = TV_DICT_HI2DI(hi);</a>
<a name="ln2083">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln2084">    tv_dict_item_free(di);</a>
<a name="ln2085">  });</a>
<a name="ln2086"> </a>
<a name="ln2087">  while (!QUEUE_EMPTY(&amp;d-&gt;watchers)) {</a>
<a name="ln2088">    QUEUE *w = QUEUE_HEAD(&amp;d-&gt;watchers);</a>
<a name="ln2089">    QUEUE_REMOVE(w);</a>
<a name="ln2090">    DictWatcher *watcher = tv_dict_watcher_node_data(w);</a>
<a name="ln2091">    tv_dict_watcher_free(watcher);</a>
<a name="ln2092">  }</a>
<a name="ln2093"> </a>
<a name="ln2094">  hash_clear(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2095">  d-&gt;dv_hashtab.ht_locked--;</a>
<a name="ln2096">  hash_init(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">/// Free a dictionary itself, ignoring items it contains</a>
<a name="ln2100">///</a>
<a name="ln2101">/// Ignores the reference count.</a>
<a name="ln2102">///</a>
<a name="ln2103">/// @param[in,out]  d  Dictionary to free.</a>
<a name="ln2104">void tv_dict_free_dict(dict_T *const d)</a>
<a name="ln2105">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2106">{</a>
<a name="ln2107">  // Remove the dict from the list of dicts for garbage collection.</a>
<a name="ln2108">  if (d-&gt;dv_used_prev == NULL) {</a>
<a name="ln2109">    gc_first_dict = d-&gt;dv_used_next;</a>
<a name="ln2110">  } else {</a>
<a name="ln2111">    d-&gt;dv_used_prev-&gt;dv_used_next = d-&gt;dv_used_next;</a>
<a name="ln2112">  }</a>
<a name="ln2113">  if (d-&gt;dv_used_next != NULL) {</a>
<a name="ln2114">    d-&gt;dv_used_next-&gt;dv_used_prev = d-&gt;dv_used_prev;</a>
<a name="ln2115">  }</a>
<a name="ln2116"> </a>
<a name="ln2117">  NLUA_CLEAR_REF(d-&gt;lua_table_ref);</a>
<a name="ln2118">  xfree(d);</a>
<a name="ln2119">}</a>
<a name="ln2120"> </a>
<a name="ln2121">/// Free a dictionary, including all items it contains</a>
<a name="ln2122">///</a>
<a name="ln2123">/// Ignores the reference count.</a>
<a name="ln2124">///</a>
<a name="ln2125">/// @param  d  Dictionary to free.</a>
<a name="ln2126">void tv_dict_free(dict_T *const d)</a>
<a name="ln2127">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2128">{</a>
<a name="ln2129">  if (!tv_in_free_unref_items) {</a>
<a name="ln2130">    tv_dict_free_contents(d);</a>
<a name="ln2131">    tv_dict_free_dict(d);</a>
<a name="ln2132">  }</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135">/// Unreference a dictionary</a>
<a name="ln2136">///</a>
<a name="ln2137">/// Decrements the reference count and frees dictionary when it becomes zero.</a>
<a name="ln2138">///</a>
<a name="ln2139">/// @param[in]  d  Dictionary to operate on.</a>
<a name="ln2140">void tv_dict_unref(dict_T *const d)</a>
<a name="ln2141">{</a>
<a name="ln2142">  if (d != NULL &amp;&amp; --d-&gt;dv_refcount &lt;= 0) {</a>
<a name="ln2143">    tv_dict_free(d);</a>
<a name="ln2144">  }</a>
<a name="ln2145">}</a>
<a name="ln2146"> </a>
<a name="ln2147">//{{{2 Indexing/searching</a>
<a name="ln2148"> </a>
<a name="ln2149">/// Find item in dictionary</a>
<a name="ln2150">///</a>
<a name="ln2151">/// @param[in]  d  Dictionary to check.</a>
<a name="ln2152">/// @param[in]  key  Dictionary key.</a>
<a name="ln2153">/// @param[in]  len  Key length. If negative, then strlen(key) is used.</a>
<a name="ln2154">///</a>
<a name="ln2155">/// @return found item or NULL if nothing was found.</a>
<a name="ln2156">dictitem_T *tv_dict_find(const dict_T *const d, const char *const key, const ptrdiff_t len)</a>
<a name="ln2157">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2158">{</a>
<a name="ln2159">  if (d == NULL) {</a>
<a name="ln2160">    return NULL;</a>
<a name="ln2161">  }</a>
<a name="ln2162">  hashitem_T *const hi = (len &lt; 0</a>
<a name="ln2163">                          ? hash_find(&amp;d-&gt;dv_hashtab, key)</a>
<a name="ln2164">                          : hash_find_len(&amp;d-&gt;dv_hashtab, key, (size_t)len));</a>
<a name="ln2165">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2166">    return NULL;</a>
<a name="ln2167">  }</a>
<a name="ln2168">  return TV_DICT_HI2DI(hi);</a>
<a name="ln2169">}</a>
<a name="ln2170"> </a>
<a name="ln2171">/// Get a typval item from a dictionary and copy it into &quot;rettv&quot;.</a>
<a name="ln2172">///</a>
<a name="ln2173">/// @param[in]  d  Dictionary to check.</a>
<a name="ln2174">/// @param[in]  key  Dictionary key.</a>
<a name="ln2175">/// @param[in]  rettv  Return value.</a>
<a name="ln2176">/// @return OK in case of success or FAIL if nothing was found.</a>
<a name="ln2177">int tv_dict_get_tv(dict_T *d, const char *const key, typval_T *rettv)</a>
<a name="ln2178">{</a>
<a name="ln2179">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2180">  if (di == NULL) {</a>
<a name="ln2181">    return FAIL;</a>
<a name="ln2182">  }</a>
<a name="ln2183"> </a>
<a name="ln2184">  tv_copy(&amp;di-&gt;di_tv, rettv);</a>
<a name="ln2185">  return OK;</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">/// Get a number item from a dictionary</a>
<a name="ln2189">///</a>
<a name="ln2190">/// Returns 0 if the entry does not exist.</a>
<a name="ln2191">///</a>
<a name="ln2192">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2193">/// @param[in]  key  Key to find in dictionary.</a>
<a name="ln2194">///</a>
<a name="ln2195">/// @return Dictionary item.</a>
<a name="ln2196">varnumber_T tv_dict_get_number(const dict_T *const d, const char *const key)</a>
<a name="ln2197">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2198">{</a>
<a name="ln2199">  return tv_dict_get_number_def(d, key, 0);</a>
<a name="ln2200">}</a>
<a name="ln2201"> </a>
<a name="ln2202">/// Get a number item from a dictionary.</a>
<a name="ln2203">///</a>
<a name="ln2204">/// Returns &quot;def&quot; if the entry doesn't exist.</a>
<a name="ln2205">///</a>
<a name="ln2206">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2207">/// @param[in]  key  Key to find in dictionary.</a>
<a name="ln2208">/// @param[in]  def  Default value.</a>
<a name="ln2209">///</a>
<a name="ln2210">/// @return Dictionary item.</a>
<a name="ln2211">varnumber_T tv_dict_get_number_def(const dict_T *const d, const char *const key, const int def)</a>
<a name="ln2212">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2213">{</a>
<a name="ln2214">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2215">  if (di == NULL) {</a>
<a name="ln2216">    return def;</a>
<a name="ln2217">  }</a>
<a name="ln2218">  return tv_get_number(&amp;di-&gt;di_tv);</a>
<a name="ln2219">}</a>
<a name="ln2220"> </a>
<a name="ln2221">varnumber_T tv_dict_get_bool(const dict_T *const d, const char *const key, const int def)</a>
<a name="ln2222">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2223">{</a>
<a name="ln2224">  dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2225">  if (di == NULL) {</a>
<a name="ln2226">    return def;</a>
<a name="ln2227">  }</a>
<a name="ln2228">  return tv_get_bool(&amp;di-&gt;di_tv);</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">/// Converts a dict to an environment</a>
<a name="ln2232">char **tv_dict_to_env(dict_T *denv)</a>
<a name="ln2233">{</a>
<a name="ln2234">  size_t env_size = (size_t)tv_dict_len(denv);</a>
<a name="ln2235"> </a>
<a name="ln2236">  size_t i = 0;</a>
<a name="ln2237">  char **env = NULL;</a>
<a name="ln2238"> </a>
<a name="ln2239">  // + 1 for NULL</a>
<a name="ln2240">  env = xmalloc((env_size + 1) * sizeof(*env));</a>
<a name="ln2241"> </a>
<a name="ln2242">  TV_DICT_ITER(denv, var, {</a>
<a name="ln2243">    const char *str = tv_get_string(&amp;var-&gt;di_tv);</a>
<a name="ln2244">    assert(str);</a>
<a name="ln2245">    size_t len = strlen(var-&gt;di_key) + strlen(str) + strlen(&quot;=&quot;) + 1;</a>
<a name="ln2246">    env[i] = xmalloc(len);</a>
<a name="ln2247">    snprintf(env[i], len, &quot;%s=%s&quot;, var-&gt;di_key, str);</a>
<a name="ln2248">    i++;</a>
<a name="ln2249">  });</a>
<a name="ln2250"> </a>
<a name="ln2251">  // must be null terminated</a>
<a name="ln2252">  env[env_size] = NULL;</a>
<a name="ln2253">  return env;</a>
<a name="ln2254">}</a>
<a name="ln2255"> </a>
<a name="ln2256">/// Get a string item from a dictionary</a>
<a name="ln2257">///</a>
<a name="ln2258">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2259">/// @param[in]  key  Dictionary key.</a>
<a name="ln2260">/// @param[in]  save  If true, returned string will be placed in the allocated</a>
<a name="ln2261">///                   memory.</a>
<a name="ln2262">///</a>
<a name="ln2263">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln2264">///         string item value otherwise. If returned value is not NULL, it may</a>
<a name="ln2265">///         be allocated depending on `save` argument.</a>
<a name="ln2266">char *tv_dict_get_string(const dict_T *const d, const char *const key, const bool save)</a>
<a name="ln2267">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2268">{</a>
<a name="ln2269">  static char numbuf[NUMBUFLEN];</a>
<a name="ln2270">  const char *const s = tv_dict_get_string_buf(d, key, numbuf);</a>
<a name="ln2271">  if (save &amp;&amp; s != NULL) {</a>
<a name="ln2272">    return xstrdup(s);</a>
<a name="ln2273">  }</a>
<a name="ln2274">  return (char *)s;</a>
<a name="ln2275">}</a>
<a name="ln2276"> </a>
<a name="ln2277">/// Get a string item from a dictionary</a>
<a name="ln2278">///</a>
<a name="ln2279">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2280">/// @param[in]  key  Dictionary key.</a>
<a name="ln2281">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln2282">///                     least of #NUMBUFLEN length.</a>
<a name="ln2283">///</a>
<a name="ln2284">/// @return NULL if key does not exist, empty string in case of type error,</a>
<a name="ln2285">///         string item value otherwise.</a>
<a name="ln2286">const char *tv_dict_get_string_buf(const dict_T *const d, const char *const key, char *const numbuf)</a>
<a name="ln2287">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2288">{</a>
<a name="ln2289">  const dictitem_T *const di = tv_dict_find(d, key, -1);</a>
<a name="ln2290">  if (di == NULL) {</a>
<a name="ln2291">    return NULL;</a>
<a name="ln2292">  }</a>
<a name="ln2293">  return tv_get_string_buf(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296">/// Get a string item from a dictionary</a>
<a name="ln2297">///</a>
<a name="ln2298">/// @param[in]  d  Dictionary to get item from.</a>
<a name="ln2299">/// @param[in]  key  Dictionary key.</a>
<a name="ln2300">/// @param[in]  key_len  Key length.</a>
<a name="ln2301">/// @param[in]  numbuf  Buffer for non-string items converted to strings, at</a>
<a name="ln2302">///                     least of #NUMBUFLEN length.</a>
<a name="ln2303">/// @param[in]  def  Default return when key does not exist.</a>
<a name="ln2304">///</a>
<a name="ln2305">/// @return `def` when key does not exist,</a>
<a name="ln2306">///         NULL in case of type error,</a>
<a name="ln2307">///         string item value in case of success.</a>
<a name="ln2308">const char *tv_dict_get_string_buf_chk(const dict_T *const d, const char *const key,</a>
<a name="ln2309">                                       const ptrdiff_t key_len, char *const numbuf,</a>
<a name="ln2310">                                       const char *const def)</a>
<a name="ln2311">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2312">{</a>
<a name="ln2313">  const dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln2314">  if (di == NULL) {</a>
<a name="ln2315">    return def;</a>
<a name="ln2316">  }</a>
<a name="ln2317">  return tv_get_string_buf_chk(&amp;di-&gt;di_tv, numbuf);</a>
<a name="ln2318">}</a>
<a name="ln2319"> </a>
<a name="ln2320">/// Get a function from a dictionary</a>
<a name="ln2321">///</a>
<a name="ln2322">/// @param[in]  d  Dictionary to get callback from.</a>
<a name="ln2323">/// @param[in]  key  Dictionary key.</a>
<a name="ln2324">/// @param[in]  key_len  Key length, may be -1 to use strlen().</a>
<a name="ln2325">/// @param[out]  result  The address where a pointer to the wanted callback</a>
<a name="ln2326">///                      will be left.</a>
<a name="ln2327">///</a>
<a name="ln2328">/// @return true/false on success/failure.</a>
<a name="ln2329">bool tv_dict_get_callback(dict_T *const d, const char *const key, const ptrdiff_t key_len,</a>
<a name="ln2330">                          Callback *const result)</a>
<a name="ln2331">  FUNC_ATTR_NONNULL_ARG(2, 4) FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2332">{</a>
<a name="ln2333">  result-&gt;type = kCallbackNone;</a>
<a name="ln2334"> </a>
<a name="ln2335">  dictitem_T *const di = tv_dict_find(d, key, key_len);</a>
<a name="ln2336"> </a>
<a name="ln2337">  if (di == NULL) {</a>
<a name="ln2338">    return true;</a>
<a name="ln2339">  }</a>
<a name="ln2340"> </a>
<a name="ln2341">  if (!tv_is_func(di-&gt;di_tv) &amp;&amp; di-&gt;di_tv.v_type != VAR_STRING) {</a>
<a name="ln2342">    emsg(_(&quot;E6000: Argument is not a function or function name&quot;));</a>
<a name="ln2343">    return false;</a>
<a name="ln2344">  }</a>
<a name="ln2345"> </a>
<a name="ln2346">  typval_T tv;</a>
<a name="ln2347">  tv_copy(&amp;di-&gt;di_tv, &amp;tv);</a>
<a name="ln2348">  set_selfdict(&amp;tv, d);</a>
<a name="ln2349">  const bool res = callback_from_typval(result, &amp;tv);</a>
<a name="ln2350">  tv_clear(&amp;tv);</a>
<a name="ln2351">  return res;</a>
<a name="ln2352">}</a>
<a name="ln2353"> </a>
<a name="ln2354">/// Check for adding a function to g: or l:.</a>
<a name="ln2355">/// If the name is wrong give an error message and return true.</a>
<a name="ln2356">int tv_dict_wrong_func_name(dict_T *d, typval_T *tv, const char *name)</a>
<a name="ln2357">{</a>
<a name="ln2358">  return (d == &amp;globvardict || &amp;d-&gt;dv_hashtab == get_funccal_local_ht())</a>
<a name="ln2359">         &amp;&amp; tv_is_func(*tv)</a>
<a name="ln2360">         &amp;&amp; var_wrong_func_name(name, true);</a>
<a name="ln2361">}</a>
<a name="ln2362"> </a>
<a name="ln2363">//{{{2 dict_add*</a>
<a name="ln2364"> </a>
<a name="ln2365">/// Add item to dictionary</a>
<a name="ln2366">///</a>
<a name="ln2367">/// @param[out]  d  Dictionary to add to.</a>
<a name="ln2368">/// @param[in]  item  Item to add.</a>
<a name="ln2369">///</a>
<a name="ln2370">/// @return FAIL if key already exists.</a>
<a name="ln2371">int tv_dict_add(dict_T *const d, dictitem_T *const item)</a>
<a name="ln2372">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2373">{</a>
<a name="ln2374">  if (tv_dict_wrong_func_name(d, &amp;item-&gt;di_tv, item-&gt;di_key)) {</a>
<a name="ln2375">    return FAIL;</a>
<a name="ln2376">  }</a>
<a name="ln2377">  return hash_add(&amp;d-&gt;dv_hashtab, item-&gt;di_key);</a>
<a name="ln2378">}</a>
<a name="ln2379"> </a>
<a name="ln2380">/// Add a list entry to dictionary</a>
<a name="ln2381">///</a>
<a name="ln2382">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2383">/// @param[in]  key  Key to add.</a>
<a name="ln2384">/// @param[in]  key_len  Key length.</a>
<a name="ln2385">/// @param  list  List to add. Will have reference count incremented.</a>
<a name="ln2386">///</a>
<a name="ln2387">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2388">int tv_dict_add_list(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2389">                     list_T *const list)</a>
<a name="ln2390">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2391">{</a>
<a name="ln2392">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2393"> </a>
<a name="ln2394">  item-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln2395">  item-&gt;di_tv.vval.v_list = list;</a>
<a name="ln2396">  tv_list_ref(list);</a>
<a name="ln2397">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2398">    tv_dict_item_free(item);</a>
<a name="ln2399">    return FAIL;</a>
<a name="ln2400">  }</a>
<a name="ln2401">  return OK;</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">/// Add a typval entry to dictionary.</a>
<a name="ln2405">///</a>
<a name="ln2406">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2407">/// @param[in]  key  Key to add.</a>
<a name="ln2408">/// @param[in]  key_len  Key length.</a>
<a name="ln2409">///</a>
<a name="ln2410">/// @return FAIL if out of memory or key already exists.</a>
<a name="ln2411">int tv_dict_add_tv(dict_T *d, const char *key, const size_t key_len, typval_T *tv)</a>
<a name="ln2412">{</a>
<a name="ln2413">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2414"> </a>
<a name="ln2415">  tv_copy(tv, &amp;item-&gt;di_tv);</a>
<a name="ln2416">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2417">    tv_dict_item_free(item);</a>
<a name="ln2418">    return FAIL;</a>
<a name="ln2419">  }</a>
<a name="ln2420">  return OK;</a>
<a name="ln2421">}</a>
<a name="ln2422"> </a>
<a name="ln2423">/// Add a dictionary entry to dictionary</a>
<a name="ln2424">///</a>
<a name="ln2425">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2426">/// @param[in]  key  Key to add.</a>
<a name="ln2427">/// @param[in]  key_len  Key length.</a>
<a name="ln2428">/// @param  dict  Dictionary to add. Will have reference count incremented.</a>
<a name="ln2429">///</a>
<a name="ln2430">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2431">int tv_dict_add_dict(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2432">                     dict_T *const dict)</a>
<a name="ln2433">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2434">{</a>
<a name="ln2435">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2436"> </a>
<a name="ln2437">  item-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln2438">  item-&gt;di_tv.vval.v_dict = dict;</a>
<a name="ln2439">  dict-&gt;dv_refcount++;</a>
<a name="ln2440">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2441">    tv_dict_item_free(item);</a>
<a name="ln2442">    return FAIL;</a>
<a name="ln2443">  }</a>
<a name="ln2444">  return OK;</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447">/// Add a number entry to dictionary</a>
<a name="ln2448">///</a>
<a name="ln2449">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2450">/// @param[in]  key  Key to add.</a>
<a name="ln2451">/// @param[in]  key_len  Key length.</a>
<a name="ln2452">/// @param[in]  nr  Number to add.</a>
<a name="ln2453">///</a>
<a name="ln2454">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2455">int tv_dict_add_nr(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2456">                   const varnumber_T nr)</a>
<a name="ln2457">{</a>
<a name="ln2458">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2459"> </a>
<a name="ln2460">  item-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln2461">  item-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln2462">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2463">    tv_dict_item_free(item);</a>
<a name="ln2464">    return FAIL;</a>
<a name="ln2465">  }</a>
<a name="ln2466">  return OK;</a>
<a name="ln2467">}</a>
<a name="ln2468"> </a>
<a name="ln2469">/// Add a floating point number entry to dictionary</a>
<a name="ln2470">///</a>
<a name="ln2471">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2472">/// @param[in]  key  Key to add.</a>
<a name="ln2473">/// @param[in]  key_len  Key length.</a>
<a name="ln2474">/// @param[in]  nr  Floating point number to add.</a>
<a name="ln2475">///</a>
<a name="ln2476">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2477">int tv_dict_add_float(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2478">                      const float_T nr)</a>
<a name="ln2479">{</a>
<a name="ln2480">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2481"> </a>
<a name="ln2482">  item-&gt;di_tv.v_type = VAR_FLOAT;</a>
<a name="ln2483">  item-&gt;di_tv.vval.v_float = nr;</a>
<a name="ln2484">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2485">    tv_dict_item_free(item);</a>
<a name="ln2486">    return FAIL;</a>
<a name="ln2487">  }</a>
<a name="ln2488">  return OK;</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">/// Add a boolean entry to dictionary</a>
<a name="ln2492">///</a>
<a name="ln2493">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2494">/// @param[in]  key  Key to add.</a>
<a name="ln2495">/// @param[in]  key_len  Key length.</a>
<a name="ln2496">/// @param[in]  val BoolVarValue to add.</a>
<a name="ln2497">///</a>
<a name="ln2498">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2499">int tv_dict_add_bool(dict_T *const d, const char *const key, const size_t key_len, BoolVarValue val)</a>
<a name="ln2500">{</a>
<a name="ln2501">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2502"> </a>
<a name="ln2503">  item-&gt;di_tv.v_type = VAR_BOOL;</a>
<a name="ln2504">  item-&gt;di_tv.vval.v_bool = val;</a>
<a name="ln2505">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2506">    tv_dict_item_free(item);</a>
<a name="ln2507">    return FAIL;</a>
<a name="ln2508">  }</a>
<a name="ln2509">  return OK;</a>
<a name="ln2510">}</a>
<a name="ln2511"> </a>
<a name="ln2512">/// Add a string entry to dictionary</a>
<a name="ln2513">///</a>
<a name="ln2514">/// @see tv_dict_add_allocated_str</a>
<a name="ln2515">int tv_dict_add_str(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2516">                    const char *const val)</a>
<a name="ln2517">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2518">{</a>
<a name="ln2519">  return tv_dict_add_str_len(d, key, key_len, val, -1);</a>
<a name="ln2520">}</a>
<a name="ln2521"> </a>
<a name="ln2522">/// Add a string entry to dictionary</a>
<a name="ln2523">///</a>
<a name="ln2524">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2525">/// @param[in]  key  Key to add.</a>
<a name="ln2526">/// @param[in]  key_len  Key length.</a>
<a name="ln2527">/// @param[in]  val  String to add. NULL adds empty string.</a>
<a name="ln2528">/// @param[in]  len  Use this many bytes from `val`, or -1 for whole string.</a>
<a name="ln2529">///</a>
<a name="ln2530">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2531">int tv_dict_add_str_len(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2532">                        const char *const val, int len)</a>
<a name="ln2533">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2534">{</a>
<a name="ln2535">  char *s = NULL;</a>
<a name="ln2536">  if (val != NULL) {</a>
<a name="ln2537">    s = (len &lt; 0) ? xstrdup(val) : xstrndup(val, (size_t)len);</a>
<a name="ln2538">  }</a>
<a name="ln2539">  return tv_dict_add_allocated_str(d, key, key_len, s);</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542">/// Add a string entry to dictionary</a>
<a name="ln2543">///</a>
<a name="ln2544">/// Unlike tv_dict_add_str() saves val to the new dictionary item in place of</a>
<a name="ln2545">/// creating a new copy.</a>
<a name="ln2546">///</a>
<a name="ln2547">/// @warning String will be freed even in case addition fails.</a>
<a name="ln2548">///</a>
<a name="ln2549">/// @param[out]  d  Dictionary to add entry to.</a>
<a name="ln2550">/// @param[in]  key  Key to add.</a>
<a name="ln2551">/// @param[in]  key_len  Key length.</a>
<a name="ln2552">/// @param[in]  val  String to add.</a>
<a name="ln2553">///</a>
<a name="ln2554">/// @return OK in case of success, FAIL when key already exists.</a>
<a name="ln2555">int tv_dict_add_allocated_str(dict_T *const d, const char *const key, const size_t key_len,</a>
<a name="ln2556">                              char *const val)</a>
<a name="ln2557">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln2558">{</a>
<a name="ln2559">  dictitem_T *const item = tv_dict_item_alloc_len(key, key_len);</a>
<a name="ln2560"> </a>
<a name="ln2561">  item-&gt;di_tv.v_type = VAR_STRING;</a>
<a name="ln2562">  item-&gt;di_tv.vval.v_string = val;</a>
<a name="ln2563">  if (tv_dict_add(d, item) == FAIL) {</a>
<a name="ln2564">    tv_dict_item_free(item);</a>
<a name="ln2565">    return FAIL;</a>
<a name="ln2566">  }</a>
<a name="ln2567">  return OK;</a>
<a name="ln2568">}</a>
<a name="ln2569"> </a>
<a name="ln2570">//{{{2 Operations on the whole dict</a>
<a name="ln2571"> </a>
<a name="ln2572">/// Clear all the keys of a Dictionary. &quot;d&quot; remains a valid empty Dictionary.</a>
<a name="ln2573">///</a>
<a name="ln2574">/// @param  d  The Dictionary to clear</a>
<a name="ln2575">void tv_dict_clear(dict_T *const d)</a>
<a name="ln2576">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2577">{</a>
<a name="ln2578">  hash_lock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2579">  assert(d-&gt;dv_hashtab.ht_locked &gt; 0);</a>
<a name="ln2580"> </a>
<a name="ln2581">  HASHTAB_ITER(&amp;d-&gt;dv_hashtab, hi, {</a>
<a name="ln2582">    tv_dict_item_free(TV_DICT_HI2DI(hi));</a>
<a name="ln2583">    hash_remove(&amp;d-&gt;dv_hashtab, hi);</a>
<a name="ln2584">  });</a>
<a name="ln2585"> </a>
<a name="ln2586">  hash_unlock(&amp;d-&gt;dv_hashtab);</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">/// Extend dictionary with items from another dictionary</a>
<a name="ln2590">///</a>
<a name="ln2591">/// @param  d1  Dictionary to extend.</a>
<a name="ln2592">/// @param[in]  d2  Dictionary to extend with.</a>
<a name="ln2593">/// @param[in]  action  &quot;error&quot;, &quot;force&quot;, &quot;move&quot;, &quot;keep&quot;:</a>
<a name="ln2594">///                     e*, including &quot;error&quot;: duplicate key gives an error.</a>
<a name="ln2595">///                     f*, including &quot;force&quot;: duplicate d2 keys override d1.</a>
<a name="ln2596">///                     m*, including &quot;move&quot;: move items instead of copying.</a>
<a name="ln2597">///                     other, including &quot;keep&quot;: duplicate d2 keys ignored.</a>
<a name="ln2598">void tv_dict_extend(dict_T *const d1, dict_T *const d2, const char *const action)</a>
<a name="ln2599">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2600">{</a>
<a name="ln2601">  const bool watched = tv_dict_is_watched(d1);</a>
<a name="ln2602">  const char *const arg_errmsg = _(&quot;extend() argument&quot;);</a>
<a name="ln2603">  const size_t arg_errmsg_len = strlen(arg_errmsg);</a>
<a name="ln2604"> </a>
<a name="ln2605">  if (*action == 'm') {</a>
<a name="ln2606">    hash_lock(&amp;d2-&gt;dv_hashtab);  // don't rehash on hash_remove()</a>
<a name="ln2607">  }</a>
<a name="ln2608"> </a>
<a name="ln2609">  HASHTAB_ITER(&amp;d2-&gt;dv_hashtab, hi2, {</a>
<a name="ln2610">    dictitem_T *const di2 = TV_DICT_HI2DI(hi2);</a>
<a name="ln2611">    dictitem_T *const di1 = tv_dict_find(d1, di2-&gt;di_key, -1);</a>
<a name="ln2612">    // Check the key to be valid when adding to any scope.</a>
<a name="ln2613">    if (d1-&gt;dv_scope != VAR_NO_SCOPE &amp;&amp; !valid_varname(di2-&gt;di_key)) {</a>
<a name="ln2614">      break;</a>
<a name="ln2615">    }</a>
<a name="ln2616">    if (di1 == NULL) {</a>
<a name="ln2617">      if (*action == 'm') {</a>
<a name="ln2618">        // Cheap way to move a dict item from &quot;d2&quot; to &quot;d1&quot;.</a>
<a name="ln2619">        // If dict_add() fails then &quot;d2&quot; won't be empty.</a>
<a name="ln2620">        dictitem_T *const new_di = di2;</a>
<a name="ln2621">        if (tv_dict_add(d1, new_di) == OK) {</a>
<a name="ln2622">          hash_remove(&amp;d2-&gt;dv_hashtab, hi2);</a>
<a name="ln2623">          tv_dict_watcher_notify(d1, new_di-&gt;di_key, &amp;new_di-&gt;di_tv, NULL);</a>
<a name="ln2624">        }</a>
<a name="ln2625">      } else {</a>
<a name="ln2626">        dictitem_T *const new_di = tv_dict_item_copy(di2);</a>
<a name="ln2627">        if (tv_dict_add(d1, new_di) == FAIL) {</a>
<a name="ln2628">          tv_dict_item_free(new_di);</a>
<a name="ln2629">        } else if (watched) {</a>
<a name="ln2630">          tv_dict_watcher_notify(d1, new_di-&gt;di_key, &amp;new_di-&gt;di_tv, NULL);</a>
<a name="ln2631">        }</a>
<a name="ln2632">      }</a>
<a name="ln2633">    } else if (*action == 'e') {</a>
<a name="ln2634">      semsg(_(&quot;E737: Key already exists: %s&quot;), di2-&gt;di_key);</a>
<a name="ln2635">      break;</a>
<a name="ln2636">    } else if (*action == 'f' &amp;&amp; di2 != di1) {</a>
<a name="ln2637">      typval_T oldtv;</a>
<a name="ln2638"> </a>
<a name="ln2639">      if (value_check_lock(di1-&gt;di_tv.v_lock, arg_errmsg, arg_errmsg_len)</a>
<a name="ln2640">          || var_check_ro(di1-&gt;di_flags, arg_errmsg, arg_errmsg_len)) {</a>
<a name="ln2641">        break;</a>
<a name="ln2642">      }</a>
<a name="ln2643">      // Disallow replacing a builtin function.</a>
<a name="ln2644">      if (tv_dict_wrong_func_name(d1, &amp;di2-&gt;di_tv, di2-&gt;di_key)) {</a>
<a name="ln2645">        break;</a>
<a name="ln2646">      }</a>
<a name="ln2647"> </a>
<a name="ln2648">      if (watched) {</a>
<a name="ln2649">        tv_copy(&amp;di1-&gt;di_tv, &amp;oldtv);</a>
<a name="ln2650">      }</a>
<a name="ln2651"> </a>
<a name="ln2652">      tv_clear(&amp;di1-&gt;di_tv);</a>
<a name="ln2653">      tv_copy(&amp;di2-&gt;di_tv, &amp;di1-&gt;di_tv);</a>
<a name="ln2654"> </a>
<a name="ln2655">      if (watched) {</a>
<a name="ln2656">        tv_dict_watcher_notify(d1, di1-&gt;di_key, &amp;di1-&gt;di_tv, &amp;oldtv);</a>
<a name="ln2657">        tv_clear(&amp;oldtv);</a>
<a name="ln2658">      }</a>
<a name="ln2659">    }</a>
<a name="ln2660">  });</a>
<a name="ln2661"> </a>
<a name="ln2662">  if (*action == 'm') {</a>
<a name="ln2663">    hash_unlock(&amp;d2-&gt;dv_hashtab);</a>
<a name="ln2664">  }</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667">/// Compare two dictionaries</a>
<a name="ln2668">///</a>
<a name="ln2669">/// @param[in]  d1  First dictionary.</a>
<a name="ln2670">/// @param[in]  d2  Second dictionary.</a>
<a name="ln2671">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln2672">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln2673">bool tv_dict_equal(dict_T *const d1, dict_T *const d2, const bool ic, const bool recursive)</a>
<a name="ln2674">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2675">{</a>
<a name="ln2676">  if (d1 == d2) {</a>
<a name="ln2677">    return true;</a>
<a name="ln2678">  }</a>
<a name="ln2679">  if (tv_dict_len(d1) != tv_dict_len(d2)) {</a>
<a name="ln2680">    return false;</a>
<a name="ln2681">  }</a>
<a name="ln2682">  if (tv_dict_len(d1) == 0) {</a>
<a name="ln2683">    // empty and NULL dicts are considered equal</a>
<a name="ln2684">    return true;</a>
<a name="ln2685">  }</a>
<a name="ln2686">  if (d1 == NULL || d2 == NULL) {</a>
<a name="ln2687">    return false;</a>
<a name="ln2688">  }</a>
<a name="ln2689"> </a>
<a name="ln2690">  TV_DICT_ITER(d1, di1, {</a>
<a name="ln2691">    dictitem_T *const di2 = tv_dict_find(d2, di1-&gt;di_key, -1);</a>
<a name="ln2692">    if (di2 == NULL) {</a>
<a name="ln2693">      return false;</a>
<a name="ln2694">    }</a>
<a name="ln2695">    if (!tv_equal(&amp;di1-&gt;di_tv, &amp;di2-&gt;di_tv, ic, recursive)) {</a>
<a name="ln2696">      return false;</a>
<a name="ln2697">    }</a>
<a name="ln2698">  });</a>
<a name="ln2699">  return true;</a>
<a name="ln2700">}</a>
<a name="ln2701"> </a>
<a name="ln2702">/// Make a copy of dictionary</a>
<a name="ln2703">///</a>
<a name="ln2704">/// @param[in]  conv  If non-NULL, then all internal strings will be converted.</a>
<a name="ln2705">/// @param[in]  orig  Original dictionary to copy.</a>
<a name="ln2706">/// @param[in]  deep  If false, then shallow copy will be done.</a>
<a name="ln2707">/// @param[in]  copyID  See var_item_copy().</a>
<a name="ln2708">///</a>
<a name="ln2709">/// @return Copied dictionary. May be NULL in case original dictionary is NULL</a>
<a name="ln2710">///         or some failure happens. The refcount of the new dictionary is set</a>
<a name="ln2711">///         to 1.</a>
<a name="ln2712">dict_T *tv_dict_copy(const vimconv_T *const conv, dict_T *const orig, const bool deep,</a>
<a name="ln2713">                     const int copyID)</a>
<a name="ln2714">{</a>
<a name="ln2715">  if (orig == NULL) {</a>
<a name="ln2716">    return NULL;</a>
<a name="ln2717">  }</a>
<a name="ln2718"> </a>
<a name="ln2719">  dict_T *copy = tv_dict_alloc();</a>
<a name="ln2720">  if (copyID != 0) {</a>
<a name="ln2721">    orig-&gt;dv_copyID = copyID;</a>
<a name="ln2722">    orig-&gt;dv_copydict = copy;</a>
<a name="ln2723">  }</a>
<a name="ln2724">  TV_DICT_ITER(orig, di, {</a>
<a name="ln2725">    if (got_int) {</a>
<a name="ln2726">      break;</a>
<a name="ln2727">    }</a>
<a name="ln2728">    dictitem_T *new_di;</a>
<a name="ln2729">    if (conv == NULL || conv-&gt;vc_type == CONV_NONE) {</a>
<a name="ln2730">      new_di = tv_dict_item_alloc(di-&gt;di_key);</a>
<a name="ln2731">    } else {</a>
<a name="ln2732">      size_t len = strlen(di-&gt;di_key);</a>
<a name="ln2733">      char *const key = string_convert(conv, di-&gt;di_key, &amp;len);</a>
<a name="ln2734">      if (key == NULL) {</a>
<a name="ln2735">        new_di = tv_dict_item_alloc_len(di-&gt;di_key, len);</a>
<a name="ln2736">      } else {</a>
<a name="ln2737">        new_di = tv_dict_item_alloc_len(key, len);</a>
<a name="ln2738">        xfree(key);</a>
<a name="ln2739">      }</a>
<a name="ln2740">    }</a>
<a name="ln2741">    if (deep) {</a>
<a name="ln2742">      if (var_item_copy(conv, &amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv, deep,</a>
<a name="ln2743">                        copyID) == FAIL) {</a>
<a name="ln2744">        xfree(new_di);</a>
<a name="ln2745">        break;</a>
<a name="ln2746">      }</a>
<a name="ln2747">    } else {</a>
<a name="ln2748">      tv_copy(&amp;di-&gt;di_tv, &amp;new_di-&gt;di_tv);</a>
<a name="ln2749">    }</a>
<a name="ln2750">    if (tv_dict_add(copy, new_di) == FAIL) {</a>
<a name="ln2751">      tv_dict_item_free(new_di);</a>
<a name="ln2752">      break;</a>
<a name="ln2753">    }</a>
<a name="ln2754">  });</a>
<a name="ln2755"> </a>
<a name="ln2756">  copy-&gt;dv_refcount++;</a>
<a name="ln2757">  if (got_int) {</a>
<a name="ln2758">    tv_dict_unref(copy);</a>
<a name="ln2759">    copy = NULL;</a>
<a name="ln2760">  }</a>
<a name="ln2761"> </a>
<a name="ln2762">  return copy;</a>
<a name="ln2763">}</a>
<a name="ln2764"> </a>
<a name="ln2765">/// Set all existing keys in &quot;dict&quot; as read-only.</a>
<a name="ln2766">///</a>
<a name="ln2767">/// This does not protect against adding new keys to the Dictionary.</a>
<a name="ln2768">///</a>
<a name="ln2769">/// @param  dict  The dict whose keys should be frozen.</a>
<a name="ln2770">void tv_dict_set_keys_readonly(dict_T *const dict)</a>
<a name="ln2771">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2772">{</a>
<a name="ln2773">  TV_DICT_ITER(dict, di, {</a>
<a name="ln2774">    di-&gt;di_flags |= DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln2775">  });</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">//{{{1 Blobs</a>
<a name="ln2779">//{{{2 Alloc/free</a>
<a name="ln2780"> </a>
<a name="ln2781">/// Allocate an empty blob.</a>
<a name="ln2782">///</a>
<a name="ln2783">/// Caller should take care of the reference count.</a>
<a name="ln2784">///</a>
<a name="ln2785">/// @return [allocated] new blob.</a>
<a name="ln2786">blob_T *tv_blob_alloc(void)</a>
<a name="ln2787">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln2788">{</a>
<a name="ln2789">  blob_T *const blob = xcalloc(1, sizeof(blob_T));</a>
<a name="ln2790">  ga_init(&amp;blob-&gt;bv_ga, 1, 100);</a>
<a name="ln2791">  return blob;</a>
<a name="ln2792">}</a>
<a name="ln2793"> </a>
<a name="ln2794">/// Free a blob. Ignores the reference count.</a>
<a name="ln2795">///</a>
<a name="ln2796">/// @param[in,out]  b  Blob to free.</a>
<a name="ln2797">void tv_blob_free(blob_T *const b)</a>
<a name="ln2798">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2799">{</a>
<a name="ln2800">  ga_clear(&amp;b-&gt;bv_ga);</a>
<a name="ln2801">  xfree(b);</a>
<a name="ln2802">}</a>
<a name="ln2803"> </a>
<a name="ln2804">/// Unreference a blob.</a>
<a name="ln2805">///</a>
<a name="ln2806">/// Decrements the reference count and frees blob when it becomes zero.</a>
<a name="ln2807">///</a>
<a name="ln2808">/// @param[in,out]  b  Blob to operate on.</a>
<a name="ln2809">void tv_blob_unref(blob_T *const b)</a>
<a name="ln2810">{</a>
<a name="ln2811">  if (b != NULL &amp;&amp; --b-&gt;bv_refcount &lt;= 0) {</a>
<a name="ln2812">    tv_blob_free(b);</a>
<a name="ln2813">  }</a>
<a name="ln2814">}</a>
<a name="ln2815"> </a>
<a name="ln2816">//{{{2 Operations on the whole blob</a>
<a name="ln2817"> </a>
<a name="ln2818">/// Check whether two blobs are equal.</a>
<a name="ln2819">///</a>
<a name="ln2820">/// @param[in]  b1  First blob.</a>
<a name="ln2821">/// @param[in]  b2  Second blob.</a>
<a name="ln2822">///</a>
<a name="ln2823">/// @return true if blobs are equal, false otherwise.</a>
<a name="ln2824">bool tv_blob_equal(const blob_T *const b1, const blob_T *const b2)</a>
<a name="ln2825">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2826">{</a>
<a name="ln2827">  const int len1 = tv_blob_len(b1);</a>
<a name="ln2828">  const int len2 = tv_blob_len(b2);</a>
<a name="ln2829"> </a>
<a name="ln2830">  // empty and NULL are considered the same</a>
<a name="ln2831">  if (len1 == 0 &amp;&amp; len2 == 0) {</a>
<a name="ln2832">    return true;</a>
<a name="ln2833">  }</a>
<a name="ln2834">  if (b1 == b2) {</a>
<a name="ln2835">    return true;</a>
<a name="ln2836">  }</a>
<a name="ln2837">  if (len1 != len2) {</a>
<a name="ln2838">    return false;</a>
<a name="ln2839">  }</a>
<a name="ln2840"> </a>
<a name="ln2841">  for (int i = 0; i &lt; b1-&gt;bv_ga.ga_len; i++) {</a>
<a name="ln2842">    if (tv_blob_get(b1, i) != tv_blob_get(b2, i)) {</a>
<a name="ln2843">      return false;</a>
<a name="ln2844">    }</a>
<a name="ln2845">  }</a>
<a name="ln2846">  return true;</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849">/// Returns a slice of &quot;blob&quot; from index &quot;n1&quot; to &quot;n2&quot; in &quot;rettv&quot;.  The length of</a>
<a name="ln2850">/// the blob is &quot;len&quot;.  Returns an empty blob if the indexes are out of range.</a>
<a name="ln2851">static int tv_blob_slice(const blob_T *blob, int len, varnumber_T n1, varnumber_T n2,</a>
<a name="ln2852">                         bool exclusive, typval_T *rettv)</a>
<a name="ln2853">{</a>
<a name="ln2854">  // The resulting variable is a sub-blob.  If the indexes</a>
<a name="ln2855">  // are out of range the result is empty.</a>
<a name="ln2856">  if (n1 &lt; 0) {</a>
<a name="ln2857">    n1 = len + n1;</a>
<a name="ln2858">    if (n1 &lt; 0) {</a>
<a name="ln2859">      n1 = 0;</a>
<a name="ln2860">    }</a>
<a name="ln2861">  }</a>
<a name="ln2862">  if (n2 &lt; 0) {</a>
<a name="ln2863">    n2 = len + n2;</a>
<a name="ln2864">  } else if (n2 &gt;= len) {</a>
<a name="ln2865">    n2 = len - (exclusive ? 0 : 1);</a>
<a name="ln2866">  }</a>
<a name="ln2867">  if (exclusive) {</a>
<a name="ln2868">    n2--;</a>
<a name="ln2869">  }</a>
<a name="ln2870">  if (n1 &gt;= len || n2 &lt; 0 || n1 &gt; n2) {</a>
<a name="ln2871">    tv_clear(rettv);</a>
<a name="ln2872">    rettv-&gt;v_type = VAR_BLOB;</a>
<a name="ln2873">    rettv-&gt;vval.v_blob = NULL;</a>
<a name="ln2874">  } else {</a>
<a name="ln2875">    blob_T *const new_blob = tv_blob_alloc();</a>
<a name="ln2876">    ga_grow(&amp;new_blob-&gt;bv_ga, (int)(n2 - n1 + 1));</a>
<a name="ln2877">    new_blob-&gt;bv_ga.ga_len = (int)(n2 - n1 + 1);</a>
<a name="ln2878">    for (int i = (int)n1; i &lt;= (int)n2; i++) {</a>
<a name="ln2879">      tv_blob_set(new_blob, i - (int)n1, tv_blob_get(rettv-&gt;vval.v_blob, i));</a>
<a name="ln2880">    }</a>
<a name="ln2881">    tv_clear(rettv);</a>
<a name="ln2882">    tv_blob_set_ret(rettv, new_blob);</a>
<a name="ln2883">  }</a>
<a name="ln2884"> </a>
<a name="ln2885">  return OK;</a>
<a name="ln2886">}</a>
<a name="ln2887"> </a>
<a name="ln2888">/// Return the byte value in &quot;blob&quot; at index &quot;idx&quot; in &quot;rettv&quot;.  If the index is</a>
<a name="ln2889">/// too big or negative that is an error.  The length of the blob is &quot;len&quot;.</a>
<a name="ln2890">static int tv_blob_index(const blob_T *blob, int len, varnumber_T idx, typval_T *rettv)</a>
<a name="ln2891">{</a>
<a name="ln2892">  // The resulting variable is a byte value.</a>
<a name="ln2893">  // If the index is too big or negative that is an error.</a>
<a name="ln2894">  if (idx &lt; 0) {</a>
<a name="ln2895">    idx = len + idx;</a>
<a name="ln2896">  }</a>
<a name="ln2897">  if (idx &lt; len &amp;&amp; idx &gt;= 0) {</a>
<a name="ln2898">    const int v = (int)tv_blob_get(rettv-&gt;vval.v_blob, (int)idx);</a>
<a name="ln2899">    tv_clear(rettv);</a>
<a name="ln2900">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln2901">    rettv-&gt;vval.v_number = v;</a>
<a name="ln2902">  } else {</a>
<a name="ln2903">    semsg(_(e_blobidx), idx);</a>
<a name="ln2904">    return FAIL;</a>
<a name="ln2905">  }</a>
<a name="ln2906"> </a>
<a name="ln2907">  return OK;</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910">int tv_blob_slice_or_index(const blob_T *blob, int is_range, varnumber_T n1, varnumber_T n2,</a>
<a name="ln2911">                           bool exclusive, typval_T *rettv)</a>
<a name="ln2912">{</a>
<a name="ln2913">  int len = tv_blob_len(rettv-&gt;vval.v_blob);</a>
<a name="ln2914"> </a>
<a name="ln2915">  if (is_range) {</a>
<a name="ln2916">    return tv_blob_slice(blob, len, n1, n2, exclusive, rettv);</a>
<a name="ln2917">  } else {</a>
<a name="ln2918">    return tv_blob_index(blob, len, n1, rettv);</a>
<a name="ln2919">  }</a>
<a name="ln2920">}</a>
<a name="ln2921"> </a>
<a name="ln2922">/// Check if &quot;n1&quot; is a valid index for a blob with length &quot;bloblen&quot;.</a>
<a name="ln2923">int tv_blob_check_index(int bloblen, varnumber_T n1, bool quiet)</a>
<a name="ln2924">{</a>
<a name="ln2925">  if (n1 &lt; 0 || n1 &gt; bloblen) {</a>
<a name="ln2926">    if (!quiet) {</a>
<a name="ln2927">      semsg(_(e_blobidx), n1);</a>
<a name="ln2928">    }</a>
<a name="ln2929">    return FAIL;</a>
<a name="ln2930">  }</a>
<a name="ln2931">  return OK;</a>
<a name="ln2932">}</a>
<a name="ln2933"> </a>
<a name="ln2934">/// Check if &quot;n1&quot;-&quot;n2&quot; is a valid range for a blob with length &quot;bloblen&quot;.</a>
<a name="ln2935">int tv_blob_check_range(int bloblen, varnumber_T n1, varnumber_T n2, bool quiet)</a>
<a name="ln2936">{</a>
<a name="ln2937">  if (n2 &lt; 0 || n2 &gt;= bloblen || n2 &lt; n1) {</a>
<a name="ln2938">    if (!quiet) {</a>
<a name="ln2939">      semsg(_(e_blobidx), n2);</a>
<a name="ln2940">    }</a>
<a name="ln2941">    return FAIL;</a>
<a name="ln2942">  }</a>
<a name="ln2943">  return OK;</a>
<a name="ln2944">}</a>
<a name="ln2945"> </a>
<a name="ln2946">/// Set bytes &quot;n1&quot; to &quot;n2&quot; (inclusive) in &quot;dest&quot; to the value of &quot;src&quot;.</a>
<a name="ln2947">/// Caller must make sure &quot;src&quot; is a blob.</a>
<a name="ln2948">/// Returns FAIL if the number of bytes does not match.</a>
<a name="ln2949">int tv_blob_set_range(blob_T *dest, varnumber_T n1, varnumber_T n2, typval_T *src)</a>
<a name="ln2950">{</a>
<a name="ln2951">  if (n2 - n1 + 1 != tv_blob_len(src-&gt;vval.v_blob)) {</a>
<a name="ln2952">    emsg(_(&quot;E972: Blob value does not have the right number of bytes&quot;));</a>
<a name="ln2953">    return FAIL;</a>
<a name="ln2954">  }</a>
<a name="ln2955"> </a>
<a name="ln2956">  for (int il = (int)n1, ir = 0; il &lt;= (int)n2; il++) {</a>
<a name="ln2957">    tv_blob_set(dest, il, tv_blob_get(src-&gt;vval.v_blob, ir++));</a>
<a name="ln2958">  }</a>
<a name="ln2959">  return OK;</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962">/// Store one byte &quot;byte&quot; in blob &quot;blob&quot; at &quot;idx&quot;.</a>
<a name="ln2963">/// Append one byte if needed.</a>
<a name="ln2964">void tv_blob_set_append(blob_T *blob, int idx, uint8_t byte)</a>
<a name="ln2965">{</a>
<a name="ln2966">  garray_T *gap = &amp;blob-&gt;bv_ga;</a>
<a name="ln2967"> </a>
<a name="ln2968">  // Allow for appending a byte.  Setting a byte beyond</a>
<a name="ln2969">  // the end is an error otherwise.</a>
<a name="ln2970">  if (idx &lt;= gap-&gt;ga_len) {</a>
<a name="ln2971">    if (idx == gap-&gt;ga_len) {</a>
<a name="ln2972">      ga_grow(gap, 1);</a>
<a name="ln2973">      gap-&gt;ga_len++;</a>
<a name="ln2974">    }</a>
<a name="ln2975">    tv_blob_set(blob, idx, byte);</a>
<a name="ln2976">  }</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">/// &quot;remove({blob})&quot; function</a>
<a name="ln2980">void tv_blob_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln2981">{</a>
<a name="ln2982">  blob_T *const b = argvars[0].vval.v_blob;</a>
<a name="ln2983"> </a>
<a name="ln2984">  if (b != NULL &amp;&amp; value_check_lock(b-&gt;bv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln2985">    return;</a>
<a name="ln2986">  }</a>
<a name="ln2987"> </a>
<a name="ln2988">  bool error = false;</a>
<a name="ln2989">  int64_t idx = tv_get_number_chk(&amp;argvars[1], &amp;error);</a>
<a name="ln2990"> </a>
<a name="ln2991">  if (!error) {</a>
<a name="ln2992">    const int len = tv_blob_len(b);</a>
<a name="ln2993"> </a>
<a name="ln2994">    if (idx &lt; 0) {</a>
<a name="ln2995">      // count from the end</a>
<a name="ln2996">      idx = len + idx;</a>
<a name="ln2997">    }</a>
<a name="ln2998">    if (idx &lt; 0 || idx &gt;= len) {</a>
<a name="ln2999">      semsg(_(e_blobidx), idx);</a>
<a name="ln3000">      return;</a>
<a name="ln3001">    }</a>
<a name="ln3002">    if (argvars[2].v_type == VAR_UNKNOWN) {</a>
<a name="ln3003">      // Remove one item, return its value.</a>
<a name="ln3004">      uint8_t *const p = (uint8_t *)b-&gt;bv_ga.ga_data;</a>
<a name="ln3005">      rettv-&gt;vval.v_number = (varnumber_T)(*(p + idx));</a>
<a name="ln3006">      memmove(p + idx, p + idx + 1, (size_t)(len - idx - 1));</a>
<a name="ln3007">      b-&gt;bv_ga.ga_len--;</a>
<a name="ln3008">    } else {</a>
<a name="ln3009">      // Remove range of items, return blob with values.</a>
<a name="ln3010">      int64_t end = tv_get_number_chk(&amp;argvars[2], &amp;error);</a>
<a name="ln3011">      if (error) {</a>
<a name="ln3012">        return;</a>
<a name="ln3013">      }</a>
<a name="ln3014">      if (end &lt; 0) {</a>
<a name="ln3015">        // count from the end</a>
<a name="ln3016">        end = len + end;</a>
<a name="ln3017">      }</a>
<a name="ln3018">      if (end &gt;= len || idx &gt; end) {</a>
<a name="ln3019">        semsg(_(e_blobidx), end);</a>
<a name="ln3020">        return;</a>
<a name="ln3021">      }</a>
<a name="ln3022">      blob_T *const blob = tv_blob_alloc();</a>
<a name="ln3023">      blob-&gt;bv_ga.ga_len = (int)(end - idx + 1);</a>
<a name="ln3024">      ga_grow(&amp;blob-&gt;bv_ga, (int)(end - idx + 1));</a>
<a name="ln3025"> </a>
<a name="ln3026">      uint8_t *const p = (uint8_t *)b-&gt;bv_ga.ga_data;</a>
<a name="ln3027">      memmove(blob-&gt;bv_ga.ga_data, p + idx, (size_t)(end - idx + 1));</a>
<a name="ln3028">      tv_blob_set_ret(rettv, blob);</a>
<a name="ln3029"> </a>
<a name="ln3030">      if (len - end - 1 &gt; 0) {</a>
<a name="ln3031">        memmove(p + idx, p + end + 1, (size_t)(len - end - 1));</a>
<a name="ln3032">      }</a>
<a name="ln3033">      b-&gt;bv_ga.ga_len -= (int)(end - idx + 1);</a>
<a name="ln3034">    }</a>
<a name="ln3035">  }</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038">/// blob2list() function</a>
<a name="ln3039">void f_blob2list(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3040">{</a>
<a name="ln3041">  tv_list_alloc_ret(rettv, kListLenMayKnow);</a>
<a name="ln3042"> </a>
<a name="ln3043">  if (tv_check_for_blob_arg(argvars, 0) == FAIL) {</a>
<a name="ln3044">    return;</a>
<a name="ln3045">  }</a>
<a name="ln3046"> </a>
<a name="ln3047">  blob_T *const blob = argvars-&gt;vval.v_blob;</a>
<a name="ln3048">  list_T *const l = rettv-&gt;vval.v_list;</a>
<a name="ln3049">  for (int i = 0; i &lt; tv_blob_len(blob); i++) {</a>
<a name="ln3050">    tv_list_append_number(l, tv_blob_get(blob, i));</a>
<a name="ln3051">  }</a>
<a name="ln3052">}</a>
<a name="ln3053"> </a>
<a name="ln3054">/// list2blob() function</a>
<a name="ln3055">void f_list2blob(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3056">{</a>
<a name="ln3057">  tv_blob_alloc_ret(rettv);</a>
<a name="ln3058">  blob_T *const blob = rettv-&gt;vval.v_blob;</a>
<a name="ln3059"> </a>
<a name="ln3060">  if (tv_check_for_list_arg(argvars, 0) == FAIL) {</a>
<a name="ln3061">    return;</a>
<a name="ln3062">  }</a>
<a name="ln3063"> </a>
<a name="ln3064">  list_T *const l = argvars-&gt;vval.v_list;</a>
<a name="ln3065">  if (l == NULL) {</a>
<a name="ln3066">    return;</a>
<a name="ln3067">  }</a>
<a name="ln3068"> </a>
<a name="ln3069">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln3070">    bool error = false;</a>
<a name="ln3071">    varnumber_T n = tv_get_number_chk(TV_LIST_ITEM_TV(li), &amp;error);</a>
<a name="ln3072">    if (error || n &lt; 0 || n &gt; 255) {</a>
<a name="ln3073">      if (!error) {</a>
<a name="ln3074">        semsg(_(e_invalid_value_for_blob_nr), (int)n);</a>
<a name="ln3075">      }</a>
<a name="ln3076">      ga_clear(&amp;blob-&gt;bv_ga);</a>
<a name="ln3077">      return;</a>
<a name="ln3078">    }</a>
<a name="ln3079">    ga_append(&amp;blob-&gt;bv_ga, (uint8_t)n);</a>
<a name="ln3080">  });</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">//{{{1 Generic typval operations</a>
<a name="ln3084">//{{{2 Init/alloc/clear</a>
<a name="ln3085">//{{{3 Alloc</a>
<a name="ln3086"> </a>
<a name="ln3087">/// Allocate an empty list for a return value</a>
<a name="ln3088">///</a>
<a name="ln3089">/// Also sets reference count.</a>
<a name="ln3090">///</a>
<a name="ln3091">/// @param[out]  ret_tv  Structure where list is saved.</a>
<a name="ln3092">/// @param[in]  len  Expected number of items to be populated before list</a>
<a name="ln3093">///                  becomes accessible from Vimscript. It is still valid to</a>
<a name="ln3094">///                  underpopulate a list, value only controls how many elements</a>
<a name="ln3095">///                  will be allocated in advance. @see ListLenSpecials.</a>
<a name="ln3096">///</a>
<a name="ln3097">/// @return [allocated] pointer to the created list.</a>
<a name="ln3098">list_T *tv_list_alloc_ret(typval_T *const ret_tv, const ptrdiff_t len)</a>
<a name="ln3099">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3100">{</a>
<a name="ln3101">  list_T *const l = tv_list_alloc(len);</a>
<a name="ln3102">  tv_list_set_ret(ret_tv, l);</a>
<a name="ln3103">  ret_tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3104">  return l;</a>
<a name="ln3105">}</a>
<a name="ln3106"> </a>
<a name="ln3107">dict_T *tv_dict_alloc_lock(VarLockStatus lock)</a>
<a name="ln3108">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3109">{</a>
<a name="ln3110">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln3111">  d-&gt;dv_lock = lock;</a>
<a name="ln3112">  return d;</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">/// Allocate an empty dictionary for a return value</a>
<a name="ln3116">///</a>
<a name="ln3117">/// Also sets reference count.</a>
<a name="ln3118">///</a>
<a name="ln3119">/// @param[out]  ret_tv  Structure where dictionary is saved.</a>
<a name="ln3120">void tv_dict_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln3121">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3122">{</a>
<a name="ln3123">  dict_T *const d = tv_dict_alloc_lock(VAR_UNLOCKED);</a>
<a name="ln3124">  tv_dict_set_ret(ret_tv, d);</a>
<a name="ln3125">}</a>
<a name="ln3126"> </a>
<a name="ln3127">/// Turn a dictionary into a list</a>
<a name="ln3128">///</a>
<a name="ln3129">/// @param[in] tv      Dictionary to convert. Is checked for actually being</a>
<a name="ln3130">///                    a dictionary, will give an error if not.</a>
<a name="ln3131">/// @param[out] rettv  Location where result will be saved.</a>
<a name="ln3132">/// @param[in] what    What to save in rettv.</a>
<a name="ln3133">static void tv_dict_list(typval_T *const tv, typval_T *const rettv, const DictListType what)</a>
<a name="ln3134">{</a>
<a name="ln3135">  if (tv-&gt;v_type != VAR_DICT) {</a>
<a name="ln3136">    emsg(_(e_dictreq));</a>
<a name="ln3137">    return;</a>
<a name="ln3138">  }</a>
<a name="ln3139"> </a>
<a name="ln3140">  tv_list_alloc_ret(rettv, tv_dict_len(tv-&gt;vval.v_dict));</a>
<a name="ln3141">  if (tv-&gt;vval.v_dict == NULL) {</a>
<a name="ln3142">    // NULL dict behaves like an empty dict</a>
<a name="ln3143">    return;</a>
<a name="ln3144">  }</a>
<a name="ln3145"> </a>
<a name="ln3146">  TV_DICT_ITER(tv-&gt;vval.v_dict, di, {</a>
<a name="ln3147">    typval_T tv_item = { .v_lock = VAR_UNLOCKED };</a>
<a name="ln3148"> </a>
<a name="ln3149">    switch (what) {</a>
<a name="ln3150">      case kDictListKeys:</a>
<a name="ln3151">        tv_item.v_type = VAR_STRING;</a>
<a name="ln3152">        tv_item.vval.v_string = xstrdup(di-&gt;di_key);</a>
<a name="ln3153">        break;</a>
<a name="ln3154">      case kDictListValues:</a>
<a name="ln3155">        tv_copy(&amp;di-&gt;di_tv, &amp;tv_item);</a>
<a name="ln3156">        break;</a>
<a name="ln3157">      case kDictListItems: {</a>
<a name="ln3158">        // items()</a>
<a name="ln3159">        list_T *const sub_l = tv_list_alloc(2);</a>
<a name="ln3160">        tv_item.v_type = VAR_LIST;</a>
<a name="ln3161">        tv_item.vval.v_list = sub_l;</a>
<a name="ln3162">        tv_list_ref(sub_l);</a>
<a name="ln3163"> </a>
<a name="ln3164">        tv_list_append_owned_tv(sub_l, (typval_T) {</a>
<a name="ln3165">          .v_type = VAR_STRING,</a>
<a name="ln3166">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln3167">          .vval.v_string = xstrdup(di-&gt;di_key),</a>
<a name="ln3168">        });</a>
<a name="ln3169"> </a>
<a name="ln3170">        tv_list_append_tv(sub_l, &amp;di-&gt;di_tv);</a>
<a name="ln3171"> </a>
<a name="ln3172">        break;</a>
<a name="ln3173">      }</a>
<a name="ln3174">    }</a>
<a name="ln3175"> </a>
<a name="ln3176">    tv_list_append_owned_tv(rettv-&gt;vval.v_list, tv_item);</a>
<a name="ln3177">  });</a>
<a name="ln3178">}</a>
<a name="ln3179"> </a>
<a name="ln3180">/// &quot;items(dict)&quot; function</a>
<a name="ln3181">void f_items(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3182">{</a>
<a name="ln3183">  tv_dict_list(argvars, rettv, 2);</a>
<a name="ln3184">}</a>
<a name="ln3185"> </a>
<a name="ln3186">/// &quot;keys()&quot; function</a>
<a name="ln3187">void f_keys(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3188">{</a>
<a name="ln3189">  tv_dict_list(argvars, rettv, 0);</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192">/// &quot;values(dict)&quot; function</a>
<a name="ln3193">void f_values(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3194">{</a>
<a name="ln3195">  tv_dict_list(argvars, rettv, 1);</a>
<a name="ln3196">}</a>
<a name="ln3197"> </a>
<a name="ln3198">/// &quot;has_key()&quot; function</a>
<a name="ln3199">void f_has_key(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3200">{</a>
<a name="ln3201">  if (tv_check_for_dict_arg(argvars, 0) == FAIL) {</a>
<a name="ln3202">    return;</a>
<a name="ln3203">  }</a>
<a name="ln3204"> </a>
<a name="ln3205">  if (argvars[0].vval.v_dict == NULL) {</a>
<a name="ln3206">    return;</a>
<a name="ln3207">  }</a>
<a name="ln3208"> </a>
<a name="ln3209">  rettv-&gt;vval.v_number = tv_dict_find(argvars[0].vval.v_dict,</a>
<a name="ln3210">                                      tv_get_string(&amp;argvars[1]),</a>
<a name="ln3211">                                      -1) != NULL;</a>
<a name="ln3212">}</a>
<a name="ln3213"> </a>
<a name="ln3214">/// &quot;remove({dict})&quot; function</a>
<a name="ln3215">void tv_dict_remove(typval_T *argvars, typval_T *rettv, const char *arg_errmsg)</a>
<a name="ln3216">{</a>
<a name="ln3217">  dict_T *d;</a>
<a name="ln3218">  if (argvars[2].v_type != VAR_UNKNOWN) {</a>
<a name="ln3219">    semsg(_(e_toomanyarg), &quot;remove()&quot;);</a>
<a name="ln3220">  } else if ((d = argvars[0].vval.v_dict) != NULL</a>
<a name="ln3221">             &amp;&amp; !value_check_lock(d-&gt;dv_lock, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln3222">    const char *key = tv_get_string_chk(&amp;argvars[1]);</a>
<a name="ln3223">    if (key != NULL) {</a>
<a name="ln3224">      dictitem_T *di = tv_dict_find(d, key, -1);</a>
<a name="ln3225">      if (di == NULL) {</a>
<a name="ln3226">        semsg(_(e_dictkey), key);</a>
<a name="ln3227">      } else if (!var_check_fixed(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)</a>
<a name="ln3228">                 &amp;&amp; !var_check_ro(di-&gt;di_flags, arg_errmsg, TV_TRANSLATE)) {</a>
<a name="ln3229">        *rettv = di-&gt;di_tv;</a>
<a name="ln3230">        di-&gt;di_tv = TV_INITIAL_VALUE;</a>
<a name="ln3231">        tv_dict_item_remove(d, di);</a>
<a name="ln3232">        if (tv_dict_is_watched(d)) {</a>
<a name="ln3233">          tv_dict_watcher_notify(d, key, NULL, rettv);</a>
<a name="ln3234">        }</a>
<a name="ln3235">      }</a>
<a name="ln3236">    }</a>
<a name="ln3237">  }</a>
<a name="ln3238">}</a>
<a name="ln3239"> </a>
<a name="ln3240">/// Allocate an empty blob for a return value.</a>
<a name="ln3241">///</a>
<a name="ln3242">/// Also sets reference count.</a>
<a name="ln3243">///</a>
<a name="ln3244">/// @param[out]  ret_tv  Structure where blob is saved.</a>
<a name="ln3245">void tv_blob_alloc_ret(typval_T *const ret_tv)</a>
<a name="ln3246">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3247">{</a>
<a name="ln3248">  blob_T *const b = tv_blob_alloc();</a>
<a name="ln3249">  tv_blob_set_ret(ret_tv, b);</a>
<a name="ln3250">}</a>
<a name="ln3251"> </a>
<a name="ln3252">/// Copy a blob typval to a different typval.</a>
<a name="ln3253">///</a>
<a name="ln3254">/// @param[in]  from  Blob object to copy from.</a>
<a name="ln3255">/// @param[out]  to  Blob object to copy to.</a>
<a name="ln3256">void tv_blob_copy(blob_T *const from, typval_T *const to)</a>
<a name="ln3257">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln3258">{</a>
<a name="ln3259">  to-&gt;v_type = VAR_BLOB;</a>
<a name="ln3260">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3261">  if (from == NULL) {</a>
<a name="ln3262">    to-&gt;vval.v_blob = NULL;</a>
<a name="ln3263">  } else {</a>
<a name="ln3264">    tv_blob_alloc_ret(to);</a>
<a name="ln3265">    int len = from-&gt;bv_ga.ga_len;</a>
<a name="ln3266"> </a>
<a name="ln3267">    if (len &gt; 0) {</a>
<a name="ln3268">      to-&gt;vval.v_blob-&gt;bv_ga.ga_data = xmemdup(from-&gt;bv_ga.ga_data, (size_t)len);</a>
<a name="ln3269">    }</a>
<a name="ln3270">    to-&gt;vval.v_blob-&gt;bv_ga.ga_len = len;</a>
<a name="ln3271">    to-&gt;vval.v_blob-&gt;bv_ga.ga_maxlen = len;</a>
<a name="ln3272">  }</a>
<a name="ln3273">}</a>
<a name="ln3274"> </a>
<a name="ln3275">//{{{3 Clear</a>
<a name="ln3276">#define TYPVAL_ENCODE_ALLOW_SPECIALS false</a>
<a name="ln3277"> </a>
<a name="ln3278">#define TYPVAL_ENCODE_CONV_NIL(tv) \</a>
<a name="ln3279">  do { \</a>
<a name="ln3280">    (tv)-&gt;vval.v_special = kSpecialVarNull; \</a>
<a name="ln3281">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3282">  } while (0)</a>
<a name="ln3283"> </a>
<a name="ln3284">#define TYPVAL_ENCODE_CONV_BOOL(tv, num) \</a>
<a name="ln3285">  do { \</a>
<a name="ln3286">    (tv)-&gt;vval.v_bool = kBoolVarFalse; \</a>
<a name="ln3287">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3288">  } while (0)</a>
<a name="ln3289"> </a>
<a name="ln3290">#define TYPVAL_ENCODE_CONV_NUMBER(tv, num) \</a>
<a name="ln3291">  do { \</a>
<a name="ln3292">    (void)(num); \</a>
<a name="ln3293">    (tv)-&gt;vval.v_number = 0; \</a>
<a name="ln3294">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3295">  } while (0)</a>
<a name="ln3296"> </a>
<a name="ln3297">#define TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER(tv, num)</a>
<a name="ln3298"> </a>
<a name="ln3299">#define TYPVAL_ENCODE_CONV_FLOAT(tv, flt) \</a>
<a name="ln3300">  do { \</a>
<a name="ln3301">    (tv)-&gt;vval.v_float = 0; \</a>
<a name="ln3302">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3303">  } while (0)</a>
<a name="ln3304"> </a>
<a name="ln3305">#define TYPVAL_ENCODE_CONV_STRING(tv, buf, len) \</a>
<a name="ln3306">  do { \</a>
<a name="ln3307">    xfree(buf); \</a>
<a name="ln3308">    (tv)-&gt;vval.v_string = NULL; \</a>
<a name="ln3309">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3310">  } while (0)</a>
<a name="ln3311"> </a>
<a name="ln3312">#define TYPVAL_ENCODE_CONV_STR_STRING(tv, buf, len)</a>
<a name="ln3313"> </a>
<a name="ln3314">#define TYPVAL_ENCODE_CONV_EXT_STRING(tv, buf, len, type)</a>
<a name="ln3315"> </a>
<a name="ln3316">#define TYPVAL_ENCODE_CONV_BLOB(tv, blob, len) \</a>
<a name="ln3317">  do { \</a>
<a name="ln3318">    tv_blob_unref((tv)-&gt;vval.v_blob); \</a>
<a name="ln3319">    (tv)-&gt;vval.v_blob = NULL; \</a>
<a name="ln3320">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3321">  } while (0)</a>
<a name="ln3322"> </a>
<a name="ln3323">static inline int _nothing_conv_func_start(typval_T *const tv, char *const fun)</a>
<a name="ln3324">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3325">{</a>
<a name="ln3326">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3327">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln3328">    partial_T *const pt_ = tv-&gt;vval.v_partial;</a>
<a name="ln3329">    if (pt_ != NULL &amp;&amp; pt_-&gt;pt_refcount &gt; 1) {</a>
<a name="ln3330">      pt_-&gt;pt_refcount--;</a>
<a name="ln3331">      tv-&gt;vval.v_partial = NULL;</a>
<a name="ln3332">      return OK;</a>
<a name="ln3333">    }</a>
<a name="ln3334">  } else {</a>
<a name="ln3335">    func_unref(fun);</a>
<a name="ln3336">    if (fun != tv_empty_string) {</a>
<a name="ln3337">      xfree(fun);</a>
<a name="ln3338">    }</a>
<a name="ln3339">    tv-&gt;vval.v_string = NULL;</a>
<a name="ln3340">  }</a>
<a name="ln3341">  return NOTDONE;</a>
<a name="ln3342">}</a>
<a name="ln3343">#define TYPVAL_ENCODE_CONV_FUNC_START(tv, fun) \</a>
<a name="ln3344">  do { \</a>
<a name="ln3345">    if (_nothing_conv_func_start(tv, fun) != NOTDONE) { \</a>
<a name="ln3346">      return OK; \</a>
<a name="ln3347">    } \</a>
<a name="ln3348">  } while (0)</a>
<a name="ln3349"> </a>
<a name="ln3350">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS(tv, len)</a>
<a name="ln3351">#define TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF(tv, len)</a>
<a name="ln3352"> </a>
<a name="ln3353">static inline void _nothing_conv_func_end(typval_T *const tv, const int copyID)</a>
<a name="ln3354">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3355">{</a>
<a name="ln3356">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln3357">    partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln3358">    if (pt == NULL) {</a>
<a name="ln3359">      return;</a>
<a name="ln3360">    }</a>
<a name="ln3361">    // Dictionary should already be freed by the time.</a>
<a name="ln3362">    // If it was not freed then it is a part of the reference cycle.</a>
<a name="ln3363">    assert(pt-&gt;pt_dict == NULL || pt-&gt;pt_dict-&gt;dv_copyID == copyID);</a>
<a name="ln3364">    pt-&gt;pt_dict = NULL;</a>
<a name="ln3365">    // As well as all arguments.</a>
<a name="ln3366">    pt-&gt;pt_argc = 0;</a>
<a name="ln3367">    assert(pt-&gt;pt_refcount &lt;= 1);</a>
<a name="ln3368">    partial_unref(pt);</a>
<a name="ln3369">    tv-&gt;vval.v_partial = NULL;</a>
<a name="ln3370">    assert(tv-&gt;v_lock == VAR_UNLOCKED);</a>
<a name="ln3371">  }</a>
<a name="ln3372">}</a>
<a name="ln3373">#define TYPVAL_ENCODE_CONV_FUNC_END(tv) _nothing_conv_func_end(tv, copyID)</a>
<a name="ln3374"> </a>
<a name="ln3375">#define TYPVAL_ENCODE_CONV_EMPTY_LIST(tv) \</a>
<a name="ln3376">  do { \</a>
<a name="ln3377">    tv_list_unref((tv)-&gt;vval.v_list); \</a>
<a name="ln3378">    (tv)-&gt;vval.v_list = NULL; \</a>
<a name="ln3379">    (tv)-&gt;v_lock = VAR_UNLOCKED; \</a>
<a name="ln3380">  } while (0)</a>
<a name="ln3381"> </a>
<a name="ln3382">static inline void _nothing_conv_empty_dict(typval_T *const tv, dict_T **const dictp)</a>
<a name="ln3383">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln3384">{</a>
<a name="ln3385">  tv_dict_unref(*dictp);</a>
<a name="ln3386">  *dictp = NULL;</a>
<a name="ln3387">  if (tv != NULL) {</a>
<a name="ln3388">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3389">  }</a>
<a name="ln3390">}</a>
<a name="ln3391">#define TYPVAL_ENCODE_CONV_EMPTY_DICT(tv, dict) \</a>
<a name="ln3392">  do { \</a>
<a name="ln3393">    assert((void *)&amp;(dict) != (void *)&amp;TYPVAL_ENCODE_NODICT_VAR); \</a>
<a name="ln3394">    _nothing_conv_empty_dict(tv, ((dict_T **)&amp;(dict))); \</a>
<a name="ln3395">  } while (0)</a>
<a name="ln3396"> </a>
<a name="ln3397">static inline int _nothing_conv_real_list_after_start(typval_T *const tv,</a>
<a name="ln3398">                                                      MPConvStackVal *const mpsv)</a>
<a name="ln3399">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3400">{</a>
<a name="ln3401">  assert(tv != NULL);</a>
<a name="ln3402">  tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3403">  if (tv-&gt;vval.v_list-&gt;lv_refcount &gt; 1) {</a>
<a name="ln3404">    tv-&gt;vval.v_list-&gt;lv_refcount--;</a>
<a name="ln3405">    tv-&gt;vval.v_list = NULL;</a>
<a name="ln3406">    mpsv-&gt;data.l.li = NULL;</a>
<a name="ln3407">    return OK;</a>
<a name="ln3408">  }</a>
<a name="ln3409">  return NOTDONE;</a>
<a name="ln3410">}</a>
<a name="ln3411">#define TYPVAL_ENCODE_CONV_LIST_START(tv, len)</a>
<a name="ln3412"> </a>
<a name="ln3413">#define TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, mpsv) \</a>
<a name="ln3414">  do { \</a>
<a name="ln3415">    if (_nothing_conv_real_list_after_start(tv, &amp;(mpsv)) != NOTDONE) { \</a>
<a name="ln3416">      goto typval_encode_stop_converting_one_item; \</a>
<a name="ln3417">    } \</a>
<a name="ln3418">  } while (0)</a>
<a name="ln3419"> </a>
<a name="ln3420">#define TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS(tv)</a>
<a name="ln3421"> </a>
<a name="ln3422">static inline void _nothing_conv_list_end(typval_T *const tv)</a>
<a name="ln3423">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln3424">{</a>
<a name="ln3425">  if (tv == NULL) {</a>
<a name="ln3426">    return;</a>
<a name="ln3427">  }</a>
<a name="ln3428">  assert(tv-&gt;v_type == VAR_LIST);</a>
<a name="ln3429">  list_T *const list = tv-&gt;vval.v_list;</a>
<a name="ln3430">  tv_list_unref(list);</a>
<a name="ln3431">  tv-&gt;vval.v_list = NULL;</a>
<a name="ln3432">}</a>
<a name="ln3433">#define TYPVAL_ENCODE_CONV_LIST_END(tv) _nothing_conv_list_end(tv)</a>
<a name="ln3434"> </a>
<a name="ln3435">static inline int _nothing_conv_real_dict_after_start(typval_T *const tv, dict_T **const dictp,</a>
<a name="ln3436">                                                      const void *const nodictvar,</a>
<a name="ln3437">                                                      MPConvStackVal *const mpsv)</a>
<a name="ln3438">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3439">{</a>
<a name="ln3440">  if (tv != NULL) {</a>
<a name="ln3441">    tv-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3442">  }</a>
<a name="ln3443">  if ((const void *)dictp != nodictvar &amp;&amp; (*dictp)-&gt;dv_refcount &gt; 1) {</a>
<a name="ln3444">    (*dictp)-&gt;dv_refcount--;</a>
<a name="ln3445">    *dictp = NULL;</a>
<a name="ln3446">    mpsv-&gt;data.d.todo = 0;</a>
<a name="ln3447">    return OK;</a>
<a name="ln3448">  }</a>
<a name="ln3449">  return NOTDONE;</a>
<a name="ln3450">}</a>
<a name="ln3451">#define TYPVAL_ENCODE_CONV_DICT_START(tv, dict, len)</a>
<a name="ln3452"> </a>
<a name="ln3453">#define TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, dict, mpsv) \</a>
<a name="ln3454">  do { \</a>
<a name="ln3455">    if (_nothing_conv_real_dict_after_start(tv, (dict_T **)&amp;(dict), \</a>
<a name="ln3456">                                            (void *)&amp;TYPVAL_ENCODE_NODICT_VAR, &amp;(mpsv)) \</a>
<a name="ln3457">        != NOTDONE) { \</a>
<a name="ln3458">      goto typval_encode_stop_converting_one_item; \</a>
<a name="ln3459">    } \</a>
<a name="ln3460">  } while (0)</a>
<a name="ln3461"> </a>
<a name="ln3462">#define TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(tv, dict)</a>
<a name="ln3463">#define TYPVAL_ENCODE_CONV_DICT_AFTER_KEY(tv, dict)</a>
<a name="ln3464">#define TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS(tv, dict)</a>
<a name="ln3465"> </a>
<a name="ln3466">static inline void _nothing_conv_dict_end(typval_T *const tv, dict_T **const dictp,</a>
<a name="ln3467">                                          const void *const nodictvar)</a>
<a name="ln3468">  FUNC_ATTR_ALWAYS_INLINE</a>
<a name="ln3469">{</a>
<a name="ln3470">  if ((const void *)dictp != nodictvar) {</a>
<a name="ln3471">    tv_dict_unref(*dictp);</a>
<a name="ln3472">    *dictp = NULL;</a>
<a name="ln3473">  }</a>
<a name="ln3474">}</a>
<a name="ln3475">#define TYPVAL_ENCODE_CONV_DICT_END(tv, dict) \</a>
<a name="ln3476">  _nothing_conv_dict_end(tv, (dict_T **)&amp;(dict), \</a>
<a name="ln3477">                         (void *)&amp;TYPVAL_ENCODE_NODICT_VAR)</a>
<a name="ln3478"> </a>
<a name="ln3479">#define TYPVAL_ENCODE_CONV_RECURSE(val, conv_type)</a>
<a name="ln3480"> </a>
<a name="ln3481">#define TYPVAL_ENCODE_SCOPE static</a>
<a name="ln3482">#define TYPVAL_ENCODE_NAME nothing</a>
<a name="ln3483">#define TYPVAL_ENCODE_FIRST_ARG_TYPE const void *const</a>
<a name="ln3484">#define TYPVAL_ENCODE_FIRST_ARG_NAME ignored</a>
<a name="ln3485">#include &quot;nvim/eval/typval_encode.c.h&quot;</a>
<a name="ln3486"> </a>
<a name="ln3487">#undef TYPVAL_ENCODE_SCOPE</a>
<a name="ln3488">#undef TYPVAL_ENCODE_NAME</a>
<a name="ln3489">#undef TYPVAL_ENCODE_FIRST_ARG_TYPE</a>
<a name="ln3490">#undef TYPVAL_ENCODE_FIRST_ARG_NAME</a>
<a name="ln3491"> </a>
<a name="ln3492">#undef TYPVAL_ENCODE_ALLOW_SPECIALS</a>
<a name="ln3493">#undef TYPVAL_ENCODE_CONV_NIL</a>
<a name="ln3494">#undef TYPVAL_ENCODE_CONV_BOOL</a>
<a name="ln3495">#undef TYPVAL_ENCODE_CONV_NUMBER</a>
<a name="ln3496">#undef TYPVAL_ENCODE_CONV_UNSIGNED_NUMBER</a>
<a name="ln3497">#undef TYPVAL_ENCODE_CONV_FLOAT</a>
<a name="ln3498">#undef TYPVAL_ENCODE_CONV_STRING</a>
<a name="ln3499">#undef TYPVAL_ENCODE_CONV_STR_STRING</a>
<a name="ln3500">#undef TYPVAL_ENCODE_CONV_EXT_STRING</a>
<a name="ln3501">#undef TYPVAL_ENCODE_CONV_BLOB</a>
<a name="ln3502">#undef TYPVAL_ENCODE_CONV_FUNC_START</a>
<a name="ln3503">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_ARGS</a>
<a name="ln3504">#undef TYPVAL_ENCODE_CONV_FUNC_BEFORE_SELF</a>
<a name="ln3505">#undef TYPVAL_ENCODE_CONV_FUNC_END</a>
<a name="ln3506">#undef TYPVAL_ENCODE_CONV_EMPTY_LIST</a>
<a name="ln3507">#undef TYPVAL_ENCODE_CONV_EMPTY_DICT</a>
<a name="ln3508">#undef TYPVAL_ENCODE_CONV_LIST_START</a>
<a name="ln3509">#undef TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START</a>
<a name="ln3510">#undef TYPVAL_ENCODE_CONV_LIST_BETWEEN_ITEMS</a>
<a name="ln3511">#undef TYPVAL_ENCODE_CONV_LIST_END</a>
<a name="ln3512">#undef TYPVAL_ENCODE_CONV_DICT_START</a>
<a name="ln3513">#undef TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START</a>
<a name="ln3514">#undef TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK</a>
<a name="ln3515">#undef TYPVAL_ENCODE_CONV_DICT_AFTER_KEY</a>
<a name="ln3516">#undef TYPVAL_ENCODE_CONV_DICT_BETWEEN_ITEMS</a>
<a name="ln3517">#undef TYPVAL_ENCODE_CONV_DICT_END</a>
<a name="ln3518">#undef TYPVAL_ENCODE_CONV_RECURSE</a>
<a name="ln3519"> </a>
<a name="ln3520">/// Free memory for a variable value and set the value to NULL or 0</a>
<a name="ln3521">///</a>
<a name="ln3522">/// @param[in,out]  tv  Value to free.</a>
<a name="ln3523">void tv_clear(typval_T *const tv)</a>
<a name="ln3524">{</a>
<a name="ln3525">  if (tv == NULL || tv-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln3526">    return;</a>
<a name="ln3527">  }</a>
<a name="ln3528"> </a>
<a name="ln3529">  // WARNING: do not translate the string here, gettext is slow and function</a>
<a name="ln3530">  // is used *very* often. At the current state encode_vim_to_nothing() does</a>
<a name="ln3531">  // not error out and does not use the argument anywhere.</a>
<a name="ln3532">  //</a>
<a name="ln3533">  // If situation changes and this argument will be used, translate it in the</a>
<a name="ln3534">  // place where it is used.</a>
<a name="ln3535">  const int evn_ret = encode_vim_to_nothing(NULL, tv, &quot;tv_clear() argument&quot;);</a>
<a name="ln3536">  (void)evn_ret;</a>
<a name="ln3537">  assert(evn_ret == OK);</a>
<a name="ln3538">}</a>
<a name="ln3539"> </a>
<a name="ln3540">//{{{3 Free</a>
<a name="ln3541"> </a>
<a name="ln3542">/// Free allocated Vimscript object and value stored inside</a>
<a name="ln3543">///</a>
<a name="ln3544">/// @param  tv  Object to free.</a>
<a name="ln3545">void tv_free(typval_T *tv)</a>
<a name="ln3546">{</a>
<a name="ln3547">  if (tv == NULL) {</a>
<a name="ln3548">    return;</a>
<a name="ln3549">  }</a>
<a name="ln3550"> </a>
<a name="ln3551">  switch (tv-&gt;v_type) {</a>
<a name="ln3552">  case VAR_PARTIAL:</a>
<a name="ln3553">    partial_unref(tv-&gt;vval.v_partial);</a>
<a name="ln3554">    break;</a>
<a name="ln3555">  case VAR_FUNC:</a>
<a name="ln3556">    func_unref(tv-&gt;vval.v_string);</a>
<a name="ln3557">    FALLTHROUGH;</a>
<a name="ln3558">  case VAR_STRING:</a>
<a name="ln3559">    xfree(tv-&gt;vval.v_string);</a>
<a name="ln3560">    break;</a>
<a name="ln3561">  case VAR_BLOB:</a>
<a name="ln3562">    tv_blob_unref(tv-&gt;vval.v_blob);</a>
<a name="ln3563">    break;</a>
<a name="ln3564">  case VAR_LIST:</a>
<a name="ln3565">    tv_list_unref(tv-&gt;vval.v_list);</a>
<a name="ln3566">    break;</a>
<a name="ln3567">  case VAR_DICT:</a>
<a name="ln3568">    tv_dict_unref(tv-&gt;vval.v_dict);</a>
<a name="ln3569">    break;</a>
<a name="ln3570">  case VAR_BOOL:</a>
<a name="ln3571">  case VAR_SPECIAL:</a>
<a name="ln3572">  case VAR_NUMBER:</a>
<a name="ln3573">  case VAR_FLOAT:</a>
<a name="ln3574">  case VAR_UNKNOWN:</a>
<a name="ln3575">    break;</a>
<a name="ln3576">  }</a>
<a name="ln3577">  xfree(tv);</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">//{{{3 Copy</a>
<a name="ln3581"> </a>
<a name="ln3582">/// Copy typval from one location to another</a>
<a name="ln3583">///</a>
<a name="ln3584">/// When needed allocates string or increases reference count. Does not make</a>
<a name="ln3585">/// a copy of a container, but copies its reference!</a>
<a name="ln3586">///</a>
<a name="ln3587">/// It is OK for `from` and `to` to point to the same location; this is used to</a>
<a name="ln3588">/// make a copy later.</a>
<a name="ln3589">///</a>
<a name="ln3590">/// @param[in]  from  Location to copy from.</a>
<a name="ln3591">/// @param[out]  to  Location to copy to.</a>
<a name="ln3592">void tv_copy(const typval_T *const from, typval_T *const to)</a>
<a name="ln3593">{</a>
<a name="ln3594">  to-&gt;v_type = from-&gt;v_type;</a>
<a name="ln3595">  to-&gt;v_lock = VAR_UNLOCKED;</a>
<a name="ln3596">  memmove(&amp;to-&gt;vval, &amp;from-&gt;vval, sizeof(to-&gt;vval));</a>
<a name="ln3597">  switch (from-&gt;v_type) {</a>
<a name="ln3598">  case VAR_NUMBER:</a>
<a name="ln3599">  case VAR_FLOAT:</a>
<a name="ln3600">  case VAR_BOOL:</a>
<a name="ln3601">  case VAR_SPECIAL:</a>
<a name="ln3602">    break;</a>
<a name="ln3603">  case VAR_STRING:</a>
<a name="ln3604">  case VAR_FUNC:</a>
<a name="ln3605">    if (from-&gt;vval.v_string != NULL) {</a>
<a name="ln3606">      to-&gt;vval.v_string = xstrdup(from-&gt;vval.v_string);</a>
<a name="ln3607">      if (from-&gt;v_type == VAR_FUNC) {</a>
<a name="ln3608">        func_ref(to-&gt;vval.v_string);</a>
<a name="ln3609">      }</a>
<a name="ln3610">    }</a>
<a name="ln3611">    break;</a>
<a name="ln3612">  case VAR_PARTIAL:</a>
<a name="ln3613">    if (to-&gt;vval.v_partial != NULL) {</a>
<a name="ln3614">      to-&gt;vval.v_partial-&gt;pt_refcount++;</a>
<a name="ln3615">    }</a>
<a name="ln3616">    break;</a>
<a name="ln3617">  case VAR_BLOB:</a>
<a name="ln3618">    if (from-&gt;vval.v_blob != NULL) {</a>
<a name="ln3619">      to-&gt;vval.v_blob-&gt;bv_refcount++;</a>
<a name="ln3620">    }</a>
<a name="ln3621">    break;</a>
<a name="ln3622">  case VAR_LIST:</a>
<a name="ln3623">    tv_list_ref(to-&gt;vval.v_list);</a>
<a name="ln3624">    break;</a>
<a name="ln3625">  case VAR_DICT:</a>
<a name="ln3626">    if (from-&gt;vval.v_dict != NULL) {</a>
<a name="ln3627">      to-&gt;vval.v_dict-&gt;dv_refcount++;</a>
<a name="ln3628">    }</a>
<a name="ln3629">    break;</a>
<a name="ln3630">  case VAR_UNKNOWN:</a>
<a name="ln3631">    semsg(_(e_intern2), &quot;tv_copy(UNKNOWN)&quot;);</a>
<a name="ln3632">    break;</a>
<a name="ln3633">  }</a>
<a name="ln3634">}</a>
<a name="ln3635"> </a>
<a name="ln3636">//{{{2 Locks</a>
<a name="ln3637"> </a>
<a name="ln3638">/// Lock or unlock an item</a>
<a name="ln3639">///</a>
<a name="ln3640">/// @param[out]  tv  Item to (un)lock.</a>
<a name="ln3641">/// @param[in]  deep  Levels to (un)lock, -1 to (un)lock everything.</a>
<a name="ln3642">/// @param[in]  lock  True if it is needed to lock an item, false to unlock.</a>
<a name="ln3643">/// @param[in]  check_refcount  If true, do not lock a list or dict with a</a>
<a name="ln3644">///                             reference count larger than 1.</a>
<a name="ln3645">void tv_item_lock(typval_T *const tv, const int deep, const bool lock, const bool check_refcount)</a>
<a name="ln3646">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3647">{</a>
<a name="ln3648">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln3649">  static int recurse = 0;</a>
<a name="ln3650"> </a>
<a name="ln3651">  if (recurse &gt;= DICT_MAXNEST) {</a>
<a name="ln3652">    emsg(_(e_variable_nested_too_deep_for_unlock));</a>
<a name="ln3653">    return;</a>
<a name="ln3654">  }</a>
<a name="ln3655">  if (deep == 0) {</a>
<a name="ln3656">    return;</a>
<a name="ln3657">  }</a>
<a name="ln3658">  recurse++;</a>
<a name="ln3659"> </a>
<a name="ln3660">  // lock/unlock the item itself</a>
<a name="ln3661">#define CHANGE_LOCK(lock, var) \</a>
<a name="ln3662">  do { \</a>
<a name="ln3663">    (var) = ((VarLockStatus[]) { \</a>
<a name="ln3664">      [VAR_UNLOCKED] = ((lock) ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln3665">      [VAR_LOCKED] = ((lock) ? VAR_LOCKED : VAR_UNLOCKED), \</a>
<a name="ln3666">      [VAR_FIXED] = VAR_FIXED, \</a>
<a name="ln3667">    })[var]; \</a>
<a name="ln3668">  } while (0)</a>
<a name="ln3669">  CHANGE_LOCK(lock, tv-&gt;v_lock);</a>
<a name="ln3670"> </a>
<a name="ln3671">  switch (tv-&gt;v_type) {</a>
<a name="ln3672">  case VAR_BLOB: {</a>
<a name="ln3673">    blob_T *const b = tv-&gt;vval.v_blob;</a>
<a name="ln3674">    if (b != NULL &amp;&amp; !(check_refcount &amp;&amp; b-&gt;bv_refcount &gt; 1)) {</a>
<a name="ln3675">      CHANGE_LOCK(lock, b-&gt;bv_lock);</a>
<a name="ln3676">    }</a>
<a name="ln3677">    break;</a>
<a name="ln3678">  }</a>
<a name="ln3679">  case VAR_LIST: {</a>
<a name="ln3680">    list_T *const l = tv-&gt;vval.v_list;</a>
<a name="ln3681">    if (l != NULL &amp;&amp; !(check_refcount &amp;&amp; l-&gt;lv_refcount &gt; 1)) {</a>
<a name="ln3682">      CHANGE_LOCK(lock, l-&gt;lv_lock);</a>
<a name="ln3683">      if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln3684">        // Recursive: lock/unlock the items the List contains.</a>
<a name="ln3685">        TV_LIST_ITER(l, li, {</a>
<a name="ln3686">            tv_item_lock(TV_LIST_ITEM_TV(li), deep - 1, lock, check_refcount);</a>
<a name="ln3687">          });</a>
<a name="ln3688">      }</a>
<a name="ln3689">    }</a>
<a name="ln3690">    break;</a>
<a name="ln3691">  }</a>
<a name="ln3692">  case VAR_DICT: {</a>
<a name="ln3693">    dict_T *const d = tv-&gt;vval.v_dict;</a>
<a name="ln3694">    if (d != NULL &amp;&amp; !(check_refcount &amp;&amp; d-&gt;dv_refcount &gt; 1)) {</a>
<a name="ln3695">      CHANGE_LOCK(lock, d-&gt;dv_lock);</a>
<a name="ln3696">      if (deep &lt; 0 || deep &gt; 1) {</a>
<a name="ln3697">        // recursive: lock/unlock the items the List contains</a>
<a name="ln3698">        TV_DICT_ITER(d, di, {</a>
<a name="ln3699">            tv_item_lock(&amp;di-&gt;di_tv, deep - 1, lock, check_refcount);</a>
<a name="ln3700">          });</a>
<a name="ln3701">      }</a>
<a name="ln3702">    }</a>
<a name="ln3703">    break;</a>
<a name="ln3704">  }</a>
<a name="ln3705">  case VAR_NUMBER:</a>
<a name="ln3706">  case VAR_FLOAT:</a>
<a name="ln3707">  case VAR_STRING:</a>
<a name="ln3708">  case VAR_FUNC:</a>
<a name="ln3709">  case VAR_PARTIAL:</a>
<a name="ln3710">  case VAR_BOOL:</a>
<a name="ln3711">  case VAR_SPECIAL:</a>
<a name="ln3712">    break;</a>
<a name="ln3713">  case VAR_UNKNOWN:</a>
<a name="ln3714">    abort();</a>
<a name="ln3715">  }</a>
<a name="ln3716">#undef CHANGE_LOCK</a>
<a name="ln3717">  recurse--;</a>
<a name="ln3718">}</a>
<a name="ln3719"> </a>
<a name="ln3720">/// Check whether Vimscript value is locked itself or refers to a locked container</a>
<a name="ln3721">///</a>
<a name="ln3722">/// @warning Fixed container is not the same as locked.</a>
<a name="ln3723">///</a>
<a name="ln3724">/// @param[in]  tv  Value to check.</a>
<a name="ln3725">///</a>
<a name="ln3726">/// @return True if value is locked, false otherwise.</a>
<a name="ln3727">bool tv_islocked(const typval_T *const tv)</a>
<a name="ln3728">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3729">{</a>
<a name="ln3730">  return ((tv-&gt;v_lock == VAR_LOCKED)</a>
<a name="ln3731">          || (tv-&gt;v_type == VAR_LIST</a>
<a name="ln3732">              &amp;&amp; (tv_list_locked(tv-&gt;vval.v_list) == VAR_LOCKED))</a>
<a name="ln3733">          || (tv-&gt;v_type == VAR_DICT</a>
<a name="ln3734">              &amp;&amp; tv-&gt;vval.v_dict != NULL</a>
<a name="ln3735">              &amp;&amp; (tv-&gt;vval.v_dict-&gt;dv_lock == VAR_LOCKED)));</a>
<a name="ln3736">}</a>
<a name="ln3737"> </a>
<a name="ln3738">/// Return true if typval is locked</a>
<a name="ln3739">///</a>
<a name="ln3740">/// Also gives an error message when typval is locked.</a>
<a name="ln3741">///</a>
<a name="ln3742">/// @param[in]  tv  Typval.</a>
<a name="ln3743">/// @param[in]  name  Variable name, used in the error message.</a>
<a name="ln3744">/// @param[in]  name_len  Variable name length. Use #TV_TRANSLATE to translate</a>
<a name="ln3745">///                       variable name and compute the length. Use #TV_CSTRING</a>
<a name="ln3746">///                       to compute the length with strlen() without</a>
<a name="ln3747">///                       translating.</a>
<a name="ln3748">///</a>
<a name="ln3749">///                       Both #TV_… values are used for optimization purposes:</a>
<a name="ln3750">///                       variable name with its length is needed only in case</a>
<a name="ln3751">///                       of error, when no error occurs computing them is</a>
<a name="ln3752">///                       a waste of CPU resources. This especially applies to</a>
<a name="ln3753">///                       gettext.</a>
<a name="ln3754">///</a>
<a name="ln3755">/// @return true if variable is locked, false otherwise.</a>
<a name="ln3756">bool tv_check_lock(const typval_T *tv, const char *name, size_t name_len)</a>
<a name="ln3757">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3758">{</a>
<a name="ln3759">  VarLockStatus lock = VAR_UNLOCKED;</a>
<a name="ln3760"> </a>
<a name="ln3761">  switch (tv-&gt;v_type) {</a>
<a name="ln3762">  case VAR_BLOB:</a>
<a name="ln3763">    if (tv-&gt;vval.v_blob != NULL) {</a>
<a name="ln3764">      lock = tv-&gt;vval.v_blob-&gt;bv_lock;</a>
<a name="ln3765">    }</a>
<a name="ln3766">    break;</a>
<a name="ln3767">  case VAR_LIST:</a>
<a name="ln3768">    if (tv-&gt;vval.v_list != NULL) {</a>
<a name="ln3769">      lock = tv-&gt;vval.v_list-&gt;lv_lock;</a>
<a name="ln3770">    }</a>
<a name="ln3771">    break;</a>
<a name="ln3772">  case VAR_DICT:</a>
<a name="ln3773">    if (tv-&gt;vval.v_dict != NULL) {</a>
<a name="ln3774">      lock = tv-&gt;vval.v_dict-&gt;dv_lock;</a>
<a name="ln3775">    }</a>
<a name="ln3776">    break;</a>
<a name="ln3777">  default:</a>
<a name="ln3778">    break;</a>
<a name="ln3779">  }</a>
<a name="ln3780">  return value_check_lock(tv-&gt;v_lock, name, name_len)</a>
<a name="ln3781">         || (lock != VAR_UNLOCKED &amp;&amp; value_check_lock(lock, name, name_len));</a>
<a name="ln3782">}</a>
<a name="ln3783"> </a>
<a name="ln3784">/// @return true if variable &quot;name&quot; has a locked (immutable) value</a>
<a name="ln3785">bool value_check_lock(VarLockStatus lock, const char *name, size_t name_len)</a>
<a name="ln3786">{</a>
<a name="ln3787">  const char *error_message = NULL;</a>
<a name="ln3788">  switch (lock) {</a>
<a name="ln3789">  case VAR_UNLOCKED:</a>
<a name="ln3790">    return false;</a>
<a name="ln3791">  case VAR_LOCKED:</a>
<a name="ln3792">    error_message = N_(&quot;E741: Value is locked: %.*s&quot;);</a>
<a name="ln3793">    break;</a>
<a name="ln3794">  case VAR_FIXED:</a>
<a name="ln3795">    error_message = N_(&quot;E742: Cannot change value of %.*s&quot;);</a>
<a name="ln3796">    break;</a>
<a name="ln3797">  }</a>
<a name="ln3798">  assert(error_message != NULL);</a>
<a name="ln3799"> </a>
<a name="ln3800">  if (name == NULL) {</a>
<a name="ln3801">    name = _(&quot;Unknown&quot;);</a>
<a name="ln3802">    name_len = strlen(name);</a>
<a name="ln3803">  } else if (name_len == TV_TRANSLATE) {</a>
<a name="ln3804">    name = _(name);</a>
<a name="ln3805">    name_len = strlen(name);</a>
<a name="ln3806">  } else if (name_len == TV_CSTRING) {</a>
<a name="ln3807">    name_len = strlen(name);</a>
<a name="ln3808">  }</a>
<a name="ln3809"> </a>
<a name="ln3810">  semsg(_(error_message), (int)name_len, name);</a>
<a name="ln3811"> </a>
<a name="ln3812">  return true;</a>
<a name="ln3813">}</a>
<a name="ln3814"> </a>
<a name="ln3815">//{{{2 Comparison</a>
<a name="ln3816"> </a>
<a name="ln3817">static int tv_equal_recurse_limit;</a>
<a name="ln3818"> </a>
<a name="ln3819">/// Compare two Vimscript values</a>
<a name="ln3820">///</a>
<a name="ln3821">/// Like &quot;==&quot;, but strings and numbers are different, as well as floats and</a>
<a name="ln3822">/// numbers.</a>
<a name="ln3823">///</a>
<a name="ln3824">/// @warning Too nested structures may be considered equal even if they are not.</a>
<a name="ln3825">///</a>
<a name="ln3826">/// @param[in]  tv1  First value to compare.</a>
<a name="ln3827">/// @param[in]  tv2  Second value to compare.</a>
<a name="ln3828">/// @param[in]  ic  True if case is to be ignored.</a>
<a name="ln3829">/// @param[in]  recursive  True when used recursively.</a>
<a name="ln3830">///</a>
<a name="ln3831">/// @return true if values are equal.</a>
<a name="ln3832">bool tv_equal(typval_T *const tv1, typval_T *const tv2, const bool ic, const bool recursive)</a>
<a name="ln3833">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3834">{</a>
<a name="ln3835">  // TODO(ZyX-I): Make this not recursive</a>
<a name="ln3836">  static int recursive_cnt = 0;  // Catch recursive loops.</a>
<a name="ln3837"> </a>
<a name="ln3838">  if (!(tv_is_func(*tv1) &amp;&amp; tv_is_func(*tv2)) &amp;&amp; tv1-&gt;v_type != tv2-&gt;v_type) {</a>
<a name="ln3839">    return false;</a>
<a name="ln3840">  }</a>
<a name="ln3841"> </a>
<a name="ln3842">  // Catch lists and dicts that have an endless loop by limiting</a>
<a name="ln3843">  // recursiveness to a limit.  We guess they are equal then.</a>
<a name="ln3844">  // A fixed limit has the problem of still taking an awful long time.</a>
<a name="ln3845">  // Reduce the limit every time running into it. That should work fine for</a>
<a name="ln3846">  // deeply linked structures that are not recursively linked and catch</a>
<a name="ln3847">  // recursiveness quickly.</a>
<a name="ln3848">  if (!recursive) {</a>
<a name="ln3849">    tv_equal_recurse_limit = 1000;</a>
<a name="ln3850">  }</a>
<a name="ln3851">  if (recursive_cnt &gt;= tv_equal_recurse_limit) {</a>
<a name="ln3852">    tv_equal_recurse_limit--;</a>
<a name="ln3853">    return true;</a>
<a name="ln3854">  }</a>
<a name="ln3855"> </a>
<a name="ln3856">  switch (tv1-&gt;v_type) {</a>
<a name="ln3857">  case VAR_LIST: {</a>
<a name="ln3858">    recursive_cnt++;</a>
<a name="ln3859">    const bool r = tv_list_equal(tv1-&gt;vval.v_list, tv2-&gt;vval.v_list, ic,</a>
<a name="ln3860">                                 true);</a>
<a name="ln3861">    recursive_cnt--;</a>
<a name="ln3862">    return r;</a>
<a name="ln3863">  }</a>
<a name="ln3864">  case VAR_DICT: {</a>
<a name="ln3865">    recursive_cnt++;</a>
<a name="ln3866">    const bool r = tv_dict_equal(tv1-&gt;vval.v_dict, tv2-&gt;vval.v_dict, ic,</a>
<a name="ln3867">                                 true);</a>
<a name="ln3868">    recursive_cnt--;</a>
<a name="ln3869">    return r;</a>
<a name="ln3870">  }</a>
<a name="ln3871">  case VAR_PARTIAL:</a>
<a name="ln3872">  case VAR_FUNC: {</a>
<a name="ln3873">    if ((tv1-&gt;v_type == VAR_PARTIAL &amp;&amp; tv1-&gt;vval.v_partial == NULL)</a>
<a name="ln3874">        || (tv2-&gt;v_type == VAR_PARTIAL &amp;&amp; tv2-&gt;vval.v_partial == NULL)) {</a>
<a name="ln3875">      return false;</a>
<a name="ln3876">    }</a>
<a name="ln3877">    recursive_cnt++;</a>
<a name="ln3878">    const bool r = func_equal(tv1, tv2, ic);</a>
<a name="ln3879">    recursive_cnt--;</a>
<a name="ln3880">    return r;</a>
<a name="ln3881">  }</a>
<a name="ln3882">  case VAR_BLOB:</a>
<a name="ln3883">    return tv_blob_equal(tv1-&gt;vval.v_blob, tv2-&gt;vval.v_blob);</a>
<a name="ln3884">  case VAR_NUMBER:</a>
<a name="ln3885">    return tv1-&gt;vval.v_number == tv2-&gt;vval.v_number;</a>
<a name="ln3886">  case VAR_FLOAT:</a>
<a name="ln3887">    return tv1-&gt;vval.v_float == tv2-&gt;vval.v_float;</a>
<a name="ln3888">  case VAR_STRING: {</a>
<a name="ln3889">    char buf1[NUMBUFLEN];</a>
<a name="ln3890">    char buf2[NUMBUFLEN];</a>
<a name="ln3891">    const char *s1 = tv_get_string_buf(tv1, buf1);</a>
<a name="ln3892">    const char *s2 = tv_get_string_buf(tv2, buf2);</a>
<a name="ln3893">    return mb_strcmp_ic(ic, s1, s2) == 0;</a>
<a name="ln3894">  }</a>
<a name="ln3895">  case VAR_BOOL:</a>
<a name="ln3896">    return tv1-&gt;vval.v_bool == tv2-&gt;vval.v_bool;</a>
<a name="ln3897">  case VAR_SPECIAL:</a>
<a name="ln3898">    return tv1-&gt;vval.v_special == tv2-&gt;vval.v_special;</a>
<a name="ln3899">  case VAR_UNKNOWN:</a>
<a name="ln3900">    // VAR_UNKNOWN can be the result of an invalid expression, let’s say it</a>
<a name="ln3901">    // does not equal anything, not even self.</a>
<a name="ln3902">    return false;</a>
<a name="ln3903">  }</a>
<a name="ln3904"> </a>
<a name="ln3905">  abort();</a>
<a name="ln3906">  return false;</a>
<a name="ln3907">}</a>
<a name="ln3908"> </a>
<a name="ln3909">//{{{2 Type checks</a>
<a name="ln3910"> </a>
<a name="ln3911">/// Check that given value is a number or string</a>
<a name="ln3912">///</a>
<a name="ln3913">/// Error messages are compatible with tv_get_number() previously used for the</a>
<a name="ln3914">/// same purpose in buf*() functions. Special values are not accepted (previous</a>
<a name="ln3915">/// behaviour: silently fail to find buffer).</a>
<a name="ln3916">///</a>
<a name="ln3917">/// @param[in]  tv  Value to check.</a>
<a name="ln3918">///</a>
<a name="ln3919">/// @return true if everything is OK, false otherwise.</a>
<a name="ln3920">bool tv_check_str_or_nr(const typval_T *const tv)</a>
<a name="ln3921">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3922">{</a>
<a name="ln3923">  switch (tv-&gt;v_type) {</a>
<a name="ln3924">  case VAR_NUMBER:</a>
<a name="ln3925">  case VAR_STRING:</a>
<a name="ln3926">    return true;</a>
<a name="ln3927">  case VAR_FLOAT:</a>
<a name="ln3928">    emsg(_(&quot;E805: Expected a Number or a String, Float found&quot;));</a>
<a name="ln3929">    return false;</a>
<a name="ln3930">  case VAR_PARTIAL:</a>
<a name="ln3931">  case VAR_FUNC:</a>
<a name="ln3932">    emsg(_(&quot;E703: Expected a Number or a String, Funcref found&quot;));</a>
<a name="ln3933">    return false;</a>
<a name="ln3934">  case VAR_LIST:</a>
<a name="ln3935">    emsg(_(&quot;E745: Expected a Number or a String, List found&quot;));</a>
<a name="ln3936">    return false;</a>
<a name="ln3937">  case VAR_DICT:</a>
<a name="ln3938">    emsg(_(&quot;E728: Expected a Number or a String, Dictionary found&quot;));</a>
<a name="ln3939">    return false;</a>
<a name="ln3940">  case VAR_BLOB:</a>
<a name="ln3941">    emsg(_(&quot;E974: Expected a Number or a String, Blob found&quot;));</a>
<a name="ln3942">    return false;</a>
<a name="ln3943">  case VAR_BOOL:</a>
<a name="ln3944">    emsg(_(&quot;E5299: Expected a Number or a String, Boolean found&quot;));</a>
<a name="ln3945">    return false;</a>
<a name="ln3946">  case VAR_SPECIAL:</a>
<a name="ln3947">    emsg(_(&quot;E5300: Expected a Number or a String&quot;));</a>
<a name="ln3948">    return false;</a>
<a name="ln3949">  case VAR_UNKNOWN:</a>
<a name="ln3950">    semsg(_(e_intern2), &quot;tv_check_str_or_nr(UNKNOWN)&quot;);</a>
<a name="ln3951">    return false;</a>
<a name="ln3952">  }</a>
<a name="ln3953">  abort();</a>
<a name="ln3954">  return false;</a>
<a name="ln3955">}</a>
<a name="ln3956"> </a>
<a name="ln3957">#define FUNC_ERROR &quot;E703: Using a Funcref as a Number&quot;</a>
<a name="ln3958"> </a>
<a name="ln3959">static const char *const num_errors[] = {</a>
<a name="ln3960">  [VAR_PARTIAL]= N_(FUNC_ERROR),</a>
<a name="ln3961">  [VAR_FUNC]= N_(FUNC_ERROR),</a>
<a name="ln3962">  [VAR_LIST]= N_(&quot;E745: Using a List as a Number&quot;),</a>
<a name="ln3963">  [VAR_DICT]= N_(&quot;E728: Using a Dictionary as a Number&quot;),</a>
<a name="ln3964">  [VAR_FLOAT]= N_(&quot;E805: Using a Float as a Number&quot;),</a>
<a name="ln3965">  [VAR_BLOB]= N_(&quot;E974: Using a Blob as a Number&quot;),</a>
<a name="ln3966">  [VAR_UNKNOWN]= N_(&quot;E685: using an invalid value as a Number&quot;),</a>
<a name="ln3967">};</a>
<a name="ln3968"> </a>
<a name="ln3969">#undef FUNC_ERROR</a>
<a name="ln3970"> </a>
<a name="ln3971">/// Check that given value is a number or can be converted to it</a>
<a name="ln3972">///</a>
<a name="ln3973">/// Error messages are compatible with tv_get_number_chk() previously used for</a>
<a name="ln3974">/// the same purpose.</a>
<a name="ln3975">///</a>
<a name="ln3976">/// @param[in]  tv  Value to check.</a>
<a name="ln3977">///</a>
<a name="ln3978">/// @return true if everything is OK, false otherwise.</a>
<a name="ln3979">bool tv_check_num(const typval_T *const tv)</a>
<a name="ln3980">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3981">{</a>
<a name="ln3982">  switch (tv-&gt;v_type) {</a>
<a name="ln3983">  case VAR_NUMBER:</a>
<a name="ln3984">  case VAR_BOOL:</a>
<a name="ln3985">  case VAR_SPECIAL:</a>
<a name="ln3986">  case VAR_STRING:</a>
<a name="ln3987">    return true;</a>
<a name="ln3988">  case VAR_FUNC:</a>
<a name="ln3989">  case VAR_PARTIAL:</a>
<a name="ln3990">  case VAR_LIST:</a>
<a name="ln3991">  case VAR_DICT:</a>
<a name="ln3992">  case VAR_FLOAT:</a>
<a name="ln3993">  case VAR_BLOB:</a>
<a name="ln3994">  case VAR_UNKNOWN:</a>
<a name="ln3995">    emsg(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln3996">    return false;</a>
<a name="ln3997">  }</a>
<a name="ln3998">  abort();</a>
<a name="ln3999">  return false;</a>
<a name="ln4000">}</a>
<a name="ln4001"> </a>
<a name="ln4002">#define FUNC_ERROR &quot;E729: Using a Funcref as a String&quot;</a>
<a name="ln4003"> </a>
<a name="ln4004">static const char *const str_errors[] = {</a>
<a name="ln4005">  [VAR_PARTIAL]= N_(FUNC_ERROR),</a>
<a name="ln4006">  [VAR_FUNC]= N_(FUNC_ERROR),</a>
<a name="ln4007">  [VAR_LIST]= N_(&quot;E730: Using a List as a String&quot;),</a>
<a name="ln4008">  [VAR_DICT]= N_(&quot;E731: Using a Dictionary as a String&quot;),</a>
<a name="ln4009">  [VAR_BLOB]= N_(&quot;E976: Using a Blob as a String&quot;),</a>
<a name="ln4010">  [VAR_UNKNOWN]= e_using_invalid_value_as_string,</a>
<a name="ln4011">};</a>
<a name="ln4012"> </a>
<a name="ln4013">#undef FUNC_ERROR</a>
<a name="ln4014"> </a>
<a name="ln4015">/// Check that given value is a Vimscript String or can be &quot;cast&quot; to it.</a>
<a name="ln4016">///</a>
<a name="ln4017">/// Error messages are compatible with tv_get_string_chk() previously used for</a>
<a name="ln4018">/// the same purpose.</a>
<a name="ln4019">///</a>
<a name="ln4020">/// @param[in]  tv  Value to check.</a>
<a name="ln4021">///</a>
<a name="ln4022">/// @return true if everything is OK, false otherwise.</a>
<a name="ln4023">bool tv_check_str(const typval_T *const tv)</a>
<a name="ln4024">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4025">{</a>
<a name="ln4026">  switch (tv-&gt;v_type) {</a>
<a name="ln4027">  case VAR_NUMBER:</a>
<a name="ln4028">  case VAR_BOOL:</a>
<a name="ln4029">  case VAR_SPECIAL:</a>
<a name="ln4030">  case VAR_STRING:</a>
<a name="ln4031">  case VAR_FLOAT:</a>
<a name="ln4032">    return true;</a>
<a name="ln4033">  case VAR_PARTIAL:</a>
<a name="ln4034">  case VAR_FUNC:</a>
<a name="ln4035">  case VAR_LIST:</a>
<a name="ln4036">  case VAR_DICT:</a>
<a name="ln4037">  case VAR_BLOB:</a>
<a name="ln4038">  case VAR_UNKNOWN:</a>
<a name="ln4039">    emsg(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln4040">    return false;</a>
<a name="ln4041">  }</a>
<a name="ln4042">  abort();</a>
<a name="ln4043">  return false;</a>
<a name="ln4044">}</a>
<a name="ln4045"> </a>
<a name="ln4046">//{{{2 Get</a>
<a name="ln4047"> </a>
<a name="ln4048">/// Get the number value of a Vimscript object</a>
<a name="ln4049">///</a>
<a name="ln4050">/// @note Use tv_get_number_chk() if you need to determine whether there was an</a>
<a name="ln4051">///       error.</a>
<a name="ln4052">///</a>
<a name="ln4053">/// @param[in]  tv  Object to get value from.</a>
<a name="ln4054">///</a>
<a name="ln4055">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln4056">///         for VAR_NUMBER objects, -1 for other types.</a>
<a name="ln4057">varnumber_T tv_get_number(const typval_T *const tv)</a>
<a name="ln4058">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4059">{</a>
<a name="ln4060">  bool error = false;</a>
<a name="ln4061">  return tv_get_number_chk(tv, &amp;error);</a>
<a name="ln4062">}</a>
<a name="ln4063"> </a>
<a name="ln4064">/// Get the number value of a Vimscript object</a>
<a name="ln4065">///</a>
<a name="ln4066">/// @param[in]  tv  Object to get value from.</a>
<a name="ln4067">/// @param[out]  ret_error  If type error occurred then `true` will be written</a>
<a name="ln4068">///                         to this location. Otherwise it is not touched.</a>
<a name="ln4069">///</a>
<a name="ln4070">///                         @note Needs to be initialized to `false` to be</a>
<a name="ln4071">///                               useful.</a>
<a name="ln4072">///</a>
<a name="ln4073">/// @return Number value: vim_str2nr() output for VAR_STRING objects, value</a>
<a name="ln4074">///         for VAR_NUMBER objects, -1 (ret_error == NULL) or 0 (otherwise) for</a>
<a name="ln4075">///         other types.</a>
<a name="ln4076">varnumber_T tv_get_number_chk(const typval_T *const tv, bool *const ret_error)</a>
<a name="ln4077">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4078">{</a>
<a name="ln4079">  switch (tv-&gt;v_type) {</a>
<a name="ln4080">  case VAR_FUNC:</a>
<a name="ln4081">  case VAR_PARTIAL:</a>
<a name="ln4082">  case VAR_LIST:</a>
<a name="ln4083">  case VAR_DICT:</a>
<a name="ln4084">  case VAR_BLOB:</a>
<a name="ln4085">  case VAR_FLOAT:</a>
<a name="ln4086">    emsg(_(num_errors[tv-&gt;v_type]));</a>
<a name="ln4087">    break;</a>
<a name="ln4088">  case VAR_NUMBER:</a>
<a name="ln4089">    return tv-&gt;vval.v_number;</a>
<a name="ln4090">  case VAR_STRING: {</a>
<a name="ln4091">    varnumber_T n = 0;</a>
<a name="ln4092">    if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln4093">      vim_str2nr(tv-&gt;vval.v_string, NULL, NULL, STR2NR_ALL, &amp;n, NULL, 0, false, NULL);</a>
<a name="ln4094">    }</a>
<a name="ln4095">    return n;</a>
<a name="ln4096">  }</a>
<a name="ln4097">  case VAR_BOOL:</a>
<a name="ln4098">    return tv-&gt;vval.v_bool == kBoolVarTrue ? 1 : 0;</a>
<a name="ln4099">  case VAR_SPECIAL:</a>
<a name="ln4100">    return 0;</a>
<a name="ln4101">  case VAR_UNKNOWN:</a>
<a name="ln4102">    semsg(_(e_intern2), &quot;tv_get_number(UNKNOWN)&quot;);</a>
<a name="ln4103">    break;</a>
<a name="ln4104">  }</a>
<a name="ln4105">  if (ret_error != NULL) {</a>
<a name="ln4106">    *ret_error = true;</a>
<a name="ln4107">  }</a>
<a name="ln4108">  return (ret_error == NULL ? -1 : 0);</a>
<a name="ln4109">}</a>
<a name="ln4110"> </a>
<a name="ln4111">varnumber_T tv_get_bool(const typval_T *const tv)</a>
<a name="ln4112">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4113">{</a>
<a name="ln4114">  return tv_get_number_chk(tv, NULL);</a>
<a name="ln4115">}</a>
<a name="ln4116"> </a>
<a name="ln4117">varnumber_T tv_get_bool_chk(const typval_T *const tv, bool *const ret_error)</a>
<a name="ln4118">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln4119">{</a>
<a name="ln4120">  return tv_get_number_chk(tv, ret_error);</a>
<a name="ln4121">}</a>
<a name="ln4122"> </a>
<a name="ln4123">/// Get the line number from Vimscript object</a>
<a name="ln4124">///</a>
<a name="ln4125">/// @param[in]  tv  Object to get value from. Is expected to be a number or</a>
<a name="ln4126">///                 a special string like &quot;.&quot;, &quot;$&quot;, … (works with current buffer</a>
<a name="ln4127">///                 only).</a>
<a name="ln4128">///</a>
<a name="ln4129">/// @return Line number or -1 or 0.</a>
<a name="ln4130">linenr_T tv_get_lnum(const typval_T *const tv)</a>
<a name="ln4131">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4132">{</a>
<a name="ln4133">  const int did_emsg_before = did_emsg;</a>
<a name="ln4134">  linenr_T lnum = (linenr_T)tv_get_number_chk(tv, NULL);</a>
<a name="ln4135">  if (lnum &lt;= 0 &amp;&amp; did_emsg_before == did_emsg &amp;&amp; tv-&gt;v_type != VAR_NUMBER) {</a>
<a name="ln4136">    int fnum;</a>
<a name="ln4137">    // No valid number, try using same function as line() does.</a>
<a name="ln4138">    pos_T *const fp = var2fpos(tv, true, &amp;fnum, false);</a>
<a name="ln4139">    if (fp != NULL) {</a>
<a name="ln4140">      lnum = fp-&gt;lnum;</a>
<a name="ln4141">    }</a>
<a name="ln4142">  }</a>
<a name="ln4143">  return lnum;</a>
<a name="ln4144">}</a>
<a name="ln4145"> </a>
<a name="ln4146">/// Get the floating-point value of a Vimscript object</a>
<a name="ln4147">///</a>
<a name="ln4148">/// Raises an error if object is not number or floating-point.</a>
<a name="ln4149">///</a>
<a name="ln4150">/// @param[in]  tv  Object to get value of.</a>
<a name="ln4151">///</a>
<a name="ln4152">/// @return Floating-point value of the variable or zero.</a>
<a name="ln4153">float_T tv_get_float(const typval_T *const tv)</a>
<a name="ln4154">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4155">{</a>
<a name="ln4156">  switch (tv-&gt;v_type) {</a>
<a name="ln4157">  case VAR_NUMBER:</a>
<a name="ln4158">    return (float_T)(tv-&gt;vval.v_number);</a>
<a name="ln4159">  case VAR_FLOAT:</a>
<a name="ln4160">    return tv-&gt;vval.v_float;</a>
<a name="ln4161">  case VAR_PARTIAL:</a>
<a name="ln4162">  case VAR_FUNC:</a>
<a name="ln4163">    emsg(_(&quot;E891: Using a Funcref as a Float&quot;));</a>
<a name="ln4164">    break;</a>
<a name="ln4165">  case VAR_STRING:</a>
<a name="ln4166">    emsg(_(&quot;E892: Using a String as a Float&quot;));</a>
<a name="ln4167">    break;</a>
<a name="ln4168">  case VAR_LIST:</a>
<a name="ln4169">    emsg(_(&quot;E893: Using a List as a Float&quot;));</a>
<a name="ln4170">    break;</a>
<a name="ln4171">  case VAR_DICT:</a>
<a name="ln4172">    emsg(_(&quot;E894: Using a Dictionary as a Float&quot;));</a>
<a name="ln4173">    break;</a>
<a name="ln4174">  case VAR_BOOL:</a>
<a name="ln4175">    emsg(_(&quot;E362: Using a boolean value as a Float&quot;));</a>
<a name="ln4176">    break;</a>
<a name="ln4177">  case VAR_SPECIAL:</a>
<a name="ln4178">    emsg(_(&quot;E907: Using a special value as a Float&quot;));</a>
<a name="ln4179">    break;</a>
<a name="ln4180">  case VAR_BLOB:</a>
<a name="ln4181">    emsg(_(&quot;E975: Using a Blob as a Float&quot;));</a>
<a name="ln4182">    break;</a>
<a name="ln4183">  case VAR_UNKNOWN:</a>
<a name="ln4184">    semsg(_(e_intern2), &quot;tv_get_float(UNKNOWN)&quot;);</a>
<a name="ln4185">    break;</a>
<a name="ln4186">  }</a>
<a name="ln4187">  return 0;</a>
<a name="ln4188">}</a>
<a name="ln4189"> </a>
<a name="ln4190">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string.</a>
<a name="ln4191">int tv_check_for_string_arg(const typval_T *const args, const int idx)</a>
<a name="ln4192">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4193">{</a>
<a name="ln4194">  if (args[idx].v_type != VAR_STRING) {</a>
<a name="ln4195">    semsg(_(e_string_required_for_argument_nr), idx + 1);</a>
<a name="ln4196">    return FAIL;</a>
<a name="ln4197">  }</a>
<a name="ln4198">  return OK;</a>
<a name="ln4199">}</a>
<a name="ln4200"> </a>
<a name="ln4201">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a non-empty string.</a>
<a name="ln4202">int tv_check_for_nonempty_string_arg(const typval_T *const args, const int idx)</a>
<a name="ln4203">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4204">{</a>
<a name="ln4205">  if (tv_check_for_string_arg(args, idx) == FAIL) {</a>
<a name="ln4206">    return FAIL;</a>
<a name="ln4207">  }</a>
<a name="ln4208">  if (args[idx].vval.v_string == NULL || *args[idx].vval.v_string == NUL) {</a>
<a name="ln4209">    semsg(_(e_non_empty_string_required_for_argument_nr), idx + 1);</a>
<a name="ln4210">    return FAIL;</a>
<a name="ln4211">  }</a>
<a name="ln4212">  return OK;</a>
<a name="ln4213">}</a>
<a name="ln4214"> </a>
<a name="ln4215">/// Check for an optional string argument at &quot;idx&quot;</a>
<a name="ln4216">int tv_check_for_opt_string_arg(const typval_T *const args, const int idx)</a>
<a name="ln4217">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4218">{</a>
<a name="ln4219">  return (args[idx].v_type == VAR_UNKNOWN</a>
<a name="ln4220">          || tv_check_for_string_arg(args, idx) != FAIL) ? OK : FAIL;</a>
<a name="ln4221">}</a>
<a name="ln4222"> </a>
<a name="ln4223">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a number.</a>
<a name="ln4224">int tv_check_for_number_arg(const typval_T *const args, const int idx)</a>
<a name="ln4225">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4226">{</a>
<a name="ln4227">  if (args[idx].v_type != VAR_NUMBER) {</a>
<a name="ln4228">    semsg(_(e_number_required_for_argument_nr), idx + 1);</a>
<a name="ln4229">    return FAIL;</a>
<a name="ln4230">  }</a>
<a name="ln4231">  return OK;</a>
<a name="ln4232">}</a>
<a name="ln4233"> </a>
<a name="ln4234">/// Check for an optional number argument at &quot;idx&quot;</a>
<a name="ln4235">int tv_check_for_opt_number_arg(const typval_T *const args, const int idx)</a>
<a name="ln4236">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4237">{</a>
<a name="ln4238">  return (args[idx].v_type == VAR_UNKNOWN</a>
<a name="ln4239">          || tv_check_for_number_arg(args, idx) != FAIL) ? OK : FAIL;</a>
<a name="ln4240">}</a>
<a name="ln4241"> </a>
<a name="ln4242">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a float or a number.</a>
<a name="ln4243">int tv_check_for_float_or_nr_arg(const typval_T *const args, const int idx)</a>
<a name="ln4244">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4245">{</a>
<a name="ln4246">  if (args[idx].v_type != VAR_FLOAT &amp;&amp; args[idx].v_type != VAR_NUMBER) {</a>
<a name="ln4247">    semsg(_(e_float_or_number_required_for_argument_nr), idx + 1);</a>
<a name="ln4248">    return FAIL;</a>
<a name="ln4249">  }</a>
<a name="ln4250">  return OK;</a>
<a name="ln4251">}</a>
<a name="ln4252"> </a>
<a name="ln4253">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a bool.</a>
<a name="ln4254">int tv_check_for_bool_arg(const typval_T *const args, const int idx)</a>
<a name="ln4255">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4256">{</a>
<a name="ln4257">  if (args[idx].v_type != VAR_BOOL</a>
<a name="ln4258">      &amp;&amp; !(args[idx].v_type == VAR_NUMBER</a>
<a name="ln4259">           &amp;&amp; (args[idx].vval.v_number == 0</a>
<a name="ln4260">               || args[idx].vval.v_number == 1))) {</a>
<a name="ln4261">    semsg(_(e_bool_required_for_argument_nr), idx + 1);</a>
<a name="ln4262">    return FAIL;</a>
<a name="ln4263">  }</a>
<a name="ln4264">  return OK;</a>
<a name="ln4265">}</a>
<a name="ln4266"> </a>
<a name="ln4267">/// Check for an optional bool argument at &quot;idx&quot;.</a>
<a name="ln4268">/// Return FAIL if the type is wrong.</a>
<a name="ln4269">int tv_check_for_opt_bool_arg(const typval_T *const args, const int idx)</a>
<a name="ln4270">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4271">{</a>
<a name="ln4272">  if (args[idx].v_type == VAR_UNKNOWN) {</a>
<a name="ln4273">    return OK;</a>
<a name="ln4274">  }</a>
<a name="ln4275">  return tv_check_for_bool_arg(args, idx);</a>
<a name="ln4276">}</a>
<a name="ln4277"> </a>
<a name="ln4278">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a blob.</a>
<a name="ln4279">int tv_check_for_blob_arg(const typval_T *const args, const int idx)</a>
<a name="ln4280">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4281">{</a>
<a name="ln4282">  if (args[idx].v_type != VAR_BLOB) {</a>
<a name="ln4283">    semsg(_(e_blob_required_for_argument_nr), idx + 1);</a>
<a name="ln4284">    return FAIL;</a>
<a name="ln4285">  }</a>
<a name="ln4286">  return OK;</a>
<a name="ln4287">}</a>
<a name="ln4288"> </a>
<a name="ln4289">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a list.</a>
<a name="ln4290">int tv_check_for_list_arg(const typval_T *const args, const int idx)</a>
<a name="ln4291">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4292">{</a>
<a name="ln4293">  if (args[idx].v_type != VAR_LIST) {</a>
<a name="ln4294">    semsg(_(e_list_required_for_argument_nr), idx + 1);</a>
<a name="ln4295">    return FAIL;</a>
<a name="ln4296">  }</a>
<a name="ln4297">  return OK;</a>
<a name="ln4298">}</a>
<a name="ln4299"> </a>
<a name="ln4300">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a dict.</a>
<a name="ln4301">int tv_check_for_dict_arg(const typval_T *const args, const int idx)</a>
<a name="ln4302">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4303">{</a>
<a name="ln4304">  if (args[idx].v_type != VAR_DICT) {</a>
<a name="ln4305">    semsg(_(e_dict_required_for_argument_nr), idx + 1);</a>
<a name="ln4306">    return FAIL;</a>
<a name="ln4307">  }</a>
<a name="ln4308">  return OK;</a>
<a name="ln4309">}</a>
<a name="ln4310"> </a>
<a name="ln4311">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a non-NULL dict.</a>
<a name="ln4312">int tv_check_for_nonnull_dict_arg(const typval_T *const args, const int idx)</a>
<a name="ln4313">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4314">{</a>
<a name="ln4315">  if (tv_check_for_dict_arg(args, idx) == FAIL) {</a>
<a name="ln4316">    return FAIL;</a>
<a name="ln4317">  }</a>
<a name="ln4318">  if (args[idx].vval.v_dict == NULL) {</a>
<a name="ln4319">    semsg(_(e_non_null_dict_required_for_argument_nr), idx + 1);</a>
<a name="ln4320">    return FAIL;</a>
<a name="ln4321">  }</a>
<a name="ln4322">  return OK;</a>
<a name="ln4323">}</a>
<a name="ln4324"> </a>
<a name="ln4325">/// Check for an optional dict argument at &quot;idx&quot;</a>
<a name="ln4326">int tv_check_for_opt_dict_arg(const typval_T *const args, const int idx)</a>
<a name="ln4327">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4328">{</a>
<a name="ln4329">  return (args[idx].v_type == VAR_UNKNOWN</a>
<a name="ln4330">          || tv_check_for_dict_arg(args, idx) != FAIL) ? OK : FAIL;</a>
<a name="ln4331">}</a>
<a name="ln4332"> </a>
<a name="ln4333">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string or</a>
<a name="ln4334">/// a number.</a>
<a name="ln4335">int tv_check_for_string_or_number_arg(const typval_T *const args, const int idx)</a>
<a name="ln4336">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4337">{</a>
<a name="ln4338">  if (args[idx].v_type != VAR_STRING &amp;&amp; args[idx].v_type != VAR_NUMBER) {</a>
<a name="ln4339">    semsg(_(e_string_or_number_required_for_argument_nr), idx + 1);</a>
<a name="ln4340">    return FAIL;</a>
<a name="ln4341">  }</a>
<a name="ln4342">  return OK;</a>
<a name="ln4343">}</a>
<a name="ln4344"> </a>
<a name="ln4345">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string or a list.</a>
<a name="ln4346">int tv_check_for_string_or_list_arg(const typval_T *const args, const int idx)</a>
<a name="ln4347">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4348">{</a>
<a name="ln4349">  if (args[idx].v_type != VAR_STRING &amp;&amp; args[idx].v_type != VAR_LIST) {</a>
<a name="ln4350">    semsg(_(e_string_or_list_required_for_argument_nr), idx + 1);</a>
<a name="ln4351">    return FAIL;</a>
<a name="ln4352">  }</a>
<a name="ln4353">  return OK;</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string, a list or a blob.</a>
<a name="ln4357">int tv_check_for_string_or_list_or_blob_arg(const typval_T *const args, const int idx)</a>
<a name="ln4358">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4359">{</a>
<a name="ln4360">  if (args[idx].v_type != VAR_STRING</a>
<a name="ln4361">      &amp;&amp; args[idx].v_type != VAR_LIST</a>
<a name="ln4362">      &amp;&amp; args[idx].v_type != VAR_BLOB) {</a>
<a name="ln4363">    semsg(_(e_string_list_or_blob_required_for_argument_nr), idx + 1);</a>
<a name="ln4364">    return FAIL;</a>
<a name="ln4365">  }</a>
<a name="ln4366">  return OK;</a>
<a name="ln4367">}</a>
<a name="ln4368"> </a>
<a name="ln4369">/// Check for an optional string or list argument at &quot;idx&quot;</a>
<a name="ln4370">int tv_check_for_opt_string_or_list_arg(const typval_T *const args, const int idx)</a>
<a name="ln4371">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4372">{</a>
<a name="ln4373">  return (args[idx].v_type == VAR_UNKNOWN</a>
<a name="ln4374">          || tv_check_for_string_or_list_arg(args, idx) != FAIL) ? OK : FAIL;</a>
<a name="ln4375">}</a>
<a name="ln4376"> </a>
<a name="ln4377">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a string</a>
<a name="ln4378">/// or a function reference.</a>
<a name="ln4379">int tv_check_for_string_or_func_arg(const typval_T *const args, const int idx)</a>
<a name="ln4380">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4381">{</a>
<a name="ln4382">  if (args[idx].v_type != VAR_PARTIAL</a>
<a name="ln4383">      &amp;&amp; args[idx].v_type != VAR_FUNC</a>
<a name="ln4384">      &amp;&amp; args[idx].v_type != VAR_STRING) {</a>
<a name="ln4385">    semsg(_(e_string_or_function_required_for_argument_nr), idx + 1);</a>
<a name="ln4386">    return FAIL;</a>
<a name="ln4387">  }</a>
<a name="ln4388">  return OK;</a>
<a name="ln4389">}</a>
<a name="ln4390"> </a>
<a name="ln4391">/// Give an error and return FAIL unless &quot;args[idx]&quot; is a list or a blob.</a>
<a name="ln4392">int tv_check_for_list_or_blob_arg(const typval_T *const args, const int idx)</a>
<a name="ln4393">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE</a>
<a name="ln4394">{</a>
<a name="ln4395">  if (args[idx].v_type != VAR_LIST &amp;&amp; args[idx].v_type != VAR_BLOB) {</a>
<a name="ln4396">    semsg(_(e_list_or_blob_required_for_argument_nr), idx + 1);</a>
<a name="ln4397">    return FAIL;</a>
<a name="ln4398">  }</a>
<a name="ln4399">  return OK;</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402">/// Get the string value of a &quot;stringish&quot; Vimscript object.</a>
<a name="ln4403">///</a>
<a name="ln4404">/// @param[in]  tv  Object to get value of.</a>
<a name="ln4405">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln4406">///              string. When function encounters one of these stringified value</a>
<a name="ln4407">///              will be written to buf and buf will be returned.</a>
<a name="ln4408">///</a>
<a name="ln4409">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln4410">///</a>
<a name="ln4411">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln4412">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln4413">const char *tv_get_string_buf_chk(const typval_T *const tv, char *const buf)</a>
<a name="ln4414">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4415">{</a>
<a name="ln4416">  switch (tv-&gt;v_type) {</a>
<a name="ln4417">  case VAR_NUMBER:</a>
<a name="ln4418">    snprintf(buf, NUMBUFLEN, &quot;%&quot; PRIdVARNUMBER, tv-&gt;vval.v_number);  // -V576</a>
<a name="ln4419">    return buf;</a>
<a name="ln4420">  case VAR_FLOAT:</a>
<a name="ln4421">    vim_snprintf(buf, NUMBUFLEN, &quot;%g&quot;, tv-&gt;vval.v_float);</a>
<a name="ln4422">    return buf;</a>
<a name="ln4423">  case VAR_STRING:</a>
<a name="ln4424">    if (tv-&gt;vval.v_string != NULL) {</a>
<a name="ln4425">      return tv-&gt;vval.v_string;</a>
<a name="ln4426">    }</a>
<a name="ln4427">    return &quot;&quot;;</a>
<a name="ln4428">  case VAR_BOOL:</a>
<a name="ln4429">    STRCPY(buf, encode_bool_var_names[tv-&gt;vval.v_bool]);</a>
<a name="ln4430">    return buf;</a>
<a name="ln4431">  case VAR_SPECIAL:</a>
<a name="ln4432">    STRCPY(buf, encode_special_var_names[tv-&gt;vval.v_special]);</a>
<a name="ln4433">    return buf;</a>
<a name="ln4434">  case VAR_PARTIAL:</a>
<a name="ln4435">  case VAR_FUNC:</a>
<a name="ln4436">  case VAR_LIST:</a>
<a name="ln4437">  case VAR_DICT:</a>
<a name="ln4438">  case VAR_BLOB:</a>
<a name="ln4439">  case VAR_UNKNOWN:</a>
<a name="ln4440">    emsg(_(str_errors[tv-&gt;v_type]));</a>
<a name="ln4441">    return NULL;</a>
<a name="ln4442">  }</a>
<a name="ln4443">  abort();</a>
<a name="ln4444">  return NULL;</a>
<a name="ln4445">}</a>
<a name="ln4446"> </a>
<a name="ln4447">/// Get the string value of a &quot;stringish&quot; Vimscript object.</a>
<a name="ln4448">///</a>
<a name="ln4449">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln4450">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln4451">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln4452">///          calling it again.</a>
<a name="ln4453">///</a>
<a name="ln4454">/// @param[in]  tv  Object to get value of.</a>
<a name="ln4455">///</a>
<a name="ln4456">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln4457">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or NULL.</a>
<a name="ln4458">const char *tv_get_string_chk(const typval_T *const tv)</a>
<a name="ln4459">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4460">{</a>
<a name="ln4461">  static char mybuf[NUMBUFLEN];</a>
<a name="ln4462"> </a>
<a name="ln4463">  return tv_get_string_buf_chk(tv, mybuf);</a>
<a name="ln4464">}</a>
<a name="ln4465"> </a>
<a name="ln4466">/// Get the string value of a &quot;stringish&quot; Vimscript object.</a>
<a name="ln4467">///</a>
<a name="ln4468">/// @warning For number and special values it uses a single, static buffer. It</a>
<a name="ln4469">///          may be used only once, next call to tv_get_string may reuse it. Use</a>
<a name="ln4470">///          tv_get_string_buf() if you need to use tv_get_string() output after</a>
<a name="ln4471">///          calling it again.</a>
<a name="ln4472">///</a>
<a name="ln4473">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln4474">///       return NULL on error.</a>
<a name="ln4475">///</a>
<a name="ln4476">/// @param[in]  tv  Object to get value of.</a>
<a name="ln4477">///</a>
<a name="ln4478">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln4479">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln4480">///         string.</a>
<a name="ln4481">const char *tv_get_string(const typval_T *const tv)</a>
<a name="ln4482">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4483">{</a>
<a name="ln4484">  static char mybuf[NUMBUFLEN];</a>
<a name="ln4485">  return tv_get_string_buf((typval_T *)tv, mybuf);</a>
<a name="ln4486">}</a>
<a name="ln4487"> </a>
<a name="ln4488">/// Get the string value of a &quot;stringish&quot; Vimscript object.</a>
<a name="ln4489">///</a>
<a name="ln4490">/// @note tv_get_string_chk() and tv_get_string_buf_chk() are similar, but</a>
<a name="ln4491">///       return NULL on error.</a>
<a name="ln4492">///</a>
<a name="ln4493">/// @param[in]  tv  Object to get value of.</a>
<a name="ln4494">/// @param  buf  Buffer used to hold numbers and special variables converted to</a>
<a name="ln4495">///              string. When function encounters one of these stringified value</a>
<a name="ln4496">///              will be written to buf and buf will be returned.</a>
<a name="ln4497">///</a>
<a name="ln4498">///              Buffer must have NUMBUFLEN size.</a>
<a name="ln4499">///</a>
<a name="ln4500">/// @return Object value if it is VAR_STRING object, number converted to</a>
<a name="ln4501">///         a string for VAR_NUMBER, v: variable name for VAR_SPECIAL or empty</a>
<a name="ln4502">///         string.</a>
<a name="ln4503">const char *tv_get_string_buf(const typval_T *const tv, char *const buf)</a>
<a name="ln4504">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4505">{</a>
<a name="ln4506">  const char *const res = tv_get_string_buf_chk(tv, buf);</a>
<a name="ln4507"> </a>
<a name="ln4508">  return res != NULL ? res : &quot;&quot;;</a>
<a name="ln4509">}</a>
<a name="ln4510"> </a>
<a name="ln4511">/// Return true when &quot;tv&quot; is not falsy: non-zero, non-empty string, non-empty</a>
<a name="ln4512">/// list, etc.  Mostly like what JavaScript does, except that empty list and</a>
<a name="ln4513">/// empty dictionary are false.</a>
<a name="ln4514">bool tv2bool(const typval_T *const tv)</a>
<a name="ln4515">{</a>
<a name="ln4516">  switch (tv-&gt;v_type) {</a>
<a name="ln4517">  case VAR_NUMBER:</a>
<a name="ln4518">    return tv-&gt;vval.v_number != 0;</a>
<a name="ln4519">  case VAR_FLOAT:</a>
<a name="ln4520">    return tv-&gt;vval.v_float != 0.0;</a>
<a name="ln4521">  case VAR_PARTIAL:</a>
<a name="ln4522">    return tv-&gt;vval.v_partial != NULL;</a>
<a name="ln4523">  case VAR_FUNC:</a>
<a name="ln4524">  case VAR_STRING:</a>
<a name="ln4525">    return tv-&gt;vval.v_string != NULL &amp;&amp; *tv-&gt;vval.v_string != NUL;</a>
<a name="ln4526">  case VAR_LIST:</a>
<a name="ln4527">    return tv-&gt;vval.v_list != NULL &amp;&amp; tv-&gt;vval.v_list-&gt;lv_len &gt; 0;</a>
<a name="ln4528">  case VAR_DICT:</a>
<a name="ln4529">    return tv-&gt;vval.v_dict != NULL &amp;&amp; tv-&gt;vval.v_dict-&gt;dv_hashtab.ht_used &gt; 0;</a>
<a name="ln4530">  case VAR_BOOL:</a>
<a name="ln4531">    return tv-&gt;vval.v_bool == kBoolVarTrue;</a>
<a name="ln4532">  case VAR_SPECIAL:</a>
<a name="ln4533">    return tv-&gt;vval.v_special != kSpecialVarNull;</a>
<a name="ln4534">  case VAR_BLOB:</a>
<a name="ln4535">    return tv-&gt;vval.v_blob != NULL &amp;&amp; tv-&gt;vval.v_blob-&gt;bv_ga.ga_len &gt; 0;</a>
<a name="ln4536">  case VAR_UNKNOWN:</a>
<a name="ln4537">    break;</a>
<a name="ln4538">  }</a>
<a name="ln4539">  return false;</a>
<a name="ln4540">}</a>
</code></pre>
<div class="balloon" rel="1283"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!info-&gt;item_compare_func_err' is always true.</p></div>
<div class="balloon" rel="1293"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'info-&gt;item_compare_func_err' is always false.</p></div>
<div class="balloon" rel="1323"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'info-&gt;item_compare_func_err' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>