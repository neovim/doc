<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>helpers.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;msgpack/unpack.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;klib/kvec.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln20">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/garray.h&quot;</a>
<a name="ln26">#include &quot;nvim/globals.h&quot;</a>
<a name="ln27">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln28">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln29">#include &quot;nvim/map.h&quot;</a>
<a name="ln30">#include &quot;nvim/mark.h&quot;</a>
<a name="ln31">#include &quot;nvim/memline.h&quot;</a>
<a name="ln32">#include &quot;nvim/memory.h&quot;</a>
<a name="ln33">#include &quot;nvim/message.h&quot;</a>
<a name="ln34">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln35">#include &quot;nvim/pos.h&quot;</a>
<a name="ln36">#include &quot;nvim/types.h&quot;</a>
<a name="ln37">#include &quot;nvim/ui.h&quot;</a>
<a name="ln38">#include &quot;nvim/version.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln41"># include &quot;api/private/funcs_metadata.generated.h&quot;</a>
<a name="ln42"># include &quot;api/private/helpers.c.generated.h&quot;</a>
<a name="ln43"># include &quot;api/private/ui_events_metadata.generated.h&quot;</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">/// Start block that may cause Vimscript exceptions while evaluating another code</a>
<a name="ln47">///</a>
<a name="ln48">/// Used when caller is supposed to be operating when other Vimscript code is being</a>
<a name="ln49">/// processed and that “other Vimscript code” must not be affected.</a>
<a name="ln50">///</a>
<a name="ln51">/// @param[out]  tstate  Location where try state should be saved.</a>
<a name="ln52">void try_enter(TryState *const tstate)</a>
<a name="ln53">{</a>
<a name="ln54">  // TODO(ZyX-I): Check whether try_enter()/try_leave() may use</a>
<a name="ln55">  //              enter_cleanup()/leave_cleanup(). Or</a>
<a name="ln56">  //              save_dbg_stuff()/restore_dbg_stuff().</a>
<a name="ln57">  *tstate = (TryState) {</a>
<a name="ln58">    .current_exception = current_exception,</a>
<a name="ln59">    .msg_list = (const msglist_T *const *)msg_list,</a>
<a name="ln60">    .private_msg_list = NULL,</a>
<a name="ln61">    .trylevel = trylevel,</a>
<a name="ln62">    .got_int = got_int,</a>
<a name="ln63">    .did_throw = did_throw,</a>
<a name="ln64">    .need_rethrow = need_rethrow,</a>
<a name="ln65">    .did_emsg = did_emsg,</a>
<a name="ln66">  };</a>
<a name="ln67">  msg_list = &amp;tstate-&gt;private_msg_list;</a>
<a name="ln68">  current_exception = NULL;</a>
<a name="ln69">  trylevel = 1;</a>
<a name="ln70">  got_int = false;</a>
<a name="ln71">  did_throw = false;</a>
<a name="ln72">  need_rethrow = false;</a>
<a name="ln73">  did_emsg = false;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">/// End try block, set the error message if any and restore previous state</a>
<a name="ln77">///</a>
<a name="ln78">/// @warning Return is consistent with most functions (false on error), not with</a>
<a name="ln79">///          try_end (true on error).</a>
<a name="ln80">///</a>
<a name="ln81">/// @param[in]  tstate  Previous state to restore.</a>
<a name="ln82">/// @param[out]  err  Location where error should be saved.</a>
<a name="ln83">///</a>
<a name="ln84">/// @return false if error occurred, true otherwise.</a>
<a name="ln85">bool try_leave(const TryState *const tstate, Error *const err)</a>
<a name="ln86">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln87">{</a>
<a name="ln88">  const bool ret = !try_end(err);</a>
<a name="ln89">  assert(trylevel == 0);</a>
<a name="ln90">  assert(!need_rethrow);</a>
<a name="ln91">  assert(!got_int);</a>
<a name="ln92">  assert(!did_throw);</a>
<a name="ln93">  assert(!did_emsg);</a>
<a name="ln94">  assert(msg_list == &amp;tstate-&gt;private_msg_list);</a>
<a name="ln95">  assert(*msg_list == NULL);</a>
<a name="ln96">  assert(current_exception == NULL);</a>
<a name="ln97">  msg_list = (msglist_T **)tstate-&gt;msg_list;</a>
<a name="ln98">  current_exception = tstate-&gt;current_exception;</a>
<a name="ln99">  trylevel = tstate-&gt;trylevel;</a>
<a name="ln100">  got_int = tstate-&gt;got_int;</a>
<a name="ln101">  did_throw = tstate-&gt;did_throw;</a>
<a name="ln102">  need_rethrow = tstate-&gt;need_rethrow;</a>
<a name="ln103">  did_emsg = tstate-&gt;did_emsg;</a>
<a name="ln104">  return ret;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">/// Start block that may cause vimscript exceptions</a>
<a name="ln108">///</a>
<a name="ln109">/// Each try_start() call should be mirrored by try_end() call.</a>
<a name="ln110">///</a>
<a name="ln111">/// To be used as a replacement of `:try … catch … endtry` in C code, in cases</a>
<a name="ln112">/// when error flag could not already be set. If there may be pending error</a>
<a name="ln113">/// state at the time try_start() is executed which needs to be preserved,</a>
<a name="ln114">/// try_enter()/try_leave() pair should be used instead.</a>
<a name="ln115">void try_start(void)</a>
<a name="ln116">{</a>
<a name="ln117">  trylevel++;</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">/// End try block, set the error message if any and return true if an error</a>
<a name="ln121">/// occurred.</a>
<a name="ln122">///</a>
<a name="ln123">/// @param err Pointer to the stack-allocated error object</a>
<a name="ln124">/// @return true if an error occurred</a>
<a name="ln125">bool try_end(Error *err)</a>
<a name="ln126">{</a>
<a name="ln127">  // Note: all globals manipulated here should be saved/restored in</a>
<a name="ln128">  // try_enter/try_leave.</a>
<a name="ln129">  trylevel--;</a>
<a name="ln130"> </a>
<a name="ln131">  // Set by emsg(), affects aborting().  See also enter_cleanup().</a>
<a name="ln132">  did_emsg = false;</a>
<a name="ln133">  force_abort = false;</a>
<a name="ln134"> </a>
<a name="ln135">  if (got_int) {</a>
<a name="ln136">    if (did_throw) {</a>
<a name="ln137">      // If we got an interrupt, discard the current exception</a>
<a name="ln138">      discard_current_exception();</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">    api_set_error(err, kErrorTypeException, &quot;Keyboard interrupt&quot;);</a>
<a name="ln142">    got_int = false;</a>
<a name="ln143">  } else if (msg_list != NULL &amp;&amp; *msg_list != NULL) {</a>
<a name="ln144">    int should_free;</a>
<a name="ln145">    char *msg = get_exception_string(*msg_list,</a>
<a name="ln146">                                     ET_ERROR,</a>
<a name="ln147">                                     NULL,</a>
<a name="ln148">                                     &amp;should_free);</a>
<a name="ln149">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, msg);</a>
<a name="ln150">    free_global_msglist();</a>
<a name="ln151"> </a>
<a name="ln152">    if (should_free) {</a>
<a name="ln153">      xfree(msg);</a>
<a name="ln154">    }</a>
<a name="ln155">  } else if (did_throw) {</a>
<a name="ln156">    if (*current_exception-&gt;throw_name != NUL) {</a>
<a name="ln157">      if (current_exception-&gt;throw_lnum != 0) {</a>
<a name="ln158">        api_set_error(err, kErrorTypeException, &quot;%s, line %&quot; PRIdLINENR &quot;: %s&quot;,</a>
<a name="ln159">                      current_exception-&gt;throw_name, current_exception-&gt;throw_lnum,</a>
<a name="ln160">                      current_exception-&gt;value);</a>
<a name="ln161">      } else {</a>
<a name="ln162">        api_set_error(err, kErrorTypeException, &quot;%s: %s&quot;,</a>
<a name="ln163">                      current_exception-&gt;throw_name, current_exception-&gt;value);</a>
<a name="ln164">      }</a>
<a name="ln165">    } else {</a>
<a name="ln166">      api_set_error(err, kErrorTypeException, &quot;%s&quot;, current_exception-&gt;value);</a>
<a name="ln167">    }</a>
<a name="ln168">    discard_current_exception();</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171">  return ERROR_SET(err);</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/// Recursively expands a vimscript value in a dict</a>
<a name="ln175">///</a>
<a name="ln176">/// @param dict The vimscript dict</a>
<a name="ln177">/// @param key The key</a>
<a name="ln178">/// @param[out] err Details of an error that may have occurred</a>
<a name="ln179">Object dict_get_value(dict_T *dict, String key, Error *err)</a>
<a name="ln180">{</a>
<a name="ln181">  dictitem_T *const di = tv_dict_find(dict, key.data, (ptrdiff_t)key.size);</a>
<a name="ln182"> </a>
<a name="ln183">  if (di == NULL) {</a>
<a name="ln184">    api_set_error(err, kErrorTypeValidation, &quot;Key not found: %s&quot;, key.data);</a>
<a name="ln185">    return (Object)OBJECT_INIT;</a>
<a name="ln186">  }</a>
<a name="ln187"> </a>
<a name="ln188">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">dictitem_T *dict_check_writable(dict_T *dict, String key, bool del, Error *err)</a>
<a name="ln192">{</a>
<a name="ln193">  dictitem_T *di = tv_dict_find(dict, key.data, (ptrdiff_t)key.size);</a>
<a name="ln194"> </a>
<a name="ln195">  if (di != NULL) {</a>
<a name="ln196">    if (di-&gt;di_flags &amp; DI_FLAGS_RO) {</a>
<a name="ln197">      api_set_error(err, kErrorTypeException, &quot;Key is read-only: %s&quot;, key.data);</a>
<a name="ln198">    } else if (di-&gt;di_flags &amp; DI_FLAGS_LOCK) {</a>
<a name="ln199">      api_set_error(err, kErrorTypeException, &quot;Key is locked: %s&quot;, key.data);</a>
<a name="ln200">    } else if (del &amp;&amp; (di-&gt;di_flags &amp; DI_FLAGS_FIX)) {</a>
<a name="ln201">      api_set_error(err, kErrorTypeException, &quot;Key is fixed: %s&quot;, key.data);</a>
<a name="ln202">    }</a>
<a name="ln203">  } else if (dict-&gt;dv_lock) {</a>
<a name="ln204">    api_set_error(err, kErrorTypeException, &quot;Dictionary is locked&quot;);</a>
<a name="ln205">  } else if (key.size == 0) {</a>
<a name="ln206">    api_set_error(err, kErrorTypeValidation, &quot;Key name is empty&quot;);</a>
<a name="ln207">  } else if (key.size &gt; INT_MAX) {</a>
<a name="ln208">    api_set_error(err, kErrorTypeValidation, &quot;Key name is too long&quot;);</a>
<a name="ln209">  }</a>
<a name="ln210"> </a>
<a name="ln211">  return di;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">/// Set a value in a scope dict. Objects are recursively expanded into their</a>
<a name="ln215">/// vimscript equivalents.</a>
<a name="ln216">///</a>
<a name="ln217">/// @param dict The vimscript dict</a>
<a name="ln218">/// @param key The key</a>
<a name="ln219">/// @param value The new value</a>
<a name="ln220">/// @param del Delete key in place of setting it. Argument `value` is ignored in</a>
<a name="ln221">///            this case.</a>
<a name="ln222">/// @param retval If true the old value will be converted and returned.</a>
<a name="ln223">/// @param[out] err Details of an error that may have occurred</a>
<a name="ln224">/// @return The old value if `retval` is true and the key was present, else NIL</a>
<a name="ln225">Object dict_set_var(dict_T *dict, String key, Object value, bool del, bool retval, Error *err)</a>
<a name="ln226">{</a>
<a name="ln227">  Object rv = OBJECT_INIT;</a>
<a name="ln228">  dictitem_T *di = dict_check_writable(dict, key, del, err);</a>
<a name="ln229"> </a>
<a name="ln230">  if (ERROR_SET(err)) {</a>
<a name="ln231">    return rv;</a>
<a name="ln232">  }</a>
<a name="ln233"> </a>
<a name="ln234">  bool watched = tv_dict_is_watched(dict);</a>
<a name="ln235"> </a>
<a name="ln236">  if (del) {</a>
<a name="ln237">    // Delete the key</a>
<a name="ln238">    if (di == NULL) {</a>
<a name="ln239">      // Doesn't exist, fail</a>
<a name="ln240">      api_set_error(err, kErrorTypeValidation, &quot;Key not found: %s&quot;, key.data);</a>
<a name="ln241">    } else {</a>
<a name="ln242">      // Notify watchers</a>
<a name="ln243">      if (watched) {</a>
<a name="ln244">        tv_dict_watcher_notify(dict, key.data, NULL, &amp;di-&gt;di_tv);</a>
<a name="ln245">      }</a>
<a name="ln246">      // Return the old value</a>
<a name="ln247">      if (retval) {</a>
<a name="ln248">        rv = vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln249">      }</a>
<a name="ln250">      // Delete the entry</a>
<a name="ln251">      tv_dict_item_remove(dict, di);</a>
<a name="ln252">    }</a>
<a name="ln253">  } else {</a>
<a name="ln254">    // Update the key</a>
<a name="ln255">    typval_T tv;</a>
<a name="ln256"> </a>
<a name="ln257">    // Convert the object to a vimscript type in the temporary variable</a>
<a name="ln258">    if (!object_to_vim(value, &amp;tv, err)) {</a>
<a name="ln259">      return rv;</a>
<a name="ln260">    }</a>
<a name="ln261"> </a>
<a name="ln262">    typval_T oldtv = TV_INITIAL_VALUE;</a>
<a name="ln263"> </a>
<a name="ln264">    if (di == NULL) {</a>
<a name="ln265">      // Need to create an entry</a>
<a name="ln266">      di = tv_dict_item_alloc_len(key.data, key.size);</a>
<a name="ln267">      tv_dict_add(dict, di);</a>
<a name="ln268">    } else {</a>
<a name="ln269">      // Return the old value</a>
<a name="ln270">      if (retval) {</a>
<a name="ln271">        rv = vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln272">      }</a>
<a name="ln273">      bool type_error = false;</a>
<a name="ln274">      if (dict == &amp;vimvardict</a>
<a name="ln275">          &amp;&amp; !before_set_vvar(key.data, di, &amp;tv, true, watched, &amp;type_error)) {</a>
<a name="ln276">        tv_clear(&amp;tv);</a>
<a name="ln277">        if (type_error) {</a>
<a name="ln278">          api_set_error(err, kErrorTypeValidation,</a>
<a name="ln279">                        &quot;Setting v:%s to value with wrong type&quot;, key.data);</a>
<a name="ln280">        }</a>
<a name="ln281">        return rv;</a>
<a name="ln282">      }</a>
<a name="ln283">      if (watched) {</a>
<a name="ln284">        tv_copy(&amp;di-&gt;di_tv, &amp;oldtv);</a>
<a name="ln285">      }</a>
<a name="ln286">      tv_clear(&amp;di-&gt;di_tv);</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">    // Update the value</a>
<a name="ln290">    tv_copy(&amp;tv, &amp;di-&gt;di_tv);</a>
<a name="ln291"> </a>
<a name="ln292">    // Notify watchers</a>
<a name="ln293">    if (watched) {</a>
<a name="ln294">      tv_dict_watcher_notify(dict, key.data, &amp;tv, &amp;oldtv);</a>
<a name="ln295">      tv_clear(&amp;oldtv);</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">    // Clear the temporary variable</a>
<a name="ln299">    tv_clear(&amp;tv);</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  return rv;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">buf_T *find_buffer_by_handle(Buffer buffer, Error *err)</a>
<a name="ln306">{</a>
<a name="ln307">  if (buffer == 0) {</a>
<a name="ln308">    return curbuf;</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  buf_T *rv = handle_get_buffer(buffer);</a>
<a name="ln312"> </a>
<a name="ln313">  if (!rv) {</a>
<a name="ln314">    api_set_error(err, kErrorTypeValidation, &quot;Invalid buffer id: %d&quot;, buffer);</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317">  return rv;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">win_T *find_window_by_handle(Window window, Error *err)</a>
<a name="ln321">{</a>
<a name="ln322">  if (window == 0) {</a>
<a name="ln323">    return curwin;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  win_T *rv = handle_get_window(window);</a>
<a name="ln327"> </a>
<a name="ln328">  if (!rv) {</a>
<a name="ln329">    api_set_error(err, kErrorTypeValidation, &quot;Invalid window id: %d&quot;, window);</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  return rv;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">tabpage_T *find_tab_by_handle(Tabpage tabpage, Error *err)</a>
<a name="ln336">{</a>
<a name="ln337">  if (tabpage == 0) {</a>
<a name="ln338">    return curtab;</a>
<a name="ln339">  }</a>
<a name="ln340"> </a>
<a name="ln341">  tabpage_T *rv = handle_get_tabpage(tabpage);</a>
<a name="ln342"> </a>
<a name="ln343">  if (!rv) {</a>
<a name="ln344">    api_set_error(err, kErrorTypeValidation, &quot;Invalid tabpage id: %d&quot;, tabpage);</a>
<a name="ln345">  }</a>
<a name="ln346"> </a>
<a name="ln347">  return rv;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">/// Allocates a String consisting of a single char. Does not support multibyte</a>
<a name="ln351">/// characters. The resulting string is also NUL-terminated, to facilitate</a>
<a name="ln352">/// interoperating with code using C strings.</a>
<a name="ln353">///</a>
<a name="ln354">/// @param char the char to convert</a>
<a name="ln355">/// @return the resulting String, if the input char was NUL, an</a>
<a name="ln356">///         empty String is returned</a>
<a name="ln357">String cchar_to_string(char c)</a>
<a name="ln358">{</a>
<a name="ln359">  char buf[] = { c, NUL };</a>
<a name="ln360">  return (String){</a>
<a name="ln361">    .data = xmemdupz(buf, 1),</a>
<a name="ln362">    .size = (c != NUL) ? 1 : 0</a>
<a name="ln363">  };</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">/// Copies a C string into a String (binary safe string, characters + length).</a>
<a name="ln367">/// The resulting string is also NUL-terminated, to facilitate interoperating</a>
<a name="ln368">/// with code using C strings.</a>
<a name="ln369">///</a>
<a name="ln370">/// @param str the C string to copy</a>
<a name="ln371">/// @return the resulting String, if the input string was NULL, an</a>
<a name="ln372">///         empty String is returned</a>
<a name="ln373">String cstr_to_string(const char *str)</a>
<a name="ln374">{</a>
<a name="ln375">  if (str == NULL) {</a>
<a name="ln376">    return (String)STRING_INIT;</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  size_t len = strlen(str);</a>
<a name="ln380">  return (String){</a>
<a name="ln381">    .data = xmemdupz(str, len),</a>
<a name="ln382">    .size = len,</a>
<a name="ln383">  };</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">/// Copies a String to an allocated, NUL-terminated C string.</a>
<a name="ln387">///</a>
<a name="ln388">/// @param str the String to copy</a>
<a name="ln389">/// @return the resulting C string</a>
<a name="ln390">char *string_to_cstr(String str)</a>
<a name="ln391">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln392">{</a>
<a name="ln393">  return xstrndup(str.data, str.size);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/// Copies buffer to an allocated String.</a>
<a name="ln397">/// The resulting string is also NUL-terminated, to facilitate interoperating</a>
<a name="ln398">/// with code using C strings.</a>
<a name="ln399">///</a>
<a name="ln400">/// @param buf the buffer to copy</a>
<a name="ln401">/// @param size length of the buffer</a>
<a name="ln402">/// @return the resulting String, if the input string was NULL, an</a>
<a name="ln403">///         empty String is returned</a>
<a name="ln404">String cbuf_to_string(const char *buf, size_t size)</a>
<a name="ln405">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln406">{</a>
<a name="ln407">  return (String){</a>
<a name="ln408">    .data = xmemdupz(buf, size),</a>
<a name="ln409">    .size = size</a>
<a name="ln410">  };</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">String cstrn_to_string(const char *str, size_t maxsize)</a>
<a name="ln414">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln415">{</a>
<a name="ln416">  return cbuf_to_string(str, strnlen(str, maxsize));</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">String cstrn_as_string(char *str, size_t maxsize)</a>
<a name="ln420">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln421">{</a>
<a name="ln422">  return cbuf_as_string(str, strnlen(str, maxsize));</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">/// Creates a String using the given C string. Unlike</a>
<a name="ln426">/// cstr_to_string this function DOES NOT copy the C string.</a>
<a name="ln427">///</a>
<a name="ln428">/// @param str the C string to use</a>
<a name="ln429">/// @return The resulting String, or an empty String if</a>
<a name="ln430">///           str was NULL</a>
<a name="ln431">String cstr_as_string(char *str) FUNC_ATTR_PURE</a>
<a name="ln432">{</a>
<a name="ln433">  if (str == NULL) {</a>
<a name="ln434">    return (String)STRING_INIT;</a>
<a name="ln435">  }</a>
<a name="ln436">  return (String){ .data = str, .size = strlen(str) };</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">/// Return the owned memory of a ga as a String</a>
<a name="ln440">///</a>
<a name="ln441">/// Reinitializes the ga to a valid empty state.</a>
<a name="ln442">String ga_take_string(garray_T *ga)</a>
<a name="ln443">{</a>
<a name="ln444">  String str = { .data = (char *)ga-&gt;ga_data, .size = (size_t)ga-&gt;ga_len };</a>
<a name="ln445">  ga-&gt;ga_data = NULL;</a>
<a name="ln446">  ga-&gt;ga_len = 0;</a>
<a name="ln447">  ga-&gt;ga_maxlen = 0;</a>
<a name="ln448">  return str;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">/// Creates &quot;readfile()-style&quot; ArrayOf(String) from a binary string.</a>
<a name="ln452">///</a>
<a name="ln453">/// - Lines break at \n (NL/LF/line-feed).</a>
<a name="ln454">/// - NUL bytes are replaced with NL.</a>
<a name="ln455">/// - If the last byte is a linebreak an extra empty list item is added.</a>
<a name="ln456">///</a>
<a name="ln457">/// @param input  Binary string</a>
<a name="ln458">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln459">/// @return [allocated] String array</a>
<a name="ln460">Array string_to_array(const String input, bool crlf)</a>
<a name="ln461">{</a>
<a name="ln462">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln463">  for (size_t i = 0; i &lt; input.size; i++) {</a>
<a name="ln464">    const char *start = input.data + i;</a>
<a name="ln465">    const char *end = start;</a>
<a name="ln466">    size_t line_len = 0;</a>
<a name="ln467">    for (; line_len &lt; input.size - i; line_len++) {</a>
<a name="ln468">      end = start + line_len;</a>
<a name="ln469">      if (*end == NL || (crlf &amp;&amp; *end == CAR)) {</a>
<a name="ln470">        break;</a>
<a name="ln471">      }</a>
<a name="ln472">    }</a>
<a name="ln473">    i += line_len;</a>
<a name="ln474">    if (crlf &amp;&amp; *end == CAR &amp;&amp; i + 1 &lt; input.size &amp;&amp; *(end + 1) == NL) {</a>
<a name="ln475">      i += 1;  // Advance past CRLF.</a>
<a name="ln476">    }</a>
<a name="ln477">    String s = {</a>
<a name="ln478">      .size = line_len,</a>
<a name="ln479">      .data = xmemdupz(start, line_len),</a>
<a name="ln480">    };</a>
<a name="ln481">    memchrsub(s.data, NUL, NL, line_len);</a>
<a name="ln482">    ADD(ret, STRING_OBJ(s));</a>
<a name="ln483">    // If line ends at end-of-buffer, add empty final item.</a>
<a name="ln484">    // This is &quot;readfile()-style&quot;, see also &quot;:help channel-lines&quot;.</a>
<a name="ln485">    if (i + 1 == input.size &amp;&amp; (*end == NL || (crlf &amp;&amp; *end == CAR))) {</a>
<a name="ln486">      ADD(ret, STRING_OBJ(STRING_INIT));</a>
<a name="ln487">    }</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  return ret;</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">/// Normalizes 0-based indexes to buffer line numbers.</a>
<a name="ln494">int64_t normalize_index(buf_T *buf, int64_t index, bool end_exclusive, bool *oob)</a>
<a name="ln495">{</a>
<a name="ln496">  assert(buf-&gt;b_ml.ml_line_count &gt; 0);</a>
<a name="ln497">  int64_t max_index = buf-&gt;b_ml.ml_line_count + (int)end_exclusive - 1;</a>
<a name="ln498">  // A negative index counts from the bottom.</a>
<a name="ln499">  index = index &lt; 0 ? max_index + index + 1 : index;</a>
<a name="ln500"> </a>
<a name="ln501">  // Check for oob and clamp.</a>
<a name="ln502">  if (index &gt; max_index) {</a>
<a name="ln503">    *oob = true;</a>
<a name="ln504">    index = max_index;</a>
<a name="ln505">  } else if (index &lt; 0) {</a>
<a name="ln506">    *oob = true;</a>
<a name="ln507">    index = 0;</a>
<a name="ln508">  }</a>
<a name="ln509">  // Convert the index to a 1-based line number.</a>
<a name="ln510">  index++;</a>
<a name="ln511">  return index;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/// Returns a substring of a buffer line</a>
<a name="ln515">///</a>
<a name="ln516">/// @param buf          Buffer handle</a>
<a name="ln517">/// @param lnum         Line number (1-based)</a>
<a name="ln518">/// @param start_col    Starting byte offset into line (0-based)</a>
<a name="ln519">/// @param end_col      Ending byte offset into line (0-based, exclusive)</a>
<a name="ln520">/// @param err          Error object</a>
<a name="ln521">/// @return The text between start_col and end_col on line lnum of buffer buf</a>
<a name="ln522">String buf_get_text(buf_T *buf, int64_t lnum, int64_t start_col, int64_t end_col, Error *err)</a>
<a name="ln523">{</a>
<a name="ln524">  String rv = STRING_INIT;</a>
<a name="ln525"> </a>
<a name="ln526">  if (lnum &gt;= MAXLNUM) {</a>
<a name="ln527">    api_set_error(err, kErrorTypeValidation, &quot;Line index is too high&quot;);</a>
<a name="ln528">    return rv;</a>
<a name="ln529">  }</a>
<a name="ln530"> </a>
<a name="ln531">  char *bufstr = ml_get_buf(buf, (linenr_T)lnum);</a>
<a name="ln532">  size_t line_length = strlen(bufstr);</a>
<a name="ln533"> </a>
<a name="ln534">  start_col = start_col &lt; 0 ? (int64_t)line_length + start_col + 1 : start_col;</a>
<a name="ln535">  end_col = end_col &lt; 0 ? (int64_t)line_length + end_col + 1 : end_col;</a>
<a name="ln536"> </a>
<a name="ln537">  if (start_col &gt;= MAXCOL || end_col &gt;= MAXCOL) {</a>
<a name="ln538">    api_set_error(err, kErrorTypeValidation, &quot;Column index is too high&quot;);</a>
<a name="ln539">    return rv;</a>
<a name="ln540">  }</a>
<a name="ln541"> </a>
<a name="ln542">  if (start_col &gt; end_col) {</a>
<a name="ln543">    api_set_error(err, kErrorTypeValidation, &quot;start_col must be less than end_col&quot;);</a>
<a name="ln544">    return rv;</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">  if ((size_t)start_col &gt;= line_length) {</a>
<a name="ln548">    return rv;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  return cstrn_as_string(&amp;bufstr[start_col], (size_t)(end_col - start_col));</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">void api_free_string(String value)</a>
<a name="ln555">{</a>
<a name="ln556">  if (!value.data) {</a>
<a name="ln557">    return;</a>
<a name="ln558">  }</a>
<a name="ln559"> </a>
<a name="ln560">  xfree(value.data);</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">Array arena_array(Arena *arena, size_t max_size)</a>
<a name="ln564">{</a>
<a name="ln565">  Array arr = ARRAY_DICT_INIT;</a>
<a name="ln566">  kv_fixsize_arena(arena, arr, max_size);</a>
<a name="ln567">  return arr;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">Dictionary arena_dict(Arena *arena, size_t max_size)</a>
<a name="ln571">{</a>
<a name="ln572">  Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln573">  kv_fixsize_arena(arena, dict, max_size);</a>
<a name="ln574">  return dict;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">String arena_string(Arena *arena, String str)</a>
<a name="ln578">{</a>
<a name="ln579">  if (str.size) {</a>
<a name="ln580">    return cbuf_as_string(arena_memdupz(arena, str.data, str.size), str.size);</a>
<a name="ln581">  } else {</a>
<a name="ln582">    return (String)STRING_INIT;</a>
<a name="ln583">  }</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">void api_free_object(Object value)</a>
<a name="ln587">{</a>
<a name="ln588">  switch (value.type) {</a>
<a name="ln589">  case kObjectTypeNil:</a>
<a name="ln590">  case kObjectTypeBoolean:</a>
<a name="ln591">  case kObjectTypeInteger:</a>
<a name="ln592">  case kObjectTypeFloat:</a>
<a name="ln593">  case kObjectTypeBuffer:</a>
<a name="ln594">  case kObjectTypeWindow:</a>
<a name="ln595">  case kObjectTypeTabpage:</a>
<a name="ln596">    break;</a>
<a name="ln597"> </a>
<a name="ln598">  case kObjectTypeString:</a>
<a name="ln599">    api_free_string(value.data.string);</a>
<a name="ln600">    break;</a>
<a name="ln601"> </a>
<a name="ln602">  case kObjectTypeArray:</a>
<a name="ln603">    api_free_array(value.data.array);</a>
<a name="ln604">    break;</a>
<a name="ln605"> </a>
<a name="ln606">  case kObjectTypeDictionary:</a>
<a name="ln607">    api_free_dictionary(value.data.dictionary);</a>
<a name="ln608">    break;</a>
<a name="ln609"> </a>
<a name="ln610">  case kObjectTypeLuaRef:</a>
<a name="ln611">    api_free_luaref(value.data.luaref);</a>
<a name="ln612">    break;</a>
<a name="ln613"> </a>
<a name="ln614">  default:</a>
<a name="ln615">    abort();</a>
<a name="ln616">  }</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">void api_free_array(Array value)</a>
<a name="ln620">{</a>
<a name="ln621">  for (size_t i = 0; i &lt; value.size; i++) {</a>
<a name="ln622">    api_free_object(value.items[i]);</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  xfree(value.items);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">void api_free_dictionary(Dictionary value)</a>
<a name="ln629">{</a>
<a name="ln630">  for (size_t i = 0; i &lt; value.size; i++) {</a>
<a name="ln631">    api_free_string(value.items[i].key);</a>
<a name="ln632">    api_free_object(value.items[i].value);</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  xfree(value.items);</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">void api_clear_error(Error *value)</a>
<a name="ln639">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln640">{</a>
<a name="ln641">  if (!ERROR_SET(value)) {</a>
<a name="ln642">    return;</a>
<a name="ln643">  }</a>
<a name="ln644">  xfree(value-&gt;msg);</a>
<a name="ln645">  value-&gt;msg = NULL;</a>
<a name="ln646">  value-&gt;type = kErrorTypeNone;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">/// @returns a shared value. caller must not modify it!</a>
<a name="ln650">Dictionary api_metadata(void)</a>
<a name="ln651">{</a>
<a name="ln652">  static Dictionary metadata = ARRAY_DICT_INIT;</a>
<a name="ln653"> </a>
<a name="ln654">  if (!metadata.size) {</a>
<a name="ln655">    PUT(metadata, &quot;version&quot;, DICTIONARY_OBJ(version_dict()));</a>
<a name="ln656">    init_function_metadata(&amp;metadata);</a>
<a name="ln657">    init_ui_event_metadata(&amp;metadata);</a>
<a name="ln658">    init_error_type_metadata(&amp;metadata);</a>
<a name="ln659">    init_type_metadata(&amp;metadata);</a>
<a name="ln660">  }</a>
<a name="ln661"> </a>
<a name="ln662">  return metadata;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">static void init_function_metadata(Dictionary *metadata)</a>
<a name="ln666">{</a>
<a name="ln667">  msgpack_unpacked unpacked;</a>
<a name="ln668">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln669">  if (msgpack_unpack_next(&amp;unpacked,</a>
<a name="ln670">                          (const char *)funcs_metadata,</a>
<a name="ln671">                          sizeof(funcs_metadata),</a>
<a name="ln672">                          NULL) != MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln673">    abort();</a>
<a name="ln674">  }</a>
<a name="ln675">  Object functions;</a>
<a name="ln676">  msgpack_rpc_to_object(&amp;unpacked.data, &amp;functions);</a>
<a name="ln677">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln678">  PUT(*metadata, &quot;functions&quot;, functions);</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">static void init_ui_event_metadata(Dictionary *metadata)</a>
<a name="ln682">{</a>
<a name="ln683">  msgpack_unpacked unpacked;</a>
<a name="ln684">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln685">  if (msgpack_unpack_next(&amp;unpacked,</a>
<a name="ln686">                          (const char *)ui_events_metadata,</a>
<a name="ln687">                          sizeof(ui_events_metadata),</a>
<a name="ln688">                          NULL) != MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln689">    abort();</a>
<a name="ln690">  }</a>
<a name="ln691">  Object ui_events;</a>
<a name="ln692">  msgpack_rpc_to_object(&amp;unpacked.data, &amp;ui_events);</a>
<a name="ln693">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln694">  PUT(*metadata, &quot;ui_events&quot;, ui_events);</a>
<a name="ln695">  Array ui_options = ARRAY_DICT_INIT;</a>
<a name="ln696">  ADD(ui_options, CSTR_TO_OBJ(&quot;rgb&quot;));</a>
<a name="ln697">  for (UIExtension i = 0; i &lt; kUIExtCount; i++) {</a>
<a name="ln698">    if (ui_ext_names[i][0] != '_') {</a>
<a name="ln699">      ADD(ui_options, CSTR_TO_OBJ(ui_ext_names[i]));</a>
<a name="ln700">    }</a>
<a name="ln701">  }</a>
<a name="ln702">  PUT(*metadata, &quot;ui_options&quot;, ARRAY_OBJ(ui_options));</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">static void init_error_type_metadata(Dictionary *metadata)</a>
<a name="ln706">{</a>
<a name="ln707">  Dictionary types = ARRAY_DICT_INIT;</a>
<a name="ln708"> </a>
<a name="ln709">  Dictionary exception_metadata = ARRAY_DICT_INIT;</a>
<a name="ln710">  PUT(exception_metadata, &quot;id&quot;, INTEGER_OBJ(kErrorTypeException));</a>
<a name="ln711"> </a>
<a name="ln712">  Dictionary validation_metadata = ARRAY_DICT_INIT;</a>
<a name="ln713">  PUT(validation_metadata, &quot;id&quot;, INTEGER_OBJ(kErrorTypeValidation));</a>
<a name="ln714"> </a>
<a name="ln715">  PUT(types, &quot;Exception&quot;, DICTIONARY_OBJ(exception_metadata));</a>
<a name="ln716">  PUT(types, &quot;Validation&quot;, DICTIONARY_OBJ(validation_metadata));</a>
<a name="ln717"> </a>
<a name="ln718">  PUT(*metadata, &quot;error_types&quot;, DICTIONARY_OBJ(types));</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">static void init_type_metadata(Dictionary *metadata)</a>
<a name="ln722">{</a>
<a name="ln723">  Dictionary types = ARRAY_DICT_INIT;</a>
<a name="ln724"> </a>
<a name="ln725">  Dictionary buffer_metadata = ARRAY_DICT_INIT;</a>
<a name="ln726">  PUT(buffer_metadata, &quot;id&quot;,</a>
<a name="ln727">      INTEGER_OBJ(kObjectTypeBuffer - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln728">  PUT(buffer_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_buf_&quot;));</a>
<a name="ln729"> </a>
<a name="ln730">  Dictionary window_metadata = ARRAY_DICT_INIT;</a>
<a name="ln731">  PUT(window_metadata, &quot;id&quot;,</a>
<a name="ln732">      INTEGER_OBJ(kObjectTypeWindow - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln733">  PUT(window_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_win_&quot;));</a>
<a name="ln734"> </a>
<a name="ln735">  Dictionary tabpage_metadata = ARRAY_DICT_INIT;</a>
<a name="ln736">  PUT(tabpage_metadata, &quot;id&quot;,</a>
<a name="ln737">      INTEGER_OBJ(kObjectTypeTabpage - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln738">  PUT(tabpage_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_tabpage_&quot;));</a>
<a name="ln739"> </a>
<a name="ln740">  PUT(types, &quot;Buffer&quot;, DICTIONARY_OBJ(buffer_metadata));</a>
<a name="ln741">  PUT(types, &quot;Window&quot;, DICTIONARY_OBJ(window_metadata));</a>
<a name="ln742">  PUT(types, &quot;Tabpage&quot;, DICTIONARY_OBJ(tabpage_metadata));</a>
<a name="ln743"> </a>
<a name="ln744">  PUT(*metadata, &quot;types&quot;, DICTIONARY_OBJ(types));</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">// all the copy_[object] functions allow arena=NULL,</a>
<a name="ln748">// then global allocations are used, and the resulting object</a>
<a name="ln749">// should be freed with an api_free_[object] function</a>
<a name="ln750"> </a>
<a name="ln751">String copy_string(String str, Arena *arena)</a>
<a name="ln752">{</a>
<a name="ln753">  if (str.data != NULL) {</a>
<a name="ln754">    return (String){ .data = arena_memdupz(arena, str.data, str.size), .size = str.size };</a>
<a name="ln755">  } else {</a>
<a name="ln756">    return (String)STRING_INIT;</a>
<a name="ln757">  }</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">Array copy_array(Array array, Arena *arena)</a>
<a name="ln761">{</a>
<a name="ln762">  Array rv = arena_array(arena, array.size);</a>
<a name="ln763">  for (size_t i = 0; i &lt; array.size; i++) {</a>
<a name="ln764">    ADD(rv, copy_object(array.items[i], arena));</a>
<a name="ln765">  }</a>
<a name="ln766">  return rv;</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">Dictionary copy_dictionary(Dictionary dict, Arena *arena)</a>
<a name="ln770">{</a>
<a name="ln771">  Dictionary rv = arena_dict(arena, dict.size);</a>
<a name="ln772">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln773">    KeyValuePair item = dict.items[i];</a>
<a name="ln774">    PUT_C(rv, copy_string(item.key, arena).data, copy_object(item.value, arena));</a>
<a name="ln775">  }</a>
<a name="ln776">  return rv;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">/// Creates a deep clone of an object</a>
<a name="ln780">Object copy_object(Object obj, Arena *arena)</a>
<a name="ln781">{</a>
<a name="ln782">  switch (obj.type) {</a>
<a name="ln783">  case kObjectTypeBuffer:</a>
<a name="ln784">  case kObjectTypeTabpage:</a>
<a name="ln785">  case kObjectTypeWindow:</a>
<a name="ln786">  case kObjectTypeNil:</a>
<a name="ln787">  case kObjectTypeBoolean:</a>
<a name="ln788">  case kObjectTypeInteger:</a>
<a name="ln789">  case kObjectTypeFloat:</a>
<a name="ln790">    return obj;</a>
<a name="ln791"> </a>
<a name="ln792">  case kObjectTypeString:</a>
<a name="ln793">    return STRING_OBJ(copy_string(obj.data.string, arena));</a>
<a name="ln794"> </a>
<a name="ln795">  case kObjectTypeArray:</a>
<a name="ln796">    return ARRAY_OBJ(copy_array(obj.data.array, arena));</a>
<a name="ln797"> </a>
<a name="ln798">  case kObjectTypeDictionary:</a>
<a name="ln799">    return DICTIONARY_OBJ(copy_dictionary(obj.data.dictionary, arena));</a>
<a name="ln800"> </a>
<a name="ln801">  case kObjectTypeLuaRef:</a>
<a name="ln802">    return LUAREF_OBJ(api_new_luaref(obj.data.luaref));</a>
<a name="ln803"> </a>
<a name="ln804">  default:</a>
<a name="ln805">    abort();</a>
<a name="ln806">  }</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">void api_set_error(Error *err, ErrorType errType, const char *format, ...)</a>
<a name="ln810">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln811">{</a>
<a name="ln812">  assert(kErrorTypeNone != errType);</a>
<a name="ln813">  va_list args1;</a>
<a name="ln814">  va_list args2;</a>
<a name="ln815">  va_start(args1, format);</a>
<a name="ln816">  va_copy(args2, args1);</a>
<a name="ln817">  int len = vsnprintf(NULL, 0, format, args1);</a>
<a name="ln818">  va_end(args1);</a>
<a name="ln819">  assert(len &gt;= 0);</a>
<a name="ln820">  // Limit error message to 1 MB.</a>
<a name="ln821">  size_t bufsize = MIN((size_t)len + 1, 1024 * 1024);</a>
<a name="ln822">  err-&gt;msg = xmalloc(bufsize);</a>
<a name="ln823">  vsnprintf(err-&gt;msg, bufsize, format, args2);</a>
<a name="ln824">  va_end(args2);</a>
<a name="ln825"> </a>
<a name="ln826">  err-&gt;type = errType;</a>
<a name="ln827">}</a>
<a name="ln828"> </a>
<a name="ln829">/// Force obj to bool.</a>
<a name="ln830">/// If it fails, returns false and sets err</a>
<a name="ln831">/// @param obj          The object to coerce to a boolean</a>
<a name="ln832">/// @param what         The name of the object, used for error message</a>
<a name="ln833">/// @param nil_value    What to return if the type is nil.</a>
<a name="ln834">/// @param err          Set if there was an error in converting to a bool</a>
<a name="ln835">bool api_object_to_bool(Object obj, const char *what, bool nil_value, Error *err)</a>
<a name="ln836">{</a>
<a name="ln837">  if (obj.type == kObjectTypeBoolean) {</a>
<a name="ln838">    return obj.data.boolean;</a>
<a name="ln839">  } else if (obj.type == kObjectTypeInteger) {</a>
<a name="ln840">    return obj.data.integer;  // C semantics: non-zero int is true</a>
<a name="ln841">  } else if (obj.type == kObjectTypeNil) {</a>
<a name="ln842">    return nil_value;  // caller decides what NIL (missing retval in Lua) means</a>
<a name="ln843">  } else {</a>
<a name="ln844">    api_set_error(err, kErrorTypeValidation, &quot;%s is not a boolean&quot;, what);</a>
<a name="ln845">    return false;</a>
<a name="ln846">  }</a>
<a name="ln847">}</a>
<a name="ln848"> </a>
<a name="ln849">int object_to_hl_id(Object obj, const char *what, Error *err)</a>
<a name="ln850">{</a>
<a name="ln851">  if (obj.type == kObjectTypeString) {</a>
<a name="ln852">    String str = obj.data.string;</a>
<a name="ln853">    return str.size ? syn_check_group(str.data, str.size) : 0;</a>
<a name="ln854">  } else if (obj.type == kObjectTypeInteger) {</a>
<a name="ln855">    return MAX((int)obj.data.integer, 0);</a>
<a name="ln856">  } else {</a>
<a name="ln857">    api_set_error(err, kErrorTypeValidation, &quot;Invalid highlight: %s&quot;, what);</a>
<a name="ln858">    return 0;</a>
<a name="ln859">  }</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">char *api_typename(ObjectType t)</a>
<a name="ln863">{</a>
<a name="ln864">  switch (t) {</a>
<a name="ln865">  case kObjectTypeNil:</a>
<a name="ln866">    return &quot;nil&quot;;</a>
<a name="ln867">  case kObjectTypeBoolean:</a>
<a name="ln868">    return &quot;Boolean&quot;;</a>
<a name="ln869">  case kObjectTypeInteger:</a>
<a name="ln870">    return &quot;Integer&quot;;</a>
<a name="ln871">  case kObjectTypeFloat:</a>
<a name="ln872">    return &quot;Float&quot;;</a>
<a name="ln873">  case kObjectTypeString:</a>
<a name="ln874">    return &quot;String&quot;;</a>
<a name="ln875">  case kObjectTypeArray:</a>
<a name="ln876">    return &quot;Array&quot;;</a>
<a name="ln877">  case kObjectTypeDictionary:</a>
<a name="ln878">    return &quot;Dict&quot;;</a>
<a name="ln879">  case kObjectTypeLuaRef:</a>
<a name="ln880">    return &quot;Function&quot;;</a>
<a name="ln881">  case kObjectTypeBuffer:</a>
<a name="ln882">    return &quot;Buffer&quot;;</a>
<a name="ln883">  case kObjectTypeWindow:</a>
<a name="ln884">    return &quot;Window&quot;;</a>
<a name="ln885">  case kObjectTypeTabpage:</a>
<a name="ln886">    return &quot;Tabpage&quot;;</a>
<a name="ln887">  default:</a>
<a name="ln888">    abort();</a>
<a name="ln889">  }</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">HlMessage parse_hl_msg(Array chunks, Error *err)</a>
<a name="ln893">{</a>
<a name="ln894">  HlMessage hl_msg = KV_INITIAL_VALUE;</a>
<a name="ln895">  for (size_t i = 0; i &lt; chunks.size; i++) {</a>
<a name="ln896">    if (chunks.items[i].type != kObjectTypeArray) {</a>
<a name="ln897">      api_set_error(err, kErrorTypeValidation, &quot;Chunk is not an array&quot;);</a>
<a name="ln898">      goto free_exit;</a>
<a name="ln899">    }</a>
<a name="ln900">    Array chunk = chunks.items[i].data.array;</a>
<a name="ln901">    if (chunk.size == 0 || chunk.size &gt; 2</a>
<a name="ln902">        || chunk.items[0].type != kObjectTypeString</a>
<a name="ln903">        || (chunk.size == 2 &amp;&amp; chunk.items[1].type != kObjectTypeString)) {</a>
<a name="ln904">      api_set_error(err, kErrorTypeValidation,</a>
<a name="ln905">                    &quot;Chunk is not an array with one or two strings&quot;);</a>
<a name="ln906">      goto free_exit;</a>
<a name="ln907">    }</a>
<a name="ln908"> </a>
<a name="ln909">    String str = copy_string(chunk.items[0].data.string, NULL);</a>
<a name="ln910"> </a>
<a name="ln911">    int attr = 0;</a>
<a name="ln912">    if (chunk.size == 2) {</a>
<a name="ln913">      String hl = chunk.items[1].data.string;</a>
<a name="ln914">      if (hl.size &gt; 0) {</a>
<a name="ln915">        // TODO(bfredl): use object_to_hl_id and allow integer</a>
<a name="ln916">        int hl_id = syn_check_group(hl.data, hl.size);</a>
<a name="ln917">        attr = hl_id &gt; 0 ? syn_id2attr(hl_id) : 0;</a>
<a name="ln918">      }</a>
<a name="ln919">    }</a>
<a name="ln920">    kv_push(hl_msg, ((HlMessageChunk){ .text = str, .attr = attr }));</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  return hl_msg;</a>
<a name="ln924"> </a>
<a name="ln925">free_exit:</a>
<a name="ln926">  hl_msg_free(hl_msg);</a>
<a name="ln927">  return (HlMessage)KV_INITIAL_VALUE;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">// see also nlua_pop_keydict for the lua specific implementation</a>
<a name="ln931">bool api_dict_to_keydict(void *retval, FieldHashfn hashy, Dictionary dict, Error *err)</a>
<a name="ln932">{</a>
<a name="ln933">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln934">    String k = dict.items[i].key;</a>
<a name="ln935">    KeySetLink *field = hashy(k.data, k.size);</a>
<a name="ln936">    if (!field) {</a>
<a name="ln937">      api_set_error(err, kErrorTypeValidation, &quot;Invalid key: '%.*s'&quot;, (int)k.size, k.data);</a>
<a name="ln938">      return false;</a>
<a name="ln939">    }</a>
<a name="ln940"> </a>
<a name="ln941">    if (field-&gt;opt_index &gt;= 0) {</a>
<a name="ln942">      OptKeySet *ks = (OptKeySet *)retval;</a>
<a name="ln943">      ks-&gt;is_set_ |= (1ULL &lt;&lt; field-&gt;opt_index);</a>
<a name="ln944">    }</a>
<a name="ln945"> </a>
<a name="ln946">    char *mem = ((char *)retval + field-&gt;ptr_off);</a>
<a name="ln947">    Object *value = &amp;dict.items[i].value;</a>
<a name="ln948">    if (field-&gt;type == kObjectTypeNil) {</a>
<a name="ln949">      *(Object *)mem = *value;</a>
<a name="ln950">    } else if (field-&gt;type == kObjectTypeInteger) {</a>
<a name="ln951">      VALIDATE_T(field-&gt;str, kObjectTypeInteger, value-&gt;type, {</a>
<a name="ln952">        return false;</a>
<a name="ln953">      });</a>
<a name="ln954">      *(Integer *)mem = value-&gt;data.integer;</a>
<a name="ln955">    } else if (field-&gt;type == kObjectTypeFloat) {</a>
<a name="ln956">      Float *val = (Float *)mem;</a>
<a name="ln957">      if (value-&gt;type == kObjectTypeInteger) {</a>
<a name="ln958">        *val = (Float)value-&gt;data.integer;</a>
<a name="ln959">      } else {</a>
<a name="ln960">        VALIDATE_T(field-&gt;str, kObjectTypeFloat, value-&gt;type, {</a>
<a name="ln961">          return false;</a>
<a name="ln962">        });</a>
<a name="ln963">        *val = value-&gt;data.floating;</a>
<a name="ln964">      }</a>
<a name="ln965">    } else if (field-&gt;type == kObjectTypeBoolean) {</a>
<a name="ln966">      // caller should check HAS_KEY to override the nil behavior, or GET_BOOL_OR_TRUE</a>
<a name="ln967">      // to directly use true when nil</a>
<a name="ln968">      *(Boolean *)mem = api_object_to_bool(*value, field-&gt;str, false, err);</a>
<a name="ln969">      if (ERROR_SET(err)) {</a>
<a name="ln970">        return false;</a>
<a name="ln971">      }</a>
<a name="ln972">    } else if (field-&gt;type == kObjectTypeString) {</a>
<a name="ln973">      VALIDATE_T(field-&gt;str, kObjectTypeString, value-&gt;type, {</a>
<a name="ln974">        return false;</a>
<a name="ln975">      });</a>
<a name="ln976">      *(String *)mem = value-&gt;data.string;</a>
<a name="ln977">    } else if (field-&gt;type == kObjectTypeArray) {</a>
<a name="ln978">      VALIDATE_T(field-&gt;str, kObjectTypeArray, value-&gt;type, {</a>
<a name="ln979">        return false;</a>
<a name="ln980">      });</a>
<a name="ln981">      *(Array *)mem = value-&gt;data.array;</a>
<a name="ln982">    } else if (field-&gt;type == kObjectTypeDictionary) {</a>
<a name="ln983">      Dictionary *val = (Dictionary *)mem;</a>
<a name="ln984">      // allow empty array as empty dict for lua (directly or via lua-client RPC)</a>
<a name="ln985">      if (value-&gt;type == kObjectTypeArray &amp;&amp; value-&gt;data.array.size == 0) {</a>
<a name="ln986">        *val = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln987">      } else if (value-&gt;type == kObjectTypeDictionary) {</a>
<a name="ln988">        *val = value-&gt;data.dictionary;</a>
<a name="ln989">      } else {</a>
<a name="ln990">        api_err_exp(err, field-&gt;str, api_typename(field-&gt;type), api_typename(value-&gt;type));</a>
<a name="ln991">        return false;</a>
<a name="ln992">      }</a>
<a name="ln993">    } else if (field-&gt;type == kObjectTypeBuffer || field-&gt;type == kObjectTypeWindow</a>
<a name="ln994">               || field-&gt;type == kObjectTypeTabpage) {</a>
<a name="ln995">      if (value-&gt;type == kObjectTypeInteger || value-&gt;type == field-&gt;type) {</a>
<a name="ln996">        *(handle_T *)mem = (handle_T)value-&gt;data.integer;</a>
<a name="ln997">      } else {</a>
<a name="ln998">        api_err_exp(err, field-&gt;str, api_typename(field-&gt;type), api_typename(value-&gt;type));</a>
<a name="ln999">        return false;</a>
<a name="ln1000">      }</a>
<a name="ln1001">    } else if (field-&gt;type == kObjectTypeLuaRef) {</a>
<a name="ln1002">      api_set_error(err, kErrorTypeValidation, &quot;Invalid key: '%.*s' is only allowed from Lua&quot;,</a>
<a name="ln1003">                    (int)k.size, k.data);</a>
<a name="ln1004">      return false;</a>
<a name="ln1005">    } else {</a>
<a name="ln1006">      abort();</a>
<a name="ln1007">    }</a>
<a name="ln1008">  }</a>
<a name="ln1009"> </a>
<a name="ln1010">  return true;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">void api_free_keydict(void *dict, KeySetLink *table)</a>
<a name="ln1014">{</a>
<a name="ln1015">  for (size_t i = 0; table[i].str; i++) {</a>
<a name="ln1016">    char *mem = ((char *)dict + table[i].ptr_off);</a>
<a name="ln1017">    if (table[i].type == kObjectTypeNil) {</a>
<a name="ln1018">      api_free_object(*(Object *)mem);</a>
<a name="ln1019">    } else if (table[i].type == kObjectTypeString) {</a>
<a name="ln1020">      api_free_string(*(String *)mem);</a>
<a name="ln1021">    } else if (table[i].type == kObjectTypeArray) {</a>
<a name="ln1022">      api_free_array(*(Array *)mem);</a>
<a name="ln1023">    } else if (table[i].type == kObjectTypeDictionary) {</a>
<a name="ln1024">      api_free_dictionary(*(Dictionary *)mem);</a>
<a name="ln1025">    } else if (table[i].type == kObjectTypeLuaRef) {</a>
<a name="ln1026">      api_free_luaref(*(LuaRef *)mem);</a>
<a name="ln1027">    }</a>
<a name="ln1028">  }</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">/// Set a named mark</a>
<a name="ln1032">/// buffer and mark name must be validated already</a>
<a name="ln1033">/// @param buffer     Buffer to set the mark on</a>
<a name="ln1034">/// @param name       Mark name</a>
<a name="ln1035">/// @param line       Line number</a>
<a name="ln1036">/// @param col        Column/row number</a>
<a name="ln1037">/// @return true if the mark was set, else false</a>
<a name="ln1038">bool set_mark(buf_T *buf, String name, Integer line, Integer col, Error *err)</a>
<a name="ln1039">{</a>
<a name="ln1040">  buf = buf == NULL ? curbuf : buf;</a>
<a name="ln1041">  // If line == 0 the marks is being deleted</a>
<a name="ln1042">  bool res = false;</a>
<a name="ln1043">  bool deleting = false;</a>
<a name="ln1044">  if (line == 0) {</a>
<a name="ln1045">    col = 0;</a>
<a name="ln1046">    deleting = true;</a>
<a name="ln1047">  } else {</a>
<a name="ln1048">    if (col &gt; MAXCOL) {</a>
<a name="ln1049">      api_set_error(err, kErrorTypeValidation, &quot;Column value outside range&quot;);</a>
<a name="ln1050">      return res;</a>
<a name="ln1051">    }</a>
<a name="ln1052">    if (line &lt; 1 || line &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1053">      api_set_error(err, kErrorTypeValidation, &quot;Line value outside range&quot;);</a>
<a name="ln1054">      return res;</a>
<a name="ln1055">    }</a>
<a name="ln1056">  }</a>
<a name="ln1057">  assert(INT32_MIN &lt;= line &amp;&amp; line &lt;= INT32_MAX);</a>
<a name="ln1058">  pos_T pos = { (linenr_T)line, (int)col, (int)col };</a>
<a name="ln1059">  res = setmark_pos(*name.data, &amp;pos, buf-&gt;handle, NULL);</a>
<a name="ln1060">  if (!res) {</a>
<a name="ln1061">    if (deleting) {</a>
<a name="ln1062">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1063">                    &quot;Failed to delete named mark: %c&quot;, *name.data);</a>
<a name="ln1064">    } else {</a>
<a name="ln1065">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1066">                    &quot;Failed to set named mark: %c&quot;, *name.data);</a>
<a name="ln1067">    }</a>
<a name="ln1068">  }</a>
<a name="ln1069">  return res;</a>
<a name="ln1070">}</a>
<a name="ln1071"> </a>
<a name="ln1072">/// Get default statusline highlight for window</a>
<a name="ln1073">const char *get_default_stl_hl(win_T *wp, bool use_winbar, int stc_hl_id)</a>
<a name="ln1074">{</a>
<a name="ln1075">  if (wp == NULL) {</a>
<a name="ln1076">    return &quot;TabLineFill&quot;;</a>
<a name="ln1077">  } else if (use_winbar) {</a>
<a name="ln1078">    return (wp == curwin) ? &quot;WinBar&quot; : &quot;WinBarNC&quot;;</a>
<a name="ln1079">  } else if (stc_hl_id &gt; 0) {</a>
<a name="ln1080">    return syn_id2name(stc_hl_id);</a>
<a name="ln1081">  } else {</a>
<a name="ln1082">    return (wp == curwin) ? &quot;StatusLine&quot; : &quot;StatusLineNC&quot;;</a>
<a name="ln1083">  }</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">int find_sid(uint64_t channel_id)</a>
<a name="ln1087">{</a>
<a name="ln1088">  switch (channel_id) {</a>
<a name="ln1089">  case VIML_INTERNAL_CALL:</a>
<a name="ln1090">  // TODO(autocmd): Figure out what this should be</a>
<a name="ln1091">  // return SID_API_CLIENT;</a>
<a name="ln1092">  case LUA_INTERNAL_CALL:</a>
<a name="ln1093">    return SID_LUA;</a>
<a name="ln1094">  default:</a>
<a name="ln1095">    return SID_API_CLIENT;</a>
<a name="ln1096">  }</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">/// Sets sctx for API calls.</a>
<a name="ln1100">///</a>
<a name="ln1101">/// @param channel_id     api clients id. Used to determine if it's a internal</a>
<a name="ln1102">///                       call or a rpc call.</a>
<a name="ln1103">/// @return returns       previous value of current_sctx. To be used</a>
<a name="ln1104">///                       to be used for restoring sctx to previous state.</a>
<a name="ln1105">sctx_T api_set_sctx(uint64_t channel_id)</a>
<a name="ln1106">{</a>
<a name="ln1107">  sctx_T old_current_sctx = current_sctx;</a>
<a name="ln1108">  if (channel_id != VIML_INTERNAL_CALL) {</a>
<a name="ln1109">    current_sctx.sc_sid =</a>
<a name="ln1110">      channel_id == LUA_INTERNAL_CALL ? SID_LUA : SID_API_CLIENT;</a>
<a name="ln1111">    current_sctx.sc_lnum = 0;</a>
<a name="ln1112">  }</a>
<a name="ln1113">  return old_current_sctx;</a>
<a name="ln1114">}</a>
</code></pre>
<div class="balloon" rel="815"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>