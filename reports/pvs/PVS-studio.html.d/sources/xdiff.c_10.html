<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>xdiff.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;lauxlib.h&gt;</a>
<a name="ln5">#include &lt;lua.h&gt;</a>
<a name="ln6">#include &lt;stdbool.h&gt;</a>
<a name="ln7">#include &lt;stdint.h&gt;</a>
<a name="ln8">#include &lt;string.h&gt;</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;luaconf.h&quot;</a>
<a name="ln11">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln12">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln13">#include &quot;nvim/linematch.h&quot;</a>
<a name="ln14">#include &quot;nvim/lua/converter.h&quot;</a>
<a name="ln15">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln16">#include &quot;nvim/lua/xdiff.h&quot;</a>
<a name="ln17">#include &quot;nvim/macros.h&quot;</a>
<a name="ln18">#include &quot;nvim/memory.h&quot;</a>
<a name="ln19">#include &quot;nvim/vim.h&quot;</a>
<a name="ln20">#include &quot;xdiff/xdiff.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">#define COMPARED_BUFFER0 (1 &lt;&lt; 0)</a>
<a name="ln23">#define COMPARED_BUFFER1 (1 &lt;&lt; 1)</a>
<a name="ln24"> </a>
<a name="ln25">typedef enum {</a>
<a name="ln26">  kNluaXdiffModeUnified = 0,</a>
<a name="ln27">  kNluaXdiffModeOnHunkCB,</a>
<a name="ln28">  kNluaXdiffModeLocations,</a>
<a name="ln29">} NluaXdiffMode;</a>
<a name="ln30"> </a>
<a name="ln31">typedef struct {</a>
<a name="ln32">  lua_State *lstate;</a>
<a name="ln33">  Error *err;</a>
<a name="ln34">  mmfile_t *ma;</a>
<a name="ln35">  mmfile_t *mb;</a>
<a name="ln36">  int64_t linematch;</a>
<a name="ln37">  bool iwhite;</a>
<a name="ln38">} hunkpriv_t;</a>
<a name="ln39"> </a>
<a name="ln40">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln41"># include &quot;lua/xdiff.c.generated.h&quot;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">static void lua_pushhunk(lua_State *lstate, long start_a, long count_a, long start_b, long count_b)</a>
<a name="ln45">{</a>
<a name="ln46">  // Mimic extra offsets done by xdiff, see:</a>
<a name="ln47">  // src/xdiff/xemit.c:284</a>
<a name="ln48">  // src/xdiff/xutils.c:(356,368)</a>
<a name="ln49">  if (count_a &gt; 0) {</a>
<a name="ln50">    start_a += 1;</a>
<a name="ln51">  }</a>
<a name="ln52">  if (count_b &gt; 0) {</a>
<a name="ln53">    start_b += 1;</a>
<a name="ln54">  }</a>
<a name="ln55">  lua_createtable(lstate, 0, 0);</a>
<a name="ln56">  lua_pushinteger(lstate, start_a);</a>
<a name="ln57">  lua_rawseti(lstate, -2, 1);</a>
<a name="ln58">  lua_pushinteger(lstate, count_a);</a>
<a name="ln59">  lua_rawseti(lstate, -2, 2);</a>
<a name="ln60">  lua_pushinteger(lstate, start_b);</a>
<a name="ln61">  lua_rawseti(lstate, -2, 3);</a>
<a name="ln62">  lua_pushinteger(lstate, count_b);</a>
<a name="ln63">  lua_rawseti(lstate, -2, 4);</a>
<a name="ln64">  lua_rawseti(lstate, -2, (signed)lua_objlen(lstate, -2) + 1);</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">static void get_linematch_results(lua_State *lstate, mmfile_t *ma, mmfile_t *mb, int start_a,</a>
<a name="ln68">                                  int count_a, int start_b, int count_b, bool iwhite)</a>
<a name="ln69">{</a>
<a name="ln70">  // get the pointer to char of the start of the diff to pass it to linematch algorithm</a>
<a name="ln71">  const char *diff_begin[2] = { ma-&gt;ptr, mb-&gt;ptr };</a>
<a name="ln72">  int diff_length[2] = { count_a, count_b };</a>
<a name="ln73"> </a>
<a name="ln74">  fastforward_buf_to_lnum(&amp;diff_begin[0], (linenr_T)start_a + 1);</a>
<a name="ln75">  fastforward_buf_to_lnum(&amp;diff_begin[1], (linenr_T)start_b + 1);</a>
<a name="ln76"> </a>
<a name="ln77">  int *decisions = NULL;</a>
<a name="ln78">  size_t decisions_length = linematch_nbuffers(diff_begin, diff_length, 2, &amp;decisions, iwhite);</a>
<a name="ln79"> </a>
<a name="ln80">  int lnuma = start_a, lnumb = start_b;</a>
<a name="ln81"> </a>
<a name="ln82">  int hunkstarta = lnuma;</a>
<a name="ln83">  int hunkstartb = lnumb;</a>
<a name="ln84">  int hunkcounta = 0;</a>
<a name="ln85">  int hunkcountb = 0;</a>
<a name="ln86">  for (size_t i = 0; i &lt; decisions_length; i++) {</a>
<a name="ln87">    if (i &amp;&amp; (decisions[i - 1] != decisions[i])) {</a>
<a name="ln88">      lua_pushhunk(lstate, hunkstarta, hunkcounta, hunkstartb, hunkcountb);</a>
<a name="ln89"> </a>
<a name="ln90">      hunkstarta = lnuma;</a>
<a name="ln91">      hunkstartb = lnumb;</a>
<a name="ln92">      hunkcounta = 0;</a>
<a name="ln93">      hunkcountb = 0;</a>
<a name="ln94">      // create a new hunk</a>
<a name="ln95">    }</a>
<a name="ln96">    if (decisions[i] &amp; COMPARED_BUFFER0) {</a>
<a name="ln97">      lnuma++;</a>
<a name="ln98">      hunkcounta++;</a>
<a name="ln99">    }</a>
<a name="ln100">    if (decisions[i] &amp; COMPARED_BUFFER1) {</a>
<a name="ln101">      lnumb++;</a>
<a name="ln102">      hunkcountb++;</a>
<a name="ln103">    }</a>
<a name="ln104">  }</a>
<a name="ln105">  lua_pushhunk(lstate, hunkstarta, hunkcounta, hunkstartb, hunkcountb);</a>
<a name="ln106">  xfree(decisions);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static int write_string(void *priv, mmbuffer_t *mb, int nbuf)</a>
<a name="ln110">{</a>
<a name="ln111">  luaL_Buffer *buf = (luaL_Buffer *)priv;</a>
<a name="ln112">  for (int i = 0; i &lt; nbuf; i++) {</a>
<a name="ln113">    const int size = mb[i].size;</a>
<a name="ln114">    for (int total = 0; total &lt; size; total += LUAL_BUFFERSIZE) {</a>
<a name="ln115">      const int tocopy = MIN((int)(size - total), LUAL_BUFFERSIZE);</a>
<a name="ln116">      char *p = luaL_prepbuffer(buf);</a>
<a name="ln117">      if (!p) {</a>
<a name="ln118">        return -1;</a>
<a name="ln119">      }</a>
<a name="ln120">      memcpy(p, mb[i].ptr + total, (unsigned)tocopy);</a>
<a name="ln121">      luaL_addsize(buf, (unsigned)tocopy);</a>
<a name="ln122">    }</a>
<a name="ln123">  }</a>
<a name="ln124">  return 0;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">// hunk_func callback used when opts.hunk_lines = true</a>
<a name="ln128">static int hunk_locations_cb(int start_a, int count_a, int start_b, int count_b, void *cb_data)</a>
<a name="ln129">{</a>
<a name="ln130">  hunkpriv_t *priv = (hunkpriv_t *)cb_data;</a>
<a name="ln131">  lua_State *lstate = priv-&gt;lstate;</a>
<a name="ln132">  if (priv-&gt;linematch &gt; 0 &amp;&amp; count_a + count_b &lt;= priv-&gt;linematch) {</a>
<a name="ln133">    get_linematch_results(lstate, priv-&gt;ma, priv-&gt;mb, start_a, count_a, start_b, count_b,</a>
<a name="ln134">                          priv-&gt;iwhite);</a>
<a name="ln135">  } else {</a>
<a name="ln136">    lua_pushhunk(lstate, start_a, count_a, start_b, count_b);</a>
<a name="ln137">  }</a>
<a name="ln138"> </a>
<a name="ln139">  return 0;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">// hunk_func callback used when opts.on_hunk is given</a>
<a name="ln143">static int call_on_hunk_cb(int start_a, int count_a, int start_b, int count_b, void *cb_data)</a>
<a name="ln144">{</a>
<a name="ln145">  // Mimic extra offsets done by xdiff, see:</a>
<a name="ln146">  // src/xdiff/xemit.c:284</a>
<a name="ln147">  // src/xdiff/xutils.c:(356,368)</a>
<a name="ln148">  if (count_a &gt; 0) {</a>
<a name="ln149">    start_a += 1;</a>
<a name="ln150">  }</a>
<a name="ln151">  if (count_b &gt; 0) {</a>
<a name="ln152">    start_b += 1;</a>
<a name="ln153">  }</a>
<a name="ln154"> </a>
<a name="ln155">  hunkpriv_t *priv = (hunkpriv_t *)cb_data;</a>
<a name="ln156">  lua_State *lstate = priv-&gt;lstate;</a>
<a name="ln157">  Error *err = priv-&gt;err;</a>
<a name="ln158">  const int fidx = lua_gettop(lstate);</a>
<a name="ln159">  lua_pushvalue(lstate, fidx);</a>
<a name="ln160">  lua_pushinteger(lstate, start_a);</a>
<a name="ln161">  lua_pushinteger(lstate, count_a);</a>
<a name="ln162">  lua_pushinteger(lstate, start_b);</a>
<a name="ln163">  lua_pushinteger(lstate, count_b);</a>
<a name="ln164"> </a>
<a name="ln165">  if (lua_pcall(lstate, 4, 1, 0) != 0) {</a>
<a name="ln166">    api_set_error(err, kErrorTypeException,</a>
<a name="ln167">                  &quot;error running function on_hunk: %s&quot;,</a>
<a name="ln168">                  lua_tostring(lstate, -1));</a>
<a name="ln169">    return -1;</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  int r = 0;</a>
<a name="ln173">  if (lua_isnumber(lstate, -1)) {</a>
<a name="ln174">    r = (int)lua_tonumber(lstate, -1);</a>
<a name="ln175">  }</a>
<a name="ln176"> </a>
<a name="ln177">  lua_pop(lstate, 1);</a>
<a name="ln178">  lua_settop(lstate, fidx);</a>
<a name="ln179">  return r;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static mmfile_t get_string_arg(lua_State *lstate, int idx)</a>
<a name="ln183">{</a>
<a name="ln184">  if (lua_type(lstate, idx) != LUA_TSTRING) {</a>
<a name="ln185">    luaL_argerror(lstate, idx, &quot;expected string&quot;);</a>
<a name="ln186">  }</a>
<a name="ln187">  mmfile_t mf;</a>
<a name="ln188">  mf.ptr = (char *)lua_tolstring(lstate, idx, (size_t *)&amp;mf.size);</a>
<a name="ln189">  return mf;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">// Helper function for validating option types</a>
<a name="ln193">static bool check_xdiff_opt(ObjectType actType, ObjectType expType, const char *name, Error *err)</a>
<a name="ln194">{</a>
<a name="ln195">  if (actType != expType) {</a>
<a name="ln196">    const char *type_str =</a>
<a name="ln197">      expType == kObjectTypeString ? &quot;string&quot; :</a>
<a name="ln198">      expType == kObjectTypeInteger ? &quot;integer&quot; :</a>
<a name="ln199">      expType == kObjectTypeBoolean ? &quot;boolean&quot; :</a>
<a name="ln200">      expType == kObjectTypeLuaRef ? &quot;function&quot; :</a>
<a name="ln201">      &quot;NA&quot;;</a>
<a name="ln202"> </a>
<a name="ln203">    api_set_error(err, kErrorTypeValidation, &quot;%s is not a %s&quot;, name,</a>
<a name="ln204">                  type_str);</a>
<a name="ln205">    return true;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  return false;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">static NluaXdiffMode process_xdl_diff_opts(lua_State *lstate, xdemitconf_t *cfg, xpparam_t *params,</a>
<a name="ln212">                                           int64_t *linematch, Error *err)</a>
<a name="ln213">{</a>
<a name="ln214">  const DictionaryOf(LuaRef) opts = nlua_pop_Dictionary(lstate, true, err);</a>
<a name="ln215"> </a>
<a name="ln216">  NluaXdiffMode mode = kNluaXdiffModeUnified;</a>
<a name="ln217"> </a>
<a name="ln218">  bool had_on_hunk = false;</a>
<a name="ln219">  bool had_result_type_indices = false;</a>
<a name="ln220">  for (size_t i = 0; i &lt; opts.size; i++) {</a>
<a name="ln221">    String k = opts.items[i].key;</a>
<a name="ln222">    Object *v = &amp;opts.items[i].value;</a>
<a name="ln223">    if (strequal(&quot;on_hunk&quot;, k.data)) {</a>
<a name="ln224">      if (check_xdiff_opt(v-&gt;type, kObjectTypeLuaRef, &quot;on_hunk&quot;, err)) {</a>
<a name="ln225">        goto exit_1;</a>
<a name="ln226">      }</a>
<a name="ln227">      had_on_hunk = true;</a>
<a name="ln228">      nlua_pushref(lstate, v-&gt;data.luaref);</a>
<a name="ln229">    } else if (strequal(&quot;result_type&quot;, k.data)) {</a>
<a name="ln230">      if (check_xdiff_opt(v-&gt;type, kObjectTypeString, &quot;result_type&quot;, err)) {</a>
<a name="ln231">        goto exit_1;</a>
<a name="ln232">      }</a>
<a name="ln233">      if (strequal(&quot;unified&quot;, v-&gt;data.string.data)) {</a>
<a name="ln234">        // the default</a>
<a name="ln235">      } else if (strequal(&quot;indices&quot;, v-&gt;data.string.data)) {</a>
<a name="ln236">        had_result_type_indices = true;</a>
<a name="ln237">      } else {</a>
<a name="ln238">        api_set_error(err, kErrorTypeValidation, &quot;not a valid result_type&quot;);</a>
<a name="ln239">        goto exit_1;</a>
<a name="ln240">      }</a>
<a name="ln241">    } else if (strequal(&quot;algorithm&quot;, k.data)) {</a>
<a name="ln242">      if (check_xdiff_opt(v-&gt;type, kObjectTypeString, &quot;algorithm&quot;, err)) {</a>
<a name="ln243">        goto exit_1;</a>
<a name="ln244">      }</a>
<a name="ln245">      if (strequal(&quot;myers&quot;, v-&gt;data.string.data)) {</a>
<a name="ln246">        // default</a>
<a name="ln247">      } else if (strequal(&quot;minimal&quot;, v-&gt;data.string.data)) {</a>
<a name="ln248">        params-&gt;flags |= XDF_NEED_MINIMAL;</a>
<a name="ln249">      } else if (strequal(&quot;patience&quot;, v-&gt;data.string.data)) {</a>
<a name="ln250">        params-&gt;flags |= XDF_PATIENCE_DIFF;</a>
<a name="ln251">      } else if (strequal(&quot;histogram&quot;, v-&gt;data.string.data)) {</a>
<a name="ln252">        params-&gt;flags |= XDF_HISTOGRAM_DIFF;</a>
<a name="ln253">      } else {</a>
<a name="ln254">        api_set_error(err, kErrorTypeValidation, &quot;not a valid algorithm&quot;);</a>
<a name="ln255">        goto exit_1;</a>
<a name="ln256">      }</a>
<a name="ln257">    } else if (strequal(&quot;ctxlen&quot;, k.data)) {</a>
<a name="ln258">      if (check_xdiff_opt(v-&gt;type, kObjectTypeInteger, &quot;ctxlen&quot;, err)) {</a>
<a name="ln259">        goto exit_1;</a>
<a name="ln260">      }</a>
<a name="ln261">      cfg-&gt;ctxlen = (long)v-&gt;data.integer;</a>
<a name="ln262">    } else if (strequal(&quot;interhunkctxlen&quot;, k.data)) {</a>
<a name="ln263">      if (check_xdiff_opt(v-&gt;type, kObjectTypeInteger, &quot;interhunkctxlen&quot;,</a>
<a name="ln264">                          err)) {</a>
<a name="ln265">        goto exit_1;</a>
<a name="ln266">      }</a>
<a name="ln267">      cfg-&gt;interhunkctxlen = (long)v-&gt;data.integer;</a>
<a name="ln268">    } else if (strequal(&quot;linematch&quot;, k.data)) {</a>
<a name="ln269">      if (v-&gt;type == kObjectTypeBoolean) {</a>
<a name="ln270">        *linematch = v-&gt;data.boolean ? INT64_MAX : 0;</a>
<a name="ln271">      } else if (v-&gt;type == kObjectTypeInteger) {</a>
<a name="ln272">        *linematch = v-&gt;data.integer;</a>
<a name="ln273">      } else {</a>
<a name="ln274">        api_set_error(err, kErrorTypeValidation, &quot;linematch must be a boolean or integer&quot;);</a>
<a name="ln275">        goto exit_1;</a>
<a name="ln276">      }</a>
<a name="ln277">    } else {</a>
<a name="ln278">      struct {</a>
<a name="ln279">        const char *name;</a>
<a name="ln280">        unsigned long value;</a>
<a name="ln281">      } flags[] = {</a>
<a name="ln282">        { &quot;ignore_whitespace&quot;, XDF_IGNORE_WHITESPACE },</a>
<a name="ln283">        { &quot;ignore_whitespace_change&quot;, XDF_IGNORE_WHITESPACE_CHANGE },</a>
<a name="ln284">        { &quot;ignore_whitespace_change_at_eol&quot;, XDF_IGNORE_WHITESPACE_AT_EOL },</a>
<a name="ln285">        { &quot;ignore_cr_at_eol&quot;, XDF_IGNORE_CR_AT_EOL },</a>
<a name="ln286">        { &quot;ignore_blank_lines&quot;, XDF_IGNORE_BLANK_LINES },</a>
<a name="ln287">        { &quot;indent_heuristic&quot;, XDF_INDENT_HEURISTIC },</a>
<a name="ln288">        {  NULL, 0 },</a>
<a name="ln289">      };</a>
<a name="ln290">      bool key_used = false;</a>
<a name="ln291">      for (size_t j = 0; flags[j].name; j++) {</a>
<a name="ln292">        if (strequal(flags[j].name, k.data)) {</a>
<a name="ln293">          if (check_xdiff_opt(v-&gt;type, kObjectTypeBoolean, flags[j].name,</a>
<a name="ln294">                              err)) {</a>
<a name="ln295">            goto exit_1;</a>
<a name="ln296">          }</a>
<a name="ln297">          if (v-&gt;data.boolean) {</a>
<a name="ln298">            params-&gt;flags |= flags[j].value;</a>
<a name="ln299">          }</a>
<a name="ln300">          key_used = true;</a>
<a name="ln301">          break;</a>
<a name="ln302">        }</a>
<a name="ln303">      }</a>
<a name="ln304"> </a>
<a name="ln305">      if (key_used) {</a>
<a name="ln306">        continue;</a>
<a name="ln307">      }</a>
<a name="ln308"> </a>
<a name="ln309">      api_set_error(err, kErrorTypeValidation, &quot;unexpected key: %s&quot;, k.data);</a>
<a name="ln310">      goto exit_1;</a>
<a name="ln311">    }</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  if (had_on_hunk) {</a>
<a name="ln315">    mode = kNluaXdiffModeOnHunkCB;</a>
<a name="ln316">  } else if (had_result_type_indices) {</a>
<a name="ln317">    mode = kNluaXdiffModeLocations;</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">exit_1:</a>
<a name="ln321">  api_free_dictionary(opts);</a>
<a name="ln322">  return mode;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">int nlua_xdl_diff(lua_State *lstate)</a>
<a name="ln326">{</a>
<a name="ln327">  if (lua_gettop(lstate) &lt; 2) {</a>
<a name="ln328">    return luaL_error(lstate, &quot;Expected at least 2 arguments&quot;);</a>
<a name="ln329">  }</a>
<a name="ln330">  mmfile_t ma = get_string_arg(lstate, 1);</a>
<a name="ln331">  mmfile_t mb = get_string_arg(lstate, 2);</a>
<a name="ln332"> </a>
<a name="ln333">  Error err = ERROR_INIT;</a>
<a name="ln334"> </a>
<a name="ln335">  xdemitconf_t cfg;</a>
<a name="ln336">  xpparam_t params;</a>
<a name="ln337">  xdemitcb_t ecb;</a>
<a name="ln338">  int64_t linematch = 0;</a>
<a name="ln339"> </a>
<a name="ln340">  CLEAR_FIELD(cfg);</a>
<a name="ln341">  CLEAR_FIELD(params);</a>
<a name="ln342">  CLEAR_FIELD(ecb);</a>
<a name="ln343"> </a>
<a name="ln344">  NluaXdiffMode mode = kNluaXdiffModeUnified;</a>
<a name="ln345"> </a>
<a name="ln346">  if (lua_gettop(lstate) == 3) {</a>
<a name="ln347">    if (lua_type(lstate, 3) != LUA_TTABLE) {</a>
<a name="ln348">      return luaL_argerror(lstate, 3, &quot;expected table&quot;);</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">    mode = process_xdl_diff_opts(lstate, &amp;cfg, &amp;params, &amp;linematch, &amp;err);</a>
<a name="ln352"> </a>
<a name="ln353">    if (ERROR_SET(&amp;err)) {</a>
<a name="ln354">      goto exit_0;</a>
<a name="ln355">    }</a>
<a name="ln356">  }</a>
<a name="ln357"> </a>
<a name="ln358">  luaL_Buffer buf;</a>
<a name="ln359">  hunkpriv_t priv;</a>
<a name="ln360">  switch (mode) {</a>
<a name="ln361">  case kNluaXdiffModeUnified:</a>
<a name="ln362">    luaL_buffinit(lstate, &amp;buf);</a>
<a name="ln363">    ecb.priv = &amp;buf;</a>
<a name="ln364">    ecb.out_line = write_string;</a>
<a name="ln365">    break;</a>
<a name="ln366">  case kNluaXdiffModeOnHunkCB:</a>
<a name="ln367">    cfg.hunk_func = call_on_hunk_cb;</a>
<a name="ln368">    priv = (hunkpriv_t) {</a>
<a name="ln369">      .lstate = lstate,</a>
<a name="ln370">      .err = &amp;err,</a>
<a name="ln371">    };</a>
<a name="ln372">    ecb.priv = &amp;priv;</a>
<a name="ln373">    break;</a>
<a name="ln374">  case kNluaXdiffModeLocations:</a>
<a name="ln375">    cfg.hunk_func = hunk_locations_cb;</a>
<a name="ln376">    priv = (hunkpriv_t) {</a>
<a name="ln377">      .lstate = lstate,</a>
<a name="ln378">      .ma = &amp;ma,</a>
<a name="ln379">      .mb = &amp;mb,</a>
<a name="ln380">      .linematch = linematch,</a>
<a name="ln381">      .iwhite = (params.flags &amp; XDF_IGNORE_WHITESPACE) &gt; 0</a>
<a name="ln382">    };</a>
<a name="ln383">    ecb.priv = &amp;priv;</a>
<a name="ln384">    lua_createtable(lstate, 0, 0);</a>
<a name="ln385">    break;</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  if (xdl_diff(&amp;ma, &amp;mb, &amp;params, &amp;cfg, &amp;ecb) == -1) {</a>
<a name="ln389">    if (!ERROR_SET(&amp;err)) {</a>
<a name="ln390">      api_set_error(&amp;err, kErrorTypeException,</a>
<a name="ln391">                    &quot;Error while performing diff operation&quot;);</a>
<a name="ln392">    }</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">exit_0:</a>
<a name="ln396">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln397">    luaL_where(lstate, 1);</a>
<a name="ln398">    lua_pushstring(lstate, err.msg);</a>
<a name="ln399">    api_clear_error(&amp;err);</a>
<a name="ln400">    lua_concat(lstate, 2);</a>
<a name="ln401">    return lua_error(lstate);</a>
<a name="ln402">  } else if (mode == kNluaXdiffModeUnified) {</a>
<a name="ln403">    luaL_pushresult(&amp;buf);</a>
<a name="ln404">    return 1;</a>
<a name="ln405">  } else if (mode == kNluaXdiffModeLocations) {</a>
<a name="ln406">    return 1;</a>
<a name="ln407">  }</a>
<a name="ln408">  return 0;</a>
<a name="ln409">}</a>
</code></pre>
<div class="balloon" rel="188"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'lua_tolstring' function will lead to overflow of the buffer '&amp; mf.size'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>