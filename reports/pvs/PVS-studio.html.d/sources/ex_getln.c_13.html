<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>ex_getln.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_getln.c: Functions for entering and editing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;limits.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13">#include &lt;time.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;klib/kvec.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/extmark.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln20">#include &quot;nvim/arabic.h&quot;</a>
<a name="ln21">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln22">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln24">#include &quot;nvim/charset.h&quot;</a>
<a name="ln25">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln26">#include &quot;nvim/cmdhist.h&quot;</a>
<a name="ln27">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln28">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln29">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln30">#include &quot;nvim/edit.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln33">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln36">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln37">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln38">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln39">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln40">#include &quot;nvim/garray.h&quot;</a>
<a name="ln41">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln42">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln43">#include &quot;nvim/globals.h&quot;</a>
<a name="ln44">#include &quot;nvim/grid.h&quot;</a>
<a name="ln45">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln46">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln47">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln48">#include &quot;nvim/macros.h&quot;</a>
<a name="ln49">#include &quot;nvim/map.h&quot;</a>
<a name="ln50">#include &quot;nvim/mapping.h&quot;</a>
<a name="ln51">#include &quot;nvim/mark.h&quot;</a>
<a name="ln52">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln53">#include &quot;nvim/memline.h&quot;</a>
<a name="ln54">#include &quot;nvim/memory.h&quot;</a>
<a name="ln55">#include &quot;nvim/message.h&quot;</a>
<a name="ln56">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln57">#include &quot;nvim/move.h&quot;</a>
<a name="ln58">#include &quot;nvim/normal.h&quot;</a>
<a name="ln59">#include &quot;nvim/ops.h&quot;</a>
<a name="ln60">#include &quot;nvim/option.h&quot;</a>
<a name="ln61">#include &quot;nvim/option_defs.h&quot;</a>
<a name="ln62">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln63">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln64">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln65">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln66">#include &quot;nvim/path.h&quot;</a>
<a name="ln67">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln68">#include &quot;nvim/pos.h&quot;</a>
<a name="ln69">#include &quot;nvim/profile.h&quot;</a>
<a name="ln70">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln71">#include &quot;nvim/search.h&quot;</a>
<a name="ln72">#include &quot;nvim/state.h&quot;</a>
<a name="ln73">#include &quot;nvim/strings.h&quot;</a>
<a name="ln74">#include &quot;nvim/ui.h&quot;</a>
<a name="ln75">#include &quot;nvim/undo.h&quot;</a>
<a name="ln76">#include &quot;nvim/usercmd.h&quot;</a>
<a name="ln77">#include &quot;nvim/vim.h&quot;</a>
<a name="ln78">#include &quot;nvim/viml/parser/expressions.h&quot;</a>
<a name="ln79">#include &quot;nvim/viml/parser/parser.h&quot;</a>
<a name="ln80">#include &quot;nvim/window.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">/// Last value of prompt_id, incremented when doing new prompt</a>
<a name="ln83">static unsigned last_prompt_id = 0;</a>
<a name="ln84"> </a>
<a name="ln85">// Struct to store the viewstate during 'incsearch' highlighting and 'inccommand' preview.</a>
<a name="ln86">typedef struct {</a>
<a name="ln87">  colnr_T vs_curswant;</a>
<a name="ln88">  colnr_T vs_leftcol;</a>
<a name="ln89">  colnr_T vs_skipcol;</a>
<a name="ln90">  linenr_T vs_topline;</a>
<a name="ln91">  int vs_topfill;</a>
<a name="ln92">  linenr_T vs_botline;</a>
<a name="ln93">  int vs_empty_rows;</a>
<a name="ln94">} viewstate_T;</a>
<a name="ln95"> </a>
<a name="ln96">// Struct to store the state of 'incsearch' highlighting.</a>
<a name="ln97">typedef struct {</a>
<a name="ln98">  pos_T search_start;   // where 'incsearch' starts searching</a>
<a name="ln99">  pos_T save_cursor;</a>
<a name="ln100">  viewstate_T init_viewstate;</a>
<a name="ln101">  viewstate_T old_viewstate;</a>
<a name="ln102">  pos_T match_start;</a>
<a name="ln103">  pos_T match_end;</a>
<a name="ln104">  bool did_incsearch;</a>
<a name="ln105">  bool incsearch_postponed;</a>
<a name="ln106">  optmagic_T magic_overruled_save;</a>
<a name="ln107">} incsearch_state_T;</a>
<a name="ln108"> </a>
<a name="ln109">typedef struct command_line_state {</a>
<a name="ln110">  VimState state;</a>
<a name="ln111">  int firstc;</a>
<a name="ln112">  int count;</a>
<a name="ln113">  int indent;</a>
<a name="ln114">  int c;</a>
<a name="ln115">  int gotesc;                           // true when &lt;ESC&gt; just typed</a>
<a name="ln116">  int do_abbr;                          // when true check for abbr.</a>
<a name="ln117">  char *lookfor;                        // string to match</a>
<a name="ln118">  int hiscnt;                           // current history line in use</a>
<a name="ln119">  int save_hiscnt;                      // history line before attempting</a>
<a name="ln120">                                        // to jump to next match</a>
<a name="ln121">  int histype;                          // history type to be used</a>
<a name="ln122">  incsearch_state_T is_state;</a>
<a name="ln123">  int did_wild_list;                    // did wild_list() recently</a>
<a name="ln124">  int wim_index;                        // index in wim_flags[]</a>
<a name="ln125">  int save_msg_scroll;</a>
<a name="ln126">  int save_State;                 // remember State when called</a>
<a name="ln127">  char *save_p_icm;</a>
<a name="ln128">  int some_key_typed;                   // one of the keys was typed</a>
<a name="ln129">  // mouse drag and release events are ignored, unless they are</a>
<a name="ln130">  // preceded with a mouse down event</a>
<a name="ln131">  int ignore_drag_release;</a>
<a name="ln132">  int break_ctrl_c;</a>
<a name="ln133">  expand_T xpc;</a>
<a name="ln134">  OptInt *b_im_ptr;</a>
<a name="ln135">  buf_T *b_im_ptr_buf;  ///&lt; buffer where b_im_ptr is valid</a>
<a name="ln136">} CommandLineState;</a>
<a name="ln137"> </a>
<a name="ln138">typedef struct cmdpreview_undo_info {</a>
<a name="ln139">  u_header_T *save_b_u_oldhead;</a>
<a name="ln140">  u_header_T *save_b_u_newhead;</a>
<a name="ln141">  u_header_T *save_b_u_curhead;</a>
<a name="ln142">  int save_b_u_numhead;</a>
<a name="ln143">  bool save_b_u_synced;</a>
<a name="ln144">  long save_b_u_seq_last;</a>
<a name="ln145">  long save_b_u_save_nr_last;</a>
<a name="ln146">  long save_b_u_seq_cur;</a>
<a name="ln147">  time_t save_b_u_time_cur;</a>
<a name="ln148">  long save_b_u_save_nr_cur;</a>
<a name="ln149">  char *save_b_u_line_ptr;</a>
<a name="ln150">  linenr_T save_b_u_line_lnum;</a>
<a name="ln151">  colnr_T save_b_u_line_colnr;</a>
<a name="ln152">} CpUndoInfo;</a>
<a name="ln153"> </a>
<a name="ln154">typedef struct cmdpreview_buf_info {</a>
<a name="ln155">  buf_T *buf;</a>
<a name="ln156">  OptInt save_b_p_ul;</a>
<a name="ln157">  int save_b_changed;</a>
<a name="ln158">  varnumber_T save_changedtick;</a>
<a name="ln159">  CpUndoInfo undo_info;</a>
<a name="ln160">} CpBufInfo;</a>
<a name="ln161"> </a>
<a name="ln162">typedef struct cmdpreview_win_info {</a>
<a name="ln163">  win_T *win;</a>
<a name="ln164">  pos_T save_w_cursor;</a>
<a name="ln165">  viewstate_T save_viewstate;</a>
<a name="ln166">  int save_w_p_cul;</a>
<a name="ln167">  int save_w_p_cuc;</a>
<a name="ln168">} CpWinInfo;</a>
<a name="ln169"> </a>
<a name="ln170">typedef struct cmdpreview_info {</a>
<a name="ln171">  kvec_t(CpWinInfo) win_info;</a>
<a name="ln172">  kvec_t(CpBufInfo) buf_info;</a>
<a name="ln173">  bool save_hls;</a>
<a name="ln174">  cmdmod_T save_cmdmod;</a>
<a name="ln175">  garray_T save_view;</a>
<a name="ln176">} CpInfo;</a>
<a name="ln177"> </a>
<a name="ln178">/// Return value when handling keys in command-line mode.</a>
<a name="ln179">enum {</a>
<a name="ln180">  CMDLINE_NOT_CHANGED = 1,</a>
<a name="ln181">  CMDLINE_CHANGED     = 2,</a>
<a name="ln182">  GOTO_NORMAL_MODE    = 3,</a>
<a name="ln183">  PROCESS_NEXT_KEY    = 4,</a>
<a name="ln184">};</a>
<a name="ln185"> </a>
<a name="ln186">/// The current cmdline_info.  It is initialized in getcmdline() and after that</a>
<a name="ln187">/// used by other functions.  When invoking getcmdline() recursively it needs</a>
<a name="ln188">/// to be saved with save_cmdline() and restored with restore_cmdline().</a>
<a name="ln189">static CmdlineInfo ccline;</a>
<a name="ln190"> </a>
<a name="ln191">static int new_cmdpos;          // position set by set_cmdline_pos()</a>
<a name="ln192"> </a>
<a name="ln193">/// currently displayed block of context</a>
<a name="ln194">static Array cmdline_block = ARRAY_DICT_INIT;</a>
<a name="ln195"> </a>
<a name="ln196">/// Flag for command_line_handle_key to ignore &lt;C-c&gt;</a>
<a name="ln197">///</a>
<a name="ln198">/// Used if it was received while processing highlight function in order for</a>
<a name="ln199">/// user interrupting highlight function to not interrupt command-line.</a>
<a name="ln200">static bool getln_interrupted_highlight = false;</a>
<a name="ln201"> </a>
<a name="ln202">static int cedit_key = -1;  ///&lt; key value of 'cedit' option</a>
<a name="ln203"> </a>
<a name="ln204">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln205"># include &quot;ex_getln.c.generated.h&quot;</a>
<a name="ln206">#endif</a>
<a name="ln207"> </a>
<a name="ln208">static handle_T cmdpreview_bufnr = 0;</a>
<a name="ln209">static long cmdpreview_ns = 0;</a>
<a name="ln210"> </a>
<a name="ln211">static void save_viewstate(win_T *wp, viewstate_T *vs)</a>
<a name="ln212">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln213">{</a>
<a name="ln214">  vs-&gt;vs_curswant = wp-&gt;w_curswant;</a>
<a name="ln215">  vs-&gt;vs_leftcol = wp-&gt;w_leftcol;</a>
<a name="ln216">  vs-&gt;vs_skipcol = wp-&gt;w_skipcol;</a>
<a name="ln217">  vs-&gt;vs_topline = wp-&gt;w_topline;</a>
<a name="ln218">  vs-&gt;vs_topfill = wp-&gt;w_topfill;</a>
<a name="ln219">  vs-&gt;vs_botline = wp-&gt;w_botline;</a>
<a name="ln220">  vs-&gt;vs_empty_rows = wp-&gt;w_empty_rows;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static void restore_viewstate(win_T *wp, viewstate_T *vs)</a>
<a name="ln224">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln225">{</a>
<a name="ln226">  wp-&gt;w_curswant = vs-&gt;vs_curswant;</a>
<a name="ln227">  wp-&gt;w_leftcol = vs-&gt;vs_leftcol;</a>
<a name="ln228">  wp-&gt;w_skipcol = vs-&gt;vs_skipcol;</a>
<a name="ln229">  wp-&gt;w_topline = vs-&gt;vs_topline;</a>
<a name="ln230">  wp-&gt;w_topfill = vs-&gt;vs_topfill;</a>
<a name="ln231">  wp-&gt;w_botline = vs-&gt;vs_botline;</a>
<a name="ln232">  wp-&gt;w_empty_rows = vs-&gt;vs_empty_rows;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">static void init_incsearch_state(incsearch_state_T *s)</a>
<a name="ln236">{</a>
<a name="ln237">  s-&gt;match_start = curwin-&gt;w_cursor;</a>
<a name="ln238">  s-&gt;did_incsearch = false;</a>
<a name="ln239">  s-&gt;incsearch_postponed = false;</a>
<a name="ln240">  s-&gt;magic_overruled_save = magic_overruled;</a>
<a name="ln241">  clearpos(&amp;s-&gt;match_end);</a>
<a name="ln242">  s-&gt;save_cursor = curwin-&gt;w_cursor;  // may be restored later</a>
<a name="ln243">  s-&gt;search_start = curwin-&gt;w_cursor;</a>
<a name="ln244">  save_viewstate(curwin, &amp;s-&gt;init_viewstate);</a>
<a name="ln245">  save_viewstate(curwin, &amp;s-&gt;old_viewstate);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">// Return true when 'incsearch' highlighting is to be done.</a>
<a name="ln249">// Sets search_first_line and search_last_line to the address range.</a>
<a name="ln250">static bool do_incsearch_highlighting(int firstc, int *search_delim, incsearch_state_T *s,</a>
<a name="ln251">                                      int *skiplen, int *patlen)</a>
<a name="ln252">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln253">{</a>
<a name="ln254">  char *cmd;</a>
<a name="ln255">  char *p;</a>
<a name="ln256">  bool delim_optional = false;</a>
<a name="ln257">  int delim;</a>
<a name="ln258">  char *end;</a>
<a name="ln259">  const char *dummy;</a>
<a name="ln260">  pos_T save_cursor;</a>
<a name="ln261">  bool use_last_pat;</a>
<a name="ln262">  bool retval = false;</a>
<a name="ln263">  magic_T magic = 0;</a>
<a name="ln264"> </a>
<a name="ln265">  *skiplen = 0;</a>
<a name="ln266">  *patlen = ccline.cmdlen;</a>
<a name="ln267"> </a>
<a name="ln268">  if (!p_is || cmd_silent) {</a>
<a name="ln269">    return false;</a>
<a name="ln270">  }</a>
<a name="ln271"> </a>
<a name="ln272">  // by default search all lines</a>
<a name="ln273">  search_first_line = 0;</a>
<a name="ln274">  search_last_line = MAXLNUM;</a>
<a name="ln275"> </a>
<a name="ln276">  if (firstc == '/' || firstc == '?') {</a>
<a name="ln277">    *search_delim = firstc;</a>
<a name="ln278">    return true;</a>
<a name="ln279">  }</a>
<a name="ln280">  if (firstc != ':') {</a>
<a name="ln281">    return false;</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  emsg_off++;</a>
<a name="ln285">  exarg_T ea = {</a>
<a name="ln286">    .line1 = 1,</a>
<a name="ln287">    .line2 = 1,</a>
<a name="ln288">    .cmd = ccline.cmdbuff,</a>
<a name="ln289">    .addr_type = ADDR_LINES,</a>
<a name="ln290">  };</a>
<a name="ln291"> </a>
<a name="ln292">  cmdmod_T dummy_cmdmod;</a>
<a name="ln293">  parse_command_modifiers(&amp;ea, &amp;dummy, &amp;dummy_cmdmod, true);</a>
<a name="ln294"> </a>
<a name="ln295">  cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln296">  if (vim_strchr(&quot;sgvl&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln297">    goto theend;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  // Skip over &quot;substitute&quot; to find the pattern separator.</a>
<a name="ln301">  for (p = cmd; ASCII_ISALPHA(*p); p++) {}</a>
<a name="ln302">  if (*skipwhite(p) == NUL) {</a>
<a name="ln303">    goto theend;</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  if (strncmp(cmd, &quot;substitute&quot;, (size_t)(p - cmd)) == 0</a>
<a name="ln307">      || strncmp(cmd, &quot;smagic&quot;, (size_t)(p - cmd)) == 0</a>
<a name="ln308">      || strncmp(cmd, &quot;snomagic&quot;, (size_t)MAX(p - cmd, 3)) == 0</a>
<a name="ln309">      || strncmp(cmd, &quot;vglobal&quot;, (size_t)(p - cmd)) == 0) {</a>
<a name="ln310">    if (*cmd == 's' &amp;&amp; cmd[1] == 'm') {</a>
<a name="ln311">      magic_overruled = OPTION_MAGIC_ON;</a>
<a name="ln312">    } else if (*cmd == 's' &amp;&amp; cmd[1] == 'n') {</a>
<a name="ln313">      magic_overruled = OPTION_MAGIC_OFF;</a>
<a name="ln314">    }</a>
<a name="ln315">  } else if (strncmp(cmd, &quot;sort&quot;, (size_t)MAX(p - cmd, 3)) == 0) {</a>
<a name="ln316">    // skip over ! and flags</a>
<a name="ln317">    if (*p == '!') {</a>
<a name="ln318">      p = skipwhite(p + 1);</a>
<a name="ln319">    }</a>
<a name="ln320">    while (ASCII_ISALPHA(*(p = skipwhite(p)))) {</a>
<a name="ln321">      p++;</a>
<a name="ln322">    }</a>
<a name="ln323">    if (*p == NUL) {</a>
<a name="ln324">      goto theend;</a>
<a name="ln325">    }</a>
<a name="ln326">  } else if (strncmp(cmd, &quot;vimgrep&quot;, (size_t)MAX(p - cmd, 3)) == 0</a>
<a name="ln327">             || strncmp(cmd, &quot;vimgrepadd&quot;, (size_t)MAX(p - cmd, 8)) == 0</a>
<a name="ln328">             || strncmp(cmd, &quot;lvimgrep&quot;, (size_t)MAX(p - cmd, 2)) == 0</a>
<a name="ln329">             || strncmp(cmd, &quot;lvimgrepadd&quot;, (size_t)MAX(p - cmd, 9)) == 0</a>
<a name="ln330">             || strncmp(cmd, &quot;global&quot;, (size_t)(p - cmd)) == 0) {</a>
<a name="ln331">    // skip over &quot;!/&quot;.</a>
<a name="ln332">    if (*p == '!') {</a>
<a name="ln333">      p++;</a>
<a name="ln334">      if (*skipwhite(p) == NUL) {</a>
<a name="ln335">        goto theend;</a>
<a name="ln336">      }</a>
<a name="ln337">    }</a>
<a name="ln338">    if (*cmd != 'g') {</a>
<a name="ln339">      delim_optional = true;</a>
<a name="ln340">    }</a>
<a name="ln341">  } else {</a>
<a name="ln342">    goto theend;</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  p = skipwhite(p);</a>
<a name="ln346">  delim = (delim_optional &amp;&amp; vim_isIDc((uint8_t)(*p))) ? ' ' : *p++;</a>
<a name="ln347">  *search_delim = delim;</a>
<a name="ln348">  end = skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &amp;magic);</a>
<a name="ln349"> </a>
<a name="ln350">  use_last_pat = end == p &amp;&amp; *end == delim;</a>
<a name="ln351">  if (end == p &amp;&amp; !use_last_pat) {</a>
<a name="ln352">    goto theend;</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  // Don't do 'hlsearch' highlighting if the pattern matches everything.</a>
<a name="ln356">  if (!use_last_pat) {</a>
<a name="ln357">    char c = *end;</a>
<a name="ln358">    *end = NUL;</a>
<a name="ln359">    bool empty = empty_pattern_magic(p, strlen(p), magic);</a>
<a name="ln360">    *end = c;</a>
<a name="ln361">    if (empty) {</a>
<a name="ln362">      goto theend;</a>
<a name="ln363">    }</a>
<a name="ln364">  }</a>
<a name="ln365"> </a>
<a name="ln366">  // found a non-empty pattern or //</a>
<a name="ln367">  *skiplen = (int)(p - ccline.cmdbuff);</a>
<a name="ln368">  *patlen = (int)(end - p);</a>
<a name="ln369"> </a>
<a name="ln370">  // parse the address range</a>
<a name="ln371">  save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln372">  curwin-&gt;w_cursor = s-&gt;search_start;</a>
<a name="ln373">  parse_cmd_address(&amp;ea, &amp;dummy, true);</a>
<a name="ln374">  if (ea.addr_count &gt; 0) {</a>
<a name="ln375">    // Allow for reverse match.</a>
<a name="ln376">    if (ea.line2 &lt; ea.line1) {</a>
<a name="ln377">      search_first_line = ea.line2;</a>
<a name="ln378">      search_last_line = ea.line1;</a>
<a name="ln379">    } else {</a>
<a name="ln380">      search_first_line = ea.line1;</a>
<a name="ln381">      search_last_line = ea.line2;</a>
<a name="ln382">    }</a>
<a name="ln383">  } else if (cmd[0] == 's' &amp;&amp; cmd[1] != 'o') {</a>
<a name="ln384">    // :s defaults to the current line</a>
<a name="ln385">    search_first_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln386">    search_last_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln390">  retval = true;</a>
<a name="ln391">theend:</a>
<a name="ln392">  emsg_off--;</a>
<a name="ln393">  return retval;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">// May do 'incsearch' highlighting if desired.</a>
<a name="ln397">static void may_do_incsearch_highlighting(int firstc, int count, incsearch_state_T *s)</a>
<a name="ln398">{</a>
<a name="ln399">  pos_T end_pos;</a>
<a name="ln400">  proftime_T tm;</a>
<a name="ln401">  int skiplen, patlen;</a>
<a name="ln402">  char next_char;</a>
<a name="ln403">  bool use_last_pat;</a>
<a name="ln404">  int search_delim;</a>
<a name="ln405"> </a>
<a name="ln406">  // Parsing range may already set the last search pattern.</a>
<a name="ln407">  // NOTE: must call restore_last_search_pattern() before returning!</a>
<a name="ln408">  save_last_search_pattern();</a>
<a name="ln409"> </a>
<a name="ln410">  if (!do_incsearch_highlighting(firstc, &amp;search_delim, s, &amp;skiplen,</a>
<a name="ln411">                                 &amp;patlen)) {</a>
<a name="ln412">    restore_last_search_pattern();</a>
<a name="ln413">    finish_incsearch_highlighting(false, s, true);</a>
<a name="ln414">    return;</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  // if there is a character waiting, search and redraw later</a>
<a name="ln418">  if (char_avail()) {</a>
<a name="ln419">    restore_last_search_pattern();</a>
<a name="ln420">    s-&gt;incsearch_postponed = true;</a>
<a name="ln421">    return;</a>
<a name="ln422">  }</a>
<a name="ln423">  s-&gt;incsearch_postponed = false;</a>
<a name="ln424"> </a>
<a name="ln425">  if (search_first_line == 0) {</a>
<a name="ln426">    // start at the original cursor position</a>
<a name="ln427">    curwin-&gt;w_cursor = s-&gt;search_start;</a>
<a name="ln428">  } else if (search_first_line &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln429">    // start after the last line</a>
<a name="ln430">    curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln431">    curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln432">  } else {</a>
<a name="ln433">    // start at the first line in the range</a>
<a name="ln434">    curwin-&gt;w_cursor.lnum = search_first_line;</a>
<a name="ln435">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln436">  }</a>
<a name="ln437">  int found;  // do_search() result</a>
<a name="ln438"> </a>
<a name="ln439">  // Use the previous pattern for &quot;:s//&quot;.</a>
<a name="ln440">  next_char = ccline.cmdbuff[skiplen + patlen];</a>
<a name="ln441">  use_last_pat = patlen == 0 &amp;&amp; skiplen &gt; 0</a>
<a name="ln442">                 &amp;&amp; ccline.cmdbuff[skiplen - 1] == next_char;</a>
<a name="ln443"> </a>
<a name="ln444">  // If there is no pattern, don't do anything.</a>
<a name="ln445">  if (patlen == 0 &amp;&amp; !use_last_pat) {</a>
<a name="ln446">    found = 0;</a>
<a name="ln447">    set_no_hlsearch(true);  // turn off previous highlight</a>
<a name="ln448">    redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln449">  } else {</a>
<a name="ln450">    int search_flags = SEARCH_OPT + SEARCH_NOOF + SEARCH_PEEK;</a>
<a name="ln451">    ui_busy_start();</a>
<a name="ln452">    ui_flush();</a>
<a name="ln453">    emsg_off++;            // So it doesn't beep if bad expr</a>
<a name="ln454">    // Set the time limit to half a second.</a>
<a name="ln455">    tm = profile_setlimit(500L);</a>
<a name="ln456">    if (!p_hls) {</a>
<a name="ln457">      search_flags += SEARCH_KEEP;</a>
<a name="ln458">    }</a>
<a name="ln459">    if (search_first_line != 0) {</a>
<a name="ln460">      search_flags += SEARCH_START;</a>
<a name="ln461">    }</a>
<a name="ln462">    ccline.cmdbuff[skiplen + patlen] = NUL;</a>
<a name="ln463">    searchit_arg_T sia = {</a>
<a name="ln464">      .sa_tm = &amp;tm,</a>
<a name="ln465">    };</a>
<a name="ln466">    found = do_search(NULL, firstc == ':' ? '/' : firstc, search_delim,</a>
<a name="ln467">                      ccline.cmdbuff + skiplen, count,</a>
<a name="ln468">                      search_flags, &amp;sia);</a>
<a name="ln469">    ccline.cmdbuff[skiplen + patlen] = next_char;</a>
<a name="ln470">    emsg_off--;</a>
<a name="ln471">    if (curwin-&gt;w_cursor.lnum &lt; search_first_line</a>
<a name="ln472">        || curwin-&gt;w_cursor.lnum &gt; search_last_line) {</a>
<a name="ln473">      // match outside of address range</a>
<a name="ln474">      found = 0;</a>
<a name="ln475">      curwin-&gt;w_cursor = s-&gt;search_start;</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    // if interrupted while searching, behave like it failed</a>
<a name="ln479">    if (got_int) {</a>
<a name="ln480">      (void)vpeekc();               // remove &lt;C-C&gt; from input stream</a>
<a name="ln481">      got_int = false;              // don't abandon the command line</a>
<a name="ln482">      found = 0;</a>
<a name="ln483">    } else if (char_avail()) {</a>
<a name="ln484">      // cancelled searching because a char was typed</a>
<a name="ln485">      s-&gt;incsearch_postponed = true;</a>
<a name="ln486">    }</a>
<a name="ln487">    ui_busy_stop();</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490">  if (found != 0) {</a>
<a name="ln491">    highlight_match = true;   // highlight position</a>
<a name="ln492">  } else {</a>
<a name="ln493">    highlight_match = false;  // remove highlight</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  // first restore the old curwin values, so the screen is</a>
<a name="ln497">  // positioned in the same way as the actual search command</a>
<a name="ln498">  restore_viewstate(curwin, &amp;s-&gt;old_viewstate);</a>
<a name="ln499">  changed_cline_bef_curs(curwin);</a>
<a name="ln500">  update_topline(curwin);</a>
<a name="ln501"> </a>
<a name="ln502">  if (found != 0) {</a>
<a name="ln503">    pos_T save_pos = curwin-&gt;w_cursor;</a>
<a name="ln504"> </a>
<a name="ln505">    s-&gt;match_start = curwin-&gt;w_cursor;</a>
<a name="ln506">    set_search_match(&amp;curwin-&gt;w_cursor);</a>
<a name="ln507">    validate_cursor();</a>
<a name="ln508">    end_pos = curwin-&gt;w_cursor;</a>
<a name="ln509">    s-&gt;match_end = end_pos;</a>
<a name="ln510">    curwin-&gt;w_cursor = save_pos;</a>
<a name="ln511">  } else {</a>
<a name="ln512">    end_pos = curwin-&gt;w_cursor;         // shutup gcc 4</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  // Disable 'hlsearch' highlighting if the pattern matches</a>
<a name="ln516">  // everything. Avoids a flash when typing &quot;foo\|&quot;.</a>
<a name="ln517">  if (!use_last_pat) {</a>
<a name="ln518">    next_char = ccline.cmdbuff[skiplen + patlen];</a>
<a name="ln519">    ccline.cmdbuff[skiplen + patlen] = NUL;</a>
<a name="ln520">    if (empty_pattern(ccline.cmdbuff + skiplen, search_delim) &amp;&amp; !no_hlsearch) {</a>
<a name="ln521">      redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln522">      set_no_hlsearch(true);</a>
<a name="ln523">    }</a>
<a name="ln524">    ccline.cmdbuff[skiplen + patlen] = next_char;</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  validate_cursor();</a>
<a name="ln528"> </a>
<a name="ln529">  // May redraw the status line to show the cursor position.</a>
<a name="ln530">  if (p_ru &amp;&amp; (curwin-&gt;w_status_height &gt; 0 || global_stl_height() &gt; 0)) {</a>
<a name="ln531">    curwin-&gt;w_redr_status = true;</a>
<a name="ln532">  }</a>
<a name="ln533"> </a>
<a name="ln534">  redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln535">  update_screen();</a>
<a name="ln536">  highlight_match = false;</a>
<a name="ln537">  restore_last_search_pattern();</a>
<a name="ln538"> </a>
<a name="ln539">  // Leave it at the end to make CTRL-R CTRL-W work.  But not when beyond the</a>
<a name="ln540">  // end of the pattern, e.g. for &quot;:s/pat/&quot;.</a>
<a name="ln541">  if (ccline.cmdbuff[skiplen + patlen] != NUL) {</a>
<a name="ln542">    curwin-&gt;w_cursor = s-&gt;search_start;</a>
<a name="ln543">  } else if (found != 0) {</a>
<a name="ln544">    curwin-&gt;w_cursor = end_pos;</a>
<a name="ln545">  }</a>
<a name="ln546"> </a>
<a name="ln547">  msg_starthere();</a>
<a name="ln548">  redrawcmdline();</a>
<a name="ln549">  s-&gt;did_incsearch = true;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">// When CTRL-L typed: add character from the match to the pattern.</a>
<a name="ln553">// May set &quot;*c&quot; to the added character.</a>
<a name="ln554">// Return OK when calling command_line_not_changed.</a>
<a name="ln555">static int may_add_char_to_search(int firstc, int *c, incsearch_state_T *s)</a>
<a name="ln556">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln557">{</a>
<a name="ln558">  int skiplen, patlen;</a>
<a name="ln559">  int search_delim;</a>
<a name="ln560"> </a>
<a name="ln561">  // Parsing range may already set the last search pattern.</a>
<a name="ln562">  // NOTE: must call restore_last_search_pattern() before returning!</a>
<a name="ln563">  save_last_search_pattern();</a>
<a name="ln564"> </a>
<a name="ln565">  // Add a character from under the cursor for 'incsearch'</a>
<a name="ln566">  if (!do_incsearch_highlighting(firstc, &amp;search_delim, s, &amp;skiplen,</a>
<a name="ln567">                                 &amp;patlen)) {</a>
<a name="ln568">    restore_last_search_pattern();</a>
<a name="ln569">    return FAIL;</a>
<a name="ln570">  }</a>
<a name="ln571">  restore_last_search_pattern();</a>
<a name="ln572"> </a>
<a name="ln573">  if (s-&gt;did_incsearch) {</a>
<a name="ln574">    curwin-&gt;w_cursor = s-&gt;match_end;</a>
<a name="ln575">    *c = gchar_cursor();</a>
<a name="ln576">    if (*c != NUL) {</a>
<a name="ln577">      // If 'ignorecase' and 'smartcase' are set and the</a>
<a name="ln578">      // command line has no uppercase characters, convert</a>
<a name="ln579">      // the character to lowercase</a>
<a name="ln580">      if (p_ic &amp;&amp; p_scs</a>
<a name="ln581">          &amp;&amp; !pat_has_uppercase(ccline.cmdbuff + skiplen)) {</a>
<a name="ln582">        *c = mb_tolower(*c);</a>
<a name="ln583">      }</a>
<a name="ln584">      if (*c == search_delim</a>
<a name="ln585">          || vim_strchr((magic_isset() ? &quot;\\~^$.*[&quot; : &quot;\\^$&quot;), *c) != NULL) {</a>
<a name="ln586">        // put a backslash before special characters</a>
<a name="ln587">        stuffcharReadbuff(*c);</a>
<a name="ln588">        *c = '\\';</a>
<a name="ln589">      }</a>
<a name="ln590">      return FAIL;</a>
<a name="ln591">    }</a>
<a name="ln592">  }</a>
<a name="ln593">  return OK;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static void finish_incsearch_highlighting(int gotesc, incsearch_state_T *s, bool call_update_screen)</a>
<a name="ln597">{</a>
<a name="ln598">  if (!s-&gt;did_incsearch) {</a>
<a name="ln599">    return;</a>
<a name="ln600">  }</a>
<a name="ln601"> </a>
<a name="ln602">  s-&gt;did_incsearch = false;</a>
<a name="ln603">  if (gotesc) {</a>
<a name="ln604">    curwin-&gt;w_cursor = s-&gt;save_cursor;</a>
<a name="ln605">  } else {</a>
<a name="ln606">    if (!equalpos(s-&gt;save_cursor, s-&gt;search_start)) {</a>
<a name="ln607">      // put the '&quot; mark at the original position</a>
<a name="ln608">      curwin-&gt;w_cursor = s-&gt;save_cursor;</a>
<a name="ln609">      setpcmark();</a>
<a name="ln610">    }</a>
<a name="ln611">    curwin-&gt;w_cursor = s-&gt;search_start;  // -V519</a>
<a name="ln612">  }</a>
<a name="ln613">  restore_viewstate(curwin, &amp;s-&gt;old_viewstate);</a>
<a name="ln614">  highlight_match = false;</a>
<a name="ln615"> </a>
<a name="ln616">  // by default search all lines</a>
<a name="ln617">  search_first_line = 0;</a>
<a name="ln618">  search_last_line = MAXLNUM;</a>
<a name="ln619"> </a>
<a name="ln620">  magic_overruled = s-&gt;magic_overruled_save;</a>
<a name="ln621"> </a>
<a name="ln622">  validate_cursor();          // needed for TAB</a>
<a name="ln623">  status_redraw_all();</a>
<a name="ln624">  redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln625">  if (call_update_screen) {</a>
<a name="ln626">    update_screen();</a>
<a name="ln627">  }</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">/// Initialize the current command-line info.</a>
<a name="ln631">static void init_ccline(int firstc, int indent)</a>
<a name="ln632">{</a>
<a name="ln633">  ccline.overstrike = false;                // always start in insert mode</a>
<a name="ln634"> </a>
<a name="ln635">  assert(indent &gt;= 0);</a>
<a name="ln636"> </a>
<a name="ln637">  // set some variables for redrawcmd()</a>
<a name="ln638">  ccline.cmdfirstc = (firstc == '@' ? 0 : firstc);</a>
<a name="ln639">  ccline.cmdindent = (firstc &gt; 0 ? indent : 0);</a>
<a name="ln640"> </a>
<a name="ln641">  // alloc initial ccline.cmdbuff</a>
<a name="ln642">  alloc_cmdbuff(indent + 50);</a>
<a name="ln643">  ccline.cmdlen = ccline.cmdpos = 0;</a>
<a name="ln644">  ccline.cmdbuff[0] = NUL;</a>
<a name="ln645"> </a>
<a name="ln646">  ccline.last_colors = (ColoredCmdline){ .cmdbuff = NULL,</a>
<a name="ln647">                                         .colors = KV_INITIAL_VALUE };</a>
<a name="ln648">  sb_text_start_cmdline();</a>
<a name="ln649"> </a>
<a name="ln650">  // autoindent for :insert and :append</a>
<a name="ln651">  if (firstc &lt;= 0) {</a>
<a name="ln652">    memset(ccline.cmdbuff, ' ', (size_t)indent);</a>
<a name="ln653">    ccline.cmdbuff[indent] = NUL;</a>
<a name="ln654">    ccline.cmdpos = indent;</a>
<a name="ln655">    ccline.cmdspos = indent;</a>
<a name="ln656">    ccline.cmdlen = indent;</a>
<a name="ln657">  }</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">/// Internal entry point for cmdline mode.</a>
<a name="ln661">///</a>
<a name="ln662">/// @param count  only used for incremental search</a>
<a name="ln663">/// @param indent  indent for inside conditionals</a>
<a name="ln664">/// @param clear_ccline  clear ccline first</a>
<a name="ln665">static uint8_t *command_line_enter(int firstc, int count, int indent, bool clear_ccline)</a>
<a name="ln666">{</a>
<a name="ln667">  // can be invoked recursively, identify each level</a>
<a name="ln668">  static int cmdline_level = 0;</a>
<a name="ln669">  cmdline_level++;</a>
<a name="ln670"> </a>
<a name="ln671">  bool save_cmdpreview = cmdpreview;</a>
<a name="ln672">  cmdpreview = false;</a>
<a name="ln673">  CommandLineState state = {</a>
<a name="ln674">    .firstc = firstc,</a>
<a name="ln675">    .count = count,</a>
<a name="ln676">    .indent = indent,</a>
<a name="ln677">    .save_msg_scroll = msg_scroll,</a>
<a name="ln678">    .save_State = State,</a>
<a name="ln679">    .ignore_drag_release = true,</a>
<a name="ln680">  };</a>
<a name="ln681">  CommandLineState *s = &amp;state;</a>
<a name="ln682">  s-&gt;save_p_icm = xstrdup(p_icm);</a>
<a name="ln683">  init_incsearch_state(&amp;s-&gt;is_state);</a>
<a name="ln684">  CmdlineInfo save_ccline;</a>
<a name="ln685">  bool did_save_ccline = false;</a>
<a name="ln686"> </a>
<a name="ln687">  if (ccline.cmdbuff != NULL) {</a>
<a name="ln688">    // Currently ccline can never be in use if clear_ccline is false.</a>
<a name="ln689">    // Some changes will be needed if this is no longer the case.</a>
<a name="ln690">    assert(clear_ccline);</a>
<a name="ln691">    // Being called recursively.  Since ccline is global, we need to save</a>
<a name="ln692">    // the current buffer and restore it when returning.</a>
<a name="ln693">    save_cmdline(&amp;save_ccline);</a>
<a name="ln694">    did_save_ccline = true;</a>
<a name="ln695">  } else if (clear_ccline) {</a>
<a name="ln696">    CLEAR_FIELD(ccline);</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  if (s-&gt;firstc == -1) {</a>
<a name="ln700">    s-&gt;firstc = NUL;</a>
<a name="ln701">    s-&gt;break_ctrl_c = true;</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  init_ccline(s-&gt;firstc, s-&gt;indent);</a>
<a name="ln705">  ccline.prompt_id = last_prompt_id++;</a>
<a name="ln706">  ccline.level = cmdline_level;</a>
<a name="ln707"> </a>
<a name="ln708">  if (cmdline_level == 50) {</a>
<a name="ln709">    // Somehow got into a loop recursively calling getcmdline(), bail out.</a>
<a name="ln710">    emsg(_(e_command_too_recursive));</a>
<a name="ln711">    goto theend;</a>
<a name="ln712">  }</a>
<a name="ln713"> </a>
<a name="ln714">  ExpandInit(&amp;s-&gt;xpc);</a>
<a name="ln715">  ccline.xpc = &amp;s-&gt;xpc;</a>
<a name="ln716"> </a>
<a name="ln717">  if (curwin-&gt;w_p_rl &amp;&amp; *curwin-&gt;w_p_rlc == 's'</a>
<a name="ln718">      &amp;&amp; (s-&gt;firstc == '/' || s-&gt;firstc == '?')) {</a>
<a name="ln719">    cmdmsg_rl = true;</a>
<a name="ln720">  } else {</a>
<a name="ln721">    cmdmsg_rl = false;</a>
<a name="ln722">  }</a>
<a name="ln723"> </a>
<a name="ln724">  msg_grid_validate();</a>
<a name="ln725"> </a>
<a name="ln726">  redir_off = true;             // don't redirect the typed command</a>
<a name="ln727">  if (!cmd_silent) {</a>
<a name="ln728">    gotocmdline(true);</a>
<a name="ln729">    redrawcmdprompt();          // draw prompt or indent</a>
<a name="ln730">    ccline.cmdspos = cmd_startcol();</a>
<a name="ln731">    if (!msg_scroll) {</a>
<a name="ln732">      msg_ext_clear(false);</a>
<a name="ln733">    }</a>
<a name="ln734">  }</a>
<a name="ln735">  s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln736">  s-&gt;xpc.xp_backslash = XP_BS_NONE;</a>
<a name="ln737">#ifndef BACKSLASH_IN_FILENAME</a>
<a name="ln738">  s-&gt;xpc.xp_shell = false;</a>
<a name="ln739">#endif</a>
<a name="ln740"> </a>
<a name="ln741">  if (ccline.input_fn) {</a>
<a name="ln742">    s-&gt;xpc.xp_context = ccline.xp_context;</a>
<a name="ln743">    s-&gt;xpc.xp_pattern = ccline.cmdbuff;</a>
<a name="ln744">    s-&gt;xpc.xp_arg = ccline.xp_arg;</a>
<a name="ln745">  }</a>
<a name="ln746"> </a>
<a name="ln747">  // Avoid scrolling when called by a recursive do_cmdline(), e.g. when</a>
<a name="ln748">  // doing &quot;:@0&quot; when register 0 doesn't contain a CR.</a>
<a name="ln749">  msg_scroll = false;</a>
<a name="ln750"> </a>
<a name="ln751">  State = MODE_CMDLINE;</a>
<a name="ln752"> </a>
<a name="ln753">  if (s-&gt;firstc == '/' || s-&gt;firstc == '?' || s-&gt;firstc == '@') {</a>
<a name="ln754">    // Use &quot;:lmap&quot; mappings for search pattern and input().</a>
<a name="ln755">    if (curbuf-&gt;b_p_imsearch == B_IMODE_USE_INSERT) {</a>
<a name="ln756">      s-&gt;b_im_ptr = &amp;curbuf-&gt;b_p_iminsert;</a>
<a name="ln757">    } else {</a>
<a name="ln758">      s-&gt;b_im_ptr = &amp;curbuf-&gt;b_p_imsearch;</a>
<a name="ln759">    }</a>
<a name="ln760">    s-&gt;b_im_ptr_buf = curbuf;</a>
<a name="ln761">    if (*s-&gt;b_im_ptr == B_IMODE_LMAP) {</a>
<a name="ln762">      State |= MODE_LANGMAP;</a>
<a name="ln763">    }</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  setmouse();</a>
<a name="ln767">  ui_cursor_shape();               // may show different cursor shape</a>
<a name="ln768"> </a>
<a name="ln769">  TryState tstate;</a>
<a name="ln770">  Error err = ERROR_INIT;</a>
<a name="ln771">  bool tl_ret = true;</a>
<a name="ln772">  char firstcbuf[2];</a>
<a name="ln773">  firstcbuf[0] = (char)(firstc &gt; 0 ? firstc : '-');</a>
<a name="ln774">  firstcbuf[1] = 0;</a>
<a name="ln775"> </a>
<a name="ln776">  if (has_event(EVENT_CMDLINEENTER)) {</a>
<a name="ln777">    save_v_event_T save_v_event;</a>
<a name="ln778">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln779"> </a>
<a name="ln780">    // set v:event to a dictionary with information about the commandline</a>
<a name="ln781">    tv_dict_add_str(dict, S_LEN(&quot;cmdtype&quot;), firstcbuf);</a>
<a name="ln782">    tv_dict_add_nr(dict, S_LEN(&quot;cmdlevel&quot;), ccline.level);</a>
<a name="ln783">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln784">    try_enter(&amp;tstate);</a>
<a name="ln785"> </a>
<a name="ln786">    apply_autocmds(EVENT_CMDLINEENTER, firstcbuf, firstcbuf, false, curbuf);</a>
<a name="ln787">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln788"> </a>
<a name="ln789">    tl_ret = try_leave(&amp;tstate, &amp;err);</a>
<a name="ln790">    if (!tl_ret &amp;&amp; ERROR_SET(&amp;err)) {</a>
<a name="ln791">      msg_putchar('\n');</a>
<a name="ln792">      msg_scroll = true;</a>
<a name="ln793">      msg_puts_attr(err.msg, HL_ATTR(HLF_E)|MSG_HIST);</a>
<a name="ln794">      api_clear_error(&amp;err);</a>
<a name="ln795">      redrawcmd();</a>
<a name="ln796">    }</a>
<a name="ln797">    tl_ret = true;</a>
<a name="ln798">  }</a>
<a name="ln799">  may_trigger_modechanged();</a>
<a name="ln800"> </a>
<a name="ln801">  init_history();</a>
<a name="ln802">  s-&gt;hiscnt = get_hislen();  // set hiscnt to impossible history value</a>
<a name="ln803">  s-&gt;histype = hist_char2type(s-&gt;firstc);</a>
<a name="ln804">  do_digraph(-1);                       // init digraph typeahead</a>
<a name="ln805"> </a>
<a name="ln806">  // If something above caused an error, reset the flags, we do want to type</a>
<a name="ln807">  // and execute commands. Display may be messed up a bit.</a>
<a name="ln808">  if (did_emsg) {</a>
<a name="ln809">    redrawcmd();</a>
<a name="ln810">  }</a>
<a name="ln811"> </a>
<a name="ln812">  // Redraw the statusline in case it uses the current mode using the mode()</a>
<a name="ln813">  // function.</a>
<a name="ln814">  if (!cmd_silent &amp;&amp; !exmode_active) {</a>
<a name="ln815">    bool found_one = false;</a>
<a name="ln816"> </a>
<a name="ln817">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln818">      if (*p_stl != NUL || *wp-&gt;w_p_stl != NUL || *p_wbr != NUL || *wp-&gt;w_p_wbr != NUL) {</a>
<a name="ln819">        wp-&gt;w_redr_status = true;</a>
<a name="ln820">        found_one = true;</a>
<a name="ln821">      }</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    if (*p_tal != NUL) {</a>
<a name="ln825">      redraw_tabline = true;</a>
<a name="ln826">      found_one = true;</a>
<a name="ln827">    }</a>
<a name="ln828"> </a>
<a name="ln829">    if (found_one) {</a>
<a name="ln830">      redraw_statuslines();</a>
<a name="ln831">    }</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  did_emsg = false;</a>
<a name="ln835">  got_int = false;</a>
<a name="ln836">  s-&gt;state.check = command_line_check;</a>
<a name="ln837">  s-&gt;state.execute = command_line_execute;</a>
<a name="ln838"> </a>
<a name="ln839">  state_enter(&amp;s-&gt;state);</a>
<a name="ln840"> </a>
<a name="ln841">  if (has_event(EVENT_CMDLINELEAVE)) {</a>
<a name="ln842">    save_v_event_T save_v_event;</a>
<a name="ln843">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln844"> </a>
<a name="ln845">    tv_dict_add_str(dict, S_LEN(&quot;cmdtype&quot;), firstcbuf);</a>
<a name="ln846">    tv_dict_add_nr(dict, S_LEN(&quot;cmdlevel&quot;), ccline.level);</a>
<a name="ln847">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln848">    // not readonly:</a>
<a name="ln849">    tv_dict_add_bool(dict, S_LEN(&quot;abort&quot;),</a>
<a name="ln850">                     s-&gt;gotesc ? kBoolVarTrue : kBoolVarFalse);</a>
<a name="ln851">    try_enter(&amp;tstate);</a>
<a name="ln852">    apply_autocmds(EVENT_CMDLINELEAVE, firstcbuf, firstcbuf, false, curbuf);</a>
<a name="ln853">    // error printed below, to avoid redraw issues</a>
<a name="ln854">    tl_ret = try_leave(&amp;tstate, &amp;err);</a>
<a name="ln855">    if (tv_dict_get_number(dict, &quot;abort&quot;) != 0) {</a>
<a name="ln856">      s-&gt;gotesc = 1;</a>
<a name="ln857">    }</a>
<a name="ln858">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln859">  }</a>
<a name="ln860"> </a>
<a name="ln861">  cmdmsg_rl = false;</a>
<a name="ln862"> </a>
<a name="ln863">  ExpandCleanup(&amp;s-&gt;xpc);</a>
<a name="ln864">  ccline.xpc = NULL;</a>
<a name="ln865"> </a>
<a name="ln866">  finish_incsearch_highlighting(s-&gt;gotesc, &amp;s-&gt;is_state, false);</a>
<a name="ln867"> </a>
<a name="ln868">  if (ccline.cmdbuff != NULL) {</a>
<a name="ln869">    // Put line in history buffer (&quot;:&quot; and &quot;=&quot; only when it was typed).</a>
<a name="ln870">    if (s-&gt;histype != HIST_INVALID</a>
<a name="ln871">        &amp;&amp; ccline.cmdlen</a>
<a name="ln872">        &amp;&amp; s-&gt;firstc != NUL</a>
<a name="ln873">        &amp;&amp; (s-&gt;some_key_typed || s-&gt;histype == HIST_SEARCH)) {</a>
<a name="ln874">      add_to_history(s-&gt;histype, ccline.cmdbuff, true,</a>
<a name="ln875">                     s-&gt;histype == HIST_SEARCH ? s-&gt;firstc : NUL);</a>
<a name="ln876">      if (s-&gt;firstc == ':') {</a>
<a name="ln877">        xfree(new_last_cmdline);</a>
<a name="ln878">        new_last_cmdline = xstrdup(ccline.cmdbuff);</a>
<a name="ln879">      }</a>
<a name="ln880">    }</a>
<a name="ln881"> </a>
<a name="ln882">    if (s-&gt;gotesc) {</a>
<a name="ln883">      abandon_cmdline();</a>
<a name="ln884">    }</a>
<a name="ln885">  }</a>
<a name="ln886"> </a>
<a name="ln887">  // If the screen was shifted up, redraw the whole screen (later).</a>
<a name="ln888">  // If the line is too long, clear it, so ruler and shown command do</a>
<a name="ln889">  // not get printed in the middle of it.</a>
<a name="ln890">  msg_check();</a>
<a name="ln891">  if (p_ch == 0 &amp;&amp; !ui_has(kUIMessages)) {</a>
<a name="ln892">    if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln893">      must_redraw = UPD_VALID;</a>
<a name="ln894">    }</a>
<a name="ln895">  }</a>
<a name="ln896">  msg_scroll = s-&gt;save_msg_scroll;</a>
<a name="ln897">  redir_off = false;</a>
<a name="ln898"> </a>
<a name="ln899">  if (!tl_ret &amp;&amp; ERROR_SET(&amp;err)) {</a>
<a name="ln900">    msg_putchar('\n');</a>
<a name="ln901">    emsg(err.msg);</a>
<a name="ln902">    did_emsg = false;</a>
<a name="ln903">    api_clear_error(&amp;err);</a>
<a name="ln904">  }</a>
<a name="ln905"> </a>
<a name="ln906">  // When the command line was typed, no need for a wait-return prompt.</a>
<a name="ln907">  if (s-&gt;some_key_typed &amp;&amp; tl_ret) {</a>
<a name="ln908">    need_wait_return = false;</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  set_string_option_direct(&quot;icm&quot;, -1, s-&gt;save_p_icm, OPT_FREE, SID_NONE);</a>
<a name="ln912">  State = s-&gt;save_State;</a>
<a name="ln913">  if (cmdpreview != save_cmdpreview) {</a>
<a name="ln914">    cmdpreview = save_cmdpreview;  // restore preview state</a>
<a name="ln915">    redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln916">  }</a>
<a name="ln917">  may_trigger_modechanged();</a>
<a name="ln918">  setmouse();</a>
<a name="ln919">  ui_cursor_shape();            // may show different cursor shape</a>
<a name="ln920">  sb_text_end_cmdline();</a>
<a name="ln921"> </a>
<a name="ln922">theend:</a>
<a name="ln923">  xfree(s-&gt;save_p_icm);</a>
<a name="ln924">  xfree(ccline.last_colors.cmdbuff);</a>
<a name="ln925">  kv_destroy(ccline.last_colors.colors);</a>
<a name="ln926"> </a>
<a name="ln927">  char *p = ccline.cmdbuff;</a>
<a name="ln928"> </a>
<a name="ln929">  if (ui_has(kUICmdline)) {</a>
<a name="ln930">    ui_call_cmdline_hide(ccline.level);</a>
<a name="ln931">    msg_ext_clear_later();</a>
<a name="ln932">  }</a>
<a name="ln933">  if (!cmd_silent) {</a>
<a name="ln934">    status_redraw_all();  // redraw to show mode change</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">  cmdline_level--;</a>
<a name="ln938"> </a>
<a name="ln939">  if (did_save_ccline) {</a>
<a name="ln940">    restore_cmdline(&amp;save_ccline);</a>
<a name="ln941">  } else {</a>
<a name="ln942">    ccline.cmdbuff = NULL;</a>
<a name="ln943">  }</a>
<a name="ln944"> </a>
<a name="ln945">  return (uint8_t *)p;</a>
<a name="ln946">}</a>
<a name="ln947"> </a>
<a name="ln948">static int command_line_check(VimState *state)</a>
<a name="ln949">{</a>
<a name="ln950">  CommandLineState *s = (CommandLineState *)state;</a>
<a name="ln951"> </a>
<a name="ln952">  redir_off = true;        // Don't redirect the typed command.</a>
<a name="ln953">  // Repeated, because a &quot;:redir&quot; inside</a>
<a name="ln954">  // completion may switch it on.</a>
<a name="ln955">  quit_more = false;       // reset after CTRL-D which had a more-prompt</a>
<a name="ln956"> </a>
<a name="ln957">  did_emsg = false;        // There can't really be a reason why an error</a>
<a name="ln958">                           // that occurs while typing a command should</a>
<a name="ln959">                           // cause the command not to be executed.</a>
<a name="ln960"> </a>
<a name="ln961">  // Trigger SafeState if nothing is pending.</a>
<a name="ln962">  may_trigger_safestate(s-&gt;xpc.xp_numfiles &lt;= 0);</a>
<a name="ln963"> </a>
<a name="ln964">  cursorcmd();             // set the cursor on the right spot</a>
<a name="ln965">  ui_cursor_shape();</a>
<a name="ln966">  return 1;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969">/// Handle CTRL-\ pressed in Command-line mode:</a>
<a name="ln970">/// - CTRL-\ CTRL-N or CTRL-\ CTRL-G goes to Normal mode.</a>
<a name="ln971">/// - CTRL-\ e prompts for an expression.</a>
<a name="ln972">static int command_line_handle_ctrl_bsl(CommandLineState *s)</a>
<a name="ln973">{</a>
<a name="ln974">  no_mapping++;</a>
<a name="ln975">  allow_keys++;</a>
<a name="ln976">  s-&gt;c = plain_vgetc();</a>
<a name="ln977">  no_mapping--;</a>
<a name="ln978">  allow_keys--;</a>
<a name="ln979"> </a>
<a name="ln980">  // CTRL-\ e doesn't work when obtaining an expression, unless it</a>
<a name="ln981">  // is in a mapping.</a>
<a name="ln982">  if (s-&gt;c != Ctrl_N</a>
<a name="ln983">      &amp;&amp; s-&gt;c != Ctrl_G</a>
<a name="ln984">      &amp;&amp; (s-&gt;c != 'e'</a>
<a name="ln985">          || (ccline.cmdfirstc == '=' &amp;&amp; KeyTyped)</a>
<a name="ln986">          || cmdline_star &gt; 0)) {</a>
<a name="ln987">    vungetc(s-&gt;c);</a>
<a name="ln988">    return PROCESS_NEXT_KEY;</a>
<a name="ln989">  }</a>
<a name="ln990"> </a>
<a name="ln991">  if (s-&gt;c == 'e') {</a>
<a name="ln992">    // Replace the command line with the result of an expression.</a>
<a name="ln993">    // This will call getcmdline() recursively in get_expr_register().</a>
<a name="ln994">    if (ccline.cmdpos == ccline.cmdlen) {</a>
<a name="ln995">      new_cmdpos = 99999;           // keep it at the end</a>
<a name="ln996">    } else {</a>
<a name="ln997">      new_cmdpos = ccline.cmdpos;</a>
<a name="ln998">    }</a>
<a name="ln999"> </a>
<a name="ln1000">    s-&gt;c = get_expr_register();</a>
<a name="ln1001">    if (s-&gt;c == '=') {</a>
<a name="ln1002">      // Evaluate the expression.  Set &quot;textlock&quot; to avoid nasty things</a>
<a name="ln1003">      // like going to another buffer.</a>
<a name="ln1004">      textlock++;</a>
<a name="ln1005">      char *p = get_expr_line();</a>
<a name="ln1006">      textlock--;</a>
<a name="ln1007"> </a>
<a name="ln1008">      if (p != NULL) {</a>
<a name="ln1009">        int len = (int)strlen(p);</a>
<a name="ln1010">        realloc_cmdbuff(len + 1);</a>
<a name="ln1011">        ccline.cmdlen = len;</a>
<a name="ln1012">        STRCPY(ccline.cmdbuff, p);</a>
<a name="ln1013">        xfree(p);</a>
<a name="ln1014"> </a>
<a name="ln1015">        // Restore the cursor or use the position set with</a>
<a name="ln1016">        // set_cmdline_pos().</a>
<a name="ln1017">        if (new_cmdpos &gt; ccline.cmdlen) {</a>
<a name="ln1018">          ccline.cmdpos = ccline.cmdlen;</a>
<a name="ln1019">        } else {</a>
<a name="ln1020">          ccline.cmdpos = new_cmdpos;</a>
<a name="ln1021">        }</a>
<a name="ln1022"> </a>
<a name="ln1023">        KeyTyped = false;                 // Don't do p_wc completion.</a>
<a name="ln1024">        redrawcmd();</a>
<a name="ln1025">        return CMDLINE_CHANGED;</a>
<a name="ln1026">      }</a>
<a name="ln1027">    }</a>
<a name="ln1028">    beep_flush();</a>
<a name="ln1029">    got_int = false;                // don't abandon the command line</a>
<a name="ln1030">    did_emsg = false;</a>
<a name="ln1031">    emsg_on_display = false;</a>
<a name="ln1032">    redrawcmd();</a>
<a name="ln1033">    return CMDLINE_NOT_CHANGED;</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  s-&gt;gotesc = true;  // will free ccline.cmdbuff after putting it in history</a>
<a name="ln1037">  return GOTO_NORMAL_MODE;</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">/// Completion for 'wildchar' or 'wildcharm' key.</a>
<a name="ln1041">/// - hitting &lt;ESC&gt; twice means: abandon command line.</a>
<a name="ln1042">/// - wildcard expansion is only done when the 'wildchar' key is really</a>
<a name="ln1043">///   typed, not when it comes from a macro</a>
<a name="ln1044">/// @return  CMDLINE_CHANGED if command line is changed or CMDLINE_NOT_CHANGED.</a>
<a name="ln1045">static int command_line_wildchar_complete(CommandLineState *s)</a>
<a name="ln1046">{</a>
<a name="ln1047">  int res;</a>
<a name="ln1048">  int options = WILD_NO_BEEP;</a>
<a name="ln1049">  if (wim_flags[s-&gt;wim_index] &amp; WIM_BUFLASTUSED) {</a>
<a name="ln1050">    options |= WILD_BUFLASTUSED;</a>
<a name="ln1051">  }</a>
<a name="ln1052">  if (s-&gt;xpc.xp_numfiles &gt; 0) {       // typed p_wc at least twice</a>
<a name="ln1053">    // if 'wildmode' contains &quot;list&quot; may still need to list</a>
<a name="ln1054">    if (s-&gt;xpc.xp_numfiles &gt; 1</a>
<a name="ln1055">        &amp;&amp; !s-&gt;did_wild_list</a>
<a name="ln1056">        &amp;&amp; ((wim_flags[s-&gt;wim_index] &amp; WIM_LIST)</a>
<a name="ln1057">            || (p_wmnu &amp;&amp; (wim_flags[s-&gt;wim_index] &amp; WIM_FULL) != 0))) {</a>
<a name="ln1058">      (void)showmatches(&amp;s-&gt;xpc, p_wmnu &amp;&amp; ((wim_flags[s-&gt;wim_index] &amp; WIM_LIST) == 0));</a>
<a name="ln1059">      redrawcmd();</a>
<a name="ln1060">      s-&gt;did_wild_list = true;</a>
<a name="ln1061">    }</a>
<a name="ln1062"> </a>
<a name="ln1063">    if (wim_flags[s-&gt;wim_index] &amp; WIM_LONGEST) {</a>
<a name="ln1064">      res = nextwild(&amp;s-&gt;xpc, WILD_LONGEST, options, s-&gt;firstc != '@');</a>
<a name="ln1065">    } else if (wim_flags[s-&gt;wim_index] &amp; WIM_FULL) {</a>
<a name="ln1066">      res = nextwild(&amp;s-&gt;xpc, WILD_NEXT, options, s-&gt;firstc != '@');</a>
<a name="ln1067">    } else {</a>
<a name="ln1068">      res = OK;                 // don't insert 'wildchar' now</a>
<a name="ln1069">    }</a>
<a name="ln1070">  } else {                    // typed p_wc first time</a>
<a name="ln1071">    s-&gt;wim_index = 0;</a>
<a name="ln1072">    int j = ccline.cmdpos;</a>
<a name="ln1073"> </a>
<a name="ln1074">    // if 'wildmode' first contains &quot;longest&quot;, get longest</a>
<a name="ln1075">    // common part</a>
<a name="ln1076">    if (wim_flags[0] &amp; WIM_LONGEST) {</a>
<a name="ln1077">      res = nextwild(&amp;s-&gt;xpc, WILD_LONGEST, options, s-&gt;firstc != '@');</a>
<a name="ln1078">    } else {</a>
<a name="ln1079">      res = nextwild(&amp;s-&gt;xpc, WILD_EXPAND_KEEP, options, s-&gt;firstc != '@');</a>
<a name="ln1080">    }</a>
<a name="ln1081"> </a>
<a name="ln1082">    // if interrupted while completing, behave like it failed</a>
<a name="ln1083">    if (got_int) {</a>
<a name="ln1084">      (void)vpeekc();               // remove &lt;C-C&gt; from input stream</a>
<a name="ln1085">      got_int = false;              // don't abandon the command line</a>
<a name="ln1086">      (void)ExpandOne(&amp;s-&gt;xpc, NULL, NULL, 0, WILD_FREE);</a>
<a name="ln1087">      s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln1088">      return CMDLINE_CHANGED;</a>
<a name="ln1089">    }</a>
<a name="ln1090"> </a>
<a name="ln1091">    // when more than one match, and 'wildmode' first contains</a>
<a name="ln1092">    // &quot;list&quot;, or no change and 'wildmode' contains &quot;longest,list&quot;,</a>
<a name="ln1093">    // list all matches</a>
<a name="ln1094">    if (res == OK &amp;&amp; s-&gt;xpc.xp_numfiles &gt; 1) {</a>
<a name="ln1095">      // a &quot;longest&quot; that didn't do anything is skipped (but not</a>
<a name="ln1096">      // &quot;list:longest&quot;)</a>
<a name="ln1097">      if (wim_flags[0] == WIM_LONGEST &amp;&amp; ccline.cmdpos == j) {</a>
<a name="ln1098">        s-&gt;wim_index = 1;</a>
<a name="ln1099">      }</a>
<a name="ln1100">      if ((wim_flags[s-&gt;wim_index] &amp; WIM_LIST)</a>
<a name="ln1101">          || (p_wmnu &amp;&amp; (wim_flags[s-&gt;wim_index] &amp; WIM_FULL) != 0)) {</a>
<a name="ln1102">        if (!(wim_flags[0] &amp; WIM_LONGEST)) {</a>
<a name="ln1103">          int p_wmnu_save = p_wmnu;</a>
<a name="ln1104">          p_wmnu = 0;</a>
<a name="ln1105">          // remove match</a>
<a name="ln1106">          nextwild(&amp;s-&gt;xpc, WILD_PREV, 0, s-&gt;firstc != '@');</a>
<a name="ln1107">          p_wmnu = p_wmnu_save;</a>
<a name="ln1108">        }</a>
<a name="ln1109"> </a>
<a name="ln1110">        (void)showmatches(&amp;s-&gt;xpc, p_wmnu &amp;&amp; ((wim_flags[s-&gt;wim_index] &amp; WIM_LIST) == 0));</a>
<a name="ln1111">        redrawcmd();</a>
<a name="ln1112">        s-&gt;did_wild_list = true;</a>
<a name="ln1113"> </a>
<a name="ln1114">        if (wim_flags[s-&gt;wim_index] &amp; WIM_LONGEST) {</a>
<a name="ln1115">          nextwild(&amp;s-&gt;xpc, WILD_LONGEST, options, s-&gt;firstc != '@');</a>
<a name="ln1116">        } else if (wim_flags[s-&gt;wim_index] &amp; WIM_FULL) {</a>
<a name="ln1117">          nextwild(&amp;s-&gt;xpc, WILD_NEXT, options, s-&gt;firstc != '@');</a>
<a name="ln1118">        }</a>
<a name="ln1119">      } else {</a>
<a name="ln1120">        vim_beep(BO_WILD);</a>
<a name="ln1121">      }</a>
<a name="ln1122">    } else if (s-&gt;xpc.xp_numfiles == -1) {</a>
<a name="ln1123">      s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln1124">    }</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  if (s-&gt;wim_index &lt; 3) {</a>
<a name="ln1128">    s-&gt;wim_index++;</a>
<a name="ln1129">  }</a>
<a name="ln1130"> </a>
<a name="ln1131">  if (s-&gt;c == ESC) {</a>
<a name="ln1132">    s-&gt;gotesc = true;</a>
<a name="ln1133">  }</a>
<a name="ln1134"> </a>
<a name="ln1135">  return (res == OK) ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">static void command_line_end_wildmenu(CommandLineState *s)</a>
<a name="ln1139">{</a>
<a name="ln1140">  if (cmdline_pum_active()) {</a>
<a name="ln1141">    cmdline_pum_remove();</a>
<a name="ln1142">  }</a>
<a name="ln1143">  if (s-&gt;xpc.xp_numfiles != -1) {</a>
<a name="ln1144">    (void)ExpandOne(&amp;s-&gt;xpc, NULL, NULL, 0, WILD_FREE);</a>
<a name="ln1145">  }</a>
<a name="ln1146">  s-&gt;did_wild_list = false;</a>
<a name="ln1147">  if (!p_wmnu || (s-&gt;c != K_UP &amp;&amp; s-&gt;c != K_DOWN)) {</a>
<a name="ln1148">    s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln1149">  }</a>
<a name="ln1150">  s-&gt;wim_index = 0;</a>
<a name="ln1151">  wildmenu_cleanup(&amp;ccline);</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">static int command_line_execute(VimState *state, int key)</a>
<a name="ln1155">{</a>
<a name="ln1156">  if (key == K_IGNORE || key == K_NOP) {</a>
<a name="ln1157">    return -1;  // get another key</a>
<a name="ln1158">  }</a>
<a name="ln1159"> </a>
<a name="ln1160">  CommandLineState *s = (CommandLineState *)state;</a>
<a name="ln1161">  s-&gt;c = key;</a>
<a name="ln1162"> </a>
<a name="ln1163">  if (s-&gt;c == K_EVENT || s-&gt;c == K_COMMAND || s-&gt;c == K_LUA) {</a>
<a name="ln1164">    if (s-&gt;c == K_EVENT) {</a>
<a name="ln1165">      state_handle_k_event();</a>
<a name="ln1166">    } else if (s-&gt;c == K_COMMAND) {</a>
<a name="ln1167">      do_cmdline(NULL, getcmdkeycmd, NULL, DOCMD_NOWAIT);</a>
<a name="ln1168">    } else {</a>
<a name="ln1169">      map_execute_lua(false);</a>
<a name="ln1170">    }</a>
<a name="ln1171"> </a>
<a name="ln1172">    // nvim_select_popupmenu_item() can be called from the handling of</a>
<a name="ln1173">    // K_EVENT, K_COMMAND, or K_LUA.</a>
<a name="ln1174">    if (pum_want.active) {</a>
<a name="ln1175">      if (cmdline_pum_active()) {</a>
<a name="ln1176">        nextwild(&amp;s-&gt;xpc, WILD_PUM_WANT, 0, s-&gt;firstc != '@');</a>
<a name="ln1177">        if (pum_want.finish) {</a>
<a name="ln1178">          nextwild(&amp;s-&gt;xpc, WILD_APPLY, WILD_NO_BEEP, s-&gt;firstc != '@');</a>
<a name="ln1179">          command_line_end_wildmenu(s);</a>
<a name="ln1180">        }</a>
<a name="ln1181">      }</a>
<a name="ln1182">      pum_want.active = false;</a>
<a name="ln1183">    }</a>
<a name="ln1184"> </a>
<a name="ln1185">    if (!cmdline_was_last_drawn) {</a>
<a name="ln1186">      redrawcmdline();</a>
<a name="ln1187">    }</a>
<a name="ln1188">    return 1;</a>
<a name="ln1189">  }</a>
<a name="ln1190"> </a>
<a name="ln1191">  if (KeyTyped) {</a>
<a name="ln1192">    s-&gt;some_key_typed = true;</a>
<a name="ln1193"> </a>
<a name="ln1194">    if (cmdmsg_rl &amp;&amp; !KeyStuffed) {</a>
<a name="ln1195">      // Invert horizontal movements and operations.  Only when</a>
<a name="ln1196">      // typed by the user directly, not when the result of a</a>
<a name="ln1197">      // mapping.</a>
<a name="ln1198">      switch (s-&gt;c) {</a>
<a name="ln1199">      case K_RIGHT:</a>
<a name="ln1200">        s-&gt;c = K_LEFT; break;</a>
<a name="ln1201">      case K_S_RIGHT:</a>
<a name="ln1202">        s-&gt;c = K_S_LEFT; break;</a>
<a name="ln1203">      case K_C_RIGHT:</a>
<a name="ln1204">        s-&gt;c = K_C_LEFT; break;</a>
<a name="ln1205">      case K_LEFT:</a>
<a name="ln1206">        s-&gt;c = K_RIGHT; break;</a>
<a name="ln1207">      case K_S_LEFT:</a>
<a name="ln1208">        s-&gt;c = K_S_RIGHT; break;</a>
<a name="ln1209">      case K_C_LEFT:</a>
<a name="ln1210">        s-&gt;c = K_C_RIGHT; break;</a>
<a name="ln1211">      }</a>
<a name="ln1212">    }</a>
<a name="ln1213">  }</a>
<a name="ln1214"> </a>
<a name="ln1215">  // Ignore got_int when CTRL-C was typed here.</a>
<a name="ln1216">  // Don't ignore it in :global, we really need to break then, e.g., for</a>
<a name="ln1217">  // &quot;:g/pat/normal /pat&quot; (without the &lt;CR&gt;).</a>
<a name="ln1218">  // Don't ignore it for the input() function.</a>
<a name="ln1219">  if ((s-&gt;c == Ctrl_C)</a>
<a name="ln1220">      &amp;&amp; s-&gt;firstc != '@'</a>
<a name="ln1221">      // do clear got_int in Ex mode to avoid infinite Ctrl-C loop</a>
<a name="ln1222">      &amp;&amp; (!s-&gt;break_ctrl_c || exmode_active)</a>
<a name="ln1223">      &amp;&amp; !global_busy) {</a>
<a name="ln1224">    got_int = false;</a>
<a name="ln1225">  }</a>
<a name="ln1226"> </a>
<a name="ln1227">  // free old command line when finished moving around in the history</a>
<a name="ln1228">  // list</a>
<a name="ln1229">  if (s-&gt;lookfor != NULL</a>
<a name="ln1230">      &amp;&amp; s-&gt;c != K_S_DOWN &amp;&amp; s-&gt;c != K_S_UP</a>
<a name="ln1231">      &amp;&amp; s-&gt;c != K_DOWN &amp;&amp; s-&gt;c != K_UP</a>
<a name="ln1232">      &amp;&amp; s-&gt;c != K_PAGEDOWN &amp;&amp; s-&gt;c != K_PAGEUP</a>
<a name="ln1233">      &amp;&amp; s-&gt;c != K_KPAGEDOWN &amp;&amp; s-&gt;c != K_KPAGEUP</a>
<a name="ln1234">      &amp;&amp; s-&gt;c != K_LEFT &amp;&amp; s-&gt;c != K_RIGHT</a>
<a name="ln1235">      &amp;&amp; (s-&gt;xpc.xp_numfiles &gt; 0 || (s-&gt;c != Ctrl_P &amp;&amp; s-&gt;c != Ctrl_N))) {</a>
<a name="ln1236">    XFREE_CLEAR(s-&gt;lookfor);</a>
<a name="ln1237">  }</a>
<a name="ln1238"> </a>
<a name="ln1239">  // When there are matching completions to select &lt;S-Tab&gt; works like</a>
<a name="ln1240">  // CTRL-P (unless 'wc' is &lt;S-Tab&gt;).</a>
<a name="ln1241">  if (s-&gt;c != p_wc &amp;&amp; s-&gt;c == K_S_TAB &amp;&amp; s-&gt;xpc.xp_numfiles &gt; 0) {</a>
<a name="ln1242">    s-&gt;c = Ctrl_P;</a>
<a name="ln1243">  }</a>
<a name="ln1244"> </a>
<a name="ln1245">  if (p_wmnu) {</a>
<a name="ln1246">    s-&gt;c = wildmenu_translate_key(&amp;ccline, s-&gt;c, &amp;s-&gt;xpc, s-&gt;did_wild_list);</a>
<a name="ln1247">  }</a>
<a name="ln1248"> </a>
<a name="ln1249">  if (cmdline_pum_active() || s-&gt;did_wild_list) {</a>
<a name="ln1250">    // Ctrl-Y: Accept the current selection and close the popup menu.</a>
<a name="ln1251">    // Ctrl-E: cancel the cmdline popup menu and return the original text.</a>
<a name="ln1252">    if (s-&gt;c == Ctrl_E || s-&gt;c == Ctrl_Y) {</a>
<a name="ln1253">      const int wild_type = (s-&gt;c == Ctrl_E) ? WILD_CANCEL : WILD_APPLY;</a>
<a name="ln1254">      (void)nextwild(&amp;s-&gt;xpc, wild_type, WILD_NO_BEEP, s-&gt;firstc != '@');</a>
<a name="ln1255">      s-&gt;c = Ctrl_E;</a>
<a name="ln1256">    }</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259">  // The wildmenu is cleared if the pressed key is not used for</a>
<a name="ln1260">  // navigating the wild menu (i.e. the key is not 'wildchar' or</a>
<a name="ln1261">  // 'wildcharm' or Ctrl-N or Ctrl-P or Ctrl-A or Ctrl-L).</a>
<a name="ln1262">  // If the popup menu is displayed, then PageDown and PageUp keys are</a>
<a name="ln1263">  // also used to navigate the menu.</a>
<a name="ln1264">  bool end_wildmenu = (!(s-&gt;c == p_wc &amp;&amp; KeyTyped) &amp;&amp; s-&gt;c != p_wcm &amp;&amp; s-&gt;c != Ctrl_Z</a>
<a name="ln1265">                       &amp;&amp; s-&gt;c != Ctrl_N &amp;&amp; s-&gt;c != Ctrl_P &amp;&amp; s-&gt;c != Ctrl_A</a>
<a name="ln1266">                       &amp;&amp; s-&gt;c != Ctrl_L);</a>
<a name="ln1267">  end_wildmenu = end_wildmenu &amp;&amp; (!cmdline_pum_active()</a>
<a name="ln1268">                                  || (s-&gt;c != K_PAGEDOWN &amp;&amp; s-&gt;c != K_PAGEUP</a>
<a name="ln1269">                                      &amp;&amp; s-&gt;c != K_KPAGEDOWN &amp;&amp; s-&gt;c != K_KPAGEUP));</a>
<a name="ln1270"> </a>
<a name="ln1271">  // free expanded names when finished walking through matches</a>
<a name="ln1272">  if (end_wildmenu) {</a>
<a name="ln1273">    command_line_end_wildmenu(s);</a>
<a name="ln1274">  }</a>
<a name="ln1275"> </a>
<a name="ln1276">  if (p_wmnu) {</a>
<a name="ln1277">    s-&gt;c = wildmenu_process_key(&amp;ccline, s-&gt;c, &amp;s-&gt;xpc);</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280">  // CTRL-\ CTRL-N or CTRL-\ CTRL-G goes to Normal mode,</a>
<a name="ln1281">  // CTRL-\ e prompts for an expression.</a>
<a name="ln1282">  if (s-&gt;c == Ctrl_BSL) {</a>
<a name="ln1283">    switch (command_line_handle_ctrl_bsl(s)) {</a>
<a name="ln1284">    case CMDLINE_CHANGED:</a>
<a name="ln1285">      return command_line_changed(s);</a>
<a name="ln1286">    case CMDLINE_NOT_CHANGED:</a>
<a name="ln1287">      return command_line_not_changed(s);</a>
<a name="ln1288">    case GOTO_NORMAL_MODE:</a>
<a name="ln1289">      return 0;                   // back to cmd mode</a>
<a name="ln1290">    default:</a>
<a name="ln1291">      s-&gt;c = Ctrl_BSL;            // backslash key not processed by</a>
<a name="ln1292">                                  // command_line_handle_ctrl_bsl()</a>
<a name="ln1293">    }</a>
<a name="ln1294">  }</a>
<a name="ln1295"> </a>
<a name="ln1296">  if (s-&gt;c == cedit_key || s-&gt;c == K_CMDWIN) {</a>
<a name="ln1297">    // TODO(vim): why is ex_normal_busy checked here?</a>
<a name="ln1298">    if ((s-&gt;c == K_CMDWIN || ex_normal_busy == 0)</a>
<a name="ln1299">        &amp;&amp; got_int == false) {</a>
<a name="ln1300">      // Open a window to edit the command line (and history).</a>
<a name="ln1301">      s-&gt;c = open_cmdwin();</a>
<a name="ln1302">      s-&gt;some_key_typed = true;</a>
<a name="ln1303">    }</a>
<a name="ln1304">  } else {</a>
<a name="ln1305">    s-&gt;c = do_digraph(s-&gt;c);</a>
<a name="ln1306">  }</a>
<a name="ln1307"> </a>
<a name="ln1308">  if (s-&gt;c == '\n'</a>
<a name="ln1309">      || s-&gt;c == '\r'</a>
<a name="ln1310">      || s-&gt;c == K_KENTER</a>
<a name="ln1311">      || (s-&gt;c == ESC</a>
<a name="ln1312">          &amp;&amp; (!KeyTyped || vim_strchr(p_cpo, CPO_ESC) != NULL))) {</a>
<a name="ln1313">    // In Ex mode a backslash escapes a newline.</a>
<a name="ln1314">    if (exmode_active</a>
<a name="ln1315">        &amp;&amp; s-&gt;c != ESC</a>
<a name="ln1316">        &amp;&amp; ccline.cmdpos == ccline.cmdlen</a>
<a name="ln1317">        &amp;&amp; ccline.cmdpos &gt; 0</a>
<a name="ln1318">        &amp;&amp; ccline.cmdbuff[ccline.cmdpos - 1] == '\\') {</a>
<a name="ln1319">      if (s-&gt;c == K_KENTER) {</a>
<a name="ln1320">        s-&gt;c = '\n';</a>
<a name="ln1321">      }</a>
<a name="ln1322">    } else {</a>
<a name="ln1323">      s-&gt;gotesc = false;         // Might have typed ESC previously, don't</a>
<a name="ln1324">                                 // truncate the cmdline now.</a>
<a name="ln1325">      if (ccheck_abbr(s-&gt;c + ABBR_OFF)) {</a>
<a name="ln1326">        return command_line_changed(s);</a>
<a name="ln1327">      }</a>
<a name="ln1328"> </a>
<a name="ln1329">      if (!cmd_silent) {</a>
<a name="ln1330">        if (!ui_has(kUICmdline)) {</a>
<a name="ln1331">          cmd_cursor_goto(msg_row, 0);</a>
<a name="ln1332">        }</a>
<a name="ln1333">        ui_flush();</a>
<a name="ln1334">      }</a>
<a name="ln1335">      return 0;</a>
<a name="ln1336">    }</a>
<a name="ln1337">  }</a>
<a name="ln1338"> </a>
<a name="ln1339">  // Completion for 'wildchar' or 'wildcharm' key.</a>
<a name="ln1340">  if ((s-&gt;c == p_wc &amp;&amp; !s-&gt;gotesc &amp;&amp; KeyTyped) || s-&gt;c == p_wcm || s-&gt;c == Ctrl_Z) {</a>
<a name="ln1341">    if (command_line_wildchar_complete(s) == CMDLINE_CHANGED) {</a>
<a name="ln1342">      return command_line_changed(s);</a>
<a name="ln1343">    }</a>
<a name="ln1344">  }</a>
<a name="ln1345"> </a>
<a name="ln1346">  s-&gt;gotesc = false;</a>
<a name="ln1347"> </a>
<a name="ln1348">  // &lt;S-Tab&gt; goes to last match, in a clumsy way</a>
<a name="ln1349">  if (s-&gt;c == K_S_TAB &amp;&amp; KeyTyped) {</a>
<a name="ln1350">    if (nextwild(&amp;s-&gt;xpc, WILD_EXPAND_KEEP, 0, s-&gt;firstc != '@') == OK) {</a>
<a name="ln1351">      if (s-&gt;xpc.xp_numfiles &gt; 1</a>
<a name="ln1352">          &amp;&amp; ((!s-&gt;did_wild_list &amp;&amp; (wim_flags[s-&gt;wim_index] &amp; WIM_LIST)) || p_wmnu)) {</a>
<a name="ln1353">        // Trigger the popup menu when wildoptions=pum</a>
<a name="ln1354">        showmatches(&amp;s-&gt;xpc, p_wmnu &amp;&amp; ((wim_flags[s-&gt;wim_index] &amp; WIM_LIST) == 0));</a>
<a name="ln1355">      }</a>
<a name="ln1356">      nextwild(&amp;s-&gt;xpc, WILD_PREV, 0, s-&gt;firstc != '@');</a>
<a name="ln1357">      nextwild(&amp;s-&gt;xpc, WILD_PREV, 0, s-&gt;firstc != '@');</a>
<a name="ln1358">      return command_line_changed(s);</a>
<a name="ln1359">    }</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  if (s-&gt;c == NUL || s-&gt;c == K_ZERO) {</a>
<a name="ln1363">    // NUL is stored as NL</a>
<a name="ln1364">    s-&gt;c = NL;</a>
<a name="ln1365">  }</a>
<a name="ln1366"> </a>
<a name="ln1367">  s-&gt;do_abbr = true;             // default: check for abbreviation</a>
<a name="ln1368">  return command_line_handle_key(s);</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">// May adjust 'incsearch' highlighting for typing CTRL-G and CTRL-T, go to next</a>
<a name="ln1372">// or previous match.</a>
<a name="ln1373">// Returns FAIL when calling command_line_not_changed.</a>
<a name="ln1374">static int may_do_command_line_next_incsearch(int firstc, int count, incsearch_state_T *s,</a>
<a name="ln1375">                                              bool next_match)</a>
<a name="ln1376">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1377">{</a>
<a name="ln1378">  int skiplen, patlen, search_delim;</a>
<a name="ln1379"> </a>
<a name="ln1380">  // Parsing range may already set the last search pattern.</a>
<a name="ln1381">  // NOTE: must call restore_last_search_pattern() before returning!</a>
<a name="ln1382">  save_last_search_pattern();</a>
<a name="ln1383"> </a>
<a name="ln1384">  if (!do_incsearch_highlighting(firstc, &amp;search_delim, s, &amp;skiplen,</a>
<a name="ln1385">                                 &amp;patlen)) {</a>
<a name="ln1386">    restore_last_search_pattern();</a>
<a name="ln1387">    return OK;</a>
<a name="ln1388">  }</a>
<a name="ln1389">  if (patlen == 0 &amp;&amp; ccline.cmdbuff[skiplen] == NUL) {</a>
<a name="ln1390">    restore_last_search_pattern();</a>
<a name="ln1391">    return FAIL;</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  ui_busy_start();</a>
<a name="ln1395">  ui_flush();</a>
<a name="ln1396"> </a>
<a name="ln1397">  pos_T t;</a>
<a name="ln1398">  char *pat;</a>
<a name="ln1399">  int search_flags = SEARCH_NOOF;</a>
<a name="ln1400">  char save;</a>
<a name="ln1401"> </a>
<a name="ln1402">  if (search_delim == ccline.cmdbuff[skiplen]) {</a>
<a name="ln1403">    pat = last_search_pattern();</a>
<a name="ln1404">    if (pat == NULL) {</a>
<a name="ln1405">      restore_last_search_pattern();</a>
<a name="ln1406">      return FAIL;</a>
<a name="ln1407">    }</a>
<a name="ln1408">    skiplen = 0;</a>
<a name="ln1409">    patlen = (int)strlen(pat);</a>
<a name="ln1410">  } else {</a>
<a name="ln1411">    pat = ccline.cmdbuff + skiplen;</a>
<a name="ln1412">  }</a>
<a name="ln1413"> </a>
<a name="ln1414">  if (next_match) {</a>
<a name="ln1415">    t = s-&gt;match_end;</a>
<a name="ln1416">    if (lt(s-&gt;match_start, s-&gt;match_end)) {</a>
<a name="ln1417">      // start searching at the end of the match</a>
<a name="ln1418">      // not at the beginning of the next column</a>
<a name="ln1419">      (void)decl(&amp;t);</a>
<a name="ln1420">    }</a>
<a name="ln1421">    search_flags += SEARCH_COL;</a>
<a name="ln1422">  } else {</a>
<a name="ln1423">    t = s-&gt;match_start;</a>
<a name="ln1424">  }</a>
<a name="ln1425">  if (!p_hls) {</a>
<a name="ln1426">    search_flags += SEARCH_KEEP;</a>
<a name="ln1427">  }</a>
<a name="ln1428">  emsg_off++;</a>
<a name="ln1429">  save = pat[patlen];</a>
<a name="ln1430">  pat[patlen] = NUL;</a>
<a name="ln1431">  int found = searchit(curwin, curbuf, &amp;t, NULL,</a>
<a name="ln1432">                       next_match ? FORWARD : BACKWARD,</a>
<a name="ln1433">                       pat, count, search_flags,</a>
<a name="ln1434">                       RE_SEARCH, NULL);</a>
<a name="ln1435">  emsg_off--;</a>
<a name="ln1436">  pat[patlen] = save;</a>
<a name="ln1437">  ui_busy_stop();</a>
<a name="ln1438">  if (found) {</a>
<a name="ln1439">    s-&gt;search_start = s-&gt;match_start;</a>
<a name="ln1440">    s-&gt;match_end = t;</a>
<a name="ln1441">    s-&gt;match_start = t;</a>
<a name="ln1442">    if (!next_match &amp;&amp; firstc != '?') {</a>
<a name="ln1443">      // move just before the current match, so that</a>
<a name="ln1444">      // when nv_search finishes the cursor will be</a>
<a name="ln1445">      // put back on the match</a>
<a name="ln1446">      s-&gt;search_start = t;</a>
<a name="ln1447">      (void)decl(&amp;s-&gt;search_start);</a>
<a name="ln1448">    } else if (next_match &amp;&amp; firstc == '?') {</a>
<a name="ln1449">      // move just after the current match, so that</a>
<a name="ln1450">      // when nv_search finishes the cursor will be</a>
<a name="ln1451">      // put back on the match</a>
<a name="ln1452">      s-&gt;search_start = t;</a>
<a name="ln1453">      (void)incl(&amp;s-&gt;search_start);</a>
<a name="ln1454">    }</a>
<a name="ln1455">    if (lt(t, s-&gt;search_start) &amp;&amp; next_match) {</a>
<a name="ln1456">      // wrap around</a>
<a name="ln1457">      s-&gt;search_start = t;</a>
<a name="ln1458">      if (firstc == '?') {</a>
<a name="ln1459">        (void)incl(&amp;s-&gt;search_start);</a>
<a name="ln1460">      } else {</a>
<a name="ln1461">        (void)decl(&amp;s-&gt;search_start);</a>
<a name="ln1462">      }</a>
<a name="ln1463">    }</a>
<a name="ln1464"> </a>
<a name="ln1465">    set_search_match(&amp;s-&gt;match_end);</a>
<a name="ln1466">    curwin-&gt;w_cursor = s-&gt;match_start;</a>
<a name="ln1467">    changed_cline_bef_curs(curwin);</a>
<a name="ln1468">    update_topline(curwin);</a>
<a name="ln1469">    validate_cursor();</a>
<a name="ln1470">    highlight_match = true;</a>
<a name="ln1471">    save_viewstate(curwin, &amp;s-&gt;old_viewstate);</a>
<a name="ln1472">    redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln1473">    update_screen();</a>
<a name="ln1474">    highlight_match = false;</a>
<a name="ln1475">    redrawcmdline();</a>
<a name="ln1476">    curwin-&gt;w_cursor = s-&gt;match_end;</a>
<a name="ln1477">  } else {</a>
<a name="ln1478">    vim_beep(BO_ERROR);</a>
<a name="ln1479">  }</a>
<a name="ln1480">  restore_last_search_pattern();</a>
<a name="ln1481">  return FAIL;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">/// Handle backspace, delete and CTRL-W keys in the command-line mode.</a>
<a name="ln1485">static int command_line_erase_chars(CommandLineState *s)</a>
<a name="ln1486">{</a>
<a name="ln1487">  if (s-&gt;c == K_KDEL) {</a>
<a name="ln1488">    s-&gt;c = K_DEL;</a>
<a name="ln1489">  }</a>
<a name="ln1490"> </a>
<a name="ln1491">  // Delete current character is the same as backspace on next</a>
<a name="ln1492">  // character, except at end of line</a>
<a name="ln1493">  if (s-&gt;c == K_DEL &amp;&amp; ccline.cmdpos != ccline.cmdlen) {</a>
<a name="ln1494">    ccline.cmdpos++;</a>
<a name="ln1495">  }</a>
<a name="ln1496"> </a>
<a name="ln1497">  if (s-&gt;c == K_DEL) {</a>
<a name="ln1498">    ccline.cmdpos += mb_off_next(ccline.cmdbuff,</a>
<a name="ln1499">                                 ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln1500">  }</a>
<a name="ln1501"> </a>
<a name="ln1502">  if (ccline.cmdpos &gt; 0) {</a>
<a name="ln1503">    char *p;</a>
<a name="ln1504"> </a>
<a name="ln1505">    int j = ccline.cmdpos;</a>
<a name="ln1506">    p = mb_prevptr(ccline.cmdbuff, ccline.cmdbuff + j);</a>
<a name="ln1507"> </a>
<a name="ln1508">    if (s-&gt;c == Ctrl_W) {</a>
<a name="ln1509">      while (p &gt; ccline.cmdbuff &amp;&amp; ascii_isspace(*p)) {</a>
<a name="ln1510">        p = mb_prevptr(ccline.cmdbuff, p);</a>
<a name="ln1511">      }</a>
<a name="ln1512"> </a>
<a name="ln1513">      int i = mb_get_class(p);</a>
<a name="ln1514">      while (p &gt; ccline.cmdbuff &amp;&amp; mb_get_class(p) == i) {</a>
<a name="ln1515">        p = mb_prevptr(ccline.cmdbuff, p);</a>
<a name="ln1516">      }</a>
<a name="ln1517"> </a>
<a name="ln1518">      if (mb_get_class(p) != i) {</a>
<a name="ln1519">        p += utfc_ptr2len(p);</a>
<a name="ln1520">      }</a>
<a name="ln1521">    }</a>
<a name="ln1522"> </a>
<a name="ln1523">    ccline.cmdpos = (int)(p - ccline.cmdbuff);</a>
<a name="ln1524">    ccline.cmdlen -= j - ccline.cmdpos;</a>
<a name="ln1525">    int i = ccline.cmdpos;</a>
<a name="ln1526"> </a>
<a name="ln1527">    while (i &lt; ccline.cmdlen) {</a>
<a name="ln1528">      ccline.cmdbuff[i++] = ccline.cmdbuff[j++];</a>
<a name="ln1529">    }</a>
<a name="ln1530"> </a>
<a name="ln1531">    // Truncate at the end, required for multi-byte chars.</a>
<a name="ln1532">    ccline.cmdbuff[ccline.cmdlen] = NUL;</a>
<a name="ln1533">    if (ccline.cmdlen == 0) {</a>
<a name="ln1534">      s-&gt;is_state.search_start = s-&gt;is_state.save_cursor;</a>
<a name="ln1535">      // save view settings, so that the screen won't be restored at the</a>
<a name="ln1536">      // wrong position</a>
<a name="ln1537">      s-&gt;is_state.old_viewstate = s-&gt;is_state.init_viewstate;</a>
<a name="ln1538">    }</a>
<a name="ln1539">    redrawcmd();</a>
<a name="ln1540">  } else if (ccline.cmdlen == 0 &amp;&amp; s-&gt;c != Ctrl_W</a>
<a name="ln1541">             &amp;&amp; ccline.cmdprompt == NULL &amp;&amp; s-&gt;indent == 0) {</a>
<a name="ln1542">    // In ex and debug mode it doesn't make sense to return.</a>
<a name="ln1543">    if (exmode_active || ccline.cmdfirstc == '&gt;') {</a>
<a name="ln1544">      return CMDLINE_NOT_CHANGED;</a>
<a name="ln1545">    }</a>
<a name="ln1546"> </a>
<a name="ln1547">    XFREE_CLEAR(ccline.cmdbuff);        // no commandline to return</a>
<a name="ln1548">    if (!cmd_silent &amp;&amp; !ui_has(kUICmdline)) {</a>
<a name="ln1549">      if (cmdmsg_rl) {</a>
<a name="ln1550">        msg_col = Columns;</a>
<a name="ln1551">      } else {</a>
<a name="ln1552">        msg_col = 0;</a>
<a name="ln1553">      }</a>
<a name="ln1554">      msg_putchar(' ');                             // delete ':'</a>
<a name="ln1555">    }</a>
<a name="ln1556">    s-&gt;is_state.search_start = s-&gt;is_state.save_cursor;</a>
<a name="ln1557">    redraw_cmdline = true;</a>
<a name="ln1558">    return GOTO_NORMAL_MODE;</a>
<a name="ln1559">  }</a>
<a name="ln1560">  return CMDLINE_CHANGED;</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">/// Handle the CTRL-^ key in the command-line mode and toggle the use of the</a>
<a name="ln1564">/// language :lmap mappings and/or Input Method.</a>
<a name="ln1565">static void command_line_toggle_langmap(CommandLineState *s)</a>
<a name="ln1566">{</a>
<a name="ln1567">  OptInt *b_im_ptr = buf_valid(s-&gt;b_im_ptr_buf) ? s-&gt;b_im_ptr : NULL;</a>
<a name="ln1568">  if (map_to_exists_mode(&quot;&quot;, MODE_LANGMAP, false)) {</a>
<a name="ln1569">    // &quot;:lmap&quot; mappings exists, toggle use of mappings.</a>
<a name="ln1570">    State ^= MODE_LANGMAP;</a>
<a name="ln1571">    if (b_im_ptr != NULL) {</a>
<a name="ln1572">      if (State &amp; MODE_LANGMAP) {</a>
<a name="ln1573">        *b_im_ptr = B_IMODE_LMAP;</a>
<a name="ln1574">      } else {</a>
<a name="ln1575">        *b_im_ptr = B_IMODE_NONE;</a>
<a name="ln1576">      }</a>
<a name="ln1577">    }</a>
<a name="ln1578">  }</a>
<a name="ln1579"> </a>
<a name="ln1580">  if (b_im_ptr != NULL) {</a>
<a name="ln1581">    if (b_im_ptr == &amp;curbuf-&gt;b_p_iminsert) {</a>
<a name="ln1582">      set_iminsert_global(curbuf);</a>
<a name="ln1583">    } else {</a>
<a name="ln1584">      set_imsearch_global(curbuf);</a>
<a name="ln1585">    }</a>
<a name="ln1586">  }</a>
<a name="ln1587">  ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln1588">  // Show/unshow value of 'keymap' in status lines later.</a>
<a name="ln1589">  status_redraw_curbuf();</a>
<a name="ln1590">}</a>
<a name="ln1591"> </a>
<a name="ln1592">/// Handle the CTRL-R key in the command-line mode and insert the contents of a</a>
<a name="ln1593">/// numbered or named register.</a>
<a name="ln1594">static int command_line_insert_reg(CommandLineState *s)</a>
<a name="ln1595">{</a>
<a name="ln1596">  const int save_new_cmdpos = new_cmdpos;</a>
<a name="ln1597"> </a>
<a name="ln1598">  putcmdline('&quot;', true);</a>
<a name="ln1599">  no_mapping++;</a>
<a name="ln1600">  allow_keys++;</a>
<a name="ln1601">  int i = s-&gt;c = plain_vgetc();      // CTRL-R &lt;char&gt;</a>
<a name="ln1602">  if (i == Ctrl_O) {</a>
<a name="ln1603">    i = Ctrl_R;                      // CTRL-R CTRL-O == CTRL-R CTRL-R</a>
<a name="ln1604">  }</a>
<a name="ln1605"> </a>
<a name="ln1606">  if (i == Ctrl_R) {</a>
<a name="ln1607">    s-&gt;c = plain_vgetc();              // CTRL-R CTRL-R &lt;char&gt;</a>
<a name="ln1608">  }</a>
<a name="ln1609">  no_mapping--;</a>
<a name="ln1610">  allow_keys--;</a>
<a name="ln1611">  // Insert the result of an expression.</a>
<a name="ln1612">  new_cmdpos = -1;</a>
<a name="ln1613">  if (s-&gt;c == '=') {</a>
<a name="ln1614">    if (ccline.cmdfirstc == '='   // can't do this recursively</a>
<a name="ln1615">        || cmdline_star &gt; 0) {    // or when typing a password</a>
<a name="ln1616">      beep_flush();</a>
<a name="ln1617">      s-&gt;c = ESC;</a>
<a name="ln1618">    } else {</a>
<a name="ln1619">      s-&gt;c = get_expr_register();</a>
<a name="ln1620">    }</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  bool literally = false;</a>
<a name="ln1624">  if (s-&gt;c != ESC) {               // use ESC to cancel inserting register</a>
<a name="ln1625">    literally = i == Ctrl_R || is_literal_register(s-&gt;c);</a>
<a name="ln1626">    cmdline_paste(s-&gt;c, literally, false);</a>
<a name="ln1627"> </a>
<a name="ln1628">    // When there was a serious error abort getting the</a>
<a name="ln1629">    // command line.</a>
<a name="ln1630">    if (aborting()) {</a>
<a name="ln1631">      s-&gt;gotesc = true;              // will free ccline.cmdbuff after</a>
<a name="ln1632">                                     // putting it in history</a>
<a name="ln1633">      return GOTO_NORMAL_MODE;</a>
<a name="ln1634">    }</a>
<a name="ln1635">    KeyTyped = false;                // Don't do p_wc completion.</a>
<a name="ln1636">    if (new_cmdpos &gt;= 0) {</a>
<a name="ln1637">      // set_cmdline_pos() was used</a>
<a name="ln1638">      if (new_cmdpos &gt; ccline.cmdlen) {</a>
<a name="ln1639">        ccline.cmdpos = ccline.cmdlen;</a>
<a name="ln1640">      } else {</a>
<a name="ln1641">        ccline.cmdpos = new_cmdpos;</a>
<a name="ln1642">      }</a>
<a name="ln1643">    }</a>
<a name="ln1644">  }</a>
<a name="ln1645">  new_cmdpos = save_new_cmdpos;</a>
<a name="ln1646"> </a>
<a name="ln1647">  // remove the double quote</a>
<a name="ln1648">  ccline.special_char = NUL;</a>
<a name="ln1649">  redrawcmd();</a>
<a name="ln1650"> </a>
<a name="ln1651">  // With &quot;literally&quot;: the command line has already changed.</a>
<a name="ln1652">  // Else: the text has been stuffed, but the command line didn't change yet.</a>
<a name="ln1653">  return literally ? CMDLINE_CHANGED : CMDLINE_NOT_CHANGED;</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">/// Handle the Left and Right mouse clicks in the command-line mode.</a>
<a name="ln1657">static void command_line_left_right_mouse(CommandLineState *s)</a>
<a name="ln1658">{</a>
<a name="ln1659">  if (s-&gt;c == K_LEFTRELEASE || s-&gt;c == K_RIGHTRELEASE) {</a>
<a name="ln1660">    s-&gt;ignore_drag_release = true;</a>
<a name="ln1661">  } else {</a>
<a name="ln1662">    s-&gt;ignore_drag_release = false;</a>
<a name="ln1663">  }</a>
<a name="ln1664"> </a>
<a name="ln1665">  ccline.cmdspos = cmd_startcol();</a>
<a name="ln1666">  for (ccline.cmdpos = 0; ccline.cmdpos &lt; ccline.cmdlen;</a>
<a name="ln1667">       ccline.cmdpos++) {</a>
<a name="ln1668">    int cells = cmdline_charsize(ccline.cmdpos);</a>
<a name="ln1669">    if (mouse_row &lt;= cmdline_row + ccline.cmdspos / Columns</a>
<a name="ln1670">        &amp;&amp; mouse_col &lt; ccline.cmdspos % Columns + cells) {</a>
<a name="ln1671">      break;</a>
<a name="ln1672">    }</a>
<a name="ln1673"> </a>
<a name="ln1674">    // Count &quot;&gt;&quot; for double-wide char that doesn't fit.</a>
<a name="ln1675">    correct_screencol(ccline.cmdpos, cells, &amp;ccline.cmdspos);</a>
<a name="ln1676">    ccline.cmdpos += utfc_ptr2len(ccline.cmdbuff + ccline.cmdpos) - 1;</a>
<a name="ln1677">    ccline.cmdspos += cells;</a>
<a name="ln1678">  }</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">static void command_line_next_histidx(CommandLineState *s, bool next_match)</a>
<a name="ln1682">{</a>
<a name="ln1683">  int j = (int)strlen(s-&gt;lookfor);</a>
<a name="ln1684">  while (true) {</a>
<a name="ln1685">    // one step backwards</a>
<a name="ln1686">    if (!next_match) {</a>
<a name="ln1687">      if (s-&gt;hiscnt == get_hislen()) {</a>
<a name="ln1688">        // first time</a>
<a name="ln1689">        s-&gt;hiscnt = *get_hisidx(s-&gt;histype);</a>
<a name="ln1690">      } else if (s-&gt;hiscnt == 0 &amp;&amp; *get_hisidx(s-&gt;histype) != get_hislen() - 1) {</a>
<a name="ln1691">        s-&gt;hiscnt = get_hislen() - 1;</a>
<a name="ln1692">      } else if (s-&gt;hiscnt != *get_hisidx(s-&gt;histype) + 1) {</a>
<a name="ln1693">        s-&gt;hiscnt--;</a>
<a name="ln1694">      } else {</a>
<a name="ln1695">        // at top of list</a>
<a name="ln1696">        s-&gt;hiscnt = s-&gt;save_hiscnt;</a>
<a name="ln1697">        break;</a>
<a name="ln1698">      }</a>
<a name="ln1699">    } else {          // one step forwards</a>
<a name="ln1700">      // on last entry, clear the line</a>
<a name="ln1701">      if (s-&gt;hiscnt == *get_hisidx(s-&gt;histype)) {</a>
<a name="ln1702">        s-&gt;hiscnt = get_hislen();</a>
<a name="ln1703">        break;</a>
<a name="ln1704">      }</a>
<a name="ln1705"> </a>
<a name="ln1706">      // not on a history line, nothing to do</a>
<a name="ln1707">      if (s-&gt;hiscnt == get_hislen()) {</a>
<a name="ln1708">        break;</a>
<a name="ln1709">      }</a>
<a name="ln1710"> </a>
<a name="ln1711">      if (s-&gt;hiscnt == get_hislen() - 1) {</a>
<a name="ln1712">        // wrap around</a>
<a name="ln1713">        s-&gt;hiscnt = 0;</a>
<a name="ln1714">      } else {</a>
<a name="ln1715">        s-&gt;hiscnt++;</a>
<a name="ln1716">      }</a>
<a name="ln1717">    }</a>
<a name="ln1718"> </a>
<a name="ln1719">    if (s-&gt;hiscnt &lt; 0 || get_histentry(s-&gt;histype)[s-&gt;hiscnt].hisstr == NULL) {</a>
<a name="ln1720">      s-&gt;hiscnt = s-&gt;save_hiscnt;</a>
<a name="ln1721">      break;</a>
<a name="ln1722">    }</a>
<a name="ln1723"> </a>
<a name="ln1724">    if ((s-&gt;c != K_UP &amp;&amp; s-&gt;c != K_DOWN)</a>
<a name="ln1725">        || s-&gt;hiscnt == s-&gt;save_hiscnt</a>
<a name="ln1726">        || strncmp(get_histentry(s-&gt;histype)[s-&gt;hiscnt].hisstr,</a>
<a name="ln1727">                   s-&gt;lookfor, (size_t)j) == 0) {</a>
<a name="ln1728">      break;</a>
<a name="ln1729">    }</a>
<a name="ln1730">  }</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">/// Handle the Up, Down, Page Up, Page down, CTRL-N and CTRL-P key in the</a>
<a name="ln1734">/// command-line mode.</a>
<a name="ln1735">static int command_line_browse_history(CommandLineState *s)</a>
<a name="ln1736">{</a>
<a name="ln1737">  if (s-&gt;histype == HIST_INVALID || get_hislen() == 0 || s-&gt;firstc == NUL) {</a>
<a name="ln1738">    // no history</a>
<a name="ln1739">    return CMDLINE_NOT_CHANGED;</a>
<a name="ln1740">  }</a>
<a name="ln1741"> </a>
<a name="ln1742">  s-&gt;save_hiscnt = s-&gt;hiscnt;</a>
<a name="ln1743"> </a>
<a name="ln1744">  // save current command string so it can be restored later</a>
<a name="ln1745">  if (s-&gt;lookfor == NULL) {</a>
<a name="ln1746">    s-&gt;lookfor = xstrdup(ccline.cmdbuff);</a>
<a name="ln1747">    s-&gt;lookfor[ccline.cmdpos] = NUL;</a>
<a name="ln1748">  }</a>
<a name="ln1749"> </a>
<a name="ln1750">  bool next_match = (s-&gt;c == K_DOWN || s-&gt;c == K_S_DOWN || s-&gt;c == Ctrl_N</a>
<a name="ln1751">                     || s-&gt;c == K_PAGEDOWN || s-&gt;c == K_KPAGEDOWN);</a>
<a name="ln1752">  command_line_next_histidx(s, next_match);</a>
<a name="ln1753"> </a>
<a name="ln1754">  if (s-&gt;hiscnt != s-&gt;save_hiscnt) {</a>
<a name="ln1755">    // jumped to other entry</a>
<a name="ln1756">    char *p;</a>
<a name="ln1757">    int old_firstc;</a>
<a name="ln1758"> </a>
<a name="ln1759">    XFREE_CLEAR(ccline.cmdbuff);</a>
<a name="ln1760">    s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln1761">    if (s-&gt;hiscnt == get_hislen()) {</a>
<a name="ln1762">      p = s-&gt;lookfor;                  // back to the old one</a>
<a name="ln1763">    } else {</a>
<a name="ln1764">      p = get_histentry(s-&gt;histype)[s-&gt;hiscnt].hisstr;</a>
<a name="ln1765">    }</a>
<a name="ln1766"> </a>
<a name="ln1767">    if (s-&gt;histype == HIST_SEARCH</a>
<a name="ln1768">        &amp;&amp; p != s-&gt;lookfor</a>
<a name="ln1769">        &amp;&amp; (old_firstc = (uint8_t)p[strlen(p) + 1]) != s-&gt;firstc) {</a>
<a name="ln1770">      int len = 0;</a>
<a name="ln1771">      // Correct for the separator character used when</a>
<a name="ln1772">      // adding the history entry vs the one used now.</a>
<a name="ln1773">      // First loop: count length.</a>
<a name="ln1774">      // Second loop: copy the characters.</a>
<a name="ln1775">      for (int i = 0; i &lt;= 1; i++) {</a>
<a name="ln1776">        len = 0;</a>
<a name="ln1777">        for (int j = 0; p[j] != NUL; j++) {</a>
<a name="ln1778">          // Replace old sep with new sep, unless it is</a>
<a name="ln1779">          // escaped.</a>
<a name="ln1780">          if (p[j] == old_firstc</a>
<a name="ln1781">              &amp;&amp; (j == 0 || p[j - 1] != '\\')) {</a>
<a name="ln1782">            if (i &gt; 0) {</a>
<a name="ln1783">              ccline.cmdbuff[len] = (char)s-&gt;firstc;</a>
<a name="ln1784">            }</a>
<a name="ln1785">          } else {</a>
<a name="ln1786">            // Escape new sep, unless it is already</a>
<a name="ln1787">            // escaped.</a>
<a name="ln1788">            if (p[j] == s-&gt;firstc</a>
<a name="ln1789">                &amp;&amp; (j == 0 || p[j - 1] != '\\')) {</a>
<a name="ln1790">              if (i &gt; 0) {</a>
<a name="ln1791">                ccline.cmdbuff[len] = '\\';</a>
<a name="ln1792">              }</a>
<a name="ln1793">              len++;</a>
<a name="ln1794">            }</a>
<a name="ln1795"> </a>
<a name="ln1796">            if (i &gt; 0) {</a>
<a name="ln1797">              ccline.cmdbuff[len] = p[j];</a>
<a name="ln1798">            }</a>
<a name="ln1799">          }</a>
<a name="ln1800">          len++;</a>
<a name="ln1801">        }</a>
<a name="ln1802"> </a>
<a name="ln1803">        if (i == 0) {</a>
<a name="ln1804">          alloc_cmdbuff(len);</a>
<a name="ln1805">        }</a>
<a name="ln1806">      }</a>
<a name="ln1807">      ccline.cmdbuff[len] = NUL;</a>
<a name="ln1808">    } else {</a>
<a name="ln1809">      alloc_cmdbuff((int)strlen(p));</a>
<a name="ln1810">      STRCPY(ccline.cmdbuff, p);</a>
<a name="ln1811">    }</a>
<a name="ln1812"> </a>
<a name="ln1813">    ccline.cmdpos = ccline.cmdlen = (int)strlen(ccline.cmdbuff);</a>
<a name="ln1814">    redrawcmd();</a>
<a name="ln1815">    return CMDLINE_CHANGED;</a>
<a name="ln1816">  }</a>
<a name="ln1817">  beep_flush();</a>
<a name="ln1818">  return CMDLINE_NOT_CHANGED;</a>
<a name="ln1819">}</a>
<a name="ln1820"> </a>
<a name="ln1821">static int command_line_handle_key(CommandLineState *s)</a>
<a name="ln1822">{</a>
<a name="ln1823">  // Big switch for a typed command line character.</a>
<a name="ln1824">  switch (s-&gt;c) {</a>
<a name="ln1825">  case K_BS:</a>
<a name="ln1826">  case Ctrl_H:</a>
<a name="ln1827">  case K_DEL:</a>
<a name="ln1828">  case K_KDEL:</a>
<a name="ln1829">  case Ctrl_W:</a>
<a name="ln1830">    switch (command_line_erase_chars(s)) {</a>
<a name="ln1831">    case CMDLINE_NOT_CHANGED:</a>
<a name="ln1832">      return command_line_not_changed(s);</a>
<a name="ln1833">    case GOTO_NORMAL_MODE:</a>
<a name="ln1834">      return 0;  // back to cmd mode</a>
<a name="ln1835">    default:</a>
<a name="ln1836">      return command_line_changed(s);</a>
<a name="ln1837">    }</a>
<a name="ln1838"> </a>
<a name="ln1839">  case K_INS:</a>
<a name="ln1840">  case K_KINS:</a>
<a name="ln1841">    ccline.overstrike = !ccline.overstrike;</a>
<a name="ln1842"> </a>
<a name="ln1843">    ui_cursor_shape();                // may show different cursor shape</a>
<a name="ln1844">    return command_line_not_changed(s);</a>
<a name="ln1845"> </a>
<a name="ln1846">  case Ctrl_HAT:</a>
<a name="ln1847">    command_line_toggle_langmap(s);</a>
<a name="ln1848">    return command_line_not_changed(s);</a>
<a name="ln1849"> </a>
<a name="ln1850">  case Ctrl_U: {</a>
<a name="ln1851">    // delete all characters left of the cursor</a>
<a name="ln1852">    int j = ccline.cmdpos;</a>
<a name="ln1853">    ccline.cmdlen -= j;</a>
<a name="ln1854">    int i = ccline.cmdpos = 0;</a>
<a name="ln1855">    while (i &lt; ccline.cmdlen) {</a>
<a name="ln1856">      ccline.cmdbuff[i++] = ccline.cmdbuff[j++];</a>
<a name="ln1857">    }</a>
<a name="ln1858"> </a>
<a name="ln1859">    // Truncate at the end, required for multi-byte chars.</a>
<a name="ln1860">    ccline.cmdbuff[ccline.cmdlen] = NUL;</a>
<a name="ln1861">    if (ccline.cmdlen == 0) {</a>
<a name="ln1862">      s-&gt;is_state.search_start = s-&gt;is_state.save_cursor;</a>
<a name="ln1863">    }</a>
<a name="ln1864">    redrawcmd();</a>
<a name="ln1865">    return command_line_changed(s);</a>
<a name="ln1866">  }</a>
<a name="ln1867"> </a>
<a name="ln1868">  case ESC:           // get here if p_wc != ESC or when ESC typed twice</a>
<a name="ln1869">  case Ctrl_C:</a>
<a name="ln1870">    // In exmode it doesn't make sense to return.  Except when</a>
<a name="ln1871">    // &quot;:normal&quot; runs out of characters. Also when highlight callback is active</a>
<a name="ln1872">    // &lt;C-c&gt; should interrupt only it.</a>
<a name="ln1873">    if ((exmode_active &amp;&amp; (ex_normal_busy == 0 || typebuf.tb_len &gt; 0))</a>
<a name="ln1874">        || (getln_interrupted_highlight &amp;&amp; s-&gt;c == Ctrl_C)) {</a>
<a name="ln1875">      getln_interrupted_highlight = false;</a>
<a name="ln1876">      return command_line_not_changed(s);</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    s-&gt;gotesc = true;                 // will free ccline.cmdbuff after</a>
<a name="ln1880">                                      // putting it in history</a>
<a name="ln1881">    return 0;                         // back to cmd mode</a>
<a name="ln1882"> </a>
<a name="ln1883">  case Ctrl_R:                        // insert register</a>
<a name="ln1884">    switch (command_line_insert_reg(s)) {</a>
<a name="ln1885">    case GOTO_NORMAL_MODE:</a>
<a name="ln1886">      return 0;  // back to cmd mode</a>
<a name="ln1887">    case CMDLINE_CHANGED:</a>
<a name="ln1888">      return command_line_changed(s);</a>
<a name="ln1889">    default:</a>
<a name="ln1890">      return command_line_not_changed(s);</a>
<a name="ln1891">    }</a>
<a name="ln1892"> </a>
<a name="ln1893">  case Ctrl_D:</a>
<a name="ln1894">    if (showmatches(&amp;s-&gt;xpc, false) == EXPAND_NOTHING) {</a>
<a name="ln1895">      break;                  // Use ^D as normal char instead</a>
<a name="ln1896">    }</a>
<a name="ln1897"> </a>
<a name="ln1898">    wild_menu_showing = WM_LIST;</a>
<a name="ln1899">    redrawcmd();</a>
<a name="ln1900">    return 1;                 // don't do incremental search now</a>
<a name="ln1901"> </a>
<a name="ln1902">  case K_RIGHT:</a>
<a name="ln1903">  case K_S_RIGHT:</a>
<a name="ln1904">  case K_C_RIGHT:</a>
<a name="ln1905">    do {</a>
<a name="ln1906">      if (ccline.cmdpos &gt;= ccline.cmdlen) {</a>
<a name="ln1907">        break;</a>
<a name="ln1908">      }</a>
<a name="ln1909"> </a>
<a name="ln1910">      int cells = cmdline_charsize(ccline.cmdpos);</a>
<a name="ln1911">      if (KeyTyped &amp;&amp; ccline.cmdspos + cells &gt;= Columns * Rows) {</a>
<a name="ln1912">        break;</a>
<a name="ln1913">      }</a>
<a name="ln1914"> </a>
<a name="ln1915">      ccline.cmdspos += cells;</a>
<a name="ln1916">      ccline.cmdpos += utfc_ptr2len(ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln1917">    } while ((s-&gt;c == K_S_RIGHT || s-&gt;c == K_C_RIGHT</a>
<a name="ln1918">              || (mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_CTRL)))</a>
<a name="ln1919">             &amp;&amp; ccline.cmdbuff[ccline.cmdpos] != ' ');</a>
<a name="ln1920">    ccline.cmdspos = cmd_screencol(ccline.cmdpos);</a>
<a name="ln1921">    return command_line_not_changed(s);</a>
<a name="ln1922"> </a>
<a name="ln1923">  case K_LEFT:</a>
<a name="ln1924">  case K_S_LEFT:</a>
<a name="ln1925">  case K_C_LEFT:</a>
<a name="ln1926">    if (ccline.cmdpos == 0) {</a>
<a name="ln1927">      return command_line_not_changed(s);</a>
<a name="ln1928">    }</a>
<a name="ln1929">    do {</a>
<a name="ln1930">      ccline.cmdpos--;</a>
<a name="ln1931">      // Move to first byte of possibly multibyte char.</a>
<a name="ln1932">      ccline.cmdpos -= utf_head_off(ccline.cmdbuff,</a>
<a name="ln1933">                                    ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln1934">      ccline.cmdspos -= cmdline_charsize(ccline.cmdpos);</a>
<a name="ln1935">    } while (ccline.cmdpos &gt; 0</a>
<a name="ln1936">             &amp;&amp; (s-&gt;c == K_S_LEFT || s-&gt;c == K_C_LEFT</a>
<a name="ln1937">                 || (mod_mask &amp; (MOD_MASK_SHIFT|MOD_MASK_CTRL)))</a>
<a name="ln1938">             &amp;&amp; ccline.cmdbuff[ccline.cmdpos - 1] != ' ');</a>
<a name="ln1939"> </a>
<a name="ln1940">    ccline.cmdspos = cmd_screencol(ccline.cmdpos);</a>
<a name="ln1941">    if (ccline.special_char != NUL) {</a>
<a name="ln1942">      putcmdline(ccline.special_char, ccline.special_shift);</a>
<a name="ln1943">    }</a>
<a name="ln1944"> </a>
<a name="ln1945">    return command_line_not_changed(s);</a>
<a name="ln1946"> </a>
<a name="ln1947">  case K_IGNORE:</a>
<a name="ln1948">    // Ignore mouse event or open_cmdwin() result.</a>
<a name="ln1949">    return command_line_not_changed(s);</a>
<a name="ln1950"> </a>
<a name="ln1951">  case K_MIDDLEDRAG:</a>
<a name="ln1952">  case K_MIDDLERELEASE:</a>
<a name="ln1953">    return command_line_not_changed(s);                 // Ignore mouse</a>
<a name="ln1954"> </a>
<a name="ln1955">  case K_MIDDLEMOUSE:</a>
<a name="ln1956">    cmdline_paste(eval_has_provider(&quot;clipboard&quot;) ? '*' : 0, true, true);</a>
<a name="ln1957">    redrawcmd();</a>
<a name="ln1958">    return command_line_changed(s);</a>
<a name="ln1959"> </a>
<a name="ln1960">  case K_LEFTDRAG:</a>
<a name="ln1961">  case K_LEFTRELEASE:</a>
<a name="ln1962">  case K_RIGHTDRAG:</a>
<a name="ln1963">  case K_RIGHTRELEASE:</a>
<a name="ln1964">    // Ignore drag and release events when the button-down wasn't</a>
<a name="ln1965">    // seen before.</a>
<a name="ln1966">    if (s-&gt;ignore_drag_release) {</a>
<a name="ln1967">      return command_line_not_changed(s);</a>
<a name="ln1968">    }</a>
<a name="ln1969">    FALLTHROUGH;</a>
<a name="ln1970">  case K_LEFTMOUSE:</a>
<a name="ln1971">  case K_RIGHTMOUSE:</a>
<a name="ln1972">    command_line_left_right_mouse(s);</a>
<a name="ln1973">    return command_line_not_changed(s);</a>
<a name="ln1974"> </a>
<a name="ln1975">  // Mouse scroll wheel: ignored here</a>
<a name="ln1976">  case K_MOUSEDOWN:</a>
<a name="ln1977">  case K_MOUSEUP:</a>
<a name="ln1978">  case K_MOUSELEFT:</a>
<a name="ln1979">  case K_MOUSERIGHT:</a>
<a name="ln1980">  // Alternate buttons ignored here</a>
<a name="ln1981">  case K_X1MOUSE:</a>
<a name="ln1982">  case K_X1DRAG:</a>
<a name="ln1983">  case K_X1RELEASE:</a>
<a name="ln1984">  case K_X2MOUSE:</a>
<a name="ln1985">  case K_X2DRAG:</a>
<a name="ln1986">  case K_X2RELEASE:</a>
<a name="ln1987">  case K_MOUSEMOVE:</a>
<a name="ln1988">    return command_line_not_changed(s);</a>
<a name="ln1989"> </a>
<a name="ln1990">  case K_SELECT:          // end of Select mode mapping - ignore</a>
<a name="ln1991">    return command_line_not_changed(s);</a>
<a name="ln1992"> </a>
<a name="ln1993">  case Ctrl_B:            // begin of command line</a>
<a name="ln1994">  case K_HOME:</a>
<a name="ln1995">  case K_KHOME:</a>
<a name="ln1996">  case K_S_HOME:</a>
<a name="ln1997">  case K_C_HOME:</a>
<a name="ln1998">    ccline.cmdpos = 0;</a>
<a name="ln1999">    ccline.cmdspos = cmd_startcol();</a>
<a name="ln2000">    return command_line_not_changed(s);</a>
<a name="ln2001"> </a>
<a name="ln2002">  case Ctrl_E:            // end of command line</a>
<a name="ln2003">  case K_END:</a>
<a name="ln2004">  case K_KEND:</a>
<a name="ln2005">  case K_S_END:</a>
<a name="ln2006">  case K_C_END:</a>
<a name="ln2007">    ccline.cmdpos = ccline.cmdlen;</a>
<a name="ln2008">    ccline.cmdspos = cmd_screencol(ccline.cmdpos);</a>
<a name="ln2009">    return command_line_not_changed(s);</a>
<a name="ln2010"> </a>
<a name="ln2011">  case Ctrl_A:            // all matches</a>
<a name="ln2012">    if (cmdline_pum_active()) {</a>
<a name="ln2013">      // As Ctrl-A completes all the matches, close the popup</a>
<a name="ln2014">      // menu (if present)</a>
<a name="ln2015">      cmdline_pum_cleanup(&amp;ccline);</a>
<a name="ln2016">    }</a>
<a name="ln2017"> </a>
<a name="ln2018">    if (nextwild(&amp;s-&gt;xpc, WILD_ALL, 0, s-&gt;firstc != '@') == FAIL) {</a>
<a name="ln2019">      break;</a>
<a name="ln2020">    }</a>
<a name="ln2021">    s-&gt;xpc.xp_context = EXPAND_NOTHING;</a>
<a name="ln2022">    s-&gt;did_wild_list = false;</a>
<a name="ln2023">    return command_line_changed(s);</a>
<a name="ln2024"> </a>
<a name="ln2025">  case Ctrl_L:</a>
<a name="ln2026">    if (may_add_char_to_search(s-&gt;firstc, &amp;s-&gt;c, &amp;s-&gt;is_state) == OK) {</a>
<a name="ln2027">      return command_line_not_changed(s);</a>
<a name="ln2028">    }</a>
<a name="ln2029"> </a>
<a name="ln2030">    // completion: longest common part</a>
<a name="ln2031">    if (nextwild(&amp;s-&gt;xpc, WILD_LONGEST, 0, s-&gt;firstc != '@') == FAIL) {</a>
<a name="ln2032">      break;</a>
<a name="ln2033">    }</a>
<a name="ln2034">    return command_line_changed(s);</a>
<a name="ln2035"> </a>
<a name="ln2036">  case Ctrl_N:            // next match</a>
<a name="ln2037">  case Ctrl_P:            // previous match</a>
<a name="ln2038">    if (s-&gt;xpc.xp_numfiles &gt; 0) {</a>
<a name="ln2039">      const int wild_type = (s-&gt;c == Ctrl_P) ? WILD_PREV : WILD_NEXT;</a>
<a name="ln2040">      if (nextwild(&amp;s-&gt;xpc, wild_type, 0, s-&gt;firstc != '@') == FAIL) {</a>
<a name="ln2041">        break;</a>
<a name="ln2042">      }</a>
<a name="ln2043">      return command_line_changed(s);</a>
<a name="ln2044">    }</a>
<a name="ln2045">    FALLTHROUGH;</a>
<a name="ln2046"> </a>
<a name="ln2047">  case K_UP:</a>
<a name="ln2048">  case K_DOWN:</a>
<a name="ln2049">  case K_S_UP:</a>
<a name="ln2050">  case K_S_DOWN:</a>
<a name="ln2051">  case K_PAGEUP:</a>
<a name="ln2052">  case K_KPAGEUP:</a>
<a name="ln2053">  case K_PAGEDOWN:</a>
<a name="ln2054">  case K_KPAGEDOWN:</a>
<a name="ln2055">    if (cmdline_pum_active()</a>
<a name="ln2056">        &amp;&amp; (s-&gt;c == K_PAGEUP || s-&gt;c == K_PAGEDOWN</a>
<a name="ln2057">            || s-&gt;c == K_KPAGEUP || s-&gt;c == K_KPAGEDOWN)) {</a>
<a name="ln2058">      // If the popup menu is displayed, then PageUp and PageDown</a>
<a name="ln2059">      // are used to scroll the menu.</a>
<a name="ln2060">      const int wild_type =</a>
<a name="ln2061">        (s-&gt;c == K_PAGEDOWN || s-&gt;c == K_KPAGEDOWN) ? WILD_PAGEDOWN : WILD_PAGEUP;</a>
<a name="ln2062">      if (nextwild(&amp;s-&gt;xpc, wild_type, 0, s-&gt;firstc != '@') == FAIL) {</a>
<a name="ln2063">        break;</a>
<a name="ln2064">      }</a>
<a name="ln2065">      return command_line_changed(s);</a>
<a name="ln2066">    } else {</a>
<a name="ln2067">      switch (command_line_browse_history(s)) {</a>
<a name="ln2068">      case CMDLINE_CHANGED:</a>
<a name="ln2069">        return command_line_changed(s);</a>
<a name="ln2070">      case GOTO_NORMAL_MODE:</a>
<a name="ln2071">        return 0;</a>
<a name="ln2072">      default:</a>
<a name="ln2073">        return command_line_not_changed(s);</a>
<a name="ln2074">      }</a>
<a name="ln2075">    }</a>
<a name="ln2076"> </a>
<a name="ln2077">  case Ctrl_G:  // next match</a>
<a name="ln2078">  case Ctrl_T:  // previous match</a>
<a name="ln2079">    if (may_do_command_line_next_incsearch(s-&gt;firstc, s-&gt;count, &amp;s-&gt;is_state,</a>
<a name="ln2080">                                           s-&gt;c == Ctrl_G) == FAIL) {</a>
<a name="ln2081">      return command_line_not_changed(s);</a>
<a name="ln2082">    }</a>
<a name="ln2083">    break;</a>
<a name="ln2084"> </a>
<a name="ln2085">  case Ctrl_V:</a>
<a name="ln2086">  case Ctrl_Q:</a>
<a name="ln2087">    s-&gt;ignore_drag_release = true;</a>
<a name="ln2088">    putcmdline('^', true);</a>
<a name="ln2089"> </a>
<a name="ln2090">    // Get next (two) characters.</a>
<a name="ln2091">    // Do not include modifiers into the key for CTRL-SHIFT-V.</a>
<a name="ln2092">    s-&gt;c = get_literal(mod_mask &amp; MOD_MASK_SHIFT);</a>
<a name="ln2093"> </a>
<a name="ln2094">    s-&gt;do_abbr = false;                   // don't do abbreviation now</a>
<a name="ln2095">    ccline.special_char = NUL;</a>
<a name="ln2096">    // may need to remove ^ when composing char was typed</a>
<a name="ln2097">    if (utf_iscomposing(s-&gt;c) &amp;&amp; !cmd_silent) {</a>
<a name="ln2098">      if (ui_has(kUICmdline)) {</a>
<a name="ln2099">        // TODO(bfredl): why not make unputcmdline also work with true?</a>
<a name="ln2100">        unputcmdline();</a>
<a name="ln2101">      } else {</a>
<a name="ln2102">        draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);</a>
<a name="ln2103">        msg_putchar(' ');</a>
<a name="ln2104">        cursorcmd();</a>
<a name="ln2105">      }</a>
<a name="ln2106">    }</a>
<a name="ln2107">    break;</a>
<a name="ln2108"> </a>
<a name="ln2109">  case Ctrl_K:</a>
<a name="ln2110">    s-&gt;ignore_drag_release = true;</a>
<a name="ln2111">    putcmdline('?', true);</a>
<a name="ln2112">    s-&gt;c = get_digraph(true);</a>
<a name="ln2113">    ccline.special_char = NUL;</a>
<a name="ln2114"> </a>
<a name="ln2115">    if (s-&gt;c != NUL) {</a>
<a name="ln2116">      break;</a>
<a name="ln2117">    }</a>
<a name="ln2118"> </a>
<a name="ln2119">    redrawcmd();</a>
<a name="ln2120">    return command_line_not_changed(s);</a>
<a name="ln2121"> </a>
<a name="ln2122">  case Ctrl__:            // CTRL-_: switch language mode</a>
<a name="ln2123">    if (!p_ari) {</a>
<a name="ln2124">      break;</a>
<a name="ln2125">    }</a>
<a name="ln2126">    return command_line_not_changed(s);</a>
<a name="ln2127"> </a>
<a name="ln2128">  default:</a>
<a name="ln2129">    // Normal character with no special meaning.  Just set mod_mask</a>
<a name="ln2130">    // to 0x0 so that typing Shift-Space in the GUI doesn't enter</a>
<a name="ln2131">    // the string &lt;S-Space&gt;.  This should only happen after ^V.</a>
<a name="ln2132">    if (!IS_SPECIAL(s-&gt;c)) {</a>
<a name="ln2133">      mod_mask = 0x0;</a>
<a name="ln2134">    }</a>
<a name="ln2135">    break;</a>
<a name="ln2136">  }</a>
<a name="ln2137"> </a>
<a name="ln2138">  // End of switch on command line character.</a>
<a name="ln2139">  // We come here if we have a normal character.</a>
<a name="ln2140">  if (s-&gt;do_abbr &amp;&amp; (IS_SPECIAL(s-&gt;c) || !vim_iswordc(s-&gt;c))</a>
<a name="ln2141">      // Add ABBR_OFF for characters above 0x100, this is</a>
<a name="ln2142">      // what check_abbr() expects.</a>
<a name="ln2143">      &amp;&amp; (ccheck_abbr((s-&gt;c &gt;= 0x100) ? (s-&gt;c + ABBR_OFF) : s-&gt;c)</a>
<a name="ln2144">          || s-&gt;c == Ctrl_RSB)) {</a>
<a name="ln2145">    return command_line_changed(s);</a>
<a name="ln2146">  }</a>
<a name="ln2147"> </a>
<a name="ln2148">  // put the character in the command line</a>
<a name="ln2149">  if (IS_SPECIAL(s-&gt;c) || mod_mask != 0) {</a>
<a name="ln2150">    put_on_cmdline(get_special_key_name(s-&gt;c, mod_mask), -1, true);</a>
<a name="ln2151">  } else {</a>
<a name="ln2152">    int j = utf_char2bytes(s-&gt;c, IObuff);</a>
<a name="ln2153">    IObuff[j] = NUL;                // exclude composing chars</a>
<a name="ln2154">    put_on_cmdline(IObuff, j, true);</a>
<a name="ln2155">  }</a>
<a name="ln2156">  return command_line_changed(s);</a>
<a name="ln2157">}</a>
<a name="ln2158"> </a>
<a name="ln2159">static int command_line_not_changed(CommandLineState *s)</a>
<a name="ln2160">{</a>
<a name="ln2161">  // Incremental searches for &quot;/&quot; and &quot;?&quot;:</a>
<a name="ln2162">  // Enter command_line_not_changed() when a character has been read but the</a>
<a name="ln2163">  // command line did not change. Then we only search and redraw if something</a>
<a name="ln2164">  // changed in the past.</a>
<a name="ln2165">  // Enter command_line_changed() when the command line did change.</a>
<a name="ln2166">  if (!s-&gt;is_state.incsearch_postponed) {</a>
<a name="ln2167">    return 1;</a>
<a name="ln2168">  }</a>
<a name="ln2169">  return command_line_changed(s);</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">/// Guess that the pattern matches everything.  Only finds specific cases, such</a>
<a name="ln2173">/// as a trailing \|, which can happen while typing a pattern.</a>
<a name="ln2174">static bool empty_pattern(char *p, int delim)</a>
<a name="ln2175">{</a>
<a name="ln2176">  size_t n = strlen(p);</a>
<a name="ln2177">  magic_T magic_val = MAGIC_ON;</a>
<a name="ln2178"> </a>
<a name="ln2179">  if (n &gt; 0) {</a>
<a name="ln2180">    (void)skip_regexp_ex(p, delim, magic_isset(), NULL, NULL, &amp;magic_val);</a>
<a name="ln2181">  } else {</a>
<a name="ln2182">    return true;</a>
<a name="ln2183">  }</a>
<a name="ln2184"> </a>
<a name="ln2185">  return empty_pattern_magic(p, n, magic_val);</a>
<a name="ln2186">}</a>
<a name="ln2187"> </a>
<a name="ln2188">static bool empty_pattern_magic(char *p, size_t len, magic_T magic_val)</a>
<a name="ln2189">{</a>
<a name="ln2190">  // remove trailing \v and the like</a>
<a name="ln2191">  while (len &gt;= 2 &amp;&amp; p[len - 2] == '\\'</a>
<a name="ln2192">         &amp;&amp; vim_strchr(&quot;mMvVcCZ&quot;, (uint8_t)p[len - 1]) != NULL) {</a>
<a name="ln2193">    len -= 2;</a>
<a name="ln2194">  }</a>
<a name="ln2195"> </a>
<a name="ln2196">  // true, if the pattern is empty, or the pattern ends with \| and magic is</a>
<a name="ln2197">  // set (or it ends with '|' and very magic is set)</a>
<a name="ln2198">  return len == 0 || (len &gt; 1</a>
<a name="ln2199">                      &amp;&amp; ((p[len - 2] == '\\'</a>
<a name="ln2200">                           &amp;&amp; p[len - 1] == '|' &amp;&amp; magic_val == MAGIC_ON)</a>
<a name="ln2201">                          || (p[len - 2] != '\\'</a>
<a name="ln2202">                              &amp;&amp; p[len - 1] == '|' &amp;&amp; magic_val == MAGIC_ALL)));</a>
<a name="ln2203">}</a>
<a name="ln2204"> </a>
<a name="ln2205">handle_T cmdpreview_get_bufnr(void)</a>
<a name="ln2206">{</a>
<a name="ln2207">  return cmdpreview_bufnr;</a>
<a name="ln2208">}</a>
<a name="ln2209"> </a>
<a name="ln2210">long cmdpreview_get_ns(void)</a>
<a name="ln2211">{</a>
<a name="ln2212">  return cmdpreview_ns;</a>
<a name="ln2213">}</a>
<a name="ln2214"> </a>
<a name="ln2215">/// Sets up command preview buffer.</a>
<a name="ln2216">///</a>
<a name="ln2217">/// @return Pointer to command preview buffer if succeeded, NULL if failed.</a>
<a name="ln2218">static buf_T *cmdpreview_open_buf(void)</a>
<a name="ln2219">{</a>
<a name="ln2220">  buf_T *cmdpreview_buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;</a>
<a name="ln2221"> </a>
<a name="ln2222">  // If preview buffer doesn't exist, open one.</a>
<a name="ln2223">  if (cmdpreview_buf == NULL) {</a>
<a name="ln2224">    Error err = ERROR_INIT;</a>
<a name="ln2225">    handle_T bufnr = nvim_create_buf(false, true, &amp;err);</a>
<a name="ln2226"> </a>
<a name="ln2227">    if (ERROR_SET(&amp;err)) {</a>
<a name="ln2228">      return NULL;</a>
<a name="ln2229">    }</a>
<a name="ln2230"> </a>
<a name="ln2231">    cmdpreview_buf = buflist_findnr(bufnr);</a>
<a name="ln2232">  }</a>
<a name="ln2233"> </a>
<a name="ln2234">  // Preview buffer cannot preview itself!</a>
<a name="ln2235">  if (cmdpreview_buf == curbuf) {</a>
<a name="ln2236">    return NULL;</a>
<a name="ln2237">  }</a>
<a name="ln2238"> </a>
<a name="ln2239">  // Rename preview buffer.</a>
<a name="ln2240">  aco_save_T aco;</a>
<a name="ln2241">  aucmd_prepbuf(&amp;aco, cmdpreview_buf);</a>
<a name="ln2242">  int retv = rename_buffer(&quot;[Preview]&quot;);</a>
<a name="ln2243">  aucmd_restbuf(&amp;aco);</a>
<a name="ln2244"> </a>
<a name="ln2245">  if (retv == FAIL) {</a>
<a name="ln2246">    return NULL;</a>
<a name="ln2247">  }</a>
<a name="ln2248"> </a>
<a name="ln2249">  // Temporarily switch to preview buffer to set it up for previewing.</a>
<a name="ln2250">  aucmd_prepbuf(&amp;aco, cmdpreview_buf);</a>
<a name="ln2251">  buf_clear();</a>
<a name="ln2252">  curbuf-&gt;b_p_ma = true;</a>
<a name="ln2253">  curbuf-&gt;b_p_ul = -1;</a>
<a name="ln2254">  curbuf-&gt;b_p_tw = 0;  // Reset 'textwidth' (was set by ftplugin)</a>
<a name="ln2255">  aucmd_restbuf(&amp;aco);</a>
<a name="ln2256">  cmdpreview_bufnr = cmdpreview_buf-&gt;handle;</a>
<a name="ln2257"> </a>
<a name="ln2258">  return cmdpreview_buf;</a>
<a name="ln2259">}</a>
<a name="ln2260"> </a>
<a name="ln2261">/// Open command preview window if it's not already open.</a>
<a name="ln2262">/// Returns to original window after opening command preview window.</a>
<a name="ln2263">///</a>
<a name="ln2264">/// @param cmdpreview_buf Pointer to command preview buffer</a>
<a name="ln2265">///</a>
<a name="ln2266">/// @return Pointer to command preview window if succeeded, NULL if failed.</a>
<a name="ln2267">static win_T *cmdpreview_open_win(buf_T *cmdpreview_buf)</a>
<a name="ln2268">{</a>
<a name="ln2269">  win_T *save_curwin = curwin;</a>
<a name="ln2270"> </a>
<a name="ln2271">  // Open preview window.</a>
<a name="ln2272">  if (win_split((int)p_cwh, WSP_BOT) == FAIL) {</a>
<a name="ln2273">    return NULL;</a>
<a name="ln2274">  }</a>
<a name="ln2275"> </a>
<a name="ln2276">  win_T *preview_win = curwin;</a>
<a name="ln2277">  Error err = ERROR_INIT;</a>
<a name="ln2278"> </a>
<a name="ln2279">  // Switch to preview buffer</a>
<a name="ln2280">  try_start();</a>
<a name="ln2281">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, cmdpreview_buf-&gt;handle, 0);</a>
<a name="ln2282">  if (try_end(&amp;err) || result == FAIL) {</a>
<a name="ln2283">    api_clear_error(&amp;err);</a>
<a name="ln2284">    return NULL;</a>
<a name="ln2285">  }</a>
<a name="ln2286"> </a>
<a name="ln2287">  curwin-&gt;w_p_cul = false;</a>
<a name="ln2288">  curwin-&gt;w_p_cuc = false;</a>
<a name="ln2289">  curwin-&gt;w_p_spell = false;</a>
<a name="ln2290">  curwin-&gt;w_p_fen = false;</a>
<a name="ln2291"> </a>
<a name="ln2292">  win_enter(save_curwin, false);</a>
<a name="ln2293">  return preview_win;</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296">/// Closes any open command preview windows.</a>
<a name="ln2297">static void cmdpreview_close_win(void)</a>
<a name="ln2298">{</a>
<a name="ln2299">  buf_T *buf = cmdpreview_bufnr ? buflist_findnr(cmdpreview_bufnr) : NULL;</a>
<a name="ln2300">  if (buf != NULL) {</a>
<a name="ln2301">    close_windows(buf, false);</a>
<a name="ln2302">  }</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305">/// Save the undo state of a buffer for command preview.</a>
<a name="ln2306">static void cmdpreview_save_undo(CpUndoInfo *cp_undoinfo, buf_T *buf)</a>
<a name="ln2307">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2308">{</a>
<a name="ln2309">  cp_undoinfo-&gt;save_b_u_synced = buf-&gt;b_u_synced;</a>
<a name="ln2310">  cp_undoinfo-&gt;save_b_u_oldhead = buf-&gt;b_u_oldhead;</a>
<a name="ln2311">  cp_undoinfo-&gt;save_b_u_newhead = buf-&gt;b_u_newhead;</a>
<a name="ln2312">  cp_undoinfo-&gt;save_b_u_curhead = buf-&gt;b_u_curhead;</a>
<a name="ln2313">  cp_undoinfo-&gt;save_b_u_numhead = buf-&gt;b_u_numhead;</a>
<a name="ln2314">  cp_undoinfo-&gt;save_b_u_seq_last = buf-&gt;b_u_seq_last;</a>
<a name="ln2315">  cp_undoinfo-&gt;save_b_u_save_nr_last = buf-&gt;b_u_save_nr_last;</a>
<a name="ln2316">  cp_undoinfo-&gt;save_b_u_seq_cur = buf-&gt;b_u_seq_cur;</a>
<a name="ln2317">  cp_undoinfo-&gt;save_b_u_time_cur = buf-&gt;b_u_time_cur;</a>
<a name="ln2318">  cp_undoinfo-&gt;save_b_u_save_nr_cur = buf-&gt;b_u_save_nr_cur;</a>
<a name="ln2319">  cp_undoinfo-&gt;save_b_u_line_ptr = buf-&gt;b_u_line_ptr;</a>
<a name="ln2320">  cp_undoinfo-&gt;save_b_u_line_lnum = buf-&gt;b_u_line_lnum;</a>
<a name="ln2321">  cp_undoinfo-&gt;save_b_u_line_colnr = buf-&gt;b_u_line_colnr;</a>
<a name="ln2322">}</a>
<a name="ln2323"> </a>
<a name="ln2324">/// Restore the undo state of a buffer for command preview.</a>
<a name="ln2325">static void cmdpreview_restore_undo(const CpUndoInfo *cp_undoinfo, buf_T *buf)</a>
<a name="ln2326">{</a>
<a name="ln2327">  buf-&gt;b_u_oldhead = cp_undoinfo-&gt;save_b_u_oldhead;</a>
<a name="ln2328">  buf-&gt;b_u_newhead = cp_undoinfo-&gt;save_b_u_newhead;</a>
<a name="ln2329">  buf-&gt;b_u_curhead = cp_undoinfo-&gt;save_b_u_curhead;</a>
<a name="ln2330">  buf-&gt;b_u_numhead = cp_undoinfo-&gt;save_b_u_numhead;</a>
<a name="ln2331">  buf-&gt;b_u_seq_last = cp_undoinfo-&gt;save_b_u_seq_last;</a>
<a name="ln2332">  buf-&gt;b_u_save_nr_last = cp_undoinfo-&gt;save_b_u_save_nr_last;</a>
<a name="ln2333">  buf-&gt;b_u_seq_cur = cp_undoinfo-&gt;save_b_u_seq_cur;</a>
<a name="ln2334">  buf-&gt;b_u_time_cur = cp_undoinfo-&gt;save_b_u_time_cur;</a>
<a name="ln2335">  buf-&gt;b_u_save_nr_cur = cp_undoinfo-&gt;save_b_u_save_nr_cur;</a>
<a name="ln2336">  buf-&gt;b_u_line_ptr = cp_undoinfo-&gt;save_b_u_line_ptr;</a>
<a name="ln2337">  buf-&gt;b_u_line_lnum = cp_undoinfo-&gt;save_b_u_line_lnum;</a>
<a name="ln2338">  buf-&gt;b_u_line_colnr = cp_undoinfo-&gt;save_b_u_line_colnr;</a>
<a name="ln2339">  if (buf-&gt;b_u_curhead == NULL) {</a>
<a name="ln2340">    buf-&gt;b_u_synced = cp_undoinfo-&gt;save_b_u_synced;</a>
<a name="ln2341">  }</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344">/// Save current state and prepare windows and buffers for command preview.</a>
<a name="ln2345">static void cmdpreview_prepare(CpInfo *cpinfo)</a>
<a name="ln2346">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2347">{</a>
<a name="ln2348">  Set(ptr_t) saved_bufs = SET_INIT;</a>
<a name="ln2349"> </a>
<a name="ln2350">  kv_init(cpinfo-&gt;buf_info);</a>
<a name="ln2351">  kv_init(cpinfo-&gt;win_info);</a>
<a name="ln2352"> </a>
<a name="ln2353">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln2354">    buf_T *buf = win-&gt;w_buffer;</a>
<a name="ln2355"> </a>
<a name="ln2356">    // Don't save state of command preview buffer or preview window.</a>
<a name="ln2357">    if (buf-&gt;handle == cmdpreview_bufnr) {</a>
<a name="ln2358">      continue;</a>
<a name="ln2359">    }</a>
<a name="ln2360"> </a>
<a name="ln2361">    if (!set_has(ptr_t, &amp;saved_bufs, buf)) {</a>
<a name="ln2362">      CpBufInfo cp_bufinfo;</a>
<a name="ln2363">      cp_bufinfo.buf = buf;</a>
<a name="ln2364">      cp_bufinfo.save_b_p_ul = buf-&gt;b_p_ul;</a>
<a name="ln2365">      cp_bufinfo.save_b_changed = buf-&gt;b_changed;</a>
<a name="ln2366">      cp_bufinfo.save_changedtick = buf_get_changedtick(buf);</a>
<a name="ln2367">      cmdpreview_save_undo(&amp;cp_bufinfo.undo_info, buf);</a>
<a name="ln2368">      kv_push(cpinfo-&gt;buf_info, cp_bufinfo);</a>
<a name="ln2369">      set_put(ptr_t, &amp;saved_bufs, buf);</a>
<a name="ln2370"> </a>
<a name="ln2371">      u_clearall(buf);</a>
<a name="ln2372">      buf-&gt;b_p_ul = INT_MAX;  // Make sure we can undo all changes</a>
<a name="ln2373">    }</a>
<a name="ln2374"> </a>
<a name="ln2375">    CpWinInfo cp_wininfo;</a>
<a name="ln2376">    cp_wininfo.win = win;</a>
<a name="ln2377"> </a>
<a name="ln2378">    // Save window cursor position and viewstate</a>
<a name="ln2379">    cp_wininfo.save_w_cursor = win-&gt;w_cursor;</a>
<a name="ln2380">    save_viewstate(win, &amp;cp_wininfo.save_viewstate);</a>
<a name="ln2381"> </a>
<a name="ln2382">    // Save 'cursorline' and 'cursorcolumn'</a>
<a name="ln2383">    cp_wininfo.save_w_p_cul = win-&gt;w_p_cul;</a>
<a name="ln2384">    cp_wininfo.save_w_p_cuc = win-&gt;w_p_cuc;</a>
<a name="ln2385"> </a>
<a name="ln2386">    kv_push(cpinfo-&gt;win_info, cp_wininfo);</a>
<a name="ln2387"> </a>
<a name="ln2388">    win-&gt;w_p_cul = false;       // Disable 'cursorline' so it doesn't mess up the highlights</a>
<a name="ln2389">    win-&gt;w_p_cuc = false;       // Disable 'cursorcolumn' so it doesn't mess up the highlights</a>
<a name="ln2390">  }</a>
<a name="ln2391"> </a>
<a name="ln2392">  set_destroy(ptr_t, &amp;saved_bufs);</a>
<a name="ln2393"> </a>
<a name="ln2394">  cpinfo-&gt;save_hls = p_hls;</a>
<a name="ln2395">  cpinfo-&gt;save_cmdmod = cmdmod;</a>
<a name="ln2396">  win_size_save(&amp;cpinfo-&gt;save_view);</a>
<a name="ln2397">  save_search_patterns();</a>
<a name="ln2398"> </a>
<a name="ln2399">  p_hls = false;                 // Don't show search highlighting during live substitution</a>
<a name="ln2400">  cmdmod.cmod_split = 0;         // Disable :leftabove/botright modifiers</a>
<a name="ln2401">  cmdmod.cmod_tab = 0;           // Disable :tab modifier</a>
<a name="ln2402">  cmdmod.cmod_flags |= CMOD_NOSWAPFILE;  // Disable swap for preview buffer</a>
<a name="ln2403"> </a>
<a name="ln2404">  u_sync(true);</a>
<a name="ln2405">}</a>
<a name="ln2406"> </a>
<a name="ln2407">/// Restore the state of buffers and windows for command preview.</a>
<a name="ln2408">static void cmdpreview_restore_state(CpInfo *cpinfo)</a>
<a name="ln2409">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2410">{</a>
<a name="ln2411">  for (size_t i = 0; i &lt; cpinfo-&gt;buf_info.size; i++) {</a>
<a name="ln2412">    CpBufInfo cp_bufinfo = cpinfo-&gt;buf_info.items[i];</a>
<a name="ln2413">    buf_T *buf = cp_bufinfo.buf;</a>
<a name="ln2414"> </a>
<a name="ln2415">    buf-&gt;b_changed = cp_bufinfo.save_b_changed;</a>
<a name="ln2416"> </a>
<a name="ln2417">    // Clear preview highlights.</a>
<a name="ln2418">    extmark_clear(buf, (uint32_t)cmdpreview_ns, 0, 0, MAXLNUM, MAXCOL);</a>
<a name="ln2419"> </a>
<a name="ln2420">    if (buf-&gt;b_u_seq_cur != cp_bufinfo.undo_info.save_b_u_seq_cur) {</a>
<a name="ln2421">      int count = 0;</a>
<a name="ln2422"> </a>
<a name="ln2423">      // Calculate how many undo steps are necessary to restore earlier state.</a>
<a name="ln2424">      for (u_header_T *uhp = buf-&gt;b_u_curhead ? buf-&gt;b_u_curhead : buf-&gt;b_u_newhead;</a>
<a name="ln2425">           uhp != NULL;</a>
<a name="ln2426">           uhp = uhp-&gt;uh_next.ptr, ++count) {}</a>
<a name="ln2427"> </a>
<a name="ln2428">      aco_save_T aco;</a>
<a name="ln2429">      aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln2430">      // Ensure all the entries will be undone</a>
<a name="ln2431">      if (curbuf-&gt;b_u_synced == false) {</a>
<a name="ln2432">        u_sync(true);</a>
<a name="ln2433">      }</a>
<a name="ln2434">      // Undo invisibly. This also moves the cursor!</a>
<a name="ln2435">      if (!u_undo_and_forget(count, false)) {</a>
<a name="ln2436">        abort();</a>
<a name="ln2437">      }</a>
<a name="ln2438">      aucmd_restbuf(&amp;aco);</a>
<a name="ln2439">    }</a>
<a name="ln2440"> </a>
<a name="ln2441">    u_blockfree(buf);</a>
<a name="ln2442">    cmdpreview_restore_undo(&amp;cp_bufinfo.undo_info, buf);</a>
<a name="ln2443"> </a>
<a name="ln2444">    if (cp_bufinfo.save_changedtick != buf_get_changedtick(buf)) {</a>
<a name="ln2445">      buf_set_changedtick(buf, cp_bufinfo.save_changedtick);</a>
<a name="ln2446">    }</a>
<a name="ln2447"> </a>
<a name="ln2448">    buf-&gt;b_p_ul = cp_bufinfo.save_b_p_ul;        // Restore 'undolevels'</a>
<a name="ln2449">  }</a>
<a name="ln2450"> </a>
<a name="ln2451">  for (size_t i = 0; i &lt; cpinfo-&gt;win_info.size; i++) {</a>
<a name="ln2452">    CpWinInfo cp_wininfo = cpinfo-&gt;win_info.items[i];</a>
<a name="ln2453">    win_T *win = cp_wininfo.win;</a>
<a name="ln2454"> </a>
<a name="ln2455">    // Restore window cursor position and viewstate</a>
<a name="ln2456">    win-&gt;w_cursor = cp_wininfo.save_w_cursor;</a>
<a name="ln2457">    restore_viewstate(win, &amp;cp_wininfo.save_viewstate);</a>
<a name="ln2458"> </a>
<a name="ln2459">    // Restore 'cursorline' and 'cursorcolumn'</a>
<a name="ln2460">    win-&gt;w_p_cul = cp_wininfo.save_w_p_cul;</a>
<a name="ln2461">    win-&gt;w_p_cuc = cp_wininfo.save_w_p_cuc;</a>
<a name="ln2462"> </a>
<a name="ln2463">    update_topline(win);</a>
<a name="ln2464">  }</a>
<a name="ln2465"> </a>
<a name="ln2466">  cmdmod = cpinfo-&gt;save_cmdmod;                // Restore cmdmod</a>
<a name="ln2467">  p_hls = cpinfo-&gt;save_hls;                    // Restore 'hlsearch'</a>
<a name="ln2468">  restore_search_patterns();           // Restore search patterns</a>
<a name="ln2469">  win_size_restore(&amp;cpinfo-&gt;save_view);        // Restore window sizes</a>
<a name="ln2470"> </a>
<a name="ln2471">  ga_clear(&amp;cpinfo-&gt;save_view);</a>
<a name="ln2472">  kv_destroy(cpinfo-&gt;win_info);</a>
<a name="ln2473">  kv_destroy(cpinfo-&gt;buf_info);</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">/// Show 'inccommand' preview if command is previewable. It works like this:</a>
<a name="ln2477">///    1. Store current undo information so we can revert to current state later.</a>
<a name="ln2478">///    2. Execute the preview callback with the parsed command, preview buffer number and preview</a>
<a name="ln2479">///       namespace number as arguments. The preview callback sets the highlight and does the</a>
<a name="ln2480">///       changes required for the preview if needed.</a>
<a name="ln2481">///    3. Preview callback returns 0, 1 or 2. 0 means no preview is shown. 1 means preview is shown</a>
<a name="ln2482">///       but preview window doesn't need to be opened. 2 means preview is shown and preview window</a>
<a name="ln2483">///       needs to be opened if inccommand=split.</a>
<a name="ln2484">///    4. Use the return value of the preview callback to determine whether to</a>
<a name="ln2485">///       open the preview window or not and open preview window if needed.</a>
<a name="ln2486">///    5. If the return value of the preview callback is not 0, update the screen while the effects</a>
<a name="ln2487">///       of the preview are still in place.</a>
<a name="ln2488">///    6. Revert all changes made by the preview callback.</a>
<a name="ln2489">///</a>
<a name="ln2490">/// @return whether preview is shown or not.</a>
<a name="ln2491">static bool cmdpreview_may_show(CommandLineState *s)</a>
<a name="ln2492">{</a>
<a name="ln2493">  // Parse the command line and return if it fails.</a>
<a name="ln2494">  exarg_T ea;</a>
<a name="ln2495">  CmdParseInfo cmdinfo;</a>
<a name="ln2496">  // Copy the command line so we can modify it.</a>
<a name="ln2497">  int cmdpreview_type = 0;</a>
<a name="ln2498">  char *cmdline = xstrdup(ccline.cmdbuff);</a>
<a name="ln2499">  const char *errormsg = NULL;</a>
<a name="ln2500">  emsg_off++;  // Block errors when parsing the command line, and don't update v:errmsg</a>
<a name="ln2501">  if (!parse_cmdline(cmdline, &amp;ea, &amp;cmdinfo, &amp;errormsg)) {</a>
<a name="ln2502">    emsg_off--;</a>
<a name="ln2503">    goto end;</a>
<a name="ln2504">  }</a>
<a name="ln2505">  emsg_off--;</a>
<a name="ln2506"> </a>
<a name="ln2507">  // Check if command is previewable, if not, don't attempt to show preview</a>
<a name="ln2508">  if (!(ea.argt &amp; EX_PREVIEW)) {</a>
<a name="ln2509">    undo_cmdmod(&amp;cmdinfo.cmdmod);</a>
<a name="ln2510">    goto end;</a>
<a name="ln2511">  }</a>
<a name="ln2512"> </a>
<a name="ln2513">  // Swap invalid command range if needed</a>
<a name="ln2514">  if ((ea.argt &amp; EX_RANGE) &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln2515">    linenr_T lnum = ea.line1;</a>
<a name="ln2516">    ea.line1 = ea.line2;</a>
<a name="ln2517">    ea.line2 = lnum;</a>
<a name="ln2518">  }</a>
<a name="ln2519"> </a>
<a name="ln2520">  CpInfo cpinfo;</a>
<a name="ln2521">  bool icm_split = *p_icm == 's';  // inccommand=split</a>
<a name="ln2522">  buf_T *cmdpreview_buf = NULL;</a>
<a name="ln2523">  win_T *cmdpreview_win = NULL;</a>
<a name="ln2524"> </a>
<a name="ln2525">  emsg_silent++;                 // Block error reporting as the command may be incomplete,</a>
<a name="ln2526">                                 // but still update v:errmsg</a>
<a name="ln2527">  msg_silent++;                  // Block messages, namely ones that prompt</a>
<a name="ln2528">  block_autocmds();              // Block events</a>
<a name="ln2529"> </a>
<a name="ln2530">  // Save current state and prepare for command preview.</a>
<a name="ln2531">  cmdpreview_prepare(&amp;cpinfo);</a>
<a name="ln2532"> </a>
<a name="ln2533">  // Open preview buffer if inccommand=split.</a>
<a name="ln2534">  if (!icm_split) {</a>
<a name="ln2535">    cmdpreview_bufnr = 0;</a>
<a name="ln2536">  } else if ((cmdpreview_buf = cmdpreview_open_buf()) == NULL) {</a>
<a name="ln2537">    abort();</a>
<a name="ln2538">  }</a>
<a name="ln2539">  // Setup preview namespace if it's not already set.</a>
<a name="ln2540">  if (!cmdpreview_ns) {</a>
<a name="ln2541">    cmdpreview_ns = (int)nvim_create_namespace((String)STRING_INIT);</a>
<a name="ln2542">  }</a>
<a name="ln2543"> </a>
<a name="ln2544">  // Set cmdpreview state.</a>
<a name="ln2545">  cmdpreview = true;</a>
<a name="ln2546"> </a>
<a name="ln2547">  // Execute the preview callback and use its return value to determine whether to show preview or</a>
<a name="ln2548">  // open the preview window. The preview callback also handles doing the changes and highlights for</a>
<a name="ln2549">  // the preview.</a>
<a name="ln2550">  Error err = ERROR_INIT;</a>
<a name="ln2551">  try_start();</a>
<a name="ln2552">  cmdpreview_type = execute_cmd(&amp;ea, &amp;cmdinfo, true);</a>
<a name="ln2553">  if (try_end(&amp;err)) {</a>
<a name="ln2554">    api_clear_error(&amp;err);</a>
<a name="ln2555">    cmdpreview_type = 0;</a>
<a name="ln2556">  }</a>
<a name="ln2557"> </a>
<a name="ln2558">  // If inccommand=split and preview callback returns 2, open preview window.</a>
<a name="ln2559">  if (icm_split &amp;&amp; cmdpreview_type == 2</a>
<a name="ln2560">      &amp;&amp; (cmdpreview_win = cmdpreview_open_win(cmdpreview_buf)) == NULL) {</a>
<a name="ln2561">    // If there's not enough room to open the preview window, just preview without the window.</a>
<a name="ln2562">    cmdpreview_type = 1;</a>
<a name="ln2563">  }</a>
<a name="ln2564"> </a>
<a name="ln2565">  // If preview callback return value is nonzero, update screen now.</a>
<a name="ln2566">  if (cmdpreview_type != 0) {</a>
<a name="ln2567">    int save_rd = RedrawingDisabled;</a>
<a name="ln2568">    RedrawingDisabled = 0;</a>
<a name="ln2569">    update_screen();</a>
<a name="ln2570">    RedrawingDisabled = save_rd;</a>
<a name="ln2571">  }</a>
<a name="ln2572"> </a>
<a name="ln2573">  // Close preview window if it's open.</a>
<a name="ln2574">  if (icm_split &amp;&amp; cmdpreview_type == 2 &amp;&amp; cmdpreview_win != NULL) {</a>
<a name="ln2575">    cmdpreview_close_win();</a>
<a name="ln2576">  }</a>
<a name="ln2577"> </a>
<a name="ln2578">  // Restore state.</a>
<a name="ln2579">  cmdpreview_restore_state(&amp;cpinfo);</a>
<a name="ln2580"> </a>
<a name="ln2581">  unblock_autocmds();                  // Unblock events</a>
<a name="ln2582">  msg_silent--;                        // Unblock messages</a>
<a name="ln2583">  emsg_silent--;                       // Unblock error reporting</a>
<a name="ln2584">  redrawcmdline();</a>
<a name="ln2585">end:</a>
<a name="ln2586">  xfree(cmdline);</a>
<a name="ln2587">  return cmdpreview_type != 0;</a>
<a name="ln2588">}</a>
<a name="ln2589"> </a>
<a name="ln2590">/// Trigger CmdlineChanged autocommands.</a>
<a name="ln2591">static void do_autocmd_cmdlinechanged(int firstc)</a>
<a name="ln2592">{</a>
<a name="ln2593">  if (has_event(EVENT_CMDLINECHANGED)) {</a>
<a name="ln2594">    TryState tstate;</a>
<a name="ln2595">    Error err = ERROR_INIT;</a>
<a name="ln2596">    save_v_event_T save_v_event;</a>
<a name="ln2597">    dict_T *dict = get_v_event(&amp;save_v_event);</a>
<a name="ln2598"> </a>
<a name="ln2599">    char firstcbuf[2];</a>
<a name="ln2600">    firstcbuf[0] = (char)firstc;</a>
<a name="ln2601">    firstcbuf[1] = 0;</a>
<a name="ln2602"> </a>
<a name="ln2603">    // set v:event to a dictionary with information about the commandline</a>
<a name="ln2604">    tv_dict_add_str(dict, S_LEN(&quot;cmdtype&quot;), firstcbuf);</a>
<a name="ln2605">    tv_dict_add_nr(dict, S_LEN(&quot;cmdlevel&quot;), ccline.level);</a>
<a name="ln2606">    tv_dict_set_keys_readonly(dict);</a>
<a name="ln2607">    try_enter(&amp;tstate);</a>
<a name="ln2608"> </a>
<a name="ln2609">    apply_autocmds(EVENT_CMDLINECHANGED, firstcbuf, firstcbuf, false, curbuf);</a>
<a name="ln2610">    restore_v_event(dict, &amp;save_v_event);</a>
<a name="ln2611"> </a>
<a name="ln2612">    bool tl_ret = try_leave(&amp;tstate, &amp;err);</a>
<a name="ln2613">    if (!tl_ret &amp;&amp; ERROR_SET(&amp;err)) {</a>
<a name="ln2614">      msg_putchar('\n');</a>
<a name="ln2615">      msg_scroll = true;</a>
<a name="ln2616">      msg_puts_attr(err.msg, HL_ATTR(HLF_E)|MSG_HIST);</a>
<a name="ln2617">      api_clear_error(&amp;err);</a>
<a name="ln2618">      redrawcmd();</a>
<a name="ln2619">    }</a>
<a name="ln2620">  }</a>
<a name="ln2621">}</a>
<a name="ln2622"> </a>
<a name="ln2623">static int command_line_changed(CommandLineState *s)</a>
<a name="ln2624">{</a>
<a name="ln2625">  // Trigger CmdlineChanged autocommands.</a>
<a name="ln2626">  do_autocmd_cmdlinechanged(s-&gt;firstc &gt; 0 ? s-&gt;firstc : '-');</a>
<a name="ln2627"> </a>
<a name="ln2628">  const bool prev_cmdpreview = cmdpreview;</a>
<a name="ln2629">  if (s-&gt;firstc == ':'</a>
<a name="ln2630">      &amp;&amp; current_sctx.sc_sid == 0    // only if interactive</a>
<a name="ln2631">      &amp;&amp; *p_icm != NUL       // 'inccommand' is set</a>
<a name="ln2632">      &amp;&amp; curbuf-&gt;b_p_ma      // buffer is modifiable</a>
<a name="ln2633">      &amp;&amp; cmdline_star == 0   // not typing a password</a>
<a name="ln2634">      &amp;&amp; !vpeekc_any()</a>
<a name="ln2635">      &amp;&amp; cmdpreview_may_show(s)) {</a>
<a name="ln2636">    // 'inccommand' preview has been shown.</a>
<a name="ln2637">  } else {</a>
<a name="ln2638">    cmdpreview = false;</a>
<a name="ln2639">    if (prev_cmdpreview) {</a>
<a name="ln2640">      // TODO(bfredl): add an immediate redraw flag for cmdline mode which will trigger</a>
<a name="ln2641">      // at next wait-for-input</a>
<a name="ln2642">      update_screen();  // Clear 'inccommand' preview.</a>
<a name="ln2643">    }</a>
<a name="ln2644">    if (s-&gt;xpc.xp_context == EXPAND_NOTHING &amp;&amp; (KeyTyped || vpeekc() == NUL)) {</a>
<a name="ln2645">      may_do_incsearch_highlighting(s-&gt;firstc, s-&gt;count, &amp;s-&gt;is_state);</a>
<a name="ln2646">    }</a>
<a name="ln2647">  }</a>
<a name="ln2648"> </a>
<a name="ln2649">  if (cmdmsg_rl || (p_arshape &amp;&amp; !p_tbidi)) {</a>
<a name="ln2650">    // Always redraw the whole command line to fix shaping and</a>
<a name="ln2651">    // right-left typing.  Not efficient, but it works.</a>
<a name="ln2652">    // Do it only when there are no characters left to read</a>
<a name="ln2653">    // to avoid useless intermediate redraws.</a>
<a name="ln2654">    // if cmdline is external the ui handles shaping, no redraw needed.</a>
<a name="ln2655">    if (!ui_has(kUICmdline) &amp;&amp; vpeekc() == NUL) {</a>
<a name="ln2656">      redrawcmd();</a>
<a name="ln2657">    }</a>
<a name="ln2658">  }</a>
<a name="ln2659"> </a>
<a name="ln2660">  return 1;</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">/// Abandon the command line.</a>
<a name="ln2664">static void abandon_cmdline(void)</a>
<a name="ln2665">{</a>
<a name="ln2666">  XFREE_CLEAR(ccline.cmdbuff);</a>
<a name="ln2667">  ccline.redraw_state = kCmdRedrawNone;</a>
<a name="ln2668">  if (msg_scrolled == 0) {</a>
<a name="ln2669">    compute_cmdrow();</a>
<a name="ln2670">  }</a>
<a name="ln2671">  msg(&quot;&quot;, 0);</a>
<a name="ln2672">  redraw_cmdline = true;</a>
<a name="ln2673">}</a>
<a name="ln2674"> </a>
<a name="ln2675">/// getcmdline() - accept a command line starting with firstc.</a>
<a name="ln2676">///</a>
<a name="ln2677">/// firstc == ':'            get &quot;:&quot; command line.</a>
<a name="ln2678">/// firstc == '/' or '?'     get search pattern</a>
<a name="ln2679">/// firstc == '='            get expression</a>
<a name="ln2680">/// firstc == '@'            get text for input() function</a>
<a name="ln2681">/// firstc == '&gt;'            get text for debug mode</a>
<a name="ln2682">/// firstc == NUL            get text for :insert command</a>
<a name="ln2683">/// firstc == -1             like NUL, and break on CTRL-C</a>
<a name="ln2684">///</a>
<a name="ln2685">/// The line is collected in ccline.cmdbuff, which is reallocated to fit the</a>
<a name="ln2686">/// command line.</a>
<a name="ln2687">///</a>
<a name="ln2688">/// Careful: getcmdline() can be called recursively!</a>
<a name="ln2689">///</a>
<a name="ln2690">/// Return pointer to allocated string if there is a commandline, NULL</a>
<a name="ln2691">/// otherwise.</a>
<a name="ln2692">///</a>
<a name="ln2693">/// @param count  only used for incremental search</a>
<a name="ln2694">/// @param indent  indent for inside conditionals</a>
<a name="ln2695">char *getcmdline(int firstc, int count, int indent, bool do_concat FUNC_ATTR_UNUSED)</a>
<a name="ln2696">{</a>
<a name="ln2697">  return (char *)command_line_enter(firstc, count, indent, true);</a>
<a name="ln2698">}</a>
<a name="ln2699"> </a>
<a name="ln2700">/// Get a command line with a prompt</a>
<a name="ln2701">///</a>
<a name="ln2702">/// This is prepared to be called recursively from getcmdline() (e.g. by</a>
<a name="ln2703">/// f_input() when evaluating an expression from `&lt;C-r&gt;=`).</a>
<a name="ln2704">///</a>
<a name="ln2705">/// @param[in]  firstc  Prompt type: e.g. '@' for input(), '&gt;' for debug.</a>
<a name="ln2706">/// @param[in]  prompt  Prompt string: what is displayed before the user text.</a>
<a name="ln2707">/// @param[in]  attr  Prompt highlighting.</a>
<a name="ln2708">/// @param[in]  xp_context  Type of expansion.</a>
<a name="ln2709">/// @param[in]  xp_arg  User-defined expansion argument.</a>
<a name="ln2710">/// @param[in]  highlight_callback  Callback used for highlighting user input.</a>
<a name="ln2711">///</a>
<a name="ln2712">/// @return [allocated] Command line or NULL.</a>
<a name="ln2713">char *getcmdline_prompt(const int firstc, const char *const prompt, const int attr,</a>
<a name="ln2714">                        const int xp_context, const char *const xp_arg,</a>
<a name="ln2715">                        const Callback highlight_callback)</a>
<a name="ln2716">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln2717">{</a>
<a name="ln2718">  const int msg_col_save = msg_col;</a>
<a name="ln2719"> </a>
<a name="ln2720">  CmdlineInfo save_ccline;</a>
<a name="ln2721">  bool did_save_ccline = false;</a>
<a name="ln2722">  if (ccline.cmdbuff != NULL) {</a>
<a name="ln2723">    // Save the values of the current cmdline and restore them below.</a>
<a name="ln2724">    save_cmdline(&amp;save_ccline);</a>
<a name="ln2725">    did_save_ccline = true;</a>
<a name="ln2726">  } else {</a>
<a name="ln2727">    CLEAR_FIELD(ccline);</a>
<a name="ln2728">  }</a>
<a name="ln2729">  ccline.prompt_id = last_prompt_id++;</a>
<a name="ln2730">  ccline.cmdprompt = (char *)prompt;</a>
<a name="ln2731">  ccline.cmdattr = attr;</a>
<a name="ln2732">  ccline.xp_context = xp_context;</a>
<a name="ln2733">  ccline.xp_arg = (char *)xp_arg;</a>
<a name="ln2734">  ccline.input_fn = (firstc == '@');</a>
<a name="ln2735">  ccline.highlight_callback = highlight_callback;</a>
<a name="ln2736"> </a>
<a name="ln2737">  int msg_silent_saved = msg_silent;</a>
<a name="ln2738">  msg_silent = 0;</a>
<a name="ln2739"> </a>
<a name="ln2740">  char *const ret = (char *)command_line_enter(firstc, 1L, 0, false);</a>
<a name="ln2741"> </a>
<a name="ln2742">  if (did_save_ccline) {</a>
<a name="ln2743">    restore_cmdline(&amp;save_ccline);</a>
<a name="ln2744">  }</a>
<a name="ln2745">  msg_silent = msg_silent_saved;</a>
<a name="ln2746">  // Restore msg_col, the prompt from input() may have changed it.</a>
<a name="ln2747">  // But only if called recursively and the commandline is therefore being</a>
<a name="ln2748">  // restored to an old one; if not, the input() prompt stays on the screen,</a>
<a name="ln2749">  // so we need its modified msg_col left intact.</a>
<a name="ln2750">  if (ccline.cmdbuff != NULL) {</a>
<a name="ln2751">    msg_col = msg_col_save;</a>
<a name="ln2752">  }</a>
<a name="ln2753"> </a>
<a name="ln2754">  return ret;</a>
<a name="ln2755">}</a>
<a name="ln2756"> </a>
<a name="ln2757">/// Read the 'wildmode' option, fill wim_flags[].</a>
<a name="ln2758">int check_opt_wim(void)</a>
<a name="ln2759">{</a>
<a name="ln2760">  uint8_t new_wim_flags[4];</a>
<a name="ln2761">  int i;</a>
<a name="ln2762">  int idx = 0;</a>
<a name="ln2763"> </a>
<a name="ln2764">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln2765">    new_wim_flags[i] = 0;</a>
<a name="ln2766">  }</a>
<a name="ln2767"> </a>
<a name="ln2768">  for (char *p = p_wim; *p; p++) {</a>
<a name="ln2769">    for (i = 0; ASCII_ISALPHA(p[i]); i++) {}</a>
<a name="ln2770">    if (p[i] != NUL &amp;&amp; p[i] != ',' &amp;&amp; p[i] != ':') {</a>
<a name="ln2771">      return FAIL;</a>
<a name="ln2772">    }</a>
<a name="ln2773">    if (i == 7 &amp;&amp; strncmp(p, &quot;longest&quot;, 7) == 0) {</a>
<a name="ln2774">      new_wim_flags[idx] |= WIM_LONGEST;</a>
<a name="ln2775">    } else if (i == 4 &amp;&amp; strncmp(p, &quot;full&quot;, 4) == 0) {</a>
<a name="ln2776">      new_wim_flags[idx] |= WIM_FULL;</a>
<a name="ln2777">    } else if (i == 4 &amp;&amp; strncmp(p, &quot;list&quot;, 4) == 0) {</a>
<a name="ln2778">      new_wim_flags[idx] |= WIM_LIST;</a>
<a name="ln2779">    } else if (i == 8 &amp;&amp; strncmp(p, &quot;lastused&quot;, 8) == 0) {</a>
<a name="ln2780">      new_wim_flags[idx] |= WIM_BUFLASTUSED;</a>
<a name="ln2781">    } else {</a>
<a name="ln2782">      return FAIL;</a>
<a name="ln2783">    }</a>
<a name="ln2784">    p += i;</a>
<a name="ln2785">    if (*p == NUL) {</a>
<a name="ln2786">      break;</a>
<a name="ln2787">    }</a>
<a name="ln2788">    if (*p == ',') {</a>
<a name="ln2789">      if (idx == 3) {</a>
<a name="ln2790">        return FAIL;</a>
<a name="ln2791">      }</a>
<a name="ln2792">      idx++;</a>
<a name="ln2793">    }</a>
<a name="ln2794">  }</a>
<a name="ln2795"> </a>
<a name="ln2796">  // fill remaining entries with last flag</a>
<a name="ln2797">  while (idx &lt; 3) {</a>
<a name="ln2798">    new_wim_flags[idx + 1] = new_wim_flags[idx];</a>
<a name="ln2799">    idx++;</a>
<a name="ln2800">  }</a>
<a name="ln2801"> </a>
<a name="ln2802">  // only when there are no errors, wim_flags[] is changed</a>
<a name="ln2803">  for (i = 0; i &lt; 4; i++) {</a>
<a name="ln2804">    wim_flags[i] = new_wim_flags[i];</a>
<a name="ln2805">  }</a>
<a name="ln2806">  return OK;</a>
<a name="ln2807">}</a>
<a name="ln2808"> </a>
<a name="ln2809">/// Return true when the text must not be changed and we can't switch to</a>
<a name="ln2810">/// another window or buffer.  True when editing the command line etc.</a>
<a name="ln2811">bool text_locked(void)</a>
<a name="ln2812">{</a>
<a name="ln2813">  if (cmdwin_type != 0) {</a>
<a name="ln2814">    return true;</a>
<a name="ln2815">  }</a>
<a name="ln2816">  if (expr_map_locked()) {</a>
<a name="ln2817">    return true;</a>
<a name="ln2818">  }</a>
<a name="ln2819">  return textlock != 0;</a>
<a name="ln2820">}</a>
<a name="ln2821"> </a>
<a name="ln2822">// Give an error message for a command that isn't allowed while the cmdline</a>
<a name="ln2823">// window is open or editing the cmdline in another way.</a>
<a name="ln2824">void text_locked_msg(void)</a>
<a name="ln2825">{</a>
<a name="ln2826">  emsg(_(get_text_locked_msg()));</a>
<a name="ln2827">}</a>
<a name="ln2828"> </a>
<a name="ln2829">const char *get_text_locked_msg(void)</a>
<a name="ln2830">{</a>
<a name="ln2831">  if (cmdwin_type != 0) {</a>
<a name="ln2832">    return e_cmdwin;</a>
<a name="ln2833">  } else {</a>
<a name="ln2834">    return e_textlock;</a>
<a name="ln2835">  }</a>
<a name="ln2836">}</a>
<a name="ln2837"> </a>
<a name="ln2838">/// Check for text, window or buffer locked.</a>
<a name="ln2839">/// Give an error message and return true if something is locked.</a>
<a name="ln2840">bool text_or_buf_locked(void)</a>
<a name="ln2841">{</a>
<a name="ln2842">  if (text_locked()) {</a>
<a name="ln2843">    text_locked_msg();</a>
<a name="ln2844">    return true;</a>
<a name="ln2845">  }</a>
<a name="ln2846">  return curbuf_locked();</a>
<a name="ln2847">}</a>
<a name="ln2848"> </a>
<a name="ln2849">/// Check if &quot;curbuf-&gt;b_ro_locked&quot; or &quot;allbuf_lock&quot; is set and</a>
<a name="ln2850">/// return true when it is and give an error message.</a>
<a name="ln2851">bool curbuf_locked(void)</a>
<a name="ln2852">{</a>
<a name="ln2853">  if (curbuf-&gt;b_ro_locked &gt; 0) {</a>
<a name="ln2854">    emsg(_(e_cannot_edit_other_buf));</a>
<a name="ln2855">    return true;</a>
<a name="ln2856">  }</a>
<a name="ln2857">  return allbuf_locked();</a>
<a name="ln2858">}</a>
<a name="ln2859"> </a>
<a name="ln2860">// Check if &quot;allbuf_lock&quot; is set and return true when it is and give an error</a>
<a name="ln2861">// message.</a>
<a name="ln2862">bool allbuf_locked(void)</a>
<a name="ln2863">{</a>
<a name="ln2864">  if (allbuf_lock &gt; 0) {</a>
<a name="ln2865">    emsg(_(&quot;E811: Not allowed to change buffer information now&quot;));</a>
<a name="ln2866">    return true;</a>
<a name="ln2867">  }</a>
<a name="ln2868">  return false;</a>
<a name="ln2869">}</a>
<a name="ln2870"> </a>
<a name="ln2871">static int cmdline_charsize(int idx)</a>
<a name="ln2872">{</a>
<a name="ln2873">  if (cmdline_star &gt; 0) {           // showing '*', always 1 position</a>
<a name="ln2874">    return 1;</a>
<a name="ln2875">  }</a>
<a name="ln2876">  return ptr2cells(ccline.cmdbuff + idx);</a>
<a name="ln2877">}</a>
<a name="ln2878"> </a>
<a name="ln2879">/// Compute the offset of the cursor on the command line for the prompt and</a>
<a name="ln2880">/// indent.</a>
<a name="ln2881">static int cmd_startcol(void)</a>
<a name="ln2882">{</a>
<a name="ln2883">  return ccline.cmdindent + ((ccline.cmdfirstc != NUL) ? 1 : 0);</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/// Compute the column position for a byte position on the command line.</a>
<a name="ln2887">int cmd_screencol(int bytepos)</a>
<a name="ln2888">{</a>
<a name="ln2889">  int m;  // maximum column</a>
<a name="ln2890"> </a>
<a name="ln2891">  int col = cmd_startcol();</a>
<a name="ln2892">  if (KeyTyped) {</a>
<a name="ln2893">    m = Columns * Rows;</a>
<a name="ln2894">    if (m &lt; 0) {        // overflow, Columns or Rows at weird value</a>
<a name="ln2895">      m = MAXCOL;</a>
<a name="ln2896">    }</a>
<a name="ln2897">  } else {</a>
<a name="ln2898">    m = MAXCOL;</a>
<a name="ln2899">  }</a>
<a name="ln2900"> </a>
<a name="ln2901">  for (int i = 0; i &lt; ccline.cmdlen &amp;&amp; i &lt; bytepos;</a>
<a name="ln2902">       i += utfc_ptr2len(ccline.cmdbuff + i)) {</a>
<a name="ln2903">    int c = cmdline_charsize(i);</a>
<a name="ln2904">    // Count &quot;&gt;&quot; for double-wide multi-byte char that doesn't fit.</a>
<a name="ln2905">    correct_screencol(i, c, &amp;col);</a>
<a name="ln2906"> </a>
<a name="ln2907">    // If the cmdline doesn't fit, show cursor on last visible char.</a>
<a name="ln2908">    // Don't move the cursor itself, so we can still append.</a>
<a name="ln2909">    if ((col += c) &gt;= m) {</a>
<a name="ln2910">      col -= c;</a>
<a name="ln2911">      break;</a>
<a name="ln2912">    }</a>
<a name="ln2913">  }</a>
<a name="ln2914">  return col;</a>
<a name="ln2915">}</a>
<a name="ln2916"> </a>
<a name="ln2917">/// Check if the character at &quot;idx&quot;, which is &quot;cells&quot; wide, is a multi-byte</a>
<a name="ln2918">/// character that doesn't fit, so that a &quot;&gt;&quot; must be displayed.</a>
<a name="ln2919">static void correct_screencol(int idx, int cells, int *col)</a>
<a name="ln2920">{</a>
<a name="ln2921">  if (utfc_ptr2len(ccline.cmdbuff + idx) &gt; 1</a>
<a name="ln2922">      &amp;&amp; utf_ptr2cells(ccline.cmdbuff + idx) &gt; 1</a>
<a name="ln2923">      &amp;&amp; (*col) % Columns + cells &gt; Columns) {</a>
<a name="ln2924">    (*col)++;</a>
<a name="ln2925">  }</a>
<a name="ln2926">}</a>
<a name="ln2927"> </a>
<a name="ln2928">/// Get an Ex command line for the &quot;:&quot; command.</a>
<a name="ln2929">///</a>
<a name="ln2930">/// @param c  normally ':', NUL for &quot;:append&quot;</a>
<a name="ln2931">/// @param indent  indent for inside conditionals</a>
<a name="ln2932">char *getexline(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln2933">{</a>
<a name="ln2934">  // When executing a register, remove ':' that's in front of each line.</a>
<a name="ln2935">  if (exec_from_reg &amp;&amp; vpeekc() == ':') {</a>
<a name="ln2936">    (void)vgetc();</a>
<a name="ln2937">  }</a>
<a name="ln2938"> </a>
<a name="ln2939">  return getcmdline(c, 1L, indent, do_concat);</a>
<a name="ln2940">}</a>
<a name="ln2941"> </a>
<a name="ln2942">bool cmdline_overstrike(void)</a>
<a name="ln2943">  FUNC_ATTR_PURE</a>
<a name="ln2944">{</a>
<a name="ln2945">  return ccline.overstrike;</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948">/// Return true if the cursor is at the end of the cmdline.</a>
<a name="ln2949">bool cmdline_at_end(void)</a>
<a name="ln2950">  FUNC_ATTR_PURE</a>
<a name="ln2951">{</a>
<a name="ln2952">  return (ccline.cmdpos &gt;= ccline.cmdlen);</a>
<a name="ln2953">}</a>
<a name="ln2954"> </a>
<a name="ln2955">// Allocate a new command line buffer.</a>
<a name="ln2956">// Assigns the new buffer to ccline.cmdbuff and ccline.cmdbufflen.</a>
<a name="ln2957">static void alloc_cmdbuff(int len)</a>
<a name="ln2958">{</a>
<a name="ln2959">  // give some extra space to avoid having to allocate all the time</a>
<a name="ln2960">  if (len &lt; 80) {</a>
<a name="ln2961">    len = 100;</a>
<a name="ln2962">  } else {</a>
<a name="ln2963">    len += 20;</a>
<a name="ln2964">  }</a>
<a name="ln2965"> </a>
<a name="ln2966">  ccline.cmdbuff = xmalloc((size_t)len);</a>
<a name="ln2967">  ccline.cmdbufflen = len;</a>
<a name="ln2968">}</a>
<a name="ln2969"> </a>
<a name="ln2970">/// Re-allocate the command line to length len + something extra.</a>
<a name="ln2971">void realloc_cmdbuff(int len)</a>
<a name="ln2972">{</a>
<a name="ln2973">  if (len &lt; ccline.cmdbufflen) {</a>
<a name="ln2974">    return;  // no need to resize</a>
<a name="ln2975">  }</a>
<a name="ln2976"> </a>
<a name="ln2977">  char *p = ccline.cmdbuff;</a>
<a name="ln2978">  alloc_cmdbuff(len);                   // will get some more</a>
<a name="ln2979">  // There isn't always a NUL after the command, but it may need to be</a>
<a name="ln2980">  // there, thus copy up to the NUL and add a NUL.</a>
<a name="ln2981">  memmove(ccline.cmdbuff, p, (size_t)ccline.cmdlen);</a>
<a name="ln2982">  ccline.cmdbuff[ccline.cmdlen] = NUL;</a>
<a name="ln2983">  xfree(p);</a>
<a name="ln2984"> </a>
<a name="ln2985">  if (ccline.xpc != NULL</a>
<a name="ln2986">      &amp;&amp; ccline.xpc-&gt;xp_pattern != NULL</a>
<a name="ln2987">      &amp;&amp; ccline.xpc-&gt;xp_context != EXPAND_NOTHING</a>
<a name="ln2988">      &amp;&amp; ccline.xpc-&gt;xp_context != EXPAND_UNSUCCESSFUL) {</a>
<a name="ln2989">    int i = (int)(ccline.xpc-&gt;xp_pattern - p);</a>
<a name="ln2990"> </a>
<a name="ln2991">    // If xp_pattern points inside the old cmdbuff it needs to be adjusted</a>
<a name="ln2992">    // to point into the newly allocated memory.</a>
<a name="ln2993">    if (i &gt;= 0 &amp;&amp; i &lt;= ccline.cmdlen) {</a>
<a name="ln2994">      ccline.xpc-&gt;xp_pattern = ccline.cmdbuff + i;</a>
<a name="ln2995">    }</a>
<a name="ln2996">  }</a>
<a name="ln2997">}</a>
<a name="ln2998"> </a>
<a name="ln2999">static char *arshape_buf = NULL;</a>
<a name="ln3000"> </a>
<a name="ln3001">#if defined(EXITFREE)</a>
<a name="ln3002">void free_arshape_buf(void)</a>
<a name="ln3003">{</a>
<a name="ln3004">  xfree(arshape_buf);</a>
<a name="ln3005">}</a>
<a name="ln3006"> </a>
<a name="ln3007">#endif</a>
<a name="ln3008"> </a>
<a name="ln3009">enum { MAX_CB_ERRORS = 1, };</a>
<a name="ln3010"> </a>
<a name="ln3011">/// Color expression cmdline using built-in expressions parser</a>
<a name="ln3012">///</a>
<a name="ln3013">/// @param[in]  colored_ccline  Command-line to color.</a>
<a name="ln3014">/// @param[out]  ret_ccline_colors  What should be colored.</a>
<a name="ln3015">///</a>
<a name="ln3016">/// Always colors the whole cmdline.</a>
<a name="ln3017">static void color_expr_cmdline(const CmdlineInfo *const colored_ccline,</a>
<a name="ln3018">                               ColoredCmdline *const ret_ccline_colors)</a>
<a name="ln3019">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3020">{</a>
<a name="ln3021">  ParserLine parser_lines[] = {</a>
<a name="ln3022">    {</a>
<a name="ln3023">      .data = colored_ccline-&gt;cmdbuff,</a>
<a name="ln3024">      .size = strlen(colored_ccline-&gt;cmdbuff),</a>
<a name="ln3025">      .allocated = false,</a>
<a name="ln3026">    },</a>
<a name="ln3027">    { NULL, 0, false },</a>
<a name="ln3028">  };</a>
<a name="ln3029">  ParserLine *plines_p = parser_lines;</a>
<a name="ln3030">  ParserHighlight colors;</a>
<a name="ln3031">  kvi_init(colors);</a>
<a name="ln3032">  ParserState pstate;</a>
<a name="ln3033">  viml_parser_init(&amp;pstate, parser_simple_get_line, &amp;plines_p, &amp;colors);</a>
<a name="ln3034">  ExprAST east = viml_pexpr_parse(&amp;pstate, kExprFlagsDisallowEOC);</a>
<a name="ln3035">  viml_pexpr_free_ast(east);</a>
<a name="ln3036">  viml_parser_destroy(&amp;pstate);</a>
<a name="ln3037">  kv_resize(ret_ccline_colors-&gt;colors, kv_size(colors));</a>
<a name="ln3038">  size_t prev_end = 0;</a>
<a name="ln3039">  for (size_t i = 0; i &lt; kv_size(colors); i++) {</a>
<a name="ln3040">    const ParserHighlightChunk chunk = kv_A(colors, i);</a>
<a name="ln3041">    assert(chunk.start.col &lt; INT_MAX);</a>
<a name="ln3042">    assert(chunk.end_col &lt; INT_MAX);</a>
<a name="ln3043">    if (chunk.start.col != prev_end) {</a>
<a name="ln3044">      kv_push(ret_ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3045">        .start = (int)prev_end,</a>
<a name="ln3046">        .end = (int)chunk.start.col,</a>
<a name="ln3047">        .attr = 0,</a>
<a name="ln3048">      }));</a>
<a name="ln3049">    }</a>
<a name="ln3050">    const int id = syn_name2id(chunk.group);</a>
<a name="ln3051">    const int attr = (id == 0 ? 0 : syn_id2attr(id));</a>
<a name="ln3052">    kv_push(ret_ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3053">      .start = (int)chunk.start.col,</a>
<a name="ln3054">      .end = (int)chunk.end_col,</a>
<a name="ln3055">      .attr = attr,</a>
<a name="ln3056">    }));</a>
<a name="ln3057">    prev_end = chunk.end_col;</a>
<a name="ln3058">  }</a>
<a name="ln3059">  if (prev_end &lt; (size_t)colored_ccline-&gt;cmdlen) {</a>
<a name="ln3060">    kv_push(ret_ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3061">      .start = (int)prev_end,</a>
<a name="ln3062">      .end = colored_ccline-&gt;cmdlen,</a>
<a name="ln3063">      .attr = 0,</a>
<a name="ln3064">    }));</a>
<a name="ln3065">  }</a>
<a name="ln3066">  kvi_destroy(colors);</a>
<a name="ln3067">}</a>
<a name="ln3068"> </a>
<a name="ln3069">/// Color command-line</a>
<a name="ln3070">///</a>
<a name="ln3071">/// Should use built-in command parser or user-specified one. Currently only the</a>
<a name="ln3072">/// latter is supported.</a>
<a name="ln3073">///</a>
<a name="ln3074">/// @param[in,out]  colored_ccline  Command-line to color. Also holds a cache:</a>
<a name="ln3075">///                                 if -&gt;prompt_id and -&gt;cmdbuff values happen</a>
<a name="ln3076">///                                 to be equal to those from colored_cmdline it</a>
<a name="ln3077">///                                 will just do nothing, assuming that -&gt;colors</a>
<a name="ln3078">///                                 already contains needed data.</a>
<a name="ln3079">///</a>
<a name="ln3080">/// Always colors the whole cmdline.</a>
<a name="ln3081">///</a>
<a name="ln3082">/// @return true if draw_cmdline may proceed, false if it does not need anything</a>
<a name="ln3083">///         to do.</a>
<a name="ln3084">static bool color_cmdline(CmdlineInfo *colored_ccline)</a>
<a name="ln3085">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3086">{</a>
<a name="ln3087">  bool printed_errmsg = false;</a>
<a name="ln3088"> </a>
<a name="ln3089">#define PRINT_ERRMSG(...) \</a>
<a name="ln3090">  do { \</a>
<a name="ln3091">    msg_putchar('\n'); \</a>
<a name="ln3092">    msg_printf_attr(HL_ATTR(HLF_E)|MSG_HIST, __VA_ARGS__); \</a>
<a name="ln3093">    printed_errmsg = true; \</a>
<a name="ln3094">  } while (0)</a>
<a name="ln3095">  bool ret = true;</a>
<a name="ln3096"> </a>
<a name="ln3097">  ColoredCmdline *ccline_colors = &amp;colored_ccline-&gt;last_colors;</a>
<a name="ln3098"> </a>
<a name="ln3099">  // Check whether result of the previous call is still valid.</a>
<a name="ln3100">  if (ccline_colors-&gt;prompt_id == colored_ccline-&gt;prompt_id</a>
<a name="ln3101">      &amp;&amp; ccline_colors-&gt;cmdbuff != NULL</a>
<a name="ln3102">      &amp;&amp; strcmp(ccline_colors-&gt;cmdbuff, colored_ccline-&gt;cmdbuff) == 0) {</a>
<a name="ln3103">    return ret;</a>
<a name="ln3104">  }</a>
<a name="ln3105"> </a>
<a name="ln3106">  kv_size(ccline_colors-&gt;colors) = 0;</a>
<a name="ln3107"> </a>
<a name="ln3108">  if (colored_ccline-&gt;cmdbuff == NULL || *colored_ccline-&gt;cmdbuff == NUL) {</a>
<a name="ln3109">    // Nothing to do, exiting.</a>
<a name="ln3110">    XFREE_CLEAR(ccline_colors-&gt;cmdbuff);</a>
<a name="ln3111">    return ret;</a>
<a name="ln3112">  }</a>
<a name="ln3113"> </a>
<a name="ln3114">  bool arg_allocated = false;</a>
<a name="ln3115">  typval_T arg = {</a>
<a name="ln3116">    .v_type = VAR_STRING,</a>
<a name="ln3117">    .vval.v_string = colored_ccline-&gt;cmdbuff,</a>
<a name="ln3118">  };</a>
<a name="ln3119">  typval_T tv = { .v_type = VAR_UNKNOWN };</a>
<a name="ln3120"> </a>
<a name="ln3121">  static unsigned prev_prompt_id = UINT_MAX;</a>
<a name="ln3122">  static int prev_prompt_errors = 0;</a>
<a name="ln3123">  Callback color_cb = CALLBACK_NONE;</a>
<a name="ln3124">  bool can_free_cb = false;</a>
<a name="ln3125">  TryState tstate;</a>
<a name="ln3126">  Error err = ERROR_INIT;</a>
<a name="ln3127">  const char *err_errmsg = e_intern2;</a>
<a name="ln3128">  bool dgc_ret = true;</a>
<a name="ln3129">  bool tl_ret = true;</a>
<a name="ln3130"> </a>
<a name="ln3131">  if (colored_ccline-&gt;prompt_id != prev_prompt_id) {</a>
<a name="ln3132">    prev_prompt_errors = 0;</a>
<a name="ln3133">    prev_prompt_id = colored_ccline-&gt;prompt_id;</a>
<a name="ln3134">  } else if (prev_prompt_errors &gt;= MAX_CB_ERRORS) {</a>
<a name="ln3135">    goto color_cmdline_end;</a>
<a name="ln3136">  }</a>
<a name="ln3137">  if (colored_ccline-&gt;highlight_callback.type != kCallbackNone) {</a>
<a name="ln3138">    // Currently this should only happen while processing input() prompts.</a>
<a name="ln3139">    assert(colored_ccline-&gt;input_fn);</a>
<a name="ln3140">    color_cb = colored_ccline-&gt;highlight_callback;</a>
<a name="ln3141">  } else if (colored_ccline-&gt;cmdfirstc == ':') {</a>
<a name="ln3142">    try_enter(&amp;tstate);</a>
<a name="ln3143">    err_errmsg = N_(&quot;E5408: Unable to get g:Nvim_color_cmdline callback: %s&quot;);</a>
<a name="ln3144">    dgc_ret = tv_dict_get_callback(&amp;globvardict, S_LEN(&quot;Nvim_color_cmdline&quot;),</a>
<a name="ln3145">                                   &amp;color_cb);</a>
<a name="ln3146">    tl_ret = try_leave(&amp;tstate, &amp;err);</a>
<a name="ln3147">    can_free_cb = true;</a>
<a name="ln3148">  } else if (colored_ccline-&gt;cmdfirstc == '=') {</a>
<a name="ln3149">    color_expr_cmdline(colored_ccline, ccline_colors);</a>
<a name="ln3150">  }</a>
<a name="ln3151">  if (!tl_ret || !dgc_ret) {</a>
<a name="ln3152">    goto color_cmdline_error;</a>
<a name="ln3153">  }</a>
<a name="ln3154"> </a>
<a name="ln3155">  if (color_cb.type == kCallbackNone) {</a>
<a name="ln3156">    goto color_cmdline_end;</a>
<a name="ln3157">  }</a>
<a name="ln3158">  if (colored_ccline-&gt;cmdbuff[colored_ccline-&gt;cmdlen] != NUL) {</a>
<a name="ln3159">    arg_allocated = true;</a>
<a name="ln3160">    arg.vval.v_string = xmemdupz(colored_ccline-&gt;cmdbuff, (size_t)colored_ccline-&gt;cmdlen);</a>
<a name="ln3161">  }</a>
<a name="ln3162">  // msg_start() called by e.g. :echo may shift command-line to the first column</a>
<a name="ln3163">  // even though msg_silent is here. Two ways to workaround this problem without</a>
<a name="ln3164">  // altering message.c: use full_screen or save and restore msg_col.</a>
<a name="ln3165">  //</a>
<a name="ln3166">  // Saving and restoring full_screen does not work well with :redraw!. Saving</a>
<a name="ln3167">  // and restoring msg_col is neither ideal, but while with full_screen it</a>
<a name="ln3168">  // appears shifted one character to the right and cursor position is no longer</a>
<a name="ln3169">  // correct, with msg_col it just misses leading `:`. Since `redraw!` in</a>
<a name="ln3170">  // callback lags this is least of the user problems.</a>
<a name="ln3171">  //</a>
<a name="ln3172">  // Also using try_enter() because error messages may overwrite typed</a>
<a name="ln3173">  // command-line which is not expected.</a>
<a name="ln3174">  getln_interrupted_highlight = false;</a>
<a name="ln3175">  try_enter(&amp;tstate);</a>
<a name="ln3176">  err_errmsg = N_(&quot;E5407: Callback has thrown an exception: %s&quot;);</a>
<a name="ln3177">  const int saved_msg_col = msg_col;</a>
<a name="ln3178">  msg_silent++;</a>
<a name="ln3179">  const bool cbcall_ret = callback_call(&amp;color_cb, 1, &amp;arg, &amp;tv);</a>
<a name="ln3180">  msg_silent--;</a>
<a name="ln3181">  msg_col = saved_msg_col;</a>
<a name="ln3182">  if (got_int) {</a>
<a name="ln3183">    getln_interrupted_highlight = true;</a>
<a name="ln3184">  }</a>
<a name="ln3185">  if (!try_leave(&amp;tstate, &amp;err) || !cbcall_ret) {</a>
<a name="ln3186">    goto color_cmdline_error;</a>
<a name="ln3187">  }</a>
<a name="ln3188">  if (tv.v_type != VAR_LIST) {</a>
<a name="ln3189">    PRINT_ERRMSG(&quot;%s&quot;, _(&quot;E5400: Callback should return list&quot;));</a>
<a name="ln3190">    goto color_cmdline_error;</a>
<a name="ln3191">  }</a>
<a name="ln3192">  if (tv.vval.v_list == NULL) {</a>
<a name="ln3193">    goto color_cmdline_end;</a>
<a name="ln3194">  }</a>
<a name="ln3195">  varnumber_T prev_end = 0;</a>
<a name="ln3196">  int i = 0;</a>
<a name="ln3197">  TV_LIST_ITER_CONST(tv.vval.v_list, li, {</a>
<a name="ln3198">    if (TV_LIST_ITEM_TV(li)-&gt;v_type != VAR_LIST) {</a>
<a name="ln3199">      PRINT_ERRMSG(_(&quot;E5401: List item %i is not a List&quot;), i);</a>
<a name="ln3200">      goto color_cmdline_error;</a>
<a name="ln3201">    }</a>
<a name="ln3202">    const list_T *const l = TV_LIST_ITEM_TV(li)-&gt;vval.v_list;</a>
<a name="ln3203">    if (tv_list_len(l) != 3) {</a>
<a name="ln3204">      PRINT_ERRMSG(_(&quot;E5402: List item %i has incorrect length: %d /= 3&quot;),</a>
<a name="ln3205">                   i, tv_list_len(l));</a>
<a name="ln3206">      goto color_cmdline_error;</a>
<a name="ln3207">    }</a>
<a name="ln3208">    bool error = false;</a>
<a name="ln3209">    const varnumber_T start = (</a>
<a name="ln3210">                               tv_get_number_chk(TV_LIST_ITEM_TV(tv_list_first(l)), &amp;error));</a>
<a name="ln3211">    if (error) {</a>
<a name="ln3212">      goto color_cmdline_error;</a>
<a name="ln3213">    } else if (!(prev_end &lt;= start &amp;&amp; start &lt; colored_ccline-&gt;cmdlen)) {</a>
<a name="ln3214">      PRINT_ERRMSG(_(&quot;E5403: Chunk %i start %&quot; PRIdVARNUMBER &quot; not in range &quot;</a>
<a name="ln3215">                     &quot;[%&quot; PRIdVARNUMBER &quot;, %i)&quot;),</a>
<a name="ln3216">                   i, start, prev_end, colored_ccline-&gt;cmdlen);</a>
<a name="ln3217">      goto color_cmdline_error;</a>
<a name="ln3218">    } else if (utf8len_tab_zero[(uint8_t)colored_ccline-&gt;cmdbuff[start]] == 0) {</a>
<a name="ln3219">      PRINT_ERRMSG(_(&quot;E5405: Chunk %i start %&quot; PRIdVARNUMBER &quot; splits &quot;</a>
<a name="ln3220">                     &quot;multibyte character&quot;), i, start);</a>
<a name="ln3221">      goto color_cmdline_error;</a>
<a name="ln3222">    }</a>
<a name="ln3223">    if (start != prev_end) {</a>
<a name="ln3224">      kv_push(ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3225">        .start = (int)prev_end,</a>
<a name="ln3226">        .end = (int)start,</a>
<a name="ln3227">        .attr = 0,</a>
<a name="ln3228">      }));</a>
<a name="ln3229">    }</a>
<a name="ln3230">    const varnumber_T end =</a>
<a name="ln3231">      tv_get_number_chk(TV_LIST_ITEM_TV(TV_LIST_ITEM_NEXT(l, tv_list_first(l))), &amp;error);</a>
<a name="ln3232">    if (error) {</a>
<a name="ln3233">      goto color_cmdline_error;</a>
<a name="ln3234">    } else if (!(start &lt; end &amp;&amp; end &lt;= colored_ccline-&gt;cmdlen)) {</a>
<a name="ln3235">      PRINT_ERRMSG(_(&quot;E5404: Chunk %i end %&quot; PRIdVARNUMBER &quot; not in range &quot;</a>
<a name="ln3236">                     &quot;(%&quot; PRIdVARNUMBER &quot;, %i]&quot;),</a>
<a name="ln3237">                   i, end, start, colored_ccline-&gt;cmdlen);</a>
<a name="ln3238">      goto color_cmdline_error;</a>
<a name="ln3239">    } else if (end &lt; colored_ccline-&gt;cmdlen</a>
<a name="ln3240">               &amp;&amp; (utf8len_tab_zero[(uint8_t)colored_ccline-&gt;cmdbuff[end]]</a>
<a name="ln3241">                   == 0)) {</a>
<a name="ln3242">      PRINT_ERRMSG(_(&quot;E5406: Chunk %i end %&quot; PRIdVARNUMBER &quot; splits multibyte &quot;</a>
<a name="ln3243">                     &quot;character&quot;), i, end);</a>
<a name="ln3244">      goto color_cmdline_error;</a>
<a name="ln3245">    }</a>
<a name="ln3246">    prev_end = end;</a>
<a name="ln3247">    const char *const group = tv_get_string_chk(TV_LIST_ITEM_TV(tv_list_last(l)));</a>
<a name="ln3248">    if (group == NULL) {</a>
<a name="ln3249">      goto color_cmdline_error;</a>
<a name="ln3250">    }</a>
<a name="ln3251">    const int id = syn_name2id(group);</a>
<a name="ln3252">    const int attr = (id == 0 ? 0 : syn_id2attr(id));</a>
<a name="ln3253">    kv_push(ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3254">      .start = (int)start,</a>
<a name="ln3255">      .end = (int)end,</a>
<a name="ln3256">      .attr = attr,</a>
<a name="ln3257">    }));</a>
<a name="ln3258">    i++;</a>
<a name="ln3259">  });</a>
<a name="ln3260">  if (prev_end &lt; colored_ccline-&gt;cmdlen) {</a>
<a name="ln3261">    kv_push(ccline_colors-&gt;colors, ((CmdlineColorChunk) {</a>
<a name="ln3262">      .start = (int)prev_end,</a>
<a name="ln3263">      .end = colored_ccline-&gt;cmdlen,</a>
<a name="ln3264">      .attr = 0,</a>
<a name="ln3265">    }));</a>
<a name="ln3266">  }</a>
<a name="ln3267">  prev_prompt_errors = 0;</a>
<a name="ln3268">color_cmdline_end:</a>
<a name="ln3269">  assert(!ERROR_SET(&amp;err));</a>
<a name="ln3270">  if (can_free_cb) {</a>
<a name="ln3271">    callback_free(&amp;color_cb);</a>
<a name="ln3272">  }</a>
<a name="ln3273">  xfree(ccline_colors-&gt;cmdbuff);</a>
<a name="ln3274">  // Note: errors output is cached just as well as regular results.</a>
<a name="ln3275">  ccline_colors-&gt;prompt_id = colored_ccline-&gt;prompt_id;</a>
<a name="ln3276">  if (arg_allocated) {</a>
<a name="ln3277">    ccline_colors-&gt;cmdbuff = arg.vval.v_string;</a>
<a name="ln3278">  } else {</a>
<a name="ln3279">    ccline_colors-&gt;cmdbuff = xmemdupz(colored_ccline-&gt;cmdbuff, (size_t)colored_ccline-&gt;cmdlen);</a>
<a name="ln3280">  }</a>
<a name="ln3281">  tv_clear(&amp;tv);</a>
<a name="ln3282">  return ret;</a>
<a name="ln3283">color_cmdline_error:</a>
<a name="ln3284">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3285">    PRINT_ERRMSG(_(err_errmsg), err.msg);</a>
<a name="ln3286">    api_clear_error(&amp;err);</a>
<a name="ln3287">  }</a>
<a name="ln3288">  assert(printed_errmsg);</a>
<a name="ln3289">  (void)printed_errmsg;</a>
<a name="ln3290"> </a>
<a name="ln3291">  prev_prompt_errors++;</a>
<a name="ln3292">  kv_size(ccline_colors-&gt;colors) = 0;</a>
<a name="ln3293">  redrawcmdline();</a>
<a name="ln3294">  ret = false;</a>
<a name="ln3295">  goto color_cmdline_end;</a>
<a name="ln3296">#undef PRINT_ERRMSG</a>
<a name="ln3297">}</a>
<a name="ln3298"> </a>
<a name="ln3299">// Draw part of the cmdline at the current cursor position.  But draw stars</a>
<a name="ln3300">// when cmdline_star is true.</a>
<a name="ln3301">static void draw_cmdline(int start, int len)</a>
<a name="ln3302">{</a>
<a name="ln3303">  if (!color_cmdline(&amp;ccline)) {</a>
<a name="ln3304">    return;</a>
<a name="ln3305">  }</a>
<a name="ln3306"> </a>
<a name="ln3307">  if (ui_has(kUICmdline)) {</a>
<a name="ln3308">    ccline.special_char = NUL;</a>
<a name="ln3309">    ccline.redraw_state = kCmdRedrawAll;</a>
<a name="ln3310">    return;</a>
<a name="ln3311">  }</a>
<a name="ln3312"> </a>
<a name="ln3313">  if (cmdline_star &gt; 0) {</a>
<a name="ln3314">    for (int i = 0; i &lt; len; i++) {</a>
<a name="ln3315">      msg_putchar('*');</a>
<a name="ln3316">      i += utfc_ptr2len(ccline.cmdbuff + start + i) - 1;</a>
<a name="ln3317">    }</a>
<a name="ln3318">  } else if (p_arshape &amp;&amp; !p_tbidi &amp;&amp; len &gt; 0) {</a>
<a name="ln3319">    bool do_arabicshape = false;</a>
<a name="ln3320">    int mb_l;</a>
<a name="ln3321">    for (int i = start; i &lt; start + len; i += mb_l) {</a>
<a name="ln3322">      char *p = ccline.cmdbuff + i;</a>
<a name="ln3323">      int u8cc[MAX_MCO];</a>
<a name="ln3324">      int u8c = utfc_ptr2char_len(p, u8cc, start + len - i);</a>
<a name="ln3325">      mb_l = utfc_ptr2len_len(p, start + len - i);</a>
<a name="ln3326">      if (ARABIC_CHAR(u8c)) {</a>
<a name="ln3327">        do_arabicshape = true;</a>
<a name="ln3328">        break;</a>
<a name="ln3329">      }</a>
<a name="ln3330">    }</a>
<a name="ln3331">    if (!do_arabicshape) {</a>
<a name="ln3332">      goto draw_cmdline_no_arabicshape;</a>
<a name="ln3333">    }</a>
<a name="ln3334"> </a>
<a name="ln3335">    static size_t buflen = 0;</a>
<a name="ln3336">    assert(len &gt;= 0);</a>
<a name="ln3337"> </a>
<a name="ln3338">    // Do arabic shaping into a temporary buffer.  This is very</a>
<a name="ln3339">    // inefficient!</a>
<a name="ln3340">    if ((size_t)len * 2 + 2 &gt; buflen) {</a>
<a name="ln3341">      // Re-allocate the buffer.  We keep it around to avoid a lot of</a>
<a name="ln3342">      // alloc()/free() calls.</a>
<a name="ln3343">      xfree(arshape_buf);</a>
<a name="ln3344">      buflen = (size_t)len * 2 + 2;</a>
<a name="ln3345">      arshape_buf = xmalloc(buflen);</a>
<a name="ln3346">    }</a>
<a name="ln3347"> </a>
<a name="ln3348">    int newlen = 0;</a>
<a name="ln3349">    if (utf_iscomposing(utf_ptr2char(ccline.cmdbuff + start))) {</a>
<a name="ln3350">      // Prepend a space to draw the leading composing char on.</a>
<a name="ln3351">      arshape_buf[0] = ' ';</a>
<a name="ln3352">      newlen = 1;</a>
<a name="ln3353">    }</a>
<a name="ln3354"> </a>
<a name="ln3355">    int prev_c = 0;</a>
<a name="ln3356">    int prev_c1 = 0;</a>
<a name="ln3357">    for (int i = start; i &lt; start + len; i += mb_l) {</a>
<a name="ln3358">      char *p = ccline.cmdbuff + i;</a>
<a name="ln3359">      int u8cc[MAX_MCO];</a>
<a name="ln3360">      int u8c = utfc_ptr2char_len(p, u8cc, start + len - i);</a>
<a name="ln3361">      mb_l = utfc_ptr2len_len(p, start + len - i);</a>
<a name="ln3362">      if (ARABIC_CHAR(u8c)) {</a>
<a name="ln3363">        int pc;</a>
<a name="ln3364">        int pc1 = 0;</a>
<a name="ln3365">        int nc = 0;</a>
<a name="ln3366">        // Do Arabic shaping.</a>
<a name="ln3367">        if (cmdmsg_rl) {</a>
<a name="ln3368">          // Displaying from right to left.</a>
<a name="ln3369">          pc = prev_c;</a>
<a name="ln3370">          pc1 = prev_c1;</a>
<a name="ln3371">          prev_c1 = u8cc[0];</a>
<a name="ln3372">          if (i + mb_l &gt;= start + len) {</a>
<a name="ln3373">            nc = NUL;</a>
<a name="ln3374">          } else {</a>
<a name="ln3375">            nc = utf_ptr2char(p + mb_l);</a>
<a name="ln3376">          }</a>
<a name="ln3377">        } else {</a>
<a name="ln3378">          // Displaying from left to right.</a>
<a name="ln3379">          if (i + mb_l &gt;= start + len) {</a>
<a name="ln3380">            pc = NUL;</a>
<a name="ln3381">          } else {</a>
<a name="ln3382">            int pcc[MAX_MCO];</a>
<a name="ln3383"> </a>
<a name="ln3384">            pc = utfc_ptr2char_len(p + mb_l, pcc, start + len - i - mb_l);</a>
<a name="ln3385">            pc1 = pcc[0];</a>
<a name="ln3386">          }</a>
<a name="ln3387">          nc = prev_c;</a>
<a name="ln3388">        }</a>
<a name="ln3389">        prev_c = u8c;</a>
<a name="ln3390"> </a>
<a name="ln3391">        u8c = arabic_shape(u8c, NULL, &amp;u8cc[0], pc, pc1, nc);</a>
<a name="ln3392"> </a>
<a name="ln3393">        newlen += utf_char2bytes(u8c, arshape_buf + newlen);</a>
<a name="ln3394">        if (u8cc[0] != 0) {</a>
<a name="ln3395">          newlen += utf_char2bytes(u8cc[0], arshape_buf + newlen);</a>
<a name="ln3396">          if (u8cc[1] != 0) {</a>
<a name="ln3397">            newlen += utf_char2bytes(u8cc[1], arshape_buf + newlen);</a>
<a name="ln3398">          }</a>
<a name="ln3399">        }</a>
<a name="ln3400">      } else {</a>
<a name="ln3401">        prev_c = u8c;</a>
<a name="ln3402">        memmove(arshape_buf + newlen, p, (size_t)mb_l);</a>
<a name="ln3403">        newlen += mb_l;</a>
<a name="ln3404">      }</a>
<a name="ln3405">    }</a>
<a name="ln3406"> </a>
<a name="ln3407">    msg_outtrans_len(arshape_buf, newlen, 0);</a>
<a name="ln3408">  } else {</a>
<a name="ln3409">draw_cmdline_no_arabicshape:</a>
<a name="ln3410">    if (kv_size(ccline.last_colors.colors)) {</a>
<a name="ln3411">      for (size_t i = 0; i &lt; kv_size(ccline.last_colors.colors); i++) {</a>
<a name="ln3412">        CmdlineColorChunk chunk = kv_A(ccline.last_colors.colors, i);</a>
<a name="ln3413">        if (chunk.end &lt;= start) {</a>
<a name="ln3414">          continue;</a>
<a name="ln3415">        }</a>
<a name="ln3416">        const int chunk_start = MAX(chunk.start, start);</a>
<a name="ln3417">        msg_outtrans_len(ccline.cmdbuff + chunk_start, chunk.end - chunk_start, chunk.attr);</a>
<a name="ln3418">      }</a>
<a name="ln3419">    } else {</a>
<a name="ln3420">      msg_outtrans_len(ccline.cmdbuff + start, len, 0);</a>
<a name="ln3421">    }</a>
<a name="ln3422">  }</a>
<a name="ln3423">}</a>
<a name="ln3424"> </a>
<a name="ln3425">static void ui_ext_cmdline_show(CmdlineInfo *line)</a>
<a name="ln3426">{</a>
<a name="ln3427">  Arena arena = ARENA_EMPTY;</a>
<a name="ln3428">  Array content;</a>
<a name="ln3429">  if (cmdline_star) {</a>
<a name="ln3430">    content = arena_array(&amp;arena, 1);</a>
<a name="ln3431">    size_t len = 0;</a>
<a name="ln3432">    for (char *p = ccline.cmdbuff; *p; MB_PTR_ADV(p)) {</a>
<a name="ln3433">      len++;</a>
<a name="ln3434">    }</a>
<a name="ln3435">    char *buf = arena_alloc(&amp;arena, len, false);</a>
<a name="ln3436">    memset(buf, '*', len);</a>
<a name="ln3437">    Array item = arena_array(&amp;arena, 2);</a>
<a name="ln3438">    ADD_C(item, INTEGER_OBJ(0));</a>
<a name="ln3439">    ADD_C(item, STRING_OBJ(cbuf_as_string(buf, len)));</a>
<a name="ln3440">    ADD_C(content, ARRAY_OBJ(item));</a>
<a name="ln3441">  } else if (kv_size(line-&gt;last_colors.colors)) {</a>
<a name="ln3442">    content = arena_array(&amp;arena, kv_size(line-&gt;last_colors.colors));</a>
<a name="ln3443">    for (size_t i = 0; i &lt; kv_size(line-&gt;last_colors.colors); i++) {</a>
<a name="ln3444">      CmdlineColorChunk chunk = kv_A(line-&gt;last_colors.colors, i);</a>
<a name="ln3445">      Array item = arena_array(&amp;arena, 2);</a>
<a name="ln3446">      ADD_C(item, INTEGER_OBJ(chunk.attr));</a>
<a name="ln3447"> </a>
<a name="ln3448">      assert(chunk.end &gt;= chunk.start);</a>
<a name="ln3449">      ADD_C(item, STRING_OBJ(cbuf_as_string(line-&gt;cmdbuff + chunk.start,</a>
<a name="ln3450">                                            (size_t)(chunk.end - chunk.start))));</a>
<a name="ln3451">      ADD_C(content, ARRAY_OBJ(item));</a>
<a name="ln3452">    }</a>
<a name="ln3453">  } else {</a>
<a name="ln3454">    Array item = arena_array(&amp;arena, 2);</a>
<a name="ln3455">    ADD_C(item, INTEGER_OBJ(0));</a>
<a name="ln3456">    ADD_C(item, CSTR_AS_OBJ(line-&gt;cmdbuff));</a>
<a name="ln3457">    content = arena_array(&amp;arena, 1);</a>
<a name="ln3458">    ADD_C(content, ARRAY_OBJ(item));</a>
<a name="ln3459">  }</a>
<a name="ln3460">  char charbuf[2] = { (char)line-&gt;cmdfirstc, 0 };</a>
<a name="ln3461">  ui_call_cmdline_show(content, line-&gt;cmdpos,</a>
<a name="ln3462">                       cstr_as_string(charbuf),</a>
<a name="ln3463">                       cstr_as_string((line-&gt;cmdprompt)),</a>
<a name="ln3464">                       line-&gt;cmdindent,</a>
<a name="ln3465">                       line-&gt;level);</a>
<a name="ln3466">  if (line-&gt;special_char) {</a>
<a name="ln3467">    charbuf[0] = line-&gt;special_char;</a>
<a name="ln3468">    ui_call_cmdline_special_char(cstr_as_string(charbuf),</a>
<a name="ln3469">                                 line-&gt;special_shift,</a>
<a name="ln3470">                                 line-&gt;level);</a>
<a name="ln3471">  }</a>
<a name="ln3472">  arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln3473">}</a>
<a name="ln3474"> </a>
<a name="ln3475">void ui_ext_cmdline_block_append(size_t indent, const char *line)</a>
<a name="ln3476">{</a>
<a name="ln3477">  char *buf = xmallocz(indent + strlen(line));</a>
<a name="ln3478">  memset(buf, ' ', indent);</a>
<a name="ln3479">  memcpy(buf + indent, line, strlen(line));  // -V575</a>
<a name="ln3480"> </a>
<a name="ln3481">  Array item = ARRAY_DICT_INIT;</a>
<a name="ln3482">  ADD(item, INTEGER_OBJ(0));</a>
<a name="ln3483">  ADD(item, CSTR_AS_OBJ(buf));</a>
<a name="ln3484">  Array content = ARRAY_DICT_INIT;</a>
<a name="ln3485">  ADD(content, ARRAY_OBJ(item));</a>
<a name="ln3486">  ADD(cmdline_block, ARRAY_OBJ(content));</a>
<a name="ln3487">  if (cmdline_block.size &gt; 1) {</a>
<a name="ln3488">    ui_call_cmdline_block_append(content);</a>
<a name="ln3489">  } else {</a>
<a name="ln3490">    ui_call_cmdline_block_show(cmdline_block);</a>
<a name="ln3491">  }</a>
<a name="ln3492">}</a>
<a name="ln3493"> </a>
<a name="ln3494">void ui_ext_cmdline_block_leave(void)</a>
<a name="ln3495">{</a>
<a name="ln3496">  api_free_array(cmdline_block);</a>
<a name="ln3497">  cmdline_block = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3498">  ui_call_cmdline_block_hide();</a>
<a name="ln3499">}</a>
<a name="ln3500"> </a>
<a name="ln3501">/// Extra redrawing needed for redraw! and on ui_attach</a>
<a name="ln3502">/// assumes &quot;redrawcmdline()&quot; will already be invoked</a>
<a name="ln3503">void cmdline_screen_cleared(void)</a>
<a name="ln3504">{</a>
<a name="ln3505">  if (!ui_has(kUICmdline)) {</a>
<a name="ln3506">    return;</a>
<a name="ln3507">  }</a>
<a name="ln3508"> </a>
<a name="ln3509">  if (cmdline_block.size) {</a>
<a name="ln3510">    ui_call_cmdline_block_show(cmdline_block);</a>
<a name="ln3511">  }</a>
<a name="ln3512"> </a>
<a name="ln3513">  int prev_level = ccline.level - 1;</a>
<a name="ln3514">  CmdlineInfo *line = ccline.prev_ccline;</a>
<a name="ln3515">  while (prev_level &gt; 0 &amp;&amp; line) {</a>
<a name="ln3516">    if (line-&gt;level == prev_level) {</a>
<a name="ln3517">      // don't redraw a cmdline already shown in the cmdline window</a>
<a name="ln3518">      if (prev_level != cmdwin_level) {</a>
<a name="ln3519">        line-&gt;redraw_state = kCmdRedrawAll;</a>
<a name="ln3520">      }</a>
<a name="ln3521">      prev_level--;</a>
<a name="ln3522">    }</a>
<a name="ln3523">    line = line-&gt;prev_ccline;</a>
<a name="ln3524">  }</a>
<a name="ln3525">}</a>
<a name="ln3526"> </a>
<a name="ln3527">/// called by ui_flush, do what redraws necessary to keep cmdline updated.</a>
<a name="ln3528">void cmdline_ui_flush(void)</a>
<a name="ln3529">{</a>
<a name="ln3530">  if (!ui_has(kUICmdline)) {</a>
<a name="ln3531">    return;</a>
<a name="ln3532">  }</a>
<a name="ln3533">  int level = ccline.level;</a>
<a name="ln3534">  CmdlineInfo *line = &amp;ccline;</a>
<a name="ln3535">  while (level &gt; 0 &amp;&amp; line) {</a>
<a name="ln3536">    if (line-&gt;level == level) {</a>
<a name="ln3537">      if (line-&gt;redraw_state == kCmdRedrawAll) {</a>
<a name="ln3538">        ui_ext_cmdline_show(line);</a>
<a name="ln3539">      } else if (line-&gt;redraw_state == kCmdRedrawPos) {</a>
<a name="ln3540">        ui_call_cmdline_pos(line-&gt;cmdpos, line-&gt;level);</a>
<a name="ln3541">      }</a>
<a name="ln3542">      line-&gt;redraw_state = kCmdRedrawNone;</a>
<a name="ln3543">      level--;</a>
<a name="ln3544">    }</a>
<a name="ln3545">    line = line-&gt;prev_ccline;</a>
<a name="ln3546">  }</a>
<a name="ln3547">}</a>
<a name="ln3548"> </a>
<a name="ln3549">// Put a character on the command line.  Shifts the following text to the</a>
<a name="ln3550">// right when &quot;shift&quot; is true.  Used for CTRL-V, CTRL-K, etc.</a>
<a name="ln3551">// &quot;c&quot; must be printable (fit in one display cell)!</a>
<a name="ln3552">void putcmdline(char c, int shift)</a>
<a name="ln3553">{</a>
<a name="ln3554">  if (cmd_silent) {</a>
<a name="ln3555">    return;</a>
<a name="ln3556">  }</a>
<a name="ln3557">  if (!ui_has(kUICmdline)) {</a>
<a name="ln3558">    msg_no_more = true;</a>
<a name="ln3559">    msg_putchar(c);</a>
<a name="ln3560">    if (shift) {</a>
<a name="ln3561">      draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);</a>
<a name="ln3562">    }</a>
<a name="ln3563">    msg_no_more = false;</a>
<a name="ln3564">  } else if (ccline.redraw_state != kCmdRedrawAll) {</a>
<a name="ln3565">    char charbuf[2] = { c, 0 };</a>
<a name="ln3566">    ui_call_cmdline_special_char(cstr_as_string(charbuf), shift,</a>
<a name="ln3567">                                 ccline.level);</a>
<a name="ln3568">  }</a>
<a name="ln3569">  cursorcmd();</a>
<a name="ln3570">  ccline.special_char = c;</a>
<a name="ln3571">  ccline.special_shift = shift;</a>
<a name="ln3572">  ui_cursor_shape();</a>
<a name="ln3573">}</a>
<a name="ln3574"> </a>
<a name="ln3575">/// Undo a putcmdline(c, false).</a>
<a name="ln3576">void unputcmdline(void)</a>
<a name="ln3577">{</a>
<a name="ln3578">  if (cmd_silent) {</a>
<a name="ln3579">    return;</a>
<a name="ln3580">  }</a>
<a name="ln3581">  msg_no_more = true;</a>
<a name="ln3582">  if (ccline.cmdlen == ccline.cmdpos &amp;&amp; !ui_has(kUICmdline)) {</a>
<a name="ln3583">    msg_putchar(' ');</a>
<a name="ln3584">  } else {</a>
<a name="ln3585">    draw_cmdline(ccline.cmdpos, utfc_ptr2len(ccline.cmdbuff + ccline.cmdpos));</a>
<a name="ln3586">  }</a>
<a name="ln3587">  msg_no_more = false;</a>
<a name="ln3588">  cursorcmd();</a>
<a name="ln3589">  ccline.special_char = NUL;</a>
<a name="ln3590">  ui_cursor_shape();</a>
<a name="ln3591">}</a>
<a name="ln3592"> </a>
<a name="ln3593">// Put the given string, of the given length, onto the command line.</a>
<a name="ln3594">// If len is -1, then strlen() is used to calculate the length.</a>
<a name="ln3595">// If 'redraw' is true then the new part of the command line, and the remaining</a>
<a name="ln3596">// part will be redrawn, otherwise it will not.  If this function is called</a>
<a name="ln3597">// twice in a row, then 'redraw' should be false and redrawcmd() should be</a>
<a name="ln3598">// called afterwards.</a>
<a name="ln3599">void put_on_cmdline(const char *str, int len, int redraw)</a>
<a name="ln3600">{</a>
<a name="ln3601">  int i;</a>
<a name="ln3602">  int m;</a>
<a name="ln3603">  int c;</a>
<a name="ln3604"> </a>
<a name="ln3605">  if (len &lt; 0) {</a>
<a name="ln3606">    len = (int)strlen(str);</a>
<a name="ln3607">  }</a>
<a name="ln3608"> </a>
<a name="ln3609">  realloc_cmdbuff(ccline.cmdlen + len + 1);</a>
<a name="ln3610"> </a>
<a name="ln3611">  if (!ccline.overstrike) {</a>
<a name="ln3612">    memmove(ccline.cmdbuff + ccline.cmdpos + len,</a>
<a name="ln3613">            ccline.cmdbuff + ccline.cmdpos,</a>
<a name="ln3614">            (size_t)(ccline.cmdlen - ccline.cmdpos));</a>
<a name="ln3615">    ccline.cmdlen += len;</a>
<a name="ln3616">  } else {</a>
<a name="ln3617">    // Count nr of characters in the new string.</a>
<a name="ln3618">    m = 0;</a>
<a name="ln3619">    for (i = 0; i &lt; len; i += utfc_ptr2len(str + i)) {</a>
<a name="ln3620">      m++;</a>
<a name="ln3621">    }</a>
<a name="ln3622">    // Count nr of bytes in cmdline that are overwritten by these</a>
<a name="ln3623">    // characters.</a>
<a name="ln3624">    for (i = ccline.cmdpos; i &lt; ccline.cmdlen &amp;&amp; m &gt; 0;</a>
<a name="ln3625">         i += utfc_ptr2len(ccline.cmdbuff + i)) {</a>
<a name="ln3626">      m--;</a>
<a name="ln3627">    }</a>
<a name="ln3628">    if (i &lt; ccline.cmdlen) {</a>
<a name="ln3629">      memmove(ccline.cmdbuff + ccline.cmdpos + len,</a>
<a name="ln3630">              ccline.cmdbuff + i, (size_t)(ccline.cmdlen - i));</a>
<a name="ln3631">      ccline.cmdlen += ccline.cmdpos + len - i;</a>
<a name="ln3632">    } else {</a>
<a name="ln3633">      ccline.cmdlen = ccline.cmdpos + len;</a>
<a name="ln3634">    }</a>
<a name="ln3635">  }</a>
<a name="ln3636">  memmove(ccline.cmdbuff + ccline.cmdpos, str, (size_t)len);</a>
<a name="ln3637">  ccline.cmdbuff[ccline.cmdlen] = NUL;</a>
<a name="ln3638"> </a>
<a name="ln3639">  {</a>
<a name="ln3640">    // When the inserted text starts with a composing character,</a>
<a name="ln3641">    // backup to the character before it.  There could be two of them.</a>
<a name="ln3642">    i = 0;</a>
<a name="ln3643">    c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln3644">    while (ccline.cmdpos &gt; 0 &amp;&amp; utf_iscomposing(c)) {</a>
<a name="ln3645">      i = utf_head_off(ccline.cmdbuff, ccline.cmdbuff + ccline.cmdpos - 1) + 1;</a>
<a name="ln3646">      ccline.cmdpos -= i;</a>
<a name="ln3647">      len += i;</a>
<a name="ln3648">      c = utf_ptr2char(ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln3649">    }</a>
<a name="ln3650">    if (i == 0 &amp;&amp; ccline.cmdpos &gt; 0 &amp;&amp; arabic_maycombine(c)) {</a>
<a name="ln3651">      // Check the previous character for Arabic combining pair.</a>
<a name="ln3652">      i = utf_head_off(ccline.cmdbuff, ccline.cmdbuff + ccline.cmdpos - 1) + 1;</a>
<a name="ln3653">      if (arabic_combine(utf_ptr2char(ccline.cmdbuff + ccline.cmdpos - i), c)) {</a>
<a name="ln3654">        ccline.cmdpos -= i;</a>
<a name="ln3655">        len += i;</a>
<a name="ln3656">      } else {</a>
<a name="ln3657">        i = 0;</a>
<a name="ln3658">      }</a>
<a name="ln3659">    }</a>
<a name="ln3660">    if (i != 0) {</a>
<a name="ln3661">      // Also backup the cursor position.</a>
<a name="ln3662">      i = ptr2cells(ccline.cmdbuff + ccline.cmdpos);</a>
<a name="ln3663">      ccline.cmdspos -= i;</a>
<a name="ln3664">      msg_col -= i;</a>
<a name="ln3665">      if (msg_col &lt; 0) {</a>
<a name="ln3666">        msg_col += Columns;</a>
<a name="ln3667">        msg_row--;</a>
<a name="ln3668">      }</a>
<a name="ln3669">    }</a>
<a name="ln3670">  }</a>
<a name="ln3671"> </a>
<a name="ln3672">  if (redraw &amp;&amp; !cmd_silent) {</a>
<a name="ln3673">    msg_no_more = true;</a>
<a name="ln3674">    i = cmdline_row;</a>
<a name="ln3675">    cursorcmd();</a>
<a name="ln3676">    draw_cmdline(ccline.cmdpos, ccline.cmdlen - ccline.cmdpos);</a>
<a name="ln3677">    // Avoid clearing the rest of the line too often.</a>
<a name="ln3678">    if (cmdline_row != i || ccline.overstrike) {</a>
<a name="ln3679">      msg_clr_eos();</a>
<a name="ln3680">    }</a>
<a name="ln3681">    msg_no_more = false;</a>
<a name="ln3682">  }</a>
<a name="ln3683">  if (KeyTyped) {</a>
<a name="ln3684">    m = Columns * Rows;</a>
<a name="ln3685">    if (m &lt; 0) {            // overflow, Columns or Rows at weird value</a>
<a name="ln3686">      m = MAXCOL;</a>
<a name="ln3687">    }</a>
<a name="ln3688">  } else {</a>
<a name="ln3689">    m = MAXCOL;</a>
<a name="ln3690">  }</a>
<a name="ln3691">  for (i = 0; i &lt; len; i++) {</a>
<a name="ln3692">    c = cmdline_charsize(ccline.cmdpos);</a>
<a name="ln3693">    // count &quot;&gt;&quot; for a double-wide char that doesn't fit.</a>
<a name="ln3694">    correct_screencol(ccline.cmdpos, c, &amp;ccline.cmdspos);</a>
<a name="ln3695">    // Stop cursor at the end of the screen, but do increment the</a>
<a name="ln3696">    // insert position, so that entering a very long command</a>
<a name="ln3697">    // works, even though you can't see it.</a>
<a name="ln3698">    if (ccline.cmdspos + c &lt; m) {</a>
<a name="ln3699">      ccline.cmdspos += c;</a>
<a name="ln3700">    }</a>
<a name="ln3701">    c = utfc_ptr2len(ccline.cmdbuff + ccline.cmdpos) - 1;</a>
<a name="ln3702">    if (c &gt; len - i - 1) {</a>
<a name="ln3703">      c = len - i - 1;</a>
<a name="ln3704">    }</a>
<a name="ln3705">    ccline.cmdpos += c;</a>
<a name="ln3706">    i += c;</a>
<a name="ln3707">    ccline.cmdpos++;</a>
<a name="ln3708">  }</a>
<a name="ln3709"> </a>
<a name="ln3710">  if (redraw) {</a>
<a name="ln3711">    msg_check();</a>
<a name="ln3712">  }</a>
<a name="ln3713">}</a>
<a name="ln3714"> </a>
<a name="ln3715">/// Save ccline, because obtaining the &quot;=&quot; register may execute &quot;normal :cmd&quot;</a>
<a name="ln3716">/// and overwrite it.</a>
<a name="ln3717">static void save_cmdline(CmdlineInfo *ccp)</a>
<a name="ln3718">{</a>
<a name="ln3719">  *ccp = ccline;</a>
<a name="ln3720">  CLEAR_FIELD(ccline);</a>
<a name="ln3721">  ccline.prev_ccline = ccp;</a>
<a name="ln3722">  ccline.cmdbuff = NULL;  // signal that ccline is not in use</a>
<a name="ln3723">}</a>
<a name="ln3724"> </a>
<a name="ln3725">/// Restore ccline after it has been saved with save_cmdline().</a>
<a name="ln3726">static void restore_cmdline(CmdlineInfo *ccp)</a>
<a name="ln3727">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3728">{</a>
<a name="ln3729">  ccline = *ccp;</a>
<a name="ln3730">}</a>
<a name="ln3731"> </a>
<a name="ln3732">/// Paste a yank register into the command line.</a>
<a name="ln3733">/// Used by CTRL-R command in command-line mode.</a>
<a name="ln3734">/// insert_reg() can't be used here, because special characters from the</a>
<a name="ln3735">/// register contents will be interpreted as commands.</a>
<a name="ln3736">///</a>
<a name="ln3737">/// @param regname   Register name.</a>
<a name="ln3738">/// @param literally Insert text literally instead of &quot;as typed&quot;.</a>
<a name="ln3739">/// @param remcr     When true, remove trailing CR.</a>
<a name="ln3740">///</a>
<a name="ln3741">/// @returns FAIL for failure, OK otherwise</a>
<a name="ln3742">static bool cmdline_paste(int regname, bool literally, bool remcr)</a>
<a name="ln3743">{</a>
<a name="ln3744">  char *arg;</a>
<a name="ln3745">  bool allocated;</a>
<a name="ln3746"> </a>
<a name="ln3747">  // check for valid regname; also accept special characters for CTRL-R in</a>
<a name="ln3748">  // the command line</a>
<a name="ln3749">  if (regname != Ctrl_F &amp;&amp; regname != Ctrl_P &amp;&amp; regname != Ctrl_W</a>
<a name="ln3750">      &amp;&amp; regname != Ctrl_A &amp;&amp; regname != Ctrl_L</a>
<a name="ln3751">      &amp;&amp; !valid_yank_reg(regname, false)) {</a>
<a name="ln3752">    return FAIL;</a>
<a name="ln3753">  }</a>
<a name="ln3754"> </a>
<a name="ln3755">  // A register containing CTRL-R can cause an endless loop.  Allow using</a>
<a name="ln3756">  // CTRL-C to break the loop.</a>
<a name="ln3757">  line_breakcheck();</a>
<a name="ln3758">  if (got_int) {</a>
<a name="ln3759">    return FAIL;</a>
<a name="ln3760">  }</a>
<a name="ln3761"> </a>
<a name="ln3762">  // Need to  set &quot;textlock&quot; to avoid nasty things like going to another</a>
<a name="ln3763">  // buffer when evaluating an expression.</a>
<a name="ln3764">  textlock++;</a>
<a name="ln3765">  const bool i = get_spec_reg(regname, &amp;arg, &amp;allocated, true);</a>
<a name="ln3766">  textlock--;</a>
<a name="ln3767"> </a>
<a name="ln3768">  if (i) {</a>
<a name="ln3769">    // Got the value of a special register in &quot;arg&quot;.</a>
<a name="ln3770">    if (arg == NULL) {</a>
<a name="ln3771">      return FAIL;</a>
<a name="ln3772">    }</a>
<a name="ln3773"> </a>
<a name="ln3774">    // When 'incsearch' is set and CTRL-R CTRL-W used: skip the duplicate</a>
<a name="ln3775">    // part of the word.</a>
<a name="ln3776">    char *p = arg;</a>
<a name="ln3777">    if (p_is &amp;&amp; regname == Ctrl_W) {</a>
<a name="ln3778">      char *w;</a>
<a name="ln3779">      int len;</a>
<a name="ln3780"> </a>
<a name="ln3781">      // Locate start of last word in the cmd buffer.</a>
<a name="ln3782">      for (w = ccline.cmdbuff + ccline.cmdpos; w &gt; ccline.cmdbuff;) {</a>
<a name="ln3783">        len = utf_head_off(ccline.cmdbuff, w - 1) + 1;</a>
<a name="ln3784">        if (!vim_iswordc(utf_ptr2char(w - len))) {</a>
<a name="ln3785">          break;</a>
<a name="ln3786">        }</a>
<a name="ln3787">        w -= len;</a>
<a name="ln3788">      }</a>
<a name="ln3789">      len = (int)((ccline.cmdbuff + ccline.cmdpos) - w);</a>
<a name="ln3790">      if (p_ic ? STRNICMP(w, arg, len) == 0 : strncmp(w, arg, (size_t)len) == 0) {</a>
<a name="ln3791">        p += len;</a>
<a name="ln3792">      }</a>
<a name="ln3793">    }</a>
<a name="ln3794"> </a>
<a name="ln3795">    cmdline_paste_str(p, literally);</a>
<a name="ln3796">    if (allocated) {</a>
<a name="ln3797">      xfree(arg);</a>
<a name="ln3798">    }</a>
<a name="ln3799">    return OK;</a>
<a name="ln3800">  }</a>
<a name="ln3801"> </a>
<a name="ln3802">  return cmdline_paste_reg(regname, literally, remcr);</a>
<a name="ln3803">}</a>
<a name="ln3804"> </a>
<a name="ln3805">// Put a string on the command line.</a>
<a name="ln3806">// When &quot;literally&quot; is true, insert literally.</a>
<a name="ln3807">// When &quot;literally&quot; is false, insert as typed, but don't leave the command</a>
<a name="ln3808">// line.</a>
<a name="ln3809">void cmdline_paste_str(const char *s, int literally)</a>
<a name="ln3810">{</a>
<a name="ln3811">  if (literally) {</a>
<a name="ln3812">    put_on_cmdline(s, -1, true);</a>
<a name="ln3813">  } else {</a>
<a name="ln3814">    while (*s != NUL) {</a>
<a name="ln3815">      int cv = (uint8_t)(*s);</a>
<a name="ln3816">      if (cv == Ctrl_V &amp;&amp; s[1]) {</a>
<a name="ln3817">        s++;</a>
<a name="ln3818">      }</a>
<a name="ln3819">      int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln3820">      if (cv == Ctrl_V || c == ESC || c == Ctrl_C</a>
<a name="ln3821">          || c == CAR || c == NL || c == Ctrl_L</a>
<a name="ln3822">          || (c == Ctrl_BSL &amp;&amp; *s == Ctrl_N)) {</a>
<a name="ln3823">        stuffcharReadbuff(Ctrl_V);</a>
<a name="ln3824">      }</a>
<a name="ln3825">      stuffcharReadbuff(c);</a>
<a name="ln3826">    }</a>
<a name="ln3827">  }</a>
<a name="ln3828">}</a>
<a name="ln3829"> </a>
<a name="ln3830">// This function is called when the screen size changes and with incremental</a>
<a name="ln3831">// search and in other situations where the command line may have been</a>
<a name="ln3832">// overwritten.</a>
<a name="ln3833">void redrawcmdline(void)</a>
<a name="ln3834">{</a>
<a name="ln3835">  if (cmd_silent) {</a>
<a name="ln3836">    return;</a>
<a name="ln3837">  }</a>
<a name="ln3838">  need_wait_return = false;</a>
<a name="ln3839">  compute_cmdrow();</a>
<a name="ln3840">  redrawcmd();</a>
<a name="ln3841">  cursorcmd();</a>
<a name="ln3842">  ui_cursor_shape();</a>
<a name="ln3843">}</a>
<a name="ln3844"> </a>
<a name="ln3845">static void redrawcmdprompt(void)</a>
<a name="ln3846">{</a>
<a name="ln3847">  if (cmd_silent) {</a>
<a name="ln3848">    return;</a>
<a name="ln3849">  }</a>
<a name="ln3850">  if (ui_has(kUICmdline)) {</a>
<a name="ln3851">    ccline.redraw_state = kCmdRedrawAll;</a>
<a name="ln3852">    return;</a>
<a name="ln3853">  }</a>
<a name="ln3854">  if (ccline.cmdfirstc != NUL) {</a>
<a name="ln3855">    msg_putchar(ccline.cmdfirstc);</a>
<a name="ln3856">  }</a>
<a name="ln3857">  if (ccline.cmdprompt != NULL) {</a>
<a name="ln3858">    msg_puts_attr(ccline.cmdprompt, ccline.cmdattr);</a>
<a name="ln3859">    ccline.cmdindent = msg_col + (msg_row - cmdline_row) * Columns;</a>
<a name="ln3860">    // do the reverse of cmd_startcol()</a>
<a name="ln3861">    if (ccline.cmdfirstc != NUL) {</a>
<a name="ln3862">      ccline.cmdindent--;</a>
<a name="ln3863">    }</a>
<a name="ln3864">  } else {</a>
<a name="ln3865">    for (int i = ccline.cmdindent; i &gt; 0; i--) {</a>
<a name="ln3866">      msg_putchar(' ');</a>
<a name="ln3867">    }</a>
<a name="ln3868">  }</a>
<a name="ln3869">}</a>
<a name="ln3870"> </a>
<a name="ln3871">// Redraw what is currently on the command line.</a>
<a name="ln3872">void redrawcmd(void)</a>
<a name="ln3873">{</a>
<a name="ln3874">  if (cmd_silent) {</a>
<a name="ln3875">    return;</a>
<a name="ln3876">  }</a>
<a name="ln3877"> </a>
<a name="ln3878">  if (ui_has(kUICmdline)) {</a>
<a name="ln3879">    draw_cmdline(0, ccline.cmdlen);</a>
<a name="ln3880">    return;</a>
<a name="ln3881">  }</a>
<a name="ln3882"> </a>
<a name="ln3883">  // when 'incsearch' is set there may be no command line while redrawing</a>
<a name="ln3884">  if (ccline.cmdbuff == NULL) {</a>
<a name="ln3885">    cmd_cursor_goto(cmdline_row, 0);</a>
<a name="ln3886">    msg_clr_eos();</a>
<a name="ln3887">    return;</a>
<a name="ln3888">  }</a>
<a name="ln3889"> </a>
<a name="ln3890">  redrawing_cmdline = true;</a>
<a name="ln3891"> </a>
<a name="ln3892">  sb_text_restart_cmdline();</a>
<a name="ln3893">  msg_start();</a>
<a name="ln3894">  redrawcmdprompt();</a>
<a name="ln3895"> </a>
<a name="ln3896">  // Don't use more prompt, truncate the cmdline if it doesn't fit.</a>
<a name="ln3897">  msg_no_more = true;</a>
<a name="ln3898">  draw_cmdline(0, ccline.cmdlen);</a>
<a name="ln3899">  msg_clr_eos();</a>
<a name="ln3900">  msg_no_more = false;</a>
<a name="ln3901"> </a>
<a name="ln3902">  ccline.cmdspos = cmd_screencol(ccline.cmdpos);</a>
<a name="ln3903"> </a>
<a name="ln3904">  if (ccline.special_char != NUL) {</a>
<a name="ln3905">    putcmdline(ccline.special_char, ccline.special_shift);</a>
<a name="ln3906">  }</a>
<a name="ln3907"> </a>
<a name="ln3908">  // An emsg() before may have set msg_scroll. This is used in normal mode,</a>
<a name="ln3909">  // in cmdline mode we can reset them now.</a>
<a name="ln3910">  msg_scroll = false;           // next message overwrites cmdline</a>
<a name="ln3911"> </a>
<a name="ln3912">  // Typing ':' at the more prompt may set skip_redraw.  We don't want this</a>
<a name="ln3913">  // in cmdline mode.</a>
<a name="ln3914">  skip_redraw = false;</a>
<a name="ln3915"> </a>
<a name="ln3916">  redrawing_cmdline = false;</a>
<a name="ln3917">}</a>
<a name="ln3918"> </a>
<a name="ln3919">void compute_cmdrow(void)</a>
<a name="ln3920">{</a>
<a name="ln3921">  if (exmode_active || msg_scrolled != 0) {</a>
<a name="ln3922">    cmdline_row = Rows - 1;</a>
<a name="ln3923">  } else {</a>
<a name="ln3924">    win_T *wp = lastwin_nofloating();</a>
<a name="ln3925">    cmdline_row = wp-&gt;w_winrow + wp-&gt;w_height</a>
<a name="ln3926">                  + wp-&gt;w_hsep_height + wp-&gt;w_status_height + global_stl_height();</a>
<a name="ln3927">  }</a>
<a name="ln3928">  if (cmdline_row == Rows &amp;&amp; p_ch &gt; 0) {</a>
<a name="ln3929">    cmdline_row--;</a>
<a name="ln3930">  }</a>
<a name="ln3931">  lines_left = cmdline_row;</a>
<a name="ln3932">}</a>
<a name="ln3933"> </a>
<a name="ln3934">void cursorcmd(void)</a>
<a name="ln3935">{</a>
<a name="ln3936">  if (cmd_silent) {</a>
<a name="ln3937">    return;</a>
<a name="ln3938">  }</a>
<a name="ln3939"> </a>
<a name="ln3940">  if (ui_has(kUICmdline)) {</a>
<a name="ln3941">    if (ccline.redraw_state &lt; kCmdRedrawPos) {</a>
<a name="ln3942">      ccline.redraw_state = kCmdRedrawPos;</a>
<a name="ln3943">    }</a>
<a name="ln3944">    setcursor();</a>
<a name="ln3945">    return;</a>
<a name="ln3946">  }</a>
<a name="ln3947"> </a>
<a name="ln3948">  if (cmdmsg_rl) {</a>
<a name="ln3949">    msg_row = cmdline_row + (ccline.cmdspos / (Columns - 1));</a>
<a name="ln3950">    msg_col = Columns - (ccline.cmdspos % (Columns - 1)) - 1;</a>
<a name="ln3951">    if (msg_row &lt;= 0) {</a>
<a name="ln3952">      msg_row = Rows - 1;</a>
<a name="ln3953">    }</a>
<a name="ln3954">  } else {</a>
<a name="ln3955">    msg_row = cmdline_row + (ccline.cmdspos / Columns);</a>
<a name="ln3956">    msg_col = ccline.cmdspos % Columns;</a>
<a name="ln3957">    if (msg_row &gt;= Rows) {</a>
<a name="ln3958">      msg_row = Rows - 1;</a>
<a name="ln3959">    }</a>
<a name="ln3960">  }</a>
<a name="ln3961"> </a>
<a name="ln3962">  cmd_cursor_goto(msg_row, msg_col);</a>
<a name="ln3963">}</a>
<a name="ln3964"> </a>
<a name="ln3965">static void cmd_cursor_goto(int row, int col)</a>
<a name="ln3966">{</a>
<a name="ln3967">  ScreenGrid *grid = &amp;msg_grid_adj;</a>
<a name="ln3968">  grid_adjust(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln3969">  ui_grid_cursor_goto(grid-&gt;handle, row, col);</a>
<a name="ln3970">}</a>
<a name="ln3971"> </a>
<a name="ln3972">void gotocmdline(bool clr)</a>
<a name="ln3973">{</a>
<a name="ln3974">  if (ui_has(kUICmdline)) {</a>
<a name="ln3975">    return;</a>
<a name="ln3976">  }</a>
<a name="ln3977">  msg_start();</a>
<a name="ln3978">  if (cmdmsg_rl) {</a>
<a name="ln3979">    msg_col = Columns - 1;</a>
<a name="ln3980">  } else {</a>
<a name="ln3981">    msg_col = 0;  // always start in column 0</a>
<a name="ln3982">  }</a>
<a name="ln3983">  if (clr) {  // clear the bottom line(s)</a>
<a name="ln3984">    msg_clr_eos();  // will reset clear_cmdline</a>
<a name="ln3985">  }</a>
<a name="ln3986">  cmd_cursor_goto(cmdline_row, 0);</a>
<a name="ln3987">}</a>
<a name="ln3988"> </a>
<a name="ln3989">// Check the word in front of the cursor for an abbreviation.</a>
<a name="ln3990">// Called when the non-id character &quot;c&quot; has been entered.</a>
<a name="ln3991">// When an abbreviation is recognized it is removed from the text with</a>
<a name="ln3992">// backspaces and the replacement string is inserted, followed by &quot;c&quot;.</a>
<a name="ln3993">static int ccheck_abbr(int c)</a>
<a name="ln3994">{</a>
<a name="ln3995">  int spos = 0;</a>
<a name="ln3996"> </a>
<a name="ln3997">  if (p_paste || no_abbr) {         // no abbreviations or in paste mode</a>
<a name="ln3998">    return false;</a>
<a name="ln3999">  }</a>
<a name="ln4000"> </a>
<a name="ln4001">  // Do not consider '&lt;,'&gt; be part of the mapping, skip leading whitespace.</a>
<a name="ln4002">  // Actually accepts any mark.</a>
<a name="ln4003">  while (spos &lt; ccline.cmdlen &amp;&amp; ascii_iswhite(ccline.cmdbuff[spos])) {</a>
<a name="ln4004">    spos++;</a>
<a name="ln4005">  }</a>
<a name="ln4006">  if (ccline.cmdlen - spos &gt; 5</a>
<a name="ln4007">      &amp;&amp; ccline.cmdbuff[spos] == '\''</a>
<a name="ln4008">      &amp;&amp; ccline.cmdbuff[spos + 2] == ','</a>
<a name="ln4009">      &amp;&amp; ccline.cmdbuff[spos + 3] == '\'') {</a>
<a name="ln4010">    spos += 5;</a>
<a name="ln4011">  } else {</a>
<a name="ln4012">    // check abbreviation from the beginning of the commandline</a>
<a name="ln4013">    spos = 0;</a>
<a name="ln4014">  }</a>
<a name="ln4015"> </a>
<a name="ln4016">  return check_abbr(c, ccline.cmdbuff, ccline.cmdpos, spos);</a>
<a name="ln4017">}</a>
<a name="ln4018"> </a>
<a name="ln4019">/// Escape special characters in &quot;fname&quot;, depending on &quot;what&quot;:</a>
<a name="ln4020">///</a>
<a name="ln4021">/// @param[in]  fname  File name to escape.</a>
<a name="ln4022">/// @param[in]  what   What to escape for:</a>
<a name="ln4023">/// - VSE_NONE: for when used as a file name argument after a Vim command.</a>
<a name="ln4024">/// - VSE_SHELL: for a shell command.</a>
<a name="ln4025">/// - VSE_BUFFER: for the &quot;:buffer&quot; command.</a>
<a name="ln4026">///</a>
<a name="ln4027">/// @return [allocated] escaped file name.</a>
<a name="ln4028">char *vim_strsave_fnameescape(const char *const fname, const int what)</a>
<a name="ln4029">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4030">{</a>
<a name="ln4031">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln4032"># define PATH_ESC_CHARS &quot; \t\n*?[{`%#'\&quot;|!&lt;&quot;</a>
<a name="ln4033"># define BUFFER_ESC_CHARS (&quot; \t\n*?[`%#'\&quot;|!&lt;&quot;)</a>
<a name="ln4034">  char buf[sizeof(PATH_ESC_CHARS)];</a>
<a name="ln4035">  int j = 0;</a>
<a name="ln4036"> </a>
<a name="ln4037">  // Don't escape '[', '{' and '!' if they are in 'isfname' and for the</a>
<a name="ln4038">  // &quot;:buffer&quot; command.</a>
<a name="ln4039">  for (const char *p = what == VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS;</a>
<a name="ln4040">       *p != NUL; p++) {</a>
<a name="ln4041">    if ((*p != '[' &amp;&amp; *p != '{' &amp;&amp; *p != '!') || !vim_isfilec((uint8_t)(*p))) {</a>
<a name="ln4042">      buf[j++] = *p;</a>
<a name="ln4043">    }</a>
<a name="ln4044">  }</a>
<a name="ln4045">  buf[j] = NUL;</a>
<a name="ln4046">  char *p = vim_strsave_escaped(fname, buf);</a>
<a name="ln4047">#else</a>
<a name="ln4048"># define PATH_ESC_CHARS &quot; \t\n*?[{`$\\%#'\&quot;|!&lt;&quot;</a>
<a name="ln4049"># define SHELL_ESC_CHARS &quot; \t\n*?[{`$\\%#'\&quot;|!&lt;&gt;();&amp;&quot;</a>
<a name="ln4050"># define BUFFER_ESC_CHARS &quot; \t\n*?[`$\\%#'\&quot;|!&lt;&quot;</a>
<a name="ln4051">  char *p = vim_strsave_escaped(fname,</a>
<a name="ln4052">                                what == VSE_SHELL ? SHELL_ESC_CHARS : what ==</a>
<a name="ln4053">                                VSE_BUFFER ? BUFFER_ESC_CHARS : PATH_ESC_CHARS);</a>
<a name="ln4054">  if (what == VSE_SHELL &amp;&amp; csh_like_shell()) {</a>
<a name="ln4055">    // For csh and similar shells need to put two backslashes before '!'.</a>
<a name="ln4056">    // One is taken by Vim, one by the shell.</a>
<a name="ln4057">    char *s = vim_strsave_escaped(p, &quot;!&quot;);</a>
<a name="ln4058">    xfree(p);</a>
<a name="ln4059">    p = s;</a>
<a name="ln4060">  }</a>
<a name="ln4061">#endif</a>
<a name="ln4062"> </a>
<a name="ln4063">  // '&gt;' and '+' are special at the start of some commands, e.g. &quot;:edit&quot; and</a>
<a name="ln4064">  // &quot;:write&quot;.  &quot;cd -&quot; has a special meaning.</a>
<a name="ln4065">  if (*p == '&gt;' || *p == '+' || (*p == '-' &amp;&amp; p[1] == NUL)) {</a>
<a name="ln4066">    escape_fname(&amp;p);</a>
<a name="ln4067">  }</a>
<a name="ln4068"> </a>
<a name="ln4069">  return p;</a>
<a name="ln4070">}</a>
<a name="ln4071"> </a>
<a name="ln4072">/// Put a backslash before the file name in &quot;pp&quot;, which is in allocated memory.</a>
<a name="ln4073">void escape_fname(char **pp)</a>
<a name="ln4074">{</a>
<a name="ln4075">  char *p = xmalloc(strlen(*pp) + 2);</a>
<a name="ln4076">  p[0] = '\\';</a>
<a name="ln4077">  STRCPY(p + 1, *pp);</a>
<a name="ln4078">  xfree(*pp);</a>
<a name="ln4079">  *pp = p;</a>
<a name="ln4080">}</a>
<a name="ln4081"> </a>
<a name="ln4082">/// For each file name in files[num_files]:</a>
<a name="ln4083">/// If 'orig_pat' starts with &quot;~/&quot;, replace the home directory with &quot;~&quot;.</a>
<a name="ln4084">void tilde_replace(char *orig_pat, int num_files, char **files)</a>
<a name="ln4085">{</a>
<a name="ln4086">  char *p;</a>
<a name="ln4087"> </a>
<a name="ln4088">  if (orig_pat[0] == '~' &amp;&amp; vim_ispathsep(orig_pat[1])) {</a>
<a name="ln4089">    for (int i = 0; i &lt; num_files; i++) {</a>
<a name="ln4090">      p = home_replace_save(NULL, files[i]);</a>
<a name="ln4091">      xfree(files[i]);</a>
<a name="ln4092">      files[i] = p;</a>
<a name="ln4093">    }</a>
<a name="ln4094">  }</a>
<a name="ln4095">}</a>
<a name="ln4096"> </a>
<a name="ln4097">/// Get a pointer to the current command line info.</a>
<a name="ln4098">CmdlineInfo *get_cmdline_info(void)</a>
<a name="ln4099">{</a>
<a name="ln4100">  return &amp;ccline;</a>
<a name="ln4101">}</a>
<a name="ln4102"> </a>
<a name="ln4103">unsigned get_cmdline_last_prompt_id(void)</a>
<a name="ln4104">{</a>
<a name="ln4105">  return last_prompt_id;</a>
<a name="ln4106">}</a>
<a name="ln4107"> </a>
<a name="ln4108">/// Get pointer to the command line info to use. save_cmdline() may clear</a>
<a name="ln4109">/// ccline and put the previous value in ccline.prev_ccline.</a>
<a name="ln4110">static CmdlineInfo *get_ccline_ptr(void)</a>
<a name="ln4111">{</a>
<a name="ln4112">  if ((State &amp; MODE_CMDLINE) == 0) {</a>
<a name="ln4113">    return NULL;</a>
<a name="ln4114">  } else if (ccline.cmdbuff != NULL) {</a>
<a name="ln4115">    return &amp;ccline;</a>
<a name="ln4116">  } else if (ccline.prev_ccline &amp;&amp; ccline.prev_ccline-&gt;cmdbuff != NULL) {</a>
<a name="ln4117">    return ccline.prev_ccline;</a>
<a name="ln4118">  } else {</a>
<a name="ln4119">    return NULL;</a>
<a name="ln4120">  }</a>
<a name="ln4121">}</a>
<a name="ln4122"> </a>
<a name="ln4123">/// Get the current command-line type.</a>
<a name="ln4124">/// Returns ':' or '/' or '?' or '@' or '&gt;' or '-'</a>
<a name="ln4125">/// Only works when the command line is being edited.</a>
<a name="ln4126">/// Returns NUL when something is wrong.</a>
<a name="ln4127">static int get_cmdline_type(void)</a>
<a name="ln4128">{</a>
<a name="ln4129">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4130"> </a>
<a name="ln4131">  if (p == NULL) {</a>
<a name="ln4132">    return NUL;</a>
<a name="ln4133">  }</a>
<a name="ln4134">  if (p-&gt;cmdfirstc == NUL) {</a>
<a name="ln4135">    return (p-&gt;input_fn) ? '@' : '-';</a>
<a name="ln4136">  }</a>
<a name="ln4137">  return p-&gt;cmdfirstc;</a>
<a name="ln4138">}</a>
<a name="ln4139"> </a>
<a name="ln4140">/// Get the current command line in allocated memory.</a>
<a name="ln4141">/// Only works when the command line is being edited.</a>
<a name="ln4142">///</a>
<a name="ln4143">/// @return  NULL when something is wrong.</a>
<a name="ln4144">static char *get_cmdline_str(void)</a>
<a name="ln4145">{</a>
<a name="ln4146">  if (cmdline_star &gt; 0) {</a>
<a name="ln4147">    return NULL;</a>
<a name="ln4148">  }</a>
<a name="ln4149">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4150"> </a>
<a name="ln4151">  if (p == NULL) {</a>
<a name="ln4152">    return NULL;</a>
<a name="ln4153">  }</a>
<a name="ln4154">  return xstrnsave(p-&gt;cmdbuff, (size_t)p-&gt;cmdlen);</a>
<a name="ln4155">}</a>
<a name="ln4156"> </a>
<a name="ln4157">/// Get the current command-line completion type.</a>
<a name="ln4158">static char *get_cmdline_completion(void)</a>
<a name="ln4159">{</a>
<a name="ln4160">  if (cmdline_star &gt; 0) {</a>
<a name="ln4161">    return NULL;</a>
<a name="ln4162">  }</a>
<a name="ln4163">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4164"> </a>
<a name="ln4165">  if (p == NULL || p-&gt;xpc == NULL) {</a>
<a name="ln4166">    return NULL;</a>
<a name="ln4167">  }</a>
<a name="ln4168"> </a>
<a name="ln4169">  set_expand_context(p-&gt;xpc);</a>
<a name="ln4170">  if (p-&gt;xpc-&gt;xp_context == EXPAND_UNSUCCESSFUL) {</a>
<a name="ln4171">    return NULL;</a>
<a name="ln4172">  }</a>
<a name="ln4173"> </a>
<a name="ln4174">  char *cmd_compl = get_user_cmd_complete(p-&gt;xpc, p-&gt;xpc-&gt;xp_context);</a>
<a name="ln4175">  if (cmd_compl == NULL) {</a>
<a name="ln4176">    return NULL;</a>
<a name="ln4177">  }</a>
<a name="ln4178"> </a>
<a name="ln4179">  if (p-&gt;xpc-&gt;xp_context == EXPAND_USER_LIST</a>
<a name="ln4180">      || p-&gt;xpc-&gt;xp_context == EXPAND_USER_DEFINED) {</a>
<a name="ln4181">    size_t buflen = strlen(cmd_compl) + strlen(p-&gt;xpc-&gt;xp_arg) + 2;</a>
<a name="ln4182">    char *buffer = xmalloc(buflen);</a>
<a name="ln4183">    snprintf(buffer, buflen, &quot;%s,%s&quot;, cmd_compl, p-&gt;xpc-&gt;xp_arg);</a>
<a name="ln4184">    return buffer;</a>
<a name="ln4185">  }</a>
<a name="ln4186"> </a>
<a name="ln4187">  return xstrdup(cmd_compl);</a>
<a name="ln4188">}</a>
<a name="ln4189"> </a>
<a name="ln4190">/// &quot;getcmdcompltype()&quot; function</a>
<a name="ln4191">void f_getcmdcompltype(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4192">{</a>
<a name="ln4193">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4194">  rettv-&gt;vval.v_string = get_cmdline_completion();</a>
<a name="ln4195">}</a>
<a name="ln4196"> </a>
<a name="ln4197">/// &quot;getcmdline()&quot; function</a>
<a name="ln4198">void f_getcmdline(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4199">{</a>
<a name="ln4200">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4201">  rettv-&gt;vval.v_string = get_cmdline_str();</a>
<a name="ln4202">}</a>
<a name="ln4203"> </a>
<a name="ln4204">/// &quot;getcmdpos()&quot; function</a>
<a name="ln4205">void f_getcmdpos(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4206">{</a>
<a name="ln4207">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4208">  rettv-&gt;vval.v_number = p != NULL ? p-&gt;cmdpos + 1 : 0;</a>
<a name="ln4209">}</a>
<a name="ln4210"> </a>
<a name="ln4211">/// &quot;getcmdscreenpos()&quot; function</a>
<a name="ln4212">void f_getcmdscreenpos(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4213">{</a>
<a name="ln4214">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4215">  rettv-&gt;vval.v_number = p != NULL ? p-&gt;cmdspos + 1 : 0;</a>
<a name="ln4216">}</a>
<a name="ln4217"> </a>
<a name="ln4218">/// &quot;getcmdtype()&quot; function</a>
<a name="ln4219">void f_getcmdtype(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4220">{</a>
<a name="ln4221">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln4222">  rettv-&gt;vval.v_string = xmallocz(1);</a>
<a name="ln4223">  rettv-&gt;vval.v_string[0] = (char)get_cmdline_type();</a>
<a name="ln4224">}</a>
<a name="ln4225"> </a>
<a name="ln4226">/// Set the command line str to &quot;str&quot;.</a>
<a name="ln4227">/// @return  1 when failed, 0 when OK.</a>
<a name="ln4228">static int set_cmdline_str(const char *str, int pos)</a>
<a name="ln4229">{</a>
<a name="ln4230">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4231"> </a>
<a name="ln4232">  if (p == NULL) {</a>
<a name="ln4233">    return 1;</a>
<a name="ln4234">  }</a>
<a name="ln4235"> </a>
<a name="ln4236">  int len = (int)strlen(str);</a>
<a name="ln4237">  realloc_cmdbuff(len + 1);</a>
<a name="ln4238">  p-&gt;cmdlen = len;</a>
<a name="ln4239">  STRCPY(p-&gt;cmdbuff, str);</a>
<a name="ln4240"> </a>
<a name="ln4241">  p-&gt;cmdpos = pos &lt; 0 || pos &gt; p-&gt;cmdlen ? p-&gt;cmdlen : pos;</a>
<a name="ln4242">  new_cmdpos = p-&gt;cmdpos;</a>
<a name="ln4243"> </a>
<a name="ln4244">  redrawcmd();</a>
<a name="ln4245"> </a>
<a name="ln4246">  // Trigger CmdlineChanged autocommands.</a>
<a name="ln4247">  do_autocmd_cmdlinechanged(get_cmdline_type());</a>
<a name="ln4248"> </a>
<a name="ln4249">  return 0;</a>
<a name="ln4250">}</a>
<a name="ln4251"> </a>
<a name="ln4252">/// Set the command line byte position to &quot;pos&quot;.  Zero is the first position.</a>
<a name="ln4253">/// Only works when the command line is being edited.</a>
<a name="ln4254">/// @return  1 when failed, 0 when OK.</a>
<a name="ln4255">static int set_cmdline_pos(int pos)</a>
<a name="ln4256">{</a>
<a name="ln4257">  CmdlineInfo *p = get_ccline_ptr();</a>
<a name="ln4258"> </a>
<a name="ln4259">  if (p == NULL) {</a>
<a name="ln4260">    return 1;</a>
<a name="ln4261">  }</a>
<a name="ln4262"> </a>
<a name="ln4263">  // The position is not set directly but after CTRL-\ e or CTRL-R = has</a>
<a name="ln4264">  // changed the command line.</a>
<a name="ln4265">  if (pos &lt; 0) {</a>
<a name="ln4266">    new_cmdpos = 0;</a>
<a name="ln4267">  } else {</a>
<a name="ln4268">    new_cmdpos = pos;</a>
<a name="ln4269">  }</a>
<a name="ln4270">  return 0;</a>
<a name="ln4271">}</a>
<a name="ln4272"> </a>
<a name="ln4273">/// &quot;setcmdline()&quot; function</a>
<a name="ln4274">void f_setcmdline(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4275">{</a>
<a name="ln4276">  if (tv_check_for_string_arg(argvars, 0) == FAIL</a>
<a name="ln4277">      || tv_check_for_opt_number_arg(argvars, 1) == FAIL) {</a>
<a name="ln4278">    return;</a>
<a name="ln4279">  }</a>
<a name="ln4280"> </a>
<a name="ln4281">  int pos = -1;</a>
<a name="ln4282">  if (argvars[1].v_type != VAR_UNKNOWN) {</a>
<a name="ln4283">    bool error = false;</a>
<a name="ln4284"> </a>
<a name="ln4285">    pos = (int)tv_get_number_chk(&amp;argvars[1], &amp;error) - 1;</a>
<a name="ln4286">    if (error) {</a>
<a name="ln4287">      return;</a>
<a name="ln4288">    }</a>
<a name="ln4289">    if (pos &lt; 0) {</a>
<a name="ln4290">      emsg(_(e_positive));</a>
<a name="ln4291">      return;</a>
<a name="ln4292">    }</a>
<a name="ln4293">  }</a>
<a name="ln4294"> </a>
<a name="ln4295">  // Use tv_get_string() to handle a NULL string like an empty string.</a>
<a name="ln4296">  rettv-&gt;vval.v_number = set_cmdline_str(tv_get_string(&amp;argvars[0]), pos);</a>
<a name="ln4297">}</a>
<a name="ln4298"> </a>
<a name="ln4299">/// &quot;setcmdpos()&quot; function</a>
<a name="ln4300">void f_setcmdpos(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln4301">{</a>
<a name="ln4302">  const int pos = (int)tv_get_number(&amp;argvars[0]) - 1;</a>
<a name="ln4303"> </a>
<a name="ln4304">  if (pos &gt;= 0) {</a>
<a name="ln4305">    rettv-&gt;vval.v_number = set_cmdline_pos(pos);</a>
<a name="ln4306">  }</a>
<a name="ln4307">}</a>
<a name="ln4308"> </a>
<a name="ln4309">/// Return the first character of the current command line.</a>
<a name="ln4310">int get_cmdline_firstc(void)</a>
<a name="ln4311">{</a>
<a name="ln4312">  return ccline.cmdfirstc;</a>
<a name="ln4313">}</a>
<a name="ln4314"> </a>
<a name="ln4315">/// Get indices that specify a range within a list (not a range of text lines</a>
<a name="ln4316">/// in a buffer!) from a string.  Used for &quot;:history&quot; and &quot;:clist&quot;.</a>
<a name="ln4317">///</a>
<a name="ln4318">/// @param str string to parse range from</a>
<a name="ln4319">/// @param num1 from</a>
<a name="ln4320">/// @param num2 to</a>
<a name="ln4321">///</a>
<a name="ln4322">/// @return OK if parsed successfully, otherwise FAIL.</a>
<a name="ln4323">int get_list_range(char **str, int *num1, int *num2)</a>
<a name="ln4324">{</a>
<a name="ln4325">  int len;</a>
<a name="ln4326">  int first = false;</a>
<a name="ln4327">  varnumber_T num;</a>
<a name="ln4328"> </a>
<a name="ln4329">  *str = skipwhite((*str));</a>
<a name="ln4330">  if (**str == '-' || ascii_isdigit(**str)) {  // parse &quot;from&quot; part of range</a>
<a name="ln4331">    vim_str2nr(*str, NULL, &amp;len, 0, &amp;num, NULL, 0, false, NULL);</a>
<a name="ln4332">    *str += len;</a>
<a name="ln4333">    *num1 = (int)num;</a>
<a name="ln4334">    first = true;</a>
<a name="ln4335">  }</a>
<a name="ln4336">  *str = skipwhite((*str));</a>
<a name="ln4337">  if (**str == ',') {                   // parse &quot;to&quot; part of range</a>
<a name="ln4338">    *str = skipwhite((*str) + 1);</a>
<a name="ln4339">    vim_str2nr(*str, NULL, &amp;len, 0, &amp;num, NULL, 0, false, NULL);</a>
<a name="ln4340">    if (len &gt; 0) {</a>
<a name="ln4341">      *num2 = (int)num;</a>
<a name="ln4342">      *str = skipwhite((*str) + len);</a>
<a name="ln4343">    } else if (!first) {                  // no number given at all</a>
<a name="ln4344">      return FAIL;</a>
<a name="ln4345">    }</a>
<a name="ln4346">  } else if (first) {                     // only one number given</a>
<a name="ln4347">    *num2 = *num1;</a>
<a name="ln4348">  }</a>
<a name="ln4349">  return OK;</a>
<a name="ln4350">}</a>
<a name="ln4351"> </a>
<a name="ln4352">void cmdline_init(void)</a>
<a name="ln4353">{</a>
<a name="ln4354">  CLEAR_FIELD(ccline);</a>
<a name="ln4355">}</a>
<a name="ln4356"> </a>
<a name="ln4357">/// Check value of 'cedit' and set cedit_key.</a>
<a name="ln4358">/// Returns NULL if value is OK, error message otherwise.</a>
<a name="ln4359">const char *did_set_cedit(optset_T *args)</a>
<a name="ln4360">{</a>
<a name="ln4361">  if (*p_cedit == NUL) {</a>
<a name="ln4362">    cedit_key = -1;</a>
<a name="ln4363">  } else {</a>
<a name="ln4364">    int n = string_to_key(p_cedit);</a>
<a name="ln4365">    if (vim_isprintc(n)) {</a>
<a name="ln4366">      return e_invarg;</a>
<a name="ln4367">    }</a>
<a name="ln4368">    cedit_key = n;</a>
<a name="ln4369">  }</a>
<a name="ln4370">  return NULL;</a>
<a name="ln4371">}</a>
<a name="ln4372"> </a>
<a name="ln4373">/// Open a window on the current command line and history.  Allow editing in</a>
<a name="ln4374">/// the window.  Returns when the window is closed.</a>
<a name="ln4375">/// Returns:</a>
<a name="ln4376">///     CR       if the command is to be executed</a>
<a name="ln4377">///     Ctrl_C   if it is to be abandoned</a>
<a name="ln4378">///     K_IGNORE if editing continues</a>
<a name="ln4379">static int open_cmdwin(void)</a>
<a name="ln4380">{</a>
<a name="ln4381">  bufref_T old_curbuf;</a>
<a name="ln4382">  bufref_T bufref;</a>
<a name="ln4383">  win_T *old_curwin = curwin;</a>
<a name="ln4384">  int i;</a>
<a name="ln4385">  garray_T winsizes;</a>
<a name="ln4386">  char typestr[2];</a>
<a name="ln4387">  int save_restart_edit = restart_edit;</a>
<a name="ln4388">  int save_State = State;</a>
<a name="ln4389">  bool save_exmode = exmode_active;</a>
<a name="ln4390">  int save_cmdmsg_rl = cmdmsg_rl;</a>
<a name="ln4391"> </a>
<a name="ln4392">  // Can't do this when text or buffer is locked.</a>
<a name="ln4393">  // Can't do this recursively.  Can't do it when typing a password.</a>
<a name="ln4394">  if (text_or_buf_locked() || cmdwin_type != 0 || cmdline_star &gt; 0) {</a>
<a name="ln4395">    beep_flush();</a>
<a name="ln4396">    return K_IGNORE;</a>
<a name="ln4397">  }</a>
<a name="ln4398"> </a>
<a name="ln4399">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln4400"> </a>
<a name="ln4401">  // Save current window sizes.</a>
<a name="ln4402">  win_size_save(&amp;winsizes);</a>
<a name="ln4403"> </a>
<a name="ln4404">  // When using completion in Insert mode with &lt;C-R&gt;=&lt;C-F&gt; one can open the</a>
<a name="ln4405">  // command line window, but we don't want the popup menu then.</a>
<a name="ln4406">  pum_undisplay(true);</a>
<a name="ln4407"> </a>
<a name="ln4408">  // don't use a new tab page</a>
<a name="ln4409">  cmdmod.cmod_tab = 0;</a>
<a name="ln4410">  cmdmod.cmod_flags |= CMOD_NOSWAPFILE;</a>
<a name="ln4411"> </a>
<a name="ln4412">  // Create a window for the command-line buffer.</a>
<a name="ln4413">  if (win_split((int)p_cwh, WSP_BOT) == FAIL) {</a>
<a name="ln4414">    beep_flush();</a>
<a name="ln4415">    ga_clear(&amp;winsizes);</a>
<a name="ln4416">    return K_IGNORE;</a>
<a name="ln4417">  }</a>
<a name="ln4418">  // Don't let quitting the More prompt make this fail.</a>
<a name="ln4419">  got_int = false;</a>
<a name="ln4420"> </a>
<a name="ln4421">  // Set &quot;cmdwin_type&quot; before any autocommands may mess things up.</a>
<a name="ln4422">  cmdwin_type = get_cmdline_type();</a>
<a name="ln4423">  cmdwin_level = ccline.level;</a>
<a name="ln4424">  cmdwin_old_curwin = old_curwin;</a>
<a name="ln4425"> </a>
<a name="ln4426">  // Create empty command-line buffer.</a>
<a name="ln4427">  if (buf_open_scratch(0, _(&quot;[Command Line]&quot;)) == FAIL) {</a>
<a name="ln4428">    // Some autocommand messed it up?</a>
<a name="ln4429">    win_close(curwin, true, false);</a>
<a name="ln4430">    ga_clear(&amp;winsizes);</a>
<a name="ln4431">    cmdwin_type = 0;</a>
<a name="ln4432">    cmdwin_old_curwin = NULL;</a>
<a name="ln4433">    return Ctrl_C;</a>
<a name="ln4434">  }</a>
<a name="ln4435">  // Command-line buffer has bufhidden=wipe, unlike a true &quot;scratch&quot; buffer.</a>
<a name="ln4436">  set_option_value_give_err(&quot;bh&quot;, STATIC_CSTR_AS_OPTVAL(&quot;wipe&quot;), OPT_LOCAL);</a>
<a name="ln4437">  curbuf-&gt;b_p_ma = true;</a>
<a name="ln4438">  curwin-&gt;w_p_fen = false;</a>
<a name="ln4439">  curwin-&gt;w_p_rl = cmdmsg_rl;</a>
<a name="ln4440">  cmdmsg_rl = false;</a>
<a name="ln4441"> </a>
<a name="ln4442">  // Don't allow switching to another buffer.</a>
<a name="ln4443">  curbuf-&gt;b_ro_locked++;</a>
<a name="ln4444"> </a>
<a name="ln4445">  // Showing the prompt may have set need_wait_return, reset it.</a>
<a name="ln4446">  need_wait_return = false;</a>
<a name="ln4447"> </a>
<a name="ln4448">  const int histtype = hist_char2type(cmdwin_type);</a>
<a name="ln4449">  if (histtype == HIST_CMD || histtype == HIST_DEBUG) {</a>
<a name="ln4450">    if (p_wc == TAB) {</a>
<a name="ln4451">      add_map(&quot;&lt;Tab&gt;&quot;, &quot;&lt;C-X&gt;&lt;C-V&gt;&quot;, MODE_INSERT, true);</a>
<a name="ln4452">      add_map(&quot;&lt;Tab&gt;&quot;, &quot;a&lt;C-X&gt;&lt;C-V&gt;&quot;, MODE_NORMAL, true);</a>
<a name="ln4453">    }</a>
<a name="ln4454">    set_option_value_give_err(&quot;ft&quot;, STATIC_CSTR_AS_OPTVAL(&quot;vim&quot;), OPT_LOCAL);</a>
<a name="ln4455">  }</a>
<a name="ln4456">  curbuf-&gt;b_ro_locked--;</a>
<a name="ln4457"> </a>
<a name="ln4458">  // Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin</a>
<a name="ln4459">  // sets 'textwidth' to 78).</a>
<a name="ln4460">  curbuf-&gt;b_p_tw = 0;</a>
<a name="ln4461"> </a>
<a name="ln4462">  // Fill the buffer with the history.</a>
<a name="ln4463">  init_history();</a>
<a name="ln4464">  if (get_hislen() &gt; 0 &amp;&amp; histtype != HIST_INVALID) {</a>
<a name="ln4465">    i = *get_hisidx(histtype);</a>
<a name="ln4466">    if (i &gt;= 0) {</a>
<a name="ln4467">      linenr_T lnum = 0;</a>
<a name="ln4468">      do {</a>
<a name="ln4469">        if (++i == get_hislen()) {</a>
<a name="ln4470">          i = 0;</a>
<a name="ln4471">        }</a>
<a name="ln4472">        if (get_histentry(histtype)[i].hisstr != NULL) {</a>
<a name="ln4473">          ml_append(lnum++, get_histentry(histtype)[i].hisstr, (colnr_T)0, false);</a>
<a name="ln4474">        }</a>
<a name="ln4475">      } while (i != *get_hisidx(histtype));</a>
<a name="ln4476">    }</a>
<a name="ln4477">  }</a>
<a name="ln4478"> </a>
<a name="ln4479">  // Replace the empty last line with the current command-line and put the</a>
<a name="ln4480">  // cursor there.</a>
<a name="ln4481">  ml_replace(curbuf-&gt;b_ml.ml_line_count, ccline.cmdbuff, true);</a>
<a name="ln4482">  curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4483">  curwin-&gt;w_cursor.col = ccline.cmdpos;</a>
<a name="ln4484">  changed_line_abv_curs();</a>
<a name="ln4485">  invalidate_botline(curwin);</a>
<a name="ln4486">  if (ui_has(kUICmdline)) {</a>
<a name="ln4487">    ccline.redraw_state = kCmdRedrawNone;</a>
<a name="ln4488">    ui_call_cmdline_hide(ccline.level);</a>
<a name="ln4489">  }</a>
<a name="ln4490">  redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln4491"> </a>
<a name="ln4492">  // No Ex mode here!</a>
<a name="ln4493">  exmode_active = false;</a>
<a name="ln4494"> </a>
<a name="ln4495">  State = MODE_NORMAL;</a>
<a name="ln4496">  setmouse();</a>
<a name="ln4497"> </a>
<a name="ln4498">  // Reset here so it can be set by a CmdWinEnter autocommand.</a>
<a name="ln4499">  cmdwin_result = 0;</a>
<a name="ln4500"> </a>
<a name="ln4501">  // Trigger CmdwinEnter autocommands.</a>
<a name="ln4502">  typestr[0] = (char)cmdwin_type;</a>
<a name="ln4503">  typestr[1] = NUL;</a>
<a name="ln4504">  apply_autocmds(EVENT_CMDWINENTER, typestr, typestr, false, curbuf);</a>
<a name="ln4505">  if (restart_edit != 0) {  // autocmd with &quot;:startinsert&quot;</a>
<a name="ln4506">    stuffcharReadbuff(K_NOP);</a>
<a name="ln4507">  }</a>
<a name="ln4508"> </a>
<a name="ln4509">  i = RedrawingDisabled;</a>
<a name="ln4510">  RedrawingDisabled = 0;</a>
<a name="ln4511">  int save_count = save_batch_count();</a>
<a name="ln4512"> </a>
<a name="ln4513">  // Call the main loop until &lt;CR&gt; or CTRL-C is typed.</a>
<a name="ln4514">  normal_enter(true, false);</a>
<a name="ln4515"> </a>
<a name="ln4516">  RedrawingDisabled = i;</a>
<a name="ln4517">  restore_batch_count(save_count);</a>
<a name="ln4518"> </a>
<a name="ln4519">  const bool save_KeyTyped = KeyTyped;</a>
<a name="ln4520"> </a>
<a name="ln4521">  // Trigger CmdwinLeave autocommands.</a>
<a name="ln4522">  apply_autocmds(EVENT_CMDWINLEAVE, typestr, typestr, false, curbuf);</a>
<a name="ln4523"> </a>
<a name="ln4524">  // Restore KeyTyped in case it is modified by autocommands</a>
<a name="ln4525">  KeyTyped = save_KeyTyped;</a>
<a name="ln4526"> </a>
<a name="ln4527">  cmdwin_type = 0;</a>
<a name="ln4528">  cmdwin_level = 0;</a>
<a name="ln4529">  cmdwin_old_curwin = NULL;</a>
<a name="ln4530"> </a>
<a name="ln4531">  exmode_active = save_exmode;</a>
<a name="ln4532"> </a>
<a name="ln4533">  // Safety check: The old window or buffer was deleted: It's a bug when</a>
<a name="ln4534">  // this happens!</a>
<a name="ln4535">  if (!win_valid(old_curwin) || !bufref_valid(&amp;old_curbuf)) {</a>
<a name="ln4536">    cmdwin_result = Ctrl_C;</a>
<a name="ln4537">    emsg(_(&quot;E199: Active window or buffer deleted&quot;));</a>
<a name="ln4538">  } else {</a>
<a name="ln4539">    win_T *wp;</a>
<a name="ln4540">    // autocmds may abort script processing</a>
<a name="ln4541">    if (aborting() &amp;&amp; cmdwin_result != K_IGNORE) {</a>
<a name="ln4542">      cmdwin_result = Ctrl_C;</a>
<a name="ln4543">    }</a>
<a name="ln4544">    // Set the new command line from the cmdline buffer.</a>
<a name="ln4545">    xfree(ccline.cmdbuff);</a>
<a name="ln4546">    if (cmdwin_result == K_XF1 || cmdwin_result == K_XF2) {  // :qa[!] typed</a>
<a name="ln4547">      const char *p = (cmdwin_result == K_XF2) ? &quot;qa&quot; : &quot;qa!&quot;;</a>
<a name="ln4548"> </a>
<a name="ln4549">      if (histtype == HIST_CMD) {</a>
<a name="ln4550">        // Execute the command directly.</a>
<a name="ln4551">        ccline.cmdbuff = xstrdup(p);</a>
<a name="ln4552">        cmdwin_result = CAR;</a>
<a name="ln4553">      } else {</a>
<a name="ln4554">        // First need to cancel what we were doing.</a>
<a name="ln4555">        ccline.cmdbuff = NULL;</a>
<a name="ln4556">        stuffcharReadbuff(':');</a>
<a name="ln4557">        stuffReadbuff(p);</a>
<a name="ln4558">        stuffcharReadbuff(CAR);</a>
<a name="ln4559">      }</a>
<a name="ln4560">    } else if (cmdwin_result == Ctrl_C) {</a>
<a name="ln4561">      // :q or :close, don't execute any command</a>
<a name="ln4562">      // and don't modify the cmd window.</a>
<a name="ln4563">      ccline.cmdbuff = NULL;</a>
<a name="ln4564">    } else {</a>
<a name="ln4565">      ccline.cmdbuff = xstrdup(get_cursor_line_ptr());</a>
<a name="ln4566">    }</a>
<a name="ln4567">    if (ccline.cmdbuff == NULL) {</a>
<a name="ln4568">      ccline.cmdbuff = xstrdup(&quot;&quot;);</a>
<a name="ln4569">      ccline.cmdlen = 0;</a>
<a name="ln4570">      ccline.cmdbufflen = 1;</a>
<a name="ln4571">      ccline.cmdpos = 0;</a>
<a name="ln4572">      cmdwin_result = Ctrl_C;</a>
<a name="ln4573">    } else {</a>
<a name="ln4574">      ccline.cmdlen = (int)strlen(ccline.cmdbuff);</a>
<a name="ln4575">      ccline.cmdbufflen = ccline.cmdlen + 1;</a>
<a name="ln4576">      ccline.cmdpos = curwin-&gt;w_cursor.col;</a>
<a name="ln4577">      // If the cursor is on the last character, it probably should be after it.</a>
<a name="ln4578">      if (ccline.cmdpos == ccline.cmdlen - 1 || ccline.cmdpos &gt; ccline.cmdlen) {</a>
<a name="ln4579">        ccline.cmdpos = ccline.cmdlen;</a>
<a name="ln4580">      }</a>
<a name="ln4581">      if (cmdwin_result == K_IGNORE) {</a>
<a name="ln4582">        ccline.cmdspos = cmd_screencol(ccline.cmdpos);</a>
<a name="ln4583">        redrawcmd();</a>
<a name="ln4584">      }</a>
<a name="ln4585">    }</a>
<a name="ln4586"> </a>
<a name="ln4587">    // Avoid command-line window first character being concealed.</a>
<a name="ln4588">    curwin-&gt;w_p_cole = 0;</a>
<a name="ln4589">    // First go back to the original window.</a>
<a name="ln4590">    wp = curwin;</a>
<a name="ln4591">    set_bufref(&amp;bufref, curbuf);</a>
<a name="ln4592">    skip_win_fix_cursor = true;</a>
<a name="ln4593">    win_goto(old_curwin);</a>
<a name="ln4594"> </a>
<a name="ln4595">    // win_goto() may trigger an autocommand that already closes the</a>
<a name="ln4596">    // cmdline window.</a>
<a name="ln4597">    if (win_valid(wp) &amp;&amp; wp != curwin) {</a>
<a name="ln4598">      win_close(wp, true, false);</a>
<a name="ln4599">    }</a>
<a name="ln4600"> </a>
<a name="ln4601">    // win_close() may have already wiped the buffer when 'bh' is</a>
<a name="ln4602">    // set to 'wipe', autocommands may have closed other windows</a>
<a name="ln4603">    if (bufref_valid(&amp;bufref) &amp;&amp; bufref.br_buf != curbuf) {</a>
<a name="ln4604">      close_buffer(NULL, bufref.br_buf, DOBUF_WIPE, false, false);</a>
<a name="ln4605">    }</a>
<a name="ln4606"> </a>
<a name="ln4607">    // Restore window sizes.</a>
<a name="ln4608">    win_size_restore(&amp;winsizes);</a>
<a name="ln4609">    skip_win_fix_cursor = false;</a>
<a name="ln4610">  }</a>
<a name="ln4611"> </a>
<a name="ln4612">  ga_clear(&amp;winsizes);</a>
<a name="ln4613">  restart_edit = save_restart_edit;</a>
<a name="ln4614">  cmdmsg_rl = save_cmdmsg_rl;</a>
<a name="ln4615"> </a>
<a name="ln4616">  State = save_State;</a>
<a name="ln4617">  may_trigger_modechanged();</a>
<a name="ln4618">  setmouse();</a>
<a name="ln4619"> </a>
<a name="ln4620">  return cmdwin_result;</a>
<a name="ln4621">}</a>
<a name="ln4622"> </a>
<a name="ln4623">/// @return true if in the cmdwin, not editing the command line.</a>
<a name="ln4624">bool is_in_cmdwin(void)</a>
<a name="ln4625">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4626">{</a>
<a name="ln4627">  return cmdwin_type != 0 &amp;&amp; get_cmdline_type() == NUL;</a>
<a name="ln4628">}</a>
<a name="ln4629"> </a>
<a name="ln4630">/// Get script string</a>
<a name="ln4631">///</a>
<a name="ln4632">/// Used for commands which accept either `:command script` or</a>
<a name="ln4633">///</a>
<a name="ln4634">///     :command &lt;&lt; endmarker</a>
<a name="ln4635">///       script</a>
<a name="ln4636">///     endmarker</a>
<a name="ln4637">///</a>
<a name="ln4638">/// @param  eap  Command being run.</a>
<a name="ln4639">/// @param[out]  lenp  Location where length of resulting string is saved. Will</a>
<a name="ln4640">///                    be set to zero when skipping.</a>
<a name="ln4641">///</a>
<a name="ln4642">/// @return [allocated] NULL or script. Does not show any error messages.</a>
<a name="ln4643">///                     NULL is returned when skipping and on error.</a>
<a name="ln4644">char *script_get(exarg_T *const eap, size_t *const lenp)</a>
<a name="ln4645">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln4646">{</a>
<a name="ln4647">  char *cmd = eap-&gt;arg;</a>
<a name="ln4648"> </a>
<a name="ln4649">  if (cmd[0] != '&lt;' || cmd[1] != '&lt;' || eap-&gt;getline == NULL) {</a>
<a name="ln4650">    *lenp = strlen(eap-&gt;arg);</a>
<a name="ln4651">    return eap-&gt;skip ? NULL : xmemdupz(eap-&gt;arg, *lenp);</a>
<a name="ln4652">  }</a>
<a name="ln4653">  cmd += 2;</a>
<a name="ln4654"> </a>
<a name="ln4655">  garray_T ga = { .ga_data = NULL, .ga_len = 0 };</a>
<a name="ln4656"> </a>
<a name="ln4657">  list_T *const l = heredoc_get(eap, cmd, true);</a>
<a name="ln4658">  if (l == NULL) {</a>
<a name="ln4659">    return NULL;</a>
<a name="ln4660">  }</a>
<a name="ln4661"> </a>
<a name="ln4662">  if (!eap-&gt;skip) {</a>
<a name="ln4663">    ga_init(&amp;ga, 1, 0x400);</a>
<a name="ln4664">  }</a>
<a name="ln4665"> </a>
<a name="ln4666">  TV_LIST_ITER_CONST(l, li, {</a>
<a name="ln4667">    if (!eap-&gt;skip) {</a>
<a name="ln4668">      ga_concat(&amp;ga, tv_get_string(TV_LIST_ITEM_TV(li)));</a>
<a name="ln4669">      ga_append(&amp;ga, '\n');</a>
<a name="ln4670">    }</a>
<a name="ln4671">  });</a>
<a name="ln4672">  *lenp = (size_t)ga.ga_len;  // Set length without trailing NUL.</a>
<a name="ln4673">  if (!eap-&gt;skip) {</a>
<a name="ln4674">    ga_append(&amp;ga, NUL);</a>
<a name="ln4675">  }</a>
<a name="ln4676"> </a>
<a name="ln4677">  tv_list_free(l);</a>
<a name="ln4678">  return (char *)ga.ga_data;</a>
<a name="ln4679">}</a>
<a name="ln4680"> </a>
<a name="ln4681">static void set_search_match(pos_T *t)</a>
<a name="ln4682">{</a>
<a name="ln4683">  // First move cursor to end of match, then to the start.  This</a>
<a name="ln4684">  // moves the whole match onto the screen when 'nowrap' is set.</a>
<a name="ln4685">  t-&gt;lnum += search_match_lines;</a>
<a name="ln4686">  t-&gt;col = search_match_endcol;</a>
<a name="ln4687">  if (t-&gt;lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln4688">    t-&gt;lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4689">    coladvance(MAXCOL);</a>
<a name="ln4690">  }</a>
<a name="ln4691">}</a>
</code></pre>
<div class="balloon" rel="3102"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'colored_ccline-&gt;cmdbuff' pointer was utilized before it was verified against nullptr. Check lines: 3102, 3108.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>