<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;assert.h&gt;</a>
<a name="ln60">#include &lt;inttypes.h&gt;</a>
<a name="ln61">#include &lt;limits.h&gt;</a>
<a name="ln62">#include &lt;stdbool.h&gt;</a>
<a name="ln63">#include &lt;stddef.h&gt;</a>
<a name="ln64">#include &lt;stdio.h&gt;</a>
<a name="ln65">#include &lt;string.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln68">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln69">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln70">#include &quot;nvim/change.h&quot;</a>
<a name="ln71">#include &quot;nvim/charset.h&quot;</a>
<a name="ln72">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln73">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln74">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln75">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln76">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln77">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln78">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln79">#include &quot;nvim/garray.h&quot;</a>
<a name="ln80">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln81">#include &quot;nvim/globals.h&quot;</a>
<a name="ln82">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln83">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln84">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln85">#include &quot;nvim/log.h&quot;</a>
<a name="ln86">#include &quot;nvim/macros.h&quot;</a>
<a name="ln87">#include &quot;nvim/mark.h&quot;</a>
<a name="ln88">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln89">#include &quot;nvim/memline.h&quot;</a>
<a name="ln90">#include &quot;nvim/memory.h&quot;</a>
<a name="ln91">#include &quot;nvim/message.h&quot;</a>
<a name="ln92">#include &quot;nvim/option.h&quot;</a>
<a name="ln93">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln94">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln95">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln96">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln97">#include &quot;nvim/path.h&quot;</a>
<a name="ln98">#include &quot;nvim/pos.h&quot;</a>
<a name="ln99">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln100">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln101">#include &quot;nvim/search.h&quot;</a>
<a name="ln102">#include &quot;nvim/spell.h&quot;</a>
<a name="ln103">#include &quot;nvim/spell_defs.h&quot;</a>
<a name="ln104">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln105">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln106">#include &quot;nvim/strings.h&quot;</a>
<a name="ln107">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln108">#include &quot;nvim/types.h&quot;</a>
<a name="ln109">#include &quot;nvim/undo.h&quot;</a>
<a name="ln110">#include &quot;nvim/vim.h&quot;</a>
<a name="ln111">#include &quot;nvim/window.h&quot;</a>
<a name="ln112"> </a>
<a name="ln113">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln114">enum {</a>
<a name="ln115">  SP_BANNED = -1,</a>
<a name="ln116">  SP_RARE = 0,</a>
<a name="ln117">  SP_OK = 1,</a>
<a name="ln118">  SP_LOCAL = 2,</a>
<a name="ln119">  SP_BAD = 3,</a>
<a name="ln120">};</a>
<a name="ln121"> </a>
<a name="ln122">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln123">// languages.</a>
<a name="ln124">slang_T *first_lang = NULL;</a>
<a name="ln125"> </a>
<a name="ln126">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln127">char *int_wordlist = NULL;</a>
<a name="ln128"> </a>
<a name="ln129">// Structure to store info for word matching.</a>
<a name="ln130">typedef struct matchinf_S {</a>
<a name="ln131">  langp_T *mi_lp;                   // info for language and region</a>
<a name="ln132"> </a>
<a name="ln133">  // pointers to original text to be checked</a>
<a name="ln134">  char *mi_word;                   // start of word being checked</a>
<a name="ln135">  char *mi_end;                    // end of matching word so far</a>
<a name="ln136">  char *mi_fend;                   // next char to be added to mi_fword</a>
<a name="ln137">  char *mi_cend;                   // char after what was used for</a>
<a name="ln138">                                   // mi_capflags</a>
<a name="ln139"> </a>
<a name="ln140">  // case-folded text</a>
<a name="ln141">  char mi_fword[MAXWLEN + 1];           // mi_word case-folded</a>
<a name="ln142">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln143"> </a>
<a name="ln144">  // for when checking word after a prefix</a>
<a name="ln145">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln146">                                        // affixID/condition</a>
<a name="ln147">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln148">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln149">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln150">                                        // case</a>
<a name="ln151"> </a>
<a name="ln152">  // for when checking a compound word</a>
<a name="ln153">  int mi_compoff;                       // start of following word offset</a>
<a name="ln154">  uint8_t mi_compflags[MAXWLEN];        // flags for compound words used</a>
<a name="ln155">  int mi_complen;                       // nr of compound words used</a>
<a name="ln156">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln157"> </a>
<a name="ln158">  // others</a>
<a name="ln159">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln160">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln161">  win_T *mi_win;                  // buffer being checked</a>
<a name="ln162"> </a>
<a name="ln163">  // for NOBREAK</a>
<a name="ln164">  int mi_result2;                       // &quot;mi_result&quot; without following word</a>
<a name="ln165">  char *mi_end2;                        // &quot;mi_end&quot; without following word</a>
<a name="ln166">} matchinf_T;</a>
<a name="ln167"> </a>
<a name="ln168">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln169">typedef struct spelload_S {</a>
<a name="ln170">  char sl_lang[MAXWLEN + 1];            // language name</a>
<a name="ln171">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln172">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln173">} spelload_T;</a>
<a name="ln174"> </a>
<a name="ln175">#define SY_MAXLEN   30</a>
<a name="ln176">typedef struct syl_item_S {</a>
<a name="ln177">  char sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln178">  int sy_len;</a>
<a name="ln179">} syl_item_T;</a>
<a name="ln180"> </a>
<a name="ln181">spelltab_T spelltab;</a>
<a name="ln182">int did_set_spelltab;</a>
<a name="ln183"> </a>
<a name="ln184">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln185"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln186">#endif</a>
<a name="ln187"> </a>
<a name="ln188">/// mode values for find_word</a>
<a name="ln189">enum {</a>
<a name="ln190">  FIND_FOLDWORD     = 0,  ///&lt; find word case-folded</a>
<a name="ln191">  FIND_KEEPWORD     = 1,  ///&lt; find keep-case word</a>
<a name="ln192">  FIND_PREFIX       = 2,  ///&lt; find word after prefix</a>
<a name="ln193">  FIND_COMPOUND     = 3,  ///&lt; find case-folded compound word</a>
<a name="ln194">  FIND_KEEPCOMPOUND = 4,  ///&lt; find keep-case compound word</a>
<a name="ln195">};</a>
<a name="ln196"> </a>
<a name="ln197">/// type values for get_char_type</a>
<a name="ln198">enum {</a>
<a name="ln199">  CHAR_OTHER = 0,</a>
<a name="ln200">  CHAR_UPPER = 1,</a>
<a name="ln201">  CHAR_DIGIT = 2,</a>
<a name="ln202">};</a>
<a name="ln203"> </a>
<a name="ln204">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln205"> </a>
<a name="ln206">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln207">char *repl_from = NULL;</a>
<a name="ln208">char *repl_to = NULL;</a>
<a name="ln209"> </a>
<a name="ln210">/// Main spell-checking function.</a>
<a name="ln211">/// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln212">/// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln213">/// non-word or when it's OK it remains unchanged.</a>
<a name="ln214">/// This must only be called when 'spelllang' is not empty.</a>
<a name="ln215">///</a>
<a name="ln216">/// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln217">/// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln218">/// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln219">/// worry.</a>
<a name="ln220">///</a>
<a name="ln221">/// @param wp  current window</a>
<a name="ln222">/// @param capcol  column to check for Capital</a>
<a name="ln223">/// @param docount  count good words</a>
<a name="ln224">///</a>
<a name="ln225">/// @return  the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln226">/// caller can skip over the word.</a>
<a name="ln227">size_t spell_check(win_T *wp, char *ptr, hlf_T *attrp, int *capcol, bool docount)</a>
<a name="ln228">{</a>
<a name="ln229">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln230">                              // be passed to functions quickly.</a>
<a name="ln231">  size_t nrlen = 0;              // found a number first</a>
<a name="ln232">  size_t wrongcaplen = 0;</a>
<a name="ln233">  bool count_word = docount;</a>
<a name="ln234">  bool use_camel_case = (wp-&gt;w_s-&gt;b_p_spo_flags &amp; SPO_CAMEL) != 0;</a>
<a name="ln235">  bool is_camel_case = false;</a>
<a name="ln236"> </a>
<a name="ln237">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln238">  // then, skipping over the character.</a>
<a name="ln239">  if ((uint8_t)(*ptr) &lt;= ' ') {</a>
<a name="ln240">    return 1;</a>
<a name="ln241">  }</a>
<a name="ln242"> </a>
<a name="ln243">  // Return here when loading language files failed.</a>
<a name="ln244">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln245">    return 1;</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  CLEAR_FIELD(mi);</a>
<a name="ln249"> </a>
<a name="ln250">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln251">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln252">  // julifeest&quot;.</a>
<a name="ln253">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln254">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln255">      mi.mi_end = (char *)skipbin(ptr + 2);</a>
<a name="ln256">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln257">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln258">    } else {</a>
<a name="ln259">      mi.mi_end = skipdigits(ptr);</a>
<a name="ln260">    }</a>
<a name="ln261">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln262">  }</a>
<a name="ln263"> </a>
<a name="ln264">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln265">  mi.mi_word = ptr;</a>
<a name="ln266">  mi.mi_fend = ptr;</a>
<a name="ln267">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln268">    if (use_camel_case) {</a>
<a name="ln269">      mi.mi_fend = advance_camelcase_word(ptr, wp, &amp;is_camel_case);</a>
<a name="ln270">    } else {</a>
<a name="ln271">      do {</a>
<a name="ln272">        MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln273">      } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp));</a>
<a name="ln274">    }</a>
<a name="ln275"> </a>
<a name="ln276">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln277">      // Check word starting with capital letter.</a>
<a name="ln278">      int c = utf_ptr2char(ptr);</a>
<a name="ln279">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln280">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln281">      }</a>
<a name="ln282">    }</a>
<a name="ln283">  }</a>
<a name="ln284">  if (capcol != NULL) {</a>
<a name="ln285">    *capcol = -1;</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  // We always use the characters up to the next non-word character,</a>
<a name="ln289">  // also for bad words.</a>
<a name="ln290">  mi.mi_end = mi.mi_fend;</a>
<a name="ln291"> </a>
<a name="ln292">  // Check caps type later.</a>
<a name="ln293">  mi.mi_capflags = 0;</a>
<a name="ln294">  mi.mi_cend = NULL;</a>
<a name="ln295">  mi.mi_win = wp;</a>
<a name="ln296"> </a>
<a name="ln297">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln298">  // for the word end.</a>
<a name="ln299">  if (*mi.mi_fend != NUL) {</a>
<a name="ln300">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,</a>
<a name="ln304">                       MAXWLEN + 1);</a>
<a name="ln305">  mi.mi_fwordlen = (int)strlen(mi.mi_fword);</a>
<a name="ln306"> </a>
<a name="ln307">  if (is_camel_case &amp;&amp; mi.mi_fwordlen &gt; 0) {</a>
<a name="ln308">    // introduce a fake word end space into the folded word.</a>
<a name="ln309">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  // The word is bad unless we recognize it.</a>
<a name="ln313">  mi.mi_result = SP_BAD;</a>
<a name="ln314">  mi.mi_result2 = SP_BAD;</a>
<a name="ln315"> </a>
<a name="ln316">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln317">  // We check them all, because a word may be matched longer in another</a>
<a name="ln318">  // language.</a>
<a name="ln319">  for (int lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln320">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln321"> </a>
<a name="ln322">    // If reloading fails the language is still in the list but everything</a>
<a name="ln323">    // has been cleared.</a>
<a name="ln324">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln325">      continue;</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">    // Check for a matching word in case-folded words.</a>
<a name="ln329">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln330"> </a>
<a name="ln331">    // Check for a matching word in keep-case words.</a>
<a name="ln332">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln333"> </a>
<a name="ln334">    // Check for matching prefixes.</a>
<a name="ln335">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln336"> </a>
<a name="ln337">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln338">    // word as a backup.</a>
<a name="ln339">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln340">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln341">      mi.mi_result = mi.mi_result2;</a>
<a name="ln342">      mi.mi_end = mi.mi_end2;</a>
<a name="ln343">    }</a>
<a name="ln344"> </a>
<a name="ln345">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln346">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln347">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln348">                        (int)(mi.mi_end - ptr), 1);</a>
<a name="ln349">      count_word = false;</a>
<a name="ln350">    }</a>
<a name="ln351">  }</a>
<a name="ln352"> </a>
<a name="ln353">  if (mi.mi_result != SP_OK) {</a>
<a name="ln354">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln355">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln356">    if (nrlen &gt; 0) {</a>
<a name="ln357">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln358">        return nrlen;</a>
<a name="ln359">      }</a>
<a name="ln360">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln361">      // When we are at a non-word character there is no error, just</a>
<a name="ln362">      // skip over the character (try looking for a word after it).</a>
<a name="ln363">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln364">        regmatch_T regmatch;</a>
<a name="ln365"> </a>
<a name="ln366">        // Check for end of sentence.</a>
<a name="ln367">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln368">        regmatch.rm_ic = false;</a>
<a name="ln369">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln370">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln371">        if (r) {</a>
<a name="ln372">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln373">        }</a>
<a name="ln374">      }</a>
<a name="ln375"> </a>
<a name="ln376">      return (size_t)(utfc_ptr2len(ptr));</a>
<a name="ln377">    } else if (mi.mi_end == ptr) {</a>
<a name="ln378">      // Always include at least one character.  Required for when there</a>
<a name="ln379">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln380">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln381">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln382">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln383">      char *p;</a>
<a name="ln384">      int save_result = mi.mi_result;</a>
<a name="ln385"> </a>
<a name="ln386">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln387">      // at which any word would be valid.</a>
<a name="ln388">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln389">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln390">        p = mi.mi_word;</a>
<a name="ln391">        char *fp = mi.mi_fword;</a>
<a name="ln392">        while (true) {</a>
<a name="ln393">          MB_PTR_ADV(p);</a>
<a name="ln394">          MB_PTR_ADV(fp);</a>
<a name="ln395">          if (p &gt;= mi.mi_end) {</a>
<a name="ln396">            break;</a>
<a name="ln397">          }</a>
<a name="ln398">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln399">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln400">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln401">            mi.mi_end = p;</a>
<a name="ln402">            break;</a>
<a name="ln403">          }</a>
<a name="ln404">        }</a>
<a name="ln405">        mi.mi_result = save_result;</a>
<a name="ln406">      }</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln410">      *attrp = HLF_SPB;</a>
<a name="ln411">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln412">      *attrp = HLF_SPR;</a>
<a name="ln413">    } else {</a>
<a name="ln414">      *attrp = HLF_SPL;</a>
<a name="ln415">    }</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln419">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln420">    *attrp = HLF_SPC;</a>
<a name="ln421">    return wrongcaplen;</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">/// Determine the type of character &quot;c&quot;.</a>
<a name="ln428">static int get_char_type(int c)</a>
<a name="ln429">{</a>
<a name="ln430">  if (ascii_isdigit(c)) {</a>
<a name="ln431">    return CHAR_DIGIT;</a>
<a name="ln432">  }</a>
<a name="ln433">  if (SPELL_ISUPPER(c)) {</a>
<a name="ln434">    return CHAR_UPPER;</a>
<a name="ln435">  }</a>
<a name="ln436">  return CHAR_OTHER;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">/// Returns a pointer to the end of the word starting at &quot;str&quot;.</a>
<a name="ln440">/// Supports camelCase words.</a>
<a name="ln441">static char *advance_camelcase_word(char *str, win_T *wp, bool *is_camel_case)</a>
<a name="ln442">{</a>
<a name="ln443">  char *end = str;</a>
<a name="ln444"> </a>
<a name="ln445">  *is_camel_case = false;</a>
<a name="ln446"> </a>
<a name="ln447">  if (*str == NUL) {</a>
<a name="ln448">    return str;</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451">  int c = utf_ptr2char(end);</a>
<a name="ln452">  MB_PTR_ADV(end);</a>
<a name="ln453">  // We need at most the types of the type of the last two chars.</a>
<a name="ln454">  int last_last_type = -1;</a>
<a name="ln455">  int last_type = get_char_type(c);</a>
<a name="ln456"> </a>
<a name="ln457">  while (*end != NUL &amp;&amp; spell_iswordp(end, wp)) {</a>
<a name="ln458">    c = utf_ptr2char(end);</a>
<a name="ln459">    int this_type = get_char_type(c);</a>
<a name="ln460"> </a>
<a name="ln461">    if (last_last_type == CHAR_UPPER &amp;&amp; last_type == CHAR_UPPER</a>
<a name="ln462">        &amp;&amp; this_type == CHAR_OTHER) {</a>
<a name="ln463">      // Handle the following cases:</a>
<a name="ln464">      // UpperUpperLower</a>
<a name="ln465">      *is_camel_case = true;</a>
<a name="ln466">      // Back up by one char.</a>
<a name="ln467">      MB_PTR_BACK(str, end);</a>
<a name="ln468">      break;</a>
<a name="ln469">    } else if ((this_type == CHAR_UPPER &amp;&amp; last_type == CHAR_OTHER)</a>
<a name="ln470">               || (this_type != last_type</a>
<a name="ln471">                   &amp;&amp; (this_type == CHAR_DIGIT || last_type == CHAR_DIGIT))) {</a>
<a name="ln472">      // Handle the following cases:</a>
<a name="ln473">      // LowerUpper LowerDigit UpperDigit DigitUpper DigitLower</a>
<a name="ln474">      *is_camel_case = true;</a>
<a name="ln475">      break;</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    last_last_type = last_type;</a>
<a name="ln479">    last_type = this_type;</a>
<a name="ln480"> </a>
<a name="ln481">    MB_PTR_ADV(end);</a>
<a name="ln482">  }</a>
<a name="ln483"> </a>
<a name="ln484">  return end;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln488">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln489">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln490">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln491">// tree.</a>
<a name="ln492">//</a>
<a name="ln493">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln494">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln495">{</a>
<a name="ln496">  int wlen = 0;</a>
<a name="ln497">  int flen;</a>
<a name="ln498">  char *ptr;</a>
<a name="ln499">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln500">  uint8_t *byts;</a>
<a name="ln501">  idx_T *idxs;</a>
<a name="ln502"> </a>
<a name="ln503">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln504">    // Check for word with matching case in keep-case tree.</a>
<a name="ln505">    ptr = mip-&gt;mi_word;</a>
<a name="ln506">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln507">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln508">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln509"> </a>
<a name="ln510">    if (mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln511">      // Skip over the previously found word(s).</a>
<a name="ln512">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln513">    }</a>
<a name="ln514">  } else {</a>
<a name="ln515">    // Check for case-folded in case-folded tree.</a>
<a name="ln516">    ptr = mip-&gt;mi_fword;</a>
<a name="ln517">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln518">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln519">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln520"> </a>
<a name="ln521">    if (mode == FIND_PREFIX) {</a>
<a name="ln522">      // Skip over the prefix.</a>
<a name="ln523">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln524">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln525">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln526">      // Skip over the previously found word(s).</a>
<a name="ln527">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln528">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln529">    }</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  if (byts == NULL) {</a>
<a name="ln533">    return;                     // array is empty</a>
<a name="ln534">  }</a>
<a name="ln535">  idx_T arridx = 0;</a>
<a name="ln536">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln537">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln538">  int endidxcnt = 0;</a>
<a name="ln539">  int c;</a>
<a name="ln540"> </a>
<a name="ln541">  // Repeat advancing in the tree until:</a>
<a name="ln542">  // - there is a byte that doesn't match,</a>
<a name="ln543">  // - we reach the end of the tree,</a>
<a name="ln544">  // - or we reach the end of the line.</a>
<a name="ln545">  while (true) {</a>
<a name="ln546">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln547">      flen = fold_more(mip);</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">    int len = byts[arridx++];</a>
<a name="ln551"> </a>
<a name="ln552">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln553">    // Remember this index, we first check for the longest word.</a>
<a name="ln554">    if (byts[arridx] == 0) {</a>
<a name="ln555">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln556">        // Must be a corrupted spell file.</a>
<a name="ln557">        emsg(_(e_format));</a>
<a name="ln558">        return;</a>
<a name="ln559">      }</a>
<a name="ln560">      endlen[endidxcnt] = wlen;</a>
<a name="ln561">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln562">      len--;</a>
<a name="ln563"> </a>
<a name="ln564">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln565">      // combinations.</a>
<a name="ln566">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln567">        arridx++;</a>
<a name="ln568">        len--;</a>
<a name="ln569">      }</a>
<a name="ln570">      if (len == 0) {</a>
<a name="ln571">        break;              // no children, word must end here</a>
<a name="ln572">      }</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">    // Stop looking at end of the line.</a>
<a name="ln576">    if (ptr[wlen] == NUL) {</a>
<a name="ln577">      break;</a>
<a name="ln578">    }</a>
<a name="ln579"> </a>
<a name="ln580">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln581">    c = (uint8_t)ptr[wlen];</a>
<a name="ln582">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln583">      c = ' ';</a>
<a name="ln584">    }</a>
<a name="ln585">    idx_T lo = arridx;</a>
<a name="ln586">    idx_T hi = arridx + len - 1;</a>
<a name="ln587">    while (lo &lt; hi) {</a>
<a name="ln588">      idx_T m = (lo + hi) / 2;</a>
<a name="ln589">      if (byts[m] &gt; c) {</a>
<a name="ln590">        hi = m - 1;</a>
<a name="ln591">      } else if (byts[m] &lt; c) {</a>
<a name="ln592">        lo = m + 1;</a>
<a name="ln593">      } else {</a>
<a name="ln594">        lo = hi = m;</a>
<a name="ln595">        break;</a>
<a name="ln596">      }</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    // Stop if there is no matching byte.</a>
<a name="ln600">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln601">      break;</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">    // Continue at the child (if there is one).</a>
<a name="ln605">    arridx = idxs[lo];</a>
<a name="ln606">    wlen++;</a>
<a name="ln607">    flen--;</a>
<a name="ln608"> </a>
<a name="ln609">    // One space in the good word may stand for several spaces in the</a>
<a name="ln610">    // checked word.</a>
<a name="ln611">    if (c == ' ') {</a>
<a name="ln612">      while (true) {</a>
<a name="ln613">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln614">          flen = fold_more(mip);</a>
<a name="ln615">        }</a>
<a name="ln616">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB) {</a>
<a name="ln617">          break;</a>
<a name="ln618">        }</a>
<a name="ln619">        wlen++;</a>
<a name="ln620">        flen--;</a>
<a name="ln621">      }</a>
<a name="ln622">    }</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  char *p;</a>
<a name="ln626">  bool word_ends;</a>
<a name="ln627"> </a>
<a name="ln628">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln629">  // first.</a>
<a name="ln630">  while (endidxcnt &gt; 0) {</a>
<a name="ln631">    endidxcnt--;</a>
<a name="ln632">    arridx = endidx[endidxcnt];</a>
<a name="ln633">    wlen = endlen[endidxcnt];</a>
<a name="ln634"> </a>
<a name="ln635">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln636">      continue;             // not at first byte of character</a>
<a name="ln637">    }</a>
<a name="ln638">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln639">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak) {</a>
<a name="ln640">        continue;                   // next char is a word character</a>
<a name="ln641">      }</a>
<a name="ln642">      word_ends = false;</a>
<a name="ln643">    } else {</a>
<a name="ln644">      word_ends = true;</a>
<a name="ln645">    }</a>
<a name="ln646">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln647">    // has been found we try compound flags.</a>
<a name="ln648">    bool prefix_found = false;</a>
<a name="ln649"> </a>
<a name="ln650">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln651">      // Compute byte length in original word, length may change</a>
<a name="ln652">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln653">      // case-folded word is equal to the keep-case word.</a>
<a name="ln654">      p = mip-&gt;mi_word;</a>
<a name="ln655">      if (strncmp(ptr, p, (size_t)wlen) != 0) {</a>
<a name="ln656">        for (char *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln657">          MB_PTR_ADV(p);</a>
<a name="ln658">        }</a>
<a name="ln659">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln660">      }</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln664">    // prefix ID.</a>
<a name="ln665">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln666">    // is a match.</a>
<a name="ln667">    for (int len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0; len--, arridx++) {</a>
<a name="ln668">      uint32_t flags = (uint32_t)idxs[arridx];</a>
<a name="ln669"> </a>
<a name="ln670">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln671">      // matches with what the word in the tree requires.</a>
<a name="ln672">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln673">      // don't bother to check.</a>
<a name="ln674">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln675">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln676">          // mi_capflags was set for a different word length, need</a>
<a name="ln677">          // to do it again.</a>
<a name="ln678">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln679">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln680">        }</a>
<a name="ln681"> </a>
<a name="ln682">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln683">            || !spell_valid_case(mip-&gt;mi_capflags, (int)flags)) {</a>
<a name="ln684">          continue;</a>
<a name="ln685">        }</a>
<a name="ln686">      } else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln687">        // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln688">        // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln689">        // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln690">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln691">                              (int)flags,</a>
<a name="ln692">                              mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln693">                              false);</a>
<a name="ln694">        if (c == 0) {</a>
<a name="ln695">          continue;</a>
<a name="ln696">        }</a>
<a name="ln697"> </a>
<a name="ln698">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln699">        if (c &amp; WF_RAREPFX) {</a>
<a name="ln700">          flags |= WF_RARE;</a>
<a name="ln701">        }</a>
<a name="ln702">        prefix_found = true;</a>
<a name="ln703">      }</a>
<a name="ln704"> </a>
<a name="ln705">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln706">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln707">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln708">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln709">          // need to know, so return.</a>
<a name="ln710">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln711">          break;</a>
<a name="ln712">        }</a>
<a name="ln713">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln714">                  || !word_ends)) {</a>
<a name="ln715">        // If there is no compound flag or the word is shorter than</a>
<a name="ln716">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln717">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln718">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln719">        // anyway.</a>
<a name="ln720">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln721">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln722">          continue;</a>
<a name="ln723">        }</a>
<a name="ln724">        // For multi-byte chars check character length against</a>
<a name="ln725">        // COMPOUNDMIN.</a>
<a name="ln726">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln727">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln728">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln729">          continue;</a>
<a name="ln730">        }</a>
<a name="ln731"> </a>
<a name="ln732">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln733">        // maximum for syllables is specified.</a>
<a name="ln734">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln735">            &gt; slang-&gt;sl_compmax</a>
<a name="ln736">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN) {</a>
<a name="ln737">          continue;</a>
<a name="ln738">        }</a>
<a name="ln739"> </a>
<a name="ln740">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln741">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln742">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF)) {</a>
<a name="ln743">          continue;</a>
<a name="ln744">        }</a>
<a name="ln745">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT)) {</a>
<a name="ln746">          continue;</a>
<a name="ln747">        }</a>
<a name="ln748"> </a>
<a name="ln749">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln750">        if (!byte_in_str(mip-&gt;mi_complen ==</a>
<a name="ln751">                         0 ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags,</a>
<a name="ln752">                         (int)((unsigned)flags &gt;&gt; 24))) {</a>
<a name="ln753">          continue;</a>
<a name="ln754">        }</a>
<a name="ln755"> </a>
<a name="ln756">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln757">        // discard the compound word.</a>
<a name="ln758">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln759">          continue;</a>
<a name="ln760">        }</a>
<a name="ln761"> </a>
<a name="ln762">        if (mode == FIND_COMPOUND) {</a>
<a name="ln763">          int capflags;</a>
<a name="ln764"> </a>
<a name="ln765">          // Need to check the caps type of the appended compound</a>
<a name="ln766">          // word.</a>
<a name="ln767">          if (strncmp(ptr, mip-&gt;mi_word, (size_t)mip-&gt;mi_compoff) != 0) {</a>
<a name="ln768">            // case folding may have changed the length</a>
<a name="ln769">            p = mip-&gt;mi_word;</a>
<a name="ln770">            for (char *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln771">              MB_PTR_ADV(p);</a>
<a name="ln772">            }</a>
<a name="ln773">          } else {</a>
<a name="ln774">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln775">          }</a>
<a name="ln776">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln777">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln778">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln779">            continue;</a>
<a name="ln780">          }</a>
<a name="ln781"> </a>
<a name="ln782">          if (capflags != WF_ALLCAP) {</a>
<a name="ln783">            // When the character before the word is a word</a>
<a name="ln784">            // character we do not accept a Onecap word.  We do</a>
<a name="ln785">            // accept a no-caps word, even when the dictionary</a>
<a name="ln786">            // word specifies ONECAP.</a>
<a name="ln787">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln788">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln789">                ? capflags == WF_ONECAP</a>
<a name="ln790">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln791">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln792">              continue;</a>
<a name="ln793">            }</a>
<a name="ln794">          }</a>
<a name="ln795">        }</a>
<a name="ln796"> </a>
<a name="ln797">        // If the word ends the sequence of compound flags of the</a>
<a name="ln798">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln799">        // the number of syllables must not be too large.</a>
<a name="ln800">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = (uint8_t)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln801">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln802">        if (word_ends) {</a>
<a name="ln803">          char fword[MAXWLEN] = { 0 };</a>
<a name="ln804"> </a>
<a name="ln805">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln806">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln807">            if (ptr == mip-&gt;mi_word) {</a>
<a name="ln808">              (void)spell_casefold(mip-&gt;mi_win, ptr, wlen, fword, MAXWLEN);</a>
<a name="ln809">            } else {</a>
<a name="ln810">              xstrlcpy(fword, ptr, (size_t)endlen[endidxcnt] + 1);</a>
<a name="ln811">            }</a>
<a name="ln812">          }</a>
<a name="ln813">          if (!can_compound(slang, fword, mip-&gt;mi_compflags)) {</a>
<a name="ln814">            continue;</a>
<a name="ln815">          }</a>
<a name="ln816">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln817">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags)) {</a>
<a name="ln818">          // The compound flags collected so far do not match any</a>
<a name="ln819">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln820">          continue;</a>
<a name="ln821">        }</a>
<a name="ln822">      } else if (flags &amp; WF_NEEDCOMP) {</a>
<a name="ln823">        // skip if word is only valid in a compound</a>
<a name="ln824">        continue;</a>
<a name="ln825">      }</a>
<a name="ln826"> </a>
<a name="ln827">      int nobreak_result = SP_OK;</a>
<a name="ln828"> </a>
<a name="ln829">      if (!word_ends) {</a>
<a name="ln830">        int save_result = mip-&gt;mi_result;</a>
<a name="ln831">        char *save_end = mip-&gt;mi_end;</a>
<a name="ln832">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln833"> </a>
<a name="ln834">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln835">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln836">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln837">        // valid word follows.</a>
<a name="ln838">        // Recursive!</a>
<a name="ln839">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln840">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln841">        }</a>
<a name="ln842"> </a>
<a name="ln843">        // Find following word in case-folded tree.</a>
<a name="ln844">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln845">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln846">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln847">          // byte length in keep-case word.  Length may change when</a>
<a name="ln848">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln849">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln850">          p = mip-&gt;mi_fword;</a>
<a name="ln851">          if (strncmp(ptr, p, (size_t)wlen) != 0) {</a>
<a name="ln852">            for (char *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln853">              MB_PTR_ADV(p);</a>
<a name="ln854">            }</a>
<a name="ln855">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln856">          }</a>
<a name="ln857">        }</a>
<a name="ln858">#if 0</a>
<a name="ln859">        c = mip-&gt;mi_compoff;</a>
<a name="ln860">#endif</a>
<a name="ln861">        mip-&gt;mi_complen++;</a>
<a name="ln862">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln863">          mip-&gt;mi_compextra++;</a>
<a name="ln864">        }</a>
<a name="ln865"> </a>
<a name="ln866">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln867">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln868">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln869">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln870">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln871">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln872">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln873">              continue;</a>
<a name="ln874">            }</a>
<a name="ln875">          }</a>
<a name="ln876"> </a>
<a name="ln877">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln878"> </a>
<a name="ln879">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln880">          // need to find the longest match, thus try with keep-case</a>
<a name="ln881">          // and prefix too.</a>
<a name="ln882">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln883">            // Find following word in keep-case tree.</a>
<a name="ln884">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln885">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln886"> </a>
<a name="ln887">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln888">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln889">            // can't be a postponed prefix.</a>
<a name="ln890">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln891">              // Check for following word with prefix.</a>
<a name="ln892">              mip-&gt;mi_compoff = c;</a>
<a name="ln893">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln894">            }</a>
<a name="ln895">#endif</a>
<a name="ln896">          }</a>
<a name="ln897"> </a>
<a name="ln898">          if (!slang-&gt;sl_nobreak) {</a>
<a name="ln899">            break;</a>
<a name="ln900">          }</a>
<a name="ln901">        }</a>
<a name="ln902">        mip-&gt;mi_complen--;</a>
<a name="ln903">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln904">          mip-&gt;mi_compextra--;</a>
<a name="ln905">        }</a>
<a name="ln906">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln907"> </a>
<a name="ln908">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln909">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln910">          mip-&gt;mi_result = save_result;</a>
<a name="ln911">          mip-&gt;mi_end = save_end;</a>
<a name="ln912">        } else {</a>
<a name="ln913">          if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln914">            break;</a>
<a name="ln915">          }</a>
<a name="ln916">          continue;</a>
<a name="ln917">        }</a>
<a name="ln918">      }</a>
<a name="ln919"> </a>
<a name="ln920">      int res = SP_BAD;</a>
<a name="ln921">      if (flags &amp; WF_BANNED) {</a>
<a name="ln922">        res = SP_BANNED;</a>
<a name="ln923">      } else if (flags &amp; WF_REGION) {</a>
<a name="ln924">        // Check region.</a>
<a name="ln925">        if (((unsigned)mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0) {</a>
<a name="ln926">          res = SP_OK;</a>
<a name="ln927">        } else {</a>
<a name="ln928">          res = SP_LOCAL;</a>
<a name="ln929">        }</a>
<a name="ln930">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln931">        res = SP_RARE;</a>
<a name="ln932">      } else {</a>
<a name="ln933">        res = SP_OK;</a>
<a name="ln934">      }</a>
<a name="ln935"> </a>
<a name="ln936">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln937">      // we separately keep the longest match without a following good</a>
<a name="ln938">      // word as a fall-back.</a>
<a name="ln939">      if (nobreak_result == SP_BAD) {</a>
<a name="ln940">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln941">          mip-&gt;mi_result2 = res;</a>
<a name="ln942">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln943">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln944">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln945">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln946">        }</a>
<a name="ln947">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln948">        mip-&gt;mi_result = res;</a>
<a name="ln949">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln950">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln951">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln952">      }</a>
<a name="ln953"> </a>
<a name="ln954">      if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln955">        break;</a>
<a name="ln956">      }</a>
<a name="ln957">    }</a>
<a name="ln958"> </a>
<a name="ln959">    if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln960">      break;</a>
<a name="ln961">    }</a>
<a name="ln962">  }</a>
<a name="ln963">}</a>
<a name="ln964"> </a>
<a name="ln965">/// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln966">/// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln967">/// word.</a>
<a name="ln968">/// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln969">/// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln970">///</a>
<a name="ln971">/// @param gap  &amp;sl_comppat</a>
<a name="ln972">bool match_checkcompoundpattern(char *ptr, int wlen, garray_T *gap)</a>
<a name="ln973">{</a>
<a name="ln974">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln975">    char *p = ((char **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln976">    if (strncmp(ptr + wlen, p, strlen(p)) == 0) {</a>
<a name="ln977">      // Second part matches at start of following compound word, now</a>
<a name="ln978">      // check if first part matches at end of previous word.</a>
<a name="ln979">      p = ((char **)gap-&gt;ga_data)[i];</a>
<a name="ln980">      int len = (int)strlen(p);</a>
<a name="ln981">      if (len &lt;= wlen &amp;&amp; strncmp(ptr + wlen - len, p, (size_t)len) == 0) {</a>
<a name="ln982">        return true;</a>
<a name="ln983">      }</a>
<a name="ln984">    }</a>
<a name="ln985">  }</a>
<a name="ln986">  return false;</a>
<a name="ln987">}</a>
<a name="ln988"> </a>
<a name="ln989">/// @return  true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln990">///          does not have too many syllables.</a>
<a name="ln991">bool can_compound(slang_T *slang, const char *word, const uint8_t *flags)</a>
<a name="ln992">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln993">{</a>
<a name="ln994">  char uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln995"> </a>
<a name="ln996">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln997">    return false;</a>
<a name="ln998">  }</a>
<a name="ln999">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln1000">  char *p = uflags;</a>
<a name="ln1001">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1002">    p += utf_char2bytes(flags[i], p);</a>
<a name="ln1003">  }</a>
<a name="ln1004">  *p = NUL;</a>
<a name="ln1005">  p = uflags;</a>
<a name="ln1006">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1007">    return false;</a>
<a name="ln1008">  }</a>
<a name="ln1009"> </a>
<a name="ln1010">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1011">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1012">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1013">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1014">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax) {</a>
<a name="ln1015">    return (int)strlen((char *)flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1016">  }</a>
<a name="ln1017">  return true;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1021">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1022">// collected so far can't possibly match any compound rule.</a>
<a name="ln1023">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1024">bool match_compoundrule(slang_T *slang, const uint8_t *compflags)</a>
<a name="ln1025">{</a>
<a name="ln1026">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1027">  for (char *p = (char *)slang-&gt;sl_comprules; *p != NUL; p++) {</a>
<a name="ln1028">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1029">    // them against the current rule entry</a>
<a name="ln1030">    for (int i = 0;; i++) {</a>
<a name="ln1031">      int c = compflags[i];</a>
<a name="ln1032">      if (c == NUL) {</a>
<a name="ln1033">        // found a rule that matches for the flags we have so far</a>
<a name="ln1034">        return true;</a>
<a name="ln1035">      }</a>
<a name="ln1036">      if (*p == '/' || *p == NUL) {</a>
<a name="ln1037">        break;          // end of rule, it's too short</a>
<a name="ln1038">      }</a>
<a name="ln1039">      if (*p == '[') {</a>
<a name="ln1040">        bool match = false;</a>
<a name="ln1041"> </a>
<a name="ln1042">        // compare against all the flags in []</a>
<a name="ln1043">        p++;</a>
<a name="ln1044">        while (*p != ']' &amp;&amp; *p != NUL) {</a>
<a name="ln1045">          if ((uint8_t)(*p++) == c) {</a>
<a name="ln1046">            match = true;</a>
<a name="ln1047">          }</a>
<a name="ln1048">        }</a>
<a name="ln1049">        if (!match) {</a>
<a name="ln1050">          break;            // none matches</a>
<a name="ln1051">        }</a>
<a name="ln1052">      } else if ((uint8_t)(*p) != c) {</a>
<a name="ln1053">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1054">      }</a>
<a name="ln1055">      p++;</a>
<a name="ln1056">    }</a>
<a name="ln1057"> </a>
<a name="ln1058">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1059">    p = vim_strchr(p, '/');</a>
<a name="ln1060">    if (p == NULL) {</a>
<a name="ln1061">      break;</a>
<a name="ln1062">    }</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1066">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1067">  return false;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1071">/// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1072">/// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1073">///</a>
<a name="ln1074">/// @param totprefcnt  nr of prefix IDs</a>
<a name="ln1075">/// @param arridx  idx in sl_pidxs[]</a>
<a name="ln1076">/// @param cond_req  only use prefixes with a condition</a>
<a name="ln1077">int valid_word_prefix(int totprefcnt, int arridx, int flags, char *word, slang_T *slang,</a>
<a name="ln1078">                      bool cond_req)</a>
<a name="ln1079">{</a>
<a name="ln1080">  int prefid = (int)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1081">  for (int prefcnt = totprefcnt - 1; prefcnt &gt;= 0; prefcnt--) {</a>
<a name="ln1082">    int pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1083"> </a>
<a name="ln1084">    // Check the prefix ID.</a>
<a name="ln1085">    if (prefid != (pidx &amp; 0xff)) {</a>
<a name="ln1086">      continue;</a>
<a name="ln1087">    }</a>
<a name="ln1088"> </a>
<a name="ln1089">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1090">    // suffix.</a>
<a name="ln1091">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC)) {</a>
<a name="ln1092">      continue;</a>
<a name="ln1093">    }</a>
<a name="ln1094"> </a>
<a name="ln1095">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1096">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1097">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1098">    if (*rp != NULL) {</a>
<a name="ln1099">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1100">        continue;</a>
<a name="ln1101">      }</a>
<a name="ln1102">    } else if (cond_req) {</a>
<a name="ln1103">      continue;</a>
<a name="ln1104">    }</a>
<a name="ln1105"> </a>
<a name="ln1106">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1107">    return pidx;</a>
<a name="ln1108">  }</a>
<a name="ln1109">  return 0;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1113">// If it does, then check the following word.</a>
<a name="ln1114">//</a>
<a name="ln1115">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1116">// prefix in a compound word.</a>
<a name="ln1117">//</a>
<a name="ln1118">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1119">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1120">{</a>
<a name="ln1121">  idx_T arridx = 0;</a>
<a name="ln1122">  int wlen = 0;</a>
<a name="ln1123">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1124"> </a>
<a name="ln1125">  uint8_t *byts = slang-&gt;sl_pbyts;</a>
<a name="ln1126">  if (byts == NULL) {</a>
<a name="ln1127">    return;                     // array is empty</a>
<a name="ln1128">  }</a>
<a name="ln1129">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1130">  // case-folded.</a>
<a name="ln1131">  char *ptr = mip-&gt;mi_fword;</a>
<a name="ln1132">  int flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1133">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1134">    // Skip over the previously found word(s).</a>
<a name="ln1135">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1136">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1137">  }</a>
<a name="ln1138">  idx_T *idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1139"> </a>
<a name="ln1140">  // Repeat advancing in the tree until:</a>
<a name="ln1141">  // - there is a byte that doesn't match,</a>
<a name="ln1142">  // - we reach the end of the tree,</a>
<a name="ln1143">  // - or we reach the end of the line.</a>
<a name="ln1144">  while (true) {</a>
<a name="ln1145">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln1146">      flen = fold_more(mip);</a>
<a name="ln1147">    }</a>
<a name="ln1148"> </a>
<a name="ln1149">    int len = byts[arridx++];</a>
<a name="ln1150"> </a>
<a name="ln1151">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1152">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1153">    if (byts[arridx] == 0) {</a>
<a name="ln1154">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1155">      // try them all, since we don't know which one will give the</a>
<a name="ln1156">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1157">      // of possible prefixes to find_word().</a>
<a name="ln1158">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1159">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1160">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1161">        arridx++;</a>
<a name="ln1162">        len--;</a>
<a name="ln1163">      }</a>
<a name="ln1164">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1165"> </a>
<a name="ln1166">      // Find the word that comes after the prefix.</a>
<a name="ln1167">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1168">      if (mode == FIND_COMPOUND) {</a>
<a name="ln1169">        // Skip over the previously found word(s).</a>
<a name="ln1170">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1171">      }</a>
<a name="ln1172"> </a>
<a name="ln1173">      // Case-folded length may differ from original length.</a>
<a name="ln1174">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1175">                                      mip-&gt;mi_word);</a>
<a name="ln1176">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1177"> </a>
<a name="ln1178">      if (len == 0) {</a>
<a name="ln1179">        break;              // no children, word must end here</a>
<a name="ln1180">      }</a>
<a name="ln1181">    }</a>
<a name="ln1182"> </a>
<a name="ln1183">    // Stop looking at end of the line.</a>
<a name="ln1184">    if (ptr[wlen] == NUL) {</a>
<a name="ln1185">      break;</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1189">    int c = (uint8_t)ptr[wlen];</a>
<a name="ln1190">    idx_T lo = arridx;</a>
<a name="ln1191">    idx_T hi = arridx + len - 1;</a>
<a name="ln1192">    while (lo &lt; hi) {</a>
<a name="ln1193">      idx_T m = (lo + hi) / 2;</a>
<a name="ln1194">      if (byts[m] &gt; c) {</a>
<a name="ln1195">        hi = m - 1;</a>
<a name="ln1196">      } else if (byts[m] &lt; c) {</a>
<a name="ln1197">        lo = m + 1;</a>
<a name="ln1198">      } else {</a>
<a name="ln1199">        lo = hi = m;</a>
<a name="ln1200">        break;</a>
<a name="ln1201">      }</a>
<a name="ln1202">    }</a>
<a name="ln1203"> </a>
<a name="ln1204">    // Stop if there is no matching byte.</a>
<a name="ln1205">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln1206">      break;</a>
<a name="ln1207">    }</a>
<a name="ln1208"> </a>
<a name="ln1209">    // Continue at the child (if there is one).</a>
<a name="ln1210">    arridx = idxs[lo];</a>
<a name="ln1211">    wlen++;</a>
<a name="ln1212">    flen--;</a>
<a name="ln1213">  }</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1217">// for efficiency.  Include the non-word character too.</a>
<a name="ln1218">// Return the length of the folded chars in bytes.</a>
<a name="ln1219">static int fold_more(matchinf_T *mip)</a>
<a name="ln1220">{</a>
<a name="ln1221">  char *p = mip-&gt;mi_fend;</a>
<a name="ln1222">  do {</a>
<a name="ln1223">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1224">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1225"> </a>
<a name="ln1226">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1227">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1228">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1229">  }</a>
<a name="ln1230"> </a>
<a name="ln1231">  (void)spell_casefold(mip-&gt;mi_win, p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1232">                       mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1233">                       MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1234">  int flen = (int)strlen(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1235">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1236">  return flen;</a>
<a name="ln1237">}</a>
<a name="ln1238"> </a>
<a name="ln1239">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1240">/// case.</a>
<a name="ln1241">///</a>
<a name="ln1242">/// @param wordflags Flags for the checked word.</a>
<a name="ln1243">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1244">bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1245">{</a>
<a name="ln1246">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1247">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1248">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1249">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">/// Return true if spell checking is enabled for &quot;wp&quot;.</a>
<a name="ln1253">bool spell_check_window(win_T *wp)</a>
<a name="ln1254">{</a>
<a name="ln1255">  return wp-&gt;w_p_spell</a>
<a name="ln1256">         &amp;&amp; *wp-&gt;w_s-&gt;b_p_spl != NUL</a>
<a name="ln1257">         &amp;&amp; wp-&gt;w_s-&gt;b_langp.ga_len &gt; 0</a>
<a name="ln1258">         &amp;&amp; *(char **)(wp-&gt;w_s-&gt;b_langp.ga_data) != NULL;</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">/// Return true and give an error if spell checking is not enabled.</a>
<a name="ln1262">bool no_spell_checking(win_T *wp)</a>
<a name="ln1263">{</a>
<a name="ln1264">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1265">    emsg(_(e_no_spell));</a>
<a name="ln1266">    return true;</a>
<a name="ln1267">  }</a>
<a name="ln1268">  return false;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">static void decor_spell_nav_start(win_T *wp)</a>
<a name="ln1272">{</a>
<a name="ln1273">  decor_state = (DecorState){ 0 };</a>
<a name="ln1274">  decor_redraw_reset(wp, &amp;decor_state);</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">static TriState decor_spell_nav_col(win_T *wp, linenr_T lnum, linenr_T *decor_lnum, int col)</a>
<a name="ln1278">{</a>
<a name="ln1279">  if (*decor_lnum != lnum) {</a>
<a name="ln1280">    decor_providers_invoke_spell(wp, lnum - 1, col, lnum - 1, -1);</a>
<a name="ln1281">    decor_redraw_line(wp, lnum - 1, &amp;decor_state);</a>
<a name="ln1282">    *decor_lnum = lnum;</a>
<a name="ln1283">  }</a>
<a name="ln1284">  decor_redraw_col(wp, col, 0, false, &amp;decor_state);</a>
<a name="ln1285">  return decor_state.spell;</a>
<a name="ln1286">}</a>
<a name="ln1287"> </a>
<a name="ln1288">static inline bool can_syn_spell(win_T *wp, linenr_T lnum, int col)</a>
<a name="ln1289">{</a>
<a name="ln1290">  bool can_spell;</a>
<a name="ln1291">  (void)syn_get_id(wp, lnum, col, false, &amp;can_spell, false);</a>
<a name="ln1292">  return can_spell;</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">/// Moves to the next spell error.</a>
<a name="ln1296">/// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1297">/// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1298">/// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1299">/// to after badly spelled word before the cursor.</a>
<a name="ln1300">///</a>
<a name="ln1301">/// @param dir  FORWARD or BACKWARD</a>
<a name="ln1302">/// @param allwords  true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1303">/// @param attrp  return: attributes of bad word or NULL (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1304">///</a>
<a name="ln1305">/// @return  0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1306">size_t spell_move_to(win_T *wp, int dir, bool allwords, bool curline, hlf_T *attrp)</a>
<a name="ln1307">{</a>
<a name="ln1308">  pos_T found_pos;</a>
<a name="ln1309">  size_t found_len = 0;</a>
<a name="ln1310">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1311">  size_t len;</a>
<a name="ln1312">  int has_syntax = syntax_present(wp);</a>
<a name="ln1313">  colnr_T col;</a>
<a name="ln1314">  char *buf = NULL;</a>
<a name="ln1315">  size_t buflen = 0;</a>
<a name="ln1316">  int skip = 0;</a>
<a name="ln1317">  colnr_T capcol = -1;</a>
<a name="ln1318">  bool found_one = false;</a>
<a name="ln1319">  bool wrapped = false;</a>
<a name="ln1320"> </a>
<a name="ln1321">  if (no_spell_checking(wp)) {</a>
<a name="ln1322">    return 0;</a>
<a name="ln1323">  }</a>
<a name="ln1324"> </a>
<a name="ln1325">  size_t ret = 0;</a>
<a name="ln1326"> </a>
<a name="ln1327">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1328">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1329">  //</a>
<a name="ln1330">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1331">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1332">  //</a>
<a name="ln1333">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1334">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1335">  // though...</a>
<a name="ln1336">  linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1337">  clearpos(&amp;found_pos);</a>
<a name="ln1338"> </a>
<a name="ln1339">  // Ephemeral extmarks are currently stored in the global decor_state.</a>
<a name="ln1340">  // When looking for spell errors, we need to:</a>
<a name="ln1341">  //  - temporarily reset decor_state</a>
<a name="ln1342">  //  - run the _on_spell_nav decor callback for each line we look at</a>
<a name="ln1343">  //  - detect if any spell marks are present</a>
<a name="ln1344">  //  - restore decor_state to the value saved here.</a>
<a name="ln1345">  // TODO(lewis6991): un-globalize decor_state and allow ephemeral marks to be stored into a</a>
<a name="ln1346">  // temporary DecorState.</a>
<a name="ln1347">  DecorState saved_decor_start = decor_state;</a>
<a name="ln1348">  linenr_T decor_lnum = -1;</a>
<a name="ln1349">  decor_spell_nav_start(wp);</a>
<a name="ln1350"> </a>
<a name="ln1351">  while (!got_int) {</a>
<a name="ln1352">    char *line = ml_get_buf(wp-&gt;w_buffer, lnum);</a>
<a name="ln1353"> </a>
<a name="ln1354">    len = strlen(line);</a>
<a name="ln1355">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1356">      xfree(buf);</a>
<a name="ln1357">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1358">      buf = xmalloc(buflen);</a>
<a name="ln1359">    }</a>
<a name="ln1360">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1361"> </a>
<a name="ln1362">    // In first line check first word for Capital.</a>
<a name="ln1363">    if (lnum == 1) {</a>
<a name="ln1364">      capcol = 0;</a>
<a name="ln1365">    }</a>
<a name="ln1366"> </a>
<a name="ln1367">    // For checking first word with a capital skip white space.</a>
<a name="ln1368">    if (capcol == 0) {</a>
<a name="ln1369">      capcol = (colnr_T)getwhitecols(line);</a>
<a name="ln1370">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1371">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1372">      col = (colnr_T)getwhitecols(line);</a>
<a name="ln1373">      if (check_need_cap(curwin, lnum, col)) {</a>
<a name="ln1374">        capcol = col;</a>
<a name="ln1375">      }</a>
<a name="ln1376"> </a>
<a name="ln1377">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1378">      // one.</a>
<a name="ln1379">      line = ml_get_buf(wp-&gt;w_buffer, lnum);</a>
<a name="ln1380">    }</a>
<a name="ln1381"> </a>
<a name="ln1382">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1383">    // possible.  Note: this ml_get_buf() may make &quot;line&quot; invalid, check</a>
<a name="ln1384">    // for empty line first.</a>
<a name="ln1385">    bool empty_line = *skipwhite(line) == NUL;</a>
<a name="ln1386">    STRCPY(buf, line);</a>
<a name="ln1387">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1388">      spell_cat_line(buf + strlen(buf),</a>
<a name="ln1389">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1),</a>
<a name="ln1390">                     MAXWLEN);</a>
<a name="ln1391">    }</a>
<a name="ln1392">    char *p = buf + skip;</a>
<a name="ln1393">    char *endp = buf + len;</a>
<a name="ln1394">    while (p &lt; endp) {</a>
<a name="ln1395">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1396">      // we wrapped around the end of the buffer.</a>
<a name="ln1397">      if (dir == BACKWARD</a>
<a name="ln1398">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1399">          &amp;&amp; !wrapped</a>
<a name="ln1400">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col) {</a>
<a name="ln1401">        break;</a>
<a name="ln1402">      }</a>
<a name="ln1403"> </a>
<a name="ln1404">      // start of word</a>
<a name="ln1405">      attr = HLF_COUNT;</a>
<a name="ln1406">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1407"> </a>
<a name="ln1408">      if (attr != HLF_COUNT) {</a>
<a name="ln1409">        // We found a bad word.  Check the attribute.</a>
<a name="ln1410">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1411">          // When searching forward only accept a bad word after</a>
<a name="ln1412">          // the cursor.</a>
<a name="ln1413">          if (dir == BACKWARD</a>
<a name="ln1414">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1415">              || wrapped</a>
<a name="ln1416">              || ((colnr_T)(curline</a>
<a name="ln1417">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1418">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1419">            col = (colnr_T)(p - buf);</a>
<a name="ln1420"> </a>
<a name="ln1421">            bool no_plain_buffer = (wp-&gt;w_s-&gt;b_p_spo_flags &amp; SPO_NPBUFFER) != 0;</a>
<a name="ln1422">            bool can_spell = !no_plain_buffer;</a>
<a name="ln1423">            switch (decor_spell_nav_col(wp, lnum, &amp;decor_lnum, col)) {</a>
<a name="ln1424">            case kTrue:</a>
<a name="ln1425">              can_spell = true; break;</a>
<a name="ln1426">            case kFalse:</a>
<a name="ln1427">              can_spell = false; break;</a>
<a name="ln1428">            case kNone:</a>
<a name="ln1429">              if (has_syntax) {</a>
<a name="ln1430">                can_spell = can_syn_spell(wp, lnum, col);</a>
<a name="ln1431">              }</a>
<a name="ln1432">            }</a>
<a name="ln1433"> </a>
<a name="ln1434">            if (!can_spell) {</a>
<a name="ln1435">              attr = HLF_COUNT;</a>
<a name="ln1436">            }</a>
<a name="ln1437"> </a>
<a name="ln1438">            if (can_spell) {</a>
<a name="ln1439">              found_one = true;</a>
<a name="ln1440">              found_pos = (pos_T) {</a>
<a name="ln1441">                .lnum = lnum,</a>
<a name="ln1442">                .col = col,</a>
<a name="ln1443">                .coladd = 0</a>
<a name="ln1444">              };</a>
<a name="ln1445">              if (dir == FORWARD) {</a>
<a name="ln1446">                // No need to search further.</a>
<a name="ln1447">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1448">                if (attrp != NULL) {</a>
<a name="ln1449">                  *attrp = attr;</a>
<a name="ln1450">                }</a>
<a name="ln1451">                ret = len;</a>
<a name="ln1452">                goto theend;</a>
<a name="ln1453">              } else if (curline) {</a>
<a name="ln1454">                // Insert mode completion: put cursor after</a>
<a name="ln1455">                // the bad word.</a>
<a name="ln1456">                assert(len &lt;= INT_MAX);</a>
<a name="ln1457">                found_pos.col += (int)len;</a>
<a name="ln1458">              }</a>
<a name="ln1459">              found_len = len;</a>
<a name="ln1460">            }</a>
<a name="ln1461">          } else {</a>
<a name="ln1462">            found_one = true;</a>
<a name="ln1463">          }</a>
<a name="ln1464">        }</a>
<a name="ln1465">      }</a>
<a name="ln1466"> </a>
<a name="ln1467">      // advance to character after the word</a>
<a name="ln1468">      p += len;</a>
<a name="ln1469">      assert(len &lt;= INT_MAX);</a>
<a name="ln1470">      capcol -= (int)len;</a>
<a name="ln1471">    }</a>
<a name="ln1472"> </a>
<a name="ln1473">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1474">      // Use the last match in the line (before the cursor).</a>
<a name="ln1475">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1476">      ret = found_len;</a>
<a name="ln1477">      goto theend;</a>
<a name="ln1478">    }</a>
<a name="ln1479"> </a>
<a name="ln1480">    if (curline) {</a>
<a name="ln1481">      break;            // only check cursor line</a>
<a name="ln1482">    }</a>
<a name="ln1483"> </a>
<a name="ln1484">    // If we are back at the starting line and searched it again there</a>
<a name="ln1485">    // is no match, give up.</a>
<a name="ln1486">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1487">      break;</a>
<a name="ln1488">    }</a>
<a name="ln1489"> </a>
<a name="ln1490">    // Advance to next line.</a>
<a name="ln1491">    if (dir == BACKWARD) {</a>
<a name="ln1492">      if (lnum &gt; 1) {</a>
<a name="ln1493">        lnum--;</a>
<a name="ln1494">      } else if (!p_ws) {</a>
<a name="ln1495">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1496">      } else {</a>
<a name="ln1497">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1498">        // starting line again and accept the last match.</a>
<a name="ln1499">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1500">        wrapped = true;</a>
<a name="ln1501">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1502">          give_warning(_(top_bot_msg), true);</a>
<a name="ln1503">        }</a>
<a name="ln1504">      }</a>
<a name="ln1505">      capcol = -1;</a>
<a name="ln1506">    } else {</a>
<a name="ln1507">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1508">        lnum++;</a>
<a name="ln1509">      } else if (!p_ws) {</a>
<a name="ln1510">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1511">      } else {</a>
<a name="ln1512">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1513">        // starting line again and accept the first match.</a>
<a name="ln1514">        lnum = 1;</a>
<a name="ln1515">        wrapped = true;</a>
<a name="ln1516">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1517">          give_warning(_(bot_top_msg), true);</a>
<a name="ln1518">        }</a>
<a name="ln1519">      }</a>
<a name="ln1520"> </a>
<a name="ln1521">      // If we are back at the starting line and there is no match then</a>
<a name="ln1522">      // give up.</a>
<a name="ln1523">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1524">        break;</a>
<a name="ln1525">      }</a>
<a name="ln1526"> </a>
<a name="ln1527">      // Skip the characters at the start of the next line that were</a>
<a name="ln1528">      // included in a match crossing line boundaries.</a>
<a name="ln1529">      if (attr == HLF_COUNT) {</a>
<a name="ln1530">        skip = (int)(p - endp);</a>
<a name="ln1531">      } else {</a>
<a name="ln1532">        skip = 0;</a>
<a name="ln1533">      }</a>
<a name="ln1534"> </a>
<a name="ln1535">      // Capcol skips over the inserted space.</a>
<a name="ln1536">      capcol--;</a>
<a name="ln1537"> </a>
<a name="ln1538">      // But after empty line check first word in next line</a>
<a name="ln1539">      if (empty_line) {</a>
<a name="ln1540">        capcol = 0;</a>
<a name="ln1541">      }</a>
<a name="ln1542">    }</a>
<a name="ln1543"> </a>
<a name="ln1544">    line_breakcheck();</a>
<a name="ln1545">  }</a>
<a name="ln1546"> </a>
<a name="ln1547">theend:</a>
<a name="ln1548">  decor_state_free(&amp;decor_state);</a>
<a name="ln1549">  decor_state = saved_decor_start;</a>
<a name="ln1550">  xfree(buf);</a>
<a name="ln1551">  return ret;</a>
<a name="ln1552">}</a>
<a name="ln1553"> </a>
<a name="ln1554">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1555">// &quot;buf&quot;, blanking-out special characters.  Copy less than &quot;maxlen&quot; bytes.</a>
<a name="ln1556">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1557">// to skip those bytes if the word was OK.</a>
<a name="ln1558">void spell_cat_line(char *buf, char *line, int maxlen)</a>
<a name="ln1559">{</a>
<a name="ln1560">  char *p = skipwhite(line);</a>
<a name="ln1561">  while (vim_strchr(&quot;*#/\&quot;\t&quot;, (uint8_t)(*p)) != NULL) {</a>
<a name="ln1562">    p = skipwhite(p + 1);</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  if (*p == NUL) {</a>
<a name="ln1566">    return;</a>
<a name="ln1567">  }</a>
<a name="ln1568"> </a>
<a name="ln1569">  // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1570">  // concatenate.</a>
<a name="ln1571">  int n = (int)(p - line) + 1;</a>
<a name="ln1572">  if (n &lt; maxlen - 1) {</a>
<a name="ln1573">    memset(buf, ' ', (size_t)n);</a>
<a name="ln1574">    xstrlcpy(buf + n, p, (size_t)(maxlen - n));</a>
<a name="ln1575">  }</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1579">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1580">static void spell_load_lang(char *lang)</a>
<a name="ln1581">{</a>
<a name="ln1582">  char fname_enc[85];</a>
<a name="ln1583">  int r;</a>
<a name="ln1584">  spelload_T sl;</a>
<a name="ln1585"> </a>
<a name="ln1586">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1587">  // It's truncated when an error is detected.</a>
<a name="ln1588">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1589">  sl.sl_slang = NULL;</a>
<a name="ln1590">  sl.sl_nobreak = false;</a>
<a name="ln1591"> </a>
<a name="ln1592">  // Disallow deleting the current buffer.  Autocommands can do weird things</a>
<a name="ln1593">  // and cause &quot;lang&quot; to be freed.</a>
<a name="ln1594">  curbuf-&gt;b_locked++;</a>
<a name="ln1595"> </a>
<a name="ln1596">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1597">  // autocommand may load it then.</a>
<a name="ln1598">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln1599">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1600">    vim_snprintf(fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1601">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1602">    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1603"> </a>
<a name="ln1604">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1605">      // Try loading the ASCII version.</a>
<a name="ln1606">      vim_snprintf(fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1607">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1608">      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1609"> </a>
<a name="ln1610">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1611">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</a>
<a name="ln1612">                            curbuf-&gt;b_fname, false, curbuf)) {</a>
<a name="ln1613">        continue;</a>
<a name="ln1614">      }</a>
<a name="ln1615">      break;</a>
<a name="ln1616">    }</a>
<a name="ln1617">    break;</a>
<a name="ln1618">  }</a>
<a name="ln1619"> </a>
<a name="ln1620">  if (r == FAIL) {</a>
<a name="ln1621">    if (starting) {</a>
<a name="ln1622">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1623">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1624">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1625">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1626">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1627">               lang);</a>
<a name="ln1628">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1629">    } else {</a>
<a name="ln1630">      smsg(0, _(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1631">           lang, spell_enc(), lang);</a>
<a name="ln1632">    }</a>
<a name="ln1633">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1634">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1635">    STRCPY(fname_enc + strlen(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1636">    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1637">  }</a>
<a name="ln1638"> </a>
<a name="ln1639">  curbuf-&gt;b_locked--;</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1643">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1644">char *spell_enc(void)</a>
<a name="ln1645">{</a>
<a name="ln1646">  if (strlen(p_enc) &lt; 60 &amp;&amp; strcmp(p_enc, &quot;iso-8859-15&quot;) != 0) {</a>
<a name="ln1647">    return p_enc;</a>
<a name="ln1648">  }</a>
<a name="ln1649">  return &quot;latin1&quot;;</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1653">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1654">static void int_wordlist_spl(char *fname)</a>
<a name="ln1655">{</a>
<a name="ln1656">  vim_snprintf(fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1657">               int_wordlist, spell_enc());</a>
<a name="ln1658">}</a>
<a name="ln1659"> </a>
<a name="ln1660">/// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1661">/// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1662">slang_T *slang_alloc(char *lang)</a>
<a name="ln1663">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1664">{</a>
<a name="ln1665">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1666"> </a>
<a name="ln1667">  if (lang != NULL) {</a>
<a name="ln1668">    lp-&gt;sl_name = xstrdup(lang);</a>
<a name="ln1669">  }</a>
<a name="ln1670">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1671">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1672">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1673">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1674">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1675"> </a>
<a name="ln1676">  return lp;</a>
<a name="ln1677">}</a>
<a name="ln1678"> </a>
<a name="ln1679">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1680">void slang_free(slang_T *lp)</a>
<a name="ln1681">{</a>
<a name="ln1682">  xfree(lp-&gt;sl_name);</a>
<a name="ln1683">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1684">  slang_clear(lp);</a>
<a name="ln1685">  xfree(lp);</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688">/// Frees a salitem_T</a>
<a name="ln1689">static void free_salitem(salitem_T *smp)</a>
<a name="ln1690">{</a>
<a name="ln1691">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1692">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1693">  xfree(smp-&gt;sm_to);</a>
<a name="ln1694">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1695">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1696">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">/// Frees a fromto_T</a>
<a name="ln1700">static void free_fromto(fromto_T *ftp)</a>
<a name="ln1701">{</a>
<a name="ln1702">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1703">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1707">void slang_clear(slang_T *lp)</a>
<a name="ln1708">{</a>
<a name="ln1709">  garray_T *gap;</a>
<a name="ln1710"> </a>
<a name="ln1711">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1712">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1713">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1714"> </a>
<a name="ln1715">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1716">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1717">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1718"> </a>
<a name="ln1719">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1720">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1721"> </a>
<a name="ln1722">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1723">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1724">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1725">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1726">  } else {</a>
<a name="ln1727">    // SAL items: free salitem_T items</a>
<a name="ln1728">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1729">  }</a>
<a name="ln1730"> </a>
<a name="ln1731">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; i++) {</a>
<a name="ln1732">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1733">  }</a>
<a name="ln1734">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1735">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1736">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1737">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1738"> </a>
<a name="ln1739">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1740">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1741">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1742">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1743">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1744"> </a>
<a name="ln1745">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1746">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1747"> </a>
<a name="ln1748">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1749"> </a>
<a name="ln1750">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1751">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1752"> </a>
<a name="ln1753">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1754"> </a>
<a name="ln1755">  // Clear info from .sug file.</a>
<a name="ln1756">  slang_clear_sug(lp);</a>
<a name="ln1757"> </a>
<a name="ln1758">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1759">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1760">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1761">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1762">}</a>
<a name="ln1763"> </a>
<a name="ln1764">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1765">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1766">{</a>
<a name="ln1767">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1768">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1769">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1770">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1771">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1772">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1776">// Invoked through do_in_runtimepath().</a>
<a name="ln1777">static bool spell_load_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln1778">{</a>
<a name="ln1779">  spelload_T *slp = (spelload_T *)cookie;</a>
<a name="ln1780">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln1781">    slang_T *slang = spell_load_file(fnames[i], slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1782"> </a>
<a name="ln1783">    if (slang == NULL) {</a>
<a name="ln1784">      continue;</a>
<a name="ln1785">    }</a>
<a name="ln1786"> </a>
<a name="ln1787">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1788">    // &quot;.add&quot; files.</a>
<a name="ln1789">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add) {</a>
<a name="ln1790">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1791">    } else if (slang-&gt;sl_nobreak) {</a>
<a name="ln1792">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1793">    }</a>
<a name="ln1794"> </a>
<a name="ln1795">    slp-&gt;sl_slang = slang;</a>
<a name="ln1796"> </a>
<a name="ln1797">    if (!all) {</a>
<a name="ln1798">      break;</a>
<a name="ln1799">    }</a>
<a name="ln1800">  }</a>
<a name="ln1801"> </a>
<a name="ln1802">  return num_fnames &gt; 0;</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">/// Add a word to the hashtable of common words.</a>
<a name="ln1806">/// If it's already there then the counter is increased.</a>
<a name="ln1807">///</a>
<a name="ln1808">/// @param[in]  lp</a>
<a name="ln1809">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1810">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1811">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1812">void count_common_word(slang_T *lp, char *word, int len, uint8_t count)</a>
<a name="ln1813">{</a>
<a name="ln1814">  char buf[MAXWLEN];</a>
<a name="ln1815">  char *p;</a>
<a name="ln1816"> </a>
<a name="ln1817">  if (len == -1) {</a>
<a name="ln1818">    p = word;</a>
<a name="ln1819">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1820">    return;</a>
<a name="ln1821">  } else {</a>
<a name="ln1822">    xstrlcpy(buf, word, (size_t)len + 1);</a>
<a name="ln1823">    p = buf;</a>
<a name="ln1824">  }</a>
<a name="ln1825"> </a>
<a name="ln1826">  wordcount_T *wc;</a>
<a name="ln1827">  hash_T hash = hash_hash(p);</a>
<a name="ln1828">  const size_t p_len = strlen(p);</a>
<a name="ln1829">  hashitem_T *hi = hash_lookup(&amp;lp-&gt;sl_wordcount, p, p_len, hash);</a>
<a name="ln1830">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1831">    wc = xmalloc(offsetof(wordcount_T, wc_word) + p_len + 1);</a>
<a name="ln1832">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1833">    wc-&gt;wc_count = count;</a>
<a name="ln1834">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1835">  } else {</a>
<a name="ln1836">    wc = HI2WC(hi);</a>
<a name="ln1837">    wc-&gt;wc_count = (uint16_t)(wc-&gt;wc_count + count);</a>
<a name="ln1838">    if (wc-&gt;wc_count &lt; count) {    // check for overflow</a>
<a name="ln1839">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1840">    }</a>
<a name="ln1841">  }</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1845">// Like strchr() but independent of locale.</a>
<a name="ln1846">bool byte_in_str(uint8_t *str, int n)</a>
<a name="ln1847">{</a>
<a name="ln1848">  for (uint8_t *p = str; *p != NUL; p++) {</a>
<a name="ln1849">    if (*p == n) {</a>
<a name="ln1850">      return true;</a>
<a name="ln1851">    }</a>
<a name="ln1852">  }</a>
<a name="ln1853">  return false;</a>
<a name="ln1854">}</a>
<a name="ln1855"> </a>
<a name="ln1856">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1857">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1858">int init_syl_tab(slang_T *slang)</a>
<a name="ln1859">{</a>
<a name="ln1860">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1861">  char *p = vim_strchr(slang-&gt;sl_syllable, '/');</a>
<a name="ln1862">  while (p != NULL) {</a>
<a name="ln1863">    *p++ = NUL;</a>
<a name="ln1864">    if (*p == NUL) {        // trailing slash</a>
<a name="ln1865">      break;</a>
<a name="ln1866">    }</a>
<a name="ln1867">    char *s = p;</a>
<a name="ln1868">    p = vim_strchr(p, '/');</a>
<a name="ln1869">    int l;</a>
<a name="ln1870">    if (p == NULL) {</a>
<a name="ln1871">      l = (int)strlen(s);</a>
<a name="ln1872">    } else {</a>
<a name="ln1873">      l = (int)(p - s);</a>
<a name="ln1874">    }</a>
<a name="ln1875">    if (l &gt;= SY_MAXLEN) {</a>
<a name="ln1876">      return SP_FORMERROR;</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1880">    xstrlcpy(syl-&gt;sy_chars, s, (size_t)l + 1);</a>
<a name="ln1881">    syl-&gt;sy_len = l;</a>
<a name="ln1882">  }</a>
<a name="ln1883">  return OK;</a>
<a name="ln1884">}</a>
<a name="ln1885"> </a>
<a name="ln1886">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1887">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1888">// Returns zero if syllables are not defines.</a>
<a name="ln1889">static int count_syllables(slang_T *slang, const char *word)</a>
<a name="ln1890">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1891">{</a>
<a name="ln1892">  int cnt = 0;</a>
<a name="ln1893">  bool skip = false;</a>
<a name="ln1894">  int len;</a>
<a name="ln1895"> </a>
<a name="ln1896">  if (slang-&gt;sl_syllable == NULL) {</a>
<a name="ln1897">    return 0;</a>
<a name="ln1898">  }</a>
<a name="ln1899"> </a>
<a name="ln1900">  for (const char *p = word; *p != NUL; p += len) {</a>
<a name="ln1901">    // When running into a space reset counter.</a>
<a name="ln1902">    if (*p == ' ') {</a>
<a name="ln1903">      len = 1;</a>
<a name="ln1904">      cnt = 0;</a>
<a name="ln1905">      continue;</a>
<a name="ln1906">    }</a>
<a name="ln1907"> </a>
<a name="ln1908">    // Find longest match of syllable items.</a>
<a name="ln1909">    len = 0;</a>
<a name="ln1910">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; i++) {</a>
<a name="ln1911">      syl_item_T *syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln1912">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln1913">          &amp;&amp; strncmp(p, syl-&gt;sy_chars, (size_t)syl-&gt;sy_len) == 0) {</a>
<a name="ln1914">        len = syl-&gt;sy_len;</a>
<a name="ln1915">      }</a>
<a name="ln1916">    }</a>
<a name="ln1917">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln1918">      cnt++;</a>
<a name="ln1919">      skip = false;</a>
<a name="ln1920">    } else {</a>
<a name="ln1921">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln1922">      int c = utf_ptr2char(p);</a>
<a name="ln1923">      len = utfc_ptr2len(p);</a>
<a name="ln1924">      if (vim_strchr(slang-&gt;sl_syllable, c) == NULL) {</a>
<a name="ln1925">        skip = false;               // No, search for next syllable</a>
<a name="ln1926">      } else if (!skip) {</a>
<a name="ln1927">        cnt++;                      // Yes, count it</a>
<a name="ln1928">        skip = true;                // don't count following syllable chars</a>
<a name="ln1929">      }</a>
<a name="ln1930">    }</a>
<a name="ln1931">  }</a>
<a name="ln1932">  return cnt;</a>
<a name="ln1933">}</a>
<a name="ln1934"> </a>
<a name="ln1935">/// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln1936">/// @return  NULL if it's OK, an untranslated error message otherwise.</a>
<a name="ln1937">char *parse_spelllang(win_T *wp)</a>
<a name="ln1938">{</a>
<a name="ln1939">  garray_T ga;</a>
<a name="ln1940">  char *splp;</a>
<a name="ln1941">  char *region;</a>
<a name="ln1942">  char region_cp[3];</a>
<a name="ln1943">  bool filename;</a>
<a name="ln1944">  int region_mask;</a>
<a name="ln1945">  slang_T *slang;</a>
<a name="ln1946">  int c;</a>
<a name="ln1947">  char lang[MAXWLEN + 1];</a>
<a name="ln1948">  char spf_name[MAXPATHL];</a>
<a name="ln1949">  int len;</a>
<a name="ln1950">  char *p;</a>
<a name="ln1951">  int round;</a>
<a name="ln1952">  char *spf;</a>
<a name="ln1953">  char *use_region = NULL;</a>
<a name="ln1954">  bool dont_use_region = false;</a>
<a name="ln1955">  bool nobreak = false;</a>
<a name="ln1956">  langp_T *lp, *lp2;</a>
<a name="ln1957">  static bool recursive = false;</a>
<a name="ln1958">  char *ret_msg = NULL;</a>
<a name="ln1959">  char *spl_copy;</a>
<a name="ln1960"> </a>
<a name="ln1961">  bufref_T bufref;</a>
<a name="ln1962">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln1963"> </a>
<a name="ln1964">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln1965">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln1966">  // in which 'spell' is set.</a>
<a name="ln1967">  if (recursive) {</a>
<a name="ln1968">    return NULL;</a>
<a name="ln1969">  }</a>
<a name="ln1970">  recursive = true;</a>
<a name="ln1971"> </a>
<a name="ln1972">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln1973">  clear_midword(wp);</a>
<a name="ln1974"> </a>
<a name="ln1975">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln1976">  // it under our fingers.</a>
<a name="ln1977">  spl_copy = xstrdup(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln1978"> </a>
<a name="ln1979">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln1980"> </a>
<a name="ln1981">  // Loop over comma separated language names.</a>
<a name="ln1982">  for (splp = spl_copy; *splp != NUL;) {</a>
<a name="ln1983">    // Get one language name.</a>
<a name="ln1984">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln1985">    region = NULL;</a>
<a name="ln1986">    len = (int)strlen(lang);</a>
<a name="ln1987"> </a>
<a name="ln1988">    if (!valid_spelllang(lang)) {</a>
<a name="ln1989">      continue;</a>
<a name="ln1990">    }</a>
<a name="ln1991"> </a>
<a name="ln1992">    if (strcmp(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln1993">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln1994">      continue;</a>
<a name="ln1995">    }</a>
<a name="ln1996"> </a>
<a name="ln1997">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln1998">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln1999">    // from the name.</a>
<a name="ln2000">    if (len &gt; 4 &amp;&amp; path_fnamecmp(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2001">      filename = true;</a>
<a name="ln2002"> </a>
<a name="ln2003">      // Locate a region and remove it from the file name.</a>
<a name="ln2004">      p = vim_strchr(path_tail(lang), '_');</a>
<a name="ln2005">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2006">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2007">        xstrlcpy(region_cp, p + 1, 3);</a>
<a name="ln2008">        memmove(p, p + 3, (size_t)(len - (p - lang) - 2));</a>
<a name="ln2009">        region = region_cp;</a>
<a name="ln2010">      } else {</a>
<a name="ln2011">        dont_use_region = true;</a>
<a name="ln2012">      }</a>
<a name="ln2013"> </a>
<a name="ln2014">      // Check if we loaded this language before.</a>
<a name="ln2015">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2016">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2017">            == kEqualFiles) {</a>
<a name="ln2018">          break;</a>
<a name="ln2019">        }</a>
<a name="ln2020">      }</a>
<a name="ln2021">    } else {</a>
<a name="ln2022">      filename = false;</a>
<a name="ln2023">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2024">        region = lang + len - 2;</a>
<a name="ln2025">        lang[len - 3] = NUL;</a>
<a name="ln2026">      } else {</a>
<a name="ln2027">        dont_use_region = true;</a>
<a name="ln2028">      }</a>
<a name="ln2029"> </a>
<a name="ln2030">      // Check if we loaded this language before.</a>
<a name="ln2031">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2032">        if (STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2033">          break;</a>
<a name="ln2034">        }</a>
<a name="ln2035">      }</a>
<a name="ln2036">    }</a>
<a name="ln2037"> </a>
<a name="ln2038">    if (region != NULL) {</a>
<a name="ln2039">      // If the region differs from what was used before then don't</a>
<a name="ln2040">      // use it for 'spellfile'.</a>
<a name="ln2041">      if (use_region != NULL &amp;&amp; strcmp(region, use_region) != 0) {</a>
<a name="ln2042">        dont_use_region = true;</a>
<a name="ln2043">      }</a>
<a name="ln2044">      use_region = region;</a>
<a name="ln2045">    }</a>
<a name="ln2046"> </a>
<a name="ln2047">    // If not found try loading the language now.</a>
<a name="ln2048">    if (slang == NULL) {</a>
<a name="ln2049">      if (filename) {</a>
<a name="ln2050">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2051">      } else {</a>
<a name="ln2052">        spell_load_lang(lang);</a>
<a name="ln2053">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2054">        // destroying the buffer we are using or closing the window.</a>
<a name="ln2055">        if (!bufref_valid(&amp;bufref) || !win_valid_any_tab(wp)) {</a>
<a name="ln2056">          ret_msg = N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2057">          goto theend;</a>
<a name="ln2058">        }</a>
<a name="ln2059">      }</a>
<a name="ln2060">    }</a>
<a name="ln2061"> </a>
<a name="ln2062">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2063">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2064">      if (filename</a>
<a name="ln2065">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2066">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2067">        region_mask = REGION_ALL;</a>
<a name="ln2068">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2069">          // find region in sl_regions</a>
<a name="ln2070">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2071">          if (c == REGION_ALL) {</a>
<a name="ln2072">            if (slang-&gt;sl_add) {</a>
<a name="ln2073">              if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2074">                // This addition file is for other regions.</a>
<a name="ln2075">                region_mask = 0;</a>
<a name="ln2076">              }</a>
<a name="ln2077">            } else {</a>
<a name="ln2078">              // This is probably an error.  Give a warning and</a>
<a name="ln2079">              // accept the words anyway.</a>
<a name="ln2080">              smsg(0, _(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2081">                   region);</a>
<a name="ln2082">            }</a>
<a name="ln2083">          } else {</a>
<a name="ln2084">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2085">          }</a>
<a name="ln2086">        }</a>
<a name="ln2087"> </a>
<a name="ln2088">        if (region_mask != 0) {</a>
<a name="ln2089">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2090">          p_-&gt;lp_slang = slang;</a>
<a name="ln2091">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2092"> </a>
<a name="ln2093">          use_midword(slang, wp);</a>
<a name="ln2094">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln2095">            nobreak = true;</a>
<a name="ln2096">          }</a>
<a name="ln2097">        }</a>
<a name="ln2098">      }</a>
<a name="ln2099">    }</a>
<a name="ln2100">  }</a>
<a name="ln2101"> </a>
<a name="ln2102">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2103">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2104">  // round 2: load second name in 'spellfile.</a>
<a name="ln2105">  // etc.</a>
<a name="ln2106">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2107">  for (round = 0; round == 0 || *spf != NUL; round++) {</a>
<a name="ln2108">    if (round == 0) {</a>
<a name="ln2109">      // Internal wordlist, if there is one.</a>
<a name="ln2110">      if (int_wordlist == NULL) {</a>
<a name="ln2111">        continue;</a>
<a name="ln2112">      }</a>
<a name="ln2113">      int_wordlist_spl(spf_name);</a>
<a name="ln2114">    } else {</a>
<a name="ln2115">      // One entry in 'spellfile'.</a>
<a name="ln2116">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2117">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2118"> </a>
<a name="ln2119">      // If it was already found above then skip it.</a>
<a name="ln2120">      for (c = 0; c &lt; ga.ga_len; c++) {</a>
<a name="ln2121">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2122">        if (p != NULL</a>
<a name="ln2123">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2124">          break;</a>
<a name="ln2125">        }</a>
<a name="ln2126">      }</a>
<a name="ln2127">      if (c &lt; ga.ga_len) {</a>
<a name="ln2128">        continue;</a>
<a name="ln2129">      }</a>
<a name="ln2130">    }</a>
<a name="ln2131"> </a>
<a name="ln2132">    // Check if it was loaded already.</a>
<a name="ln2133">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2134">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2135">          == kEqualFiles) {</a>
<a name="ln2136">        break;</a>
<a name="ln2137">      }</a>
<a name="ln2138">    }</a>
<a name="ln2139">    if (slang == NULL) {</a>
<a name="ln2140">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2141">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2142">      // use an arbitrary name.</a>
<a name="ln2143">      if (round == 0) {</a>
<a name="ln2144">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2145">      } else {</a>
<a name="ln2146">        xstrlcpy(lang, path_tail(spf_name), MAXWLEN + 1);</a>
<a name="ln2147">        p = vim_strchr(lang, '.');</a>
<a name="ln2148">        if (p != NULL) {</a>
<a name="ln2149">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2150">        }</a>
<a name="ln2151">      }</a>
<a name="ln2152">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2153"> </a>
<a name="ln2154">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2155">      // files also have this.</a>
<a name="ln2156">      if (slang != NULL &amp;&amp; nobreak) {</a>
<a name="ln2157">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2158">      }</a>
<a name="ln2159">    }</a>
<a name="ln2160">    if (slang != NULL) {</a>
<a name="ln2161">      region_mask = REGION_ALL;</a>
<a name="ln2162">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2163">        // find region in sl_regions</a>
<a name="ln2164">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2165">        if (c != REGION_ALL) {</a>
<a name="ln2166">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2167">        } else if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2168">          // This spell file is for other regions.</a>
<a name="ln2169">          region_mask = 0;</a>
<a name="ln2170">        }</a>
<a name="ln2171">      }</a>
<a name="ln2172"> </a>
<a name="ln2173">      if (region_mask != 0) {</a>
<a name="ln2174">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2175">        p_-&gt;lp_slang = slang;</a>
<a name="ln2176">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2177">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2178">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2179"> </a>
<a name="ln2180">        use_midword(slang, wp);</a>
<a name="ln2181">      }</a>
<a name="ln2182">    }</a>
<a name="ln2183">  }</a>
<a name="ln2184"> </a>
<a name="ln2185">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2186">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2187">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2188"> </a>
<a name="ln2189">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2190">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2191">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2192">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln2193">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2194"> </a>
<a name="ln2195">    // sound folding</a>
<a name="ln2196">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2197">      // language does sound folding itself</a>
<a name="ln2198">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2199">    } else {</a>
<a name="ln2200">      // find first similar language that does sound folding</a>
<a name="ln2201">      for (int j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2202">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2203">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2204">            &amp;&amp; strncmp(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2205">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2206">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2207">          break;</a>
<a name="ln2208">        }</a>
<a name="ln2209">      }</a>
<a name="ln2210">    }</a>
<a name="ln2211"> </a>
<a name="ln2212">    // REP items</a>
<a name="ln2213">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep)) {</a>
<a name="ln2214">      // language has REP items itself</a>
<a name="ln2215">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2216">    } else {</a>
<a name="ln2217">      // find first similar language that has REP items</a>
<a name="ln2218">      for (int j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2219">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2220">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2221">            &amp;&amp; strncmp(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2222">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2223">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2224">          break;</a>
<a name="ln2225">        }</a>
<a name="ln2226">      }</a>
<a name="ln2227">    }</a>
<a name="ln2228">  }</a>
<a name="ln2229">  redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln2230"> </a>
<a name="ln2231">theend:</a>
<a name="ln2232">  xfree(spl_copy);</a>
<a name="ln2233">  recursive = false;</a>
<a name="ln2234">  return ret_msg;</a>
<a name="ln2235">}</a>
<a name="ln2236"> </a>
<a name="ln2237">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2238">static void clear_midword(win_T *wp)</a>
<a name="ln2239">{</a>
<a name="ln2240">  CLEAR_FIELD(wp-&gt;w_s-&gt;b_spell_ismw);</a>
<a name="ln2241">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2242">}</a>
<a name="ln2243"> </a>
<a name="ln2244">/// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2245">/// They add up to any currently used midword characters.</a>
<a name="ln2246">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2247">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2248">{</a>
<a name="ln2249">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2250">    return;</a>
<a name="ln2251">  }</a>
<a name="ln2252"> </a>
<a name="ln2253">  for (char *p = lp-&gt;sl_midword; *p != NUL;) {</a>
<a name="ln2254">    const int c = utf_ptr2char(p);</a>
<a name="ln2255">    const int l = utfc_ptr2len(p);</a>
<a name="ln2256">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2257">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2258">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2259">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2260">      wp-&gt;w_s-&gt;b_spell_ismw_mb = xmemdupz(p, (size_t)l);</a>
<a name="ln2261">    } else {</a>
<a name="ln2262">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2263">      const int n = (int)strlen(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2264">      char *bp = xstrnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, (size_t)n + (size_t)l);</a>
<a name="ln2265">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2266">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2267">      xstrlcpy(bp + n, p, (size_t)l + 1);</a>
<a name="ln2268">    }</a>
<a name="ln2269">    p += l;</a>
<a name="ln2270">  }</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2274">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2275">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2276">static int find_region(const char *rp, const char *region)</a>
<a name="ln2277">{</a>
<a name="ln2278">  int i;</a>
<a name="ln2279"> </a>
<a name="ln2280">  for (i = 0;; i += 2) {</a>
<a name="ln2281">    if (rp[i] == NUL) {</a>
<a name="ln2282">      return REGION_ALL;</a>
<a name="ln2283">    }</a>
<a name="ln2284">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1]) {</a>
<a name="ln2285">      break;</a>
<a name="ln2286">    }</a>
<a name="ln2287">  }</a>
<a name="ln2288">  return i / 2;</a>
<a name="ln2289">}</a>
<a name="ln2290"> </a>
<a name="ln2291">/// Return case type of word:</a>
<a name="ln2292">/// w word       0</a>
<a name="ln2293">/// Word         WF_ONECAP</a>
<a name="ln2294">/// W WORD       WF_ALLCAP</a>
<a name="ln2295">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2296">///</a>
<a name="ln2297">/// @param[in]  word</a>
<a name="ln2298">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2299">///</a>
<a name="ln2300">/// @returns  Case type of word</a>
<a name="ln2301">int captype(const char *word, const char *end)</a>
<a name="ln2302">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2303">{</a>
<a name="ln2304">  const char *p;</a>
<a name="ln2305"> </a>
<a name="ln2306">  // find first letter</a>
<a name="ln2307">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2308">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2309">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2310">    }</a>
<a name="ln2311">  }</a>
<a name="ln2312">  int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln2313">  bool allcap;</a>
<a name="ln2314">  bool firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2315">  bool past_second = false;              // past second word char</a>
<a name="ln2316"> </a>
<a name="ln2317">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2318">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2319">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2320">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2321">      c = utf_ptr2char(p);</a>
<a name="ln2322">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2323">        // UUl -&gt; KEEPCAP</a>
<a name="ln2324">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2325">          return WF_KEEPCAP;</a>
<a name="ln2326">        }</a>
<a name="ln2327">        allcap = false;</a>
<a name="ln2328">      } else if (!allcap) {</a>
<a name="ln2329">        // UlU -&gt; KEEPCAP</a>
<a name="ln2330">        return WF_KEEPCAP;</a>
<a name="ln2331">      }</a>
<a name="ln2332">      past_second = true;</a>
<a name="ln2333">    }</a>
<a name="ln2334">  }</a>
<a name="ln2335"> </a>
<a name="ln2336">  if (allcap) {</a>
<a name="ln2337">    return WF_ALLCAP;</a>
<a name="ln2338">  }</a>
<a name="ln2339">  if (firstcap) {</a>
<a name="ln2340">    return WF_ONECAP;</a>
<a name="ln2341">  }</a>
<a name="ln2342">  return 0;</a>
<a name="ln2343">}</a>
<a name="ln2344"> </a>
<a name="ln2345">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2346">void spell_delete_wordlist(void)</a>
<a name="ln2347">{</a>
<a name="ln2348">  if (int_wordlist == NULL) {</a>
<a name="ln2349">    return;</a>
<a name="ln2350">  }</a>
<a name="ln2351"> </a>
<a name="ln2352">  char fname[MAXPATHL] = { 0 };</a>
<a name="ln2353">  os_remove(int_wordlist);</a>
<a name="ln2354">  int_wordlist_spl(fname);</a>
<a name="ln2355">  os_remove(fname);</a>
<a name="ln2356">  XFREE_CLEAR(int_wordlist);</a>
<a name="ln2357">}</a>
<a name="ln2358"> </a>
<a name="ln2359">// Free all languages.</a>
<a name="ln2360">void spell_free_all(void)</a>
<a name="ln2361">{</a>
<a name="ln2362">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2363">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2364">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2365">  }</a>
<a name="ln2366"> </a>
<a name="ln2367">  while (first_lang != NULL) {</a>
<a name="ln2368">    slang_T *slang = first_lang;</a>
<a name="ln2369">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2370">    slang_free(slang);</a>
<a name="ln2371">  }</a>
<a name="ln2372"> </a>
<a name="ln2373">  spell_delete_wordlist();</a>
<a name="ln2374"> </a>
<a name="ln2375">  XFREE_CLEAR(repl_to);</a>
<a name="ln2376">  XFREE_CLEAR(repl_from);</a>
<a name="ln2377">}</a>
<a name="ln2378"> </a>
<a name="ln2379">// Clear all spelling tables and reload them.</a>
<a name="ln2380">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2381">void spell_reload(void)</a>
<a name="ln2382">{</a>
<a name="ln2383">  // Initialize the table for spell_iswordp().</a>
<a name="ln2384">  init_spell_chartab();</a>
<a name="ln2385"> </a>
<a name="ln2386">  // Unload all allocated memory.</a>
<a name="ln2387">  spell_free_all();</a>
<a name="ln2388"> </a>
<a name="ln2389">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2390">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2391">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2392">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2393">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2394">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2395">        (void)parse_spelllang(wp);</a>
<a name="ln2396">        break;</a>
<a name="ln2397">      }</a>
<a name="ln2398">    }</a>
<a name="ln2399">  }</a>
<a name="ln2400">}</a>
<a name="ln2401"> </a>
<a name="ln2402">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2403">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2404">// use.</a>
<a name="ln2405">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2406">// NULL and there is no undo info.</a>
<a name="ln2407">buf_T *open_spellbuf(void)</a>
<a name="ln2408">{</a>
<a name="ln2409">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2410"> </a>
<a name="ln2411">  buf-&gt;b_spell = true;</a>
<a name="ln2412">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2413">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2414">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2415">  }</a>
<a name="ln2416">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2417"> </a>
<a name="ln2418">  return buf;</a>
<a name="ln2419">}</a>
<a name="ln2420"> </a>
<a name="ln2421">// Close the buffer used for spell info.</a>
<a name="ln2422">void close_spellbuf(buf_T *buf)</a>
<a name="ln2423">{</a>
<a name="ln2424">  if (buf == NULL) {</a>
<a name="ln2425">    return;</a>
<a name="ln2426">  }</a>
<a name="ln2427"> </a>
<a name="ln2428">  ml_close(buf, true);</a>
<a name="ln2429">  xfree(buf);</a>
<a name="ln2430">}</a>
<a name="ln2431"> </a>
<a name="ln2432">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2433">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2434">{</a>
<a name="ln2435">  // Init everything to false (zero).</a>
<a name="ln2436">  CLEAR_FIELD(sp-&gt;st_isw);</a>
<a name="ln2437">  CLEAR_FIELD(sp-&gt;st_isu);</a>
<a name="ln2438"> </a>
<a name="ln2439">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln2440">    sp-&gt;st_fold[i] = (uint8_t)i;</a>
<a name="ln2441">    sp-&gt;st_upper[i] = (uint8_t)i;</a>
<a name="ln2442">  }</a>
<a name="ln2443"> </a>
<a name="ln2444">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2445">  // that is done separately.</a>
<a name="ln2446">  for (int i = '0'; i &lt;= '9'; i++) {</a>
<a name="ln2447">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2448">  }</a>
<a name="ln2449">  for (int i = 'A'; i &lt;= 'Z'; i++) {</a>
<a name="ln2450">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2451">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2452">    sp-&gt;st_fold[i] = (uint8_t)(i + 0x20);</a>
<a name="ln2453">  }</a>
<a name="ln2454">  for (int i = 'a'; i &lt;= 'z'; i++) {</a>
<a name="ln2455">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2456">    sp-&gt;st_upper[i] = (uint8_t)(i - 0x20);</a>
<a name="ln2457">  }</a>
<a name="ln2458">}</a>
<a name="ln2459"> </a>
<a name="ln2460">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2461">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2462">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2463">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2464">void init_spell_chartab(void)</a>
<a name="ln2465">{</a>
<a name="ln2466">  did_set_spelltab = false;</a>
<a name="ln2467">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2468">  for (int i = 128; i &lt; 256; i++) {</a>
<a name="ln2469">    int f = utf_fold(i);</a>
<a name="ln2470">    int u = mb_toupper(i);</a>
<a name="ln2471"> </a>
<a name="ln2472">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2473">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2474">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2475">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2476">    // value for utf-8 to avoid this.</a>
<a name="ln2477">    spelltab.st_fold[i] = (f &lt; 256) ? (uint8_t)f : (uint8_t)i;</a>
<a name="ln2478">    spelltab.st_upper[i] = (u &lt; 256) ? (uint8_t)u : (uint8_t)i;</a>
<a name="ln2479">  }</a>
<a name="ln2480">}</a>
<a name="ln2481"> </a>
<a name="ln2482">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2483">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2484">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2485">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2486">///</a>
<a name="ln2487">/// @param wp Buffer used.</a>
<a name="ln2488">bool spell_iswordp(const char *p, const win_T *wp)</a>
<a name="ln2489">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2490">{</a>
<a name="ln2491">  const int l = utfc_ptr2len(p);</a>
<a name="ln2492">  const char *s = p;</a>
<a name="ln2493">  if (l == 1) {</a>
<a name="ln2494">    // be quick for ASCII</a>
<a name="ln2495">    if (wp-&gt;w_s-&gt;b_spell_ismw[(uint8_t)(*p)]) {</a>
<a name="ln2496">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2497">    }</a>
<a name="ln2498">  } else {</a>
<a name="ln2499">    int c = utf_ptr2char(p);</a>
<a name="ln2500">    if (c &lt; 256</a>
<a name="ln2501">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2502">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2503">           &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2504">      s = p + l;</a>
<a name="ln2505">    }</a>
<a name="ln2506">  }</a>
<a name="ln2507"> </a>
<a name="ln2508">  int c = utf_ptr2char(s);</a>
<a name="ln2509">  if (c &gt; 255) {</a>
<a name="ln2510">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2511">  }</a>
<a name="ln2512">  return spelltab.st_isw[c];</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2516">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2517">bool spell_iswordp_nmw(const char *p, win_T *wp)</a>
<a name="ln2518">{</a>
<a name="ln2519">  int c = utf_ptr2char(p);</a>
<a name="ln2520">  if (c &gt; 255) {</a>
<a name="ln2521">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2522">  }</a>
<a name="ln2523">  return spelltab.st_isw[c];</a>
<a name="ln2524">}</a>
<a name="ln2525"> </a>
<a name="ln2526">// Returns true if word class indicates a word character.</a>
<a name="ln2527">// Only for characters above 255.</a>
<a name="ln2528">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2529">// See also utf_class() in mbyte.c.</a>
<a name="ln2530">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2531">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2532">{</a>
<a name="ln2533">  if (wp-&gt;w_s-&gt;b_cjk) {</a>
<a name="ln2534">    // East Asian characters are not considered word characters.</a>
<a name="ln2535">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2536">  }</a>
<a name="ln2537">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2541">// Wide version of spell_iswordp().</a>
<a name="ln2542">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2543">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2544">{</a>
<a name="ln2545">  const int *s;</a>
<a name="ln2546"> </a>
<a name="ln2547">  if (*p &lt;</a>
<a name="ln2548">      256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p] : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2549">                                         &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb,</a>
<a name="ln2550">                                                       *p) != NULL)) {</a>
<a name="ln2551">    s = p + 1;</a>
<a name="ln2552">  } else {</a>
<a name="ln2553">    s = p;</a>
<a name="ln2554">  }</a>
<a name="ln2555"> </a>
<a name="ln2556">  if (*s &gt; 255) {</a>
<a name="ln2557">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2558">  }</a>
<a name="ln2559">  return spelltab.st_isw[*s];</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2563">// Uses the character definitions from the .spl file.</a>
<a name="ln2564">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2565">// Returns FAIL when something wrong.</a>
<a name="ln2566">int spell_casefold(const win_T *wp, const char *str, int len, char *buf, int buflen)</a>
<a name="ln2567">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2568">{</a>
<a name="ln2569">  if (len &gt;= buflen) {</a>
<a name="ln2570">    buf[0] = NUL;</a>
<a name="ln2571">    return FAIL;                // result will not fit</a>
<a name="ln2572">  }</a>
<a name="ln2573"> </a>
<a name="ln2574">  int outi = 0;</a>
<a name="ln2575"> </a>
<a name="ln2576">  // Fold one character at a time.</a>
<a name="ln2577">  for (const char *p = str; p &lt; str + len;) {</a>
<a name="ln2578">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2579">      buf[outi] = NUL;</a>
<a name="ln2580">      return FAIL;</a>
<a name="ln2581">    }</a>
<a name="ln2582">    int c = mb_cptr2char_adv(&amp;p);</a>
<a name="ln2583"> </a>
<a name="ln2584">    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except</a>
<a name="ln2585">    // when it is the last character in a word, then it folds to</a>
<a name="ln2586">    // 0x03C2.</a>
<a name="ln2587">    if (c == 0x03a3 || c == 0x03c2) {</a>
<a name="ln2588">      if (p == str + len || !spell_iswordp(p, wp)) {</a>
<a name="ln2589">        c = 0x03c2;</a>
<a name="ln2590">      } else {</a>
<a name="ln2591">        c = 0x03c3;</a>
<a name="ln2592">      }</a>
<a name="ln2593">    } else {</a>
<a name="ln2594">      c = SPELL_TOFOLD(c);</a>
<a name="ln2595">    }</a>
<a name="ln2596"> </a>
<a name="ln2597">    outi += utf_char2bytes(c, buf + outi);</a>
<a name="ln2598">  }</a>
<a name="ln2599">  buf[outi] = NUL;</a>
<a name="ln2600"> </a>
<a name="ln2601">  return OK;</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln2605">// capital.  This uses 'spellcapcheck' of the buffer in window &quot;wp&quot;.</a>
<a name="ln2606">bool check_need_cap(win_T *wp, linenr_T lnum, colnr_T col)</a>
<a name="ln2607">{</a>
<a name="ln2608">  if (wp-&gt;w_s-&gt;b_cap_prog == NULL) {</a>
<a name="ln2609">    return false;</a>
<a name="ln2610">  }</a>
<a name="ln2611"> </a>
<a name="ln2612">  bool need_cap = false;</a>
<a name="ln2613">  char *line = col ? ml_get_buf(wp-&gt;w_buffer, lnum) : NULL;</a>
<a name="ln2614">  char *line_copy = NULL;</a>
<a name="ln2615">  colnr_T endcol = 0;</a>
<a name="ln2616">  if (col == 0 || getwhitecols(line) &gt;= col) {</a>
<a name="ln2617">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln2618">    // ends there.</a>
<a name="ln2619">    if (lnum == 1) {</a>
<a name="ln2620">      need_cap = true;</a>
<a name="ln2621">    } else {</a>
<a name="ln2622">      line = ml_get_buf(wp-&gt;w_buffer, lnum - 1);</a>
<a name="ln2623">      if (*skipwhite(line) == NUL) {</a>
<a name="ln2624">        need_cap = true;</a>
<a name="ln2625">      } else {</a>
<a name="ln2626">        // Append a space in place of the line break.</a>
<a name="ln2627">        line_copy = concat_str(line, &quot; &quot;);</a>
<a name="ln2628">        line = line_copy;</a>
<a name="ln2629">        endcol = (colnr_T)strlen(line);</a>
<a name="ln2630">      }</a>
<a name="ln2631">    }</a>
<a name="ln2632">  } else {</a>
<a name="ln2633">    endcol = col;</a>
<a name="ln2634">  }</a>
<a name="ln2635"> </a>
<a name="ln2636">  if (endcol &gt; 0) {</a>
<a name="ln2637">    // Check if sentence ends before the bad word.</a>
<a name="ln2638">    regmatch_T regmatch = {</a>
<a name="ln2639">      .regprog = wp-&gt;w_s-&gt;b_cap_prog,</a>
<a name="ln2640">      .rm_ic = false</a>
<a name="ln2641">    };</a>
<a name="ln2642">    char *p = line + endcol;</a>
<a name="ln2643">    while (true) {</a>
<a name="ln2644">      MB_PTR_BACK(line, p);</a>
<a name="ln2645">      if (p == line || spell_iswordp_nmw(p, wp)) {</a>
<a name="ln2646">        break;</a>
<a name="ln2647">      }</a>
<a name="ln2648">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln2649">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln2650">        need_cap = true;</a>
<a name="ln2651">        break;</a>
<a name="ln2652">      }</a>
<a name="ln2653">    }</a>
<a name="ln2654">    wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln2655">  }</a>
<a name="ln2656"> </a>
<a name="ln2657">  xfree(line_copy);</a>
<a name="ln2658"> </a>
<a name="ln2659">  return need_cap;</a>
<a name="ln2660">}</a>
<a name="ln2661"> </a>
<a name="ln2662">// &quot;:spellrepall&quot;</a>
<a name="ln2663">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln2664">{</a>
<a name="ln2665">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln2666">  bool save_ws = p_ws;</a>
<a name="ln2667">  linenr_T prev_lnum = 0;</a>
<a name="ln2668"> </a>
<a name="ln2669">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln2670">    emsg(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln2671">    return;</a>
<a name="ln2672">  }</a>
<a name="ln2673">  const size_t repl_from_len = strlen(repl_from);</a>
<a name="ln2674">  const size_t repl_to_len = strlen(repl_to);</a>
<a name="ln2675">  const int addlen = (int)(repl_to_len - repl_from_len);</a>
<a name="ln2676"> </a>
<a name="ln2677">  const size_t frompatlen = repl_from_len + 7;</a>
<a name="ln2678">  char *frompat = xmalloc(frompatlen);</a>
<a name="ln2679">  snprintf(frompat, frompatlen, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln2680">  p_ws = false;</a>
<a name="ln2681"> </a>
<a name="ln2682">  sub_nsubs = 0;</a>
<a name="ln2683">  sub_nlines = 0;</a>
<a name="ln2684">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln2685">  while (!got_int) {</a>
<a name="ln2686">    if (do_search(NULL, '/', '/', frompat, 1, SEARCH_KEEP, NULL) == 0</a>
<a name="ln2687">        || u_save_cursor() == FAIL) {</a>
<a name="ln2688">      break;</a>
<a name="ln2689">    }</a>
<a name="ln2690"> </a>
<a name="ln2691">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln2692">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln2693">    char *line = get_cursor_line_ptr();</a>
<a name="ln2694">    if (addlen &lt;= 0</a>
<a name="ln2695">        || strncmp(line + curwin-&gt;w_cursor.col, repl_to, repl_to_len) != 0) {</a>
<a name="ln2696">      char *p = xmalloc(strlen(line) + (size_t)addlen + 1);</a>
<a name="ln2697">      memmove(p, line, (size_t)curwin-&gt;w_cursor.col);</a>
<a name="ln2698">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln2699">      STRCAT(p, line + curwin-&gt;w_cursor.col + repl_from_len);</a>
<a name="ln2700">      ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln2701">      inserted_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln2702">                     (int)repl_from_len, (int)repl_to_len);</a>
<a name="ln2703"> </a>
<a name="ln2704">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln2705">        sub_nlines++;</a>
<a name="ln2706">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2707">      }</a>
<a name="ln2708">      sub_nsubs++;</a>
<a name="ln2709">    }</a>
<a name="ln2710">    curwin-&gt;w_cursor.col += (colnr_T)repl_to_len;</a>
<a name="ln2711">  }</a>
<a name="ln2712"> </a>
<a name="ln2713">  p_ws = save_ws;</a>
<a name="ln2714">  curwin-&gt;w_cursor = pos;</a>
<a name="ln2715">  xfree(frompat);</a>
<a name="ln2716"> </a>
<a name="ln2717">  if (sub_nsubs == 0) {</a>
<a name="ln2718">    semsg(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln2719">  } else {</a>
<a name="ln2720">    do_sub_msg(false);</a>
<a name="ln2721">  }</a>
<a name="ln2722">}</a>
<a name="ln2723"> </a>
<a name="ln2724">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln2725">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln2726">/// The result is NUL terminated.</a>
<a name="ln2727">///</a>
<a name="ln2728">/// @param[in]  word  source string to copy</a>
<a name="ln2729">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln2730">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln2731">void onecap_copy(const char *word, char *wcopy, bool upper)</a>
<a name="ln2732">{</a>
<a name="ln2733">  const char *p = word;</a>
<a name="ln2734">  int c = mb_cptr2char_adv(&amp;p);</a>
<a name="ln2735">  if (upper) {</a>
<a name="ln2736">    c = SPELL_TOUPPER(c);</a>
<a name="ln2737">  } else {</a>
<a name="ln2738">    c = SPELL_TOFOLD(c);</a>
<a name="ln2739">  }</a>
<a name="ln2740">  int l = utf_char2bytes(c, wcopy);</a>
<a name="ln2741">  xstrlcpy(wcopy + l, p, (size_t)(MAXWLEN - l));</a>
<a name="ln2742">}</a>
<a name="ln2743"> </a>
<a name="ln2744">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln2745">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln2746">void allcap_copy(const char *word, char *wcopy)</a>
<a name="ln2747">{</a>
<a name="ln2748">  char *d = wcopy;</a>
<a name="ln2749">  for (const char *s = word; *s != NUL;) {</a>
<a name="ln2750">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (c == 0xdf) {</a>
<a name="ln2753">      c = 'S';</a>
<a name="ln2754">      if (d - wcopy &gt;= MAXWLEN - 1) {</a>
<a name="ln2755">        break;</a>
<a name="ln2756">      }</a>
<a name="ln2757">      *d++ = (char)c;</a>
<a name="ln2758">    } else {</a>
<a name="ln2759">      c = SPELL_TOUPPER(c);</a>
<a name="ln2760">    }</a>
<a name="ln2761"> </a>
<a name="ln2762">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln2763">      break;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    d += utf_char2bytes(c, d);</a>
<a name="ln2766">  }</a>
<a name="ln2767">  *d = NUL;</a>
<a name="ln2768">}</a>
<a name="ln2769"> </a>
<a name="ln2770">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln2771">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln2772">int nofold_len(char *fword, int flen, char *word)</a>
<a name="ln2773">{</a>
<a name="ln2774">  char *p;</a>
<a name="ln2775">  int i = 0;</a>
<a name="ln2776"> </a>
<a name="ln2777">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln2778">    i++;</a>
<a name="ln2779">  }</a>
<a name="ln2780">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln2781">    i--;</a>
<a name="ln2782">  }</a>
<a name="ln2783">  return (int)(p - word);</a>
<a name="ln2784">}</a>
<a name="ln2785"> </a>
<a name="ln2786">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln2787">void make_case_word(char *fword, char *cword, int flags)</a>
<a name="ln2788">{</a>
<a name="ln2789">  if (flags &amp; WF_ALLCAP) {</a>
<a name="ln2790">    // Make it all upper-case</a>
<a name="ln2791">    allcap_copy(fword, cword);</a>
<a name="ln2792">  } else if (flags &amp; WF_ONECAP) {</a>
<a name="ln2793">    // Make the first letter upper-case</a>
<a name="ln2794">    onecap_copy(fword, cword, true);</a>
<a name="ln2795">  } else {</a>
<a name="ln2796">    // Use goodword as-is.</a>
<a name="ln2797">    STRCPY(cword, fword);</a>
<a name="ln2798">  }</a>
<a name="ln2799">}</a>
<a name="ln2800"> </a>
<a name="ln2801">/// Soundfold a string, for soundfold()</a>
<a name="ln2802">///</a>
<a name="ln2803">/// @param[in]  word  Word to soundfold.</a>
<a name="ln2804">///</a>
<a name="ln2805">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln2806">///                     copy of the input string if soundfolding is not</a>
<a name="ln2807">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln2808">char *eval_soundfold(const char *const word)</a>
<a name="ln2809">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2810">{</a>
<a name="ln2811">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2812">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln2813">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2814">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2815">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2816">        // soundfold the word</a>
<a name="ln2817">        char sound[MAXWLEN];</a>
<a name="ln2818">        spell_soundfold(lp-&gt;lp_slang, (char *)word, false, sound);</a>
<a name="ln2819">        return xstrdup(sound);</a>
<a name="ln2820">      }</a>
<a name="ln2821">    }</a>
<a name="ln2822">  }</a>
<a name="ln2823"> </a>
<a name="ln2824">  // No language with sound folding, return word as-is.</a>
<a name="ln2825">  return xstrdup(word);</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln2829">///</a>
<a name="ln2830">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln2831">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln2832">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln2833">/// Erikson.</a>
<a name="ln2834">///</a>
<a name="ln2835">/// We support two methods:</a>
<a name="ln2836">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln2837">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln2838">///</a>
<a name="ln2839">/// @param[in]  slang</a>
<a name="ln2840">/// @param[in]  inword  word to soundfold</a>
<a name="ln2841">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln2842">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln2843">void spell_soundfold(slang_T *slang, char *inword, bool folded, char *res)</a>
<a name="ln2844">{</a>
<a name="ln2845">  if (slang-&gt;sl_sofo) {</a>
<a name="ln2846">    // SOFOFROM and SOFOTO used</a>
<a name="ln2847">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln2848">  } else {</a>
<a name="ln2849">    char fword[MAXWLEN];</a>
<a name="ln2850">    char *word;</a>
<a name="ln2851">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln2852">    if (folded) {</a>
<a name="ln2853">      word = inword;</a>
<a name="ln2854">    } else {</a>
<a name="ln2855">      (void)spell_casefold(curwin, inword, (int)strlen(inword), fword, MAXWLEN);</a>
<a name="ln2856">      word = fword;</a>
<a name="ln2857">    }</a>
<a name="ln2858"> </a>
<a name="ln2859">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln2860">  }</a>
<a name="ln2861">}</a>
<a name="ln2862"> </a>
<a name="ln2863">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln2864">// SOFOTO lines.</a>
<a name="ln2865">static void spell_soundfold_sofo(slang_T *slang, const char *inword, char *res)</a>
<a name="ln2866">{</a>
<a name="ln2867">  int ri = 0;</a>
<a name="ln2868"> </a>
<a name="ln2869">  int prevc = 0;</a>
<a name="ln2870"> </a>
<a name="ln2871">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln2872">  // 255, sl_sal the rest.</a>
<a name="ln2873">  for (const char *s = inword; *s != NUL;) {</a>
<a name="ln2874">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2875">    if (utf_class(c) == 0) {</a>
<a name="ln2876">      c = ' ';</a>
<a name="ln2877">    } else if (c &lt; 256) {</a>
<a name="ln2878">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln2879">    } else {</a>
<a name="ln2880">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln2881">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln2882">        c = NUL;</a>
<a name="ln2883">      } else {</a>
<a name="ln2884">        while (true) {                // find &quot;c&quot; in the list</a>
<a name="ln2885">          if (*ip == 0) {             // not found</a>
<a name="ln2886">            c = NUL;</a>
<a name="ln2887">            break;</a>
<a name="ln2888">          }</a>
<a name="ln2889">          if (*ip == c) {             // match!</a>
<a name="ln2890">            c = ip[1];</a>
<a name="ln2891">            break;</a>
<a name="ln2892">          }</a>
<a name="ln2893">          ip += 2;</a>
<a name="ln2894">        }</a>
<a name="ln2895">      }</a>
<a name="ln2896">    }</a>
<a name="ln2897"> </a>
<a name="ln2898">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln2899">      ri += utf_char2bytes(c, res + ri);</a>
<a name="ln2900">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln2901">        break;</a>
<a name="ln2902">      }</a>
<a name="ln2903">      prevc = c;</a>
<a name="ln2904">    }</a>
<a name="ln2905">  }</a>
<a name="ln2906"> </a>
<a name="ln2907">  res[ri] = NUL;</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln2911">// Multi-byte version of spell_soundfold().</a>
<a name="ln2912">static void spell_soundfold_wsal(slang_T *slang, const char *inword, char *res)</a>
<a name="ln2913">{</a>
<a name="ln2914">  salitem_T *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln2915">  int word[MAXWLEN] = { 0 };</a>
<a name="ln2916">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln2917">  int *ws;</a>
<a name="ln2918">  int *pf;</a>
<a name="ln2919">  int j, z;</a>
<a name="ln2920">  int reslen;</a>
<a name="ln2921">  int k = 0;</a>
<a name="ln2922">  int k0;</a>
<a name="ln2923">  int n0;</a>
<a name="ln2924">  int pri;</a>
<a name="ln2925">  int p0 = -333;</a>
<a name="ln2926">  int c0;</a>
<a name="ln2927">  bool did_white = false;</a>
<a name="ln2928"> </a>
<a name="ln2929">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln2930">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln2931">  // But keep white space.</a>
<a name="ln2932">  int wordlen = 0;</a>
<a name="ln2933">  for (const char *s = inword; *s != NUL;) {</a>
<a name="ln2934">    const char *t = s;</a>
<a name="ln2935">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2936">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln2937">      if (utf_class(c) == 0) {</a>
<a name="ln2938">        if (did_white) {</a>
<a name="ln2939">          continue;</a>
<a name="ln2940">        }</a>
<a name="ln2941">        c = ' ';</a>
<a name="ln2942">        did_white = true;</a>
<a name="ln2943">      } else {</a>
<a name="ln2944">        did_white = false;</a>
<a name="ln2945">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln2946">          continue;</a>
<a name="ln2947">        }</a>
<a name="ln2948">      }</a>
<a name="ln2949">    }</a>
<a name="ln2950">    word[wordlen++] = c;</a>
<a name="ln2951">  }</a>
<a name="ln2952">  word[wordlen] = NUL;</a>
<a name="ln2953"> </a>
<a name="ln2954">  int c;</a>
<a name="ln2955">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln2956">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln2957">  // Changed to keep spaces.</a>
<a name="ln2958">  int i = reslen = z = 0;</a>
<a name="ln2959">  while ((c = word[i]) != NUL) {</a>
<a name="ln2960">    // Start with the first rule that has the character in the word.</a>
<a name="ln2961">    int n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln2962">    int z0 = 0;</a>
<a name="ln2963"> </a>
<a name="ln2964">    if (n &gt;= 0) {</a>
<a name="ln2965">      // Check all rules for the same index byte.</a>
<a name="ln2966">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln2967">      // (c &amp; 0xff) is NUL.</a>
<a name="ln2968">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln2969">           &amp;&amp; ws[0] != NUL; n++) {</a>
<a name="ln2970">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln2971">        // entries are less than three chars, optimize for that.</a>
<a name="ln2972">        if (c != ws[0]) {</a>
<a name="ln2973">          continue;</a>
<a name="ln2974">        }</a>
<a name="ln2975">        k = smp[n].sm_leadlen;</a>
<a name="ln2976">        if (k &gt; 1) {</a>
<a name="ln2977">          if (word[i + 1] != ws[1]) {</a>
<a name="ln2978">            continue;</a>
<a name="ln2979">          }</a>
<a name="ln2980">          if (k &gt; 2) {</a>
<a name="ln2981">            for (j = 2; j &lt; k; j++) {</a>
<a name="ln2982">              if (word[i + j] != ws[j]) {</a>
<a name="ln2983">                break;</a>
<a name="ln2984">              }</a>
<a name="ln2985">            }</a>
<a name="ln2986">            if (j &lt; k) {</a>
<a name="ln2987">              continue;</a>
<a name="ln2988">            }</a>
<a name="ln2989">          }</a>
<a name="ln2990">        }</a>
<a name="ln2991"> </a>
<a name="ln2992">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln2993">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln2994">          while (*pf != NUL &amp;&amp; *pf != word[i + k]) {</a>
<a name="ln2995">            pf++;</a>
<a name="ln2996">          }</a>
<a name="ln2997">          if (*pf == NUL) {</a>
<a name="ln2998">            continue;</a>
<a name="ln2999">          }</a>
<a name="ln3000">          k++;</a>
<a name="ln3001">        }</a>
<a name="ln3002">        char *s = smp[n].sm_rules;</a>
<a name="ln3003">        pri = 5;            // default priority</a>
<a name="ln3004"> </a>
<a name="ln3005">        p0 = (uint8_t)(*s);</a>
<a name="ln3006">        k0 = k;</a>
<a name="ln3007">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln3008">          k--;</a>
<a name="ln3009">          s++;</a>
<a name="ln3010">        }</a>
<a name="ln3011">        if (*s == '&lt;') {</a>
<a name="ln3012">          s++;</a>
<a name="ln3013">        }</a>
<a name="ln3014">        if (ascii_isdigit(*s)) {</a>
<a name="ln3015">          // determine priority</a>
<a name="ln3016">          pri = (uint8_t)(*s) - '0';</a>
<a name="ln3017">          s++;</a>
<a name="ln3018">        }</a>
<a name="ln3019">        if (*s == '^' &amp;&amp; *(s + 1) == '^') {</a>
<a name="ln3020">          s++;</a>
<a name="ln3021">        }</a>
<a name="ln3022"> </a>
<a name="ln3023">        if (*s == NUL</a>
<a name="ln3024">            || (*s == '^'</a>
<a name="ln3025">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln3026">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln3027">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln3028">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln3029">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln3030">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln3031">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln3032">          // search for followup rules, if:</a>
<a name="ln3033">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln3034">          c0 = word[i + k - 1];</a>
<a name="ln3035">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln3036"> </a>
<a name="ln3037">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln3038">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln3039">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln3040">            // all entries with the same index byte.</a>
<a name="ln3041">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln3042">                 == (c0 &amp; 0xff); n0++) {</a>
<a name="ln3043">              // Quickly skip entries that don't match the word.</a>
<a name="ln3044">              if (c0 != ws[0]) {</a>
<a name="ln3045">                continue;</a>
<a name="ln3046">              }</a>
<a name="ln3047">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln3048">              if (k0 &gt; 1) {</a>
<a name="ln3049">                if (word[i + k] != ws[1]) {</a>
<a name="ln3050">                  continue;</a>
<a name="ln3051">                }</a>
<a name="ln3052">                if (k0 &gt; 2) {</a>
<a name="ln3053">                  pf = word + i + k + 1;</a>
<a name="ln3054">                  for (j = 2; j &lt; k0; j++) {</a>
<a name="ln3055">                    if (*pf++ != ws[j]) {</a>
<a name="ln3056">                      break;</a>
<a name="ln3057">                    }</a>
<a name="ln3058">                  }</a>
<a name="ln3059">                  if (j &lt; k0) {</a>
<a name="ln3060">                    continue;</a>
<a name="ln3061">                  }</a>
<a name="ln3062">                }</a>
<a name="ln3063">              }</a>
<a name="ln3064">              k0 += k - 1;</a>
<a name="ln3065"> </a>
<a name="ln3066">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln3067">                // Check for match with one of the chars in</a>
<a name="ln3068">                // &quot;sm_oneof&quot;.</a>
<a name="ln3069">                while (*pf != NUL &amp;&amp; *pf != word[i + k0]) {</a>
<a name="ln3070">                  pf++;</a>
<a name="ln3071">                }</a>
<a name="ln3072">                if (*pf == NUL) {</a>
<a name="ln3073">                  continue;</a>
<a name="ln3074">                }</a>
<a name="ln3075">                k0++;</a>
<a name="ln3076">              }</a>
<a name="ln3077"> </a>
<a name="ln3078">              p0 = 5;</a>
<a name="ln3079">              s = smp[n0].sm_rules;</a>
<a name="ln3080">              while (*s == '-') {</a>
<a name="ln3081">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln3082">                // &quot;if (k0 == k)&quot;</a>
<a name="ln3083">                s++;</a>
<a name="ln3084">              }</a>
<a name="ln3085">              if (*s == '&lt;') {</a>
<a name="ln3086">                s++;</a>
<a name="ln3087">              }</a>
<a name="ln3088">              if (ascii_isdigit(*s)) {</a>
<a name="ln3089">                p0 = (uint8_t)(*s) - '0';</a>
<a name="ln3090">                s++;</a>
<a name="ln3091">              }</a>
<a name="ln3092"> </a>
<a name="ln3093">              if (*s == NUL</a>
<a name="ln3094">                  // *s == '^' cuts</a>
<a name="ln3095">                  || (*s == '$'</a>
<a name="ln3096">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln3097">                                          curwin))) {</a>
<a name="ln3098">                if (k0 == k) {</a>
<a name="ln3099">                  // this is just a piece of the string</a>
<a name="ln3100">                  continue;</a>
<a name="ln3101">                }</a>
<a name="ln3102"> </a>
<a name="ln3103">                if (p0 &lt; pri) {</a>
<a name="ln3104">                  // priority too low</a>
<a name="ln3105">                  continue;</a>
<a name="ln3106">                }</a>
<a name="ln3107">                // rule fits; stop search</a>
<a name="ln3108">                break;</a>
<a name="ln3109">              }</a>
<a name="ln3110">            }</a>
<a name="ln3111"> </a>
<a name="ln3112">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln3113">                == (c0 &amp; 0xff)) {</a>
<a name="ln3114">              continue;</a>
<a name="ln3115">            }</a>
<a name="ln3116">          }</a>
<a name="ln3117"> </a>
<a name="ln3118">          // replace string</a>
<a name="ln3119">          ws = smp[n].sm_to_w;</a>
<a name="ln3120">          s = smp[n].sm_rules;</a>
<a name="ln3121">          p0 = (vim_strchr(s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln3122">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln3123">            // rule with '&lt;' is used</a>
<a name="ln3124">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln3125">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln3126">                    || wres[reslen - 1] == *ws)) {</a>
<a name="ln3127">              reslen--;</a>
<a name="ln3128">            }</a>
<a name="ln3129">            z0 = 1;</a>
<a name="ln3130">            z = 1;</a>
<a name="ln3131">            k0 = 0;</a>
<a name="ln3132">            if (ws != NULL) {</a>
<a name="ln3133">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln3134">                word[i + k0] = *ws;</a>
<a name="ln3135">                k0++;</a>
<a name="ln3136">                ws++;</a>
<a name="ln3137">              }</a>
<a name="ln3138">            }</a>
<a name="ln3139">            if (k &gt; k0) {</a>
<a name="ln3140">              memmove(word + i + k0, word + i + k, sizeof(int) * (size_t)(wordlen - (i + k) + 1));</a>
<a name="ln3141">            }</a>
<a name="ln3142"> </a>
<a name="ln3143">            // new &quot;actual letter&quot;</a>
<a name="ln3144">            c = word[i];</a>
<a name="ln3145">          } else {</a>
<a name="ln3146">            // no '&lt;' rule used</a>
<a name="ln3147">            i += k - 1;</a>
<a name="ln3148">            z = 0;</a>
<a name="ln3149">            if (ws != NULL) {</a>
<a name="ln3150">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln3151">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln3152">                if (reslen == 0 || wres[reslen - 1] != *ws) {</a>
<a name="ln3153">                  wres[reslen++] = *ws;</a>
<a name="ln3154">                }</a>
<a name="ln3155">                ws++;</a>
<a name="ln3156">              }</a>
<a name="ln3157">            }</a>
<a name="ln3158">            // new &quot;actual letter&quot;</a>
<a name="ln3159">            if (ws == NULL) {</a>
<a name="ln3160">              c = NUL;</a>
<a name="ln3161">            } else {</a>
<a name="ln3162">              c = *ws;</a>
<a name="ln3163">            }</a>
<a name="ln3164">            if (strstr(s, &quot;^^&quot;) != NULL) {</a>
<a name="ln3165">              if (c != NUL) {</a>
<a name="ln3166">                wres[reslen++] = c;</a>
<a name="ln3167">              }</a>
<a name="ln3168">              memmove(word, word + i + 1, sizeof(int) * (size_t)(wordlen - (i + 1) + 1));</a>
<a name="ln3169">              i = 0;</a>
<a name="ln3170">              z0 = 1;</a>
<a name="ln3171">            }</a>
<a name="ln3172">          }</a>
<a name="ln3173">          break;</a>
<a name="ln3174">        }</a>
<a name="ln3175">      }</a>
<a name="ln3176">    } else if (ascii_iswhite(c)) {</a>
<a name="ln3177">      c = ' ';</a>
<a name="ln3178">      k = 1;</a>
<a name="ln3179">    }</a>
<a name="ln3180"> </a>
<a name="ln3181">    if (z0 == 0) {</a>
<a name="ln3182">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln3183">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln3184">              || wres[reslen - 1] != c)) {</a>
<a name="ln3185">        // condense only double letters</a>
<a name="ln3186">        wres[reslen++] = c;</a>
<a name="ln3187">      }</a>
<a name="ln3188"> </a>
<a name="ln3189">      i++;</a>
<a name="ln3190">      z = 0;</a>
<a name="ln3191">      k = 0;</a>
<a name="ln3192">    }</a>
<a name="ln3193">  }</a>
<a name="ln3194"> </a>
<a name="ln3195">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln3196">  int l = 0;</a>
<a name="ln3197">  for (int n = 0; n &lt; reslen; n++) {</a>
<a name="ln3198">    l += utf_char2bytes(wres[n], res + l);</a>
<a name="ln3199">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln3200">      break;</a>
<a name="ln3201">    }</a>
<a name="ln3202">  }</a>
<a name="ln3203">  res[l] = NUL;</a>
<a name="ln3204">}</a>
<a name="ln3205"> </a>
<a name="ln3206">// &quot;:spellinfo&quot;</a>
<a name="ln3207">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln3208">{</a>
<a name="ln3209">  if (no_spell_checking(curwin)) {</a>
<a name="ln3210">    return;</a>
<a name="ln3211">  }</a>
<a name="ln3212"> </a>
<a name="ln3213">  msg_start();</a>
<a name="ln3214">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln3215">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3216">    msg_puts(&quot;file: &quot;);</a>
<a name="ln3217">    msg_puts(lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln3218">    msg_putchar('\n');</a>
<a name="ln3219">    const char *const p = lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln3220">    if (p != NULL) {</a>
<a name="ln3221">      msg_puts(p);</a>
<a name="ln3222">      msg_putchar('\n');</a>
<a name="ln3223">    }</a>
<a name="ln3224">  }</a>
<a name="ln3225">  msg_end();</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln3229">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln3230">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln3231">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln3232">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln3233"> </a>
<a name="ln3234">// &quot;:spelldump&quot;</a>
<a name="ln3235">void ex_spelldump(exarg_T *eap)</a>
<a name="ln3236">{</a>
<a name="ln3237">  if (no_spell_checking(curwin)) {</a>
<a name="ln3238">    return;</a>
<a name="ln3239">  }</a>
<a name="ln3240">  OptVal spl = get_option_value(&quot;spl&quot;, NULL, OPT_LOCAL, NULL);</a>
<a name="ln3241"> </a>
<a name="ln3242">  // Create a new empty buffer in a new window.</a>
<a name="ln3243">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln3244"> </a>
<a name="ln3245">  // enable spelling locally in the new window</a>
<a name="ln3246">  set_option_value_give_err(&quot;spell&quot;, BOOLEAN_OPTVAL(true), OPT_LOCAL);</a>
<a name="ln3247">  set_option_value_give_err(&quot;spl&quot;, spl, OPT_LOCAL);</a>
<a name="ln3248">  optval_free(spl);</a>
<a name="ln3249"> </a>
<a name="ln3250">  if (!buf_is_empty(curbuf)) {</a>
<a name="ln3251">    return;</a>
<a name="ln3252">  }</a>
<a name="ln3253"> </a>
<a name="ln3254">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln3255"> </a>
<a name="ln3256">  // Delete the empty line that we started with.</a>
<a name="ln3257">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln3258">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln3259">  }</a>
<a name="ln3260">  redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln3261">}</a>
<a name="ln3262"> </a>
<a name="ln3263">/// Go through all possible words and:</a>
<a name="ln3264">/// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln3265">///      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln3266">/// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln3267">///</a>
<a name="ln3268">/// @param pat  leading part of the word</a>
<a name="ln3269">/// @param ic  ignore case</a>
<a name="ln3270">/// @param dir  direction for adding matches</a>
<a name="ln3271">/// @param dumpflags_arg  DUMPFLAG_*</a>
<a name="ln3272">void spell_dump_compl(char *pat, int ic, Direction *dir, int dumpflags_arg)</a>
<a name="ln3273">{</a>
<a name="ln3274">  langp_T *lp;</a>
<a name="ln3275">  slang_T *slang;</a>
<a name="ln3276">  idx_T arridx[MAXWLEN];</a>
<a name="ln3277">  int curi[MAXWLEN];</a>
<a name="ln3278">  char word[MAXWLEN];</a>
<a name="ln3279">  int c;</a>
<a name="ln3280">  uint8_t *byts;</a>
<a name="ln3281">  idx_T *idxs;</a>
<a name="ln3282">  linenr_T lnum = 0;</a>
<a name="ln3283">  int depth;</a>
<a name="ln3284">  int n;</a>
<a name="ln3285">  int flags;</a>
<a name="ln3286">  char *region_names = NULL;         // region names being used</a>
<a name="ln3287">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln3288">  char *p;</a>
<a name="ln3289">  int dumpflags = dumpflags_arg;</a>
<a name="ln3290">  int patlen;</a>
<a name="ln3291"> </a>
<a name="ln3292">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln3293">  // to dump_word().</a>
<a name="ln3294">  if (pat != NULL) {</a>
<a name="ln3295">    if (ic) {</a>
<a name="ln3296">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln3297">    } else {</a>
<a name="ln3298">      n = captype(pat, NULL);</a>
<a name="ln3299">      if (n == WF_ONECAP) {</a>
<a name="ln3300">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln3301">      } else if (n == WF_ALLCAP</a>
<a name="ln3302">                 &amp;&amp; (int)strlen(pat) &gt; utfc_ptr2len(pat)) {</a>
<a name="ln3303">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln3304">      }</a>
<a name="ln3305">    }</a>
<a name="ln3306">  }</a>
<a name="ln3307"> </a>
<a name="ln3308">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln3309">  // regions or none at all.</a>
<a name="ln3310">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln3311">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3312">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln3313">    if (p[0] != 0) {</a>
<a name="ln3314">      if (region_names == NULL) {           // first language with regions</a>
<a name="ln3315">        region_names = p;</a>
<a name="ln3316">      } else if (strcmp(region_names, p) != 0) {</a>
<a name="ln3317">        do_region = false;                  // region names are different</a>
<a name="ln3318">        break;</a>
<a name="ln3319">      }</a>
<a name="ln3320">    }</a>
<a name="ln3321">  }</a>
<a name="ln3322"> </a>
<a name="ln3323">  if (do_region &amp;&amp; region_names != NULL &amp;&amp; pat == NULL) {</a>
<a name="ln3324">    vim_snprintf(IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln3325">    ml_append(lnum++, IObuff, 0, false);</a>
<a name="ln3326">  } else {</a>
<a name="ln3327">    do_region = false;</a>
<a name="ln3328">  }</a>
<a name="ln3329"> </a>
<a name="ln3330">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln3331">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln3332">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3333">    slang = lp-&gt;lp_slang;</a>
<a name="ln3334">    if (slang-&gt;sl_fbyts == NULL) {          // reloading failed</a>
<a name="ln3335">      continue;</a>
<a name="ln3336">    }</a>
<a name="ln3337"> </a>
<a name="ln3338">    if (pat == NULL) {</a>
<a name="ln3339">      vim_snprintf(IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln3340">      ml_append(lnum++, IObuff, 0, false);</a>
<a name="ln3341">    }</a>
<a name="ln3342"> </a>
<a name="ln3343">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln3344">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln3345">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL) {</a>
<a name="ln3346">      patlen = (int)strlen(pat);</a>
<a name="ln3347">    } else {</a>
<a name="ln3348">      patlen = -1;</a>
<a name="ln3349">    }</a>
<a name="ln3350"> </a>
<a name="ln3351">    // round 1: case-folded tree</a>
<a name="ln3352">    // round 2: keep-case tree</a>
<a name="ln3353">    for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln3354">      if (round == 1) {</a>
<a name="ln3355">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln3356">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln3357">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln3358">      } else {</a>
<a name="ln3359">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln3360">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln3361">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln3362">      }</a>
<a name="ln3363">      if (byts == NULL) {</a>
<a name="ln3364">        continue;                       // array is empty</a>
<a name="ln3365">      }</a>
<a name="ln3366">      depth = 0;</a>
<a name="ln3367">      arridx[0] = 0;</a>
<a name="ln3368">      curi[0] = 1;</a>
<a name="ln3369">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln3370">             &amp;&amp; (pat == NULL || !ins_compl_interrupted())) {</a>
<a name="ln3371">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln3372">          // Done all bytes at this node, go up one level.</a>
<a name="ln3373">          depth--;</a>
<a name="ln3374">          line_breakcheck();</a>
<a name="ln3375">          ins_compl_check_keys(50, false);</a>
<a name="ln3376">        } else {</a>
<a name="ln3377">          // Do one more byte at this node.</a>
<a name="ln3378">          n = arridx[depth] + curi[depth];</a>
<a name="ln3379">          curi[depth]++;</a>
<a name="ln3380">          c = byts[n];</a>
<a name="ln3381">          if (c == 0 || depth &gt;= MAXWLEN - 1) {</a>
<a name="ln3382">            // End of word or reached maximum length, deal with the</a>
<a name="ln3383">            // word.</a>
<a name="ln3384">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln3385">            // they will appear in the keep-case tree.</a>
<a name="ln3386">            // Only use the word when the region matches.</a>
<a name="ln3387">            flags = (int)idxs[n];</a>
<a name="ln3388">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln3389">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln3390">                &amp;&amp; (do_region</a>
<a name="ln3391">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln3392">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln3393">                        &amp; (unsigned)lp-&gt;lp_region) != 0)) {</a>
<a name="ln3394">              word[depth] = NUL;</a>
<a name="ln3395">              if (!do_region) {</a>
<a name="ln3396">                flags &amp;= ~WF_REGION;</a>
<a name="ln3397">              }</a>
<a name="ln3398"> </a>
<a name="ln3399">              // Dump the basic word if there is no prefix or</a>
<a name="ln3400">              // when it's the first one.</a>
<a name="ln3401">              c = (int)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3402">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln3403">                dump_word(slang, word, pat, dir, dumpflags, flags, lnum);</a>
<a name="ln3404">                if (pat == NULL) {</a>
<a name="ln3405">                  lnum++;</a>
<a name="ln3406">                }</a>
<a name="ln3407">              }</a>
<a name="ln3408"> </a>
<a name="ln3409">              // Apply the prefix, if there is one.</a>
<a name="ln3410">              if (c != 0) {</a>
<a name="ln3411">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln3412">                                     dumpflags, flags, lnum);</a>
<a name="ln3413">              }</a>
<a name="ln3414">            }</a>
<a name="ln3415">          } else {</a>
<a name="ln3416">            // Normal char, go one level deeper.</a>
<a name="ln3417">            word[depth++] = (char)c;</a>
<a name="ln3418">            arridx[depth] = idxs[n];</a>
<a name="ln3419">            curi[depth] = 1;</a>
<a name="ln3420"> </a>
<a name="ln3421">            // Check if this character matches with the pattern.</a>
<a name="ln3422">            // If not skip the whole tree below it.</a>
<a name="ln3423">            // Always ignore case here, dump_word() will check</a>
<a name="ln3424">            // proper case later.  This isn't exactly right when</a>
<a name="ln3425">            // length changes for multi-byte characters with</a>
<a name="ln3426">            // ignore case...</a>
<a name="ln3427">            assert(depth &gt;= 0);</a>
<a name="ln3428">            if (depth &lt;= patlen</a>
<a name="ln3429">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0) {</a>
<a name="ln3430">              depth--;</a>
<a name="ln3431">            }</a>
<a name="ln3432">          }</a>
<a name="ln3433">        }</a>
<a name="ln3434">      }</a>
<a name="ln3435">    }</a>
<a name="ln3436">  }</a>
<a name="ln3437">}</a>
<a name="ln3438"> </a>
<a name="ln3439">/// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln3440">/// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln3441">static void dump_word(slang_T *slang, char *word, char *pat, Direction *dir, int dumpflags,</a>
<a name="ln3442">                      int wordflags, linenr_T lnum)</a>
<a name="ln3443">{</a>
<a name="ln3444">  bool keepcap = false;</a>
<a name="ln3445">  char *p;</a>
<a name="ln3446">  char cword[MAXWLEN];</a>
<a name="ln3447">  char badword[MAXWLEN + 10];</a>
<a name="ln3448">  int flags = wordflags;</a>
<a name="ln3449"> </a>
<a name="ln3450">  if (dumpflags &amp; DUMPFLAG_ONECAP) {</a>
<a name="ln3451">    flags |= WF_ONECAP;</a>
<a name="ln3452">  }</a>
<a name="ln3453">  if (dumpflags &amp; DUMPFLAG_ALLCAP) {</a>
<a name="ln3454">    flags |= WF_ALLCAP;</a>
<a name="ln3455">  }</a>
<a name="ln3456"> </a>
<a name="ln3457">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln3458">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln3459">    make_case_word(word, cword, flags);</a>
<a name="ln3460">    p = cword;</a>
<a name="ln3461">  } else {</a>
<a name="ln3462">    p = word;</a>
<a name="ln3463">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln3464">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln3465">            || (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln3466">      keepcap = true;</a>
<a name="ln3467">    }</a>
<a name="ln3468">  }</a>
<a name="ln3469">  char *tw = p;</a>
<a name="ln3470"> </a>
<a name="ln3471">  if (pat == NULL) {</a>
<a name="ln3472">    // Add flags and regions after a slash.</a>
<a name="ln3473">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln3474">      STRCPY(badword, p);</a>
<a name="ln3475">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln3476">      if (keepcap) {</a>
<a name="ln3477">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln3478">      }</a>
<a name="ln3479">      if (flags &amp; WF_BANNED) {</a>
<a name="ln3480">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln3481">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln3482">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln3483">      }</a>
<a name="ln3484">      if (flags &amp; WF_REGION) {</a>
<a name="ln3485">        for (int i = 0; i &lt; 7; i++) {</a>
<a name="ln3486">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln3487">            const size_t badword_len = strlen(badword);</a>
<a name="ln3488">            snprintf(badword + badword_len,</a>
<a name="ln3489">                     sizeof(badword) - badword_len,</a>
<a name="ln3490">                     &quot;%d&quot;, i + 1);</a>
<a name="ln3491">          }</a>
<a name="ln3492">        }</a>
<a name="ln3493">      }</a>
<a name="ln3494">      p = badword;</a>
<a name="ln3495">    }</a>
<a name="ln3496"> </a>
<a name="ln3497">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln3498">      hashitem_T *hi;</a>
<a name="ln3499"> </a>
<a name="ln3500">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln3501">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln3502">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3503">        vim_snprintf(IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln3504">                     tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln3505">        p = IObuff;</a>
<a name="ln3506">      }</a>
<a name="ln3507">    }</a>
<a name="ln3508"> </a>
<a name="ln3509">    ml_append(lnum, p, 0, false);</a>
<a name="ln3510">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln3511">              ? mb_strnicmp(p, pat, strlen(pat)) == 0</a>
<a name="ln3512">              : strncmp(p, pat, strlen(pat)) == 0)</a>
<a name="ln3513">             &amp;&amp; ins_compl_add_infercase(p, (int)strlen(p),</a>
<a name="ln3514">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln3515">    // if dir was BACKWARD then honor it just once</a>
<a name="ln3516">    *dir = FORWARD;</a>
<a name="ln3517">  }</a>
<a name="ln3518">}</a>
<a name="ln3519"> </a>
<a name="ln3520">/// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln3521">/// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln3522">/// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln3523">///</a>
<a name="ln3524">/// @param word  case-folded word</a>
<a name="ln3525">/// @param flags  flags with prefix ID</a>
<a name="ln3526">///</a>
<a name="ln3527">/// @return  the updated line number.</a>
<a name="ln3528">static linenr_T dump_prefixes(slang_T *slang, char *word, char *pat, Direction *dir, int dumpflags,</a>
<a name="ln3529">                              int flags, linenr_T startlnum)</a>
<a name="ln3530">{</a>
<a name="ln3531">  idx_T arridx[MAXWLEN];</a>
<a name="ln3532">  int curi[MAXWLEN];</a>
<a name="ln3533">  char prefix[MAXWLEN];</a>
<a name="ln3534">  char word_up[MAXWLEN];</a>
<a name="ln3535">  bool has_word_up = false;</a>
<a name="ln3536">  linenr_T lnum = startlnum;</a>
<a name="ln3537"> </a>
<a name="ln3538">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln3539">  // upper-case letter in word_up[].</a>
<a name="ln3540">  int c = utf_ptr2char(word);</a>
<a name="ln3541">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln3542">    onecap_copy(word, word_up, true);</a>
<a name="ln3543">    has_word_up = true;</a>
<a name="ln3544">  }</a>
<a name="ln3545"> </a>
<a name="ln3546">  uint8_t *byts = slang-&gt;sl_pbyts;</a>
<a name="ln3547">  idx_T *idxs = slang-&gt;sl_pidxs;</a>
<a name="ln3548">  if (byts != NULL) {           // array not is empty</a>
<a name="ln3549">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln3550">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln3551">    int depth = 0;</a>
<a name="ln3552">    arridx[0] = 0;</a>
<a name="ln3553">    curi[0] = 1;</a>
<a name="ln3554">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3555">      int n = arridx[depth];</a>
<a name="ln3556">      int len = byts[n];</a>
<a name="ln3557">      if (curi[depth] &gt; len) {</a>
<a name="ln3558">        // Done all bytes at this node, go up one level.</a>
<a name="ln3559">        depth--;</a>
<a name="ln3560">        line_breakcheck();</a>
<a name="ln3561">      } else {</a>
<a name="ln3562">        // Do one more byte at this node.</a>
<a name="ln3563">        n += curi[depth];</a>
<a name="ln3564">        curi[depth]++;</a>
<a name="ln3565">        c = byts[n];</a>
<a name="ln3566">        if (c == 0) {</a>
<a name="ln3567">          // End of prefix, find out how many IDs there are.</a>
<a name="ln3568">          int i;</a>
<a name="ln3569">          for (i = 1; i &lt; len; i++) {</a>
<a name="ln3570">            if (byts[n + i] != 0) {</a>
<a name="ln3571">              break;</a>
<a name="ln3572">            }</a>
<a name="ln3573">          }</a>
<a name="ln3574">          curi[depth] += i - 1;</a>
<a name="ln3575"> </a>
<a name="ln3576">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln3577">          if (c != 0) {</a>
<a name="ln3578">            xstrlcpy(prefix + depth, word, (size_t)(MAXWLEN - depth));</a>
<a name="ln3579">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln3580">                      (c &amp; WF_RAREPFX) ? (flags | WF_RARE) : flags, lnum);</a>
<a name="ln3581">            if (lnum != 0) {</a>
<a name="ln3582">              lnum++;</a>
<a name="ln3583">            }</a>
<a name="ln3584">          }</a>
<a name="ln3585"> </a>
<a name="ln3586">          // Check for prefix that matches the word when the</a>
<a name="ln3587">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln3588">          // a condition.</a>
<a name="ln3589">          if (has_word_up) {</a>
<a name="ln3590">            c = valid_word_prefix(i, n, flags, word_up, slang, true);</a>
<a name="ln3591">            if (c != 0) {</a>
<a name="ln3592">              xstrlcpy(prefix + depth, word_up, (size_t)(MAXWLEN - depth));</a>
<a name="ln3593">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln3594">                        (c &amp; WF_RAREPFX) ? (flags | WF_RARE) : flags, lnum);</a>
<a name="ln3595">              if (lnum != 0) {</a>
<a name="ln3596">                lnum++;</a>
<a name="ln3597">              }</a>
<a name="ln3598">            }</a>
<a name="ln3599">          }</a>
<a name="ln3600">        } else {</a>
<a name="ln3601">          // Normal char, go one level deeper.</a>
<a name="ln3602">          prefix[depth++] = (char)c;</a>
<a name="ln3603">          arridx[depth] = idxs[n];</a>
<a name="ln3604">          curi[depth] = 1;</a>
<a name="ln3605">        }</a>
<a name="ln3606">      }</a>
<a name="ln3607">    }</a>
<a name="ln3608">  }</a>
<a name="ln3609"> </a>
<a name="ln3610">  return lnum;</a>
<a name="ln3611">}</a>
<a name="ln3612"> </a>
<a name="ln3613">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln3614">// Uses the spell-checking word characters.</a>
<a name="ln3615">char *spell_to_word_end(char *start, win_T *win)</a>
<a name="ln3616">{</a>
<a name="ln3617">  char *p = start;</a>
<a name="ln3618"> </a>
<a name="ln3619">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln3620">    MB_PTR_ADV(p);</a>
<a name="ln3621">  }</a>
<a name="ln3622">  return p;</a>
<a name="ln3623">}</a>
<a name="ln3624"> </a>
<a name="ln3625">// For Insert mode completion CTRL-X s:</a>
<a name="ln3626">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln3627">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln3628">// the word in front of the cursor.</a>
<a name="ln3629">// Returns the column number of the word.</a>
<a name="ln3630">int spell_word_start(int startcol)</a>
<a name="ln3631">{</a>
<a name="ln3632">  if (no_spell_checking(curwin)) {</a>
<a name="ln3633">    return startcol;</a>
<a name="ln3634">  }</a>
<a name="ln3635"> </a>
<a name="ln3636">  char *line = get_cursor_line_ptr();</a>
<a name="ln3637">  char *p;</a>
<a name="ln3638"> </a>
<a name="ln3639">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln3640">  for (p = line + startcol; p &gt; line;) {</a>
<a name="ln3641">    MB_PTR_BACK(line, p);</a>
<a name="ln3642">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln3643">      break;</a>
<a name="ln3644">    }</a>
<a name="ln3645">  }</a>
<a name="ln3646"> </a>
<a name="ln3647">  int col = 0;</a>
<a name="ln3648"> </a>
<a name="ln3649">  // Go back to start of the word.</a>
<a name="ln3650">  while (p &gt; line) {</a>
<a name="ln3651">    col = (int)(p - line);</a>
<a name="ln3652">    MB_PTR_BACK(line, p);</a>
<a name="ln3653">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln3654">      break;</a>
<a name="ln3655">    }</a>
<a name="ln3656">    col = 0;</a>
<a name="ln3657">  }</a>
<a name="ln3658"> </a>
<a name="ln3659">  return col;</a>
<a name="ln3660">}</a>
<a name="ln3661"> </a>
<a name="ln3662">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln3663">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln3664">static bool spell_expand_need_cap;</a>
<a name="ln3665"> </a>
<a name="ln3666">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln3667">{</a>
<a name="ln3668">  spell_expand_need_cap = check_need_cap(curwin, curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671">// Get list of spelling suggestions.</a>
<a name="ln3672">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln3673">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln3674">// allocated strings.</a>
<a name="ln3675">int expand_spelling(linenr_T lnum, char *pat, char ***matchp)</a>
<a name="ln3676">{</a>
<a name="ln3677">  garray_T ga;</a>
<a name="ln3678"> </a>
<a name="ln3679">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln3680">  *matchp = ga.ga_data;</a>
<a name="ln3681">  return ga.ga_len;</a>
<a name="ln3682">}</a>
<a name="ln3683"> </a>
<a name="ln3684">/// @return  true if &quot;val&quot; is a valid 'spelllang' value.</a>
<a name="ln3685">bool valid_spelllang(const char *val)</a>
<a name="ln3686">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3687">{</a>
<a name="ln3688">  return valid_name(val, &quot;.-_,@&quot;);</a>
<a name="ln3689">}</a>
<a name="ln3690"> </a>
<a name="ln3691">/// @return  true if &quot;val&quot; is a valid 'spellfile' value.</a>
<a name="ln3692">bool valid_spellfile(const char *val)</a>
<a name="ln3693">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3694">{</a>
<a name="ln3695">  for (const char *s = val; *s != NUL; s++) {</a>
<a name="ln3696">    if (!vim_is_fname_char((uint8_t)(*s))) {</a>
<a name="ln3697">      return false;</a>
<a name="ln3698">    }</a>
<a name="ln3699">  }</a>
<a name="ln3700">  return true;</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">const char *did_set_spell_option(bool is_spellfile)</a>
<a name="ln3704">{</a>
<a name="ln3705">  const char *errmsg = NULL;</a>
<a name="ln3706"> </a>
<a name="ln3707">  if (is_spellfile) {</a>
<a name="ln3708">    int l = (int)strlen(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln3709">    if (l &gt; 0</a>
<a name="ln3710">        &amp;&amp; (l &lt; 4 || strcmp(curwin-&gt;w_s-&gt;b_p_spf + l - 4, &quot;.add&quot;) != 0)) {</a>
<a name="ln3711">      errmsg = e_invarg;</a>
<a name="ln3712">    }</a>
<a name="ln3713">  }</a>
<a name="ln3714"> </a>
<a name="ln3715">  if (errmsg != NULL) {</a>
<a name="ln3716">    return errmsg;</a>
<a name="ln3717">  }</a>
<a name="ln3718"> </a>
<a name="ln3719">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3720">    if (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;w_p_spell) {</a>
<a name="ln3721">      errmsg = parse_spelllang(wp);</a>
<a name="ln3722">      break;</a>
<a name="ln3723">    }</a>
<a name="ln3724">  }</a>
<a name="ln3725">  return errmsg;</a>
<a name="ln3726">}</a>
<a name="ln3727"> </a>
<a name="ln3728">/// Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</a>
<a name="ln3729">/// Return error message when failed, NULL when OK.</a>
<a name="ln3730">const char *compile_cap_prog(synblock_T *synblock)</a>
<a name="ln3731">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3732">{</a>
<a name="ln3733">  regprog_T *rp = synblock-&gt;b_cap_prog;</a>
<a name="ln3734"> </a>
<a name="ln3735">  if (synblock-&gt;b_p_spc == NULL || *synblock-&gt;b_p_spc == NUL) {</a>
<a name="ln3736">    synblock-&gt;b_cap_prog = NULL;</a>
<a name="ln3737">  } else {</a>
<a name="ln3738">    // Prepend a ^ so that we only match at one column</a>
<a name="ln3739">    char *re = concat_str(&quot;^&quot;, synblock-&gt;b_p_spc);</a>
<a name="ln3740">    synblock-&gt;b_cap_prog = vim_regcomp(re, RE_MAGIC);</a>
<a name="ln3741">    xfree(re);</a>
<a name="ln3742">    if (synblock-&gt;b_cap_prog == NULL) {</a>
<a name="ln3743">      synblock-&gt;b_cap_prog = rp;         // restore the previous program</a>
<a name="ln3744">      return e_invarg;</a>
<a name="ln3745">    }</a>
<a name="ln3746">  }</a>
<a name="ln3747"> </a>
<a name="ln3748">  vim_regfree(rp);</a>
<a name="ln3749">  return NULL;</a>
<a name="ln3750">}</a>
</code></pre>
<div class="balloon" rel="3023"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>