<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rpc.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;string.h&gt;</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;rpc.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">enum {</a>
<a name="ln9">  MPACK_RPC_RECEIVE_ARRAY = 1,</a>
<a name="ln10">  MPACK_RPC_RECEIVE_TYPE,</a>
<a name="ln11">  MPACK_RPC_RECEIVE_ID</a>
<a name="ln12">};</a>
<a name="ln13"> </a>
<a name="ln14">static mpack_rpc_header_t mpack_rpc_request_hdr(void);</a>
<a name="ln15">static mpack_rpc_header_t mpack_rpc_reply_hdr(void);</a>
<a name="ln16">static mpack_rpc_header_t mpack_rpc_notify_hdr(void);</a>
<a name="ln17">static int mpack_rpc_put(mpack_rpc_session_t *s, mpack_rpc_message_t m);</a>
<a name="ln18">static int mpack_rpc_pop(mpack_rpc_session_t *s, mpack_rpc_message_t *m);</a>
<a name="ln19">static void mpack_rpc_reset_hdr(mpack_rpc_header_t *hdr);</a>
<a name="ln20"> </a>
<a name="ln21">MPACK_API void mpack_rpc_session_init(mpack_rpc_session_t *session,</a>
<a name="ln22">    mpack_uint32_t capacity)</a>
<a name="ln23">{</a>
<a name="ln24">  session-&gt;capacity = capacity ? capacity : MPACK_RPC_MAX_REQUESTS;</a>
<a name="ln25">  session-&gt;request_id = 0;</a>
<a name="ln26">  mpack_tokbuf_init(&amp;session-&gt;reader);</a>
<a name="ln27">  mpack_tokbuf_init(&amp;session-&gt;writer);</a>
<a name="ln28">  mpack_rpc_reset_hdr(&amp;session-&gt;receive);</a>
<a name="ln29">  mpack_rpc_reset_hdr(&amp;session-&gt;send);</a>
<a name="ln30">  memset(session-&gt;slots, 0,</a>
<a name="ln31">      sizeof(struct mpack_rpc_slot_s) * session-&gt;capacity);</a>
<a name="ln32">}</a>
<a name="ln33"> </a>
<a name="ln34">MPACK_API int mpack_rpc_receive_tok(mpack_rpc_session_t *session,</a>
<a name="ln35">    mpack_token_t tok, mpack_rpc_message_t *msg)</a>
<a name="ln36">{</a>
<a name="ln37">  int type;</a>
<a name="ln38"> </a>
<a name="ln39">  if (session-&gt;receive.index == 0) {</a>
<a name="ln40">    if (tok.type != MPACK_TOKEN_ARRAY)</a>
<a name="ln41">      /* not an array */</a>
<a name="ln42">      return MPACK_RPC_EARRAY;</a>
<a name="ln43"> </a>
<a name="ln44">    if (tok.length &lt; 3 || tok.length &gt; 4)</a>
<a name="ln45">      /* invalid array length */</a>
<a name="ln46">      return MPACK_RPC_EARRAYL;</a>
<a name="ln47"> </a>
<a name="ln48">    session-&gt;receive.toks[0] = tok;</a>
<a name="ln49">    session-&gt;receive.index++;</a>
<a name="ln50">    return MPACK_EOF;  /* get the type */</a>
<a name="ln51">  }</a>
<a name="ln52"> </a>
<a name="ln53">  if (session-&gt;receive.index == 1) {</a>
<a name="ln54"> </a>
<a name="ln55">    if (tok.type != MPACK_TOKEN_UINT || tok.length &gt; 1 || tok.data.value.lo &gt; 2)</a>
<a name="ln56">      /* invalid type */</a>
<a name="ln57">      return MPACK_RPC_ETYPE;</a>
<a name="ln58"> </a>
<a name="ln59">    if (tok.data.value.lo &lt; 2 &amp;&amp; session-&gt;receive.toks[0].length != 4)</a>
<a name="ln60">      /* request or response with array length != 4 */</a>
<a name="ln61">      return MPACK_RPC_EARRAYL;</a>
<a name="ln62"> </a>
<a name="ln63">    if (tok.data.value.lo == 2 &amp;&amp; session-&gt;receive.toks[0].length != 3)</a>
<a name="ln64">      /* notification with array length != 3 */</a>
<a name="ln65">      return MPACK_RPC_EARRAYL;</a>
<a name="ln66"> </a>
<a name="ln67">    session-&gt;receive.toks[1] = tok;</a>
<a name="ln68">    session-&gt;receive.index++;</a>
<a name="ln69"> </a>
<a name="ln70">    if (tok.data.value.lo &lt; 2) return MPACK_EOF;</a>
<a name="ln71"> </a>
<a name="ln72">    type = MPACK_RPC_NOTIFICATION;</a>
<a name="ln73">    goto end;</a>
<a name="ln74">  }</a>
<a name="ln75"> </a>
<a name="ln76">  assert(session-&gt;receive.index == 2);</a>
<a name="ln77">  </a>
<a name="ln78">  if (tok.type != MPACK_TOKEN_UINT || tok.length &gt; 4)</a>
<a name="ln79">    /* invalid request/response id */</a>
<a name="ln80">    return MPACK_RPC_EMSGID;</a>
<a name="ln81">    </a>
<a name="ln82">  msg-&gt;id = tok.data.value.lo;</a>
<a name="ln83">  msg-&gt;data.p = NULL;</a>
<a name="ln84">  type = (int)session-&gt;receive.toks[1].data.value.lo + MPACK_RPC_REQUEST;</a>
<a name="ln85"> </a>
<a name="ln86">  if (type == MPACK_RPC_RESPONSE &amp;&amp; !mpack_rpc_pop(session, msg))</a>
<a name="ln87">    /* response with invalid id */</a>
<a name="ln88">    return MPACK_RPC_ERESPID;</a>
<a name="ln89"> </a>
<a name="ln90">end:</a>
<a name="ln91">  mpack_rpc_reset_hdr(&amp;session-&gt;receive);</a>
<a name="ln92">  return type;</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">MPACK_API int mpack_rpc_request_tok(mpack_rpc_session_t *session, </a>
<a name="ln96">    mpack_token_t *tok, mpack_data_t data)</a>
<a name="ln97">{</a>
<a name="ln98">  if (session-&gt;send.index == 0) {</a>
<a name="ln99">    int status;</a>
<a name="ln100">    mpack_rpc_message_t msg;</a>
<a name="ln101">    do {</a>
<a name="ln102">      msg.id = session-&gt;request_id;</a>
<a name="ln103">      msg.data = data;</a>
<a name="ln104">      session-&gt;send = mpack_rpc_request_hdr();</a>
<a name="ln105">      session-&gt;send.toks[2].type = MPACK_TOKEN_UINT;</a>
<a name="ln106">      session-&gt;send.toks[2].data.value.lo = msg.id;</a>
<a name="ln107">      session-&gt;send.toks[2].data.value.hi = 0;</a>
<a name="ln108">      *tok = session-&gt;send.toks[0];</a>
<a name="ln109">      status = mpack_rpc_put(session, msg);</a>
<a name="ln110">      if (status == -1) return MPACK_NOMEM;</a>
<a name="ln111">      session-&gt;request_id = (session-&gt;request_id + 1) % 0xffffffff;</a>
<a name="ln112">    } while (!status);</a>
<a name="ln113">    session-&gt;send.index++;</a>
<a name="ln114">    return MPACK_EOF;</a>
<a name="ln115">  }</a>
<a name="ln116">  </a>
<a name="ln117">  if (session-&gt;send.index == 1) {</a>
<a name="ln118">    *tok = session-&gt;send.toks[1];</a>
<a name="ln119">    session-&gt;send.index++;</a>
<a name="ln120">    return MPACK_EOF;</a>
<a name="ln121">  }</a>
<a name="ln122"> </a>
<a name="ln123">  assert(session-&gt;send.index == 2);</a>
<a name="ln124">  *tok = session-&gt;send.toks[2];</a>
<a name="ln125">  mpack_rpc_reset_hdr(&amp;session-&gt;send);</a>
<a name="ln126">  return MPACK_OK;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">MPACK_API int mpack_rpc_reply_tok(mpack_rpc_session_t *session,</a>
<a name="ln130">    mpack_token_t *tok, mpack_uint32_t id)</a>
<a name="ln131">{</a>
<a name="ln132">  if (session-&gt;send.index == 0) {</a>
<a name="ln133">    session-&gt;send = mpack_rpc_reply_hdr();</a>
<a name="ln134">    session-&gt;send.toks[2].type = MPACK_TOKEN_UINT;</a>
<a name="ln135">    session-&gt;send.toks[2].data.value.lo = id;</a>
<a name="ln136">    session-&gt;send.toks[2].data.value.hi = 0;</a>
<a name="ln137">    *tok = session-&gt;send.toks[0];</a>
<a name="ln138">    session-&gt;send.index++;</a>
<a name="ln139">    return MPACK_EOF;</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  if (session-&gt;send.index == 1) {</a>
<a name="ln143">    *tok = session-&gt;send.toks[1];</a>
<a name="ln144">    session-&gt;send.index++;</a>
<a name="ln145">    return MPACK_EOF;</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  assert(session-&gt;send.index == 2);</a>
<a name="ln149">  *tok = session-&gt;send.toks[2];</a>
<a name="ln150">  mpack_rpc_reset_hdr(&amp;session-&gt;send);</a>
<a name="ln151">  return MPACK_OK;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">MPACK_API int mpack_rpc_notify_tok(mpack_rpc_session_t *session,</a>
<a name="ln155">    mpack_token_t *tok)</a>
<a name="ln156">{</a>
<a name="ln157">  if (session-&gt;send.index == 0) {</a>
<a name="ln158">    session-&gt;send = mpack_rpc_notify_hdr();</a>
<a name="ln159">    *tok = session-&gt;send.toks[0];</a>
<a name="ln160">    session-&gt;send.index++;</a>
<a name="ln161">    return MPACK_EOF;</a>
<a name="ln162">  }</a>
<a name="ln163"> </a>
<a name="ln164">  assert(session-&gt;send.index == 1);</a>
<a name="ln165">  *tok = session-&gt;send.toks[1];</a>
<a name="ln166">  mpack_rpc_reset_hdr(&amp;session-&gt;send);</a>
<a name="ln167">  return MPACK_OK;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">MPACK_API int mpack_rpc_receive(mpack_rpc_session_t *session, const char **buf,</a>
<a name="ln171">    size_t *buflen, mpack_rpc_message_t *msg)</a>
<a name="ln172">{</a>
<a name="ln173">  int status;</a>
<a name="ln174"> </a>
<a name="ln175">  do {</a>
<a name="ln176">    mpack_token_t tok;</a>
<a name="ln177">    status = mpack_read(&amp;session-&gt;reader, buf, buflen, &amp;tok);</a>
<a name="ln178">    if (status) break;</a>
<a name="ln179">    status = mpack_rpc_receive_tok(session, tok, msg);</a>
<a name="ln180">    if (status &gt;= MPACK_RPC_REQUEST) break;</a>
<a name="ln181">  } while (*buflen);</a>
<a name="ln182"> </a>
<a name="ln183">  return status;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">MPACK_API int mpack_rpc_request(mpack_rpc_session_t *session, char **buf,</a>
<a name="ln187">    size_t *buflen, mpack_data_t data)</a>
<a name="ln188">{</a>
<a name="ln189">  int status = MPACK_EOF;</a>
<a name="ln190"> </a>
<a name="ln191">  while (status &amp;&amp; *buflen) {</a>
<a name="ln192">    int write_status;</a>
<a name="ln193">    mpack_token_t tok;</a>
<a name="ln194">    if (!session-&gt;writer.plen) {</a>
<a name="ln195">      status = mpack_rpc_request_tok(session, &amp;tok, data);</a>
<a name="ln196">    }</a>
<a name="ln197">    if (status == MPACK_NOMEM) break;</a>
<a name="ln198">    write_status = mpack_write(&amp;session-&gt;writer, buf, buflen, &amp;tok);</a>
<a name="ln199">    status = write_status ? write_status : status;</a>
<a name="ln200">  }</a>
<a name="ln201"> </a>
<a name="ln202">  return status;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">MPACK_API int mpack_rpc_reply(mpack_rpc_session_t *session, char **buf,</a>
<a name="ln206">    size_t *buflen, mpack_uint32_t id)</a>
<a name="ln207">{</a>
<a name="ln208">  int status = MPACK_EOF;</a>
<a name="ln209"> </a>
<a name="ln210">  while (status &amp;&amp; *buflen) {</a>
<a name="ln211">    int write_status;</a>
<a name="ln212">    mpack_token_t tok;</a>
<a name="ln213">    if (!session-&gt;writer.plen) {</a>
<a name="ln214">      status = mpack_rpc_reply_tok(session, &amp;tok, id);</a>
<a name="ln215">    }</a>
<a name="ln216">    write_status = mpack_write(&amp;session-&gt;writer, buf, buflen, &amp;tok);</a>
<a name="ln217">    status = write_status ? write_status : status;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  return status;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">MPACK_API int mpack_rpc_notify(mpack_rpc_session_t *session, char **buf,</a>
<a name="ln224">    size_t *buflen)</a>
<a name="ln225">{</a>
<a name="ln226">  int status = MPACK_EOF;</a>
<a name="ln227"> </a>
<a name="ln228">  while (status &amp;&amp; *buflen) {</a>
<a name="ln229">    int write_status;</a>
<a name="ln230">    mpack_token_t tok;</a>
<a name="ln231">    if (!session-&gt;writer.plen) {</a>
<a name="ln232">      status = mpack_rpc_notify_tok(session, &amp;tok);</a>
<a name="ln233">    }</a>
<a name="ln234">    write_status = mpack_write(&amp;session-&gt;writer, buf, buflen, &amp;tok);</a>
<a name="ln235">    status = write_status ? write_status : status;</a>
<a name="ln236">  }</a>
<a name="ln237"> </a>
<a name="ln238">  return status;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">MPACK_API void mpack_rpc_session_copy(mpack_rpc_session_t *dst,</a>
<a name="ln242">    mpack_rpc_session_t *src)</a>
<a name="ln243">{</a>
<a name="ln244">  mpack_uint32_t i;</a>
<a name="ln245">  mpack_uint32_t dst_capacity = dst-&gt;capacity; </a>
<a name="ln246">  assert(src-&gt;capacity &lt;= dst_capacity);</a>
<a name="ln247">  /* copy all fields except slots */</a>
<a name="ln248">  memcpy(dst, src, sizeof(mpack_rpc_one_session_t) -</a>
<a name="ln249">      sizeof(struct mpack_rpc_slot_s));</a>
<a name="ln250">  /* reset capacity */</a>
<a name="ln251">  dst-&gt;capacity = dst_capacity;</a>
<a name="ln252">  /* reinsert requests  */</a>
<a name="ln253">  memset(dst-&gt;slots, 0, sizeof(struct mpack_rpc_slot_s) * dst-&gt;capacity);</a>
<a name="ln254">  for (i = 0; i &lt; src-&gt;capacity; i++) {</a>
<a name="ln255">    if (src-&gt;slots[i].used) mpack_rpc_put(dst, src-&gt;slots[i].msg);</a>
<a name="ln256">  }</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">static mpack_rpc_header_t mpack_rpc_request_hdr(void)</a>
<a name="ln260">{</a>
<a name="ln261">  mpack_rpc_header_t hdr;</a>
<a name="ln262">  hdr.index = 0;</a>
<a name="ln263">  hdr.toks[0].type = MPACK_TOKEN_ARRAY;</a>
<a name="ln264">  hdr.toks[0].length = 4;</a>
<a name="ln265">  hdr.toks[1].type = MPACK_TOKEN_UINT;</a>
<a name="ln266">  hdr.toks[1].data.value.lo = 0;</a>
<a name="ln267">  hdr.toks[1].data.value.hi = 0;</a>
<a name="ln268">  return hdr;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">static mpack_rpc_header_t mpack_rpc_reply_hdr(void)</a>
<a name="ln272">{</a>
<a name="ln273">  mpack_rpc_header_t hdr = mpack_rpc_request_hdr();</a>
<a name="ln274">  hdr.toks[1].data.value.lo = 1;</a>
<a name="ln275">  hdr.toks[1].data.value.hi = 0;</a>
<a name="ln276">  return hdr;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static mpack_rpc_header_t mpack_rpc_notify_hdr(void)</a>
<a name="ln280">{</a>
<a name="ln281">  mpack_rpc_header_t hdr = mpack_rpc_request_hdr();</a>
<a name="ln282">  hdr.toks[0].length = 3;</a>
<a name="ln283">  hdr.toks[1].data.value.lo = 2;</a>
<a name="ln284">  hdr.toks[1].data.value.hi = 0;</a>
<a name="ln285">  return hdr;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static int mpack_rpc_put(mpack_rpc_session_t *session, mpack_rpc_message_t msg)</a>
<a name="ln289">{</a>
<a name="ln290">  struct mpack_rpc_slot_s *slot = NULL;</a>
<a name="ln291">  mpack_uint32_t i;</a>
<a name="ln292">  mpack_uint32_t hash = msg.id % session-&gt;capacity;</a>
<a name="ln293"> </a>
<a name="ln294">  for (i = 0; i &lt; session-&gt;capacity; i++) {</a>
<a name="ln295">    if (!session-&gt;slots[hash].used || session-&gt;slots[hash].msg.id == msg.id) {</a>
<a name="ln296">      slot = session-&gt;slots + hash;</a>
<a name="ln297">      break;</a>
<a name="ln298">    }</a>
<a name="ln299">    hash = hash &gt; 0 ? hash - 1 : session-&gt;capacity - 1;</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  if (!slot) return -1; /* no space */</a>
<a name="ln303">  if (slot-&gt;msg.id == msg.id &amp;&amp; slot-&gt;used) return 0;  /* duplicate key */</a>
<a name="ln304">  slot-&gt;msg = msg;</a>
<a name="ln305">  slot-&gt;used = 1;</a>
<a name="ln306">  return 1;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static int mpack_rpc_pop(mpack_rpc_session_t *session, mpack_rpc_message_t *msg)</a>
<a name="ln310">{</a>
<a name="ln311">  struct mpack_rpc_slot_s *slot = NULL;</a>
<a name="ln312">  mpack_uint32_t i;</a>
<a name="ln313">  mpack_uint32_t hash = msg-&gt;id % session-&gt;capacity;</a>
<a name="ln314"> </a>
<a name="ln315">  for (i = 0; i &lt; session-&gt;capacity; i++) {</a>
<a name="ln316">    if (session-&gt;slots[hash].used &amp;&amp; session-&gt;slots[hash].msg.id == msg-&gt;id) {</a>
<a name="ln317">      slot = session-&gt;slots + hash;</a>
<a name="ln318">      break;</a>
<a name="ln319">    }</a>
<a name="ln320">    hash = hash &gt; 0 ? hash - 1 : session-&gt;capacity - 1;</a>
<a name="ln321">  }</a>
<a name="ln322">  </a>
<a name="ln323">  if (!slot) return 0;</a>
<a name="ln324"> </a>
<a name="ln325">  *msg = slot-&gt;msg;</a>
<a name="ln326">  slot-&gt;used = 0;</a>
<a name="ln327"> </a>
<a name="ln328">  return 1;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">static void mpack_rpc_reset_hdr(mpack_rpc_header_t *hdr)</a>
<a name="ln332">{</a>
<a name="ln333">  hdr-&gt;index = 0;</a>
<a name="ln334">}</a>
</code></pre>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memcpy' function will lead to underflow of the buffer 'dst'.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memcpy' function will lead to underflow of the buffer 'src'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>