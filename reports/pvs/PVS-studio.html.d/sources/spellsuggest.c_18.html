<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spellsuggest.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spellsuggest.c: functions for spelling suggestions</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;limits.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln16">#include &quot;nvim/change.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln23">#include &quot;nvim/garray.h&quot;</a>
<a name="ln24">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln25">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln26">#include &quot;nvim/globals.h&quot;</a>
<a name="ln27">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln28">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln29">#include &quot;nvim/input.h&quot;</a>
<a name="ln30">#include &quot;nvim/macros.h&quot;</a>
<a name="ln31">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln32">#include &quot;nvim/memline.h&quot;</a>
<a name="ln33">#include &quot;nvim/memory.h&quot;</a>
<a name="ln34">#include &quot;nvim/message.h&quot;</a>
<a name="ln35">#include &quot;nvim/normal.h&quot;</a>
<a name="ln36">#include &quot;nvim/option.h&quot;</a>
<a name="ln37">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln38">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln39">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln40">#include &quot;nvim/pos.h&quot;</a>
<a name="ln41">#include &quot;nvim/profile.h&quot;</a>
<a name="ln42">#include &quot;nvim/spell.h&quot;</a>
<a name="ln43">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln44">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln45">#include &quot;nvim/strings.h&quot;</a>
<a name="ln46">#include &quot;nvim/types.h&quot;</a>
<a name="ln47">#include &quot;nvim/ui.h&quot;</a>
<a name="ln48">#include &quot;nvim/undo.h&quot;</a>
<a name="ln49">#include &quot;nvim/vim.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln52">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln53">// it for every possible suggestion.</a>
<a name="ln54">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln55">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln56">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln57">#define RESCORE(word_score, sound_score) ((3 * (word_score) + (sound_score)) / 4)</a>
<a name="ln58"> </a>
<a name="ln59">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln60">// compute the maximum word score that can be used.</a>
<a name="ln61">#define MAXSCORE(word_score, sound_score) ((4 * (word_score) - (sound_score)) / 3)</a>
<a name="ln62"> </a>
<a name="ln63">// only used for su_badflags</a>
<a name="ln64">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln65"> </a>
<a name="ln66">/// Information used when looking for suggestions.</a>
<a name="ln67">typedef struct suginfo_S {</a>
<a name="ln68">  garray_T su_ga;                  ///&lt; suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln69">  int su_maxcount;                 ///&lt; max. number of suggestions displayed</a>
<a name="ln70">  int su_maxscore;                 ///&lt; maximum score for adding to su_ga</a>
<a name="ln71">  int su_sfmaxscore;               ///&lt; idem, for when doing soundfold words</a>
<a name="ln72">  garray_T su_sga;                 ///&lt; like su_ga, sound-folded scoring</a>
<a name="ln73">  char *su_badptr;                 ///&lt; start of bad word in line</a>
<a name="ln74">  int su_badlen;                   ///&lt; length of detected bad word in line</a>
<a name="ln75">  int su_badflags;                 ///&lt; caps flags for bad word</a>
<a name="ln76">  char su_badword[MAXWLEN];        ///&lt; bad word truncated at su_badlen</a>
<a name="ln77">  char su_fbadword[MAXWLEN];       ///&lt; su_badword case-folded</a>
<a name="ln78">  char su_sal_badword[MAXWLEN];    ///&lt; su_badword soundfolded</a>
<a name="ln79">  hashtab_T su_banned;             ///&lt; table with banned words</a>
<a name="ln80">  slang_T *su_sallang;             ///&lt; default language for sound folding</a>
<a name="ln81">} suginfo_T;</a>
<a name="ln82"> </a>
<a name="ln83">/// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln84">typedef struct {</a>
<a name="ln85">  char *st_word;      ///&lt; suggested word, allocated string</a>
<a name="ln86">  int st_wordlen;     ///&lt; strlen(st_word)</a>
<a name="ln87">  int st_orglen;      ///&lt; length of replaced text</a>
<a name="ln88">  int st_score;       ///&lt; lower is better</a>
<a name="ln89">  int st_altscore;    ///&lt; used when st_score compares equal</a>
<a name="ln90">  bool st_salscore;   ///&lt; st_score is for soundalike</a>
<a name="ln91">  bool st_had_bonus;  ///&lt; bonus already included in score</a>
<a name="ln92">  slang_T *st_slang;  ///&lt; language used for sound folding</a>
<a name="ln93">} suggest_T;</a>
<a name="ln94"> </a>
<a name="ln95">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln96"> </a>
<a name="ln97">// True if a word appears in the list of banned words.</a>
<a name="ln98">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;(su)-&gt;su_banned, word)))</a>
<a name="ln99"> </a>
<a name="ln100">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln101">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln102">// may change and wrong suggestions may be removed later.</a>
<a name="ln103">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln104">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln105"> </a>
<a name="ln106">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln107">// of suggestions that are not going to be displayed.</a>
<a name="ln108">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln109"> </a>
<a name="ln110">// score for various changes</a>
<a name="ln111">enum {</a>
<a name="ln112">  SCORE_SPLIT = 149,     // split bad word</a>
<a name="ln113">  SCORE_SPLIT_NO = 249,  // split bad word with NOSPLITSUGS</a>
<a name="ln114">  SCORE_ICASE = 52,      // slightly different case</a>
<a name="ln115">  SCORE_REGION = 200,    // word is for different region</a>
<a name="ln116">  SCORE_RARE = 180,      // rare word</a>
<a name="ln117">  SCORE_SWAP = 75,       // swap two characters</a>
<a name="ln118">  SCORE_SWAP3 = 110,     // swap two characters in three</a>
<a name="ln119">  SCORE_REP = 65,        // REP replacement</a>
<a name="ln120">  SCORE_SUBST = 93,      // substitute a character</a>
<a name="ln121">  SCORE_SIMILAR = 33,    // substitute a similar character</a>
<a name="ln122">  SCORE_SUBCOMP = 33,    // substitute a composing character</a>
<a name="ln123">  SCORE_DEL = 94,        // delete a character</a>
<a name="ln124">  SCORE_DELDUP = 66,     // delete a duplicated character</a>
<a name="ln125">  SCORE_DELCOMP = 28,    // delete a composing character</a>
<a name="ln126">  SCORE_INS = 96,        // insert a character</a>
<a name="ln127">  SCORE_INSDUP = 67,     // insert a duplicate character</a>
<a name="ln128">  SCORE_INSCOMP = 30,    // insert a composing character</a>
<a name="ln129">  SCORE_NONWORD = 103,   // change non-word to word char</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">enum {</a>
<a name="ln133">  SCORE_FILE = 30,      // suggestion from a file</a>
<a name="ln134">  SCORE_MAXINIT = 350,  // Initial maximum score: higher == slower.</a>
<a name="ln135">                        // 350 allows for about three changes.</a>
<a name="ln136">};</a>
<a name="ln137"> </a>
<a name="ln138">enum {</a>
<a name="ln139">  SCORE_COMMON1 = 30,  // subtracted for words seen before</a>
<a name="ln140">  SCORE_COMMON2 = 40,  // subtracted for words often seen</a>
<a name="ln141">  SCORE_COMMON3 = 50,  // subtracted for words very often seen</a>
<a name="ln142">  SCORE_THRES2 = 10,   // word count threshold for COMMON2</a>
<a name="ln143">  SCORE_THRES3 = 100,  // word count threshold for COMMON3</a>
<a name="ln144">};</a>
<a name="ln145"> </a>
<a name="ln146">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln147">// two changes.  With less than two changes it's slightly faster but we miss a</a>
<a name="ln148">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln149">enum {</a>
<a name="ln150">  SCORE_SFMAX1 = 200,  // maximum score for first try</a>
<a name="ln151">  SCORE_SFMAX2 = 300,  // maximum score for second try</a>
<a name="ln152">  SCORE_SFMAX3 = 400,  // maximum score for third try</a>
<a name="ln153">};</a>
<a name="ln154"> </a>
<a name="ln155">#define SCORE_BIG       (SCORE_INS * 3)  // big difference</a>
<a name="ln156">enum {</a>
<a name="ln157">  SCORE_MAXMAX = 999999,  // accept any score</a>
<a name="ln158">  SCORE_LIMITMAX = 350,   // for spell_edit_score_limit()</a>
<a name="ln159">};</a>
<a name="ln160"> </a>
<a name="ln161">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln162">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln163">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln164"> </a>
<a name="ln165">/// For finding suggestions: At each node in the tree these states are tried:</a>
<a name="ln166">typedef enum {</a>
<a name="ln167">  STATE_START = 0,  ///&lt; At start of node check for NUL bytes (goodword</a>
<a name="ln168">                    ///&lt; ends); if badword ends there is a match, otherwise</a>
<a name="ln169">                    ///&lt; try splitting word.</a>
<a name="ln170">  STATE_NOPREFIX,   ///&lt; try without prefix</a>
<a name="ln171">  STATE_SPLITUNDO,  ///&lt; Undo splitting.</a>
<a name="ln172">  STATE_ENDNUL,     ///&lt; Past NUL bytes at start of the node.</a>
<a name="ln173">  STATE_PLAIN,      ///&lt; Use each byte of the node.</a>
<a name="ln174">  STATE_DEL,        ///&lt; Delete a byte from the bad word.</a>
<a name="ln175">  STATE_INS_PREP,   ///&lt; Prepare for inserting bytes.</a>
<a name="ln176">  STATE_INS,        ///&lt; Insert a byte in the bad word.</a>
<a name="ln177">  STATE_SWAP,       ///&lt; Swap two bytes.</a>
<a name="ln178">  STATE_UNSWAP,     ///&lt; Undo swap two characters.</a>
<a name="ln179">  STATE_SWAP3,      ///&lt; Swap two characters over three.</a>
<a name="ln180">  STATE_UNSWAP3,    ///&lt; Undo Swap two characters over three.</a>
<a name="ln181">  STATE_UNROT3L,    ///&lt; Undo rotate three characters left</a>
<a name="ln182">  STATE_UNROT3R,    ///&lt; Undo rotate three characters right</a>
<a name="ln183">  STATE_REP_INI,    ///&lt; Prepare for using REP items.</a>
<a name="ln184">  STATE_REP,        ///&lt; Use matching REP items from the .aff file.</a>
<a name="ln185">  STATE_REP_UNDO,   ///&lt; Undo a REP item replacement.</a>
<a name="ln186">  STATE_FINAL,      ///&lt; End of this node.</a>
<a name="ln187">} state_T;</a>
<a name="ln188"> </a>
<a name="ln189">/// Struct to keep the state at each level in suggest_try_change().</a>
<a name="ln190">typedef struct trystate_S {</a>
<a name="ln191">  state_T ts_state;          ///&lt; state at this level, STATE_</a>
<a name="ln192">  int ts_score;              ///&lt; score</a>
<a name="ln193">  idx_T ts_arridx;           ///&lt; index in tree array, start of node</a>
<a name="ln194">  int16_t ts_curi;           ///&lt; index in list of child nodes</a>
<a name="ln195">  uint8_t ts_fidx;           ///&lt; index in fword[], case-folded bad word</a>
<a name="ln196">  uint8_t ts_fidxtry;        ///&lt; ts_fidx at which bytes may be changed</a>
<a name="ln197">  uint8_t ts_twordlen;       ///&lt; valid length of tword[]</a>
<a name="ln198">  uint8_t ts_prefixdepth;    ///&lt; stack depth for end of prefix or</a>
<a name="ln199">                             ///&lt; PFD_PREFIXTREE or PFD_NOPREFIX</a>
<a name="ln200">  uint8_t ts_flags;          ///&lt; TSF_ flags</a>
<a name="ln201">  uint8_t ts_tcharlen;       ///&lt; number of bytes in tword character</a>
<a name="ln202">  uint8_t ts_tcharidx;       ///&lt; current byte index in tword character</a>
<a name="ln203">  uint8_t ts_isdiff;         ///&lt; DIFF_ values</a>
<a name="ln204">  uint8_t ts_fcharstart;     ///&lt; index in fword where badword char started</a>
<a name="ln205">  uint8_t ts_prewordlen;     ///&lt; length of word in &quot;preword[]&quot;</a>
<a name="ln206">  uint8_t ts_splitoff;       ///&lt; index in &quot;tword&quot; after last split</a>
<a name="ln207">  uint8_t ts_splitfidx;      ///&lt; &quot;ts_fidx&quot; at word split</a>
<a name="ln208">  uint8_t ts_complen;        ///&lt; nr of compound words used</a>
<a name="ln209">  uint8_t ts_compsplit;      ///&lt; index for &quot;compflags&quot; where word was spit</a>
<a name="ln210">  uint8_t ts_save_badflags;  ///&lt; su_badflags saved here</a>
<a name="ln211">  uint8_t ts_delidx;         ///&lt; index in fword for char that was deleted,</a>
<a name="ln212">                             ///&lt; valid when &quot;ts_flags&quot; has TSF_DIDDEL</a>
<a name="ln213">} trystate_T;</a>
<a name="ln214"> </a>
<a name="ln215">// values for ts_isdiff</a>
<a name="ln216">enum {</a>
<a name="ln217">  DIFF_NONE = 0,    // no different byte (yet)</a>
<a name="ln218">  DIFF_YES = 1,     // different byte found</a>
<a name="ln219">  DIFF_INSERT = 2,  // inserting character</a>
<a name="ln220">};</a>
<a name="ln221"> </a>
<a name="ln222">// values for ts_flags</a>
<a name="ln223">enum {</a>
<a name="ln224">  TSF_PREFIXOK = 1,  // already checked that prefix is OK</a>
<a name="ln225">  TSF_DIDSPLIT = 2,  // tried split at this point</a>
<a name="ln226">  TSF_DIDDEL = 4,    // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln227">};</a>
<a name="ln228"> </a>
<a name="ln229">// special values ts_prefixdepth</a>
<a name="ln230">enum {</a>
<a name="ln231">  PFD_NOPREFIX = 0xff,    // not using prefixes</a>
<a name="ln232">  PFD_PREFIXTREE = 0xfe,  // walking through the prefix tree</a>
<a name="ln233">  PFD_NOTSPECIAL = 0xfd,  // highest value that's not special</a>
<a name="ln234">};</a>
<a name="ln235"> </a>
<a name="ln236">static long spell_suggest_timeout = 5000;</a>
<a name="ln237"> </a>
<a name="ln238">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln239"># include &quot;spellsuggest.c.generated.h&quot;</a>
<a name="ln240">#endif</a>
<a name="ln241"> </a>
<a name="ln242">/// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln243">/// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln244">/// lines if they don't contain wildcards.</a>
<a name="ln245">static bool can_be_compound(trystate_T *sp, slang_T *slang, uint8_t *compflags, int flag)</a>
<a name="ln246">{</a>
<a name="ln247">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln248">  // then it can't possibly compound.</a>
<a name="ln249">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln250">                   ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag)) {</a>
<a name="ln251">    return false;</a>
<a name="ln252">  }</a>
<a name="ln253"> </a>
<a name="ln254">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln255">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln256">  // makes sense when we have two or more words.</a>
<a name="ln257">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln258">    compflags[sp-&gt;ts_complen] = (uint8_t)flag;</a>
<a name="ln259">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln260">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln261">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln262">    return v;</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  return true;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/// Adjust the score of common words.</a>
<a name="ln269">///</a>
<a name="ln270">/// @param split  word was split, less bonus</a>
<a name="ln271">static int score_wordcount_adj(slang_T *slang, int score, char *word, bool split)</a>
<a name="ln272">{</a>
<a name="ln273">  int bonus;</a>
<a name="ln274">  int newscore;</a>
<a name="ln275"> </a>
<a name="ln276">  hashitem_T *hi = hash_find(&amp;slang-&gt;sl_wordcount, word);</a>
<a name="ln277">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln278">    return score;</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  wordcount_T *wc = HI2WC(hi);</a>
<a name="ln282">  if (wc-&gt;wc_count &lt; SCORE_THRES2) {</a>
<a name="ln283">    bonus = SCORE_COMMON1;</a>
<a name="ln284">  } else if (wc-&gt;wc_count &lt; SCORE_THRES3) {</a>
<a name="ln285">    bonus = SCORE_COMMON2;</a>
<a name="ln286">  } else {</a>
<a name="ln287">    bonus = SCORE_COMMON3;</a>
<a name="ln288">  }</a>
<a name="ln289">  if (split) {</a>
<a name="ln290">    newscore = score - bonus / 2;</a>
<a name="ln291">  } else {</a>
<a name="ln292">    newscore = score - bonus;</a>
<a name="ln293">  }</a>
<a name="ln294">  if (newscore &lt; 0) {</a>
<a name="ln295">    return 0;</a>
<a name="ln296">  }</a>
<a name="ln297">  return newscore;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">/// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln301">/// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln302">/// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln303">static int badword_captype(char *word, char *end)</a>
<a name="ln304">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln305">{</a>
<a name="ln306">  int flags = captype(word, end);</a>
<a name="ln307"> </a>
<a name="ln308">  if (!(flags &amp; WF_KEEPCAP)) {</a>
<a name="ln309">    return flags;</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  // Count the number of UPPER and lower case letters.</a>
<a name="ln313">  int l= 0;</a>
<a name="ln314">  int u= 0;</a>
<a name="ln315">  bool first = false;</a>
<a name="ln316">  for (char *p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln317">    int c = utf_ptr2char(p);</a>
<a name="ln318">    if (SPELL_ISUPPER(c)) {</a>
<a name="ln319">      u++;</a>
<a name="ln320">      if (p == word) {</a>
<a name="ln321">        first = true;</a>
<a name="ln322">      }</a>
<a name="ln323">    } else {</a>
<a name="ln324">      l++;</a>
<a name="ln325">    }</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  // If there are more UPPER than lower case letters suggest an</a>
<a name="ln329">  // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln330">  // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln331">  // require three upper case letters.</a>
<a name="ln332">  if (u &gt; l &amp;&amp; u &gt; 2) {</a>
<a name="ln333">    flags |= WF_ALLCAP;</a>
<a name="ln334">  } else if (first) {</a>
<a name="ln335">    flags |= WF_ONECAP;</a>
<a name="ln336">  }</a>
<a name="ln337"> </a>
<a name="ln338">  if (u &gt;= 2 &amp;&amp; l &gt;= 2) {     // maCARONI maCAroni</a>
<a name="ln339">    flags |= WF_MIXCAP;</a>
<a name="ln340">  }</a>
<a name="ln341"> </a>
<a name="ln342">  return flags;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">/// Opposite of offset2bytes().</a>
<a name="ln346">/// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln347">///</a>
<a name="ln348">/// @return  the offset.</a>
<a name="ln349">static int bytes2offset(char **pp)</a>
<a name="ln350">{</a>
<a name="ln351">  uint8_t *p = (uint8_t *)(*pp);</a>
<a name="ln352">  int nr;</a>
<a name="ln353"> </a>
<a name="ln354">  int c = *p++;</a>
<a name="ln355">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln356">    nr = c - 1;</a>
<a name="ln357">  } else if ((c &amp; 0xc0) == 0x80) {      // 2 bytes</a>
<a name="ln358">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln359">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln360">  } else if ((c &amp; 0xe0) == 0xc0) {      // 3 bytes</a>
<a name="ln361">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln362">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln363">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln364">  } else {                              // 4 bytes</a>
<a name="ln365">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln366">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln367">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln368">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  *pp = (char *)p;</a>
<a name="ln372">  return nr;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">// values for sps_flags</a>
<a name="ln376">enum {</a>
<a name="ln377">  SPS_BEST = 1,</a>
<a name="ln378">  SPS_FAST = 2,</a>
<a name="ln379">  SPS_DOUBLE = 4,</a>
<a name="ln380">};</a>
<a name="ln381"> </a>
<a name="ln382">static int sps_flags = SPS_BEST;  ///&lt; flags from 'spellsuggest'</a>
<a name="ln383">static int sps_limit = 9999;      ///&lt; max nr of suggestions given</a>
<a name="ln384"> </a>
<a name="ln385">/// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln386">/// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln387">int spell_check_sps(void)</a>
<a name="ln388">{</a>
<a name="ln389">  char *s;</a>
<a name="ln390">  char buf[MAXPATHL];</a>
<a name="ln391"> </a>
<a name="ln392">  sps_flags = 0;</a>
<a name="ln393">  sps_limit = 9999;</a>
<a name="ln394"> </a>
<a name="ln395">  for (char *p = p_sps; *p != NUL;) {</a>
<a name="ln396">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln397"> </a>
<a name="ln398">    int f = 0;</a>
<a name="ln399">    if (ascii_isdigit(*buf)) {</a>
<a name="ln400">      s = buf;</a>
<a name="ln401">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln402">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln403">        f = -1;</a>
<a name="ln404">      }</a>
<a name="ln405">    } else if (strcmp(buf, &quot;best&quot;) == 0) {</a>
<a name="ln406">      f = SPS_BEST;</a>
<a name="ln407">    } else if (strcmp(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln408">      f = SPS_FAST;</a>
<a name="ln409">    } else if (strcmp(buf, &quot;double&quot;) == 0) {</a>
<a name="ln410">      f = SPS_DOUBLE;</a>
<a name="ln411">    } else if (strncmp(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln412">               &amp;&amp; strncmp(buf, &quot;file:&quot;, 5) != 0</a>
<a name="ln413">               &amp;&amp; (strncmp(buf, &quot;timeout:&quot;, 8) != 0</a>
<a name="ln414">                   || (!ascii_isdigit(buf[8])</a>
<a name="ln415">                       &amp;&amp; !(buf[8] == '-' &amp;&amp; ascii_isdigit(buf[9]))))) {</a>
<a name="ln416">      f = -1;</a>
<a name="ln417">    }</a>
<a name="ln418"> </a>
<a name="ln419">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln420">      sps_flags = SPS_BEST;</a>
<a name="ln421">      sps_limit = 9999;</a>
<a name="ln422">      return FAIL;</a>
<a name="ln423">    }</a>
<a name="ln424">    if (f != 0) {</a>
<a name="ln425">      sps_flags = f;</a>
<a name="ln426">    }</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  if (sps_flags == 0) {</a>
<a name="ln430">    sps_flags = SPS_BEST;</a>
<a name="ln431">  }</a>
<a name="ln432"> </a>
<a name="ln433">  return OK;</a>
<a name="ln434">}</a>
<a name="ln435"> </a>
<a name="ln436">/// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln437">/// Give suggestions for the properly spelled word.</a>
<a name="ln438">/// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln439">/// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln440">void spell_suggest(int count)</a>
<a name="ln441">{</a>
<a name="ln442">  char *line;</a>
<a name="ln443">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln444">  char wcopy[MAXWLEN + 2];</a>
<a name="ln445">  char *p;</a>
<a name="ln446">  suginfo_T sug;</a>
<a name="ln447">  suggest_T *stp;</a>
<a name="ln448">  int mouse_used;</a>
<a name="ln449">  int limit;</a>
<a name="ln450">  int selected = count;</a>
<a name="ln451">  int badlen = 0;</a>
<a name="ln452">  int msg_scroll_save = msg_scroll;</a>
<a name="ln453">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln454"> </a>
<a name="ln455">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln456">    parse_spelllang(curwin);</a>
<a name="ln457">    curwin-&gt;w_p_spell = true;</a>
<a name="ln458">  }</a>
<a name="ln459"> </a>
<a name="ln460">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln461">    emsg(_(e_no_spell));</a>
<a name="ln462">    return;</a>
<a name="ln463">  }</a>
<a name="ln464"> </a>
<a name="ln465">  if (VIsual_active) {</a>
<a name="ln466">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln467">    // a multi-line selection.</a>
<a name="ln468">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln469">      vim_beep(BO_SPELL);</a>
<a name="ln470">      return;</a>
<a name="ln471">    }</a>
<a name="ln472">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln473">    if (badlen &lt; 0) {</a>
<a name="ln474">      badlen = -badlen;</a>
<a name="ln475">    } else {</a>
<a name="ln476">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln477">    }</a>
<a name="ln478">    badlen++;</a>
<a name="ln479">    end_visual_mode();</a>
<a name="ln480">    // make sure we don't include the NUL at the end of the line</a>
<a name="ln481">    line = get_cursor_line_ptr();</a>
<a name="ln482">    if (badlen &gt; (int)strlen(line) - (int)curwin-&gt;w_cursor.col) {</a>
<a name="ln483">      badlen = (int)strlen(line) - (int)curwin-&gt;w_cursor.col;</a>
<a name="ln484">    }</a>
<a name="ln485">    // Find the start of the badly spelled word.</a>
<a name="ln486">  } else if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln487">             || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln488">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln489">    // cursor.</a>
<a name="ln490">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln491">    line = get_cursor_line_ptr();</a>
<a name="ln492">    p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln493">    // Backup to before start of word.</a>
<a name="ln494">    while (p &gt; line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln495">      MB_PTR_BACK(line, p);</a>
<a name="ln496">    }</a>
<a name="ln497">    // Forward to start of word.</a>
<a name="ln498">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln499">      MB_PTR_ADV(p);</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln503">      beep_flush();</a>
<a name="ln504">      return;</a>
<a name="ln505">    }</a>
<a name="ln506">    curwin-&gt;w_cursor.col = (colnr_T)(p - line);</a>
<a name="ln507">  }</a>
<a name="ln508"> </a>
<a name="ln509">  // Get the word and its length.</a>
<a name="ln510"> </a>
<a name="ln511">  // Figure out if the word should be capitalised.</a>
<a name="ln512">  int need_cap = check_need_cap(curwin, curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln513"> </a>
<a name="ln514">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln515">  line = xstrdup(get_cursor_line_ptr());</a>
<a name="ln516">  spell_suggest_timeout = 5000;</a>
<a name="ln517"> </a>
<a name="ln518">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln519">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln520">  if (sps_limit &gt; Rows - 2) {</a>
<a name="ln521">    limit = Rows - 2;</a>
<a name="ln522">  } else {</a>
<a name="ln523">    limit = sps_limit;</a>
<a name="ln524">  }</a>
<a name="ln525">  spell_find_suggest(line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln526">                     true, need_cap, true);</a>
<a name="ln527"> </a>
<a name="ln528">  if (GA_EMPTY(&amp;sug.su_ga)) {</a>
<a name="ln529">    msg(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln530">  } else if (count &gt; 0) {</a>
<a name="ln531">    if (count &gt; sug.su_ga.ga_len) {</a>
<a name="ln532">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln533">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln534">    }</a>
<a name="ln535">  } else {</a>
<a name="ln536">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln537">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln538">    if (cmdmsg_rl) {</a>
<a name="ln539">      msg_col = Columns - 1;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    // List the suggestions.</a>
<a name="ln543">    msg_start();</a>
<a name="ln544">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln545">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln546">    vim_snprintf(IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln547">                 sug.su_badlen, sug.su_badptr);</a>
<a name="ln548">    if (cmdmsg_rl &amp;&amp; strncmp(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln549">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln550">      // untranslated message rightleft.</a>
<a name="ln551">      vim_snprintf(IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln552">                   sug.su_badlen, sug.su_badptr);</a>
<a name="ln553">    }</a>
<a name="ln554">    msg_puts(IObuff);</a>
<a name="ln555">    msg_clr_eos();</a>
<a name="ln556">    msg_putchar('\n');</a>
<a name="ln557"> </a>
<a name="ln558">    msg_scroll = true;</a>
<a name="ln559">    for (int i = 0; i &lt; sug.su_ga.ga_len; i++) {</a>
<a name="ln560">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln561"> </a>
<a name="ln562">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln563">      // the not replaced part.  But only when it's not getting too long.</a>
<a name="ln564">      xstrlcpy(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln565">      int el = sug.su_badlen - stp-&gt;st_orglen;</a>
<a name="ln566">      if (el &gt; 0 &amp;&amp; stp-&gt;st_wordlen + el &lt;= MAXWLEN) {</a>
<a name="ln567">        xstrlcpy(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen, (size_t)el + 1);</a>
<a name="ln568">      }</a>
<a name="ln569">      vim_snprintf(IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln570">      if (cmdmsg_rl) {</a>
<a name="ln571">        rl_mirror_ascii(IObuff);</a>
<a name="ln572">      }</a>
<a name="ln573">      msg_puts(IObuff);</a>
<a name="ln574"> </a>
<a name="ln575">      vim_snprintf(IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln576">      msg_puts(IObuff);</a>
<a name="ln577"> </a>
<a name="ln578">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln579">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln580">        vim_snprintf(IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln581">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln582">        msg_puts(IObuff);</a>
<a name="ln583">      }</a>
<a name="ln584"> </a>
<a name="ln585">      if (p_verbose &gt; 0) {</a>
<a name="ln586">        // Add the score.</a>
<a name="ln587">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST)) {</a>
<a name="ln588">          vim_snprintf(IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln589">                       stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln590">                       stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln591">        } else {</a>
<a name="ln592">          vim_snprintf(IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln593">                       stp-&gt;st_score);</a>
<a name="ln594">        }</a>
<a name="ln595">        if (cmdmsg_rl) {</a>
<a name="ln596">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln597">          rl_mirror_ascii(IObuff + 1);</a>
<a name="ln598">        }</a>
<a name="ln599">        msg_advance(30);</a>
<a name="ln600">        msg_puts(IObuff);</a>
<a name="ln601">      }</a>
<a name="ln602">      msg_putchar('\n');</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    cmdmsg_rl = false;</a>
<a name="ln606">    msg_col = 0;</a>
<a name="ln607">    // Ask for choice.</a>
<a name="ln608">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln609"> </a>
<a name="ln610">    if (ui_has(kUIMessages)) {</a>
<a name="ln611">      ui_call_msg_clear();</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    if (mouse_used) {</a>
<a name="ln615">      selected -= lines_left;</a>
<a name="ln616">    }</a>
<a name="ln617">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln618">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln619">    msg_scroll = msg_scroll_save;</a>
<a name="ln620">  }</a>
<a name="ln621"> </a>
<a name="ln622">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln623">    // Save the from and to text for :spellrepall.</a>
<a name="ln624">    XFREE_CLEAR(repl_from);</a>
<a name="ln625">    XFREE_CLEAR(repl_to);</a>
<a name="ln626"> </a>
<a name="ln627">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln628">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln629">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln630">      // repl_to.</a>
<a name="ln631">      repl_from = xstrnsave(sug.su_badptr, (size_t)sug.su_badlen);</a>
<a name="ln632">      vim_snprintf(IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln633">                   sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln634">                   sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln635">      repl_to = xstrdup(IObuff);</a>
<a name="ln636">    } else {</a>
<a name="ln637">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln638">      repl_from = xstrnsave(sug.su_badptr, (size_t)stp-&gt;st_orglen);</a>
<a name="ln639">      repl_to = xstrdup(stp-&gt;st_word);</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    // Replace the word.</a>
<a name="ln643">    p = xmalloc(strlen(line) - (size_t)stp-&gt;st_orglen + (size_t)stp-&gt;st_wordlen + 1);</a>
<a name="ln644">    int c = (int)(sug.su_badptr - line);</a>
<a name="ln645">    memmove(p, line, (size_t)c);</a>
<a name="ln646">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln647">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln648"> </a>
<a name="ln649">    // For redo we use a change-word command.</a>
<a name="ln650">    ResetRedobuff();</a>
<a name="ln651">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln652">    AppendToRedobuffLit(p + c,</a>
<a name="ln653">                        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln654">    AppendCharToRedobuff(ESC);</a>
<a name="ln655"> </a>
<a name="ln656">    // &quot;p&quot; may be freed here</a>
<a name="ln657">    ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln658">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln659"> </a>
<a name="ln660">    inserted_bytes(curwin-&gt;w_cursor.lnum, c, stp-&gt;st_orglen, stp-&gt;st_wordlen);</a>
<a name="ln661">  } else {</a>
<a name="ln662">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln663">  }</a>
<a name="ln664"> </a>
<a name="ln665">  spell_find_cleanup(&amp;sug);</a>
<a name="ln666">  xfree(line);</a>
<a name="ln667">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">/// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln671">/// a list of allocated strings.</a>
<a name="ln672">///</a>
<a name="ln673">/// @param maxcount  maximum nr of suggestions</a>
<a name="ln674">/// @param need_cap  'spellcapcheck' matched</a>
<a name="ln675">void spell_suggest_list(garray_T *gap, char *word, int maxcount, bool need_cap, bool interactive)</a>
<a name="ln676">{</a>
<a name="ln677">  suginfo_T sug;</a>
<a name="ln678">  char *wcopy;</a>
<a name="ln679"> </a>
<a name="ln680">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln681"> </a>
<a name="ln682">  // Make room in &quot;gap&quot;.</a>
<a name="ln683">  ga_init(gap, sizeof(char *), sug.su_ga.ga_len + 1);</a>
<a name="ln684">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln685">  for (int i = 0; i &lt; sug.su_ga.ga_len; i++) {</a>
<a name="ln686">    suggest_T *stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln687"> </a>
<a name="ln688">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln689">    // replaced part.</a>
<a name="ln690">    wcopy = xmalloc((size_t)stp-&gt;st_wordlen + strlen(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln691">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln692">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln693">    ((char **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  spell_find_cleanup(&amp;sug);</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">/// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln700">/// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln701">/// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln702">/// Note: does use info for the current window.</a>
<a name="ln703">/// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln704">///</a>
<a name="ln705">/// @param badlen  length of bad word or 0 if unknown</a>
<a name="ln706">/// @param banbadword  don't include badword in suggestions</a>
<a name="ln707">/// @param need_cap  word should start with capital</a>
<a name="ln708">static void spell_find_suggest(char *badptr, int badlen, suginfo_T *su, int maxcount,</a>
<a name="ln709">                               bool banbadword, bool need_cap, bool interactive)</a>
<a name="ln710">{</a>
<a name="ln711">  hlf_T attr = HLF_COUNT;</a>
<a name="ln712">  char buf[MAXPATHL];</a>
<a name="ln713">  bool do_combine = false;</a>
<a name="ln714">  static bool expr_busy = false;</a>
<a name="ln715">  langp_T *lp;</a>
<a name="ln716">  bool did_intern = false;</a>
<a name="ln717"> </a>
<a name="ln718">  // Set the info in &quot;*su&quot;.</a>
<a name="ln719">  CLEAR_POINTER(su);</a>
<a name="ln720">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln721">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln722">  if (*badptr == NUL) {</a>
<a name="ln723">    return;</a>
<a name="ln724">  }</a>
<a name="ln725">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln726"> </a>
<a name="ln727">  su-&gt;su_badptr = badptr;</a>
<a name="ln728">  if (badlen != 0) {</a>
<a name="ln729">    su-&gt;su_badlen = badlen;</a>
<a name="ln730">  } else {</a>
<a name="ln731">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln732">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln733">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln734">  }</a>
<a name="ln735">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln736">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln737"> </a>
<a name="ln738">  if (su-&gt;su_badlen &gt;= MAXWLEN) {</a>
<a name="ln739">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln740">  }</a>
<a name="ln741">  xstrlcpy(su-&gt;su_badword, su-&gt;su_badptr, (size_t)su-&gt;su_badlen + 1);</a>
<a name="ln742">  (void)spell_casefold(curwin, su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword,</a>
<a name="ln743">                       MAXWLEN);</a>
<a name="ln744"> </a>
<a name="ln745">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln746">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln747">  // computations.</a>
<a name="ln748">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln749"> </a>
<a name="ln750">  // get caps flags for bad word</a>
<a name="ln751">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln752">                                    su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln753">  if (need_cap) {</a>
<a name="ln754">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln755">  }</a>
<a name="ln756"> </a>
<a name="ln757">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln758">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln759">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln760">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln761">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; i++) {</a>
<a name="ln762">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln763">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln764">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln765">      break;</a>
<a name="ln766">    }</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln770">  // have to do this many times.</a>
<a name="ln771">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln772">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln773">                    su-&gt;su_sal_badword);</a>
<a name="ln774">  }</a>
<a name="ln775"> </a>
<a name="ln776">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln777">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln778">  // for that.</a>
<a name="ln779">  int c = utf_ptr2char(su-&gt;su_badptr);</a>
<a name="ln780">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln781">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln782">    add_suggestion(su, &amp;su-&gt;su_ga, buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln783">                   0, true, su-&gt;su_sallang, false);</a>
<a name="ln784">  }</a>
<a name="ln785"> </a>
<a name="ln786">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln787">  if (banbadword) {</a>
<a name="ln788">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln789">  }</a>
<a name="ln790"> </a>
<a name="ln791">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln792">  char *sps_copy = xstrdup(p_sps);</a>
<a name="ln793"> </a>
<a name="ln794">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln795">  for (char *p = sps_copy; *p != NUL;) {</a>
<a name="ln796">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln797"> </a>
<a name="ln798">    if (strncmp(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln799">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln800">      // when using spellsuggest() in the expression.</a>
<a name="ln801">      if (!expr_busy) {</a>
<a name="ln802">        expr_busy = true;</a>
<a name="ln803">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln804">        expr_busy = false;</a>
<a name="ln805">      }</a>
<a name="ln806">    } else if (strncmp(buf, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln807">      // Use list of suggestions in a file.</a>
<a name="ln808">      spell_suggest_file(su, buf + 5);</a>
<a name="ln809">    } else if (strncmp(buf, &quot;timeout:&quot;, 8) == 0) {</a>
<a name="ln810">      // Limit the time searching for suggestions.</a>
<a name="ln811">      spell_suggest_timeout = atol(buf + 8);</a>
<a name="ln812">    } else if (!did_intern) {</a>
<a name="ln813">      // Use internal method once.</a>
<a name="ln814">      spell_suggest_intern(su, interactive);</a>
<a name="ln815">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln816">        do_combine = true;</a>
<a name="ln817">      }</a>
<a name="ln818">      did_intern = true;</a>
<a name="ln819">    }</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822">  xfree(sps_copy);</a>
<a name="ln823"> </a>
<a name="ln824">  if (do_combine) {</a>
<a name="ln825">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln826">    // because sorting changes the order again.</a>
<a name="ln827">    score_combine(su);</a>
<a name="ln828">  }</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">/// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln832">static void spell_suggest_expr(suginfo_T *su, char *expr)</a>
<a name="ln833">{</a>
<a name="ln834">  const char *p;</a>
<a name="ln835"> </a>
<a name="ln836">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln837">  // suginfo_T.</a>
<a name="ln838">  // First evaluate the expression and get the resulting list.</a>
<a name="ln839">  list_T *const list = eval_spell_expr(su-&gt;su_badword, expr);</a>
<a name="ln840">  if (list != NULL) {</a>
<a name="ln841">    // Loop over the items in the list.</a>
<a name="ln842">    TV_LIST_ITER(list, li, {</a>
<a name="ln843">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln844">        // Get the word and the score from the items.</a>
<a name="ln845">        int score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln846">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln847">          add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln848">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln849">        }</a>
<a name="ln850">      }</a>
<a name="ln851">    });</a>
<a name="ln852">    tv_list_unref(list);</a>
<a name="ln853">  }</a>
<a name="ln854"> </a>
<a name="ln855">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln856">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln857">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">/// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln861">static void spell_suggest_file(suginfo_T *su, char *fname)</a>
<a name="ln862">{</a>
<a name="ln863">  char line[MAXWLEN * 2];</a>
<a name="ln864">  int len;</a>
<a name="ln865">  char cword[MAXWLEN];</a>
<a name="ln866"> </a>
<a name="ln867">  // Open the file.</a>
<a name="ln868">  FILE *fd = os_fopen(fname, &quot;r&quot;);</a>
<a name="ln869">  if (fd == NULL) {</a>
<a name="ln870">    semsg(_(e_notopen), fname);</a>
<a name="ln871">    return;</a>
<a name="ln872">  }</a>
<a name="ln873"> </a>
<a name="ln874">  // Read it line by line.</a>
<a name="ln875">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln876">    line_breakcheck();</a>
<a name="ln877"> </a>
<a name="ln878">    char *p = vim_strchr(line, '/');</a>
<a name="ln879">    if (p == NULL) {</a>
<a name="ln880">      continue;             // No Tab found, just skip the line.</a>
<a name="ln881">    }</a>
<a name="ln882">    *p++ = NUL;</a>
<a name="ln883">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln884">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln885">      for (len = 0; (uint8_t)p[len] &gt;= ' '; len++) {}</a>
<a name="ln886">      p[len] = NUL;</a>
<a name="ln887"> </a>
<a name="ln888">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln889">      // of the bad word.</a>
<a name="ln890">      if (captype(p, NULL) == 0) {</a>
<a name="ln891">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln892">        p = cword;</a>
<a name="ln893">      }</a>
<a name="ln894"> </a>
<a name="ln895">      add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln896">                     SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln897">    }</a>
<a name="ln898">  }</a>
<a name="ln899"> </a>
<a name="ln900">  fclose(fd);</a>
<a name="ln901"> </a>
<a name="ln902">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln903">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln904">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">/// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln908">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln909">{</a>
<a name="ln910">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln911">  suggest_load_files();</a>
<a name="ln912"> </a>
<a name="ln913">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln914">  //</a>
<a name="ln915">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln916">  // tried.</a>
<a name="ln917">  suggest_try_special(su);</a>
<a name="ln918"> </a>
<a name="ln919">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln920">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln921">  suggest_try_change(su);</a>
<a name="ln922"> </a>
<a name="ln923">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln924">  if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln925">    score_comp_sal(su);</a>
<a name="ln926">  }</a>
<a name="ln927"> </a>
<a name="ln928">  // 3. Try finding sound-a-like words.</a>
<a name="ln929">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln930">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln931">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln932">      // they sounds like.</a>
<a name="ln933">      rescore_suggestions(su);</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln937">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln938">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln939">    // cleanup_suggestions().</a>
<a name="ln940">    // First find words with a small edit distance, because this is much</a>
<a name="ln941">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln942">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln943">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln944">    suggest_try_soundalike_prep();</a>
<a name="ln945">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln946">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln947">    suggest_try_soundalike(su);</a>
<a name="ln948">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln949">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln950">      // changes to the soundfold word.</a>
<a name="ln951">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln952">      suggest_try_soundalike(su);</a>
<a name="ln953">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln954">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln955">        // more changes to the soundfold word.</a>
<a name="ln956">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln957">        suggest_try_soundalike(su);</a>
<a name="ln958">      }</a>
<a name="ln959">    }</a>
<a name="ln960">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln961">    suggest_try_soundalike_finish();</a>
<a name="ln962">  }</a>
<a name="ln963"> </a>
<a name="ln964">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln965">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln966">  os_breakcheck();</a>
<a name="ln967">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln968">    (void)vgetc();</a>
<a name="ln969">    got_int = false;</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln973">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln974">      // Adjust the word score for how it sounds like.</a>
<a name="ln975">      rescore_suggestions(su);</a>
<a name="ln976">    }</a>
<a name="ln977"> </a>
<a name="ln978">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln979">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln980">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln981">  }</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984">/// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln985">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln986">{</a>
<a name="ln987">#define FREE_SUG_WORD(sug) xfree((sug)-&gt;st_word)</a>
<a name="ln988">  // Free the suggestions.</a>
<a name="ln989">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln990">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln991"> </a>
<a name="ln992">  // Free the banned words.</a>
<a name="ln993">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">/// Try finding suggestions by recognizing specific situations.</a>
<a name="ln997">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln998">{</a>
<a name="ln999">  char word[MAXWLEN];</a>
<a name="ln1000"> </a>
<a name="ln1001">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln1002">  char *p = skiptowhite(su-&gt;su_fbadword);</a>
<a name="ln1003">  size_t len = (size_t)(p - su-&gt;su_fbadword);</a>
<a name="ln1004">  p = skipwhite(p);</a>
<a name="ln1005">  if (strlen(p) == len &amp;&amp; strncmp(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln1006">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln1007">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln1008">    char c = su-&gt;su_fbadword[len];</a>
<a name="ln1009">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln1010">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln1011">    su-&gt;su_fbadword[len] = c;</a>
<a name="ln1012"> </a>
<a name="ln1013">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln1014">    // character.</a>
<a name="ln1015">    add_suggestion(su, &amp;su-&gt;su_ga, word, su-&gt;su_badlen,</a>
<a name="ln1016">                   RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln1017">  }</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">// Measure how much time is spent in each state.</a>
<a name="ln1021">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln1022"> </a>
<a name="ln1023">#ifdef SUGGEST_PROFILE</a>
<a name="ln1024">proftime_T current;</a>
<a name="ln1025">proftime_T total;</a>
<a name="ln1026">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln1027">long counts[STATE_FINAL + 1];</a>
<a name="ln1028"> </a>
<a name="ln1029">static void prof_init(void)</a>
<a name="ln1030">{</a>
<a name="ln1031">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln1032">    profile_zero(&amp;times[i]);</a>
<a name="ln1033">    counts[i] = 0;</a>
<a name="ln1034">  }</a>
<a name="ln1035">  profile_start(&amp;current);</a>
<a name="ln1036">  profile_start(&amp;total);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">/// call before changing state</a>
<a name="ln1040">static void prof_store(state_T state)</a>
<a name="ln1041">{</a>
<a name="ln1042">  profile_end(&amp;current);</a>
<a name="ln1043">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln1044">  counts[state]++;</a>
<a name="ln1045">  profile_start(&amp;current);</a>
<a name="ln1046">}</a>
<a name="ln1047"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln1048"> </a>
<a name="ln1049">static void prof_report(char *name)</a>
<a name="ln1050">{</a>
<a name="ln1051">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln1052"> </a>
<a name="ln1053">  profile_end(&amp;total);</a>
<a name="ln1054">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln1055">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln1056">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln1057">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln1058">  }</a>
<a name="ln1059">  fclose(fd);</a>
<a name="ln1060">}</a>
<a name="ln1061">#else</a>
<a name="ln1062"># define PROF_STORE(state)</a>
<a name="ln1063">#endif</a>
<a name="ln1064"> </a>
<a name="ln1065">/// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln1066">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln1067">{</a>
<a name="ln1068">  char fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln1069">  langp_T *lp;</a>
<a name="ln1070"> </a>
<a name="ln1071">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln1072">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln1073">  // chars after the bad word may help.</a>
<a name="ln1074">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln1075">  int n = (int)strlen(fword);</a>
<a name="ln1076">  char *p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln1077">  (void)spell_casefold(curwin, p, (int)strlen(p), fword + n, MAXWLEN - n);</a>
<a name="ln1078"> </a>
<a name="ln1079">  // Make sure the resulting text is not longer than the original text.</a>
<a name="ln1080">  n = (int)strlen(su-&gt;su_badptr);</a>
<a name="ln1081">  if (n &lt; MAXWLEN) {</a>
<a name="ln1082">    fword[n] = NUL;</a>
<a name="ln1083">  }</a>
<a name="ln1084"> </a>
<a name="ln1085">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln1086">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln1087"> </a>
<a name="ln1088">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln1089">    // everything has been cleared.</a>
<a name="ln1090">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL) {</a>
<a name="ln1091">      continue;</a>
<a name="ln1092">    }</a>
<a name="ln1093"> </a>
<a name="ln1094">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln1095">#ifdef SUGGEST_PROFILE</a>
<a name="ln1096">    prof_init();</a>
<a name="ln1097">#endif</a>
<a name="ln1098">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln1099">#ifdef SUGGEST_PROFILE</a>
<a name="ln1100">    prof_report(&quot;try_change&quot;);</a>
<a name="ln1101">#endif</a>
<a name="ln1102">  }</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln1106">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln1107">  ((depth) &lt; MAXWLEN - 1 &amp;&amp; (stack)[depth].ts_score + (add) &lt; (su)-&gt;su_maxscore)</a>
<a name="ln1108"> </a>
<a name="ln1109">/// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln1110">///</a>
<a name="ln1111">/// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln1112">/// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln1113">/// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln1114">/// character, replace one and delete another.  The number of changes is</a>
<a name="ln1115">/// limited by su-&gt;su_maxscore.</a>
<a name="ln1116">///</a>
<a name="ln1117">/// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln1118">/// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln1119">/// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln1120">/// The implementation in the article is simplified and requires a stack of</a>
<a name="ln1121">/// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln1122">/// the length of the word.</a>
<a name="ln1123">///</a>
<a name="ln1124">/// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln1125">/// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln1126">/// that comes from one or more original words.  Each of these words may be</a>
<a name="ln1127">/// added, this is done by add_sound_suggest().</a>
<a name="ln1128">/// Don't use:</a>
<a name="ln1129">///      the prefix tree or the keep-case tree</a>
<a name="ln1130">///      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln1131">///      anything to do with upper and lower case</a>
<a name="ln1132">///      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln1133">///      banned words</a>
<a name="ln1134">///      word flags (rare, region, compounding)</a>
<a name="ln1135">///      word splitting for now</a>
<a name="ln1136">///      &quot;similar_chars()&quot;</a>
<a name="ln1137">///      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln1138">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char *fword, bool soundfold)</a>
<a name="ln1139">{</a>
<a name="ln1140">  char tword[MAXWLEN];            // good word collected so far</a>
<a name="ln1141">  trystate_T stack[MAXWLEN];</a>
<a name="ln1142">  char preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln1143">  // concatenation of prefix compound</a>
<a name="ln1144">  // words and split word.  NUL terminated</a>
<a name="ln1145">  // when going deeper but not when coming</a>
<a name="ln1146">  // back.</a>
<a name="ln1147">  uint8_t compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln1148">  int newscore;</a>
<a name="ln1149">  int score;</a>
<a name="ln1150">  uint8_t *byts, *fbyts, *pbyts;</a>
<a name="ln1151">  idx_T *idxs, *fidxs, *pidxs;</a>
<a name="ln1152">  int c, c2, c3;</a>
<a name="ln1153">  int n = 0;</a>
<a name="ln1154">  int flags;</a>
<a name="ln1155">  garray_T *gap;</a>
<a name="ln1156">  idx_T arridx;</a>
<a name="ln1157">  int len;</a>
<a name="ln1158">  char *p;</a>
<a name="ln1159">  fromto_T *ftp;</a>
<a name="ln1160">  int fl = 0, tl;</a>
<a name="ln1161">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln1162">  slang_T *slang = lp-&gt;lp_slang;</a>
<a name="ln1163">  int fword_ends;</a>
<a name="ln1164">  bool goodword_ends;</a>
<a name="ln1165">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1166">  // Stores the name of the change made at each level.</a>
<a name="ln1167">  uint8_t changename[MAXWLEN][80];</a>
<a name="ln1168">#endif</a>
<a name="ln1169">  int breakcheckcount = 1000;</a>
<a name="ln1170">  bool compound_ok;</a>
<a name="ln1171"> </a>
<a name="ln1172">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln1173">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln1174">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln1175">  // word).</a>
<a name="ln1176">  int depth = 0;</a>
<a name="ln1177">  trystate_T *sp = &amp;stack[0];</a>
<a name="ln1178">  CLEAR_POINTER(sp);  // -V1068</a>
<a name="ln1179">  sp-&gt;ts_curi = 1;</a>
<a name="ln1180"> </a>
<a name="ln1181">  if (soundfold) {</a>
<a name="ln1182">    // Going through the soundfold tree.</a>
<a name="ln1183">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln1184">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln1185">    pbyts = NULL;</a>
<a name="ln1186">    pidxs = NULL;</a>
<a name="ln1187">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1188">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln1189">  } else {</a>
<a name="ln1190">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln1191">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln1192">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln1193">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln1194">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln1195">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln1196">    if (pbyts != NULL) {</a>
<a name="ln1197">      byts = pbyts;</a>
<a name="ln1198">      idxs = pidxs;</a>
<a name="ln1199">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln1200">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln1201">    } else {</a>
<a name="ln1202">      byts = fbyts;</a>
<a name="ln1203">      idxs = fidxs;</a>
<a name="ln1204">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1205">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln1206">    }</a>
<a name="ln1207">  }</a>
<a name="ln1208"> </a>
<a name="ln1209">  // The loop may take an indefinite amount of time. Break out after some</a>
<a name="ln1210">  // time.</a>
<a name="ln1211">  proftime_T time_limit = 0;</a>
<a name="ln1212">  if (spell_suggest_timeout &gt; 0) {</a>
<a name="ln1213">    time_limit = profile_setlimit(spell_suggest_timeout);</a>
<a name="ln1214">  }</a>
<a name="ln1215"> </a>
<a name="ln1216">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln1217">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln1218">  //   increase &quot;depth&quot;.</a>
<a name="ln1219">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln1220">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln1221">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1222">    sp = &amp;stack[depth];</a>
<a name="ln1223">    switch (sp-&gt;ts_state) {</a>
<a name="ln1224">    case STATE_START:</a>
<a name="ln1225">    case STATE_NOPREFIX:</a>
<a name="ln1226">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln1227">      // tword[] may end here.</a>
<a name="ln1228">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln1229">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln1230">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln1231"> </a>
<a name="ln1232">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln1233">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln1234">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; n++) {}</a>
<a name="ln1235">        sp-&gt;ts_curi = (int16_t)(sp-&gt;ts_curi + n);</a>
<a name="ln1236"> </a>
<a name="ln1237">        // Always past NUL bytes now.</a>
<a name="ln1238">        n = (int)sp-&gt;ts_state;</a>
<a name="ln1239">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1240">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln1241">        sp-&gt;ts_save_badflags = (uint8_t)su-&gt;su_badflags;</a>
<a name="ln1242"> </a>
<a name="ln1243">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln1244">        // following word.</a>
<a name="ln1245">        if (depth &lt; MAXWLEN - 1 &amp;&amp; (byts[arridx] == 0 || n == STATE_NOPREFIX)) {</a>
<a name="ln1246">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln1247">          // Use the caps type until here for the prefix itself.</a>
<a name="ln1248">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln1249">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln1250">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln1251">                                            su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln1252">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1253">          sprintf(changename[depth], &quot;prefix&quot;);  // NOLINT(runtime/printf)</a>
<a name="ln1254">#endif</a>
<a name="ln1255">          go_deeper(stack, depth, 0);</a>
<a name="ln1256">          depth++;</a>
<a name="ln1257">          sp = &amp;stack[depth];</a>
<a name="ln1258">          sp-&gt;ts_prefixdepth = (uint8_t)(depth - 1);</a>
<a name="ln1259">          byts = fbyts;</a>
<a name="ln1260">          idxs = fidxs;</a>
<a name="ln1261">          sp-&gt;ts_arridx = 0;</a>
<a name="ln1262"> </a>
<a name="ln1263">          // Move the prefix to preword[] with the right case</a>
<a name="ln1264">          // and make find_keepcap_word() works.</a>
<a name="ln1265">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln1266">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1267">                         preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln1268">          sp-&gt;ts_prewordlen = (uint8_t)strlen(preword);</a>
<a name="ln1269">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln1270">        }</a>
<a name="ln1271">        break;</a>
<a name="ln1272">      }</a>
<a name="ln1273"> </a>
<a name="ln1274">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln1275">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln1276">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1277">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln1278">        sp-&gt;ts_save_badflags = (uint8_t)su-&gt;su_badflags;</a>
<a name="ln1279">        break;</a>
<a name="ln1280">      }</a>
<a name="ln1281"> </a>
<a name="ln1282">      // End of word in tree.</a>
<a name="ln1283">      sp-&gt;ts_curi++;                    // eat one NUL byte</a>
<a name="ln1284"> </a>
<a name="ln1285">      flags = (int)idxs[arridx];</a>
<a name="ln1286"> </a>
<a name="ln1287">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln1288">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln1289">        break;</a>
<a name="ln1290">      }</a>
<a name="ln1291"> </a>
<a name="ln1292">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln1293">                    || (soundfold</a>
<a name="ln1294">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln1295">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln1296">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln1297"> </a>
<a name="ln1298">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln1299">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln1300">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln1301">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln1302">        // can be used with this word.</a>
<a name="ln1303">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln1304">        // none this must be the first try without a prefix.</a>
<a name="ln1305">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln1306">        len = pbyts[n++];</a>
<a name="ln1307">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; c++) {}</a>
<a name="ln1308">        if (c &gt; 0) {</a>
<a name="ln1309">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln1310">                                tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln1311">          if (c == 0) {</a>
<a name="ln1312">            break;</a>
<a name="ln1313">          }</a>
<a name="ln1314"> </a>
<a name="ln1315">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln1316">          if (c &amp; WF_RAREPFX) {</a>
<a name="ln1317">            flags |= WF_RARE;</a>
<a name="ln1318">          }</a>
<a name="ln1319"> </a>
<a name="ln1320">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln1321">          // we run into the prefix flag first.</a>
<a name="ln1322">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln1323">          // when arriving at a compound flag.</a>
<a name="ln1324">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln1325">        }</a>
<a name="ln1326">      }</a>
<a name="ln1327"> </a>
<a name="ln1328">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln1329">      // appending another compound word below.</a>
<a name="ln1330">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln1331">          &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln1332">        goodword_ends = false;</a>
<a name="ln1333">      } else {</a>
<a name="ln1334">        goodword_ends = true;</a>
<a name="ln1335">      }</a>
<a name="ln1336"> </a>
<a name="ln1337">      p = NULL;</a>
<a name="ln1338">      compound_ok = true;</a>
<a name="ln1339">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1340">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln1341">          // There was a word before this word.  When there was no</a>
<a name="ln1342">          // change in this word (it was correct) add the first word</a>
<a name="ln1343">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln1344">          // need to check if a correct word follows.</a>
<a name="ln1345">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln1346">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1347">              &amp;&amp; strncmp(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln1348">                         tword + sp-&gt;ts_splitoff,</a>
<a name="ln1349">                         (size_t)(sp-&gt;ts_fidx - sp-&gt;ts_splitfidx)) == 0) {</a>
<a name="ln1350">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln1351">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln1352">                                           preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1353">                                           sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln1354">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln1355">            if (newscore &lt;= su-&gt;su_maxscore) {</a>
<a name="ln1356">              add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln1357">                             sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln1358">                             newscore, 0, false,</a>
<a name="ln1359">                             lp-&gt;lp_sallang, false);</a>
<a name="ln1360">            }</a>
<a name="ln1361">            break;</a>
<a name="ln1362">          }</a>
<a name="ln1363">        } else {</a>
<a name="ln1364">          // There was a compound word before this word.  If this</a>
<a name="ln1365">          // word does not support compounding then give up</a>
<a name="ln1366">          // (splitting is tried for the word without compound</a>
<a name="ln1367">          // flag).</a>
<a name="ln1368">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln1369">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1370">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln1371">            break;</a>
<a name="ln1372">          }</a>
<a name="ln1373">          // For multi-byte chars check character length against</a>
<a name="ln1374">          // COMPOUNDMIN.</a>
<a name="ln1375">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln1376">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln1377">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln1378">            break;</a>
<a name="ln1379">          }</a>
<a name="ln1380"> </a>
<a name="ln1381">          compflags[sp-&gt;ts_complen] = (uint8_t)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1382">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1383">          xstrlcpy(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1384">                   tword + sp-&gt;ts_splitoff,</a>
<a name="ln1385">                   (size_t)(sp-&gt;ts_twordlen - sp-&gt;ts_splitoff) + 1);</a>
<a name="ln1386"> </a>
<a name="ln1387">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln1388">          if (match_checkcompoundpattern(preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln1389">                                         &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln1390">            compound_ok = false;</a>
<a name="ln1391">          }</a>
<a name="ln1392"> </a>
<a name="ln1393">          if (compound_ok) {</a>
<a name="ln1394">            p = preword;</a>
<a name="ln1395">            while (*skiptowhite(p) != NUL) {</a>
<a name="ln1396">              p = skipwhite(skiptowhite(p));</a>
<a name="ln1397">            }</a>
<a name="ln1398">            if (fword_ends &amp;&amp; !can_compound(slang, p, compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln1399">              // Compound is not allowed.  But it may still be</a>
<a name="ln1400">              // possible if we add another (short) word.</a>
<a name="ln1401">              compound_ok = false;</a>
<a name="ln1402">            }</a>
<a name="ln1403">          }</a>
<a name="ln1404"> </a>
<a name="ln1405">          // Get pointer to last char of previous word.</a>
<a name="ln1406">          p = preword + sp-&gt;ts_prewordlen;</a>
<a name="ln1407">          MB_PTR_BACK(preword, p);</a>
<a name="ln1408">        }</a>
<a name="ln1409">      }</a>
<a name="ln1410"> </a>
<a name="ln1411">      // Form the word with proper case in preword.</a>
<a name="ln1412">      // If there is a word from a previous split, append.</a>
<a name="ln1413">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln1414">      if (soundfold) {</a>
<a name="ln1415">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln1416">      } else if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln1417">        // Must find the word in the keep-case tree.</a>
<a name="ln1418">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln1419">      } else {</a>
<a name="ln1420">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln1421">        // use that for the goodword too.  But if the badword is</a>
<a name="ln1422">        // allcap and it's only one char long use onecap.</a>
<a name="ln1423">        c = su-&gt;su_badflags;</a>
<a name="ln1424">        if ((c &amp; WF_ALLCAP) &amp;&amp; su-&gt;su_badlen == utfc_ptr2len(su-&gt;su_badptr)) {</a>
<a name="ln1425">          c = WF_ONECAP;</a>
<a name="ln1426">        }</a>
<a name="ln1427">        c |= flags;</a>
<a name="ln1428"> </a>
<a name="ln1429">        // When appending a compound word after a word character don't</a>
<a name="ln1430">        // use Onecap.</a>
<a name="ln1431">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln1432">          c &amp;= ~WF_ONECAP;</a>
<a name="ln1433">        }</a>
<a name="ln1434">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1435">                       preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln1436">      }</a>
<a name="ln1437"> </a>
<a name="ln1438">      if (!soundfold) {</a>
<a name="ln1439">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln1440">        // word, thus remember it.</a>
<a name="ln1441">        if (flags &amp; WF_BANNED) {</a>
<a name="ln1442">          add_banned(su, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln1443">          break;</a>
<a name="ln1444">        }</a>
<a name="ln1445">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1446">             &amp;&amp; WAS_BANNED(su, preword + sp-&gt;ts_prewordlen))</a>
<a name="ln1447">            || WAS_BANNED(su, preword)) {</a>
<a name="ln1448">          if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1449">            break;</a>
<a name="ln1450">          }</a>
<a name="ln1451">          // the word so far was banned but we may try compounding</a>
<a name="ln1452">          goodword_ends = false;</a>
<a name="ln1453">        }</a>
<a name="ln1454">      }</a>
<a name="ln1455"> </a>
<a name="ln1456">      newscore = 0;</a>
<a name="ln1457">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln1458">        if ((flags &amp; WF_REGION)</a>
<a name="ln1459">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; (unsigned)lp-&gt;lp_region) == 0) {</a>
<a name="ln1460">          newscore += SCORE_REGION;</a>
<a name="ln1461">        }</a>
<a name="ln1462">        if (flags &amp; WF_RARE) {</a>
<a name="ln1463">          newscore += SCORE_RARE;</a>
<a name="ln1464">        }</a>
<a name="ln1465"> </a>
<a name="ln1466">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln1467">                              captype(preword + sp-&gt;ts_prewordlen, NULL))) {</a>
<a name="ln1468">          newscore += SCORE_ICASE;</a>
<a name="ln1469">        }</a>
<a name="ln1470">      }</a>
<a name="ln1471"> </a>
<a name="ln1472">      // TODO(vim): how about splitting in the soundfold tree?</a>
<a name="ln1473">      if (fword_ends</a>
<a name="ln1474">          &amp;&amp; goodword_ends</a>
<a name="ln1475">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln1476">          &amp;&amp; compound_ok) {</a>
<a name="ln1477">        // The badword also ends: add suggestions.</a>
<a name="ln1478">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1479">        if (soundfold &amp;&amp; strcmp(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln1480">          int j;</a>
<a name="ln1481"> </a>
<a name="ln1482">          // print the stack of changes that brought us here</a>
<a name="ln1483">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln1484">          for (j = 0; j &lt; depth; j++) {</a>
<a name="ln1485">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln1486">          }</a>
<a name="ln1487">        }</a>
<a name="ln1488">#endif</a>
<a name="ln1489">        if (soundfold) {</a>
<a name="ln1490">          // For soundfolded words we need to find the original</a>
<a name="ln1491">          // words, the edit distance and then add them.</a>
<a name="ln1492">          add_sound_suggest(su, preword, sp-&gt;ts_score, lp);</a>
<a name="ln1493">        } else if (sp-&gt;ts_fidx &gt; 0) {</a>
<a name="ln1494">          // Give a penalty when changing non-word char to word</a>
<a name="ln1495">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln1496">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln1497">          MB_PTR_BACK(fword, p);</a>
<a name="ln1498">          if (!spell_iswordp(p, curwin) &amp;&amp; *preword != NUL) {</a>
<a name="ln1499">            p = preword + strlen(preword);</a>
<a name="ln1500">            MB_PTR_BACK(preword, p);</a>
<a name="ln1501">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln1502">              newscore += SCORE_NONWORD;</a>
<a name="ln1503">            }</a>
<a name="ln1504">          }</a>
<a name="ln1505"> </a>
<a name="ln1506">          // Give a bonus to words seen before.</a>
<a name="ln1507">          score = score_wordcount_adj(slang,</a>
<a name="ln1508">                                      sp-&gt;ts_score + newscore,</a>
<a name="ln1509">                                      preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1510">                                      sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln1511"> </a>
<a name="ln1512">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln1513">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln1514">            add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln1515">                           sp-&gt;ts_fidx - repextra,</a>
<a name="ln1516">                           score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln1517"> </a>
<a name="ln1518">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln1519">              // We really don't know if the word should be</a>
<a name="ln1520">              // upper or lower case, add both.</a>
<a name="ln1521">              c = captype(preword, NULL);</a>
<a name="ln1522">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln1523">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln1524">                               preword + sp-&gt;ts_prewordlen,</a>
<a name="ln1525">                               c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln1526"> </a>
<a name="ln1527">                add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln1528">                               sp-&gt;ts_fidx - repextra,</a>
<a name="ln1529">                               score + SCORE_ICASE, 0, false,</a>
<a name="ln1530">                               lp-&gt;lp_sallang, false);</a>
<a name="ln1531">              }</a>
<a name="ln1532">            }</a>
<a name="ln1533">          }</a>
<a name="ln1534">        }</a>
<a name="ln1535">      }</a>
<a name="ln1536"> </a>
<a name="ln1537">      // Try word split and/or compounding.</a>
<a name="ln1538">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln1539">          // Don't split in the middle of a character</a>
<a name="ln1540">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)) {</a>
<a name="ln1541">        bool try_compound;</a>
<a name="ln1542">        int try_split;</a>
<a name="ln1543"> </a>
<a name="ln1544">        // If past the end of the bad word don't try a split.</a>
<a name="ln1545">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln1546">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln1547">        // different.  It's done like a split.</a>
<a name="ln1548">        // TODO(vim): word split for soundfold words</a>
<a name="ln1549">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln1550">                    &amp;&amp; !soundfold;</a>
<a name="ln1551"> </a>
<a name="ln1552">        // Get here in several situations:</a>
<a name="ln1553">        // 1. The word in the tree ends:</a>
<a name="ln1554">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln1555">        //    a split by inserting a space.  For both check that a</a>
<a name="ln1556">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln1557">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln1558">        //    the next word is valid.</a>
<a name="ln1559">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln1560">        //    a swap).  No need to split, but do check that the</a>
<a name="ln1561">        //    following word is valid.</a>
<a name="ln1562">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln1563">        //    be possible to compound another (short) word.</a>
<a name="ln1564">        try_compound = false;</a>
<a name="ln1565">        if (!soundfold</a>
<a name="ln1566">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln1567">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln1568">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln1569">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln1570">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln1571">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln1572">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln1573">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln1574">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1575">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln1576">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln1577">            &amp;&amp; (can_be_compound(sp, slang, compflags, (int)((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln1578">          try_compound = true;</a>
<a name="ln1579">          compflags[sp-&gt;ts_complen] = (uint8_t)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1580">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1581">        }</a>
<a name="ln1582"> </a>
<a name="ln1583">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln1584">        // valid.</a>
<a name="ln1585">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln1586">          try_compound = true;</a>
<a name="ln1587">        } else if (!fword_ends</a>
<a name="ln1588">                   &amp;&amp; try_compound</a>
<a name="ln1589">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln1590">          // If we could add a compound word, and it's also possible to</a>
<a name="ln1591">          // split at this point, do the split first and set</a>
<a name="ln1592">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln1593">          try_compound = false;</a>
<a name="ln1594">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln1595">          sp-&gt;ts_curi--;                    // do the same NUL again</a>
<a name="ln1596">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1597">        } else {</a>
<a name="ln1598">          sp-&gt;ts_flags &amp;= (uint8_t) ~TSF_DIDSPLIT;</a>
<a name="ln1599">        }</a>
<a name="ln1600"> </a>
<a name="ln1601">        if (try_split || try_compound) {</a>
<a name="ln1602">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln1603">            // If we're going to split need to check that the</a>
<a name="ln1604">            // words so far are valid for compounding.  If there</a>
<a name="ln1605">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln1606">            // flag.</a>
<a name="ln1607">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1608">                &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln1609">              break;</a>
<a name="ln1610">            }</a>
<a name="ln1611">            p = preword;</a>
<a name="ln1612">            while (*skiptowhite(p) != NUL) {</a>
<a name="ln1613">              p = skipwhite(skiptowhite(p));</a>
<a name="ln1614">            }</a>
<a name="ln1615">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln1616">                &amp;&amp; !can_compound(slang, p, compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln1617">              break;</a>
<a name="ln1618">            }</a>
<a name="ln1619"> </a>
<a name="ln1620">            if (slang-&gt;sl_nosplitsugs) {</a>
<a name="ln1621">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln1622">            } else {</a>
<a name="ln1623">              newscore += SCORE_SPLIT;</a>
<a name="ln1624">            }</a>
<a name="ln1625"> </a>
<a name="ln1626">            // Give a bonus to words seen before.</a>
<a name="ln1627">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln1628">                                           preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln1629">          }</a>
<a name="ln1630"> </a>
<a name="ln1631">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1632">            go_deeper(stack, depth, newscore);</a>
<a name="ln1633">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1634">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln1635">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1636">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln1637">            } else {</a>
<a name="ln1638">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1639">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln1640">            }</a>
<a name="ln1641">#endif</a>
<a name="ln1642">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln1643">            sp-&gt;ts_save_badflags = (uint8_t)su-&gt;su_badflags;</a>
<a name="ln1644">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1645">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln1646"> </a>
<a name="ln1647">            depth++;</a>
<a name="ln1648">            sp = &amp;stack[depth];</a>
<a name="ln1649"> </a>
<a name="ln1650">            // Append a space to preword when splitting.</a>
<a name="ln1651">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln1652">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln1653">            }</a>
<a name="ln1654">            sp-&gt;ts_prewordlen = (uint8_t)strlen(preword);</a>
<a name="ln1655">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln1656">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln1657"> </a>
<a name="ln1658">            // If the badword has a non-word character at this</a>
<a name="ln1659">            // position skip it.  That means replacing the</a>
<a name="ln1660">            // non-word character with a space.  Always skip a</a>
<a name="ln1661">            // character when the word ends.  But only when the</a>
<a name="ln1662">            // good word can end.</a>
<a name="ln1663">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln1664">                                                      + sp-&gt;ts_fidx,</a>
<a name="ln1665">                                                      curwin))</a>
<a name="ln1666">                 || fword_ends)</a>
<a name="ln1667">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln1668">                &amp;&amp; goodword_ends) {</a>
<a name="ln1669">              int l;</a>
<a name="ln1670"> </a>
<a name="ln1671">              l = utfc_ptr2len(fword + sp-&gt;ts_fidx);</a>
<a name="ln1672">              if (fword_ends) {</a>
<a name="ln1673">                // Copy the skipped character to preword.</a>
<a name="ln1674">                memmove(preword + sp-&gt;ts_prewordlen, fword + sp-&gt;ts_fidx, (size_t)l);</a>
<a name="ln1675">                sp-&gt;ts_prewordlen = (uint8_t)(sp-&gt;ts_prewordlen + l);</a>
<a name="ln1676">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln1677">              } else {</a>
<a name="ln1678">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln1679">              }</a>
<a name="ln1680">              sp-&gt;ts_fidx = (uint8_t)(sp-&gt;ts_fidx + l);</a>
<a name="ln1681">            }</a>
<a name="ln1682"> </a>
<a name="ln1683">            // When compounding include compound flag in</a>
<a name="ln1684">            // compflags[] (already set above).  When splitting we</a>
<a name="ln1685">            // may start compounding over again.</a>
<a name="ln1686">            if (try_compound) {</a>
<a name="ln1687">              sp-&gt;ts_complen++;</a>
<a name="ln1688">            } else {</a>
<a name="ln1689">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln1690">            }</a>
<a name="ln1691">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln1692"> </a>
<a name="ln1693">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln1694">            // position</a>
<a name="ln1695">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln1696">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln1697">                                              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln1698"> </a>
<a name="ln1699">            // Restart at top of the tree.</a>
<a name="ln1700">            sp-&gt;ts_arridx = 0;</a>
<a name="ln1701"> </a>
<a name="ln1702">            // If there are postponed prefixes, try these too.</a>
<a name="ln1703">            if (pbyts != NULL) {</a>
<a name="ln1704">              byts = pbyts;</a>
<a name="ln1705">              idxs = pidxs;</a>
<a name="ln1706">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln1707">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1708">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln1709">            }</a>
<a name="ln1710">          }</a>
<a name="ln1711">        }</a>
<a name="ln1712">      }</a>
<a name="ln1713">      break;</a>
<a name="ln1714"> </a>
<a name="ln1715">    case STATE_SPLITUNDO:</a>
<a name="ln1716">      // Undo the changes done for word split or compound word.</a>
<a name="ln1717">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln1718"> </a>
<a name="ln1719">      // Continue looking for NUL bytes.</a>
<a name="ln1720">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1721">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln1722"> </a>
<a name="ln1723">      // In case we went into the prefix tree.</a>
<a name="ln1724">      byts = fbyts;</a>
<a name="ln1725">      idxs = fidxs;</a>
<a name="ln1726">      break;</a>
<a name="ln1727"> </a>
<a name="ln1728">    case STATE_ENDNUL:</a>
<a name="ln1729">      // Past the NUL bytes in the node.</a>
<a name="ln1730">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln1731">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln1732">          &amp;&amp; sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln1733">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln1734">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1735">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln1736">        break;</a>
<a name="ln1737">      }</a>
<a name="ln1738">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1739">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln1740">      FALLTHROUGH;</a>
<a name="ln1741"> </a>
<a name="ln1742">    case STATE_PLAIN:</a>
<a name="ln1743">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln1744">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln1745">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln1746">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln1747">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln1748">        // already changed bytes skip the other tricks.</a>
<a name="ln1749">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1750">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln1751">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln1752">        } else {</a>
<a name="ln1753">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln1754">        }</a>
<a name="ln1755">      } else {</a>
<a name="ln1756">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln1757">        c = byts[arridx];</a>
<a name="ln1758"> </a>
<a name="ln1759">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln1760">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln1761">        // when the byte was already changed.  And don't try when we</a>
<a name="ln1762">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln1763">        // delete + substitute.</a>
<a name="ln1764">        if (c == (uint8_t)fword[sp-&gt;ts_fidx]</a>
<a name="ln1765">            || (sp-&gt;ts_tcharlen &gt; 0</a>
<a name="ln1766">                &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)) {</a>
<a name="ln1767">          newscore = 0;</a>
<a name="ln1768">        } else {</a>
<a name="ln1769">          newscore = SCORE_SUBST;</a>
<a name="ln1770">        }</a>
<a name="ln1771">        if ((newscore == 0</a>
<a name="ln1772">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln1773">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln1774">                     || c != (uint8_t)fword[sp-&gt;ts_delidx])))</a>
<a name="ln1775">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1776">          go_deeper(stack, depth, newscore);</a>
<a name="ln1777">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1778">          if (newscore &gt; 0) {</a>
<a name="ln1779">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1780">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1781">                    fword[sp-&gt;ts_fidx], c);</a>
<a name="ln1782">          } else {</a>
<a name="ln1783">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1784">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1785">                    fword[sp-&gt;ts_fidx]);</a>
<a name="ln1786">          }</a>
<a name="ln1787">#endif</a>
<a name="ln1788">          depth++;</a>
<a name="ln1789">          sp = &amp;stack[depth];</a>
<a name="ln1790">          if (fword[sp-&gt;ts_fidx] != NUL) {</a>
<a name="ln1791">            sp-&gt;ts_fidx++;</a>
<a name="ln1792">          }</a>
<a name="ln1793">          tword[sp-&gt;ts_twordlen++] = (char)c;</a>
<a name="ln1794">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln1795">          if (newscore == SCORE_SUBST) {</a>
<a name="ln1796">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln1797">          }</a>
<a name="ln1798">          // Multi-byte characters are a bit complicated to</a>
<a name="ln1799">          // handle: They differ when any of the bytes differ</a>
<a name="ln1800">          // and then their length may also differ.</a>
<a name="ln1801">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln1802">            // First byte.</a>
<a name="ln1803">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln1804">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln1805">            sp-&gt;ts_fcharstart = (uint8_t)(sp-&gt;ts_fidx - 1);</a>
<a name="ln1806">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln1807">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln1808">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT &amp;&amp; sp-&gt;ts_fidx &gt; 0) {</a>
<a name="ln1809">            // When inserting trail bytes don't advance in the</a>
<a name="ln1810">            // bad word.</a>
<a name="ln1811">            sp-&gt;ts_fidx--;</a>
<a name="ln1812">          }</a>
<a name="ln1813">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln1814">            // Last byte of character.</a>
<a name="ln1815">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln1816">              // Correct ts_fidx for the byte length of the</a>
<a name="ln1817">              // character (we didn't check that before).</a>
<a name="ln1818">              sp-&gt;ts_fidx = (uint8_t)(sp-&gt;ts_fcharstart</a>
<a name="ln1819">                                      + utfc_ptr2len(fword + sp-&gt;ts_fcharstart));</a>
<a name="ln1820"> </a>
<a name="ln1821">              // For changing a composing character adjust</a>
<a name="ln1822">              // the score from SCORE_SUBST to</a>
<a name="ln1823">              // SCORE_SUBCOMP.</a>
<a name="ln1824">              if (utf_iscomposing(utf_ptr2char(tword + sp-&gt;ts_twordlen</a>
<a name="ln1825">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln1826">                  &amp;&amp; utf_iscomposing(utf_ptr2char(fword</a>
<a name="ln1827">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln1828">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln1829">              } else if (!soundfold</a>
<a name="ln1830">                         &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln1831">                         &amp;&amp; similar_chars(slang,</a>
<a name="ln1832">                                          utf_ptr2char(tword + sp-&gt;ts_twordlen -</a>
<a name="ln1833">                                                       sp-&gt;ts_tcharlen),</a>
<a name="ln1834">                                          utf_ptr2char(fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln1835">                // For a similar character adjust score from</a>
<a name="ln1836">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln1837">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln1838">              }</a>
<a name="ln1839">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln1840">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln1841">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln1842">              c = utf_ptr2char(p);</a>
<a name="ln1843">              if (utf_iscomposing(c)) {</a>
<a name="ln1844">                // Inserting a composing char doesn't</a>
<a name="ln1845">                // count that much.</a>
<a name="ln1846">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln1847">              } else {</a>
<a name="ln1848">                // If the previous character was the same,</a>
<a name="ln1849">                // thus doubling a character, give a bonus</a>
<a name="ln1850">                // to the score.  Also for the soundfold</a>
<a name="ln1851">                // tree (might seem illogical but does</a>
<a name="ln1852">                // give better scores).</a>
<a name="ln1853">                MB_PTR_BACK(tword, p);</a>
<a name="ln1854">                if (c == utf_ptr2char(p)) {</a>
<a name="ln1855">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln1856">                }</a>
<a name="ln1857">              }</a>
<a name="ln1858">            }</a>
<a name="ln1859"> </a>
<a name="ln1860">            // Starting a new char, reset the length.</a>
<a name="ln1861">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln1862">          }</a>
<a name="ln1863">        }</a>
<a name="ln1864">      }</a>
<a name="ln1865">      break;</a>
<a name="ln1866"> </a>
<a name="ln1867">    case STATE_DEL:</a>
<a name="ln1868">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln1869">      // delete/insert/swap a character.</a>
<a name="ln1870">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln1871">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1872">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln1873">        break;</a>
<a name="ln1874">      }</a>
<a name="ln1875">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln1876">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1877">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln1878">      sp-&gt;ts_curi = 1;</a>
<a name="ln1879">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*') {</a>
<a name="ln1880">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln1881">        // soundalike_score().</a>
<a name="ln1882">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln1883">      } else {</a>
<a name="ln1884">        newscore = SCORE_DEL;</a>
<a name="ln1885">      }</a>
<a name="ln1886">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln1887">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1888">        go_deeper(stack, depth, newscore);</a>
<a name="ln1889">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1890">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1891">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1892">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln1893">#endif</a>
<a name="ln1894">        depth++;</a>
<a name="ln1895"> </a>
<a name="ln1896">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln1897">        // inserting it again.</a>
<a name="ln1898">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln1899">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln1900"> </a>
<a name="ln1901">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln1902">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln1903">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln1904">        // results.</a>
<a name="ln1905">        c = utf_ptr2char(fword + sp-&gt;ts_fidx);</a>
<a name="ln1906">        stack[depth].ts_fidx =</a>
<a name="ln1907">          (uint8_t)(stack[depth].ts_fidx + utfc_ptr2len(fword + sp-&gt;ts_fidx));</a>
<a name="ln1908">        if (utf_iscomposing(c)) {</a>
<a name="ln1909">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln1910">        } else if (c == utf_ptr2char(fword + stack[depth].ts_fidx)) {</a>
<a name="ln1911">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln1912">        }</a>
<a name="ln1913"> </a>
<a name="ln1914">        break;</a>
<a name="ln1915">      }</a>
<a name="ln1916">      FALLTHROUGH;</a>
<a name="ln1917"> </a>
<a name="ln1918">    case STATE_INS_PREP:</a>
<a name="ln1919">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln1920">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln1921">        // a substitute is always cheaper.</a>
<a name="ln1922">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1923">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1924">        break;</a>
<a name="ln1925">      }</a>
<a name="ln1926"> </a>
<a name="ln1927">      // skip over NUL bytes</a>
<a name="ln1928">      n = sp-&gt;ts_arridx;</a>
<a name="ln1929">      while (true) {</a>
<a name="ln1930">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln1931">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln1932">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1933">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1934">          break;</a>
<a name="ln1935">        }</a>
<a name="ln1936">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln1937">          // Found a byte to insert.</a>
<a name="ln1938">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1939">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln1940">          break;</a>
<a name="ln1941">        }</a>
<a name="ln1942">        sp-&gt;ts_curi++;</a>
<a name="ln1943">      }</a>
<a name="ln1944">      break;</a>
<a name="ln1945"> </a>
<a name="ln1946">    case STATE_INS:</a>
<a name="ln1947">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln1948">      // node.</a>
<a name="ln1949">      n = sp-&gt;ts_arridx;</a>
<a name="ln1950">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln1951">        // Done all bytes at this node, go to next state.</a>
<a name="ln1952">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln1953">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln1954">        break;</a>
<a name="ln1955">      }</a>
<a name="ln1956"> </a>
<a name="ln1957">      // Do one more byte at this node, but:</a>
<a name="ln1958">      // - Skip NUL bytes.</a>
<a name="ln1959">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln1960">      //   accepting that byte is always better.</a>
<a name="ln1961">      n += sp-&gt;ts_curi++;</a>
<a name="ln1962">      c = byts[n];</a>
<a name="ln1963">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*') {</a>
<a name="ln1964">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln1965">        // see soundalike_score().</a>
<a name="ln1966">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln1967">      } else {</a>
<a name="ln1968">        newscore = SCORE_INS;</a>
<a name="ln1969">      }</a>
<a name="ln1970">      if (c != (uint8_t)fword[sp-&gt;ts_fidx]</a>
<a name="ln1971">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln1972">        go_deeper(stack, depth, newscore);</a>
<a name="ln1973">#ifdef DEBUG_TRIEWALK</a>
<a name="ln1974">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln1975">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln1976">                c);</a>
<a name="ln1977">#endif</a>
<a name="ln1978">        depth++;</a>
<a name="ln1979">        sp = &amp;stack[depth];</a>
<a name="ln1980">        tword[sp-&gt;ts_twordlen++] = (char)c;</a>
<a name="ln1981">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln1982">        fl = MB_BYTE2LEN(c);</a>
<a name="ln1983">        if (fl &gt; 1) {</a>
<a name="ln1984">          // There are following bytes for the same character.</a>
<a name="ln1985">          // We must find all bytes before trying</a>
<a name="ln1986">          // delete/insert/swap/etc.</a>
<a name="ln1987">          sp-&gt;ts_tcharlen = (uint8_t)fl;</a>
<a name="ln1988">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln1989">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln1990">        }</a>
<a name="ln1991">        if (fl == 1) {</a>
<a name="ln1992">          // If the previous character was the same, thus doubling a</a>
<a name="ln1993">          // character, give a bonus to the score.  Also for</a>
<a name="ln1994">          // soundfold words (illogical but does give a better</a>
<a name="ln1995">          // score).</a>
<a name="ln1996">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln1997">              &amp;&amp; (uint8_t)tword[sp-&gt;ts_twordlen - 2] == c) {</a>
<a name="ln1998">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln1999">          }</a>
<a name="ln2000">        }</a>
<a name="ln2001">      }</a>
<a name="ln2002">      break;</a>
<a name="ln2003"> </a>
<a name="ln2004">    case STATE_SWAP:</a>
<a name="ln2005">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln2006">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln2007">      // STATE_UNSWAP.</a>
<a name="ln2008">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2009">      c = (uint8_t)(*p);</a>
<a name="ln2010">      if (c == NUL) {</a>
<a name="ln2011">        // End of word, can't swap or replace.</a>
<a name="ln2012">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2013">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2014">        break;</a>
<a name="ln2015">      }</a>
<a name="ln2016"> </a>
<a name="ln2017">      // Don't swap if the first character is not a word character.</a>
<a name="ln2018">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln2019">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln2020">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2021">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2022">        break;</a>
<a name="ln2023">      }</a>
<a name="ln2024"> </a>
<a name="ln2025">      n = utf_ptr2len(p);</a>
<a name="ln2026">      c = utf_ptr2char(p);</a>
<a name="ln2027">      if (p[n] == NUL) {</a>
<a name="ln2028">        c2 = NUL;</a>
<a name="ln2029">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln2030">        c2 = c;  // don't swap non-word char</a>
<a name="ln2031">      } else {</a>
<a name="ln2032">        c2 = utf_ptr2char(p + n);</a>
<a name="ln2033">      }</a>
<a name="ln2034"> </a>
<a name="ln2035">      // When the second character is NUL we can't swap.</a>
<a name="ln2036">      if (c2 == NUL) {</a>
<a name="ln2037">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2038">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2039">        break;</a>
<a name="ln2040">      }</a>
<a name="ln2041"> </a>
<a name="ln2042">      // When characters are identical, swap won't do anything.</a>
<a name="ln2043">      // Also get here if the second char is not a word character.</a>
<a name="ln2044">      if (c == c2) {</a>
<a name="ln2045">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2046">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln2047">        break;</a>
<a name="ln2048">      }</a>
<a name="ln2049">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln2050">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln2051">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2052">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln2053">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln2054">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2055">                 c, c2);</a>
<a name="ln2056">#endif</a>
<a name="ln2057">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2058">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln2059">        depth++;</a>
<a name="ln2060">        fl = utf_char2len(c2);</a>
<a name="ln2061">        memmove(p, p + n, (size_t)fl);</a>
<a name="ln2062">        utf_char2bytes(c, p + fl);</a>
<a name="ln2063">        stack[depth].ts_fidxtry = (uint8_t)(sp-&gt;ts_fidx + n + fl);</a>
<a name="ln2064">      } else {</a>
<a name="ln2065">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln2066">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2067">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2068">      }</a>
<a name="ln2069">      break;</a>
<a name="ln2070"> </a>
<a name="ln2071">    case STATE_UNSWAP:</a>
<a name="ln2072">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln2073">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2074">      n = utfc_ptr2len(p);</a>
<a name="ln2075">      c = utf_ptr2char(p + n);</a>
<a name="ln2076">      memmove(p + utfc_ptr2len(p + n), p, (size_t)n);</a>
<a name="ln2077">      utf_char2bytes(c, p);</a>
<a name="ln2078"> </a>
<a name="ln2079">      FALLTHROUGH;</a>
<a name="ln2080"> </a>
<a name="ln2081">    case STATE_SWAP3:</a>
<a name="ln2082">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln2083">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln2084">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2085">      n = utf_ptr2len(p);</a>
<a name="ln2086">      c = utf_ptr2char(p);</a>
<a name="ln2087">      fl = utf_ptr2len(p + n);</a>
<a name="ln2088">      c2 = utf_ptr2char(p + n);</a>
<a name="ln2089">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln2090">        c3 = c;  // don't swap non-word char</a>
<a name="ln2091">      } else {</a>
<a name="ln2092">        c3 = utf_ptr2char(p + n + fl);</a>
<a name="ln2093">      }</a>
<a name="ln2094"> </a>
<a name="ln2095">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln2096">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln2097">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln2098">      // Also skip when c3 is NUL.</a>
<a name="ln2099">      // Also get here when the third character is not a word character.</a>
<a name="ln2100">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln2101">      if (c == c3 || c3 == NUL) {</a>
<a name="ln2102">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2103">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2104">        break;</a>
<a name="ln2105">      }</a>
<a name="ln2106">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2107">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2108">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2109">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2110">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2111">                c, c3);</a>
<a name="ln2112">#endif</a>
<a name="ln2113">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2114">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln2115">        depth++;</a>
<a name="ln2116">        tl = utf_char2len(c3);</a>
<a name="ln2117">        memmove(p, p + n + fl, (size_t)tl);</a>
<a name="ln2118">        utf_char2bytes(c2, p + tl);</a>
<a name="ln2119">        utf_char2bytes(c, p + fl + tl);</a>
<a name="ln2120">        stack[depth].ts_fidxtry = (uint8_t)(sp-&gt;ts_fidx + n + fl + tl);</a>
<a name="ln2121">      } else {</a>
<a name="ln2122">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2123">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2124">      }</a>
<a name="ln2125">      break;</a>
<a name="ln2126"> </a>
<a name="ln2127">    case STATE_UNSWAP3:</a>
<a name="ln2128">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln2129">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2130">      n = utfc_ptr2len(p);</a>
<a name="ln2131">      c2 = utf_ptr2char(p + n);</a>
<a name="ln2132">      fl = utfc_ptr2len(p + n);</a>
<a name="ln2133">      c = utf_ptr2char(p + n + fl);</a>
<a name="ln2134">      tl = utfc_ptr2len(p + n + fl);</a>
<a name="ln2135">      memmove(p + fl + tl, p, (size_t)n);</a>
<a name="ln2136">      utf_char2bytes(c, p);</a>
<a name="ln2137">      utf_char2bytes(c2, p + tl);</a>
<a name="ln2138">      p = p + tl;</a>
<a name="ln2139"> </a>
<a name="ln2140">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln2141">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln2142">        // third char were already checked at swap and swap3.</a>
<a name="ln2143">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2144">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2145">        break;</a>
<a name="ln2146">      }</a>
<a name="ln2147"> </a>
<a name="ln2148">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln2149">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln2150">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2151">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2152">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2153">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2154">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2155">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2156">                p[0], p[1], p[2]);</a>
<a name="ln2157">#endif</a>
<a name="ln2158">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2159">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln2160">        depth++;</a>
<a name="ln2161">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2162">        n = utf_ptr2len(p);</a>
<a name="ln2163">        c = utf_ptr2char(p);</a>
<a name="ln2164">        fl = utf_ptr2len(p + n);</a>
<a name="ln2165">        fl += utf_ptr2len(p + n + fl);</a>
<a name="ln2166">        memmove(p, p + n, (size_t)fl);</a>
<a name="ln2167">        utf_char2bytes(c, p + fl);</a>
<a name="ln2168">        stack[depth].ts_fidxtry = (uint8_t)(sp-&gt;ts_fidx + n + fl);</a>
<a name="ln2169">      } else {</a>
<a name="ln2170">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2171">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2172">      }</a>
<a name="ln2173">      break;</a>
<a name="ln2174"> </a>
<a name="ln2175">    case STATE_UNROT3L:</a>
<a name="ln2176">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln2177">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2178">      n = utfc_ptr2len(p);</a>
<a name="ln2179">      n += utfc_ptr2len(p + n);</a>
<a name="ln2180">      c = utf_ptr2char(p + n);</a>
<a name="ln2181">      tl = utfc_ptr2len(p + n);</a>
<a name="ln2182">      memmove(p + tl, p, (size_t)n);</a>
<a name="ln2183">      utf_char2bytes(c, p);</a>
<a name="ln2184"> </a>
<a name="ln2185">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln2186">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln2187">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln2188">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln2189">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2190">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2191">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2192">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2193">                p[0], p[1], p[2]);</a>
<a name="ln2194">#endif</a>
<a name="ln2195">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2196">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln2197">        depth++;</a>
<a name="ln2198">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2199">        n = utf_ptr2len(p);</a>
<a name="ln2200">        n += utf_ptr2len(p + n);</a>
<a name="ln2201">        c = utf_ptr2char(p + n);</a>
<a name="ln2202">        tl = utf_ptr2len(p + n);</a>
<a name="ln2203">        memmove(p + tl, p, (size_t)n);</a>
<a name="ln2204">        utf_char2bytes(c, p);</a>
<a name="ln2205">        stack[depth].ts_fidxtry = (uint8_t)(sp-&gt;ts_fidx + n + tl);</a>
<a name="ln2206">      } else {</a>
<a name="ln2207">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2208">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln2209">      }</a>
<a name="ln2210">      break;</a>
<a name="ln2211"> </a>
<a name="ln2212">    case STATE_UNROT3R:</a>
<a name="ln2213">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln2214">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2215">      c = utf_ptr2char(p);</a>
<a name="ln2216">      tl = utfc_ptr2len(p);</a>
<a name="ln2217">      n = utfc_ptr2len(p + tl);</a>
<a name="ln2218">      n += utfc_ptr2len(p + tl + n);</a>
<a name="ln2219">      memmove(p, p + tl, (size_t)n);</a>
<a name="ln2220">      utf_char2bytes(c, p + n);</a>
<a name="ln2221"> </a>
<a name="ln2222">      FALLTHROUGH;</a>
<a name="ln2223"> </a>
<a name="ln2224">    case STATE_REP_INI:</a>
<a name="ln2225">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln2226">      // Quickly skip if:</a>
<a name="ln2227">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln2228">      // - the score is going to be too high anyway</a>
<a name="ln2229">      // - already applied a REP item or swapped here</a>
<a name="ln2230">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln2231">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln2232">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln2233">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2234">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2235">        break;</a>
<a name="ln2236">      }</a>
<a name="ln2237"> </a>
<a name="ln2238">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln2239">      // match.  If the index is -1 there is none.</a>
<a name="ln2240">      if (soundfold) {</a>
<a name="ln2241">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[(uint8_t)fword[sp-&gt;ts_fidx]];</a>
<a name="ln2242">      } else {</a>
<a name="ln2243">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[(uint8_t)fword[sp-&gt;ts_fidx]];</a>
<a name="ln2244">      }</a>
<a name="ln2245"> </a>
<a name="ln2246">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln2247">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2248">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2249">        break;</a>
<a name="ln2250">      }</a>
<a name="ln2251"> </a>
<a name="ln2252">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2253">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln2254">      FALLTHROUGH;</a>
<a name="ln2255"> </a>
<a name="ln2256">    case STATE_REP:</a>
<a name="ln2257">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln2258">      // replace the characters and check if the resulting word is</a>
<a name="ln2259">      // valid.</a>
<a name="ln2260">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2261"> </a>
<a name="ln2262">      if (soundfold) {</a>
<a name="ln2263">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln2264">      } else {</a>
<a name="ln2265">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln2266">      }</a>
<a name="ln2267">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln2268">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln2269">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln2270">          // past possible matching entries</a>
<a name="ln2271">          sp-&gt;ts_curi = (int16_t)gap-&gt;ga_len;</a>
<a name="ln2272">          break;</a>
<a name="ln2273">        }</a>
<a name="ln2274">        if (strncmp(ftp-&gt;ft_from, p, strlen(ftp-&gt;ft_from)) == 0</a>
<a name="ln2275">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln2276">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln2277">#ifdef DEBUG_TRIEWALK</a>
<a name="ln2278">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,  // NOLINT(runtime/printf)</a>
<a name="ln2279">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln2280">                  ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln2281">#endif</a>
<a name="ln2282">          // Need to undo this afterwards.</a>
<a name="ln2283">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2284">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln2285"> </a>
<a name="ln2286">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln2287">          depth++;</a>
<a name="ln2288">          fl = (int)strlen(ftp-&gt;ft_from);</a>
<a name="ln2289">          tl = (int)strlen(ftp-&gt;ft_to);</a>
<a name="ln2290">          if (fl != tl) {</a>
<a name="ln2291">            STRMOVE(p + tl, p + fl);</a>
<a name="ln2292">            repextra += tl - fl;</a>
<a name="ln2293">          }</a>
<a name="ln2294">          memmove(p, ftp-&gt;ft_to, (size_t)tl);</a>
<a name="ln2295">          stack[depth].ts_fidxtry = (uint8_t)(sp-&gt;ts_fidx + tl);</a>
<a name="ln2296">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln2297">          break;</a>
<a name="ln2298">        }</a>
<a name="ln2299">      }</a>
<a name="ln2300"> </a>
<a name="ln2301">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP) {</a>
<a name="ln2302">        // No (more) matches.</a>
<a name="ln2303">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2304">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln2305">      }</a>
<a name="ln2306"> </a>
<a name="ln2307">      break;</a>
<a name="ln2308"> </a>
<a name="ln2309">    case STATE_REP_UNDO:</a>
<a name="ln2310">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln2311">      if (soundfold) {</a>
<a name="ln2312">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln2313">      } else {</a>
<a name="ln2314">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln2315">      }</a>
<a name="ln2316">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln2317">      fl = (int)strlen(ftp-&gt;ft_from);</a>
<a name="ln2318">      tl = (int)strlen(ftp-&gt;ft_to);</a>
<a name="ln2319">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln2320">      if (fl != tl) {</a>
<a name="ln2321">        STRMOVE(p + fl, p + tl);</a>
<a name="ln2322">        repextra -= tl - fl;</a>
<a name="ln2323">      }</a>
<a name="ln2324">      memmove(p, ftp-&gt;ft_from, (size_t)fl);</a>
<a name="ln2325">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln2326">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln2327">      break;</a>
<a name="ln2328"> </a>
<a name="ln2329">    default:</a>
<a name="ln2330">      // Did all possible states at this level, go up one level.</a>
<a name="ln2331">      depth--;</a>
<a name="ln2332"> </a>
<a name="ln2333">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln2334">        // Continue in or go back to the prefix tree.</a>
<a name="ln2335">        byts = pbyts;</a>
<a name="ln2336">        idxs = pidxs;</a>
<a name="ln2337">      }</a>
<a name="ln2338"> </a>
<a name="ln2339">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln2340">      if (--breakcheckcount == 0) {</a>
<a name="ln2341">        os_breakcheck();</a>
<a name="ln2342">        breakcheckcount = 1000;</a>
<a name="ln2343">        if (spell_suggest_timeout &gt; 0 &amp;&amp; profile_passed_limit(time_limit)) {</a>
<a name="ln2344">          got_int = true;</a>
<a name="ln2345">        }</a>
<a name="ln2346">      }</a>
<a name="ln2347">    }</a>
<a name="ln2348">  }</a>
<a name="ln2349">}</a>
<a name="ln2350"> </a>
<a name="ln2351">/// Go one level deeper in the tree.</a>
<a name="ln2352">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln2353">{</a>
<a name="ln2354">  stack[depth + 1] = stack[depth];</a>
<a name="ln2355">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln2356">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln2357">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln2358">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln2359">}</a>
<a name="ln2360"> </a>
<a name="ln2361">/// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln2362">/// words and put it in &quot;kword&quot;.</a>
<a name="ln2363">/// Theoretically there could be several keep-case words that result in the</a>
<a name="ln2364">/// same case-folded word, but we only find one...</a>
<a name="ln2365">static void find_keepcap_word(slang_T *slang, char *fword, char *kword)</a>
<a name="ln2366">{</a>
<a name="ln2367">  char uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln2368">  idx_T tryidx;</a>
<a name="ln2369"> </a>
<a name="ln2370">  // The following arrays are used at each depth in the tree.</a>
<a name="ln2371">  idx_T arridx[MAXWLEN];</a>
<a name="ln2372">  int round[MAXWLEN];</a>
<a name="ln2373">  int fwordidx[MAXWLEN];</a>
<a name="ln2374">  int uwordidx[MAXWLEN];</a>
<a name="ln2375">  int kwordlen[MAXWLEN];</a>
<a name="ln2376"> </a>
<a name="ln2377">  int flen, ulen;</a>
<a name="ln2378">  int l;</a>
<a name="ln2379">  int len;</a>
<a name="ln2380">  int c;</a>
<a name="ln2381">  idx_T lo, hi, m;</a>
<a name="ln2382">  char *p;</a>
<a name="ln2383">  uint8_t *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln2384">  idx_T *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln2385"> </a>
<a name="ln2386">  if (byts == NULL) {</a>
<a name="ln2387">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln2388">    *kword = NUL;</a>
<a name="ln2389">    return;</a>
<a name="ln2390">  }</a>
<a name="ln2391"> </a>
<a name="ln2392">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln2393">  allcap_copy(fword, uword);</a>
<a name="ln2394"> </a>
<a name="ln2395">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln2396">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln2397">  // may change the byte length of a multi-byte character...</a>
<a name="ln2398">  int depth = 0;</a>
<a name="ln2399">  arridx[0] = 0;</a>
<a name="ln2400">  round[0] = 0;</a>
<a name="ln2401">  fwordidx[0] = 0;</a>
<a name="ln2402">  uwordidx[0] = 0;</a>
<a name="ln2403">  kwordlen[0] = 0;</a>
<a name="ln2404">  while (depth &gt;= 0) {</a>
<a name="ln2405">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln2406">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln2407">      // here we have found a match.</a>
<a name="ln2408">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln2409">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln2410">        return;</a>
<a name="ln2411">      }</a>
<a name="ln2412"> </a>
<a name="ln2413">      // kword is getting too long, continue one level up</a>
<a name="ln2414">      depth--;</a>
<a name="ln2415">    } else if (++round[depth] &gt; 2) {</a>
<a name="ln2416">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln2417">      // level up</a>
<a name="ln2418">      depth--;</a>
<a name="ln2419">    } else {</a>
<a name="ln2420">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln2421">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln2422">      flen = utf_ptr2len(fword + fwordidx[depth]);</a>
<a name="ln2423">      ulen = utf_ptr2len(uword + uwordidx[depth]);</a>
<a name="ln2424">      if (round[depth] == 1) {</a>
<a name="ln2425">        p = fword + fwordidx[depth];</a>
<a name="ln2426">        l = flen;</a>
<a name="ln2427">      } else {</a>
<a name="ln2428">        p = uword + uwordidx[depth];</a>
<a name="ln2429">        l = ulen;</a>
<a name="ln2430">      }</a>
<a name="ln2431"> </a>
<a name="ln2432">      for (tryidx = arridx[depth]; l &gt; 0; l--) {</a>
<a name="ln2433">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln2434">        len = byts[tryidx++];</a>
<a name="ln2435">        c = (uint8_t)(*p++);</a>
<a name="ln2436">        lo = tryidx;</a>
<a name="ln2437">        hi = tryidx + len - 1;</a>
<a name="ln2438">        while (lo &lt; hi) {</a>
<a name="ln2439">          m = (lo + hi) / 2;</a>
<a name="ln2440">          if (byts[m] &gt; c) {</a>
<a name="ln2441">            hi = m - 1;</a>
<a name="ln2442">          } else if (byts[m] &lt; c) {</a>
<a name="ln2443">            lo = m + 1;</a>
<a name="ln2444">          } else {</a>
<a name="ln2445">            lo = hi = m;</a>
<a name="ln2446">            break;</a>
<a name="ln2447">          }</a>
<a name="ln2448">        }</a>
<a name="ln2449"> </a>
<a name="ln2450">        // Stop if there is no matching byte.</a>
<a name="ln2451">        if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln2452">          break;</a>
<a name="ln2453">        }</a>
<a name="ln2454"> </a>
<a name="ln2455">        // Continue at the child (if there is one).</a>
<a name="ln2456">        tryidx = idxs[lo];</a>
<a name="ln2457">      }</a>
<a name="ln2458"> </a>
<a name="ln2459">      if (l == 0) {</a>
<a name="ln2460">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln2461">        // level deeper.</a>
<a name="ln2462">        if (round[depth] == 1) {</a>
<a name="ln2463">          strncpy(kword + kwordlen[depth],  // NOLINT(runtime/printf)</a>
<a name="ln2464">                  fword + fwordidx[depth],</a>
<a name="ln2465">                  (size_t)flen);</a>
<a name="ln2466">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln2467">        } else {</a>
<a name="ln2468">          strncpy(kword + kwordlen[depth],  // NOLINT(runtime/printf)</a>
<a name="ln2469">                  uword + uwordidx[depth],</a>
<a name="ln2470">                  (size_t)ulen);</a>
<a name="ln2471">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln2472">        }</a>
<a name="ln2473">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln2474">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln2475"> </a>
<a name="ln2476">        depth++;</a>
<a name="ln2477">        arridx[depth] = tryidx;</a>
<a name="ln2478">        round[depth] = 0;</a>
<a name="ln2479">      }</a>
<a name="ln2480">    }</a>
<a name="ln2481">  }</a>
<a name="ln2482"> </a>
<a name="ln2483">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln2484">  *kword = NUL;</a>
<a name="ln2485">}</a>
<a name="ln2486"> </a>
<a name="ln2487">/// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln2488">/// su-&gt;su_sga.</a>
<a name="ln2489">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln2490">{</a>
<a name="ln2491">  langp_T *lp;</a>
<a name="ln2492">  char badsound[MAXWLEN];</a>
<a name="ln2493">  suggest_T *stp;</a>
<a name="ln2494">  suggest_T *sstp;</a>
<a name="ln2495">  int score;</a>
<a name="ln2496"> </a>
<a name="ln2497">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln2498"> </a>
<a name="ln2499">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln2500">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2501">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2502">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2503">      // soundfold the bad word</a>
<a name="ln2504">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln2505"> </a>
<a name="ln2506">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln2507">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln2508"> </a>
<a name="ln2509">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln2510">        // sound-a-like score.</a>
<a name="ln2511">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln2512">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln2513">          // Add the suggestion.</a>
<a name="ln2514">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln2515">          sstp-&gt;st_word = xstrdup(stp-&gt;st_word);</a>
<a name="ln2516">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln2517">          sstp-&gt;st_score = score;</a>
<a name="ln2518">          sstp-&gt;st_altscore = 0;</a>
<a name="ln2519">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln2520">          su-&gt;su_sga.ga_len++;</a>
<a name="ln2521">        }</a>
<a name="ln2522">      }</a>
<a name="ln2523">      break;</a>
<a name="ln2524">    }</a>
<a name="ln2525">  }</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">/// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln2529">/// They are entwined.</a>
<a name="ln2530">static void score_combine(suginfo_T *su)</a>
<a name="ln2531">{</a>
<a name="ln2532">  garray_T ga;</a>
<a name="ln2533">  garray_T *gap;</a>
<a name="ln2534">  langp_T *lp;</a>
<a name="ln2535">  suggest_T *stp;</a>
<a name="ln2536">  char *p;</a>
<a name="ln2537">  char badsound[MAXWLEN];</a>
<a name="ln2538">  int round;</a>
<a name="ln2539">  slang_T *slang = NULL;</a>
<a name="ln2540"> </a>
<a name="ln2541">  // Add the alternate score to su_ga.</a>
<a name="ln2542">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2543">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2544">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2545">      // soundfold the bad word</a>
<a name="ln2546">      slang = lp-&gt;lp_slang;</a>
<a name="ln2547">      spell_soundfold(slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln2548"> </a>
<a name="ln2549">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln2550">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln2551">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, badsound);</a>
<a name="ln2552">        if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln2553">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln2554">        } else {</a>
<a name="ln2555">          stp-&gt;st_score = (stp-&gt;st_score * 3 + stp-&gt;st_altscore) / 4;</a>
<a name="ln2556">        }</a>
<a name="ln2557">        stp-&gt;st_salscore = false;</a>
<a name="ln2558">      }</a>
<a name="ln2559">      break;</a>
<a name="ln2560">    }</a>
<a name="ln2561">  }</a>
<a name="ln2562"> </a>
<a name="ln2563">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln2564">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln2565">                              su-&gt;su_maxcount);</a>
<a name="ln2566">    return;</a>
<a name="ln2567">  }</a>
<a name="ln2568"> </a>
<a name="ln2569">  // Add the alternate score to su_sga.</a>
<a name="ln2570">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; i++) {</a>
<a name="ln2571">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln2572">    stp-&gt;st_altscore = spell_edit_score(slang, su-&gt;su_badword, stp-&gt;st_word);</a>
<a name="ln2573">    if (stp-&gt;st_score == SCORE_MAXMAX) {</a>
<a name="ln2574">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln2575">    } else {</a>
<a name="ln2576">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln2577">    }</a>
<a name="ln2578">    stp-&gt;st_salscore = true;</a>
<a name="ln2579">  }</a>
<a name="ln2580"> </a>
<a name="ln2581">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln2582">  // for both lists.</a>
<a name="ln2583">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln2584">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln2585">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln2586">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln2587"> </a>
<a name="ln2588">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln2589">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln2590"> </a>
<a name="ln2591">  stp = &amp;SUG(ga, 0);</a>
<a name="ln2592">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; i++) {</a>
<a name="ln2593">    // round 1: get a suggestion from su_ga</a>
<a name="ln2594">    // round 2: get a suggestion from su_sga</a>
<a name="ln2595">    for (round = 1; round &lt;= 2; round++) {</a>
<a name="ln2596">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln2597">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln2598">        // Don't add a word if it's already there.</a>
<a name="ln2599">        p = SUG(*gap, i).st_word;</a>
<a name="ln2600">        int j;</a>
<a name="ln2601">        for (j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2602">          if (strcmp(stp[j].st_word, p) == 0) {</a>
<a name="ln2603">            break;</a>
<a name="ln2604">          }</a>
<a name="ln2605">        }</a>
<a name="ln2606">        if (j == ga.ga_len) {</a>
<a name="ln2607">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln2608">        } else {</a>
<a name="ln2609">          xfree(p);</a>
<a name="ln2610">        }</a>
<a name="ln2611">      }</a>
<a name="ln2612">    }</a>
<a name="ln2613">  }</a>
<a name="ln2614"> </a>
<a name="ln2615">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln2616">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln2617"> </a>
<a name="ln2618">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln2619">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln2620">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; i++) {</a>
<a name="ln2621">      xfree(stp[i].st_word);</a>
<a name="ln2622">    }</a>
<a name="ln2623">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln2624">  }</a>
<a name="ln2625"> </a>
<a name="ln2626">  su-&gt;su_ga = ga;</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">/// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln2630">/// badword.</a>
<a name="ln2631">///</a>
<a name="ln2632">/// @param badsound  sound-folded badword</a>
<a name="ln2633">static int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char *badsound)</a>
<a name="ln2634">{</a>
<a name="ln2635">  char *pbad;</a>
<a name="ln2636">  char *pgood;</a>
<a name="ln2637">  char badsound2[MAXWLEN];</a>
<a name="ln2638">  char fword[MAXWLEN];</a>
<a name="ln2639">  char goodsound[MAXWLEN];</a>
<a name="ln2640">  char goodword[MAXWLEN];</a>
<a name="ln2641"> </a>
<a name="ln2642">  int lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln2643">  if (lendiff &gt;= 0) {</a>
<a name="ln2644">    pbad = badsound;</a>
<a name="ln2645">  } else {</a>
<a name="ln2646">    // soundfold the bad word with more characters following</a>
<a name="ln2647">    (void)spell_casefold(curwin, su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln2648"> </a>
<a name="ln2649">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln2650">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln2651">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln2652">    // space.</a>
<a name="ln2653">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln2654">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL) {</a>
<a name="ln2655">      for (char *p = fword; *(p = skiptowhite(p)) != NUL;) {</a>
<a name="ln2656">        STRMOVE(p, p + 1);</a>
<a name="ln2657">      }</a>
<a name="ln2658">    }</a>
<a name="ln2659"> </a>
<a name="ln2660">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln2661">    pbad = badsound2;</a>
<a name="ln2662">  }</a>
<a name="ln2663"> </a>
<a name="ln2664">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln2665">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln2666">    // what replaces the bad word.</a>
<a name="ln2667">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln2668">    xstrlcpy(goodword + stp-&gt;st_wordlen,</a>
<a name="ln2669">             su-&gt;su_badptr + su-&gt;su_badlen - lendiff, (size_t)lendiff + 1);</a>
<a name="ln2670">    pgood = goodword;</a>
<a name="ln2671">  } else {</a>
<a name="ln2672">    pgood = stp-&gt;st_word;</a>
<a name="ln2673">  }</a>
<a name="ln2674"> </a>
<a name="ln2675">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln2676">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln2677"> </a>
<a name="ln2678">  return soundalike_score(goodsound, pbad);</a>
<a name="ln2679">}</a>
<a name="ln2680"> </a>
<a name="ln2681">/// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln2682">/// handled already.</a>
<a name="ln2683">typedef struct {</a>
<a name="ln2684">  int16_t sft_score;   ///&lt; lowest score used</a>
<a name="ln2685">  uint8_t sft_word[];   ///&lt; soundfolded word</a>
<a name="ln2686">} sftword_T;</a>
<a name="ln2687"> </a>
<a name="ln2688">static sftword_T dumsft;</a>
<a name="ln2689">#define HIKEY2SFT(p)  ((sftword_T *)((p) - (dumsft.sft_word - (uint8_t *)&amp;dumsft)))</a>
<a name="ln2690">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln2691"> </a>
<a name="ln2692">/// Prepare for calling suggest_try_soundalike().</a>
<a name="ln2693">static void suggest_try_soundalike_prep(void)</a>
<a name="ln2694">{</a>
<a name="ln2695">  langp_T *lp;</a>
<a name="ln2696">  slang_T *slang;</a>
<a name="ln2697"> </a>
<a name="ln2698">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2699">  // .sug file has been loaded.</a>
<a name="ln2700">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2701">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2702">    slang = lp-&gt;lp_slang;</a>
<a name="ln2703">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2704">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln2705">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2706">    }</a>
<a name="ln2707">  }</a>
<a name="ln2708">}</a>
<a name="ln2709"> </a>
<a name="ln2710">/// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln2711">/// Note: This doesn't support postponed prefixes.</a>
<a name="ln2712">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln2713">{</a>
<a name="ln2714">  char salword[MAXWLEN];</a>
<a name="ln2715">  langp_T *lp;</a>
<a name="ln2716">  slang_T *slang;</a>
<a name="ln2717"> </a>
<a name="ln2718">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2719">  // .sug file has been loaded.</a>
<a name="ln2720">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2721">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2722">    slang = lp-&gt;lp_slang;</a>
<a name="ln2723">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2724">      // soundfold the bad word</a>
<a name="ln2725">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln2726"> </a>
<a name="ln2727">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln2728">      // TODO(vim): also soundfold the next words, so that we can try joining</a>
<a name="ln2729">      // and splitting</a>
<a name="ln2730">#ifdef SUGGEST_PROFILE</a>
<a name="ln2731">      prof_init();</a>
<a name="ln2732">#endif</a>
<a name="ln2733">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln2734">#ifdef SUGGEST_PROFILE</a>
<a name="ln2735">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln2736">#endif</a>
<a name="ln2737">    }</a>
<a name="ln2738">  }</a>
<a name="ln2739">}</a>
<a name="ln2740"> </a>
<a name="ln2741">/// Finish up after calling suggest_try_soundalike().</a>
<a name="ln2742">static void suggest_try_soundalike_finish(void)</a>
<a name="ln2743">{</a>
<a name="ln2744">  langp_T *lp;</a>
<a name="ln2745">  slang_T *slang;</a>
<a name="ln2746">  int todo;</a>
<a name="ln2747">  hashitem_T *hi;</a>
<a name="ln2748"> </a>
<a name="ln2749">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln2750">  // .sug file has been loaded.</a>
<a name="ln2751">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2752">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2753">    slang = lp-&gt;lp_slang;</a>
<a name="ln2754">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln2755">      // Free the info about handled words.</a>
<a name="ln2756">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln2757">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln2758">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln2759">          xfree(HI2SFT(hi));</a>
<a name="ln2760">          todo--;</a>
<a name="ln2761">        }</a>
<a name="ln2762">      }</a>
<a name="ln2763"> </a>
<a name="ln2764">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln2765">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2766">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln2767">    }</a>
<a name="ln2768">  }</a>
<a name="ln2769">}</a>
<a name="ln2770"> </a>
<a name="ln2771">/// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln2772">/// produce this soundfolded word.</a>
<a name="ln2773">///</a>
<a name="ln2774">/// @param score  soundfold score</a>
<a name="ln2775">static void add_sound_suggest(suginfo_T *su, char *goodword, int score, langp_T *lp)</a>
<a name="ln2776">{</a>
<a name="ln2777">  slang_T *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln2778">  char theword[MAXWLEN];</a>
<a name="ln2779">  int i;</a>
<a name="ln2780">  int wlen;</a>
<a name="ln2781">  uint8_t *byts;</a>
<a name="ln2782">  idx_T *idxs;</a>
<a name="ln2783">  int n;</a>
<a name="ln2784">  int wordcount;</a>
<a name="ln2785">  int wc;</a>
<a name="ln2786">  int goodscore;</a>
<a name="ln2787">  sftword_T *sft;</a>
<a name="ln2788">  int bc, gc;</a>
<a name="ln2789">  int limit;</a>
<a name="ln2790"> </a>
<a name="ln2791">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln2792">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln2793">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln2794">  // remember the words that have been done.</a>
<a name="ln2795">  hash_T hash = hash_hash(goodword);</a>
<a name="ln2796">  const size_t goodword_len = strlen(goodword);</a>
<a name="ln2797">  hashitem_T *hi = hash_lookup(&amp;slang-&gt;sl_sounddone, goodword, goodword_len, hash);</a>
<a name="ln2798">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2799">    sft = xmalloc(offsetof(sftword_T, sft_word) + goodword_len + 1);</a>
<a name="ln2800">    sft-&gt;sft_score = (int16_t)score;</a>
<a name="ln2801">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln2802">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, (char *)sft-&gt;sft_word, hash);</a>
<a name="ln2803">  } else {</a>
<a name="ln2804">    sft = HI2SFT(hi);</a>
<a name="ln2805">    if (score &gt;= sft-&gt;sft_score) {</a>
<a name="ln2806">      return;</a>
<a name="ln2807">    }</a>
<a name="ln2808">    sft-&gt;sft_score = (int16_t)score;</a>
<a name="ln2809">  }</a>
<a name="ln2810"> </a>
<a name="ln2811">  // Find the word nr in the soundfold tree.</a>
<a name="ln2812">  int sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln2813">  if (sfwordnr &lt; 0) {</a>
<a name="ln2814">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln2815">    return;</a>
<a name="ln2816">  }</a>
<a name="ln2817"> </a>
<a name="ln2818">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln2819">  char *nrline = ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln2820">  int orgnr = 0;</a>
<a name="ln2821">  while (*nrline != NUL) {</a>
<a name="ln2822">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln2823">    // previous wordnr.</a>
<a name="ln2824">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln2825"> </a>
<a name="ln2826">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln2827">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln2828"> </a>
<a name="ln2829">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln2830">    n = 0;</a>
<a name="ln2831">    wordcount = 0;</a>
<a name="ln2832">    for (wlen = 0; wlen &lt; MAXWLEN - 3; wlen++) {</a>
<a name="ln2833">      i = 1;</a>
<a name="ln2834">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL) {</a>
<a name="ln2835">        break;          // found end of word</a>
<a name="ln2836">      }</a>
<a name="ln2837">      if (byts[n + 1] == NUL) {</a>
<a name="ln2838">        wordcount++;</a>
<a name="ln2839">      }</a>
<a name="ln2840"> </a>
<a name="ln2841">      // skip over the NUL bytes</a>
<a name="ln2842">      for (; byts[n + i] == NUL; i++) {</a>
<a name="ln2843">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln2844">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln2845">          wlen += 3;</a>
<a name="ln2846">          goto badword;</a>
<a name="ln2847">        }</a>
<a name="ln2848">      }</a>
<a name="ln2849"> </a>
<a name="ln2850">      // One of the siblings must have the word.</a>
<a name="ln2851">      for (; i &lt; byts[n]; i++) {</a>
<a name="ln2852">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln2853">        if (wordcount + wc &gt; orgnr) {</a>
<a name="ln2854">          break;</a>
<a name="ln2855">        }</a>
<a name="ln2856">        wordcount += wc;</a>
<a name="ln2857">      }</a>
<a name="ln2858"> </a>
<a name="ln2859">      theword[wlen] = (char)byts[n + i];</a>
<a name="ln2860">      n = idxs[n + i];</a>
<a name="ln2861">    }</a>
<a name="ln2862">badword:</a>
<a name="ln2863">    theword[wlen] = NUL;</a>
<a name="ln2864"> </a>
<a name="ln2865">    // Go over the possible flags and regions.</a>
<a name="ln2866">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; i++) {</a>
<a name="ln2867">      char cword[MAXWLEN];</a>
<a name="ln2868">      char *p;</a>
<a name="ln2869">      int flags = (int)idxs[n + i];</a>
<a name="ln2870"> </a>
<a name="ln2871">      // Skip words with the NOSUGGEST flag</a>
<a name="ln2872">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln2873">        continue;</a>
<a name="ln2874">      }</a>
<a name="ln2875"> </a>
<a name="ln2876">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2877">        // Must find the word in the keep-case tree.</a>
<a name="ln2878">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln2879">        p = cword;</a>
<a name="ln2880">      } else {</a>
<a name="ln2881">        flags |= su-&gt;su_badflags;</a>
<a name="ln2882">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln2883">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln2884">          make_case_word(theword, cword, flags);</a>
<a name="ln2885">          p = cword;</a>
<a name="ln2886">        } else {</a>
<a name="ln2887">          p = theword;</a>
<a name="ln2888">        }</a>
<a name="ln2889">      }</a>
<a name="ln2890"> </a>
<a name="ln2891">      // Add the suggestion.</a>
<a name="ln2892">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln2893">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln2894">        if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln2895">          add_suggestion(su, &amp;su-&gt;su_sga, p, su-&gt;su_badlen,</a>
<a name="ln2896">                         score, 0, false, slang, false);</a>
<a name="ln2897">        }</a>
<a name="ln2898">      } else {</a>
<a name="ln2899">        // Add a penalty for words in another region.</a>
<a name="ln2900">        if ((flags &amp; WF_REGION)</a>
<a name="ln2901">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; (unsigned)lp-&gt;lp_region) == 0) {</a>
<a name="ln2902">          goodscore = SCORE_REGION;</a>
<a name="ln2903">        } else {</a>
<a name="ln2904">          goodscore = 0;</a>
<a name="ln2905">        }</a>
<a name="ln2906"> </a>
<a name="ln2907">        // Add a small penalty for changing the first letter from</a>
<a name="ln2908">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln2909">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln2910">        // letter is the same, that has already been counted.</a>
<a name="ln2911">        gc = utf_ptr2char(p);</a>
<a name="ln2912">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln2913">          bc = utf_ptr2char(su-&gt;su_badword);</a>
<a name="ln2914">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln2915">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc)) {</a>
<a name="ln2916">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln2917">          }</a>
<a name="ln2918">        }</a>
<a name="ln2919"> </a>
<a name="ln2920">        // Compute the score for the good word.  This only does letter</a>
<a name="ln2921">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln2922">        // which may make the score a bit higher.</a>
<a name="ln2923">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln2924">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln2925">        // If the limit is very high then the iterative method is</a>
<a name="ln2926">        // inefficient, using an array is quicker.</a>
<a name="ln2927">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln2928">        if (limit &gt; SCORE_LIMITMAX) {</a>
<a name="ln2929">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln2930">        } else {</a>
<a name="ln2931">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword, p, limit);</a>
<a name="ln2932">        }</a>
<a name="ln2933"> </a>
<a name="ln2934">        // When going over the limit don't bother to do the rest.</a>
<a name="ln2935">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln2936">          // Give a bonus to words seen before.</a>
<a name="ln2937">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln2938"> </a>
<a name="ln2939">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln2940">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln2941">          if (goodscore &lt;= su-&gt;su_sfmaxscore) {</a>
<a name="ln2942">            add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln2943">                           goodscore, score, true, slang, true);</a>
<a name="ln2944">          }</a>
<a name="ln2945">        }</a>
<a name="ln2946">      }</a>
<a name="ln2947">    }</a>
<a name="ln2948">  }</a>
<a name="ln2949">}</a>
<a name="ln2950"> </a>
<a name="ln2951">/// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln2952">static int soundfold_find(slang_T *slang, char *word)</a>
<a name="ln2953">{</a>
<a name="ln2954">  idx_T arridx = 0;</a>
<a name="ln2955">  int wlen = 0;</a>
<a name="ln2956">  uint8_t *ptr = (uint8_t *)word;</a>
<a name="ln2957">  int wordnr = 0;</a>
<a name="ln2958"> </a>
<a name="ln2959">  uint8_t *byts = slang-&gt;sl_sbyts;</a>
<a name="ln2960">  idx_T *idxs = slang-&gt;sl_sidxs;</a>
<a name="ln2961"> </a>
<a name="ln2962">  while (true) {</a>
<a name="ln2963">    // First byte is the number of possible bytes.</a>
<a name="ln2964">    int len = byts[arridx++];</a>
<a name="ln2965"> </a>
<a name="ln2966">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln2967">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln2968">    int c = ptr[wlen];</a>
<a name="ln2969">    if (byts[arridx] == NUL) {</a>
<a name="ln2970">      if (c == NUL) {</a>
<a name="ln2971">        break;</a>
<a name="ln2972">      }</a>
<a name="ln2973"> </a>
<a name="ln2974">      // Skip over the zeros, there can be several.</a>
<a name="ln2975">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln2976">        arridx++;</a>
<a name="ln2977">        len--;</a>
<a name="ln2978">      }</a>
<a name="ln2979">      if (len == 0) {</a>
<a name="ln2980">        return -1;            // no children, word should have ended here</a>
<a name="ln2981">      }</a>
<a name="ln2982">      wordnr++;</a>
<a name="ln2983">    }</a>
<a name="ln2984"> </a>
<a name="ln2985">    // If the word ends we didn't find it.</a>
<a name="ln2986">    if (c == NUL) {</a>
<a name="ln2987">      return -1;</a>
<a name="ln2988">    }</a>
<a name="ln2989"> </a>
<a name="ln2990">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln2991">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln2992">      c = ' ';</a>
<a name="ln2993">    }</a>
<a name="ln2994">    while (byts[arridx] &lt; c) {</a>
<a name="ln2995">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln2996">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln2997">      arridx++;</a>
<a name="ln2998">      if (--len == 0) {         // end of the bytes, didn't find it</a>
<a name="ln2999">        return -1;</a>
<a name="ln3000">      }</a>
<a name="ln3001">    }</a>
<a name="ln3002">    if (byts[arridx] != c) {    // didn't find the byte</a>
<a name="ln3003">      return -1;</a>
<a name="ln3004">    }</a>
<a name="ln3005"> </a>
<a name="ln3006">    // Continue at the child (if there is one).</a>
<a name="ln3007">    arridx = idxs[arridx];</a>
<a name="ln3008">    wlen++;</a>
<a name="ln3009"> </a>
<a name="ln3010">    // One space in the good word may stand for several spaces in the</a>
<a name="ln3011">    // checked word.</a>
<a name="ln3012">    if (c == ' ') {</a>
<a name="ln3013">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB) {</a>
<a name="ln3014">        wlen++;</a>
<a name="ln3015">      }</a>
<a name="ln3016">    }</a>
<a name="ln3017">  }</a>
<a name="ln3018"> </a>
<a name="ln3019">  return wordnr;</a>
<a name="ln3020">}</a>
<a name="ln3021"> </a>
<a name="ln3022">/// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln3023">/// lines in the .aff file.</a>
<a name="ln3024">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln3025">{</a>
<a name="ln3026">  int m1, m2;</a>
<a name="ln3027">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln3028">  hashitem_T *hi;</a>
<a name="ln3029"> </a>
<a name="ln3030">  if (c1 &gt;= 256) {</a>
<a name="ln3031">    buf[utf_char2bytes(c1, buf)] = 0;</a>
<a name="ln3032">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln3033">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3034">      m1 = 0;</a>
<a name="ln3035">    } else {</a>
<a name="ln3036">      m1 = utf_ptr2char(hi-&gt;hi_key + strlen(hi-&gt;hi_key) + 1);</a>
<a name="ln3037">    }</a>
<a name="ln3038">  } else {</a>
<a name="ln3039">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln3040">  }</a>
<a name="ln3041">  if (m1 == 0) {</a>
<a name="ln3042">    return false;</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  if (c2 &gt;= 256) {</a>
<a name="ln3046">    buf[utf_char2bytes(c2, buf)] = 0;</a>
<a name="ln3047">    hi = hash_find(&amp;slang-&gt;sl_map_hash, buf);</a>
<a name="ln3048">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln3049">      m2 = 0;</a>
<a name="ln3050">    } else {</a>
<a name="ln3051">      m2 = utf_ptr2char(hi-&gt;hi_key + strlen(hi-&gt;hi_key) + 1);</a>
<a name="ln3052">    }</a>
<a name="ln3053">  } else {</a>
<a name="ln3054">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln3055">  }</a>
<a name="ln3056"> </a>
<a name="ln3057">  return m1 == m2;</a>
<a name="ln3058">}</a>
<a name="ln3059"> </a>
<a name="ln3060">/// Adds a suggestion to the list of suggestions.</a>
<a name="ln3061">/// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln3062">///</a>
<a name="ln3063">/// @param gap  either su_ga or su_sga</a>
<a name="ln3064">/// @param badlenarg  len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln3065">/// @param had_bonus  value for st_had_bonus</a>
<a name="ln3066">/// @param slang  language for sound folding</a>
<a name="ln3067">/// @param maxsf  su_maxscore applies to soundfold score, su_sfmaxscore to the total score.</a>
<a name="ln3068">static void add_suggestion(suginfo_T *su, garray_T *gap, const char *goodword, int badlenarg,</a>
<a name="ln3069">                           int score, int altscore, bool had_bonus, slang_T *slang, bool maxsf)</a>
<a name="ln3070">{</a>
<a name="ln3071">  int goodlen;                  // len of goodword changed</a>
<a name="ln3072">  int badlen;                   // len of bad word changed</a>
<a name="ln3073">  suggest_T *stp;</a>
<a name="ln3074">  suggest_T new_sug;</a>
<a name="ln3075"> </a>
<a name="ln3076">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln3077">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln3078">  const char *pgood = goodword + strlen(goodword);</a>
<a name="ln3079">  char *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln3080">  while (true) {</a>
<a name="ln3081">    goodlen = (int)(pgood - goodword);</a>
<a name="ln3082">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln3083">    if (goodlen &lt;= 0 || badlen &lt;= 0) {</a>
<a name="ln3084">      break;</a>
<a name="ln3085">    }</a>
<a name="ln3086">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln3087">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln3088">    if (utf_ptr2char(pgood) != utf_ptr2char(pbad)) {</a>
<a name="ln3089">      break;</a>
<a name="ln3090">    }</a>
<a name="ln3091">  }</a>
<a name="ln3092"> </a>
<a name="ln3093">  if (badlen == 0 &amp;&amp; goodlen == 0) {</a>
<a name="ln3094">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln3095">    // the first &quot;the&quot; to itself.</a>
<a name="ln3096">    return;</a>
<a name="ln3097">  }</a>
<a name="ln3098"> </a>
<a name="ln3099">  int i;</a>
<a name="ln3100">  if (GA_EMPTY(gap)) {</a>
<a name="ln3101">    i = -1;</a>
<a name="ln3102">  } else {</a>
<a name="ln3103">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln3104">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln3105">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln3106">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln3107">    for (i = gap-&gt;ga_len; --i &gt;= 0; stp++) {</a>
<a name="ln3108">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln3109">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln3110">          &amp;&amp; strncmp(stp-&gt;st_word, goodword, (size_t)goodlen) == 0) {</a>
<a name="ln3111">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln3112">        if (stp-&gt;st_slang == NULL) {</a>
<a name="ln3113">          stp-&gt;st_slang = slang;</a>
<a name="ln3114">        }</a>
<a name="ln3115"> </a>
<a name="ln3116">        new_sug.st_score = score;</a>
<a name="ln3117">        new_sug.st_altscore = altscore;</a>
<a name="ln3118">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln3119"> </a>
<a name="ln3120">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln3121">          // Only one of the two had the soundalike score computed.</a>
<a name="ln3122">          // Need to do that for the other one now, otherwise the</a>
<a name="ln3123">          // scores can't be compared.  This happens because</a>
<a name="ln3124">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln3125">          // word to keep it fast, while some special methods set</a>
<a name="ln3126">          // the soundalike score to zero.</a>
<a name="ln3127">          if (had_bonus) {</a>
<a name="ln3128">            rescore_one(su, stp);</a>
<a name="ln3129">          } else {</a>
<a name="ln3130">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln3131">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln3132">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln3133">            new_sug.st_orglen = badlen;</a>
<a name="ln3134">            rescore_one(su, &amp;new_sug);</a>
<a name="ln3135">          }</a>
<a name="ln3136">        }</a>
<a name="ln3137"> </a>
<a name="ln3138">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln3139">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln3140">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln3141">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln3142">        }</a>
<a name="ln3143">        break;</a>
<a name="ln3144">      }</a>
<a name="ln3145">    }</a>
<a name="ln3146">  }</a>
<a name="ln3147"> </a>
<a name="ln3148">  if (i &lt; 0) {</a>
<a name="ln3149">    // Add a suggestion.</a>
<a name="ln3150">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln3151">    stp-&gt;st_word = xstrnsave(goodword, (size_t)goodlen);</a>
<a name="ln3152">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln3153">    stp-&gt;st_score = score;</a>
<a name="ln3154">    stp-&gt;st_altscore = altscore;</a>
<a name="ln3155">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln3156">    stp-&gt;st_orglen = badlen;</a>
<a name="ln3157">    stp-&gt;st_slang = slang;</a>
<a name="ln3158"> </a>
<a name="ln3159">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln3160">    // the best suggestions.</a>
<a name="ln3161">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln3162">      if (maxsf) {</a>
<a name="ln3163">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln3164">                                                su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln3165">      } else {</a>
<a name="ln3166">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln3167">                                              su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln3168">      }</a>
<a name="ln3169">    }</a>
<a name="ln3170">  }</a>
<a name="ln3171">}</a>
<a name="ln3172"> </a>
<a name="ln3173">/// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln3174">/// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln3175">///</a>
<a name="ln3176">/// @param gap  either su_ga or su_sga</a>
<a name="ln3177">static void check_suggestions(suginfo_T *su, garray_T *gap)</a>
<a name="ln3178">{</a>
<a name="ln3179">  char longword[MAXWLEN + 1];</a>
<a name="ln3180">  hlf_T attr;</a>
<a name="ln3181"> </a>
<a name="ln3182">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln3183">    return;</a>
<a name="ln3184">  }</a>
<a name="ln3185">  suggest_T *stp = &amp;SUG(*gap, 0);</a>
<a name="ln3186">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; i--) {</a>
<a name="ln3187">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln3188">    xstrlcpy(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln3189">    int len = stp[i].st_wordlen;</a>
<a name="ln3190">    xstrlcpy(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln3191">             (size_t)(MAXWLEN - len + 1));</a>
<a name="ln3192">    attr = HLF_COUNT;</a>
<a name="ln3193">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln3194">    if (attr != HLF_COUNT) {</a>
<a name="ln3195">      // Remove this entry.</a>
<a name="ln3196">      xfree(stp[i].st_word);</a>
<a name="ln3197">      gap-&gt;ga_len--;</a>
<a name="ln3198">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln3199">        memmove(stp + i, stp + i + 1, sizeof(suggest_T) * (size_t)(gap-&gt;ga_len - i));</a>
<a name="ln3200">      }</a>
<a name="ln3201">    }</a>
<a name="ln3202">  }</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205">/// Add a word to be banned.</a>
<a name="ln3206">static void add_banned(suginfo_T *su, char *word)</a>
<a name="ln3207">{</a>
<a name="ln3208">  hash_T hash = hash_hash(word);</a>
<a name="ln3209">  const size_t word_len = strlen(word);</a>
<a name="ln3210">  hashitem_T *hi = hash_lookup(&amp;su-&gt;su_banned, word, word_len, hash);</a>
<a name="ln3211">  if (!HASHITEM_EMPTY(hi)) {  // already present</a>
<a name="ln3212">    return;</a>
<a name="ln3213">  }</a>
<a name="ln3214">  char *s = xmemdupz(word, word_len);</a>
<a name="ln3215">  hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln3216">}</a>
<a name="ln3217"> </a>
<a name="ln3218">/// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln3219">/// is slow, thus only done for the final results.</a>
<a name="ln3220">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln3221">{</a>
<a name="ln3222">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln3223">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; i++) {</a>
<a name="ln3224">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln3225">    }</a>
<a name="ln3226">  }</a>
<a name="ln3227">}</a>
<a name="ln3228"> </a>
<a name="ln3229">/// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln3230">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln3231">{</a>
<a name="ln3232">  slang_T *slang = stp-&gt;st_slang;</a>
<a name="ln3233">  char sal_badword[MAXWLEN];</a>
<a name="ln3234"> </a>
<a name="ln3235">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln3236">  // language.</a>
<a name="ln3237">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln3238">    char *p;</a>
<a name="ln3239">    if (slang == su-&gt;su_sallang) {</a>
<a name="ln3240">      p = su-&gt;su_sal_badword;</a>
<a name="ln3241">    } else {</a>
<a name="ln3242">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln3243">      p = sal_badword;</a>
<a name="ln3244">    }</a>
<a name="ln3245"> </a>
<a name="ln3246">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln3247">    if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln3248">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln3249">    }</a>
<a name="ln3250">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln3251">    stp-&gt;st_had_bonus = true;</a>
<a name="ln3252">  }</a>
<a name="ln3253">}</a>
<a name="ln3254"> </a>
<a name="ln3255">/// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln3256">/// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln3257">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln3258">{</a>
<a name="ln3259">  suggest_T *p1 = (suggest_T *)s1;</a>
<a name="ln3260">  suggest_T *p2 = (suggest_T *)s2;</a>
<a name="ln3261">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln3262"> </a>
<a name="ln3263">  if (n == 0) {</a>
<a name="ln3264">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln3265">    if (n == 0) {</a>
<a name="ln3266">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln3267">    }</a>
<a name="ln3268">  }</a>
<a name="ln3269">  return n;</a>
<a name="ln3270">}</a>
<a name="ln3271"> </a>
<a name="ln3272">/// Cleanup the suggestions:</a>
<a name="ln3273">/// - Sort on score.</a>
<a name="ln3274">/// - Remove words that won't be displayed.</a>
<a name="ln3275">///</a>
<a name="ln3276">/// @param keep  nr of suggestions to keep</a>
<a name="ln3277">///</a>
<a name="ln3278">/// @return  the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln3279">static int cleanup_suggestions(garray_T *gap, int maxscore, int keep)</a>
<a name="ln3280">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3281">{</a>
<a name="ln3282">  if (gap-&gt;ga_len &lt;= 0) {</a>
<a name="ln3283">    return maxscore;</a>
<a name="ln3284">  }</a>
<a name="ln3285"> </a>
<a name="ln3286">  // Sort the list.</a>
<a name="ln3287">  qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln3288"> </a>
<a name="ln3289">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln3290">  if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln3291">    suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln3292"> </a>
<a name="ln3293">    for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln3294">      xfree(stp[i].st_word);</a>
<a name="ln3295">    }</a>
<a name="ln3296">    gap-&gt;ga_len = keep;</a>
<a name="ln3297">    if (keep &gt;= 1) {</a>
<a name="ln3298">      return stp[keep - 1].st_score;</a>
<a name="ln3299">    }</a>
<a name="ln3300">  }</a>
<a name="ln3301">  return maxscore;</a>
<a name="ln3302">}</a>
<a name="ln3303"> </a>
<a name="ln3304">/// Compute a score for two sound-a-like words.</a>
<a name="ln3305">/// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln3306">/// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln3307">/// avoiding checks that will not be possible.</a>
<a name="ln3308">///</a>
<a name="ln3309">/// @param goodstart  sound-folded good word</a>
<a name="ln3310">/// @param badstart  sound-folded bad word</a>
<a name="ln3311">static int soundalike_score(char *goodstart, char *badstart)</a>
<a name="ln3312">{</a>
<a name="ln3313">  char *goodsound = goodstart;</a>
<a name="ln3314">  char *badsound = badstart;</a>
<a name="ln3315">  char *pl, *ps;</a>
<a name="ln3316">  char *pl2, *ps2;</a>
<a name="ln3317">  int score = 0;</a>
<a name="ln3318"> </a>
<a name="ln3319">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln3320">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln3321">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln3322">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln3323">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL)) {</a>
<a name="ln3324">      // changing word with vowel to word without a sound</a>
<a name="ln3325">      return SCORE_DEL;</a>
<a name="ln3326">    }</a>
<a name="ln3327">    if (badsound[0] == NUL || goodsound[0] == NUL) {</a>
<a name="ln3328">      // more than two changes</a>
<a name="ln3329">      return SCORE_MAXMAX;</a>
<a name="ln3330">    }</a>
<a name="ln3331"> </a>
<a name="ln3332">    if (badsound[1] == goodsound[1]</a>
<a name="ln3333">        || (badsound[1] != NUL</a>
<a name="ln3334">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln3335">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln3336">      // handle like a substitute</a>
<a name="ln3337">    } else {</a>
<a name="ln3338">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln3339">      if (*badsound == '*') {</a>
<a name="ln3340">        badsound++;</a>
<a name="ln3341">      } else {</a>
<a name="ln3342">        goodsound++;</a>
<a name="ln3343">      }</a>
<a name="ln3344">    }</a>
<a name="ln3345">  }</a>
<a name="ln3346"> </a>
<a name="ln3347">  int goodlen = (int)strlen(goodsound);</a>
<a name="ln3348">  int badlen = (int)strlen(badsound);</a>
<a name="ln3349"> </a>
<a name="ln3350">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln3351">  // changes.</a>
<a name="ln3352">  int n = goodlen - badlen;</a>
<a name="ln3353">  if (n &lt; -2 || n &gt; 2) {</a>
<a name="ln3354">    return SCORE_MAXMAX;</a>
<a name="ln3355">  }</a>
<a name="ln3356"> </a>
<a name="ln3357">  if (n &gt; 0) {</a>
<a name="ln3358">    pl = goodsound;         // goodsound is longest</a>
<a name="ln3359">    ps = badsound;</a>
<a name="ln3360">  } else {</a>
<a name="ln3361">    pl = badsound;          // badsound is longest</a>
<a name="ln3362">    ps = goodsound;</a>
<a name="ln3363">  }</a>
<a name="ln3364"> </a>
<a name="ln3365">  // Skip over the identical part.</a>
<a name="ln3366">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln3367">    pl++;</a>
<a name="ln3368">    ps++;</a>
<a name="ln3369">  }</a>
<a name="ln3370"> </a>
<a name="ln3371">  switch (n) {</a>
<a name="ln3372">  case -2:</a>
<a name="ln3373">  case 2:</a>
<a name="ln3374">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln3375">    pl++;               // first delete</a>
<a name="ln3376">    while (*pl == *ps) {</a>
<a name="ln3377">      pl++;</a>
<a name="ln3378">      ps++;</a>
<a name="ln3379">    }</a>
<a name="ln3380">    // strings must be equal after second delete</a>
<a name="ln3381">    if (strcmp(pl + 1, ps) == 0) {</a>
<a name="ln3382">      return score + SCORE_DEL * 2;</a>
<a name="ln3383">    }</a>
<a name="ln3384"> </a>
<a name="ln3385">    // Failed to compare.</a>
<a name="ln3386">    break;</a>
<a name="ln3387"> </a>
<a name="ln3388">  case -1:</a>
<a name="ln3389">  case 1:</a>
<a name="ln3390">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln3391"> </a>
<a name="ln3392">    // 1: delete</a>
<a name="ln3393">    pl2 = pl + 1;</a>
<a name="ln3394">    ps2 = ps;</a>
<a name="ln3395">    while (*pl2 == *ps2) {</a>
<a name="ln3396">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln3397">        return score + SCORE_DEL;</a>
<a name="ln3398">      }</a>
<a name="ln3399">      pl2++;</a>
<a name="ln3400">      ps2++;</a>
<a name="ln3401">    }</a>
<a name="ln3402"> </a>
<a name="ln3403">    // 2: delete then swap, then rest must be equal</a>
<a name="ln3404">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3405">        &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3406">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln3407">    }</a>
<a name="ln3408"> </a>
<a name="ln3409">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln3410">    if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3411">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln3412">    }</a>
<a name="ln3413"> </a>
<a name="ln3414">    // 4: first swap then delete</a>
<a name="ln3415">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln3416">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln3417">      ps2 = ps + 2;</a>
<a name="ln3418">      while (*pl2 == *ps2) {</a>
<a name="ln3419">        pl2++;</a>
<a name="ln3420">        ps2++;</a>
<a name="ln3421">      }</a>
<a name="ln3422">      // delete a char and then strings must be equal</a>
<a name="ln3423">      if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3424">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln3425">      }</a>
<a name="ln3426">    }</a>
<a name="ln3427"> </a>
<a name="ln3428">    // 5: first substitute then delete</a>
<a name="ln3429">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln3430">    ps2 = ps + 1;</a>
<a name="ln3431">    while (*pl2 == *ps2) {</a>
<a name="ln3432">      pl2++;</a>
<a name="ln3433">      ps2++;</a>
<a name="ln3434">    }</a>
<a name="ln3435">    // delete a char and then strings must be equal</a>
<a name="ln3436">    if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3437">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln3438">    }</a>
<a name="ln3439"> </a>
<a name="ln3440">    // Failed to compare.</a>
<a name="ln3441">    break;</a>
<a name="ln3442"> </a>
<a name="ln3443">  case 0:</a>
<a name="ln3444">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln3445">    // insert is only possible in combination with a delete.</a>
<a name="ln3446">    // 1: check if for identical strings</a>
<a name="ln3447">    if (*pl == NUL) {</a>
<a name="ln3448">      return score;</a>
<a name="ln3449">    }</a>
<a name="ln3450"> </a>
<a name="ln3451">    // 2: swap</a>
<a name="ln3452">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln3453">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln3454">      ps2 = ps + 2;</a>
<a name="ln3455">      while (*pl2 == *ps2) {</a>
<a name="ln3456">        if (*pl2 == NUL) {              // reached the end</a>
<a name="ln3457">          return score + SCORE_SWAP;</a>
<a name="ln3458">        }</a>
<a name="ln3459">        pl2++;</a>
<a name="ln3460">        ps2++;</a>
<a name="ln3461">      }</a>
<a name="ln3462">      // 3: swap and swap again</a>
<a name="ln3463">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3464">          &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3465">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln3466">      }</a>
<a name="ln3467"> </a>
<a name="ln3468">      // 4: swap and substitute</a>
<a name="ln3469">      if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3470">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln3471">      }</a>
<a name="ln3472">    }</a>
<a name="ln3473"> </a>
<a name="ln3474">    // 5: substitute</a>
<a name="ln3475">    pl2 = pl + 1;</a>
<a name="ln3476">    ps2 = ps + 1;</a>
<a name="ln3477">    while (*pl2 == *ps2) {</a>
<a name="ln3478">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln3479">        return score + SCORE_SUBST;</a>
<a name="ln3480">      }</a>
<a name="ln3481">      pl2++;</a>
<a name="ln3482">      ps2++;</a>
<a name="ln3483">    }</a>
<a name="ln3484"> </a>
<a name="ln3485">    // 6: substitute and swap</a>
<a name="ln3486">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln3487">        &amp;&amp; strcmp(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln3488">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln3489">    }</a>
<a name="ln3490"> </a>
<a name="ln3491">    // 7: substitute and substitute</a>
<a name="ln3492">    if (strcmp(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln3493">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln3494">    }</a>
<a name="ln3495"> </a>
<a name="ln3496">    // 8: insert then delete</a>
<a name="ln3497">    pl2 = pl;</a>
<a name="ln3498">    ps2 = ps + 1;</a>
<a name="ln3499">    while (*pl2 == *ps2) {</a>
<a name="ln3500">      pl2++;</a>
<a name="ln3501">      ps2++;</a>
<a name="ln3502">    }</a>
<a name="ln3503">    if (strcmp(pl2 + 1, ps2) == 0) {</a>
<a name="ln3504">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln3505">    }</a>
<a name="ln3506"> </a>
<a name="ln3507">    // 9: delete then insert</a>
<a name="ln3508">    pl2 = pl + 1;</a>
<a name="ln3509">    ps2 = ps;</a>
<a name="ln3510">    while (*pl2 == *ps2) {</a>
<a name="ln3511">      pl2++;</a>
<a name="ln3512">      ps2++;</a>
<a name="ln3513">    }</a>
<a name="ln3514">    if (strcmp(pl2, ps2 + 1) == 0) {</a>
<a name="ln3515">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln3516">    }</a>
<a name="ln3517"> </a>
<a name="ln3518">    // Failed to compare.</a>
<a name="ln3519">    break;</a>
<a name="ln3520">  }</a>
<a name="ln3521"> </a>
<a name="ln3522">  return SCORE_MAXMAX;</a>
<a name="ln3523">}</a>
<a name="ln3524"> </a>
<a name="ln3525">/// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln3526">/// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln3527">///</a>
<a name="ln3528">/// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln3529">/// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln3530">/// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln3531">/// support multi-byte characters.</a>
<a name="ln3532">static int spell_edit_score(slang_T *slang, const char *badword, const char *goodword)</a>
<a name="ln3533">{</a>
<a name="ln3534">  int *cnt;</a>
<a name="ln3535">  int j, i;</a>
<a name="ln3536">  int t;</a>
<a name="ln3537">  int bc, gc;</a>
<a name="ln3538">  int pbc, pgc;</a>
<a name="ln3539">  int wbadword[MAXWLEN];</a>
<a name="ln3540">  int wgoodword[MAXWLEN];</a>
<a name="ln3541"> </a>
<a name="ln3542">  // Lengths with NUL.</a>
<a name="ln3543">  int badlen;</a>
<a name="ln3544">  int goodlen;</a>
<a name="ln3545">  {</a>
<a name="ln3546">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln3547">    // int array for easy access.</a>
<a name="ln3548">    badlen = 0;</a>
<a name="ln3549">    for (const char *p = badword; *p != NUL;) {</a>
<a name="ln3550">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3551">    }</a>
<a name="ln3552">    wbadword[badlen++] = 0;</a>
<a name="ln3553">    goodlen = 0;</a>
<a name="ln3554">    for (const char *p = goodword; *p != NUL;) {</a>
<a name="ln3555">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3556">    }</a>
<a name="ln3557">    wgoodword[goodlen++] = 0;</a>
<a name="ln3558">  }</a>
<a name="ln3559"> </a>
<a name="ln3560">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln3561">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln3562">  cnt = xmalloc(sizeof(int) * ((size_t)badlen + 1) * ((size_t)goodlen + 1));</a>
<a name="ln3563"> </a>
<a name="ln3564">  CNT(0, 0) = 0;</a>
<a name="ln3565">  for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln3566">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln3567">  }</a>
<a name="ln3568"> </a>
<a name="ln3569">  for (i = 1; i &lt;= badlen; i++) {</a>
<a name="ln3570">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln3571">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln3572">      bc = wbadword[i - 1];</a>
<a name="ln3573">      gc = wgoodword[j - 1];</a>
<a name="ln3574">      if (bc == gc) {</a>
<a name="ln3575">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln3576">      } else {</a>
<a name="ln3577">        // Use a better score when there is only a case difference.</a>
<a name="ln3578">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln3579">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln3580">        } else {</a>
<a name="ln3581">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln3582">          if (slang != NULL</a>
<a name="ln3583">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln3584">              &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln3585">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln3586">          } else {</a>
<a name="ln3587">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln3588">          }</a>
<a name="ln3589">        }</a>
<a name="ln3590"> </a>
<a name="ln3591">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln3592">          pbc = wbadword[i - 2];</a>
<a name="ln3593">          pgc = wgoodword[j - 2];</a>
<a name="ln3594">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln3595">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln3596">            if (t &lt; CNT(i, j)) {</a>
<a name="ln3597">              CNT(i, j) = t;</a>
<a name="ln3598">            }</a>
<a name="ln3599">          }</a>
<a name="ln3600">        }</a>
<a name="ln3601">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln3602">        if (t &lt; CNT(i, j)) {</a>
<a name="ln3603">          CNT(i, j) = t;</a>
<a name="ln3604">        }</a>
<a name="ln3605">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln3606">        if (t &lt; CNT(i, j)) {</a>
<a name="ln3607">          CNT(i, j) = t;</a>
<a name="ln3608">        }</a>
<a name="ln3609">      }</a>
<a name="ln3610">    }</a>
<a name="ln3611">  }</a>
<a name="ln3612"> </a>
<a name="ln3613">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln3614">  xfree(cnt);</a>
<a name="ln3615">  return i;</a>
<a name="ln3616">}</a>
<a name="ln3617"> </a>
<a name="ln3618">typedef struct {</a>
<a name="ln3619">  int badi;</a>
<a name="ln3620">  int goodi;</a>
<a name="ln3621">  int score;</a>
<a name="ln3622">} limitscore_T;</a>
<a name="ln3623"> </a>
<a name="ln3624">/// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln3625">/// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln3626">///</a>
<a name="ln3627">/// This uses a stack for the edits still to be tried.</a>
<a name="ln3628">/// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln3629">/// for multi-byte characters.</a>
<a name="ln3630">static int spell_edit_score_limit(slang_T *slang, char *badword, char *goodword, int limit)</a>
<a name="ln3631">{</a>
<a name="ln3632">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln3633">}</a>
<a name="ln3634"> </a>
<a name="ln3635">/// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln3636">/// Keep it in sync with the above!</a>
<a name="ln3637">static int spell_edit_score_limit_w(slang_T *slang, const char *badword, const char *goodword,</a>
<a name="ln3638">                                    int limit)</a>
<a name="ln3639">{</a>
<a name="ln3640">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln3641">  int bi2, gi2;</a>
<a name="ln3642">  int bc, gc;</a>
<a name="ln3643">  int score_off;</a>
<a name="ln3644">  int round;</a>
<a name="ln3645">  int wbadword[MAXWLEN];</a>
<a name="ln3646">  int wgoodword[MAXWLEN];</a>
<a name="ln3647"> </a>
<a name="ln3648">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln3649">  // int array for easy access.</a>
<a name="ln3650">  int bi = 0;</a>
<a name="ln3651">  for (const char *p = badword; *p != NUL;) {</a>
<a name="ln3652">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3653">  }</a>
<a name="ln3654">  wbadword[bi++] = 0;</a>
<a name="ln3655">  int gi = 0;</a>
<a name="ln3656">  for (const char *p = goodword; *p != NUL;) {</a>
<a name="ln3657">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln3658">  }</a>
<a name="ln3659">  wgoodword[gi++] = 0;</a>
<a name="ln3660"> </a>
<a name="ln3661">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln3662">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln3663">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln3664">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln3665">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln3666">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln3667">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln3668">  int stackidx = 0;</a>
<a name="ln3669">  bi = 0;</a>
<a name="ln3670">  gi = 0;</a>
<a name="ln3671">  int score = 0;</a>
<a name="ln3672">  int minscore = limit + 1;</a>
<a name="ln3673"> </a>
<a name="ln3674">  while (true) {</a>
<a name="ln3675">    // Skip over an equal part, score remains the same.</a>
<a name="ln3676">    while (true) {</a>
<a name="ln3677">      bc = wbadword[bi];</a>
<a name="ln3678">      gc = wgoodword[gi];</a>
<a name="ln3679"> </a>
<a name="ln3680">      if (bc != gc) {           // stop at a char that's different</a>
<a name="ln3681">        break;</a>
<a name="ln3682">      }</a>
<a name="ln3683">      if (bc == NUL) {          // both words end</a>
<a name="ln3684">        if (score &lt; minscore) {</a>
<a name="ln3685">          minscore = score;</a>
<a name="ln3686">        }</a>
<a name="ln3687">        goto pop;               // do next alternative</a>
<a name="ln3688">      }</a>
<a name="ln3689">      bi++;</a>
<a name="ln3690">      gi++;</a>
<a name="ln3691">    }</a>
<a name="ln3692"> </a>
<a name="ln3693">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln3694">      do {</a>
<a name="ln3695">        if ((score += SCORE_DEL) &gt;= minscore) {</a>
<a name="ln3696">          goto pop;                 // do next alternative</a>
<a name="ln3697">        }</a>
<a name="ln3698">      } while (wbadword[++bi] != NUL);</a>
<a name="ln3699">      minscore = score;</a>
<a name="ln3700">    } else if (bc == NUL) {   // badword ends, insert badword chars</a>
<a name="ln3701">      do {</a>
<a name="ln3702">        if ((score += SCORE_INS) &gt;= minscore) {</a>
<a name="ln3703">          goto pop;                 // do next alternative</a>
<a name="ln3704">        }</a>
<a name="ln3705">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln3706">      minscore = score;</a>
<a name="ln3707">    } else {                  // both words continue</a>
<a name="ln3708">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln3709">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln3710">      // round 0: try deleting a char from badword</a>
<a name="ln3711">      // round 1: try inserting a char in badword</a>
<a name="ln3712">      for (round = 0; round &lt;= 1; round++) {</a>
<a name="ln3713">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln3714">        if (score_off &lt; minscore) {</a>
<a name="ln3715">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln3716">            // Near the limit, rest of the words must match.  We</a>
<a name="ln3717">            // can check that right now, no need to push an item</a>
<a name="ln3718">            // onto the stack.</a>
<a name="ln3719">            bi2 = bi + 1 - round;</a>
<a name="ln3720">            gi2 = gi + round;</a>
<a name="ln3721">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln3722">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln3723">                minscore = score_off;</a>
<a name="ln3724">                break;</a>
<a name="ln3725">              }</a>
<a name="ln3726">              bi2++;</a>
<a name="ln3727">              gi2++;</a>
<a name="ln3728">            }</a>
<a name="ln3729">          } else {</a>
<a name="ln3730">            // try deleting a character from badword later</a>
<a name="ln3731">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln3732">            stack[stackidx].goodi = gi + round;</a>
<a name="ln3733">            stack[stackidx].score = score_off;</a>
<a name="ln3734">            stackidx++;</a>
<a name="ln3735">          }</a>
<a name="ln3736">        }</a>
<a name="ln3737">      }</a>
<a name="ln3738"> </a>
<a name="ln3739">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln3740">        // If swapping two characters makes a match then the</a>
<a name="ln3741">        // substitution is more expensive, thus there is no need to</a>
<a name="ln3742">        // try both.</a>
<a name="ln3743">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln3744">          // Swap two characters, that is: skip them.</a>
<a name="ln3745">          gi += 2;</a>
<a name="ln3746">          bi += 2;</a>
<a name="ln3747">          score += SCORE_SWAP;</a>
<a name="ln3748">          continue;</a>
<a name="ln3749">        }</a>
<a name="ln3750">      }</a>
<a name="ln3751"> </a>
<a name="ln3752">      // Substitute one character for another which is the same</a>
<a name="ln3753">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln3754">      // Use a better score when there is only a case difference.</a>
<a name="ln3755">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln3756">        score += SCORE_ICASE;</a>
<a name="ln3757">      } else {</a>
<a name="ln3758">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln3759">        if (slang != NULL</a>
<a name="ln3760">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln3761">            &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln3762">          score += SCORE_SIMILAR;</a>
<a name="ln3763">        } else {</a>
<a name="ln3764">          score += SCORE_SUBST;</a>
<a name="ln3765">        }</a>
<a name="ln3766">      }</a>
<a name="ln3767"> </a>
<a name="ln3768">      if (score &lt; minscore) {</a>
<a name="ln3769">        // Do the substitution.</a>
<a name="ln3770">        gi++;</a>
<a name="ln3771">        bi++;</a>
<a name="ln3772">        continue;</a>
<a name="ln3773">      }</a>
<a name="ln3774">    }</a>
<a name="ln3775">pop:</a>
<a name="ln3776">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln3777">    if (stackidx == 0) {                // stack is empty, finished</a>
<a name="ln3778">      break;</a>
<a name="ln3779">    }</a>
<a name="ln3780"> </a>
<a name="ln3781">    // pop an item from the stack</a>
<a name="ln3782">    stackidx--;</a>
<a name="ln3783">    gi = stack[stackidx].goodi;</a>
<a name="ln3784">    bi = stack[stackidx].badi;</a>
<a name="ln3785">    score = stack[stackidx].score;</a>
<a name="ln3786">  }</a>
<a name="ln3787"> </a>
<a name="ln3788">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln3789">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln3790">  // bonus.</a>
<a name="ln3791">  if (minscore &gt; limit) {</a>
<a name="ln3792">    return SCORE_MAXMAX;</a>
<a name="ln3793">  }</a>
<a name="ln3794">  return minscore;</a>
<a name="ln3795">}</a>
</code></pre>
<div class="balloon" rel="1178"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memset' function will lead to underflow of the buffer 'sp'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>