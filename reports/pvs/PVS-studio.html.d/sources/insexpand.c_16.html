<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>insexpand.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// insexpand.c: functions for Insert mode completion</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;limits.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdint.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln18">#include &quot;nvim/change.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln21">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln22">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln23">#include &quot;nvim/edit.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln26">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln29">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln30">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln32">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln33">#include &quot;nvim/garray.h&quot;</a>
<a name="ln34">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln35">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln36">#include &quot;nvim/globals.h&quot;</a>
<a name="ln37">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln38">#include &quot;nvim/indent.h&quot;</a>
<a name="ln39">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln40">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln41">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln42">#include &quot;nvim/macros.h&quot;</a>
<a name="ln43">#include &quot;nvim/mark.h&quot;</a>
<a name="ln44">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln45">#include &quot;nvim/memline.h&quot;</a>
<a name="ln46">#include &quot;nvim/memory.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/move.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln53">#include &quot;nvim/path.h&quot;</a>
<a name="ln54">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln55">#include &quot;nvim/pos.h&quot;</a>
<a name="ln56">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln57">#include &quot;nvim/search.h&quot;</a>
<a name="ln58">#include &quot;nvim/spell.h&quot;</a>
<a name="ln59">#include &quot;nvim/state.h&quot;</a>
<a name="ln60">#include &quot;nvim/strings.h&quot;</a>
<a name="ln61">#include &quot;nvim/tag.h&quot;</a>
<a name="ln62">#include &quot;nvim/textformat.h&quot;</a>
<a name="ln63">#include &quot;nvim/types.h&quot;</a>
<a name="ln64">#include &quot;nvim/ui.h&quot;</a>
<a name="ln65">#include &quot;nvim/undo.h&quot;</a>
<a name="ln66">#include &quot;nvim/vim.h&quot;</a>
<a name="ln67">#include &quot;nvim/window.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">// Definitions used for CTRL-X submode.</a>
<a name="ln70">// Note: If you change CTRL-X submode, you must also maintain ctrl_x_msgs[]</a>
<a name="ln71">// and ctrl_x_mode_names[].</a>
<a name="ln72"> </a>
<a name="ln73">#define CTRL_X_WANT_IDENT       0x100</a>
<a name="ln74"> </a>
<a name="ln75">enum {</a>
<a name="ln76">  CTRL_X_NORMAL = 0,  ///&lt; CTRL-N CTRL-P completion, default</a>
<a name="ln77">  CTRL_X_NOT_DEFINED_YET = 1,</a>
<a name="ln78">  CTRL_X_SCROLL = 2,</a>
<a name="ln79">  CTRL_X_WHOLE_LINE = 3,</a>
<a name="ln80">  CTRL_X_FILES = 4,</a>
<a name="ln81">  CTRL_X_TAGS = (5 + CTRL_X_WANT_IDENT),</a>
<a name="ln82">  CTRL_X_PATH_PATTERNS = (6 + CTRL_X_WANT_IDENT),</a>
<a name="ln83">  CTRL_X_PATH_DEFINES = (7 + CTRL_X_WANT_IDENT),</a>
<a name="ln84">  CTRL_X_FINISHED = 8,</a>
<a name="ln85">  CTRL_X_DICTIONARY = (9 + CTRL_X_WANT_IDENT),</a>
<a name="ln86">  CTRL_X_THESAURUS = (10 + CTRL_X_WANT_IDENT),</a>
<a name="ln87">  CTRL_X_CMDLINE = 11,</a>
<a name="ln88">  CTRL_X_FUNCTION = 12,</a>
<a name="ln89">  CTRL_X_OMNI = 13,</a>
<a name="ln90">  CTRL_X_SPELL = 14,</a>
<a name="ln91">  CTRL_X_LOCAL_MSG = 15,       ///&lt; only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln92">  CTRL_X_EVAL = 16,            ///&lt; for builtin function complete()</a>
<a name="ln93">  CTRL_X_CMDLINE_CTRL_X = 17,  ///&lt; CTRL-X typed in CTRL_X_CMDLINE</a>
<a name="ln94">};</a>
<a name="ln95"> </a>
<a name="ln96">#define CTRL_X_MSG(i) ctrl_x_msgs[(i) &amp; ~CTRL_X_WANT_IDENT]</a>
<a name="ln97"> </a>
<a name="ln98">/// Message for CTRL-X mode, index is ctrl_x_mode.</a>
<a name="ln99">static char *ctrl_x_msgs[] = {</a>
<a name="ln100">  N_(&quot; Keyword completion (^N^P)&quot;),  // CTRL_X_NORMAL, ^P/^N compl.</a>
<a name="ln101">  N_(&quot; ^X mode (^]^D^E^F^I^K^L^N^O^Ps^U^V^Y)&quot;),</a>
<a name="ln102">  NULL,  // CTRL_X_SCROLL: depends on state</a>
<a name="ln103">  N_(&quot; Whole line completion (^L^N^P)&quot;),</a>
<a name="ln104">  N_(&quot; File name completion (^F^N^P)&quot;),</a>
<a name="ln105">  N_(&quot; Tag completion (^]^N^P)&quot;),</a>
<a name="ln106">  N_(&quot; Path pattern completion (^N^P)&quot;),</a>
<a name="ln107">  N_(&quot; Definition completion (^D^N^P)&quot;),</a>
<a name="ln108">  NULL,  // CTRL_X_FINISHED</a>
<a name="ln109">  N_(&quot; Dictionary completion (^K^N^P)&quot;),</a>
<a name="ln110">  N_(&quot; Thesaurus completion (^T^N^P)&quot;),</a>
<a name="ln111">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln112">  N_(&quot; User defined completion (^U^N^P)&quot;),</a>
<a name="ln113">  N_(&quot; Omni completion (^O^N^P)&quot;),</a>
<a name="ln114">  N_(&quot; Spelling suggestion (s^N^P)&quot;),</a>
<a name="ln115">  N_(&quot; Keyword Local completion (^N^P)&quot;),</a>
<a name="ln116">  NULL,  // CTRL_X_EVAL doesn't use msg.</a>
<a name="ln117">  N_(&quot; Command-line completion (^V^N^P)&quot;),</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">static char *ctrl_x_mode_names[] = {</a>
<a name="ln121">  &quot;keyword&quot;,</a>
<a name="ln122">  &quot;ctrl_x&quot;,</a>
<a name="ln123">  &quot;scroll&quot;,</a>
<a name="ln124">  &quot;whole_line&quot;,</a>
<a name="ln125">  &quot;files&quot;,</a>
<a name="ln126">  &quot;tags&quot;,</a>
<a name="ln127">  &quot;path_patterns&quot;,</a>
<a name="ln128">  &quot;path_defines&quot;,</a>
<a name="ln129">  &quot;unknown&quot;,          // CTRL_X_FINISHED</a>
<a name="ln130">  &quot;dictionary&quot;,</a>
<a name="ln131">  &quot;thesaurus&quot;,</a>
<a name="ln132">  &quot;cmdline&quot;,</a>
<a name="ln133">  &quot;function&quot;,</a>
<a name="ln134">  &quot;omni&quot;,</a>
<a name="ln135">  &quot;spell&quot;,</a>
<a name="ln136">  NULL,               // CTRL_X_LOCAL_MSG only used in &quot;ctrl_x_msgs&quot;</a>
<a name="ln137">  &quot;eval&quot;,</a>
<a name="ln138">  &quot;cmdline&quot;,</a>
<a name="ln139">};</a>
<a name="ln140"> </a>
<a name="ln141">// Array indexes used for cp_text[].</a>
<a name="ln142">#define CPT_ABBR        0   ///&lt; &quot;abbr&quot;</a>
<a name="ln143">#define CPT_MENU        1   ///&lt; &quot;menu&quot;</a>
<a name="ln144">#define CPT_KIND        2   ///&lt; &quot;kind&quot;</a>
<a name="ln145">#define CPT_INFO        3   ///&lt; &quot;info&quot;</a>
<a name="ln146">#define CPT_COUNT       4   ///&lt; Number of entries</a>
<a name="ln147"> </a>
<a name="ln148">/// Structure used to store one match for insert completion.</a>
<a name="ln149">typedef struct compl_S compl_T;</a>
<a name="ln150">struct compl_S {</a>
<a name="ln151">  compl_T *cp_next;</a>
<a name="ln152">  compl_T *cp_prev;</a>
<a name="ln153">  char *cp_str;                  ///&lt; matched text</a>
<a name="ln154">  char *(cp_text[CPT_COUNT]);    ///&lt; text for the menu</a>
<a name="ln155">  typval_T cp_user_data;</a>
<a name="ln156">  char *cp_fname;                ///&lt; file containing the match, allocated when</a>
<a name="ln157">                                 ///&lt; cp_flags has CP_FREE_FNAME</a>
<a name="ln158">  int cp_flags;                  ///&lt; CP_ values</a>
<a name="ln159">  int cp_number;                 ///&lt; sequence number</a>
<a name="ln160">};</a>
<a name="ln161"> </a>
<a name="ln162">/// state information used for getting the next set of insert completion</a>
<a name="ln163">/// matches.</a>
<a name="ln164">typedef struct {</a>
<a name="ln165">  char *e_cpt_copy;       ///&lt; copy of 'complete'</a>
<a name="ln166">  char *e_cpt;            ///&lt; current entry in &quot;e_cpt_copy&quot;</a>
<a name="ln167">  buf_T *ins_buf;         ///&lt; buffer being scanned</a>
<a name="ln168">  pos_T *cur_match_pos;   ///&lt; current match position</a>
<a name="ln169">  pos_T prev_match_pos;   ///&lt; previous match position</a>
<a name="ln170">  bool set_match_pos;     ///&lt; save first_match_pos/last_match_pos</a>
<a name="ln171">  pos_T first_match_pos;  ///&lt; first match position</a>
<a name="ln172">  pos_T last_match_pos;   ///&lt; last match position</a>
<a name="ln173">  bool found_all;         ///&lt; found all matches of a certain type.</a>
<a name="ln174">  char *dict;             ///&lt; dictionary file to search</a>
<a name="ln175">  int dict_f;             ///&lt; &quot;dict&quot; is an exact file name or not</a>
<a name="ln176">} ins_compl_next_state_T;</a>
<a name="ln177"> </a>
<a name="ln178">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln179"># include &quot;insexpand.c.generated.h&quot;</a>
<a name="ln180">#endif</a>
<a name="ln181"> </a>
<a name="ln182">/// values for cp_flags</a>
<a name="ln183">typedef enum {</a>
<a name="ln184">  CP_ORIGINAL_TEXT = 1,  ///&lt; the original text when the expansion begun</a>
<a name="ln185">  CP_FREE_FNAME = 2,     ///&lt; cp_fname is allocated</a>
<a name="ln186">  CP_CONT_S_IPOS = 4,    ///&lt; use CONT_S_IPOS for compl_cont_status</a>
<a name="ln187">  CP_EQUAL = 8,          ///&lt; ins_compl_equal() always returns true</a>
<a name="ln188">  CP_ICASE = 16,         ///&lt; ins_compl_equal ignores case</a>
<a name="ln189">  CP_FAST = 32,          ///&lt; use fast_breakcheck instead of os_breakcheck</a>
<a name="ln190">} cp_flags_T;</a>
<a name="ln191"> </a>
<a name="ln192">static const char e_hitend[] = N_(&quot;Hit end of paragraph&quot;);</a>
<a name="ln193">static const char e_compldel[] = N_(&quot;E840: Completion function deleted text&quot;);</a>
<a name="ln194"> </a>
<a name="ln195">// All the current matches are stored in a list.</a>
<a name="ln196">// &quot;compl_first_match&quot; points to the start of the list.</a>
<a name="ln197">// &quot;compl_curr_match&quot; points to the currently selected entry.</a>
<a name="ln198">// &quot;compl_shown_match&quot; is different from compl_curr_match during</a>
<a name="ln199">// ins_compl_get_exp().</a>
<a name="ln200">// &quot;compl_old_match&quot; points to previous &quot;compl_curr_match&quot;.</a>
<a name="ln201"> </a>
<a name="ln202">static compl_T *compl_first_match = NULL;</a>
<a name="ln203">static compl_T *compl_curr_match = NULL;</a>
<a name="ln204">static compl_T *compl_shown_match = NULL;</a>
<a name="ln205">static compl_T *compl_old_match = NULL;</a>
<a name="ln206"> </a>
<a name="ln207">/// After using a cursor key &lt;Enter&gt; selects a match in the popup menu,</a>
<a name="ln208">/// otherwise it inserts a line break.</a>
<a name="ln209">static bool compl_enter_selects = false;</a>
<a name="ln210"> </a>
<a name="ln211">/// When &quot;compl_leader&quot; is not NULL only matches that start with this string</a>
<a name="ln212">/// are used.</a>
<a name="ln213">static char *compl_leader = NULL;</a>
<a name="ln214"> </a>
<a name="ln215">static bool compl_get_longest = false;  ///&lt; put longest common string in compl_leader</a>
<a name="ln216"> </a>
<a name="ln217">static bool compl_no_insert = false;    ///&lt; false: select &amp; insert</a>
<a name="ln218">                                        ///&lt; true: noinsert</a>
<a name="ln219">static bool compl_no_select = false;    ///&lt; false: select &amp; insert</a>
<a name="ln220">                                        ///&lt; true: noselect</a>
<a name="ln221">static bool compl_longest = false;      ///&lt; false: insert full match</a>
<a name="ln222">                                        ///&lt; true: insert longest prefix</a>
<a name="ln223"> </a>
<a name="ln224">/// Selected one of the matches. When false the match was edited or using the</a>
<a name="ln225">/// longest common string.</a>
<a name="ln226">static bool compl_used_match;</a>
<a name="ln227"> </a>
<a name="ln228">/// didn't finish finding completions.</a>
<a name="ln229">static bool compl_was_interrupted = false;</a>
<a name="ln230"> </a>
<a name="ln231">// Set when character typed while looking for matches and it means we should</a>
<a name="ln232">// stop looking for matches.</a>
<a name="ln233">static bool compl_interrupted = false;</a>
<a name="ln234"> </a>
<a name="ln235">static bool compl_restarting = false;   ///&lt; don't insert match</a>
<a name="ln236"> </a>
<a name="ln237">/// When the first completion is done &quot;compl_started&quot; is set.  When it's</a>
<a name="ln238">/// false the word to be completed must be located.</a>
<a name="ln239">static bool compl_started = false;</a>
<a name="ln240"> </a>
<a name="ln241">/// Which Ctrl-X mode are we in?</a>
<a name="ln242">static int ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln243"> </a>
<a name="ln244">static int compl_matches = 0;           ///&lt; number of completion matches</a>
<a name="ln245">static char *compl_pattern = NULL;</a>
<a name="ln246">static Direction compl_direction = FORWARD;</a>
<a name="ln247">static Direction compl_shows_dir = FORWARD;</a>
<a name="ln248">static int compl_pending = 0;           ///&lt; &gt; 1 for postponed CTRL-N</a>
<a name="ln249">static pos_T compl_startpos;</a>
<a name="ln250">/// Length in bytes of the text being completed (this is deleted to be replaced</a>
<a name="ln251">/// by the match.)</a>
<a name="ln252">static int compl_length = 0;</a>
<a name="ln253">static colnr_T compl_col = 0;           ///&lt; column where the text starts</a>
<a name="ln254">                                        ///&lt; that is being completed</a>
<a name="ln255">static char *compl_orig_text = NULL;    ///&lt; text as it was before</a>
<a name="ln256">                                        ///&lt; completion started</a>
<a name="ln257">static int compl_cont_mode = 0;</a>
<a name="ln258">static expand_T compl_xp;</a>
<a name="ln259"> </a>
<a name="ln260">// List of flags for method of completion.</a>
<a name="ln261">static int compl_cont_status = 0;</a>
<a name="ln262">#define CONT_ADDING    1        ///&lt; &quot;normal&quot; or &quot;adding&quot; expansion</a>
<a name="ln263">#define CONT_INTRPT    (2 + 4)  ///&lt; a ^X interrupted the current expansion</a>
<a name="ln264">                                ///&lt; it's set only iff N_ADDS is set</a>
<a name="ln265">#define CONT_N_ADDS    4        ///&lt; next ^X&lt;&gt; will add-new or expand-current</a>
<a name="ln266">#define CONT_S_IPOS    8        ///&lt; next ^X&lt;&gt; will set initial_pos?</a>
<a name="ln267">                                ///&lt; if so, word-wise-expansion will set SOL</a>
<a name="ln268">#define CONT_SOL       16       ///&lt; pattern includes start of line, just for</a>
<a name="ln269">                                ///&lt; word-wise expansion, not set for ^X^L</a>
<a name="ln270">#define CONT_LOCAL     32       ///&lt; for ctrl_x_mode 0, ^X^P/^X^N do a local</a>
<a name="ln271">                                ///&lt; expansion, (eg use complete=.)</a>
<a name="ln272"> </a>
<a name="ln273">static bool compl_opt_refresh_always = false;</a>
<a name="ln274"> </a>
<a name="ln275">static size_t spell_bad_len = 0;   // length of located bad word</a>
<a name="ln276"> </a>
<a name="ln277">static int pum_selected_item = -1;</a>
<a name="ln278"> </a>
<a name="ln279">/// CTRL-X pressed in Insert mode.</a>
<a name="ln280">void ins_ctrl_x(void)</a>
<a name="ln281">{</a>
<a name="ln282">  if (!ctrl_x_mode_cmdline()) {</a>
<a name="ln283">    // if the next ^X&lt;&gt; won't ADD nothing, then reset compl_cont_status</a>
<a name="ln284">    if (compl_cont_status &amp; CONT_N_ADDS) {</a>
<a name="ln285">      compl_cont_status |= CONT_INTRPT;</a>
<a name="ln286">    } else {</a>
<a name="ln287">      compl_cont_status = 0;</a>
<a name="ln288">    }</a>
<a name="ln289">    // We're not sure which CTRL-X mode it will be yet</a>
<a name="ln290">    ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln291">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln292">    edit_submode_pre = NULL;</a>
<a name="ln293">    showmode();</a>
<a name="ln294">  } else {</a>
<a name="ln295">    // CTRL-X in CTRL-X CTRL-V mode behaves differently to make CTRL-X</a>
<a name="ln296">    // CTRL-V look like CTRL-N</a>
<a name="ln297">    ctrl_x_mode = CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  may_trigger_modechanged();</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">// Functions to check the current CTRL-X mode.</a>
<a name="ln304"> </a>
<a name="ln305">bool ctrl_x_mode_none(void)</a>
<a name="ln306">  FUNC_ATTR_PURE</a>
<a name="ln307">{</a>
<a name="ln308">  return ctrl_x_mode == 0;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">bool ctrl_x_mode_normal(void)</a>
<a name="ln312">  FUNC_ATTR_PURE</a>
<a name="ln313">{</a>
<a name="ln314">  return ctrl_x_mode == CTRL_X_NORMAL;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">bool ctrl_x_mode_scroll(void)</a>
<a name="ln318">  FUNC_ATTR_PURE</a>
<a name="ln319">{</a>
<a name="ln320">  return ctrl_x_mode == CTRL_X_SCROLL;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">bool ctrl_x_mode_whole_line(void)</a>
<a name="ln324">  FUNC_ATTR_PURE</a>
<a name="ln325">{</a>
<a name="ln326">  return ctrl_x_mode == CTRL_X_WHOLE_LINE;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">bool ctrl_x_mode_files(void)</a>
<a name="ln330">  FUNC_ATTR_PURE</a>
<a name="ln331">{</a>
<a name="ln332">  return ctrl_x_mode == CTRL_X_FILES;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">bool ctrl_x_mode_tags(void)</a>
<a name="ln336">  FUNC_ATTR_PURE</a>
<a name="ln337">{</a>
<a name="ln338">  return ctrl_x_mode == CTRL_X_TAGS;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">bool ctrl_x_mode_path_patterns(void)</a>
<a name="ln342">  FUNC_ATTR_PURE</a>
<a name="ln343">{</a>
<a name="ln344">  return ctrl_x_mode == CTRL_X_PATH_PATTERNS;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">bool ctrl_x_mode_path_defines(void)</a>
<a name="ln348">  FUNC_ATTR_PURE</a>
<a name="ln349">{</a>
<a name="ln350">  return ctrl_x_mode == CTRL_X_PATH_DEFINES;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">bool ctrl_x_mode_dictionary(void)</a>
<a name="ln354">  FUNC_ATTR_PURE</a>
<a name="ln355">{</a>
<a name="ln356">  return ctrl_x_mode == CTRL_X_DICTIONARY;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">bool ctrl_x_mode_thesaurus(void)</a>
<a name="ln360">  FUNC_ATTR_PURE</a>
<a name="ln361">{</a>
<a name="ln362">  return ctrl_x_mode == CTRL_X_THESAURUS;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">bool ctrl_x_mode_cmdline(void)</a>
<a name="ln366">  FUNC_ATTR_PURE</a>
<a name="ln367">{</a>
<a name="ln368">  return ctrl_x_mode == CTRL_X_CMDLINE || ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X;</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">bool ctrl_x_mode_function(void)</a>
<a name="ln372">  FUNC_ATTR_PURE</a>
<a name="ln373">{</a>
<a name="ln374">  return ctrl_x_mode == CTRL_X_FUNCTION;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">bool ctrl_x_mode_omni(void)</a>
<a name="ln378">  FUNC_ATTR_PURE</a>
<a name="ln379">{</a>
<a name="ln380">  return ctrl_x_mode == CTRL_X_OMNI;</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">bool ctrl_x_mode_spell(void)</a>
<a name="ln384">  FUNC_ATTR_PURE</a>
<a name="ln385">{</a>
<a name="ln386">  return ctrl_x_mode == CTRL_X_SPELL;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">static bool ctrl_x_mode_eval(void)</a>
<a name="ln390">  FUNC_ATTR_PURE</a>
<a name="ln391">{</a>
<a name="ln392">  return ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">bool ctrl_x_mode_line_or_eval(void)</a>
<a name="ln396">  FUNC_ATTR_PURE</a>
<a name="ln397">{</a>
<a name="ln398">  return ctrl_x_mode == CTRL_X_WHOLE_LINE || ctrl_x_mode == CTRL_X_EVAL;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">/// Whether other than default completion has been selected.</a>
<a name="ln402">bool ctrl_x_mode_not_default(void)</a>
<a name="ln403">  FUNC_ATTR_PURE</a>
<a name="ln404">{</a>
<a name="ln405">  return ctrl_x_mode != CTRL_X_NORMAL;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">/// Whether CTRL-X was typed without a following character,</a>
<a name="ln409">/// not including when in CTRL-X CTRL-V mode.</a>
<a name="ln410">bool ctrl_x_mode_not_defined_yet(void)</a>
<a name="ln411">  FUNC_ATTR_PURE</a>
<a name="ln412">{</a>
<a name="ln413">  return ctrl_x_mode == CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">/// @return  true if currently in &quot;normal&quot; or &quot;adding&quot; insert completion matches state</a>
<a name="ln417">bool compl_status_adding(void)</a>
<a name="ln418">{</a>
<a name="ln419">  return compl_cont_status &amp; CONT_ADDING;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">/// @return  true if the completion pattern includes start of line, just for</a>
<a name="ln423">///          word-wise expansion.</a>
<a name="ln424">bool compl_status_sol(void)</a>
<a name="ln425">{</a>
<a name="ln426">  return compl_cont_status &amp; CONT_SOL;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/// @return  true if ^X^P/^X^N will do a local completion (i.e. use complete=.)</a>
<a name="ln430">bool compl_status_local(void)</a>
<a name="ln431">{</a>
<a name="ln432">  return compl_cont_status &amp; CONT_LOCAL;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">/// Clear the completion status flags</a>
<a name="ln436">void compl_status_clear(void)</a>
<a name="ln437">{</a>
<a name="ln438">  compl_cont_status = 0;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/// @return  true if completion is using the forward direction matches</a>
<a name="ln442">static bool compl_dir_forward(void)</a>
<a name="ln443">{</a>
<a name="ln444">  return compl_direction == FORWARD;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">/// @return  true if currently showing forward completion matches</a>
<a name="ln448">static bool compl_shows_dir_forward(void)</a>
<a name="ln449">{</a>
<a name="ln450">  return compl_shows_dir == FORWARD;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/// @return  true if currently showing backward completion matches</a>
<a name="ln454">static bool compl_shows_dir_backward(void)</a>
<a name="ln455">{</a>
<a name="ln456">  return compl_shows_dir == BACKWARD;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">/// Check that the 'dictionary' or 'thesaurus' option can be used.</a>
<a name="ln460">///</a>
<a name="ln461">/// @param  dict_opt  check 'dictionary' when true, 'thesaurus' when false.</a>
<a name="ln462">bool check_compl_option(bool dict_opt)</a>
<a name="ln463">{</a>
<a name="ln464">  if (dict_opt</a>
<a name="ln465">      ? (*curbuf-&gt;b_p_dict == NUL &amp;&amp; *p_dict == NUL &amp;&amp; !curwin-&gt;w_p_spell)</a>
<a name="ln466">      : (*curbuf-&gt;b_p_tsr == NUL &amp;&amp; *p_tsr == NUL</a>
<a name="ln467">         &amp;&amp; *curbuf-&gt;b_p_tsrfu == NUL &amp;&amp; *p_tsrfu == NUL)) {</a>
<a name="ln468">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln469">    edit_submode = NULL;</a>
<a name="ln470">    msg_attr((dict_opt</a>
<a name="ln471">              ? _(&quot;'dictionary' option is empty&quot;)</a>
<a name="ln472">              : _(&quot;'thesaurus' option is empty&quot;)), HL_ATTR(HLF_E));</a>
<a name="ln473">    if (emsg_silent == 0 &amp;&amp; !in_assert_fails) {</a>
<a name="ln474">      vim_beep(BO_COMPL);</a>
<a name="ln475">      setcursor();</a>
<a name="ln476">      ui_flush();</a>
<a name="ln477">      os_delay(2004L, false);</a>
<a name="ln478">    }</a>
<a name="ln479">    return false;</a>
<a name="ln480">  }</a>
<a name="ln481">  return true;</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">/// Check that the character &quot;c&quot; a valid key to go to or keep us in CTRL-X mode?</a>
<a name="ln485">/// This depends on the current mode.</a>
<a name="ln486">///</a>
<a name="ln487">/// @param  c  character to check</a>
<a name="ln488">bool vim_is_ctrl_x_key(int c)</a>
<a name="ln489">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln490">{</a>
<a name="ln491">  // Always allow ^R - let its results then be checked</a>
<a name="ln492">  if (c == Ctrl_R) {</a>
<a name="ln493">    return true;</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  // Accept &lt;PageUp&gt; and &lt;PageDown&gt; if the popup menu is visible.</a>
<a name="ln497">  if (ins_compl_pum_key(c)) {</a>
<a name="ln498">    return true;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">  switch (ctrl_x_mode) {</a>
<a name="ln502">  case 0:  // Not in any CTRL-X mode</a>
<a name="ln503">    return c == Ctrl_N || c == Ctrl_P || c == Ctrl_X;</a>
<a name="ln504">  case CTRL_X_NOT_DEFINED_YET:</a>
<a name="ln505">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln506">    return c == Ctrl_X || c == Ctrl_Y || c == Ctrl_E</a>
<a name="ln507">           || c == Ctrl_L || c == Ctrl_F || c == Ctrl_RSB</a>
<a name="ln508">           || c == Ctrl_I || c == Ctrl_D || c == Ctrl_P</a>
<a name="ln509">           || c == Ctrl_N || c == Ctrl_T || c == Ctrl_V</a>
<a name="ln510">           || c == Ctrl_Q || c == Ctrl_U || c == Ctrl_O</a>
<a name="ln511">           || c == Ctrl_S || c == Ctrl_K || c == 's'</a>
<a name="ln512">           || c == Ctrl_Z;</a>
<a name="ln513">  case CTRL_X_SCROLL:</a>
<a name="ln514">    return c == Ctrl_Y || c == Ctrl_E;</a>
<a name="ln515">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln516">    return c == Ctrl_L || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln517">  case CTRL_X_FILES:</a>
<a name="ln518">    return c == Ctrl_F || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln519">  case CTRL_X_DICTIONARY:</a>
<a name="ln520">    return c == Ctrl_K || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln521">  case CTRL_X_THESAURUS:</a>
<a name="ln522">    return c == Ctrl_T || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln523">  case CTRL_X_TAGS:</a>
<a name="ln524">    return c == Ctrl_RSB || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln525">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln526">    return c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln527">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln528">    return c == Ctrl_D || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln529">  case CTRL_X_CMDLINE:</a>
<a name="ln530">    return c == Ctrl_V || c == Ctrl_Q || c == Ctrl_P || c == Ctrl_N</a>
<a name="ln531">           || c == Ctrl_X;</a>
<a name="ln532">  case CTRL_X_FUNCTION:</a>
<a name="ln533">    return c == Ctrl_U || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln534">  case CTRL_X_OMNI:</a>
<a name="ln535">    return c == Ctrl_O || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln536">  case CTRL_X_SPELL:</a>
<a name="ln537">    return c == Ctrl_S || c == Ctrl_P || c == Ctrl_N;</a>
<a name="ln538">  case CTRL_X_EVAL:</a>
<a name="ln539">    return (c == Ctrl_P || c == Ctrl_N);</a>
<a name="ln540">  }</a>
<a name="ln541">  internal_error(&quot;vim_is_ctrl_x_key()&quot;);</a>
<a name="ln542">  return false;</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">/// @return  true if &quot;match&quot; is the original text when the completion began.</a>
<a name="ln546">static bool match_at_original_text(const compl_T *const match)</a>
<a name="ln547">{</a>
<a name="ln548">  return match-&gt;cp_flags &amp; CP_ORIGINAL_TEXT;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">/// @return  true if &quot;match&quot; is the first match in the completion list.</a>
<a name="ln552">static bool is_first_match(const compl_T *const match)</a>
<a name="ln553">{</a>
<a name="ln554">  return match == compl_first_match;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">/// Check that character &quot;c&quot; is part of the item currently being</a>
<a name="ln558">/// completed.  Used to decide whether to abandon complete mode when the menu</a>
<a name="ln559">/// is visible.</a>
<a name="ln560">///</a>
<a name="ln561">/// @param  c  character to check</a>
<a name="ln562">bool ins_compl_accept_char(int c)</a>
<a name="ln563">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln564">{</a>
<a name="ln565">  if (ctrl_x_mode &amp; CTRL_X_WANT_IDENT) {</a>
<a name="ln566">    // When expanding an identifier only accept identifier chars.</a>
<a name="ln567">    return vim_isIDc(c);</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">  switch (ctrl_x_mode) {</a>
<a name="ln571">  case CTRL_X_FILES:</a>
<a name="ln572">    // When expanding file name only accept file name chars. But not</a>
<a name="ln573">    // path separators, so that &quot;proto/&lt;Tab&gt;&quot; expands files in</a>
<a name="ln574">    // &quot;proto&quot;, not &quot;proto/&quot; as a whole</a>
<a name="ln575">    return vim_isfilec(c) &amp;&amp; !vim_ispathsep(c);</a>
<a name="ln576"> </a>
<a name="ln577">  case CTRL_X_CMDLINE:</a>
<a name="ln578">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln579">  case CTRL_X_OMNI:</a>
<a name="ln580">    // Command line and Omni completion can work with just about any</a>
<a name="ln581">    // printable character, but do stop at white space.</a>
<a name="ln582">    return vim_isprintc(c) &amp;&amp; !ascii_iswhite(c);</a>
<a name="ln583"> </a>
<a name="ln584">  case CTRL_X_WHOLE_LINE:</a>
<a name="ln585">    // For while line completion a space can be part of the line.</a>
<a name="ln586">    return vim_isprintc(c);</a>
<a name="ln587">  }</a>
<a name="ln588">  return vim_iswordc(c);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/// Get the completed text by inferring the case of the originally typed text.</a>
<a name="ln592">/// If the result is in allocated memory &quot;tofree&quot; is set to it.</a>
<a name="ln593">static char *ins_compl_infercase_gettext(const char *str, int char_len, int compl_char_len,</a>
<a name="ln594">                                         int min_len, char **tofree)</a>
<a name="ln595">{</a>
<a name="ln596">  bool has_lower = false;</a>
<a name="ln597">  bool was_letter = false;</a>
<a name="ln598"> </a>
<a name="ln599">  // Allocate wide character array for the completion and fill it.</a>
<a name="ln600">  int *const wca = xmalloc((size_t)char_len * sizeof(*wca));</a>
<a name="ln601">  {</a>
<a name="ln602">    const char *p = str;</a>
<a name="ln603">    for (int i = 0; i &lt; char_len; i++) {</a>
<a name="ln604">      wca[i] = mb_ptr2char_adv(&amp;p);</a>
<a name="ln605">    }</a>
<a name="ln606">  }</a>
<a name="ln607"> </a>
<a name="ln608">  // Rule 1: Were any chars converted to lower?</a>
<a name="ln609">  {</a>
<a name="ln610">    const char *p = compl_orig_text;</a>
<a name="ln611">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln612">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln613">      if (mb_islower(c)) {</a>
<a name="ln614">        has_lower = true;</a>
<a name="ln615">        if (mb_isupper(wca[i])) {</a>
<a name="ln616">          // Rule 1 is satisfied.</a>
<a name="ln617">          for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln618">            wca[i] = mb_tolower(wca[i]);</a>
<a name="ln619">          }</a>
<a name="ln620">          break;</a>
<a name="ln621">        }</a>
<a name="ln622">      }</a>
<a name="ln623">    }</a>
<a name="ln624">  }</a>
<a name="ln625"> </a>
<a name="ln626">  // Rule 2: No lower case, 2nd consecutive letter converted to</a>
<a name="ln627">  // upper case.</a>
<a name="ln628">  if (!has_lower) {</a>
<a name="ln629">    const char *p = compl_orig_text;</a>
<a name="ln630">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln631">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln632">      if (was_letter &amp;&amp; mb_isupper(c) &amp;&amp; mb_islower(wca[i])) {</a>
<a name="ln633">        // Rule 2 is satisfied.</a>
<a name="ln634">        for (i = compl_char_len; i &lt; char_len; i++) {</a>
<a name="ln635">          wca[i] = mb_toupper(wca[i]);</a>
<a name="ln636">        }</a>
<a name="ln637">        break;</a>
<a name="ln638">      }</a>
<a name="ln639">      was_letter = mb_islower(c) || mb_isupper(c);</a>
<a name="ln640">    }</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  // Copy the original case of the part we typed.</a>
<a name="ln644">  {</a>
<a name="ln645">    const char *p = compl_orig_text;</a>
<a name="ln646">    for (int i = 0; i &lt; min_len; i++) {</a>
<a name="ln647">      const int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln648">      if (mb_islower(c)) {</a>
<a name="ln649">        wca[i] = mb_tolower(wca[i]);</a>
<a name="ln650">      } else if (mb_isupper(c)) {</a>
<a name="ln651">        wca[i] = mb_toupper(wca[i]);</a>
<a name="ln652">      }</a>
<a name="ln653">    }</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  // Generate encoding specific output from wide character array.</a>
<a name="ln657">  garray_T gap;</a>
<a name="ln658">  char *p = IObuff;</a>
<a name="ln659">  int i = 0;</a>
<a name="ln660">  ga_init(&amp;gap, 1, 500);</a>
<a name="ln661">  while (i &lt; char_len) {</a>
<a name="ln662">    if (gap.ga_data != NULL) {</a>
<a name="ln663">      ga_grow(&amp;gap, 10);</a>
<a name="ln664">      assert(gap.ga_data != NULL);  // suppress clang &quot;Dereference of NULL pointer&quot;</a>
<a name="ln665">      p = (char *)gap.ga_data + gap.ga_len;</a>
<a name="ln666">      gap.ga_len += utf_char2bytes(wca[i++], p);</a>
<a name="ln667">    } else if ((p - IObuff) + 6 &gt;= IOSIZE) {</a>
<a name="ln668">      // Multi-byte characters can occupy up to five bytes more than</a>
<a name="ln669">      // ASCII characters, and we also need one byte for NUL, so when</a>
<a name="ln670">      // getting to six bytes from the edge of IObuff switch to using a</a>
<a name="ln671">      // growarray.  Add the character in the next round.</a>
<a name="ln672">      ga_grow(&amp;gap, IOSIZE);</a>
<a name="ln673">      *p = NUL;</a>
<a name="ln674">      STRCPY(gap.ga_data, IObuff);</a>
<a name="ln675">      gap.ga_len = (int)strlen(IObuff);</a>
<a name="ln676">    } else {</a>
<a name="ln677">      p += utf_char2bytes(wca[i++], p);</a>
<a name="ln678">    }</a>
<a name="ln679">  }</a>
<a name="ln680">  xfree(wca);</a>
<a name="ln681"> </a>
<a name="ln682">  if (gap.ga_data != NULL) {</a>
<a name="ln683">    *tofree = gap.ga_data;</a>
<a name="ln684">    return gap.ga_data;</a>
<a name="ln685">  }</a>
<a name="ln686"> </a>
<a name="ln687">  *p = NUL;</a>
<a name="ln688">  return IObuff;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">/// This is like ins_compl_add(), but if 'ic' and 'inf' are set, then the</a>
<a name="ln692">/// case of the originally typed text is used, and the case of the completed</a>
<a name="ln693">/// text is inferred, ie this tries to work out what case you probably wanted</a>
<a name="ln694">/// the rest of the word to be in -- webb</a>
<a name="ln695">///</a>
<a name="ln696">/// @param[in]  cont_s_ipos  next ^X&lt;&gt; will set initial_pos</a>
<a name="ln697">int ins_compl_add_infercase(char *str_arg, int len, bool icase, char *fname, Direction dir,</a>
<a name="ln698">                            bool cont_s_ipos)</a>
<a name="ln699">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln700">{</a>
<a name="ln701">  char *str = str_arg;</a>
<a name="ln702">  int char_len;  // count multi-byte characters</a>
<a name="ln703">  int compl_char_len;</a>
<a name="ln704">  int flags = 0;</a>
<a name="ln705">  char *tofree = NULL;</a>
<a name="ln706"> </a>
<a name="ln707">  if (p_ic &amp;&amp; curbuf-&gt;b_p_inf &amp;&amp; len &gt; 0) {</a>
<a name="ln708">    // Infer case of completed part.</a>
<a name="ln709"> </a>
<a name="ln710">    // Find actual length of completion.</a>
<a name="ln711">    {</a>
<a name="ln712">      const char *p = str;</a>
<a name="ln713">      char_len = 0;</a>
<a name="ln714">      while (*p != NUL) {</a>
<a name="ln715">        MB_PTR_ADV(p);</a>
<a name="ln716">        char_len++;</a>
<a name="ln717">      }</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">    // Find actual length of original text.</a>
<a name="ln721">    {</a>
<a name="ln722">      const char *p = compl_orig_text;</a>
<a name="ln723">      compl_char_len = 0;</a>
<a name="ln724">      while (*p != NUL) {</a>
<a name="ln725">        MB_PTR_ADV(p);</a>
<a name="ln726">        compl_char_len++;</a>
<a name="ln727">      }</a>
<a name="ln728">    }</a>
<a name="ln729"> </a>
<a name="ln730">    // &quot;char_len&quot; may be smaller than &quot;compl_char_len&quot; when using</a>
<a name="ln731">    // thesaurus, only use the minimum when comparing.</a>
<a name="ln732">    int min_len = char_len &lt; compl_char_len ? char_len : compl_char_len;</a>
<a name="ln733"> </a>
<a name="ln734">    str = ins_compl_infercase_gettext(str, char_len, compl_char_len, min_len, &amp;tofree);</a>
<a name="ln735">  }</a>
<a name="ln736">  if (cont_s_ipos) {</a>
<a name="ln737">    flags |= CP_CONT_S_IPOS;</a>
<a name="ln738">  }</a>
<a name="ln739">  if (icase) {</a>
<a name="ln740">    flags |= CP_ICASE;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  int res = ins_compl_add(str, len, fname, NULL, false, NULL, dir, flags, false);</a>
<a name="ln744">  xfree(tofree);</a>
<a name="ln745">  return res;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">/// Add a match to the list of matches</a>
<a name="ln749">///</a>
<a name="ln750">/// @param[in]  str     text of the match to add</a>
<a name="ln751">/// @param[in]  len     length of &quot;str&quot;. If -1, then the length of &quot;str&quot; is computed.</a>
<a name="ln752">/// @param[in]  fname   file name to associate with this match. May be NULL.</a>
<a name="ln753">/// @param[in]  cptext  list of strings to use with this match (for abbr, menu, info</a>
<a name="ln754">///                     and kind). May be NULL.</a>
<a name="ln755">///                     If not NULL, must have exactly #CPT_COUNT items.</a>
<a name="ln756">/// @param[in]  cptext_allocated  If true, will not copy cptext strings.</a>
<a name="ln757">///</a>
<a name="ln758">///                               @note Will free strings in case of error.</a>
<a name="ln759">///                                     cptext itself will not be freed.</a>
<a name="ln760">/// @param[in]  user_data  user supplied data (any vim type) for this match</a>
<a name="ln761">/// @param[in]  cdir       match direction. If 0, use &quot;compl_direction&quot;.</a>
<a name="ln762">/// @param[in]  flags_arg  match flags (cp_flags)</a>
<a name="ln763">/// @param[in]  adup       accept this match even if it is already present.</a>
<a name="ln764">///</a>
<a name="ln765">/// If &quot;cdir&quot; is FORWARD, then the match is added after the current match.</a>
<a name="ln766">/// Otherwise, it is added before the current match.</a>
<a name="ln767">///</a>
<a name="ln768">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln769">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln770">///         returned in case of error.</a>
<a name="ln771">static int ins_compl_add(char *const str, int len, char *const fname, char *const *const cptext,</a>
<a name="ln772">                         const bool cptext_allocated, typval_T *user_data, const Direction cdir,</a>
<a name="ln773">                         int flags_arg, const bool adup)</a>
<a name="ln774">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln775">{</a>
<a name="ln776">  compl_T *match;</a>
<a name="ln777">  const Direction dir = (cdir == kDirectionNotSet ? compl_direction : cdir);</a>
<a name="ln778">  int flags = flags_arg;</a>
<a name="ln779"> </a>
<a name="ln780">  if (flags &amp; CP_FAST) {</a>
<a name="ln781">    fast_breakcheck();</a>
<a name="ln782">  } else {</a>
<a name="ln783">    os_breakcheck();</a>
<a name="ln784">  }</a>
<a name="ln785">#define FREE_CPTEXT(cptext, cptext_allocated) \</a>
<a name="ln786">  do { \</a>
<a name="ln787">    if ((cptext) != NULL &amp;&amp; (cptext_allocated)) { \</a>
<a name="ln788">      for (size_t i = 0; i &lt; CPT_COUNT; i++) { \</a>
<a name="ln789">        xfree((cptext)[i]); \</a>
<a name="ln790">      } \</a>
<a name="ln791">    } \</a>
<a name="ln792">  } while (0)</a>
<a name="ln793">  if (got_int) {</a>
<a name="ln794">    FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln795">    return FAIL;</a>
<a name="ln796">  }</a>
<a name="ln797">  if (len &lt; 0) {</a>
<a name="ln798">    len = (int)strlen(str);</a>
<a name="ln799">  }</a>
<a name="ln800"> </a>
<a name="ln801">  // If the same match is already present, don't add it.</a>
<a name="ln802">  if (compl_first_match != NULL &amp;&amp; !adup) {</a>
<a name="ln803">    match = compl_first_match;</a>
<a name="ln804">    do {</a>
<a name="ln805">      if (!match_at_original_text(match)</a>
<a name="ln806">          &amp;&amp; strncmp(match-&gt;cp_str, str, (size_t)len) == 0</a>
<a name="ln807">          &amp;&amp; ((int)strlen(match-&gt;cp_str) &lt;= len || match-&gt;cp_str[len] == NUL)) {</a>
<a name="ln808">        FREE_CPTEXT(cptext, cptext_allocated);</a>
<a name="ln809">        return NOTDONE;</a>
<a name="ln810">      }</a>
<a name="ln811">      match = match-&gt;cp_next;</a>
<a name="ln812">    } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln813">  }</a>
<a name="ln814"> </a>
<a name="ln815">  // Remove any popup menu before changing the list of matches.</a>
<a name="ln816">  ins_compl_del_pum();</a>
<a name="ln817"> </a>
<a name="ln818">  // Allocate a new match structure.</a>
<a name="ln819">  // Copy the values to the new match structure.</a>
<a name="ln820">  match = xcalloc(1, sizeof(compl_T));</a>
<a name="ln821">  match-&gt;cp_number = -1;</a>
<a name="ln822">  if (flags &amp; CP_ORIGINAL_TEXT) {</a>
<a name="ln823">    match-&gt;cp_number = 0;</a>
<a name="ln824">  }</a>
<a name="ln825">  match-&gt;cp_str = xstrnsave(str, (size_t)len);</a>
<a name="ln826"> </a>
<a name="ln827">  // match-fname is:</a>
<a name="ln828">  // - compl_curr_match-&gt;cp_fname if it is a string equal to fname.</a>
<a name="ln829">  // - a copy of fname, CP_FREE_FNAME is set to free later THE allocated mem.</a>
<a name="ln830">  // - NULL otherwise.  --Acevedo</a>
<a name="ln831">  if (fname != NULL</a>
<a name="ln832">      &amp;&amp; compl_curr_match != NULL</a>
<a name="ln833">      &amp;&amp; compl_curr_match-&gt;cp_fname != NULL</a>
<a name="ln834">      &amp;&amp; strcmp(fname, compl_curr_match-&gt;cp_fname) == 0) {</a>
<a name="ln835">    match-&gt;cp_fname = compl_curr_match-&gt;cp_fname;</a>
<a name="ln836">  } else if (fname != NULL) {</a>
<a name="ln837">    match-&gt;cp_fname = xstrdup(fname);</a>
<a name="ln838">    flags |= CP_FREE_FNAME;</a>
<a name="ln839">  } else {</a>
<a name="ln840">    match-&gt;cp_fname = NULL;</a>
<a name="ln841">  }</a>
<a name="ln842">  match-&gt;cp_flags = flags;</a>
<a name="ln843"> </a>
<a name="ln844">  if (cptext != NULL) {</a>
<a name="ln845">    int i;</a>
<a name="ln846"> </a>
<a name="ln847">    for (i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln848">      if (cptext[i] == NULL) {</a>
<a name="ln849">        continue;</a>
<a name="ln850">      }</a>
<a name="ln851">      if (*cptext[i] != NUL) {</a>
<a name="ln852">        match-&gt;cp_text[i] = (cptext_allocated ? cptext[i] : xstrdup(cptext[i]));</a>
<a name="ln853">      } else if (cptext_allocated) {</a>
<a name="ln854">        xfree(cptext[i]);</a>
<a name="ln855">      }</a>
<a name="ln856">    }</a>
<a name="ln857">  }</a>
<a name="ln858"> </a>
<a name="ln859">  if (user_data != NULL) {</a>
<a name="ln860">    match-&gt;cp_user_data = *user_data;</a>
<a name="ln861">  }</a>
<a name="ln862"> </a>
<a name="ln863">  // Link the new match structure after (FORWARD) or before (BACKWARD) the</a>
<a name="ln864">  // current match in the list of matches .</a>
<a name="ln865">  if (compl_first_match == NULL) {</a>
<a name="ln866">    match-&gt;cp_next = match-&gt;cp_prev = NULL;</a>
<a name="ln867">  } else if (dir == FORWARD) {</a>
<a name="ln868">    match-&gt;cp_next = compl_curr_match-&gt;cp_next;</a>
<a name="ln869">    match-&gt;cp_prev = compl_curr_match;</a>
<a name="ln870">  } else {    // BACKWARD</a>
<a name="ln871">    match-&gt;cp_next = compl_curr_match;</a>
<a name="ln872">    match-&gt;cp_prev = compl_curr_match-&gt;cp_prev;</a>
<a name="ln873">  }</a>
<a name="ln874">  if (match-&gt;cp_next) {</a>
<a name="ln875">    match-&gt;cp_next-&gt;cp_prev = match;</a>
<a name="ln876">  }</a>
<a name="ln877">  if (match-&gt;cp_prev) {</a>
<a name="ln878">    match-&gt;cp_prev-&gt;cp_next = match;</a>
<a name="ln879">  } else {        // if there's nothing before, it is the first match</a>
<a name="ln880">    compl_first_match = match;</a>
<a name="ln881">  }</a>
<a name="ln882">  compl_curr_match = match;</a>
<a name="ln883"> </a>
<a name="ln884">  // Find the longest common string if still doing that.</a>
<a name="ln885">  if (compl_get_longest &amp;&amp; (flags &amp; CP_ORIGINAL_TEXT) == 0) {</a>
<a name="ln886">    ins_compl_longest_match(match);</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  return OK;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">/// Check that &quot;str[len]&quot; matches with &quot;match-&gt;cp_str&quot;, considering</a>
<a name="ln893">/// &quot;match-&gt;cp_flags&quot;.</a>
<a name="ln894">///</a>
<a name="ln895">/// @param  match  completion match</a>
<a name="ln896">/// @param  str    character string to check</a>
<a name="ln897">/// @param  len    length of &quot;str&quot;</a>
<a name="ln898">static bool ins_compl_equal(compl_T *match, char *str, size_t len)</a>
<a name="ln899">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln900">{</a>
<a name="ln901">  if (match-&gt;cp_flags &amp; CP_EQUAL) {</a>
<a name="ln902">    return true;</a>
<a name="ln903">  }</a>
<a name="ln904">  if (match-&gt;cp_flags &amp; CP_ICASE) {</a>
<a name="ln905">    return STRNICMP(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln906">  }</a>
<a name="ln907">  return strncmp(match-&gt;cp_str, str, len) == 0;</a>
<a name="ln908">}</a>
<a name="ln909"> </a>
<a name="ln910">/// Reduce the longest common string for match &quot;match&quot;.</a>
<a name="ln911">static void ins_compl_longest_match(compl_T *match)</a>
<a name="ln912">{</a>
<a name="ln913">  char *p, *s;</a>
<a name="ln914">  int c1, c2;</a>
<a name="ln915">  int had_match;</a>
<a name="ln916"> </a>
<a name="ln917">  if (compl_leader == NULL) {</a>
<a name="ln918">    // First match, use it as a whole.</a>
<a name="ln919">    compl_leader = xstrdup(match-&gt;cp_str);</a>
<a name="ln920"> </a>
<a name="ln921">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln922">    ins_compl_delete();</a>
<a name="ln923">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln924">    ins_redraw(false);</a>
<a name="ln925"> </a>
<a name="ln926">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln927">    // again after redrawing.</a>
<a name="ln928">    if (!had_match) {</a>
<a name="ln929">      ins_compl_delete();</a>
<a name="ln930">    }</a>
<a name="ln931">    compl_used_match = false;</a>
<a name="ln932"> </a>
<a name="ln933">    return;</a>
<a name="ln934">  }</a>
<a name="ln935"> </a>
<a name="ln936">  // Reduce the text if this match differs from compl_leader.</a>
<a name="ln937">  p = compl_leader;</a>
<a name="ln938">  s = match-&gt;cp_str;</a>
<a name="ln939">  while (*p != NUL) {</a>
<a name="ln940">    c1 = utf_ptr2char(p);</a>
<a name="ln941">    c2 = utf_ptr2char(s);</a>
<a name="ln942"> </a>
<a name="ln943">    if ((match-&gt;cp_flags &amp; CP_ICASE)</a>
<a name="ln944">        ? (mb_tolower(c1) != mb_tolower(c2))</a>
<a name="ln945">        : (c1 != c2)) {</a>
<a name="ln946">      break;</a>
<a name="ln947">    }</a>
<a name="ln948">    MB_PTR_ADV(p);</a>
<a name="ln949">    MB_PTR_ADV(s);</a>
<a name="ln950">  }</a>
<a name="ln951"> </a>
<a name="ln952">  if (*p != NUL) {</a>
<a name="ln953">    // Leader was shortened, need to change the inserted text.</a>
<a name="ln954">    *p = NUL;</a>
<a name="ln955">    had_match = (curwin-&gt;w_cursor.col &gt; compl_col);</a>
<a name="ln956">    ins_compl_delete();</a>
<a name="ln957">    ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln958">    ins_redraw(false);</a>
<a name="ln959"> </a>
<a name="ln960">    // When the match isn't there (to avoid matching itself) remove it</a>
<a name="ln961">    // again after redrawing.</a>
<a name="ln962">    if (!had_match) {</a>
<a name="ln963">      ins_compl_delete();</a>
<a name="ln964">    }</a>
<a name="ln965">  }</a>
<a name="ln966"> </a>
<a name="ln967">  compl_used_match = false;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">/// Add an array of matches to the list of matches.</a>
<a name="ln971">/// Frees matches[].</a>
<a name="ln972">static void ins_compl_add_matches(int num_matches, char **matches, int icase)</a>
<a name="ln973">{</a>
<a name="ln974">  int add_r = OK;</a>
<a name="ln975">  Direction dir = compl_direction;</a>
<a name="ln976"> </a>
<a name="ln977">  for (int i = 0; i &lt; num_matches &amp;&amp; add_r != FAIL; i++) {</a>
<a name="ln978">    if ((add_r = ins_compl_add(matches[i], -1, NULL, NULL, false, NULL, dir,</a>
<a name="ln979">                               CP_FAST | (icase ? CP_ICASE : 0),</a>
<a name="ln980">                               false)) == OK) {</a>
<a name="ln981">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln982">      dir = FORWARD;</a>
<a name="ln983">    }</a>
<a name="ln984">  }</a>
<a name="ln985">  FreeWild(num_matches, matches);</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/// Make the completion list cyclic.</a>
<a name="ln989">/// Return the number of matches (excluding the original).</a>
<a name="ln990">static int ins_compl_make_cyclic(void)</a>
<a name="ln991">{</a>
<a name="ln992">  if (compl_first_match == NULL) {</a>
<a name="ln993">    return 0;</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  // Find the end of the list.</a>
<a name="ln997">  compl_T *match = compl_first_match;</a>
<a name="ln998">  int count = 0;</a>
<a name="ln999">  // there's always an entry for the compl_orig_text, it doesn't count.</a>
<a name="ln1000">  while (match-&gt;cp_next != NULL &amp;&amp; !is_first_match(match-&gt;cp_next)) {</a>
<a name="ln1001">    match = match-&gt;cp_next;</a>
<a name="ln1002">    count++;</a>
<a name="ln1003">  }</a>
<a name="ln1004">  match-&gt;cp_next = compl_first_match;</a>
<a name="ln1005">  compl_first_match-&gt;cp_prev = match;</a>
<a name="ln1006"> </a>
<a name="ln1007">  return count;</a>
<a name="ln1008">}</a>
<a name="ln1009"> </a>
<a name="ln1010">/// Return whether there currently is a shown match.</a>
<a name="ln1011">bool ins_compl_has_shown_match(void)</a>
<a name="ln1012">{</a>
<a name="ln1013">  return compl_shown_match == NULL || compl_shown_match != compl_shown_match-&gt;cp_next;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">/// Return whether the shown match is long enough.</a>
<a name="ln1017">bool ins_compl_long_shown_match(void)</a>
<a name="ln1018">{</a>
<a name="ln1019">  return compl_shown_match != NULL &amp;&amp; compl_shown_match-&gt;cp_str != NULL</a>
<a name="ln1020">         &amp;&amp; (colnr_T)strlen(compl_shown_match-&gt;cp_str) &gt; curwin-&gt;w_cursor.col - compl_col;</a>
<a name="ln1021">}</a>
<a name="ln1022"> </a>
<a name="ln1023">/// Set variables that store noselect and noinsert behavior from the</a>
<a name="ln1024">/// 'completeopt' value.</a>
<a name="ln1025">void completeopt_was_set(void)</a>
<a name="ln1026">{</a>
<a name="ln1027">  compl_no_insert = false;</a>
<a name="ln1028">  compl_no_select = false;</a>
<a name="ln1029">  compl_longest = false;</a>
<a name="ln1030">  if (strstr(p_cot, &quot;noselect&quot;) != NULL) {</a>
<a name="ln1031">    compl_no_select = true;</a>
<a name="ln1032">  }</a>
<a name="ln1033">  if (strstr(p_cot, &quot;noinsert&quot;) != NULL) {</a>
<a name="ln1034">    compl_no_insert = true;</a>
<a name="ln1035">  }</a>
<a name="ln1036">  if (strstr(p_cot, &quot;longest&quot;) != NULL) {</a>
<a name="ln1037">    compl_longest = true;</a>
<a name="ln1038">  }</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">/// &quot;compl_match_array&quot; points the currently displayed list of entries in the</a>
<a name="ln1042">/// popup menu.  It is NULL when there is no popup menu.</a>
<a name="ln1043">static pumitem_T *compl_match_array = NULL;</a>
<a name="ln1044">static int compl_match_arraysize;</a>
<a name="ln1045"> </a>
<a name="ln1046">/// Remove any popup menu.</a>
<a name="ln1047">static void ins_compl_del_pum(void)</a>
<a name="ln1048">{</a>
<a name="ln1049">  if (compl_match_array == NULL) {</a>
<a name="ln1050">    return;</a>
<a name="ln1051">  }</a>
<a name="ln1052"> </a>
<a name="ln1053">  pum_undisplay(false);</a>
<a name="ln1054">  XFREE_CLEAR(compl_match_array);</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">/// Check if the popup menu should be displayed.</a>
<a name="ln1058">bool pum_wanted(void)</a>
<a name="ln1059">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1060">{</a>
<a name="ln1061">  // &quot;completeopt&quot; must contain &quot;menu&quot; or &quot;menuone&quot;</a>
<a name="ln1062">  return vim_strchr(p_cot, 'm') != NULL;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">/// Check that there are two or more matches to be shown in the popup menu.</a>
<a name="ln1066">/// One if &quot;completopt&quot; contains &quot;menuone&quot;.</a>
<a name="ln1067">static bool pum_enough_matches(void)</a>
<a name="ln1068">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1069">{</a>
<a name="ln1070">  // Don't display the popup menu if there are no matches or there is only</a>
<a name="ln1071">  // one (ignoring the original text).</a>
<a name="ln1072">  compl_T *comp = compl_first_match;</a>
<a name="ln1073">  int i = 0;</a>
<a name="ln1074">  do {</a>
<a name="ln1075">    if (comp == NULL || (!match_at_original_text(comp) &amp;&amp; ++i == 2)) {</a>
<a name="ln1076">      break;</a>
<a name="ln1077">    }</a>
<a name="ln1078">    comp = comp-&gt;cp_next;</a>
<a name="ln1079">  } while (!is_first_match(comp));</a>
<a name="ln1080"> </a>
<a name="ln1081">  if (strstr(p_cot, &quot;menuone&quot;) != NULL) {</a>
<a name="ln1082">    return i &gt;= 1;</a>
<a name="ln1083">  }</a>
<a name="ln1084">  return i &gt;= 2;</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">/// Convert to complete item dict</a>
<a name="ln1088">static dict_T *ins_compl_dict_alloc(compl_T *match)</a>
<a name="ln1089">{</a>
<a name="ln1090">  // { word, abbr, menu, kind, info }</a>
<a name="ln1091">  dict_T *dict = tv_dict_alloc_lock(VAR_FIXED);</a>
<a name="ln1092">  tv_dict_add_str(dict, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln1093">  tv_dict_add_str(dict, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln1094">  tv_dict_add_str(dict, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln1095">  tv_dict_add_str(dict, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln1096">  tv_dict_add_str(dict, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln1097">  if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln1098">    tv_dict_add_str(dict, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln1099">  } else {</a>
<a name="ln1100">    tv_dict_add_tv(dict, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln1101">  }</a>
<a name="ln1102">  return dict;</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">/// Trigger the CompleteChanged autocmd event. Invoked each time the Insert mode</a>
<a name="ln1106">/// completion menu is changed.</a>
<a name="ln1107">static void trigger_complete_changed_event(int cur)</a>
<a name="ln1108">{</a>
<a name="ln1109">  static bool recursive = false;</a>
<a name="ln1110">  save_v_event_T save_v_event;</a>
<a name="ln1111"> </a>
<a name="ln1112">  if (recursive) {</a>
<a name="ln1113">    return;</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  dict_T *v_event = get_v_event(&amp;save_v_event);</a>
<a name="ln1117">  if (cur &lt; 0) {</a>
<a name="ln1118">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), tv_dict_alloc());</a>
<a name="ln1119">  } else {</a>
<a name="ln1120">    dict_T *item = ins_compl_dict_alloc(compl_curr_match);</a>
<a name="ln1121">    tv_dict_add_dict(v_event, S_LEN(&quot;completed_item&quot;), item);</a>
<a name="ln1122">  }</a>
<a name="ln1123">  pum_set_event_info(v_event);</a>
<a name="ln1124">  tv_dict_set_keys_readonly(v_event);</a>
<a name="ln1125"> </a>
<a name="ln1126">  recursive = true;</a>
<a name="ln1127">  textlock++;</a>
<a name="ln1128">  apply_autocmds(EVENT_COMPLETECHANGED, NULL, NULL, false, curbuf);</a>
<a name="ln1129">  textlock--;</a>
<a name="ln1130">  recursive = false;</a>
<a name="ln1131"> </a>
<a name="ln1132">  restore_v_event(v_event, &amp;save_v_event);</a>
<a name="ln1133">}</a>
<a name="ln1134"> </a>
<a name="ln1135">/// Build a popup menu to show the completion matches.</a>
<a name="ln1136">///</a>
<a name="ln1137">/// @return  the popup menu entry that should be selected,</a>
<a name="ln1138">///          -1 if nothing should be selected.</a>
<a name="ln1139">static int ins_compl_build_pum(void)</a>
<a name="ln1140">{</a>
<a name="ln1141">  // Need to build the popup menu list.</a>
<a name="ln1142">  compl_match_arraysize = 0;</a>
<a name="ln1143">  compl_T *comp = compl_first_match;</a>
<a name="ln1144"> </a>
<a name="ln1145">  // If it's user complete function and refresh_always,</a>
<a name="ln1146">  // do not use &quot;compl_leader&quot; as prefix filter.</a>
<a name="ln1147">  if (ins_compl_need_restart()) {</a>
<a name="ln1148">    XFREE_CLEAR(compl_leader);</a>
<a name="ln1149">  }</a>
<a name="ln1150"> </a>
<a name="ln1151">  const int lead_len = compl_leader != NULL ? (int)strlen(compl_leader) : 0;</a>
<a name="ln1152"> </a>
<a name="ln1153">  do {</a>
<a name="ln1154">    if (!match_at_original_text(comp)</a>
<a name="ln1155">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1156">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1157">      compl_match_arraysize++;</a>
<a name="ln1158">    }</a>
<a name="ln1159">    comp = comp-&gt;cp_next;</a>
<a name="ln1160">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1161"> </a>
<a name="ln1162">  if (compl_match_arraysize == 0) {</a>
<a name="ln1163">    return -1;</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">  assert(compl_match_arraysize &gt;= 0);</a>
<a name="ln1167">  compl_match_array = xcalloc((size_t)compl_match_arraysize, sizeof(pumitem_T));</a>
<a name="ln1168"> </a>
<a name="ln1169">  // If the current match is the original text don't find the first</a>
<a name="ln1170">  // match after it, don't highlight anything.</a>
<a name="ln1171">  bool shown_match_ok = match_at_original_text(compl_shown_match);</a>
<a name="ln1172"> </a>
<a name="ln1173">  compl_T *shown_compl = NULL;</a>
<a name="ln1174">  bool did_find_shown_match = false;</a>
<a name="ln1175">  int cur = -1;</a>
<a name="ln1176">  int i = 0;</a>
<a name="ln1177">  comp = compl_first_match;</a>
<a name="ln1178">  do {</a>
<a name="ln1179">    if (!match_at_original_text(comp)</a>
<a name="ln1180">        &amp;&amp; (compl_leader == NULL</a>
<a name="ln1181">            || ins_compl_equal(comp, compl_leader, (size_t)lead_len))) {</a>
<a name="ln1182">      if (!shown_match_ok) {</a>
<a name="ln1183">        if (comp == compl_shown_match || did_find_shown_match) {</a>
<a name="ln1184">          // This item is the shown match or this is the</a>
<a name="ln1185">          // first displayed item after the shown match.</a>
<a name="ln1186">          compl_shown_match = comp;</a>
<a name="ln1187">          did_find_shown_match = true;</a>
<a name="ln1188">          shown_match_ok = true;</a>
<a name="ln1189">        } else {</a>
<a name="ln1190">          // Remember this displayed match for when the</a>
<a name="ln1191">          // shown match is just below it.</a>
<a name="ln1192">          shown_compl = comp;</a>
<a name="ln1193">        }</a>
<a name="ln1194">        cur = i;</a>
<a name="ln1195">      }</a>
<a name="ln1196"> </a>
<a name="ln1197">      if (comp-&gt;cp_text[CPT_ABBR] != NULL) {</a>
<a name="ln1198">        compl_match_array[i].pum_text = comp-&gt;cp_text[CPT_ABBR];</a>
<a name="ln1199">      } else {</a>
<a name="ln1200">        compl_match_array[i].pum_text = comp-&gt;cp_str;</a>
<a name="ln1201">      }</a>
<a name="ln1202">      compl_match_array[i].pum_kind = comp-&gt;cp_text[CPT_KIND];</a>
<a name="ln1203">      compl_match_array[i].pum_info = comp-&gt;cp_text[CPT_INFO];</a>
<a name="ln1204">      if (comp-&gt;cp_text[CPT_MENU] != NULL) {</a>
<a name="ln1205">        compl_match_array[i++].pum_extra = comp-&gt;cp_text[CPT_MENU];</a>
<a name="ln1206">      } else {</a>
<a name="ln1207">        compl_match_array[i++].pum_extra = comp-&gt;cp_fname;</a>
<a name="ln1208">      }</a>
<a name="ln1209">    }</a>
<a name="ln1210"> </a>
<a name="ln1211">    if (comp == compl_shown_match) {</a>
<a name="ln1212">      did_find_shown_match = true;</a>
<a name="ln1213"> </a>
<a name="ln1214">      // When the original text is the shown match don't set</a>
<a name="ln1215">      // compl_shown_match.</a>
<a name="ln1216">      if (match_at_original_text(comp)) {</a>
<a name="ln1217">        shown_match_ok = true;</a>
<a name="ln1218">      }</a>
<a name="ln1219"> </a>
<a name="ln1220">      if (!shown_match_ok &amp;&amp; shown_compl != NULL) {</a>
<a name="ln1221">        // The shown match isn't displayed, set it to the</a>
<a name="ln1222">        // previously displayed match.</a>
<a name="ln1223">        compl_shown_match = shown_compl;</a>
<a name="ln1224">        shown_match_ok = true;</a>
<a name="ln1225">      }</a>
<a name="ln1226">    }</a>
<a name="ln1227">    comp = comp-&gt;cp_next;</a>
<a name="ln1228">  } while (comp != NULL &amp;&amp; !is_first_match(comp));</a>
<a name="ln1229"> </a>
<a name="ln1230">  if (!shown_match_ok) {  // no displayed match at all</a>
<a name="ln1231">    cur = -1;</a>
<a name="ln1232">  }</a>
<a name="ln1233"> </a>
<a name="ln1234">  return cur;</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">/// Show the popup menu for the list of matches.</a>
<a name="ln1238">/// Also adjusts &quot;compl_shown_match&quot; to an entry that is actually displayed.</a>
<a name="ln1239">void ins_compl_show_pum(void)</a>
<a name="ln1240">{</a>
<a name="ln1241">  if (!pum_wanted() || !pum_enough_matches()) {</a>
<a name="ln1242">    return;</a>
<a name="ln1243">  }</a>
<a name="ln1244"> </a>
<a name="ln1245">  // Dirty hard-coded hack: remove any matchparen highlighting.</a>
<a name="ln1246">  do_cmdline_cmd(&quot;if exists('g:loaded_matchparen')|3match none|endif&quot;);</a>
<a name="ln1247"> </a>
<a name="ln1248">  // Update the screen before drawing the popup menu over it.</a>
<a name="ln1249">  update_screen();</a>
<a name="ln1250"> </a>
<a name="ln1251">  int cur = -1;</a>
<a name="ln1252">  bool array_changed = false;</a>
<a name="ln1253"> </a>
<a name="ln1254">  if (compl_match_array == NULL) {</a>
<a name="ln1255">    array_changed = true;</a>
<a name="ln1256">    // Need to build the popup menu list.</a>
<a name="ln1257">    cur = ins_compl_build_pum();</a>
<a name="ln1258">  } else {</a>
<a name="ln1259">    // popup menu already exists, only need to find the current item.</a>
<a name="ln1260">    for (int i = 0; i &lt; compl_match_arraysize; i++) {</a>
<a name="ln1261">      if (compl_match_array[i].pum_text == compl_shown_match-&gt;cp_str</a>
<a name="ln1262">          || compl_match_array[i].pum_text == compl_shown_match-&gt;cp_text[CPT_ABBR]) {</a>
<a name="ln1263">        cur = i;</a>
<a name="ln1264">        break;</a>
<a name="ln1265">      }</a>
<a name="ln1266">    }</a>
<a name="ln1267">  }</a>
<a name="ln1268"> </a>
<a name="ln1269">  if (compl_match_array == NULL) {</a>
<a name="ln1270">    return;</a>
<a name="ln1271">  }</a>
<a name="ln1272"> </a>
<a name="ln1273">  // In Replace mode when a $ is displayed at the end of the line only</a>
<a name="ln1274">  // part of the screen would be updated.  We do need to redraw here.</a>
<a name="ln1275">  dollar_vcol = -1;</a>
<a name="ln1276"> </a>
<a name="ln1277">  // Compute the screen column of the start of the completed text.</a>
<a name="ln1278">  // Use the cursor to get all wrapping and other settings right.</a>
<a name="ln1279">  const colnr_T col = curwin-&gt;w_cursor.col;</a>
<a name="ln1280">  curwin-&gt;w_cursor.col = compl_col;</a>
<a name="ln1281">  pum_selected_item = cur;</a>
<a name="ln1282">  pum_display(compl_match_array, compl_match_arraysize, cur, array_changed, 0);</a>
<a name="ln1283">  curwin-&gt;w_cursor.col = col;</a>
<a name="ln1284"> </a>
<a name="ln1285">  if (has_event(EVENT_COMPLETECHANGED)) {</a>
<a name="ln1286">    trigger_complete_changed_event(cur);</a>
<a name="ln1287">  }</a>
<a name="ln1288">}</a>
<a name="ln1289"> </a>
<a name="ln1290">#define DICT_FIRST      (1)     ///&lt; use just first element in &quot;dict&quot;</a>
<a name="ln1291">#define DICT_EXACT      (2)     ///&lt; &quot;dict&quot; is the exact name of a file</a>
<a name="ln1292"> </a>
<a name="ln1293">/// Add any identifiers that match the given pattern &quot;pat&quot; in the list of</a>
<a name="ln1294">/// dictionary files &quot;dict_start&quot; to the list of completions.</a>
<a name="ln1295">///</a>
<a name="ln1296">/// @param flags      DICT_FIRST and/or DICT_EXACT</a>
<a name="ln1297">/// @param thesaurus  Thesaurus completion</a>
<a name="ln1298">static void ins_compl_dictionaries(char *dict_start, char *pat, int flags, int thesaurus)</a>
<a name="ln1299">{</a>
<a name="ln1300">  char *dict = dict_start;</a>
<a name="ln1301">  char *ptr;</a>
<a name="ln1302">  char *buf;</a>
<a name="ln1303">  regmatch_T regmatch;</a>
<a name="ln1304">  char **files;</a>
<a name="ln1305">  int count;</a>
<a name="ln1306">  int save_p_scs;</a>
<a name="ln1307">  Direction dir = compl_direction;</a>
<a name="ln1308"> </a>
<a name="ln1309">  if (*dict == NUL) {</a>
<a name="ln1310">    // When 'dictionary' is empty and spell checking is enabled use</a>
<a name="ln1311">    // &quot;spell&quot;.</a>
<a name="ln1312">    if (!thesaurus &amp;&amp; curwin-&gt;w_p_spell) {</a>
<a name="ln1313">      dict = &quot;spell&quot;;</a>
<a name="ln1314">    } else {</a>
<a name="ln1315">      return;</a>
<a name="ln1316">    }</a>
<a name="ln1317">  }</a>
<a name="ln1318"> </a>
<a name="ln1319">  buf = xmalloc(LSIZE);</a>
<a name="ln1320">  regmatch.regprog = NULL;      // so that we can goto theend</a>
<a name="ln1321"> </a>
<a name="ln1322">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln1323">  save_p_scs = p_scs;</a>
<a name="ln1324">  if (curbuf-&gt;b_p_inf) {</a>
<a name="ln1325">    p_scs = false;</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  // When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern</a>
<a name="ln1329">  // to only match at the start of a line.  Otherwise just match the</a>
<a name="ln1330">  // pattern. Also need to double backslashes.</a>
<a name="ln1331">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1332">    char *pat_esc = vim_strsave_escaped(pat, &quot;\\&quot;);</a>
<a name="ln1333"> </a>
<a name="ln1334">    size_t len = strlen(pat_esc) + 10;</a>
<a name="ln1335">    ptr = xmalloc(len);</a>
<a name="ln1336">    vim_snprintf(ptr, len, &quot;^\\s*\\zs\\V%s&quot;, pat_esc);</a>
<a name="ln1337">    regmatch.regprog = vim_regcomp(ptr, RE_MAGIC);</a>
<a name="ln1338">    xfree(pat_esc);</a>
<a name="ln1339">    xfree(ptr);</a>
<a name="ln1340">  } else {</a>
<a name="ln1341">    regmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);</a>
<a name="ln1342">    if (regmatch.regprog == NULL) {</a>
<a name="ln1343">      goto theend;</a>
<a name="ln1344">    }</a>
<a name="ln1345">  }</a>
<a name="ln1346"> </a>
<a name="ln1347">  // ignore case depends on 'ignorecase', 'smartcase' and &quot;pat&quot;</a>
<a name="ln1348">  regmatch.rm_ic = ignorecase(pat);</a>
<a name="ln1349">  while (*dict != NUL &amp;&amp; !got_int &amp;&amp; !compl_interrupted) {</a>
<a name="ln1350">    // copy one dictionary file name into buf</a>
<a name="ln1351">    if (flags == DICT_EXACT) {</a>
<a name="ln1352">      count = 1;</a>
<a name="ln1353">      files = &amp;dict;</a>
<a name="ln1354">    } else {</a>
<a name="ln1355">      // Expand wildcards in the dictionary name, but do not allow</a>
<a name="ln1356">      // backticks (for security, the 'dict' option may have been set in</a>
<a name="ln1357">      // a modeline).</a>
<a name="ln1358">      copy_option_part(&amp;dict, buf, LSIZE, &quot;,&quot;);</a>
<a name="ln1359">      if (!thesaurus &amp;&amp; strcmp(buf, &quot;spell&quot;) == 0) {</a>
<a name="ln1360">        count = -1;</a>
<a name="ln1361">      } else if (vim_strchr(buf, '`') != NULL</a>
<a name="ln1362">                 || expand_wildcards(1, &amp;buf, &amp;count, &amp;files,</a>
<a name="ln1363">                                     EW_FILE|EW_SILENT) != OK) {</a>
<a name="ln1364">        count = 0;</a>
<a name="ln1365">      }</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368">    if (count == -1) {</a>
<a name="ln1369">      // Complete from active spelling.  Skip &quot;\&lt;&quot; in the pattern, we</a>
<a name="ln1370">      // don't use it as a RE.</a>
<a name="ln1371">      if (pat[0] == '\\' &amp;&amp; pat[1] == '&lt;') {</a>
<a name="ln1372">        ptr = pat + 2;</a>
<a name="ln1373">      } else {</a>
<a name="ln1374">        ptr = pat;</a>
<a name="ln1375">      }</a>
<a name="ln1376">      spell_dump_compl(ptr, regmatch.rm_ic, &amp;dir, 0);</a>
<a name="ln1377">    } else if (count &gt; 0) {  // avoid warning for using &quot;files&quot; uninit</a>
<a name="ln1378">      ins_compl_files(count, files, thesaurus, flags,</a>
<a name="ln1379">                      &amp;regmatch, buf, &amp;dir);</a>
<a name="ln1380">      if (flags != DICT_EXACT) {</a>
<a name="ln1381">        FreeWild(count, files);</a>
<a name="ln1382">      }</a>
<a name="ln1383">    }</a>
<a name="ln1384">    if (flags != 0) {</a>
<a name="ln1385">      break;</a>
<a name="ln1386">    }</a>
<a name="ln1387">  }</a>
<a name="ln1388"> </a>
<a name="ln1389">theend:</a>
<a name="ln1390">  p_scs = save_p_scs;</a>
<a name="ln1391">  vim_regfree(regmatch.regprog);</a>
<a name="ln1392">  xfree(buf);</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">/// Add all the words in the line &quot;*buf_arg&quot; from the thesaurus file &quot;fname&quot;</a>
<a name="ln1396">/// skipping the word at 'skip_word'.</a>
<a name="ln1397">///</a>
<a name="ln1398">/// @return  OK on success.</a>
<a name="ln1399">static int thesaurus_add_words_in_line(char *fname, char **buf_arg, int dir, const char *skip_word)</a>
<a name="ln1400">{</a>
<a name="ln1401">  int status = OK;</a>
<a name="ln1402"> </a>
<a name="ln1403">  // Add the other matches on the line</a>
<a name="ln1404">  char *ptr = *buf_arg;</a>
<a name="ln1405">  while (!got_int) {</a>
<a name="ln1406">    // Find start of the next word.  Skip white</a>
<a name="ln1407">    // space and punctuation.</a>
<a name="ln1408">    ptr = find_word_start(ptr);</a>
<a name="ln1409">    if (*ptr == NUL || *ptr == NL) {</a>
<a name="ln1410">      break;</a>
<a name="ln1411">    }</a>
<a name="ln1412">    char *wstart = ptr;</a>
<a name="ln1413"> </a>
<a name="ln1414">    // Find end of the word.</a>
<a name="ln1415">    // Japanese words may have characters in</a>
<a name="ln1416">    // different classes, only separate words</a>
<a name="ln1417">    // with single-byte non-word characters.</a>
<a name="ln1418">    while (*ptr != NUL) {</a>
<a name="ln1419">      const int l = utfc_ptr2len(ptr);</a>
<a name="ln1420"> </a>
<a name="ln1421">      if (l &lt; 2 &amp;&amp; !vim_iswordc((uint8_t)(*ptr))) {</a>
<a name="ln1422">        break;</a>
<a name="ln1423">      }</a>
<a name="ln1424">      ptr += l;</a>
<a name="ln1425">    }</a>
<a name="ln1426"> </a>
<a name="ln1427">    // Add the word. Skip the regexp match.</a>
<a name="ln1428">    if (wstart != skip_word) {</a>
<a name="ln1429">      status = ins_compl_add_infercase(wstart, (int)(ptr - wstart), p_ic,</a>
<a name="ln1430">                                       fname, dir, false);</a>
<a name="ln1431">      if (status == FAIL) {</a>
<a name="ln1432">        break;</a>
<a name="ln1433">      }</a>
<a name="ln1434">    }</a>
<a name="ln1435">  }</a>
<a name="ln1436"> </a>
<a name="ln1437">  *buf_arg = ptr;</a>
<a name="ln1438">  return status;</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441">/// Process &quot;count&quot; dictionary/thesaurus &quot;files&quot; and add the text matching</a>
<a name="ln1442">/// &quot;regmatch&quot;.</a>
<a name="ln1443">static void ins_compl_files(int count, char **files, int thesaurus, int flags, regmatch_T *regmatch,</a>
<a name="ln1444">                            char *buf, Direction *dir)</a>
<a name="ln1445">  FUNC_ATTR_NONNULL_ARG(2, 7)</a>
<a name="ln1446">{</a>
<a name="ln1447">  char *ptr;</a>
<a name="ln1448">  int i;</a>
<a name="ln1449">  FILE *fp;</a>
<a name="ln1450">  int add_r;</a>
<a name="ln1451"> </a>
<a name="ln1452">  for (i = 0; i &lt; count &amp;&amp; !got_int &amp;&amp; !compl_interrupted; i++) {</a>
<a name="ln1453">    fp = os_fopen(files[i], &quot;r&quot;);  // open dictionary file</a>
<a name="ln1454">    if (flags != DICT_EXACT &amp;&amp; !shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln1455">      msg_hist_off = true;  // reset in msg_trunc_attr()</a>
<a name="ln1456">      vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln1457">                   _(&quot;Scanning dictionary: %s&quot;), files[i]);</a>
<a name="ln1458">      (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln1459">    }</a>
<a name="ln1460"> </a>
<a name="ln1461">    if (fp == NULL) {</a>
<a name="ln1462">      continue;</a>
<a name="ln1463">    }</a>
<a name="ln1464"> </a>
<a name="ln1465">    // Read dictionary file line by line.</a>
<a name="ln1466">    // Check each line for a match.</a>
<a name="ln1467">    while (!got_int &amp;&amp; !compl_interrupted &amp;&amp; !vim_fgets(buf, LSIZE, fp)) {</a>
<a name="ln1468">      ptr = buf;</a>
<a name="ln1469">      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf))) {</a>
<a name="ln1470">        ptr = regmatch-&gt;startp[0];</a>
<a name="ln1471">        if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln1472">          ptr = find_line_end(ptr);</a>
<a name="ln1473">        } else {</a>
<a name="ln1474">          ptr = find_word_end(ptr);</a>
<a name="ln1475">        }</a>
<a name="ln1476">        add_r = ins_compl_add_infercase(regmatch-&gt;startp[0],</a>
<a name="ln1477">                                        (int)(ptr - regmatch-&gt;startp[0]),</a>
<a name="ln1478">                                        p_ic, files[i], *dir, false);</a>
<a name="ln1479">        if (thesaurus) {</a>
<a name="ln1480">          // For a thesaurus, add all the words in the line</a>
<a name="ln1481">          ptr = buf;</a>
<a name="ln1482">          add_r = thesaurus_add_words_in_line(files[i], &amp;ptr, *dir, regmatch-&gt;startp[0]);</a>
<a name="ln1483">        }</a>
<a name="ln1484">        if (add_r == OK) {</a>
<a name="ln1485">          // if dir was BACKWARD then honor it just once</a>
<a name="ln1486">          *dir = FORWARD;</a>
<a name="ln1487">        } else if (add_r == FAIL) {</a>
<a name="ln1488">          break;</a>
<a name="ln1489">        }</a>
<a name="ln1490">        // avoid expensive call to vim_regexec() when at end</a>
<a name="ln1491">        // of line</a>
<a name="ln1492">        if (*ptr == '\n' || got_int) {</a>
<a name="ln1493">          break;</a>
<a name="ln1494">        }</a>
<a name="ln1495">      }</a>
<a name="ln1496">      line_breakcheck();</a>
<a name="ln1497">      ins_compl_check_keys(50, false);</a>
<a name="ln1498">    }</a>
<a name="ln1499">    fclose(fp);</a>
<a name="ln1500">  }</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">/// Find the start of the next word.</a>
<a name="ln1504">/// Returns a pointer to the first char of the word.  Also stops at a NUL.</a>
<a name="ln1505">char *find_word_start(char *ptr)</a>
<a name="ln1506">  FUNC_ATTR_PURE</a>
<a name="ln1507">{</a>
<a name="ln1508">  while (*ptr != NUL &amp;&amp; *ptr != '\n' &amp;&amp; mb_get_class(ptr) &lt;= 1) {</a>
<a name="ln1509">    ptr += utfc_ptr2len(ptr);</a>
<a name="ln1510">  }</a>
<a name="ln1511">  return ptr;</a>
<a name="ln1512">}</a>
<a name="ln1513"> </a>
<a name="ln1514">/// Find the end of the word.  Assumes it starts inside a word.</a>
<a name="ln1515">/// Returns a pointer to just after the word.</a>
<a name="ln1516">char *find_word_end(char *ptr)</a>
<a name="ln1517">  FUNC_ATTR_PURE</a>
<a name="ln1518">{</a>
<a name="ln1519">  const int start_class = mb_get_class(ptr);</a>
<a name="ln1520">  if (start_class &gt; 1) {</a>
<a name="ln1521">    while (*ptr != NUL) {</a>
<a name="ln1522">      ptr += utfc_ptr2len(ptr);</a>
<a name="ln1523">      if (mb_get_class(ptr) != start_class) {</a>
<a name="ln1524">        break;</a>
<a name="ln1525">      }</a>
<a name="ln1526">    }</a>
<a name="ln1527">  }</a>
<a name="ln1528">  return ptr;</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">/// Find the end of the line, omitting CR and NL at the end.</a>
<a name="ln1532">///</a>
<a name="ln1533">/// @return  a pointer to just after the line.</a>
<a name="ln1534">static char *find_line_end(char *ptr)</a>
<a name="ln1535">{</a>
<a name="ln1536">  char *s;</a>
<a name="ln1537"> </a>
<a name="ln1538">  s = ptr + strlen(ptr);</a>
<a name="ln1539">  while (s &gt; ptr &amp;&amp; (s[-1] == CAR || s[-1] == NL)) {</a>
<a name="ln1540">    s--;</a>
<a name="ln1541">  }</a>
<a name="ln1542">  return s;</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545">/// Free the list of completions</a>
<a name="ln1546">static void ins_compl_free(void)</a>
<a name="ln1547">{</a>
<a name="ln1548">  compl_T *match;</a>
<a name="ln1549"> </a>
<a name="ln1550">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1551">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1552"> </a>
<a name="ln1553">  if (compl_first_match == NULL) {</a>
<a name="ln1554">    return;</a>
<a name="ln1555">  }</a>
<a name="ln1556"> </a>
<a name="ln1557">  ins_compl_del_pum();</a>
<a name="ln1558">  pum_clear();</a>
<a name="ln1559"> </a>
<a name="ln1560">  compl_curr_match = compl_first_match;</a>
<a name="ln1561">  do {</a>
<a name="ln1562">    match = compl_curr_match;</a>
<a name="ln1563">    compl_curr_match = compl_curr_match-&gt;cp_next;</a>
<a name="ln1564">    xfree(match-&gt;cp_str);</a>
<a name="ln1565">    // several entries may use the same fname, free it just once.</a>
<a name="ln1566">    if (match-&gt;cp_flags &amp; CP_FREE_FNAME) {</a>
<a name="ln1567">      xfree(match-&gt;cp_fname);</a>
<a name="ln1568">    }</a>
<a name="ln1569">    for (int i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln1570">      xfree(match-&gt;cp_text[i]);</a>
<a name="ln1571">    }</a>
<a name="ln1572">    tv_clear(&amp;match-&gt;cp_user_data);</a>
<a name="ln1573">    xfree(match);</a>
<a name="ln1574">  } while (compl_curr_match != NULL &amp;&amp; !is_first_match(compl_curr_match));</a>
<a name="ln1575">  compl_first_match = compl_curr_match = NULL;</a>
<a name="ln1576">  compl_shown_match = NULL;</a>
<a name="ln1577">  compl_old_match = NULL;</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">/// Reset/clear the completion state.</a>
<a name="ln1581">void ins_compl_clear(void)</a>
<a name="ln1582">{</a>
<a name="ln1583">  compl_cont_status = 0;</a>
<a name="ln1584">  compl_started = false;</a>
<a name="ln1585">  compl_matches = 0;</a>
<a name="ln1586">  XFREE_CLEAR(compl_pattern);</a>
<a name="ln1587">  XFREE_CLEAR(compl_leader);</a>
<a name="ln1588">  edit_submode_extra = NULL;</a>
<a name="ln1589">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln1590">  compl_enter_selects = false;</a>
<a name="ln1591">  // clear v:completed_item</a>
<a name="ln1592">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln1593">}</a>
<a name="ln1594"> </a>
<a name="ln1595">/// Check that Insert completion is active.</a>
<a name="ln1596">bool ins_compl_active(void)</a>
<a name="ln1597">  FUNC_ATTR_PURE</a>
<a name="ln1598">{</a>
<a name="ln1599">  return compl_started;</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">/// Selected one of the matches.  When false the match was edited or using the</a>
<a name="ln1603">/// longest common string.</a>
<a name="ln1604">bool ins_compl_used_match(void)</a>
<a name="ln1605">{</a>
<a name="ln1606">  return compl_used_match;</a>
<a name="ln1607">}</a>
<a name="ln1608"> </a>
<a name="ln1609">/// Initialize get longest common string.</a>
<a name="ln1610">void ins_compl_init_get_longest(void)</a>
<a name="ln1611">{</a>
<a name="ln1612">  compl_get_longest = false;</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615">/// Returns true when insert completion is interrupted.</a>
<a name="ln1616">bool ins_compl_interrupted(void)</a>
<a name="ln1617">{</a>
<a name="ln1618">  return compl_interrupted;</a>
<a name="ln1619">}</a>
<a name="ln1620"> </a>
<a name="ln1621">/// Returns true if the &lt;Enter&gt; key selects a match in the completion popup</a>
<a name="ln1622">/// menu.</a>
<a name="ln1623">bool ins_compl_enter_selects(void)</a>
<a name="ln1624">{</a>
<a name="ln1625">  return compl_enter_selects;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">/// Return the column where the text starts that is being completed</a>
<a name="ln1629">colnr_T ins_compl_col(void)</a>
<a name="ln1630">{</a>
<a name="ln1631">  return compl_col;</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">/// Return the length in bytes of the text being completed</a>
<a name="ln1635">int ins_compl_len(void)</a>
<a name="ln1636">{</a>
<a name="ln1637">  return compl_length;</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">/// Delete one character before the cursor and show the subset of the matches</a>
<a name="ln1641">/// that match the word that is now before the cursor.</a>
<a name="ln1642">/// Returns the character to be used, NUL if the work is done and another char</a>
<a name="ln1643">/// to be got from the user.</a>
<a name="ln1644">int ins_compl_bs(void)</a>
<a name="ln1645">{</a>
<a name="ln1646">  char *line = get_cursor_line_ptr();</a>
<a name="ln1647">  char *p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln1648">  MB_PTR_BACK(line, p);</a>
<a name="ln1649">  ptrdiff_t p_off = p - line;</a>
<a name="ln1650"> </a>
<a name="ln1651">  // Stop completion when the whole word was deleted.  For Omni completion</a>
<a name="ln1652">  // allow the word to be deleted, we won't match everything.</a>
<a name="ln1653">  // Respect the 'backspace' option.</a>
<a name="ln1654">  if ((int)(p - line) - (int)compl_col &lt; 0</a>
<a name="ln1655">      || ((int)(p - line) - (int)compl_col == 0 &amp;&amp; !ctrl_x_mode_omni())</a>
<a name="ln1656">      || ctrl_x_mode_eval()</a>
<a name="ln1657">      || (!can_bs(BS_START) &amp;&amp; (int)(p - line) - (int)compl_col</a>
<a name="ln1658">          - compl_length &lt; 0)) {</a>
<a name="ln1659">    return K_BS;</a>
<a name="ln1660">  }</a>
<a name="ln1661"> </a>
<a name="ln1662">  // Deleted more than what was used to find matches or didn't finish</a>
<a name="ln1663">  // finding all matches: need to look for matches all over again.</a>
<a name="ln1664">  if (curwin-&gt;w_cursor.col &lt;= compl_col + compl_length</a>
<a name="ln1665">      || ins_compl_need_restart()) {</a>
<a name="ln1666">    ins_compl_restart();</a>
<a name="ln1667">  }</a>
<a name="ln1668"> </a>
<a name="ln1669">  // ins_compl_restart() calls update_screen() which may invalidate the pointer</a>
<a name="ln1670">  // TODO(bfredl): get rid of random update_screen() calls deep inside completion logic</a>
<a name="ln1671">  line = get_cursor_line_ptr();</a>
<a name="ln1672"> </a>
<a name="ln1673">  xfree(compl_leader);</a>
<a name="ln1674">  compl_leader = xstrnsave(line + compl_col, (size_t)(p_off - (ptrdiff_t)compl_col));</a>
<a name="ln1675"> </a>
<a name="ln1676">  ins_compl_new_leader();</a>
<a name="ln1677">  if (compl_shown_match != NULL) {</a>
<a name="ln1678">    // Make sure current match is not a hidden item.</a>
<a name="ln1679">    compl_curr_match = compl_shown_match;</a>
<a name="ln1680">  }</a>
<a name="ln1681">  return NUL;</a>
<a name="ln1682">}</a>
<a name="ln1683"> </a>
<a name="ln1684">/// Check that we need to find matches again, ins_compl_restart() is to</a>
<a name="ln1685">/// be called.</a>
<a name="ln1686">static bool ins_compl_need_restart(void)</a>
<a name="ln1687">  FUNC_ATTR_PURE</a>
<a name="ln1688">{</a>
<a name="ln1689">  // Return true if we didn't complete finding matches or when the</a>
<a name="ln1690">  // &quot;completefunc&quot; returned &quot;always&quot; in the &quot;refresh&quot; dictionary item.</a>
<a name="ln1691">  return compl_was_interrupted</a>
<a name="ln1692">         || ((ctrl_x_mode_function() || ctrl_x_mode_omni())</a>
<a name="ln1693">             &amp;&amp; compl_opt_refresh_always);</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">/// Called after changing &quot;compl_leader&quot;.</a>
<a name="ln1697">/// Show the popup menu with a different set of matches.</a>
<a name="ln1698">/// May also search for matches again if the previous search was interrupted.</a>
<a name="ln1699">static void ins_compl_new_leader(void)</a>
<a name="ln1700">{</a>
<a name="ln1701">  ins_compl_del_pum();</a>
<a name="ln1702">  ins_compl_delete();</a>
<a name="ln1703">  ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln1704">  compl_used_match = false;</a>
<a name="ln1705"> </a>
<a name="ln1706">  if (compl_started) {</a>
<a name="ln1707">    ins_compl_set_original_text(compl_leader);</a>
<a name="ln1708">  } else {</a>
<a name="ln1709">    spell_bad_len = 0;  // need to redetect bad word</a>
<a name="ln1710">    // Matches were cleared, need to search for them now.</a>
<a name="ln1711">    // Set &quot;compl_restarting&quot; to avoid that the first match is inserted.</a>
<a name="ln1712">    compl_restarting = true;</a>
<a name="ln1713">    if (ins_complete(Ctrl_N, true) == FAIL) {</a>
<a name="ln1714">      compl_cont_status = 0;</a>
<a name="ln1715">    }</a>
<a name="ln1716">    compl_restarting = false;</a>
<a name="ln1717">  }</a>
<a name="ln1718"> </a>
<a name="ln1719">  compl_enter_selects = !compl_used_match;</a>
<a name="ln1720"> </a>
<a name="ln1721">  // Show the popup menu with a different set of matches.</a>
<a name="ln1722">  ins_compl_show_pum();</a>
<a name="ln1723"> </a>
<a name="ln1724">  // Don't let Enter select the original text when there is no popup menu.</a>
<a name="ln1725">  // Don't let Enter select when use user function and refresh_always is set</a>
<a name="ln1726">  if (compl_match_array == NULL || ins_compl_need_restart()) {</a>
<a name="ln1727">    compl_enter_selects = false;</a>
<a name="ln1728">  }</a>
<a name="ln1729">}</a>
<a name="ln1730"> </a>
<a name="ln1731">/// Return the length of the completion, from the completion start column to</a>
<a name="ln1732">/// the cursor column.  Making sure it never goes below zero.</a>
<a name="ln1733">static int get_compl_len(void)</a>
<a name="ln1734">{</a>
<a name="ln1735">  int off = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1736"> </a>
<a name="ln1737">  if (off &lt; 0) {</a>
<a name="ln1738">    return 0;</a>
<a name="ln1739">  }</a>
<a name="ln1740">  return off;</a>
<a name="ln1741">}</a>
<a name="ln1742"> </a>
<a name="ln1743">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1744">/// matches.</a>
<a name="ln1745">void ins_compl_addleader(int c)</a>
<a name="ln1746">{</a>
<a name="ln1747">  int cc;</a>
<a name="ln1748"> </a>
<a name="ln1749">  if (stop_arrow() == FAIL) {</a>
<a name="ln1750">    return;</a>
<a name="ln1751">  }</a>
<a name="ln1752">  if ((cc = utf_char2len(c)) &gt; 1) {</a>
<a name="ln1753">    char buf[MB_MAXBYTES + 1];</a>
<a name="ln1754"> </a>
<a name="ln1755">    utf_char2bytes(c, buf);</a>
<a name="ln1756">    buf[cc] = NUL;</a>
<a name="ln1757">    ins_char_bytes(buf, (size_t)cc);</a>
<a name="ln1758">  } else {</a>
<a name="ln1759">    ins_char(c);</a>
<a name="ln1760">  }</a>
<a name="ln1761"> </a>
<a name="ln1762">  // If we didn't complete finding matches we must search again.</a>
<a name="ln1763">  if (ins_compl_need_restart()) {</a>
<a name="ln1764">    ins_compl_restart();</a>
<a name="ln1765">  }</a>
<a name="ln1766"> </a>
<a name="ln1767">  xfree(compl_leader);</a>
<a name="ln1768">  compl_leader = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln1769">                           (size_t)(curwin-&gt;w_cursor.col - compl_col));</a>
<a name="ln1770">  ins_compl_new_leader();</a>
<a name="ln1771">}</a>
<a name="ln1772"> </a>
<a name="ln1773">/// Setup for finding completions again without leaving CTRL-X mode.  Used when</a>
<a name="ln1774">/// BS or a key was typed while still searching for matches.</a>
<a name="ln1775">static void ins_compl_restart(void)</a>
<a name="ln1776">{</a>
<a name="ln1777">  // update screen before restart.</a>
<a name="ln1778">  // so if complete is blocked,</a>
<a name="ln1779">  // will stay to the last popup menu and reduce flicker</a>
<a name="ln1780">  update_screen();  // TODO(bfredl): no.</a>
<a name="ln1781">  ins_compl_free();</a>
<a name="ln1782">  compl_started = false;</a>
<a name="ln1783">  compl_matches = 0;</a>
<a name="ln1784">  compl_cont_status = 0;</a>
<a name="ln1785">  compl_cont_mode = 0;</a>
<a name="ln1786">}</a>
<a name="ln1787"> </a>
<a name="ln1788">/// Set the first match, the original text.</a>
<a name="ln1789">static void ins_compl_set_original_text(char *str)</a>
<a name="ln1790">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1791">{</a>
<a name="ln1792">  // Replace the original text entry.</a>
<a name="ln1793">  // The CP_ORIGINAL_TEXT flag is either at the first item or might possibly</a>
<a name="ln1794">  // be at the last item for backward completion</a>
<a name="ln1795">  if (match_at_original_text(compl_first_match)) {  // safety check</a>
<a name="ln1796">    xfree(compl_first_match-&gt;cp_str);</a>
<a name="ln1797">    compl_first_match-&gt;cp_str = xstrdup(str);</a>
<a name="ln1798">  } else if (compl_first_match-&gt;cp_prev != NULL</a>
<a name="ln1799">             &amp;&amp; match_at_original_text(compl_first_match-&gt;cp_prev)) {</a>
<a name="ln1800">    xfree(compl_first_match-&gt;cp_prev-&gt;cp_str);</a>
<a name="ln1801">    compl_first_match-&gt;cp_prev-&gt;cp_str = xstrdup(str);</a>
<a name="ln1802">  }</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">/// Append one character to the match leader.  May reduce the number of</a>
<a name="ln1806">/// matches.</a>
<a name="ln1807">void ins_compl_addfrommatch(void)</a>
<a name="ln1808">{</a>
<a name="ln1809">  char *p;</a>
<a name="ln1810">  int len = (int)curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln1811">  int c;</a>
<a name="ln1812">  compl_T *cp;</a>
<a name="ln1813">  assert(compl_shown_match != NULL);</a>
<a name="ln1814">  p = compl_shown_match-&gt;cp_str;</a>
<a name="ln1815">  if ((int)strlen(p) &lt;= len) {   // the match is too short</a>
<a name="ln1816">    // When still at the original match use the first entry that matches</a>
<a name="ln1817">    // the leader.</a>
<a name="ln1818">    if (!match_at_original_text(compl_shown_match)) {</a>
<a name="ln1819">      return;</a>
<a name="ln1820">    }</a>
<a name="ln1821"> </a>
<a name="ln1822">    p = NULL;</a>
<a name="ln1823">    for (cp = compl_shown_match-&gt;cp_next; cp != NULL</a>
<a name="ln1824">         &amp;&amp; !is_first_match(cp); cp = cp-&gt;cp_next) {</a>
<a name="ln1825">      if (compl_leader == NULL</a>
<a name="ln1826">          || ins_compl_equal(cp, compl_leader, strlen(compl_leader))) {</a>
<a name="ln1827">        p = cp-&gt;cp_str;</a>
<a name="ln1828">        break;</a>
<a name="ln1829">      }</a>
<a name="ln1830">    }</a>
<a name="ln1831">    if (p == NULL || (int)strlen(p) &lt;= len) {</a>
<a name="ln1832">      return;</a>
<a name="ln1833">    }</a>
<a name="ln1834">  }</a>
<a name="ln1835">  p += len;</a>
<a name="ln1836">  c = utf_ptr2char(p);</a>
<a name="ln1837">  ins_compl_addleader(c);</a>
<a name="ln1838">}</a>
<a name="ln1839"> </a>
<a name="ln1840">/// Set the CTRL-X completion mode based on the key &quot;c&quot; typed after a CTRL-X.</a>
<a name="ln1841">/// Uses the global variables: ctrl_x_mode, edit_submode, edit_submode_pre,</a>
<a name="ln1842">/// compl_cont_mode and compl_cont_status.</a>
<a name="ln1843">///</a>
<a name="ln1844">/// @return  true when the character is not to be inserted.</a>
<a name="ln1845">static bool set_ctrl_x_mode(const int c)</a>
<a name="ln1846">{</a>
<a name="ln1847">  bool retval = false;</a>
<a name="ln1848"> </a>
<a name="ln1849">  switch (c) {</a>
<a name="ln1850">  case Ctrl_E:</a>
<a name="ln1851">  case Ctrl_Y:</a>
<a name="ln1852">    // scroll the window one line up or down</a>
<a name="ln1853">    ctrl_x_mode = CTRL_X_SCROLL;</a>
<a name="ln1854">    if (!(State &amp; REPLACE_FLAG)) {</a>
<a name="ln1855">      edit_submode = _(&quot; (insert) Scroll (^E/^Y)&quot;);</a>
<a name="ln1856">    } else {</a>
<a name="ln1857">      edit_submode = _(&quot; (replace) Scroll (^E/^Y)&quot;);</a>
<a name="ln1858">    }</a>
<a name="ln1859">    edit_submode_pre = NULL;</a>
<a name="ln1860">    showmode();</a>
<a name="ln1861">    break;</a>
<a name="ln1862">  case Ctrl_L:</a>
<a name="ln1863">    // complete whole line</a>
<a name="ln1864">    ctrl_x_mode = CTRL_X_WHOLE_LINE;</a>
<a name="ln1865">    break;</a>
<a name="ln1866">  case Ctrl_F:</a>
<a name="ln1867">    // complete filenames</a>
<a name="ln1868">    ctrl_x_mode = CTRL_X_FILES;</a>
<a name="ln1869">    break;</a>
<a name="ln1870">  case Ctrl_K:</a>
<a name="ln1871">    // complete words from a dictionary</a>
<a name="ln1872">    ctrl_x_mode = CTRL_X_DICTIONARY;</a>
<a name="ln1873">    break;</a>
<a name="ln1874">  case Ctrl_R:</a>
<a name="ln1875">    // Register insertion without exiting CTRL-X mode</a>
<a name="ln1876">    // Simply allow ^R to happen without affecting ^X mode</a>
<a name="ln1877">    break;</a>
<a name="ln1878">  case Ctrl_T:</a>
<a name="ln1879">    // complete words from a thesaurus</a>
<a name="ln1880">    ctrl_x_mode = CTRL_X_THESAURUS;</a>
<a name="ln1881">    break;</a>
<a name="ln1882">  case Ctrl_U:</a>
<a name="ln1883">    // user defined completion</a>
<a name="ln1884">    ctrl_x_mode = CTRL_X_FUNCTION;</a>
<a name="ln1885">    break;</a>
<a name="ln1886">  case Ctrl_O:</a>
<a name="ln1887">    // omni completion</a>
<a name="ln1888">    ctrl_x_mode = CTRL_X_OMNI;</a>
<a name="ln1889">    break;</a>
<a name="ln1890">  case 's':</a>
<a name="ln1891">  case Ctrl_S:</a>
<a name="ln1892">    // complete spelling suggestions</a>
<a name="ln1893">    ctrl_x_mode = CTRL_X_SPELL;</a>
<a name="ln1894">    emsg_off++;  // Avoid getting the E756 error twice.</a>
<a name="ln1895">    spell_back_to_badword();</a>
<a name="ln1896">    emsg_off--;</a>
<a name="ln1897">    break;</a>
<a name="ln1898">  case Ctrl_RSB:</a>
<a name="ln1899">    // complete tag names</a>
<a name="ln1900">    ctrl_x_mode = CTRL_X_TAGS;</a>
<a name="ln1901">    break;</a>
<a name="ln1902">  case Ctrl_I:</a>
<a name="ln1903">  case K_S_TAB:</a>
<a name="ln1904">    // complete keywords from included files</a>
<a name="ln1905">    ctrl_x_mode = CTRL_X_PATH_PATTERNS;</a>
<a name="ln1906">    break;</a>
<a name="ln1907">  case Ctrl_D:</a>
<a name="ln1908">    // complete definitions from included files</a>
<a name="ln1909">    ctrl_x_mode = CTRL_X_PATH_DEFINES;</a>
<a name="ln1910">    break;</a>
<a name="ln1911">  case Ctrl_V:</a>
<a name="ln1912">  case Ctrl_Q:</a>
<a name="ln1913">    // complete vim commands</a>
<a name="ln1914">    ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln1915">    break;</a>
<a name="ln1916">  case Ctrl_Z:</a>
<a name="ln1917">    // stop completion</a>
<a name="ln1918">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1919">    edit_submode = NULL;</a>
<a name="ln1920">    showmode();</a>
<a name="ln1921">    retval = true;</a>
<a name="ln1922">    break;</a>
<a name="ln1923">  case Ctrl_P:</a>
<a name="ln1924">  case Ctrl_N:</a>
<a name="ln1925">    // ^X^P means LOCAL expansion if nothing interrupted (eg we</a>
<a name="ln1926">    // just started ^X mode, or there were enough ^X's to cancel</a>
<a name="ln1927">    // the previous mode, say ^X^F^X^X^P or ^P^X^X^X^P, see below)</a>
<a name="ln1928">    // do normal expansion when interrupting a different mode (say</a>
<a name="ln1929">    // ^X^F^X^P or ^P^X^X^P, see below)</a>
<a name="ln1930">    // nothing changes if interrupting mode 0, (eg, the flag</a>
<a name="ln1931">    // doesn't change when going to ADDING mode  -- Acevedo</a>
<a name="ln1932">    if (!(compl_cont_status &amp; CONT_INTRPT)) {</a>
<a name="ln1933">      compl_cont_status |= CONT_LOCAL;</a>
<a name="ln1934">    } else if (compl_cont_mode != 0) {</a>
<a name="ln1935">      compl_cont_status &amp;= ~CONT_LOCAL;</a>
<a name="ln1936">    }</a>
<a name="ln1937">    FALLTHROUGH;</a>
<a name="ln1938">  default:</a>
<a name="ln1939">    // If we have typed at least 2 ^X's... for modes != 0, we set</a>
<a name="ln1940">    // compl_cont_status = 0 (eg, as if we had just started ^X</a>
<a name="ln1941">    // mode).</a>
<a name="ln1942">    // For mode 0, we set &quot;compl_cont_mode&quot; to an impossible</a>
<a name="ln1943">    // value, in both cases ^X^X can be used to restart the same</a>
<a name="ln1944">    // mode (avoiding ADDING mode).</a>
<a name="ln1945">    // Undocumented feature: In a mode != 0 ^X^P and ^X^X^P start</a>
<a name="ln1946">    // 'complete' and local ^P expansions respectively.</a>
<a name="ln1947">    // In mode 0 an extra ^X is needed since ^X^P goes to ADDING</a>
<a name="ln1948">    // mode  -- Acevedo</a>
<a name="ln1949">    if (c == Ctrl_X) {</a>
<a name="ln1950">      if (compl_cont_mode != 0) {</a>
<a name="ln1951">        compl_cont_status = 0;</a>
<a name="ln1952">      } else {</a>
<a name="ln1953">        compl_cont_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln1954">      }</a>
<a name="ln1955">    }</a>
<a name="ln1956">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln1957">    edit_submode = NULL;</a>
<a name="ln1958">    showmode();</a>
<a name="ln1959">    break;</a>
<a name="ln1960">  }</a>
<a name="ln1961"> </a>
<a name="ln1962">  return retval;</a>
<a name="ln1963">}</a>
<a name="ln1964"> </a>
<a name="ln1965">/// Stop insert completion mode</a>
<a name="ln1966">static bool ins_compl_stop(const int c, const int prev_mode, bool retval)</a>
<a name="ln1967">{</a>
<a name="ln1968">  // Get here when we have finished typing a sequence of ^N and</a>
<a name="ln1969">  // ^P or other completion characters in CTRL-X mode.  Free up</a>
<a name="ln1970">  // memory that was used, and make sure we can redo the insert.</a>
<a name="ln1971">  if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {</a>
<a name="ln1972">    // If any of the original typed text has been changed, eg when</a>
<a name="ln1973">    // ignorecase is set, we must add back-spaces to the redo</a>
<a name="ln1974">    // buffer.  We add as few as necessary to delete just the part</a>
<a name="ln1975">    // of the original text that has changed.</a>
<a name="ln1976">    // When using the longest match, edited the match or used</a>
<a name="ln1977">    // CTRL-E then don't use the current match.</a>
<a name="ln1978">    char *ptr;</a>
<a name="ln1979">    if (compl_curr_match != NULL &amp;&amp; compl_used_match &amp;&amp; c != Ctrl_E) {</a>
<a name="ln1980">      ptr = compl_curr_match-&gt;cp_str;</a>
<a name="ln1981">    } else {</a>
<a name="ln1982">      ptr = NULL;</a>
<a name="ln1983">    }</a>
<a name="ln1984">    ins_compl_fixRedoBufForLeader(ptr);</a>
<a name="ln1985">  }</a>
<a name="ln1986"> </a>
<a name="ln1987">  bool want_cindent = (get_can_cindent() &amp;&amp; cindent_on());</a>
<a name="ln1988"> </a>
<a name="ln1989">  // When completing whole lines: fix indent for 'cindent'.</a>
<a name="ln1990">  // Otherwise, break line if it's too long.</a>
<a name="ln1991">  if (compl_cont_mode == CTRL_X_WHOLE_LINE) {</a>
<a name="ln1992">    // re-indent the current line</a>
<a name="ln1993">    if (want_cindent) {</a>
<a name="ln1994">      do_c_expr_indent();</a>
<a name="ln1995">      want_cindent = false;                 // don't do it again</a>
<a name="ln1996">    }</a>
<a name="ln1997">  } else {</a>
<a name="ln1998">    const int prev_col = curwin-&gt;w_cursor.col;</a>
<a name="ln1999"> </a>
<a name="ln2000">    // put the cursor on the last char, for 'tw' formatting</a>
<a name="ln2001">    if (prev_col &gt; 0) {</a>
<a name="ln2002">      dec_cursor();</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    // only format when something was inserted</a>
<a name="ln2006">    if (!arrow_used &amp;&amp; !ins_need_undo_get() &amp;&amp; c != Ctrl_E) {</a>
<a name="ln2007">      insertchar(NUL, 0, -1);</a>
<a name="ln2008">    }</a>
<a name="ln2009"> </a>
<a name="ln2010">    if (prev_col &gt; 0</a>
<a name="ln2011">        &amp;&amp; get_cursor_line_ptr()[curwin-&gt;w_cursor.col] != NUL) {</a>
<a name="ln2012">      inc_cursor();</a>
<a name="ln2013">    }</a>
<a name="ln2014">  }</a>
<a name="ln2015"> </a>
<a name="ln2016">  // If the popup menu is displayed pressing CTRL-Y means accepting</a>
<a name="ln2017">  // the selection without inserting anything.  When</a>
<a name="ln2018">  // compl_enter_selects is set the Enter key does the same.</a>
<a name="ln2019">  if ((c == Ctrl_Y || (compl_enter_selects</a>
<a name="ln2020">                       &amp;&amp; (c == CAR || c == K_KENTER || c == NL)))</a>
<a name="ln2021">      &amp;&amp; pum_visible()) {</a>
<a name="ln2022">    retval = true;</a>
<a name="ln2023">  }</a>
<a name="ln2024"> </a>
<a name="ln2025">  // CTRL-E means completion is Ended, go back to the typed text.</a>
<a name="ln2026">  // but only do this, if the Popup is still visible</a>
<a name="ln2027">  if (c == Ctrl_E) {</a>
<a name="ln2028">    ins_compl_delete();</a>
<a name="ln2029">    char *p = NULL;</a>
<a name="ln2030">    if (compl_leader != NULL) {</a>
<a name="ln2031">      p = compl_leader;</a>
<a name="ln2032">    } else if (compl_first_match != NULL) {</a>
<a name="ln2033">      p = compl_orig_text;</a>
<a name="ln2034">    }</a>
<a name="ln2035">    if (p != NULL) {</a>
<a name="ln2036">      const int compl_len = get_compl_len();</a>
<a name="ln2037">      const int len = (int)strlen(p);</a>
<a name="ln2038">      if (len &gt; compl_len) {</a>
<a name="ln2039">        ins_bytes_len(p + compl_len, (size_t)(len - compl_len));</a>
<a name="ln2040">      }</a>
<a name="ln2041">    }</a>
<a name="ln2042">    retval = true;</a>
<a name="ln2043">  }</a>
<a name="ln2044"> </a>
<a name="ln2045">  auto_format(false, true);</a>
<a name="ln2046"> </a>
<a name="ln2047">  // Trigger the CompleteDonePre event to give scripts a chance to</a>
<a name="ln2048">  // act upon the completion before clearing the info, and restore</a>
<a name="ln2049">  // ctrl_x_mode, so that complete_info() can be used.</a>
<a name="ln2050">  ctrl_x_mode = prev_mode;</a>
<a name="ln2051">  ins_apply_autocmds(EVENT_COMPLETEDONEPRE);</a>
<a name="ln2052"> </a>
<a name="ln2053">  ins_compl_free();</a>
<a name="ln2054">  compl_started = false;</a>
<a name="ln2055">  compl_matches = 0;</a>
<a name="ln2056">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln2057">    msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln2058">  }</a>
<a name="ln2059">  ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2060">  compl_enter_selects = false;</a>
<a name="ln2061">  if (edit_submode != NULL) {</a>
<a name="ln2062">    edit_submode = NULL;</a>
<a name="ln2063">    showmode();</a>
<a name="ln2064">  }</a>
<a name="ln2065"> </a>
<a name="ln2066">  if (c == Ctrl_C &amp;&amp; cmdwin_type != 0) {</a>
<a name="ln2067">    // Avoid the popup menu remains displayed when leaving the</a>
<a name="ln2068">    // command line window.</a>
<a name="ln2069">    update_screen();</a>
<a name="ln2070">  }</a>
<a name="ln2071"> </a>
<a name="ln2072">  // Indent now if a key was typed that is in 'cinkeys'.</a>
<a name="ln2073">  if (want_cindent &amp;&amp; in_cinkeys(KEY_COMPLETE, ' ', inindent(0))) {</a>
<a name="ln2074">    do_c_expr_indent();</a>
<a name="ln2075">  }</a>
<a name="ln2076">  // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2077">  // upon the end of completion.</a>
<a name="ln2078">  ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2079"> </a>
<a name="ln2080">  return retval;</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/// Prepare for Insert mode completion, or stop it.</a>
<a name="ln2084">/// Called just after typing a character in Insert mode.</a>
<a name="ln2085">///</a>
<a name="ln2086">/// @param  c  character that was typed</a>
<a name="ln2087">///</a>
<a name="ln2088">/// @return true when the character is not to be inserted;</a>
<a name="ln2089">bool ins_compl_prep(int c)</a>
<a name="ln2090">{</a>
<a name="ln2091">  bool retval = false;</a>
<a name="ln2092">  const int prev_mode = ctrl_x_mode;</a>
<a name="ln2093"> </a>
<a name="ln2094">  // Forget any previous 'special' messages if this is actually</a>
<a name="ln2095">  // a ^X mode key - bar ^R, in which case we wait to see what it gives us.</a>
<a name="ln2096">  if (c != Ctrl_R &amp;&amp; vim_is_ctrl_x_key(c)) {</a>
<a name="ln2097">    edit_submode_extra = NULL;</a>
<a name="ln2098">  }</a>
<a name="ln2099"> </a>
<a name="ln2100">  // Ignore end of Select mode mapping and mouse scroll/movement.</a>
<a name="ln2101">  if (c == K_SELECT || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln2102">      || c == K_MOUSELEFT || c == K_MOUSERIGHT || c == K_MOUSEMOVE</a>
<a name="ln2103">      || c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln2104">    return retval;</a>
<a name="ln2105">  }</a>
<a name="ln2106"> </a>
<a name="ln2107">  if (ctrl_x_mode == CTRL_X_CMDLINE_CTRL_X &amp;&amp; c != Ctrl_X) {</a>
<a name="ln2108">    if (c == Ctrl_V || c == Ctrl_Q || c == Ctrl_Z || ins_compl_pum_key(c)</a>
<a name="ln2109">        || !vim_is_ctrl_x_key(c)) {</a>
<a name="ln2110">      // Not starting another completion mode.</a>
<a name="ln2111">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2112"> </a>
<a name="ln2113">      // CTRL-X CTRL-Z should stop completion without inserting anything</a>
<a name="ln2114">      if (c == Ctrl_Z) {</a>
<a name="ln2115">        retval = true;</a>
<a name="ln2116">      }</a>
<a name="ln2117">    } else {</a>
<a name="ln2118">      ctrl_x_mode = CTRL_X_CMDLINE;</a>
<a name="ln2119"> </a>
<a name="ln2120">      // Other CTRL-X keys first stop completion, then start another</a>
<a name="ln2121">      // completion mode.</a>
<a name="ln2122">      ins_compl_prep(' ');</a>
<a name="ln2123">      ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;</a>
<a name="ln2124">    }</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127">  // Set &quot;compl_get_longest&quot; when finding the first matches.</a>
<a name="ln2128">  if (ctrl_x_mode_not_defined_yet()</a>
<a name="ln2129">      || (ctrl_x_mode_normal() &amp;&amp; !compl_started)) {</a>
<a name="ln2130">    compl_get_longest = compl_longest;</a>
<a name="ln2131">    compl_used_match = true;</a>
<a name="ln2132">  }</a>
<a name="ln2133"> </a>
<a name="ln2134">  if (ctrl_x_mode_not_defined_yet()) {</a>
<a name="ln2135">    // We have just typed CTRL-X and aren't quite sure which CTRL-X mode</a>
<a name="ln2136">    // it will be yet.  Now we decide.</a>
<a name="ln2137">    retval = set_ctrl_x_mode(c);</a>
<a name="ln2138">  } else if (ctrl_x_mode_not_default()) {</a>
<a name="ln2139">    // We're already in CTRL-X mode, do we stay in it?</a>
<a name="ln2140">    if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2141">      if (ctrl_x_mode_scroll()) {</a>
<a name="ln2142">        ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln2143">      } else {</a>
<a name="ln2144">        ctrl_x_mode = CTRL_X_FINISHED;</a>
<a name="ln2145">      }</a>
<a name="ln2146">      edit_submode = NULL;</a>
<a name="ln2147">    }</a>
<a name="ln2148">    showmode();</a>
<a name="ln2149">  }</a>
<a name="ln2150"> </a>
<a name="ln2151">  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2152">    // Show error message from attempted keyword completion (probably</a>
<a name="ln2153">    // 'Pattern not found') until another key is hit, then go back to</a>
<a name="ln2154">    // showing what mode we are in.</a>
<a name="ln2155">    showmode();</a>
<a name="ln2156">    if ((ctrl_x_mode_normal()</a>
<a name="ln2157">         &amp;&amp; c != Ctrl_N</a>
<a name="ln2158">         &amp;&amp; c != Ctrl_P</a>
<a name="ln2159">         &amp;&amp; c != Ctrl_R</a>
<a name="ln2160">         &amp;&amp; !ins_compl_pum_key(c))</a>
<a name="ln2161">        || ctrl_x_mode == CTRL_X_FINISHED) {</a>
<a name="ln2162">      retval = ins_compl_stop(c, prev_mode, retval);</a>
<a name="ln2163">    }</a>
<a name="ln2164">  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {</a>
<a name="ln2165">    // Trigger the CompleteDone event to give scripts a chance to act</a>
<a name="ln2166">    // upon the (possibly failed) completion.</a>
<a name="ln2167">    ins_apply_autocmds(EVENT_COMPLETEDONE);</a>
<a name="ln2168">  }</a>
<a name="ln2169"> </a>
<a name="ln2170">  may_trigger_modechanged();</a>
<a name="ln2171"> </a>
<a name="ln2172">  // reset continue_* if we left expansion-mode, if we stay they'll be</a>
<a name="ln2173">  // (re)set properly in ins_complete()</a>
<a name="ln2174">  if (!vim_is_ctrl_x_key(c)) {</a>
<a name="ln2175">    compl_cont_status = 0;</a>
<a name="ln2176">    compl_cont_mode = 0;</a>
<a name="ln2177">  }</a>
<a name="ln2178"> </a>
<a name="ln2179">  return retval;</a>
<a name="ln2180">}</a>
<a name="ln2181"> </a>
<a name="ln2182">/// Fix the redo buffer for the completion leader replacing some of the typed</a>
<a name="ln2183">/// text.  This inserts backspaces and appends the changed text.</a>
<a name="ln2184">/// &quot;ptr&quot; is the known leader text or NUL.</a>
<a name="ln2185">static void ins_compl_fixRedoBufForLeader(char *ptr_arg)</a>
<a name="ln2186">{</a>
<a name="ln2187">  int len;</a>
<a name="ln2188">  char *p;</a>
<a name="ln2189">  char *ptr = ptr_arg;</a>
<a name="ln2190"> </a>
<a name="ln2191">  if (ptr == NULL) {</a>
<a name="ln2192">    if (compl_leader != NULL) {</a>
<a name="ln2193">      ptr = compl_leader;</a>
<a name="ln2194">    } else {</a>
<a name="ln2195">      return;        // nothing to do</a>
<a name="ln2196">    }</a>
<a name="ln2197">  }</a>
<a name="ln2198">  if (compl_orig_text != NULL) {</a>
<a name="ln2199">    p = compl_orig_text;</a>
<a name="ln2200">    for (len = 0; p[len] != NUL &amp;&amp; p[len] == ptr[len]; len++) {}</a>
<a name="ln2201">    if (len &gt; 0) {</a>
<a name="ln2202">      len -= utf_head_off(p, p + len);</a>
<a name="ln2203">    }</a>
<a name="ln2204">    for (p += len; *p != NUL; MB_PTR_ADV(p)) {</a>
<a name="ln2205">      AppendCharToRedobuff(K_BS);</a>
<a name="ln2206">    }</a>
<a name="ln2207">  } else {</a>
<a name="ln2208">    len = 0;</a>
<a name="ln2209">  }</a>
<a name="ln2210">  AppendToRedobuffLit(ptr + len, -1);</a>
<a name="ln2211">}</a>
<a name="ln2212"> </a>
<a name="ln2213">/// Loops through the list of windows, loaded-buffers or non-loaded-buffers</a>
<a name="ln2214">/// (depending on flag) starting from buf and looking for a non-scanned</a>
<a name="ln2215">/// buffer (other than curbuf).  curbuf is special, if it is called with</a>
<a name="ln2216">/// buf=curbuf then it has to be the first call for a given flag/expansion.</a>
<a name="ln2217">///</a>
<a name="ln2218">/// Returns the buffer to scan, if any, otherwise returns curbuf -- Acevedo</a>
<a name="ln2219">static buf_T *ins_compl_next_buf(buf_T *buf, int flag)</a>
<a name="ln2220">{</a>
<a name="ln2221">  static win_T *wp = NULL;</a>
<a name="ln2222"> </a>
<a name="ln2223">  if (flag == 'w') {            // just windows</a>
<a name="ln2224">    if (buf == curbuf || !win_valid(wp)) {</a>
<a name="ln2225">      // first call for this flag/expansion or window was closed</a>
<a name="ln2226">      wp = curwin;</a>
<a name="ln2227">    }</a>
<a name="ln2228">    assert(wp);</a>
<a name="ln2229">    while ((wp = (wp-&gt;w_next != NULL ? wp-&gt;w_next : firstwin)) != curwin</a>
<a name="ln2230">           &amp;&amp; wp-&gt;w_buffer-&gt;b_scanned) {}</a>
<a name="ln2231">    buf = wp-&gt;w_buffer;</a>
<a name="ln2232">  } else {</a>
<a name="ln2233">    // 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'</a>
<a name="ln2234">    // (unlisted buffers)</a>
<a name="ln2235">    // When completing whole lines skip unloaded buffers.</a>
<a name="ln2236">    while ((buf = (buf-&gt;b_next != NULL ? buf-&gt;b_next : firstbuf)) != curbuf</a>
<a name="ln2237">           &amp;&amp; ((flag == 'U'</a>
<a name="ln2238">                ? buf-&gt;b_p_bl</a>
<a name="ln2239">                : (!buf-&gt;b_p_bl</a>
<a name="ln2240">                   || (buf-&gt;b_ml.ml_mfp == NULL) != (flag == 'u')))</a>
<a name="ln2241">               || buf-&gt;b_scanned)) {}</a>
<a name="ln2242">  }</a>
<a name="ln2243">  return buf;</a>
<a name="ln2244">}</a>
<a name="ln2245"> </a>
<a name="ln2246">static Callback cfu_cb;    ///&lt; 'completefunc' callback function</a>
<a name="ln2247">static Callback ofu_cb;    ///&lt; 'omnifunc' callback function</a>
<a name="ln2248">static Callback tsrfu_cb;  ///&lt; 'thesaurusfunc' callback function</a>
<a name="ln2249"> </a>
<a name="ln2250">/// Copy a global callback function to a buffer local callback.</a>
<a name="ln2251">static void copy_global_to_buflocal_cb(Callback *globcb, Callback *bufcb)</a>
<a name="ln2252">{</a>
<a name="ln2253">  callback_free(bufcb);</a>
<a name="ln2254">  if (globcb-&gt;type != kCallbackNone) {</a>
<a name="ln2255">    callback_copy(bufcb, globcb);</a>
<a name="ln2256">  }</a>
<a name="ln2257">}</a>
<a name="ln2258"> </a>
<a name="ln2259">/// Parse the 'completefunc' option value and set the callback function.</a>
<a name="ln2260">/// Invoked when the 'completefunc' option is set. The option value can be a</a>
<a name="ln2261">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2262">/// lambda expression.</a>
<a name="ln2263">const char *did_set_completefunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2264">{</a>
<a name="ln2265">  if (option_set_callback_func(curbuf-&gt;b_p_cfu, &amp;cfu_cb) == FAIL) {</a>
<a name="ln2266">    return e_invarg;</a>
<a name="ln2267">  }</a>
<a name="ln2268"> </a>
<a name="ln2269">  set_buflocal_cfu_callback(curbuf);</a>
<a name="ln2270">  return NULL;</a>
<a name="ln2271">}</a>
<a name="ln2272"> </a>
<a name="ln2273">/// Copy the global 'completefunc' callback function to the buffer-local</a>
<a name="ln2274">/// 'completefunc' callback for &quot;buf&quot;.</a>
<a name="ln2275">void set_buflocal_cfu_callback(buf_T *buf)</a>
<a name="ln2276">{</a>
<a name="ln2277">  copy_global_to_buflocal_cb(&amp;cfu_cb, &amp;buf-&gt;b_cfu_cb);</a>
<a name="ln2278">}</a>
<a name="ln2279"> </a>
<a name="ln2280">/// Parse the 'omnifunc' option value and set the callback function.</a>
<a name="ln2281">/// Invoked when the 'omnifunc' option is set. The option value can be a</a>
<a name="ln2282">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2283">/// lambda expression.</a>
<a name="ln2284">const char *did_set_omnifunc(optset_T *args)</a>
<a name="ln2285">{</a>
<a name="ln2286">  buf_T *buf = (buf_T *)args-&gt;os_buf;</a>
<a name="ln2287">  if (option_set_callback_func(buf-&gt;b_p_ofu, &amp;ofu_cb) == FAIL) {</a>
<a name="ln2288">    return e_invarg;</a>
<a name="ln2289">  }</a>
<a name="ln2290">  set_buflocal_ofu_callback(buf);</a>
<a name="ln2291">  return NULL;</a>
<a name="ln2292">}</a>
<a name="ln2293"> </a>
<a name="ln2294">/// Copy the global 'omnifunc' callback function to the buffer-local 'omnifunc'</a>
<a name="ln2295">/// callback for &quot;buf&quot;.</a>
<a name="ln2296">void set_buflocal_ofu_callback(buf_T *buf)</a>
<a name="ln2297">{</a>
<a name="ln2298">  copy_global_to_buflocal_cb(&amp;ofu_cb, &amp;buf-&gt;b_ofu_cb);</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">/// Parse the 'thesaurusfunc' option value and set the callback function.</a>
<a name="ln2302">/// Invoked when the 'thesaurusfunc' option is set. The option value can be a</a>
<a name="ln2303">/// name of a function (string), or function(&lt;name&gt;) or funcref(&lt;name&gt;) or a</a>
<a name="ln2304">/// lambda expression.</a>
<a name="ln2305">const char *did_set_thesaurusfunc(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln2306">{</a>
<a name="ln2307">  int retval;</a>
<a name="ln2308"> </a>
<a name="ln2309">  if (*curbuf-&gt;b_p_tsrfu != NUL) {</a>
<a name="ln2310">    // buffer-local option set</a>
<a name="ln2311">    retval = option_set_callback_func(curbuf-&gt;b_p_tsrfu, &amp;curbuf-&gt;b_tsrfu_cb);</a>
<a name="ln2312">  } else {</a>
<a name="ln2313">    // global option set</a>
<a name="ln2314">    retval = option_set_callback_func(p_tsrfu, &amp;tsrfu_cb);</a>
<a name="ln2315">  }</a>
<a name="ln2316"> </a>
<a name="ln2317">  return retval == FAIL ? e_invarg : NULL;</a>
<a name="ln2318">}</a>
<a name="ln2319"> </a>
<a name="ln2320">/// Mark the global 'completefunc' 'omnifunc' and 'thesaurusfunc' callbacks with</a>
<a name="ln2321">/// &quot;copyID&quot; so that they are not garbage collected.</a>
<a name="ln2322">bool set_ref_in_insexpand_funcs(int copyID)</a>
<a name="ln2323">{</a>
<a name="ln2324">  bool abort = set_ref_in_callback(&amp;cfu_cb, copyID, NULL, NULL);</a>
<a name="ln2325">  abort = abort || set_ref_in_callback(&amp;ofu_cb, copyID, NULL, NULL);</a>
<a name="ln2326">  abort = abort || set_ref_in_callback(&amp;tsrfu_cb, copyID, NULL, NULL);</a>
<a name="ln2327"> </a>
<a name="ln2328">  return abort;</a>
<a name="ln2329">}</a>
<a name="ln2330"> </a>
<a name="ln2331">/// Get the user-defined completion function name for completion &quot;type&quot;</a>
<a name="ln2332">static char *get_complete_funcname(int type)</a>
<a name="ln2333">{</a>
<a name="ln2334">  switch (type) {</a>
<a name="ln2335">  case CTRL_X_FUNCTION:</a>
<a name="ln2336">    return curbuf-&gt;b_p_cfu;</a>
<a name="ln2337">  case CTRL_X_OMNI:</a>
<a name="ln2338">    return curbuf-&gt;b_p_ofu;</a>
<a name="ln2339">  case CTRL_X_THESAURUS:</a>
<a name="ln2340">    return *curbuf-&gt;b_p_tsrfu == NUL ? p_tsrfu : curbuf-&gt;b_p_tsrfu;</a>
<a name="ln2341">  default:</a>
<a name="ln2342">    return &quot;&quot;;</a>
<a name="ln2343">  }</a>
<a name="ln2344">}</a>
<a name="ln2345"> </a>
<a name="ln2346">/// Get the callback to use for insert mode completion.</a>
<a name="ln2347">static Callback *get_insert_callback(int type)</a>
<a name="ln2348">{</a>
<a name="ln2349">  if (type == CTRL_X_FUNCTION) {</a>
<a name="ln2350">    return &amp;curbuf-&gt;b_cfu_cb;</a>
<a name="ln2351">  }</a>
<a name="ln2352">  if (type == CTRL_X_OMNI) {</a>
<a name="ln2353">    return &amp;curbuf-&gt;b_ofu_cb;</a>
<a name="ln2354">  }</a>
<a name="ln2355">  // CTRL_X_THESAURUS</a>
<a name="ln2356">  return (*curbuf-&gt;b_p_tsrfu != NUL) ? &amp;curbuf-&gt;b_tsrfu_cb : &amp;tsrfu_cb;</a>
<a name="ln2357">}</a>
<a name="ln2358"> </a>
<a name="ln2359">/// Execute user defined complete function 'completefunc', 'omnifunc' or</a>
<a name="ln2360">/// 'thesaurusfunc', and get matches in &quot;matches&quot;.</a>
<a name="ln2361">///</a>
<a name="ln2362">/// @param type  either CTRL_X_OMNI or CTRL_X_FUNCTION or CTRL_X_THESAURUS</a>
<a name="ln2363">static void expand_by_function(int type, char *base)</a>
<a name="ln2364">{</a>
<a name="ln2365">  list_T *matchlist = NULL;</a>
<a name="ln2366">  dict_T *matchdict = NULL;</a>
<a name="ln2367">  char *funcname;</a>
<a name="ln2368">  pos_T pos;</a>
<a name="ln2369">  typval_T rettv;</a>
<a name="ln2370">  const int save_State = State;</a>
<a name="ln2371"> </a>
<a name="ln2372">  assert(curbuf != NULL);</a>
<a name="ln2373">  funcname = get_complete_funcname(type);</a>
<a name="ln2374">  if (*funcname == NUL) {</a>
<a name="ln2375">    return;</a>
<a name="ln2376">  }</a>
<a name="ln2377"> </a>
<a name="ln2378">  // Call 'completefunc' to obtain the list of matches.</a>
<a name="ln2379">  typval_T args[3];</a>
<a name="ln2380">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln2381">  args[1].v_type = VAR_STRING;</a>
<a name="ln2382">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln2383">  args[0].vval.v_number = 0;</a>
<a name="ln2384">  args[1].vval.v_string = base != NULL ? base : &quot;&quot;;</a>
<a name="ln2385"> </a>
<a name="ln2386">  pos = curwin-&gt;w_cursor;</a>
<a name="ln2387">  // Lock the text to avoid weird things from happening.  Also disallow</a>
<a name="ln2388">  // switching to another window, it should not be needed and may end up in</a>
<a name="ln2389">  // Insert mode in another buffer.</a>
<a name="ln2390">  textlock++;</a>
<a name="ln2391"> </a>
<a name="ln2392">  Callback *cb = get_insert_callback(type);</a>
<a name="ln2393"> </a>
<a name="ln2394">  // Call a function, which returns a list or dict.</a>
<a name="ln2395">  if (callback_call(cb, 2, args, &amp;rettv)) {</a>
<a name="ln2396">    switch (rettv.v_type) {</a>
<a name="ln2397">    case VAR_LIST:</a>
<a name="ln2398">      matchlist = rettv.vval.v_list;</a>
<a name="ln2399">      break;</a>
<a name="ln2400">    case VAR_DICT:</a>
<a name="ln2401">      matchdict = rettv.vval.v_dict;</a>
<a name="ln2402">      break;</a>
<a name="ln2403">    case VAR_SPECIAL:</a>
<a name="ln2404">      FALLTHROUGH;</a>
<a name="ln2405">    default:</a>
<a name="ln2406">      // TODO(brammool): Give error message?</a>
<a name="ln2407">      tv_clear(&amp;rettv);</a>
<a name="ln2408">      break;</a>
<a name="ln2409">    }</a>
<a name="ln2410">  }</a>
<a name="ln2411">  textlock--;</a>
<a name="ln2412"> </a>
<a name="ln2413">  curwin-&gt;w_cursor = pos;       // restore the cursor position</a>
<a name="ln2414">  validate_cursor();</a>
<a name="ln2415">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln2416">    emsg(_(e_compldel));</a>
<a name="ln2417">    goto theend;</a>
<a name="ln2418">  }</a>
<a name="ln2419"> </a>
<a name="ln2420">  if (matchlist != NULL) {</a>
<a name="ln2421">    ins_compl_add_list(matchlist);</a>
<a name="ln2422">  } else if (matchdict != NULL) {</a>
<a name="ln2423">    ins_compl_add_dict(matchdict);</a>
<a name="ln2424">  }</a>
<a name="ln2425"> </a>
<a name="ln2426">theend:</a>
<a name="ln2427">  // Restore State, it might have been changed.</a>
<a name="ln2428">  State = save_State;</a>
<a name="ln2429"> </a>
<a name="ln2430">  if (matchdict != NULL) {</a>
<a name="ln2431">    tv_dict_unref(matchdict);</a>
<a name="ln2432">  }</a>
<a name="ln2433">  if (matchlist != NULL) {</a>
<a name="ln2434">    tv_list_unref(matchlist);</a>
<a name="ln2435">  }</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">/// Add a match to the list of matches from Vimscript object</a>
<a name="ln2439">///</a>
<a name="ln2440">/// @param[in]  tv  Object to get matches from.</a>
<a name="ln2441">/// @param[in]  dir  Completion direction.</a>
<a name="ln2442">/// @param[in]  fast  use fast_breakcheck() instead of os_breakcheck().</a>
<a name="ln2443">///</a>
<a name="ln2444">/// @return NOTDONE if the given string is already in the list of completions,</a>
<a name="ln2445">///         otherwise it is added to the list and  OK is returned. FAIL will be</a>
<a name="ln2446">///         returned in case of error.</a>
<a name="ln2447">static int ins_compl_add_tv(typval_T *const tv, const Direction dir, bool fast)</a>
<a name="ln2448">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2449">{</a>
<a name="ln2450">  const char *word;</a>
<a name="ln2451">  bool dup = false;</a>
<a name="ln2452">  bool empty = false;</a>
<a name="ln2453">  int flags = fast ? CP_FAST : 0;</a>
<a name="ln2454">  char *(cptext[CPT_COUNT]);</a>
<a name="ln2455">  typval_T user_data;</a>
<a name="ln2456"> </a>
<a name="ln2457">  user_data.v_type = VAR_UNKNOWN;</a>
<a name="ln2458">  if (tv-&gt;v_type == VAR_DICT &amp;&amp; tv-&gt;vval.v_dict != NULL) {</a>
<a name="ln2459">    word = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;word&quot;, false);</a>
<a name="ln2460">    cptext[CPT_ABBR] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;abbr&quot;, true);</a>
<a name="ln2461">    cptext[CPT_MENU] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;menu&quot;, true);</a>
<a name="ln2462">    cptext[CPT_KIND] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;kind&quot;, true);</a>
<a name="ln2463">    cptext[CPT_INFO] = tv_dict_get_string(tv-&gt;vval.v_dict, &quot;info&quot;, true);</a>
<a name="ln2464">    tv_dict_get_tv(tv-&gt;vval.v_dict, &quot;user_data&quot;, &amp;user_data);</a>
<a name="ln2465"> </a>
<a name="ln2466">    if (tv_dict_get_number(tv-&gt;vval.v_dict, &quot;icase&quot;)) {</a>
<a name="ln2467">      flags |= CP_ICASE;</a>
<a name="ln2468">    }</a>
<a name="ln2469">    dup = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;dup&quot;);</a>
<a name="ln2470">    empty = (bool)tv_dict_get_number(tv-&gt;vval.v_dict, &quot;empty&quot;);</a>
<a name="ln2471">    if (tv_dict_get_string(tv-&gt;vval.v_dict, &quot;equal&quot;, false) != NULL</a>
<a name="ln2472">        &amp;&amp; tv_dict_get_number(tv-&gt;vval.v_dict, &quot;equal&quot;)) {</a>
<a name="ln2473">      flags |= CP_EQUAL;</a>
<a name="ln2474">    }</a>
<a name="ln2475">  } else {</a>
<a name="ln2476">    word = tv_get_string_chk(tv);</a>
<a name="ln2477">    CLEAR_FIELD(cptext);</a>
<a name="ln2478">  }</a>
<a name="ln2479">  if (word == NULL || (!empty &amp;&amp; *word == NUL)) {</a>
<a name="ln2480">    for (size_t i = 0; i &lt; CPT_COUNT; i++) {</a>
<a name="ln2481">      xfree(cptext[i]);</a>
<a name="ln2482">    }</a>
<a name="ln2483">    tv_clear(&amp;user_data);</a>
<a name="ln2484">    return FAIL;</a>
<a name="ln2485">  }</a>
<a name="ln2486">  int status = ins_compl_add((char *)word, -1, NULL, cptext, true,</a>
<a name="ln2487">                             &amp;user_data, dir, flags, dup);</a>
<a name="ln2488">  if (status != OK) {</a>
<a name="ln2489">    tv_clear(&amp;user_data);</a>
<a name="ln2490">  }</a>
<a name="ln2491">  return status;</a>
<a name="ln2492">}</a>
<a name="ln2493"> </a>
<a name="ln2494">/// Add completions from a list.</a>
<a name="ln2495">static void ins_compl_add_list(list_T *const list)</a>
<a name="ln2496">{</a>
<a name="ln2497">  Direction dir = compl_direction;</a>
<a name="ln2498"> </a>
<a name="ln2499">  // Go through the List with matches and add each of them.</a>
<a name="ln2500">  TV_LIST_ITER(list, li, {</a>
<a name="ln2501">    if (ins_compl_add_tv(TV_LIST_ITEM_TV(li), dir, true) == OK) {</a>
<a name="ln2502">      // If dir was BACKWARD then honor it just once.</a>
<a name="ln2503">      dir = FORWARD;</a>
<a name="ln2504">    } else if (did_emsg) {</a>
<a name="ln2505">      break;</a>
<a name="ln2506">    }</a>
<a name="ln2507">  });</a>
<a name="ln2508">}</a>
<a name="ln2509"> </a>
<a name="ln2510">/// Add completions from a dict.</a>
<a name="ln2511">static void ins_compl_add_dict(dict_T *dict)</a>
<a name="ln2512">{</a>
<a name="ln2513">  dictitem_T *di_refresh;</a>
<a name="ln2514">  dictitem_T *di_words;</a>
<a name="ln2515"> </a>
<a name="ln2516">  // Check for optional &quot;refresh&quot; item.</a>
<a name="ln2517">  compl_opt_refresh_always = false;</a>
<a name="ln2518">  di_refresh = tv_dict_find(dict, S_LEN(&quot;refresh&quot;));</a>
<a name="ln2519">  if (di_refresh != NULL &amp;&amp; di_refresh-&gt;di_tv.v_type == VAR_STRING) {</a>
<a name="ln2520">    const char *v = di_refresh-&gt;di_tv.vval.v_string;</a>
<a name="ln2521"> </a>
<a name="ln2522">    if (v != NULL &amp;&amp; strcmp(v, &quot;always&quot;) == 0) {</a>
<a name="ln2523">      compl_opt_refresh_always = true;</a>
<a name="ln2524">    }</a>
<a name="ln2525">  }</a>
<a name="ln2526"> </a>
<a name="ln2527">  // Add completions from a &quot;words&quot; list.</a>
<a name="ln2528">  di_words = tv_dict_find(dict, S_LEN(&quot;words&quot;));</a>
<a name="ln2529">  if (di_words != NULL &amp;&amp; di_words-&gt;di_tv.v_type == VAR_LIST) {</a>
<a name="ln2530">    ins_compl_add_list(di_words-&gt;di_tv.vval.v_list);</a>
<a name="ln2531">  }</a>
<a name="ln2532">}</a>
<a name="ln2533"> </a>
<a name="ln2534">/// Start completion for the complete() function.</a>
<a name="ln2535">///</a>
<a name="ln2536">/// @param startcol  where the matched text starts (1 is first column).</a>
<a name="ln2537">/// @param list      the list of matches.</a>
<a name="ln2538">static void set_completion(colnr_T startcol, list_T *list)</a>
<a name="ln2539">{</a>
<a name="ln2540">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln2541"> </a>
<a name="ln2542">  // If already doing completions stop it.</a>
<a name="ln2543">  if (ctrl_x_mode_not_default()) {</a>
<a name="ln2544">    ins_compl_prep(' ');</a>
<a name="ln2545">  }</a>
<a name="ln2546">  ins_compl_clear();</a>
<a name="ln2547">  ins_compl_free();</a>
<a name="ln2548">  compl_get_longest = compl_longest;</a>
<a name="ln2549"> </a>
<a name="ln2550">  compl_direction = FORWARD;</a>
<a name="ln2551">  if (startcol &gt; curwin-&gt;w_cursor.col) {</a>
<a name="ln2552">    startcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2553">  }</a>
<a name="ln2554">  compl_col = startcol;</a>
<a name="ln2555">  compl_length = (int)curwin-&gt;w_cursor.col - (int)startcol;</a>
<a name="ln2556">  // compl_pattern doesn't need to be set</a>
<a name="ln2557">  compl_orig_text = xstrnsave(get_cursor_line_ptr() + compl_col,</a>
<a name="ln2558">                              (size_t)compl_length);</a>
<a name="ln2559">  if (p_ic) {</a>
<a name="ln2560">    flags |= CP_ICASE;</a>
<a name="ln2561">  }</a>
<a name="ln2562">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln2563">                    flags | CP_FAST, false) != OK) {</a>
<a name="ln2564">    return;</a>
<a name="ln2565">  }</a>
<a name="ln2566"> </a>
<a name="ln2567">  ctrl_x_mode = CTRL_X_EVAL;</a>
<a name="ln2568"> </a>
<a name="ln2569">  ins_compl_add_list(list);</a>
<a name="ln2570">  compl_matches = ins_compl_make_cyclic();</a>
<a name="ln2571">  compl_started = true;</a>
<a name="ln2572">  compl_used_match = true;</a>
<a name="ln2573">  compl_cont_status = 0;</a>
<a name="ln2574">  int save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln2575">  int save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln2576"> </a>
<a name="ln2577">  compl_curr_match = compl_first_match;</a>
<a name="ln2578">  bool no_select = compl_no_select || compl_longest;</a>
<a name="ln2579">  if (compl_no_insert || no_select) {</a>
<a name="ln2580">    ins_complete(K_DOWN, false);</a>
<a name="ln2581">    if (no_select) {</a>
<a name="ln2582">      ins_complete(K_UP, false);</a>
<a name="ln2583">    }</a>
<a name="ln2584">  } else {</a>
<a name="ln2585">    ins_complete(Ctrl_N, false);</a>
<a name="ln2586">  }</a>
<a name="ln2587">  compl_enter_selects = compl_no_insert;</a>
<a name="ln2588"> </a>
<a name="ln2589">  // Lazily show the popup menu, unless we got interrupted.</a>
<a name="ln2590">  if (!compl_interrupted) {</a>
<a name="ln2591">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln2592">  }</a>
<a name="ln2593"> </a>
<a name="ln2594">  may_trigger_modechanged();</a>
<a name="ln2595">  ui_flush();</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">/// &quot;complete()&quot; function</a>
<a name="ln2599">void f_complete(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2600">{</a>
<a name="ln2601">  if ((State &amp; MODE_INSERT) == 0) {</a>
<a name="ln2602">    emsg(_(&quot;E785: complete() can only be used in Insert mode&quot;));</a>
<a name="ln2603">    return;</a>
<a name="ln2604">  }</a>
<a name="ln2605"> </a>
<a name="ln2606">  // Check for undo allowed here, because if something was already inserted</a>
<a name="ln2607">  // the line was already saved for undo and this check isn't done.</a>
<a name="ln2608">  if (!undo_allowed(curbuf)) {</a>
<a name="ln2609">    return;</a>
<a name="ln2610">  }</a>
<a name="ln2611"> </a>
<a name="ln2612">  if (argvars[1].v_type != VAR_LIST) {</a>
<a name="ln2613">    emsg(_(e_invarg));</a>
<a name="ln2614">  } else {</a>
<a name="ln2615">    const colnr_T startcol = (colnr_T)tv_get_number_chk(&amp;argvars[0], NULL);</a>
<a name="ln2616">    if (startcol &gt; 0) {</a>
<a name="ln2617">      set_completion(startcol - 1, argvars[1].vval.v_list);</a>
<a name="ln2618">    }</a>
<a name="ln2619">  }</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">/// &quot;complete_add()&quot; function</a>
<a name="ln2623">void f_complete_add(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2624">{</a>
<a name="ln2625">  rettv-&gt;vval.v_number = ins_compl_add_tv(&amp;argvars[0], 0, false);</a>
<a name="ln2626">}</a>
<a name="ln2627"> </a>
<a name="ln2628">/// &quot;complete_check()&quot; function</a>
<a name="ln2629">void f_complete_check(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2630">{</a>
<a name="ln2631">  int saved = RedrawingDisabled;</a>
<a name="ln2632"> </a>
<a name="ln2633">  RedrawingDisabled = 0;</a>
<a name="ln2634">  ins_compl_check_keys(0, true);</a>
<a name="ln2635">  rettv-&gt;vval.v_number = ins_compl_interrupted();</a>
<a name="ln2636">  RedrawingDisabled = saved;</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639">/// Return Insert completion mode name string</a>
<a name="ln2640">static char *ins_compl_mode(void)</a>
<a name="ln2641">{</a>
<a name="ln2642">  if (ctrl_x_mode_not_defined_yet() || ctrl_x_mode_scroll() || compl_started) {</a>
<a name="ln2643">    return ctrl_x_mode_names[ctrl_x_mode &amp; ~CTRL_X_WANT_IDENT];</a>
<a name="ln2644">  }</a>
<a name="ln2645">  return &quot;&quot;;</a>
<a name="ln2646">}</a>
<a name="ln2647"> </a>
<a name="ln2648">/// Assign the sequence number to all the completion matches which don't have</a>
<a name="ln2649">/// one assigned yet.</a>
<a name="ln2650">static void ins_compl_update_sequence_numbers(void)</a>
<a name="ln2651">{</a>
<a name="ln2652">  int number = 0;</a>
<a name="ln2653">  compl_T *match;</a>
<a name="ln2654"> </a>
<a name="ln2655">  if (compl_dir_forward()) {</a>
<a name="ln2656">    // Search backwards for the first valid (!= -1) number.</a>
<a name="ln2657">    // This should normally succeed already at the first loop</a>
<a name="ln2658">    // cycle, so it's fast!</a>
<a name="ln2659">    for (match = compl_curr_match-&gt;cp_prev;</a>
<a name="ln2660">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_prev) {</a>
<a name="ln2661">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2662">        number = match-&gt;cp_number;</a>
<a name="ln2663">        break;</a>
<a name="ln2664">      }</a>
<a name="ln2665">    }</a>
<a name="ln2666">    if (match != NULL) {</a>
<a name="ln2667">      // go up and assign all numbers which are not assigned yet</a>
<a name="ln2668">      for (match = match-&gt;cp_next;</a>
<a name="ln2669">           match != NULL &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2670">           match = match-&gt;cp_next) {</a>
<a name="ln2671">        match-&gt;cp_number = ++number;</a>
<a name="ln2672">      }</a>
<a name="ln2673">    }</a>
<a name="ln2674">  } else {  // BACKWARD</a>
<a name="ln2675">    assert(compl_direction == BACKWARD);</a>
<a name="ln2676">    // Search forwards (upwards) for the first valid (!= -1)</a>
<a name="ln2677">    // number.  This should normally succeed already at the</a>
<a name="ln2678">    // first loop cycle, so it's fast!</a>
<a name="ln2679">    for (match = compl_curr_match-&gt;cp_next;</a>
<a name="ln2680">         match != NULL &amp;&amp; !is_first_match(match); match = match-&gt;cp_next) {</a>
<a name="ln2681">      if (match-&gt;cp_number != -1) {</a>
<a name="ln2682">        number = match-&gt;cp_number;</a>
<a name="ln2683">        break;</a>
<a name="ln2684">      }</a>
<a name="ln2685">    }</a>
<a name="ln2686">    if (match != NULL) {</a>
<a name="ln2687">      // go down and assign all numbers which are not assigned yet</a>
<a name="ln2688">      for (match = match-&gt;cp_prev;</a>
<a name="ln2689">           match &amp;&amp; match-&gt;cp_number == -1;</a>
<a name="ln2690">           match = match-&gt;cp_prev) {</a>
<a name="ln2691">        match-&gt;cp_number = ++number;</a>
<a name="ln2692">      }</a>
<a name="ln2693">    }</a>
<a name="ln2694">  }</a>
<a name="ln2695">}</a>
<a name="ln2696"> </a>
<a name="ln2697">/// Get complete information</a>
<a name="ln2698">static void get_complete_info(list_T *what_list, dict_T *retdict)</a>
<a name="ln2699">{</a>
<a name="ln2700">#define CI_WHAT_MODE            0x01</a>
<a name="ln2701">#define CI_WHAT_PUM_VISIBLE     0x02</a>
<a name="ln2702">#define CI_WHAT_ITEMS           0x04</a>
<a name="ln2703">#define CI_WHAT_SELECTED        0x08</a>
<a name="ln2704">#define CI_WHAT_INSERTED        0x10</a>
<a name="ln2705">#define CI_WHAT_ALL             0xff</a>
<a name="ln2706">  int what_flag;</a>
<a name="ln2707"> </a>
<a name="ln2708">  if (what_list == NULL) {</a>
<a name="ln2709">    what_flag = CI_WHAT_ALL;</a>
<a name="ln2710">  } else {</a>
<a name="ln2711">    what_flag = 0;</a>
<a name="ln2712">    for (listitem_T *item = tv_list_first(what_list)</a>
<a name="ln2713">         ; item != NULL</a>
<a name="ln2714">         ; item = TV_LIST_ITEM_NEXT(what_list, item)) {</a>
<a name="ln2715">      const char *what = tv_get_string(TV_LIST_ITEM_TV(item));</a>
<a name="ln2716"> </a>
<a name="ln2717">      if (strcmp(what, &quot;mode&quot;) == 0) {</a>
<a name="ln2718">        what_flag |= CI_WHAT_MODE;</a>
<a name="ln2719">      } else if (strcmp(what, &quot;pum_visible&quot;) == 0) {</a>
<a name="ln2720">        what_flag |= CI_WHAT_PUM_VISIBLE;</a>
<a name="ln2721">      } else if (strcmp(what, &quot;items&quot;) == 0) {</a>
<a name="ln2722">        what_flag |= CI_WHAT_ITEMS;</a>
<a name="ln2723">      } else if (strcmp(what, &quot;selected&quot;) == 0) {</a>
<a name="ln2724">        what_flag |= CI_WHAT_SELECTED;</a>
<a name="ln2725">      } else if (strcmp(what, &quot;inserted&quot;) == 0) {</a>
<a name="ln2726">        what_flag |= CI_WHAT_INSERTED;</a>
<a name="ln2727">      }</a>
<a name="ln2728">    }</a>
<a name="ln2729">  }</a>
<a name="ln2730"> </a>
<a name="ln2731">  int ret = OK;</a>
<a name="ln2732">  if (what_flag &amp; CI_WHAT_MODE) {</a>
<a name="ln2733">    ret = tv_dict_add_str(retdict, S_LEN(&quot;mode&quot;), ins_compl_mode());</a>
<a name="ln2734">  }</a>
<a name="ln2735"> </a>
<a name="ln2736">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_PUM_VISIBLE)) {</a>
<a name="ln2737">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;pum_visible&quot;), pum_visible());</a>
<a name="ln2738">  }</a>
<a name="ln2739"> </a>
<a name="ln2740">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_ITEMS)) {</a>
<a name="ln2741">    list_T *li = tv_list_alloc(get_compl_len());</a>
<a name="ln2742"> </a>
<a name="ln2743">    ret = tv_dict_add_list(retdict, S_LEN(&quot;items&quot;), li);</a>
<a name="ln2744">    if (ret == OK &amp;&amp; compl_first_match != NULL) {</a>
<a name="ln2745">      compl_T *match = compl_first_match;</a>
<a name="ln2746">      do {</a>
<a name="ln2747">        if (!match_at_original_text(match)) {</a>
<a name="ln2748">          dict_T *di = tv_dict_alloc();</a>
<a name="ln2749"> </a>
<a name="ln2750">          tv_list_append_dict(li, di);</a>
<a name="ln2751">          tv_dict_add_str(di, S_LEN(&quot;word&quot;), EMPTY_IF_NULL(match-&gt;cp_str));</a>
<a name="ln2752">          tv_dict_add_str(di, S_LEN(&quot;abbr&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_ABBR]));</a>
<a name="ln2753">          tv_dict_add_str(di, S_LEN(&quot;menu&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_MENU]));</a>
<a name="ln2754">          tv_dict_add_str(di, S_LEN(&quot;kind&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_KIND]));</a>
<a name="ln2755">          tv_dict_add_str(di, S_LEN(&quot;info&quot;), EMPTY_IF_NULL(match-&gt;cp_text[CPT_INFO]));</a>
<a name="ln2756">          if (match-&gt;cp_user_data.v_type == VAR_UNKNOWN) {</a>
<a name="ln2757">            // Add an empty string for backwards compatibility</a>
<a name="ln2758">            tv_dict_add_str(di, S_LEN(&quot;user_data&quot;), &quot;&quot;);</a>
<a name="ln2759">          } else {</a>
<a name="ln2760">            tv_dict_add_tv(di, S_LEN(&quot;user_data&quot;), &amp;match-&gt;cp_user_data);</a>
<a name="ln2761">          }</a>
<a name="ln2762">        }</a>
<a name="ln2763">        match = match-&gt;cp_next;</a>
<a name="ln2764">      } while (match != NULL &amp;&amp; !is_first_match(match));</a>
<a name="ln2765">    }</a>
<a name="ln2766">  }</a>
<a name="ln2767"> </a>
<a name="ln2768">  if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_SELECTED)) {</a>
<a name="ln2769">    if (compl_curr_match != NULL &amp;&amp; compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln2770">      ins_compl_update_sequence_numbers();</a>
<a name="ln2771">    }</a>
<a name="ln2772">    ret = tv_dict_add_nr(retdict, S_LEN(&quot;selected&quot;),</a>
<a name="ln2773">                         (compl_curr_match != NULL)</a>
<a name="ln2774">                         ? compl_curr_match-&gt;cp_number - 1 : -1);</a>
<a name="ln2775">  }</a>
<a name="ln2776"> </a>
<a name="ln2777">  (void)ret;</a>
<a name="ln2778">  // TODO(vim):</a>
<a name="ln2779">  // if (ret == OK &amp;&amp; (what_flag &amp; CI_WHAT_INSERTED))</a>
<a name="ln2780">}</a>
<a name="ln2781"> </a>
<a name="ln2782">/// &quot;complete_info()&quot; function</a>
<a name="ln2783">void f_complete_info(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln2784">{</a>
<a name="ln2785">  tv_dict_alloc_ret(rettv);</a>
<a name="ln2786"> </a>
<a name="ln2787">  list_T *what_list = NULL;</a>
<a name="ln2788"> </a>
<a name="ln2789">  if (argvars[0].v_type != VAR_UNKNOWN) {</a>
<a name="ln2790">    if (argvars[0].v_type != VAR_LIST) {</a>
<a name="ln2791">      emsg(_(e_listreq));</a>
<a name="ln2792">      return;</a>
<a name="ln2793">    }</a>
<a name="ln2794">    what_list = argvars[0].vval.v_list;</a>
<a name="ln2795">  }</a>
<a name="ln2796">  get_complete_info(what_list, rettv-&gt;vval.v_dict);</a>
<a name="ln2797">}</a>
<a name="ln2798"> </a>
<a name="ln2799">/// Returns true when using a user-defined function for thesaurus completion.</a>
<a name="ln2800">static bool thesaurus_func_complete(int type)</a>
<a name="ln2801">{</a>
<a name="ln2802">  return type == CTRL_X_THESAURUS</a>
<a name="ln2803">         &amp;&amp; (*curbuf-&gt;b_p_tsrfu != NUL || *p_tsrfu != NUL);</a>
<a name="ln2804">}</a>
<a name="ln2805"> </a>
<a name="ln2806">/// Return value of process_next_cpt_value()</a>
<a name="ln2807">enum {</a>
<a name="ln2808">  INS_COMPL_CPT_OK = 1,</a>
<a name="ln2809">  INS_COMPL_CPT_CONT,</a>
<a name="ln2810">  INS_COMPL_CPT_END,</a>
<a name="ln2811">};</a>
<a name="ln2812"> </a>
<a name="ln2813">/// Process the next 'complete' option value in st-&gt;e_cpt.</a>
<a name="ln2814">///</a>
<a name="ln2815">/// If successful, the arguments are set as below:</a>
<a name="ln2816">///   st-&gt;cpt - pointer to the next option value in &quot;st-&gt;cpt&quot;</a>
<a name="ln2817">///   compl_type_arg - type of insert mode completion to use</a>
<a name="ln2818">///   st-&gt;found_all - all matches of this type are found</a>
<a name="ln2819">///   st-&gt;ins_buf - search for completions in this buffer</a>
<a name="ln2820">///   st-&gt;first_match_pos - position of the first completion match</a>
<a name="ln2821">///   st-&gt;last_match_pos - position of the last completion match</a>
<a name="ln2822">///   st-&gt;set_match_pos - true if the first match position should be saved to</a>
<a name="ln2823">///                       avoid loops after the search wraps around.</a>
<a name="ln2824">///   st-&gt;dict - name of the dictionary or thesaurus file to search</a>
<a name="ln2825">///   st-&gt;dict_f - flag specifying whether &quot;dict&quot; is an exact file name or not</a>
<a name="ln2826">///</a>
<a name="ln2827">/// @return  INS_COMPL_CPT_OK if the next value is processed successfully.</a>
<a name="ln2828">///          INS_COMPL_CPT_CONT to skip the current completion source matching</a>
<a name="ln2829">///          the &quot;st-&gt;e_cpt&quot; option value and process the next matching source.</a>
<a name="ln2830">///          INS_COMPL_CPT_END if all the values in &quot;st-&gt;e_cpt&quot; are processed.</a>
<a name="ln2831">static int process_next_cpt_value(ins_compl_next_state_T *st, int *compl_type_arg,</a>
<a name="ln2832">                                  pos_T *start_match_pos)</a>
<a name="ln2833">{</a>
<a name="ln2834">  int compl_type = -1;</a>
<a name="ln2835">  int status = INS_COMPL_CPT_OK;</a>
<a name="ln2836"> </a>
<a name="ln2837">  st-&gt;found_all = false;</a>
<a name="ln2838"> </a>
<a name="ln2839">  while (*st-&gt;e_cpt == ',' || *st-&gt;e_cpt == ' ') {</a>
<a name="ln2840">    st-&gt;e_cpt++;</a>
<a name="ln2841">  }</a>
<a name="ln2842"> </a>
<a name="ln2843">  if (*st-&gt;e_cpt == '.' &amp;&amp; !curbuf-&gt;b_scanned) {</a>
<a name="ln2844">    st-&gt;ins_buf = curbuf;</a>
<a name="ln2845">    st-&gt;first_match_pos = *start_match_pos;</a>
<a name="ln2846">    // Move the cursor back one character so that ^N can match the</a>
<a name="ln2847">    // word immediately after the cursor.</a>
<a name="ln2848">    if (ctrl_x_mode_normal() &amp;&amp; dec(&amp;st-&gt;first_match_pos) &lt; 0) {</a>
<a name="ln2849">      // Move the cursor to after the last character in the</a>
<a name="ln2850">      // buffer, so that word at start of buffer is found</a>
<a name="ln2851">      // correctly.</a>
<a name="ln2852">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count;</a>
<a name="ln2853">      st-&gt;first_match_pos.col = (colnr_T)strlen(ml_get(st-&gt;first_match_pos.lnum));</a>
<a name="ln2854">    }</a>
<a name="ln2855">    st-&gt;last_match_pos = st-&gt;first_match_pos;</a>
<a name="ln2856">    compl_type = 0;</a>
<a name="ln2857"> </a>
<a name="ln2858">    // Remember the first match so that the loop stops when we</a>
<a name="ln2859">    // wrap and come back there a second time.</a>
<a name="ln2860">    st-&gt;set_match_pos = true;</a>
<a name="ln2861">  } else if (vim_strchr(&quot;buwU&quot;, (uint8_t)(*st-&gt;e_cpt)) != NULL</a>
<a name="ln2862">             &amp;&amp; (st-&gt;ins_buf = ins_compl_next_buf(st-&gt;ins_buf, *st-&gt;e_cpt)) != curbuf) {</a>
<a name="ln2863">    // Scan a buffer, but not the current one.</a>
<a name="ln2864">    if (st-&gt;ins_buf-&gt;b_ml.ml_mfp != NULL) {  // loaded buffer</a>
<a name="ln2865">      compl_started = true;</a>
<a name="ln2866">      st-&gt;first_match_pos.col = st-&gt;last_match_pos.col = 0;</a>
<a name="ln2867">      st-&gt;first_match_pos.lnum = st-&gt;ins_buf-&gt;b_ml.ml_line_count + 1;</a>
<a name="ln2868">      st-&gt;last_match_pos.lnum = 0;</a>
<a name="ln2869">      compl_type = 0;</a>
<a name="ln2870">    } else {  // unloaded buffer, scan like dictionary</a>
<a name="ln2871">      st-&gt;found_all = true;</a>
<a name="ln2872">      if (st-&gt;ins_buf-&gt;b_fname == NULL) {</a>
<a name="ln2873">        status = INS_COMPL_CPT_CONT;</a>
<a name="ln2874">        goto done;</a>
<a name="ln2875">      }</a>
<a name="ln2876">      compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2877">      st-&gt;dict = st-&gt;ins_buf-&gt;b_fname;</a>
<a name="ln2878">      st-&gt;dict_f = DICT_EXACT;</a>
<a name="ln2879">    }</a>
<a name="ln2880">    if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2881">      msg_hist_off = true;  // reset in msg_trunc_attr()</a>
<a name="ln2882">      vim_snprintf(IObuff, IOSIZE, _(&quot;Scanning: %s&quot;),</a>
<a name="ln2883">                   st-&gt;ins_buf-&gt;b_fname == NULL</a>
<a name="ln2884">                   ? buf_spname(st-&gt;ins_buf)</a>
<a name="ln2885">                   : st-&gt;ins_buf-&gt;b_sfname == NULL</a>
<a name="ln2886">                   ? st-&gt;ins_buf-&gt;b_fname</a>
<a name="ln2887">                   : st-&gt;ins_buf-&gt;b_sfname);</a>
<a name="ln2888">      (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2889">    }</a>
<a name="ln2890">  } else if (*st-&gt;e_cpt == NUL) {</a>
<a name="ln2891">    status = INS_COMPL_CPT_END;</a>
<a name="ln2892">  } else {</a>
<a name="ln2893">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln2894">      // compl_type = -1;</a>
<a name="ln2895">    } else if (*st-&gt;e_cpt == 'k' || *st-&gt;e_cpt == 's') {</a>
<a name="ln2896">      if (*st-&gt;e_cpt == 'k') {</a>
<a name="ln2897">        compl_type = CTRL_X_DICTIONARY;</a>
<a name="ln2898">      } else {</a>
<a name="ln2899">        compl_type = CTRL_X_THESAURUS;</a>
<a name="ln2900">      }</a>
<a name="ln2901">      if (*++st-&gt;e_cpt != ',' &amp;&amp; *st-&gt;e_cpt != NUL) {</a>
<a name="ln2902">        st-&gt;dict = st-&gt;e_cpt;</a>
<a name="ln2903">        st-&gt;dict_f = DICT_FIRST;</a>
<a name="ln2904">      }</a>
<a name="ln2905">    } else if (*st-&gt;e_cpt == 'i') {</a>
<a name="ln2906">      compl_type = CTRL_X_PATH_PATTERNS;</a>
<a name="ln2907">    } else if (*st-&gt;e_cpt == 'd') {</a>
<a name="ln2908">      compl_type = CTRL_X_PATH_DEFINES;</a>
<a name="ln2909">    } else if (*st-&gt;e_cpt == ']' || *st-&gt;e_cpt == 't') {</a>
<a name="ln2910">      compl_type = CTRL_X_TAGS;</a>
<a name="ln2911">      if (!shortmess(SHM_COMPLETIONSCAN)) {</a>
<a name="ln2912">        msg_hist_off = true;  // reset in msg_trunc_attr()</a>
<a name="ln2913">        vim_snprintf(IObuff, IOSIZE, &quot;%s&quot;, _(&quot;Scanning tags.&quot;));</a>
<a name="ln2914">        (void)msg_trunc_attr(IObuff, true, HL_ATTR(HLF_R));</a>
<a name="ln2915">      }</a>
<a name="ln2916">    }</a>
<a name="ln2917"> </a>
<a name="ln2918">    // in any case e_cpt is advanced to the next entry</a>
<a name="ln2919">    (void)copy_option_part(&amp;st-&gt;e_cpt, IObuff, IOSIZE, &quot;,&quot;);</a>
<a name="ln2920"> </a>
<a name="ln2921">    st-&gt;found_all = true;</a>
<a name="ln2922">    if (compl_type == -1) {</a>
<a name="ln2923">      status = INS_COMPL_CPT_CONT;</a>
<a name="ln2924">    }</a>
<a name="ln2925">  }</a>
<a name="ln2926"> </a>
<a name="ln2927">done:</a>
<a name="ln2928">  *compl_type_arg = compl_type;</a>
<a name="ln2929">  return status;</a>
<a name="ln2930">}</a>
<a name="ln2931"> </a>
<a name="ln2932">/// Get the next set of identifiers or defines matching &quot;compl_pattern&quot; in</a>
<a name="ln2933">/// included files.</a>
<a name="ln2934">static void get_next_include_file_completion(int compl_type)</a>
<a name="ln2935">{</a>
<a name="ln2936">  find_pattern_in_path(compl_pattern, compl_direction,</a>
<a name="ln2937">                       strlen(compl_pattern), false, false,</a>
<a name="ln2938">                       ((compl_type == CTRL_X_PATH_DEFINES</a>
<a name="ln2939">                         &amp;&amp; !(compl_cont_status &amp; CONT_SOL))</a>
<a name="ln2940">                        ? FIND_DEFINE : FIND_ANY),</a>
<a name="ln2941">                       1L, ACTION_EXPAND, 1, MAXLNUM);</a>
<a name="ln2942">}</a>
<a name="ln2943"> </a>
<a name="ln2944">/// Get the next set of words matching &quot;compl_pattern&quot; in dictionary or</a>
<a name="ln2945">/// thesaurus files.</a>
<a name="ln2946">static void get_next_dict_tsr_completion(int compl_type, char *dict, int dict_f)</a>
<a name="ln2947">{</a>
<a name="ln2948">  if (thesaurus_func_complete(compl_type)) {</a>
<a name="ln2949">    expand_by_function(compl_type, compl_pattern);</a>
<a name="ln2950">  } else {</a>
<a name="ln2951">    ins_compl_dictionaries(dict != NULL ? dict</a>
<a name="ln2952">                           : (compl_type == CTRL_X_THESAURUS</a>
<a name="ln2953">                              ? (*curbuf-&gt;b_p_tsr == NUL ? p_tsr : curbuf-&gt;b_p_tsr)</a>
<a name="ln2954">                              : (*curbuf-&gt;b_p_dict ==</a>
<a name="ln2955">                                 NUL ? p_dict : curbuf-&gt;b_p_dict)),</a>
<a name="ln2956">                           compl_pattern,</a>
<a name="ln2957">                           dict != NULL ? dict_f : 0,</a>
<a name="ln2958">                           compl_type == CTRL_X_THESAURUS);</a>
<a name="ln2959">  }</a>
<a name="ln2960">}</a>
<a name="ln2961"> </a>
<a name="ln2962">/// Get the next set of tag names matching &quot;compl_pattern&quot;.</a>
<a name="ln2963">static void get_next_tag_completion(void)</a>
<a name="ln2964">{</a>
<a name="ln2965">  // set p_ic according to p_ic, p_scs and pat for find_tags().</a>
<a name="ln2966">  const int save_p_ic = p_ic;</a>
<a name="ln2967">  p_ic = ignorecase(compl_pattern);</a>
<a name="ln2968"> </a>
<a name="ln2969">  // Find up to TAG_MANY matches.  Avoids that an enormous number</a>
<a name="ln2970">  // of matches is found when compl_pattern is empty</a>
<a name="ln2971">  g_tag_at_cursor = true;</a>
<a name="ln2972">  char **matches;</a>
<a name="ln2973">  int num_matches;</a>
<a name="ln2974">  if (find_tags(compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2975">                TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP</a>
<a name="ln2976">                | (ctrl_x_mode_not_default() ? TAG_VERBOSE : 0),</a>
<a name="ln2977">                TAG_MANY, curbuf-&gt;b_ffname) == OK &amp;&amp; num_matches &gt; 0) {</a>
<a name="ln2978">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln2979">  }</a>
<a name="ln2980">  g_tag_at_cursor = false;</a>
<a name="ln2981">  p_ic = save_p_ic;</a>
<a name="ln2982">}</a>
<a name="ln2983"> </a>
<a name="ln2984">/// Get the next set of filename matching &quot;compl_pattern&quot;.</a>
<a name="ln2985">static void get_next_filename_completion(void)</a>
<a name="ln2986">{</a>
<a name="ln2987">  char **matches;</a>
<a name="ln2988">  int num_matches;</a>
<a name="ln2989">  if (expand_wildcards(1, &amp;compl_pattern, &amp;num_matches, &amp;matches,</a>
<a name="ln2990">                       EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK) {</a>
<a name="ln2991">    return;</a>
<a name="ln2992">  }</a>
<a name="ln2993"> </a>
<a name="ln2994">  // May change home directory back to &quot;~&quot;.</a>
<a name="ln2995">  tilde_replace(compl_pattern, num_matches, matches);</a>
<a name="ln2996">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln2997">  if (curbuf-&gt;b_p_csl[0] != NUL) {</a>
<a name="ln2998">    for (int i = 0; i &lt; num_matches; i++) {</a>
<a name="ln2999">      char *ptr = matches[i];</a>
<a name="ln3000">      while (*ptr != NUL) {</a>
<a name="ln3001">        if (curbuf-&gt;b_p_csl[0] == 's' &amp;&amp; *ptr == '\\') {</a>
<a name="ln3002">          *ptr = '/';</a>
<a name="ln3003">        } else if (curbuf-&gt;b_p_csl[0] == 'b' &amp;&amp; *ptr == '/') {</a>
<a name="ln3004">          *ptr = '\\';</a>
<a name="ln3005">        }</a>
<a name="ln3006">        ptr += utfc_ptr2len(ptr);</a>
<a name="ln3007">      }</a>
<a name="ln3008">    }</a>
<a name="ln3009">  }</a>
<a name="ln3010">#endif</a>
<a name="ln3011">  ins_compl_add_matches(num_matches, matches, p_fic || p_wic);</a>
<a name="ln3012">}</a>
<a name="ln3013"> </a>
<a name="ln3014">/// Get the next set of command-line completions matching &quot;compl_pattern&quot;.</a>
<a name="ln3015">static void get_next_cmdline_completion(void)</a>
<a name="ln3016">{</a>
<a name="ln3017">  char **matches;</a>
<a name="ln3018">  int num_matches;</a>
<a name="ln3019">  if (expand_cmdline(&amp;compl_xp, compl_pattern,</a>
<a name="ln3020">                     (int)strlen(compl_pattern),</a>
<a name="ln3021">                     &amp;num_matches, &amp;matches) == EXPAND_OK) {</a>
<a name="ln3022">    ins_compl_add_matches(num_matches, matches, false);</a>
<a name="ln3023">  }</a>
<a name="ln3024">}</a>
<a name="ln3025"> </a>
<a name="ln3026">/// Get the next set of spell suggestions matching &quot;compl_pattern&quot;.</a>
<a name="ln3027">static void get_next_spell_completion(linenr_T lnum)</a>
<a name="ln3028">{</a>
<a name="ln3029">  char **matches;</a>
<a name="ln3030">  int num_matches = expand_spelling(lnum, compl_pattern, &amp;matches);</a>
<a name="ln3031">  if (num_matches &gt; 0) {</a>
<a name="ln3032">    ins_compl_add_matches(num_matches, matches, p_ic);</a>
<a name="ln3033">  } else {</a>
<a name="ln3034">    xfree(matches);</a>
<a name="ln3035">  }</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038">/// Return the next word or line from buffer &quot;ins_buf&quot; at position</a>
<a name="ln3039">/// &quot;cur_match_pos&quot; for completion.  The length of the match is set in &quot;len&quot;.</a>
<a name="ln3040">/// @param ins_buf        buffer being scanned</a>
<a name="ln3041">/// @param cur_match_pos  current match position</a>
<a name="ln3042">/// @param match_len</a>
<a name="ln3043">/// @param cont_s_ipos    next ^X&lt;&gt; will set initial_pos</a>
<a name="ln3044">static char *ins_compl_get_next_word_or_line(buf_T *ins_buf, pos_T *cur_match_pos, int *match_len,</a>
<a name="ln3045">                                             bool *cont_s_ipos)</a>
<a name="ln3046">{</a>
<a name="ln3047">  *match_len = 0;</a>
<a name="ln3048">  char *ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum) + cur_match_pos-&gt;col;</a>
<a name="ln3049">  int len;</a>
<a name="ln3050">  if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln3051">    if (compl_status_adding()) {</a>
<a name="ln3052">      if (cur_match_pos-&gt;lnum &gt;= ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3053">        return NULL;</a>
<a name="ln3054">      }</a>
<a name="ln3055">      ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3056">      if (!p_paste) {</a>
<a name="ln3057">        ptr = skipwhite(ptr);</a>
<a name="ln3058">      }</a>
<a name="ln3059">    }</a>
<a name="ln3060">    len = (int)strlen(ptr);</a>
<a name="ln3061">  } else {</a>
<a name="ln3062">    char *tmp_ptr = ptr;</a>
<a name="ln3063"> </a>
<a name="ln3064">    if (compl_status_adding() &amp;&amp; compl_length &lt;= (int)strlen(tmp_ptr)) {</a>
<a name="ln3065">      tmp_ptr += compl_length;</a>
<a name="ln3066">      // Skip if already inside a word.</a>
<a name="ln3067">      if (vim_iswordp(tmp_ptr)) {</a>
<a name="ln3068">        return NULL;</a>
<a name="ln3069">      }</a>
<a name="ln3070">      // Find start of next word.</a>
<a name="ln3071">      tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3072">    }</a>
<a name="ln3073">    // Find end of this word.</a>
<a name="ln3074">    tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3075">    len = (int)(tmp_ptr - ptr);</a>
<a name="ln3076"> </a>
<a name="ln3077">    if (compl_status_adding() &amp;&amp; len == compl_length) {</a>
<a name="ln3078">      if (cur_match_pos-&gt;lnum &lt; ins_buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3079">        // Try next line, if any. the new word will be &quot;join&quot; as if the</a>
<a name="ln3080">        // normal command &quot;J&quot; was used. IOSIZE is always greater than</a>
<a name="ln3081">        // compl_length, so the next strncpy always works -- Acevedo</a>
<a name="ln3082">        strncpy(IObuff, ptr, (size_t)len);  // NOLINT(runtime/printf)</a>
<a name="ln3083">        ptr = ml_get_buf(ins_buf, cur_match_pos-&gt;lnum + 1);</a>
<a name="ln3084">        tmp_ptr = ptr = skipwhite(ptr);</a>
<a name="ln3085">        // Find start of next word.</a>
<a name="ln3086">        tmp_ptr = find_word_start(tmp_ptr);</a>
<a name="ln3087">        // Find end of next word.</a>
<a name="ln3088">        tmp_ptr = find_word_end(tmp_ptr);</a>
<a name="ln3089">        if (tmp_ptr &gt; ptr) {</a>
<a name="ln3090">          if (*ptr != ')' &amp;&amp; IObuff[len - 1] != TAB) {</a>
<a name="ln3091">            if (IObuff[len - 1] != ' ') {</a>
<a name="ln3092">              IObuff[len++] = ' ';</a>
<a name="ln3093">            }</a>
<a name="ln3094">            // IObuf =~ &quot;\k.* &quot;, thus len &gt;= 2</a>
<a name="ln3095">            if (p_js</a>
<a name="ln3096">                &amp;&amp; (IObuff[len - 2] == '.'</a>
<a name="ln3097">                    || IObuff[len - 2] == '?'</a>
<a name="ln3098">                    || IObuff[len - 2] == '!')) {</a>
<a name="ln3099">              IObuff[len++] = ' ';</a>
<a name="ln3100">            }</a>
<a name="ln3101">          }</a>
<a name="ln3102">          // copy as much as possible of the new word</a>
<a name="ln3103">          if (tmp_ptr - ptr &gt;= IOSIZE - len) {</a>
<a name="ln3104">            tmp_ptr = ptr + IOSIZE - len - 1;</a>
<a name="ln3105">          }</a>
<a name="ln3106">          xstrlcpy(IObuff + len, ptr, (size_t)(IOSIZE - len));</a>
<a name="ln3107">          len += (int)(tmp_ptr - ptr);</a>
<a name="ln3108">          *cont_s_ipos = true;</a>
<a name="ln3109">        }</a>
<a name="ln3110">        IObuff[len] = NUL;</a>
<a name="ln3111">        ptr = IObuff;</a>
<a name="ln3112">      }</a>
<a name="ln3113">      if (len == compl_length) {</a>
<a name="ln3114">        return NULL;</a>
<a name="ln3115">      }</a>
<a name="ln3116">    }</a>
<a name="ln3117">  }</a>
<a name="ln3118"> </a>
<a name="ln3119">  *match_len = len;</a>
<a name="ln3120">  return ptr;</a>
<a name="ln3121">}</a>
<a name="ln3122"> </a>
<a name="ln3123">/// Get the next set of words matching &quot;compl_pattern&quot; for default completion(s)</a>
<a name="ln3124">/// (normal ^P/^N and ^X^L).</a>
<a name="ln3125">/// Search for &quot;compl_pattern&quot; in the buffer &quot;st-&gt;ins_buf&quot; starting from the</a>
<a name="ln3126">/// position &quot;st-&gt;start_pos&quot; in the &quot;compl_direction&quot; direction. If</a>
<a name="ln3127">/// &quot;st-&gt;set_match_pos&quot; is true, then set the &quot;st-&gt;first_match_pos&quot; and</a>
<a name="ln3128">/// &quot;st-&gt;last_match_pos&quot;.</a>
<a name="ln3129">///</a>
<a name="ln3130">/// @return  OK if a new next match is found, otherwise FAIL.</a>
<a name="ln3131">static int get_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)</a>
<a name="ln3132">{</a>
<a name="ln3133">  // If 'infercase' is set, don't use 'smartcase' here</a>
<a name="ln3134">  const int save_p_scs = p_scs;</a>
<a name="ln3135">  assert(st-&gt;ins_buf);</a>
<a name="ln3136">  if (st-&gt;ins_buf-&gt;b_p_inf) {</a>
<a name="ln3137">    p_scs = false;</a>
<a name="ln3138">  }</a>
<a name="ln3139"> </a>
<a name="ln3140">  // Buffers other than curbuf are scanned from the beginning or the</a>
<a name="ln3141">  // end but never from the middle, thus setting nowrapscan in this</a>
<a name="ln3142">  // buffers is a good idea, on the other hand, we always set</a>
<a name="ln3143">  // wrapscan for curbuf to avoid missing matches -- Acevedo,Webb</a>
<a name="ln3144">  const int save_p_ws = p_ws;</a>
<a name="ln3145">  if (st-&gt;ins_buf != curbuf) {</a>
<a name="ln3146">    p_ws = false;</a>
<a name="ln3147">  } else if (*st-&gt;e_cpt == '.') {</a>
<a name="ln3148">    p_ws = true;</a>
<a name="ln3149">  }</a>
<a name="ln3150">  bool looped_around = false;</a>
<a name="ln3151">  int found_new_match = FAIL;</a>
<a name="ln3152">  while (true) {</a>
<a name="ln3153">    bool cont_s_ipos = false;</a>
<a name="ln3154"> </a>
<a name="ln3155">    msg_silent++;  // Don't want messages for wrapscan.</a>
<a name="ln3156">    // ctrl_x_mode_line_or_eval() || word-wise search that</a>
<a name="ln3157">    // has added a word that was at the beginning of the line.</a>
<a name="ln3158">    if (ctrl_x_mode_line_or_eval() || (compl_cont_status &amp; CONT_SOL)) {</a>
<a name="ln3159">      found_new_match = search_for_exact_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3160">                                              compl_direction, compl_pattern);</a>
<a name="ln3161">    } else {</a>
<a name="ln3162">      found_new_match = searchit(NULL, st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3163">                                 NULL, compl_direction, compl_pattern, 1L,</a>
<a name="ln3164">                                 SEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);</a>
<a name="ln3165">    }</a>
<a name="ln3166">    msg_silent--;</a>
<a name="ln3167">    if (!compl_started || st-&gt;set_match_pos) {</a>
<a name="ln3168">      // set &quot;compl_started&quot; even on fail</a>
<a name="ln3169">      compl_started = true;</a>
<a name="ln3170">      st-&gt;first_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3171">      st-&gt;last_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3172">      st-&gt;set_match_pos = false;</a>
<a name="ln3173">    } else if (st-&gt;first_match_pos.lnum == st-&gt;last_match_pos.lnum</a>
<a name="ln3174">               &amp;&amp; st-&gt;first_match_pos.col == st-&gt;last_match_pos.col) {</a>
<a name="ln3175">      found_new_match = FAIL;</a>
<a name="ln3176">    } else if (compl_dir_forward()</a>
<a name="ln3177">               &amp;&amp; (st-&gt;prev_match_pos.lnum &gt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3178">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3179">                       &amp;&amp; st-&gt;prev_match_pos.col &gt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3180">      if (looped_around) {</a>
<a name="ln3181">        found_new_match = FAIL;</a>
<a name="ln3182">      } else {</a>
<a name="ln3183">        looped_around = true;</a>
<a name="ln3184">      }</a>
<a name="ln3185">    } else if (!compl_dir_forward()</a>
<a name="ln3186">               &amp;&amp; (st-&gt;prev_match_pos.lnum &lt; st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3187">                   || (st-&gt;prev_match_pos.lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3188">                       &amp;&amp; st-&gt;prev_match_pos.col &lt;= st-&gt;cur_match_pos-&gt;col))) {</a>
<a name="ln3189">      if (looped_around) {</a>
<a name="ln3190">        found_new_match = FAIL;</a>
<a name="ln3191">      } else {</a>
<a name="ln3192">        looped_around = true;</a>
<a name="ln3193">      }</a>
<a name="ln3194">    }</a>
<a name="ln3195">    st-&gt;prev_match_pos = *st-&gt;cur_match_pos;</a>
<a name="ln3196">    if (found_new_match == FAIL) {</a>
<a name="ln3197">      break;</a>
<a name="ln3198">    }</a>
<a name="ln3199"> </a>
<a name="ln3200">    // when ADDING, the text before the cursor matches, skip it</a>
<a name="ln3201">    if (compl_status_adding() &amp;&amp; st-&gt;ins_buf == curbuf</a>
<a name="ln3202">        &amp;&amp; start_pos-&gt;lnum == st-&gt;cur_match_pos-&gt;lnum</a>
<a name="ln3203">        &amp;&amp; start_pos-&gt;col == st-&gt;cur_match_pos-&gt;col) {</a>
<a name="ln3204">      continue;</a>
<a name="ln3205">    }</a>
<a name="ln3206">    int len;</a>
<a name="ln3207">    char *ptr = ins_compl_get_next_word_or_line(st-&gt;ins_buf, st-&gt;cur_match_pos,</a>
<a name="ln3208">                                                &amp;len, &amp;cont_s_ipos);</a>
<a name="ln3209">    if (ptr == NULL) {</a>
<a name="ln3210">      continue;</a>
<a name="ln3211">    }</a>
<a name="ln3212">    if (ins_compl_add_infercase(ptr, len, p_ic,</a>
<a name="ln3213">                                st-&gt;ins_buf == curbuf ? NULL : st-&gt;ins_buf-&gt;b_sfname,</a>
<a name="ln3214">                                0, cont_s_ipos) != NOTDONE) {</a>
<a name="ln3215">      found_new_match = OK;</a>
<a name="ln3216">      break;</a>
<a name="ln3217">    }</a>
<a name="ln3218">  }</a>
<a name="ln3219">  p_scs = save_p_scs;</a>
<a name="ln3220">  p_ws = save_p_ws;</a>
<a name="ln3221"> </a>
<a name="ln3222">  return found_new_match;</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225">/// get the next set of completion matches for &quot;type&quot;.</a>
<a name="ln3226">/// @return  true if a new match is found, otherwise false.</a>
<a name="ln3227">static bool get_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)</a>
<a name="ln3228">{</a>
<a name="ln3229">  int found_new_match = FAIL;</a>
<a name="ln3230"> </a>
<a name="ln3231">  switch (type) {</a>
<a name="ln3232">  case -1:</a>
<a name="ln3233">    break;</a>
<a name="ln3234">  case CTRL_X_PATH_PATTERNS:</a>
<a name="ln3235">  case CTRL_X_PATH_DEFINES:</a>
<a name="ln3236">    get_next_include_file_completion(type);</a>
<a name="ln3237">    break;</a>
<a name="ln3238"> </a>
<a name="ln3239">  case CTRL_X_DICTIONARY:</a>
<a name="ln3240">  case CTRL_X_THESAURUS:</a>
<a name="ln3241">    get_next_dict_tsr_completion(type, st-&gt;dict, st-&gt;dict_f);</a>
<a name="ln3242">    st-&gt;dict = NULL;</a>
<a name="ln3243">    break;</a>
<a name="ln3244"> </a>
<a name="ln3245">  case CTRL_X_TAGS:</a>
<a name="ln3246">    get_next_tag_completion();</a>
<a name="ln3247">    break;</a>
<a name="ln3248"> </a>
<a name="ln3249">  case CTRL_X_FILES:</a>
<a name="ln3250">    get_next_filename_completion();</a>
<a name="ln3251">    break;</a>
<a name="ln3252"> </a>
<a name="ln3253">  case CTRL_X_CMDLINE:</a>
<a name="ln3254">  case CTRL_X_CMDLINE_CTRL_X:</a>
<a name="ln3255">    get_next_cmdline_completion();</a>
<a name="ln3256">    break;</a>
<a name="ln3257"> </a>
<a name="ln3258">  case CTRL_X_FUNCTION:</a>
<a name="ln3259">  case CTRL_X_OMNI:</a>
<a name="ln3260">    expand_by_function(type, compl_pattern);</a>
<a name="ln3261">    break;</a>
<a name="ln3262"> </a>
<a name="ln3263">  case CTRL_X_SPELL:</a>
<a name="ln3264">    get_next_spell_completion(st-&gt;first_match_pos.lnum);</a>
<a name="ln3265">    break;</a>
<a name="ln3266"> </a>
<a name="ln3267">  default:            // normal ^P/^N and ^X^L</a>
<a name="ln3268">    found_new_match = get_next_default_completion(st, ini);</a>
<a name="ln3269">    if (found_new_match == FAIL &amp;&amp; st-&gt;ins_buf == curbuf) {</a>
<a name="ln3270">      st-&gt;found_all = true;</a>
<a name="ln3271">    }</a>
<a name="ln3272">  }</a>
<a name="ln3273"> </a>
<a name="ln3274">  // check if compl_curr_match has changed, (e.g. other type of</a>
<a name="ln3275">  // expansion added something)</a>
<a name="ln3276">  if (type != 0 &amp;&amp; compl_curr_match != compl_old_match) {</a>
<a name="ln3277">    found_new_match = OK;</a>
<a name="ln3278">  }</a>
<a name="ln3279"> </a>
<a name="ln3280">  return found_new_match;</a>
<a name="ln3281">}</a>
<a name="ln3282"> </a>
<a name="ln3283">/// Get the next expansion(s), using &quot;compl_pattern&quot;.</a>
<a name="ln3284">/// The search starts at position &quot;ini&quot; in curbuf and in the direction</a>
<a name="ln3285">/// compl_direction.</a>
<a name="ln3286">/// When &quot;compl_started&quot; is false start at that position, otherwise continue</a>
<a name="ln3287">/// where we stopped searching before.</a>
<a name="ln3288">/// This may return before finding all the matches.</a>
<a name="ln3289">/// Return the total number of matches or -1 if still unknown -- Acevedo</a>
<a name="ln3290">static int ins_compl_get_exp(pos_T *ini)</a>
<a name="ln3291">{</a>
<a name="ln3292">  static ins_compl_next_state_T st;</a>
<a name="ln3293">  static bool st_cleared = false;</a>
<a name="ln3294">  int i;</a>
<a name="ln3295">  int found_new_match;</a>
<a name="ln3296">  int type = ctrl_x_mode;</a>
<a name="ln3297"> </a>
<a name="ln3298">  assert(curbuf != NULL);</a>
<a name="ln3299"> </a>
<a name="ln3300">  if (!compl_started) {</a>
<a name="ln3301">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln3302">      buf-&gt;b_scanned = false;</a>
<a name="ln3303">    }</a>
<a name="ln3304">    if (!st_cleared) {</a>
<a name="ln3305">      CLEAR_FIELD(st);</a>
<a name="ln3306">      st_cleared = true;</a>
<a name="ln3307">    }</a>
<a name="ln3308">    st.found_all = false;</a>
<a name="ln3309">    st.ins_buf = curbuf;</a>
<a name="ln3310">    xfree(st.e_cpt_copy);</a>
<a name="ln3311">    // Make a copy of 'complete', in case the buffer is wiped out.</a>
<a name="ln3312">    st.e_cpt_copy = xstrdup((compl_cont_status &amp; CONT_LOCAL) ? &quot;.&quot; : curbuf-&gt;b_p_cpt);</a>
<a name="ln3313">    st.e_cpt = st.e_cpt_copy == NULL ? &quot;&quot; : st.e_cpt_copy;</a>
<a name="ln3314">    st.last_match_pos = st.first_match_pos = *ini;</a>
<a name="ln3315">  } else if (st.ins_buf != curbuf &amp;&amp; !buf_valid(st.ins_buf)) {</a>
<a name="ln3316">    st.ins_buf = curbuf;  // In case the buffer was wiped out.</a>
<a name="ln3317">  }</a>
<a name="ln3318">  assert(st.ins_buf != NULL);</a>
<a name="ln3319"> </a>
<a name="ln3320">  compl_old_match = compl_curr_match;   // remember the last current match</a>
<a name="ln3321">  st.cur_match_pos = compl_dir_forward() ? &amp;st.last_match_pos : &amp;st.first_match_pos;</a>
<a name="ln3322"> </a>
<a name="ln3323">  // For ^N/^P loop over all the flags/windows/buffers in 'complete'</a>
<a name="ln3324">  while (true) {</a>
<a name="ln3325">    found_new_match = FAIL;</a>
<a name="ln3326">    st.set_match_pos = false;</a>
<a name="ln3327"> </a>
<a name="ln3328">    // For ^N/^P pick a new entry from e_cpt if compl_started is off,</a>
<a name="ln3329">    // or if found_all says this entry is done.  For ^X^L only use the</a>
<a name="ln3330">    // entries from 'complete' that look in loaded buffers.</a>
<a name="ln3331">    if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3332">        &amp;&amp; (!compl_started || st.found_all)) {</a>
<a name="ln3333">      int status = process_next_cpt_value(&amp;st, &amp;type, ini);</a>
<a name="ln3334">      if (status == INS_COMPL_CPT_END) {</a>
<a name="ln3335">        break;</a>
<a name="ln3336">      }</a>
<a name="ln3337">      if (status == INS_COMPL_CPT_CONT) {</a>
<a name="ln3338">        continue;</a>
<a name="ln3339">      }</a>
<a name="ln3340">    }</a>
<a name="ln3341"> </a>
<a name="ln3342">    // If complete() was called then compl_pattern has been reset.</a>
<a name="ln3343">    // The following won't work then, bail out.</a>
<a name="ln3344">    if (compl_pattern == NULL) {</a>
<a name="ln3345">      break;</a>
<a name="ln3346">    }</a>
<a name="ln3347"> </a>
<a name="ln3348">    // get the next set of completion matches</a>
<a name="ln3349">    found_new_match = get_next_completion_match(type, &amp;st, ini);</a>
<a name="ln3350"> </a>
<a name="ln3351">    // break the loop for specialized modes (use 'complete' just for the</a>
<a name="ln3352">    // generic ctrl_x_mode == CTRL_X_NORMAL) or when we've found a new match</a>
<a name="ln3353">    if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3354">        || found_new_match != FAIL) {</a>
<a name="ln3355">      if (got_int) {</a>
<a name="ln3356">        break;</a>
<a name="ln3357">      }</a>
<a name="ln3358">      // Fill the popup menu as soon as possible.</a>
<a name="ln3359">      if (type != -1) {</a>
<a name="ln3360">        ins_compl_check_keys(0, false);</a>
<a name="ln3361">      }</a>
<a name="ln3362"> </a>
<a name="ln3363">      if ((ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())</a>
<a name="ln3364">          || compl_interrupted) {</a>
<a name="ln3365">        break;</a>
<a name="ln3366">      }</a>
<a name="ln3367">      compl_started = true;</a>
<a name="ln3368">    } else {</a>
<a name="ln3369">      // Mark a buffer scanned when it has been scanned completely</a>
<a name="ln3370">      if (type == 0 || type == CTRL_X_PATH_PATTERNS) {</a>
<a name="ln3371">        assert(st.ins_buf);</a>
<a name="ln3372">        st.ins_buf-&gt;b_scanned = true;</a>
<a name="ln3373">      }</a>
<a name="ln3374"> </a>
<a name="ln3375">      compl_started = false;</a>
<a name="ln3376">    }</a>
<a name="ln3377">  }</a>
<a name="ln3378">  compl_started = true;</a>
<a name="ln3379"> </a>
<a name="ln3380">  if ((ctrl_x_mode_normal() || ctrl_x_mode_line_or_eval())</a>
<a name="ln3381">      &amp;&amp; *st.e_cpt == NUL) {  // Got to end of 'complete'</a>
<a name="ln3382">    found_new_match = FAIL;</a>
<a name="ln3383">  }</a>
<a name="ln3384"> </a>
<a name="ln3385">  i = -1;               // total of matches, unknown</a>
<a name="ln3386">  if (found_new_match == FAIL</a>
<a name="ln3387">      || (ctrl_x_mode_not_default() &amp;&amp; !ctrl_x_mode_line_or_eval())) {</a>
<a name="ln3388">    i = ins_compl_make_cyclic();</a>
<a name="ln3389">  }</a>
<a name="ln3390"> </a>
<a name="ln3391">  if (compl_old_match != NULL) {</a>
<a name="ln3392">    // If several matches were added (FORWARD) or the search failed and has</a>
<a name="ln3393">    // just been made cyclic then we have to move compl_curr_match to the</a>
<a name="ln3394">    // next or previous entry (if any) -- Acevedo</a>
<a name="ln3395">    compl_curr_match = compl_dir_forward()</a>
<a name="ln3396">                        ? compl_old_match-&gt;cp_next</a>
<a name="ln3397">                        : compl_old_match-&gt;cp_prev;</a>
<a name="ln3398">    if (compl_curr_match == NULL) {</a>
<a name="ln3399">      compl_curr_match = compl_old_match;</a>
<a name="ln3400">    }</a>
<a name="ln3401">  }</a>
<a name="ln3402">  may_trigger_modechanged();</a>
<a name="ln3403"> </a>
<a name="ln3404">  return i;</a>
<a name="ln3405">}</a>
<a name="ln3406"> </a>
<a name="ln3407">/// Update &quot;compl_shown_match&quot; to the actually shown match, it may differ when</a>
<a name="ln3408">/// &quot;compl_leader&quot; is used to omit some of the matches.</a>
<a name="ln3409">static void ins_compl_update_shown_match(void)</a>
<a name="ln3410">{</a>
<a name="ln3411">  while (!ins_compl_equal(compl_shown_match,</a>
<a name="ln3412">                          compl_leader, strlen(compl_leader))</a>
<a name="ln3413">         &amp;&amp; compl_shown_match-&gt;cp_next != NULL</a>
<a name="ln3414">         &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_next)) {</a>
<a name="ln3415">    compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3416">  }</a>
<a name="ln3417"> </a>
<a name="ln3418">  // If we didn't find it searching forward, and compl_shows_dir is</a>
<a name="ln3419">  // backward, find the last match.</a>
<a name="ln3420">  if (compl_shows_dir_backward()</a>
<a name="ln3421">      &amp;&amp; !ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3422">      &amp;&amp; (compl_shown_match-&gt;cp_next == NULL</a>
<a name="ln3423">          || is_first_match(compl_shown_match-&gt;cp_next))) {</a>
<a name="ln3424">    while (!ins_compl_equal(compl_shown_match, compl_leader, strlen(compl_leader))</a>
<a name="ln3425">           &amp;&amp; compl_shown_match-&gt;cp_prev != NULL</a>
<a name="ln3426">           &amp;&amp; !is_first_match(compl_shown_match-&gt;cp_prev)) {</a>
<a name="ln3427">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3428">    }</a>
<a name="ln3429">  }</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">/// Delete the old text being completed.</a>
<a name="ln3433">void ins_compl_delete(void)</a>
<a name="ln3434">{</a>
<a name="ln3435">  int col;</a>
<a name="ln3436"> </a>
<a name="ln3437">  // In insert mode: Delete the typed part.</a>
<a name="ln3438">  // In replace mode: Put the old characters back, if any.</a>
<a name="ln3439">  col = compl_col + (compl_status_adding() ? compl_length : 0);</a>
<a name="ln3440">  if ((int)curwin-&gt;w_cursor.col &gt; col) {</a>
<a name="ln3441">    if (stop_arrow() == FAIL) {</a>
<a name="ln3442">      return;</a>
<a name="ln3443">    }</a>
<a name="ln3444">    backspace_until_column(col);</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  // TODO(vim): is this sufficient for redrawing?  Redrawing everything</a>
<a name="ln3448">  // causes flicker, thus we can't do that.</a>
<a name="ln3449">  changed_cline_bef_curs(curwin);</a>
<a name="ln3450">  // clear v:completed_item</a>
<a name="ln3451">  set_vim_var_dict(VV_COMPLETED_ITEM, tv_dict_alloc_lock(VAR_FIXED));</a>
<a name="ln3452">}</a>
<a name="ln3453"> </a>
<a name="ln3454">/// Insert the new text being completed.</a>
<a name="ln3455">/// &quot;in_compl_func&quot; is true when called from complete_check().</a>
<a name="ln3456">void ins_compl_insert(bool in_compl_func)</a>
<a name="ln3457">{</a>
<a name="ln3458">  ins_bytes(compl_shown_match-&gt;cp_str + get_compl_len());</a>
<a name="ln3459">  compl_used_match = !match_at_original_text(compl_shown_match);</a>
<a name="ln3460"> </a>
<a name="ln3461">  dict_T *dict = ins_compl_dict_alloc(compl_shown_match);</a>
<a name="ln3462">  set_vim_var_dict(VV_COMPLETED_ITEM, dict);</a>
<a name="ln3463">  if (!in_compl_func) {</a>
<a name="ln3464">    compl_curr_match = compl_shown_match;</a>
<a name="ln3465">  }</a>
<a name="ln3466">}</a>
<a name="ln3467"> </a>
<a name="ln3468">/// show the file name for the completion match (if any).  Truncate the file</a>
<a name="ln3469">/// name to avoid a wait for return.</a>
<a name="ln3470">static void ins_compl_show_filename(void)</a>
<a name="ln3471">{</a>
<a name="ln3472">  char *const lead = _(&quot;match in file&quot;);</a>
<a name="ln3473">  int space = sc_col - vim_strsize(lead) - 2;</a>
<a name="ln3474">  if (space &lt;= 0) {</a>
<a name="ln3475">    return;</a>
<a name="ln3476">  }</a>
<a name="ln3477"> </a>
<a name="ln3478">  // We need the tail that fits.  With double-byte encoding going</a>
<a name="ln3479">  // back from the end is very slow, thus go from the start and keep</a>
<a name="ln3480">  // the text that fits in &quot;space&quot; between &quot;s&quot; and &quot;e&quot;.</a>
<a name="ln3481">  char *s;</a>
<a name="ln3482">  char *e;</a>
<a name="ln3483">  for (s = e = compl_shown_match-&gt;cp_fname; *e != NUL; MB_PTR_ADV(e)) {</a>
<a name="ln3484">    space -= ptr2cells(e);</a>
<a name="ln3485">    while (space &lt; 0) {</a>
<a name="ln3486">      space += ptr2cells(s);</a>
<a name="ln3487">      MB_PTR_ADV(s);</a>
<a name="ln3488">    }</a>
<a name="ln3489">  }</a>
<a name="ln3490">  msg_hist_off = true;</a>
<a name="ln3491">  vim_snprintf(IObuff, IOSIZE, &quot;%s %s%s&quot;, lead,</a>
<a name="ln3492">               s &gt; compl_shown_match-&gt;cp_fname ? &quot;&lt;&quot; : &quot;&quot;, s);</a>
<a name="ln3493">  msg(IObuff);</a>
<a name="ln3494">  msg_hist_off = false;</a>
<a name="ln3495">  redraw_cmdline = false;  // don't overwrite!</a>
<a name="ln3496">}</a>
<a name="ln3497"> </a>
<a name="ln3498">/// Find the next set of matches for completion. Repeat the completion &quot;todo&quot;</a>
<a name="ln3499">/// times.  The number of matches found is returned in 'num_matches'.</a>
<a name="ln3500">///</a>
<a name="ln3501">/// @param allow_get_expansion  If true, then ins_compl_get_exp() may be called to</a>
<a name="ln3502">///                             get more completions.</a>
<a name="ln3503">///                             If false, then do nothing when there are no more</a>
<a name="ln3504">///                             completions in the given direction.</a>
<a name="ln3505">/// @param todo  repeat completion this many times</a>
<a name="ln3506">/// @param advance  If true, then completion will move to the first match.</a>
<a name="ln3507">///                 Otherwise, the original text will be shown.</a>
<a name="ln3508">///</a>
<a name="ln3509">/// @return  OK on success and -1 if the number of matches are unknown.</a>
<a name="ln3510">static int find_next_completion_match(bool allow_get_expansion, int todo, bool advance,</a>
<a name="ln3511">                                      int *num_matches)</a>
<a name="ln3512">{</a>
<a name="ln3513">  bool found_end = false;</a>
<a name="ln3514">  compl_T *found_compl = NULL;</a>
<a name="ln3515"> </a>
<a name="ln3516">  while (--todo &gt;= 0) {</a>
<a name="ln3517">    if (compl_shows_dir_forward() &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3518">      compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3519">      found_end = (compl_first_match != NULL</a>
<a name="ln3520">                   &amp;&amp; (is_first_match(compl_shown_match-&gt;cp_next)</a>
<a name="ln3521">                       || is_first_match(compl_shown_match)));</a>
<a name="ln3522">    } else if (compl_shows_dir_backward()</a>
<a name="ln3523">               &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3524">      found_end = is_first_match(compl_shown_match);</a>
<a name="ln3525">      compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3526">      found_end |= is_first_match(compl_shown_match);</a>
<a name="ln3527">    } else {</a>
<a name="ln3528">      if (!allow_get_expansion) {</a>
<a name="ln3529">        if (advance) {</a>
<a name="ln3530">          if (compl_shows_dir_backward()) {</a>
<a name="ln3531">            compl_pending -= todo + 1;</a>
<a name="ln3532">          } else {</a>
<a name="ln3533">            compl_pending += todo + 1;</a>
<a name="ln3534">          }</a>
<a name="ln3535">        }</a>
<a name="ln3536">        return -1;</a>
<a name="ln3537">      }</a>
<a name="ln3538"> </a>
<a name="ln3539">      if (!compl_no_select &amp;&amp; advance) {</a>
<a name="ln3540">        if (compl_shows_dir_backward()) {</a>
<a name="ln3541">          compl_pending--;</a>
<a name="ln3542">        } else {</a>
<a name="ln3543">          compl_pending++;</a>
<a name="ln3544">        }</a>
<a name="ln3545">      }</a>
<a name="ln3546"> </a>
<a name="ln3547">      // Find matches.</a>
<a name="ln3548">      *num_matches = ins_compl_get_exp(&amp;compl_startpos);</a>
<a name="ln3549"> </a>
<a name="ln3550">      // handle any pending completions</a>
<a name="ln3551">      while (compl_pending != 0 &amp;&amp; compl_direction == compl_shows_dir</a>
<a name="ln3552">             &amp;&amp; advance) {</a>
<a name="ln3553">        if (compl_pending &gt; 0 &amp;&amp; compl_shown_match-&gt;cp_next != NULL) {</a>
<a name="ln3554">          compl_shown_match = compl_shown_match-&gt;cp_next;</a>
<a name="ln3555">          compl_pending--;</a>
<a name="ln3556">        }</a>
<a name="ln3557">        if (compl_pending &lt; 0 &amp;&amp; compl_shown_match-&gt;cp_prev != NULL) {</a>
<a name="ln3558">          compl_shown_match = compl_shown_match-&gt;cp_prev;</a>
<a name="ln3559">          compl_pending++;</a>
<a name="ln3560">        } else {</a>
<a name="ln3561">          break;</a>
<a name="ln3562">        }</a>
<a name="ln3563">      }</a>
<a name="ln3564">      found_end = false;</a>
<a name="ln3565">    }</a>
<a name="ln3566">    if (!match_at_original_text(compl_shown_match)</a>
<a name="ln3567">        &amp;&amp; compl_leader != NULL</a>
<a name="ln3568">        &amp;&amp; !ins_compl_equal(compl_shown_match,</a>
<a name="ln3569">                            compl_leader, strlen(compl_leader))) {</a>
<a name="ln3570">      todo++;</a>
<a name="ln3571">    } else {</a>
<a name="ln3572">      // Remember a matching item.</a>
<a name="ln3573">      found_compl = compl_shown_match;</a>
<a name="ln3574">    }</a>
<a name="ln3575"> </a>
<a name="ln3576">    // Stop at the end of the list when we found a usable match.</a>
<a name="ln3577">    if (found_end) {</a>
<a name="ln3578">      if (found_compl != NULL) {</a>
<a name="ln3579">        compl_shown_match = found_compl;</a>
<a name="ln3580">        break;</a>
<a name="ln3581">      }</a>
<a name="ln3582">      todo = 1;             // use first usable match after wrapping around</a>
<a name="ln3583">    }</a>
<a name="ln3584">  }</a>
<a name="ln3585"> </a>
<a name="ln3586">  return OK;</a>
<a name="ln3587">}</a>
<a name="ln3588"> </a>
<a name="ln3589">/// Fill in the next completion in the current direction.</a>
<a name="ln3590">/// If &quot;allow_get_expansion&quot; is true, then we may call ins_compl_get_exp() to</a>
<a name="ln3591">/// get more completions.  If it is false, then we just do nothing when there</a>
<a name="ln3592">/// are no more completions in a given direction.  The latter case is used when</a>
<a name="ln3593">/// we are still in the middle of finding completions, to allow browsing</a>
<a name="ln3594">/// through the ones found so far.</a>
<a name="ln3595">/// @return  the total number of matches, or -1 if still unknown -- webb.</a>
<a name="ln3596">///</a>
<a name="ln3597">/// compl_curr_match is currently being used by ins_compl_get_exp(), so we use</a>
<a name="ln3598">/// compl_shown_match here.</a>
<a name="ln3599">///</a>
<a name="ln3600">/// Note that this function may be called recursively once only.  First with</a>
<a name="ln3601">/// &quot;allow_get_expansion&quot; true, which calls ins_compl_get_exp(), which in turn</a>
<a name="ln3602">/// calls this function with &quot;allow_get_expansion&quot; false.</a>
<a name="ln3603">///</a>
<a name="ln3604">/// @param count          Repeat completion this many times; should be at least 1</a>
<a name="ln3605">/// @param insert_match   Insert the newly selected match</a>
<a name="ln3606">/// @param in_compl_func  Called from complete_check()</a>
<a name="ln3607">static int ins_compl_next(bool allow_get_expansion, int count, bool insert_match,</a>
<a name="ln3608">                          bool in_compl_func)</a>
<a name="ln3609">{</a>
<a name="ln3610">  int num_matches = -1;</a>
<a name="ln3611">  int todo = count;</a>
<a name="ln3612">  const bool started = compl_started;</a>
<a name="ln3613">  buf_T *const orig_curbuf = curbuf;</a>
<a name="ln3614"> </a>
<a name="ln3615">  // When user complete function return -1 for findstart which is next</a>
<a name="ln3616">  // time of 'always', compl_shown_match become NULL.</a>
<a name="ln3617">  if (compl_shown_match == NULL) {</a>
<a name="ln3618">    return -1;</a>
<a name="ln3619">  }</a>
<a name="ln3620"> </a>
<a name="ln3621">  if (compl_leader != NULL &amp;&amp; !match_at_original_text(compl_shown_match)) {</a>
<a name="ln3622">    // Update &quot;compl_shown_match&quot; to the actually shown match</a>
<a name="ln3623">    ins_compl_update_shown_match();</a>
<a name="ln3624">  }</a>
<a name="ln3625"> </a>
<a name="ln3626">  if (allow_get_expansion &amp;&amp; insert_match</a>
<a name="ln3627">      &amp;&amp; (!(compl_get_longest || compl_restarting) || compl_used_match)) {</a>
<a name="ln3628">    // Delete old text to be replaced</a>
<a name="ln3629">    ins_compl_delete();</a>
<a name="ln3630">  }</a>
<a name="ln3631"> </a>
<a name="ln3632">  // When finding the longest common text we stick at the original text,</a>
<a name="ln3633">  // don't let CTRL-N or CTRL-P move to the first match.</a>
<a name="ln3634">  bool advance = count != 1 || !allow_get_expansion || !compl_get_longest;</a>
<a name="ln3635"> </a>
<a name="ln3636">  // When restarting the search don't insert the first match either.</a>
<a name="ln3637">  if (compl_restarting) {</a>
<a name="ln3638">    advance = false;</a>
<a name="ln3639">    compl_restarting = false;</a>
<a name="ln3640">  }</a>
<a name="ln3641"> </a>
<a name="ln3642">  // Repeat this for when &lt;PageUp&gt; or &lt;PageDown&gt; is typed.  But don't wrap</a>
<a name="ln3643">  // around.</a>
<a name="ln3644">  if (find_next_completion_match(allow_get_expansion, todo, advance,</a>
<a name="ln3645">                                 &amp;num_matches) == -1) {</a>
<a name="ln3646">    return -1;</a>
<a name="ln3647">  }</a>
<a name="ln3648"> </a>
<a name="ln3649">  if (curbuf != orig_curbuf) {</a>
<a name="ln3650">    // In case some completion function switched buffer, don't want to</a>
<a name="ln3651">    // insert the completion elsewhere.</a>
<a name="ln3652">    return -1;</a>
<a name="ln3653">  }</a>
<a name="ln3654"> </a>
<a name="ln3655">  // Insert the text of the new completion, or the compl_leader.</a>
<a name="ln3656">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3657">    ins_bytes(compl_orig_text + get_compl_len());</a>
<a name="ln3658">    compl_used_match = false;</a>
<a name="ln3659">  } else if (insert_match) {</a>
<a name="ln3660">    if (!compl_get_longest || compl_used_match) {</a>
<a name="ln3661">      ins_compl_insert(in_compl_func);</a>
<a name="ln3662">    } else {</a>
<a name="ln3663">      ins_bytes(compl_leader + get_compl_len());</a>
<a name="ln3664">    }</a>
<a name="ln3665">  } else {</a>
<a name="ln3666">    compl_used_match = false;</a>
<a name="ln3667">  }</a>
<a name="ln3668"> </a>
<a name="ln3669">  if (!allow_get_expansion) {</a>
<a name="ln3670">    // redraw to show the user what was inserted</a>
<a name="ln3671">    update_screen();  // TODO(bfredl): no!</a>
<a name="ln3672"> </a>
<a name="ln3673">    // display the updated popup menu</a>
<a name="ln3674">    ins_compl_show_pum();</a>
<a name="ln3675"> </a>
<a name="ln3676">    // Delete old text to be replaced, since we're still searching and</a>
<a name="ln3677">    // don't want to match ourselves!</a>
<a name="ln3678">    ins_compl_delete();</a>
<a name="ln3679">  }</a>
<a name="ln3680"> </a>
<a name="ln3681">  // Enter will select a match when the match wasn't inserted and the popup</a>
<a name="ln3682">  // menu is visible.</a>
<a name="ln3683">  if (compl_no_insert &amp;&amp; !started) {</a>
<a name="ln3684">    compl_enter_selects = true;</a>
<a name="ln3685">  } else {</a>
<a name="ln3686">    compl_enter_selects = !insert_match &amp;&amp; compl_match_array != NULL;</a>
<a name="ln3687">  }</a>
<a name="ln3688"> </a>
<a name="ln3689">  // Show the file name for the match (if any)</a>
<a name="ln3690">  if (compl_shown_match-&gt;cp_fname != NULL) {</a>
<a name="ln3691">    ins_compl_show_filename();</a>
<a name="ln3692">  }</a>
<a name="ln3693"> </a>
<a name="ln3694">  return num_matches;</a>
<a name="ln3695">}</a>
<a name="ln3696"> </a>
<a name="ln3697">/// Call this while finding completions, to check whether the user has hit a key</a>
<a name="ln3698">/// that should change the currently displayed completion, or exit completion</a>
<a name="ln3699">/// mode.  Also, when compl_pending is not zero, show a completion as soon as</a>
<a name="ln3700">/// possible. -- webb</a>
<a name="ln3701">///</a>
<a name="ln3702">/// @param frequency      specifies out of how many calls we actually check.</a>
<a name="ln3703">/// @param in_compl_func  true when called from complete_check(), don't set</a>
<a name="ln3704">///                       compl_curr_match.</a>
<a name="ln3705">void ins_compl_check_keys(int frequency, bool in_compl_func)</a>
<a name="ln3706">{</a>
<a name="ln3707">  static int count = 0;</a>
<a name="ln3708"> </a>
<a name="ln3709">  // Don't check when reading keys from a script, :normal or feedkeys().</a>
<a name="ln3710">  // That would break the test scripts.  But do check for keys when called</a>
<a name="ln3711">  // from complete_check().</a>
<a name="ln3712">  if (!in_compl_func &amp;&amp; (using_script() || ex_normal_busy)) {</a>
<a name="ln3713">    return;</a>
<a name="ln3714">  }</a>
<a name="ln3715"> </a>
<a name="ln3716">  // Only do this at regular intervals</a>
<a name="ln3717">  if (++count &lt; frequency) {</a>
<a name="ln3718">    return;</a>
<a name="ln3719">  }</a>
<a name="ln3720">  count = 0;</a>
<a name="ln3721"> </a>
<a name="ln3722">  // Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()</a>
<a name="ln3723">  // can't do its work correctly.</a>
<a name="ln3724">  int c = vpeekc_any();</a>
<a name="ln3725">  if (c != NUL) {</a>
<a name="ln3726">    if (vim_is_ctrl_x_key(c) &amp;&amp; c != Ctrl_X &amp;&amp; c != Ctrl_R) {</a>
<a name="ln3727">      c = safe_vgetc();         // Eat the character</a>
<a name="ln3728">      compl_shows_dir = ins_compl_key2dir(c);</a>
<a name="ln3729">      (void)ins_compl_next(false, ins_compl_key2count(c),</a>
<a name="ln3730">                           c != K_UP &amp;&amp; c != K_DOWN, in_compl_func);</a>
<a name="ln3731">    } else {</a>
<a name="ln3732">      // Need to get the character to have KeyTyped set.  We'll put it</a>
<a name="ln3733">      // back with vungetc() below.  But skip K_IGNORE.</a>
<a name="ln3734">      c = safe_vgetc();</a>
<a name="ln3735">      if (c != K_IGNORE) {</a>
<a name="ln3736">        // Don't interrupt completion when the character wasn't typed,</a>
<a name="ln3737">        // e.g., when doing @q to replay keys.</a>
<a name="ln3738">        if (c != Ctrl_R &amp;&amp; KeyTyped) {</a>
<a name="ln3739">          compl_interrupted = true;</a>
<a name="ln3740">        }</a>
<a name="ln3741"> </a>
<a name="ln3742">        vungetc(c);</a>
<a name="ln3743">      }</a>
<a name="ln3744">    }</a>
<a name="ln3745">  }</a>
<a name="ln3746">  if (compl_pending != 0 &amp;&amp; !got_int &amp;&amp; !compl_no_insert) {</a>
<a name="ln3747">    int todo = compl_pending &gt; 0 ? compl_pending : -compl_pending;</a>
<a name="ln3748"> </a>
<a name="ln3749">    compl_pending = 0;</a>
<a name="ln3750">    (void)ins_compl_next(false, todo, true, in_compl_func);</a>
<a name="ln3751">  }</a>
<a name="ln3752">}</a>
<a name="ln3753"> </a>
<a name="ln3754">/// Decide the direction of Insert mode complete from the key typed.</a>
<a name="ln3755">/// Returns BACKWARD or FORWARD.</a>
<a name="ln3756">static int ins_compl_key2dir(int c)</a>
<a name="ln3757">{</a>
<a name="ln3758">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3759">    return pum_want.item &lt; pum_selected_item ? BACKWARD : FORWARD;</a>
<a name="ln3760">  }</a>
<a name="ln3761">  if (c == Ctrl_P || c == Ctrl_L</a>
<a name="ln3762">      || c == K_PAGEUP || c == K_KPAGEUP</a>
<a name="ln3763">      || c == K_S_UP || c == K_UP) {</a>
<a name="ln3764">    return BACKWARD;</a>
<a name="ln3765">  }</a>
<a name="ln3766">  return FORWARD;</a>
<a name="ln3767">}</a>
<a name="ln3768"> </a>
<a name="ln3769">/// Check that &quot;c&quot; is a valid completion key only while the popup menu is shown</a>
<a name="ln3770">///</a>
<a name="ln3771">/// @param  c  character to check</a>
<a name="ln3772">static bool ins_compl_pum_key(int c)</a>
<a name="ln3773">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3774">{</a>
<a name="ln3775">  return pum_visible() &amp;&amp; (c == K_PAGEUP || c == K_KPAGEUP || c == K_S_UP</a>
<a name="ln3776">                           || c == K_PAGEDOWN || c == K_KPAGEDOWN</a>
<a name="ln3777">                           || c == K_S_DOWN || c == K_UP || c == K_DOWN);</a>
<a name="ln3778">}</a>
<a name="ln3779"> </a>
<a name="ln3780">/// Decide the number of completions to move forward.</a>
<a name="ln3781">/// Returns 1 for most keys, height of the popup menu for page-up/down keys.</a>
<a name="ln3782">static int ins_compl_key2count(int c)</a>
<a name="ln3783">{</a>
<a name="ln3784">  int h;</a>
<a name="ln3785"> </a>
<a name="ln3786">  if (c == K_EVENT || c == K_COMMAND || c == K_LUA) {</a>
<a name="ln3787">    int offset = pum_want.item - pum_selected_item;</a>
<a name="ln3788">    return abs(offset);</a>
<a name="ln3789">  }</a>
<a name="ln3790"> </a>
<a name="ln3791">  if (ins_compl_pum_key(c) &amp;&amp; c != K_UP &amp;&amp; c != K_DOWN) {</a>
<a name="ln3792">    h = pum_get_height();</a>
<a name="ln3793">    if (h &gt; 3) {</a>
<a name="ln3794">      h -= 2;       // keep some context</a>
<a name="ln3795">    }</a>
<a name="ln3796">    return h;</a>
<a name="ln3797">  }</a>
<a name="ln3798">  return 1;</a>
<a name="ln3799">}</a>
<a name="ln3800"> </a>
<a name="ln3801">/// Check that completion with &quot;c&quot; should insert the match, false if only</a>
<a name="ln3802">/// to change the currently selected completion.</a>
<a name="ln3803">///</a>
<a name="ln3804">/// @param  c  character to check</a>
<a name="ln3805">static bool ins_compl_use_match(int c)</a>
<a name="ln3806">  FUNC_ATTR_CONST FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3807">{</a>
<a name="ln3808">  switch (c) {</a>
<a name="ln3809">  case K_UP:</a>
<a name="ln3810">  case K_DOWN:</a>
<a name="ln3811">  case K_PAGEDOWN:</a>
<a name="ln3812">  case K_KPAGEDOWN:</a>
<a name="ln3813">  case K_S_DOWN:</a>
<a name="ln3814">  case K_PAGEUP:</a>
<a name="ln3815">  case K_KPAGEUP:</a>
<a name="ln3816">  case K_S_UP:</a>
<a name="ln3817">    return false;</a>
<a name="ln3818">  case K_EVENT:</a>
<a name="ln3819">  case K_COMMAND:</a>
<a name="ln3820">  case K_LUA:</a>
<a name="ln3821">    return pum_want.active &amp;&amp; pum_want.insert;</a>
<a name="ln3822">  }</a>
<a name="ln3823">  return true;</a>
<a name="ln3824">}</a>
<a name="ln3825"> </a>
<a name="ln3826">/// Get the pattern, column and length for normal completion (CTRL-N CTRL-P</a>
<a name="ln3827">/// completion)</a>
<a name="ln3828">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3829">/// Uses the global variables: compl_cont_status and ctrl_x_mode</a>
<a name="ln3830">static int get_normal_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3831">{</a>
<a name="ln3832">  if ((compl_cont_status &amp; CONT_SOL) || ctrl_x_mode_path_defines()) {</a>
<a name="ln3833">    if (!compl_status_adding()) {</a>
<a name="ln3834">      while (--startcol &gt;= 0 &amp;&amp; vim_isIDc((uint8_t)line[startcol])) {}</a>
<a name="ln3835">      compl_col += ++startcol;</a>
<a name="ln3836">      compl_length = curs_col - startcol;</a>
<a name="ln3837">    }</a>
<a name="ln3838">    if (p_ic) {</a>
<a name="ln3839">      compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3840">    } else {</a>
<a name="ln3841">      compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3842">    }</a>
<a name="ln3843">  } else if (compl_status_adding()) {</a>
<a name="ln3844">    char *prefix = &quot;\\&lt;&quot;;</a>
<a name="ln3845"> </a>
<a name="ln3846">    // we need up to 2 extra chars for the prefix</a>
<a name="ln3847">    compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3848">    if (!vim_iswordp(line + compl_col)</a>
<a name="ln3849">        || (compl_col &gt; 0</a>
<a name="ln3850">            &amp;&amp; (vim_iswordp(mb_prevptr(line, line + compl_col))))) {</a>
<a name="ln3851">      prefix = &quot;&quot;;</a>
<a name="ln3852">    }</a>
<a name="ln3853">    STRCPY(compl_pattern, prefix);</a>
<a name="ln3854">    (void)quote_meta(compl_pattern + strlen(prefix),</a>
<a name="ln3855">                     line + compl_col, compl_length);</a>
<a name="ln3856">  } else if (--startcol &lt; 0</a>
<a name="ln3857">             || !vim_iswordp(mb_prevptr(line, line + startcol + 1))) {</a>
<a name="ln3858">    // Match any word of at least two chars</a>
<a name="ln3859">    compl_pattern = xstrdup(&quot;\\&lt;\\k\\k&quot;);</a>
<a name="ln3860">    compl_col += curs_col;</a>
<a name="ln3861">    compl_length = 0;</a>
<a name="ln3862">  } else {</a>
<a name="ln3863">    // Search the point of change class of multibyte character</a>
<a name="ln3864">    // or not a word single byte character backward.</a>
<a name="ln3865">    startcol -= utf_head_off(line, line + startcol);</a>
<a name="ln3866">    int base_class = mb_get_class(line + startcol);</a>
<a name="ln3867">    while (--startcol &gt;= 0) {</a>
<a name="ln3868">      int head_off = utf_head_off(line, line + startcol);</a>
<a name="ln3869">      if (base_class != mb_get_class(line + startcol - head_off)) {</a>
<a name="ln3870">        break;</a>
<a name="ln3871">      }</a>
<a name="ln3872">      startcol -= head_off;</a>
<a name="ln3873">    }</a>
<a name="ln3874">    compl_col += ++startcol;</a>
<a name="ln3875">    compl_length = (int)curs_col - startcol;</a>
<a name="ln3876">    if (compl_length == 1) {</a>
<a name="ln3877">      // Only match word with at least two chars -- webb</a>
<a name="ln3878">      // there's no need to call quote_meta,</a>
<a name="ln3879">      // xmalloc(7) is enough  -- Acevedo</a>
<a name="ln3880">      compl_pattern = xmalloc(7);</a>
<a name="ln3881">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3882">      (void)quote_meta(compl_pattern + 2, line + compl_col, 1);</a>
<a name="ln3883">      STRCAT(compl_pattern, &quot;\\k&quot;);</a>
<a name="ln3884">    } else {</a>
<a name="ln3885">      compl_pattern = xmalloc(quote_meta(NULL, line + compl_col, compl_length) + 2);</a>
<a name="ln3886">      STRCPY(compl_pattern, &quot;\\&lt;&quot;);</a>
<a name="ln3887">      (void)quote_meta(compl_pattern + 2, line + compl_col, compl_length);</a>
<a name="ln3888">    }</a>
<a name="ln3889">  }</a>
<a name="ln3890"> </a>
<a name="ln3891">  return OK;</a>
<a name="ln3892">}</a>
<a name="ln3893"> </a>
<a name="ln3894">/// Get the pattern, column and length for whole line completion or for the</a>
<a name="ln3895">/// complete() function.</a>
<a name="ln3896">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3897">static int get_wholeline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3898">{</a>
<a name="ln3899">  compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln3900">  compl_length = (int)curs_col - (int)compl_col;</a>
<a name="ln3901">  if (compl_length &lt; 0) {  // cursor in indent: empty pattern</a>
<a name="ln3902">    compl_length = 0;</a>
<a name="ln3903">  }</a>
<a name="ln3904">  if (p_ic) {</a>
<a name="ln3905">    compl_pattern = str_foldcase(line + compl_col, compl_length, NULL, 0);</a>
<a name="ln3906">  } else {</a>
<a name="ln3907">    compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln3908">  }</a>
<a name="ln3909"> </a>
<a name="ln3910">  return OK;</a>
<a name="ln3911">}</a>
<a name="ln3912"> </a>
<a name="ln3913">/// Get the pattern, column and length for filename completion.</a>
<a name="ln3914">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3915">static int get_filename_compl_info(char *line, int startcol, colnr_T curs_col)</a>
<a name="ln3916">{</a>
<a name="ln3917">  // Go back to just before the first filename character.</a>
<a name="ln3918">  if (startcol &gt; 0) {</a>
<a name="ln3919">    char *p = line + startcol;</a>
<a name="ln3920"> </a>
<a name="ln3921">    MB_PTR_BACK(line, p);</a>
<a name="ln3922">    while (p &gt; line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3923">      MB_PTR_BACK(line, p);</a>
<a name="ln3924">    }</a>
<a name="ln3925">    if (p == line &amp;&amp; vim_isfilec(utf_ptr2char(p))) {</a>
<a name="ln3926">      startcol = 0;</a>
<a name="ln3927">    } else {</a>
<a name="ln3928">      startcol = (int)(p - line) + 1;</a>
<a name="ln3929">    }</a>
<a name="ln3930">  }</a>
<a name="ln3931"> </a>
<a name="ln3932">  compl_col += startcol;</a>
<a name="ln3933">  compl_length = (int)curs_col - startcol;</a>
<a name="ln3934">  compl_pattern = addstar(line + compl_col, (size_t)compl_length, EXPAND_FILES);</a>
<a name="ln3935"> </a>
<a name="ln3936">  return OK;</a>
<a name="ln3937">}</a>
<a name="ln3938"> </a>
<a name="ln3939">/// Get the pattern, column and length for command-line completion.</a>
<a name="ln3940">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3941">static int get_cmdline_compl_info(char *line, colnr_T curs_col)</a>
<a name="ln3942">{</a>
<a name="ln3943">  compl_pattern = xstrnsave(line, (size_t)curs_col);</a>
<a name="ln3944">  set_cmd_context(&amp;compl_xp, compl_pattern, (int)strlen(compl_pattern), curs_col, false);</a>
<a name="ln3945">  if (compl_xp.xp_context == EXPAND_UNSUCCESSFUL</a>
<a name="ln3946">      || compl_xp.xp_context == EXPAND_NOTHING) {</a>
<a name="ln3947">    // No completion possible, use an empty pattern to get a</a>
<a name="ln3948">    // &quot;pattern not found&quot; message.</a>
<a name="ln3949">    compl_col = curs_col;</a>
<a name="ln3950">  } else {</a>
<a name="ln3951">    compl_col = (int)(compl_xp.xp_pattern - compl_pattern);</a>
<a name="ln3952">  }</a>
<a name="ln3953">  compl_length = curs_col - compl_col;</a>
<a name="ln3954"> </a>
<a name="ln3955">  return OK;</a>
<a name="ln3956">}</a>
<a name="ln3957"> </a>
<a name="ln3958">/// Get the pattern, column and length for user defined completion ('omnifunc',</a>
<a name="ln3959">/// 'completefunc' and 'thesaurusfunc')</a>
<a name="ln3960">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln3961">/// Uses the global variable: spell_bad_len</a>
<a name="ln3962">static int get_userdefined_compl_info(colnr_T curs_col)</a>
<a name="ln3963">{</a>
<a name="ln3964">  // Call user defined function 'completefunc' with &quot;a:findstart&quot;</a>
<a name="ln3965">  // set to 1 to obtain the length of text to use for completion.</a>
<a name="ln3966">  const int save_State = State;</a>
<a name="ln3967"> </a>
<a name="ln3968">  // Call 'completefunc' or 'omnifunc' and get pattern length as a string</a>
<a name="ln3969">  char *funcname = get_complete_funcname(ctrl_x_mode);</a>
<a name="ln3970">  if (*funcname == NUL) {</a>
<a name="ln3971">    semsg(_(e_notset), ctrl_x_mode_function() ? &quot;completefunc&quot; : &quot;omnifunc&quot;);</a>
<a name="ln3972">    return FAIL;</a>
<a name="ln3973">  }</a>
<a name="ln3974"> </a>
<a name="ln3975">  typval_T args[3];</a>
<a name="ln3976">  args[0].v_type = VAR_NUMBER;</a>
<a name="ln3977">  args[1].v_type = VAR_STRING;</a>
<a name="ln3978">  args[2].v_type = VAR_UNKNOWN;</a>
<a name="ln3979">  args[0].vval.v_number = 1;</a>
<a name="ln3980">  args[1].vval.v_string = &quot;&quot;;</a>
<a name="ln3981"> </a>
<a name="ln3982">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3983">  textlock++;</a>
<a name="ln3984">  Callback *cb = get_insert_callback(ctrl_x_mode);</a>
<a name="ln3985">  colnr_T col = (colnr_T)callback_call_retnr(cb, 2, args);</a>
<a name="ln3986">  textlock--;</a>
<a name="ln3987"> </a>
<a name="ln3988">  State = save_State;</a>
<a name="ln3989">  curwin-&gt;w_cursor = pos;  // restore the cursor position</a>
<a name="ln3990">  validate_cursor();</a>
<a name="ln3991">  if (!equalpos(curwin-&gt;w_cursor, pos)) {</a>
<a name="ln3992">    emsg(_(e_compldel));</a>
<a name="ln3993">    return FAIL;</a>
<a name="ln3994">  }</a>
<a name="ln3995"> </a>
<a name="ln3996">  // Return value -2 means the user complete function wants to cancel the</a>
<a name="ln3997">  // complete without an error, do the same if the function did not execute</a>
<a name="ln3998">  // successfully.</a>
<a name="ln3999">  if (col == -2 || aborting()) {</a>
<a name="ln4000">    return FAIL;</a>
<a name="ln4001">  }</a>
<a name="ln4002">  // Return value -3 does the same as -2 and leaves CTRL-X mode.</a>
<a name="ln4003">  if (col == -3) {</a>
<a name="ln4004">    ctrl_x_mode = CTRL_X_NORMAL;</a>
<a name="ln4005">    edit_submode = NULL;</a>
<a name="ln4006">    if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4007">      msg_clr_cmdline();</a>
<a name="ln4008">    }</a>
<a name="ln4009">    return FAIL;</a>
<a name="ln4010">  }</a>
<a name="ln4011"> </a>
<a name="ln4012">  // Reset extended parameters of completion, when starting new</a>
<a name="ln4013">  // completion.</a>
<a name="ln4014">  compl_opt_refresh_always = false;</a>
<a name="ln4015"> </a>
<a name="ln4016">  if (col &lt; 0) {</a>
<a name="ln4017">    col = curs_col;</a>
<a name="ln4018">  }</a>
<a name="ln4019">  compl_col = col;</a>
<a name="ln4020">  if (compl_col &gt; curs_col) {</a>
<a name="ln4021">    compl_col = curs_col;</a>
<a name="ln4022">  }</a>
<a name="ln4023"> </a>
<a name="ln4024">  // Setup variables for completion.  Need to obtain &quot;line&quot; again,</a>
<a name="ln4025">  // it may have become invalid.</a>
<a name="ln4026">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4027">  compl_length = curs_col - compl_col;</a>
<a name="ln4028">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4029"> </a>
<a name="ln4030">  return OK;</a>
<a name="ln4031">}</a>
<a name="ln4032"> </a>
<a name="ln4033">/// Get the pattern, column and length for spell completion.</a>
<a name="ln4034">/// Sets the global variables: compl_col, compl_length and compl_pattern.</a>
<a name="ln4035">/// Uses the global variable: spell_bad_len</a>
<a name="ln4036">static int get_spell_compl_info(int startcol, colnr_T curs_col)</a>
<a name="ln4037">{</a>
<a name="ln4038">  if (spell_bad_len &gt; 0) {</a>
<a name="ln4039">    assert(spell_bad_len &lt;= INT_MAX);</a>
<a name="ln4040">    compl_col = curs_col - (int)spell_bad_len;</a>
<a name="ln4041">  } else {</a>
<a name="ln4042">    compl_col = spell_word_start(startcol);</a>
<a name="ln4043">  }</a>
<a name="ln4044">  if (compl_col &gt;= (colnr_T)startcol) {</a>
<a name="ln4045">    compl_length = 0;</a>
<a name="ln4046">    compl_col = curs_col;</a>
<a name="ln4047">  } else {</a>
<a name="ln4048">    spell_expand_check_cap(compl_col);</a>
<a name="ln4049">    compl_length = (int)curs_col - compl_col;</a>
<a name="ln4050">  }</a>
<a name="ln4051">  // Need to obtain &quot;line&quot; again, it may have become invalid.</a>
<a name="ln4052">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4053">  compl_pattern = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4054"> </a>
<a name="ln4055">  return OK;</a>
<a name="ln4056">}</a>
<a name="ln4057"> </a>
<a name="ln4058">/// Get the completion pattern, column and length.</a>
<a name="ln4059">///</a>
<a name="ln4060">/// @param startcol  start column number of the completion pattern/text</a>
<a name="ln4061">/// @param cur_col   current cursor column</a>
<a name="ln4062">///</a>
<a name="ln4063">/// On return, &quot;line_invalid&quot; is set to true, if the current line may have</a>
<a name="ln4064">/// become invalid and needs to be fetched again.</a>
<a name="ln4065">///</a>
<a name="ln4066">/// @return  OK on success.</a>
<a name="ln4067">static int compl_get_info(char *line, int startcol, colnr_T curs_col, bool *line_invalid)</a>
<a name="ln4068">{</a>
<a name="ln4069">  if (ctrl_x_mode_normal()</a>
<a name="ln4070">      || ((ctrl_x_mode &amp; CTRL_X_WANT_IDENT)</a>
<a name="ln4071">          &amp;&amp; !thesaurus_func_complete(ctrl_x_mode))) {</a>
<a name="ln4072">    return get_normal_compl_info(line, startcol, curs_col);</a>
<a name="ln4073">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4074">    return get_wholeline_compl_info(line, curs_col);</a>
<a name="ln4075">  } else if (ctrl_x_mode_files()) {</a>
<a name="ln4076">    return get_filename_compl_info(line, startcol, curs_col);</a>
<a name="ln4077">  } else if (ctrl_x_mode == CTRL_X_CMDLINE) {</a>
<a name="ln4078">    return get_cmdline_compl_info(line, curs_col);</a>
<a name="ln4079">  } else if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4080">             || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4081">    if (get_userdefined_compl_info(curs_col) == FAIL) {</a>
<a name="ln4082">      return FAIL;</a>
<a name="ln4083">    }</a>
<a name="ln4084">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4085">  } else if (ctrl_x_mode_spell()) {</a>
<a name="ln4086">    if (get_spell_compl_info(startcol, curs_col) == FAIL) {</a>
<a name="ln4087">      return FAIL;</a>
<a name="ln4088">    }</a>
<a name="ln4089">    *line_invalid = true;  // &quot;line&quot; may have become invalid</a>
<a name="ln4090">  } else {</a>
<a name="ln4091">    internal_error(&quot;ins_complete()&quot;);</a>
<a name="ln4092">    return FAIL;</a>
<a name="ln4093">  }</a>
<a name="ln4094"> </a>
<a name="ln4095">  return OK;</a>
<a name="ln4096">}</a>
<a name="ln4097"> </a>
<a name="ln4098">/// Continue an interrupted completion mode search in &quot;line&quot;.</a>
<a name="ln4099">///</a>
<a name="ln4100">/// If this same ctrl_x_mode has been interrupted use the text from</a>
<a name="ln4101">/// &quot;compl_startpos&quot; to the cursor as a pattern to add a new word instead of</a>
<a name="ln4102">/// expand the one before the cursor, in word-wise if &quot;compl_startpos&quot; is not in</a>
<a name="ln4103">/// the same line as the cursor then fix it (the line has been split because it</a>
<a name="ln4104">/// was longer than 'tw').  if SOL is set then skip the previous pattern, a word</a>
<a name="ln4105">/// at the beginning of the line has been inserted, we'll look for that.</a>
<a name="ln4106">static void ins_compl_continue_search(char *line)</a>
<a name="ln4107">{</a>
<a name="ln4108">  // it is a continued search</a>
<a name="ln4109">  compl_cont_status &amp;= ~CONT_INTRPT;  // remove INTRPT</a>
<a name="ln4110">  if (ctrl_x_mode_normal()</a>
<a name="ln4111">      || ctrl_x_mode_path_patterns()</a>
<a name="ln4112">      || ctrl_x_mode_path_defines()) {</a>
<a name="ln4113">    if (compl_startpos.lnum != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln4114">      // line (probably) wrapped, set compl_startpos to the</a>
<a name="ln4115">      // first non_blank in the line, if it is not a wordchar</a>
<a name="ln4116">      // include it to get a better pattern, but then we don't</a>
<a name="ln4117">      // want the &quot;\\&lt;&quot; prefix, check it below.</a>
<a name="ln4118">      compl_col = (colnr_T)getwhitecols(line);</a>
<a name="ln4119">      compl_startpos.col = compl_col;</a>
<a name="ln4120">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4121">      compl_cont_status &amp;= ~CONT_SOL;  // clear SOL if present</a>
<a name="ln4122">    } else {</a>
<a name="ln4123">      // S_IPOS was set when we inserted a word that was at the</a>
<a name="ln4124">      // beginning of the line, which means that we'll go to SOL</a>
<a name="ln4125">      // mode but first we need to redefine compl_startpos</a>
<a name="ln4126">      if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4127">        compl_cont_status |= CONT_SOL;</a>
<a name="ln4128">        compl_startpos.col = (colnr_T)(skipwhite(line + compl_length + compl_startpos.col) - line);</a>
<a name="ln4129">      }</a>
<a name="ln4130">      compl_col = compl_startpos.col;</a>
<a name="ln4131">    }</a>
<a name="ln4132">    compl_length = curwin-&gt;w_cursor.col - (int)compl_col;</a>
<a name="ln4133">    // IObuff is used to add a &quot;word from the next line&quot; would we</a>
<a name="ln4134">    // have enough space?  just being paranoid</a>
<a name="ln4135">#define MIN_SPACE 75</a>
<a name="ln4136">    if (compl_length &gt; (IOSIZE - MIN_SPACE)) {</a>
<a name="ln4137">      compl_cont_status &amp;= ~CONT_SOL;</a>
<a name="ln4138">      compl_length = (IOSIZE - MIN_SPACE);</a>
<a name="ln4139">      compl_col = curwin-&gt;w_cursor.col - compl_length;</a>
<a name="ln4140">    }</a>
<a name="ln4141">    compl_cont_status |= CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4142">    if (compl_length &lt; 1) {</a>
<a name="ln4143">      compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4144">    }</a>
<a name="ln4145">  } else if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4146">    compl_cont_status = CONT_ADDING | CONT_N_ADDS;</a>
<a name="ln4147">  } else {</a>
<a name="ln4148">    compl_cont_status = 0;</a>
<a name="ln4149">  }</a>
<a name="ln4150">}</a>
<a name="ln4151"> </a>
<a name="ln4152">/// start insert mode completion</a>
<a name="ln4153">static int ins_compl_start(void)</a>
<a name="ln4154">{</a>
<a name="ln4155">  const bool save_did_ai = did_ai;</a>
<a name="ln4156"> </a>
<a name="ln4157">  // First time we hit ^N or ^P (in a row, I mean)</a>
<a name="ln4158"> </a>
<a name="ln4159">  did_ai = false;</a>
<a name="ln4160">  did_si = false;</a>
<a name="ln4161">  can_si = false;</a>
<a name="ln4162">  can_si_back = false;</a>
<a name="ln4163">  if (stop_arrow() == FAIL) {</a>
<a name="ln4164">    return FAIL;</a>
<a name="ln4165">  }</a>
<a name="ln4166"> </a>
<a name="ln4167">  char *line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4168">  colnr_T curs_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4169">  compl_pending = 0;</a>
<a name="ln4170"> </a>
<a name="ln4171">  if ((compl_cont_status &amp; CONT_INTRPT) == CONT_INTRPT</a>
<a name="ln4172">      &amp;&amp; compl_cont_mode == ctrl_x_mode) {</a>
<a name="ln4173">    // this same ctrl-x_mode was interrupted previously. Continue the</a>
<a name="ln4174">    // completion.</a>
<a name="ln4175">    ins_compl_continue_search(line);</a>
<a name="ln4176">  } else {</a>
<a name="ln4177">    compl_cont_status &amp;= CONT_LOCAL;</a>
<a name="ln4178">  }</a>
<a name="ln4179"> </a>
<a name="ln4180">  int startcol = 0;  // column where searched text starts</a>
<a name="ln4181">  if (!compl_status_adding()) {   // normal expansion</a>
<a name="ln4182">    compl_cont_mode = ctrl_x_mode;</a>
<a name="ln4183">    if (ctrl_x_mode_not_default()) {</a>
<a name="ln4184">      // Remove LOCAL if ctrl_x_mode != CTRL_X_NORMAL</a>
<a name="ln4185">      compl_cont_status = 0;</a>
<a name="ln4186">    }</a>
<a name="ln4187">    compl_cont_status |= CONT_N_ADDS;</a>
<a name="ln4188">    compl_startpos = curwin-&gt;w_cursor;</a>
<a name="ln4189">    startcol = (int)curs_col;</a>
<a name="ln4190">    compl_col = 0;</a>
<a name="ln4191">  }</a>
<a name="ln4192"> </a>
<a name="ln4193">  // Work out completion pattern and original text -- webb</a>
<a name="ln4194">  bool line_invalid = false;</a>
<a name="ln4195">  if (compl_get_info(line, startcol, curs_col, &amp;line_invalid) == FAIL) {</a>
<a name="ln4196">    if (ctrl_x_mode_function() || ctrl_x_mode_omni()</a>
<a name="ln4197">        || thesaurus_func_complete(ctrl_x_mode)) {</a>
<a name="ln4198">      // restore did_ai, so that adding comment leader works</a>
<a name="ln4199">      did_ai = save_did_ai;</a>
<a name="ln4200">    }</a>
<a name="ln4201">    return FAIL;</a>
<a name="ln4202">  }</a>
<a name="ln4203">  // If &quot;line&quot; was changed while getting completion info get it again.</a>
<a name="ln4204">  if (line_invalid) {</a>
<a name="ln4205">    line = ml_get(curwin-&gt;w_cursor.lnum);</a>
<a name="ln4206">  }</a>
<a name="ln4207"> </a>
<a name="ln4208">  if (compl_status_adding()) {</a>
<a name="ln4209">    edit_submode_pre = _(&quot; Adding&quot;);</a>
<a name="ln4210">    if (ctrl_x_mode_line_or_eval()) {</a>
<a name="ln4211">      // Insert a new line, keep indentation but ignore 'comments'.</a>
<a name="ln4212">      char *old = curbuf-&gt;b_p_com;</a>
<a name="ln4213"> </a>
<a name="ln4214">      curbuf-&gt;b_p_com = &quot;&quot;;</a>
<a name="ln4215">      compl_startpos.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4216">      compl_startpos.col = compl_col;</a>
<a name="ln4217">      ins_eol('\r');</a>
<a name="ln4218">      curbuf-&gt;b_p_com = old;</a>
<a name="ln4219">      compl_length = 0;</a>
<a name="ln4220">      compl_col = curwin-&gt;w_cursor.col;</a>
<a name="ln4221">    }</a>
<a name="ln4222">  } else {</a>
<a name="ln4223">    edit_submode_pre = NULL;</a>
<a name="ln4224">    compl_startpos.col = compl_col;</a>
<a name="ln4225">  }</a>
<a name="ln4226"> </a>
<a name="ln4227">  if (compl_cont_status &amp; CONT_LOCAL) {</a>
<a name="ln4228">    edit_submode = _(ctrl_x_msgs[CTRL_X_LOCAL_MSG]);</a>
<a name="ln4229">  } else {</a>
<a name="ln4230">    edit_submode = _(CTRL_X_MSG(ctrl_x_mode));</a>
<a name="ln4231">  }</a>
<a name="ln4232"> </a>
<a name="ln4233">  // If any of the original typed text has been changed we need to fix</a>
<a name="ln4234">  // the redo buffer.</a>
<a name="ln4235">  ins_compl_fixRedoBufForLeader(NULL);</a>
<a name="ln4236"> </a>
<a name="ln4237">  // Always add completion for the original text.</a>
<a name="ln4238">  xfree(compl_orig_text);</a>
<a name="ln4239">  compl_orig_text = xstrnsave(line + compl_col, (size_t)compl_length);</a>
<a name="ln4240">  int flags = CP_ORIGINAL_TEXT;</a>
<a name="ln4241">  if (p_ic) {</a>
<a name="ln4242">    flags |= CP_ICASE;</a>
<a name="ln4243">  }</a>
<a name="ln4244">  if (ins_compl_add(compl_orig_text, -1, NULL, NULL, false, NULL, 0,</a>
<a name="ln4245">                    flags, false) != OK) {</a>
<a name="ln4246">    XFREE_CLEAR(compl_pattern);</a>
<a name="ln4247">    XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4248">    return FAIL;</a>
<a name="ln4249">  }</a>
<a name="ln4250"> </a>
<a name="ln4251">  // showmode might reset the internal line pointers, so it must</a>
<a name="ln4252">  // be called before line = ml_get(), or when this address is no</a>
<a name="ln4253">  // longer needed.  -- Acevedo.</a>
<a name="ln4254">  edit_submode_extra = _(&quot;-- Searching...&quot;);</a>
<a name="ln4255">  edit_submode_highl = HLF_COUNT;</a>
<a name="ln4256">  showmode();</a>
<a name="ln4257">  edit_submode_extra = NULL;</a>
<a name="ln4258">  ui_flush();</a>
<a name="ln4259"> </a>
<a name="ln4260">  return OK;</a>
<a name="ln4261">}</a>
<a name="ln4262"> </a>
<a name="ln4263">/// display the completion status message</a>
<a name="ln4264">static void ins_compl_show_statusmsg(void)</a>
<a name="ln4265">{</a>
<a name="ln4266">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4267">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4268">    edit_submode_extra = compl_status_adding() &amp;&amp; compl_length &gt; 1 ? _(e_hitend) : _(e_patnotf);</a>
<a name="ln4269">    edit_submode_highl = HLF_E;</a>
<a name="ln4270">  }</a>
<a name="ln4271"> </a>
<a name="ln4272">  if (edit_submode_extra == NULL) {</a>
<a name="ln4273">    if (match_at_original_text(compl_curr_match)) {</a>
<a name="ln4274">      edit_submode_extra = _(&quot;Back at original&quot;);</a>
<a name="ln4275">      edit_submode_highl = HLF_W;</a>
<a name="ln4276">    } else if (compl_cont_status &amp; CONT_S_IPOS) {</a>
<a name="ln4277">      edit_submode_extra = _(&quot;Word from other line&quot;);</a>
<a name="ln4278">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4279">    } else if (compl_curr_match-&gt;cp_next == compl_curr_match-&gt;cp_prev) {</a>
<a name="ln4280">      edit_submode_extra = _(&quot;The only match&quot;);</a>
<a name="ln4281">      edit_submode_highl = HLF_COUNT;</a>
<a name="ln4282">      compl_curr_match-&gt;cp_number = 1;</a>
<a name="ln4283">    } else {</a>
<a name="ln4284">      // Update completion sequence number when needed.</a>
<a name="ln4285">      if (compl_curr_match-&gt;cp_number == -1) {</a>
<a name="ln4286">        ins_compl_update_sequence_numbers();</a>
<a name="ln4287">      }</a>
<a name="ln4288"> </a>
<a name="ln4289">      // The match should always have a sequence number now, this is</a>
<a name="ln4290">      // just a safety check.</a>
<a name="ln4291">      if (compl_curr_match-&gt;cp_number != -1) {</a>
<a name="ln4292">        // Space for 10 text chars. + 2x10-digit no.s = 31.</a>
<a name="ln4293">        // Translations may need more than twice that.</a>
<a name="ln4294">        static char match_ref[81];</a>
<a name="ln4295"> </a>
<a name="ln4296">        if (compl_matches &gt; 0) {</a>
<a name="ln4297">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4298">                       _(&quot;match %d of %d&quot;),</a>
<a name="ln4299">                       compl_curr_match-&gt;cp_number, compl_matches);</a>
<a name="ln4300">        } else {</a>
<a name="ln4301">          vim_snprintf(match_ref, sizeof(match_ref),</a>
<a name="ln4302">                       _(&quot;match %d&quot;),</a>
<a name="ln4303">                       compl_curr_match-&gt;cp_number);</a>
<a name="ln4304">        }</a>
<a name="ln4305">        edit_submode_extra = match_ref;</a>
<a name="ln4306">        edit_submode_highl = HLF_R;</a>
<a name="ln4307">        if (dollar_vcol &gt;= 0) {</a>
<a name="ln4308">          curs_columns(curwin, false);</a>
<a name="ln4309">        }</a>
<a name="ln4310">      }</a>
<a name="ln4311">    }</a>
<a name="ln4312">  }</a>
<a name="ln4313"> </a>
<a name="ln4314">  // Show a message about what (completion) mode we're in.</a>
<a name="ln4315">  showmode();</a>
<a name="ln4316">  if (!shortmess(SHM_COMPLETIONMENU)) {</a>
<a name="ln4317">    if (edit_submode_extra != NULL) {</a>
<a name="ln4318">      if (!p_smd) {</a>
<a name="ln4319">        msg_hist_off = true;</a>
<a name="ln4320">        msg_attr(edit_submode_extra,</a>
<a name="ln4321">                 (edit_submode_highl &lt; HLF_COUNT</a>
<a name="ln4322">                  ? HL_ATTR(edit_submode_highl) : 0));</a>
<a name="ln4323">        msg_hist_off = false;</a>
<a name="ln4324">      }</a>
<a name="ln4325">    } else {</a>
<a name="ln4326">      msg_clr_cmdline();  // necessary for &quot;noshowmode&quot;</a>
<a name="ln4327">    }</a>
<a name="ln4328">  }</a>
<a name="ln4329">}</a>
<a name="ln4330"> </a>
<a name="ln4331">/// Do Insert mode completion.</a>
<a name="ln4332">/// Called when character &quot;c&quot; was typed, which has a meaning for completion.</a>
<a name="ln4333">/// Returns OK if completion was done, FAIL if something failed.</a>
<a name="ln4334">int ins_complete(int c, bool enable_pum)</a>
<a name="ln4335">{</a>
<a name="ln4336">  int n;</a>
<a name="ln4337">  int save_w_wrow;</a>
<a name="ln4338">  int save_w_leftcol;</a>
<a name="ln4339">  int insert_match;</a>
<a name="ln4340"> </a>
<a name="ln4341">  compl_direction = ins_compl_key2dir(c);</a>
<a name="ln4342">  insert_match = ins_compl_use_match(c);</a>
<a name="ln4343"> </a>
<a name="ln4344">  if (!compl_started) {</a>
<a name="ln4345">    if (ins_compl_start() == FAIL) {</a>
<a name="ln4346">      return FAIL;</a>
<a name="ln4347">    }</a>
<a name="ln4348">  } else if (insert_match &amp;&amp; stop_arrow() == FAIL) {</a>
<a name="ln4349">    return FAIL;</a>
<a name="ln4350">  }</a>
<a name="ln4351"> </a>
<a name="ln4352">  compl_shown_match = compl_curr_match;</a>
<a name="ln4353">  compl_shows_dir = compl_direction;</a>
<a name="ln4354"> </a>
<a name="ln4355">  // Find next match (and following matches).</a>
<a name="ln4356">  save_w_wrow = curwin-&gt;w_wrow;</a>
<a name="ln4357">  save_w_leftcol = curwin-&gt;w_leftcol;</a>
<a name="ln4358">  n = ins_compl_next(true, ins_compl_key2count(c), insert_match, false);</a>
<a name="ln4359"> </a>
<a name="ln4360">  if (n &gt; 1) {          // all matches have been found</a>
<a name="ln4361">    compl_matches = n;</a>
<a name="ln4362">  }</a>
<a name="ln4363">  compl_curr_match = compl_shown_match;</a>
<a name="ln4364">  compl_direction = compl_shows_dir;</a>
<a name="ln4365"> </a>
<a name="ln4366">  // Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert</a>
<a name="ln4367">  // mode.</a>
<a name="ln4368">  if (got_int &amp;&amp; !global_busy) {</a>
<a name="ln4369">    (void)vgetc();</a>
<a name="ln4370">    got_int = false;</a>
<a name="ln4371">  }</a>
<a name="ln4372"> </a>
<a name="ln4373">  // we found no match if the list has only the &quot;compl_orig_text&quot;-entry</a>
<a name="ln4374">  if (is_first_match(compl_first_match-&gt;cp_next)) {</a>
<a name="ln4375">    // remove N_ADDS flag, so next ^X&lt;&gt; won't try to go to ADDING mode,</a>
<a name="ln4376">    // because we couldn't expand anything at first place, but if we used</a>
<a name="ln4377">    // ^P, ^N, ^X^I or ^X^D we might want to add-expand a single-char-word</a>
<a name="ln4378">    // (such as M in M'exico) if not tried already.  -- Acevedo</a>
<a name="ln4379">    if (compl_length &gt; 1</a>
<a name="ln4380">        || compl_status_adding()</a>
<a name="ln4381">        || (ctrl_x_mode_not_default()</a>
<a name="ln4382">            &amp;&amp; !ctrl_x_mode_path_patterns()</a>
<a name="ln4383">            &amp;&amp; !ctrl_x_mode_path_defines())) {</a>
<a name="ln4384">      compl_cont_status &amp;= ~CONT_N_ADDS;</a>
<a name="ln4385">    }</a>
<a name="ln4386">  }</a>
<a name="ln4387"> </a>
<a name="ln4388">  if (compl_curr_match-&gt;cp_flags &amp; CP_CONT_S_IPOS) {</a>
<a name="ln4389">    compl_cont_status |= CONT_S_IPOS;</a>
<a name="ln4390">  } else {</a>
<a name="ln4391">    compl_cont_status &amp;= ~CONT_S_IPOS;</a>
<a name="ln4392">  }</a>
<a name="ln4393"> </a>
<a name="ln4394">  ins_compl_show_statusmsg();</a>
<a name="ln4395"> </a>
<a name="ln4396">  // Show the popup menu, unless we got interrupted.</a>
<a name="ln4397">  if (enable_pum &amp;&amp; !compl_interrupted) {</a>
<a name="ln4398">    show_pum(save_w_wrow, save_w_leftcol);</a>
<a name="ln4399">  }</a>
<a name="ln4400">  compl_was_interrupted = compl_interrupted;</a>
<a name="ln4401">  compl_interrupted = false;</a>
<a name="ln4402"> </a>
<a name="ln4403">  return OK;</a>
<a name="ln4404">}</a>
<a name="ln4405"> </a>
<a name="ln4406">/// Remove (if needed) and show the popup menu</a>
<a name="ln4407">static void show_pum(int prev_w_wrow, int prev_w_leftcol)</a>
<a name="ln4408">{</a>
<a name="ln4409">  // RedrawingDisabled may be set when invoked through complete().</a>
<a name="ln4410">  int n = RedrawingDisabled;</a>
<a name="ln4411">  RedrawingDisabled = 0;</a>
<a name="ln4412"> </a>
<a name="ln4413">  // If the cursor moved or the display scrolled we need to remove the pum</a>
<a name="ln4414">  // first.</a>
<a name="ln4415">  setcursor();</a>
<a name="ln4416">  if (prev_w_wrow != curwin-&gt;w_wrow || prev_w_leftcol != curwin-&gt;w_leftcol) {</a>
<a name="ln4417">    ins_compl_del_pum();</a>
<a name="ln4418">  }</a>
<a name="ln4419"> </a>
<a name="ln4420">  ins_compl_show_pum();</a>
<a name="ln4421">  setcursor();</a>
<a name="ln4422">  RedrawingDisabled = n;</a>
<a name="ln4423">}</a>
<a name="ln4424"> </a>
<a name="ln4425">// Looks in the first &quot;len&quot; chars. of &quot;src&quot; for search-metachars.</a>
<a name="ln4426">// If dest is not NULL the chars. are copied there quoting (with</a>
<a name="ln4427">// a backslash) the metachars, and dest would be NUL terminated.</a>
<a name="ln4428">// Returns the length (needed) of dest</a>
<a name="ln4429">static unsigned quote_meta(char *dest, char *src, int len)</a>
<a name="ln4430">{</a>
<a name="ln4431">  unsigned m = (unsigned)len + 1;       // one extra for the NUL</a>
<a name="ln4432"> </a>
<a name="ln4433">  for (; --len &gt;= 0; src++) {</a>
<a name="ln4434">    switch (*src) {</a>
<a name="ln4435">    case '.':</a>
<a name="ln4436">    case '*':</a>
<a name="ln4437">    case '[':</a>
<a name="ln4438">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4439">        break;</a>
<a name="ln4440">      }</a>
<a name="ln4441">      FALLTHROUGH;</a>
<a name="ln4442">    case '~':</a>
<a name="ln4443">      if (!magic_isset()) {  // quote these only if magic is set</a>
<a name="ln4444">        break;</a>
<a name="ln4445">      }</a>
<a name="ln4446">      FALLTHROUGH;</a>
<a name="ln4447">    case '\\':</a>
<a name="ln4448">      if (ctrl_x_mode_dictionary() || ctrl_x_mode_thesaurus()) {</a>
<a name="ln4449">        break;</a>
<a name="ln4450">      }</a>
<a name="ln4451">      FALLTHROUGH;</a>
<a name="ln4452">    case '^':                   // currently it's not needed.</a>
<a name="ln4453">    case '$':</a>
<a name="ln4454">      m++;</a>
<a name="ln4455">      if (dest != NULL) {</a>
<a name="ln4456">        *dest++ = '\\';</a>
<a name="ln4457">      }</a>
<a name="ln4458">      break;</a>
<a name="ln4459">    }</a>
<a name="ln4460">    if (dest != NULL) {</a>
<a name="ln4461">      *dest++ = *src;</a>
<a name="ln4462">    }</a>
<a name="ln4463">    // Copy remaining bytes of a multibyte character.</a>
<a name="ln4464">    const int mb_len = utfc_ptr2len(src) - 1;</a>
<a name="ln4465">    if (mb_len &gt; 0 &amp;&amp; len &gt;= mb_len) {</a>
<a name="ln4466">      for (int i = 0; i &lt; mb_len; i++) {</a>
<a name="ln4467">        len--;</a>
<a name="ln4468">        src++;</a>
<a name="ln4469">        if (dest != NULL) {</a>
<a name="ln4470">          *dest++ = *src;</a>
<a name="ln4471">        }</a>
<a name="ln4472">      }</a>
<a name="ln4473">    }</a>
<a name="ln4474">  }</a>
<a name="ln4475">  if (dest != NULL) {</a>
<a name="ln4476">    *dest = NUL;</a>
<a name="ln4477">  }</a>
<a name="ln4478"> </a>
<a name="ln4479">  return m;</a>
<a name="ln4480">}</a>
<a name="ln4481"> </a>
<a name="ln4482">#if defined(EXITFREE)</a>
<a name="ln4483">void free_insexpand_stuff(void)</a>
<a name="ln4484">{</a>
<a name="ln4485">  XFREE_CLEAR(compl_orig_text);</a>
<a name="ln4486">  callback_free(&amp;cfu_cb);</a>
<a name="ln4487">  callback_free(&amp;ofu_cb);</a>
<a name="ln4488">  callback_free(&amp;tsrfu_cb);</a>
<a name="ln4489">}</a>
<a name="ln4490">#endif</a>
<a name="ln4491"> </a>
<a name="ln4492">/// Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly</a>
<a name="ln4493">/// spelled word, if there is one.</a>
<a name="ln4494">static void spell_back_to_badword(void)</a>
<a name="ln4495">{</a>
<a name="ln4496">  pos_T tpos = curwin-&gt;w_cursor;</a>
<a name="ln4497">  spell_bad_len = spell_move_to(curwin, BACKWARD, true, true, NULL);</a>
<a name="ln4498">  if (curwin-&gt;w_cursor.col != tpos.col) {</a>
<a name="ln4499">    start_arrow(&amp;tpos);</a>
<a name="ln4500">  }</a>
<a name="ln4501">}</a>
</code></pre>
<div class="balloon" rel="3313"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'st.e_cpt_copy == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>