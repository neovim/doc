<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>marktree.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Tree data structure for storing marks at (row, col) positions and updating</a>
<a name="ln5">// them to arbitrary text changes. Derivative work of kbtree in klib, whose</a>
<a name="ln6">// copyright notice is reproduced below. Also inspired by the design of the</a>
<a name="ln7">// marker tree data structure of the Atom editor, regarding efficient updates</a>
<a name="ln8">// to text changes.</a>
<a name="ln9">//</a>
<a name="ln10">// Marks are inserted using marktree_put. Text changes are processed using</a>
<a name="ln11">// marktree_splice. All read and delete operations use the iterator.</a>
<a name="ln12">// use marktree_itr_get to put an iterator at a given position or</a>
<a name="ln13">// marktree_lookup to lookup a mark by its id (iterator optional in this case).</a>
<a name="ln14">// Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.</a>
<a name="ln15">// marktree_del_itr deletes the current mark of the iterator and implicitly</a>
<a name="ln16">// moves the iterator to the next mark.</a>
<a name="ln17">//</a>
<a name="ln18">// Work is ongoing to fully support ranges (mark pairs).</a>
<a name="ln19"> </a>
<a name="ln20">// Copyright notice for kbtree (included in heavily modified form):</a>
<a name="ln21">//</a>
<a name="ln22">// Copyright 1997-1999, 2001, John-Mark Gurney.</a>
<a name="ln23">//           2008-2009, Attractive Chaos &lt;attractor@live.co.uk&gt;</a>
<a name="ln24">//</a>
<a name="ln25">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln26">// modification, are permitted provided that the following conditions</a>
<a name="ln27">// are met:</a>
<a name="ln28">//</a>
<a name="ln29">// 1. Redistributions of source code must retain the above copyright</a>
<a name="ln30">//    notice, this list of conditions and the following disclaimer.</a>
<a name="ln31">// 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln32">//    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln33">//    documentation and/or other materials provided with the distribution.</a>
<a name="ln34">//</a>
<a name="ln35">// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln36">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln37">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln38">// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln39">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln40">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln41">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln42">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln43">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln44">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln45">// SUCH DAMAGE.</a>
<a name="ln46">//</a>
<a name="ln47">// Changes done by by the neovim project follow the Apache v2 license available</a>
<a name="ln48">// at the repo root.</a>
<a name="ln49"> </a>
<a name="ln50">#include &lt;assert.h&gt;</a>
<a name="ln51">#include &lt;stdio.h&gt;</a>
<a name="ln52">#include &lt;stdlib.h&gt;</a>
<a name="ln53">#include &lt;string.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">#include &quot;klib/kvec.h&quot;</a>
<a name="ln56">#include &quot;nvim/garray.h&quot;</a>
<a name="ln57">#include &quot;nvim/marktree.h&quot;</a>
<a name="ln58">#include &quot;nvim/memory.h&quot;</a>
<a name="ln59">#include &quot;nvim/pos.h&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#define T MT_BRANCH_FACTOR</a>
<a name="ln62">#define ILEN (sizeof(mtnode_t) + (2 * T) * sizeof(void *))</a>
<a name="ln63"> </a>
<a name="ln64">#define ID_INCR (((uint64_t)1) &lt;&lt; 2)</a>
<a name="ln65"> </a>
<a name="ln66">#define rawkey(itr) ((itr)-&gt;node-&gt;key[(itr)-&gt;i])</a>
<a name="ln67"> </a>
<a name="ln68">static bool pos_leq(mtpos_t a, mtpos_t b)</a>
<a name="ln69">{</a>
<a name="ln70">  return a.row &lt; b.row || (a.row == b.row &amp;&amp; a.col &lt;= b.col);</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">static void relative(mtpos_t base, mtpos_t *val)</a>
<a name="ln74">{</a>
<a name="ln75">  assert(pos_leq(base, *val));</a>
<a name="ln76">  if (val-&gt;row == base.row) {</a>
<a name="ln77">    val-&gt;row = 0;</a>
<a name="ln78">    val-&gt;col -= base.col;</a>
<a name="ln79">  } else {</a>
<a name="ln80">    val-&gt;row -= base.row;</a>
<a name="ln81">  }</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">static void unrelative(mtpos_t base, mtpos_t *val)</a>
<a name="ln85">{</a>
<a name="ln86">  if (val-&gt;row == 0) {</a>
<a name="ln87">    val-&gt;row = base.row;</a>
<a name="ln88">    val-&gt;col += base.col;</a>
<a name="ln89">  } else {</a>
<a name="ln90">    val-&gt;row += base.row;</a>
<a name="ln91">  }</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">static void compose(mtpos_t *base, mtpos_t val)</a>
<a name="ln95">{</a>
<a name="ln96">  if (val.row == 0) {</a>
<a name="ln97">    base-&gt;col += val.col;</a>
<a name="ln98">  } else {</a>
<a name="ln99">    base-&gt;row += val.row;</a>
<a name="ln100">    base-&gt;col = val.col;</a>
<a name="ln101">  }</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln105"># include &quot;marktree.c.generated.h&quot;</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108">#define mt_generic_cmp(a, b) (((b) &lt; (a)) - ((a) &lt; (b)))</a>
<a name="ln109">static int key_cmp(mtkey_t a, mtkey_t b)</a>
<a name="ln110">{</a>
<a name="ln111">  int cmp = mt_generic_cmp(a.pos.row, b.pos.row);</a>
<a name="ln112">  if (cmp != 0) {</a>
<a name="ln113">    return cmp;</a>
<a name="ln114">  }</a>
<a name="ln115">  cmp = mt_generic_cmp(a.pos.col, b.pos.col);</a>
<a name="ln116">  if (cmp != 0) {</a>
<a name="ln117">    return cmp;</a>
<a name="ln118">  }</a>
<a name="ln119">  // NB: keeping the events at the same pos sorted by id is actually not</a>
<a name="ln120">  // necessary only make sure that START is before END etc.</a>
<a name="ln121">  return mt_generic_cmp(a.flags, b.flags);</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static inline int marktree_getp_aux(const mtnode_t *x, mtkey_t k, int *r)</a>
<a name="ln125">{</a>
<a name="ln126">  int tr, *rr, begin = 0, end = x-&gt;n;</a>
<a name="ln127">  if (x-&gt;n == 0) {</a>
<a name="ln128">    return -1;</a>
<a name="ln129">  }</a>
<a name="ln130">  rr = r ? r : &amp;tr;</a>
<a name="ln131">  while (begin &lt; end) {</a>
<a name="ln132">    int mid = (begin + end) &gt;&gt; 1;</a>
<a name="ln133">    if (key_cmp(x-&gt;key[mid], k) &lt; 0) {</a>
<a name="ln134">      begin = mid + 1;</a>
<a name="ln135">    } else {</a>
<a name="ln136">      end = mid;</a>
<a name="ln137">    }</a>
<a name="ln138">  }</a>
<a name="ln139">  if (begin == x-&gt;n) {</a>
<a name="ln140">    *rr = 1; return x-&gt;n - 1;</a>
<a name="ln141">  }</a>
<a name="ln142">  if ((*rr = key_cmp(k, x-&gt;key[begin])) &lt; 0) {</a>
<a name="ln143">    begin--;</a>
<a name="ln144">  }</a>
<a name="ln145">  return begin;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">static inline void refkey(MarkTree *b, mtnode_t *x, int i)</a>
<a name="ln149">{</a>
<a name="ln150">  pmap_put(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i]), x);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">// put functions</a>
<a name="ln154"> </a>
<a name="ln155">// x must be an internal node, which is not full</a>
<a name="ln156">// x-&gt;ptr[i] should be a full node, i e x-&gt;ptr[i]-&gt;n == 2*T-1</a>
<a name="ln157">static inline void split_node(MarkTree *b, mtnode_t *x, const int i)</a>
<a name="ln158">{</a>
<a name="ln159">  mtnode_t *y = x-&gt;ptr[i];</a>
<a name="ln160">  mtnode_t *z;</a>
<a name="ln161">  z = (mtnode_t *)xcalloc(1, y-&gt;level ? ILEN : sizeof(mtnode_t));</a>
<a name="ln162">  b-&gt;n_nodes++;</a>
<a name="ln163">  z-&gt;level = y-&gt;level;</a>
<a name="ln164">  z-&gt;n = T - 1;</a>
<a name="ln165">  memcpy(z-&gt;key, &amp;y-&gt;key[T], sizeof(mtkey_t) * (T - 1));</a>
<a name="ln166">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln167">    refkey(b, z, j);</a>
<a name="ln168">  }</a>
<a name="ln169">  if (y-&gt;level) {</a>
<a name="ln170">    memcpy(z-&gt;ptr, &amp;y-&gt;ptr[T], sizeof(mtnode_t *) * T);</a>
<a name="ln171">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln172">      z-&gt;ptr[j]-&gt;parent = z;</a>
<a name="ln173">    }</a>
<a name="ln174">  }</a>
<a name="ln175">  y-&gt;n = T - 1;</a>
<a name="ln176">  memmove(&amp;x-&gt;ptr[i + 2], &amp;x-&gt;ptr[i + 1],</a>
<a name="ln177">          sizeof(mtnode_t *) * (size_t)(x-&gt;n - i));</a>
<a name="ln178">  x-&gt;ptr[i + 1] = z;</a>
<a name="ln179">  z-&gt;parent = x;  // == y-&gt;parent</a>
<a name="ln180">  memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i], sizeof(mtkey_t) * (size_t)(x-&gt;n - i));</a>
<a name="ln181"> </a>
<a name="ln182">  // move key to internal layer:</a>
<a name="ln183">  x-&gt;key[i] = y-&gt;key[T - 1];</a>
<a name="ln184">  refkey(b, x, i);</a>
<a name="ln185">  x-&gt;n++;</a>
<a name="ln186"> </a>
<a name="ln187">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln188">    relative(x-&gt;key[i].pos, &amp;z-&gt;key[j].pos);</a>
<a name="ln189">  }</a>
<a name="ln190">  if (i &gt; 0) {</a>
<a name="ln191">    unrelative(x-&gt;key[i - 1].pos, &amp;x-&gt;key[i].pos);</a>
<a name="ln192">  }</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">// x must not be a full node (even if there might be internal space)</a>
<a name="ln196">static inline void marktree_putp_aux(MarkTree *b, mtnode_t *x, mtkey_t k)</a>
<a name="ln197">{</a>
<a name="ln198">  int i;</a>
<a name="ln199">  if (x-&gt;level == 0) {</a>
<a name="ln200">    i = marktree_getp_aux(x, k, 0);</a>
<a name="ln201">    if (i != x-&gt;n - 1) {</a>
<a name="ln202">      memmove(&amp;x-&gt;key[i + 2], &amp;x-&gt;key[i + 1],</a>
<a name="ln203">              (size_t)(x-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln204">    }</a>
<a name="ln205">    x-&gt;key[i + 1] = k;</a>
<a name="ln206">    refkey(b, x, i + 1);</a>
<a name="ln207">    x-&gt;n++;</a>
<a name="ln208">  } else {</a>
<a name="ln209">    i = marktree_getp_aux(x, k, 0) + 1;</a>
<a name="ln210">    if (x-&gt;ptr[i]-&gt;n == 2 * T - 1) {</a>
<a name="ln211">      split_node(b, x, i);</a>
<a name="ln212">      if (key_cmp(k, x-&gt;key[i]) &gt; 0) {</a>
<a name="ln213">        i++;</a>
<a name="ln214">      }</a>
<a name="ln215">    }</a>
<a name="ln216">    if (i &gt; 0) {</a>
<a name="ln217">      relative(x-&gt;key[i - 1].pos, &amp;k.pos);</a>
<a name="ln218">    }</a>
<a name="ln219">    marktree_putp_aux(b, x-&gt;ptr[i], k);</a>
<a name="ln220">  }</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">void marktree_put(MarkTree *b, mtkey_t key, int end_row, int end_col, bool end_right)</a>
<a name="ln224">{</a>
<a name="ln225">  assert(!(key.flags &amp; ~MT_FLAG_EXTERNAL_MASK));</a>
<a name="ln226">  if (end_row &gt;= 0) {</a>
<a name="ln227">    key.flags |= MT_FLAG_PAIRED;</a>
<a name="ln228">  }</a>
<a name="ln229"> </a>
<a name="ln230">  marktree_put_key(b, key);</a>
<a name="ln231"> </a>
<a name="ln232">  if (end_row &gt;= 0) {</a>
<a name="ln233">    mtkey_t end_key = key;</a>
<a name="ln234">    end_key.flags = (uint16_t)((uint16_t)(key.flags &amp; ~MT_FLAG_RIGHT_GRAVITY)</a>
<a name="ln235">                               |(uint16_t)MT_FLAG_END</a>
<a name="ln236">                               |(uint16_t)(end_right ? MT_FLAG_RIGHT_GRAVITY : 0));</a>
<a name="ln237">    end_key.pos = (mtpos_t){ end_row, end_col };</a>
<a name="ln238">    marktree_put_key(b, end_key);</a>
<a name="ln239">  }</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">void marktree_put_key(MarkTree *b, mtkey_t k)</a>
<a name="ln243">{</a>
<a name="ln244">  k.flags |= MT_FLAG_REAL;  // let's be real.</a>
<a name="ln245">  if (!b-&gt;root) {</a>
<a name="ln246">    b-&gt;root = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln247">    b-&gt;n_nodes++;</a>
<a name="ln248">  }</a>
<a name="ln249">  mtnode_t *r, *s;</a>
<a name="ln250">  b-&gt;n_keys++;</a>
<a name="ln251">  r = b-&gt;root;</a>
<a name="ln252">  if (r-&gt;n == 2 * T - 1) {</a>
<a name="ln253">    b-&gt;n_nodes++;</a>
<a name="ln254">    s = (mtnode_t *)xcalloc(1, ILEN);</a>
<a name="ln255">    b-&gt;root = s; s-&gt;level = r-&gt;level + 1; s-&gt;n = 0;</a>
<a name="ln256">    s-&gt;ptr[0] = r;</a>
<a name="ln257">    r-&gt;parent = s;</a>
<a name="ln258">    split_node(b, s, 0);</a>
<a name="ln259">    r = s;</a>
<a name="ln260">  }</a>
<a name="ln261">  marktree_putp_aux(b, r, k);</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">/// INITIATING DELETION PROTOCOL:</a>
<a name="ln265">///</a>
<a name="ln266">/// 1. Construct a valid iterator to the node to delete (argument)</a>
<a name="ln267">/// 2. If an &quot;internal&quot; key. Iterate one step to the left or right,</a>
<a name="ln268">///     which gives an internal key &quot;auxiliary key&quot;.</a>
<a name="ln269">/// 3. Now delete this internal key (intended or auxiliary).</a>
<a name="ln270">///    The leaf node X might become undersized.</a>
<a name="ln271">/// 4. If step two was done: now replace the key that _should_ be</a>
<a name="ln272">///    deleted with the auxiliary key. Adjust relative</a>
<a name="ln273">/// 5. Now &quot;repair&quot; the tree as needed. We always start at a leaf node X.</a>
<a name="ln274">///     - if the node is big enough, terminate</a>
<a name="ln275">///     - if we can steal from the left, steal</a>
<a name="ln276">///     - if we can steal from the right, steal</a>
<a name="ln277">///     - otherwise merge this node with a neighbour. This might make our</a>
<a name="ln278">///       parent undersized. So repeat 5 for the parent.</a>
<a name="ln279">/// 6. If 4 went all the way to the root node. The root node</a>
<a name="ln280">///    might have ended up with size 0. Delete it then.</a>
<a name="ln281">///</a>
<a name="ln282">/// The iterator remains valid, and now points at the key _after_ the deleted</a>
<a name="ln283">/// one.</a>
<a name="ln284">///</a>
<a name="ln285">/// @param rev should be true if we plan to iterate _backwards_ and delete</a>
<a name="ln286">///            stuff before this key. Most of the time this is false (the</a>
<a name="ln287">///            recommended strategy is to always iterate forward)</a>
<a name="ln288">uint64_t marktree_del_itr(MarkTree *b, MarkTreeIter *itr, bool rev)</a>
<a name="ln289">{</a>
<a name="ln290">  int adjustment = 0;</a>
<a name="ln291"> </a>
<a name="ln292">  mtnode_t *cur = itr-&gt;node;</a>
<a name="ln293">  int curi = itr-&gt;i;</a>
<a name="ln294">  uint64_t id = mt_lookup_key(cur-&gt;key[curi]);</a>
<a name="ln295">  // fprintf(stderr, &quot;\nDELET %lu\n&quot;, id);</a>
<a name="ln296"> </a>
<a name="ln297">  mtkey_t raw = rawkey(itr);</a>
<a name="ln298">  uint64_t other = 0;</a>
<a name="ln299">  if (mt_paired(raw)) {</a>
<a name="ln300">    other = mt_lookup_id(raw.ns, raw.id, !mt_end(raw));</a>
<a name="ln301">  }</a>
<a name="ln302"> </a>
<a name="ln303">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln304">    if (rev) {</a>
<a name="ln305">      abort();</a>
<a name="ln306">    } else {</a>
<a name="ln307">      // fprintf(stderr, &quot;INTERNAL %d\n&quot;, cur-&gt;level);</a>
<a name="ln308">      // steal previous node</a>
<a name="ln309">      marktree_itr_prev(b, itr);</a>
<a name="ln310">      adjustment = -1;</a>
<a name="ln311">    }</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  // 3.</a>
<a name="ln315">  mtnode_t *x = itr-&gt;node;</a>
<a name="ln316">  assert(x-&gt;level == 0);</a>
<a name="ln317">  mtkey_t intkey = x-&gt;key[itr-&gt;i];</a>
<a name="ln318">  if (x-&gt;n &gt; itr-&gt;i + 1) {</a>
<a name="ln319">    memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i + 1],</a>
<a name="ln320">            sizeof(mtkey_t) * (size_t)(x-&gt;n - itr-&gt;i - 1));</a>
<a name="ln321">  }</a>
<a name="ln322">  x-&gt;n--;</a>
<a name="ln323"> </a>
<a name="ln324">  // 4.</a>
<a name="ln325">  // if (adjustment == 1) {</a>
<a name="ln326">  //   abort();</a>
<a name="ln327">  // }</a>
<a name="ln328">  if (adjustment == -1) {</a>
<a name="ln329">    int ilvl = itr-&gt;lvl - 1;</a>
<a name="ln330">    const mtnode_t *lnode = x;</a>
<a name="ln331">    do {</a>
<a name="ln332">      const mtnode_t *const p = lnode-&gt;parent;</a>
<a name="ln333">      if (ilvl &lt; 0) {</a>
<a name="ln334">        abort();</a>
<a name="ln335">      }</a>
<a name="ln336">      const int i = itr-&gt;s[ilvl].i;</a>
<a name="ln337">      assert(p-&gt;ptr[i] == lnode);</a>
<a name="ln338">      if (i &gt; 0) {</a>
<a name="ln339">        unrelative(p-&gt;key[i - 1].pos, &amp;intkey.pos);</a>
<a name="ln340">      }</a>
<a name="ln341">      lnode = p;</a>
<a name="ln342">      ilvl--;</a>
<a name="ln343">    } while (lnode != cur);</a>
<a name="ln344"> </a>
<a name="ln345">    mtkey_t deleted = cur-&gt;key[curi];</a>
<a name="ln346">    cur-&gt;key[curi] = intkey;</a>
<a name="ln347">    refkey(b, cur, curi);</a>
<a name="ln348">    relative(intkey.pos, &amp;deleted.pos);</a>
<a name="ln349">    mtnode_t *y = cur-&gt;ptr[curi + 1];</a>
<a name="ln350">    if (deleted.pos.row || deleted.pos.col) {</a>
<a name="ln351">      while (y) {</a>
<a name="ln352">        for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln353">          unrelative(deleted.pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln354">        }</a>
<a name="ln355">        y = y-&gt;level ? y-&gt;ptr[0] : NULL;</a>
<a name="ln356">      }</a>
<a name="ln357">    }</a>
<a name="ln358">    itr-&gt;i--;</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361">  b-&gt;n_keys--;</a>
<a name="ln362">  pmap_del(uint64_t)(b-&gt;id2node, id, NULL);</a>
<a name="ln363"> </a>
<a name="ln364">  // 5.</a>
<a name="ln365">  bool itr_dirty = false;</a>
<a name="ln366">  int rlvl = itr-&gt;lvl - 1;</a>
<a name="ln367">  int *lasti = &amp;itr-&gt;i;</a>
<a name="ln368">  while (x != b-&gt;root) {</a>
<a name="ln369">    assert(rlvl &gt;= 0);</a>
<a name="ln370">    mtnode_t *p = x-&gt;parent;</a>
<a name="ln371">    if (x-&gt;n &gt;= T - 1) {</a>
<a name="ln372">      // we are done, if this node is fine the rest of the tree will be</a>
<a name="ln373">      break;</a>
<a name="ln374">    }</a>
<a name="ln375">    int pi = itr-&gt;s[rlvl].i;</a>
<a name="ln376">    assert(p-&gt;ptr[pi] == x);</a>
<a name="ln377">    if (pi &gt; 0 &amp;&amp; p-&gt;ptr[pi - 1]-&gt;n &gt; T - 1) {</a>
<a name="ln378">      *lasti += 1;</a>
<a name="ln379">      itr_dirty = true;</a>
<a name="ln380">      // steal one key from the left neighbour</a>
<a name="ln381">      pivot_right(b, p, pi - 1);</a>
<a name="ln382">      break;</a>
<a name="ln383">    } else if (pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n &gt; T - 1) {</a>
<a name="ln384">      // steal one key from right neighbour</a>
<a name="ln385">      pivot_left(b, p, pi);</a>
<a name="ln386">      break;</a>
<a name="ln387">    } else if (pi &gt; 0) {</a>
<a name="ln388">      // fprintf(stderr, &quot;LEFT &quot;);</a>
<a name="ln389">      assert(p-&gt;ptr[pi - 1]-&gt;n == T - 1);</a>
<a name="ln390">      // merge with left neighbour</a>
<a name="ln391">      *lasti += T;</a>
<a name="ln392">      x = merge_node(b, p, pi - 1);</a>
<a name="ln393">      if (lasti == &amp;itr-&gt;i) {</a>
<a name="ln394">        // TRICKY: we merged the node the iterator was on</a>
<a name="ln395">        itr-&gt;node = x;</a>
<a name="ln396">      }</a>
<a name="ln397">      itr-&gt;s[rlvl].i--;</a>
<a name="ln398">      itr_dirty = true;</a>
<a name="ln399">    } else {</a>
<a name="ln400">      // fprintf(stderr, &quot;RIGHT &quot;);</a>
<a name="ln401">      assert(pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n == T - 1);</a>
<a name="ln402">      merge_node(b, p, pi);</a>
<a name="ln403">      // no iter adjustment needed</a>
<a name="ln404">    }</a>
<a name="ln405">    lasti = &amp;itr-&gt;s[rlvl].i;</a>
<a name="ln406">    rlvl--;</a>
<a name="ln407">    x = p;</a>
<a name="ln408">  }</a>
<a name="ln409"> </a>
<a name="ln410">  // 6.</a>
<a name="ln411">  if (b-&gt;root-&gt;n == 0) {</a>
<a name="ln412">    if (itr-&gt;lvl &gt; 0) {</a>
<a name="ln413">      memmove(itr-&gt;s, itr-&gt;s + 1, (size_t)(itr-&gt;lvl - 1) * sizeof(*itr-&gt;s));</a>
<a name="ln414">      itr-&gt;lvl--;</a>
<a name="ln415">    }</a>
<a name="ln416">    if (b-&gt;root-&gt;level) {</a>
<a name="ln417">      mtnode_t *oldroot = b-&gt;root;</a>
<a name="ln418">      b-&gt;root = b-&gt;root-&gt;ptr[0];</a>
<a name="ln419">      b-&gt;root-&gt;parent = NULL;</a>
<a name="ln420">      xfree(oldroot);</a>
<a name="ln421">    } else {</a>
<a name="ln422">      // no items, nothing for iterator to point to</a>
<a name="ln423">      // not strictly needed, should handle delete right-most mark anyway</a>
<a name="ln424">      itr-&gt;node = NULL;</a>
<a name="ln425">    }</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  if (itr-&gt;node &amp;&amp; itr_dirty) {</a>
<a name="ln429">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  // BONUS STEP: fix the iterator, so that it points to the key afterwards</a>
<a name="ln433">  // TODO(bfredl): with &quot;rev&quot; should point before</a>
<a name="ln434">  // if (adjustment == 1) {</a>
<a name="ln435">  //   abort();</a>
<a name="ln436">  // }</a>
<a name="ln437">  if (adjustment == -1) {</a>
<a name="ln438">    // tricky: we stand at the deleted space in the previous leaf node.</a>
<a name="ln439">    // But the inner key is now the previous key we stole, so we need</a>
<a name="ln440">    // to skip that one as well.</a>
<a name="ln441">    marktree_itr_next(b, itr);</a>
<a name="ln442">    marktree_itr_next(b, itr);</a>
<a name="ln443">  } else {</a>
<a name="ln444">    if (itr-&gt;node &amp;&amp; itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln445">      // we deleted the last key of a leaf node</a>
<a name="ln446">      // go to the inner key after that.</a>
<a name="ln447">      assert(itr-&gt;node-&gt;level == 0);</a>
<a name="ln448">      marktree_itr_next(b, itr);</a>
<a name="ln449">    }</a>
<a name="ln450">  }</a>
<a name="ln451"> </a>
<a name="ln452">  return other;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">static mtnode_t *merge_node(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln456">{</a>
<a name="ln457">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln458"> </a>
<a name="ln459">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln460">  refkey(b, x, x-&gt;n);</a>
<a name="ln461">  if (i &gt; 0) {</a>
<a name="ln462">    relative(p-&gt;key[i - 1].pos, &amp;x-&gt;key[x-&gt;n].pos);</a>
<a name="ln463">  }</a>
<a name="ln464"> </a>
<a name="ln465">  memmove(&amp;x-&gt;key[x-&gt;n + 1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln466">  for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln467">    refkey(b, x, x-&gt;n + 1 + k);</a>
<a name="ln468">    unrelative(x-&gt;key[x-&gt;n].pos, &amp;x-&gt;key[x-&gt;n + 1 + k].pos);</a>
<a name="ln469">  }</a>
<a name="ln470">  if (x-&gt;level) {</a>
<a name="ln471">    memmove(&amp;x-&gt;ptr[x-&gt;n + 1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln472">    for (int k = 0; k &lt; y-&gt;n + 1; k++) {</a>
<a name="ln473">      x-&gt;ptr[x-&gt;n + k + 1]-&gt;parent = x;</a>
<a name="ln474">    }</a>
<a name="ln475">  }</a>
<a name="ln476">  x-&gt;n += y-&gt;n + 1;</a>
<a name="ln477">  memmove(&amp;p-&gt;key[i], &amp;p-&gt;key[i + 1], (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t));</a>
<a name="ln478">  memmove(&amp;p-&gt;ptr[i + 1], &amp;p-&gt;ptr[i + 2],</a>
<a name="ln479">          (size_t)(p-&gt;n - i - 1) * sizeof(mtkey_t *));</a>
<a name="ln480">  p-&gt;n--;</a>
<a name="ln481">  xfree(y);</a>
<a name="ln482">  b-&gt;n_nodes--;</a>
<a name="ln483">  return x;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">// TODO(bfredl): as a potential &quot;micro&quot; optimization, pivoting should balance</a>
<a name="ln487">// the two nodes instead of stealing just one key</a>
<a name="ln488">static void pivot_right(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln489">{</a>
<a name="ln490">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln491">  memmove(&amp;y-&gt;key[1], y-&gt;key, (size_t)y-&gt;n * sizeof(mtkey_t));</a>
<a name="ln492">  if (y-&gt;level) {</a>
<a name="ln493">    memmove(&amp;y-&gt;ptr[1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(mtnode_t *));</a>
<a name="ln494">  }</a>
<a name="ln495">  y-&gt;key[0] = p-&gt;key[i];</a>
<a name="ln496">  refkey(b, y, 0);</a>
<a name="ln497">  p-&gt;key[i] = x-&gt;key[x-&gt;n - 1];</a>
<a name="ln498">  refkey(b, p, i);</a>
<a name="ln499">  if (x-&gt;level) {</a>
<a name="ln500">    y-&gt;ptr[0] = x-&gt;ptr[x-&gt;n];</a>
<a name="ln501">    y-&gt;ptr[0]-&gt;parent = y;</a>
<a name="ln502">  }</a>
<a name="ln503">  x-&gt;n--;</a>
<a name="ln504">  y-&gt;n++;</a>
<a name="ln505">  if (i &gt; 0) {</a>
<a name="ln506">    unrelative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln507">  }</a>
<a name="ln508">  relative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln509">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln510">    unrelative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln511">  }</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">static void pivot_left(MarkTree *b, mtnode_t *p, int i)</a>
<a name="ln515">{</a>
<a name="ln516">  mtnode_t *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln517"> </a>
<a name="ln518">  // reverse from how we &quot;always&quot; do it. but pivot_left</a>
<a name="ln519">  // is just the inverse of pivot_right, so reverse it literally.</a>
<a name="ln520">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln521">    relative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln522">  }</a>
<a name="ln523">  unrelative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln524">  if (i &gt; 0) {</a>
<a name="ln525">    relative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln526">  }</a>
<a name="ln527"> </a>
<a name="ln528">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln529">  refkey(b, x, x-&gt;n);</a>
<a name="ln530">  p-&gt;key[i] = y-&gt;key[0];</a>
<a name="ln531">  refkey(b, p, i);</a>
<a name="ln532">  if (x-&gt;level) {</a>
<a name="ln533">    x-&gt;ptr[x-&gt;n + 1] = y-&gt;ptr[0];</a>
<a name="ln534">    x-&gt;ptr[x-&gt;n + 1]-&gt;parent = x;</a>
<a name="ln535">  }</a>
<a name="ln536">  memmove(y-&gt;key, &amp;y-&gt;key[1], (size_t)(y-&gt;n - 1) * sizeof(mtkey_t));</a>
<a name="ln537">  if (y-&gt;level) {</a>
<a name="ln538">    memmove(y-&gt;ptr, &amp;y-&gt;ptr[1], (size_t)y-&gt;n * sizeof(mtnode_t *));</a>
<a name="ln539">  }</a>
<a name="ln540">  x-&gt;n++;</a>
<a name="ln541">  y-&gt;n--;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">/// frees all mem, resets tree to valid empty state</a>
<a name="ln545">void marktree_clear(MarkTree *b)</a>
<a name="ln546">{</a>
<a name="ln547">  if (b-&gt;root) {</a>
<a name="ln548">    marktree_free_node(b-&gt;root);</a>
<a name="ln549">    b-&gt;root = NULL;</a>
<a name="ln550">  }</a>
<a name="ln551">  if (b-&gt;id2node-&gt;table.keys) {</a>
<a name="ln552">    map_destroy(uint64_t, b-&gt;id2node);</a>
<a name="ln553">    *b-&gt;id2node = (PMap(uint64_t)) MAP_INIT;</a>
<a name="ln554">  }</a>
<a name="ln555">  b-&gt;n_keys = 0;</a>
<a name="ln556">  b-&gt;n_nodes = 0;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">void marktree_free_node(mtnode_t *x)</a>
<a name="ln560">{</a>
<a name="ln561">  if (x-&gt;level) {</a>
<a name="ln562">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln563">      marktree_free_node(x-&gt;ptr[i]);</a>
<a name="ln564">    }</a>
<a name="ln565">  }</a>
<a name="ln566">  xfree(x);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">/// NB: caller must check not pair!</a>
<a name="ln570">void marktree_revise(MarkTree *b, MarkTreeIter *itr, uint8_t decor_level, mtkey_t key)</a>
<a name="ln571">{</a>
<a name="ln572">  // TODO(bfredl): clean up this mess and re-instantiate &amp;= and |= forms</a>
<a name="ln573">  // once we upgrade to a non-broken version of gcc in functionaltest-lua CI</a>
<a name="ln574">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags &amp; (uint16_t) ~MT_FLAG_DECOR_MASK);</a>
<a name="ln575">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags</a>
<a name="ln576">                                 | (uint16_t)(decor_level &lt;&lt; MT_FLAG_DECOR_OFFSET)</a>
<a name="ln577">                                 | (uint16_t)(key.flags &amp; MT_FLAG_DECOR_MASK));</a>
<a name="ln578">  rawkey(itr).decor_full = key.decor_full;</a>
<a name="ln579">  rawkey(itr).hl_id = key.hl_id;</a>
<a name="ln580">  rawkey(itr).priority = key.priority;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">void marktree_move(MarkTree *b, MarkTreeIter *itr, int row, int col)</a>
<a name="ln584">{</a>
<a name="ln585">  mtkey_t key = rawkey(itr);</a>
<a name="ln586">  // TODO(bfredl): optimize when moving a mark within a leaf without moving it</a>
<a name="ln587">  // across neighbours!</a>
<a name="ln588">  marktree_del_itr(b, itr, false);</a>
<a name="ln589">  key.pos = (mtpos_t){ row, col };</a>
<a name="ln590"> </a>
<a name="ln591">  marktree_put_key(b, key);</a>
<a name="ln592">  itr-&gt;node = NULL;  // itr might become invalid by put</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">// itr functions</a>
<a name="ln596"> </a>
<a name="ln597">// TODO(bfredl): static inline?</a>
<a name="ln598">bool marktree_itr_get(MarkTree *b, int32_t row, int col, MarkTreeIter *itr)</a>
<a name="ln599">{</a>
<a name="ln600">  return marktree_itr_get_ext(b, (mtpos_t){ row, col },</a>
<a name="ln601">                              itr, false, false, NULL);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">bool marktree_itr_get_ext(MarkTree *b, mtpos_t p, MarkTreeIter *itr, bool last, bool gravity,</a>
<a name="ln605">                          mtpos_t *oldbase)</a>
<a name="ln606">{</a>
<a name="ln607">  if (b-&gt;n_keys == 0) {</a>
<a name="ln608">    itr-&gt;node = NULL;</a>
<a name="ln609">    return false;</a>
<a name="ln610">  }</a>
<a name="ln611"> </a>
<a name="ln612">  mtkey_t k = { .pos = p, .flags = gravity ? MT_FLAG_RIGHT_GRAVITY : 0 };</a>
<a name="ln613">  if (last &amp;&amp; !gravity) {</a>
<a name="ln614">    k.flags = MT_FLAG_LAST;</a>
<a name="ln615">  }</a>
<a name="ln616">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln617">  itr-&gt;node = b-&gt;root;</a>
<a name="ln618">  itr-&gt;lvl = 0;</a>
<a name="ln619">  if (oldbase) {</a>
<a name="ln620">    oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln621">  }</a>
<a name="ln622">  while (true) {</a>
<a name="ln623">    itr-&gt;i = marktree_getp_aux(itr-&gt;node, k, 0) + 1;</a>
<a name="ln624"> </a>
<a name="ln625">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln626">      break;</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln630">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln631"> </a>
<a name="ln632">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln633">      compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln634">      relative(itr-&gt;node-&gt;key[itr-&gt;i - 1].pos, &amp;k.pos);</a>
<a name="ln635">    }</a>
<a name="ln636">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln637">    itr-&gt;lvl++;</a>
<a name="ln638">    if (oldbase) {</a>
<a name="ln639">      oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln640">    }</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  if (last) {</a>
<a name="ln644">    return marktree_itr_prev(b, itr);</a>
<a name="ln645">  } else if (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln646">    return marktree_itr_next(b, itr);</a>
<a name="ln647">  }</a>
<a name="ln648">  return true;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">bool marktree_itr_first(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln652">{</a>
<a name="ln653">  itr-&gt;node = b-&gt;root;</a>
<a name="ln654">  if (b-&gt;n_keys == 0) {</a>
<a name="ln655">    return false;</a>
<a name="ln656">  }</a>
<a name="ln657"> </a>
<a name="ln658">  itr-&gt;i = 0;</a>
<a name="ln659">  itr-&gt;lvl = 0;</a>
<a name="ln660">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln661">  while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln662">    itr-&gt;s[itr-&gt;lvl].i = 0;</a>
<a name="ln663">    itr-&gt;s[itr-&gt;lvl].oldcol = 0;</a>
<a name="ln664">    itr-&gt;lvl++;</a>
<a name="ln665">    itr-&gt;node = itr-&gt;node-&gt;ptr[0];</a>
<a name="ln666">  }</a>
<a name="ln667">  return true;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">// gives the first key that is greater or equal to p</a>
<a name="ln671">int marktree_itr_last(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln672">{</a>
<a name="ln673">  if (b-&gt;n_keys == 0) {</a>
<a name="ln674">    itr-&gt;node = NULL;</a>
<a name="ln675">    return false;</a>
<a name="ln676">  }</a>
<a name="ln677">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln678">  itr-&gt;node = b-&gt;root;</a>
<a name="ln679">  itr-&gt;lvl = 0;</a>
<a name="ln680">  while (true) {</a>
<a name="ln681">    itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln682"> </a>
<a name="ln683">    if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln684">      break;</a>
<a name="ln685">    }</a>
<a name="ln686"> </a>
<a name="ln687">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln688">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln689"> </a>
<a name="ln690">    assert(itr-&gt;i &gt; 0);</a>
<a name="ln691">    compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln692"> </a>
<a name="ln693">    itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln694">    itr-&gt;lvl++;</a>
<a name="ln695">  }</a>
<a name="ln696">  itr-&gt;i--;</a>
<a name="ln697">  return true;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">// TODO(bfredl): static inline</a>
<a name="ln701">bool marktree_itr_next(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln702">{</a>
<a name="ln703">  return marktree_itr_next_skip(b, itr, false, NULL);</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">static bool marktree_itr_next_skip(MarkTree *b, MarkTreeIter *itr, bool skip, mtpos_t oldbase[])</a>
<a name="ln707">{</a>
<a name="ln708">  if (!itr-&gt;node) {</a>
<a name="ln709">    return false;</a>
<a name="ln710">  }</a>
<a name="ln711">  itr-&gt;i++;</a>
<a name="ln712">  if (itr-&gt;node-&gt;level == 0 || skip) {</a>
<a name="ln713">    if (itr-&gt;i &lt; itr-&gt;node-&gt;n) {</a>
<a name="ln714">      // TODO(bfredl): this is the common case,</a>
<a name="ln715">      // and could be handled by inline wrapper</a>
<a name="ln716">      return true;</a>
<a name="ln717">    }</a>
<a name="ln718">    // we ran out of non-internal keys. Go up until we find an internal key</a>
<a name="ln719">    while (itr-&gt;i &gt;= itr-&gt;node-&gt;n) {</a>
<a name="ln720">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln721">      if (itr-&gt;node == NULL) {</a>
<a name="ln722">        return false;</a>
<a name="ln723">      }</a>
<a name="ln724">      itr-&gt;lvl--;</a>
<a name="ln725">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln726">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln727">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i - 1].pos.row;</a>
<a name="ln728">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln729">      }</a>
<a name="ln730">    }</a>
<a name="ln731">  } else {</a>
<a name="ln732">    // we stood at an &quot;internal&quot; key. Go down to the first non-internal</a>
<a name="ln733">    // key after it.</a>
<a name="ln734">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln735">      // internal key, there is always a child after</a>
<a name="ln736">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln737">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln738">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln739">      }</a>
<a name="ln740">      if (oldbase &amp;&amp; itr-&gt;i == 0) {</a>
<a name="ln741">        oldbase[itr-&gt;lvl + 1] = oldbase[itr-&gt;lvl];</a>
<a name="ln742">      }</a>
<a name="ln743">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln744">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln745">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln746">      itr-&gt;i = 0;</a>
<a name="ln747">      itr-&gt;lvl++;</a>
<a name="ln748">    }</a>
<a name="ln749">  }</a>
<a name="ln750">  return true;</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">bool marktree_itr_prev(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln754">{</a>
<a name="ln755">  if (!itr-&gt;node) {</a>
<a name="ln756">    return false;</a>
<a name="ln757">  }</a>
<a name="ln758">  if (itr-&gt;node-&gt;level == 0) {</a>
<a name="ln759">    itr-&gt;i--;</a>
<a name="ln760">    if (itr-&gt;i &gt;= 0) {</a>
<a name="ln761">      // TODO(bfredl): this is the common case,</a>
<a name="ln762">      // and could be handled by inline wrapper</a>
<a name="ln763">      return true;</a>
<a name="ln764">    }</a>
<a name="ln765">    // we ran out of non-internal keys. Go up until we find a non-internal key</a>
<a name="ln766">    while (itr-&gt;i &lt; 0) {</a>
<a name="ln767">      itr-&gt;node = itr-&gt;node-&gt;parent;</a>
<a name="ln768">      if (itr-&gt;node == NULL) {</a>
<a name="ln769">        return false;</a>
<a name="ln770">      }</a>
<a name="ln771">      itr-&gt;lvl--;</a>
<a name="ln772">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i - 1;</a>
<a name="ln773">      if (itr-&gt;i &gt;= 0) {</a>
<a name="ln774">        itr-&gt;pos.row -= itr-&gt;node-&gt;key[itr-&gt;i].pos.row;</a>
<a name="ln775">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln776">      }</a>
<a name="ln777">    }</a>
<a name="ln778">  } else {</a>
<a name="ln779">    // we stood at an &quot;internal&quot; key. Go down to the last non-internal</a>
<a name="ln780">    // key before it.</a>
<a name="ln781">    while (itr-&gt;node-&gt;level &gt; 0) {</a>
<a name="ln782">      // internal key, there is always a child before</a>
<a name="ln783">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln784">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln785">        compose(&amp;itr-&gt;pos, itr-&gt;node-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln786">      }</a>
<a name="ln787">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln788">      assert(itr-&gt;node-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;node);</a>
<a name="ln789">      itr-&gt;node = itr-&gt;node-&gt;ptr[itr-&gt;i];</a>
<a name="ln790">      itr-&gt;i = itr-&gt;node-&gt;n;</a>
<a name="ln791">      itr-&gt;lvl++;</a>
<a name="ln792">    }</a>
<a name="ln793">    itr-&gt;i--;</a>
<a name="ln794">  }</a>
<a name="ln795">  return true;</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">void marktree_itr_rewind(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln799">{</a>
<a name="ln800">  if (!itr-&gt;node) {</a>
<a name="ln801">    return;</a>
<a name="ln802">  }</a>
<a name="ln803">  if (itr-&gt;node-&gt;level) {</a>
<a name="ln804">    marktree_itr_prev(b, itr);</a>
<a name="ln805">  }</a>
<a name="ln806">  itr-&gt;i = 0;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">bool marktree_itr_node_done(MarkTreeIter *itr)</a>
<a name="ln810">{</a>
<a name="ln811">  return !itr-&gt;node || itr-&gt;i == itr-&gt;node-&gt;n - 1;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">mtpos_t marktree_itr_pos(MarkTreeIter *itr)</a>
<a name="ln815">{</a>
<a name="ln816">  mtpos_t pos = rawkey(itr).pos;</a>
<a name="ln817">  unrelative(itr-&gt;pos, &amp;pos);</a>
<a name="ln818">  return pos;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">mtkey_t marktree_itr_current(MarkTreeIter *itr)</a>
<a name="ln822">{</a>
<a name="ln823">  if (itr-&gt;node) {</a>
<a name="ln824">    mtkey_t key = rawkey(itr);</a>
<a name="ln825">    key.pos = marktree_itr_pos(itr);</a>
<a name="ln826">    return key;</a>
<a name="ln827">  }</a>
<a name="ln828">  return MT_INVALID_KEY;</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">static bool itr_eq(MarkTreeIter *itr1, MarkTreeIter *itr2)</a>
<a name="ln832">{</a>
<a name="ln833">  return (&amp;rawkey(itr1) == &amp;rawkey(itr2));</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">static void itr_swap(MarkTreeIter *itr1, MarkTreeIter *itr2)</a>
<a name="ln837">{</a>
<a name="ln838">  mtkey_t key1 = rawkey(itr1);</a>
<a name="ln839">  mtkey_t key2 = rawkey(itr2);</a>
<a name="ln840">  rawkey(itr1) = key2;</a>
<a name="ln841">  rawkey(itr1).pos = key1.pos;</a>
<a name="ln842">  rawkey(itr2) = key1;</a>
<a name="ln843">  rawkey(itr2).pos = key2.pos;</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">bool marktree_splice(MarkTree *b, int32_t start_line, int start_col, int old_extent_line,</a>
<a name="ln847">                     int old_extent_col, int new_extent_line, int new_extent_col)</a>
<a name="ln848">{</a>
<a name="ln849">  mtpos_t start = { start_line, start_col };</a>
<a name="ln850">  mtpos_t old_extent = { old_extent_line, old_extent_col };</a>
<a name="ln851">  mtpos_t new_extent = { new_extent_line, new_extent_col };</a>
<a name="ln852"> </a>
<a name="ln853">  bool may_delete = (old_extent.row != 0 || old_extent.col != 0);</a>
<a name="ln854">  bool same_line = old_extent.row == 0 &amp;&amp; new_extent.row == 0;</a>
<a name="ln855">  unrelative(start, &amp;old_extent);</a>
<a name="ln856">  unrelative(start, &amp;new_extent);</a>
<a name="ln857">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln858">  MarkTreeIter enditr[1] = { 0 };</a>
<a name="ln859"> </a>
<a name="ln860">  mtpos_t oldbase[MT_MAX_DEPTH] = { 0 };</a>
<a name="ln861"> </a>
<a name="ln862">  marktree_itr_get_ext(b, start, itr, false, true, oldbase);</a>
<a name="ln863">  if (!itr-&gt;node) {</a>
<a name="ln864">    // den e FÃ„RDIG</a>
<a name="ln865">    return false;</a>
<a name="ln866">  }</a>
<a name="ln867">  mtpos_t delta = { new_extent.row - old_extent.row,</a>
<a name="ln868">                    new_extent.col - old_extent.col };</a>
<a name="ln869"> </a>
<a name="ln870">  if (may_delete) {</a>
<a name="ln871">    mtpos_t ipos = marktree_itr_pos(itr);</a>
<a name="ln872">    if (!pos_leq(old_extent, ipos)</a>
<a name="ln873">        || (old_extent.row == ipos.row &amp;&amp; old_extent.col == ipos.col</a>
<a name="ln874">            &amp;&amp; !mt_right(rawkey(itr)))) {</a>
<a name="ln875">      marktree_itr_get_ext(b, old_extent, enditr, true, true, NULL);</a>
<a name="ln876">      assert(enditr-&gt;node);</a>
<a name="ln877">      // &quot;assert&quot; (itr &lt;= enditr)</a>
<a name="ln878">    } else {</a>
<a name="ln879">      may_delete = false;</a>
<a name="ln880">    }</a>
<a name="ln881">  }</a>
<a name="ln882"> </a>
<a name="ln883">  bool past_right = false;</a>
<a name="ln884">  bool moved = false;</a>
<a name="ln885"> </a>
<a name="ln886">  // Follow the general strategy of messing things up and fix them later</a>
<a name="ln887">  // &quot;oldbase&quot; carries the information needed to calculate old position of</a>
<a name="ln888">  // children.</a>
<a name="ln889">  if (may_delete) {</a>
<a name="ln890">    while (itr-&gt;node &amp;&amp; !past_right) {</a>
<a name="ln891">      mtpos_t loc_start = start;</a>
<a name="ln892">      mtpos_t loc_old = old_extent;</a>
<a name="ln893">      relative(itr-&gt;pos, &amp;loc_start);</a>
<a name="ln894"> </a>
<a name="ln895">      relative(oldbase[itr-&gt;lvl], &amp;loc_old);</a>
<a name="ln896"> </a>
<a name="ln897">continue_same_node:</a>
<a name="ln898">      // NB: strictly should be less than the right gravity of loc_old, but</a>
<a name="ln899">      // the iter comparison below will already break on that.</a>
<a name="ln900">      if (!pos_leq(rawkey(itr).pos, loc_old)) {</a>
<a name="ln901">        break;</a>
<a name="ln902">      }</a>
<a name="ln903"> </a>
<a name="ln904">      if (mt_right(rawkey(itr))) {</a>
<a name="ln905">        while (!itr_eq(itr, enditr)</a>
<a name="ln906">               &amp;&amp; mt_right(rawkey(enditr))) {</a>
<a name="ln907">          marktree_itr_prev(b, enditr);</a>
<a name="ln908">        }</a>
<a name="ln909">        if (!mt_right(rawkey(enditr))) {</a>
<a name="ln910">          itr_swap(itr, enditr);</a>
<a name="ln911">          refkey(b, itr-&gt;node, itr-&gt;i);</a>
<a name="ln912">          refkey(b, enditr-&gt;node, enditr-&gt;i);</a>
<a name="ln913">        } else {</a>
<a name="ln914">          past_right = true;  // NOLINT</a>
<a name="ln915">          (void)past_right;</a>
<a name="ln916">          break;</a>
<a name="ln917">        }</a>
<a name="ln918">      }</a>
<a name="ln919"> </a>
<a name="ln920">      if (itr_eq(itr, enditr)) {</a>
<a name="ln921">        // actually, will be past_right after this key</a>
<a name="ln922">        past_right = true;</a>
<a name="ln923">      }</a>
<a name="ln924"> </a>
<a name="ln925">      moved = true;</a>
<a name="ln926">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln927">        oldbase[itr-&gt;lvl + 1] = rawkey(itr).pos;</a>
<a name="ln928">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln929">        rawkey(itr).pos = loc_start;</a>
<a name="ln930">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln931">      } else {</a>
<a name="ln932">        rawkey(itr).pos = loc_start;</a>
<a name="ln933">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n - 1) {</a>
<a name="ln934">          itr-&gt;i++;</a>
<a name="ln935">          if (!past_right) {</a>
<a name="ln936">            goto continue_same_node;</a>
<a name="ln937">          }</a>
<a name="ln938">        } else {</a>
<a name="ln939">          marktree_itr_next(b, itr);</a>
<a name="ln940">        }</a>
<a name="ln941">      }</a>
<a name="ln942">    }</a>
<a name="ln943">    while (itr-&gt;node) {</a>
<a name="ln944">      mtpos_t loc_new = new_extent;</a>
<a name="ln945">      relative(itr-&gt;pos, &amp;loc_new);</a>
<a name="ln946">      mtpos_t limit = old_extent;</a>
<a name="ln947"> </a>
<a name="ln948">      relative(oldbase[itr-&gt;lvl], &amp;limit);</a>
<a name="ln949"> </a>
<a name="ln950">past_continue_same_node:</a>
<a name="ln951"> </a>
<a name="ln952">      if (pos_leq(limit, rawkey(itr).pos)) {</a>
<a name="ln953">        break;</a>
<a name="ln954">      }</a>
<a name="ln955"> </a>
<a name="ln956">      mtpos_t oldpos = rawkey(itr).pos;</a>
<a name="ln957">      rawkey(itr).pos = loc_new;</a>
<a name="ln958">      moved = true;</a>
<a name="ln959">      if (itr-&gt;node-&gt;level) {</a>
<a name="ln960">        oldbase[itr-&gt;lvl + 1] = oldpos;</a>
<a name="ln961">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln962"> </a>
<a name="ln963">        marktree_itr_next_skip(b, itr, false, oldbase);</a>
<a name="ln964">      } else {</a>
<a name="ln965">        if (itr-&gt;i &lt; itr-&gt;node-&gt;n - 1) {</a>
<a name="ln966">          itr-&gt;i++;</a>
<a name="ln967">          goto past_continue_same_node;</a>
<a name="ln968">        } else {</a>
<a name="ln969">          marktree_itr_next(b, itr);</a>
<a name="ln970">        }</a>
<a name="ln971">      }</a>
<a name="ln972">    }</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  while (itr-&gt;node) {</a>
<a name="ln976">    unrelative(oldbase[itr-&gt;lvl], &amp;rawkey(itr).pos);</a>
<a name="ln977">    int realrow = rawkey(itr).pos.row;</a>
<a name="ln978">    assert(realrow &gt;= old_extent.row);</a>
<a name="ln979">    bool done = false;</a>
<a name="ln980">    if (realrow == old_extent.row) {</a>
<a name="ln981">      if (delta.col) {</a>
<a name="ln982">        rawkey(itr).pos.col += delta.col;</a>
<a name="ln983">        moved = true;</a>
<a name="ln984">      }</a>
<a name="ln985">    } else {</a>
<a name="ln986">      if (same_line) {</a>
<a name="ln987">        // optimization: column only adjustment can skip remaining rows</a>
<a name="ln988">        done = true;</a>
<a name="ln989">      }</a>
<a name="ln990">    }</a>
<a name="ln991">    if (delta.row) {</a>
<a name="ln992">      rawkey(itr).pos.row += delta.row;</a>
<a name="ln993">      moved = true;</a>
<a name="ln994">    }</a>
<a name="ln995">    relative(itr-&gt;pos, &amp;rawkey(itr).pos);</a>
<a name="ln996">    if (done) {</a>
<a name="ln997">      break;</a>
<a name="ln998">    }</a>
<a name="ln999">    marktree_itr_next_skip(b, itr, true, NULL);</a>
<a name="ln1000">  }</a>
<a name="ln1001">  return moved;</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">void marktree_move_region(MarkTree *b, int start_row, colnr_T start_col, int extent_row,</a>
<a name="ln1005">                          colnr_T extent_col, int new_row, colnr_T new_col)</a>
<a name="ln1006">{</a>
<a name="ln1007">  mtpos_t start = { start_row, start_col }, size = { extent_row, extent_col };</a>
<a name="ln1008">  mtpos_t end = size;</a>
<a name="ln1009">  unrelative(start, &amp;end);</a>
<a name="ln1010">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln1011">  marktree_itr_get_ext(b, start, itr, false, true, NULL);</a>
<a name="ln1012">  kvec_t(mtkey_t) saved = KV_INITIAL_VALUE;</a>
<a name="ln1013">  while (itr-&gt;node) {</a>
<a name="ln1014">    mtkey_t k = marktree_itr_current(itr);</a>
<a name="ln1015">    if (!pos_leq(k.pos, end) || (k.pos.row == end.row &amp;&amp; k.pos.col == end.col</a>
<a name="ln1016">                                 &amp;&amp; mt_right(k))) {</a>
<a name="ln1017">      break;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    relative(start, &amp;k.pos);</a>
<a name="ln1020">    kv_push(saved, k);</a>
<a name="ln1021">    marktree_del_itr(b, itr, false);</a>
<a name="ln1022">  }</a>
<a name="ln1023"> </a>
<a name="ln1024">  marktree_splice(b, start.row, start.col, size.row, size.col, 0, 0);</a>
<a name="ln1025">  mtpos_t new = { new_row, new_col };</a>
<a name="ln1026">  marktree_splice(b, new.row, new.col,</a>
<a name="ln1027">                  0, 0, size.row, size.col);</a>
<a name="ln1028"> </a>
<a name="ln1029">  for (size_t i = 0; i &lt; kv_size(saved); i++) {</a>
<a name="ln1030">    mtkey_t item = kv_A(saved, i);</a>
<a name="ln1031">    unrelative(new, &amp;item.pos);</a>
<a name="ln1032">    marktree_put_key(b, item);</a>
<a name="ln1033">  }</a>
<a name="ln1034">  kv_destroy(saved);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1038">mtkey_t marktree_lookup_ns(MarkTree *b, uint32_t ns, uint32_t id, bool end, MarkTreeIter *itr)</a>
<a name="ln1039">{</a>
<a name="ln1040">  return marktree_lookup(b, mt_lookup_id(ns, id, end), itr);</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1044">mtkey_t marktree_lookup(MarkTree *b, uint64_t id, MarkTreeIter *itr)</a>
<a name="ln1045">{</a>
<a name="ln1046">  mtnode_t *n = pmap_get(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln1047">  if (n == NULL) {</a>
<a name="ln1048">    if (itr) {</a>
<a name="ln1049">      itr-&gt;node = NULL;</a>
<a name="ln1050">    }</a>
<a name="ln1051">    return MT_INVALID_KEY;</a>
<a name="ln1052">  }</a>
<a name="ln1053">  int i = 0;</a>
<a name="ln1054">  for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1055">    if (mt_lookup_key(n-&gt;key[i]) == id) {</a>
<a name="ln1056">      goto found;</a>
<a name="ln1057">    }</a>
<a name="ln1058">  }</a>
<a name="ln1059">  abort();</a>
<a name="ln1060">found: {}</a>
<a name="ln1061">  mtkey_t key = n-&gt;key[i];</a>
<a name="ln1062">  if (itr) {</a>
<a name="ln1063">    itr-&gt;i = i;</a>
<a name="ln1064">    itr-&gt;node = n;</a>
<a name="ln1065">    itr-&gt;lvl = b-&gt;root-&gt;level - n-&gt;level;</a>
<a name="ln1066">  }</a>
<a name="ln1067">  while (n-&gt;parent != NULL) {</a>
<a name="ln1068">    mtnode_t *p = n-&gt;parent;</a>
<a name="ln1069">    for (i = 0; i &lt; p-&gt;n + 1; i++) {</a>
<a name="ln1070">      if (p-&gt;ptr[i] == n) {</a>
<a name="ln1071">        goto found_node;</a>
<a name="ln1072">      }</a>
<a name="ln1073">    }</a>
<a name="ln1074">    abort();</a>
<a name="ln1075">found_node:</a>
<a name="ln1076">    if (itr) {</a>
<a name="ln1077">      itr-&gt;s[b-&gt;root-&gt;level - p-&gt;level].i = i;</a>
<a name="ln1078">    }</a>
<a name="ln1079">    if (i &gt; 0) {</a>
<a name="ln1080">      unrelative(p-&gt;key[i - 1].pos, &amp;key.pos);</a>
<a name="ln1081">    }</a>
<a name="ln1082">    n = p;</a>
<a name="ln1083">  }</a>
<a name="ln1084">  if (itr) {</a>
<a name="ln1085">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln1086">  }</a>
<a name="ln1087">  return key;</a>
<a name="ln1088">}</a>
<a name="ln1089"> </a>
<a name="ln1090">mtpos_t marktree_get_altpos(MarkTree *b, mtkey_t mark, MarkTreeIter *itr)</a>
<a name="ln1091">{</a>
<a name="ln1092">  return marktree_get_alt(b, mark, itr).pos;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">mtkey_t marktree_get_alt(MarkTree *b, mtkey_t mark, MarkTreeIter *itr)</a>
<a name="ln1096">{</a>
<a name="ln1097">  mtkey_t end = MT_INVALID_KEY;</a>
<a name="ln1098">  if (mt_paired(mark)) {</a>
<a name="ln1099">    end = marktree_lookup_ns(b, mark.ns, mark.id, !mt_end(mark), itr);</a>
<a name="ln1100">  }</a>
<a name="ln1101">  return end;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">static void marktree_itr_fix_pos(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1105">{</a>
<a name="ln1106">  itr-&gt;pos = (mtpos_t){ 0, 0 };</a>
<a name="ln1107">  mtnode_t *x = b-&gt;root;</a>
<a name="ln1108">  for (int lvl = 0; lvl &lt; itr-&gt;lvl; lvl++) {</a>
<a name="ln1109">    itr-&gt;s[lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1110">    int i = itr-&gt;s[lvl].i;</a>
<a name="ln1111">    if (i &gt; 0) {</a>
<a name="ln1112">      compose(&amp;itr-&gt;pos, x-&gt;key[i - 1].pos);</a>
<a name="ln1113">    }</a>
<a name="ln1114">    assert(x-&gt;level);</a>
<a name="ln1115">    x = x-&gt;ptr[i];</a>
<a name="ln1116">  }</a>
<a name="ln1117">  assert(x == itr-&gt;node);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">// for unit test</a>
<a name="ln1121">void marktree_put_test(MarkTree *b, uint32_t id, int row, int col, bool right_gravity)</a>
<a name="ln1122">{</a>
<a name="ln1123">  mtkey_t key = { { row, col }, UINT32_MAX, id, 0,</a>
<a name="ln1124">                  mt_flags(right_gravity, 0), 0, NULL };</a>
<a name="ln1125">  marktree_put(b, key, -1, -1, false);</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">// for unit test</a>
<a name="ln1129">bool mt_right_test(mtkey_t key)</a>
<a name="ln1130">{</a>
<a name="ln1131">  return mt_right(key);</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">void marktree_check(MarkTree *b)</a>
<a name="ln1135">{</a>
<a name="ln1136">#ifndef NDEBUG</a>
<a name="ln1137">  if (b-&gt;root == NULL) {</a>
<a name="ln1138">    assert(b-&gt;n_keys == 0);</a>
<a name="ln1139">    assert(b-&gt;n_nodes == 0);</a>
<a name="ln1140">    assert(b-&gt;id2node == NULL || map_size(b-&gt;id2node) == 0);</a>
<a name="ln1141">    return;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  mtpos_t dummy;</a>
<a name="ln1145">  bool last_right = false;</a>
<a name="ln1146">  size_t nkeys = marktree_check_node(b, b-&gt;root, &amp;dummy, &amp;last_right);</a>
<a name="ln1147">  assert(b-&gt;n_keys == nkeys);</a>
<a name="ln1148">  assert(b-&gt;n_keys == map_size(b-&gt;id2node));</a>
<a name="ln1149">#else</a>
<a name="ln1150">  // Do nothing, as assertions are required</a>
<a name="ln1151">  (void)b;</a>
<a name="ln1152">#endif</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">#ifndef NDEBUG</a>
<a name="ln1156">size_t marktree_check_node(MarkTree *b, mtnode_t *x, mtpos_t *last, bool *last_right)</a>
<a name="ln1157">{</a>
<a name="ln1158">  assert(x-&gt;n &lt;= 2 * T - 1);</a>
<a name="ln1159">  // TODO(bfredl): too strict if checking &quot;in repair&quot; post-delete tree.</a>
<a name="ln1160">  assert(x-&gt;n &gt;= (x != b-&gt;root ? T - 1 : 0));</a>
<a name="ln1161">  size_t n_keys = (size_t)x-&gt;n;</a>
<a name="ln1162"> </a>
<a name="ln1163">  for (int i = 0; i &lt; x-&gt;n; i++) {</a>
<a name="ln1164">    if (x-&gt;level) {</a>
<a name="ln1165">      n_keys += marktree_check_node(b, x-&gt;ptr[i], last, last_right);</a>
<a name="ln1166">    } else {</a>
<a name="ln1167">      *last = (mtpos_t) { 0, 0 };</a>
<a name="ln1168">    }</a>
<a name="ln1169">    if (i &gt; 0) {</a>
<a name="ln1170">      unrelative(x-&gt;key[i - 1].pos, last);</a>
<a name="ln1171">    }</a>
<a name="ln1172">    assert(pos_leq(*last, x-&gt;key[i].pos));</a>
<a name="ln1173">    if (last-&gt;row == x-&gt;key[i].pos.row &amp;&amp; last-&gt;col == x-&gt;key[i].pos.col) {</a>
<a name="ln1174">      assert(!*last_right || mt_right(x-&gt;key[i]));</a>
<a name="ln1175">    }</a>
<a name="ln1176">    *last_right = mt_right(x-&gt;key[i]);</a>
<a name="ln1177">    assert(x-&gt;key[i].pos.col &gt;= 0);</a>
<a name="ln1178">    assert(pmap_get(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i])) == x);</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  if (x-&gt;level) {</a>
<a name="ln1182">    n_keys += marktree_check_node(b, x-&gt;ptr[x-&gt;n], last, last_right);</a>
<a name="ln1183">    unrelative(x-&gt;key[x-&gt;n - 1].pos, last);</a>
<a name="ln1184"> </a>
<a name="ln1185">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln1186">      assert(x-&gt;ptr[i]-&gt;parent == x);</a>
<a name="ln1187">      assert(x-&gt;ptr[i]-&gt;level == x-&gt;level - 1);</a>
<a name="ln1188">      // PARANOIA: check no double node ref</a>
<a name="ln1189">      for (int j = 0; j &lt; i; j++) {</a>
<a name="ln1190">        assert(x-&gt;ptr[i] != x-&gt;ptr[j]);</a>
<a name="ln1191">      }</a>
<a name="ln1192">    }</a>
<a name="ln1193">  } else if (x-&gt;n &gt; 0) {</a>
<a name="ln1194">    *last = x-&gt;key[x-&gt;n - 1].pos;</a>
<a name="ln1195">  }</a>
<a name="ln1196">  return n_keys;</a>
<a name="ln1197">}</a>
<a name="ln1198">#endif</a>
<a name="ln1199"> </a>
<a name="ln1200">char *mt_inspect_rec(MarkTree *b)</a>
<a name="ln1201">{</a>
<a name="ln1202">  garray_T ga;</a>
<a name="ln1203">  ga_init(&amp;ga, (int)sizeof(char), 80);</a>
<a name="ln1204">  mtpos_t p = { 0, 0 };</a>
<a name="ln1205">  mt_inspect_node(b, &amp;ga, b-&gt;root, p);</a>
<a name="ln1206">  return ga.ga_data;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">void mt_inspect_node(MarkTree *b, garray_T *ga, mtnode_t *n, mtpos_t off)</a>
<a name="ln1210">{</a>
<a name="ln1211">  static char buf[1024];</a>
<a name="ln1212">  ga_concat(ga, &quot;[&quot;);</a>
<a name="ln1213">  if (n-&gt;level) {</a>
<a name="ln1214">    mt_inspect_node(b, ga, n-&gt;ptr[0], off);</a>
<a name="ln1215">  }</a>
<a name="ln1216">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1217">    mtpos_t p = n-&gt;key[i].pos;</a>
<a name="ln1218">    unrelative(off, &amp;p);</a>
<a name="ln1219">    snprintf(buf, sizeof(buf), &quot;%d/%d&quot;, p.row, p.col);</a>
<a name="ln1220">    ga_concat(ga, buf);</a>
<a name="ln1221">    if (n-&gt;level) {</a>
<a name="ln1222">      mt_inspect_node(b, ga, n-&gt;ptr[i + 1], p);</a>
<a name="ln1223">    } else {</a>
<a name="ln1224">      ga_concat(ga, &quot;,&quot;);</a>
<a name="ln1225">    }</a>
<a name="ln1226">  }</a>
<a name="ln1227">  ga_concat(ga, &quot;]&quot;);</a>
<a name="ln1228">}</a>
</code></pre>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memcpy' function will lead to underflow of the buffer 'z-&gt;key'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>