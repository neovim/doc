<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>userfunc.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// User defined function support</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;lauxlib.h&quot;</a>
<a name="ln14">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln15">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln16">#include &quot;nvim/charset.h&quot;</a>
<a name="ln17">#include &quot;nvim/cmdexpand_defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/debugger.h&quot;</a>
<a name="ln19">#include &quot;nvim/eval.h&quot;</a>
<a name="ln20">#include &quot;nvim/eval/encode.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval/funcs.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln24">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln25">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln32">#include &quot;nvim/globals.h&quot;</a>
<a name="ln33">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln34">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln35">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln36">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln37">#include &quot;nvim/macros.h&quot;</a>
<a name="ln38">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln39">#include &quot;nvim/memory.h&quot;</a>
<a name="ln40">#include &quot;nvim/message.h&quot;</a>
<a name="ln41">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln42">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln43">#include &quot;nvim/path.h&quot;</a>
<a name="ln44">#include &quot;nvim/profile.h&quot;</a>
<a name="ln45">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln46">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln47">#include &quot;nvim/search.h&quot;</a>
<a name="ln48">#include &quot;nvim/strings.h&quot;</a>
<a name="ln49">#include &quot;nvim/types.h&quot;</a>
<a name="ln50">#include &quot;nvim/ui.h&quot;</a>
<a name="ln51">#include &quot;nvim/vim.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln54"># include &quot;eval/userfunc.c.generated.h&quot;</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">/// structure used as item in &quot;fc_defer&quot;</a>
<a name="ln58">typedef struct {</a>
<a name="ln59">  char *dr_name;  ///&lt; function name, allocated</a>
<a name="ln60">  typval_T dr_argvars[MAX_FUNC_ARGS + 1];</a>
<a name="ln61">  int dr_argcount;</a>
<a name="ln62">} defer_T;</a>
<a name="ln63"> </a>
<a name="ln64">static hashtab_T func_hashtab;</a>
<a name="ln65"> </a>
<a name="ln66">// Used by get_func_tv()</a>
<a name="ln67">static garray_T funcargs = GA_EMPTY_INIT_VALUE;</a>
<a name="ln68"> </a>
<a name="ln69">// pointer to funccal for currently active function</a>
<a name="ln70">static funccall_T *current_funccal = NULL;</a>
<a name="ln71"> </a>
<a name="ln72">// Pointer to list of previously used funccal, still around because some</a>
<a name="ln73">// item in it is still being used.</a>
<a name="ln74">static funccall_T *previous_funccal = NULL;</a>
<a name="ln75"> </a>
<a name="ln76">static const char *e_unknown_function_str = N_(&quot;E117: Unknown function: %s&quot;);</a>
<a name="ln77">static const char *e_funcexts = N_(&quot;E122: Function %s already exists, add ! to replace it&quot;);</a>
<a name="ln78">static const char *e_funcdict = N_(&quot;E717: Dictionary entry already exists&quot;);</a>
<a name="ln79">static const char *e_funcref = N_(&quot;E718: Funcref required&quot;);</a>
<a name="ln80">static const char *e_nofunc = N_(&quot;E130: Unknown function: %s&quot;);</a>
<a name="ln81">static const char e_function_list_was_modified[]</a>
<a name="ln82">  = N_(&quot;E454: Function list was modified&quot;);</a>
<a name="ln83">static const char e_function_nesting_too_deep[]</a>
<a name="ln84">  = N_(&quot;E1058: Function nesting too deep&quot;);</a>
<a name="ln85">static const char e_no_white_space_allowed_before_str_str[]</a>
<a name="ln86">  = N_(&quot;E1068: No white space allowed before '%s': %s&quot;);</a>
<a name="ln87">static const char e_missing_heredoc_end_marker_str[]</a>
<a name="ln88">  = N_(&quot;E1145: Missing heredoc end marker: %s&quot;);</a>
<a name="ln89">static const char e_cannot_use_partial_with_dictionary_for_defer[]</a>
<a name="ln90">  = N_(&quot;E1300: Cannot use a partial with dictionary for :defer&quot;);</a>
<a name="ln91"> </a>
<a name="ln92">void func_init(void)</a>
<a name="ln93">{</a>
<a name="ln94">  hash_init(&amp;func_hashtab);</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">/// Return the function hash table</a>
<a name="ln98">hashtab_T *func_tbl_get(void)</a>
<a name="ln99">{</a>
<a name="ln100">  return &amp;func_hashtab;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/// Get function arguments.</a>
<a name="ln104">static int get_function_args(char **argp, char endchar, garray_T *newargs, int *varargs,</a>
<a name="ln105">                             garray_T *default_args, bool skip)</a>
<a name="ln106">{</a>
<a name="ln107">  bool mustend = false;</a>
<a name="ln108">  char *arg = *argp;</a>
<a name="ln109">  char *p = arg;</a>
<a name="ln110">  uint8_t c;</a>
<a name="ln111">  int i;</a>
<a name="ln112"> </a>
<a name="ln113">  if (newargs != NULL) {</a>
<a name="ln114">    ga_init(newargs, (int)sizeof(char *), 3);</a>
<a name="ln115">  }</a>
<a name="ln116">  if (default_args != NULL) {</a>
<a name="ln117">    ga_init(default_args, (int)sizeof(char *), 3);</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  if (varargs != NULL) {</a>
<a name="ln121">    *varargs = false;</a>
<a name="ln122">  }</a>
<a name="ln123"> </a>
<a name="ln124">  // Isolate the arguments: &quot;arg1, arg2, ...)&quot;</a>
<a name="ln125">  bool any_default = false;</a>
<a name="ln126">  while (*p != endchar) {</a>
<a name="ln127">    if (p[0] == '.' &amp;&amp; p[1] == '.' &amp;&amp; p[2] == '.') {</a>
<a name="ln128">      if (varargs != NULL) {</a>
<a name="ln129">        *varargs = true;</a>
<a name="ln130">      }</a>
<a name="ln131">      p += 3;</a>
<a name="ln132">      mustend = true;</a>
<a name="ln133">    } else {</a>
<a name="ln134">      arg = p;</a>
<a name="ln135">      while (ASCII_ISALNUM(*p) || *p == '_') {</a>
<a name="ln136">        p++;</a>
<a name="ln137">      }</a>
<a name="ln138">      if (arg == p || isdigit((uint8_t)(*arg))</a>
<a name="ln139">          || (p - arg == 9 &amp;&amp; strncmp(arg, &quot;firstline&quot;, 9) == 0)</a>
<a name="ln140">          || (p - arg == 8 &amp;&amp; strncmp(arg, &quot;lastline&quot;, 8) == 0)) {</a>
<a name="ln141">        if (!skip) {</a>
<a name="ln142">          semsg(_(&quot;E125: Illegal argument: %s&quot;), arg);</a>
<a name="ln143">        }</a>
<a name="ln144">        break;</a>
<a name="ln145">      }</a>
<a name="ln146">      if (newargs != NULL) {</a>
<a name="ln147">        ga_grow(newargs, 1);</a>
<a name="ln148">        c = (uint8_t)(*p);</a>
<a name="ln149">        *p = NUL;</a>
<a name="ln150">        arg = xstrdup(arg);</a>
<a name="ln151"> </a>
<a name="ln152">        // Check for duplicate argument name.</a>
<a name="ln153">        for (i = 0; i &lt; newargs-&gt;ga_len; i++) {</a>
<a name="ln154">          if (strcmp(((char **)(newargs-&gt;ga_data))[i], arg) == 0) {</a>
<a name="ln155">            semsg(_(&quot;E853: Duplicate argument name: %s&quot;), arg);</a>
<a name="ln156">            xfree(arg);</a>
<a name="ln157">            goto err_ret;</a>
<a name="ln158">          }</a>
<a name="ln159">        }</a>
<a name="ln160">        ((char **)(newargs-&gt;ga_data))[newargs-&gt;ga_len] = arg;</a>
<a name="ln161">        newargs-&gt;ga_len++;</a>
<a name="ln162"> </a>
<a name="ln163">        *p = (char)c;</a>
<a name="ln164">      }</a>
<a name="ln165">      if (*skipwhite(p) == '=' &amp;&amp; default_args != NULL) {</a>
<a name="ln166">        typval_T rettv;</a>
<a name="ln167"> </a>
<a name="ln168">        any_default = true;</a>
<a name="ln169">        p = skipwhite(p) + 1;</a>
<a name="ln170">        p = skipwhite(p);</a>
<a name="ln171">        char *expr = p;</a>
<a name="ln172">        if (eval1(&amp;p, &amp;rettv, NULL) != FAIL) {</a>
<a name="ln173">          ga_grow(default_args, 1);</a>
<a name="ln174"> </a>
<a name="ln175">          // trim trailing whitespace</a>
<a name="ln176">          while (p &gt; expr &amp;&amp; ascii_iswhite(p[-1])) {</a>
<a name="ln177">            p--;</a>
<a name="ln178">          }</a>
<a name="ln179">          c = (uint8_t)(*p);</a>
<a name="ln180">          *p = NUL;</a>
<a name="ln181">          expr = xstrdup(expr);</a>
<a name="ln182">          ((char **)(default_args-&gt;ga_data))[default_args-&gt;ga_len] = expr;</a>
<a name="ln183">          default_args-&gt;ga_len++;</a>
<a name="ln184">          *p = (char)c;</a>
<a name="ln185">        } else {</a>
<a name="ln186">          mustend = true;</a>
<a name="ln187">        }</a>
<a name="ln188">      } else if (any_default) {</a>
<a name="ln189">        emsg(_(&quot;E989: Non-default argument follows default argument&quot;));</a>
<a name="ln190">        mustend = true;</a>
<a name="ln191">      }</a>
<a name="ln192"> </a>
<a name="ln193">      if (ascii_iswhite(*p) &amp;&amp; *skipwhite(p) == ',') {</a>
<a name="ln194">        // Be tolerant when skipping</a>
<a name="ln195">        if (!skip) {</a>
<a name="ln196">          semsg(_(e_no_white_space_allowed_before_str_str), &quot;,&quot;, p);</a>
<a name="ln197">          goto err_ret;</a>
<a name="ln198">        }</a>
<a name="ln199">        p = skipwhite(p);</a>
<a name="ln200">      }</a>
<a name="ln201">      if (*p == ',') {</a>
<a name="ln202">        p++;</a>
<a name="ln203">      } else {</a>
<a name="ln204">        mustend = true;</a>
<a name="ln205">      }</a>
<a name="ln206">    }</a>
<a name="ln207">    p = skipwhite(p);</a>
<a name="ln208">    if (mustend &amp;&amp; *p != endchar) {</a>
<a name="ln209">      if (!skip) {</a>
<a name="ln210">        semsg(_(e_invarg2), *argp);</a>
<a name="ln211">      }</a>
<a name="ln212">      break;</a>
<a name="ln213">    }</a>
<a name="ln214">  }</a>
<a name="ln215">  if (*p != endchar) {</a>
<a name="ln216">    goto err_ret;</a>
<a name="ln217">  }</a>
<a name="ln218">  p++;  // skip &quot;endchar&quot;</a>
<a name="ln219"> </a>
<a name="ln220">  *argp = p;</a>
<a name="ln221">  return OK;</a>
<a name="ln222"> </a>
<a name="ln223">err_ret:</a>
<a name="ln224">  if (newargs != NULL) {</a>
<a name="ln225">    ga_clear_strings(newargs);</a>
<a name="ln226">  }</a>
<a name="ln227">  if (default_args != NULL) {</a>
<a name="ln228">    ga_clear_strings(default_args);</a>
<a name="ln229">  }</a>
<a name="ln230">  return FAIL;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">/// Register function &quot;fp&quot; as using &quot;current_funccal&quot; as its scope.</a>
<a name="ln234">static void register_closure(ufunc_T *fp)</a>
<a name="ln235">{</a>
<a name="ln236">  if (fp-&gt;uf_scoped == current_funccal) {</a>
<a name="ln237">    // no change</a>
<a name="ln238">    return;</a>
<a name="ln239">  }</a>
<a name="ln240">  funccal_unref(fp-&gt;uf_scoped, fp, false);</a>
<a name="ln241">  fp-&gt;uf_scoped = current_funccal;</a>
<a name="ln242">  current_funccal-&gt;fc_refcount++;</a>
<a name="ln243">  ga_grow(&amp;current_funccal-&gt;fc_ufuncs, 1);</a>
<a name="ln244">  ((ufunc_T **)current_funccal-&gt;fc_ufuncs.ga_data)</a>
<a name="ln245">  [current_funccal-&gt;fc_ufuncs.ga_len++] = fp;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">/// @return  a name for a lambda.  Returned in static memory.</a>
<a name="ln249">char *get_lambda_name(void)</a>
<a name="ln250">{</a>
<a name="ln251">  static char name[30];</a>
<a name="ln252">  static int lambda_no = 0;</a>
<a name="ln253"> </a>
<a name="ln254">  snprintf(name, sizeof(name), &quot;&lt;lambda&gt;%d&quot;, ++lambda_no);</a>
<a name="ln255">  return name;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">static void set_ufunc_name(ufunc_T *fp, char *name)</a>
<a name="ln259">{</a>
<a name="ln260">  STRCPY(fp-&gt;uf_name, name);</a>
<a name="ln261"> </a>
<a name="ln262">  if ((uint8_t)name[0] == K_SPECIAL) {</a>
<a name="ln263">    fp-&gt;uf_name_exp = xmalloc(strlen(name) + 3);</a>
<a name="ln264">    STRCPY(fp-&gt;uf_name_exp, &quot;&lt;SNR&gt;&quot;);</a>
<a name="ln265">    STRCAT(fp-&gt;uf_name_exp, fp-&gt;uf_name + 3);</a>
<a name="ln266">  }</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">/// Parse a lambda expression and get a Funcref from &quot;*arg&quot;.</a>
<a name="ln270">///</a>
<a name="ln271">/// @return OK or FAIL.  Returns NOTDONE for dict or {expr}.</a>
<a name="ln272">int get_lambda_tv(char **arg, typval_T *rettv, evalarg_T *evalarg)</a>
<a name="ln273">{</a>
<a name="ln274">  const bool evaluate = evalarg != NULL &amp;&amp; (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln275">  garray_T newargs = GA_EMPTY_INIT_VALUE;</a>
<a name="ln276">  garray_T *pnewargs;</a>
<a name="ln277">  ufunc_T *fp = NULL;</a>
<a name="ln278">  partial_T *pt = NULL;</a>
<a name="ln279">  int varargs;</a>
<a name="ln280">  int ret;</a>
<a name="ln281">  bool *old_eval_lavars = eval_lavars_used;</a>
<a name="ln282">  bool eval_lavars = false;</a>
<a name="ln283">  char *tofree = NULL;</a>
<a name="ln284"> </a>
<a name="ln285">  // First, check if this is a lambda expression. &quot;-&gt;&quot; must exists.</a>
<a name="ln286">  char *s = skipwhite(*arg + 1);</a>
<a name="ln287">  ret = get_function_args(&amp;s, '-', NULL, NULL, NULL, true);</a>
<a name="ln288">  if (ret == FAIL || *s != '&gt;') {</a>
<a name="ln289">    return NOTDONE;</a>
<a name="ln290">  }</a>
<a name="ln291"> </a>
<a name="ln292">  // Parse the arguments again.</a>
<a name="ln293">  if (evaluate) {</a>
<a name="ln294">    pnewargs = &amp;newargs;</a>
<a name="ln295">  } else {</a>
<a name="ln296">    pnewargs = NULL;</a>
<a name="ln297">  }</a>
<a name="ln298">  *arg = skipwhite(*arg + 1);</a>
<a name="ln299">  ret = get_function_args(arg, '-', pnewargs, &amp;varargs, NULL, false);</a>
<a name="ln300">  if (ret == FAIL || **arg != '&gt;') {</a>
<a name="ln301">    goto errret;</a>
<a name="ln302">  }</a>
<a name="ln303"> </a>
<a name="ln304">  // Set up a flag for checking local variables and arguments.</a>
<a name="ln305">  if (evaluate) {</a>
<a name="ln306">    eval_lavars_used = &amp;eval_lavars;</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  // Get the start and the end of the expression.</a>
<a name="ln310">  *arg = skipwhite((*arg) + 1);</a>
<a name="ln311">  char *start = *arg;</a>
<a name="ln312">  ret = skip_expr(arg, evalarg);</a>
<a name="ln313">  char *end = *arg;</a>
<a name="ln314">  if (ret == FAIL) {</a>
<a name="ln315">    goto errret;</a>
<a name="ln316">  }</a>
<a name="ln317">  if (evalarg != NULL) {</a>
<a name="ln318">    // avoid that the expression gets freed when another line break follows</a>
<a name="ln319">    tofree = evalarg-&gt;eval_tofree;</a>
<a name="ln320">    evalarg-&gt;eval_tofree = NULL;</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  *arg = skipwhite(*arg);</a>
<a name="ln324">  if (**arg != '}') {</a>
<a name="ln325">    semsg(_(&quot;E451: Expected }: %s&quot;), *arg);</a>
<a name="ln326">    goto errret;</a>
<a name="ln327">  }</a>
<a name="ln328">  (*arg)++;</a>
<a name="ln329"> </a>
<a name="ln330">  if (evaluate) {</a>
<a name="ln331">    int flags = 0;</a>
<a name="ln332">    char *p;</a>
<a name="ln333">    garray_T newlines;</a>
<a name="ln334"> </a>
<a name="ln335">    char *name = get_lambda_name();</a>
<a name="ln336"> </a>
<a name="ln337">    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + strlen(name) + 1);</a>
<a name="ln338">    pt = xcalloc(1, sizeof(partial_T));</a>
<a name="ln339"> </a>
<a name="ln340">    ga_init(&amp;newlines, (int)sizeof(char *), 1);</a>
<a name="ln341">    ga_grow(&amp;newlines, 1);</a>
<a name="ln342"> </a>
<a name="ln343">    // Add &quot;return &quot; before the expression.</a>
<a name="ln344">    size_t len = (size_t)(7 + end - start + 1);</a>
<a name="ln345">    p = xmalloc(len);</a>
<a name="ln346">    ((char **)(newlines.ga_data))[newlines.ga_len++] = p;</a>
<a name="ln347">    STRCPY(p, &quot;return &quot;);</a>
<a name="ln348">    xstrlcpy(p + 7, start, (size_t)(end - start) + 1);</a>
<a name="ln349">    if (strstr(p + 7, &quot;a:&quot;) == NULL) {</a>
<a name="ln350">      // No a: variables are used for sure.</a>
<a name="ln351">      flags |= FC_NOARGS;</a>
<a name="ln352">    }</a>
<a name="ln353"> </a>
<a name="ln354">    fp-&gt;uf_refcount = 1;</a>
<a name="ln355">    set_ufunc_name(fp, name);</a>
<a name="ln356">    hash_add(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln357">    fp-&gt;uf_args = newargs;</a>
<a name="ln358">    ga_init(&amp;fp-&gt;uf_def_args, (int)sizeof(char *), 1);</a>
<a name="ln359">    fp-&gt;uf_lines = newlines;</a>
<a name="ln360">    if (current_funccal != NULL &amp;&amp; eval_lavars) {</a>
<a name="ln361">      flags |= FC_CLOSURE;</a>
<a name="ln362">      register_closure(fp);</a>
<a name="ln363">    } else {</a>
<a name="ln364">      fp-&gt;uf_scoped = NULL;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    if (prof_def_func()) {</a>
<a name="ln368">      func_do_profile(fp);</a>
<a name="ln369">    }</a>
<a name="ln370">    if (sandbox) {</a>
<a name="ln371">      flags |= FC_SANDBOX;</a>
<a name="ln372">    }</a>
<a name="ln373">    fp-&gt;uf_varargs = true;</a>
<a name="ln374">    fp-&gt;uf_flags = flags;</a>
<a name="ln375">    fp-&gt;uf_calls = 0;</a>
<a name="ln376">    fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln377">    fp-&gt;uf_script_ctx.sc_lnum += SOURCING_LNUM - newlines.ga_len;</a>
<a name="ln378"> </a>
<a name="ln379">    pt-&gt;pt_func = fp;</a>
<a name="ln380">    pt-&gt;pt_refcount = 1;</a>
<a name="ln381">    rettv-&gt;vval.v_partial = pt;</a>
<a name="ln382">    rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385">  eval_lavars_used = old_eval_lavars;</a>
<a name="ln386">  if (evalarg != NULL &amp;&amp; evalarg-&gt;eval_tofree == NULL) {</a>
<a name="ln387">    evalarg-&gt;eval_tofree = tofree;</a>
<a name="ln388">  } else {</a>
<a name="ln389">    xfree(tofree);</a>
<a name="ln390">  }</a>
<a name="ln391">  return OK;</a>
<a name="ln392"> </a>
<a name="ln393">errret:</a>
<a name="ln394">  ga_clear_strings(&amp;newargs);</a>
<a name="ln395">  xfree(fp);</a>
<a name="ln396">  xfree(pt);</a>
<a name="ln397">  if (evalarg != NULL &amp;&amp; evalarg-&gt;eval_tofree == NULL) {</a>
<a name="ln398">    evalarg-&gt;eval_tofree = tofree;</a>
<a name="ln399">  } else {</a>
<a name="ln400">    xfree(tofree);</a>
<a name="ln401">  }</a>
<a name="ln402">  eval_lavars_used = old_eval_lavars;</a>
<a name="ln403">  return FAIL;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">/// Return name of the function corresponding to `name`</a>
<a name="ln407">///</a>
<a name="ln408">/// If `name` points to variable that is either a function or partial then</a>
<a name="ln409">/// corresponding function name is returned. Otherwise it returns `name` itself.</a>
<a name="ln410">///</a>
<a name="ln411">/// @param[in]  name  Function name to check.</a>
<a name="ln412">/// @param[in,out]  lenp  Location where length of the returned name is stored.</a>
<a name="ln413">///                       Must be set to the length of the `name` argument.</a>
<a name="ln414">/// @param[out]  partialp  Location where partial will be stored if found</a>
<a name="ln415">///                        function appears to be a partial. May be NULL if this</a>
<a name="ln416">///                        is not needed.</a>
<a name="ln417">/// @param[in]  no_autoload  If true, do not source autoload scripts if function</a>
<a name="ln418">///                          was not found.</a>
<a name="ln419">/// @param[out]  found_var  If not NULL and a variable was found set it to true.</a>
<a name="ln420">///</a>
<a name="ln421">/// @return name of the function.</a>
<a name="ln422">char *deref_func_name(const char *name, int *lenp, partial_T **const partialp, bool no_autoload,</a>
<a name="ln423">                      bool *found_var)</a>
<a name="ln424">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln425">{</a>
<a name="ln426">  if (partialp != NULL) {</a>
<a name="ln427">    *partialp = NULL;</a>
<a name="ln428">  }</a>
<a name="ln429"> </a>
<a name="ln430">  dictitem_T *const v = find_var(name, (size_t)(*lenp), NULL, no_autoload);</a>
<a name="ln431">  if (v == NULL) {</a>
<a name="ln432">    return (char *)name;</a>
<a name="ln433">  }</a>
<a name="ln434">  typval_T *const tv = &amp;v-&gt;di_tv;</a>
<a name="ln435">  if (found_var != NULL) {</a>
<a name="ln436">    *found_var = true;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  if (tv-&gt;v_type == VAR_FUNC) {</a>
<a name="ln440">    if (tv-&gt;vval.v_string == NULL) {  // just in case</a>
<a name="ln441">      *lenp = 0;</a>
<a name="ln442">      return &quot;&quot;;</a>
<a name="ln443">    }</a>
<a name="ln444">    *lenp = (int)strlen(tv-&gt;vval.v_string);</a>
<a name="ln445">    return tv-&gt;vval.v_string;</a>
<a name="ln446">  }</a>
<a name="ln447"> </a>
<a name="ln448">  if (tv-&gt;v_type == VAR_PARTIAL) {</a>
<a name="ln449">    partial_T *const pt = tv-&gt;vval.v_partial;</a>
<a name="ln450">    if (pt == NULL) {  // just in case</a>
<a name="ln451">      *lenp = 0;</a>
<a name="ln452">      return &quot;&quot;;</a>
<a name="ln453">    }</a>
<a name="ln454">    if (partialp != NULL) {</a>
<a name="ln455">      *partialp = pt;</a>
<a name="ln456">    }</a>
<a name="ln457">    char *s = partial_name(pt);</a>
<a name="ln458">    *lenp = (int)strlen(s);</a>
<a name="ln459">    return s;</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  return (char *)name;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">/// Give an error message with a function name.  Handle &lt;SNR&gt; things.</a>
<a name="ln466">///</a>
<a name="ln467">/// @param errmsg must be passed without translation (use N_() instead of _()).</a>
<a name="ln468">/// @param name function name</a>
<a name="ln469">void emsg_funcname(const char *errmsg, const char *name)</a>
<a name="ln470">{</a>
<a name="ln471">  char *p = (char *)name;</a>
<a name="ln472"> </a>
<a name="ln473">  if ((uint8_t)name[0] == K_SPECIAL &amp;&amp; name[1] != NUL &amp;&amp; name[2] != NUL) {</a>
<a name="ln474">    p = concat_str(&quot;&lt;SNR&gt;&quot;, name + 3);</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  semsg(_(errmsg), p);</a>
<a name="ln478"> </a>
<a name="ln479">  if (p != name) {</a>
<a name="ln480">    xfree(p);</a>
<a name="ln481">  }</a>
<a name="ln482">}</a>
<a name="ln483"> </a>
<a name="ln484">/// Get function arguments at &quot;*arg&quot; and advance it.</a>
<a name="ln485">/// Return them in &quot;*argvars[MAX_FUNC_ARGS + 1]&quot; and the count in &quot;argcount&quot;.</a>
<a name="ln486">/// On failure FAIL is returned but the &quot;argvars[argcount]&quot; are still set.</a>
<a name="ln487">static int get_func_arguments(char **arg, evalarg_T *const evalarg, int partial_argc,</a>
<a name="ln488">                              typval_T *argvars, int *argcount)</a>
<a name="ln489">{</a>
<a name="ln490">  char *argp = *arg;</a>
<a name="ln491">  int ret = OK;</a>
<a name="ln492"> </a>
<a name="ln493">  // Get the arguments.</a>
<a name="ln494">  while (*argcount &lt; MAX_FUNC_ARGS - partial_argc) {</a>
<a name="ln495">    argp = skipwhite(argp + 1);             // skip the '(' or ','</a>
<a name="ln496"> </a>
<a name="ln497">    if (*argp == ')' || *argp == ',' || *argp == NUL) {</a>
<a name="ln498">      break;</a>
<a name="ln499">    }</a>
<a name="ln500">    if (eval1(&amp;argp, &amp;argvars[*argcount], evalarg) == FAIL) {</a>
<a name="ln501">      ret = FAIL;</a>
<a name="ln502">      break;</a>
<a name="ln503">    }</a>
<a name="ln504">    (*argcount)++;</a>
<a name="ln505">    if (*argp != ',') {</a>
<a name="ln506">      break;</a>
<a name="ln507">    }</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  argp = skipwhite(argp);</a>
<a name="ln511">  if (*argp == ')') {</a>
<a name="ln512">    argp++;</a>
<a name="ln513">  } else {</a>
<a name="ln514">    ret = FAIL;</a>
<a name="ln515">  }</a>
<a name="ln516">  *arg = argp;</a>
<a name="ln517">  return ret;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/// Call a function and put the result in &quot;rettv&quot;.</a>
<a name="ln521">///</a>
<a name="ln522">/// @param name  name of the function</a>
<a name="ln523">/// @param len  length of &quot;name&quot; or -1 to use strlen()</a>
<a name="ln524">/// @param arg  argument, pointing to the '('</a>
<a name="ln525">/// @param funcexe  various values</a>
<a name="ln526">///</a>
<a name="ln527">/// @return  OK or FAIL.</a>
<a name="ln528">int get_func_tv(const char *name, int len, typval_T *rettv, char **arg, evalarg_T *const evalarg,</a>
<a name="ln529">                funcexe_T *funcexe)</a>
<a name="ln530">{</a>
<a name="ln531">  typval_T argvars[MAX_FUNC_ARGS + 1];          // vars for arguments</a>
<a name="ln532">  int argcount = 0;                     // number of arguments found</a>
<a name="ln533">  const bool evaluate = evalarg == NULL ? false : (evalarg-&gt;eval_flags &amp; EVAL_EVALUATE);</a>
<a name="ln534"> </a>
<a name="ln535">  char *argp = *arg;</a>
<a name="ln536">  int ret = get_func_arguments(&amp;argp, evalarg,</a>
<a name="ln537">                               (funcexe-&gt;fe_partial == NULL</a>
<a name="ln538">                                ? 0</a>
<a name="ln539">                                : funcexe-&gt;fe_partial-&gt;pt_argc),</a>
<a name="ln540">                               argvars, &amp;argcount);</a>
<a name="ln541"> </a>
<a name="ln542">  assert(ret == OK || ret == FAIL);  // suppress clang false positive</a>
<a name="ln543">  if (ret == OK) {</a>
<a name="ln544">    int i = 0;</a>
<a name="ln545"> </a>
<a name="ln546">    if (get_vim_var_nr(VV_TESTING)) {</a>
<a name="ln547">      // Prepare for calling test_garbagecollect_now(), need to know</a>
<a name="ln548">      // what variables are used on the call stack.</a>
<a name="ln549">      if (funcargs.ga_itemsize == 0) {</a>
<a name="ln550">        ga_init(&amp;funcargs, (int)sizeof(typval_T *), 50);</a>
<a name="ln551">      }</a>
<a name="ln552">      for (i = 0; i &lt; argcount; i++) {</a>
<a name="ln553">        ga_grow(&amp;funcargs, 1);</a>
<a name="ln554">        ((typval_T **)funcargs.ga_data)[funcargs.ga_len++] = &amp;argvars[i];</a>
<a name="ln555">      }</a>
<a name="ln556">    }</a>
<a name="ln557">    ret = call_func(name, len, rettv, argcount, argvars, funcexe);</a>
<a name="ln558"> </a>
<a name="ln559">    funcargs.ga_len -= i;</a>
<a name="ln560">  } else if (!aborting() &amp;&amp; evaluate) {</a>
<a name="ln561">    if (argcount == MAX_FUNC_ARGS) {</a>
<a name="ln562">      emsg_funcname(N_(&quot;E740: Too many arguments for function %s&quot;), name);</a>
<a name="ln563">    } else {</a>
<a name="ln564">      emsg_funcname(N_(&quot;E116: Invalid arguments for function %s&quot;), name);</a>
<a name="ln565">    }</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  while (--argcount &gt;= 0) {</a>
<a name="ln569">    tv_clear(&amp;argvars[argcount]);</a>
<a name="ln570">  }</a>
<a name="ln571"> </a>
<a name="ln572">  *arg = skipwhite(argp);</a>
<a name="ln573">  return ret;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">#define FLEN_FIXED 40</a>
<a name="ln577"> </a>
<a name="ln578">/// Check whether function name starts with &lt;SID&gt; or s:</a>
<a name="ln579">///</a>
<a name="ln580">/// @warning Only works for names previously checked by eval_fname_script(), if</a>
<a name="ln581">///          it returned non-zero.</a>
<a name="ln582">///</a>
<a name="ln583">/// @param[in]  name  Name to check.</a>
<a name="ln584">///</a>
<a name="ln585">/// @return true if it starts with &lt;SID&gt; or s:, false otherwise.</a>
<a name="ln586">static inline bool eval_fname_sid(const char *const name)</a>
<a name="ln587">  FUNC_ATTR_PURE FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln588">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln589">{</a>
<a name="ln590">  return *name == 's' || TOUPPER_ASC(name[2]) == 'I';</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">/// In a script transform script-local names into actually used names</a>
<a name="ln594">///</a>
<a name="ln595">/// Transforms &quot;&lt;SID&gt;&quot; and &quot;s:&quot; prefixes to `K_SNR {N}` (e.g. K_SNR &quot;123&quot;) and</a>
<a name="ln596">/// &quot;&lt;SNR&gt;&quot; prefix to `K_SNR`. Uses `fname_buf` buffer that is supposed to have</a>
<a name="ln597">/// #FLEN_FIXED + 1 length when it fits, otherwise it allocates memory.</a>
<a name="ln598">///</a>
<a name="ln599">/// @param[in]  name  Name to transform.</a>
<a name="ln600">/// @param  fname_buf  Buffer to save resulting function name to, if it fits.</a>
<a name="ln601">///                    Must have at least #FLEN_FIXED + 1 length.</a>
<a name="ln602">/// @param[out]  tofree  Location where pointer to an allocated memory is saved</a>
<a name="ln603">///                      in case result does not fit into fname_buf.</a>
<a name="ln604">/// @param[out]  error  Location where error type is saved, @see</a>
<a name="ln605">///                     FnameTransError.</a>
<a name="ln606">///</a>
<a name="ln607">/// @return transformed name: either `fname_buf` or a pointer to an allocated</a>
<a name="ln608">///         memory.</a>
<a name="ln609">static char *fname_trans_sid(const char *const name, char *const fname_buf, char **const tofree,</a>
<a name="ln610">                             int *const error)</a>
<a name="ln611">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln612">{</a>
<a name="ln613">  const int llen = eval_fname_script(name);</a>
<a name="ln614">  if (llen == 0) {</a>
<a name="ln615">    return (char *)name;  // no prefix</a>
<a name="ln616">  }</a>
<a name="ln617"> </a>
<a name="ln618">  fname_buf[0] = (char)K_SPECIAL;</a>
<a name="ln619">  fname_buf[1] = (char)KS_EXTRA;</a>
<a name="ln620">  fname_buf[2] = KE_SNR;</a>
<a name="ln621">  int i = 3;</a>
<a name="ln622">  if (eval_fname_sid(name)) {  // &quot;&lt;SID&gt;&quot; or &quot;s:&quot;</a>
<a name="ln623">    if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln624">      *error = FCERR_SCRIPT;</a>
<a name="ln625">    } else {</a>
<a name="ln626">      snprintf(fname_buf + i, (size_t)(FLEN_FIXED + 1 - i), &quot;%&quot; PRId64 &quot;_&quot;,</a>
<a name="ln627">               (int64_t)current_sctx.sc_sid);</a>
<a name="ln628">      i = (int)strlen(fname_buf);</a>
<a name="ln629">    }</a>
<a name="ln630">  }</a>
<a name="ln631">  char *fname;</a>
<a name="ln632">  if ((size_t)i + strlen(name + llen) &lt; FLEN_FIXED) {</a>
<a name="ln633">    STRCPY(fname_buf + i, name + llen);</a>
<a name="ln634">    fname = fname_buf;</a>
<a name="ln635">  } else {</a>
<a name="ln636">    fname = xmalloc((size_t)i + strlen(name + llen) + 1);</a>
<a name="ln637">    *tofree = fname;</a>
<a name="ln638">    memmove(fname, fname_buf, (size_t)i);</a>
<a name="ln639">    STRCPY(fname + i, name + llen);</a>
<a name="ln640">  }</a>
<a name="ln641">  return fname;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/// Find a function by name, return pointer to it in ufuncs.</a>
<a name="ln645">///</a>
<a name="ln646">/// @return  NULL for unknown function.</a>
<a name="ln647">ufunc_T *find_func(const char *name)</a>
<a name="ln648">{</a>
<a name="ln649">  hashitem_T *hi = hash_find(&amp;func_hashtab, name);</a>
<a name="ln650">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln651">    return HI2UF(hi);</a>
<a name="ln652">  }</a>
<a name="ln653">  return NULL;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">/// Copy the function name of &quot;fp&quot; to buffer &quot;buf&quot;.</a>
<a name="ln657">/// &quot;buf&quot; must be able to hold the function name plus three bytes.</a>
<a name="ln658">/// Takes care of script-local function names.</a>
<a name="ln659">static void cat_func_name(char *buf, size_t buflen, ufunc_T *fp)</a>
<a name="ln660">{</a>
<a name="ln661">  int len = -1;</a>
<a name="ln662">  size_t uflen = strlen(fp-&gt;uf_name);</a>
<a name="ln663">  assert(uflen &gt; 0);</a>
<a name="ln664"> </a>
<a name="ln665">  if ((uint8_t)fp-&gt;uf_name[0] == K_SPECIAL &amp;&amp; uflen &gt; 3) {</a>
<a name="ln666">    len = snprintf(buf, buflen, &quot;&lt;SNR&gt;%s&quot;, fp-&gt;uf_name + 3);</a>
<a name="ln667">  } else {</a>
<a name="ln668">    len = snprintf(buf, buflen, &quot;%s&quot;, fp-&gt;uf_name);</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  (void)len;  // Avoid unused warning on release builds</a>
<a name="ln672">  assert(len &gt; 0);</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">/// Add a number variable &quot;name&quot; to dict &quot;dp&quot; with value &quot;nr&quot;.</a>
<a name="ln676">static void add_nr_var(dict_T *dp, dictitem_T *v, char *name, varnumber_T nr)</a>
<a name="ln677">{</a>
<a name="ln678">#ifndef __clang_analyzer__</a>
<a name="ln679">  STRCPY(v-&gt;di_key, name);</a>
<a name="ln680">#endif</a>
<a name="ln681">  v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln682">  hash_add(&amp;dp-&gt;dv_hashtab, v-&gt;di_key);</a>
<a name="ln683">  v-&gt;di_tv.v_type = VAR_NUMBER;</a>
<a name="ln684">  v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln685">  v-&gt;di_tv.vval.v_number = nr;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">/// Free &quot;fc&quot;</a>
<a name="ln689">static void free_funccal(funccall_T *fc)</a>
<a name="ln690">{</a>
<a name="ln691">  for (int i = 0; i &lt; fc-&gt;fc_ufuncs.ga_len; i++) {</a>
<a name="ln692">    ufunc_T *fp = ((ufunc_T **)(fc-&gt;fc_ufuncs.ga_data))[i];</a>
<a name="ln693"> </a>
<a name="ln694">    // When garbage collecting a funccall_T may be freed before the</a>
<a name="ln695">    // function that references it, clear its uf_scoped field.</a>
<a name="ln696">    // The function may have been redefined and point to another</a>
<a name="ln697">    // funccal_T, don't clear it then.</a>
<a name="ln698">    if (fp != NULL &amp;&amp; fp-&gt;uf_scoped == fc) {</a>
<a name="ln699">      fp-&gt;uf_scoped = NULL;</a>
<a name="ln700">    }</a>
<a name="ln701">  }</a>
<a name="ln702">  ga_clear(&amp;fc-&gt;fc_ufuncs);</a>
<a name="ln703"> </a>
<a name="ln704">  func_ptr_unref(fc-&gt;fc_func);</a>
<a name="ln705">  xfree(fc);</a>
<a name="ln706">}</a>
<a name="ln707"> </a>
<a name="ln708">/// Free &quot;fc&quot; and what it contains.</a>
<a name="ln709">/// Can be called only when &quot;fc&quot; is kept beyond the period of it called,</a>
<a name="ln710">/// i.e. after cleanup_function_call(fc).</a>
<a name="ln711">static void free_funccal_contents(funccall_T *fc)</a>
<a name="ln712">{</a>
<a name="ln713">  // Free all l: variables.</a>
<a name="ln714">  vars_clear(&amp;fc-&gt;fc_l_vars.dv_hashtab);</a>
<a name="ln715"> </a>
<a name="ln716">  // Free all a: variables.</a>
<a name="ln717">  vars_clear(&amp;fc-&gt;fc_l_avars.dv_hashtab);</a>
<a name="ln718"> </a>
<a name="ln719">  // Free the a:000 variables.</a>
<a name="ln720">  TV_LIST_ITER(&amp;fc-&gt;fc_l_varlist, li, {</a>
<a name="ln721">    tv_clear(TV_LIST_ITEM_TV(li));</a>
<a name="ln722">  });</a>
<a name="ln723"> </a>
<a name="ln724">  free_funccal(fc);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">/// Handle the last part of returning from a function: free the local hashtable.</a>
<a name="ln728">/// Unless it is still in use by a closure.</a>
<a name="ln729">static void cleanup_function_call(funccall_T *fc)</a>
<a name="ln730">{</a>
<a name="ln731">  bool may_free_fc = fc-&gt;fc_refcount &lt;= 0;</a>
<a name="ln732">  bool free_fc = true;</a>
<a name="ln733"> </a>
<a name="ln734">  current_funccal = fc-&gt;fc_caller;</a>
<a name="ln735"> </a>
<a name="ln736">  // Free all l: variables if not referred.</a>
<a name="ln737">  if (may_free_fc &amp;&amp; fc-&gt;fc_l_vars.dv_refcount == DO_NOT_FREE_CNT) {</a>
<a name="ln738">    vars_clear(&amp;fc-&gt;fc_l_vars.dv_hashtab);</a>
<a name="ln739">  } else {</a>
<a name="ln740">    free_fc = false;</a>
<a name="ln741">  }</a>
<a name="ln742"> </a>
<a name="ln743">  // If the a:000 list and the l: and a: dicts are not referenced and</a>
<a name="ln744">  // there is no closure using it, we can free the funccall_T and what's</a>
<a name="ln745">  // in it.</a>
<a name="ln746">  if (may_free_fc &amp;&amp; fc-&gt;fc_l_avars.dv_refcount == DO_NOT_FREE_CNT) {</a>
<a name="ln747">    vars_clear_ext(&amp;fc-&gt;fc_l_avars.dv_hashtab, false);</a>
<a name="ln748">  } else {</a>
<a name="ln749">    free_fc = false;</a>
<a name="ln750"> </a>
<a name="ln751">    // Make a copy of the a: variables, since we didn't do that above.</a>
<a name="ln752">    TV_DICT_ITER(&amp;fc-&gt;fc_l_avars, di, {</a>
<a name="ln753">      tv_copy(&amp;di-&gt;di_tv, &amp;di-&gt;di_tv);</a>
<a name="ln754">    });</a>
<a name="ln755">  }</a>
<a name="ln756"> </a>
<a name="ln757">  if (may_free_fc &amp;&amp; fc-&gt;fc_l_varlist.lv_refcount   // NOLINT(runtime/deprecated)</a>
<a name="ln758">      == DO_NOT_FREE_CNT) {</a>
<a name="ln759">    fc-&gt;fc_l_varlist.lv_first = NULL;  // NOLINT(runtime/deprecated)</a>
<a name="ln760">  } else {</a>
<a name="ln761">    free_fc = false;</a>
<a name="ln762"> </a>
<a name="ln763">    // Make a copy of the a:000 items, since we didn't do that above.</a>
<a name="ln764">    TV_LIST_ITER(&amp;fc-&gt;fc_l_varlist, li, {</a>
<a name="ln765">      tv_copy(TV_LIST_ITEM_TV(li), TV_LIST_ITEM_TV(li));</a>
<a name="ln766">    });</a>
<a name="ln767">  }</a>
<a name="ln768"> </a>
<a name="ln769">  if (free_fc) {</a>
<a name="ln770">    free_funccal(fc);</a>
<a name="ln771">  } else {</a>
<a name="ln772">    static int made_copy = 0;</a>
<a name="ln773"> </a>
<a name="ln774">    // &quot;fc&quot; is still in use.  This can happen when returning &quot;a:000&quot;,</a>
<a name="ln775">    // assigning &quot;l:&quot; to a global variable or defining a closure.</a>
<a name="ln776">    // Link &quot;fc&quot; in the list for garbage collection later.</a>
<a name="ln777">    fc-&gt;fc_caller = previous_funccal;</a>
<a name="ln778">    previous_funccal = fc;</a>
<a name="ln779"> </a>
<a name="ln780">    if (want_garbage_collect) {</a>
<a name="ln781">      // If garbage collector is ready, clear count.</a>
<a name="ln782">      made_copy = 0;</a>
<a name="ln783">    } else if (++made_copy &gt;= (int)((4096 * 1024) / sizeof(*fc))) {</a>
<a name="ln784">      // We have made a lot of copies, worth 4 Mbyte.  This can happen</a>
<a name="ln785">      // when repetitively calling a function that creates a reference to</a>
<a name="ln786">      // itself somehow.  Call the garbage collector soon to avoid using</a>
<a name="ln787">      // too much memory.</a>
<a name="ln788">      made_copy = 0;</a>
<a name="ln789">      want_garbage_collect = true;</a>
<a name="ln790">    }</a>
<a name="ln791">  }</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/// Unreference &quot;fc&quot;: decrement the reference count and free it when it</a>
<a name="ln795">/// becomes zero.  &quot;fp&quot; is detached from &quot;fc&quot;.</a>
<a name="ln796">///</a>
<a name="ln797">/// @param[in]   force   When true, we are exiting.</a>
<a name="ln798">static void funccal_unref(funccall_T *fc, ufunc_T *fp, bool force)</a>
<a name="ln799">{</a>
<a name="ln800">  int i;</a>
<a name="ln801"> </a>
<a name="ln802">  if (fc == NULL) {</a>
<a name="ln803">    return;</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  fc-&gt;fc_refcount--;</a>
<a name="ln807">  if (force ? fc-&gt;fc_refcount &lt;= 0 : !fc_referenced(fc)) {</a>
<a name="ln808">    for (funccall_T **pfc = &amp;previous_funccal; *pfc != NULL; pfc = &amp;(*pfc)-&gt;fc_caller) {</a>
<a name="ln809">      if (fc == *pfc) {</a>
<a name="ln810">        *pfc = fc-&gt;fc_caller;</a>
<a name="ln811">        free_funccal_contents(fc);</a>
<a name="ln812">        return;</a>
<a name="ln813">      }</a>
<a name="ln814">    }</a>
<a name="ln815">  }</a>
<a name="ln816">  for (i = 0; i &lt; fc-&gt;fc_ufuncs.ga_len; i++) {</a>
<a name="ln817">    if (((ufunc_T **)(fc-&gt;fc_ufuncs.ga_data))[i] == fp) {</a>
<a name="ln818">      ((ufunc_T **)(fc-&gt;fc_ufuncs.ga_data))[i] = NULL;</a>
<a name="ln819">    }</a>
<a name="ln820">  }</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">/// Remove the function from the function hashtable.  If the function was</a>
<a name="ln824">/// deleted while it still has references this was already done.</a>
<a name="ln825">///</a>
<a name="ln826">/// @return true if the entry was deleted, false if it wasn't found.</a>
<a name="ln827">static bool func_remove(ufunc_T *fp)</a>
<a name="ln828">{</a>
<a name="ln829">  hashitem_T *hi = hash_find(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln830">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln831">    return false;</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  hash_remove(&amp;func_hashtab, hi);</a>
<a name="ln835">  return true;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">static void func_clear_items(ufunc_T *fp)</a>
<a name="ln839">{</a>
<a name="ln840">  ga_clear_strings(&amp;(fp-&gt;uf_args));</a>
<a name="ln841">  ga_clear_strings(&amp;(fp-&gt;uf_def_args));</a>
<a name="ln842">  ga_clear_strings(&amp;(fp-&gt;uf_lines));</a>
<a name="ln843">  XFREE_CLEAR(fp-&gt;uf_name_exp);</a>
<a name="ln844"> </a>
<a name="ln845">  if (fp-&gt;uf_flags &amp; FC_LUAREF) {</a>
<a name="ln846">    api_free_luaref(fp-&gt;uf_luaref);</a>
<a name="ln847">    fp-&gt;uf_luaref = LUA_NOREF;</a>
<a name="ln848">  }</a>
<a name="ln849"> </a>
<a name="ln850">  XFREE_CLEAR(fp-&gt;uf_tml_count);</a>
<a name="ln851">  XFREE_CLEAR(fp-&gt;uf_tml_total);</a>
<a name="ln852">  XFREE_CLEAR(fp-&gt;uf_tml_self);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/// Free all things that a function contains. Does not free the function</a>
<a name="ln856">/// itself, use func_free() for that.</a>
<a name="ln857">///</a>
<a name="ln858">/// @param[in] force  When true, we are exiting.</a>
<a name="ln859">static void func_clear(ufunc_T *fp, bool force)</a>
<a name="ln860">{</a>
<a name="ln861">  if (fp-&gt;uf_cleared) {</a>
<a name="ln862">    return;</a>
<a name="ln863">  }</a>
<a name="ln864">  fp-&gt;uf_cleared = true;</a>
<a name="ln865"> </a>
<a name="ln866">  // clear this function</a>
<a name="ln867">  func_clear_items(fp);</a>
<a name="ln868">  funccal_unref(fp-&gt;uf_scoped, fp, force);</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">/// Free a function and remove it from the list of functions. Does not free</a>
<a name="ln872">/// what a function contains, call func_clear() first.</a>
<a name="ln873">///</a>
<a name="ln874">/// @param[in] fp  The function to free.</a>
<a name="ln875">static void func_free(ufunc_T *fp)</a>
<a name="ln876">{</a>
<a name="ln877">  // only remove it when not done already, otherwise we would remove a newer</a>
<a name="ln878">  // version of the function</a>
<a name="ln879">  if ((fp-&gt;uf_flags &amp; (FC_DELETED | FC_REMOVED)) == 0) {</a>
<a name="ln880">    func_remove(fp);</a>
<a name="ln881">  }</a>
<a name="ln882">  xfree(fp);</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">/// Free all things that a function contains and free the function itself.</a>
<a name="ln886">///</a>
<a name="ln887">/// @param[in] force  When true, we are exiting.</a>
<a name="ln888">static void func_clear_free(ufunc_T *fp, bool force)</a>
<a name="ln889">{</a>
<a name="ln890">  func_clear(fp, force);</a>
<a name="ln891">  func_free(fp);</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">/// Allocate a funccall_T, link it in current_funccal and fill in &quot;fp&quot; and &quot;rettv&quot;.</a>
<a name="ln895">/// Must be followed by one call to remove_funccal() or cleanup_function_call().</a>
<a name="ln896">funccall_T *create_funccal(ufunc_T *fp, typval_T *rettv)</a>
<a name="ln897">{</a>
<a name="ln898">  funccall_T *fc = xcalloc(1, sizeof(funccall_T));</a>
<a name="ln899">  fc-&gt;fc_caller = current_funccal;</a>
<a name="ln900">  current_funccal = fc;</a>
<a name="ln901">  fc-&gt;fc_func = fp;</a>
<a name="ln902">  func_ptr_ref(fp);</a>
<a name="ln903">  fc-&gt;fc_rettv = rettv;</a>
<a name="ln904">  return fc;</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">/// Restore current_funccal.</a>
<a name="ln908">void remove_funccal(void)</a>
<a name="ln909">{</a>
<a name="ln910">  funccall_T *fc = current_funccal;</a>
<a name="ln911">  current_funccal = fc-&gt;fc_caller;</a>
<a name="ln912">  free_funccal(fc);</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915">/// Call a user function</a>
<a name="ln916">///</a>
<a name="ln917">/// @param fp  Function to call.</a>
<a name="ln918">/// @param[in] argcount  Number of arguments.</a>
<a name="ln919">/// @param argvars  Arguments.</a>
<a name="ln920">/// @param[out] rettv  Return value.</a>
<a name="ln921">/// @param[in] firstline  First line of range.</a>
<a name="ln922">/// @param[in] lastline  Last line of range.</a>
<a name="ln923">/// @param selfdict  Dictionary for &quot;self&quot; for dictionary functions.</a>
<a name="ln924">void call_user_func(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv,</a>
<a name="ln925">                    linenr_T firstline, linenr_T lastline, dict_T *selfdict)</a>
<a name="ln926">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln927">{</a>
<a name="ln928">  bool using_sandbox = false;</a>
<a name="ln929">  int save_did_emsg;</a>
<a name="ln930">  static int depth = 0;</a>
<a name="ln931">  dictitem_T *v;</a>
<a name="ln932">  int fixvar_idx = 0;           // index in fc_fixvar[]</a>
<a name="ln933">  int ai;</a>
<a name="ln934">  bool islambda = false;</a>
<a name="ln935">  char numbuf[NUMBUFLEN];</a>
<a name="ln936">  char *name;</a>
<a name="ln937">  typval_T *tv_to_free[MAX_FUNC_ARGS];</a>
<a name="ln938">  int tv_to_free_len = 0;</a>
<a name="ln939">  proftime_T wait_start;</a>
<a name="ln940">  proftime_T call_start;</a>
<a name="ln941">  int started_profiling = false;</a>
<a name="ln942">  bool did_save_redo = false;</a>
<a name="ln943">  save_redo_T save_redo;</a>
<a name="ln944"> </a>
<a name="ln945">  // If depth of calling is getting too high, don't execute the function</a>
<a name="ln946">  if (depth &gt;= p_mfd) {</a>
<a name="ln947">    emsg(_(&quot;E132: Function call depth is higher than 'maxfuncdepth'&quot;));</a>
<a name="ln948">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln949">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln950">    return;</a>
<a name="ln951">  }</a>
<a name="ln952">  depth++;</a>
<a name="ln953">  // Save search patterns and redo buffer.</a>
<a name="ln954">  save_search_patterns();</a>
<a name="ln955">  if (!ins_compl_active()) {</a>
<a name="ln956">    saveRedobuff(&amp;save_redo);</a>
<a name="ln957">    did_save_redo = true;</a>
<a name="ln958">  }</a>
<a name="ln959">  fp-&gt;uf_calls++;</a>
<a name="ln960">  // check for CTRL-C hit</a>
<a name="ln961">  line_breakcheck();</a>
<a name="ln962">  // prepare the funccall_T structure</a>
<a name="ln963">  funccall_T *fc = create_funccal(fp, rettv);</a>
<a name="ln964">  fc-&gt;fc_level = ex_nesting_level;</a>
<a name="ln965">  // Check if this function has a breakpoint.</a>
<a name="ln966">  fc-&gt;fc_breakpoint = dbg_find_breakpoint(false, fp-&gt;uf_name, (linenr_T)0);</a>
<a name="ln967">  fc-&gt;fc_dbg_tick = debug_tick;</a>
<a name="ln968">  // Set up fields for closure.</a>
<a name="ln969">  ga_init(&amp;fc-&gt;fc_ufuncs, sizeof(ufunc_T *), 1);</a>
<a name="ln970"> </a>
<a name="ln971">  if (strncmp(fp-&gt;uf_name, &quot;&lt;lambda&gt;&quot;, 8) == 0) {</a>
<a name="ln972">    islambda = true;</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  // Note about using fc-&gt;fc_fixvar[]: This is an array of FIXVAR_CNT variables</a>
<a name="ln976">  // with names up to VAR_SHORT_LEN long.  This avoids having to alloc/free</a>
<a name="ln977">  // each argument variable and saves a lot of time.</a>
<a name="ln978">  //</a>
<a name="ln979">  // Init l: variables.</a>
<a name="ln980">  init_var_dict(&amp;fc-&gt;fc_l_vars, &amp;fc-&gt;fc_l_vars_var, VAR_DEF_SCOPE);</a>
<a name="ln981">  if (selfdict != NULL) {</a>
<a name="ln982">    // Set l:self to &quot;selfdict&quot;.  Use &quot;name&quot; to avoid a warning from</a>
<a name="ln983">    // some compiler that checks the destination size.</a>
<a name="ln984">    v = (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++];</a>
<a name="ln985">#ifndef __clang_analyzer__</a>
<a name="ln986">    name = (char *)v-&gt;di_key;</a>
<a name="ln987">    STRCPY(name, &quot;self&quot;);</a>
<a name="ln988">#endif</a>
<a name="ln989">    v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln990">    hash_add(&amp;fc-&gt;fc_l_vars.dv_hashtab, v-&gt;di_key);</a>
<a name="ln991">    v-&gt;di_tv.v_type = VAR_DICT;</a>
<a name="ln992">    v-&gt;di_tv.v_lock = VAR_UNLOCKED;</a>
<a name="ln993">    v-&gt;di_tv.vval.v_dict = selfdict;</a>
<a name="ln994">    selfdict-&gt;dv_refcount++;</a>
<a name="ln995">  }</a>
<a name="ln996"> </a>
<a name="ln997">  // Init a: variables, unless none found (in lambda).</a>
<a name="ln998">  // Set a:0 to &quot;argcount&quot; less number of named arguments, if &gt;= 0.</a>
<a name="ln999">  // Set a:000 to a list with room for the &quot;...&quot; arguments.</a>
<a name="ln1000">  init_var_dict(&amp;fc-&gt;fc_l_avars, &amp;fc-&gt;fc_l_avars_var, VAR_SCOPE);</a>
<a name="ln1001">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln1002">    add_nr_var(&amp;fc-&gt;fc_l_avars, (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++], &quot;0&quot;,</a>
<a name="ln1003">               (varnumber_T)(argcount &gt;= fp-&gt;uf_args.ga_len</a>
<a name="ln1004">                             ? argcount - fp-&gt;uf_args.ga_len : 0));</a>
<a name="ln1005">  }</a>
<a name="ln1006">  fc-&gt;fc_l_avars.dv_lock = VAR_FIXED;</a>
<a name="ln1007">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln1008">    // Use &quot;name&quot; to avoid a warning from some compiler that checks the</a>
<a name="ln1009">    // destination size.</a>
<a name="ln1010">    v = (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++];</a>
<a name="ln1011">#ifndef __clang_analyzer__</a>
<a name="ln1012">    name = (char *)v-&gt;di_key;</a>
<a name="ln1013">    STRCPY(name, &quot;000&quot;);</a>
<a name="ln1014">#endif</a>
<a name="ln1015">    v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln1016">    hash_add(&amp;fc-&gt;fc_l_avars.dv_hashtab, v-&gt;di_key);</a>
<a name="ln1017">    v-&gt;di_tv.v_type = VAR_LIST;</a>
<a name="ln1018">    v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln1019">    v-&gt;di_tv.vval.v_list = &amp;fc-&gt;fc_l_varlist;</a>
<a name="ln1020">  }</a>
<a name="ln1021">  tv_list_init_static(&amp;fc-&gt;fc_l_varlist);</a>
<a name="ln1022">  tv_list_set_lock(&amp;fc-&gt;fc_l_varlist, VAR_FIXED);</a>
<a name="ln1023"> </a>
<a name="ln1024">  // Set a:firstline to &quot;firstline&quot; and a:lastline to &quot;lastline&quot;.</a>
<a name="ln1025">  // Set a:name to named arguments.</a>
<a name="ln1026">  // Set a:N to the &quot;...&quot; arguments.</a>
<a name="ln1027">  // Skipped when no a: variables used (in lambda).</a>
<a name="ln1028">  if ((fp-&gt;uf_flags &amp; FC_NOARGS) == 0) {</a>
<a name="ln1029">    add_nr_var(&amp;fc-&gt;fc_l_avars, (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++],</a>
<a name="ln1030">               &quot;firstline&quot;, (varnumber_T)firstline);</a>
<a name="ln1031">    add_nr_var(&amp;fc-&gt;fc_l_avars, (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++],</a>
<a name="ln1032">               &quot;lastline&quot;, (varnumber_T)lastline);</a>
<a name="ln1033">  }</a>
<a name="ln1034">  bool default_arg_err = false;</a>
<a name="ln1035">  for (int i = 0; i &lt; argcount || i &lt; fp-&gt;uf_args.ga_len; i++) {</a>
<a name="ln1036">    bool addlocal = false;</a>
<a name="ln1037">    bool isdefault = false;</a>
<a name="ln1038">    typval_T def_rettv;</a>
<a name="ln1039"> </a>
<a name="ln1040">    ai = i - fp-&gt;uf_args.ga_len;</a>
<a name="ln1041">    if (ai &lt; 0) {</a>
<a name="ln1042">      // named argument a:name</a>
<a name="ln1043">      name = FUNCARG(fp, i);</a>
<a name="ln1044">      if (islambda) {</a>
<a name="ln1045">        addlocal = true;</a>
<a name="ln1046">      }</a>
<a name="ln1047"> </a>
<a name="ln1048">      // evaluate named argument default expression</a>
<a name="ln1049">      isdefault = ai + fp-&gt;uf_def_args.ga_len &gt;= 0 &amp;&amp; i &gt;= argcount;</a>
<a name="ln1050">      if (isdefault) {</a>
<a name="ln1051">        char *default_expr = NULL;</a>
<a name="ln1052">        def_rettv.v_type = VAR_NUMBER;</a>
<a name="ln1053">        def_rettv.vval.v_number = -1;</a>
<a name="ln1054"> </a>
<a name="ln1055">        default_expr = ((char **)(fp-&gt;uf_def_args.ga_data))</a>
<a name="ln1056">                       [ai + fp-&gt;uf_def_args.ga_len];</a>
<a name="ln1057">        if (eval1(&amp;default_expr, &amp;def_rettv, &amp;EVALARG_EVALUATE) == FAIL) {</a>
<a name="ln1058">          default_arg_err = true;</a>
<a name="ln1059">          break;</a>
<a name="ln1060">        }</a>
<a name="ln1061">      }</a>
<a name="ln1062">    } else {</a>
<a name="ln1063">      if ((fp-&gt;uf_flags &amp; FC_NOARGS) != 0) {</a>
<a name="ln1064">        // Bail out if no a: arguments used (in lambda).</a>
<a name="ln1065">        break;</a>
<a name="ln1066">      }</a>
<a name="ln1067">      // &quot;...&quot; argument a:1, a:2, etc.</a>
<a name="ln1068">      snprintf(numbuf, sizeof(numbuf), &quot;%d&quot;, ai + 1);</a>
<a name="ln1069">      name = numbuf;</a>
<a name="ln1070">    }</a>
<a name="ln1071">    if (fixvar_idx &lt; FIXVAR_CNT &amp;&amp; strlen(name) &lt;= VAR_SHORT_LEN) {</a>
<a name="ln1072">      v = (dictitem_T *)&amp;fc-&gt;fc_fixvar[fixvar_idx++];</a>
<a name="ln1073">      v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX;</a>
<a name="ln1074">    } else {</a>
<a name="ln1075">      v = xmalloc(sizeof(dictitem_T) + strlen(name));</a>
<a name="ln1076">      v-&gt;di_flags = DI_FLAGS_RO | DI_FLAGS_FIX | DI_FLAGS_ALLOC;</a>
<a name="ln1077">    }</a>
<a name="ln1078">    STRCPY(v-&gt;di_key, name);</a>
<a name="ln1079"> </a>
<a name="ln1080">    // Note: the values are copied directly to avoid alloc/free.</a>
<a name="ln1081">    // &quot;argvars&quot; must have VAR_FIXED for v_lock.</a>
<a name="ln1082">    v-&gt;di_tv = isdefault ? def_rettv : argvars[i];</a>
<a name="ln1083">    v-&gt;di_tv.v_lock = VAR_FIXED;</a>
<a name="ln1084"> </a>
<a name="ln1085">    if (isdefault) {</a>
<a name="ln1086">      // Need to free this later, no matter where it's stored.</a>
<a name="ln1087">      tv_to_free[tv_to_free_len++] = &amp;v-&gt;di_tv;</a>
<a name="ln1088">    }</a>
<a name="ln1089"> </a>
<a name="ln1090">    if (addlocal) {</a>
<a name="ln1091">      // Named arguments can be accessed without the &quot;a:&quot; prefix in lambda</a>
<a name="ln1092">      // expressions. Add to the l: dict.</a>
<a name="ln1093">      tv_copy(&amp;v-&gt;di_tv, &amp;v-&gt;di_tv);</a>
<a name="ln1094">      hash_add(&amp;fc-&gt;fc_l_vars.dv_hashtab, v-&gt;di_key);</a>
<a name="ln1095">    } else {</a>
<a name="ln1096">      hash_add(&amp;fc-&gt;fc_l_avars.dv_hashtab, v-&gt;di_key);</a>
<a name="ln1097">    }</a>
<a name="ln1098"> </a>
<a name="ln1099">    if (ai &gt;= 0 &amp;&amp; ai &lt; MAX_FUNC_ARGS) {</a>
<a name="ln1100">      listitem_T *li = &amp;fc-&gt;fc_l_listitems[ai];</a>
<a name="ln1101"> </a>
<a name="ln1102">      *TV_LIST_ITEM_TV(li) = argvars[i];</a>
<a name="ln1103">      TV_LIST_ITEM_TV(li)-&gt;v_lock = VAR_FIXED;</a>
<a name="ln1104">      tv_list_append(&amp;fc-&gt;fc_l_varlist, li);</a>
<a name="ln1105">    }</a>
<a name="ln1106">  }</a>
<a name="ln1107"> </a>
<a name="ln1108">  // Don't redraw while executing the function.</a>
<a name="ln1109">  RedrawingDisabled++;</a>
<a name="ln1110"> </a>
<a name="ln1111">  if (fp-&gt;uf_flags &amp; FC_SANDBOX) {</a>
<a name="ln1112">    using_sandbox = true;</a>
<a name="ln1113">    sandbox++;</a>
<a name="ln1114">  }</a>
<a name="ln1115"> </a>
<a name="ln1116">  estack_push_ufunc(fp, 1);</a>
<a name="ln1117">  if (p_verbose &gt;= 12) {</a>
<a name="ln1118">    no_wait_return++;</a>
<a name="ln1119">    verbose_enter_scroll();</a>
<a name="ln1120"> </a>
<a name="ln1121">    smsg(0, _(&quot;calling %s&quot;), SOURCING_NAME);</a>
<a name="ln1122">    if (p_verbose &gt;= 14) {</a>
<a name="ln1123">      msg_puts(&quot;(&quot;);</a>
<a name="ln1124">      for (int i = 0; i &lt; argcount; i++) {</a>
<a name="ln1125">        if (i &gt; 0) {</a>
<a name="ln1126">          msg_puts(&quot;, &quot;);</a>
<a name="ln1127">        }</a>
<a name="ln1128">        if (argvars[i].v_type == VAR_NUMBER) {</a>
<a name="ln1129">          msg_outnum((int)argvars[i].vval.v_number);</a>
<a name="ln1130">        } else {</a>
<a name="ln1131">          // Do not want errors such as E724 here.</a>
<a name="ln1132">          emsg_off++;</a>
<a name="ln1133">          char *tofree = encode_tv2string(&amp;argvars[i], NULL);</a>
<a name="ln1134">          emsg_off--;</a>
<a name="ln1135">          if (tofree != NULL) {</a>
<a name="ln1136">            char *s = tofree;</a>
<a name="ln1137">            char buf[MSG_BUF_LEN];</a>
<a name="ln1138">            if (vim_strsize(s) &gt; MSG_BUF_CLEN) {</a>
<a name="ln1139">              trunc_string(s, buf, MSG_BUF_CLEN, sizeof(buf));</a>
<a name="ln1140">              s = buf;</a>
<a name="ln1141">            }</a>
<a name="ln1142">            msg_puts(s);</a>
<a name="ln1143">            xfree(tofree);</a>
<a name="ln1144">          }</a>
<a name="ln1145">        }</a>
<a name="ln1146">      }</a>
<a name="ln1147">      msg_puts(&quot;)&quot;);</a>
<a name="ln1148">    }</a>
<a name="ln1149">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1150"> </a>
<a name="ln1151">    verbose_leave_scroll();</a>
<a name="ln1152">    no_wait_return--;</a>
<a name="ln1153">  }</a>
<a name="ln1154"> </a>
<a name="ln1155">  const bool do_profiling_yes = do_profiling == PROF_YES;</a>
<a name="ln1156"> </a>
<a name="ln1157">  bool func_not_yet_profiling_but_should =</a>
<a name="ln1158">    do_profiling_yes</a>
<a name="ln1159">    &amp;&amp; !fp-&gt;uf_profiling &amp;&amp; has_profiling(false, fp-&gt;uf_name, NULL);</a>
<a name="ln1160"> </a>
<a name="ln1161">  if (func_not_yet_profiling_but_should) {</a>
<a name="ln1162">    started_profiling = true;</a>
<a name="ln1163">    func_do_profile(fp);</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">  bool func_or_func_caller_profiling =</a>
<a name="ln1167">    do_profiling_yes</a>
<a name="ln1168">    &amp;&amp; (fp-&gt;uf_profiling</a>
<a name="ln1169">        || (fc-&gt;fc_caller != NULL &amp;&amp; fc-&gt;fc_caller-&gt;fc_func-&gt;uf_profiling));</a>
<a name="ln1170"> </a>
<a name="ln1171">  if (func_or_func_caller_profiling) {</a>
<a name="ln1172">    fp-&gt;uf_tm_count++;</a>
<a name="ln1173">    call_start = profile_start();</a>
<a name="ln1174">    fp-&gt;uf_tm_children = profile_zero();</a>
<a name="ln1175">  }</a>
<a name="ln1176"> </a>
<a name="ln1177">  if (do_profiling_yes) {</a>
<a name="ln1178">    script_prof_save(&amp;wait_start);</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  const sctx_T save_current_sctx = current_sctx;</a>
<a name="ln1182">  current_sctx = fp-&gt;uf_script_ctx;</a>
<a name="ln1183">  save_did_emsg = did_emsg;</a>
<a name="ln1184">  did_emsg = false;</a>
<a name="ln1185"> </a>
<a name="ln1186">  if (default_arg_err &amp;&amp; (fp-&gt;uf_flags &amp; FC_ABORT)) {</a>
<a name="ln1187">    did_emsg = true;</a>
<a name="ln1188">  } else if (islambda) {</a>
<a name="ln1189">    char *p = *(char **)fp-&gt;uf_lines.ga_data + 7;</a>
<a name="ln1190"> </a>
<a name="ln1191">    // A Lambda always has the command &quot;return {expr}&quot;.  It is much faster</a>
<a name="ln1192">    // to evaluate {expr} directly.</a>
<a name="ln1193">    ex_nesting_level++;</a>
<a name="ln1194">    (void)eval1(&amp;p, rettv, &amp;EVALARG_EVALUATE);</a>
<a name="ln1195">    ex_nesting_level--;</a>
<a name="ln1196">  } else {</a>
<a name="ln1197">    // call do_cmdline() to execute the lines</a>
<a name="ln1198">    do_cmdline(NULL, get_func_line, (void *)fc,</a>
<a name="ln1199">               DOCMD_NOWAIT|DOCMD_VERBOSE|DOCMD_REPEAT);</a>
<a name="ln1200">  }</a>
<a name="ln1201"> </a>
<a name="ln1202">  // Invoke functions added with &quot;:defer&quot;.</a>
<a name="ln1203">  handle_defer_one(current_funccal);</a>
<a name="ln1204"> </a>
<a name="ln1205">  RedrawingDisabled--;</a>
<a name="ln1206"> </a>
<a name="ln1207">  // when the function was aborted because of an error, return -1</a>
<a name="ln1208">  if ((did_emsg</a>
<a name="ln1209">       &amp;&amp; (fp-&gt;uf_flags &amp; FC_ABORT)) || rettv-&gt;v_type == VAR_UNKNOWN) {</a>
<a name="ln1210">    tv_clear(rettv);</a>
<a name="ln1211">    rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln1212">    rettv-&gt;vval.v_number = -1;</a>
<a name="ln1213">  }</a>
<a name="ln1214"> </a>
<a name="ln1215">  if (func_or_func_caller_profiling) {</a>
<a name="ln1216">    call_start = profile_end(call_start);</a>
<a name="ln1217">    call_start = profile_sub_wait(wait_start, call_start);  // -V614</a>
<a name="ln1218">    fp-&gt;uf_tm_total = profile_add(fp-&gt;uf_tm_total, call_start);</a>
<a name="ln1219">    fp-&gt;uf_tm_self = profile_self(fp-&gt;uf_tm_self, call_start,</a>
<a name="ln1220">                                  fp-&gt;uf_tm_children);</a>
<a name="ln1221">    if (fc-&gt;fc_caller != NULL &amp;&amp; fc-&gt;fc_caller-&gt;fc_func-&gt;uf_profiling) {</a>
<a name="ln1222">      fc-&gt;fc_caller-&gt;fc_func-&gt;uf_tm_children =</a>
<a name="ln1223">        profile_add(fc-&gt;fc_caller-&gt;fc_func-&gt;uf_tm_children, call_start);</a>
<a name="ln1224">      fc-&gt;fc_caller-&gt;fc_func-&gt;uf_tml_children =</a>
<a name="ln1225">        profile_add(fc-&gt;fc_caller-&gt;fc_func-&gt;uf_tml_children, call_start);</a>
<a name="ln1226">    }</a>
<a name="ln1227">    if (started_profiling) {</a>
<a name="ln1228">      // make a &quot;:profdel func&quot; stop profiling the function</a>
<a name="ln1229">      fp-&gt;uf_profiling = false;</a>
<a name="ln1230">    }</a>
<a name="ln1231">  }</a>
<a name="ln1232"> </a>
<a name="ln1233">  // when being verbose, mention the return value</a>
<a name="ln1234">  if (p_verbose &gt;= 12) {</a>
<a name="ln1235">    no_wait_return++;</a>
<a name="ln1236">    verbose_enter_scroll();</a>
<a name="ln1237"> </a>
<a name="ln1238">    if (aborting()) {</a>
<a name="ln1239">      smsg(0, _(&quot;%s aborted&quot;), SOURCING_NAME);</a>
<a name="ln1240">    } else if (fc-&gt;fc_rettv-&gt;v_type == VAR_NUMBER) {</a>
<a name="ln1241">      smsg(0, _(&quot;%s returning #%&quot; PRId64 &quot;&quot;),</a>
<a name="ln1242">           SOURCING_NAME, (int64_t)fc-&gt;fc_rettv-&gt;vval.v_number);</a>
<a name="ln1243">    } else {</a>
<a name="ln1244">      char buf[MSG_BUF_LEN];</a>
<a name="ln1245"> </a>
<a name="ln1246">      // The value may be very long.  Skip the middle part, so that we</a>
<a name="ln1247">      // have some idea how it starts and ends. smsg() would always</a>
<a name="ln1248">      // truncate it at the end. Don't want errors such as E724 here.</a>
<a name="ln1249">      emsg_off++;</a>
<a name="ln1250">      char *s = encode_tv2string(fc-&gt;fc_rettv, NULL);</a>
<a name="ln1251">      char *tofree = s;</a>
<a name="ln1252">      emsg_off--;</a>
<a name="ln1253">      if (s != NULL) {</a>
<a name="ln1254">        if (vim_strsize(s) &gt; MSG_BUF_CLEN) {</a>
<a name="ln1255">          trunc_string(s, buf, MSG_BUF_CLEN, MSG_BUF_LEN);</a>
<a name="ln1256">          s = buf;</a>
<a name="ln1257">        }</a>
<a name="ln1258">        smsg(0, _(&quot;%s returning %s&quot;), SOURCING_NAME, s);</a>
<a name="ln1259">        xfree(tofree);</a>
<a name="ln1260">      }</a>
<a name="ln1261">    }</a>
<a name="ln1262">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1263"> </a>
<a name="ln1264">    verbose_leave_scroll();</a>
<a name="ln1265">    no_wait_return--;</a>
<a name="ln1266">  }</a>
<a name="ln1267"> </a>
<a name="ln1268">  estack_pop();</a>
<a name="ln1269">  current_sctx = save_current_sctx;</a>
<a name="ln1270">  if (do_profiling_yes) {</a>
<a name="ln1271">    script_prof_restore(&amp;wait_start);</a>
<a name="ln1272">  }</a>
<a name="ln1273">  if (using_sandbox) {</a>
<a name="ln1274">    sandbox--;</a>
<a name="ln1275">  }</a>
<a name="ln1276"> </a>
<a name="ln1277">  if (p_verbose &gt;= 12 &amp;&amp; SOURCING_NAME != NULL) {</a>
<a name="ln1278">    no_wait_return++;</a>
<a name="ln1279">    verbose_enter_scroll();</a>
<a name="ln1280"> </a>
<a name="ln1281">    smsg(0, _(&quot;continuing in %s&quot;), SOURCING_NAME);</a>
<a name="ln1282">    msg_puts(&quot;\n&quot;);  // don't overwrite this either</a>
<a name="ln1283"> </a>
<a name="ln1284">    verbose_leave_scroll();</a>
<a name="ln1285">    no_wait_return--;</a>
<a name="ln1286">  }</a>
<a name="ln1287"> </a>
<a name="ln1288">  did_emsg |= save_did_emsg;</a>
<a name="ln1289">  depth--;</a>
<a name="ln1290">  for (int i = 0; i &lt; tv_to_free_len; i++) {</a>
<a name="ln1291">    tv_clear(tv_to_free[i]);</a>
<a name="ln1292">  }</a>
<a name="ln1293">  cleanup_function_call(fc);</a>
<a name="ln1294"> </a>
<a name="ln1295">  if (--fp-&gt;uf_calls &lt;= 0 &amp;&amp; fp-&gt;uf_refcount &lt;= 0) {</a>
<a name="ln1296">    // Function was unreferenced while being used, free it now.</a>
<a name="ln1297">    func_clear_free(fp, false);</a>
<a name="ln1298">  }</a>
<a name="ln1299">  // restore search patterns and redo buffer</a>
<a name="ln1300">  if (did_save_redo) {</a>
<a name="ln1301">    restoreRedobuff(&amp;save_redo);</a>
<a name="ln1302">  }</a>
<a name="ln1303">  restore_search_patterns();</a>
<a name="ln1304">}</a>
<a name="ln1305"> </a>
<a name="ln1306">/// There are two kinds of function names:</a>
<a name="ln1307">/// 1. ordinary names, function defined with :function</a>
<a name="ln1308">/// 2. numbered functions and lambdas</a>
<a name="ln1309">/// For the first we only count the name stored in func_hashtab as a reference,</a>
<a name="ln1310">/// using function() does not count as a reference, because the function is</a>
<a name="ln1311">/// looked up by name.</a>
<a name="ln1312">static bool func_name_refcount(const char *name)</a>
<a name="ln1313">{</a>
<a name="ln1314">  return isdigit((uint8_t)(*name)) || *name == '&lt;';</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">/// Check the argument count for user function &quot;fp&quot;.</a>
<a name="ln1318">/// @return  FCERR_UNKNOWN if OK, FCERR_TOOFEW or FCERR_TOOMANY otherwise.</a>
<a name="ln1319">static int check_user_func_argcount(ufunc_T *fp, int argcount)</a>
<a name="ln1320">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1321">{</a>
<a name="ln1322">  const int regular_args = fp-&gt;uf_args.ga_len;</a>
<a name="ln1323"> </a>
<a name="ln1324">  if (argcount &lt; regular_args - fp-&gt;uf_def_args.ga_len) {</a>
<a name="ln1325">    return FCERR_TOOFEW;</a>
<a name="ln1326">  } else if (!fp-&gt;uf_varargs &amp;&amp; argcount &gt; regular_args) {</a>
<a name="ln1327">    return FCERR_TOOMANY;</a>
<a name="ln1328">  }</a>
<a name="ln1329">  return FCERR_UNKNOWN;</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">/// Call a user function after checking the arguments.</a>
<a name="ln1333">static int call_user_func_check(ufunc_T *fp, int argcount, typval_T *argvars, typval_T *rettv,</a>
<a name="ln1334">                                funcexe_T *funcexe, dict_T *selfdict)</a>
<a name="ln1335">  FUNC_ATTR_NONNULL_ARG(1, 3, 4, 5)</a>
<a name="ln1336">{</a>
<a name="ln1337">  if (fp-&gt;uf_flags &amp; FC_LUAREF) {</a>
<a name="ln1338">    return typval_exec_lua_callable(fp-&gt;uf_luaref, argcount, argvars, rettv);</a>
<a name="ln1339">  }</a>
<a name="ln1340"> </a>
<a name="ln1341">  if ((fp-&gt;uf_flags &amp; FC_RANGE) &amp;&amp; funcexe-&gt;fe_doesrange != NULL) {</a>
<a name="ln1342">    *funcexe-&gt;fe_doesrange = true;</a>
<a name="ln1343">  }</a>
<a name="ln1344">  int error = check_user_func_argcount(fp, argcount);</a>
<a name="ln1345">  if (error != FCERR_UNKNOWN) {</a>
<a name="ln1346">    return error;</a>
<a name="ln1347">  }</a>
<a name="ln1348">  if ((fp-&gt;uf_flags &amp; FC_DICT) &amp;&amp; selfdict == NULL) {</a>
<a name="ln1349">    error = FCERR_DICT;</a>
<a name="ln1350">  } else {</a>
<a name="ln1351">    // Call the user function.</a>
<a name="ln1352">    call_user_func(fp, argcount, argvars, rettv, funcexe-&gt;fe_firstline, funcexe-&gt;fe_lastline,</a>
<a name="ln1353">                   (fp-&gt;uf_flags &amp; FC_DICT) ? selfdict : NULL);</a>
<a name="ln1354">    error = FCERR_NONE;</a>
<a name="ln1355">  }</a>
<a name="ln1356">  return error;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">static funccal_entry_T *funccal_stack = NULL;</a>
<a name="ln1360"> </a>
<a name="ln1361">/// Save the current function call pointer, and set it to NULL.</a>
<a name="ln1362">/// Used when executing autocommands and for &quot;:source&quot;.</a>
<a name="ln1363">void save_funccal(funccal_entry_T *entry)</a>
<a name="ln1364">{</a>
<a name="ln1365">  entry-&gt;top_funccal = current_funccal;</a>
<a name="ln1366">  entry-&gt;next = funccal_stack;</a>
<a name="ln1367">  funccal_stack = entry;</a>
<a name="ln1368">  current_funccal = NULL;</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">void restore_funccal(void)</a>
<a name="ln1372">{</a>
<a name="ln1373">  if (funccal_stack == NULL) {</a>
<a name="ln1374">    iemsg(&quot;INTERNAL: restore_funccal()&quot;);</a>
<a name="ln1375">  } else {</a>
<a name="ln1376">    current_funccal = funccal_stack-&gt;top_funccal;</a>
<a name="ln1377">    funccal_stack = funccal_stack-&gt;next;</a>
<a name="ln1378">  }</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381">funccall_T *get_current_funccal(void)</a>
<a name="ln1382">{</a>
<a name="ln1383">  return current_funccal;</a>
<a name="ln1384">}</a>
<a name="ln1385"> </a>
<a name="ln1386">void set_current_funccal(funccall_T *fc)</a>
<a name="ln1387">{</a>
<a name="ln1388">  current_funccal = fc;</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">#if defined(EXITFREE)</a>
<a name="ln1392">void free_all_functions(void)</a>
<a name="ln1393">{</a>
<a name="ln1394">  hashitem_T *hi;</a>
<a name="ln1395">  ufunc_T *fp;</a>
<a name="ln1396">  uint64_t skipped = 0;</a>
<a name="ln1397">  uint64_t todo = 1;</a>
<a name="ln1398">  int changed;</a>
<a name="ln1399"> </a>
<a name="ln1400">  // Clean up the current_funccal chain and the funccal stack.</a>
<a name="ln1401">  while (current_funccal != NULL) {</a>
<a name="ln1402">    tv_clear(current_funccal-&gt;fc_rettv);</a>
<a name="ln1403">    cleanup_function_call(current_funccal);  // -V595</a>
<a name="ln1404">    if (current_funccal == NULL &amp;&amp; funccal_stack != NULL) {</a>
<a name="ln1405">      restore_funccal();</a>
<a name="ln1406">    }</a>
<a name="ln1407">  }</a>
<a name="ln1408"> </a>
<a name="ln1409">  // First clear what the functions contain. Since this may lower the</a>
<a name="ln1410">  // reference count of a function, it may also free a function and change</a>
<a name="ln1411">  // the hash table. Restart if that happens.</a>
<a name="ln1412">  while (todo &gt; 0) {</a>
<a name="ln1413">    todo = func_hashtab.ht_used;</a>
<a name="ln1414">    for (hi = func_hashtab.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln1415">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1416">        // Only free functions that are not refcounted, those are</a>
<a name="ln1417">        // supposed to be freed when no longer referenced.</a>
<a name="ln1418">        fp = HI2UF(hi);</a>
<a name="ln1419">        if (func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln1420">          skipped++;</a>
<a name="ln1421">        } else {</a>
<a name="ln1422">          changed = func_hashtab.ht_changed;</a>
<a name="ln1423">          func_clear(fp, true);</a>
<a name="ln1424">          if (changed != func_hashtab.ht_changed) {</a>
<a name="ln1425">            skipped = 0;</a>
<a name="ln1426">            break;</a>
<a name="ln1427">          }</a>
<a name="ln1428">        }</a>
<a name="ln1429">        todo--;</a>
<a name="ln1430">      }</a>
<a name="ln1431">    }</a>
<a name="ln1432">  }</a>
<a name="ln1433"> </a>
<a name="ln1434">  // Now actually free the functions. Need to start all over every time,</a>
<a name="ln1435">  // because func_free() may change the hash table.</a>
<a name="ln1436">  skipped = 0;</a>
<a name="ln1437">  while (func_hashtab.ht_used &gt; skipped) {</a>
<a name="ln1438">    todo = func_hashtab.ht_used;</a>
<a name="ln1439">    for (hi = func_hashtab.ht_array; todo &gt; 0; hi++) {</a>
<a name="ln1440">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1441">        todo--;</a>
<a name="ln1442">        // Only free functions that are not refcounted, those are</a>
<a name="ln1443">        // supposed to be freed when no longer referenced.</a>
<a name="ln1444">        fp = HI2UF(hi);</a>
<a name="ln1445">        if (func_name_refcount(fp-&gt;uf_name)) {</a>
<a name="ln1446">          skipped++;</a>
<a name="ln1447">        } else {</a>
<a name="ln1448">          func_free(fp);</a>
<a name="ln1449">          skipped = 0;</a>
<a name="ln1450">          break;</a>
<a name="ln1451">        }</a>
<a name="ln1452">      }</a>
<a name="ln1453">    }</a>
<a name="ln1454">  }</a>
<a name="ln1455">  if (skipped == 0) {</a>
<a name="ln1456">    hash_clear(&amp;func_hashtab);</a>
<a name="ln1457">  }</a>
<a name="ln1458">}</a>
<a name="ln1459"> </a>
<a name="ln1460">#endif</a>
<a name="ln1461"> </a>
<a name="ln1462">/// Checks if a builtin function with the given name exists.</a>
<a name="ln1463">///</a>
<a name="ln1464">/// @param[in]   name   name of the builtin function to check.</a>
<a name="ln1465">/// @param[in]   len    length of &quot;name&quot;, or -1 for NUL terminated.</a>
<a name="ln1466">///</a>
<a name="ln1467">/// @return true if &quot;name&quot; looks like a builtin function name: starts with a</a>
<a name="ln1468">/// lower case letter and doesn't contain AUTOLOAD_CHAR or ':'.</a>
<a name="ln1469">static bool builtin_function(const char *name, int len)</a>
<a name="ln1470">{</a>
<a name="ln1471">  if (!ASCII_ISLOWER(name[0]) || name[1] == ':') {</a>
<a name="ln1472">    return false;</a>
<a name="ln1473">  }</a>
<a name="ln1474"> </a>
<a name="ln1475">  const char *p = (len == -1</a>
<a name="ln1476">                   ? strchr(name, AUTOLOAD_CHAR)</a>
<a name="ln1477">                   : memchr(name, AUTOLOAD_CHAR, (size_t)len));</a>
<a name="ln1478"> </a>
<a name="ln1479">  return p == NULL;</a>
<a name="ln1480">}</a>
<a name="ln1481"> </a>
<a name="ln1482">int func_call(char *name, typval_T *args, partial_T *partial, dict_T *selfdict, typval_T *rettv)</a>
<a name="ln1483">{</a>
<a name="ln1484">  typval_T argv[MAX_FUNC_ARGS + 1];</a>
<a name="ln1485">  int argc = 0;</a>
<a name="ln1486">  int r = 0;</a>
<a name="ln1487"> </a>
<a name="ln1488">  TV_LIST_ITER(args-&gt;vval.v_list, item, {</a>
<a name="ln1489">    if (argc == MAX_FUNC_ARGS - (partial == NULL ? 0 : partial-&gt;pt_argc)) {</a>
<a name="ln1490">      emsg(_(&quot;E699: Too many arguments&quot;));</a>
<a name="ln1491">      goto func_call_skip_call;</a>
<a name="ln1492">    }</a>
<a name="ln1493">    // Make a copy of each argument.  This is needed to be able to set</a>
<a name="ln1494">    // v_lock to VAR_FIXED in the copy without changing the original list.</a>
<a name="ln1495">    tv_copy(TV_LIST_ITEM_TV(item), &amp;argv[argc++]);</a>
<a name="ln1496">  });</a>
<a name="ln1497"> </a>
<a name="ln1498">  funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln1499">  funcexe.fe_firstline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1500">  funcexe.fe_lastline = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1501">  funcexe.fe_evaluate = true;</a>
<a name="ln1502">  funcexe.fe_partial = partial;</a>
<a name="ln1503">  funcexe.fe_selfdict = selfdict;</a>
<a name="ln1504">  r = call_func(name, -1, rettv, argc, argv, &amp;funcexe);</a>
<a name="ln1505"> </a>
<a name="ln1506">func_call_skip_call:</a>
<a name="ln1507">  // Free the arguments.</a>
<a name="ln1508">  while (argc &gt; 0) {</a>
<a name="ln1509">    tv_clear(&amp;argv[--argc]);</a>
<a name="ln1510">  }</a>
<a name="ln1511"> </a>
<a name="ln1512">  return r;</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">/// call the 'callback' function and return the result as a number.</a>
<a name="ln1516">/// Returns -2 when calling the function fails.  Uses argv[0] to argv[argc - 1]</a>
<a name="ln1517">/// for the function arguments. argv[argc] should have type VAR_UNKNOWN.</a>
<a name="ln1518">///</a>
<a name="ln1519">/// @param argcount  number of &quot;argvars&quot;</a>
<a name="ln1520">/// @param argvars   vars for arguments, must have &quot;argcount&quot; PLUS ONE elements!</a>
<a name="ln1521">varnumber_T callback_call_retnr(Callback *callback, int argcount, typval_T *argvars)</a>
<a name="ln1522">{</a>
<a name="ln1523">  typval_T rettv;</a>
<a name="ln1524">  if (!callback_call(callback, argcount, argvars, &amp;rettv)) {</a>
<a name="ln1525">    return -2;</a>
<a name="ln1526">  }</a>
<a name="ln1527"> </a>
<a name="ln1528">  varnumber_T retval = tv_get_number_chk(&amp;rettv, NULL);</a>
<a name="ln1529">  tv_clear(&amp;rettv);</a>
<a name="ln1530">  return retval;</a>
<a name="ln1531">}</a>
<a name="ln1532"> </a>
<a name="ln1533">/// Give an error message for the result of a function.</a>
<a name="ln1534">/// Nothing if &quot;error&quot; is FCERR_NONE.</a>
<a name="ln1535">static void user_func_error(int error, const char *name, funcexe_T *funcexe)</a>
<a name="ln1536">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln1537">{</a>
<a name="ln1538">  switch (error) {</a>
<a name="ln1539">  case FCERR_UNKNOWN:</a>
<a name="ln1540">    if (funcexe-&gt;fe_found_var) {</a>
<a name="ln1541">      semsg(_(e_not_callable_type_str), name);</a>
<a name="ln1542">    } else {</a>
<a name="ln1543">      emsg_funcname(e_unknown_function_str, name);</a>
<a name="ln1544">    }</a>
<a name="ln1545">    break;</a>
<a name="ln1546">  case FCERR_NOTMETHOD:</a>
<a name="ln1547">    emsg_funcname(N_(&quot;E276: Cannot use function as a method: %s&quot;), name);</a>
<a name="ln1548">    break;</a>
<a name="ln1549">  case FCERR_DELETED:</a>
<a name="ln1550">    emsg_funcname(N_(&quot;E933: Function was deleted: %s&quot;), name);</a>
<a name="ln1551">    break;</a>
<a name="ln1552">  case FCERR_TOOMANY:</a>
<a name="ln1553">    emsg_funcname(_(e_toomanyarg), name);</a>
<a name="ln1554">    break;</a>
<a name="ln1555">  case FCERR_TOOFEW:</a>
<a name="ln1556">    emsg_funcname(_(e_toofewarg), name);</a>
<a name="ln1557">    break;</a>
<a name="ln1558">  case FCERR_SCRIPT:</a>
<a name="ln1559">    emsg_funcname(N_(&quot;E120: Using &lt;SID&gt; not in a script context: %s&quot;), name);</a>
<a name="ln1560">    break;</a>
<a name="ln1561">  case FCERR_DICT:</a>
<a name="ln1562">    emsg_funcname(N_(&quot;E725: Calling dict function without Dictionary: %s&quot;), name);</a>
<a name="ln1563">    break;</a>
<a name="ln1564">  }</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">/// Used by call_func to add a method base (if any) to a function argument list</a>
<a name="ln1568">/// as the first argument. @see call_func</a>
<a name="ln1569">static void argv_add_base(typval_T *const basetv, typval_T **const argvars, int *const argcount,</a>
<a name="ln1570">                          typval_T *const new_argvars, int *const argv_base)</a>
<a name="ln1571">  FUNC_ATTR_NONNULL_ARG(2, 3, 4, 5)</a>
<a name="ln1572">{</a>
<a name="ln1573">  if (basetv != NULL) {</a>
<a name="ln1574">    // Method call: base-&gt;Method()</a>
<a name="ln1575">    memmove(&amp;new_argvars[1], *argvars, sizeof(typval_T) * (size_t)(*argcount));</a>
<a name="ln1576">    new_argvars[0] = *basetv;</a>
<a name="ln1577">    (*argcount)++;</a>
<a name="ln1578">    *argvars = new_argvars;</a>
<a name="ln1579">    *argv_base = 1;</a>
<a name="ln1580">  }</a>
<a name="ln1581">}</a>
<a name="ln1582"> </a>
<a name="ln1583">/// Call a function with its resolved parameters</a>
<a name="ln1584">///</a>
<a name="ln1585">/// @param funcname  name of the function</a>
<a name="ln1586">/// @param len  length of &quot;name&quot; or -1 to use strlen()</a>
<a name="ln1587">/// @param rettv  [out] value goes here</a>
<a name="ln1588">/// @param argcount_in  number of &quot;argvars&quot;</a>
<a name="ln1589">/// @param argvars_in  vars for arguments, must have &quot;argcount&quot; PLUS ONE elements!</a>
<a name="ln1590">/// @param funcexe  more arguments</a>
<a name="ln1591">///</a>
<a name="ln1592">/// @return FAIL if function cannot be called, else OK (even if an error</a>
<a name="ln1593">///         occurred while executing the function! Set `msg_list` to capture</a>
<a name="ln1594">///         the error, see do_cmdline()).</a>
<a name="ln1595">int call_func(const char *funcname, int len, typval_T *rettv, int argcount_in, typval_T *argvars_in,</a>
<a name="ln1596">              funcexe_T *funcexe)</a>
<a name="ln1597">  FUNC_ATTR_NONNULL_ARG(1, 3, 5, 6)</a>
<a name="ln1598">{</a>
<a name="ln1599">  int ret = FAIL;</a>
<a name="ln1600">  int error = FCERR_NONE;</a>
<a name="ln1601">  ufunc_T *fp = NULL;</a>
<a name="ln1602">  char fname_buf[FLEN_FIXED + 1];</a>
<a name="ln1603">  char *tofree = NULL;</a>
<a name="ln1604">  char *fname = NULL;</a>
<a name="ln1605">  char *name = NULL;</a>
<a name="ln1606">  int argcount = argcount_in;</a>
<a name="ln1607">  typval_T *argvars = argvars_in;</a>
<a name="ln1608">  dict_T *selfdict = funcexe-&gt;fe_selfdict;</a>
<a name="ln1609">  typval_T argv[MAX_FUNC_ARGS + 1];  // used when &quot;partial&quot; or</a>
<a name="ln1610">                                     // &quot;funcexe-&gt;fe_basetv&quot; is not NULL</a>
<a name="ln1611">  int argv_clear = 0;</a>
<a name="ln1612">  int argv_base = 0;</a>
<a name="ln1613">  partial_T *partial = funcexe-&gt;fe_partial;</a>
<a name="ln1614"> </a>
<a name="ln1615">  // Initialize rettv so that it is safe for caller to invoke tv_clear(rettv)</a>
<a name="ln1616">  // even when call_func() returns FAIL.</a>
<a name="ln1617">  rettv-&gt;v_type = VAR_UNKNOWN;</a>
<a name="ln1618"> </a>
<a name="ln1619">  if (len &lt;= 0) {</a>
<a name="ln1620">    len = (int)strlen(funcname);</a>
<a name="ln1621">  }</a>
<a name="ln1622">  if (partial != NULL) {</a>
<a name="ln1623">    fp = partial-&gt;pt_func;</a>
<a name="ln1624">  }</a>
<a name="ln1625">  if (fp == NULL) {</a>
<a name="ln1626">    // Make a copy of the name, if it comes from a funcref variable it could</a>
<a name="ln1627">    // be changed or deleted in the called function.</a>
<a name="ln1628">    name = xstrnsave(funcname, (size_t)len);</a>
<a name="ln1629">    fname = fname_trans_sid(name, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln1630">  }</a>
<a name="ln1631"> </a>
<a name="ln1632">  if (funcexe-&gt;fe_doesrange != NULL) {</a>
<a name="ln1633">    *funcexe-&gt;fe_doesrange = false;</a>
<a name="ln1634">  }</a>
<a name="ln1635"> </a>
<a name="ln1636">  if (partial != NULL) {</a>
<a name="ln1637">    // When the function has a partial with a dict and there is a dict</a>
<a name="ln1638">    // argument, use the dict argument. That is backwards compatible.</a>
<a name="ln1639">    // When the dict was bound explicitly use the one from the partial.</a>
<a name="ln1640">    if (partial-&gt;pt_dict != NULL &amp;&amp; (selfdict == NULL || !partial-&gt;pt_auto)) {</a>
<a name="ln1641">      selfdict = partial-&gt;pt_dict;</a>
<a name="ln1642">    }</a>
<a name="ln1643">    if (error == FCERR_NONE &amp;&amp; partial-&gt;pt_argc &gt; 0) {</a>
<a name="ln1644">      for (argv_clear = 0; argv_clear &lt; partial-&gt;pt_argc; argv_clear++) {</a>
<a name="ln1645">        if (argv_clear + argcount_in &gt;= MAX_FUNC_ARGS) {</a>
<a name="ln1646">          error = FCERR_TOOMANY;</a>
<a name="ln1647">          goto theend;</a>
<a name="ln1648">        }</a>
<a name="ln1649">        tv_copy(&amp;partial-&gt;pt_argv[argv_clear], &amp;argv[argv_clear]);</a>
<a name="ln1650">      }</a>
<a name="ln1651">      for (int i = 0; i &lt; argcount_in; i++) {</a>
<a name="ln1652">        argv[i + argv_clear] = argvars_in[i];</a>
<a name="ln1653">      }</a>
<a name="ln1654">      argvars = argv;</a>
<a name="ln1655">      argcount = partial-&gt;pt_argc + argcount_in;</a>
<a name="ln1656">    }</a>
<a name="ln1657">  }</a>
<a name="ln1658"> </a>
<a name="ln1659">  if (error == FCERR_NONE &amp;&amp; funcexe-&gt;fe_evaluate) {</a>
<a name="ln1660">    char *rfname = fname;</a>
<a name="ln1661"> </a>
<a name="ln1662">    // Ignore &quot;g:&quot; before a function name.</a>
<a name="ln1663">    if (fp == NULL &amp;&amp; fname[0] == 'g' &amp;&amp; fname[1] == ':') {</a>
<a name="ln1664">      rfname = fname + 2;</a>
<a name="ln1665">    }</a>
<a name="ln1666"> </a>
<a name="ln1667">    rettv-&gt;v_type = VAR_NUMBER;         // default rettv is number zero</a>
<a name="ln1668">    rettv-&gt;vval.v_number = 0;</a>
<a name="ln1669">    error = FCERR_UNKNOWN;</a>
<a name="ln1670"> </a>
<a name="ln1671">    if (is_luafunc(partial)) {</a>
<a name="ln1672">      if (len &gt; 0) {</a>
<a name="ln1673">        error = FCERR_NONE;</a>
<a name="ln1674">        argv_add_base(funcexe-&gt;fe_basetv, &amp;argvars, &amp;argcount, argv, &amp;argv_base);</a>
<a name="ln1675">        nlua_typval_call(funcname, (size_t)len, argvars, argcount, rettv);</a>
<a name="ln1676">      } else {</a>
<a name="ln1677">        // v:lua was called directly; show its name in the emsg</a>
<a name="ln1678">        XFREE_CLEAR(name);</a>
<a name="ln1679">        funcname = &quot;v:lua&quot;;</a>
<a name="ln1680">      }</a>
<a name="ln1681">    } else if (fp != NULL || !builtin_function(rfname, -1)) {</a>
<a name="ln1682">      // User defined function.</a>
<a name="ln1683">      if (fp == NULL) {</a>
<a name="ln1684">        fp = find_func(rfname);</a>
<a name="ln1685">      }</a>
<a name="ln1686"> </a>
<a name="ln1687">      // Trigger FuncUndefined event, may load the function.</a>
<a name="ln1688">      if (fp == NULL</a>
<a name="ln1689">          &amp;&amp; apply_autocmds(EVENT_FUNCUNDEFINED, rfname, rfname, true, NULL)</a>
<a name="ln1690">          &amp;&amp; !aborting()) {</a>
<a name="ln1691">        // executed an autocommand, search for the function again</a>
<a name="ln1692">        fp = find_func(rfname);</a>
<a name="ln1693">      }</a>
<a name="ln1694">      // Try loading a package.</a>
<a name="ln1695">      if (fp == NULL &amp;&amp; script_autoload(rfname, strlen(rfname), true) &amp;&amp; !aborting()) {</a>
<a name="ln1696">        // Loaded a package, search for the function again.</a>
<a name="ln1697">        fp = find_func(rfname);</a>
<a name="ln1698">      }</a>
<a name="ln1699"> </a>
<a name="ln1700">      if (fp != NULL &amp;&amp; (fp-&gt;uf_flags &amp; FC_DELETED)) {</a>
<a name="ln1701">        error = FCERR_DELETED;</a>
<a name="ln1702">      } else if (fp != NULL) {</a>
<a name="ln1703">        if (funcexe-&gt;fe_argv_func != NULL) {</a>
<a name="ln1704">          // postponed filling in the arguments, do it now</a>
<a name="ln1705">          argcount = funcexe-&gt;fe_argv_func(argcount, argvars, argv_clear, fp);</a>
<a name="ln1706">        }</a>
<a name="ln1707"> </a>
<a name="ln1708">        argv_add_base(funcexe-&gt;fe_basetv, &amp;argvars, &amp;argcount, argv, &amp;argv_base);</a>
<a name="ln1709"> </a>
<a name="ln1710">        error = call_user_func_check(fp, argcount, argvars, rettv, funcexe, selfdict);</a>
<a name="ln1711">      }</a>
<a name="ln1712">    } else if (funcexe-&gt;fe_basetv != NULL) {</a>
<a name="ln1713">      // expr-&gt;method(): Find the method name in the table, call its</a>
<a name="ln1714">      // implementation with the base as one of the arguments.</a>
<a name="ln1715">      error = call_internal_method(fname, argcount, argvars, rettv,</a>
<a name="ln1716">                                   funcexe-&gt;fe_basetv);</a>
<a name="ln1717">    } else {</a>
<a name="ln1718">      // Find the function name in the table, call its implementation.</a>
<a name="ln1719">      error = call_internal_func(fname, argcount, argvars, rettv);</a>
<a name="ln1720">    }</a>
<a name="ln1721">    // The function call (or &quot;FuncUndefined&quot; autocommand sequence) might</a>
<a name="ln1722">    // have been aborted by an error, an interrupt, or an explicitly thrown</a>
<a name="ln1723">    // exception that has not been caught so far.  This situation can be</a>
<a name="ln1724">    // tested for by calling aborting().  For an error in an internal</a>
<a name="ln1725">    // function or for the &quot;E132&quot; error in call_user_func(), however, the</a>
<a name="ln1726">    // throw point at which the &quot;force_abort&quot; flag (temporarily reset by</a>
<a name="ln1727">    // emsg()) is normally updated has not been reached yet. We need to</a>
<a name="ln1728">    // update that flag first to make aborting() reliable.</a>
<a name="ln1729">    update_force_abort();</a>
<a name="ln1730">  }</a>
<a name="ln1731">  if (error == FCERR_NONE) {</a>
<a name="ln1732">    ret = OK;</a>
<a name="ln1733">  }</a>
<a name="ln1734"> </a>
<a name="ln1735">theend:</a>
<a name="ln1736">  // Report an error unless the argument evaluation or function call has been</a>
<a name="ln1737">  // cancelled due to an aborting error, an interrupt, or an exception.</a>
<a name="ln1738">  if (!aborting()) {</a>
<a name="ln1739">    user_func_error(error, (name != NULL) ? name : funcname, funcexe);</a>
<a name="ln1740">  }</a>
<a name="ln1741"> </a>
<a name="ln1742">  // clear the copies made from the partial</a>
<a name="ln1743">  while (argv_clear &gt; 0) {</a>
<a name="ln1744">    tv_clear(&amp;argv[--argv_clear + argv_base]);</a>
<a name="ln1745">  }</a>
<a name="ln1746"> </a>
<a name="ln1747">  xfree(tofree);</a>
<a name="ln1748">  xfree(name);</a>
<a name="ln1749"> </a>
<a name="ln1750">  return ret;</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">char *printable_func_name(ufunc_T *fp)</a>
<a name="ln1754">{</a>
<a name="ln1755">  return fp-&gt;uf_name_exp != NULL ? fp-&gt;uf_name_exp : fp-&gt;uf_name;</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758">/// When &quot;prev_ht_changed&quot; does not equal &quot;ht_changed&quot; give an error and return</a>
<a name="ln1759">/// true.  Otherwise return false.</a>
<a name="ln1760">static int function_list_modified(const int prev_ht_changed)</a>
<a name="ln1761">{</a>
<a name="ln1762">  if (prev_ht_changed != func_hashtab.ht_changed) {</a>
<a name="ln1763">    emsg(_(e_function_list_was_modified));</a>
<a name="ln1764">    return true;</a>
<a name="ln1765">  }</a>
<a name="ln1766">  return false;</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/// List the head of the function: &quot;name(arg1, arg2)&quot;.</a>
<a name="ln1770">///</a>
<a name="ln1771">/// @param[in]  fp      Function pointer.</a>
<a name="ln1772">/// @param[in]  indent  Indent line.</a>
<a name="ln1773">/// @param[in]  force   Include bang &quot;!&quot; (i.e.: &quot;function!&quot;).</a>
<a name="ln1774">static int list_func_head(ufunc_T *fp, bool indent, bool force)</a>
<a name="ln1775">{</a>
<a name="ln1776">  const int prev_ht_changed = func_hashtab.ht_changed;</a>
<a name="ln1777"> </a>
<a name="ln1778">  msg_start();</a>
<a name="ln1779"> </a>
<a name="ln1780">  // a callback at the more prompt may have deleted the function</a>
<a name="ln1781">  if (function_list_modified(prev_ht_changed)) {</a>
<a name="ln1782">    return FAIL;</a>
<a name="ln1783">  }</a>
<a name="ln1784"> </a>
<a name="ln1785">  if (indent) {</a>
<a name="ln1786">    msg_puts(&quot;   &quot;);</a>
<a name="ln1787">  }</a>
<a name="ln1788">  msg_puts(force ? &quot;function! &quot; : &quot;function &quot;);</a>
<a name="ln1789">  if (fp-&gt;uf_name_exp != NULL) {</a>
<a name="ln1790">    msg_puts(fp-&gt;uf_name_exp);</a>
<a name="ln1791">  } else {</a>
<a name="ln1792">    msg_puts(fp-&gt;uf_name);</a>
<a name="ln1793">  }</a>
<a name="ln1794">  msg_putchar('(');</a>
<a name="ln1795">  int j;</a>
<a name="ln1796">  for (j = 0; j &lt; fp-&gt;uf_args.ga_len; j++) {</a>
<a name="ln1797">    if (j) {</a>
<a name="ln1798">      msg_puts(&quot;, &quot;);</a>
<a name="ln1799">    }</a>
<a name="ln1800">    msg_puts(FUNCARG(fp, j));</a>
<a name="ln1801">    if (j &gt;= fp-&gt;uf_args.ga_len - fp-&gt;uf_def_args.ga_len) {</a>
<a name="ln1802">      msg_puts(&quot; = &quot;);</a>
<a name="ln1803">      msg_puts(((char **)(fp-&gt;uf_def_args.ga_data))</a>
<a name="ln1804">               [j - fp-&gt;uf_args.ga_len + fp-&gt;uf_def_args.ga_len]);</a>
<a name="ln1805">    }</a>
<a name="ln1806">  }</a>
<a name="ln1807">  if (fp-&gt;uf_varargs) {</a>
<a name="ln1808">    if (j) {</a>
<a name="ln1809">      msg_puts(&quot;, &quot;);</a>
<a name="ln1810">    }</a>
<a name="ln1811">    msg_puts(&quot;...&quot;);</a>
<a name="ln1812">  }</a>
<a name="ln1813">  msg_putchar(')');</a>
<a name="ln1814">  if (fp-&gt;uf_flags &amp; FC_ABORT) {</a>
<a name="ln1815">    msg_puts(&quot; abort&quot;);</a>
<a name="ln1816">  }</a>
<a name="ln1817">  if (fp-&gt;uf_flags &amp; FC_RANGE) {</a>
<a name="ln1818">    msg_puts(&quot; range&quot;);</a>
<a name="ln1819">  }</a>
<a name="ln1820">  if (fp-&gt;uf_flags &amp; FC_DICT) {</a>
<a name="ln1821">    msg_puts(&quot; dict&quot;);</a>
<a name="ln1822">  }</a>
<a name="ln1823">  if (fp-&gt;uf_flags &amp; FC_CLOSURE) {</a>
<a name="ln1824">    msg_puts(&quot; closure&quot;);</a>
<a name="ln1825">  }</a>
<a name="ln1826">  msg_clr_eos();</a>
<a name="ln1827">  if (p_verbose &gt; 0) {</a>
<a name="ln1828">    last_set_msg(fp-&gt;uf_script_ctx);</a>
<a name="ln1829">  }</a>
<a name="ln1830"> </a>
<a name="ln1831">  return OK;</a>
<a name="ln1832">}</a>
<a name="ln1833"> </a>
<a name="ln1834">/// Get a function name, translating &quot;&lt;SID&gt;&quot; and &quot;&lt;SNR&gt;&quot;.</a>
<a name="ln1835">/// Also handles a Funcref in a List or Dictionary.</a>
<a name="ln1836">/// flags:</a>
<a name="ln1837">/// TFN_INT:         internal function name OK</a>
<a name="ln1838">/// TFN_QUIET:       be quiet</a>
<a name="ln1839">/// TFN_NO_AUTOLOAD: do not use script autoloading</a>
<a name="ln1840">/// TFN_NO_DEREF:    do not dereference a Funcref</a>
<a name="ln1841">/// Advances &quot;pp&quot; to just after the function name (if no error).</a>
<a name="ln1842">///</a>
<a name="ln1843">/// @param skip  only find the end, don't evaluate</a>
<a name="ln1844">/// @param fdp  return: info about dictionary used</a>
<a name="ln1845">/// @param partial  return: partial of a FuncRef</a>
<a name="ln1846">///</a>
<a name="ln1847">/// @return the function name in allocated memory, or NULL for failure.</a>
<a name="ln1848">char *trans_function_name(char **pp, bool skip, int flags, funcdict_T *fdp, partial_T **partial)</a>
<a name="ln1849">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln1850">{</a>
<a name="ln1851">  char *name = NULL;</a>
<a name="ln1852">  const char *start;</a>
<a name="ln1853">  const char *end;</a>
<a name="ln1854">  int lead;</a>
<a name="ln1855">  int len;</a>
<a name="ln1856">  lval_T lv;</a>
<a name="ln1857"> </a>
<a name="ln1858">  if (fdp != NULL) {</a>
<a name="ln1859">    CLEAR_POINTER(fdp);</a>
<a name="ln1860">  }</a>
<a name="ln1861">  start = *pp;</a>
<a name="ln1862"> </a>
<a name="ln1863">  // Check for hard coded &lt;SNR&gt;: already translated function ID (from a user</a>
<a name="ln1864">  // command).</a>
<a name="ln1865">  if ((uint8_t)(*pp)[0] == K_SPECIAL &amp;&amp; (uint8_t)(*pp)[1] == KS_EXTRA &amp;&amp; (*pp)[2] == KE_SNR) {</a>
<a name="ln1866">    *pp += 3;</a>
<a name="ln1867">    len = get_id_len((const char **)pp) + 3;</a>
<a name="ln1868">    return xmemdupz(start, (size_t)len);</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  // A name starting with &quot;&lt;SID&gt;&quot; or &quot;&lt;SNR&gt;&quot; is local to a script.  But</a>
<a name="ln1872">  // don't skip over &quot;s:&quot;, get_lval() needs it for &quot;s:dict.func&quot;.</a>
<a name="ln1873">  lead = eval_fname_script(start);</a>
<a name="ln1874">  if (lead &gt; 2) {</a>
<a name="ln1875">    start += lead;</a>
<a name="ln1876">  }</a>
<a name="ln1877"> </a>
<a name="ln1878">  // Note that TFN_ flags use the same values as GLV_ flags.</a>
<a name="ln1879">  end = get_lval((char *)start, NULL, &amp;lv, false, skip, flags | GLV_READ_ONLY,</a>
<a name="ln1880">                 lead &gt; 2 ? 0 : FNE_CHECK_START);</a>
<a name="ln1881">  if (end == start) {</a>
<a name="ln1882">    if (!skip) {</a>
<a name="ln1883">      emsg(_(&quot;E129: Function name required&quot;));</a>
<a name="ln1884">    }</a>
<a name="ln1885">    goto theend;</a>
<a name="ln1886">  }</a>
<a name="ln1887">  if (end == NULL || (lv.ll_tv != NULL &amp;&amp; (lead &gt; 2 || lv.ll_range))) {</a>
<a name="ln1888">    // Report an invalid expression in braces, unless the expression</a>
<a name="ln1889">    // evaluation has been cancelled due to an aborting error, an</a>
<a name="ln1890">    // interrupt, or an exception.</a>
<a name="ln1891">    if (!aborting()) {</a>
<a name="ln1892">      if (end != NULL) {</a>
<a name="ln1893">        semsg(_(e_invarg2), start);</a>
<a name="ln1894">      }</a>
<a name="ln1895">    } else {</a>
<a name="ln1896">      *pp = (char *)find_name_end(start, NULL, NULL, FNE_INCL_BR);</a>
<a name="ln1897">    }</a>
<a name="ln1898">    goto theend;</a>
<a name="ln1899">  }</a>
<a name="ln1900"> </a>
<a name="ln1901">  if (lv.ll_tv != NULL) {</a>
<a name="ln1902">    if (fdp != NULL) {</a>
<a name="ln1903">      fdp-&gt;fd_dict = lv.ll_dict;</a>
<a name="ln1904">      fdp-&gt;fd_newkey = lv.ll_newkey;</a>
<a name="ln1905">      lv.ll_newkey = NULL;</a>
<a name="ln1906">      fdp-&gt;fd_di = lv.ll_di;</a>
<a name="ln1907">    }</a>
<a name="ln1908">    if (lv.ll_tv-&gt;v_type == VAR_FUNC &amp;&amp; lv.ll_tv-&gt;vval.v_string != NULL) {</a>
<a name="ln1909">      name = xstrdup(lv.ll_tv-&gt;vval.v_string);</a>
<a name="ln1910">      *pp = (char *)end;</a>
<a name="ln1911">    } else if (lv.ll_tv-&gt;v_type == VAR_PARTIAL</a>
<a name="ln1912">               &amp;&amp; lv.ll_tv-&gt;vval.v_partial != NULL) {</a>
<a name="ln1913">      if (is_luafunc(lv.ll_tv-&gt;vval.v_partial) &amp;&amp; *end == '.') {</a>
<a name="ln1914">        len = check_luafunc_name(end + 1, true);</a>
<a name="ln1915">        if (len == 0) {</a>
<a name="ln1916">          semsg(e_invexpr2, &quot;v:lua&quot;);</a>
<a name="ln1917">          goto theend;</a>
<a name="ln1918">        }</a>
<a name="ln1919">        name = xmallocz((size_t)len);</a>
<a name="ln1920">        memcpy(name, end + 1, (size_t)len);</a>
<a name="ln1921">        *pp = (char *)end + 1 + len;</a>
<a name="ln1922">      } else {</a>
<a name="ln1923">        name = xstrdup(partial_name(lv.ll_tv-&gt;vval.v_partial));</a>
<a name="ln1924">        *pp = (char *)end;</a>
<a name="ln1925">      }</a>
<a name="ln1926">      if (partial != NULL) {</a>
<a name="ln1927">        *partial = lv.ll_tv-&gt;vval.v_partial;</a>
<a name="ln1928">      }</a>
<a name="ln1929">    } else {</a>
<a name="ln1930">      if (!skip &amp;&amp; !(flags &amp; TFN_QUIET) &amp;&amp; (fdp == NULL</a>
<a name="ln1931">                                            || lv.ll_dict == NULL</a>
<a name="ln1932">                                            || fdp-&gt;fd_newkey == NULL)) {</a>
<a name="ln1933">        emsg(_(e_funcref));</a>
<a name="ln1934">      } else {</a>
<a name="ln1935">        *pp = (char *)end;</a>
<a name="ln1936">      }</a>
<a name="ln1937">      name = NULL;</a>
<a name="ln1938">    }</a>
<a name="ln1939">    goto theend;</a>
<a name="ln1940">  }</a>
<a name="ln1941"> </a>
<a name="ln1942">  if (lv.ll_name == NULL) {</a>
<a name="ln1943">    // Error found, but continue after the function name.</a>
<a name="ln1944">    *pp = (char *)end;</a>
<a name="ln1945">    goto theend;</a>
<a name="ln1946">  }</a>
<a name="ln1947"> </a>
<a name="ln1948">  // Check if the name is a Funcref.  If so, use the value.</a>
<a name="ln1949">  if (lv.ll_exp_name != NULL) {</a>
<a name="ln1950">    len = (int)strlen(lv.ll_exp_name);</a>
<a name="ln1951">    name = deref_func_name(lv.ll_exp_name, &amp;len, partial, flags &amp; TFN_NO_AUTOLOAD, NULL);</a>
<a name="ln1952">    if (name == lv.ll_exp_name) {</a>
<a name="ln1953">      name = NULL;</a>
<a name="ln1954">    }</a>
<a name="ln1955">  } else if (!(flags &amp; TFN_NO_DEREF)) {</a>
<a name="ln1956">    len = (int)(end - *pp);</a>
<a name="ln1957">    name = deref_func_name(*pp, &amp;len, partial, flags &amp; TFN_NO_AUTOLOAD, NULL);</a>
<a name="ln1958">    if (name == *pp) {</a>
<a name="ln1959">      name = NULL;</a>
<a name="ln1960">    }</a>
<a name="ln1961">  }</a>
<a name="ln1962">  if (name != NULL) {</a>
<a name="ln1963">    name = xstrdup(name);</a>
<a name="ln1964">    *pp = (char *)end;</a>
<a name="ln1965">    if (strncmp(name, &quot;&lt;SNR&gt;&quot;, 5) == 0) {</a>
<a name="ln1966">      // Change &quot;&lt;SNR&gt;&quot; to the byte sequence.</a>
<a name="ln1967">      name[0] = (char)K_SPECIAL;</a>
<a name="ln1968">      name[1] = (char)KS_EXTRA;</a>
<a name="ln1969">      name[2] = KE_SNR;</a>
<a name="ln1970">      memmove(name + 3, name + 5, strlen(name + 5) + 1);</a>
<a name="ln1971">    }</a>
<a name="ln1972">    goto theend;</a>
<a name="ln1973">  }</a>
<a name="ln1974"> </a>
<a name="ln1975">  if (lv.ll_exp_name != NULL) {</a>
<a name="ln1976">    len = (int)strlen(lv.ll_exp_name);</a>
<a name="ln1977">    if (lead &lt;= 2 &amp;&amp; lv.ll_name == lv.ll_exp_name</a>
<a name="ln1978">        &amp;&amp; lv.ll_name_len &gt;= 2 &amp;&amp; memcmp(lv.ll_name, &quot;s:&quot;, 2) == 0) {</a>
<a name="ln1979">      // When there was &quot;s:&quot; already or the name expanded to get a</a>
<a name="ln1980">      // leading &quot;s:&quot; then remove it.</a>
<a name="ln1981">      lv.ll_name += 2;</a>
<a name="ln1982">      lv.ll_name_len -= 2;</a>
<a name="ln1983">      len -= 2;</a>
<a name="ln1984">      lead = 2;</a>
<a name="ln1985">    }</a>
<a name="ln1986">  } else {</a>
<a name="ln1987">    // Skip over &quot;s:&quot; and &quot;g:&quot;.</a>
<a name="ln1988">    if (lead == 2 || (lv.ll_name[0] == 'g' &amp;&amp; lv.ll_name[1] == ':')) {</a>
<a name="ln1989">      lv.ll_name += 2;</a>
<a name="ln1990">      lv.ll_name_len -= 2;</a>
<a name="ln1991">    }</a>
<a name="ln1992">    len = (int)(end - lv.ll_name);</a>
<a name="ln1993">  }</a>
<a name="ln1994"> </a>
<a name="ln1995">  size_t sid_buf_len = 0;</a>
<a name="ln1996">  char sid_buf[20];</a>
<a name="ln1997"> </a>
<a name="ln1998">  // Copy the function name to allocated memory.</a>
<a name="ln1999">  // Accept &lt;SID&gt;name() inside a script, translate into &lt;SNR&gt;123_name().</a>
<a name="ln2000">  // Accept &lt;SNR&gt;123_name() outside a script.</a>
<a name="ln2001">  if (skip) {</a>
<a name="ln2002">    lead = 0;  // do nothing</a>
<a name="ln2003">  } else if (lead &gt; 0) {</a>
<a name="ln2004">    lead = 3;</a>
<a name="ln2005">    if ((lv.ll_exp_name != NULL &amp;&amp; eval_fname_sid(lv.ll_exp_name)) || eval_fname_sid(*pp)) {</a>
<a name="ln2006">      // It's &quot;s:&quot; or &quot;&lt;SID&gt;&quot;.</a>
<a name="ln2007">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln2008">        emsg(_(e_usingsid));</a>
<a name="ln2009">        goto theend;</a>
<a name="ln2010">      }</a>
<a name="ln2011">      sid_buf_len =</a>
<a name="ln2012">        (size_t)snprintf(sid_buf, sizeof(sid_buf), &quot;%&quot; PRIdSCID &quot;_&quot;, current_sctx.sc_sid);</a>
<a name="ln2013">      lead += (int)sid_buf_len;</a>
<a name="ln2014">    }</a>
<a name="ln2015">  } else if (!(flags &amp; TFN_INT) &amp;&amp; builtin_function(lv.ll_name, (int)lv.ll_name_len)) {</a>
<a name="ln2016">    semsg(_(&quot;E128: Function name must start with a capital or \&quot;s:\&quot;: %s&quot;),</a>
<a name="ln2017">          start);</a>
<a name="ln2018">    goto theend;</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  if (!skip &amp;&amp; !(flags &amp; TFN_QUIET) &amp;&amp; !(flags &amp; TFN_NO_DEREF)) {</a>
<a name="ln2022">    char *cp = xmemrchr(lv.ll_name, ':', lv.ll_name_len);</a>
<a name="ln2023"> </a>
<a name="ln2024">    if (cp != NULL &amp;&amp; cp &lt; end) {</a>
<a name="ln2025">      semsg(_(&quot;E884: Function name cannot contain a colon: %s&quot;), start);</a>
<a name="ln2026">      goto theend;</a>
<a name="ln2027">    }</a>
<a name="ln2028">  }</a>
<a name="ln2029"> </a>
<a name="ln2030">  name = xmalloc((size_t)len + (size_t)lead + 1);</a>
<a name="ln2031">  if (!skip &amp;&amp; lead &gt; 0) {</a>
<a name="ln2032">    name[0] = (char)K_SPECIAL;</a>
<a name="ln2033">    name[1] = (char)KS_EXTRA;</a>
<a name="ln2034">    name[2] = KE_SNR;</a>
<a name="ln2035">    if (sid_buf_len &gt; 0) {  // If it's &quot;&lt;SID&gt;&quot;</a>
<a name="ln2036">      memcpy(name + 3, sid_buf, sid_buf_len);</a>
<a name="ln2037">    }</a>
<a name="ln2038">  }</a>
<a name="ln2039">  memmove(name + lead, lv.ll_name, (size_t)len);</a>
<a name="ln2040">  name[lead + len] = NUL;</a>
<a name="ln2041">  *pp = (char *)end;</a>
<a name="ln2042"> </a>
<a name="ln2043">theend:</a>
<a name="ln2044">  clear_lval(&amp;lv);</a>
<a name="ln2045">  return name;</a>
<a name="ln2046">}</a>
<a name="ln2047"> </a>
<a name="ln2048">/// If the &quot;funcname&quot; starts with &quot;s:&quot; or &quot;&lt;SID&gt;&quot;, then expands it to the</a>
<a name="ln2049">/// current script ID and returns the expanded function name. The caller should</a>
<a name="ln2050">/// free the returned name. If not called from a script context or the function</a>
<a name="ln2051">/// name doesn't start with these prefixes, then returns NULL.</a>
<a name="ln2052">/// This doesn't check whether the script-local function exists or not.</a>
<a name="ln2053">char *get_scriptlocal_funcname(char *funcname)</a>
<a name="ln2054">{</a>
<a name="ln2055">  if (funcname == NULL) {</a>
<a name="ln2056">    return NULL;</a>
<a name="ln2057">  }</a>
<a name="ln2058"> </a>
<a name="ln2059">  if (strncmp(funcname, &quot;s:&quot;, 2) != 0</a>
<a name="ln2060">      &amp;&amp; strncmp(funcname, &quot;&lt;SID&gt;&quot;, 5) != 0) {</a>
<a name="ln2061">    // The function name is not a script-local function name</a>
<a name="ln2062">    return NULL;</a>
<a name="ln2063">  }</a>
<a name="ln2064"> </a>
<a name="ln2065">  if (!SCRIPT_ID_VALID(current_sctx.sc_sid)) {</a>
<a name="ln2066">    emsg(_(e_usingsid));</a>
<a name="ln2067">    return NULL;</a>
<a name="ln2068">  }</a>
<a name="ln2069"> </a>
<a name="ln2070">  char sid_buf[25];</a>
<a name="ln2071">  // Expand s: and &lt;SID&gt; prefix into &lt;SNR&gt;nr_&lt;name&gt;</a>
<a name="ln2072">  snprintf(sid_buf, sizeof(sid_buf), &quot;&lt;SNR&gt;%&quot; PRId64 &quot;_&quot;,</a>
<a name="ln2073">           (int64_t)current_sctx.sc_sid);</a>
<a name="ln2074">  const int off = *funcname == 's' ? 2 : 5;</a>
<a name="ln2075">  char *newname = xmalloc(strlen(sid_buf) + strlen(funcname + off) + 1);</a>
<a name="ln2076">  STRCPY(newname, sid_buf);</a>
<a name="ln2077">  STRCAT(newname, funcname + off);</a>
<a name="ln2078"> </a>
<a name="ln2079">  return newname;</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">/// Call trans_function_name(), except that a lambda is returned as-is.</a>
<a name="ln2083">/// Returns the name in allocated memory.</a>
<a name="ln2084">char *save_function_name(char **name, bool skip, int flags, funcdict_T *fudi)</a>
<a name="ln2085">{</a>
<a name="ln2086">  char *p = *name;</a>
<a name="ln2087">  char *saved;</a>
<a name="ln2088"> </a>
<a name="ln2089">  if (strncmp(p, &quot;&lt;lambda&gt;&quot;, 8) == 0) {</a>
<a name="ln2090">    p += 8;</a>
<a name="ln2091">    (void)getdigits(&amp;p, false, 0);</a>
<a name="ln2092">    saved = xstrndup(*name, (size_t)(p - *name));</a>
<a name="ln2093">    if (fudi != NULL) {</a>
<a name="ln2094">      CLEAR_POINTER(fudi);</a>
<a name="ln2095">    }</a>
<a name="ln2096">  } else {</a>
<a name="ln2097">    saved = trans_function_name(&amp;p, skip, flags, fudi, NULL);</a>
<a name="ln2098">  }</a>
<a name="ln2099">  *name = p;</a>
<a name="ln2100">  return saved;</a>
<a name="ln2101">}</a>
<a name="ln2102"> </a>
<a name="ln2103">#define MAX_FUNC_NESTING 50</a>
<a name="ln2104"> </a>
<a name="ln2105">/// List functions.</a>
<a name="ln2106">///</a>
<a name="ln2107">/// @param regmatch  When NULL, all of them.</a>
<a name="ln2108">///                  Otherwise functions matching &quot;regmatch&quot;.</a>
<a name="ln2109">static void list_functions(regmatch_T *regmatch)</a>
<a name="ln2110">{</a>
<a name="ln2111">  const int prev_ht_changed = func_hashtab.ht_changed;</a>
<a name="ln2112">  size_t todo = func_hashtab.ht_used;</a>
<a name="ln2113">  const hashitem_T *const ht_array = func_hashtab.ht_array;</a>
<a name="ln2114"> </a>
<a name="ln2115">  for (const hashitem_T *hi = ht_array; todo &gt; 0 &amp;&amp; !got_int; hi++) {</a>
<a name="ln2116">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln2117">      ufunc_T *fp = HI2UF(hi);</a>
<a name="ln2118">      todo--;</a>
<a name="ln2119">      if (regmatch == NULL</a>
<a name="ln2120">          ? (!message_filtered(fp-&gt;uf_name)</a>
<a name="ln2121">             &amp;&amp; !func_name_refcount(fp-&gt;uf_name))</a>
<a name="ln2122">          : (!isdigit((uint8_t)(*fp-&gt;uf_name))</a>
<a name="ln2123">             &amp;&amp; vim_regexec(regmatch, fp-&gt;uf_name, 0))) {</a>
<a name="ln2124">        if (list_func_head(fp, false, false) == FAIL) {</a>
<a name="ln2125">          return;</a>
<a name="ln2126">        }</a>
<a name="ln2127">        if (function_list_modified(prev_ht_changed)) {</a>
<a name="ln2128">          return;</a>
<a name="ln2129">        }</a>
<a name="ln2130">      }</a>
<a name="ln2131">    }</a>
<a name="ln2132">  }</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135">/// &quot;:function&quot;</a>
<a name="ln2136">void ex_function(exarg_T *eap)</a>
<a name="ln2137">{</a>
<a name="ln2138">  char *theline;</a>
<a name="ln2139">  char *line_to_free = NULL;</a>
<a name="ln2140">  char c;</a>
<a name="ln2141">  bool saved_wait_return = need_wait_return;</a>
<a name="ln2142">  char *name = NULL;</a>
<a name="ln2143">  char *p;</a>
<a name="ln2144">  char *arg;</a>
<a name="ln2145">  char *line_arg = NULL;</a>
<a name="ln2146">  garray_T newargs;</a>
<a name="ln2147">  garray_T default_args;</a>
<a name="ln2148">  garray_T newlines;</a>
<a name="ln2149">  int varargs = false;</a>
<a name="ln2150">  int flags = 0;</a>
<a name="ln2151">  ufunc_T *fp;</a>
<a name="ln2152">  bool overwrite = false;</a>
<a name="ln2153">  int indent;</a>
<a name="ln2154">  int nesting;</a>
<a name="ln2155">  dictitem_T *v;</a>
<a name="ln2156">  funcdict_T fudi;</a>
<a name="ln2157">  static int func_nr = 0;           // number for nameless function</a>
<a name="ln2158">  int paren;</a>
<a name="ln2159">  hashtab_T *ht;</a>
<a name="ln2160">  hashitem_T *hi;</a>
<a name="ln2161">  linenr_T sourcing_lnum_off;</a>
<a name="ln2162">  linenr_T sourcing_lnum_top;</a>
<a name="ln2163">  bool is_heredoc = false;</a>
<a name="ln2164">  char *skip_until = NULL;</a>
<a name="ln2165">  char *heredoc_trimmed = NULL;</a>
<a name="ln2166">  bool show_block = false;</a>
<a name="ln2167">  bool do_concat = true;</a>
<a name="ln2168"> </a>
<a name="ln2169">  // &quot;:function&quot; without argument: list functions.</a>
<a name="ln2170">  if (ends_excmd(*eap-&gt;arg)) {</a>
<a name="ln2171">    if (!eap-&gt;skip) {</a>
<a name="ln2172">      list_functions(NULL);</a>
<a name="ln2173">    }</a>
<a name="ln2174">    eap-&gt;nextcmd = check_nextcmd(eap-&gt;arg);</a>
<a name="ln2175">    return;</a>
<a name="ln2176">  }</a>
<a name="ln2177"> </a>
<a name="ln2178">  // &quot;:function /pat&quot;: list functions matching pattern.</a>
<a name="ln2179">  if (*eap-&gt;arg == '/') {</a>
<a name="ln2180">    p = skip_regexp(eap-&gt;arg + 1, '/', true);</a>
<a name="ln2181">    if (!eap-&gt;skip) {</a>
<a name="ln2182">      regmatch_T regmatch;</a>
<a name="ln2183"> </a>
<a name="ln2184">      c = *p;</a>
<a name="ln2185">      *p = NUL;</a>
<a name="ln2186">      regmatch.regprog = vim_regcomp(eap-&gt;arg + 1, RE_MAGIC);</a>
<a name="ln2187">      *p = c;</a>
<a name="ln2188">      if (regmatch.regprog != NULL) {</a>
<a name="ln2189">        regmatch.rm_ic = p_ic;</a>
<a name="ln2190">        list_functions(&amp;regmatch);</a>
<a name="ln2191">        vim_regfree(regmatch.regprog);</a>
<a name="ln2192">      }</a>
<a name="ln2193">    }</a>
<a name="ln2194">    if (*p == '/') {</a>
<a name="ln2195">      p++;</a>
<a name="ln2196">    }</a>
<a name="ln2197">    eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln2198">    return;</a>
<a name="ln2199">  }</a>
<a name="ln2200"> </a>
<a name="ln2201">  // Get the function name.  There are these situations:</a>
<a name="ln2202">  // func        function name</a>
<a name="ln2203">  //             &quot;name&quot; == func, &quot;fudi.fd_dict&quot; == NULL</a>
<a name="ln2204">  // dict.func   new dictionary entry</a>
<a name="ln2205">  //             &quot;name&quot; == NULL, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln2206">  //             &quot;fudi.fd_di&quot; == NULL, &quot;fudi.fd_newkey&quot; == func</a>
<a name="ln2207">  // dict.func   existing dict entry with a Funcref</a>
<a name="ln2208">  //             &quot;name&quot; == func, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln2209">  //             &quot;fudi.fd_di&quot; set, &quot;fudi.fd_newkey&quot; == NULL</a>
<a name="ln2210">  // dict.func   existing dict entry that's not a Funcref</a>
<a name="ln2211">  //             &quot;name&quot; == NULL, &quot;fudi.fd_dict&quot; set,</a>
<a name="ln2212">  //             &quot;fudi.fd_di&quot; set, &quot;fudi.fd_newkey&quot; == NULL</a>
<a name="ln2213">  // s:func      script-local function name</a>
<a name="ln2214">  // g:func      global function name, same as &quot;func&quot;</a>
<a name="ln2215">  p = eap-&gt;arg;</a>
<a name="ln2216">  name = save_function_name(&amp;p, eap-&gt;skip, TFN_NO_AUTOLOAD, &amp;fudi);</a>
<a name="ln2217">  paren = (vim_strchr(p, '(') != NULL);</a>
<a name="ln2218">  if (name == NULL &amp;&amp; (fudi.fd_dict == NULL || !paren) &amp;&amp; !eap-&gt;skip) {</a>
<a name="ln2219">    // Return on an invalid expression in braces, unless the expression</a>
<a name="ln2220">    // evaluation has been cancelled due to an aborting error, an</a>
<a name="ln2221">    // interrupt, or an exception.</a>
<a name="ln2222">    if (!aborting()) {</a>
<a name="ln2223">      if (fudi.fd_newkey != NULL) {</a>
<a name="ln2224">        semsg(_(e_dictkey), fudi.fd_newkey);</a>
<a name="ln2225">      }</a>
<a name="ln2226">      xfree(fudi.fd_newkey);</a>
<a name="ln2227">      return;</a>
<a name="ln2228">    }</a>
<a name="ln2229">    eap-&gt;skip = true;</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  // An error in a function call during evaluation of an expression in magic</a>
<a name="ln2233">  // braces should not cause the function not to be defined.</a>
<a name="ln2234">  const int saved_did_emsg = did_emsg;</a>
<a name="ln2235">  did_emsg = false;</a>
<a name="ln2236"> </a>
<a name="ln2237">  //</a>
<a name="ln2238">  // &quot;:function func&quot; with only function name: list function.</a>
<a name="ln2239">  // If bang is given:</a>
<a name="ln2240">  //  - include &quot;!&quot; in function head</a>
<a name="ln2241">  //  - exclude line numbers from function body</a>
<a name="ln2242">  //</a>
<a name="ln2243">  if (!paren) {</a>
<a name="ln2244">    if (!ends_excmd(*skipwhite(p))) {</a>
<a name="ln2245">      semsg(_(e_trailing_arg), p);</a>
<a name="ln2246">      goto ret_free;</a>
<a name="ln2247">    }</a>
<a name="ln2248">    eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln2249">    if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln2250">      *p = NUL;</a>
<a name="ln2251">    }</a>
<a name="ln2252">    if (!eap-&gt;skip &amp;&amp; !got_int) {</a>
<a name="ln2253">      fp = find_func(name);</a>
<a name="ln2254">      if (fp != NULL) {</a>
<a name="ln2255">        // Check no function was added or removed from a callback, e.g. at</a>
<a name="ln2256">        // the more prompt.  &quot;fp&quot; may then be invalid.</a>
<a name="ln2257">        const int prev_ht_changed = func_hashtab.ht_changed;</a>
<a name="ln2258"> </a>
<a name="ln2259">        if (list_func_head(fp, !eap-&gt;forceit, eap-&gt;forceit) == OK) {</a>
<a name="ln2260">          for (int j = 0; j &lt; fp-&gt;uf_lines.ga_len &amp;&amp; !got_int; j++) {</a>
<a name="ln2261">            if (FUNCLINE(fp, j) == NULL) {</a>
<a name="ln2262">              continue;</a>
<a name="ln2263">            }</a>
<a name="ln2264">            msg_putchar('\n');</a>
<a name="ln2265">            if (!eap-&gt;forceit) {</a>
<a name="ln2266">              msg_outnum(j + 1);</a>
<a name="ln2267">              if (j &lt; 9) {</a>
<a name="ln2268">                msg_putchar(' ');</a>
<a name="ln2269">              }</a>
<a name="ln2270">              if (j &lt; 99) {</a>
<a name="ln2271">                msg_putchar(' ');</a>
<a name="ln2272">              }</a>
<a name="ln2273">              if (function_list_modified(prev_ht_changed)) {</a>
<a name="ln2274">                break;</a>
<a name="ln2275">              }</a>
<a name="ln2276">            }</a>
<a name="ln2277">            msg_prt_line(FUNCLINE(fp, j), false);</a>
<a name="ln2278">            line_breakcheck();  // show multiple lines at a time!</a>
<a name="ln2279">          }</a>
<a name="ln2280">          if (!got_int) {</a>
<a name="ln2281">            msg_putchar('\n');</a>
<a name="ln2282">            if (!function_list_modified(prev_ht_changed)) {</a>
<a name="ln2283">              msg_puts(eap-&gt;forceit ? &quot;endfunction&quot; : &quot;   endfunction&quot;);</a>
<a name="ln2284">            }</a>
<a name="ln2285">          }</a>
<a name="ln2286">        }</a>
<a name="ln2287">      } else {</a>
<a name="ln2288">        emsg_funcname(N_(&quot;E123: Undefined function: %s&quot;), name);</a>
<a name="ln2289">      }</a>
<a name="ln2290">    }</a>
<a name="ln2291">    goto ret_free;</a>
<a name="ln2292">  }</a>
<a name="ln2293"> </a>
<a name="ln2294">  // &quot;:function name(arg1, arg2)&quot; Define function.</a>
<a name="ln2295">  p = skipwhite(p);</a>
<a name="ln2296">  if (*p != '(') {</a>
<a name="ln2297">    if (!eap-&gt;skip) {</a>
<a name="ln2298">      semsg(_(&quot;E124: Missing '(': %s&quot;), eap-&gt;arg);</a>
<a name="ln2299">      goto ret_free;</a>
<a name="ln2300">    }</a>
<a name="ln2301">    // attempt to continue by skipping some text</a>
<a name="ln2302">    if (vim_strchr(p, '(') != NULL) {</a>
<a name="ln2303">      p = vim_strchr(p, '(');</a>
<a name="ln2304">    }</a>
<a name="ln2305">  }</a>
<a name="ln2306">  p = skipwhite(p + 1);</a>
<a name="ln2307"> </a>
<a name="ln2308">  ga_init(&amp;newargs, (int)sizeof(char *), 3);</a>
<a name="ln2309">  ga_init(&amp;newlines, (int)sizeof(char *), 3);</a>
<a name="ln2310"> </a>
<a name="ln2311">  if (!eap-&gt;skip) {</a>
<a name="ln2312">    // Check the name of the function.  Unless it's a dictionary function</a>
<a name="ln2313">    // (that we are overwriting).</a>
<a name="ln2314">    if (name != NULL) {</a>
<a name="ln2315">      arg = name;</a>
<a name="ln2316">    } else {</a>
<a name="ln2317">      arg = fudi.fd_newkey;</a>
<a name="ln2318">    }</a>
<a name="ln2319">    if (arg != NULL &amp;&amp; (fudi.fd_di == NULL || !tv_is_func(fudi.fd_di-&gt;di_tv))) {</a>
<a name="ln2320">      int j = ((uint8_t)(*arg) == K_SPECIAL) ? 3 : 0;</a>
<a name="ln2321">      while (arg[j] != NUL &amp;&amp; (j == 0 ? eval_isnamec1(arg[j]) : eval_isnamec(arg[j]))) {</a>
<a name="ln2322">        j++;</a>
<a name="ln2323">      }</a>
<a name="ln2324">      if (arg[j] != NUL) {</a>
<a name="ln2325">        emsg_funcname(e_invarg2, arg);</a>
<a name="ln2326">      }</a>
<a name="ln2327">    }</a>
<a name="ln2328">    // Disallow using the g: dict.</a>
<a name="ln2329">    if (fudi.fd_dict != NULL &amp;&amp; fudi.fd_dict-&gt;dv_scope == VAR_DEF_SCOPE) {</a>
<a name="ln2330">      emsg(_(&quot;E862: Cannot use g: here&quot;));</a>
<a name="ln2331">    }</a>
<a name="ln2332">  }</a>
<a name="ln2333"> </a>
<a name="ln2334">  if (get_function_args(&amp;p, ')', &amp;newargs, &amp;varargs,</a>
<a name="ln2335">                        &amp;default_args, eap-&gt;skip) == FAIL) {</a>
<a name="ln2336">    goto errret_2;</a>
<a name="ln2337">  }</a>
<a name="ln2338"> </a>
<a name="ln2339">  if (KeyTyped &amp;&amp; ui_has(kUICmdline)) {</a>
<a name="ln2340">    show_block = true;</a>
<a name="ln2341">    ui_ext_cmdline_block_append(0, eap-&gt;cmd);</a>
<a name="ln2342">  }</a>
<a name="ln2343"> </a>
<a name="ln2344">  // find extra arguments &quot;range&quot;, &quot;dict&quot;, &quot;abort&quot; and &quot;closure&quot;</a>
<a name="ln2345">  while (true) {</a>
<a name="ln2346">    p = skipwhite(p);</a>
<a name="ln2347">    if (strncmp(p, &quot;range&quot;, 5) == 0) {</a>
<a name="ln2348">      flags |= FC_RANGE;</a>
<a name="ln2349">      p += 5;</a>
<a name="ln2350">    } else if (strncmp(p, &quot;dict&quot;, 4) == 0) {</a>
<a name="ln2351">      flags |= FC_DICT;</a>
<a name="ln2352">      p += 4;</a>
<a name="ln2353">    } else if (strncmp(p, &quot;abort&quot;, 5) == 0) {</a>
<a name="ln2354">      flags |= FC_ABORT;</a>
<a name="ln2355">      p += 5;</a>
<a name="ln2356">    } else if (strncmp(p, &quot;closure&quot;, 7) == 0) {</a>
<a name="ln2357">      flags |= FC_CLOSURE;</a>
<a name="ln2358">      p += 7;</a>
<a name="ln2359">      if (current_funccal == NULL) {</a>
<a name="ln2360">        emsg_funcname(N_(&quot;E932: Closure function should not be at top level: %s&quot;),</a>
<a name="ln2361">                      name == NULL ? &quot;&quot; : name);</a>
<a name="ln2362">        goto erret;</a>
<a name="ln2363">      }</a>
<a name="ln2364">    } else {</a>
<a name="ln2365">      break;</a>
<a name="ln2366">    }</a>
<a name="ln2367">  }</a>
<a name="ln2368"> </a>
<a name="ln2369">  // When there is a line break use what follows for the function body.</a>
<a name="ln2370">  // Makes 'exe &quot;func Test()\n...\nendfunc&quot;' work.</a>
<a name="ln2371">  if (*p == '\n') {</a>
<a name="ln2372">    line_arg = p + 1;</a>
<a name="ln2373">  } else if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; !eap-&gt;skip &amp;&amp; !did_emsg) {</a>
<a name="ln2374">    semsg(_(e_trailing_arg), p);</a>
<a name="ln2375">  }</a>
<a name="ln2376"> </a>
<a name="ln2377">  // Read the body of the function, until &quot;:endfunction&quot; is found.</a>
<a name="ln2378">  if (KeyTyped) {</a>
<a name="ln2379">    // Check if the function already exists, don't let the user type the</a>
<a name="ln2380">    // whole function before telling him it doesn't work!  For a script we</a>
<a name="ln2381">    // need to skip the body to be able to find what follows.</a>
<a name="ln2382">    if (!eap-&gt;skip &amp;&amp; !eap-&gt;forceit) {</a>
<a name="ln2383">      if (fudi.fd_dict != NULL &amp;&amp; fudi.fd_newkey == NULL) {</a>
<a name="ln2384">        emsg(_(e_funcdict));</a>
<a name="ln2385">      } else if (name != NULL &amp;&amp; find_func(name) != NULL) {</a>
<a name="ln2386">        emsg_funcname(e_funcexts, name);</a>
<a name="ln2387">      }</a>
<a name="ln2388">    }</a>
<a name="ln2389"> </a>
<a name="ln2390">    if (!eap-&gt;skip &amp;&amp; did_emsg) {</a>
<a name="ln2391">      goto erret;</a>
<a name="ln2392">    }</a>
<a name="ln2393"> </a>
<a name="ln2394">    if (!ui_has(kUICmdline)) {</a>
<a name="ln2395">      msg_putchar('\n');              // don't overwrite the function name</a>
<a name="ln2396">    }</a>
<a name="ln2397">    cmdline_row = msg_row;</a>
<a name="ln2398">  }</a>
<a name="ln2399"> </a>
<a name="ln2400">  // Save the starting line number.</a>
<a name="ln2401">  sourcing_lnum_top = SOURCING_LNUM;</a>
<a name="ln2402"> </a>
<a name="ln2403">  indent = 2;</a>
<a name="ln2404">  nesting = 0;</a>
<a name="ln2405">  while (true) {</a>
<a name="ln2406">    if (KeyTyped) {</a>
<a name="ln2407">      msg_scroll = true;</a>
<a name="ln2408">      saved_wait_return = false;</a>
<a name="ln2409">    }</a>
<a name="ln2410">    need_wait_return = false;</a>
<a name="ln2411"> </a>
<a name="ln2412">    if (line_arg != NULL) {</a>
<a name="ln2413">      // Use eap-&gt;arg, split up in parts by line breaks.</a>
<a name="ln2414">      theline = line_arg;</a>
<a name="ln2415">      p = vim_strchr(theline, '\n');</a>
<a name="ln2416">      if (p == NULL) {</a>
<a name="ln2417">        line_arg += strlen(line_arg);</a>
<a name="ln2418">      } else {</a>
<a name="ln2419">        *p = NUL;</a>
<a name="ln2420">        line_arg = p + 1;</a>
<a name="ln2421">      }</a>
<a name="ln2422">    } else {</a>
<a name="ln2423">      xfree(line_to_free);</a>
<a name="ln2424">      if (eap-&gt;getline == NULL) {</a>
<a name="ln2425">        theline = getcmdline(':', 0L, indent, do_concat);</a>
<a name="ln2426">      } else {</a>
<a name="ln2427">        theline = eap-&gt;getline(':', eap-&gt;cookie, indent, do_concat);</a>
<a name="ln2428">      }</a>
<a name="ln2429">      line_to_free = theline;</a>
<a name="ln2430">    }</a>
<a name="ln2431">    if (KeyTyped) {</a>
<a name="ln2432">      lines_left = Rows - 1;</a>
<a name="ln2433">    }</a>
<a name="ln2434">    if (theline == NULL) {</a>
<a name="ln2435">      if (skip_until != NULL) {</a>
<a name="ln2436">        semsg(_(e_missing_heredoc_end_marker_str), skip_until);</a>
<a name="ln2437">      } else {</a>
<a name="ln2438">        emsg(_(&quot;E126: Missing :endfunction&quot;));</a>
<a name="ln2439">      }</a>
<a name="ln2440">      goto erret;</a>
<a name="ln2441">    }</a>
<a name="ln2442">    if (show_block) {</a>
<a name="ln2443">      assert(indent &gt;= 0);</a>
<a name="ln2444">      ui_ext_cmdline_block_append((size_t)indent, theline);</a>
<a name="ln2445">    }</a>
<a name="ln2446"> </a>
<a name="ln2447">    // Detect line continuation: SOURCING_LNUM increased more than one.</a>
<a name="ln2448">    sourcing_lnum_off = get_sourced_lnum(eap-&gt;getline, eap-&gt;cookie);</a>
<a name="ln2449">    if (SOURCING_LNUM &lt; sourcing_lnum_off) {</a>
<a name="ln2450">      sourcing_lnum_off -= SOURCING_LNUM;</a>
<a name="ln2451">    } else {</a>
<a name="ln2452">      sourcing_lnum_off = 0;</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    if (skip_until != NULL) {</a>
<a name="ln2456">      // Don't check for &quot;:endfunc&quot; between</a>
<a name="ln2457">      // * &quot;:append&quot; and &quot;.&quot;</a>
<a name="ln2458">      // * &quot;:python &lt;&lt;EOF&quot; and &quot;EOF&quot;</a>
<a name="ln2459">      // * &quot;:let {var-name} =&lt;&lt; [trim] {marker}&quot; and &quot;{marker}&quot;</a>
<a name="ln2460">      if (heredoc_trimmed == NULL</a>
<a name="ln2461">          || (is_heredoc &amp;&amp; skipwhite(theline) == theline)</a>
<a name="ln2462">          || strncmp(theline, heredoc_trimmed,</a>
<a name="ln2463">                     strlen(heredoc_trimmed)) == 0) {</a>
<a name="ln2464">        if (heredoc_trimmed == NULL) {</a>
<a name="ln2465">          p = theline;</a>
<a name="ln2466">        } else if (is_heredoc) {</a>
<a name="ln2467">          p = skipwhite(theline) == theline</a>
<a name="ln2468">            ? theline : theline + strlen(heredoc_trimmed);</a>
<a name="ln2469">        } else {</a>
<a name="ln2470">          p = theline + strlen(heredoc_trimmed);</a>
<a name="ln2471">        }</a>
<a name="ln2472">        if (strcmp(p, skip_until) == 0) {</a>
<a name="ln2473">          XFREE_CLEAR(skip_until);</a>
<a name="ln2474">          XFREE_CLEAR(heredoc_trimmed);</a>
<a name="ln2475">          do_concat = true;</a>
<a name="ln2476">          is_heredoc = false;</a>
<a name="ln2477">        }</a>
<a name="ln2478">      }</a>
<a name="ln2479">    } else {</a>
<a name="ln2480">      // skip ':' and blanks</a>
<a name="ln2481">      for (p = theline; ascii_iswhite(*p) || *p == ':'; p++) {}</a>
<a name="ln2482"> </a>
<a name="ln2483">      // Check for &quot;endfunction&quot;.</a>
<a name="ln2484">      if (checkforcmd(&amp;p, &quot;endfunction&quot;, 4) &amp;&amp; nesting-- == 0) {</a>
<a name="ln2485">        if (*p == '!') {</a>
<a name="ln2486">          p++;</a>
<a name="ln2487">        }</a>
<a name="ln2488">        char *nextcmd = NULL;</a>
<a name="ln2489">        if (*p == '|') {</a>
<a name="ln2490">          nextcmd = p + 1;</a>
<a name="ln2491">        } else if (line_arg != NULL &amp;&amp; *skipwhite(line_arg) != NUL) {</a>
<a name="ln2492">          nextcmd = line_arg;</a>
<a name="ln2493">        } else if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; p_verbose &gt; 0) {</a>
<a name="ln2494">          give_warning2(_(&quot;W22: Text found after :endfunction: %s&quot;), p, true);</a>
<a name="ln2495">        }</a>
<a name="ln2496">        if (nextcmd != NULL) {</a>
<a name="ln2497">          // Another command follows. If the line came from &quot;eap&quot; we</a>
<a name="ln2498">          // can simply point into it, otherwise we need to change</a>
<a name="ln2499">          // &quot;eap-&gt;cmdlinep&quot;.</a>
<a name="ln2500">          eap-&gt;nextcmd = nextcmd;</a>
<a name="ln2501">          if (line_to_free != NULL) {</a>
<a name="ln2502">            xfree(*eap-&gt;cmdlinep);</a>
<a name="ln2503">            *eap-&gt;cmdlinep = line_to_free;</a>
<a name="ln2504">            line_to_free = NULL;</a>
<a name="ln2505">          }</a>
<a name="ln2506">        }</a>
<a name="ln2507">        break;</a>
<a name="ln2508">      }</a>
<a name="ln2509"> </a>
<a name="ln2510">      // Increase indent inside &quot;if&quot;, &quot;while&quot;, &quot;for&quot; and &quot;try&quot;, decrease</a>
<a name="ln2511">      // at &quot;end&quot;.</a>
<a name="ln2512">      if (indent &gt; 2 &amp;&amp; strncmp(p, &quot;end&quot;, 3) == 0) {</a>
<a name="ln2513">        indent -= 2;</a>
<a name="ln2514">      } else if (strncmp(p, &quot;if&quot;, 2) == 0</a>
<a name="ln2515">                 || strncmp(p, &quot;wh&quot;, 2) == 0</a>
<a name="ln2516">                 || strncmp(p, &quot;for&quot;, 3) == 0</a>
<a name="ln2517">                 || strncmp(p, &quot;try&quot;, 3) == 0) {</a>
<a name="ln2518">        indent += 2;</a>
<a name="ln2519">      }</a>
<a name="ln2520"> </a>
<a name="ln2521">      // Check for defining a function inside this function.</a>
<a name="ln2522">      if (checkforcmd(&amp;p, &quot;function&quot;, 2)) {</a>
<a name="ln2523">        if (*p == '!') {</a>
<a name="ln2524">          p = skipwhite(p + 1);</a>
<a name="ln2525">        }</a>
<a name="ln2526">        p += eval_fname_script(p);</a>
<a name="ln2527">        xfree(trans_function_name(&amp;p, true, 0, NULL, NULL));</a>
<a name="ln2528">        if (*skipwhite(p) == '(') {</a>
<a name="ln2529">          if (nesting == MAX_FUNC_NESTING - 1) {</a>
<a name="ln2530">            emsg(_(e_function_nesting_too_deep));</a>
<a name="ln2531">          } else {</a>
<a name="ln2532">            nesting++;</a>
<a name="ln2533">            indent += 2;</a>
<a name="ln2534">          }</a>
<a name="ln2535">        }</a>
<a name="ln2536">      }</a>
<a name="ln2537"> </a>
<a name="ln2538">      // Check for &quot;:append&quot;, &quot;:change&quot;, &quot;:insert&quot;.</a>
<a name="ln2539">      p = skip_range(p, NULL);</a>
<a name="ln2540">      if ((p[0] == 'a' &amp;&amp; (!ASCII_ISALPHA(p[1]) || p[1] == 'p'))</a>
<a name="ln2541">          || (p[0] == 'c'</a>
<a name="ln2542">              &amp;&amp; (!ASCII_ISALPHA(p[1])</a>
<a name="ln2543">                  || (p[1] == 'h' &amp;&amp; (!ASCII_ISALPHA(p[2])</a>
<a name="ln2544">                                      || (p[2] == 'a'</a>
<a name="ln2545">                                          &amp;&amp; (strncmp(&amp;p[3], &quot;nge&quot;, 3) != 0</a>
<a name="ln2546">                                              || !ASCII_ISALPHA(p[6])))))))</a>
<a name="ln2547">          || (p[0] == 'i'</a>
<a name="ln2548">              &amp;&amp; (!ASCII_ISALPHA(p[1]) || (p[1] == 'n'</a>
<a name="ln2549">                                           &amp;&amp; (!ASCII_ISALPHA(p[2])</a>
<a name="ln2550">                                               || (p[2] == 's')))))) {</a>
<a name="ln2551">        skip_until = xstrdup(&quot;.&quot;);</a>
<a name="ln2552">      }</a>
<a name="ln2553"> </a>
<a name="ln2554">      // heredoc: Check for &quot;:python &lt;&lt;EOF&quot;, &quot;:lua &lt;&lt;EOF&quot;, etc.</a>
<a name="ln2555">      arg = skipwhite(skiptowhite(p));</a>
<a name="ln2556">      if (arg[0] == '&lt;' &amp;&amp; arg[1] == '&lt;'</a>
<a name="ln2557">          &amp;&amp; ((p[0] == 'p' &amp;&amp; p[1] == 'y'</a>
<a name="ln2558">               &amp;&amp; (!ASCII_ISALNUM(p[2]) || p[2] == 't'</a>
<a name="ln2559">                   || ((p[2] == '3' || p[2] == 'x')</a>
<a name="ln2560">                       &amp;&amp; !ASCII_ISALPHA(p[3]))))</a>
<a name="ln2561">              || (p[0] == 'p' &amp;&amp; p[1] == 'e'</a>
<a name="ln2562">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 'r'))</a>
<a name="ln2563">              || (p[0] == 't' &amp;&amp; p[1] == 'c'</a>
<a name="ln2564">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 'l'))</a>
<a name="ln2565">              || (p[0] == 'l' &amp;&amp; p[1] == 'u' &amp;&amp; p[2] == 'a'</a>
<a name="ln2566">                  &amp;&amp; !ASCII_ISALPHA(p[3]))</a>
<a name="ln2567">              || (p[0] == 'r' &amp;&amp; p[1] == 'u' &amp;&amp; p[2] == 'b'</a>
<a name="ln2568">                  &amp;&amp; (!ASCII_ISALPHA(p[3]) || p[3] == 'y'))</a>
<a name="ln2569">              || (p[0] == 'm' &amp;&amp; p[1] == 'z'</a>
<a name="ln2570">                  &amp;&amp; (!ASCII_ISALPHA(p[2]) || p[2] == 's')))) {</a>
<a name="ln2571">        // &quot;:python &lt;&lt;&quot; continues until a dot, like &quot;:append&quot;</a>
<a name="ln2572">        p = skipwhite(arg + 2);</a>
<a name="ln2573">        if (strncmp(p, &quot;trim&quot;, 4) == 0) {</a>
<a name="ln2574">          // Ignore leading white space.</a>
<a name="ln2575">          p = skipwhite(p + 4);</a>
<a name="ln2576">          heredoc_trimmed = xstrnsave(theline, (size_t)(skipwhite(theline) - theline));</a>
<a name="ln2577">        }</a>
<a name="ln2578">        if (*p == NUL) {</a>
<a name="ln2579">          skip_until = xstrdup(&quot;.&quot;);</a>
<a name="ln2580">        } else {</a>
<a name="ln2581">          skip_until = xstrnsave(p, (size_t)(skiptowhite(p) - p));</a>
<a name="ln2582">        }</a>
<a name="ln2583">        do_concat = false;</a>
<a name="ln2584">        is_heredoc = true;</a>
<a name="ln2585">      }</a>
<a name="ln2586"> </a>
<a name="ln2587">      // Check for &quot;:let v =&lt;&lt; [trim] EOF&quot;</a>
<a name="ln2588">      //       and &quot;:let [a, b] =&lt;&lt; [trim] EOF&quot;</a>
<a name="ln2589">      arg = p;</a>
<a name="ln2590">      if (checkforcmd(&amp;arg, &quot;let&quot;, 2)) {</a>
<a name="ln2591">        while (vim_strchr(&quot;$@&amp;&quot;, *arg) != NULL) {</a>
<a name="ln2592">          arg++;</a>
<a name="ln2593">        }</a>
<a name="ln2594">        arg = skipwhite(find_name_end(arg, NULL, NULL, FNE_INCL_BR));</a>
<a name="ln2595">        if (arg[0] == '=' &amp;&amp; arg[1] == '&lt;' &amp;&amp; arg[2] == '&lt;') {</a>
<a name="ln2596">          p = skipwhite(arg + 3);</a>
<a name="ln2597">          while (true) {</a>
<a name="ln2598">            if (strncmp(p, &quot;trim&quot;, 4) == 0) {</a>
<a name="ln2599">              // Ignore leading white space.</a>
<a name="ln2600">              p = skipwhite(p + 4);</a>
<a name="ln2601">              heredoc_trimmed = xstrnsave(theline, (size_t)(skipwhite(theline) - theline));</a>
<a name="ln2602">              continue;</a>
<a name="ln2603">            }</a>
<a name="ln2604">            if (strncmp(p, &quot;eval&quot;, 4) == 0) {</a>
<a name="ln2605">              // Ignore leading white space.</a>
<a name="ln2606">              p = skipwhite(p + 4);</a>
<a name="ln2607">              continue;</a>
<a name="ln2608">            }</a>
<a name="ln2609">            break;</a>
<a name="ln2610">          }</a>
<a name="ln2611">          skip_until = xstrnsave(p, (size_t)(skiptowhite(p) - p));</a>
<a name="ln2612">          do_concat = false;</a>
<a name="ln2613">          is_heredoc = true;</a>
<a name="ln2614">        }</a>
<a name="ln2615">      }</a>
<a name="ln2616">    }</a>
<a name="ln2617"> </a>
<a name="ln2618">    // Add the line to the function.</a>
<a name="ln2619">    ga_grow(&amp;newlines, 1 + (int)sourcing_lnum_off);</a>
<a name="ln2620"> </a>
<a name="ln2621">    // Copy the line to newly allocated memory.  get_one_sourceline()</a>
<a name="ln2622">    // allocates 250 bytes per line, this saves 80% on average.  The cost</a>
<a name="ln2623">    // is an extra alloc/free.</a>
<a name="ln2624">    p = xstrdup(theline);</a>
<a name="ln2625">    ((char **)(newlines.ga_data))[newlines.ga_len++] = p;</a>
<a name="ln2626"> </a>
<a name="ln2627">    // Add NULL lines for continuation lines, so that the line count is</a>
<a name="ln2628">    // equal to the index in the growarray.</a>
<a name="ln2629">    while (sourcing_lnum_off-- &gt; 0) {</a>
<a name="ln2630">      ((char **)(newlines.ga_data))[newlines.ga_len++] = NULL;</a>
<a name="ln2631">    }</a>
<a name="ln2632"> </a>
<a name="ln2633">    // Check for end of eap-&gt;arg.</a>
<a name="ln2634">    if (line_arg != NULL &amp;&amp; *line_arg == NUL) {</a>
<a name="ln2635">      line_arg = NULL;</a>
<a name="ln2636">    }</a>
<a name="ln2637">  }</a>
<a name="ln2638"> </a>
<a name="ln2639">  // Don't define the function when skipping commands or when an error was</a>
<a name="ln2640">  // detected.</a>
<a name="ln2641">  if (eap-&gt;skip || did_emsg) {</a>
<a name="ln2642">    goto erret;</a>
<a name="ln2643">  }</a>
<a name="ln2644"> </a>
<a name="ln2645">  // If there are no errors, add the function</a>
<a name="ln2646">  if (fudi.fd_dict == NULL) {</a>
<a name="ln2647">    v = find_var(name, strlen(name), &amp;ht, false);</a>
<a name="ln2648">    if (v != NULL &amp;&amp; v-&gt;di_tv.v_type == VAR_FUNC) {</a>
<a name="ln2649">      emsg_funcname(N_(&quot;E707: Function name conflicts with variable: %s&quot;), name);</a>
<a name="ln2650">      goto erret;</a>
<a name="ln2651">    }</a>
<a name="ln2652"> </a>
<a name="ln2653">    fp = find_func(name);</a>
<a name="ln2654">    if (fp != NULL) {</a>
<a name="ln2655">      // Function can be replaced with &quot;function!&quot; and when sourcing the</a>
<a name="ln2656">      // same script again, but only once.</a>
<a name="ln2657">      if (!eap-&gt;forceit</a>
<a name="ln2658">          &amp;&amp; (fp-&gt;uf_script_ctx.sc_sid != current_sctx.sc_sid</a>
<a name="ln2659">              || fp-&gt;uf_script_ctx.sc_seq == current_sctx.sc_seq)) {</a>
<a name="ln2660">        emsg_funcname(e_funcexts, name);</a>
<a name="ln2661">        goto erret;</a>
<a name="ln2662">      }</a>
<a name="ln2663">      if (fp-&gt;uf_calls &gt; 0) {</a>
<a name="ln2664">        emsg_funcname(N_(&quot;E127: Cannot redefine function %s: It is in use&quot;), name);</a>
<a name="ln2665">        goto erret;</a>
<a name="ln2666">      }</a>
<a name="ln2667">      if (fp-&gt;uf_refcount &gt; 1) {</a>
<a name="ln2668">        // This function is referenced somewhere, don't redefine it but</a>
<a name="ln2669">        // create a new one.</a>
<a name="ln2670">        (fp-&gt;uf_refcount)--;</a>
<a name="ln2671">        fp-&gt;uf_flags |= FC_REMOVED;</a>
<a name="ln2672">        fp = NULL;</a>
<a name="ln2673">        overwrite = true;</a>
<a name="ln2674">      } else {</a>
<a name="ln2675">        char *exp_name = fp-&gt;uf_name_exp;</a>
<a name="ln2676">        // redefine existing function, keep the expanded name</a>
<a name="ln2677">        XFREE_CLEAR(name);</a>
<a name="ln2678">        fp-&gt;uf_name_exp = NULL;</a>
<a name="ln2679">        func_clear_items(fp);</a>
<a name="ln2680">        fp-&gt;uf_name_exp = exp_name;</a>
<a name="ln2681">        fp-&gt;uf_profiling = false;</a>
<a name="ln2682">        fp-&gt;uf_prof_initialized = false;</a>
<a name="ln2683">      }</a>
<a name="ln2684">    }</a>
<a name="ln2685">  } else {</a>
<a name="ln2686">    char numbuf[20];</a>
<a name="ln2687"> </a>
<a name="ln2688">    fp = NULL;</a>
<a name="ln2689">    if (fudi.fd_newkey == NULL &amp;&amp; !eap-&gt;forceit) {</a>
<a name="ln2690">      emsg(_(e_funcdict));</a>
<a name="ln2691">      goto erret;</a>
<a name="ln2692">    }</a>
<a name="ln2693">    if (fudi.fd_di == NULL) {</a>
<a name="ln2694">      if (value_check_lock(fudi.fd_dict-&gt;dv_lock, eap-&gt;arg, TV_CSTRING)) {</a>
<a name="ln2695">        // Can't add a function to a locked dictionary</a>
<a name="ln2696">        goto erret;</a>
<a name="ln2697">      }</a>
<a name="ln2698">    } else if (value_check_lock(fudi.fd_di-&gt;di_tv.v_lock, eap-&gt;arg, TV_CSTRING)) {</a>
<a name="ln2699">      // Can't change an existing function if it is locked</a>
<a name="ln2700">      goto erret;</a>
<a name="ln2701">    }</a>
<a name="ln2702"> </a>
<a name="ln2703">    // Give the function a sequential number.  Can only be used with a</a>
<a name="ln2704">    // Funcref!</a>
<a name="ln2705">    xfree(name);</a>
<a name="ln2706">    snprintf(numbuf, sizeof(numbuf), &quot;%d&quot;, ++func_nr);</a>
<a name="ln2707">    name = xstrdup(numbuf);</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  if (fp == NULL) {</a>
<a name="ln2711">    if (fudi.fd_dict == NULL &amp;&amp; vim_strchr(name, AUTOLOAD_CHAR) != NULL) {</a>
<a name="ln2712">      int slen, plen;</a>
<a name="ln2713">      char *scriptname;</a>
<a name="ln2714"> </a>
<a name="ln2715">      // Check that the autoload name matches the script name.</a>
<a name="ln2716">      int j = FAIL;</a>
<a name="ln2717">      if (SOURCING_NAME != NULL) {</a>
<a name="ln2718">        scriptname = autoload_name(name, strlen(name));</a>
<a name="ln2719">        p = vim_strchr(scriptname, '/');</a>
<a name="ln2720">        plen = (int)strlen(p);</a>
<a name="ln2721">        slen = (int)strlen(SOURCING_NAME);</a>
<a name="ln2722">        if (slen &gt; plen &amp;&amp; path_fnamecmp(p, SOURCING_NAME + slen - plen) == 0) {</a>
<a name="ln2723">          j = OK;</a>
<a name="ln2724">        }</a>
<a name="ln2725">        xfree(scriptname);</a>
<a name="ln2726">      }</a>
<a name="ln2727">      if (j == FAIL) {</a>
<a name="ln2728">        semsg(_(&quot;E746: Function name does not match script file name: %s&quot;),</a>
<a name="ln2729">              name);</a>
<a name="ln2730">        goto erret;</a>
<a name="ln2731">      }</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    fp = xcalloc(1, offsetof(ufunc_T, uf_name) + strlen(name) + 1);</a>
<a name="ln2735"> </a>
<a name="ln2736">    if (fudi.fd_dict != NULL) {</a>
<a name="ln2737">      if (fudi.fd_di == NULL) {</a>
<a name="ln2738">        // Add new dict entry</a>
<a name="ln2739">        fudi.fd_di = tv_dict_item_alloc(fudi.fd_newkey);</a>
<a name="ln2740">        if (tv_dict_add(fudi.fd_dict, fudi.fd_di) == FAIL) {</a>
<a name="ln2741">          xfree(fudi.fd_di);</a>
<a name="ln2742">          xfree(fp);</a>
<a name="ln2743">          goto erret;</a>
<a name="ln2744">        }</a>
<a name="ln2745">      } else {</a>
<a name="ln2746">        // Overwrite existing dict entry.</a>
<a name="ln2747">        tv_clear(&amp;fudi.fd_di-&gt;di_tv);</a>
<a name="ln2748">      }</a>
<a name="ln2749">      fudi.fd_di-&gt;di_tv.v_type = VAR_FUNC;</a>
<a name="ln2750">      fudi.fd_di-&gt;di_tv.vval.v_string = xstrdup(name);</a>
<a name="ln2751"> </a>
<a name="ln2752">      // behave like &quot;dict&quot; was used</a>
<a name="ln2753">      flags |= FC_DICT;</a>
<a name="ln2754">    }</a>
<a name="ln2755"> </a>
<a name="ln2756">    // insert the new function in the function list</a>
<a name="ln2757">    set_ufunc_name(fp, name);</a>
<a name="ln2758">    if (overwrite) {</a>
<a name="ln2759">      hi = hash_find(&amp;func_hashtab, name);</a>
<a name="ln2760">      hi-&gt;hi_key = UF2HIKEY(fp);</a>
<a name="ln2761">    } else if (hash_add(&amp;func_hashtab, UF2HIKEY(fp)) == FAIL) {</a>
<a name="ln2762">      xfree(fp);</a>
<a name="ln2763">      goto erret;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    fp-&gt;uf_refcount = 1;</a>
<a name="ln2766">  }</a>
<a name="ln2767">  fp-&gt;uf_args = newargs;</a>
<a name="ln2768">  fp-&gt;uf_def_args = default_args;</a>
<a name="ln2769">  fp-&gt;uf_lines = newlines;</a>
<a name="ln2770">  if ((flags &amp; FC_CLOSURE) != 0) {</a>
<a name="ln2771">    register_closure(fp);</a>
<a name="ln2772">  } else {</a>
<a name="ln2773">    fp-&gt;uf_scoped = NULL;</a>
<a name="ln2774">  }</a>
<a name="ln2775">  if (prof_def_func()) {</a>
<a name="ln2776">    func_do_profile(fp);</a>
<a name="ln2777">  }</a>
<a name="ln2778">  fp-&gt;uf_varargs = varargs;</a>
<a name="ln2779">  if (sandbox) {</a>
<a name="ln2780">    flags |= FC_SANDBOX;</a>
<a name="ln2781">  }</a>
<a name="ln2782">  fp-&gt;uf_flags = flags;</a>
<a name="ln2783">  fp-&gt;uf_calls = 0;</a>
<a name="ln2784">  fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln2785">  fp-&gt;uf_script_ctx.sc_lnum += sourcing_lnum_top;</a>
<a name="ln2786">  nlua_set_sctx(&amp;fp-&gt;uf_script_ctx);</a>
<a name="ln2787"> </a>
<a name="ln2788">  goto ret_free;</a>
<a name="ln2789"> </a>
<a name="ln2790">erret:</a>
<a name="ln2791">  ga_clear_strings(&amp;newargs);</a>
<a name="ln2792">  ga_clear_strings(&amp;default_args);</a>
<a name="ln2793">errret_2:</a>
<a name="ln2794">  ga_clear_strings(&amp;newlines);</a>
<a name="ln2795">ret_free:</a>
<a name="ln2796">  xfree(skip_until);</a>
<a name="ln2797">  xfree(heredoc_trimmed);</a>
<a name="ln2798">  xfree(line_to_free);</a>
<a name="ln2799">  xfree(fudi.fd_newkey);</a>
<a name="ln2800">  xfree(name);</a>
<a name="ln2801">  did_emsg |= saved_did_emsg;</a>
<a name="ln2802">  need_wait_return |= saved_wait_return;</a>
<a name="ln2803">  if (show_block) {</a>
<a name="ln2804">    ui_ext_cmdline_block_leave();</a>
<a name="ln2805">  }</a>
<a name="ln2806">}</a>
<a name="ln2807"> </a>
<a name="ln2808">/// @return  5 if &quot;p&quot; starts with &quot;&lt;SID&gt;&quot; or &quot;&lt;SNR&gt;&quot; (ignoring case).</a>
<a name="ln2809">///          2 if &quot;p&quot; starts with &quot;s:&quot;.</a>
<a name="ln2810">///          0 otherwise.</a>
<a name="ln2811">int eval_fname_script(const char *const p)</a>
<a name="ln2812">{</a>
<a name="ln2813">  // Use mb_strnicmp() because in Turkish comparing the &quot;I&quot; may not work with</a>
<a name="ln2814">  // the standard library function.</a>
<a name="ln2815">  if (p[0] == '&lt;'</a>
<a name="ln2816">      &amp;&amp; (mb_strnicmp(p + 1, &quot;SID&gt;&quot;, 4) == 0</a>
<a name="ln2817">          || mb_strnicmp(p + 1, &quot;SNR&gt;&quot;, 4) == 0)) {</a>
<a name="ln2818">    return 5;</a>
<a name="ln2819">  }</a>
<a name="ln2820">  if (p[0] == 's' &amp;&amp; p[1] == ':') {</a>
<a name="ln2821">    return 2;</a>
<a name="ln2822">  }</a>
<a name="ln2823">  return 0;</a>
<a name="ln2824">}</a>
<a name="ln2825"> </a>
<a name="ln2826">bool translated_function_exists(const char *name)</a>
<a name="ln2827">{</a>
<a name="ln2828">  if (builtin_function(name, -1)) {</a>
<a name="ln2829">    return find_internal_func(name) != NULL;</a>
<a name="ln2830">  }</a>
<a name="ln2831">  return find_func(name) != NULL;</a>
<a name="ln2832">}</a>
<a name="ln2833"> </a>
<a name="ln2834">/// Check whether function with the given name exists</a>
<a name="ln2835">///</a>
<a name="ln2836">/// @param[in] name  Function name.</a>
<a name="ln2837">/// @param[in] no_deref  Whether to dereference a Funcref.</a>
<a name="ln2838">///</a>
<a name="ln2839">/// @return  true if it exists, false otherwise.</a>
<a name="ln2840">bool function_exists(const char *const name, bool no_deref)</a>
<a name="ln2841">{</a>
<a name="ln2842">  const char *nm = name;</a>
<a name="ln2843">  bool n = false;</a>
<a name="ln2844">  int flag = TFN_INT | TFN_QUIET | TFN_NO_AUTOLOAD;</a>
<a name="ln2845"> </a>
<a name="ln2846">  if (no_deref) {</a>
<a name="ln2847">    flag |= TFN_NO_DEREF;</a>
<a name="ln2848">  }</a>
<a name="ln2849">  char *const p = trans_function_name((char **)&amp;nm, false, flag, NULL, NULL);</a>
<a name="ln2850">  nm = skipwhite(nm);</a>
<a name="ln2851"> </a>
<a name="ln2852">  // Only accept &quot;funcname&quot;, &quot;funcname &quot;, &quot;funcname (...&quot; and</a>
<a name="ln2853">  // &quot;funcname(...&quot;, not &quot;funcname!...&quot;.</a>
<a name="ln2854">  if (p != NULL &amp;&amp; (*nm == NUL || *nm == '(')) {</a>
<a name="ln2855">    n = translated_function_exists(p);</a>
<a name="ln2856">  }</a>
<a name="ln2857">  xfree(p);</a>
<a name="ln2858">  return n;</a>
<a name="ln2859">}</a>
<a name="ln2860"> </a>
<a name="ln2861">/// Function given to ExpandGeneric() to obtain the list of user defined</a>
<a name="ln2862">/// function names.</a>
<a name="ln2863">char *get_user_func_name(expand_T *xp, int idx)</a>
<a name="ln2864">{</a>
<a name="ln2865">  static size_t done;</a>
<a name="ln2866">  static int changed;</a>
<a name="ln2867">  static hashitem_T *hi;</a>
<a name="ln2868">  ufunc_T *fp;</a>
<a name="ln2869"> </a>
<a name="ln2870">  if (idx == 0) {</a>
<a name="ln2871">    done = 0;</a>
<a name="ln2872">    hi = func_hashtab.ht_array;</a>
<a name="ln2873">    changed = func_hashtab.ht_changed;</a>
<a name="ln2874">  }</a>
<a name="ln2875">  assert(hi);</a>
<a name="ln2876">  if (changed == func_hashtab.ht_changed &amp;&amp; done &lt; func_hashtab.ht_used) {</a>
<a name="ln2877">    if (done++ &gt; 0) {</a>
<a name="ln2878">      hi++;</a>
<a name="ln2879">    }</a>
<a name="ln2880">    while (HASHITEM_EMPTY(hi)) {</a>
<a name="ln2881">      hi++;</a>
<a name="ln2882">    }</a>
<a name="ln2883">    fp = HI2UF(hi);</a>
<a name="ln2884"> </a>
<a name="ln2885">    if ((fp-&gt;uf_flags &amp; FC_DICT)</a>
<a name="ln2886">        || strncmp(fp-&gt;uf_name, &quot;&lt;lambda&gt;&quot;, 8) == 0) {</a>
<a name="ln2887">      return &quot;&quot;;       // don't show dict and lambda functions</a>
<a name="ln2888">    }</a>
<a name="ln2889"> </a>
<a name="ln2890">    if (strlen(fp-&gt;uf_name) + 4 &gt;= IOSIZE) {</a>
<a name="ln2891">      return fp-&gt;uf_name;  // Prevent overflow.</a>
<a name="ln2892">    }</a>
<a name="ln2893"> </a>
<a name="ln2894">    cat_func_name(IObuff, IOSIZE, fp);</a>
<a name="ln2895">    if (xp-&gt;xp_context != EXPAND_USER_FUNC) {</a>
<a name="ln2896">      xstrlcat(IObuff, &quot;(&quot;, IOSIZE);</a>
<a name="ln2897">      if (!fp-&gt;uf_varargs &amp;&amp; GA_EMPTY(&amp;fp-&gt;uf_args)) {</a>
<a name="ln2898">        xstrlcat(IObuff, &quot;)&quot;, IOSIZE);</a>
<a name="ln2899">      }</a>
<a name="ln2900">    }</a>
<a name="ln2901">    return IObuff;</a>
<a name="ln2902">  }</a>
<a name="ln2903">  return NULL;</a>
<a name="ln2904">}</a>
<a name="ln2905"> </a>
<a name="ln2906">/// &quot;:delfunction {name}&quot;</a>
<a name="ln2907">void ex_delfunction(exarg_T *eap)</a>
<a name="ln2908">{</a>
<a name="ln2909">  ufunc_T *fp = NULL;</a>
<a name="ln2910">  char *p;</a>
<a name="ln2911">  char *name;</a>
<a name="ln2912">  funcdict_T fudi;</a>
<a name="ln2913"> </a>
<a name="ln2914">  p = eap-&gt;arg;</a>
<a name="ln2915">  name = trans_function_name(&amp;p, eap-&gt;skip, 0, &amp;fudi, NULL);</a>
<a name="ln2916">  xfree(fudi.fd_newkey);</a>
<a name="ln2917">  if (name == NULL) {</a>
<a name="ln2918">    if (fudi.fd_dict != NULL &amp;&amp; !eap-&gt;skip) {</a>
<a name="ln2919">      emsg(_(e_funcref));</a>
<a name="ln2920">    }</a>
<a name="ln2921">    return;</a>
<a name="ln2922">  }</a>
<a name="ln2923">  if (!ends_excmd(*skipwhite(p))) {</a>
<a name="ln2924">    xfree(name);</a>
<a name="ln2925">    semsg(_(e_trailing_arg), p);</a>
<a name="ln2926">    return;</a>
<a name="ln2927">  }</a>
<a name="ln2928">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln2929">  if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln2930">    *p = NUL;</a>
<a name="ln2931">  }</a>
<a name="ln2932"> </a>
<a name="ln2933">  if (isdigit((uint8_t)(*name)) &amp;&amp; fudi.fd_dict == NULL) {</a>
<a name="ln2934">    if (!eap-&gt;skip) {</a>
<a name="ln2935">      semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln2936">    }</a>
<a name="ln2937">    xfree(name);</a>
<a name="ln2938">    return;</a>
<a name="ln2939">  }</a>
<a name="ln2940">  if (!eap-&gt;skip) {</a>
<a name="ln2941">    fp = find_func(name);</a>
<a name="ln2942">  }</a>
<a name="ln2943">  xfree(name);</a>
<a name="ln2944"> </a>
<a name="ln2945">  if (!eap-&gt;skip) {</a>
<a name="ln2946">    if (fp == NULL) {</a>
<a name="ln2947">      if (!eap-&gt;forceit) {</a>
<a name="ln2948">        semsg(_(e_nofunc), eap-&gt;arg);</a>
<a name="ln2949">      }</a>
<a name="ln2950">      return;</a>
<a name="ln2951">    }</a>
<a name="ln2952">    if (fp-&gt;uf_calls &gt; 0) {</a>
<a name="ln2953">      semsg(_(&quot;E131: Cannot delete function %s: It is in use&quot;), eap-&gt;arg);</a>
<a name="ln2954">      return;</a>
<a name="ln2955">    }</a>
<a name="ln2956">    // check `uf_refcount &gt; 2` because deleting a function should also reduce</a>
<a name="ln2957">    // the reference count, and 1 is the initial refcount.</a>
<a name="ln2958">    if (fp-&gt;uf_refcount &gt; 2) {</a>
<a name="ln2959">      semsg(_(&quot;Cannot delete function %s: It is being used internally&quot;),</a>
<a name="ln2960">            eap-&gt;arg);</a>
<a name="ln2961">      return;</a>
<a name="ln2962">    }</a>
<a name="ln2963"> </a>
<a name="ln2964">    if (fudi.fd_dict != NULL) {</a>
<a name="ln2965">      // Delete the dict item that refers to the function, it will</a>
<a name="ln2966">      // invoke func_unref() and possibly delete the function.</a>
<a name="ln2967">      tv_dict_item_remove(fudi.fd_dict, fudi.fd_di);</a>
<a name="ln2968">    } else {</a>
<a name="ln2969">      // A normal function (not a numbered function or lambda) has a</a>
<a name="ln2970">      // refcount of 1 for the entry in the hashtable.  When deleting</a>
<a name="ln2971">      // it and the refcount is more than one, it should be kept.</a>
<a name="ln2972">      // A numbered function or lambda should be kept if the refcount is</a>
<a name="ln2973">      // one or more.</a>
<a name="ln2974">      if (fp-&gt;uf_refcount &gt; (func_name_refcount(fp-&gt;uf_name) ? 0 : 1)) {</a>
<a name="ln2975">        // Function is still referenced somewhere. Don't free it but</a>
<a name="ln2976">        // do remove it from the hashtable.</a>
<a name="ln2977">        if (func_remove(fp)) {</a>
<a name="ln2978">          fp-&gt;uf_refcount--;</a>
<a name="ln2979">        }</a>
<a name="ln2980">        fp-&gt;uf_flags |= FC_DELETED;</a>
<a name="ln2981">      } else {</a>
<a name="ln2982">        func_clear_free(fp, false);</a>
<a name="ln2983">      }</a>
<a name="ln2984">    }</a>
<a name="ln2985">  }</a>
<a name="ln2986">}</a>
<a name="ln2987"> </a>
<a name="ln2988">/// Unreference a Function: decrement the reference count and free it when it</a>
<a name="ln2989">/// becomes zero.</a>
<a name="ln2990">void func_unref(char *name)</a>
<a name="ln2991">{</a>
<a name="ln2992">  ufunc_T *fp = NULL;</a>
<a name="ln2993"> </a>
<a name="ln2994">  if (name == NULL || !func_name_refcount(name)) {</a>
<a name="ln2995">    return;</a>
<a name="ln2996">  }</a>
<a name="ln2997"> </a>
<a name="ln2998">  fp = find_func(name);</a>
<a name="ln2999">  if (fp == NULL &amp;&amp; isdigit((uint8_t)(*name))) {</a>
<a name="ln3000">#ifdef EXITFREE</a>
<a name="ln3001">    if (!entered_free_all_mem) {</a>
<a name="ln3002">      internal_error(&quot;func_unref()&quot;);</a>
<a name="ln3003">      abort();</a>
<a name="ln3004">    }</a>
<a name="ln3005">#else</a>
<a name="ln3006">    internal_error(&quot;func_unref()&quot;);</a>
<a name="ln3007">    abort();</a>
<a name="ln3008">#endif</a>
<a name="ln3009">  }</a>
<a name="ln3010">  func_ptr_unref(fp);</a>
<a name="ln3011">}</a>
<a name="ln3012"> </a>
<a name="ln3013">/// Unreference a Function: decrement the reference count and free it when it</a>
<a name="ln3014">/// becomes zero.</a>
<a name="ln3015">/// Unreference user function, freeing it if needed</a>
<a name="ln3016">///</a>
<a name="ln3017">/// Decrements the reference count and frees when it becomes zero.</a>
<a name="ln3018">///</a>
<a name="ln3019">/// @param  fp  Function to unreference.</a>
<a name="ln3020">void func_ptr_unref(ufunc_T *fp)</a>
<a name="ln3021">{</a>
<a name="ln3022">  if (fp != NULL &amp;&amp; --fp-&gt;uf_refcount &lt;= 0) {</a>
<a name="ln3023">    // Only delete it when it's not being used. Otherwise it's done</a>
<a name="ln3024">    // when &quot;uf_calls&quot; becomes zero.</a>
<a name="ln3025">    if (fp-&gt;uf_calls == 0) {</a>
<a name="ln3026">      func_clear_free(fp, false);</a>
<a name="ln3027">    }</a>
<a name="ln3028">  }</a>
<a name="ln3029">}</a>
<a name="ln3030"> </a>
<a name="ln3031">/// Count a reference to a Function.</a>
<a name="ln3032">void func_ref(char *name)</a>
<a name="ln3033">{</a>
<a name="ln3034">  ufunc_T *fp;</a>
<a name="ln3035"> </a>
<a name="ln3036">  if (name == NULL || !func_name_refcount(name)) {</a>
<a name="ln3037">    return;</a>
<a name="ln3038">  }</a>
<a name="ln3039">  fp = find_func(name);</a>
<a name="ln3040">  if (fp != NULL) {</a>
<a name="ln3041">    (fp-&gt;uf_refcount)++;</a>
<a name="ln3042">  } else if (isdigit((uint8_t)(*name))) {</a>
<a name="ln3043">    // Only give an error for a numbered function.</a>
<a name="ln3044">    // Fail silently, when named or lambda function isn't found.</a>
<a name="ln3045">    internal_error(&quot;func_ref()&quot;);</a>
<a name="ln3046">  }</a>
<a name="ln3047">}</a>
<a name="ln3048"> </a>
<a name="ln3049">/// Count a reference to a Function.</a>
<a name="ln3050">void func_ptr_ref(ufunc_T *fp)</a>
<a name="ln3051">{</a>
<a name="ln3052">  if (fp != NULL) {</a>
<a name="ln3053">    (fp-&gt;uf_refcount)++;</a>
<a name="ln3054">  }</a>
<a name="ln3055">}</a>
<a name="ln3056"> </a>
<a name="ln3057">/// Check whether funccall is still referenced outside</a>
<a name="ln3058">///</a>
<a name="ln3059">/// It is supposed to be referenced if either it is referenced itself or if l:,</a>
<a name="ln3060">/// a: or a:000 are referenced as all these are statically allocated within</a>
<a name="ln3061">/// funccall structure.</a>
<a name="ln3062">static inline bool fc_referenced(const funccall_T *const fc)</a>
<a name="ln3063">  FUNC_ATTR_ALWAYS_INLINE FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3064">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3065">{</a>
<a name="ln3066">  return ((fc-&gt;fc_l_varlist.lv_refcount  // NOLINT(runtime/deprecated)</a>
<a name="ln3067">           != DO_NOT_FREE_CNT)</a>
<a name="ln3068">          || fc-&gt;fc_l_vars.dv_refcount != DO_NOT_FREE_CNT</a>
<a name="ln3069">          || fc-&gt;fc_l_avars.dv_refcount != DO_NOT_FREE_CNT</a>
<a name="ln3070">          || fc-&gt;fc_refcount &gt; 0);</a>
<a name="ln3071">}</a>
<a name="ln3072"> </a>
<a name="ln3073">/// @return true if items in &quot;fc&quot; do not have &quot;copyID&quot;.  That means they are not</a>
<a name="ln3074">/// referenced from anywhere that is in use.</a>
<a name="ln3075">static int can_free_funccal(funccall_T *fc, int copyID)</a>
<a name="ln3076">{</a>
<a name="ln3077">  return fc-&gt;fc_l_varlist.lv_copyID != copyID</a>
<a name="ln3078">         &amp;&amp; fc-&gt;fc_l_vars.dv_copyID != copyID</a>
<a name="ln3079">         &amp;&amp; fc-&gt;fc_l_avars.dv_copyID != copyID</a>
<a name="ln3080">         &amp;&amp; fc-&gt;fc_copyID != copyID;</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">/// &quot;:return [expr]&quot;</a>
<a name="ln3084">void ex_return(exarg_T *eap)</a>
<a name="ln3085">{</a>
<a name="ln3086">  char *arg = eap-&gt;arg;</a>
<a name="ln3087">  typval_T rettv;</a>
<a name="ln3088">  int returning = false;</a>
<a name="ln3089"> </a>
<a name="ln3090">  if (current_funccal == NULL) {</a>
<a name="ln3091">    emsg(_(&quot;E133: :return not inside a function&quot;));</a>
<a name="ln3092">    return;</a>
<a name="ln3093">  }</a>
<a name="ln3094"> </a>
<a name="ln3095">  evalarg_T evalarg = { .eval_flags = eap-&gt;skip ? 0 : EVAL_EVALUATE };</a>
<a name="ln3096"> </a>
<a name="ln3097">  if (eap-&gt;skip) {</a>
<a name="ln3098">    emsg_skip++;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">  eap-&gt;nextcmd = NULL;</a>
<a name="ln3102">  if ((*arg != NUL &amp;&amp; *arg != '|' &amp;&amp; *arg != '\n')</a>
<a name="ln3103">      &amp;&amp; eval0(arg, &amp;rettv, eap, &amp;evalarg) != FAIL) {</a>
<a name="ln3104">    if (!eap-&gt;skip) {</a>
<a name="ln3105">      returning = do_return(eap, false, true, &amp;rettv);</a>
<a name="ln3106">    } else {</a>
<a name="ln3107">      tv_clear(&amp;rettv);</a>
<a name="ln3108">    }</a>
<a name="ln3109">  } else if (!eap-&gt;skip) {  // It's safer to return also on error.</a>
<a name="ln3110">    // In return statement, cause_abort should be force_abort.</a>
<a name="ln3111">    update_force_abort();</a>
<a name="ln3112"> </a>
<a name="ln3113">    // Return unless the expression evaluation has been cancelled due to an</a>
<a name="ln3114">    // aborting error, an interrupt, or an exception.</a>
<a name="ln3115">    if (!aborting()) {</a>
<a name="ln3116">      returning = do_return(eap, false, true, NULL);</a>
<a name="ln3117">    }</a>
<a name="ln3118">  }</a>
<a name="ln3119"> </a>
<a name="ln3120">  // When skipping or the return gets pending, advance to the next command</a>
<a name="ln3121">  // in this line (!returning).  Otherwise, ignore the rest of the line.</a>
<a name="ln3122">  // Following lines will be ignored by get_func_line().</a>
<a name="ln3123">  if (returning) {</a>
<a name="ln3124">    eap-&gt;nextcmd = NULL;</a>
<a name="ln3125">  } else if (eap-&gt;nextcmd == NULL) {          // no argument</a>
<a name="ln3126">    eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln3127">  }</a>
<a name="ln3128"> </a>
<a name="ln3129">  if (eap-&gt;skip) {</a>
<a name="ln3130">    emsg_skip--;</a>
<a name="ln3131">  }</a>
<a name="ln3132">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135">/// Lower level implementation of &quot;call&quot;.  Only called when not skipping.</a>
<a name="ln3136">static int ex_call_inner(exarg_T *eap, char *name, char **arg, char *startarg,</a>
<a name="ln3137">                         const funcexe_T *const funcexe_init, evalarg_T *const evalarg)</a>
<a name="ln3138">{</a>
<a name="ln3139">  bool doesrange;</a>
<a name="ln3140">  bool failed = false;</a>
<a name="ln3141"> </a>
<a name="ln3142">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln3143">    if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln3144">      if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3145">        // If the function deleted lines or switched to another buffer</a>
<a name="ln3146">        // the line number may become invalid.</a>
<a name="ln3147">        emsg(_(e_invrange));</a>
<a name="ln3148">        break;</a>
<a name="ln3149">      }</a>
<a name="ln3150">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3151">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3152">      curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln3153">    }</a>
<a name="ln3154">    *arg = startarg;</a>
<a name="ln3155"> </a>
<a name="ln3156">    funcexe_T funcexe = *funcexe_init;</a>
<a name="ln3157">    funcexe.fe_doesrange = &amp;doesrange;</a>
<a name="ln3158">    typval_T rettv;</a>
<a name="ln3159">    rettv.v_type = VAR_UNKNOWN;  // tv_clear() uses this</a>
<a name="ln3160">    if (get_func_tv(name, -1, &amp;rettv, arg, evalarg, &amp;funcexe) == FAIL) {</a>
<a name="ln3161">      failed = true;</a>
<a name="ln3162">      break;</a>
<a name="ln3163">    }</a>
<a name="ln3164"> </a>
<a name="ln3165">    // Handle a function returning a Funcref, Dictionary or List.</a>
<a name="ln3166">    if (handle_subscript((const char **)arg, &amp;rettv, &amp;EVALARG_EVALUATE, true) == FAIL) {</a>
<a name="ln3167">      failed = true;</a>
<a name="ln3168">      break;</a>
<a name="ln3169">    }</a>
<a name="ln3170"> </a>
<a name="ln3171">    tv_clear(&amp;rettv);</a>
<a name="ln3172">    if (doesrange) {</a>
<a name="ln3173">      break;</a>
<a name="ln3174">    }</a>
<a name="ln3175"> </a>
<a name="ln3176">    // Stop when immediately aborting on error, or when an interrupt</a>
<a name="ln3177">    // occurred or an exception was thrown but not caught.</a>
<a name="ln3178">    // get_func_tv() returned OK, so that the check for trailing</a>
<a name="ln3179">    // characters below is executed.</a>
<a name="ln3180">    if (aborting()) {</a>
<a name="ln3181">      break;</a>
<a name="ln3182">    }</a>
<a name="ln3183">  }</a>
<a name="ln3184"> </a>
<a name="ln3185">  return failed;</a>
<a name="ln3186">}</a>
<a name="ln3187"> </a>
<a name="ln3188">/// Core part of &quot;:defer func(arg)&quot;.  &quot;arg&quot; points to the &quot;(&quot; and is advanced.</a>
<a name="ln3189">///</a>
<a name="ln3190">/// @return  FAIL or OK.</a>
<a name="ln3191">static int ex_defer_inner(char *name, char **arg, const partial_T *const partial,</a>
<a name="ln3192">                          evalarg_T *const evalarg)</a>
<a name="ln3193">{</a>
<a name="ln3194">  typval_T argvars[MAX_FUNC_ARGS + 1];  // vars for arguments</a>
<a name="ln3195">  int partial_argc = 0;  // number of partial arguments</a>
<a name="ln3196">  int argcount = 0;  // number of arguments found</a>
<a name="ln3197"> </a>
<a name="ln3198">  if (current_funccal == NULL) {</a>
<a name="ln3199">    semsg(_(e_str_not_inside_function), &quot;defer&quot;);</a>
<a name="ln3200">    return FAIL;</a>
<a name="ln3201">  }</a>
<a name="ln3202">  if (partial != NULL) {</a>
<a name="ln3203">    if (partial-&gt;pt_dict != NULL) {</a>
<a name="ln3204">      emsg(_(e_cannot_use_partial_with_dictionary_for_defer));</a>
<a name="ln3205">      return FAIL;</a>
<a name="ln3206">    }</a>
<a name="ln3207">    if (partial-&gt;pt_argc &gt; 0) {</a>
<a name="ln3208">      partial_argc = partial-&gt;pt_argc;</a>
<a name="ln3209">      for (int i = 0; i &lt; partial_argc; i++) {</a>
<a name="ln3210">        tv_copy(&amp;partial-&gt;pt_argv[i], &amp;argvars[i]);</a>
<a name="ln3211">      }</a>
<a name="ln3212">    }</a>
<a name="ln3213">  }</a>
<a name="ln3214">  int r = get_func_arguments(arg, evalarg, false, argvars + partial_argc, &amp;argcount);</a>
<a name="ln3215">  argcount += partial_argc;</a>
<a name="ln3216"> </a>
<a name="ln3217">  if (r == OK) {</a>
<a name="ln3218">    if (builtin_function(name, -1)) {</a>
<a name="ln3219">      const EvalFuncDef *const fdef = find_internal_func(name);</a>
<a name="ln3220">      if (fdef == NULL) {</a>
<a name="ln3221">        emsg_funcname(e_unknown_function_str, name);</a>
<a name="ln3222">        r = FAIL;</a>
<a name="ln3223">      } else if (check_internal_func(fdef, argcount) == -1) {</a>
<a name="ln3224">        r = FAIL;</a>
<a name="ln3225">      }</a>
<a name="ln3226">    } else {</a>
<a name="ln3227">      ufunc_T *ufunc = find_func(name);</a>
<a name="ln3228">      // we tolerate an unknown function here, it might be defined later</a>
<a name="ln3229">      if (ufunc != NULL) {</a>
<a name="ln3230">        int error = check_user_func_argcount(ufunc, argcount);</a>
<a name="ln3231">        if (error != FCERR_UNKNOWN) {</a>
<a name="ln3232">          user_func_error(error, name, NULL);</a>
<a name="ln3233">          r = FAIL;</a>
<a name="ln3234">        }</a>
<a name="ln3235">      }</a>
<a name="ln3236">    }</a>
<a name="ln3237">  }</a>
<a name="ln3238"> </a>
<a name="ln3239">  if (r == FAIL) {</a>
<a name="ln3240">    while (--argcount &gt;= 0) {</a>
<a name="ln3241">      tv_clear(&amp;argvars[argcount]);</a>
<a name="ln3242">    }</a>
<a name="ln3243">    return FAIL;</a>
<a name="ln3244">  }</a>
<a name="ln3245">  add_defer(name, argcount, argvars);</a>
<a name="ln3246">  return OK;</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">/// Return true if currently inside a function call.</a>
<a name="ln3250">/// Give an error message and return false when not.</a>
<a name="ln3251">bool can_add_defer(void)</a>
<a name="ln3252">{</a>
<a name="ln3253">  if (get_current_funccal() == NULL) {</a>
<a name="ln3254">    semsg(_(e_str_not_inside_function), &quot;defer&quot;);</a>
<a name="ln3255">    return false;</a>
<a name="ln3256">  }</a>
<a name="ln3257">  return true;</a>
<a name="ln3258">}</a>
<a name="ln3259"> </a>
<a name="ln3260">/// Add a deferred call for &quot;name&quot; with arguments &quot;argvars[argcount]&quot;.</a>
<a name="ln3261">/// Consumes &quot;argvars[]&quot;.</a>
<a name="ln3262">/// Caller must check that current_funccal is not NULL.</a>
<a name="ln3263">void add_defer(char *name, int argcount_arg, typval_T *argvars)</a>
<a name="ln3264">{</a>
<a name="ln3265">  char *saved_name = xstrdup(name);</a>
<a name="ln3266">  int argcount = argcount_arg;</a>
<a name="ln3267"> </a>
<a name="ln3268">  if (current_funccal-&gt;fc_defer.ga_itemsize == 0) {</a>
<a name="ln3269">    ga_init(&amp;current_funccal-&gt;fc_defer, sizeof(defer_T), 10);</a>
<a name="ln3270">  }</a>
<a name="ln3271">  defer_T *dr = GA_APPEND_VIA_PTR(defer_T, &amp;current_funccal-&gt;fc_defer);</a>
<a name="ln3272">  dr-&gt;dr_name = saved_name;</a>
<a name="ln3273">  dr-&gt;dr_argcount = argcount;</a>
<a name="ln3274">  while (argcount &gt; 0) {</a>
<a name="ln3275">    argcount--;</a>
<a name="ln3276">    dr-&gt;dr_argvars[argcount] = argvars[argcount];</a>
<a name="ln3277">  }</a>
<a name="ln3278">}</a>
<a name="ln3279"> </a>
<a name="ln3280">/// Invoked after a function has finished: invoke &quot;:defer&quot; functions.</a>
<a name="ln3281">static void handle_defer_one(funccall_T *funccal)</a>
<a name="ln3282">{</a>
<a name="ln3283">  for (int idx = funccal-&gt;fc_defer.ga_len - 1; idx &gt;= 0; idx--) {</a>
<a name="ln3284">    defer_T *dr = ((defer_T *)funccal-&gt;fc_defer.ga_data) + idx;</a>
<a name="ln3285"> </a>
<a name="ln3286">    if (dr-&gt;dr_name == NULL) {</a>
<a name="ln3287">      // already being called, can happen if function does &quot;:qa&quot;</a>
<a name="ln3288">      continue;</a>
<a name="ln3289">    }</a>
<a name="ln3290"> </a>
<a name="ln3291">    funcexe_T funcexe = { .fe_evaluate = true };</a>
<a name="ln3292"> </a>
<a name="ln3293">    typval_T rettv;</a>
<a name="ln3294">    rettv.v_type = VAR_UNKNOWN;     // tv_clear() uses this</a>
<a name="ln3295"> </a>
<a name="ln3296">    char *name = dr-&gt;dr_name;</a>
<a name="ln3297">    dr-&gt;dr_name = NULL;</a>
<a name="ln3298"> </a>
<a name="ln3299">    call_func(name, -1, &amp;rettv, dr-&gt;dr_argcount, dr-&gt;dr_argvars, &amp;funcexe);</a>
<a name="ln3300"> </a>
<a name="ln3301">    tv_clear(&amp;rettv);</a>
<a name="ln3302">    xfree(name);</a>
<a name="ln3303">    for (int i = dr-&gt;dr_argcount - 1; i &gt;= 0; i--) {</a>
<a name="ln3304">      tv_clear(&amp;dr-&gt;dr_argvars[i]);</a>
<a name="ln3305">    }</a>
<a name="ln3306">  }</a>
<a name="ln3307">  ga_clear(&amp;funccal-&gt;fc_defer);</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310">/// Called when exiting: call all defer functions.</a>
<a name="ln3311">void invoke_all_defer(void)</a>
<a name="ln3312">{</a>
<a name="ln3313">  for (funccall_T *fc = current_funccal; fc != NULL; fc = fc-&gt;fc_caller) {</a>
<a name="ln3314">    handle_defer_one(fc);</a>
<a name="ln3315">  }</a>
<a name="ln3316"> </a>
<a name="ln3317">  for (funccal_entry_T *fce = funccal_stack; fce != NULL; fce = fce-&gt;next) {</a>
<a name="ln3318">    for (funccall_T *fc = fce-&gt;top_funccal; fc != NULL; fc = fc-&gt;fc_caller) {</a>
<a name="ln3319">      handle_defer_one(fc);</a>
<a name="ln3320">    }</a>
<a name="ln3321">  }</a>
<a name="ln3322">}</a>
<a name="ln3323"> </a>
<a name="ln3324">/// &quot;:1,25call func(arg1, arg2)&quot; function call.</a>
<a name="ln3325">/// &quot;:defer func(arg1, arg2)&quot;    deferred function call.</a>
<a name="ln3326">void ex_call(exarg_T *eap)</a>
<a name="ln3327">{</a>
<a name="ln3328">  char *arg = eap-&gt;arg;</a>
<a name="ln3329">  char *startarg;</a>
<a name="ln3330">  char *name;</a>
<a name="ln3331">  char *tofree;</a>
<a name="ln3332">  int len;</a>
<a name="ln3333">  bool failed = false;</a>
<a name="ln3334">  funcdict_T fudi;</a>
<a name="ln3335">  partial_T *partial = NULL;</a>
<a name="ln3336">  evalarg_T evalarg;</a>
<a name="ln3337"> </a>
<a name="ln3338">  fill_evalarg_from_eap(&amp;evalarg, eap, eap-&gt;skip);</a>
<a name="ln3339">  if (eap-&gt;skip) {</a>
<a name="ln3340">    typval_T rettv;</a>
<a name="ln3341">    // trans_function_name() doesn't work well when skipping, use eval0()</a>
<a name="ln3342">    // instead to skip to any following command, e.g. for:</a>
<a name="ln3343">    //   :if 0 | call dict.foo().bar() | endif.</a>
<a name="ln3344">    emsg_skip++;</a>
<a name="ln3345">    if (eval0(eap-&gt;arg, &amp;rettv, eap, &amp;evalarg) != FAIL) {</a>
<a name="ln3346">      tv_clear(&amp;rettv);</a>
<a name="ln3347">    }</a>
<a name="ln3348">    emsg_skip--;</a>
<a name="ln3349">    clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln3350">    return;</a>
<a name="ln3351">  }</a>
<a name="ln3352"> </a>
<a name="ln3353">  tofree = trans_function_name(&amp;arg, false, TFN_INT, &amp;fudi, &amp;partial);</a>
<a name="ln3354">  if (fudi.fd_newkey != NULL) {</a>
<a name="ln3355">    // Still need to give an error message for missing key.</a>
<a name="ln3356">    semsg(_(e_dictkey), fudi.fd_newkey);</a>
<a name="ln3357">    xfree(fudi.fd_newkey);</a>
<a name="ln3358">  }</a>
<a name="ln3359">  if (tofree == NULL) {</a>
<a name="ln3360">    return;</a>
<a name="ln3361">  }</a>
<a name="ln3362"> </a>
<a name="ln3363">  // Increase refcount on dictionary, it could get deleted when evaluating</a>
<a name="ln3364">  // the arguments.</a>
<a name="ln3365">  if (fudi.fd_dict != NULL) {</a>
<a name="ln3366">    fudi.fd_dict-&gt;dv_refcount++;</a>
<a name="ln3367">  }</a>
<a name="ln3368"> </a>
<a name="ln3369">  // If it is the name of a variable of type VAR_FUNC or VAR_PARTIAL use its</a>
<a name="ln3370">  // contents. For VAR_PARTIAL get its partial, unless we already have one</a>
<a name="ln3371">  // from trans_function_name().</a>
<a name="ln3372">  len = (int)strlen(tofree);</a>
<a name="ln3373">  bool found_var = false;</a>
<a name="ln3374">  name = deref_func_name(tofree, &amp;len, partial != NULL ? NULL : &amp;partial, false, &amp;found_var);</a>
<a name="ln3375"> </a>
<a name="ln3376">  // Skip white space to allow &quot;:call func ()&quot;.  Not good, but required for</a>
<a name="ln3377">  // backward compatibility.</a>
<a name="ln3378">  startarg = skipwhite(arg);</a>
<a name="ln3379"> </a>
<a name="ln3380">  if (*startarg != '(') {</a>
<a name="ln3381">    semsg(_(e_missingparen), eap-&gt;arg);</a>
<a name="ln3382">    goto end;</a>
<a name="ln3383">  }</a>
<a name="ln3384"> </a>
<a name="ln3385">  if (eap-&gt;cmdidx == CMD_defer) {</a>
<a name="ln3386">    arg = startarg;</a>
<a name="ln3387">    failed = ex_defer_inner(name, &amp;arg, partial, &amp;evalarg) == FAIL;</a>
<a name="ln3388">  } else {</a>
<a name="ln3389">    funcexe_T funcexe = FUNCEXE_INIT;</a>
<a name="ln3390">    funcexe.fe_partial = partial;</a>
<a name="ln3391">    funcexe.fe_selfdict = fudi.fd_dict;</a>
<a name="ln3392">    funcexe.fe_firstline = eap-&gt;line1;</a>
<a name="ln3393">    funcexe.fe_lastline = eap-&gt;line2;</a>
<a name="ln3394">    funcexe.fe_found_var = found_var;</a>
<a name="ln3395">    funcexe.fe_evaluate = true;</a>
<a name="ln3396">    failed = ex_call_inner(eap, name, &amp;arg, startarg, &amp;funcexe, &amp;evalarg);</a>
<a name="ln3397">  }</a>
<a name="ln3398"> </a>
<a name="ln3399">  // When inside :try we need to check for following &quot;| catch&quot; or &quot;| endtry&quot;.</a>
<a name="ln3400">  // Not when there was an error, but do check if an exception was thrown.</a>
<a name="ln3401">  if ((!aborting() || did_throw) &amp;&amp; (!failed || eap-&gt;cstack-&gt;cs_trylevel &gt; 0)) {</a>
<a name="ln3402">    // Check for trailing illegal characters and a following command.</a>
<a name="ln3403">    if (!ends_excmd(*arg)) {</a>
<a name="ln3404">      if (!failed &amp;&amp; !aborting()) {</a>
<a name="ln3405">        emsg_severe = true;</a>
<a name="ln3406">        semsg(_(e_trailing_arg), arg);</a>
<a name="ln3407">      }</a>
<a name="ln3408">    } else {</a>
<a name="ln3409">      eap-&gt;nextcmd = check_nextcmd(arg);</a>
<a name="ln3410">    }</a>
<a name="ln3411">  }</a>
<a name="ln3412">  clear_evalarg(&amp;evalarg, eap);</a>
<a name="ln3413"> </a>
<a name="ln3414">end:</a>
<a name="ln3415">  tv_dict_unref(fudi.fd_dict);</a>
<a name="ln3416">  xfree(tofree);</a>
<a name="ln3417">}</a>
<a name="ln3418"> </a>
<a name="ln3419">/// Return from a function.  Possibly makes the return pending.  Also called</a>
<a name="ln3420">/// for a pending return at the &quot;:endtry&quot; or after returning from an extra</a>
<a name="ln3421">/// do_cmdline().  &quot;reanimate&quot; is used in the latter case.</a>
<a name="ln3422">///</a>
<a name="ln3423">/// @param reanimate  used after returning from an extra do_cmdline().</a>
<a name="ln3424">/// @param is_cmd     set when called due to a &quot;:return&quot; command.</a>
<a name="ln3425">/// @param rettv      may point to a typval_T with the return rettv.</a>
<a name="ln3426">///</a>
<a name="ln3427">/// @return  true when the return can be carried out,</a>
<a name="ln3428">///          false when the return gets pending.</a>
<a name="ln3429">int do_return(exarg_T *eap, int reanimate, int is_cmd, void *rettv)</a>
<a name="ln3430">{</a>
<a name="ln3431">  int idx;</a>
<a name="ln3432">  cstack_T *const cstack = eap-&gt;cstack;</a>
<a name="ln3433"> </a>
<a name="ln3434">  if (reanimate) {</a>
<a name="ln3435">    // Undo the return.</a>
<a name="ln3436">    current_funccal-&gt;fc_returned = false;</a>
<a name="ln3437">  }</a>
<a name="ln3438"> </a>
<a name="ln3439">  // Cleanup (and deactivate) conditionals, but stop when a try conditional</a>
<a name="ln3440">  // not in its finally clause (which then is to be executed next) is found.</a>
<a name="ln3441">  // In this case, make the &quot;:return&quot; pending for execution at the &quot;:endtry&quot;.</a>
<a name="ln3442">  // Otherwise, return normally.</a>
<a name="ln3443">  idx = cleanup_conditionals(eap-&gt;cstack, 0, true);</a>
<a name="ln3444">  if (idx &gt;= 0) {</a>
<a name="ln3445">    cstack-&gt;cs_pending[idx] = CSTP_RETURN;</a>
<a name="ln3446"> </a>
<a name="ln3447">    if (!is_cmd &amp;&amp; !reanimate) {</a>
<a name="ln3448">      // A pending return again gets pending.  &quot;rettv&quot; points to an</a>
<a name="ln3449">      // allocated variable with the rettv of the original &quot;:return&quot;'s</a>
<a name="ln3450">      // argument if present or is NULL else.</a>
<a name="ln3451">      cstack-&gt;cs_rettv[idx] = rettv;</a>
<a name="ln3452">    } else {</a>
<a name="ln3453">      // When undoing a return in order to make it pending, get the stored</a>
<a name="ln3454">      // return rettv.</a>
<a name="ln3455">      if (reanimate) {</a>
<a name="ln3456">        assert(current_funccal-&gt;fc_rettv);</a>
<a name="ln3457">        rettv = current_funccal-&gt;fc_rettv;</a>
<a name="ln3458">      }</a>
<a name="ln3459"> </a>
<a name="ln3460">      if (rettv != NULL) {</a>
<a name="ln3461">        // Store the value of the pending return.</a>
<a name="ln3462">        cstack-&gt;cs_rettv[idx] = xcalloc(1, sizeof(typval_T));</a>
<a name="ln3463">        *(typval_T *)cstack-&gt;cs_rettv[idx] = *(typval_T *)rettv;</a>
<a name="ln3464">      } else {</a>
<a name="ln3465">        cstack-&gt;cs_rettv[idx] = NULL;</a>
<a name="ln3466">      }</a>
<a name="ln3467"> </a>
<a name="ln3468">      if (reanimate) {</a>
<a name="ln3469">        // The pending return value could be overwritten by a &quot;:return&quot;</a>
<a name="ln3470">        // without argument in a finally clause; reset the default</a>
<a name="ln3471">        // return value.</a>
<a name="ln3472">        current_funccal-&gt;fc_rettv-&gt;v_type = VAR_NUMBER;</a>
<a name="ln3473">        current_funccal-&gt;fc_rettv-&gt;vval.v_number = 0;</a>
<a name="ln3474">      }</a>
<a name="ln3475">    }</a>
<a name="ln3476">    report_make_pending(CSTP_RETURN, rettv);</a>
<a name="ln3477">  } else {</a>
<a name="ln3478">    current_funccal-&gt;fc_returned = true;</a>
<a name="ln3479"> </a>
<a name="ln3480">    // If the return is carried out now, store the return value.  For</a>
<a name="ln3481">    // a return immediately after reanimation, the value is already</a>
<a name="ln3482">    // there.</a>
<a name="ln3483">    if (!reanimate &amp;&amp; rettv != NULL) {</a>
<a name="ln3484">      tv_clear(current_funccal-&gt;fc_rettv);</a>
<a name="ln3485">      *current_funccal-&gt;fc_rettv = *(typval_T *)rettv;</a>
<a name="ln3486">      if (!is_cmd) {</a>
<a name="ln3487">        xfree(rettv);</a>
<a name="ln3488">      }</a>
<a name="ln3489">    }</a>
<a name="ln3490">  }</a>
<a name="ln3491"> </a>
<a name="ln3492">  return idx &lt; 0;</a>
<a name="ln3493">}</a>
<a name="ln3494"> </a>
<a name="ln3495">/// Generate a return command for producing the value of &quot;rettv&quot;.  The result</a>
<a name="ln3496">/// is an allocated string.  Used by report_pending() for verbose messages.</a>
<a name="ln3497">char *get_return_cmd(void *rettv)</a>
<a name="ln3498">{</a>
<a name="ln3499">  char *s = NULL;</a>
<a name="ln3500">  char *tofree = NULL;</a>
<a name="ln3501"> </a>
<a name="ln3502">  if (rettv != NULL) {</a>
<a name="ln3503">    tofree = s = encode_tv2echo((typval_T *)rettv, NULL);</a>
<a name="ln3504">  }</a>
<a name="ln3505">  if (s == NULL) {</a>
<a name="ln3506">    s = &quot;&quot;;</a>
<a name="ln3507">  }</a>
<a name="ln3508"> </a>
<a name="ln3509">  xstrlcpy(IObuff, &quot;:return &quot;, IOSIZE);</a>
<a name="ln3510">  xstrlcpy(IObuff + 8, s, IOSIZE - 8);</a>
<a name="ln3511">  if (strlen(s) + 8 &gt;= IOSIZE) {</a>
<a name="ln3512">    STRCPY(IObuff + IOSIZE - 4, &quot;...&quot;);</a>
<a name="ln3513">  }</a>
<a name="ln3514">  xfree(tofree);</a>
<a name="ln3515">  return xstrdup(IObuff);</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518">/// Get next function line.</a>
<a name="ln3519">/// Called by do_cmdline() to get the next line.</a>
<a name="ln3520">///</a>
<a name="ln3521">/// @return  allocated string, or NULL for end of function.</a>
<a name="ln3522">char *get_func_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln3523">{</a>
<a name="ln3524">  funccall_T *fcp = (funccall_T *)cookie;</a>
<a name="ln3525">  ufunc_T *fp = fcp-&gt;fc_func;</a>
<a name="ln3526">  char *retval;</a>
<a name="ln3527">  garray_T *gap;    // growarray with function lines</a>
<a name="ln3528"> </a>
<a name="ln3529">  // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln3530">  if (fcp-&gt;fc_dbg_tick != debug_tick) {</a>
<a name="ln3531">    fcp-&gt;fc_breakpoint = dbg_find_breakpoint(false, fp-&gt;uf_name, SOURCING_LNUM);</a>
<a name="ln3532">    fcp-&gt;fc_dbg_tick = debug_tick;</a>
<a name="ln3533">  }</a>
<a name="ln3534">  if (do_profiling == PROF_YES) {</a>
<a name="ln3535">    func_line_end(cookie);</a>
<a name="ln3536">  }</a>
<a name="ln3537"> </a>
<a name="ln3538">  gap = &amp;fp-&gt;uf_lines;</a>
<a name="ln3539">  if (((fp-&gt;uf_flags &amp; FC_ABORT) &amp;&amp; did_emsg &amp;&amp; !aborted_in_try())</a>
<a name="ln3540">      || fcp-&gt;fc_returned) {</a>
<a name="ln3541">    retval = NULL;</a>
<a name="ln3542">  } else {</a>
<a name="ln3543">    // Skip NULL lines (continuation lines).</a>
<a name="ln3544">    while (fcp-&gt;fc_linenr &lt; gap-&gt;ga_len</a>
<a name="ln3545">           &amp;&amp; ((char **)(gap-&gt;ga_data))[fcp-&gt;fc_linenr] == NULL) {</a>
<a name="ln3546">      fcp-&gt;fc_linenr++;</a>
<a name="ln3547">    }</a>
<a name="ln3548">    if (fcp-&gt;fc_linenr &gt;= gap-&gt;ga_len) {</a>
<a name="ln3549">      retval = NULL;</a>
<a name="ln3550">    } else {</a>
<a name="ln3551">      retval = xstrdup(((char **)(gap-&gt;ga_data))[fcp-&gt;fc_linenr++]);</a>
<a name="ln3552">      SOURCING_LNUM = fcp-&gt;fc_linenr;</a>
<a name="ln3553">      if (do_profiling == PROF_YES) {</a>
<a name="ln3554">        func_line_start(cookie);</a>
<a name="ln3555">      }</a>
<a name="ln3556">    }</a>
<a name="ln3557">  }</a>
<a name="ln3558"> </a>
<a name="ln3559">  // Did we encounter a breakpoint?</a>
<a name="ln3560">  if (fcp-&gt;fc_breakpoint != 0 &amp;&amp; fcp-&gt;fc_breakpoint &lt;= SOURCING_LNUM) {</a>
<a name="ln3561">    dbg_breakpoint(fp-&gt;uf_name, SOURCING_LNUM);</a>
<a name="ln3562">    // Find next breakpoint.</a>
<a name="ln3563">    fcp-&gt;fc_breakpoint = dbg_find_breakpoint(false, fp-&gt;uf_name, SOURCING_LNUM);</a>
<a name="ln3564">    fcp-&gt;fc_dbg_tick = debug_tick;</a>
<a name="ln3565">  }</a>
<a name="ln3566"> </a>
<a name="ln3567">  return retval;</a>
<a name="ln3568">}</a>
<a name="ln3569"> </a>
<a name="ln3570">/// @return  true if the currently active function should be ended, because a</a>
<a name="ln3571">///          return was encountered or an error occurred.  Used inside a &quot;:while&quot;.</a>
<a name="ln3572">int func_has_ended(void *cookie)</a>
<a name="ln3573">{</a>
<a name="ln3574">  funccall_T *fcp = (funccall_T *)cookie;</a>
<a name="ln3575"> </a>
<a name="ln3576">  // Ignore the &quot;abort&quot; flag if the abortion behavior has been changed due to</a>
<a name="ln3577">  // an error inside a try conditional.</a>
<a name="ln3578">  return ((fcp-&gt;fc_func-&gt;uf_flags &amp; FC_ABORT) &amp;&amp; did_emsg &amp;&amp; !aborted_in_try())</a>
<a name="ln3579">         || fcp-&gt;fc_returned;</a>
<a name="ln3580">}</a>
<a name="ln3581"> </a>
<a name="ln3582">/// @return  true if cookie indicates a function which &quot;abort&quot;s on errors.</a>
<a name="ln3583">int func_has_abort(void *cookie)</a>
<a name="ln3584">{</a>
<a name="ln3585">  return ((funccall_T *)cookie)-&gt;fc_func-&gt;uf_flags &amp; FC_ABORT;</a>
<a name="ln3586">}</a>
<a name="ln3587"> </a>
<a name="ln3588">/// Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; bound to &quot;dict&quot;.</a>
<a name="ln3589">/// Changes &quot;rettv&quot; in-place.</a>
<a name="ln3590">void make_partial(dict_T *const selfdict, typval_T *const rettv)</a>
<a name="ln3591">{</a>
<a name="ln3592">  char *tofree = NULL;</a>
<a name="ln3593">  ufunc_T *fp;</a>
<a name="ln3594">  char fname_buf[FLEN_FIXED + 1];</a>
<a name="ln3595">  int error;</a>
<a name="ln3596"> </a>
<a name="ln3597">  if (rettv-&gt;v_type == VAR_PARTIAL &amp;&amp; rettv-&gt;vval.v_partial-&gt;pt_func != NULL) {</a>
<a name="ln3598">    fp = rettv-&gt;vval.v_partial-&gt;pt_func;</a>
<a name="ln3599">  } else {</a>
<a name="ln3600">    char *fname = rettv-&gt;v_type == VAR_FUNC || rettv-&gt;v_type == VAR_STRING</a>
<a name="ln3601">                                      ? rettv-&gt;vval.v_string</a>
<a name="ln3602">                                      : rettv-&gt;vval.v_partial-&gt;pt_name;</a>
<a name="ln3603">    // Translate &quot;s:func&quot; to the stored function name.</a>
<a name="ln3604">    fname = fname_trans_sid(fname, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln3605">    fp = find_func(fname);</a>
<a name="ln3606">    xfree(tofree);</a>
<a name="ln3607">  }</a>
<a name="ln3608"> </a>
<a name="ln3609">  // Turn &quot;dict.Func&quot; into a partial for &quot;Func&quot; with &quot;dict&quot;.</a>
<a name="ln3610">  if (fp != NULL &amp;&amp; (fp-&gt;uf_flags &amp; FC_DICT)) {</a>
<a name="ln3611">    partial_T *pt = (partial_T *)xcalloc(1, sizeof(partial_T));</a>
<a name="ln3612">    pt-&gt;pt_refcount = 1;</a>
<a name="ln3613">    pt-&gt;pt_dict = selfdict;</a>
<a name="ln3614">    (selfdict-&gt;dv_refcount)++;</a>
<a name="ln3615">    pt-&gt;pt_auto = true;</a>
<a name="ln3616">    if (rettv-&gt;v_type == VAR_FUNC || rettv-&gt;v_type == VAR_STRING) {</a>
<a name="ln3617">      // Just a function: Take over the function name and use selfdict.</a>
<a name="ln3618">      pt-&gt;pt_name = rettv-&gt;vval.v_string;</a>
<a name="ln3619">    } else {</a>
<a name="ln3620">      partial_T *ret_pt = rettv-&gt;vval.v_partial;</a>
<a name="ln3621"> </a>
<a name="ln3622">      // Partial: copy the function name, use selfdict and copy</a>
<a name="ln3623">      // args. Can't take over name or args, the partial might</a>
<a name="ln3624">      // be referenced elsewhere.</a>
<a name="ln3625">      if (ret_pt-&gt;pt_name != NULL) {</a>
<a name="ln3626">        pt-&gt;pt_name = xstrdup(ret_pt-&gt;pt_name);</a>
<a name="ln3627">        func_ref(pt-&gt;pt_name);</a>
<a name="ln3628">      } else {</a>
<a name="ln3629">        pt-&gt;pt_func = ret_pt-&gt;pt_func;</a>
<a name="ln3630">        func_ptr_ref(pt-&gt;pt_func);</a>
<a name="ln3631">      }</a>
<a name="ln3632">      if (ret_pt-&gt;pt_argc &gt; 0) {</a>
<a name="ln3633">        size_t arg_size = sizeof(typval_T) * (size_t)ret_pt-&gt;pt_argc;</a>
<a name="ln3634">        pt-&gt;pt_argv = (typval_T *)xmalloc(arg_size);</a>
<a name="ln3635">        pt-&gt;pt_argc = ret_pt-&gt;pt_argc;</a>
<a name="ln3636">        for (int i = 0; i &lt; pt-&gt;pt_argc; i++) {</a>
<a name="ln3637">          tv_copy(&amp;ret_pt-&gt;pt_argv[i], &amp;pt-&gt;pt_argv[i]);</a>
<a name="ln3638">        }</a>
<a name="ln3639">      }</a>
<a name="ln3640">      partial_unref(ret_pt);</a>
<a name="ln3641">    }</a>
<a name="ln3642">    rettv-&gt;v_type = VAR_PARTIAL;</a>
<a name="ln3643">    rettv-&gt;vval.v_partial = pt;</a>
<a name="ln3644">  }</a>
<a name="ln3645">}</a>
<a name="ln3646"> </a>
<a name="ln3647">/// @return  the name of the executed function.</a>
<a name="ln3648">char *func_name(void *cookie)</a>
<a name="ln3649">{</a>
<a name="ln3650">  return ((funccall_T *)cookie)-&gt;fc_func-&gt;uf_name;</a>
<a name="ln3651">}</a>
<a name="ln3652"> </a>
<a name="ln3653">/// @return  the address holding the next breakpoint line for a funccall cookie.</a>
<a name="ln3654">linenr_T *func_breakpoint(void *cookie)</a>
<a name="ln3655">{</a>
<a name="ln3656">  return &amp;((funccall_T *)cookie)-&gt;fc_breakpoint;</a>
<a name="ln3657">}</a>
<a name="ln3658"> </a>
<a name="ln3659">/// @return  the address holding the debug tick for a funccall cookie.</a>
<a name="ln3660">int *func_dbg_tick(void *cookie)</a>
<a name="ln3661">{</a>
<a name="ln3662">  return &amp;((funccall_T *)cookie)-&gt;fc_dbg_tick;</a>
<a name="ln3663">}</a>
<a name="ln3664"> </a>
<a name="ln3665">/// @return  the nesting level for a funccall cookie.</a>
<a name="ln3666">int func_level(void *cookie)</a>
<a name="ln3667">{</a>
<a name="ln3668">  return ((funccall_T *)cookie)-&gt;fc_level;</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671">/// @return  true when a function was ended by a &quot;:return&quot; command.</a>
<a name="ln3672">int current_func_returned(void)</a>
<a name="ln3673">{</a>
<a name="ln3674">  return current_funccal-&gt;fc_returned;</a>
<a name="ln3675">}</a>
<a name="ln3676"> </a>
<a name="ln3677">bool free_unref_funccal(int copyID, int testing)</a>
<a name="ln3678">{</a>
<a name="ln3679">  bool did_free = false;</a>
<a name="ln3680">  bool did_free_funccal = false;</a>
<a name="ln3681"> </a>
<a name="ln3682">  for (funccall_T **pfc = &amp;previous_funccal; *pfc != NULL;) {</a>
<a name="ln3683">    if (can_free_funccal(*pfc, copyID)) {</a>
<a name="ln3684">      funccall_T *fc = *pfc;</a>
<a name="ln3685">      *pfc = fc-&gt;fc_caller;</a>
<a name="ln3686">      free_funccal_contents(fc);</a>
<a name="ln3687">      did_free = true;</a>
<a name="ln3688">      did_free_funccal = true;</a>
<a name="ln3689">    } else {</a>
<a name="ln3690">      pfc = &amp;(*pfc)-&gt;fc_caller;</a>
<a name="ln3691">    }</a>
<a name="ln3692">  }</a>
<a name="ln3693">  if (did_free_funccal) {</a>
<a name="ln3694">    // When a funccal was freed some more items might be garbage</a>
<a name="ln3695">    // collected, so run again.</a>
<a name="ln3696">    (void)garbage_collect(testing);</a>
<a name="ln3697">  }</a>
<a name="ln3698">  return did_free;</a>
<a name="ln3699">}</a>
<a name="ln3700"> </a>
<a name="ln3701">// Get function call environment based on backtrace debug level</a>
<a name="ln3702">funccall_T *get_funccal(void)</a>
<a name="ln3703">{</a>
<a name="ln3704">  funccall_T *funccal = current_funccal;</a>
<a name="ln3705">  if (debug_backtrace_level &gt; 0) {</a>
<a name="ln3706">    for (int i = 0; i &lt; debug_backtrace_level; i++) {</a>
<a name="ln3707">      funccall_T *temp_funccal = funccal-&gt;fc_caller;</a>
<a name="ln3708">      if (temp_funccal) {</a>
<a name="ln3709">        funccal = temp_funccal;</a>
<a name="ln3710">      } else {</a>
<a name="ln3711">        // backtrace level overflow. reset to max</a>
<a name="ln3712">        debug_backtrace_level = i;</a>
<a name="ln3713">      }</a>
<a name="ln3714">    }</a>
<a name="ln3715">  }</a>
<a name="ln3716"> </a>
<a name="ln3717">  return funccal;</a>
<a name="ln3718">}</a>
<a name="ln3719"> </a>
<a name="ln3720">/// @return  hashtable used for local variables in the current funccal or</a>
<a name="ln3721">///          NULL if there is no current funccal.</a>
<a name="ln3722">hashtab_T *get_funccal_local_ht(void)</a>
<a name="ln3723">{</a>
<a name="ln3724">  if (current_funccal == NULL) {</a>
<a name="ln3725">    return NULL;</a>
<a name="ln3726">  }</a>
<a name="ln3727">  return &amp;get_funccal()-&gt;fc_l_vars.dv_hashtab;</a>
<a name="ln3728">}</a>
<a name="ln3729"> </a>
<a name="ln3730">/// @return   the l: scope variable or</a>
<a name="ln3731">///           NULL if there is no current funccal.</a>
<a name="ln3732">dictitem_T *get_funccal_local_var(void)</a>
<a name="ln3733">{</a>
<a name="ln3734">  if (current_funccal == NULL) {</a>
<a name="ln3735">    return NULL;</a>
<a name="ln3736">  }</a>
<a name="ln3737">  return (dictitem_T *)&amp;get_funccal()-&gt;fc_l_vars_var;</a>
<a name="ln3738">}</a>
<a name="ln3739"> </a>
<a name="ln3740">/// @return  the hashtable used for argument in the current funccal or</a>
<a name="ln3741">///          NULL if there is no current funccal.</a>
<a name="ln3742">hashtab_T *get_funccal_args_ht(void)</a>
<a name="ln3743">{</a>
<a name="ln3744">  if (current_funccal == NULL) {</a>
<a name="ln3745">    return NULL;</a>
<a name="ln3746">  }</a>
<a name="ln3747">  return &amp;get_funccal()-&gt;fc_l_avars.dv_hashtab;</a>
<a name="ln3748">}</a>
<a name="ln3749"> </a>
<a name="ln3750">/// @return  the a: scope variable or</a>
<a name="ln3751">///          NULL if there is no current funccal.</a>
<a name="ln3752">dictitem_T *get_funccal_args_var(void)</a>
<a name="ln3753">{</a>
<a name="ln3754">  if (current_funccal == NULL) {</a>
<a name="ln3755">    return NULL;</a>
<a name="ln3756">  }</a>
<a name="ln3757">  return (dictitem_T *)&amp;current_funccal-&gt;fc_l_avars_var;</a>
<a name="ln3758">}</a>
<a name="ln3759"> </a>
<a name="ln3760">/// List function variables, if there is a function.</a>
<a name="ln3761">void list_func_vars(int *first)</a>
<a name="ln3762">{</a>
<a name="ln3763">  if (current_funccal != NULL) {</a>
<a name="ln3764">    list_hashtable_vars(&amp;current_funccal-&gt;fc_l_vars.dv_hashtab, &quot;l:&quot;, false,</a>
<a name="ln3765">                        first);</a>
<a name="ln3766">  }</a>
<a name="ln3767">}</a>
<a name="ln3768"> </a>
<a name="ln3769">/// @return  if &quot;ht&quot; is the hashtable for local variables in the current</a>
<a name="ln3770">///          funccal, return the dict that contains it. Otherwise return NULL.</a>
<a name="ln3771">dict_T *get_current_funccal_dict(hashtab_T *ht)</a>
<a name="ln3772">{</a>
<a name="ln3773">  if (current_funccal != NULL &amp;&amp; ht == &amp;current_funccal-&gt;fc_l_vars.dv_hashtab) {</a>
<a name="ln3774">    return &amp;current_funccal-&gt;fc_l_vars;</a>
<a name="ln3775">  }</a>
<a name="ln3776">  return NULL;</a>
<a name="ln3777">}</a>
<a name="ln3778"> </a>
<a name="ln3779">/// Search hashitem in parent scope.</a>
<a name="ln3780">hashitem_T *find_hi_in_scoped_ht(const char *name, hashtab_T **pht)</a>
<a name="ln3781">{</a>
<a name="ln3782">  if (current_funccal == NULL || current_funccal-&gt;fc_func-&gt;uf_scoped == NULL) {</a>
<a name="ln3783">    return NULL;</a>
<a name="ln3784">  }</a>
<a name="ln3785"> </a>
<a name="ln3786">  funccall_T *old_current_funccal = current_funccal;</a>
<a name="ln3787">  hashitem_T *hi = NULL;</a>
<a name="ln3788">  const size_t namelen = strlen(name);</a>
<a name="ln3789">  const char *varname;</a>
<a name="ln3790"> </a>
<a name="ln3791">  // Search in parent scope which is possible to reference from lambda</a>
<a name="ln3792">  current_funccal = current_funccal-&gt;fc_func-&gt;uf_scoped;</a>
<a name="ln3793">  while (current_funccal != NULL) {</a>
<a name="ln3794">    hashtab_T *ht = find_var_ht(name, namelen, &amp;varname);</a>
<a name="ln3795">    if (ht != NULL &amp;&amp; *varname != NUL) {</a>
<a name="ln3796">      hi = hash_find_len(ht, varname, namelen - (size_t)(varname - name));</a>
<a name="ln3797">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3798">        *pht = ht;</a>
<a name="ln3799">        break;</a>
<a name="ln3800">      }</a>
<a name="ln3801">    }</a>
<a name="ln3802">    if (current_funccal == current_funccal-&gt;fc_func-&gt;uf_scoped) {</a>
<a name="ln3803">      break;</a>
<a name="ln3804">    }</a>
<a name="ln3805">    current_funccal = current_funccal-&gt;fc_func-&gt;uf_scoped;</a>
<a name="ln3806">  }</a>
<a name="ln3807">  current_funccal = old_current_funccal;</a>
<a name="ln3808"> </a>
<a name="ln3809">  return hi;</a>
<a name="ln3810">}</a>
<a name="ln3811"> </a>
<a name="ln3812">/// Search variable in parent scope.</a>
<a name="ln3813">dictitem_T *find_var_in_scoped_ht(const char *name, const size_t namelen, int no_autoload)</a>
<a name="ln3814">{</a>
<a name="ln3815">  if (current_funccal == NULL || current_funccal-&gt;fc_func-&gt;uf_scoped == NULL) {</a>
<a name="ln3816">    return NULL;</a>
<a name="ln3817">  }</a>
<a name="ln3818"> </a>
<a name="ln3819">  dictitem_T *v = NULL;</a>
<a name="ln3820">  funccall_T *old_current_funccal = current_funccal;</a>
<a name="ln3821">  const char *varname;</a>
<a name="ln3822"> </a>
<a name="ln3823">  // Search in parent scope which is possible to reference from lambda</a>
<a name="ln3824">  current_funccal = current_funccal-&gt;fc_func-&gt;uf_scoped;</a>
<a name="ln3825">  while (current_funccal) {</a>
<a name="ln3826">    hashtab_T *ht = find_var_ht(name, namelen, &amp;varname);</a>
<a name="ln3827">    if (ht != NULL &amp;&amp; *varname != NUL) {</a>
<a name="ln3828">      v = find_var_in_ht(ht, *name, varname,</a>
<a name="ln3829">                         namelen - (size_t)(varname - name), no_autoload);</a>
<a name="ln3830">      if (v != NULL) {</a>
<a name="ln3831">        break;</a>
<a name="ln3832">      }</a>
<a name="ln3833">    }</a>
<a name="ln3834">    if (current_funccal == current_funccal-&gt;fc_func-&gt;uf_scoped) {</a>
<a name="ln3835">      break;</a>
<a name="ln3836">    }</a>
<a name="ln3837">    current_funccal = current_funccal-&gt;fc_func-&gt;uf_scoped;</a>
<a name="ln3838">  }</a>
<a name="ln3839">  current_funccal = old_current_funccal;</a>
<a name="ln3840"> </a>
<a name="ln3841">  return v;</a>
<a name="ln3842">}</a>
<a name="ln3843"> </a>
<a name="ln3844">/// Set &quot;copyID + 1&quot; in previous_funccal and callers.</a>
<a name="ln3845">bool set_ref_in_previous_funccal(int copyID)</a>
<a name="ln3846">{</a>
<a name="ln3847">  for (funccall_T *fc = previous_funccal; fc != NULL;</a>
<a name="ln3848">       fc = fc-&gt;fc_caller) {</a>
<a name="ln3849">    fc-&gt;fc_copyID = copyID + 1;</a>
<a name="ln3850">    if (set_ref_in_ht(&amp;fc-&gt;fc_l_vars.dv_hashtab, copyID + 1, NULL)</a>
<a name="ln3851">        || set_ref_in_ht(&amp;fc-&gt;fc_l_avars.dv_hashtab, copyID + 1, NULL)</a>
<a name="ln3852">        || set_ref_in_list(&amp;fc-&gt;fc_l_varlist, copyID + 1, NULL)) {</a>
<a name="ln3853">      return true;</a>
<a name="ln3854">    }</a>
<a name="ln3855">  }</a>
<a name="ln3856">  return false;</a>
<a name="ln3857">}</a>
<a name="ln3858"> </a>
<a name="ln3859">static bool set_ref_in_funccal(funccall_T *fc, int copyID)</a>
<a name="ln3860">{</a>
<a name="ln3861">  if (fc-&gt;fc_copyID != copyID) {</a>
<a name="ln3862">    fc-&gt;fc_copyID = copyID;</a>
<a name="ln3863">    if (set_ref_in_ht(&amp;fc-&gt;fc_l_vars.dv_hashtab, copyID, NULL)</a>
<a name="ln3864">        || set_ref_in_ht(&amp;fc-&gt;fc_l_avars.dv_hashtab, copyID, NULL)</a>
<a name="ln3865">        || set_ref_in_list(&amp;fc-&gt;fc_l_varlist, copyID, NULL)</a>
<a name="ln3866">        || set_ref_in_func(NULL, fc-&gt;fc_func, copyID)) {</a>
<a name="ln3867">      return true;</a>
<a name="ln3868">    }</a>
<a name="ln3869">  }</a>
<a name="ln3870">  return false;</a>
<a name="ln3871">}</a>
<a name="ln3872"> </a>
<a name="ln3873">/// Set &quot;copyID&quot; in all local vars and arguments in the call stack.</a>
<a name="ln3874">bool set_ref_in_call_stack(int copyID)</a>
<a name="ln3875">{</a>
<a name="ln3876">  for (funccall_T *fc = current_funccal; fc != NULL;</a>
<a name="ln3877">       fc = fc-&gt;fc_caller) {</a>
<a name="ln3878">    if (set_ref_in_funccal(fc, copyID)) {</a>
<a name="ln3879">      return true;</a>
<a name="ln3880">    }</a>
<a name="ln3881">  }</a>
<a name="ln3882"> </a>
<a name="ln3883">  // Also go through the funccal_stack.</a>
<a name="ln3884">  for (funccal_entry_T *entry = funccal_stack; entry != NULL;</a>
<a name="ln3885">       entry = entry-&gt;next) {</a>
<a name="ln3886">    for (funccall_T *fc = entry-&gt;top_funccal; fc != NULL;</a>
<a name="ln3887">         fc = fc-&gt;fc_caller) {</a>
<a name="ln3888">      if (set_ref_in_funccal(fc, copyID)) {</a>
<a name="ln3889">        return true;</a>
<a name="ln3890">      }</a>
<a name="ln3891">    }</a>
<a name="ln3892">  }</a>
<a name="ln3893"> </a>
<a name="ln3894">  return false;</a>
<a name="ln3895">}</a>
<a name="ln3896"> </a>
<a name="ln3897">/// Set &quot;copyID&quot; in all functions available by name.</a>
<a name="ln3898">bool set_ref_in_functions(int copyID)</a>
<a name="ln3899">{</a>
<a name="ln3900">  int todo;</a>
<a name="ln3901">  hashitem_T *hi = NULL;</a>
<a name="ln3902">  ufunc_T *fp;</a>
<a name="ln3903"> </a>
<a name="ln3904">  todo = (int)func_hashtab.ht_used;</a>
<a name="ln3905">  for (hi = func_hashtab.ht_array; todo &gt; 0 &amp;&amp; !got_int; hi++) {</a>
<a name="ln3906">    if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3907">      todo--;</a>
<a name="ln3908">      fp = HI2UF(hi);</a>
<a name="ln3909">      if (!func_name_refcount(fp-&gt;uf_name)</a>
<a name="ln3910">          &amp;&amp; set_ref_in_func(NULL, fp, copyID)) {</a>
<a name="ln3911">        return true;</a>
<a name="ln3912">      }</a>
<a name="ln3913">    }</a>
<a name="ln3914">  }</a>
<a name="ln3915">  return false;</a>
<a name="ln3916">}</a>
<a name="ln3917"> </a>
<a name="ln3918">/// Set &quot;copyID&quot; in all function arguments.</a>
<a name="ln3919">bool set_ref_in_func_args(int copyID)</a>
<a name="ln3920">{</a>
<a name="ln3921">  for (int i = 0; i &lt; funcargs.ga_len; i++) {</a>
<a name="ln3922">    if (set_ref_in_item(((typval_T **)funcargs.ga_data)[i],</a>
<a name="ln3923">                        copyID, NULL, NULL)) {</a>
<a name="ln3924">      return true;</a>
<a name="ln3925">    }</a>
<a name="ln3926">  }</a>
<a name="ln3927">  return false;</a>
<a name="ln3928">}</a>
<a name="ln3929"> </a>
<a name="ln3930">/// Mark all lists and dicts referenced through function &quot;name&quot; with &quot;copyID&quot;.</a>
<a name="ln3931">/// &quot;list_stack&quot; is used to add lists to be marked.  Can be NULL.</a>
<a name="ln3932">/// &quot;ht_stack&quot; is used to add hashtabs to be marked.  Can be NULL.</a>
<a name="ln3933">///</a>
<a name="ln3934">/// @return  true if setting references failed somehow.</a>
<a name="ln3935">bool set_ref_in_func(char *name, ufunc_T *fp_in, int copyID)</a>
<a name="ln3936">{</a>
<a name="ln3937">  ufunc_T *fp = fp_in;</a>
<a name="ln3938">  funccall_T *fc;</a>
<a name="ln3939">  int error = FCERR_NONE;</a>
<a name="ln3940">  char fname_buf[FLEN_FIXED + 1];</a>
<a name="ln3941">  char *tofree = NULL;</a>
<a name="ln3942">  bool abort = false;</a>
<a name="ln3943">  if (name == NULL &amp;&amp; fp_in == NULL) {</a>
<a name="ln3944">    return false;</a>
<a name="ln3945">  }</a>
<a name="ln3946"> </a>
<a name="ln3947">  if (fp_in == NULL) {</a>
<a name="ln3948">    char *fname = fname_trans_sid(name, fname_buf, &amp;tofree, &amp;error);</a>
<a name="ln3949">    fp = find_func(fname);</a>
<a name="ln3950">  }</a>
<a name="ln3951">  if (fp != NULL) {</a>
<a name="ln3952">    for (fc = fp-&gt;uf_scoped; fc != NULL; fc = fc-&gt;fc_func-&gt;uf_scoped) {</a>
<a name="ln3953">      abort = abort || set_ref_in_funccal(fc, copyID);</a>
<a name="ln3954">    }</a>
<a name="ln3955">  }</a>
<a name="ln3956">  xfree(tofree);</a>
<a name="ln3957">  return abort;</a>
<a name="ln3958">}</a>
<a name="ln3959"> </a>
<a name="ln3960">/// Registers a luaref as a lambda.</a>
<a name="ln3961">char *register_luafunc(LuaRef ref)</a>
<a name="ln3962">{</a>
<a name="ln3963">  char *name = get_lambda_name();</a>
<a name="ln3964">  ufunc_T *fp = xcalloc(1, offsetof(ufunc_T, uf_name) + strlen(name) + 1);</a>
<a name="ln3965"> </a>
<a name="ln3966">  fp-&gt;uf_refcount = 1;</a>
<a name="ln3967">  fp-&gt;uf_varargs = true;</a>
<a name="ln3968">  fp-&gt;uf_flags = FC_LUAREF;</a>
<a name="ln3969">  fp-&gt;uf_calls = 0;</a>
<a name="ln3970">  fp-&gt;uf_script_ctx = current_sctx;</a>
<a name="ln3971">  fp-&gt;uf_luaref = ref;</a>
<a name="ln3972"> </a>
<a name="ln3973">  STRCPY(fp-&gt;uf_name, name);</a>
<a name="ln3974">  hash_add(&amp;func_hashtab, UF2HIKEY(fp));</a>
<a name="ln3975"> </a>
<a name="ln3976">  // coverity[leaked_storage]</a>
<a name="ln3977">  return fp-&gt;uf_name;</a>
<a name="ln3978">}</a>
</code></pre>
<div class="balloon" rel="2288"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'name' pointer was utilized before it was verified against nullptr. Check lines: 2288, 2314.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>