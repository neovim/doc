<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>helpers.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;limits.h&gt;</a>
<a name="ln7">#include &lt;msgpack/unpack.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;klib/kvec.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/converter.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln20">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln25">#include &quot;nvim/garray.h&quot;</a>
<a name="ln26">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln27">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln28">#include &quot;nvim/map.h&quot;</a>
<a name="ln29">#include &quot;nvim/mark.h&quot;</a>
<a name="ln30">#include &quot;nvim/memline.h&quot;</a>
<a name="ln31">#include &quot;nvim/memory.h&quot;</a>
<a name="ln32">#include &quot;nvim/message.h&quot;</a>
<a name="ln33">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln34">#include &quot;nvim/pos.h&quot;</a>
<a name="ln35">#include &quot;nvim/ui.h&quot;</a>
<a name="ln36">#include &quot;nvim/version.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln39"># include &quot;api/private/funcs_metadata.generated.h&quot;</a>
<a name="ln40"># include &quot;api/private/helpers.c.generated.h&quot;</a>
<a name="ln41"># include &quot;api/private/ui_events_metadata.generated.h&quot;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44">/// Start block that may cause Vimscript exceptions while evaluating another code</a>
<a name="ln45">///</a>
<a name="ln46">/// Used when caller is supposed to be operating when other Vimscript code is being</a>
<a name="ln47">/// processed and that “other Vimscript code” must not be affected.</a>
<a name="ln48">///</a>
<a name="ln49">/// @param[out]  tstate  Location where try state should be saved.</a>
<a name="ln50">void try_enter(TryState *const tstate)</a>
<a name="ln51">{</a>
<a name="ln52">  // TODO(ZyX-I): Check whether try_enter()/try_leave() may use</a>
<a name="ln53">  //              enter_cleanup()/leave_cleanup(). Or</a>
<a name="ln54">  //              save_dbg_stuff()/restore_dbg_stuff().</a>
<a name="ln55">  *tstate = (TryState) {</a>
<a name="ln56">    .current_exception = current_exception,</a>
<a name="ln57">    .msg_list = (const msglist_T *const *)msg_list,</a>
<a name="ln58">    .private_msg_list = NULL,</a>
<a name="ln59">    .trylevel = trylevel,</a>
<a name="ln60">    .got_int = got_int,</a>
<a name="ln61">    .did_throw = did_throw,</a>
<a name="ln62">    .need_rethrow = need_rethrow,</a>
<a name="ln63">    .did_emsg = did_emsg,</a>
<a name="ln64">  };</a>
<a name="ln65">  msg_list = &amp;tstate-&gt;private_msg_list;</a>
<a name="ln66">  current_exception = NULL;</a>
<a name="ln67">  trylevel = 1;</a>
<a name="ln68">  got_int = false;</a>
<a name="ln69">  did_throw = false;</a>
<a name="ln70">  need_rethrow = false;</a>
<a name="ln71">  did_emsg = false;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">/// End try block, set the error message if any and restore previous state</a>
<a name="ln75">///</a>
<a name="ln76">/// @warning Return is consistent with most functions (false on error), not with</a>
<a name="ln77">///          try_end (true on error).</a>
<a name="ln78">///</a>
<a name="ln79">/// @param[in]  tstate  Previous state to restore.</a>
<a name="ln80">/// @param[out]  err  Location where error should be saved.</a>
<a name="ln81">///</a>
<a name="ln82">/// @return false if error occurred, true otherwise.</a>
<a name="ln83">bool try_leave(const TryState *const tstate, Error *const err)</a>
<a name="ln84">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln85">{</a>
<a name="ln86">  const bool ret = !try_end(err);</a>
<a name="ln87">  assert(trylevel == 0);</a>
<a name="ln88">  assert(!need_rethrow);</a>
<a name="ln89">  assert(!got_int);</a>
<a name="ln90">  assert(!did_throw);</a>
<a name="ln91">  assert(!did_emsg);</a>
<a name="ln92">  assert(msg_list == &amp;tstate-&gt;private_msg_list);</a>
<a name="ln93">  assert(*msg_list == NULL);</a>
<a name="ln94">  assert(current_exception == NULL);</a>
<a name="ln95">  msg_list = (msglist_T **)tstate-&gt;msg_list;</a>
<a name="ln96">  current_exception = tstate-&gt;current_exception;</a>
<a name="ln97">  trylevel = tstate-&gt;trylevel;</a>
<a name="ln98">  got_int = tstate-&gt;got_int;</a>
<a name="ln99">  did_throw = tstate-&gt;did_throw;</a>
<a name="ln100">  need_rethrow = tstate-&gt;need_rethrow;</a>
<a name="ln101">  did_emsg = tstate-&gt;did_emsg;</a>
<a name="ln102">  return ret;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">/// Start block that may cause vimscript exceptions</a>
<a name="ln106">///</a>
<a name="ln107">/// Each try_start() call should be mirrored by try_end() call.</a>
<a name="ln108">///</a>
<a name="ln109">/// To be used as a replacement of `:try … catch … endtry` in C code, in cases</a>
<a name="ln110">/// when error flag could not already be set. If there may be pending error</a>
<a name="ln111">/// state at the time try_start() is executed which needs to be preserved,</a>
<a name="ln112">/// try_enter()/try_leave() pair should be used instead.</a>
<a name="ln113">void try_start(void)</a>
<a name="ln114">{</a>
<a name="ln115">  trylevel++;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">/// End try block, set the error message if any and return true if an error</a>
<a name="ln119">/// occurred.</a>
<a name="ln120">///</a>
<a name="ln121">/// @param err Pointer to the stack-allocated error object</a>
<a name="ln122">/// @return true if an error occurred</a>
<a name="ln123">bool try_end(Error *err)</a>
<a name="ln124">{</a>
<a name="ln125">  // Note: all globals manipulated here should be saved/restored in</a>
<a name="ln126">  // try_enter/try_leave.</a>
<a name="ln127">  trylevel--;</a>
<a name="ln128"> </a>
<a name="ln129">  // Set by emsg(), affects aborting().  See also enter_cleanup().</a>
<a name="ln130">  did_emsg = false;</a>
<a name="ln131">  force_abort = false;</a>
<a name="ln132"> </a>
<a name="ln133">  if (got_int) {</a>
<a name="ln134">    if (did_throw) {</a>
<a name="ln135">      // If we got an interrupt, discard the current exception</a>
<a name="ln136">      discard_current_exception();</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">    api_set_error(err, kErrorTypeException, &quot;Keyboard interrupt&quot;);</a>
<a name="ln140">    got_int = false;</a>
<a name="ln141">  } else if (msg_list != NULL &amp;&amp; *msg_list != NULL) {</a>
<a name="ln142">    int should_free;</a>
<a name="ln143">    char *msg = get_exception_string(*msg_list,</a>
<a name="ln144">                                     ET_ERROR,</a>
<a name="ln145">                                     NULL,</a>
<a name="ln146">                                     &amp;should_free);</a>
<a name="ln147">    api_set_error(err, kErrorTypeException, &quot;%s&quot;, msg);</a>
<a name="ln148">    free_global_msglist();</a>
<a name="ln149"> </a>
<a name="ln150">    if (should_free) {</a>
<a name="ln151">      xfree(msg);</a>
<a name="ln152">    }</a>
<a name="ln153">  } else if (did_throw) {</a>
<a name="ln154">    if (*current_exception-&gt;throw_name != NUL) {</a>
<a name="ln155">      if (current_exception-&gt;throw_lnum != 0) {</a>
<a name="ln156">        api_set_error(err, kErrorTypeException, &quot;%s, line %&quot; PRIdLINENR &quot;: %s&quot;,</a>
<a name="ln157">                      current_exception-&gt;throw_name, current_exception-&gt;throw_lnum,</a>
<a name="ln158">                      current_exception-&gt;value);</a>
<a name="ln159">      } else {</a>
<a name="ln160">        api_set_error(err, kErrorTypeException, &quot;%s: %s&quot;,</a>
<a name="ln161">                      current_exception-&gt;throw_name, current_exception-&gt;value);</a>
<a name="ln162">      }</a>
<a name="ln163">    } else {</a>
<a name="ln164">      api_set_error(err, kErrorTypeException, &quot;%s&quot;, current_exception-&gt;value);</a>
<a name="ln165">    }</a>
<a name="ln166">    discard_current_exception();</a>
<a name="ln167">  }</a>
<a name="ln168"> </a>
<a name="ln169">  return ERROR_SET(err);</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">/// Recursively expands a vimscript value in a dict</a>
<a name="ln173">///</a>
<a name="ln174">/// @param dict The vimscript dict</a>
<a name="ln175">/// @param key The key</a>
<a name="ln176">/// @param[out] err Details of an error that may have occurred</a>
<a name="ln177">Object dict_get_value(dict_T *dict, String key, Error *err)</a>
<a name="ln178">{</a>
<a name="ln179">  dictitem_T *const di = tv_dict_find(dict, key.data, (ptrdiff_t)key.size);</a>
<a name="ln180"> </a>
<a name="ln181">  if (di == NULL) {</a>
<a name="ln182">    api_set_error(err, kErrorTypeValidation, &quot;Key not found: %s&quot;, key.data);</a>
<a name="ln183">    return (Object)OBJECT_INIT;</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  return vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">dictitem_T *dict_check_writable(dict_T *dict, String key, bool del, Error *err)</a>
<a name="ln190">{</a>
<a name="ln191">  dictitem_T *di = tv_dict_find(dict, key.data, (ptrdiff_t)key.size);</a>
<a name="ln192"> </a>
<a name="ln193">  if (di != NULL) {</a>
<a name="ln194">    if (di-&gt;di_flags &amp; DI_FLAGS_RO) {</a>
<a name="ln195">      api_set_error(err, kErrorTypeException, &quot;Key is read-only: %s&quot;, key.data);</a>
<a name="ln196">    } else if (di-&gt;di_flags &amp; DI_FLAGS_LOCK) {</a>
<a name="ln197">      api_set_error(err, kErrorTypeException, &quot;Key is locked: %s&quot;, key.data);</a>
<a name="ln198">    } else if (del &amp;&amp; (di-&gt;di_flags &amp; DI_FLAGS_FIX)) {</a>
<a name="ln199">      api_set_error(err, kErrorTypeException, &quot;Key is fixed: %s&quot;, key.data);</a>
<a name="ln200">    }</a>
<a name="ln201">  } else if (dict-&gt;dv_lock) {</a>
<a name="ln202">    api_set_error(err, kErrorTypeException, &quot;Dictionary is locked&quot;);</a>
<a name="ln203">  } else if (key.size == 0) {</a>
<a name="ln204">    api_set_error(err, kErrorTypeValidation, &quot;Key name is empty&quot;);</a>
<a name="ln205">  } else if (key.size &gt; INT_MAX) {</a>
<a name="ln206">    api_set_error(err, kErrorTypeValidation, &quot;Key name is too long&quot;);</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  return di;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">/// Set a value in a scope dict. Objects are recursively expanded into their</a>
<a name="ln213">/// vimscript equivalents.</a>
<a name="ln214">///</a>
<a name="ln215">/// @param dict The vimscript dict</a>
<a name="ln216">/// @param key The key</a>
<a name="ln217">/// @param value The new value</a>
<a name="ln218">/// @param del Delete key in place of setting it. Argument `value` is ignored in</a>
<a name="ln219">///            this case.</a>
<a name="ln220">/// @param retval If true the old value will be converted and returned.</a>
<a name="ln221">/// @param[out] err Details of an error that may have occurred</a>
<a name="ln222">/// @return The old value if `retval` is true and the key was present, else NIL</a>
<a name="ln223">Object dict_set_var(dict_T *dict, String key, Object value, bool del, bool retval, Error *err)</a>
<a name="ln224">{</a>
<a name="ln225">  Object rv = OBJECT_INIT;</a>
<a name="ln226">  dictitem_T *di = dict_check_writable(dict, key, del, err);</a>
<a name="ln227"> </a>
<a name="ln228">  if (ERROR_SET(err)) {</a>
<a name="ln229">    return rv;</a>
<a name="ln230">  }</a>
<a name="ln231"> </a>
<a name="ln232">  bool watched = tv_dict_is_watched(dict);</a>
<a name="ln233"> </a>
<a name="ln234">  if (del) {</a>
<a name="ln235">    // Delete the key</a>
<a name="ln236">    if (di == NULL) {</a>
<a name="ln237">      // Doesn't exist, fail</a>
<a name="ln238">      api_set_error(err, kErrorTypeValidation, &quot;Key not found: %s&quot;,</a>
<a name="ln239">                    key.data);</a>
<a name="ln240">    } else {</a>
<a name="ln241">      // Notify watchers</a>
<a name="ln242">      if (watched) {</a>
<a name="ln243">        tv_dict_watcher_notify(dict, key.data, NULL, &amp;di-&gt;di_tv);</a>
<a name="ln244">      }</a>
<a name="ln245">      // Return the old value</a>
<a name="ln246">      if (retval) {</a>
<a name="ln247">        rv = vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln248">      }</a>
<a name="ln249">      // Delete the entry</a>
<a name="ln250">      tv_dict_item_remove(dict, di);</a>
<a name="ln251">    }</a>
<a name="ln252">  } else {</a>
<a name="ln253">    // Update the key</a>
<a name="ln254">    typval_T tv;</a>
<a name="ln255"> </a>
<a name="ln256">    // Convert the object to a vimscript type in the temporary variable</a>
<a name="ln257">    if (!object_to_vim(value, &amp;tv, err)) {</a>
<a name="ln258">      return rv;</a>
<a name="ln259">    }</a>
<a name="ln260"> </a>
<a name="ln261">    typval_T oldtv = TV_INITIAL_VALUE;</a>
<a name="ln262"> </a>
<a name="ln263">    if (di == NULL) {</a>
<a name="ln264">      // Need to create an entry</a>
<a name="ln265">      di = tv_dict_item_alloc_len(key.data, key.size);</a>
<a name="ln266">      tv_dict_add(dict, di);</a>
<a name="ln267">    } else {</a>
<a name="ln268">      if (watched) {</a>
<a name="ln269">        tv_copy(&amp;di-&gt;di_tv, &amp;oldtv);</a>
<a name="ln270">      }</a>
<a name="ln271">      // Return the old value</a>
<a name="ln272">      if (retval) {</a>
<a name="ln273">        rv = vim_to_object(&amp;di-&gt;di_tv);</a>
<a name="ln274">      }</a>
<a name="ln275">      tv_clear(&amp;di-&gt;di_tv);</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">    // Update the value</a>
<a name="ln279">    tv_copy(&amp;tv, &amp;di-&gt;di_tv);</a>
<a name="ln280"> </a>
<a name="ln281">    // Notify watchers</a>
<a name="ln282">    if (watched) {</a>
<a name="ln283">      tv_dict_watcher_notify(dict, key.data, &amp;tv, &amp;oldtv);</a>
<a name="ln284">      tv_clear(&amp;oldtv);</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">    // Clear the temporary variable</a>
<a name="ln288">    tv_clear(&amp;tv);</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">  return rv;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">buf_T *find_buffer_by_handle(Buffer buffer, Error *err)</a>
<a name="ln295">{</a>
<a name="ln296">  if (buffer == 0) {</a>
<a name="ln297">    return curbuf;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  buf_T *rv = handle_get_buffer(buffer);</a>
<a name="ln301"> </a>
<a name="ln302">  if (!rv) {</a>
<a name="ln303">    api_set_error(err, kErrorTypeValidation, &quot;Invalid buffer id: %d&quot;, buffer);</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  return rv;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">win_T *find_window_by_handle(Window window, Error *err)</a>
<a name="ln310">{</a>
<a name="ln311">  if (window == 0) {</a>
<a name="ln312">    return curwin;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  win_T *rv = handle_get_window(window);</a>
<a name="ln316"> </a>
<a name="ln317">  if (!rv) {</a>
<a name="ln318">    api_set_error(err, kErrorTypeValidation, &quot;Invalid window id: %d&quot;, window);</a>
<a name="ln319">  }</a>
<a name="ln320"> </a>
<a name="ln321">  return rv;</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">tabpage_T *find_tab_by_handle(Tabpage tabpage, Error *err)</a>
<a name="ln325">{</a>
<a name="ln326">  if (tabpage == 0) {</a>
<a name="ln327">    return curtab;</a>
<a name="ln328">  }</a>
<a name="ln329"> </a>
<a name="ln330">  tabpage_T *rv = handle_get_tabpage(tabpage);</a>
<a name="ln331"> </a>
<a name="ln332">  if (!rv) {</a>
<a name="ln333">    api_set_error(err, kErrorTypeValidation, &quot;Invalid tabpage id: %d&quot;, tabpage);</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  return rv;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">/// Allocates a String consisting of a single char. Does not support multibyte</a>
<a name="ln340">/// characters. The resulting string is also NUL-terminated, to facilitate</a>
<a name="ln341">/// interoperating with code using C strings.</a>
<a name="ln342">///</a>
<a name="ln343">/// @param char the char to convert</a>
<a name="ln344">/// @return the resulting String, if the input char was NUL, an</a>
<a name="ln345">///         empty String is returned</a>
<a name="ln346">String cchar_to_string(char c)</a>
<a name="ln347">{</a>
<a name="ln348">  char buf[] = { c, NUL };</a>
<a name="ln349">  return (String){</a>
<a name="ln350">    .data = xmemdupz(buf, 1),</a>
<a name="ln351">    .size = (c != NUL) ? 1 : 0</a>
<a name="ln352">  };</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">/// Copies a C string into a String (binary safe string, characters + length).</a>
<a name="ln356">/// The resulting string is also NUL-terminated, to facilitate interoperating</a>
<a name="ln357">/// with code using C strings.</a>
<a name="ln358">///</a>
<a name="ln359">/// @param str the C string to copy</a>
<a name="ln360">/// @return the resulting String, if the input string was NULL, an</a>
<a name="ln361">///         empty String is returned</a>
<a name="ln362">String cstr_to_string(const char *str)</a>
<a name="ln363">{</a>
<a name="ln364">  if (str == NULL) {</a>
<a name="ln365">    return (String)STRING_INIT;</a>
<a name="ln366">  }</a>
<a name="ln367"> </a>
<a name="ln368">  size_t len = strlen(str);</a>
<a name="ln369">  return (String){</a>
<a name="ln370">    .data = xmemdupz(str, len),</a>
<a name="ln371">    .size = len,</a>
<a name="ln372">  };</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">/// Copies a String to an allocated, NUL-terminated C string.</a>
<a name="ln376">///</a>
<a name="ln377">/// @param str the String to copy</a>
<a name="ln378">/// @return the resulting C string</a>
<a name="ln379">char *string_to_cstr(String str)</a>
<a name="ln380">  FUNC_ATTR_NONNULL_RET FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln381">{</a>
<a name="ln382">  return xstrndup(str.data, str.size);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">/// Copies buffer to an allocated String.</a>
<a name="ln386">/// The resulting string is also NUL-terminated, to facilitate interoperating</a>
<a name="ln387">/// with code using C strings.</a>
<a name="ln388">///</a>
<a name="ln389">/// @param buf the buffer to copy</a>
<a name="ln390">/// @param size length of the buffer</a>
<a name="ln391">/// @return the resulting String, if the input string was NULL, an</a>
<a name="ln392">///         empty String is returned</a>
<a name="ln393">String cbuf_to_string(const char *buf, size_t size)</a>
<a name="ln394">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln395">{</a>
<a name="ln396">  return (String){</a>
<a name="ln397">    .data = xmemdupz(buf, size),</a>
<a name="ln398">    .size = size</a>
<a name="ln399">  };</a>
<a name="ln400">}</a>
<a name="ln401"> </a>
<a name="ln402">String cstrn_to_string(const char *str, size_t maxsize)</a>
<a name="ln403">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln404">{</a>
<a name="ln405">  return cbuf_to_string(str, strnlen(str, maxsize));</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">String cstrn_as_string(char *str, size_t maxsize)</a>
<a name="ln409">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln410">{</a>
<a name="ln411">  return cbuf_as_string(str, strnlen(str, maxsize));</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">/// Creates a String using the given C string. Unlike</a>
<a name="ln415">/// cstr_to_string this function DOES NOT copy the C string.</a>
<a name="ln416">///</a>
<a name="ln417">/// @param str the C string to use</a>
<a name="ln418">/// @return The resulting String, or an empty String if</a>
<a name="ln419">///           str was NULL</a>
<a name="ln420">String cstr_as_string(char *str) FUNC_ATTR_PURE</a>
<a name="ln421">{</a>
<a name="ln422">  if (str == NULL) {</a>
<a name="ln423">    return (String)STRING_INIT;</a>
<a name="ln424">  }</a>
<a name="ln425">  return (String){ .data = str, .size = strlen(str) };</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/// Return the owned memory of a ga as a String</a>
<a name="ln429">///</a>
<a name="ln430">/// Reinitializes the ga to a valid empty state.</a>
<a name="ln431">String ga_take_string(garray_T *ga)</a>
<a name="ln432">{</a>
<a name="ln433">  String str = { .data = (char *)ga-&gt;ga_data, .size = (size_t)ga-&gt;ga_len };</a>
<a name="ln434">  ga-&gt;ga_data = NULL;</a>
<a name="ln435">  ga-&gt;ga_len = 0;</a>
<a name="ln436">  ga-&gt;ga_maxlen = 0;</a>
<a name="ln437">  return str;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/// Creates &quot;readfile()-style&quot; ArrayOf(String) from a binary string.</a>
<a name="ln441">///</a>
<a name="ln442">/// - Lines break at \n (NL/LF/line-feed).</a>
<a name="ln443">/// - NUL bytes are replaced with NL.</a>
<a name="ln444">/// - If the last byte is a linebreak an extra empty list item is added.</a>
<a name="ln445">///</a>
<a name="ln446">/// @param input  Binary string</a>
<a name="ln447">/// @param crlf  Also break lines at CR and CRLF.</a>
<a name="ln448">/// @return [allocated] String array</a>
<a name="ln449">Array string_to_array(const String input, bool crlf)</a>
<a name="ln450">{</a>
<a name="ln451">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln452">  for (size_t i = 0; i &lt; input.size; i++) {</a>
<a name="ln453">    const char *start = input.data + i;</a>
<a name="ln454">    const char *end = start;</a>
<a name="ln455">    size_t line_len = 0;</a>
<a name="ln456">    for (; line_len &lt; input.size - i; line_len++) {</a>
<a name="ln457">      end = start + line_len;</a>
<a name="ln458">      if (*end == NL || (crlf &amp;&amp; *end == CAR)) {</a>
<a name="ln459">        break;</a>
<a name="ln460">      }</a>
<a name="ln461">    }</a>
<a name="ln462">    i += line_len;</a>
<a name="ln463">    if (crlf &amp;&amp; *end == CAR &amp;&amp; i + 1 &lt; input.size &amp;&amp; *(end + 1) == NL) {</a>
<a name="ln464">      i += 1;  // Advance past CRLF.</a>
<a name="ln465">    }</a>
<a name="ln466">    String s = {</a>
<a name="ln467">      .size = line_len,</a>
<a name="ln468">      .data = xmemdupz(start, line_len),</a>
<a name="ln469">    };</a>
<a name="ln470">    memchrsub(s.data, NUL, NL, line_len);</a>
<a name="ln471">    ADD(ret, STRING_OBJ(s));</a>
<a name="ln472">    // If line ends at end-of-buffer, add empty final item.</a>
<a name="ln473">    // This is &quot;readfile()-style&quot;, see also &quot;:help channel-lines&quot;.</a>
<a name="ln474">    if (i + 1 == input.size &amp;&amp; (*end == NL || (crlf &amp;&amp; *end == CAR))) {</a>
<a name="ln475">      ADD(ret, STRING_OBJ(STRING_INIT));</a>
<a name="ln476">    }</a>
<a name="ln477">  }</a>
<a name="ln478"> </a>
<a name="ln479">  return ret;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/// Normalizes 0-based indexes to buffer line numbers.</a>
<a name="ln483">int64_t normalize_index(buf_T *buf, int64_t index, bool end_exclusive, bool *oob)</a>
<a name="ln484">{</a>
<a name="ln485">  assert(buf-&gt;b_ml.ml_line_count &gt; 0);</a>
<a name="ln486">  int64_t max_index = buf-&gt;b_ml.ml_line_count + (int)end_exclusive - 1;</a>
<a name="ln487">  // A negative index counts from the bottom.</a>
<a name="ln488">  index = index &lt; 0 ? max_index + index + 1 : index;</a>
<a name="ln489"> </a>
<a name="ln490">  // Check for oob and clamp.</a>
<a name="ln491">  if (index &gt; max_index) {</a>
<a name="ln492">    *oob = true;</a>
<a name="ln493">    index = max_index;</a>
<a name="ln494">  } else if (index &lt; 0) {</a>
<a name="ln495">    *oob = true;</a>
<a name="ln496">    index = 0;</a>
<a name="ln497">  }</a>
<a name="ln498">  // Convert the index to a 1-based line number.</a>
<a name="ln499">  index++;</a>
<a name="ln500">  return index;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/// Returns a substring of a buffer line</a>
<a name="ln504">///</a>
<a name="ln505">/// @param buf          Buffer handle</a>
<a name="ln506">/// @param lnum         Line number (1-based)</a>
<a name="ln507">/// @param start_col    Starting byte offset into line (0-based)</a>
<a name="ln508">/// @param end_col      Ending byte offset into line (0-based, exclusive)</a>
<a name="ln509">/// @param err          Error object</a>
<a name="ln510">/// @return The text between start_col and end_col on line lnum of buffer buf</a>
<a name="ln511">String buf_get_text(buf_T *buf, int64_t lnum, int64_t start_col, int64_t end_col, Error *err)</a>
<a name="ln512">{</a>
<a name="ln513">  String rv = STRING_INIT;</a>
<a name="ln514"> </a>
<a name="ln515">  if (lnum &gt;= MAXLNUM) {</a>
<a name="ln516">    api_set_error(err, kErrorTypeValidation, &quot;Line index is too high&quot;);</a>
<a name="ln517">    return rv;</a>
<a name="ln518">  }</a>
<a name="ln519"> </a>
<a name="ln520">  char *bufstr = ml_get_buf(buf, (linenr_T)lnum);</a>
<a name="ln521">  size_t line_length = strlen(bufstr);</a>
<a name="ln522"> </a>
<a name="ln523">  start_col = start_col &lt; 0 ? (int64_t)line_length + start_col + 1 : start_col;</a>
<a name="ln524">  end_col = end_col &lt; 0 ? (int64_t)line_length + end_col + 1 : end_col;</a>
<a name="ln525"> </a>
<a name="ln526">  if (start_col &gt;= MAXCOL || end_col &gt;= MAXCOL) {</a>
<a name="ln527">    api_set_error(err, kErrorTypeValidation, &quot;Column index is too high&quot;);</a>
<a name="ln528">    return rv;</a>
<a name="ln529">  }</a>
<a name="ln530"> </a>
<a name="ln531">  if (start_col &gt; end_col) {</a>
<a name="ln532">    api_set_error(err, kErrorTypeValidation, &quot;start_col must be less than end_col&quot;);</a>
<a name="ln533">    return rv;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536">  if ((size_t)start_col &gt;= line_length) {</a>
<a name="ln537">    return rv;</a>
<a name="ln538">  }</a>
<a name="ln539"> </a>
<a name="ln540">  return cstrn_as_string(&amp;bufstr[start_col], (size_t)(end_col - start_col));</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">void api_free_string(String value)</a>
<a name="ln544">{</a>
<a name="ln545">  if (!value.data) {</a>
<a name="ln546">    return;</a>
<a name="ln547">  }</a>
<a name="ln548"> </a>
<a name="ln549">  xfree(value.data);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">Array arena_array(Arena *arena, size_t max_size)</a>
<a name="ln553">{</a>
<a name="ln554">  Array arr = ARRAY_DICT_INIT;</a>
<a name="ln555">  kv_fixsize_arena(arena, arr, max_size);</a>
<a name="ln556">  return arr;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">Dictionary arena_dict(Arena *arena, size_t max_size)</a>
<a name="ln560">{</a>
<a name="ln561">  Dictionary dict = ARRAY_DICT_INIT;</a>
<a name="ln562">  kv_fixsize_arena(arena, dict, max_size);</a>
<a name="ln563">  return dict;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">String arena_string(Arena *arena, String str)</a>
<a name="ln567">{</a>
<a name="ln568">  if (str.size) {</a>
<a name="ln569">    return cbuf_as_string(arena_memdupz(arena, str.data, str.size), str.size);</a>
<a name="ln570">  } else {</a>
<a name="ln571">    return (String)STRING_INIT;</a>
<a name="ln572">  }</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">void api_free_object(Object value)</a>
<a name="ln576">{</a>
<a name="ln577">  switch (value.type) {</a>
<a name="ln578">  case kObjectTypeNil:</a>
<a name="ln579">  case kObjectTypeBoolean:</a>
<a name="ln580">  case kObjectTypeInteger:</a>
<a name="ln581">  case kObjectTypeFloat:</a>
<a name="ln582">  case kObjectTypeBuffer:</a>
<a name="ln583">  case kObjectTypeWindow:</a>
<a name="ln584">  case kObjectTypeTabpage:</a>
<a name="ln585">    break;</a>
<a name="ln586"> </a>
<a name="ln587">  case kObjectTypeString:</a>
<a name="ln588">    api_free_string(value.data.string);</a>
<a name="ln589">    break;</a>
<a name="ln590"> </a>
<a name="ln591">  case kObjectTypeArray:</a>
<a name="ln592">    api_free_array(value.data.array);</a>
<a name="ln593">    break;</a>
<a name="ln594"> </a>
<a name="ln595">  case kObjectTypeDictionary:</a>
<a name="ln596">    api_free_dictionary(value.data.dictionary);</a>
<a name="ln597">    break;</a>
<a name="ln598"> </a>
<a name="ln599">  case kObjectTypeLuaRef:</a>
<a name="ln600">    api_free_luaref(value.data.luaref);</a>
<a name="ln601">    break;</a>
<a name="ln602"> </a>
<a name="ln603">  default:</a>
<a name="ln604">    abort();</a>
<a name="ln605">  }</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">void api_free_array(Array value)</a>
<a name="ln609">{</a>
<a name="ln610">  for (size_t i = 0; i &lt; value.size; i++) {</a>
<a name="ln611">    api_free_object(value.items[i]);</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  xfree(value.items);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">void api_free_dictionary(Dictionary value)</a>
<a name="ln618">{</a>
<a name="ln619">  for (size_t i = 0; i &lt; value.size; i++) {</a>
<a name="ln620">    api_free_string(value.items[i].key);</a>
<a name="ln621">    api_free_object(value.items[i].value);</a>
<a name="ln622">  }</a>
<a name="ln623"> </a>
<a name="ln624">  xfree(value.items);</a>
<a name="ln625">}</a>
<a name="ln626"> </a>
<a name="ln627">void api_clear_error(Error *value)</a>
<a name="ln628">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln629">{</a>
<a name="ln630">  if (!ERROR_SET(value)) {</a>
<a name="ln631">    return;</a>
<a name="ln632">  }</a>
<a name="ln633">  xfree(value-&gt;msg);</a>
<a name="ln634">  value-&gt;msg = NULL;</a>
<a name="ln635">  value-&gt;type = kErrorTypeNone;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">/// @returns a shared value. caller must not modify it!</a>
<a name="ln639">Dictionary api_metadata(void)</a>
<a name="ln640">{</a>
<a name="ln641">  static Dictionary metadata = ARRAY_DICT_INIT;</a>
<a name="ln642"> </a>
<a name="ln643">  if (!metadata.size) {</a>
<a name="ln644">    PUT(metadata, &quot;version&quot;, DICTIONARY_OBJ(version_dict()));</a>
<a name="ln645">    init_function_metadata(&amp;metadata);</a>
<a name="ln646">    init_ui_event_metadata(&amp;metadata);</a>
<a name="ln647">    init_error_type_metadata(&amp;metadata);</a>
<a name="ln648">    init_type_metadata(&amp;metadata);</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  return metadata;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">static void init_function_metadata(Dictionary *metadata)</a>
<a name="ln655">{</a>
<a name="ln656">  msgpack_unpacked unpacked;</a>
<a name="ln657">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln658">  if (msgpack_unpack_next(&amp;unpacked,</a>
<a name="ln659">                          (const char *)funcs_metadata,</a>
<a name="ln660">                          sizeof(funcs_metadata),</a>
<a name="ln661">                          NULL) != MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln662">    abort();</a>
<a name="ln663">  }</a>
<a name="ln664">  Object functions;</a>
<a name="ln665">  msgpack_rpc_to_object(&amp;unpacked.data, &amp;functions);</a>
<a name="ln666">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln667">  PUT(*metadata, &quot;functions&quot;, functions);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">static void init_ui_event_metadata(Dictionary *metadata)</a>
<a name="ln671">{</a>
<a name="ln672">  msgpack_unpacked unpacked;</a>
<a name="ln673">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln674">  if (msgpack_unpack_next(&amp;unpacked,</a>
<a name="ln675">                          (const char *)ui_events_metadata,</a>
<a name="ln676">                          sizeof(ui_events_metadata),</a>
<a name="ln677">                          NULL) != MSGPACK_UNPACK_SUCCESS) {</a>
<a name="ln678">    abort();</a>
<a name="ln679">  }</a>
<a name="ln680">  Object ui_events;</a>
<a name="ln681">  msgpack_rpc_to_object(&amp;unpacked.data, &amp;ui_events);</a>
<a name="ln682">  msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln683">  PUT(*metadata, &quot;ui_events&quot;, ui_events);</a>
<a name="ln684">  Array ui_options = ARRAY_DICT_INIT;</a>
<a name="ln685">  ADD(ui_options, CSTR_TO_OBJ(&quot;rgb&quot;));</a>
<a name="ln686">  for (UIExtension i = 0; i &lt; kUIExtCount; i++) {</a>
<a name="ln687">    if (ui_ext_names[i][0] != '_') {</a>
<a name="ln688">      ADD(ui_options, CSTR_TO_OBJ(ui_ext_names[i]));</a>
<a name="ln689">    }</a>
<a name="ln690">  }</a>
<a name="ln691">  PUT(*metadata, &quot;ui_options&quot;, ARRAY_OBJ(ui_options));</a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">static void init_error_type_metadata(Dictionary *metadata)</a>
<a name="ln695">{</a>
<a name="ln696">  Dictionary types = ARRAY_DICT_INIT;</a>
<a name="ln697"> </a>
<a name="ln698">  Dictionary exception_metadata = ARRAY_DICT_INIT;</a>
<a name="ln699">  PUT(exception_metadata, &quot;id&quot;, INTEGER_OBJ(kErrorTypeException));</a>
<a name="ln700"> </a>
<a name="ln701">  Dictionary validation_metadata = ARRAY_DICT_INIT;</a>
<a name="ln702">  PUT(validation_metadata, &quot;id&quot;, INTEGER_OBJ(kErrorTypeValidation));</a>
<a name="ln703"> </a>
<a name="ln704">  PUT(types, &quot;Exception&quot;, DICTIONARY_OBJ(exception_metadata));</a>
<a name="ln705">  PUT(types, &quot;Validation&quot;, DICTIONARY_OBJ(validation_metadata));</a>
<a name="ln706"> </a>
<a name="ln707">  PUT(*metadata, &quot;error_types&quot;, DICTIONARY_OBJ(types));</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">static void init_type_metadata(Dictionary *metadata)</a>
<a name="ln711">{</a>
<a name="ln712">  Dictionary types = ARRAY_DICT_INIT;</a>
<a name="ln713"> </a>
<a name="ln714">  Dictionary buffer_metadata = ARRAY_DICT_INIT;</a>
<a name="ln715">  PUT(buffer_metadata, &quot;id&quot;,</a>
<a name="ln716">      INTEGER_OBJ(kObjectTypeBuffer - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln717">  PUT(buffer_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_buf_&quot;));</a>
<a name="ln718"> </a>
<a name="ln719">  Dictionary window_metadata = ARRAY_DICT_INIT;</a>
<a name="ln720">  PUT(window_metadata, &quot;id&quot;,</a>
<a name="ln721">      INTEGER_OBJ(kObjectTypeWindow - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln722">  PUT(window_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_win_&quot;));</a>
<a name="ln723"> </a>
<a name="ln724">  Dictionary tabpage_metadata = ARRAY_DICT_INIT;</a>
<a name="ln725">  PUT(tabpage_metadata, &quot;id&quot;,</a>
<a name="ln726">      INTEGER_OBJ(kObjectTypeTabpage - EXT_OBJECT_TYPE_SHIFT));</a>
<a name="ln727">  PUT(tabpage_metadata, &quot;prefix&quot;, CSTR_TO_OBJ(&quot;nvim_tabpage_&quot;));</a>
<a name="ln728"> </a>
<a name="ln729">  PUT(types, &quot;Buffer&quot;, DICTIONARY_OBJ(buffer_metadata));</a>
<a name="ln730">  PUT(types, &quot;Window&quot;, DICTIONARY_OBJ(window_metadata));</a>
<a name="ln731">  PUT(types, &quot;Tabpage&quot;, DICTIONARY_OBJ(tabpage_metadata));</a>
<a name="ln732"> </a>
<a name="ln733">  PUT(*metadata, &quot;types&quot;, DICTIONARY_OBJ(types));</a>
<a name="ln734">}</a>
<a name="ln735"> </a>
<a name="ln736">// all the copy_[object] functions allow arena=NULL,</a>
<a name="ln737">// then global allocations are used, and the resulting object</a>
<a name="ln738">// should be freed with an api_free_[object] function</a>
<a name="ln739"> </a>
<a name="ln740">String copy_string(String str, Arena *arena)</a>
<a name="ln741">{</a>
<a name="ln742">  if (str.data != NULL) {</a>
<a name="ln743">    return (String){ .data = arena_memdupz(arena, str.data, str.size), .size = str.size };</a>
<a name="ln744">  } else {</a>
<a name="ln745">    return (String)STRING_INIT;</a>
<a name="ln746">  }</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">Array copy_array(Array array, Arena *arena)</a>
<a name="ln750">{</a>
<a name="ln751">  Array rv = arena_array(arena, array.size);</a>
<a name="ln752">  for (size_t i = 0; i &lt; array.size; i++) {</a>
<a name="ln753">    ADD(rv, copy_object(array.items[i], arena));</a>
<a name="ln754">  }</a>
<a name="ln755">  return rv;</a>
<a name="ln756">}</a>
<a name="ln757"> </a>
<a name="ln758">Dictionary copy_dictionary(Dictionary dict, Arena *arena)</a>
<a name="ln759">{</a>
<a name="ln760">  Dictionary rv = arena_dict(arena, dict.size);</a>
<a name="ln761">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln762">    KeyValuePair item = dict.items[i];</a>
<a name="ln763">    PUT_C(rv, copy_string(item.key, arena).data, copy_object(item.value, arena));</a>
<a name="ln764">  }</a>
<a name="ln765">  return rv;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">/// Creates a deep clone of an object</a>
<a name="ln769">Object copy_object(Object obj, Arena *arena)</a>
<a name="ln770">{</a>
<a name="ln771">  switch (obj.type) {</a>
<a name="ln772">  case kObjectTypeBuffer:</a>
<a name="ln773">  case kObjectTypeTabpage:</a>
<a name="ln774">  case kObjectTypeWindow:</a>
<a name="ln775">  case kObjectTypeNil:</a>
<a name="ln776">  case kObjectTypeBoolean:</a>
<a name="ln777">  case kObjectTypeInteger:</a>
<a name="ln778">  case kObjectTypeFloat:</a>
<a name="ln779">    return obj;</a>
<a name="ln780"> </a>
<a name="ln781">  case kObjectTypeString:</a>
<a name="ln782">    return STRING_OBJ(copy_string(obj.data.string, arena));</a>
<a name="ln783"> </a>
<a name="ln784">  case kObjectTypeArray:</a>
<a name="ln785">    return ARRAY_OBJ(copy_array(obj.data.array, arena));</a>
<a name="ln786"> </a>
<a name="ln787">  case kObjectTypeDictionary:</a>
<a name="ln788">    return DICTIONARY_OBJ(copy_dictionary(obj.data.dictionary, arena));</a>
<a name="ln789"> </a>
<a name="ln790">  case kObjectTypeLuaRef:</a>
<a name="ln791">    return LUAREF_OBJ(api_new_luaref(obj.data.luaref));</a>
<a name="ln792"> </a>
<a name="ln793">  default:</a>
<a name="ln794">    abort();</a>
<a name="ln795">  }</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">void api_set_error(Error *err, ErrorType errType, const char *format, ...)</a>
<a name="ln799">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PRINTF(3, 4)</a>
<a name="ln800">{</a>
<a name="ln801">  assert(kErrorTypeNone != errType);</a>
<a name="ln802">  va_list args1;</a>
<a name="ln803">  va_list args2;</a>
<a name="ln804">  va_start(args1, format);</a>
<a name="ln805">  va_copy(args2, args1);</a>
<a name="ln806">  int len = vsnprintf(NULL, 0, format, args1);</a>
<a name="ln807">  va_end(args1);</a>
<a name="ln808">  assert(len &gt;= 0);</a>
<a name="ln809">  // Limit error message to 1 MB.</a>
<a name="ln810">  size_t bufsize = MIN((size_t)len + 1, 1024 * 1024);</a>
<a name="ln811">  err-&gt;msg = xmalloc(bufsize);</a>
<a name="ln812">  vsnprintf(err-&gt;msg, bufsize, format, args2);</a>
<a name="ln813">  va_end(args2);</a>
<a name="ln814"> </a>
<a name="ln815">  err-&gt;type = errType;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">/// Force obj to bool.</a>
<a name="ln819">/// If it fails, returns false and sets err</a>
<a name="ln820">/// @param obj          The object to coerce to a boolean</a>
<a name="ln821">/// @param what         The name of the object, used for error message</a>
<a name="ln822">/// @param nil_value    What to return if the type is nil.</a>
<a name="ln823">/// @param err          Set if there was an error in converting to a bool</a>
<a name="ln824">bool api_object_to_bool(Object obj, const char *what, bool nil_value, Error *err)</a>
<a name="ln825">{</a>
<a name="ln826">  if (obj.type == kObjectTypeBoolean) {</a>
<a name="ln827">    return obj.data.boolean;</a>
<a name="ln828">  } else if (obj.type == kObjectTypeInteger) {</a>
<a name="ln829">    return obj.data.integer;  // C semantics: non-zero int is true</a>
<a name="ln830">  } else if (obj.type == kObjectTypeNil) {</a>
<a name="ln831">    return nil_value;  // caller decides what NIL (missing retval in Lua) means</a>
<a name="ln832">  } else {</a>
<a name="ln833">    api_set_error(err, kErrorTypeValidation, &quot;%s is not a boolean&quot;, what);</a>
<a name="ln834">    return false;</a>
<a name="ln835">  }</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">int object_to_hl_id(Object obj, const char *what, Error *err)</a>
<a name="ln839">{</a>
<a name="ln840">  if (obj.type == kObjectTypeString) {</a>
<a name="ln841">    String str = obj.data.string;</a>
<a name="ln842">    return str.size ? syn_check_group(str.data, str.size) : 0;</a>
<a name="ln843">  } else if (obj.type == kObjectTypeInteger) {</a>
<a name="ln844">    return MAX((int)obj.data.integer, 0);</a>
<a name="ln845">  } else {</a>
<a name="ln846">    api_set_error(err, kErrorTypeValidation, &quot;Invalid highlight: %s&quot;, what);</a>
<a name="ln847">    return 0;</a>
<a name="ln848">  }</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">char *api_typename(ObjectType t)</a>
<a name="ln852">{</a>
<a name="ln853">  switch (t) {</a>
<a name="ln854">  case kObjectTypeNil:</a>
<a name="ln855">    return &quot;nil&quot;;</a>
<a name="ln856">  case kObjectTypeBoolean:</a>
<a name="ln857">    return &quot;Boolean&quot;;</a>
<a name="ln858">  case kObjectTypeInteger:</a>
<a name="ln859">    return &quot;Integer&quot;;</a>
<a name="ln860">  case kObjectTypeFloat:</a>
<a name="ln861">    return &quot;Float&quot;;</a>
<a name="ln862">  case kObjectTypeString:</a>
<a name="ln863">    return &quot;String&quot;;</a>
<a name="ln864">  case kObjectTypeArray:</a>
<a name="ln865">    return &quot;Array&quot;;</a>
<a name="ln866">  case kObjectTypeDictionary:</a>
<a name="ln867">    return &quot;Dict&quot;;</a>
<a name="ln868">  case kObjectTypeLuaRef:</a>
<a name="ln869">    return &quot;Function&quot;;</a>
<a name="ln870">  case kObjectTypeBuffer:</a>
<a name="ln871">    return &quot;Buffer&quot;;</a>
<a name="ln872">  case kObjectTypeWindow:</a>
<a name="ln873">    return &quot;Window&quot;;</a>
<a name="ln874">  case kObjectTypeTabpage:</a>
<a name="ln875">    return &quot;Tabpage&quot;;</a>
<a name="ln876">  default:</a>
<a name="ln877">    abort();</a>
<a name="ln878">  }</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">HlMessage parse_hl_msg(Array chunks, Error *err)</a>
<a name="ln882">{</a>
<a name="ln883">  HlMessage hl_msg = KV_INITIAL_VALUE;</a>
<a name="ln884">  for (size_t i = 0; i &lt; chunks.size; i++) {</a>
<a name="ln885">    if (chunks.items[i].type != kObjectTypeArray) {</a>
<a name="ln886">      api_set_error(err, kErrorTypeValidation, &quot;Chunk is not an array&quot;);</a>
<a name="ln887">      goto free_exit;</a>
<a name="ln888">    }</a>
<a name="ln889">    Array chunk = chunks.items[i].data.array;</a>
<a name="ln890">    if (chunk.size == 0 || chunk.size &gt; 2</a>
<a name="ln891">        || chunk.items[0].type != kObjectTypeString</a>
<a name="ln892">        || (chunk.size == 2 &amp;&amp; chunk.items[1].type != kObjectTypeString)) {</a>
<a name="ln893">      api_set_error(err, kErrorTypeValidation,</a>
<a name="ln894">                    &quot;Chunk is not an array with one or two strings&quot;);</a>
<a name="ln895">      goto free_exit;</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">    String str = copy_string(chunk.items[0].data.string, NULL);</a>
<a name="ln899"> </a>
<a name="ln900">    int attr = 0;</a>
<a name="ln901">    if (chunk.size == 2) {</a>
<a name="ln902">      String hl = chunk.items[1].data.string;</a>
<a name="ln903">      if (hl.size &gt; 0) {</a>
<a name="ln904">        // TODO(bfredl): use object_to_hl_id and allow integer</a>
<a name="ln905">        int hl_id = syn_check_group(hl.data, hl.size);</a>
<a name="ln906">        attr = hl_id &gt; 0 ? syn_id2attr(hl_id) : 0;</a>
<a name="ln907">      }</a>
<a name="ln908">    }</a>
<a name="ln909">    kv_push(hl_msg, ((HlMessageChunk){ .text = str, .attr = attr }));</a>
<a name="ln910">  }</a>
<a name="ln911"> </a>
<a name="ln912">  return hl_msg;</a>
<a name="ln913"> </a>
<a name="ln914">free_exit:</a>
<a name="ln915">  hl_msg_free(hl_msg);</a>
<a name="ln916">  return (HlMessage)KV_INITIAL_VALUE;</a>
<a name="ln917">}</a>
<a name="ln918"> </a>
<a name="ln919">// see also nlua_pop_keydict for the lua specific implementation</a>
<a name="ln920">bool api_dict_to_keydict(void *retval, FieldHashfn hashy, Dictionary dict, Error *err)</a>
<a name="ln921">{</a>
<a name="ln922">  for (size_t i = 0; i &lt; dict.size; i++) {</a>
<a name="ln923">    String k = dict.items[i].key;</a>
<a name="ln924">    KeySetLink *field = hashy(k.data, k.size);</a>
<a name="ln925">    if (!field) {</a>
<a name="ln926">      api_set_error(err, kErrorTypeValidation, &quot;Invalid key: '%.*s'&quot;, (int)k.size, k.data);</a>
<a name="ln927">      return false;</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">    if (field-&gt;opt_index &gt;= 0) {</a>
<a name="ln931">      OptKeySet *ks = (OptKeySet *)retval;</a>
<a name="ln932">      ks-&gt;is_set_ |= (1ULL &lt;&lt; field-&gt;opt_index);</a>
<a name="ln933">    }</a>
<a name="ln934"> </a>
<a name="ln935">    char *mem = ((char *)retval + field-&gt;ptr_off);</a>
<a name="ln936">    Object *value = &amp;dict.items[i].value;</a>
<a name="ln937">    if (field-&gt;type == kObjectTypeNil) {</a>
<a name="ln938">      *(Object *)mem = *value;</a>
<a name="ln939">    } else if (field-&gt;type == kObjectTypeInteger) {</a>
<a name="ln940">      VALIDATE_T(field-&gt;str, kObjectTypeInteger, value-&gt;type, {</a>
<a name="ln941">        return false;</a>
<a name="ln942">      });</a>
<a name="ln943">      *(Integer *)mem = value-&gt;data.integer;</a>
<a name="ln944">    } else if (field-&gt;type == kObjectTypeFloat) {</a>
<a name="ln945">      Float *val = (Float *)mem;</a>
<a name="ln946">      if (value-&gt;type == kObjectTypeInteger) {</a>
<a name="ln947">        *val = (Float)value-&gt;data.integer;</a>
<a name="ln948">      } else {</a>
<a name="ln949">        VALIDATE_T(field-&gt;str, kObjectTypeFloat, value-&gt;type, {</a>
<a name="ln950">          return false;</a>
<a name="ln951">        });</a>
<a name="ln952">        *val = value-&gt;data.floating;</a>
<a name="ln953">      }</a>
<a name="ln954">    } else if (field-&gt;type == kObjectTypeBoolean) {</a>
<a name="ln955">      // caller should check HAS_KEY to override the nil behavior, or GET_BOOL_OR_TRUE</a>
<a name="ln956">      // to directly use true when nil</a>
<a name="ln957">      *(Boolean *)mem = api_object_to_bool(*value, field-&gt;str, false, err);</a>
<a name="ln958">      if (ERROR_SET(err)) {</a>
<a name="ln959">        return false;</a>
<a name="ln960">      }</a>
<a name="ln961">    } else if (field-&gt;type == kObjectTypeString) {</a>
<a name="ln962">      VALIDATE_T(field-&gt;str, kObjectTypeString, value-&gt;type, {</a>
<a name="ln963">        return false;</a>
<a name="ln964">      });</a>
<a name="ln965">      *(String *)mem = value-&gt;data.string;</a>
<a name="ln966">    } else if (field-&gt;type == kObjectTypeArray) {</a>
<a name="ln967">      VALIDATE_T(field-&gt;str, kObjectTypeArray, value-&gt;type, {</a>
<a name="ln968">        return false;</a>
<a name="ln969">      });</a>
<a name="ln970">      *(Array *)mem = value-&gt;data.array;</a>
<a name="ln971">    } else if (field-&gt;type == kObjectTypeDictionary) {</a>
<a name="ln972">      Dictionary *val = (Dictionary *)mem;</a>
<a name="ln973">      // allow empty array as empty dict for lua (directly or via lua-client RPC)</a>
<a name="ln974">      if (value-&gt;type == kObjectTypeArray &amp;&amp; value-&gt;data.array.size == 0) {</a>
<a name="ln975">        *val = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln976">      } else if (value-&gt;type == kObjectTypeDictionary) {</a>
<a name="ln977">        *val = value-&gt;data.dictionary;</a>
<a name="ln978">      } else {</a>
<a name="ln979">        api_err_exp(err, field-&gt;str, api_typename(field-&gt;type), api_typename(value-&gt;type));</a>
<a name="ln980">        return false;</a>
<a name="ln981">      }</a>
<a name="ln982">    } else if (field-&gt;type == kObjectTypeBuffer || field-&gt;type == kObjectTypeWindow</a>
<a name="ln983">               || field-&gt;type == kObjectTypeTabpage) {</a>
<a name="ln984">      if (value-&gt;type == kObjectTypeInteger || value-&gt;type == field-&gt;type) {</a>
<a name="ln985">        *(handle_T *)mem = (handle_T)value-&gt;data.integer;</a>
<a name="ln986">      } else {</a>
<a name="ln987">        api_err_exp(err, field-&gt;str, api_typename(field-&gt;type), api_typename(value-&gt;type));</a>
<a name="ln988">        return false;</a>
<a name="ln989">      }</a>
<a name="ln990">    } else if (field-&gt;type == kObjectTypeLuaRef) {</a>
<a name="ln991">      api_set_error(err, kErrorTypeValidation, &quot;Invalid key: '%.*s' is only allowed from Lua&quot;,</a>
<a name="ln992">                    (int)k.size, k.data);</a>
<a name="ln993">      return false;</a>
<a name="ln994">    } else {</a>
<a name="ln995">      abort();</a>
<a name="ln996">    }</a>
<a name="ln997">  }</a>
<a name="ln998"> </a>
<a name="ln999">  return true;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002">void api_free_keydict(void *dict, KeySetLink *table)</a>
<a name="ln1003">{</a>
<a name="ln1004">  for (size_t i = 0; table[i].str; i++) {</a>
<a name="ln1005">    char *mem = ((char *)dict + table[i].ptr_off);</a>
<a name="ln1006">    if (table[i].type == kObjectTypeNil) {</a>
<a name="ln1007">      api_free_object(*(Object *)mem);</a>
<a name="ln1008">    } else if (table[i].type == kObjectTypeString) {</a>
<a name="ln1009">      api_free_string(*(String *)mem);</a>
<a name="ln1010">    } else if (table[i].type == kObjectTypeArray) {</a>
<a name="ln1011">      api_free_array(*(Array *)mem);</a>
<a name="ln1012">    } else if (table[i].type == kObjectTypeDictionary) {</a>
<a name="ln1013">      api_free_dictionary(*(Dictionary *)mem);</a>
<a name="ln1014">    } else if (table[i].type == kObjectTypeLuaRef) {</a>
<a name="ln1015">      api_free_luaref(*(LuaRef *)mem);</a>
<a name="ln1016">    }</a>
<a name="ln1017">  }</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">/// Set a named mark</a>
<a name="ln1021">/// buffer and mark name must be validated already</a>
<a name="ln1022">/// @param buffer     Buffer to set the mark on</a>
<a name="ln1023">/// @param name       Mark name</a>
<a name="ln1024">/// @param line       Line number</a>
<a name="ln1025">/// @param col        Column/row number</a>
<a name="ln1026">/// @return true if the mark was set, else false</a>
<a name="ln1027">bool set_mark(buf_T *buf, String name, Integer line, Integer col, Error *err)</a>
<a name="ln1028">{</a>
<a name="ln1029">  buf = buf == NULL ? curbuf : buf;</a>
<a name="ln1030">  // If line == 0 the marks is being deleted</a>
<a name="ln1031">  bool res = false;</a>
<a name="ln1032">  bool deleting = false;</a>
<a name="ln1033">  if (line == 0) {</a>
<a name="ln1034">    col = 0;</a>
<a name="ln1035">    deleting = true;</a>
<a name="ln1036">  } else {</a>
<a name="ln1037">    if (col &gt; MAXCOL) {</a>
<a name="ln1038">      api_set_error(err, kErrorTypeValidation, &quot;Column value outside range&quot;);</a>
<a name="ln1039">      return res;</a>
<a name="ln1040">    }</a>
<a name="ln1041">    if (line &lt; 1 || line &gt; buf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1042">      api_set_error(err, kErrorTypeValidation, &quot;Line value outside range&quot;);</a>
<a name="ln1043">      return res;</a>
<a name="ln1044">    }</a>
<a name="ln1045">  }</a>
<a name="ln1046">  assert(INT32_MIN &lt;= line &amp;&amp; line &lt;= INT32_MAX);</a>
<a name="ln1047">  pos_T pos = { (linenr_T)line, (int)col, (int)col };</a>
<a name="ln1048">  res = setmark_pos(*name.data, &amp;pos, buf-&gt;handle, NULL);</a>
<a name="ln1049">  if (!res) {</a>
<a name="ln1050">    if (deleting) {</a>
<a name="ln1051">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1052">                    &quot;Failed to delete named mark: %c&quot;, *name.data);</a>
<a name="ln1053">    } else {</a>
<a name="ln1054">      api_set_error(err, kErrorTypeException,</a>
<a name="ln1055">                    &quot;Failed to set named mark: %c&quot;, *name.data);</a>
<a name="ln1056">    }</a>
<a name="ln1057">  }</a>
<a name="ln1058">  return res;</a>
<a name="ln1059">}</a>
<a name="ln1060"> </a>
<a name="ln1061">/// Get default statusline highlight for window</a>
<a name="ln1062">const char *get_default_stl_hl(win_T *wp, bool use_winbar, int stc_hl_id)</a>
<a name="ln1063">{</a>
<a name="ln1064">  if (wp == NULL) {</a>
<a name="ln1065">    return &quot;TabLineFill&quot;;</a>
<a name="ln1066">  } else if (use_winbar) {</a>
<a name="ln1067">    return (wp == curwin) ? &quot;WinBar&quot; : &quot;WinBarNC&quot;;</a>
<a name="ln1068">  } else if (stc_hl_id &gt; 0) {</a>
<a name="ln1069">    return syn_id2name(stc_hl_id);</a>
<a name="ln1070">  } else {</a>
<a name="ln1071">    return (wp == curwin) ? &quot;StatusLine&quot; : &quot;StatusLineNC&quot;;</a>
<a name="ln1072">  }</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">int find_sid(uint64_t channel_id)</a>
<a name="ln1076">{</a>
<a name="ln1077">  switch (channel_id) {</a>
<a name="ln1078">  case VIML_INTERNAL_CALL:</a>
<a name="ln1079">  // TODO(autocmd): Figure out what this should be</a>
<a name="ln1080">  // return SID_API_CLIENT;</a>
<a name="ln1081">  case LUA_INTERNAL_CALL:</a>
<a name="ln1082">    return SID_LUA;</a>
<a name="ln1083">  default:</a>
<a name="ln1084">    return SID_API_CLIENT;</a>
<a name="ln1085">  }</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">/// Sets sctx for API calls.</a>
<a name="ln1089">///</a>
<a name="ln1090">/// @param channel_id     api clients id. Used to determine if it's a internal</a>
<a name="ln1091">///                       call or a rpc call.</a>
<a name="ln1092">/// @return returns       previous value of current_sctx. To be used</a>
<a name="ln1093">///                       to be used for restoring sctx to previous state.</a>
<a name="ln1094">sctx_T api_set_sctx(uint64_t channel_id)</a>
<a name="ln1095">{</a>
<a name="ln1096">  sctx_T old_current_sctx = current_sctx;</a>
<a name="ln1097">  if (channel_id != VIML_INTERNAL_CALL) {</a>
<a name="ln1098">    current_sctx.sc_sid =</a>
<a name="ln1099">      channel_id == LUA_INTERNAL_CALL ? SID_LUA : SID_API_CLIENT;</a>
<a name="ln1100">    current_sctx.sc_lnum = 0;</a>
<a name="ln1101">  }</a>
<a name="ln1102">  return old_current_sctx;</a>
<a name="ln1103">}</a>
</code></pre>
<div class="balloon" rel="804"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>