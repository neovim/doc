<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>channel.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;msgpack/object.h&gt;</a>
<a name="ln7">#include &lt;msgpack/pack.h&gt;</a>
<a name="ln8">#include &lt;msgpack/sbuffer.h&gt;</a>
<a name="ln9">#include &lt;msgpack/unpack.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;uv.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;klib/kvec.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln18">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/ui.h&quot;</a>
<a name="ln20">#include &quot;nvim/channel.h&quot;</a>
<a name="ln21">#include &quot;nvim/event/defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln23">#include &quot;nvim/event/process.h&quot;</a>
<a name="ln24">#include &quot;nvim/event/rstream.h&quot;</a>
<a name="ln25">#include &quot;nvim/event/stream.h&quot;</a>
<a name="ln26">#include &quot;nvim/event/wstream.h&quot;</a>
<a name="ln27">#include &quot;nvim/log.h&quot;</a>
<a name="ln28">#include &quot;nvim/main.h&quot;</a>
<a name="ln29">#include &quot;nvim/map.h&quot;</a>
<a name="ln30">#include &quot;nvim/memory.h&quot;</a>
<a name="ln31">#include &quot;nvim/message.h&quot;</a>
<a name="ln32">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln33">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln34">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln35">#include &quot;nvim/msgpack_rpc/unpacker.h&quot;</a>
<a name="ln36">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/rbuffer.h&quot;</a>
<a name="ln38">#include &quot;nvim/types.h&quot;</a>
<a name="ln39">#include &quot;nvim/ui.h&quot;</a>
<a name="ln40">#include &quot;nvim/ui_client.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#ifdef NVIM_LOG_DEBUG</a>
<a name="ln43"># define REQ &quot;[request]  &quot;</a>
<a name="ln44"># define RES &quot;[response] &quot;</a>
<a name="ln45"># define NOT &quot;[notify]   &quot;</a>
<a name="ln46"># define ERR &quot;[error]    &quot;</a>
<a name="ln47"> </a>
<a name="ln48">// Cannot define array with negative offsets, so this one is needed to be added</a>
<a name="ln49">// to MSGPACK_UNPACK_\* values.</a>
<a name="ln50"># define MUR_OFF 2</a>
<a name="ln51"> </a>
<a name="ln52">static const char *const msgpack_error_messages[] = {</a>
<a name="ln53">  [MSGPACK_UNPACK_EXTRA_BYTES + MUR_OFF] = &quot;extra bytes found&quot;,</a>
<a name="ln54">  [MSGPACK_UNPACK_CONTINUE + MUR_OFF] = &quot;incomplete string&quot;,</a>
<a name="ln55">  [MSGPACK_UNPACK_PARSE_ERROR + MUR_OFF] = &quot;parse error&quot;,</a>
<a name="ln56">  [MSGPACK_UNPACK_NOMEM_ERROR + MUR_OFF] = &quot;not enough memory&quot;,</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">static void log_close(FILE *f)</a>
<a name="ln60">{</a>
<a name="ln61">  fputc('\n', f);</a>
<a name="ln62">  fflush(f);</a>
<a name="ln63">  fclose(f);</a>
<a name="ln64">  log_unlock();</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">static void log_server_msg(uint64_t channel_id, msgpack_sbuffer *packed)</a>
<a name="ln68">{</a>
<a name="ln69">  msgpack_unpacked unpacked;</a>
<a name="ln70">  msgpack_unpacked_init(&amp;unpacked);</a>
<a name="ln71">  DLOGN(&quot;RPC -&gt;ch %&quot; PRIu64 &quot;: &quot;, channel_id);</a>
<a name="ln72">  const msgpack_unpack_return result =</a>
<a name="ln73">    msgpack_unpack_next(&amp;unpacked, packed-&gt;data, packed-&gt;size, NULL);</a>
<a name="ln74">  switch (result) {</a>
<a name="ln75">  case MSGPACK_UNPACK_SUCCESS: {</a>
<a name="ln76">    uint64_t type = unpacked.data.via.array.ptr[0].via.u64;</a>
<a name="ln77">    log_lock();</a>
<a name="ln78">    FILE *f = open_log_file();</a>
<a name="ln79">    fprintf(f, type ? (type == 1 ? RES : NOT) : REQ);</a>
<a name="ln80">    msgpack_object_print(f, unpacked.data);</a>
<a name="ln81">    log_close(f);</a>
<a name="ln82">    msgpack_unpacked_destroy(&amp;unpacked);</a>
<a name="ln83">    break;</a>
<a name="ln84">  }</a>
<a name="ln85">  case MSGPACK_UNPACK_EXTRA_BYTES:</a>
<a name="ln86">  case MSGPACK_UNPACK_CONTINUE:</a>
<a name="ln87">  case MSGPACK_UNPACK_PARSE_ERROR:</a>
<a name="ln88">  case MSGPACK_UNPACK_NOMEM_ERROR: {</a>
<a name="ln89">    log_lock();</a>
<a name="ln90">    FILE *f = open_log_file();</a>
<a name="ln91">    fprintf(f, ERR);</a>
<a name="ln92">    fprintf(f, &quot;%s&quot;, msgpack_error_messages[result + MUR_OFF]);</a>
<a name="ln93">    log_close(f);</a>
<a name="ln94">    break;</a>
<a name="ln95">  }</a>
<a name="ln96">  }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">static void log_client_msg(uint64_t channel_id, bool is_request, const char *name)</a>
<a name="ln100">{</a>
<a name="ln101">  DLOGN(&quot;RPC &lt;-ch %&quot; PRIu64 &quot;: &quot;, channel_id);</a>
<a name="ln102">  log_lock();</a>
<a name="ln103">  FILE *f = open_log_file();</a>
<a name="ln104">  fprintf(f, &quot;%s: %s&quot;, is_request ? REQ : RES, name);</a>
<a name="ln105">  log_close(f);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">#else</a>
<a name="ln109"># define log_client_msg(...)</a>
<a name="ln110"># define log_server_msg(...)</a>
<a name="ln111">#endif</a>
<a name="ln112"> </a>
<a name="ln113">static Set(cstr_t) event_strings = SET_INIT;</a>
<a name="ln114">static msgpack_sbuffer out_buffer;</a>
<a name="ln115"> </a>
<a name="ln116">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln117"># include &quot;msgpack_rpc/channel.c.generated.h&quot;</a>
<a name="ln118">#endif</a>
<a name="ln119"> </a>
<a name="ln120">void rpc_init(void)</a>
<a name="ln121">{</a>
<a name="ln122">  ch_before_blocking_events = multiqueue_new_child(main_loop.events);</a>
<a name="ln123">  msgpack_sbuffer_init(&amp;out_buffer);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void rpc_start(Channel *channel)</a>
<a name="ln127">{</a>
<a name="ln128">  channel_incref(channel);</a>
<a name="ln129">  channel-&gt;is_rpc = true;</a>
<a name="ln130">  RpcState *rpc = &amp;channel-&gt;rpc;</a>
<a name="ln131">  rpc-&gt;closed = false;</a>
<a name="ln132">  rpc-&gt;unpacker = xcalloc(1, sizeof *rpc-&gt;unpacker);</a>
<a name="ln133">  unpacker_init(rpc-&gt;unpacker);</a>
<a name="ln134">  rpc-&gt;next_request_id = 1;</a>
<a name="ln135">  rpc-&gt;info = (Dictionary)ARRAY_DICT_INIT;</a>
<a name="ln136">  kv_init(rpc-&gt;call_stack);</a>
<a name="ln137"> </a>
<a name="ln138">  if (channel-&gt;streamtype != kChannelStreamInternal) {</a>
<a name="ln139">    Stream *out = channel_outstream(channel);</a>
<a name="ln140">#ifdef NVIM_LOG_DEBUG</a>
<a name="ln141">    Stream *in = channel_instream(channel);</a>
<a name="ln142">    DLOG(&quot;rpc ch %&quot; PRIu64 &quot; in-stream=%p out-stream=%p&quot;, channel-&gt;id,</a>
<a name="ln143">         (void *)in, (void *)out);</a>
<a name="ln144">#endif</a>
<a name="ln145"> </a>
<a name="ln146">    rstream_start(out, receive_msgpack, channel);</a>
<a name="ln147">  }</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static Channel *find_rpc_channel(uint64_t id)</a>
<a name="ln151">{</a>
<a name="ln152">  Channel *chan = find_channel(id);</a>
<a name="ln153">  if (!chan || !chan-&gt;is_rpc || chan-&gt;rpc.closed) {</a>
<a name="ln154">    return NULL;</a>
<a name="ln155">  }</a>
<a name="ln156">  return chan;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">/// Publishes an event to a channel.</a>
<a name="ln160">///</a>
<a name="ln161">/// @param id Channel id. 0 means &quot;broadcast to all subscribed channels&quot;</a>
<a name="ln162">/// @param name Event name (application-defined)</a>
<a name="ln163">/// @param args Array of event arguments</a>
<a name="ln164">/// @return True if the event was sent successfully, false otherwise.</a>
<a name="ln165">bool rpc_send_event(uint64_t id, const char *name, Array args)</a>
<a name="ln166">{</a>
<a name="ln167">  Channel *channel = NULL;</a>
<a name="ln168"> </a>
<a name="ln169">  if (id &amp;&amp; (!(channel = find_rpc_channel(id)))) {</a>
<a name="ln170">    return false;</a>
<a name="ln171">  }</a>
<a name="ln172"> </a>
<a name="ln173">  if (channel) {</a>
<a name="ln174">    send_event(channel, name, args);</a>
<a name="ln175">  } else {</a>
<a name="ln176">    broadcast_event(name, args);</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  return true;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">/// Sends a method call to a channel</a>
<a name="ln183">///</a>
<a name="ln184">/// @param id The channel id</a>
<a name="ln185">/// @param method_name The method name, an arbitrary string</a>
<a name="ln186">/// @param args Array with method arguments</a>
<a name="ln187">/// @param[out] error True if the return value is an error</a>
<a name="ln188">/// @return Whatever the remote method returned</a>
<a name="ln189">Object rpc_send_call(uint64_t id, const char *method_name, Array args, ArenaMem *result_mem,</a>
<a name="ln190">                     Error *err)</a>
<a name="ln191">{</a>
<a name="ln192">  Channel *channel = NULL;</a>
<a name="ln193"> </a>
<a name="ln194">  if (!(channel = find_rpc_channel(id))) {</a>
<a name="ln195">    api_set_error(err, kErrorTypeException, &quot;Invalid channel: %&quot; PRIu64, id);</a>
<a name="ln196">    api_free_array(args);</a>
<a name="ln197">    return NIL;</a>
<a name="ln198">  }</a>
<a name="ln199"> </a>
<a name="ln200">  channel_incref(channel);</a>
<a name="ln201">  RpcState *rpc = &amp;channel-&gt;rpc;</a>
<a name="ln202">  uint32_t request_id = rpc-&gt;next_request_id++;</a>
<a name="ln203">  // Send the msgpack-rpc request</a>
<a name="ln204">  send_request(channel, request_id, method_name, args);</a>
<a name="ln205">  api_free_array(args);</a>
<a name="ln206"> </a>
<a name="ln207">  // Push the frame</a>
<a name="ln208">  ChannelCallFrame frame = { request_id, false, false, NIL, NULL };</a>
<a name="ln209">  kv_push(rpc-&gt;call_stack, &amp;frame);</a>
<a name="ln210">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, channel-&gt;events, -1, frame.returned || rpc-&gt;closed);</a>
<a name="ln211">  (void)kv_pop(rpc-&gt;call_stack);</a>
<a name="ln212"> </a>
<a name="ln213">  if (rpc-&gt;closed) {</a>
<a name="ln214">    api_set_error(err, kErrorTypeException, &quot;Invalid channel: %&quot; PRIu64, id);</a>
<a name="ln215">    channel_decref(channel);</a>
<a name="ln216">    return NIL;</a>
<a name="ln217">  }</a>
<a name="ln218"> </a>
<a name="ln219">  if (frame.errored) {</a>
<a name="ln220">    if (frame.result.type == kObjectTypeString) {</a>
<a name="ln221">      api_set_error(err, kErrorTypeException, &quot;%s&quot;,</a>
<a name="ln222">                    frame.result.data.string.data);</a>
<a name="ln223">    } else if (frame.result.type == kObjectTypeArray) {</a>
<a name="ln224">      // Should be an error in the form [type, message]</a>
<a name="ln225">      Array array = frame.result.data.array;</a>
<a name="ln226">      if (array.size == 2 &amp;&amp; array.items[0].type == kObjectTypeInteger</a>
<a name="ln227">          &amp;&amp; (array.items[0].data.integer == kErrorTypeException</a>
<a name="ln228">              || array.items[0].data.integer == kErrorTypeValidation)</a>
<a name="ln229">          &amp;&amp; array.items[1].type == kObjectTypeString) {</a>
<a name="ln230">        api_set_error(err, (ErrorType)array.items[0].data.integer, &quot;%s&quot;,</a>
<a name="ln231">                      array.items[1].data.string.data);</a>
<a name="ln232">      } else {</a>
<a name="ln233">        api_set_error(err, kErrorTypeException, &quot;%s&quot;, &quot;unknown error&quot;);</a>
<a name="ln234">      }</a>
<a name="ln235">    } else {</a>
<a name="ln236">      api_set_error(err, kErrorTypeException, &quot;%s&quot;, &quot;unknown error&quot;);</a>
<a name="ln237">    }</a>
<a name="ln238"> </a>
<a name="ln239">    // frame.result was allocated in an arena</a>
<a name="ln240">    arena_mem_free(frame.result_mem);</a>
<a name="ln241">    frame.result_mem = NULL;</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  channel_decref(channel);</a>
<a name="ln245"> </a>
<a name="ln246">  *result_mem = frame.result_mem;</a>
<a name="ln247"> </a>
<a name="ln248">  return frame.errored ? NIL : frame.result;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">/// Subscribes to event broadcasts</a>
<a name="ln252">///</a>
<a name="ln253">/// @param id The channel id</a>
<a name="ln254">/// @param event The event type string</a>
<a name="ln255">void rpc_subscribe(uint64_t id, char *event)</a>
<a name="ln256">{</a>
<a name="ln257">  Channel *channel;</a>
<a name="ln258"> </a>
<a name="ln259">  if (!(channel = find_rpc_channel(id))) {</a>
<a name="ln260">    abort();</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  const char **key_alloc = NULL;</a>
<a name="ln264">  if (set_put_ref(cstr_t, &amp;event_strings, event, &amp;key_alloc)) {</a>
<a name="ln265">    *key_alloc = xstrdup(event);</a>
<a name="ln266">  }</a>
<a name="ln267"> </a>
<a name="ln268">  set_put(cstr_t, channel-&gt;rpc.subscribed_events, *key_alloc);</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">/// Unsubscribes to event broadcasts</a>
<a name="ln272">///</a>
<a name="ln273">/// @param id The channel id</a>
<a name="ln274">/// @param event The event type string</a>
<a name="ln275">void rpc_unsubscribe(uint64_t id, char *event)</a>
<a name="ln276">{</a>
<a name="ln277">  Channel *channel;</a>
<a name="ln278"> </a>
<a name="ln279">  if (!(channel = find_rpc_channel(id))) {</a>
<a name="ln280">    abort();</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  unsubscribe(channel, event);</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static void receive_msgpack(Stream *stream, RBuffer *rbuf, size_t c, void *data, bool eof)</a>
<a name="ln287">{</a>
<a name="ln288">  Channel *channel = data;</a>
<a name="ln289">  channel_incref(channel);</a>
<a name="ln290"> </a>
<a name="ln291">  if (eof) {</a>
<a name="ln292">    channel_close(channel-&gt;id, kChannelPartRpc, NULL);</a>
<a name="ln293">    char buf[256];</a>
<a name="ln294">    snprintf(buf, sizeof(buf), &quot;ch %&quot; PRIu64 &quot; was closed by the client&quot;,</a>
<a name="ln295">             channel-&gt;id);</a>
<a name="ln296">    chan_close_with_error(channel, buf, LOGLVL_INF);</a>
<a name="ln297">    goto end;</a>
<a name="ln298">  }</a>
<a name="ln299"> </a>
<a name="ln300">  DLOG(&quot;ch %&quot; PRIu64 &quot;: parsing %zu bytes from msgpack Stream: %p&quot;,</a>
<a name="ln301">       channel-&gt;id, rbuffer_size(rbuf), (void *)stream);</a>
<a name="ln302"> </a>
<a name="ln303">  Unpacker *p = channel-&gt;rpc.unpacker;</a>
<a name="ln304">  size_t size = 0;</a>
<a name="ln305">  p-&gt;read_ptr = rbuffer_read_ptr(rbuf, &amp;size);</a>
<a name="ln306">  p-&gt;read_size = size;</a>
<a name="ln307">  parse_msgpack(channel);</a>
<a name="ln308">  size_t consumed = size - p-&gt;read_size;</a>
<a name="ln309">  rbuffer_consumed_compact(rbuf, consumed);</a>
<a name="ln310"> </a>
<a name="ln311">end:</a>
<a name="ln312">  channel_decref(channel);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">static ChannelCallFrame *find_call_frame(RpcState *rpc, uint32_t request_id)</a>
<a name="ln316">{</a>
<a name="ln317">  for (size_t i = 0; i &lt; kv_size(rpc-&gt;call_stack); i++) {</a>
<a name="ln318">    ChannelCallFrame *frame = kv_Z(rpc-&gt;call_stack, i);</a>
<a name="ln319">    if (frame-&gt;request_id == request_id) {</a>
<a name="ln320">      return frame;</a>
<a name="ln321">    }</a>
<a name="ln322">  }</a>
<a name="ln323">  return NULL;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">static void parse_msgpack(Channel *channel)</a>
<a name="ln327">{</a>
<a name="ln328">  Unpacker *p = channel-&gt;rpc.unpacker;</a>
<a name="ln329">  while (unpacker_advance(p)) {</a>
<a name="ln330">    if (p-&gt;type == kMessageTypeRedrawEvent) {</a>
<a name="ln331">      // When exiting, ui_client_stop() has already been called, so don't handle UI events.</a>
<a name="ln332">      if (ui_client_channel_id &amp;&amp; !exiting) {</a>
<a name="ln333">        if (p-&gt;grid_line_event) {</a>
<a name="ln334">          ui_client_event_raw_line(p-&gt;grid_line_event);</a>
<a name="ln335">        } else if (p-&gt;ui_handler.fn != NULL &amp;&amp; p-&gt;result.type == kObjectTypeArray) {</a>
<a name="ln336">          p-&gt;ui_handler.fn(p-&gt;result.data.array);</a>
<a name="ln337">        }</a>
<a name="ln338">      }</a>
<a name="ln339">      arena_mem_free(arena_finish(&amp;p-&gt;arena));</a>
<a name="ln340">    } else if (p-&gt;type == kMessageTypeResponse) {</a>
<a name="ln341">      ChannelCallFrame *frame = channel-&gt;rpc.client_type == kClientTypeMsgpackRpc</a>
<a name="ln342">        ? find_call_frame(&amp;channel-&gt;rpc, p-&gt;request_id)</a>
<a name="ln343">        : kv_last(channel-&gt;rpc.call_stack);</a>
<a name="ln344">      if (frame == NULL || p-&gt;request_id != frame-&gt;request_id) {</a>
<a name="ln345">        char buf[256];</a>
<a name="ln346">        snprintf(buf, sizeof(buf),</a>
<a name="ln347">                 &quot;ch %&quot; PRIu64 &quot; (type=%&quot; PRIu32 &quot;) returned a response with an unknown request &quot;</a>
<a name="ln348">                 &quot;id %&quot; PRIu32 &quot;. Ensure the client is properly synchronized&quot;,</a>
<a name="ln349">                 channel-&gt;id, (unsigned)channel-&gt;rpc.client_type, p-&gt;request_id);</a>
<a name="ln350">        chan_close_with_error(channel, buf, LOGLVL_ERR);</a>
<a name="ln351">      }</a>
<a name="ln352">      frame-&gt;returned = true;</a>
<a name="ln353">      frame-&gt;errored = (p-&gt;error.type != kObjectTypeNil);</a>
<a name="ln354"> </a>
<a name="ln355">      if (frame-&gt;errored) {</a>
<a name="ln356">        frame-&gt;result = p-&gt;error;</a>
<a name="ln357">        // TODO(bfredl): p-&gt;result should not even be decoded</a>
<a name="ln358">        // api_free_object(p-&gt;result);</a>
<a name="ln359">      } else {</a>
<a name="ln360">        frame-&gt;result = p-&gt;result;</a>
<a name="ln361">      }</a>
<a name="ln362">      frame-&gt;result_mem = arena_finish(&amp;p-&gt;arena);</a>
<a name="ln363">    } else {</a>
<a name="ln364">      log_client_msg(channel-&gt;id, p-&gt;type == kMessageTypeRequest, p-&gt;handler.name);</a>
<a name="ln365"> </a>
<a name="ln366">      Object res = p-&gt;result;</a>
<a name="ln367">      if (p-&gt;result.type != kObjectTypeArray) {</a>
<a name="ln368">        chan_close_with_error(channel, &quot;msgpack-rpc request args has to be an array&quot;, LOGLVL_ERR);</a>
<a name="ln369">        return;</a>
<a name="ln370">      }</a>
<a name="ln371">      Array arg = res.data.array;</a>
<a name="ln372">      handle_request(channel, p, arg);</a>
<a name="ln373">    }</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  if (unpacker_closed(p)) {</a>
<a name="ln377">    chan_close_with_error(channel, p-&gt;unpack_error.msg, LOGLVL_ERR);</a>
<a name="ln378">    api_clear_error(&amp;p-&gt;unpack_error);</a>
<a name="ln379">  }</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">/// Handles requests and notifications received on the channel.</a>
<a name="ln383">static void handle_request(Channel *channel, Unpacker *p, Array args)</a>
<a name="ln384">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln385">{</a>
<a name="ln386">  assert(p-&gt;type == kMessageTypeRequest || p-&gt;type == kMessageTypeNotification);</a>
<a name="ln387"> </a>
<a name="ln388">  if (!p-&gt;handler.fn) {</a>
<a name="ln389">    send_error(channel, p-&gt;handler, p-&gt;type, p-&gt;request_id, p-&gt;unpack_error.msg);</a>
<a name="ln390">    api_clear_error(&amp;p-&gt;unpack_error);</a>
<a name="ln391">    arena_mem_free(arena_finish(&amp;p-&gt;arena));</a>
<a name="ln392">    return;</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  RequestEvent *evdata = xmalloc(sizeof(RequestEvent));</a>
<a name="ln396">  evdata-&gt;type = p-&gt;type;</a>
<a name="ln397">  evdata-&gt;channel = channel;</a>
<a name="ln398">  evdata-&gt;handler = p-&gt;handler;</a>
<a name="ln399">  evdata-&gt;args = args;</a>
<a name="ln400">  evdata-&gt;used_mem = p-&gt;arena;</a>
<a name="ln401">  p-&gt;arena = (Arena)ARENA_EMPTY;</a>
<a name="ln402">  evdata-&gt;request_id = p-&gt;request_id;</a>
<a name="ln403">  channel_incref(channel);</a>
<a name="ln404">  if (p-&gt;handler.fast) {</a>
<a name="ln405">    bool is_get_mode = p-&gt;handler.fn == handle_nvim_get_mode;</a>
<a name="ln406"> </a>
<a name="ln407">    if (is_get_mode &amp;&amp; !input_blocking()) {</a>
<a name="ln408">      // Defer the event to a special queue used by os/input.c. #6247</a>
<a name="ln409">      multiqueue_put(ch_before_blocking_events, request_event, 1, evdata);</a>
<a name="ln410">    } else {</a>
<a name="ln411">      // Invoke immediately.</a>
<a name="ln412">      request_event((void **)&amp;evdata);</a>
<a name="ln413">    }</a>
<a name="ln414">  } else {</a>
<a name="ln415">    bool is_resize = p-&gt;handler.fn == handle_nvim_ui_try_resize;</a>
<a name="ln416">    if (is_resize) {</a>
<a name="ln417">      Event ev = event_create_oneshot(event_create(request_event, 1, evdata),</a>
<a name="ln418">                                      2);</a>
<a name="ln419">      multiqueue_put_event(channel-&gt;events, ev);</a>
<a name="ln420">      multiqueue_put_event(resize_events, ev);</a>
<a name="ln421">    } else {</a>
<a name="ln422">      multiqueue_put(channel-&gt;events, request_event, 1, evdata);</a>
<a name="ln423">      DLOG(&quot;RPC: scheduled %.*s&quot;, (int)p-&gt;method_name_len, p-&gt;handler.name);</a>
<a name="ln424">    }</a>
<a name="ln425">  }</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">/// Handles a message, depending on the type:</a>
<a name="ln429">///   - Request: invokes method and writes the response (or error).</a>
<a name="ln430">///   - Notification: invokes method (emits `nvim_error_event` on error).</a>
<a name="ln431">static void request_event(void **argv)</a>
<a name="ln432">{</a>
<a name="ln433">  RequestEvent *e = argv[0];</a>
<a name="ln434">  Channel *channel = e-&gt;channel;</a>
<a name="ln435">  MsgpackRpcRequestHandler handler = e-&gt;handler;</a>
<a name="ln436">  Error error = ERROR_INIT;</a>
<a name="ln437">  if (channel-&gt;rpc.closed) {</a>
<a name="ln438">    // channel was closed, abort any pending requests</a>
<a name="ln439">    goto free_ret;</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  Object result = handler.fn(channel-&gt;id, e-&gt;args, &amp;e-&gt;used_mem, &amp;error);</a>
<a name="ln443">  if (e-&gt;type == kMessageTypeRequest || ERROR_SET(&amp;error)) {</a>
<a name="ln444">    // Send the response.</a>
<a name="ln445">    msgpack_packer response;</a>
<a name="ln446">    msgpack_packer_init(&amp;response, &amp;out_buffer, msgpack_sbuffer_write);</a>
<a name="ln447">    channel_write(channel, serialize_response(channel-&gt;id,</a>
<a name="ln448">                                              e-&gt;handler,</a>
<a name="ln449">                                              e-&gt;type,</a>
<a name="ln450">                                              e-&gt;request_id,</a>
<a name="ln451">                                              &amp;error,</a>
<a name="ln452">                                              result,</a>
<a name="ln453">                                              &amp;out_buffer));</a>
<a name="ln454">  }</a>
<a name="ln455">  if (!handler.arena_return) {</a>
<a name="ln456">    api_free_object(result);</a>
<a name="ln457">  }</a>
<a name="ln458"> </a>
<a name="ln459">free_ret:</a>
<a name="ln460">  // e-&gt;args (and possibly result) are allocated in an arena</a>
<a name="ln461">  arena_mem_free(arena_finish(&amp;e-&gt;used_mem));</a>
<a name="ln462">  channel_decref(channel);</a>
<a name="ln463">  xfree(e);</a>
<a name="ln464">  api_clear_error(&amp;error);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">bool rpc_write_raw(uint64_t id, WBuffer *buffer)</a>
<a name="ln468">{</a>
<a name="ln469">  Channel *channel = find_rpc_channel(id);</a>
<a name="ln470">  if (!channel) {</a>
<a name="ln471">    wstream_release_wbuffer(buffer);</a>
<a name="ln472">    return false;</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475">  return channel_write(channel, buffer);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">static bool channel_write(Channel *channel, WBuffer *buffer)</a>
<a name="ln479">{</a>
<a name="ln480">  bool success;</a>
<a name="ln481"> </a>
<a name="ln482">  if (channel-&gt;rpc.closed) {</a>
<a name="ln483">    wstream_release_wbuffer(buffer);</a>
<a name="ln484">    return false;</a>
<a name="ln485">  }</a>
<a name="ln486"> </a>
<a name="ln487">  if (channel-&gt;streamtype == kChannelStreamInternal) {</a>
<a name="ln488">    channel_incref(channel);</a>
<a name="ln489">    CREATE_EVENT(channel-&gt;events, internal_read_event, 2, channel, buffer);</a>
<a name="ln490">    success = true;</a>
<a name="ln491">  } else {</a>
<a name="ln492">    Stream *in = channel_instream(channel);</a>
<a name="ln493">    success = wstream_write(in, buffer);</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  if (!success) {</a>
<a name="ln497">    // If the write failed for any reason, close the channel</a>
<a name="ln498">    char buf[256];</a>
<a name="ln499">    snprintf(buf,</a>
<a name="ln500">             sizeof(buf),</a>
<a name="ln501">             &quot;ch %&quot; PRIu64 &quot;: stream write failed. &quot;</a>
<a name="ln502">             &quot;RPC canceled; closing channel&quot;,</a>
<a name="ln503">             channel-&gt;id);</a>
<a name="ln504">    chan_close_with_error(channel, buf, LOGLVL_ERR);</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  return success;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">static void internal_read_event(void **argv)</a>
<a name="ln511">{</a>
<a name="ln512">  Channel *channel = argv[0];</a>
<a name="ln513">  WBuffer *buffer = argv[1];</a>
<a name="ln514">  Unpacker *p = channel-&gt;rpc.unpacker;</a>
<a name="ln515"> </a>
<a name="ln516">  p-&gt;read_ptr = buffer-&gt;data;</a>
<a name="ln517">  p-&gt;read_size = buffer-&gt;size;</a>
<a name="ln518">  parse_msgpack(channel);</a>
<a name="ln519"> </a>
<a name="ln520">  if (p-&gt;read_size) {</a>
<a name="ln521">    // This should not happen, as WBuffer is one single serialized message.</a>
<a name="ln522">    if (!channel-&gt;rpc.closed) {</a>
<a name="ln523">      chan_close_with_error(channel, &quot;internal channel: internal error&quot;, LOGLVL_ERR);</a>
<a name="ln524">    }</a>
<a name="ln525">  }</a>
<a name="ln526"> </a>
<a name="ln527">  channel_decref(channel);</a>
<a name="ln528">  wstream_release_wbuffer(buffer);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">static void send_error(Channel *chan, MsgpackRpcRequestHandler handler, MessageType type,</a>
<a name="ln532">                       uint32_t id, char *err)</a>
<a name="ln533">{</a>
<a name="ln534">  Error e = ERROR_INIT;</a>
<a name="ln535">  api_set_error(&amp;e, kErrorTypeException, &quot;%s&quot;, err);</a>
<a name="ln536">  channel_write(chan, serialize_response(chan-&gt;id,</a>
<a name="ln537">                                         handler,</a>
<a name="ln538">                                         type,</a>
<a name="ln539">                                         id,</a>
<a name="ln540">                                         &amp;e,</a>
<a name="ln541">                                         NIL,</a>
<a name="ln542">                                         &amp;out_buffer));</a>
<a name="ln543">  api_clear_error(&amp;e);</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">static void send_request(Channel *channel, uint32_t id, const char *name, Array args)</a>
<a name="ln547">{</a>
<a name="ln548">  const String method = cstr_as_string((char *)name);</a>
<a name="ln549">  channel_write(channel, serialize_request(channel-&gt;id,</a>
<a name="ln550">                                           id,</a>
<a name="ln551">                                           method,</a>
<a name="ln552">                                           args,</a>
<a name="ln553">                                           &amp;out_buffer,</a>
<a name="ln554">                                           1));</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">static void send_event(Channel *channel, const char *name, Array args)</a>
<a name="ln558">{</a>
<a name="ln559">  const String method = cstr_as_string((char *)name);</a>
<a name="ln560">  channel_write(channel, serialize_request(channel-&gt;id,</a>
<a name="ln561">                                           0,</a>
<a name="ln562">                                           method,</a>
<a name="ln563">                                           args,</a>
<a name="ln564">                                           &amp;out_buffer,</a>
<a name="ln565">                                           1));</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">static void broadcast_event(const char *name, Array args)</a>
<a name="ln569">{</a>
<a name="ln570">  kvec_t(Channel *) subscribed = KV_INITIAL_VALUE;</a>
<a name="ln571">  Channel *channel;</a>
<a name="ln572"> </a>
<a name="ln573">  map_foreach_value(&amp;channels, channel, {</a>
<a name="ln574">    if (channel-&gt;is_rpc</a>
<a name="ln575">        &amp;&amp; set_has(cstr_t, channel-&gt;rpc.subscribed_events, name)) {</a>
<a name="ln576">      kv_push(subscribed, channel);</a>
<a name="ln577">    }</a>
<a name="ln578">  });</a>
<a name="ln579"> </a>
<a name="ln580">  if (!kv_size(subscribed)) {</a>
<a name="ln581">    goto end;</a>
<a name="ln582">  }</a>
<a name="ln583"> </a>
<a name="ln584">  const String method = cstr_as_string((char *)name);</a>
<a name="ln585">  WBuffer *buffer = serialize_request(0,</a>
<a name="ln586">                                      0,</a>
<a name="ln587">                                      method,</a>
<a name="ln588">                                      args,</a>
<a name="ln589">                                      &amp;out_buffer,</a>
<a name="ln590">                                      kv_size(subscribed));</a>
<a name="ln591"> </a>
<a name="ln592">  for (size_t i = 0; i &lt; kv_size(subscribed); i++) {</a>
<a name="ln593">    Channel *c = kv_A(subscribed, i);</a>
<a name="ln594">    channel_write(c, buffer);</a>
<a name="ln595">  }</a>
<a name="ln596"> </a>
<a name="ln597">end:</a>
<a name="ln598">  kv_destroy(subscribed);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">static void unsubscribe(Channel *channel, char *event)</a>
<a name="ln602">{</a>
<a name="ln603">  if (!set_has(cstr_t, &amp;event_strings, event)) {</a>
<a name="ln604">    WLOG(&quot;RPC: ch %&quot; PRIu64 &quot;: tried to unsubscribe unknown event '%s'&quot;,</a>
<a name="ln605">         channel-&gt;id, event);</a>
<a name="ln606">    return;</a>
<a name="ln607">  }</a>
<a name="ln608">  set_del(cstr_t, channel-&gt;rpc.subscribed_events, event);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/// Mark rpc state as closed, and release its reference to the channel.</a>
<a name="ln612">/// Don't call this directly, call channel_close(id, kChannelPartRpc, &amp;error)</a>
<a name="ln613">void rpc_close(Channel *channel)</a>
<a name="ln614">{</a>
<a name="ln615">  if (channel-&gt;rpc.closed) {</a>
<a name="ln616">    return;</a>
<a name="ln617">  }</a>
<a name="ln618"> </a>
<a name="ln619">  channel-&gt;rpc.closed = true;</a>
<a name="ln620">  channel_decref(channel);</a>
<a name="ln621"> </a>
<a name="ln622">  if (channel-&gt;streamtype == kChannelStreamStdio</a>
<a name="ln623">      || (channel-&gt;id == ui_client_channel_id &amp;&amp; channel-&gt;streamtype != kChannelStreamProc)) {</a>
<a name="ln624">    if (channel-&gt;streamtype == kChannelStreamStdio) {</a>
<a name="ln625">      // Avoid hanging when there are no other UIs and a prompt is triggered on exit.</a>
<a name="ln626">      remote_ui_disconnect(channel-&gt;id);</a>
<a name="ln627">    }</a>
<a name="ln628">    exit_from_channel(0);</a>
<a name="ln629">  }</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">void rpc_free(Channel *channel)</a>
<a name="ln633">{</a>
<a name="ln634">  remote_ui_disconnect(channel-&gt;id);</a>
<a name="ln635">  unpacker_teardown(channel-&gt;rpc.unpacker);</a>
<a name="ln636">  xfree(channel-&gt;rpc.unpacker);</a>
<a name="ln637"> </a>
<a name="ln638">  set_destroy(cstr_t, channel-&gt;rpc.subscribed_events);</a>
<a name="ln639">  kv_destroy(channel-&gt;rpc.call_stack);</a>
<a name="ln640">  api_free_dictionary(channel-&gt;rpc.info);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">static void chan_close_with_error(Channel *channel, char *msg, int loglevel)</a>
<a name="ln644">{</a>
<a name="ln645">  LOG(loglevel, &quot;RPC: %s&quot;, msg);</a>
<a name="ln646">  for (size_t i = 0; i &lt; kv_size(channel-&gt;rpc.call_stack); i++) {</a>
<a name="ln647">    ChannelCallFrame *frame = kv_A(channel-&gt;rpc.call_stack, i);</a>
<a name="ln648">    frame-&gt;returned = true;</a>
<a name="ln649">    frame-&gt;errored = true;</a>
<a name="ln650">    frame-&gt;result = CSTR_TO_OBJ(msg);</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  channel_close(channel-&gt;id, kChannelPartRpc, NULL);</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">static WBuffer *serialize_request(uint64_t channel_id, uint32_t request_id, const String method,</a>
<a name="ln657">                                  Array args, msgpack_sbuffer *sbuffer, size_t refcount)</a>
<a name="ln658">{</a>
<a name="ln659">  msgpack_packer pac;</a>
<a name="ln660">  msgpack_packer_init(&amp;pac, sbuffer, msgpack_sbuffer_write);</a>
<a name="ln661">  msgpack_rpc_serialize_request(request_id, method, args, &amp;pac);</a>
<a name="ln662">  log_server_msg(channel_id, sbuffer);</a>
<a name="ln663">  WBuffer *rv = wstream_new_buffer(xmemdup(sbuffer-&gt;data, sbuffer-&gt;size),</a>
<a name="ln664">                                   sbuffer-&gt;size,</a>
<a name="ln665">                                   refcount,</a>
<a name="ln666">                                   xfree);</a>
<a name="ln667">  msgpack_sbuffer_clear(sbuffer);</a>
<a name="ln668">  return rv;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">static WBuffer *serialize_response(uint64_t channel_id, MsgpackRpcRequestHandler handler,</a>
<a name="ln672">                                   MessageType type, uint32_t response_id, Error *err, Object arg,</a>
<a name="ln673">                                   msgpack_sbuffer *sbuffer)</a>
<a name="ln674">{</a>
<a name="ln675">  msgpack_packer pac;</a>
<a name="ln676">  msgpack_packer_init(&amp;pac, sbuffer, msgpack_sbuffer_write);</a>
<a name="ln677">  if (ERROR_SET(err) &amp;&amp; type == kMessageTypeNotification) {</a>
<a name="ln678">    if (handler.fn == handle_nvim_paste) {</a>
<a name="ln679">      // TODO(bfredl): this is pretty much ad-hoc. maybe TUI and UI:s should be</a>
<a name="ln680">      // allowed to ask nvim to just scream directly in the users face</a>
<a name="ln681">      // instead of sending nvim_error_event, in general.</a>
<a name="ln682">      semsg(&quot;paste: %s&quot;, err-&gt;msg);</a>
<a name="ln683">      api_clear_error(err);</a>
<a name="ln684">    } else {</a>
<a name="ln685">      Array args = ARRAY_DICT_INIT;</a>
<a name="ln686">      ADD(args, INTEGER_OBJ(err-&gt;type));</a>
<a name="ln687">      ADD(args, CSTR_TO_OBJ(err-&gt;msg));</a>
<a name="ln688">      msgpack_rpc_serialize_request(0, cstr_as_string(&quot;nvim_error_event&quot;),</a>
<a name="ln689">                                    args, &amp;pac);</a>
<a name="ln690">      api_free_array(args);</a>
<a name="ln691">    }</a>
<a name="ln692">  } else {</a>
<a name="ln693">    msgpack_rpc_serialize_response(response_id, err, arg, &amp;pac);</a>
<a name="ln694">  }</a>
<a name="ln695">  log_server_msg(channel_id, sbuffer);</a>
<a name="ln696">  WBuffer *rv = wstream_new_buffer(xmemdup(sbuffer-&gt;data, sbuffer-&gt;size),</a>
<a name="ln697">                                   sbuffer-&gt;size,</a>
<a name="ln698">                                   1,  // responses only go though 1 channel</a>
<a name="ln699">                                   xfree);</a>
<a name="ln700">  msgpack_sbuffer_clear(sbuffer);</a>
<a name="ln701">  return rv;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">void rpc_set_client_info(uint64_t id, Dictionary info)</a>
<a name="ln705">{</a>
<a name="ln706">  Channel *chan = find_rpc_channel(id);</a>
<a name="ln707">  if (!chan) {</a>
<a name="ln708">    abort();</a>
<a name="ln709">  }</a>
<a name="ln710"> </a>
<a name="ln711">  api_free_dictionary(chan-&gt;rpc.info);</a>
<a name="ln712">  chan-&gt;rpc.info = info;</a>
<a name="ln713"> </a>
<a name="ln714">  // Parse &quot;type&quot; on &quot;info&quot; and set &quot;client_type&quot;</a>
<a name="ln715">  const char *type = get_client_info(chan, &quot;type&quot;);</a>
<a name="ln716">  if (type == NULL || strequal(type, &quot;remote&quot;)) {</a>
<a name="ln717">    chan-&gt;rpc.client_type = kClientTypeRemote;</a>
<a name="ln718">  } else if (strequal(type, &quot;msgpack-rpc&quot;)) {</a>
<a name="ln719">    chan-&gt;rpc.client_type = kClientTypeMsgpackRpc;</a>
<a name="ln720">  } else if (strequal(type, &quot;ui&quot;)) {</a>
<a name="ln721">    chan-&gt;rpc.client_type = kClientTypeUi;</a>
<a name="ln722">  } else if (strequal(type, &quot;embedder&quot;)) {</a>
<a name="ln723">    chan-&gt;rpc.client_type = kClientTypeEmbedder;</a>
<a name="ln724">  } else if (strequal(type, &quot;host&quot;)) {</a>
<a name="ln725">    chan-&gt;rpc.client_type = kClientTypeHost;</a>
<a name="ln726">  } else if (strequal(type, &quot;plugin&quot;)) {</a>
<a name="ln727">    chan-&gt;rpc.client_type = kClientTypePlugin;</a>
<a name="ln728">  } else {</a>
<a name="ln729">    chan-&gt;rpc.client_type = kClientTypeUnknown;</a>
<a name="ln730">  }</a>
<a name="ln731"> </a>
<a name="ln732">  channel_info_changed(chan, false);</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">Dictionary rpc_client_info(Channel *chan)</a>
<a name="ln736">{</a>
<a name="ln737">  return copy_dictionary(chan-&gt;rpc.info, NULL);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">const char *get_client_info(Channel *chan, const char *key)</a>
<a name="ln741">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln742">{</a>
<a name="ln743">  if (!chan-&gt;is_rpc) {</a>
<a name="ln744">    return NULL;</a>
<a name="ln745">  }</a>
<a name="ln746">  Dictionary info = chan-&gt;rpc.info;</a>
<a name="ln747">  for (size_t i = 0; i &lt; info.size; i++) {</a>
<a name="ln748">    if (strequal(key, info.items[i].key.data)</a>
<a name="ln749">        &amp;&amp; info.items[i].value.type == kObjectTypeString) {</a>
<a name="ln750">      return info.items[i].value.data.string.data;</a>
<a name="ln751">    }</a>
<a name="ln752">  }</a>
<a name="ln753"> </a>
<a name="ln754">  return NULL;</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">void rpc_free_all_mem(void)</a>
<a name="ln758">{</a>
<a name="ln759">  cstr_t key;</a>
<a name="ln760">  set_foreach(&amp;event_strings, key, {</a>
<a name="ln761">    xfree((void *)key);</a>
<a name="ln762">  });</a>
<a name="ln763">  set_destroy(cstr_t, &amp;event_strings);</a>
<a name="ln764">}</a>
</code></pre>
<div class="balloon" rel="352"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1004/" target="_blank">V1004</a> The 'frame' pointer was used unsafely after it was verified against nullptr. Check lines: 344, 352.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>