<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_cmds.c: some functions for command line commands</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;float.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;math.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;stddef.h&gt;</a>
<a name="ln13">#include &lt;stdio.h&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;time.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;auto/config.h&quot;</a>
<a name="ln19">#include &quot;klib/kvec.h&quot;</a>
<a name="ln20">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln21">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln22">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln24">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln25">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln26">#include &quot;nvim/bufwrite.h&quot;</a>
<a name="ln27">#include &quot;nvim/change.h&quot;</a>
<a name="ln28">#include &quot;nvim/channel.h&quot;</a>
<a name="ln29">#include &quot;nvim/charset.h&quot;</a>
<a name="ln30">#include &quot;nvim/cmdhist.h&quot;</a>
<a name="ln31">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln32">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln33">#include &quot;nvim/diff.h&quot;</a>
<a name="ln34">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln35">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln36">#include &quot;nvim/edit.h&quot;</a>
<a name="ln37">#include &quot;nvim/eval.h&quot;</a>
<a name="ln38">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln39">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln40">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln41">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln43">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln45">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln46">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln47">#include &quot;nvim/fold.h&quot;</a>
<a name="ln48">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln49">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln50">#include &quot;nvim/globals.h&quot;</a>
<a name="ln51">#include &quot;nvim/grid_defs.h&quot;</a>
<a name="ln52">#include &quot;nvim/help.h&quot;</a>
<a name="ln53">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln54">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln55">#include &quot;nvim/indent.h&quot;</a>
<a name="ln56">#include &quot;nvim/input.h&quot;</a>
<a name="ln57">#include &quot;nvim/macros.h&quot;</a>
<a name="ln58">#include &quot;nvim/main.h&quot;</a>
<a name="ln59">#include &quot;nvim/mark.h&quot;</a>
<a name="ln60">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln61">#include &quot;nvim/memline.h&quot;</a>
<a name="ln62">#include &quot;nvim/memory.h&quot;</a>
<a name="ln63">#include &quot;nvim/message.h&quot;</a>
<a name="ln64">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln65">#include &quot;nvim/move.h&quot;</a>
<a name="ln66">#include &quot;nvim/normal.h&quot;</a>
<a name="ln67">#include &quot;nvim/ops.h&quot;</a>
<a name="ln68">#include &quot;nvim/option.h&quot;</a>
<a name="ln69">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln70">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln71">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln72">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln73">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln74">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln75">#include &quot;nvim/path.h&quot;</a>
<a name="ln76">#include &quot;nvim/plines.h&quot;</a>
<a name="ln77">#include &quot;nvim/profile.h&quot;</a>
<a name="ln78">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln79">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln80">#include &quot;nvim/search.h&quot;</a>
<a name="ln81">#include &quot;nvim/spell.h&quot;</a>
<a name="ln82">#include &quot;nvim/strings.h&quot;</a>
<a name="ln83">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln84">#include &quot;nvim/types.h&quot;</a>
<a name="ln85">#include &quot;nvim/ui.h&quot;</a>
<a name="ln86">#include &quot;nvim/undo.h&quot;</a>
<a name="ln87">#include &quot;nvim/vim.h&quot;</a>
<a name="ln88">#include &quot;nvim/window.h&quot;</a>
<a name="ln89"> </a>
<a name="ln90">/// Case matching style to use for :substitute</a>
<a name="ln91">typedef enum {</a>
<a name="ln92">  kSubHonorOptions = 0,  ///&lt; Honor the user's 'ignorecase'/'smartcase' options</a>
<a name="ln93">  kSubIgnoreCase,        ///&lt; Ignore case of the search</a>
<a name="ln94">  kSubMatchCase,         ///&lt; Match case of the search</a>
<a name="ln95">} SubIgnoreType;</a>
<a name="ln96"> </a>
<a name="ln97">/// Flags kept between calls to :substitute.</a>
<a name="ln98">typedef struct {</a>
<a name="ln99">  bool do_all;          ///&lt; do multiple substitutions per line</a>
<a name="ln100">  bool do_ask;          ///&lt; ask for confirmation</a>
<a name="ln101">  bool do_count;        ///&lt; count only</a>
<a name="ln102">  bool do_error;        ///&lt; if false, ignore errors</a>
<a name="ln103">  bool do_print;        ///&lt; print last line with subs</a>
<a name="ln104">  bool do_list;         ///&lt; list last line with subs</a>
<a name="ln105">  bool do_number;       ///&lt; list last line with line nr</a>
<a name="ln106">  SubIgnoreType do_ic;  ///&lt; ignore case flag</a>
<a name="ln107">} subflags_T;</a>
<a name="ln108"> </a>
<a name="ln109">/// Partial result of a substitution during :substitute.</a>
<a name="ln110">/// Numbers refer to the buffer _after_ substitution</a>
<a name="ln111">typedef struct {</a>
<a name="ln112">  lpos_T start;  // start of the match</a>
<a name="ln113">  lpos_T end;    // end of the match</a>
<a name="ln114">  linenr_T pre_match;  // where to begin showing lines before the match</a>
<a name="ln115">} SubResult;</a>
<a name="ln116"> </a>
<a name="ln117">// Collected results of a substitution for showing them in</a>
<a name="ln118">// the preview window</a>
<a name="ln119">typedef struct {</a>
<a name="ln120">  kvec_t(SubResult) subresults;</a>
<a name="ln121">  linenr_T lines_needed;  // lines needed in the preview window</a>
<a name="ln122">} PreviewLines;</a>
<a name="ln123"> </a>
<a name="ln124">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln125"># include &quot;ex_cmds.c.generated.h&quot;</a>
<a name="ln126">#endif</a>
<a name="ln127"> </a>
<a name="ln128">static const char e_non_numeric_argument_to_z[]</a>
<a name="ln129">  = N_(&quot;E144: Non-numeric argument to :z&quot;);</a>
<a name="ln130"> </a>
<a name="ln131">/// &quot;:ascii&quot; and &quot;ga&quot; implementation</a>
<a name="ln132">void do_ascii(const exarg_T *const eap)</a>
<a name="ln133">{</a>
<a name="ln134">  char *dig;</a>
<a name="ln135">  int cc[MAX_MCO];</a>
<a name="ln136">  int c = utfc_ptr2char(get_cursor_pos_ptr(), cc);</a>
<a name="ln137">  if (c == NUL) {</a>
<a name="ln138">    msg(&quot;NUL&quot;, 0);</a>
<a name="ln139">    return;</a>
<a name="ln140">  }</a>
<a name="ln141"> </a>
<a name="ln142">  size_t iobuff_len = 0;</a>
<a name="ln143"> </a>
<a name="ln144">  int ci = 0;</a>
<a name="ln145">  if (c &lt; 0x80) {</a>
<a name="ln146">    if (c == NL) {  // NUL is stored as NL.</a>
<a name="ln147">      c = NUL;</a>
<a name="ln148">    }</a>
<a name="ln149">    const int cval = (c == CAR &amp;&amp; get_fileformat(curbuf) == EOL_MAC</a>
<a name="ln150">                      ? NL  // NL is stored as CR.</a>
<a name="ln151">                      : c);</a>
<a name="ln152">    char buf1[20];</a>
<a name="ln153">    if (vim_isprintc_strict(c) &amp;&amp; (c &lt; ' ' || c &gt; '~')) {</a>
<a name="ln154">      char buf3[7];</a>
<a name="ln155">      transchar_nonprint(curbuf, buf3, c);</a>
<a name="ln156">      vim_snprintf(buf1, sizeof(buf1), &quot;  &lt;%s&gt;&quot;, buf3);</a>
<a name="ln157">    } else {</a>
<a name="ln158">      buf1[0] = NUL;</a>
<a name="ln159">    }</a>
<a name="ln160">    char buf2[20];</a>
<a name="ln161">    buf2[0] = NUL;</a>
<a name="ln162"> </a>
<a name="ln163">    dig = get_digraph_for_char(cval);</a>
<a name="ln164">    if (dig != NULL) {</a>
<a name="ln165">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln166">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln167">                                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Oct %03o, Digr %s&quot;),</a>
<a name="ln168">                                         transchar(c), buf1, buf2, cval, cval, cval, dig);</a>
<a name="ln169">    } else {</a>
<a name="ln170">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln171">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln172">                                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Octal %03o&quot;),</a>
<a name="ln173">                                         transchar(c), buf1, buf2, cval, cval, cval);</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    c = cc[ci++];</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">#define SPACE_FOR_DESC (1 + 1 + 1 + MB_MAXBYTES + 16 + 4 + 3 + 3 + 1)</a>
<a name="ln180">  // Space for description:</a>
<a name="ln181">  // - 1 byte for separator (starting from second entry)</a>
<a name="ln182">  // - 1 byte for &quot;&lt;&quot;</a>
<a name="ln183">  // - 1 byte for space to draw composing character on (optional, but really</a>
<a name="ln184">  //   mostly required)</a>
<a name="ln185">  // - up to MB_MAXBYTES bytes for character itself</a>
<a name="ln186">  // - 16 bytes for raw text (&quot;&gt; , Hex , Octal &quot;).</a>
<a name="ln187">  // - at least 4 bytes for hexadecimal representation</a>
<a name="ln188">  // - at least 3 bytes for decimal representation</a>
<a name="ln189">  // - at least 3 bytes for octal representation</a>
<a name="ln190">  // - 1 byte for NUL</a>
<a name="ln191">  //</a>
<a name="ln192">  // Taking into account MAX_MCO and characters which need 8 bytes for</a>
<a name="ln193">  // hexadecimal representation, but not taking translation into account:</a>
<a name="ln194">  // resulting string will occupy less then 400 bytes (conservative estimate).</a>
<a name="ln195">  //</a>
<a name="ln196">  // Less then 1000 bytes if translation multiplies number of bytes needed for</a>
<a name="ln197">  // raw text by 6, so it should always fit into 1025 bytes reserved for IObuff.</a>
<a name="ln198"> </a>
<a name="ln199">  // Repeat for combining characters, also handle multiby here.</a>
<a name="ln200">  while (c &gt;= 0x80 &amp;&amp; iobuff_len &lt; sizeof(IObuff) - SPACE_FOR_DESC) {</a>
<a name="ln201">    // This assumes every multi-byte char is printable...</a>
<a name="ln202">    if (iobuff_len &gt; 0) {</a>
<a name="ln203">      IObuff[iobuff_len++] = ' ';</a>
<a name="ln204">    }</a>
<a name="ln205">    IObuff[iobuff_len++] = '&lt;';</a>
<a name="ln206">    if (utf_iscomposing(c)) {</a>
<a name="ln207">      IObuff[iobuff_len++] = ' ';  // Draw composing char on top of a space.</a>
<a name="ln208">    }</a>
<a name="ln209">    iobuff_len += (size_t)utf_char2bytes(c, IObuff + iobuff_len);</a>
<a name="ln210"> </a>
<a name="ln211">    dig = get_digraph_for_char(c);</a>
<a name="ln212">    if (dig != NULL) {</a>
<a name="ln213">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln214">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln215">                                         (c &lt; 0x10000</a>
<a name="ln216">                                          ? _(&quot;&gt; %d, Hex %04x, Oct %o, Digr %s&quot;)</a>
<a name="ln217">                                          : _(&quot;&gt; %d, Hex %08x, Oct %o, Digr %s&quot;)),</a>
<a name="ln218">                                         c, c, c, dig);</a>
<a name="ln219">    } else {</a>
<a name="ln220">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln221">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln222">                                         (c &lt; 0x10000</a>
<a name="ln223">                                          ? _(&quot;&gt; %d, Hex %04x, Octal %o&quot;)</a>
<a name="ln224">                                          : _(&quot;&gt; %d, Hex %08x, Octal %o&quot;)),</a>
<a name="ln225">                                         c, c, c);</a>
<a name="ln226">    }</a>
<a name="ln227">    if (ci == MAX_MCO) {</a>
<a name="ln228">      break;</a>
<a name="ln229">    }</a>
<a name="ln230">    c = cc[ci++];</a>
<a name="ln231">  }</a>
<a name="ln232">  if (ci != MAX_MCO &amp;&amp; c != 0) {</a>
<a name="ln233">    xstrlcpy(IObuff + iobuff_len, &quot; ...&quot;, sizeof(IObuff) - iobuff_len);</a>
<a name="ln234">  }</a>
<a name="ln235"> </a>
<a name="ln236">  msg(IObuff, 0);</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">/// &quot;:left&quot;, &quot;:center&quot; and &quot;:right&quot;: align text.</a>
<a name="ln240">void ex_align(exarg_T *eap)</a>
<a name="ln241">{</a>
<a name="ln242">  pos_T save_curpos;</a>
<a name="ln243">  int len;</a>
<a name="ln244">  int indent = 0;</a>
<a name="ln245">  int new_indent;</a>
<a name="ln246">  int has_tab;</a>
<a name="ln247">  int width;</a>
<a name="ln248"> </a>
<a name="ln249">  if (curwin-&gt;w_p_rl) {</a>
<a name="ln250">    // switch left and right aligning</a>
<a name="ln251">    if (eap-&gt;cmdidx == CMD_right) {</a>
<a name="ln252">      eap-&gt;cmdidx = CMD_left;</a>
<a name="ln253">    } else if (eap-&gt;cmdidx == CMD_left) {</a>
<a name="ln254">      eap-&gt;cmdidx = CMD_right;</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  width = atoi(eap-&gt;arg);</a>
<a name="ln259">  save_curpos = curwin-&gt;w_cursor;</a>
<a name="ln260">  if (eap-&gt;cmdidx == CMD_left) {    // width is used for new indent</a>
<a name="ln261">    if (width &gt;= 0) {</a>
<a name="ln262">      indent = width;</a>
<a name="ln263">    }</a>
<a name="ln264">  } else {</a>
<a name="ln265">    // if 'textwidth' set, use it</a>
<a name="ln266">    // else if 'wrapmargin' set, use it</a>
<a name="ln267">    // if invalid value, use 80</a>
<a name="ln268">    if (width &lt;= 0) {</a>
<a name="ln269">      width = (int)curbuf-&gt;b_p_tw;</a>
<a name="ln270">    }</a>
<a name="ln271">    if (width == 0 &amp;&amp; curbuf-&gt;b_p_wm &gt; 0) {</a>
<a name="ln272">      width = curwin-&gt;w_width_inner - (int)curbuf-&gt;b_p_wm;</a>
<a name="ln273">    }</a>
<a name="ln274">    if (width &lt;= 0) {</a>
<a name="ln275">      width = 80;</a>
<a name="ln276">    }</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln280">    return;</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  for (curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln284">       curwin-&gt;w_cursor.lnum &lt;= eap-&gt;line2; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln285">    if (eap-&gt;cmdidx == CMD_left) {              // left align</a>
<a name="ln286">      new_indent = indent;</a>
<a name="ln287">    } else {</a>
<a name="ln288">      has_tab = false;          // avoid uninit warnings</a>
<a name="ln289">      len = linelen(eap-&gt;cmdidx == CMD_right ? &amp;has_tab : NULL) - get_indent();</a>
<a name="ln290"> </a>
<a name="ln291">      if (len &lt;= 0) {                           // skip blank lines</a>
<a name="ln292">        continue;</a>
<a name="ln293">      }</a>
<a name="ln294"> </a>
<a name="ln295">      if (eap-&gt;cmdidx == CMD_center) {</a>
<a name="ln296">        new_indent = (width - len) / 2;</a>
<a name="ln297">      } else {</a>
<a name="ln298">        new_indent = width - len;               // right align</a>
<a name="ln299"> </a>
<a name="ln300">        // Make sure that embedded TABs don't make the text go too far</a>
<a name="ln301">        // to the right.</a>
<a name="ln302">        if (has_tab) {</a>
<a name="ln303">          while (new_indent &gt; 0) {</a>
<a name="ln304">            (void)set_indent(new_indent, 0);</a>
<a name="ln305">            if (linelen(NULL) &lt;= width) {</a>
<a name="ln306">              // Now try to move the line as much as possible to</a>
<a name="ln307">              // the right.  Stop when it moves too far.</a>
<a name="ln308">              do {</a>
<a name="ln309">                (void)set_indent(++new_indent, 0);</a>
<a name="ln310">              } while (linelen(NULL) &lt;= width);</a>
<a name="ln311">              new_indent--;</a>
<a name="ln312">              break;</a>
<a name="ln313">            }</a>
<a name="ln314">            new_indent--;</a>
<a name="ln315">          }</a>
<a name="ln316">        }</a>
<a name="ln317">      }</a>
<a name="ln318">    }</a>
<a name="ln319">    if (new_indent &lt; 0) {</a>
<a name="ln320">      new_indent = 0;</a>
<a name="ln321">    }</a>
<a name="ln322">    (void)set_indent(new_indent, 0);                    // set indent</a>
<a name="ln323">  }</a>
<a name="ln324">  changed_lines(curbuf, eap-&gt;line1, 0, eap-&gt;line2 + 1, 0L, true);</a>
<a name="ln325">  curwin-&gt;w_cursor = save_curpos;</a>
<a name="ln326">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">/// @return  the length of the current line, excluding trailing white space.</a>
<a name="ln330">static int linelen(int *has_tab)</a>
<a name="ln331">{</a>
<a name="ln332">  char *line;</a>
<a name="ln333">  char *first;</a>
<a name="ln334">  char *last;</a>
<a name="ln335">  int len;</a>
<a name="ln336"> </a>
<a name="ln337">  // Get the line.  If it's empty bail out early (could be the empty string</a>
<a name="ln338">  // for an unloaded buffer).</a>
<a name="ln339">  line = get_cursor_line_ptr();</a>
<a name="ln340">  if (*line == NUL) {</a>
<a name="ln341">    return 0;</a>
<a name="ln342">  }</a>
<a name="ln343">  // find the first non-blank character</a>
<a name="ln344">  first = skipwhite(line);</a>
<a name="ln345"> </a>
<a name="ln346">  // find the character after the last non-blank character</a>
<a name="ln347">  for (last = first + strlen(first);</a>
<a name="ln348">       last &gt; first &amp;&amp; ascii_iswhite(last[-1]); last--) {}</a>
<a name="ln349">  char save = *last;</a>
<a name="ln350">  *last = NUL;</a>
<a name="ln351">  len = linetabsize_str(line);  // Get line length.</a>
<a name="ln352">  if (has_tab != NULL) {        // Check for embedded TAB.</a>
<a name="ln353">    *has_tab = vim_strchr(first, TAB) != NULL;</a>
<a name="ln354">  }</a>
<a name="ln355">  *last = save;</a>
<a name="ln356"> </a>
<a name="ln357">  return len;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">// Buffer for two lines used during sorting.  They are allocated to</a>
<a name="ln361">// contain the longest line being sorted.</a>
<a name="ln362">static char *sortbuf1;</a>
<a name="ln363">static char *sortbuf2;</a>
<a name="ln364"> </a>
<a name="ln365">static int sort_lc;       ///&lt; sort using locale</a>
<a name="ln366">static int sort_ic;       ///&lt; ignore case</a>
<a name="ln367">static int sort_nr;       ///&lt; sort on number</a>
<a name="ln368">static int sort_rx;       ///&lt; sort on regex instead of skipping it</a>
<a name="ln369">static int sort_flt;      ///&lt; sort on floating number</a>
<a name="ln370"> </a>
<a name="ln371">static int sort_abort;    ///&lt; flag to indicate if sorting has been interrupted</a>
<a name="ln372"> </a>
<a name="ln373">/// Struct to store info to be sorted.</a>
<a name="ln374">typedef struct {</a>
<a name="ln375">  linenr_T lnum;          ///&lt; line number</a>
<a name="ln376">  union {</a>
<a name="ln377">    struct {</a>
<a name="ln378">      varnumber_T start_col_nr;  ///&lt; starting column number</a>
<a name="ln379">      varnumber_T end_col_nr;    ///&lt; ending column number</a>
<a name="ln380">    } line;</a>
<a name="ln381">    struct {</a>
<a name="ln382">      varnumber_T value;         ///&lt; value if sorting by integer</a>
<a name="ln383">      bool is_number;            ///&lt; true when line contains a number</a>
<a name="ln384">    } num;</a>
<a name="ln385">    float_T value_flt;    ///&lt; value if sorting by float</a>
<a name="ln386">  } st_u;</a>
<a name="ln387">} sorti_T;</a>
<a name="ln388"> </a>
<a name="ln389">static int string_compare(const void *s1, const void *s2) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln390">{</a>
<a name="ln391">  if (sort_lc) {</a>
<a name="ln392">    return strcoll((const char *)s1, (const char *)s2);</a>
<a name="ln393">  }</a>
<a name="ln394">  return sort_ic ? STRICMP(s1, s2) : strcmp(s1, s2);</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln398">{</a>
<a name="ln399">  sorti_T l1 = *(sorti_T *)s1;</a>
<a name="ln400">  sorti_T l2 = *(sorti_T *)s2;</a>
<a name="ln401">  int result = 0;</a>
<a name="ln402"> </a>
<a name="ln403">  // If the user interrupts, there's no way to stop qsort() immediately, but</a>
<a name="ln404">  // if we return 0 every time, qsort will assume it's done sorting and</a>
<a name="ln405">  // exit.</a>
<a name="ln406">  if (sort_abort) {</a>
<a name="ln407">    return 0;</a>
<a name="ln408">  }</a>
<a name="ln409">  fast_breakcheck();</a>
<a name="ln410">  if (got_int) {</a>
<a name="ln411">    sort_abort = true;</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  // When sorting numbers &quot;start_col_nr&quot; is the number, not the column</a>
<a name="ln415">  // number.</a>
<a name="ln416">  if (sort_nr) {</a>
<a name="ln417">    if (l1.st_u.num.is_number != l2.st_u.num.is_number) {</a>
<a name="ln418">      result = l1.st_u.num.is_number - l2.st_u.num.is_number;</a>
<a name="ln419">    } else {</a>
<a name="ln420">      result = l1.st_u.num.value == l2.st_u.num.value</a>
<a name="ln421">        ? 0</a>
<a name="ln422">        : l1.st_u.num.value &gt; l2.st_u.num.value</a>
<a name="ln423">          ? 1</a>
<a name="ln424">          : -1;</a>
<a name="ln425">    }</a>
<a name="ln426">  } else if (sort_flt) {</a>
<a name="ln427">    result = l1.st_u.value_flt == l2.st_u.value_flt</a>
<a name="ln428">             ? 0 : l1.st_u.value_flt &gt; l2.st_u.value_flt</a>
<a name="ln429">             ? 1 : -1;</a>
<a name="ln430">  } else {</a>
<a name="ln431">    // We need to copy one line into &quot;sortbuf1&quot;, because there is no</a>
<a name="ln432">    // guarantee that the first pointer becomes invalid when obtaining the</a>
<a name="ln433">    // second one.</a>
<a name="ln434">    memcpy(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,</a>
<a name="ln435">           (size_t)(l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1));</a>
<a name="ln436">    sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = NUL;</a>
<a name="ln437">    memcpy(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,</a>
<a name="ln438">           (size_t)(l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1));</a>
<a name="ln439">    sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = NUL;</a>
<a name="ln440"> </a>
<a name="ln441">    result = string_compare(sortbuf1, sortbuf2);</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  // If two lines have the same value, preserve the original line order.</a>
<a name="ln445">  if (result == 0) {</a>
<a name="ln446">    return l1.lnum - l2.lnum;</a>
<a name="ln447">  }</a>
<a name="ln448">  return result;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">/// &quot;:sort&quot;.</a>
<a name="ln452">void ex_sort(exarg_T *eap)</a>
<a name="ln453">{</a>
<a name="ln454">  regmatch_T regmatch;</a>
<a name="ln455">  int len;</a>
<a name="ln456">  linenr_T lnum;</a>
<a name="ln457">  long maxlen = 0;</a>
<a name="ln458">  size_t count = (size_t)(eap-&gt;line2 - eap-&gt;line1) + 1;</a>
<a name="ln459">  size_t i;</a>
<a name="ln460">  char *p;</a>
<a name="ln461">  char *s;</a>
<a name="ln462">  char *s2;</a>
<a name="ln463">  char c;                             // temporary character storage</a>
<a name="ln464">  bool unique = false;</a>
<a name="ln465">  linenr_T deleted;</a>
<a name="ln466">  colnr_T start_col;</a>
<a name="ln467">  colnr_T end_col;</a>
<a name="ln468">  int sort_what = 0;</a>
<a name="ln469"> </a>
<a name="ln470">  // Sorting one line is really quick!</a>
<a name="ln471">  if (count &lt;= 1) {</a>
<a name="ln472">    return;</a>
<a name="ln473">  }</a>
<a name="ln474"> </a>
<a name="ln475">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln476">    return;</a>
<a name="ln477">  }</a>
<a name="ln478">  sortbuf1 = NULL;</a>
<a name="ln479">  sortbuf2 = NULL;</a>
<a name="ln480">  regmatch.regprog = NULL;</a>
<a name="ln481">  sorti_T *nrs = xmalloc(count * sizeof(sorti_T));</a>
<a name="ln482"> </a>
<a name="ln483">  sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = sort_flt = 0;</a>
<a name="ln484">  size_t format_found = 0;</a>
<a name="ln485">  bool change_occurred = false;   // Buffer contents changed.</a>
<a name="ln486"> </a>
<a name="ln487">  for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln488">    if (ascii_iswhite(*p)) {</a>
<a name="ln489">      // Skip</a>
<a name="ln490">    } else if (*p == 'i') {</a>
<a name="ln491">      sort_ic = true;</a>
<a name="ln492">    } else if (*p == 'l') {</a>
<a name="ln493">      sort_lc = true;</a>
<a name="ln494">    } else if (*p == 'r') {</a>
<a name="ln495">      sort_rx = true;</a>
<a name="ln496">    } else if (*p == 'n') {</a>
<a name="ln497">      sort_nr = 1;</a>
<a name="ln498">      format_found++;</a>
<a name="ln499">    } else if (*p == 'f') {</a>
<a name="ln500">      sort_flt = 1;</a>
<a name="ln501">      format_found++;</a>
<a name="ln502">    } else if (*p == 'b') {</a>
<a name="ln503">      sort_what = STR2NR_BIN + STR2NR_FORCE;</a>
<a name="ln504">      format_found++;</a>
<a name="ln505">    } else if (*p == 'o') {</a>
<a name="ln506">      sort_what = STR2NR_OCT + STR2NR_FORCE;</a>
<a name="ln507">      format_found++;</a>
<a name="ln508">    } else if (*p == 'x') {</a>
<a name="ln509">      sort_what = STR2NR_HEX + STR2NR_FORCE;</a>
<a name="ln510">      format_found++;</a>
<a name="ln511">    } else if (*p == 'u') {</a>
<a name="ln512">      unique = true;</a>
<a name="ln513">    } else if (*p == '&quot;') {</a>
<a name="ln514">      // comment start</a>
<a name="ln515">      break;</a>
<a name="ln516">    } else if (check_nextcmd(p) != NULL) {</a>
<a name="ln517">      eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln518">      break;</a>
<a name="ln519">    } else if (!ASCII_ISALPHA(*p) &amp;&amp; regmatch.regprog == NULL) {</a>
<a name="ln520">      s = skip_regexp_err(p + 1, *p, true);</a>
<a name="ln521">      if (s == NULL) {</a>
<a name="ln522">        goto sortend;</a>
<a name="ln523">      }</a>
<a name="ln524">      *s = NUL;</a>
<a name="ln525">      // Use last search pattern if sort pattern is empty.</a>
<a name="ln526">      if (s == p + 1) {</a>
<a name="ln527">        if (last_search_pat() == NULL) {</a>
<a name="ln528">          emsg(_(e_noprevre));</a>
<a name="ln529">          goto sortend;</a>
<a name="ln530">        }</a>
<a name="ln531">        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);</a>
<a name="ln532">      } else {</a>
<a name="ln533">        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);</a>
<a name="ln534">      }</a>
<a name="ln535">      if (regmatch.regprog == NULL) {</a>
<a name="ln536">        goto sortend;</a>
<a name="ln537">      }</a>
<a name="ln538">      p = s;                    // continue after the regexp</a>
<a name="ln539">      regmatch.rm_ic = p_ic;</a>
<a name="ln540">    } else {</a>
<a name="ln541">      semsg(_(e_invarg2), p);</a>
<a name="ln542">      goto sortend;</a>
<a name="ln543">    }</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  // Can only have one of 'n', 'b', 'o' and 'x'.</a>
<a name="ln547">  if (format_found &gt; 1) {</a>
<a name="ln548">    emsg(_(e_invarg));</a>
<a name="ln549">    goto sortend;</a>
<a name="ln550">  }</a>
<a name="ln551"> </a>
<a name="ln552">  // From here on &quot;sort_nr&quot; is used as a flag for any integer number</a>
<a name="ln553">  // sorting.</a>
<a name="ln554">  sort_nr += sort_what;</a>
<a name="ln555"> </a>
<a name="ln556">  // Make an array with all line numbers.  This avoids having to copy all</a>
<a name="ln557">  // the lines into allocated memory.</a>
<a name="ln558">  // When sorting on strings &quot;start_col_nr&quot; is the offset in the line, for</a>
<a name="ln559">  // numbers sorting it's the number to sort on.  This means the pattern</a>
<a name="ln560">  // matching and number conversion only has to be done once per line.</a>
<a name="ln561">  // Also get the longest line length for allocating &quot;sortbuf&quot;.</a>
<a name="ln562">  for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln563">    s = ml_get(lnum);</a>
<a name="ln564">    len = (int)strlen(s);</a>
<a name="ln565">    if (maxlen &lt; len) {</a>
<a name="ln566">      maxlen = len;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    start_col = 0;</a>
<a name="ln570">    end_col = len;</a>
<a name="ln571">    if (regmatch.regprog != NULL &amp;&amp; vim_regexec(&amp;regmatch, s, 0)) {</a>
<a name="ln572">      if (sort_rx) {</a>
<a name="ln573">        start_col = (colnr_T)(regmatch.startp[0] - s);</a>
<a name="ln574">        end_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln575">      } else {</a>
<a name="ln576">        start_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln577">      }</a>
<a name="ln578">    } else if (regmatch.regprog != NULL) {</a>
<a name="ln579">      end_col = 0;</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">    if (sort_nr || sort_flt) {</a>
<a name="ln583">      // Make sure vim_str2nr() doesn't read any digits past the end</a>
<a name="ln584">      // of the match, by temporarily terminating the string there</a>
<a name="ln585">      s2 = s + end_col;</a>
<a name="ln586">      c = *s2;</a>
<a name="ln587">      *s2 = NUL;</a>
<a name="ln588">      // Sorting on number: Store the number itself.</a>
<a name="ln589">      p = s + start_col;</a>
<a name="ln590">      if (sort_nr) {</a>
<a name="ln591">        if (sort_what &amp; STR2NR_HEX) {</a>
<a name="ln592">          s = skiptohex(p);</a>
<a name="ln593">        } else if (sort_what &amp; STR2NR_BIN) {</a>
<a name="ln594">          s = (char *)skiptobin(p);</a>
<a name="ln595">        } else {</a>
<a name="ln596">          s = skiptodigit(p);</a>
<a name="ln597">        }</a>
<a name="ln598">        if (s &gt; p &amp;&amp; s[-1] == '-') {</a>
<a name="ln599">          s--;  // include preceding negative sign</a>
<a name="ln600">        }</a>
<a name="ln601">        if (*s == NUL) {</a>
<a name="ln602">          // line without number should sort before any number</a>
<a name="ln603">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = false;</a>
<a name="ln604">          nrs[lnum - eap-&gt;line1].st_u.num.value = 0;</a>
<a name="ln605">        } else {</a>
<a name="ln606">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = true;</a>
<a name="ln607">          vim_str2nr(s, NULL, NULL, sort_what,</a>
<a name="ln608">                     &amp;nrs[lnum - eap-&gt;line1].st_u.num.value, NULL, 0, false, NULL);</a>
<a name="ln609">        }</a>
<a name="ln610">      } else {</a>
<a name="ln611">        s = skipwhite(p);</a>
<a name="ln612">        if (*s == '+') {</a>
<a name="ln613">          s = skipwhite(s + 1);</a>
<a name="ln614">        }</a>
<a name="ln615"> </a>
<a name="ln616">        if (*s == NUL) {</a>
<a name="ln617">          // empty line should sort before any number</a>
<a name="ln618">          nrs[lnum - eap-&gt;line1].st_u.value_flt = -DBL_MAX;</a>
<a name="ln619">        } else {</a>
<a name="ln620">          nrs[lnum - eap-&gt;line1].st_u.value_flt = strtod(s, NULL);</a>
<a name="ln621">        }</a>
<a name="ln622">      }</a>
<a name="ln623">      *s2 = c;</a>
<a name="ln624">    } else {</a>
<a name="ln625">      // Store the column to sort at.</a>
<a name="ln626">      nrs[lnum - eap-&gt;line1].st_u.line.start_col_nr = start_col;</a>
<a name="ln627">      nrs[lnum - eap-&gt;line1].st_u.line.end_col_nr = end_col;</a>
<a name="ln628">    }</a>
<a name="ln629"> </a>
<a name="ln630">    nrs[lnum - eap-&gt;line1].lnum = lnum;</a>
<a name="ln631"> </a>
<a name="ln632">    if (regmatch.regprog != NULL) {</a>
<a name="ln633">      fast_breakcheck();</a>
<a name="ln634">    }</a>
<a name="ln635">    if (got_int) {</a>
<a name="ln636">      goto sortend;</a>
<a name="ln637">    }</a>
<a name="ln638">  }</a>
<a name="ln639"> </a>
<a name="ln640">  // Allocate a buffer that can hold the longest line.</a>
<a name="ln641">  sortbuf1 = xmalloc((size_t)maxlen + 1);</a>
<a name="ln642">  sortbuf2 = xmalloc((size_t)maxlen + 1);</a>
<a name="ln643"> </a>
<a name="ln644">  // Sort the array of line numbers.  Note: can't be interrupted!</a>
<a name="ln645">  qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);</a>
<a name="ln646"> </a>
<a name="ln647">  if (sort_abort) {</a>
<a name="ln648">    goto sortend;</a>
<a name="ln649">  }</a>
<a name="ln650"> </a>
<a name="ln651">  bcount_t old_count = 0, new_count = 0;</a>
<a name="ln652"> </a>
<a name="ln653">  // Insert the lines in the sorted order below the last one.</a>
<a name="ln654">  lnum = eap-&gt;line2;</a>
<a name="ln655">  for (i = 0; i &lt; count; i++) {</a>
<a name="ln656">    const linenr_T get_lnum = nrs[eap-&gt;forceit ? count - i - 1 : i].lnum;</a>
<a name="ln657"> </a>
<a name="ln658">    // If the original line number of the line being placed is not the same</a>
<a name="ln659">    // as &quot;lnum&quot; (accounting for offset), we know that the buffer changed.</a>
<a name="ln660">    if (get_lnum + ((linenr_T)count - 1) != lnum) {</a>
<a name="ln661">      change_occurred = true;</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    s = ml_get(get_lnum);</a>
<a name="ln665">    size_t bytelen = strlen(s) + 1;  // include EOL in bytelen</a>
<a name="ln666">    old_count += (bcount_t)bytelen;</a>
<a name="ln667">    if (!unique || i == 0 || string_compare(s, sortbuf1) != 0) {</a>
<a name="ln668">      // Copy the line into a buffer, it may become invalid in</a>
<a name="ln669">      // ml_append(). And it's needed for &quot;unique&quot;.</a>
<a name="ln670">      STRCPY(sortbuf1, s);</a>
<a name="ln671">      if (ml_append(lnum++, sortbuf1, (colnr_T)0, false) == FAIL) {</a>
<a name="ln672">        break;</a>
<a name="ln673">      }</a>
<a name="ln674">      new_count += (bcount_t)bytelen;</a>
<a name="ln675">    }</a>
<a name="ln676">    fast_breakcheck();</a>
<a name="ln677">    if (got_int) {</a>
<a name="ln678">      goto sortend;</a>
<a name="ln679">    }</a>
<a name="ln680">  }</a>
<a name="ln681"> </a>
<a name="ln682">  // delete the original lines if appending worked</a>
<a name="ln683">  if (i == count) {</a>
<a name="ln684">    for (i = 0; i &lt; count; i++) {</a>
<a name="ln685">      ml_delete(eap-&gt;line1, false);</a>
<a name="ln686">    }</a>
<a name="ln687">  } else {</a>
<a name="ln688">    count = 0;</a>
<a name="ln689">  }</a>
<a name="ln690"> </a>
<a name="ln691">  // Adjust marks for deleted (or added) lines and prepare for displaying.</a>
<a name="ln692">  deleted = (linenr_T)count - (lnum - eap-&gt;line2);</a>
<a name="ln693">  if (deleted &gt; 0) {</a>
<a name="ln694">    mark_adjust(eap-&gt;line2 - deleted, eap-&gt;line2, (long)MAXLNUM, -deleted, kExtmarkNOOP);</a>
<a name="ln695">    msgmore(-deleted);</a>
<a name="ln696">  } else if (deleted &lt; 0) {</a>
<a name="ln697">    mark_adjust(eap-&gt;line2, MAXLNUM, -deleted, 0L, kExtmarkNOOP);</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700">  if (change_occurred || deleted != 0) {</a>
<a name="ln701">    extmark_splice(curbuf, eap-&gt;line1 - 1, 0,</a>
<a name="ln702">                   (int)count, 0, old_count,</a>
<a name="ln703">                   lnum - eap-&gt;line2, 0, new_count, kExtmarkUndo);</a>
<a name="ln704"> </a>
<a name="ln705">    changed_lines(curbuf, eap-&gt;line1, 0, eap-&gt;line2 + 1, -deleted, true);</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln709">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln710"> </a>
<a name="ln711">sortend:</a>
<a name="ln712">  xfree(nrs);</a>
<a name="ln713">  xfree(sortbuf1);</a>
<a name="ln714">  xfree(sortbuf2);</a>
<a name="ln715">  vim_regfree(regmatch.regprog);</a>
<a name="ln716">  if (got_int) {</a>
<a name="ln717">    emsg(_(e_interr));</a>
<a name="ln718">  }</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">/// :move command - move lines line1-line2 to line dest</a>
<a name="ln722">///</a>
<a name="ln723">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln724">int do_move(linenr_T line1, linenr_T line2, linenr_T dest)</a>
<a name="ln725">{</a>
<a name="ln726">  linenr_T l;</a>
<a name="ln727">  linenr_T extra;      // Num lines added before line1</a>
<a name="ln728">  linenr_T num_lines;  // Num lines moved</a>
<a name="ln729">  linenr_T last_line;  // Last line in file after adding new text</a>
<a name="ln730"> </a>
<a name="ln731">  if (dest &gt;= line1 &amp;&amp; dest &lt; line2) {</a>
<a name="ln732">    emsg(_(&quot;E134: Cannot move a range of lines into itself&quot;));</a>
<a name="ln733">    return FAIL;</a>
<a name="ln734">  }</a>
<a name="ln735"> </a>
<a name="ln736">  // Do nothing if we are not actually moving any lines.  This will prevent</a>
<a name="ln737">  // the 'modified' flag from being set without cause.</a>
<a name="ln738">  if (dest == line1 - 1 || dest == line2) {</a>
<a name="ln739">    // Move the cursor as if lines were moved (see below) to be backwards</a>
<a name="ln740">    // compatible.</a>
<a name="ln741">    if (dest &gt;= line1) {</a>
<a name="ln742">      curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln743">    } else {</a>
<a name="ln744">      curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln745">    }</a>
<a name="ln746">    return OK;</a>
<a name="ln747">  }</a>
<a name="ln748"> </a>
<a name="ln749">  bcount_t start_byte = ml_find_line_or_offset(curbuf, line1, NULL, true);</a>
<a name="ln750">  bcount_t end_byte = ml_find_line_or_offset(curbuf, line2 + 1, NULL, true);</a>
<a name="ln751">  bcount_t extent_byte = end_byte - start_byte;</a>
<a name="ln752">  bcount_t dest_byte = ml_find_line_or_offset(curbuf, dest + 1, NULL, true);</a>
<a name="ln753"> </a>
<a name="ln754">  num_lines = line2 - line1 + 1;</a>
<a name="ln755"> </a>
<a name="ln756">  // First we copy the old text to its new location -- webb</a>
<a name="ln757">  // Also copy the flag that &quot;:global&quot; command uses.</a>
<a name="ln758">  if (u_save(dest, dest + 1) == FAIL) {</a>
<a name="ln759">    return FAIL;</a>
<a name="ln760">  }</a>
<a name="ln761">  for (extra = 0, l = line1; l &lt;= line2; l++) {</a>
<a name="ln762">    char *str = xstrdup(ml_get(l + extra));</a>
<a name="ln763">    ml_append(dest + l - line1, str, (colnr_T)0, false);</a>
<a name="ln764">    xfree(str);</a>
<a name="ln765">    if (dest &lt; line1) {</a>
<a name="ln766">      extra++;</a>
<a name="ln767">    }</a>
<a name="ln768">  }</a>
<a name="ln769"> </a>
<a name="ln770">  // Now we must be careful adjusting our marks so that we don't overlap our</a>
<a name="ln771">  // mark_adjust() calls.</a>
<a name="ln772">  //</a>
<a name="ln773">  // We adjust the marks within the old text so that they refer to the</a>
<a name="ln774">  // last lines of the file (temporarily), because we know no other marks</a>
<a name="ln775">  // will be set there since these line numbers did not exist until we added</a>
<a name="ln776">  // our new lines.</a>
<a name="ln777">  //</a>
<a name="ln778">  // Then we adjust the marks on lines between the old and new text positions</a>
<a name="ln779">  // (either forwards or backwards).</a>
<a name="ln780">  //</a>
<a name="ln781">  // And Finally we adjust the marks we put at the end of the file back to</a>
<a name="ln782">  // their final destination at the new text position -- webb</a>
<a name="ln783">  last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln784">  mark_adjust_nofold(line1, line2, last_line - line2, 0L, kExtmarkNOOP);</a>
<a name="ln785"> </a>
<a name="ln786">  disable_fold_update++;</a>
<a name="ln787">  changed_lines(curbuf, last_line - num_lines + 1, 0, last_line + 1, num_lines, false);</a>
<a name="ln788">  disable_fold_update--;</a>
<a name="ln789"> </a>
<a name="ln790">  int line_off = 0;</a>
<a name="ln791">  bcount_t byte_off = 0;</a>
<a name="ln792">  if (dest &gt;= line2) {</a>
<a name="ln793">    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln794">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln795">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln796">        foldMoveRange(win, &amp;win-&gt;w_folds, line1, line2, dest);</a>
<a name="ln797">      }</a>
<a name="ln798">    }</a>
<a name="ln799">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln800">      curbuf-&gt;b_op_start.lnum = dest - num_lines + 1;</a>
<a name="ln801">      curbuf-&gt;b_op_end.lnum = dest;</a>
<a name="ln802">    }</a>
<a name="ln803">    line_off = -num_lines;</a>
<a name="ln804">    byte_off = -extent_byte;</a>
<a name="ln805">  } else {</a>
<a name="ln806">    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln807">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln808">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln809">        foldMoveRange(win, &amp;win-&gt;w_folds, dest + 1, line1 - 1, line2);</a>
<a name="ln810">      }</a>
<a name="ln811">    }</a>
<a name="ln812">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln813">      curbuf-&gt;b_op_start.lnum = dest + 1;</a>
<a name="ln814">      curbuf-&gt;b_op_end.lnum = dest + num_lines;</a>
<a name="ln815">    }</a>
<a name="ln816">  }</a>
<a name="ln817">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln818">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln819">  }</a>
<a name="ln820">  mark_adjust_nofold(last_line - num_lines + 1, last_line,</a>
<a name="ln821">                     -(last_line - dest - extra), 0L, kExtmarkNOOP);</a>
<a name="ln822"> </a>
<a name="ln823">  disable_fold_update++;</a>
<a name="ln824">  changed_lines(curbuf, last_line - num_lines + 1, 0, last_line + 1, -extra, false);</a>
<a name="ln825">  disable_fold_update--;</a>
<a name="ln826"> </a>
<a name="ln827">  // send update regarding the new lines that were added</a>
<a name="ln828">  buf_updates_send_changes(curbuf, dest + 1, num_lines, 0);</a>
<a name="ln829"> </a>
<a name="ln830">  // Now we delete the original text -- webb</a>
<a name="ln831">  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL) {</a>
<a name="ln832">    return FAIL;</a>
<a name="ln833">  }</a>
<a name="ln834"> </a>
<a name="ln835">  for (l = line1; l &lt;= line2; l++) {</a>
<a name="ln836">    ml_delete(line1 + extra, true);</a>
<a name="ln837">  }</a>
<a name="ln838">  if (!global_busy &amp;&amp; num_lines &gt; p_report) {</a>
<a name="ln839">    smsg(NGETTEXT(&quot;%&quot; PRId64 &quot; line moved&quot;,</a>
<a name="ln840">                  &quot;%&quot; PRId64 &quot; lines moved&quot;, num_lines),</a>
<a name="ln841">         (int64_t)num_lines);</a>
<a name="ln842">  }</a>
<a name="ln843"> </a>
<a name="ln844">  extmark_move_region(curbuf, line1 - 1, 0, start_byte,</a>
<a name="ln845">                      line2 - line1 + 1, 0, extent_byte,</a>
<a name="ln846">                      dest + line_off, 0, dest_byte + byte_off,</a>
<a name="ln847">                      kExtmarkUndo);</a>
<a name="ln848"> </a>
<a name="ln849">  // Leave the cursor on the last of the moved lines.</a>
<a name="ln850">  if (dest &gt;= line1) {</a>
<a name="ln851">    curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln852">  } else {</a>
<a name="ln853">    curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  if (line1 &lt; dest) {</a>
<a name="ln857">    dest += num_lines + 1;</a>
<a name="ln858">    last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln859">    if (dest &gt; last_line + 1) {</a>
<a name="ln860">      dest = last_line + 1;</a>
<a name="ln861">    }</a>
<a name="ln862">    changed_lines(curbuf, line1, 0, dest, 0L, false);</a>
<a name="ln863">  } else {</a>
<a name="ln864">    changed_lines(curbuf, dest + 1, 0, line1 + num_lines, 0L, false);</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  // send nvim_buf_lines_event regarding lines that were deleted</a>
<a name="ln868">  buf_updates_send_changes(curbuf, line1 + extra, 0, num_lines);</a>
<a name="ln869"> </a>
<a name="ln870">  return OK;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/// &quot;:copy&quot;</a>
<a name="ln874">void ex_copy(linenr_T line1, linenr_T line2, linenr_T n)</a>
<a name="ln875">{</a>
<a name="ln876">  linenr_T count = line2 - line1 + 1;</a>
<a name="ln877">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln878">    curbuf-&gt;b_op_start.lnum = n + 1;</a>
<a name="ln879">    curbuf-&gt;b_op_end.lnum = n + count;</a>
<a name="ln880">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln881">  }</a>
<a name="ln882"> </a>
<a name="ln883">  // there are three situations:</a>
<a name="ln884">  // 1. destination is above line1</a>
<a name="ln885">  // 2. destination is between line1 and line2</a>
<a name="ln886">  // 3. destination is below line2</a>
<a name="ln887">  //</a>
<a name="ln888">  // n = destination (when starting)</a>
<a name="ln889">  // curwin-&gt;w_cursor.lnum = destination (while copying)</a>
<a name="ln890">  // line1 = start of source (while copying)</a>
<a name="ln891">  // line2 = end of source (while copying)</a>
<a name="ln892">  if (u_save(n, n + 1) == FAIL) {</a>
<a name="ln893">    return;</a>
<a name="ln894">  }</a>
<a name="ln895"> </a>
<a name="ln896">  curwin-&gt;w_cursor.lnum = n;</a>
<a name="ln897">  while (line1 &lt;= line2) {</a>
<a name="ln898">    // need to use xstrdup() because the line will be unlocked within</a>
<a name="ln899">    // ml_append()</a>
<a name="ln900">    char *p = xstrdup(ml_get(line1));</a>
<a name="ln901">    ml_append(curwin-&gt;w_cursor.lnum, p, (colnr_T)0, false);</a>
<a name="ln902">    xfree(p);</a>
<a name="ln903"> </a>
<a name="ln904">    // situation 2: skip already copied lines</a>
<a name="ln905">    if (line1 == n) {</a>
<a name="ln906">      line1 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln907">    }</a>
<a name="ln908">    line1++;</a>
<a name="ln909">    if (curwin-&gt;w_cursor.lnum &lt; line1) {</a>
<a name="ln910">      line1++;</a>
<a name="ln911">    }</a>
<a name="ln912">    if (curwin-&gt;w_cursor.lnum &lt; line2) {</a>
<a name="ln913">      line2++;</a>
<a name="ln914">    }</a>
<a name="ln915">    curwin-&gt;w_cursor.lnum++;</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  appended_lines_mark(n, count);</a>
<a name="ln919">  if (VIsual_active) {</a>
<a name="ln920">    check_pos(curbuf, &amp;VIsual);</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  msgmore((long)count);</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">static char *prevcmd = NULL;        // the previous command</a>
<a name="ln927"> </a>
<a name="ln928">#if defined(EXITFREE)</a>
<a name="ln929">void free_prev_shellcmd(void)</a>
<a name="ln930">{</a>
<a name="ln931">  xfree(prevcmd);</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">#endif</a>
<a name="ln935"> </a>
<a name="ln936">/// Check that &quot;prevcmd&quot; is not NULL.  If it is NULL then give an error message</a>
<a name="ln937">/// and return false.</a>
<a name="ln938">static int prevcmd_is_set(void)</a>
<a name="ln939">{</a>
<a name="ln940">  if (prevcmd == NULL) {</a>
<a name="ln941">    emsg(_(e_noprev));</a>
<a name="ln942">    return false;</a>
<a name="ln943">  }</a>
<a name="ln944">  return true;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/// Handle the &quot;:!cmd&quot; command.  Also for &quot;:r !cmd&quot; and &quot;:w !cmd&quot;</a>
<a name="ln948">/// Bangs in the argument are replaced with the previously entered command.</a>
<a name="ln949">/// Remember the argument.</a>
<a name="ln950">void do_bang(int addr_count, exarg_T *eap, bool forceit, bool do_in, bool do_out)</a>
<a name="ln951">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln952">{</a>
<a name="ln953">  char *arg = eap-&gt;arg;             // command</a>
<a name="ln954">  linenr_T line1 = eap-&gt;line1;        // start of range</a>
<a name="ln955">  linenr_T line2 = eap-&gt;line2;        // end of range</a>
<a name="ln956">  char *newcmd = NULL;              // the new command</a>
<a name="ln957">  bool free_newcmd = false;           // need to free() newcmd</a>
<a name="ln958">  char *t;</a>
<a name="ln959">  char *p;</a>
<a name="ln960">  char *trailarg;</a>
<a name="ln961">  int scroll_save = msg_scroll;</a>
<a name="ln962"> </a>
<a name="ln963">  //</a>
<a name="ln964">  // Disallow shell commands in secure mode</a>
<a name="ln965">  //</a>
<a name="ln966">  if (check_secure()) {</a>
<a name="ln967">    return;</a>
<a name="ln968">  }</a>
<a name="ln969"> </a>
<a name="ln970">  if (addr_count == 0) {                // :!</a>
<a name="ln971">    msg_scroll = false;             // don't scroll here</a>
<a name="ln972">    autowrite_all();</a>
<a name="ln973">    msg_scroll = scroll_save;</a>
<a name="ln974">  }</a>
<a name="ln975"> </a>
<a name="ln976">  // Try to find an embedded bang, like in &quot;:!&lt;cmd&gt; ! [args]&quot;</a>
<a name="ln977">  // &quot;:!!&quot; is indicated by the 'forceit' variable.</a>
<a name="ln978">  bool ins_prevcmd = forceit;</a>
<a name="ln979"> </a>
<a name="ln980">  // Skip leading white space to avoid a strange error with some shells.</a>
<a name="ln981">  trailarg = skipwhite(arg);</a>
<a name="ln982">  do {</a>
<a name="ln983">    size_t len = strlen(trailarg) + 1;</a>
<a name="ln984">    if (newcmd != NULL) {</a>
<a name="ln985">      len += strlen(newcmd);</a>
<a name="ln986">    }</a>
<a name="ln987">    if (ins_prevcmd) {</a>
<a name="ln988">      if (!prevcmd_is_set()) {</a>
<a name="ln989">        xfree(newcmd);</a>
<a name="ln990">        return;</a>
<a name="ln991">      }</a>
<a name="ln992">      len += strlen(prevcmd);</a>
<a name="ln993">    }</a>
<a name="ln994">    t = xmalloc(len);</a>
<a name="ln995">    *t = NUL;</a>
<a name="ln996">    if (newcmd != NULL) {</a>
<a name="ln997">      STRCAT(t, newcmd);</a>
<a name="ln998">    }</a>
<a name="ln999">    if (ins_prevcmd) {</a>
<a name="ln1000">      STRCAT(t, prevcmd);</a>
<a name="ln1001">    }</a>
<a name="ln1002">    p = t + strlen(t);</a>
<a name="ln1003">    STRCAT(t, trailarg);</a>
<a name="ln1004">    xfree(newcmd);</a>
<a name="ln1005">    newcmd = t;</a>
<a name="ln1006"> </a>
<a name="ln1007">    // Scan the rest of the argument for '!', which is replaced by the</a>
<a name="ln1008">    // previous command.  &quot;\!&quot; is replaced by &quot;!&quot; (this is vi compatible).</a>
<a name="ln1009">    trailarg = NULL;</a>
<a name="ln1010">    while (*p) {</a>
<a name="ln1011">      if (*p == '!') {</a>
<a name="ln1012">        if (p &gt; newcmd &amp;&amp; p[-1] == '\\') {</a>
<a name="ln1013">          STRMOVE(p - 1, p);</a>
<a name="ln1014">        } else {</a>
<a name="ln1015">          trailarg = p;</a>
<a name="ln1016">          *trailarg++ = NUL;</a>
<a name="ln1017">          ins_prevcmd = true;</a>
<a name="ln1018">          break;</a>
<a name="ln1019">        }</a>
<a name="ln1020">      }</a>
<a name="ln1021">      p++;</a>
<a name="ln1022">    }</a>
<a name="ln1023">  } while (trailarg != NULL);</a>
<a name="ln1024"> </a>
<a name="ln1025">  // Only set &quot;prevcmd&quot; if there is a command to run, otherwise keep te one</a>
<a name="ln1026">  // we have.</a>
<a name="ln1027">  if (strlen(newcmd) &gt; 0) {</a>
<a name="ln1028">    xfree(prevcmd);</a>
<a name="ln1029">    prevcmd = newcmd;</a>
<a name="ln1030">  } else {</a>
<a name="ln1031">    free_newcmd = true;</a>
<a name="ln1032">  }</a>
<a name="ln1033"> </a>
<a name="ln1034">  if (bangredo) {  // put cmd in redo buffer for ! command</a>
<a name="ln1035">    if (!prevcmd_is_set()) {</a>
<a name="ln1036">      goto theend;</a>
<a name="ln1037">    }</a>
<a name="ln1038"> </a>
<a name="ln1039">    // If % or # appears in the command, it must have been escaped.</a>
<a name="ln1040">    // Reescape them, so that redoing them does not substitute them by the</a>
<a name="ln1041">    // buffername.</a>
<a name="ln1042">    char *cmd = vim_strsave_escaped(prevcmd, &quot;%#&quot;);</a>
<a name="ln1043"> </a>
<a name="ln1044">    AppendToRedobuffLit(cmd, -1);</a>
<a name="ln1045">    xfree(cmd);</a>
<a name="ln1046">    AppendToRedobuff(&quot;\n&quot;);</a>
<a name="ln1047">    bangredo = false;</a>
<a name="ln1048">  }</a>
<a name="ln1049">  // Add quotes around the command, for shells that need them.</a>
<a name="ln1050">  if (*p_shq != NUL) {</a>
<a name="ln1051">    if (free_newcmd) {</a>
<a name="ln1052">      xfree(newcmd);</a>
<a name="ln1053">    }</a>
<a name="ln1054">    newcmd = xmalloc(strlen(prevcmd) + 2 * strlen(p_shq) + 1);</a>
<a name="ln1055">    STRCPY(newcmd, p_shq);</a>
<a name="ln1056">    STRCAT(newcmd, prevcmd);</a>
<a name="ln1057">    STRCAT(newcmd, p_shq);</a>
<a name="ln1058">    free_newcmd = true;</a>
<a name="ln1059">  }</a>
<a name="ln1060">  if (addr_count == 0) {                // :!</a>
<a name="ln1061">    // echo the command</a>
<a name="ln1062">    msg_start();</a>
<a name="ln1063">    msg_putchar(':');</a>
<a name="ln1064">    msg_putchar('!');</a>
<a name="ln1065">    msg_outtrans(newcmd, 0);</a>
<a name="ln1066">    msg_clr_eos();</a>
<a name="ln1067">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1068"> </a>
<a name="ln1069">    do_shell(newcmd, 0);</a>
<a name="ln1070">  } else {                            // :range!</a>
<a name="ln1071">    // Careful: This may recursively call do_bang() again! (because of</a>
<a name="ln1072">    // autocommands)</a>
<a name="ln1073">    do_filter(line1, line2, eap, newcmd, do_in, do_out);</a>
<a name="ln1074">    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">theend:</a>
<a name="ln1078">  if (free_newcmd) {</a>
<a name="ln1079">    xfree(newcmd);</a>
<a name="ln1080">  }</a>
<a name="ln1081">}</a>
<a name="ln1082"> </a>
<a name="ln1083">/// do_filter: filter lines through a command given by the user</a>
<a name="ln1084">///</a>
<a name="ln1085">/// We mostly use temp files and the call_shell() routine here. This would</a>
<a name="ln1086">/// normally be done using pipes on a Unix system, but this is more portable</a>
<a name="ln1087">/// to non-Unix systems. The call_shell() routine needs to be able</a>
<a name="ln1088">/// to deal with redirection somehow, and should handle things like looking</a>
<a name="ln1089">/// at the PATH env. variable, and adding reasonable extensions to the</a>
<a name="ln1090">/// command name given by the user. All reasonable versions of call_shell()</a>
<a name="ln1091">/// do this.</a>
<a name="ln1092">/// Alternatively, if on Unix and redirecting input or output, but not both,</a>
<a name="ln1093">/// and the 'shelltemp' option isn't set, use pipes.</a>
<a name="ln1094">/// We use input redirection if do_in is true.</a>
<a name="ln1095">/// We use output redirection if do_out is true.</a>
<a name="ln1096">///</a>
<a name="ln1097">/// @param eap  for forced 'ff' and 'fenc'</a>
<a name="ln1098">static void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char *cmd, bool do_in,</a>
<a name="ln1099">                      bool do_out)</a>
<a name="ln1100">{</a>
<a name="ln1101">  char *itmp = NULL;</a>
<a name="ln1102">  char *otmp = NULL;</a>
<a name="ln1103">  linenr_T linecount;</a>
<a name="ln1104">  linenr_T read_linecount;</a>
<a name="ln1105">  pos_T cursor_save;</a>
<a name="ln1106">  char *cmd_buf;</a>
<a name="ln1107">  buf_T *old_curbuf = curbuf;</a>
<a name="ln1108">  int shell_flags = 0;</a>
<a name="ln1109">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln1110">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln1111">  const int stmp = p_stmp;</a>
<a name="ln1112"> </a>
<a name="ln1113">  if (*cmd == NUL) {        // no filter command</a>
<a name="ln1114">    return;</a>
<a name="ln1115">  }</a>
<a name="ln1116"> </a>
<a name="ln1117">  const int save_cmod_flags = cmdmod.cmod_flags;</a>
<a name="ln1118">  // Temporarily disable lockmarks since that's needed to propagate changed</a>
<a name="ln1119">  // regions of the buffer for foldUpdate(), linecount, etc.</a>
<a name="ln1120">  cmdmod.cmod_flags &amp;= ~CMOD_LOCKMARKS;</a>
<a name="ln1121"> </a>
<a name="ln1122">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1123">  linecount = line2 - line1 + 1;</a>
<a name="ln1124">  curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1125">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1126">  changed_line_abv_curs();</a>
<a name="ln1127">  invalidate_botline(curwin);</a>
<a name="ln1128"> </a>
<a name="ln1129">  // When using temp files:</a>
<a name="ln1130">  // 1. * Form temp file names</a>
<a name="ln1131">  // 2. * Write the lines to a temp file</a>
<a name="ln1132">  // 3.   Run the filter command on the temp file</a>
<a name="ln1133">  // 4. * Read the output of the command into the buffer</a>
<a name="ln1134">  // 5. * Delete the original lines to be filtered</a>
<a name="ln1135">  // 6. * Remove the temp files</a>
<a name="ln1136">  //</a>
<a name="ln1137">  // When writing the input with a pipe or when catching the output with a</a>
<a name="ln1138">  // pipe only need to do 3.</a>
<a name="ln1139"> </a>
<a name="ln1140">  if (do_out) {</a>
<a name="ln1141">    shell_flags |= kShellOptDoOut;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  if (!do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1145">    // Use a pipe to fetch stdout of the command, do not use a temp file.</a>
<a name="ln1146">    shell_flags |= kShellOptRead;</a>
<a name="ln1147">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1148">  } else if (do_in &amp;&amp; !do_out &amp;&amp; !stmp) {</a>
<a name="ln1149">    // Use a pipe to write stdin of the command, do not use a temp file.</a>
<a name="ln1150">    shell_flags |= kShellOptWrite;</a>
<a name="ln1151">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1152">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1153">  } else if (do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1154">    // Use a pipe to write stdin and fetch stdout of the command, do not</a>
<a name="ln1155">    // use a temp file.</a>
<a name="ln1156">    shell_flags |= kShellOptRead | kShellOptWrite;</a>
<a name="ln1157">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1158">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1159">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1160">  } else if ((do_in &amp;&amp; (itmp = vim_tempname()) == NULL)</a>
<a name="ln1161">             || (do_out &amp;&amp; (otmp = vim_tempname()) == NULL)) {</a>
<a name="ln1162">    emsg(_(e_notmp));</a>
<a name="ln1163">    goto filterend;</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">  // The writing and reading of temp files will not be shown.</a>
<a name="ln1167">  // Vi also doesn't do this and the messages are not very informative.</a>
<a name="ln1168">  no_wait_return++;             // don't call wait_return() while busy</a>
<a name="ln1169">  if (itmp != NULL &amp;&amp; buf_write(curbuf, itmp, NULL, line1, line2, eap,</a>
<a name="ln1170">                                false, false, false, true) == FAIL) {</a>
<a name="ln1171">    msg_putchar('\n');  // Keep message from buf_write().</a>
<a name="ln1172">    no_wait_return--;</a>
<a name="ln1173">    if (!aborting()) {</a>
<a name="ln1174">      // will call wait_return()</a>
<a name="ln1175">      semsg(_(&quot;E482: Can't create file %s&quot;), itmp);</a>
<a name="ln1176">    }</a>
<a name="ln1177">    goto filterend;</a>
<a name="ln1178">  }</a>
<a name="ln1179">  if (curbuf != old_curbuf) {</a>
<a name="ln1180">    goto filterend;</a>
<a name="ln1181">  }</a>
<a name="ln1182"> </a>
<a name="ln1183">  if (!do_out) {</a>
<a name="ln1184">    msg_putchar('\n');</a>
<a name="ln1185">  }</a>
<a name="ln1186"> </a>
<a name="ln1187">  // Create the shell command in allocated memory.</a>
<a name="ln1188">  cmd_buf = make_filter_cmd(cmd, itmp, otmp);</a>
<a name="ln1189">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln1190"> </a>
<a name="ln1191">  if (do_out) {</a>
<a name="ln1192">    if (u_save(line2, (linenr_T)(line2 + 1)) == FAIL) {</a>
<a name="ln1193">      xfree(cmd_buf);</a>
<a name="ln1194">      goto error;</a>
<a name="ln1195">    }</a>
<a name="ln1196">    redraw_curbuf_later(UPD_VALID);</a>
<a name="ln1197">  }</a>
<a name="ln1198">  read_linecount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1199"> </a>
<a name="ln1200">  // Pass on the kShellOptDoOut flag when the output is being redirected.</a>
<a name="ln1201">  call_shell(cmd_buf, (ShellOpts)(kShellOptFilter | shell_flags), NULL);</a>
<a name="ln1202">  xfree(cmd_buf);</a>
<a name="ln1203"> </a>
<a name="ln1204">  did_check_timestamps = false;</a>
<a name="ln1205">  need_check_timestamps = true;</a>
<a name="ln1206"> </a>
<a name="ln1207">  // When interrupting the shell command, it may still have produced some</a>
<a name="ln1208">  // useful output.  Reset got_int here, so that readfile() won't cancel</a>
<a name="ln1209">  // reading.</a>
<a name="ln1210">  os_breakcheck();</a>
<a name="ln1211">  got_int = false;</a>
<a name="ln1212"> </a>
<a name="ln1213">  if (do_out) {</a>
<a name="ln1214">    if (otmp != NULL) {</a>
<a name="ln1215">      if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln1216">                   READ_FILTER, false) != OK) {</a>
<a name="ln1217">        if (!aborting()) {</a>
<a name="ln1218">          msg_putchar('\n');</a>
<a name="ln1219">          semsg(_(e_notread), otmp);</a>
<a name="ln1220">        }</a>
<a name="ln1221">        goto error;</a>
<a name="ln1222">      }</a>
<a name="ln1223">      if (curbuf != old_curbuf) {</a>
<a name="ln1224">        goto filterend;</a>
<a name="ln1225">      }</a>
<a name="ln1226">    }</a>
<a name="ln1227"> </a>
<a name="ln1228">    read_linecount = curbuf-&gt;b_ml.ml_line_count - read_linecount;</a>
<a name="ln1229"> </a>
<a name="ln1230">    if (shell_flags &amp; kShellOptRead) {</a>
<a name="ln1231">      curbuf-&gt;b_op_start.lnum = line2 + 1;</a>
<a name="ln1232">      curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1233">      appended_lines_mark(line2, read_linecount);</a>
<a name="ln1234">    }</a>
<a name="ln1235"> </a>
<a name="ln1236">    if (do_in) {</a>
<a name="ln1237">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPMARKS)</a>
<a name="ln1238">          || vim_strchr(p_cpo, CPO_REMMARK) == NULL) {</a>
<a name="ln1239">        // TODO(bfredl): Currently not active for extmarks. What would we</a>
<a name="ln1240">        // do if columns don't match, assume added/deleted bytes at the</a>
<a name="ln1241">        // end of each line?</a>
<a name="ln1242">        if (read_linecount &gt;= linecount) {</a>
<a name="ln1243">          // move all marks from old lines to new lines</a>
<a name="ln1244">          mark_adjust(line1, line2, linecount, 0L, kExtmarkNOOP);</a>
<a name="ln1245">        } else {</a>
<a name="ln1246">          // move marks from old lines to new lines, delete marks</a>
<a name="ln1247">          // that are in deleted lines</a>
<a name="ln1248">          mark_adjust(line1, line1 + read_linecount - 1, linecount, 0L,</a>
<a name="ln1249">                      kExtmarkNOOP);</a>
<a name="ln1250">          mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L,</a>
<a name="ln1251">                      kExtmarkNOOP);</a>
<a name="ln1252">        }</a>
<a name="ln1253">      }</a>
<a name="ln1254"> </a>
<a name="ln1255">      // Put cursor on first filtered line for &quot;:range!cmd&quot;.</a>
<a name="ln1256">      // Adjust '[ and '] (set by buf_write()).</a>
<a name="ln1257">      curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1258">      del_lines(linecount, true);</a>
<a name="ln1259">      curbuf-&gt;b_op_start.lnum -= linecount;             // adjust '[</a>
<a name="ln1260">      curbuf-&gt;b_op_end.lnum -= linecount;               // adjust ']</a>
<a name="ln1261">      write_lnum_adjust(-linecount);                    // adjust last line</a>
<a name="ln1262">                                                        // for next write</a>
<a name="ln1263">      foldUpdate(curwin, curbuf-&gt;b_op_start.lnum, curbuf-&gt;b_op_end.lnum);</a>
<a name="ln1264">    } else {</a>
<a name="ln1265">      // Put cursor on last new line for &quot;:r !cmd&quot;.</a>
<a name="ln1266">      linecount = curbuf-&gt;b_op_end.lnum - curbuf-&gt;b_op_start.lnum + 1;</a>
<a name="ln1267">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_op_end.lnum;</a>
<a name="ln1268">    }</a>
<a name="ln1269"> </a>
<a name="ln1270">    beginline(BL_WHITE | BL_FIX);           // cursor on first non-blank</a>
<a name="ln1271">    no_wait_return--;</a>
<a name="ln1272"> </a>
<a name="ln1273">    if (linecount &gt; p_report) {</a>
<a name="ln1274">      if (do_in) {</a>
<a name="ln1275">        vim_snprintf(msg_buf, sizeof(msg_buf),</a>
<a name="ln1276">                     _(&quot;%&quot; PRId64 &quot; lines filtered&quot;), (int64_t)linecount);</a>
<a name="ln1277">        if (msg(msg_buf, 0) &amp;&amp; !msg_scroll) {</a>
<a name="ln1278">          // save message to display it after redraw</a>
<a name="ln1279">          set_keep_msg(msg_buf, 0);</a>
<a name="ln1280">        }</a>
<a name="ln1281">      } else {</a>
<a name="ln1282">        msgmore((long)linecount);</a>
<a name="ln1283">      }</a>
<a name="ln1284">    }</a>
<a name="ln1285">  } else {</a>
<a name="ln1286">error:</a>
<a name="ln1287">    // put cursor back in same position for &quot;:w !cmd&quot;</a>
<a name="ln1288">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1289">    no_wait_return--;</a>
<a name="ln1290">    wait_return(false);</a>
<a name="ln1291">  }</a>
<a name="ln1292"> </a>
<a name="ln1293">filterend:</a>
<a name="ln1294"> </a>
<a name="ln1295">  cmdmod.cmod_flags = save_cmod_flags;</a>
<a name="ln1296">  if (curbuf != old_curbuf) {</a>
<a name="ln1297">    no_wait_return--;</a>
<a name="ln1298">    emsg(_(&quot;E135: *Filter* Autocommands must not change current buffer&quot;));</a>
<a name="ln1299">  } else if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln1300">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln1301">    curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln1302">  }</a>
<a name="ln1303"> </a>
<a name="ln1304">  if (itmp != NULL) {</a>
<a name="ln1305">    os_remove(itmp);</a>
<a name="ln1306">  }</a>
<a name="ln1307">  if (otmp != NULL) {</a>
<a name="ln1308">    os_remove(otmp);</a>
<a name="ln1309">  }</a>
<a name="ln1310">  xfree(itmp);</a>
<a name="ln1311">  xfree(otmp);</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">/// Call a shell to execute a command.</a>
<a name="ln1315">/// When &quot;cmd&quot; is NULL start an interactive shell.</a>
<a name="ln1316">///</a>
<a name="ln1317">/// @param flags  may be SHELL_DOOUT when output is redirected</a>
<a name="ln1318">void do_shell(char *cmd, int flags)</a>
<a name="ln1319">{</a>
<a name="ln1320">  // Disallow shell commands in secure mode</a>
<a name="ln1321">  if (check_secure()) {</a>
<a name="ln1322">    msg_end();</a>
<a name="ln1323">    return;</a>
<a name="ln1324">  }</a>
<a name="ln1325"> </a>
<a name="ln1326">  // For autocommands we want to get the output on the current screen, to</a>
<a name="ln1327">  // avoid having to type return below.</a>
<a name="ln1328">  msg_putchar('\r');                    // put cursor at start of line</a>
<a name="ln1329">  msg_putchar('\n');                    // may shift screen one line up</a>
<a name="ln1330"> </a>
<a name="ln1331">  // warning message before calling the shell</a>
<a name="ln1332">  if (p_warn</a>
<a name="ln1333">      &amp;&amp; !autocmd_busy</a>
<a name="ln1334">      &amp;&amp; msg_silent == 0) {</a>
<a name="ln1335">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1336">      if (bufIsChanged(buf)) {</a>
<a name="ln1337">        msg_puts(_(&quot;[No write since last change]\n&quot;));</a>
<a name="ln1338">        break;</a>
<a name="ln1339">      }</a>
<a name="ln1340">    }</a>
<a name="ln1341">  }</a>
<a name="ln1342"> </a>
<a name="ln1343">  // This ui_cursor_goto is required for when the '\n' resulted in a &quot;delete line</a>
<a name="ln1344">  // 1&quot; command to the terminal.</a>
<a name="ln1345">  ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1346">  (void)call_shell(cmd, (ShellOpts)flags, NULL);</a>
<a name="ln1347">  msg_didout = true;</a>
<a name="ln1348">  did_check_timestamps = false;</a>
<a name="ln1349">  need_check_timestamps = true;</a>
<a name="ln1350"> </a>
<a name="ln1351">  // put the message cursor at the end of the screen, avoids wait_return()</a>
<a name="ln1352">  // to overwrite the text that the external command showed</a>
<a name="ln1353">  msg_row = Rows - 1;</a>
<a name="ln1354">  msg_col = 0;</a>
<a name="ln1355"> </a>
<a name="ln1356">  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">#if !defined(UNIX)</a>
<a name="ln1360">static char *find_pipe(const char *cmd)</a>
<a name="ln1361">{</a>
<a name="ln1362">  bool inquote = false;</a>
<a name="ln1363"> </a>
<a name="ln1364">  for (const char *p = cmd; *p != NUL; p++) {</a>
<a name="ln1365">    if (!inquote &amp;&amp; *p == '|') {</a>
<a name="ln1366">      return (char *)p;</a>
<a name="ln1367">    }</a>
<a name="ln1368">    if (*p == '&quot;') {</a>
<a name="ln1369">      inquote = !inquote;</a>
<a name="ln1370">    } else if (rem_backslash(p)) {</a>
<a name="ln1371">      p++;</a>
<a name="ln1372">    }</a>
<a name="ln1373">  }</a>
<a name="ln1374">  return NULL;</a>
<a name="ln1375">}</a>
<a name="ln1376">#endif</a>
<a name="ln1377"> </a>
<a name="ln1378">/// Create a shell command from a command string, input redirection file and</a>
<a name="ln1379">/// output redirection file.</a>
<a name="ln1380">///</a>
<a name="ln1381">/// @param cmd  Command to execute.</a>
<a name="ln1382">/// @param itmp NULL or the input file.</a>
<a name="ln1383">/// @param otmp NULL or the output file.</a>
<a name="ln1384">/// @returns an allocated string with the shell command.</a>
<a name="ln1385">char *make_filter_cmd(char *cmd, char *itmp, char *otmp)</a>
<a name="ln1386">{</a>
<a name="ln1387">  bool is_fish_shell =</a>
<a name="ln1388">#if defined(UNIX)</a>
<a name="ln1389">    strncmp(invocation_path_tail(p_sh, NULL), &quot;fish&quot;, 4) == 0;</a>
<a name="ln1390">#else</a>
<a name="ln1391">    false;</a>
<a name="ln1392">#endif</a>
<a name="ln1393">  bool is_pwsh = strncmp(invocation_path_tail(p_sh, NULL), &quot;pwsh&quot;, 4) == 0</a>
<a name="ln1394">                 || strncmp(invocation_path_tail(p_sh, NULL), &quot;powershell&quot;,</a>
<a name="ln1395">                            10) == 0;</a>
<a name="ln1396"> </a>
<a name="ln1397">  size_t len = strlen(cmd) + 1;  // At least enough space for cmd + NULL.</a>
<a name="ln1398"> </a>
<a name="ln1399">  len += is_fish_shell ? sizeof(&quot;begin; &quot; &quot;; end&quot;) - 1</a>
<a name="ln1400">                       : !is_pwsh ? sizeof(&quot;(&quot; &quot;)&quot;) - 1</a>
<a name="ln1401">                                  : 0;</a>
<a name="ln1402"> </a>
<a name="ln1403">  if (itmp != NULL) {</a>
<a name="ln1404">    len += is_pwsh ? strlen(itmp) + sizeof(&quot;&amp; { Get-Content &quot; &quot; | &amp; &quot; &quot; }&quot;) - 1 + 6  // +6: #20530</a>
<a name="ln1405">                    : strlen(itmp) + sizeof(&quot; { &quot; &quot; &lt; &quot; &quot; } &quot;) - 1;</a>
<a name="ln1406">  }</a>
<a name="ln1407">  if (otmp != NULL) {</a>
<a name="ln1408">    len += strlen(otmp) + strlen(p_srr) + 2;  // two extra spaces (&quot;  &quot;),</a>
<a name="ln1409">  }</a>
<a name="ln1410"> </a>
<a name="ln1411">  char *const buf = xmalloc(len);</a>
<a name="ln1412"> </a>
<a name="ln1413">  if (is_pwsh) {</a>
<a name="ln1414">    if (itmp != NULL) {</a>
<a name="ln1415">      xstrlcpy(buf, &quot;&amp; { Get-Content &quot;, len - 1);  // FIXME: should we add &quot;-Encoding utf8&quot;?</a>
<a name="ln1416">      xstrlcat(buf, itmp, len - 1);</a>
<a name="ln1417">      xstrlcat(buf, &quot; | &amp; &quot;, len - 1);  // FIXME: add `&amp;` ourself or leave to user?</a>
<a name="ln1418">      xstrlcat(buf, cmd, len - 1);</a>
<a name="ln1419">      xstrlcat(buf, &quot; }&quot;, len - 1);</a>
<a name="ln1420">    } else {</a>
<a name="ln1421">      xstrlcpy(buf, cmd, len - 1);</a>
<a name="ln1422">    }</a>
<a name="ln1423">  } else {</a>
<a name="ln1424">#if defined(UNIX)</a>
<a name="ln1425">    // Put delimiters around the command (for concatenated commands) when</a>
<a name="ln1426">    // redirecting input and/or output.</a>
<a name="ln1427">    if (itmp != NULL || otmp != NULL) {</a>
<a name="ln1428">      char *fmt = is_fish_shell ? &quot;begin; %s; end&quot;</a>
<a name="ln1429">        : &quot;(%s)&quot;;</a>
<a name="ln1430">      vim_snprintf(buf, len, fmt, cmd);</a>
<a name="ln1431">    } else {</a>
<a name="ln1432">      xstrlcpy(buf, cmd, len);</a>
<a name="ln1433">    }</a>
<a name="ln1434"> </a>
<a name="ln1435">    if (itmp != NULL) {</a>
<a name="ln1436">      xstrlcat(buf, &quot; &lt; &quot;, len - 1);</a>
<a name="ln1437">      xstrlcat(buf, itmp, len - 1);</a>
<a name="ln1438">    }</a>
<a name="ln1439">#else</a>
<a name="ln1440">    // For shells that don't understand braces around commands, at least allow</a>
<a name="ln1441">    // the use of commands in a pipe.</a>
<a name="ln1442">    xstrlcpy(buf, cmd, len);</a>
<a name="ln1443">    if (itmp != NULL) {</a>
<a name="ln1444">      // If there is a pipe, we have to put the '&lt;' in front of it.</a>
<a name="ln1445">      // Don't do this when 'shellquote' is not empty, otherwise the</a>
<a name="ln1446">      // redirection would be inside the quotes.</a>
<a name="ln1447">      if (*p_shq == NUL) {</a>
<a name="ln1448">        char *const p = find_pipe(buf);</a>
<a name="ln1449">        if (p != NULL) {</a>
<a name="ln1450">          *p = NUL;</a>
<a name="ln1451">        }</a>
<a name="ln1452">      }</a>
<a name="ln1453">      xstrlcat(buf, &quot; &lt; &quot;, len);</a>
<a name="ln1454">      xstrlcat(buf, itmp, len);</a>
<a name="ln1455">      if (*p_shq == NUL) {</a>
<a name="ln1456">        const char *const p = find_pipe(cmd);</a>
<a name="ln1457">        if (p != NULL) {</a>
<a name="ln1458">          xstrlcat(buf, &quot; &quot;, len - 1);  // Insert a space before the '|' for DOS</a>
<a name="ln1459">          xstrlcat(buf, p, len - 1);</a>
<a name="ln1460">        }</a>
<a name="ln1461">      }</a>
<a name="ln1462">    }</a>
<a name="ln1463">#endif</a>
<a name="ln1464">  }</a>
<a name="ln1465">  if (otmp != NULL) {</a>
<a name="ln1466">    append_redir(buf, len, p_srr, otmp);</a>
<a name="ln1467">  }</a>
<a name="ln1468">  return buf;</a>
<a name="ln1469">}</a>
<a name="ln1470"> </a>
<a name="ln1471">/// Append output redirection for the given file to the end of the buffer</a>
<a name="ln1472">///</a>
<a name="ln1473">/// @param[out]  buf  Buffer to append to.</a>
<a name="ln1474">/// @param[in]  buflen  Buffer length.</a>
<a name="ln1475">/// @param[in]  opt  Separator or format string to append: will append</a>
<a name="ln1476">///                  `printf(' ' . opt, fname)` if `%s` is found in `opt` or</a>
<a name="ln1477">///                  a space, opt, a space and then fname if `%s` is not found</a>
<a name="ln1478">///                  there.</a>
<a name="ln1479">/// @param[in]  fname  File name to append.</a>
<a name="ln1480">void append_redir(char *const buf, const size_t buflen, const char *const opt,</a>
<a name="ln1481">                  const char *const fname)</a>
<a name="ln1482">{</a>
<a name="ln1483">  char *const end = buf + strlen(buf);</a>
<a name="ln1484">  // find &quot;%s&quot;</a>
<a name="ln1485">  const char *p = opt;</a>
<a name="ln1486">  for (; (p = strchr(p, '%')) != NULL; p++) {</a>
<a name="ln1487">    if (p[1] == 's') {  // found %s</a>
<a name="ln1488">      break;</a>
<a name="ln1489">    } else if (p[1] == '%') {  // skip %%</a>
<a name="ln1490">      p++;</a>
<a name="ln1491">    }</a>
<a name="ln1492">  }</a>
<a name="ln1493">  if (p != NULL) {</a>
<a name="ln1494">    *end = ' ';  // not really needed? Not with sh, ksh or bash</a>
<a name="ln1495">    vim_snprintf(end + 1, (size_t)((ptrdiff_t)buflen - (end + 1 - buf)), opt, fname);</a>
<a name="ln1496">  } else {</a>
<a name="ln1497">    vim_snprintf(end, (size_t)((ptrdiff_t)buflen - (end - buf)), &quot; %s %s&quot;, opt, fname);</a>
<a name="ln1498">  }</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">void print_line_no_prefix(linenr_T lnum, int use_number, int list)</a>
<a name="ln1502">{</a>
<a name="ln1503">  char numbuf[30];</a>
<a name="ln1504"> </a>
<a name="ln1505">  if (curwin-&gt;w_p_nu || use_number) {</a>
<a name="ln1506">    vim_snprintf(numbuf, sizeof(numbuf), &quot;%*&quot; PRIdLINENR &quot; &quot;,</a>
<a name="ln1507">                 number_width(curwin), lnum);</a>
<a name="ln1508">    msg_puts_attr(numbuf, HL_ATTR(HLF_N));  // Highlight line nrs.</a>
<a name="ln1509">  }</a>
<a name="ln1510">  msg_prt_line(ml_get(lnum), list);</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513">/// Print a text line.  Also in silent mode (&quot;ex -s&quot;).</a>
<a name="ln1514">void print_line(linenr_T lnum, int use_number, int list)</a>
<a name="ln1515">{</a>
<a name="ln1516">  int save_silent = silent_mode;</a>
<a name="ln1517"> </a>
<a name="ln1518">  // apply :filter /pat/</a>
<a name="ln1519">  if (message_filtered(ml_get(lnum))) {</a>
<a name="ln1520">    return;</a>
<a name="ln1521">  }</a>
<a name="ln1522"> </a>
<a name="ln1523">  msg_start();</a>
<a name="ln1524">  silent_mode = false;</a>
<a name="ln1525">  info_message = true;  // use os_msg(), not os_errmsg()</a>
<a name="ln1526">  print_line_no_prefix(lnum, use_number, list);</a>
<a name="ln1527">  if (save_silent) {</a>
<a name="ln1528">    msg_putchar('\n');</a>
<a name="ln1529">    silent_mode = save_silent;</a>
<a name="ln1530">  }</a>
<a name="ln1531">  info_message = false;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">int rename_buffer(char *new_fname)</a>
<a name="ln1535">{</a>
<a name="ln1536">  char *fname, *sfname, *xfname;</a>
<a name="ln1537">  buf_T *buf;</a>
<a name="ln1538"> </a>
<a name="ln1539">  buf = curbuf;</a>
<a name="ln1540">  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, curbuf);</a>
<a name="ln1541">  // buffer changed, don't change name now</a>
<a name="ln1542">  if (buf != curbuf) {</a>
<a name="ln1543">    return FAIL;</a>
<a name="ln1544">  }</a>
<a name="ln1545">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln1546">    return FAIL;</a>
<a name="ln1547">  }</a>
<a name="ln1548">  // The name of the current buffer will be changed.</a>
<a name="ln1549">  // A new (unlisted) buffer entry needs to be made to hold the old file</a>
<a name="ln1550">  // name, which will become the alternate file name.</a>
<a name="ln1551">  // But don't set the alternate file name if the buffer didn't have a</a>
<a name="ln1552">  // name.</a>
<a name="ln1553">  fname = curbuf-&gt;b_ffname;</a>
<a name="ln1554">  sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1555">  xfname = curbuf-&gt;b_fname;</a>
<a name="ln1556">  curbuf-&gt;b_ffname = NULL;</a>
<a name="ln1557">  curbuf-&gt;b_sfname = NULL;</a>
<a name="ln1558">  if (setfname(curbuf, new_fname, NULL, true) == FAIL) {</a>
<a name="ln1559">    curbuf-&gt;b_ffname = fname;</a>
<a name="ln1560">    curbuf-&gt;b_sfname = sfname;</a>
<a name="ln1561">    return FAIL;</a>
<a name="ln1562">  }</a>
<a name="ln1563">  curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln1564">  if (xfname != NULL &amp;&amp; *xfname != NUL) {</a>
<a name="ln1565">    buf = buflist_new(fname, xfname, curwin-&gt;w_cursor.lnum, 0);</a>
<a name="ln1566">    if (buf != NULL &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln1567">      curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln1568">    }</a>
<a name="ln1569">  }</a>
<a name="ln1570">  xfree(fname);</a>
<a name="ln1571">  xfree(sfname);</a>
<a name="ln1572">  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1573">  // Change directories when the 'acd' option is set.</a>
<a name="ln1574">  do_autochdir();</a>
<a name="ln1575">  return OK;</a>
<a name="ln1576">}</a>
<a name="ln1577"> </a>
<a name="ln1578">/// &quot;:file[!] [fname]&quot;.</a>
<a name="ln1579">void ex_file(exarg_T *eap)</a>
<a name="ln1580">{</a>
<a name="ln1581">  // &quot;:0file&quot; removes the file name.  Check for illegal uses &quot;:3file&quot;,</a>
<a name="ln1582">  // &quot;0file name&quot;, etc.</a>
<a name="ln1583">  if (eap-&gt;addr_count &gt; 0</a>
<a name="ln1584">      &amp;&amp; (*eap-&gt;arg != NUL</a>
<a name="ln1585">          || eap-&gt;line2 &gt; 0</a>
<a name="ln1586">          || eap-&gt;addr_count &gt; 1)) {</a>
<a name="ln1587">    emsg(_(e_invarg));</a>
<a name="ln1588">    return;</a>
<a name="ln1589">  }</a>
<a name="ln1590"> </a>
<a name="ln1591">  if (*eap-&gt;arg != NUL || eap-&gt;addr_count == 1) {</a>
<a name="ln1592">    if (rename_buffer(eap-&gt;arg) == FAIL) {</a>
<a name="ln1593">      return;</a>
<a name="ln1594">    }</a>
<a name="ln1595">    redraw_tabline = true;</a>
<a name="ln1596">  }</a>
<a name="ln1597"> </a>
<a name="ln1598">  // print file name if no argument or 'F' is not in 'shortmess'</a>
<a name="ln1599">  if (*eap-&gt;arg == NUL || !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1600">    fileinfo(false, false, eap-&gt;forceit);</a>
<a name="ln1601">  }</a>
<a name="ln1602">}</a>
<a name="ln1603"> </a>
<a name="ln1604">/// &quot;:update&quot;.</a>
<a name="ln1605">void ex_update(exarg_T *eap)</a>
<a name="ln1606">{</a>
<a name="ln1607">  if (curbufIsChanged()) {</a>
<a name="ln1608">    (void)do_write(eap);</a>
<a name="ln1609">  }</a>
<a name="ln1610">}</a>
<a name="ln1611"> </a>
<a name="ln1612">/// &quot;:write&quot; and &quot;:saveas&quot;.</a>
<a name="ln1613">void ex_write(exarg_T *eap)</a>
<a name="ln1614">{</a>
<a name="ln1615">  if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1616">    // :saveas does not take a range, uses all lines.</a>
<a name="ln1617">    eap-&gt;line1 = 1;</a>
<a name="ln1618">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1619">  }</a>
<a name="ln1620"> </a>
<a name="ln1621">  if (eap-&gt;usefilter) {  // input lines to shell command</a>
<a name="ln1622">    do_bang(1, eap, false, true, false);</a>
<a name="ln1623">  } else {</a>
<a name="ln1624">    (void)do_write(eap);</a>
<a name="ln1625">  }</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">#ifdef UNIX</a>
<a name="ln1629">static int check_writable(const char *fname)</a>
<a name="ln1630">{</a>
<a name="ln1631">  if (os_nodetype(fname) == NODE_OTHER) {</a>
<a name="ln1632">    semsg(_(&quot;E503: \&quot;%s\&quot; is not a file or writable device&quot;), fname);</a>
<a name="ln1633">    return FAIL;</a>
<a name="ln1634">  }</a>
<a name="ln1635">  return OK;</a>
<a name="ln1636">}</a>
<a name="ln1637">#endif</a>
<a name="ln1638"> </a>
<a name="ln1639">/// Write current buffer to file &quot;eap-&gt;arg&quot;.</a>
<a name="ln1640">/// If &quot;eap-&gt;append&quot; is true, append to the file.</a>
<a name="ln1641">///</a>
<a name="ln1642">/// If &quot;*eap-&gt;arg == NUL&quot; write to current file.</a>
<a name="ln1643">///</a>
<a name="ln1644">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln1645">int do_write(exarg_T *eap)</a>
<a name="ln1646">{</a>
<a name="ln1647">  int other;</a>
<a name="ln1648">  char *fname = NULL;            // init to shut up gcc</a>
<a name="ln1649">  char *ffname;</a>
<a name="ln1650">  int retval = FAIL;</a>
<a name="ln1651">  char *free_fname = NULL;</a>
<a name="ln1652">  buf_T *alt_buf = NULL;</a>
<a name="ln1653">  int name_was_missing;</a>
<a name="ln1654"> </a>
<a name="ln1655">  if (not_writing()) {          // check 'write' option</a>
<a name="ln1656">    return FAIL;</a>
<a name="ln1657">  }</a>
<a name="ln1658"> </a>
<a name="ln1659">  ffname = eap-&gt;arg;</a>
<a name="ln1660">  if (*ffname == NUL) {</a>
<a name="ln1661">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1662">      emsg(_(e_argreq));</a>
<a name="ln1663">      goto theend;</a>
<a name="ln1664">    }</a>
<a name="ln1665">    other = false;</a>
<a name="ln1666">  } else {</a>
<a name="ln1667">    fname = ffname;</a>
<a name="ln1668">    free_fname = fix_fname(ffname);</a>
<a name="ln1669">    // When out-of-memory, keep unexpanded file name, because we MUST be</a>
<a name="ln1670">    // able to write the file in this situation.</a>
<a name="ln1671">    if (free_fname != NULL) {</a>
<a name="ln1672">      ffname = free_fname;</a>
<a name="ln1673">    }</a>
<a name="ln1674">    other = otherfile(ffname);</a>
<a name="ln1675">  }</a>
<a name="ln1676"> </a>
<a name="ln1677">  // If we have a new file, put its name in the list of alternate file names.</a>
<a name="ln1678">  if (other) {</a>
<a name="ln1679">    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL</a>
<a name="ln1680">        || eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1681">      alt_buf = setaltfname(ffname, fname, (linenr_T)1);</a>
<a name="ln1682">    } else {</a>
<a name="ln1683">      alt_buf = buflist_findname(ffname);</a>
<a name="ln1684">    }</a>
<a name="ln1685">    if (alt_buf != NULL &amp;&amp; alt_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln1686">      // Overwriting a file that is loaded in another buffer is not a</a>
<a name="ln1687">      // good idea.</a>
<a name="ln1688">      emsg(_(e_bufloaded));</a>
<a name="ln1689">      goto theend;</a>
<a name="ln1690">    }</a>
<a name="ln1691">  }</a>
<a name="ln1692"> </a>
<a name="ln1693">  // Writing to the current file is not allowed in readonly mode</a>
<a name="ln1694">  // and a file name is required.</a>
<a name="ln1695">  // &quot;nofile&quot; and &quot;nowrite&quot; buffers cannot be written implicitly either.</a>
<a name="ln1696">  if (!other &amp;&amp; (bt_dontwrite_msg(curbuf)</a>
<a name="ln1697">                 || check_fname() == FAIL</a>
<a name="ln1698">#ifdef UNIX</a>
<a name="ln1699">                 || check_writable(curbuf-&gt;b_ffname) == FAIL</a>
<a name="ln1700">#endif</a>
<a name="ln1701">                 || check_readonly(&amp;eap-&gt;forceit, curbuf))) {</a>
<a name="ln1702">    goto theend;</a>
<a name="ln1703">  }</a>
<a name="ln1704"> </a>
<a name="ln1705">  if (!other) {</a>
<a name="ln1706">    ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1707">    fname = curbuf-&gt;b_fname;</a>
<a name="ln1708">    // Not writing the whole file is only allowed with '!'.</a>
<a name="ln1709">    if ((eap-&gt;line1 != 1</a>
<a name="ln1710">         || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1711">        &amp;&amp; !eap-&gt;forceit</a>
<a name="ln1712">        &amp;&amp; !eap-&gt;append</a>
<a name="ln1713">        &amp;&amp; !p_wa) {</a>
<a name="ln1714">      if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1715">        if (vim_dialog_yesno(VIM_QUESTION, NULL,</a>
<a name="ln1716">                             _(&quot;Write partial file?&quot;), 2) != VIM_YES) {</a>
<a name="ln1717">          goto theend;</a>
<a name="ln1718">        }</a>
<a name="ln1719">        eap-&gt;forceit = true;</a>
<a name="ln1720">      } else {</a>
<a name="ln1721">        emsg(_(&quot;E140: Use ! to write partial buffer&quot;));</a>
<a name="ln1722">        goto theend;</a>
<a name="ln1723">      }</a>
<a name="ln1724">    }</a>
<a name="ln1725">  }</a>
<a name="ln1726"> </a>
<a name="ln1727">  if (check_overwrite(eap, curbuf, fname, ffname, other) == OK) {</a>
<a name="ln1728">    if (eap-&gt;cmdidx == CMD_saveas &amp;&amp; alt_buf != NULL) {</a>
<a name="ln1729">      buf_T *was_curbuf = curbuf;</a>
<a name="ln1730"> </a>
<a name="ln1731">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, curbuf);</a>
<a name="ln1732">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, alt_buf);</a>
<a name="ln1733">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1734">        // buffer changed, don't change name now</a>
<a name="ln1735">        retval = FAIL;</a>
<a name="ln1736">        goto theend;</a>
<a name="ln1737">      }</a>
<a name="ln1738">      // Exchange the file names for the current and the alternate</a>
<a name="ln1739">      // buffer.  This makes it look like we are now editing the buffer</a>
<a name="ln1740">      // under the new name.  Must be done before buf_write(), because</a>
<a name="ln1741">      // if there is no file name and 'cpo' contains 'F', it will set</a>
<a name="ln1742">      // the file name.</a>
<a name="ln1743">      fname = alt_buf-&gt;b_fname;</a>
<a name="ln1744">      alt_buf-&gt;b_fname = curbuf-&gt;b_fname;</a>
<a name="ln1745">      curbuf-&gt;b_fname = fname;</a>
<a name="ln1746">      fname = alt_buf-&gt;b_ffname;</a>
<a name="ln1747">      alt_buf-&gt;b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1748">      curbuf-&gt;b_ffname = fname;</a>
<a name="ln1749">      fname = alt_buf-&gt;b_sfname;</a>
<a name="ln1750">      alt_buf-&gt;b_sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1751">      curbuf-&gt;b_sfname = fname;</a>
<a name="ln1752">      buf_name_changed(curbuf);</a>
<a name="ln1753">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1754">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, alt_buf);</a>
<a name="ln1755">      if (!alt_buf-&gt;b_p_bl) {</a>
<a name="ln1756">        alt_buf-&gt;b_p_bl = true;</a>
<a name="ln1757">        apply_autocmds(EVENT_BUFADD, NULL, NULL, false, alt_buf);</a>
<a name="ln1758">      }</a>
<a name="ln1759">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1760">        // buffer changed, don't write the file</a>
<a name="ln1761">        retval = FAIL;</a>
<a name="ln1762">        goto theend;</a>
<a name="ln1763">      }</a>
<a name="ln1764"> </a>
<a name="ln1765">      // If 'filetype' was empty try detecting it now.</a>
<a name="ln1766">      if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln1767">        if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln1768">          (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln1769">        }</a>
<a name="ln1770">        do_modelines(0);</a>
<a name="ln1771">      }</a>
<a name="ln1772"> </a>
<a name="ln1773">      // Autocommands may have changed buffer names, esp. when</a>
<a name="ln1774">      // 'autochdir' is set.</a>
<a name="ln1775">      fname = curbuf-&gt;b_sfname;</a>
<a name="ln1776">    }</a>
<a name="ln1777"> </a>
<a name="ln1778">    if (eap-&gt;mkdir_p) {</a>
<a name="ln1779">      if (os_file_mkdir(fname, 0755) &lt; 0) {</a>
<a name="ln1780">        retval = FAIL;</a>
<a name="ln1781">        goto theend;</a>
<a name="ln1782">      }</a>
<a name="ln1783">    }</a>
<a name="ln1784"> </a>
<a name="ln1785">    name_was_missing = curbuf-&gt;b_ffname == NULL;</a>
<a name="ln1786">    retval = buf_write(curbuf, ffname, fname, eap-&gt;line1, eap-&gt;line2,</a>
<a name="ln1787">                       eap, eap-&gt;append, eap-&gt;forceit, true, false);</a>
<a name="ln1788"> </a>
<a name="ln1789">    // After &quot;:saveas fname&quot; reset 'readonly'.</a>
<a name="ln1790">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1791">      if (retval == OK) {</a>
<a name="ln1792">        curbuf-&gt;b_p_ro = false;</a>
<a name="ln1793">        redraw_tabline = true;</a>
<a name="ln1794">      }</a>
<a name="ln1795">    }</a>
<a name="ln1796"> </a>
<a name="ln1797">    // Change directories when the 'acd' option is set and the file name</a>
<a name="ln1798">    // got changed or set.</a>
<a name="ln1799">    if (eap-&gt;cmdidx == CMD_saveas || name_was_missing) {</a>
<a name="ln1800">      do_autochdir();</a>
<a name="ln1801">    }</a>
<a name="ln1802">  }</a>
<a name="ln1803"> </a>
<a name="ln1804">theend:</a>
<a name="ln1805">  xfree(free_fname);</a>
<a name="ln1806">  return retval;</a>
<a name="ln1807">}</a>
<a name="ln1808"> </a>
<a name="ln1809">/// Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,</a>
<a name="ln1810">/// BF_NEW or BF_READERR, check for overwriting current file.</a>
<a name="ln1811">/// May set eap-&gt;forceit if a dialog says it's OK to overwrite.</a>
<a name="ln1812">///</a>
<a name="ln1813">/// @param fname   file name to be used (can differ from buf-&gt;ffname)</a>
<a name="ln1814">/// @param ffname  full path version of fname</a>
<a name="ln1815">/// @param other   writing under other name</a>
<a name="ln1816">///</a>
<a name="ln1817">/// @return  OK if it's OK, FAIL if it is not.</a>
<a name="ln1818">int check_overwrite(exarg_T *eap, buf_T *buf, char *fname, char *ffname, int other)</a>
<a name="ln1819">{</a>
<a name="ln1820">  // Write to another file or b_flags set or not writing the whole file:</a>
<a name="ln1821">  // overwriting only allowed with '!'</a>
<a name="ln1822">  // If &quot;other&quot; is false and bt_nofilename(buf) is true, this must be</a>
<a name="ln1823">  // writing an &quot;acwrite&quot; buffer to the same file as its b_ffname, and</a>
<a name="ln1824">  // buf_write() will only allow writing with BufWriteCmd autocommands,</a>
<a name="ln1825">  // so there is no need for an overwrite check.</a>
<a name="ln1826">  if ((other</a>
<a name="ln1827">       || (!bt_nofilename(buf)</a>
<a name="ln1828">           &amp;&amp; ((buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln1829">               || ((buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln1830">                   &amp;&amp; vim_strchr(p_cpo, CPO_OVERNEW) == NULL)</a>
<a name="ln1831">               || (buf-&gt;b_flags &amp; BF_READERR))))</a>
<a name="ln1832">      &amp;&amp; !p_wa</a>
<a name="ln1833">      &amp;&amp; os_path_exists(ffname)) {</a>
<a name="ln1834">    if (!eap-&gt;forceit &amp;&amp; !eap-&gt;append) {</a>
<a name="ln1835">#ifdef UNIX</a>
<a name="ln1836">      // It is possible to open a directory on Unix.</a>
<a name="ln1837">      if (os_isdir(ffname)) {</a>
<a name="ln1838">        semsg(_(e_isadir2), ffname);</a>
<a name="ln1839">        return FAIL;</a>
<a name="ln1840">      }</a>
<a name="ln1841">#endif</a>
<a name="ln1842">      if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1843">        char buff[DIALOG_MSG_SIZE];</a>
<a name="ln1844"> </a>
<a name="ln1845">        dialog_msg(buff, _(&quot;Overwrite existing file \&quot;%s\&quot;?&quot;), fname);</a>
<a name="ln1846">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES) {</a>
<a name="ln1847">          return FAIL;</a>
<a name="ln1848">        }</a>
<a name="ln1849">        eap-&gt;forceit = true;</a>
<a name="ln1850">      } else {</a>
<a name="ln1851">        emsg(_(e_exists));</a>
<a name="ln1852">        return FAIL;</a>
<a name="ln1853">      }</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">    // For &quot;:w! filename&quot; check that no swap file exists for &quot;filename&quot;.</a>
<a name="ln1857">    if (other &amp;&amp; !emsg_silent) {</a>
<a name="ln1858">      char *dir;</a>
<a name="ln1859">      char *p;</a>
<a name="ln1860">      char *swapname;</a>
<a name="ln1861"> </a>
<a name="ln1862">      // We only try the first entry in 'directory', without checking if</a>
<a name="ln1863">      // it's writable.  If the &quot;.&quot; directory is not writable the write</a>
<a name="ln1864">      // will probably fail anyway.</a>
<a name="ln1865">      // Use 'shortname' of the current buffer, since there is no buffer</a>
<a name="ln1866">      // for the written file.</a>
<a name="ln1867">      if (*p_dir == NUL) {</a>
<a name="ln1868">        dir = xmalloc(5);</a>
<a name="ln1869">        STRCPY(dir, &quot;.&quot;);</a>
<a name="ln1870">      } else {</a>
<a name="ln1871">        dir = xmalloc(MAXPATHL);</a>
<a name="ln1872">        p = p_dir;</a>
<a name="ln1873">        copy_option_part(&amp;p, dir, MAXPATHL, &quot;,&quot;);</a>
<a name="ln1874">      }</a>
<a name="ln1875">      swapname = makeswapname(fname, ffname, curbuf, dir);</a>
<a name="ln1876">      xfree(dir);</a>
<a name="ln1877">      if (os_path_exists(swapname)) {</a>
<a name="ln1878">        if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1879">          char buff[DIALOG_MSG_SIZE];</a>
<a name="ln1880"> </a>
<a name="ln1881">          dialog_msg(buff,</a>
<a name="ln1882">                     _(&quot;Swap file \&quot;%s\&quot; exists, overwrite anyway?&quot;),</a>
<a name="ln1883">                     swapname);</a>
<a name="ln1884">          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)</a>
<a name="ln1885">              != VIM_YES) {</a>
<a name="ln1886">            xfree(swapname);</a>
<a name="ln1887">            return FAIL;</a>
<a name="ln1888">          }</a>
<a name="ln1889">          eap-&gt;forceit = true;</a>
<a name="ln1890">        } else {</a>
<a name="ln1891">          semsg(_(&quot;E768: Swap file exists: %s (:silent! overrides)&quot;),</a>
<a name="ln1892">                swapname);</a>
<a name="ln1893">          xfree(swapname);</a>
<a name="ln1894">          return FAIL;</a>
<a name="ln1895">        }</a>
<a name="ln1896">      }</a>
<a name="ln1897">      xfree(swapname);</a>
<a name="ln1898">    }</a>
<a name="ln1899">  }</a>
<a name="ln1900">  return OK;</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">/// Handle &quot;:wnext&quot;, &quot;:wNext&quot; and &quot;:wprevious&quot; commands.</a>
<a name="ln1904">void ex_wnext(exarg_T *eap)</a>
<a name="ln1905">{</a>
<a name="ln1906">  int i;</a>
<a name="ln1907"> </a>
<a name="ln1908">  if (eap-&gt;cmd[1] == 'n') {</a>
<a name="ln1909">    i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln1910">  } else {</a>
<a name="ln1911">    i = curwin-&gt;w_arg_idx - (int)eap-&gt;line2;</a>
<a name="ln1912">  }</a>
<a name="ln1913">  eap-&gt;line1 = 1;</a>
<a name="ln1914">  eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1915">  if (do_write(eap) != FAIL) {</a>
<a name="ln1916">    do_argfile(eap, i);</a>
<a name="ln1917">  }</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">/// &quot;:wall&quot;, &quot;:wqall&quot; and &quot;:xall&quot;: Write all changed files (and exit).</a>
<a name="ln1921">void do_wqall(exarg_T *eap)</a>
<a name="ln1922">{</a>
<a name="ln1923">  int error = 0;</a>
<a name="ln1924">  int save_forceit = eap-&gt;forceit;</a>
<a name="ln1925"> </a>
<a name="ln1926">  if (eap-&gt;cmdidx == CMD_xall || eap-&gt;cmdidx == CMD_wqall) {</a>
<a name="ln1927">    if (before_quit_all(eap) == FAIL) {</a>
<a name="ln1928">      return;</a>
<a name="ln1929">    }</a>
<a name="ln1930">    exiting = true;</a>
<a name="ln1931">  }</a>
<a name="ln1932"> </a>
<a name="ln1933">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1934">    if (exiting</a>
<a name="ln1935">        &amp;&amp; buf-&gt;terminal</a>
<a name="ln1936">        &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel)) {</a>
<a name="ln1937">      no_write_message_nobang(buf);</a>
<a name="ln1938">      error++;</a>
<a name="ln1939">    } else if (!bufIsChanged(buf) || bt_dontwrite(buf)) {</a>
<a name="ln1940">      continue;</a>
<a name="ln1941">    }</a>
<a name="ln1942">    // Check if there is a reason the buffer cannot be written:</a>
<a name="ln1943">    // 1. if the 'write' option is set</a>
<a name="ln1944">    // 2. if there is no file name (even after browsing)</a>
<a name="ln1945">    // 3. if the 'readonly' is set (even after a dialog)</a>
<a name="ln1946">    // 4. if overwriting is allowed (even after a dialog)</a>
<a name="ln1947">    if (not_writing()) {</a>
<a name="ln1948">      error++;</a>
<a name="ln1949">      break;</a>
<a name="ln1950">    }</a>
<a name="ln1951">    if (buf-&gt;b_ffname == NULL) {</a>
<a name="ln1952">      semsg(_(&quot;E141: No file name for buffer %&quot; PRId64), (int64_t)buf-&gt;b_fnum);</a>
<a name="ln1953">      error++;</a>
<a name="ln1954">    } else if (check_readonly(&amp;eap-&gt;forceit, buf)</a>
<a name="ln1955">               || check_overwrite(eap, buf, buf-&gt;b_fname, buf-&gt;b_ffname, false) == FAIL) {</a>
<a name="ln1956">      error++;</a>
<a name="ln1957">    } else {</a>
<a name="ln1958">      bufref_T bufref;</a>
<a name="ln1959">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1960">      if (buf_write_all(buf, eap-&gt;forceit) == FAIL) {</a>
<a name="ln1961">        error++;</a>
<a name="ln1962">      }</a>
<a name="ln1963">      // An autocommand may have deleted the buffer.</a>
<a name="ln1964">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1965">        buf = firstbuf;</a>
<a name="ln1966">      }</a>
<a name="ln1967">    }</a>
<a name="ln1968">    eap-&gt;forceit = save_forceit;          // check_overwrite() may set it</a>
<a name="ln1969">  }</a>
<a name="ln1970">  if (exiting) {</a>
<a name="ln1971">    if (!error) {</a>
<a name="ln1972">      getout(0);                // exit Vim</a>
<a name="ln1973">    }</a>
<a name="ln1974">    not_exiting();</a>
<a name="ln1975">  }</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978">/// Check the 'write' option.</a>
<a name="ln1979">///</a>
<a name="ln1980">/// @return  true and give a message when it's not st.</a>
<a name="ln1981">bool not_writing(void)</a>
<a name="ln1982">{</a>
<a name="ln1983">  if (p_write) {</a>
<a name="ln1984">    return false;</a>
<a name="ln1985">  }</a>
<a name="ln1986">  emsg(_(&quot;E142: File not written: Writing is disabled by 'write' option&quot;));</a>
<a name="ln1987">  return true;</a>
<a name="ln1988">}</a>
<a name="ln1989"> </a>
<a name="ln1990">/// Check if a buffer is read-only (either 'readonly' option is set or file is</a>
<a name="ln1991">/// read-only). Ask for overruling in a dialog. Return true and give an error</a>
<a name="ln1992">/// message when the buffer is readonly.</a>
<a name="ln1993">static int check_readonly(int *forceit, buf_T *buf)</a>
<a name="ln1994">{</a>
<a name="ln1995">  // Handle a file being readonly when the 'readonly' option is set or when</a>
<a name="ln1996">  // the file exists and permissions are read-only.</a>
<a name="ln1997">  if (!*forceit &amp;&amp; (buf-&gt;b_p_ro</a>
<a name="ln1998">                    || (os_path_exists(buf-&gt;b_ffname)</a>
<a name="ln1999">                        &amp;&amp; !os_file_is_writable(buf-&gt;b_ffname)))) {</a>
<a name="ln2000">    if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln2001">      char buff[DIALOG_MSG_SIZE];</a>
<a name="ln2002"> </a>
<a name="ln2003">      if (buf-&gt;b_p_ro) {</a>
<a name="ln2004">        dialog_msg(buff,</a>
<a name="ln2005">                   _(&quot;'readonly' option is set for \&quot;%s\&quot;.\nDo you wish to write anyway?&quot;),</a>
<a name="ln2006">                   buf-&gt;b_fname);</a>
<a name="ln2007">      } else {</a>
<a name="ln2008">        dialog_msg(buff,</a>
<a name="ln2009">                   _(&quot;File permissions of \&quot;%s\&quot; are read-only.\nIt may still be possible to &quot;</a>
<a name="ln2010">                     &quot;write it.\nDo you wish to try?&quot;),</a>
<a name="ln2011">                   buf-&gt;b_fname);</a>
<a name="ln2012">      }</a>
<a name="ln2013"> </a>
<a name="ln2014">      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {</a>
<a name="ln2015">        // Set forceit, to force the writing of a readonly file</a>
<a name="ln2016">        *forceit = true;</a>
<a name="ln2017">        return false;</a>
<a name="ln2018">      }</a>
<a name="ln2019">      return true;</a>
<a name="ln2020">    } else if (buf-&gt;b_p_ro) {</a>
<a name="ln2021">      emsg(_(e_readonly));</a>
<a name="ln2022">    } else {</a>
<a name="ln2023">      semsg(_(&quot;E505: \&quot;%s\&quot; is read-only (add ! to override)&quot;),</a>
<a name="ln2024">            buf-&gt;b_fname);</a>
<a name="ln2025">    }</a>
<a name="ln2026">    return true;</a>
<a name="ln2027">  }</a>
<a name="ln2028"> </a>
<a name="ln2029">  return false;</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">/// Try to abandon the current file and edit a new or existing file.</a>
<a name="ln2033">///</a>
<a name="ln2034">/// @param fnum  the number of the file, if zero use &quot;ffname_arg&quot;/&quot;sfname_arg&quot;.</a>
<a name="ln2035">/// @param lnum  the line number for the cursor in the new file (if non-zero).</a>
<a name="ln2036">///</a>
<a name="ln2037">/// @return:</a>
<a name="ln2038">///           GETFILE_ERROR for &quot;normal&quot; error,</a>
<a name="ln2039">///           GETFILE_NOT_WRITTEN for &quot;not written&quot; error,</a>
<a name="ln2040">///           GETFILE_SAME_FILE for success</a>
<a name="ln2041">///           GETFILE_OPEN_OTHER for successfully opening another file.</a>
<a name="ln2042">int getfile(int fnum, char *ffname_arg, char *sfname_arg, int setpm, linenr_T lnum, int forceit)</a>
<a name="ln2043">{</a>
<a name="ln2044">  char *ffname = ffname_arg;</a>
<a name="ln2045">  char *sfname = sfname_arg;</a>
<a name="ln2046">  int other;</a>
<a name="ln2047">  int retval;</a>
<a name="ln2048">  char *free_me = NULL;</a>
<a name="ln2049"> </a>
<a name="ln2050">  if (text_locked()) {</a>
<a name="ln2051">    return GETFILE_ERROR;</a>
<a name="ln2052">  }</a>
<a name="ln2053">  if (curbuf_locked()) {</a>
<a name="ln2054">    return GETFILE_ERROR;</a>
<a name="ln2055">  }</a>
<a name="ln2056"> </a>
<a name="ln2057">  if (fnum == 0) {</a>
<a name="ln2058">    // make ffname full path, set sfname</a>
<a name="ln2059">    fname_expand(curbuf, &amp;ffname, &amp;sfname);</a>
<a name="ln2060">    other = otherfile(ffname);</a>
<a name="ln2061">    free_me = ffname;                   // has been allocated, free() later</a>
<a name="ln2062">  } else {</a>
<a name="ln2063">    other = (fnum != curbuf-&gt;b_fnum);</a>
<a name="ln2064">  }</a>
<a name="ln2065"> </a>
<a name="ln2066">  if (other) {</a>
<a name="ln2067">    no_wait_return++;               // don't wait for autowrite message</a>
<a name="ln2068">  }</a>
<a name="ln2069">  if (other &amp;&amp; !forceit &amp;&amp; curbuf-&gt;b_nwindows == 1 &amp;&amp; !buf_hide(curbuf)</a>
<a name="ln2070">      &amp;&amp; curbufIsChanged() &amp;&amp; autowrite(curbuf, forceit) == FAIL) {</a>
<a name="ln2071">    if (p_confirm &amp;&amp; p_write) {</a>
<a name="ln2072">      dialog_changed(curbuf, false);</a>
<a name="ln2073">    }</a>
<a name="ln2074">    if (curbufIsChanged()) {</a>
<a name="ln2075">      no_wait_return--;</a>
<a name="ln2076">      no_write_message();</a>
<a name="ln2077">      retval = GETFILE_NOT_WRITTEN;     // File has been changed.</a>
<a name="ln2078">      goto theend;</a>
<a name="ln2079">    }</a>
<a name="ln2080">  }</a>
<a name="ln2081">  if (other) {</a>
<a name="ln2082">    no_wait_return--;</a>
<a name="ln2083">  }</a>
<a name="ln2084">  if (setpm) {</a>
<a name="ln2085">    setpcmark();</a>
<a name="ln2086">  }</a>
<a name="ln2087">  if (!other) {</a>
<a name="ln2088">    if (lnum != 0) {</a>
<a name="ln2089">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2090">    }</a>
<a name="ln2091">    check_cursor_lnum(curwin);</a>
<a name="ln2092">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln2093">    retval = GETFILE_SAME_FILE;     // it's in the same file</a>
<a name="ln2094">  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,</a>
<a name="ln2095">                     (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln2096">                     + (forceit ? ECMD_FORCEIT : 0), curwin) == OK) {</a>
<a name="ln2097">    retval = GETFILE_OPEN_OTHER;    // opened another file</a>
<a name="ln2098">  } else {</a>
<a name="ln2099">    retval = GETFILE_ERROR;         // error encountered</a>
<a name="ln2100">  }</a>
<a name="ln2101"> </a>
<a name="ln2102">theend:</a>
<a name="ln2103">  xfree(free_me);</a>
<a name="ln2104">  return retval;</a>
<a name="ln2105">}</a>
<a name="ln2106"> </a>
<a name="ln2107">/// start editing a new file</a>
<a name="ln2108">///</a>
<a name="ln2109">/// @param fnum     file number; if zero use ffname/sfname</a>
<a name="ln2110">/// @param ffname   the file name</a>
<a name="ln2111">///                 - full path if sfname used,</a>
<a name="ln2112">///                 - any file name if sfname is NULL</a>
<a name="ln2113">///                 - empty string to re-edit with the same file name (but may</a>
<a name="ln2114">///                   be in a different directory)</a>
<a name="ln2115">///                 - NULL to start an empty buffer</a>
<a name="ln2116">/// @param sfname   the short file name (or NULL)</a>
<a name="ln2117">/// @param eap      contains the command to be executed after loading the file</a>
<a name="ln2118">///                 and forced 'ff' and 'fenc'. Can be NULL!</a>
<a name="ln2119">/// @param newlnum  if &gt; 0: put cursor on this line number (if possible)</a>
<a name="ln2120">///                 ECMD_LASTL: use last position in loaded file</a>
<a name="ln2121">///                 ECMD_LAST: use last position in all files</a>
<a name="ln2122">///                 ECMD_ONE: use first line</a>
<a name="ln2123">/// @param flags    ECMD_HIDE: if true don't free the current buffer</a>
<a name="ln2124">///                 ECMD_SET_HELP: set b_help flag of (new) buffer before</a>
<a name="ln2125">///                 opening file</a>
<a name="ln2126">///                 ECMD_OLDBUF: use existing buffer if it exists</a>
<a name="ln2127">///                 ECMD_FORCEIT: ! used for Ex command</a>
<a name="ln2128">///                 ECMD_ADDBUF: don't edit, just add to buffer list</a>
<a name="ln2129">///                 ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate</a>
<a name="ln2130">///                 file</a>
<a name="ln2131">///                 ECMD_NOWINENTER: Do not trigger BufWinEnter</a>
<a name="ln2132">/// @param oldwin   Should be &quot;curwin&quot; when editing a new buffer in the current</a>
<a name="ln2133">///                 window, NULL when splitting the window first.  When not NULL</a>
<a name="ln2134">///                 info of the previous buffer for &quot;oldwin&quot; is stored.</a>
<a name="ln2135">///</a>
<a name="ln2136">/// @return FAIL for failure, OK otherwise</a>
<a name="ln2137">int do_ecmd(int fnum, char *ffname, char *sfname, exarg_T *eap, linenr_T newlnum, int flags,</a>
<a name="ln2138">            win_T *oldwin)</a>
<a name="ln2139">{</a>
<a name="ln2140">  bool other_file;                      // true if editing another file</a>
<a name="ln2141">  int oldbuf;                           // true if using existing buffer</a>
<a name="ln2142">  bool auto_buf = false;                // true if autocommands brought us</a>
<a name="ln2143">                                        // into the buffer unexpectedly</a>
<a name="ln2144">  char *new_name = NULL;</a>
<a name="ln2145">  bool did_set_swapcommand = false;</a>
<a name="ln2146">  buf_T *buf;</a>
<a name="ln2147">  bufref_T bufref;</a>
<a name="ln2148">  bufref_T old_curbuf;</a>
<a name="ln2149">  char *free_fname = NULL;</a>
<a name="ln2150">  int retval = FAIL;</a>
<a name="ln2151">  long n;</a>
<a name="ln2152">  pos_T orig_pos;</a>
<a name="ln2153">  linenr_T topline = 0;</a>
<a name="ln2154">  int newcol = -1;</a>
<a name="ln2155">  int solcol = -1;</a>
<a name="ln2156">  pos_T *pos;</a>
<a name="ln2157">  char *command = NULL;</a>
<a name="ln2158">  bool did_get_winopts = false;</a>
<a name="ln2159">  int readfile_flags = 0;</a>
<a name="ln2160">  bool did_inc_redrawing_disabled = false;</a>
<a name="ln2161">  long *so_ptr = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (eap != NULL) {</a>
<a name="ln2164">    command = eap-&gt;do_ecmd_cmd;</a>
<a name="ln2165">  }</a>
<a name="ln2166"> </a>
<a name="ln2167">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2168"> </a>
<a name="ln2169">  if (fnum != 0) {</a>
<a name="ln2170">    if (fnum == curbuf-&gt;b_fnum) {       // file is already being edited</a>
<a name="ln2171">      return OK;                        // nothing to do</a>
<a name="ln2172">    }</a>
<a name="ln2173">    other_file = true;</a>
<a name="ln2174">  } else {</a>
<a name="ln2175">    // if no short name given, use ffname for short name</a>
<a name="ln2176">    if (sfname == NULL) {</a>
<a name="ln2177">      sfname = ffname;</a>
<a name="ln2178">    }</a>
<a name="ln2179">#ifdef USE_FNAME_CASE</a>
<a name="ln2180">    if (sfname != NULL) {</a>
<a name="ln2181">      path_fix_case(sfname);             // set correct case for sfname</a>
<a name="ln2182">    }</a>
<a name="ln2183">#endif</a>
<a name="ln2184"> </a>
<a name="ln2185">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))</a>
<a name="ln2186">        &amp;&amp; (ffname == NULL || *ffname == NUL)) {</a>
<a name="ln2187">      goto theend;</a>
<a name="ln2188">    }</a>
<a name="ln2189"> </a>
<a name="ln2190">    if (ffname == NULL) {</a>
<a name="ln2191">      other_file = true;</a>
<a name="ln2192">    } else if (*ffname == NUL &amp;&amp; curbuf-&gt;b_ffname == NULL) {  // there is no file name</a>
<a name="ln2193">      other_file = false;</a>
<a name="ln2194">    } else {</a>
<a name="ln2195">      if (*ffname == NUL) {                 // re-edit with same file name</a>
<a name="ln2196">        ffname = curbuf-&gt;b_ffname;</a>
<a name="ln2197">        sfname = curbuf-&gt;b_fname;</a>
<a name="ln2198">      }</a>
<a name="ln2199">      free_fname = fix_fname(ffname);       // may expand to full path name</a>
<a name="ln2200">      if (free_fname != NULL) {</a>
<a name="ln2201">        ffname = free_fname;</a>
<a name="ln2202">      }</a>
<a name="ln2203">      other_file = otherfile(ffname);</a>
<a name="ln2204">    }</a>
<a name="ln2205">  }</a>
<a name="ln2206"> </a>
<a name="ln2207">  // Re-editing a terminal buffer: skip most buffer re-initialization.</a>
<a name="ln2208">  if (!other_file &amp;&amp; curbuf-&gt;terminal) {</a>
<a name="ln2209">    check_arg_idx(curwin);  // Needed when called from do_argfile().</a>
<a name="ln2210">    maketitle();            // Title may show the arg index, e.g. &quot;(2 of 5)&quot;.</a>
<a name="ln2211">    retval = OK;</a>
<a name="ln2212">    goto theend;</a>
<a name="ln2213">  }</a>
<a name="ln2214"> </a>
<a name="ln2215">  // If the file was changed we may not be allowed to abandon it:</a>
<a name="ln2216">  // - if we are going to re-edit the same file</a>
<a name="ln2217">  // - or if we are the only window on this file and if ECMD_HIDE is false</a>
<a name="ln2218">  if (((!other_file &amp;&amp; !(flags &amp; ECMD_OLDBUF))</a>
<a name="ln2219">       || (curbuf-&gt;b_nwindows == 1</a>
<a name="ln2220">           &amp;&amp; !(flags &amp; (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))</a>
<a name="ln2221">      &amp;&amp; check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln2222">                       | (other_file ? 0 : CCGD_MULTWIN)</a>
<a name="ln2223">                       | ((flags &amp; ECMD_FORCEIT) ? CCGD_FORCEIT : 0)</a>
<a name="ln2224">                       | (eap == NULL ? 0 : CCGD_EXCMD))) {</a>
<a name="ln2225">    if (fnum == 0 &amp;&amp; other_file &amp;&amp; ffname != NULL) {</a>
<a name="ln2226">      (void)setaltfname(ffname, sfname, newlnum &lt; 0 ? 0 : newlnum);</a>
<a name="ln2227">    }</a>
<a name="ln2228">    goto theend;</a>
<a name="ln2229">  }</a>
<a name="ln2230"> </a>
<a name="ln2231">  // End Visual mode before switching to another buffer, so the text can be</a>
<a name="ln2232">  // copied into the GUI selection buffer.</a>
<a name="ln2233">  // Careful: may trigger ModeChanged() autocommand</a>
<a name="ln2234"> </a>
<a name="ln2235">  // Should we block autocommands here?</a>
<a name="ln2236">  reset_VIsual();</a>
<a name="ln2237"> </a>
<a name="ln2238">  // autocommands freed window :(</a>
<a name="ln2239">  if (oldwin != NULL &amp;&amp; !win_valid(oldwin)) {</a>
<a name="ln2240">    oldwin = NULL;</a>
<a name="ln2241">  }</a>
<a name="ln2242"> </a>
<a name="ln2243">  if ((command != NULL || newlnum &gt; (linenr_T)0)</a>
<a name="ln2244">      &amp;&amp; *get_vim_var_str(VV_SWAPCOMMAND) == NUL) {</a>
<a name="ln2245">    // Set v:swapcommand for the SwapExists autocommands.</a>
<a name="ln2246">    const size_t len = (command != NULL) ? strlen(command) + 3 : 30;</a>
<a name="ln2247">    char *const p = xmalloc(len);</a>
<a name="ln2248">    if (command != NULL) {</a>
<a name="ln2249">      vim_snprintf(p, len, &quot;:%s\r&quot;, command);</a>
<a name="ln2250">    } else {</a>
<a name="ln2251">      vim_snprintf(p, len, &quot;%&quot; PRId64 &quot;G&quot;, (int64_t)newlnum);</a>
<a name="ln2252">    }</a>
<a name="ln2253">    set_vim_var_string(VV_SWAPCOMMAND, p, -1);</a>
<a name="ln2254">    did_set_swapcommand = true;</a>
<a name="ln2255">    xfree(p);</a>
<a name="ln2256">  }</a>
<a name="ln2257"> </a>
<a name="ln2258">  // If we are starting to edit another file, open a (new) buffer.</a>
<a name="ln2259">  // Otherwise we re-use the current buffer.</a>
<a name="ln2260">  if (other_file) {</a>
<a name="ln2261">    const int prev_alt_fnum = curwin-&gt;w_alt_fnum;</a>
<a name="ln2262"> </a>
<a name="ln2263">    if (!(flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))) {</a>
<a name="ln2264">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln2265">        curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln2266">      }</a>
<a name="ln2267">      if (oldwin != NULL) {</a>
<a name="ln2268">        buflist_altfpos(oldwin);</a>
<a name="ln2269">      }</a>
<a name="ln2270">    }</a>
<a name="ln2271"> </a>
<a name="ln2272">    if (fnum) {</a>
<a name="ln2273">      buf = buflist_findnr(fnum);</a>
<a name="ln2274">    } else {</a>
<a name="ln2275">      if (flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) {</a>
<a name="ln2276">        // Default the line number to zero to avoid that a wininfo item</a>
<a name="ln2277">        // is added for the current window.</a>
<a name="ln2278">        linenr_T tlnum = 0;</a>
<a name="ln2279"> </a>
<a name="ln2280">        if (command != NULL) {</a>
<a name="ln2281">          tlnum = (linenr_T)atol(command);</a>
<a name="ln2282">          if (tlnum &lt;= 0) {</a>
<a name="ln2283">            tlnum = 1L;</a>
<a name="ln2284">          }</a>
<a name="ln2285">        }</a>
<a name="ln2286">        // Add BLN_NOCURWIN to avoid a new wininfo items are associated</a>
<a name="ln2287">        // with the current window.</a>
<a name="ln2288">        const buf_T *const newbuf</a>
<a name="ln2289">          = buflist_new(ffname, sfname, tlnum, BLN_LISTED | BLN_NOCURWIN);</a>
<a name="ln2290">        if (newbuf != NULL &amp;&amp; (flags &amp; ECMD_ALTBUF)) {</a>
<a name="ln2291">          curwin-&gt;w_alt_fnum = newbuf-&gt;b_fnum;</a>
<a name="ln2292">        }</a>
<a name="ln2293">        goto theend;</a>
<a name="ln2294">      }</a>
<a name="ln2295">      buf = buflist_new(ffname, sfname, 0L,</a>
<a name="ln2296">                        BLN_CURBUF | (flags &amp; ECMD_SET_HELP ? 0 : BLN_LISTED));</a>
<a name="ln2297">      // Autocmds may change curwin and curbuf.</a>
<a name="ln2298">      if (oldwin != NULL) {</a>
<a name="ln2299">        oldwin = curwin;</a>
<a name="ln2300">      }</a>
<a name="ln2301">      set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2302">    }</a>
<a name="ln2303">    if (buf == NULL) {</a>
<a name="ln2304">      goto theend;</a>
<a name="ln2305">    }</a>
<a name="ln2306">    if (curwin-&gt;w_alt_fnum == buf-&gt;b_fnum &amp;&amp; prev_alt_fnum != 0) {</a>
<a name="ln2307">      // reusing the buffer, keep the old alternate file</a>
<a name="ln2308">      curwin-&gt;w_alt_fnum = prev_alt_fnum;</a>
<a name="ln2309">    }</a>
<a name="ln2310">    if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2311">      // No memfile yet.</a>
<a name="ln2312">      oldbuf = false;</a>
<a name="ln2313">    } else {</a>
<a name="ln2314">      // Existing memfile.</a>
<a name="ln2315">      oldbuf = true;</a>
<a name="ln2316">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2317">      (void)buf_check_timestamp(buf);</a>
<a name="ln2318">      // Check if autocommands made buffer invalid or changed the current</a>
<a name="ln2319">      // buffer.</a>
<a name="ln2320">      if (!bufref_valid(&amp;bufref) || curbuf != old_curbuf.br_buf) {</a>
<a name="ln2321">        goto theend;</a>
<a name="ln2322">      }</a>
<a name="ln2323">      if (aborting()) {</a>
<a name="ln2324">        // Autocmds may abort script processing.</a>
<a name="ln2325">        goto theend;</a>
<a name="ln2326">      }</a>
<a name="ln2327">    }</a>
<a name="ln2328"> </a>
<a name="ln2329">    // May jump to last used line number for a loaded buffer or when asked</a>
<a name="ln2330">    // for explicitly</a>
<a name="ln2331">    if ((oldbuf &amp;&amp; newlnum == ECMD_LASTL) || newlnum == ECMD_LAST) {</a>
<a name="ln2332">      pos = &amp;buflist_findfmark(buf)-&gt;mark;</a>
<a name="ln2333">      newlnum = pos-&gt;lnum;</a>
<a name="ln2334">      solcol = pos-&gt;col;</a>
<a name="ln2335">    }</a>
<a name="ln2336"> </a>
<a name="ln2337">    // Make the (new) buffer the one used by the current window.</a>
<a name="ln2338">    // If the old buffer becomes unused, free it if ECMD_HIDE is false.</a>
<a name="ln2339">    // If the current buffer was empty and has no file name, curbuf</a>
<a name="ln2340">    // is returned by buflist_new(), nothing to do here.</a>
<a name="ln2341">    if (buf != curbuf) {</a>
<a name="ln2342">      const int save_cmdwin_type = cmdwin_type;</a>
<a name="ln2343"> </a>
<a name="ln2344">      // BufLeave applies to the old buffer.</a>
<a name="ln2345">      cmdwin_type = 0;</a>
<a name="ln2346"> </a>
<a name="ln2347">      // Be careful: The autocommands may delete any buffer and change</a>
<a name="ln2348">      // the current buffer.</a>
<a name="ln2349">      // - If the buffer we are going to edit is deleted, give up.</a>
<a name="ln2350">      // - If the current buffer is deleted, prefer to load the new</a>
<a name="ln2351">      //   buffer when loading a buffer is required.  This avoids</a>
<a name="ln2352">      //   loading another buffer which then must be closed again.</a>
<a name="ln2353">      // - If we ended up in the new buffer already, need to skip a few</a>
<a name="ln2354">      //         things, set auto_buf.</a>
<a name="ln2355">      if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2356">        new_name = xstrdup(buf-&gt;b_fname);</a>
<a name="ln2357">      }</a>
<a name="ln2358">      const bufref_T save_au_new_curbuf = au_new_curbuf;</a>
<a name="ln2359">      set_bufref(&amp;au_new_curbuf, buf);</a>
<a name="ln2360">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2361">      cmdwin_type = save_cmdwin_type;</a>
<a name="ln2362">      if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2363">        // New buffer has been deleted.</a>
<a name="ln2364">        delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2365">        au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2366">        goto theend;</a>
<a name="ln2367">      }</a>
<a name="ln2368">      if (aborting()) {             // autocmds may abort script processing</a>
<a name="ln2369">        xfree(new_name);</a>
<a name="ln2370">        au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2371">        goto theend;</a>
<a name="ln2372">      }</a>
<a name="ln2373">      if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2374">        auto_buf = true;</a>
<a name="ln2375">      } else {</a>
<a name="ln2376">        win_T *the_curwin = curwin;</a>
<a name="ln2377">        buf_T *was_curbuf = curbuf;</a>
<a name="ln2378"> </a>
<a name="ln2379">        // Set w_closing to avoid that autocommands close the window.</a>
<a name="ln2380">        // Set b_locked for the same reason.</a>
<a name="ln2381">        the_curwin-&gt;w_closing = true;</a>
<a name="ln2382">        buf-&gt;b_locked++;</a>
<a name="ln2383"> </a>
<a name="ln2384">        if (curbuf == old_curbuf.br_buf) {</a>
<a name="ln2385">          buf_copy_options(buf, BCO_ENTER);</a>
<a name="ln2386">        }</a>
<a name="ln2387"> </a>
<a name="ln2388">        // Close the link to the current buffer. This will set</a>
<a name="ln2389">        // oldwin-&gt;w_buffer to NULL.</a>
<a name="ln2390">        u_sync(false);</a>
<a name="ln2391">        const bool did_decrement</a>
<a name="ln2392">          = close_buffer(oldwin, curbuf, (flags &amp; ECMD_HIDE) || curbuf-&gt;terminal ? 0 : DOBUF_UNLOAD,</a>
<a name="ln2393">                         false, false);</a>
<a name="ln2394"> </a>
<a name="ln2395">        // Autocommands may have closed the window.</a>
<a name="ln2396">        if (win_valid(the_curwin)) {</a>
<a name="ln2397">          the_curwin-&gt;w_closing = false;</a>
<a name="ln2398">        }</a>
<a name="ln2399">        buf-&gt;b_locked--;</a>
<a name="ln2400"> </a>
<a name="ln2401">        // autocmds may abort script processing</a>
<a name="ln2402">        if (aborting() &amp;&amp; curwin-&gt;w_buffer != NULL) {</a>
<a name="ln2403">          xfree(new_name);</a>
<a name="ln2404">          au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2405">          goto theend;</a>
<a name="ln2406">        }</a>
<a name="ln2407">        // Be careful again, like above.</a>
<a name="ln2408">        if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2409">          // New buffer has been deleted.</a>
<a name="ln2410">          delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2411">          au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2412">          goto theend;</a>
<a name="ln2413">        }</a>
<a name="ln2414">        if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2415">          // close_buffer() has decremented the window count,</a>
<a name="ln2416">          // increment it again here and restore w_buffer.</a>
<a name="ln2417">          if (did_decrement &amp;&amp; buf_valid(was_curbuf)) {</a>
<a name="ln2418">            was_curbuf-&gt;b_nwindows++;</a>
<a name="ln2419">          }</a>
<a name="ln2420">          if (win_valid_any_tab(oldwin) &amp;&amp; oldwin-&gt;w_buffer == NULL) {</a>
<a name="ln2421">            oldwin-&gt;w_buffer = was_curbuf;</a>
<a name="ln2422">          }</a>
<a name="ln2423">          auto_buf = true;</a>
<a name="ln2424">        } else {</a>
<a name="ln2425">          // &lt;VN&gt; We could instead free the synblock</a>
<a name="ln2426">          // and re-attach to buffer, perhaps.</a>
<a name="ln2427">          if (curwin-&gt;w_buffer == NULL</a>
<a name="ln2428">              || curwin-&gt;w_s == &amp;(curwin-&gt;w_buffer-&gt;b_s)) {</a>
<a name="ln2429">            curwin-&gt;w_s = &amp;(buf-&gt;b_s);</a>
<a name="ln2430">          }</a>
<a name="ln2431"> </a>
<a name="ln2432">          curwin-&gt;w_buffer = buf;</a>
<a name="ln2433">          curbuf = buf;</a>
<a name="ln2434">          curbuf-&gt;b_nwindows++;</a>
<a name="ln2435"> </a>
<a name="ln2436">          // Set 'fileformat', 'binary' and 'fenc' when forced.</a>
<a name="ln2437">          if (!oldbuf &amp;&amp; eap != NULL) {</a>
<a name="ln2438">            set_file_options(true, eap);</a>
<a name="ln2439">            set_forced_fenc(eap);</a>
<a name="ln2440">          }</a>
<a name="ln2441">        }</a>
<a name="ln2442"> </a>
<a name="ln2443">        // May get the window options from the last time this buffer</a>
<a name="ln2444">        // was in this window (or another window).  If not used</a>
<a name="ln2445">        // before, reset the local window options to the global</a>
<a name="ln2446">        // values.  Also restores old folding stuff.</a>
<a name="ln2447">        get_winopts(curbuf);</a>
<a name="ln2448">        did_get_winopts = true;</a>
<a name="ln2449">      }</a>
<a name="ln2450">      xfree(new_name);</a>
<a name="ln2451">      au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2452">    }</a>
<a name="ln2453"> </a>
<a name="ln2454">    curwin-&gt;w_pcmark.lnum = 1;</a>
<a name="ln2455">    curwin-&gt;w_pcmark.col = 0;</a>
<a name="ln2456">  } else {  // !other_file</a>
<a name="ln2457">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL) {</a>
<a name="ln2458">      goto theend;</a>
<a name="ln2459">    }</a>
<a name="ln2460">    oldbuf = (flags &amp; ECMD_OLDBUF);</a>
<a name="ln2461">  }</a>
<a name="ln2462"> </a>
<a name="ln2463">  // Don't redraw until the cursor is in the right line, otherwise</a>
<a name="ln2464">  // autocommands may cause ml_get errors.</a>
<a name="ln2465">  RedrawingDisabled++;</a>
<a name="ln2466">  did_inc_redrawing_disabled = true;</a>
<a name="ln2467"> </a>
<a name="ln2468">  buf = curbuf;</a>
<a name="ln2469">  if ((flags &amp; ECMD_SET_HELP) || keep_help_flag) {</a>
<a name="ln2470">    prepare_help_buffer();</a>
<a name="ln2471">  } else if (!curbuf-&gt;b_help) {</a>
<a name="ln2472">    // Don't make a buffer listed if it's a help buffer.  Useful when using</a>
<a name="ln2473">    // CTRL-O to go back to a help file.</a>
<a name="ln2474">    set_buflisted(true);</a>
<a name="ln2475">  }</a>
<a name="ln2476"> </a>
<a name="ln2477">  // If autocommands change buffers under our fingers, forget about</a>
<a name="ln2478">  // editing the file.</a>
<a name="ln2479">  if (buf != curbuf) {</a>
<a name="ln2480">    goto theend;</a>
<a name="ln2481">  }</a>
<a name="ln2482">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2483">    goto theend;</a>
<a name="ln2484">  }</a>
<a name="ln2485"> </a>
<a name="ln2486">  // Since we are starting to edit a file, consider the filetype to be</a>
<a name="ln2487">  // unset.  Helps for when an autocommand changes files and expects syntax</a>
<a name="ln2488">  // highlighting to work in the other file.</a>
<a name="ln2489">  did_filetype = false;</a>
<a name="ln2490"> </a>
<a name="ln2491">  // other_file oldbuf</a>
<a name="ln2492">  //  false     false       re-edit same file, buffer is re-used</a>
<a name="ln2493">  //  false     true        re-edit same file, nothing changes</a>
<a name="ln2494">  //  true      false       start editing new file, new buffer</a>
<a name="ln2495">  //  true      true        start editing in existing buffer (nothing to do)</a>
<a name="ln2496">  if (!other_file &amp;&amp; !oldbuf) {         // re-use the buffer</a>
<a name="ln2497">    set_last_cursor(curwin);            // may set b_last_cursor</a>
<a name="ln2498">    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {</a>
<a name="ln2499">      newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2500">      solcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2501">    }</a>
<a name="ln2502">    buf = curbuf;</a>
<a name="ln2503">    if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2504">      new_name = xstrdup(buf-&gt;b_fname);</a>
<a name="ln2505">    } else {</a>
<a name="ln2506">      new_name = NULL;</a>
<a name="ln2507">    }</a>
<a name="ln2508">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2509"> </a>
<a name="ln2510">    // If the buffer was used before, store the current contents so that</a>
<a name="ln2511">    // the reload can be undone.  Do not do this if the (empty) buffer is</a>
<a name="ln2512">    // being re-used for another file.</a>
<a name="ln2513">    if (!(curbuf-&gt;b_flags &amp; BF_NEVERLOADED)</a>
<a name="ln2514">        &amp;&amp; (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur)) {</a>
<a name="ln2515">      // Sync first so that this is a separate undo-able action.</a>
<a name="ln2516">      u_sync(false);</a>
<a name="ln2517">      if (u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true)</a>
<a name="ln2518">          == FAIL) {</a>
<a name="ln2519">        xfree(new_name);</a>
<a name="ln2520">        goto theend;</a>
<a name="ln2521">      }</a>
<a name="ln2522">      u_unchanged(curbuf);</a>
<a name="ln2523">      buf_updates_unload(curbuf, false);</a>
<a name="ln2524">      buf_freeall(curbuf, BFA_KEEP_UNDO);</a>
<a name="ln2525"> </a>
<a name="ln2526">      // Tell readfile() not to clear or reload undo info.</a>
<a name="ln2527">      readfile_flags = READ_KEEP_UNDO;</a>
<a name="ln2528">    } else {</a>
<a name="ln2529">      buf_updates_unload(curbuf, false);</a>
<a name="ln2530">      buf_freeall(curbuf, 0);  // Free all things for buffer.</a>
<a name="ln2531">    }</a>
<a name="ln2532">    // If autocommands deleted the buffer we were going to re-edit, give</a>
<a name="ln2533">    // up and jump to the end.</a>
<a name="ln2534">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2535">      delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2536">      goto theend;</a>
<a name="ln2537">    }</a>
<a name="ln2538">    xfree(new_name);</a>
<a name="ln2539"> </a>
<a name="ln2540">    // If autocommands change buffers under our fingers, forget about</a>
<a name="ln2541">    // re-editing the file.  Should do the buf_clear_file(), but perhaps</a>
<a name="ln2542">    // the autocommands changed the buffer...</a>
<a name="ln2543">    if (buf != curbuf) {</a>
<a name="ln2544">      goto theend;</a>
<a name="ln2545">    }</a>
<a name="ln2546">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln2547">      goto theend;</a>
<a name="ln2548">    }</a>
<a name="ln2549">    buf_clear_file(curbuf);</a>
<a name="ln2550">    curbuf-&gt;b_op_start.lnum = 0;        // clear '[ and '] marks</a>
<a name="ln2551">    curbuf-&gt;b_op_end.lnum = 0;</a>
<a name="ln2552">  }</a>
<a name="ln2553"> </a>
<a name="ln2554">  // If we get here we are sure to start editing</a>
<a name="ln2555"> </a>
<a name="ln2556">  // Assume success now</a>
<a name="ln2557">  retval = OK;</a>
<a name="ln2558"> </a>
<a name="ln2559">  // If the file name was changed, reset the not-edit flag so that &quot;:write&quot;</a>
<a name="ln2560">  // works.</a>
<a name="ln2561">  if (!other_file) {</a>
<a name="ln2562">    curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln2563">  }</a>
<a name="ln2564"> </a>
<a name="ln2565">  // Check if we are editing the w_arg_idx file in the argument list.</a>
<a name="ln2566">  check_arg_idx(curwin);</a>
<a name="ln2567"> </a>
<a name="ln2568">  if (!auto_buf) {</a>
<a name="ln2569">    // Set cursor and init window before reading the file and executing</a>
<a name="ln2570">    // autocommands.  This allows for the autocommands to position the</a>
<a name="ln2571">    // cursor.</a>
<a name="ln2572">    curwin_init();</a>
<a name="ln2573"> </a>
<a name="ln2574">    // It's possible that all lines in the buffer changed.  Need to update</a>
<a name="ln2575">    // automatic folding for all windows where it's used.</a>
<a name="ln2576">    FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln2577">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln2578">        foldUpdateAll(win);</a>
<a name="ln2579">      }</a>
<a name="ln2580">    }</a>
<a name="ln2581"> </a>
<a name="ln2582">    // Change directories when the 'acd' option is set.</a>
<a name="ln2583">    do_autochdir();</a>
<a name="ln2584"> </a>
<a name="ln2585">    // Careful: open_buffer() and apply_autocmds() may change the current</a>
<a name="ln2586">    // buffer and window.</a>
<a name="ln2587">    orig_pos = curwin-&gt;w_cursor;</a>
<a name="ln2588">    topline = curwin-&gt;w_topline;</a>
<a name="ln2589">    if (!oldbuf) {                          // need to read the file</a>
<a name="ln2590">      swap_exists_action = SEA_DIALOG;</a>
<a name="ln2591">      curbuf-&gt;b_flags |= BF_CHECK_RO;       // set/reset 'ro' flag</a>
<a name="ln2592"> </a>
<a name="ln2593">      // Open the buffer and read the file.</a>
<a name="ln2594">      if (flags &amp; ECMD_NOWINENTER) {</a>
<a name="ln2595">        readfile_flags |= READ_NOWINENTER;</a>
<a name="ln2596">      }</a>
<a name="ln2597">      if (should_abort(open_buffer(false, eap, readfile_flags))) {</a>
<a name="ln2598">        retval = FAIL;</a>
<a name="ln2599">      }</a>
<a name="ln2600"> </a>
<a name="ln2601">      if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln2602">        retval = FAIL;</a>
<a name="ln2603">      }</a>
<a name="ln2604">      handle_swap_exists(&amp;old_curbuf);</a>
<a name="ln2605">    } else {</a>
<a name="ln2606">      // Read the modelines, but only to set window-local options.  Any</a>
<a name="ln2607">      // buffer-local options have already been set and may have been</a>
<a name="ln2608">      // changed by the user.</a>
<a name="ln2609">      do_modelines(OPT_WINONLY);</a>
<a name="ln2610"> </a>
<a name="ln2611">      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, false, curbuf,</a>
<a name="ln2612">                            &amp;retval);</a>
<a name="ln2613">      if ((flags &amp; ECMD_NOWINENTER) == 0) {</a>
<a name="ln2614">        apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, false, curbuf,</a>
<a name="ln2615">                              &amp;retval);</a>
<a name="ln2616">      }</a>
<a name="ln2617">    }</a>
<a name="ln2618">    check_arg_idx(curwin);</a>
<a name="ln2619"> </a>
<a name="ln2620">    // If autocommands change the cursor position or topline, we should</a>
<a name="ln2621">    // keep it.  Also when it moves within a line. But not when it moves</a>
<a name="ln2622">    // to the first non-blank.</a>
<a name="ln2623">    if (!equalpos(curwin-&gt;w_cursor, orig_pos)) {</a>
<a name="ln2624">      const char *text = get_cursor_line_ptr();</a>
<a name="ln2625"> </a>
<a name="ln2626">      if (curwin-&gt;w_cursor.lnum != orig_pos.lnum</a>
<a name="ln2627">          || curwin-&gt;w_cursor.col != (int)(skipwhite(text) - text)) {</a>
<a name="ln2628">        newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2629">        newcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2630">      }</a>
<a name="ln2631">    }</a>
<a name="ln2632">    if (curwin-&gt;w_topline == topline) {</a>
<a name="ln2633">      topline = 0;</a>
<a name="ln2634">    }</a>
<a name="ln2635"> </a>
<a name="ln2636">    // Even when cursor didn't move we need to recompute topline.</a>
<a name="ln2637">    changed_line_abv_curs();</a>
<a name="ln2638"> </a>
<a name="ln2639">    maketitle();</a>
<a name="ln2640">  }</a>
<a name="ln2641"> </a>
<a name="ln2642">  // Tell the diff stuff that this buffer is new and/or needs updating.</a>
<a name="ln2643">  // Also needed when re-editing the same buffer, because unloading will</a>
<a name="ln2644">  // have removed it as a diff buffer.</a>
<a name="ln2645">  if (curwin-&gt;w_p_diff) {</a>
<a name="ln2646">    diff_buf_add(curbuf);</a>
<a name="ln2647">    diff_invalidate(curbuf);</a>
<a name="ln2648">  }</a>
<a name="ln2649"> </a>
<a name="ln2650">  // If the window options were changed may need to set the spell language.</a>
<a name="ln2651">  // Can only do this after the buffer has been properly setup.</a>
<a name="ln2652">  if (did_get_winopts &amp;&amp; curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2653">    (void)parse_spelllang(curwin);</a>
<a name="ln2654">  }</a>
<a name="ln2655"> </a>
<a name="ln2656">  if (command == NULL) {</a>
<a name="ln2657">    if (newcol &gt;= 0) {          // position set by autocommands</a>
<a name="ln2658">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2659">      curwin-&gt;w_cursor.col = newcol;</a>
<a name="ln2660">      check_cursor();</a>
<a name="ln2661">    } else if (newlnum &gt; 0) {  // line number from caller or old position</a>
<a name="ln2662">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2663">      check_cursor_lnum(curwin);</a>
<a name="ln2664">      if (solcol &gt;= 0 &amp;&amp; !p_sol) {</a>
<a name="ln2665">        // 'sol' is off: Use last known column.</a>
<a name="ln2666">        curwin-&gt;w_cursor.col = solcol;</a>
<a name="ln2667">        check_cursor_col();</a>
<a name="ln2668">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2669">        curwin-&gt;w_set_curswant = true;</a>
<a name="ln2670">      } else {</a>
<a name="ln2671">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2672">      }</a>
<a name="ln2673">    } else {                  // no line number, go to last line in Ex mode</a>
<a name="ln2674">      if (exmode_active) {</a>
<a name="ln2675">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2676">      }</a>
<a name="ln2677">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln2678">    }</a>
<a name="ln2679">  }</a>
<a name="ln2680"> </a>
<a name="ln2681">  // Check if cursors in other windows on the same buffer are still valid</a>
<a name="ln2682">  check_lnums(false);</a>
<a name="ln2683"> </a>
<a name="ln2684">  // Did not read the file, need to show some info about the file.</a>
<a name="ln2685">  // Do this after setting the cursor.</a>
<a name="ln2686">  if (oldbuf</a>
<a name="ln2687">      &amp;&amp; !auto_buf) {</a>
<a name="ln2688">    int msg_scroll_save = msg_scroll;</a>
<a name="ln2689"> </a>
<a name="ln2690">    // Obey the 'O' flag in 'cpoptions': overwrite any previous file</a>
<a name="ln2691">    // message.</a>
<a name="ln2692">    if (shortmess(SHM_OVERALL) &amp;&amp; !msg_listdo_overwrite &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln2693">      msg_scroll = false;</a>
<a name="ln2694">    }</a>
<a name="ln2695">    if (!msg_scroll) {          // wait a bit when overwriting an error msg</a>
<a name="ln2696">      msg_check_for_delay(false);</a>
<a name="ln2697">    }</a>
<a name="ln2698">    msg_start();</a>
<a name="ln2699">    msg_scroll = msg_scroll_save;</a>
<a name="ln2700">    msg_scrolled_ign = true;</a>
<a name="ln2701"> </a>
<a name="ln2702">    if (!shortmess(SHM_FILEINFO)) {</a>
<a name="ln2703">      fileinfo(false, true, false);</a>
<a name="ln2704">    }</a>
<a name="ln2705"> </a>
<a name="ln2706">    msg_scrolled_ign = false;</a>
<a name="ln2707">  }</a>
<a name="ln2708"> </a>
<a name="ln2709">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln2710"> </a>
<a name="ln2711">  if (command != NULL) {</a>
<a name="ln2712">    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);</a>
<a name="ln2713">  }</a>
<a name="ln2714"> </a>
<a name="ln2715">  if (curbuf-&gt;b_kmap_state &amp; KEYMAP_INIT) {</a>
<a name="ln2716">    (void)keymap_init();</a>
<a name="ln2717">  }</a>
<a name="ln2718"> </a>
<a name="ln2719">  RedrawingDisabled--;</a>
<a name="ln2720">  did_inc_redrawing_disabled = false;</a>
<a name="ln2721">  if (!skip_redraw) {</a>
<a name="ln2722">    n = *so_ptr;</a>
<a name="ln2723">    if (topline == 0 &amp;&amp; command == NULL) {</a>
<a name="ln2724">      *so_ptr = 999;    // force cursor to be vertically centered in the window</a>
<a name="ln2725">    }</a>
<a name="ln2726">    update_topline(curwin);</a>
<a name="ln2727">    curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln2728">    *so_ptr = n;</a>
<a name="ln2729">    redraw_curbuf_later(UPD_NOT_VALID);  // redraw this buffer later</a>
<a name="ln2730">  }</a>
<a name="ln2731"> </a>
<a name="ln2732">  // Change directories when the 'acd' option is set.</a>
<a name="ln2733">  do_autochdir();</a>
<a name="ln2734"> </a>
<a name="ln2735">theend:</a>
<a name="ln2736">  if (bufref_valid(&amp;old_curbuf) &amp;&amp; old_curbuf.br_buf-&gt;terminal != NULL) {</a>
<a name="ln2737">    terminal_check_size(old_curbuf.br_buf-&gt;terminal);</a>
<a name="ln2738">  }</a>
<a name="ln2739"> </a>
<a name="ln2740">  if (did_inc_redrawing_disabled) {</a>
<a name="ln2741">    RedrawingDisabled--;</a>
<a name="ln2742">  }</a>
<a name="ln2743">  if (did_set_swapcommand) {</a>
<a name="ln2744">    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);</a>
<a name="ln2745">  }</a>
<a name="ln2746">  xfree(free_fname);</a>
<a name="ln2747">  return retval;</a>
<a name="ln2748">}</a>
<a name="ln2749"> </a>
<a name="ln2750">static void delbuf_msg(char *name)</a>
<a name="ln2751">{</a>
<a name="ln2752">  semsg(_(&quot;E143: Autocommands unexpectedly deleted new buffer %s&quot;),</a>
<a name="ln2753">        name == NULL ? &quot;&quot; : name);</a>
<a name="ln2754">  xfree(name);</a>
<a name="ln2755">  au_new_curbuf.br_buf = NULL;</a>
<a name="ln2756">  au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2757">}</a>
<a name="ln2758"> </a>
<a name="ln2759">static int append_indent = 0;       // autoindent for first line</a>
<a name="ln2760"> </a>
<a name="ln2761">/// &quot;:insert&quot; and &quot;:append&quot;, also used by &quot;:change&quot;</a>
<a name="ln2762">void ex_append(exarg_T *eap)</a>
<a name="ln2763">{</a>
<a name="ln2764">  char *theline;</a>
<a name="ln2765">  bool did_undo = false;</a>
<a name="ln2766">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2767">  int indent = 0;</a>
<a name="ln2768">  char *p;</a>
<a name="ln2769">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln2770"> </a>
<a name="ln2771">  // the ! flag toggles autoindent</a>
<a name="ln2772">  if (eap-&gt;forceit) {</a>
<a name="ln2773">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2774">  }</a>
<a name="ln2775"> </a>
<a name="ln2776">  // First autoindent comes from the line we start on</a>
<a name="ln2777">  if (eap-&gt;cmdidx != CMD_change &amp;&amp; curbuf-&gt;b_p_ai &amp;&amp; lnum &gt; 0) {</a>
<a name="ln2778">    append_indent = get_indent_lnum(lnum);</a>
<a name="ln2779">  }</a>
<a name="ln2780"> </a>
<a name="ln2781">  if (eap-&gt;cmdidx != CMD_append) {</a>
<a name="ln2782">    lnum--;</a>
<a name="ln2783">  }</a>
<a name="ln2784"> </a>
<a name="ln2785">  // when the buffer is empty need to delete the dummy line</a>
<a name="ln2786">  if (empty &amp;&amp; lnum == 1) {</a>
<a name="ln2787">    lnum = 0;</a>
<a name="ln2788">  }</a>
<a name="ln2789"> </a>
<a name="ln2790">  State = MODE_INSERT;                   // behave like in Insert mode</a>
<a name="ln2791">  if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln2792">    State |= MODE_LANGMAP;</a>
<a name="ln2793">  }</a>
<a name="ln2794"> </a>
<a name="ln2795">  while (true) {</a>
<a name="ln2796">    msg_scroll = true;</a>
<a name="ln2797">    need_wait_return = false;</a>
<a name="ln2798">    if (curbuf-&gt;b_p_ai) {</a>
<a name="ln2799">      if (append_indent &gt;= 0) {</a>
<a name="ln2800">        indent = append_indent;</a>
<a name="ln2801">        append_indent = -1;</a>
<a name="ln2802">      } else if (lnum &gt; 0) {</a>
<a name="ln2803">        indent = get_indent_lnum(lnum);</a>
<a name="ln2804">      }</a>
<a name="ln2805">    }</a>
<a name="ln2806">    if (eap-&gt;getline == NULL) {</a>
<a name="ln2807">      // No getline() function, use the lines that follow. This ends</a>
<a name="ln2808">      // when there is no more.</a>
<a name="ln2809">      if (eap-&gt;nextcmd == NULL || *eap-&gt;nextcmd == NUL) {</a>
<a name="ln2810">        break;</a>
<a name="ln2811">      }</a>
<a name="ln2812">      p = vim_strchr(eap-&gt;nextcmd, NL);</a>
<a name="ln2813">      if (p == NULL) {</a>
<a name="ln2814">        p = eap-&gt;nextcmd + strlen(eap-&gt;nextcmd);</a>
<a name="ln2815">      }</a>
<a name="ln2816">      theline = xstrnsave(eap-&gt;nextcmd, (size_t)(p - eap-&gt;nextcmd));</a>
<a name="ln2817">      if (*p != NUL) {</a>
<a name="ln2818">        p++;</a>
<a name="ln2819">      }</a>
<a name="ln2820">      eap-&gt;nextcmd = p;</a>
<a name="ln2821">    } else {</a>
<a name="ln2822">      int save_State = State;</a>
<a name="ln2823">      // Set State to avoid the cursor shape to be set to MODE_INSERT</a>
<a name="ln2824">      // state when getline() returns.</a>
<a name="ln2825">      State = MODE_CMDLINE;</a>
<a name="ln2826">      theline = eap-&gt;getline(eap-&gt;cstack-&gt;cs_looplevel &gt; 0 ? -1 : NUL, eap-&gt;cookie, indent, true);</a>
<a name="ln2827">      State = save_State;</a>
<a name="ln2828">    }</a>
<a name="ln2829">    lines_left = Rows - 1;</a>
<a name="ln2830">    if (theline == NULL) {</a>
<a name="ln2831">      break;</a>
<a name="ln2832">    }</a>
<a name="ln2833"> </a>
<a name="ln2834">    // Look for the &quot;.&quot; after automatic indent.</a>
<a name="ln2835">    int vcol = 0;</a>
<a name="ln2836">    for (p = theline; indent &gt; vcol; p++) {</a>
<a name="ln2837">      if (*p == ' ') {</a>
<a name="ln2838">        vcol++;</a>
<a name="ln2839">      } else if (*p == TAB) {</a>
<a name="ln2840">        vcol += 8 - vcol % 8;</a>
<a name="ln2841">      } else {</a>
<a name="ln2842">        break;</a>
<a name="ln2843">      }</a>
<a name="ln2844">    }</a>
<a name="ln2845">    if ((p[0] == '.' &amp;&amp; p[1] == NUL)</a>
<a name="ln2846">        || (!did_undo &amp;&amp; u_save(lnum, lnum + 1 + (empty ? 1 : 0))</a>
<a name="ln2847">            == FAIL)) {</a>
<a name="ln2848">      xfree(theline);</a>
<a name="ln2849">      break;</a>
<a name="ln2850">    }</a>
<a name="ln2851"> </a>
<a name="ln2852">    // don't use autoindent if nothing was typed.</a>
<a name="ln2853">    if (p[0] == NUL) {</a>
<a name="ln2854">      theline[0] = NUL;</a>
<a name="ln2855">    }</a>
<a name="ln2856"> </a>
<a name="ln2857">    did_undo = true;</a>
<a name="ln2858">    ml_append(lnum, theline, (colnr_T)0, false);</a>
<a name="ln2859">    if (empty) {</a>
<a name="ln2860">      // there are no marks below the inserted lines</a>
<a name="ln2861">      appended_lines(lnum, 1L);</a>
<a name="ln2862">    } else {</a>
<a name="ln2863">      appended_lines_mark(lnum, 1L);</a>
<a name="ln2864">    }</a>
<a name="ln2865"> </a>
<a name="ln2866">    xfree(theline);</a>
<a name="ln2867">    lnum++;</a>
<a name="ln2868"> </a>
<a name="ln2869">    if (empty) {</a>
<a name="ln2870">      ml_delete(2L, false);</a>
<a name="ln2871">      empty = 0;</a>
<a name="ln2872">    }</a>
<a name="ln2873">  }</a>
<a name="ln2874">  State = MODE_NORMAL;</a>
<a name="ln2875"> </a>
<a name="ln2876">  if (eap-&gt;forceit) {</a>
<a name="ln2877">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2878">  }</a>
<a name="ln2879"> </a>
<a name="ln2880">  // &quot;start&quot; is set to eap-&gt;line2+1 unless that position is invalid (when</a>
<a name="ln2881">  // eap-&gt;line2 pointed to the end of the buffer and nothing was appended)</a>
<a name="ln2882">  // &quot;end&quot; is set to lnum when something has been appended, otherwise</a>
<a name="ln2883">  // it is the same as &quot;start&quot;  -- Acevedo</a>
<a name="ln2884">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2885">    curbuf-&gt;b_op_start.lnum</a>
<a name="ln2886">      = (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count) ? eap-&gt;line2 + 1 : curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2887">    if (eap-&gt;cmdidx != CMD_append) {</a>
<a name="ln2888">      curbuf-&gt;b_op_start.lnum--;</a>
<a name="ln2889">    }</a>
<a name="ln2890">    curbuf-&gt;b_op_end.lnum = (eap-&gt;line2 &lt; lnum) ? lnum : curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2891">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln2892">  }</a>
<a name="ln2893">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2894">  check_cursor_lnum(curwin);</a>
<a name="ln2895">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln2896"> </a>
<a name="ln2897">  need_wait_return = false;     // don't use wait_return() now</a>
<a name="ln2898">  ex_no_reprint = true;</a>
<a name="ln2899">}</a>
<a name="ln2900"> </a>
<a name="ln2901">/// &quot;:change&quot;</a>
<a name="ln2902">void ex_change(exarg_T *eap)</a>
<a name="ln2903">{</a>
<a name="ln2904">  linenr_T lnum;</a>
<a name="ln2905"> </a>
<a name="ln2906">  if (eap-&gt;line2 &gt;= eap-&gt;line1</a>
<a name="ln2907">      &amp;&amp; u_save(eap-&gt;line1 - 1, eap-&gt;line2 + 1) == FAIL) {</a>
<a name="ln2908">    return;</a>
<a name="ln2909">  }</a>
<a name="ln2910"> </a>
<a name="ln2911">  // the ! flag toggles autoindent</a>
<a name="ln2912">  if (eap-&gt;forceit ? !curbuf-&gt;b_p_ai : curbuf-&gt;b_p_ai) {</a>
<a name="ln2913">    append_indent = get_indent_lnum(eap-&gt;line1);</a>
<a name="ln2914">  }</a>
<a name="ln2915"> </a>
<a name="ln2916">  for (lnum = eap-&gt;line2; lnum &gt;= eap-&gt;line1; lnum--) {</a>
<a name="ln2917">    if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {         // nothing to delete</a>
<a name="ln2918">      break;</a>
<a name="ln2919">    }</a>
<a name="ln2920">    ml_delete(eap-&gt;line1, false);</a>
<a name="ln2921">  }</a>
<a name="ln2922"> </a>
<a name="ln2923">  // make sure the cursor is not beyond the end of the file now</a>
<a name="ln2924">  check_cursor_lnum(curwin);</a>
<a name="ln2925">  deleted_lines_mark(eap-&gt;line1, (eap-&gt;line2 - lnum));</a>
<a name="ln2926"> </a>
<a name="ln2927">  // &quot;:append&quot; on the line above the deleted lines.</a>
<a name="ln2928">  eap-&gt;line2 = eap-&gt;line1;</a>
<a name="ln2929">  ex_append(eap);</a>
<a name="ln2930">}</a>
<a name="ln2931"> </a>
<a name="ln2932">void ex_z(exarg_T *eap)</a>
<a name="ln2933">{</a>
<a name="ln2934">  char *x;</a>
<a name="ln2935">  int64_t bigness;</a>
<a name="ln2936">  char *kind;</a>
<a name="ln2937">  int minus = 0;</a>
<a name="ln2938">  linenr_T start, end, curs, i;</a>
<a name="ln2939">  int j;</a>
<a name="ln2940">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2941"> </a>
<a name="ln2942">  // Vi compatible: &quot;:z!&quot; uses display height, without a count uses</a>
<a name="ln2943">  // 'scroll'</a>
<a name="ln2944">  if (eap-&gt;forceit) {</a>
<a name="ln2945">    bigness = Rows - 1;</a>
<a name="ln2946">  } else if (ONE_WINDOW) {</a>
<a name="ln2947">    bigness = curwin-&gt;w_p_scr * 2;</a>
<a name="ln2948">  } else {</a>
<a name="ln2949">    bigness = curwin-&gt;w_height_inner - 3;</a>
<a name="ln2950">  }</a>
<a name="ln2951">  if (bigness &lt; 1) {</a>
<a name="ln2952">    bigness = 1;</a>
<a name="ln2953">  }</a>
<a name="ln2954"> </a>
<a name="ln2955">  x = eap-&gt;arg;</a>
<a name="ln2956">  kind = x;</a>
<a name="ln2957">  if (*kind == '-' || *kind == '+' || *kind == '='</a>
<a name="ln2958">      || *kind == '^' || *kind == '.') {</a>
<a name="ln2959">    x++;</a>
<a name="ln2960">  }</a>
<a name="ln2961">  while (*x == '-' || *x == '+') {</a>
<a name="ln2962">    x++;</a>
<a name="ln2963">  }</a>
<a name="ln2964"> </a>
<a name="ln2965">  if (*x != 0) {</a>
<a name="ln2966">    if (!ascii_isdigit(*x)) {</a>
<a name="ln2967">      emsg(_(e_non_numeric_argument_to_z));</a>
<a name="ln2968">      return;</a>
<a name="ln2969">    }</a>
<a name="ln2970">    bigness = atol(x);</a>
<a name="ln2971"> </a>
<a name="ln2972">    // bigness could be &lt; 0 if atol(x) overflows.</a>
<a name="ln2973">    if (bigness &gt; 2 * curbuf-&gt;b_ml.ml_line_count || bigness &lt; 0) {</a>
<a name="ln2974">      bigness = 2 * curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2975">    }</a>
<a name="ln2976"> </a>
<a name="ln2977">    p_window = (int)bigness;</a>
<a name="ln2978">    if (*kind == '=') {</a>
<a name="ln2979">      bigness += 2;</a>
<a name="ln2980">    }</a>
<a name="ln2981">  }</a>
<a name="ln2982"> </a>
<a name="ln2983">  // the number of '-' and '+' multiplies the distance</a>
<a name="ln2984">  if (*kind == '-' || *kind == '+') {</a>
<a name="ln2985">    for (x = kind + 1; *x == *kind; x++) {}</a>
<a name="ln2986">  }</a>
<a name="ln2987"> </a>
<a name="ln2988">  switch (*kind) {</a>
<a name="ln2989">  case '-':</a>
<a name="ln2990">    start = lnum - (linenr_T)bigness * (linenr_T)(x - kind) + 1;</a>
<a name="ln2991">    end = start + (linenr_T)bigness - 1;</a>
<a name="ln2992">    curs = end;</a>
<a name="ln2993">    break;</a>
<a name="ln2994"> </a>
<a name="ln2995">  case '=':</a>
<a name="ln2996">    start = lnum - ((linenr_T)bigness + 1) / 2 + 1;</a>
<a name="ln2997">    end = lnum + ((linenr_T)bigness + 1) / 2 - 1;</a>
<a name="ln2998">    curs = lnum;</a>
<a name="ln2999">    minus = 1;</a>
<a name="ln3000">    break;</a>
<a name="ln3001"> </a>
<a name="ln3002">  case '^':</a>
<a name="ln3003">    start = lnum - (linenr_T)bigness * 2;</a>
<a name="ln3004">    end = lnum - (linenr_T)bigness;</a>
<a name="ln3005">    curs = lnum - (linenr_T)bigness;</a>
<a name="ln3006">    break;</a>
<a name="ln3007"> </a>
<a name="ln3008">  case '.':</a>
<a name="ln3009">    start = lnum - ((linenr_T)bigness + 1) / 2 + 1;</a>
<a name="ln3010">    end = lnum + ((linenr_T)bigness + 1) / 2 - 1;</a>
<a name="ln3011">    curs = end;</a>
<a name="ln3012">    break;</a>
<a name="ln3013"> </a>
<a name="ln3014">  default:        // '+'</a>
<a name="ln3015">    start = lnum;</a>
<a name="ln3016">    if (*kind == '+') {</a>
<a name="ln3017">      start += (linenr_T)bigness * (linenr_T)(x - kind - 1) + 1;</a>
<a name="ln3018">    } else if (eap-&gt;addr_count == 0) {</a>
<a name="ln3019">      start++;</a>
<a name="ln3020">    }</a>
<a name="ln3021">    end = start + (linenr_T)bigness - 1;</a>
<a name="ln3022">    curs = end;</a>
<a name="ln3023">    break;</a>
<a name="ln3024">  }</a>
<a name="ln3025"> </a>
<a name="ln3026">  if (start &lt; 1) {</a>
<a name="ln3027">    start = 1;</a>
<a name="ln3028">  }</a>
<a name="ln3029"> </a>
<a name="ln3030">  if (end &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3031">    end = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3032">  }</a>
<a name="ln3033"> </a>
<a name="ln3034">  if (curs &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3035">    curs = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3036">  } else if (curs &lt; 1) {</a>
<a name="ln3037">    curs = 1;</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040">  for (i = start; i &lt;= end; i++) {</a>
<a name="ln3041">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3042">      msg_putchar('\n');</a>
<a name="ln3043"> </a>
<a name="ln3044">      for (j = 1; j &lt; Columns; j++) {</a>
<a name="ln3045">        msg_putchar('-');</a>
<a name="ln3046">      }</a>
<a name="ln3047">    }</a>
<a name="ln3048"> </a>
<a name="ln3049">    print_line(i, eap-&gt;flags &amp; EXFLAG_NR, eap-&gt;flags &amp; EXFLAG_LIST);</a>
<a name="ln3050"> </a>
<a name="ln3051">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3052">      msg_putchar('\n');</a>
<a name="ln3053"> </a>
<a name="ln3054">      for (j = 1; j &lt; Columns; j++) {</a>
<a name="ln3055">        msg_putchar('-');</a>
<a name="ln3056">      }</a>
<a name="ln3057">    }</a>
<a name="ln3058">  }</a>
<a name="ln3059"> </a>
<a name="ln3060">  if (curwin-&gt;w_cursor.lnum != curs) {</a>
<a name="ln3061">    curwin-&gt;w_cursor.lnum = curs;</a>
<a name="ln3062">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3063">  }</a>
<a name="ln3064">  ex_no_reprint = true;</a>
<a name="ln3065">}</a>
<a name="ln3066"> </a>
<a name="ln3067">/// @return  true if the secure flag is set and also give an error message.</a>
<a name="ln3068">///          Otherwise, return false.</a>
<a name="ln3069">bool check_secure(void)</a>
<a name="ln3070">{</a>
<a name="ln3071">  if (secure) {</a>
<a name="ln3072">    secure = 2;</a>
<a name="ln3073">    emsg(_(e_curdir));</a>
<a name="ln3074">    return true;</a>
<a name="ln3075">  }</a>
<a name="ln3076"> </a>
<a name="ln3077">  // In the sandbox more things are not allowed, including the things</a>
<a name="ln3078">  // disallowed in secure mode.</a>
<a name="ln3079">  if (sandbox != 0) {</a>
<a name="ln3080">    emsg(_(e_sandbox));</a>
<a name="ln3081">    return true;</a>
<a name="ln3082">  }</a>
<a name="ln3083">  return false;</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086">/// Previous substitute replacement string</a>
<a name="ln3087">static SubReplacementString old_sub = { NULL, 0, NULL };</a>
<a name="ln3088"> </a>
<a name="ln3089">static int global_need_beginline;       // call beginline() after &quot;:g&quot;</a>
<a name="ln3090"> </a>
<a name="ln3091">/// Get old substitute replacement string</a>
<a name="ln3092">///</a>
<a name="ln3093">/// @param[out]  ret_sub    Location where old string will be saved.</a>
<a name="ln3094">void sub_get_replacement(SubReplacementString *const ret_sub)</a>
<a name="ln3095">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3096">{</a>
<a name="ln3097">  *ret_sub = old_sub;</a>
<a name="ln3098">}</a>
<a name="ln3099"> </a>
<a name="ln3100">/// Set substitute string and timestamp</a>
<a name="ln3101">///</a>
<a name="ln3102">/// @warning `sub` must be in allocated memory. It is not copied.</a>
<a name="ln3103">///</a>
<a name="ln3104">/// @param[in]  sub  New replacement string.</a>
<a name="ln3105">void sub_set_replacement(SubReplacementString sub)</a>
<a name="ln3106">{</a>
<a name="ln3107">  xfree(old_sub.sub);</a>
<a name="ln3108">  if (sub.additional_elements != old_sub.additional_elements) {</a>
<a name="ln3109">    tv_list_unref(old_sub.additional_elements);</a>
<a name="ln3110">  }</a>
<a name="ln3111">  old_sub = sub;</a>
<a name="ln3112">}</a>
<a name="ln3113"> </a>
<a name="ln3114">/// Recognize &quot;:%s/\n//&quot; and turn it into a join command, which is much</a>
<a name="ln3115">/// more efficient.</a>
<a name="ln3116">///</a>
<a name="ln3117">/// @param[in]  eap  Ex arguments</a>
<a name="ln3118">/// @param[in]  pat  Search pattern</a>
<a name="ln3119">/// @param[in]  sub  Replacement string</a>
<a name="ln3120">/// @param[in]  cmd  Command from :s_flags</a>
<a name="ln3121">/// @param[in]  save Save pattern to options, history</a>
<a name="ln3122">///</a>
<a name="ln3123">/// @returns true if :substitute can be replaced with a join command</a>
<a name="ln3124">static bool sub_joining_lines(exarg_T *eap, char *pat, const char *sub, const char *cmd, bool save)</a>
<a name="ln3125">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln3126">{</a>
<a name="ln3127">  // TODO(vim): find a generic solution to make line-joining operations more</a>
<a name="ln3128">  // efficient, avoid allocating a string that grows in size.</a>
<a name="ln3129">  if (pat != NULL</a>
<a name="ln3130">      &amp;&amp; strcmp(pat, &quot;\\n&quot;) == 0</a>
<a name="ln3131">      &amp;&amp; *sub == NUL</a>
<a name="ln3132">      &amp;&amp; (*cmd == NUL || (cmd[1] == NUL</a>
<a name="ln3133">                          &amp;&amp; (*cmd == 'g'</a>
<a name="ln3134">                              || *cmd == 'l'</a>
<a name="ln3135">                              || *cmd == 'p'</a>
<a name="ln3136">                              || *cmd == '#')))) {</a>
<a name="ln3137">    if (eap-&gt;skip) {</a>
<a name="ln3138">      return true;</a>
<a name="ln3139">    }</a>
<a name="ln3140">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln3141">    if (*cmd == 'l') {</a>
<a name="ln3142">      eap-&gt;flags = EXFLAG_LIST;</a>
<a name="ln3143">    } else if (*cmd == '#') {</a>
<a name="ln3144">      eap-&gt;flags = EXFLAG_NR;</a>
<a name="ln3145">    } else if (*cmd == 'p') {</a>
<a name="ln3146">      eap-&gt;flags = EXFLAG_PRINT;</a>
<a name="ln3147">    }</a>
<a name="ln3148"> </a>
<a name="ln3149">    // The number of lines joined is the number of lines in the range</a>
<a name="ln3150">    linenr_T joined_lines_count = eap-&gt;line2 - eap-&gt;line1 + 1</a>
<a name="ln3151">                                  // plus one extra line if not at the end of file.</a>
<a name="ln3152">                                  + (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count ? 1 : 0);</a>
<a name="ln3153">    if (joined_lines_count &gt; 1) {</a>
<a name="ln3154">      do_join((size_t)joined_lines_count, false, true, false, true);</a>
<a name="ln3155">      sub_nsubs = joined_lines_count - 1;</a>
<a name="ln3156">      sub_nlines = 1;</a>
<a name="ln3157">      do_sub_msg(false);</a>
<a name="ln3158">      ex_may_print(eap);</a>
<a name="ln3159">    }</a>
<a name="ln3160"> </a>
<a name="ln3161">    if (save) {</a>
<a name="ln3162">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPPATTERNS) == 0) {</a>
<a name="ln3163">        save_re_pat(RE_SUBST, pat, magic_isset());</a>
<a name="ln3164">      }</a>
<a name="ln3165">      // put pattern in history</a>
<a name="ln3166">      add_to_history(HIST_SEARCH, pat, true, NUL);</a>
<a name="ln3167">    }</a>
<a name="ln3168"> </a>
<a name="ln3169">    return true;</a>
<a name="ln3170">  }</a>
<a name="ln3171"> </a>
<a name="ln3172">  return false;</a>
<a name="ln3173">}</a>
<a name="ln3174"> </a>
<a name="ln3175">/// Allocate memory to store the replacement text for :substitute.</a>
<a name="ln3176">///</a>
<a name="ln3177">/// Slightly more memory that is strictly necessary is allocated to reduce the</a>
<a name="ln3178">/// frequency of memory (re)allocation.</a>
<a name="ln3179">///</a>
<a name="ln3180">/// @param[in,out]  new_start      pointer to the memory for the replacement text</a>
<a name="ln3181">/// @param[in,out]  new_start_len  pointer to length of new_start</a>
<a name="ln3182">/// @param[in]      needed_len     amount of memory needed</a>
<a name="ln3183">///</a>
<a name="ln3184">/// @returns pointer to the end of the allocated memory</a>
<a name="ln3185">static char *sub_grow_buf(char **new_start, int *new_start_len, int needed_len)</a>
<a name="ln3186">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3187">{</a>
<a name="ln3188">  char *new_end;</a>
<a name="ln3189">  if (*new_start == NULL) {</a>
<a name="ln3190">    // Get some space for a temporary buffer to do the</a>
<a name="ln3191">    // substitution into (and some extra space to avoid</a>
<a name="ln3192">    // too many calls to xmalloc()/free()).</a>
<a name="ln3193">    *new_start_len = needed_len + 50;</a>
<a name="ln3194">    *new_start = xmalloc((size_t)(*new_start_len));</a>
<a name="ln3195">    **new_start = NUL;</a>
<a name="ln3196">    new_end = *new_start;</a>
<a name="ln3197">  } else {</a>
<a name="ln3198">    // Check if the temporary buffer is long enough to do the</a>
<a name="ln3199">    // substitution into.  If not, make it larger (with a bit</a>
<a name="ln3200">    // extra to avoid too many calls to xmalloc()/free()).</a>
<a name="ln3201">    size_t len = strlen(*new_start);</a>
<a name="ln3202">    needed_len += (int)len;</a>
<a name="ln3203">    if (needed_len &gt; *new_start_len) {</a>
<a name="ln3204">      *new_start_len = needed_len + 50;</a>
<a name="ln3205">      *new_start = xrealloc(*new_start, (size_t)(*new_start_len));</a>
<a name="ln3206">    }</a>
<a name="ln3207">    new_end = *new_start + len;</a>
<a name="ln3208">  }</a>
<a name="ln3209"> </a>
<a name="ln3210">  return new_end;</a>
<a name="ln3211">}</a>
<a name="ln3212"> </a>
<a name="ln3213">/// Parse cmd string for :substitute's {flags} and update subflags accordingly</a>
<a name="ln3214">///</a>
<a name="ln3215">/// @param[in]      cmd  command string</a>
<a name="ln3216">/// @param[in,out]  subflags  current flags defined for the :substitute command</a>
<a name="ln3217">/// @param[in,out]  which_pat  pattern type from which to get default search</a>
<a name="ln3218">///</a>
<a name="ln3219">/// @returns pointer to the end of the flags, which may be the end of the string</a>
<a name="ln3220">static char *sub_parse_flags(char *cmd, subflags_T *subflags, int *which_pat)</a>
<a name="ln3221">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3222">{</a>
<a name="ln3223">  // Find trailing options.  When '&amp;' is used, keep old options.</a>
<a name="ln3224">  if (*cmd == '&amp;') {</a>
<a name="ln3225">    cmd++;</a>
<a name="ln3226">  } else {</a>
<a name="ln3227">    subflags-&gt;do_all = p_gd;</a>
<a name="ln3228">    subflags-&gt;do_ask = false;</a>
<a name="ln3229">    subflags-&gt;do_error = true;</a>
<a name="ln3230">    subflags-&gt;do_print = false;</a>
<a name="ln3231">    subflags-&gt;do_list = false;</a>
<a name="ln3232">    subflags-&gt;do_count = false;</a>
<a name="ln3233">    subflags-&gt;do_number = false;</a>
<a name="ln3234">    subflags-&gt;do_ic = kSubHonorOptions;</a>
<a name="ln3235">  }</a>
<a name="ln3236">  while (*cmd) {</a>
<a name="ln3237">    // Note that 'g' and 'c' are always inverted.</a>
<a name="ln3238">    // 'r' is never inverted.</a>
<a name="ln3239">    if (*cmd == 'g') {</a>
<a name="ln3240">      subflags-&gt;do_all = !subflags-&gt;do_all;</a>
<a name="ln3241">    } else if (*cmd == 'c') {</a>
<a name="ln3242">      subflags-&gt;do_ask = !subflags-&gt;do_ask;</a>
<a name="ln3243">    } else if (*cmd == 'n') {</a>
<a name="ln3244">      subflags-&gt;do_count = true;</a>
<a name="ln3245">    } else if (*cmd == 'e') {</a>
<a name="ln3246">      subflags-&gt;do_error = !subflags-&gt;do_error;</a>
<a name="ln3247">    } else if (*cmd == 'r') {  // use last used regexp</a>
<a name="ln3248">      *which_pat = RE_LAST;</a>
<a name="ln3249">    } else if (*cmd == 'p') {</a>
<a name="ln3250">      subflags-&gt;do_print = true;</a>
<a name="ln3251">    } else if (*cmd == '#') {</a>
<a name="ln3252">      subflags-&gt;do_print = true;</a>
<a name="ln3253">      subflags-&gt;do_number = true;</a>
<a name="ln3254">    } else if (*cmd == 'l') {</a>
<a name="ln3255">      subflags-&gt;do_print = true;</a>
<a name="ln3256">      subflags-&gt;do_list = true;</a>
<a name="ln3257">    } else if (*cmd == 'i') {  // ignore case</a>
<a name="ln3258">      subflags-&gt;do_ic = kSubIgnoreCase;</a>
<a name="ln3259">    } else if (*cmd == 'I') {  // don't ignore case</a>
<a name="ln3260">      subflags-&gt;do_ic = kSubMatchCase;</a>
<a name="ln3261">    } else {</a>
<a name="ln3262">      break;</a>
<a name="ln3263">    }</a>
<a name="ln3264">    cmd++;</a>
<a name="ln3265">  }</a>
<a name="ln3266">  if (subflags-&gt;do_count) {</a>
<a name="ln3267">    subflags-&gt;do_ask = false;</a>
<a name="ln3268">  }</a>
<a name="ln3269"> </a>
<a name="ln3270">  return cmd;</a>
<a name="ln3271">}</a>
<a name="ln3272"> </a>
<a name="ln3273">static int check_regexp_delim(int c)</a>
<a name="ln3274">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3275">{</a>
<a name="ln3276">  if (isalpha(c)) {</a>
<a name="ln3277">    emsg(_(&quot;E146: Regular expressions can't be delimited by letters&quot;));</a>
<a name="ln3278">    return FAIL;</a>
<a name="ln3279">  }</a>
<a name="ln3280">  return OK;</a>
<a name="ln3281">}</a>
<a name="ln3282"> </a>
<a name="ln3283">/// Perform a substitution from line eap-&gt;line1 to line eap-&gt;line2 using the</a>
<a name="ln3284">/// command pointed to by eap-&gt;arg which should be of the form:</a>
<a name="ln3285">///</a>
<a name="ln3286">/// /pattern/substitution/{flags}</a>
<a name="ln3287">///</a>
<a name="ln3288">/// The usual escapes are supported as described in the regexp docs.</a>
<a name="ln3289">///</a>
<a name="ln3290">/// @param cmdpreview_ns  The namespace to show 'inccommand' preview highlights.</a>
<a name="ln3291">///                       If &lt;= 0, preview shouldn't be shown.</a>
<a name="ln3292">/// @return 0, 1 or 2. See show_cmdpreview() for more information on what the return value means.</a>
<a name="ln3293">static int do_sub(exarg_T *eap, const proftime_T timeout, const long cmdpreview_ns,</a>
<a name="ln3294">                  const handle_T cmdpreview_bufnr)</a>
<a name="ln3295">{</a>
<a name="ln3296">#define ADJUST_SUB_FIRSTLNUM() \</a>
<a name="ln3297">  do { \</a>
<a name="ln3298">    /* For a multi-line match, make a copy of the last matched */ \</a>
<a name="ln3299">    /* line and continue in that one. */ \</a>
<a name="ln3300">    if (nmatch &gt; 1) { \</a>
<a name="ln3301">      sub_firstlnum += (linenr_T)nmatch - 1; \</a>
<a name="ln3302">      xfree(sub_firstline); \</a>
<a name="ln3303">      sub_firstline = xstrdup(ml_get(sub_firstlnum)); \</a>
<a name="ln3304">      /* When going beyond the last line, stop substituting. */ \</a>
<a name="ln3305">      if (sub_firstlnum &lt;= line2) { \</a>
<a name="ln3306">        do_again = true; \</a>
<a name="ln3307">      } else { \</a>
<a name="ln3308">        subflags.do_all = false; \</a>
<a name="ln3309">      } \</a>
<a name="ln3310">    } \</a>
<a name="ln3311">    if (skip_match) { \</a>
<a name="ln3312">      /* Already hit end of the buffer, sub_firstlnum is one */ \</a>
<a name="ln3313">      /* less than what it ought to be. */ \</a>
<a name="ln3314">      xfree(sub_firstline); \</a>
<a name="ln3315">      sub_firstline = xstrdup(&quot;&quot;); \</a>
<a name="ln3316">      copycol = 0; \</a>
<a name="ln3317">    } \</a>
<a name="ln3318">  } while (0)</a>
<a name="ln3319"> </a>
<a name="ln3320">  long i = 0;</a>
<a name="ln3321">  regmmatch_T regmatch;</a>
<a name="ln3322">  static subflags_T subflags = {</a>
<a name="ln3323">    .do_all = false,</a>
<a name="ln3324">    .do_ask = false,</a>
<a name="ln3325">    .do_count = false,</a>
<a name="ln3326">    .do_error = true,</a>
<a name="ln3327">    .do_print = false,</a>
<a name="ln3328">    .do_list = false,</a>
<a name="ln3329">    .do_number = false,</a>
<a name="ln3330">    .do_ic = kSubHonorOptions</a>
<a name="ln3331">  };</a>
<a name="ln3332">  char *pat = NULL, *sub = NULL;  // init for GCC</a>
<a name="ln3333">  int delimiter;</a>
<a name="ln3334">  bool has_second_delim = false;</a>
<a name="ln3335">  int sublen;</a>
<a name="ln3336">  bool got_quit = false;</a>
<a name="ln3337">  bool got_match = false;</a>
<a name="ln3338">  int which_pat;</a>
<a name="ln3339">  char *cmd = eap-&gt;arg;</a>
<a name="ln3340">  linenr_T first_line = 0;  // first changed line</a>
<a name="ln3341">  linenr_T last_line= 0;    // below last changed line AFTER the change</a>
<a name="ln3342">  linenr_T old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3343">  char *sub_firstline;    // allocated copy of first sub line</a>
<a name="ln3344">  bool endcolumn = false;   // cursor in last column when done</a>
<a name="ln3345">  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0 };</a>
<a name="ln3346">  static int pre_hl_id = 0;</a>
<a name="ln3347">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3348">  long start_nsubs;</a>
<a name="ln3349"> </a>
<a name="ln3350">  bool did_save = false;</a>
<a name="ln3351"> </a>
<a name="ln3352">  if (!global_busy) {</a>
<a name="ln3353">    sub_nsubs = 0;</a>
<a name="ln3354">    sub_nlines = 0;</a>
<a name="ln3355">  }</a>
<a name="ln3356">  start_nsubs = sub_nsubs;</a>
<a name="ln3357"> </a>
<a name="ln3358">  if (eap-&gt;cmdidx == CMD_tilde) {</a>
<a name="ln3359">    which_pat = RE_LAST;        // use last used regexp</a>
<a name="ln3360">  } else {</a>
<a name="ln3361">    which_pat = RE_SUBST;       // use last substitute regexp</a>
<a name="ln3362">  }</a>
<a name="ln3363">  // new pattern and substitution</a>
<a name="ln3364">  if (eap-&gt;cmd[0] == 's' &amp;&amp; *cmd != NUL &amp;&amp; !ascii_iswhite(*cmd)</a>
<a name="ln3365">      &amp;&amp; vim_strchr(&quot;0123456789cegriIp|\&quot;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln3366">    // don't accept alphanumeric for separator</a>
<a name="ln3367">    if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln3368">      return 0;</a>
<a name="ln3369">    }</a>
<a name="ln3370"> </a>
<a name="ln3371">    // undocumented vi feature:</a>
<a name="ln3372">    //  &quot;\/sub/&quot; and &quot;\?sub?&quot; use last used search pattern (almost like</a>
<a name="ln3373">    //  //sub/r).  &quot;\&amp;sub&amp;&quot; use last substitute pattern (like //sub/).</a>
<a name="ln3374">    if (*cmd == '\\') {</a>
<a name="ln3375">      cmd++;</a>
<a name="ln3376">      if (vim_strchr(&quot;/?&amp;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln3377">        emsg(_(e_backslash));</a>
<a name="ln3378">        return 0;</a>
<a name="ln3379">      }</a>
<a name="ln3380">      if (*cmd != '&amp;') {</a>
<a name="ln3381">        which_pat = RE_SEARCH;              // use last '/' pattern</a>
<a name="ln3382">      }</a>
<a name="ln3383">      pat = &quot;&quot;;                   // empty search pattern</a>
<a name="ln3384">      delimiter = (uint8_t)(*cmd++);                   // remember delimiter character</a>
<a name="ln3385">      has_second_delim = true;</a>
<a name="ln3386">    } else {          // find the end of the regexp</a>
<a name="ln3387">      which_pat = RE_LAST;                  // use last used regexp</a>
<a name="ln3388">      delimiter = (uint8_t)(*cmd++);                   // remember delimiter character</a>
<a name="ln3389">      pat = cmd;                            // remember start of search pat</a>
<a name="ln3390">      cmd = skip_regexp_ex(cmd, delimiter, magic_isset(), &amp;eap-&gt;arg, NULL, NULL);</a>
<a name="ln3391">      if (cmd[0] == delimiter) {            // end delimiter found</a>
<a name="ln3392">        *cmd++ = NUL;                       // replace it with a NUL</a>
<a name="ln3393">        has_second_delim = true;</a>
<a name="ln3394">      }</a>
<a name="ln3395">    }</a>
<a name="ln3396"> </a>
<a name="ln3397">    // Small incompatibility: vi sees '\n' as end of the command, but in</a>
<a name="ln3398">    // Vim we want to use '\n' to find/substitute a NUL.</a>
<a name="ln3399">    sub = cmd;              // remember the start of the substitution</a>
<a name="ln3400"> </a>
<a name="ln3401">    while (cmd[0]) {</a>
<a name="ln3402">      if (cmd[0] == delimiter) {                // end delimiter found</a>
<a name="ln3403">        *cmd++ = NUL;                           // replace it with a NUL</a>
<a name="ln3404">        break;</a>
<a name="ln3405">      }</a>
<a name="ln3406">      if (cmd[0] == '\\' &amp;&amp; cmd[1] != 0) {      // skip escaped characters</a>
<a name="ln3407">        cmd++;</a>
<a name="ln3408">      }</a>
<a name="ln3409">      MB_PTR_ADV(cmd);</a>
<a name="ln3410">    }</a>
<a name="ln3411"> </a>
<a name="ln3412">    if (!eap-&gt;skip &amp;&amp; cmdpreview_ns &lt;= 0) {</a>
<a name="ln3413">      sub_set_replacement((SubReplacementString) {</a>
<a name="ln3414">        .sub = xstrdup(sub),</a>
<a name="ln3415">        .timestamp = os_time(),</a>
<a name="ln3416">        .additional_elements = NULL,</a>
<a name="ln3417">      });</a>
<a name="ln3418">    }</a>
<a name="ln3419">  } else if (!eap-&gt;skip) {    // use previous pattern and substitution</a>
<a name="ln3420">    if (old_sub.sub == NULL) {      // there is no previous command</a>
<a name="ln3421">      emsg(_(e_nopresub));</a>
<a name="ln3422">      return 0;</a>
<a name="ln3423">    }</a>
<a name="ln3424">    pat = NULL;                 // search_regcomp() will use previous pattern</a>
<a name="ln3425">    sub = old_sub.sub;</a>
<a name="ln3426"> </a>
<a name="ln3427">    // Vi compatibility quirk: repeating with &quot;:s&quot; keeps the cursor in the</a>
<a name="ln3428">    // last column after using &quot;$&quot;.</a>
<a name="ln3429">    endcolumn = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  if (sub != NULL &amp;&amp; sub_joining_lines(eap, pat, sub, cmd, cmdpreview_ns &lt;= 0)) {</a>
<a name="ln3433">    return 0;</a>
<a name="ln3434">  }</a>
<a name="ln3435"> </a>
<a name="ln3436">  cmd = sub_parse_flags(cmd, &amp;subflags, &amp;which_pat);</a>
<a name="ln3437"> </a>
<a name="ln3438">  bool save_do_all = subflags.do_all;  // remember user specified 'g' flag</a>
<a name="ln3439">  bool save_do_ask = subflags.do_ask;  // remember user specified 'c' flag</a>
<a name="ln3440"> </a>
<a name="ln3441">  // check for a trailing count</a>
<a name="ln3442">  cmd = skipwhite(cmd);</a>
<a name="ln3443">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3444">    i = getdigits_long(&amp;cmd, true, 0);</a>
<a name="ln3445">    if (i &lt;= 0 &amp;&amp; !eap-&gt;skip &amp;&amp; subflags.do_error) {</a>
<a name="ln3446">      emsg(_(e_zerocount));</a>
<a name="ln3447">      return 0;</a>
<a name="ln3448">    }</a>
<a name="ln3449">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln3450">    eap-&gt;line2 += (linenr_T)i - 1;</a>
<a name="ln3451">    if (eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3452">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3453">    }</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456">  // check for trailing command or garbage</a>
<a name="ln3457">  cmd = skipwhite(cmd);</a>
<a name="ln3458">  if (*cmd &amp;&amp; *cmd != '&quot;') {        // if not end-of-line or comment</a>
<a name="ln3459">    eap-&gt;nextcmd = check_nextcmd(cmd);</a>
<a name="ln3460">    if (eap-&gt;nextcmd == NULL) {</a>
<a name="ln3461">      semsg(_(e_trailing_arg), cmd);</a>
<a name="ln3462">      return 0;</a>
<a name="ln3463">    }</a>
<a name="ln3464">  }</a>
<a name="ln3465"> </a>
<a name="ln3466">  if (eap-&gt;skip) {          // not executing commands, only parsing</a>
<a name="ln3467">    return 0;</a>
<a name="ln3468">  }</a>
<a name="ln3469"> </a>
<a name="ln3470">  if (!subflags.do_count &amp;&amp; !MODIFIABLE(curbuf)) {</a>
<a name="ln3471">    // Substitution is not allowed in non-'modifiable' buffer</a>
<a name="ln3472">    emsg(_(e_modifiable));</a>
<a name="ln3473">    return 0;</a>
<a name="ln3474">  }</a>
<a name="ln3475"> </a>
<a name="ln3476">  if (search_regcomp(pat, NULL, RE_SUBST, which_pat,</a>
<a name="ln3477">                     (cmdpreview_ns &gt; 0 ? 0 : SEARCH_HIS), &amp;regmatch) == FAIL) {</a>
<a name="ln3478">    if (subflags.do_error) {</a>
<a name="ln3479">      emsg(_(e_invcmd));</a>
<a name="ln3480">    }</a>
<a name="ln3481">    return 0;</a>
<a name="ln3482">  }</a>
<a name="ln3483"> </a>
<a name="ln3484">  // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'</a>
<a name="ln3485">  if (subflags.do_ic == kSubIgnoreCase) {</a>
<a name="ln3486">    regmatch.rmm_ic = true;</a>
<a name="ln3487">  } else if (subflags.do_ic == kSubMatchCase) {</a>
<a name="ln3488">    regmatch.rmm_ic = false;</a>
<a name="ln3489">  }</a>
<a name="ln3490"> </a>
<a name="ln3491">  sub_firstline = NULL;</a>
<a name="ln3492"> </a>
<a name="ln3493">  assert(sub != NULL);</a>
<a name="ln3494"> </a>
<a name="ln3495">  char *sub_copy = NULL;</a>
<a name="ln3496"> </a>
<a name="ln3497">  // If the substitute pattern starts with &quot;\=&quot; then it's an expression.</a>
<a name="ln3498">  // Make a copy, a recursive function may free it.</a>
<a name="ln3499">  // Otherwise, '~' in the substitute pattern is replaced with the old</a>
<a name="ln3500">  // pattern.  We do it here once to avoid it to be replaced over and over</a>
<a name="ln3501">  // again.</a>
<a name="ln3502">  if (sub[0] == '\\' &amp;&amp; sub[1] == '=') {</a>
<a name="ln3503">    sub = xstrdup(sub);</a>
<a name="ln3504">    sub_copy = sub;</a>
<a name="ln3505">  } else {</a>
<a name="ln3506">    char *newsub = regtilde(sub, magic_isset(), cmdpreview_ns &gt; 0);</a>
<a name="ln3507">    if (newsub != sub) {</a>
<a name="ln3508">      // newsub was allocated, free it later.</a>
<a name="ln3509">      sub_copy = newsub;</a>
<a name="ln3510">      sub = newsub;</a>
<a name="ln3511">    }</a>
<a name="ln3512">  }</a>
<a name="ln3513"> </a>
<a name="ln3514">  // Check for a match on each line.</a>
<a name="ln3515">  // If preview: limit to max('cmdwinheight', viewport).</a>
<a name="ln3516">  linenr_T line2 = eap-&gt;line2;</a>
<a name="ln3517"> </a>
<a name="ln3518">  for (linenr_T lnum = eap-&gt;line1;</a>
<a name="ln3519">       lnum &lt;= line2 &amp;&amp; !got_quit &amp;&amp; !aborting()</a>
<a name="ln3520">       &amp;&amp; (cmdpreview_ns &lt;= 0 || preview_lines.lines_needed &lt;= (linenr_T)p_cwh</a>
<a name="ln3521">           || lnum &lt;= curwin-&gt;w_botline);</a>
<a name="ln3522">       lnum++) {</a>
<a name="ln3523">    long nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln3524">                                    (colnr_T)0, NULL, NULL);</a>
<a name="ln3525">    if (nmatch) {</a>
<a name="ln3526">      colnr_T copycol;</a>
<a name="ln3527">      colnr_T matchcol;</a>
<a name="ln3528">      colnr_T prev_matchcol = MAXCOL;</a>
<a name="ln3529">      char *new_end, *new_start = NULL;</a>
<a name="ln3530">      int new_start_len = 0;</a>
<a name="ln3531">      char *p1;</a>
<a name="ln3532">      bool did_sub = false;</a>
<a name="ln3533">      int lastone;</a>
<a name="ln3534">      long nmatch_tl = 0;               // nr of lines matched below lnum</a>
<a name="ln3535">      int do_again;                     // do it again after joining lines</a>
<a name="ln3536">      bool skip_match = false;</a>
<a name="ln3537">      linenr_T sub_firstlnum;           // nr of first sub line</a>
<a name="ln3538"> </a>
<a name="ln3539">      // The new text is build up step by step, to avoid too much</a>
<a name="ln3540">      // copying.  There are these pieces:</a>
<a name="ln3541">      // sub_firstline  The old text, unmodified.</a>
<a name="ln3542">      // copycol                Column in the old text where we started</a>
<a name="ln3543">      //                        looking for a match; from here old text still</a>
<a name="ln3544">      //                        needs to be copied to the new text.</a>
<a name="ln3545">      // matchcol               Column number of the old text where to look</a>
<a name="ln3546">      //                        for the next match.  It's just after the</a>
<a name="ln3547">      //                        previous match or one further.</a>
<a name="ln3548">      // prev_matchcol  Column just after the previous match (if any).</a>
<a name="ln3549">      //                        Mostly equal to matchcol, except for the first</a>
<a name="ln3550">      //                        match and after skipping an empty match.</a>
<a name="ln3551">      // regmatch.*pos  Where the pattern matched in the old text.</a>
<a name="ln3552">      // new_start      The new text, all that has been produced so</a>
<a name="ln3553">      //                        far.</a>
<a name="ln3554">      // new_end                The new text, where to append new text.</a>
<a name="ln3555">      //</a>
<a name="ln3556">      // lnum           The line number where we found the start of</a>
<a name="ln3557">      //                        the match.  Can be below the line we searched</a>
<a name="ln3558">      //                        when there is a \n before a \zs in the</a>
<a name="ln3559">      //                        pattern.</a>
<a name="ln3560">      // sub_firstlnum  The line number in the buffer where to look</a>
<a name="ln3561">      //                        for a match.  Can be different from &quot;lnum&quot;</a>
<a name="ln3562">      //                        when the pattern or substitute string contains</a>
<a name="ln3563">      //                        line breaks.</a>
<a name="ln3564">      //</a>
<a name="ln3565">      // Special situations:</a>
<a name="ln3566">      // - When the substitute string contains a line break, the part up</a>
<a name="ln3567">      //   to the line break is inserted in the text, but the copy of</a>
<a name="ln3568">      //   the original line is kept.  &quot;sub_firstlnum&quot; is adjusted for</a>
<a name="ln3569">      //   the inserted lines.</a>
<a name="ln3570">      // - When the matched pattern contains a line break, the old line</a>
<a name="ln3571">      //   is taken from the line at the end of the pattern.  The lines</a>
<a name="ln3572">      //   in the match are deleted later, &quot;sub_firstlnum&quot; is adjusted</a>
<a name="ln3573">      //   accordingly.</a>
<a name="ln3574">      //</a>
<a name="ln3575">      // The new text is built up in new_start[].  It has some extra</a>
<a name="ln3576">      // room to avoid using xmalloc()/free() too often.  new_start_len is</a>
<a name="ln3577">      // the length of the allocated memory at new_start.</a>
<a name="ln3578">      //</a>
<a name="ln3579">      // Make a copy of the old line, so it won't be taken away when</a>
<a name="ln3580">      // updating the screen or handling a multi-line match.  The &quot;old_&quot;</a>
<a name="ln3581">      // pointers point into this copy.</a>
<a name="ln3582">      sub_firstlnum = lnum;</a>
<a name="ln3583">      copycol = 0;</a>
<a name="ln3584">      matchcol = 0;</a>
<a name="ln3585"> </a>
<a name="ln3586">      // At first match, remember current cursor position.</a>
<a name="ln3587">      if (!got_match) {</a>
<a name="ln3588">        setpcmark();</a>
<a name="ln3589">        got_match = true;</a>
<a name="ln3590">      }</a>
<a name="ln3591"> </a>
<a name="ln3592">      // Loop until nothing more to replace in this line.</a>
<a name="ln3593">      // 1. Handle match with empty string.</a>
<a name="ln3594">      // 2. If subflags.do_ask is set, ask for confirmation.</a>
<a name="ln3595">      // 3. substitute the string.</a>
<a name="ln3596">      // 4. if subflags.do_all is set, find next match</a>
<a name="ln3597">      // 5. break if there isn't another match in this line</a>
<a name="ln3598">      while (true) {</a>
<a name="ln3599">        SubResult current_match = {</a>
<a name="ln3600">          .start = { 0, 0 },</a>
<a name="ln3601">          .end   = { 0, 0 },</a>
<a name="ln3602">          .pre_match = 0,</a>
<a name="ln3603">        };</a>
<a name="ln3604">        // lnum is where the match start, but maybe not the pattern match,</a>
<a name="ln3605">        // since we can have \n before \zs in the pattern</a>
<a name="ln3606"> </a>
<a name="ln3607">        // Advance &quot;lnum&quot; to the line where the match starts.  The</a>
<a name="ln3608">        // match does not start in the first line when there is a line</a>
<a name="ln3609">        // break before \zs.</a>
<a name="ln3610">        if (regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln3611">          current_match.pre_match = lnum;</a>
<a name="ln3612">          lnum += regmatch.startpos[0].lnum;</a>
<a name="ln3613">          sub_firstlnum += regmatch.startpos[0].lnum;</a>
<a name="ln3614">          nmatch -= regmatch.startpos[0].lnum;</a>
<a name="ln3615">          XFREE_CLEAR(sub_firstline);</a>
<a name="ln3616">        }</a>
<a name="ln3617"> </a>
<a name="ln3618">        // Now we're at the line where the pattern match starts</a>
<a name="ln3619">        // Note: If not first match on a line, column can't be known here</a>
<a name="ln3620">        current_match.start.lnum = sub_firstlnum;</a>
<a name="ln3621"> </a>
<a name="ln3622">        // Match might be after the last line for &quot;\n\zs&quot; matching at</a>
<a name="ln3623">        // the end of the last line.</a>
<a name="ln3624">        if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3625">          break;</a>
<a name="ln3626">        }</a>
<a name="ln3627">        if (sub_firstline == NULL) {</a>
<a name="ln3628">          sub_firstline = xstrdup(ml_get(sub_firstlnum));</a>
<a name="ln3629">        }</a>
<a name="ln3630"> </a>
<a name="ln3631">        // Save the line number of the last change for the final</a>
<a name="ln3632">        // cursor position (just like Vi).</a>
<a name="ln3633">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3634">        do_again = false;</a>
<a name="ln3635"> </a>
<a name="ln3636">        // 1. Match empty string does not count, except for first</a>
<a name="ln3637">        // match.  This reproduces the strange vi behaviour.</a>
<a name="ln3638">        // This also catches endless loops.</a>
<a name="ln3639">        if (matchcol == prev_matchcol</a>
<a name="ln3640">            &amp;&amp; regmatch.endpos[0].lnum == 0</a>
<a name="ln3641">            &amp;&amp; matchcol == regmatch.endpos[0].col) {</a>
<a name="ln3642">          if (sub_firstline[matchcol] == NUL) {</a>
<a name="ln3643">            // We already were at the end of the line.  Don't look</a>
<a name="ln3644">            // for a match in this line again.</a>
<a name="ln3645">            skip_match = true;</a>
<a name="ln3646">          } else {</a>
<a name="ln3647">            // search for a match at next column</a>
<a name="ln3648">            matchcol += utfc_ptr2len(sub_firstline + matchcol);</a>
<a name="ln3649">          }</a>
<a name="ln3650">          // match will be pushed to preview_lines, bring it into a proper state</a>
<a name="ln3651">          current_match.start.col = matchcol;</a>
<a name="ln3652">          current_match.end.lnum = sub_firstlnum;</a>
<a name="ln3653">          current_match.end.col = matchcol;</a>
<a name="ln3654">          goto skip;</a>
<a name="ln3655">        }</a>
<a name="ln3656"> </a>
<a name="ln3657">        // Normally we continue searching for a match just after the</a>
<a name="ln3658">        // previous match.</a>
<a name="ln3659">        matchcol = regmatch.endpos[0].col;</a>
<a name="ln3660">        prev_matchcol = matchcol;</a>
<a name="ln3661"> </a>
<a name="ln3662">        // 2. If subflags.do_count is set only increase the counter.</a>
<a name="ln3663">        //    If do_ask is set, ask for confirmation.</a>
<a name="ln3664">        if (subflags.do_count) {</a>
<a name="ln3665">          // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3666">          // the end of the line and set nmatch to one, so that</a>
<a name="ln3667">          // we continue looking for a match on the next line.</a>
<a name="ln3668">          // Avoids that &quot;:s/\nB\@=//gc&quot; get stuck.</a>
<a name="ln3669">          if (nmatch &gt; 1) {</a>
<a name="ln3670">            matchcol = (colnr_T)strlen(sub_firstline);</a>
<a name="ln3671">            nmatch = 1;</a>
<a name="ln3672">            skip_match = true;</a>
<a name="ln3673">          }</a>
<a name="ln3674">          sub_nsubs++;</a>
<a name="ln3675">          did_sub = true;</a>
<a name="ln3676">          // Skip the substitution, unless an expression is used,</a>
<a name="ln3677">          // then it is evaluated in the sandbox.</a>
<a name="ln3678">          if (!(sub[0] == '\\' &amp;&amp; sub[1] == '=')) {</a>
<a name="ln3679">            goto skip;</a>
<a name="ln3680">          }</a>
<a name="ln3681">        }</a>
<a name="ln3682"> </a>
<a name="ln3683">        if (subflags.do_ask &amp;&amp; cmdpreview_ns &lt;= 0) {</a>
<a name="ln3684">          int typed = 0;</a>
<a name="ln3685"> </a>
<a name="ln3686">          // change State to MODE_CONFIRM, so that the mouse works</a>
<a name="ln3687">          // properly</a>
<a name="ln3688">          int save_State = State;</a>
<a name="ln3689">          State = MODE_CONFIRM;</a>
<a name="ln3690">          setmouse();                   // disable mouse in xterm</a>
<a name="ln3691">          curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3692"> </a>
<a name="ln3693">          if (curwin-&gt;w_p_crb) {</a>
<a name="ln3694">            do_check_cursorbind();</a>
<a name="ln3695">          }</a>
<a name="ln3696"> </a>
<a name="ln3697">          // When 'cpoptions' contains &quot;u&quot; don't sync undo when</a>
<a name="ln3698">          // asking for confirmation.</a>
<a name="ln3699">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL) {</a>
<a name="ln3700">            no_u_sync++;</a>
<a name="ln3701">          }</a>
<a name="ln3702"> </a>
<a name="ln3703">          // Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.</a>
<a name="ln3704">          while (subflags.do_ask) {</a>
<a name="ln3705">            if (exmode_active) {</a>
<a name="ln3706">              char *prompt;</a>
<a name="ln3707">              char *resp;</a>
<a name="ln3708">              colnr_T sc, ec;</a>
<a name="ln3709"> </a>
<a name="ln3710">              print_line_no_prefix(lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln3711"> </a>
<a name="ln3712">              getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;sc, NULL, NULL);</a>
<a name="ln3713">              curwin-&gt;w_cursor.col = regmatch.endpos[0].col - 1;</a>
<a name="ln3714">              if (curwin-&gt;w_cursor.col &lt; 0) {</a>
<a name="ln3715">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3716">              }</a>
<a name="ln3717">              getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;ec);</a>
<a name="ln3718">              curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3719">              if (subflags.do_number || curwin-&gt;w_p_nu) {</a>
<a name="ln3720">                int numw = number_width(curwin) + 1;</a>
<a name="ln3721">                sc += numw;</a>
<a name="ln3722">                ec += numw;</a>
<a name="ln3723">              }</a>
<a name="ln3724"> </a>
<a name="ln3725">              prompt = xmallocz((size_t)ec + 1);</a>
<a name="ln3726">              memset(prompt, ' ', (size_t)sc);</a>
<a name="ln3727">              memset(prompt + sc, '^', (size_t)(ec - sc) + 1);</a>
<a name="ln3728">              resp = getcmdline_prompt(-1, prompt, 0, EXPAND_NOTHING, NULL, CALLBACK_NONE);</a>
<a name="ln3729">              msg_putchar('\n');</a>
<a name="ln3730">              xfree(prompt);</a>
<a name="ln3731">              if (resp != NULL) {</a>
<a name="ln3732">                typed = (uint8_t)(*resp);</a>
<a name="ln3733">                xfree(resp);</a>
<a name="ln3734">              } else {</a>
<a name="ln3735">                // getcmdline_prompt() returns NULL if there is no command line to return.</a>
<a name="ln3736">                typed = NUL;</a>
<a name="ln3737">              }</a>
<a name="ln3738">              // When &quot;:normal&quot; runs out of characters we get</a>
<a name="ln3739">              // an empty line.  Use &quot;q&quot; to get out of the</a>
<a name="ln3740">              // loop.</a>
<a name="ln3741">              if (ex_normal_busy &amp;&amp; typed == NUL) {</a>
<a name="ln3742">                typed = 'q';</a>
<a name="ln3743">              }</a>
<a name="ln3744">            } else {</a>
<a name="ln3745">              char *orig_line = NULL;</a>
<a name="ln3746">              int len_change = 0;</a>
<a name="ln3747">              const bool save_p_lz = p_lz;</a>
<a name="ln3748">              int save_p_fen = curwin-&gt;w_p_fen;</a>
<a name="ln3749"> </a>
<a name="ln3750">              curwin-&gt;w_p_fen = false;</a>
<a name="ln3751">              // Invert the matched string.</a>
<a name="ln3752">              // Remove the inversion afterwards.</a>
<a name="ln3753">              int temp = RedrawingDisabled;</a>
<a name="ln3754">              RedrawingDisabled = 0;</a>
<a name="ln3755"> </a>
<a name="ln3756">              // avoid calling update_screen() in vgetorpeek()</a>
<a name="ln3757">              p_lz = false;</a>
<a name="ln3758"> </a>
<a name="ln3759">              if (new_start != NULL) {</a>
<a name="ln3760">                // There already was a substitution, we would</a>
<a name="ln3761">                // like to show this to the user.  We cannot</a>
<a name="ln3762">                // really update the line, it would change</a>
<a name="ln3763">                // what matches.  Temporarily replace the line</a>
<a name="ln3764">                // and change it back afterwards.</a>
<a name="ln3765">                orig_line = xstrdup(ml_get(lnum));</a>
<a name="ln3766">                char *new_line = concat_str(new_start, sub_firstline + copycol);</a>
<a name="ln3767"> </a>
<a name="ln3768">                // Position the cursor relative to the end of the line, the</a>
<a name="ln3769">                // previous substitute may have inserted or deleted characters</a>
<a name="ln3770">                // before the cursor.</a>
<a name="ln3771">                len_change = (int)strlen(new_line) - (int)strlen(orig_line);</a>
<a name="ln3772">                curwin-&gt;w_cursor.col += len_change;</a>
<a name="ln3773">                ml_replace(lnum, new_line, false);</a>
<a name="ln3774">              }</a>
<a name="ln3775"> </a>
<a name="ln3776">              search_match_lines = regmatch.endpos[0].lnum</a>
<a name="ln3777">                                   - regmatch.startpos[0].lnum;</a>
<a name="ln3778">              search_match_endcol = regmatch.endpos[0].col</a>
<a name="ln3779">                                    + len_change;</a>
<a name="ln3780">              if (search_match_lines == 0 &amp;&amp; search_match_endcol == 0) {</a>
<a name="ln3781">                // highlight at least one character for /^/</a>
<a name="ln3782">                search_match_endcol = 1;</a>
<a name="ln3783">              }</a>
<a name="ln3784">              highlight_match = true;</a>
<a name="ln3785"> </a>
<a name="ln3786">              update_topline(curwin);</a>
<a name="ln3787">              validate_cursor();</a>
<a name="ln3788">              redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln3789">              show_cursor_info_later(true);</a>
<a name="ln3790">              update_screen();</a>
<a name="ln3791">              highlight_match = false;</a>
<a name="ln3792">              redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln3793"> </a>
<a name="ln3794">              curwin-&gt;w_p_fen = save_p_fen;</a>
<a name="ln3795">              if (msg_row == Rows - 1) {</a>
<a name="ln3796">                msg_didout = false;                     // avoid a scroll-up</a>
<a name="ln3797">              }</a>
<a name="ln3798">              msg_starthere();</a>
<a name="ln3799">              i = msg_scroll;</a>
<a name="ln3800">              msg_scroll = 0;                           // truncate msg when</a>
<a name="ln3801">                                                        // needed</a>
<a name="ln3802">              msg_no_more = true;</a>
<a name="ln3803">              msg_ext_set_kind(&quot;confirm_sub&quot;);</a>
<a name="ln3804">              smsg_attr(HL_ATTR(HLF_R),  // Same highlight as wait_return().</a>
<a name="ln3805">                        _(&quot;replace with %s (y/n/a/q/l/^E/^Y)?&quot;), sub);</a>
<a name="ln3806">              msg_no_more = false;</a>
<a name="ln3807">              msg_scroll = (int)i;</a>
<a name="ln3808">              if (!ui_has(kUIMessages)) {</a>
<a name="ln3809">                ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3810">              }</a>
<a name="ln3811">              RedrawingDisabled = temp;</a>
<a name="ln3812"> </a>
<a name="ln3813">              no_mapping++;                     // don't map this key</a>
<a name="ln3814">              allow_keys++;                     // allow special keys</a>
<a name="ln3815">              typed = plain_vgetc();</a>
<a name="ln3816">              no_mapping--;</a>
<a name="ln3817">              allow_keys--;</a>
<a name="ln3818"> </a>
<a name="ln3819">              // clear the question</a>
<a name="ln3820">              msg_didout = false;               // don't scroll up</a>
<a name="ln3821">              msg_col = 0;</a>
<a name="ln3822">              gotocmdline(true);</a>
<a name="ln3823">              p_lz = save_p_lz;</a>
<a name="ln3824"> </a>
<a name="ln3825">              // restore the line</a>
<a name="ln3826">              if (orig_line != NULL) {</a>
<a name="ln3827">                ml_replace(lnum, orig_line, false);</a>
<a name="ln3828">              }</a>
<a name="ln3829">            }</a>
<a name="ln3830"> </a>
<a name="ln3831">            need_wait_return = false;             // no hit-return prompt</a>
<a name="ln3832">            if (typed == 'q' || typed == ESC || typed == Ctrl_C) {</a>
<a name="ln3833">              got_quit = true;</a>
<a name="ln3834">              break;</a>
<a name="ln3835">            }</a>
<a name="ln3836">            if (typed == 'n') {</a>
<a name="ln3837">              break;</a>
<a name="ln3838">            }</a>
<a name="ln3839">            if (typed == 'y') {</a>
<a name="ln3840">              break;</a>
<a name="ln3841">            }</a>
<a name="ln3842">            if (typed == 'l') {</a>
<a name="ln3843">              // last: replace and then stop</a>
<a name="ln3844">              subflags.do_all = false;</a>
<a name="ln3845">              line2 = lnum;</a>
<a name="ln3846">              break;</a>
<a name="ln3847">            }</a>
<a name="ln3848">            if (typed == 'a') {</a>
<a name="ln3849">              subflags.do_ask = false;</a>
<a name="ln3850">              break;</a>
<a name="ln3851">            }</a>
<a name="ln3852">            if (typed == Ctrl_E) {</a>
<a name="ln3853">              scrollup_clamp();</a>
<a name="ln3854">            } else if (typed == Ctrl_Y) {</a>
<a name="ln3855">              scrolldown_clamp();</a>
<a name="ln3856">            }</a>
<a name="ln3857">          }</a>
<a name="ln3858">          State = save_State;</a>
<a name="ln3859">          setmouse();</a>
<a name="ln3860">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL) {</a>
<a name="ln3861">            no_u_sync--;</a>
<a name="ln3862">          }</a>
<a name="ln3863"> </a>
<a name="ln3864">          if (typed == 'n') {</a>
<a name="ln3865">            // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3866">            // the end of the line and set nmatch to one, so that</a>
<a name="ln3867">            // we continue looking for a match on the next line.</a>
<a name="ln3868">            // Avoids that &quot;:%s/\nB\@=//gc&quot; and &quot;:%s/\n/,\r/gc&quot;</a>
<a name="ln3869">            // get stuck when pressing 'n'.</a>
<a name="ln3870">            if (nmatch &gt; 1) {</a>
<a name="ln3871">              matchcol = (colnr_T)strlen(sub_firstline);</a>
<a name="ln3872">              skip_match = true;</a>
<a name="ln3873">            }</a>
<a name="ln3874">            goto skip;</a>
<a name="ln3875">          }</a>
<a name="ln3876">          if (got_quit) {</a>
<a name="ln3877">            goto skip;</a>
<a name="ln3878">          }</a>
<a name="ln3879">        }</a>
<a name="ln3880"> </a>
<a name="ln3881">        // Move the cursor to the start of the match, so that we can</a>
<a name="ln3882">        // use &quot;\=col(&quot;.&quot;).</a>
<a name="ln3883">        curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3884"> </a>
<a name="ln3885">        // When the match included the &quot;$&quot; of the last line it may</a>
<a name="ln3886">        // go beyond the last line of the buffer.</a>
<a name="ln3887">        if (nmatch &gt; curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1) {</a>
<a name="ln3888">          nmatch = curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1;</a>
<a name="ln3889">          current_match.end.lnum = sub_firstlnum + (linenr_T)nmatch;</a>
<a name="ln3890">          skip_match = true;</a>
<a name="ln3891">          // safety check</a>
<a name="ln3892">          if (nmatch &lt; 0) {</a>
<a name="ln3893">            goto skip;</a>
<a name="ln3894">          }</a>
<a name="ln3895">        }</a>
<a name="ln3896"> </a>
<a name="ln3897">        // Save the line numbers for the preview buffer</a>
<a name="ln3898">        // NOTE: If the pattern matches a final newline, the next line will</a>
<a name="ln3899">        // be shown also, but should not be highlighted. Intentional for now.</a>
<a name="ln3900">        if (cmdpreview_ns &gt; 0 &amp;&amp; !has_second_delim) {</a>
<a name="ln3901">          current_match.start.col = regmatch.startpos[0].col;</a>
<a name="ln3902">          if (current_match.end.lnum == 0) {</a>
<a name="ln3903">            current_match.end.lnum = sub_firstlnum + (linenr_T)nmatch - 1;</a>
<a name="ln3904">          }</a>
<a name="ln3905">          current_match.end.col  = regmatch.endpos[0].col;</a>
<a name="ln3906"> </a>
<a name="ln3907">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3908">          lnum += (linenr_T)nmatch - 1;</a>
<a name="ln3909"> </a>
<a name="ln3910">          goto skip;</a>
<a name="ln3911">        }</a>
<a name="ln3912"> </a>
<a name="ln3913">        // 3. Substitute the string. During 'inccommand' preview only do this if</a>
<a name="ln3914">        //    there is a replace pattern.</a>
<a name="ln3915">        if (cmdpreview_ns &lt;= 0 || has_second_delim) {</a>
<a name="ln3916">          linenr_T lnum_start = lnum;  // save the start lnum</a>
<a name="ln3917">          int save_ma = curbuf-&gt;b_p_ma;</a>
<a name="ln3918">          int save_sandbox = sandbox;</a>
<a name="ln3919">          if (subflags.do_count) {</a>
<a name="ln3920">            // prevent accidentally changing the buffer by a function</a>
<a name="ln3921">            curbuf-&gt;b_p_ma = false;</a>
<a name="ln3922">            sandbox++;</a>
<a name="ln3923">          }</a>
<a name="ln3924">          // Save flags for recursion.  They can change for e.g.</a>
<a name="ln3925">          // :s/^/\=execute(&quot;s#^##gn&quot;)</a>
<a name="ln3926">          subflags_T subflags_save = subflags;</a>
<a name="ln3927"> </a>
<a name="ln3928">          // Disallow changing text or switching window in an expression.</a>
<a name="ln3929">          textlock++;</a>
<a name="ln3930">          // Get length of substitution part, including the NUL.</a>
<a name="ln3931">          // When it fails sublen is zero.</a>
<a name="ln3932">          sublen = vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3933">                                    sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3934">                                    sub, sub_firstline, 0,</a>
<a name="ln3935">                                    REGSUB_BACKSLASH</a>
<a name="ln3936">                                    | (magic_isset() ? REGSUB_MAGIC : 0));</a>
<a name="ln3937">          textlock--;</a>
<a name="ln3938"> </a>
<a name="ln3939">          // If getting the substitute string caused an error, don't do</a>
<a name="ln3940">          // the replacement.</a>
<a name="ln3941">          // Don't keep flags set by a recursive call</a>
<a name="ln3942">          subflags = subflags_save;</a>
<a name="ln3943">          if (sublen == 0 || aborting() || subflags.do_count) {</a>
<a name="ln3944">            curbuf-&gt;b_p_ma = save_ma;</a>
<a name="ln3945">            sandbox = save_sandbox;</a>
<a name="ln3946">            goto skip;</a>
<a name="ln3947">          }</a>
<a name="ln3948"> </a>
<a name="ln3949">          // Need room for:</a>
<a name="ln3950">          // - result so far in new_start (not for first sub in line)</a>
<a name="ln3951">          // - original text up to match</a>
<a name="ln3952">          // - length of substituted part</a>
<a name="ln3953">          // - original text after match</a>
<a name="ln3954">          if (nmatch == 1) {</a>
<a name="ln3955">            p1 = sub_firstline;</a>
<a name="ln3956">          } else {</a>
<a name="ln3957">            p1 = ml_get(sub_firstlnum + (linenr_T)nmatch - 1);</a>
<a name="ln3958">            nmatch_tl += nmatch - 1;</a>
<a name="ln3959">          }</a>
<a name="ln3960">          int copy_len = regmatch.startpos[0].col - copycol;</a>
<a name="ln3961">          new_end = sub_grow_buf(&amp;new_start, &amp;new_start_len,</a>
<a name="ln3962">                                 (colnr_T)strlen(p1) - regmatch.endpos[0].col</a>
<a name="ln3963">                                 + copy_len + sublen + 1);</a>
<a name="ln3964"> </a>
<a name="ln3965">          // copy the text up to the part that matched</a>
<a name="ln3966">          memmove(new_end, sub_firstline + copycol, (size_t)copy_len);</a>
<a name="ln3967">          new_end += copy_len;</a>
<a name="ln3968"> </a>
<a name="ln3969">          if (new_start_len - copy_len &lt; sublen) {</a>
<a name="ln3970">            sublen = new_start_len - copy_len - 1;</a>
<a name="ln3971">          }</a>
<a name="ln3972"> </a>
<a name="ln3973">          // Finally, at this point we can know where the match actually will</a>
<a name="ln3974">          // start in the new text</a>
<a name="ln3975">          int start_col = (int)(new_end - new_start);</a>
<a name="ln3976">          current_match.start.col = start_col;</a>
<a name="ln3977"> </a>
<a name="ln3978">          textlock++;</a>
<a name="ln3979">          (void)vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3980">                                 sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3981">                                 sub, new_end, sublen,</a>
<a name="ln3982">                                 REGSUB_COPY | REGSUB_BACKSLASH</a>
<a name="ln3983">                                 | (magic_isset() ? REGSUB_MAGIC : 0));</a>
<a name="ln3984">          textlock--;</a>
<a name="ln3985">          sub_nsubs++;</a>
<a name="ln3986">          did_sub = true;</a>
<a name="ln3987"> </a>
<a name="ln3988">          // Move the cursor to the start of the line, to avoid that it</a>
<a name="ln3989">          // is beyond the end of the line after the substitution.</a>
<a name="ln3990">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3991"> </a>
<a name="ln3992">          // Remember next character to be copied.</a>
<a name="ln3993">          copycol = regmatch.endpos[0].col;</a>
<a name="ln3994"> </a>
<a name="ln3995">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3996"> </a>
<a name="ln3997">          // TODO(bfredl): this has some robustness issues, look into later.</a>
<a name="ln3998">          bcount_t replaced_bytes = 0;</a>
<a name="ln3999">          lpos_T start = regmatch.startpos[0], end = regmatch.endpos[0];</a>
<a name="ln4000">          for (i = 0; i &lt; nmatch - 1; i++) {</a>
<a name="ln4001">            replaced_bytes += (bcount_t)strlen(ml_get((linenr_T)(lnum_start + i))) + 1;</a>
<a name="ln4002">          }</a>
<a name="ln4003">          replaced_bytes += end.col - start.col;</a>
<a name="ln4004"> </a>
<a name="ln4005">          // Now the trick is to replace CTRL-M chars with a real line</a>
<a name="ln4006">          // break.  This would make it impossible to insert a CTRL-M in</a>
<a name="ln4007">          // the text.  The line break can be avoided by preceding the</a>
<a name="ln4008">          // CTRL-M with a backslash.  To be able to insert a backslash,</a>
<a name="ln4009">          // they must be doubled in the string and are halved here.</a>
<a name="ln4010">          // That is Vi compatible.</a>
<a name="ln4011">          for (p1 = new_end; *p1; p1++) {</a>
<a name="ln4012">            if (p1[0] == '\\' &amp;&amp; p1[1] != NUL) {            // remove backslash</a>
<a name="ln4013">              sublen--;  // correct the byte counts for extmark_splice()</a>
<a name="ln4014">              STRMOVE(p1, p1 + 1);</a>
<a name="ln4015">            } else if (*p1 == CAR) {</a>
<a name="ln4016">              if (u_inssub(lnum) == OK) {             // prepare for undo</a>
<a name="ln4017">                *p1 = NUL;                            // truncate up to the CR</a>
<a name="ln4018">                ml_append(lnum - 1, new_start,</a>
<a name="ln4019">                          (colnr_T)(p1 - new_start + 1), false);</a>
<a name="ln4020">                mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L, kExtmarkNOOP);</a>
<a name="ln4021"> </a>
<a name="ln4022">                if (subflags.do_ask) {</a>
<a name="ln4023">                  appended_lines(lnum - 1, 1L);</a>
<a name="ln4024">                } else {</a>
<a name="ln4025">                  if (first_line == 0) {</a>
<a name="ln4026">                    first_line = lnum;</a>
<a name="ln4027">                  }</a>
<a name="ln4028">                  last_line = lnum + 1;</a>
<a name="ln4029">                }</a>
<a name="ln4030">                // All line numbers increase.</a>
<a name="ln4031">                sub_firstlnum++;</a>
<a name="ln4032">                lnum++;</a>
<a name="ln4033">                line2++;</a>
<a name="ln4034">                // move the cursor to the new line, like Vi</a>
<a name="ln4035">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4036">                // copy the rest</a>
<a name="ln4037">                STRMOVE(new_start, p1 + 1);</a>
<a name="ln4038">                p1 = new_start - 1;</a>
<a name="ln4039">              }</a>
<a name="ln4040">            } else {</a>
<a name="ln4041">              p1 += utfc_ptr2len(p1) - 1;</a>
<a name="ln4042">            }</a>
<a name="ln4043">          }</a>
<a name="ln4044">          colnr_T new_endcol = (colnr_T)strlen(new_start);</a>
<a name="ln4045">          current_match.end.col = new_endcol;</a>
<a name="ln4046">          current_match.end.lnum = lnum;</a>
<a name="ln4047"> </a>
<a name="ln4048">          int matchcols = end.col - ((end.lnum == start.lnum)</a>
<a name="ln4049">                                     ? start.col : 0);</a>
<a name="ln4050">          int subcols = new_endcol - ((lnum == lnum_start) ? start_col : 0);</a>
<a name="ln4051">          if (!did_save) {</a>
<a name="ln4052">            // Required for Undo to work for extmarks.</a>
<a name="ln4053">            u_save_cursor();</a>
<a name="ln4054">            did_save = true;</a>
<a name="ln4055">          }</a>
<a name="ln4056">          extmark_splice(curbuf, (int)lnum_start - 1, start_col,</a>
<a name="ln4057">                         end.lnum - start.lnum, matchcols, replaced_bytes,</a>
<a name="ln4058">                         lnum - lnum_start, subcols, sublen - 1, kExtmarkUndo);</a>
<a name="ln4059">        }</a>
<a name="ln4060"> </a>
<a name="ln4061">        // 4. If subflags.do_all is set, find next match.</a>
<a name="ln4062">        // Prevent endless loop with patterns that match empty</a>
<a name="ln4063">        // strings, e.g. :s/$/pat/g or :s/[a-z]* /(&amp;)/g.</a>
<a name="ln4064">        // But &quot;:s/\n/#/&quot; is OK.</a>
<a name="ln4065">skip:</a>
<a name="ln4066">        // We already know that we did the last subst when we are at</a>
<a name="ln4067">        // the end of the line, except that a pattern like</a>
<a name="ln4068">        // &quot;bar\|\nfoo&quot; may match at the NUL.  &quot;lnum&quot; can be below</a>
<a name="ln4069">        // &quot;line2&quot; when there is a \zs in the pattern after a line</a>
<a name="ln4070">        // break.</a>
<a name="ln4071">        lastone = (skip_match</a>
<a name="ln4072">                   || got_int</a>
<a name="ln4073">                   || got_quit</a>
<a name="ln4074">                   || lnum &gt; line2</a>
<a name="ln4075">                   || !(subflags.do_all || do_again)</a>
<a name="ln4076">                   || (sub_firstline[matchcol] == NUL &amp;&amp; nmatch &lt;= 1</a>
<a name="ln4077">                       &amp;&amp; !re_multiline(regmatch.regprog)));</a>
<a name="ln4078">        nmatch = -1;</a>
<a name="ln4079"> </a>
<a name="ln4080">        // Replace the line in the buffer when needed.  This is</a>
<a name="ln4081">        // skipped when there are more matches.</a>
<a name="ln4082">        // The check for nmatch_tl is needed for when multi-line</a>
<a name="ln4083">        // matching must replace the lines before trying to do another</a>
<a name="ln4084">        // match, otherwise &quot;\@&lt;=&quot; won't work.</a>
<a name="ln4085">        // When the match starts below where we start searching also</a>
<a name="ln4086">        // need to replace the line first (using \zs after \n).</a>
<a name="ln4087">        if (lastone</a>
<a name="ln4088">            || nmatch_tl &gt; 0</a>
<a name="ln4089">            || (nmatch = vim_regexec_multi(&amp;regmatch, curwin,</a>
<a name="ln4090">                                           curbuf, sub_firstlnum,</a>
<a name="ln4091">                                           matchcol, NULL, NULL)) == 0</a>
<a name="ln4092">            || regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln4093">          if (new_start != NULL) {</a>
<a name="ln4094">            // Copy the rest of the line, that didn't match.</a>
<a name="ln4095">            // &quot;matchcol&quot; has to be adjusted, we use the end of</a>
<a name="ln4096">            // the line as reference, because the substitute may</a>
<a name="ln4097">            // have changed the number of characters.  Same for</a>
<a name="ln4098">            // &quot;prev_matchcol&quot;.</a>
<a name="ln4099">            STRCAT(new_start, sub_firstline + copycol);</a>
<a name="ln4100">            matchcol = (colnr_T)strlen(sub_firstline) - matchcol;</a>
<a name="ln4101">            prev_matchcol = (colnr_T)strlen(sub_firstline)</a>
<a name="ln4102">                            - prev_matchcol;</a>
<a name="ln4103"> </a>
<a name="ln4104">            if (u_savesub(lnum) != OK) {</a>
<a name="ln4105">              break;</a>
<a name="ln4106">            }</a>
<a name="ln4107">            ml_replace(lnum, new_start, true);</a>
<a name="ln4108"> </a>
<a name="ln4109">            if (nmatch_tl &gt; 0) {</a>
<a name="ln4110">              // Matched lines have now been substituted and are</a>
<a name="ln4111">              // useless, delete them.  The part after the match</a>
<a name="ln4112">              // has been appended to new_start, we don't need</a>
<a name="ln4113">              // it in the buffer.</a>
<a name="ln4114">              lnum++;</a>
<a name="ln4115">              if (u_savedel(lnum, nmatch_tl) != OK) {</a>
<a name="ln4116">                break;</a>
<a name="ln4117">              }</a>
<a name="ln4118">              for (i = 0; i &lt; nmatch_tl; i++) {</a>
<a name="ln4119">                ml_delete(lnum, false);</a>
<a name="ln4120">              }</a>
<a name="ln4121">              mark_adjust(lnum, lnum + (linenr_T)nmatch_tl - 1,</a>
<a name="ln4122">                          (long)MAXLNUM, (linenr_T)(-nmatch_tl), kExtmarkNOOP);</a>
<a name="ln4123">              if (subflags.do_ask) {</a>
<a name="ln4124">                deleted_lines(lnum, (linenr_T)nmatch_tl);</a>
<a name="ln4125">              }</a>
<a name="ln4126">              lnum--;</a>
<a name="ln4127">              line2 -= (linenr_T)nmatch_tl;  // nr of lines decreases</a>
<a name="ln4128">              nmatch_tl = 0;</a>
<a name="ln4129">            }</a>
<a name="ln4130"> </a>
<a name="ln4131">            // When asking, undo is saved each time, must also set</a>
<a name="ln4132">            // changed flag each time.</a>
<a name="ln4133">            if (subflags.do_ask) {</a>
<a name="ln4134">              changed_bytes(lnum, 0);</a>
<a name="ln4135">            } else {</a>
<a name="ln4136">              if (first_line == 0) {</a>
<a name="ln4137">                first_line = lnum;</a>
<a name="ln4138">              }</a>
<a name="ln4139">              last_line = lnum + 1;</a>
<a name="ln4140">            }</a>
<a name="ln4141"> </a>
<a name="ln4142">            sub_firstlnum = lnum;</a>
<a name="ln4143">            xfree(sub_firstline);                // free the temp buffer</a>
<a name="ln4144">            sub_firstline = new_start;</a>
<a name="ln4145">            new_start = NULL;</a>
<a name="ln4146">            matchcol = (colnr_T)strlen(sub_firstline) - matchcol;</a>
<a name="ln4147">            prev_matchcol = (colnr_T)strlen(sub_firstline)</a>
<a name="ln4148">                            - prev_matchcol;</a>
<a name="ln4149">            copycol = 0;</a>
<a name="ln4150">          }</a>
<a name="ln4151">          if (nmatch == -1 &amp;&amp; !lastone) {</a>
<a name="ln4152">            nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4153">                                       sub_firstlnum, matchcol, NULL, NULL);</a>
<a name="ln4154">          }</a>
<a name="ln4155"> </a>
<a name="ln4156">          // 5. break if there isn't another match in this line</a>
<a name="ln4157">          if (nmatch &lt;= 0) {</a>
<a name="ln4158">            // If the match found didn't start where we were</a>
<a name="ln4159">            // searching, do the next search in the line where we</a>
<a name="ln4160">            // found the match.</a>
<a name="ln4161">            if (nmatch == -1) {</a>
<a name="ln4162">              lnum -= regmatch.startpos[0].lnum;</a>
<a name="ln4163">            }</a>
<a name="ln4164"> </a>
<a name="ln4165">            // uncrustify:off</a>
<a name="ln4166"> </a>
<a name="ln4167">#define PUSH_PREVIEW_LINES() \</a>
<a name="ln4168">  do { \</a>
<a name="ln4169">    if (cmdpreview_ns &gt; 0) { \</a>
<a name="ln4170">      linenr_T match_lines = current_match.end.lnum \</a>
<a name="ln4171">                             - current_match.start.lnum +1; \</a>
<a name="ln4172">      if (preview_lines.subresults.size &gt; 0) { \</a>
<a name="ln4173">        linenr_T last = kv_last(preview_lines.subresults).end.lnum; \</a>
<a name="ln4174">        if (last == current_match.start.lnum) { \</a>
<a name="ln4175">          preview_lines.lines_needed += match_lines - 1; \</a>
<a name="ln4176">        } else { \</a>
<a name="ln4177">          preview_lines.lines_needed += match_lines; \</a>
<a name="ln4178">        } \</a>
<a name="ln4179">      } else { \</a>
<a name="ln4180">        preview_lines.lines_needed += match_lines; \</a>
<a name="ln4181">      } \</a>
<a name="ln4182">      kv_push(preview_lines.subresults, current_match); \</a>
<a name="ln4183">    } \</a>
<a name="ln4184">  } while (0)</a>
<a name="ln4185"> </a>
<a name="ln4186">            // uncrustify:on</a>
<a name="ln4187"> </a>
<a name="ln4188">            // Push the match to preview_lines.</a>
<a name="ln4189">            PUSH_PREVIEW_LINES();</a>
<a name="ln4190"> </a>
<a name="ln4191">            break;</a>
<a name="ln4192">          }</a>
<a name="ln4193">        }</a>
<a name="ln4194">        // Push the match to preview_lines.</a>
<a name="ln4195">        PUSH_PREVIEW_LINES();</a>
<a name="ln4196"> </a>
<a name="ln4197">        line_breakcheck();</a>
<a name="ln4198">      }</a>
<a name="ln4199"> </a>
<a name="ln4200">      if (did_sub) {</a>
<a name="ln4201">        sub_nlines++;</a>
<a name="ln4202">      }</a>
<a name="ln4203">      xfree(new_start);              // for when substitute was cancelled</a>
<a name="ln4204">      XFREE_CLEAR(sub_firstline);    // free the copy of the original line</a>
<a name="ln4205">    }</a>
<a name="ln4206"> </a>
<a name="ln4207">    line_breakcheck();</a>
<a name="ln4208"> </a>
<a name="ln4209">    if (profile_passed_limit(timeout)) {</a>
<a name="ln4210">      got_quit = true;</a>
<a name="ln4211">    }</a>
<a name="ln4212">  }</a>
<a name="ln4213"> </a>
<a name="ln4214">  curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln4215"> </a>
<a name="ln4216">  if (first_line != 0) {</a>
<a name="ln4217">    // Need to subtract the number of added lines from &quot;last_line&quot; to get</a>
<a name="ln4218">    // the line number before the change (same as adding the number of</a>
<a name="ln4219">    // deleted lines).</a>
<a name="ln4220">    i = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4221">    changed_lines(curbuf, first_line, 0, last_line - (linenr_T)i, (linenr_T)i, false);</a>
<a name="ln4222"> </a>
<a name="ln4223">    int64_t num_added = last_line - first_line;</a>
<a name="ln4224">    int64_t num_removed = num_added - i;</a>
<a name="ln4225">    buf_updates_send_changes(curbuf, first_line, num_added, num_removed);</a>
<a name="ln4226">  }</a>
<a name="ln4227"> </a>
<a name="ln4228">  xfree(sub_firstline);   // may have to free allocated copy of the line</a>
<a name="ln4229"> </a>
<a name="ln4230">  // &quot;:s/pat//n&quot; doesn't move the cursor</a>
<a name="ln4231">  if (subflags.do_count) {</a>
<a name="ln4232">    curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln4233">  }</a>
<a name="ln4234"> </a>
<a name="ln4235">  if (sub_nsubs &gt; start_nsubs) {</a>
<a name="ln4236">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4237">      // Set the '[ and '] marks.</a>
<a name="ln4238">      curbuf-&gt;b_op_start.lnum = eap-&gt;line1;</a>
<a name="ln4239">      curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln4240">      curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln4241">    }</a>
<a name="ln4242"> </a>
<a name="ln4243">    if (!global_busy) {</a>
<a name="ln4244">      // when interactive leave cursor on the match</a>
<a name="ln4245">      if (!subflags.do_ask) {</a>
<a name="ln4246">        if (endcolumn) {</a>
<a name="ln4247">          coladvance(MAXCOL);</a>
<a name="ln4248">        } else {</a>
<a name="ln4249">          beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4250">        }</a>
<a name="ln4251">      }</a>
<a name="ln4252">      if (cmdpreview_ns &lt;= 0 &amp;&amp; !do_sub_msg(subflags.do_count) &amp;&amp; subflags.do_ask &amp;&amp; p_ch &gt; 0) {</a>
<a name="ln4253">        msg(&quot;&quot;, 0);</a>
<a name="ln4254">      }</a>
<a name="ln4255">    } else {</a>
<a name="ln4256">      global_need_beginline = true;</a>
<a name="ln4257">    }</a>
<a name="ln4258">    if (subflags.do_print) {</a>
<a name="ln4259">      print_line(curwin-&gt;w_cursor.lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln4260">    }</a>
<a name="ln4261">  } else if (!global_busy) {</a>
<a name="ln4262">    if (got_int) {</a>
<a name="ln4263">      // interrupted</a>
<a name="ln4264">      emsg(_(e_interr));</a>
<a name="ln4265">    } else if (got_match) {</a>
<a name="ln4266">      // did find something but nothing substituted</a>
<a name="ln4267">      if (p_ch &gt; 0) {</a>
<a name="ln4268">        msg(&quot;&quot;, 0);</a>
<a name="ln4269">      }</a>
<a name="ln4270">    } else if (subflags.do_error) {</a>
<a name="ln4271">      // nothing found</a>
<a name="ln4272">      semsg(_(e_patnotf2), get_search_pat());</a>
<a name="ln4273">    }</a>
<a name="ln4274">  }</a>
<a name="ln4275"> </a>
<a name="ln4276">  if (subflags.do_ask &amp;&amp; hasAnyFolding(curwin)) {</a>
<a name="ln4277">    // Cursor position may require updating</a>
<a name="ln4278">    changed_window_setting();</a>
<a name="ln4279">  }</a>
<a name="ln4280"> </a>
<a name="ln4281">  vim_regfree(regmatch.regprog);</a>
<a name="ln4282">  xfree(sub_copy);</a>
<a name="ln4283"> </a>
<a name="ln4284">  // Restore the flag values, they can be used for &quot;:&amp;&amp;&quot;.</a>
<a name="ln4285">  subflags.do_all = save_do_all;</a>
<a name="ln4286">  subflags.do_ask = save_do_ask;</a>
<a name="ln4287"> </a>
<a name="ln4288">  int retv = 0;</a>
<a name="ln4289"> </a>
<a name="ln4290">  // Show 'inccommand' preview if there are matched lines.</a>
<a name="ln4291">  if (cmdpreview_ns &gt; 0 &amp;&amp; !aborting()) {</a>
<a name="ln4292">    if (got_quit || profile_passed_limit(timeout)) {  // Too slow, disable.</a>
<a name="ln4293">      set_string_option_direct(&quot;icm&quot;, -1, &quot;&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4294">    } else if (*p_icm != NUL &amp;&amp; pat != NULL) {</a>
<a name="ln4295">      if (pre_hl_id == 0) {</a>
<a name="ln4296">        pre_hl_id = syn_check_group(S_LEN(&quot;Substitute&quot;));</a>
<a name="ln4297">      }</a>
<a name="ln4298">      retv = show_sub(eap, old_cursor, &amp;preview_lines, pre_hl_id, cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln4299">    }</a>
<a name="ln4300">  }</a>
<a name="ln4301"> </a>
<a name="ln4302">  kv_destroy(preview_lines.subresults);</a>
<a name="ln4303">  return retv;</a>
<a name="ln4304">#undef ADJUST_SUB_FIRSTLNUM</a>
<a name="ln4305">#undef PUSH_PREVIEW_LINES</a>
<a name="ln4306">}</a>
<a name="ln4307"> </a>
<a name="ln4308">/// Give message for number of substitutions.</a>
<a name="ln4309">/// Can also be used after a &quot;:global&quot; command.</a>
<a name="ln4310">///</a>
<a name="ln4311">/// @param count_only  used 'n' flag for &quot;:s&quot;</a>
<a name="ln4312">///</a>
<a name="ln4313">/// @return            true if a message was given.</a>
<a name="ln4314">bool do_sub_msg(bool count_only)</a>
<a name="ln4315">{</a>
<a name="ln4316">  // Only report substitutions when:</a>
<a name="ln4317">  // - more than 'report' substitutions</a>
<a name="ln4318">  // - command was typed by user, or number of changed lines &gt; 'report'</a>
<a name="ln4319">  // - giving messages is not disabled by 'lazyredraw'</a>
<a name="ln4320">  if (((sub_nsubs &gt; p_report &amp;&amp; (KeyTyped || sub_nlines &gt; 1 || p_report &lt; 1))</a>
<a name="ln4321">       || count_only)</a>
<a name="ln4322">      &amp;&amp; messaging()) {</a>
<a name="ln4323">    if (got_int) {</a>
<a name="ln4324">      STRCPY(msg_buf, _(&quot;(Interrupted) &quot;));</a>
<a name="ln4325">    } else {</a>
<a name="ln4326">      *msg_buf = NUL;</a>
<a name="ln4327">    }</a>
<a name="ln4328"> </a>
<a name="ln4329">    char *msg_single = count_only</a>
<a name="ln4330">                     ? NGETTEXT(&quot;%&quot; PRId64 &quot; match on %&quot; PRId64 &quot; line&quot;,</a>
<a name="ln4331">                                &quot;%&quot; PRId64 &quot; matches on %&quot; PRId64 &quot; line&quot;, sub_nsubs)</a>
<a name="ln4332">                     : NGETTEXT(&quot;%&quot; PRId64 &quot; substitution on %&quot; PRId64 &quot; line&quot;,</a>
<a name="ln4333">                                &quot;%&quot; PRId64 &quot; substitutions on %&quot; PRId64 &quot; line&quot;, sub_nsubs);</a>
<a name="ln4334">    char *msg_plural = count_only</a>
<a name="ln4335">                     ? NGETTEXT(&quot;%&quot; PRId64 &quot; match on %&quot; PRId64 &quot; lines&quot;,</a>
<a name="ln4336">                                &quot;%&quot; PRId64 &quot; matches on %&quot; PRId64 &quot; lines&quot;, sub_nsubs)</a>
<a name="ln4337">                     : NGETTEXT(&quot;%&quot; PRId64 &quot; substitution on %&quot; PRId64 &quot; lines&quot;,</a>
<a name="ln4338">                                &quot;%&quot; PRId64 &quot; substitutions on %&quot; PRId64 &quot; lines&quot;, sub_nsubs);</a>
<a name="ln4339">    vim_snprintf_add(msg_buf, sizeof(msg_buf),</a>
<a name="ln4340">                     NGETTEXT(msg_single, msg_plural, sub_nlines),</a>
<a name="ln4341">                     (int64_t)sub_nsubs, (int64_t)sub_nlines);</a>
<a name="ln4342">    if (msg(msg_buf, 0)) {</a>
<a name="ln4343">      // save message to display it after redraw</a>
<a name="ln4344">      set_keep_msg(msg_buf, 0);</a>
<a name="ln4345">    }</a>
<a name="ln4346">    return true;</a>
<a name="ln4347">  }</a>
<a name="ln4348">  if (got_int) {</a>
<a name="ln4349">    emsg(_(e_interr));</a>
<a name="ln4350">    return true;</a>
<a name="ln4351">  }</a>
<a name="ln4352">  return false;</a>
<a name="ln4353">}</a>
<a name="ln4354"> </a>
<a name="ln4355">static void global_exe_one(char *const cmd, const linenr_T lnum)</a>
<a name="ln4356">{</a>
<a name="ln4357">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4358">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4359">  if (*cmd == NUL || *cmd == '\n') {</a>
<a name="ln4360">    do_cmdline(&quot;p&quot;, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4361">  } else {</a>
<a name="ln4362">    do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4363">  }</a>
<a name="ln4364">}</a>
<a name="ln4365"> </a>
<a name="ln4366">/// Execute a global command of the form:</a>
<a name="ln4367">///</a>
<a name="ln4368">/// g/pattern/X : execute X on all lines where pattern matches</a>
<a name="ln4369">/// v/pattern/X : execute X on all lines where pattern does not match</a>
<a name="ln4370">///</a>
<a name="ln4371">/// where 'X' is an EX command</a>
<a name="ln4372">///</a>
<a name="ln4373">/// The command character (as well as the trailing slash) is optional, and</a>
<a name="ln4374">/// is assumed to be 'p' if missing.</a>
<a name="ln4375">///</a>
<a name="ln4376">/// This is implemented in two passes: first we scan the file for the pattern and</a>
<a name="ln4377">/// set a mark for each line that (not) matches. Secondly we execute the command</a>
<a name="ln4378">/// for each line that has a mark. This is required because after deleting</a>
<a name="ln4379">/// lines we do not know where to search for the next match.</a>
<a name="ln4380">void ex_global(exarg_T *eap)</a>
<a name="ln4381">{</a>
<a name="ln4382">  linenr_T lnum;                // line number according to old situation</a>
<a name="ln4383">  int type;                     // first char of cmd: 'v' or 'g'</a>
<a name="ln4384">  char *cmd;             // command argument</a>
<a name="ln4385"> </a>
<a name="ln4386">  char delim;                 // delimiter, normally '/'</a>
<a name="ln4387">  char *pat;</a>
<a name="ln4388">  regmmatch_T regmatch;</a>
<a name="ln4389">  int match;</a>
<a name="ln4390">  int which_pat;</a>
<a name="ln4391"> </a>
<a name="ln4392">  // When nesting the command works on one line.  This allows for</a>
<a name="ln4393">  // &quot;:g/found/v/notfound/command&quot;.</a>
<a name="ln4394">  if (global_busy &amp;&amp; (eap-&gt;line1 != 1</a>
<a name="ln4395">                      || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln4396">    // will increment global_busy to break out of the loop</a>
<a name="ln4397">    emsg(_(&quot;E147: Cannot do :global recursive with a range&quot;));</a>
<a name="ln4398">    return;</a>
<a name="ln4399">  }</a>
<a name="ln4400"> </a>
<a name="ln4401">  if (eap-&gt;forceit) {               // &quot;:global!&quot; is like &quot;:vglobal&quot;</a>
<a name="ln4402">    type = 'v';</a>
<a name="ln4403">  } else {</a>
<a name="ln4404">    type = (uint8_t)(*eap-&gt;cmd);</a>
<a name="ln4405">  }</a>
<a name="ln4406">  cmd = eap-&gt;arg;</a>
<a name="ln4407">  which_pat = RE_LAST;              // default: use last used regexp</a>
<a name="ln4408"> </a>
<a name="ln4409">  // undocumented vi feature:</a>
<a name="ln4410">  //    &quot;\/&quot; and &quot;\?&quot;: use previous search pattern.</a>
<a name="ln4411">  //             &quot;\&amp;&quot;: use previous substitute pattern.</a>
<a name="ln4412">  if (*cmd == '\\') {</a>
<a name="ln4413">    cmd++;</a>
<a name="ln4414">    if (vim_strchr(&quot;/?&amp;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln4415">      emsg(_(e_backslash));</a>
<a name="ln4416">      return;</a>
<a name="ln4417">    }</a>
<a name="ln4418">    if (*cmd == '&amp;') {</a>
<a name="ln4419">      which_pat = RE_SUBST;             // use previous substitute pattern</a>
<a name="ln4420">    } else {</a>
<a name="ln4421">      which_pat = RE_SEARCH;            // use previous search pattern</a>
<a name="ln4422">    }</a>
<a name="ln4423">    cmd++;</a>
<a name="ln4424">    pat = &quot;&quot;;</a>
<a name="ln4425">  } else if (*cmd == NUL) {</a>
<a name="ln4426">    emsg(_(&quot;E148: Regular expression missing from global&quot;));</a>
<a name="ln4427">    return;</a>
<a name="ln4428">  } else if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln4429">    return;</a>
<a name="ln4430">  } else {</a>
<a name="ln4431">    delim = *cmd;               // get the delimiter</a>
<a name="ln4432">    cmd++;                      // skip delimiter if there is one</a>
<a name="ln4433">    pat = cmd;                  // remember start of pattern</a>
<a name="ln4434">    cmd = skip_regexp_ex(cmd, delim, magic_isset(), &amp;eap-&gt;arg, NULL, NULL);</a>
<a name="ln4435">    if (cmd[0] == delim) {                  // end delimiter found</a>
<a name="ln4436">      *cmd++ = NUL;                         // replace it with a NUL</a>
<a name="ln4437">    }</a>
<a name="ln4438">  }</a>
<a name="ln4439"> </a>
<a name="ln4440">  char *used_pat;</a>
<a name="ln4441">  if (search_regcomp(pat, &amp;used_pat, RE_BOTH, which_pat,</a>
<a name="ln4442">                     SEARCH_HIS, &amp;regmatch) == FAIL) {</a>
<a name="ln4443">    emsg(_(e_invcmd));</a>
<a name="ln4444">    return;</a>
<a name="ln4445">  }</a>
<a name="ln4446"> </a>
<a name="ln4447">  if (global_busy) {</a>
<a name="ln4448">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4449">    match = (int)vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum, 0, NULL, NULL);</a>
<a name="ln4450">    if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4451">      global_exe_one(cmd, lnum);</a>
<a name="ln4452">    }</a>
<a name="ln4453">  } else {</a>
<a name="ln4454">    int ndone = 0;</a>
<a name="ln4455">    // pass 1: set marks for each (not) matching line</a>
<a name="ln4456">    for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2 &amp;&amp; !got_int; lnum++) {</a>
<a name="ln4457">      // a match on this line?</a>
<a name="ln4458">      match = (int)vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum, 0, NULL, NULL);</a>
<a name="ln4459">      if (regmatch.regprog == NULL) {</a>
<a name="ln4460">        break;  // re-compiling regprog failed</a>
<a name="ln4461">      }</a>
<a name="ln4462">      if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4463">        ml_setmarked(lnum);</a>
<a name="ln4464">        ndone++;</a>
<a name="ln4465">      }</a>
<a name="ln4466">      line_breakcheck();</a>
<a name="ln4467">    }</a>
<a name="ln4468"> </a>
<a name="ln4469">    // pass 2: execute the command for each line that has been marked</a>
<a name="ln4470">    if (got_int) {</a>
<a name="ln4471">      msg(_(e_interr), 0);</a>
<a name="ln4472">    } else if (ndone == 0) {</a>
<a name="ln4473">      if (type == 'v') {</a>
<a name="ln4474">        smsg(_(&quot;Pattern found in every line: %s&quot;), used_pat);</a>
<a name="ln4475">      } else {</a>
<a name="ln4476">        smsg(_(&quot;Pattern not found: %s&quot;), used_pat);</a>
<a name="ln4477">      }</a>
<a name="ln4478">    } else {</a>
<a name="ln4479">      global_exe(cmd);</a>
<a name="ln4480">    }</a>
<a name="ln4481">    ml_clearmarked();         // clear rest of the marks</a>
<a name="ln4482">  }</a>
<a name="ln4483">  vim_regfree(regmatch.regprog);</a>
<a name="ln4484">}</a>
<a name="ln4485"> </a>
<a name="ln4486">/// Execute `cmd` on lines marked with ml_setmarked().</a>
<a name="ln4487">void global_exe(char *cmd)</a>
<a name="ln4488">{</a>
<a name="ln4489">  linenr_T old_lcount;      // b_ml.ml_line_count before the command</a>
<a name="ln4490">  buf_T *old_buf = curbuf;  // remember what buffer we started in</a>
<a name="ln4491">  linenr_T lnum;            // line number according to old situation</a>
<a name="ln4492"> </a>
<a name="ln4493">  // Set current position only once for a global command.</a>
<a name="ln4494">  // If global_busy is set, setpcmark() will not do anything.</a>
<a name="ln4495">  // If there is an error, global_busy will be incremented.</a>
<a name="ln4496">  setpcmark();</a>
<a name="ln4497"> </a>
<a name="ln4498">  // When the command writes a message, don't overwrite the command.</a>
<a name="ln4499">  msg_didout = true;</a>
<a name="ln4500"> </a>
<a name="ln4501">  sub_nsubs = 0;</a>
<a name="ln4502">  sub_nlines = 0;</a>
<a name="ln4503">  global_need_beginline = false;</a>
<a name="ln4504">  global_busy = 1;</a>
<a name="ln4505">  old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4506"> </a>
<a name="ln4507">  while (!got_int &amp;&amp; (lnum = ml_firstmarked()) != 0 &amp;&amp; global_busy == 1) {</a>
<a name="ln4508">    global_exe_one(cmd, lnum);</a>
<a name="ln4509">    os_breakcheck();</a>
<a name="ln4510">  }</a>
<a name="ln4511"> </a>
<a name="ln4512">  global_busy = 0;</a>
<a name="ln4513">  if (global_need_beginline) {</a>
<a name="ln4514">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4515">  } else {</a>
<a name="ln4516">    check_cursor();  // cursor may be beyond the end of the line</a>
<a name="ln4517">  }</a>
<a name="ln4518"> </a>
<a name="ln4519">  // the cursor may not have moved in the text but a change in a previous</a>
<a name="ln4520">  // line may move it on the screen</a>
<a name="ln4521">  changed_line_abv_curs();</a>
<a name="ln4522"> </a>
<a name="ln4523">  // If it looks like no message was written, allow overwriting the</a>
<a name="ln4524">  // command with the report for number of changes.</a>
<a name="ln4525">  if (msg_col == 0 &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln4526">    msg_didout = false;</a>
<a name="ln4527">  }</a>
<a name="ln4528"> </a>
<a name="ln4529">  // If substitutes done, report number of substitutes, otherwise report</a>
<a name="ln4530">  // number of extra or deleted lines.</a>
<a name="ln4531">  // Don't report extra or deleted lines in the edge case where the buffer</a>
<a name="ln4532">  // we are in after execution is different from the buffer we started in.</a>
<a name="ln4533">  if (!do_sub_msg(false) &amp;&amp; curbuf == old_buf) {</a>
<a name="ln4534">    msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln4535">  }</a>
<a name="ln4536">}</a>
<a name="ln4537"> </a>
<a name="ln4538">#if defined(EXITFREE)</a>
<a name="ln4539">void free_old_sub(void)</a>
<a name="ln4540">{</a>
<a name="ln4541">  sub_set_replacement((SubReplacementString) { NULL, 0, NULL });</a>
<a name="ln4542">}</a>
<a name="ln4543"> </a>
<a name="ln4544">#endif</a>
<a name="ln4545"> </a>
<a name="ln4546">/// Set up for a tagpreview.</a>
<a name="ln4547">///</a>
<a name="ln4548">/// @param undo_sync  sync undo when leaving the window</a>
<a name="ln4549">///</a>
<a name="ln4550">/// @return           true when it was created.</a>
<a name="ln4551">bool prepare_tagpreview(bool undo_sync)</a>
<a name="ln4552">{</a>
<a name="ln4553">  if (curwin-&gt;w_p_pvw) {</a>
<a name="ln4554">    return false;</a>
<a name="ln4555">  }</a>
<a name="ln4556"> </a>
<a name="ln4557">  // If there is already a preview window open, use that one.</a>
<a name="ln4558">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4559">    if (wp-&gt;w_p_pvw) {</a>
<a name="ln4560">      win_enter(wp, undo_sync);</a>
<a name="ln4561">      return false;</a>
<a name="ln4562">    }</a>
<a name="ln4563">  }</a>
<a name="ln4564"> </a>
<a name="ln4565">  // There is no preview window open yet.  Create one.</a>
<a name="ln4566">  if (win_split(g_do_tagpreview &gt; 0 ? g_do_tagpreview : 0, 0)</a>
<a name="ln4567">      == FAIL) {</a>
<a name="ln4568">    return false;</a>
<a name="ln4569">  }</a>
<a name="ln4570">  curwin-&gt;w_p_pvw = true;</a>
<a name="ln4571">  curwin-&gt;w_p_wfh = true;</a>
<a name="ln4572">  RESET_BINDING(curwin);                // don't take over 'scrollbind' and 'cursorbind'</a>
<a name="ln4573">  curwin-&gt;w_p_diff = false;             // no 'diff'</a>
<a name="ln4574">  set_string_option_direct(&quot;fdc&quot;, -1,     // no 'foldcolumn'</a>
<a name="ln4575">                           &quot;0&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4576">  return true;</a>
<a name="ln4577">}</a>
<a name="ln4578"> </a>
<a name="ln4579">/// Shows the effects of the :substitute command being typed ('inccommand').</a>
<a name="ln4580">/// If inccommand=split, shows a preview window and later restores the layout.</a>
<a name="ln4581">///</a>
<a name="ln4582">/// @return 1 if preview window isn't needed, 2 if preview window is needed.</a>
<a name="ln4583">static int show_sub(exarg_T *eap, pos_T old_cusr, PreviewLines *preview_lines, int hl_id,</a>
<a name="ln4584">                    long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln4585">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4586">{</a>
<a name="ln4587">  char *save_shm_p = xstrdup(p_shm);</a>
<a name="ln4588">  PreviewLines lines = *preview_lines;</a>
<a name="ln4589">  buf_T *orig_buf = curbuf;</a>
<a name="ln4590">  // We keep a special-purpose buffer around, but don't assume it exists.</a>
<a name="ln4591">  buf_T *cmdpreview_buf = NULL;</a>
<a name="ln4592"> </a>
<a name="ln4593">  // disable file info message</a>
<a name="ln4594">  set_string_option_direct(&quot;shm&quot;, -1, &quot;F&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4595"> </a>
<a name="ln4596">  // Update the topline to ensure that main window is on the correct line</a>
<a name="ln4597">  update_topline(curwin);</a>
<a name="ln4598"> </a>
<a name="ln4599">  // Place cursor on nearest matching line, to undo do_sub() cursor placement.</a>
<a name="ln4600">  for (size_t i = 0; i &lt; lines.subresults.size; i++) {</a>
<a name="ln4601">    SubResult curres = lines.subresults.items[i];</a>
<a name="ln4602">    if (curres.start.lnum &gt;= old_cusr.lnum) {</a>
<a name="ln4603">      curwin-&gt;w_cursor.lnum = curres.start.lnum;</a>
<a name="ln4604">      curwin-&gt;w_cursor.col = curres.start.col;</a>
<a name="ln4605">      break;</a>
<a name="ln4606">    }  // Else: All matches are above, do_sub() already placed cursor.</a>
<a name="ln4607">  }</a>
<a name="ln4608"> </a>
<a name="ln4609">  // Width of the &quot;| lnum|...&quot; column which displays the line numbers.</a>
<a name="ln4610">  linenr_T highest_num_line = 0;</a>
<a name="ln4611">  int col_width = 0;</a>
<a name="ln4612">  // Use preview window only when inccommand=split and range is not just the current line</a>
<a name="ln4613">  bool preview = (*p_icm == 's') &amp;&amp; (eap-&gt;line1 != old_cusr.lnum || eap-&gt;line2 != old_cusr.lnum);</a>
<a name="ln4614"> </a>
<a name="ln4615">  if (preview) {</a>
<a name="ln4616">    cmdpreview_buf = buflist_findnr(cmdpreview_bufnr);</a>
<a name="ln4617">    assert(cmdpreview_buf != NULL);</a>
<a name="ln4618"> </a>
<a name="ln4619">    if (lines.subresults.size &gt; 0) {</a>
<a name="ln4620">      highest_num_line = kv_last(lines.subresults).end.lnum;</a>
<a name="ln4621">      col_width = (int)log10(highest_num_line) + 1 + 3;</a>
<a name="ln4622">    }</a>
<a name="ln4623">  }</a>
<a name="ln4624"> </a>
<a name="ln4625">  char *str = NULL;  // construct the line to show in here</a>
<a name="ln4626">  size_t old_line_size = 0;</a>
<a name="ln4627">  size_t line_size = 0;</a>
<a name="ln4628">  linenr_T linenr_preview = 0;  // last line added to preview buffer</a>
<a name="ln4629">  linenr_T linenr_origbuf = 0;  // last line added to original buffer</a>
<a name="ln4630">  linenr_T next_linenr = 0;     // next line to show for the match</a>
<a name="ln4631"> </a>
<a name="ln4632">  for (size_t matchidx = 0; matchidx &lt; lines.subresults.size; matchidx++) {</a>
<a name="ln4633">    SubResult match = lines.subresults.items[matchidx];</a>
<a name="ln4634"> </a>
<a name="ln4635">    if (cmdpreview_buf) {</a>
<a name="ln4636">      lpos_T p_start = { 0, match.start.col };  // match starts here in preview</a>
<a name="ln4637">      lpos_T p_end   = { 0, match.end.col };    // ... and ends here</a>
<a name="ln4638"> </a>
<a name="ln4639">      // You Might Gonna Need It</a>
<a name="ln4640">      buf_ensure_loaded(cmdpreview_buf);</a>
<a name="ln4641"> </a>
<a name="ln4642">      if (match.pre_match == 0) {</a>
<a name="ln4643">        next_linenr = match.start.lnum;</a>
<a name="ln4644">      } else {</a>
<a name="ln4645">        next_linenr = match.pre_match;</a>
<a name="ln4646">      }</a>
<a name="ln4647">      // Don't add a line twice</a>
<a name="ln4648">      if (next_linenr == linenr_origbuf) {</a>
<a name="ln4649">        next_linenr++;</a>
<a name="ln4650">        p_start.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln4651">        p_end.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln4652">      }</a>
<a name="ln4653"> </a>
<a name="ln4654">      for (; next_linenr &lt;= match.end.lnum; next_linenr++) {</a>
<a name="ln4655">        if (next_linenr == match.start.lnum) {</a>
<a name="ln4656">          p_start.lnum = linenr_preview + 1;</a>
<a name="ln4657">        }</a>
<a name="ln4658">        if (next_linenr == match.end.lnum) {</a>
<a name="ln4659">          p_end.lnum = linenr_preview + 1;</a>
<a name="ln4660">        }</a>
<a name="ln4661">        char *line;</a>
<a name="ln4662">        if (next_linenr == orig_buf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln4663">          line = &quot;&quot;;</a>
<a name="ln4664">        } else {</a>
<a name="ln4665">          line = ml_get_buf(orig_buf, next_linenr);</a>
<a name="ln4666">          line_size = strlen(line) + (size_t)col_width + 1;</a>
<a name="ln4667"> </a>
<a name="ln4668">          // Reallocate if line not long enough</a>
<a name="ln4669">          if (line_size &gt; old_line_size) {</a>
<a name="ln4670">            str = xrealloc(str, line_size * sizeof(char));</a>
<a name="ln4671">            old_line_size = line_size;</a>
<a name="ln4672">          }</a>
<a name="ln4673">        }</a>
<a name="ln4674">        // Put &quot;|lnum| line&quot; into `str` and append it to the preview buffer.</a>
<a name="ln4675">        snprintf(str, line_size, &quot;|%*&quot; PRIdLINENR &quot;| %s&quot;, col_width - 3,</a>
<a name="ln4676">                 next_linenr, line);</a>
<a name="ln4677">        if (linenr_preview == 0) {</a>
<a name="ln4678">          ml_replace_buf(cmdpreview_buf, 1, str, true);</a>
<a name="ln4679">        } else {</a>
<a name="ln4680">          ml_append_buf(cmdpreview_buf, linenr_preview, str, (colnr_T)line_size, false);</a>
<a name="ln4681">        }</a>
<a name="ln4682">        linenr_preview += 1;</a>
<a name="ln4683">      }</a>
<a name="ln4684">      linenr_origbuf = match.end.lnum;</a>
<a name="ln4685"> </a>
<a name="ln4686">      bufhl_add_hl_pos_offset(cmdpreview_buf, (int)cmdpreview_ns, hl_id, p_start, p_end, col_width);</a>
<a name="ln4687">    }</a>
<a name="ln4688">    bufhl_add_hl_pos_offset(orig_buf, (int)cmdpreview_ns, hl_id, match.start, match.end, 0);</a>
<a name="ln4689">  }</a>
<a name="ln4690"> </a>
<a name="ln4691">  xfree(str);</a>
<a name="ln4692"> </a>
<a name="ln4693">  set_string_option_direct(&quot;shm&quot;, -1, save_shm_p, OPT_FREE, SID_NONE);</a>
<a name="ln4694">  xfree(save_shm_p);</a>
<a name="ln4695"> </a>
<a name="ln4696">  return preview ? 2 : 1;</a>
<a name="ln4697">}</a>
<a name="ln4698"> </a>
<a name="ln4699">/// :substitute command.</a>
<a name="ln4700">void ex_substitute(exarg_T *eap)</a>
<a name="ln4701">{</a>
<a name="ln4702">  (void)do_sub(eap, profile_zero(), 0, 0);</a>
<a name="ln4703">}</a>
<a name="ln4704"> </a>
<a name="ln4705">/// :substitute command preview callback.</a>
<a name="ln4706">int ex_substitute_preview(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln4707">{</a>
<a name="ln4708">  // Only preview once the pattern delimiter has been typed</a>
<a name="ln4709">  if (*eap-&gt;arg &amp;&amp; !ASCII_ISALNUM(*eap-&gt;arg)) {</a>
<a name="ln4710">    char *save_eap = eap-&gt;arg;</a>
<a name="ln4711">    int retv = do_sub(eap, profile_setlimit(p_rdt), cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln4712">    eap-&gt;arg = save_eap;</a>
<a name="ln4713">    return retv;</a>
<a name="ln4714">  }</a>
<a name="ln4715"> </a>
<a name="ln4716">  return 0;</a>
<a name="ln4717">}</a>
<a name="ln4718"> </a>
<a name="ln4719">/// Skip over the pattern argument of &quot;:vimgrep /pat/[g][j]&quot;.</a>
<a name="ln4720">/// Put the start of the pattern in &quot;*s&quot;, unless &quot;s&quot; is NULL.</a>
<a name="ln4721">///</a>
<a name="ln4722">/// @param flags  if not NULL, put the flags in it: VGR_GLOBAL, VGR_NOJUMP.</a>
<a name="ln4723">/// @param s      if not NULL, terminate the pattern with a NUL.</a>
<a name="ln4724">///</a>
<a name="ln4725">/// @return  a pointer to the char just past the pattern plus flags.</a>
<a name="ln4726">char *skip_vimgrep_pat(char *p, char **s, int *flags)</a>
<a name="ln4727">{</a>
<a name="ln4728">  if (vim_isIDc((uint8_t)(*p))) {</a>
<a name="ln4729">    // &quot;:vimgrep pattern fname&quot;</a>
<a name="ln4730">    if (s != NULL) {</a>
<a name="ln4731">      *s = p;</a>
<a name="ln4732">    }</a>
<a name="ln4733">    p = skiptowhite(p);</a>
<a name="ln4734">    if (s != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln4735">      *p++ = NUL;</a>
<a name="ln4736">    }</a>
<a name="ln4737">  } else {</a>
<a name="ln4738">    // &quot;:vimgrep /pattern/[g][j] fname&quot;</a>
<a name="ln4739">    if (s != NULL) {</a>
<a name="ln4740">      *s = p + 1;</a>
<a name="ln4741">    }</a>
<a name="ln4742">    int c = (uint8_t)(*p);</a>
<a name="ln4743">    p = skip_regexp(p + 1, c, true);</a>
<a name="ln4744">    if (*p != c) {</a>
<a name="ln4745">      return NULL;</a>
<a name="ln4746">    }</a>
<a name="ln4747"> </a>
<a name="ln4748">    // Truncate the pattern.</a>
<a name="ln4749">    if (s != NULL) {</a>
<a name="ln4750">      *p = NUL;</a>
<a name="ln4751">    }</a>
<a name="ln4752">    p++;</a>
<a name="ln4753"> </a>
<a name="ln4754">    // Find the flags</a>
<a name="ln4755">    while (*p == 'g' || *p == 'j' || *p == 'f') {</a>
<a name="ln4756">      if (flags != NULL) {</a>
<a name="ln4757">        if (*p == 'g') {</a>
<a name="ln4758">          *flags |= VGR_GLOBAL;</a>
<a name="ln4759">        } else if (*p == 'j') {</a>
<a name="ln4760">          *flags |= VGR_NOJUMP;</a>
<a name="ln4761">        } else {</a>
<a name="ln4762">          *flags |= VGR_FUZZY;</a>
<a name="ln4763">        }</a>
<a name="ln4764">      }</a>
<a name="ln4765">      p++;</a>
<a name="ln4766">    }</a>
<a name="ln4767">  }</a>
<a name="ln4768">  return p;</a>
<a name="ln4769">}</a>
<a name="ln4770"> </a>
<a name="ln4771">/// List v:oldfiles in a nice way.</a>
<a name="ln4772">void ex_oldfiles(exarg_T *eap)</a>
<a name="ln4773">{</a>
<a name="ln4774">  list_T *l = get_vim_var_list(VV_OLDFILES);</a>
<a name="ln4775">  long nr = 0;</a>
<a name="ln4776"> </a>
<a name="ln4777">  if (l == NULL) {</a>
<a name="ln4778">    msg(_(&quot;No old files&quot;), 0);</a>
<a name="ln4779">    return;</a>
<a name="ln4780">  }</a>
<a name="ln4781"> </a>
<a name="ln4782">  msg_start();</a>
<a name="ln4783">  msg_scroll = true;</a>
<a name="ln4784">  TV_LIST_ITER(l, li, {</a>
<a name="ln4785">    if (got_int) {</a>
<a name="ln4786">      break;</a>
<a name="ln4787">    }</a>
<a name="ln4788">    nr++;</a>
<a name="ln4789">    const char *fname = tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln4790">    if (!message_filtered(fname)) {</a>
<a name="ln4791">      msg_outnum(nr);</a>
<a name="ln4792">      msg_puts(&quot;: &quot;);</a>
<a name="ln4793">      msg_outtrans(tv_get_string(TV_LIST_ITEM_TV(li)), 0);</a>
<a name="ln4794">      msg_clr_eos();</a>
<a name="ln4795">      msg_putchar('\n');</a>
<a name="ln4796">      os_breakcheck();</a>
<a name="ln4797">    }</a>
<a name="ln4798">  });</a>
<a name="ln4799"> </a>
<a name="ln4800">  // Assume &quot;got_int&quot; was set to truncate the listing.</a>
<a name="ln4801">  got_int = false;</a>
<a name="ln4802"> </a>
<a name="ln4803">  // File selection prompt on &quot;:browse oldfiles&quot;</a>
<a name="ln4804">  if (cmdmod.cmod_flags &amp; CMOD_BROWSE) {</a>
<a name="ln4805">    quit_more = false;</a>
<a name="ln4806">    nr = prompt_for_number(false);</a>
<a name="ln4807">    msg_starthere();</a>
<a name="ln4808">    if (nr &gt; 0 &amp;&amp; nr &lt;= tv_list_len(l)) {</a>
<a name="ln4809">      const char *const p = tv_list_find_str(l, (int)nr - 1);</a>
<a name="ln4810">      if (p == NULL) {</a>
<a name="ln4811">        return;</a>
<a name="ln4812">      }</a>
<a name="ln4813">      char *const s = expand_env_save((char *)p);</a>
<a name="ln4814">      eap-&gt;arg = s;</a>
<a name="ln4815">      eap-&gt;cmdidx = CMD_edit;</a>
<a name="ln4816">      cmdmod.cmod_flags &amp;= ~CMOD_BROWSE;</a>
<a name="ln4817">      do_exedit(eap, NULL);</a>
<a name="ln4818">      xfree(s);</a>
<a name="ln4819">    }</a>
<a name="ln4820">  }</a>
<a name="ln4821">}</a>
</code></pre>
<div class="balloon" rel="138"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v666/" target="_blank">V666</a> Consider inspecting second argument of the function 'msg'. It is possible that the value does not correspond with the length of a string which was passed with the first argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>