<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_cmds.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_cmds.c: some functions for command line commands</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;float.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;math.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;stddef.h&gt;</a>
<a name="ln13">#include &lt;stdio.h&gt;</a>
<a name="ln14">#include &lt;stdlib.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;time.h&gt;</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;auto/config.h&quot;</a>
<a name="ln19">#include &quot;klib/kvec.h&quot;</a>
<a name="ln20">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln21">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln22">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln24">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln25">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln26">#include &quot;nvim/bufwrite.h&quot;</a>
<a name="ln27">#include &quot;nvim/change.h&quot;</a>
<a name="ln28">#include &quot;nvim/channel.h&quot;</a>
<a name="ln29">#include &quot;nvim/charset.h&quot;</a>
<a name="ln30">#include &quot;nvim/cmdexpand_defs.h&quot;</a>
<a name="ln31">#include &quot;nvim/cmdhist.h&quot;</a>
<a name="ln32">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln33">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln34">#include &quot;nvim/diff.h&quot;</a>
<a name="ln35">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln36">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln37">#include &quot;nvim/edit.h&quot;</a>
<a name="ln38">#include &quot;nvim/eval.h&quot;</a>
<a name="ln39">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln40">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln41">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln42">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln43">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln44">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln45">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln46">#include &quot;nvim/extmark.h&quot;</a>
<a name="ln47">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln48">#include &quot;nvim/fold.h&quot;</a>
<a name="ln49">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln50">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln51">#include &quot;nvim/globals.h&quot;</a>
<a name="ln52">#include &quot;nvim/grid_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/help.h&quot;</a>
<a name="ln54">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln55">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln56">#include &quot;nvim/indent.h&quot;</a>
<a name="ln57">#include &quot;nvim/input.h&quot;</a>
<a name="ln58">#include &quot;nvim/macros.h&quot;</a>
<a name="ln59">#include &quot;nvim/main.h&quot;</a>
<a name="ln60">#include &quot;nvim/mark.h&quot;</a>
<a name="ln61">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln62">#include &quot;nvim/memline.h&quot;</a>
<a name="ln63">#include &quot;nvim/memory.h&quot;</a>
<a name="ln64">#include &quot;nvim/message.h&quot;</a>
<a name="ln65">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln66">#include &quot;nvim/move.h&quot;</a>
<a name="ln67">#include &quot;nvim/normal.h&quot;</a>
<a name="ln68">#include &quot;nvim/ops.h&quot;</a>
<a name="ln69">#include &quot;nvim/option.h&quot;</a>
<a name="ln70">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln71">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln72">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln73">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln74">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln75">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln76">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln77">#include &quot;nvim/path.h&quot;</a>
<a name="ln78">#include &quot;nvim/plines.h&quot;</a>
<a name="ln79">#include &quot;nvim/profile.h&quot;</a>
<a name="ln80">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln81">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln82">#include &quot;nvim/search.h&quot;</a>
<a name="ln83">#include &quot;nvim/spell.h&quot;</a>
<a name="ln84">#include &quot;nvim/strings.h&quot;</a>
<a name="ln85">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln86">#include &quot;nvim/types.h&quot;</a>
<a name="ln87">#include &quot;nvim/ui.h&quot;</a>
<a name="ln88">#include &quot;nvim/undo.h&quot;</a>
<a name="ln89">#include &quot;nvim/vim.h&quot;</a>
<a name="ln90">#include &quot;nvim/window.h&quot;</a>
<a name="ln91"> </a>
<a name="ln92">/// Case matching style to use for :substitute</a>
<a name="ln93">typedef enum {</a>
<a name="ln94">  kSubHonorOptions = 0,  ///&lt; Honor the user's 'ignorecase'/'smartcase' options</a>
<a name="ln95">  kSubIgnoreCase,        ///&lt; Ignore case of the search</a>
<a name="ln96">  kSubMatchCase,         ///&lt; Match case of the search</a>
<a name="ln97">} SubIgnoreType;</a>
<a name="ln98"> </a>
<a name="ln99">/// Flags kept between calls to :substitute.</a>
<a name="ln100">typedef struct {</a>
<a name="ln101">  bool do_all;          ///&lt; do multiple substitutions per line</a>
<a name="ln102">  bool do_ask;          ///&lt; ask for confirmation</a>
<a name="ln103">  bool do_count;        ///&lt; count only</a>
<a name="ln104">  bool do_error;        ///&lt; if false, ignore errors</a>
<a name="ln105">  bool do_print;        ///&lt; print last line with subs</a>
<a name="ln106">  bool do_list;         ///&lt; list last line with subs</a>
<a name="ln107">  bool do_number;       ///&lt; list last line with line nr</a>
<a name="ln108">  SubIgnoreType do_ic;  ///&lt; ignore case flag</a>
<a name="ln109">} subflags_T;</a>
<a name="ln110"> </a>
<a name="ln111">/// Partial result of a substitution during :substitute.</a>
<a name="ln112">/// Numbers refer to the buffer _after_ substitution</a>
<a name="ln113">typedef struct {</a>
<a name="ln114">  lpos_T start;  // start of the match</a>
<a name="ln115">  lpos_T end;    // end of the match</a>
<a name="ln116">  linenr_T pre_match;  // where to begin showing lines before the match</a>
<a name="ln117">} SubResult;</a>
<a name="ln118"> </a>
<a name="ln119">// Collected results of a substitution for showing them in</a>
<a name="ln120">// the preview window</a>
<a name="ln121">typedef struct {</a>
<a name="ln122">  kvec_t(SubResult) subresults;</a>
<a name="ln123">  linenr_T lines_needed;  // lines needed in the preview window</a>
<a name="ln124">} PreviewLines;</a>
<a name="ln125"> </a>
<a name="ln126">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln127"># include &quot;ex_cmds.c.generated.h&quot;</a>
<a name="ln128">#endif</a>
<a name="ln129"> </a>
<a name="ln130">static const char e_non_numeric_argument_to_z[]</a>
<a name="ln131">  = N_(&quot;E144: Non-numeric argument to :z&quot;);</a>
<a name="ln132"> </a>
<a name="ln133">/// &quot;:ascii&quot; and &quot;ga&quot; implementation</a>
<a name="ln134">void do_ascii(exarg_T *eap)</a>
<a name="ln135">{</a>
<a name="ln136">  char *dig;</a>
<a name="ln137">  int cc[MAX_MCO];</a>
<a name="ln138">  int c = utfc_ptr2char(get_cursor_pos_ptr(), cc);</a>
<a name="ln139">  if (c == NUL) {</a>
<a name="ln140">    msg(&quot;NUL&quot;, 0);</a>
<a name="ln141">    return;</a>
<a name="ln142">  }</a>
<a name="ln143"> </a>
<a name="ln144">  size_t iobuff_len = 0;</a>
<a name="ln145"> </a>
<a name="ln146">  int ci = 0;</a>
<a name="ln147">  if (c &lt; 0x80) {</a>
<a name="ln148">    if (c == NL) {  // NUL is stored as NL.</a>
<a name="ln149">      c = NUL;</a>
<a name="ln150">    }</a>
<a name="ln151">    const int cval = (c == CAR &amp;&amp; get_fileformat(curbuf) == EOL_MAC</a>
<a name="ln152">                      ? NL  // NL is stored as CR.</a>
<a name="ln153">                      : c);</a>
<a name="ln154">    char buf1[20];</a>
<a name="ln155">    if (vim_isprintc_strict(c) &amp;&amp; (c &lt; ' ' || c &gt; '~')) {</a>
<a name="ln156">      char buf3[7];</a>
<a name="ln157">      transchar_nonprint(curbuf, buf3, c);</a>
<a name="ln158">      vim_snprintf(buf1, sizeof(buf1), &quot;  &lt;%s&gt;&quot;, buf3);</a>
<a name="ln159">    } else {</a>
<a name="ln160">      buf1[0] = NUL;</a>
<a name="ln161">    }</a>
<a name="ln162">    char buf2[20];</a>
<a name="ln163">    buf2[0] = NUL;</a>
<a name="ln164"> </a>
<a name="ln165">    dig = get_digraph_for_char(cval);</a>
<a name="ln166">    if (dig != NULL) {</a>
<a name="ln167">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln168">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln169">                                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Oct %03o, Digr %s&quot;),</a>
<a name="ln170">                                         transchar(c), buf1, buf2, cval, cval, cval, dig);</a>
<a name="ln171">    } else {</a>
<a name="ln172">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln173">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln174">                                         _(&quot;&lt;%s&gt;%s%s  %d,  Hex %02x,  Octal %03o&quot;),</a>
<a name="ln175">                                         transchar(c), buf1, buf2, cval, cval, cval);</a>
<a name="ln176">    }</a>
<a name="ln177"> </a>
<a name="ln178">    c = cc[ci++];</a>
<a name="ln179">  }</a>
<a name="ln180"> </a>
<a name="ln181">#define SPACE_FOR_DESC (1 + 1 + 1 + MB_MAXBYTES + 16 + 4 + 3 + 3 + 1)</a>
<a name="ln182">  // Space for description:</a>
<a name="ln183">  // - 1 byte for separator (starting from second entry)</a>
<a name="ln184">  // - 1 byte for &quot;&lt;&quot;</a>
<a name="ln185">  // - 1 byte for space to draw composing character on (optional, but really</a>
<a name="ln186">  //   mostly required)</a>
<a name="ln187">  // - up to MB_MAXBYTES bytes for character itself</a>
<a name="ln188">  // - 16 bytes for raw text (&quot;&gt; , Hex , Octal &quot;).</a>
<a name="ln189">  // - at least 4 bytes for hexadecimal representation</a>
<a name="ln190">  // - at least 3 bytes for decimal representation</a>
<a name="ln191">  // - at least 3 bytes for octal representation</a>
<a name="ln192">  // - 1 byte for NUL</a>
<a name="ln193">  //</a>
<a name="ln194">  // Taking into account MAX_MCO and characters which need 8 bytes for</a>
<a name="ln195">  // hexadecimal representation, but not taking translation into account:</a>
<a name="ln196">  // resulting string will occupy less then 400 bytes (conservative estimate).</a>
<a name="ln197">  //</a>
<a name="ln198">  // Less then 1000 bytes if translation multiplies number of bytes needed for</a>
<a name="ln199">  // raw text by 6, so it should always fit into 1025 bytes reserved for IObuff.</a>
<a name="ln200"> </a>
<a name="ln201">  // Repeat for combining characters, also handle multiby here.</a>
<a name="ln202">  while (c &gt;= 0x80 &amp;&amp; iobuff_len &lt; sizeof(IObuff) - SPACE_FOR_DESC) {</a>
<a name="ln203">    // This assumes every multi-byte char is printable...</a>
<a name="ln204">    if (iobuff_len &gt; 0) {</a>
<a name="ln205">      IObuff[iobuff_len++] = ' ';</a>
<a name="ln206">    }</a>
<a name="ln207">    IObuff[iobuff_len++] = '&lt;';</a>
<a name="ln208">    if (utf_iscomposing(c)) {</a>
<a name="ln209">      IObuff[iobuff_len++] = ' ';  // Draw composing char on top of a space.</a>
<a name="ln210">    }</a>
<a name="ln211">    iobuff_len += (size_t)utf_char2bytes(c, IObuff + iobuff_len);</a>
<a name="ln212"> </a>
<a name="ln213">    dig = get_digraph_for_char(c);</a>
<a name="ln214">    if (dig != NULL) {</a>
<a name="ln215">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln216">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln217">                                         (c &lt; 0x10000</a>
<a name="ln218">                                          ? _(&quot;&gt; %d, Hex %04x, Oct %o, Digr %s&quot;)</a>
<a name="ln219">                                          : _(&quot;&gt; %d, Hex %08x, Oct %o, Digr %s&quot;)),</a>
<a name="ln220">                                         c, c, c, dig);</a>
<a name="ln221">    } else {</a>
<a name="ln222">      iobuff_len += (size_t)vim_snprintf(IObuff + iobuff_len,</a>
<a name="ln223">                                         sizeof(IObuff) - iobuff_len,</a>
<a name="ln224">                                         (c &lt; 0x10000</a>
<a name="ln225">                                          ? _(&quot;&gt; %d, Hex %04x, Octal %o&quot;)</a>
<a name="ln226">                                          : _(&quot;&gt; %d, Hex %08x, Octal %o&quot;)),</a>
<a name="ln227">                                         c, c, c);</a>
<a name="ln228">    }</a>
<a name="ln229">    if (ci == MAX_MCO) {</a>
<a name="ln230">      break;</a>
<a name="ln231">    }</a>
<a name="ln232">    c = cc[ci++];</a>
<a name="ln233">  }</a>
<a name="ln234">  if (ci != MAX_MCO &amp;&amp; c != 0) {</a>
<a name="ln235">    xstrlcpy(IObuff + iobuff_len, &quot; ...&quot;, sizeof(IObuff) - iobuff_len);</a>
<a name="ln236">  }</a>
<a name="ln237"> </a>
<a name="ln238">  msg(IObuff, 0);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/// &quot;:left&quot;, &quot;:center&quot; and &quot;:right&quot;: align text.</a>
<a name="ln242">void ex_align(exarg_T *eap)</a>
<a name="ln243">{</a>
<a name="ln244">  pos_T save_curpos;</a>
<a name="ln245">  int len;</a>
<a name="ln246">  int indent = 0;</a>
<a name="ln247">  int new_indent;</a>
<a name="ln248">  int has_tab;</a>
<a name="ln249">  int width;</a>
<a name="ln250"> </a>
<a name="ln251">  if (curwin-&gt;w_p_rl) {</a>
<a name="ln252">    // switch left and right aligning</a>
<a name="ln253">    if (eap-&gt;cmdidx == CMD_right) {</a>
<a name="ln254">      eap-&gt;cmdidx = CMD_left;</a>
<a name="ln255">    } else if (eap-&gt;cmdidx == CMD_left) {</a>
<a name="ln256">      eap-&gt;cmdidx = CMD_right;</a>
<a name="ln257">    }</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  width = atoi(eap-&gt;arg);</a>
<a name="ln261">  save_curpos = curwin-&gt;w_cursor;</a>
<a name="ln262">  if (eap-&gt;cmdidx == CMD_left) {    // width is used for new indent</a>
<a name="ln263">    if (width &gt;= 0) {</a>
<a name="ln264">      indent = width;</a>
<a name="ln265">    }</a>
<a name="ln266">  } else {</a>
<a name="ln267">    // if 'textwidth' set, use it</a>
<a name="ln268">    // else if 'wrapmargin' set, use it</a>
<a name="ln269">    // if invalid value, use 80</a>
<a name="ln270">    if (width &lt;= 0) {</a>
<a name="ln271">      width = (int)curbuf-&gt;b_p_tw;</a>
<a name="ln272">    }</a>
<a name="ln273">    if (width == 0 &amp;&amp; curbuf-&gt;b_p_wm &gt; 0) {</a>
<a name="ln274">      width = curwin-&gt;w_width_inner - (int)curbuf-&gt;b_p_wm;</a>
<a name="ln275">    }</a>
<a name="ln276">    if (width &lt;= 0) {</a>
<a name="ln277">      width = 80;</a>
<a name="ln278">    }</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln282">    return;</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  for (curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln286">       curwin-&gt;w_cursor.lnum &lt;= eap-&gt;line2; curwin-&gt;w_cursor.lnum++) {</a>
<a name="ln287">    if (eap-&gt;cmdidx == CMD_left) {              // left align</a>
<a name="ln288">      new_indent = indent;</a>
<a name="ln289">    } else {</a>
<a name="ln290">      has_tab = false;          // avoid uninit warnings</a>
<a name="ln291">      len = linelen(eap-&gt;cmdidx == CMD_right ? &amp;has_tab : NULL) - get_indent();</a>
<a name="ln292"> </a>
<a name="ln293">      if (len &lt;= 0) {                           // skip blank lines</a>
<a name="ln294">        continue;</a>
<a name="ln295">      }</a>
<a name="ln296"> </a>
<a name="ln297">      if (eap-&gt;cmdidx == CMD_center) {</a>
<a name="ln298">        new_indent = (width - len) / 2;</a>
<a name="ln299">      } else {</a>
<a name="ln300">        new_indent = width - len;               // right align</a>
<a name="ln301"> </a>
<a name="ln302">        // Make sure that embedded TABs don't make the text go too far</a>
<a name="ln303">        // to the right.</a>
<a name="ln304">        if (has_tab) {</a>
<a name="ln305">          while (new_indent &gt; 0) {</a>
<a name="ln306">            (void)set_indent(new_indent, 0);</a>
<a name="ln307">            if (linelen(NULL) &lt;= width) {</a>
<a name="ln308">              // Now try to move the line as much as possible to</a>
<a name="ln309">              // the right.  Stop when it moves too far.</a>
<a name="ln310">              do {</a>
<a name="ln311">                (void)set_indent(++new_indent, 0);</a>
<a name="ln312">              } while (linelen(NULL) &lt;= width);</a>
<a name="ln313">              new_indent--;</a>
<a name="ln314">              break;</a>
<a name="ln315">            }</a>
<a name="ln316">            new_indent--;</a>
<a name="ln317">          }</a>
<a name="ln318">        }</a>
<a name="ln319">      }</a>
<a name="ln320">    }</a>
<a name="ln321">    if (new_indent &lt; 0) {</a>
<a name="ln322">      new_indent = 0;</a>
<a name="ln323">    }</a>
<a name="ln324">    (void)set_indent(new_indent, 0);                    // set indent</a>
<a name="ln325">  }</a>
<a name="ln326">  changed_lines(curbuf, eap-&gt;line1, 0, eap-&gt;line2 + 1, 0L, true);</a>
<a name="ln327">  curwin-&gt;w_cursor = save_curpos;</a>
<a name="ln328">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">/// @return  the length of the current line, excluding trailing white space.</a>
<a name="ln332">static int linelen(int *has_tab)</a>
<a name="ln333">{</a>
<a name="ln334">  char *line;</a>
<a name="ln335">  char *first;</a>
<a name="ln336">  char *last;</a>
<a name="ln337">  int len;</a>
<a name="ln338"> </a>
<a name="ln339">  // Get the line.  If it's empty bail out early (could be the empty string</a>
<a name="ln340">  // for an unloaded buffer).</a>
<a name="ln341">  line = get_cursor_line_ptr();</a>
<a name="ln342">  if (*line == NUL) {</a>
<a name="ln343">    return 0;</a>
<a name="ln344">  }</a>
<a name="ln345">  // find the first non-blank character</a>
<a name="ln346">  first = skipwhite(line);</a>
<a name="ln347"> </a>
<a name="ln348">  // find the character after the last non-blank character</a>
<a name="ln349">  for (last = first + strlen(first);</a>
<a name="ln350">       last &gt; first &amp;&amp; ascii_iswhite(last[-1]); last--) {}</a>
<a name="ln351">  char save = *last;</a>
<a name="ln352">  *last = NUL;</a>
<a name="ln353">  len = linetabsize_str(line);  // Get line length.</a>
<a name="ln354">  if (has_tab != NULL) {        // Check for embedded TAB.</a>
<a name="ln355">    *has_tab = vim_strchr(first, TAB) != NULL;</a>
<a name="ln356">  }</a>
<a name="ln357">  *last = save;</a>
<a name="ln358"> </a>
<a name="ln359">  return len;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">// Buffer for two lines used during sorting.  They are allocated to</a>
<a name="ln363">// contain the longest line being sorted.</a>
<a name="ln364">static char *sortbuf1;</a>
<a name="ln365">static char *sortbuf2;</a>
<a name="ln366"> </a>
<a name="ln367">static int sort_lc;       ///&lt; sort using locale</a>
<a name="ln368">static int sort_ic;       ///&lt; ignore case</a>
<a name="ln369">static int sort_nr;       ///&lt; sort on number</a>
<a name="ln370">static int sort_rx;       ///&lt; sort on regex instead of skipping it</a>
<a name="ln371">static int sort_flt;      ///&lt; sort on floating number</a>
<a name="ln372"> </a>
<a name="ln373">static int sort_abort;    ///&lt; flag to indicate if sorting has been interrupted</a>
<a name="ln374"> </a>
<a name="ln375">/// Struct to store info to be sorted.</a>
<a name="ln376">typedef struct {</a>
<a name="ln377">  linenr_T lnum;          ///&lt; line number</a>
<a name="ln378">  union {</a>
<a name="ln379">    struct {</a>
<a name="ln380">      varnumber_T start_col_nr;  ///&lt; starting column number</a>
<a name="ln381">      varnumber_T end_col_nr;    ///&lt; ending column number</a>
<a name="ln382">    } line;</a>
<a name="ln383">    struct {</a>
<a name="ln384">      varnumber_T value;         ///&lt; value if sorting by integer</a>
<a name="ln385">      bool is_number;            ///&lt; true when line contains a number</a>
<a name="ln386">    } num;</a>
<a name="ln387">    float_T value_flt;    ///&lt; value if sorting by float</a>
<a name="ln388">  } st_u;</a>
<a name="ln389">} sorti_T;</a>
<a name="ln390"> </a>
<a name="ln391">static int string_compare(const void *s1, const void *s2) FUNC_ATTR_NONNULL_ALL</a>
<a name="ln392">{</a>
<a name="ln393">  if (sort_lc) {</a>
<a name="ln394">    return strcoll((const char *)s1, (const char *)s2);</a>
<a name="ln395">  }</a>
<a name="ln396">  return sort_ic ? STRICMP(s1, s2) : strcmp(s1, s2);</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">static int sort_compare(const void *s1, const void *s2)</a>
<a name="ln400">{</a>
<a name="ln401">  sorti_T l1 = *(sorti_T *)s1;</a>
<a name="ln402">  sorti_T l2 = *(sorti_T *)s2;</a>
<a name="ln403">  int result = 0;</a>
<a name="ln404"> </a>
<a name="ln405">  // If the user interrupts, there's no way to stop qsort() immediately, but</a>
<a name="ln406">  // if we return 0 every time, qsort will assume it's done sorting and</a>
<a name="ln407">  // exit.</a>
<a name="ln408">  if (sort_abort) {</a>
<a name="ln409">    return 0;</a>
<a name="ln410">  }</a>
<a name="ln411">  fast_breakcheck();</a>
<a name="ln412">  if (got_int) {</a>
<a name="ln413">    sort_abort = true;</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  // When sorting numbers &quot;start_col_nr&quot; is the number, not the column</a>
<a name="ln417">  // number.</a>
<a name="ln418">  if (sort_nr) {</a>
<a name="ln419">    if (l1.st_u.num.is_number != l2.st_u.num.is_number) {</a>
<a name="ln420">      result = l1.st_u.num.is_number - l2.st_u.num.is_number;</a>
<a name="ln421">    } else {</a>
<a name="ln422">      result = l1.st_u.num.value == l2.st_u.num.value</a>
<a name="ln423">        ? 0</a>
<a name="ln424">        : l1.st_u.num.value &gt; l2.st_u.num.value</a>
<a name="ln425">          ? 1</a>
<a name="ln426">          : -1;</a>
<a name="ln427">    }</a>
<a name="ln428">  } else if (sort_flt) {</a>
<a name="ln429">    result = l1.st_u.value_flt == l2.st_u.value_flt</a>
<a name="ln430">             ? 0 : l1.st_u.value_flt &gt; l2.st_u.value_flt</a>
<a name="ln431">             ? 1 : -1;</a>
<a name="ln432">  } else {</a>
<a name="ln433">    // We need to copy one line into &quot;sortbuf1&quot;, because there is no</a>
<a name="ln434">    // guarantee that the first pointer becomes invalid when obtaining the</a>
<a name="ln435">    // second one.</a>
<a name="ln436">    memcpy(sortbuf1, ml_get(l1.lnum) + l1.st_u.line.start_col_nr,</a>
<a name="ln437">           (size_t)(l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr + 1));</a>
<a name="ln438">    sortbuf1[l1.st_u.line.end_col_nr - l1.st_u.line.start_col_nr] = NUL;</a>
<a name="ln439">    memcpy(sortbuf2, ml_get(l2.lnum) + l2.st_u.line.start_col_nr,</a>
<a name="ln440">           (size_t)(l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr + 1));</a>
<a name="ln441">    sortbuf2[l2.st_u.line.end_col_nr - l2.st_u.line.start_col_nr] = NUL;</a>
<a name="ln442"> </a>
<a name="ln443">    result = string_compare(sortbuf1, sortbuf2);</a>
<a name="ln444">  }</a>
<a name="ln445"> </a>
<a name="ln446">  // If two lines have the same value, preserve the original line order.</a>
<a name="ln447">  if (result == 0) {</a>
<a name="ln448">    return l1.lnum - l2.lnum;</a>
<a name="ln449">  }</a>
<a name="ln450">  return result;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/// &quot;:sort&quot;.</a>
<a name="ln454">void ex_sort(exarg_T *eap)</a>
<a name="ln455">{</a>
<a name="ln456">  regmatch_T regmatch;</a>
<a name="ln457">  int len;</a>
<a name="ln458">  linenr_T lnum;</a>
<a name="ln459">  long maxlen = 0;</a>
<a name="ln460">  size_t count = (size_t)(eap-&gt;line2 - eap-&gt;line1) + 1;</a>
<a name="ln461">  size_t i;</a>
<a name="ln462">  char *p;</a>
<a name="ln463">  char *s;</a>
<a name="ln464">  char *s2;</a>
<a name="ln465">  char c;                             // temporary character storage</a>
<a name="ln466">  bool unique = false;</a>
<a name="ln467">  linenr_T deleted;</a>
<a name="ln468">  colnr_T start_col;</a>
<a name="ln469">  colnr_T end_col;</a>
<a name="ln470">  int sort_what = 0;</a>
<a name="ln471"> </a>
<a name="ln472">  // Sorting one line is really quick!</a>
<a name="ln473">  if (count &lt;= 1) {</a>
<a name="ln474">    return;</a>
<a name="ln475">  }</a>
<a name="ln476"> </a>
<a name="ln477">  if (u_save((linenr_T)(eap-&gt;line1 - 1), (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln478">    return;</a>
<a name="ln479">  }</a>
<a name="ln480">  sortbuf1 = NULL;</a>
<a name="ln481">  sortbuf2 = NULL;</a>
<a name="ln482">  regmatch.regprog = NULL;</a>
<a name="ln483">  sorti_T *nrs = xmalloc(count * sizeof(sorti_T));</a>
<a name="ln484"> </a>
<a name="ln485">  sort_abort = sort_ic = sort_lc = sort_rx = sort_nr = sort_flt = 0;</a>
<a name="ln486">  size_t format_found = 0;</a>
<a name="ln487">  bool change_occurred = false;   // Buffer contents changed.</a>
<a name="ln488"> </a>
<a name="ln489">  for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln490">    if (ascii_iswhite(*p)) {</a>
<a name="ln491">      // Skip</a>
<a name="ln492">    } else if (*p == 'i') {</a>
<a name="ln493">      sort_ic = true;</a>
<a name="ln494">    } else if (*p == 'l') {</a>
<a name="ln495">      sort_lc = true;</a>
<a name="ln496">    } else if (*p == 'r') {</a>
<a name="ln497">      sort_rx = true;</a>
<a name="ln498">    } else if (*p == 'n') {</a>
<a name="ln499">      sort_nr = 1;</a>
<a name="ln500">      format_found++;</a>
<a name="ln501">    } else if (*p == 'f') {</a>
<a name="ln502">      sort_flt = 1;</a>
<a name="ln503">      format_found++;</a>
<a name="ln504">    } else if (*p == 'b') {</a>
<a name="ln505">      sort_what = STR2NR_BIN + STR2NR_FORCE;</a>
<a name="ln506">      format_found++;</a>
<a name="ln507">    } else if (*p == 'o') {</a>
<a name="ln508">      sort_what = STR2NR_OCT + STR2NR_FORCE;</a>
<a name="ln509">      format_found++;</a>
<a name="ln510">    } else if (*p == 'x') {</a>
<a name="ln511">      sort_what = STR2NR_HEX + STR2NR_FORCE;</a>
<a name="ln512">      format_found++;</a>
<a name="ln513">    } else if (*p == 'u') {</a>
<a name="ln514">      unique = true;</a>
<a name="ln515">    } else if (*p == '&quot;') {</a>
<a name="ln516">      // comment start</a>
<a name="ln517">      break;</a>
<a name="ln518">    } else if (check_nextcmd(p) != NULL) {</a>
<a name="ln519">      eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln520">      break;</a>
<a name="ln521">    } else if (!ASCII_ISALPHA(*p) &amp;&amp; regmatch.regprog == NULL) {</a>
<a name="ln522">      s = skip_regexp_err(p + 1, *p, true);</a>
<a name="ln523">      if (s == NULL) {</a>
<a name="ln524">        goto sortend;</a>
<a name="ln525">      }</a>
<a name="ln526">      *s = NUL;</a>
<a name="ln527">      // Use last search pattern if sort pattern is empty.</a>
<a name="ln528">      if (s == p + 1) {</a>
<a name="ln529">        if (last_search_pat() == NULL) {</a>
<a name="ln530">          emsg(_(e_noprevre));</a>
<a name="ln531">          goto sortend;</a>
<a name="ln532">        }</a>
<a name="ln533">        regmatch.regprog = vim_regcomp(last_search_pat(), RE_MAGIC);</a>
<a name="ln534">      } else {</a>
<a name="ln535">        regmatch.regprog = vim_regcomp(p + 1, RE_MAGIC);</a>
<a name="ln536">      }</a>
<a name="ln537">      if (regmatch.regprog == NULL) {</a>
<a name="ln538">        goto sortend;</a>
<a name="ln539">      }</a>
<a name="ln540">      p = s;                    // continue after the regexp</a>
<a name="ln541">      regmatch.rm_ic = p_ic;</a>
<a name="ln542">    } else {</a>
<a name="ln543">      semsg(_(e_invarg2), p);</a>
<a name="ln544">      goto sortend;</a>
<a name="ln545">    }</a>
<a name="ln546">  }</a>
<a name="ln547"> </a>
<a name="ln548">  // Can only have one of 'n', 'b', 'o' and 'x'.</a>
<a name="ln549">  if (format_found &gt; 1) {</a>
<a name="ln550">    emsg(_(e_invarg));</a>
<a name="ln551">    goto sortend;</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  // From here on &quot;sort_nr&quot; is used as a flag for any integer number</a>
<a name="ln555">  // sorting.</a>
<a name="ln556">  sort_nr += sort_what;</a>
<a name="ln557"> </a>
<a name="ln558">  // Make an array with all line numbers.  This avoids having to copy all</a>
<a name="ln559">  // the lines into allocated memory.</a>
<a name="ln560">  // When sorting on strings &quot;start_col_nr&quot; is the offset in the line, for</a>
<a name="ln561">  // numbers sorting it's the number to sort on.  This means the pattern</a>
<a name="ln562">  // matching and number conversion only has to be done once per line.</a>
<a name="ln563">  // Also get the longest line length for allocating &quot;sortbuf&quot;.</a>
<a name="ln564">  for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln565">    s = ml_get(lnum);</a>
<a name="ln566">    len = (int)strlen(s);</a>
<a name="ln567">    if (maxlen &lt; len) {</a>
<a name="ln568">      maxlen = len;</a>
<a name="ln569">    }</a>
<a name="ln570"> </a>
<a name="ln571">    start_col = 0;</a>
<a name="ln572">    end_col = len;</a>
<a name="ln573">    if (regmatch.regprog != NULL &amp;&amp; vim_regexec(&amp;regmatch, s, 0)) {</a>
<a name="ln574">      if (sort_rx) {</a>
<a name="ln575">        start_col = (colnr_T)(regmatch.startp[0] - s);</a>
<a name="ln576">        end_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln577">      } else {</a>
<a name="ln578">        start_col = (colnr_T)(regmatch.endp[0] - s);</a>
<a name="ln579">      }</a>
<a name="ln580">    } else if (regmatch.regprog != NULL) {</a>
<a name="ln581">      end_col = 0;</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    if (sort_nr || sort_flt) {</a>
<a name="ln585">      // Make sure vim_str2nr() doesn't read any digits past the end</a>
<a name="ln586">      // of the match, by temporarily terminating the string there</a>
<a name="ln587">      s2 = s + end_col;</a>
<a name="ln588">      c = *s2;</a>
<a name="ln589">      *s2 = NUL;</a>
<a name="ln590">      // Sorting on number: Store the number itself.</a>
<a name="ln591">      p = s + start_col;</a>
<a name="ln592">      if (sort_nr) {</a>
<a name="ln593">        if (sort_what &amp; STR2NR_HEX) {</a>
<a name="ln594">          s = skiptohex(p);</a>
<a name="ln595">        } else if (sort_what &amp; STR2NR_BIN) {</a>
<a name="ln596">          s = (char *)skiptobin(p);</a>
<a name="ln597">        } else {</a>
<a name="ln598">          s = skiptodigit(p);</a>
<a name="ln599">        }</a>
<a name="ln600">        if (s &gt; p &amp;&amp; s[-1] == '-') {</a>
<a name="ln601">          s--;  // include preceding negative sign</a>
<a name="ln602">        }</a>
<a name="ln603">        if (*s == NUL) {</a>
<a name="ln604">          // line without number should sort before any number</a>
<a name="ln605">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = false;</a>
<a name="ln606">          nrs[lnum - eap-&gt;line1].st_u.num.value = 0;</a>
<a name="ln607">        } else {</a>
<a name="ln608">          nrs[lnum - eap-&gt;line1].st_u.num.is_number = true;</a>
<a name="ln609">          vim_str2nr(s, NULL, NULL, sort_what,</a>
<a name="ln610">                     &amp;nrs[lnum - eap-&gt;line1].st_u.num.value, NULL, 0, false, NULL);</a>
<a name="ln611">        }</a>
<a name="ln612">      } else {</a>
<a name="ln613">        s = skipwhite(p);</a>
<a name="ln614">        if (*s == '+') {</a>
<a name="ln615">          s = skipwhite(s + 1);</a>
<a name="ln616">        }</a>
<a name="ln617"> </a>
<a name="ln618">        if (*s == NUL) {</a>
<a name="ln619">          // empty line should sort before any number</a>
<a name="ln620">          nrs[lnum - eap-&gt;line1].st_u.value_flt = -DBL_MAX;</a>
<a name="ln621">        } else {</a>
<a name="ln622">          nrs[lnum - eap-&gt;line1].st_u.value_flt = strtod(s, NULL);</a>
<a name="ln623">        }</a>
<a name="ln624">      }</a>
<a name="ln625">      *s2 = c;</a>
<a name="ln626">    } else {</a>
<a name="ln627">      // Store the column to sort at.</a>
<a name="ln628">      nrs[lnum - eap-&gt;line1].st_u.line.start_col_nr = start_col;</a>
<a name="ln629">      nrs[lnum - eap-&gt;line1].st_u.line.end_col_nr = end_col;</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">    nrs[lnum - eap-&gt;line1].lnum = lnum;</a>
<a name="ln633"> </a>
<a name="ln634">    if (regmatch.regprog != NULL) {</a>
<a name="ln635">      fast_breakcheck();</a>
<a name="ln636">    }</a>
<a name="ln637">    if (got_int) {</a>
<a name="ln638">      goto sortend;</a>
<a name="ln639">    }</a>
<a name="ln640">  }</a>
<a name="ln641"> </a>
<a name="ln642">  // Allocate a buffer that can hold the longest line.</a>
<a name="ln643">  sortbuf1 = xmalloc((size_t)maxlen + 1);</a>
<a name="ln644">  sortbuf2 = xmalloc((size_t)maxlen + 1);</a>
<a name="ln645"> </a>
<a name="ln646">  // Sort the array of line numbers.  Note: can't be interrupted!</a>
<a name="ln647">  qsort((void *)nrs, count, sizeof(sorti_T), sort_compare);</a>
<a name="ln648"> </a>
<a name="ln649">  if (sort_abort) {</a>
<a name="ln650">    goto sortend;</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  bcount_t old_count = 0, new_count = 0;</a>
<a name="ln654"> </a>
<a name="ln655">  // Insert the lines in the sorted order below the last one.</a>
<a name="ln656">  lnum = eap-&gt;line2;</a>
<a name="ln657">  for (i = 0; i &lt; count; i++) {</a>
<a name="ln658">    const linenr_T get_lnum = nrs[eap-&gt;forceit ? count - i - 1 : i].lnum;</a>
<a name="ln659"> </a>
<a name="ln660">    // If the original line number of the line being placed is not the same</a>
<a name="ln661">    // as &quot;lnum&quot; (accounting for offset), we know that the buffer changed.</a>
<a name="ln662">    if (get_lnum + ((linenr_T)count - 1) != lnum) {</a>
<a name="ln663">      change_occurred = true;</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    s = ml_get(get_lnum);</a>
<a name="ln667">    size_t bytelen = strlen(s) + 1;  // include EOL in bytelen</a>
<a name="ln668">    old_count += (bcount_t)bytelen;</a>
<a name="ln669">    if (!unique || i == 0 || string_compare(s, sortbuf1) != 0) {</a>
<a name="ln670">      // Copy the line into a buffer, it may become invalid in</a>
<a name="ln671">      // ml_append(). And it's needed for &quot;unique&quot;.</a>
<a name="ln672">      STRCPY(sortbuf1, s);</a>
<a name="ln673">      if (ml_append(lnum++, sortbuf1, (colnr_T)0, false) == FAIL) {</a>
<a name="ln674">        break;</a>
<a name="ln675">      }</a>
<a name="ln676">      new_count += (bcount_t)bytelen;</a>
<a name="ln677">    }</a>
<a name="ln678">    fast_breakcheck();</a>
<a name="ln679">    if (got_int) {</a>
<a name="ln680">      goto sortend;</a>
<a name="ln681">    }</a>
<a name="ln682">  }</a>
<a name="ln683"> </a>
<a name="ln684">  // delete the original lines if appending worked</a>
<a name="ln685">  if (i == count) {</a>
<a name="ln686">    for (i = 0; i &lt; count; i++) {</a>
<a name="ln687">      ml_delete(eap-&gt;line1, false);</a>
<a name="ln688">    }</a>
<a name="ln689">  } else {</a>
<a name="ln690">    count = 0;</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">  // Adjust marks for deleted (or added) lines and prepare for displaying.</a>
<a name="ln694">  deleted = (linenr_T)count - (lnum - eap-&gt;line2);</a>
<a name="ln695">  if (deleted &gt; 0) {</a>
<a name="ln696">    mark_adjust(eap-&gt;line2 - deleted, eap-&gt;line2, (long)MAXLNUM, -deleted, kExtmarkNOOP);</a>
<a name="ln697">    msgmore(-deleted);</a>
<a name="ln698">  } else if (deleted &lt; 0) {</a>
<a name="ln699">    mark_adjust(eap-&gt;line2, MAXLNUM, -deleted, 0L, kExtmarkNOOP);</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  if (change_occurred || deleted != 0) {</a>
<a name="ln703">    extmark_splice(curbuf, eap-&gt;line1 - 1, 0,</a>
<a name="ln704">                   (int)count, 0, old_count,</a>
<a name="ln705">                   lnum - eap-&gt;line2, 0, new_count, kExtmarkUndo);</a>
<a name="ln706"> </a>
<a name="ln707">    changed_lines(curbuf, eap-&gt;line1, 0, eap-&gt;line2 + 1, -deleted, true);</a>
<a name="ln708">  }</a>
<a name="ln709"> </a>
<a name="ln710">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln711">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln712"> </a>
<a name="ln713">sortend:</a>
<a name="ln714">  xfree(nrs);</a>
<a name="ln715">  xfree(sortbuf1);</a>
<a name="ln716">  xfree(sortbuf2);</a>
<a name="ln717">  vim_regfree(regmatch.regprog);</a>
<a name="ln718">  if (got_int) {</a>
<a name="ln719">    emsg(_(e_interr));</a>
<a name="ln720">  }</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723">/// :move command - move lines line1-line2 to line dest</a>
<a name="ln724">///</a>
<a name="ln725">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln726">int do_move(linenr_T line1, linenr_T line2, linenr_T dest)</a>
<a name="ln727">{</a>
<a name="ln728">  linenr_T l;</a>
<a name="ln729">  linenr_T extra;      // Num lines added before line1</a>
<a name="ln730">  linenr_T num_lines;  // Num lines moved</a>
<a name="ln731">  linenr_T last_line;  // Last line in file after adding new text</a>
<a name="ln732"> </a>
<a name="ln733">  if (dest &gt;= line1 &amp;&amp; dest &lt; line2) {</a>
<a name="ln734">    emsg(_(&quot;E134: Cannot move a range of lines into itself&quot;));</a>
<a name="ln735">    return FAIL;</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  // Do nothing if we are not actually moving any lines.  This will prevent</a>
<a name="ln739">  // the 'modified' flag from being set without cause.</a>
<a name="ln740">  if (dest == line1 - 1 || dest == line2) {</a>
<a name="ln741">    // Move the cursor as if lines were moved (see below) to be backwards</a>
<a name="ln742">    // compatible.</a>
<a name="ln743">    if (dest &gt;= line1) {</a>
<a name="ln744">      curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln745">    } else {</a>
<a name="ln746">      curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln747">    }</a>
<a name="ln748">    return OK;</a>
<a name="ln749">  }</a>
<a name="ln750"> </a>
<a name="ln751">  bcount_t start_byte = ml_find_line_or_offset(curbuf, line1, NULL, true);</a>
<a name="ln752">  bcount_t end_byte = ml_find_line_or_offset(curbuf, line2 + 1, NULL, true);</a>
<a name="ln753">  bcount_t extent_byte = end_byte - start_byte;</a>
<a name="ln754">  bcount_t dest_byte = ml_find_line_or_offset(curbuf, dest + 1, NULL, true);</a>
<a name="ln755"> </a>
<a name="ln756">  num_lines = line2 - line1 + 1;</a>
<a name="ln757"> </a>
<a name="ln758">  // First we copy the old text to its new location -- webb</a>
<a name="ln759">  // Also copy the flag that &quot;:global&quot; command uses.</a>
<a name="ln760">  if (u_save(dest, dest + 1) == FAIL) {</a>
<a name="ln761">    return FAIL;</a>
<a name="ln762">  }</a>
<a name="ln763">  for (extra = 0, l = line1; l &lt;= line2; l++) {</a>
<a name="ln764">    char *str = xstrdup(ml_get(l + extra));</a>
<a name="ln765">    ml_append(dest + l - line1, str, (colnr_T)0, false);</a>
<a name="ln766">    xfree(str);</a>
<a name="ln767">    if (dest &lt; line1) {</a>
<a name="ln768">      extra++;</a>
<a name="ln769">    }</a>
<a name="ln770">  }</a>
<a name="ln771"> </a>
<a name="ln772">  // Now we must be careful adjusting our marks so that we don't overlap our</a>
<a name="ln773">  // mark_adjust() calls.</a>
<a name="ln774">  //</a>
<a name="ln775">  // We adjust the marks within the old text so that they refer to the</a>
<a name="ln776">  // last lines of the file (temporarily), because we know no other marks</a>
<a name="ln777">  // will be set there since these line numbers did not exist until we added</a>
<a name="ln778">  // our new lines.</a>
<a name="ln779">  //</a>
<a name="ln780">  // Then we adjust the marks on lines between the old and new text positions</a>
<a name="ln781">  // (either forwards or backwards).</a>
<a name="ln782">  //</a>
<a name="ln783">  // And Finally we adjust the marks we put at the end of the file back to</a>
<a name="ln784">  // their final destination at the new text position -- webb</a>
<a name="ln785">  last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln786">  mark_adjust_nofold(line1, line2, last_line - line2, 0L, kExtmarkNOOP);</a>
<a name="ln787"> </a>
<a name="ln788">  disable_fold_update++;</a>
<a name="ln789">  changed_lines(curbuf, last_line - num_lines + 1, 0, last_line + 1, num_lines, false);</a>
<a name="ln790">  disable_fold_update--;</a>
<a name="ln791"> </a>
<a name="ln792">  int line_off = 0;</a>
<a name="ln793">  bcount_t byte_off = 0;</a>
<a name="ln794">  if (dest &gt;= line2) {</a>
<a name="ln795">    mark_adjust_nofold(line2 + 1, dest, -num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln796">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln797">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln798">        foldMoveRange(win, &amp;win-&gt;w_folds, line1, line2, dest);</a>
<a name="ln799">      }</a>
<a name="ln800">    }</a>
<a name="ln801">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln802">      curbuf-&gt;b_op_start.lnum = dest - num_lines + 1;</a>
<a name="ln803">      curbuf-&gt;b_op_end.lnum = dest;</a>
<a name="ln804">    }</a>
<a name="ln805">    line_off = -num_lines;</a>
<a name="ln806">    byte_off = -extent_byte;</a>
<a name="ln807">  } else {</a>
<a name="ln808">    mark_adjust_nofold(dest + 1, line1 - 1, num_lines, 0L, kExtmarkNOOP);</a>
<a name="ln809">    FOR_ALL_TAB_WINDOWS(tab, win) {</a>
<a name="ln810">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln811">        foldMoveRange(win, &amp;win-&gt;w_folds, dest + 1, line1 - 1, line2);</a>
<a name="ln812">      }</a>
<a name="ln813">    }</a>
<a name="ln814">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln815">      curbuf-&gt;b_op_start.lnum = dest + 1;</a>
<a name="ln816">      curbuf-&gt;b_op_end.lnum = dest + num_lines;</a>
<a name="ln817">    }</a>
<a name="ln818">  }</a>
<a name="ln819">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln820">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln821">  }</a>
<a name="ln822">  mark_adjust_nofold(last_line - num_lines + 1, last_line,</a>
<a name="ln823">                     -(last_line - dest - extra), 0L, kExtmarkNOOP);</a>
<a name="ln824"> </a>
<a name="ln825">  disable_fold_update++;</a>
<a name="ln826">  changed_lines(curbuf, last_line - num_lines + 1, 0, last_line + 1, -extra, false);</a>
<a name="ln827">  disable_fold_update--;</a>
<a name="ln828"> </a>
<a name="ln829">  // send update regarding the new lines that were added</a>
<a name="ln830">  buf_updates_send_changes(curbuf, dest + 1, num_lines, 0);</a>
<a name="ln831"> </a>
<a name="ln832">  // Now we delete the original text -- webb</a>
<a name="ln833">  if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL) {</a>
<a name="ln834">    return FAIL;</a>
<a name="ln835">  }</a>
<a name="ln836"> </a>
<a name="ln837">  for (l = line1; l &lt;= line2; l++) {</a>
<a name="ln838">    ml_delete(line1 + extra, true);</a>
<a name="ln839">  }</a>
<a name="ln840">  if (!global_busy &amp;&amp; num_lines &gt; p_report) {</a>
<a name="ln841">    smsg(0, NGETTEXT(&quot;%&quot; PRId64 &quot; line moved&quot;,</a>
<a name="ln842">                     &quot;%&quot; PRId64 &quot; lines moved&quot;, num_lines),</a>
<a name="ln843">         (int64_t)num_lines);</a>
<a name="ln844">  }</a>
<a name="ln845"> </a>
<a name="ln846">  extmark_move_region(curbuf, line1 - 1, 0, start_byte,</a>
<a name="ln847">                      line2 - line1 + 1, 0, extent_byte,</a>
<a name="ln848">                      dest + line_off, 0, dest_byte + byte_off,</a>
<a name="ln849">                      kExtmarkUndo);</a>
<a name="ln850"> </a>
<a name="ln851">  // Leave the cursor on the last of the moved lines.</a>
<a name="ln852">  if (dest &gt;= line1) {</a>
<a name="ln853">    curwin-&gt;w_cursor.lnum = dest;</a>
<a name="ln854">  } else {</a>
<a name="ln855">    curwin-&gt;w_cursor.lnum = dest + (line2 - line1) + 1;</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858">  if (line1 &lt; dest) {</a>
<a name="ln859">    dest += num_lines + 1;</a>
<a name="ln860">    last_line = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln861">    if (dest &gt; last_line + 1) {</a>
<a name="ln862">      dest = last_line + 1;</a>
<a name="ln863">    }</a>
<a name="ln864">    changed_lines(curbuf, line1, 0, dest, 0L, false);</a>
<a name="ln865">  } else {</a>
<a name="ln866">    changed_lines(curbuf, dest + 1, 0, line1 + num_lines, 0L, false);</a>
<a name="ln867">  }</a>
<a name="ln868"> </a>
<a name="ln869">  // send nvim_buf_lines_event regarding lines that were deleted</a>
<a name="ln870">  buf_updates_send_changes(curbuf, line1 + extra, 0, num_lines);</a>
<a name="ln871"> </a>
<a name="ln872">  return OK;</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">/// &quot;:copy&quot;</a>
<a name="ln876">void ex_copy(linenr_T line1, linenr_T line2, linenr_T n)</a>
<a name="ln877">{</a>
<a name="ln878">  linenr_T count = line2 - line1 + 1;</a>
<a name="ln879">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln880">    curbuf-&gt;b_op_start.lnum = n + 1;</a>
<a name="ln881">    curbuf-&gt;b_op_end.lnum = n + count;</a>
<a name="ln882">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">  // there are three situations:</a>
<a name="ln886">  // 1. destination is above line1</a>
<a name="ln887">  // 2. destination is between line1 and line2</a>
<a name="ln888">  // 3. destination is below line2</a>
<a name="ln889">  //</a>
<a name="ln890">  // n = destination (when starting)</a>
<a name="ln891">  // curwin-&gt;w_cursor.lnum = destination (while copying)</a>
<a name="ln892">  // line1 = start of source (while copying)</a>
<a name="ln893">  // line2 = end of source (while copying)</a>
<a name="ln894">  if (u_save(n, n + 1) == FAIL) {</a>
<a name="ln895">    return;</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  curwin-&gt;w_cursor.lnum = n;</a>
<a name="ln899">  while (line1 &lt;= line2) {</a>
<a name="ln900">    // need to use xstrdup() because the line will be unlocked within</a>
<a name="ln901">    // ml_append()</a>
<a name="ln902">    char *p = xstrdup(ml_get(line1));</a>
<a name="ln903">    ml_append(curwin-&gt;w_cursor.lnum, p, (colnr_T)0, false);</a>
<a name="ln904">    xfree(p);</a>
<a name="ln905"> </a>
<a name="ln906">    // situation 2: skip already copied lines</a>
<a name="ln907">    if (line1 == n) {</a>
<a name="ln908">      line1 = curwin-&gt;w_cursor.lnum;</a>
<a name="ln909">    }</a>
<a name="ln910">    line1++;</a>
<a name="ln911">    if (curwin-&gt;w_cursor.lnum &lt; line1) {</a>
<a name="ln912">      line1++;</a>
<a name="ln913">    }</a>
<a name="ln914">    if (curwin-&gt;w_cursor.lnum &lt; line2) {</a>
<a name="ln915">      line2++;</a>
<a name="ln916">    }</a>
<a name="ln917">    curwin-&gt;w_cursor.lnum++;</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  appended_lines_mark(n, count);</a>
<a name="ln921">  if (VIsual_active) {</a>
<a name="ln922">    check_pos(curbuf, &amp;VIsual);</a>
<a name="ln923">  }</a>
<a name="ln924"> </a>
<a name="ln925">  msgmore((long)count);</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">static char *prevcmd = NULL;        // the previous command</a>
<a name="ln929"> </a>
<a name="ln930">#if defined(EXITFREE)</a>
<a name="ln931">void free_prev_shellcmd(void)</a>
<a name="ln932">{</a>
<a name="ln933">  xfree(prevcmd);</a>
<a name="ln934">}</a>
<a name="ln935"> </a>
<a name="ln936">#endif</a>
<a name="ln937"> </a>
<a name="ln938">/// Check that &quot;prevcmd&quot; is not NULL.  If it is NULL then give an error message</a>
<a name="ln939">/// and return false.</a>
<a name="ln940">static int prevcmd_is_set(void)</a>
<a name="ln941">{</a>
<a name="ln942">  if (prevcmd == NULL) {</a>
<a name="ln943">    emsg(_(e_noprev));</a>
<a name="ln944">    return false;</a>
<a name="ln945">  }</a>
<a name="ln946">  return true;</a>
<a name="ln947">}</a>
<a name="ln948"> </a>
<a name="ln949">/// Handle the &quot;:!cmd&quot; command.  Also for &quot;:r !cmd&quot; and &quot;:w !cmd&quot;</a>
<a name="ln950">/// Bangs in the argument are replaced with the previously entered command.</a>
<a name="ln951">/// Remember the argument.</a>
<a name="ln952">void do_bang(int addr_count, exarg_T *eap, bool forceit, bool do_in, bool do_out)</a>
<a name="ln953">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln954">{</a>
<a name="ln955">  char *arg = eap-&gt;arg;             // command</a>
<a name="ln956">  linenr_T line1 = eap-&gt;line1;        // start of range</a>
<a name="ln957">  linenr_T line2 = eap-&gt;line2;        // end of range</a>
<a name="ln958">  char *newcmd = NULL;              // the new command</a>
<a name="ln959">  bool free_newcmd = false;           // need to free() newcmd</a>
<a name="ln960">  char *t;</a>
<a name="ln961">  char *p;</a>
<a name="ln962">  char *trailarg;</a>
<a name="ln963">  int scroll_save = msg_scroll;</a>
<a name="ln964"> </a>
<a name="ln965">  //</a>
<a name="ln966">  // Disallow shell commands in secure mode</a>
<a name="ln967">  //</a>
<a name="ln968">  if (check_secure()) {</a>
<a name="ln969">    return;</a>
<a name="ln970">  }</a>
<a name="ln971"> </a>
<a name="ln972">  if (addr_count == 0) {                // :!</a>
<a name="ln973">    msg_scroll = false;             // don't scroll here</a>
<a name="ln974">    autowrite_all();</a>
<a name="ln975">    msg_scroll = scroll_save;</a>
<a name="ln976">  }</a>
<a name="ln977"> </a>
<a name="ln978">  // Try to find an embedded bang, like in &quot;:!&lt;cmd&gt; ! [args]&quot;</a>
<a name="ln979">  // &quot;:!!&quot; is indicated by the 'forceit' variable.</a>
<a name="ln980">  bool ins_prevcmd = forceit;</a>
<a name="ln981"> </a>
<a name="ln982">  // Skip leading white space to avoid a strange error with some shells.</a>
<a name="ln983">  trailarg = skipwhite(arg);</a>
<a name="ln984">  do {</a>
<a name="ln985">    size_t len = strlen(trailarg) + 1;</a>
<a name="ln986">    if (newcmd != NULL) {</a>
<a name="ln987">      len += strlen(newcmd);</a>
<a name="ln988">    }</a>
<a name="ln989">    if (ins_prevcmd) {</a>
<a name="ln990">      if (!prevcmd_is_set()) {</a>
<a name="ln991">        xfree(newcmd);</a>
<a name="ln992">        return;</a>
<a name="ln993">      }</a>
<a name="ln994">      len += strlen(prevcmd);</a>
<a name="ln995">    }</a>
<a name="ln996">    t = xmalloc(len);</a>
<a name="ln997">    *t = NUL;</a>
<a name="ln998">    if (newcmd != NULL) {</a>
<a name="ln999">      STRCAT(t, newcmd);</a>
<a name="ln1000">    }</a>
<a name="ln1001">    if (ins_prevcmd) {</a>
<a name="ln1002">      STRCAT(t, prevcmd);</a>
<a name="ln1003">    }</a>
<a name="ln1004">    p = t + strlen(t);</a>
<a name="ln1005">    STRCAT(t, trailarg);</a>
<a name="ln1006">    xfree(newcmd);</a>
<a name="ln1007">    newcmd = t;</a>
<a name="ln1008"> </a>
<a name="ln1009">    // Scan the rest of the argument for '!', which is replaced by the</a>
<a name="ln1010">    // previous command.  &quot;\!&quot; is replaced by &quot;!&quot; (this is vi compatible).</a>
<a name="ln1011">    trailarg = NULL;</a>
<a name="ln1012">    while (*p) {</a>
<a name="ln1013">      if (*p == '!') {</a>
<a name="ln1014">        if (p &gt; newcmd &amp;&amp; p[-1] == '\\') {</a>
<a name="ln1015">          STRMOVE(p - 1, p);</a>
<a name="ln1016">        } else {</a>
<a name="ln1017">          trailarg = p;</a>
<a name="ln1018">          *trailarg++ = NUL;</a>
<a name="ln1019">          ins_prevcmd = true;</a>
<a name="ln1020">          break;</a>
<a name="ln1021">        }</a>
<a name="ln1022">      }</a>
<a name="ln1023">      p++;</a>
<a name="ln1024">    }</a>
<a name="ln1025">  } while (trailarg != NULL);</a>
<a name="ln1026"> </a>
<a name="ln1027">  // Only set &quot;prevcmd&quot; if there is a command to run, otherwise keep te one</a>
<a name="ln1028">  // we have.</a>
<a name="ln1029">  if (strlen(newcmd) &gt; 0) {</a>
<a name="ln1030">    xfree(prevcmd);</a>
<a name="ln1031">    prevcmd = newcmd;</a>
<a name="ln1032">  } else {</a>
<a name="ln1033">    free_newcmd = true;</a>
<a name="ln1034">  }</a>
<a name="ln1035"> </a>
<a name="ln1036">  if (bangredo) {  // put cmd in redo buffer for ! command</a>
<a name="ln1037">    if (!prevcmd_is_set()) {</a>
<a name="ln1038">      goto theend;</a>
<a name="ln1039">    }</a>
<a name="ln1040"> </a>
<a name="ln1041">    // If % or # appears in the command, it must have been escaped.</a>
<a name="ln1042">    // Reescape them, so that redoing them does not substitute them by the</a>
<a name="ln1043">    // buffername.</a>
<a name="ln1044">    char *cmd = vim_strsave_escaped(prevcmd, &quot;%#&quot;);</a>
<a name="ln1045"> </a>
<a name="ln1046">    AppendToRedobuffLit(cmd, -1);</a>
<a name="ln1047">    xfree(cmd);</a>
<a name="ln1048">    AppendToRedobuff(&quot;\n&quot;);</a>
<a name="ln1049">    bangredo = false;</a>
<a name="ln1050">  }</a>
<a name="ln1051">  // Add quotes around the command, for shells that need them.</a>
<a name="ln1052">  if (*p_shq != NUL) {</a>
<a name="ln1053">    if (free_newcmd) {</a>
<a name="ln1054">      xfree(newcmd);</a>
<a name="ln1055">    }</a>
<a name="ln1056">    newcmd = xmalloc(strlen(prevcmd) + 2 * strlen(p_shq) + 1);</a>
<a name="ln1057">    STRCPY(newcmd, p_shq);</a>
<a name="ln1058">    STRCAT(newcmd, prevcmd);</a>
<a name="ln1059">    STRCAT(newcmd, p_shq);</a>
<a name="ln1060">    free_newcmd = true;</a>
<a name="ln1061">  }</a>
<a name="ln1062">  if (addr_count == 0) {                // :!</a>
<a name="ln1063">    // echo the command</a>
<a name="ln1064">    msg_start();</a>
<a name="ln1065">    msg_putchar(':');</a>
<a name="ln1066">    msg_putchar('!');</a>
<a name="ln1067">    msg_outtrans(newcmd, 0);</a>
<a name="ln1068">    msg_clr_eos();</a>
<a name="ln1069">    ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1070"> </a>
<a name="ln1071">    do_shell(newcmd, 0);</a>
<a name="ln1072">  } else {                            // :range!</a>
<a name="ln1073">    // Careful: This may recursively call do_bang() again! (because of</a>
<a name="ln1074">    // autocommands)</a>
<a name="ln1075">    do_filter(line1, line2, eap, newcmd, do_in, do_out);</a>
<a name="ln1076">    apply_autocmds(EVENT_SHELLFILTERPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1077">  }</a>
<a name="ln1078"> </a>
<a name="ln1079">theend:</a>
<a name="ln1080">  if (free_newcmd) {</a>
<a name="ln1081">    xfree(newcmd);</a>
<a name="ln1082">  }</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/// do_filter: filter lines through a command given by the user</a>
<a name="ln1086">///</a>
<a name="ln1087">/// We mostly use temp files and the call_shell() routine here. This would</a>
<a name="ln1088">/// normally be done using pipes on a Unix system, but this is more portable</a>
<a name="ln1089">/// to non-Unix systems. The call_shell() routine needs to be able</a>
<a name="ln1090">/// to deal with redirection somehow, and should handle things like looking</a>
<a name="ln1091">/// at the PATH env. variable, and adding reasonable extensions to the</a>
<a name="ln1092">/// command name given by the user. All reasonable versions of call_shell()</a>
<a name="ln1093">/// do this.</a>
<a name="ln1094">/// Alternatively, if on Unix and redirecting input or output, but not both,</a>
<a name="ln1095">/// and the 'shelltemp' option isn't set, use pipes.</a>
<a name="ln1096">/// We use input redirection if do_in is true.</a>
<a name="ln1097">/// We use output redirection if do_out is true.</a>
<a name="ln1098">///</a>
<a name="ln1099">/// @param eap  for forced 'ff' and 'fenc'</a>
<a name="ln1100">static void do_filter(linenr_T line1, linenr_T line2, exarg_T *eap, char *cmd, bool do_in,</a>
<a name="ln1101">                      bool do_out)</a>
<a name="ln1102">{</a>
<a name="ln1103">  char *itmp = NULL;</a>
<a name="ln1104">  char *otmp = NULL;</a>
<a name="ln1105">  linenr_T linecount;</a>
<a name="ln1106">  linenr_T read_linecount;</a>
<a name="ln1107">  pos_T cursor_save;</a>
<a name="ln1108">  char *cmd_buf;</a>
<a name="ln1109">  buf_T *old_curbuf = curbuf;</a>
<a name="ln1110">  int shell_flags = 0;</a>
<a name="ln1111">  const pos_T orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln1112">  const pos_T orig_end = curbuf-&gt;b_op_end;</a>
<a name="ln1113">  const int stmp = p_stmp;</a>
<a name="ln1114"> </a>
<a name="ln1115">  if (*cmd == NUL) {        // no filter command</a>
<a name="ln1116">    return;</a>
<a name="ln1117">  }</a>
<a name="ln1118"> </a>
<a name="ln1119">  const int save_cmod_flags = cmdmod.cmod_flags;</a>
<a name="ln1120">  // Temporarily disable lockmarks since that's needed to propagate changed</a>
<a name="ln1121">  // regions of the buffer for foldUpdate(), linecount, etc.</a>
<a name="ln1122">  cmdmod.cmod_flags &amp;= ~CMOD_LOCKMARKS;</a>
<a name="ln1123"> </a>
<a name="ln1124">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1125">  linecount = line2 - line1 + 1;</a>
<a name="ln1126">  curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1127">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1128">  changed_line_abv_curs();</a>
<a name="ln1129">  invalidate_botline(curwin);</a>
<a name="ln1130"> </a>
<a name="ln1131">  // When using temp files:</a>
<a name="ln1132">  // 1. * Form temp file names</a>
<a name="ln1133">  // 2. * Write the lines to a temp file</a>
<a name="ln1134">  // 3.   Run the filter command on the temp file</a>
<a name="ln1135">  // 4. * Read the output of the command into the buffer</a>
<a name="ln1136">  // 5. * Delete the original lines to be filtered</a>
<a name="ln1137">  // 6. * Remove the temp files</a>
<a name="ln1138">  //</a>
<a name="ln1139">  // When writing the input with a pipe or when catching the output with a</a>
<a name="ln1140">  // pipe only need to do 3.</a>
<a name="ln1141"> </a>
<a name="ln1142">  if (do_out) {</a>
<a name="ln1143">    shell_flags |= kShellOptDoOut;</a>
<a name="ln1144">  }</a>
<a name="ln1145"> </a>
<a name="ln1146">  if (!do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1147">    // Use a pipe to fetch stdout of the command, do not use a temp file.</a>
<a name="ln1148">    shell_flags |= kShellOptRead;</a>
<a name="ln1149">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1150">  } else if (do_in &amp;&amp; !do_out &amp;&amp; !stmp) {</a>
<a name="ln1151">    // Use a pipe to write stdin of the command, do not use a temp file.</a>
<a name="ln1152">    shell_flags |= kShellOptWrite;</a>
<a name="ln1153">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1154">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1155">  } else if (do_in &amp;&amp; do_out &amp;&amp; !stmp) {</a>
<a name="ln1156">    // Use a pipe to write stdin and fetch stdout of the command, do not</a>
<a name="ln1157">    // use a temp file.</a>
<a name="ln1158">    shell_flags |= kShellOptRead | kShellOptWrite;</a>
<a name="ln1159">    curbuf-&gt;b_op_start.lnum = line1;</a>
<a name="ln1160">    curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln1161">    curwin-&gt;w_cursor.lnum = line2;</a>
<a name="ln1162">  } else if ((do_in &amp;&amp; (itmp = vim_tempname()) == NULL)</a>
<a name="ln1163">             || (do_out &amp;&amp; (otmp = vim_tempname()) == NULL)) {</a>
<a name="ln1164">    emsg(_(e_notmp));</a>
<a name="ln1165">    goto filterend;</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  // The writing and reading of temp files will not be shown.</a>
<a name="ln1169">  // Vi also doesn't do this and the messages are not very informative.</a>
<a name="ln1170">  no_wait_return++;             // don't call wait_return() while busy</a>
<a name="ln1171">  if (itmp != NULL &amp;&amp; buf_write(curbuf, itmp, NULL, line1, line2, eap,</a>
<a name="ln1172">                                false, false, false, true) == FAIL) {</a>
<a name="ln1173">    msg_putchar('\n');  // Keep message from buf_write().</a>
<a name="ln1174">    no_wait_return--;</a>
<a name="ln1175">    if (!aborting()) {</a>
<a name="ln1176">      // will call wait_return()</a>
<a name="ln1177">      semsg(_(&quot;E482: Can't create file %s&quot;), itmp);</a>
<a name="ln1178">    }</a>
<a name="ln1179">    goto filterend;</a>
<a name="ln1180">  }</a>
<a name="ln1181">  if (curbuf != old_curbuf) {</a>
<a name="ln1182">    goto filterend;</a>
<a name="ln1183">  }</a>
<a name="ln1184"> </a>
<a name="ln1185">  if (!do_out) {</a>
<a name="ln1186">    msg_putchar('\n');</a>
<a name="ln1187">  }</a>
<a name="ln1188"> </a>
<a name="ln1189">  // Create the shell command in allocated memory.</a>
<a name="ln1190">  cmd_buf = make_filter_cmd(cmd, itmp, otmp);</a>
<a name="ln1191">  ui_cursor_goto(Rows - 1, 0);</a>
<a name="ln1192"> </a>
<a name="ln1193">  if (do_out) {</a>
<a name="ln1194">    if (u_save(line2, (linenr_T)(line2 + 1)) == FAIL) {</a>
<a name="ln1195">      xfree(cmd_buf);</a>
<a name="ln1196">      goto error;</a>
<a name="ln1197">    }</a>
<a name="ln1198">    redraw_curbuf_later(UPD_VALID);</a>
<a name="ln1199">  }</a>
<a name="ln1200">  read_linecount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1201"> </a>
<a name="ln1202">  // Pass on the kShellOptDoOut flag when the output is being redirected.</a>
<a name="ln1203">  call_shell(cmd_buf, (ShellOpts)(kShellOptFilter | shell_flags), NULL);</a>
<a name="ln1204">  xfree(cmd_buf);</a>
<a name="ln1205"> </a>
<a name="ln1206">  did_check_timestamps = false;</a>
<a name="ln1207">  need_check_timestamps = true;</a>
<a name="ln1208"> </a>
<a name="ln1209">  // When interrupting the shell command, it may still have produced some</a>
<a name="ln1210">  // useful output.  Reset got_int here, so that readfile() won't cancel</a>
<a name="ln1211">  // reading.</a>
<a name="ln1212">  os_breakcheck();</a>
<a name="ln1213">  got_int = false;</a>
<a name="ln1214"> </a>
<a name="ln1215">  if (do_out) {</a>
<a name="ln1216">    if (otmp != NULL) {</a>
<a name="ln1217">      if (readfile(otmp, NULL, line2, (linenr_T)0, (linenr_T)MAXLNUM, eap,</a>
<a name="ln1218">                   READ_FILTER, false) != OK) {</a>
<a name="ln1219">        if (!aborting()) {</a>
<a name="ln1220">          msg_putchar('\n');</a>
<a name="ln1221">          semsg(_(e_notread), otmp);</a>
<a name="ln1222">        }</a>
<a name="ln1223">        goto error;</a>
<a name="ln1224">      }</a>
<a name="ln1225">      if (curbuf != old_curbuf) {</a>
<a name="ln1226">        goto filterend;</a>
<a name="ln1227">      }</a>
<a name="ln1228">    }</a>
<a name="ln1229"> </a>
<a name="ln1230">    read_linecount = curbuf-&gt;b_ml.ml_line_count - read_linecount;</a>
<a name="ln1231"> </a>
<a name="ln1232">    if (shell_flags &amp; kShellOptRead) {</a>
<a name="ln1233">      curbuf-&gt;b_op_start.lnum = line2 + 1;</a>
<a name="ln1234">      curbuf-&gt;b_op_end.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1235">      appended_lines_mark(line2, read_linecount);</a>
<a name="ln1236">    }</a>
<a name="ln1237"> </a>
<a name="ln1238">    if (do_in) {</a>
<a name="ln1239">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPMARKS)</a>
<a name="ln1240">          || vim_strchr(p_cpo, CPO_REMMARK) == NULL) {</a>
<a name="ln1241">        // TODO(bfredl): Currently not active for extmarks. What would we</a>
<a name="ln1242">        // do if columns don't match, assume added/deleted bytes at the</a>
<a name="ln1243">        // end of each line?</a>
<a name="ln1244">        if (read_linecount &gt;= linecount) {</a>
<a name="ln1245">          // move all marks from old lines to new lines</a>
<a name="ln1246">          mark_adjust(line1, line2, linecount, 0L, kExtmarkNOOP);</a>
<a name="ln1247">        } else {</a>
<a name="ln1248">          // move marks from old lines to new lines, delete marks</a>
<a name="ln1249">          // that are in deleted lines</a>
<a name="ln1250">          mark_adjust(line1, line1 + read_linecount - 1, linecount, 0L,</a>
<a name="ln1251">                      kExtmarkNOOP);</a>
<a name="ln1252">          mark_adjust(line1 + read_linecount, line2, MAXLNUM, 0L,</a>
<a name="ln1253">                      kExtmarkNOOP);</a>
<a name="ln1254">        }</a>
<a name="ln1255">      }</a>
<a name="ln1256"> </a>
<a name="ln1257">      // Put cursor on first filtered line for &quot;:range!cmd&quot;.</a>
<a name="ln1258">      // Adjust '[ and '] (set by buf_write()).</a>
<a name="ln1259">      curwin-&gt;w_cursor.lnum = line1;</a>
<a name="ln1260">      del_lines(linecount, true);</a>
<a name="ln1261">      curbuf-&gt;b_op_start.lnum -= linecount;             // adjust '[</a>
<a name="ln1262">      curbuf-&gt;b_op_end.lnum -= linecount;               // adjust ']</a>
<a name="ln1263">      write_lnum_adjust(-linecount);                    // adjust last line</a>
<a name="ln1264">                                                        // for next write</a>
<a name="ln1265">      foldUpdate(curwin, curbuf-&gt;b_op_start.lnum, curbuf-&gt;b_op_end.lnum);</a>
<a name="ln1266">    } else {</a>
<a name="ln1267">      // Put cursor on last new line for &quot;:r !cmd&quot;.</a>
<a name="ln1268">      linecount = curbuf-&gt;b_op_end.lnum - curbuf-&gt;b_op_start.lnum + 1;</a>
<a name="ln1269">      curwin-&gt;w_cursor.lnum = curbuf-&gt;b_op_end.lnum;</a>
<a name="ln1270">    }</a>
<a name="ln1271"> </a>
<a name="ln1272">    beginline(BL_WHITE | BL_FIX);           // cursor on first non-blank</a>
<a name="ln1273">    no_wait_return--;</a>
<a name="ln1274"> </a>
<a name="ln1275">    if (linecount &gt; p_report) {</a>
<a name="ln1276">      if (do_in) {</a>
<a name="ln1277">        vim_snprintf(msg_buf, sizeof(msg_buf),</a>
<a name="ln1278">                     _(&quot;%&quot; PRId64 &quot; lines filtered&quot;), (int64_t)linecount);</a>
<a name="ln1279">        if (msg(msg_buf, 0) &amp;&amp; !msg_scroll) {</a>
<a name="ln1280">          // save message to display it after redraw</a>
<a name="ln1281">          set_keep_msg(msg_buf, 0);</a>
<a name="ln1282">        }</a>
<a name="ln1283">      } else {</a>
<a name="ln1284">        msgmore((long)linecount);</a>
<a name="ln1285">      }</a>
<a name="ln1286">    }</a>
<a name="ln1287">  } else {</a>
<a name="ln1288">error:</a>
<a name="ln1289">    // put cursor back in same position for &quot;:w !cmd&quot;</a>
<a name="ln1290">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1291">    no_wait_return--;</a>
<a name="ln1292">    wait_return(false);</a>
<a name="ln1293">  }</a>
<a name="ln1294"> </a>
<a name="ln1295">filterend:</a>
<a name="ln1296"> </a>
<a name="ln1297">  cmdmod.cmod_flags = save_cmod_flags;</a>
<a name="ln1298">  if (curbuf != old_curbuf) {</a>
<a name="ln1299">    no_wait_return--;</a>
<a name="ln1300">    emsg(_(&quot;E135: *Filter* Autocommands must not change current buffer&quot;));</a>
<a name="ln1301">  } else if (cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) {</a>
<a name="ln1302">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln1303">    curbuf-&gt;b_op_end = orig_end;</a>
<a name="ln1304">  }</a>
<a name="ln1305"> </a>
<a name="ln1306">  if (itmp != NULL) {</a>
<a name="ln1307">    os_remove(itmp);</a>
<a name="ln1308">  }</a>
<a name="ln1309">  if (otmp != NULL) {</a>
<a name="ln1310">    os_remove(otmp);</a>
<a name="ln1311">  }</a>
<a name="ln1312">  xfree(itmp);</a>
<a name="ln1313">  xfree(otmp);</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">/// Call a shell to execute a command.</a>
<a name="ln1317">/// When &quot;cmd&quot; is NULL start an interactive shell.</a>
<a name="ln1318">///</a>
<a name="ln1319">/// @param flags  may be SHELL_DOOUT when output is redirected</a>
<a name="ln1320">void do_shell(char *cmd, int flags)</a>
<a name="ln1321">{</a>
<a name="ln1322">  // Disallow shell commands in secure mode</a>
<a name="ln1323">  if (check_secure()) {</a>
<a name="ln1324">    msg_end();</a>
<a name="ln1325">    return;</a>
<a name="ln1326">  }</a>
<a name="ln1327"> </a>
<a name="ln1328">  // For autocommands we want to get the output on the current screen, to</a>
<a name="ln1329">  // avoid having to type return below.</a>
<a name="ln1330">  msg_putchar('\r');                    // put cursor at start of line</a>
<a name="ln1331">  msg_putchar('\n');                    // may shift screen one line up</a>
<a name="ln1332"> </a>
<a name="ln1333">  // warning message before calling the shell</a>
<a name="ln1334">  if (p_warn</a>
<a name="ln1335">      &amp;&amp; !autocmd_busy</a>
<a name="ln1336">      &amp;&amp; msg_silent == 0) {</a>
<a name="ln1337">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1338">      if (bufIsChanged(buf)) {</a>
<a name="ln1339">        msg_puts(_(&quot;[No write since last change]\n&quot;));</a>
<a name="ln1340">        break;</a>
<a name="ln1341">      }</a>
<a name="ln1342">    }</a>
<a name="ln1343">  }</a>
<a name="ln1344"> </a>
<a name="ln1345">  // This ui_cursor_goto is required for when the '\n' resulted in a &quot;delete line</a>
<a name="ln1346">  // 1&quot; command to the terminal.</a>
<a name="ln1347">  ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln1348">  (void)call_shell(cmd, (ShellOpts)flags, NULL);</a>
<a name="ln1349">  msg_didout = true;</a>
<a name="ln1350">  did_check_timestamps = false;</a>
<a name="ln1351">  need_check_timestamps = true;</a>
<a name="ln1352"> </a>
<a name="ln1353">  // put the message cursor at the end of the screen, avoids wait_return()</a>
<a name="ln1354">  // to overwrite the text that the external command showed</a>
<a name="ln1355">  msg_row = Rows - 1;</a>
<a name="ln1356">  msg_col = 0;</a>
<a name="ln1357"> </a>
<a name="ln1358">  apply_autocmds(EVENT_SHELLCMDPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">#if !defined(UNIX)</a>
<a name="ln1362">static char *find_pipe(const char *cmd)</a>
<a name="ln1363">{</a>
<a name="ln1364">  bool inquote = false;</a>
<a name="ln1365"> </a>
<a name="ln1366">  for (const char *p = cmd; *p != NUL; p++) {</a>
<a name="ln1367">    if (!inquote &amp;&amp; *p == '|') {</a>
<a name="ln1368">      return (char *)p;</a>
<a name="ln1369">    }</a>
<a name="ln1370">    if (*p == '&quot;') {</a>
<a name="ln1371">      inquote = !inquote;</a>
<a name="ln1372">    } else if (rem_backslash(p)) {</a>
<a name="ln1373">      p++;</a>
<a name="ln1374">    }</a>
<a name="ln1375">  }</a>
<a name="ln1376">  return NULL;</a>
<a name="ln1377">}</a>
<a name="ln1378">#endif</a>
<a name="ln1379"> </a>
<a name="ln1380">/// Create a shell command from a command string, input redirection file and</a>
<a name="ln1381">/// output redirection file.</a>
<a name="ln1382">///</a>
<a name="ln1383">/// @param cmd  Command to execute.</a>
<a name="ln1384">/// @param itmp NULL or the input file.</a>
<a name="ln1385">/// @param otmp NULL or the output file.</a>
<a name="ln1386">/// @returns an allocated string with the shell command.</a>
<a name="ln1387">char *make_filter_cmd(char *cmd, char *itmp, char *otmp)</a>
<a name="ln1388">{</a>
<a name="ln1389">  bool is_fish_shell =</a>
<a name="ln1390">#if defined(UNIX)</a>
<a name="ln1391">    strncmp(invocation_path_tail(p_sh, NULL), &quot;fish&quot;, 4) == 0;</a>
<a name="ln1392">#else</a>
<a name="ln1393">    false;</a>
<a name="ln1394">#endif</a>
<a name="ln1395">  bool is_pwsh = strncmp(invocation_path_tail(p_sh, NULL), &quot;pwsh&quot;, 4) == 0</a>
<a name="ln1396">                 || strncmp(invocation_path_tail(p_sh, NULL), &quot;powershell&quot;,</a>
<a name="ln1397">                            10) == 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">  size_t len = strlen(cmd) + 1;  // At least enough space for cmd + NULL.</a>
<a name="ln1400"> </a>
<a name="ln1401">  len += is_fish_shell ? sizeof(&quot;begin; &quot; &quot;; end&quot;) - 1</a>
<a name="ln1402">                       : !is_pwsh ? sizeof(&quot;(&quot; &quot;)&quot;) - 1</a>
<a name="ln1403">                                  : 0;</a>
<a name="ln1404"> </a>
<a name="ln1405">  if (itmp != NULL) {</a>
<a name="ln1406">    len += is_pwsh ? strlen(itmp) + sizeof(&quot;&amp; { Get-Content &quot; &quot; | &amp; &quot; &quot; }&quot;) - 1 + 6  // +6: #20530</a>
<a name="ln1407">                    : strlen(itmp) + sizeof(&quot; { &quot; &quot; &lt; &quot; &quot; } &quot;) - 1;</a>
<a name="ln1408">  }</a>
<a name="ln1409">  if (otmp != NULL) {</a>
<a name="ln1410">    len += strlen(otmp) + strlen(p_srr) + 2;  // two extra spaces (&quot;  &quot;),</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  char *const buf = xmalloc(len);</a>
<a name="ln1414"> </a>
<a name="ln1415">  if (is_pwsh) {</a>
<a name="ln1416">    if (itmp != NULL) {</a>
<a name="ln1417">      xstrlcpy(buf, &quot;&amp; { Get-Content &quot;, len - 1);  // FIXME: should we add &quot;-Encoding utf8&quot;?</a>
<a name="ln1418">      xstrlcat(buf, itmp, len - 1);</a>
<a name="ln1419">      xstrlcat(buf, &quot; | &amp; &quot;, len - 1);  // FIXME: add `&amp;` ourself or leave to user?</a>
<a name="ln1420">      xstrlcat(buf, cmd, len - 1);</a>
<a name="ln1421">      xstrlcat(buf, &quot; }&quot;, len - 1);</a>
<a name="ln1422">    } else {</a>
<a name="ln1423">      xstrlcpy(buf, cmd, len - 1);</a>
<a name="ln1424">    }</a>
<a name="ln1425">  } else {</a>
<a name="ln1426">#if defined(UNIX)</a>
<a name="ln1427">    // Put delimiters around the command (for concatenated commands) when</a>
<a name="ln1428">    // redirecting input and/or output.</a>
<a name="ln1429">    if (itmp != NULL || otmp != NULL) {</a>
<a name="ln1430">      char *fmt = is_fish_shell ? &quot;begin; %s; end&quot;</a>
<a name="ln1431">        : &quot;(%s)&quot;;</a>
<a name="ln1432">      vim_snprintf(buf, len, fmt, cmd);</a>
<a name="ln1433">    } else {</a>
<a name="ln1434">      xstrlcpy(buf, cmd, len);</a>
<a name="ln1435">    }</a>
<a name="ln1436"> </a>
<a name="ln1437">    if (itmp != NULL) {</a>
<a name="ln1438">      xstrlcat(buf, &quot; &lt; &quot;, len - 1);</a>
<a name="ln1439">      xstrlcat(buf, itmp, len - 1);</a>
<a name="ln1440">    }</a>
<a name="ln1441">#else</a>
<a name="ln1442">    // For shells that don't understand braces around commands, at least allow</a>
<a name="ln1443">    // the use of commands in a pipe.</a>
<a name="ln1444">    xstrlcpy(buf, cmd, len);</a>
<a name="ln1445">    if (itmp != NULL) {</a>
<a name="ln1446">      // If there is a pipe, we have to put the '&lt;' in front of it.</a>
<a name="ln1447">      // Don't do this when 'shellquote' is not empty, otherwise the</a>
<a name="ln1448">      // redirection would be inside the quotes.</a>
<a name="ln1449">      if (*p_shq == NUL) {</a>
<a name="ln1450">        char *const p = find_pipe(buf);</a>
<a name="ln1451">        if (p != NULL) {</a>
<a name="ln1452">          *p = NUL;</a>
<a name="ln1453">        }</a>
<a name="ln1454">      }</a>
<a name="ln1455">      xstrlcat(buf, &quot; &lt; &quot;, len);</a>
<a name="ln1456">      xstrlcat(buf, itmp, len);</a>
<a name="ln1457">      if (*p_shq == NUL) {</a>
<a name="ln1458">        const char *const p = find_pipe(cmd);</a>
<a name="ln1459">        if (p != NULL) {</a>
<a name="ln1460">          xstrlcat(buf, &quot; &quot;, len - 1);  // Insert a space before the '|' for DOS</a>
<a name="ln1461">          xstrlcat(buf, p, len - 1);</a>
<a name="ln1462">        }</a>
<a name="ln1463">      }</a>
<a name="ln1464">    }</a>
<a name="ln1465">#endif</a>
<a name="ln1466">  }</a>
<a name="ln1467">  if (otmp != NULL) {</a>
<a name="ln1468">    append_redir(buf, len, p_srr, otmp);</a>
<a name="ln1469">  }</a>
<a name="ln1470">  return buf;</a>
<a name="ln1471">}</a>
<a name="ln1472"> </a>
<a name="ln1473">/// Append output redirection for the given file to the end of the buffer</a>
<a name="ln1474">///</a>
<a name="ln1475">/// @param[out]  buf  Buffer to append to.</a>
<a name="ln1476">/// @param[in]  buflen  Buffer length.</a>
<a name="ln1477">/// @param[in]  opt  Separator or format string to append: will append</a>
<a name="ln1478">///                  `printf(' ' . opt, fname)` if `%s` is found in `opt` or</a>
<a name="ln1479">///                  a space, opt, a space and then fname if `%s` is not found</a>
<a name="ln1480">///                  there.</a>
<a name="ln1481">/// @param[in]  fname  File name to append.</a>
<a name="ln1482">void append_redir(char *const buf, const size_t buflen, const char *const opt,</a>
<a name="ln1483">                  const char *const fname)</a>
<a name="ln1484">{</a>
<a name="ln1485">  char *const end = buf + strlen(buf);</a>
<a name="ln1486">  // find &quot;%s&quot;</a>
<a name="ln1487">  const char *p = opt;</a>
<a name="ln1488">  for (; (p = strchr(p, '%')) != NULL; p++) {</a>
<a name="ln1489">    if (p[1] == 's') {  // found %s</a>
<a name="ln1490">      break;</a>
<a name="ln1491">    } else if (p[1] == '%') {  // skip %%</a>
<a name="ln1492">      p++;</a>
<a name="ln1493">    }</a>
<a name="ln1494">  }</a>
<a name="ln1495">  if (p != NULL) {</a>
<a name="ln1496">    *end = ' ';  // not really needed? Not with sh, ksh or bash</a>
<a name="ln1497">    vim_snprintf(end + 1, (size_t)((ptrdiff_t)buflen - (end + 1 - buf)), opt, fname);</a>
<a name="ln1498">  } else {</a>
<a name="ln1499">    vim_snprintf(end, (size_t)((ptrdiff_t)buflen - (end - buf)), &quot; %s %s&quot;, opt, fname);</a>
<a name="ln1500">  }</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">void print_line_no_prefix(linenr_T lnum, int use_number, int list)</a>
<a name="ln1504">{</a>
<a name="ln1505">  char numbuf[30];</a>
<a name="ln1506"> </a>
<a name="ln1507">  if (curwin-&gt;w_p_nu || use_number) {</a>
<a name="ln1508">    vim_snprintf(numbuf, sizeof(numbuf), &quot;%*&quot; PRIdLINENR &quot; &quot;,</a>
<a name="ln1509">                 number_width(curwin), lnum);</a>
<a name="ln1510">    msg_puts_attr(numbuf, HL_ATTR(HLF_N));  // Highlight line nrs.</a>
<a name="ln1511">  }</a>
<a name="ln1512">  msg_prt_line(ml_get(lnum), list);</a>
<a name="ln1513">}</a>
<a name="ln1514"> </a>
<a name="ln1515">/// Print a text line.  Also in silent mode (&quot;ex -s&quot;).</a>
<a name="ln1516">void print_line(linenr_T lnum, int use_number, int list)</a>
<a name="ln1517">{</a>
<a name="ln1518">  int save_silent = silent_mode;</a>
<a name="ln1519"> </a>
<a name="ln1520">  // apply :filter /pat/</a>
<a name="ln1521">  if (message_filtered(ml_get(lnum))) {</a>
<a name="ln1522">    return;</a>
<a name="ln1523">  }</a>
<a name="ln1524"> </a>
<a name="ln1525">  msg_start();</a>
<a name="ln1526">  silent_mode = false;</a>
<a name="ln1527">  info_message = true;  // use os_msg(), not os_errmsg()</a>
<a name="ln1528">  print_line_no_prefix(lnum, use_number, list);</a>
<a name="ln1529">  if (save_silent) {</a>
<a name="ln1530">    msg_putchar('\n');</a>
<a name="ln1531">    silent_mode = save_silent;</a>
<a name="ln1532">  }</a>
<a name="ln1533">  info_message = false;</a>
<a name="ln1534">}</a>
<a name="ln1535"> </a>
<a name="ln1536">int rename_buffer(char *new_fname)</a>
<a name="ln1537">{</a>
<a name="ln1538">  char *fname, *sfname, *xfname;</a>
<a name="ln1539">  buf_T *buf;</a>
<a name="ln1540"> </a>
<a name="ln1541">  buf = curbuf;</a>
<a name="ln1542">  apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, curbuf);</a>
<a name="ln1543">  // buffer changed, don't change name now</a>
<a name="ln1544">  if (buf != curbuf) {</a>
<a name="ln1545">    return FAIL;</a>
<a name="ln1546">  }</a>
<a name="ln1547">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln1548">    return FAIL;</a>
<a name="ln1549">  }</a>
<a name="ln1550">  // The name of the current buffer will be changed.</a>
<a name="ln1551">  // A new (unlisted) buffer entry needs to be made to hold the old file</a>
<a name="ln1552">  // name, which will become the alternate file name.</a>
<a name="ln1553">  // But don't set the alternate file name if the buffer didn't have a</a>
<a name="ln1554">  // name.</a>
<a name="ln1555">  fname = curbuf-&gt;b_ffname;</a>
<a name="ln1556">  sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1557">  xfname = curbuf-&gt;b_fname;</a>
<a name="ln1558">  curbuf-&gt;b_ffname = NULL;</a>
<a name="ln1559">  curbuf-&gt;b_sfname = NULL;</a>
<a name="ln1560">  if (setfname(curbuf, new_fname, NULL, true) == FAIL) {</a>
<a name="ln1561">    curbuf-&gt;b_ffname = fname;</a>
<a name="ln1562">    curbuf-&gt;b_sfname = sfname;</a>
<a name="ln1563">    return FAIL;</a>
<a name="ln1564">  }</a>
<a name="ln1565">  curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln1566">  if (xfname != NULL &amp;&amp; *xfname != NUL) {</a>
<a name="ln1567">    buf = buflist_new(fname, xfname, curwin-&gt;w_cursor.lnum, 0);</a>
<a name="ln1568">    if (buf != NULL &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln1569">      curwin-&gt;w_alt_fnum = buf-&gt;b_fnum;</a>
<a name="ln1570">    }</a>
<a name="ln1571">  }</a>
<a name="ln1572">  xfree(fname);</a>
<a name="ln1573">  xfree(sfname);</a>
<a name="ln1574">  apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1575">  // Change directories when the 'acd' option is set.</a>
<a name="ln1576">  do_autochdir();</a>
<a name="ln1577">  return OK;</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580">/// &quot;:file[!] [fname]&quot;.</a>
<a name="ln1581">void ex_file(exarg_T *eap)</a>
<a name="ln1582">{</a>
<a name="ln1583">  // &quot;:0file&quot; removes the file name.  Check for illegal uses &quot;:3file&quot;,</a>
<a name="ln1584">  // &quot;0file name&quot;, etc.</a>
<a name="ln1585">  if (eap-&gt;addr_count &gt; 0</a>
<a name="ln1586">      &amp;&amp; (*eap-&gt;arg != NUL</a>
<a name="ln1587">          || eap-&gt;line2 &gt; 0</a>
<a name="ln1588">          || eap-&gt;addr_count &gt; 1)) {</a>
<a name="ln1589">    emsg(_(e_invarg));</a>
<a name="ln1590">    return;</a>
<a name="ln1591">  }</a>
<a name="ln1592"> </a>
<a name="ln1593">  if (*eap-&gt;arg != NUL || eap-&gt;addr_count == 1) {</a>
<a name="ln1594">    if (rename_buffer(eap-&gt;arg) == FAIL) {</a>
<a name="ln1595">      return;</a>
<a name="ln1596">    }</a>
<a name="ln1597">    redraw_tabline = true;</a>
<a name="ln1598">  }</a>
<a name="ln1599"> </a>
<a name="ln1600">  // print file name if no argument or 'F' is not in 'shortmess'</a>
<a name="ln1601">  if (*eap-&gt;arg == NUL || !shortmess(SHM_FILEINFO)) {</a>
<a name="ln1602">    fileinfo(false, false, eap-&gt;forceit);</a>
<a name="ln1603">  }</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">/// &quot;:update&quot;.</a>
<a name="ln1607">void ex_update(exarg_T *eap)</a>
<a name="ln1608">{</a>
<a name="ln1609">  if (curbufIsChanged()) {</a>
<a name="ln1610">    (void)do_write(eap);</a>
<a name="ln1611">  }</a>
<a name="ln1612">}</a>
<a name="ln1613"> </a>
<a name="ln1614">/// &quot;:write&quot; and &quot;:saveas&quot;.</a>
<a name="ln1615">void ex_write(exarg_T *eap)</a>
<a name="ln1616">{</a>
<a name="ln1617">  if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1618">    // :saveas does not take a range, uses all lines.</a>
<a name="ln1619">    eap-&gt;line1 = 1;</a>
<a name="ln1620">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  if (eap-&gt;usefilter) {  // input lines to shell command</a>
<a name="ln1624">    do_bang(1, eap, false, true, false);</a>
<a name="ln1625">  } else {</a>
<a name="ln1626">    (void)do_write(eap);</a>
<a name="ln1627">  }</a>
<a name="ln1628">}</a>
<a name="ln1629"> </a>
<a name="ln1630">#ifdef UNIX</a>
<a name="ln1631">static int check_writable(const char *fname)</a>
<a name="ln1632">{</a>
<a name="ln1633">  if (os_nodetype(fname) == NODE_OTHER) {</a>
<a name="ln1634">    semsg(_(&quot;E503: \&quot;%s\&quot; is not a file or writable device&quot;), fname);</a>
<a name="ln1635">    return FAIL;</a>
<a name="ln1636">  }</a>
<a name="ln1637">  return OK;</a>
<a name="ln1638">}</a>
<a name="ln1639">#endif</a>
<a name="ln1640"> </a>
<a name="ln1641">/// Write current buffer to file &quot;eap-&gt;arg&quot;.</a>
<a name="ln1642">/// If &quot;eap-&gt;append&quot; is true, append to the file.</a>
<a name="ln1643">///</a>
<a name="ln1644">/// If &quot;*eap-&gt;arg == NUL&quot; write to current file.</a>
<a name="ln1645">///</a>
<a name="ln1646">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln1647">int do_write(exarg_T *eap)</a>
<a name="ln1648">{</a>
<a name="ln1649">  int other;</a>
<a name="ln1650">  char *fname = NULL;            // init to shut up gcc</a>
<a name="ln1651">  char *ffname;</a>
<a name="ln1652">  int retval = FAIL;</a>
<a name="ln1653">  char *free_fname = NULL;</a>
<a name="ln1654">  buf_T *alt_buf = NULL;</a>
<a name="ln1655">  int name_was_missing;</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (not_writing()) {          // check 'write' option</a>
<a name="ln1658">    return FAIL;</a>
<a name="ln1659">  }</a>
<a name="ln1660"> </a>
<a name="ln1661">  ffname = eap-&gt;arg;</a>
<a name="ln1662">  if (*ffname == NUL) {</a>
<a name="ln1663">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1664">      emsg(_(e_argreq));</a>
<a name="ln1665">      goto theend;</a>
<a name="ln1666">    }</a>
<a name="ln1667">    other = false;</a>
<a name="ln1668">  } else {</a>
<a name="ln1669">    fname = ffname;</a>
<a name="ln1670">    free_fname = fix_fname(ffname);</a>
<a name="ln1671">    // When out-of-memory, keep unexpanded file name, because we MUST be</a>
<a name="ln1672">    // able to write the file in this situation.</a>
<a name="ln1673">    if (free_fname != NULL) {</a>
<a name="ln1674">      ffname = free_fname;</a>
<a name="ln1675">    }</a>
<a name="ln1676">    other = otherfile(ffname);</a>
<a name="ln1677">  }</a>
<a name="ln1678"> </a>
<a name="ln1679">  // If we have a new file, put its name in the list of alternate file names.</a>
<a name="ln1680">  if (other) {</a>
<a name="ln1681">    if (vim_strchr(p_cpo, CPO_ALTWRITE) != NULL</a>
<a name="ln1682">        || eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1683">      alt_buf = setaltfname(ffname, fname, (linenr_T)1);</a>
<a name="ln1684">    } else {</a>
<a name="ln1685">      alt_buf = buflist_findname(ffname);</a>
<a name="ln1686">    }</a>
<a name="ln1687">    if (alt_buf != NULL &amp;&amp; alt_buf-&gt;b_ml.ml_mfp != NULL) {</a>
<a name="ln1688">      // Overwriting a file that is loaded in another buffer is not a</a>
<a name="ln1689">      // good idea.</a>
<a name="ln1690">      emsg(_(e_bufloaded));</a>
<a name="ln1691">      goto theend;</a>
<a name="ln1692">    }</a>
<a name="ln1693">  }</a>
<a name="ln1694"> </a>
<a name="ln1695">  // Writing to the current file is not allowed in readonly mode</a>
<a name="ln1696">  // and a file name is required.</a>
<a name="ln1697">  // &quot;nofile&quot; and &quot;nowrite&quot; buffers cannot be written implicitly either.</a>
<a name="ln1698">  if (!other &amp;&amp; (bt_dontwrite_msg(curbuf)</a>
<a name="ln1699">                 || check_fname() == FAIL</a>
<a name="ln1700">#ifdef UNIX</a>
<a name="ln1701">                 || check_writable(curbuf-&gt;b_ffname) == FAIL</a>
<a name="ln1702">#endif</a>
<a name="ln1703">                 || check_readonly(&amp;eap-&gt;forceit, curbuf))) {</a>
<a name="ln1704">    goto theend;</a>
<a name="ln1705">  }</a>
<a name="ln1706"> </a>
<a name="ln1707">  if (!other) {</a>
<a name="ln1708">    ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1709">    fname = curbuf-&gt;b_fname;</a>
<a name="ln1710">    // Not writing the whole file is only allowed with '!'.</a>
<a name="ln1711">    if ((eap-&gt;line1 != 1</a>
<a name="ln1712">         || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)</a>
<a name="ln1713">        &amp;&amp; !eap-&gt;forceit</a>
<a name="ln1714">        &amp;&amp; !eap-&gt;append</a>
<a name="ln1715">        &amp;&amp; !p_wa) {</a>
<a name="ln1716">      if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1717">        if (vim_dialog_yesno(VIM_QUESTION, NULL,</a>
<a name="ln1718">                             _(&quot;Write partial file?&quot;), 2) != VIM_YES) {</a>
<a name="ln1719">          goto theend;</a>
<a name="ln1720">        }</a>
<a name="ln1721">        eap-&gt;forceit = true;</a>
<a name="ln1722">      } else {</a>
<a name="ln1723">        emsg(_(&quot;E140: Use ! to write partial buffer&quot;));</a>
<a name="ln1724">        goto theend;</a>
<a name="ln1725">      }</a>
<a name="ln1726">    }</a>
<a name="ln1727">  }</a>
<a name="ln1728"> </a>
<a name="ln1729">  if (check_overwrite(eap, curbuf, fname, ffname, other) == OK) {</a>
<a name="ln1730">    if (eap-&gt;cmdidx == CMD_saveas &amp;&amp; alt_buf != NULL) {</a>
<a name="ln1731">      buf_T *was_curbuf = curbuf;</a>
<a name="ln1732"> </a>
<a name="ln1733">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, curbuf);</a>
<a name="ln1734">      apply_autocmds(EVENT_BUFFILEPRE, NULL, NULL, false, alt_buf);</a>
<a name="ln1735">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1736">        // buffer changed, don't change name now</a>
<a name="ln1737">        retval = FAIL;</a>
<a name="ln1738">        goto theend;</a>
<a name="ln1739">      }</a>
<a name="ln1740">      // Exchange the file names for the current and the alternate</a>
<a name="ln1741">      // buffer.  This makes it look like we are now editing the buffer</a>
<a name="ln1742">      // under the new name.  Must be done before buf_write(), because</a>
<a name="ln1743">      // if there is no file name and 'cpo' contains 'F', it will set</a>
<a name="ln1744">      // the file name.</a>
<a name="ln1745">      fname = alt_buf-&gt;b_fname;</a>
<a name="ln1746">      alt_buf-&gt;b_fname = curbuf-&gt;b_fname;</a>
<a name="ln1747">      curbuf-&gt;b_fname = fname;</a>
<a name="ln1748">      fname = alt_buf-&gt;b_ffname;</a>
<a name="ln1749">      alt_buf-&gt;b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln1750">      curbuf-&gt;b_ffname = fname;</a>
<a name="ln1751">      fname = alt_buf-&gt;b_sfname;</a>
<a name="ln1752">      alt_buf-&gt;b_sfname = curbuf-&gt;b_sfname;</a>
<a name="ln1753">      curbuf-&gt;b_sfname = fname;</a>
<a name="ln1754">      buf_name_changed(curbuf);</a>
<a name="ln1755">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, curbuf);</a>
<a name="ln1756">      apply_autocmds(EVENT_BUFFILEPOST, NULL, NULL, false, alt_buf);</a>
<a name="ln1757">      if (!alt_buf-&gt;b_p_bl) {</a>
<a name="ln1758">        alt_buf-&gt;b_p_bl = true;</a>
<a name="ln1759">        apply_autocmds(EVENT_BUFADD, NULL, NULL, false, alt_buf);</a>
<a name="ln1760">      }</a>
<a name="ln1761">      if (curbuf != was_curbuf || aborting()) {</a>
<a name="ln1762">        // buffer changed, don't write the file</a>
<a name="ln1763">        retval = FAIL;</a>
<a name="ln1764">        goto theend;</a>
<a name="ln1765">      }</a>
<a name="ln1766"> </a>
<a name="ln1767">      // If 'filetype' was empty try detecting it now.</a>
<a name="ln1768">      if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln1769">        if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln1770">          (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln1771">        }</a>
<a name="ln1772">        do_modelines(0);</a>
<a name="ln1773">      }</a>
<a name="ln1774"> </a>
<a name="ln1775">      // Autocommands may have changed buffer names, esp. when</a>
<a name="ln1776">      // 'autochdir' is set.</a>
<a name="ln1777">      fname = curbuf-&gt;b_sfname;</a>
<a name="ln1778">    }</a>
<a name="ln1779"> </a>
<a name="ln1780">    if (eap-&gt;mkdir_p) {</a>
<a name="ln1781">      if (os_file_mkdir(fname, 0755) &lt; 0) {</a>
<a name="ln1782">        retval = FAIL;</a>
<a name="ln1783">        goto theend;</a>
<a name="ln1784">      }</a>
<a name="ln1785">    }</a>
<a name="ln1786"> </a>
<a name="ln1787">    name_was_missing = curbuf-&gt;b_ffname == NULL;</a>
<a name="ln1788">    retval = buf_write(curbuf, ffname, fname, eap-&gt;line1, eap-&gt;line2,</a>
<a name="ln1789">                       eap, eap-&gt;append, eap-&gt;forceit, true, false);</a>
<a name="ln1790"> </a>
<a name="ln1791">    // After &quot;:saveas fname&quot; reset 'readonly'.</a>
<a name="ln1792">    if (eap-&gt;cmdidx == CMD_saveas) {</a>
<a name="ln1793">      if (retval == OK) {</a>
<a name="ln1794">        curbuf-&gt;b_p_ro = false;</a>
<a name="ln1795">        redraw_tabline = true;</a>
<a name="ln1796">      }</a>
<a name="ln1797">    }</a>
<a name="ln1798"> </a>
<a name="ln1799">    // Change directories when the 'acd' option is set and the file name</a>
<a name="ln1800">    // got changed or set.</a>
<a name="ln1801">    if (eap-&gt;cmdidx == CMD_saveas || name_was_missing) {</a>
<a name="ln1802">      do_autochdir();</a>
<a name="ln1803">    }</a>
<a name="ln1804">  }</a>
<a name="ln1805"> </a>
<a name="ln1806">theend:</a>
<a name="ln1807">  xfree(free_fname);</a>
<a name="ln1808">  return retval;</a>
<a name="ln1809">}</a>
<a name="ln1810"> </a>
<a name="ln1811">/// Check if it is allowed to overwrite a file.  If b_flags has BF_NOTEDITED,</a>
<a name="ln1812">/// BF_NEW or BF_READERR, check for overwriting current file.</a>
<a name="ln1813">/// May set eap-&gt;forceit if a dialog says it's OK to overwrite.</a>
<a name="ln1814">///</a>
<a name="ln1815">/// @param fname   file name to be used (can differ from buf-&gt;ffname)</a>
<a name="ln1816">/// @param ffname  full path version of fname</a>
<a name="ln1817">/// @param other   writing under other name</a>
<a name="ln1818">///</a>
<a name="ln1819">/// @return  OK if it's OK, FAIL if it is not.</a>
<a name="ln1820">int check_overwrite(exarg_T *eap, buf_T *buf, char *fname, char *ffname, int other)</a>
<a name="ln1821">{</a>
<a name="ln1822">  // Write to another file or b_flags set or not writing the whole file:</a>
<a name="ln1823">  // overwriting only allowed with '!'</a>
<a name="ln1824">  // If &quot;other&quot; is false and bt_nofilename(buf) is true, this must be</a>
<a name="ln1825">  // writing an &quot;acwrite&quot; buffer to the same file as its b_ffname, and</a>
<a name="ln1826">  // buf_write() will only allow writing with BufWriteCmd autocommands,</a>
<a name="ln1827">  // so there is no need for an overwrite check.</a>
<a name="ln1828">  if ((other</a>
<a name="ln1829">       || (!bt_nofilename(buf)</a>
<a name="ln1830">           &amp;&amp; ((buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln1831">               || ((buf-&gt;b_flags &amp; BF_NEW)</a>
<a name="ln1832">                   &amp;&amp; vim_strchr(p_cpo, CPO_OVERNEW) == NULL)</a>
<a name="ln1833">               || (buf-&gt;b_flags &amp; BF_READERR))))</a>
<a name="ln1834">      &amp;&amp; !p_wa</a>
<a name="ln1835">      &amp;&amp; os_path_exists(ffname)) {</a>
<a name="ln1836">    if (!eap-&gt;forceit &amp;&amp; !eap-&gt;append) {</a>
<a name="ln1837">#ifdef UNIX</a>
<a name="ln1838">      // It is possible to open a directory on Unix.</a>
<a name="ln1839">      if (os_isdir(ffname)) {</a>
<a name="ln1840">        semsg(_(e_isadir2), ffname);</a>
<a name="ln1841">        return FAIL;</a>
<a name="ln1842">      }</a>
<a name="ln1843">#endif</a>
<a name="ln1844">      if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1845">        char buff[DIALOG_MSG_SIZE];</a>
<a name="ln1846"> </a>
<a name="ln1847">        dialog_msg(buff, _(&quot;Overwrite existing file \&quot;%s\&quot;?&quot;), fname);</a>
<a name="ln1848">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES) {</a>
<a name="ln1849">          return FAIL;</a>
<a name="ln1850">        }</a>
<a name="ln1851">        eap-&gt;forceit = true;</a>
<a name="ln1852">      } else {</a>
<a name="ln1853">        emsg(_(e_exists));</a>
<a name="ln1854">        return FAIL;</a>
<a name="ln1855">      }</a>
<a name="ln1856">    }</a>
<a name="ln1857"> </a>
<a name="ln1858">    // For &quot;:w! filename&quot; check that no swap file exists for &quot;filename&quot;.</a>
<a name="ln1859">    if (other &amp;&amp; !emsg_silent) {</a>
<a name="ln1860">      char *dir;</a>
<a name="ln1861">      char *p;</a>
<a name="ln1862">      char *swapname;</a>
<a name="ln1863"> </a>
<a name="ln1864">      // We only try the first entry in 'directory', without checking if</a>
<a name="ln1865">      // it's writable.  If the &quot;.&quot; directory is not writable the write</a>
<a name="ln1866">      // will probably fail anyway.</a>
<a name="ln1867">      // Use 'shortname' of the current buffer, since there is no buffer</a>
<a name="ln1868">      // for the written file.</a>
<a name="ln1869">      if (*p_dir == NUL) {</a>
<a name="ln1870">        dir = xmalloc(5);</a>
<a name="ln1871">        STRCPY(dir, &quot;.&quot;);</a>
<a name="ln1872">      } else {</a>
<a name="ln1873">        dir = xmalloc(MAXPATHL);</a>
<a name="ln1874">        p = p_dir;</a>
<a name="ln1875">        copy_option_part(&amp;p, dir, MAXPATHL, &quot;,&quot;);</a>
<a name="ln1876">      }</a>
<a name="ln1877">      swapname = makeswapname(fname, ffname, curbuf, dir);</a>
<a name="ln1878">      xfree(dir);</a>
<a name="ln1879">      if (os_path_exists(swapname)) {</a>
<a name="ln1880">        if (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) {</a>
<a name="ln1881">          char buff[DIALOG_MSG_SIZE];</a>
<a name="ln1882"> </a>
<a name="ln1883">          dialog_msg(buff,</a>
<a name="ln1884">                     _(&quot;Swap file \&quot;%s\&quot; exists, overwrite anyway?&quot;),</a>
<a name="ln1885">                     swapname);</a>
<a name="ln1886">          if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2)</a>
<a name="ln1887">              != VIM_YES) {</a>
<a name="ln1888">            xfree(swapname);</a>
<a name="ln1889">            return FAIL;</a>
<a name="ln1890">          }</a>
<a name="ln1891">          eap-&gt;forceit = true;</a>
<a name="ln1892">        } else {</a>
<a name="ln1893">          semsg(_(&quot;E768: Swap file exists: %s (:silent! overrides)&quot;),</a>
<a name="ln1894">                swapname);</a>
<a name="ln1895">          xfree(swapname);</a>
<a name="ln1896">          return FAIL;</a>
<a name="ln1897">        }</a>
<a name="ln1898">      }</a>
<a name="ln1899">      xfree(swapname);</a>
<a name="ln1900">    }</a>
<a name="ln1901">  }</a>
<a name="ln1902">  return OK;</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">/// Handle &quot;:wnext&quot;, &quot;:wNext&quot; and &quot;:wprevious&quot; commands.</a>
<a name="ln1906">void ex_wnext(exarg_T *eap)</a>
<a name="ln1907">{</a>
<a name="ln1908">  int i;</a>
<a name="ln1909"> </a>
<a name="ln1910">  if (eap-&gt;cmd[1] == 'n') {</a>
<a name="ln1911">    i = curwin-&gt;w_arg_idx + (int)eap-&gt;line2;</a>
<a name="ln1912">  } else {</a>
<a name="ln1913">    i = curwin-&gt;w_arg_idx - (int)eap-&gt;line2;</a>
<a name="ln1914">  }</a>
<a name="ln1915">  eap-&gt;line1 = 1;</a>
<a name="ln1916">  eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1917">  if (do_write(eap) != FAIL) {</a>
<a name="ln1918">    do_argfile(eap, i);</a>
<a name="ln1919">  }</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922">/// &quot;:wall&quot;, &quot;:wqall&quot; and &quot;:xall&quot;: Write all changed files (and exit).</a>
<a name="ln1923">void do_wqall(exarg_T *eap)</a>
<a name="ln1924">{</a>
<a name="ln1925">  int error = 0;</a>
<a name="ln1926">  int save_forceit = eap-&gt;forceit;</a>
<a name="ln1927"> </a>
<a name="ln1928">  if (eap-&gt;cmdidx == CMD_xall || eap-&gt;cmdidx == CMD_wqall) {</a>
<a name="ln1929">    if (before_quit_all(eap) == FAIL) {</a>
<a name="ln1930">      return;</a>
<a name="ln1931">    }</a>
<a name="ln1932">    exiting = true;</a>
<a name="ln1933">  }</a>
<a name="ln1934"> </a>
<a name="ln1935">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln1936">    if (exiting</a>
<a name="ln1937">        &amp;&amp; buf-&gt;terminal</a>
<a name="ln1938">        &amp;&amp; channel_job_running((uint64_t)buf-&gt;b_p_channel)) {</a>
<a name="ln1939">      no_write_message_nobang(buf);</a>
<a name="ln1940">      error++;</a>
<a name="ln1941">    } else if (!bufIsChanged(buf) || bt_dontwrite(buf)) {</a>
<a name="ln1942">      continue;</a>
<a name="ln1943">    }</a>
<a name="ln1944">    // Check if there is a reason the buffer cannot be written:</a>
<a name="ln1945">    // 1. if the 'write' option is set</a>
<a name="ln1946">    // 2. if there is no file name (even after browsing)</a>
<a name="ln1947">    // 3. if the 'readonly' is set (even after a dialog)</a>
<a name="ln1948">    // 4. if overwriting is allowed (even after a dialog)</a>
<a name="ln1949">    if (not_writing()) {</a>
<a name="ln1950">      error++;</a>
<a name="ln1951">      break;</a>
<a name="ln1952">    }</a>
<a name="ln1953">    if (buf-&gt;b_ffname == NULL) {</a>
<a name="ln1954">      semsg(_(&quot;E141: No file name for buffer %&quot; PRId64), (int64_t)buf-&gt;b_fnum);</a>
<a name="ln1955">      error++;</a>
<a name="ln1956">    } else if (check_readonly(&amp;eap-&gt;forceit, buf)</a>
<a name="ln1957">               || check_overwrite(eap, buf, buf-&gt;b_fname, buf-&gt;b_ffname, false) == FAIL) {</a>
<a name="ln1958">      error++;</a>
<a name="ln1959">    } else {</a>
<a name="ln1960">      bufref_T bufref;</a>
<a name="ln1961">      set_bufref(&amp;bufref, buf);</a>
<a name="ln1962">      if (buf_write_all(buf, eap-&gt;forceit) == FAIL) {</a>
<a name="ln1963">        error++;</a>
<a name="ln1964">      }</a>
<a name="ln1965">      // An autocommand may have deleted the buffer.</a>
<a name="ln1966">      if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln1967">        buf = firstbuf;</a>
<a name="ln1968">      }</a>
<a name="ln1969">    }</a>
<a name="ln1970">    eap-&gt;forceit = save_forceit;          // check_overwrite() may set it</a>
<a name="ln1971">  }</a>
<a name="ln1972">  if (exiting) {</a>
<a name="ln1973">    if (!error) {</a>
<a name="ln1974">      getout(0);                // exit Vim</a>
<a name="ln1975">    }</a>
<a name="ln1976">    not_exiting();</a>
<a name="ln1977">  }</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">/// Check the 'write' option.</a>
<a name="ln1981">///</a>
<a name="ln1982">/// @return  true and give a message when it's not st.</a>
<a name="ln1983">bool not_writing(void)</a>
<a name="ln1984">{</a>
<a name="ln1985">  if (p_write) {</a>
<a name="ln1986">    return false;</a>
<a name="ln1987">  }</a>
<a name="ln1988">  emsg(_(&quot;E142: File not written: Writing is disabled by 'write' option&quot;));</a>
<a name="ln1989">  return true;</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">/// Check if a buffer is read-only (either 'readonly' option is set or file is</a>
<a name="ln1993">/// read-only). Ask for overruling in a dialog. Return true and give an error</a>
<a name="ln1994">/// message when the buffer is readonly.</a>
<a name="ln1995">static int check_readonly(int *forceit, buf_T *buf)</a>
<a name="ln1996">{</a>
<a name="ln1997">  // Handle a file being readonly when the 'readonly' option is set or when</a>
<a name="ln1998">  // the file exists and permissions are read-only.</a>
<a name="ln1999">  if (!*forceit &amp;&amp; (buf-&gt;b_p_ro</a>
<a name="ln2000">                    || (os_path_exists(buf-&gt;b_ffname)</a>
<a name="ln2001">                        &amp;&amp; !os_file_is_writable(buf-&gt;b_ffname)))) {</a>
<a name="ln2002">    if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; buf-&gt;b_fname != NULL) {</a>
<a name="ln2003">      char buff[DIALOG_MSG_SIZE];</a>
<a name="ln2004"> </a>
<a name="ln2005">      if (buf-&gt;b_p_ro) {</a>
<a name="ln2006">        dialog_msg(buff,</a>
<a name="ln2007">                   _(&quot;'readonly' option is set for \&quot;%s\&quot;.\nDo you wish to write anyway?&quot;),</a>
<a name="ln2008">                   buf-&gt;b_fname);</a>
<a name="ln2009">      } else {</a>
<a name="ln2010">        dialog_msg(buff,</a>
<a name="ln2011">                   _(&quot;File permissions of \&quot;%s\&quot; are read-only.\nIt may still be possible to &quot;</a>
<a name="ln2012">                     &quot;write it.\nDo you wish to try?&quot;),</a>
<a name="ln2013">                   buf-&gt;b_fname);</a>
<a name="ln2014">      }</a>
<a name="ln2015"> </a>
<a name="ln2016">      if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) == VIM_YES) {</a>
<a name="ln2017">        // Set forceit, to force the writing of a readonly file</a>
<a name="ln2018">        *forceit = true;</a>
<a name="ln2019">        return false;</a>
<a name="ln2020">      }</a>
<a name="ln2021">      return true;</a>
<a name="ln2022">    } else if (buf-&gt;b_p_ro) {</a>
<a name="ln2023">      emsg(_(e_readonly));</a>
<a name="ln2024">    } else {</a>
<a name="ln2025">      semsg(_(&quot;E505: \&quot;%s\&quot; is read-only (add ! to override)&quot;),</a>
<a name="ln2026">            buf-&gt;b_fname);</a>
<a name="ln2027">    }</a>
<a name="ln2028">    return true;</a>
<a name="ln2029">  }</a>
<a name="ln2030"> </a>
<a name="ln2031">  return false;</a>
<a name="ln2032">}</a>
<a name="ln2033"> </a>
<a name="ln2034">/// Try to abandon the current file and edit a new or existing file.</a>
<a name="ln2035">///</a>
<a name="ln2036">/// @param fnum  the number of the file, if zero use &quot;ffname_arg&quot;/&quot;sfname_arg&quot;.</a>
<a name="ln2037">/// @param lnum  the line number for the cursor in the new file (if non-zero).</a>
<a name="ln2038">///</a>
<a name="ln2039">/// @return:</a>
<a name="ln2040">///           GETFILE_ERROR for &quot;normal&quot; error,</a>
<a name="ln2041">///           GETFILE_NOT_WRITTEN for &quot;not written&quot; error,</a>
<a name="ln2042">///           GETFILE_SAME_FILE for success</a>
<a name="ln2043">///           GETFILE_OPEN_OTHER for successfully opening another file.</a>
<a name="ln2044">int getfile(int fnum, char *ffname_arg, char *sfname_arg, int setpm, linenr_T lnum, int forceit)</a>
<a name="ln2045">{</a>
<a name="ln2046">  char *ffname = ffname_arg;</a>
<a name="ln2047">  char *sfname = sfname_arg;</a>
<a name="ln2048">  int other;</a>
<a name="ln2049">  int retval;</a>
<a name="ln2050">  char *free_me = NULL;</a>
<a name="ln2051"> </a>
<a name="ln2052">  if (text_locked()) {</a>
<a name="ln2053">    return GETFILE_ERROR;</a>
<a name="ln2054">  }</a>
<a name="ln2055">  if (curbuf_locked()) {</a>
<a name="ln2056">    return GETFILE_ERROR;</a>
<a name="ln2057">  }</a>
<a name="ln2058"> </a>
<a name="ln2059">  if (fnum == 0) {</a>
<a name="ln2060">    // make ffname full path, set sfname</a>
<a name="ln2061">    fname_expand(curbuf, &amp;ffname, &amp;sfname);</a>
<a name="ln2062">    other = otherfile(ffname);</a>
<a name="ln2063">    free_me = ffname;                   // has been allocated, free() later</a>
<a name="ln2064">  } else {</a>
<a name="ln2065">    other = (fnum != curbuf-&gt;b_fnum);</a>
<a name="ln2066">  }</a>
<a name="ln2067"> </a>
<a name="ln2068">  if (other) {</a>
<a name="ln2069">    no_wait_return++;               // don't wait for autowrite message</a>
<a name="ln2070">  }</a>
<a name="ln2071">  if (other &amp;&amp; !forceit &amp;&amp; curbuf-&gt;b_nwindows == 1 &amp;&amp; !buf_hide(curbuf)</a>
<a name="ln2072">      &amp;&amp; curbufIsChanged() &amp;&amp; autowrite(curbuf, forceit) == FAIL) {</a>
<a name="ln2073">    if (p_confirm &amp;&amp; p_write) {</a>
<a name="ln2074">      dialog_changed(curbuf, false);</a>
<a name="ln2075">    }</a>
<a name="ln2076">    if (curbufIsChanged()) {</a>
<a name="ln2077">      no_wait_return--;</a>
<a name="ln2078">      no_write_message();</a>
<a name="ln2079">      retval = GETFILE_NOT_WRITTEN;     // File has been changed.</a>
<a name="ln2080">      goto theend;</a>
<a name="ln2081">    }</a>
<a name="ln2082">  }</a>
<a name="ln2083">  if (other) {</a>
<a name="ln2084">    no_wait_return--;</a>
<a name="ln2085">  }</a>
<a name="ln2086">  if (setpm) {</a>
<a name="ln2087">    setpcmark();</a>
<a name="ln2088">  }</a>
<a name="ln2089">  if (!other) {</a>
<a name="ln2090">    if (lnum != 0) {</a>
<a name="ln2091">      curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2092">    }</a>
<a name="ln2093">    check_cursor_lnum(curwin);</a>
<a name="ln2094">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln2095">    retval = GETFILE_SAME_FILE;     // it's in the same file</a>
<a name="ln2096">  } else if (do_ecmd(fnum, ffname, sfname, NULL, lnum,</a>
<a name="ln2097">                     (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln2098">                     + (forceit ? ECMD_FORCEIT : 0), curwin) == OK) {</a>
<a name="ln2099">    retval = GETFILE_OPEN_OTHER;    // opened another file</a>
<a name="ln2100">  } else {</a>
<a name="ln2101">    retval = GETFILE_ERROR;         // error encountered</a>
<a name="ln2102">  }</a>
<a name="ln2103"> </a>
<a name="ln2104">theend:</a>
<a name="ln2105">  xfree(free_me);</a>
<a name="ln2106">  return retval;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">/// start editing a new file</a>
<a name="ln2110">///</a>
<a name="ln2111">/// @param fnum     file number; if zero use ffname/sfname</a>
<a name="ln2112">/// @param ffname   the file name</a>
<a name="ln2113">///                 - full path if sfname used,</a>
<a name="ln2114">///                 - any file name if sfname is NULL</a>
<a name="ln2115">///                 - empty string to re-edit with the same file name (but may</a>
<a name="ln2116">///                   be in a different directory)</a>
<a name="ln2117">///                 - NULL to start an empty buffer</a>
<a name="ln2118">/// @param sfname   the short file name (or NULL)</a>
<a name="ln2119">/// @param eap      contains the command to be executed after loading the file</a>
<a name="ln2120">///                 and forced 'ff' and 'fenc'. Can be NULL!</a>
<a name="ln2121">/// @param newlnum  if &gt; 0: put cursor on this line number (if possible)</a>
<a name="ln2122">///                 ECMD_LASTL: use last position in loaded file</a>
<a name="ln2123">///                 ECMD_LAST: use last position in all files</a>
<a name="ln2124">///                 ECMD_ONE: use first line</a>
<a name="ln2125">/// @param flags    ECMD_HIDE: if true don't free the current buffer</a>
<a name="ln2126">///                 ECMD_SET_HELP: set b_help flag of (new) buffer before</a>
<a name="ln2127">///                 opening file</a>
<a name="ln2128">///                 ECMD_OLDBUF: use existing buffer if it exists</a>
<a name="ln2129">///                 ECMD_FORCEIT: ! used for Ex command</a>
<a name="ln2130">///                 ECMD_ADDBUF: don't edit, just add to buffer list</a>
<a name="ln2131">///                 ECMD_ALTBUF: like ECMD_ADDBUF and also set the alternate</a>
<a name="ln2132">///                 file</a>
<a name="ln2133">///                 ECMD_NOWINENTER: Do not trigger BufWinEnter</a>
<a name="ln2134">/// @param oldwin   Should be &quot;curwin&quot; when editing a new buffer in the current</a>
<a name="ln2135">///                 window, NULL when splitting the window first.  When not NULL</a>
<a name="ln2136">///                 info of the previous buffer for &quot;oldwin&quot; is stored.</a>
<a name="ln2137">///</a>
<a name="ln2138">/// @return FAIL for failure, OK otherwise</a>
<a name="ln2139">int do_ecmd(int fnum, char *ffname, char *sfname, exarg_T *eap, linenr_T newlnum, int flags,</a>
<a name="ln2140">            win_T *oldwin)</a>
<a name="ln2141">{</a>
<a name="ln2142">  bool other_file;                      // true if editing another file</a>
<a name="ln2143">  int oldbuf;                           // true if using existing buffer</a>
<a name="ln2144">  bool auto_buf = false;                // true if autocommands brought us</a>
<a name="ln2145">                                        // into the buffer unexpectedly</a>
<a name="ln2146">  char *new_name = NULL;</a>
<a name="ln2147">  bool did_set_swapcommand = false;</a>
<a name="ln2148">  buf_T *buf;</a>
<a name="ln2149">  bufref_T bufref;</a>
<a name="ln2150">  bufref_T old_curbuf;</a>
<a name="ln2151">  char *free_fname = NULL;</a>
<a name="ln2152">  int retval = FAIL;</a>
<a name="ln2153">  pos_T orig_pos;</a>
<a name="ln2154">  linenr_T topline = 0;</a>
<a name="ln2155">  int newcol = -1;</a>
<a name="ln2156">  int solcol = -1;</a>
<a name="ln2157">  pos_T *pos;</a>
<a name="ln2158">  char *command = NULL;</a>
<a name="ln2159">  bool did_get_winopts = false;</a>
<a name="ln2160">  int readfile_flags = 0;</a>
<a name="ln2161">  bool did_inc_redrawing_disabled = false;</a>
<a name="ln2162">  OptInt *so_ptr = curwin-&gt;w_p_so &gt;= 0 ? &amp;curwin-&gt;w_p_so : &amp;p_so;</a>
<a name="ln2163"> </a>
<a name="ln2164">  if (eap != NULL) {</a>
<a name="ln2165">    command = eap-&gt;do_ecmd_cmd;</a>
<a name="ln2166">  }</a>
<a name="ln2167"> </a>
<a name="ln2168">  set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2169"> </a>
<a name="ln2170">  if (fnum != 0) {</a>
<a name="ln2171">    if (fnum == curbuf-&gt;b_fnum) {       // file is already being edited</a>
<a name="ln2172">      return OK;                        // nothing to do</a>
<a name="ln2173">    }</a>
<a name="ln2174">    other_file = true;</a>
<a name="ln2175">  } else {</a>
<a name="ln2176">    // if no short name given, use ffname for short name</a>
<a name="ln2177">    if (sfname == NULL) {</a>
<a name="ln2178">      sfname = ffname;</a>
<a name="ln2179">    }</a>
<a name="ln2180">#ifdef USE_FNAME_CASE</a>
<a name="ln2181">    if (sfname != NULL) {</a>
<a name="ln2182">      path_fix_case(sfname);             // set correct case for sfname</a>
<a name="ln2183">    }</a>
<a name="ln2184">#endif</a>
<a name="ln2185"> </a>
<a name="ln2186">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))</a>
<a name="ln2187">        &amp;&amp; (ffname == NULL || *ffname == NUL)) {</a>
<a name="ln2188">      goto theend;</a>
<a name="ln2189">    }</a>
<a name="ln2190"> </a>
<a name="ln2191">    if (ffname == NULL) {</a>
<a name="ln2192">      other_file = true;</a>
<a name="ln2193">    } else if (*ffname == NUL &amp;&amp; curbuf-&gt;b_ffname == NULL) {  // there is no file name</a>
<a name="ln2194">      other_file = false;</a>
<a name="ln2195">    } else {</a>
<a name="ln2196">      if (*ffname == NUL) {                 // re-edit with same file name</a>
<a name="ln2197">        ffname = curbuf-&gt;b_ffname;</a>
<a name="ln2198">        sfname = curbuf-&gt;b_fname;</a>
<a name="ln2199">      }</a>
<a name="ln2200">      free_fname = fix_fname(ffname);       // may expand to full path name</a>
<a name="ln2201">      if (free_fname != NULL) {</a>
<a name="ln2202">        ffname = free_fname;</a>
<a name="ln2203">      }</a>
<a name="ln2204">      other_file = otherfile(ffname);</a>
<a name="ln2205">    }</a>
<a name="ln2206">  }</a>
<a name="ln2207"> </a>
<a name="ln2208">  // Re-editing a terminal buffer: skip most buffer re-initialization.</a>
<a name="ln2209">  if (!other_file &amp;&amp; curbuf-&gt;terminal) {</a>
<a name="ln2210">    check_arg_idx(curwin);  // Needed when called from do_argfile().</a>
<a name="ln2211">    maketitle();            // Title may show the arg index, e.g. &quot;(2 of 5)&quot;.</a>
<a name="ln2212">    retval = OK;</a>
<a name="ln2213">    goto theend;</a>
<a name="ln2214">  }</a>
<a name="ln2215"> </a>
<a name="ln2216">  // If the file was changed we may not be allowed to abandon it:</a>
<a name="ln2217">  // - if we are going to re-edit the same file</a>
<a name="ln2218">  // - or if we are the only window on this file and if ECMD_HIDE is false</a>
<a name="ln2219">  if (((!other_file &amp;&amp; !(flags &amp; ECMD_OLDBUF))</a>
<a name="ln2220">       || (curbuf-&gt;b_nwindows == 1</a>
<a name="ln2221">           &amp;&amp; !(flags &amp; (ECMD_HIDE | ECMD_ADDBUF | ECMD_ALTBUF))))</a>
<a name="ln2222">      &amp;&amp; check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln2223">                       | (other_file ? 0 : CCGD_MULTWIN)</a>
<a name="ln2224">                       | ((flags &amp; ECMD_FORCEIT) ? CCGD_FORCEIT : 0)</a>
<a name="ln2225">                       | (eap == NULL ? 0 : CCGD_EXCMD))) {</a>
<a name="ln2226">    if (fnum == 0 &amp;&amp; other_file &amp;&amp; ffname != NULL) {</a>
<a name="ln2227">      (void)setaltfname(ffname, sfname, newlnum &lt; 0 ? 0 : newlnum);</a>
<a name="ln2228">    }</a>
<a name="ln2229">    goto theend;</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  // End Visual mode before switching to another buffer, so the text can be</a>
<a name="ln2233">  // copied into the GUI selection buffer.</a>
<a name="ln2234">  // Careful: may trigger ModeChanged() autocommand</a>
<a name="ln2235"> </a>
<a name="ln2236">  // Should we block autocommands here?</a>
<a name="ln2237">  reset_VIsual();</a>
<a name="ln2238"> </a>
<a name="ln2239">  // autocommands freed window :(</a>
<a name="ln2240">  if (oldwin != NULL &amp;&amp; !win_valid(oldwin)) {</a>
<a name="ln2241">    oldwin = NULL;</a>
<a name="ln2242">  }</a>
<a name="ln2243"> </a>
<a name="ln2244">  if ((command != NULL || newlnum &gt; (linenr_T)0)</a>
<a name="ln2245">      &amp;&amp; *get_vim_var_str(VV_SWAPCOMMAND) == NUL) {</a>
<a name="ln2246">    // Set v:swapcommand for the SwapExists autocommands.</a>
<a name="ln2247">    const size_t len = (command != NULL) ? strlen(command) + 3 : 30;</a>
<a name="ln2248">    char *const p = xmalloc(len);</a>
<a name="ln2249">    if (command != NULL) {</a>
<a name="ln2250">      vim_snprintf(p, len, &quot;:%s\r&quot;, command);</a>
<a name="ln2251">    } else {</a>
<a name="ln2252">      vim_snprintf(p, len, &quot;%&quot; PRId64 &quot;G&quot;, (int64_t)newlnum);</a>
<a name="ln2253">    }</a>
<a name="ln2254">    set_vim_var_string(VV_SWAPCOMMAND, p, -1);</a>
<a name="ln2255">    did_set_swapcommand = true;</a>
<a name="ln2256">    xfree(p);</a>
<a name="ln2257">  }</a>
<a name="ln2258"> </a>
<a name="ln2259">  // If we are starting to edit another file, open a (new) buffer.</a>
<a name="ln2260">  // Otherwise we re-use the current buffer.</a>
<a name="ln2261">  if (other_file) {</a>
<a name="ln2262">    const int prev_alt_fnum = curwin-&gt;w_alt_fnum;</a>
<a name="ln2263"> </a>
<a name="ln2264">    if (!(flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF))) {</a>
<a name="ln2265">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln2266">        curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln2267">      }</a>
<a name="ln2268">      if (oldwin != NULL) {</a>
<a name="ln2269">        buflist_altfpos(oldwin);</a>
<a name="ln2270">      }</a>
<a name="ln2271">    }</a>
<a name="ln2272"> </a>
<a name="ln2273">    if (fnum) {</a>
<a name="ln2274">      buf = buflist_findnr(fnum);</a>
<a name="ln2275">    } else {</a>
<a name="ln2276">      if (flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) {</a>
<a name="ln2277">        // Default the line number to zero to avoid that a wininfo item</a>
<a name="ln2278">        // is added for the current window.</a>
<a name="ln2279">        linenr_T tlnum = 0;</a>
<a name="ln2280"> </a>
<a name="ln2281">        if (command != NULL) {</a>
<a name="ln2282">          tlnum = (linenr_T)atol(command);</a>
<a name="ln2283">          if (tlnum &lt;= 0) {</a>
<a name="ln2284">            tlnum = 1L;</a>
<a name="ln2285">          }</a>
<a name="ln2286">        }</a>
<a name="ln2287">        // Add BLN_NOCURWIN to avoid a new wininfo items are associated</a>
<a name="ln2288">        // with the current window.</a>
<a name="ln2289">        const buf_T *const newbuf</a>
<a name="ln2290">          = buflist_new(ffname, sfname, tlnum, BLN_LISTED | BLN_NOCURWIN);</a>
<a name="ln2291">        if (newbuf != NULL &amp;&amp; (flags &amp; ECMD_ALTBUF)) {</a>
<a name="ln2292">          curwin-&gt;w_alt_fnum = newbuf-&gt;b_fnum;</a>
<a name="ln2293">        }</a>
<a name="ln2294">        goto theend;</a>
<a name="ln2295">      }</a>
<a name="ln2296">      buf = buflist_new(ffname, sfname, 0L,</a>
<a name="ln2297">                        BLN_CURBUF | (flags &amp; ECMD_SET_HELP ? 0 : BLN_LISTED));</a>
<a name="ln2298">      // Autocmds may change curwin and curbuf.</a>
<a name="ln2299">      if (oldwin != NULL) {</a>
<a name="ln2300">        oldwin = curwin;</a>
<a name="ln2301">      }</a>
<a name="ln2302">      set_bufref(&amp;old_curbuf, curbuf);</a>
<a name="ln2303">    }</a>
<a name="ln2304">    if (buf == NULL) {</a>
<a name="ln2305">      goto theend;</a>
<a name="ln2306">    }</a>
<a name="ln2307">    if (curwin-&gt;w_alt_fnum == buf-&gt;b_fnum &amp;&amp; prev_alt_fnum != 0) {</a>
<a name="ln2308">      // reusing the buffer, keep the old alternate file</a>
<a name="ln2309">      curwin-&gt;w_alt_fnum = prev_alt_fnum;</a>
<a name="ln2310">    }</a>
<a name="ln2311">    if (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2312">      // No memfile yet.</a>
<a name="ln2313">      oldbuf = false;</a>
<a name="ln2314">    } else {</a>
<a name="ln2315">      // Existing memfile.</a>
<a name="ln2316">      oldbuf = true;</a>
<a name="ln2317">      set_bufref(&amp;bufref, buf);</a>
<a name="ln2318">      (void)buf_check_timestamp(buf);</a>
<a name="ln2319">      // Check if autocommands made buffer invalid or changed the current</a>
<a name="ln2320">      // buffer.</a>
<a name="ln2321">      if (!bufref_valid(&amp;bufref) || curbuf != old_curbuf.br_buf) {</a>
<a name="ln2322">        goto theend;</a>
<a name="ln2323">      }</a>
<a name="ln2324">      if (aborting()) {</a>
<a name="ln2325">        // Autocmds may abort script processing.</a>
<a name="ln2326">        goto theend;</a>
<a name="ln2327">      }</a>
<a name="ln2328">    }</a>
<a name="ln2329"> </a>
<a name="ln2330">    // May jump to last used line number for a loaded buffer or when asked</a>
<a name="ln2331">    // for explicitly</a>
<a name="ln2332">    if ((oldbuf &amp;&amp; newlnum == ECMD_LASTL) || newlnum == ECMD_LAST) {</a>
<a name="ln2333">      pos = &amp;buflist_findfmark(buf)-&gt;mark;</a>
<a name="ln2334">      newlnum = pos-&gt;lnum;</a>
<a name="ln2335">      solcol = pos-&gt;col;</a>
<a name="ln2336">    }</a>
<a name="ln2337"> </a>
<a name="ln2338">    // Make the (new) buffer the one used by the current window.</a>
<a name="ln2339">    // If the old buffer becomes unused, free it if ECMD_HIDE is false.</a>
<a name="ln2340">    // If the current buffer was empty and has no file name, curbuf</a>
<a name="ln2341">    // is returned by buflist_new(), nothing to do here.</a>
<a name="ln2342">    if (buf != curbuf) {</a>
<a name="ln2343">      const int save_cmdwin_type = cmdwin_type;</a>
<a name="ln2344"> </a>
<a name="ln2345">      // BufLeave applies to the old buffer.</a>
<a name="ln2346">      cmdwin_type = 0;</a>
<a name="ln2347"> </a>
<a name="ln2348">      // Be careful: The autocommands may delete any buffer and change</a>
<a name="ln2349">      // the current buffer.</a>
<a name="ln2350">      // - If the buffer we are going to edit is deleted, give up.</a>
<a name="ln2351">      // - If the current buffer is deleted, prefer to load the new</a>
<a name="ln2352">      //   buffer when loading a buffer is required.  This avoids</a>
<a name="ln2353">      //   loading another buffer which then must be closed again.</a>
<a name="ln2354">      // - If we ended up in the new buffer already, need to skip a few</a>
<a name="ln2355">      //         things, set auto_buf.</a>
<a name="ln2356">      if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2357">        new_name = xstrdup(buf-&gt;b_fname);</a>
<a name="ln2358">      }</a>
<a name="ln2359">      const bufref_T save_au_new_curbuf = au_new_curbuf;</a>
<a name="ln2360">      set_bufref(&amp;au_new_curbuf, buf);</a>
<a name="ln2361">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2362">      cmdwin_type = save_cmdwin_type;</a>
<a name="ln2363">      if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2364">        // New buffer has been deleted.</a>
<a name="ln2365">        delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2366">        au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2367">        goto theend;</a>
<a name="ln2368">      }</a>
<a name="ln2369">      if (aborting()) {             // autocmds may abort script processing</a>
<a name="ln2370">        xfree(new_name);</a>
<a name="ln2371">        au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2372">        goto theend;</a>
<a name="ln2373">      }</a>
<a name="ln2374">      if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2375">        auto_buf = true;</a>
<a name="ln2376">      } else {</a>
<a name="ln2377">        win_T *the_curwin = curwin;</a>
<a name="ln2378">        buf_T *was_curbuf = curbuf;</a>
<a name="ln2379"> </a>
<a name="ln2380">        // Set w_closing to avoid that autocommands close the window.</a>
<a name="ln2381">        // Set b_locked for the same reason.</a>
<a name="ln2382">        the_curwin-&gt;w_closing = true;</a>
<a name="ln2383">        buf-&gt;b_locked++;</a>
<a name="ln2384"> </a>
<a name="ln2385">        if (curbuf == old_curbuf.br_buf) {</a>
<a name="ln2386">          buf_copy_options(buf, BCO_ENTER);</a>
<a name="ln2387">        }</a>
<a name="ln2388"> </a>
<a name="ln2389">        // Close the link to the current buffer. This will set</a>
<a name="ln2390">        // oldwin-&gt;w_buffer to NULL.</a>
<a name="ln2391">        u_sync(false);</a>
<a name="ln2392">        const bool did_decrement</a>
<a name="ln2393">          = close_buffer(oldwin, curbuf, (flags &amp; ECMD_HIDE) || curbuf-&gt;terminal ? 0 : DOBUF_UNLOAD,</a>
<a name="ln2394">                         false, false);</a>
<a name="ln2395"> </a>
<a name="ln2396">        // Autocommands may have closed the window.</a>
<a name="ln2397">        if (win_valid(the_curwin)) {</a>
<a name="ln2398">          the_curwin-&gt;w_closing = false;</a>
<a name="ln2399">        }</a>
<a name="ln2400">        buf-&gt;b_locked--;</a>
<a name="ln2401"> </a>
<a name="ln2402">        // autocmds may abort script processing</a>
<a name="ln2403">        if (aborting() &amp;&amp; curwin-&gt;w_buffer != NULL) {</a>
<a name="ln2404">          xfree(new_name);</a>
<a name="ln2405">          au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2406">          goto theend;</a>
<a name="ln2407">        }</a>
<a name="ln2408">        // Be careful again, like above.</a>
<a name="ln2409">        if (!bufref_valid(&amp;au_new_curbuf)) {</a>
<a name="ln2410">          // New buffer has been deleted.</a>
<a name="ln2411">          delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2412">          au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2413">          goto theend;</a>
<a name="ln2414">        }</a>
<a name="ln2415">        if (buf == curbuf) {  // already in new buffer</a>
<a name="ln2416">          // close_buffer() has decremented the window count,</a>
<a name="ln2417">          // increment it again here and restore w_buffer.</a>
<a name="ln2418">          if (did_decrement &amp;&amp; buf_valid(was_curbuf)) {</a>
<a name="ln2419">            was_curbuf-&gt;b_nwindows++;</a>
<a name="ln2420">          }</a>
<a name="ln2421">          if (win_valid_any_tab(oldwin) &amp;&amp; oldwin-&gt;w_buffer == NULL) {</a>
<a name="ln2422">            oldwin-&gt;w_buffer = was_curbuf;</a>
<a name="ln2423">          }</a>
<a name="ln2424">          auto_buf = true;</a>
<a name="ln2425">        } else {</a>
<a name="ln2426">          // &lt;VN&gt; We could instead free the synblock</a>
<a name="ln2427">          // and re-attach to buffer, perhaps.</a>
<a name="ln2428">          if (curwin-&gt;w_buffer == NULL</a>
<a name="ln2429">              || curwin-&gt;w_s == &amp;(curwin-&gt;w_buffer-&gt;b_s)) {</a>
<a name="ln2430">            curwin-&gt;w_s = &amp;(buf-&gt;b_s);</a>
<a name="ln2431">          }</a>
<a name="ln2432"> </a>
<a name="ln2433">          curwin-&gt;w_buffer = buf;</a>
<a name="ln2434">          curbuf = buf;</a>
<a name="ln2435">          curbuf-&gt;b_nwindows++;</a>
<a name="ln2436"> </a>
<a name="ln2437">          // Set 'fileformat', 'binary' and 'fenc' when forced.</a>
<a name="ln2438">          if (!oldbuf &amp;&amp; eap != NULL) {</a>
<a name="ln2439">            set_file_options(true, eap);</a>
<a name="ln2440">            set_forced_fenc(eap);</a>
<a name="ln2441">          }</a>
<a name="ln2442">        }</a>
<a name="ln2443"> </a>
<a name="ln2444">        // May get the window options from the last time this buffer</a>
<a name="ln2445">        // was in this window (or another window).  If not used</a>
<a name="ln2446">        // before, reset the local window options to the global</a>
<a name="ln2447">        // values.  Also restores old folding stuff.</a>
<a name="ln2448">        get_winopts(curbuf);</a>
<a name="ln2449">        did_get_winopts = true;</a>
<a name="ln2450">      }</a>
<a name="ln2451">      xfree(new_name);</a>
<a name="ln2452">      au_new_curbuf = save_au_new_curbuf;</a>
<a name="ln2453">    }</a>
<a name="ln2454"> </a>
<a name="ln2455">    curwin-&gt;w_pcmark.lnum = 1;</a>
<a name="ln2456">    curwin-&gt;w_pcmark.col = 0;</a>
<a name="ln2457">  } else {  // !other_file</a>
<a name="ln2458">    if ((flags &amp; (ECMD_ADDBUF | ECMD_ALTBUF)) || check_fname() == FAIL) {</a>
<a name="ln2459">      goto theend;</a>
<a name="ln2460">    }</a>
<a name="ln2461">    oldbuf = (flags &amp; ECMD_OLDBUF);</a>
<a name="ln2462">  }</a>
<a name="ln2463"> </a>
<a name="ln2464">  // Don't redraw until the cursor is in the right line, otherwise</a>
<a name="ln2465">  // autocommands may cause ml_get errors.</a>
<a name="ln2466">  RedrawingDisabled++;</a>
<a name="ln2467">  did_inc_redrawing_disabled = true;</a>
<a name="ln2468"> </a>
<a name="ln2469">  buf = curbuf;</a>
<a name="ln2470">  if ((flags &amp; ECMD_SET_HELP) || keep_help_flag) {</a>
<a name="ln2471">    prepare_help_buffer();</a>
<a name="ln2472">  } else if (!curbuf-&gt;b_help) {</a>
<a name="ln2473">    // Don't make a buffer listed if it's a help buffer.  Useful when using</a>
<a name="ln2474">    // CTRL-O to go back to a help file.</a>
<a name="ln2475">    set_buflisted(true);</a>
<a name="ln2476">  }</a>
<a name="ln2477"> </a>
<a name="ln2478">  // If autocommands change buffers under our fingers, forget about</a>
<a name="ln2479">  // editing the file.</a>
<a name="ln2480">  if (buf != curbuf) {</a>
<a name="ln2481">    goto theend;</a>
<a name="ln2482">  }</a>
<a name="ln2483">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2484">    goto theend;</a>
<a name="ln2485">  }</a>
<a name="ln2486"> </a>
<a name="ln2487">  // Since we are starting to edit a file, consider the filetype to be</a>
<a name="ln2488">  // unset.  Helps for when an autocommand changes files and expects syntax</a>
<a name="ln2489">  // highlighting to work in the other file.</a>
<a name="ln2490">  did_filetype = false;</a>
<a name="ln2491"> </a>
<a name="ln2492">  // other_file oldbuf</a>
<a name="ln2493">  //  false     false       re-edit same file, buffer is re-used</a>
<a name="ln2494">  //  false     true        re-edit same file, nothing changes</a>
<a name="ln2495">  //  true      false       start editing new file, new buffer</a>
<a name="ln2496">  //  true      true        start editing in existing buffer (nothing to do)</a>
<a name="ln2497">  if (!other_file &amp;&amp; !oldbuf) {         // re-use the buffer</a>
<a name="ln2498">    set_last_cursor(curwin);            // may set b_last_cursor</a>
<a name="ln2499">    if (newlnum == ECMD_LAST || newlnum == ECMD_LASTL) {</a>
<a name="ln2500">      newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2501">      solcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2502">    }</a>
<a name="ln2503">    buf = curbuf;</a>
<a name="ln2504">    if (buf-&gt;b_fname != NULL) {</a>
<a name="ln2505">      new_name = xstrdup(buf-&gt;b_fname);</a>
<a name="ln2506">    } else {</a>
<a name="ln2507">      new_name = NULL;</a>
<a name="ln2508">    }</a>
<a name="ln2509">    set_bufref(&amp;bufref, buf);</a>
<a name="ln2510"> </a>
<a name="ln2511">    // If the buffer was used before, store the current contents so that</a>
<a name="ln2512">    // the reload can be undone.  Do not do this if the (empty) buffer is</a>
<a name="ln2513">    // being re-used for another file.</a>
<a name="ln2514">    if (!(curbuf-&gt;b_flags &amp; BF_NEVERLOADED)</a>
<a name="ln2515">        &amp;&amp; (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur)) {</a>
<a name="ln2516">      // Sync first so that this is a separate undo-able action.</a>
<a name="ln2517">      u_sync(false);</a>
<a name="ln2518">      if (u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true)</a>
<a name="ln2519">          == FAIL) {</a>
<a name="ln2520">        xfree(new_name);</a>
<a name="ln2521">        goto theend;</a>
<a name="ln2522">      }</a>
<a name="ln2523">      u_unchanged(curbuf);</a>
<a name="ln2524">      buf_updates_unload(curbuf, false);</a>
<a name="ln2525">      buf_freeall(curbuf, BFA_KEEP_UNDO);</a>
<a name="ln2526"> </a>
<a name="ln2527">      // Tell readfile() not to clear or reload undo info.</a>
<a name="ln2528">      readfile_flags = READ_KEEP_UNDO;</a>
<a name="ln2529">    } else {</a>
<a name="ln2530">      buf_updates_unload(curbuf, false);</a>
<a name="ln2531">      buf_freeall(curbuf, 0);  // Free all things for buffer.</a>
<a name="ln2532">    }</a>
<a name="ln2533">    // If autocommands deleted the buffer we were going to re-edit, give</a>
<a name="ln2534">    // up and jump to the end.</a>
<a name="ln2535">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2536">      delbuf_msg(new_name);  // Frees new_name.</a>
<a name="ln2537">      goto theend;</a>
<a name="ln2538">    }</a>
<a name="ln2539">    xfree(new_name);</a>
<a name="ln2540"> </a>
<a name="ln2541">    // If autocommands change buffers under our fingers, forget about</a>
<a name="ln2542">    // re-editing the file.  Should do the buf_clear_file(), but perhaps</a>
<a name="ln2543">    // the autocommands changed the buffer...</a>
<a name="ln2544">    if (buf != curbuf) {</a>
<a name="ln2545">      goto theend;</a>
<a name="ln2546">    }</a>
<a name="ln2547">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln2548">      goto theend;</a>
<a name="ln2549">    }</a>
<a name="ln2550">    buf_clear_file(curbuf);</a>
<a name="ln2551">    curbuf-&gt;b_op_start.lnum = 0;        // clear '[ and '] marks</a>
<a name="ln2552">    curbuf-&gt;b_op_end.lnum = 0;</a>
<a name="ln2553">  }</a>
<a name="ln2554"> </a>
<a name="ln2555">  // If we get here we are sure to start editing</a>
<a name="ln2556"> </a>
<a name="ln2557">  // Assume success now</a>
<a name="ln2558">  retval = OK;</a>
<a name="ln2559"> </a>
<a name="ln2560">  // If the file name was changed, reset the not-edit flag so that &quot;:write&quot;</a>
<a name="ln2561">  // works.</a>
<a name="ln2562">  if (!other_file) {</a>
<a name="ln2563">    curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln2564">  }</a>
<a name="ln2565"> </a>
<a name="ln2566">  // Check if we are editing the w_arg_idx file in the argument list.</a>
<a name="ln2567">  check_arg_idx(curwin);</a>
<a name="ln2568"> </a>
<a name="ln2569">  if (!auto_buf) {</a>
<a name="ln2570">    // Set cursor and init window before reading the file and executing</a>
<a name="ln2571">    // autocommands.  This allows for the autocommands to position the</a>
<a name="ln2572">    // cursor.</a>
<a name="ln2573">    curwin_init();</a>
<a name="ln2574"> </a>
<a name="ln2575">    // It's possible that all lines in the buffer changed.  Need to update</a>
<a name="ln2576">    // automatic folding for all windows where it's used.</a>
<a name="ln2577">    FOR_ALL_TAB_WINDOWS(tp, win) {</a>
<a name="ln2578">      if (win-&gt;w_buffer == curbuf) {</a>
<a name="ln2579">        foldUpdateAll(win);</a>
<a name="ln2580">      }</a>
<a name="ln2581">    }</a>
<a name="ln2582"> </a>
<a name="ln2583">    // Change directories when the 'acd' option is set.</a>
<a name="ln2584">    do_autochdir();</a>
<a name="ln2585"> </a>
<a name="ln2586">    // Careful: open_buffer() and apply_autocmds() may change the current</a>
<a name="ln2587">    // buffer and window.</a>
<a name="ln2588">    orig_pos = curwin-&gt;w_cursor;</a>
<a name="ln2589">    topline = curwin-&gt;w_topline;</a>
<a name="ln2590">    if (!oldbuf) {                          // need to read the file</a>
<a name="ln2591">      swap_exists_action = SEA_DIALOG;</a>
<a name="ln2592">      curbuf-&gt;b_flags |= BF_CHECK_RO;       // set/reset 'ro' flag</a>
<a name="ln2593"> </a>
<a name="ln2594">      // Open the buffer and read the file.</a>
<a name="ln2595">      if (flags &amp; ECMD_NOWINENTER) {</a>
<a name="ln2596">        readfile_flags |= READ_NOWINENTER;</a>
<a name="ln2597">      }</a>
<a name="ln2598">      if (should_abort(open_buffer(false, eap, readfile_flags))) {</a>
<a name="ln2599">        retval = FAIL;</a>
<a name="ln2600">      }</a>
<a name="ln2601"> </a>
<a name="ln2602">      if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln2603">        retval = FAIL;</a>
<a name="ln2604">      }</a>
<a name="ln2605">      handle_swap_exists(&amp;old_curbuf);</a>
<a name="ln2606">    } else {</a>
<a name="ln2607">      // Read the modelines, but only to set window-local options.  Any</a>
<a name="ln2608">      // buffer-local options have already been set and may have been</a>
<a name="ln2609">      // changed by the user.</a>
<a name="ln2610">      do_modelines(OPT_WINONLY);</a>
<a name="ln2611"> </a>
<a name="ln2612">      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, false, curbuf,</a>
<a name="ln2613">                            &amp;retval);</a>
<a name="ln2614">      if ((flags &amp; ECMD_NOWINENTER) == 0) {</a>
<a name="ln2615">        apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL, false, curbuf,</a>
<a name="ln2616">                              &amp;retval);</a>
<a name="ln2617">      }</a>
<a name="ln2618">    }</a>
<a name="ln2619">    check_arg_idx(curwin);</a>
<a name="ln2620"> </a>
<a name="ln2621">    // If autocommands change the cursor position or topline, we should</a>
<a name="ln2622">    // keep it.  Also when it moves within a line. But not when it moves</a>
<a name="ln2623">    // to the first non-blank.</a>
<a name="ln2624">    if (!equalpos(curwin-&gt;w_cursor, orig_pos)) {</a>
<a name="ln2625">      const char *text = get_cursor_line_ptr();</a>
<a name="ln2626"> </a>
<a name="ln2627">      if (curwin-&gt;w_cursor.lnum != orig_pos.lnum</a>
<a name="ln2628">          || curwin-&gt;w_cursor.col != (int)(skipwhite(text) - text)) {</a>
<a name="ln2629">        newlnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2630">        newcol = curwin-&gt;w_cursor.col;</a>
<a name="ln2631">      }</a>
<a name="ln2632">    }</a>
<a name="ln2633">    if (curwin-&gt;w_topline == topline) {</a>
<a name="ln2634">      topline = 0;</a>
<a name="ln2635">    }</a>
<a name="ln2636"> </a>
<a name="ln2637">    // Even when cursor didn't move we need to recompute topline.</a>
<a name="ln2638">    changed_line_abv_curs();</a>
<a name="ln2639"> </a>
<a name="ln2640">    maketitle();</a>
<a name="ln2641">  }</a>
<a name="ln2642"> </a>
<a name="ln2643">  // Tell the diff stuff that this buffer is new and/or needs updating.</a>
<a name="ln2644">  // Also needed when re-editing the same buffer, because unloading will</a>
<a name="ln2645">  // have removed it as a diff buffer.</a>
<a name="ln2646">  if (curwin-&gt;w_p_diff) {</a>
<a name="ln2647">    diff_buf_add(curbuf);</a>
<a name="ln2648">    diff_invalidate(curbuf);</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  // If the window options were changed may need to set the spell language.</a>
<a name="ln2652">  // Can only do this after the buffer has been properly setup.</a>
<a name="ln2653">  if (did_get_winopts &amp;&amp; curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2654">    (void)parse_spelllang(curwin);</a>
<a name="ln2655">  }</a>
<a name="ln2656"> </a>
<a name="ln2657">  if (command == NULL) {</a>
<a name="ln2658">    if (newcol &gt;= 0) {          // position set by autocommands</a>
<a name="ln2659">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2660">      curwin-&gt;w_cursor.col = newcol;</a>
<a name="ln2661">      check_cursor();</a>
<a name="ln2662">    } else if (newlnum &gt; 0) {  // line number from caller or old position</a>
<a name="ln2663">      curwin-&gt;w_cursor.lnum = newlnum;</a>
<a name="ln2664">      check_cursor_lnum(curwin);</a>
<a name="ln2665">      if (solcol &gt;= 0 &amp;&amp; !p_sol) {</a>
<a name="ln2666">        // 'sol' is off: Use last known column.</a>
<a name="ln2667">        curwin-&gt;w_cursor.col = solcol;</a>
<a name="ln2668">        check_cursor_col();</a>
<a name="ln2669">        curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln2670">        curwin-&gt;w_set_curswant = true;</a>
<a name="ln2671">      } else {</a>
<a name="ln2672">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2673">      }</a>
<a name="ln2674">    } else {                  // no line number, go to last line in Ex mode</a>
<a name="ln2675">      if (exmode_active) {</a>
<a name="ln2676">        curwin-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2677">      }</a>
<a name="ln2678">      beginline(BL_WHITE | BL_FIX);</a>
<a name="ln2679">    }</a>
<a name="ln2680">  }</a>
<a name="ln2681"> </a>
<a name="ln2682">  // Check if cursors in other windows on the same buffer are still valid</a>
<a name="ln2683">  check_lnums(false);</a>
<a name="ln2684"> </a>
<a name="ln2685">  // Did not read the file, need to show some info about the file.</a>
<a name="ln2686">  // Do this after setting the cursor.</a>
<a name="ln2687">  if (oldbuf</a>
<a name="ln2688">      &amp;&amp; !auto_buf) {</a>
<a name="ln2689">    int msg_scroll_save = msg_scroll;</a>
<a name="ln2690"> </a>
<a name="ln2691">    // Obey the 'O' flag in 'cpoptions': overwrite any previous file</a>
<a name="ln2692">    // message.</a>
<a name="ln2693">    if (shortmess(SHM_OVERALL) &amp;&amp; !msg_listdo_overwrite &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln2694">      msg_scroll = false;</a>
<a name="ln2695">    }</a>
<a name="ln2696">    if (!msg_scroll) {          // wait a bit when overwriting an error msg</a>
<a name="ln2697">      msg_check_for_delay(false);</a>
<a name="ln2698">    }</a>
<a name="ln2699">    msg_start();</a>
<a name="ln2700">    msg_scroll = msg_scroll_save;</a>
<a name="ln2701">    msg_scrolled_ign = true;</a>
<a name="ln2702"> </a>
<a name="ln2703">    if (!shortmess(SHM_FILEINFO)) {</a>
<a name="ln2704">      fileinfo(false, true, false);</a>
<a name="ln2705">    }</a>
<a name="ln2706"> </a>
<a name="ln2707">    msg_scrolled_ign = false;</a>
<a name="ln2708">  }</a>
<a name="ln2709"> </a>
<a name="ln2710">  curbuf-&gt;b_last_used = time(NULL);</a>
<a name="ln2711"> </a>
<a name="ln2712">  if (command != NULL) {</a>
<a name="ln2713">    do_cmdline(command, NULL, NULL, DOCMD_VERBOSE);</a>
<a name="ln2714">  }</a>
<a name="ln2715"> </a>
<a name="ln2716">  if (curbuf-&gt;b_kmap_state &amp; KEYMAP_INIT) {</a>
<a name="ln2717">    (void)keymap_init();</a>
<a name="ln2718">  }</a>
<a name="ln2719"> </a>
<a name="ln2720">  RedrawingDisabled--;</a>
<a name="ln2721">  did_inc_redrawing_disabled = false;</a>
<a name="ln2722">  if (!skip_redraw) {</a>
<a name="ln2723">    OptInt n = *so_ptr;</a>
<a name="ln2724">    if (topline == 0 &amp;&amp; command == NULL) {</a>
<a name="ln2725">      *so_ptr = 999;    // force cursor to be vertically centered in the window</a>
<a name="ln2726">    }</a>
<a name="ln2727">    update_topline(curwin);</a>
<a name="ln2728">    curwin-&gt;w_scbind_pos = curwin-&gt;w_topline;</a>
<a name="ln2729">    *so_ptr = n;</a>
<a name="ln2730">    redraw_curbuf_later(UPD_NOT_VALID);  // redraw this buffer later</a>
<a name="ln2731">  }</a>
<a name="ln2732"> </a>
<a name="ln2733">  // Change directories when the 'acd' option is set.</a>
<a name="ln2734">  do_autochdir();</a>
<a name="ln2735"> </a>
<a name="ln2736">theend:</a>
<a name="ln2737">  if (bufref_valid(&amp;old_curbuf) &amp;&amp; old_curbuf.br_buf-&gt;terminal != NULL) {</a>
<a name="ln2738">    terminal_check_size(old_curbuf.br_buf-&gt;terminal);</a>
<a name="ln2739">  }</a>
<a name="ln2740"> </a>
<a name="ln2741">  if (did_inc_redrawing_disabled) {</a>
<a name="ln2742">    RedrawingDisabled--;</a>
<a name="ln2743">  }</a>
<a name="ln2744">  if (did_set_swapcommand) {</a>
<a name="ln2745">    set_vim_var_string(VV_SWAPCOMMAND, NULL, -1);</a>
<a name="ln2746">  }</a>
<a name="ln2747">  xfree(free_fname);</a>
<a name="ln2748">  return retval;</a>
<a name="ln2749">}</a>
<a name="ln2750"> </a>
<a name="ln2751">static void delbuf_msg(char *name)</a>
<a name="ln2752">{</a>
<a name="ln2753">  semsg(_(&quot;E143: Autocommands unexpectedly deleted new buffer %s&quot;),</a>
<a name="ln2754">        name == NULL ? &quot;&quot; : name);</a>
<a name="ln2755">  xfree(name);</a>
<a name="ln2756">  au_new_curbuf.br_buf = NULL;</a>
<a name="ln2757">  au_new_curbuf.br_buf_free_count = 0;</a>
<a name="ln2758">}</a>
<a name="ln2759"> </a>
<a name="ln2760">static int append_indent = 0;       // autoindent for first line</a>
<a name="ln2761"> </a>
<a name="ln2762">/// &quot;:insert&quot; and &quot;:append&quot;, also used by &quot;:change&quot;</a>
<a name="ln2763">void ex_append(exarg_T *eap)</a>
<a name="ln2764">{</a>
<a name="ln2765">  char *theline;</a>
<a name="ln2766">  bool did_undo = false;</a>
<a name="ln2767">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2768">  int indent = 0;</a>
<a name="ln2769">  char *p;</a>
<a name="ln2770">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln2771"> </a>
<a name="ln2772">  // the ! flag toggles autoindent</a>
<a name="ln2773">  if (eap-&gt;forceit) {</a>
<a name="ln2774">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2775">  }</a>
<a name="ln2776"> </a>
<a name="ln2777">  // First autoindent comes from the line we start on</a>
<a name="ln2778">  if (eap-&gt;cmdidx != CMD_change &amp;&amp; curbuf-&gt;b_p_ai &amp;&amp; lnum &gt; 0) {</a>
<a name="ln2779">    append_indent = get_indent_lnum(lnum);</a>
<a name="ln2780">  }</a>
<a name="ln2781"> </a>
<a name="ln2782">  if (eap-&gt;cmdidx != CMD_append) {</a>
<a name="ln2783">    lnum--;</a>
<a name="ln2784">  }</a>
<a name="ln2785"> </a>
<a name="ln2786">  // when the buffer is empty need to delete the dummy line</a>
<a name="ln2787">  if (empty &amp;&amp; lnum == 1) {</a>
<a name="ln2788">    lnum = 0;</a>
<a name="ln2789">  }</a>
<a name="ln2790"> </a>
<a name="ln2791">  State = MODE_INSERT;                   // behave like in Insert mode</a>
<a name="ln2792">  if (curbuf-&gt;b_p_iminsert == B_IMODE_LMAP) {</a>
<a name="ln2793">    State |= MODE_LANGMAP;</a>
<a name="ln2794">  }</a>
<a name="ln2795"> </a>
<a name="ln2796">  while (true) {</a>
<a name="ln2797">    msg_scroll = true;</a>
<a name="ln2798">    need_wait_return = false;</a>
<a name="ln2799">    if (curbuf-&gt;b_p_ai) {</a>
<a name="ln2800">      if (append_indent &gt;= 0) {</a>
<a name="ln2801">        indent = append_indent;</a>
<a name="ln2802">        append_indent = -1;</a>
<a name="ln2803">      } else if (lnum &gt; 0) {</a>
<a name="ln2804">        indent = get_indent_lnum(lnum);</a>
<a name="ln2805">      }</a>
<a name="ln2806">    }</a>
<a name="ln2807">    if (eap-&gt;getline == NULL) {</a>
<a name="ln2808">      // No getline() function, use the lines that follow. This ends</a>
<a name="ln2809">      // when there is no more.</a>
<a name="ln2810">      if (eap-&gt;nextcmd == NULL || *eap-&gt;nextcmd == NUL) {</a>
<a name="ln2811">        break;</a>
<a name="ln2812">      }</a>
<a name="ln2813">      p = vim_strchr(eap-&gt;nextcmd, NL);</a>
<a name="ln2814">      if (p == NULL) {</a>
<a name="ln2815">        p = eap-&gt;nextcmd + strlen(eap-&gt;nextcmd);</a>
<a name="ln2816">      }</a>
<a name="ln2817">      theline = xstrnsave(eap-&gt;nextcmd, (size_t)(p - eap-&gt;nextcmd));</a>
<a name="ln2818">      if (*p != NUL) {</a>
<a name="ln2819">        p++;</a>
<a name="ln2820">      }</a>
<a name="ln2821">      eap-&gt;nextcmd = p;</a>
<a name="ln2822">    } else {</a>
<a name="ln2823">      int save_State = State;</a>
<a name="ln2824">      // Set State to avoid the cursor shape to be set to MODE_INSERT</a>
<a name="ln2825">      // state when getline() returns.</a>
<a name="ln2826">      State = MODE_CMDLINE;</a>
<a name="ln2827">      theline = eap-&gt;getline(eap-&gt;cstack-&gt;cs_looplevel &gt; 0 ? -1 : NUL, eap-&gt;cookie, indent, true);</a>
<a name="ln2828">      State = save_State;</a>
<a name="ln2829">    }</a>
<a name="ln2830">    lines_left = Rows - 1;</a>
<a name="ln2831">    if (theline == NULL) {</a>
<a name="ln2832">      break;</a>
<a name="ln2833">    }</a>
<a name="ln2834"> </a>
<a name="ln2835">    // Look for the &quot;.&quot; after automatic indent.</a>
<a name="ln2836">    int vcol = 0;</a>
<a name="ln2837">    for (p = theline; indent &gt; vcol; p++) {</a>
<a name="ln2838">      if (*p == ' ') {</a>
<a name="ln2839">        vcol++;</a>
<a name="ln2840">      } else if (*p == TAB) {</a>
<a name="ln2841">        vcol += 8 - vcol % 8;</a>
<a name="ln2842">      } else {</a>
<a name="ln2843">        break;</a>
<a name="ln2844">      }</a>
<a name="ln2845">    }</a>
<a name="ln2846">    if ((p[0] == '.' &amp;&amp; p[1] == NUL)</a>
<a name="ln2847">        || (!did_undo &amp;&amp; u_save(lnum, lnum + 1 + (empty ? 1 : 0))</a>
<a name="ln2848">            == FAIL)) {</a>
<a name="ln2849">      xfree(theline);</a>
<a name="ln2850">      break;</a>
<a name="ln2851">    }</a>
<a name="ln2852"> </a>
<a name="ln2853">    // don't use autoindent if nothing was typed.</a>
<a name="ln2854">    if (p[0] == NUL) {</a>
<a name="ln2855">      theline[0] = NUL;</a>
<a name="ln2856">    }</a>
<a name="ln2857"> </a>
<a name="ln2858">    did_undo = true;</a>
<a name="ln2859">    ml_append(lnum, theline, (colnr_T)0, false);</a>
<a name="ln2860">    if (empty) {</a>
<a name="ln2861">      // there are no marks below the inserted lines</a>
<a name="ln2862">      appended_lines(lnum, 1L);</a>
<a name="ln2863">    } else {</a>
<a name="ln2864">      appended_lines_mark(lnum, 1L);</a>
<a name="ln2865">    }</a>
<a name="ln2866"> </a>
<a name="ln2867">    xfree(theline);</a>
<a name="ln2868">    lnum++;</a>
<a name="ln2869"> </a>
<a name="ln2870">    if (empty) {</a>
<a name="ln2871">      ml_delete(2L, false);</a>
<a name="ln2872">      empty = 0;</a>
<a name="ln2873">    }</a>
<a name="ln2874">  }</a>
<a name="ln2875">  State = MODE_NORMAL;</a>
<a name="ln2876"> </a>
<a name="ln2877">  if (eap-&gt;forceit) {</a>
<a name="ln2878">    curbuf-&gt;b_p_ai = !curbuf-&gt;b_p_ai;</a>
<a name="ln2879">  }</a>
<a name="ln2880"> </a>
<a name="ln2881">  // &quot;start&quot; is set to eap-&gt;line2+1 unless that position is invalid (when</a>
<a name="ln2882">  // eap-&gt;line2 pointed to the end of the buffer and nothing was appended)</a>
<a name="ln2883">  // &quot;end&quot; is set to lnum when something has been appended, otherwise</a>
<a name="ln2884">  // it is the same as &quot;start&quot;  -- Acevedo</a>
<a name="ln2885">  if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln2886">    curbuf-&gt;b_op_start.lnum</a>
<a name="ln2887">      = (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count) ? eap-&gt;line2 + 1 : curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2888">    if (eap-&gt;cmdidx != CMD_append) {</a>
<a name="ln2889">      curbuf-&gt;b_op_start.lnum--;</a>
<a name="ln2890">    }</a>
<a name="ln2891">    curbuf-&gt;b_op_end.lnum = (eap-&gt;line2 &lt; lnum) ? lnum : curbuf-&gt;b_op_start.lnum;</a>
<a name="ln2892">    curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln2893">  }</a>
<a name="ln2894">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2895">  check_cursor_lnum(curwin);</a>
<a name="ln2896">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln2897"> </a>
<a name="ln2898">  need_wait_return = false;     // don't use wait_return() now</a>
<a name="ln2899">  ex_no_reprint = true;</a>
<a name="ln2900">}</a>
<a name="ln2901"> </a>
<a name="ln2902">/// &quot;:change&quot;</a>
<a name="ln2903">void ex_change(exarg_T *eap)</a>
<a name="ln2904">{</a>
<a name="ln2905">  linenr_T lnum;</a>
<a name="ln2906"> </a>
<a name="ln2907">  if (eap-&gt;line2 &gt;= eap-&gt;line1</a>
<a name="ln2908">      &amp;&amp; u_save(eap-&gt;line1 - 1, eap-&gt;line2 + 1) == FAIL) {</a>
<a name="ln2909">    return;</a>
<a name="ln2910">  }</a>
<a name="ln2911"> </a>
<a name="ln2912">  // the ! flag toggles autoindent</a>
<a name="ln2913">  if (eap-&gt;forceit ? !curbuf-&gt;b_p_ai : curbuf-&gt;b_p_ai) {</a>
<a name="ln2914">    append_indent = get_indent_lnum(eap-&gt;line1);</a>
<a name="ln2915">  }</a>
<a name="ln2916"> </a>
<a name="ln2917">  for (lnum = eap-&gt;line2; lnum &gt;= eap-&gt;line1; lnum--) {</a>
<a name="ln2918">    if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {         // nothing to delete</a>
<a name="ln2919">      break;</a>
<a name="ln2920">    }</a>
<a name="ln2921">    ml_delete(eap-&gt;line1, false);</a>
<a name="ln2922">  }</a>
<a name="ln2923"> </a>
<a name="ln2924">  // make sure the cursor is not beyond the end of the file now</a>
<a name="ln2925">  check_cursor_lnum(curwin);</a>
<a name="ln2926">  deleted_lines_mark(eap-&gt;line1, (eap-&gt;line2 - lnum));</a>
<a name="ln2927"> </a>
<a name="ln2928">  // &quot;:append&quot; on the line above the deleted lines.</a>
<a name="ln2929">  eap-&gt;line2 = eap-&gt;line1;</a>
<a name="ln2930">  ex_append(eap);</a>
<a name="ln2931">}</a>
<a name="ln2932"> </a>
<a name="ln2933">void ex_z(exarg_T *eap)</a>
<a name="ln2934">{</a>
<a name="ln2935">  char *x;</a>
<a name="ln2936">  int64_t bigness;</a>
<a name="ln2937">  char *kind;</a>
<a name="ln2938">  int minus = 0;</a>
<a name="ln2939">  linenr_T start, end, curs, i;</a>
<a name="ln2940">  int j;</a>
<a name="ln2941">  linenr_T lnum = eap-&gt;line2;</a>
<a name="ln2942"> </a>
<a name="ln2943">  // Vi compatible: &quot;:z!&quot; uses display height, without a count uses</a>
<a name="ln2944">  // 'scroll'</a>
<a name="ln2945">  if (eap-&gt;forceit) {</a>
<a name="ln2946">    bigness = Rows - 1;</a>
<a name="ln2947">  } else if (ONE_WINDOW) {</a>
<a name="ln2948">    bigness = curwin-&gt;w_p_scr * 2;</a>
<a name="ln2949">  } else {</a>
<a name="ln2950">    bigness = curwin-&gt;w_height_inner - 3;</a>
<a name="ln2951">  }</a>
<a name="ln2952">  if (bigness &lt; 1) {</a>
<a name="ln2953">    bigness = 1;</a>
<a name="ln2954">  }</a>
<a name="ln2955"> </a>
<a name="ln2956">  x = eap-&gt;arg;</a>
<a name="ln2957">  kind = x;</a>
<a name="ln2958">  if (*kind == '-' || *kind == '+' || *kind == '='</a>
<a name="ln2959">      || *kind == '^' || *kind == '.') {</a>
<a name="ln2960">    x++;</a>
<a name="ln2961">  }</a>
<a name="ln2962">  while (*x == '-' || *x == '+') {</a>
<a name="ln2963">    x++;</a>
<a name="ln2964">  }</a>
<a name="ln2965"> </a>
<a name="ln2966">  if (*x != 0) {</a>
<a name="ln2967">    if (!ascii_isdigit(*x)) {</a>
<a name="ln2968">      emsg(_(e_non_numeric_argument_to_z));</a>
<a name="ln2969">      return;</a>
<a name="ln2970">    }</a>
<a name="ln2971">    bigness = atol(x);</a>
<a name="ln2972"> </a>
<a name="ln2973">    // bigness could be &lt; 0 if atol(x) overflows.</a>
<a name="ln2974">    if (bigness &gt; 2 * curbuf-&gt;b_ml.ml_line_count || bigness &lt; 0) {</a>
<a name="ln2975">      bigness = 2 * curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2976">    }</a>
<a name="ln2977"> </a>
<a name="ln2978">    p_window = (int)bigness;</a>
<a name="ln2979">    if (*kind == '=') {</a>
<a name="ln2980">      bigness += 2;</a>
<a name="ln2981">    }</a>
<a name="ln2982">  }</a>
<a name="ln2983"> </a>
<a name="ln2984">  // the number of '-' and '+' multiplies the distance</a>
<a name="ln2985">  if (*kind == '-' || *kind == '+') {</a>
<a name="ln2986">    for (x = kind + 1; *x == *kind; x++) {}</a>
<a name="ln2987">  }</a>
<a name="ln2988"> </a>
<a name="ln2989">  switch (*kind) {</a>
<a name="ln2990">  case '-':</a>
<a name="ln2991">    start = lnum - (linenr_T)bigness * (linenr_T)(x - kind) + 1;</a>
<a name="ln2992">    end = start + (linenr_T)bigness - 1;</a>
<a name="ln2993">    curs = end;</a>
<a name="ln2994">    break;</a>
<a name="ln2995"> </a>
<a name="ln2996">  case '=':</a>
<a name="ln2997">    start = lnum - ((linenr_T)bigness + 1) / 2 + 1;</a>
<a name="ln2998">    end = lnum + ((linenr_T)bigness + 1) / 2 - 1;</a>
<a name="ln2999">    curs = lnum;</a>
<a name="ln3000">    minus = 1;</a>
<a name="ln3001">    break;</a>
<a name="ln3002"> </a>
<a name="ln3003">  case '^':</a>
<a name="ln3004">    start = lnum - (linenr_T)bigness * 2;</a>
<a name="ln3005">    end = lnum - (linenr_T)bigness;</a>
<a name="ln3006">    curs = lnum - (linenr_T)bigness;</a>
<a name="ln3007">    break;</a>
<a name="ln3008"> </a>
<a name="ln3009">  case '.':</a>
<a name="ln3010">    start = lnum - ((linenr_T)bigness + 1) / 2 + 1;</a>
<a name="ln3011">    end = lnum + ((linenr_T)bigness + 1) / 2 - 1;</a>
<a name="ln3012">    curs = end;</a>
<a name="ln3013">    break;</a>
<a name="ln3014"> </a>
<a name="ln3015">  default:        // '+'</a>
<a name="ln3016">    start = lnum;</a>
<a name="ln3017">    if (*kind == '+') {</a>
<a name="ln3018">      start += (linenr_T)bigness * (linenr_T)(x - kind - 1) + 1;</a>
<a name="ln3019">    } else if (eap-&gt;addr_count == 0) {</a>
<a name="ln3020">      start++;</a>
<a name="ln3021">    }</a>
<a name="ln3022">    end = start + (linenr_T)bigness - 1;</a>
<a name="ln3023">    curs = end;</a>
<a name="ln3024">    break;</a>
<a name="ln3025">  }</a>
<a name="ln3026"> </a>
<a name="ln3027">  if (start &lt; 1) {</a>
<a name="ln3028">    start = 1;</a>
<a name="ln3029">  }</a>
<a name="ln3030"> </a>
<a name="ln3031">  if (end &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3032">    end = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3033">  }</a>
<a name="ln3034"> </a>
<a name="ln3035">  if (curs &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3036">    curs = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3037">  } else if (curs &lt; 1) {</a>
<a name="ln3038">    curs = 1;</a>
<a name="ln3039">  }</a>
<a name="ln3040"> </a>
<a name="ln3041">  for (i = start; i &lt;= end; i++) {</a>
<a name="ln3042">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3043">      msg_putchar('\n');</a>
<a name="ln3044"> </a>
<a name="ln3045">      for (j = 1; j &lt; Columns; j++) {</a>
<a name="ln3046">        msg_putchar('-');</a>
<a name="ln3047">      }</a>
<a name="ln3048">    }</a>
<a name="ln3049"> </a>
<a name="ln3050">    print_line(i, eap-&gt;flags &amp; EXFLAG_NR, eap-&gt;flags &amp; EXFLAG_LIST);</a>
<a name="ln3051"> </a>
<a name="ln3052">    if (minus &amp;&amp; i == lnum) {</a>
<a name="ln3053">      msg_putchar('\n');</a>
<a name="ln3054"> </a>
<a name="ln3055">      for (j = 1; j &lt; Columns; j++) {</a>
<a name="ln3056">        msg_putchar('-');</a>
<a name="ln3057">      }</a>
<a name="ln3058">    }</a>
<a name="ln3059">  }</a>
<a name="ln3060"> </a>
<a name="ln3061">  if (curwin-&gt;w_cursor.lnum != curs) {</a>
<a name="ln3062">    curwin-&gt;w_cursor.lnum = curs;</a>
<a name="ln3063">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3064">  }</a>
<a name="ln3065">  ex_no_reprint = true;</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068">/// @return  true if the secure flag is set and also give an error message.</a>
<a name="ln3069">///          Otherwise, return false.</a>
<a name="ln3070">bool check_secure(void)</a>
<a name="ln3071">{</a>
<a name="ln3072">  if (secure) {</a>
<a name="ln3073">    secure = 2;</a>
<a name="ln3074">    emsg(_(e_curdir));</a>
<a name="ln3075">    return true;</a>
<a name="ln3076">  }</a>
<a name="ln3077"> </a>
<a name="ln3078">  // In the sandbox more things are not allowed, including the things</a>
<a name="ln3079">  // disallowed in secure mode.</a>
<a name="ln3080">  if (sandbox != 0) {</a>
<a name="ln3081">    emsg(_(e_sandbox));</a>
<a name="ln3082">    return true;</a>
<a name="ln3083">  }</a>
<a name="ln3084">  return false;</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087">/// Previous substitute replacement string</a>
<a name="ln3088">static SubReplacementString old_sub = { NULL, 0, NULL };</a>
<a name="ln3089"> </a>
<a name="ln3090">static int global_need_beginline;       // call beginline() after &quot;:g&quot;</a>
<a name="ln3091"> </a>
<a name="ln3092">/// Get old substitute replacement string</a>
<a name="ln3093">///</a>
<a name="ln3094">/// @param[out]  ret_sub    Location where old string will be saved.</a>
<a name="ln3095">void sub_get_replacement(SubReplacementString *const ret_sub)</a>
<a name="ln3096">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3097">{</a>
<a name="ln3098">  *ret_sub = old_sub;</a>
<a name="ln3099">}</a>
<a name="ln3100"> </a>
<a name="ln3101">/// Set substitute string and timestamp</a>
<a name="ln3102">///</a>
<a name="ln3103">/// @warning `sub` must be in allocated memory. It is not copied.</a>
<a name="ln3104">///</a>
<a name="ln3105">/// @param[in]  sub  New replacement string.</a>
<a name="ln3106">void sub_set_replacement(SubReplacementString sub)</a>
<a name="ln3107">{</a>
<a name="ln3108">  xfree(old_sub.sub);</a>
<a name="ln3109">  if (sub.additional_elements != old_sub.additional_elements) {</a>
<a name="ln3110">    tv_list_unref(old_sub.additional_elements);</a>
<a name="ln3111">  }</a>
<a name="ln3112">  old_sub = sub;</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">/// Recognize &quot;:%s/\n//&quot; and turn it into a join command, which is much</a>
<a name="ln3116">/// more efficient.</a>
<a name="ln3117">///</a>
<a name="ln3118">/// @param[in]  eap  Ex arguments</a>
<a name="ln3119">/// @param[in]  pat  Search pattern</a>
<a name="ln3120">/// @param[in]  sub  Replacement string</a>
<a name="ln3121">/// @param[in]  cmd  Command from :s_flags</a>
<a name="ln3122">/// @param[in]  save Save pattern to options, history</a>
<a name="ln3123">///</a>
<a name="ln3124">/// @returns true if :substitute can be replaced with a join command</a>
<a name="ln3125">static bool sub_joining_lines(exarg_T *eap, char *pat, const char *sub, const char *cmd, bool save)</a>
<a name="ln3126">  FUNC_ATTR_NONNULL_ARG(1, 3, 4)</a>
<a name="ln3127">{</a>
<a name="ln3128">  // TODO(vim): find a generic solution to make line-joining operations more</a>
<a name="ln3129">  // efficient, avoid allocating a string that grows in size.</a>
<a name="ln3130">  if (pat != NULL</a>
<a name="ln3131">      &amp;&amp; strcmp(pat, &quot;\\n&quot;) == 0</a>
<a name="ln3132">      &amp;&amp; *sub == NUL</a>
<a name="ln3133">      &amp;&amp; (*cmd == NUL || (cmd[1] == NUL</a>
<a name="ln3134">                          &amp;&amp; (*cmd == 'g'</a>
<a name="ln3135">                              || *cmd == 'l'</a>
<a name="ln3136">                              || *cmd == 'p'</a>
<a name="ln3137">                              || *cmd == '#')))) {</a>
<a name="ln3138">    if (eap-&gt;skip) {</a>
<a name="ln3139">      return true;</a>
<a name="ln3140">    }</a>
<a name="ln3141">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln3142">    if (*cmd == 'l') {</a>
<a name="ln3143">      eap-&gt;flags = EXFLAG_LIST;</a>
<a name="ln3144">    } else if (*cmd == '#') {</a>
<a name="ln3145">      eap-&gt;flags = EXFLAG_NR;</a>
<a name="ln3146">    } else if (*cmd == 'p') {</a>
<a name="ln3147">      eap-&gt;flags = EXFLAG_PRINT;</a>
<a name="ln3148">    }</a>
<a name="ln3149"> </a>
<a name="ln3150">    // The number of lines joined is the number of lines in the range</a>
<a name="ln3151">    linenr_T joined_lines_count = eap-&gt;line2 - eap-&gt;line1 + 1</a>
<a name="ln3152">                                  // plus one extra line if not at the end of file.</a>
<a name="ln3153">                                  + (eap-&gt;line2 &lt; curbuf-&gt;b_ml.ml_line_count ? 1 : 0);</a>
<a name="ln3154">    if (joined_lines_count &gt; 1) {</a>
<a name="ln3155">      do_join((size_t)joined_lines_count, false, true, false, true);</a>
<a name="ln3156">      sub_nsubs = joined_lines_count - 1;</a>
<a name="ln3157">      sub_nlines = 1;</a>
<a name="ln3158">      do_sub_msg(false);</a>
<a name="ln3159">      ex_may_print(eap);</a>
<a name="ln3160">    }</a>
<a name="ln3161"> </a>
<a name="ln3162">    if (save) {</a>
<a name="ln3163">      if ((cmdmod.cmod_flags &amp; CMOD_KEEPPATTERNS) == 0) {</a>
<a name="ln3164">        save_re_pat(RE_SUBST, pat, magic_isset());</a>
<a name="ln3165">      }</a>
<a name="ln3166">      // put pattern in history</a>
<a name="ln3167">      add_to_history(HIST_SEARCH, pat, true, NUL);</a>
<a name="ln3168">    }</a>
<a name="ln3169"> </a>
<a name="ln3170">    return true;</a>
<a name="ln3171">  }</a>
<a name="ln3172"> </a>
<a name="ln3173">  return false;</a>
<a name="ln3174">}</a>
<a name="ln3175"> </a>
<a name="ln3176">/// Allocate memory to store the replacement text for :substitute.</a>
<a name="ln3177">///</a>
<a name="ln3178">/// Slightly more memory that is strictly necessary is allocated to reduce the</a>
<a name="ln3179">/// frequency of memory (re)allocation.</a>
<a name="ln3180">///</a>
<a name="ln3181">/// @param[in,out]  new_start      pointer to the memory for the replacement text</a>
<a name="ln3182">/// @param[in,out]  new_start_len  pointer to length of new_start</a>
<a name="ln3183">/// @param[in]      needed_len     amount of memory needed</a>
<a name="ln3184">///</a>
<a name="ln3185">/// @returns pointer to the end of the allocated memory</a>
<a name="ln3186">static char *sub_grow_buf(char **new_start, int *new_start_len, int needed_len)</a>
<a name="ln3187">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3188">{</a>
<a name="ln3189">  char *new_end;</a>
<a name="ln3190">  if (*new_start == NULL) {</a>
<a name="ln3191">    // Get some space for a temporary buffer to do the</a>
<a name="ln3192">    // substitution into (and some extra space to avoid</a>
<a name="ln3193">    // too many calls to xmalloc()/free()).</a>
<a name="ln3194">    *new_start_len = needed_len + 50;</a>
<a name="ln3195">    *new_start = xmalloc((size_t)(*new_start_len));</a>
<a name="ln3196">    **new_start = NUL;</a>
<a name="ln3197">    new_end = *new_start;</a>
<a name="ln3198">  } else {</a>
<a name="ln3199">    // Check if the temporary buffer is long enough to do the</a>
<a name="ln3200">    // substitution into.  If not, make it larger (with a bit</a>
<a name="ln3201">    // extra to avoid too many calls to xmalloc()/free()).</a>
<a name="ln3202">    size_t len = strlen(*new_start);</a>
<a name="ln3203">    needed_len += (int)len;</a>
<a name="ln3204">    if (needed_len &gt; *new_start_len) {</a>
<a name="ln3205">      *new_start_len = needed_len + 50;</a>
<a name="ln3206">      *new_start = xrealloc(*new_start, (size_t)(*new_start_len));</a>
<a name="ln3207">    }</a>
<a name="ln3208">    new_end = *new_start + len;</a>
<a name="ln3209">  }</a>
<a name="ln3210"> </a>
<a name="ln3211">  return new_end;</a>
<a name="ln3212">}</a>
<a name="ln3213"> </a>
<a name="ln3214">/// Parse cmd string for :substitute's {flags} and update subflags accordingly</a>
<a name="ln3215">///</a>
<a name="ln3216">/// @param[in]      cmd  command string</a>
<a name="ln3217">/// @param[in,out]  subflags  current flags defined for the :substitute command</a>
<a name="ln3218">/// @param[in,out]  which_pat  pattern type from which to get default search</a>
<a name="ln3219">///</a>
<a name="ln3220">/// @returns pointer to the end of the flags, which may be the end of the string</a>
<a name="ln3221">static char *sub_parse_flags(char *cmd, subflags_T *subflags, int *which_pat)</a>
<a name="ln3222">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln3223">{</a>
<a name="ln3224">  // Find trailing options.  When '&amp;' is used, keep old options.</a>
<a name="ln3225">  if (*cmd == '&amp;') {</a>
<a name="ln3226">    cmd++;</a>
<a name="ln3227">  } else {</a>
<a name="ln3228">    subflags-&gt;do_all = p_gd;</a>
<a name="ln3229">    subflags-&gt;do_ask = false;</a>
<a name="ln3230">    subflags-&gt;do_error = true;</a>
<a name="ln3231">    subflags-&gt;do_print = false;</a>
<a name="ln3232">    subflags-&gt;do_list = false;</a>
<a name="ln3233">    subflags-&gt;do_count = false;</a>
<a name="ln3234">    subflags-&gt;do_number = false;</a>
<a name="ln3235">    subflags-&gt;do_ic = kSubHonorOptions;</a>
<a name="ln3236">  }</a>
<a name="ln3237">  while (*cmd) {</a>
<a name="ln3238">    // Note that 'g' and 'c' are always inverted.</a>
<a name="ln3239">    // 'r' is never inverted.</a>
<a name="ln3240">    if (*cmd == 'g') {</a>
<a name="ln3241">      subflags-&gt;do_all = !subflags-&gt;do_all;</a>
<a name="ln3242">    } else if (*cmd == 'c') {</a>
<a name="ln3243">      subflags-&gt;do_ask = !subflags-&gt;do_ask;</a>
<a name="ln3244">    } else if (*cmd == 'n') {</a>
<a name="ln3245">      subflags-&gt;do_count = true;</a>
<a name="ln3246">    } else if (*cmd == 'e') {</a>
<a name="ln3247">      subflags-&gt;do_error = !subflags-&gt;do_error;</a>
<a name="ln3248">    } else if (*cmd == 'r') {  // use last used regexp</a>
<a name="ln3249">      *which_pat = RE_LAST;</a>
<a name="ln3250">    } else if (*cmd == 'p') {</a>
<a name="ln3251">      subflags-&gt;do_print = true;</a>
<a name="ln3252">    } else if (*cmd == '#') {</a>
<a name="ln3253">      subflags-&gt;do_print = true;</a>
<a name="ln3254">      subflags-&gt;do_number = true;</a>
<a name="ln3255">    } else if (*cmd == 'l') {</a>
<a name="ln3256">      subflags-&gt;do_print = true;</a>
<a name="ln3257">      subflags-&gt;do_list = true;</a>
<a name="ln3258">    } else if (*cmd == 'i') {  // ignore case</a>
<a name="ln3259">      subflags-&gt;do_ic = kSubIgnoreCase;</a>
<a name="ln3260">    } else if (*cmd == 'I') {  // don't ignore case</a>
<a name="ln3261">      subflags-&gt;do_ic = kSubMatchCase;</a>
<a name="ln3262">    } else {</a>
<a name="ln3263">      break;</a>
<a name="ln3264">    }</a>
<a name="ln3265">    cmd++;</a>
<a name="ln3266">  }</a>
<a name="ln3267">  if (subflags-&gt;do_count) {</a>
<a name="ln3268">    subflags-&gt;do_ask = false;</a>
<a name="ln3269">  }</a>
<a name="ln3270"> </a>
<a name="ln3271">  return cmd;</a>
<a name="ln3272">}</a>
<a name="ln3273"> </a>
<a name="ln3274">static int check_regexp_delim(int c)</a>
<a name="ln3275">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3276">{</a>
<a name="ln3277">  if (isalpha(c)) {</a>
<a name="ln3278">    emsg(_(&quot;E146: Regular expressions can't be delimited by letters&quot;));</a>
<a name="ln3279">    return FAIL;</a>
<a name="ln3280">  }</a>
<a name="ln3281">  return OK;</a>
<a name="ln3282">}</a>
<a name="ln3283"> </a>
<a name="ln3284">/// Perform a substitution from line eap-&gt;line1 to line eap-&gt;line2 using the</a>
<a name="ln3285">/// command pointed to by eap-&gt;arg which should be of the form:</a>
<a name="ln3286">///</a>
<a name="ln3287">/// /pattern/substitution/{flags}</a>
<a name="ln3288">///</a>
<a name="ln3289">/// The usual escapes are supported as described in the regexp docs.</a>
<a name="ln3290">///</a>
<a name="ln3291">/// @param cmdpreview_ns  The namespace to show 'inccommand' preview highlights.</a>
<a name="ln3292">///                       If &lt;= 0, preview shouldn't be shown.</a>
<a name="ln3293">/// @return 0, 1 or 2. See show_cmdpreview() for more information on what the return value means.</a>
<a name="ln3294">static int do_sub(exarg_T *eap, const proftime_T timeout, const long cmdpreview_ns,</a>
<a name="ln3295">                  const handle_T cmdpreview_bufnr)</a>
<a name="ln3296">{</a>
<a name="ln3297">#define ADJUST_SUB_FIRSTLNUM() \</a>
<a name="ln3298">  do { \</a>
<a name="ln3299">    /* For a multi-line match, make a copy of the last matched */ \</a>
<a name="ln3300">    /* line and continue in that one. */ \</a>
<a name="ln3301">    if (nmatch &gt; 1) { \</a>
<a name="ln3302">      sub_firstlnum += (linenr_T)nmatch - 1; \</a>
<a name="ln3303">      xfree(sub_firstline); \</a>
<a name="ln3304">      sub_firstline = xstrdup(ml_get(sub_firstlnum)); \</a>
<a name="ln3305">      /* When going beyond the last line, stop substituting. */ \</a>
<a name="ln3306">      if (sub_firstlnum &lt;= line2) { \</a>
<a name="ln3307">        do_again = true; \</a>
<a name="ln3308">      } else { \</a>
<a name="ln3309">        subflags.do_all = false; \</a>
<a name="ln3310">      } \</a>
<a name="ln3311">    } \</a>
<a name="ln3312">    if (skip_match) { \</a>
<a name="ln3313">      /* Already hit end of the buffer, sub_firstlnum is one */ \</a>
<a name="ln3314">      /* less than what it ought to be. */ \</a>
<a name="ln3315">      xfree(sub_firstline); \</a>
<a name="ln3316">      sub_firstline = xstrdup(&quot;&quot;); \</a>
<a name="ln3317">      copycol = 0; \</a>
<a name="ln3318">    } \</a>
<a name="ln3319">  } while (0)</a>
<a name="ln3320"> </a>
<a name="ln3321">  long i = 0;</a>
<a name="ln3322">  regmmatch_T regmatch;</a>
<a name="ln3323">  static subflags_T subflags = {</a>
<a name="ln3324">    .do_all = false,</a>
<a name="ln3325">    .do_ask = false,</a>
<a name="ln3326">    .do_count = false,</a>
<a name="ln3327">    .do_error = true,</a>
<a name="ln3328">    .do_print = false,</a>
<a name="ln3329">    .do_list = false,</a>
<a name="ln3330">    .do_number = false,</a>
<a name="ln3331">    .do_ic = kSubHonorOptions</a>
<a name="ln3332">  };</a>
<a name="ln3333">  char *pat = NULL, *sub = NULL;  // init for GCC</a>
<a name="ln3334">  int delimiter;</a>
<a name="ln3335">  bool has_second_delim = false;</a>
<a name="ln3336">  int sublen;</a>
<a name="ln3337">  bool got_quit = false;</a>
<a name="ln3338">  bool got_match = false;</a>
<a name="ln3339">  int which_pat;</a>
<a name="ln3340">  char *cmd = eap-&gt;arg;</a>
<a name="ln3341">  linenr_T first_line = 0;  // first changed line</a>
<a name="ln3342">  linenr_T last_line= 0;    // below last changed line AFTER the change</a>
<a name="ln3343">  linenr_T old_line_count = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3344">  char *sub_firstline;    // allocated copy of first sub line</a>
<a name="ln3345">  bool endcolumn = false;   // cursor in last column when done</a>
<a name="ln3346">  PreviewLines preview_lines = { KV_INITIAL_VALUE, 0 };</a>
<a name="ln3347">  static int pre_hl_id = 0;</a>
<a name="ln3348">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3349">  long start_nsubs;</a>
<a name="ln3350"> </a>
<a name="ln3351">  bool did_save = false;</a>
<a name="ln3352"> </a>
<a name="ln3353">  if (!global_busy) {</a>
<a name="ln3354">    sub_nsubs = 0;</a>
<a name="ln3355">    sub_nlines = 0;</a>
<a name="ln3356">  }</a>
<a name="ln3357">  start_nsubs = sub_nsubs;</a>
<a name="ln3358"> </a>
<a name="ln3359">  if (eap-&gt;cmdidx == CMD_tilde) {</a>
<a name="ln3360">    which_pat = RE_LAST;        // use last used regexp</a>
<a name="ln3361">  } else {</a>
<a name="ln3362">    which_pat = RE_SUBST;       // use last substitute regexp</a>
<a name="ln3363">  }</a>
<a name="ln3364">  // new pattern and substitution</a>
<a name="ln3365">  if (eap-&gt;cmd[0] == 's' &amp;&amp; *cmd != NUL &amp;&amp; !ascii_iswhite(*cmd)</a>
<a name="ln3366">      &amp;&amp; vim_strchr(&quot;0123456789cegriIp|\&quot;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln3367">    // don't accept alphanumeric for separator</a>
<a name="ln3368">    if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln3369">      return 0;</a>
<a name="ln3370">    }</a>
<a name="ln3371"> </a>
<a name="ln3372">    // undocumented vi feature:</a>
<a name="ln3373">    //  &quot;\/sub/&quot; and &quot;\?sub?&quot; use last used search pattern (almost like</a>
<a name="ln3374">    //  //sub/r).  &quot;\&amp;sub&amp;&quot; use last substitute pattern (like //sub/).</a>
<a name="ln3375">    if (*cmd == '\\') {</a>
<a name="ln3376">      cmd++;</a>
<a name="ln3377">      if (vim_strchr(&quot;/?&amp;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln3378">        emsg(_(e_backslash));</a>
<a name="ln3379">        return 0;</a>
<a name="ln3380">      }</a>
<a name="ln3381">      if (*cmd != '&amp;') {</a>
<a name="ln3382">        which_pat = RE_SEARCH;              // use last '/' pattern</a>
<a name="ln3383">      }</a>
<a name="ln3384">      pat = &quot;&quot;;                   // empty search pattern</a>
<a name="ln3385">      delimiter = (uint8_t)(*cmd++);                   // remember delimiter character</a>
<a name="ln3386">      has_second_delim = true;</a>
<a name="ln3387">    } else {          // find the end of the regexp</a>
<a name="ln3388">      which_pat = RE_LAST;                  // use last used regexp</a>
<a name="ln3389">      delimiter = (uint8_t)(*cmd++);                   // remember delimiter character</a>
<a name="ln3390">      pat = cmd;                            // remember start of search pat</a>
<a name="ln3391">      cmd = skip_regexp_ex(cmd, delimiter, magic_isset(), &amp;eap-&gt;arg, NULL, NULL);</a>
<a name="ln3392">      if (cmd[0] == delimiter) {            // end delimiter found</a>
<a name="ln3393">        *cmd++ = NUL;                       // replace it with a NUL</a>
<a name="ln3394">        has_second_delim = true;</a>
<a name="ln3395">      }</a>
<a name="ln3396">    }</a>
<a name="ln3397"> </a>
<a name="ln3398">    // Small incompatibility: vi sees '\n' as end of the command, but in</a>
<a name="ln3399">    // Vim we want to use '\n' to find/substitute a NUL.</a>
<a name="ln3400">    sub = cmd;              // remember the start of the substitution</a>
<a name="ln3401"> </a>
<a name="ln3402">    while (cmd[0]) {</a>
<a name="ln3403">      if (cmd[0] == delimiter) {                // end delimiter found</a>
<a name="ln3404">        *cmd++ = NUL;                           // replace it with a NUL</a>
<a name="ln3405">        break;</a>
<a name="ln3406">      }</a>
<a name="ln3407">      if (cmd[0] == '\\' &amp;&amp; cmd[1] != 0) {      // skip escaped characters</a>
<a name="ln3408">        cmd++;</a>
<a name="ln3409">      }</a>
<a name="ln3410">      MB_PTR_ADV(cmd);</a>
<a name="ln3411">    }</a>
<a name="ln3412"> </a>
<a name="ln3413">    if (!eap-&gt;skip &amp;&amp; cmdpreview_ns &lt;= 0) {</a>
<a name="ln3414">      sub_set_replacement((SubReplacementString) {</a>
<a name="ln3415">        .sub = xstrdup(sub),</a>
<a name="ln3416">        .timestamp = os_time(),</a>
<a name="ln3417">        .additional_elements = NULL,</a>
<a name="ln3418">      });</a>
<a name="ln3419">    }</a>
<a name="ln3420">  } else if (!eap-&gt;skip) {    // use previous pattern and substitution</a>
<a name="ln3421">    if (old_sub.sub == NULL) {      // there is no previous command</a>
<a name="ln3422">      emsg(_(e_nopresub));</a>
<a name="ln3423">      return 0;</a>
<a name="ln3424">    }</a>
<a name="ln3425">    pat = NULL;                 // search_regcomp() will use previous pattern</a>
<a name="ln3426">    sub = old_sub.sub;</a>
<a name="ln3427"> </a>
<a name="ln3428">    // Vi compatibility quirk: repeating with &quot;:s&quot; keeps the cursor in the</a>
<a name="ln3429">    // last column after using &quot;$&quot;.</a>
<a name="ln3430">    endcolumn = (curwin-&gt;w_curswant == MAXCOL);</a>
<a name="ln3431">  }</a>
<a name="ln3432"> </a>
<a name="ln3433">  if (sub != NULL &amp;&amp; sub_joining_lines(eap, pat, sub, cmd, cmdpreview_ns &lt;= 0)) {</a>
<a name="ln3434">    return 0;</a>
<a name="ln3435">  }</a>
<a name="ln3436"> </a>
<a name="ln3437">  cmd = sub_parse_flags(cmd, &amp;subflags, &amp;which_pat);</a>
<a name="ln3438"> </a>
<a name="ln3439">  bool save_do_all = subflags.do_all;  // remember user specified 'g' flag</a>
<a name="ln3440">  bool save_do_ask = subflags.do_ask;  // remember user specified 'c' flag</a>
<a name="ln3441"> </a>
<a name="ln3442">  // check for a trailing count</a>
<a name="ln3443">  cmd = skipwhite(cmd);</a>
<a name="ln3444">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3445">    i = getdigits_long(&amp;cmd, true, 0);</a>
<a name="ln3446">    if (i &lt;= 0 &amp;&amp; !eap-&gt;skip &amp;&amp; subflags.do_error) {</a>
<a name="ln3447">      emsg(_(e_zerocount));</a>
<a name="ln3448">      return 0;</a>
<a name="ln3449">    }</a>
<a name="ln3450">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln3451">    eap-&gt;line2 += (linenr_T)i - 1;</a>
<a name="ln3452">    if (eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3453">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3454">    }</a>
<a name="ln3455">  }</a>
<a name="ln3456"> </a>
<a name="ln3457">  // check for trailing command or garbage</a>
<a name="ln3458">  cmd = skipwhite(cmd);</a>
<a name="ln3459">  if (*cmd &amp;&amp; *cmd != '&quot;') {        // if not end-of-line or comment</a>
<a name="ln3460">    eap-&gt;nextcmd = check_nextcmd(cmd);</a>
<a name="ln3461">    if (eap-&gt;nextcmd == NULL) {</a>
<a name="ln3462">      semsg(_(e_trailing_arg), cmd);</a>
<a name="ln3463">      return 0;</a>
<a name="ln3464">    }</a>
<a name="ln3465">  }</a>
<a name="ln3466"> </a>
<a name="ln3467">  if (eap-&gt;skip) {          // not executing commands, only parsing</a>
<a name="ln3468">    return 0;</a>
<a name="ln3469">  }</a>
<a name="ln3470"> </a>
<a name="ln3471">  if (!subflags.do_count &amp;&amp; !MODIFIABLE(curbuf)) {</a>
<a name="ln3472">    // Substitution is not allowed in non-'modifiable' buffer</a>
<a name="ln3473">    emsg(_(e_modifiable));</a>
<a name="ln3474">    return 0;</a>
<a name="ln3475">  }</a>
<a name="ln3476"> </a>
<a name="ln3477">  if (search_regcomp(pat, NULL, RE_SUBST, which_pat,</a>
<a name="ln3478">                     (cmdpreview_ns &gt; 0 ? 0 : SEARCH_HIS), &amp;regmatch) == FAIL) {</a>
<a name="ln3479">    if (subflags.do_error) {</a>
<a name="ln3480">      emsg(_(e_invcmd));</a>
<a name="ln3481">    }</a>
<a name="ln3482">    return 0;</a>
<a name="ln3483">  }</a>
<a name="ln3484"> </a>
<a name="ln3485">  // the 'i' or 'I' flag overrules 'ignorecase' and 'smartcase'</a>
<a name="ln3486">  if (subflags.do_ic == kSubIgnoreCase) {</a>
<a name="ln3487">    regmatch.rmm_ic = true;</a>
<a name="ln3488">  } else if (subflags.do_ic == kSubMatchCase) {</a>
<a name="ln3489">    regmatch.rmm_ic = false;</a>
<a name="ln3490">  }</a>
<a name="ln3491"> </a>
<a name="ln3492">  sub_firstline = NULL;</a>
<a name="ln3493"> </a>
<a name="ln3494">  assert(sub != NULL);</a>
<a name="ln3495"> </a>
<a name="ln3496">  char *sub_copy = NULL;</a>
<a name="ln3497"> </a>
<a name="ln3498">  // If the substitute pattern starts with &quot;\=&quot; then it's an expression.</a>
<a name="ln3499">  // Make a copy, a recursive function may free it.</a>
<a name="ln3500">  // Otherwise, '~' in the substitute pattern is replaced with the old</a>
<a name="ln3501">  // pattern.  We do it here once to avoid it to be replaced over and over</a>
<a name="ln3502">  // again.</a>
<a name="ln3503">  if (sub[0] == '\\' &amp;&amp; sub[1] == '=') {</a>
<a name="ln3504">    sub = xstrdup(sub);</a>
<a name="ln3505">    sub_copy = sub;</a>
<a name="ln3506">  } else {</a>
<a name="ln3507">    char *newsub = regtilde(sub, magic_isset(), cmdpreview_ns &gt; 0);</a>
<a name="ln3508">    if (newsub != sub) {</a>
<a name="ln3509">      // newsub was allocated, free it later.</a>
<a name="ln3510">      sub_copy = newsub;</a>
<a name="ln3511">      sub = newsub;</a>
<a name="ln3512">    }</a>
<a name="ln3513">  }</a>
<a name="ln3514"> </a>
<a name="ln3515">  // Check for a match on each line.</a>
<a name="ln3516">  // If preview: limit to max('cmdwinheight', viewport).</a>
<a name="ln3517">  linenr_T line2 = eap-&gt;line2;</a>
<a name="ln3518"> </a>
<a name="ln3519">  for (linenr_T lnum = eap-&gt;line1;</a>
<a name="ln3520">       lnum &lt;= line2 &amp;&amp; !got_quit &amp;&amp; !aborting()</a>
<a name="ln3521">       &amp;&amp; (cmdpreview_ns &lt;= 0 || preview_lines.lines_needed &lt;= (linenr_T)p_cwh</a>
<a name="ln3522">           || lnum &lt;= curwin-&gt;w_botline);</a>
<a name="ln3523">       lnum++) {</a>
<a name="ln3524">    long nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum,</a>
<a name="ln3525">                                    (colnr_T)0, NULL, NULL);</a>
<a name="ln3526">    if (nmatch) {</a>
<a name="ln3527">      colnr_T copycol;</a>
<a name="ln3528">      colnr_T matchcol;</a>
<a name="ln3529">      colnr_T prev_matchcol = MAXCOL;</a>
<a name="ln3530">      char *new_end, *new_start = NULL;</a>
<a name="ln3531">      int new_start_len = 0;</a>
<a name="ln3532">      char *p1;</a>
<a name="ln3533">      bool did_sub = false;</a>
<a name="ln3534">      int lastone;</a>
<a name="ln3535">      long nmatch_tl = 0;               // nr of lines matched below lnum</a>
<a name="ln3536">      int do_again;                     // do it again after joining lines</a>
<a name="ln3537">      bool skip_match = false;</a>
<a name="ln3538">      linenr_T sub_firstlnum;           // nr of first sub line</a>
<a name="ln3539"> </a>
<a name="ln3540">      // The new text is build up step by step, to avoid too much</a>
<a name="ln3541">      // copying.  There are these pieces:</a>
<a name="ln3542">      // sub_firstline  The old text, unmodified.</a>
<a name="ln3543">      // copycol                Column in the old text where we started</a>
<a name="ln3544">      //                        looking for a match; from here old text still</a>
<a name="ln3545">      //                        needs to be copied to the new text.</a>
<a name="ln3546">      // matchcol               Column number of the old text where to look</a>
<a name="ln3547">      //                        for the next match.  It's just after the</a>
<a name="ln3548">      //                        previous match or one further.</a>
<a name="ln3549">      // prev_matchcol  Column just after the previous match (if any).</a>
<a name="ln3550">      //                        Mostly equal to matchcol, except for the first</a>
<a name="ln3551">      //                        match and after skipping an empty match.</a>
<a name="ln3552">      // regmatch.*pos  Where the pattern matched in the old text.</a>
<a name="ln3553">      // new_start      The new text, all that has been produced so</a>
<a name="ln3554">      //                        far.</a>
<a name="ln3555">      // new_end                The new text, where to append new text.</a>
<a name="ln3556">      //</a>
<a name="ln3557">      // lnum           The line number where we found the start of</a>
<a name="ln3558">      //                        the match.  Can be below the line we searched</a>
<a name="ln3559">      //                        when there is a \n before a \zs in the</a>
<a name="ln3560">      //                        pattern.</a>
<a name="ln3561">      // sub_firstlnum  The line number in the buffer where to look</a>
<a name="ln3562">      //                        for a match.  Can be different from &quot;lnum&quot;</a>
<a name="ln3563">      //                        when the pattern or substitute string contains</a>
<a name="ln3564">      //                        line breaks.</a>
<a name="ln3565">      //</a>
<a name="ln3566">      // Special situations:</a>
<a name="ln3567">      // - When the substitute string contains a line break, the part up</a>
<a name="ln3568">      //   to the line break is inserted in the text, but the copy of</a>
<a name="ln3569">      //   the original line is kept.  &quot;sub_firstlnum&quot; is adjusted for</a>
<a name="ln3570">      //   the inserted lines.</a>
<a name="ln3571">      // - When the matched pattern contains a line break, the old line</a>
<a name="ln3572">      //   is taken from the line at the end of the pattern.  The lines</a>
<a name="ln3573">      //   in the match are deleted later, &quot;sub_firstlnum&quot; is adjusted</a>
<a name="ln3574">      //   accordingly.</a>
<a name="ln3575">      //</a>
<a name="ln3576">      // The new text is built up in new_start[].  It has some extra</a>
<a name="ln3577">      // room to avoid using xmalloc()/free() too often.  new_start_len is</a>
<a name="ln3578">      // the length of the allocated memory at new_start.</a>
<a name="ln3579">      //</a>
<a name="ln3580">      // Make a copy of the old line, so it won't be taken away when</a>
<a name="ln3581">      // updating the screen or handling a multi-line match.  The &quot;old_&quot;</a>
<a name="ln3582">      // pointers point into this copy.</a>
<a name="ln3583">      sub_firstlnum = lnum;</a>
<a name="ln3584">      copycol = 0;</a>
<a name="ln3585">      matchcol = 0;</a>
<a name="ln3586"> </a>
<a name="ln3587">      // At first match, remember current cursor position.</a>
<a name="ln3588">      if (!got_match) {</a>
<a name="ln3589">        setpcmark();</a>
<a name="ln3590">        got_match = true;</a>
<a name="ln3591">      }</a>
<a name="ln3592"> </a>
<a name="ln3593">      // Loop until nothing more to replace in this line.</a>
<a name="ln3594">      // 1. Handle match with empty string.</a>
<a name="ln3595">      // 2. If subflags.do_ask is set, ask for confirmation.</a>
<a name="ln3596">      // 3. substitute the string.</a>
<a name="ln3597">      // 4. if subflags.do_all is set, find next match</a>
<a name="ln3598">      // 5. break if there isn't another match in this line</a>
<a name="ln3599">      while (true) {</a>
<a name="ln3600">        SubResult current_match = {</a>
<a name="ln3601">          .start = { 0, 0 },</a>
<a name="ln3602">          .end   = { 0, 0 },</a>
<a name="ln3603">          .pre_match = 0,</a>
<a name="ln3604">        };</a>
<a name="ln3605">        // lnum is where the match start, but maybe not the pattern match,</a>
<a name="ln3606">        // since we can have \n before \zs in the pattern</a>
<a name="ln3607"> </a>
<a name="ln3608">        // Advance &quot;lnum&quot; to the line where the match starts.  The</a>
<a name="ln3609">        // match does not start in the first line when there is a line</a>
<a name="ln3610">        // break before \zs.</a>
<a name="ln3611">        if (regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln3612">          current_match.pre_match = lnum;</a>
<a name="ln3613">          lnum += regmatch.startpos[0].lnum;</a>
<a name="ln3614">          sub_firstlnum += regmatch.startpos[0].lnum;</a>
<a name="ln3615">          nmatch -= regmatch.startpos[0].lnum;</a>
<a name="ln3616">          XFREE_CLEAR(sub_firstline);</a>
<a name="ln3617">        }</a>
<a name="ln3618"> </a>
<a name="ln3619">        // Now we're at the line where the pattern match starts</a>
<a name="ln3620">        // Note: If not first match on a line, column can't be known here</a>
<a name="ln3621">        current_match.start.lnum = sub_firstlnum;</a>
<a name="ln3622"> </a>
<a name="ln3623">        // Match might be after the last line for &quot;\n\zs&quot; matching at</a>
<a name="ln3624">        // the end of the last line.</a>
<a name="ln3625">        if (lnum &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3626">          break;</a>
<a name="ln3627">        }</a>
<a name="ln3628">        if (sub_firstline == NULL) {</a>
<a name="ln3629">          sub_firstline = xstrdup(ml_get(sub_firstlnum));</a>
<a name="ln3630">        }</a>
<a name="ln3631"> </a>
<a name="ln3632">        // Save the line number of the last change for the final</a>
<a name="ln3633">        // cursor position (just like Vi).</a>
<a name="ln3634">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln3635">        do_again = false;</a>
<a name="ln3636"> </a>
<a name="ln3637">        // 1. Match empty string does not count, except for first</a>
<a name="ln3638">        // match.  This reproduces the strange vi behaviour.</a>
<a name="ln3639">        // This also catches endless loops.</a>
<a name="ln3640">        if (matchcol == prev_matchcol</a>
<a name="ln3641">            &amp;&amp; regmatch.endpos[0].lnum == 0</a>
<a name="ln3642">            &amp;&amp; matchcol == regmatch.endpos[0].col) {</a>
<a name="ln3643">          if (sub_firstline[matchcol] == NUL) {</a>
<a name="ln3644">            // We already were at the end of the line.  Don't look</a>
<a name="ln3645">            // for a match in this line again.</a>
<a name="ln3646">            skip_match = true;</a>
<a name="ln3647">          } else {</a>
<a name="ln3648">            // search for a match at next column</a>
<a name="ln3649">            matchcol += utfc_ptr2len(sub_firstline + matchcol);</a>
<a name="ln3650">          }</a>
<a name="ln3651">          // match will be pushed to preview_lines, bring it into a proper state</a>
<a name="ln3652">          current_match.start.col = matchcol;</a>
<a name="ln3653">          current_match.end.lnum = sub_firstlnum;</a>
<a name="ln3654">          current_match.end.col = matchcol;</a>
<a name="ln3655">          goto skip;</a>
<a name="ln3656">        }</a>
<a name="ln3657"> </a>
<a name="ln3658">        // Normally we continue searching for a match just after the</a>
<a name="ln3659">        // previous match.</a>
<a name="ln3660">        matchcol = regmatch.endpos[0].col;</a>
<a name="ln3661">        prev_matchcol = matchcol;</a>
<a name="ln3662"> </a>
<a name="ln3663">        // 2. If subflags.do_count is set only increase the counter.</a>
<a name="ln3664">        //    If do_ask is set, ask for confirmation.</a>
<a name="ln3665">        if (subflags.do_count) {</a>
<a name="ln3666">          // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3667">          // the end of the line and set nmatch to one, so that</a>
<a name="ln3668">          // we continue looking for a match on the next line.</a>
<a name="ln3669">          // Avoids that &quot;:s/\nB\@=//gc&quot; get stuck.</a>
<a name="ln3670">          if (nmatch &gt; 1) {</a>
<a name="ln3671">            matchcol = (colnr_T)strlen(sub_firstline);</a>
<a name="ln3672">            nmatch = 1;</a>
<a name="ln3673">            skip_match = true;</a>
<a name="ln3674">          }</a>
<a name="ln3675">          sub_nsubs++;</a>
<a name="ln3676">          did_sub = true;</a>
<a name="ln3677">          // Skip the substitution, unless an expression is used,</a>
<a name="ln3678">          // then it is evaluated in the sandbox.</a>
<a name="ln3679">          if (!(sub[0] == '\\' &amp;&amp; sub[1] == '=')) {</a>
<a name="ln3680">            goto skip;</a>
<a name="ln3681">          }</a>
<a name="ln3682">        }</a>
<a name="ln3683"> </a>
<a name="ln3684">        if (subflags.do_ask &amp;&amp; cmdpreview_ns &lt;= 0) {</a>
<a name="ln3685">          int typed = 0;</a>
<a name="ln3686"> </a>
<a name="ln3687">          // change State to MODE_CONFIRM, so that the mouse works</a>
<a name="ln3688">          // properly</a>
<a name="ln3689">          int save_State = State;</a>
<a name="ln3690">          State = MODE_CONFIRM;</a>
<a name="ln3691">          setmouse();                   // disable mouse in xterm</a>
<a name="ln3692">          curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3693"> </a>
<a name="ln3694">          if (curwin-&gt;w_p_crb) {</a>
<a name="ln3695">            do_check_cursorbind();</a>
<a name="ln3696">          }</a>
<a name="ln3697"> </a>
<a name="ln3698">          // When 'cpoptions' contains &quot;u&quot; don't sync undo when</a>
<a name="ln3699">          // asking for confirmation.</a>
<a name="ln3700">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL) {</a>
<a name="ln3701">            no_u_sync++;</a>
<a name="ln3702">          }</a>
<a name="ln3703"> </a>
<a name="ln3704">          // Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed.</a>
<a name="ln3705">          while (subflags.do_ask) {</a>
<a name="ln3706">            if (exmode_active) {</a>
<a name="ln3707">              char *prompt;</a>
<a name="ln3708">              char *resp;</a>
<a name="ln3709">              colnr_T sc, ec;</a>
<a name="ln3710"> </a>
<a name="ln3711">              print_line_no_prefix(lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln3712"> </a>
<a name="ln3713">              getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;sc, NULL, NULL);</a>
<a name="ln3714">              curwin-&gt;w_cursor.col = regmatch.endpos[0].col - 1;</a>
<a name="ln3715">              if (curwin-&gt;w_cursor.col &lt; 0) {</a>
<a name="ln3716">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3717">              }</a>
<a name="ln3718">              getvcol(curwin, &amp;curwin-&gt;w_cursor, NULL, NULL, &amp;ec);</a>
<a name="ln3719">              curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3720">              if (subflags.do_number || curwin-&gt;w_p_nu) {</a>
<a name="ln3721">                int numw = number_width(curwin) + 1;</a>
<a name="ln3722">                sc += numw;</a>
<a name="ln3723">                ec += numw;</a>
<a name="ln3724">              }</a>
<a name="ln3725"> </a>
<a name="ln3726">              prompt = xmallocz((size_t)ec + 1);</a>
<a name="ln3727">              memset(prompt, ' ', (size_t)sc);</a>
<a name="ln3728">              memset(prompt + sc, '^', (size_t)(ec - sc) + 1);</a>
<a name="ln3729">              resp = getcmdline_prompt(-1, prompt, 0, EXPAND_NOTHING, NULL, CALLBACK_NONE);</a>
<a name="ln3730">              msg_putchar('\n');</a>
<a name="ln3731">              xfree(prompt);</a>
<a name="ln3732">              if (resp != NULL) {</a>
<a name="ln3733">                typed = (uint8_t)(*resp);</a>
<a name="ln3734">                xfree(resp);</a>
<a name="ln3735">              } else {</a>
<a name="ln3736">                // getcmdline_prompt() returns NULL if there is no command line to return.</a>
<a name="ln3737">                typed = NUL;</a>
<a name="ln3738">              }</a>
<a name="ln3739">              // When &quot;:normal&quot; runs out of characters we get</a>
<a name="ln3740">              // an empty line.  Use &quot;q&quot; to get out of the</a>
<a name="ln3741">              // loop.</a>
<a name="ln3742">              if (ex_normal_busy &amp;&amp; typed == NUL) {</a>
<a name="ln3743">                typed = 'q';</a>
<a name="ln3744">              }</a>
<a name="ln3745">            } else {</a>
<a name="ln3746">              char *orig_line = NULL;</a>
<a name="ln3747">              int len_change = 0;</a>
<a name="ln3748">              const bool save_p_lz = p_lz;</a>
<a name="ln3749">              int save_p_fen = curwin-&gt;w_p_fen;</a>
<a name="ln3750"> </a>
<a name="ln3751">              curwin-&gt;w_p_fen = false;</a>
<a name="ln3752">              // Invert the matched string.</a>
<a name="ln3753">              // Remove the inversion afterwards.</a>
<a name="ln3754">              int temp = RedrawingDisabled;</a>
<a name="ln3755">              RedrawingDisabled = 0;</a>
<a name="ln3756"> </a>
<a name="ln3757">              // avoid calling update_screen() in vgetorpeek()</a>
<a name="ln3758">              p_lz = false;</a>
<a name="ln3759"> </a>
<a name="ln3760">              if (new_start != NULL) {</a>
<a name="ln3761">                // There already was a substitution, we would</a>
<a name="ln3762">                // like to show this to the user.  We cannot</a>
<a name="ln3763">                // really update the line, it would change</a>
<a name="ln3764">                // what matches.  Temporarily replace the line</a>
<a name="ln3765">                // and change it back afterwards.</a>
<a name="ln3766">                orig_line = xstrdup(ml_get(lnum));</a>
<a name="ln3767">                char *new_line = concat_str(new_start, sub_firstline + copycol);</a>
<a name="ln3768"> </a>
<a name="ln3769">                // Position the cursor relative to the end of the line, the</a>
<a name="ln3770">                // previous substitute may have inserted or deleted characters</a>
<a name="ln3771">                // before the cursor.</a>
<a name="ln3772">                len_change = (int)strlen(new_line) - (int)strlen(orig_line);</a>
<a name="ln3773">                curwin-&gt;w_cursor.col += len_change;</a>
<a name="ln3774">                ml_replace(lnum, new_line, false);</a>
<a name="ln3775">              }</a>
<a name="ln3776"> </a>
<a name="ln3777">              search_match_lines = regmatch.endpos[0].lnum</a>
<a name="ln3778">                                   - regmatch.startpos[0].lnum;</a>
<a name="ln3779">              search_match_endcol = regmatch.endpos[0].col</a>
<a name="ln3780">                                    + len_change;</a>
<a name="ln3781">              if (search_match_lines == 0 &amp;&amp; search_match_endcol == 0) {</a>
<a name="ln3782">                // highlight at least one character for /^/</a>
<a name="ln3783">                search_match_endcol = 1;</a>
<a name="ln3784">              }</a>
<a name="ln3785">              highlight_match = true;</a>
<a name="ln3786"> </a>
<a name="ln3787">              update_topline(curwin);</a>
<a name="ln3788">              validate_cursor();</a>
<a name="ln3789">              redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln3790">              show_cursor_info_later(true);</a>
<a name="ln3791">              update_screen();</a>
<a name="ln3792">              highlight_match = false;</a>
<a name="ln3793">              redraw_later(curwin, UPD_SOME_VALID);</a>
<a name="ln3794"> </a>
<a name="ln3795">              curwin-&gt;w_p_fen = save_p_fen;</a>
<a name="ln3796">              if (msg_row == Rows - 1) {</a>
<a name="ln3797">                msg_didout = false;                     // avoid a scroll-up</a>
<a name="ln3798">              }</a>
<a name="ln3799">              msg_starthere();</a>
<a name="ln3800">              i = msg_scroll;</a>
<a name="ln3801">              msg_scroll = 0;                           // truncate msg when</a>
<a name="ln3802">                                                        // needed</a>
<a name="ln3803">              msg_no_more = true;</a>
<a name="ln3804">              msg_ext_set_kind(&quot;confirm_sub&quot;);</a>
<a name="ln3805">              // Same highlight as wait_return().</a>
<a name="ln3806">              smsg(HL_ATTR(HLF_R), _(&quot;replace with %s (y/n/a/q/l/^E/^Y)?&quot;), sub);</a>
<a name="ln3807">              msg_no_more = false;</a>
<a name="ln3808">              msg_scroll = (int)i;</a>
<a name="ln3809">              if (!ui_has(kUIMessages)) {</a>
<a name="ln3810">                ui_cursor_goto(msg_row, msg_col);</a>
<a name="ln3811">              }</a>
<a name="ln3812">              RedrawingDisabled = temp;</a>
<a name="ln3813"> </a>
<a name="ln3814">              no_mapping++;                     // don't map this key</a>
<a name="ln3815">              allow_keys++;                     // allow special keys</a>
<a name="ln3816">              typed = plain_vgetc();</a>
<a name="ln3817">              no_mapping--;</a>
<a name="ln3818">              allow_keys--;</a>
<a name="ln3819"> </a>
<a name="ln3820">              // clear the question</a>
<a name="ln3821">              msg_didout = false;               // don't scroll up</a>
<a name="ln3822">              msg_col = 0;</a>
<a name="ln3823">              gotocmdline(true);</a>
<a name="ln3824">              p_lz = save_p_lz;</a>
<a name="ln3825"> </a>
<a name="ln3826">              // restore the line</a>
<a name="ln3827">              if (orig_line != NULL) {</a>
<a name="ln3828">                ml_replace(lnum, orig_line, false);</a>
<a name="ln3829">              }</a>
<a name="ln3830">            }</a>
<a name="ln3831"> </a>
<a name="ln3832">            need_wait_return = false;             // no hit-return prompt</a>
<a name="ln3833">            if (typed == 'q' || typed == ESC || typed == Ctrl_C) {</a>
<a name="ln3834">              got_quit = true;</a>
<a name="ln3835">              break;</a>
<a name="ln3836">            }</a>
<a name="ln3837">            if (typed == 'n') {</a>
<a name="ln3838">              break;</a>
<a name="ln3839">            }</a>
<a name="ln3840">            if (typed == 'y') {</a>
<a name="ln3841">              break;</a>
<a name="ln3842">            }</a>
<a name="ln3843">            if (typed == 'l') {</a>
<a name="ln3844">              // last: replace and then stop</a>
<a name="ln3845">              subflags.do_all = false;</a>
<a name="ln3846">              line2 = lnum;</a>
<a name="ln3847">              break;</a>
<a name="ln3848">            }</a>
<a name="ln3849">            if (typed == 'a') {</a>
<a name="ln3850">              subflags.do_ask = false;</a>
<a name="ln3851">              break;</a>
<a name="ln3852">            }</a>
<a name="ln3853">            if (typed == Ctrl_E) {</a>
<a name="ln3854">              scrollup_clamp();</a>
<a name="ln3855">            } else if (typed == Ctrl_Y) {</a>
<a name="ln3856">              scrolldown_clamp();</a>
<a name="ln3857">            }</a>
<a name="ln3858">          }</a>
<a name="ln3859">          State = save_State;</a>
<a name="ln3860">          setmouse();</a>
<a name="ln3861">          if (vim_strchr(p_cpo, CPO_UNDO) != NULL) {</a>
<a name="ln3862">            no_u_sync--;</a>
<a name="ln3863">          }</a>
<a name="ln3864"> </a>
<a name="ln3865">          if (typed == 'n') {</a>
<a name="ln3866">            // For a multi-line match, put matchcol at the NUL at</a>
<a name="ln3867">            // the end of the line and set nmatch to one, so that</a>
<a name="ln3868">            // we continue looking for a match on the next line.</a>
<a name="ln3869">            // Avoids that &quot;:%s/\nB\@=//gc&quot; and &quot;:%s/\n/,\r/gc&quot;</a>
<a name="ln3870">            // get stuck when pressing 'n'.</a>
<a name="ln3871">            if (nmatch &gt; 1) {</a>
<a name="ln3872">              matchcol = (colnr_T)strlen(sub_firstline);</a>
<a name="ln3873">              skip_match = true;</a>
<a name="ln3874">            }</a>
<a name="ln3875">            goto skip;</a>
<a name="ln3876">          }</a>
<a name="ln3877">          if (got_quit) {</a>
<a name="ln3878">            goto skip;</a>
<a name="ln3879">          }</a>
<a name="ln3880">        }</a>
<a name="ln3881"> </a>
<a name="ln3882">        // Move the cursor to the start of the match, so that we can</a>
<a name="ln3883">        // use &quot;\=col(&quot;.&quot;).</a>
<a name="ln3884">        curwin-&gt;w_cursor.col = regmatch.startpos[0].col;</a>
<a name="ln3885"> </a>
<a name="ln3886">        // When the match included the &quot;$&quot; of the last line it may</a>
<a name="ln3887">        // go beyond the last line of the buffer.</a>
<a name="ln3888">        if (nmatch &gt; curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1) {</a>
<a name="ln3889">          nmatch = curbuf-&gt;b_ml.ml_line_count - sub_firstlnum + 1;</a>
<a name="ln3890">          current_match.end.lnum = sub_firstlnum + (linenr_T)nmatch;</a>
<a name="ln3891">          skip_match = true;</a>
<a name="ln3892">          // safety check</a>
<a name="ln3893">          if (nmatch &lt; 0) {</a>
<a name="ln3894">            goto skip;</a>
<a name="ln3895">          }</a>
<a name="ln3896">        }</a>
<a name="ln3897"> </a>
<a name="ln3898">        // Save the line numbers for the preview buffer</a>
<a name="ln3899">        // NOTE: If the pattern matches a final newline, the next line will</a>
<a name="ln3900">        // be shown also, but should not be highlighted. Intentional for now.</a>
<a name="ln3901">        if (cmdpreview_ns &gt; 0 &amp;&amp; !has_second_delim) {</a>
<a name="ln3902">          current_match.start.col = regmatch.startpos[0].col;</a>
<a name="ln3903">          if (current_match.end.lnum == 0) {</a>
<a name="ln3904">            current_match.end.lnum = sub_firstlnum + (linenr_T)nmatch - 1;</a>
<a name="ln3905">          }</a>
<a name="ln3906">          current_match.end.col  = regmatch.endpos[0].col;</a>
<a name="ln3907"> </a>
<a name="ln3908">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3909">          lnum += (linenr_T)nmatch - 1;</a>
<a name="ln3910"> </a>
<a name="ln3911">          goto skip;</a>
<a name="ln3912">        }</a>
<a name="ln3913"> </a>
<a name="ln3914">        // 3. Substitute the string. During 'inccommand' preview only do this if</a>
<a name="ln3915">        //    there is a replace pattern.</a>
<a name="ln3916">        if (cmdpreview_ns &lt;= 0 || has_second_delim) {</a>
<a name="ln3917">          linenr_T lnum_start = lnum;  // save the start lnum</a>
<a name="ln3918">          int save_ma = curbuf-&gt;b_p_ma;</a>
<a name="ln3919">          int save_sandbox = sandbox;</a>
<a name="ln3920">          if (subflags.do_count) {</a>
<a name="ln3921">            // prevent accidentally changing the buffer by a function</a>
<a name="ln3922">            curbuf-&gt;b_p_ma = false;</a>
<a name="ln3923">            sandbox++;</a>
<a name="ln3924">          }</a>
<a name="ln3925">          // Save flags for recursion.  They can change for e.g.</a>
<a name="ln3926">          // :s/^/\=execute(&quot;s#^##gn&quot;)</a>
<a name="ln3927">          subflags_T subflags_save = subflags;</a>
<a name="ln3928"> </a>
<a name="ln3929">          // Disallow changing text or switching window in an expression.</a>
<a name="ln3930">          textlock++;</a>
<a name="ln3931">          // Get length of substitution part, including the NUL.</a>
<a name="ln3932">          // When it fails sublen is zero.</a>
<a name="ln3933">          sublen = vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3934">                                    sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3935">                                    sub, sub_firstline, 0,</a>
<a name="ln3936">                                    REGSUB_BACKSLASH</a>
<a name="ln3937">                                    | (magic_isset() ? REGSUB_MAGIC : 0));</a>
<a name="ln3938">          textlock--;</a>
<a name="ln3939"> </a>
<a name="ln3940">          // If getting the substitute string caused an error, don't do</a>
<a name="ln3941">          // the replacement.</a>
<a name="ln3942">          // Don't keep flags set by a recursive call</a>
<a name="ln3943">          subflags = subflags_save;</a>
<a name="ln3944">          if (sublen == 0 || aborting() || subflags.do_count) {</a>
<a name="ln3945">            curbuf-&gt;b_p_ma = save_ma;</a>
<a name="ln3946">            sandbox = save_sandbox;</a>
<a name="ln3947">            goto skip;</a>
<a name="ln3948">          }</a>
<a name="ln3949"> </a>
<a name="ln3950">          // Need room for:</a>
<a name="ln3951">          // - result so far in new_start (not for first sub in line)</a>
<a name="ln3952">          // - original text up to match</a>
<a name="ln3953">          // - length of substituted part</a>
<a name="ln3954">          // - original text after match</a>
<a name="ln3955">          if (nmatch == 1) {</a>
<a name="ln3956">            p1 = sub_firstline;</a>
<a name="ln3957">          } else {</a>
<a name="ln3958">            p1 = ml_get(sub_firstlnum + (linenr_T)nmatch - 1);</a>
<a name="ln3959">            nmatch_tl += nmatch - 1;</a>
<a name="ln3960">          }</a>
<a name="ln3961">          int copy_len = regmatch.startpos[0].col - copycol;</a>
<a name="ln3962">          new_end = sub_grow_buf(&amp;new_start, &amp;new_start_len,</a>
<a name="ln3963">                                 (colnr_T)strlen(p1) - regmatch.endpos[0].col</a>
<a name="ln3964">                                 + copy_len + sublen + 1);</a>
<a name="ln3965"> </a>
<a name="ln3966">          // copy the text up to the part that matched</a>
<a name="ln3967">          memmove(new_end, sub_firstline + copycol, (size_t)copy_len);</a>
<a name="ln3968">          new_end += copy_len;</a>
<a name="ln3969"> </a>
<a name="ln3970">          if (new_start_len - copy_len &lt; sublen) {</a>
<a name="ln3971">            sublen = new_start_len - copy_len - 1;</a>
<a name="ln3972">          }</a>
<a name="ln3973"> </a>
<a name="ln3974">          // Finally, at this point we can know where the match actually will</a>
<a name="ln3975">          // start in the new text</a>
<a name="ln3976">          int start_col = (int)(new_end - new_start);</a>
<a name="ln3977">          current_match.start.col = start_col;</a>
<a name="ln3978"> </a>
<a name="ln3979">          textlock++;</a>
<a name="ln3980">          (void)vim_regsub_multi(&amp;regmatch,</a>
<a name="ln3981">                                 sub_firstlnum - regmatch.startpos[0].lnum,</a>
<a name="ln3982">                                 sub, new_end, sublen,</a>
<a name="ln3983">                                 REGSUB_COPY | REGSUB_BACKSLASH</a>
<a name="ln3984">                                 | (magic_isset() ? REGSUB_MAGIC : 0));</a>
<a name="ln3985">          textlock--;</a>
<a name="ln3986">          sub_nsubs++;</a>
<a name="ln3987">          did_sub = true;</a>
<a name="ln3988"> </a>
<a name="ln3989">          // Move the cursor to the start of the line, to avoid that it</a>
<a name="ln3990">          // is beyond the end of the line after the substitution.</a>
<a name="ln3991">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3992"> </a>
<a name="ln3993">          // Remember next character to be copied.</a>
<a name="ln3994">          copycol = regmatch.endpos[0].col;</a>
<a name="ln3995"> </a>
<a name="ln3996">          ADJUST_SUB_FIRSTLNUM();</a>
<a name="ln3997"> </a>
<a name="ln3998">          // TODO(bfredl): this has some robustness issues, look into later.</a>
<a name="ln3999">          bcount_t replaced_bytes = 0;</a>
<a name="ln4000">          lpos_T start = regmatch.startpos[0], end = regmatch.endpos[0];</a>
<a name="ln4001">          for (i = 0; i &lt; nmatch - 1; i++) {</a>
<a name="ln4002">            replaced_bytes += (bcount_t)strlen(ml_get((linenr_T)(lnum_start + i))) + 1;</a>
<a name="ln4003">          }</a>
<a name="ln4004">          replaced_bytes += end.col - start.col;</a>
<a name="ln4005"> </a>
<a name="ln4006">          // Now the trick is to replace CTRL-M chars with a real line</a>
<a name="ln4007">          // break.  This would make it impossible to insert a CTRL-M in</a>
<a name="ln4008">          // the text.  The line break can be avoided by preceding the</a>
<a name="ln4009">          // CTRL-M with a backslash.  To be able to insert a backslash,</a>
<a name="ln4010">          // they must be doubled in the string and are halved here.</a>
<a name="ln4011">          // That is Vi compatible.</a>
<a name="ln4012">          for (p1 = new_end; *p1; p1++) {</a>
<a name="ln4013">            if (p1[0] == '\\' &amp;&amp; p1[1] != NUL) {            // remove backslash</a>
<a name="ln4014">              sublen--;  // correct the byte counts for extmark_splice()</a>
<a name="ln4015">              STRMOVE(p1, p1 + 1);</a>
<a name="ln4016">            } else if (*p1 == CAR) {</a>
<a name="ln4017">              if (u_inssub(lnum) == OK) {             // prepare for undo</a>
<a name="ln4018">                *p1 = NUL;                            // truncate up to the CR</a>
<a name="ln4019">                ml_append(lnum - 1, new_start,</a>
<a name="ln4020">                          (colnr_T)(p1 - new_start + 1), false);</a>
<a name="ln4021">                mark_adjust(lnum + 1, (linenr_T)MAXLNUM, 1L, 0L, kExtmarkNOOP);</a>
<a name="ln4022"> </a>
<a name="ln4023">                if (subflags.do_ask) {</a>
<a name="ln4024">                  appended_lines(lnum - 1, 1L);</a>
<a name="ln4025">                } else {</a>
<a name="ln4026">                  if (first_line == 0) {</a>
<a name="ln4027">                    first_line = lnum;</a>
<a name="ln4028">                  }</a>
<a name="ln4029">                  last_line = lnum + 1;</a>
<a name="ln4030">                }</a>
<a name="ln4031">                // All line numbers increase.</a>
<a name="ln4032">                sub_firstlnum++;</a>
<a name="ln4033">                lnum++;</a>
<a name="ln4034">                line2++;</a>
<a name="ln4035">                // move the cursor to the new line, like Vi</a>
<a name="ln4036">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln4037">                // copy the rest</a>
<a name="ln4038">                STRMOVE(new_start, p1 + 1);</a>
<a name="ln4039">                p1 = new_start - 1;</a>
<a name="ln4040">              }</a>
<a name="ln4041">            } else {</a>
<a name="ln4042">              p1 += utfc_ptr2len(p1) - 1;</a>
<a name="ln4043">            }</a>
<a name="ln4044">          }</a>
<a name="ln4045">          colnr_T new_endcol = (colnr_T)strlen(new_start);</a>
<a name="ln4046">          current_match.end.col = new_endcol;</a>
<a name="ln4047">          current_match.end.lnum = lnum;</a>
<a name="ln4048"> </a>
<a name="ln4049">          int matchcols = end.col - ((end.lnum == start.lnum)</a>
<a name="ln4050">                                     ? start.col : 0);</a>
<a name="ln4051">          int subcols = new_endcol - ((lnum == lnum_start) ? start_col : 0);</a>
<a name="ln4052">          if (!did_save) {</a>
<a name="ln4053">            // Required for Undo to work for extmarks.</a>
<a name="ln4054">            u_save_cursor();</a>
<a name="ln4055">            did_save = true;</a>
<a name="ln4056">          }</a>
<a name="ln4057">          extmark_splice(curbuf, (int)lnum_start - 1, start_col,</a>
<a name="ln4058">                         end.lnum - start.lnum, matchcols, replaced_bytes,</a>
<a name="ln4059">                         lnum - lnum_start, subcols, sublen - 1, kExtmarkUndo);</a>
<a name="ln4060">        }</a>
<a name="ln4061"> </a>
<a name="ln4062">        // 4. If subflags.do_all is set, find next match.</a>
<a name="ln4063">        // Prevent endless loop with patterns that match empty</a>
<a name="ln4064">        // strings, e.g. :s/$/pat/g or :s/[a-z]* /(&amp;)/g.</a>
<a name="ln4065">        // But &quot;:s/\n/#/&quot; is OK.</a>
<a name="ln4066">skip:</a>
<a name="ln4067">        // We already know that we did the last subst when we are at</a>
<a name="ln4068">        // the end of the line, except that a pattern like</a>
<a name="ln4069">        // &quot;bar\|\nfoo&quot; may match at the NUL.  &quot;lnum&quot; can be below</a>
<a name="ln4070">        // &quot;line2&quot; when there is a \zs in the pattern after a line</a>
<a name="ln4071">        // break.</a>
<a name="ln4072">        lastone = (skip_match</a>
<a name="ln4073">                   || got_int</a>
<a name="ln4074">                   || got_quit</a>
<a name="ln4075">                   || lnum &gt; line2</a>
<a name="ln4076">                   || !(subflags.do_all || do_again)</a>
<a name="ln4077">                   || (sub_firstline[matchcol] == NUL &amp;&amp; nmatch &lt;= 1</a>
<a name="ln4078">                       &amp;&amp; !re_multiline(regmatch.regprog)));</a>
<a name="ln4079">        nmatch = -1;</a>
<a name="ln4080"> </a>
<a name="ln4081">        // Replace the line in the buffer when needed.  This is</a>
<a name="ln4082">        // skipped when there are more matches.</a>
<a name="ln4083">        // The check for nmatch_tl is needed for when multi-line</a>
<a name="ln4084">        // matching must replace the lines before trying to do another</a>
<a name="ln4085">        // match, otherwise &quot;\@&lt;=&quot; won't work.</a>
<a name="ln4086">        // When the match starts below where we start searching also</a>
<a name="ln4087">        // need to replace the line first (using \zs after \n).</a>
<a name="ln4088">        if (lastone</a>
<a name="ln4089">            || nmatch_tl &gt; 0</a>
<a name="ln4090">            || (nmatch = vim_regexec_multi(&amp;regmatch, curwin,</a>
<a name="ln4091">                                           curbuf, sub_firstlnum,</a>
<a name="ln4092">                                           matchcol, NULL, NULL)) == 0</a>
<a name="ln4093">            || regmatch.startpos[0].lnum &gt; 0) {</a>
<a name="ln4094">          if (new_start != NULL) {</a>
<a name="ln4095">            // Copy the rest of the line, that didn't match.</a>
<a name="ln4096">            // &quot;matchcol&quot; has to be adjusted, we use the end of</a>
<a name="ln4097">            // the line as reference, because the substitute may</a>
<a name="ln4098">            // have changed the number of characters.  Same for</a>
<a name="ln4099">            // &quot;prev_matchcol&quot;.</a>
<a name="ln4100">            STRCAT(new_start, sub_firstline + copycol);</a>
<a name="ln4101">            matchcol = (colnr_T)strlen(sub_firstline) - matchcol;</a>
<a name="ln4102">            prev_matchcol = (colnr_T)strlen(sub_firstline)</a>
<a name="ln4103">                            - prev_matchcol;</a>
<a name="ln4104"> </a>
<a name="ln4105">            if (u_savesub(lnum) != OK) {</a>
<a name="ln4106">              break;</a>
<a name="ln4107">            }</a>
<a name="ln4108">            ml_replace(lnum, new_start, true);</a>
<a name="ln4109"> </a>
<a name="ln4110">            if (nmatch_tl &gt; 0) {</a>
<a name="ln4111">              // Matched lines have now been substituted and are</a>
<a name="ln4112">              // useless, delete them.  The part after the match</a>
<a name="ln4113">              // has been appended to new_start, we don't need</a>
<a name="ln4114">              // it in the buffer.</a>
<a name="ln4115">              lnum++;</a>
<a name="ln4116">              if (u_savedel(lnum, nmatch_tl) != OK) {</a>
<a name="ln4117">                break;</a>
<a name="ln4118">              }</a>
<a name="ln4119">              for (i = 0; i &lt; nmatch_tl; i++) {</a>
<a name="ln4120">                ml_delete(lnum, false);</a>
<a name="ln4121">              }</a>
<a name="ln4122">              mark_adjust(lnum, lnum + (linenr_T)nmatch_tl - 1,</a>
<a name="ln4123">                          (long)MAXLNUM, (linenr_T)(-nmatch_tl), kExtmarkNOOP);</a>
<a name="ln4124">              if (subflags.do_ask) {</a>
<a name="ln4125">                deleted_lines(lnum, (linenr_T)nmatch_tl);</a>
<a name="ln4126">              }</a>
<a name="ln4127">              lnum--;</a>
<a name="ln4128">              line2 -= (linenr_T)nmatch_tl;  // nr of lines decreases</a>
<a name="ln4129">              nmatch_tl = 0;</a>
<a name="ln4130">            }</a>
<a name="ln4131"> </a>
<a name="ln4132">            // When asking, undo is saved each time, must also set</a>
<a name="ln4133">            // changed flag each time.</a>
<a name="ln4134">            if (subflags.do_ask) {</a>
<a name="ln4135">              changed_bytes(lnum, 0);</a>
<a name="ln4136">            } else {</a>
<a name="ln4137">              if (first_line == 0) {</a>
<a name="ln4138">                first_line = lnum;</a>
<a name="ln4139">              }</a>
<a name="ln4140">              last_line = lnum + 1;</a>
<a name="ln4141">            }</a>
<a name="ln4142"> </a>
<a name="ln4143">            sub_firstlnum = lnum;</a>
<a name="ln4144">            xfree(sub_firstline);                // free the temp buffer</a>
<a name="ln4145">            sub_firstline = new_start;</a>
<a name="ln4146">            new_start = NULL;</a>
<a name="ln4147">            matchcol = (colnr_T)strlen(sub_firstline) - matchcol;</a>
<a name="ln4148">            prev_matchcol = (colnr_T)strlen(sub_firstline)</a>
<a name="ln4149">                            - prev_matchcol;</a>
<a name="ln4150">            copycol = 0;</a>
<a name="ln4151">          }</a>
<a name="ln4152">          if (nmatch == -1 &amp;&amp; !lastone) {</a>
<a name="ln4153">            nmatch = vim_regexec_multi(&amp;regmatch, curwin, curbuf,</a>
<a name="ln4154">                                       sub_firstlnum, matchcol, NULL, NULL);</a>
<a name="ln4155">          }</a>
<a name="ln4156"> </a>
<a name="ln4157">          // 5. break if there isn't another match in this line</a>
<a name="ln4158">          if (nmatch &lt;= 0) {</a>
<a name="ln4159">            // If the match found didn't start where we were</a>
<a name="ln4160">            // searching, do the next search in the line where we</a>
<a name="ln4161">            // found the match.</a>
<a name="ln4162">            if (nmatch == -1) {</a>
<a name="ln4163">              lnum -= regmatch.startpos[0].lnum;</a>
<a name="ln4164">            }</a>
<a name="ln4165"> </a>
<a name="ln4166">            // uncrustify:off</a>
<a name="ln4167"> </a>
<a name="ln4168">#define PUSH_PREVIEW_LINES() \</a>
<a name="ln4169">  do { \</a>
<a name="ln4170">    if (cmdpreview_ns &gt; 0) { \</a>
<a name="ln4171">      linenr_T match_lines = current_match.end.lnum \</a>
<a name="ln4172">                             - current_match.start.lnum +1; \</a>
<a name="ln4173">      if (preview_lines.subresults.size &gt; 0) { \</a>
<a name="ln4174">        linenr_T last = kv_last(preview_lines.subresults).end.lnum; \</a>
<a name="ln4175">        if (last == current_match.start.lnum) { \</a>
<a name="ln4176">          preview_lines.lines_needed += match_lines - 1; \</a>
<a name="ln4177">        } else { \</a>
<a name="ln4178">          preview_lines.lines_needed += match_lines; \</a>
<a name="ln4179">        } \</a>
<a name="ln4180">      } else { \</a>
<a name="ln4181">        preview_lines.lines_needed += match_lines; \</a>
<a name="ln4182">      } \</a>
<a name="ln4183">      kv_push(preview_lines.subresults, current_match); \</a>
<a name="ln4184">    } \</a>
<a name="ln4185">  } while (0)</a>
<a name="ln4186"> </a>
<a name="ln4187">            // uncrustify:on</a>
<a name="ln4188"> </a>
<a name="ln4189">            // Push the match to preview_lines.</a>
<a name="ln4190">            PUSH_PREVIEW_LINES();</a>
<a name="ln4191"> </a>
<a name="ln4192">            break;</a>
<a name="ln4193">          }</a>
<a name="ln4194">        }</a>
<a name="ln4195">        // Push the match to preview_lines.</a>
<a name="ln4196">        PUSH_PREVIEW_LINES();</a>
<a name="ln4197"> </a>
<a name="ln4198">        line_breakcheck();</a>
<a name="ln4199">      }</a>
<a name="ln4200"> </a>
<a name="ln4201">      if (did_sub) {</a>
<a name="ln4202">        sub_nlines++;</a>
<a name="ln4203">      }</a>
<a name="ln4204">      xfree(new_start);              // for when substitute was cancelled</a>
<a name="ln4205">      XFREE_CLEAR(sub_firstline);    // free the copy of the original line</a>
<a name="ln4206">    }</a>
<a name="ln4207"> </a>
<a name="ln4208">    line_breakcheck();</a>
<a name="ln4209"> </a>
<a name="ln4210">    if (profile_passed_limit(timeout)) {</a>
<a name="ln4211">      got_quit = true;</a>
<a name="ln4212">    }</a>
<a name="ln4213">  }</a>
<a name="ln4214"> </a>
<a name="ln4215">  curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln4216"> </a>
<a name="ln4217">  if (first_line != 0) {</a>
<a name="ln4218">    // Need to subtract the number of added lines from &quot;last_line&quot; to get</a>
<a name="ln4219">    // the line number before the change (same as adding the number of</a>
<a name="ln4220">    // deleted lines).</a>
<a name="ln4221">    i = curbuf-&gt;b_ml.ml_line_count - old_line_count;</a>
<a name="ln4222">    changed_lines(curbuf, first_line, 0, last_line - (linenr_T)i, (linenr_T)i, false);</a>
<a name="ln4223"> </a>
<a name="ln4224">    int64_t num_added = last_line - first_line;</a>
<a name="ln4225">    int64_t num_removed = num_added - i;</a>
<a name="ln4226">    buf_updates_send_changes(curbuf, first_line, num_added, num_removed);</a>
<a name="ln4227">  }</a>
<a name="ln4228"> </a>
<a name="ln4229">  xfree(sub_firstline);   // may have to free allocated copy of the line</a>
<a name="ln4230"> </a>
<a name="ln4231">  // &quot;:s/pat//n&quot; doesn't move the cursor</a>
<a name="ln4232">  if (subflags.do_count) {</a>
<a name="ln4233">    curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln4234">  }</a>
<a name="ln4235"> </a>
<a name="ln4236">  if (sub_nsubs &gt; start_nsubs) {</a>
<a name="ln4237">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln4238">      // Set the '[ and '] marks.</a>
<a name="ln4239">      curbuf-&gt;b_op_start.lnum = eap-&gt;line1;</a>
<a name="ln4240">      curbuf-&gt;b_op_end.lnum = line2;</a>
<a name="ln4241">      curbuf-&gt;b_op_start.col = curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln4242">    }</a>
<a name="ln4243"> </a>
<a name="ln4244">    if (!global_busy) {</a>
<a name="ln4245">      // when interactive leave cursor on the match</a>
<a name="ln4246">      if (!subflags.do_ask) {</a>
<a name="ln4247">        if (endcolumn) {</a>
<a name="ln4248">          coladvance(MAXCOL);</a>
<a name="ln4249">        } else {</a>
<a name="ln4250">          beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4251">        }</a>
<a name="ln4252">      }</a>
<a name="ln4253">      if (cmdpreview_ns &lt;= 0 &amp;&amp; !do_sub_msg(subflags.do_count) &amp;&amp; subflags.do_ask &amp;&amp; p_ch &gt; 0) {</a>
<a name="ln4254">        msg(&quot;&quot;, 0);</a>
<a name="ln4255">      }</a>
<a name="ln4256">    } else {</a>
<a name="ln4257">      global_need_beginline = true;</a>
<a name="ln4258">    }</a>
<a name="ln4259">    if (subflags.do_print) {</a>
<a name="ln4260">      print_line(curwin-&gt;w_cursor.lnum, subflags.do_number, subflags.do_list);</a>
<a name="ln4261">    }</a>
<a name="ln4262">  } else if (!global_busy) {</a>
<a name="ln4263">    if (got_int) {</a>
<a name="ln4264">      // interrupted</a>
<a name="ln4265">      emsg(_(e_interr));</a>
<a name="ln4266">    } else if (got_match) {</a>
<a name="ln4267">      // did find something but nothing substituted</a>
<a name="ln4268">      if (p_ch &gt; 0) {</a>
<a name="ln4269">        msg(&quot;&quot;, 0);</a>
<a name="ln4270">      }</a>
<a name="ln4271">    } else if (subflags.do_error) {</a>
<a name="ln4272">      // nothing found</a>
<a name="ln4273">      semsg(_(e_patnotf2), get_search_pat());</a>
<a name="ln4274">    }</a>
<a name="ln4275">  }</a>
<a name="ln4276"> </a>
<a name="ln4277">  if (subflags.do_ask &amp;&amp; hasAnyFolding(curwin)) {</a>
<a name="ln4278">    // Cursor position may require updating</a>
<a name="ln4279">    changed_window_setting();</a>
<a name="ln4280">  }</a>
<a name="ln4281"> </a>
<a name="ln4282">  vim_regfree(regmatch.regprog);</a>
<a name="ln4283">  xfree(sub_copy);</a>
<a name="ln4284"> </a>
<a name="ln4285">  // Restore the flag values, they can be used for &quot;:&amp;&amp;&quot;.</a>
<a name="ln4286">  subflags.do_all = save_do_all;</a>
<a name="ln4287">  subflags.do_ask = save_do_ask;</a>
<a name="ln4288"> </a>
<a name="ln4289">  int retv = 0;</a>
<a name="ln4290"> </a>
<a name="ln4291">  // Show 'inccommand' preview if there are matched lines.</a>
<a name="ln4292">  if (cmdpreview_ns &gt; 0 &amp;&amp; !aborting()) {</a>
<a name="ln4293">    if (got_quit || profile_passed_limit(timeout)) {  // Too slow, disable.</a>
<a name="ln4294">      set_string_option_direct(&quot;icm&quot;, -1, &quot;&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4295">    } else if (*p_icm != NUL &amp;&amp; pat != NULL) {</a>
<a name="ln4296">      if (pre_hl_id == 0) {</a>
<a name="ln4297">        pre_hl_id = syn_check_group(S_LEN(&quot;Substitute&quot;));</a>
<a name="ln4298">      }</a>
<a name="ln4299">      retv = show_sub(eap, old_cursor, &amp;preview_lines, pre_hl_id, cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln4300">    }</a>
<a name="ln4301">  }</a>
<a name="ln4302"> </a>
<a name="ln4303">  kv_destroy(preview_lines.subresults);</a>
<a name="ln4304">  return retv;</a>
<a name="ln4305">#undef ADJUST_SUB_FIRSTLNUM</a>
<a name="ln4306">#undef PUSH_PREVIEW_LINES</a>
<a name="ln4307">}</a>
<a name="ln4308"> </a>
<a name="ln4309">/// Give message for number of substitutions.</a>
<a name="ln4310">/// Can also be used after a &quot;:global&quot; command.</a>
<a name="ln4311">///</a>
<a name="ln4312">/// @param count_only  used 'n' flag for &quot;:s&quot;</a>
<a name="ln4313">///</a>
<a name="ln4314">/// @return            true if a message was given.</a>
<a name="ln4315">bool do_sub_msg(bool count_only)</a>
<a name="ln4316">{</a>
<a name="ln4317">  // Only report substitutions when:</a>
<a name="ln4318">  // - more than 'report' substitutions</a>
<a name="ln4319">  // - command was typed by user, or number of changed lines &gt; 'report'</a>
<a name="ln4320">  // - giving messages is not disabled by 'lazyredraw'</a>
<a name="ln4321">  if (((sub_nsubs &gt; p_report &amp;&amp; (KeyTyped || sub_nlines &gt; 1 || p_report &lt; 1))</a>
<a name="ln4322">       || count_only)</a>
<a name="ln4323">      &amp;&amp; messaging()) {</a>
<a name="ln4324">    if (got_int) {</a>
<a name="ln4325">      STRCPY(msg_buf, _(&quot;(Interrupted) &quot;));</a>
<a name="ln4326">    } else {</a>
<a name="ln4327">      *msg_buf = NUL;</a>
<a name="ln4328">    }</a>
<a name="ln4329"> </a>
<a name="ln4330">    char *msg_single = count_only</a>
<a name="ln4331">                     ? NGETTEXT(&quot;%&quot; PRId64 &quot; match on %&quot; PRId64 &quot; line&quot;,</a>
<a name="ln4332">                                &quot;%&quot; PRId64 &quot; matches on %&quot; PRId64 &quot; line&quot;, sub_nsubs)</a>
<a name="ln4333">                     : NGETTEXT(&quot;%&quot; PRId64 &quot; substitution on %&quot; PRId64 &quot; line&quot;,</a>
<a name="ln4334">                                &quot;%&quot; PRId64 &quot; substitutions on %&quot; PRId64 &quot; line&quot;, sub_nsubs);</a>
<a name="ln4335">    char *msg_plural = count_only</a>
<a name="ln4336">                     ? NGETTEXT(&quot;%&quot; PRId64 &quot; match on %&quot; PRId64 &quot; lines&quot;,</a>
<a name="ln4337">                                &quot;%&quot; PRId64 &quot; matches on %&quot; PRId64 &quot; lines&quot;, sub_nsubs)</a>
<a name="ln4338">                     : NGETTEXT(&quot;%&quot; PRId64 &quot; substitution on %&quot; PRId64 &quot; lines&quot;,</a>
<a name="ln4339">                                &quot;%&quot; PRId64 &quot; substitutions on %&quot; PRId64 &quot; lines&quot;, sub_nsubs);</a>
<a name="ln4340">    vim_snprintf_add(msg_buf, sizeof(msg_buf),</a>
<a name="ln4341">                     NGETTEXT(msg_single, msg_plural, sub_nlines),</a>
<a name="ln4342">                     (int64_t)sub_nsubs, (int64_t)sub_nlines);</a>
<a name="ln4343">    if (msg(msg_buf, 0)) {</a>
<a name="ln4344">      // save message to display it after redraw</a>
<a name="ln4345">      set_keep_msg(msg_buf, 0);</a>
<a name="ln4346">    }</a>
<a name="ln4347">    return true;</a>
<a name="ln4348">  }</a>
<a name="ln4349">  if (got_int) {</a>
<a name="ln4350">    emsg(_(e_interr));</a>
<a name="ln4351">    return true;</a>
<a name="ln4352">  }</a>
<a name="ln4353">  return false;</a>
<a name="ln4354">}</a>
<a name="ln4355"> </a>
<a name="ln4356">static void global_exe_one(char *const cmd, const linenr_T lnum)</a>
<a name="ln4357">{</a>
<a name="ln4358">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln4359">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln4360">  if (*cmd == NUL || *cmd == '\n') {</a>
<a name="ln4361">    do_cmdline(&quot;p&quot;, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4362">  } else {</a>
<a name="ln4363">    do_cmdline(cmd, NULL, NULL, DOCMD_NOWAIT);</a>
<a name="ln4364">  }</a>
<a name="ln4365">}</a>
<a name="ln4366"> </a>
<a name="ln4367">/// Execute a global command of the form:</a>
<a name="ln4368">///</a>
<a name="ln4369">/// g/pattern/X : execute X on all lines where pattern matches</a>
<a name="ln4370">/// v/pattern/X : execute X on all lines where pattern does not match</a>
<a name="ln4371">///</a>
<a name="ln4372">/// where 'X' is an EX command</a>
<a name="ln4373">///</a>
<a name="ln4374">/// The command character (as well as the trailing slash) is optional, and</a>
<a name="ln4375">/// is assumed to be 'p' if missing.</a>
<a name="ln4376">///</a>
<a name="ln4377">/// This is implemented in two passes: first we scan the file for the pattern and</a>
<a name="ln4378">/// set a mark for each line that (not) matches. Secondly we execute the command</a>
<a name="ln4379">/// for each line that has a mark. This is required because after deleting</a>
<a name="ln4380">/// lines we do not know where to search for the next match.</a>
<a name="ln4381">void ex_global(exarg_T *eap)</a>
<a name="ln4382">{</a>
<a name="ln4383">  linenr_T lnum;                // line number according to old situation</a>
<a name="ln4384">  int type;                     // first char of cmd: 'v' or 'g'</a>
<a name="ln4385">  char *cmd;             // command argument</a>
<a name="ln4386"> </a>
<a name="ln4387">  char delim;                 // delimiter, normally '/'</a>
<a name="ln4388">  char *pat;</a>
<a name="ln4389">  regmmatch_T regmatch;</a>
<a name="ln4390">  int match;</a>
<a name="ln4391">  int which_pat;</a>
<a name="ln4392"> </a>
<a name="ln4393">  // When nesting the command works on one line.  This allows for</a>
<a name="ln4394">  // &quot;:g/found/v/notfound/command&quot;.</a>
<a name="ln4395">  if (global_busy &amp;&amp; (eap-&gt;line1 != 1</a>
<a name="ln4396">                      || eap-&gt;line2 != curbuf-&gt;b_ml.ml_line_count)) {</a>
<a name="ln4397">    // will increment global_busy to break out of the loop</a>
<a name="ln4398">    emsg(_(&quot;E147: Cannot do :global recursive with a range&quot;));</a>
<a name="ln4399">    return;</a>
<a name="ln4400">  }</a>
<a name="ln4401"> </a>
<a name="ln4402">  if (eap-&gt;forceit) {               // &quot;:global!&quot; is like &quot;:vglobal&quot;</a>
<a name="ln4403">    type = 'v';</a>
<a name="ln4404">  } else {</a>
<a name="ln4405">    type = (uint8_t)(*eap-&gt;cmd);</a>
<a name="ln4406">  }</a>
<a name="ln4407">  cmd = eap-&gt;arg;</a>
<a name="ln4408">  which_pat = RE_LAST;              // default: use last used regexp</a>
<a name="ln4409"> </a>
<a name="ln4410">  // undocumented vi feature:</a>
<a name="ln4411">  //    &quot;\/&quot; and &quot;\?&quot;: use previous search pattern.</a>
<a name="ln4412">  //             &quot;\&amp;&quot;: use previous substitute pattern.</a>
<a name="ln4413">  if (*cmd == '\\') {</a>
<a name="ln4414">    cmd++;</a>
<a name="ln4415">    if (vim_strchr(&quot;/?&amp;&quot;, (uint8_t)(*cmd)) == NULL) {</a>
<a name="ln4416">      emsg(_(e_backslash));</a>
<a name="ln4417">      return;</a>
<a name="ln4418">    }</a>
<a name="ln4419">    if (*cmd == '&amp;') {</a>
<a name="ln4420">      which_pat = RE_SUBST;             // use previous substitute pattern</a>
<a name="ln4421">    } else {</a>
<a name="ln4422">      which_pat = RE_SEARCH;            // use previous search pattern</a>
<a name="ln4423">    }</a>
<a name="ln4424">    cmd++;</a>
<a name="ln4425">    pat = &quot;&quot;;</a>
<a name="ln4426">  } else if (*cmd == NUL) {</a>
<a name="ln4427">    emsg(_(&quot;E148: Regular expression missing from global&quot;));</a>
<a name="ln4428">    return;</a>
<a name="ln4429">  } else if (check_regexp_delim(*cmd) == FAIL) {</a>
<a name="ln4430">    return;</a>
<a name="ln4431">  } else {</a>
<a name="ln4432">    delim = *cmd;               // get the delimiter</a>
<a name="ln4433">    cmd++;                      // skip delimiter if there is one</a>
<a name="ln4434">    pat = cmd;                  // remember start of pattern</a>
<a name="ln4435">    cmd = skip_regexp_ex(cmd, delim, magic_isset(), &amp;eap-&gt;arg, NULL, NULL);</a>
<a name="ln4436">    if (cmd[0] == delim) {                  // end delimiter found</a>
<a name="ln4437">      *cmd++ = NUL;                         // replace it with a NUL</a>
<a name="ln4438">    }</a>
<a name="ln4439">  }</a>
<a name="ln4440"> </a>
<a name="ln4441">  char *used_pat;</a>
<a name="ln4442">  if (search_regcomp(pat, &amp;used_pat, RE_BOTH, which_pat,</a>
<a name="ln4443">                     SEARCH_HIS, &amp;regmatch) == FAIL) {</a>
<a name="ln4444">    emsg(_(e_invcmd));</a>
<a name="ln4445">    return;</a>
<a name="ln4446">  }</a>
<a name="ln4447"> </a>
<a name="ln4448">  if (global_busy) {</a>
<a name="ln4449">    lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln4450">    match = (int)vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum, 0, NULL, NULL);</a>
<a name="ln4451">    if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4452">      global_exe_one(cmd, lnum);</a>
<a name="ln4453">    }</a>
<a name="ln4454">  } else {</a>
<a name="ln4455">    int ndone = 0;</a>
<a name="ln4456">    // pass 1: set marks for each (not) matching line</a>
<a name="ln4457">    for (lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2 &amp;&amp; !got_int; lnum++) {</a>
<a name="ln4458">      // a match on this line?</a>
<a name="ln4459">      match = (int)vim_regexec_multi(&amp;regmatch, curwin, curbuf, lnum, 0, NULL, NULL);</a>
<a name="ln4460">      if (regmatch.regprog == NULL) {</a>
<a name="ln4461">        break;  // re-compiling regprog failed</a>
<a name="ln4462">      }</a>
<a name="ln4463">      if ((type == 'g' &amp;&amp; match) || (type == 'v' &amp;&amp; !match)) {</a>
<a name="ln4464">        ml_setmarked(lnum);</a>
<a name="ln4465">        ndone++;</a>
<a name="ln4466">      }</a>
<a name="ln4467">      line_breakcheck();</a>
<a name="ln4468">    }</a>
<a name="ln4469"> </a>
<a name="ln4470">    // pass 2: execute the command for each line that has been marked</a>
<a name="ln4471">    if (got_int) {</a>
<a name="ln4472">      msg(_(e_interr), 0);</a>
<a name="ln4473">    } else if (ndone == 0) {</a>
<a name="ln4474">      if (type == 'v') {</a>
<a name="ln4475">        smsg(0, _(&quot;Pattern found in every line: %s&quot;), used_pat);</a>
<a name="ln4476">      } else {</a>
<a name="ln4477">        smsg(0, _(&quot;Pattern not found: %s&quot;), used_pat);</a>
<a name="ln4478">      }</a>
<a name="ln4479">    } else {</a>
<a name="ln4480">      global_exe(cmd);</a>
<a name="ln4481">    }</a>
<a name="ln4482">    ml_clearmarked();         // clear rest of the marks</a>
<a name="ln4483">  }</a>
<a name="ln4484">  vim_regfree(regmatch.regprog);</a>
<a name="ln4485">}</a>
<a name="ln4486"> </a>
<a name="ln4487">/// Execute `cmd` on lines marked with ml_setmarked().</a>
<a name="ln4488">void global_exe(char *cmd)</a>
<a name="ln4489">{</a>
<a name="ln4490">  linenr_T old_lcount;      // b_ml.ml_line_count before the command</a>
<a name="ln4491">  buf_T *old_buf = curbuf;  // remember what buffer we started in</a>
<a name="ln4492">  linenr_T lnum;            // line number according to old situation</a>
<a name="ln4493"> </a>
<a name="ln4494">  // Set current position only once for a global command.</a>
<a name="ln4495">  // If global_busy is set, setpcmark() will not do anything.</a>
<a name="ln4496">  // If there is an error, global_busy will be incremented.</a>
<a name="ln4497">  setpcmark();</a>
<a name="ln4498"> </a>
<a name="ln4499">  // When the command writes a message, don't overwrite the command.</a>
<a name="ln4500">  msg_didout = true;</a>
<a name="ln4501"> </a>
<a name="ln4502">  sub_nsubs = 0;</a>
<a name="ln4503">  sub_nlines = 0;</a>
<a name="ln4504">  global_need_beginline = false;</a>
<a name="ln4505">  global_busy = 1;</a>
<a name="ln4506">  old_lcount = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln4507"> </a>
<a name="ln4508">  while (!got_int &amp;&amp; (lnum = ml_firstmarked()) != 0 &amp;&amp; global_busy == 1) {</a>
<a name="ln4509">    global_exe_one(cmd, lnum);</a>
<a name="ln4510">    os_breakcheck();</a>
<a name="ln4511">  }</a>
<a name="ln4512"> </a>
<a name="ln4513">  global_busy = 0;</a>
<a name="ln4514">  if (global_need_beginline) {</a>
<a name="ln4515">    beginline(BL_WHITE | BL_FIX);</a>
<a name="ln4516">  } else {</a>
<a name="ln4517">    check_cursor();  // cursor may be beyond the end of the line</a>
<a name="ln4518">  }</a>
<a name="ln4519"> </a>
<a name="ln4520">  // the cursor may not have moved in the text but a change in a previous</a>
<a name="ln4521">  // line may move it on the screen</a>
<a name="ln4522">  changed_line_abv_curs();</a>
<a name="ln4523"> </a>
<a name="ln4524">  // If it looks like no message was written, allow overwriting the</a>
<a name="ln4525">  // command with the report for number of changes.</a>
<a name="ln4526">  if (msg_col == 0 &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln4527">    msg_didout = false;</a>
<a name="ln4528">  }</a>
<a name="ln4529"> </a>
<a name="ln4530">  // If substitutes done, report number of substitutes, otherwise report</a>
<a name="ln4531">  // number of extra or deleted lines.</a>
<a name="ln4532">  // Don't report extra or deleted lines in the edge case where the buffer</a>
<a name="ln4533">  // we are in after execution is different from the buffer we started in.</a>
<a name="ln4534">  if (!do_sub_msg(false) &amp;&amp; curbuf == old_buf) {</a>
<a name="ln4535">    msgmore(curbuf-&gt;b_ml.ml_line_count - old_lcount);</a>
<a name="ln4536">  }</a>
<a name="ln4537">}</a>
<a name="ln4538"> </a>
<a name="ln4539">#if defined(EXITFREE)</a>
<a name="ln4540">void free_old_sub(void)</a>
<a name="ln4541">{</a>
<a name="ln4542">  sub_set_replacement((SubReplacementString) { NULL, 0, NULL });</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">#endif</a>
<a name="ln4546"> </a>
<a name="ln4547">/// Set up for a tagpreview.</a>
<a name="ln4548">///</a>
<a name="ln4549">/// @param undo_sync  sync undo when leaving the window</a>
<a name="ln4550">///</a>
<a name="ln4551">/// @return           true when it was created.</a>
<a name="ln4552">bool prepare_tagpreview(bool undo_sync)</a>
<a name="ln4553">{</a>
<a name="ln4554">  if (curwin-&gt;w_p_pvw) {</a>
<a name="ln4555">    return false;</a>
<a name="ln4556">  }</a>
<a name="ln4557"> </a>
<a name="ln4558">  // If there is already a preview window open, use that one.</a>
<a name="ln4559">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4560">    if (wp-&gt;w_p_pvw) {</a>
<a name="ln4561">      win_enter(wp, undo_sync);</a>
<a name="ln4562">      return false;</a>
<a name="ln4563">    }</a>
<a name="ln4564">  }</a>
<a name="ln4565"> </a>
<a name="ln4566">  // There is no preview window open yet.  Create one.</a>
<a name="ln4567">  if (win_split(g_do_tagpreview &gt; 0 ? g_do_tagpreview : 0, 0)</a>
<a name="ln4568">      == FAIL) {</a>
<a name="ln4569">    return false;</a>
<a name="ln4570">  }</a>
<a name="ln4571">  curwin-&gt;w_p_pvw = true;</a>
<a name="ln4572">  curwin-&gt;w_p_wfh = true;</a>
<a name="ln4573">  RESET_BINDING(curwin);                // don't take over 'scrollbind' and 'cursorbind'</a>
<a name="ln4574">  curwin-&gt;w_p_diff = false;             // no 'diff'</a>
<a name="ln4575">  set_string_option_direct(&quot;fdc&quot;, -1,     // no 'foldcolumn'</a>
<a name="ln4576">                           &quot;0&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4577">  return true;</a>
<a name="ln4578">}</a>
<a name="ln4579"> </a>
<a name="ln4580">/// Shows the effects of the :substitute command being typed ('inccommand').</a>
<a name="ln4581">/// If inccommand=split, shows a preview window and later restores the layout.</a>
<a name="ln4582">///</a>
<a name="ln4583">/// @return 1 if preview window isn't needed, 2 if preview window is needed.</a>
<a name="ln4584">static int show_sub(exarg_T *eap, pos_T old_cusr, PreviewLines *preview_lines, int hl_id,</a>
<a name="ln4585">                    long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln4586">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4587">{</a>
<a name="ln4588">  char *save_shm_p = xstrdup(p_shm);</a>
<a name="ln4589">  PreviewLines lines = *preview_lines;</a>
<a name="ln4590">  buf_T *orig_buf = curbuf;</a>
<a name="ln4591">  // We keep a special-purpose buffer around, but don't assume it exists.</a>
<a name="ln4592">  buf_T *cmdpreview_buf = NULL;</a>
<a name="ln4593"> </a>
<a name="ln4594">  // disable file info message</a>
<a name="ln4595">  set_string_option_direct(&quot;shm&quot;, -1, &quot;F&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln4596"> </a>
<a name="ln4597">  // Update the topline to ensure that main window is on the correct line</a>
<a name="ln4598">  update_topline(curwin);</a>
<a name="ln4599"> </a>
<a name="ln4600">  // Place cursor on nearest matching line, to undo do_sub() cursor placement.</a>
<a name="ln4601">  for (size_t i = 0; i &lt; lines.subresults.size; i++) {</a>
<a name="ln4602">    SubResult curres = lines.subresults.items[i];</a>
<a name="ln4603">    if (curres.start.lnum &gt;= old_cusr.lnum) {</a>
<a name="ln4604">      curwin-&gt;w_cursor.lnum = curres.start.lnum;</a>
<a name="ln4605">      curwin-&gt;w_cursor.col = curres.start.col;</a>
<a name="ln4606">      break;</a>
<a name="ln4607">    }  // Else: All matches are above, do_sub() already placed cursor.</a>
<a name="ln4608">  }</a>
<a name="ln4609"> </a>
<a name="ln4610">  // Width of the &quot;| lnum|...&quot; column which displays the line numbers.</a>
<a name="ln4611">  linenr_T highest_num_line = 0;</a>
<a name="ln4612">  int col_width = 0;</a>
<a name="ln4613">  // Use preview window only when inccommand=split and range is not just the current line</a>
<a name="ln4614">  bool preview = (*p_icm == 's') &amp;&amp; (eap-&gt;line1 != old_cusr.lnum || eap-&gt;line2 != old_cusr.lnum);</a>
<a name="ln4615"> </a>
<a name="ln4616">  if (preview) {</a>
<a name="ln4617">    cmdpreview_buf = buflist_findnr(cmdpreview_bufnr);</a>
<a name="ln4618">    assert(cmdpreview_buf != NULL);</a>
<a name="ln4619"> </a>
<a name="ln4620">    if (lines.subresults.size &gt; 0) {</a>
<a name="ln4621">      highest_num_line = kv_last(lines.subresults).end.lnum;</a>
<a name="ln4622">      col_width = (int)log10(highest_num_line) + 1 + 3;</a>
<a name="ln4623">    }</a>
<a name="ln4624">  }</a>
<a name="ln4625"> </a>
<a name="ln4626">  char *str = NULL;  // construct the line to show in here</a>
<a name="ln4627">  size_t old_line_size = 0;</a>
<a name="ln4628">  size_t line_size = 0;</a>
<a name="ln4629">  linenr_T linenr_preview = 0;  // last line added to preview buffer</a>
<a name="ln4630">  linenr_T linenr_origbuf = 0;  // last line added to original buffer</a>
<a name="ln4631">  linenr_T next_linenr = 0;     // next line to show for the match</a>
<a name="ln4632"> </a>
<a name="ln4633">  for (size_t matchidx = 0; matchidx &lt; lines.subresults.size; matchidx++) {</a>
<a name="ln4634">    SubResult match = lines.subresults.items[matchidx];</a>
<a name="ln4635"> </a>
<a name="ln4636">    if (cmdpreview_buf) {</a>
<a name="ln4637">      lpos_T p_start = { 0, match.start.col };  // match starts here in preview</a>
<a name="ln4638">      lpos_T p_end   = { 0, match.end.col };    // ... and ends here</a>
<a name="ln4639"> </a>
<a name="ln4640">      // You Might Gonna Need It</a>
<a name="ln4641">      buf_ensure_loaded(cmdpreview_buf);</a>
<a name="ln4642"> </a>
<a name="ln4643">      if (match.pre_match == 0) {</a>
<a name="ln4644">        next_linenr = match.start.lnum;</a>
<a name="ln4645">      } else {</a>
<a name="ln4646">        next_linenr = match.pre_match;</a>
<a name="ln4647">      }</a>
<a name="ln4648">      // Don't add a line twice</a>
<a name="ln4649">      if (next_linenr == linenr_origbuf) {</a>
<a name="ln4650">        next_linenr++;</a>
<a name="ln4651">        p_start.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln4652">        p_end.lnum = linenr_preview;  // might be redefined below</a>
<a name="ln4653">      }</a>
<a name="ln4654"> </a>
<a name="ln4655">      for (; next_linenr &lt;= match.end.lnum; next_linenr++) {</a>
<a name="ln4656">        if (next_linenr == match.start.lnum) {</a>
<a name="ln4657">          p_start.lnum = linenr_preview + 1;</a>
<a name="ln4658">        }</a>
<a name="ln4659">        if (next_linenr == match.end.lnum) {</a>
<a name="ln4660">          p_end.lnum = linenr_preview + 1;</a>
<a name="ln4661">        }</a>
<a name="ln4662">        char *line;</a>
<a name="ln4663">        if (next_linenr == orig_buf-&gt;b_ml.ml_line_count + 1) {</a>
<a name="ln4664">          line = &quot;&quot;;</a>
<a name="ln4665">        } else {</a>
<a name="ln4666">          line = ml_get_buf(orig_buf, next_linenr);</a>
<a name="ln4667">          line_size = strlen(line) + (size_t)col_width + 1;</a>
<a name="ln4668"> </a>
<a name="ln4669">          // Reallocate if line not long enough</a>
<a name="ln4670">          if (line_size &gt; old_line_size) {</a>
<a name="ln4671">            str = xrealloc(str, line_size * sizeof(char));</a>
<a name="ln4672">            old_line_size = line_size;</a>
<a name="ln4673">          }</a>
<a name="ln4674">        }</a>
<a name="ln4675">        // Put &quot;|lnum| line&quot; into `str` and append it to the preview buffer.</a>
<a name="ln4676">        snprintf(str, line_size, &quot;|%*&quot; PRIdLINENR &quot;| %s&quot;, col_width - 3,</a>
<a name="ln4677">                 next_linenr, line);</a>
<a name="ln4678">        if (linenr_preview == 0) {</a>
<a name="ln4679">          ml_replace_buf(cmdpreview_buf, 1, str, true);</a>
<a name="ln4680">        } else {</a>
<a name="ln4681">          ml_append_buf(cmdpreview_buf, linenr_preview, str, (colnr_T)line_size, false);</a>
<a name="ln4682">        }</a>
<a name="ln4683">        linenr_preview += 1;</a>
<a name="ln4684">      }</a>
<a name="ln4685">      linenr_origbuf = match.end.lnum;</a>
<a name="ln4686"> </a>
<a name="ln4687">      bufhl_add_hl_pos_offset(cmdpreview_buf, (int)cmdpreview_ns, hl_id, p_start, p_end, col_width);</a>
<a name="ln4688">    }</a>
<a name="ln4689">    bufhl_add_hl_pos_offset(orig_buf, (int)cmdpreview_ns, hl_id, match.start, match.end, 0);</a>
<a name="ln4690">  }</a>
<a name="ln4691"> </a>
<a name="ln4692">  xfree(str);</a>
<a name="ln4693"> </a>
<a name="ln4694">  set_string_option_direct(&quot;shm&quot;, -1, save_shm_p, OPT_FREE, SID_NONE);</a>
<a name="ln4695">  xfree(save_shm_p);</a>
<a name="ln4696"> </a>
<a name="ln4697">  return preview ? 2 : 1;</a>
<a name="ln4698">}</a>
<a name="ln4699"> </a>
<a name="ln4700">/// :substitute command.</a>
<a name="ln4701">void ex_substitute(exarg_T *eap)</a>
<a name="ln4702">{</a>
<a name="ln4703">  (void)do_sub(eap, profile_zero(), 0, 0);</a>
<a name="ln4704">}</a>
<a name="ln4705"> </a>
<a name="ln4706">/// :substitute command preview callback.</a>
<a name="ln4707">int ex_substitute_preview(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln4708">{</a>
<a name="ln4709">  // Only preview once the pattern delimiter has been typed</a>
<a name="ln4710">  if (*eap-&gt;arg &amp;&amp; !ASCII_ISALNUM(*eap-&gt;arg)) {</a>
<a name="ln4711">    char *save_eap = eap-&gt;arg;</a>
<a name="ln4712">    int retv = do_sub(eap, profile_setlimit(p_rdt), cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln4713">    eap-&gt;arg = save_eap;</a>
<a name="ln4714">    return retv;</a>
<a name="ln4715">  }</a>
<a name="ln4716"> </a>
<a name="ln4717">  return 0;</a>
<a name="ln4718">}</a>
<a name="ln4719"> </a>
<a name="ln4720">/// Skip over the pattern argument of &quot;:vimgrep /pat/[g][j]&quot;.</a>
<a name="ln4721">/// Put the start of the pattern in &quot;*s&quot;, unless &quot;s&quot; is NULL.</a>
<a name="ln4722">///</a>
<a name="ln4723">/// @param flags  if not NULL, put the flags in it: VGR_GLOBAL, VGR_NOJUMP.</a>
<a name="ln4724">/// @param s      if not NULL, terminate the pattern with a NUL.</a>
<a name="ln4725">///</a>
<a name="ln4726">/// @return  a pointer to the char just past the pattern plus flags.</a>
<a name="ln4727">char *skip_vimgrep_pat(char *p, char **s, int *flags)</a>
<a name="ln4728">{</a>
<a name="ln4729">  if (vim_isIDc((uint8_t)(*p))) {</a>
<a name="ln4730">    // &quot;:vimgrep pattern fname&quot;</a>
<a name="ln4731">    if (s != NULL) {</a>
<a name="ln4732">      *s = p;</a>
<a name="ln4733">    }</a>
<a name="ln4734">    p = skiptowhite(p);</a>
<a name="ln4735">    if (s != NULL &amp;&amp; *p != NUL) {</a>
<a name="ln4736">      *p++ = NUL;</a>
<a name="ln4737">    }</a>
<a name="ln4738">  } else {</a>
<a name="ln4739">    // &quot;:vimgrep /pattern/[g][j] fname&quot;</a>
<a name="ln4740">    if (s != NULL) {</a>
<a name="ln4741">      *s = p + 1;</a>
<a name="ln4742">    }</a>
<a name="ln4743">    int c = (uint8_t)(*p);</a>
<a name="ln4744">    p = skip_regexp(p + 1, c, true);</a>
<a name="ln4745">    if (*p != c) {</a>
<a name="ln4746">      return NULL;</a>
<a name="ln4747">    }</a>
<a name="ln4748"> </a>
<a name="ln4749">    // Truncate the pattern.</a>
<a name="ln4750">    if (s != NULL) {</a>
<a name="ln4751">      *p = NUL;</a>
<a name="ln4752">    }</a>
<a name="ln4753">    p++;</a>
<a name="ln4754"> </a>
<a name="ln4755">    // Find the flags</a>
<a name="ln4756">    while (*p == 'g' || *p == 'j' || *p == 'f') {</a>
<a name="ln4757">      if (flags != NULL) {</a>
<a name="ln4758">        if (*p == 'g') {</a>
<a name="ln4759">          *flags |= VGR_GLOBAL;</a>
<a name="ln4760">        } else if (*p == 'j') {</a>
<a name="ln4761">          *flags |= VGR_NOJUMP;</a>
<a name="ln4762">        } else {</a>
<a name="ln4763">          *flags |= VGR_FUZZY;</a>
<a name="ln4764">        }</a>
<a name="ln4765">      }</a>
<a name="ln4766">      p++;</a>
<a name="ln4767">    }</a>
<a name="ln4768">  }</a>
<a name="ln4769">  return p;</a>
<a name="ln4770">}</a>
<a name="ln4771"> </a>
<a name="ln4772">/// List v:oldfiles in a nice way.</a>
<a name="ln4773">void ex_oldfiles(exarg_T *eap)</a>
<a name="ln4774">{</a>
<a name="ln4775">  list_T *l = get_vim_var_list(VV_OLDFILES);</a>
<a name="ln4776">  long nr = 0;</a>
<a name="ln4777"> </a>
<a name="ln4778">  if (l == NULL) {</a>
<a name="ln4779">    msg(_(&quot;No old files&quot;), 0);</a>
<a name="ln4780">    return;</a>
<a name="ln4781">  }</a>
<a name="ln4782"> </a>
<a name="ln4783">  msg_start();</a>
<a name="ln4784">  msg_scroll = true;</a>
<a name="ln4785">  TV_LIST_ITER(l, li, {</a>
<a name="ln4786">    if (got_int) {</a>
<a name="ln4787">      break;</a>
<a name="ln4788">    }</a>
<a name="ln4789">    nr++;</a>
<a name="ln4790">    const char *fname = tv_get_string(TV_LIST_ITEM_TV(li));</a>
<a name="ln4791">    if (!message_filtered(fname)) {</a>
<a name="ln4792">      msg_outnum(nr);</a>
<a name="ln4793">      msg_puts(&quot;: &quot;);</a>
<a name="ln4794">      msg_outtrans(tv_get_string(TV_LIST_ITEM_TV(li)), 0);</a>
<a name="ln4795">      msg_clr_eos();</a>
<a name="ln4796">      msg_putchar('\n');</a>
<a name="ln4797">      os_breakcheck();</a>
<a name="ln4798">    }</a>
<a name="ln4799">  });</a>
<a name="ln4800"> </a>
<a name="ln4801">  // Assume &quot;got_int&quot; was set to truncate the listing.</a>
<a name="ln4802">  got_int = false;</a>
<a name="ln4803"> </a>
<a name="ln4804">  // File selection prompt on &quot;:browse oldfiles&quot;</a>
<a name="ln4805">  if (cmdmod.cmod_flags &amp; CMOD_BROWSE) {</a>
<a name="ln4806">    quit_more = false;</a>
<a name="ln4807">    nr = prompt_for_number(false);</a>
<a name="ln4808">    msg_starthere();</a>
<a name="ln4809">    if (nr &gt; 0 &amp;&amp; nr &lt;= tv_list_len(l)) {</a>
<a name="ln4810">      const char *const p = tv_list_find_str(l, (int)nr - 1);</a>
<a name="ln4811">      if (p == NULL) {</a>
<a name="ln4812">        return;</a>
<a name="ln4813">      }</a>
<a name="ln4814">      char *const s = expand_env_save((char *)p);</a>
<a name="ln4815">      eap-&gt;arg = s;</a>
<a name="ln4816">      eap-&gt;cmdidx = CMD_edit;</a>
<a name="ln4817">      cmdmod.cmod_flags &amp;= ~CMOD_BROWSE;</a>
<a name="ln4818">      do_exedit(eap, NULL);</a>
<a name="ln4819">      xfree(s);</a>
<a name="ln4820">    }</a>
<a name="ln4821">  }</a>
<a name="ln4822">}</a>
</code></pre>
<div class="balloon" rel="140"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v666/" target="_blank">V666</a> Consider inspecting second argument of the function 'msg'. It is possible that the value does not correspond with the length of a string which was passed with the first argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>