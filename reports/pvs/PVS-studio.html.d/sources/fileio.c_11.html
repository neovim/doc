<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;fcntl.h&gt;</a>
<a name="ln9">#include &lt;iconv.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;limits.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;stddef.h&gt;</a>
<a name="ln14">#include &lt;stdio.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;sys/stat.h&gt;</a>
<a name="ln17">#include &lt;uv.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;auto/config.h&quot;</a>
<a name="ln20">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln21">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln22">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln25">#include &quot;nvim/change.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/diff.h&quot;</a>
<a name="ln28">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln29">#include &quot;nvim/edit.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln33">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln34">#include &quot;nvim/fold.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln37">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln38">#include &quot;nvim/globals.h&quot;</a>
<a name="ln39">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln40">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln41">#include &quot;nvim/log.h&quot;</a>
<a name="ln42">#include &quot;nvim/macros.h&quot;</a>
<a name="ln43">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln44">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln45">#include &quot;nvim/memline.h&quot;</a>
<a name="ln46">#include &quot;nvim/memory.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/move.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln51">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln55">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln56">#include &quot;nvim/path.h&quot;</a>
<a name="ln57">#include &quot;nvim/pos.h&quot;</a>
<a name="ln58">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln59">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln60">#include &quot;nvim/shada.h&quot;</a>
<a name="ln61">#include &quot;nvim/strings.h&quot;</a>
<a name="ln62">#include &quot;nvim/types.h&quot;</a>
<a name="ln63">#include &quot;nvim/ui.h&quot;</a>
<a name="ln64">#include &quot;nvim/undo.h&quot;</a>
<a name="ln65">#include &quot;nvim/vim.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln68"># include &quot;nvim/charset.h&quot;</a>
<a name="ln69">#endif</a>
<a name="ln70"> </a>
<a name="ln71">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln72"># include &lt;dirent.h&gt;</a>
<a name="ln73"># include &lt;sys/file.h&gt;</a>
<a name="ln74">#endif</a>
<a name="ln75"> </a>
<a name="ln76">#ifdef OPEN_CHR_FILES</a>
<a name="ln77"># include &quot;nvim/charset.h&quot;</a>
<a name="ln78">#endif</a>
<a name="ln79"> </a>
<a name="ln80">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln81">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln82"># define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln86"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln87">#endif</a>
<a name="ln88"> </a>
<a name="ln89">static const char *e_auchangedbuf = N_(&quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln90"> </a>
<a name="ln91">void filemess(buf_T *buf, char *name, char *s, int attr)</a>
<a name="ln92">{</a>
<a name="ln93">  int msg_scroll_save;</a>
<a name="ln94">  int prev_msg_col = msg_col;</a>
<a name="ln95"> </a>
<a name="ln96">  if (msg_silent != 0) {</a>
<a name="ln97">    return;</a>
<a name="ln98">  }</a>
<a name="ln99"> </a>
<a name="ln100">  add_quoted_fname(IObuff, IOSIZE - 100, buf, name);</a>
<a name="ln101"> </a>
<a name="ln102">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln103">  xstrlcat(IObuff, s, IOSIZE);</a>
<a name="ln104"> </a>
<a name="ln105">  // For the first message may have to start a new line.</a>
<a name="ln106">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln107">  // calling filemess().</a>
<a name="ln108">  msg_scroll_save = msg_scroll;</a>
<a name="ln109">  if (shortmess(SHM_OVERALL) &amp;&amp; !msg_listdo_overwrite &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln110">    msg_scroll = false;</a>
<a name="ln111">  }</a>
<a name="ln112">  if (!msg_scroll) {    // wait a bit when overwriting an error msg</a>
<a name="ln113">    msg_check_for_delay(false);</a>
<a name="ln114">  }</a>
<a name="ln115">  msg_start();</a>
<a name="ln116">  if (prev_msg_col != 0 &amp;&amp; msg_col == 0) {</a>
<a name="ln117">    msg_putchar('\r');  // overwrite any previous message.</a>
<a name="ln118">  }</a>
<a name="ln119">  msg_scroll = msg_scroll_save;</a>
<a name="ln120">  msg_scrolled_ign = true;</a>
<a name="ln121">  // may truncate the message to avoid a hit-return prompt</a>
<a name="ln122">  msg_outtrans(msg_may_trunc(false, IObuff), attr);</a>
<a name="ln123">  msg_clr_eos();</a>
<a name="ln124">  ui_flush();</a>
<a name="ln125">  msg_scrolled_ign = false;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">/// Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln129">///</a>
<a name="ln130">/// 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln131">/// 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln132">/// 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln133">///</a>
<a name="ln134">/// (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln135">///</a>
<a name="ln136">/// &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln137">/// &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln138">/// When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln139">///</a>
<a name="ln140">/// flags:</a>
<a name="ln141">/// READ_NEW     starting to edit a new buffer</a>
<a name="ln142">/// READ_FILTER  reading filter output</a>
<a name="ln143">/// READ_STDIN   read from stdin instead of a file</a>
<a name="ln144">/// READ_BUFFER  read from curbuf instead of a file (converting after reading</a>
<a name="ln145">///              stdin)</a>
<a name="ln146">/// READ_NOFILE  do not read a file, only trigger BufReadCmd</a>
<a name="ln147">/// READ_DUMMY   read into a dummy buffer (to check if file contents changed)</a>
<a name="ln148">/// READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln149">/// READ_FIFO    read from fifo/socket instead of a file</a>
<a name="ln150">///</a>
<a name="ln151">/// @param eap  can be NULL!</a>
<a name="ln152">///</a>
<a name="ln153">/// @return     FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln154">int readfile(char *fname, char *sfname, linenr_T from, linenr_T lines_to_skip,</a>
<a name="ln155">             linenr_T lines_to_read, exarg_T *eap, int flags, bool silent)</a>
<a name="ln156">{</a>
<a name="ln157">  int retval = FAIL;  // jump to &quot;theend&quot; instead of returning</a>
<a name="ln158">  int fd = stdin_fd &gt;= 0 ? stdin_fd : 0;</a>
<a name="ln159">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln160">  int check_readonly;</a>
<a name="ln161">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln162">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln163">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln164">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln165">  int set_options = newfile || read_buffer</a>
<a name="ln166">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln167">  linenr_T read_buf_lnum = 1;           // next line to read from curbuf</a>
<a name="ln168">  colnr_T read_buf_col = 0;             // next char to read from this line</a>
<a name="ln169">  char c;</a>
<a name="ln170">  linenr_T lnum = from;</a>
<a name="ln171">  char *ptr = NULL;              // pointer into read buffer</a>
<a name="ln172">  char *buffer = NULL;           // read buffer</a>
<a name="ln173">  char *new_buffer = NULL;       // init to shut up gcc</a>
<a name="ln174">  char *line_start = NULL;       // init to shut up gcc</a>
<a name="ln175">  int wasempty;                         // buffer was empty before reading</a>
<a name="ln176">  colnr_T len;</a>
<a name="ln177">  ptrdiff_t size = 0;</a>
<a name="ln178">  uint8_t *p = NULL;</a>
<a name="ln179">  off_T filesize = 0;</a>
<a name="ln180">  bool skip_read = false;</a>
<a name="ln181">  context_sha256_T sha_ctx;</a>
<a name="ln182">  int read_undo_file = false;</a>
<a name="ln183">  int split = 0;  // number of split lines</a>
<a name="ln184">  linenr_T linecnt;</a>
<a name="ln185">  bool error = false;                   // errors encountered</a>
<a name="ln186">  int ff_error = EOL_UNKNOWN;           // file format with errors</a>
<a name="ln187">  ptrdiff_t linerest = 0;               // remaining chars in line</a>
<a name="ln188">  int perm = 0;</a>
<a name="ln189">#ifdef UNIX</a>
<a name="ln190">  int swap_mode = -1;                   // protection bits for swap file</a>
<a name="ln191">#endif</a>
<a name="ln192">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln193">  bool keep_fileformat = false;</a>
<a name="ln194">  FileInfo file_info;</a>
<a name="ln195">  linenr_T skip_count = 0;</a>
<a name="ln196">  linenr_T read_count = 0;</a>
<a name="ln197">  int msg_save = msg_scroll;</a>
<a name="ln198">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln199">                                        // last read was missing the eol</a>
<a name="ln200">  bool file_rewind = false;</a>
<a name="ln201">  int can_retry;</a>
<a name="ln202">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln203">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln204">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln205">                                        // in destination encoding</a>
<a name="ln206">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln207">  // BAD_KEEP, BAD_DROP or character to</a>
<a name="ln208">  // replace with</a>
<a name="ln209">  char *tmpname = NULL;          // name of 'charconvert' output file</a>
<a name="ln210">  int fio_flags = 0;</a>
<a name="ln211">  char *fenc;                    // fileencoding to use</a>
<a name="ln212">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln213">  char *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln214">  bool advance_fenc = false;</a>
<a name="ln215">  long real_size = 0;</a>
<a name="ln216">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln217">  bool did_iconv = false;               // true when iconv() failed and trying</a>
<a name="ln218">                                        // 'charconvert' next</a>
<a name="ln219">  bool converted = false;                // true if conversion done</a>
<a name="ln220">  bool notconverted = false;             // true if conversion wanted but it wasn't possible</a>
<a name="ln221">  char conv_rest[CONV_RESTLEN];</a>
<a name="ln222">  int conv_restlen = 0;                 // nr of bytes in conv_rest[]</a>
<a name="ln223">  pos_T orig_start;</a>
<a name="ln224">  buf_T *old_curbuf;</a>
<a name="ln225">  char *old_b_ffname;</a>
<a name="ln226">  char *old_b_fname;</a>
<a name="ln227">  int using_b_ffname;</a>
<a name="ln228">  int using_b_fname;</a>
<a name="ln229">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln230"> </a>
<a name="ln231">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln232"> </a>
<a name="ln233">  curbuf-&gt;b_no_eol_lnum = 0;    // in case it was set by the previous read</a>
<a name="ln234"> </a>
<a name="ln235">  // If there is no file name yet, use the one for the read file.</a>
<a name="ln236">  // BF_NOTEDITED is set to reflect this.</a>
<a name="ln237">  // Don't do this for a read from a filter.</a>
<a name="ln238">  // Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln239">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln240">      &amp;&amp; !filtering</a>
<a name="ln241">      &amp;&amp; fname != NULL</a>
<a name="ln242">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln243">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln244">    if (set_rw_fname(fname, sfname) == FAIL) {</a>
<a name="ln245">      goto theend;</a>
<a name="ln246">    }</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  // Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln250">  // curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln251">  // executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln252">  // point to one of these values.</a>
<a name="ln253">  old_curbuf = curbuf;</a>
<a name="ln254">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln255">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln256">  using_b_ffname = (fname == curbuf-&gt;b_ffname) || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln257">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln258"> </a>
<a name="ln259">  // After reading a file the cursor line changes but we don't want to</a>
<a name="ln260">  // display the line.</a>
<a name="ln261">  ex_no_reprint = true;</a>
<a name="ln262"> </a>
<a name="ln263">  // don't display the file info for another buffer now</a>
<a name="ln264">  need_fileinfo = false;</a>
<a name="ln265"> </a>
<a name="ln266">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln267">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln268">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln269">  // another directory, which we don't detect.</a>
<a name="ln270">  if (sfname == NULL) {</a>
<a name="ln271">    sfname = fname;</a>
<a name="ln272">  }</a>
<a name="ln273">#if defined(UNIX)</a>
<a name="ln274">  fname = sfname;</a>
<a name="ln275">#endif</a>
<a name="ln276"> </a>
<a name="ln277">  // The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln278">  // executing the associated commands instead.</a>
<a name="ln279">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln280">    orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln281"> </a>
<a name="ln282">    // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln283">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln284">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln285"> </a>
<a name="ln286">    if (newfile) {</a>
<a name="ln287">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln288">                               false, curbuf, eap)) {</a>
<a name="ln289">        retval = OK;</a>
<a name="ln290">        if (aborting()) {</a>
<a name="ln291">          retval = FAIL;</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln295">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln296">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln297">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln298">        // same file.</a>
<a name="ln299">        if (retval == OK) {</a>
<a name="ln300">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln301">        }</a>
<a name="ln302">        goto theend;</a>
<a name="ln303">      }</a>
<a name="ln304">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln305">                                    false, NULL, eap)) {</a>
<a name="ln306">      retval = aborting() ? FAIL : OK;</a>
<a name="ln307">      goto theend;</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln311"> </a>
<a name="ln312">    if (flags &amp; READ_NOFILE) {</a>
<a name="ln313">      // Return NOTDONE instead of FAIL so that BufEnter can be triggered</a>
<a name="ln314">      // and other operations don't fail.</a>
<a name="ln315">      retval = NOTDONE;</a>
<a name="ln316">      goto theend;</a>
<a name="ln317">    }</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">  if (((shortmess(SHM_OVER) &amp;&amp; !msg_listdo_overwrite) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0) {</a>
<a name="ln321">    msg_scroll = false;         // overwrite previous file message</a>
<a name="ln322">  } else {</a>
<a name="ln323">    msg_scroll = true;          // don't overwrite previous file message</a>
<a name="ln324">  }</a>
<a name="ln325">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln326">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln327">    size_t namelen = strlen(fname);</a>
<a name="ln328"> </a>
<a name="ln329">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln330">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln331">      filemess(curbuf, fname, _(&quot;Illegal file name&quot;), 0);</a>
<a name="ln332">      msg_end();</a>
<a name="ln333">      msg_scroll = msg_save;</a>
<a name="ln334">      goto theend;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln338">    // because reading the file may actually work, but then creating the</a>
<a name="ln339">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln340">    if (after_pathsep(fname, fname + namelen)) {</a>
<a name="ln341">      if (!silent) {</a>
<a name="ln342">        filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln343">      }</a>
<a name="ln344">      msg_end();</a>
<a name="ln345">      msg_scroll = msg_save;</a>
<a name="ln346">      retval = NOTDONE;</a>
<a name="ln347">      goto theend;</a>
<a name="ln348">    }</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln352">    perm = os_getperm(fname);</a>
<a name="ln353">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln354">    // check for it before os_open().</a>
<a name="ln355"> </a>
<a name="ln356">#ifdef OPEN_CHR_FILES</a>
<a name="ln357"># define IS_CHR_DEV(perm, fname) S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname)</a>
<a name="ln358">#else</a>
<a name="ln359"># define IS_CHR_DEV(perm, fname) false</a>
<a name="ln360">#endif</a>
<a name="ln361"> </a>
<a name="ln362">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln363">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln364">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln365">        &amp;&amp; !(IS_CHR_DEV(perm, fname))</a>
<a name="ln366">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln367">        ) {</a>
<a name="ln368">      if (S_ISDIR(perm)) {</a>
<a name="ln369">        if (!silent) {</a>
<a name="ln370">          filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln371">        }</a>
<a name="ln372">        retval = NOTDONE;</a>
<a name="ln373">      } else {</a>
<a name="ln374">        filemess(curbuf, fname, _(&quot;is not a file&quot;), 0);</a>
<a name="ln375">      }</a>
<a name="ln376">      msg_end();</a>
<a name="ln377">      msg_scroll = msg_save;</a>
<a name="ln378">      goto theend;</a>
<a name="ln379">    }</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  // Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln383">  set_file_options(set_options, eap);</a>
<a name="ln384"> </a>
<a name="ln385">  // When opening a new file we take the readonly flag from the file.</a>
<a name="ln386">  // Default is r/w, can be set to r/o below.</a>
<a name="ln387">  // Don't reset it when in readonly mode</a>
<a name="ln388">  // Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln389">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln390">  if (check_readonly &amp;&amp; !readonlymode) {</a>
<a name="ln391">    curbuf-&gt;b_p_ro = false;</a>
<a name="ln392">  }</a>
<a name="ln393"> </a>
<a name="ln394">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln395">    // Remember time of file.</a>
<a name="ln396">    if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln397">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln398">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln399">      curbuf-&gt;b_mtime_read_ns = curbuf-&gt;b_mtime_ns;</a>
<a name="ln400">#ifdef UNIX</a>
<a name="ln401">      // Use the protection bits of the original file for the swap file.</a>
<a name="ln402">      // This makes it possible for others to read the name of the</a>
<a name="ln403">      // edited file from the swapfile, but only if they can read the</a>
<a name="ln404">      // edited file.</a>
<a name="ln405">      // Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln406">      // (they must not write the swapfile).</a>
<a name="ln407">      // Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln408">      // not be able to write to the file ourselves.</a>
<a name="ln409">      // Setting the bits is done below, after creating the swap file.</a>
<a name="ln410">      swap_mode = ((int)file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln411">#endif</a>
<a name="ln412">    } else {</a>
<a name="ln413">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln414">      curbuf-&gt;b_mtime_ns = 0;</a>
<a name="ln415">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln416">      curbuf-&gt;b_mtime_read_ns = 0;</a>
<a name="ln417">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln418">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln419">    }</a>
<a name="ln420"> </a>
<a name="ln421">    // Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln422">    // file doesn't exist.</a>
<a name="ln423">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln424">  }</a>
<a name="ln425"> </a>
<a name="ln426">  // Check readonly.</a>
<a name="ln427">  bool file_readonly = false;</a>
<a name="ln428">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln429">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln430">        || !os_file_is_writable(fname)) {</a>
<a name="ln431">      file_readonly = true;</a>
<a name="ln432">    }</a>
<a name="ln433">    fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln434">  }</a>
<a name="ln435"> </a>
<a name="ln436">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln437">    msg_scroll = msg_save;</a>
<a name="ln438">    if (!newfile) {</a>
<a name="ln439">      goto theend;</a>
<a name="ln440">    }</a>
<a name="ln441">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln442">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln443">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln444">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln445"> </a>
<a name="ln446">      // Create a swap file now, so that other Vims are warned</a>
<a name="ln447">      // that we are editing this file.  Don't do this for a</a>
<a name="ln448">      // &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln449">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln450">        check_need_swap(newfile);</a>
<a name="ln451">        // SwapExists autocommand may mess things up</a>
<a name="ln452">        if (curbuf != old_curbuf</a>
<a name="ln453">            || (using_b_ffname</a>
<a name="ln454">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln455">            || (using_b_fname</a>
<a name="ln456">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln457">          emsg(_(e_auchangedbuf));</a>
<a name="ln458">          goto theend;</a>
<a name="ln459">        }</a>
<a name="ln460">      }</a>
<a name="ln461">      if (!silent) {</a>
<a name="ln462">        if (dir_of_file_exists(fname)) {</a>
<a name="ln463">          filemess(curbuf, sfname, _(&quot;[New]&quot;), 0);</a>
<a name="ln464">        } else {</a>
<a name="ln465">          filemess(curbuf, sfname, _(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln466">        }</a>
<a name="ln467">      }</a>
<a name="ln468">      // Even though this is a new file, it might have been</a>
<a name="ln469">      // edited before and deleted.  Get the old marks.</a>
<a name="ln470">      check_marks_read();</a>
<a name="ln471">      // Set forced 'fileencoding'.</a>
<a name="ln472">      if (eap != NULL) {</a>
<a name="ln473">        set_forced_fenc(eap);</a>
<a name="ln474">      }</a>
<a name="ln475">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln476">                           false, curbuf, eap);</a>
<a name="ln477">      // remember the current fileformat</a>
<a name="ln478">      save_file_ff(curbuf);</a>
<a name="ln479"> </a>
<a name="ln480">      if (!aborting()) {  // autocmds may abort script processing</a>
<a name="ln481">        retval = OK;      // a new file is not an error</a>
<a name="ln482">      }</a>
<a name="ln483">      goto theend;</a>
<a name="ln484">    }</a>
<a name="ln485">#if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln486">    filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln487">                              // libuv only returns -errno</a>
<a name="ln488">                              // in Unix and in Windows</a>
<a name="ln489">                              // open() does not set</a>
<a name="ln490">                              // EOVERFLOW</a>
<a name="ln491">                              (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln492">                              _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln493">#else</a>
<a name="ln494">    filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln495">                              _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln496">#endif</a>
<a name="ln497">    curbuf-&gt;b_p_ro = true;                  // must use &quot;w!&quot; now</a>
<a name="ln498"> </a>
<a name="ln499">    goto theend;</a>
<a name="ln500">  }</a>
<a name="ln501"> </a>
<a name="ln502">  // Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln503">  // loaded.    Help files always get readonly mode</a>
<a name="ln504">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help) {</a>
<a name="ln505">    curbuf-&gt;b_p_ro = true;</a>
<a name="ln506">  }</a>
<a name="ln507"> </a>
<a name="ln508">  if (set_options) {</a>
<a name="ln509">    // Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln510">    // correctly set when reading stdin.</a>
<a name="ln511">    if (!read_buffer) {</a>
<a name="ln512">      curbuf-&gt;b_p_eof = false;</a>
<a name="ln513">      curbuf-&gt;b_start_eof = false;</a>
<a name="ln514">      curbuf-&gt;b_p_eol = true;</a>
<a name="ln515">      curbuf-&gt;b_start_eol = true;</a>
<a name="ln516">    }</a>
<a name="ln517">    curbuf-&gt;b_p_bomb = false;</a>
<a name="ln518">    curbuf-&gt;b_start_bomb = false;</a>
<a name="ln519">  }</a>
<a name="ln520"> </a>
<a name="ln521">  // Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln522">  // editing this file.</a>
<a name="ln523">  // Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln524">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln525">    check_need_swap(newfile);</a>
<a name="ln526">    if (!read_stdin</a>
<a name="ln527">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln528">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln529">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln530">      emsg(_(e_auchangedbuf));</a>
<a name="ln531">      if (!read_buffer) {</a>
<a name="ln532">        close(fd);</a>
<a name="ln533">      }</a>
<a name="ln534">      goto theend;</a>
<a name="ln535">    }</a>
<a name="ln536">#ifdef UNIX</a>
<a name="ln537">    // Set swap file protection bits after creating it.</a>
<a name="ln538">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln539">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln540">      const char *swap_fname = curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln541"> </a>
<a name="ln542">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln543">      // the group must be equal to the group of the original file.  If</a>
<a name="ln544">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln545">      // avoids making the swap file readable to more users when the</a>
<a name="ln546">      // primary group of the user is too permissive.</a>
<a name="ln547">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln548">        FileInfo swap_info;</a>
<a name="ln549"> </a>
<a name="ln550">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln551">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln552">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, (uv_uid_t)(-1),</a>
<a name="ln553">                         (uv_gid_t)file_info.stat.st_gid)</a>
<a name="ln554">            == -1) {</a>
<a name="ln555">          swap_mode &amp;= 0600;</a>
<a name="ln556">        }</a>
<a name="ln557">      }</a>
<a name="ln558"> </a>
<a name="ln559">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln560">    }</a>
<a name="ln561">#endif</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln565">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln566">    if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln567">      close(fd);</a>
<a name="ln568">    }</a>
<a name="ln569">    goto theend;</a>
<a name="ln570">  }</a>
<a name="ln571"> </a>
<a name="ln572">  no_wait_return++;         // don't wait for return yet</a>
<a name="ln573"> </a>
<a name="ln574">  // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln575">  orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln576">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln577">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln578"> </a>
<a name="ln579">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln580">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln581">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln582"> </a>
<a name="ln583">  if (!read_buffer) {</a>
<a name="ln584">    int m = msg_scroll;</a>
<a name="ln585">    int n = msg_scrolled;</a>
<a name="ln586"> </a>
<a name="ln587">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln588">    // the file before reading it.</a>
<a name="ln589">    if (!read_stdin) {</a>
<a name="ln590">      close(fd);                // ignore errors</a>
<a name="ln591">    }</a>
<a name="ln592"> </a>
<a name="ln593">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln594">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln595">    // output was done.</a>
<a name="ln596">    msg_scroll = true;</a>
<a name="ln597">    if (filtering) {</a>
<a name="ln598">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln599">                           false, curbuf, eap);</a>
<a name="ln600">    } else if (read_stdin) {</a>
<a name="ln601">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln602">                           false, curbuf, eap);</a>
<a name="ln603">    } else if (newfile) {</a>
<a name="ln604">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln605">                           false, curbuf, eap);</a>
<a name="ln606">    } else {</a>
<a name="ln607">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln608">                           false, NULL, eap);</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">    // autocommands may have changed it</a>
<a name="ln612">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln613">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln614">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln615">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln616"> </a>
<a name="ln617">    if (msg_scrolled == n) {</a>
<a name="ln618">      msg_scroll = m;</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln622">      no_wait_return--;</a>
<a name="ln623">      msg_scroll = msg_save;</a>
<a name="ln624">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln625">      goto theend;</a>
<a name="ln626">    }</a>
<a name="ln627">    // Don't allow the autocommands to change the current buffer.</a>
<a name="ln628">    // Try to re-open the file.</a>
<a name="ln629">    //</a>
<a name="ln630">    // Don't allow the autocommands to change the buffer name either</a>
<a name="ln631">    // (cd for example) if it invalidates fname or sfname.</a>
<a name="ln632">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln633">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln634">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln635">                        || (fd = os_open(fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln636">      no_wait_return--;</a>
<a name="ln637">      msg_scroll = msg_save;</a>
<a name="ln638">      if (fd &lt; 0) {</a>
<a name="ln639">        emsg(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln640">      } else {</a>
<a name="ln641">        emsg(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln642">      }</a>
<a name="ln643">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln644">      goto theend;</a>
<a name="ln645">    }</a>
<a name="ln646">  }</a>
<a name="ln647"> </a>
<a name="ln648">  // Autocommands may add lines to the file, need to check if it is empty</a>
<a name="ln649">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln650"> </a>
<a name="ln651">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln652">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln653">      filemess(curbuf, sfname, &quot;&quot;, 0);</a>
<a name="ln654">    }</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  msg_scroll = false;                   // overwrite the file message</a>
<a name="ln658"> </a>
<a name="ln659">  // Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln660">  // fileformat, and after the autocommands, which may change them.</a>
<a name="ln661">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln662"> </a>
<a name="ln663">  // &quot;++bad=&quot; argument.</a>
<a name="ln664">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln665">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln666">    if (set_options) {</a>
<a name="ln667">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln668">    }</a>
<a name="ln669">  } else {</a>
<a name="ln670">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln671">  }</a>
<a name="ln672"> </a>
<a name="ln673">  // Decide which 'encoding' to use or use first.</a>
<a name="ln674">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln675">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln676">    fenc_alloced = true;</a>
<a name="ln677">    keep_dest_enc = true;</a>
<a name="ln678">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln679">    fenc = &quot;&quot;;                // binary: don't convert</a>
<a name="ln680">    fenc_alloced = false;</a>
<a name="ln681">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln682">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln683">    // fails it must be latin1.</a>
<a name="ln684">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln685">    // That is only in *.??x files.</a>
<a name="ln686">    fenc_next = &quot;latin1&quot;;</a>
<a name="ln687">    fenc = &quot;utf-8&quot;;</a>
<a name="ln688"> </a>
<a name="ln689">    fenc_alloced = false;</a>
<a name="ln690">  } else if (*p_fencs == NUL) {</a>
<a name="ln691">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln692">    fenc_alloced = false;</a>
<a name="ln693">  } else {</a>
<a name="ln694">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln695">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln696">  }</a>
<a name="ln697"> </a>
<a name="ln698">  // Jump back here to retry reading the file in different ways.</a>
<a name="ln699">  // Reasons to retry:</a>
<a name="ln700">  // - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln701">  // - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln702">  // - &quot;fileformat&quot; check failed: try another</a>
<a name="ln703">  //</a>
<a name="ln704">  // Variables set for special retry actions:</a>
<a name="ln705">  // &quot;file_rewind&quot;      Rewind the file to start reading it again.</a>
<a name="ln706">  // &quot;advance_fenc&quot;     Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln707">  // &quot;skip_read&quot;        Re-use already read bytes (BOM detected).</a>
<a name="ln708">  // &quot;did_iconv&quot;        iconv() conversion failed, try 'charconvert'.</a>
<a name="ln709">  // &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln710">  //</a>
<a name="ln711">  // Other status indicators:</a>
<a name="ln712">  // &quot;tmpname&quot;  When != NULL did conversion with 'charconvert'.</a>
<a name="ln713">  //                    Output file has to be deleted afterwards.</a>
<a name="ln714">  // &quot;iconv_fd&quot; When != -1 did conversion with iconv().</a>
<a name="ln715">retry:</a>
<a name="ln716"> </a>
<a name="ln717">  if (file_rewind) {</a>
<a name="ln718">    if (read_buffer) {</a>
<a name="ln719">      read_buf_lnum = 1;</a>
<a name="ln720">      read_buf_col = 0;</a>
<a name="ln721">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln722">      // Can't rewind the file, give up.</a>
<a name="ln723">      error = true;</a>
<a name="ln724">      goto failed;</a>
<a name="ln725">    }</a>
<a name="ln726">    // Delete the previously read lines.</a>
<a name="ln727">    while (lnum &gt; from) {</a>
<a name="ln728">      ml_delete(lnum--, false);</a>
<a name="ln729">    }</a>
<a name="ln730">    file_rewind = false;</a>
<a name="ln731">    if (set_options) {</a>
<a name="ln732">      curbuf-&gt;b_p_bomb = false;</a>
<a name="ln733">      curbuf-&gt;b_start_bomb = false;</a>
<a name="ln734">    }</a>
<a name="ln735">    conv_error = 0;</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">  // When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln739">  // will be reset.</a>
<a name="ln740">  if (keep_fileformat) {</a>
<a name="ln741">    keep_fileformat = false;</a>
<a name="ln742">  } else {</a>
<a name="ln743">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln744">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln745">      try_unix = try_dos = try_mac = false;</a>
<a name="ln746">    } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln747">      fileformat = EOL_UNIX;                    // binary: use Unix format</a>
<a name="ln748">    } else if (*p_ffs ==</a>
<a name="ln749">               NUL) {</a>
<a name="ln750">      fileformat = get_fileformat(curbuf);      // use format from buffer</a>
<a name="ln751">    } else {</a>
<a name="ln752">      fileformat = EOL_UNKNOWN;                 // detect from file</a>
<a name="ln753">    }</a>
<a name="ln754">  }</a>
<a name="ln755"> </a>
<a name="ln756">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln757">    // aborted conversion with iconv(), close the descriptor</a>
<a name="ln758">    iconv_close(iconv_fd);</a>
<a name="ln759">    iconv_fd = (iconv_t)-1;</a>
<a name="ln760">  }</a>
<a name="ln761"> </a>
<a name="ln762">  if (advance_fenc) {</a>
<a name="ln763">    // Try the next entry in 'fileencodings'.</a>
<a name="ln764">    advance_fenc = false;</a>
<a name="ln765"> </a>
<a name="ln766">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln767">      // Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln768">      // without conversion.</a>
<a name="ln769">      notconverted = true;</a>
<a name="ln770">      conv_error = 0;</a>
<a name="ln771">      if (fenc_alloced) {</a>
<a name="ln772">        xfree(fenc);</a>
<a name="ln773">      }</a>
<a name="ln774">      fenc = &quot;&quot;;</a>
<a name="ln775">      fenc_alloced = false;</a>
<a name="ln776">    } else {</a>
<a name="ln777">      if (fenc_alloced) {</a>
<a name="ln778">        xfree(fenc);</a>
<a name="ln779">      }</a>
<a name="ln780">      if (fenc_next != NULL) {</a>
<a name="ln781">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln782">      } else {</a>
<a name="ln783">        fenc = &quot;&quot;;</a>
<a name="ln784">        fenc_alloced = false;</a>
<a name="ln785">      }</a>
<a name="ln786">    }</a>
<a name="ln787">    if (tmpname != NULL) {</a>
<a name="ln788">      os_remove(tmpname);  // delete converted file</a>
<a name="ln789">      XFREE_CLEAR(tmpname);</a>
<a name="ln790">    }</a>
<a name="ln791">  }</a>
<a name="ln792"> </a>
<a name="ln793">  // Conversion may be required when the encoding of the file is different</a>
<a name="ln794">  // from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln795">  fio_flags = 0;</a>
<a name="ln796">  converted = need_conversion(fenc);</a>
<a name="ln797">  if (converted) {</a>
<a name="ln798">    // &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln799">    // for a BOM.</a>
<a name="ln800">    if (strcmp(fenc, ENC_UCSBOM) == 0) {</a>
<a name="ln801">      fio_flags = FIO_UCSBOM;</a>
<a name="ln802">    } else {</a>
<a name="ln803">      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln804">      // done.  This is handled below after read().  Prepare the</a>
<a name="ln805">      // fio_flags to avoid having to parse the string each time.</a>
<a name="ln806">      // Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln807">      // appears not to handle this correctly.  This works just like</a>
<a name="ln808">      // conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln809">      // the buffer.</a>
<a name="ln810">      fio_flags = get_fio_flags(fenc);</a>
<a name="ln811">    }</a>
<a name="ln812"> </a>
<a name="ln813">    // Try using iconv() if we can't convert internally.</a>
<a name="ln814">    if (fio_flags == 0</a>
<a name="ln815">        &amp;&amp; !did_iconv) {</a>
<a name="ln816">      iconv_fd = (iconv_t)my_iconv_open(&quot;utf-8&quot;, fenc);</a>
<a name="ln817">    }</a>
<a name="ln818"> </a>
<a name="ln819">    // Use the 'charconvert' expression when conversion is required</a>
<a name="ln820">    // and we can't do it internally or with iconv().</a>
<a name="ln821">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln822">        &amp;&amp; !read_fifo &amp;&amp; iconv_fd == (iconv_t)-1) {</a>
<a name="ln823">      did_iconv = false;</a>
<a name="ln824">      // Skip conversion when it's already done (retry for wrong</a>
<a name="ln825">      // &quot;fileformat&quot;).</a>
<a name="ln826">      if (tmpname == NULL) {</a>
<a name="ln827">        tmpname = readfile_charconvert(fname, fenc, &amp;fd);</a>
<a name="ln828">        if (tmpname == NULL) {</a>
<a name="ln829">          // Conversion failed.  Try another one.</a>
<a name="ln830">          advance_fenc = true;</a>
<a name="ln831">          if (fd &lt; 0) {</a>
<a name="ln832">            // Re-opening the original file failed!</a>
<a name="ln833">            emsg(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln834">            error = true;</a>
<a name="ln835">            goto failed;</a>
<a name="ln836">          }</a>
<a name="ln837">          goto retry;</a>
<a name="ln838">        }</a>
<a name="ln839">      }</a>
<a name="ln840">    } else {</a>
<a name="ln841">      if (fio_flags == 0 &amp;&amp; iconv_fd == (iconv_t)-1) {</a>
<a name="ln842">        // Conversion wanted but we can't.</a>
<a name="ln843">        // Try the next conversion in 'fileencodings'</a>
<a name="ln844">        advance_fenc = true;</a>
<a name="ln845">        goto retry;</a>
<a name="ln846">      }</a>
<a name="ln847">    }</a>
<a name="ln848">  }</a>
<a name="ln849"> </a>
<a name="ln850">  // Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln851">  // another &quot;fenc&quot; value.  It's false when no other &quot;fenc&quot; to try, reading</a>
<a name="ln852">  // stdin or fixed at a specific encoding.</a>
<a name="ln853">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln854"> </a>
<a name="ln855">  if (!skip_read) {</a>
<a name="ln856">    linerest = 0;</a>
<a name="ln857">    filesize = 0;</a>
<a name="ln858">    skip_count = lines_to_skip;</a>
<a name="ln859">    read_count = lines_to_read;</a>
<a name="ln860">    conv_restlen = 0;</a>
<a name="ln861">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln862">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln863">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln864">                      &amp;&amp; !filtering</a>
<a name="ln865">                      &amp;&amp; !read_fifo</a>
<a name="ln866">                      &amp;&amp; !read_stdin</a>
<a name="ln867">                      &amp;&amp; !read_buffer);</a>
<a name="ln868">    if (read_undo_file) {</a>
<a name="ln869">      sha256_start(&amp;sha_ctx);</a>
<a name="ln870">    }</a>
<a name="ln871">  }</a>
<a name="ln872"> </a>
<a name="ln873">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln874">    // We allocate as much space for the file as we can get, plus</a>
<a name="ln875">    // space for the old line plus room for one terminating NUL.</a>
<a name="ln876">    // The amount is limited by the fact that read() only can read</a>
<a name="ln877">    // up to max_unsigned characters (and other things).</a>
<a name="ln878">    {</a>
<a name="ln879">      if (!skip_read) {</a>
<a name="ln880">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln881">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln882">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln883">        size = 0x10000L + linerest;</a>
<a name="ln884">        if (size &gt; 0x100000L) {</a>
<a name="ln885">          size = 0x100000L;</a>
<a name="ln886">        }</a>
<a name="ln887">      }</a>
<a name="ln888"> </a>
<a name="ln889">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln890">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln891">        split++;</a>
<a name="ln892">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln893">        size = 1;</a>
<a name="ln894">      } else if (!skip_read) {</a>
<a name="ln895">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln896">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln897">          if (new_buffer) {</a>
<a name="ln898">            break;</a>
<a name="ln899">          }</a>
<a name="ln900">        }</a>
<a name="ln901">        if (new_buffer == NULL) {</a>
<a name="ln902">          error = true;</a>
<a name="ln903">          break;</a>
<a name="ln904">        }</a>
<a name="ln905">        if (linerest) {         // copy characters from the previous buffer</a>
<a name="ln906">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln907">        }</a>
<a name="ln908">        xfree(buffer);</a>
<a name="ln909">        buffer = new_buffer;</a>
<a name="ln910">        ptr = buffer + linerest;</a>
<a name="ln911">        line_start = buffer;</a>
<a name="ln912"> </a>
<a name="ln913">        // May need room to translate into.</a>
<a name="ln914">        // For iconv() we don't really know the required space, use a</a>
<a name="ln915">        // factor ICONV_MULT.</a>
<a name="ln916">        // latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln917">        // utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln918">        // become up to 4 bytes, size must be multiple of 2</a>
<a name="ln919">        // ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln920">        // multiple of 2</a>
<a name="ln921">        // ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln922">        // multiple of 4</a>
<a name="ln923">        real_size = (int)size;</a>
<a name="ln924">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln925">          size = size / ICONV_MULT;</a>
<a name="ln926">        } else if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln927">          size = size / 2;</a>
<a name="ln928">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln929">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln930">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln931">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln932">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln933">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln934">        }</a>
<a name="ln935"> </a>
<a name="ln936">        if (conv_restlen &gt; 0) {</a>
<a name="ln937">          // Insert unconverted bytes from previous line.</a>
<a name="ln938">          memmove(ptr, conv_rest, (size_t)conv_restlen);  // -V614</a>
<a name="ln939">          ptr += conv_restlen;</a>
<a name="ln940">          size -= conv_restlen;</a>
<a name="ln941">        }</a>
<a name="ln942"> </a>
<a name="ln943">        if (read_buffer) {</a>
<a name="ln944">          // Read bytes from curbuf.  Used for converting text read</a>
<a name="ln945">          // from stdin.</a>
<a name="ln946">          if (read_buf_lnum &gt; from) {</a>
<a name="ln947">            size = 0;</a>
<a name="ln948">          } else {</a>
<a name="ln949">            int ni;</a>
<a name="ln950">            long tlen = 0;</a>
<a name="ln951">            while (true) {</a>
<a name="ln952">              p = (uint8_t *)ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln953">              int n = (int)strlen((char *)p);</a>
<a name="ln954">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln955">                // Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln956">                // Change NL to NUL to reverse the effect done</a>
<a name="ln957">                // below.</a>
<a name="ln958">                n = (int)(size - tlen);</a>
<a name="ln959">                for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln960">                  if (p[ni] == NL) {</a>
<a name="ln961">                    ptr[tlen++] = NUL;</a>
<a name="ln962">                  } else {</a>
<a name="ln963">                    ptr[tlen++] = (char)p[ni];</a>
<a name="ln964">                  }</a>
<a name="ln965">                }</a>
<a name="ln966">                read_buf_col += n;</a>
<a name="ln967">                break;</a>
<a name="ln968">              }</a>
<a name="ln969"> </a>
<a name="ln970">              // Append whole line and new-line.  Change NL</a>
<a name="ln971">              // to NUL to reverse the effect done below.</a>
<a name="ln972">              for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln973">                if (p[ni] == NL) {</a>
<a name="ln974">                  ptr[tlen++] = NUL;</a>
<a name="ln975">                } else {</a>
<a name="ln976">                  ptr[tlen++] = (char)p[ni];</a>
<a name="ln977">                }</a>
<a name="ln978">              }</a>
<a name="ln979">              ptr[tlen++] = NL;</a>
<a name="ln980">              read_buf_col = 0;</a>
<a name="ln981">              if (++read_buf_lnum &gt; from) {</a>
<a name="ln982">                // When the last line didn't have an</a>
<a name="ln983">                // end-of-line don't add it now either.</a>
<a name="ln984">                if (!curbuf-&gt;b_p_eol) {</a>
<a name="ln985">                  tlen--;</a>
<a name="ln986">                }</a>
<a name="ln987">                size = tlen;</a>
<a name="ln988">                break;</a>
<a name="ln989">              }</a>
<a name="ln990">            }</a>
<a name="ln991">          }</a>
<a name="ln992">        } else {</a>
<a name="ln993">          // Read bytes from the file.</a>
<a name="ln994">          size_t read_size = (size_t)size;</a>
<a name="ln995">          size = read_eintr(fd, ptr, read_size);</a>
<a name="ln996">        }</a>
<a name="ln997"> </a>
<a name="ln998">        if (size &lt;= 0) {</a>
<a name="ln999">          if (size &lt; 0) {                           // read error</a>
<a name="ln1000">            error = true;</a>
<a name="ln1001">          } else if (conv_restlen &gt; 0) {</a>
<a name="ln1002">            // Reached end-of-file but some trailing bytes could</a>
<a name="ln1003">            // not be converted.  Truncated file?</a>
<a name="ln1004"> </a>
<a name="ln1005">            // When we did a conversion report an error.</a>
<a name="ln1006">            if (fio_flags != 0 || iconv_fd != (iconv_t)-1) {</a>
<a name="ln1007">              if (can_retry) {</a>
<a name="ln1008">                goto rewind_retry;</a>
<a name="ln1009">              }</a>
<a name="ln1010">              if (conv_error == 0) {</a>
<a name="ln1011">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1012">                             - linecnt + 1;</a>
<a name="ln1013">              }</a>
<a name="ln1014">            } else if (illegal_byte == 0) {</a>
<a name="ln1015">              // Remember the first linenr with an illegal byte</a>
<a name="ln1016">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1017">                             - linecnt + 1;</a>
<a name="ln1018">            }</a>
<a name="ln1019">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1020">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1021">              conv_restlen = 0;</a>
<a name="ln1022">            } else {</a>
<a name="ln1023">              // Replace the trailing bytes with the replacement</a>
<a name="ln1024">              // character if we were converting; if we weren't,</a>
<a name="ln1025">              // leave the UTF8 checking code to do it, as it</a>
<a name="ln1026">              // works slightly differently.</a>
<a name="ln1027">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0 || iconv_fd != (iconv_t)-1)) {</a>
<a name="ln1028">                while (conv_restlen &gt; 0) {</a>
<a name="ln1029">                  *(--ptr) = (char)bad_char_behavior;</a>
<a name="ln1030">                  conv_restlen--;</a>
<a name="ln1031">                }</a>
<a name="ln1032">              }</a>
<a name="ln1033">              fio_flags = 0;  // don't convert this</a>
<a name="ln1034">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1035">                iconv_close(iconv_fd);</a>
<a name="ln1036">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1037">              }</a>
<a name="ln1038">            }</a>
<a name="ln1039">          }</a>
<a name="ln1040">        }</a>
<a name="ln1041">      }</a>
<a name="ln1042"> </a>
<a name="ln1043">      skip_read = false;</a>
<a name="ln1044"> </a>
<a name="ln1045">      // At start of file: Check for BOM.</a>
<a name="ln1046">      // Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1047">      // converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1048">      // found.</a>
<a name="ln1049">      if ((filesize == 0)</a>
<a name="ln1050">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1051">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1052">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1053">                  &amp;&amp; (*fenc == 'u' || *fenc == NUL)))) {</a>
<a name="ln1054">        char *ccname;</a>
<a name="ln1055">        int blen = 0;</a>
<a name="ln1056"> </a>
<a name="ln1057">        // no BOM detection in a short file or in binary mode</a>
<a name="ln1058">        if (size &lt; 2 || curbuf-&gt;b_p_bin) {</a>
<a name="ln1059">          ccname = NULL;</a>
<a name="ln1060">        } else {</a>
<a name="ln1061">          ccname = check_for_bom(ptr, (int)size, &amp;blen,</a>
<a name="ln1062">                                 fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));</a>
<a name="ln1063">        }</a>
<a name="ln1064">        if (ccname != NULL) {</a>
<a name="ln1065">          // Remove BOM from the text</a>
<a name="ln1066">          filesize += blen;</a>
<a name="ln1067">          size -= blen;</a>
<a name="ln1068">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1069">          if (set_options) {</a>
<a name="ln1070">            curbuf-&gt;b_p_bomb = true;</a>
<a name="ln1071">            curbuf-&gt;b_start_bomb = true;</a>
<a name="ln1072">          }</a>
<a name="ln1073">        }</a>
<a name="ln1074"> </a>
<a name="ln1075">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1076">          if (ccname == NULL) {</a>
<a name="ln1077">            // No BOM detected: retry with next encoding.</a>
<a name="ln1078">            advance_fenc = true;</a>
<a name="ln1079">          } else {</a>
<a name="ln1080">            // BOM detected: set &quot;fenc&quot; and jump back</a>
<a name="ln1081">            if (fenc_alloced) {</a>
<a name="ln1082">              xfree(fenc);</a>
<a name="ln1083">            }</a>
<a name="ln1084">            fenc = ccname;</a>
<a name="ln1085">            fenc_alloced = false;</a>
<a name="ln1086">          }</a>
<a name="ln1087">          // retry reading without getting new bytes or rewinding</a>
<a name="ln1088">          skip_read = true;</a>
<a name="ln1089">          goto retry;</a>
<a name="ln1090">        }</a>
<a name="ln1091">      }</a>
<a name="ln1092"> </a>
<a name="ln1093">      // Include not converted bytes.</a>
<a name="ln1094">      ptr -= conv_restlen;</a>
<a name="ln1095">      size += conv_restlen;</a>
<a name="ln1096">      conv_restlen = 0;</a>
<a name="ln1097">      // Break here for a read error or end-of-file.</a>
<a name="ln1098">      if (size &lt;= 0) {</a>
<a name="ln1099">        break;</a>
<a name="ln1100">      }</a>
<a name="ln1101"> </a>
<a name="ln1102">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1103">        // Attempt conversion of the read bytes to 'encoding' using iconv().</a>
<a name="ln1104">        const char *fromp = ptr;</a>
<a name="ln1105">        size_t from_size = (size_t)size;</a>
<a name="ln1106">        ptr += size;</a>
<a name="ln1107">        char *top = ptr;</a>
<a name="ln1108">        size_t to_size = (size_t)(real_size - size);</a>
<a name="ln1109"> </a>
<a name="ln1110">        // If there is conversion error or not enough room try using</a>
<a name="ln1111">        // another conversion.  Except for when there is no</a>
<a name="ln1112">        // alternative (help files).</a>
<a name="ln1113">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1114">                      &amp;top, &amp;to_size)</a>
<a name="ln1115">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1116">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1117">          if (can_retry) {</a>
<a name="ln1118">            goto rewind_retry;</a>
<a name="ln1119">          }</a>
<a name="ln1120">          if (conv_error == 0) {</a>
<a name="ln1121">            conv_error = readfile_linenr(linecnt, ptr, top);</a>
<a name="ln1122">          }</a>
<a name="ln1123"> </a>
<a name="ln1124">          // Deal with a bad byte and continue with the next.</a>
<a name="ln1125">          fromp++;</a>
<a name="ln1126">          from_size--;</a>
<a name="ln1127">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1128">            *top++ = *(fromp - 1);</a>
<a name="ln1129">            to_size--;</a>
<a name="ln1130">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1131">            *top++ = (char)bad_char_behavior;</a>
<a name="ln1132">            to_size--;</a>
<a name="ln1133">          }</a>
<a name="ln1134">        }</a>
<a name="ln1135"> </a>
<a name="ln1136">        if (from_size &gt; 0) {</a>
<a name="ln1137">          // Some remaining characters, keep them for the next</a>
<a name="ln1138">          // round.</a>
<a name="ln1139">          memmove(conv_rest, fromp, from_size);</a>
<a name="ln1140">          conv_restlen = (int)from_size;</a>
<a name="ln1141">        }</a>
<a name="ln1142"> </a>
<a name="ln1143">        // move the linerest to before the converted characters</a>
<a name="ln1144">        line_start = ptr - linerest;</a>
<a name="ln1145">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1146">        size = (top - ptr);</a>
<a name="ln1147">      }</a>
<a name="ln1148"> </a>
<a name="ln1149">      if (fio_flags != 0) {</a>
<a name="ln1150">        unsigned u8c;</a>
<a name="ln1151">        char *dest;</a>
<a name="ln1152">        char *tail = NULL;</a>
<a name="ln1153"> </a>
<a name="ln1154">        // Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1155">        // Go from end to start through the buffer, because the number</a>
<a name="ln1156">        // of bytes may increase.</a>
<a name="ln1157">        // &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1158">        // to after the next character to convert.</a>
<a name="ln1159">        dest = ptr + real_size;</a>
<a name="ln1160">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1161">          p = (uint8_t *)ptr + size;</a>
<a name="ln1162">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1163">            // Check for a trailing incomplete UTF-8 sequence</a>
<a name="ln1164">            tail = ptr + size - 1;</a>
<a name="ln1165">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80) {</a>
<a name="ln1166">              tail--;</a>
<a name="ln1167">            }</a>
<a name="ln1168">            if (tail + utf_byte2len(*tail) &lt;= ptr + size) {</a>
<a name="ln1169">              tail = NULL;</a>
<a name="ln1170">            } else {</a>
<a name="ln1171">              p = (uint8_t *)tail;</a>
<a name="ln1172">            }</a>
<a name="ln1173">          }</a>
<a name="ln1174">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1175">          // Check for a trailing byte</a>
<a name="ln1176">          p = (uint8_t *)ptr + (size &amp; ~1);</a>
<a name="ln1177">          if (size &amp; 1) {</a>
<a name="ln1178">            tail = (char *)p;</a>
<a name="ln1179">          }</a>
<a name="ln1180">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; (uint8_t *)ptr) {</a>
<a name="ln1181">            // Check for a trailing leading word</a>
<a name="ln1182">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1183">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1184">              u8c += *--p;</a>
<a name="ln1185">            } else {</a>
<a name="ln1186">              u8c = *--p;</a>
<a name="ln1187">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1188">            }</a>
<a name="ln1189">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff) {</a>
<a name="ln1190">              tail = (char *)p;</a>
<a name="ln1191">            } else {</a>
<a name="ln1192">              p += 2;</a>
<a name="ln1193">            }</a>
<a name="ln1194">          }</a>
<a name="ln1195">        } else {   //  FIO_UCS4</a>
<a name="ln1196">                   // Check for trailing 1, 2 or 3 bytes</a>
<a name="ln1197">          p = (uint8_t *)ptr + (size &amp; ~3);</a>
<a name="ln1198">          if (size &amp; 3) {</a>
<a name="ln1199">            tail = (char *)p;</a>
<a name="ln1200">          }</a>
<a name="ln1201">        }</a>
<a name="ln1202"> </a>
<a name="ln1203">        // If there is a trailing incomplete sequence move it to</a>
<a name="ln1204">        // conv_rest[].</a>
<a name="ln1205">        if (tail != NULL) {</a>
<a name="ln1206">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1207">          memmove(conv_rest, tail, (size_t)conv_restlen);</a>
<a name="ln1208">          size -= conv_restlen;</a>
<a name="ln1209">        }</a>
<a name="ln1210"> </a>
<a name="ln1211">        while (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1212">          if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln1213">            u8c = *--p;</a>
<a name="ln1214">          } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1215">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1216">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1217">              u8c += *--p;</a>
<a name="ln1218">            } else {</a>
<a name="ln1219">              u8c = *--p;</a>
<a name="ln1220">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1221">            }</a>
<a name="ln1222">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1223">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1224">              int u16c;</a>
<a name="ln1225"> </a>
<a name="ln1226">              if (p == (uint8_t *)ptr) {</a>
<a name="ln1227">                // Missing leading word.</a>
<a name="ln1228">                if (can_retry) {</a>
<a name="ln1229">                  goto rewind_retry;</a>
<a name="ln1230">                }</a>
<a name="ln1231">                if (conv_error == 0) {</a>
<a name="ln1232">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1233">                }</a>
<a name="ln1234">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1235">                  continue;</a>
<a name="ln1236">                }</a>
<a name="ln1237">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1238">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1239">                }</a>
<a name="ln1240">              }</a>
<a name="ln1241"> </a>
<a name="ln1242">              // found second word of double-word, get the first</a>
<a name="ln1243">              // word and compute the resulting character</a>
<a name="ln1244">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1245">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1246">                u16c += *--p;</a>
<a name="ln1247">              } else {</a>
<a name="ln1248">                u16c = *--p;</a>
<a name="ln1249">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1250">              }</a>
<a name="ln1251">              u8c = 0x10000 + (((unsigned)u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1252">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1253"> </a>
<a name="ln1254">              // Check if the word is indeed a leading word.</a>
<a name="ln1255">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1256">                if (can_retry) {</a>
<a name="ln1257">                  goto rewind_retry;</a>
<a name="ln1258">                }</a>
<a name="ln1259">                if (conv_error == 0) {</a>
<a name="ln1260">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1261">                }</a>
<a name="ln1262">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1263">                  continue;</a>
<a name="ln1264">                }</a>
<a name="ln1265">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1266">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1267">                }</a>
<a name="ln1268">              }</a>
<a name="ln1269">            }</a>
<a name="ln1270">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1271">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1272">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1273">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1274">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1275">              u8c += *--p;</a>
<a name="ln1276">            } else {          // big endian</a>
<a name="ln1277">              u8c = *--p;</a>
<a name="ln1278">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1279">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1280">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1281">            }</a>
<a name="ln1282">            // Replace characters over INT_MAX with Unicode replacement character</a>
<a name="ln1283">            if (u8c &gt; INT_MAX) {</a>
<a name="ln1284">              u8c = 0xfffd;</a>
<a name="ln1285">            }</a>
<a name="ln1286">          } else {        // UTF-8</a>
<a name="ln1287">            if (*--p &lt; 0x80) {</a>
<a name="ln1288">              u8c = *p;</a>
<a name="ln1289">            } else {</a>
<a name="ln1290">              len = utf_head_off(ptr, (char *)p);</a>
<a name="ln1291">              p -= len;</a>
<a name="ln1292">              u8c = (unsigned)utf_ptr2char((char *)p);</a>
<a name="ln1293">              if (len == 0) {</a>
<a name="ln1294">                // Not a valid UTF-8 character, retry with</a>
<a name="ln1295">                // another fenc when possible, otherwise just</a>
<a name="ln1296">                // report the error.</a>
<a name="ln1297">                if (can_retry) {</a>
<a name="ln1298">                  goto rewind_retry;</a>
<a name="ln1299">                }</a>
<a name="ln1300">                if (conv_error == 0) {</a>
<a name="ln1301">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1302">                }</a>
<a name="ln1303">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1304">                  continue;</a>
<a name="ln1305">                }</a>
<a name="ln1306">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1307">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1308">                }</a>
<a name="ln1309">              }</a>
<a name="ln1310">            }</a>
<a name="ln1311">          }</a>
<a name="ln1312">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1313">          // produce UTF-8</a>
<a name="ln1314">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1315">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1316">        }</a>
<a name="ln1317"> </a>
<a name="ln1318">        // move the linerest to before the converted characters</a>
<a name="ln1319">        line_start = dest - linerest;</a>
<a name="ln1320">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1321">        size = ((ptr + real_size) - dest);</a>
<a name="ln1322">        ptr = dest;</a>
<a name="ln1323">      } else if (!curbuf-&gt;b_p_bin) {</a>
<a name="ln1324">        bool incomplete_tail = false;</a>
<a name="ln1325"> </a>
<a name="ln1326">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1327">        for (p = (uint8_t *)ptr;; p++) {</a>
<a name="ln1328">          int todo = (int)(((uint8_t *)ptr + size) - p);</a>
<a name="ln1329">          int l;</a>
<a name="ln1330"> </a>
<a name="ln1331">          if (todo &lt;= 0) {</a>
<a name="ln1332">            break;</a>
<a name="ln1333">          }</a>
<a name="ln1334">          if (*p &gt;= 0x80) {</a>
<a name="ln1335">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1336">            // an incomplete character at the end though, the next</a>
<a name="ln1337">            // read() will get the next bytes, we'll check it</a>
<a name="ln1338">            // then.</a>
<a name="ln1339">            l = utf_ptr2len_len((char *)p, todo);</a>
<a name="ln1340">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1341">              // Avoid retrying with a different encoding when</a>
<a name="ln1342">              // a truncated file is more likely, or attempting</a>
<a name="ln1343">              // to read the rest of an incomplete sequence when</a>
<a name="ln1344">              // we have already done so.</a>
<a name="ln1345">              if (p &gt; (uint8_t *)ptr || filesize &gt; 0) {</a>
<a name="ln1346">                incomplete_tail = true;</a>
<a name="ln1347">              }</a>
<a name="ln1348">              // Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1349">              // and try to read the rest of it, unless we've</a>
<a name="ln1350">              // already done so.</a>
<a name="ln1351">              if (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1352">                conv_restlen = todo;</a>
<a name="ln1353">                memmove(conv_rest, p, (size_t)conv_restlen);</a>
<a name="ln1354">                size -= conv_restlen;</a>
<a name="ln1355">                break;</a>
<a name="ln1356">              }</a>
<a name="ln1357">            }</a>
<a name="ln1358">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1359">              // Illegal byte.  If we can try another encoding</a>
<a name="ln1360">              // do that, unless at EOF where a truncated</a>
<a name="ln1361">              // file is more likely than a conversion error.</a>
<a name="ln1362">              if (can_retry &amp;&amp; !incomplete_tail) {</a>
<a name="ln1363">                break;</a>
<a name="ln1364">              }</a>
<a name="ln1365"> </a>
<a name="ln1366">              // When we did a conversion report an error.</a>
<a name="ln1367">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1368">                conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1369">              }</a>
<a name="ln1370"> </a>
<a name="ln1371">              // Remember the first linenr with an illegal byte</a>
<a name="ln1372">              if (conv_error == 0 &amp;&amp; illegal_byte == 0) {</a>
<a name="ln1373">                illegal_byte = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1374">              }</a>
<a name="ln1375"> </a>
<a name="ln1376">              // Drop, keep or replace the bad byte.</a>
<a name="ln1377">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1378">                memmove(p, p + 1, (size_t)(todo - 1));</a>
<a name="ln1379">                p--;</a>
<a name="ln1380">                size--;</a>
<a name="ln1381">              } else if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1382">                *p = (uint8_t)bad_char_behavior;</a>
<a name="ln1383">              }</a>
<a name="ln1384">            } else {</a>
<a name="ln1385">              p += l - 1;</a>
<a name="ln1386">            }</a>
<a name="ln1387">          }</a>
<a name="ln1388">        }</a>
<a name="ln1389">        if (p &lt; (uint8_t *)ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1390">          // Detected a UTF-8 error.</a>
<a name="ln1391">rewind_retry:</a>
<a name="ln1392">          // Retry reading with another conversion.</a>
<a name="ln1393">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1394">            // iconv() failed, try 'charconvert'</a>
<a name="ln1395">            did_iconv = true;</a>
<a name="ln1396">          } else {</a>
<a name="ln1397">            // use next item from 'fileencodings'</a>
<a name="ln1398">            advance_fenc = true;</a>
<a name="ln1399">          }</a>
<a name="ln1400">          file_rewind = true;</a>
<a name="ln1401">          goto retry;</a>
<a name="ln1402">        }</a>
<a name="ln1403">      }</a>
<a name="ln1404"> </a>
<a name="ln1405">      // count the number of characters (after conversion!)</a>
<a name="ln1406">      filesize += size;</a>
<a name="ln1407"> </a>
<a name="ln1408">      // when reading the first part of a file: guess EOL type</a>
<a name="ln1409">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1410">        // First try finding a NL, for Dos and Unix</a>
<a name="ln1411">        if (try_dos || try_unix) {</a>
<a name="ln1412">          // Reset the carriage return counter.</a>
<a name="ln1413">          if (try_mac) {</a>
<a name="ln1414">            try_mac = 1;</a>
<a name="ln1415">          }</a>
<a name="ln1416"> </a>
<a name="ln1417">          for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1418">            if (*p == NL) {</a>
<a name="ln1419">              if (!try_unix</a>
<a name="ln1420">                  || (try_dos &amp;&amp; p &gt; (uint8_t *)ptr &amp;&amp; p[-1] == CAR)) {</a>
<a name="ln1421">                fileformat = EOL_DOS;</a>
<a name="ln1422">              } else {</a>
<a name="ln1423">                fileformat = EOL_UNIX;</a>
<a name="ln1424">              }</a>
<a name="ln1425">              break;</a>
<a name="ln1426">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1427">              try_mac++;</a>
<a name="ln1428">            }</a>
<a name="ln1429">          }</a>
<a name="ln1430"> </a>
<a name="ln1431">          // Don't give in to EOL_UNIX if EOL_MAC is more likely</a>
<a name="ln1432">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1433">            // Need to reset the counters when retrying fenc.</a>
<a name="ln1434">            try_mac = 1;</a>
<a name="ln1435">            try_unix = 1;</a>
<a name="ln1436">            for (; p &gt;= (uint8_t *)ptr &amp;&amp; *p != CAR; p--) {}</a>
<a name="ln1437">            if (p &gt;= (uint8_t *)ptr) {</a>
<a name="ln1438">              for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1439">                if (*p == NL) {</a>
<a name="ln1440">                  try_unix++;</a>
<a name="ln1441">                } else if (*p == CAR) {</a>
<a name="ln1442">                  try_mac++;</a>
<a name="ln1443">                }</a>
<a name="ln1444">              }</a>
<a name="ln1445">              if (try_mac &gt; try_unix) {</a>
<a name="ln1446">                fileformat = EOL_MAC;</a>
<a name="ln1447">              }</a>
<a name="ln1448">            }</a>
<a name="ln1449">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1450">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1451">            // use the default format.</a>
<a name="ln1452">            fileformat = default_fileformat();</a>
<a name="ln1453">          }</a>
<a name="ln1454">        }</a>
<a name="ln1455"> </a>
<a name="ln1456">        // No NL found: may use Mac format</a>
<a name="ln1457">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac) {</a>
<a name="ln1458">          fileformat = EOL_MAC;</a>
<a name="ln1459">        }</a>
<a name="ln1460"> </a>
<a name="ln1461">        // Still nothing found?  Use first format in 'ffs'</a>
<a name="ln1462">        if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1463">          fileformat = default_fileformat();</a>
<a name="ln1464">        }</a>
<a name="ln1465"> </a>
<a name="ln1466">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1467">        if (set_options) {</a>
<a name="ln1468">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1469">        }</a>
<a name="ln1470">      }</a>
<a name="ln1471">    }</a>
<a name="ln1472"> </a>
<a name="ln1473">    // This loop is executed once for every character read.</a>
<a name="ln1474">    // Keep it fast!</a>
<a name="ln1475">    if (fileformat == EOL_MAC) {</a>
<a name="ln1476">      ptr--;</a>
<a name="ln1477">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1478">        // catch most common case first</a>
<a name="ln1479">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL) {</a>
<a name="ln1480">          continue;</a>
<a name="ln1481">        }</a>
<a name="ln1482">        if (c == NUL) {</a>
<a name="ln1483">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1484">        } else if (c == NL) {</a>
<a name="ln1485">          *ptr = CAR;           // NLs are replaced by CRs!</a>
<a name="ln1486">        } else {</a>
<a name="ln1487">          if (skip_count == 0) {</a>
<a name="ln1488">            *ptr = NUL;                     // end of line</a>
<a name="ln1489">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1490">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1491">              error = true;</a>
<a name="ln1492">              break;</a>
<a name="ln1493">            }</a>
<a name="ln1494">            if (read_undo_file) {</a>
<a name="ln1495">              sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1496">            }</a>
<a name="ln1497">            lnum++;</a>
<a name="ln1498">            if (--read_count == 0) {</a>
<a name="ln1499">              error = true;                     // break loop</a>
<a name="ln1500">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1501">              break;</a>
<a name="ln1502">            }</a>
<a name="ln1503">          } else {</a>
<a name="ln1504">            skip_count--;</a>
<a name="ln1505">          }</a>
<a name="ln1506">          line_start = ptr + 1;</a>
<a name="ln1507">        }</a>
<a name="ln1508">      }</a>
<a name="ln1509">    } else {</a>
<a name="ln1510">      ptr--;</a>
<a name="ln1511">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1512">        if ((c = *ptr) != NUL &amp;&amp; c != NL) {        // catch most common case</a>
<a name="ln1513">          continue;</a>
<a name="ln1514">        }</a>
<a name="ln1515">        if (c == NUL) {</a>
<a name="ln1516">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1517">        } else {</a>
<a name="ln1518">          if (skip_count == 0) {</a>
<a name="ln1519">            *ptr = NUL;                         // end of line</a>
<a name="ln1520">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1521">            if (fileformat == EOL_DOS) {</a>
<a name="ln1522">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1523">                // remove CR before NL</a>
<a name="ln1524">                ptr[-1] = NUL;</a>
<a name="ln1525">                len--;</a>
<a name="ln1526">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1527">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1528">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1529">                // the lines read so far and start all over again.</a>
<a name="ln1530">                // Otherwise give an error message later.</a>
<a name="ln1531">                if (try_unix</a>
<a name="ln1532">                    &amp;&amp; !read_stdin</a>
<a name="ln1533">                    &amp;&amp; (read_buffer</a>
<a name="ln1534">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1535">                  fileformat = EOL_UNIX;</a>
<a name="ln1536">                  if (set_options) {</a>
<a name="ln1537">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1538">                  }</a>
<a name="ln1539">                  file_rewind = true;</a>
<a name="ln1540">                  keep_fileformat = true;</a>
<a name="ln1541">                  goto retry;</a>
<a name="ln1542">                }</a>
<a name="ln1543">                ff_error = EOL_DOS;</a>
<a name="ln1544">              }</a>
<a name="ln1545">            }</a>
<a name="ln1546">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1547">              error = true;</a>
<a name="ln1548">              break;</a>
<a name="ln1549">            }</a>
<a name="ln1550">            if (read_undo_file) {</a>
<a name="ln1551">              sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1552">            }</a>
<a name="ln1553">            lnum++;</a>
<a name="ln1554">            if (--read_count == 0) {</a>
<a name="ln1555">              error = true;                         // break loop</a>
<a name="ln1556">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1557">              break;</a>
<a name="ln1558">            }</a>
<a name="ln1559">          } else {</a>
<a name="ln1560">            skip_count--;</a>
<a name="ln1561">          }</a>
<a name="ln1562">          line_start = ptr + 1;</a>
<a name="ln1563">        }</a>
<a name="ln1564">      }</a>
<a name="ln1565">    }</a>
<a name="ln1566">    linerest = (ptr - line_start);</a>
<a name="ln1567">    os_breakcheck();</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">failed:</a>
<a name="ln1571">  // not an error, max. number of lines reached</a>
<a name="ln1572">  if (error &amp;&amp; read_count == 0) {</a>
<a name="ln1573">    error = false;</a>
<a name="ln1574">  }</a>
<a name="ln1575"> </a>
<a name="ln1576">  // In Dos format ignore a trailing CTRL-Z, unless 'binary' is set.</a>
<a name="ln1577">  // In old days the file length was in sector count and the CTRL-Z the</a>
<a name="ln1578">  // marker where the file really ended.  Assuming we write it to a file</a>
<a name="ln1579">  // system that keeps file length properly the CTRL-Z should be dropped.</a>
<a name="ln1580">  // Set the 'endoffile' option so the user can decide what to write later.</a>
<a name="ln1581">  // In Unix format the CTRL-Z is just another character.</a>
<a name="ln1582">  if (linerest != 0</a>
<a name="ln1583">      &amp;&amp; !curbuf-&gt;b_p_bin</a>
<a name="ln1584">      &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1585">      &amp;&amp; ptr[-1] == Ctrl_Z) {</a>
<a name="ln1586">    ptr--;</a>
<a name="ln1587">    linerest--;</a>
<a name="ln1588">    if (set_options) {</a>
<a name="ln1589">      curbuf-&gt;b_p_eof = true;</a>
<a name="ln1590">    }</a>
<a name="ln1591">  }</a>
<a name="ln1592"> </a>
<a name="ln1593">  // If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1594">  // complete the line ourselves.</a>
<a name="ln1595">  if (!error</a>
<a name="ln1596">      &amp;&amp; !got_int</a>
<a name="ln1597">      &amp;&amp; linerest != 0) {</a>
<a name="ln1598">    // remember for when writing</a>
<a name="ln1599">    if (set_options) {</a>
<a name="ln1600">      curbuf-&gt;b_p_eol = false;</a>
<a name="ln1601">    }</a>
<a name="ln1602">    *ptr = NUL;</a>
<a name="ln1603">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1604">    if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1605">      error = true;</a>
<a name="ln1606">    } else {</a>
<a name="ln1607">      if (read_undo_file) {</a>
<a name="ln1608">        sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1609">      }</a>
<a name="ln1610">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1611">    }</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  if (set_options) {</a>
<a name="ln1615">    // Remember the current file format.</a>
<a name="ln1616">    save_file_ff(curbuf);</a>
<a name="ln1617">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1618">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1619">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1620">  }</a>
<a name="ln1621">  if (fenc_alloced) {</a>
<a name="ln1622">    xfree(fenc);</a>
<a name="ln1623">  }</a>
<a name="ln1624">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1625">    iconv_close(iconv_fd);</a>
<a name="ln1626">  }</a>
<a name="ln1627"> </a>
<a name="ln1628">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1629">    close(fd);  // errors are ignored</a>
<a name="ln1630">  } else {</a>
<a name="ln1631">    (void)os_set_cloexec(fd);</a>
<a name="ln1632">  }</a>
<a name="ln1633">  xfree(buffer);</a>
<a name="ln1634"> </a>
<a name="ln1635">  if (read_stdin) {</a>
<a name="ln1636">    close(fd);</a>
<a name="ln1637">    if (stdin_fd &lt; 0) {</a>
<a name="ln1638">#ifndef MSWIN</a>
<a name="ln1639">      // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1640">      vim_ignored = dup(2);</a>
<a name="ln1641">#else</a>
<a name="ln1642">      // On Windows, use the console input handle for stdin.</a>
<a name="ln1643">      HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1644">                                FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1645">                                OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1646">      vim_ignored = _open_osfhandle((intptr_t)conin, _O_RDONLY);</a>
<a name="ln1647">#endif</a>
<a name="ln1648">    }</a>
<a name="ln1649">  }</a>
<a name="ln1650"> </a>
<a name="ln1651">  if (tmpname != NULL) {</a>
<a name="ln1652">    os_remove(tmpname);  // delete converted file</a>
<a name="ln1653">    xfree(tmpname);</a>
<a name="ln1654">  }</a>
<a name="ln1655">  no_wait_return--;                     // may wait for return now</a>
<a name="ln1656"> </a>
<a name="ln1657">  // In recovery mode everything but autocommands is skipped.</a>
<a name="ln1658">  if (!recoverymode) {</a>
<a name="ln1659">    // need to delete the last line, which comes from the empty buffer</a>
<a name="ln1660">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1661">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1662">      linecnt--;</a>
<a name="ln1663">    }</a>
<a name="ln1664">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1665">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1666">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1667">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1668">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1669">    if (filesize == 0) {</a>
<a name="ln1670">      linecnt = 0;</a>
<a name="ln1671">    }</a>
<a name="ln1672">    if (newfile || read_buffer) {</a>
<a name="ln1673">      redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln1674">      // After reading the text into the buffer the diff info needs to</a>
<a name="ln1675">      // be updated.</a>
<a name="ln1676">      diff_invalidate(curbuf);</a>
<a name="ln1677">      // All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1678">      // before triggering autocommands.</a>
<a name="ln1679">      foldUpdateAll(curwin);</a>
<a name="ln1680">    } else if (linecnt) {               // appended at least one line</a>
<a name="ln1681">      appended_lines_mark(from, linecnt);</a>
<a name="ln1682">    }</a>
<a name="ln1683"> </a>
<a name="ln1684">    if (got_int) {</a>
<a name="ln1685">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1686">        filemess(curbuf, sfname, _(e_interr), 0);</a>
<a name="ln1687">        if (newfile) {</a>
<a name="ln1688">          curbuf-&gt;b_p_ro = true;                // must use &quot;w!&quot; now</a>
<a name="ln1689">        }</a>
<a name="ln1690">      }</a>
<a name="ln1691">      msg_scroll = msg_save;</a>
<a name="ln1692">      check_marks_read();</a>
<a name="ln1693">      retval = OK;        // an interrupt isn't really an error</a>
<a name="ln1694">      goto theend;</a>
<a name="ln1695">    }</a>
<a name="ln1696"> </a>
<a name="ln1697">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln1698">      add_quoted_fname(IObuff, IOSIZE, curbuf, sfname);</a>
<a name="ln1699">      c = false;</a>
<a name="ln1700"> </a>
<a name="ln1701">#ifdef UNIX</a>
<a name="ln1702">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1703">        xstrlcat(IObuff, _(&quot;[fifo]&quot;), IOSIZE);</a>
<a name="ln1704">        c = true;</a>
<a name="ln1705">      }</a>
<a name="ln1706">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1707">        xstrlcat(IObuff, _(&quot;[socket]&quot;), IOSIZE);</a>
<a name="ln1708">        c = true;</a>
<a name="ln1709">      }</a>
<a name="ln1710"># ifdef OPEN_CHR_FILES</a>
<a name="ln1711">      if (S_ISCHR(perm)) {                          // or character special</a>
<a name="ln1712">        xstrlcat(IObuff, _(&quot;[character special]&quot;), IOSIZE);</a>
<a name="ln1713">        c = true;</a>
<a name="ln1714">      }</a>
<a name="ln1715"># endif</a>
<a name="ln1716">#endif</a>
<a name="ln1717">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1718">        xstrlcat(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;), IOSIZE);</a>
<a name="ln1719">        c = true;</a>
<a name="ln1720">      }</a>
<a name="ln1721">      if (read_no_eol_lnum) {</a>
<a name="ln1722">        xstrlcat(IObuff, _(&quot;[noeol]&quot;), IOSIZE);</a>
<a name="ln1723">        c = true;</a>
<a name="ln1724">      }</a>
<a name="ln1725">      if (ff_error == EOL_DOS) {</a>
<a name="ln1726">        xstrlcat(IObuff, _(&quot;[CR missing]&quot;), IOSIZE);</a>
<a name="ln1727">        c = true;</a>
<a name="ln1728">      }</a>
<a name="ln1729">      if (split) {</a>
<a name="ln1730">        xstrlcat(IObuff, _(&quot;[long lines split]&quot;), IOSIZE);</a>
<a name="ln1731">        c = true;</a>
<a name="ln1732">      }</a>
<a name="ln1733">      if (notconverted) {</a>
<a name="ln1734">        xstrlcat(IObuff, _(&quot;[NOT converted]&quot;), IOSIZE);</a>
<a name="ln1735">        c = true;</a>
<a name="ln1736">      } else if (converted) {</a>
<a name="ln1737">        xstrlcat(IObuff, _(&quot;[converted]&quot;), IOSIZE);</a>
<a name="ln1738">        c = true;</a>
<a name="ln1739">      }</a>
<a name="ln1740">      if (conv_error != 0) {</a>
<a name="ln1741">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1742">                 _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1743">        c = true;</a>
<a name="ln1744">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1745">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1746">                 _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1747">        c = true;</a>
<a name="ln1748">      } else if (error) {</a>
<a name="ln1749">        xstrlcat(IObuff, _(&quot;[READ ERRORS]&quot;), IOSIZE);</a>
<a name="ln1750">        c = true;</a>
<a name="ln1751">      }</a>
<a name="ln1752">      if (msg_add_fileformat(fileformat)) {</a>
<a name="ln1753">        c = true;</a>
<a name="ln1754">      }</a>
<a name="ln1755"> </a>
<a name="ln1756">      msg_add_lines(c, linecnt, filesize);</a>
<a name="ln1757"> </a>
<a name="ln1758">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1759">      p = NULL;</a>
<a name="ln1760">      msg_scrolled_ign = true;</a>
<a name="ln1761"> </a>
<a name="ln1762">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1763">        if (msg_col &gt; 0) {</a>
<a name="ln1764">          msg_putchar('\r');  // overwrite previous message</a>
<a name="ln1765">        }</a>
<a name="ln1766">        p = (uint8_t *)msg_trunc(IObuff, false, 0);</a>
<a name="ln1767">      }</a>
<a name="ln1768"> </a>
<a name="ln1769">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1770">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1771">        // Need to repeat the message after redrawing when:</a>
<a name="ln1772">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1773">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1774">        //   redrawing).</a>
<a name="ln1775">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1776">        set_keep_msg((char *)p, 0);</a>
<a name="ln1777">      }</a>
<a name="ln1778">      msg_scrolled_ign = false;</a>
<a name="ln1779">    }</a>
<a name="ln1780"> </a>
<a name="ln1781">    // with errors writing the file requires &quot;:w!&quot;</a>
<a name="ln1782">    if (newfile &amp;&amp; (error</a>
<a name="ln1783">                    || conv_error != 0</a>
<a name="ln1784">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP))) {</a>
<a name="ln1785">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln1786">    }</a>
<a name="ln1787"> </a>
<a name="ln1788">    u_clearline(curbuf);   // cannot use &quot;U&quot; command after adding lines</a>
<a name="ln1789"> </a>
<a name="ln1790">    // In Ex mode: cursor at last new line.</a>
<a name="ln1791">    // Otherwise: cursor at first new line.</a>
<a name="ln1792">    if (exmode_active) {</a>
<a name="ln1793">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1794">    } else {</a>
<a name="ln1795">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1796">    }</a>
<a name="ln1797">    check_cursor_lnum(curwin);</a>
<a name="ln1798">    beginline(BL_WHITE | BL_FIX);           // on first non-blank</a>
<a name="ln1799"> </a>
<a name="ln1800">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1801">      // Set '[ and '] marks to the newly read lines.</a>
<a name="ln1802">      curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1803">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1804">      curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1805">      curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1806">    }</a>
<a name="ln1807">  }</a>
<a name="ln1808">  msg_scroll = msg_save;</a>
<a name="ln1809"> </a>
<a name="ln1810">  // Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1811">  check_marks_read();</a>
<a name="ln1812"> </a>
<a name="ln1813">  // We remember if the last line of the read didn't have</a>
<a name="ln1814">  // an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1815">  // or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1816">  // for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1817">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1818"> </a>
<a name="ln1819">  // When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1820">  // different.</a>
<a name="ln1821">  if (flags &amp; READ_KEEP_UNDO) {</a>
<a name="ln1822">    u_find_first_changed();</a>
<a name="ln1823">  }</a>
<a name="ln1824"> </a>
<a name="ln1825">  // When opening a new file locate undo info and read it.</a>
<a name="ln1826">  if (read_undo_file) {</a>
<a name="ln1827">    uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln1828"> </a>
<a name="ln1829">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1830">    u_read_undo(NULL, hash, fname);</a>
<a name="ln1831">  }</a>
<a name="ln1832"> </a>
<a name="ln1833">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1834">    int m = msg_scroll;</a>
<a name="ln1835">    int n = msg_scrolled;</a>
<a name="ln1836"> </a>
<a name="ln1837">    // Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1838">    // modified if the format/encoding was automatically detected.</a>
<a name="ln1839">    if (set_options) {</a>
<a name="ln1840">      save_file_ff(curbuf);</a>
<a name="ln1841">    }</a>
<a name="ln1842"> </a>
<a name="ln1843">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln1844">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1845">    // output was done.</a>
<a name="ln1846">    msg_scroll = true;</a>
<a name="ln1847">    if (filtering) {</a>
<a name="ln1848">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1849">                           false, curbuf, eap);</a>
<a name="ln1850">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1851">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1852">                           false, curbuf, eap);</a>
<a name="ln1853">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1854">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1855">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1856">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln1857">      }</a>
<a name="ln1858">    } else {</a>
<a name="ln1859">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln1860">                           false, NULL, eap);</a>
<a name="ln1861">    }</a>
<a name="ln1862">    if (msg_scrolled == n) {</a>
<a name="ln1863">      msg_scroll = m;</a>
<a name="ln1864">    }</a>
<a name="ln1865">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln1866">      return FAIL;</a>
<a name="ln1867">    }</a>
<a name="ln1868">  }</a>
<a name="ln1869"> </a>
<a name="ln1870">  if (!(recoverymode &amp;&amp; error)) {</a>
<a name="ln1871">    retval = OK;</a>
<a name="ln1872">  }</a>
<a name="ln1873"> </a>
<a name="ln1874">theend:</a>
<a name="ln1875">  if (curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln1876">      &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_dirty == MF_DIRTY_YES_NOSYNC) {</a>
<a name="ln1877">    // OK to sync the swap file now</a>
<a name="ln1878">    curbuf-&gt;b_ml.ml_mfp-&gt;mf_dirty = MF_DIRTY_YES;</a>
<a name="ln1879">  }</a>
<a name="ln1880"> </a>
<a name="ln1881">  return retval;</a>
<a name="ln1882">}</a>
<a name="ln1883"> </a>
<a name="ln1884">#ifdef OPEN_CHR_FILES</a>
<a name="ln1885">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln1886">/// which is the name of files used for process substitution output by</a>
<a name="ln1887">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln1888">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln1889">///</a>
<a name="ln1890">/// @param fname file name to check</a>
<a name="ln1891">bool is_dev_fd_file(char *fname)</a>
<a name="ln1892">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1893">{</a>
<a name="ln1894">  return strncmp(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln1895">         &amp;&amp; ascii_isdigit((uint8_t)fname[8])</a>
<a name="ln1896">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln1897">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln1898">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln1899">}</a>
<a name="ln1900">#endif</a>
<a name="ln1901"> </a>
<a name="ln1902">/// From the current line count and characters read after that, estimate the</a>
<a name="ln1903">/// line number where we are now.</a>
<a name="ln1904">/// Used for error messages that include a line number.</a>
<a name="ln1905">///</a>
<a name="ln1906">/// @param linecnt  line count before reading more bytes</a>
<a name="ln1907">/// @param p        start of more bytes read</a>
<a name="ln1908">/// @param endp     end of more bytes read</a>
<a name="ln1909">static linenr_T readfile_linenr(linenr_T linecnt, char *p, const char *endp)</a>
<a name="ln1910">{</a>
<a name="ln1911">  char *s;</a>
<a name="ln1912">  linenr_T lnum;</a>
<a name="ln1913"> </a>
<a name="ln1914">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln1915">  for (s = p; s &lt; endp; s++) {</a>
<a name="ln1916">    if (*s == '\n') {</a>
<a name="ln1917">      lnum++;</a>
<a name="ln1918">    }</a>
<a name="ln1919">  }</a>
<a name="ln1920">  return lnum;</a>
<a name="ln1921">}</a>
<a name="ln1922"> </a>
<a name="ln1923">/// Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary' to be</a>
<a name="ln1924">/// equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln1925">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln1926">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1927">{</a>
<a name="ln1928">  const size_t cmd_len = 15 + strlen(buf-&gt;b_p_fenc);</a>
<a name="ln1929">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln1930"> </a>
<a name="ln1931">  snprintf(eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln1932">  eap-&gt;force_enc = 8;</a>
<a name="ln1933">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln1934">  eap-&gt;force_ff = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln1935"> </a>
<a name="ln1936">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln1937">  eap-&gt;read_edit = false;</a>
<a name="ln1938">  eap-&gt;forceit = false;</a>
<a name="ln1939">}</a>
<a name="ln1940"> </a>
<a name="ln1941">/// Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln1942">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln1943">{</a>
<a name="ln1944">  // set default 'fileformat'</a>
<a name="ln1945">  if (set_options) {</a>
<a name="ln1946">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln1947">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln1948">    } else if (*p_ffs != NUL) {</a>
<a name="ln1949">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln1950">    }</a>
<a name="ln1951">  }</a>
<a name="ln1952"> </a>
<a name="ln1953">  // set or reset 'binary'</a>
<a name="ln1954">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln1955">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln1956"> </a>
<a name="ln1957">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln1958">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln1959">  }</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">/// Set forced 'fileencoding'.</a>
<a name="ln1963">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln1964">{</a>
<a name="ln1965">  if (eap-&gt;force_enc == 0) {</a>
<a name="ln1966">    return;</a>
<a name="ln1967">  }</a>
<a name="ln1968"> </a>
<a name="ln1969">  char *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln1970">  set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln1971">  xfree(fenc);</a>
<a name="ln1972">}</a>
<a name="ln1973"> </a>
<a name="ln1974">/// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln1975">/// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln1976">/// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln1977">/// NULL.</a>
<a name="ln1978">/// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln1979">/// is set to true.</a>
<a name="ln1980">static char *next_fenc(char **pp, bool *alloced)</a>
<a name="ln1981">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln1982">{</a>
<a name="ln1983">  char *p;</a>
<a name="ln1984">  char *r;</a>
<a name="ln1985"> </a>
<a name="ln1986">  *alloced = false;</a>
<a name="ln1987">  if (**pp == NUL) {</a>
<a name="ln1988">    *pp = NULL;</a>
<a name="ln1989">    return &quot;&quot;;</a>
<a name="ln1990">  }</a>
<a name="ln1991">  p = vim_strchr(*pp, ',');</a>
<a name="ln1992">  if (p == NULL) {</a>
<a name="ln1993">    r = enc_canonize(*pp);</a>
<a name="ln1994">    *pp += strlen(*pp);</a>
<a name="ln1995">  } else {</a>
<a name="ln1996">    r = xstrnsave(*pp, (size_t)(p - *pp));</a>
<a name="ln1997">    *pp = p + 1;</a>
<a name="ln1998">    p = enc_canonize(r);</a>
<a name="ln1999">    xfree(r);</a>
<a name="ln2000">    r = p;</a>
<a name="ln2001">  }</a>
<a name="ln2002">  *alloced = true;</a>
<a name="ln2003">  return r;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">/// Convert a file with the 'charconvert' expression.</a>
<a name="ln2007">/// This closes the file which is to be read, converts it and opens the</a>
<a name="ln2008">/// resulting file for reading.</a>
<a name="ln2009">///</a>
<a name="ln2010">/// @param fname  name of input file</a>
<a name="ln2011">/// @param fenc   converted from</a>
<a name="ln2012">/// @param fdp    in/out: file descriptor of file</a>
<a name="ln2013">///</a>
<a name="ln2014">/// @return       name of the resulting converted file (the caller should delete it after reading it).</a>
<a name="ln2015">///               Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2016">static char *readfile_charconvert(char *fname, char *fenc, int *fdp)</a>
<a name="ln2017">{</a>
<a name="ln2018">  char *tmpname;</a>
<a name="ln2019">  char *errmsg = NULL;</a>
<a name="ln2020"> </a>
<a name="ln2021">  tmpname = vim_tempname();</a>
<a name="ln2022">  if (tmpname == NULL) {</a>
<a name="ln2023">    errmsg = _(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2024">  } else {</a>
<a name="ln2025">    close(*fdp);                // close the input file, ignore errors</a>
<a name="ln2026">    *fdp = -1;</a>
<a name="ln2027">    if (eval_charconvert(fenc, &quot;utf-8&quot;,</a>
<a name="ln2028">                         fname, tmpname) == FAIL) {</a>
<a name="ln2029">      errmsg = _(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2030">    }</a>
<a name="ln2031">    if (errmsg == NULL &amp;&amp; (*fdp = os_open(tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2032">      errmsg = _(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2033">    }</a>
<a name="ln2034">  }</a>
<a name="ln2035"> </a>
<a name="ln2036">  if (errmsg != NULL) {</a>
<a name="ln2037">    // Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2038">    // another type of conversion might still work.</a>
<a name="ln2039">    msg(errmsg, 0);</a>
<a name="ln2040">    if (tmpname != NULL) {</a>
<a name="ln2041">      os_remove(tmpname);  // delete converted file</a>
<a name="ln2042">      XFREE_CLEAR(tmpname);</a>
<a name="ln2043">    }</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  // If the input file is closed, open it (caller should check for error).</a>
<a name="ln2047">  if (*fdp &lt; 0) {</a>
<a name="ln2048">    *fdp = os_open(fname, O_RDONLY, 0);</a>
<a name="ln2049">  }</a>
<a name="ln2050"> </a>
<a name="ln2051">  return tmpname;</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">/// Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2055">/// buffer marks and the buffer has a name.</a>
<a name="ln2056">static void check_marks_read(void)</a>
<a name="ln2057">{</a>
<a name="ln2058">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2059">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2060">    shada_read_marks();</a>
<a name="ln2061">  }</a>
<a name="ln2062"> </a>
<a name="ln2063">  // Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2064">  // the ' parameter after opening a buffer.</a>
<a name="ln2065">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2066">}</a>
<a name="ln2067"> </a>
<a name="ln2068">/// Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln2069">/// name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln2070">int set_rw_fname(char *fname, char *sfname)</a>
<a name="ln2071">{</a>
<a name="ln2072">  buf_T *buf = curbuf;</a>
<a name="ln2073"> </a>
<a name="ln2074">  // It's like the unnamed buffer is deleted....</a>
<a name="ln2075">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln2076">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln2077">  }</a>
<a name="ln2078">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);</a>
<a name="ln2079">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2080">    return FAIL;</a>
<a name="ln2081">  }</a>
<a name="ln2082">  if (curbuf != buf) {</a>
<a name="ln2083">    // We are in another buffer now, don't do the renaming.</a>
<a name="ln2084">    emsg(_(e_auchangedbuf));</a>
<a name="ln2085">    return FAIL;</a>
<a name="ln2086">  }</a>
<a name="ln2087"> </a>
<a name="ln2088">  if (setfname(curbuf, fname, sfname, false) == OK) {</a>
<a name="ln2089">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln2090">  }</a>
<a name="ln2091"> </a>
<a name="ln2092">  // ....and a new named one is created</a>
<a name="ln2093">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, curbuf);</a>
<a name="ln2094">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln2095">    apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);</a>
<a name="ln2096">  }</a>
<a name="ln2097">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2098">    return FAIL;</a>
<a name="ln2099">  }</a>
<a name="ln2100"> </a>
<a name="ln2101">  // Do filetype detection now if 'filetype' is empty.</a>
<a name="ln2102">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln2103">    if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln2104">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln2105">    }</a>
<a name="ln2106">    do_modelines(0);</a>
<a name="ln2107">  }</a>
<a name="ln2108"> </a>
<a name="ln2109">  return OK;</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">/// Put file name into the specified buffer with quotes</a>
<a name="ln2113">///</a>
<a name="ln2114">/// Replaces home directory at the start with `~`.</a>
<a name="ln2115">///</a>
<a name="ln2116">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln2117">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln2118">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln2119">/// @param[in]  fname  File name to write.</a>
<a name="ln2120">void add_quoted_fname(char *const ret_buf, const size_t buf_len, const buf_T *const buf,</a>
<a name="ln2121">                      const char *fname)</a>
<a name="ln2122">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2123">{</a>
<a name="ln2124">  if (fname == NULL) {</a>
<a name="ln2125">    fname = &quot;-stdin-&quot;;</a>
<a name="ln2126">  }</a>
<a name="ln2127">  ret_buf[0] = '&quot;';</a>
<a name="ln2128">  home_replace(buf, fname, ret_buf + 1, buf_len - 4, true);</a>
<a name="ln2129">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">/// Append message for text mode to IObuff.</a>
<a name="ln2133">///</a>
<a name="ln2134">/// @param eol_type line ending type</a>
<a name="ln2135">///</a>
<a name="ln2136">/// @return true if something was appended.</a>
<a name="ln2137">bool msg_add_fileformat(int eol_type)</a>
<a name="ln2138">{</a>
<a name="ln2139">#ifndef USE_CRNL</a>
<a name="ln2140">  if (eol_type == EOL_DOS) {</a>
<a name="ln2141">    xstrlcat(IObuff, _(&quot;[dos]&quot;), IOSIZE);</a>
<a name="ln2142">    return true;</a>
<a name="ln2143">  }</a>
<a name="ln2144">#endif</a>
<a name="ln2145">  if (eol_type == EOL_MAC) {</a>
<a name="ln2146">    xstrlcat(IObuff, _(&quot;[mac]&quot;), IOSIZE);</a>
<a name="ln2147">    return true;</a>
<a name="ln2148">  }</a>
<a name="ln2149">#ifdef USE_CRNL</a>
<a name="ln2150">  if (eol_type == EOL_UNIX) {</a>
<a name="ln2151">    xstrlcat(IObuff, _(&quot;[unix]&quot;), IOSIZE);</a>
<a name="ln2152">    return true;</a>
<a name="ln2153">  }</a>
<a name="ln2154">#endif</a>
<a name="ln2155">  return false;</a>
<a name="ln2156">}</a>
<a name="ln2157"> </a>
<a name="ln2158">/// Append line and character count to IObuff.</a>
<a name="ln2159">void msg_add_lines(int insert_space, linenr_T lnum, off_T nchars)</a>
<a name="ln2160">{</a>
<a name="ln2161">  char *p = IObuff + strlen(IObuff);</a>
<a name="ln2162"> </a>
<a name="ln2163">  if (insert_space) {</a>
<a name="ln2164">    *p++ = ' ';</a>
<a name="ln2165">  }</a>
<a name="ln2166">  if (shortmess(SHM_LINES)) {</a>
<a name="ln2167">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)), &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;B&quot;,</a>
<a name="ln2168">                 (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln2169">  } else {</a>
<a name="ln2170">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)),</a>
<a name="ln2171">                 NGETTEXT(&quot;%&quot; PRId64 &quot; line, &quot;, &quot;%&quot; PRId64 &quot; lines, &quot;, lnum),</a>
<a name="ln2172">                 (int64_t)lnum);</a>
<a name="ln2173">    p += strlen(p);</a>
<a name="ln2174">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)),</a>
<a name="ln2175">                 NGETTEXT(&quot;%&quot; PRId64 &quot; byte&quot;, &quot;%&quot; PRId64 &quot; bytes&quot;, nchars),</a>
<a name="ln2176">                 (int64_t)nchars);</a>
<a name="ln2177">  }</a>
<a name="ln2178">}</a>
<a name="ln2179"> </a>
<a name="ln2180">bool time_differs(const FileInfo *file_info, long mtime, long mtime_ns) FUNC_ATTR_CONST</a>
<a name="ln2181">{</a>
<a name="ln2182">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln2183">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln2184">         // On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln2185">         // the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln2186">         // time may change unexpectedly by one second!!!</a>
<a name="ln2187">         || file_info-&gt;stat.st_mtim.tv_sec - mtime &gt; 1</a>
<a name="ln2188">         || mtime - file_info-&gt;stat.st_mtim.tv_sec &gt; 1;</a>
<a name="ln2189">#else</a>
<a name="ln2190">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln2191">         || file_info-&gt;stat.st_mtim.tv_sec != mtime;</a>
<a name="ln2192">#endif</a>
<a name="ln2193">}</a>
<a name="ln2194"> </a>
<a name="ln2195">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln2196">/// 'encoding'.</a>
<a name="ln2197">///</a>
<a name="ln2198">/// @param fenc file encoding to check</a>
<a name="ln2199">///</a>
<a name="ln2200">/// @return true if conversion is required</a>
<a name="ln2201">bool need_conversion(const char *fenc)</a>
<a name="ln2202">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2203">{</a>
<a name="ln2204">  int same_encoding;</a>
<a name="ln2205">  int fenc_flags;</a>
<a name="ln2206"> </a>
<a name="ln2207">  if (*fenc == NUL || strcmp(p_enc, fenc) == 0) {</a>
<a name="ln2208">    same_encoding = true;</a>
<a name="ln2209">    fenc_flags = 0;</a>
<a name="ln2210">  } else {</a>
<a name="ln2211">    // Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln2212">    // &quot;ucs-4be&quot;, etc.</a>
<a name="ln2213">    int enc_flags = get_fio_flags(p_enc);</a>
<a name="ln2214">    fenc_flags = get_fio_flags(fenc);</a>
<a name="ln2215">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln2216">  }</a>
<a name="ln2217">  if (same_encoding) {</a>
<a name="ln2218">    // Specified file encoding matches UTF-8.</a>
<a name="ln2219">    return false;</a>
<a name="ln2220">  }</a>
<a name="ln2221"> </a>
<a name="ln2222">  // Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln2223">  // Unicode encoding and the file is UTF-8.</a>
<a name="ln2224">  return !(fenc_flags == FIO_UTF8);</a>
<a name="ln2225">}</a>
<a name="ln2226"> </a>
<a name="ln2227">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln2228">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln2229">/// use 'encoding'.</a>
<a name="ln2230">///</a>
<a name="ln2231">/// @param name string to check for encoding</a>
<a name="ln2232">int get_fio_flags(const char *name)</a>
<a name="ln2233">{</a>
<a name="ln2234">  if (*name == NUL) {</a>
<a name="ln2235">    name = p_enc;</a>
<a name="ln2236">  }</a>
<a name="ln2237">  int prop = enc_canon_props(name);</a>
<a name="ln2238">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln2239">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln2240">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2241">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln2242">      }</a>
<a name="ln2243">      return FIO_UCS2;</a>
<a name="ln2244">    }</a>
<a name="ln2245">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln2246">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2247">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln2248">      }</a>
<a name="ln2249">      return FIO_UCS4;</a>
<a name="ln2250">    }</a>
<a name="ln2251">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln2252">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2253">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln2254">      }</a>
<a name="ln2255">      return FIO_UTF16;</a>
<a name="ln2256">    }</a>
<a name="ln2257">    return FIO_UTF8;</a>
<a name="ln2258">  }</a>
<a name="ln2259">  if (prop &amp; ENC_LATIN1) {</a>
<a name="ln2260">    return FIO_LATIN1;</a>
<a name="ln2261">  }</a>
<a name="ln2262">  // must be ENC_DBCS, requires iconv()</a>
<a name="ln2263">  return 0;</a>
<a name="ln2264">}</a>
<a name="ln2265"> </a>
<a name="ln2266">/// Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln2267">/// &quot;size&quot; must be at least 2.</a>
<a name="ln2268">///</a>
<a name="ln2269">/// @return  the name of the encoding and set &quot;*lenp&quot; to the length or,</a>
<a name="ln2270">///          NULL when no BOM found.</a>
<a name="ln2271">static char *check_for_bom(const char *p_in, int size, int *lenp, int flags)</a>
<a name="ln2272">{</a>
<a name="ln2273">  const uint8_t *p = (const uint8_t *)p_in;</a>
<a name="ln2274">  char *name = NULL;</a>
<a name="ln2275">  int len = 2;</a>
<a name="ln2276"> </a>
<a name="ln2277">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln2278">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln2279">    name = &quot;utf-8&quot;;             // EF BB BF</a>
<a name="ln2280">    len = 3;</a>
<a name="ln2281">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln2282">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln2283">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln2284">      name = &quot;ucs-4le&quot;;         // FF FE 00 00</a>
<a name="ln2285">      len = 4;</a>
<a name="ln2286">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L)) {</a>
<a name="ln2287">      name = &quot;ucs-2le&quot;;         // FF FE</a>
<a name="ln2288">    } else if (flags == FIO_ALL</a>
<a name="ln2289">               || flags == (FIO_UTF16 | FIO_ENDIAN_L)) {</a>
<a name="ln2290">      // utf-16le is preferred, it also works for ucs-2le text</a>
<a name="ln2291">      name = &quot;utf-16le&quot;;        // FF FE</a>
<a name="ln2292">    }</a>
<a name="ln2293">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln2294">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln2295">                 FIO_UTF16)) {</a>
<a name="ln2296">    // Default to utf-16, it works also for ucs-2 text.</a>
<a name="ln2297">    if (flags == FIO_UCS2) {</a>
<a name="ln2298">      name = &quot;ucs-2&quot;;           // FE FF</a>
<a name="ln2299">    } else {</a>
<a name="ln2300">      name = &quot;utf-16&quot;;          // FE FF</a>
<a name="ln2301">    }</a>
<a name="ln2302">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln2303">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln2304">    name = &quot;ucs-4&quot;;             // 00 00 FE FF</a>
<a name="ln2305">    len = 4;</a>
<a name="ln2306">  }</a>
<a name="ln2307"> </a>
<a name="ln2308">  *lenp = len;</a>
<a name="ln2309">  return name;</a>
<a name="ln2310">}</a>
<a name="ln2311"> </a>
<a name="ln2312">/// Shorten filename of a buffer.</a>
<a name="ln2313">///</a>
<a name="ln2314">/// @param force  when true: Use full path from now on for files currently being</a>
<a name="ln2315">///               edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln2316">///               names a bit, if safe to do so.</a>
<a name="ln2317">///               when false: Only try to shorten absolute file names.</a>
<a name="ln2318">///</a>
<a name="ln2319">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln2320">/// name.</a>
<a name="ln2321">void shorten_buf_fname(buf_T *buf, char *dirname, int force)</a>
<a name="ln2322">{</a>
<a name="ln2323">  if (buf-&gt;b_fname != NULL</a>
<a name="ln2324">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln2325">      &amp;&amp; !path_with_url(buf-&gt;b_fname)</a>
<a name="ln2326">      &amp;&amp; (force</a>
<a name="ln2327">          || buf-&gt;b_sfname == NULL</a>
<a name="ln2328">          || path_is_absolute(buf-&gt;b_sfname))) {</a>
<a name="ln2329">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln2330">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln2331">    }</a>
<a name="ln2332">    char *p = path_shorten_fname(buf-&gt;b_ffname, dirname);</a>
<a name="ln2333">    if (p != NULL) {</a>
<a name="ln2334">      buf-&gt;b_sfname = xstrdup(p);</a>
<a name="ln2335">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln2336">    }</a>
<a name="ln2337">    if (p == NULL) {</a>
<a name="ln2338">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln2339">    }</a>
<a name="ln2340">  }</a>
<a name="ln2341">}</a>
<a name="ln2342"> </a>
<a name="ln2343">/// Shorten filenames for all buffers.</a>
<a name="ln2344">void shorten_fnames(int force)</a>
<a name="ln2345">{</a>
<a name="ln2346">  char dirname[MAXPATHL];</a>
<a name="ln2347"> </a>
<a name="ln2348">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln2349">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2350">    shorten_buf_fname(buf, dirname, force);</a>
<a name="ln2351"> </a>
<a name="ln2352">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln2353">    // also have a swap file.</a>
<a name="ln2354">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln2355">  }</a>
<a name="ln2356">  status_redraw_all();</a>
<a name="ln2357">  redraw_tabline = true;</a>
<a name="ln2358">}</a>
<a name="ln2359"> </a>
<a name="ln2360">/// Get new filename ended by given extension.</a>
<a name="ln2361">///</a>
<a name="ln2362">/// @param fname        The original filename.</a>
<a name="ln2363">///                     If NULL, use current directory name and ext to</a>
<a name="ln2364">///                     compute new filename.</a>
<a name="ln2365">/// @param ext          The extension to add to the filename.</a>
<a name="ln2366">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln2367">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln2368">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln2369">///                     if fname is NULL.</a>
<a name="ln2370">///</a>
<a name="ln2371">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln2372">///                       * fname + ext, if fname not NULL.</a>
<a name="ln2373">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln2374">///                       Result is guaranteed to:</a>
<a name="ln2375">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln2376">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln2377">///                         original basename is truncated if necessary.</a>
<a name="ln2378">///                       * be different than original: basename chars are</a>
<a name="ln2379">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln2380">///                         because truncated value of original filename was</a>
<a name="ln2381">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln2382">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln2383">///                       to get current directory.</a>
<a name="ln2384">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln2385">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2386">{</a>
<a name="ln2387">  char *retval;</a>
<a name="ln2388">  size_t fnamelen;</a>
<a name="ln2389">  size_t extlen = strlen(ext);</a>
<a name="ln2390"> </a>
<a name="ln2391">  // If there is no file name we must get the name of the current directory</a>
<a name="ln2392">  // (we need the full path in case :cd is used).</a>
<a name="ln2393">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln2394">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln2395">    if (os_dirname(retval, MAXPATHL) == FAIL</a>
<a name="ln2396">        || strlen(retval) == 0) {</a>
<a name="ln2397">      xfree(retval);</a>
<a name="ln2398">      return NULL;</a>
<a name="ln2399">    }</a>
<a name="ln2400">    add_pathsep(retval);</a>
<a name="ln2401">    fnamelen = strlen(retval);</a>
<a name="ln2402">    prepend_dot = false;  // nothing to prepend a dot to</a>
<a name="ln2403">  } else {</a>
<a name="ln2404">    fnamelen = strlen(fname);</a>
<a name="ln2405">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln2406">    strcpy(retval, fname);  // NOLINT(runtime/printf)</a>
<a name="ln2407">  }</a>
<a name="ln2408"> </a>
<a name="ln2409">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln2410">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln2411">  char *ptr = NULL;</a>
<a name="ln2412">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln2413">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln2414">      ptr++;</a>
<a name="ln2415">      break;</a>
<a name="ln2416">    }</a>
<a name="ln2417">  }</a>
<a name="ln2418"> </a>
<a name="ln2419">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln2420">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln2421">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln2422">  }</a>
<a name="ln2423"> </a>
<a name="ln2424">  char *s = ptr + strlen(ptr);</a>
<a name="ln2425"> </a>
<a name="ln2426">  // Append the extension.</a>
<a name="ln2427">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln2428">  strcpy(s, ext);  // NOLINT(runtime/printf)</a>
<a name="ln2429"> </a>
<a name="ln2430">  char *e;</a>
<a name="ln2431">  // Prepend the dot if needed.</a>
<a name="ln2432">  if (prepend_dot &amp;&amp; *(e = path_tail(retval)) != '.') {</a>
<a name="ln2433">    STRMOVE(e + 1, e);</a>
<a name="ln2434">    *e = '.';</a>
<a name="ln2435">  }</a>
<a name="ln2436"> </a>
<a name="ln2437">  // Check that, after appending the extension, the file name is really</a>
<a name="ln2438">  // different.</a>
<a name="ln2439">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln2440">    // we search for a character that can be replaced by '_'</a>
<a name="ln2441">    while (--s &gt;= ptr) {</a>
<a name="ln2442">      if (*s != '_') {</a>
<a name="ln2443">        *s = '_';</a>
<a name="ln2444">        break;</a>
<a name="ln2445">      }</a>
<a name="ln2446">    }</a>
<a name="ln2447">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln2448">      *ptr = 'v';</a>
<a name="ln2449">    }</a>
<a name="ln2450">  }</a>
<a name="ln2451">  return retval;</a>
<a name="ln2452">}</a>
<a name="ln2453"> </a>
<a name="ln2454">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln2455">/// rest of the line is thrown away.</a>
<a name="ln2456">///</a>
<a name="ln2457">/// @param[out] buf buffer to fill</a>
<a name="ln2458">/// @param size size of the buffer</a>
<a name="ln2459">/// @param fp file to read from</a>
<a name="ln2460">///</a>
<a name="ln2461">/// @return true for EOF or error</a>
<a name="ln2462">bool vim_fgets(char *buf, int size, FILE *fp)</a>
<a name="ln2463">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2464">{</a>
<a name="ln2465">  char *retval;</a>
<a name="ln2466"> </a>
<a name="ln2467">  assert(size &gt; 0);</a>
<a name="ln2468">  buf[size - 2] = NUL;</a>
<a name="ln2469"> </a>
<a name="ln2470">  do {</a>
<a name="ln2471">    errno = 0;</a>
<a name="ln2472">    retval = fgets(buf, size, fp);</a>
<a name="ln2473">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln2474"> </a>
<a name="ln2475">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln2476">    char tbuf[200];</a>
<a name="ln2477"> </a>
<a name="ln2478">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln2479"> </a>
<a name="ln2480">    // Now throw away the rest of the line:</a>
<a name="ln2481">    do {</a>
<a name="ln2482">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln2483">      errno = 0;</a>
<a name="ln2484">      retval = fgets(tbuf, sizeof(tbuf), fp);</a>
<a name="ln2485">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln2486">        break;</a>
<a name="ln2487">      }</a>
<a name="ln2488">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln2489">  }</a>
<a name="ln2490">  return retval == NULL;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2494">///</a>
<a name="ln2495">/// @return  -1 when encountering EOF.</a>
<a name="ln2496">int get2c(FILE *fd)</a>
<a name="ln2497">{</a>
<a name="ln2498">  const int n = getc(fd);</a>
<a name="ln2499">  if (n == EOF) {</a>
<a name="ln2500">    return -1;</a>
<a name="ln2501">  }</a>
<a name="ln2502">  const int c = getc(fd);</a>
<a name="ln2503">  if (c == EOF) {</a>
<a name="ln2504">    return -1;</a>
<a name="ln2505">  }</a>
<a name="ln2506">  return (n &lt;&lt; 8) + c;</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2510">///</a>
<a name="ln2511">/// @return  -1 when encountering EOF.</a>
<a name="ln2512">int get3c(FILE *fd)</a>
<a name="ln2513">{</a>
<a name="ln2514">  int n = getc(fd);</a>
<a name="ln2515">  if (n == EOF) {</a>
<a name="ln2516">    return -1;</a>
<a name="ln2517">  }</a>
<a name="ln2518">  int c = getc(fd);</a>
<a name="ln2519">  if (c == EOF) {</a>
<a name="ln2520">    return -1;</a>
<a name="ln2521">  }</a>
<a name="ln2522">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln2523">  c = getc(fd);</a>
<a name="ln2524">  if (c == EOF) {</a>
<a name="ln2525">    return -1;</a>
<a name="ln2526">  }</a>
<a name="ln2527">  return (n &lt;&lt; 8) + c;</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2531">///</a>
<a name="ln2532">/// @return  -1 when encountering EOF.</a>
<a name="ln2533">int get4c(FILE *fd)</a>
<a name="ln2534">{</a>
<a name="ln2535">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln2536">  // when left-shift sets the MSB.</a>
<a name="ln2537">  unsigned n;</a>
<a name="ln2538"> </a>
<a name="ln2539">  int c = getc(fd);</a>
<a name="ln2540">  if (c == EOF) {</a>
<a name="ln2541">    return -1;</a>
<a name="ln2542">  }</a>
<a name="ln2543">  n = (unsigned)c;</a>
<a name="ln2544">  c = getc(fd);</a>
<a name="ln2545">  if (c == EOF) {</a>
<a name="ln2546">    return -1;</a>
<a name="ln2547">  }</a>
<a name="ln2548">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2549">  c = getc(fd);</a>
<a name="ln2550">  if (c == EOF) {</a>
<a name="ln2551">    return -1;</a>
<a name="ln2552">  }</a>
<a name="ln2553">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2554">  c = getc(fd);</a>
<a name="ln2555">  if (c == EOF) {</a>
<a name="ln2556">    return -1;</a>
<a name="ln2557">  }</a>
<a name="ln2558">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2559">  return (int)n;</a>
<a name="ln2560">}</a>
<a name="ln2561"> </a>
<a name="ln2562">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln2563">///</a>
<a name="ln2564">/// @return  -1 when encountering EOF.</a>
<a name="ln2565">time_t get8ctime(FILE *fd)</a>
<a name="ln2566">{</a>
<a name="ln2567">  time_t n = 0;</a>
<a name="ln2568"> </a>
<a name="ln2569">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln2570">    const int c = getc(fd);</a>
<a name="ln2571">    if (c == EOF) {</a>
<a name="ln2572">      return -1;</a>
<a name="ln2573">    }</a>
<a name="ln2574">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln2575">  }</a>
<a name="ln2576">  return n;</a>
<a name="ln2577">}</a>
<a name="ln2578"> </a>
<a name="ln2579">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln2580">///</a>
<a name="ln2581">/// @return  pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln2582">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln2583">{</a>
<a name="ln2584">  char *str = xmallocz(cnt);</a>
<a name="ln2585">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln2586">    int c = getc(fd);</a>
<a name="ln2587">    if (c == EOF) {</a>
<a name="ln2588">      xfree(str);</a>
<a name="ln2589">      return NULL;</a>
<a name="ln2590">    }</a>
<a name="ln2591">    str[i] = (char)c;</a>
<a name="ln2592">  }</a>
<a name="ln2593">  return str;</a>
<a name="ln2594">}</a>
<a name="ln2595"> </a>
<a name="ln2596">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln2597">///</a>
<a name="ln2598">/// @return  false in case of an error.</a>
<a name="ln2599">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln2600">{</a>
<a name="ln2601">  assert(len &gt; 0);</a>
<a name="ln2602">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln2603">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln2604">      return false;</a>
<a name="ln2605">    }</a>
<a name="ln2606">  }</a>
<a name="ln2607">  return true;</a>
<a name="ln2608">}</a>
<a name="ln2609"> </a>
<a name="ln2610">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln2611">///</a>
<a name="ln2612">/// @return  FAIL when the write failed.</a>
<a name="ln2613">int put_time(FILE *fd, time_t time_)</a>
<a name="ln2614">{</a>
<a name="ln2615">  uint8_t buf[8];</a>
<a name="ln2616">  time_to_bytes(time_, buf);</a>
<a name="ln2617">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln2618">}</a>
<a name="ln2619"> </a>
<a name="ln2620">static int rename_with_tmp(const char *const from, const char *const to)</a>
<a name="ln2621">{</a>
<a name="ln2622">  // Find a name that doesn't exist and is in the same directory.</a>
<a name="ln2623">  // Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln2624">  if (strlen(from) &gt;= MAXPATHL - 5) {</a>
<a name="ln2625">    return -1;</a>
<a name="ln2626">  }</a>
<a name="ln2627"> </a>
<a name="ln2628">  char tempname[MAXPATHL + 1];</a>
<a name="ln2629">  STRCPY(tempname, from);</a>
<a name="ln2630">  for (int n = 123; n &lt; 99999; n++) {</a>
<a name="ln2631">    char *tail = path_tail(tempname);</a>
<a name="ln2632">    snprintf(tail, (size_t)((MAXPATHL + 1) - (tail - tempname - 1)), &quot;%d&quot;, n);</a>
<a name="ln2633"> </a>
<a name="ln2634">    if (!os_path_exists(tempname)) {</a>
<a name="ln2635">      if (os_rename(from, tempname) == OK) {</a>
<a name="ln2636">        if (os_rename(tempname, to) == OK) {</a>
<a name="ln2637">          return 0;</a>
<a name="ln2638">        }</a>
<a name="ln2639">        // Strange, the second step failed.  Try moving the</a>
<a name="ln2640">        // file back and return failure.</a>
<a name="ln2641">        (void)os_rename(tempname, from);</a>
<a name="ln2642">        return -1;</a>
<a name="ln2643">      }</a>
<a name="ln2644">      // If it fails for one temp name it will most likely fail</a>
<a name="ln2645">      // for any temp name, give up.</a>
<a name="ln2646">      return -1;</a>
<a name="ln2647">    }</a>
<a name="ln2648">  }</a>
<a name="ln2649">  return -1;</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln2653">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln2654">///</a>
<a name="ln2655">/// @return  -1 for failure, 0 for success</a>
<a name="ln2656">int vim_rename(const char *from, const char *to)</a>
<a name="ln2657">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2658">{</a>
<a name="ln2659">  char *errmsg = NULL;</a>
<a name="ln2660">  bool use_tmp_file = false;</a>
<a name="ln2661"> </a>
<a name="ln2662">  // When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln2663">  // to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln2664">  // the file name differs we need to go through a temp file.</a>
<a name="ln2665">  if (path_fnamecmp(from, to) == 0) {</a>
<a name="ln2666">    if (p_fic &amp;&amp; (strcmp(path_tail(from), path_tail(to)) != 0)) {</a>
<a name="ln2667">      use_tmp_file = true;</a>
<a name="ln2668">    } else {</a>
<a name="ln2669">      return 0;</a>
<a name="ln2670">    }</a>
<a name="ln2671">  }</a>
<a name="ln2672"> </a>
<a name="ln2673">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln2674">  FileInfo from_info;</a>
<a name="ln2675">  if (!os_fileinfo(from, &amp;from_info)) {</a>
<a name="ln2676">    return -1;</a>
<a name="ln2677">  }</a>
<a name="ln2678"> </a>
<a name="ln2679">  // It's possible for the source and destination to be the same file.</a>
<a name="ln2680">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln2681">  // filesystem. In that case go through a temp file name.</a>
<a name="ln2682">  FileInfo to_info;</a>
<a name="ln2683">  if (os_fileinfo(to, &amp;to_info) &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln2684">    use_tmp_file = true;</a>
<a name="ln2685">  }</a>
<a name="ln2686"> </a>
<a name="ln2687">  if (use_tmp_file) {</a>
<a name="ln2688">    return rename_with_tmp(from, to);</a>
<a name="ln2689">  }</a>
<a name="ln2690"> </a>
<a name="ln2691">  // Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln2692">  // os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln2693">  // two files when the os_rename() fails.</a>
<a name="ln2694"> </a>
<a name="ln2695">  os_remove(to);</a>
<a name="ln2696"> </a>
<a name="ln2697">  // First try a normal rename, return if it works.</a>
<a name="ln2698">  if (os_rename(from, to) == OK) {</a>
<a name="ln2699">    return 0;</a>
<a name="ln2700">  }</a>
<a name="ln2701"> </a>
<a name="ln2702">  // Rename() failed, try copying the file.</a>
<a name="ln2703">  int perm = os_getperm(from);</a>
<a name="ln2704">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2705">  vim_acl_T acl = os_get_acl(from);</a>
<a name="ln2706">  int fd_in = os_open(from, O_RDONLY, 0);</a>
<a name="ln2707">  if (fd_in &lt; 0) {</a>
<a name="ln2708">    os_free_acl(acl);</a>
<a name="ln2709">    return -1;</a>
<a name="ln2710">  }</a>
<a name="ln2711"> </a>
<a name="ln2712">  // Create the new file with same permissions as the original.</a>
<a name="ln2713">  int fd_out = os_open(to, O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, perm);</a>
<a name="ln2714">  if (fd_out &lt; 0) {</a>
<a name="ln2715">    close(fd_in);</a>
<a name="ln2716">    os_free_acl(acl);</a>
<a name="ln2717">    return -1;</a>
<a name="ln2718">  }</a>
<a name="ln2719"> </a>
<a name="ln2720">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln2721">  // is `preserve_exit()`ing.</a>
<a name="ln2722">  char *buffer = try_malloc(WRITEBUFSIZE);</a>
<a name="ln2723">  if (buffer == NULL) {</a>
<a name="ln2724">    close(fd_out);</a>
<a name="ln2725">    close(fd_in);</a>
<a name="ln2726">    os_free_acl(acl);</a>
<a name="ln2727">    return -1;</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  int n;</a>
<a name="ln2731">  while ((n = (int)read_eintr(fd_in, buffer, WRITEBUFSIZE)) &gt; 0) {</a>
<a name="ln2732">    if (write_eintr(fd_out, buffer, (size_t)n) != n) {</a>
<a name="ln2733">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln2734">      break;</a>
<a name="ln2735">    }</a>
<a name="ln2736">  }</a>
<a name="ln2737"> </a>
<a name="ln2738">  xfree(buffer);</a>
<a name="ln2739">  close(fd_in);</a>
<a name="ln2740">  if (close(fd_out) &lt; 0) {</a>
<a name="ln2741">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln2742">  }</a>
<a name="ln2743">  if (n &lt; 0) {</a>
<a name="ln2744">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln2745">    to = from;</a>
<a name="ln2746">  }</a>
<a name="ln2747">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln2748">  os_setperm(to, perm);</a>
<a name="ln2749">#endif</a>
<a name="ln2750">  os_set_acl(to, acl);</a>
<a name="ln2751">  os_free_acl(acl);</a>
<a name="ln2752">  if (errmsg != NULL) {</a>
<a name="ln2753">    semsg(errmsg, to);</a>
<a name="ln2754">    return -1;</a>
<a name="ln2755">  }</a>
<a name="ln2756">  os_remove(from);</a>
<a name="ln2757">  return 0;</a>
<a name="ln2758">}</a>
<a name="ln2759"> </a>
<a name="ln2760">static int already_warned = false;</a>
<a name="ln2761"> </a>
<a name="ln2762">/// Check if any not hidden buffer has been changed.</a>
<a name="ln2763">/// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln2764">/// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln2765">/// busy.</a>
<a name="ln2766">///</a>
<a name="ln2767">/// @param focus  called for GUI focus event</a>
<a name="ln2768">///</a>
<a name="ln2769">/// @return       true if some message was written (screen should be redrawn and cursor positioned).</a>
<a name="ln2770">int check_timestamps(int focus)</a>
<a name="ln2771">{</a>
<a name="ln2772">  // Don't check timestamps while system() or another low-level function may</a>
<a name="ln2773">  // cause us to lose and gain focus.</a>
<a name="ln2774">  if (no_check_timestamps &gt; 0) {</a>
<a name="ln2775">    return false;</a>
<a name="ln2776">  }</a>
<a name="ln2777"> </a>
<a name="ln2778">  // Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln2779">  // event and we would keep on checking if the file is steadily growing.</a>
<a name="ln2780">  // Do check again after typing something.</a>
<a name="ln2781">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln2782">    need_check_timestamps = true;</a>
<a name="ln2783">    return false;</a>
<a name="ln2784">  }</a>
<a name="ln2785"> </a>
<a name="ln2786">  int didit = 0;</a>
<a name="ln2787"> </a>
<a name="ln2788">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln2789">      || autocmd_busy || curbuf-&gt;b_ro_locked &gt; 0</a>
<a name="ln2790">      || allbuf_lock &gt; 0) {</a>
<a name="ln2791">    need_check_timestamps = true;               // check later</a>
<a name="ln2792">  } else {</a>
<a name="ln2793">    no_wait_return++;</a>
<a name="ln2794">    did_check_timestamps = true;</a>
<a name="ln2795">    already_warned = false;</a>
<a name="ln2796">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2797">      // Only check buffers in a window.</a>
<a name="ln2798">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln2799">        bufref_T bufref;</a>
<a name="ln2800">        set_bufref(&amp;bufref, buf);</a>
<a name="ln2801">        const int n = buf_check_timestamp(buf);</a>
<a name="ln2802">        if (didit &lt; n) {</a>
<a name="ln2803">          didit = n;</a>
<a name="ln2804">        }</a>
<a name="ln2805">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln2806">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln2807">          buf = firstbuf;</a>
<a name="ln2808">          continue;</a>
<a name="ln2809">        }</a>
<a name="ln2810">      }</a>
<a name="ln2811">    }</a>
<a name="ln2812">    no_wait_return--;</a>
<a name="ln2813">    need_check_timestamps = false;</a>
<a name="ln2814">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln2815">      // make sure msg isn't overwritten</a>
<a name="ln2816">      msg_puts(&quot;\n&quot;);</a>
<a name="ln2817">      ui_flush();</a>
<a name="ln2818">    }</a>
<a name="ln2819">  }</a>
<a name="ln2820">  return didit;</a>
<a name="ln2821">}</a>
<a name="ln2822"> </a>
<a name="ln2823">/// Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln2824">///</a>
<a name="ln2825">/// @return  OK or FAIL.</a>
<a name="ln2826">///          When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not empty.</a>
<a name="ln2827">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln2828">{</a>
<a name="ln2829">  buf_T *tbuf = curbuf;</a>
<a name="ln2830">  int retval = OK;</a>
<a name="ln2831"> </a>
<a name="ln2832">  // Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;.</a>
<a name="ln2833">  curbuf = tobuf;</a>
<a name="ln2834">  for (linenr_T lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln2835">    char *p = xstrdup(ml_get_buf(frombuf, lnum));</a>
<a name="ln2836">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln2837">      xfree(p);</a>
<a name="ln2838">      retval = FAIL;</a>
<a name="ln2839">      break;</a>
<a name="ln2840">    }</a>
<a name="ln2841">    xfree(p);</a>
<a name="ln2842">  }</a>
<a name="ln2843"> </a>
<a name="ln2844">  // Delete all the lines in &quot;frombuf&quot;.</a>
<a name="ln2845">  if (retval != FAIL) {</a>
<a name="ln2846">    curbuf = frombuf;</a>
<a name="ln2847">    for (linenr_T lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln2848">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln2849">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln2850">        // might fail again...</a>
<a name="ln2851">        retval = FAIL;</a>
<a name="ln2852">        break;</a>
<a name="ln2853">      }</a>
<a name="ln2854">    }</a>
<a name="ln2855">  }</a>
<a name="ln2856"> </a>
<a name="ln2857">  curbuf = tbuf;</a>
<a name="ln2858">  return retval;</a>
<a name="ln2859">}</a>
<a name="ln2860"> </a>
<a name="ln2861">/// Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln2862">/// Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln2863">///</a>
<a name="ln2864">/// @return  1 if a changed buffer was found or,</a>
<a name="ln2865">///          2 if a message has been displayed or,</a>
<a name="ln2866">///          0 otherwise.</a>
<a name="ln2867">int buf_check_timestamp(buf_T *buf)</a>
<a name="ln2868">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2869">{</a>
<a name="ln2870">  int retval = 0;</a>
<a name="ln2871">  char *mesg = NULL;</a>
<a name="ln2872">  char *mesg2 = &quot;&quot;;</a>
<a name="ln2873">  bool helpmesg = false;</a>
<a name="ln2874"> </a>
<a name="ln2875">  enum {</a>
<a name="ln2876">    RELOAD_NONE,</a>
<a name="ln2877">    RELOAD_NORMAL,</a>
<a name="ln2878">    RELOAD_DETECT,</a>
<a name="ln2879">  } reload = RELOAD_NONE;</a>
<a name="ln2880"> </a>
<a name="ln2881">  bool can_reload = false;</a>
<a name="ln2882">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln2883">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln2884">  static bool busy = false;</a>
<a name="ln2885"> </a>
<a name="ln2886">  bufref_T bufref;</a>
<a name="ln2887">  set_bufref(&amp;bufref, buf);</a>
<a name="ln2888"> </a>
<a name="ln2889">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln2890">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln2891">  // recursively: ignore this buffer.</a>
<a name="ln2892">  if (buf-&gt;terminal</a>
<a name="ln2893">      || buf-&gt;b_ffname == NULL</a>
<a name="ln2894">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln2895">      || !bt_normal(buf)</a>
<a name="ln2896">      || buf-&gt;b_saving</a>
<a name="ln2897">      || busy) {</a>
<a name="ln2898">    return 0;</a>
<a name="ln2899">  }</a>
<a name="ln2900"> </a>
<a name="ln2901">  FileInfo file_info;</a>
<a name="ln2902">  bool file_info_ok;</a>
<a name="ln2903">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln2904">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln2905">      &amp;&amp; (!(file_info_ok = os_fileinfo(buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln2906">          || time_differs(&amp;file_info, buf-&gt;b_mtime, buf-&gt;b_mtime_ns)</a>
<a name="ln2907">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln2908">    const int prev_b_mtime = (int)buf-&gt;b_mtime;</a>
<a name="ln2909"> </a>
<a name="ln2910">    retval = 1;</a>
<a name="ln2911"> </a>
<a name="ln2912">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln2913">    // FileChangedShell autocmd)</a>
<a name="ln2914">    if (!file_info_ok) {</a>
<a name="ln2915">      // Check the file again later to see if it re-appears.</a>
<a name="ln2916">      buf-&gt;b_mtime = -1;</a>
<a name="ln2917">      buf-&gt;b_orig_size = 0;</a>
<a name="ln2918">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln2919">    } else {</a>
<a name="ln2920">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln2921">    }</a>
<a name="ln2922"> </a>
<a name="ln2923">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln2924">      // Don't do anything for a directory.  Might contain the file explorer.</a>
<a name="ln2925">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln2926">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln2927">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln2928">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln2929">      // was set, the global option value otherwise.</a>
<a name="ln2930">      reload = RELOAD_NORMAL;</a>
<a name="ln2931">    } else {</a>
<a name="ln2932">      char *reason;</a>
<a name="ln2933">      if (!file_info_ok) {</a>
<a name="ln2934">        reason = &quot;deleted&quot;;</a>
<a name="ln2935">      } else if (bufIsChanged(buf)) {</a>
<a name="ln2936">        reason = &quot;conflict&quot;;</a>
<a name="ln2937">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln2938">        reason = &quot;changed&quot;;</a>
<a name="ln2939">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln2940">        reason = &quot;mode&quot;;</a>
<a name="ln2941">      } else {</a>
<a name="ln2942">        reason = &quot;time&quot;;</a>
<a name="ln2943">      }</a>
<a name="ln2944"> </a>
<a name="ln2945">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln2946">      // autocommands.</a>
<a name="ln2947">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln2948">      busy = true;</a>
<a name="ln2949">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln2950">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln2951">      allbuf_lock++;</a>
<a name="ln2952">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln2953">      allbuf_lock--;</a>
<a name="ln2954">      busy = false;</a>
<a name="ln2955">      if (n) {</a>
<a name="ln2956">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2957">          emsg(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln2958">        }</a>
<a name="ln2959">        char *s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln2960">        if (strcmp(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln2961">          reload = RELOAD_NORMAL;</a>
<a name="ln2962">        } else if (strcmp(s, &quot;edit&quot;) == 0) {</a>
<a name="ln2963">          reload = RELOAD_DETECT;</a>
<a name="ln2964">        } else if (strcmp(s, &quot;ask&quot;) == 0) {</a>
<a name="ln2965">          n = false;</a>
<a name="ln2966">        } else {</a>
<a name="ln2967">          return 2;</a>
<a name="ln2968">        }</a>
<a name="ln2969">      }</a>
<a name="ln2970">      if (!n) {</a>
<a name="ln2971">        if (*reason == 'd') {</a>
<a name="ln2972">          // Only give the message once.</a>
<a name="ln2973">          if (prev_b_mtime != -1) {</a>
<a name="ln2974">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln2975">          }</a>
<a name="ln2976">        } else {</a>
<a name="ln2977">          helpmesg = true;</a>
<a name="ln2978">          can_reload = true;</a>
<a name="ln2979"> </a>
<a name="ln2980">          // Check if the file contents really changed to avoid</a>
<a name="ln2981">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln2982">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln2983">          // changed.</a>
<a name="ln2984">          if (reason[2] == 'n') {</a>
<a name="ln2985">            mesg = _(</a>
<a name="ln2986">                    &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln2987">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln2988">          } else if (reason[1] == 'h') {</a>
<a name="ln2989">            mesg = _(&quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln2990">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln2991">          } else if (*reason == 'm') {</a>
<a name="ln2992">            mesg = _(&quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln2993">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln2994">          } else {</a>
<a name="ln2995">            // Only timestamp changed, store it to avoid a warning</a>
<a name="ln2996">            // in check_mtime() later.</a>
<a name="ln2997">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln2998">            buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln2999">          }</a>
<a name="ln3000">        }</a>
<a name="ln3001">      }</a>
<a name="ln3002">    }</a>
<a name="ln3003">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln3004">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln3005">    retval = 1;</a>
<a name="ln3006">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln3007">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln3008">    can_reload = true;</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">  if (mesg != NULL) {</a>
<a name="ln3012">    char *path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln3013">    if (!helpmesg) {</a>
<a name="ln3014">      mesg2 = &quot;&quot;;</a>
<a name="ln3015">    }</a>
<a name="ln3016">    const size_t tbuf_len = strlen(path) + strlen(mesg) + strlen(mesg2) + 2;</a>
<a name="ln3017">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln3018">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln3019">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln3020">    // mesg2 has been appended.</a>
<a name="ln3021">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln3022">    if (can_reload) {</a>
<a name="ln3023">      if (*mesg2 != NUL) {</a>
<a name="ln3024">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln3025">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln3026">      }</a>
<a name="ln3027">      switch (do_dialog(VIM_WARNING, _(&quot;Warning&quot;), tbuf,</a>
<a name="ln3028">                        _(&quot;&amp;OK\n&amp;Load File\nLoad File &amp;and Options&quot;),</a>
<a name="ln3029">                        1, NULL, true)) {</a>
<a name="ln3030">      case 2:</a>
<a name="ln3031">        reload = RELOAD_NORMAL;</a>
<a name="ln3032">        break;</a>
<a name="ln3033">      case 3:</a>
<a name="ln3034">        reload = RELOAD_DETECT;</a>
<a name="ln3035">        break;</a>
<a name="ln3036">      }</a>
<a name="ln3037">    } else if (State &gt; MODE_NORMAL_BUSY || (State &amp; MODE_CMDLINE) || already_warned) {</a>
<a name="ln3038">      if (*mesg2 != NUL) {</a>
<a name="ln3039">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln3040">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln3041">      }</a>
<a name="ln3042">      emsg(tbuf);</a>
<a name="ln3043">      retval = 2;</a>
<a name="ln3044">    } else {</a>
<a name="ln3045">      if (!autocmd_busy) {</a>
<a name="ln3046">        msg_start();</a>
<a name="ln3047">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln3048">        if (*mesg2 != NUL) {</a>
<a name="ln3049">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln3050">        }</a>
<a name="ln3051">        msg_clr_eos();</a>
<a name="ln3052">        (void)msg_end();</a>
<a name="ln3053">        if (emsg_silent == 0 &amp;&amp; !in_assert_fails) {</a>
<a name="ln3054">          ui_flush();</a>
<a name="ln3055">          // give the user some time to think about it</a>
<a name="ln3056">          os_delay(1004L, true);</a>
<a name="ln3057"> </a>
<a name="ln3058">          // don't redraw and erase the message</a>
<a name="ln3059">          redraw_cmdline = false;</a>
<a name="ln3060">        }</a>
<a name="ln3061">      }</a>
<a name="ln3062">      already_warned = true;</a>
<a name="ln3063">    }</a>
<a name="ln3064"> </a>
<a name="ln3065">    xfree(path);</a>
<a name="ln3066">    xfree(tbuf);</a>
<a name="ln3067">  }</a>
<a name="ln3068"> </a>
<a name="ln3069">  if (reload != RELOAD_NONE) {</a>
<a name="ln3070">    // Reload the buffer.</a>
<a name="ln3071">    buf_reload(buf, orig_mode, reload == RELOAD_DETECT);</a>
<a name="ln3072">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln3073">      uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln3074"> </a>
<a name="ln3075">      // Any existing undo file is unusable, write it now.</a>
<a name="ln3076">      u_compute_hash(buf, hash);</a>
<a name="ln3077">      u_write_undo(NULL, false, buf, hash);</a>
<a name="ln3078">    }</a>
<a name="ln3079">  }</a>
<a name="ln3080"> </a>
<a name="ln3081">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln3082">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln3083">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln3084">  }</a>
<a name="ln3085">  return retval;</a>
<a name="ln3086">}</a>
<a name="ln3087"> </a>
<a name="ln3088">/// Reload a buffer that is already loaded.</a>
<a name="ln3089">/// Used when the file was changed outside of Vim.</a>
<a name="ln3090">/// &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln3091">/// buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln3092">void buf_reload(buf_T *buf, int orig_mode, bool reload_options)</a>
<a name="ln3093">{</a>
<a name="ln3094">  exarg_T ea;</a>
<a name="ln3095">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln3096">  buf_T *savebuf;</a>
<a name="ln3097">  bufref_T bufref;</a>
<a name="ln3098">  int saved = OK;</a>
<a name="ln3099">  aco_save_T aco;</a>
<a name="ln3100">  int flags = READ_NEW;</a>
<a name="ln3101"> </a>
<a name="ln3102">  // Set curwin/curbuf for &quot;buf&quot; and save some things.</a>
<a name="ln3103">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3104"> </a>
<a name="ln3105">  // Unless reload_options is set, we only want to read the text from the</a>
<a name="ln3106">  // file, not reset the syntax highlighting, clear marks, diff status, etc.</a>
<a name="ln3107">  // Force the fileformat and encoding to be the same.</a>
<a name="ln3108">  if (reload_options) {</a>
<a name="ln3109">    CLEAR_FIELD(ea);</a>
<a name="ln3110">  } else {</a>
<a name="ln3111">    prep_exarg(&amp;ea, buf);</a>
<a name="ln3112">  }</a>
<a name="ln3113"> </a>
<a name="ln3114">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3115">  linenr_T old_topline = curwin-&gt;w_topline;</a>
<a name="ln3116"> </a>
<a name="ln3117">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln3118">    // Save all the text, so that the reload can be undone.</a>
<a name="ln3119">    // Sync first so that this is a separate undo-able action.</a>
<a name="ln3120">    u_sync(false);</a>
<a name="ln3121">    saved = u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true);</a>
<a name="ln3122">    flags |= READ_KEEP_UNDO;</a>
<a name="ln3123">  }</a>
<a name="ln3124"> </a>
<a name="ln3125">  // To behave like when a new file is edited (matters for</a>
<a name="ln3126">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln3127">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln3128">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln3129">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln3130">  if (buf_is_empty(curbuf) || saved == FAIL) {</a>
<a name="ln3131">    savebuf = NULL;</a>
<a name="ln3132">  } else {</a>
<a name="ln3133">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln3134">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln3135">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln3136">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln3137">      // Open the memline.</a>
<a name="ln3138">      curbuf = savebuf;</a>
<a name="ln3139">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln3140">      saved = ml_open(curbuf);</a>
<a name="ln3141">      curbuf = buf;</a>
<a name="ln3142">      curwin-&gt;w_buffer = buf;</a>
<a name="ln3143">    }</a>
<a name="ln3144">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln3145">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln3146">      semsg(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln3147">            buf-&gt;b_fname);</a>
<a name="ln3148">      saved = FAIL;</a>
<a name="ln3149">    }</a>
<a name="ln3150">  }</a>
<a name="ln3151"> </a>
<a name="ln3152">  if (saved == OK) {</a>
<a name="ln3153">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln3154">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln3155">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln3156">                 (linenr_T)MAXLNUM, &amp;ea, flags, false) != OK) {</a>
<a name="ln3157">      if (!aborting()) {</a>
<a name="ln3158">        semsg(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln3159">      }</a>
<a name="ln3160">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln3161">        // Put the text back from the save buffer.  First</a>
<a name="ln3162">        // delete any lines that readfile() added.</a>
<a name="ln3163">        while (!buf_is_empty(curbuf)) {</a>
<a name="ln3164">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln3165">            break;</a>
<a name="ln3166">          }</a>
<a name="ln3167">        }</a>
<a name="ln3168">        (void)move_lines(savebuf, buf);</a>
<a name="ln3169">      }</a>
<a name="ln3170">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln3171">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln3172">      unchanged(buf, true, true);</a>
<a name="ln3173">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln3174">        u_blockfree(buf);</a>
<a name="ln3175">        u_clearall(buf);</a>
<a name="ln3176">      } else {</a>
<a name="ln3177">        // Mark all undo states as changed.</a>
<a name="ln3178">        u_unchanged(curbuf);</a>
<a name="ln3179">      }</a>
<a name="ln3180">      buf_updates_unload(curbuf, true);</a>
<a name="ln3181">      curbuf-&gt;b_mod_set = true;</a>
<a name="ln3182">    }</a>
<a name="ln3183">  }</a>
<a name="ln3184">  xfree(ea.cmd);</a>
<a name="ln3185"> </a>
<a name="ln3186">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln3187">    wipe_buffer(savebuf, false);</a>
<a name="ln3188">  }</a>
<a name="ln3189"> </a>
<a name="ln3190">  // Invalidate diff info if necessary.</a>
<a name="ln3191">  diff_invalidate(curbuf);</a>
<a name="ln3192"> </a>
<a name="ln3193">  // Restore the topline and cursor position and check it (lines may</a>
<a name="ln3194">  // have been removed).</a>
<a name="ln3195">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3196">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3197">  } else {</a>
<a name="ln3198">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln3199">  }</a>
<a name="ln3200">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln3201">  check_cursor();</a>
<a name="ln3202">  update_topline(curwin);</a>
<a name="ln3203">  keep_filetype = false;</a>
<a name="ln3204"> </a>
<a name="ln3205">  // Update folds unless they are defined manually.</a>
<a name="ln3206">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln3207">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln3208">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln3209">      foldUpdateAll(wp);</a>
<a name="ln3210">    }</a>
<a name="ln3211">  }</a>
<a name="ln3212"> </a>
<a name="ln3213">  // If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln3214">  // value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln3215">  // reset it, might have had a read error.</a>
<a name="ln3216">  if (orig_mode == curbuf-&gt;b_orig_mode) {</a>
<a name="ln3217">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln3218">  }</a>
<a name="ln3219"> </a>
<a name="ln3220">  // Modelines must override settings done by autocommands.</a>
<a name="ln3221">  do_modelines(0);</a>
<a name="ln3222"> </a>
<a name="ln3223">  // restore curwin/curbuf and a few other things</a>
<a name="ln3224">  aucmd_restbuf(&amp;aco);</a>
<a name="ln3225">  // Careful: autocommands may have made &quot;buf&quot; invalid!</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3229">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3230">{</a>
<a name="ln3231">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln3232">  buf-&gt;b_mtime_ns = file_info-&gt;stat.st_mtim.tv_nsec;</a>
<a name="ln3233">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln3234">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237">/// Adjust the line with missing eol, used for the next write.</a>
<a name="ln3238">/// Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln3239">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln3240">{</a>
<a name="ln3241">  if (curbuf-&gt;b_no_eol_lnum != 0) {     // only if there is a missing eol</a>
<a name="ln3242">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln3243">  }</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3247">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln3248">/// unless when it looks like a URL.</a>
<a name="ln3249">void forward_slash(char *fname)</a>
<a name="ln3250">{</a>
<a name="ln3251">  char *p;</a>
<a name="ln3252"> </a>
<a name="ln3253">  if (path_with_url(fname)) {</a>
<a name="ln3254">    return;</a>
<a name="ln3255">  }</a>
<a name="ln3256">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln3257">    if (*p == '\\') {</a>
<a name="ln3258">      *p = '/';</a>
<a name="ln3259">    }</a>
<a name="ln3260">  }</a>
<a name="ln3261">}</a>
<a name="ln3262">#endif</a>
<a name="ln3263"> </a>
<a name="ln3264">/// Path to Nvim's own temp dir. Ends in a slash.</a>
<a name="ln3265">static char *vim_tempdir = NULL;</a>
<a name="ln3266">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3267">DIR *vim_tempdir_dp = NULL;  ///&lt; File descriptor of temp dir</a>
<a name="ln3268">#endif</a>
<a name="ln3269"> </a>
<a name="ln3270">/// Creates a directory for private use by this instance of Nvim, trying each of</a>
<a name="ln3271">/// `TEMP_DIR_NAMES` until one succeeds.</a>
<a name="ln3272">///</a>
<a name="ln3273">/// Only done once, the same directory is used for all temp files.</a>
<a name="ln3274">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln3275">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln3276">/// file when creating the directory and not for each temp file.</a>
<a name="ln3277">static void vim_mktempdir(void)</a>
<a name="ln3278">{</a>
<a name="ln3279">  static const char *temp_dirs[] = TEMP_DIR_NAMES;  // Try each of these until one succeeds.</a>
<a name="ln3280">  char tmp[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3281">  char path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3282">  char user[40] = { 0 };</a>
<a name="ln3283">  char appname[40] = { 0 };</a>
<a name="ln3284"> </a>
<a name="ln3285">  (void)os_get_username(user, sizeof(user));</a>
<a name="ln3286">  // Usernames may contain slashes! #19240</a>
<a name="ln3287">  memchrsub(user, '/', '_', sizeof(user));</a>
<a name="ln3288">  memchrsub(user, '\\', '_', sizeof(user));</a>
<a name="ln3289"> </a>
<a name="ln3290">  // Appname may be a relative path, replace slashes to make it name-like.</a>
<a name="ln3291">  xstrlcpy(appname, get_appname(), sizeof(appname));</a>
<a name="ln3292">  memchrsub(appname, '/', '%', sizeof(appname));</a>
<a name="ln3293">  memchrsub(appname, '\\', '%', sizeof(appname));</a>
<a name="ln3294"> </a>
<a name="ln3295">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln3296">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln3297">  mode_t umask_save = umask(0077);</a>
<a name="ln3298">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln3299">    // Expand environment variables, leave room for &quot;/tmp/nvim.&lt;user&gt;/XXXXXX/999999999&quot;.</a>
<a name="ln3300">    expand_env((char *)temp_dirs[i], tmp, TEMP_FILE_PATH_MAXLEN - 64);</a>
<a name="ln3301">    if (!os_isdir(tmp)) {</a>
<a name="ln3302">      continue;</a>
<a name="ln3303">    }</a>
<a name="ln3304"> </a>
<a name="ln3305">    // &quot;/tmp/&quot; exists, now try to create &quot;/tmp/nvim.&lt;user&gt;/&quot;.</a>
<a name="ln3306">    add_pathsep(tmp);</a>
<a name="ln3307"> </a>
<a name="ln3308">    xstrlcat(tmp, appname, sizeof(tmp));</a>
<a name="ln3309">    xstrlcat(tmp, &quot;.&quot;, sizeof(tmp));</a>
<a name="ln3310">    xstrlcat(tmp, user, sizeof(tmp));</a>
<a name="ln3311">    (void)os_mkdir(tmp, 0700);  // Always create, to avoid a race.</a>
<a name="ln3312">    bool owned = os_file_owned(tmp);</a>
<a name="ln3313">    bool isdir = os_isdir(tmp);</a>
<a name="ln3314">#ifdef UNIX</a>
<a name="ln3315">    int perm = os_getperm(tmp);  // XDG_RUNTIME_DIR must be owned by the user, mode 0700.</a>
<a name="ln3316">    bool valid = isdir &amp;&amp; owned &amp;&amp; 0700 == (perm &amp; 0777);</a>
<a name="ln3317">#else</a>
<a name="ln3318">    bool valid = isdir &amp;&amp; owned;  // TODO(justinmk): Windows ACL?</a>
<a name="ln3319">#endif</a>
<a name="ln3320">    if (valid) {</a>
<a name="ln3321">      add_pathsep(tmp);</a>
<a name="ln3322">    } else {</a>
<a name="ln3323">      if (!owned) {</a>
<a name="ln3324">        ELOG(&quot;tempdir root not owned by current user (%s): %s&quot;, user, tmp);</a>
<a name="ln3325">      } else if (!isdir) {</a>
<a name="ln3326">        ELOG(&quot;tempdir root not a directory: %s&quot;, tmp);</a>
<a name="ln3327">      }</a>
<a name="ln3328">#ifdef UNIX</a>
<a name="ln3329">      if (0700 != (perm &amp; 0777)) {</a>
<a name="ln3330">        ELOG(&quot;tempdir root has invalid permissions (%o): %s&quot;, perm, tmp);</a>
<a name="ln3331">      }</a>
<a name="ln3332">#endif</a>
<a name="ln3333">      // If our &quot;root&quot; tempdir is invalid or fails, proceed without &quot;&lt;user&gt;/&quot;.</a>
<a name="ln3334">      // Else user1 could break user2 by creating &quot;/tmp/nvim.user2/&quot;.</a>
<a name="ln3335">      tmp[strlen(tmp) - strlen(user)] = '\0';</a>
<a name="ln3336">    }</a>
<a name="ln3337"> </a>
<a name="ln3338">    // Now try to create &quot;/tmp/nvim.&lt;user&gt;/XXXXXX&quot;.</a>
<a name="ln3339">    xstrlcat(tmp, &quot;XXXXXX&quot;, sizeof(tmp));  // mkdtemp &quot;template&quot;, will be replaced with random alphanumeric chars.</a>
<a name="ln3340">    int r = os_mkdtemp(tmp, path);</a>
<a name="ln3341">    if (r != 0) {</a>
<a name="ln3342">      WLOG(&quot;tempdir create failed: %s: %s&quot;, os_strerror(r), tmp);</a>
<a name="ln3343">      continue;</a>
<a name="ln3344">    }</a>
<a name="ln3345"> </a>
<a name="ln3346">    if (vim_settempdir(path)) {</a>
<a name="ln3347">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln3348">      break;</a>
<a name="ln3349">    }</a>
<a name="ln3350">    // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln3351">    os_rmdir(path);</a>
<a name="ln3352">  }</a>
<a name="ln3353">  (void)umask(umask_save);</a>
<a name="ln3354">}</a>
<a name="ln3355"> </a>
<a name="ln3356">/// Core part of &quot;readdir()&quot; function.</a>
<a name="ln3357">/// Retrieve the list of files/directories of &quot;path&quot; into &quot;gap&quot;.</a>
<a name="ln3358">///</a>
<a name="ln3359">/// @return  OK for success, FAIL for failure.</a>
<a name="ln3360">int readdir_core(garray_T *gap, const char *path, void *context, CheckItem checkitem)</a>
<a name="ln3361">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln3362">{</a>
<a name="ln3363">  ga_init(gap, (int)sizeof(char *), 20);</a>
<a name="ln3364"> </a>
<a name="ln3365">  Directory dir;</a>
<a name="ln3366">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln3367">    smsg(0, _(e_notopen), path);</a>
<a name="ln3368">    return FAIL;</a>
<a name="ln3369">  }</a>
<a name="ln3370"> </a>
<a name="ln3371">  while (true) {</a>
<a name="ln3372">    const char *p = os_scandir_next(&amp;dir);</a>
<a name="ln3373">    if (p == NULL) {</a>
<a name="ln3374">      break;</a>
<a name="ln3375">    }</a>
<a name="ln3376"> </a>
<a name="ln3377">    bool ignore = (p[0] == '.' &amp;&amp; (p[1] == NUL || (p[1] == '.' &amp;&amp; p[2] == NUL)));</a>
<a name="ln3378">    if (!ignore &amp;&amp; checkitem != NULL) {</a>
<a name="ln3379">      varnumber_T r = checkitem(context, p);</a>
<a name="ln3380">      if (r &lt; 0) {</a>
<a name="ln3381">        break;</a>
<a name="ln3382">      }</a>
<a name="ln3383">      if (r == 0) {</a>
<a name="ln3384">        ignore = true;</a>
<a name="ln3385">      }</a>
<a name="ln3386">    }</a>
<a name="ln3387"> </a>
<a name="ln3388">    if (!ignore) {</a>
<a name="ln3389">      ga_grow(gap, 1);</a>
<a name="ln3390">      ((char **)gap-&gt;ga_data)[gap-&gt;ga_len++] = xstrdup(p);</a>
<a name="ln3391">    }</a>
<a name="ln3392">  }</a>
<a name="ln3393"> </a>
<a name="ln3394">  os_closedir(&amp;dir);</a>
<a name="ln3395"> </a>
<a name="ln3396">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln3397">    sort_strings(gap-&gt;ga_data, gap-&gt;ga_len);</a>
<a name="ln3398">  }</a>
<a name="ln3399"> </a>
<a name="ln3400">  return OK;</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln3404">///</a>
<a name="ln3405">/// @param name  The path which should be deleted.</a>
<a name="ln3406">///</a>
<a name="ln3407">/// @return  0 for success, -1 if some file was not deleted.</a>
<a name="ln3408">int delete_recursive(const char *name)</a>
<a name="ln3409">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3410">{</a>
<a name="ln3411">  int result = 0;</a>
<a name="ln3412"> </a>
<a name="ln3413">  if (os_isrealdir(name)) {</a>
<a name="ln3414">    char *exp = xstrdup(name);</a>
<a name="ln3415">    garray_T ga;</a>
<a name="ln3416">    if (readdir_core(&amp;ga, exp, NULL, NULL) == OK) {</a>
<a name="ln3417">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln3418">        vim_snprintf(NameBuff, MAXPATHL, &quot;%s/%s&quot;, exp, ((char **)ga.ga_data)[i]);</a>
<a name="ln3419">        if (delete_recursive(NameBuff) != 0) {</a>
<a name="ln3420">          // Remember the failure but continue deleting any further</a>
<a name="ln3421">          // entries.</a>
<a name="ln3422">          result = -1;</a>
<a name="ln3423">        }</a>
<a name="ln3424">      }</a>
<a name="ln3425">      ga_clear_strings(&amp;ga);</a>
<a name="ln3426">      if (os_rmdir(exp) != 0) {</a>
<a name="ln3427">        result = -1;</a>
<a name="ln3428">      }</a>
<a name="ln3429">    } else {</a>
<a name="ln3430">      result = -1;</a>
<a name="ln3431">    }</a>
<a name="ln3432">    xfree(exp);</a>
<a name="ln3433">  } else {</a>
<a name="ln3434">    // Delete symlink only.</a>
<a name="ln3435">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln3436">  }</a>
<a name="ln3437"> </a>
<a name="ln3438">  return result;</a>
<a name="ln3439">}</a>
<a name="ln3440"> </a>
<a name="ln3441">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3442">/// Open temporary directory and take file lock to prevent</a>
<a name="ln3443">/// to be auto-cleaned.</a>
<a name="ln3444">static void vim_opentempdir(void)</a>
<a name="ln3445">{</a>
<a name="ln3446">  if (vim_tempdir_dp != NULL) {</a>
<a name="ln3447">    return;</a>
<a name="ln3448">  }</a>
<a name="ln3449"> </a>
<a name="ln3450">  DIR *dp = opendir(vim_tempdir);</a>
<a name="ln3451">  if (dp == NULL) {</a>
<a name="ln3452">    return;</a>
<a name="ln3453">  }</a>
<a name="ln3454"> </a>
<a name="ln3455">  vim_tempdir_dp = dp;</a>
<a name="ln3456">  flock(dirfd(vim_tempdir_dp), LOCK_SH);</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">/// Close temporary directory - it automatically release file lock.</a>
<a name="ln3460">static void vim_closetempdir(void)</a>
<a name="ln3461">{</a>
<a name="ln3462">  if (vim_tempdir_dp == NULL) {</a>
<a name="ln3463">    return;</a>
<a name="ln3464">  }</a>
<a name="ln3465"> </a>
<a name="ln3466">  closedir(vim_tempdir_dp);</a>
<a name="ln3467">  vim_tempdir_dp = NULL;</a>
<a name="ln3468">}</a>
<a name="ln3469">#endif</a>
<a name="ln3470"> </a>
<a name="ln3471">/// Delete the temp directory and all files it contains.</a>
<a name="ln3472">void vim_deltempdir(void)</a>
<a name="ln3473">{</a>
<a name="ln3474">  if (vim_tempdir == NULL) {</a>
<a name="ln3475">    return;</a>
<a name="ln3476">  }</a>
<a name="ln3477"> </a>
<a name="ln3478">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3479">  vim_closetempdir();</a>
<a name="ln3480">#endif</a>
<a name="ln3481">  // remove the trailing path separator</a>
<a name="ln3482">  path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln3483">  delete_recursive(vim_tempdir);</a>
<a name="ln3484">  XFREE_CLEAR(vim_tempdir);</a>
<a name="ln3485">}</a>
<a name="ln3486"> </a>
<a name="ln3487">/// Gets path to Nvim's own temp dir (ending with slash).</a>
<a name="ln3488">///</a>
<a name="ln3489">/// Creates the directory on the first call.</a>
<a name="ln3490">char *vim_gettempdir(void)</a>
<a name="ln3491">{</a>
<a name="ln3492">  static int notfound = 0;</a>
<a name="ln3493">  if (vim_tempdir == NULL || !os_isdir(vim_tempdir)) {</a>
<a name="ln3494">    if (vim_tempdir != NULL) {</a>
<a name="ln3495">      notfound++;</a>
<a name="ln3496">      if (notfound == 1) {</a>
<a name="ln3497">        ELOG(&quot;tempdir disappeared (antivirus or broken cleanup job?): %s&quot;, vim_tempdir);</a>
<a name="ln3498">      }</a>
<a name="ln3499">      if (notfound &gt; 1) {</a>
<a name="ln3500">        msg_schedule_semsg(&quot;E5431: tempdir disappeared (%d times)&quot;, notfound);</a>
<a name="ln3501">      }</a>
<a name="ln3502">      XFREE_CLEAR(vim_tempdir);</a>
<a name="ln3503">    }</a>
<a name="ln3504">    vim_mktempdir();</a>
<a name="ln3505">  }</a>
<a name="ln3506">  return vim_tempdir;</a>
<a name="ln3507">}</a>
<a name="ln3508"> </a>
<a name="ln3509">/// Sets Nvim's own temporary directory name to `tempdir`. This directory must</a>
<a name="ln3510">/// already exist. Expands the name to a full path and put it in `vim_tempdir`.</a>
<a name="ln3511">/// This avoids that using `:cd` would confuse us.</a>
<a name="ln3512">///</a>
<a name="ln3513">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln3514">///</a>
<a name="ln3515">/// @return false if we run out of memory.</a>
<a name="ln3516">static bool vim_settempdir(char *tempdir)</a>
<a name="ln3517">{</a>
<a name="ln3518">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln3519">  if (buf == NULL) {</a>
<a name="ln3520">    return false;</a>
<a name="ln3521">  }</a>
<a name="ln3522"> </a>
<a name="ln3523">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln3524">  add_pathsep(buf);</a>
<a name="ln3525">  vim_tempdir = xstrdup(buf);</a>
<a name="ln3526">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3527">  vim_opentempdir();</a>
<a name="ln3528">#endif</a>
<a name="ln3529">  xfree(buf);</a>
<a name="ln3530">  return true;</a>
<a name="ln3531">}</a>
<a name="ln3532"> </a>
<a name="ln3533">/// Return a unique name that can be used for a temp file.</a>
<a name="ln3534">///</a>
<a name="ln3535">/// @note The temp file is NOT created.</a>
<a name="ln3536">///</a>
<a name="ln3537">/// @return  pointer to the temp file name or NULL if Nvim can't create</a>
<a name="ln3538">///          temporary directory for its own temporary files.</a>
<a name="ln3539">char *vim_tempname(void)</a>
<a name="ln3540">{</a>
<a name="ln3541">  // Temp filename counter.</a>
<a name="ln3542">  static uint64_t temp_count;</a>
<a name="ln3543"> </a>
<a name="ln3544">  char *tempdir = vim_gettempdir();</a>
<a name="ln3545">  if (!tempdir) {</a>
<a name="ln3546">    return NULL;</a>
<a name="ln3547">  }</a>
<a name="ln3548"> </a>
<a name="ln3549">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln3550">  // and nobody else creates a file in it.</a>
<a name="ln3551">  char templ[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3552">  snprintf(templ, TEMP_FILE_PATH_MAXLEN, &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln3553">  return xstrdup(templ);</a>
<a name="ln3554">}</a>
<a name="ln3555"> </a>
<a name="ln3556">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln3557">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln3558">/// vim_regcomp() often.</a>
<a name="ln3559">///</a>
<a name="ln3560">/// Used for autocommands and 'wildignore'.</a>
<a name="ln3561">///</a>
<a name="ln3562">/// @param pattern pattern to match with</a>
<a name="ln3563">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln3564">/// @param fname full path of the file name</a>
<a name="ln3565">/// @param sfname short file name or NULL</a>
<a name="ln3566">/// @param tail tail of the path</a>
<a name="ln3567">/// @param allow_dirs Allow matching with dir</a>
<a name="ln3568">///</a>
<a name="ln3569">/// @return true if there is a match, false otherwise</a>
<a name="ln3570">bool match_file_pat(char *pattern, regprog_T **prog, char *fname, char *sfname, char *tail,</a>
<a name="ln3571">                    int allow_dirs)</a>
<a name="ln3572">{</a>
<a name="ln3573">  regmatch_T regmatch;</a>
<a name="ln3574">  bool result = false;</a>
<a name="ln3575"> </a>
<a name="ln3576">  regmatch.rm_ic = p_fic;   // ignore case if 'fileignorecase' is set</a>
<a name="ln3577">  regmatch.regprog = prog != NULL ? *prog : vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln3578"> </a>
<a name="ln3579">  // Try for a match with the pattern with:</a>
<a name="ln3580">  // 1. the full file name, when the pattern has a '/'.</a>
<a name="ln3581">  // 2. the short file name, when the pattern has a '/'.</a>
<a name="ln3582">  // 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln3583">  if (regmatch.regprog != NULL</a>
<a name="ln3584">      &amp;&amp; ((allow_dirs</a>
<a name="ln3585">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln3586">               || (sfname != NULL</a>
<a name="ln3587">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln3588">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln3589">    result = true;</a>
<a name="ln3590">  }</a>
<a name="ln3591"> </a>
<a name="ln3592">  if (prog != NULL) {</a>
<a name="ln3593">    *prog = regmatch.regprog;</a>
<a name="ln3594">  } else {</a>
<a name="ln3595">    vim_regfree(regmatch.regprog);</a>
<a name="ln3596">  }</a>
<a name="ln3597">  return result;</a>
<a name="ln3598">}</a>
<a name="ln3599"> </a>
<a name="ln3600">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln3601">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln3602">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln3603">///</a>
<a name="ln3604">/// @param list list of patterns to match</a>
<a name="ln3605">/// @param sfname short file name</a>
<a name="ln3606">/// @param ffname full file name</a>
<a name="ln3607">///</a>
<a name="ln3608">/// @return true if there was a match</a>
<a name="ln3609">bool match_file_list(char *list, char *sfname, char *ffname)</a>
<a name="ln3610">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln3611">{</a>
<a name="ln3612">  char *tail = path_tail(sfname);</a>
<a name="ln3613"> </a>
<a name="ln3614">  // try all patterns in 'wildignore'</a>
<a name="ln3615">  char *p = list;</a>
<a name="ln3616">  while (*p) {</a>
<a name="ln3617">    char buf[MAXPATHL];</a>
<a name="ln3618">    copy_option_part(&amp;p, buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln3619">    char allow_dirs;</a>
<a name="ln3620">    char *regpat = file_pat_to_reg_pat(buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln3621">    if (regpat == NULL) {</a>
<a name="ln3622">      break;</a>
<a name="ln3623">    }</a>
<a name="ln3624">    bool match = match_file_pat(regpat, NULL, ffname, sfname, tail, (int)allow_dirs);</a>
<a name="ln3625">    xfree(regpat);</a>
<a name="ln3626">    if (match) {</a>
<a name="ln3627">      return true;</a>
<a name="ln3628">    }</a>
<a name="ln3629">  }</a>
<a name="ln3630">  return false;</a>
<a name="ln3631">}</a>
<a name="ln3632"> </a>
<a name="ln3633">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln3634">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln3635">/// is a directory path separator to be matched, then true is put in</a>
<a name="ln3636">/// allow_dirs, otherwise false is put there -- webb.</a>
<a name="ln3637">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln3638">///</a>
<a name="ln3639">/// @param pat_end     first char after pattern or NULL</a>
<a name="ln3640">/// @param allow_dirs  Result passed back out in here</a>
<a name="ln3641">/// @param no_bslash   Don't use a backward slash as pathsep</a>
<a name="ln3642">///</a>
<a name="ln3643">/// @return            NULL on failure.</a>
<a name="ln3644">char *file_pat_to_reg_pat(const char *pat, const char *pat_end, char *allow_dirs, int no_bslash)</a>
<a name="ln3645">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3646">{</a>
<a name="ln3647">  if (allow_dirs != NULL) {</a>
<a name="ln3648">    *allow_dirs = false;</a>
<a name="ln3649">  }</a>
<a name="ln3650"> </a>
<a name="ln3651">  if (pat_end == NULL) {</a>
<a name="ln3652">    pat_end = pat + strlen(pat);</a>
<a name="ln3653">  }</a>
<a name="ln3654"> </a>
<a name="ln3655">  if (pat_end == pat) {</a>
<a name="ln3656">    return xstrdup(&quot;^$&quot;);</a>
<a name="ln3657">  }</a>
<a name="ln3658"> </a>
<a name="ln3659">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln3660"> </a>
<a name="ln3661">  for (const char *p = pat; p &lt; pat_end; p++) {</a>
<a name="ln3662">    switch (*p) {</a>
<a name="ln3663">    case '*':</a>
<a name="ln3664">    case '.':</a>
<a name="ln3665">    case ',':</a>
<a name="ln3666">    case '{':</a>
<a name="ln3667">    case '}':</a>
<a name="ln3668">    case '~':</a>
<a name="ln3669">      size += 2;                // extra backslash</a>
<a name="ln3670">      break;</a>
<a name="ln3671">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3672">    case '\\':</a>
<a name="ln3673">    case '/':</a>
<a name="ln3674">      size += 4;                // could become &quot;[\/]&quot;</a>
<a name="ln3675">      break;</a>
<a name="ln3676">#endif</a>
<a name="ln3677">    default:</a>
<a name="ln3678">      size++;</a>
<a name="ln3679">      break;</a>
<a name="ln3680">    }</a>
<a name="ln3681">  }</a>
<a name="ln3682">  char *reg_pat = xmalloc(size + 1);</a>
<a name="ln3683"> </a>
<a name="ln3684">  size_t i = 0;</a>
<a name="ln3685"> </a>
<a name="ln3686">  if (pat[0] == '*') {</a>
<a name="ln3687">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1) {</a>
<a name="ln3688">      pat++;</a>
<a name="ln3689">    }</a>
<a name="ln3690">  } else {</a>
<a name="ln3691">    reg_pat[i++] = '^';</a>
<a name="ln3692">  }</a>
<a name="ln3693">  const char *endp = pat_end - 1;</a>
<a name="ln3694">  bool add_dollar = true;</a>
<a name="ln3695">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln3696">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln3697">      endp--;</a>
<a name="ln3698">    }</a>
<a name="ln3699">    add_dollar = false;</a>
<a name="ln3700">  }</a>
<a name="ln3701">  int nested = 0;</a>
<a name="ln3702">  for (const char *p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln3703">    switch (*p) {</a>
<a name="ln3704">    case '*':</a>
<a name="ln3705">      reg_pat[i++] = '.';</a>
<a name="ln3706">      reg_pat[i++] = '*';</a>
<a name="ln3707">      while (p[1] == '*') {  // &quot;**&quot; matches like &quot;*&quot;</a>
<a name="ln3708">        p++;</a>
<a name="ln3709">      }</a>
<a name="ln3710">      break;</a>
<a name="ln3711">    case '.':</a>
<a name="ln3712">    case '~':</a>
<a name="ln3713">      reg_pat[i++] = '\\';</a>
<a name="ln3714">      reg_pat[i++] = *p;</a>
<a name="ln3715">      break;</a>
<a name="ln3716">    case '?':</a>
<a name="ln3717">      reg_pat[i++] = '.';</a>
<a name="ln3718">      break;</a>
<a name="ln3719">    case '\\':</a>
<a name="ln3720">      if (p[1] == NUL) {</a>
<a name="ln3721">        break;</a>
<a name="ln3722">      }</a>
<a name="ln3723">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3724">      if (!no_bslash) {</a>
<a name="ln3725">        // translate:</a>
<a name="ln3726">        // &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln3727">        // &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln3728">        // &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln3729">        // &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln3730">        if ((vim_isfilec((uint8_t)p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln3731">            &amp;&amp; p[1] != '+') {</a>
<a name="ln3732">          reg_pat[i++] = '[';</a>
<a name="ln3733">          reg_pat[i++] = '\\';</a>
<a name="ln3734">          reg_pat[i++] = '/';</a>
<a name="ln3735">          reg_pat[i++] = ']';</a>
<a name="ln3736">          if (allow_dirs != NULL) {</a>
<a name="ln3737">            *allow_dirs = true;</a>
<a name="ln3738">          }</a>
<a name="ln3739">          break;</a>
<a name="ln3740">        }</a>
<a name="ln3741">      }</a>
<a name="ln3742">#endif</a>
<a name="ln3743">      // Undo escaping from ExpandEscape():</a>
<a name="ln3744">      // foo\?bar -&gt; foo?bar</a>
<a name="ln3745">      // foo\%bar -&gt; foo%bar</a>
<a name="ln3746">      // foo\,bar -&gt; foo,bar</a>
<a name="ln3747">      // foo\ bar -&gt; foo bar</a>
<a name="ln3748">      // Don't unescape \, * and others that are also special in a</a>
<a name="ln3749">      // regexp.</a>
<a name="ln3750">      // An escaped { must be unescaped since we use magic not</a>
<a name="ln3751">      // verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln3752">      if (*++p == '?' &amp;&amp; (!BACKSLASH_IN_FILENAME_BOOL || no_bslash)) {</a>
<a name="ln3753">        reg_pat[i++] = '?';</a>
<a name="ln3754">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln3755">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln3756">        reg_pat[i++] = *p;</a>
<a name="ln3757">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln3758">        reg_pat[i++] = '\\';</a>
<a name="ln3759">        reg_pat[i++] = '{';</a>
<a name="ln3760">        p += 2;</a>
<a name="ln3761">      } else {</a>
<a name="ln3762">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln3763">            &amp;&amp; (!BACKSLASH_IN_FILENAME_BOOL || (!no_bslash || *p != '\\'))) {</a>
<a name="ln3764">          *allow_dirs = true;</a>
<a name="ln3765">        }</a>
<a name="ln3766">        reg_pat[i++] = '\\';</a>
<a name="ln3767">        reg_pat[i++] = *p;</a>
<a name="ln3768">      }</a>
<a name="ln3769">      break;</a>
<a name="ln3770">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3771">    case '/':</a>
<a name="ln3772">      reg_pat[i++] = '[';</a>
<a name="ln3773">      reg_pat[i++] = '\\';</a>
<a name="ln3774">      reg_pat[i++] = '/';</a>
<a name="ln3775">      reg_pat[i++] = ']';</a>
<a name="ln3776">      if (allow_dirs != NULL) {</a>
<a name="ln3777">        *allow_dirs = true;</a>
<a name="ln3778">      }</a>
<a name="ln3779">      break;</a>
<a name="ln3780">#endif</a>
<a name="ln3781">    case '{':</a>
<a name="ln3782">      reg_pat[i++] = '\\';</a>
<a name="ln3783">      reg_pat[i++] = '(';</a>
<a name="ln3784">      nested++;</a>
<a name="ln3785">      break;</a>
<a name="ln3786">    case '}':</a>
<a name="ln3787">      reg_pat[i++] = '\\';</a>
<a name="ln3788">      reg_pat[i++] = ')';</a>
<a name="ln3789">      nested--;</a>
<a name="ln3790">      break;</a>
<a name="ln3791">    case ',':</a>
<a name="ln3792">      if (nested) {</a>
<a name="ln3793">        reg_pat[i++] = '\\';</a>
<a name="ln3794">        reg_pat[i++] = '|';</a>
<a name="ln3795">      } else {</a>
<a name="ln3796">        reg_pat[i++] = ',';</a>
<a name="ln3797">      }</a>
<a name="ln3798">      break;</a>
<a name="ln3799">    default:</a>
<a name="ln3800">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln3801">        *allow_dirs = true;</a>
<a name="ln3802">      }</a>
<a name="ln3803">      reg_pat[i++] = *p;</a>
<a name="ln3804">      break;</a>
<a name="ln3805">    }</a>
<a name="ln3806">  }</a>
<a name="ln3807">  if (add_dollar) {</a>
<a name="ln3808">    reg_pat[i++] = '$';</a>
<a name="ln3809">  }</a>
<a name="ln3810">  reg_pat[i] = NUL;</a>
<a name="ln3811">  if (nested != 0) {</a>
<a name="ln3812">    if (nested &lt; 0) {</a>
<a name="ln3813">      emsg(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln3814">    } else {</a>
<a name="ln3815">      emsg(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln3816">    }</a>
<a name="ln3817">    XFREE_CLEAR(reg_pat);</a>
<a name="ln3818">  }</a>
<a name="ln3819">  return reg_pat;</a>
<a name="ln3820">}</a>
<a name="ln3821"> </a>
<a name="ln3822">#if defined(EINTR)</a>
<a name="ln3823"> </a>
<a name="ln3824">/// Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln3825">/// by a SIGWINCH).</a>
<a name="ln3826">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln3827">{</a>
<a name="ln3828">  long ret;</a>
<a name="ln3829"> </a>
<a name="ln3830">  while (true) {</a>
<a name="ln3831">    ret = read(fd, buf, (unsigned)bufsize);</a>
<a name="ln3832">    if (ret &gt;= 0 || errno != EINTR) {</a>
<a name="ln3833">      break;</a>
<a name="ln3834">    }</a>
<a name="ln3835">  }</a>
<a name="ln3836">  return ret;</a>
<a name="ln3837">}</a>
<a name="ln3838"> </a>
<a name="ln3839">/// Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln3840">/// by a SIGWINCH).</a>
<a name="ln3841">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln3842">{</a>
<a name="ln3843">  long ret = 0;</a>
<a name="ln3844"> </a>
<a name="ln3845">  // Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln3846">  // by a signal.</a>
<a name="ln3847">  while (ret &lt; (long)bufsize) {</a>
<a name="ln3848">    long wlen = write(fd, (char *)buf + ret, (unsigned)(bufsize - (size_t)ret));</a>
<a name="ln3849">    if (wlen &lt; 0) {</a>
<a name="ln3850">      if (errno != EINTR) {</a>
<a name="ln3851">        break;</a>
<a name="ln3852">      }</a>
<a name="ln3853">    } else {</a>
<a name="ln3854">      ret += wlen;</a>
<a name="ln3855">    }</a>
<a name="ln3856">  }</a>
<a name="ln3857">  return ret;</a>
<a name="ln3858">}</a>
<a name="ln3859">#endif</a>
</code></pre>
<div class="balloon" rel="3335"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen(tmp) - strlen(user)' index could reach 18446744073709551615.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>