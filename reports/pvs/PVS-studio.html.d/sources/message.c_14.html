<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// message.c: functions for displaying messages on the command line</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/channel.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/event/defs.h&quot;</a>
<a name="ln25">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln26">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln28">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln29">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln30">#include &quot;nvim/garray.h&quot;</a>
<a name="ln31">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln32">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln33">#include &quot;nvim/globals.h&quot;</a>
<a name="ln34">#include &quot;nvim/grid.h&quot;</a>
<a name="ln35">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln36">#include &quot;nvim/indent.h&quot;</a>
<a name="ln37">#include &quot;nvim/input.h&quot;</a>
<a name="ln38">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln39">#include &quot;nvim/log.h&quot;</a>
<a name="ln40">#include &quot;nvim/main.h&quot;</a>
<a name="ln41">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln42">#include &quot;nvim/memory.h&quot;</a>
<a name="ln43">#include &quot;nvim/message.h&quot;</a>
<a name="ln44">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln45">#include &quot;nvim/ops.h&quot;</a>
<a name="ln46">#include &quot;nvim/option.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln49">#include &quot;nvim/pos.h&quot;</a>
<a name="ln50">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln51">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln52">#include &quot;nvim/strings.h&quot;</a>
<a name="ln53">#include &quot;nvim/ui.h&quot;</a>
<a name="ln54">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln55">#include &quot;nvim/vim.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">// To be able to scroll back at the &quot;more&quot; and &quot;hit-enter&quot; prompts we need to</a>
<a name="ln58">// store the displayed text and remember where screen lines start.</a>
<a name="ln59">typedef struct msgchunk_S msgchunk_T;</a>
<a name="ln60">struct msgchunk_S {</a>
<a name="ln61">  msgchunk_T *sb_next;</a>
<a name="ln62">  msgchunk_T *sb_prev;</a>
<a name="ln63">  char sb_eol;                  // true when line ends after this text</a>
<a name="ln64">  int sb_msg_col;               // column in which text starts</a>
<a name="ln65">  int sb_attr;                  // text attributes</a>
<a name="ln66">  char sb_text[];               // text to be displayed</a>
<a name="ln67">};</a>
<a name="ln68"> </a>
<a name="ln69">// Magic chars used in confirm dialog strings</a>
<a name="ln70">enum {</a>
<a name="ln71">  DLG_BUTTON_SEP = '\n',</a>
<a name="ln72">  DLG_HOTKEY_CHAR = '&amp;',</a>
<a name="ln73">};</a>
<a name="ln74"> </a>
<a name="ln75">static int confirm_msg_used = false;            // displaying confirm_msg</a>
<a name="ln76">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln77"># include &quot;message.c.generated.h&quot;</a>
<a name="ln78">#endif</a>
<a name="ln79">static char *confirm_msg = NULL;            // &quot;:confirm&quot; message</a>
<a name="ln80">static char *confirm_msg_tail;              // tail of confirm_msg</a>
<a name="ln81"> </a>
<a name="ln82">MessageHistoryEntry *first_msg_hist = NULL;</a>
<a name="ln83">MessageHistoryEntry *last_msg_hist = NULL;</a>
<a name="ln84">static int msg_hist_len = 0;</a>
<a name="ln85"> </a>
<a name="ln86">static FILE *verbose_fd = NULL;</a>
<a name="ln87">static int verbose_did_open = false;</a>
<a name="ln88"> </a>
<a name="ln89">bool keep_msg_more = false;    // keep_msg was set by msgmore()</a>
<a name="ln90"> </a>
<a name="ln91">// When writing messages to the screen, there are many different situations.</a>
<a name="ln92">// A number of variables is used to remember the current state:</a>
<a name="ln93">// msg_didany       true when messages were written since the last time the</a>
<a name="ln94">//                  user reacted to a prompt.</a>
<a name="ln95">//                  Reset: After hitting a key for the hit-return prompt,</a>
<a name="ln96">//                  hitting &lt;CR&gt; for the command line or input().</a>
<a name="ln97">//                  Set: When any message is written to the screen.</a>
<a name="ln98">// msg_didout       true when something was written to the current line.</a>
<a name="ln99">//                  Reset: When advancing to the next line, when the current</a>
<a name="ln100">//                  text can be overwritten.</a>
<a name="ln101">//                  Set: When any message is written to the screen.</a>
<a name="ln102">// msg_nowait       No extra delay for the last drawn message.</a>
<a name="ln103">//                  Used in normal_cmd() before the mode message is drawn.</a>
<a name="ln104">// emsg_on_display  There was an error message recently.  Indicates that there</a>
<a name="ln105">//                  should be a delay before redrawing.</a>
<a name="ln106">// msg_scroll       The next message should not overwrite the current one.</a>
<a name="ln107">// msg_scrolled     How many lines the screen has been scrolled (because of</a>
<a name="ln108">//                  messages).  Used in update_screen() to scroll the screen</a>
<a name="ln109">//                  back.  Incremented each time the screen scrolls a line.</a>
<a name="ln110">// msg_scrolled_ign  true when msg_scrolled is non-zero and msg_puts_attr()</a>
<a name="ln111">//                  writes something without scrolling should not make</a>
<a name="ln112">//                  need_wait_return to be set.  This is a hack to make &quot;:ts&quot;</a>
<a name="ln113">//                  work without an extra prompt.</a>
<a name="ln114">// lines_left       Number of lines available for messages before the</a>
<a name="ln115">//                  more-prompt is to be given.  -1 when not set.</a>
<a name="ln116">// need_wait_return true when the hit-return prompt is needed.</a>
<a name="ln117">//                  Reset: After giving the hit-return prompt, when the user</a>
<a name="ln118">//                  has answered some other prompt.</a>
<a name="ln119">//                  Set: When the ruler or typeahead display is overwritten,</a>
<a name="ln120">//                  scrolling the screen for some message.</a>
<a name="ln121">// keep_msg         Message to be displayed after redrawing the screen, in</a>
<a name="ln122">//                  main_loop().</a>
<a name="ln123">//                  This is an allocated string or NULL when not used.</a>
<a name="ln124"> </a>
<a name="ln125">// Extended msg state, currently used for external UIs with ext_messages</a>
<a name="ln126">static const char *msg_ext_kind = NULL;</a>
<a name="ln127">static Array msg_ext_chunks = ARRAY_DICT_INIT;</a>
<a name="ln128">static garray_T msg_ext_last_chunk = GA_INIT(sizeof(char), 40);</a>
<a name="ln129">static sattr_T msg_ext_last_attr = -1;</a>
<a name="ln130">static size_t msg_ext_cur_len = 0;</a>
<a name="ln131"> </a>
<a name="ln132">static bool msg_ext_overwrite = false;  ///&lt; will overwrite last message</a>
<a name="ln133">static int msg_ext_visible = 0;  ///&lt; number of messages currently visible</a>
<a name="ln134"> </a>
<a name="ln135">static bool msg_ext_history_visible = false;</a>
<a name="ln136"> </a>
<a name="ln137">/// Shouldn't clear message after leaving cmdline</a>
<a name="ln138">static bool msg_ext_keep_after_cmdline = false;</a>
<a name="ln139"> </a>
<a name="ln140">static int msg_grid_pos_at_flush = 0;</a>
<a name="ln141"> </a>
<a name="ln142">static void ui_ext_msg_set_pos(int row, bool scrolled)</a>
<a name="ln143">{</a>
<a name="ln144">  char buf[MAX_MCO + 1];</a>
<a name="ln145">  size_t size = (size_t)utf_char2bytes(curwin-&gt;w_p_fcs_chars.msgsep, buf);</a>
<a name="ln146">  buf[size] = '\0';</a>
<a name="ln147">  ui_call_msg_set_pos(msg_grid.handle, row, scrolled,</a>
<a name="ln148">                      (String){ .data = buf, .size = size });</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">void msg_grid_set_pos(int row, bool scrolled)</a>
<a name="ln152">{</a>
<a name="ln153">  if (!msg_grid.throttled) {</a>
<a name="ln154">    ui_ext_msg_set_pos(row, scrolled);</a>
<a name="ln155">    msg_grid_pos_at_flush = row;</a>
<a name="ln156">  }</a>
<a name="ln157">  msg_grid_pos = row;</a>
<a name="ln158">  if (msg_grid.chars) {</a>
<a name="ln159">    msg_grid_adj.row_offset = -row;</a>
<a name="ln160">  }</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">bool msg_use_grid(void)</a>
<a name="ln164">{</a>
<a name="ln165">  return default_grid.chars &amp;&amp; !ui_has(kUIMessages);</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">void msg_grid_validate(void)</a>
<a name="ln169">{</a>
<a name="ln170">  grid_assign_handle(&amp;msg_grid);</a>
<a name="ln171">  bool should_alloc = msg_use_grid();</a>
<a name="ln172">  int max_rows = Rows - (int)p_ch;</a>
<a name="ln173">  if (should_alloc &amp;&amp; (msg_grid.rows != Rows || msg_grid.cols != Columns</a>
<a name="ln174">                       || !msg_grid.chars)) {</a>
<a name="ln175">    // TODO(bfredl): eventually should be set to &quot;invalid&quot;. I e all callers</a>
<a name="ln176">    // will use the grid including clear to EOS if necessary.</a>
<a name="ln177">    grid_alloc(&amp;msg_grid, Rows, Columns, false, true);</a>
<a name="ln178">    msg_grid.zindex = kZIndexMessages;</a>
<a name="ln179"> </a>
<a name="ln180">    xfree(msg_grid.dirty_col);</a>
<a name="ln181">    msg_grid.dirty_col = xcalloc((size_t)Rows, sizeof(*msg_grid.dirty_col));</a>
<a name="ln182"> </a>
<a name="ln183">    // Tricky: allow resize while pager or ex mode is active</a>
<a name="ln184">    int pos = (State &amp; MODE_ASKMORE) ? 0 : MAX(max_rows - msg_scrolled, 0);</a>
<a name="ln185">    msg_grid.throttled = false;  // don't throttle in 'cmdheight' area</a>
<a name="ln186">    msg_grid_set_pos(pos, msg_scrolled);</a>
<a name="ln187">    ui_comp_put_grid(&amp;msg_grid, pos, 0, msg_grid.rows, msg_grid.cols,</a>
<a name="ln188">                     false, true);</a>
<a name="ln189">    ui_call_grid_resize(msg_grid.handle, msg_grid.cols, msg_grid.rows);</a>
<a name="ln190"> </a>
<a name="ln191">    msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln192">    msg_grid.focusable = false;</a>
<a name="ln193">    msg_grid_adj.target = &amp;msg_grid;</a>
<a name="ln194">  } else if (!should_alloc &amp;&amp; msg_grid.chars) {</a>
<a name="ln195">    ui_comp_remove_grid(&amp;msg_grid);</a>
<a name="ln196">    grid_free(&amp;msg_grid);</a>
<a name="ln197">    XFREE_CLEAR(msg_grid.dirty_col);</a>
<a name="ln198">    ui_call_grid_destroy(msg_grid.handle);</a>
<a name="ln199">    msg_grid.throttled = false;</a>
<a name="ln200">    msg_grid_adj.row_offset = 0;</a>
<a name="ln201">    msg_grid_adj.target = &amp;default_grid;</a>
<a name="ln202">    redraw_cmdline = true;</a>
<a name="ln203">  } else if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; msg_grid_pos != max_rows) {</a>
<a name="ln204">    msg_grid_set_pos(max_rows, false);</a>
<a name="ln205">  }</a>
<a name="ln206"> </a>
<a name="ln207">  if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; cmdline_row &lt; msg_grid_pos) {</a>
<a name="ln208">    // TODO(bfredl): this should already be the case, but fails in some</a>
<a name="ln209">    // &quot;batched&quot; executions where compute_cmdrow() use stale positions or</a>
<a name="ln210">    // something.</a>
<a name="ln211">    cmdline_row = msg_grid_pos;</a>
<a name="ln212">  }</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">/// Displays the string 's' on the status line</a>
<a name="ln216">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln217">///</a>
<a name="ln218">/// @return  true if wait_return() not called</a>
<a name="ln219">int msg(const char *s)</a>
<a name="ln220">{</a>
<a name="ln221">  return msg_attr_keep(s, 0, false, false);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">/// Like msg() but keep it silent when 'verbosefile' is set.</a>
<a name="ln225">int verb_msg(const char *s)</a>
<a name="ln226">{</a>
<a name="ln227">  verbose_enter();</a>
<a name="ln228">  int n = msg_attr_keep(s, 0, false, false);</a>
<a name="ln229">  verbose_leave();</a>
<a name="ln230"> </a>
<a name="ln231">  return n;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">int msg_attr(const char *s, const int attr)</a>
<a name="ln235">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln236">{</a>
<a name="ln237">  return msg_attr_keep(s, attr, false, false);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/// Similar to msg_outtrans_attr, but support newlines and tabs.</a>
<a name="ln241">void msg_multiline_attr(const char *s, int attr, bool check_int, bool *need_clear)</a>
<a name="ln242">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln243">{</a>
<a name="ln244">  const char *next_spec = s;</a>
<a name="ln245"> </a>
<a name="ln246">  while (next_spec != NULL) {</a>
<a name="ln247">    if (check_int &amp;&amp; got_int) {</a>
<a name="ln248">      return;</a>
<a name="ln249">    }</a>
<a name="ln250">    next_spec = strpbrk(s, &quot;\t\n\r&quot;);</a>
<a name="ln251"> </a>
<a name="ln252">    if (next_spec != NULL) {</a>
<a name="ln253">      // Printing all char that are before the char found by strpbrk</a>
<a name="ln254">      msg_outtrans_len_attr(s, (int)(next_spec - s), attr);</a>
<a name="ln255"> </a>
<a name="ln256">      if (*next_spec != TAB &amp;&amp; *need_clear) {</a>
<a name="ln257">        msg_clr_eos();</a>
<a name="ln258">        *need_clear = false;</a>
<a name="ln259">      }</a>
<a name="ln260">      msg_putchar_attr((uint8_t)(*next_spec), attr);</a>
<a name="ln261">      s = next_spec + 1;</a>
<a name="ln262">    }</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  // Print the rest of the message. We know there is no special</a>
<a name="ln266">  // character because strpbrk returned NULL</a>
<a name="ln267">  if (*s != NUL) {</a>
<a name="ln268">    msg_outtrans_attr(s, attr);</a>
<a name="ln269">  }</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">void msg_multiattr(HlMessage hl_msg, const char *kind, bool history)</a>
<a name="ln273">{</a>
<a name="ln274">  no_wait_return++;</a>
<a name="ln275">  msg_start();</a>
<a name="ln276">  msg_clr_eos();</a>
<a name="ln277">  bool need_clear = false;</a>
<a name="ln278">  msg_ext_set_kind(kind);</a>
<a name="ln279">  for (uint32_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln280">    HlMessageChunk chunk = kv_A(hl_msg, i);</a>
<a name="ln281">    msg_multiline_attr(chunk.text.data, chunk.attr, true, &amp;need_clear);</a>
<a name="ln282">  }</a>
<a name="ln283">  if (history &amp;&amp; kv_size(hl_msg)) {</a>
<a name="ln284">    add_msg_hist_multiattr(NULL, 0, 0, true, hl_msg);</a>
<a name="ln285">  }</a>
<a name="ln286">  no_wait_return--;</a>
<a name="ln287">  msg_end();</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/// @param keep set keep_msg if it doesn't scroll</a>
<a name="ln291">bool msg_attr_keep(const char *s, int attr, bool keep, bool multiline)</a>
<a name="ln292">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln293">{</a>
<a name="ln294">  static int entered = 0;</a>
<a name="ln295">  int retval;</a>
<a name="ln296">  char *buf = NULL;</a>
<a name="ln297"> </a>
<a name="ln298">  if (keep &amp;&amp; multiline) {</a>
<a name="ln299">    // Not implemented. 'multiline' is only used by nvim-added messages,</a>
<a name="ln300">    // which should avoid 'keep' behavior (just show the message at</a>
<a name="ln301">    // the correct time already).</a>
<a name="ln302">    abort();</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  // Skip messages not match &quot;:filter pattern&quot;.</a>
<a name="ln306">  // Don't filter when there is an error.</a>
<a name="ln307">  if (!emsg_on_display &amp;&amp; message_filtered(s)) {</a>
<a name="ln308">    return true;</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  if (attr == 0) {</a>
<a name="ln312">    set_vim_var_string(VV_STATUSMSG, s, -1);</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  // It is possible that displaying a messages causes a problem (e.g.,</a>
<a name="ln316">  // when redrawing the window), which causes another message, etc..    To</a>
<a name="ln317">  // break this loop, limit the recursiveness to 3 levels.</a>
<a name="ln318">  if (entered &gt;= 3) {</a>
<a name="ln319">    return true;</a>
<a name="ln320">  }</a>
<a name="ln321">  entered++;</a>
<a name="ln322"> </a>
<a name="ln323">  // Add message to history (unless it's a repeated kept message or a</a>
<a name="ln324">  // truncated message)</a>
<a name="ln325">  if (s != keep_msg</a>
<a name="ln326">      || (*s != '&lt;'</a>
<a name="ln327">          &amp;&amp; last_msg_hist != NULL</a>
<a name="ln328">          &amp;&amp; last_msg_hist-&gt;msg != NULL</a>
<a name="ln329">          &amp;&amp; strcmp(s, last_msg_hist-&gt;msg) != 0)) {</a>
<a name="ln330">    add_msg_hist(s, -1, attr, multiline);</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  // Truncate the message if needed.</a>
<a name="ln334">  msg_start();</a>
<a name="ln335">  buf = msg_strtrunc(s, false);</a>
<a name="ln336">  if (buf != NULL) {</a>
<a name="ln337">    s = buf;</a>
<a name="ln338">  }</a>
<a name="ln339"> </a>
<a name="ln340">  bool need_clear = true;</a>
<a name="ln341">  if (multiline) {</a>
<a name="ln342">    msg_multiline_attr(s, attr, false, &amp;need_clear);</a>
<a name="ln343">  } else {</a>
<a name="ln344">    msg_outtrans_attr(s, attr);</a>
<a name="ln345">  }</a>
<a name="ln346">  if (need_clear) {</a>
<a name="ln347">    msg_clr_eos();</a>
<a name="ln348">  }</a>
<a name="ln349">  retval = msg_end();</a>
<a name="ln350"> </a>
<a name="ln351">  if (keep &amp;&amp; retval &amp;&amp; vim_strsize(s) &lt; (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln352">    set_keep_msg(s, 0);</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  need_fileinfo = false;</a>
<a name="ln356"> </a>
<a name="ln357">  xfree(buf);</a>
<a name="ln358">  entered--;</a>
<a name="ln359">  return retval;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/// Truncate a string such that it can be printed without causing a scroll.</a>
<a name="ln363">///</a>
<a name="ln364">/// @return  an allocated string or NULL when no truncating is done.</a>
<a name="ln365">///</a>
<a name="ln366">/// @param force  always truncate</a>
<a name="ln367">char *msg_strtrunc(const char *s, int force)</a>
<a name="ln368">{</a>
<a name="ln369">  char *buf = NULL;</a>
<a name="ln370"> </a>
<a name="ln371">  // May truncate message to avoid a hit-return prompt</a>
<a name="ln372">  if ((!msg_scroll &amp;&amp; !need_wait_return &amp;&amp; shortmess(SHM_TRUNCALL)</a>
<a name="ln373">       &amp;&amp; !exmode_active &amp;&amp; msg_silent == 0 &amp;&amp; !ui_has(kUIMessages))</a>
<a name="ln374">      || force) {</a>
<a name="ln375">    int room;</a>
<a name="ln376">    int len = vim_strsize(s);</a>
<a name="ln377">    if (msg_scrolled != 0) {</a>
<a name="ln378">      // Use all the columns.</a>
<a name="ln379">      room = (Rows - msg_row) * Columns - 1;</a>
<a name="ln380">    } else {</a>
<a name="ln381">      // Use up to 'showcmd' column.</a>
<a name="ln382">      room = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln383">    }</a>
<a name="ln384">    if (len &gt; room &amp;&amp; room &gt; 0) {</a>
<a name="ln385">      // may have up to 18 bytes per cell (6 per char, up to two</a>
<a name="ln386">      // composing chars)</a>
<a name="ln387">      len = (room + 2) * 18;</a>
<a name="ln388">      buf = xmalloc((size_t)len);</a>
<a name="ln389">      trunc_string(s, buf, room, len);</a>
<a name="ln390">    }</a>
<a name="ln391">  }</a>
<a name="ln392">  return buf;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">/// Truncate a string &quot;s&quot; to &quot;buf&quot; with cell width &quot;room&quot;.</a>
<a name="ln396">/// &quot;s&quot; and &quot;buf&quot; may be equal.</a>
<a name="ln397">void trunc_string(const char *s, char *buf, int room_in, int buflen)</a>
<a name="ln398">{</a>
<a name="ln399">  int room = room_in - 3;  // &quot;...&quot; takes 3 chars</a>
<a name="ln400">  int half;</a>
<a name="ln401">  int len = 0;</a>
<a name="ln402">  int e;</a>
<a name="ln403">  int i;</a>
<a name="ln404">  int n;</a>
<a name="ln405"> </a>
<a name="ln406">  if (*s == NUL) {</a>
<a name="ln407">    if (buflen &gt; 0) {</a>
<a name="ln408">      *buf = NUL;</a>
<a name="ln409">    }</a>
<a name="ln410">    return;</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  if (room_in &lt; 3) {</a>
<a name="ln414">    room = 0;</a>
<a name="ln415">  }</a>
<a name="ln416">  half = room / 2;</a>
<a name="ln417"> </a>
<a name="ln418">  // First part: Start of the string.</a>
<a name="ln419">  for (e = 0; len &lt; half &amp;&amp; e &lt; buflen; e++) {</a>
<a name="ln420">    if (s[e] == NUL) {</a>
<a name="ln421">      // text fits without truncating!</a>
<a name="ln422">      buf[e] = NUL;</a>
<a name="ln423">      return;</a>
<a name="ln424">    }</a>
<a name="ln425">    n = ptr2cells(s + e);</a>
<a name="ln426">    if (len + n &gt; half) {</a>
<a name="ln427">      break;</a>
<a name="ln428">    }</a>
<a name="ln429">    len += n;</a>
<a name="ln430">    buf[e] = s[e];</a>
<a name="ln431">    for (n = utfc_ptr2len(s + e); --n &gt; 0;) {</a>
<a name="ln432">      if (++e == buflen) {</a>
<a name="ln433">        break;</a>
<a name="ln434">      }</a>
<a name="ln435">      buf[e] = s[e];</a>
<a name="ln436">    }</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  // Last part: End of the string.</a>
<a name="ln440">  half = i = (int)strlen(s);</a>
<a name="ln441">  while (true) {</a>
<a name="ln442">    do {</a>
<a name="ln443">      half = half - utf_head_off(s, s + half - 1) - 1;</a>
<a name="ln444">    } while (half &gt; 0 &amp;&amp; utf_iscomposing(utf_ptr2char(s + half)));</a>
<a name="ln445">    n = ptr2cells(s + half);</a>
<a name="ln446">    if (len + n &gt; room || half == 0) {</a>
<a name="ln447">      break;</a>
<a name="ln448">    }</a>
<a name="ln449">    len += n;</a>
<a name="ln450">    i = half;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">  if (i &lt;= e + 3) {</a>
<a name="ln454">    // text fits without truncating</a>
<a name="ln455">    if (s != buf) {</a>
<a name="ln456">      len = (int)strlen(s);</a>
<a name="ln457">      if (len &gt;= buflen) {</a>
<a name="ln458">        len = buflen - 1;</a>
<a name="ln459">      }</a>
<a name="ln460">      len = len - e + 1;</a>
<a name="ln461">      if (len &lt; 1) {</a>
<a name="ln462">        buf[e - 1] = NUL;</a>
<a name="ln463">      } else {</a>
<a name="ln464">        memmove(buf + e, s + e, (size_t)len);</a>
<a name="ln465">      }</a>
<a name="ln466">    }</a>
<a name="ln467">  } else if (e + 3 &lt; buflen) {</a>
<a name="ln468">    // set the middle and copy the last part</a>
<a name="ln469">    memmove(buf + e, &quot;...&quot;, (size_t)3);</a>
<a name="ln470">    len = (int)strlen(s + i) + 1;</a>
<a name="ln471">    if (len &gt;= buflen - e - 3) {</a>
<a name="ln472">      len = buflen - e - 3 - 1;</a>
<a name="ln473">    }</a>
<a name="ln474">    memmove(buf + e + 3, s + i, (size_t)len);</a>
<a name="ln475">    buf[e + 3 + len - 1] = NUL;</a>
<a name="ln476">  } else {</a>
<a name="ln477">    // can't fit in the &quot;...&quot;, just truncate it</a>
<a name="ln478">    buf[e - 1] = NUL;</a>
<a name="ln479">  }</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">// Note: Caller of smsg() and smsg_attr() must check the resulting string is</a>
<a name="ln483">// shorter than IOSIZE!!!</a>
<a name="ln484"> </a>
<a name="ln485">int smsg(const char *s, ...)</a>
<a name="ln486">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln487">{</a>
<a name="ln488">  va_list arglist;</a>
<a name="ln489"> </a>
<a name="ln490">  va_start(arglist, s);</a>
<a name="ln491">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln492">  va_end(arglist);</a>
<a name="ln493"> </a>
<a name="ln494">  return msg(IObuff);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">int smsg_attr(int attr, const char *s, ...)</a>
<a name="ln498">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln499">{</a>
<a name="ln500">  va_list arglist;</a>
<a name="ln501"> </a>
<a name="ln502">  va_start(arglist, s);</a>
<a name="ln503">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln504">  va_end(arglist);</a>
<a name="ln505">  return msg_attr(IObuff, attr);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">int smsg_attr_keep(int attr, const char *s, ...)</a>
<a name="ln509">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln510">{</a>
<a name="ln511">  va_list arglist;</a>
<a name="ln512"> </a>
<a name="ln513">  va_start(arglist, s);</a>
<a name="ln514">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln515">  va_end(arglist);</a>
<a name="ln516">  return msg_attr_keep(IObuff, attr, true, false);</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">// Remember the last sourcing name/lnum used in an error message, so that it</a>
<a name="ln520">// isn't printed each time when it didn't change.</a>
<a name="ln521">static int last_sourcing_lnum = 0;</a>
<a name="ln522">static char *last_sourcing_name = NULL;</a>
<a name="ln523"> </a>
<a name="ln524">/// Reset the last used sourcing name/lnum.  Makes sure it is displayed again</a>
<a name="ln525">/// for the next error message;</a>
<a name="ln526">void reset_last_sourcing(void)</a>
<a name="ln527">{</a>
<a name="ln528">  XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln529">  last_sourcing_lnum = 0;</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">/// @return  true if &quot;SOURCING_NAME&quot; differs from &quot;last_sourcing_name&quot;.</a>
<a name="ln533">static bool other_sourcing_name(void)</a>
<a name="ln534">{</a>
<a name="ln535">  if (SOURCING_NAME != NULL) {</a>
<a name="ln536">    if (last_sourcing_name != NULL) {</a>
<a name="ln537">      return strcmp(SOURCING_NAME, last_sourcing_name) != 0;</a>
<a name="ln538">    }</a>
<a name="ln539">    return true;</a>
<a name="ln540">  }</a>
<a name="ln541">  return false;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">/// Get the message about the source, as used for an error message</a>
<a name="ln545">///</a>
<a name="ln546">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln547">///                     message is to be given.</a>
<a name="ln548">static char *get_emsg_source(void)</a>
<a name="ln549">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln550">{</a>
<a name="ln551">  if (SOURCING_NAME != NULL &amp;&amp; other_sourcing_name()) {</a>
<a name="ln552">    char *sname = estack_sfile(ESTACK_NONE);</a>
<a name="ln553">    char *tofree = sname;</a>
<a name="ln554"> </a>
<a name="ln555">    if (sname == NULL) {</a>
<a name="ln556">      sname = SOURCING_NAME;</a>
<a name="ln557">    }</a>
<a name="ln558"> </a>
<a name="ln559">    const char *const p = _(&quot;Error detected while processing %s:&quot;);</a>
<a name="ln560">    const size_t buf_len = strlen(sname) + strlen(p) + 1;</a>
<a name="ln561">    char *const buf = xmalloc(buf_len);</a>
<a name="ln562">    snprintf(buf, buf_len, p, sname);</a>
<a name="ln563">    xfree(tofree);</a>
<a name="ln564">    return buf;</a>
<a name="ln565">  }</a>
<a name="ln566">  return NULL;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">/// Get the message about the source lnum, as used for an error message.</a>
<a name="ln570">///</a>
<a name="ln571">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln572">///                     message is to be given.</a>
<a name="ln573">static char *get_emsg_lnum(void)</a>
<a name="ln574">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln575">{</a>
<a name="ln576">  // lnum is 0 when executing a command from the command line</a>
<a name="ln577">  // argument, we don't want a line number then</a>
<a name="ln578">  if (SOURCING_NAME != NULL</a>
<a name="ln579">      &amp;&amp; (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)</a>
<a name="ln580">      &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln581">    const char *const p = _(&quot;line %4ld:&quot;);</a>
<a name="ln582">    const size_t buf_len = 20 + strlen(p);</a>
<a name="ln583">    char *const buf = xmalloc(buf_len);</a>
<a name="ln584">    snprintf(buf, buf_len, p, (long)SOURCING_LNUM);</a>
<a name="ln585">    return buf;</a>
<a name="ln586">  }</a>
<a name="ln587">  return NULL;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">/// Display name and line number for the source of an error.</a>
<a name="ln591">/// Remember the file name and line number, so that for the next error the info</a>
<a name="ln592">/// is only displayed if it changed.</a>
<a name="ln593">void msg_source(int attr)</a>
<a name="ln594">{</a>
<a name="ln595">  static bool recursive = false;</a>
<a name="ln596"> </a>
<a name="ln597">  // Bail out if something called here causes an error.</a>
<a name="ln598">  if (recursive) {</a>
<a name="ln599">    return;</a>
<a name="ln600">  }</a>
<a name="ln601">  recursive = true;</a>
<a name="ln602"> </a>
<a name="ln603">  no_wait_return++;</a>
<a name="ln604">  char *p = get_emsg_source();</a>
<a name="ln605">  if (p != NULL) {</a>
<a name="ln606">    msg_scroll = true;  // this will take more than one line</a>
<a name="ln607">    msg_attr(p, attr);</a>
<a name="ln608">    xfree(p);</a>
<a name="ln609">  }</a>
<a name="ln610">  p = get_emsg_lnum();</a>
<a name="ln611">  if (p != NULL) {</a>
<a name="ln612">    msg_attr(p, HL_ATTR(HLF_N));</a>
<a name="ln613">    xfree(p);</a>
<a name="ln614">    last_sourcing_lnum = SOURCING_LNUM;      // only once for each line</a>
<a name="ln615">  }</a>
<a name="ln616"> </a>
<a name="ln617">  // remember the last sourcing name printed, also when it's empty</a>
<a name="ln618">  if (SOURCING_NAME == NULL || other_sourcing_name()) {</a>
<a name="ln619">    XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln620">    if (SOURCING_NAME != NULL) {</a>
<a name="ln621">      last_sourcing_name = xstrdup(SOURCING_NAME);</a>
<a name="ln622">    }</a>
<a name="ln623">  }</a>
<a name="ln624">  no_wait_return--;</a>
<a name="ln625"> </a>
<a name="ln626">  recursive = false;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">/// @return  true if not giving error messages right now:</a>
<a name="ln630">///            If &quot;emsg_off&quot; is set: no error messages at the moment.</a>
<a name="ln631">///            If &quot;msg&quot; is in 'debug': do error message but without side effects.</a>
<a name="ln632">///            If &quot;emsg_skip&quot; is set: never do error messages.</a>
<a name="ln633">int emsg_not_now(void)</a>
<a name="ln634">{</a>
<a name="ln635">  if ((emsg_off &gt; 0 &amp;&amp; vim_strchr(p_debug, 'm') == NULL</a>
<a name="ln636">       &amp;&amp; vim_strchr(p_debug, 't') == NULL)</a>
<a name="ln637">      || emsg_skip &gt; 0) {</a>
<a name="ln638">    return true;</a>
<a name="ln639">  }</a>
<a name="ln640">  return false;</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">static bool emsg_multiline(const char *s, bool multiline)</a>
<a name="ln644">{</a>
<a name="ln645">  int attr;</a>
<a name="ln646">  bool ignore = false;</a>
<a name="ln647"> </a>
<a name="ln648">  // Skip this if not giving error messages at the moment.</a>
<a name="ln649">  if (emsg_not_now()) {</a>
<a name="ln650">    return true;</a>
<a name="ln651">  }</a>
<a name="ln652"> </a>
<a name="ln653">  called_emsg++;</a>
<a name="ln654"> </a>
<a name="ln655">  // If &quot;emsg_severe&quot; is true: When an error exception is to be thrown,</a>
<a name="ln656">  // prefer this message over previous messages for the same command.</a>
<a name="ln657">  bool severe = emsg_severe;</a>
<a name="ln658">  emsg_severe = false;</a>
<a name="ln659"> </a>
<a name="ln660">  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {</a>
<a name="ln661">    // Cause a throw of an error exception if appropriate.  Don't display</a>
<a name="ln662">    // the error message in this case.  (If no matching catch clause will</a>
<a name="ln663">    // be found, the message will be displayed later on.)  &quot;ignore&quot; is set</a>
<a name="ln664">    // when the message should be ignored completely (used for the</a>
<a name="ln665">    // interrupt message).</a>
<a name="ln666">    if (cause_errthrow(s, severe, &amp;ignore)) {</a>
<a name="ln667">      if (!ignore) {</a>
<a name="ln668">        did_emsg++;</a>
<a name="ln669">      }</a>
<a name="ln670">      return true;</a>
<a name="ln671">    }</a>
<a name="ln672"> </a>
<a name="ln673">    if (in_assert_fails &amp;&amp; emsg_assert_fails_msg == NULL) {</a>
<a name="ln674">      emsg_assert_fails_msg = xstrdup(s);</a>
<a name="ln675">      emsg_assert_fails_lnum = SOURCING_LNUM;</a>
<a name="ln676">      xfree(emsg_assert_fails_context);</a>
<a name="ln677">      emsg_assert_fails_context = xstrdup(SOURCING_NAME == NULL ? &quot;&quot; : SOURCING_NAME);</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    // set &quot;v:errmsg&quot;, also when using &quot;:silent! cmd&quot;</a>
<a name="ln681">    set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln682"> </a>
<a name="ln683">    // When using &quot;:silent! cmd&quot; ignore error messages.</a>
<a name="ln684">    // But do write it to the redirection file.</a>
<a name="ln685">    if (emsg_silent != 0) {</a>
<a name="ln686">      if (!emsg_noredir) {</a>
<a name="ln687">        msg_start();</a>
<a name="ln688">        char *p = get_emsg_source();</a>
<a name="ln689">        if (p != NULL) {</a>
<a name="ln690">          const size_t p_len = strlen(p);</a>
<a name="ln691">          p[p_len] = '\n';</a>
<a name="ln692">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln693">          xfree(p);</a>
<a name="ln694">        }</a>
<a name="ln695">        p = get_emsg_lnum();</a>
<a name="ln696">        if (p != NULL) {</a>
<a name="ln697">          const size_t p_len = strlen(p);</a>
<a name="ln698">          p[p_len] = '\n';</a>
<a name="ln699">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln700">          xfree(p);</a>
<a name="ln701">        }</a>
<a name="ln702">        redir_write(s, (ptrdiff_t)strlen(s));</a>
<a name="ln703">      }</a>
<a name="ln704"> </a>
<a name="ln705">      // Log (silent) errors as debug messages.</a>
<a name="ln706">      if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln707">        DLOG(&quot;(:silent) %s (%s (line %ld))&quot;,</a>
<a name="ln708">             s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln709">      } else {</a>
<a name="ln710">        DLOG(&quot;(:silent) %s&quot;, s);</a>
<a name="ln711">      }</a>
<a name="ln712"> </a>
<a name="ln713">      return true;</a>
<a name="ln714">    }</a>
<a name="ln715"> </a>
<a name="ln716">    // Log editor errors as INFO.</a>
<a name="ln717">    if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln718">      ILOG(&quot;%s (%s (line %ld))&quot;, s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln719">    } else {</a>
<a name="ln720">      ILOG(&quot;%s&quot;, s);</a>
<a name="ln721">    }</a>
<a name="ln722"> </a>
<a name="ln723">    ex_exitval = 1;</a>
<a name="ln724"> </a>
<a name="ln725">    // Reset msg_silent, an error causes messages to be switched back on.</a>
<a name="ln726">    msg_silent = 0;</a>
<a name="ln727">    cmd_silent = false;</a>
<a name="ln728"> </a>
<a name="ln729">    if (global_busy) {        // break :global command</a>
<a name="ln730">      global_busy++;</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">    if (p_eb) {</a>
<a name="ln734">      beep_flush();           // also includes flush_buffers()</a>
<a name="ln735">    } else {</a>
<a name="ln736">      flush_buffers(FLUSH_MINIMAL);  // flush internal buffers</a>
<a name="ln737">    }</a>
<a name="ln738">    did_emsg++;               // flag for DoOneCmd()</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  emsg_on_display = true;     // remember there is an error message</a>
<a name="ln742">  attr = HL_ATTR(HLF_E);      // set highlight mode for error messages</a>
<a name="ln743">  if (msg_scrolled != 0) {</a>
<a name="ln744">    need_wait_return = true;  // needed in case emsg() is called after</a>
<a name="ln745">  }                           // wait_return() has reset need_wait_return</a>
<a name="ln746">                              // and a redraw is expected because</a>
<a name="ln747">                              // msg_scrolled is non-zero</a>
<a name="ln748">  if (msg_ext_kind == NULL) {</a>
<a name="ln749">    msg_ext_set_kind(&quot;emsg&quot;);</a>
<a name="ln750">  }</a>
<a name="ln751"> </a>
<a name="ln752">  // Display name and line number for the source of the error.</a>
<a name="ln753">  msg_scroll = true;</a>
<a name="ln754">  msg_source(attr);</a>
<a name="ln755"> </a>
<a name="ln756">  // Display the error message itself.</a>
<a name="ln757">  msg_nowait = false;  // Wait for this msg.</a>
<a name="ln758">  return msg_attr_keep(s, attr, false, multiline);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/// emsg() - display an error message</a>
<a name="ln762">///</a>
<a name="ln763">/// Rings the bell, if appropriate, and calls message() to do the real work</a>
<a name="ln764">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln765">///</a>
<a name="ln766">/// @return true if wait_return() not called</a>
<a name="ln767">bool emsg(const char *s)</a>
<a name="ln768">{</a>
<a name="ln769">  return emsg_multiline(s, false);</a>
<a name="ln770">}</a>
<a name="ln771"> </a>
<a name="ln772">void emsg_invreg(int name)</a>
<a name="ln773">{</a>
<a name="ln774">  semsg(_(&quot;E354: Invalid register name: '%s'&quot;), transchar_buf(NULL, name));</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/// Print an error message with unknown number of arguments</a>
<a name="ln778">bool semsg(const char *const fmt, ...)</a>
<a name="ln779">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln780">{</a>
<a name="ln781">  bool ret;</a>
<a name="ln782"> </a>
<a name="ln783">  va_list ap;</a>
<a name="ln784">  va_start(ap, fmt);</a>
<a name="ln785">  ret = semsgv(fmt, ap);</a>
<a name="ln786">  va_end(ap);</a>
<a name="ln787"> </a>
<a name="ln788">  return ret;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">#define MULTILINE_BUFSIZE 8192</a>
<a name="ln792"> </a>
<a name="ln793">bool semsg_multiline(const char *const fmt, ...)</a>
<a name="ln794">{</a>
<a name="ln795">  bool ret;</a>
<a name="ln796">  va_list ap;</a>
<a name="ln797"> </a>
<a name="ln798">  static char errbuf[MULTILINE_BUFSIZE];</a>
<a name="ln799">  if (emsg_not_now()) {</a>
<a name="ln800">    return true;</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  va_start(ap, fmt);</a>
<a name="ln804">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln805">  va_end(ap);</a>
<a name="ln806"> </a>
<a name="ln807">  ret = emsg_multiline(errbuf, true);</a>
<a name="ln808"> </a>
<a name="ln809">  return ret;</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">/// Print an error message with unknown number of arguments</a>
<a name="ln813">static bool semsgv(const char *fmt, va_list ap)</a>
<a name="ln814">{</a>
<a name="ln815">  static char errbuf[IOSIZE];</a>
<a name="ln816">  if (emsg_not_now()) {</a>
<a name="ln817">    return true;</a>
<a name="ln818">  }</a>
<a name="ln819"> </a>
<a name="ln820">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln821"> </a>
<a name="ln822">  return emsg(errbuf);</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/// Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln826">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln827">/// detected when fuzzing vim.</a>
<a name="ln828">void iemsg(const char *s)</a>
<a name="ln829">{</a>
<a name="ln830">  if (emsg_not_now()) {</a>
<a name="ln831">    return;</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  emsg(s);</a>
<a name="ln835">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln836">  set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln837">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln838">  ui_flush();</a>
<a name="ln839">  abort();</a>
<a name="ln840">#endif</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">/// Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln844">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln845">/// detected when fuzzing vim.</a>
<a name="ln846">void siemsg(const char *s, ...)</a>
<a name="ln847">{</a>
<a name="ln848">  if (emsg_not_now()) {</a>
<a name="ln849">    return;</a>
<a name="ln850">  }</a>
<a name="ln851"> </a>
<a name="ln852">  va_list ap;</a>
<a name="ln853">  va_start(ap, s);</a>
<a name="ln854">  (void)semsgv(s, ap);</a>
<a name="ln855">  va_end(ap);</a>
<a name="ln856">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln857">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln858">  ui_flush();</a>
<a name="ln859">  abort();</a>
<a name="ln860">#endif</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">/// Give an &quot;Internal error&quot; message.</a>
<a name="ln864">void internal_error(const char *where)</a>
<a name="ln865">{</a>
<a name="ln866">  siemsg(_(e_intern2), where);</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">static void msg_semsg_event(void **argv)</a>
<a name="ln870">{</a>
<a name="ln871">  char *s = argv[0];</a>
<a name="ln872">  (void)emsg(s);</a>
<a name="ln873">  xfree(s);</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">void msg_schedule_semsg(const char *const fmt, ...)</a>
<a name="ln877">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln878">{</a>
<a name="ln879">  va_list ap;</a>
<a name="ln880">  va_start(ap, fmt);</a>
<a name="ln881">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln882">  va_end(ap);</a>
<a name="ln883"> </a>
<a name="ln884">  char *s = xstrdup(IObuff);</a>
<a name="ln885">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_event, 1, s));</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">/// Like msg(), but truncate to a single line if p_shm contains 't', or when</a>
<a name="ln889">/// &quot;force&quot; is true.  This truncates in another way as for normal messages.</a>
<a name="ln890">/// Careful: The string may be changed by msg_may_trunc()!</a>
<a name="ln891">///</a>
<a name="ln892">/// @return  a pointer to the printed message, if wait_return() not called.</a>
<a name="ln893">char *msg_trunc_attr(char *s, bool force, int attr)</a>
<a name="ln894">{</a>
<a name="ln895">  int n;</a>
<a name="ln896"> </a>
<a name="ln897">  // Add message to history before truncating.</a>
<a name="ln898">  add_msg_hist(s, -1, attr, false);</a>
<a name="ln899"> </a>
<a name="ln900">  char *ts = msg_may_trunc(force, s);</a>
<a name="ln901"> </a>
<a name="ln902">  msg_hist_off = true;</a>
<a name="ln903">  n = msg_attr(ts, attr);</a>
<a name="ln904">  msg_hist_off = false;</a>
<a name="ln905"> </a>
<a name="ln906">  if (n) {</a>
<a name="ln907">    return ts;</a>
<a name="ln908">  }</a>
<a name="ln909">  return NULL;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">/// Check if message &quot;s&quot; should be truncated at the start (for filenames).</a>
<a name="ln913">///</a>
<a name="ln914">/// @return  a pointer to where the truncated message starts.</a>
<a name="ln915">///</a>
<a name="ln916">/// @note: May change the message by replacing a character with '&lt;'.</a>
<a name="ln917">char *msg_may_trunc(bool force, char *s)</a>
<a name="ln918">{</a>
<a name="ln919">  if (ui_has(kUIMessages)) {</a>
<a name="ln920">    return s;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  int room = (Rows - cmdline_row - 1) * Columns + sc_col - 1;</a>
<a name="ln924">  if ((force || (shortmess(SHM_TRUNC) &amp;&amp; !exmode_active))</a>
<a name="ln925">      &amp;&amp; (int)strlen(s) - room &gt; 0) {</a>
<a name="ln926">    int size = vim_strsize(s);</a>
<a name="ln927"> </a>
<a name="ln928">    // There may be room anyway when there are multibyte chars.</a>
<a name="ln929">    if (size &lt;= room) {</a>
<a name="ln930">      return s;</a>
<a name="ln931">    }</a>
<a name="ln932">    int n;</a>
<a name="ln933">    for (n = 0; size &gt;= room;) {</a>
<a name="ln934">      size -= utf_ptr2cells(s + n);</a>
<a name="ln935">      n += utfc_ptr2len(s + n);</a>
<a name="ln936">    }</a>
<a name="ln937">    n--;</a>
<a name="ln938">    s += n;</a>
<a name="ln939">    *s = '&lt;';</a>
<a name="ln940">  }</a>
<a name="ln941">  return s;</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void hl_msg_free(HlMessage hl_msg)</a>
<a name="ln945">{</a>
<a name="ln946">  for (size_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln947">    xfree(kv_A(hl_msg, i).text.data);</a>
<a name="ln948">  }</a>
<a name="ln949">  kv_destroy(hl_msg);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/// @param[in]  len  Length of s or -1.</a>
<a name="ln953">static void add_msg_hist(const char *s, int len, int attr, bool multiline)</a>
<a name="ln954">{</a>
<a name="ln955">  add_msg_hist_multiattr(s, len, attr, multiline, (HlMessage)KV_INITIAL_VALUE);</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static void add_msg_hist_multiattr(const char *s, int len, int attr, bool multiline,</a>
<a name="ln959">                                   HlMessage multiattr)</a>
<a name="ln960">{</a>
<a name="ln961">  if (msg_hist_off || msg_silent != 0) {</a>
<a name="ln962">    hl_msg_free(multiattr);</a>
<a name="ln963">    return;</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966">  // Don't let the message history get too big</a>
<a name="ln967">  while (msg_hist_len &gt; MAX_MSG_HIST_LEN) {</a>
<a name="ln968">    (void)delete_first_msg();</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  // allocate an entry and add the message at the end of the history</a>
<a name="ln972">  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));</a>
<a name="ln973">  if (s) {</a>
<a name="ln974">    if (len &lt; 0) {</a>
<a name="ln975">      len = (int)strlen(s);</a>
<a name="ln976">    }</a>
<a name="ln977">    // remove leading and trailing newlines</a>
<a name="ln978">    while (len &gt; 0 &amp;&amp; *s == '\n') {</a>
<a name="ln979">      s++;</a>
<a name="ln980">      len--;</a>
<a name="ln981">    }</a>
<a name="ln982">    while (len &gt; 0 &amp;&amp; s[len - 1] == '\n') {</a>
<a name="ln983">      len--;</a>
<a name="ln984">    }</a>
<a name="ln985">    p-&gt;msg = xmemdupz(s, (size_t)len);</a>
<a name="ln986">  } else {</a>
<a name="ln987">    p-&gt;msg = NULL;</a>
<a name="ln988">  }</a>
<a name="ln989">  p-&gt;next = NULL;</a>
<a name="ln990">  p-&gt;attr = attr;</a>
<a name="ln991">  p-&gt;multiline = multiline;</a>
<a name="ln992">  p-&gt;multiattr = multiattr;</a>
<a name="ln993">  p-&gt;kind = msg_ext_kind;</a>
<a name="ln994">  if (last_msg_hist != NULL) {</a>
<a name="ln995">    last_msg_hist-&gt;next = p;</a>
<a name="ln996">  }</a>
<a name="ln997">  last_msg_hist = p;</a>
<a name="ln998">  if (first_msg_hist == NULL) {</a>
<a name="ln999">    first_msg_hist = last_msg_hist;</a>
<a name="ln1000">  }</a>
<a name="ln1001">  msg_hist_len++;</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">/// Delete the first (oldest) message from the history.</a>
<a name="ln1005">///</a>
<a name="ln1006">/// @return  FAIL if there are no messages.</a>
<a name="ln1007">int delete_first_msg(void)</a>
<a name="ln1008">{</a>
<a name="ln1009">  struct msg_hist *p;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (msg_hist_len &lt;= 0) {</a>
<a name="ln1012">    return FAIL;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  p = first_msg_hist;</a>
<a name="ln1015">  first_msg_hist = p-&gt;next;</a>
<a name="ln1016">  if (first_msg_hist == NULL) {  // history is becoming empty</a>
<a name="ln1017">    assert(msg_hist_len == 1);</a>
<a name="ln1018">    last_msg_hist = NULL;</a>
<a name="ln1019">  }</a>
<a name="ln1020">  xfree(p-&gt;msg);</a>
<a name="ln1021">  hl_msg_free(p-&gt;multiattr);</a>
<a name="ln1022">  xfree(p);</a>
<a name="ln1023">  msg_hist_len--;</a>
<a name="ln1024">  return OK;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/// :messages command implementation</a>
<a name="ln1028">void ex_messages(void *const eap_p)</a>
<a name="ln1029">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1030">{</a>
<a name="ln1031">  const exarg_T *const eap = (const exarg_T *)eap_p;</a>
<a name="ln1032">  struct msg_hist *p;</a>
<a name="ln1033"> </a>
<a name="ln1034">  if (strcmp(eap-&gt;arg, &quot;clear&quot;) == 0) {</a>
<a name="ln1035">    int keep = eap-&gt;addr_count == 0 ? 0 : eap-&gt;line2;</a>
<a name="ln1036"> </a>
<a name="ln1037">    while (msg_hist_len &gt; keep) {</a>
<a name="ln1038">      (void)delete_first_msg();</a>
<a name="ln1039">    }</a>
<a name="ln1040">    return;</a>
<a name="ln1041">  }</a>
<a name="ln1042"> </a>
<a name="ln1043">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1044">    emsg(_(e_invarg));</a>
<a name="ln1045">    return;</a>
<a name="ln1046">  }</a>
<a name="ln1047"> </a>
<a name="ln1048">  p = first_msg_hist;</a>
<a name="ln1049"> </a>
<a name="ln1050">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln1051">    int c = 0;</a>
<a name="ln1052">    // Count total messages</a>
<a name="ln1053">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1054">      c++;</a>
<a name="ln1055">    }</a>
<a name="ln1056"> </a>
<a name="ln1057">    c -= eap-&gt;line2;</a>
<a name="ln1058"> </a>
<a name="ln1059">    // Skip without number of messages specified</a>
<a name="ln1060">    for (p = first_msg_hist; p != NULL &amp;&amp; !got_int &amp;&amp; c &gt; 0; p = p-&gt;next, c--) {}</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  // Display what was not skipped.</a>
<a name="ln1064">  if (ui_has(kUIMessages)) {</a>
<a name="ln1065">    if (msg_silent) {</a>
<a name="ln1066">      return;</a>
<a name="ln1067">    }</a>
<a name="ln1068">    Array entries = ARRAY_DICT_INIT;</a>
<a name="ln1069">    for (; p != NULL; p = p-&gt;next) {</a>
<a name="ln1070">      if (kv_size(p-&gt;multiattr) || (p-&gt;msg &amp;&amp; p-&gt;msg[0])) {</a>
<a name="ln1071">        Array entry = ARRAY_DICT_INIT;</a>
<a name="ln1072">        ADD(entry, CSTR_TO_OBJ(p-&gt;kind));</a>
<a name="ln1073">        Array content = ARRAY_DICT_INIT;</a>
<a name="ln1074">        if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1075">          for (uint32_t i = 0; i &lt; kv_size(p-&gt;multiattr); i++) {</a>
<a name="ln1076">            HlMessageChunk chunk = kv_A(p-&gt;multiattr, i);</a>
<a name="ln1077">            Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1078">            ADD(content_entry, INTEGER_OBJ(chunk.attr));</a>
<a name="ln1079">            ADD(content_entry, STRING_OBJ(copy_string(chunk.text, NULL)));</a>
<a name="ln1080">            ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1081">          }</a>
<a name="ln1082">        } else if (p-&gt;msg &amp;&amp; p-&gt;msg[0]) {</a>
<a name="ln1083">          Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1084">          ADD(content_entry, INTEGER_OBJ(p-&gt;attr));</a>
<a name="ln1085">          ADD(content_entry, CSTR_TO_OBJ(p-&gt;msg));</a>
<a name="ln1086">          ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1087">        }</a>
<a name="ln1088">        ADD(entry, ARRAY_OBJ(content));</a>
<a name="ln1089">        ADD(entries, ARRAY_OBJ(entry));</a>
<a name="ln1090">      }</a>
<a name="ln1091">    }</a>
<a name="ln1092">    ui_call_msg_history_show(entries);</a>
<a name="ln1093">    api_free_array(entries);</a>
<a name="ln1094">    msg_ext_history_visible = true;</a>
<a name="ln1095">    wait_return(false);</a>
<a name="ln1096">  } else {</a>
<a name="ln1097">    msg_hist_off = true;</a>
<a name="ln1098">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1099">      if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1100">        msg_multiattr(p-&gt;multiattr, p-&gt;kind, false);</a>
<a name="ln1101">      } else if (p-&gt;msg != NULL) {</a>
<a name="ln1102">        msg_attr_keep(p-&gt;msg, p-&gt;attr, false, p-&gt;multiline);</a>
<a name="ln1103">      }</a>
<a name="ln1104">    }</a>
<a name="ln1105">    msg_hist_off = false;</a>
<a name="ln1106">  }</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">/// Call this after prompting the user.  This will avoid a hit-return message</a>
<a name="ln1110">/// and a delay.</a>
<a name="ln1111">void msg_end_prompt(void)</a>
<a name="ln1112">{</a>
<a name="ln1113">  msg_ext_clear_later();</a>
<a name="ln1114">  need_wait_return = false;</a>
<a name="ln1115">  emsg_on_display = false;</a>
<a name="ln1116">  cmdline_row = msg_row;</a>
<a name="ln1117">  msg_col = 0;</a>
<a name="ln1118">  msg_clr_eos();</a>
<a name="ln1119">  lines_left = -1;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/// Wait for the user to hit a key (normally Enter)</a>
<a name="ln1123">///</a>
<a name="ln1124">/// @param redraw  if true, redraw the entire screen UPD_NOT_VALID</a>
<a name="ln1125">///                if false, do a normal redraw</a>
<a name="ln1126">///                if -1, don't redraw at all</a>
<a name="ln1127">void wait_return(int redraw)</a>
<a name="ln1128">{</a>
<a name="ln1129">  int c;</a>
<a name="ln1130">  int oldState;</a>
<a name="ln1131">  int tmpState;</a>
<a name="ln1132">  int had_got_int;</a>
<a name="ln1133">  FILE *save_scriptout;</a>
<a name="ln1134"> </a>
<a name="ln1135">  if (redraw == true) {</a>
<a name="ln1136">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln1137">  }</a>
<a name="ln1138"> </a>
<a name="ln1139">  // If using &quot;:silent cmd&quot;, don't wait for a return.  Also don't set</a>
<a name="ln1140">  // need_wait_return to do it later.</a>
<a name="ln1141">  if (msg_silent != 0) {</a>
<a name="ln1142">    return;</a>
<a name="ln1143">  }</a>
<a name="ln1144"> </a>
<a name="ln1145">  if (headless_mode &amp;&amp; !ui_active()) {</a>
<a name="ln1146">    return;</a>
<a name="ln1147">  }</a>
<a name="ln1148"> </a>
<a name="ln1149">  // When inside vgetc(), we can't wait for a typed character at all.</a>
<a name="ln1150">  // With the global command (and some others) we only need one return at</a>
<a name="ln1151">  // the end. Adjust cmdline_row to avoid the next message overwriting the</a>
<a name="ln1152">  // last one.</a>
<a name="ln1153">  if (vgetc_busy &gt; 0) {</a>
<a name="ln1154">    return;</a>
<a name="ln1155">  }</a>
<a name="ln1156">  need_wait_return = true;</a>
<a name="ln1157">  if (no_wait_return) {</a>
<a name="ln1158">    if (!exmode_active) {</a>
<a name="ln1159">      cmdline_row = msg_row;</a>
<a name="ln1160">    }</a>
<a name="ln1161">    return;</a>
<a name="ln1162">  }</a>
<a name="ln1163"> </a>
<a name="ln1164">  redir_off = true;             // don't redirect this message</a>
<a name="ln1165">  oldState = State;</a>
<a name="ln1166">  if (quit_more) {</a>
<a name="ln1167">    c = CAR;                    // just pretend CR was hit</a>
<a name="ln1168">    quit_more = false;</a>
<a name="ln1169">    got_int = false;</a>
<a name="ln1170">  } else if (exmode_active) {</a>
<a name="ln1171">    msg_puts(&quot; &quot;);              // make sure the cursor is on the right line</a>
<a name="ln1172">    c = CAR;                    // no need for a return in ex mode</a>
<a name="ln1173">    got_int = false;</a>
<a name="ln1174">  } else {</a>
<a name="ln1175">    State = MODE_HITRETURN;</a>
<a name="ln1176">    setmouse();</a>
<a name="ln1177">    cmdline_row = msg_row;</a>
<a name="ln1178">    // Avoid the sequence that the user types &quot;:&quot; at the hit-return prompt</a>
<a name="ln1179">    // to start an Ex command, but the file-changed dialog gets in the</a>
<a name="ln1180">    // way.</a>
<a name="ln1181">    if (need_check_timestamps) {</a>
<a name="ln1182">      check_timestamps(false);</a>
<a name="ln1183">    }</a>
<a name="ln1184"> </a>
<a name="ln1185">    hit_return_msg();</a>
<a name="ln1186"> </a>
<a name="ln1187">    do {</a>
<a name="ln1188">      // Remember &quot;got_int&quot;, if it is set vgetc() probably returns a</a>
<a name="ln1189">      // CTRL-C, but we need to loop then.</a>
<a name="ln1190">      had_got_int = got_int;</a>
<a name="ln1191"> </a>
<a name="ln1192">      // Don't do mappings here, we put the character back in the</a>
<a name="ln1193">      // typeahead buffer.</a>
<a name="ln1194">      no_mapping++;</a>
<a name="ln1195">      allow_keys++;</a>
<a name="ln1196"> </a>
<a name="ln1197">      // Temporarily disable Recording. If Recording is active, the</a>
<a name="ln1198">      // character will be recorded later, since it will be added to the</a>
<a name="ln1199">      // typebuf after the loop</a>
<a name="ln1200">      const int save_reg_recording = reg_recording;</a>
<a name="ln1201">      save_scriptout = scriptout;</a>
<a name="ln1202">      reg_recording = 0;</a>
<a name="ln1203">      scriptout = NULL;</a>
<a name="ln1204">      c = safe_vgetc();</a>
<a name="ln1205">      if (had_got_int &amp;&amp; !global_busy) {</a>
<a name="ln1206">        got_int = false;</a>
<a name="ln1207">      }</a>
<a name="ln1208">      no_mapping--;</a>
<a name="ln1209">      allow_keys--;</a>
<a name="ln1210">      reg_recording = save_reg_recording;</a>
<a name="ln1211">      scriptout = save_scriptout;</a>
<a name="ln1212"> </a>
<a name="ln1213">      // Allow scrolling back in the messages.</a>
<a name="ln1214">      // Also accept scroll-down commands when messages fill the screen,</a>
<a name="ln1215">      // to avoid that typing one 'j' too many makes the messages</a>
<a name="ln1216">      // disappear.</a>
<a name="ln1217">      if (p_more) {</a>
<a name="ln1218">        if (c == 'b' || c == 'k' || c == 'u' || c == 'g'</a>
<a name="ln1219">            || c == K_UP || c == K_PAGEUP) {</a>
<a name="ln1220">          if (msg_scrolled &gt; Rows) {</a>
<a name="ln1221">            // scroll back to show older messages</a>
<a name="ln1222">            do_more_prompt(c);</a>
<a name="ln1223">          } else {</a>
<a name="ln1224">            msg_didout = false;</a>
<a name="ln1225">            c = K_IGNORE;</a>
<a name="ln1226">            msg_col =</a>
<a name="ln1227">              cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1228">              0;</a>
<a name="ln1229">          }</a>
<a name="ln1230">          if (quit_more) {</a>
<a name="ln1231">            c = CAR;                            // just pretend CR was hit</a>
<a name="ln1232">            quit_more = false;</a>
<a name="ln1233">            got_int = false;</a>
<a name="ln1234">          } else if (c != K_IGNORE) {</a>
<a name="ln1235">            c = K_IGNORE;</a>
<a name="ln1236">            hit_return_msg();</a>
<a name="ln1237">          }</a>
<a name="ln1238">        } else if (msg_scrolled &gt; Rows - 2</a>
<a name="ln1239">                   &amp;&amp; (c == 'j' || c == 'd' || c == 'f'</a>
<a name="ln1240">                       || c == K_DOWN || c == K_PAGEDOWN)) {</a>
<a name="ln1241">          c = K_IGNORE;</a>
<a name="ln1242">        }</a>
<a name="ln1243">      }</a>
<a name="ln1244">    } while ((had_got_int &amp;&amp; c == Ctrl_C)</a>
<a name="ln1245">             || c == K_IGNORE</a>
<a name="ln1246">             || c == K_LEFTDRAG || c == K_LEFTRELEASE</a>
<a name="ln1247">             || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE</a>
<a name="ln1248">             || c == K_RIGHTDRAG || c == K_RIGHTRELEASE</a>
<a name="ln1249">             || c == K_MOUSELEFT || c == K_MOUSERIGHT</a>
<a name="ln1250">             || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln1251">             || c == K_MOUSEMOVE);</a>
<a name="ln1252">    os_breakcheck();</a>
<a name="ln1253"> </a>
<a name="ln1254">    // Avoid that the mouse-up event causes visual mode to start.</a>
<a name="ln1255">    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE</a>
<a name="ln1256">        || c == K_X1MOUSE || c == K_X2MOUSE) {</a>
<a name="ln1257">      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);</a>
<a name="ln1258">    } else if (vim_strchr(&quot;\r\n &quot;, c) == NULL &amp;&amp; c != Ctrl_C) {</a>
<a name="ln1259">      // Put the character back in the typeahead buffer.  Don't use the</a>
<a name="ln1260">      // stuff buffer, because lmaps wouldn't work.</a>
<a name="ln1261">      ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1262">      do_redraw = true;             // need a redraw even though there is</a>
<a name="ln1263">                                    // typeahead</a>
<a name="ln1264">    }</a>
<a name="ln1265">  }</a>
<a name="ln1266">  redir_off = false;</a>
<a name="ln1267"> </a>
<a name="ln1268">  // If the user hits ':', '?' or '/' we get a command line from the next</a>
<a name="ln1269">  // line.</a>
<a name="ln1270">  if (c == ':' || c == '?' || c == '/') {</a>
<a name="ln1271">    if (!exmode_active) {</a>
<a name="ln1272">      cmdline_row = msg_row;</a>
<a name="ln1273">    }</a>
<a name="ln1274">    skip_redraw = true;  // skip redraw once</a>
<a name="ln1275">    do_redraw = false;</a>
<a name="ln1276">    msg_ext_keep_after_cmdline = true;</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  // If the screen size changed screen_resize() will redraw the screen.</a>
<a name="ln1280">  // Otherwise the screen is only redrawn if 'redraw' is set and no ':'</a>
<a name="ln1281">  // typed.</a>
<a name="ln1282">  tmpState = State;</a>
<a name="ln1283">  State = oldState;  // restore State before screen_resize()</a>
<a name="ln1284">  setmouse();</a>
<a name="ln1285">  msg_check();</a>
<a name="ln1286">  need_wait_return = false;</a>
<a name="ln1287">  did_wait_return = true;</a>
<a name="ln1288">  emsg_on_display = false;      // can delete error message now</a>
<a name="ln1289">  lines_left = -1;              // reset lines_left at next msg_start()</a>
<a name="ln1290">  reset_last_sourcing();</a>
<a name="ln1291">  if (keep_msg != NULL &amp;&amp; vim_strsize(keep_msg) &gt;=</a>
<a name="ln1292">      (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln1293">    XFREE_CLEAR(keep_msg);          // don't redisplay message, it's too long</a>
<a name="ln1294">  }</a>
<a name="ln1295"> </a>
<a name="ln1296">  if (tmpState == MODE_SETWSIZE) {       // got resize event while in vgetc()</a>
<a name="ln1297">    ui_refresh();</a>
<a name="ln1298">  } else if (!skip_redraw) {</a>
<a name="ln1299">    if (redraw == true || (msg_scrolled != 0 &amp;&amp; redraw != -1)) {</a>
<a name="ln1300">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln1301">    }</a>
<a name="ln1302">    if (ui_has(kUIMessages)) {</a>
<a name="ln1303">      msg_ext_clear(true);</a>
<a name="ln1304">    }</a>
<a name="ln1305">  }</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308">/// Write the hit-return prompt.</a>
<a name="ln1309">static void hit_return_msg(void)</a>
<a name="ln1310">{</a>
<a name="ln1311">  int save_p_more = p_more;</a>
<a name="ln1312"> </a>
<a name="ln1313">  p_more = false;       // don't want to see this message when scrolling back</a>
<a name="ln1314">  if (msg_didout) {     // start on a new line</a>
<a name="ln1315">    msg_putchar('\n');</a>
<a name="ln1316">  }</a>
<a name="ln1317">  msg_ext_set_kind(&quot;return_prompt&quot;);</a>
<a name="ln1318">  if (got_int) {</a>
<a name="ln1319">    msg_puts(_(&quot;Interrupt: &quot;));</a>
<a name="ln1320">  }</a>
<a name="ln1321"> </a>
<a name="ln1322">  msg_puts_attr(_(&quot;Press ENTER or type command to continue&quot;), HL_ATTR(HLF_R));</a>
<a name="ln1323">  if (!msg_use_printf()) {</a>
<a name="ln1324">    msg_clr_eos();</a>
<a name="ln1325">  }</a>
<a name="ln1326">  p_more = save_p_more;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">/// Set &quot;keep_msg&quot; to &quot;s&quot;.  Free the old value and check for NULL pointer.</a>
<a name="ln1330">void set_keep_msg(const char *s, int attr)</a>
<a name="ln1331">{</a>
<a name="ln1332">  xfree(keep_msg);</a>
<a name="ln1333">  if (s != NULL &amp;&amp; msg_silent == 0) {</a>
<a name="ln1334">    keep_msg = xstrdup(s);</a>
<a name="ln1335">  } else {</a>
<a name="ln1336">    keep_msg = NULL;</a>
<a name="ln1337">  }</a>
<a name="ln1338">  keep_msg_more = false;</a>
<a name="ln1339">  keep_msg_attr = attr;</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">/// Return true if printing messages should currently be done.</a>
<a name="ln1343">bool messaging(void)</a>
<a name="ln1344">{</a>
<a name="ln1345">  // TODO(bfredl): with general support for &quot;async&quot; messages with p_ch,</a>
<a name="ln1346">  // this should be re-enabled.</a>
<a name="ln1347">  return !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped) &amp;&amp; (p_ch &gt; 0 || ui_has(kUIMessages));</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">void msgmore(long n)</a>
<a name="ln1351">{</a>
<a name="ln1352">  long pn;</a>
<a name="ln1353"> </a>
<a name="ln1354">  if (global_busy           // no messages now, wait until global is finished</a>
<a name="ln1355">      || !messaging()) {      // 'lazyredraw' set, don't do messages now</a>
<a name="ln1356">    return;</a>
<a name="ln1357">  }</a>
<a name="ln1358"> </a>
<a name="ln1359">  // We don't want to overwrite another important message, but do overwrite</a>
<a name="ln1360">  // a previous &quot;more lines&quot; or &quot;fewer lines&quot; message, so that &quot;5dd&quot; and</a>
<a name="ln1361">  // then &quot;put&quot; reports the last action.</a>
<a name="ln1362">  if (keep_msg != NULL &amp;&amp; !keep_msg_more) {</a>
<a name="ln1363">    return;</a>
<a name="ln1364">  }</a>
<a name="ln1365"> </a>
<a name="ln1366">  if (n &gt; 0) {</a>
<a name="ln1367">    pn = n;</a>
<a name="ln1368">  } else {</a>
<a name="ln1369">    pn = -n;</a>
<a name="ln1370">  }</a>
<a name="ln1371"> </a>
<a name="ln1372">  if (pn &gt; p_report) {</a>
<a name="ln1373">    if (n &gt; 0) {</a>
<a name="ln1374">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1375">                   NGETTEXT(&quot;%ld more line&quot;, &quot;%ld more lines&quot;, pn),</a>
<a name="ln1376">                   pn);</a>
<a name="ln1377">    } else {</a>
<a name="ln1378">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1379">                   NGETTEXT(&quot;%ld line less&quot;, &quot;%ld fewer lines&quot;, pn),</a>
<a name="ln1380">                   pn);</a>
<a name="ln1381">    }</a>
<a name="ln1382">    if (got_int) {</a>
<a name="ln1383">      xstrlcat(msg_buf, _(&quot; (Interrupted)&quot;), MSG_BUF_LEN);</a>
<a name="ln1384">    }</a>
<a name="ln1385">    if (msg(msg_buf)) {</a>
<a name="ln1386">      set_keep_msg(msg_buf, 0);</a>
<a name="ln1387">      keep_msg_more = true;</a>
<a name="ln1388">    }</a>
<a name="ln1389">  }</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">void msg_ext_set_kind(const char *msg_kind)</a>
<a name="ln1393">{</a>
<a name="ln1394">  // Don't change the label of an existing batch:</a>
<a name="ln1395">  msg_ext_ui_flush();</a>
<a name="ln1396"> </a>
<a name="ln1397">  // TODO(bfredl): would be nice to avoid dynamic scoping, but that would</a>
<a name="ln1398">  // need refactoring the msg_ interface to not be &quot;please pretend nvim is</a>
<a name="ln1399">  // a terminal for a moment&quot;</a>
<a name="ln1400">  msg_ext_kind = msg_kind;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">/// Prepare for outputting characters in the command line.</a>
<a name="ln1404">void msg_start(void)</a>
<a name="ln1405">{</a>
<a name="ln1406">  int did_return = false;</a>
<a name="ln1407"> </a>
<a name="ln1408">  if (!msg_silent) {</a>
<a name="ln1409">    XFREE_CLEAR(keep_msg);              // don't display old message now</a>
<a name="ln1410">    need_fileinfo = false;</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  if (need_clr_eos || (p_ch == 0 &amp;&amp; redrawing_cmdline)) {</a>
<a name="ln1414">    // Halfway an &quot;:echo&quot; command and getting an (error) message: clear</a>
<a name="ln1415">    // any text from the command.</a>
<a name="ln1416">    need_clr_eos = false;</a>
<a name="ln1417">    msg_clr_eos();</a>
<a name="ln1418">  }</a>
<a name="ln1419"> </a>
<a name="ln1420">  // if cmdheight=0, we need to scroll in the first line of msg_grid upon the screen</a>
<a name="ln1421">  if (p_ch == 0 &amp;&amp; !ui_has(kUIMessages) &amp;&amp; !msg_scrolled) {</a>
<a name="ln1422">    msg_grid_validate();</a>
<a name="ln1423">    msg_scroll_up(false, true);</a>
<a name="ln1424">    msg_scrolled++;</a>
<a name="ln1425">    cmdline_row = Rows - 1;</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  if (!msg_scroll &amp;&amp; full_screen) {     // overwrite last message</a>
<a name="ln1429">    msg_row = cmdline_row;</a>
<a name="ln1430">    msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln1431">  } else if (msg_didout || (p_ch == 0 &amp;&amp; !ui_has(kUIMessages))) {  // start message on next line</a>
<a name="ln1432">    msg_putchar('\n');</a>
<a name="ln1433">    did_return = true;</a>
<a name="ln1434">    cmdline_row = msg_row;</a>
<a name="ln1435">  }</a>
<a name="ln1436">  if (!msg_didany || lines_left &lt; 0) {</a>
<a name="ln1437">    msg_starthere();</a>
<a name="ln1438">  }</a>
<a name="ln1439">  if (msg_silent == 0) {</a>
<a name="ln1440">    msg_didout = false;                     // no output on current line yet</a>
<a name="ln1441">  }</a>
<a name="ln1442"> </a>
<a name="ln1443">  if (ui_has(kUIMessages)) {</a>
<a name="ln1444">    msg_ext_ui_flush();</a>
<a name="ln1445">    if (!msg_scroll &amp;&amp; msg_ext_visible) {</a>
<a name="ln1446">      // Will overwrite last message.</a>
<a name="ln1447">      msg_ext_overwrite = true;</a>
<a name="ln1448">    }</a>
<a name="ln1449">  }</a>
<a name="ln1450"> </a>
<a name="ln1451">  // When redirecting, may need to start a new line.</a>
<a name="ln1452">  if (!did_return) {</a>
<a name="ln1453">    redir_write(&quot;\n&quot;, 1);</a>
<a name="ln1454">  }</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">/// Note that the current msg position is where messages start.</a>
<a name="ln1458">void msg_starthere(void)</a>
<a name="ln1459">{</a>
<a name="ln1460">  lines_left = cmdline_row;</a>
<a name="ln1461">  msg_didany = false;</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">void msg_putchar(int c)</a>
<a name="ln1465">{</a>
<a name="ln1466">  msg_putchar_attr(c, 0);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">void msg_putchar_attr(int c, int attr)</a>
<a name="ln1470">{</a>
<a name="ln1471">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln1472"> </a>
<a name="ln1473">  if (IS_SPECIAL(c)) {</a>
<a name="ln1474">    buf[0] = (char)K_SPECIAL;</a>
<a name="ln1475">    buf[1] = (char)K_SECOND(c);</a>
<a name="ln1476">    buf[2] = (char)K_THIRD(c);</a>
<a name="ln1477">    buf[3] = NUL;</a>
<a name="ln1478">  } else {</a>
<a name="ln1479">    buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln1480">  }</a>
<a name="ln1481">  msg_puts_attr(buf, attr);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">void msg_outnum(long n)</a>
<a name="ln1485">{</a>
<a name="ln1486">  char buf[20];</a>
<a name="ln1487"> </a>
<a name="ln1488">  snprintf(buf, sizeof(buf), &quot;%ld&quot;, n);</a>
<a name="ln1489">  msg_puts(buf);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">void msg_home_replace(const char *fname)</a>
<a name="ln1493">{</a>
<a name="ln1494">  msg_home_replace_attr(fname, 0);</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497">void msg_home_replace_hl(const char *fname)</a>
<a name="ln1498">{</a>
<a name="ln1499">  msg_home_replace_attr(fname, HL_ATTR(HLF_D));</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">static void msg_home_replace_attr(const char *fname, int attr)</a>
<a name="ln1503">{</a>
<a name="ln1504">  char *name = home_replace_save(NULL, fname);</a>
<a name="ln1505">  msg_outtrans_attr(name, attr);</a>
<a name="ln1506">  xfree(name);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">/// Output 'len' characters in 'str' (including NULs) with translation</a>
<a name="ln1510">/// if 'len' is -1, output up to a NUL character.</a>
<a name="ln1511">/// Use attributes 'attr'.</a>
<a name="ln1512">///</a>
<a name="ln1513">/// @return  the number of characters it takes on the screen.</a>
<a name="ln1514">int msg_outtrans(const char *str)</a>
<a name="ln1515">{</a>
<a name="ln1516">  return msg_outtrans_attr(str, 0);</a>
<a name="ln1517">}</a>
<a name="ln1518"> </a>
<a name="ln1519">int msg_outtrans_attr(const char *str, int attr)</a>
<a name="ln1520">{</a>
<a name="ln1521">  return msg_outtrans_len_attr(str, (int)strlen(str), attr);</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524">int msg_outtrans_len(const char *str, int len)</a>
<a name="ln1525">{</a>
<a name="ln1526">  return msg_outtrans_len_attr(str, len, 0);</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">/// Output one character at &quot;p&quot;.</a>
<a name="ln1530">/// Handles multi-byte characters.</a>
<a name="ln1531">///</a>
<a name="ln1532">/// @return  pointer to the next character.</a>
<a name="ln1533">const char *msg_outtrans_one(const char *p, int attr)</a>
<a name="ln1534">{</a>
<a name="ln1535">  int l;</a>
<a name="ln1536"> </a>
<a name="ln1537">  if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln1538">    msg_outtrans_len_attr(p, l, attr);</a>
<a name="ln1539">    return p + l;</a>
<a name="ln1540">  }</a>
<a name="ln1541">  msg_puts_attr(transchar_byte_buf(NULL, (uint8_t)(*p)), attr);</a>
<a name="ln1542">  return p + 1;</a>
<a name="ln1543">}</a>
<a name="ln1544"> </a>
<a name="ln1545">int msg_outtrans_len_attr(const char *msgstr, int len, int attr)</a>
<a name="ln1546">{</a>
<a name="ln1547">  int retval = 0;</a>
<a name="ln1548">  const char *str = msgstr;</a>
<a name="ln1549">  const char *plain_start = msgstr;</a>
<a name="ln1550">  char *s;</a>
<a name="ln1551">  int c;</a>
<a name="ln1552">  int save_got_int = got_int;</a>
<a name="ln1553"> </a>
<a name="ln1554">  // Only quit when got_int was set in here.</a>
<a name="ln1555">  got_int = false;</a>
<a name="ln1556"> </a>
<a name="ln1557">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1558">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1559">    add_msg_hist(str, len, attr, false);</a>
<a name="ln1560">    attr &amp;= ~MSG_HIST;</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  // When drawing over the command line no need to clear it later or remove</a>
<a name="ln1564">  // the mode message.</a>
<a name="ln1565">  if (msg_row &gt;= cmdline_row &amp;&amp; msg_col == 0) {</a>
<a name="ln1566">    clear_cmdline = false;</a>
<a name="ln1567">    mode_displayed = false;</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">  // If the string starts with a composing character first draw a space on</a>
<a name="ln1571">  // which the composing char can be drawn.</a>
<a name="ln1572">  if (utf_iscomposing(utf_ptr2char(msgstr))) {</a>
<a name="ln1573">    msg_puts_attr(&quot; &quot;, attr);</a>
<a name="ln1574">  }</a>
<a name="ln1575"> </a>
<a name="ln1576">  // Go over the string.  Special characters are translated and printed.</a>
<a name="ln1577">  // Normal characters are printed several at a time.</a>
<a name="ln1578">  while (--len &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1579">    // Don't include composing chars after the end.</a>
<a name="ln1580">    int mb_l = utfc_ptr2len_len(str, len + 1);</a>
<a name="ln1581">    if (mb_l &gt; 1) {</a>
<a name="ln1582">      c = utf_ptr2char(str);</a>
<a name="ln1583">      if (vim_isprintc(c)) {</a>
<a name="ln1584">        // Printable multi-byte char: count the cells.</a>
<a name="ln1585">        retval += utf_ptr2cells(str);</a>
<a name="ln1586">      } else {</a>
<a name="ln1587">        // Unprintable multi-byte char: print the printable chars so</a>
<a name="ln1588">        // far and the translation of the unprintable char.</a>
<a name="ln1589">        if (str &gt; plain_start) {</a>
<a name="ln1590">          msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1591">        }</a>
<a name="ln1592">        plain_start = str + mb_l;</a>
<a name="ln1593">        msg_puts_attr(transchar_buf(NULL, c), attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1594">        retval += char2cells(c);</a>
<a name="ln1595">      }</a>
<a name="ln1596">      len -= mb_l - 1;</a>
<a name="ln1597">      str += mb_l;</a>
<a name="ln1598">    } else {</a>
<a name="ln1599">      s = transchar_byte_buf(NULL, (uint8_t)(*str));</a>
<a name="ln1600">      if (s[1] != NUL) {</a>
<a name="ln1601">        // Unprintable char: print the printable chars so far and the</a>
<a name="ln1602">        // translation of the unprintable char.</a>
<a name="ln1603">        if (str &gt; plain_start) {</a>
<a name="ln1604">          msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1605">        }</a>
<a name="ln1606">        plain_start = str + 1;</a>
<a name="ln1607">        msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1608">        retval += (int)strlen(s);</a>
<a name="ln1609">      } else {</a>
<a name="ln1610">        retval++;</a>
<a name="ln1611">      }</a>
<a name="ln1612">      str++;</a>
<a name="ln1613">    }</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616">  if (str &gt; plain_start &amp;&amp; !got_int) {</a>
<a name="ln1617">    // Print the printable chars at the end.</a>
<a name="ln1618">    msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1619">  }</a>
<a name="ln1620"> </a>
<a name="ln1621">  got_int |= save_got_int;</a>
<a name="ln1622"> </a>
<a name="ln1623">  return retval;</a>
<a name="ln1624">}</a>
<a name="ln1625"> </a>
<a name="ln1626">void msg_make(const char *arg)</a>
<a name="ln1627">{</a>
<a name="ln1628">  int i;</a>
<a name="ln1629">  static const char *str = &quot;eeffoc&quot;;</a>
<a name="ln1630">  static const char *rs = &quot;Plon#dqg#vxjduB&quot;;</a>
<a name="ln1631"> </a>
<a name="ln1632">  arg = skipwhite(arg);</a>
<a name="ln1633">  for (i = 5; *arg &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln1634">    if (*arg++ != str[i]) {</a>
<a name="ln1635">      break;</a>
<a name="ln1636">    }</a>
<a name="ln1637">  }</a>
<a name="ln1638">  if (i &lt; 0) {</a>
<a name="ln1639">    msg_putchar('\n');</a>
<a name="ln1640">    for (i = 0; rs[i]; i++) {</a>
<a name="ln1641">      msg_putchar(rs[i] - 3);</a>
<a name="ln1642">    }</a>
<a name="ln1643">  }</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">/// Output the string 'str' up to a NUL character.</a>
<a name="ln1647">/// Return the number of characters it takes on the screen.</a>
<a name="ln1648">///</a>
<a name="ln1649">/// If K_SPECIAL is encountered, then it is taken in conjunction with the</a>
<a name="ln1650">/// following character and shown as &lt;F1&gt;, &lt;S-Up&gt; etc.  Any other character</a>
<a name="ln1651">/// which is not printable shown in &lt;&gt; form.</a>
<a name="ln1652">/// If 'from' is true (lhs of a mapping), a space is shown as &lt;Space&gt;.</a>
<a name="ln1653">/// If a character is displayed in one of these special ways, is also</a>
<a name="ln1654">/// highlighted (its highlight name is '8' in the p_hl variable).</a>
<a name="ln1655">/// Otherwise characters are not highlighted.</a>
<a name="ln1656">/// This function is used to show mappings, where we want to see how to type</a>
<a name="ln1657">/// the character/string -- webb</a>
<a name="ln1658">///</a>
<a name="ln1659">/// @param from  true for LHS of a mapping</a>
<a name="ln1660">/// @param maxlen  screen columns, 0 for unlimited</a>
<a name="ln1661">int msg_outtrans_special(const char *strstart, bool from, int maxlen)</a>
<a name="ln1662">{</a>
<a name="ln1663">  if (strstart == NULL) {</a>
<a name="ln1664">    return 0;  // Do nothing.</a>
<a name="ln1665">  }</a>
<a name="ln1666">  const char *str = strstart;</a>
<a name="ln1667">  int retval = 0;</a>
<a name="ln1668">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln1669"> </a>
<a name="ln1670">  while (*str != NUL) {</a>
<a name="ln1671">    const char *text;</a>
<a name="ln1672">    // Leading and trailing spaces need to be displayed in &lt;&gt; form.</a>
<a name="ln1673">    if ((str == strstart || str[1] == NUL) &amp;&amp; *str == ' ') {</a>
<a name="ln1674">      text = &quot;&lt;Space&gt;&quot;;</a>
<a name="ln1675">      str++;</a>
<a name="ln1676">    } else {</a>
<a name="ln1677">      text = str2special(&amp;str, from, false);</a>
<a name="ln1678">    }</a>
<a name="ln1679">    if (text[0] != NUL &amp;&amp; text[1] == NUL) {</a>
<a name="ln1680">      // single-byte character or illegal byte</a>
<a name="ln1681">      text = transchar_byte_buf(NULL, (uint8_t)text[0]);</a>
<a name="ln1682">    }</a>
<a name="ln1683">    const int len = vim_strsize(text);</a>
<a name="ln1684">    if (maxlen &gt; 0 &amp;&amp; retval + len &gt;= maxlen) {</a>
<a name="ln1685">      break;</a>
<a name="ln1686">    }</a>
<a name="ln1687">    // Highlight special keys</a>
<a name="ln1688">    msg_puts_attr(text, (len &gt; 1</a>
<a name="ln1689">                         &amp;&amp; utfc_ptr2len(text) &lt;= 1</a>
<a name="ln1690">                         ? attr : 0));</a>
<a name="ln1691">    retval += len;</a>
<a name="ln1692">  }</a>
<a name="ln1693">  return retval;</a>
<a name="ln1694">}</a>
<a name="ln1695"> </a>
<a name="ln1696">/// Convert string, replacing key codes with printables</a>
<a name="ln1697">///</a>
<a name="ln1698">/// Used for lhs or rhs of mappings.</a>
<a name="ln1699">///</a>
<a name="ln1700">/// @param[in]  str  String to convert.</a>
<a name="ln1701">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1702">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1703">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1704">///</a>
<a name="ln1705">/// @return [allocated] Converted string.</a>
<a name="ln1706">char *str2special_save(const char *const str, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1707">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1708">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1709">{</a>
<a name="ln1710">  garray_T ga;</a>
<a name="ln1711">  ga_init(&amp;ga, 1, 40);</a>
<a name="ln1712"> </a>
<a name="ln1713">  const char *p = str;</a>
<a name="ln1714">  while (*p != NUL) {</a>
<a name="ln1715">    ga_concat(&amp;ga, str2special(&amp;p, replace_spaces, replace_lt));</a>
<a name="ln1716">  }</a>
<a name="ln1717">  ga_append(&amp;ga, NUL);</a>
<a name="ln1718">  return (char *)ga.ga_data;</a>
<a name="ln1719">}</a>
<a name="ln1720"> </a>
<a name="ln1721">/// Convert character, replacing key with printable representation.</a>
<a name="ln1722">///</a>
<a name="ln1723">/// @param[in,out]  sp  String to convert. Is advanced to the next key code.</a>
<a name="ln1724">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1725">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1726">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1727">///</a>
<a name="ln1728">/// @return Converted key code, in a static buffer. Buffer is always one and the</a>
<a name="ln1729">///         same, so save converted string somewhere before running str2special</a>
<a name="ln1730">///         for the second time.</a>
<a name="ln1731">///         On illegal byte return a string with only that byte.</a>
<a name="ln1732">const char *str2special(const char **const sp, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1733">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET</a>
<a name="ln1734">{</a>
<a name="ln1735">  static char buf[7];</a>
<a name="ln1736"> </a>
<a name="ln1737">  {</a>
<a name="ln1738">    // Try to un-escape a multi-byte character.  Return the un-escaped</a>
<a name="ln1739">    // string if it is a multi-byte character.</a>
<a name="ln1740">    const char *const p = mb_unescape(sp);</a>
<a name="ln1741">    if (p != NULL) {</a>
<a name="ln1742">      return p;</a>
<a name="ln1743">    }</a>
<a name="ln1744">  }</a>
<a name="ln1745"> </a>
<a name="ln1746">  const char *str = *sp;</a>
<a name="ln1747">  int c = (uint8_t)(*str);</a>
<a name="ln1748">  int modifiers = 0;</a>
<a name="ln1749">  bool special = false;</a>
<a name="ln1750">  if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1751">    if ((uint8_t)str[1] == KS_MODIFIER) {</a>
<a name="ln1752">      modifiers = (uint8_t)str[2];</a>
<a name="ln1753">      str += 3;</a>
<a name="ln1754">      c = (uint8_t)(*str);</a>
<a name="ln1755">    }</a>
<a name="ln1756">    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1757">      c = TO_SPECIAL((uint8_t)str[1], (uint8_t)str[2]);</a>
<a name="ln1758">      str += 2;</a>
<a name="ln1759">    }</a>
<a name="ln1760">    if (IS_SPECIAL(c) || modifiers) {  // Special key.</a>
<a name="ln1761">      special = true;</a>
<a name="ln1762">    }</a>
<a name="ln1763">  }</a>
<a name="ln1764"> </a>
<a name="ln1765">  if (!IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1) {</a>
<a name="ln1766">    *sp = str;</a>
<a name="ln1767">    // Try to un-escape a multi-byte character after modifiers.</a>
<a name="ln1768">    const char *p = mb_unescape(sp);</a>
<a name="ln1769">    if (p != NULL) {</a>
<a name="ln1770">      // Since 'special' is true the multi-byte character 'c' will be</a>
<a name="ln1771">      // processed by get_special_key_name().</a>
<a name="ln1772">      c = utf_ptr2char(p);</a>
<a name="ln1773">    } else {</a>
<a name="ln1774">      // illegal byte</a>
<a name="ln1775">      *sp = str + 1;</a>
<a name="ln1776">    }</a>
<a name="ln1777">  } else {</a>
<a name="ln1778">    // single-byte character, NUL or illegal byte</a>
<a name="ln1779">    *sp = str + (*str == NUL ? 0 : 1);</a>
<a name="ln1780">  }</a>
<a name="ln1781"> </a>
<a name="ln1782">  // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.</a>
<a name="ln1783">  if (special</a>
<a name="ln1784">      || c &lt; ' '</a>
<a name="ln1785">      || (replace_spaces &amp;&amp; c == ' ')</a>
<a name="ln1786">      || (replace_lt &amp;&amp; c == '&lt;')) {</a>
<a name="ln1787">    return get_special_key_name(c, modifiers);</a>
<a name="ln1788">  }</a>
<a name="ln1789">  buf[0] = (char)c;</a>
<a name="ln1790">  buf[1] = NUL;</a>
<a name="ln1791">  return buf;</a>
<a name="ln1792">}</a>
<a name="ln1793"> </a>
<a name="ln1794">/// Convert string, replacing key codes with printables</a>
<a name="ln1795">///</a>
<a name="ln1796">/// @param[in]  str  String to convert.</a>
<a name="ln1797">/// @param[out]  buf  Buffer to save results to.</a>
<a name="ln1798">/// @param[in]  len  Buffer length.</a>
<a name="ln1799">void str2specialbuf(const char *sp, char *buf, size_t len)</a>
<a name="ln1800">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1801">{</a>
<a name="ln1802">  while (*sp) {</a>
<a name="ln1803">    const char *s = str2special(&amp;sp, false, false);</a>
<a name="ln1804">    const size_t s_len = strlen(s);</a>
<a name="ln1805">    if (len &lt;= s_len) {</a>
<a name="ln1806">      break;</a>
<a name="ln1807">    }</a>
<a name="ln1808">    memcpy(buf, s, s_len);</a>
<a name="ln1809">    buf += s_len;</a>
<a name="ln1810">    len -= s_len;</a>
<a name="ln1811">  }</a>
<a name="ln1812">  *buf = NUL;</a>
<a name="ln1813">}</a>
<a name="ln1814"> </a>
<a name="ln1815">/// print line for :print or :list command</a>
<a name="ln1816">void msg_prt_line(const char *s, int list)</a>
<a name="ln1817">{</a>
<a name="ln1818">  int c;</a>
<a name="ln1819">  int col = 0;</a>
<a name="ln1820">  int n_extra = 0;</a>
<a name="ln1821">  int c_extra = 0;</a>
<a name="ln1822">  int c_final = 0;</a>
<a name="ln1823">  const char *p_extra = NULL;  // init to make SASC shut up</a>
<a name="ln1824">  int n;</a>
<a name="ln1825">  int attr = 0;</a>
<a name="ln1826">  const char *lead = NULL;</a>
<a name="ln1827">  bool in_multispace = false;</a>
<a name="ln1828">  int multispace_pos = 0;</a>
<a name="ln1829">  const char *trail = NULL;</a>
<a name="ln1830">  int l;</a>
<a name="ln1831"> </a>
<a name="ln1832">  if (curwin-&gt;w_p_list) {</a>
<a name="ln1833">    list = true;</a>
<a name="ln1834">  }</a>
<a name="ln1835"> </a>
<a name="ln1836">  if (list) {</a>
<a name="ln1837">    // find start of trailing whitespace</a>
<a name="ln1838">    if (curwin-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1839">      trail = s + strlen(s);</a>
<a name="ln1840">      while (trail &gt; s &amp;&amp; ascii_iswhite(trail[-1])) {</a>
<a name="ln1841">        trail--;</a>
<a name="ln1842">      }</a>
<a name="ln1843">    }</a>
<a name="ln1844">    // find end of leading whitespace</a>
<a name="ln1845">    if (curwin-&gt;w_p_lcs_chars.lead || curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1846">      lead = s;</a>
<a name="ln1847">      while (ascii_iswhite(lead[0])) {</a>
<a name="ln1848">        lead++;</a>
<a name="ln1849">      }</a>
<a name="ln1850">      // in a line full of spaces all of them are treated as trailing</a>
<a name="ln1851">      if (*lead == NUL) {</a>
<a name="ln1852">        lead = NULL;</a>
<a name="ln1853">      }</a>
<a name="ln1854">    }</a>
<a name="ln1855">  }</a>
<a name="ln1856"> </a>
<a name="ln1857">  // output a space for an empty line, otherwise the line will be overwritten</a>
<a name="ln1858">  if (*s == NUL &amp;&amp; !(list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL)) {</a>
<a name="ln1859">    msg_putchar(' ');</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  while (!got_int) {</a>
<a name="ln1863">    if (n_extra &gt; 0) {</a>
<a name="ln1864">      n_extra--;</a>
<a name="ln1865">      if (n_extra == 0 &amp;&amp; c_final) {</a>
<a name="ln1866">        c = c_final;</a>
<a name="ln1867">      } else if (c_extra) {</a>
<a name="ln1868">        c = c_extra;</a>
<a name="ln1869">      } else {</a>
<a name="ln1870">        assert(p_extra != NULL);</a>
<a name="ln1871">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1872">      }</a>
<a name="ln1873">    } else if ((l = utfc_ptr2len(s)) &gt; 1) {</a>
<a name="ln1874">      col += utf_ptr2cells(s);</a>
<a name="ln1875">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln1876">      if (l &gt;= MB_MAXBYTES) {</a>
<a name="ln1877">        xstrlcpy(buf, &quot;?&quot;, sizeof(buf));</a>
<a name="ln1878">      } else if (curwin-&gt;w_p_lcs_chars.nbsp != NUL &amp;&amp; list</a>
<a name="ln1879">                 &amp;&amp; (utf_ptr2char(s) == 160</a>
<a name="ln1880">                     || utf_ptr2char(s) == 0x202f)) {</a>
<a name="ln1881">        int len = utf_char2bytes(curwin-&gt;w_p_lcs_chars.nbsp, buf);</a>
<a name="ln1882">        buf[len] = NUL;</a>
<a name="ln1883">      } else {</a>
<a name="ln1884">        memmove(buf, s, (size_t)l);</a>
<a name="ln1885">        buf[l] = NUL;</a>
<a name="ln1886">      }</a>
<a name="ln1887">      msg_puts(buf);</a>
<a name="ln1888">      s += l;</a>
<a name="ln1889">      continue;</a>
<a name="ln1890">    } else {</a>
<a name="ln1891">      attr = 0;</a>
<a name="ln1892">      c = (unsigned char)(*s++);</a>
<a name="ln1893">      in_multispace = c == ' ' &amp;&amp; ((col &gt; 0 &amp;&amp; s[-2] == ' ') || *s == ' ');</a>
<a name="ln1894">      if (!in_multispace) {</a>
<a name="ln1895">        multispace_pos = 0;</a>
<a name="ln1896">      }</a>
<a name="ln1897">      if (c == TAB &amp;&amp; (!list || curwin-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1898">        // tab amount depends on current column</a>
<a name="ln1899">        n_extra = tabstop_padding(col,</a>
<a name="ln1900">                                  curbuf-&gt;b_p_ts,</a>
<a name="ln1901">                                  curbuf-&gt;b_p_vts_array) - 1;</a>
<a name="ln1902">        if (!list) {</a>
<a name="ln1903">          c = ' ';</a>
<a name="ln1904">          c_extra = ' ';</a>
<a name="ln1905">          c_final = NUL;</a>
<a name="ln1906">        } else {</a>
<a name="ln1907">          c = (n_extra == 0 &amp;&amp; curwin-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln1908">              ? curwin-&gt;w_p_lcs_chars.tab3</a>
<a name="ln1909">              : curwin-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1910">          c_extra = curwin-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1911">          c_final = curwin-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1912">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1913">        }</a>
<a name="ln1914">      } else if (c == 160 &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp != NUL) {</a>
<a name="ln1915">        c = curwin-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1916">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1917">      } else if (c == NUL &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL) {</a>
<a name="ln1918">        p_extra = &quot;&quot;;</a>
<a name="ln1919">        c_extra = NUL;</a>
<a name="ln1920">        c_final = NUL;</a>
<a name="ln1921">        n_extra = 1;</a>
<a name="ln1922">        c = curwin-&gt;w_p_lcs_chars.eol;</a>
<a name="ln1923">        attr = HL_ATTR(HLF_AT);</a>
<a name="ln1924">        s--;</a>
<a name="ln1925">      } else if (c != NUL &amp;&amp; (n = byte2cells(c)) &gt; 1) {</a>
<a name="ln1926">        n_extra = n - 1;</a>
<a name="ln1927">        p_extra = transchar_byte_buf(NULL, c);</a>
<a name="ln1928">        c_extra = NUL;</a>
<a name="ln1929">        c_final = NUL;</a>
<a name="ln1930">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1931">        // Use special coloring to be able to distinguish &lt;hex&gt; from</a>
<a name="ln1932">        // the same in plain text.</a>
<a name="ln1933">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1934">      } else if (c == ' ') {</a>
<a name="ln1935">        if (list &amp;&amp; lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; in_multispace</a>
<a name="ln1936">            &amp;&amp; curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1937">          c = curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos++];</a>
<a name="ln1938">          if (curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos] == NUL) {</a>
<a name="ln1939">            multispace_pos = 0;</a>
<a name="ln1940">          }</a>
<a name="ln1941">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1942">        } else if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; curwin-&gt;w_p_lcs_chars.lead != NUL) {</a>
<a name="ln1943">          c = curwin-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1944">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1945">        } else if (trail != NULL &amp;&amp; s &gt; trail) {</a>
<a name="ln1946">          c = curwin-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1947">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1948">        } else if (list &amp;&amp; in_multispace</a>
<a name="ln1949">                   &amp;&amp; curwin-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1950">          c = curwin-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1951">          if (curwin-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1952">            multispace_pos = 0;</a>
<a name="ln1953">          }</a>
<a name="ln1954">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1955">        } else if (list &amp;&amp; curwin-&gt;w_p_lcs_chars.space != NUL) {</a>
<a name="ln1956">          c = curwin-&gt;w_p_lcs_chars.space;</a>
<a name="ln1957">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1958">        }</a>
<a name="ln1959">      }</a>
<a name="ln1960">    }</a>
<a name="ln1961"> </a>
<a name="ln1962">    if (c == NUL) {</a>
<a name="ln1963">      break;</a>
<a name="ln1964">    }</a>
<a name="ln1965"> </a>
<a name="ln1966">    msg_putchar_attr(c, attr);</a>
<a name="ln1967">    col++;</a>
<a name="ln1968">  }</a>
<a name="ln1969">  msg_clr_eos();</a>
<a name="ln1970">}</a>
<a name="ln1971"> </a>
<a name="ln1972">/// Use grid_puts() to output one multi-byte character.</a>
<a name="ln1973">///</a>
<a name="ln1974">/// @return  the pointer &quot;s&quot; advanced to the next character.</a>
<a name="ln1975">static const char *screen_puts_mbyte(const char *s, int l, int attr)</a>
<a name="ln1976">{</a>
<a name="ln1977">  int cw;</a>
<a name="ln1978">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln1979"> </a>
<a name="ln1980">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln1981">  cw = utf_ptr2cells(s);</a>
<a name="ln1982">  if (cw &gt; 1</a>
<a name="ln1983">      &amp;&amp; (cmdmsg_rl ? msg_col &lt;= 1 : msg_col == Columns - 1)) {</a>
<a name="ln1984">    // Doesn't fit, print a highlighted '&gt;' to fill it up.</a>
<a name="ln1985">    msg_screen_putchar('&gt;', HL_ATTR(HLF_AT));</a>
<a name="ln1986">    return s;</a>
<a name="ln1987">  }</a>
<a name="ln1988"> </a>
<a name="ln1989">  grid_puts_len(&amp;msg_grid_adj, s, l, msg_row, msg_col, attr);</a>
<a name="ln1990">  if (cmdmsg_rl) {</a>
<a name="ln1991">    msg_col -= cw;</a>
<a name="ln1992">    if (msg_col == 0) {</a>
<a name="ln1993">      msg_col = Columns;</a>
<a name="ln1994">      msg_row++;</a>
<a name="ln1995">    }</a>
<a name="ln1996">  } else {</a>
<a name="ln1997">    msg_col += cw;</a>
<a name="ln1998">    if (msg_col &gt;= Columns) {</a>
<a name="ln1999">      msg_col = 0;</a>
<a name="ln2000">      msg_row++;</a>
<a name="ln2001">    }</a>
<a name="ln2002">  }</a>
<a name="ln2003">  return s + l;</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">/// Output a string to the screen at position msg_row, msg_col.</a>
<a name="ln2007">/// Update msg_row and msg_col for the next message.</a>
<a name="ln2008">void msg_puts(const char *s)</a>
<a name="ln2009">{</a>
<a name="ln2010">  msg_puts_attr(s, 0);</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013">void msg_puts_title(const char *s)</a>
<a name="ln2014">{</a>
<a name="ln2015">  msg_puts_attr(s, HL_ATTR(HLF_T));</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018">/// Show a message in such a way that it always fits in the line.  Cut out a</a>
<a name="ln2019">/// part in the middle and replace it with &quot;...&quot; when necessary.</a>
<a name="ln2020">/// Does not handle multi-byte characters!</a>
<a name="ln2021">void msg_outtrans_long_attr(const char *longstr, int attr)</a>
<a name="ln2022">{</a>
<a name="ln2023">  msg_outtrans_long_len_attr(longstr, (int)strlen(longstr), attr);</a>
<a name="ln2024">}</a>
<a name="ln2025"> </a>
<a name="ln2026">void msg_outtrans_long_len_attr(const char *longstr, int len, int attr)</a>
<a name="ln2027">{</a>
<a name="ln2028">  int slen = len;</a>
<a name="ln2029">  int room;</a>
<a name="ln2030"> </a>
<a name="ln2031">  room = Columns - msg_col;</a>
<a name="ln2032">  if (len &gt; room &amp;&amp; room &gt;= 20) {</a>
<a name="ln2033">    slen = (room - 3) / 2;</a>
<a name="ln2034">    msg_outtrans_len_attr(longstr, slen, attr);</a>
<a name="ln2035">    msg_puts_attr(&quot;...&quot;, HL_ATTR(HLF_8));</a>
<a name="ln2036">  }</a>
<a name="ln2037">  msg_outtrans_len_attr(longstr + len - slen, slen, attr);</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040">/// Basic function for writing a message with highlight attributes.</a>
<a name="ln2041">void msg_puts_attr(const char *const s, const int attr)</a>
<a name="ln2042">{</a>
<a name="ln2043">  msg_puts_attr_len(s, -1, attr);</a>
<a name="ln2044">}</a>
<a name="ln2045"> </a>
<a name="ln2046">/// Write a message with highlight attributes</a>
<a name="ln2047">///</a>
<a name="ln2048">/// @param[in]  str  NUL-terminated message string.</a>
<a name="ln2049">/// @param[in]  len  Length of the string or -1.</a>
<a name="ln2050">/// @param[in]  attr  Highlight attribute.</a>
<a name="ln2051">void msg_puts_attr_len(const char *const str, const ptrdiff_t len, int attr)</a>
<a name="ln2052">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2053">{</a>
<a name="ln2054">  assert(len &lt; 0 || memchr(str, 0, (size_t)len) == NULL);</a>
<a name="ln2055">  // If redirection is on, also write to the redirection file.</a>
<a name="ln2056">  redir_write(str, len);</a>
<a name="ln2057"> </a>
<a name="ln2058">  // Don't print anything when using &quot;:silent cmd&quot;.</a>
<a name="ln2059">  if (msg_silent != 0) {</a>
<a name="ln2060">    return;</a>
<a name="ln2061">  }</a>
<a name="ln2062"> </a>
<a name="ln2063">  // if MSG_HIST flag set, add message to history</a>
<a name="ln2064">  if (attr &amp; MSG_HIST) {</a>
<a name="ln2065">    add_msg_hist(str, (int)len, attr, false);</a>
<a name="ln2066">    attr &amp;= ~MSG_HIST;</a>
<a name="ln2067">  }</a>
<a name="ln2068"> </a>
<a name="ln2069">  // When writing something to the screen after it has scrolled, requires a</a>
<a name="ln2070">  // wait-return prompt later.  Needed when scrolling, resetting</a>
<a name="ln2071">  // need_wait_return after some prompt, and then outputting something</a>
<a name="ln2072">  // without scrolling</a>
<a name="ln2073">  // Not needed when only using CR to move the cursor.</a>
<a name="ln2074">  bool overflow = false;</a>
<a name="ln2075">  if (ui_has(kUIMessages)) {</a>
<a name="ln2076">    int count = msg_ext_visible + (msg_ext_overwrite ? 0 : 1);</a>
<a name="ln2077">    // TODO(bfredl): possible extension point, let external UI control this</a>
<a name="ln2078">    if (count &gt; 1) {</a>
<a name="ln2079">      overflow = true;</a>
<a name="ln2080">    }</a>
<a name="ln2081">  } else {</a>
<a name="ln2082">    overflow = msg_scrolled &gt; (p_ch == 0 ? 1 : 0);</a>
<a name="ln2083">  }</a>
<a name="ln2084"> </a>
<a name="ln2085">  if (overflow &amp;&amp; !msg_scrolled_ign &amp;&amp; strcmp(str, &quot;\r&quot;) != 0) {</a>
<a name="ln2086">    need_wait_return = true;</a>
<a name="ln2087">  }</a>
<a name="ln2088">  msg_didany = true;  // remember that something was outputted</a>
<a name="ln2089"> </a>
<a name="ln2090">  // If there is no valid screen, use fprintf so we can see error messages.</a>
<a name="ln2091">  // If termcap is not active, we may be writing in an alternate console</a>
<a name="ln2092">  // window, cursor positioning may not work correctly (window size may be</a>
<a name="ln2093">  // different, e.g. for Win32 console) or we just don't know where the</a>
<a name="ln2094">  // cursor is.</a>
<a name="ln2095">  if (msg_use_printf()) {</a>
<a name="ln2096">    int saved_msg_col = msg_col;</a>
<a name="ln2097">    msg_puts_printf(str, len);</a>
<a name="ln2098">    if (headless_mode) {</a>
<a name="ln2099">      msg_col = saved_msg_col;</a>
<a name="ln2100">    }</a>
<a name="ln2101">  }</a>
<a name="ln2102">  if (!msg_use_printf() || (headless_mode &amp;&amp; default_grid.chars)) {</a>
<a name="ln2103">    msg_puts_display(str, (int)len, attr, false);</a>
<a name="ln2104">  }</a>
<a name="ln2105"> </a>
<a name="ln2106">  need_fileinfo = false;</a>
<a name="ln2107">}</a>
<a name="ln2108"> </a>
<a name="ln2109">/// Print a formatted message</a>
<a name="ln2110">///</a>
<a name="ln2111">/// Message printed is limited by #IOSIZE. Must not be used from inside</a>
<a name="ln2112">/// msg_puts_attr().</a>
<a name="ln2113">///</a>
<a name="ln2114">/// @param[in]  attr  Highlight attributes.</a>
<a name="ln2115">/// @param[in]  fmt  Format string.</a>
<a name="ln2116">void msg_printf_attr(const int attr, const char *const fmt, ...)</a>
<a name="ln2117">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2118">{</a>
<a name="ln2119">  static char msgbuf[IOSIZE];</a>
<a name="ln2120"> </a>
<a name="ln2121">  va_list ap;</a>
<a name="ln2122">  va_start(ap, fmt);</a>
<a name="ln2123">  const size_t len = (size_t)vim_vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);</a>
<a name="ln2124">  va_end(ap);</a>
<a name="ln2125"> </a>
<a name="ln2126">  msg_scroll = true;</a>
<a name="ln2127">  msg_puts_attr_len(msgbuf, (ptrdiff_t)len, attr);</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130">static void msg_ext_emit_chunk(void)</a>
<a name="ln2131">{</a>
<a name="ln2132">  // Color was changed or a message flushed, end current chunk.</a>
<a name="ln2133">  if (msg_ext_last_attr == -1) {</a>
<a name="ln2134">    return;  // no chunk</a>
<a name="ln2135">  }</a>
<a name="ln2136">  Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln2137">  ADD(chunk, INTEGER_OBJ(msg_ext_last_attr));</a>
<a name="ln2138">  msg_ext_last_attr = -1;</a>
<a name="ln2139">  String text = ga_take_string(&amp;msg_ext_last_chunk);</a>
<a name="ln2140">  ADD(chunk, STRING_OBJ(text));</a>
<a name="ln2141">  ADD(msg_ext_chunks, ARRAY_OBJ(chunk));</a>
<a name="ln2142">}</a>
<a name="ln2143"> </a>
<a name="ln2144">/// The display part of msg_puts_attr_len().</a>
<a name="ln2145">/// May be called recursively to display scroll-back text.</a>
<a name="ln2146">static void msg_puts_display(const char *str, int maxlen, int attr, int recurse)</a>
<a name="ln2147">{</a>
<a name="ln2148">  const char *s = str;</a>
<a name="ln2149">  const char *t_s = str;  // String from &quot;t_s&quot; to &quot;s&quot; is still todo.</a>
<a name="ln2150">  int t_col = 0;  // Screen cells todo, 0 when &quot;t_s&quot; not used.</a>
<a name="ln2151">  int l;</a>
<a name="ln2152">  int cw;</a>
<a name="ln2153">  const char *sb_str = str;</a>
<a name="ln2154">  int sb_col = msg_col;</a>
<a name="ln2155">  int wrap;</a>
<a name="ln2156">  int did_last_char;</a>
<a name="ln2157"> </a>
<a name="ln2158">  did_wait_return = false;</a>
<a name="ln2159"> </a>
<a name="ln2160">  if (ui_has(kUIMessages)) {</a>
<a name="ln2161">    if (attr != msg_ext_last_attr) {</a>
<a name="ln2162">      msg_ext_emit_chunk();</a>
<a name="ln2163">      msg_ext_last_attr = attr;</a>
<a name="ln2164">    }</a>
<a name="ln2165">    // Concat pieces with the same highlight</a>
<a name="ln2166">    size_t len = strnlen(str, (size_t)maxlen);  // -V781</a>
<a name="ln2167">    ga_concat_len(&amp;msg_ext_last_chunk, str, len);</a>
<a name="ln2168">    msg_ext_cur_len += len;</a>
<a name="ln2169">    return;</a>
<a name="ln2170">  }</a>
<a name="ln2171"> </a>
<a name="ln2172">  msg_grid_validate();</a>
<a name="ln2173"> </a>
<a name="ln2174">  cmdline_was_last_drawn = redrawing_cmdline;</a>
<a name="ln2175"> </a>
<a name="ln2176">  while ((maxlen &lt; 0 || (int)(s - str) &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2177">    // We are at the end of the screen line when:</a>
<a name="ln2178">    // - When outputting a newline.</a>
<a name="ln2179">    // - When outputting a character in the last column.</a>
<a name="ln2180">    if (!recurse &amp;&amp; msg_row &gt;= Rows - 1</a>
<a name="ln2181">        &amp;&amp; (*s == '\n' || (cmdmsg_rl</a>
<a name="ln2182">                           ? (msg_col &lt;= 1</a>
<a name="ln2183">                              || (*s == TAB &amp;&amp; msg_col &lt;= 7)</a>
<a name="ln2184">                              || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2185">                                  &amp;&amp; msg_col &lt;= 2))</a>
<a name="ln2186">                           : ((*s != '\r' &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2187">                              || (*s == TAB</a>
<a name="ln2188">                                  &amp;&amp; msg_col + t_col &gt;= ((Columns - 1) &amp; ~7))</a>
<a name="ln2189">                              || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2190">                                  &amp;&amp; msg_col + t_col &gt;= Columns - 2))))) {</a>
<a name="ln2191">      // The screen is scrolled up when at the last row (some terminals</a>
<a name="ln2192">      // scroll automatically, some don't.  To avoid problems we scroll</a>
<a name="ln2193">      // ourselves).</a>
<a name="ln2194">      if (t_col &gt; 0) {</a>
<a name="ln2195">        // output postponed text</a>
<a name="ln2196">        t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2197">      }</a>
<a name="ln2198"> </a>
<a name="ln2199">      // When no more prompt and no more room, truncate here</a>
<a name="ln2200">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2201">        break;</a>
<a name="ln2202">      }</a>
<a name="ln2203"> </a>
<a name="ln2204">      // Scroll the screen up one line.</a>
<a name="ln2205">      bool has_last_char = ((uint8_t)(*s) &gt;= ' ' &amp;&amp; !cmdmsg_rl);</a>
<a name="ln2206">      msg_scroll_up(!has_last_char, false);</a>
<a name="ln2207"> </a>
<a name="ln2208">      msg_row = Rows - 2;</a>
<a name="ln2209">      if (msg_col &gt;= Columns) {         // can happen after screen resize</a>
<a name="ln2210">        msg_col = Columns - 1;</a>
<a name="ln2211">      }</a>
<a name="ln2212"> </a>
<a name="ln2213">      // Display char in last column before showing more-prompt.</a>
<a name="ln2214">      if (has_last_char) {</a>
<a name="ln2215">        if (maxlen &gt;= 0) {</a>
<a name="ln2216">          // Avoid including composing chars after the end.</a>
<a name="ln2217">          l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2218">        } else {</a>
<a name="ln2219">          l = utfc_ptr2len(s);</a>
<a name="ln2220">        }</a>
<a name="ln2221">        s = screen_puts_mbyte(s, l, attr);</a>
<a name="ln2222">        did_last_char = true;</a>
<a name="ln2223">      } else {</a>
<a name="ln2224">        did_last_char = false;</a>
<a name="ln2225">      }</a>
<a name="ln2226"> </a>
<a name="ln2227">      // Tricky: if last cell will be written, delay the throttle until</a>
<a name="ln2228">      // after the first scroll. Otherwise we would need to keep track of it.</a>
<a name="ln2229">      if (has_last_char &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2230">        if (!msg_grid.throttled) {</a>
<a name="ln2231">          msg_grid_scroll_discount++;</a>
<a name="ln2232">        }</a>
<a name="ln2233">        msg_grid.throttled = true;</a>
<a name="ln2234">      }</a>
<a name="ln2235"> </a>
<a name="ln2236">      if (p_more) {</a>
<a name="ln2237">        // Store text for scrolling back.</a>
<a name="ln2238">        store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2239">      }</a>
<a name="ln2240"> </a>
<a name="ln2241">      inc_msg_scrolled();</a>
<a name="ln2242">      need_wait_return = true;       // may need wait_return() in main()</a>
<a name="ln2243">      redraw_cmdline = true;</a>
<a name="ln2244">      if (cmdline_row &gt; 0 &amp;&amp; !exmode_active) {</a>
<a name="ln2245">        cmdline_row--;</a>
<a name="ln2246">      }</a>
<a name="ln2247"> </a>
<a name="ln2248">      // If screen is completely filled and 'more' is set then wait</a>
<a name="ln2249">      // for a character.</a>
<a name="ln2250">      if (lines_left &gt; 0) {</a>
<a name="ln2251">        lines_left--;</a>
<a name="ln2252">      }</a>
<a name="ln2253">      if (p_more &amp;&amp; lines_left == 0 &amp;&amp; State != MODE_HITRETURN</a>
<a name="ln2254">          &amp;&amp; !msg_no_more &amp;&amp; !exmode_active) {</a>
<a name="ln2255">        if (do_more_prompt(NUL)) {</a>
<a name="ln2256">          s = confirm_msg_tail;</a>
<a name="ln2257">        }</a>
<a name="ln2258">        if (quit_more) {</a>
<a name="ln2259">          return;</a>
<a name="ln2260">        }</a>
<a name="ln2261">      }</a>
<a name="ln2262"> </a>
<a name="ln2263">      // When we displayed a char in last column need to check if there</a>
<a name="ln2264">      // is still more.</a>
<a name="ln2265">      if (did_last_char) {</a>
<a name="ln2266">        continue;</a>
<a name="ln2267">      }</a>
<a name="ln2268">    }</a>
<a name="ln2269"> </a>
<a name="ln2270">    wrap = *s == '\n'</a>
<a name="ln2271">           || msg_col + t_col &gt;= Columns</a>
<a name="ln2272">           || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2273">               &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2274">    ;</a>
<a name="ln2275">    if (t_col &gt; 0 &amp;&amp; (wrap || *s == '\r' || *s == '\b'</a>
<a name="ln2276">                      || *s == '\t' || *s == BELL)) {</a>
<a name="ln2277">      // Output any postponed text.</a>
<a name="ln2278">      t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2279">    }</a>
<a name="ln2280"> </a>
<a name="ln2281">    if (wrap &amp;&amp; p_more &amp;&amp; !recurse) {</a>
<a name="ln2282">      // Store text for scrolling back.</a>
<a name="ln2283">      store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2284">    }</a>
<a name="ln2285"> </a>
<a name="ln2286">    if (*s == '\n') {               // go to next line</a>
<a name="ln2287">      msg_didout = false;           // remember that line is empty</a>
<a name="ln2288">      if (cmdmsg_rl) {</a>
<a name="ln2289">        msg_col = Columns - 1;</a>
<a name="ln2290">      } else {</a>
<a name="ln2291">        msg_col = 0;</a>
<a name="ln2292">      }</a>
<a name="ln2293">      if (++msg_row &gt;= Rows) {        // safety check</a>
<a name="ln2294">        msg_row = Rows - 1;</a>
<a name="ln2295">      }</a>
<a name="ln2296">    } else if (*s == '\r') {      // go to column 0</a>
<a name="ln2297">      msg_col = 0;</a>
<a name="ln2298">    } else if (*s == '\b') {      // go to previous char</a>
<a name="ln2299">      if (msg_col) {</a>
<a name="ln2300">        msg_col--;</a>
<a name="ln2301">      }</a>
<a name="ln2302">    } else if (*s == TAB) {       // translate Tab into spaces</a>
<a name="ln2303">      do {</a>
<a name="ln2304">        msg_screen_putchar(' ', attr);</a>
<a name="ln2305">      } while (msg_col &amp; 7);</a>
<a name="ln2306">    } else if (*s == BELL) {  // beep (from &quot;:sh&quot;)</a>
<a name="ln2307">      vim_beep(BO_SH);</a>
<a name="ln2308">    } else if ((uint8_t)(*s) &gt;= 0x20) {  // printable char</a>
<a name="ln2309">      cw = utf_ptr2cells(s);</a>
<a name="ln2310">      if (maxlen &gt;= 0) {</a>
<a name="ln2311">        // avoid including composing chars after the end</a>
<a name="ln2312">        l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2313">      } else {</a>
<a name="ln2314">        l = utfc_ptr2len(s);</a>
<a name="ln2315">      }</a>
<a name="ln2316">      // When drawing from right to left or when a double-wide character</a>
<a name="ln2317">      // doesn't fit, draw a single character here.  Otherwise collect</a>
<a name="ln2318">      // characters and draw them all at once later.</a>
<a name="ln2319">      if (cmdmsg_rl || (cw &gt; 1 &amp;&amp; msg_col + t_col &gt;= Columns - 1)) {</a>
<a name="ln2320">        if (l &gt; 1) {</a>
<a name="ln2321">          s = screen_puts_mbyte(s, l, attr) - 1;</a>
<a name="ln2322">        } else {</a>
<a name="ln2323">          msg_screen_putchar(*s, attr);</a>
<a name="ln2324">        }</a>
<a name="ln2325">      } else {</a>
<a name="ln2326">        // postpone this character until later</a>
<a name="ln2327">        if (t_col == 0) {</a>
<a name="ln2328">          t_s = s;</a>
<a name="ln2329">        }</a>
<a name="ln2330">        t_col += cw;</a>
<a name="ln2331">        s += l - 1;</a>
<a name="ln2332">      }</a>
<a name="ln2333">    }</a>
<a name="ln2334">    s++;</a>
<a name="ln2335">  }</a>
<a name="ln2336"> </a>
<a name="ln2337">  // Output any postponed text.</a>
<a name="ln2338">  if (t_col &gt; 0) {</a>
<a name="ln2339">    t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2340">  }</a>
<a name="ln2341">  if (p_more &amp;&amp; !recurse &amp;&amp; !(s == sb_str + 1 &amp;&amp; *sb_str == '\n')) {</a>
<a name="ln2342">    store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, false);</a>
<a name="ln2343">  }</a>
<a name="ln2344"> </a>
<a name="ln2345">  msg_check();</a>
<a name="ln2346">}</a>
<a name="ln2347"> </a>
<a name="ln2348">/// @return  true when &quot;:filter pattern&quot; was used and &quot;msg&quot; does not match</a>
<a name="ln2349">///          &quot;pattern&quot;.</a>
<a name="ln2350">bool message_filtered(const char *msg)</a>
<a name="ln2351">{</a>
<a name="ln2352">  if (cmdmod.cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2353">    return false;</a>
<a name="ln2354">  }</a>
<a name="ln2355"> </a>
<a name="ln2356">  bool match = vim_regexec(&amp;cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);</a>
<a name="ln2357">  return cmdmod.cmod_filter_force ? match : !match;</a>
<a name="ln2358">}</a>
<a name="ln2359"> </a>
<a name="ln2360">/// including horizontal separator</a>
<a name="ln2361">int msg_scrollsize(void)</a>
<a name="ln2362">{</a>
<a name="ln2363">  return msg_scrolled + (int)p_ch + ((p_ch &gt; 0 || msg_scrolled &gt; 1) ? 1 : 0);</a>
<a name="ln2364">}</a>
<a name="ln2365"> </a>
<a name="ln2366">bool msg_do_throttle(void)</a>
<a name="ln2367">{</a>
<a name="ln2368">  return msg_use_grid() &amp;&amp; !(rdb_flags &amp; RDB_NOTHROTTLE);</a>
<a name="ln2369">}</a>
<a name="ln2370"> </a>
<a name="ln2371">/// Scroll the screen up one line for displaying the next message line.</a>
<a name="ln2372">void msg_scroll_up(bool may_throttle, bool zerocmd)</a>
<a name="ln2373">{</a>
<a name="ln2374">  if (may_throttle &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2375">    msg_grid.throttled = true;</a>
<a name="ln2376">  }</a>
<a name="ln2377">  msg_did_scroll = true;</a>
<a name="ln2378">  if (msg_grid_pos &gt; 0) {</a>
<a name="ln2379">    msg_grid_set_pos(msg_grid_pos - 1, !zerocmd);</a>
<a name="ln2380"> </a>
<a name="ln2381">    // When displaying the first line with cmdheight=0, we need to draw over</a>
<a name="ln2382">    // the existing last line of the screen.</a>
<a name="ln2383">    if (zerocmd &amp;&amp; msg_grid.chars) {</a>
<a name="ln2384">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[0], msg_grid.cols, false);</a>
<a name="ln2385">    }</a>
<a name="ln2386">  } else {</a>
<a name="ln2387">    grid_del_lines(&amp;msg_grid, 0, 1, msg_grid.rows, 0, msg_grid.cols);</a>
<a name="ln2388">    memmove(msg_grid.dirty_col, msg_grid.dirty_col + 1,</a>
<a name="ln2389">            (size_t)(msg_grid.rows - 1) * sizeof(*msg_grid.dirty_col));</a>
<a name="ln2390">    msg_grid.dirty_col[msg_grid.rows - 1] = 0;</a>
<a name="ln2391">  }</a>
<a name="ln2392"> </a>
<a name="ln2393">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln2394">}</a>
<a name="ln2395"> </a>
<a name="ln2396">/// Send throttled message output to UI clients</a>
<a name="ln2397">///</a>
<a name="ln2398">/// The way message.c uses the grid_xx family of functions is quite inefficient</a>
<a name="ln2399">/// relative to the &quot;gridline&quot; UI protocol used by TUI and modern clients.</a>
<a name="ln2400">/// For instance scrolling is done one line at a time. By throttling drawing</a>
<a name="ln2401">/// on the message grid, we can coalesce scrolling to a single grid_scroll</a>
<a name="ln2402">/// per screen update.</a>
<a name="ln2403">///</a>
<a name="ln2404">/// NB: The bookkeeping is quite messy, and rests on a bunch of poorly</a>
<a name="ln2405">/// documented assumptions. For instance that the message area always grows</a>
<a name="ln2406">/// while being throttled, messages are only being output on the last line</a>
<a name="ln2407">/// etc.</a>
<a name="ln2408">///</a>
<a name="ln2409">/// Probably message scrollback storage should be reimplemented as a</a>
<a name="ln2410">/// file_buffer, and message scrolling in TUI be reimplemented as a modal</a>
<a name="ln2411">/// floating window. Then we get throttling &quot;for free&quot; using standard</a>
<a name="ln2412">/// redraw_later code paths.</a>
<a name="ln2413">void msg_scroll_flush(void)</a>
<a name="ln2414">{</a>
<a name="ln2415">  if (msg_grid.throttled) {</a>
<a name="ln2416">    msg_grid.throttled = false;</a>
<a name="ln2417">    int pos_delta = msg_grid_pos_at_flush - msg_grid_pos;</a>
<a name="ln2418">    assert(pos_delta &gt;= 0);</a>
<a name="ln2419">    int delta = MIN(msg_scrolled - msg_scrolled_at_flush, msg_grid.rows);</a>
<a name="ln2420"> </a>
<a name="ln2421">    if (pos_delta &gt; 0) {</a>
<a name="ln2422">      ui_ext_msg_set_pos(msg_grid_pos, true);</a>
<a name="ln2423">    }</a>
<a name="ln2424"> </a>
<a name="ln2425">    int to_scroll = delta - pos_delta - msg_grid_scroll_discount;</a>
<a name="ln2426">    assert(to_scroll &gt;= 0);</a>
<a name="ln2427"> </a>
<a name="ln2428">    // TODO(bfredl): msg_grid_pos should be 0 already when starting scrolling</a>
<a name="ln2429">    // but this sometimes fails in &quot;headless&quot; message printing.</a>
<a name="ln2430">    if (to_scroll &gt; 0 &amp;&amp; msg_grid_pos == 0) {</a>
<a name="ln2431">      ui_call_grid_scroll(msg_grid.handle, 0, Rows, 0, Columns, to_scroll, 0);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    for (int i = MAX(Rows - MAX(delta, 1), 0); i &lt; Rows; i++) {</a>
<a name="ln2435">      int row = i - msg_grid_pos;</a>
<a name="ln2436">      assert(row &gt;= 0);</a>
<a name="ln2437">      ui_line(&amp;msg_grid, row, 0, msg_grid.dirty_col[row], msg_grid.cols,</a>
<a name="ln2438">              HL_ATTR(HLF_MSG), false);</a>
<a name="ln2439">      msg_grid.dirty_col[row] = 0;</a>
<a name="ln2440">    }</a>
<a name="ln2441">  }</a>
<a name="ln2442">  msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln2443">  msg_grid_scroll_discount = 0;</a>
<a name="ln2444">  msg_grid_pos_at_flush = msg_grid_pos;</a>
<a name="ln2445">}</a>
<a name="ln2446"> </a>
<a name="ln2447">void msg_reset_scroll(void)</a>
<a name="ln2448">{</a>
<a name="ln2449">  if (ui_has(kUIMessages)) {</a>
<a name="ln2450">    msg_ext_clear(true);</a>
<a name="ln2451">    return;</a>
<a name="ln2452">  }</a>
<a name="ln2453">  // TODO(bfredl): some duplicate logic with update_screen(). Later on</a>
<a name="ln2454">  // we should properly disentangle message clear with full screen redraw.</a>
<a name="ln2455">  msg_grid.throttled = false;</a>
<a name="ln2456">  // TODO(bfredl): risk for extra flicker i e with</a>
<a name="ln2457">  // &quot;nvim -o has_swap also_has_swap&quot;</a>
<a name="ln2458">  msg_grid_set_pos(Rows - (int)p_ch, false);</a>
<a name="ln2459">  clear_cmdline = true;</a>
<a name="ln2460">  if (msg_grid.chars) {</a>
<a name="ln2461">    // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln2462">    for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.rows); i++) {</a>
<a name="ln2463">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln2464">                      msg_grid.cols, false);</a>
<a name="ln2465">    }</a>
<a name="ln2466">  }</a>
<a name="ln2467">  msg_scrolled = 0;</a>
<a name="ln2468">  msg_scrolled_at_flush = 0;</a>
<a name="ln2469">  msg_grid_scroll_discount = 0;</a>
<a name="ln2470">}</a>
<a name="ln2471"> </a>
<a name="ln2472">/// Increment &quot;msg_scrolled&quot;.</a>
<a name="ln2473">static void inc_msg_scrolled(void)</a>
<a name="ln2474">{</a>
<a name="ln2475">  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {</a>
<a name="ln2476">    char *p = SOURCING_NAME;</a>
<a name="ln2477">    char *tofree = NULL;</a>
<a name="ln2478"> </a>
<a name="ln2479">    // v:scrollstart is empty, set it to the script/function name and line</a>
<a name="ln2480">    // number</a>
<a name="ln2481">    if (p == NULL) {</a>
<a name="ln2482">      p = _(&quot;Unknown&quot;);</a>
<a name="ln2483">    } else {</a>
<a name="ln2484">      size_t len = strlen(p) + 40;</a>
<a name="ln2485">      tofree = xmalloc(len);</a>
<a name="ln2486">      vim_snprintf(tofree, len, _(&quot;%s line %&quot; PRId64),</a>
<a name="ln2487">                   p, (int64_t)SOURCING_LNUM);</a>
<a name="ln2488">      p = tofree;</a>
<a name="ln2489">    }</a>
<a name="ln2490">    set_vim_var_string(VV_SCROLLSTART, p, -1);</a>
<a name="ln2491">    xfree(tofree);</a>
<a name="ln2492">  }</a>
<a name="ln2493">  msg_scrolled++;</a>
<a name="ln2494">  if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln2495">    must_redraw = UPD_VALID;</a>
<a name="ln2496">  }</a>
<a name="ln2497">}</a>
<a name="ln2498"> </a>
<a name="ln2499">static msgchunk_T *last_msgchunk = NULL;  // last displayed text</a>
<a name="ln2500"> </a>
<a name="ln2501">typedef enum {</a>
<a name="ln2502">  SB_CLEAR_NONE = 0,</a>
<a name="ln2503">  SB_CLEAR_ALL,</a>
<a name="ln2504">  SB_CLEAR_CMDLINE_BUSY,</a>
<a name="ln2505">  SB_CLEAR_CMDLINE_DONE,</a>
<a name="ln2506">} sb_clear_T;</a>
<a name="ln2507"> </a>
<a name="ln2508">// When to clear text on next msg.</a>
<a name="ln2509">static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2510"> </a>
<a name="ln2511">/// Store part of a printed message for displaying when scrolling back.</a>
<a name="ln2512">///</a>
<a name="ln2513">/// @param sb_str  start of string</a>
<a name="ln2514">/// @param s  just after string</a>
<a name="ln2515">/// @param finish  line ends</a>
<a name="ln2516">static void store_sb_text(const char **sb_str, const char *s, int attr, int *sb_col, int finish)</a>
<a name="ln2517">{</a>
<a name="ln2518">  msgchunk_T *mp;</a>
<a name="ln2519"> </a>
<a name="ln2520">  if (do_clear_sb_text == SB_CLEAR_ALL</a>
<a name="ln2521">      || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE) {</a>
<a name="ln2522">    clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);</a>
<a name="ln2523">    msg_sb_eol();  // prevent messages from overlapping</a>
<a name="ln2524">    do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2525">  }</a>
<a name="ln2526"> </a>
<a name="ln2527">  if (s &gt; *sb_str) {</a>
<a name="ln2528">    mp = xmalloc(offsetof(msgchunk_T, sb_text) + (size_t)(s - *sb_str) + 1);</a>
<a name="ln2529">    mp-&gt;sb_eol = (char)finish;</a>
<a name="ln2530">    mp-&gt;sb_msg_col = *sb_col;</a>
<a name="ln2531">    mp-&gt;sb_attr = attr;</a>
<a name="ln2532">    memcpy(mp-&gt;sb_text, *sb_str, (size_t)(s - *sb_str));</a>
<a name="ln2533">    mp-&gt;sb_text[s - *sb_str] = NUL;</a>
<a name="ln2534"> </a>
<a name="ln2535">    if (last_msgchunk == NULL) {</a>
<a name="ln2536">      last_msgchunk = mp;</a>
<a name="ln2537">      mp-&gt;sb_prev = NULL;</a>
<a name="ln2538">    } else {</a>
<a name="ln2539">      mp-&gt;sb_prev = last_msgchunk;</a>
<a name="ln2540">      last_msgchunk-&gt;sb_next = mp;</a>
<a name="ln2541">      last_msgchunk = mp;</a>
<a name="ln2542">    }</a>
<a name="ln2543">    mp-&gt;sb_next = NULL;</a>
<a name="ln2544">  } else if (finish &amp;&amp; last_msgchunk != NULL) {</a>
<a name="ln2545">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548">  *sb_str = s;</a>
<a name="ln2549">  *sb_col = 0;</a>
<a name="ln2550">}</a>
<a name="ln2551"> </a>
<a name="ln2552">/// Finished showing messages, clear the scroll-back text on the next message.</a>
<a name="ln2553">void may_clear_sb_text(void)</a>
<a name="ln2554">{</a>
<a name="ln2555">  do_clear_sb_text = SB_CLEAR_ALL;</a>
<a name="ln2556">}</a>
<a name="ln2557"> </a>
<a name="ln2558">/// Starting to edit the command line: do not clear messages now.</a>
<a name="ln2559">void sb_text_start_cmdline(void)</a>
<a name="ln2560">{</a>
<a name="ln2561">  if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY) {</a>
<a name="ln2562">    // Invoking command line recursively: the previous-level command line</a>
<a name="ln2563">    // doesn't need to be remembered as it will be redrawn when returning</a>
<a name="ln2564">    // to that level.</a>
<a name="ln2565">    sb_text_restart_cmdline();</a>
<a name="ln2566">  } else {</a>
<a name="ln2567">    msg_sb_eol();</a>
<a name="ln2568">    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2569">  }</a>
<a name="ln2570">}</a>
<a name="ln2571"> </a>
<a name="ln2572">/// Redrawing the command line: clear the last unfinished line.</a>
<a name="ln2573">void sb_text_restart_cmdline(void)</a>
<a name="ln2574">{</a>
<a name="ln2575">  // Needed when returning from nested command line.</a>
<a name="ln2576">  do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2577"> </a>
<a name="ln2578">  if (last_msgchunk == NULL || last_msgchunk-&gt;sb_eol) {</a>
<a name="ln2579">    // No unfinished line: don't clear anything.</a>
<a name="ln2580">    return;</a>
<a name="ln2581">  }</a>
<a name="ln2582"> </a>
<a name="ln2583">  msgchunk_T *tofree = msg_sb_start(last_msgchunk);</a>
<a name="ln2584">  last_msgchunk = tofree-&gt;sb_prev;</a>
<a name="ln2585">  if (last_msgchunk != NULL) {</a>
<a name="ln2586">    last_msgchunk-&gt;sb_next = NULL;</a>
<a name="ln2587">  }</a>
<a name="ln2588">  while (tofree != NULL) {</a>
<a name="ln2589">    msgchunk_T *tofree_next = tofree-&gt;sb_next;</a>
<a name="ln2590">    xfree(tofree);</a>
<a name="ln2591">    tofree = tofree_next;</a>
<a name="ln2592">  }</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">/// Ending to edit the command line: clear old lines but the last one later.</a>
<a name="ln2596">void sb_text_end_cmdline(void)</a>
<a name="ln2597">{</a>
<a name="ln2598">  do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;</a>
<a name="ln2599">}</a>
<a name="ln2600"> </a>
<a name="ln2601">/// Clear any text remembered for scrolling back.</a>
<a name="ln2602">/// When &quot;all&quot; is false keep the last line.</a>
<a name="ln2603">/// Called when redrawing the screen.</a>
<a name="ln2604">void clear_sb_text(int all)</a>
<a name="ln2605">{</a>
<a name="ln2606">  msgchunk_T *mp;</a>
<a name="ln2607">  msgchunk_T **lastp;</a>
<a name="ln2608"> </a>
<a name="ln2609">  if (all) {</a>
<a name="ln2610">    lastp = &amp;last_msgchunk;</a>
<a name="ln2611">  } else {</a>
<a name="ln2612">    if (last_msgchunk == NULL) {</a>
<a name="ln2613">      return;</a>
<a name="ln2614">    }</a>
<a name="ln2615">    lastp = &amp;msg_sb_start(last_msgchunk)-&gt;sb_prev;</a>
<a name="ln2616">  }</a>
<a name="ln2617"> </a>
<a name="ln2618">  while (*lastp != NULL) {</a>
<a name="ln2619">    mp = (*lastp)-&gt;sb_prev;</a>
<a name="ln2620">    xfree(*lastp);</a>
<a name="ln2621">    *lastp = mp;</a>
<a name="ln2622">  }</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625">/// &quot;g&lt;&quot; command.</a>
<a name="ln2626">void show_sb_text(void)</a>
<a name="ln2627">{</a>
<a name="ln2628">  msgchunk_T *mp;</a>
<a name="ln2629"> </a>
<a name="ln2630">  // Only show something if there is more than one line, otherwise it looks</a>
<a name="ln2631">  // weird, typing a command without output results in one line.</a>
<a name="ln2632">  mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2633">  if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2634">    vim_beep(BO_MESS);</a>
<a name="ln2635">  } else {</a>
<a name="ln2636">    do_more_prompt('G');</a>
<a name="ln2637">    wait_return(false);</a>
<a name="ln2638">  }</a>
<a name="ln2639">}</a>
<a name="ln2640"> </a>
<a name="ln2641">/// Move to the start of screen line in already displayed text.</a>
<a name="ln2642">static msgchunk_T *msg_sb_start(msgchunk_T *mps)</a>
<a name="ln2643">{</a>
<a name="ln2644">  msgchunk_T *mp = mps;</a>
<a name="ln2645"> </a>
<a name="ln2646">  while (mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL &amp;&amp; !mp-&gt;sb_prev-&gt;sb_eol) {</a>
<a name="ln2647">    mp = mp-&gt;sb_prev;</a>
<a name="ln2648">  }</a>
<a name="ln2649">  return mp;</a>
<a name="ln2650">}</a>
<a name="ln2651"> </a>
<a name="ln2652">/// Mark the last message chunk as finishing the line.</a>
<a name="ln2653">void msg_sb_eol(void)</a>
<a name="ln2654">{</a>
<a name="ln2655">  if (last_msgchunk != NULL) {</a>
<a name="ln2656">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2657">  }</a>
<a name="ln2658">}</a>
<a name="ln2659"> </a>
<a name="ln2660">/// Display a screen line from previously displayed text at row &quot;row&quot;.</a>
<a name="ln2661">///</a>
<a name="ln2662">/// @return  a pointer to the text for the next line (can be NULL).</a>
<a name="ln2663">static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp)</a>
<a name="ln2664">{</a>
<a name="ln2665">  msgchunk_T *mp = smp;</a>
<a name="ln2666"> </a>
<a name="ln2667">  while (true) {</a>
<a name="ln2668">    msg_row = row;</a>
<a name="ln2669">    msg_col = mp-&gt;sb_msg_col;</a>
<a name="ln2670">    char *p = mp-&gt;sb_text;</a>
<a name="ln2671">    if (*p == '\n') {       // don't display the line break</a>
<a name="ln2672">      p++;</a>
<a name="ln2673">    }</a>
<a name="ln2674">    msg_puts_display(p, -1, mp-&gt;sb_attr, true);</a>
<a name="ln2675">    if (mp-&gt;sb_eol || mp-&gt;sb_next == NULL) {</a>
<a name="ln2676">      break;</a>
<a name="ln2677">    }</a>
<a name="ln2678">    mp = mp-&gt;sb_next;</a>
<a name="ln2679">  }</a>
<a name="ln2680"> </a>
<a name="ln2681">  return mp-&gt;sb_next;</a>
<a name="ln2682">}</a>
<a name="ln2683"> </a>
<a name="ln2684">/// Output any postponed text for msg_puts_attr_len().</a>
<a name="ln2685">static void t_puts(int *t_col, const char *t_s, const char *s, int attr)</a>
<a name="ln2686">{</a>
<a name="ln2687">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2688">  // Output postponed text.</a>
<a name="ln2689">  msg_didout = true;  // Remember that line is not empty.</a>
<a name="ln2690">  grid_puts_len(&amp;msg_grid_adj, t_s, (int)(s - t_s), msg_row, msg_col, attr);</a>
<a name="ln2691">  msg_col += *t_col;</a>
<a name="ln2692">  *t_col = 0;</a>
<a name="ln2693">  // If the string starts with a composing character don't increment the</a>
<a name="ln2694">  // column position for it.</a>
<a name="ln2695">  if (utf_iscomposing(utf_ptr2char(t_s))) {</a>
<a name="ln2696">    msg_col--;</a>
<a name="ln2697">  }</a>
<a name="ln2698">  if (msg_col &gt;= Columns) {</a>
<a name="ln2699">    msg_col = 0;</a>
<a name="ln2700">    msg_row++;</a>
<a name="ln2701">  }</a>
<a name="ln2702">}</a>
<a name="ln2703"> </a>
<a name="ln2704">/// @return  true when messages should be printed to stdout/stderr:</a>
<a name="ln2705">///          - &quot;batch mode&quot; (&quot;silent mode&quot;, -es/-Es)</a>
<a name="ln2706">///          - no UI and not embedded</a>
<a name="ln2707">int msg_use_printf(void)</a>
<a name="ln2708">{</a>
<a name="ln2709">  return !embedded_mode &amp;&amp; !ui_active();</a>
<a name="ln2710">}</a>
<a name="ln2711"> </a>
<a name="ln2712">/// Print a message when there is no valid screen.</a>
<a name="ln2713">static void msg_puts_printf(const char *str, const ptrdiff_t maxlen)</a>
<a name="ln2714">{</a>
<a name="ln2715">  const char *s = str;</a>
<a name="ln2716">  char buf[7];</a>
<a name="ln2717">  char *p;</a>
<a name="ln2718"> </a>
<a name="ln2719">  if (on_print.type != kCallbackNone) {</a>
<a name="ln2720">    typval_T argv[1];</a>
<a name="ln2721">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2722">    argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln2723">    argv[0].vval.v_string = (char *)str;</a>
<a name="ln2724">    typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln2725">    callback_call(&amp;on_print, 1, argv, &amp;rettv);</a>
<a name="ln2726">    tv_clear(&amp;rettv);</a>
<a name="ln2727">    return;</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730">  while ((maxlen &lt; 0 || s - str &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2731">    int len = utf_ptr2len(s);</a>
<a name="ln2732">    if (!(silent_mode &amp;&amp; p_verbose == 0)) {</a>
<a name="ln2733">      // NL --&gt; CR NL translation (for Unix, not for &quot;--version&quot;)</a>
<a name="ln2734">      p = &amp;buf[0];</a>
<a name="ln2735">      if (*s == '\n' &amp;&amp; !info_message) {</a>
<a name="ln2736">        *p++ = '\r';</a>
<a name="ln2737">      }</a>
<a name="ln2738">      memcpy(p, s, (size_t)len);</a>
<a name="ln2739">      *(p + len) = '\0';</a>
<a name="ln2740">      if (info_message) {</a>
<a name="ln2741">        os_msg(buf);</a>
<a name="ln2742">      } else {</a>
<a name="ln2743">        os_errmsg(buf);</a>
<a name="ln2744">      }</a>
<a name="ln2745">    }</a>
<a name="ln2746"> </a>
<a name="ln2747">    int cw = utf_char2cells(utf_ptr2char(s));</a>
<a name="ln2748">    // primitive way to compute the current column</a>
<a name="ln2749">    if (cmdmsg_rl) {</a>
<a name="ln2750">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2751">        msg_col = Columns - 1;</a>
<a name="ln2752">      } else {</a>
<a name="ln2753">        msg_col -= cw;</a>
<a name="ln2754">      }</a>
<a name="ln2755">    } else {</a>
<a name="ln2756">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2757">        msg_col = 0;</a>
<a name="ln2758">      } else {</a>
<a name="ln2759">        msg_col += cw;</a>
<a name="ln2760">      }</a>
<a name="ln2761">    }</a>
<a name="ln2762">    s += len;</a>
<a name="ln2763">  }</a>
<a name="ln2764">  msg_didout = true;  // assume that line is not empty</a>
<a name="ln2765">}</a>
<a name="ln2766"> </a>
<a name="ln2767">/// Show the more-prompt and handle the user response.</a>
<a name="ln2768">/// This takes care of scrolling back and displaying previously displayed text.</a>
<a name="ln2769">/// When at hit-enter prompt &quot;typed_char&quot; is the already typed character,</a>
<a name="ln2770">/// otherwise it's NUL.</a>
<a name="ln2771">///</a>
<a name="ln2772">/// @return  true when jumping ahead to &quot;confirm_msg_tail&quot;.</a>
<a name="ln2773">static int do_more_prompt(int typed_char)</a>
<a name="ln2774">{</a>
<a name="ln2775">  static bool entered = false;</a>
<a name="ln2776">  int used_typed_char = typed_char;</a>
<a name="ln2777">  int oldState = State;</a>
<a name="ln2778">  int c;</a>
<a name="ln2779">  int retval = false;</a>
<a name="ln2780">  bool to_redraw = false;</a>
<a name="ln2781">  msgchunk_T *mp_last = NULL;</a>
<a name="ln2782">  msgchunk_T *mp;</a>
<a name="ln2783">  int i;</a>
<a name="ln2784"> </a>
<a name="ln2785">  // If headless mode is enabled and no input is required, this variable</a>
<a name="ln2786">  // will be true. However If server mode is enabled, the message &quot;--more--&quot;</a>
<a name="ln2787">  // should be displayed.</a>
<a name="ln2788">  bool no_need_more = headless_mode &amp;&amp; !embedded_mode;</a>
<a name="ln2789"> </a>
<a name="ln2790">  // We get called recursively when a timer callback outputs a message. In</a>
<a name="ln2791">  // that case don't show another prompt. Also when at the hit-Enter prompt</a>
<a name="ln2792">  // and nothing was typed.</a>
<a name="ln2793">  if (no_need_more || entered || (State == MODE_HITRETURN &amp;&amp; typed_char == 0)) {</a>
<a name="ln2794">    return false;</a>
<a name="ln2795">  }</a>
<a name="ln2796">  entered = true;</a>
<a name="ln2797"> </a>
<a name="ln2798">  if (typed_char == 'G') {</a>
<a name="ln2799">    // &quot;g&lt;&quot;: Find first line on the last page.</a>
<a name="ln2800">    mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2801">    for (i = 0; i &lt; Rows - 2 &amp;&amp; mp_last != NULL</a>
<a name="ln2802">         &amp;&amp; mp_last-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2803">      mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2804">    }</a>
<a name="ln2805">  }</a>
<a name="ln2806"> </a>
<a name="ln2807">  State = MODE_ASKMORE;</a>
<a name="ln2808">  setmouse();</a>
<a name="ln2809">  if (typed_char == NUL) {</a>
<a name="ln2810">    msg_moremsg(false);</a>
<a name="ln2811">  }</a>
<a name="ln2812">  while (true) {</a>
<a name="ln2813">    // Get a typed character directly from the user.</a>
<a name="ln2814">    if (used_typed_char != NUL) {</a>
<a name="ln2815">      c = used_typed_char;              // was typed at hit-enter prompt</a>
<a name="ln2816">      used_typed_char = NUL;</a>
<a name="ln2817">    } else {</a>
<a name="ln2818">      c = get_keystroke(resize_events);</a>
<a name="ln2819">    }</a>
<a name="ln2820"> </a>
<a name="ln2821">    int toscroll = 0;</a>
<a name="ln2822">    switch (c) {</a>
<a name="ln2823">    case BS:                    // scroll one line back</a>
<a name="ln2824">    case K_BS:</a>
<a name="ln2825">    case 'k':</a>
<a name="ln2826">    case K_UP:</a>
<a name="ln2827">      toscroll = -1;</a>
<a name="ln2828">      break;</a>
<a name="ln2829"> </a>
<a name="ln2830">    case CAR:                   // one extra line</a>
<a name="ln2831">    case NL:</a>
<a name="ln2832">    case 'j':</a>
<a name="ln2833">    case K_DOWN:</a>
<a name="ln2834">      toscroll = 1;</a>
<a name="ln2835">      break;</a>
<a name="ln2836"> </a>
<a name="ln2837">    case 'u':                   // Up half a page</a>
<a name="ln2838">      toscroll = -(Rows / 2);</a>
<a name="ln2839">      break;</a>
<a name="ln2840"> </a>
<a name="ln2841">    case 'd':                   // Down half a page</a>
<a name="ln2842">      toscroll = Rows / 2;</a>
<a name="ln2843">      break;</a>
<a name="ln2844"> </a>
<a name="ln2845">    case 'b':                   // one page back</a>
<a name="ln2846">    case K_PAGEUP:</a>
<a name="ln2847">      toscroll = -(Rows - 1);</a>
<a name="ln2848">      break;</a>
<a name="ln2849"> </a>
<a name="ln2850">    case ' ':                   // one extra page</a>
<a name="ln2851">    case 'f':</a>
<a name="ln2852">    case K_PAGEDOWN:</a>
<a name="ln2853">    case K_LEFTMOUSE:</a>
<a name="ln2854">      toscroll = Rows - 1;</a>
<a name="ln2855">      break;</a>
<a name="ln2856"> </a>
<a name="ln2857">    case 'g':                   // all the way back to the start</a>
<a name="ln2858">      toscroll = -999999;</a>
<a name="ln2859">      break;</a>
<a name="ln2860"> </a>
<a name="ln2861">    case 'G':                   // all the way to the end</a>
<a name="ln2862">      toscroll = 999999;</a>
<a name="ln2863">      lines_left = 999999;</a>
<a name="ln2864">      break;</a>
<a name="ln2865"> </a>
<a name="ln2866">    case ':':                   // start new command line</a>
<a name="ln2867">      if (!confirm_msg_used) {</a>
<a name="ln2868">        // Since got_int is set all typeahead will be flushed, but we</a>
<a name="ln2869">        // want to keep this ':', remember that in a special way.</a>
<a name="ln2870">        typeahead_noflush(':');</a>
<a name="ln2871">        cmdline_row = Rows - 1;                 // put ':' on this line</a>
<a name="ln2872">        skip_redraw = true;                     // skip redraw once</a>
<a name="ln2873">        need_wait_return = false;               // don't wait in main()</a>
<a name="ln2874">      }</a>
<a name="ln2875">      FALLTHROUGH;</a>
<a name="ln2876">    case 'q':                   // quit</a>
<a name="ln2877">    case Ctrl_C:</a>
<a name="ln2878">    case ESC:</a>
<a name="ln2879">      if (confirm_msg_used) {</a>
<a name="ln2880">        // Jump to the choices of the dialog.</a>
<a name="ln2881">        retval = true;</a>
<a name="ln2882">      } else {</a>
<a name="ln2883">        got_int = true;</a>
<a name="ln2884">        quit_more = true;</a>
<a name="ln2885">      }</a>
<a name="ln2886">      // When there is some more output (wrapping line) display that</a>
<a name="ln2887">      // without another prompt.</a>
<a name="ln2888">      lines_left = Rows - 1;</a>
<a name="ln2889">      break;</a>
<a name="ln2890"> </a>
<a name="ln2891">    case K_EVENT:</a>
<a name="ln2892">      // only resize_events are processed here</a>
<a name="ln2893">      // Attempt to redraw the screen. sb_text doesn't support reflow</a>
<a name="ln2894">      // so this only really works for vertical resize.</a>
<a name="ln2895">      multiqueue_process_events(resize_events);</a>
<a name="ln2896">      to_redraw = true;</a>
<a name="ln2897">      break;</a>
<a name="ln2898"> </a>
<a name="ln2899">    default:                    // no valid response</a>
<a name="ln2900">      msg_moremsg(true);</a>
<a name="ln2901">      continue;</a>
<a name="ln2902">    }</a>
<a name="ln2903"> </a>
<a name="ln2904">    // code assumes we only do one at a time</a>
<a name="ln2905">    assert((toscroll == 0) || !to_redraw);</a>
<a name="ln2906"> </a>
<a name="ln2907">    if (toscroll != 0 || to_redraw) {</a>
<a name="ln2908">      if (toscroll &lt; 0 || to_redraw) {</a>
<a name="ln2909">        // go to start of last line</a>
<a name="ln2910">        if (mp_last == NULL) {</a>
<a name="ln2911">          mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2912">        } else if (mp_last-&gt;sb_prev != NULL) {</a>
<a name="ln2913">          mp = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2914">        } else {</a>
<a name="ln2915">          mp = NULL;</a>
<a name="ln2916">        }</a>
<a name="ln2917"> </a>
<a name="ln2918">        // go to start of line at top of the screen</a>
<a name="ln2919">        for (i = 0; i &lt; Rows - 2 &amp;&amp; mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2920">          mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2921">        }</a>
<a name="ln2922"> </a>
<a name="ln2923">        if (mp != NULL &amp;&amp; (mp-&gt;sb_prev != NULL || to_redraw)) {</a>
<a name="ln2924">          // Find line to be displayed at top</a>
<a name="ln2925">          for (i = 0; i &gt; toscroll; i--) {</a>
<a name="ln2926">            if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2927">              break;</a>
<a name="ln2928">            }</a>
<a name="ln2929">            mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2930">            if (mp_last == NULL) {</a>
<a name="ln2931">              mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2932">            } else {</a>
<a name="ln2933">              mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2934">            }</a>
<a name="ln2935">          }</a>
<a name="ln2936"> </a>
<a name="ln2937">          if (toscroll == -1 &amp;&amp; !to_redraw) {</a>
<a name="ln2938">            grid_ins_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2939">            grid_fill(&amp;msg_grid_adj, 0, 1, 0, Columns, ' ', ' ',</a>
<a name="ln2940">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2941">            // display line at top</a>
<a name="ln2942">            (void)disp_sb_line(0, mp);</a>
<a name="ln2943">          } else {</a>
<a name="ln2944">            // redisplay all lines</a>
<a name="ln2945">            // TODO(bfredl): this case is not optimized (though only concerns</a>
<a name="ln2946">            // event fragmentization, not unnecessary scroll events).</a>
<a name="ln2947">            grid_fill(&amp;msg_grid_adj, 0, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2948">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2949">            for (i = 0; mp != NULL &amp;&amp; i &lt; Rows - 1; i++) {</a>
<a name="ln2950">              mp = disp_sb_line(i, mp);</a>
<a name="ln2951">              msg_scrolled++;</a>
<a name="ln2952">            }</a>
<a name="ln2953">            to_redraw = false;</a>
<a name="ln2954">          }</a>
<a name="ln2955">          toscroll = 0;</a>
<a name="ln2956">        }</a>
<a name="ln2957">      } else {</a>
<a name="ln2958">        // First display any text that we scrolled back.</a>
<a name="ln2959">        // if p_ch=0 we need to allocate a line for &quot;press enter&quot; messages!</a>
<a name="ln2960">        if (cmdline_row &gt;= Rows &amp;&amp; !ui_has(kUIMessages)) {</a>
<a name="ln2961">          msg_scroll_up(true, false);</a>
<a name="ln2962">          msg_scrolled++;</a>
<a name="ln2963">        }</a>
<a name="ln2964">        while (toscroll &gt; 0 &amp;&amp; mp_last != NULL) {</a>
<a name="ln2965">          if (msg_do_throttle() &amp;&amp; !msg_grid.throttled) {</a>
<a name="ln2966">            // Tricky: we redraw at one line higher than usual. Therefore</a>
<a name="ln2967">            // the non-flushed area is one line larger.</a>
<a name="ln2968">            msg_scrolled_at_flush--;</a>
<a name="ln2969">            msg_grid_scroll_discount++;</a>
<a name="ln2970">          }</a>
<a name="ln2971">          // scroll up, display line at bottom</a>
<a name="ln2972">          msg_scroll_up(true, false);</a>
<a name="ln2973">          inc_msg_scrolled();</a>
<a name="ln2974">          grid_fill(&amp;msg_grid_adj, Rows - 2, Rows - 1, 0, Columns, ' ', ' ',</a>
<a name="ln2975">                    HL_ATTR(HLF_MSG));</a>
<a name="ln2976">          mp_last = disp_sb_line(Rows - 2, mp_last);</a>
<a name="ln2977">          toscroll--;</a>
<a name="ln2978">        }</a>
<a name="ln2979">      }</a>
<a name="ln2980"> </a>
<a name="ln2981">      if (toscroll &lt;= 0) {</a>
<a name="ln2982">        // displayed the requested text, more prompt again</a>
<a name="ln2983">        grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2984">                  HL_ATTR(HLF_MSG));</a>
<a name="ln2985">        msg_moremsg(false);</a>
<a name="ln2986">        continue;</a>
<a name="ln2987">      }</a>
<a name="ln2988"> </a>
<a name="ln2989">      // display more text, return to caller</a>
<a name="ln2990">      lines_left = toscroll;</a>
<a name="ln2991">    }</a>
<a name="ln2992"> </a>
<a name="ln2993">    break;</a>
<a name="ln2994">  }</a>
<a name="ln2995"> </a>
<a name="ln2996">  // clear the --more-- message</a>
<a name="ln2997">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2998">            HL_ATTR(HLF_MSG));</a>
<a name="ln2999">  redraw_cmdline = true;</a>
<a name="ln3000">  clear_cmdline = false;</a>
<a name="ln3001">  mode_displayed = false;</a>
<a name="ln3002"> </a>
<a name="ln3003">  State = oldState;</a>
<a name="ln3004">  setmouse();</a>
<a name="ln3005">  if (quit_more) {</a>
<a name="ln3006">    msg_row = Rows - 1;</a>
<a name="ln3007">    msg_col = 0;</a>
<a name="ln3008">  } else if (cmdmsg_rl) {</a>
<a name="ln3009">    msg_col = Columns - 1;</a>
<a name="ln3010">  }</a>
<a name="ln3011"> </a>
<a name="ln3012">  entered = false;</a>
<a name="ln3013">  return retval;</a>
<a name="ln3014">}</a>
<a name="ln3015"> </a>
<a name="ln3016">#if defined(MSWIN)</a>
<a name="ln3017">/// Headless (no UI) error message handler.</a>
<a name="ln3018">static void do_msg(const char *str, bool errmsg)</a>
<a name="ln3019">{</a>
<a name="ln3020">  static bool did_err = false;</a>
<a name="ln3021">  assert(str != NULL);</a>
<a name="ln3022">  wchar_t *utf16str;</a>
<a name="ln3023">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln3024">  if (r != 0 &amp;&amp; !did_err) {</a>
<a name="ln3025">    did_err = true;</a>
<a name="ln3026">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln3027">    ELOG(&quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln3028">  } else if (r == 0) {</a>
<a name="ln3029">    if (errmsg) {</a>
<a name="ln3030">      fwprintf(stderr, L&quot;%ls&quot;, utf16str);</a>
<a name="ln3031">    } else {</a>
<a name="ln3032">      wprintf(L&quot;%ls&quot;, utf16str);</a>
<a name="ln3033">    }</a>
<a name="ln3034">    xfree(utf16str);</a>
<a name="ln3035">  }</a>
<a name="ln3036">}</a>
<a name="ln3037"> </a>
<a name="ln3038">void os_errmsg(const char *str)</a>
<a name="ln3039">{</a>
<a name="ln3040">  do_msg(str, true);</a>
<a name="ln3041">}</a>
<a name="ln3042"> </a>
<a name="ln3043">/// Headless (no UI) message handler.</a>
<a name="ln3044">void os_msg(const char *str)</a>
<a name="ln3045">{</a>
<a name="ln3046">  do_msg(str, false);</a>
<a name="ln3047">}</a>
<a name="ln3048">#endif  // MSWIN</a>
<a name="ln3049"> </a>
<a name="ln3050">/// Put a character on the screen at the current message position and advance</a>
<a name="ln3051">/// to the next position.  Only for printable ASCII!</a>
<a name="ln3052">static void msg_screen_putchar(int c, int attr)</a>
<a name="ln3053">{</a>
<a name="ln3054">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln3055">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln3056">  grid_putchar(&amp;msg_grid_adj, c, msg_row, msg_col, attr);</a>
<a name="ln3057">  if (cmdmsg_rl) {</a>
<a name="ln3058">    if (--msg_col == 0) {</a>
<a name="ln3059">      msg_col = Columns;</a>
<a name="ln3060">      msg_row++;</a>
<a name="ln3061">    }</a>
<a name="ln3062">  } else {</a>
<a name="ln3063">    if (++msg_col &gt;= Columns) {</a>
<a name="ln3064">      msg_col = 0;</a>
<a name="ln3065">      msg_row++;</a>
<a name="ln3066">    }</a>
<a name="ln3067">  }</a>
<a name="ln3068">}</a>
<a name="ln3069"> </a>
<a name="ln3070">void msg_moremsg(int full)</a>
<a name="ln3071">{</a>
<a name="ln3072">  int attr;</a>
<a name="ln3073">  char *s = _(&quot;-- More --&quot;);</a>
<a name="ln3074"> </a>
<a name="ln3075">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), HL_ATTR(HLF_M));</a>
<a name="ln3076">  grid_puts(&amp;msg_grid_adj, s, Rows - 1, 0, attr);</a>
<a name="ln3077">  if (full) {</a>
<a name="ln3078">    grid_puts(&amp;msg_grid_adj, _(&quot; SPACE/d/j: screen/page/line down, b/u/k: up, q: quit &quot;),</a>
<a name="ln3079">              Rows - 1, vim_strsize(s), attr);</a>
<a name="ln3080">  }</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">/// Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,</a>
<a name="ln3084">/// MODE_CONFIRM or exmode_active.</a>
<a name="ln3085">void repeat_message(void)</a>
<a name="ln3086">{</a>
<a name="ln3087">  if (State == MODE_ASKMORE) {</a>
<a name="ln3088">    msg_moremsg(true);          // display --more-- message again</a>
<a name="ln3089">    msg_row = Rows - 1;</a>
<a name="ln3090">  } else if (State == MODE_CONFIRM) {</a>
<a name="ln3091">    display_confirm_msg();      // display &quot;:confirm&quot; message again</a>
<a name="ln3092">    msg_row = Rows - 1;</a>
<a name="ln3093">  } else if (State == MODE_EXTERNCMD) {</a>
<a name="ln3094">    ui_cursor_goto(msg_row, msg_col);     // put cursor back</a>
<a name="ln3095">  } else if (State == MODE_HITRETURN || State == MODE_SETWSIZE) {</a>
<a name="ln3096">    if (msg_row == Rows - 1) {</a>
<a name="ln3097">      // Avoid drawing the &quot;hit-enter&quot; prompt below the previous one,</a>
<a name="ln3098">      // overwrite it.  Esp. useful when regaining focus and a</a>
<a name="ln3099">      // FocusGained autocmd exists but didn't draw anything.</a>
<a name="ln3100">      msg_didout = false;</a>
<a name="ln3101">      msg_col = 0;</a>
<a name="ln3102">      msg_clr_eos();</a>
<a name="ln3103">    }</a>
<a name="ln3104">    hit_return_msg();</a>
<a name="ln3105">    msg_row = Rows - 1;</a>
<a name="ln3106">  }</a>
<a name="ln3107">}</a>
<a name="ln3108"> </a>
<a name="ln3109">/// Clear from current message position to end of screen.</a>
<a name="ln3110">/// Skip this when &quot;:silent&quot; was used, no need to clear for redirection.</a>
<a name="ln3111">void msg_clr_eos(void)</a>
<a name="ln3112">{</a>
<a name="ln3113">  if (msg_silent == 0) {</a>
<a name="ln3114">    msg_clr_eos_force();</a>
<a name="ln3115">  }</a>
<a name="ln3116">}</a>
<a name="ln3117"> </a>
<a name="ln3118">/// Clear from current message position to end of screen.</a>
<a name="ln3119">/// Note: msg_col is not updated, so we remember the end of the message</a>
<a name="ln3120">/// for msg_check().</a>
<a name="ln3121">void msg_clr_eos_force(void)</a>
<a name="ln3122">{</a>
<a name="ln3123">  if (ui_has(kUIMessages)) {</a>
<a name="ln3124">    return;</a>
<a name="ln3125">  }</a>
<a name="ln3126">  int msg_startcol = (cmdmsg_rl) ? 0 : msg_col;</a>
<a name="ln3127">  int msg_endcol = (cmdmsg_rl) ? msg_col + 1 : Columns;</a>
<a name="ln3128"> </a>
<a name="ln3129">  if (msg_grid.chars &amp;&amp; msg_row &lt; msg_grid_pos) {</a>
<a name="ln3130">    // TODO(bfredl): ugly, this state should already been validated at this</a>
<a name="ln3131">    // point. But msg_clr_eos() is called in a lot of places.</a>
<a name="ln3132">    msg_row = msg_grid_pos;</a>
<a name="ln3133">  }</a>
<a name="ln3134"> </a>
<a name="ln3135">  grid_fill(&amp;msg_grid_adj, msg_row, msg_row + 1, msg_startcol, msg_endcol,</a>
<a name="ln3136">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3137">  grid_fill(&amp;msg_grid_adj, msg_row + 1, Rows, 0, Columns,</a>
<a name="ln3138">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3139"> </a>
<a name="ln3140">  redraw_cmdline = true;  // overwritten the command line</a>
<a name="ln3141">  if (msg_row &lt; Rows - 1 || msg_col == (cmdmsg_rl ? Columns : 0)) {</a>
<a name="ln3142">    clear_cmdline = false;  // command line has been cleared</a>
<a name="ln3143">    mode_displayed = false;  // mode cleared or overwritten</a>
<a name="ln3144">  }</a>
<a name="ln3145">}</a>
<a name="ln3146"> </a>
<a name="ln3147">/// Clear the command line.</a>
<a name="ln3148">void msg_clr_cmdline(void)</a>
<a name="ln3149">{</a>
<a name="ln3150">  msg_row = cmdline_row;</a>
<a name="ln3151">  msg_col = 0;</a>
<a name="ln3152">  msg_clr_eos_force();</a>
<a name="ln3153">}</a>
<a name="ln3154"> </a>
<a name="ln3155">/// end putting a message on the screen</a>
<a name="ln3156">/// call wait_return() if the message does not fit in the available space</a>
<a name="ln3157">///</a>
<a name="ln3158">/// @return  true if wait_return() not called.</a>
<a name="ln3159">int msg_end(void)</a>
<a name="ln3160">{</a>
<a name="ln3161">  // If the string is larger than the window,</a>
<a name="ln3162">  // or the ruler option is set and we run into it,</a>
<a name="ln3163">  // we have to redraw the window.</a>
<a name="ln3164">  // Do not do this if we are abandoning the file or editing the command line.</a>
<a name="ln3165">  if (!exiting &amp;&amp; need_wait_return &amp;&amp; !(State &amp; MODE_CMDLINE)) {</a>
<a name="ln3166">    wait_return(false);</a>
<a name="ln3167">    return false;</a>
<a name="ln3168">  }</a>
<a name="ln3169"> </a>
<a name="ln3170">  // NOTE: ui_flush() used to be called here. This had to be removed, as it</a>
<a name="ln3171">  // inhibited substantial performance improvements. It is assumed that relevant</a>
<a name="ln3172">  // callers invoke ui_flush() before going into CPU busywork, or restricted</a>
<a name="ln3173">  // event processing after displaying a message to the user.</a>
<a name="ln3174">  msg_ext_ui_flush();</a>
<a name="ln3175">  return true;</a>
<a name="ln3176">}</a>
<a name="ln3177"> </a>
<a name="ln3178">void msg_ext_ui_flush(void)</a>
<a name="ln3179">{</a>
<a name="ln3180">  if (!ui_has(kUIMessages)) {</a>
<a name="ln3181">    msg_ext_kind = NULL;</a>
<a name="ln3182">    return;</a>
<a name="ln3183">  }</a>
<a name="ln3184"> </a>
<a name="ln3185">  msg_ext_emit_chunk();</a>
<a name="ln3186">  if (msg_ext_chunks.size &gt; 0) {</a>
<a name="ln3187">    ui_call_msg_show(cstr_as_string((char *)msg_ext_kind),</a>
<a name="ln3188">                     msg_ext_chunks, msg_ext_overwrite);</a>
<a name="ln3189">    if (!msg_ext_overwrite) {</a>
<a name="ln3190">      msg_ext_visible++;</a>
<a name="ln3191">    }</a>
<a name="ln3192">    msg_ext_kind = NULL;</a>
<a name="ln3193">    api_free_array(msg_ext_chunks);</a>
<a name="ln3194">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3195">    msg_ext_cur_len = 0;</a>
<a name="ln3196">    msg_ext_overwrite = false;</a>
<a name="ln3197">  }</a>
<a name="ln3198">}</a>
<a name="ln3199"> </a>
<a name="ln3200">void msg_ext_flush_showmode(void)</a>
<a name="ln3201">{</a>
<a name="ln3202">  // Showmode messages doesn't interrupt normal message flow, so we use</a>
<a name="ln3203">  // separate event. Still reuse the same chunking logic, for simplicity.</a>
<a name="ln3204">  if (ui_has(kUIMessages)) {</a>
<a name="ln3205">    msg_ext_emit_chunk();</a>
<a name="ln3206">    ui_call_msg_showmode(msg_ext_chunks);</a>
<a name="ln3207">    api_free_array(msg_ext_chunks);</a>
<a name="ln3208">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3209">    msg_ext_cur_len = 0;</a>
<a name="ln3210">  }</a>
<a name="ln3211">}</a>
<a name="ln3212"> </a>
<a name="ln3213">void msg_ext_clear(bool force)</a>
<a name="ln3214">{</a>
<a name="ln3215">  if (msg_ext_visible &amp;&amp; (!msg_ext_keep_after_cmdline || force)) {</a>
<a name="ln3216">    ui_call_msg_clear();</a>
<a name="ln3217">    msg_ext_visible = 0;</a>
<a name="ln3218">    msg_ext_overwrite = false;  // nothing to overwrite</a>
<a name="ln3219">  }</a>
<a name="ln3220">  if (msg_ext_history_visible) {</a>
<a name="ln3221">    ui_call_msg_history_clear();</a>
<a name="ln3222">    msg_ext_history_visible = false;</a>
<a name="ln3223">  }</a>
<a name="ln3224"> </a>
<a name="ln3225">  // Only keep once.</a>
<a name="ln3226">  msg_ext_keep_after_cmdline = false;</a>
<a name="ln3227">}</a>
<a name="ln3228"> </a>
<a name="ln3229">void msg_ext_clear_later(void)</a>
<a name="ln3230">{</a>
<a name="ln3231">  if (msg_ext_is_visible()) {</a>
<a name="ln3232">    msg_ext_need_clear = true;</a>
<a name="ln3233">    if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln3234">      must_redraw = UPD_VALID;</a>
<a name="ln3235">    }</a>
<a name="ln3236">  }</a>
<a name="ln3237">}</a>
<a name="ln3238"> </a>
<a name="ln3239">void msg_ext_check_clear(void)</a>
<a name="ln3240">{</a>
<a name="ln3241">  // Redraw after cmdline or prompt is expected to clear messages.</a>
<a name="ln3242">  if (msg_ext_need_clear) {</a>
<a name="ln3243">    msg_ext_clear(true);</a>
<a name="ln3244">    msg_ext_need_clear = false;</a>
<a name="ln3245">  }</a>
<a name="ln3246">}</a>
<a name="ln3247"> </a>
<a name="ln3248">bool msg_ext_is_visible(void)</a>
<a name="ln3249">{</a>
<a name="ln3250">  return ui_has(kUIMessages) &amp;&amp; msg_ext_visible &gt; 0;</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">/// If the written message runs into the shown command or ruler, we have to</a>
<a name="ln3254">/// wait for hit-return and redraw the window later.</a>
<a name="ln3255">void msg_check(void)</a>
<a name="ln3256">{</a>
<a name="ln3257">  if (ui_has(kUIMessages)) {</a>
<a name="ln3258">    return;</a>
<a name="ln3259">  }</a>
<a name="ln3260">  if (msg_row == Rows - 1 &amp;&amp; msg_col &gt;= sc_col) {</a>
<a name="ln3261">    need_wait_return = true;</a>
<a name="ln3262">    redraw_cmdline = true;</a>
<a name="ln3263">  }</a>
<a name="ln3264">}</a>
<a name="ln3265"> </a>
<a name="ln3266">/// May write a string to the redirection file.</a>
<a name="ln3267">///</a>
<a name="ln3268">/// @param maxlen  if -1, write the whole string, otherwise up to &quot;maxlen&quot; bytes.</a>
<a name="ln3269">static void redir_write(const char *const str, const ptrdiff_t maxlen)</a>
<a name="ln3270">{</a>
<a name="ln3271">  const char *s = str;</a>
<a name="ln3272">  static int cur_col = 0;</a>
<a name="ln3273"> </a>
<a name="ln3274">  if (maxlen == 0) {</a>
<a name="ln3275">    return;</a>
<a name="ln3276">  }</a>
<a name="ln3277"> </a>
<a name="ln3278">  // Don't do anything for displaying prompts and the like.</a>
<a name="ln3279">  if (redir_off) {</a>
<a name="ln3280">    return;</a>
<a name="ln3281">  }</a>
<a name="ln3282"> </a>
<a name="ln3283">  // If 'verbosefile' is set prepare for writing in that file.</a>
<a name="ln3284">  if (*p_vfile != NUL &amp;&amp; verbose_fd == NULL) {</a>
<a name="ln3285">    verbose_open();</a>
<a name="ln3286">  }</a>
<a name="ln3287"> </a>
<a name="ln3288">  if (redirecting()) {</a>
<a name="ln3289">    // If the string doesn't start with CR or NL, go to msg_col</a>
<a name="ln3290">    if (*s != '\n' &amp;&amp; *s != '\r') {</a>
<a name="ln3291">      while (cur_col &lt; msg_col) {</a>
<a name="ln3292">        if (capture_ga) {</a>
<a name="ln3293">          ga_concat_len(capture_ga, &quot; &quot;, 1);</a>
<a name="ln3294">        }</a>
<a name="ln3295">        if (redir_reg) {</a>
<a name="ln3296">          write_reg_contents(redir_reg, &quot; &quot;, 1, true);</a>
<a name="ln3297">        } else if (redir_vname) {</a>
<a name="ln3298">          var_redir_str(&quot; &quot;, -1);</a>
<a name="ln3299">        } else if (redir_fd != NULL) {</a>
<a name="ln3300">          fputs(&quot; &quot;, redir_fd);</a>
<a name="ln3301">        }</a>
<a name="ln3302">        if (verbose_fd != NULL) {</a>
<a name="ln3303">          fputs(&quot; &quot;, verbose_fd);</a>
<a name="ln3304">        }</a>
<a name="ln3305">        cur_col++;</a>
<a name="ln3306">      }</a>
<a name="ln3307">    }</a>
<a name="ln3308"> </a>
<a name="ln3309">    size_t len = maxlen == -1 ? strlen(s) : (size_t)maxlen;</a>
<a name="ln3310">    if (capture_ga) {</a>
<a name="ln3311">      ga_concat_len(capture_ga, str, len);</a>
<a name="ln3312">    }</a>
<a name="ln3313">    if (redir_reg) {</a>
<a name="ln3314">      write_reg_contents(redir_reg, s, (ssize_t)len, true);</a>
<a name="ln3315">    }</a>
<a name="ln3316">    if (redir_vname) {</a>
<a name="ln3317">      var_redir_str(s, (int)maxlen);</a>
<a name="ln3318">    }</a>
<a name="ln3319"> </a>
<a name="ln3320">    // Write and adjust the current column.</a>
<a name="ln3321">    while (*s != NUL</a>
<a name="ln3322">           &amp;&amp; (maxlen &lt; 0 || (int)(s - str) &lt; maxlen)) {</a>
<a name="ln3323">      if (!redir_reg &amp;&amp; !redir_vname &amp;&amp; !capture_ga) {</a>
<a name="ln3324">        if (redir_fd != NULL) {</a>
<a name="ln3325">          putc(*s, redir_fd);</a>
<a name="ln3326">        }</a>
<a name="ln3327">      }</a>
<a name="ln3328">      if (verbose_fd != NULL) {</a>
<a name="ln3329">        putc(*s, verbose_fd);</a>
<a name="ln3330">      }</a>
<a name="ln3331">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln3332">        cur_col = 0;</a>
<a name="ln3333">      } else if (*s == '\t') {</a>
<a name="ln3334">        cur_col += (8 - cur_col % 8);</a>
<a name="ln3335">      } else {</a>
<a name="ln3336">        cur_col++;</a>
<a name="ln3337">      }</a>
<a name="ln3338">      s++;</a>
<a name="ln3339">    }</a>
<a name="ln3340"> </a>
<a name="ln3341">    if (msg_silent != 0) {      // should update msg_col</a>
<a name="ln3342">      msg_col = cur_col;</a>
<a name="ln3343">    }</a>
<a name="ln3344">  }</a>
<a name="ln3345">}</a>
<a name="ln3346"> </a>
<a name="ln3347">int redirecting(void)</a>
<a name="ln3348">{</a>
<a name="ln3349">  return redir_fd != NULL || *p_vfile != NUL</a>
<a name="ln3350">         || redir_reg || redir_vname || capture_ga != NULL;</a>
<a name="ln3351">}</a>
<a name="ln3352"> </a>
<a name="ln3353">/// Before giving verbose message.</a>
<a name="ln3354">/// Must always be called paired with verbose_leave()!</a>
<a name="ln3355">void verbose_enter(void)</a>
<a name="ln3356">{</a>
<a name="ln3357">  if (*p_vfile != NUL) {</a>
<a name="ln3358">    msg_silent++;</a>
<a name="ln3359">  }</a>
<a name="ln3360">}</a>
<a name="ln3361"> </a>
<a name="ln3362">/// After giving verbose message.</a>
<a name="ln3363">/// Must always be called paired with verbose_enter()!</a>
<a name="ln3364">void verbose_leave(void)</a>
<a name="ln3365">{</a>
<a name="ln3366">  if (*p_vfile != NUL) {</a>
<a name="ln3367">    if (--msg_silent &lt; 0) {</a>
<a name="ln3368">      msg_silent = 0;</a>
<a name="ln3369">    }</a>
<a name="ln3370">  }</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">/// Like verbose_enter() and set msg_scroll when displaying the message.</a>
<a name="ln3374">void verbose_enter_scroll(void)</a>
<a name="ln3375">{</a>
<a name="ln3376">  if (*p_vfile != NUL) {</a>
<a name="ln3377">    msg_silent++;</a>
<a name="ln3378">  } else {</a>
<a name="ln3379">    // always scroll up, don't overwrite</a>
<a name="ln3380">    msg_scroll = true;</a>
<a name="ln3381">  }</a>
<a name="ln3382">}</a>
<a name="ln3383"> </a>
<a name="ln3384">/// Like verbose_leave() and set cmdline_row when displaying the message.</a>
<a name="ln3385">void verbose_leave_scroll(void)</a>
<a name="ln3386">{</a>
<a name="ln3387">  if (*p_vfile != NUL) {</a>
<a name="ln3388">    if (--msg_silent &lt; 0) {</a>
<a name="ln3389">      msg_silent = 0;</a>
<a name="ln3390">    }</a>
<a name="ln3391">  } else {</a>
<a name="ln3392">    cmdline_row = msg_row;</a>
<a name="ln3393">  }</a>
<a name="ln3394">}</a>
<a name="ln3395"> </a>
<a name="ln3396">/// Called when 'verbosefile' is set: stop writing to the file.</a>
<a name="ln3397">void verbose_stop(void)</a>
<a name="ln3398">{</a>
<a name="ln3399">  if (verbose_fd != NULL) {</a>
<a name="ln3400">    fclose(verbose_fd);</a>
<a name="ln3401">    verbose_fd = NULL;</a>
<a name="ln3402">  }</a>
<a name="ln3403">  verbose_did_open = false;</a>
<a name="ln3404">}</a>
<a name="ln3405"> </a>
<a name="ln3406">/// Open the file 'verbosefile'.</a>
<a name="ln3407">///</a>
<a name="ln3408">/// @return  FAIL or OK.</a>
<a name="ln3409">int verbose_open(void)</a>
<a name="ln3410">{</a>
<a name="ln3411">  if (verbose_fd == NULL &amp;&amp; !verbose_did_open) {</a>
<a name="ln3412">    // Only give the error message once.</a>
<a name="ln3413">    verbose_did_open = true;</a>
<a name="ln3414"> </a>
<a name="ln3415">    verbose_fd = os_fopen(p_vfile, &quot;a&quot;);</a>
<a name="ln3416">    if (verbose_fd == NULL) {</a>
<a name="ln3417">      semsg(_(e_notopen), p_vfile);</a>
<a name="ln3418">      return FAIL;</a>
<a name="ln3419">    }</a>
<a name="ln3420">  }</a>
<a name="ln3421">  return OK;</a>
<a name="ln3422">}</a>
<a name="ln3423"> </a>
<a name="ln3424">/// Give a warning message (for searching).</a>
<a name="ln3425">/// Use 'w' highlighting and may repeat the message after redrawing</a>
<a name="ln3426">void give_warning(const char *message, bool hl)</a>
<a name="ln3427">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3428">{</a>
<a name="ln3429">  // Don't do this for &quot;:silent&quot;.</a>
<a name="ln3430">  if (msg_silent != 0) {</a>
<a name="ln3431">    return;</a>
<a name="ln3432">  }</a>
<a name="ln3433"> </a>
<a name="ln3434">  // Don't want a hit-enter prompt here.</a>
<a name="ln3435">  no_wait_return++;</a>
<a name="ln3436"> </a>
<a name="ln3437">  set_vim_var_string(VV_WARNINGMSG, message, -1);</a>
<a name="ln3438">  XFREE_CLEAR(keep_msg);</a>
<a name="ln3439">  if (hl) {</a>
<a name="ln3440">    keep_msg_attr = HL_ATTR(HLF_W);</a>
<a name="ln3441">  } else {</a>
<a name="ln3442">    keep_msg_attr = 0;</a>
<a name="ln3443">  }</a>
<a name="ln3444"> </a>
<a name="ln3445">  if (msg_ext_kind == NULL) {</a>
<a name="ln3446">    msg_ext_set_kind(&quot;wmsg&quot;);</a>
<a name="ln3447">  }</a>
<a name="ln3448"> </a>
<a name="ln3449">  if (msg_attr(message, keep_msg_attr) &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln3450">    set_keep_msg(message, keep_msg_attr);</a>
<a name="ln3451">  }</a>
<a name="ln3452">  msg_didout = false;  // Overwrite this message.</a>
<a name="ln3453">  msg_nowait = true;   // Don't wait for this message.</a>
<a name="ln3454">  msg_col = 0;</a>
<a name="ln3455"> </a>
<a name="ln3456">  no_wait_return--;</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">void give_warning2(const char *const message, const char *const a1, bool hl)</a>
<a name="ln3460">{</a>
<a name="ln3461">  vim_snprintf(IObuff, IOSIZE, message, a1);</a>
<a name="ln3462">  give_warning(IObuff, hl);</a>
<a name="ln3463">}</a>
<a name="ln3464"> </a>
<a name="ln3465">/// Advance msg cursor to column &quot;col&quot;.</a>
<a name="ln3466">void msg_advance(int col)</a>
<a name="ln3467">{</a>
<a name="ln3468">  if (msg_silent != 0) {        // nothing to advance to</a>
<a name="ln3469">    msg_col = col;              // for redirection, may fill it up later</a>
<a name="ln3470">    return;</a>
<a name="ln3471">  }</a>
<a name="ln3472">  if (ui_has(kUIMessages)) {</a>
<a name="ln3473">    // TODO(bfredl): use byte count as a basic proxy.</a>
<a name="ln3474">    // later on we might add proper support for formatted messages.</a>
<a name="ln3475">    while (msg_ext_cur_len &lt; (size_t)col) {</a>
<a name="ln3476">      msg_putchar(' ');</a>
<a name="ln3477">    }</a>
<a name="ln3478">    return;</a>
<a name="ln3479">  }</a>
<a name="ln3480">  if (col &gt;= Columns) {         // not enough room</a>
<a name="ln3481">    col = Columns - 1;</a>
<a name="ln3482">  }</a>
<a name="ln3483">  if (cmdmsg_rl) {</a>
<a name="ln3484">    while (msg_col &gt; Columns - col) {</a>
<a name="ln3485">      msg_putchar(' ');</a>
<a name="ln3486">    }</a>
<a name="ln3487">  } else {</a>
<a name="ln3488">    while (msg_col &lt; col) {</a>
<a name="ln3489">      msg_putchar(' ');</a>
<a name="ln3490">    }</a>
<a name="ln3491">  }</a>
<a name="ln3492">}</a>
<a name="ln3493"> </a>
<a name="ln3494">/// Used for &quot;confirm()&quot; function, and the :confirm command prefix.</a>
<a name="ln3495">/// Versions which haven't got flexible dialogs yet, and console</a>
<a name="ln3496">/// versions, get this generic handler which uses the command line.</a>
<a name="ln3497">///</a>
<a name="ln3498">/// type  = one of:</a>
<a name="ln3499">///         VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC</a>
<a name="ln3500">/// title = title string (can be NULL for default)</a>
<a name="ln3501">/// (neither used in console dialogs at the moment)</a>
<a name="ln3502">///</a>
<a name="ln3503">/// Format of the &quot;buttons&quot; string:</a>
<a name="ln3504">/// &quot;Button1Name\nButton2Name\nButton3Name&quot;</a>
<a name="ln3505">/// The first button should normally be the default/accept</a>
<a name="ln3506">/// The second button should be the 'Cancel' button</a>
<a name="ln3507">/// Other buttons- use your imagination!</a>
<a name="ln3508">/// A '&amp;' in a button name becomes a shortcut, so each '&amp;' should be before a</a>
<a name="ln3509">/// different letter.</a>
<a name="ln3510">///</a>
<a name="ln3511">/// @param textfiel  IObuff for inputdialog(), NULL otherwise</a>
<a name="ln3512">/// @param ex_cmd  when true pressing : accepts default and starts Ex command</a>
<a name="ln3513">/// @returns 0 if cancelled, otherwise the nth button (1-indexed).</a>
<a name="ln3514">int do_dialog(int type, char *title, char *message, char *buttons, int dfltbutton, char *textfield,</a>
<a name="ln3515">              int ex_cmd)</a>
<a name="ln3516">{</a>
<a name="ln3517">  int retval = 0;</a>
<a name="ln3518">  char *hotkeys;</a>
<a name="ln3519">  int i;</a>
<a name="ln3520"> </a>
<a name="ln3521">  if (silent_mode      // No dialogs in silent mode (&quot;ex -s&quot;)</a>
<a name="ln3522">      || !ui_active()  // Without a UI Nvim waits for input forever.</a>
<a name="ln3523">      ) {</a>
<a name="ln3524">    return dfltbutton;  // return default option</a>
<a name="ln3525">  }</a>
<a name="ln3526"> </a>
<a name="ln3527">  int save_msg_silent = msg_silent;</a>
<a name="ln3528">  int oldState = State;</a>
<a name="ln3529"> </a>
<a name="ln3530">  msg_silent = 0;  // If dialog prompts for input, user needs to see it! #8788</a>
<a name="ln3531">  State = MODE_CONFIRM;</a>
<a name="ln3532">  setmouse();</a>
<a name="ln3533"> </a>
<a name="ln3534">  // Since we wait for a keypress, don't make the</a>
<a name="ln3535">  // user press RETURN as well afterwards.</a>
<a name="ln3536">  no_wait_return++;</a>
<a name="ln3537">  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);</a>
<a name="ln3538"> </a>
<a name="ln3539">  while (true) {</a>
<a name="ln3540">    // Get a typed character directly from the user.</a>
<a name="ln3541">    int c = get_keystroke(NULL);</a>
<a name="ln3542">    switch (c) {</a>
<a name="ln3543">    case CAR:                 // User accepts default option</a>
<a name="ln3544">    case NL:</a>
<a name="ln3545">      retval = dfltbutton;</a>
<a name="ln3546">      break;</a>
<a name="ln3547">    case Ctrl_C:              // User aborts/cancels</a>
<a name="ln3548">    case ESC:</a>
<a name="ln3549">      retval = 0;</a>
<a name="ln3550">      break;</a>
<a name="ln3551">    default:                  // Could be a hotkey?</a>
<a name="ln3552">      if (c &lt; 0) {            // special keys are ignored here</a>
<a name="ln3553">        continue;</a>
<a name="ln3554">      }</a>
<a name="ln3555">      if (c == ':' &amp;&amp; ex_cmd) {</a>
<a name="ln3556">        retval = dfltbutton;</a>
<a name="ln3557">        ins_char_typebuf(':', 0);</a>
<a name="ln3558">        break;</a>
<a name="ln3559">      }</a>
<a name="ln3560"> </a>
<a name="ln3561">      // Make the character lowercase, as chars in &quot;hotkeys&quot; are.</a>
<a name="ln3562">      c = mb_tolower(c);</a>
<a name="ln3563">      retval = 1;</a>
<a name="ln3564">      for (i = 0; hotkeys[i]; i++) {</a>
<a name="ln3565">        if (utf_ptr2char(hotkeys + i) == c) {</a>
<a name="ln3566">          break;</a>
<a name="ln3567">        }</a>
<a name="ln3568">        i += utfc_ptr2len(hotkeys + i) - 1;</a>
<a name="ln3569">        retval++;</a>
<a name="ln3570">      }</a>
<a name="ln3571">      if (hotkeys[i]) {</a>
<a name="ln3572">        break;</a>
<a name="ln3573">      }</a>
<a name="ln3574">      // No hotkey match, so keep waiting</a>
<a name="ln3575">      continue;</a>
<a name="ln3576">    }</a>
<a name="ln3577">    break;</a>
<a name="ln3578">  }</a>
<a name="ln3579"> </a>
<a name="ln3580">  xfree(hotkeys);</a>
<a name="ln3581"> </a>
<a name="ln3582">  msg_silent = save_msg_silent;</a>
<a name="ln3583">  State = oldState;</a>
<a name="ln3584">  setmouse();</a>
<a name="ln3585">  no_wait_return--;</a>
<a name="ln3586">  msg_end_prompt();</a>
<a name="ln3587"> </a>
<a name="ln3588">  return retval;</a>
<a name="ln3589">}</a>
<a name="ln3590"> </a>
<a name="ln3591">/// Copy one character from &quot;*from&quot; to &quot;*to&quot;, taking care of multi-byte</a>
<a name="ln3592">/// characters.  Return the length of the character in bytes.</a>
<a name="ln3593">///</a>
<a name="ln3594">/// @param lowercase  make character lower case</a>
<a name="ln3595">static int copy_char(const char *from, char *to, bool lowercase)</a>
<a name="ln3596">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3597">{</a>
<a name="ln3598">  if (lowercase) {</a>
<a name="ln3599">    int c = mb_tolower(utf_ptr2char(from));</a>
<a name="ln3600">    return utf_char2bytes(c, to);</a>
<a name="ln3601">  }</a>
<a name="ln3602">  int len = utfc_ptr2len(from);</a>
<a name="ln3603">  memmove(to, from, (size_t)len);</a>
<a name="ln3604">  return len;</a>
<a name="ln3605">}</a>
<a name="ln3606"> </a>
<a name="ln3607">#define HAS_HOTKEY_LEN 30</a>
<a name="ln3608">#define HOTK_LEN MB_MAXBYTES</a>
<a name="ln3609"> </a>
<a name="ln3610">/// Allocates memory for dialog string &amp; for storing hotkeys</a>
<a name="ln3611">///</a>
<a name="ln3612">/// Finds the size of memory required for the confirm_msg &amp; for storing hotkeys</a>
<a name="ln3613">/// and then allocates the memory for them.</a>
<a name="ln3614">/// has_hotkey array is also filled-up.</a>
<a name="ln3615">///</a>
<a name="ln3616">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3617">/// @param buttons String containing button names</a>
<a name="ln3618">/// @param[out] has_hotkey An element in this array is set to true if</a>
<a name="ln3619">///                        corresponding button has a hotkey</a>
<a name="ln3620">///</a>
<a name="ln3621">/// @return Pointer to memory allocated for storing hotkeys</a>
<a name="ln3622">static char *console_dialog_alloc(const char *message, char *buttons, bool has_hotkey[])</a>
<a name="ln3623">{</a>
<a name="ln3624">  int lenhotkey = HOTK_LEN;  // count first button</a>
<a name="ln3625">  has_hotkey[0] = false;</a>
<a name="ln3626"> </a>
<a name="ln3627">  // Compute the size of memory to allocate.</a>
<a name="ln3628">  int len = 0;</a>
<a name="ln3629">  int idx = 0;</a>
<a name="ln3630">  char *r = buttons;</a>
<a name="ln3631">  while (*r) {</a>
<a name="ln3632">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3633">      len += 3;                         // '\n' -&gt; ', '; 'x' -&gt; '(x)'</a>
<a name="ln3634">      lenhotkey += HOTK_LEN;            // each button needs a hotkey</a>
<a name="ln3635">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3636">        has_hotkey[++idx] = false;</a>
<a name="ln3637">      }</a>
<a name="ln3638">    } else if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3639">      r++;</a>
<a name="ln3640">      len++;                    // '&amp;a' -&gt; '[a]'</a>
<a name="ln3641">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3642">        has_hotkey[idx] = true;</a>
<a name="ln3643">      }</a>
<a name="ln3644">    }</a>
<a name="ln3645"> </a>
<a name="ln3646">    // Advance to the next character</a>
<a name="ln3647">    MB_PTR_ADV(r);</a>
<a name="ln3648">  }</a>
<a name="ln3649"> </a>
<a name="ln3650">  len += (int)(strlen(message)</a>
<a name="ln3651">               + 2                          // for the NL's</a>
<a name="ln3652">               + strlen(buttons)</a>
<a name="ln3653">               + 3);                        // for the &quot;: &quot; and NUL</a>
<a name="ln3654">  lenhotkey++;                               // for the NUL</a>
<a name="ln3655"> </a>
<a name="ln3656">  // If no hotkey is specified, first char is used.</a>
<a name="ln3657">  if (!has_hotkey[0]) {</a>
<a name="ln3658">    len += 2;                                // &quot;x&quot; -&gt; &quot;[x]&quot;</a>
<a name="ln3659">  }</a>
<a name="ln3660"> </a>
<a name="ln3661">  // Now allocate space for the strings</a>
<a name="ln3662">  xfree(confirm_msg);</a>
<a name="ln3663">  confirm_msg = xmalloc((size_t)len);</a>
<a name="ln3664">  *confirm_msg = NUL;</a>
<a name="ln3665"> </a>
<a name="ln3666">  return xmalloc((size_t)lenhotkey);</a>
<a name="ln3667">}</a>
<a name="ln3668"> </a>
<a name="ln3669">/// Format the dialog string, and display it at the bottom of</a>
<a name="ln3670">/// the screen. Return a string of hotkey chars (if defined) for</a>
<a name="ln3671">/// each 'button'. If a button has no hotkey defined, the first character of</a>
<a name="ln3672">/// the button is used.</a>
<a name="ln3673">/// The hotkeys can be multi-byte characters, but without combining chars.</a>
<a name="ln3674">///</a>
<a name="ln3675">/// @return  an allocated string with hotkeys.</a>
<a name="ln3676">static char *msg_show_console_dialog(char *message, char *buttons, int dfltbutton)</a>
<a name="ln3677">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3678">{</a>
<a name="ln3679">  bool has_hotkey[HAS_HOTKEY_LEN] = { false };</a>
<a name="ln3680">  char *hotk = console_dialog_alloc(message, buttons, has_hotkey);</a>
<a name="ln3681"> </a>
<a name="ln3682">  copy_hotkeys_and_msg(message, buttons, dfltbutton, has_hotkey, hotk);</a>
<a name="ln3683"> </a>
<a name="ln3684">  display_confirm_msg();</a>
<a name="ln3685">  return hotk;</a>
<a name="ln3686">}</a>
<a name="ln3687"> </a>
<a name="ln3688">/// Copies hotkeys &amp; dialog message into the memory allocated for it</a>
<a name="ln3689">///</a>
<a name="ln3690">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3691">/// @param buttons String containing button names</a>
<a name="ln3692">/// @param default_button_idx Number of default button</a>
<a name="ln3693">/// @param has_hotkey An element in this array is true if corresponding button</a>
<a name="ln3694">///                   has a hotkey</a>
<a name="ln3695">/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied</a>
<a name="ln3696">static void copy_hotkeys_and_msg(const char *message, char *buttons, int default_button_idx,</a>
<a name="ln3697">                                 const bool has_hotkey[], char *hotkeys_ptr)</a>
<a name="ln3698">{</a>
<a name="ln3699">  *confirm_msg = '\n';</a>
<a name="ln3700">  STRCPY(confirm_msg + 1, message);</a>
<a name="ln3701"> </a>
<a name="ln3702">  char *msgp = confirm_msg + 1 + strlen(message);</a>
<a name="ln3703"> </a>
<a name="ln3704">  // Define first default hotkey. Keep the hotkey string NUL</a>
<a name="ln3705">  // terminated to avoid reading past the end.</a>
<a name="ln3706">  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3707"> </a>
<a name="ln3708">  // Remember where the choices start, displaying starts here when</a>
<a name="ln3709">  // &quot;hotkeys_ptr&quot; typed at the more prompt.</a>
<a name="ln3710">  confirm_msg_tail = msgp;</a>
<a name="ln3711">  *msgp++ = '\n';</a>
<a name="ln3712"> </a>
<a name="ln3713">  bool first_hotkey = false;  // Is the first char of button a hotkey</a>
<a name="ln3714">  if (!has_hotkey[0]) {</a>
<a name="ln3715">    first_hotkey = true;     // If no hotkey is specified, first char is used</a>
<a name="ln3716">  }</a>
<a name="ln3717"> </a>
<a name="ln3718">  int idx = 0;</a>
<a name="ln3719">  char *r = buttons;</a>
<a name="ln3720">  while (*r) {</a>
<a name="ln3721">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3722">      *msgp++ = ',';</a>
<a name="ln3723">      *msgp++ = ' ';                    // '\n' -&gt; ', '</a>
<a name="ln3724"> </a>
<a name="ln3725">      // Advance to next hotkey and set default hotkey</a>
<a name="ln3726">      hotkeys_ptr += strlen(hotkeys_ptr);</a>
<a name="ln3727">      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3728"> </a>
<a name="ln3729">      if (default_button_idx) {</a>
<a name="ln3730">        default_button_idx--;</a>
<a name="ln3731">      }</a>
<a name="ln3732"> </a>
<a name="ln3733">      // If no hotkey is specified, first char is used.</a>
<a name="ln3734">      if (idx &lt; HAS_HOTKEY_LEN - 1 &amp;&amp; !has_hotkey[++idx]) {</a>
<a name="ln3735">        first_hotkey = true;</a>
<a name="ln3736">      }</a>
<a name="ln3737">    } else if (*r == DLG_HOTKEY_CHAR || first_hotkey) {</a>
<a name="ln3738">      if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3739">        r++;</a>
<a name="ln3740">      }</a>
<a name="ln3741"> </a>
<a name="ln3742">      first_hotkey = false;</a>
<a name="ln3743">      if (*r == DLG_HOTKEY_CHAR) {                 // '&amp;&amp;a' -&gt; '&amp;a'</a>
<a name="ln3744">        *msgp++ = *r;</a>
<a name="ln3745">      } else {</a>
<a name="ln3746">        // '&amp;a' -&gt; '[a]'</a>
<a name="ln3747">        *msgp++ = (default_button_idx == 1) ? '[' : '(';</a>
<a name="ln3748">        msgp += copy_char(r, msgp, false);</a>
<a name="ln3749">        *msgp++ = (default_button_idx == 1) ? ']' : ')';</a>
<a name="ln3750"> </a>
<a name="ln3751">        // redefine hotkey</a>
<a name="ln3752">        hotkeys_ptr[copy_char(r, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3753">      }</a>
<a name="ln3754">    } else {</a>
<a name="ln3755">      // everything else copy literally</a>
<a name="ln3756">      msgp += copy_char(r, msgp, false);</a>
<a name="ln3757">    }</a>
<a name="ln3758"> </a>
<a name="ln3759">    // advance to the next character</a>
<a name="ln3760">    MB_PTR_ADV(r);</a>
<a name="ln3761">  }</a>
<a name="ln3762"> </a>
<a name="ln3763">  *msgp++ = ':';</a>
<a name="ln3764">  *msgp++ = ' ';</a>
<a name="ln3765">  *msgp = NUL;</a>
<a name="ln3766">}</a>
<a name="ln3767"> </a>
<a name="ln3768">/// Display the &quot;:confirm&quot; message.  Also called when screen resized.</a>
<a name="ln3769">void display_confirm_msg(void)</a>
<a name="ln3770">{</a>
<a name="ln3771">  // Avoid that 'q' at the more prompt truncates the message here.</a>
<a name="ln3772">  confirm_msg_used++;</a>
<a name="ln3773">  if (confirm_msg != NULL) {</a>
<a name="ln3774">    msg_ext_set_kind(&quot;confirm&quot;);</a>
<a name="ln3775">    msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));</a>
<a name="ln3776">  }</a>
<a name="ln3777">  confirm_msg_used--;</a>
<a name="ln3778">}</a>
<a name="ln3779"> </a>
<a name="ln3780">int vim_dialog_yesno(int type, char *title, char *message, int dflt)</a>
<a name="ln3781">{</a>
<a name="ln3782">  if (do_dialog(type,</a>
<a name="ln3783">                title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3784">                message,</a>
<a name="ln3785">                _(&quot;&amp;Yes\n&amp;No&quot;), dflt, NULL, false) == 1) {</a>
<a name="ln3786">    return VIM_YES;</a>
<a name="ln3787">  }</a>
<a name="ln3788">  return VIM_NO;</a>
<a name="ln3789">}</a>
<a name="ln3790"> </a>
<a name="ln3791">int vim_dialog_yesnocancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3792">{</a>
<a name="ln3793">  switch (do_dialog(type,</a>
<a name="ln3794">                    title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3795">                    message,</a>
<a name="ln3796">                    _(&quot;&amp;Yes\n&amp;No\n&amp;Cancel&quot;), dflt, NULL, false)) {</a>
<a name="ln3797">  case 1:</a>
<a name="ln3798">    return VIM_YES;</a>
<a name="ln3799">  case 2:</a>
<a name="ln3800">    return VIM_NO;</a>
<a name="ln3801">  }</a>
<a name="ln3802">  return VIM_CANCEL;</a>
<a name="ln3803">}</a>
<a name="ln3804"> </a>
<a name="ln3805">int vim_dialog_yesnoallcancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3806">{</a>
<a name="ln3807">  switch (do_dialog(type,</a>
<a name="ln3808">                    title == NULL ? &quot;Question&quot; : title,</a>
<a name="ln3809">                    message,</a>
<a name="ln3810">                    _(&quot;&amp;Yes\n&amp;No\nSave &amp;All\n&amp;Discard All\n&amp;Cancel&quot;),</a>
<a name="ln3811">                    dflt, NULL, false)) {</a>
<a name="ln3812">  case 1:</a>
<a name="ln3813">    return VIM_YES;</a>
<a name="ln3814">  case 2:</a>
<a name="ln3815">    return VIM_NO;</a>
<a name="ln3816">  case 3:</a>
<a name="ln3817">    return VIM_ALL;</a>
<a name="ln3818">  case 4:</a>
<a name="ln3819">    return VIM_DISCARDALL;</a>
<a name="ln3820">  }</a>
<a name="ln3821">  return VIM_CANCEL;</a>
<a name="ln3822">}</a>
<a name="ln3823"> </a>
<a name="ln3824">/// Check if there should be a delay to allow the user to see a message.</a>
<a name="ln3825">///</a>
<a name="ln3826">/// Used before clearing or redrawing the screen or the command line.</a>
<a name="ln3827">void msg_check_for_delay(bool check_msg_scroll)</a>
<a name="ln3828">{</a>
<a name="ln3829">  if ((emsg_on_display || (check_msg_scroll &amp;&amp; msg_scroll))</a>
<a name="ln3830">      &amp;&amp; !did_wait_return</a>
<a name="ln3831">      &amp;&amp; emsg_silent == 0</a>
<a name="ln3832">      &amp;&amp; !in_assert_fails) {</a>
<a name="ln3833">    ui_flush();</a>
<a name="ln3834">    os_delay(1006L, true);</a>
<a name="ln3835">    emsg_on_display = false;</a>
<a name="ln3836">    if (check_msg_scroll) {</a>
<a name="ln3837">      msg_scroll = false;</a>
<a name="ln3838">    }</a>
<a name="ln3839">  }</a>
<a name="ln3840">}</a>
</code></pre>
<div class="balloon" rel="490"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="502"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="513"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="784"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="803"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="853"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="880"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2122"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>