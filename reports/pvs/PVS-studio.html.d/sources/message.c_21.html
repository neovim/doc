<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// message.c: functions for displaying messages on the command line</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/channel.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/event/defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln25">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln32">#include &quot;nvim/globals.h&quot;</a>
<a name="ln33">#include &quot;nvim/grid.h&quot;</a>
<a name="ln34">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln35">#include &quot;nvim/indent.h&quot;</a>
<a name="ln36">#include &quot;nvim/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln38">#include &quot;nvim/log.h&quot;</a>
<a name="ln39">#include &quot;nvim/main.h&quot;</a>
<a name="ln40">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln41">#include &quot;nvim/memory.h&quot;</a>
<a name="ln42">#include &quot;nvim/message.h&quot;</a>
<a name="ln43">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln50">#include &quot;nvim/pos.h&quot;</a>
<a name="ln51">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln52">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln53">#include &quot;nvim/strings.h&quot;</a>
<a name="ln54">#include &quot;nvim/ui.h&quot;</a>
<a name="ln55">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln56">#include &quot;nvim/vim.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">// To be able to scroll back at the &quot;more&quot; and &quot;hit-enter&quot; prompts we need to</a>
<a name="ln59">// store the displayed text and remember where screen lines start.</a>
<a name="ln60">typedef struct msgchunk_S msgchunk_T;</a>
<a name="ln61">struct msgchunk_S {</a>
<a name="ln62">  msgchunk_T *sb_next;</a>
<a name="ln63">  msgchunk_T *sb_prev;</a>
<a name="ln64">  char sb_eol;                  // true when line ends after this text</a>
<a name="ln65">  int sb_msg_col;               // column in which text starts</a>
<a name="ln66">  int sb_attr;                  // text attributes</a>
<a name="ln67">  char sb_text[];               // text to be displayed</a>
<a name="ln68">};</a>
<a name="ln69"> </a>
<a name="ln70">// Magic chars used in confirm dialog strings</a>
<a name="ln71">enum {</a>
<a name="ln72">  DLG_BUTTON_SEP = '\n',</a>
<a name="ln73">  DLG_HOTKEY_CHAR = '&amp;',</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">static int confirm_msg_used = false;            // displaying confirm_msg</a>
<a name="ln77">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln78"># include &quot;message.c.generated.h&quot;</a>
<a name="ln79">#endif</a>
<a name="ln80">static char *confirm_msg = NULL;            // &quot;:confirm&quot; message</a>
<a name="ln81">static char *confirm_msg_tail;              // tail of confirm_msg</a>
<a name="ln82"> </a>
<a name="ln83">MessageHistoryEntry *first_msg_hist = NULL;</a>
<a name="ln84">MessageHistoryEntry *last_msg_hist = NULL;</a>
<a name="ln85">static int msg_hist_len = 0;</a>
<a name="ln86"> </a>
<a name="ln87">static FILE *verbose_fd = NULL;</a>
<a name="ln88">static int verbose_did_open = false;</a>
<a name="ln89"> </a>
<a name="ln90">bool keep_msg_more = false;    // keep_msg was set by msgmore()</a>
<a name="ln91"> </a>
<a name="ln92">// When writing messages to the screen, there are many different situations.</a>
<a name="ln93">// A number of variables is used to remember the current state:</a>
<a name="ln94">// msg_didany       true when messages were written since the last time the</a>
<a name="ln95">//                  user reacted to a prompt.</a>
<a name="ln96">//                  Reset: After hitting a key for the hit-return prompt,</a>
<a name="ln97">//                  hitting &lt;CR&gt; for the command line or input().</a>
<a name="ln98">//                  Set: When any message is written to the screen.</a>
<a name="ln99">// msg_didout       true when something was written to the current line.</a>
<a name="ln100">//                  Reset: When advancing to the next line, when the current</a>
<a name="ln101">//                  text can be overwritten.</a>
<a name="ln102">//                  Set: When any message is written to the screen.</a>
<a name="ln103">// msg_nowait       No extra delay for the last drawn message.</a>
<a name="ln104">//                  Used in normal_cmd() before the mode message is drawn.</a>
<a name="ln105">// emsg_on_display  There was an error message recently.  Indicates that there</a>
<a name="ln106">//                  should be a delay before redrawing.</a>
<a name="ln107">// msg_scroll       The next message should not overwrite the current one.</a>
<a name="ln108">// msg_scrolled     How many lines the screen has been scrolled (because of</a>
<a name="ln109">//                  messages).  Used in update_screen() to scroll the screen</a>
<a name="ln110">//                  back.  Incremented each time the screen scrolls a line.</a>
<a name="ln111">// msg_scrolled_ign  true when msg_scrolled is non-zero and msg_puts_attr()</a>
<a name="ln112">//                  writes something without scrolling should not make</a>
<a name="ln113">//                  need_wait_return to be set.  This is a hack to make &quot;:ts&quot;</a>
<a name="ln114">//                  work without an extra prompt.</a>
<a name="ln115">// lines_left       Number of lines available for messages before the</a>
<a name="ln116">//                  more-prompt is to be given.  -1 when not set.</a>
<a name="ln117">// need_wait_return true when the hit-return prompt is needed.</a>
<a name="ln118">//                  Reset: After giving the hit-return prompt, when the user</a>
<a name="ln119">//                  has answered some other prompt.</a>
<a name="ln120">//                  Set: When the ruler or typeahead display is overwritten,</a>
<a name="ln121">//                  scrolling the screen for some message.</a>
<a name="ln122">// keep_msg         Message to be displayed after redrawing the screen, in</a>
<a name="ln123">//                  main_loop().</a>
<a name="ln124">//                  This is an allocated string or NULL when not used.</a>
<a name="ln125"> </a>
<a name="ln126">// Extended msg state, currently used for external UIs with ext_messages</a>
<a name="ln127">static const char *msg_ext_kind = NULL;</a>
<a name="ln128">static Array msg_ext_chunks = ARRAY_DICT_INIT;</a>
<a name="ln129">static garray_T msg_ext_last_chunk = GA_INIT(sizeof(char), 40);</a>
<a name="ln130">static sattr_T msg_ext_last_attr = -1;</a>
<a name="ln131">static size_t msg_ext_cur_len = 0;</a>
<a name="ln132"> </a>
<a name="ln133">static bool msg_ext_overwrite = false;  ///&lt; will overwrite last message</a>
<a name="ln134">static int msg_ext_visible = 0;  ///&lt; number of messages currently visible</a>
<a name="ln135"> </a>
<a name="ln136">static bool msg_ext_history_visible = false;</a>
<a name="ln137"> </a>
<a name="ln138">/// Shouldn't clear message after leaving cmdline</a>
<a name="ln139">static bool msg_ext_keep_after_cmdline = false;</a>
<a name="ln140"> </a>
<a name="ln141">static int msg_grid_pos_at_flush = 0;</a>
<a name="ln142"> </a>
<a name="ln143">static void ui_ext_msg_set_pos(int row, bool scrolled)</a>
<a name="ln144">{</a>
<a name="ln145">  char buf[MAX_MCO + 1];</a>
<a name="ln146">  size_t size = (size_t)utf_char2bytes(curwin-&gt;w_p_fcs_chars.msgsep, buf);</a>
<a name="ln147">  buf[size] = '\0';</a>
<a name="ln148">  ui_call_msg_set_pos(msg_grid.handle, row, scrolled,</a>
<a name="ln149">                      (String){ .data = buf, .size = size });</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">void msg_grid_set_pos(int row, bool scrolled)</a>
<a name="ln153">{</a>
<a name="ln154">  if (!msg_grid.throttled) {</a>
<a name="ln155">    ui_ext_msg_set_pos(row, scrolled);</a>
<a name="ln156">    msg_grid_pos_at_flush = row;</a>
<a name="ln157">  }</a>
<a name="ln158">  msg_grid_pos = row;</a>
<a name="ln159">  if (msg_grid.chars) {</a>
<a name="ln160">    msg_grid_adj.row_offset = -row;</a>
<a name="ln161">  }</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">bool msg_use_grid(void)</a>
<a name="ln165">{</a>
<a name="ln166">  return default_grid.chars &amp;&amp; !ui_has(kUIMessages);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">void msg_grid_validate(void)</a>
<a name="ln170">{</a>
<a name="ln171">  grid_assign_handle(&amp;msg_grid);</a>
<a name="ln172">  bool should_alloc = msg_use_grid();</a>
<a name="ln173">  int max_rows = Rows - (int)p_ch;</a>
<a name="ln174">  if (should_alloc &amp;&amp; (msg_grid.rows != Rows || msg_grid.cols != Columns</a>
<a name="ln175">                       || !msg_grid.chars)) {</a>
<a name="ln176">    // TODO(bfredl): eventually should be set to &quot;invalid&quot;. I e all callers</a>
<a name="ln177">    // will use the grid including clear to EOS if necessary.</a>
<a name="ln178">    grid_alloc(&amp;msg_grid, Rows, Columns, false, true);</a>
<a name="ln179">    msg_grid.zindex = kZIndexMessages;</a>
<a name="ln180"> </a>
<a name="ln181">    xfree(msg_grid.dirty_col);</a>
<a name="ln182">    msg_grid.dirty_col = xcalloc((size_t)Rows, sizeof(*msg_grid.dirty_col));</a>
<a name="ln183"> </a>
<a name="ln184">    // Tricky: allow resize while pager or ex mode is active</a>
<a name="ln185">    int pos = (State &amp; MODE_ASKMORE) ? 0 : MAX(max_rows - msg_scrolled, 0);</a>
<a name="ln186">    msg_grid.throttled = false;  // don't throttle in 'cmdheight' area</a>
<a name="ln187">    msg_grid_set_pos(pos, msg_scrolled);</a>
<a name="ln188">    ui_comp_put_grid(&amp;msg_grid, pos, 0, msg_grid.rows, msg_grid.cols,</a>
<a name="ln189">                     false, true);</a>
<a name="ln190">    ui_call_grid_resize(msg_grid.handle, msg_grid.cols, msg_grid.rows);</a>
<a name="ln191"> </a>
<a name="ln192">    msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln193">    msg_grid.focusable = false;</a>
<a name="ln194">    msg_grid_adj.target = &amp;msg_grid;</a>
<a name="ln195">  } else if (!should_alloc &amp;&amp; msg_grid.chars) {</a>
<a name="ln196">    ui_comp_remove_grid(&amp;msg_grid);</a>
<a name="ln197">    grid_free(&amp;msg_grid);</a>
<a name="ln198">    XFREE_CLEAR(msg_grid.dirty_col);</a>
<a name="ln199">    ui_call_grid_destroy(msg_grid.handle);</a>
<a name="ln200">    msg_grid.throttled = false;</a>
<a name="ln201">    msg_grid_adj.row_offset = 0;</a>
<a name="ln202">    msg_grid_adj.target = &amp;default_grid;</a>
<a name="ln203">    redraw_cmdline = true;</a>
<a name="ln204">  } else if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; msg_grid_pos != max_rows) {</a>
<a name="ln205">    msg_grid_set_pos(max_rows, false);</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; cmdline_row &lt; msg_grid_pos) {</a>
<a name="ln209">    // TODO(bfredl): this should already be the case, but fails in some</a>
<a name="ln210">    // &quot;batched&quot; executions where compute_cmdrow() use stale positions or</a>
<a name="ln211">    // something.</a>
<a name="ln212">    cmdline_row = msg_grid_pos;</a>
<a name="ln213">  }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">/// Like msg() but keep it silent when 'verbosefile' is set.</a>
<a name="ln217">int verb_msg(const char *s)</a>
<a name="ln218">{</a>
<a name="ln219">  verbose_enter();</a>
<a name="ln220">  int n = msg_attr_keep(s, 0, false, false);</a>
<a name="ln221">  verbose_leave();</a>
<a name="ln222"> </a>
<a name="ln223">  return n;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/// Displays the string 's' on the status line</a>
<a name="ln227">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln228">///</a>
<a name="ln229">/// @return  true if wait_return() not called</a>
<a name="ln230">int msg(const char *s, const int attr)</a>
<a name="ln231">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln232">{</a>
<a name="ln233">  return msg_attr_keep(s, attr, false, false);</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/// Similar to msg_outtrans, but support newlines and tabs.</a>
<a name="ln237">void msg_multiline(const char *s, int attr, bool check_int, bool *need_clear)</a>
<a name="ln238">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln239">{</a>
<a name="ln240">  const char *next_spec = s;</a>
<a name="ln241"> </a>
<a name="ln242">  while (next_spec != NULL) {</a>
<a name="ln243">    if (check_int &amp;&amp; got_int) {</a>
<a name="ln244">      return;</a>
<a name="ln245">    }</a>
<a name="ln246">    next_spec = strpbrk(s, &quot;\t\n\r&quot;);</a>
<a name="ln247"> </a>
<a name="ln248">    if (next_spec != NULL) {</a>
<a name="ln249">      // Printing all char that are before the char found by strpbrk</a>
<a name="ln250">      msg_outtrans_len(s, (int)(next_spec - s), attr);</a>
<a name="ln251"> </a>
<a name="ln252">      if (*next_spec != TAB &amp;&amp; *need_clear) {</a>
<a name="ln253">        msg_clr_eos();</a>
<a name="ln254">        *need_clear = false;</a>
<a name="ln255">      }</a>
<a name="ln256">      msg_putchar_attr((uint8_t)(*next_spec), attr);</a>
<a name="ln257">      s = next_spec + 1;</a>
<a name="ln258">    }</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  // Print the rest of the message. We know there is no special</a>
<a name="ln262">  // character because strpbrk returned NULL</a>
<a name="ln263">  if (*s != NUL) {</a>
<a name="ln264">    msg_outtrans(s, attr);</a>
<a name="ln265">  }</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">void msg_multiattr(HlMessage hl_msg, const char *kind, bool history)</a>
<a name="ln269">{</a>
<a name="ln270">  no_wait_return++;</a>
<a name="ln271">  msg_start();</a>
<a name="ln272">  msg_clr_eos();</a>
<a name="ln273">  bool need_clear = false;</a>
<a name="ln274">  msg_ext_set_kind(kind);</a>
<a name="ln275">  for (uint32_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln276">    HlMessageChunk chunk = kv_A(hl_msg, i);</a>
<a name="ln277">    msg_multiline(chunk.text.data, chunk.attr, true, &amp;need_clear);</a>
<a name="ln278">  }</a>
<a name="ln279">  if (history &amp;&amp; kv_size(hl_msg)) {</a>
<a name="ln280">    add_msg_hist_multiattr(NULL, 0, 0, true, hl_msg);</a>
<a name="ln281">  }</a>
<a name="ln282">  no_wait_return--;</a>
<a name="ln283">  msg_end();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/// @param keep set keep_msg if it doesn't scroll</a>
<a name="ln287">bool msg_attr_keep(const char *s, int attr, bool keep, bool multiline)</a>
<a name="ln288">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln289">{</a>
<a name="ln290">  static int entered = 0;</a>
<a name="ln291">  int retval;</a>
<a name="ln292">  char *buf = NULL;</a>
<a name="ln293"> </a>
<a name="ln294">  if (keep &amp;&amp; multiline) {</a>
<a name="ln295">    // Not implemented. 'multiline' is only used by nvim-added messages,</a>
<a name="ln296">    // which should avoid 'keep' behavior (just show the message at</a>
<a name="ln297">    // the correct time already).</a>
<a name="ln298">    abort();</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  // Skip messages not match &quot;:filter pattern&quot;.</a>
<a name="ln302">  // Don't filter when there is an error.</a>
<a name="ln303">  if (!emsg_on_display &amp;&amp; message_filtered(s)) {</a>
<a name="ln304">    return true;</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  if (attr == 0) {</a>
<a name="ln308">    set_vim_var_string(VV_STATUSMSG, s, -1);</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // It is possible that displaying a messages causes a problem (e.g.,</a>
<a name="ln312">  // when redrawing the window), which causes another message, etc..    To</a>
<a name="ln313">  // break this loop, limit the recursiveness to 3 levels.</a>
<a name="ln314">  if (entered &gt;= 3) {</a>
<a name="ln315">    return true;</a>
<a name="ln316">  }</a>
<a name="ln317">  entered++;</a>
<a name="ln318"> </a>
<a name="ln319">  // Add message to history (unless it's a repeated kept message or a</a>
<a name="ln320">  // truncated message)</a>
<a name="ln321">  if (s != keep_msg</a>
<a name="ln322">      || (*s != '&lt;'</a>
<a name="ln323">          &amp;&amp; last_msg_hist != NULL</a>
<a name="ln324">          &amp;&amp; last_msg_hist-&gt;msg != NULL</a>
<a name="ln325">          &amp;&amp; strcmp(s, last_msg_hist-&gt;msg) != 0)) {</a>
<a name="ln326">    add_msg_hist(s, -1, attr, multiline);</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  // Truncate the message if needed.</a>
<a name="ln330">  msg_start();</a>
<a name="ln331">  buf = msg_strtrunc(s, false);</a>
<a name="ln332">  if (buf != NULL) {</a>
<a name="ln333">    s = buf;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  bool need_clear = true;</a>
<a name="ln337">  if (multiline) {</a>
<a name="ln338">    msg_multiline(s, attr, false, &amp;need_clear);</a>
<a name="ln339">  } else {</a>
<a name="ln340">    msg_outtrans(s, attr);</a>
<a name="ln341">  }</a>
<a name="ln342">  if (need_clear) {</a>
<a name="ln343">    msg_clr_eos();</a>
<a name="ln344">  }</a>
<a name="ln345">  retval = msg_end();</a>
<a name="ln346"> </a>
<a name="ln347">  if (keep &amp;&amp; retval &amp;&amp; vim_strsize(s) &lt; (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln348">    set_keep_msg(s, 0);</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  need_fileinfo = false;</a>
<a name="ln352"> </a>
<a name="ln353">  xfree(buf);</a>
<a name="ln354">  entered--;</a>
<a name="ln355">  return retval;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">/// Truncate a string such that it can be printed without causing a scroll.</a>
<a name="ln359">///</a>
<a name="ln360">/// @return  an allocated string or NULL when no truncating is done.</a>
<a name="ln361">///</a>
<a name="ln362">/// @param force  always truncate</a>
<a name="ln363">char *msg_strtrunc(const char *s, int force)</a>
<a name="ln364">{</a>
<a name="ln365">  char *buf = NULL;</a>
<a name="ln366"> </a>
<a name="ln367">  // May truncate message to avoid a hit-return prompt</a>
<a name="ln368">  if ((!msg_scroll &amp;&amp; !need_wait_return &amp;&amp; shortmess(SHM_TRUNCALL)</a>
<a name="ln369">       &amp;&amp; !exmode_active &amp;&amp; msg_silent == 0 &amp;&amp; !ui_has(kUIMessages))</a>
<a name="ln370">      || force) {</a>
<a name="ln371">    int room;</a>
<a name="ln372">    int len = vim_strsize(s);</a>
<a name="ln373">    if (msg_scrolled != 0) {</a>
<a name="ln374">      // Use all the columns.</a>
<a name="ln375">      room = (Rows - msg_row) * Columns - 1;</a>
<a name="ln376">    } else {</a>
<a name="ln377">      // Use up to 'showcmd' column.</a>
<a name="ln378">      room = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln379">    }</a>
<a name="ln380">    if (len &gt; room &amp;&amp; room &gt; 0) {</a>
<a name="ln381">      // may have up to 18 bytes per cell (6 per char, up to two</a>
<a name="ln382">      // composing chars)</a>
<a name="ln383">      len = (room + 2) * 18;</a>
<a name="ln384">      buf = xmalloc((size_t)len);</a>
<a name="ln385">      trunc_string(s, buf, room, len);</a>
<a name="ln386">    }</a>
<a name="ln387">  }</a>
<a name="ln388">  return buf;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/// Truncate a string &quot;s&quot; to &quot;buf&quot; with cell width &quot;room&quot;.</a>
<a name="ln392">/// &quot;s&quot; and &quot;buf&quot; may be equal.</a>
<a name="ln393">void trunc_string(const char *s, char *buf, int room_in, int buflen)</a>
<a name="ln394">{</a>
<a name="ln395">  int room = room_in - 3;  // &quot;...&quot; takes 3 chars</a>
<a name="ln396">  int half;</a>
<a name="ln397">  int len = 0;</a>
<a name="ln398">  int e;</a>
<a name="ln399">  int i;</a>
<a name="ln400">  int n;</a>
<a name="ln401"> </a>
<a name="ln402">  if (*s == NUL) {</a>
<a name="ln403">    if (buflen &gt; 0) {</a>
<a name="ln404">      *buf = NUL;</a>
<a name="ln405">    }</a>
<a name="ln406">    return;</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  if (room_in &lt; 3) {</a>
<a name="ln410">    room = 0;</a>
<a name="ln411">  }</a>
<a name="ln412">  half = room / 2;</a>
<a name="ln413"> </a>
<a name="ln414">  // First part: Start of the string.</a>
<a name="ln415">  for (e = 0; len &lt; half &amp;&amp; e &lt; buflen; e++) {</a>
<a name="ln416">    if (s[e] == NUL) {</a>
<a name="ln417">      // text fits without truncating!</a>
<a name="ln418">      buf[e] = NUL;</a>
<a name="ln419">      return;</a>
<a name="ln420">    }</a>
<a name="ln421">    n = ptr2cells(s + e);</a>
<a name="ln422">    if (len + n &gt; half) {</a>
<a name="ln423">      break;</a>
<a name="ln424">    }</a>
<a name="ln425">    len += n;</a>
<a name="ln426">    buf[e] = s[e];</a>
<a name="ln427">    for (n = utfc_ptr2len(s + e); --n &gt; 0;) {</a>
<a name="ln428">      if (++e == buflen) {</a>
<a name="ln429">        break;</a>
<a name="ln430">      }</a>
<a name="ln431">      buf[e] = s[e];</a>
<a name="ln432">    }</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  // Last part: End of the string.</a>
<a name="ln436">  half = i = (int)strlen(s);</a>
<a name="ln437">  while (true) {</a>
<a name="ln438">    do {</a>
<a name="ln439">      half = half - utf_head_off(s, s + half - 1) - 1;</a>
<a name="ln440">    } while (half &gt; 0 &amp;&amp; utf_iscomposing(utf_ptr2char(s + half)));</a>
<a name="ln441">    n = ptr2cells(s + half);</a>
<a name="ln442">    if (len + n &gt; room || half == 0) {</a>
<a name="ln443">      break;</a>
<a name="ln444">    }</a>
<a name="ln445">    len += n;</a>
<a name="ln446">    i = half;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (i &lt;= e + 3) {</a>
<a name="ln450">    // text fits without truncating</a>
<a name="ln451">    if (s != buf) {</a>
<a name="ln452">      len = (int)strlen(s);</a>
<a name="ln453">      if (len &gt;= buflen) {</a>
<a name="ln454">        len = buflen - 1;</a>
<a name="ln455">      }</a>
<a name="ln456">      len = len - e + 1;</a>
<a name="ln457">      if (len &lt; 1) {</a>
<a name="ln458">        buf[e - 1] = NUL;</a>
<a name="ln459">      } else {</a>
<a name="ln460">        memmove(buf + e, s + e, (size_t)len);</a>
<a name="ln461">      }</a>
<a name="ln462">    }</a>
<a name="ln463">  } else if (e + 3 &lt; buflen) {</a>
<a name="ln464">    // set the middle and copy the last part</a>
<a name="ln465">    memmove(buf + e, &quot;...&quot;, (size_t)3);</a>
<a name="ln466">    len = (int)strlen(s + i) + 1;</a>
<a name="ln467">    if (len &gt;= buflen - e - 3) {</a>
<a name="ln468">      len = buflen - e - 3 - 1;</a>
<a name="ln469">    }</a>
<a name="ln470">    memmove(buf + e + 3, s + i, (size_t)len);</a>
<a name="ln471">    buf[e + 3 + len - 1] = NUL;</a>
<a name="ln472">  } else {</a>
<a name="ln473">    // can't fit in the &quot;...&quot;, just truncate it</a>
<a name="ln474">    buf[e - 1] = NUL;</a>
<a name="ln475">  }</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">// Note: Caller of smsg() must check the resulting string is shorter than IOSIZE!!!</a>
<a name="ln479">int smsg(int attr, const char *s, ...)</a>
<a name="ln480">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln481">{</a>
<a name="ln482">  va_list arglist;</a>
<a name="ln483"> </a>
<a name="ln484">  va_start(arglist, s);</a>
<a name="ln485">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln486">  va_end(arglist);</a>
<a name="ln487">  return msg(IObuff, attr);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">int smsg_attr_keep(int attr, const char *s, ...)</a>
<a name="ln491">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln492">{</a>
<a name="ln493">  va_list arglist;</a>
<a name="ln494"> </a>
<a name="ln495">  va_start(arglist, s);</a>
<a name="ln496">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln497">  va_end(arglist);</a>
<a name="ln498">  return msg_attr_keep(IObuff, attr, true, false);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// Remember the last sourcing name/lnum used in an error message, so that it</a>
<a name="ln502">// isn't printed each time when it didn't change.</a>
<a name="ln503">static int last_sourcing_lnum = 0;</a>
<a name="ln504">static char *last_sourcing_name = NULL;</a>
<a name="ln505"> </a>
<a name="ln506">/// Reset the last used sourcing name/lnum.  Makes sure it is displayed again</a>
<a name="ln507">/// for the next error message;</a>
<a name="ln508">void reset_last_sourcing(void)</a>
<a name="ln509">{</a>
<a name="ln510">  XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln511">  last_sourcing_lnum = 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/// @return  true if &quot;SOURCING_NAME&quot; differs from &quot;last_sourcing_name&quot;.</a>
<a name="ln515">static bool other_sourcing_name(void)</a>
<a name="ln516">{</a>
<a name="ln517">  if (SOURCING_NAME != NULL) {</a>
<a name="ln518">    if (last_sourcing_name != NULL) {</a>
<a name="ln519">      return strcmp(SOURCING_NAME, last_sourcing_name) != 0;</a>
<a name="ln520">    }</a>
<a name="ln521">    return true;</a>
<a name="ln522">  }</a>
<a name="ln523">  return false;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">/// Get the message about the source, as used for an error message</a>
<a name="ln527">///</a>
<a name="ln528">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln529">///                     message is to be given.</a>
<a name="ln530">static char *get_emsg_source(void)</a>
<a name="ln531">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln532">{</a>
<a name="ln533">  if (SOURCING_NAME != NULL &amp;&amp; other_sourcing_name()) {</a>
<a name="ln534">    char *sname = estack_sfile(ESTACK_NONE);</a>
<a name="ln535">    char *tofree = sname;</a>
<a name="ln536"> </a>
<a name="ln537">    if (sname == NULL) {</a>
<a name="ln538">      sname = SOURCING_NAME;</a>
<a name="ln539">    }</a>
<a name="ln540"> </a>
<a name="ln541">    const char *const p = _(&quot;Error detected while processing %s:&quot;);</a>
<a name="ln542">    const size_t buf_len = strlen(sname) + strlen(p) + 1;</a>
<a name="ln543">    char *const buf = xmalloc(buf_len);</a>
<a name="ln544">    snprintf(buf, buf_len, p, sname);</a>
<a name="ln545">    xfree(tofree);</a>
<a name="ln546">    return buf;</a>
<a name="ln547">  }</a>
<a name="ln548">  return NULL;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">/// Get the message about the source lnum, as used for an error message.</a>
<a name="ln552">///</a>
<a name="ln553">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln554">///                     message is to be given.</a>
<a name="ln555">static char *get_emsg_lnum(void)</a>
<a name="ln556">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln557">{</a>
<a name="ln558">  // lnum is 0 when executing a command from the command line</a>
<a name="ln559">  // argument, we don't want a line number then</a>
<a name="ln560">  if (SOURCING_NAME != NULL</a>
<a name="ln561">      &amp;&amp; (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)</a>
<a name="ln562">      &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln563">    const char *const p = _(&quot;line %4ld:&quot;);</a>
<a name="ln564">    const size_t buf_len = 20 + strlen(p);</a>
<a name="ln565">    char *const buf = xmalloc(buf_len);</a>
<a name="ln566">    snprintf(buf, buf_len, p, (long)SOURCING_LNUM);</a>
<a name="ln567">    return buf;</a>
<a name="ln568">  }</a>
<a name="ln569">  return NULL;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">/// Display name and line number for the source of an error.</a>
<a name="ln573">/// Remember the file name and line number, so that for the next error the info</a>
<a name="ln574">/// is only displayed if it changed.</a>
<a name="ln575">void msg_source(int attr)</a>
<a name="ln576">{</a>
<a name="ln577">  static bool recursive = false;</a>
<a name="ln578"> </a>
<a name="ln579">  // Bail out if something called here causes an error.</a>
<a name="ln580">  if (recursive) {</a>
<a name="ln581">    return;</a>
<a name="ln582">  }</a>
<a name="ln583">  recursive = true;</a>
<a name="ln584"> </a>
<a name="ln585">  no_wait_return++;</a>
<a name="ln586">  char *p = get_emsg_source();</a>
<a name="ln587">  if (p != NULL) {</a>
<a name="ln588">    msg_scroll = true;  // this will take more than one line</a>
<a name="ln589">    msg(p, attr);</a>
<a name="ln590">    xfree(p);</a>
<a name="ln591">  }</a>
<a name="ln592">  p = get_emsg_lnum();</a>
<a name="ln593">  if (p != NULL) {</a>
<a name="ln594">    msg(p, HL_ATTR(HLF_N));</a>
<a name="ln595">    xfree(p);</a>
<a name="ln596">    last_sourcing_lnum = SOURCING_LNUM;      // only once for each line</a>
<a name="ln597">  }</a>
<a name="ln598"> </a>
<a name="ln599">  // remember the last sourcing name printed, also when it's empty</a>
<a name="ln600">  if (SOURCING_NAME == NULL || other_sourcing_name()) {</a>
<a name="ln601">    XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln602">    if (SOURCING_NAME != NULL) {</a>
<a name="ln603">      last_sourcing_name = xstrdup(SOURCING_NAME);</a>
<a name="ln604">    }</a>
<a name="ln605">  }</a>
<a name="ln606">  no_wait_return--;</a>
<a name="ln607"> </a>
<a name="ln608">  recursive = false;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/// @return  true if not giving error messages right now:</a>
<a name="ln612">///            If &quot;emsg_off&quot; is set: no error messages at the moment.</a>
<a name="ln613">///            If &quot;msg&quot; is in 'debug': do error message but without side effects.</a>
<a name="ln614">///            If &quot;emsg_skip&quot; is set: never do error messages.</a>
<a name="ln615">int emsg_not_now(void)</a>
<a name="ln616">{</a>
<a name="ln617">  if ((emsg_off &gt; 0 &amp;&amp; vim_strchr(p_debug, 'm') == NULL</a>
<a name="ln618">       &amp;&amp; vim_strchr(p_debug, 't') == NULL)</a>
<a name="ln619">      || emsg_skip &gt; 0) {</a>
<a name="ln620">    return true;</a>
<a name="ln621">  }</a>
<a name="ln622">  return false;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">bool emsg_multiline(const char *s, bool multiline)</a>
<a name="ln626">{</a>
<a name="ln627">  int attr;</a>
<a name="ln628">  bool ignore = false;</a>
<a name="ln629"> </a>
<a name="ln630">  // Skip this if not giving error messages at the moment.</a>
<a name="ln631">  if (emsg_not_now()) {</a>
<a name="ln632">    return true;</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  called_emsg++;</a>
<a name="ln636"> </a>
<a name="ln637">  // If &quot;emsg_severe&quot; is true: When an error exception is to be thrown,</a>
<a name="ln638">  // prefer this message over previous messages for the same command.</a>
<a name="ln639">  bool severe = emsg_severe;</a>
<a name="ln640">  emsg_severe = false;</a>
<a name="ln641"> </a>
<a name="ln642">  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {</a>
<a name="ln643">    // Cause a throw of an error exception if appropriate.  Don't display</a>
<a name="ln644">    // the error message in this case.  (If no matching catch clause will</a>
<a name="ln645">    // be found, the message will be displayed later on.)  &quot;ignore&quot; is set</a>
<a name="ln646">    // when the message should be ignored completely (used for the</a>
<a name="ln647">    // interrupt message).</a>
<a name="ln648">    if (cause_errthrow(s, multiline, severe, &amp;ignore)) {</a>
<a name="ln649">      if (!ignore) {</a>
<a name="ln650">        did_emsg++;</a>
<a name="ln651">      }</a>
<a name="ln652">      return true;</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    if (in_assert_fails &amp;&amp; emsg_assert_fails_msg == NULL) {</a>
<a name="ln656">      emsg_assert_fails_msg = xstrdup(s);</a>
<a name="ln657">      emsg_assert_fails_lnum = SOURCING_LNUM;</a>
<a name="ln658">      xfree(emsg_assert_fails_context);</a>
<a name="ln659">      emsg_assert_fails_context = xstrdup(SOURCING_NAME == NULL ? &quot;&quot; : SOURCING_NAME);</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    // set &quot;v:errmsg&quot;, also when using &quot;:silent! cmd&quot;</a>
<a name="ln663">    set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln664"> </a>
<a name="ln665">    // When using &quot;:silent! cmd&quot; ignore error messages.</a>
<a name="ln666">    // But do write it to the redirection file.</a>
<a name="ln667">    if (emsg_silent != 0) {</a>
<a name="ln668">      if (!emsg_noredir) {</a>
<a name="ln669">        msg_start();</a>
<a name="ln670">        char *p = get_emsg_source();</a>
<a name="ln671">        if (p != NULL) {</a>
<a name="ln672">          const size_t p_len = strlen(p);</a>
<a name="ln673">          p[p_len] = '\n';</a>
<a name="ln674">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln675">          xfree(p);</a>
<a name="ln676">        }</a>
<a name="ln677">        p = get_emsg_lnum();</a>
<a name="ln678">        if (p != NULL) {</a>
<a name="ln679">          const size_t p_len = strlen(p);</a>
<a name="ln680">          p[p_len] = '\n';</a>
<a name="ln681">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln682">          xfree(p);</a>
<a name="ln683">        }</a>
<a name="ln684">        redir_write(s, (ptrdiff_t)strlen(s));</a>
<a name="ln685">      }</a>
<a name="ln686"> </a>
<a name="ln687">      // Log (silent) errors as debug messages.</a>
<a name="ln688">      if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln689">        DLOG(&quot;(:silent) %s (%s (line %ld))&quot;,</a>
<a name="ln690">             s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln691">      } else {</a>
<a name="ln692">        DLOG(&quot;(:silent) %s&quot;, s);</a>
<a name="ln693">      }</a>
<a name="ln694"> </a>
<a name="ln695">      return true;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">    // Log editor errors as INFO.</a>
<a name="ln699">    if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln700">      ILOG(&quot;%s (%s (line %ld))&quot;, s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln701">    } else {</a>
<a name="ln702">      ILOG(&quot;%s&quot;, s);</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    ex_exitval = 1;</a>
<a name="ln706"> </a>
<a name="ln707">    // Reset msg_silent, an error causes messages to be switched back on.</a>
<a name="ln708">    msg_silent = 0;</a>
<a name="ln709">    cmd_silent = false;</a>
<a name="ln710"> </a>
<a name="ln711">    if (global_busy) {        // break :global command</a>
<a name="ln712">      global_busy++;</a>
<a name="ln713">    }</a>
<a name="ln714"> </a>
<a name="ln715">    if (p_eb) {</a>
<a name="ln716">      beep_flush();           // also includes flush_buffers()</a>
<a name="ln717">    } else {</a>
<a name="ln718">      flush_buffers(FLUSH_MINIMAL);  // flush internal buffers</a>
<a name="ln719">    }</a>
<a name="ln720">    did_emsg++;               // flag for DoOneCmd()</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  emsg_on_display = true;     // remember there is an error message</a>
<a name="ln724">  attr = HL_ATTR(HLF_E);      // set highlight mode for error messages</a>
<a name="ln725">  if (msg_scrolled != 0) {</a>
<a name="ln726">    need_wait_return = true;  // needed in case emsg() is called after</a>
<a name="ln727">  }                           // wait_return() has reset need_wait_return</a>
<a name="ln728">                              // and a redraw is expected because</a>
<a name="ln729">                              // msg_scrolled is non-zero</a>
<a name="ln730">  if (msg_ext_kind == NULL) {</a>
<a name="ln731">    msg_ext_set_kind(&quot;emsg&quot;);</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  // Display name and line number for the source of the error.</a>
<a name="ln735">  msg_scroll = true;</a>
<a name="ln736">  msg_source(attr);</a>
<a name="ln737"> </a>
<a name="ln738">  // Display the error message itself.</a>
<a name="ln739">  msg_nowait = false;  // Wait for this msg.</a>
<a name="ln740">  return msg_attr_keep(s, attr, false, multiline);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// emsg() - display an error message</a>
<a name="ln744">///</a>
<a name="ln745">/// Rings the bell, if appropriate, and calls message() to do the real work</a>
<a name="ln746">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln747">///</a>
<a name="ln748">/// @return true if wait_return() not called</a>
<a name="ln749">bool emsg(const char *s)</a>
<a name="ln750">{</a>
<a name="ln751">  return emsg_multiline(s, false);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">void emsg_invreg(int name)</a>
<a name="ln755">{</a>
<a name="ln756">  semsg(_(&quot;E354: Invalid register name: '%s'&quot;), transchar_buf(NULL, name));</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">/// Print an error message with unknown number of arguments</a>
<a name="ln760">bool semsg(const char *const fmt, ...)</a>
<a name="ln761">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln762">{</a>
<a name="ln763">  bool ret;</a>
<a name="ln764"> </a>
<a name="ln765">  va_list ap;</a>
<a name="ln766">  va_start(ap, fmt);</a>
<a name="ln767">  ret = semsgv(fmt, ap);</a>
<a name="ln768">  va_end(ap);</a>
<a name="ln769"> </a>
<a name="ln770">  return ret;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">#define MULTILINE_BUFSIZE 8192</a>
<a name="ln774"> </a>
<a name="ln775">bool semsg_multiline(const char *const fmt, ...)</a>
<a name="ln776">{</a>
<a name="ln777">  bool ret;</a>
<a name="ln778">  va_list ap;</a>
<a name="ln779"> </a>
<a name="ln780">  static char errbuf[MULTILINE_BUFSIZE];</a>
<a name="ln781">  if (emsg_not_now()) {</a>
<a name="ln782">    return true;</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  va_start(ap, fmt);</a>
<a name="ln786">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln787">  va_end(ap);</a>
<a name="ln788"> </a>
<a name="ln789">  ret = emsg_multiline(errbuf, true);</a>
<a name="ln790"> </a>
<a name="ln791">  return ret;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/// Print an error message with unknown number of arguments</a>
<a name="ln795">static bool semsgv(const char *fmt, va_list ap)</a>
<a name="ln796">{</a>
<a name="ln797">  static char errbuf[IOSIZE];</a>
<a name="ln798">  if (emsg_not_now()) {</a>
<a name="ln799">    return true;</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln803"> </a>
<a name="ln804">  return emsg(errbuf);</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">/// Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln808">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln809">/// detected when fuzzing vim.</a>
<a name="ln810">void iemsg(const char *s)</a>
<a name="ln811">{</a>
<a name="ln812">  if (emsg_not_now()) {</a>
<a name="ln813">    return;</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  emsg(s);</a>
<a name="ln817">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln818">  set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln819">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln820">  ui_flush();</a>
<a name="ln821">  abort();</a>
<a name="ln822">#endif</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/// Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln826">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln827">/// detected when fuzzing vim.</a>
<a name="ln828">void siemsg(const char *s, ...)</a>
<a name="ln829">{</a>
<a name="ln830">  if (emsg_not_now()) {</a>
<a name="ln831">    return;</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  va_list ap;</a>
<a name="ln835">  va_start(ap, s);</a>
<a name="ln836">  (void)semsgv(s, ap);</a>
<a name="ln837">  va_end(ap);</a>
<a name="ln838">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln839">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln840">  ui_flush();</a>
<a name="ln841">  abort();</a>
<a name="ln842">#endif</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/// Give an &quot;Internal error&quot; message.</a>
<a name="ln846">void internal_error(const char *where)</a>
<a name="ln847">{</a>
<a name="ln848">  siemsg(_(e_intern2), where);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">static void msg_semsg_event(void **argv)</a>
<a name="ln852">{</a>
<a name="ln853">  char *s = argv[0];</a>
<a name="ln854">  (void)emsg(s);</a>
<a name="ln855">  xfree(s);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">void msg_schedule_semsg(const char *const fmt, ...)</a>
<a name="ln859">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln860">{</a>
<a name="ln861">  va_list ap;</a>
<a name="ln862">  va_start(ap, fmt);</a>
<a name="ln863">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln864">  va_end(ap);</a>
<a name="ln865"> </a>
<a name="ln866">  char *s = xstrdup(IObuff);</a>
<a name="ln867">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_event, 1, s));</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static void msg_semsg_multiline_event(void **argv)</a>
<a name="ln871">{</a>
<a name="ln872">  char *s = argv[0];</a>
<a name="ln873">  (void)emsg_multiline(s, true);</a>
<a name="ln874">  xfree(s);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">void msg_schedule_semsg_multiline(const char *const fmt, ...)</a>
<a name="ln878">{</a>
<a name="ln879">  va_list ap;</a>
<a name="ln880">  va_start(ap, fmt);</a>
<a name="ln881">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln882">  va_end(ap);</a>
<a name="ln883"> </a>
<a name="ln884">  char *s = xstrdup(IObuff);</a>
<a name="ln885">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_multiline_event, 1, s));</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">/// Like msg(), but truncate to a single line if p_shm contains 't', or when</a>
<a name="ln889">/// &quot;force&quot; is true.  This truncates in another way as for normal messages.</a>
<a name="ln890">/// Careful: The string may be changed by msg_may_trunc()!</a>
<a name="ln891">///</a>
<a name="ln892">/// @return  a pointer to the printed message, if wait_return() not called.</a>
<a name="ln893">char *msg_trunc(char *s, bool force, int attr)</a>
<a name="ln894">{</a>
<a name="ln895">  int n;</a>
<a name="ln896"> </a>
<a name="ln897">  // Add message to history before truncating.</a>
<a name="ln898">  add_msg_hist(s, -1, attr, false);</a>
<a name="ln899"> </a>
<a name="ln900">  char *ts = msg_may_trunc(force, s);</a>
<a name="ln901"> </a>
<a name="ln902">  msg_hist_off = true;</a>
<a name="ln903">  n = msg(ts, attr);</a>
<a name="ln904">  msg_hist_off = false;</a>
<a name="ln905"> </a>
<a name="ln906">  if (n) {</a>
<a name="ln907">    return ts;</a>
<a name="ln908">  }</a>
<a name="ln909">  return NULL;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">/// Check if message &quot;s&quot; should be truncated at the start (for filenames).</a>
<a name="ln913">///</a>
<a name="ln914">/// @return  a pointer to where the truncated message starts.</a>
<a name="ln915">///</a>
<a name="ln916">/// @note: May change the message by replacing a character with '&lt;'.</a>
<a name="ln917">char *msg_may_trunc(bool force, char *s)</a>
<a name="ln918">{</a>
<a name="ln919">  if (ui_has(kUIMessages)) {</a>
<a name="ln920">    return s;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  int room = (Rows - cmdline_row - 1) * Columns + sc_col - 1;</a>
<a name="ln924">  if ((force || (shortmess(SHM_TRUNC) &amp;&amp; !exmode_active))</a>
<a name="ln925">      &amp;&amp; (int)strlen(s) - room &gt; 0) {</a>
<a name="ln926">    int size = vim_strsize(s);</a>
<a name="ln927"> </a>
<a name="ln928">    // There may be room anyway when there are multibyte chars.</a>
<a name="ln929">    if (size &lt;= room) {</a>
<a name="ln930">      return s;</a>
<a name="ln931">    }</a>
<a name="ln932">    int n;</a>
<a name="ln933">    for (n = 0; size &gt;= room;) {</a>
<a name="ln934">      size -= utf_ptr2cells(s + n);</a>
<a name="ln935">      n += utfc_ptr2len(s + n);</a>
<a name="ln936">    }</a>
<a name="ln937">    n--;</a>
<a name="ln938">    s += n;</a>
<a name="ln939">    *s = '&lt;';</a>
<a name="ln940">  }</a>
<a name="ln941">  return s;</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void hl_msg_free(HlMessage hl_msg)</a>
<a name="ln945">{</a>
<a name="ln946">  for (size_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln947">    xfree(kv_A(hl_msg, i).text.data);</a>
<a name="ln948">  }</a>
<a name="ln949">  kv_destroy(hl_msg);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/// @param[in]  len  Length of s or -1.</a>
<a name="ln953">static void add_msg_hist(const char *s, int len, int attr, bool multiline)</a>
<a name="ln954">{</a>
<a name="ln955">  add_msg_hist_multiattr(s, len, attr, multiline, (HlMessage)KV_INITIAL_VALUE);</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static void add_msg_hist_multiattr(const char *s, int len, int attr, bool multiline,</a>
<a name="ln959">                                   HlMessage multiattr)</a>
<a name="ln960">{</a>
<a name="ln961">  if (msg_hist_off || msg_silent != 0) {</a>
<a name="ln962">    hl_msg_free(multiattr);</a>
<a name="ln963">    return;</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966">  // Don't let the message history get too big</a>
<a name="ln967">  while (msg_hist_len &gt; MAX_MSG_HIST_LEN) {</a>
<a name="ln968">    (void)delete_first_msg();</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  // allocate an entry and add the message at the end of the history</a>
<a name="ln972">  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));</a>
<a name="ln973">  if (s) {</a>
<a name="ln974">    if (len &lt; 0) {</a>
<a name="ln975">      len = (int)strlen(s);</a>
<a name="ln976">    }</a>
<a name="ln977">    // remove leading and trailing newlines</a>
<a name="ln978">    while (len &gt; 0 &amp;&amp; *s == '\n') {</a>
<a name="ln979">      s++;</a>
<a name="ln980">      len--;</a>
<a name="ln981">    }</a>
<a name="ln982">    while (len &gt; 0 &amp;&amp; s[len - 1] == '\n') {</a>
<a name="ln983">      len--;</a>
<a name="ln984">    }</a>
<a name="ln985">    p-&gt;msg = xmemdupz(s, (size_t)len);</a>
<a name="ln986">  } else {</a>
<a name="ln987">    p-&gt;msg = NULL;</a>
<a name="ln988">  }</a>
<a name="ln989">  p-&gt;next = NULL;</a>
<a name="ln990">  p-&gt;attr = attr;</a>
<a name="ln991">  p-&gt;multiline = multiline;</a>
<a name="ln992">  p-&gt;multiattr = multiattr;</a>
<a name="ln993">  p-&gt;kind = msg_ext_kind;</a>
<a name="ln994">  if (last_msg_hist != NULL) {</a>
<a name="ln995">    last_msg_hist-&gt;next = p;</a>
<a name="ln996">  }</a>
<a name="ln997">  last_msg_hist = p;</a>
<a name="ln998">  if (first_msg_hist == NULL) {</a>
<a name="ln999">    first_msg_hist = last_msg_hist;</a>
<a name="ln1000">  }</a>
<a name="ln1001">  msg_hist_len++;</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">/// Delete the first (oldest) message from the history.</a>
<a name="ln1005">///</a>
<a name="ln1006">/// @return  FAIL if there are no messages.</a>
<a name="ln1007">int delete_first_msg(void)</a>
<a name="ln1008">{</a>
<a name="ln1009">  struct msg_hist *p;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (msg_hist_len &lt;= 0) {</a>
<a name="ln1012">    return FAIL;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  p = first_msg_hist;</a>
<a name="ln1015">  first_msg_hist = p-&gt;next;</a>
<a name="ln1016">  if (first_msg_hist == NULL) {  // history is becoming empty</a>
<a name="ln1017">    assert(msg_hist_len == 1);</a>
<a name="ln1018">    last_msg_hist = NULL;</a>
<a name="ln1019">  }</a>
<a name="ln1020">  xfree(p-&gt;msg);</a>
<a name="ln1021">  hl_msg_free(p-&gt;multiattr);</a>
<a name="ln1022">  xfree(p);</a>
<a name="ln1023">  msg_hist_len--;</a>
<a name="ln1024">  return OK;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/// :messages command implementation</a>
<a name="ln1028">void ex_messages(void *const eap_p)</a>
<a name="ln1029">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1030">{</a>
<a name="ln1031">  const exarg_T *const eap = (const exarg_T *)eap_p;</a>
<a name="ln1032">  struct msg_hist *p;</a>
<a name="ln1033"> </a>
<a name="ln1034">  if (strcmp(eap-&gt;arg, &quot;clear&quot;) == 0) {</a>
<a name="ln1035">    int keep = eap-&gt;addr_count == 0 ? 0 : eap-&gt;line2;</a>
<a name="ln1036"> </a>
<a name="ln1037">    while (msg_hist_len &gt; keep) {</a>
<a name="ln1038">      (void)delete_first_msg();</a>
<a name="ln1039">    }</a>
<a name="ln1040">    return;</a>
<a name="ln1041">  }</a>
<a name="ln1042"> </a>
<a name="ln1043">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1044">    emsg(_(e_invarg));</a>
<a name="ln1045">    return;</a>
<a name="ln1046">  }</a>
<a name="ln1047"> </a>
<a name="ln1048">  p = first_msg_hist;</a>
<a name="ln1049"> </a>
<a name="ln1050">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln1051">    int c = 0;</a>
<a name="ln1052">    // Count total messages</a>
<a name="ln1053">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1054">      c++;</a>
<a name="ln1055">    }</a>
<a name="ln1056"> </a>
<a name="ln1057">    c -= eap-&gt;line2;</a>
<a name="ln1058"> </a>
<a name="ln1059">    // Skip without number of messages specified</a>
<a name="ln1060">    for (p = first_msg_hist; p != NULL &amp;&amp; !got_int &amp;&amp; c &gt; 0; p = p-&gt;next, c--) {}</a>
<a name="ln1061">  }</a>
<a name="ln1062"> </a>
<a name="ln1063">  // Display what was not skipped.</a>
<a name="ln1064">  if (ui_has(kUIMessages)) {</a>
<a name="ln1065">    if (msg_silent) {</a>
<a name="ln1066">      return;</a>
<a name="ln1067">    }</a>
<a name="ln1068">    Array entries = ARRAY_DICT_INIT;</a>
<a name="ln1069">    for (; p != NULL; p = p-&gt;next) {</a>
<a name="ln1070">      if (kv_size(p-&gt;multiattr) || (p-&gt;msg &amp;&amp; p-&gt;msg[0])) {</a>
<a name="ln1071">        Array entry = ARRAY_DICT_INIT;</a>
<a name="ln1072">        ADD(entry, CSTR_TO_OBJ(p-&gt;kind));</a>
<a name="ln1073">        Array content = ARRAY_DICT_INIT;</a>
<a name="ln1074">        if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1075">          for (uint32_t i = 0; i &lt; kv_size(p-&gt;multiattr); i++) {</a>
<a name="ln1076">            HlMessageChunk chunk = kv_A(p-&gt;multiattr, i);</a>
<a name="ln1077">            Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1078">            ADD(content_entry, INTEGER_OBJ(chunk.attr));</a>
<a name="ln1079">            ADD(content_entry, STRING_OBJ(copy_string(chunk.text, NULL)));</a>
<a name="ln1080">            ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1081">          }</a>
<a name="ln1082">        } else if (p-&gt;msg &amp;&amp; p-&gt;msg[0]) {</a>
<a name="ln1083">          Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1084">          ADD(content_entry, INTEGER_OBJ(p-&gt;attr));</a>
<a name="ln1085">          ADD(content_entry, CSTR_TO_OBJ(p-&gt;msg));</a>
<a name="ln1086">          ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1087">        }</a>
<a name="ln1088">        ADD(entry, ARRAY_OBJ(content));</a>
<a name="ln1089">        ADD(entries, ARRAY_OBJ(entry));</a>
<a name="ln1090">      }</a>
<a name="ln1091">    }</a>
<a name="ln1092">    ui_call_msg_history_show(entries);</a>
<a name="ln1093">    api_free_array(entries);</a>
<a name="ln1094">    msg_ext_history_visible = true;</a>
<a name="ln1095">    wait_return(false);</a>
<a name="ln1096">  } else {</a>
<a name="ln1097">    msg_hist_off = true;</a>
<a name="ln1098">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1099">      if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1100">        msg_multiattr(p-&gt;multiattr, p-&gt;kind, false);</a>
<a name="ln1101">      } else if (p-&gt;msg != NULL) {</a>
<a name="ln1102">        msg_attr_keep(p-&gt;msg, p-&gt;attr, false, p-&gt;multiline);</a>
<a name="ln1103">      }</a>
<a name="ln1104">    }</a>
<a name="ln1105">    msg_hist_off = false;</a>
<a name="ln1106">  }</a>
<a name="ln1107">}</a>
<a name="ln1108"> </a>
<a name="ln1109">/// Call this after prompting the user.  This will avoid a hit-return message</a>
<a name="ln1110">/// and a delay.</a>
<a name="ln1111">void msg_end_prompt(void)</a>
<a name="ln1112">{</a>
<a name="ln1113">  msg_ext_clear_later();</a>
<a name="ln1114">  need_wait_return = false;</a>
<a name="ln1115">  emsg_on_display = false;</a>
<a name="ln1116">  cmdline_row = msg_row;</a>
<a name="ln1117">  msg_col = 0;</a>
<a name="ln1118">  msg_clr_eos();</a>
<a name="ln1119">  lines_left = -1;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/// Wait for the user to hit a key (normally Enter)</a>
<a name="ln1123">///</a>
<a name="ln1124">/// @param redraw  if true, redraw the entire screen UPD_NOT_VALID</a>
<a name="ln1125">///                if false, do a normal redraw</a>
<a name="ln1126">///                if -1, don't redraw at all</a>
<a name="ln1127">void wait_return(int redraw)</a>
<a name="ln1128">{</a>
<a name="ln1129">  int c;</a>
<a name="ln1130">  int oldState;</a>
<a name="ln1131">  int tmpState;</a>
<a name="ln1132">  int had_got_int;</a>
<a name="ln1133">  FILE *save_scriptout;</a>
<a name="ln1134"> </a>
<a name="ln1135">  if (redraw == true) {</a>
<a name="ln1136">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln1137">  }</a>
<a name="ln1138"> </a>
<a name="ln1139">  // If using &quot;:silent cmd&quot;, don't wait for a return.  Also don't set</a>
<a name="ln1140">  // need_wait_return to do it later.</a>
<a name="ln1141">  if (msg_silent != 0) {</a>
<a name="ln1142">    return;</a>
<a name="ln1143">  }</a>
<a name="ln1144"> </a>
<a name="ln1145">  if (headless_mode &amp;&amp; !ui_active()) {</a>
<a name="ln1146">    return;</a>
<a name="ln1147">  }</a>
<a name="ln1148"> </a>
<a name="ln1149">  // When inside vgetc(), we can't wait for a typed character at all.</a>
<a name="ln1150">  // With the global command (and some others) we only need one return at</a>
<a name="ln1151">  // the end. Adjust cmdline_row to avoid the next message overwriting the</a>
<a name="ln1152">  // last one.</a>
<a name="ln1153">  if (vgetc_busy &gt; 0) {</a>
<a name="ln1154">    return;</a>
<a name="ln1155">  }</a>
<a name="ln1156">  need_wait_return = true;</a>
<a name="ln1157">  if (no_wait_return) {</a>
<a name="ln1158">    if (!exmode_active) {</a>
<a name="ln1159">      cmdline_row = msg_row;</a>
<a name="ln1160">    }</a>
<a name="ln1161">    return;</a>
<a name="ln1162">  }</a>
<a name="ln1163"> </a>
<a name="ln1164">  redir_off = true;             // don't redirect this message</a>
<a name="ln1165">  oldState = State;</a>
<a name="ln1166">  if (quit_more) {</a>
<a name="ln1167">    c = CAR;                    // just pretend CR was hit</a>
<a name="ln1168">    quit_more = false;</a>
<a name="ln1169">    got_int = false;</a>
<a name="ln1170">  } else if (exmode_active) {</a>
<a name="ln1171">    msg_puts(&quot; &quot;);              // make sure the cursor is on the right line</a>
<a name="ln1172">    c = CAR;                    // no need for a return in ex mode</a>
<a name="ln1173">    got_int = false;</a>
<a name="ln1174">  } else {</a>
<a name="ln1175">    State = MODE_HITRETURN;</a>
<a name="ln1176">    setmouse();</a>
<a name="ln1177">    cmdline_row = msg_row;</a>
<a name="ln1178">    // Avoid the sequence that the user types &quot;:&quot; at the hit-return prompt</a>
<a name="ln1179">    // to start an Ex command, but the file-changed dialog gets in the</a>
<a name="ln1180">    // way.</a>
<a name="ln1181">    if (need_check_timestamps) {</a>
<a name="ln1182">      check_timestamps(false);</a>
<a name="ln1183">    }</a>
<a name="ln1184"> </a>
<a name="ln1185">    hit_return_msg();</a>
<a name="ln1186"> </a>
<a name="ln1187">    do {</a>
<a name="ln1188">      // Remember &quot;got_int&quot;, if it is set vgetc() probably returns a</a>
<a name="ln1189">      // CTRL-C, but we need to loop then.</a>
<a name="ln1190">      had_got_int = got_int;</a>
<a name="ln1191"> </a>
<a name="ln1192">      // Don't do mappings here, we put the character back in the</a>
<a name="ln1193">      // typeahead buffer.</a>
<a name="ln1194">      no_mapping++;</a>
<a name="ln1195">      allow_keys++;</a>
<a name="ln1196"> </a>
<a name="ln1197">      // Temporarily disable Recording. If Recording is active, the</a>
<a name="ln1198">      // character will be recorded later, since it will be added to the</a>
<a name="ln1199">      // typebuf after the loop</a>
<a name="ln1200">      const int save_reg_recording = reg_recording;</a>
<a name="ln1201">      save_scriptout = scriptout;</a>
<a name="ln1202">      reg_recording = 0;</a>
<a name="ln1203">      scriptout = NULL;</a>
<a name="ln1204">      c = safe_vgetc();</a>
<a name="ln1205">      if (had_got_int &amp;&amp; !global_busy) {</a>
<a name="ln1206">        got_int = false;</a>
<a name="ln1207">      }</a>
<a name="ln1208">      no_mapping--;</a>
<a name="ln1209">      allow_keys--;</a>
<a name="ln1210">      reg_recording = save_reg_recording;</a>
<a name="ln1211">      scriptout = save_scriptout;</a>
<a name="ln1212"> </a>
<a name="ln1213">      // Allow scrolling back in the messages.</a>
<a name="ln1214">      // Also accept scroll-down commands when messages fill the screen,</a>
<a name="ln1215">      // to avoid that typing one 'j' too many makes the messages</a>
<a name="ln1216">      // disappear.</a>
<a name="ln1217">      if (p_more) {</a>
<a name="ln1218">        if (c == 'b' || c == 'k' || c == 'u' || c == 'g'</a>
<a name="ln1219">            || c == K_UP || c == K_PAGEUP) {</a>
<a name="ln1220">          if (msg_scrolled &gt; Rows) {</a>
<a name="ln1221">            // scroll back to show older messages</a>
<a name="ln1222">            do_more_prompt(c);</a>
<a name="ln1223">          } else {</a>
<a name="ln1224">            msg_didout = false;</a>
<a name="ln1225">            c = K_IGNORE;</a>
<a name="ln1226">            msg_col =</a>
<a name="ln1227">              cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1228">              0;</a>
<a name="ln1229">          }</a>
<a name="ln1230">          if (quit_more) {</a>
<a name="ln1231">            c = CAR;                            // just pretend CR was hit</a>
<a name="ln1232">            quit_more = false;</a>
<a name="ln1233">            got_int = false;</a>
<a name="ln1234">          } else if (c != K_IGNORE) {</a>
<a name="ln1235">            c = K_IGNORE;</a>
<a name="ln1236">            hit_return_msg();</a>
<a name="ln1237">          }</a>
<a name="ln1238">        } else if (msg_scrolled &gt; Rows - 2</a>
<a name="ln1239">                   &amp;&amp; (c == 'j' || c == 'd' || c == 'f'</a>
<a name="ln1240">                       || c == K_DOWN || c == K_PAGEDOWN)) {</a>
<a name="ln1241">          c = K_IGNORE;</a>
<a name="ln1242">        }</a>
<a name="ln1243">      }</a>
<a name="ln1244">    } while ((had_got_int &amp;&amp; c == Ctrl_C)</a>
<a name="ln1245">             || c == K_IGNORE</a>
<a name="ln1246">             || c == K_LEFTDRAG || c == K_LEFTRELEASE</a>
<a name="ln1247">             || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE</a>
<a name="ln1248">             || c == K_RIGHTDRAG || c == K_RIGHTRELEASE</a>
<a name="ln1249">             || c == K_MOUSELEFT || c == K_MOUSERIGHT</a>
<a name="ln1250">             || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln1251">             || c == K_MOUSEMOVE);</a>
<a name="ln1252">    os_breakcheck();</a>
<a name="ln1253"> </a>
<a name="ln1254">    // Avoid that the mouse-up event causes visual mode to start.</a>
<a name="ln1255">    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE</a>
<a name="ln1256">        || c == K_X1MOUSE || c == K_X2MOUSE) {</a>
<a name="ln1257">      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);</a>
<a name="ln1258">    } else if (vim_strchr(&quot;\r\n &quot;, c) == NULL &amp;&amp; c != Ctrl_C) {</a>
<a name="ln1259">      // Put the character back in the typeahead buffer.  Don't use the</a>
<a name="ln1260">      // stuff buffer, because lmaps wouldn't work.</a>
<a name="ln1261">      ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1262">      do_redraw = true;             // need a redraw even though there is</a>
<a name="ln1263">                                    // typeahead</a>
<a name="ln1264">    }</a>
<a name="ln1265">  }</a>
<a name="ln1266">  redir_off = false;</a>
<a name="ln1267"> </a>
<a name="ln1268">  // If the user hits ':', '?' or '/' we get a command line from the next</a>
<a name="ln1269">  // line.</a>
<a name="ln1270">  if (c == ':' || c == '?' || c == '/') {</a>
<a name="ln1271">    if (!exmode_active) {</a>
<a name="ln1272">      cmdline_row = msg_row;</a>
<a name="ln1273">    }</a>
<a name="ln1274">    skip_redraw = true;  // skip redraw once</a>
<a name="ln1275">    do_redraw = false;</a>
<a name="ln1276">    msg_ext_keep_after_cmdline = true;</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  // If the screen size changed screen_resize() will redraw the screen.</a>
<a name="ln1280">  // Otherwise the screen is only redrawn if 'redraw' is set and no ':'</a>
<a name="ln1281">  // typed.</a>
<a name="ln1282">  tmpState = State;</a>
<a name="ln1283">  State = oldState;  // restore State before screen_resize()</a>
<a name="ln1284">  setmouse();</a>
<a name="ln1285">  msg_check();</a>
<a name="ln1286">  need_wait_return = false;</a>
<a name="ln1287">  did_wait_return = true;</a>
<a name="ln1288">  emsg_on_display = false;      // can delete error message now</a>
<a name="ln1289">  lines_left = -1;              // reset lines_left at next msg_start()</a>
<a name="ln1290">  reset_last_sourcing();</a>
<a name="ln1291">  if (keep_msg != NULL &amp;&amp; vim_strsize(keep_msg) &gt;=</a>
<a name="ln1292">      (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln1293">    XFREE_CLEAR(keep_msg);          // don't redisplay message, it's too long</a>
<a name="ln1294">  }</a>
<a name="ln1295"> </a>
<a name="ln1296">  if (tmpState == MODE_SETWSIZE) {       // got resize event while in vgetc()</a>
<a name="ln1297">    ui_refresh();</a>
<a name="ln1298">  } else if (!skip_redraw) {</a>
<a name="ln1299">    if (redraw == true || (msg_scrolled != 0 &amp;&amp; redraw != -1)) {</a>
<a name="ln1300">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln1301">    }</a>
<a name="ln1302">    if (ui_has(kUIMessages)) {</a>
<a name="ln1303">      msg_ext_clear(true);</a>
<a name="ln1304">    }</a>
<a name="ln1305">  }</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308">/// Write the hit-return prompt.</a>
<a name="ln1309">static void hit_return_msg(void)</a>
<a name="ln1310">{</a>
<a name="ln1311">  int save_p_more = p_more;</a>
<a name="ln1312"> </a>
<a name="ln1313">  p_more = false;       // don't want to see this message when scrolling back</a>
<a name="ln1314">  if (msg_didout) {     // start on a new line</a>
<a name="ln1315">    msg_putchar('\n');</a>
<a name="ln1316">  }</a>
<a name="ln1317">  msg_ext_set_kind(&quot;return_prompt&quot;);</a>
<a name="ln1318">  if (got_int) {</a>
<a name="ln1319">    msg_puts(_(&quot;Interrupt: &quot;));</a>
<a name="ln1320">  }</a>
<a name="ln1321"> </a>
<a name="ln1322">  msg_puts_attr(_(&quot;Press ENTER or type command to continue&quot;), HL_ATTR(HLF_R));</a>
<a name="ln1323">  if (!msg_use_printf()) {</a>
<a name="ln1324">    msg_clr_eos();</a>
<a name="ln1325">  }</a>
<a name="ln1326">  p_more = save_p_more;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">/// Set &quot;keep_msg&quot; to &quot;s&quot;.  Free the old value and check for NULL pointer.</a>
<a name="ln1330">void set_keep_msg(const char *s, int attr)</a>
<a name="ln1331">{</a>
<a name="ln1332">  xfree(keep_msg);</a>
<a name="ln1333">  if (s != NULL &amp;&amp; msg_silent == 0) {</a>
<a name="ln1334">    keep_msg = xstrdup(s);</a>
<a name="ln1335">  } else {</a>
<a name="ln1336">    keep_msg = NULL;</a>
<a name="ln1337">  }</a>
<a name="ln1338">  keep_msg_more = false;</a>
<a name="ln1339">  keep_msg_attr = attr;</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">/// Return true if printing messages should currently be done.</a>
<a name="ln1343">bool messaging(void)</a>
<a name="ln1344">{</a>
<a name="ln1345">  // TODO(bfredl): with general support for &quot;async&quot; messages with p_ch,</a>
<a name="ln1346">  // this should be re-enabled.</a>
<a name="ln1347">  return !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped) &amp;&amp; (p_ch &gt; 0 || ui_has(kUIMessages));</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">void msgmore(long n)</a>
<a name="ln1351">{</a>
<a name="ln1352">  long pn;</a>
<a name="ln1353"> </a>
<a name="ln1354">  if (global_busy           // no messages now, wait until global is finished</a>
<a name="ln1355">      || !messaging()) {      // 'lazyredraw' set, don't do messages now</a>
<a name="ln1356">    return;</a>
<a name="ln1357">  }</a>
<a name="ln1358"> </a>
<a name="ln1359">  // We don't want to overwrite another important message, but do overwrite</a>
<a name="ln1360">  // a previous &quot;more lines&quot; or &quot;fewer lines&quot; message, so that &quot;5dd&quot; and</a>
<a name="ln1361">  // then &quot;put&quot; reports the last action.</a>
<a name="ln1362">  if (keep_msg != NULL &amp;&amp; !keep_msg_more) {</a>
<a name="ln1363">    return;</a>
<a name="ln1364">  }</a>
<a name="ln1365"> </a>
<a name="ln1366">  if (n &gt; 0) {</a>
<a name="ln1367">    pn = n;</a>
<a name="ln1368">  } else {</a>
<a name="ln1369">    pn = -n;</a>
<a name="ln1370">  }</a>
<a name="ln1371"> </a>
<a name="ln1372">  if (pn &gt; p_report) {</a>
<a name="ln1373">    if (n &gt; 0) {</a>
<a name="ln1374">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1375">                   NGETTEXT(&quot;%ld more line&quot;, &quot;%ld more lines&quot;, pn),</a>
<a name="ln1376">                   pn);</a>
<a name="ln1377">    } else {</a>
<a name="ln1378">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1379">                   NGETTEXT(&quot;%ld line less&quot;, &quot;%ld fewer lines&quot;, pn),</a>
<a name="ln1380">                   pn);</a>
<a name="ln1381">    }</a>
<a name="ln1382">    if (got_int) {</a>
<a name="ln1383">      xstrlcat(msg_buf, _(&quot; (Interrupted)&quot;), MSG_BUF_LEN);</a>
<a name="ln1384">    }</a>
<a name="ln1385">    if (msg(msg_buf, 0)) {</a>
<a name="ln1386">      set_keep_msg(msg_buf, 0);</a>
<a name="ln1387">      keep_msg_more = true;</a>
<a name="ln1388">    }</a>
<a name="ln1389">  }</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">void msg_ext_set_kind(const char *msg_kind)</a>
<a name="ln1393">{</a>
<a name="ln1394">  // Don't change the label of an existing batch:</a>
<a name="ln1395">  msg_ext_ui_flush();</a>
<a name="ln1396"> </a>
<a name="ln1397">  // TODO(bfredl): would be nice to avoid dynamic scoping, but that would</a>
<a name="ln1398">  // need refactoring the msg_ interface to not be &quot;please pretend nvim is</a>
<a name="ln1399">  // a terminal for a moment&quot;</a>
<a name="ln1400">  msg_ext_kind = msg_kind;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">/// Prepare for outputting characters in the command line.</a>
<a name="ln1404">void msg_start(void)</a>
<a name="ln1405">{</a>
<a name="ln1406">  int did_return = false;</a>
<a name="ln1407"> </a>
<a name="ln1408">  if (!msg_silent) {</a>
<a name="ln1409">    XFREE_CLEAR(keep_msg);              // don't display old message now</a>
<a name="ln1410">    need_fileinfo = false;</a>
<a name="ln1411">  }</a>
<a name="ln1412"> </a>
<a name="ln1413">  if (need_clr_eos || (p_ch == 0 &amp;&amp; redrawing_cmdline)) {</a>
<a name="ln1414">    // Halfway an &quot;:echo&quot; command and getting an (error) message: clear</a>
<a name="ln1415">    // any text from the command.</a>
<a name="ln1416">    need_clr_eos = false;</a>
<a name="ln1417">    msg_clr_eos();</a>
<a name="ln1418">  }</a>
<a name="ln1419"> </a>
<a name="ln1420">  // if cmdheight=0, we need to scroll in the first line of msg_grid upon the screen</a>
<a name="ln1421">  if (p_ch == 0 &amp;&amp; !ui_has(kUIMessages) &amp;&amp; !msg_scrolled) {</a>
<a name="ln1422">    msg_grid_validate();</a>
<a name="ln1423">    msg_scroll_up(false, true);</a>
<a name="ln1424">    msg_scrolled++;</a>
<a name="ln1425">    cmdline_row = Rows - 1;</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  if (!msg_scroll &amp;&amp; full_screen) {     // overwrite last message</a>
<a name="ln1429">    msg_row = cmdline_row;</a>
<a name="ln1430">    msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln1431">  } else if (msg_didout || (p_ch == 0 &amp;&amp; !ui_has(kUIMessages))) {  // start message on next line</a>
<a name="ln1432">    msg_putchar('\n');</a>
<a name="ln1433">    did_return = true;</a>
<a name="ln1434">    cmdline_row = msg_row;</a>
<a name="ln1435">  }</a>
<a name="ln1436">  if (!msg_didany || lines_left &lt; 0) {</a>
<a name="ln1437">    msg_starthere();</a>
<a name="ln1438">  }</a>
<a name="ln1439">  if (msg_silent == 0) {</a>
<a name="ln1440">    msg_didout = false;                     // no output on current line yet</a>
<a name="ln1441">  }</a>
<a name="ln1442"> </a>
<a name="ln1443">  if (ui_has(kUIMessages)) {</a>
<a name="ln1444">    msg_ext_ui_flush();</a>
<a name="ln1445">    if (!msg_scroll &amp;&amp; msg_ext_visible) {</a>
<a name="ln1446">      // Will overwrite last message.</a>
<a name="ln1447">      msg_ext_overwrite = true;</a>
<a name="ln1448">    }</a>
<a name="ln1449">  }</a>
<a name="ln1450"> </a>
<a name="ln1451">  // When redirecting, may need to start a new line.</a>
<a name="ln1452">  if (!did_return) {</a>
<a name="ln1453">    redir_write(&quot;\n&quot;, 1);</a>
<a name="ln1454">  }</a>
<a name="ln1455">}</a>
<a name="ln1456"> </a>
<a name="ln1457">/// Note that the current msg position is where messages start.</a>
<a name="ln1458">void msg_starthere(void)</a>
<a name="ln1459">{</a>
<a name="ln1460">  lines_left = cmdline_row;</a>
<a name="ln1461">  msg_didany = false;</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">void msg_putchar(int c)</a>
<a name="ln1465">{</a>
<a name="ln1466">  msg_putchar_attr(c, 0);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">void msg_putchar_attr(int c, int attr)</a>
<a name="ln1470">{</a>
<a name="ln1471">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln1472"> </a>
<a name="ln1473">  if (IS_SPECIAL(c)) {</a>
<a name="ln1474">    buf[0] = (char)K_SPECIAL;</a>
<a name="ln1475">    buf[1] = (char)K_SECOND(c);</a>
<a name="ln1476">    buf[2] = (char)K_THIRD(c);</a>
<a name="ln1477">    buf[3] = NUL;</a>
<a name="ln1478">  } else {</a>
<a name="ln1479">    buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln1480">  }</a>
<a name="ln1481">  msg_puts_attr(buf, attr);</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">void msg_outnum(long n)</a>
<a name="ln1485">{</a>
<a name="ln1486">  char buf[20];</a>
<a name="ln1487"> </a>
<a name="ln1488">  snprintf(buf, sizeof(buf), &quot;%ld&quot;, n);</a>
<a name="ln1489">  msg_puts(buf);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">void msg_home_replace(const char *fname)</a>
<a name="ln1493">{</a>
<a name="ln1494">  msg_home_replace_attr(fname, 0);</a>
<a name="ln1495">}</a>
<a name="ln1496"> </a>
<a name="ln1497">void msg_home_replace_hl(const char *fname)</a>
<a name="ln1498">{</a>
<a name="ln1499">  msg_home_replace_attr(fname, HL_ATTR(HLF_D));</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">static void msg_home_replace_attr(const char *fname, int attr)</a>
<a name="ln1503">{</a>
<a name="ln1504">  char *name = home_replace_save(NULL, fname);</a>
<a name="ln1505">  msg_outtrans(name, attr);</a>
<a name="ln1506">  xfree(name);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">/// Output 'len' characters in 'str' (including NULs) with translation</a>
<a name="ln1510">/// if 'len' is -1, output up to a NUL character.</a>
<a name="ln1511">/// Use attributes 'attr'.</a>
<a name="ln1512">///</a>
<a name="ln1513">/// @return  the number of characters it takes on the screen.</a>
<a name="ln1514">int msg_outtrans(const char *str, int attr)</a>
<a name="ln1515">{</a>
<a name="ln1516">  return msg_outtrans_len(str, (int)strlen(str), attr);</a>
<a name="ln1517">}</a>
<a name="ln1518"> </a>
<a name="ln1519">/// Output one character at &quot;p&quot;.</a>
<a name="ln1520">/// Handles multi-byte characters.</a>
<a name="ln1521">///</a>
<a name="ln1522">/// @return  pointer to the next character.</a>
<a name="ln1523">const char *msg_outtrans_one(const char *p, int attr)</a>
<a name="ln1524">{</a>
<a name="ln1525">  int l;</a>
<a name="ln1526"> </a>
<a name="ln1527">  if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln1528">    msg_outtrans_len(p, l, attr);</a>
<a name="ln1529">    return p + l;</a>
<a name="ln1530">  }</a>
<a name="ln1531">  msg_puts_attr(transchar_byte_buf(NULL, (uint8_t)(*p)), attr);</a>
<a name="ln1532">  return p + 1;</a>
<a name="ln1533">}</a>
<a name="ln1534"> </a>
<a name="ln1535">int msg_outtrans_len(const char *msgstr, int len, int attr)</a>
<a name="ln1536">{</a>
<a name="ln1537">  int retval = 0;</a>
<a name="ln1538">  const char *str = msgstr;</a>
<a name="ln1539">  const char *plain_start = msgstr;</a>
<a name="ln1540">  char *s;</a>
<a name="ln1541">  int c;</a>
<a name="ln1542">  int save_got_int = got_int;</a>
<a name="ln1543"> </a>
<a name="ln1544">  // Only quit when got_int was set in here.</a>
<a name="ln1545">  got_int = false;</a>
<a name="ln1546"> </a>
<a name="ln1547">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1548">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1549">    add_msg_hist(str, len, attr, false);</a>
<a name="ln1550">    attr &amp;= ~MSG_HIST;</a>
<a name="ln1551">  }</a>
<a name="ln1552"> </a>
<a name="ln1553">  // When drawing over the command line no need to clear it later or remove</a>
<a name="ln1554">  // the mode message.</a>
<a name="ln1555">  if (msg_row &gt;= cmdline_row &amp;&amp; msg_col == 0) {</a>
<a name="ln1556">    clear_cmdline = false;</a>
<a name="ln1557">    mode_displayed = false;</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  // If the string starts with a composing character first draw a space on</a>
<a name="ln1561">  // which the composing char can be drawn.</a>
<a name="ln1562">  if (utf_iscomposing(utf_ptr2char(msgstr))) {</a>
<a name="ln1563">    msg_puts_attr(&quot; &quot;, attr);</a>
<a name="ln1564">  }</a>
<a name="ln1565"> </a>
<a name="ln1566">  // Go over the string.  Special characters are translated and printed.</a>
<a name="ln1567">  // Normal characters are printed several at a time.</a>
<a name="ln1568">  while (--len &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1569">    // Don't include composing chars after the end.</a>
<a name="ln1570">    int mb_l = utfc_ptr2len_len(str, len + 1);</a>
<a name="ln1571">    if (mb_l &gt; 1) {</a>
<a name="ln1572">      c = utf_ptr2char(str);</a>
<a name="ln1573">      if (vim_isprintc(c)) {</a>
<a name="ln1574">        // Printable multi-byte char: count the cells.</a>
<a name="ln1575">        retval += utf_ptr2cells(str);</a>
<a name="ln1576">      } else {</a>
<a name="ln1577">        // Unprintable multi-byte char: print the printable chars so</a>
<a name="ln1578">        // far and the translation of the unprintable char.</a>
<a name="ln1579">        if (str &gt; plain_start) {</a>
<a name="ln1580">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1581">        }</a>
<a name="ln1582">        plain_start = str + mb_l;</a>
<a name="ln1583">        msg_puts_attr(transchar_buf(NULL, c), attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1584">        retval += char2cells(c);</a>
<a name="ln1585">      }</a>
<a name="ln1586">      len -= mb_l - 1;</a>
<a name="ln1587">      str += mb_l;</a>
<a name="ln1588">    } else {</a>
<a name="ln1589">      s = transchar_byte_buf(NULL, (uint8_t)(*str));</a>
<a name="ln1590">      if (s[1] != NUL) {</a>
<a name="ln1591">        // Unprintable char: print the printable chars so far and the</a>
<a name="ln1592">        // translation of the unprintable char.</a>
<a name="ln1593">        if (str &gt; plain_start) {</a>
<a name="ln1594">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1595">        }</a>
<a name="ln1596">        plain_start = str + 1;</a>
<a name="ln1597">        msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1598">        retval += (int)strlen(s);</a>
<a name="ln1599">      } else {</a>
<a name="ln1600">        retval++;</a>
<a name="ln1601">      }</a>
<a name="ln1602">      str++;</a>
<a name="ln1603">    }</a>
<a name="ln1604">  }</a>
<a name="ln1605"> </a>
<a name="ln1606">  if (str &gt; plain_start &amp;&amp; !got_int) {</a>
<a name="ln1607">    // Print the printable chars at the end.</a>
<a name="ln1608">    msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1609">  }</a>
<a name="ln1610"> </a>
<a name="ln1611">  got_int |= save_got_int;</a>
<a name="ln1612"> </a>
<a name="ln1613">  return retval;</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">void msg_make(const char *arg)</a>
<a name="ln1617">{</a>
<a name="ln1618">  int i;</a>
<a name="ln1619">  static const char *str = &quot;eeffoc&quot;;</a>
<a name="ln1620">  static const char *rs = &quot;Plon#dqg#vxjduB&quot;;</a>
<a name="ln1621"> </a>
<a name="ln1622">  arg = skipwhite(arg);</a>
<a name="ln1623">  for (i = 5; *arg &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln1624">    if (*arg++ != str[i]) {</a>
<a name="ln1625">      break;</a>
<a name="ln1626">    }</a>
<a name="ln1627">  }</a>
<a name="ln1628">  if (i &lt; 0) {</a>
<a name="ln1629">    msg_putchar('\n');</a>
<a name="ln1630">    for (i = 0; rs[i]; i++) {</a>
<a name="ln1631">      msg_putchar(rs[i] - 3);</a>
<a name="ln1632">    }</a>
<a name="ln1633">  }</a>
<a name="ln1634">}</a>
<a name="ln1635"> </a>
<a name="ln1636">/// Output the string 'str' up to a NUL character.</a>
<a name="ln1637">/// Return the number of characters it takes on the screen.</a>
<a name="ln1638">///</a>
<a name="ln1639">/// If K_SPECIAL is encountered, then it is taken in conjunction with the</a>
<a name="ln1640">/// following character and shown as &lt;F1&gt;, &lt;S-Up&gt; etc.  Any other character</a>
<a name="ln1641">/// which is not printable shown in &lt;&gt; form.</a>
<a name="ln1642">/// If 'from' is true (lhs of a mapping), a space is shown as &lt;Space&gt;.</a>
<a name="ln1643">/// If a character is displayed in one of these special ways, is also</a>
<a name="ln1644">/// highlighted (its highlight name is '8' in the p_hl variable).</a>
<a name="ln1645">/// Otherwise characters are not highlighted.</a>
<a name="ln1646">/// This function is used to show mappings, where we want to see how to type</a>
<a name="ln1647">/// the character/string -- webb</a>
<a name="ln1648">///</a>
<a name="ln1649">/// @param from  true for LHS of a mapping</a>
<a name="ln1650">/// @param maxlen  screen columns, 0 for unlimited</a>
<a name="ln1651">int msg_outtrans_special(const char *strstart, bool from, int maxlen)</a>
<a name="ln1652">{</a>
<a name="ln1653">  if (strstart == NULL) {</a>
<a name="ln1654">    return 0;  // Do nothing.</a>
<a name="ln1655">  }</a>
<a name="ln1656">  const char *str = strstart;</a>
<a name="ln1657">  int retval = 0;</a>
<a name="ln1658">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln1659"> </a>
<a name="ln1660">  while (*str != NUL) {</a>
<a name="ln1661">    const char *text;</a>
<a name="ln1662">    // Leading and trailing spaces need to be displayed in &lt;&gt; form.</a>
<a name="ln1663">    if ((str == strstart || str[1] == NUL) &amp;&amp; *str == ' ') {</a>
<a name="ln1664">      text = &quot;&lt;Space&gt;&quot;;</a>
<a name="ln1665">      str++;</a>
<a name="ln1666">    } else {</a>
<a name="ln1667">      text = str2special(&amp;str, from, false);</a>
<a name="ln1668">    }</a>
<a name="ln1669">    if (text[0] != NUL &amp;&amp; text[1] == NUL) {</a>
<a name="ln1670">      // single-byte character or illegal byte</a>
<a name="ln1671">      text = transchar_byte_buf(NULL, (uint8_t)text[0]);</a>
<a name="ln1672">    }</a>
<a name="ln1673">    const int len = vim_strsize(text);</a>
<a name="ln1674">    if (maxlen &gt; 0 &amp;&amp; retval + len &gt;= maxlen) {</a>
<a name="ln1675">      break;</a>
<a name="ln1676">    }</a>
<a name="ln1677">    // Highlight special keys</a>
<a name="ln1678">    msg_puts_attr(text, (len &gt; 1</a>
<a name="ln1679">                         &amp;&amp; utfc_ptr2len(text) &lt;= 1</a>
<a name="ln1680">                         ? attr : 0));</a>
<a name="ln1681">    retval += len;</a>
<a name="ln1682">  }</a>
<a name="ln1683">  return retval;</a>
<a name="ln1684">}</a>
<a name="ln1685"> </a>
<a name="ln1686">/// Convert string, replacing key codes with printables</a>
<a name="ln1687">///</a>
<a name="ln1688">/// Used for lhs or rhs of mappings.</a>
<a name="ln1689">///</a>
<a name="ln1690">/// @param[in]  str  String to convert.</a>
<a name="ln1691">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1692">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1693">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1694">///</a>
<a name="ln1695">/// @return [allocated] Converted string.</a>
<a name="ln1696">char *str2special_save(const char *const str, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1697">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1698">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1699">{</a>
<a name="ln1700">  garray_T ga;</a>
<a name="ln1701">  ga_init(&amp;ga, 1, 40);</a>
<a name="ln1702"> </a>
<a name="ln1703">  const char *p = str;</a>
<a name="ln1704">  while (*p != NUL) {</a>
<a name="ln1705">    ga_concat(&amp;ga, str2special(&amp;p, replace_spaces, replace_lt));</a>
<a name="ln1706">  }</a>
<a name="ln1707">  ga_append(&amp;ga, NUL);</a>
<a name="ln1708">  return (char *)ga.ga_data;</a>
<a name="ln1709">}</a>
<a name="ln1710"> </a>
<a name="ln1711">/// Convert character, replacing key with printable representation.</a>
<a name="ln1712">///</a>
<a name="ln1713">/// @param[in,out]  sp  String to convert. Is advanced to the next key code.</a>
<a name="ln1714">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1715">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1716">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1717">///</a>
<a name="ln1718">/// @return Converted key code, in a static buffer. Buffer is always one and the</a>
<a name="ln1719">///         same, so save converted string somewhere before running str2special</a>
<a name="ln1720">///         for the second time.</a>
<a name="ln1721">///         On illegal byte return a string with only that byte.</a>
<a name="ln1722">const char *str2special(const char **const sp, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1723">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET</a>
<a name="ln1724">{</a>
<a name="ln1725">  static char buf[7];</a>
<a name="ln1726"> </a>
<a name="ln1727">  {</a>
<a name="ln1728">    // Try to un-escape a multi-byte character.  Return the un-escaped</a>
<a name="ln1729">    // string if it is a multi-byte character.</a>
<a name="ln1730">    const char *const p = mb_unescape(sp);</a>
<a name="ln1731">    if (p != NULL) {</a>
<a name="ln1732">      return p;</a>
<a name="ln1733">    }</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">  const char *str = *sp;</a>
<a name="ln1737">  int c = (uint8_t)(*str);</a>
<a name="ln1738">  int modifiers = 0;</a>
<a name="ln1739">  bool special = false;</a>
<a name="ln1740">  if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1741">    if ((uint8_t)str[1] == KS_MODIFIER) {</a>
<a name="ln1742">      modifiers = (uint8_t)str[2];</a>
<a name="ln1743">      str += 3;</a>
<a name="ln1744">      c = (uint8_t)(*str);</a>
<a name="ln1745">    }</a>
<a name="ln1746">    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1747">      c = TO_SPECIAL((uint8_t)str[1], (uint8_t)str[2]);</a>
<a name="ln1748">      str += 2;</a>
<a name="ln1749">    }</a>
<a name="ln1750">    if (IS_SPECIAL(c) || modifiers) {  // Special key.</a>
<a name="ln1751">      special = true;</a>
<a name="ln1752">    }</a>
<a name="ln1753">  }</a>
<a name="ln1754"> </a>
<a name="ln1755">  if (!IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1) {</a>
<a name="ln1756">    *sp = str;</a>
<a name="ln1757">    // Try to un-escape a multi-byte character after modifiers.</a>
<a name="ln1758">    const char *p = mb_unescape(sp);</a>
<a name="ln1759">    if (p != NULL) {</a>
<a name="ln1760">      // Since 'special' is true the multi-byte character 'c' will be</a>
<a name="ln1761">      // processed by get_special_key_name().</a>
<a name="ln1762">      c = utf_ptr2char(p);</a>
<a name="ln1763">    } else {</a>
<a name="ln1764">      // illegal byte</a>
<a name="ln1765">      *sp = str + 1;</a>
<a name="ln1766">    }</a>
<a name="ln1767">  } else {</a>
<a name="ln1768">    // single-byte character, NUL or illegal byte</a>
<a name="ln1769">    *sp = str + (*str == NUL ? 0 : 1);</a>
<a name="ln1770">  }</a>
<a name="ln1771"> </a>
<a name="ln1772">  // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.</a>
<a name="ln1773">  if (special</a>
<a name="ln1774">      || c &lt; ' '</a>
<a name="ln1775">      || (replace_spaces &amp;&amp; c == ' ')</a>
<a name="ln1776">      || (replace_lt &amp;&amp; c == '&lt;')) {</a>
<a name="ln1777">    return get_special_key_name(c, modifiers);</a>
<a name="ln1778">  }</a>
<a name="ln1779">  buf[0] = (char)c;</a>
<a name="ln1780">  buf[1] = NUL;</a>
<a name="ln1781">  return buf;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">/// Convert string, replacing key codes with printables</a>
<a name="ln1785">///</a>
<a name="ln1786">/// @param[in]  str  String to convert.</a>
<a name="ln1787">/// @param[out]  buf  Buffer to save results to.</a>
<a name="ln1788">/// @param[in]  len  Buffer length.</a>
<a name="ln1789">void str2specialbuf(const char *sp, char *buf, size_t len)</a>
<a name="ln1790">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1791">{</a>
<a name="ln1792">  while (*sp) {</a>
<a name="ln1793">    const char *s = str2special(&amp;sp, false, false);</a>
<a name="ln1794">    const size_t s_len = strlen(s);</a>
<a name="ln1795">    if (len &lt;= s_len) {</a>
<a name="ln1796">      break;</a>
<a name="ln1797">    }</a>
<a name="ln1798">    memcpy(buf, s, s_len);</a>
<a name="ln1799">    buf += s_len;</a>
<a name="ln1800">    len -= s_len;</a>
<a name="ln1801">  }</a>
<a name="ln1802">  *buf = NUL;</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">/// print line for :print or :list command</a>
<a name="ln1806">void msg_prt_line(const char *s, int list)</a>
<a name="ln1807">{</a>
<a name="ln1808">  int c;</a>
<a name="ln1809">  int col = 0;</a>
<a name="ln1810">  int n_extra = 0;</a>
<a name="ln1811">  int c_extra = 0;</a>
<a name="ln1812">  int c_final = 0;</a>
<a name="ln1813">  const char *p_extra = NULL;  // init to make SASC shut up</a>
<a name="ln1814">  int n;</a>
<a name="ln1815">  int attr = 0;</a>
<a name="ln1816">  const char *lead = NULL;</a>
<a name="ln1817">  bool in_multispace = false;</a>
<a name="ln1818">  int multispace_pos = 0;</a>
<a name="ln1819">  const char *trail = NULL;</a>
<a name="ln1820">  int l;</a>
<a name="ln1821"> </a>
<a name="ln1822">  if (curwin-&gt;w_p_list) {</a>
<a name="ln1823">    list = true;</a>
<a name="ln1824">  }</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (list) {</a>
<a name="ln1827">    // find start of trailing whitespace</a>
<a name="ln1828">    if (curwin-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1829">      trail = s + strlen(s);</a>
<a name="ln1830">      while (trail &gt; s &amp;&amp; ascii_iswhite(trail[-1])) {</a>
<a name="ln1831">        trail--;</a>
<a name="ln1832">      }</a>
<a name="ln1833">    }</a>
<a name="ln1834">    // find end of leading whitespace</a>
<a name="ln1835">    if (curwin-&gt;w_p_lcs_chars.lead || curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1836">      lead = s;</a>
<a name="ln1837">      while (ascii_iswhite(lead[0])) {</a>
<a name="ln1838">        lead++;</a>
<a name="ln1839">      }</a>
<a name="ln1840">      // in a line full of spaces all of them are treated as trailing</a>
<a name="ln1841">      if (*lead == NUL) {</a>
<a name="ln1842">        lead = NULL;</a>
<a name="ln1843">      }</a>
<a name="ln1844">    }</a>
<a name="ln1845">  }</a>
<a name="ln1846"> </a>
<a name="ln1847">  // output a space for an empty line, otherwise the line will be overwritten</a>
<a name="ln1848">  if (*s == NUL &amp;&amp; !(list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL)) {</a>
<a name="ln1849">    msg_putchar(' ');</a>
<a name="ln1850">  }</a>
<a name="ln1851"> </a>
<a name="ln1852">  while (!got_int) {</a>
<a name="ln1853">    if (n_extra &gt; 0) {</a>
<a name="ln1854">      n_extra--;</a>
<a name="ln1855">      if (n_extra == 0 &amp;&amp; c_final) {</a>
<a name="ln1856">        c = c_final;</a>
<a name="ln1857">      } else if (c_extra) {</a>
<a name="ln1858">        c = c_extra;</a>
<a name="ln1859">      } else {</a>
<a name="ln1860">        assert(p_extra != NULL);</a>
<a name="ln1861">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1862">      }</a>
<a name="ln1863">    } else if ((l = utfc_ptr2len(s)) &gt; 1) {</a>
<a name="ln1864">      col += utf_ptr2cells(s);</a>
<a name="ln1865">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln1866">      if (l &gt;= MB_MAXBYTES) {</a>
<a name="ln1867">        xstrlcpy(buf, &quot;?&quot;, sizeof(buf));</a>
<a name="ln1868">      } else if (curwin-&gt;w_p_lcs_chars.nbsp != NUL &amp;&amp; list</a>
<a name="ln1869">                 &amp;&amp; (utf_ptr2char(s) == 160</a>
<a name="ln1870">                     || utf_ptr2char(s) == 0x202f)) {</a>
<a name="ln1871">        int len = utf_char2bytes(curwin-&gt;w_p_lcs_chars.nbsp, buf);</a>
<a name="ln1872">        buf[len] = NUL;</a>
<a name="ln1873">      } else {</a>
<a name="ln1874">        memmove(buf, s, (size_t)l);</a>
<a name="ln1875">        buf[l] = NUL;</a>
<a name="ln1876">      }</a>
<a name="ln1877">      msg_puts(buf);</a>
<a name="ln1878">      s += l;</a>
<a name="ln1879">      continue;</a>
<a name="ln1880">    } else {</a>
<a name="ln1881">      attr = 0;</a>
<a name="ln1882">      c = (uint8_t)(*s++);</a>
<a name="ln1883">      if (list) {</a>
<a name="ln1884">        in_multispace = c == ' ' &amp;&amp; (*s == ' '</a>
<a name="ln1885">                                     || (col &gt; 0 &amp;&amp; s[-2] == ' '));</a>
<a name="ln1886">        if (!in_multispace) {</a>
<a name="ln1887">          multispace_pos = 0;</a>
<a name="ln1888">        }</a>
<a name="ln1889">      }</a>
<a name="ln1890">      if (c == TAB &amp;&amp; (!list || curwin-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1891">        // tab amount depends on current column</a>
<a name="ln1892">        n_extra = tabstop_padding(col,</a>
<a name="ln1893">                                  curbuf-&gt;b_p_ts,</a>
<a name="ln1894">                                  curbuf-&gt;b_p_vts_array) - 1;</a>
<a name="ln1895">        if (!list) {</a>
<a name="ln1896">          c = ' ';</a>
<a name="ln1897">          c_extra = ' ';</a>
<a name="ln1898">          c_final = NUL;</a>
<a name="ln1899">        } else {</a>
<a name="ln1900">          c = (n_extra == 0 &amp;&amp; curwin-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln1901">              ? curwin-&gt;w_p_lcs_chars.tab3</a>
<a name="ln1902">              : curwin-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1903">          c_extra = curwin-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1904">          c_final = curwin-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1905">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1906">        }</a>
<a name="ln1907">      } else if (c == 160 &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp != NUL) {</a>
<a name="ln1908">        c = curwin-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1909">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1910">      } else if (c == NUL &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL) {</a>
<a name="ln1911">        p_extra = &quot;&quot;;</a>
<a name="ln1912">        c_extra = NUL;</a>
<a name="ln1913">        c_final = NUL;</a>
<a name="ln1914">        n_extra = 1;</a>
<a name="ln1915">        c = curwin-&gt;w_p_lcs_chars.eol;</a>
<a name="ln1916">        attr = HL_ATTR(HLF_AT);</a>
<a name="ln1917">        s--;</a>
<a name="ln1918">      } else if (c != NUL &amp;&amp; (n = byte2cells(c)) &gt; 1) {</a>
<a name="ln1919">        n_extra = n - 1;</a>
<a name="ln1920">        p_extra = transchar_byte_buf(NULL, c);</a>
<a name="ln1921">        c_extra = NUL;</a>
<a name="ln1922">        c_final = NUL;</a>
<a name="ln1923">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1924">        // Use special coloring to be able to distinguish &lt;hex&gt; from</a>
<a name="ln1925">        // the same in plain text.</a>
<a name="ln1926">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1927">      } else if (c == ' ') {</a>
<a name="ln1928">        if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; in_multispace</a>
<a name="ln1929">            &amp;&amp; curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1930">          c = curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos++];</a>
<a name="ln1931">          if (curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos] == NUL) {</a>
<a name="ln1932">            multispace_pos = 0;</a>
<a name="ln1933">          }</a>
<a name="ln1934">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1935">        } else if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; curwin-&gt;w_p_lcs_chars.lead != NUL) {</a>
<a name="ln1936">          c = curwin-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1937">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1938">        } else if (trail != NULL &amp;&amp; s &gt; trail) {</a>
<a name="ln1939">          c = curwin-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1940">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1941">        } else if (in_multispace</a>
<a name="ln1942">                   &amp;&amp; curwin-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1943">          c = curwin-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1944">          if (curwin-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1945">            multispace_pos = 0;</a>
<a name="ln1946">          }</a>
<a name="ln1947">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1948">        } else if (list &amp;&amp; curwin-&gt;w_p_lcs_chars.space != NUL) {</a>
<a name="ln1949">          c = curwin-&gt;w_p_lcs_chars.space;</a>
<a name="ln1950">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1951">        }</a>
<a name="ln1952">      }</a>
<a name="ln1953">    }</a>
<a name="ln1954"> </a>
<a name="ln1955">    if (c == NUL) {</a>
<a name="ln1956">      break;</a>
<a name="ln1957">    }</a>
<a name="ln1958"> </a>
<a name="ln1959">    msg_putchar_attr(c, attr);</a>
<a name="ln1960">    col++;</a>
<a name="ln1961">  }</a>
<a name="ln1962">  msg_clr_eos();</a>
<a name="ln1963">}</a>
<a name="ln1964"> </a>
<a name="ln1965">/// Use grid_puts() to output one multi-byte character.</a>
<a name="ln1966">///</a>
<a name="ln1967">/// @return  the pointer &quot;s&quot; advanced to the next character.</a>
<a name="ln1968">static const char *screen_puts_mbyte(const char *s, int l, int attr)</a>
<a name="ln1969">{</a>
<a name="ln1970">  int cw;</a>
<a name="ln1971">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln1972"> </a>
<a name="ln1973">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln1974">  cw = utf_ptr2cells(s);</a>
<a name="ln1975">  if (cw &gt; 1</a>
<a name="ln1976">      &amp;&amp; (cmdmsg_rl ? msg_col &lt;= 1 : msg_col == Columns - 1)) {</a>
<a name="ln1977">    // Doesn't fit, print a highlighted '&gt;' to fill it up.</a>
<a name="ln1978">    msg_screen_putchar('&gt;', HL_ATTR(HLF_AT));</a>
<a name="ln1979">    return s;</a>
<a name="ln1980">  }</a>
<a name="ln1981"> </a>
<a name="ln1982">  grid_puts(&amp;msg_grid_adj, s, l, msg_row, msg_col, attr);</a>
<a name="ln1983">  if (cmdmsg_rl) {</a>
<a name="ln1984">    msg_col -= cw;</a>
<a name="ln1985">    if (msg_col == 0) {</a>
<a name="ln1986">      msg_col = Columns;</a>
<a name="ln1987">      msg_row++;</a>
<a name="ln1988">    }</a>
<a name="ln1989">  } else {</a>
<a name="ln1990">    msg_col += cw;</a>
<a name="ln1991">    if (msg_col &gt;= Columns) {</a>
<a name="ln1992">      msg_col = 0;</a>
<a name="ln1993">      msg_row++;</a>
<a name="ln1994">    }</a>
<a name="ln1995">  }</a>
<a name="ln1996">  return s + l;</a>
<a name="ln1997">}</a>
<a name="ln1998"> </a>
<a name="ln1999">/// Output a string to the screen at position msg_row, msg_col.</a>
<a name="ln2000">/// Update msg_row and msg_col for the next message.</a>
<a name="ln2001">void msg_puts(const char *s)</a>
<a name="ln2002">{</a>
<a name="ln2003">  msg_puts_attr(s, 0);</a>
<a name="ln2004">}</a>
<a name="ln2005"> </a>
<a name="ln2006">void msg_puts_title(const char *s)</a>
<a name="ln2007">{</a>
<a name="ln2008">  msg_puts_attr(s, HL_ATTR(HLF_T));</a>
<a name="ln2009">}</a>
<a name="ln2010"> </a>
<a name="ln2011">/// Show a message in such a way that it always fits in the line.  Cut out a</a>
<a name="ln2012">/// part in the middle and replace it with &quot;...&quot; when necessary.</a>
<a name="ln2013">/// Does not handle multi-byte characters!</a>
<a name="ln2014">void msg_outtrans_long(const char *longstr, int attr)</a>
<a name="ln2015">{</a>
<a name="ln2016">  int len = (int)strlen(longstr);</a>
<a name="ln2017">  int slen = len;</a>
<a name="ln2018">  int room = Columns - msg_col;</a>
<a name="ln2019">  if (len &gt; room &amp;&amp; room &gt;= 20) {</a>
<a name="ln2020">    slen = (room - 3) / 2;</a>
<a name="ln2021">    msg_outtrans_len(longstr, slen, attr);</a>
<a name="ln2022">    msg_puts_attr(&quot;...&quot;, HL_ATTR(HLF_8));</a>
<a name="ln2023">  }</a>
<a name="ln2024">  msg_outtrans_len(longstr + len - slen, slen, attr);</a>
<a name="ln2025">}</a>
<a name="ln2026"> </a>
<a name="ln2027">/// Basic function for writing a message with highlight attributes.</a>
<a name="ln2028">void msg_puts_attr(const char *const s, const int attr)</a>
<a name="ln2029">{</a>
<a name="ln2030">  msg_puts_len(s, -1, attr);</a>
<a name="ln2031">}</a>
<a name="ln2032"> </a>
<a name="ln2033">/// Write a message with highlight attributes</a>
<a name="ln2034">///</a>
<a name="ln2035">/// @param[in]  str  NUL-terminated message string.</a>
<a name="ln2036">/// @param[in]  len  Length of the string or -1.</a>
<a name="ln2037">/// @param[in]  attr  Highlight attribute.</a>
<a name="ln2038">void msg_puts_len(const char *const str, const ptrdiff_t len, int attr)</a>
<a name="ln2039">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2040">{</a>
<a name="ln2041">  assert(len &lt; 0 || memchr(str, 0, (size_t)len) == NULL);</a>
<a name="ln2042">  // If redirection is on, also write to the redirection file.</a>
<a name="ln2043">  redir_write(str, len);</a>
<a name="ln2044"> </a>
<a name="ln2045">  // Don't print anything when using &quot;:silent cmd&quot;.</a>
<a name="ln2046">  if (msg_silent != 0) {</a>
<a name="ln2047">    return;</a>
<a name="ln2048">  }</a>
<a name="ln2049"> </a>
<a name="ln2050">  // if MSG_HIST flag set, add message to history</a>
<a name="ln2051">  if (attr &amp; MSG_HIST) {</a>
<a name="ln2052">    add_msg_hist(str, (int)len, attr, false);</a>
<a name="ln2053">    attr &amp;= ~MSG_HIST;</a>
<a name="ln2054">  }</a>
<a name="ln2055"> </a>
<a name="ln2056">  // When writing something to the screen after it has scrolled, requires a</a>
<a name="ln2057">  // wait-return prompt later.  Needed when scrolling, resetting</a>
<a name="ln2058">  // need_wait_return after some prompt, and then outputting something</a>
<a name="ln2059">  // without scrolling</a>
<a name="ln2060">  // Not needed when only using CR to move the cursor.</a>
<a name="ln2061">  bool overflow = false;</a>
<a name="ln2062">  if (ui_has(kUIMessages)) {</a>
<a name="ln2063">    int count = msg_ext_visible + (msg_ext_overwrite ? 0 : 1);</a>
<a name="ln2064">    // TODO(bfredl): possible extension point, let external UI control this</a>
<a name="ln2065">    if (count &gt; 1) {</a>
<a name="ln2066">      overflow = true;</a>
<a name="ln2067">    }</a>
<a name="ln2068">  } else {</a>
<a name="ln2069">    overflow = msg_scrolled &gt; (p_ch == 0 ? 1 : 0);</a>
<a name="ln2070">  }</a>
<a name="ln2071"> </a>
<a name="ln2072">  if (overflow &amp;&amp; !msg_scrolled_ign &amp;&amp; strcmp(str, &quot;\r&quot;) != 0) {</a>
<a name="ln2073">    need_wait_return = true;</a>
<a name="ln2074">  }</a>
<a name="ln2075">  msg_didany = true;  // remember that something was outputted</a>
<a name="ln2076"> </a>
<a name="ln2077">  // If there is no valid screen, use fprintf so we can see error messages.</a>
<a name="ln2078">  // If termcap is not active, we may be writing in an alternate console</a>
<a name="ln2079">  // window, cursor positioning may not work correctly (window size may be</a>
<a name="ln2080">  // different, e.g. for Win32 console) or we just don't know where the</a>
<a name="ln2081">  // cursor is.</a>
<a name="ln2082">  if (msg_use_printf()) {</a>
<a name="ln2083">    int saved_msg_col = msg_col;</a>
<a name="ln2084">    msg_puts_printf(str, len);</a>
<a name="ln2085">    if (headless_mode) {</a>
<a name="ln2086">      msg_col = saved_msg_col;</a>
<a name="ln2087">    }</a>
<a name="ln2088">  }</a>
<a name="ln2089">  if (!msg_use_printf() || (headless_mode &amp;&amp; default_grid.chars)) {</a>
<a name="ln2090">    msg_puts_display(str, (int)len, attr, false);</a>
<a name="ln2091">  }</a>
<a name="ln2092"> </a>
<a name="ln2093">  need_fileinfo = false;</a>
<a name="ln2094">}</a>
<a name="ln2095"> </a>
<a name="ln2096">/// Print a formatted message</a>
<a name="ln2097">///</a>
<a name="ln2098">/// Message printed is limited by #IOSIZE. Must not be used from inside</a>
<a name="ln2099">/// msg_puts_attr().</a>
<a name="ln2100">///</a>
<a name="ln2101">/// @param[in]  attr  Highlight attributes.</a>
<a name="ln2102">/// @param[in]  fmt  Format string.</a>
<a name="ln2103">void msg_printf_attr(const int attr, const char *const fmt, ...)</a>
<a name="ln2104">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2105">{</a>
<a name="ln2106">  static char msgbuf[IOSIZE];</a>
<a name="ln2107"> </a>
<a name="ln2108">  va_list ap;</a>
<a name="ln2109">  va_start(ap, fmt);</a>
<a name="ln2110">  const size_t len = (size_t)vim_vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);</a>
<a name="ln2111">  va_end(ap);</a>
<a name="ln2112"> </a>
<a name="ln2113">  msg_scroll = true;</a>
<a name="ln2114">  msg_puts_len(msgbuf, (ptrdiff_t)len, attr);</a>
<a name="ln2115">}</a>
<a name="ln2116"> </a>
<a name="ln2117">static void msg_ext_emit_chunk(void)</a>
<a name="ln2118">{</a>
<a name="ln2119">  // Color was changed or a message flushed, end current chunk.</a>
<a name="ln2120">  if (msg_ext_last_attr == -1) {</a>
<a name="ln2121">    return;  // no chunk</a>
<a name="ln2122">  }</a>
<a name="ln2123">  Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln2124">  ADD(chunk, INTEGER_OBJ(msg_ext_last_attr));</a>
<a name="ln2125">  msg_ext_last_attr = -1;</a>
<a name="ln2126">  String text = ga_take_string(&amp;msg_ext_last_chunk);</a>
<a name="ln2127">  ADD(chunk, STRING_OBJ(text));</a>
<a name="ln2128">  ADD(msg_ext_chunks, ARRAY_OBJ(chunk));</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131">/// The display part of msg_puts_len().</a>
<a name="ln2132">/// May be called recursively to display scroll-back text.</a>
<a name="ln2133">static void msg_puts_display(const char *str, int maxlen, int attr, int recurse)</a>
<a name="ln2134">{</a>
<a name="ln2135">  const char *s = str;</a>
<a name="ln2136">  const char *t_s = str;  // String from &quot;t_s&quot; to &quot;s&quot; is still todo.</a>
<a name="ln2137">  int t_col = 0;  // Screen cells todo, 0 when &quot;t_s&quot; not used.</a>
<a name="ln2138">  int l;</a>
<a name="ln2139">  int cw;</a>
<a name="ln2140">  const char *sb_str = str;</a>
<a name="ln2141">  int sb_col = msg_col;</a>
<a name="ln2142">  int wrap;</a>
<a name="ln2143">  int did_last_char;</a>
<a name="ln2144"> </a>
<a name="ln2145">  did_wait_return = false;</a>
<a name="ln2146"> </a>
<a name="ln2147">  if (ui_has(kUIMessages)) {</a>
<a name="ln2148">    if (attr != msg_ext_last_attr) {</a>
<a name="ln2149">      msg_ext_emit_chunk();</a>
<a name="ln2150">      msg_ext_last_attr = attr;</a>
<a name="ln2151">    }</a>
<a name="ln2152">    // Concat pieces with the same highlight</a>
<a name="ln2153">    size_t len = strnlen(str, (size_t)maxlen);  // -V781</a>
<a name="ln2154">    ga_concat_len(&amp;msg_ext_last_chunk, str, len);</a>
<a name="ln2155">    msg_ext_cur_len += len;</a>
<a name="ln2156">    return;</a>
<a name="ln2157">  }</a>
<a name="ln2158"> </a>
<a name="ln2159">  msg_grid_validate();</a>
<a name="ln2160"> </a>
<a name="ln2161">  cmdline_was_last_drawn = redrawing_cmdline;</a>
<a name="ln2162"> </a>
<a name="ln2163">  while ((maxlen &lt; 0 || (int)(s - str) &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2164">    // We are at the end of the screen line when:</a>
<a name="ln2165">    // - When outputting a newline.</a>
<a name="ln2166">    // - When outputting a character in the last column.</a>
<a name="ln2167">    if (!recurse &amp;&amp; msg_row &gt;= Rows - 1</a>
<a name="ln2168">        &amp;&amp; (*s == '\n' || (cmdmsg_rl</a>
<a name="ln2169">                           ? (msg_col &lt;= 1</a>
<a name="ln2170">                              || (*s == TAB &amp;&amp; msg_col &lt;= 7)</a>
<a name="ln2171">                              || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2172">                                  &amp;&amp; msg_col &lt;= 2))</a>
<a name="ln2173">                           : ((*s != '\r' &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2174">                              || (*s == TAB</a>
<a name="ln2175">                                  &amp;&amp; msg_col + t_col &gt;= ((Columns - 1) &amp; ~7))</a>
<a name="ln2176">                              || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2177">                                  &amp;&amp; msg_col + t_col &gt;= Columns - 2))))) {</a>
<a name="ln2178">      // The screen is scrolled up when at the last row (some terminals</a>
<a name="ln2179">      // scroll automatically, some don't.  To avoid problems we scroll</a>
<a name="ln2180">      // ourselves).</a>
<a name="ln2181">      if (t_col &gt; 0) {</a>
<a name="ln2182">        // output postponed text</a>
<a name="ln2183">        t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2184">      }</a>
<a name="ln2185"> </a>
<a name="ln2186">      // When no more prompt and no more room, truncate here</a>
<a name="ln2187">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2188">        break;</a>
<a name="ln2189">      }</a>
<a name="ln2190"> </a>
<a name="ln2191">      // Scroll the screen up one line.</a>
<a name="ln2192">      bool has_last_char = ((uint8_t)(*s) &gt;= ' ' &amp;&amp; !cmdmsg_rl);</a>
<a name="ln2193">      msg_scroll_up(!has_last_char, false);</a>
<a name="ln2194"> </a>
<a name="ln2195">      msg_row = Rows - 2;</a>
<a name="ln2196">      if (msg_col &gt;= Columns) {         // can happen after screen resize</a>
<a name="ln2197">        msg_col = Columns - 1;</a>
<a name="ln2198">      }</a>
<a name="ln2199"> </a>
<a name="ln2200">      // Display char in last column before showing more-prompt.</a>
<a name="ln2201">      if (has_last_char) {</a>
<a name="ln2202">        if (maxlen &gt;= 0) {</a>
<a name="ln2203">          // Avoid including composing chars after the end.</a>
<a name="ln2204">          l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2205">        } else {</a>
<a name="ln2206">          l = utfc_ptr2len(s);</a>
<a name="ln2207">        }</a>
<a name="ln2208">        s = screen_puts_mbyte(s, l, attr);</a>
<a name="ln2209">        did_last_char = true;</a>
<a name="ln2210">      } else {</a>
<a name="ln2211">        did_last_char = false;</a>
<a name="ln2212">      }</a>
<a name="ln2213"> </a>
<a name="ln2214">      // Tricky: if last cell will be written, delay the throttle until</a>
<a name="ln2215">      // after the first scroll. Otherwise we would need to keep track of it.</a>
<a name="ln2216">      if (has_last_char &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2217">        if (!msg_grid.throttled) {</a>
<a name="ln2218">          msg_grid_scroll_discount++;</a>
<a name="ln2219">        }</a>
<a name="ln2220">        msg_grid.throttled = true;</a>
<a name="ln2221">      }</a>
<a name="ln2222"> </a>
<a name="ln2223">      if (p_more) {</a>
<a name="ln2224">        // Store text for scrolling back.</a>
<a name="ln2225">        store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2226">      }</a>
<a name="ln2227"> </a>
<a name="ln2228">      inc_msg_scrolled();</a>
<a name="ln2229">      need_wait_return = true;       // may need wait_return() in main()</a>
<a name="ln2230">      redraw_cmdline = true;</a>
<a name="ln2231">      if (cmdline_row &gt; 0 &amp;&amp; !exmode_active) {</a>
<a name="ln2232">        cmdline_row--;</a>
<a name="ln2233">      }</a>
<a name="ln2234"> </a>
<a name="ln2235">      // If screen is completely filled and 'more' is set then wait</a>
<a name="ln2236">      // for a character.</a>
<a name="ln2237">      if (lines_left &gt; 0) {</a>
<a name="ln2238">        lines_left--;</a>
<a name="ln2239">      }</a>
<a name="ln2240">      if (p_more &amp;&amp; lines_left == 0 &amp;&amp; State != MODE_HITRETURN</a>
<a name="ln2241">          &amp;&amp; !msg_no_more &amp;&amp; !exmode_active) {</a>
<a name="ln2242">        if (do_more_prompt(NUL)) {</a>
<a name="ln2243">          s = confirm_msg_tail;</a>
<a name="ln2244">        }</a>
<a name="ln2245">        if (quit_more) {</a>
<a name="ln2246">          return;</a>
<a name="ln2247">        }</a>
<a name="ln2248">      }</a>
<a name="ln2249"> </a>
<a name="ln2250">      // When we displayed a char in last column need to check if there</a>
<a name="ln2251">      // is still more.</a>
<a name="ln2252">      if (did_last_char) {</a>
<a name="ln2253">        continue;</a>
<a name="ln2254">      }</a>
<a name="ln2255">    }</a>
<a name="ln2256"> </a>
<a name="ln2257">    wrap = *s == '\n'</a>
<a name="ln2258">           || msg_col + t_col &gt;= Columns</a>
<a name="ln2259">           || (utf_ptr2cells(s) &gt; 1</a>
<a name="ln2260">               &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2261">    ;</a>
<a name="ln2262">    if (t_col &gt; 0 &amp;&amp; (wrap || *s == '\r' || *s == '\b'</a>
<a name="ln2263">                      || *s == '\t' || *s == BELL)) {</a>
<a name="ln2264">      // Output any postponed text.</a>
<a name="ln2265">      t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2266">    }</a>
<a name="ln2267"> </a>
<a name="ln2268">    if (wrap &amp;&amp; p_more &amp;&amp; !recurse) {</a>
<a name="ln2269">      // Store text for scrolling back.</a>
<a name="ln2270">      store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2271">    }</a>
<a name="ln2272"> </a>
<a name="ln2273">    if (*s == '\n') {               // go to next line</a>
<a name="ln2274">      msg_didout = false;           // remember that line is empty</a>
<a name="ln2275">      if (cmdmsg_rl) {</a>
<a name="ln2276">        msg_col = Columns - 1;</a>
<a name="ln2277">      } else {</a>
<a name="ln2278">        msg_col = 0;</a>
<a name="ln2279">      }</a>
<a name="ln2280">      if (++msg_row &gt;= Rows) {        // safety check</a>
<a name="ln2281">        msg_row = Rows - 1;</a>
<a name="ln2282">      }</a>
<a name="ln2283">    } else if (*s == '\r') {      // go to column 0</a>
<a name="ln2284">      msg_col = 0;</a>
<a name="ln2285">    } else if (*s == '\b') {      // go to previous char</a>
<a name="ln2286">      if (msg_col) {</a>
<a name="ln2287">        msg_col--;</a>
<a name="ln2288">      }</a>
<a name="ln2289">    } else if (*s == TAB) {       // translate Tab into spaces</a>
<a name="ln2290">      do {</a>
<a name="ln2291">        msg_screen_putchar(' ', attr);</a>
<a name="ln2292">      } while (msg_col &amp; 7);</a>
<a name="ln2293">    } else if (*s == BELL) {  // beep (from &quot;:sh&quot;)</a>
<a name="ln2294">      vim_beep(BO_SH);</a>
<a name="ln2295">    } else if ((uint8_t)(*s) &gt;= 0x20) {  // printable char</a>
<a name="ln2296">      cw = utf_ptr2cells(s);</a>
<a name="ln2297">      if (maxlen &gt;= 0) {</a>
<a name="ln2298">        // avoid including composing chars after the end</a>
<a name="ln2299">        l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2300">      } else {</a>
<a name="ln2301">        l = utfc_ptr2len(s);</a>
<a name="ln2302">      }</a>
<a name="ln2303">      // When drawing from right to left or when a double-wide character</a>
<a name="ln2304">      // doesn't fit, draw a single character here.  Otherwise collect</a>
<a name="ln2305">      // characters and draw them all at once later.</a>
<a name="ln2306">      if (cmdmsg_rl || (cw &gt; 1 &amp;&amp; msg_col + t_col &gt;= Columns - 1)) {</a>
<a name="ln2307">        if (l &gt; 1) {</a>
<a name="ln2308">          s = screen_puts_mbyte(s, l, attr) - 1;</a>
<a name="ln2309">        } else {</a>
<a name="ln2310">          msg_screen_putchar(*s, attr);</a>
<a name="ln2311">        }</a>
<a name="ln2312">      } else {</a>
<a name="ln2313">        // postpone this character until later</a>
<a name="ln2314">        if (t_col == 0) {</a>
<a name="ln2315">          t_s = s;</a>
<a name="ln2316">        }</a>
<a name="ln2317">        t_col += cw;</a>
<a name="ln2318">        s += l - 1;</a>
<a name="ln2319">      }</a>
<a name="ln2320">    }</a>
<a name="ln2321">    s++;</a>
<a name="ln2322">  }</a>
<a name="ln2323"> </a>
<a name="ln2324">  // Output any postponed text.</a>
<a name="ln2325">  if (t_col &gt; 0) {</a>
<a name="ln2326">    t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2327">  }</a>
<a name="ln2328">  if (p_more &amp;&amp; !recurse &amp;&amp; !(s == sb_str + 1 &amp;&amp; *sb_str == '\n')) {</a>
<a name="ln2329">    store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, false);</a>
<a name="ln2330">  }</a>
<a name="ln2331"> </a>
<a name="ln2332">  msg_check();</a>
<a name="ln2333">}</a>
<a name="ln2334"> </a>
<a name="ln2335">/// @return  true when &quot;:filter pattern&quot; was used and &quot;msg&quot; does not match</a>
<a name="ln2336">///          &quot;pattern&quot;.</a>
<a name="ln2337">bool message_filtered(const char *msg)</a>
<a name="ln2338">{</a>
<a name="ln2339">  if (cmdmod.cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2340">    return false;</a>
<a name="ln2341">  }</a>
<a name="ln2342"> </a>
<a name="ln2343">  bool match = vim_regexec(&amp;cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);</a>
<a name="ln2344">  return cmdmod.cmod_filter_force ? match : !match;</a>
<a name="ln2345">}</a>
<a name="ln2346"> </a>
<a name="ln2347">/// including horizontal separator</a>
<a name="ln2348">int msg_scrollsize(void)</a>
<a name="ln2349">{</a>
<a name="ln2350">  return msg_scrolled + (int)p_ch + ((p_ch &gt; 0 || msg_scrolled &gt; 1) ? 1 : 0);</a>
<a name="ln2351">}</a>
<a name="ln2352"> </a>
<a name="ln2353">bool msg_do_throttle(void)</a>
<a name="ln2354">{</a>
<a name="ln2355">  return msg_use_grid() &amp;&amp; !(rdb_flags &amp; RDB_NOTHROTTLE);</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358">/// Scroll the screen up one line for displaying the next message line.</a>
<a name="ln2359">void msg_scroll_up(bool may_throttle, bool zerocmd)</a>
<a name="ln2360">{</a>
<a name="ln2361">  if (may_throttle &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2362">    msg_grid.throttled = true;</a>
<a name="ln2363">  }</a>
<a name="ln2364">  msg_did_scroll = true;</a>
<a name="ln2365">  if (msg_grid_pos &gt; 0) {</a>
<a name="ln2366">    msg_grid_set_pos(msg_grid_pos - 1, !zerocmd);</a>
<a name="ln2367"> </a>
<a name="ln2368">    // When displaying the first line with cmdheight=0, we need to draw over</a>
<a name="ln2369">    // the existing last line of the screen.</a>
<a name="ln2370">    if (zerocmd &amp;&amp; msg_grid.chars) {</a>
<a name="ln2371">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[0], msg_grid.cols, false);</a>
<a name="ln2372">    }</a>
<a name="ln2373">  } else {</a>
<a name="ln2374">    grid_del_lines(&amp;msg_grid, 0, 1, msg_grid.rows, 0, msg_grid.cols);</a>
<a name="ln2375">    memmove(msg_grid.dirty_col, msg_grid.dirty_col + 1,</a>
<a name="ln2376">            (size_t)(msg_grid.rows - 1) * sizeof(*msg_grid.dirty_col));</a>
<a name="ln2377">    msg_grid.dirty_col[msg_grid.rows - 1] = 0;</a>
<a name="ln2378">  }</a>
<a name="ln2379"> </a>
<a name="ln2380">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln2381">}</a>
<a name="ln2382"> </a>
<a name="ln2383">/// Send throttled message output to UI clients</a>
<a name="ln2384">///</a>
<a name="ln2385">/// The way message.c uses the grid_xx family of functions is quite inefficient</a>
<a name="ln2386">/// relative to the &quot;gridline&quot; UI protocol used by TUI and modern clients.</a>
<a name="ln2387">/// For instance scrolling is done one line at a time. By throttling drawing</a>
<a name="ln2388">/// on the message grid, we can coalesce scrolling to a single grid_scroll</a>
<a name="ln2389">/// per screen update.</a>
<a name="ln2390">///</a>
<a name="ln2391">/// NB: The bookkeeping is quite messy, and rests on a bunch of poorly</a>
<a name="ln2392">/// documented assumptions. For instance that the message area always grows</a>
<a name="ln2393">/// while being throttled, messages are only being output on the last line</a>
<a name="ln2394">/// etc.</a>
<a name="ln2395">///</a>
<a name="ln2396">/// Probably message scrollback storage should be reimplemented as a</a>
<a name="ln2397">/// file_buffer, and message scrolling in TUI be reimplemented as a modal</a>
<a name="ln2398">/// floating window. Then we get throttling &quot;for free&quot; using standard</a>
<a name="ln2399">/// redraw_later code paths.</a>
<a name="ln2400">void msg_scroll_flush(void)</a>
<a name="ln2401">{</a>
<a name="ln2402">  if (msg_grid.throttled) {</a>
<a name="ln2403">    msg_grid.throttled = false;</a>
<a name="ln2404">    int pos_delta = msg_grid_pos_at_flush - msg_grid_pos;</a>
<a name="ln2405">    assert(pos_delta &gt;= 0);</a>
<a name="ln2406">    int delta = MIN(msg_scrolled - msg_scrolled_at_flush, msg_grid.rows);</a>
<a name="ln2407"> </a>
<a name="ln2408">    if (pos_delta &gt; 0) {</a>
<a name="ln2409">      ui_ext_msg_set_pos(msg_grid_pos, true);</a>
<a name="ln2410">    }</a>
<a name="ln2411"> </a>
<a name="ln2412">    int to_scroll = delta - pos_delta - msg_grid_scroll_discount;</a>
<a name="ln2413">    assert(to_scroll &gt;= 0);</a>
<a name="ln2414"> </a>
<a name="ln2415">    // TODO(bfredl): msg_grid_pos should be 0 already when starting scrolling</a>
<a name="ln2416">    // but this sometimes fails in &quot;headless&quot; message printing.</a>
<a name="ln2417">    if (to_scroll &gt; 0 &amp;&amp; msg_grid_pos == 0) {</a>
<a name="ln2418">      ui_call_grid_scroll(msg_grid.handle, 0, Rows, 0, Columns, to_scroll, 0);</a>
<a name="ln2419">    }</a>
<a name="ln2420"> </a>
<a name="ln2421">    for (int i = MAX(Rows - MAX(delta, 1), 0); i &lt; Rows; i++) {</a>
<a name="ln2422">      int row = i - msg_grid_pos;</a>
<a name="ln2423">      assert(row &gt;= 0);</a>
<a name="ln2424">      ui_line(&amp;msg_grid, row, 0, msg_grid.dirty_col[row], msg_grid.cols,</a>
<a name="ln2425">              HL_ATTR(HLF_MSG), false);</a>
<a name="ln2426">      msg_grid.dirty_col[row] = 0;</a>
<a name="ln2427">    }</a>
<a name="ln2428">  }</a>
<a name="ln2429">  msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln2430">  msg_grid_scroll_discount = 0;</a>
<a name="ln2431">  msg_grid_pos_at_flush = msg_grid_pos;</a>
<a name="ln2432">}</a>
<a name="ln2433"> </a>
<a name="ln2434">void msg_reset_scroll(void)</a>
<a name="ln2435">{</a>
<a name="ln2436">  if (ui_has(kUIMessages)) {</a>
<a name="ln2437">    msg_ext_clear(true);</a>
<a name="ln2438">    return;</a>
<a name="ln2439">  }</a>
<a name="ln2440">  // TODO(bfredl): some duplicate logic with update_screen(). Later on</a>
<a name="ln2441">  // we should properly disentangle message clear with full screen redraw.</a>
<a name="ln2442">  msg_grid.throttled = false;</a>
<a name="ln2443">  // TODO(bfredl): risk for extra flicker i e with</a>
<a name="ln2444">  // &quot;nvim -o has_swap also_has_swap&quot;</a>
<a name="ln2445">  msg_grid_set_pos(Rows - (int)p_ch, false);</a>
<a name="ln2446">  clear_cmdline = true;</a>
<a name="ln2447">  if (msg_grid.chars) {</a>
<a name="ln2448">    // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln2449">    for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.rows); i++) {</a>
<a name="ln2450">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln2451">                      msg_grid.cols, false);</a>
<a name="ln2452">    }</a>
<a name="ln2453">  }</a>
<a name="ln2454">  msg_scrolled = 0;</a>
<a name="ln2455">  msg_scrolled_at_flush = 0;</a>
<a name="ln2456">  msg_grid_scroll_discount = 0;</a>
<a name="ln2457">}</a>
<a name="ln2458"> </a>
<a name="ln2459">/// Increment &quot;msg_scrolled&quot;.</a>
<a name="ln2460">static void inc_msg_scrolled(void)</a>
<a name="ln2461">{</a>
<a name="ln2462">  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {</a>
<a name="ln2463">    char *p = SOURCING_NAME;</a>
<a name="ln2464">    char *tofree = NULL;</a>
<a name="ln2465"> </a>
<a name="ln2466">    // v:scrollstart is empty, set it to the script/function name and line</a>
<a name="ln2467">    // number</a>
<a name="ln2468">    if (p == NULL) {</a>
<a name="ln2469">      p = _(&quot;Unknown&quot;);</a>
<a name="ln2470">    } else {</a>
<a name="ln2471">      size_t len = strlen(p) + 40;</a>
<a name="ln2472">      tofree = xmalloc(len);</a>
<a name="ln2473">      vim_snprintf(tofree, len, _(&quot;%s line %&quot; PRId64),</a>
<a name="ln2474">                   p, (int64_t)SOURCING_LNUM);</a>
<a name="ln2475">      p = tofree;</a>
<a name="ln2476">    }</a>
<a name="ln2477">    set_vim_var_string(VV_SCROLLSTART, p, -1);</a>
<a name="ln2478">    xfree(tofree);</a>
<a name="ln2479">  }</a>
<a name="ln2480">  msg_scrolled++;</a>
<a name="ln2481">  if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln2482">    must_redraw = UPD_VALID;</a>
<a name="ln2483">  }</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">static msgchunk_T *last_msgchunk = NULL;  // last displayed text</a>
<a name="ln2487"> </a>
<a name="ln2488">typedef enum {</a>
<a name="ln2489">  SB_CLEAR_NONE = 0,</a>
<a name="ln2490">  SB_CLEAR_ALL,</a>
<a name="ln2491">  SB_CLEAR_CMDLINE_BUSY,</a>
<a name="ln2492">  SB_CLEAR_CMDLINE_DONE,</a>
<a name="ln2493">} sb_clear_T;</a>
<a name="ln2494"> </a>
<a name="ln2495">// When to clear text on next msg.</a>
<a name="ln2496">static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2497"> </a>
<a name="ln2498">/// Store part of a printed message for displaying when scrolling back.</a>
<a name="ln2499">///</a>
<a name="ln2500">/// @param sb_str  start of string</a>
<a name="ln2501">/// @param s  just after string</a>
<a name="ln2502">/// @param finish  line ends</a>
<a name="ln2503">static void store_sb_text(const char **sb_str, const char *s, int attr, int *sb_col, int finish)</a>
<a name="ln2504">{</a>
<a name="ln2505">  msgchunk_T *mp;</a>
<a name="ln2506"> </a>
<a name="ln2507">  if (do_clear_sb_text == SB_CLEAR_ALL</a>
<a name="ln2508">      || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE) {</a>
<a name="ln2509">    clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);</a>
<a name="ln2510">    msg_sb_eol();  // prevent messages from overlapping</a>
<a name="ln2511">    do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2512">  }</a>
<a name="ln2513"> </a>
<a name="ln2514">  if (s &gt; *sb_str) {</a>
<a name="ln2515">    mp = xmalloc(offsetof(msgchunk_T, sb_text) + (size_t)(s - *sb_str) + 1);</a>
<a name="ln2516">    mp-&gt;sb_eol = (char)finish;</a>
<a name="ln2517">    mp-&gt;sb_msg_col = *sb_col;</a>
<a name="ln2518">    mp-&gt;sb_attr = attr;</a>
<a name="ln2519">    memcpy(mp-&gt;sb_text, *sb_str, (size_t)(s - *sb_str));</a>
<a name="ln2520">    mp-&gt;sb_text[s - *sb_str] = NUL;</a>
<a name="ln2521"> </a>
<a name="ln2522">    if (last_msgchunk == NULL) {</a>
<a name="ln2523">      last_msgchunk = mp;</a>
<a name="ln2524">      mp-&gt;sb_prev = NULL;</a>
<a name="ln2525">    } else {</a>
<a name="ln2526">      mp-&gt;sb_prev = last_msgchunk;</a>
<a name="ln2527">      last_msgchunk-&gt;sb_next = mp;</a>
<a name="ln2528">      last_msgchunk = mp;</a>
<a name="ln2529">    }</a>
<a name="ln2530">    mp-&gt;sb_next = NULL;</a>
<a name="ln2531">  } else if (finish &amp;&amp; last_msgchunk != NULL) {</a>
<a name="ln2532">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2533">  }</a>
<a name="ln2534"> </a>
<a name="ln2535">  *sb_str = s;</a>
<a name="ln2536">  *sb_col = 0;</a>
<a name="ln2537">}</a>
<a name="ln2538"> </a>
<a name="ln2539">/// Finished showing messages, clear the scroll-back text on the next message.</a>
<a name="ln2540">void may_clear_sb_text(void)</a>
<a name="ln2541">{</a>
<a name="ln2542">  do_clear_sb_text = SB_CLEAR_ALL;</a>
<a name="ln2543">}</a>
<a name="ln2544"> </a>
<a name="ln2545">/// Starting to edit the command line: do not clear messages now.</a>
<a name="ln2546">void sb_text_start_cmdline(void)</a>
<a name="ln2547">{</a>
<a name="ln2548">  if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY) {</a>
<a name="ln2549">    // Invoking command line recursively: the previous-level command line</a>
<a name="ln2550">    // doesn't need to be remembered as it will be redrawn when returning</a>
<a name="ln2551">    // to that level.</a>
<a name="ln2552">    sb_text_restart_cmdline();</a>
<a name="ln2553">  } else {</a>
<a name="ln2554">    msg_sb_eol();</a>
<a name="ln2555">    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2556">  }</a>
<a name="ln2557">}</a>
<a name="ln2558"> </a>
<a name="ln2559">/// Redrawing the command line: clear the last unfinished line.</a>
<a name="ln2560">void sb_text_restart_cmdline(void)</a>
<a name="ln2561">{</a>
<a name="ln2562">  // Needed when returning from nested command line.</a>
<a name="ln2563">  do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2564"> </a>
<a name="ln2565">  if (last_msgchunk == NULL || last_msgchunk-&gt;sb_eol) {</a>
<a name="ln2566">    // No unfinished line: don't clear anything.</a>
<a name="ln2567">    return;</a>
<a name="ln2568">  }</a>
<a name="ln2569"> </a>
<a name="ln2570">  msgchunk_T *tofree = msg_sb_start(last_msgchunk);</a>
<a name="ln2571">  last_msgchunk = tofree-&gt;sb_prev;</a>
<a name="ln2572">  if (last_msgchunk != NULL) {</a>
<a name="ln2573">    last_msgchunk-&gt;sb_next = NULL;</a>
<a name="ln2574">  }</a>
<a name="ln2575">  while (tofree != NULL) {</a>
<a name="ln2576">    msgchunk_T *tofree_next = tofree-&gt;sb_next;</a>
<a name="ln2577">    xfree(tofree);</a>
<a name="ln2578">    tofree = tofree_next;</a>
<a name="ln2579">  }</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582">/// Ending to edit the command line: clear old lines but the last one later.</a>
<a name="ln2583">void sb_text_end_cmdline(void)</a>
<a name="ln2584">{</a>
<a name="ln2585">  do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;</a>
<a name="ln2586">}</a>
<a name="ln2587"> </a>
<a name="ln2588">/// Clear any text remembered for scrolling back.</a>
<a name="ln2589">/// When &quot;all&quot; is false keep the last line.</a>
<a name="ln2590">/// Called when redrawing the screen.</a>
<a name="ln2591">void clear_sb_text(int all)</a>
<a name="ln2592">{</a>
<a name="ln2593">  msgchunk_T *mp;</a>
<a name="ln2594">  msgchunk_T **lastp;</a>
<a name="ln2595"> </a>
<a name="ln2596">  if (all) {</a>
<a name="ln2597">    lastp = &amp;last_msgchunk;</a>
<a name="ln2598">  } else {</a>
<a name="ln2599">    if (last_msgchunk == NULL) {</a>
<a name="ln2600">      return;</a>
<a name="ln2601">    }</a>
<a name="ln2602">    lastp = &amp;msg_sb_start(last_msgchunk)-&gt;sb_prev;</a>
<a name="ln2603">  }</a>
<a name="ln2604"> </a>
<a name="ln2605">  while (*lastp != NULL) {</a>
<a name="ln2606">    mp = (*lastp)-&gt;sb_prev;</a>
<a name="ln2607">    xfree(*lastp);</a>
<a name="ln2608">    *lastp = mp;</a>
<a name="ln2609">  }</a>
<a name="ln2610">}</a>
<a name="ln2611"> </a>
<a name="ln2612">/// &quot;g&lt;&quot; command.</a>
<a name="ln2613">void show_sb_text(void)</a>
<a name="ln2614">{</a>
<a name="ln2615">  msgchunk_T *mp;</a>
<a name="ln2616"> </a>
<a name="ln2617">  // Only show something if there is more than one line, otherwise it looks</a>
<a name="ln2618">  // weird, typing a command without output results in one line.</a>
<a name="ln2619">  mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2620">  if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2621">    vim_beep(BO_MESS);</a>
<a name="ln2622">  } else {</a>
<a name="ln2623">    do_more_prompt('G');</a>
<a name="ln2624">    wait_return(false);</a>
<a name="ln2625">  }</a>
<a name="ln2626">}</a>
<a name="ln2627"> </a>
<a name="ln2628">/// Move to the start of screen line in already displayed text.</a>
<a name="ln2629">static msgchunk_T *msg_sb_start(msgchunk_T *mps)</a>
<a name="ln2630">{</a>
<a name="ln2631">  msgchunk_T *mp = mps;</a>
<a name="ln2632"> </a>
<a name="ln2633">  while (mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL &amp;&amp; !mp-&gt;sb_prev-&gt;sb_eol) {</a>
<a name="ln2634">    mp = mp-&gt;sb_prev;</a>
<a name="ln2635">  }</a>
<a name="ln2636">  return mp;</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639">/// Mark the last message chunk as finishing the line.</a>
<a name="ln2640">void msg_sb_eol(void)</a>
<a name="ln2641">{</a>
<a name="ln2642">  if (last_msgchunk != NULL) {</a>
<a name="ln2643">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2644">  }</a>
<a name="ln2645">}</a>
<a name="ln2646"> </a>
<a name="ln2647">/// Display a screen line from previously displayed text at row &quot;row&quot;.</a>
<a name="ln2648">///</a>
<a name="ln2649">/// @return  a pointer to the text for the next line (can be NULL).</a>
<a name="ln2650">static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp)</a>
<a name="ln2651">{</a>
<a name="ln2652">  msgchunk_T *mp = smp;</a>
<a name="ln2653"> </a>
<a name="ln2654">  while (true) {</a>
<a name="ln2655">    msg_row = row;</a>
<a name="ln2656">    msg_col = mp-&gt;sb_msg_col;</a>
<a name="ln2657">    char *p = mp-&gt;sb_text;</a>
<a name="ln2658">    if (*p == '\n') {       // don't display the line break</a>
<a name="ln2659">      p++;</a>
<a name="ln2660">    }</a>
<a name="ln2661">    msg_puts_display(p, -1, mp-&gt;sb_attr, true);</a>
<a name="ln2662">    if (mp-&gt;sb_eol || mp-&gt;sb_next == NULL) {</a>
<a name="ln2663">      break;</a>
<a name="ln2664">    }</a>
<a name="ln2665">    mp = mp-&gt;sb_next;</a>
<a name="ln2666">  }</a>
<a name="ln2667"> </a>
<a name="ln2668">  return mp-&gt;sb_next;</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">/// Output any postponed text for msg_puts_len().</a>
<a name="ln2672">static void t_puts(int *t_col, const char *t_s, const char *s, int attr)</a>
<a name="ln2673">{</a>
<a name="ln2674">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2675">  // Output postponed text.</a>
<a name="ln2676">  msg_didout = true;  // Remember that line is not empty.</a>
<a name="ln2677">  grid_puts(&amp;msg_grid_adj, t_s, (int)(s - t_s), msg_row, msg_col, attr);</a>
<a name="ln2678">  msg_col += *t_col;</a>
<a name="ln2679">  *t_col = 0;</a>
<a name="ln2680">  // If the string starts with a composing character don't increment the</a>
<a name="ln2681">  // column position for it.</a>
<a name="ln2682">  if (utf_iscomposing(utf_ptr2char(t_s))) {</a>
<a name="ln2683">    msg_col--;</a>
<a name="ln2684">  }</a>
<a name="ln2685">  if (msg_col &gt;= Columns) {</a>
<a name="ln2686">    msg_col = 0;</a>
<a name="ln2687">    msg_row++;</a>
<a name="ln2688">  }</a>
<a name="ln2689">}</a>
<a name="ln2690"> </a>
<a name="ln2691">/// @return  true when messages should be printed to stdout/stderr:</a>
<a name="ln2692">///          - &quot;batch mode&quot; (&quot;silent mode&quot;, -es/-Es)</a>
<a name="ln2693">///          - no UI and not embedded</a>
<a name="ln2694">int msg_use_printf(void)</a>
<a name="ln2695">{</a>
<a name="ln2696">  return !embedded_mode &amp;&amp; !ui_active();</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699">/// Print a message when there is no valid screen.</a>
<a name="ln2700">static void msg_puts_printf(const char *str, const ptrdiff_t maxlen)</a>
<a name="ln2701">{</a>
<a name="ln2702">  const char *s = str;</a>
<a name="ln2703">  char buf[7];</a>
<a name="ln2704">  char *p;</a>
<a name="ln2705"> </a>
<a name="ln2706">  if (on_print.type != kCallbackNone) {</a>
<a name="ln2707">    typval_T argv[1];</a>
<a name="ln2708">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2709">    argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln2710">    argv[0].vval.v_string = (char *)str;</a>
<a name="ln2711">    typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln2712">    callback_call(&amp;on_print, 1, argv, &amp;rettv);</a>
<a name="ln2713">    tv_clear(&amp;rettv);</a>
<a name="ln2714">    return;</a>
<a name="ln2715">  }</a>
<a name="ln2716"> </a>
<a name="ln2717">  while ((maxlen &lt; 0 || s - str &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2718">    int len = utf_ptr2len(s);</a>
<a name="ln2719">    if (!(silent_mode &amp;&amp; p_verbose == 0)) {</a>
<a name="ln2720">      // NL --&gt; CR NL translation (for Unix, not for &quot;--version&quot;)</a>
<a name="ln2721">      p = &amp;buf[0];</a>
<a name="ln2722">      if (*s == '\n' &amp;&amp; !info_message) {</a>
<a name="ln2723">        *p++ = '\r';</a>
<a name="ln2724">      }</a>
<a name="ln2725">      memcpy(p, s, (size_t)len);</a>
<a name="ln2726">      *(p + len) = '\0';</a>
<a name="ln2727">      if (info_message) {</a>
<a name="ln2728">        os_msg(buf);</a>
<a name="ln2729">      } else {</a>
<a name="ln2730">        os_errmsg(buf);</a>
<a name="ln2731">      }</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    int cw = utf_char2cells(utf_ptr2char(s));</a>
<a name="ln2735">    // primitive way to compute the current column</a>
<a name="ln2736">    if (cmdmsg_rl) {</a>
<a name="ln2737">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2738">        msg_col = Columns - 1;</a>
<a name="ln2739">      } else {</a>
<a name="ln2740">        msg_col -= cw;</a>
<a name="ln2741">      }</a>
<a name="ln2742">    } else {</a>
<a name="ln2743">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2744">        msg_col = 0;</a>
<a name="ln2745">      } else {</a>
<a name="ln2746">        msg_col += cw;</a>
<a name="ln2747">      }</a>
<a name="ln2748">    }</a>
<a name="ln2749">    s += len;</a>
<a name="ln2750">  }</a>
<a name="ln2751">  msg_didout = true;  // assume that line is not empty</a>
<a name="ln2752">}</a>
<a name="ln2753"> </a>
<a name="ln2754">/// Show the more-prompt and handle the user response.</a>
<a name="ln2755">/// This takes care of scrolling back and displaying previously displayed text.</a>
<a name="ln2756">/// When at hit-enter prompt &quot;typed_char&quot; is the already typed character,</a>
<a name="ln2757">/// otherwise it's NUL.</a>
<a name="ln2758">///</a>
<a name="ln2759">/// @return  true when jumping ahead to &quot;confirm_msg_tail&quot;.</a>
<a name="ln2760">static int do_more_prompt(int typed_char)</a>
<a name="ln2761">{</a>
<a name="ln2762">  static bool entered = false;</a>
<a name="ln2763">  int used_typed_char = typed_char;</a>
<a name="ln2764">  int oldState = State;</a>
<a name="ln2765">  int c;</a>
<a name="ln2766">  int retval = false;</a>
<a name="ln2767">  bool to_redraw = false;</a>
<a name="ln2768">  msgchunk_T *mp_last = NULL;</a>
<a name="ln2769">  msgchunk_T *mp;</a>
<a name="ln2770">  int i;</a>
<a name="ln2771"> </a>
<a name="ln2772">  // If headless mode is enabled and no input is required, this variable</a>
<a name="ln2773">  // will be true. However If server mode is enabled, the message &quot;--more--&quot;</a>
<a name="ln2774">  // should be displayed.</a>
<a name="ln2775">  bool no_need_more = headless_mode &amp;&amp; !embedded_mode;</a>
<a name="ln2776"> </a>
<a name="ln2777">  // We get called recursively when a timer callback outputs a message. In</a>
<a name="ln2778">  // that case don't show another prompt. Also when at the hit-Enter prompt</a>
<a name="ln2779">  // and nothing was typed.</a>
<a name="ln2780">  if (no_need_more || entered || (State == MODE_HITRETURN &amp;&amp; typed_char == 0)) {</a>
<a name="ln2781">    return false;</a>
<a name="ln2782">  }</a>
<a name="ln2783">  entered = true;</a>
<a name="ln2784"> </a>
<a name="ln2785">  if (typed_char == 'G') {</a>
<a name="ln2786">    // &quot;g&lt;&quot;: Find first line on the last page.</a>
<a name="ln2787">    mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2788">    for (i = 0; i &lt; Rows - 2 &amp;&amp; mp_last != NULL</a>
<a name="ln2789">         &amp;&amp; mp_last-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2790">      mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2791">    }</a>
<a name="ln2792">  }</a>
<a name="ln2793"> </a>
<a name="ln2794">  State = MODE_ASKMORE;</a>
<a name="ln2795">  setmouse();</a>
<a name="ln2796">  if (typed_char == NUL) {</a>
<a name="ln2797">    msg_moremsg(false);</a>
<a name="ln2798">  }</a>
<a name="ln2799">  while (true) {</a>
<a name="ln2800">    // Get a typed character directly from the user.</a>
<a name="ln2801">    if (used_typed_char != NUL) {</a>
<a name="ln2802">      c = used_typed_char;              // was typed at hit-enter prompt</a>
<a name="ln2803">      used_typed_char = NUL;</a>
<a name="ln2804">    } else {</a>
<a name="ln2805">      c = get_keystroke(resize_events);</a>
<a name="ln2806">    }</a>
<a name="ln2807"> </a>
<a name="ln2808">    int toscroll = 0;</a>
<a name="ln2809">    switch (c) {</a>
<a name="ln2810">    case BS:                    // scroll one line back</a>
<a name="ln2811">    case K_BS:</a>
<a name="ln2812">    case 'k':</a>
<a name="ln2813">    case K_UP:</a>
<a name="ln2814">      toscroll = -1;</a>
<a name="ln2815">      break;</a>
<a name="ln2816"> </a>
<a name="ln2817">    case CAR:                   // one extra line</a>
<a name="ln2818">    case NL:</a>
<a name="ln2819">    case 'j':</a>
<a name="ln2820">    case K_DOWN:</a>
<a name="ln2821">      toscroll = 1;</a>
<a name="ln2822">      break;</a>
<a name="ln2823"> </a>
<a name="ln2824">    case 'u':                   // Up half a page</a>
<a name="ln2825">      toscroll = -(Rows / 2);</a>
<a name="ln2826">      break;</a>
<a name="ln2827"> </a>
<a name="ln2828">    case 'd':                   // Down half a page</a>
<a name="ln2829">      toscroll = Rows / 2;</a>
<a name="ln2830">      break;</a>
<a name="ln2831"> </a>
<a name="ln2832">    case 'b':                   // one page back</a>
<a name="ln2833">    case K_PAGEUP:</a>
<a name="ln2834">      toscroll = -(Rows - 1);</a>
<a name="ln2835">      break;</a>
<a name="ln2836"> </a>
<a name="ln2837">    case ' ':                   // one extra page</a>
<a name="ln2838">    case 'f':</a>
<a name="ln2839">    case K_PAGEDOWN:</a>
<a name="ln2840">    case K_LEFTMOUSE:</a>
<a name="ln2841">      toscroll = Rows - 1;</a>
<a name="ln2842">      break;</a>
<a name="ln2843"> </a>
<a name="ln2844">    case 'g':                   // all the way back to the start</a>
<a name="ln2845">      toscroll = -999999;</a>
<a name="ln2846">      break;</a>
<a name="ln2847"> </a>
<a name="ln2848">    case 'G':                   // all the way to the end</a>
<a name="ln2849">      toscroll = 999999;</a>
<a name="ln2850">      lines_left = 999999;</a>
<a name="ln2851">      break;</a>
<a name="ln2852"> </a>
<a name="ln2853">    case ':':                   // start new command line</a>
<a name="ln2854">      if (!confirm_msg_used) {</a>
<a name="ln2855">        // Since got_int is set all typeahead will be flushed, but we</a>
<a name="ln2856">        // want to keep this ':', remember that in a special way.</a>
<a name="ln2857">        typeahead_noflush(':');</a>
<a name="ln2858">        cmdline_row = Rows - 1;                 // put ':' on this line</a>
<a name="ln2859">        skip_redraw = true;                     // skip redraw once</a>
<a name="ln2860">        need_wait_return = false;               // don't wait in main()</a>
<a name="ln2861">      }</a>
<a name="ln2862">      FALLTHROUGH;</a>
<a name="ln2863">    case 'q':                   // quit</a>
<a name="ln2864">    case Ctrl_C:</a>
<a name="ln2865">    case ESC:</a>
<a name="ln2866">      if (confirm_msg_used) {</a>
<a name="ln2867">        // Jump to the choices of the dialog.</a>
<a name="ln2868">        retval = true;</a>
<a name="ln2869">      } else {</a>
<a name="ln2870">        got_int = true;</a>
<a name="ln2871">        quit_more = true;</a>
<a name="ln2872">      }</a>
<a name="ln2873">      // When there is some more output (wrapping line) display that</a>
<a name="ln2874">      // without another prompt.</a>
<a name="ln2875">      lines_left = Rows - 1;</a>
<a name="ln2876">      break;</a>
<a name="ln2877"> </a>
<a name="ln2878">    case K_EVENT:</a>
<a name="ln2879">      // only resize_events are processed here</a>
<a name="ln2880">      // Attempt to redraw the screen. sb_text doesn't support reflow</a>
<a name="ln2881">      // so this only really works for vertical resize.</a>
<a name="ln2882">      multiqueue_process_events(resize_events);</a>
<a name="ln2883">      to_redraw = true;</a>
<a name="ln2884">      break;</a>
<a name="ln2885"> </a>
<a name="ln2886">    default:                    // no valid response</a>
<a name="ln2887">      msg_moremsg(true);</a>
<a name="ln2888">      continue;</a>
<a name="ln2889">    }</a>
<a name="ln2890"> </a>
<a name="ln2891">    // code assumes we only do one at a time</a>
<a name="ln2892">    assert((toscroll == 0) || !to_redraw);</a>
<a name="ln2893"> </a>
<a name="ln2894">    if (toscroll != 0 || to_redraw) {</a>
<a name="ln2895">      if (toscroll &lt; 0 || to_redraw) {</a>
<a name="ln2896">        // go to start of last line</a>
<a name="ln2897">        if (mp_last == NULL) {</a>
<a name="ln2898">          mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2899">        } else if (mp_last-&gt;sb_prev != NULL) {</a>
<a name="ln2900">          mp = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2901">        } else {</a>
<a name="ln2902">          mp = NULL;</a>
<a name="ln2903">        }</a>
<a name="ln2904"> </a>
<a name="ln2905">        // go to start of line at top of the screen</a>
<a name="ln2906">        for (i = 0; i &lt; Rows - 2 &amp;&amp; mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2907">          mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2908">        }</a>
<a name="ln2909"> </a>
<a name="ln2910">        if (mp != NULL &amp;&amp; (mp-&gt;sb_prev != NULL || to_redraw)) {</a>
<a name="ln2911">          // Find line to be displayed at top</a>
<a name="ln2912">          for (i = 0; i &gt; toscroll; i--) {</a>
<a name="ln2913">            if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2914">              break;</a>
<a name="ln2915">            }</a>
<a name="ln2916">            mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2917">            if (mp_last == NULL) {</a>
<a name="ln2918">              mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2919">            } else {</a>
<a name="ln2920">              mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2921">            }</a>
<a name="ln2922">          }</a>
<a name="ln2923"> </a>
<a name="ln2924">          if (toscroll == -1 &amp;&amp; !to_redraw) {</a>
<a name="ln2925">            grid_ins_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2926">            grid_fill(&amp;msg_grid_adj, 0, 1, 0, Columns, ' ', ' ',</a>
<a name="ln2927">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2928">            // display line at top</a>
<a name="ln2929">            (void)disp_sb_line(0, mp);</a>
<a name="ln2930">          } else {</a>
<a name="ln2931">            // redisplay all lines</a>
<a name="ln2932">            // TODO(bfredl): this case is not optimized (though only concerns</a>
<a name="ln2933">            // event fragmentization, not unnecessary scroll events).</a>
<a name="ln2934">            grid_fill(&amp;msg_grid_adj, 0, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2935">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2936">            for (i = 0; mp != NULL &amp;&amp; i &lt; Rows - 1; i++) {</a>
<a name="ln2937">              mp = disp_sb_line(i, mp);</a>
<a name="ln2938">              msg_scrolled++;</a>
<a name="ln2939">            }</a>
<a name="ln2940">            to_redraw = false;</a>
<a name="ln2941">          }</a>
<a name="ln2942">          toscroll = 0;</a>
<a name="ln2943">        }</a>
<a name="ln2944">      } else {</a>
<a name="ln2945">        // First display any text that we scrolled back.</a>
<a name="ln2946">        // if p_ch=0 we need to allocate a line for &quot;press enter&quot; messages!</a>
<a name="ln2947">        if (cmdline_row &gt;= Rows &amp;&amp; !ui_has(kUIMessages)) {</a>
<a name="ln2948">          msg_scroll_up(true, false);</a>
<a name="ln2949">          msg_scrolled++;</a>
<a name="ln2950">        }</a>
<a name="ln2951">        while (toscroll &gt; 0 &amp;&amp; mp_last != NULL) {</a>
<a name="ln2952">          if (msg_do_throttle() &amp;&amp; !msg_grid.throttled) {</a>
<a name="ln2953">            // Tricky: we redraw at one line higher than usual. Therefore</a>
<a name="ln2954">            // the non-flushed area is one line larger.</a>
<a name="ln2955">            msg_scrolled_at_flush--;</a>
<a name="ln2956">            msg_grid_scroll_discount++;</a>
<a name="ln2957">          }</a>
<a name="ln2958">          // scroll up, display line at bottom</a>
<a name="ln2959">          msg_scroll_up(true, false);</a>
<a name="ln2960">          inc_msg_scrolled();</a>
<a name="ln2961">          grid_fill(&amp;msg_grid_adj, Rows - 2, Rows - 1, 0, Columns, ' ', ' ',</a>
<a name="ln2962">                    HL_ATTR(HLF_MSG));</a>
<a name="ln2963">          mp_last = disp_sb_line(Rows - 2, mp_last);</a>
<a name="ln2964">          toscroll--;</a>
<a name="ln2965">        }</a>
<a name="ln2966">      }</a>
<a name="ln2967"> </a>
<a name="ln2968">      if (toscroll &lt;= 0) {</a>
<a name="ln2969">        // displayed the requested text, more prompt again</a>
<a name="ln2970">        grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2971">                  HL_ATTR(HLF_MSG));</a>
<a name="ln2972">        msg_moremsg(false);</a>
<a name="ln2973">        continue;</a>
<a name="ln2974">      }</a>
<a name="ln2975"> </a>
<a name="ln2976">      // display more text, return to caller</a>
<a name="ln2977">      lines_left = toscroll;</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">    break;</a>
<a name="ln2981">  }</a>
<a name="ln2982"> </a>
<a name="ln2983">  // clear the --more-- message</a>
<a name="ln2984">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2985">            HL_ATTR(HLF_MSG));</a>
<a name="ln2986">  redraw_cmdline = true;</a>
<a name="ln2987">  clear_cmdline = false;</a>
<a name="ln2988">  mode_displayed = false;</a>
<a name="ln2989"> </a>
<a name="ln2990">  State = oldState;</a>
<a name="ln2991">  setmouse();</a>
<a name="ln2992">  if (quit_more) {</a>
<a name="ln2993">    msg_row = Rows - 1;</a>
<a name="ln2994">    msg_col = 0;</a>
<a name="ln2995">  } else if (cmdmsg_rl) {</a>
<a name="ln2996">    msg_col = Columns - 1;</a>
<a name="ln2997">  }</a>
<a name="ln2998"> </a>
<a name="ln2999">  entered = false;</a>
<a name="ln3000">  return retval;</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">#if defined(MSWIN)</a>
<a name="ln3004">/// Headless (no UI) error message handler.</a>
<a name="ln3005">static void do_msg(const char *str, bool errmsg)</a>
<a name="ln3006">{</a>
<a name="ln3007">  static bool did_err = false;</a>
<a name="ln3008">  assert(str != NULL);</a>
<a name="ln3009">  wchar_t *utf16str;</a>
<a name="ln3010">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln3011">  if (r != 0 &amp;&amp; !did_err) {</a>
<a name="ln3012">    did_err = true;</a>
<a name="ln3013">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln3014">    ELOG(&quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln3015">  } else if (r == 0) {</a>
<a name="ln3016">    if (errmsg) {</a>
<a name="ln3017">      fwprintf(stderr, L&quot;%ls&quot;, utf16str);</a>
<a name="ln3018">    } else {</a>
<a name="ln3019">      wprintf(L&quot;%ls&quot;, utf16str);</a>
<a name="ln3020">    }</a>
<a name="ln3021">    xfree(utf16str);</a>
<a name="ln3022">  }</a>
<a name="ln3023">}</a>
<a name="ln3024"> </a>
<a name="ln3025">void os_errmsg(const char *str)</a>
<a name="ln3026">{</a>
<a name="ln3027">  do_msg(str, true);</a>
<a name="ln3028">}</a>
<a name="ln3029"> </a>
<a name="ln3030">/// Headless (no UI) message handler.</a>
<a name="ln3031">void os_msg(const char *str)</a>
<a name="ln3032">{</a>
<a name="ln3033">  do_msg(str, false);</a>
<a name="ln3034">}</a>
<a name="ln3035">#endif  // MSWIN</a>
<a name="ln3036"> </a>
<a name="ln3037">/// Put a character on the screen at the current message position and advance</a>
<a name="ln3038">/// to the next position.  Only for printable ASCII!</a>
<a name="ln3039">static void msg_screen_putchar(int c, int attr)</a>
<a name="ln3040">{</a>
<a name="ln3041">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln3042">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln3043">  grid_putchar(&amp;msg_grid_adj, c, msg_row, msg_col, attr);</a>
<a name="ln3044">  if (cmdmsg_rl) {</a>
<a name="ln3045">    if (--msg_col == 0) {</a>
<a name="ln3046">      msg_col = Columns;</a>
<a name="ln3047">      msg_row++;</a>
<a name="ln3048">    }</a>
<a name="ln3049">  } else {</a>
<a name="ln3050">    if (++msg_col &gt;= Columns) {</a>
<a name="ln3051">      msg_col = 0;</a>
<a name="ln3052">      msg_row++;</a>
<a name="ln3053">    }</a>
<a name="ln3054">  }</a>
<a name="ln3055">}</a>
<a name="ln3056"> </a>
<a name="ln3057">void msg_moremsg(int full)</a>
<a name="ln3058">{</a>
<a name="ln3059">  int attr;</a>
<a name="ln3060">  char *s = _(&quot;-- More --&quot;);</a>
<a name="ln3061"> </a>
<a name="ln3062">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), HL_ATTR(HLF_M));</a>
<a name="ln3063">  grid_puts(&amp;msg_grid_adj, s, -1, Rows - 1, 0, attr);</a>
<a name="ln3064">  if (full) {</a>
<a name="ln3065">    grid_puts(&amp;msg_grid_adj, _(&quot; SPACE/d/j: screen/page/line down, b/u/k: up, q: quit &quot;), -1,</a>
<a name="ln3066">              Rows - 1, vim_strsize(s), attr);</a>
<a name="ln3067">  }</a>
<a name="ln3068">}</a>
<a name="ln3069"> </a>
<a name="ln3070">/// Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,</a>
<a name="ln3071">/// MODE_CONFIRM or exmode_active.</a>
<a name="ln3072">void repeat_message(void)</a>
<a name="ln3073">{</a>
<a name="ln3074">  if (State == MODE_ASKMORE) {</a>
<a name="ln3075">    msg_moremsg(true);          // display --more-- message again</a>
<a name="ln3076">    msg_row = Rows - 1;</a>
<a name="ln3077">  } else if (State == MODE_CONFIRM) {</a>
<a name="ln3078">    display_confirm_msg();      // display &quot;:confirm&quot; message again</a>
<a name="ln3079">    msg_row = Rows - 1;</a>
<a name="ln3080">  } else if (State == MODE_EXTERNCMD) {</a>
<a name="ln3081">    ui_cursor_goto(msg_row, msg_col);     // put cursor back</a>
<a name="ln3082">  } else if (State == MODE_HITRETURN || State == MODE_SETWSIZE) {</a>
<a name="ln3083">    if (msg_row == Rows - 1) {</a>
<a name="ln3084">      // Avoid drawing the &quot;hit-enter&quot; prompt below the previous one,</a>
<a name="ln3085">      // overwrite it.  Esp. useful when regaining focus and a</a>
<a name="ln3086">      // FocusGained autocmd exists but didn't draw anything.</a>
<a name="ln3087">      msg_didout = false;</a>
<a name="ln3088">      msg_col = 0;</a>
<a name="ln3089">      msg_clr_eos();</a>
<a name="ln3090">    }</a>
<a name="ln3091">    hit_return_msg();</a>
<a name="ln3092">    msg_row = Rows - 1;</a>
<a name="ln3093">  }</a>
<a name="ln3094">}</a>
<a name="ln3095"> </a>
<a name="ln3096">/// Clear from current message position to end of screen.</a>
<a name="ln3097">/// Skip this when &quot;:silent&quot; was used, no need to clear for redirection.</a>
<a name="ln3098">void msg_clr_eos(void)</a>
<a name="ln3099">{</a>
<a name="ln3100">  if (msg_silent == 0) {</a>
<a name="ln3101">    msg_clr_eos_force();</a>
<a name="ln3102">  }</a>
<a name="ln3103">}</a>
<a name="ln3104"> </a>
<a name="ln3105">/// Clear from current message position to end of screen.</a>
<a name="ln3106">/// Note: msg_col is not updated, so we remember the end of the message</a>
<a name="ln3107">/// for msg_check().</a>
<a name="ln3108">void msg_clr_eos_force(void)</a>
<a name="ln3109">{</a>
<a name="ln3110">  if (ui_has(kUIMessages)) {</a>
<a name="ln3111">    return;</a>
<a name="ln3112">  }</a>
<a name="ln3113">  int msg_startcol = (cmdmsg_rl) ? 0 : msg_col;</a>
<a name="ln3114">  int msg_endcol = (cmdmsg_rl) ? msg_col + 1 : Columns;</a>
<a name="ln3115"> </a>
<a name="ln3116">  if (msg_grid.chars &amp;&amp; msg_row &lt; msg_grid_pos) {</a>
<a name="ln3117">    // TODO(bfredl): ugly, this state should already been validated at this</a>
<a name="ln3118">    // point. But msg_clr_eos() is called in a lot of places.</a>
<a name="ln3119">    msg_row = msg_grid_pos;</a>
<a name="ln3120">  }</a>
<a name="ln3121"> </a>
<a name="ln3122">  grid_fill(&amp;msg_grid_adj, msg_row, msg_row + 1, msg_startcol, msg_endcol,</a>
<a name="ln3123">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3124">  grid_fill(&amp;msg_grid_adj, msg_row + 1, Rows, 0, Columns,</a>
<a name="ln3125">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3126"> </a>
<a name="ln3127">  redraw_cmdline = true;  // overwritten the command line</a>
<a name="ln3128">  if (msg_row &lt; Rows - 1 || msg_col == (cmdmsg_rl ? Columns : 0)) {</a>
<a name="ln3129">    clear_cmdline = false;  // command line has been cleared</a>
<a name="ln3130">    mode_displayed = false;  // mode cleared or overwritten</a>
<a name="ln3131">  }</a>
<a name="ln3132">}</a>
<a name="ln3133"> </a>
<a name="ln3134">/// Clear the command line.</a>
<a name="ln3135">void msg_clr_cmdline(void)</a>
<a name="ln3136">{</a>
<a name="ln3137">  msg_row = cmdline_row;</a>
<a name="ln3138">  msg_col = 0;</a>
<a name="ln3139">  msg_clr_eos_force();</a>
<a name="ln3140">}</a>
<a name="ln3141"> </a>
<a name="ln3142">/// end putting a message on the screen</a>
<a name="ln3143">/// call wait_return() if the message does not fit in the available space</a>
<a name="ln3144">///</a>
<a name="ln3145">/// @return  true if wait_return() not called.</a>
<a name="ln3146">int msg_end(void)</a>
<a name="ln3147">{</a>
<a name="ln3148">  // If the string is larger than the window,</a>
<a name="ln3149">  // or the ruler option is set and we run into it,</a>
<a name="ln3150">  // we have to redraw the window.</a>
<a name="ln3151">  // Do not do this if we are abandoning the file or editing the command line.</a>
<a name="ln3152">  if (!exiting &amp;&amp; need_wait_return &amp;&amp; !(State &amp; MODE_CMDLINE)) {</a>
<a name="ln3153">    wait_return(false);</a>
<a name="ln3154">    return false;</a>
<a name="ln3155">  }</a>
<a name="ln3156"> </a>
<a name="ln3157">  // NOTE: ui_flush() used to be called here. This had to be removed, as it</a>
<a name="ln3158">  // inhibited substantial performance improvements. It is assumed that relevant</a>
<a name="ln3159">  // callers invoke ui_flush() before going into CPU busywork, or restricted</a>
<a name="ln3160">  // event processing after displaying a message to the user.</a>
<a name="ln3161">  msg_ext_ui_flush();</a>
<a name="ln3162">  return true;</a>
<a name="ln3163">}</a>
<a name="ln3164"> </a>
<a name="ln3165">void msg_ext_ui_flush(void)</a>
<a name="ln3166">{</a>
<a name="ln3167">  if (!ui_has(kUIMessages)) {</a>
<a name="ln3168">    msg_ext_kind = NULL;</a>
<a name="ln3169">    return;</a>
<a name="ln3170">  }</a>
<a name="ln3171"> </a>
<a name="ln3172">  msg_ext_emit_chunk();</a>
<a name="ln3173">  if (msg_ext_chunks.size &gt; 0) {</a>
<a name="ln3174">    ui_call_msg_show(cstr_as_string((char *)msg_ext_kind),</a>
<a name="ln3175">                     msg_ext_chunks, msg_ext_overwrite);</a>
<a name="ln3176">    if (!msg_ext_overwrite) {</a>
<a name="ln3177">      msg_ext_visible++;</a>
<a name="ln3178">    }</a>
<a name="ln3179">    msg_ext_kind = NULL;</a>
<a name="ln3180">    api_free_array(msg_ext_chunks);</a>
<a name="ln3181">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3182">    msg_ext_cur_len = 0;</a>
<a name="ln3183">    msg_ext_overwrite = false;</a>
<a name="ln3184">  }</a>
<a name="ln3185">}</a>
<a name="ln3186"> </a>
<a name="ln3187">void msg_ext_flush_showmode(void)</a>
<a name="ln3188">{</a>
<a name="ln3189">  // Showmode messages doesn't interrupt normal message flow, so we use</a>
<a name="ln3190">  // separate event. Still reuse the same chunking logic, for simplicity.</a>
<a name="ln3191">  if (ui_has(kUIMessages)) {</a>
<a name="ln3192">    msg_ext_emit_chunk();</a>
<a name="ln3193">    ui_call_msg_showmode(msg_ext_chunks);</a>
<a name="ln3194">    api_free_array(msg_ext_chunks);</a>
<a name="ln3195">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3196">    msg_ext_cur_len = 0;</a>
<a name="ln3197">  }</a>
<a name="ln3198">}</a>
<a name="ln3199"> </a>
<a name="ln3200">void msg_ext_clear(bool force)</a>
<a name="ln3201">{</a>
<a name="ln3202">  if (msg_ext_visible &amp;&amp; (!msg_ext_keep_after_cmdline || force)) {</a>
<a name="ln3203">    ui_call_msg_clear();</a>
<a name="ln3204">    msg_ext_visible = 0;</a>
<a name="ln3205">    msg_ext_overwrite = false;  // nothing to overwrite</a>
<a name="ln3206">  }</a>
<a name="ln3207">  if (msg_ext_history_visible) {</a>
<a name="ln3208">    ui_call_msg_history_clear();</a>
<a name="ln3209">    msg_ext_history_visible = false;</a>
<a name="ln3210">  }</a>
<a name="ln3211"> </a>
<a name="ln3212">  // Only keep once.</a>
<a name="ln3213">  msg_ext_keep_after_cmdline = false;</a>
<a name="ln3214">}</a>
<a name="ln3215"> </a>
<a name="ln3216">void msg_ext_clear_later(void)</a>
<a name="ln3217">{</a>
<a name="ln3218">  if (msg_ext_is_visible()) {</a>
<a name="ln3219">    msg_ext_need_clear = true;</a>
<a name="ln3220">    if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln3221">      must_redraw = UPD_VALID;</a>
<a name="ln3222">    }</a>
<a name="ln3223">  }</a>
<a name="ln3224">}</a>
<a name="ln3225"> </a>
<a name="ln3226">void msg_ext_check_clear(void)</a>
<a name="ln3227">{</a>
<a name="ln3228">  // Redraw after cmdline or prompt is expected to clear messages.</a>
<a name="ln3229">  if (msg_ext_need_clear) {</a>
<a name="ln3230">    msg_ext_clear(true);</a>
<a name="ln3231">    msg_ext_need_clear = false;</a>
<a name="ln3232">  }</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">bool msg_ext_is_visible(void)</a>
<a name="ln3236">{</a>
<a name="ln3237">  return ui_has(kUIMessages) &amp;&amp; msg_ext_visible &gt; 0;</a>
<a name="ln3238">}</a>
<a name="ln3239"> </a>
<a name="ln3240">/// If the written message runs into the shown command or ruler, we have to</a>
<a name="ln3241">/// wait for hit-return and redraw the window later.</a>
<a name="ln3242">void msg_check(void)</a>
<a name="ln3243">{</a>
<a name="ln3244">  if (ui_has(kUIMessages)) {</a>
<a name="ln3245">    return;</a>
<a name="ln3246">  }</a>
<a name="ln3247">  if (msg_row == Rows - 1 &amp;&amp; msg_col &gt;= sc_col) {</a>
<a name="ln3248">    need_wait_return = true;</a>
<a name="ln3249">    redraw_cmdline = true;</a>
<a name="ln3250">  }</a>
<a name="ln3251">}</a>
<a name="ln3252"> </a>
<a name="ln3253">/// May write a string to the redirection file.</a>
<a name="ln3254">///</a>
<a name="ln3255">/// @param maxlen  if -1, write the whole string, otherwise up to &quot;maxlen&quot; bytes.</a>
<a name="ln3256">static void redir_write(const char *const str, const ptrdiff_t maxlen)</a>
<a name="ln3257">{</a>
<a name="ln3258">  const char *s = str;</a>
<a name="ln3259">  static int cur_col = 0;</a>
<a name="ln3260"> </a>
<a name="ln3261">  if (maxlen == 0) {</a>
<a name="ln3262">    return;</a>
<a name="ln3263">  }</a>
<a name="ln3264"> </a>
<a name="ln3265">  // Don't do anything for displaying prompts and the like.</a>
<a name="ln3266">  if (redir_off) {</a>
<a name="ln3267">    return;</a>
<a name="ln3268">  }</a>
<a name="ln3269"> </a>
<a name="ln3270">  // If 'verbosefile' is set prepare for writing in that file.</a>
<a name="ln3271">  if (*p_vfile != NUL &amp;&amp; verbose_fd == NULL) {</a>
<a name="ln3272">    verbose_open();</a>
<a name="ln3273">  }</a>
<a name="ln3274"> </a>
<a name="ln3275">  if (redirecting()) {</a>
<a name="ln3276">    // If the string doesn't start with CR or NL, go to msg_col</a>
<a name="ln3277">    if (*s != '\n' &amp;&amp; *s != '\r') {</a>
<a name="ln3278">      while (cur_col &lt; msg_col) {</a>
<a name="ln3279">        if (capture_ga) {</a>
<a name="ln3280">          ga_concat_len(capture_ga, &quot; &quot;, 1);</a>
<a name="ln3281">        }</a>
<a name="ln3282">        if (redir_reg) {</a>
<a name="ln3283">          write_reg_contents(redir_reg, &quot; &quot;, 1, true);</a>
<a name="ln3284">        } else if (redir_vname) {</a>
<a name="ln3285">          var_redir_str(&quot; &quot;, -1);</a>
<a name="ln3286">        } else if (redir_fd != NULL) {</a>
<a name="ln3287">          fputs(&quot; &quot;, redir_fd);</a>
<a name="ln3288">        }</a>
<a name="ln3289">        if (verbose_fd != NULL) {</a>
<a name="ln3290">          fputs(&quot; &quot;, verbose_fd);</a>
<a name="ln3291">        }</a>
<a name="ln3292">        cur_col++;</a>
<a name="ln3293">      }</a>
<a name="ln3294">    }</a>
<a name="ln3295"> </a>
<a name="ln3296">    size_t len = maxlen == -1 ? strlen(s) : (size_t)maxlen;</a>
<a name="ln3297">    if (capture_ga) {</a>
<a name="ln3298">      ga_concat_len(capture_ga, str, len);</a>
<a name="ln3299">    }</a>
<a name="ln3300">    if (redir_reg) {</a>
<a name="ln3301">      write_reg_contents(redir_reg, s, (ssize_t)len, true);</a>
<a name="ln3302">    }</a>
<a name="ln3303">    if (redir_vname) {</a>
<a name="ln3304">      var_redir_str(s, (int)maxlen);</a>
<a name="ln3305">    }</a>
<a name="ln3306"> </a>
<a name="ln3307">    // Write and adjust the current column.</a>
<a name="ln3308">    while (*s != NUL</a>
<a name="ln3309">           &amp;&amp; (maxlen &lt; 0 || (int)(s - str) &lt; maxlen)) {</a>
<a name="ln3310">      if (!redir_reg &amp;&amp; !redir_vname &amp;&amp; !capture_ga) {</a>
<a name="ln3311">        if (redir_fd != NULL) {</a>
<a name="ln3312">          putc(*s, redir_fd);</a>
<a name="ln3313">        }</a>
<a name="ln3314">      }</a>
<a name="ln3315">      if (verbose_fd != NULL) {</a>
<a name="ln3316">        putc(*s, verbose_fd);</a>
<a name="ln3317">      }</a>
<a name="ln3318">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln3319">        cur_col = 0;</a>
<a name="ln3320">      } else if (*s == '\t') {</a>
<a name="ln3321">        cur_col += (8 - cur_col % 8);</a>
<a name="ln3322">      } else {</a>
<a name="ln3323">        cur_col++;</a>
<a name="ln3324">      }</a>
<a name="ln3325">      s++;</a>
<a name="ln3326">    }</a>
<a name="ln3327"> </a>
<a name="ln3328">    if (msg_silent != 0) {      // should update msg_col</a>
<a name="ln3329">      msg_col = cur_col;</a>
<a name="ln3330">    }</a>
<a name="ln3331">  }</a>
<a name="ln3332">}</a>
<a name="ln3333"> </a>
<a name="ln3334">int redirecting(void)</a>
<a name="ln3335">{</a>
<a name="ln3336">  return redir_fd != NULL || *p_vfile != NUL</a>
<a name="ln3337">         || redir_reg || redir_vname || capture_ga != NULL;</a>
<a name="ln3338">}</a>
<a name="ln3339"> </a>
<a name="ln3340">/// Before giving verbose message.</a>
<a name="ln3341">/// Must always be called paired with verbose_leave()!</a>
<a name="ln3342">void verbose_enter(void)</a>
<a name="ln3343">{</a>
<a name="ln3344">  if (*p_vfile != NUL) {</a>
<a name="ln3345">    msg_silent++;</a>
<a name="ln3346">  }</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349">/// After giving verbose message.</a>
<a name="ln3350">/// Must always be called paired with verbose_enter()!</a>
<a name="ln3351">void verbose_leave(void)</a>
<a name="ln3352">{</a>
<a name="ln3353">  if (*p_vfile != NUL) {</a>
<a name="ln3354">    if (--msg_silent &lt; 0) {</a>
<a name="ln3355">      msg_silent = 0;</a>
<a name="ln3356">    }</a>
<a name="ln3357">  }</a>
<a name="ln3358">}</a>
<a name="ln3359"> </a>
<a name="ln3360">/// Like verbose_enter() and set msg_scroll when displaying the message.</a>
<a name="ln3361">void verbose_enter_scroll(void)</a>
<a name="ln3362">{</a>
<a name="ln3363">  if (*p_vfile != NUL) {</a>
<a name="ln3364">    msg_silent++;</a>
<a name="ln3365">  } else {</a>
<a name="ln3366">    // always scroll up, don't overwrite</a>
<a name="ln3367">    msg_scroll = true;</a>
<a name="ln3368">  }</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">/// Like verbose_leave() and set cmdline_row when displaying the message.</a>
<a name="ln3372">void verbose_leave_scroll(void)</a>
<a name="ln3373">{</a>
<a name="ln3374">  if (*p_vfile != NUL) {</a>
<a name="ln3375">    if (--msg_silent &lt; 0) {</a>
<a name="ln3376">      msg_silent = 0;</a>
<a name="ln3377">    }</a>
<a name="ln3378">  } else {</a>
<a name="ln3379">    cmdline_row = msg_row;</a>
<a name="ln3380">  }</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">/// Called when 'verbosefile' is set: stop writing to the file.</a>
<a name="ln3384">void verbose_stop(void)</a>
<a name="ln3385">{</a>
<a name="ln3386">  if (verbose_fd != NULL) {</a>
<a name="ln3387">    fclose(verbose_fd);</a>
<a name="ln3388">    verbose_fd = NULL;</a>
<a name="ln3389">  }</a>
<a name="ln3390">  verbose_did_open = false;</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">/// Open the file 'verbosefile'.</a>
<a name="ln3394">///</a>
<a name="ln3395">/// @return  FAIL or OK.</a>
<a name="ln3396">int verbose_open(void)</a>
<a name="ln3397">{</a>
<a name="ln3398">  if (verbose_fd == NULL &amp;&amp; !verbose_did_open) {</a>
<a name="ln3399">    // Only give the error message once.</a>
<a name="ln3400">    verbose_did_open = true;</a>
<a name="ln3401"> </a>
<a name="ln3402">    verbose_fd = os_fopen(p_vfile, &quot;a&quot;);</a>
<a name="ln3403">    if (verbose_fd == NULL) {</a>
<a name="ln3404">      semsg(_(e_notopen), p_vfile);</a>
<a name="ln3405">      return FAIL;</a>
<a name="ln3406">    }</a>
<a name="ln3407">  }</a>
<a name="ln3408">  return OK;</a>
<a name="ln3409">}</a>
<a name="ln3410"> </a>
<a name="ln3411">/// Give a warning message (for searching).</a>
<a name="ln3412">/// Use 'w' highlighting and may repeat the message after redrawing</a>
<a name="ln3413">void give_warning(const char *message, bool hl)</a>
<a name="ln3414">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3415">{</a>
<a name="ln3416">  // Don't do this for &quot;:silent&quot;.</a>
<a name="ln3417">  if (msg_silent != 0) {</a>
<a name="ln3418">    return;</a>
<a name="ln3419">  }</a>
<a name="ln3420"> </a>
<a name="ln3421">  // Don't want a hit-enter prompt here.</a>
<a name="ln3422">  no_wait_return++;</a>
<a name="ln3423"> </a>
<a name="ln3424">  set_vim_var_string(VV_WARNINGMSG, message, -1);</a>
<a name="ln3425">  XFREE_CLEAR(keep_msg);</a>
<a name="ln3426">  if (hl) {</a>
<a name="ln3427">    keep_msg_attr = HL_ATTR(HLF_W);</a>
<a name="ln3428">  } else {</a>
<a name="ln3429">    keep_msg_attr = 0;</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  if (msg_ext_kind == NULL) {</a>
<a name="ln3433">    msg_ext_set_kind(&quot;wmsg&quot;);</a>
<a name="ln3434">  }</a>
<a name="ln3435"> </a>
<a name="ln3436">  if (msg(message, keep_msg_attr) &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln3437">    set_keep_msg(message, keep_msg_attr);</a>
<a name="ln3438">  }</a>
<a name="ln3439">  msg_didout = false;  // Overwrite this message.</a>
<a name="ln3440">  msg_nowait = true;   // Don't wait for this message.</a>
<a name="ln3441">  msg_col = 0;</a>
<a name="ln3442"> </a>
<a name="ln3443">  no_wait_return--;</a>
<a name="ln3444">}</a>
<a name="ln3445"> </a>
<a name="ln3446">void give_warning2(const char *const message, const char *const a1, bool hl)</a>
<a name="ln3447">{</a>
<a name="ln3448">  vim_snprintf(IObuff, IOSIZE, message, a1);</a>
<a name="ln3449">  give_warning(IObuff, hl);</a>
<a name="ln3450">}</a>
<a name="ln3451"> </a>
<a name="ln3452">/// Advance msg cursor to column &quot;col&quot;.</a>
<a name="ln3453">void msg_advance(int col)</a>
<a name="ln3454">{</a>
<a name="ln3455">  if (msg_silent != 0) {        // nothing to advance to</a>
<a name="ln3456">    msg_col = col;              // for redirection, may fill it up later</a>
<a name="ln3457">    return;</a>
<a name="ln3458">  }</a>
<a name="ln3459">  if (ui_has(kUIMessages)) {</a>
<a name="ln3460">    // TODO(bfredl): use byte count as a basic proxy.</a>
<a name="ln3461">    // later on we might add proper support for formatted messages.</a>
<a name="ln3462">    while (msg_ext_cur_len &lt; (size_t)col) {</a>
<a name="ln3463">      msg_putchar(' ');</a>
<a name="ln3464">    }</a>
<a name="ln3465">    return;</a>
<a name="ln3466">  }</a>
<a name="ln3467">  if (col &gt;= Columns) {         // not enough room</a>
<a name="ln3468">    col = Columns - 1;</a>
<a name="ln3469">  }</a>
<a name="ln3470">  if (cmdmsg_rl) {</a>
<a name="ln3471">    while (msg_col &gt; Columns - col) {</a>
<a name="ln3472">      msg_putchar(' ');</a>
<a name="ln3473">    }</a>
<a name="ln3474">  } else {</a>
<a name="ln3475">    while (msg_col &lt; col) {</a>
<a name="ln3476">      msg_putchar(' ');</a>
<a name="ln3477">    }</a>
<a name="ln3478">  }</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">/// Used for &quot;confirm()&quot; function, and the :confirm command prefix.</a>
<a name="ln3482">/// Versions which haven't got flexible dialogs yet, and console</a>
<a name="ln3483">/// versions, get this generic handler which uses the command line.</a>
<a name="ln3484">///</a>
<a name="ln3485">/// type  = one of:</a>
<a name="ln3486">///         VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC</a>
<a name="ln3487">/// title = title string (can be NULL for default)</a>
<a name="ln3488">/// (neither used in console dialogs at the moment)</a>
<a name="ln3489">///</a>
<a name="ln3490">/// Format of the &quot;buttons&quot; string:</a>
<a name="ln3491">/// &quot;Button1Name\nButton2Name\nButton3Name&quot;</a>
<a name="ln3492">/// The first button should normally be the default/accept</a>
<a name="ln3493">/// The second button should be the 'Cancel' button</a>
<a name="ln3494">/// Other buttons- use your imagination!</a>
<a name="ln3495">/// A '&amp;' in a button name becomes a shortcut, so each '&amp;' should be before a</a>
<a name="ln3496">/// different letter.</a>
<a name="ln3497">///</a>
<a name="ln3498">/// @param textfiel  IObuff for inputdialog(), NULL otherwise</a>
<a name="ln3499">/// @param ex_cmd  when true pressing : accepts default and starts Ex command</a>
<a name="ln3500">/// @returns 0 if cancelled, otherwise the nth button (1-indexed).</a>
<a name="ln3501">int do_dialog(int type, const char *title, const char *message, const char *buttons, int dfltbutton,</a>
<a name="ln3502">              const char *textfield, int ex_cmd)</a>
<a name="ln3503">{</a>
<a name="ln3504">  int retval = 0;</a>
<a name="ln3505">  char *hotkeys;</a>
<a name="ln3506">  int i;</a>
<a name="ln3507"> </a>
<a name="ln3508">  if (silent_mode      // No dialogs in silent mode (&quot;ex -s&quot;)</a>
<a name="ln3509">      || !ui_active()  // Without a UI Nvim waits for input forever.</a>
<a name="ln3510">      ) {</a>
<a name="ln3511">    return dfltbutton;  // return default option</a>
<a name="ln3512">  }</a>
<a name="ln3513"> </a>
<a name="ln3514">  int save_msg_silent = msg_silent;</a>
<a name="ln3515">  int oldState = State;</a>
<a name="ln3516"> </a>
<a name="ln3517">  msg_silent = 0;  // If dialog prompts for input, user needs to see it! #8788</a>
<a name="ln3518">  State = MODE_CONFIRM;</a>
<a name="ln3519">  setmouse();</a>
<a name="ln3520"> </a>
<a name="ln3521">  // Since we wait for a keypress, don't make the</a>
<a name="ln3522">  // user press RETURN as well afterwards.</a>
<a name="ln3523">  no_wait_return++;</a>
<a name="ln3524">  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);</a>
<a name="ln3525"> </a>
<a name="ln3526">  while (true) {</a>
<a name="ln3527">    // Get a typed character directly from the user.</a>
<a name="ln3528">    int c = get_keystroke(NULL);</a>
<a name="ln3529">    switch (c) {</a>
<a name="ln3530">    case CAR:                 // User accepts default option</a>
<a name="ln3531">    case NL:</a>
<a name="ln3532">      retval = dfltbutton;</a>
<a name="ln3533">      break;</a>
<a name="ln3534">    case Ctrl_C:              // User aborts/cancels</a>
<a name="ln3535">    case ESC:</a>
<a name="ln3536">      retval = 0;</a>
<a name="ln3537">      break;</a>
<a name="ln3538">    default:                  // Could be a hotkey?</a>
<a name="ln3539">      if (c &lt; 0) {            // special keys are ignored here</a>
<a name="ln3540">        continue;</a>
<a name="ln3541">      }</a>
<a name="ln3542">      if (c == ':' &amp;&amp; ex_cmd) {</a>
<a name="ln3543">        retval = dfltbutton;</a>
<a name="ln3544">        ins_char_typebuf(':', 0);</a>
<a name="ln3545">        break;</a>
<a name="ln3546">      }</a>
<a name="ln3547"> </a>
<a name="ln3548">      // Make the character lowercase, as chars in &quot;hotkeys&quot; are.</a>
<a name="ln3549">      c = mb_tolower(c);</a>
<a name="ln3550">      retval = 1;</a>
<a name="ln3551">      for (i = 0; hotkeys[i]; i++) {</a>
<a name="ln3552">        if (utf_ptr2char(hotkeys + i) == c) {</a>
<a name="ln3553">          break;</a>
<a name="ln3554">        }</a>
<a name="ln3555">        i += utfc_ptr2len(hotkeys + i) - 1;</a>
<a name="ln3556">        retval++;</a>
<a name="ln3557">      }</a>
<a name="ln3558">      if (hotkeys[i]) {</a>
<a name="ln3559">        break;</a>
<a name="ln3560">      }</a>
<a name="ln3561">      // No hotkey match, so keep waiting</a>
<a name="ln3562">      continue;</a>
<a name="ln3563">    }</a>
<a name="ln3564">    break;</a>
<a name="ln3565">  }</a>
<a name="ln3566"> </a>
<a name="ln3567">  xfree(hotkeys);</a>
<a name="ln3568"> </a>
<a name="ln3569">  msg_silent = save_msg_silent;</a>
<a name="ln3570">  State = oldState;</a>
<a name="ln3571">  setmouse();</a>
<a name="ln3572">  no_wait_return--;</a>
<a name="ln3573">  msg_end_prompt();</a>
<a name="ln3574"> </a>
<a name="ln3575">  return retval;</a>
<a name="ln3576">}</a>
<a name="ln3577"> </a>
<a name="ln3578">/// Copy one character from &quot;*from&quot; to &quot;*to&quot;, taking care of multi-byte</a>
<a name="ln3579">/// characters.  Return the length of the character in bytes.</a>
<a name="ln3580">///</a>
<a name="ln3581">/// @param lowercase  make character lower case</a>
<a name="ln3582">static int copy_char(const char *from, char *to, bool lowercase)</a>
<a name="ln3583">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3584">{</a>
<a name="ln3585">  if (lowercase) {</a>
<a name="ln3586">    int c = mb_tolower(utf_ptr2char(from));</a>
<a name="ln3587">    return utf_char2bytes(c, to);</a>
<a name="ln3588">  }</a>
<a name="ln3589">  int len = utfc_ptr2len(from);</a>
<a name="ln3590">  memmove(to, from, (size_t)len);</a>
<a name="ln3591">  return len;</a>
<a name="ln3592">}</a>
<a name="ln3593"> </a>
<a name="ln3594">#define HAS_HOTKEY_LEN 30</a>
<a name="ln3595">#define HOTK_LEN MB_MAXBYTES</a>
<a name="ln3596"> </a>
<a name="ln3597">/// Allocates memory for dialog string &amp; for storing hotkeys</a>
<a name="ln3598">///</a>
<a name="ln3599">/// Finds the size of memory required for the confirm_msg &amp; for storing hotkeys</a>
<a name="ln3600">/// and then allocates the memory for them.</a>
<a name="ln3601">/// has_hotkey array is also filled-up.</a>
<a name="ln3602">///</a>
<a name="ln3603">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3604">/// @param buttons String containing button names</a>
<a name="ln3605">/// @param[out] has_hotkey An element in this array is set to true if</a>
<a name="ln3606">///                        corresponding button has a hotkey</a>
<a name="ln3607">///</a>
<a name="ln3608">/// @return Pointer to memory allocated for storing hotkeys</a>
<a name="ln3609">static char *console_dialog_alloc(const char *message, const char *buttons, bool has_hotkey[])</a>
<a name="ln3610">{</a>
<a name="ln3611">  int lenhotkey = HOTK_LEN;  // count first button</a>
<a name="ln3612">  has_hotkey[0] = false;</a>
<a name="ln3613"> </a>
<a name="ln3614">  // Compute the size of memory to allocate.</a>
<a name="ln3615">  int len = 0;</a>
<a name="ln3616">  int idx = 0;</a>
<a name="ln3617">  const char *r = buttons;</a>
<a name="ln3618">  while (*r) {</a>
<a name="ln3619">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3620">      len += 3;                         // '\n' -&gt; ', '; 'x' -&gt; '(x)'</a>
<a name="ln3621">      lenhotkey += HOTK_LEN;            // each button needs a hotkey</a>
<a name="ln3622">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3623">        has_hotkey[++idx] = false;</a>
<a name="ln3624">      }</a>
<a name="ln3625">    } else if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3626">      r++;</a>
<a name="ln3627">      len++;                    // '&amp;a' -&gt; '[a]'</a>
<a name="ln3628">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3629">        has_hotkey[idx] = true;</a>
<a name="ln3630">      }</a>
<a name="ln3631">    }</a>
<a name="ln3632"> </a>
<a name="ln3633">    // Advance to the next character</a>
<a name="ln3634">    MB_PTR_ADV(r);</a>
<a name="ln3635">  }</a>
<a name="ln3636"> </a>
<a name="ln3637">  len += (int)(strlen(message)</a>
<a name="ln3638">               + 2                          // for the NL's</a>
<a name="ln3639">               + strlen(buttons)</a>
<a name="ln3640">               + 3);                        // for the &quot;: &quot; and NUL</a>
<a name="ln3641">  lenhotkey++;                               // for the NUL</a>
<a name="ln3642"> </a>
<a name="ln3643">  // If no hotkey is specified, first char is used.</a>
<a name="ln3644">  if (!has_hotkey[0]) {</a>
<a name="ln3645">    len += 2;                                // &quot;x&quot; -&gt; &quot;[x]&quot;</a>
<a name="ln3646">  }</a>
<a name="ln3647"> </a>
<a name="ln3648">  // Now allocate space for the strings</a>
<a name="ln3649">  xfree(confirm_msg);</a>
<a name="ln3650">  confirm_msg = xmalloc((size_t)len);</a>
<a name="ln3651">  *confirm_msg = NUL;</a>
<a name="ln3652"> </a>
<a name="ln3653">  return xmalloc((size_t)lenhotkey);</a>
<a name="ln3654">}</a>
<a name="ln3655"> </a>
<a name="ln3656">/// Format the dialog string, and display it at the bottom of</a>
<a name="ln3657">/// the screen. Return a string of hotkey chars (if defined) for</a>
<a name="ln3658">/// each 'button'. If a button has no hotkey defined, the first character of</a>
<a name="ln3659">/// the button is used.</a>
<a name="ln3660">/// The hotkeys can be multi-byte characters, but without combining chars.</a>
<a name="ln3661">///</a>
<a name="ln3662">/// @return  an allocated string with hotkeys.</a>
<a name="ln3663">static char *msg_show_console_dialog(const char *message, const char *buttons, int dfltbutton)</a>
<a name="ln3664">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3665">{</a>
<a name="ln3666">  bool has_hotkey[HAS_HOTKEY_LEN] = { false };</a>
<a name="ln3667">  char *hotk = console_dialog_alloc(message, buttons, has_hotkey);</a>
<a name="ln3668"> </a>
<a name="ln3669">  copy_hotkeys_and_msg(message, buttons, dfltbutton, has_hotkey, hotk);</a>
<a name="ln3670"> </a>
<a name="ln3671">  display_confirm_msg();</a>
<a name="ln3672">  return hotk;</a>
<a name="ln3673">}</a>
<a name="ln3674"> </a>
<a name="ln3675">/// Copies hotkeys &amp; dialog message into the memory allocated for it</a>
<a name="ln3676">///</a>
<a name="ln3677">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3678">/// @param buttons String containing button names</a>
<a name="ln3679">/// @param default_button_idx Number of default button</a>
<a name="ln3680">/// @param has_hotkey An element in this array is true if corresponding button</a>
<a name="ln3681">///                   has a hotkey</a>
<a name="ln3682">/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied</a>
<a name="ln3683">static void copy_hotkeys_and_msg(const char *message, const char *buttons, int default_button_idx,</a>
<a name="ln3684">                                 const bool has_hotkey[], char *hotkeys_ptr)</a>
<a name="ln3685">{</a>
<a name="ln3686">  *confirm_msg = '\n';</a>
<a name="ln3687">  STRCPY(confirm_msg + 1, message);</a>
<a name="ln3688"> </a>
<a name="ln3689">  char *msgp = confirm_msg + 1 + strlen(message);</a>
<a name="ln3690"> </a>
<a name="ln3691">  // Define first default hotkey. Keep the hotkey string NUL</a>
<a name="ln3692">  // terminated to avoid reading past the end.</a>
<a name="ln3693">  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3694"> </a>
<a name="ln3695">  // Remember where the choices start, displaying starts here when</a>
<a name="ln3696">  // &quot;hotkeys_ptr&quot; typed at the more prompt.</a>
<a name="ln3697">  confirm_msg_tail = msgp;</a>
<a name="ln3698">  *msgp++ = '\n';</a>
<a name="ln3699"> </a>
<a name="ln3700">  bool first_hotkey = false;  // Is the first char of button a hotkey</a>
<a name="ln3701">  if (!has_hotkey[0]) {</a>
<a name="ln3702">    first_hotkey = true;     // If no hotkey is specified, first char is used</a>
<a name="ln3703">  }</a>
<a name="ln3704"> </a>
<a name="ln3705">  int idx = 0;</a>
<a name="ln3706">  const char *r = buttons;</a>
<a name="ln3707">  while (*r) {</a>
<a name="ln3708">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3709">      *msgp++ = ',';</a>
<a name="ln3710">      *msgp++ = ' ';                    // '\n' -&gt; ', '</a>
<a name="ln3711"> </a>
<a name="ln3712">      // Advance to next hotkey and set default hotkey</a>
<a name="ln3713">      hotkeys_ptr += strlen(hotkeys_ptr);</a>
<a name="ln3714">      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3715"> </a>
<a name="ln3716">      if (default_button_idx) {</a>
<a name="ln3717">        default_button_idx--;</a>
<a name="ln3718">      }</a>
<a name="ln3719"> </a>
<a name="ln3720">      // If no hotkey is specified, first char is used.</a>
<a name="ln3721">      if (idx &lt; HAS_HOTKEY_LEN - 1 &amp;&amp; !has_hotkey[++idx]) {</a>
<a name="ln3722">        first_hotkey = true;</a>
<a name="ln3723">      }</a>
<a name="ln3724">    } else if (*r == DLG_HOTKEY_CHAR || first_hotkey) {</a>
<a name="ln3725">      if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3726">        r++;</a>
<a name="ln3727">      }</a>
<a name="ln3728"> </a>
<a name="ln3729">      first_hotkey = false;</a>
<a name="ln3730">      if (*r == DLG_HOTKEY_CHAR) {                 // '&amp;&amp;a' -&gt; '&amp;a'</a>
<a name="ln3731">        *msgp++ = *r;</a>
<a name="ln3732">      } else {</a>
<a name="ln3733">        // '&amp;a' -&gt; '[a]'</a>
<a name="ln3734">        *msgp++ = (default_button_idx == 1) ? '[' : '(';</a>
<a name="ln3735">        msgp += copy_char(r, msgp, false);</a>
<a name="ln3736">        *msgp++ = (default_button_idx == 1) ? ']' : ')';</a>
<a name="ln3737"> </a>
<a name="ln3738">        // redefine hotkey</a>
<a name="ln3739">        hotkeys_ptr[copy_char(r, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3740">      }</a>
<a name="ln3741">    } else {</a>
<a name="ln3742">      // everything else copy literally</a>
<a name="ln3743">      msgp += copy_char(r, msgp, false);</a>
<a name="ln3744">    }</a>
<a name="ln3745"> </a>
<a name="ln3746">    // advance to the next character</a>
<a name="ln3747">    MB_PTR_ADV(r);</a>
<a name="ln3748">  }</a>
<a name="ln3749"> </a>
<a name="ln3750">  *msgp++ = ':';</a>
<a name="ln3751">  *msgp++ = ' ';</a>
<a name="ln3752">  *msgp = NUL;</a>
<a name="ln3753">}</a>
<a name="ln3754"> </a>
<a name="ln3755">/// Display the &quot;:confirm&quot; message.  Also called when screen resized.</a>
<a name="ln3756">void display_confirm_msg(void)</a>
<a name="ln3757">{</a>
<a name="ln3758">  // Avoid that 'q' at the more prompt truncates the message here.</a>
<a name="ln3759">  confirm_msg_used++;</a>
<a name="ln3760">  if (confirm_msg != NULL) {</a>
<a name="ln3761">    msg_ext_set_kind(&quot;confirm&quot;);</a>
<a name="ln3762">    msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));</a>
<a name="ln3763">  }</a>
<a name="ln3764">  confirm_msg_used--;</a>
<a name="ln3765">}</a>
<a name="ln3766"> </a>
<a name="ln3767">int vim_dialog_yesno(int type, char *title, char *message, int dflt)</a>
<a name="ln3768">{</a>
<a name="ln3769">  if (do_dialog(type,</a>
<a name="ln3770">                title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3771">                message,</a>
<a name="ln3772">                _(&quot;&amp;Yes\n&amp;No&quot;), dflt, NULL, false) == 1) {</a>
<a name="ln3773">    return VIM_YES;</a>
<a name="ln3774">  }</a>
<a name="ln3775">  return VIM_NO;</a>
<a name="ln3776">}</a>
<a name="ln3777"> </a>
<a name="ln3778">int vim_dialog_yesnocancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3779">{</a>
<a name="ln3780">  switch (do_dialog(type,</a>
<a name="ln3781">                    title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3782">                    message,</a>
<a name="ln3783">                    _(&quot;&amp;Yes\n&amp;No\n&amp;Cancel&quot;), dflt, NULL, false)) {</a>
<a name="ln3784">  case 1:</a>
<a name="ln3785">    return VIM_YES;</a>
<a name="ln3786">  case 2:</a>
<a name="ln3787">    return VIM_NO;</a>
<a name="ln3788">  }</a>
<a name="ln3789">  return VIM_CANCEL;</a>
<a name="ln3790">}</a>
<a name="ln3791"> </a>
<a name="ln3792">int vim_dialog_yesnoallcancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3793">{</a>
<a name="ln3794">  switch (do_dialog(type,</a>
<a name="ln3795">                    title == NULL ? &quot;Question&quot; : title,</a>
<a name="ln3796">                    message,</a>
<a name="ln3797">                    _(&quot;&amp;Yes\n&amp;No\nSave &amp;All\n&amp;Discard All\n&amp;Cancel&quot;),</a>
<a name="ln3798">                    dflt, NULL, false)) {</a>
<a name="ln3799">  case 1:</a>
<a name="ln3800">    return VIM_YES;</a>
<a name="ln3801">  case 2:</a>
<a name="ln3802">    return VIM_NO;</a>
<a name="ln3803">  case 3:</a>
<a name="ln3804">    return VIM_ALL;</a>
<a name="ln3805">  case 4:</a>
<a name="ln3806">    return VIM_DISCARDALL;</a>
<a name="ln3807">  }</a>
<a name="ln3808">  return VIM_CANCEL;</a>
<a name="ln3809">}</a>
<a name="ln3810"> </a>
<a name="ln3811">/// Check if there should be a delay to allow the user to see a message.</a>
<a name="ln3812">///</a>
<a name="ln3813">/// Used before clearing or redrawing the screen or the command line.</a>
<a name="ln3814">void msg_check_for_delay(bool check_msg_scroll)</a>
<a name="ln3815">{</a>
<a name="ln3816">  if ((emsg_on_display || (check_msg_scroll &amp;&amp; msg_scroll))</a>
<a name="ln3817">      &amp;&amp; !did_wait_return</a>
<a name="ln3818">      &amp;&amp; emsg_silent == 0</a>
<a name="ln3819">      &amp;&amp; !in_assert_fails) {</a>
<a name="ln3820">    ui_flush();</a>
<a name="ln3821">    os_delay(1006L, true);</a>
<a name="ln3822">    emsg_on_display = false;</a>
<a name="ln3823">    if (check_msg_scroll) {</a>
<a name="ln3824">      msg_scroll = false;</a>
<a name="ln3825">    }</a>
<a name="ln3826">  }</a>
<a name="ln3827">}</a>
</code></pre>
<div class="balloon" rel="484"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="495"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="766"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="785"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="835"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="862"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="880"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2109"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>