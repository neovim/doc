<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// message.c: functions for displaying messages on the command line</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/channel.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/event/defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln25">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln32">#include &quot;nvim/globals.h&quot;</a>
<a name="ln33">#include &quot;nvim/grid.h&quot;</a>
<a name="ln34">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln35">#include &quot;nvim/indent.h&quot;</a>
<a name="ln36">#include &quot;nvim/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln38">#include &quot;nvim/log.h&quot;</a>
<a name="ln39">#include &quot;nvim/main.h&quot;</a>
<a name="ln40">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln41">#include &quot;nvim/memory.h&quot;</a>
<a name="ln42">#include &quot;nvim/message.h&quot;</a>
<a name="ln43">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln50">#include &quot;nvim/pos.h&quot;</a>
<a name="ln51">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln52">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln53">#include &quot;nvim/strings.h&quot;</a>
<a name="ln54">#include &quot;nvim/ui.h&quot;</a>
<a name="ln55">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln56">#include &quot;nvim/vim.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">// To be able to scroll back at the &quot;more&quot; and &quot;hit-enter&quot; prompts we need to</a>
<a name="ln59">// store the displayed text and remember where screen lines start.</a>
<a name="ln60">typedef struct msgchunk_S msgchunk_T;</a>
<a name="ln61">struct msgchunk_S {</a>
<a name="ln62">  msgchunk_T *sb_next;</a>
<a name="ln63">  msgchunk_T *sb_prev;</a>
<a name="ln64">  char sb_eol;                  // true when line ends after this text</a>
<a name="ln65">  int sb_msg_col;               // column in which text starts</a>
<a name="ln66">  int sb_attr;                  // text attributes</a>
<a name="ln67">  char sb_text[];               // text to be displayed</a>
<a name="ln68">};</a>
<a name="ln69"> </a>
<a name="ln70">// Magic chars used in confirm dialog strings</a>
<a name="ln71">enum {</a>
<a name="ln72">  DLG_BUTTON_SEP = '\n',</a>
<a name="ln73">  DLG_HOTKEY_CHAR = '&amp;',</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">static int confirm_msg_used = false;            // displaying confirm_msg</a>
<a name="ln77">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln78"># include &quot;message.c.generated.h&quot;</a>
<a name="ln79">#endif</a>
<a name="ln80">static char *confirm_msg = NULL;            // &quot;:confirm&quot; message</a>
<a name="ln81">static char *confirm_msg_tail;              // tail of confirm_msg</a>
<a name="ln82"> </a>
<a name="ln83">MessageHistoryEntry *first_msg_hist = NULL;</a>
<a name="ln84">MessageHistoryEntry *last_msg_hist = NULL;</a>
<a name="ln85">static int msg_hist_len = 0;</a>
<a name="ln86"> </a>
<a name="ln87">static FILE *verbose_fd = NULL;</a>
<a name="ln88">static int verbose_did_open = false;</a>
<a name="ln89"> </a>
<a name="ln90">bool keep_msg_more = false;    // keep_msg was set by msgmore()</a>
<a name="ln91"> </a>
<a name="ln92">// When writing messages to the screen, there are many different situations.</a>
<a name="ln93">// A number of variables is used to remember the current state:</a>
<a name="ln94">// msg_didany       true when messages were written since the last time the</a>
<a name="ln95">//                  user reacted to a prompt.</a>
<a name="ln96">//                  Reset: After hitting a key for the hit-return prompt,</a>
<a name="ln97">//                  hitting &lt;CR&gt; for the command line or input().</a>
<a name="ln98">//                  Set: When any message is written to the screen.</a>
<a name="ln99">// msg_didout       true when something was written to the current line.</a>
<a name="ln100">//                  Reset: When advancing to the next line, when the current</a>
<a name="ln101">//                  text can be overwritten.</a>
<a name="ln102">//                  Set: When any message is written to the screen.</a>
<a name="ln103">// msg_nowait       No extra delay for the last drawn message.</a>
<a name="ln104">//                  Used in normal_cmd() before the mode message is drawn.</a>
<a name="ln105">// emsg_on_display  There was an error message recently.  Indicates that there</a>
<a name="ln106">//                  should be a delay before redrawing.</a>
<a name="ln107">// msg_scroll       The next message should not overwrite the current one.</a>
<a name="ln108">// msg_scrolled     How many lines the screen has been scrolled (because of</a>
<a name="ln109">//                  messages).  Used in update_screen() to scroll the screen</a>
<a name="ln110">//                  back.  Incremented each time the screen scrolls a line.</a>
<a name="ln111">// msg_scrolled_ign  true when msg_scrolled is non-zero and msg_puts_attr()</a>
<a name="ln112">//                  writes something without scrolling should not make</a>
<a name="ln113">//                  need_wait_return to be set.  This is a hack to make &quot;:ts&quot;</a>
<a name="ln114">//                  work without an extra prompt.</a>
<a name="ln115">// lines_left       Number of lines available for messages before the</a>
<a name="ln116">//                  more-prompt is to be given.  -1 when not set.</a>
<a name="ln117">// need_wait_return true when the hit-return prompt is needed.</a>
<a name="ln118">//                  Reset: After giving the hit-return prompt, when the user</a>
<a name="ln119">//                  has answered some other prompt.</a>
<a name="ln120">//                  Set: When the ruler or typeahead display is overwritten,</a>
<a name="ln121">//                  scrolling the screen for some message.</a>
<a name="ln122">// keep_msg         Message to be displayed after redrawing the screen, in</a>
<a name="ln123">//                  main_loop().</a>
<a name="ln124">//                  This is an allocated string or NULL when not used.</a>
<a name="ln125"> </a>
<a name="ln126">// Extended msg state, currently used for external UIs with ext_messages</a>
<a name="ln127">static const char *msg_ext_kind = NULL;</a>
<a name="ln128">static Array msg_ext_chunks = ARRAY_DICT_INIT;</a>
<a name="ln129">static garray_T msg_ext_last_chunk = GA_INIT(sizeof(char), 40);</a>
<a name="ln130">static sattr_T msg_ext_last_attr = -1;</a>
<a name="ln131">static size_t msg_ext_cur_len = 0;</a>
<a name="ln132"> </a>
<a name="ln133">static bool msg_ext_overwrite = false;  ///&lt; will overwrite last message</a>
<a name="ln134">static int msg_ext_visible = 0;  ///&lt; number of messages currently visible</a>
<a name="ln135"> </a>
<a name="ln136">static bool msg_ext_history_visible = false;</a>
<a name="ln137"> </a>
<a name="ln138">/// Shouldn't clear message after leaving cmdline</a>
<a name="ln139">static bool msg_ext_keep_after_cmdline = false;</a>
<a name="ln140"> </a>
<a name="ln141">static int msg_grid_pos_at_flush = 0;</a>
<a name="ln142"> </a>
<a name="ln143">static void ui_ext_msg_set_pos(int row, bool scrolled)</a>
<a name="ln144">{</a>
<a name="ln145">  char buf[MAX_MCO + 1];</a>
<a name="ln146">  size_t size = (size_t)utf_char2bytes(curwin-&gt;w_p_fcs_chars.msgsep, buf);</a>
<a name="ln147">  buf[size] = '\0';</a>
<a name="ln148">  ui_call_msg_set_pos(msg_grid.handle, row, scrolled,</a>
<a name="ln149">                      (String){ .data = buf, .size = size });</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">void msg_grid_set_pos(int row, bool scrolled)</a>
<a name="ln153">{</a>
<a name="ln154">  if (!msg_grid.throttled) {</a>
<a name="ln155">    ui_ext_msg_set_pos(row, scrolled);</a>
<a name="ln156">    msg_grid_pos_at_flush = row;</a>
<a name="ln157">  }</a>
<a name="ln158">  msg_grid_pos = row;</a>
<a name="ln159">  if (msg_grid.chars) {</a>
<a name="ln160">    msg_grid_adj.row_offset = -row;</a>
<a name="ln161">  }</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">bool msg_use_grid(void)</a>
<a name="ln165">{</a>
<a name="ln166">  return default_grid.chars &amp;&amp; !ui_has(kUIMessages);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">void msg_grid_validate(void)</a>
<a name="ln170">{</a>
<a name="ln171">  grid_assign_handle(&amp;msg_grid);</a>
<a name="ln172">  bool should_alloc = msg_use_grid();</a>
<a name="ln173">  int max_rows = Rows - (int)p_ch;</a>
<a name="ln174">  if (should_alloc &amp;&amp; (msg_grid.rows != Rows || msg_grid.cols != Columns</a>
<a name="ln175">                       || !msg_grid.chars)) {</a>
<a name="ln176">    // TODO(bfredl): eventually should be set to &quot;invalid&quot;. I e all callers</a>
<a name="ln177">    // will use the grid including clear to EOS if necessary.</a>
<a name="ln178">    grid_alloc(&amp;msg_grid, Rows, Columns, false, true);</a>
<a name="ln179">    msg_grid.zindex = kZIndexMessages;</a>
<a name="ln180"> </a>
<a name="ln181">    xfree(msg_grid.dirty_col);</a>
<a name="ln182">    msg_grid.dirty_col = xcalloc((size_t)Rows, sizeof(*msg_grid.dirty_col));</a>
<a name="ln183"> </a>
<a name="ln184">    // Tricky: allow resize while pager or ex mode is active</a>
<a name="ln185">    int pos = (State &amp; MODE_ASKMORE) ? 0 : MAX(max_rows - msg_scrolled, 0);</a>
<a name="ln186">    msg_grid.throttled = false;  // don't throttle in 'cmdheight' area</a>
<a name="ln187">    msg_grid_set_pos(pos, msg_scrolled);</a>
<a name="ln188">    ui_comp_put_grid(&amp;msg_grid, pos, 0, msg_grid.rows, msg_grid.cols,</a>
<a name="ln189">                     false, true);</a>
<a name="ln190">    ui_call_grid_resize(msg_grid.handle, msg_grid.cols, msg_grid.rows);</a>
<a name="ln191"> </a>
<a name="ln192">    msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln193">    msg_grid.focusable = false;</a>
<a name="ln194">    msg_grid_adj.target = &amp;msg_grid;</a>
<a name="ln195">  } else if (!should_alloc &amp;&amp; msg_grid.chars) {</a>
<a name="ln196">    ui_comp_remove_grid(&amp;msg_grid);</a>
<a name="ln197">    grid_free(&amp;msg_grid);</a>
<a name="ln198">    XFREE_CLEAR(msg_grid.dirty_col);</a>
<a name="ln199">    ui_call_grid_destroy(msg_grid.handle);</a>
<a name="ln200">    msg_grid.throttled = false;</a>
<a name="ln201">    msg_grid_adj.row_offset = 0;</a>
<a name="ln202">    msg_grid_adj.target = &amp;default_grid;</a>
<a name="ln203">    redraw_cmdline = true;</a>
<a name="ln204">  } else if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; msg_grid_pos != max_rows) {</a>
<a name="ln205">    msg_grid_set_pos(max_rows, false);</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; cmdline_row &lt; msg_grid_pos) {</a>
<a name="ln209">    // TODO(bfredl): this should already be the case, but fails in some</a>
<a name="ln210">    // &quot;batched&quot; executions where compute_cmdrow() use stale positions or</a>
<a name="ln211">    // something.</a>
<a name="ln212">    cmdline_row = msg_grid_pos;</a>
<a name="ln213">  }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">/// Like msg() but keep it silent when 'verbosefile' is set.</a>
<a name="ln217">int verb_msg(const char *s)</a>
<a name="ln218">{</a>
<a name="ln219">  verbose_enter();</a>
<a name="ln220">  int n = msg_attr_keep(s, 0, false, false);</a>
<a name="ln221">  verbose_leave();</a>
<a name="ln222"> </a>
<a name="ln223">  return n;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/// Displays the string 's' on the status line</a>
<a name="ln227">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln228">///</a>
<a name="ln229">/// @return  true if wait_return() not called</a>
<a name="ln230">int msg(const char *s, const int attr)</a>
<a name="ln231">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln232">{</a>
<a name="ln233">  return msg_attr_keep(s, attr, false, false);</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/// Similar to msg_outtrans, but support newlines and tabs.</a>
<a name="ln237">void msg_multiline(const char *s, int attr, bool check_int, bool *need_clear)</a>
<a name="ln238">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln239">{</a>
<a name="ln240">  const char *next_spec = s;</a>
<a name="ln241"> </a>
<a name="ln242">  while (next_spec != NULL) {</a>
<a name="ln243">    if (check_int &amp;&amp; got_int) {</a>
<a name="ln244">      return;</a>
<a name="ln245">    }</a>
<a name="ln246">    next_spec = strpbrk(s, &quot;\t\n\r&quot;);</a>
<a name="ln247"> </a>
<a name="ln248">    if (next_spec != NULL) {</a>
<a name="ln249">      // Printing all char that are before the char found by strpbrk</a>
<a name="ln250">      msg_outtrans_len(s, (int)(next_spec - s), attr);</a>
<a name="ln251"> </a>
<a name="ln252">      if (*next_spec != TAB &amp;&amp; *need_clear) {</a>
<a name="ln253">        msg_clr_eos();</a>
<a name="ln254">        *need_clear = false;</a>
<a name="ln255">      }</a>
<a name="ln256">      msg_putchar_attr((uint8_t)(*next_spec), attr);</a>
<a name="ln257">      s = next_spec + 1;</a>
<a name="ln258">    }</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  // Print the rest of the message. We know there is no special</a>
<a name="ln262">  // character because strpbrk returned NULL</a>
<a name="ln263">  if (*s != NUL) {</a>
<a name="ln264">    msg_outtrans(s, attr);</a>
<a name="ln265">  }</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">void msg_multiattr(HlMessage hl_msg, const char *kind, bool history)</a>
<a name="ln269">{</a>
<a name="ln270">  no_wait_return++;</a>
<a name="ln271">  msg_start();</a>
<a name="ln272">  msg_clr_eos();</a>
<a name="ln273">  bool need_clear = false;</a>
<a name="ln274">  msg_ext_set_kind(kind);</a>
<a name="ln275">  for (uint32_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln276">    HlMessageChunk chunk = kv_A(hl_msg, i);</a>
<a name="ln277">    msg_multiline(chunk.text.data, chunk.attr, true, &amp;need_clear);</a>
<a name="ln278">  }</a>
<a name="ln279">  if (history &amp;&amp; kv_size(hl_msg)) {</a>
<a name="ln280">    add_msg_hist_multiattr(NULL, 0, 0, true, hl_msg);</a>
<a name="ln281">  }</a>
<a name="ln282">  no_wait_return--;</a>
<a name="ln283">  msg_end();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/// @param keep set keep_msg if it doesn't scroll</a>
<a name="ln287">bool msg_attr_keep(const char *s, int attr, bool keep, bool multiline)</a>
<a name="ln288">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln289">{</a>
<a name="ln290">  static int entered = 0;</a>
<a name="ln291">  int retval;</a>
<a name="ln292">  char *buf = NULL;</a>
<a name="ln293"> </a>
<a name="ln294">  if (keep &amp;&amp; multiline) {</a>
<a name="ln295">    // Not implemented. 'multiline' is only used by nvim-added messages,</a>
<a name="ln296">    // which should avoid 'keep' behavior (just show the message at</a>
<a name="ln297">    // the correct time already).</a>
<a name="ln298">    abort();</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  // Skip messages not match &quot;:filter pattern&quot;.</a>
<a name="ln302">  // Don't filter when there is an error.</a>
<a name="ln303">  if (!emsg_on_display &amp;&amp; message_filtered(s)) {</a>
<a name="ln304">    return true;</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  if (attr == 0) {</a>
<a name="ln308">    set_vim_var_string(VV_STATUSMSG, s, -1);</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // It is possible that displaying a messages causes a problem (e.g.,</a>
<a name="ln312">  // when redrawing the window), which causes another message, etc..    To</a>
<a name="ln313">  // break this loop, limit the recursiveness to 3 levels.</a>
<a name="ln314">  if (entered &gt;= 3) {</a>
<a name="ln315">    return true;</a>
<a name="ln316">  }</a>
<a name="ln317">  entered++;</a>
<a name="ln318"> </a>
<a name="ln319">  // Add message to history (unless it's a repeated kept message or a</a>
<a name="ln320">  // truncated message)</a>
<a name="ln321">  if (s != keep_msg</a>
<a name="ln322">      || (*s != '&lt;'</a>
<a name="ln323">          &amp;&amp; last_msg_hist != NULL</a>
<a name="ln324">          &amp;&amp; last_msg_hist-&gt;msg != NULL</a>
<a name="ln325">          &amp;&amp; strcmp(s, last_msg_hist-&gt;msg) != 0)) {</a>
<a name="ln326">    add_msg_hist(s, -1, attr, multiline);</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  // Truncate the message if needed.</a>
<a name="ln330">  msg_start();</a>
<a name="ln331">  buf = msg_strtrunc(s, false);</a>
<a name="ln332">  if (buf != NULL) {</a>
<a name="ln333">    s = buf;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  bool need_clear = true;</a>
<a name="ln337">  if (multiline) {</a>
<a name="ln338">    msg_multiline(s, attr, false, &amp;need_clear);</a>
<a name="ln339">  } else {</a>
<a name="ln340">    msg_outtrans(s, attr);</a>
<a name="ln341">  }</a>
<a name="ln342">  if (need_clear) {</a>
<a name="ln343">    msg_clr_eos();</a>
<a name="ln344">  }</a>
<a name="ln345">  retval = msg_end();</a>
<a name="ln346"> </a>
<a name="ln347">  if (keep &amp;&amp; retval &amp;&amp; vim_strsize(s) &lt; (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln348">    set_keep_msg(s, 0);</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  need_fileinfo = false;</a>
<a name="ln352"> </a>
<a name="ln353">  xfree(buf);</a>
<a name="ln354">  entered--;</a>
<a name="ln355">  return retval;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">/// Truncate a string such that it can be printed without causing a scroll.</a>
<a name="ln359">///</a>
<a name="ln360">/// @return  an allocated string or NULL when no truncating is done.</a>
<a name="ln361">///</a>
<a name="ln362">/// @param force  always truncate</a>
<a name="ln363">char *msg_strtrunc(const char *s, int force)</a>
<a name="ln364">{</a>
<a name="ln365">  char *buf = NULL;</a>
<a name="ln366"> </a>
<a name="ln367">  // May truncate message to avoid a hit-return prompt</a>
<a name="ln368">  if ((!msg_scroll &amp;&amp; !need_wait_return &amp;&amp; shortmess(SHM_TRUNCALL)</a>
<a name="ln369">       &amp;&amp; !exmode_active &amp;&amp; msg_silent == 0 &amp;&amp; !ui_has(kUIMessages))</a>
<a name="ln370">      || force) {</a>
<a name="ln371">    int room;</a>
<a name="ln372">    int len = vim_strsize(s);</a>
<a name="ln373">    if (msg_scrolled != 0) {</a>
<a name="ln374">      // Use all the columns.</a>
<a name="ln375">      room = (Rows - msg_row) * Columns - 1;</a>
<a name="ln376">    } else {</a>
<a name="ln377">      // Use up to 'showcmd' column.</a>
<a name="ln378">      room = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln379">    }</a>
<a name="ln380">    if (len &gt; room &amp;&amp; room &gt; 0) {</a>
<a name="ln381">      // may have up to 18 bytes per cell (6 per char, up to two</a>
<a name="ln382">      // composing chars)</a>
<a name="ln383">      len = (room + 2) * 18;</a>
<a name="ln384">      buf = xmalloc((size_t)len);</a>
<a name="ln385">      trunc_string(s, buf, room, len);</a>
<a name="ln386">    }</a>
<a name="ln387">  }</a>
<a name="ln388">  return buf;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/// Truncate a string &quot;s&quot; to &quot;buf&quot; with cell width &quot;room&quot;.</a>
<a name="ln392">/// &quot;s&quot; and &quot;buf&quot; may be equal.</a>
<a name="ln393">void trunc_string(const char *s, char *buf, int room_in, int buflen)</a>
<a name="ln394">{</a>
<a name="ln395">  int room = room_in - 3;  // &quot;...&quot; takes 3 chars</a>
<a name="ln396">  int half;</a>
<a name="ln397">  int len = 0;</a>
<a name="ln398">  int e;</a>
<a name="ln399">  int i;</a>
<a name="ln400">  int n;</a>
<a name="ln401"> </a>
<a name="ln402">  if (*s == NUL) {</a>
<a name="ln403">    if (buflen &gt; 0) {</a>
<a name="ln404">      *buf = NUL;</a>
<a name="ln405">    }</a>
<a name="ln406">    return;</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  if (room_in &lt; 3) {</a>
<a name="ln410">    room = 0;</a>
<a name="ln411">  }</a>
<a name="ln412">  half = room / 2;</a>
<a name="ln413"> </a>
<a name="ln414">  // First part: Start of the string.</a>
<a name="ln415">  for (e = 0; len &lt; half &amp;&amp; e &lt; buflen; e++) {</a>
<a name="ln416">    if (s[e] == NUL) {</a>
<a name="ln417">      // text fits without truncating!</a>
<a name="ln418">      buf[e] = NUL;</a>
<a name="ln419">      return;</a>
<a name="ln420">    }</a>
<a name="ln421">    n = ptr2cells(s + e);</a>
<a name="ln422">    if (len + n &gt; half) {</a>
<a name="ln423">      break;</a>
<a name="ln424">    }</a>
<a name="ln425">    len += n;</a>
<a name="ln426">    buf[e] = s[e];</a>
<a name="ln427">    for (n = utfc_ptr2len(s + e); --n &gt; 0;) {</a>
<a name="ln428">      if (++e == buflen) {</a>
<a name="ln429">        break;</a>
<a name="ln430">      }</a>
<a name="ln431">      buf[e] = s[e];</a>
<a name="ln432">    }</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  // Last part: End of the string.</a>
<a name="ln436">  half = i = (int)strlen(s);</a>
<a name="ln437">  while (true) {</a>
<a name="ln438">    do {</a>
<a name="ln439">      half = half - utf_head_off(s, s + half - 1) - 1;</a>
<a name="ln440">    } while (half &gt; 0 &amp;&amp; utf_iscomposing(utf_ptr2char(s + half)));</a>
<a name="ln441">    n = ptr2cells(s + half);</a>
<a name="ln442">    if (len + n &gt; room || half == 0) {</a>
<a name="ln443">      break;</a>
<a name="ln444">    }</a>
<a name="ln445">    len += n;</a>
<a name="ln446">    i = half;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (i &lt;= e + 3) {</a>
<a name="ln450">    // text fits without truncating</a>
<a name="ln451">    if (s != buf) {</a>
<a name="ln452">      len = (int)strlen(s);</a>
<a name="ln453">      if (len &gt;= buflen) {</a>
<a name="ln454">        len = buflen - 1;</a>
<a name="ln455">      }</a>
<a name="ln456">      len = len - e + 1;</a>
<a name="ln457">      if (len &lt; 1) {</a>
<a name="ln458">        buf[e - 1] = NUL;</a>
<a name="ln459">      } else {</a>
<a name="ln460">        memmove(buf + e, s + e, (size_t)len);</a>
<a name="ln461">      }</a>
<a name="ln462">    }</a>
<a name="ln463">  } else if (e + 3 &lt; buflen) {</a>
<a name="ln464">    // set the middle and copy the last part</a>
<a name="ln465">    memmove(buf + e, &quot;...&quot;, (size_t)3);</a>
<a name="ln466">    len = (int)strlen(s + i) + 1;</a>
<a name="ln467">    if (len &gt;= buflen - e - 3) {</a>
<a name="ln468">      len = buflen - e - 3 - 1;</a>
<a name="ln469">    }</a>
<a name="ln470">    memmove(buf + e + 3, s + i, (size_t)len);</a>
<a name="ln471">    buf[e + 3 + len - 1] = NUL;</a>
<a name="ln472">  } else {</a>
<a name="ln473">    // can't fit in the &quot;...&quot;, just truncate it</a>
<a name="ln474">    buf[e - 1] = NUL;</a>
<a name="ln475">  }</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">/// Shows a printf-style message with attributes.</a>
<a name="ln479">///</a>
<a name="ln480">/// Note: Caller must check the resulting string is shorter than IOSIZE!!!</a>
<a name="ln481">///</a>
<a name="ln482">/// @see semsg</a>
<a name="ln483">/// @see swmsg</a>
<a name="ln484">///</a>
<a name="ln485">/// @param s printf-style format message</a>
<a name="ln486">int smsg(int attr, const char *s, ...)</a>
<a name="ln487">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln488">{</a>
<a name="ln489">  va_list arglist;</a>
<a name="ln490"> </a>
<a name="ln491">  va_start(arglist, s);</a>
<a name="ln492">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln493">  va_end(arglist);</a>
<a name="ln494">  return msg(IObuff, attr);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497">int smsg_attr_keep(int attr, const char *s, ...)</a>
<a name="ln498">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln499">{</a>
<a name="ln500">  va_list arglist;</a>
<a name="ln501"> </a>
<a name="ln502">  va_start(arglist, s);</a>
<a name="ln503">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln504">  va_end(arglist);</a>
<a name="ln505">  return msg_attr_keep(IObuff, attr, true, false);</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">// Remember the last sourcing name/lnum used in an error message, so that it</a>
<a name="ln509">// isn't printed each time when it didn't change.</a>
<a name="ln510">static int last_sourcing_lnum = 0;</a>
<a name="ln511">static char *last_sourcing_name = NULL;</a>
<a name="ln512"> </a>
<a name="ln513">/// Reset the last used sourcing name/lnum.  Makes sure it is displayed again</a>
<a name="ln514">/// for the next error message;</a>
<a name="ln515">void reset_last_sourcing(void)</a>
<a name="ln516">{</a>
<a name="ln517">  XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln518">  last_sourcing_lnum = 0;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">/// @return  true if &quot;SOURCING_NAME&quot; differs from &quot;last_sourcing_name&quot;.</a>
<a name="ln522">static bool other_sourcing_name(void)</a>
<a name="ln523">{</a>
<a name="ln524">  if (SOURCING_NAME != NULL) {</a>
<a name="ln525">    if (last_sourcing_name != NULL) {</a>
<a name="ln526">      return strcmp(SOURCING_NAME, last_sourcing_name) != 0;</a>
<a name="ln527">    }</a>
<a name="ln528">    return true;</a>
<a name="ln529">  }</a>
<a name="ln530">  return false;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">/// Get the message about the source, as used for an error message</a>
<a name="ln534">///</a>
<a name="ln535">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln536">///                     message is to be given.</a>
<a name="ln537">static char *get_emsg_source(void)</a>
<a name="ln538">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln539">{</a>
<a name="ln540">  if (SOURCING_NAME != NULL &amp;&amp; other_sourcing_name()) {</a>
<a name="ln541">    char *sname = estack_sfile(ESTACK_NONE);</a>
<a name="ln542">    char *tofree = sname;</a>
<a name="ln543"> </a>
<a name="ln544">    if (sname == NULL) {</a>
<a name="ln545">      sname = SOURCING_NAME;</a>
<a name="ln546">    }</a>
<a name="ln547"> </a>
<a name="ln548">    const char *const p = _(&quot;Error detected while processing %s:&quot;);</a>
<a name="ln549">    const size_t buf_len = strlen(sname) + strlen(p) + 1;</a>
<a name="ln550">    char *const buf = xmalloc(buf_len);</a>
<a name="ln551">    snprintf(buf, buf_len, p, sname);</a>
<a name="ln552">    xfree(tofree);</a>
<a name="ln553">    return buf;</a>
<a name="ln554">  }</a>
<a name="ln555">  return NULL;</a>
<a name="ln556">}</a>
<a name="ln557"> </a>
<a name="ln558">/// Get the message about the source lnum, as used for an error message.</a>
<a name="ln559">///</a>
<a name="ln560">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln561">///                     message is to be given.</a>
<a name="ln562">static char *get_emsg_lnum(void)</a>
<a name="ln563">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln564">{</a>
<a name="ln565">  // lnum is 0 when executing a command from the command line</a>
<a name="ln566">  // argument, we don't want a line number then</a>
<a name="ln567">  if (SOURCING_NAME != NULL</a>
<a name="ln568">      &amp;&amp; (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)</a>
<a name="ln569">      &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln570">    const char *const p = _(&quot;line %4ld:&quot;);</a>
<a name="ln571">    const size_t buf_len = 20 + strlen(p);</a>
<a name="ln572">    char *const buf = xmalloc(buf_len);</a>
<a name="ln573">    snprintf(buf, buf_len, p, (long)SOURCING_LNUM);</a>
<a name="ln574">    return buf;</a>
<a name="ln575">  }</a>
<a name="ln576">  return NULL;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">/// Display name and line number for the source of an error.</a>
<a name="ln580">/// Remember the file name and line number, so that for the next error the info</a>
<a name="ln581">/// is only displayed if it changed.</a>
<a name="ln582">void msg_source(int attr)</a>
<a name="ln583">{</a>
<a name="ln584">  static bool recursive = false;</a>
<a name="ln585"> </a>
<a name="ln586">  // Bail out if something called here causes an error.</a>
<a name="ln587">  if (recursive) {</a>
<a name="ln588">    return;</a>
<a name="ln589">  }</a>
<a name="ln590">  recursive = true;</a>
<a name="ln591"> </a>
<a name="ln592">  no_wait_return++;</a>
<a name="ln593">  char *p = get_emsg_source();</a>
<a name="ln594">  if (p != NULL) {</a>
<a name="ln595">    msg_scroll = true;  // this will take more than one line</a>
<a name="ln596">    msg(p, attr);</a>
<a name="ln597">    xfree(p);</a>
<a name="ln598">  }</a>
<a name="ln599">  p = get_emsg_lnum();</a>
<a name="ln600">  if (p != NULL) {</a>
<a name="ln601">    msg(p, HL_ATTR(HLF_N));</a>
<a name="ln602">    xfree(p);</a>
<a name="ln603">    last_sourcing_lnum = SOURCING_LNUM;      // only once for each line</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  // remember the last sourcing name printed, also when it's empty</a>
<a name="ln607">  if (SOURCING_NAME == NULL || other_sourcing_name()) {</a>
<a name="ln608">    XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln609">    if (SOURCING_NAME != NULL) {</a>
<a name="ln610">      last_sourcing_name = xstrdup(SOURCING_NAME);</a>
<a name="ln611">    }</a>
<a name="ln612">  }</a>
<a name="ln613">  no_wait_return--;</a>
<a name="ln614"> </a>
<a name="ln615">  recursive = false;</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">/// @return  true if not giving error messages right now:</a>
<a name="ln619">///            If &quot;emsg_off&quot; is set: no error messages at the moment.</a>
<a name="ln620">///            If &quot;msg&quot; is in 'debug': do error message but without side effects.</a>
<a name="ln621">///            If &quot;emsg_skip&quot; is set: never do error messages.</a>
<a name="ln622">int emsg_not_now(void)</a>
<a name="ln623">{</a>
<a name="ln624">  if ((emsg_off &gt; 0 &amp;&amp; vim_strchr(p_debug, 'm') == NULL</a>
<a name="ln625">       &amp;&amp; vim_strchr(p_debug, 't') == NULL)</a>
<a name="ln626">      || emsg_skip &gt; 0) {</a>
<a name="ln627">    return true;</a>
<a name="ln628">  }</a>
<a name="ln629">  return false;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">bool emsg_multiline(const char *s, bool multiline)</a>
<a name="ln633">{</a>
<a name="ln634">  int attr;</a>
<a name="ln635">  bool ignore = false;</a>
<a name="ln636"> </a>
<a name="ln637">  // Skip this if not giving error messages at the moment.</a>
<a name="ln638">  if (emsg_not_now()) {</a>
<a name="ln639">    return true;</a>
<a name="ln640">  }</a>
<a name="ln641"> </a>
<a name="ln642">  called_emsg++;</a>
<a name="ln643"> </a>
<a name="ln644">  // If &quot;emsg_severe&quot; is true: When an error exception is to be thrown,</a>
<a name="ln645">  // prefer this message over previous messages for the same command.</a>
<a name="ln646">  bool severe = emsg_severe;</a>
<a name="ln647">  emsg_severe = false;</a>
<a name="ln648"> </a>
<a name="ln649">  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {</a>
<a name="ln650">    // Cause a throw of an error exception if appropriate.  Don't display</a>
<a name="ln651">    // the error message in this case.  (If no matching catch clause will</a>
<a name="ln652">    // be found, the message will be displayed later on.)  &quot;ignore&quot; is set</a>
<a name="ln653">    // when the message should be ignored completely (used for the</a>
<a name="ln654">    // interrupt message).</a>
<a name="ln655">    if (cause_errthrow(s, multiline, severe, &amp;ignore)) {</a>
<a name="ln656">      if (!ignore) {</a>
<a name="ln657">        did_emsg++;</a>
<a name="ln658">      }</a>
<a name="ln659">      return true;</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    if (in_assert_fails &amp;&amp; emsg_assert_fails_msg == NULL) {</a>
<a name="ln663">      emsg_assert_fails_msg = xstrdup(s);</a>
<a name="ln664">      emsg_assert_fails_lnum = SOURCING_LNUM;</a>
<a name="ln665">      xfree(emsg_assert_fails_context);</a>
<a name="ln666">      emsg_assert_fails_context = xstrdup(SOURCING_NAME == NULL ? &quot;&quot; : SOURCING_NAME);</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    // set &quot;v:errmsg&quot;, also when using &quot;:silent! cmd&quot;</a>
<a name="ln670">    set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln671"> </a>
<a name="ln672">    // When using &quot;:silent! cmd&quot; ignore error messages.</a>
<a name="ln673">    // But do write it to the redirection file.</a>
<a name="ln674">    if (emsg_silent != 0) {</a>
<a name="ln675">      if (!emsg_noredir) {</a>
<a name="ln676">        msg_start();</a>
<a name="ln677">        char *p = get_emsg_source();</a>
<a name="ln678">        if (p != NULL) {</a>
<a name="ln679">          const size_t p_len = strlen(p);</a>
<a name="ln680">          p[p_len] = '\n';</a>
<a name="ln681">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln682">          xfree(p);</a>
<a name="ln683">        }</a>
<a name="ln684">        p = get_emsg_lnum();</a>
<a name="ln685">        if (p != NULL) {</a>
<a name="ln686">          const size_t p_len = strlen(p);</a>
<a name="ln687">          p[p_len] = '\n';</a>
<a name="ln688">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln689">          xfree(p);</a>
<a name="ln690">        }</a>
<a name="ln691">        redir_write(s, (ptrdiff_t)strlen(s));</a>
<a name="ln692">      }</a>
<a name="ln693"> </a>
<a name="ln694">      // Log (silent) errors as debug messages.</a>
<a name="ln695">      if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln696">        DLOG(&quot;(:silent) %s (%s (line %ld))&quot;,</a>
<a name="ln697">             s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln698">      } else {</a>
<a name="ln699">        DLOG(&quot;(:silent) %s&quot;, s);</a>
<a name="ln700">      }</a>
<a name="ln701"> </a>
<a name="ln702">      return true;</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    // Log editor errors as INFO.</a>
<a name="ln706">    if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln707">      ILOG(&quot;%s (%s (line %ld))&quot;, s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln708">    } else {</a>
<a name="ln709">      ILOG(&quot;%s&quot;, s);</a>
<a name="ln710">    }</a>
<a name="ln711"> </a>
<a name="ln712">    ex_exitval = 1;</a>
<a name="ln713"> </a>
<a name="ln714">    // Reset msg_silent, an error causes messages to be switched back on.</a>
<a name="ln715">    msg_silent = 0;</a>
<a name="ln716">    cmd_silent = false;</a>
<a name="ln717"> </a>
<a name="ln718">    if (global_busy) {        // break :global command</a>
<a name="ln719">      global_busy++;</a>
<a name="ln720">    }</a>
<a name="ln721"> </a>
<a name="ln722">    if (p_eb) {</a>
<a name="ln723">      beep_flush();           // also includes flush_buffers()</a>
<a name="ln724">    } else {</a>
<a name="ln725">      flush_buffers(FLUSH_MINIMAL);  // flush internal buffers</a>
<a name="ln726">    }</a>
<a name="ln727">    did_emsg++;               // flag for DoOneCmd()</a>
<a name="ln728">  }</a>
<a name="ln729"> </a>
<a name="ln730">  emsg_on_display = true;     // remember there is an error message</a>
<a name="ln731">  attr = HL_ATTR(HLF_E);      // set highlight mode for error messages</a>
<a name="ln732">  if (msg_scrolled != 0) {</a>
<a name="ln733">    need_wait_return = true;  // needed in case emsg() is called after</a>
<a name="ln734">  }                           // wait_return() has reset need_wait_return</a>
<a name="ln735">                              // and a redraw is expected because</a>
<a name="ln736">                              // msg_scrolled is non-zero</a>
<a name="ln737">  if (msg_ext_kind == NULL) {</a>
<a name="ln738">    msg_ext_set_kind(&quot;emsg&quot;);</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  // Display name and line number for the source of the error.</a>
<a name="ln742">  msg_scroll = true;</a>
<a name="ln743">  msg_source(attr);</a>
<a name="ln744"> </a>
<a name="ln745">  // Display the error message itself.</a>
<a name="ln746">  msg_nowait = false;  // Wait for this msg.</a>
<a name="ln747">  return msg_attr_keep(s, attr, false, multiline);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/// emsg() - display an error message</a>
<a name="ln751">///</a>
<a name="ln752">/// Rings the bell, if appropriate, and calls message() to do the real work</a>
<a name="ln753">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln754">///</a>
<a name="ln755">/// @return true if wait_return() not called</a>
<a name="ln756">bool emsg(const char *s)</a>
<a name="ln757">{</a>
<a name="ln758">  return emsg_multiline(s, false);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">void emsg_invreg(int name)</a>
<a name="ln762">{</a>
<a name="ln763">  semsg(_(&quot;E354: Invalid register name: '%s'&quot;), transchar_buf(NULL, name));</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">/// Print an error message with unknown number of arguments</a>
<a name="ln767">///</a>
<a name="ln768">/// @return whether the message was displayed</a>
<a name="ln769">bool semsg(const char *const fmt, ...)</a>
<a name="ln770">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln771">{</a>
<a name="ln772">  bool ret;</a>
<a name="ln773"> </a>
<a name="ln774">  va_list ap;</a>
<a name="ln775">  va_start(ap, fmt);</a>
<a name="ln776">  ret = semsgv(fmt, ap);</a>
<a name="ln777">  va_end(ap);</a>
<a name="ln778"> </a>
<a name="ln779">  return ret;</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">#define MULTILINE_BUFSIZE 8192</a>
<a name="ln783"> </a>
<a name="ln784">bool semsg_multiline(const char *const fmt, ...)</a>
<a name="ln785">{</a>
<a name="ln786">  bool ret;</a>
<a name="ln787">  va_list ap;</a>
<a name="ln788"> </a>
<a name="ln789">  static char errbuf[MULTILINE_BUFSIZE];</a>
<a name="ln790">  if (emsg_not_now()) {</a>
<a name="ln791">    return true;</a>
<a name="ln792">  }</a>
<a name="ln793"> </a>
<a name="ln794">  va_start(ap, fmt);</a>
<a name="ln795">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln796">  va_end(ap);</a>
<a name="ln797"> </a>
<a name="ln798">  ret = emsg_multiline(errbuf, true);</a>
<a name="ln799"> </a>
<a name="ln800">  return ret;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/// Print an error message with unknown number of arguments</a>
<a name="ln804">static bool semsgv(const char *fmt, va_list ap)</a>
<a name="ln805">{</a>
<a name="ln806">  static char errbuf[IOSIZE];</a>
<a name="ln807">  if (emsg_not_now()) {</a>
<a name="ln808">    return true;</a>
<a name="ln809">  }</a>
<a name="ln810"> </a>
<a name="ln811">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln812"> </a>
<a name="ln813">  return emsg(errbuf);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">/// Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln817">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln818">/// detected when fuzzing vim.</a>
<a name="ln819">void iemsg(const char *s)</a>
<a name="ln820">{</a>
<a name="ln821">  if (emsg_not_now()) {</a>
<a name="ln822">    return;</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  emsg(s);</a>
<a name="ln826">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln827">  set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln828">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln829">  ui_flush();</a>
<a name="ln830">  abort();</a>
<a name="ln831">#endif</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">/// Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln835">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln836">/// detected when fuzzing vim.</a>
<a name="ln837">void siemsg(const char *s, ...)</a>
<a name="ln838">{</a>
<a name="ln839">  if (emsg_not_now()) {</a>
<a name="ln840">    return;</a>
<a name="ln841">  }</a>
<a name="ln842"> </a>
<a name="ln843">  va_list ap;</a>
<a name="ln844">  va_start(ap, s);</a>
<a name="ln845">  (void)semsgv(s, ap);</a>
<a name="ln846">  va_end(ap);</a>
<a name="ln847">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln848">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln849">  ui_flush();</a>
<a name="ln850">  abort();</a>
<a name="ln851">#endif</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">/// Give an &quot;Internal error&quot; message.</a>
<a name="ln855">void internal_error(const char *where)</a>
<a name="ln856">{</a>
<a name="ln857">  siemsg(_(e_intern2), where);</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">static void msg_semsg_event(void **argv)</a>
<a name="ln861">{</a>
<a name="ln862">  char *s = argv[0];</a>
<a name="ln863">  (void)emsg(s);</a>
<a name="ln864">  xfree(s);</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">void msg_schedule_semsg(const char *const fmt, ...)</a>
<a name="ln868">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln869">{</a>
<a name="ln870">  va_list ap;</a>
<a name="ln871">  va_start(ap, fmt);</a>
<a name="ln872">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln873">  va_end(ap);</a>
<a name="ln874"> </a>
<a name="ln875">  char *s = xstrdup(IObuff);</a>
<a name="ln876">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_event, 1, s));</a>
<a name="ln877">}</a>
<a name="ln878"> </a>
<a name="ln879">static void msg_semsg_multiline_event(void **argv)</a>
<a name="ln880">{</a>
<a name="ln881">  char *s = argv[0];</a>
<a name="ln882">  (void)emsg_multiline(s, true);</a>
<a name="ln883">  xfree(s);</a>
<a name="ln884">}</a>
<a name="ln885"> </a>
<a name="ln886">void msg_schedule_semsg_multiline(const char *const fmt, ...)</a>
<a name="ln887">{</a>
<a name="ln888">  va_list ap;</a>
<a name="ln889">  va_start(ap, fmt);</a>
<a name="ln890">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln891">  va_end(ap);</a>
<a name="ln892"> </a>
<a name="ln893">  char *s = xstrdup(IObuff);</a>
<a name="ln894">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_multiline_event, 1, s));</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">/// Like msg(), but truncate to a single line if p_shm contains 't', or when</a>
<a name="ln898">/// &quot;force&quot; is true.  This truncates in another way as for normal messages.</a>
<a name="ln899">/// Careful: The string may be changed by msg_may_trunc()!</a>
<a name="ln900">///</a>
<a name="ln901">/// @return  a pointer to the printed message, if wait_return() not called.</a>
<a name="ln902">char *msg_trunc(char *s, bool force, int attr)</a>
<a name="ln903">{</a>
<a name="ln904">  int n;</a>
<a name="ln905"> </a>
<a name="ln906">  // Add message to history before truncating.</a>
<a name="ln907">  add_msg_hist(s, -1, attr, false);</a>
<a name="ln908"> </a>
<a name="ln909">  char *ts = msg_may_trunc(force, s);</a>
<a name="ln910"> </a>
<a name="ln911">  msg_hist_off = true;</a>
<a name="ln912">  n = msg(ts, attr);</a>
<a name="ln913">  msg_hist_off = false;</a>
<a name="ln914"> </a>
<a name="ln915">  if (n) {</a>
<a name="ln916">    return ts;</a>
<a name="ln917">  }</a>
<a name="ln918">  return NULL;</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">/// Check if message &quot;s&quot; should be truncated at the start (for filenames).</a>
<a name="ln922">///</a>
<a name="ln923">/// @return  a pointer to where the truncated message starts.</a>
<a name="ln924">///</a>
<a name="ln925">/// @note: May change the message by replacing a character with '&lt;'.</a>
<a name="ln926">char *msg_may_trunc(bool force, char *s)</a>
<a name="ln927">{</a>
<a name="ln928">  if (ui_has(kUIMessages)) {</a>
<a name="ln929">    return s;</a>
<a name="ln930">  }</a>
<a name="ln931"> </a>
<a name="ln932">  int room = (Rows - cmdline_row - 1) * Columns + sc_col - 1;</a>
<a name="ln933">  if ((force || (shortmess(SHM_TRUNC) &amp;&amp; !exmode_active))</a>
<a name="ln934">      &amp;&amp; (int)strlen(s) - room &gt; 0) {</a>
<a name="ln935">    int size = vim_strsize(s);</a>
<a name="ln936"> </a>
<a name="ln937">    // There may be room anyway when there are multibyte chars.</a>
<a name="ln938">    if (size &lt;= room) {</a>
<a name="ln939">      return s;</a>
<a name="ln940">    }</a>
<a name="ln941">    int n;</a>
<a name="ln942">    for (n = 0; size &gt;= room;) {</a>
<a name="ln943">      size -= utf_ptr2cells(s + n);</a>
<a name="ln944">      n += utfc_ptr2len(s + n);</a>
<a name="ln945">    }</a>
<a name="ln946">    n--;</a>
<a name="ln947">    s += n;</a>
<a name="ln948">    *s = '&lt;';</a>
<a name="ln949">  }</a>
<a name="ln950">  return s;</a>
<a name="ln951">}</a>
<a name="ln952"> </a>
<a name="ln953">void hl_msg_free(HlMessage hl_msg)</a>
<a name="ln954">{</a>
<a name="ln955">  for (size_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln956">    xfree(kv_A(hl_msg, i).text.data);</a>
<a name="ln957">  }</a>
<a name="ln958">  kv_destroy(hl_msg);</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">/// @param[in]  len  Length of s or -1.</a>
<a name="ln962">static void add_msg_hist(const char *s, int len, int attr, bool multiline)</a>
<a name="ln963">{</a>
<a name="ln964">  add_msg_hist_multiattr(s, len, attr, multiline, (HlMessage)KV_INITIAL_VALUE);</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">static void add_msg_hist_multiattr(const char *s, int len, int attr, bool multiline,</a>
<a name="ln968">                                   HlMessage multiattr)</a>
<a name="ln969">{</a>
<a name="ln970">  if (msg_hist_off || msg_silent != 0) {</a>
<a name="ln971">    hl_msg_free(multiattr);</a>
<a name="ln972">    return;</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  // Don't let the message history get too big</a>
<a name="ln976">  while (msg_hist_len &gt; MAX_MSG_HIST_LEN) {</a>
<a name="ln977">    (void)delete_first_msg();</a>
<a name="ln978">  }</a>
<a name="ln979"> </a>
<a name="ln980">  // allocate an entry and add the message at the end of the history</a>
<a name="ln981">  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));</a>
<a name="ln982">  if (s) {</a>
<a name="ln983">    if (len &lt; 0) {</a>
<a name="ln984">      len = (int)strlen(s);</a>
<a name="ln985">    }</a>
<a name="ln986">    // remove leading and trailing newlines</a>
<a name="ln987">    while (len &gt; 0 &amp;&amp; *s == '\n') {</a>
<a name="ln988">      s++;</a>
<a name="ln989">      len--;</a>
<a name="ln990">    }</a>
<a name="ln991">    while (len &gt; 0 &amp;&amp; s[len - 1] == '\n') {</a>
<a name="ln992">      len--;</a>
<a name="ln993">    }</a>
<a name="ln994">    p-&gt;msg = xmemdupz(s, (size_t)len);</a>
<a name="ln995">  } else {</a>
<a name="ln996">    p-&gt;msg = NULL;</a>
<a name="ln997">  }</a>
<a name="ln998">  p-&gt;next = NULL;</a>
<a name="ln999">  p-&gt;attr = attr;</a>
<a name="ln1000">  p-&gt;multiline = multiline;</a>
<a name="ln1001">  p-&gt;multiattr = multiattr;</a>
<a name="ln1002">  p-&gt;kind = msg_ext_kind;</a>
<a name="ln1003">  if (last_msg_hist != NULL) {</a>
<a name="ln1004">    last_msg_hist-&gt;next = p;</a>
<a name="ln1005">  }</a>
<a name="ln1006">  last_msg_hist = p;</a>
<a name="ln1007">  if (first_msg_hist == NULL) {</a>
<a name="ln1008">    first_msg_hist = last_msg_hist;</a>
<a name="ln1009">  }</a>
<a name="ln1010">  msg_hist_len++;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">/// Delete the first (oldest) message from the history.</a>
<a name="ln1014">///</a>
<a name="ln1015">/// @return  FAIL if there are no messages.</a>
<a name="ln1016">int delete_first_msg(void)</a>
<a name="ln1017">{</a>
<a name="ln1018">  struct msg_hist *p;</a>
<a name="ln1019"> </a>
<a name="ln1020">  if (msg_hist_len &lt;= 0) {</a>
<a name="ln1021">    return FAIL;</a>
<a name="ln1022">  }</a>
<a name="ln1023">  p = first_msg_hist;</a>
<a name="ln1024">  first_msg_hist = p-&gt;next;</a>
<a name="ln1025">  if (first_msg_hist == NULL) {  // history is becoming empty</a>
<a name="ln1026">    assert(msg_hist_len == 1);</a>
<a name="ln1027">    last_msg_hist = NULL;</a>
<a name="ln1028">  }</a>
<a name="ln1029">  xfree(p-&gt;msg);</a>
<a name="ln1030">  hl_msg_free(p-&gt;multiattr);</a>
<a name="ln1031">  xfree(p);</a>
<a name="ln1032">  msg_hist_len--;</a>
<a name="ln1033">  return OK;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036">/// :messages command implementation</a>
<a name="ln1037">void ex_messages(exarg_T *eap)</a>
<a name="ln1038">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1039">{</a>
<a name="ln1040">  struct msg_hist *p;</a>
<a name="ln1041"> </a>
<a name="ln1042">  if (strcmp(eap-&gt;arg, &quot;clear&quot;) == 0) {</a>
<a name="ln1043">    int keep = eap-&gt;addr_count == 0 ? 0 : eap-&gt;line2;</a>
<a name="ln1044"> </a>
<a name="ln1045">    while (msg_hist_len &gt; keep) {</a>
<a name="ln1046">      (void)delete_first_msg();</a>
<a name="ln1047">    }</a>
<a name="ln1048">    return;</a>
<a name="ln1049">  }</a>
<a name="ln1050"> </a>
<a name="ln1051">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1052">    emsg(_(e_invarg));</a>
<a name="ln1053">    return;</a>
<a name="ln1054">  }</a>
<a name="ln1055"> </a>
<a name="ln1056">  p = first_msg_hist;</a>
<a name="ln1057"> </a>
<a name="ln1058">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln1059">    int c = 0;</a>
<a name="ln1060">    // Count total messages</a>
<a name="ln1061">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1062">      c++;</a>
<a name="ln1063">    }</a>
<a name="ln1064"> </a>
<a name="ln1065">    c -= eap-&gt;line2;</a>
<a name="ln1066"> </a>
<a name="ln1067">    // Skip without number of messages specified</a>
<a name="ln1068">    for (p = first_msg_hist; p != NULL &amp;&amp; !got_int &amp;&amp; c &gt; 0; p = p-&gt;next, c--) {}</a>
<a name="ln1069">  }</a>
<a name="ln1070"> </a>
<a name="ln1071">  // Display what was not skipped.</a>
<a name="ln1072">  if (ui_has(kUIMessages)) {</a>
<a name="ln1073">    if (msg_silent) {</a>
<a name="ln1074">      return;</a>
<a name="ln1075">    }</a>
<a name="ln1076">    Array entries = ARRAY_DICT_INIT;</a>
<a name="ln1077">    for (; p != NULL; p = p-&gt;next) {</a>
<a name="ln1078">      if (kv_size(p-&gt;multiattr) || (p-&gt;msg &amp;&amp; p-&gt;msg[0])) {</a>
<a name="ln1079">        Array entry = ARRAY_DICT_INIT;</a>
<a name="ln1080">        ADD(entry, CSTR_TO_OBJ(p-&gt;kind));</a>
<a name="ln1081">        Array content = ARRAY_DICT_INIT;</a>
<a name="ln1082">        if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1083">          for (uint32_t i = 0; i &lt; kv_size(p-&gt;multiattr); i++) {</a>
<a name="ln1084">            HlMessageChunk chunk = kv_A(p-&gt;multiattr, i);</a>
<a name="ln1085">            Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1086">            ADD(content_entry, INTEGER_OBJ(chunk.attr));</a>
<a name="ln1087">            ADD(content_entry, STRING_OBJ(copy_string(chunk.text, NULL)));</a>
<a name="ln1088">            ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1089">          }</a>
<a name="ln1090">        } else if (p-&gt;msg &amp;&amp; p-&gt;msg[0]) {</a>
<a name="ln1091">          Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1092">          ADD(content_entry, INTEGER_OBJ(p-&gt;attr));</a>
<a name="ln1093">          ADD(content_entry, CSTR_TO_OBJ(p-&gt;msg));</a>
<a name="ln1094">          ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1095">        }</a>
<a name="ln1096">        ADD(entry, ARRAY_OBJ(content));</a>
<a name="ln1097">        ADD(entries, ARRAY_OBJ(entry));</a>
<a name="ln1098">      }</a>
<a name="ln1099">    }</a>
<a name="ln1100">    ui_call_msg_history_show(entries);</a>
<a name="ln1101">    api_free_array(entries);</a>
<a name="ln1102">    msg_ext_history_visible = true;</a>
<a name="ln1103">    wait_return(false);</a>
<a name="ln1104">  } else {</a>
<a name="ln1105">    msg_hist_off = true;</a>
<a name="ln1106">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1107">      if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1108">        msg_multiattr(p-&gt;multiattr, p-&gt;kind, false);</a>
<a name="ln1109">      } else if (p-&gt;msg != NULL) {</a>
<a name="ln1110">        msg_attr_keep(p-&gt;msg, p-&gt;attr, false, p-&gt;multiline);</a>
<a name="ln1111">      }</a>
<a name="ln1112">    }</a>
<a name="ln1113">    msg_hist_off = false;</a>
<a name="ln1114">  }</a>
<a name="ln1115">}</a>
<a name="ln1116"> </a>
<a name="ln1117">/// Call this after prompting the user.  This will avoid a hit-return message</a>
<a name="ln1118">/// and a delay.</a>
<a name="ln1119">void msg_end_prompt(void)</a>
<a name="ln1120">{</a>
<a name="ln1121">  msg_ext_clear_later();</a>
<a name="ln1122">  need_wait_return = false;</a>
<a name="ln1123">  emsg_on_display = false;</a>
<a name="ln1124">  cmdline_row = msg_row;</a>
<a name="ln1125">  msg_col = 0;</a>
<a name="ln1126">  msg_clr_eos();</a>
<a name="ln1127">  lines_left = -1;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">/// Wait for the user to hit a key (normally Enter)</a>
<a name="ln1131">///</a>
<a name="ln1132">/// @param redraw  if true, redraw the entire screen UPD_NOT_VALID</a>
<a name="ln1133">///                if false, do a normal redraw</a>
<a name="ln1134">///                if -1, don't redraw at all</a>
<a name="ln1135">void wait_return(int redraw)</a>
<a name="ln1136">{</a>
<a name="ln1137">  int c;</a>
<a name="ln1138">  int oldState;</a>
<a name="ln1139">  int tmpState;</a>
<a name="ln1140">  int had_got_int;</a>
<a name="ln1141">  FILE *save_scriptout;</a>
<a name="ln1142"> </a>
<a name="ln1143">  if (redraw == true) {</a>
<a name="ln1144">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln1145">  }</a>
<a name="ln1146"> </a>
<a name="ln1147">  // If using &quot;:silent cmd&quot;, don't wait for a return.  Also don't set</a>
<a name="ln1148">  // need_wait_return to do it later.</a>
<a name="ln1149">  if (msg_silent != 0) {</a>
<a name="ln1150">    return;</a>
<a name="ln1151">  }</a>
<a name="ln1152"> </a>
<a name="ln1153">  if (headless_mode &amp;&amp; !ui_active()) {</a>
<a name="ln1154">    return;</a>
<a name="ln1155">  }</a>
<a name="ln1156"> </a>
<a name="ln1157">  // When inside vgetc(), we can't wait for a typed character at all.</a>
<a name="ln1158">  // With the global command (and some others) we only need one return at</a>
<a name="ln1159">  // the end. Adjust cmdline_row to avoid the next message overwriting the</a>
<a name="ln1160">  // last one.</a>
<a name="ln1161">  if (vgetc_busy &gt; 0) {</a>
<a name="ln1162">    return;</a>
<a name="ln1163">  }</a>
<a name="ln1164">  need_wait_return = true;</a>
<a name="ln1165">  if (no_wait_return) {</a>
<a name="ln1166">    if (!exmode_active) {</a>
<a name="ln1167">      cmdline_row = msg_row;</a>
<a name="ln1168">    }</a>
<a name="ln1169">    return;</a>
<a name="ln1170">  }</a>
<a name="ln1171"> </a>
<a name="ln1172">  redir_off = true;             // don't redirect this message</a>
<a name="ln1173">  oldState = State;</a>
<a name="ln1174">  if (quit_more) {</a>
<a name="ln1175">    c = CAR;                    // just pretend CR was hit</a>
<a name="ln1176">    quit_more = false;</a>
<a name="ln1177">    got_int = false;</a>
<a name="ln1178">  } else if (exmode_active) {</a>
<a name="ln1179">    msg_puts(&quot; &quot;);              // make sure the cursor is on the right line</a>
<a name="ln1180">    c = CAR;                    // no need for a return in ex mode</a>
<a name="ln1181">    got_int = false;</a>
<a name="ln1182">  } else {</a>
<a name="ln1183">    State = MODE_HITRETURN;</a>
<a name="ln1184">    setmouse();</a>
<a name="ln1185">    cmdline_row = msg_row;</a>
<a name="ln1186">    // Avoid the sequence that the user types &quot;:&quot; at the hit-return prompt</a>
<a name="ln1187">    // to start an Ex command, but the file-changed dialog gets in the</a>
<a name="ln1188">    // way.</a>
<a name="ln1189">    if (need_check_timestamps) {</a>
<a name="ln1190">      check_timestamps(false);</a>
<a name="ln1191">    }</a>
<a name="ln1192"> </a>
<a name="ln1193">    hit_return_msg();</a>
<a name="ln1194"> </a>
<a name="ln1195">    do {</a>
<a name="ln1196">      // Remember &quot;got_int&quot;, if it is set vgetc() probably returns a</a>
<a name="ln1197">      // CTRL-C, but we need to loop then.</a>
<a name="ln1198">      had_got_int = got_int;</a>
<a name="ln1199"> </a>
<a name="ln1200">      // Don't do mappings here, we put the character back in the</a>
<a name="ln1201">      // typeahead buffer.</a>
<a name="ln1202">      no_mapping++;</a>
<a name="ln1203">      allow_keys++;</a>
<a name="ln1204"> </a>
<a name="ln1205">      // Temporarily disable Recording. If Recording is active, the</a>
<a name="ln1206">      // character will be recorded later, since it will be added to the</a>
<a name="ln1207">      // typebuf after the loop</a>
<a name="ln1208">      const int save_reg_recording = reg_recording;</a>
<a name="ln1209">      save_scriptout = scriptout;</a>
<a name="ln1210">      reg_recording = 0;</a>
<a name="ln1211">      scriptout = NULL;</a>
<a name="ln1212">      c = safe_vgetc();</a>
<a name="ln1213">      if (had_got_int &amp;&amp; !global_busy) {</a>
<a name="ln1214">        got_int = false;</a>
<a name="ln1215">      }</a>
<a name="ln1216">      no_mapping--;</a>
<a name="ln1217">      allow_keys--;</a>
<a name="ln1218">      reg_recording = save_reg_recording;</a>
<a name="ln1219">      scriptout = save_scriptout;</a>
<a name="ln1220"> </a>
<a name="ln1221">      // Allow scrolling back in the messages.</a>
<a name="ln1222">      // Also accept scroll-down commands when messages fill the screen,</a>
<a name="ln1223">      // to avoid that typing one 'j' too many makes the messages</a>
<a name="ln1224">      // disappear.</a>
<a name="ln1225">      if (p_more) {</a>
<a name="ln1226">        if (c == 'b' || c == 'k' || c == 'u' || c == 'g'</a>
<a name="ln1227">            || c == K_UP || c == K_PAGEUP) {</a>
<a name="ln1228">          if (msg_scrolled &gt; Rows) {</a>
<a name="ln1229">            // scroll back to show older messages</a>
<a name="ln1230">            do_more_prompt(c);</a>
<a name="ln1231">          } else {</a>
<a name="ln1232">            msg_didout = false;</a>
<a name="ln1233">            c = K_IGNORE;</a>
<a name="ln1234">            msg_col =</a>
<a name="ln1235">              cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1236">              0;</a>
<a name="ln1237">          }</a>
<a name="ln1238">          if (quit_more) {</a>
<a name="ln1239">            c = CAR;                            // just pretend CR was hit</a>
<a name="ln1240">            quit_more = false;</a>
<a name="ln1241">            got_int = false;</a>
<a name="ln1242">          } else if (c != K_IGNORE) {</a>
<a name="ln1243">            c = K_IGNORE;</a>
<a name="ln1244">            hit_return_msg();</a>
<a name="ln1245">          }</a>
<a name="ln1246">        } else if (msg_scrolled &gt; Rows - 2</a>
<a name="ln1247">                   &amp;&amp; (c == 'j' || c == 'd' || c == 'f'</a>
<a name="ln1248">                       || c == K_DOWN || c == K_PAGEDOWN)) {</a>
<a name="ln1249">          c = K_IGNORE;</a>
<a name="ln1250">        }</a>
<a name="ln1251">      }</a>
<a name="ln1252">    } while ((had_got_int &amp;&amp; c == Ctrl_C)</a>
<a name="ln1253">             || c == K_IGNORE</a>
<a name="ln1254">             || c == K_LEFTDRAG || c == K_LEFTRELEASE</a>
<a name="ln1255">             || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE</a>
<a name="ln1256">             || c == K_RIGHTDRAG || c == K_RIGHTRELEASE</a>
<a name="ln1257">             || c == K_MOUSELEFT || c == K_MOUSERIGHT</a>
<a name="ln1258">             || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln1259">             || c == K_MOUSEMOVE);</a>
<a name="ln1260">    os_breakcheck();</a>
<a name="ln1261"> </a>
<a name="ln1262">    // Avoid that the mouse-up event causes visual mode to start.</a>
<a name="ln1263">    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE</a>
<a name="ln1264">        || c == K_X1MOUSE || c == K_X2MOUSE) {</a>
<a name="ln1265">      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);</a>
<a name="ln1266">    } else if (vim_strchr(&quot;\r\n &quot;, c) == NULL &amp;&amp; c != Ctrl_C) {</a>
<a name="ln1267">      // Put the character back in the typeahead buffer.  Don't use the</a>
<a name="ln1268">      // stuff buffer, because lmaps wouldn't work.</a>
<a name="ln1269">      ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1270">      do_redraw = true;             // need a redraw even though there is</a>
<a name="ln1271">                                    // typeahead</a>
<a name="ln1272">    }</a>
<a name="ln1273">  }</a>
<a name="ln1274">  redir_off = false;</a>
<a name="ln1275"> </a>
<a name="ln1276">  // If the user hits ':', '?' or '/' we get a command line from the next</a>
<a name="ln1277">  // line.</a>
<a name="ln1278">  if (c == ':' || c == '?' || c == '/') {</a>
<a name="ln1279">    if (!exmode_active) {</a>
<a name="ln1280">      cmdline_row = msg_row;</a>
<a name="ln1281">    }</a>
<a name="ln1282">    skip_redraw = true;  // skip redraw once</a>
<a name="ln1283">    do_redraw = false;</a>
<a name="ln1284">    msg_ext_keep_after_cmdline = true;</a>
<a name="ln1285">  }</a>
<a name="ln1286"> </a>
<a name="ln1287">  // If the screen size changed screen_resize() will redraw the screen.</a>
<a name="ln1288">  // Otherwise the screen is only redrawn if 'redraw' is set and no ':'</a>
<a name="ln1289">  // typed.</a>
<a name="ln1290">  tmpState = State;</a>
<a name="ln1291">  State = oldState;  // restore State before screen_resize()</a>
<a name="ln1292">  setmouse();</a>
<a name="ln1293">  msg_check();</a>
<a name="ln1294">  need_wait_return = false;</a>
<a name="ln1295">  did_wait_return = true;</a>
<a name="ln1296">  emsg_on_display = false;      // can delete error message now</a>
<a name="ln1297">  lines_left = -1;              // reset lines_left at next msg_start()</a>
<a name="ln1298">  reset_last_sourcing();</a>
<a name="ln1299">  if (keep_msg != NULL &amp;&amp; vim_strsize(keep_msg) &gt;=</a>
<a name="ln1300">      (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln1301">    XFREE_CLEAR(keep_msg);          // don't redisplay message, it's too long</a>
<a name="ln1302">  }</a>
<a name="ln1303"> </a>
<a name="ln1304">  if (tmpState == MODE_SETWSIZE) {       // got resize event while in vgetc()</a>
<a name="ln1305">    ui_refresh();</a>
<a name="ln1306">  } else if (!skip_redraw) {</a>
<a name="ln1307">    if (redraw == true || (msg_scrolled != 0 &amp;&amp; redraw != -1)) {</a>
<a name="ln1308">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln1309">    }</a>
<a name="ln1310">    if (ui_has(kUIMessages)) {</a>
<a name="ln1311">      msg_ext_clear(true);</a>
<a name="ln1312">    }</a>
<a name="ln1313">  }</a>
<a name="ln1314">}</a>
<a name="ln1315"> </a>
<a name="ln1316">/// Write the hit-return prompt.</a>
<a name="ln1317">static void hit_return_msg(void)</a>
<a name="ln1318">{</a>
<a name="ln1319">  int save_p_more = p_more;</a>
<a name="ln1320"> </a>
<a name="ln1321">  p_more = false;       // don't want to see this message when scrolling back</a>
<a name="ln1322">  if (msg_didout) {     // start on a new line</a>
<a name="ln1323">    msg_putchar('\n');</a>
<a name="ln1324">  }</a>
<a name="ln1325">  msg_ext_set_kind(&quot;return_prompt&quot;);</a>
<a name="ln1326">  if (got_int) {</a>
<a name="ln1327">    msg_puts(_(&quot;Interrupt: &quot;));</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">  msg_puts_attr(_(&quot;Press ENTER or type command to continue&quot;), HL_ATTR(HLF_R));</a>
<a name="ln1331">  if (!msg_use_printf()) {</a>
<a name="ln1332">    msg_clr_eos();</a>
<a name="ln1333">  }</a>
<a name="ln1334">  p_more = save_p_more;</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337">/// Set &quot;keep_msg&quot; to &quot;s&quot;.  Free the old value and check for NULL pointer.</a>
<a name="ln1338">void set_keep_msg(const char *s, int attr)</a>
<a name="ln1339">{</a>
<a name="ln1340">  xfree(keep_msg);</a>
<a name="ln1341">  if (s != NULL &amp;&amp; msg_silent == 0) {</a>
<a name="ln1342">    keep_msg = xstrdup(s);</a>
<a name="ln1343">  } else {</a>
<a name="ln1344">    keep_msg = NULL;</a>
<a name="ln1345">  }</a>
<a name="ln1346">  keep_msg_more = false;</a>
<a name="ln1347">  keep_msg_attr = attr;</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">/// Return true if printing messages should currently be done.</a>
<a name="ln1351">bool messaging(void)</a>
<a name="ln1352">{</a>
<a name="ln1353">  // TODO(bfredl): with general support for &quot;async&quot; messages with p_ch,</a>
<a name="ln1354">  // this should be re-enabled.</a>
<a name="ln1355">  return !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped) &amp;&amp; (p_ch &gt; 0 || ui_has(kUIMessages));</a>
<a name="ln1356">}</a>
<a name="ln1357"> </a>
<a name="ln1358">void msgmore(int n)</a>
<a name="ln1359">{</a>
<a name="ln1360">  long pn;</a>
<a name="ln1361"> </a>
<a name="ln1362">  if (global_busy           // no messages now, wait until global is finished</a>
<a name="ln1363">      || !messaging()) {      // 'lazyredraw' set, don't do messages now</a>
<a name="ln1364">    return;</a>
<a name="ln1365">  }</a>
<a name="ln1366"> </a>
<a name="ln1367">  // We don't want to overwrite another important message, but do overwrite</a>
<a name="ln1368">  // a previous &quot;more lines&quot; or &quot;fewer lines&quot; message, so that &quot;5dd&quot; and</a>
<a name="ln1369">  // then &quot;put&quot; reports the last action.</a>
<a name="ln1370">  if (keep_msg != NULL &amp;&amp; !keep_msg_more) {</a>
<a name="ln1371">    return;</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">  if (n &gt; 0) {</a>
<a name="ln1375">    pn = n;</a>
<a name="ln1376">  } else {</a>
<a name="ln1377">    pn = -n;</a>
<a name="ln1378">  }</a>
<a name="ln1379"> </a>
<a name="ln1380">  if (pn &gt; p_report) {</a>
<a name="ln1381">    if (n &gt; 0) {</a>
<a name="ln1382">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1383">                   NGETTEXT(&quot;%ld more line&quot;, &quot;%ld more lines&quot;, pn),</a>
<a name="ln1384">                   pn);</a>
<a name="ln1385">    } else {</a>
<a name="ln1386">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1387">                   NGETTEXT(&quot;%ld line less&quot;, &quot;%ld fewer lines&quot;, pn),</a>
<a name="ln1388">                   pn);</a>
<a name="ln1389">    }</a>
<a name="ln1390">    if (got_int) {</a>
<a name="ln1391">      xstrlcat(msg_buf, _(&quot; (Interrupted)&quot;), MSG_BUF_LEN);</a>
<a name="ln1392">    }</a>
<a name="ln1393">    if (msg(msg_buf, 0)) {</a>
<a name="ln1394">      set_keep_msg(msg_buf, 0);</a>
<a name="ln1395">      keep_msg_more = true;</a>
<a name="ln1396">    }</a>
<a name="ln1397">  }</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">void msg_ext_set_kind(const char *msg_kind)</a>
<a name="ln1401">{</a>
<a name="ln1402">  // Don't change the label of an existing batch:</a>
<a name="ln1403">  msg_ext_ui_flush();</a>
<a name="ln1404"> </a>
<a name="ln1405">  // TODO(bfredl): would be nice to avoid dynamic scoping, but that would</a>
<a name="ln1406">  // need refactoring the msg_ interface to not be &quot;please pretend nvim is</a>
<a name="ln1407">  // a terminal for a moment&quot;</a>
<a name="ln1408">  msg_ext_kind = msg_kind;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">/// Prepare for outputting characters in the command line.</a>
<a name="ln1412">void msg_start(void)</a>
<a name="ln1413">{</a>
<a name="ln1414">  int did_return = false;</a>
<a name="ln1415"> </a>
<a name="ln1416">  if (!msg_silent) {</a>
<a name="ln1417">    XFREE_CLEAR(keep_msg);              // don't display old message now</a>
<a name="ln1418">    need_fileinfo = false;</a>
<a name="ln1419">  }</a>
<a name="ln1420"> </a>
<a name="ln1421">  if (need_clr_eos || (p_ch == 0 &amp;&amp; redrawing_cmdline)) {</a>
<a name="ln1422">    // Halfway an &quot;:echo&quot; command and getting an (error) message: clear</a>
<a name="ln1423">    // any text from the command.</a>
<a name="ln1424">    need_clr_eos = false;</a>
<a name="ln1425">    msg_clr_eos();</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  // if cmdheight=0, we need to scroll in the first line of msg_grid upon the screen</a>
<a name="ln1429">  if (p_ch == 0 &amp;&amp; !ui_has(kUIMessages) &amp;&amp; !msg_scrolled) {</a>
<a name="ln1430">    msg_grid_validate();</a>
<a name="ln1431">    msg_scroll_up(false, true);</a>
<a name="ln1432">    msg_scrolled++;</a>
<a name="ln1433">    cmdline_row = Rows - 1;</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">  if (!msg_scroll &amp;&amp; full_screen) {     // overwrite last message</a>
<a name="ln1437">    msg_row = cmdline_row;</a>
<a name="ln1438">    msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln1439">  } else if (msg_didout || (p_ch == 0 &amp;&amp; !ui_has(kUIMessages))) {  // start message on next line</a>
<a name="ln1440">    msg_putchar('\n');</a>
<a name="ln1441">    did_return = true;</a>
<a name="ln1442">    cmdline_row = msg_row;</a>
<a name="ln1443">  }</a>
<a name="ln1444">  if (!msg_didany || lines_left &lt; 0) {</a>
<a name="ln1445">    msg_starthere();</a>
<a name="ln1446">  }</a>
<a name="ln1447">  if (msg_silent == 0) {</a>
<a name="ln1448">    msg_didout = false;                     // no output on current line yet</a>
<a name="ln1449">  }</a>
<a name="ln1450"> </a>
<a name="ln1451">  if (ui_has(kUIMessages)) {</a>
<a name="ln1452">    msg_ext_ui_flush();</a>
<a name="ln1453">    if (!msg_scroll &amp;&amp; msg_ext_visible) {</a>
<a name="ln1454">      // Will overwrite last message.</a>
<a name="ln1455">      msg_ext_overwrite = true;</a>
<a name="ln1456">    }</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  // When redirecting, may need to start a new line.</a>
<a name="ln1460">  if (!did_return) {</a>
<a name="ln1461">    redir_write(&quot;\n&quot;, 1);</a>
<a name="ln1462">  }</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">/// Note that the current msg position is where messages start.</a>
<a name="ln1466">void msg_starthere(void)</a>
<a name="ln1467">{</a>
<a name="ln1468">  lines_left = cmdline_row;</a>
<a name="ln1469">  msg_didany = false;</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">void msg_putchar(int c)</a>
<a name="ln1473">{</a>
<a name="ln1474">  msg_putchar_attr(c, 0);</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">void msg_putchar_attr(int c, int attr)</a>
<a name="ln1478">{</a>
<a name="ln1479">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln1480"> </a>
<a name="ln1481">  if (IS_SPECIAL(c)) {</a>
<a name="ln1482">    buf[0] = (char)K_SPECIAL;</a>
<a name="ln1483">    buf[1] = (char)K_SECOND(c);</a>
<a name="ln1484">    buf[2] = (char)K_THIRD(c);</a>
<a name="ln1485">    buf[3] = NUL;</a>
<a name="ln1486">  } else {</a>
<a name="ln1487">    buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln1488">  }</a>
<a name="ln1489">  msg_puts_attr(buf, attr);</a>
<a name="ln1490">}</a>
<a name="ln1491"> </a>
<a name="ln1492">void msg_outnum(int n)</a>
<a name="ln1493">{</a>
<a name="ln1494">  char buf[20];</a>
<a name="ln1495"> </a>
<a name="ln1496">  snprintf(buf, sizeof(buf), &quot;%d&quot;, n);</a>
<a name="ln1497">  msg_puts(buf);</a>
<a name="ln1498">}</a>
<a name="ln1499"> </a>
<a name="ln1500">void msg_home_replace(const char *fname)</a>
<a name="ln1501">{</a>
<a name="ln1502">  msg_home_replace_attr(fname, 0);</a>
<a name="ln1503">}</a>
<a name="ln1504"> </a>
<a name="ln1505">void msg_home_replace_hl(const char *fname)</a>
<a name="ln1506">{</a>
<a name="ln1507">  msg_home_replace_attr(fname, HL_ATTR(HLF_D));</a>
<a name="ln1508">}</a>
<a name="ln1509"> </a>
<a name="ln1510">static void msg_home_replace_attr(const char *fname, int attr)</a>
<a name="ln1511">{</a>
<a name="ln1512">  char *name = home_replace_save(NULL, fname);</a>
<a name="ln1513">  msg_outtrans(name, attr);</a>
<a name="ln1514">  xfree(name);</a>
<a name="ln1515">}</a>
<a name="ln1516"> </a>
<a name="ln1517">/// Output 'len' characters in 'str' (including NULs) with translation</a>
<a name="ln1518">/// if 'len' is -1, output up to a NUL character.</a>
<a name="ln1519">/// Use attributes 'attr'.</a>
<a name="ln1520">///</a>
<a name="ln1521">/// @return  the number of characters it takes on the screen.</a>
<a name="ln1522">int msg_outtrans(const char *str, int attr)</a>
<a name="ln1523">{</a>
<a name="ln1524">  return msg_outtrans_len(str, (int)strlen(str), attr);</a>
<a name="ln1525">}</a>
<a name="ln1526"> </a>
<a name="ln1527">/// Output one character at &quot;p&quot;.</a>
<a name="ln1528">/// Handles multi-byte characters.</a>
<a name="ln1529">///</a>
<a name="ln1530">/// @return  pointer to the next character.</a>
<a name="ln1531">const char *msg_outtrans_one(const char *p, int attr)</a>
<a name="ln1532">{</a>
<a name="ln1533">  int l;</a>
<a name="ln1534"> </a>
<a name="ln1535">  if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln1536">    msg_outtrans_len(p, l, attr);</a>
<a name="ln1537">    return p + l;</a>
<a name="ln1538">  }</a>
<a name="ln1539">  msg_puts_attr(transchar_byte_buf(NULL, (uint8_t)(*p)), attr);</a>
<a name="ln1540">  return p + 1;</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">int msg_outtrans_len(const char *msgstr, int len, int attr)</a>
<a name="ln1544">{</a>
<a name="ln1545">  int retval = 0;</a>
<a name="ln1546">  const char *str = msgstr;</a>
<a name="ln1547">  const char *plain_start = msgstr;</a>
<a name="ln1548">  char *s;</a>
<a name="ln1549">  int c;</a>
<a name="ln1550">  int save_got_int = got_int;</a>
<a name="ln1551"> </a>
<a name="ln1552">  // Only quit when got_int was set in here.</a>
<a name="ln1553">  got_int = false;</a>
<a name="ln1554"> </a>
<a name="ln1555">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1556">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1557">    add_msg_hist(str, len, attr, false);</a>
<a name="ln1558">    attr &amp;= ~MSG_HIST;</a>
<a name="ln1559">  }</a>
<a name="ln1560"> </a>
<a name="ln1561">  // When drawing over the command line no need to clear it later or remove</a>
<a name="ln1562">  // the mode message.</a>
<a name="ln1563">  if (msg_row &gt;= cmdline_row &amp;&amp; msg_col == 0) {</a>
<a name="ln1564">    clear_cmdline = false;</a>
<a name="ln1565">    mode_displayed = false;</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568">  // If the string starts with a composing character first draw a space on</a>
<a name="ln1569">  // which the composing char can be drawn.</a>
<a name="ln1570">  if (utf_iscomposing(utf_ptr2char(msgstr))) {</a>
<a name="ln1571">    msg_puts_attr(&quot; &quot;, attr);</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  // Go over the string.  Special characters are translated and printed.</a>
<a name="ln1575">  // Normal characters are printed several at a time.</a>
<a name="ln1576">  while (--len &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1577">    // Don't include composing chars after the end.</a>
<a name="ln1578">    int mb_l = utfc_ptr2len_len(str, len + 1);</a>
<a name="ln1579">    if (mb_l &gt; 1) {</a>
<a name="ln1580">      c = utf_ptr2char(str);</a>
<a name="ln1581">      if (vim_isprintc(c)) {</a>
<a name="ln1582">        // Printable multi-byte char: count the cells.</a>
<a name="ln1583">        retval += utf_ptr2cells(str);</a>
<a name="ln1584">      } else {</a>
<a name="ln1585">        // Unprintable multi-byte char: print the printable chars so</a>
<a name="ln1586">        // far and the translation of the unprintable char.</a>
<a name="ln1587">        if (str &gt; plain_start) {</a>
<a name="ln1588">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1589">        }</a>
<a name="ln1590">        plain_start = str + mb_l;</a>
<a name="ln1591">        msg_puts_attr(transchar_buf(NULL, c), attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1592">        retval += char2cells(c);</a>
<a name="ln1593">      }</a>
<a name="ln1594">      len -= mb_l - 1;</a>
<a name="ln1595">      str += mb_l;</a>
<a name="ln1596">    } else {</a>
<a name="ln1597">      s = transchar_byte_buf(NULL, (uint8_t)(*str));</a>
<a name="ln1598">      if (s[1] != NUL) {</a>
<a name="ln1599">        // Unprintable char: print the printable chars so far and the</a>
<a name="ln1600">        // translation of the unprintable char.</a>
<a name="ln1601">        if (str &gt; plain_start) {</a>
<a name="ln1602">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1603">        }</a>
<a name="ln1604">        plain_start = str + 1;</a>
<a name="ln1605">        msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1606">        retval += (int)strlen(s);</a>
<a name="ln1607">      } else {</a>
<a name="ln1608">        retval++;</a>
<a name="ln1609">      }</a>
<a name="ln1610">      str++;</a>
<a name="ln1611">    }</a>
<a name="ln1612">  }</a>
<a name="ln1613"> </a>
<a name="ln1614">  if (str &gt; plain_start &amp;&amp; !got_int) {</a>
<a name="ln1615">    // Print the printable chars at the end.</a>
<a name="ln1616">    msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1617">  }</a>
<a name="ln1618"> </a>
<a name="ln1619">  got_int |= save_got_int;</a>
<a name="ln1620"> </a>
<a name="ln1621">  return retval;</a>
<a name="ln1622">}</a>
<a name="ln1623"> </a>
<a name="ln1624">void msg_make(const char *arg)</a>
<a name="ln1625">{</a>
<a name="ln1626">  int i;</a>
<a name="ln1627">  static const char *str = &quot;eeffoc&quot;;</a>
<a name="ln1628">  static const char *rs = &quot;Plon#dqg#vxjduB&quot;;</a>
<a name="ln1629"> </a>
<a name="ln1630">  arg = skipwhite(arg);</a>
<a name="ln1631">  for (i = 5; *arg &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln1632">    if (*arg++ != str[i]) {</a>
<a name="ln1633">      break;</a>
<a name="ln1634">    }</a>
<a name="ln1635">  }</a>
<a name="ln1636">  if (i &lt; 0) {</a>
<a name="ln1637">    msg_putchar('\n');</a>
<a name="ln1638">    for (i = 0; rs[i]; i++) {</a>
<a name="ln1639">      msg_putchar(rs[i] - 3);</a>
<a name="ln1640">    }</a>
<a name="ln1641">  }</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">/// Output the string 'str' up to a NUL character.</a>
<a name="ln1645">/// Return the number of characters it takes on the screen.</a>
<a name="ln1646">///</a>
<a name="ln1647">/// If K_SPECIAL is encountered, then it is taken in conjunction with the</a>
<a name="ln1648">/// following character and shown as &lt;F1&gt;, &lt;S-Up&gt; etc.  Any other character</a>
<a name="ln1649">/// which is not printable shown in &lt;&gt; form.</a>
<a name="ln1650">/// If 'from' is true (lhs of a mapping), a space is shown as &lt;Space&gt;.</a>
<a name="ln1651">/// If a character is displayed in one of these special ways, is also</a>
<a name="ln1652">/// highlighted (its highlight name is '8' in the p_hl variable).</a>
<a name="ln1653">/// Otherwise characters are not highlighted.</a>
<a name="ln1654">/// This function is used to show mappings, where we want to see how to type</a>
<a name="ln1655">/// the character/string -- webb</a>
<a name="ln1656">///</a>
<a name="ln1657">/// @param from  true for LHS of a mapping</a>
<a name="ln1658">/// @param maxlen  screen columns, 0 for unlimited</a>
<a name="ln1659">int msg_outtrans_special(const char *strstart, bool from, int maxlen)</a>
<a name="ln1660">{</a>
<a name="ln1661">  if (strstart == NULL) {</a>
<a name="ln1662">    return 0;  // Do nothing.</a>
<a name="ln1663">  }</a>
<a name="ln1664">  const char *str = strstart;</a>
<a name="ln1665">  int retval = 0;</a>
<a name="ln1666">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln1667"> </a>
<a name="ln1668">  while (*str != NUL) {</a>
<a name="ln1669">    const char *text;</a>
<a name="ln1670">    // Leading and trailing spaces need to be displayed in &lt;&gt; form.</a>
<a name="ln1671">    if ((str == strstart || str[1] == NUL) &amp;&amp; *str == ' ') {</a>
<a name="ln1672">      text = &quot;&lt;Space&gt;&quot;;</a>
<a name="ln1673">      str++;</a>
<a name="ln1674">    } else {</a>
<a name="ln1675">      text = str2special(&amp;str, from, false);</a>
<a name="ln1676">    }</a>
<a name="ln1677">    if (text[0] != NUL &amp;&amp; text[1] == NUL) {</a>
<a name="ln1678">      // single-byte character or illegal byte</a>
<a name="ln1679">      text = transchar_byte_buf(NULL, (uint8_t)text[0]);</a>
<a name="ln1680">    }</a>
<a name="ln1681">    const int len = vim_strsize(text);</a>
<a name="ln1682">    if (maxlen &gt; 0 &amp;&amp; retval + len &gt;= maxlen) {</a>
<a name="ln1683">      break;</a>
<a name="ln1684">    }</a>
<a name="ln1685">    // Highlight special keys</a>
<a name="ln1686">    msg_puts_attr(text, (len &gt; 1</a>
<a name="ln1687">                         &amp;&amp; utfc_ptr2len(text) &lt;= 1</a>
<a name="ln1688">                         ? attr : 0));</a>
<a name="ln1689">    retval += len;</a>
<a name="ln1690">  }</a>
<a name="ln1691">  return retval;</a>
<a name="ln1692">}</a>
<a name="ln1693"> </a>
<a name="ln1694">/// Convert string, replacing key codes with printables</a>
<a name="ln1695">///</a>
<a name="ln1696">/// Used for lhs or rhs of mappings.</a>
<a name="ln1697">///</a>
<a name="ln1698">/// @param[in]  str  String to convert.</a>
<a name="ln1699">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1700">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1701">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1702">///</a>
<a name="ln1703">/// @return [allocated] Converted string.</a>
<a name="ln1704">char *str2special_save(const char *const str, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1705">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1706">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1707">{</a>
<a name="ln1708">  garray_T ga;</a>
<a name="ln1709">  ga_init(&amp;ga, 1, 40);</a>
<a name="ln1710"> </a>
<a name="ln1711">  const char *p = str;</a>
<a name="ln1712">  while (*p != NUL) {</a>
<a name="ln1713">    ga_concat(&amp;ga, str2special(&amp;p, replace_spaces, replace_lt));</a>
<a name="ln1714">  }</a>
<a name="ln1715">  ga_append(&amp;ga, NUL);</a>
<a name="ln1716">  return (char *)ga.ga_data;</a>
<a name="ln1717">}</a>
<a name="ln1718"> </a>
<a name="ln1719">/// Convert character, replacing key with printable representation.</a>
<a name="ln1720">///</a>
<a name="ln1721">/// @param[in,out]  sp  String to convert. Is advanced to the next key code.</a>
<a name="ln1722">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1723">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1724">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1725">///</a>
<a name="ln1726">/// @return Converted key code, in a static buffer. Buffer is always one and the</a>
<a name="ln1727">///         same, so save converted string somewhere before running str2special</a>
<a name="ln1728">///         for the second time.</a>
<a name="ln1729">///         On illegal byte return a string with only that byte.</a>
<a name="ln1730">const char *str2special(const char **const sp, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1731">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET</a>
<a name="ln1732">{</a>
<a name="ln1733">  static char buf[7];</a>
<a name="ln1734"> </a>
<a name="ln1735">  {</a>
<a name="ln1736">    // Try to un-escape a multi-byte character.  Return the un-escaped</a>
<a name="ln1737">    // string if it is a multi-byte character.</a>
<a name="ln1738">    const char *const p = mb_unescape(sp);</a>
<a name="ln1739">    if (p != NULL) {</a>
<a name="ln1740">      return p;</a>
<a name="ln1741">    }</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">  const char *str = *sp;</a>
<a name="ln1745">  int c = (uint8_t)(*str);</a>
<a name="ln1746">  int modifiers = 0;</a>
<a name="ln1747">  bool special = false;</a>
<a name="ln1748">  if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1749">    if ((uint8_t)str[1] == KS_MODIFIER) {</a>
<a name="ln1750">      modifiers = (uint8_t)str[2];</a>
<a name="ln1751">      str += 3;</a>
<a name="ln1752">      c = (uint8_t)(*str);</a>
<a name="ln1753">    }</a>
<a name="ln1754">    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1755">      c = TO_SPECIAL((uint8_t)str[1], (uint8_t)str[2]);</a>
<a name="ln1756">      str += 2;</a>
<a name="ln1757">    }</a>
<a name="ln1758">    if (IS_SPECIAL(c) || modifiers) {  // Special key.</a>
<a name="ln1759">      special = true;</a>
<a name="ln1760">    }</a>
<a name="ln1761">  }</a>
<a name="ln1762"> </a>
<a name="ln1763">  if (!IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1) {</a>
<a name="ln1764">    *sp = str;</a>
<a name="ln1765">    // Try to un-escape a multi-byte character after modifiers.</a>
<a name="ln1766">    const char *p = mb_unescape(sp);</a>
<a name="ln1767">    if (p != NULL) {</a>
<a name="ln1768">      // Since 'special' is true the multi-byte character 'c' will be</a>
<a name="ln1769">      // processed by get_special_key_name().</a>
<a name="ln1770">      c = utf_ptr2char(p);</a>
<a name="ln1771">    } else {</a>
<a name="ln1772">      // illegal byte</a>
<a name="ln1773">      *sp = str + 1;</a>
<a name="ln1774">    }</a>
<a name="ln1775">  } else {</a>
<a name="ln1776">    // single-byte character, NUL or illegal byte</a>
<a name="ln1777">    *sp = str + (*str == NUL ? 0 : 1);</a>
<a name="ln1778">  }</a>
<a name="ln1779"> </a>
<a name="ln1780">  // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.</a>
<a name="ln1781">  if (special</a>
<a name="ln1782">      || c &lt; ' '</a>
<a name="ln1783">      || (replace_spaces &amp;&amp; c == ' ')</a>
<a name="ln1784">      || (replace_lt &amp;&amp; c == '&lt;')) {</a>
<a name="ln1785">    return get_special_key_name(c, modifiers);</a>
<a name="ln1786">  }</a>
<a name="ln1787">  buf[0] = (char)c;</a>
<a name="ln1788">  buf[1] = NUL;</a>
<a name="ln1789">  return buf;</a>
<a name="ln1790">}</a>
<a name="ln1791"> </a>
<a name="ln1792">/// Convert string, replacing key codes with printables</a>
<a name="ln1793">///</a>
<a name="ln1794">/// @param[in]  str  String to convert.</a>
<a name="ln1795">/// @param[out]  buf  Buffer to save results to.</a>
<a name="ln1796">/// @param[in]  len  Buffer length.</a>
<a name="ln1797">void str2specialbuf(const char *sp, char *buf, size_t len)</a>
<a name="ln1798">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1799">{</a>
<a name="ln1800">  while (*sp) {</a>
<a name="ln1801">    const char *s = str2special(&amp;sp, false, false);</a>
<a name="ln1802">    const size_t s_len = strlen(s);</a>
<a name="ln1803">    if (len &lt;= s_len) {</a>
<a name="ln1804">      break;</a>
<a name="ln1805">    }</a>
<a name="ln1806">    memcpy(buf, s, s_len);</a>
<a name="ln1807">    buf += s_len;</a>
<a name="ln1808">    len -= s_len;</a>
<a name="ln1809">  }</a>
<a name="ln1810">  *buf = NUL;</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">/// print line for :print or :list command</a>
<a name="ln1814">void msg_prt_line(const char *s, int list)</a>
<a name="ln1815">{</a>
<a name="ln1816">  int c;</a>
<a name="ln1817">  int col = 0;</a>
<a name="ln1818">  int n_extra = 0;</a>
<a name="ln1819">  int c_extra = 0;</a>
<a name="ln1820">  int c_final = 0;</a>
<a name="ln1821">  const char *p_extra = NULL;  // init to make SASC shut up</a>
<a name="ln1822">  int n;</a>
<a name="ln1823">  int attr = 0;</a>
<a name="ln1824">  const char *lead = NULL;</a>
<a name="ln1825">  bool in_multispace = false;</a>
<a name="ln1826">  int multispace_pos = 0;</a>
<a name="ln1827">  const char *trail = NULL;</a>
<a name="ln1828">  int l;</a>
<a name="ln1829"> </a>
<a name="ln1830">  if (curwin-&gt;w_p_list) {</a>
<a name="ln1831">    list = true;</a>
<a name="ln1832">  }</a>
<a name="ln1833"> </a>
<a name="ln1834">  if (list) {</a>
<a name="ln1835">    // find start of trailing whitespace</a>
<a name="ln1836">    if (curwin-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1837">      trail = s + strlen(s);</a>
<a name="ln1838">      while (trail &gt; s &amp;&amp; ascii_iswhite(trail[-1])) {</a>
<a name="ln1839">        trail--;</a>
<a name="ln1840">      }</a>
<a name="ln1841">    }</a>
<a name="ln1842">    // find end of leading whitespace</a>
<a name="ln1843">    if (curwin-&gt;w_p_lcs_chars.lead || curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1844">      lead = s;</a>
<a name="ln1845">      while (ascii_iswhite(lead[0])) {</a>
<a name="ln1846">        lead++;</a>
<a name="ln1847">      }</a>
<a name="ln1848">      // in a line full of spaces all of them are treated as trailing</a>
<a name="ln1849">      if (*lead == NUL) {</a>
<a name="ln1850">        lead = NULL;</a>
<a name="ln1851">      }</a>
<a name="ln1852">    }</a>
<a name="ln1853">  }</a>
<a name="ln1854"> </a>
<a name="ln1855">  // output a space for an empty line, otherwise the line will be overwritten</a>
<a name="ln1856">  if (*s == NUL &amp;&amp; !(list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL)) {</a>
<a name="ln1857">    msg_putchar(' ');</a>
<a name="ln1858">  }</a>
<a name="ln1859"> </a>
<a name="ln1860">  while (!got_int) {</a>
<a name="ln1861">    if (n_extra &gt; 0) {</a>
<a name="ln1862">      n_extra--;</a>
<a name="ln1863">      if (n_extra == 0 &amp;&amp; c_final) {</a>
<a name="ln1864">        c = c_final;</a>
<a name="ln1865">      } else if (c_extra) {</a>
<a name="ln1866">        c = c_extra;</a>
<a name="ln1867">      } else {</a>
<a name="ln1868">        assert(p_extra != NULL);</a>
<a name="ln1869">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1870">      }</a>
<a name="ln1871">    } else if ((l = utfc_ptr2len(s)) &gt; 1) {</a>
<a name="ln1872">      col += utf_ptr2cells(s);</a>
<a name="ln1873">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln1874">      if (l &gt;= MB_MAXBYTES) {</a>
<a name="ln1875">        xstrlcpy(buf, &quot;?&quot;, sizeof(buf));</a>
<a name="ln1876">      } else if (curwin-&gt;w_p_lcs_chars.nbsp != NUL &amp;&amp; list</a>
<a name="ln1877">                 &amp;&amp; (utf_ptr2char(s) == 160</a>
<a name="ln1878">                     || utf_ptr2char(s) == 0x202f)) {</a>
<a name="ln1879">        int len = utf_char2bytes(curwin-&gt;w_p_lcs_chars.nbsp, buf);</a>
<a name="ln1880">        buf[len] = NUL;</a>
<a name="ln1881">      } else {</a>
<a name="ln1882">        memmove(buf, s, (size_t)l);</a>
<a name="ln1883">        buf[l] = NUL;</a>
<a name="ln1884">      }</a>
<a name="ln1885">      msg_puts(buf);</a>
<a name="ln1886">      s += l;</a>
<a name="ln1887">      continue;</a>
<a name="ln1888">    } else {</a>
<a name="ln1889">      attr = 0;</a>
<a name="ln1890">      c = (uint8_t)(*s++);</a>
<a name="ln1891">      if (list) {</a>
<a name="ln1892">        in_multispace = c == ' ' &amp;&amp; (*s == ' '</a>
<a name="ln1893">                                     || (col &gt; 0 &amp;&amp; s[-2] == ' '));</a>
<a name="ln1894">        if (!in_multispace) {</a>
<a name="ln1895">          multispace_pos = 0;</a>
<a name="ln1896">        }</a>
<a name="ln1897">      }</a>
<a name="ln1898">      if (c == TAB &amp;&amp; (!list || curwin-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1899">        // tab amount depends on current column</a>
<a name="ln1900">        n_extra = tabstop_padding(col,</a>
<a name="ln1901">                                  curbuf-&gt;b_p_ts,</a>
<a name="ln1902">                                  curbuf-&gt;b_p_vts_array) - 1;</a>
<a name="ln1903">        if (!list) {</a>
<a name="ln1904">          c = ' ';</a>
<a name="ln1905">          c_extra = ' ';</a>
<a name="ln1906">          c_final = NUL;</a>
<a name="ln1907">        } else {</a>
<a name="ln1908">          c = (n_extra == 0 &amp;&amp; curwin-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln1909">              ? curwin-&gt;w_p_lcs_chars.tab3</a>
<a name="ln1910">              : curwin-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1911">          c_extra = curwin-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1912">          c_final = curwin-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1913">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1914">        }</a>
<a name="ln1915">      } else if (c == 160 &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp != NUL) {</a>
<a name="ln1916">        c = curwin-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1917">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1918">      } else if (c == NUL &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL) {</a>
<a name="ln1919">        p_extra = &quot;&quot;;</a>
<a name="ln1920">        c_extra = NUL;</a>
<a name="ln1921">        c_final = NUL;</a>
<a name="ln1922">        n_extra = 1;</a>
<a name="ln1923">        c = curwin-&gt;w_p_lcs_chars.eol;</a>
<a name="ln1924">        attr = HL_ATTR(HLF_AT);</a>
<a name="ln1925">        s--;</a>
<a name="ln1926">      } else if (c != NUL &amp;&amp; (n = byte2cells(c)) &gt; 1) {</a>
<a name="ln1927">        n_extra = n - 1;</a>
<a name="ln1928">        p_extra = transchar_byte_buf(NULL, c);</a>
<a name="ln1929">        c_extra = NUL;</a>
<a name="ln1930">        c_final = NUL;</a>
<a name="ln1931">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1932">        // Use special coloring to be able to distinguish &lt;hex&gt; from</a>
<a name="ln1933">        // the same in plain text.</a>
<a name="ln1934">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1935">      } else if (c == ' ') {</a>
<a name="ln1936">        if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; in_multispace</a>
<a name="ln1937">            &amp;&amp; curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1938">          c = curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos++];</a>
<a name="ln1939">          if (curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos] == NUL) {</a>
<a name="ln1940">            multispace_pos = 0;</a>
<a name="ln1941">          }</a>
<a name="ln1942">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1943">        } else if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; curwin-&gt;w_p_lcs_chars.lead != NUL) {</a>
<a name="ln1944">          c = curwin-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1945">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1946">        } else if (trail != NULL &amp;&amp; s &gt; trail) {</a>
<a name="ln1947">          c = curwin-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1948">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1949">        } else if (in_multispace</a>
<a name="ln1950">                   &amp;&amp; curwin-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1951">          c = curwin-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1952">          if (curwin-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1953">            multispace_pos = 0;</a>
<a name="ln1954">          }</a>
<a name="ln1955">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1956">        } else if (list &amp;&amp; curwin-&gt;w_p_lcs_chars.space != NUL) {</a>
<a name="ln1957">          c = curwin-&gt;w_p_lcs_chars.space;</a>
<a name="ln1958">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1959">        }</a>
<a name="ln1960">      }</a>
<a name="ln1961">    }</a>
<a name="ln1962"> </a>
<a name="ln1963">    if (c == NUL) {</a>
<a name="ln1964">      break;</a>
<a name="ln1965">    }</a>
<a name="ln1966"> </a>
<a name="ln1967">    msg_putchar_attr(c, attr);</a>
<a name="ln1968">    col++;</a>
<a name="ln1969">  }</a>
<a name="ln1970">  msg_clr_eos();</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">/// Output a string to the screen at position msg_row, msg_col.</a>
<a name="ln1974">/// Update msg_row and msg_col for the next message.</a>
<a name="ln1975">void msg_puts(const char *s)</a>
<a name="ln1976">{</a>
<a name="ln1977">  msg_puts_attr(s, 0);</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">void msg_puts_title(const char *s)</a>
<a name="ln1981">{</a>
<a name="ln1982">  msg_puts_attr(s, HL_ATTR(HLF_T));</a>
<a name="ln1983">}</a>
<a name="ln1984"> </a>
<a name="ln1985">/// Show a message in such a way that it always fits in the line.  Cut out a</a>
<a name="ln1986">/// part in the middle and replace it with &quot;...&quot; when necessary.</a>
<a name="ln1987">/// Does not handle multi-byte characters!</a>
<a name="ln1988">void msg_outtrans_long(const char *longstr, int attr)</a>
<a name="ln1989">{</a>
<a name="ln1990">  int len = (int)strlen(longstr);</a>
<a name="ln1991">  int slen = len;</a>
<a name="ln1992">  int room = Columns - msg_col;</a>
<a name="ln1993">  if (len &gt; room &amp;&amp; room &gt;= 20) {</a>
<a name="ln1994">    slen = (room - 3) / 2;</a>
<a name="ln1995">    msg_outtrans_len(longstr, slen, attr);</a>
<a name="ln1996">    msg_puts_attr(&quot;...&quot;, HL_ATTR(HLF_8));</a>
<a name="ln1997">  }</a>
<a name="ln1998">  msg_outtrans_len(longstr + len - slen, slen, attr);</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">/// Basic function for writing a message with highlight attributes.</a>
<a name="ln2002">void msg_puts_attr(const char *const s, const int attr)</a>
<a name="ln2003">{</a>
<a name="ln2004">  msg_puts_len(s, -1, attr);</a>
<a name="ln2005">}</a>
<a name="ln2006"> </a>
<a name="ln2007">/// Write a message with highlight attributes</a>
<a name="ln2008">///</a>
<a name="ln2009">/// @param[in]  str  NUL-terminated message string.</a>
<a name="ln2010">/// @param[in]  len  Length of the string or -1.</a>
<a name="ln2011">/// @param[in]  attr  Highlight attribute.</a>
<a name="ln2012">void msg_puts_len(const char *const str, const ptrdiff_t len, int attr)</a>
<a name="ln2013">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2014">{</a>
<a name="ln2015">  assert(len &lt; 0 || memchr(str, 0, (size_t)len) == NULL);</a>
<a name="ln2016">  // If redirection is on, also write to the redirection file.</a>
<a name="ln2017">  redir_write(str, len);</a>
<a name="ln2018"> </a>
<a name="ln2019">  // Don't print anything when using &quot;:silent cmd&quot;.</a>
<a name="ln2020">  if (msg_silent != 0) {</a>
<a name="ln2021">    return;</a>
<a name="ln2022">  }</a>
<a name="ln2023"> </a>
<a name="ln2024">  // if MSG_HIST flag set, add message to history</a>
<a name="ln2025">  if (attr &amp; MSG_HIST) {</a>
<a name="ln2026">    add_msg_hist(str, (int)len, attr, false);</a>
<a name="ln2027">    attr &amp;= ~MSG_HIST;</a>
<a name="ln2028">  }</a>
<a name="ln2029"> </a>
<a name="ln2030">  // When writing something to the screen after it has scrolled, requires a</a>
<a name="ln2031">  // wait-return prompt later.  Needed when scrolling, resetting</a>
<a name="ln2032">  // need_wait_return after some prompt, and then outputting something</a>
<a name="ln2033">  // without scrolling</a>
<a name="ln2034">  // Not needed when only using CR to move the cursor.</a>
<a name="ln2035">  bool overflow = false;</a>
<a name="ln2036">  if (ui_has(kUIMessages)) {</a>
<a name="ln2037">    int count = msg_ext_visible + (msg_ext_overwrite ? 0 : 1);</a>
<a name="ln2038">    // TODO(bfredl): possible extension point, let external UI control this</a>
<a name="ln2039">    if (count &gt; 1) {</a>
<a name="ln2040">      overflow = true;</a>
<a name="ln2041">    }</a>
<a name="ln2042">  } else {</a>
<a name="ln2043">    overflow = msg_scrolled &gt; (p_ch == 0 ? 1 : 0);</a>
<a name="ln2044">  }</a>
<a name="ln2045"> </a>
<a name="ln2046">  if (overflow &amp;&amp; !msg_scrolled_ign &amp;&amp; strcmp(str, &quot;\r&quot;) != 0) {</a>
<a name="ln2047">    need_wait_return = true;</a>
<a name="ln2048">  }</a>
<a name="ln2049">  msg_didany = true;  // remember that something was outputted</a>
<a name="ln2050"> </a>
<a name="ln2051">  // If there is no valid screen, use fprintf so we can see error messages.</a>
<a name="ln2052">  // If termcap is not active, we may be writing in an alternate console</a>
<a name="ln2053">  // window, cursor positioning may not work correctly (window size may be</a>
<a name="ln2054">  // different, e.g. for Win32 console) or we just don't know where the</a>
<a name="ln2055">  // cursor is.</a>
<a name="ln2056">  if (msg_use_printf()) {</a>
<a name="ln2057">    int saved_msg_col = msg_col;</a>
<a name="ln2058">    msg_puts_printf(str, len);</a>
<a name="ln2059">    if (headless_mode) {</a>
<a name="ln2060">      msg_col = saved_msg_col;</a>
<a name="ln2061">    }</a>
<a name="ln2062">  }</a>
<a name="ln2063">  if (!msg_use_printf() || (headless_mode &amp;&amp; default_grid.chars)) {</a>
<a name="ln2064">    msg_puts_display(str, (int)len, attr, false);</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  need_fileinfo = false;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">/// Print a formatted message</a>
<a name="ln2071">///</a>
<a name="ln2072">/// Message printed is limited by #IOSIZE. Must not be used from inside</a>
<a name="ln2073">/// msg_puts_attr().</a>
<a name="ln2074">///</a>
<a name="ln2075">/// @param[in]  attr  Highlight attributes.</a>
<a name="ln2076">/// @param[in]  fmt  Format string.</a>
<a name="ln2077">void msg_printf_attr(const int attr, const char *const fmt, ...)</a>
<a name="ln2078">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2079">{</a>
<a name="ln2080">  static char msgbuf[IOSIZE];</a>
<a name="ln2081"> </a>
<a name="ln2082">  va_list ap;</a>
<a name="ln2083">  va_start(ap, fmt);</a>
<a name="ln2084">  const size_t len = (size_t)vim_vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);</a>
<a name="ln2085">  va_end(ap);</a>
<a name="ln2086"> </a>
<a name="ln2087">  msg_scroll = true;</a>
<a name="ln2088">  msg_puts_len(msgbuf, (ptrdiff_t)len, attr);</a>
<a name="ln2089">}</a>
<a name="ln2090"> </a>
<a name="ln2091">static void msg_ext_emit_chunk(void)</a>
<a name="ln2092">{</a>
<a name="ln2093">  // Color was changed or a message flushed, end current chunk.</a>
<a name="ln2094">  if (msg_ext_last_attr == -1) {</a>
<a name="ln2095">    return;  // no chunk</a>
<a name="ln2096">  }</a>
<a name="ln2097">  Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln2098">  ADD(chunk, INTEGER_OBJ(msg_ext_last_attr));</a>
<a name="ln2099">  msg_ext_last_attr = -1;</a>
<a name="ln2100">  String text = ga_take_string(&amp;msg_ext_last_chunk);</a>
<a name="ln2101">  ADD(chunk, STRING_OBJ(text));</a>
<a name="ln2102">  ADD(msg_ext_chunks, ARRAY_OBJ(chunk));</a>
<a name="ln2103">}</a>
<a name="ln2104"> </a>
<a name="ln2105">/// The display part of msg_puts_len().</a>
<a name="ln2106">/// May be called recursively to display scroll-back text.</a>
<a name="ln2107">static void msg_puts_display(const char *str, int maxlen, int attr, int recurse)</a>
<a name="ln2108">{</a>
<a name="ln2109">  const char *s = str;</a>
<a name="ln2110">  const char *sb_str = str;</a>
<a name="ln2111">  int sb_col = msg_col;</a>
<a name="ln2112"> </a>
<a name="ln2113">  did_wait_return = false;</a>
<a name="ln2114"> </a>
<a name="ln2115">  if (ui_has(kUIMessages)) {</a>
<a name="ln2116">    if (attr != msg_ext_last_attr) {</a>
<a name="ln2117">      msg_ext_emit_chunk();</a>
<a name="ln2118">      msg_ext_last_attr = attr;</a>
<a name="ln2119">    }</a>
<a name="ln2120">    // Concat pieces with the same highlight</a>
<a name="ln2121">    size_t len = strnlen(str, (size_t)maxlen);  // -V781</a>
<a name="ln2122">    ga_concat_len(&amp;msg_ext_last_chunk, str, len);</a>
<a name="ln2123">    msg_ext_cur_len += len;</a>
<a name="ln2124">    return;</a>
<a name="ln2125">  }</a>
<a name="ln2126"> </a>
<a name="ln2127">  int print_attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2128">  msg_grid_validate();</a>
<a name="ln2129"> </a>
<a name="ln2130">  cmdline_was_last_drawn = redrawing_cmdline;</a>
<a name="ln2131"> </a>
<a name="ln2132">  int msg_row_pending = -1;</a>
<a name="ln2133"> </a>
<a name="ln2134">  while (true) {</a>
<a name="ln2135">    if (cmdmsg_rl ? msg_col &lt;= 0 : msg_col &gt;= Columns) {</a>
<a name="ln2136">      if (p_more &amp;&amp; !recurse) {</a>
<a name="ln2137">        // Store text for scrolling back.</a>
<a name="ln2138">        store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2139">      }</a>
<a name="ln2140">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2141">        break;</a>
<a name="ln2142">      }</a>
<a name="ln2143"> </a>
<a name="ln2144">      msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln2145">      msg_row++;</a>
<a name="ln2146">      msg_didout = false;</a>
<a name="ln2147">    }</a>
<a name="ln2148"> </a>
<a name="ln2149">    if (msg_row &gt;= Rows) {</a>
<a name="ln2150">      msg_row = Rows - 1;</a>
<a name="ln2151"> </a>
<a name="ln2152">      // When no more prompt and no more room, truncate here</a>
<a name="ln2153">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2154">        break;</a>
<a name="ln2155">      }</a>
<a name="ln2156"> </a>
<a name="ln2157">      if (!recurse) {</a>
<a name="ln2158">        if (msg_row_pending &gt;= 0) {</a>
<a name="ln2159">          grid_line_flush_if_valid_row();</a>
<a name="ln2160">          msg_row_pending = -1;</a>
<a name="ln2161">        }</a>
<a name="ln2162"> </a>
<a name="ln2163">        // Scroll the screen up one line.</a>
<a name="ln2164">        msg_scroll_up(true, false);</a>
<a name="ln2165"> </a>
<a name="ln2166">        inc_msg_scrolled();</a>
<a name="ln2167">        need_wait_return = true;       // may need wait_return() in main()</a>
<a name="ln2168">        redraw_cmdline = true;</a>
<a name="ln2169">        if (cmdline_row &gt; 0 &amp;&amp; !exmode_active) {</a>
<a name="ln2170">          cmdline_row--;</a>
<a name="ln2171">        }</a>
<a name="ln2172"> </a>
<a name="ln2173">        // If screen is completely filled and 'more' is set then wait</a>
<a name="ln2174">        // for a character.</a>
<a name="ln2175">        if (lines_left &gt; 0) {</a>
<a name="ln2176">          lines_left--;</a>
<a name="ln2177">        }</a>
<a name="ln2178"> </a>
<a name="ln2179">        if (p_more &amp;&amp; lines_left == 0 &amp;&amp; State != MODE_HITRETURN</a>
<a name="ln2180">            &amp;&amp; !msg_no_more &amp;&amp; !exmode_active) {</a>
<a name="ln2181">          if (do_more_prompt(NUL)) {</a>
<a name="ln2182">            s = confirm_msg_tail;</a>
<a name="ln2183">          }</a>
<a name="ln2184">          if (quit_more) {</a>
<a name="ln2185">            return;</a>
<a name="ln2186">          }</a>
<a name="ln2187">        }</a>
<a name="ln2188">      }</a>
<a name="ln2189">    }</a>
<a name="ln2190"> </a>
<a name="ln2191">    if (!((maxlen &lt; 0 || (int)(s - str) &lt; maxlen) &amp;&amp; *s != NUL)) {</a>
<a name="ln2192">      break;</a>
<a name="ln2193">    }</a>
<a name="ln2194"> </a>
<a name="ln2195">    if (msg_row != msg_row_pending &amp;&amp; ((uint8_t)(*s) &gt;= 0x20 || *s == TAB)) {</a>
<a name="ln2196">      // TODO(bfredl): this logic is messier that it has to be. What</a>
<a name="ln2197">      // messages really want is its own private linebuf_char buffer.</a>
<a name="ln2198">      if (msg_row_pending &gt;= 0) {</a>
<a name="ln2199">        grid_line_flush_if_valid_row();</a>
<a name="ln2200">      }</a>
<a name="ln2201">      grid_line_start(&amp;msg_grid_adj, msg_row);</a>
<a name="ln2202">      msg_row_pending = msg_row;</a>
<a name="ln2203">    }</a>
<a name="ln2204"> </a>
<a name="ln2205">    if ((uint8_t)(*s) &gt;= 0x20) {  // printable char</a>
<a name="ln2206">      int cw = utf_ptr2cells(s);</a>
<a name="ln2207">      // avoid including composing chars after the end</a>
<a name="ln2208">      int l = (maxlen &gt;= 0) ? utfc_ptr2len_len(s, (int)((str + maxlen) - s)) : utfc_ptr2len(s);</a>
<a name="ln2209"> </a>
<a name="ln2210">      if (cw &gt; 1 &amp;&amp; (cmdmsg_rl ? msg_col &lt;= 1 : msg_col == Columns - 1)) {</a>
<a name="ln2211">        // Doesn't fit, print a highlighted '&gt;' to fill it up.</a>
<a name="ln2212">        grid_line_puts(msg_col, &quot;&gt;&quot;, 1, HL_ATTR(HLF_AT));</a>
<a name="ln2213">        cw = 1;</a>
<a name="ln2214">      } else {</a>
<a name="ln2215">        grid_line_puts(msg_col, s, l, print_attr);</a>
<a name="ln2216">        s += l;</a>
<a name="ln2217">      }</a>
<a name="ln2218">      msg_didout = true;  // remember that line is not empty</a>
<a name="ln2219">      if (cmdmsg_rl) {</a>
<a name="ln2220">        msg_col -= cw;</a>
<a name="ln2221">      } else {</a>
<a name="ln2222">        msg_col += cw;</a>
<a name="ln2223">      }</a>
<a name="ln2224">    } else {</a>
<a name="ln2225">      char c = *s++;</a>
<a name="ln2226">      if (c == '\n') {  // go to next line</a>
<a name="ln2227">        msg_didout = false;  // remember that line is empty</a>
<a name="ln2228">        if (cmdmsg_rl) {</a>
<a name="ln2229">          msg_col = Columns - 1;</a>
<a name="ln2230">        } else {</a>
<a name="ln2231">          msg_col = 0;</a>
<a name="ln2232">        }</a>
<a name="ln2233">        msg_row++;</a>
<a name="ln2234">        if (p_more &amp;&amp; !recurse) {</a>
<a name="ln2235">          // Store text for scrolling back.</a>
<a name="ln2236">          store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2237">        }</a>
<a name="ln2238">      } else if (c == '\r') {  // go to column 0</a>
<a name="ln2239">        msg_col = 0;</a>
<a name="ln2240">      } else if (c == '\b') {  // go to previous char</a>
<a name="ln2241">        if (msg_col) {</a>
<a name="ln2242">          msg_col--;</a>
<a name="ln2243">        }</a>
<a name="ln2244">      } else if (c == TAB) {  // translate Tab into spaces</a>
<a name="ln2245">        do {</a>
<a name="ln2246">          grid_line_puts(msg_col, &quot; &quot;, 1, print_attr);</a>
<a name="ln2247">          msg_col += cmdmsg_rl ? -1 : 1;</a>
<a name="ln2248"> </a>
<a name="ln2249">          if (msg_col == (cmdmsg_rl ? 0 : Columns)) {</a>
<a name="ln2250">            break;</a>
<a name="ln2251">          }</a>
<a name="ln2252">        } while (msg_col &amp; 7);</a>
<a name="ln2253">      } else if (c == BELL) {  // beep (from &quot;:sh&quot;)</a>
<a name="ln2254">        vim_beep(BO_SH);</a>
<a name="ln2255">      }</a>
<a name="ln2256">    }</a>
<a name="ln2257">  }</a>
<a name="ln2258"> </a>
<a name="ln2259">  if (msg_row_pending &gt;= 0) {</a>
<a name="ln2260">    grid_line_flush_if_valid_row();</a>
<a name="ln2261">  }</a>
<a name="ln2262">  msg_cursor_goto(msg_row, msg_col);</a>
<a name="ln2263"> </a>
<a name="ln2264">  if (p_more &amp;&amp; !recurse &amp;&amp; !(s == sb_str + 1 &amp;&amp; *sb_str == '\n')) {</a>
<a name="ln2265">    store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, false);</a>
<a name="ln2266">  }</a>
<a name="ln2267"> </a>
<a name="ln2268">  msg_check();</a>
<a name="ln2269">}</a>
<a name="ln2270"> </a>
<a name="ln2271">void msg_cursor_goto(int row, int col)</a>
<a name="ln2272">{</a>
<a name="ln2273">  ScreenGrid *grid = &amp;msg_grid_adj;</a>
<a name="ln2274">  grid_adjust(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln2275">  ui_grid_cursor_goto(grid-&gt;handle, row, col);</a>
<a name="ln2276">}</a>
<a name="ln2277"> </a>
<a name="ln2278">/// @return  true when &quot;:filter pattern&quot; was used and &quot;msg&quot; does not match</a>
<a name="ln2279">///          &quot;pattern&quot;.</a>
<a name="ln2280">bool message_filtered(const char *msg)</a>
<a name="ln2281">{</a>
<a name="ln2282">  if (cmdmod.cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2283">    return false;</a>
<a name="ln2284">  }</a>
<a name="ln2285"> </a>
<a name="ln2286">  bool match = vim_regexec(&amp;cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);</a>
<a name="ln2287">  return cmdmod.cmod_filter_force ? match : !match;</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/// including horizontal separator</a>
<a name="ln2291">int msg_scrollsize(void)</a>
<a name="ln2292">{</a>
<a name="ln2293">  return msg_scrolled + (int)p_ch + ((p_ch &gt; 0 || msg_scrolled &gt; 1) ? 1 : 0);</a>
<a name="ln2294">}</a>
<a name="ln2295"> </a>
<a name="ln2296">bool msg_do_throttle(void)</a>
<a name="ln2297">{</a>
<a name="ln2298">  return msg_use_grid() &amp;&amp; !(rdb_flags &amp; RDB_NOTHROTTLE);</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">/// Scroll the screen up one line for displaying the next message line.</a>
<a name="ln2302">void msg_scroll_up(bool may_throttle, bool zerocmd)</a>
<a name="ln2303">{</a>
<a name="ln2304">  if (may_throttle &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2305">    msg_grid.throttled = true;</a>
<a name="ln2306">  }</a>
<a name="ln2307">  msg_did_scroll = true;</a>
<a name="ln2308">  if (msg_grid_pos &gt; 0) {</a>
<a name="ln2309">    msg_grid_set_pos(msg_grid_pos - 1, !zerocmd);</a>
<a name="ln2310"> </a>
<a name="ln2311">    // When displaying the first line with cmdheight=0, we need to draw over</a>
<a name="ln2312">    // the existing last line of the screen.</a>
<a name="ln2313">    if (zerocmd &amp;&amp; msg_grid.chars) {</a>
<a name="ln2314">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[0], msg_grid.cols, false);</a>
<a name="ln2315">    }</a>
<a name="ln2316">  } else {</a>
<a name="ln2317">    grid_del_lines(&amp;msg_grid, 0, 1, msg_grid.rows, 0, msg_grid.cols);</a>
<a name="ln2318">    memmove(msg_grid.dirty_col, msg_grid.dirty_col + 1,</a>
<a name="ln2319">            (size_t)(msg_grid.rows - 1) * sizeof(*msg_grid.dirty_col));</a>
<a name="ln2320">    msg_grid.dirty_col[msg_grid.rows - 1] = 0;</a>
<a name="ln2321">  }</a>
<a name="ln2322"> </a>
<a name="ln2323">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln2324">}</a>
<a name="ln2325"> </a>
<a name="ln2326">/// Send throttled message output to UI clients</a>
<a name="ln2327">///</a>
<a name="ln2328">/// The way message.c uses the grid_xx family of functions is quite inefficient</a>
<a name="ln2329">/// relative to the &quot;gridline&quot; UI protocol used by TUI and modern clients.</a>
<a name="ln2330">/// For instance scrolling is done one line at a time. By throttling drawing</a>
<a name="ln2331">/// on the message grid, we can coalesce scrolling to a single grid_scroll</a>
<a name="ln2332">/// per screen update.</a>
<a name="ln2333">///</a>
<a name="ln2334">/// NB: The bookkeeping is quite messy, and rests on a bunch of poorly</a>
<a name="ln2335">/// documented assumptions. For instance that the message area always grows</a>
<a name="ln2336">/// while being throttled, messages are only being output on the last line</a>
<a name="ln2337">/// etc.</a>
<a name="ln2338">///</a>
<a name="ln2339">/// Probably message scrollback storage should be reimplemented as a</a>
<a name="ln2340">/// file_buffer, and message scrolling in TUI be reimplemented as a modal</a>
<a name="ln2341">/// floating window. Then we get throttling &quot;for free&quot; using standard</a>
<a name="ln2342">/// redraw_later code paths.</a>
<a name="ln2343">void msg_scroll_flush(void)</a>
<a name="ln2344">{</a>
<a name="ln2345">  if (msg_grid.throttled) {</a>
<a name="ln2346">    msg_grid.throttled = false;</a>
<a name="ln2347">    int pos_delta = msg_grid_pos_at_flush - msg_grid_pos;</a>
<a name="ln2348">    assert(pos_delta &gt;= 0);</a>
<a name="ln2349">    int delta = MIN(msg_scrolled - msg_scrolled_at_flush, msg_grid.rows);</a>
<a name="ln2350"> </a>
<a name="ln2351">    if (pos_delta &gt; 0) {</a>
<a name="ln2352">      ui_ext_msg_set_pos(msg_grid_pos, true);</a>
<a name="ln2353">    }</a>
<a name="ln2354"> </a>
<a name="ln2355">    int to_scroll = delta - pos_delta - msg_grid_scroll_discount;</a>
<a name="ln2356">    assert(to_scroll &gt;= 0);</a>
<a name="ln2357"> </a>
<a name="ln2358">    // TODO(bfredl): msg_grid_pos should be 0 already when starting scrolling</a>
<a name="ln2359">    // but this sometimes fails in &quot;headless&quot; message printing.</a>
<a name="ln2360">    if (to_scroll &gt; 0 &amp;&amp; msg_grid_pos == 0) {</a>
<a name="ln2361">      ui_call_grid_scroll(msg_grid.handle, 0, Rows, 0, Columns, to_scroll, 0);</a>
<a name="ln2362">    }</a>
<a name="ln2363"> </a>
<a name="ln2364">    for (int i = MAX(Rows - MAX(delta, 1), 0); i &lt; Rows; i++) {</a>
<a name="ln2365">      int row = i - msg_grid_pos;</a>
<a name="ln2366">      assert(row &gt;= 0);</a>
<a name="ln2367">      ui_line(&amp;msg_grid, row, 0, msg_grid.dirty_col[row], msg_grid.cols,</a>
<a name="ln2368">              HL_ATTR(HLF_MSG), false);</a>
<a name="ln2369">      msg_grid.dirty_col[row] = 0;</a>
<a name="ln2370">    }</a>
<a name="ln2371">  }</a>
<a name="ln2372">  msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln2373">  msg_grid_scroll_discount = 0;</a>
<a name="ln2374">  msg_grid_pos_at_flush = msg_grid_pos;</a>
<a name="ln2375">}</a>
<a name="ln2376"> </a>
<a name="ln2377">void msg_reset_scroll(void)</a>
<a name="ln2378">{</a>
<a name="ln2379">  if (ui_has(kUIMessages)) {</a>
<a name="ln2380">    msg_ext_clear(true);</a>
<a name="ln2381">    return;</a>
<a name="ln2382">  }</a>
<a name="ln2383">  // TODO(bfredl): some duplicate logic with update_screen(). Later on</a>
<a name="ln2384">  // we should properly disentangle message clear with full screen redraw.</a>
<a name="ln2385">  msg_grid.throttled = false;</a>
<a name="ln2386">  // TODO(bfredl): risk for extra flicker i e with</a>
<a name="ln2387">  // &quot;nvim -o has_swap also_has_swap&quot;</a>
<a name="ln2388">  msg_grid_set_pos(Rows - (int)p_ch, false);</a>
<a name="ln2389">  clear_cmdline = true;</a>
<a name="ln2390">  if (msg_grid.chars) {</a>
<a name="ln2391">    // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln2392">    for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.rows); i++) {</a>
<a name="ln2393">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln2394">                      msg_grid.cols, false);</a>
<a name="ln2395">    }</a>
<a name="ln2396">  }</a>
<a name="ln2397">  msg_scrolled = 0;</a>
<a name="ln2398">  msg_scrolled_at_flush = 0;</a>
<a name="ln2399">  msg_grid_scroll_discount = 0;</a>
<a name="ln2400">}</a>
<a name="ln2401"> </a>
<a name="ln2402">/// Increment &quot;msg_scrolled&quot;.</a>
<a name="ln2403">static void inc_msg_scrolled(void)</a>
<a name="ln2404">{</a>
<a name="ln2405">  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {</a>
<a name="ln2406">    char *p = SOURCING_NAME;</a>
<a name="ln2407">    char *tofree = NULL;</a>
<a name="ln2408"> </a>
<a name="ln2409">    // v:scrollstart is empty, set it to the script/function name and line</a>
<a name="ln2410">    // number</a>
<a name="ln2411">    if (p == NULL) {</a>
<a name="ln2412">      p = _(&quot;Unknown&quot;);</a>
<a name="ln2413">    } else {</a>
<a name="ln2414">      size_t len = strlen(p) + 40;</a>
<a name="ln2415">      tofree = xmalloc(len);</a>
<a name="ln2416">      vim_snprintf(tofree, len, _(&quot;%s line %&quot; PRId64),</a>
<a name="ln2417">                   p, (int64_t)SOURCING_LNUM);</a>
<a name="ln2418">      p = tofree;</a>
<a name="ln2419">    }</a>
<a name="ln2420">    set_vim_var_string(VV_SCROLLSTART, p, -1);</a>
<a name="ln2421">    xfree(tofree);</a>
<a name="ln2422">  }</a>
<a name="ln2423">  msg_scrolled++;</a>
<a name="ln2424">  if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln2425">    must_redraw = UPD_VALID;</a>
<a name="ln2426">  }</a>
<a name="ln2427">}</a>
<a name="ln2428"> </a>
<a name="ln2429">static msgchunk_T *last_msgchunk = NULL;  // last displayed text</a>
<a name="ln2430"> </a>
<a name="ln2431">typedef enum {</a>
<a name="ln2432">  SB_CLEAR_NONE = 0,</a>
<a name="ln2433">  SB_CLEAR_ALL,</a>
<a name="ln2434">  SB_CLEAR_CMDLINE_BUSY,</a>
<a name="ln2435">  SB_CLEAR_CMDLINE_DONE,</a>
<a name="ln2436">} sb_clear_T;</a>
<a name="ln2437"> </a>
<a name="ln2438">// When to clear text on next msg.</a>
<a name="ln2439">static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2440"> </a>
<a name="ln2441">/// Store part of a printed message for displaying when scrolling back.</a>
<a name="ln2442">///</a>
<a name="ln2443">/// @param sb_str  start of string</a>
<a name="ln2444">/// @param s  just after string</a>
<a name="ln2445">/// @param finish  line ends</a>
<a name="ln2446">static void store_sb_text(const char **sb_str, const char *s, int attr, int *sb_col, int finish)</a>
<a name="ln2447">{</a>
<a name="ln2448">  msgchunk_T *mp;</a>
<a name="ln2449"> </a>
<a name="ln2450">  if (do_clear_sb_text == SB_CLEAR_ALL</a>
<a name="ln2451">      || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE) {</a>
<a name="ln2452">    clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);</a>
<a name="ln2453">    msg_sb_eol();  // prevent messages from overlapping</a>
<a name="ln2454">    if (do_clear_sb_text == SB_CLEAR_CMDLINE_DONE &amp;&amp; s &gt; *sb_str &amp;&amp; **sb_str == '\n') {</a>
<a name="ln2455">      (*sb_str)++;</a>
<a name="ln2456">    }</a>
<a name="ln2457">    do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2458">  }</a>
<a name="ln2459"> </a>
<a name="ln2460">  if (s &gt; *sb_str) {</a>
<a name="ln2461">    mp = xmalloc(offsetof(msgchunk_T, sb_text) + (size_t)(s - *sb_str) + 1);</a>
<a name="ln2462">    mp-&gt;sb_eol = (char)finish;</a>
<a name="ln2463">    mp-&gt;sb_msg_col = *sb_col;</a>
<a name="ln2464">    mp-&gt;sb_attr = attr;</a>
<a name="ln2465">    memcpy(mp-&gt;sb_text, *sb_str, (size_t)(s - *sb_str));</a>
<a name="ln2466">    mp-&gt;sb_text[s - *sb_str] = NUL;</a>
<a name="ln2467"> </a>
<a name="ln2468">    if (last_msgchunk == NULL) {</a>
<a name="ln2469">      last_msgchunk = mp;</a>
<a name="ln2470">      mp-&gt;sb_prev = NULL;</a>
<a name="ln2471">    } else {</a>
<a name="ln2472">      mp-&gt;sb_prev = last_msgchunk;</a>
<a name="ln2473">      last_msgchunk-&gt;sb_next = mp;</a>
<a name="ln2474">      last_msgchunk = mp;</a>
<a name="ln2475">    }</a>
<a name="ln2476">    mp-&gt;sb_next = NULL;</a>
<a name="ln2477">  } else if (finish &amp;&amp; last_msgchunk != NULL) {</a>
<a name="ln2478">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2479">  }</a>
<a name="ln2480"> </a>
<a name="ln2481">  *sb_str = s;</a>
<a name="ln2482">  *sb_col = 0;</a>
<a name="ln2483">}</a>
<a name="ln2484"> </a>
<a name="ln2485">/// Finished showing messages, clear the scroll-back text on the next message.</a>
<a name="ln2486">void may_clear_sb_text(void)</a>
<a name="ln2487">{</a>
<a name="ln2488">  do_clear_sb_text = SB_CLEAR_ALL;</a>
<a name="ln2489">}</a>
<a name="ln2490"> </a>
<a name="ln2491">/// Starting to edit the command line: do not clear messages now.</a>
<a name="ln2492">void sb_text_start_cmdline(void)</a>
<a name="ln2493">{</a>
<a name="ln2494">  if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY) {</a>
<a name="ln2495">    // Invoking command line recursively: the previous-level command line</a>
<a name="ln2496">    // doesn't need to be remembered as it will be redrawn when returning</a>
<a name="ln2497">    // to that level.</a>
<a name="ln2498">    sb_text_restart_cmdline();</a>
<a name="ln2499">  } else {</a>
<a name="ln2500">    msg_sb_eol();</a>
<a name="ln2501">    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2502">  }</a>
<a name="ln2503">}</a>
<a name="ln2504"> </a>
<a name="ln2505">/// Redrawing the command line: clear the last unfinished line.</a>
<a name="ln2506">void sb_text_restart_cmdline(void)</a>
<a name="ln2507">{</a>
<a name="ln2508">  // Needed when returning from nested command line.</a>
<a name="ln2509">  do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2510"> </a>
<a name="ln2511">  if (last_msgchunk == NULL || last_msgchunk-&gt;sb_eol) {</a>
<a name="ln2512">    // No unfinished line: don't clear anything.</a>
<a name="ln2513">    return;</a>
<a name="ln2514">  }</a>
<a name="ln2515"> </a>
<a name="ln2516">  msgchunk_T *tofree = msg_sb_start(last_msgchunk);</a>
<a name="ln2517">  last_msgchunk = tofree-&gt;sb_prev;</a>
<a name="ln2518">  if (last_msgchunk != NULL) {</a>
<a name="ln2519">    last_msgchunk-&gt;sb_next = NULL;</a>
<a name="ln2520">  }</a>
<a name="ln2521">  while (tofree != NULL) {</a>
<a name="ln2522">    msgchunk_T *tofree_next = tofree-&gt;sb_next;</a>
<a name="ln2523">    xfree(tofree);</a>
<a name="ln2524">    tofree = tofree_next;</a>
<a name="ln2525">  }</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">/// Ending to edit the command line: clear old lines but the last one later.</a>
<a name="ln2529">void sb_text_end_cmdline(void)</a>
<a name="ln2530">{</a>
<a name="ln2531">  do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;</a>
<a name="ln2532">}</a>
<a name="ln2533"> </a>
<a name="ln2534">/// Clear any text remembered for scrolling back.</a>
<a name="ln2535">/// When &quot;all&quot; is false keep the last line.</a>
<a name="ln2536">/// Called when redrawing the screen.</a>
<a name="ln2537">void clear_sb_text(int all)</a>
<a name="ln2538">{</a>
<a name="ln2539">  msgchunk_T *mp;</a>
<a name="ln2540">  msgchunk_T **lastp;</a>
<a name="ln2541"> </a>
<a name="ln2542">  if (all) {</a>
<a name="ln2543">    lastp = &amp;last_msgchunk;</a>
<a name="ln2544">  } else {</a>
<a name="ln2545">    if (last_msgchunk == NULL) {</a>
<a name="ln2546">      return;</a>
<a name="ln2547">    }</a>
<a name="ln2548">    lastp = &amp;msg_sb_start(last_msgchunk)-&gt;sb_prev;</a>
<a name="ln2549">  }</a>
<a name="ln2550"> </a>
<a name="ln2551">  while (*lastp != NULL) {</a>
<a name="ln2552">    mp = (*lastp)-&gt;sb_prev;</a>
<a name="ln2553">    xfree(*lastp);</a>
<a name="ln2554">    *lastp = mp;</a>
<a name="ln2555">  }</a>
<a name="ln2556">}</a>
<a name="ln2557"> </a>
<a name="ln2558">/// &quot;g&lt;&quot; command.</a>
<a name="ln2559">void show_sb_text(void)</a>
<a name="ln2560">{</a>
<a name="ln2561">  msgchunk_T *mp;</a>
<a name="ln2562"> </a>
<a name="ln2563">  // Only show something if there is more than one line, otherwise it looks</a>
<a name="ln2564">  // weird, typing a command without output results in one line.</a>
<a name="ln2565">  mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2566">  if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2567">    vim_beep(BO_MESS);</a>
<a name="ln2568">  } else {</a>
<a name="ln2569">    do_more_prompt('G');</a>
<a name="ln2570">    wait_return(false);</a>
<a name="ln2571">  }</a>
<a name="ln2572">}</a>
<a name="ln2573"> </a>
<a name="ln2574">/// Move to the start of screen line in already displayed text.</a>
<a name="ln2575">static msgchunk_T *msg_sb_start(msgchunk_T *mps)</a>
<a name="ln2576">{</a>
<a name="ln2577">  msgchunk_T *mp = mps;</a>
<a name="ln2578"> </a>
<a name="ln2579">  while (mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL &amp;&amp; !mp-&gt;sb_prev-&gt;sb_eol) {</a>
<a name="ln2580">    mp = mp-&gt;sb_prev;</a>
<a name="ln2581">  }</a>
<a name="ln2582">  return mp;</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585">/// Mark the last message chunk as finishing the line.</a>
<a name="ln2586">void msg_sb_eol(void)</a>
<a name="ln2587">{</a>
<a name="ln2588">  if (last_msgchunk != NULL) {</a>
<a name="ln2589">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2590">  }</a>
<a name="ln2591">}</a>
<a name="ln2592"> </a>
<a name="ln2593">/// Display a screen line from previously displayed text at row &quot;row&quot;.</a>
<a name="ln2594">///</a>
<a name="ln2595">/// @return  a pointer to the text for the next line (can be NULL).</a>
<a name="ln2596">static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp)</a>
<a name="ln2597">{</a>
<a name="ln2598">  msgchunk_T *mp = smp;</a>
<a name="ln2599"> </a>
<a name="ln2600">  while (true) {</a>
<a name="ln2601">    msg_row = row;</a>
<a name="ln2602">    msg_col = mp-&gt;sb_msg_col;</a>
<a name="ln2603">    char *p = mp-&gt;sb_text;</a>
<a name="ln2604">    msg_puts_display(p, -1, mp-&gt;sb_attr, true);</a>
<a name="ln2605">    if (mp-&gt;sb_eol || mp-&gt;sb_next == NULL) {</a>
<a name="ln2606">      break;</a>
<a name="ln2607">    }</a>
<a name="ln2608">    mp = mp-&gt;sb_next;</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  return mp-&gt;sb_next;</a>
<a name="ln2612">}</a>
<a name="ln2613"> </a>
<a name="ln2614">/// @return  true when messages should be printed to stdout/stderr:</a>
<a name="ln2615">///          - &quot;batch mode&quot; (&quot;silent mode&quot;, -es/-Es)</a>
<a name="ln2616">///          - no UI and not embedded</a>
<a name="ln2617">int msg_use_printf(void)</a>
<a name="ln2618">{</a>
<a name="ln2619">  return !embedded_mode &amp;&amp; !ui_active();</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">/// Print a message when there is no valid screen.</a>
<a name="ln2623">static void msg_puts_printf(const char *str, const ptrdiff_t maxlen)</a>
<a name="ln2624">{</a>
<a name="ln2625">  const char *s = str;</a>
<a name="ln2626">  char buf[7];</a>
<a name="ln2627">  char *p;</a>
<a name="ln2628"> </a>
<a name="ln2629">  if (on_print.type != kCallbackNone) {</a>
<a name="ln2630">    typval_T argv[1];</a>
<a name="ln2631">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2632">    argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln2633">    argv[0].vval.v_string = (char *)str;</a>
<a name="ln2634">    typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln2635">    callback_call(&amp;on_print, 1, argv, &amp;rettv);</a>
<a name="ln2636">    tv_clear(&amp;rettv);</a>
<a name="ln2637">    return;</a>
<a name="ln2638">  }</a>
<a name="ln2639"> </a>
<a name="ln2640">  while ((maxlen &lt; 0 || s - str &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2641">    int len = utf_ptr2len(s);</a>
<a name="ln2642">    if (!(silent_mode &amp;&amp; p_verbose == 0)) {</a>
<a name="ln2643">      // NL --&gt; CR NL translation (for Unix, not for &quot;--version&quot;)</a>
<a name="ln2644">      p = &amp;buf[0];</a>
<a name="ln2645">      if (*s == '\n' &amp;&amp; !info_message) {</a>
<a name="ln2646">        *p++ = '\r';</a>
<a name="ln2647">      }</a>
<a name="ln2648">      memcpy(p, s, (size_t)len);</a>
<a name="ln2649">      *(p + len) = '\0';</a>
<a name="ln2650">      if (info_message) {</a>
<a name="ln2651">        os_msg(buf);</a>
<a name="ln2652">      } else {</a>
<a name="ln2653">        os_errmsg(buf);</a>
<a name="ln2654">      }</a>
<a name="ln2655">    }</a>
<a name="ln2656"> </a>
<a name="ln2657">    int cw = utf_char2cells(utf_ptr2char(s));</a>
<a name="ln2658">    // primitive way to compute the current column</a>
<a name="ln2659">    if (cmdmsg_rl) {</a>
<a name="ln2660">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2661">        msg_col = Columns - 1;</a>
<a name="ln2662">      } else {</a>
<a name="ln2663">        msg_col -= cw;</a>
<a name="ln2664">      }</a>
<a name="ln2665">    } else {</a>
<a name="ln2666">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2667">        msg_col = 0;</a>
<a name="ln2668">      } else {</a>
<a name="ln2669">        msg_col += cw;</a>
<a name="ln2670">      }</a>
<a name="ln2671">    }</a>
<a name="ln2672">    s += len;</a>
<a name="ln2673">  }</a>
<a name="ln2674">  msg_didout = true;  // assume that line is not empty</a>
<a name="ln2675">}</a>
<a name="ln2676"> </a>
<a name="ln2677">/// Show the more-prompt and handle the user response.</a>
<a name="ln2678">/// This takes care of scrolling back and displaying previously displayed text.</a>
<a name="ln2679">/// When at hit-enter prompt &quot;typed_char&quot; is the already typed character,</a>
<a name="ln2680">/// otherwise it's NUL.</a>
<a name="ln2681">///</a>
<a name="ln2682">/// @return  true when jumping ahead to &quot;confirm_msg_tail&quot;.</a>
<a name="ln2683">static int do_more_prompt(int typed_char)</a>
<a name="ln2684">{</a>
<a name="ln2685">  static bool entered = false;</a>
<a name="ln2686">  int used_typed_char = typed_char;</a>
<a name="ln2687">  int oldState = State;</a>
<a name="ln2688">  int c;</a>
<a name="ln2689">  int retval = false;</a>
<a name="ln2690">  bool to_redraw = false;</a>
<a name="ln2691">  msgchunk_T *mp_last = NULL;</a>
<a name="ln2692">  msgchunk_T *mp;</a>
<a name="ln2693">  int i;</a>
<a name="ln2694"> </a>
<a name="ln2695">  // If headless mode is enabled and no input is required, this variable</a>
<a name="ln2696">  // will be true. However If server mode is enabled, the message &quot;--more--&quot;</a>
<a name="ln2697">  // should be displayed.</a>
<a name="ln2698">  bool no_need_more = headless_mode &amp;&amp; !embedded_mode;</a>
<a name="ln2699"> </a>
<a name="ln2700">  // We get called recursively when a timer callback outputs a message. In</a>
<a name="ln2701">  // that case don't show another prompt. Also when at the hit-Enter prompt</a>
<a name="ln2702">  // and nothing was typed.</a>
<a name="ln2703">  if (no_need_more || entered || (State == MODE_HITRETURN &amp;&amp; typed_char == 0)) {</a>
<a name="ln2704">    return false;</a>
<a name="ln2705">  }</a>
<a name="ln2706">  entered = true;</a>
<a name="ln2707"> </a>
<a name="ln2708">  if (typed_char == 'G') {</a>
<a name="ln2709">    // &quot;g&lt;&quot;: Find first line on the last page.</a>
<a name="ln2710">    mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2711">    for (i = 0; i &lt; Rows - 2 &amp;&amp; mp_last != NULL</a>
<a name="ln2712">         &amp;&amp; mp_last-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2713">      mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2714">    }</a>
<a name="ln2715">  }</a>
<a name="ln2716"> </a>
<a name="ln2717">  State = MODE_ASKMORE;</a>
<a name="ln2718">  setmouse();</a>
<a name="ln2719">  if (typed_char == NUL) {</a>
<a name="ln2720">    msg_moremsg(false);</a>
<a name="ln2721">  }</a>
<a name="ln2722">  while (true) {</a>
<a name="ln2723">    // Get a typed character directly from the user.</a>
<a name="ln2724">    if (used_typed_char != NUL) {</a>
<a name="ln2725">      c = used_typed_char;              // was typed at hit-enter prompt</a>
<a name="ln2726">      used_typed_char = NUL;</a>
<a name="ln2727">    } else {</a>
<a name="ln2728">      c = get_keystroke(resize_events);</a>
<a name="ln2729">    }</a>
<a name="ln2730"> </a>
<a name="ln2731">    int toscroll = 0;</a>
<a name="ln2732">    switch (c) {</a>
<a name="ln2733">    case BS:                    // scroll one line back</a>
<a name="ln2734">    case K_BS:</a>
<a name="ln2735">    case 'k':</a>
<a name="ln2736">    case K_UP:</a>
<a name="ln2737">      toscroll = -1;</a>
<a name="ln2738">      break;</a>
<a name="ln2739"> </a>
<a name="ln2740">    case CAR:                   // one extra line</a>
<a name="ln2741">    case NL:</a>
<a name="ln2742">    case 'j':</a>
<a name="ln2743">    case K_DOWN:</a>
<a name="ln2744">      toscroll = 1;</a>
<a name="ln2745">      break;</a>
<a name="ln2746"> </a>
<a name="ln2747">    case 'u':                   // Up half a page</a>
<a name="ln2748">      toscroll = -(Rows / 2);</a>
<a name="ln2749">      break;</a>
<a name="ln2750"> </a>
<a name="ln2751">    case 'd':                   // Down half a page</a>
<a name="ln2752">      toscroll = Rows / 2;</a>
<a name="ln2753">      break;</a>
<a name="ln2754"> </a>
<a name="ln2755">    case 'b':                   // one page back</a>
<a name="ln2756">    case K_PAGEUP:</a>
<a name="ln2757">      toscroll = -(Rows - 1);</a>
<a name="ln2758">      break;</a>
<a name="ln2759"> </a>
<a name="ln2760">    case ' ':                   // one extra page</a>
<a name="ln2761">    case 'f':</a>
<a name="ln2762">    case K_PAGEDOWN:</a>
<a name="ln2763">    case K_LEFTMOUSE:</a>
<a name="ln2764">      toscroll = Rows - 1;</a>
<a name="ln2765">      break;</a>
<a name="ln2766"> </a>
<a name="ln2767">    case 'g':                   // all the way back to the start</a>
<a name="ln2768">      toscroll = -999999;</a>
<a name="ln2769">      break;</a>
<a name="ln2770"> </a>
<a name="ln2771">    case 'G':                   // all the way to the end</a>
<a name="ln2772">      toscroll = 999999;</a>
<a name="ln2773">      lines_left = 999999;</a>
<a name="ln2774">      break;</a>
<a name="ln2775"> </a>
<a name="ln2776">    case ':':                   // start new command line</a>
<a name="ln2777">      if (!confirm_msg_used) {</a>
<a name="ln2778">        // Since got_int is set all typeahead will be flushed, but we</a>
<a name="ln2779">        // want to keep this ':', remember that in a special way.</a>
<a name="ln2780">        typeahead_noflush(':');</a>
<a name="ln2781">        cmdline_row = Rows - 1;                 // put ':' on this line</a>
<a name="ln2782">        skip_redraw = true;                     // skip redraw once</a>
<a name="ln2783">        need_wait_return = false;               // don't wait in main()</a>
<a name="ln2784">      }</a>
<a name="ln2785">      FALLTHROUGH;</a>
<a name="ln2786">    case 'q':                   // quit</a>
<a name="ln2787">    case Ctrl_C:</a>
<a name="ln2788">    case ESC:</a>
<a name="ln2789">      if (confirm_msg_used) {</a>
<a name="ln2790">        // Jump to the choices of the dialog.</a>
<a name="ln2791">        retval = true;</a>
<a name="ln2792">      } else {</a>
<a name="ln2793">        got_int = true;</a>
<a name="ln2794">        quit_more = true;</a>
<a name="ln2795">      }</a>
<a name="ln2796">      // When there is some more output (wrapping line) display that</a>
<a name="ln2797">      // without another prompt.</a>
<a name="ln2798">      lines_left = Rows - 1;</a>
<a name="ln2799">      break;</a>
<a name="ln2800"> </a>
<a name="ln2801">    case K_EVENT:</a>
<a name="ln2802">      // only resize_events are processed here</a>
<a name="ln2803">      // Attempt to redraw the screen. sb_text doesn't support reflow</a>
<a name="ln2804">      // so this only really works for vertical resize.</a>
<a name="ln2805">      multiqueue_process_events(resize_events);</a>
<a name="ln2806">      to_redraw = true;</a>
<a name="ln2807">      break;</a>
<a name="ln2808"> </a>
<a name="ln2809">    default:                    // no valid response</a>
<a name="ln2810">      msg_moremsg(true);</a>
<a name="ln2811">      continue;</a>
<a name="ln2812">    }</a>
<a name="ln2813"> </a>
<a name="ln2814">    // code assumes we only do one at a time</a>
<a name="ln2815">    assert((toscroll == 0) || !to_redraw);</a>
<a name="ln2816"> </a>
<a name="ln2817">    if (toscroll != 0 || to_redraw) {</a>
<a name="ln2818">      if (toscroll &lt; 0 || to_redraw) {</a>
<a name="ln2819">        // go to start of last line</a>
<a name="ln2820">        if (mp_last == NULL) {</a>
<a name="ln2821">          mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2822">        } else if (mp_last-&gt;sb_prev != NULL) {</a>
<a name="ln2823">          mp = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2824">        } else {</a>
<a name="ln2825">          mp = NULL;</a>
<a name="ln2826">        }</a>
<a name="ln2827"> </a>
<a name="ln2828">        // go to start of line at top of the screen</a>
<a name="ln2829">        for (i = 0; i &lt; Rows - 2 &amp;&amp; mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2830">          mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2831">        }</a>
<a name="ln2832"> </a>
<a name="ln2833">        if (mp != NULL &amp;&amp; (mp-&gt;sb_prev != NULL || to_redraw)) {</a>
<a name="ln2834">          // Find line to be displayed at top</a>
<a name="ln2835">          for (i = 0; i &gt; toscroll; i--) {</a>
<a name="ln2836">            if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2837">              break;</a>
<a name="ln2838">            }</a>
<a name="ln2839">            mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2840">            if (mp_last == NULL) {</a>
<a name="ln2841">              mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2842">            } else {</a>
<a name="ln2843">              mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2844">            }</a>
<a name="ln2845">          }</a>
<a name="ln2846"> </a>
<a name="ln2847">          if (toscroll == -1 &amp;&amp; !to_redraw) {</a>
<a name="ln2848">            grid_ins_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2849">            grid_fill(&amp;msg_grid_adj, 0, 1, 0, Columns, ' ', ' ',</a>
<a name="ln2850">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2851">            // display line at top</a>
<a name="ln2852">            (void)disp_sb_line(0, mp);</a>
<a name="ln2853">          } else {</a>
<a name="ln2854">            // redisplay all lines</a>
<a name="ln2855">            // TODO(bfredl): this case is not optimized (though only concerns</a>
<a name="ln2856">            // event fragmentization, not unnecessary scroll events).</a>
<a name="ln2857">            grid_fill(&amp;msg_grid_adj, 0, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2858">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2859">            for (i = 0; mp != NULL &amp;&amp; i &lt; Rows - 1; i++) {</a>
<a name="ln2860">              mp = disp_sb_line(i, mp);</a>
<a name="ln2861">              msg_scrolled++;</a>
<a name="ln2862">            }</a>
<a name="ln2863">            to_redraw = false;</a>
<a name="ln2864">          }</a>
<a name="ln2865">          toscroll = 0;</a>
<a name="ln2866">        }</a>
<a name="ln2867">      } else {</a>
<a name="ln2868">        // First display any text that we scrolled back.</a>
<a name="ln2869">        // if p_ch=0 we need to allocate a line for &quot;press enter&quot; messages!</a>
<a name="ln2870">        if (cmdline_row &gt;= Rows &amp;&amp; !ui_has(kUIMessages)) {</a>
<a name="ln2871">          msg_scroll_up(true, false);</a>
<a name="ln2872">          msg_scrolled++;</a>
<a name="ln2873">        }</a>
<a name="ln2874">        while (toscroll &gt; 0 &amp;&amp; mp_last != NULL) {</a>
<a name="ln2875">          if (msg_do_throttle() &amp;&amp; !msg_grid.throttled) {</a>
<a name="ln2876">            // Tricky: we redraw at one line higher than usual. Therefore</a>
<a name="ln2877">            // the non-flushed area is one line larger.</a>
<a name="ln2878">            msg_scrolled_at_flush--;</a>
<a name="ln2879">            msg_grid_scroll_discount++;</a>
<a name="ln2880">          }</a>
<a name="ln2881">          // scroll up, display line at bottom</a>
<a name="ln2882">          msg_scroll_up(true, false);</a>
<a name="ln2883">          inc_msg_scrolled();</a>
<a name="ln2884">          grid_fill(&amp;msg_grid_adj, Rows - 2, Rows - 1, 0, Columns, ' ', ' ',</a>
<a name="ln2885">                    HL_ATTR(HLF_MSG));</a>
<a name="ln2886">          mp_last = disp_sb_line(Rows - 2, mp_last);</a>
<a name="ln2887">          toscroll--;</a>
<a name="ln2888">        }</a>
<a name="ln2889">      }</a>
<a name="ln2890"> </a>
<a name="ln2891">      if (toscroll &lt;= 0) {</a>
<a name="ln2892">        // displayed the requested text, more prompt again</a>
<a name="ln2893">        grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2894">                  HL_ATTR(HLF_MSG));</a>
<a name="ln2895">        msg_moremsg(false);</a>
<a name="ln2896">        continue;</a>
<a name="ln2897">      }</a>
<a name="ln2898"> </a>
<a name="ln2899">      // display more text, return to caller</a>
<a name="ln2900">      lines_left = toscroll;</a>
<a name="ln2901">    }</a>
<a name="ln2902"> </a>
<a name="ln2903">    break;</a>
<a name="ln2904">  }</a>
<a name="ln2905"> </a>
<a name="ln2906">  // clear the --more-- message</a>
<a name="ln2907">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2908">            HL_ATTR(HLF_MSG));</a>
<a name="ln2909">  redraw_cmdline = true;</a>
<a name="ln2910">  clear_cmdline = false;</a>
<a name="ln2911">  mode_displayed = false;</a>
<a name="ln2912"> </a>
<a name="ln2913">  State = oldState;</a>
<a name="ln2914">  setmouse();</a>
<a name="ln2915">  if (quit_more) {</a>
<a name="ln2916">    msg_row = Rows - 1;</a>
<a name="ln2917">    msg_col = 0;</a>
<a name="ln2918">  } else if (cmdmsg_rl) {</a>
<a name="ln2919">    msg_col = Columns - 1;</a>
<a name="ln2920">  }</a>
<a name="ln2921"> </a>
<a name="ln2922">  entered = false;</a>
<a name="ln2923">  return retval;</a>
<a name="ln2924">}</a>
<a name="ln2925"> </a>
<a name="ln2926">#if defined(MSWIN)</a>
<a name="ln2927">/// Headless (no UI) error message handler.</a>
<a name="ln2928">static void do_msg(const char *str, bool errmsg)</a>
<a name="ln2929">{</a>
<a name="ln2930">  static bool did_err = false;</a>
<a name="ln2931">  assert(str != NULL);</a>
<a name="ln2932">  wchar_t *utf16str;</a>
<a name="ln2933">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln2934">  if (r != 0 &amp;&amp; !did_err) {</a>
<a name="ln2935">    did_err = true;</a>
<a name="ln2936">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2937">    ELOG(&quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2938">  } else if (r == 0) {</a>
<a name="ln2939">    if (errmsg) {</a>
<a name="ln2940">      fwprintf(stderr, L&quot;%ls&quot;, utf16str);</a>
<a name="ln2941">    } else {</a>
<a name="ln2942">      wprintf(L&quot;%ls&quot;, utf16str);</a>
<a name="ln2943">    }</a>
<a name="ln2944">    xfree(utf16str);</a>
<a name="ln2945">  }</a>
<a name="ln2946">}</a>
<a name="ln2947"> </a>
<a name="ln2948">void os_errmsg(const char *str)</a>
<a name="ln2949">{</a>
<a name="ln2950">  do_msg(str, true);</a>
<a name="ln2951">}</a>
<a name="ln2952"> </a>
<a name="ln2953">/// Headless (no UI) message handler.</a>
<a name="ln2954">void os_msg(const char *str)</a>
<a name="ln2955">{</a>
<a name="ln2956">  do_msg(str, false);</a>
<a name="ln2957">}</a>
<a name="ln2958">#endif  // MSWIN</a>
<a name="ln2959"> </a>
<a name="ln2960">void msg_moremsg(int full)</a>
<a name="ln2961">{</a>
<a name="ln2962">  int attr;</a>
<a name="ln2963">  char *s = _(&quot;-- More --&quot;);</a>
<a name="ln2964"> </a>
<a name="ln2965">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), HL_ATTR(HLF_M));</a>
<a name="ln2966">  grid_puts(&amp;msg_grid_adj, s, -1, Rows - 1, 0, attr);</a>
<a name="ln2967">  if (full) {</a>
<a name="ln2968">    grid_puts(&amp;msg_grid_adj, _(&quot; SPACE/d/j: screen/page/line down, b/u/k: up, q: quit &quot;), -1,</a>
<a name="ln2969">              Rows - 1, vim_strsize(s), attr);</a>
<a name="ln2970">  }</a>
<a name="ln2971">}</a>
<a name="ln2972"> </a>
<a name="ln2973">/// Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,</a>
<a name="ln2974">/// MODE_CONFIRM or exmode_active.</a>
<a name="ln2975">void repeat_message(void)</a>
<a name="ln2976">{</a>
<a name="ln2977">  if (State == MODE_ASKMORE) {</a>
<a name="ln2978">    msg_moremsg(true);          // display --more-- message again</a>
<a name="ln2979">    msg_row = Rows - 1;</a>
<a name="ln2980">  } else if (State == MODE_CONFIRM) {</a>
<a name="ln2981">    display_confirm_msg();      // display &quot;:confirm&quot; message again</a>
<a name="ln2982">    msg_row = Rows - 1;</a>
<a name="ln2983">  } else if (State == MODE_EXTERNCMD) {</a>
<a name="ln2984">    ui_cursor_goto(msg_row, msg_col);     // put cursor back</a>
<a name="ln2985">  } else if (State == MODE_HITRETURN || State == MODE_SETWSIZE) {</a>
<a name="ln2986">    if (msg_row == Rows - 1) {</a>
<a name="ln2987">      // Avoid drawing the &quot;hit-enter&quot; prompt below the previous one,</a>
<a name="ln2988">      // overwrite it.  Esp. useful when regaining focus and a</a>
<a name="ln2989">      // FocusGained autocmd exists but didn't draw anything.</a>
<a name="ln2990">      msg_didout = false;</a>
<a name="ln2991">      msg_col = 0;</a>
<a name="ln2992">      msg_clr_eos();</a>
<a name="ln2993">    }</a>
<a name="ln2994">    hit_return_msg();</a>
<a name="ln2995">    msg_row = Rows - 1;</a>
<a name="ln2996">  }</a>
<a name="ln2997">}</a>
<a name="ln2998"> </a>
<a name="ln2999">/// Clear from current message position to end of screen.</a>
<a name="ln3000">/// Skip this when &quot;:silent&quot; was used, no need to clear for redirection.</a>
<a name="ln3001">void msg_clr_eos(void)</a>
<a name="ln3002">{</a>
<a name="ln3003">  if (msg_silent == 0) {</a>
<a name="ln3004">    msg_clr_eos_force();</a>
<a name="ln3005">  }</a>
<a name="ln3006">}</a>
<a name="ln3007"> </a>
<a name="ln3008">/// Clear from current message position to end of screen.</a>
<a name="ln3009">/// Note: msg_col is not updated, so we remember the end of the message</a>
<a name="ln3010">/// for msg_check().</a>
<a name="ln3011">void msg_clr_eos_force(void)</a>
<a name="ln3012">{</a>
<a name="ln3013">  if (ui_has(kUIMessages)) {</a>
<a name="ln3014">    return;</a>
<a name="ln3015">  }</a>
<a name="ln3016">  int msg_startcol = (cmdmsg_rl) ? 0 : msg_col;</a>
<a name="ln3017">  int msg_endcol = (cmdmsg_rl) ? msg_col + 1 : Columns;</a>
<a name="ln3018"> </a>
<a name="ln3019">  if (msg_grid.chars &amp;&amp; msg_row &lt; msg_grid_pos) {</a>
<a name="ln3020">    // TODO(bfredl): ugly, this state should already been validated at this</a>
<a name="ln3021">    // point. But msg_clr_eos() is called in a lot of places.</a>
<a name="ln3022">    msg_row = msg_grid_pos;</a>
<a name="ln3023">  }</a>
<a name="ln3024"> </a>
<a name="ln3025">  grid_fill(&amp;msg_grid_adj, msg_row, msg_row + 1, msg_startcol, msg_endcol,</a>
<a name="ln3026">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3027">  grid_fill(&amp;msg_grid_adj, msg_row + 1, Rows, 0, Columns,</a>
<a name="ln3028">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3029"> </a>
<a name="ln3030">  redraw_cmdline = true;  // overwritten the command line</a>
<a name="ln3031">  if (msg_row &lt; Rows - 1 || msg_col == (cmdmsg_rl ? Columns : 0)) {</a>
<a name="ln3032">    clear_cmdline = false;  // command line has been cleared</a>
<a name="ln3033">    mode_displayed = false;  // mode cleared or overwritten</a>
<a name="ln3034">  }</a>
<a name="ln3035">}</a>
<a name="ln3036"> </a>
<a name="ln3037">/// Clear the command line.</a>
<a name="ln3038">void msg_clr_cmdline(void)</a>
<a name="ln3039">{</a>
<a name="ln3040">  msg_row = cmdline_row;</a>
<a name="ln3041">  msg_col = 0;</a>
<a name="ln3042">  msg_clr_eos_force();</a>
<a name="ln3043">}</a>
<a name="ln3044"> </a>
<a name="ln3045">/// end putting a message on the screen</a>
<a name="ln3046">/// call wait_return() if the message does not fit in the available space</a>
<a name="ln3047">///</a>
<a name="ln3048">/// @return  true if wait_return() not called.</a>
<a name="ln3049">int msg_end(void)</a>
<a name="ln3050">{</a>
<a name="ln3051">  // If the string is larger than the window,</a>
<a name="ln3052">  // or the ruler option is set and we run into it,</a>
<a name="ln3053">  // we have to redraw the window.</a>
<a name="ln3054">  // Do not do this if we are abandoning the file or editing the command line.</a>
<a name="ln3055">  if (!exiting &amp;&amp; need_wait_return &amp;&amp; !(State &amp; MODE_CMDLINE)) {</a>
<a name="ln3056">    wait_return(false);</a>
<a name="ln3057">    return false;</a>
<a name="ln3058">  }</a>
<a name="ln3059"> </a>
<a name="ln3060">  // NOTE: ui_flush() used to be called here. This had to be removed, as it</a>
<a name="ln3061">  // inhibited substantial performance improvements. It is assumed that relevant</a>
<a name="ln3062">  // callers invoke ui_flush() before going into CPU busywork, or restricted</a>
<a name="ln3063">  // event processing after displaying a message to the user.</a>
<a name="ln3064">  msg_ext_ui_flush();</a>
<a name="ln3065">  return true;</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068">void msg_ext_ui_flush(void)</a>
<a name="ln3069">{</a>
<a name="ln3070">  if (!ui_has(kUIMessages)) {</a>
<a name="ln3071">    msg_ext_kind = NULL;</a>
<a name="ln3072">    return;</a>
<a name="ln3073">  }</a>
<a name="ln3074"> </a>
<a name="ln3075">  msg_ext_emit_chunk();</a>
<a name="ln3076">  if (msg_ext_chunks.size &gt; 0) {</a>
<a name="ln3077">    ui_call_msg_show(cstr_as_string((char *)msg_ext_kind),</a>
<a name="ln3078">                     msg_ext_chunks, msg_ext_overwrite);</a>
<a name="ln3079">    if (!msg_ext_overwrite) {</a>
<a name="ln3080">      msg_ext_visible++;</a>
<a name="ln3081">    }</a>
<a name="ln3082">    msg_ext_kind = NULL;</a>
<a name="ln3083">    api_free_array(msg_ext_chunks);</a>
<a name="ln3084">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3085">    msg_ext_cur_len = 0;</a>
<a name="ln3086">    msg_ext_overwrite = false;</a>
<a name="ln3087">  }</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">void msg_ext_flush_showmode(void)</a>
<a name="ln3091">{</a>
<a name="ln3092">  // Showmode messages doesn't interrupt normal message flow, so we use</a>
<a name="ln3093">  // separate event. Still reuse the same chunking logic, for simplicity.</a>
<a name="ln3094">  if (ui_has(kUIMessages)) {</a>
<a name="ln3095">    msg_ext_emit_chunk();</a>
<a name="ln3096">    ui_call_msg_showmode(msg_ext_chunks);</a>
<a name="ln3097">    api_free_array(msg_ext_chunks);</a>
<a name="ln3098">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3099">    msg_ext_cur_len = 0;</a>
<a name="ln3100">  }</a>
<a name="ln3101">}</a>
<a name="ln3102"> </a>
<a name="ln3103">void msg_ext_clear(bool force)</a>
<a name="ln3104">{</a>
<a name="ln3105">  if (msg_ext_visible &amp;&amp; (!msg_ext_keep_after_cmdline || force)) {</a>
<a name="ln3106">    ui_call_msg_clear();</a>
<a name="ln3107">    msg_ext_visible = 0;</a>
<a name="ln3108">    msg_ext_overwrite = false;  // nothing to overwrite</a>
<a name="ln3109">  }</a>
<a name="ln3110">  if (msg_ext_history_visible) {</a>
<a name="ln3111">    ui_call_msg_history_clear();</a>
<a name="ln3112">    msg_ext_history_visible = false;</a>
<a name="ln3113">  }</a>
<a name="ln3114"> </a>
<a name="ln3115">  // Only keep once.</a>
<a name="ln3116">  msg_ext_keep_after_cmdline = false;</a>
<a name="ln3117">}</a>
<a name="ln3118"> </a>
<a name="ln3119">void msg_ext_clear_later(void)</a>
<a name="ln3120">{</a>
<a name="ln3121">  if (msg_ext_is_visible()) {</a>
<a name="ln3122">    msg_ext_need_clear = true;</a>
<a name="ln3123">    if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln3124">      must_redraw = UPD_VALID;</a>
<a name="ln3125">    }</a>
<a name="ln3126">  }</a>
<a name="ln3127">}</a>
<a name="ln3128"> </a>
<a name="ln3129">void msg_ext_check_clear(void)</a>
<a name="ln3130">{</a>
<a name="ln3131">  // Redraw after cmdline or prompt is expected to clear messages.</a>
<a name="ln3132">  if (msg_ext_need_clear) {</a>
<a name="ln3133">    msg_ext_clear(true);</a>
<a name="ln3134">    msg_ext_need_clear = false;</a>
<a name="ln3135">  }</a>
<a name="ln3136">}</a>
<a name="ln3137"> </a>
<a name="ln3138">bool msg_ext_is_visible(void)</a>
<a name="ln3139">{</a>
<a name="ln3140">  return ui_has(kUIMessages) &amp;&amp; msg_ext_visible &gt; 0;</a>
<a name="ln3141">}</a>
<a name="ln3142"> </a>
<a name="ln3143">/// If the written message runs into the shown command or ruler, we have to</a>
<a name="ln3144">/// wait for hit-return and redraw the window later.</a>
<a name="ln3145">void msg_check(void)</a>
<a name="ln3146">{</a>
<a name="ln3147">  if (ui_has(kUIMessages)) {</a>
<a name="ln3148">    return;</a>
<a name="ln3149">  }</a>
<a name="ln3150">  if (msg_row == Rows - 1 &amp;&amp; msg_col &gt;= sc_col) {</a>
<a name="ln3151">    need_wait_return = true;</a>
<a name="ln3152">    redraw_cmdline = true;</a>
<a name="ln3153">  }</a>
<a name="ln3154">}</a>
<a name="ln3155"> </a>
<a name="ln3156">/// May write a string to the redirection file.</a>
<a name="ln3157">///</a>
<a name="ln3158">/// @param maxlen  if -1, write the whole string, otherwise up to &quot;maxlen&quot; bytes.</a>
<a name="ln3159">static void redir_write(const char *const str, const ptrdiff_t maxlen)</a>
<a name="ln3160">{</a>
<a name="ln3161">  const char *s = str;</a>
<a name="ln3162">  static int cur_col = 0;</a>
<a name="ln3163"> </a>
<a name="ln3164">  if (maxlen == 0) {</a>
<a name="ln3165">    return;</a>
<a name="ln3166">  }</a>
<a name="ln3167"> </a>
<a name="ln3168">  // Don't do anything for displaying prompts and the like.</a>
<a name="ln3169">  if (redir_off) {</a>
<a name="ln3170">    return;</a>
<a name="ln3171">  }</a>
<a name="ln3172"> </a>
<a name="ln3173">  // If 'verbosefile' is set prepare for writing in that file.</a>
<a name="ln3174">  if (*p_vfile != NUL &amp;&amp; verbose_fd == NULL) {</a>
<a name="ln3175">    verbose_open();</a>
<a name="ln3176">  }</a>
<a name="ln3177"> </a>
<a name="ln3178">  if (redirecting()) {</a>
<a name="ln3179">    // If the string doesn't start with CR or NL, go to msg_col</a>
<a name="ln3180">    if (*s != '\n' &amp;&amp; *s != '\r') {</a>
<a name="ln3181">      while (cur_col &lt; msg_col) {</a>
<a name="ln3182">        if (capture_ga) {</a>
<a name="ln3183">          ga_concat_len(capture_ga, &quot; &quot;, 1);</a>
<a name="ln3184">        }</a>
<a name="ln3185">        if (redir_reg) {</a>
<a name="ln3186">          write_reg_contents(redir_reg, &quot; &quot;, 1, true);</a>
<a name="ln3187">        } else if (redir_vname) {</a>
<a name="ln3188">          var_redir_str(&quot; &quot;, -1);</a>
<a name="ln3189">        } else if (redir_fd != NULL) {</a>
<a name="ln3190">          fputs(&quot; &quot;, redir_fd);</a>
<a name="ln3191">        }</a>
<a name="ln3192">        if (verbose_fd != NULL) {</a>
<a name="ln3193">          fputs(&quot; &quot;, verbose_fd);</a>
<a name="ln3194">        }</a>
<a name="ln3195">        cur_col++;</a>
<a name="ln3196">      }</a>
<a name="ln3197">    }</a>
<a name="ln3198"> </a>
<a name="ln3199">    size_t len = maxlen == -1 ? strlen(s) : (size_t)maxlen;</a>
<a name="ln3200">    if (capture_ga) {</a>
<a name="ln3201">      ga_concat_len(capture_ga, str, len);</a>
<a name="ln3202">    }</a>
<a name="ln3203">    if (redir_reg) {</a>
<a name="ln3204">      write_reg_contents(redir_reg, s, (ssize_t)len, true);</a>
<a name="ln3205">    }</a>
<a name="ln3206">    if (redir_vname) {</a>
<a name="ln3207">      var_redir_str(s, (int)maxlen);</a>
<a name="ln3208">    }</a>
<a name="ln3209"> </a>
<a name="ln3210">    // Write and adjust the current column.</a>
<a name="ln3211">    while (*s != NUL</a>
<a name="ln3212">           &amp;&amp; (maxlen &lt; 0 || (int)(s - str) &lt; maxlen)) {</a>
<a name="ln3213">      if (!redir_reg &amp;&amp; !redir_vname &amp;&amp; !capture_ga) {</a>
<a name="ln3214">        if (redir_fd != NULL) {</a>
<a name="ln3215">          putc(*s, redir_fd);</a>
<a name="ln3216">        }</a>
<a name="ln3217">      }</a>
<a name="ln3218">      if (verbose_fd != NULL) {</a>
<a name="ln3219">        putc(*s, verbose_fd);</a>
<a name="ln3220">      }</a>
<a name="ln3221">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln3222">        cur_col = 0;</a>
<a name="ln3223">      } else if (*s == '\t') {</a>
<a name="ln3224">        cur_col += (8 - cur_col % 8);</a>
<a name="ln3225">      } else {</a>
<a name="ln3226">        cur_col++;</a>
<a name="ln3227">      }</a>
<a name="ln3228">      s++;</a>
<a name="ln3229">    }</a>
<a name="ln3230"> </a>
<a name="ln3231">    if (msg_silent != 0) {      // should update msg_col</a>
<a name="ln3232">      msg_col = cur_col;</a>
<a name="ln3233">    }</a>
<a name="ln3234">  }</a>
<a name="ln3235">}</a>
<a name="ln3236"> </a>
<a name="ln3237">int redirecting(void)</a>
<a name="ln3238">{</a>
<a name="ln3239">  return redir_fd != NULL || *p_vfile != NUL</a>
<a name="ln3240">         || redir_reg || redir_vname || capture_ga != NULL;</a>
<a name="ln3241">}</a>
<a name="ln3242"> </a>
<a name="ln3243">/// Before giving verbose message.</a>
<a name="ln3244">/// Must always be called paired with verbose_leave()!</a>
<a name="ln3245">void verbose_enter(void)</a>
<a name="ln3246">{</a>
<a name="ln3247">  if (*p_vfile != NUL) {</a>
<a name="ln3248">    msg_silent++;</a>
<a name="ln3249">  }</a>
<a name="ln3250">}</a>
<a name="ln3251"> </a>
<a name="ln3252">/// After giving verbose message.</a>
<a name="ln3253">/// Must always be called paired with verbose_enter()!</a>
<a name="ln3254">void verbose_leave(void)</a>
<a name="ln3255">{</a>
<a name="ln3256">  if (*p_vfile != NUL) {</a>
<a name="ln3257">    if (--msg_silent &lt; 0) {</a>
<a name="ln3258">      msg_silent = 0;</a>
<a name="ln3259">    }</a>
<a name="ln3260">  }</a>
<a name="ln3261">}</a>
<a name="ln3262"> </a>
<a name="ln3263">/// Like verbose_enter() and set msg_scroll when displaying the message.</a>
<a name="ln3264">void verbose_enter_scroll(void)</a>
<a name="ln3265">{</a>
<a name="ln3266">  if (*p_vfile != NUL) {</a>
<a name="ln3267">    msg_silent++;</a>
<a name="ln3268">  } else {</a>
<a name="ln3269">    // always scroll up, don't overwrite</a>
<a name="ln3270">    msg_scroll = true;</a>
<a name="ln3271">  }</a>
<a name="ln3272">}</a>
<a name="ln3273"> </a>
<a name="ln3274">/// Like verbose_leave() and set cmdline_row when displaying the message.</a>
<a name="ln3275">void verbose_leave_scroll(void)</a>
<a name="ln3276">{</a>
<a name="ln3277">  if (*p_vfile != NUL) {</a>
<a name="ln3278">    if (--msg_silent &lt; 0) {</a>
<a name="ln3279">      msg_silent = 0;</a>
<a name="ln3280">    }</a>
<a name="ln3281">  } else {</a>
<a name="ln3282">    cmdline_row = msg_row;</a>
<a name="ln3283">  }</a>
<a name="ln3284">}</a>
<a name="ln3285"> </a>
<a name="ln3286">/// Called when 'verbosefile' is set: stop writing to the file.</a>
<a name="ln3287">void verbose_stop(void)</a>
<a name="ln3288">{</a>
<a name="ln3289">  if (verbose_fd != NULL) {</a>
<a name="ln3290">    fclose(verbose_fd);</a>
<a name="ln3291">    verbose_fd = NULL;</a>
<a name="ln3292">  }</a>
<a name="ln3293">  verbose_did_open = false;</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296">/// Open the file 'verbosefile'.</a>
<a name="ln3297">///</a>
<a name="ln3298">/// @return  FAIL or OK.</a>
<a name="ln3299">int verbose_open(void)</a>
<a name="ln3300">{</a>
<a name="ln3301">  if (verbose_fd == NULL &amp;&amp; !verbose_did_open) {</a>
<a name="ln3302">    // Only give the error message once.</a>
<a name="ln3303">    verbose_did_open = true;</a>
<a name="ln3304"> </a>
<a name="ln3305">    verbose_fd = os_fopen(p_vfile, &quot;a&quot;);</a>
<a name="ln3306">    if (verbose_fd == NULL) {</a>
<a name="ln3307">      semsg(_(e_notopen), p_vfile);</a>
<a name="ln3308">      return FAIL;</a>
<a name="ln3309">    }</a>
<a name="ln3310">  }</a>
<a name="ln3311">  return OK;</a>
<a name="ln3312">}</a>
<a name="ln3313"> </a>
<a name="ln3314">/// Give a warning message (for searching).</a>
<a name="ln3315">/// Use 'w' highlighting and may repeat the message after redrawing</a>
<a name="ln3316">void give_warning(const char *message, bool hl)</a>
<a name="ln3317">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3318">{</a>
<a name="ln3319">  // Don't do this for &quot;:silent&quot;.</a>
<a name="ln3320">  if (msg_silent != 0) {</a>
<a name="ln3321">    return;</a>
<a name="ln3322">  }</a>
<a name="ln3323"> </a>
<a name="ln3324">  // Don't want a hit-enter prompt here.</a>
<a name="ln3325">  no_wait_return++;</a>
<a name="ln3326"> </a>
<a name="ln3327">  set_vim_var_string(VV_WARNINGMSG, message, -1);</a>
<a name="ln3328">  XFREE_CLEAR(keep_msg);</a>
<a name="ln3329">  if (hl) {</a>
<a name="ln3330">    keep_msg_attr = HL_ATTR(HLF_W);</a>
<a name="ln3331">  } else {</a>
<a name="ln3332">    keep_msg_attr = 0;</a>
<a name="ln3333">  }</a>
<a name="ln3334"> </a>
<a name="ln3335">  if (msg_ext_kind == NULL) {</a>
<a name="ln3336">    msg_ext_set_kind(&quot;wmsg&quot;);</a>
<a name="ln3337">  }</a>
<a name="ln3338"> </a>
<a name="ln3339">  if (msg(message, keep_msg_attr) &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln3340">    set_keep_msg(message, keep_msg_attr);</a>
<a name="ln3341">  }</a>
<a name="ln3342">  msg_didout = false;  // Overwrite this message.</a>
<a name="ln3343">  msg_nowait = true;   // Don't wait for this message.</a>
<a name="ln3344">  msg_col = 0;</a>
<a name="ln3345"> </a>
<a name="ln3346">  no_wait_return--;</a>
<a name="ln3347">}</a>
<a name="ln3348"> </a>
<a name="ln3349">/// Shows a warning, with optional highlighting.</a>
<a name="ln3350">///</a>
<a name="ln3351">/// @param hl enable highlighting</a>
<a name="ln3352">/// @param fmt printf-style format message</a>
<a name="ln3353">///</a>
<a name="ln3354">/// @see smsg</a>
<a name="ln3355">/// @see semsg</a>
<a name="ln3356">void swmsg(bool hl, const char *const fmt, ...)</a>
<a name="ln3357">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln3358">{</a>
<a name="ln3359">  va_list args;</a>
<a name="ln3360"> </a>
<a name="ln3361">  va_start(args, fmt);</a>
<a name="ln3362">  vim_vsnprintf(IObuff, IOSIZE, fmt, args);</a>
<a name="ln3363">  va_end(args);</a>
<a name="ln3364"> </a>
<a name="ln3365">  give_warning(IObuff, hl);</a>
<a name="ln3366">}</a>
<a name="ln3367"> </a>
<a name="ln3368">/// Advance msg cursor to column &quot;col&quot;.</a>
<a name="ln3369">void msg_advance(int col)</a>
<a name="ln3370">{</a>
<a name="ln3371">  if (msg_silent != 0) {        // nothing to advance to</a>
<a name="ln3372">    msg_col = col;              // for redirection, may fill it up later</a>
<a name="ln3373">    return;</a>
<a name="ln3374">  }</a>
<a name="ln3375">  if (ui_has(kUIMessages)) {</a>
<a name="ln3376">    // TODO(bfredl): use byte count as a basic proxy.</a>
<a name="ln3377">    // later on we might add proper support for formatted messages.</a>
<a name="ln3378">    while (msg_ext_cur_len &lt; (size_t)col) {</a>
<a name="ln3379">      msg_putchar(' ');</a>
<a name="ln3380">    }</a>
<a name="ln3381">    return;</a>
<a name="ln3382">  }</a>
<a name="ln3383">  if (col &gt;= Columns) {         // not enough room</a>
<a name="ln3384">    col = Columns - 1;</a>
<a name="ln3385">  }</a>
<a name="ln3386">  if (cmdmsg_rl) {</a>
<a name="ln3387">    while (msg_col &gt; Columns - col) {</a>
<a name="ln3388">      msg_putchar(' ');</a>
<a name="ln3389">    }</a>
<a name="ln3390">  } else {</a>
<a name="ln3391">    while (msg_col &lt; col) {</a>
<a name="ln3392">      msg_putchar(' ');</a>
<a name="ln3393">    }</a>
<a name="ln3394">  }</a>
<a name="ln3395">}</a>
<a name="ln3396"> </a>
<a name="ln3397">/// Used for &quot;confirm()&quot; function, and the :confirm command prefix.</a>
<a name="ln3398">/// Versions which haven't got flexible dialogs yet, and console</a>
<a name="ln3399">/// versions, get this generic handler which uses the command line.</a>
<a name="ln3400">///</a>
<a name="ln3401">/// type  = one of:</a>
<a name="ln3402">///         VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC</a>
<a name="ln3403">/// title = title string (can be NULL for default)</a>
<a name="ln3404">/// (neither used in console dialogs at the moment)</a>
<a name="ln3405">///</a>
<a name="ln3406">/// Format of the &quot;buttons&quot; string:</a>
<a name="ln3407">/// &quot;Button1Name\nButton2Name\nButton3Name&quot;</a>
<a name="ln3408">/// The first button should normally be the default/accept</a>
<a name="ln3409">/// The second button should be the 'Cancel' button</a>
<a name="ln3410">/// Other buttons- use your imagination!</a>
<a name="ln3411">/// A '&amp;' in a button name becomes a shortcut, so each '&amp;' should be before a</a>
<a name="ln3412">/// different letter.</a>
<a name="ln3413">///</a>
<a name="ln3414">/// @param textfiel  IObuff for inputdialog(), NULL otherwise</a>
<a name="ln3415">/// @param ex_cmd  when true pressing : accepts default and starts Ex command</a>
<a name="ln3416">/// @returns 0 if cancelled, otherwise the nth button (1-indexed).</a>
<a name="ln3417">int do_dialog(int type, const char *title, const char *message, const char *buttons, int dfltbutton,</a>
<a name="ln3418">              const char *textfield, int ex_cmd)</a>
<a name="ln3419">{</a>
<a name="ln3420">  int retval = 0;</a>
<a name="ln3421">  char *hotkeys;</a>
<a name="ln3422">  int i;</a>
<a name="ln3423"> </a>
<a name="ln3424">  if (silent_mode      // No dialogs in silent mode (&quot;ex -s&quot;)</a>
<a name="ln3425">      || !ui_active()  // Without a UI Nvim waits for input forever.</a>
<a name="ln3426">      ) {</a>
<a name="ln3427">    return dfltbutton;  // return default option</a>
<a name="ln3428">  }</a>
<a name="ln3429"> </a>
<a name="ln3430">  int save_msg_silent = msg_silent;</a>
<a name="ln3431">  int oldState = State;</a>
<a name="ln3432"> </a>
<a name="ln3433">  msg_silent = 0;  // If dialog prompts for input, user needs to see it! #8788</a>
<a name="ln3434">  State = MODE_CONFIRM;</a>
<a name="ln3435">  setmouse();</a>
<a name="ln3436"> </a>
<a name="ln3437">  // Since we wait for a keypress, don't make the</a>
<a name="ln3438">  // user press RETURN as well afterwards.</a>
<a name="ln3439">  no_wait_return++;</a>
<a name="ln3440">  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);</a>
<a name="ln3441"> </a>
<a name="ln3442">  while (true) {</a>
<a name="ln3443">    // Get a typed character directly from the user.</a>
<a name="ln3444">    int c = get_keystroke(NULL);</a>
<a name="ln3445">    switch (c) {</a>
<a name="ln3446">    case CAR:                 // User accepts default option</a>
<a name="ln3447">    case NL:</a>
<a name="ln3448">      retval = dfltbutton;</a>
<a name="ln3449">      break;</a>
<a name="ln3450">    case Ctrl_C:              // User aborts/cancels</a>
<a name="ln3451">    case ESC:</a>
<a name="ln3452">      retval = 0;</a>
<a name="ln3453">      break;</a>
<a name="ln3454">    default:                  // Could be a hotkey?</a>
<a name="ln3455">      if (c &lt; 0) {            // special keys are ignored here</a>
<a name="ln3456">        continue;</a>
<a name="ln3457">      }</a>
<a name="ln3458">      if (c == ':' &amp;&amp; ex_cmd) {</a>
<a name="ln3459">        retval = dfltbutton;</a>
<a name="ln3460">        ins_char_typebuf(':', 0);</a>
<a name="ln3461">        break;</a>
<a name="ln3462">      }</a>
<a name="ln3463"> </a>
<a name="ln3464">      // Make the character lowercase, as chars in &quot;hotkeys&quot; are.</a>
<a name="ln3465">      c = mb_tolower(c);</a>
<a name="ln3466">      retval = 1;</a>
<a name="ln3467">      for (i = 0; hotkeys[i]; i++) {</a>
<a name="ln3468">        if (utf_ptr2char(hotkeys + i) == c) {</a>
<a name="ln3469">          break;</a>
<a name="ln3470">        }</a>
<a name="ln3471">        i += utfc_ptr2len(hotkeys + i) - 1;</a>
<a name="ln3472">        retval++;</a>
<a name="ln3473">      }</a>
<a name="ln3474">      if (hotkeys[i]) {</a>
<a name="ln3475">        break;</a>
<a name="ln3476">      }</a>
<a name="ln3477">      // No hotkey match, so keep waiting</a>
<a name="ln3478">      continue;</a>
<a name="ln3479">    }</a>
<a name="ln3480">    break;</a>
<a name="ln3481">  }</a>
<a name="ln3482"> </a>
<a name="ln3483">  xfree(hotkeys);</a>
<a name="ln3484"> </a>
<a name="ln3485">  msg_silent = save_msg_silent;</a>
<a name="ln3486">  State = oldState;</a>
<a name="ln3487">  setmouse();</a>
<a name="ln3488">  no_wait_return--;</a>
<a name="ln3489">  msg_end_prompt();</a>
<a name="ln3490"> </a>
<a name="ln3491">  return retval;</a>
<a name="ln3492">}</a>
<a name="ln3493"> </a>
<a name="ln3494">/// Copy one character from &quot;*from&quot; to &quot;*to&quot;, taking care of multi-byte</a>
<a name="ln3495">/// characters.  Return the length of the character in bytes.</a>
<a name="ln3496">///</a>
<a name="ln3497">/// @param lowercase  make character lower case</a>
<a name="ln3498">static int copy_char(const char *from, char *to, bool lowercase)</a>
<a name="ln3499">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3500">{</a>
<a name="ln3501">  if (lowercase) {</a>
<a name="ln3502">    int c = mb_tolower(utf_ptr2char(from));</a>
<a name="ln3503">    return utf_char2bytes(c, to);</a>
<a name="ln3504">  }</a>
<a name="ln3505">  int len = utfc_ptr2len(from);</a>
<a name="ln3506">  memmove(to, from, (size_t)len);</a>
<a name="ln3507">  return len;</a>
<a name="ln3508">}</a>
<a name="ln3509"> </a>
<a name="ln3510">#define HAS_HOTKEY_LEN 30</a>
<a name="ln3511">#define HOTK_LEN MB_MAXBYTES</a>
<a name="ln3512"> </a>
<a name="ln3513">/// Allocates memory for dialog string &amp; for storing hotkeys</a>
<a name="ln3514">///</a>
<a name="ln3515">/// Finds the size of memory required for the confirm_msg &amp; for storing hotkeys</a>
<a name="ln3516">/// and then allocates the memory for them.</a>
<a name="ln3517">/// has_hotkey array is also filled-up.</a>
<a name="ln3518">///</a>
<a name="ln3519">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3520">/// @param buttons String containing button names</a>
<a name="ln3521">/// @param[out] has_hotkey An element in this array is set to true if</a>
<a name="ln3522">///                        corresponding button has a hotkey</a>
<a name="ln3523">///</a>
<a name="ln3524">/// @return Pointer to memory allocated for storing hotkeys</a>
<a name="ln3525">static char *console_dialog_alloc(const char *message, const char *buttons, bool has_hotkey[])</a>
<a name="ln3526">{</a>
<a name="ln3527">  int lenhotkey = HOTK_LEN;  // count first button</a>
<a name="ln3528">  has_hotkey[0] = false;</a>
<a name="ln3529"> </a>
<a name="ln3530">  // Compute the size of memory to allocate.</a>
<a name="ln3531">  int len = 0;</a>
<a name="ln3532">  int idx = 0;</a>
<a name="ln3533">  const char *r = buttons;</a>
<a name="ln3534">  while (*r) {</a>
<a name="ln3535">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3536">      len += 3;                         // '\n' -&gt; ', '; 'x' -&gt; '(x)'</a>
<a name="ln3537">      lenhotkey += HOTK_LEN;            // each button needs a hotkey</a>
<a name="ln3538">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3539">        has_hotkey[++idx] = false;</a>
<a name="ln3540">      }</a>
<a name="ln3541">    } else if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3542">      r++;</a>
<a name="ln3543">      len++;                    // '&amp;a' -&gt; '[a]'</a>
<a name="ln3544">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3545">        has_hotkey[idx] = true;</a>
<a name="ln3546">      }</a>
<a name="ln3547">    }</a>
<a name="ln3548"> </a>
<a name="ln3549">    // Advance to the next character</a>
<a name="ln3550">    MB_PTR_ADV(r);</a>
<a name="ln3551">  }</a>
<a name="ln3552"> </a>
<a name="ln3553">  len += (int)(strlen(message)</a>
<a name="ln3554">               + 2                          // for the NL's</a>
<a name="ln3555">               + strlen(buttons)</a>
<a name="ln3556">               + 3);                        // for the &quot;: &quot; and NUL</a>
<a name="ln3557">  lenhotkey++;                               // for the NUL</a>
<a name="ln3558"> </a>
<a name="ln3559">  // If no hotkey is specified, first char is used.</a>
<a name="ln3560">  if (!has_hotkey[0]) {</a>
<a name="ln3561">    len += 2;                                // &quot;x&quot; -&gt; &quot;[x]&quot;</a>
<a name="ln3562">  }</a>
<a name="ln3563"> </a>
<a name="ln3564">  // Now allocate space for the strings</a>
<a name="ln3565">  xfree(confirm_msg);</a>
<a name="ln3566">  confirm_msg = xmalloc((size_t)len);</a>
<a name="ln3567">  *confirm_msg = NUL;</a>
<a name="ln3568"> </a>
<a name="ln3569">  return xmalloc((size_t)lenhotkey);</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">/// Format the dialog string, and display it at the bottom of</a>
<a name="ln3573">/// the screen. Return a string of hotkey chars (if defined) for</a>
<a name="ln3574">/// each 'button'. If a button has no hotkey defined, the first character of</a>
<a name="ln3575">/// the button is used.</a>
<a name="ln3576">/// The hotkeys can be multi-byte characters, but without combining chars.</a>
<a name="ln3577">///</a>
<a name="ln3578">/// @return  an allocated string with hotkeys.</a>
<a name="ln3579">static char *msg_show_console_dialog(const char *message, const char *buttons, int dfltbutton)</a>
<a name="ln3580">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3581">{</a>
<a name="ln3582">  bool has_hotkey[HAS_HOTKEY_LEN] = { false };</a>
<a name="ln3583">  char *hotk = console_dialog_alloc(message, buttons, has_hotkey);</a>
<a name="ln3584"> </a>
<a name="ln3585">  copy_hotkeys_and_msg(message, buttons, dfltbutton, has_hotkey, hotk);</a>
<a name="ln3586"> </a>
<a name="ln3587">  display_confirm_msg();</a>
<a name="ln3588">  return hotk;</a>
<a name="ln3589">}</a>
<a name="ln3590"> </a>
<a name="ln3591">/// Copies hotkeys &amp; dialog message into the memory allocated for it</a>
<a name="ln3592">///</a>
<a name="ln3593">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3594">/// @param buttons String containing button names</a>
<a name="ln3595">/// @param default_button_idx Number of default button</a>
<a name="ln3596">/// @param has_hotkey An element in this array is true if corresponding button</a>
<a name="ln3597">///                   has a hotkey</a>
<a name="ln3598">/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied</a>
<a name="ln3599">static void copy_hotkeys_and_msg(const char *message, const char *buttons, int default_button_idx,</a>
<a name="ln3600">                                 const bool has_hotkey[], char *hotkeys_ptr)</a>
<a name="ln3601">{</a>
<a name="ln3602">  *confirm_msg = '\n';</a>
<a name="ln3603">  STRCPY(confirm_msg + 1, message);</a>
<a name="ln3604"> </a>
<a name="ln3605">  char *msgp = confirm_msg + 1 + strlen(message);</a>
<a name="ln3606"> </a>
<a name="ln3607">  // Define first default hotkey. Keep the hotkey string NUL</a>
<a name="ln3608">  // terminated to avoid reading past the end.</a>
<a name="ln3609">  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3610"> </a>
<a name="ln3611">  // Remember where the choices start, displaying starts here when</a>
<a name="ln3612">  // &quot;hotkeys_ptr&quot; typed at the more prompt.</a>
<a name="ln3613">  confirm_msg_tail = msgp;</a>
<a name="ln3614">  *msgp++ = '\n';</a>
<a name="ln3615"> </a>
<a name="ln3616">  bool first_hotkey = false;  // Is the first char of button a hotkey</a>
<a name="ln3617">  if (!has_hotkey[0]) {</a>
<a name="ln3618">    first_hotkey = true;     // If no hotkey is specified, first char is used</a>
<a name="ln3619">  }</a>
<a name="ln3620"> </a>
<a name="ln3621">  int idx = 0;</a>
<a name="ln3622">  const char *r = buttons;</a>
<a name="ln3623">  while (*r) {</a>
<a name="ln3624">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3625">      *msgp++ = ',';</a>
<a name="ln3626">      *msgp++ = ' ';                    // '\n' -&gt; ', '</a>
<a name="ln3627"> </a>
<a name="ln3628">      // Advance to next hotkey and set default hotkey</a>
<a name="ln3629">      hotkeys_ptr += strlen(hotkeys_ptr);</a>
<a name="ln3630">      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3631"> </a>
<a name="ln3632">      if (default_button_idx) {</a>
<a name="ln3633">        default_button_idx--;</a>
<a name="ln3634">      }</a>
<a name="ln3635"> </a>
<a name="ln3636">      // If no hotkey is specified, first char is used.</a>
<a name="ln3637">      if (idx &lt; HAS_HOTKEY_LEN - 1 &amp;&amp; !has_hotkey[++idx]) {</a>
<a name="ln3638">        first_hotkey = true;</a>
<a name="ln3639">      }</a>
<a name="ln3640">    } else if (*r == DLG_HOTKEY_CHAR || first_hotkey) {</a>
<a name="ln3641">      if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3642">        r++;</a>
<a name="ln3643">      }</a>
<a name="ln3644"> </a>
<a name="ln3645">      first_hotkey = false;</a>
<a name="ln3646">      if (*r == DLG_HOTKEY_CHAR) {                 // '&amp;&amp;a' -&gt; '&amp;a'</a>
<a name="ln3647">        *msgp++ = *r;</a>
<a name="ln3648">      } else {</a>
<a name="ln3649">        // '&amp;a' -&gt; '[a]'</a>
<a name="ln3650">        *msgp++ = (default_button_idx == 1) ? '[' : '(';</a>
<a name="ln3651">        msgp += copy_char(r, msgp, false);</a>
<a name="ln3652">        *msgp++ = (default_button_idx == 1) ? ']' : ')';</a>
<a name="ln3653"> </a>
<a name="ln3654">        // redefine hotkey</a>
<a name="ln3655">        hotkeys_ptr[copy_char(r, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3656">      }</a>
<a name="ln3657">    } else {</a>
<a name="ln3658">      // everything else copy literally</a>
<a name="ln3659">      msgp += copy_char(r, msgp, false);</a>
<a name="ln3660">    }</a>
<a name="ln3661"> </a>
<a name="ln3662">    // advance to the next character</a>
<a name="ln3663">    MB_PTR_ADV(r);</a>
<a name="ln3664">  }</a>
<a name="ln3665"> </a>
<a name="ln3666">  *msgp++ = ':';</a>
<a name="ln3667">  *msgp++ = ' ';</a>
<a name="ln3668">  *msgp = NUL;</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671">/// Display the &quot;:confirm&quot; message.  Also called when screen resized.</a>
<a name="ln3672">void display_confirm_msg(void)</a>
<a name="ln3673">{</a>
<a name="ln3674">  // Avoid that 'q' at the more prompt truncates the message here.</a>
<a name="ln3675">  confirm_msg_used++;</a>
<a name="ln3676">  if (confirm_msg != NULL) {</a>
<a name="ln3677">    msg_ext_set_kind(&quot;confirm&quot;);</a>
<a name="ln3678">    msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));</a>
<a name="ln3679">  }</a>
<a name="ln3680">  confirm_msg_used--;</a>
<a name="ln3681">}</a>
<a name="ln3682"> </a>
<a name="ln3683">int vim_dialog_yesno(int type, char *title, char *message, int dflt)</a>
<a name="ln3684">{</a>
<a name="ln3685">  if (do_dialog(type,</a>
<a name="ln3686">                title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3687">                message,</a>
<a name="ln3688">                _(&quot;&amp;Yes\n&amp;No&quot;), dflt, NULL, false) == 1) {</a>
<a name="ln3689">    return VIM_YES;</a>
<a name="ln3690">  }</a>
<a name="ln3691">  return VIM_NO;</a>
<a name="ln3692">}</a>
<a name="ln3693"> </a>
<a name="ln3694">int vim_dialog_yesnocancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3695">{</a>
<a name="ln3696">  switch (do_dialog(type,</a>
<a name="ln3697">                    title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3698">                    message,</a>
<a name="ln3699">                    _(&quot;&amp;Yes\n&amp;No\n&amp;Cancel&quot;), dflt, NULL, false)) {</a>
<a name="ln3700">  case 1:</a>
<a name="ln3701">    return VIM_YES;</a>
<a name="ln3702">  case 2:</a>
<a name="ln3703">    return VIM_NO;</a>
<a name="ln3704">  }</a>
<a name="ln3705">  return VIM_CANCEL;</a>
<a name="ln3706">}</a>
<a name="ln3707"> </a>
<a name="ln3708">int vim_dialog_yesnoallcancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3709">{</a>
<a name="ln3710">  switch (do_dialog(type,</a>
<a name="ln3711">                    title == NULL ? &quot;Question&quot; : title,</a>
<a name="ln3712">                    message,</a>
<a name="ln3713">                    _(&quot;&amp;Yes\n&amp;No\nSave &amp;All\n&amp;Discard All\n&amp;Cancel&quot;),</a>
<a name="ln3714">                    dflt, NULL, false)) {</a>
<a name="ln3715">  case 1:</a>
<a name="ln3716">    return VIM_YES;</a>
<a name="ln3717">  case 2:</a>
<a name="ln3718">    return VIM_NO;</a>
<a name="ln3719">  case 3:</a>
<a name="ln3720">    return VIM_ALL;</a>
<a name="ln3721">  case 4:</a>
<a name="ln3722">    return VIM_DISCARDALL;</a>
<a name="ln3723">  }</a>
<a name="ln3724">  return VIM_CANCEL;</a>
<a name="ln3725">}</a>
<a name="ln3726"> </a>
<a name="ln3727">/// Check if there should be a delay to allow the user to see a message.</a>
<a name="ln3728">///</a>
<a name="ln3729">/// Used before clearing or redrawing the screen or the command line.</a>
<a name="ln3730">void msg_check_for_delay(bool check_msg_scroll)</a>
<a name="ln3731">{</a>
<a name="ln3732">  if ((emsg_on_display || (check_msg_scroll &amp;&amp; msg_scroll))</a>
<a name="ln3733">      &amp;&amp; !did_wait_return</a>
<a name="ln3734">      &amp;&amp; emsg_silent == 0</a>
<a name="ln3735">      &amp;&amp; !in_assert_fails) {</a>
<a name="ln3736">    ui_flush();</a>
<a name="ln3737">    os_delay(1006L, true);</a>
<a name="ln3738">    emsg_on_display = false;</a>
<a name="ln3739">    if (check_msg_scroll) {</a>
<a name="ln3740">      msg_scroll = false;</a>
<a name="ln3741">    }</a>
<a name="ln3742">  }</a>
<a name="ln3743">}</a>
</code></pre>
<div class="balloon" rel="491"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="502"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="775"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="794"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="844"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="871"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="889"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2083"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="3361"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>