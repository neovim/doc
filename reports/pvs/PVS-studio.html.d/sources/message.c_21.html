<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// message.c: functions for displaying messages on the command line</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;stdarg.h&gt;</a>
<a name="ln9">#include &lt;stdbool.h&gt;</a>
<a name="ln10">#include &lt;stddef.h&gt;</a>
<a name="ln11">#include &lt;stdio.h&gt;</a>
<a name="ln12">#include &lt;stdlib.h&gt;</a>
<a name="ln13">#include &lt;string.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln16">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln17">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln18">#include &quot;nvim/channel.h&quot;</a>
<a name="ln19">#include &quot;nvim/charset.h&quot;</a>
<a name="ln20">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln21">#include &quot;nvim/eval.h&quot;</a>
<a name="ln22">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln23">#include &quot;nvim/event/defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln25">#include &quot;nvim/event/multiqueue.h&quot;</a>
<a name="ln26">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln27">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln28">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln29">#include &quot;nvim/garray.h&quot;</a>
<a name="ln30">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln31">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln32">#include &quot;nvim/globals.h&quot;</a>
<a name="ln33">#include &quot;nvim/grid.h&quot;</a>
<a name="ln34">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln35">#include &quot;nvim/indent.h&quot;</a>
<a name="ln36">#include &quot;nvim/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln38">#include &quot;nvim/log.h&quot;</a>
<a name="ln39">#include &quot;nvim/main.h&quot;</a>
<a name="ln40">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln41">#include &quot;nvim/memory.h&quot;</a>
<a name="ln42">#include &quot;nvim/message.h&quot;</a>
<a name="ln43">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln44">#include &quot;nvim/ops.h&quot;</a>
<a name="ln45">#include &quot;nvim/option.h&quot;</a>
<a name="ln46">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln47">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln48">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln49">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln50">#include &quot;nvim/pos.h&quot;</a>
<a name="ln51">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln52">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln53">#include &quot;nvim/strings.h&quot;</a>
<a name="ln54">#include &quot;nvim/ui.h&quot;</a>
<a name="ln55">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln56">#include &quot;nvim/vim.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">// To be able to scroll back at the &quot;more&quot; and &quot;hit-enter&quot; prompts we need to</a>
<a name="ln59">// store the displayed text and remember where screen lines start.</a>
<a name="ln60">typedef struct msgchunk_S msgchunk_T;</a>
<a name="ln61">struct msgchunk_S {</a>
<a name="ln62">  msgchunk_T *sb_next;</a>
<a name="ln63">  msgchunk_T *sb_prev;</a>
<a name="ln64">  char sb_eol;                  // true when line ends after this text</a>
<a name="ln65">  int sb_msg_col;               // column in which text starts</a>
<a name="ln66">  int sb_attr;                  // text attributes</a>
<a name="ln67">  char sb_text[];               // text to be displayed</a>
<a name="ln68">};</a>
<a name="ln69"> </a>
<a name="ln70">// Magic chars used in confirm dialog strings</a>
<a name="ln71">enum {</a>
<a name="ln72">  DLG_BUTTON_SEP = '\n',</a>
<a name="ln73">  DLG_HOTKEY_CHAR = '&amp;',</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">static int confirm_msg_used = false;            // displaying confirm_msg</a>
<a name="ln77">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln78"># include &quot;message.c.generated.h&quot;</a>
<a name="ln79">#endif</a>
<a name="ln80">static char *confirm_msg = NULL;            // &quot;:confirm&quot; message</a>
<a name="ln81">static char *confirm_msg_tail;              // tail of confirm_msg</a>
<a name="ln82"> </a>
<a name="ln83">MessageHistoryEntry *first_msg_hist = NULL;</a>
<a name="ln84">MessageHistoryEntry *last_msg_hist = NULL;</a>
<a name="ln85">static int msg_hist_len = 0;</a>
<a name="ln86"> </a>
<a name="ln87">static FILE *verbose_fd = NULL;</a>
<a name="ln88">static int verbose_did_open = false;</a>
<a name="ln89"> </a>
<a name="ln90">bool keep_msg_more = false;    // keep_msg was set by msgmore()</a>
<a name="ln91"> </a>
<a name="ln92">// When writing messages to the screen, there are many different situations.</a>
<a name="ln93">// A number of variables is used to remember the current state:</a>
<a name="ln94">// msg_didany       true when messages were written since the last time the</a>
<a name="ln95">//                  user reacted to a prompt.</a>
<a name="ln96">//                  Reset: After hitting a key for the hit-return prompt,</a>
<a name="ln97">//                  hitting &lt;CR&gt; for the command line or input().</a>
<a name="ln98">//                  Set: When any message is written to the screen.</a>
<a name="ln99">// msg_didout       true when something was written to the current line.</a>
<a name="ln100">//                  Reset: When advancing to the next line, when the current</a>
<a name="ln101">//                  text can be overwritten.</a>
<a name="ln102">//                  Set: When any message is written to the screen.</a>
<a name="ln103">// msg_nowait       No extra delay for the last drawn message.</a>
<a name="ln104">//                  Used in normal_cmd() before the mode message is drawn.</a>
<a name="ln105">// emsg_on_display  There was an error message recently.  Indicates that there</a>
<a name="ln106">//                  should be a delay before redrawing.</a>
<a name="ln107">// msg_scroll       The next message should not overwrite the current one.</a>
<a name="ln108">// msg_scrolled     How many lines the screen has been scrolled (because of</a>
<a name="ln109">//                  messages).  Used in update_screen() to scroll the screen</a>
<a name="ln110">//                  back.  Incremented each time the screen scrolls a line.</a>
<a name="ln111">// msg_scrolled_ign  true when msg_scrolled is non-zero and msg_puts_attr()</a>
<a name="ln112">//                  writes something without scrolling should not make</a>
<a name="ln113">//                  need_wait_return to be set.  This is a hack to make &quot;:ts&quot;</a>
<a name="ln114">//                  work without an extra prompt.</a>
<a name="ln115">// lines_left       Number of lines available for messages before the</a>
<a name="ln116">//                  more-prompt is to be given.  -1 when not set.</a>
<a name="ln117">// need_wait_return true when the hit-return prompt is needed.</a>
<a name="ln118">//                  Reset: After giving the hit-return prompt, when the user</a>
<a name="ln119">//                  has answered some other prompt.</a>
<a name="ln120">//                  Set: When the ruler or typeahead display is overwritten,</a>
<a name="ln121">//                  scrolling the screen for some message.</a>
<a name="ln122">// keep_msg         Message to be displayed after redrawing the screen, in</a>
<a name="ln123">//                  main_loop().</a>
<a name="ln124">//                  This is an allocated string or NULL when not used.</a>
<a name="ln125"> </a>
<a name="ln126">// Extended msg state, currently used for external UIs with ext_messages</a>
<a name="ln127">static const char *msg_ext_kind = NULL;</a>
<a name="ln128">static Array msg_ext_chunks = ARRAY_DICT_INIT;</a>
<a name="ln129">static garray_T msg_ext_last_chunk = GA_INIT(sizeof(char), 40);</a>
<a name="ln130">static sattr_T msg_ext_last_attr = -1;</a>
<a name="ln131">static size_t msg_ext_cur_len = 0;</a>
<a name="ln132"> </a>
<a name="ln133">static bool msg_ext_overwrite = false;  ///&lt; will overwrite last message</a>
<a name="ln134">static int msg_ext_visible = 0;  ///&lt; number of messages currently visible</a>
<a name="ln135"> </a>
<a name="ln136">static bool msg_ext_history_visible = false;</a>
<a name="ln137"> </a>
<a name="ln138">/// Shouldn't clear message after leaving cmdline</a>
<a name="ln139">static bool msg_ext_keep_after_cmdline = false;</a>
<a name="ln140"> </a>
<a name="ln141">static int msg_grid_pos_at_flush = 0;</a>
<a name="ln142"> </a>
<a name="ln143">static void ui_ext_msg_set_pos(int row, bool scrolled)</a>
<a name="ln144">{</a>
<a name="ln145">  char buf[MAX_MCO + 1];</a>
<a name="ln146">  size_t size = (size_t)utf_char2bytes(curwin-&gt;w_p_fcs_chars.msgsep, buf);</a>
<a name="ln147">  buf[size] = '\0';</a>
<a name="ln148">  ui_call_msg_set_pos(msg_grid.handle, row, scrolled,</a>
<a name="ln149">                      (String){ .data = buf, .size = size });</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">void msg_grid_set_pos(int row, bool scrolled)</a>
<a name="ln153">{</a>
<a name="ln154">  if (!msg_grid.throttled) {</a>
<a name="ln155">    ui_ext_msg_set_pos(row, scrolled);</a>
<a name="ln156">    msg_grid_pos_at_flush = row;</a>
<a name="ln157">  }</a>
<a name="ln158">  msg_grid_pos = row;</a>
<a name="ln159">  if (msg_grid.chars) {</a>
<a name="ln160">    msg_grid_adj.row_offset = -row;</a>
<a name="ln161">  }</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">bool msg_use_grid(void)</a>
<a name="ln165">{</a>
<a name="ln166">  return default_grid.chars &amp;&amp; !ui_has(kUIMessages);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">void msg_grid_validate(void)</a>
<a name="ln170">{</a>
<a name="ln171">  grid_assign_handle(&amp;msg_grid);</a>
<a name="ln172">  bool should_alloc = msg_use_grid();</a>
<a name="ln173">  int max_rows = Rows - (int)p_ch;</a>
<a name="ln174">  if (should_alloc &amp;&amp; (msg_grid.rows != Rows || msg_grid.cols != Columns</a>
<a name="ln175">                       || !msg_grid.chars)) {</a>
<a name="ln176">    // TODO(bfredl): eventually should be set to &quot;invalid&quot;. I e all callers</a>
<a name="ln177">    // will use the grid including clear to EOS if necessary.</a>
<a name="ln178">    grid_alloc(&amp;msg_grid, Rows, Columns, false, true);</a>
<a name="ln179">    msg_grid.zindex = kZIndexMessages;</a>
<a name="ln180"> </a>
<a name="ln181">    xfree(msg_grid.dirty_col);</a>
<a name="ln182">    msg_grid.dirty_col = xcalloc((size_t)Rows, sizeof(*msg_grid.dirty_col));</a>
<a name="ln183"> </a>
<a name="ln184">    // Tricky: allow resize while pager or ex mode is active</a>
<a name="ln185">    int pos = (State &amp; MODE_ASKMORE) ? 0 : MAX(max_rows - msg_scrolled, 0);</a>
<a name="ln186">    msg_grid.throttled = false;  // don't throttle in 'cmdheight' area</a>
<a name="ln187">    msg_grid_set_pos(pos, msg_scrolled);</a>
<a name="ln188">    ui_comp_put_grid(&amp;msg_grid, pos, 0, msg_grid.rows, msg_grid.cols,</a>
<a name="ln189">                     false, true);</a>
<a name="ln190">    ui_call_grid_resize(msg_grid.handle, msg_grid.cols, msg_grid.rows);</a>
<a name="ln191"> </a>
<a name="ln192">    msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln193">    msg_grid.focusable = false;</a>
<a name="ln194">    msg_grid_adj.target = &amp;msg_grid;</a>
<a name="ln195">  } else if (!should_alloc &amp;&amp; msg_grid.chars) {</a>
<a name="ln196">    ui_comp_remove_grid(&amp;msg_grid);</a>
<a name="ln197">    grid_free(&amp;msg_grid);</a>
<a name="ln198">    XFREE_CLEAR(msg_grid.dirty_col);</a>
<a name="ln199">    ui_call_grid_destroy(msg_grid.handle);</a>
<a name="ln200">    msg_grid.throttled = false;</a>
<a name="ln201">    msg_grid_adj.row_offset = 0;</a>
<a name="ln202">    msg_grid_adj.target = &amp;default_grid;</a>
<a name="ln203">    redraw_cmdline = true;</a>
<a name="ln204">  } else if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; msg_grid_pos != max_rows) {</a>
<a name="ln205">    msg_grid_set_pos(max_rows, false);</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; cmdline_row &lt; msg_grid_pos) {</a>
<a name="ln209">    // TODO(bfredl): this should already be the case, but fails in some</a>
<a name="ln210">    // &quot;batched&quot; executions where compute_cmdrow() use stale positions or</a>
<a name="ln211">    // something.</a>
<a name="ln212">    cmdline_row = msg_grid_pos;</a>
<a name="ln213">  }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">/// Like msg() but keep it silent when 'verbosefile' is set.</a>
<a name="ln217">int verb_msg(const char *s)</a>
<a name="ln218">{</a>
<a name="ln219">  verbose_enter();</a>
<a name="ln220">  int n = msg_attr_keep(s, 0, false, false);</a>
<a name="ln221">  verbose_leave();</a>
<a name="ln222"> </a>
<a name="ln223">  return n;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/// Displays the string 's' on the status line</a>
<a name="ln227">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln228">///</a>
<a name="ln229">/// @return  true if wait_return() not called</a>
<a name="ln230">int msg(const char *s, const int attr)</a>
<a name="ln231">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln232">{</a>
<a name="ln233">  return msg_attr_keep(s, attr, false, false);</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/// Similar to msg_outtrans, but support newlines and tabs.</a>
<a name="ln237">void msg_multiline(const char *s, int attr, bool check_int, bool *need_clear)</a>
<a name="ln238">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln239">{</a>
<a name="ln240">  const char *next_spec = s;</a>
<a name="ln241"> </a>
<a name="ln242">  while (next_spec != NULL) {</a>
<a name="ln243">    if (check_int &amp;&amp; got_int) {</a>
<a name="ln244">      return;</a>
<a name="ln245">    }</a>
<a name="ln246">    next_spec = strpbrk(s, &quot;\t\n\r&quot;);</a>
<a name="ln247"> </a>
<a name="ln248">    if (next_spec != NULL) {</a>
<a name="ln249">      // Printing all char that are before the char found by strpbrk</a>
<a name="ln250">      msg_outtrans_len(s, (int)(next_spec - s), attr);</a>
<a name="ln251"> </a>
<a name="ln252">      if (*next_spec != TAB &amp;&amp; *need_clear) {</a>
<a name="ln253">        msg_clr_eos();</a>
<a name="ln254">        *need_clear = false;</a>
<a name="ln255">      }</a>
<a name="ln256">      msg_putchar_attr((uint8_t)(*next_spec), attr);</a>
<a name="ln257">      s = next_spec + 1;</a>
<a name="ln258">    }</a>
<a name="ln259">  }</a>
<a name="ln260"> </a>
<a name="ln261">  // Print the rest of the message. We know there is no special</a>
<a name="ln262">  // character because strpbrk returned NULL</a>
<a name="ln263">  if (*s != NUL) {</a>
<a name="ln264">    msg_outtrans(s, attr);</a>
<a name="ln265">  }</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">void msg_multiattr(HlMessage hl_msg, const char *kind, bool history)</a>
<a name="ln269">{</a>
<a name="ln270">  no_wait_return++;</a>
<a name="ln271">  msg_start();</a>
<a name="ln272">  msg_clr_eos();</a>
<a name="ln273">  bool need_clear = false;</a>
<a name="ln274">  msg_ext_set_kind(kind);</a>
<a name="ln275">  for (uint32_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln276">    HlMessageChunk chunk = kv_A(hl_msg, i);</a>
<a name="ln277">    msg_multiline(chunk.text.data, chunk.attr, true, &amp;need_clear);</a>
<a name="ln278">  }</a>
<a name="ln279">  if (history &amp;&amp; kv_size(hl_msg)) {</a>
<a name="ln280">    add_msg_hist_multiattr(NULL, 0, 0, true, hl_msg);</a>
<a name="ln281">  }</a>
<a name="ln282">  no_wait_return--;</a>
<a name="ln283">  msg_end();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/// @param keep set keep_msg if it doesn't scroll</a>
<a name="ln287">bool msg_attr_keep(const char *s, int attr, bool keep, bool multiline)</a>
<a name="ln288">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln289">{</a>
<a name="ln290">  static int entered = 0;</a>
<a name="ln291">  int retval;</a>
<a name="ln292">  char *buf = NULL;</a>
<a name="ln293"> </a>
<a name="ln294">  if (keep &amp;&amp; multiline) {</a>
<a name="ln295">    // Not implemented. 'multiline' is only used by nvim-added messages,</a>
<a name="ln296">    // which should avoid 'keep' behavior (just show the message at</a>
<a name="ln297">    // the correct time already).</a>
<a name="ln298">    abort();</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  // Skip messages not match &quot;:filter pattern&quot;.</a>
<a name="ln302">  // Don't filter when there is an error.</a>
<a name="ln303">  if (!emsg_on_display &amp;&amp; message_filtered(s)) {</a>
<a name="ln304">    return true;</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  if (attr == 0) {</a>
<a name="ln308">    set_vim_var_string(VV_STATUSMSG, s, -1);</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // It is possible that displaying a messages causes a problem (e.g.,</a>
<a name="ln312">  // when redrawing the window), which causes another message, etc..    To</a>
<a name="ln313">  // break this loop, limit the recursiveness to 3 levels.</a>
<a name="ln314">  if (entered &gt;= 3) {</a>
<a name="ln315">    return true;</a>
<a name="ln316">  }</a>
<a name="ln317">  entered++;</a>
<a name="ln318"> </a>
<a name="ln319">  // Add message to history (unless it's a repeated kept message or a</a>
<a name="ln320">  // truncated message)</a>
<a name="ln321">  if (s != keep_msg</a>
<a name="ln322">      || (*s != '&lt;'</a>
<a name="ln323">          &amp;&amp; last_msg_hist != NULL</a>
<a name="ln324">          &amp;&amp; last_msg_hist-&gt;msg != NULL</a>
<a name="ln325">          &amp;&amp; strcmp(s, last_msg_hist-&gt;msg) != 0)) {</a>
<a name="ln326">    add_msg_hist(s, -1, attr, multiline);</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  // Truncate the message if needed.</a>
<a name="ln330">  msg_start();</a>
<a name="ln331">  buf = msg_strtrunc(s, false);</a>
<a name="ln332">  if (buf != NULL) {</a>
<a name="ln333">    s = buf;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336">  bool need_clear = true;</a>
<a name="ln337">  if (multiline) {</a>
<a name="ln338">    msg_multiline(s, attr, false, &amp;need_clear);</a>
<a name="ln339">  } else {</a>
<a name="ln340">    msg_outtrans(s, attr);</a>
<a name="ln341">  }</a>
<a name="ln342">  if (need_clear) {</a>
<a name="ln343">    msg_clr_eos();</a>
<a name="ln344">  }</a>
<a name="ln345">  retval = msg_end();</a>
<a name="ln346"> </a>
<a name="ln347">  if (keep &amp;&amp; retval &amp;&amp; vim_strsize(s) &lt; (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln348">    set_keep_msg(s, 0);</a>
<a name="ln349">  }</a>
<a name="ln350"> </a>
<a name="ln351">  need_fileinfo = false;</a>
<a name="ln352"> </a>
<a name="ln353">  xfree(buf);</a>
<a name="ln354">  entered--;</a>
<a name="ln355">  return retval;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">/// Truncate a string such that it can be printed without causing a scroll.</a>
<a name="ln359">///</a>
<a name="ln360">/// @return  an allocated string or NULL when no truncating is done.</a>
<a name="ln361">///</a>
<a name="ln362">/// @param force  always truncate</a>
<a name="ln363">char *msg_strtrunc(const char *s, int force)</a>
<a name="ln364">{</a>
<a name="ln365">  char *buf = NULL;</a>
<a name="ln366"> </a>
<a name="ln367">  // May truncate message to avoid a hit-return prompt</a>
<a name="ln368">  if ((!msg_scroll &amp;&amp; !need_wait_return &amp;&amp; shortmess(SHM_TRUNCALL)</a>
<a name="ln369">       &amp;&amp; !exmode_active &amp;&amp; msg_silent == 0 &amp;&amp; !ui_has(kUIMessages))</a>
<a name="ln370">      || force) {</a>
<a name="ln371">    int room;</a>
<a name="ln372">    int len = vim_strsize(s);</a>
<a name="ln373">    if (msg_scrolled != 0) {</a>
<a name="ln374">      // Use all the columns.</a>
<a name="ln375">      room = (Rows - msg_row) * Columns - 1;</a>
<a name="ln376">    } else {</a>
<a name="ln377">      // Use up to 'showcmd' column.</a>
<a name="ln378">      room = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln379">    }</a>
<a name="ln380">    if (len &gt; room &amp;&amp; room &gt; 0) {</a>
<a name="ln381">      // may have up to 18 bytes per cell (6 per char, up to two</a>
<a name="ln382">      // composing chars)</a>
<a name="ln383">      len = (room + 2) * 18;</a>
<a name="ln384">      buf = xmalloc((size_t)len);</a>
<a name="ln385">      trunc_string(s, buf, room, len);</a>
<a name="ln386">    }</a>
<a name="ln387">  }</a>
<a name="ln388">  return buf;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/// Truncate a string &quot;s&quot; to &quot;buf&quot; with cell width &quot;room&quot;.</a>
<a name="ln392">/// &quot;s&quot; and &quot;buf&quot; may be equal.</a>
<a name="ln393">void trunc_string(const char *s, char *buf, int room_in, int buflen)</a>
<a name="ln394">{</a>
<a name="ln395">  int room = room_in - 3;  // &quot;...&quot; takes 3 chars</a>
<a name="ln396">  int half;</a>
<a name="ln397">  int len = 0;</a>
<a name="ln398">  int e;</a>
<a name="ln399">  int i;</a>
<a name="ln400">  int n;</a>
<a name="ln401"> </a>
<a name="ln402">  if (*s == NUL) {</a>
<a name="ln403">    if (buflen &gt; 0) {</a>
<a name="ln404">      *buf = NUL;</a>
<a name="ln405">    }</a>
<a name="ln406">    return;</a>
<a name="ln407">  }</a>
<a name="ln408"> </a>
<a name="ln409">  if (room_in &lt; 3) {</a>
<a name="ln410">    room = 0;</a>
<a name="ln411">  }</a>
<a name="ln412">  half = room / 2;</a>
<a name="ln413"> </a>
<a name="ln414">  // First part: Start of the string.</a>
<a name="ln415">  for (e = 0; len &lt; half &amp;&amp; e &lt; buflen; e++) {</a>
<a name="ln416">    if (s[e] == NUL) {</a>
<a name="ln417">      // text fits without truncating!</a>
<a name="ln418">      buf[e] = NUL;</a>
<a name="ln419">      return;</a>
<a name="ln420">    }</a>
<a name="ln421">    n = ptr2cells(s + e);</a>
<a name="ln422">    if (len + n &gt; half) {</a>
<a name="ln423">      break;</a>
<a name="ln424">    }</a>
<a name="ln425">    len += n;</a>
<a name="ln426">    buf[e] = s[e];</a>
<a name="ln427">    for (n = utfc_ptr2len(s + e); --n &gt; 0;) {</a>
<a name="ln428">      if (++e == buflen) {</a>
<a name="ln429">        break;</a>
<a name="ln430">      }</a>
<a name="ln431">      buf[e] = s[e];</a>
<a name="ln432">    }</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  // Last part: End of the string.</a>
<a name="ln436">  half = i = (int)strlen(s);</a>
<a name="ln437">  while (true) {</a>
<a name="ln438">    do {</a>
<a name="ln439">      half = half - utf_head_off(s, s + half - 1) - 1;</a>
<a name="ln440">    } while (half &gt; 0 &amp;&amp; utf_iscomposing(utf_ptr2char(s + half)));</a>
<a name="ln441">    n = ptr2cells(s + half);</a>
<a name="ln442">    if (len + n &gt; room || half == 0) {</a>
<a name="ln443">      break;</a>
<a name="ln444">    }</a>
<a name="ln445">    len += n;</a>
<a name="ln446">    i = half;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (i &lt;= e + 3) {</a>
<a name="ln450">    // text fits without truncating</a>
<a name="ln451">    if (s != buf) {</a>
<a name="ln452">      len = (int)strlen(s);</a>
<a name="ln453">      if (len &gt;= buflen) {</a>
<a name="ln454">        len = buflen - 1;</a>
<a name="ln455">      }</a>
<a name="ln456">      len = len - e + 1;</a>
<a name="ln457">      if (len &lt; 1) {</a>
<a name="ln458">        buf[e - 1] = NUL;</a>
<a name="ln459">      } else {</a>
<a name="ln460">        memmove(buf + e, s + e, (size_t)len);</a>
<a name="ln461">      }</a>
<a name="ln462">    }</a>
<a name="ln463">  } else if (e + 3 &lt; buflen) {</a>
<a name="ln464">    // set the middle and copy the last part</a>
<a name="ln465">    memmove(buf + e, &quot;...&quot;, (size_t)3);</a>
<a name="ln466">    len = (int)strlen(s + i) + 1;</a>
<a name="ln467">    if (len &gt;= buflen - e - 3) {</a>
<a name="ln468">      len = buflen - e - 3 - 1;</a>
<a name="ln469">    }</a>
<a name="ln470">    memmove(buf + e + 3, s + i, (size_t)len);</a>
<a name="ln471">    buf[e + 3 + len - 1] = NUL;</a>
<a name="ln472">  } else {</a>
<a name="ln473">    // can't fit in the &quot;...&quot;, just truncate it</a>
<a name="ln474">    buf[e - 1] = NUL;</a>
<a name="ln475">  }</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">// Note: Caller of smsg() must check the resulting string is shorter than IOSIZE!!!</a>
<a name="ln479">int smsg(int attr, const char *s, ...)</a>
<a name="ln480">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln481">{</a>
<a name="ln482">  va_list arglist;</a>
<a name="ln483"> </a>
<a name="ln484">  va_start(arglist, s);</a>
<a name="ln485">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln486">  va_end(arglist);</a>
<a name="ln487">  return msg(IObuff, attr);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">int smsg_attr_keep(int attr, const char *s, ...)</a>
<a name="ln491">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln492">{</a>
<a name="ln493">  va_list arglist;</a>
<a name="ln494"> </a>
<a name="ln495">  va_start(arglist, s);</a>
<a name="ln496">  vim_vsnprintf(IObuff, IOSIZE, s, arglist);</a>
<a name="ln497">  va_end(arglist);</a>
<a name="ln498">  return msg_attr_keep(IObuff, attr, true, false);</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">// Remember the last sourcing name/lnum used in an error message, so that it</a>
<a name="ln502">// isn't printed each time when it didn't change.</a>
<a name="ln503">static int last_sourcing_lnum = 0;</a>
<a name="ln504">static char *last_sourcing_name = NULL;</a>
<a name="ln505"> </a>
<a name="ln506">/// Reset the last used sourcing name/lnum.  Makes sure it is displayed again</a>
<a name="ln507">/// for the next error message;</a>
<a name="ln508">void reset_last_sourcing(void)</a>
<a name="ln509">{</a>
<a name="ln510">  XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln511">  last_sourcing_lnum = 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/// @return  true if &quot;SOURCING_NAME&quot; differs from &quot;last_sourcing_name&quot;.</a>
<a name="ln515">static bool other_sourcing_name(void)</a>
<a name="ln516">{</a>
<a name="ln517">  if (SOURCING_NAME != NULL) {</a>
<a name="ln518">    if (last_sourcing_name != NULL) {</a>
<a name="ln519">      return strcmp(SOURCING_NAME, last_sourcing_name) != 0;</a>
<a name="ln520">    }</a>
<a name="ln521">    return true;</a>
<a name="ln522">  }</a>
<a name="ln523">  return false;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">/// Get the message about the source, as used for an error message</a>
<a name="ln527">///</a>
<a name="ln528">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln529">///                     message is to be given.</a>
<a name="ln530">static char *get_emsg_source(void)</a>
<a name="ln531">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln532">{</a>
<a name="ln533">  if (SOURCING_NAME != NULL &amp;&amp; other_sourcing_name()) {</a>
<a name="ln534">    char *sname = estack_sfile(ESTACK_NONE);</a>
<a name="ln535">    char *tofree = sname;</a>
<a name="ln536"> </a>
<a name="ln537">    if (sname == NULL) {</a>
<a name="ln538">      sname = SOURCING_NAME;</a>
<a name="ln539">    }</a>
<a name="ln540"> </a>
<a name="ln541">    const char *const p = _(&quot;Error detected while processing %s:&quot;);</a>
<a name="ln542">    const size_t buf_len = strlen(sname) + strlen(p) + 1;</a>
<a name="ln543">    char *const buf = xmalloc(buf_len);</a>
<a name="ln544">    snprintf(buf, buf_len, p, sname);</a>
<a name="ln545">    xfree(tofree);</a>
<a name="ln546">    return buf;</a>
<a name="ln547">  }</a>
<a name="ln548">  return NULL;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">/// Get the message about the source lnum, as used for an error message.</a>
<a name="ln552">///</a>
<a name="ln553">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln554">///                     message is to be given.</a>
<a name="ln555">static char *get_emsg_lnum(void)</a>
<a name="ln556">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln557">{</a>
<a name="ln558">  // lnum is 0 when executing a command from the command line</a>
<a name="ln559">  // argument, we don't want a line number then</a>
<a name="ln560">  if (SOURCING_NAME != NULL</a>
<a name="ln561">      &amp;&amp; (other_sourcing_name() || SOURCING_LNUM != last_sourcing_lnum)</a>
<a name="ln562">      &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln563">    const char *const p = _(&quot;line %4ld:&quot;);</a>
<a name="ln564">    const size_t buf_len = 20 + strlen(p);</a>
<a name="ln565">    char *const buf = xmalloc(buf_len);</a>
<a name="ln566">    snprintf(buf, buf_len, p, (long)SOURCING_LNUM);</a>
<a name="ln567">    return buf;</a>
<a name="ln568">  }</a>
<a name="ln569">  return NULL;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">/// Display name and line number for the source of an error.</a>
<a name="ln573">/// Remember the file name and line number, so that for the next error the info</a>
<a name="ln574">/// is only displayed if it changed.</a>
<a name="ln575">void msg_source(int attr)</a>
<a name="ln576">{</a>
<a name="ln577">  static bool recursive = false;</a>
<a name="ln578"> </a>
<a name="ln579">  // Bail out if something called here causes an error.</a>
<a name="ln580">  if (recursive) {</a>
<a name="ln581">    return;</a>
<a name="ln582">  }</a>
<a name="ln583">  recursive = true;</a>
<a name="ln584"> </a>
<a name="ln585">  no_wait_return++;</a>
<a name="ln586">  char *p = get_emsg_source();</a>
<a name="ln587">  if (p != NULL) {</a>
<a name="ln588">    msg_scroll = true;  // this will take more than one line</a>
<a name="ln589">    msg(p, attr);</a>
<a name="ln590">    xfree(p);</a>
<a name="ln591">  }</a>
<a name="ln592">  p = get_emsg_lnum();</a>
<a name="ln593">  if (p != NULL) {</a>
<a name="ln594">    msg(p, HL_ATTR(HLF_N));</a>
<a name="ln595">    xfree(p);</a>
<a name="ln596">    last_sourcing_lnum = SOURCING_LNUM;      // only once for each line</a>
<a name="ln597">  }</a>
<a name="ln598"> </a>
<a name="ln599">  // remember the last sourcing name printed, also when it's empty</a>
<a name="ln600">  if (SOURCING_NAME == NULL || other_sourcing_name()) {</a>
<a name="ln601">    XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln602">    if (SOURCING_NAME != NULL) {</a>
<a name="ln603">      last_sourcing_name = xstrdup(SOURCING_NAME);</a>
<a name="ln604">    }</a>
<a name="ln605">  }</a>
<a name="ln606">  no_wait_return--;</a>
<a name="ln607"> </a>
<a name="ln608">  recursive = false;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/// @return  true if not giving error messages right now:</a>
<a name="ln612">///            If &quot;emsg_off&quot; is set: no error messages at the moment.</a>
<a name="ln613">///            If &quot;msg&quot; is in 'debug': do error message but without side effects.</a>
<a name="ln614">///            If &quot;emsg_skip&quot; is set: never do error messages.</a>
<a name="ln615">int emsg_not_now(void)</a>
<a name="ln616">{</a>
<a name="ln617">  if ((emsg_off &gt; 0 &amp;&amp; vim_strchr(p_debug, 'm') == NULL</a>
<a name="ln618">       &amp;&amp; vim_strchr(p_debug, 't') == NULL)</a>
<a name="ln619">      || emsg_skip &gt; 0) {</a>
<a name="ln620">    return true;</a>
<a name="ln621">  }</a>
<a name="ln622">  return false;</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">bool emsg_multiline(const char *s, bool multiline)</a>
<a name="ln626">{</a>
<a name="ln627">  int attr;</a>
<a name="ln628">  bool ignore = false;</a>
<a name="ln629"> </a>
<a name="ln630">  // Skip this if not giving error messages at the moment.</a>
<a name="ln631">  if (emsg_not_now()) {</a>
<a name="ln632">    return true;</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  called_emsg++;</a>
<a name="ln636"> </a>
<a name="ln637">  // If &quot;emsg_severe&quot; is true: When an error exception is to be thrown,</a>
<a name="ln638">  // prefer this message over previous messages for the same command.</a>
<a name="ln639">  bool severe = emsg_severe;</a>
<a name="ln640">  emsg_severe = false;</a>
<a name="ln641"> </a>
<a name="ln642">  if (!emsg_off || vim_strchr(p_debug, 't') != NULL) {</a>
<a name="ln643">    // Cause a throw of an error exception if appropriate.  Don't display</a>
<a name="ln644">    // the error message in this case.  (If no matching catch clause will</a>
<a name="ln645">    // be found, the message will be displayed later on.)  &quot;ignore&quot; is set</a>
<a name="ln646">    // when the message should be ignored completely (used for the</a>
<a name="ln647">    // interrupt message).</a>
<a name="ln648">    if (cause_errthrow(s, multiline, severe, &amp;ignore)) {</a>
<a name="ln649">      if (!ignore) {</a>
<a name="ln650">        did_emsg++;</a>
<a name="ln651">      }</a>
<a name="ln652">      return true;</a>
<a name="ln653">    }</a>
<a name="ln654"> </a>
<a name="ln655">    if (in_assert_fails &amp;&amp; emsg_assert_fails_msg == NULL) {</a>
<a name="ln656">      emsg_assert_fails_msg = xstrdup(s);</a>
<a name="ln657">      emsg_assert_fails_lnum = SOURCING_LNUM;</a>
<a name="ln658">      xfree(emsg_assert_fails_context);</a>
<a name="ln659">      emsg_assert_fails_context = xstrdup(SOURCING_NAME == NULL ? &quot;&quot; : SOURCING_NAME);</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    // set &quot;v:errmsg&quot;, also when using &quot;:silent! cmd&quot;</a>
<a name="ln663">    set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln664"> </a>
<a name="ln665">    // When using &quot;:silent! cmd&quot; ignore error messages.</a>
<a name="ln666">    // But do write it to the redirection file.</a>
<a name="ln667">    if (emsg_silent != 0) {</a>
<a name="ln668">      if (!emsg_noredir) {</a>
<a name="ln669">        msg_start();</a>
<a name="ln670">        char *p = get_emsg_source();</a>
<a name="ln671">        if (p != NULL) {</a>
<a name="ln672">          const size_t p_len = strlen(p);</a>
<a name="ln673">          p[p_len] = '\n';</a>
<a name="ln674">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln675">          xfree(p);</a>
<a name="ln676">        }</a>
<a name="ln677">        p = get_emsg_lnum();</a>
<a name="ln678">        if (p != NULL) {</a>
<a name="ln679">          const size_t p_len = strlen(p);</a>
<a name="ln680">          p[p_len] = '\n';</a>
<a name="ln681">          redir_write(p, (ptrdiff_t)p_len + 1);</a>
<a name="ln682">          xfree(p);</a>
<a name="ln683">        }</a>
<a name="ln684">        redir_write(s, (ptrdiff_t)strlen(s));</a>
<a name="ln685">      }</a>
<a name="ln686"> </a>
<a name="ln687">      // Log (silent) errors as debug messages.</a>
<a name="ln688">      if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln689">        DLOG(&quot;(:silent) %s (%s (line %ld))&quot;,</a>
<a name="ln690">             s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln691">      } else {</a>
<a name="ln692">        DLOG(&quot;(:silent) %s&quot;, s);</a>
<a name="ln693">      }</a>
<a name="ln694"> </a>
<a name="ln695">      return true;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">    // Log editor errors as INFO.</a>
<a name="ln699">    if (SOURCING_NAME != NULL &amp;&amp; SOURCING_LNUM != 0) {</a>
<a name="ln700">      ILOG(&quot;%s (%s (line %ld))&quot;, s, SOURCING_NAME, (long)SOURCING_LNUM);</a>
<a name="ln701">    } else {</a>
<a name="ln702">      ILOG(&quot;%s&quot;, s);</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    ex_exitval = 1;</a>
<a name="ln706"> </a>
<a name="ln707">    // Reset msg_silent, an error causes messages to be switched back on.</a>
<a name="ln708">    msg_silent = 0;</a>
<a name="ln709">    cmd_silent = false;</a>
<a name="ln710"> </a>
<a name="ln711">    if (global_busy) {        // break :global command</a>
<a name="ln712">      global_busy++;</a>
<a name="ln713">    }</a>
<a name="ln714"> </a>
<a name="ln715">    if (p_eb) {</a>
<a name="ln716">      beep_flush();           // also includes flush_buffers()</a>
<a name="ln717">    } else {</a>
<a name="ln718">      flush_buffers(FLUSH_MINIMAL);  // flush internal buffers</a>
<a name="ln719">    }</a>
<a name="ln720">    did_emsg++;               // flag for DoOneCmd()</a>
<a name="ln721">  }</a>
<a name="ln722"> </a>
<a name="ln723">  emsg_on_display = true;     // remember there is an error message</a>
<a name="ln724">  attr = HL_ATTR(HLF_E);      // set highlight mode for error messages</a>
<a name="ln725">  if (msg_scrolled != 0) {</a>
<a name="ln726">    need_wait_return = true;  // needed in case emsg() is called after</a>
<a name="ln727">  }                           // wait_return() has reset need_wait_return</a>
<a name="ln728">                              // and a redraw is expected because</a>
<a name="ln729">                              // msg_scrolled is non-zero</a>
<a name="ln730">  if (msg_ext_kind == NULL) {</a>
<a name="ln731">    msg_ext_set_kind(&quot;emsg&quot;);</a>
<a name="ln732">  }</a>
<a name="ln733"> </a>
<a name="ln734">  // Display name and line number for the source of the error.</a>
<a name="ln735">  msg_scroll = true;</a>
<a name="ln736">  msg_source(attr);</a>
<a name="ln737"> </a>
<a name="ln738">  // Display the error message itself.</a>
<a name="ln739">  msg_nowait = false;  // Wait for this msg.</a>
<a name="ln740">  return msg_attr_keep(s, attr, false, multiline);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">/// emsg() - display an error message</a>
<a name="ln744">///</a>
<a name="ln745">/// Rings the bell, if appropriate, and calls message() to do the real work</a>
<a name="ln746">/// When terminal not initialized (yet) os_errmsg(..) is used.</a>
<a name="ln747">///</a>
<a name="ln748">/// @return true if wait_return() not called</a>
<a name="ln749">bool emsg(const char *s)</a>
<a name="ln750">{</a>
<a name="ln751">  return emsg_multiline(s, false);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">void emsg_invreg(int name)</a>
<a name="ln755">{</a>
<a name="ln756">  semsg(_(&quot;E354: Invalid register name: '%s'&quot;), transchar_buf(NULL, name));</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">/// Print an error message with unknown number of arguments</a>
<a name="ln760">bool semsg(const char *const fmt, ...)</a>
<a name="ln761">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln762">{</a>
<a name="ln763">  bool ret;</a>
<a name="ln764"> </a>
<a name="ln765">  va_list ap;</a>
<a name="ln766">  va_start(ap, fmt);</a>
<a name="ln767">  ret = semsgv(fmt, ap);</a>
<a name="ln768">  va_end(ap);</a>
<a name="ln769"> </a>
<a name="ln770">  return ret;</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">#define MULTILINE_BUFSIZE 8192</a>
<a name="ln774"> </a>
<a name="ln775">bool semsg_multiline(const char *const fmt, ...)</a>
<a name="ln776">{</a>
<a name="ln777">  bool ret;</a>
<a name="ln778">  va_list ap;</a>
<a name="ln779"> </a>
<a name="ln780">  static char errbuf[MULTILINE_BUFSIZE];</a>
<a name="ln781">  if (emsg_not_now()) {</a>
<a name="ln782">    return true;</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  va_start(ap, fmt);</a>
<a name="ln786">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln787">  va_end(ap);</a>
<a name="ln788"> </a>
<a name="ln789">  ret = emsg_multiline(errbuf, true);</a>
<a name="ln790"> </a>
<a name="ln791">  return ret;</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/// Print an error message with unknown number of arguments</a>
<a name="ln795">static bool semsgv(const char *fmt, va_list ap)</a>
<a name="ln796">{</a>
<a name="ln797">  static char errbuf[IOSIZE];</a>
<a name="ln798">  if (emsg_not_now()) {</a>
<a name="ln799">    return true;</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln803"> </a>
<a name="ln804">  return emsg(errbuf);</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">/// Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln808">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln809">/// detected when fuzzing vim.</a>
<a name="ln810">void iemsg(const char *s)</a>
<a name="ln811">{</a>
<a name="ln812">  if (emsg_not_now()) {</a>
<a name="ln813">    return;</a>
<a name="ln814">  }</a>
<a name="ln815"> </a>
<a name="ln816">  emsg(s);</a>
<a name="ln817">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln818">  set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln819">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln820">  ui_flush();</a>
<a name="ln821">  abort();</a>
<a name="ln822">#endif</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/// Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln826">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln827">/// detected when fuzzing vim.</a>
<a name="ln828">void siemsg(const char *s, ...)</a>
<a name="ln829">{</a>
<a name="ln830">  if (emsg_not_now()) {</a>
<a name="ln831">    return;</a>
<a name="ln832">  }</a>
<a name="ln833"> </a>
<a name="ln834">  va_list ap;</a>
<a name="ln835">  va_start(ap, s);</a>
<a name="ln836">  (void)semsgv(s, ap);</a>
<a name="ln837">  va_end(ap);</a>
<a name="ln838">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln839">  msg_putchar('\n');  // avoid overwriting the error message</a>
<a name="ln840">  ui_flush();</a>
<a name="ln841">  abort();</a>
<a name="ln842">#endif</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/// Give an &quot;Internal error&quot; message.</a>
<a name="ln846">void internal_error(const char *where)</a>
<a name="ln847">{</a>
<a name="ln848">  siemsg(_(e_intern2), where);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">static void msg_semsg_event(void **argv)</a>
<a name="ln852">{</a>
<a name="ln853">  char *s = argv[0];</a>
<a name="ln854">  (void)emsg(s);</a>
<a name="ln855">  xfree(s);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">void msg_schedule_semsg(const char *const fmt, ...)</a>
<a name="ln859">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln860">{</a>
<a name="ln861">  va_list ap;</a>
<a name="ln862">  va_start(ap, fmt);</a>
<a name="ln863">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln864">  va_end(ap);</a>
<a name="ln865"> </a>
<a name="ln866">  char *s = xstrdup(IObuff);</a>
<a name="ln867">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_event, 1, s));</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static void msg_semsg_multiline_event(void **argv)</a>
<a name="ln871">{</a>
<a name="ln872">  char *s = argv[0];</a>
<a name="ln873">  (void)emsg_multiline(s, true);</a>
<a name="ln874">  xfree(s);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">void msg_schedule_semsg_multiline(const char *const fmt, ...)</a>
<a name="ln878">{</a>
<a name="ln879">  va_list ap;</a>
<a name="ln880">  va_start(ap, fmt);</a>
<a name="ln881">  vim_vsnprintf(IObuff, IOSIZE, fmt, ap);</a>
<a name="ln882">  va_end(ap);</a>
<a name="ln883"> </a>
<a name="ln884">  char *s = xstrdup(IObuff);</a>
<a name="ln885">  loop_schedule_deferred(&amp;main_loop, event_create(msg_semsg_multiline_event, 1, s));</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">/// Like msg(), but truncate to a single line if p_shm contains 't', or when</a>
<a name="ln889">/// &quot;force&quot; is true.  This truncates in another way as for normal messages.</a>
<a name="ln890">/// Careful: The string may be changed by msg_may_trunc()!</a>
<a name="ln891">///</a>
<a name="ln892">/// @return  a pointer to the printed message, if wait_return() not called.</a>
<a name="ln893">char *msg_trunc(char *s, bool force, int attr)</a>
<a name="ln894">{</a>
<a name="ln895">  int n;</a>
<a name="ln896"> </a>
<a name="ln897">  // Add message to history before truncating.</a>
<a name="ln898">  add_msg_hist(s, -1, attr, false);</a>
<a name="ln899"> </a>
<a name="ln900">  char *ts = msg_may_trunc(force, s);</a>
<a name="ln901"> </a>
<a name="ln902">  msg_hist_off = true;</a>
<a name="ln903">  n = msg(ts, attr);</a>
<a name="ln904">  msg_hist_off = false;</a>
<a name="ln905"> </a>
<a name="ln906">  if (n) {</a>
<a name="ln907">    return ts;</a>
<a name="ln908">  }</a>
<a name="ln909">  return NULL;</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">/// Check if message &quot;s&quot; should be truncated at the start (for filenames).</a>
<a name="ln913">///</a>
<a name="ln914">/// @return  a pointer to where the truncated message starts.</a>
<a name="ln915">///</a>
<a name="ln916">/// @note: May change the message by replacing a character with '&lt;'.</a>
<a name="ln917">char *msg_may_trunc(bool force, char *s)</a>
<a name="ln918">{</a>
<a name="ln919">  if (ui_has(kUIMessages)) {</a>
<a name="ln920">    return s;</a>
<a name="ln921">  }</a>
<a name="ln922"> </a>
<a name="ln923">  int room = (Rows - cmdline_row - 1) * Columns + sc_col - 1;</a>
<a name="ln924">  if ((force || (shortmess(SHM_TRUNC) &amp;&amp; !exmode_active))</a>
<a name="ln925">      &amp;&amp; (int)strlen(s) - room &gt; 0) {</a>
<a name="ln926">    int size = vim_strsize(s);</a>
<a name="ln927"> </a>
<a name="ln928">    // There may be room anyway when there are multibyte chars.</a>
<a name="ln929">    if (size &lt;= room) {</a>
<a name="ln930">      return s;</a>
<a name="ln931">    }</a>
<a name="ln932">    int n;</a>
<a name="ln933">    for (n = 0; size &gt;= room;) {</a>
<a name="ln934">      size -= utf_ptr2cells(s + n);</a>
<a name="ln935">      n += utfc_ptr2len(s + n);</a>
<a name="ln936">    }</a>
<a name="ln937">    n--;</a>
<a name="ln938">    s += n;</a>
<a name="ln939">    *s = '&lt;';</a>
<a name="ln940">  }</a>
<a name="ln941">  return s;</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void hl_msg_free(HlMessage hl_msg)</a>
<a name="ln945">{</a>
<a name="ln946">  for (size_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln947">    xfree(kv_A(hl_msg, i).text.data);</a>
<a name="ln948">  }</a>
<a name="ln949">  kv_destroy(hl_msg);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/// @param[in]  len  Length of s or -1.</a>
<a name="ln953">static void add_msg_hist(const char *s, int len, int attr, bool multiline)</a>
<a name="ln954">{</a>
<a name="ln955">  add_msg_hist_multiattr(s, len, attr, multiline, (HlMessage)KV_INITIAL_VALUE);</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">static void add_msg_hist_multiattr(const char *s, int len, int attr, bool multiline,</a>
<a name="ln959">                                   HlMessage multiattr)</a>
<a name="ln960">{</a>
<a name="ln961">  if (msg_hist_off || msg_silent != 0) {</a>
<a name="ln962">    hl_msg_free(multiattr);</a>
<a name="ln963">    return;</a>
<a name="ln964">  }</a>
<a name="ln965"> </a>
<a name="ln966">  // Don't let the message history get too big</a>
<a name="ln967">  while (msg_hist_len &gt; MAX_MSG_HIST_LEN) {</a>
<a name="ln968">    (void)delete_first_msg();</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  // allocate an entry and add the message at the end of the history</a>
<a name="ln972">  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));</a>
<a name="ln973">  if (s) {</a>
<a name="ln974">    if (len &lt; 0) {</a>
<a name="ln975">      len = (int)strlen(s);</a>
<a name="ln976">    }</a>
<a name="ln977">    // remove leading and trailing newlines</a>
<a name="ln978">    while (len &gt; 0 &amp;&amp; *s == '\n') {</a>
<a name="ln979">      s++;</a>
<a name="ln980">      len--;</a>
<a name="ln981">    }</a>
<a name="ln982">    while (len &gt; 0 &amp;&amp; s[len - 1] == '\n') {</a>
<a name="ln983">      len--;</a>
<a name="ln984">    }</a>
<a name="ln985">    p-&gt;msg = xmemdupz(s, (size_t)len);</a>
<a name="ln986">  } else {</a>
<a name="ln987">    p-&gt;msg = NULL;</a>
<a name="ln988">  }</a>
<a name="ln989">  p-&gt;next = NULL;</a>
<a name="ln990">  p-&gt;attr = attr;</a>
<a name="ln991">  p-&gt;multiline = multiline;</a>
<a name="ln992">  p-&gt;multiattr = multiattr;</a>
<a name="ln993">  p-&gt;kind = msg_ext_kind;</a>
<a name="ln994">  if (last_msg_hist != NULL) {</a>
<a name="ln995">    last_msg_hist-&gt;next = p;</a>
<a name="ln996">  }</a>
<a name="ln997">  last_msg_hist = p;</a>
<a name="ln998">  if (first_msg_hist == NULL) {</a>
<a name="ln999">    first_msg_hist = last_msg_hist;</a>
<a name="ln1000">  }</a>
<a name="ln1001">  msg_hist_len++;</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">/// Delete the first (oldest) message from the history.</a>
<a name="ln1005">///</a>
<a name="ln1006">/// @return  FAIL if there are no messages.</a>
<a name="ln1007">int delete_first_msg(void)</a>
<a name="ln1008">{</a>
<a name="ln1009">  struct msg_hist *p;</a>
<a name="ln1010"> </a>
<a name="ln1011">  if (msg_hist_len &lt;= 0) {</a>
<a name="ln1012">    return FAIL;</a>
<a name="ln1013">  }</a>
<a name="ln1014">  p = first_msg_hist;</a>
<a name="ln1015">  first_msg_hist = p-&gt;next;</a>
<a name="ln1016">  if (first_msg_hist == NULL) {  // history is becoming empty</a>
<a name="ln1017">    assert(msg_hist_len == 1);</a>
<a name="ln1018">    last_msg_hist = NULL;</a>
<a name="ln1019">  }</a>
<a name="ln1020">  xfree(p-&gt;msg);</a>
<a name="ln1021">  hl_msg_free(p-&gt;multiattr);</a>
<a name="ln1022">  xfree(p);</a>
<a name="ln1023">  msg_hist_len--;</a>
<a name="ln1024">  return OK;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/// :messages command implementation</a>
<a name="ln1028">void ex_messages(exarg_T *eap)</a>
<a name="ln1029">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1030">{</a>
<a name="ln1031">  struct msg_hist *p;</a>
<a name="ln1032"> </a>
<a name="ln1033">  if (strcmp(eap-&gt;arg, &quot;clear&quot;) == 0) {</a>
<a name="ln1034">    int keep = eap-&gt;addr_count == 0 ? 0 : eap-&gt;line2;</a>
<a name="ln1035"> </a>
<a name="ln1036">    while (msg_hist_len &gt; keep) {</a>
<a name="ln1037">      (void)delete_first_msg();</a>
<a name="ln1038">    }</a>
<a name="ln1039">    return;</a>
<a name="ln1040">  }</a>
<a name="ln1041"> </a>
<a name="ln1042">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1043">    emsg(_(e_invarg));</a>
<a name="ln1044">    return;</a>
<a name="ln1045">  }</a>
<a name="ln1046"> </a>
<a name="ln1047">  p = first_msg_hist;</a>
<a name="ln1048"> </a>
<a name="ln1049">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln1050">    int c = 0;</a>
<a name="ln1051">    // Count total messages</a>
<a name="ln1052">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1053">      c++;</a>
<a name="ln1054">    }</a>
<a name="ln1055"> </a>
<a name="ln1056">    c -= eap-&gt;line2;</a>
<a name="ln1057"> </a>
<a name="ln1058">    // Skip without number of messages specified</a>
<a name="ln1059">    for (p = first_msg_hist; p != NULL &amp;&amp; !got_int &amp;&amp; c &gt; 0; p = p-&gt;next, c--) {}</a>
<a name="ln1060">  }</a>
<a name="ln1061"> </a>
<a name="ln1062">  // Display what was not skipped.</a>
<a name="ln1063">  if (ui_has(kUIMessages)) {</a>
<a name="ln1064">    if (msg_silent) {</a>
<a name="ln1065">      return;</a>
<a name="ln1066">    }</a>
<a name="ln1067">    Array entries = ARRAY_DICT_INIT;</a>
<a name="ln1068">    for (; p != NULL; p = p-&gt;next) {</a>
<a name="ln1069">      if (kv_size(p-&gt;multiattr) || (p-&gt;msg &amp;&amp; p-&gt;msg[0])) {</a>
<a name="ln1070">        Array entry = ARRAY_DICT_INIT;</a>
<a name="ln1071">        ADD(entry, CSTR_TO_OBJ(p-&gt;kind));</a>
<a name="ln1072">        Array content = ARRAY_DICT_INIT;</a>
<a name="ln1073">        if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1074">          for (uint32_t i = 0; i &lt; kv_size(p-&gt;multiattr); i++) {</a>
<a name="ln1075">            HlMessageChunk chunk = kv_A(p-&gt;multiattr, i);</a>
<a name="ln1076">            Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1077">            ADD(content_entry, INTEGER_OBJ(chunk.attr));</a>
<a name="ln1078">            ADD(content_entry, STRING_OBJ(copy_string(chunk.text, NULL)));</a>
<a name="ln1079">            ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1080">          }</a>
<a name="ln1081">        } else if (p-&gt;msg &amp;&amp; p-&gt;msg[0]) {</a>
<a name="ln1082">          Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1083">          ADD(content_entry, INTEGER_OBJ(p-&gt;attr));</a>
<a name="ln1084">          ADD(content_entry, CSTR_TO_OBJ(p-&gt;msg));</a>
<a name="ln1085">          ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1086">        }</a>
<a name="ln1087">        ADD(entry, ARRAY_OBJ(content));</a>
<a name="ln1088">        ADD(entries, ARRAY_OBJ(entry));</a>
<a name="ln1089">      }</a>
<a name="ln1090">    }</a>
<a name="ln1091">    ui_call_msg_history_show(entries);</a>
<a name="ln1092">    api_free_array(entries);</a>
<a name="ln1093">    msg_ext_history_visible = true;</a>
<a name="ln1094">    wait_return(false);</a>
<a name="ln1095">  } else {</a>
<a name="ln1096">    msg_hist_off = true;</a>
<a name="ln1097">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1098">      if (kv_size(p-&gt;multiattr)) {</a>
<a name="ln1099">        msg_multiattr(p-&gt;multiattr, p-&gt;kind, false);</a>
<a name="ln1100">      } else if (p-&gt;msg != NULL) {</a>
<a name="ln1101">        msg_attr_keep(p-&gt;msg, p-&gt;attr, false, p-&gt;multiline);</a>
<a name="ln1102">      }</a>
<a name="ln1103">    }</a>
<a name="ln1104">    msg_hist_off = false;</a>
<a name="ln1105">  }</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108">/// Call this after prompting the user.  This will avoid a hit-return message</a>
<a name="ln1109">/// and a delay.</a>
<a name="ln1110">void msg_end_prompt(void)</a>
<a name="ln1111">{</a>
<a name="ln1112">  msg_ext_clear_later();</a>
<a name="ln1113">  need_wait_return = false;</a>
<a name="ln1114">  emsg_on_display = false;</a>
<a name="ln1115">  cmdline_row = msg_row;</a>
<a name="ln1116">  msg_col = 0;</a>
<a name="ln1117">  msg_clr_eos();</a>
<a name="ln1118">  lines_left = -1;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">/// Wait for the user to hit a key (normally Enter)</a>
<a name="ln1122">///</a>
<a name="ln1123">/// @param redraw  if true, redraw the entire screen UPD_NOT_VALID</a>
<a name="ln1124">///                if false, do a normal redraw</a>
<a name="ln1125">///                if -1, don't redraw at all</a>
<a name="ln1126">void wait_return(int redraw)</a>
<a name="ln1127">{</a>
<a name="ln1128">  int c;</a>
<a name="ln1129">  int oldState;</a>
<a name="ln1130">  int tmpState;</a>
<a name="ln1131">  int had_got_int;</a>
<a name="ln1132">  FILE *save_scriptout;</a>
<a name="ln1133"> </a>
<a name="ln1134">  if (redraw == true) {</a>
<a name="ln1135">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln1136">  }</a>
<a name="ln1137"> </a>
<a name="ln1138">  // If using &quot;:silent cmd&quot;, don't wait for a return.  Also don't set</a>
<a name="ln1139">  // need_wait_return to do it later.</a>
<a name="ln1140">  if (msg_silent != 0) {</a>
<a name="ln1141">    return;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  if (headless_mode &amp;&amp; !ui_active()) {</a>
<a name="ln1145">    return;</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  // When inside vgetc(), we can't wait for a typed character at all.</a>
<a name="ln1149">  // With the global command (and some others) we only need one return at</a>
<a name="ln1150">  // the end. Adjust cmdline_row to avoid the next message overwriting the</a>
<a name="ln1151">  // last one.</a>
<a name="ln1152">  if (vgetc_busy &gt; 0) {</a>
<a name="ln1153">    return;</a>
<a name="ln1154">  }</a>
<a name="ln1155">  need_wait_return = true;</a>
<a name="ln1156">  if (no_wait_return) {</a>
<a name="ln1157">    if (!exmode_active) {</a>
<a name="ln1158">      cmdline_row = msg_row;</a>
<a name="ln1159">    }</a>
<a name="ln1160">    return;</a>
<a name="ln1161">  }</a>
<a name="ln1162"> </a>
<a name="ln1163">  redir_off = true;             // don't redirect this message</a>
<a name="ln1164">  oldState = State;</a>
<a name="ln1165">  if (quit_more) {</a>
<a name="ln1166">    c = CAR;                    // just pretend CR was hit</a>
<a name="ln1167">    quit_more = false;</a>
<a name="ln1168">    got_int = false;</a>
<a name="ln1169">  } else if (exmode_active) {</a>
<a name="ln1170">    msg_puts(&quot; &quot;);              // make sure the cursor is on the right line</a>
<a name="ln1171">    c = CAR;                    // no need for a return in ex mode</a>
<a name="ln1172">    got_int = false;</a>
<a name="ln1173">  } else {</a>
<a name="ln1174">    State = MODE_HITRETURN;</a>
<a name="ln1175">    setmouse();</a>
<a name="ln1176">    cmdline_row = msg_row;</a>
<a name="ln1177">    // Avoid the sequence that the user types &quot;:&quot; at the hit-return prompt</a>
<a name="ln1178">    // to start an Ex command, but the file-changed dialog gets in the</a>
<a name="ln1179">    // way.</a>
<a name="ln1180">    if (need_check_timestamps) {</a>
<a name="ln1181">      check_timestamps(false);</a>
<a name="ln1182">    }</a>
<a name="ln1183"> </a>
<a name="ln1184">    hit_return_msg();</a>
<a name="ln1185"> </a>
<a name="ln1186">    do {</a>
<a name="ln1187">      // Remember &quot;got_int&quot;, if it is set vgetc() probably returns a</a>
<a name="ln1188">      // CTRL-C, but we need to loop then.</a>
<a name="ln1189">      had_got_int = got_int;</a>
<a name="ln1190"> </a>
<a name="ln1191">      // Don't do mappings here, we put the character back in the</a>
<a name="ln1192">      // typeahead buffer.</a>
<a name="ln1193">      no_mapping++;</a>
<a name="ln1194">      allow_keys++;</a>
<a name="ln1195"> </a>
<a name="ln1196">      // Temporarily disable Recording. If Recording is active, the</a>
<a name="ln1197">      // character will be recorded later, since it will be added to the</a>
<a name="ln1198">      // typebuf after the loop</a>
<a name="ln1199">      const int save_reg_recording = reg_recording;</a>
<a name="ln1200">      save_scriptout = scriptout;</a>
<a name="ln1201">      reg_recording = 0;</a>
<a name="ln1202">      scriptout = NULL;</a>
<a name="ln1203">      c = safe_vgetc();</a>
<a name="ln1204">      if (had_got_int &amp;&amp; !global_busy) {</a>
<a name="ln1205">        got_int = false;</a>
<a name="ln1206">      }</a>
<a name="ln1207">      no_mapping--;</a>
<a name="ln1208">      allow_keys--;</a>
<a name="ln1209">      reg_recording = save_reg_recording;</a>
<a name="ln1210">      scriptout = save_scriptout;</a>
<a name="ln1211"> </a>
<a name="ln1212">      // Allow scrolling back in the messages.</a>
<a name="ln1213">      // Also accept scroll-down commands when messages fill the screen,</a>
<a name="ln1214">      // to avoid that typing one 'j' too many makes the messages</a>
<a name="ln1215">      // disappear.</a>
<a name="ln1216">      if (p_more) {</a>
<a name="ln1217">        if (c == 'b' || c == 'k' || c == 'u' || c == 'g'</a>
<a name="ln1218">            || c == K_UP || c == K_PAGEUP) {</a>
<a name="ln1219">          if (msg_scrolled &gt; Rows) {</a>
<a name="ln1220">            // scroll back to show older messages</a>
<a name="ln1221">            do_more_prompt(c);</a>
<a name="ln1222">          } else {</a>
<a name="ln1223">            msg_didout = false;</a>
<a name="ln1224">            c = K_IGNORE;</a>
<a name="ln1225">            msg_col =</a>
<a name="ln1226">              cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1227">              0;</a>
<a name="ln1228">          }</a>
<a name="ln1229">          if (quit_more) {</a>
<a name="ln1230">            c = CAR;                            // just pretend CR was hit</a>
<a name="ln1231">            quit_more = false;</a>
<a name="ln1232">            got_int = false;</a>
<a name="ln1233">          } else if (c != K_IGNORE) {</a>
<a name="ln1234">            c = K_IGNORE;</a>
<a name="ln1235">            hit_return_msg();</a>
<a name="ln1236">          }</a>
<a name="ln1237">        } else if (msg_scrolled &gt; Rows - 2</a>
<a name="ln1238">                   &amp;&amp; (c == 'j' || c == 'd' || c == 'f'</a>
<a name="ln1239">                       || c == K_DOWN || c == K_PAGEDOWN)) {</a>
<a name="ln1240">          c = K_IGNORE;</a>
<a name="ln1241">        }</a>
<a name="ln1242">      }</a>
<a name="ln1243">    } while ((had_got_int &amp;&amp; c == Ctrl_C)</a>
<a name="ln1244">             || c == K_IGNORE</a>
<a name="ln1245">             || c == K_LEFTDRAG || c == K_LEFTRELEASE</a>
<a name="ln1246">             || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE</a>
<a name="ln1247">             || c == K_RIGHTDRAG || c == K_RIGHTRELEASE</a>
<a name="ln1248">             || c == K_MOUSELEFT || c == K_MOUSERIGHT</a>
<a name="ln1249">             || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln1250">             || c == K_MOUSEMOVE);</a>
<a name="ln1251">    os_breakcheck();</a>
<a name="ln1252"> </a>
<a name="ln1253">    // Avoid that the mouse-up event causes visual mode to start.</a>
<a name="ln1254">    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE</a>
<a name="ln1255">        || c == K_X1MOUSE || c == K_X2MOUSE) {</a>
<a name="ln1256">      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);</a>
<a name="ln1257">    } else if (vim_strchr(&quot;\r\n &quot;, c) == NULL &amp;&amp; c != Ctrl_C) {</a>
<a name="ln1258">      // Put the character back in the typeahead buffer.  Don't use the</a>
<a name="ln1259">      // stuff buffer, because lmaps wouldn't work.</a>
<a name="ln1260">      ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1261">      do_redraw = true;             // need a redraw even though there is</a>
<a name="ln1262">                                    // typeahead</a>
<a name="ln1263">    }</a>
<a name="ln1264">  }</a>
<a name="ln1265">  redir_off = false;</a>
<a name="ln1266"> </a>
<a name="ln1267">  // If the user hits ':', '?' or '/' we get a command line from the next</a>
<a name="ln1268">  // line.</a>
<a name="ln1269">  if (c == ':' || c == '?' || c == '/') {</a>
<a name="ln1270">    if (!exmode_active) {</a>
<a name="ln1271">      cmdline_row = msg_row;</a>
<a name="ln1272">    }</a>
<a name="ln1273">    skip_redraw = true;  // skip redraw once</a>
<a name="ln1274">    do_redraw = false;</a>
<a name="ln1275">    msg_ext_keep_after_cmdline = true;</a>
<a name="ln1276">  }</a>
<a name="ln1277"> </a>
<a name="ln1278">  // If the screen size changed screen_resize() will redraw the screen.</a>
<a name="ln1279">  // Otherwise the screen is only redrawn if 'redraw' is set and no ':'</a>
<a name="ln1280">  // typed.</a>
<a name="ln1281">  tmpState = State;</a>
<a name="ln1282">  State = oldState;  // restore State before screen_resize()</a>
<a name="ln1283">  setmouse();</a>
<a name="ln1284">  msg_check();</a>
<a name="ln1285">  need_wait_return = false;</a>
<a name="ln1286">  did_wait_return = true;</a>
<a name="ln1287">  emsg_on_display = false;      // can delete error message now</a>
<a name="ln1288">  lines_left = -1;              // reset lines_left at next msg_start()</a>
<a name="ln1289">  reset_last_sourcing();</a>
<a name="ln1290">  if (keep_msg != NULL &amp;&amp; vim_strsize(keep_msg) &gt;=</a>
<a name="ln1291">      (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln1292">    XFREE_CLEAR(keep_msg);          // don't redisplay message, it's too long</a>
<a name="ln1293">  }</a>
<a name="ln1294"> </a>
<a name="ln1295">  if (tmpState == MODE_SETWSIZE) {       // got resize event while in vgetc()</a>
<a name="ln1296">    ui_refresh();</a>
<a name="ln1297">  } else if (!skip_redraw) {</a>
<a name="ln1298">    if (redraw == true || (msg_scrolled != 0 &amp;&amp; redraw != -1)) {</a>
<a name="ln1299">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln1300">    }</a>
<a name="ln1301">    if (ui_has(kUIMessages)) {</a>
<a name="ln1302">      msg_ext_clear(true);</a>
<a name="ln1303">    }</a>
<a name="ln1304">  }</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">/// Write the hit-return prompt.</a>
<a name="ln1308">static void hit_return_msg(void)</a>
<a name="ln1309">{</a>
<a name="ln1310">  int save_p_more = p_more;</a>
<a name="ln1311"> </a>
<a name="ln1312">  p_more = false;       // don't want to see this message when scrolling back</a>
<a name="ln1313">  if (msg_didout) {     // start on a new line</a>
<a name="ln1314">    msg_putchar('\n');</a>
<a name="ln1315">  }</a>
<a name="ln1316">  msg_ext_set_kind(&quot;return_prompt&quot;);</a>
<a name="ln1317">  if (got_int) {</a>
<a name="ln1318">    msg_puts(_(&quot;Interrupt: &quot;));</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  msg_puts_attr(_(&quot;Press ENTER or type command to continue&quot;), HL_ATTR(HLF_R));</a>
<a name="ln1322">  if (!msg_use_printf()) {</a>
<a name="ln1323">    msg_clr_eos();</a>
<a name="ln1324">  }</a>
<a name="ln1325">  p_more = save_p_more;</a>
<a name="ln1326">}</a>
<a name="ln1327"> </a>
<a name="ln1328">/// Set &quot;keep_msg&quot; to &quot;s&quot;.  Free the old value and check for NULL pointer.</a>
<a name="ln1329">void set_keep_msg(const char *s, int attr)</a>
<a name="ln1330">{</a>
<a name="ln1331">  xfree(keep_msg);</a>
<a name="ln1332">  if (s != NULL &amp;&amp; msg_silent == 0) {</a>
<a name="ln1333">    keep_msg = xstrdup(s);</a>
<a name="ln1334">  } else {</a>
<a name="ln1335">    keep_msg = NULL;</a>
<a name="ln1336">  }</a>
<a name="ln1337">  keep_msg_more = false;</a>
<a name="ln1338">  keep_msg_attr = attr;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">/// Return true if printing messages should currently be done.</a>
<a name="ln1342">bool messaging(void)</a>
<a name="ln1343">{</a>
<a name="ln1344">  // TODO(bfredl): with general support for &quot;async&quot; messages with p_ch,</a>
<a name="ln1345">  // this should be re-enabled.</a>
<a name="ln1346">  return !(p_lz &amp;&amp; char_avail() &amp;&amp; !KeyTyped) &amp;&amp; (p_ch &gt; 0 || ui_has(kUIMessages));</a>
<a name="ln1347">}</a>
<a name="ln1348"> </a>
<a name="ln1349">void msgmore(int n)</a>
<a name="ln1350">{</a>
<a name="ln1351">  long pn;</a>
<a name="ln1352"> </a>
<a name="ln1353">  if (global_busy           // no messages now, wait until global is finished</a>
<a name="ln1354">      || !messaging()) {      // 'lazyredraw' set, don't do messages now</a>
<a name="ln1355">    return;</a>
<a name="ln1356">  }</a>
<a name="ln1357"> </a>
<a name="ln1358">  // We don't want to overwrite another important message, but do overwrite</a>
<a name="ln1359">  // a previous &quot;more lines&quot; or &quot;fewer lines&quot; message, so that &quot;5dd&quot; and</a>
<a name="ln1360">  // then &quot;put&quot; reports the last action.</a>
<a name="ln1361">  if (keep_msg != NULL &amp;&amp; !keep_msg_more) {</a>
<a name="ln1362">    return;</a>
<a name="ln1363">  }</a>
<a name="ln1364"> </a>
<a name="ln1365">  if (n &gt; 0) {</a>
<a name="ln1366">    pn = n;</a>
<a name="ln1367">  } else {</a>
<a name="ln1368">    pn = -n;</a>
<a name="ln1369">  }</a>
<a name="ln1370"> </a>
<a name="ln1371">  if (pn &gt; p_report) {</a>
<a name="ln1372">    if (n &gt; 0) {</a>
<a name="ln1373">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1374">                   NGETTEXT(&quot;%ld more line&quot;, &quot;%ld more lines&quot;, pn),</a>
<a name="ln1375">                   pn);</a>
<a name="ln1376">    } else {</a>
<a name="ln1377">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1378">                   NGETTEXT(&quot;%ld line less&quot;, &quot;%ld fewer lines&quot;, pn),</a>
<a name="ln1379">                   pn);</a>
<a name="ln1380">    }</a>
<a name="ln1381">    if (got_int) {</a>
<a name="ln1382">      xstrlcat(msg_buf, _(&quot; (Interrupted)&quot;), MSG_BUF_LEN);</a>
<a name="ln1383">    }</a>
<a name="ln1384">    if (msg(msg_buf, 0)) {</a>
<a name="ln1385">      set_keep_msg(msg_buf, 0);</a>
<a name="ln1386">      keep_msg_more = true;</a>
<a name="ln1387">    }</a>
<a name="ln1388">  }</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">void msg_ext_set_kind(const char *msg_kind)</a>
<a name="ln1392">{</a>
<a name="ln1393">  // Don't change the label of an existing batch:</a>
<a name="ln1394">  msg_ext_ui_flush();</a>
<a name="ln1395"> </a>
<a name="ln1396">  // TODO(bfredl): would be nice to avoid dynamic scoping, but that would</a>
<a name="ln1397">  // need refactoring the msg_ interface to not be &quot;please pretend nvim is</a>
<a name="ln1398">  // a terminal for a moment&quot;</a>
<a name="ln1399">  msg_ext_kind = msg_kind;</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">/// Prepare for outputting characters in the command line.</a>
<a name="ln1403">void msg_start(void)</a>
<a name="ln1404">{</a>
<a name="ln1405">  int did_return = false;</a>
<a name="ln1406"> </a>
<a name="ln1407">  if (!msg_silent) {</a>
<a name="ln1408">    XFREE_CLEAR(keep_msg);              // don't display old message now</a>
<a name="ln1409">    need_fileinfo = false;</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">  if (need_clr_eos || (p_ch == 0 &amp;&amp; redrawing_cmdline)) {</a>
<a name="ln1413">    // Halfway an &quot;:echo&quot; command and getting an (error) message: clear</a>
<a name="ln1414">    // any text from the command.</a>
<a name="ln1415">    need_clr_eos = false;</a>
<a name="ln1416">    msg_clr_eos();</a>
<a name="ln1417">  }</a>
<a name="ln1418"> </a>
<a name="ln1419">  // if cmdheight=0, we need to scroll in the first line of msg_grid upon the screen</a>
<a name="ln1420">  if (p_ch == 0 &amp;&amp; !ui_has(kUIMessages) &amp;&amp; !msg_scrolled) {</a>
<a name="ln1421">    msg_grid_validate();</a>
<a name="ln1422">    msg_scroll_up(false, true);</a>
<a name="ln1423">    msg_scrolled++;</a>
<a name="ln1424">    cmdline_row = Rows - 1;</a>
<a name="ln1425">  }</a>
<a name="ln1426"> </a>
<a name="ln1427">  if (!msg_scroll &amp;&amp; full_screen) {     // overwrite last message</a>
<a name="ln1428">    msg_row = cmdline_row;</a>
<a name="ln1429">    msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln1430">  } else if (msg_didout || (p_ch == 0 &amp;&amp; !ui_has(kUIMessages))) {  // start message on next line</a>
<a name="ln1431">    msg_putchar('\n');</a>
<a name="ln1432">    did_return = true;</a>
<a name="ln1433">    cmdline_row = msg_row;</a>
<a name="ln1434">  }</a>
<a name="ln1435">  if (!msg_didany || lines_left &lt; 0) {</a>
<a name="ln1436">    msg_starthere();</a>
<a name="ln1437">  }</a>
<a name="ln1438">  if (msg_silent == 0) {</a>
<a name="ln1439">    msg_didout = false;                     // no output on current line yet</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  if (ui_has(kUIMessages)) {</a>
<a name="ln1443">    msg_ext_ui_flush();</a>
<a name="ln1444">    if (!msg_scroll &amp;&amp; msg_ext_visible) {</a>
<a name="ln1445">      // Will overwrite last message.</a>
<a name="ln1446">      msg_ext_overwrite = true;</a>
<a name="ln1447">    }</a>
<a name="ln1448">  }</a>
<a name="ln1449"> </a>
<a name="ln1450">  // When redirecting, may need to start a new line.</a>
<a name="ln1451">  if (!did_return) {</a>
<a name="ln1452">    redir_write(&quot;\n&quot;, 1);</a>
<a name="ln1453">  }</a>
<a name="ln1454">}</a>
<a name="ln1455"> </a>
<a name="ln1456">/// Note that the current msg position is where messages start.</a>
<a name="ln1457">void msg_starthere(void)</a>
<a name="ln1458">{</a>
<a name="ln1459">  lines_left = cmdline_row;</a>
<a name="ln1460">  msg_didany = false;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">void msg_putchar(int c)</a>
<a name="ln1464">{</a>
<a name="ln1465">  msg_putchar_attr(c, 0);</a>
<a name="ln1466">}</a>
<a name="ln1467"> </a>
<a name="ln1468">void msg_putchar_attr(int c, int attr)</a>
<a name="ln1469">{</a>
<a name="ln1470">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln1471"> </a>
<a name="ln1472">  if (IS_SPECIAL(c)) {</a>
<a name="ln1473">    buf[0] = (char)K_SPECIAL;</a>
<a name="ln1474">    buf[1] = (char)K_SECOND(c);</a>
<a name="ln1475">    buf[2] = (char)K_THIRD(c);</a>
<a name="ln1476">    buf[3] = NUL;</a>
<a name="ln1477">  } else {</a>
<a name="ln1478">    buf[utf_char2bytes(c, buf)] = NUL;</a>
<a name="ln1479">  }</a>
<a name="ln1480">  msg_puts_attr(buf, attr);</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483">void msg_outnum(int n)</a>
<a name="ln1484">{</a>
<a name="ln1485">  char buf[20];</a>
<a name="ln1486"> </a>
<a name="ln1487">  snprintf(buf, sizeof(buf), &quot;%d&quot;, n);</a>
<a name="ln1488">  msg_puts(buf);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">void msg_home_replace(const char *fname)</a>
<a name="ln1492">{</a>
<a name="ln1493">  msg_home_replace_attr(fname, 0);</a>
<a name="ln1494">}</a>
<a name="ln1495"> </a>
<a name="ln1496">void msg_home_replace_hl(const char *fname)</a>
<a name="ln1497">{</a>
<a name="ln1498">  msg_home_replace_attr(fname, HL_ATTR(HLF_D));</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">static void msg_home_replace_attr(const char *fname, int attr)</a>
<a name="ln1502">{</a>
<a name="ln1503">  char *name = home_replace_save(NULL, fname);</a>
<a name="ln1504">  msg_outtrans(name, attr);</a>
<a name="ln1505">  xfree(name);</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">/// Output 'len' characters in 'str' (including NULs) with translation</a>
<a name="ln1509">/// if 'len' is -1, output up to a NUL character.</a>
<a name="ln1510">/// Use attributes 'attr'.</a>
<a name="ln1511">///</a>
<a name="ln1512">/// @return  the number of characters it takes on the screen.</a>
<a name="ln1513">int msg_outtrans(const char *str, int attr)</a>
<a name="ln1514">{</a>
<a name="ln1515">  return msg_outtrans_len(str, (int)strlen(str), attr);</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">/// Output one character at &quot;p&quot;.</a>
<a name="ln1519">/// Handles multi-byte characters.</a>
<a name="ln1520">///</a>
<a name="ln1521">/// @return  pointer to the next character.</a>
<a name="ln1522">const char *msg_outtrans_one(const char *p, int attr)</a>
<a name="ln1523">{</a>
<a name="ln1524">  int l;</a>
<a name="ln1525"> </a>
<a name="ln1526">  if ((l = utfc_ptr2len(p)) &gt; 1) {</a>
<a name="ln1527">    msg_outtrans_len(p, l, attr);</a>
<a name="ln1528">    return p + l;</a>
<a name="ln1529">  }</a>
<a name="ln1530">  msg_puts_attr(transchar_byte_buf(NULL, (uint8_t)(*p)), attr);</a>
<a name="ln1531">  return p + 1;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">int msg_outtrans_len(const char *msgstr, int len, int attr)</a>
<a name="ln1535">{</a>
<a name="ln1536">  int retval = 0;</a>
<a name="ln1537">  const char *str = msgstr;</a>
<a name="ln1538">  const char *plain_start = msgstr;</a>
<a name="ln1539">  char *s;</a>
<a name="ln1540">  int c;</a>
<a name="ln1541">  int save_got_int = got_int;</a>
<a name="ln1542"> </a>
<a name="ln1543">  // Only quit when got_int was set in here.</a>
<a name="ln1544">  got_int = false;</a>
<a name="ln1545"> </a>
<a name="ln1546">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1547">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1548">    add_msg_hist(str, len, attr, false);</a>
<a name="ln1549">    attr &amp;= ~MSG_HIST;</a>
<a name="ln1550">  }</a>
<a name="ln1551"> </a>
<a name="ln1552">  // When drawing over the command line no need to clear it later or remove</a>
<a name="ln1553">  // the mode message.</a>
<a name="ln1554">  if (msg_row &gt;= cmdline_row &amp;&amp; msg_col == 0) {</a>
<a name="ln1555">    clear_cmdline = false;</a>
<a name="ln1556">    mode_displayed = false;</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">  // If the string starts with a composing character first draw a space on</a>
<a name="ln1560">  // which the composing char can be drawn.</a>
<a name="ln1561">  if (utf_iscomposing(utf_ptr2char(msgstr))) {</a>
<a name="ln1562">    msg_puts_attr(&quot; &quot;, attr);</a>
<a name="ln1563">  }</a>
<a name="ln1564"> </a>
<a name="ln1565">  // Go over the string.  Special characters are translated and printed.</a>
<a name="ln1566">  // Normal characters are printed several at a time.</a>
<a name="ln1567">  while (--len &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1568">    // Don't include composing chars after the end.</a>
<a name="ln1569">    int mb_l = utfc_ptr2len_len(str, len + 1);</a>
<a name="ln1570">    if (mb_l &gt; 1) {</a>
<a name="ln1571">      c = utf_ptr2char(str);</a>
<a name="ln1572">      if (vim_isprintc(c)) {</a>
<a name="ln1573">        // Printable multi-byte char: count the cells.</a>
<a name="ln1574">        retval += utf_ptr2cells(str);</a>
<a name="ln1575">      } else {</a>
<a name="ln1576">        // Unprintable multi-byte char: print the printable chars so</a>
<a name="ln1577">        // far and the translation of the unprintable char.</a>
<a name="ln1578">        if (str &gt; plain_start) {</a>
<a name="ln1579">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1580">        }</a>
<a name="ln1581">        plain_start = str + mb_l;</a>
<a name="ln1582">        msg_puts_attr(transchar_buf(NULL, c), attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1583">        retval += char2cells(c);</a>
<a name="ln1584">      }</a>
<a name="ln1585">      len -= mb_l - 1;</a>
<a name="ln1586">      str += mb_l;</a>
<a name="ln1587">    } else {</a>
<a name="ln1588">      s = transchar_byte_buf(NULL, (uint8_t)(*str));</a>
<a name="ln1589">      if (s[1] != NUL) {</a>
<a name="ln1590">        // Unprintable char: print the printable chars so far and the</a>
<a name="ln1591">        // translation of the unprintable char.</a>
<a name="ln1592">        if (str &gt; plain_start) {</a>
<a name="ln1593">          msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1594">        }</a>
<a name="ln1595">        plain_start = str + 1;</a>
<a name="ln1596">        msg_puts_attr(s, attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1597">        retval += (int)strlen(s);</a>
<a name="ln1598">      } else {</a>
<a name="ln1599">        retval++;</a>
<a name="ln1600">      }</a>
<a name="ln1601">      str++;</a>
<a name="ln1602">    }</a>
<a name="ln1603">  }</a>
<a name="ln1604"> </a>
<a name="ln1605">  if (str &gt; plain_start &amp;&amp; !got_int) {</a>
<a name="ln1606">    // Print the printable chars at the end.</a>
<a name="ln1607">    msg_puts_len(plain_start, str - plain_start, attr);</a>
<a name="ln1608">  }</a>
<a name="ln1609"> </a>
<a name="ln1610">  got_int |= save_got_int;</a>
<a name="ln1611"> </a>
<a name="ln1612">  return retval;</a>
<a name="ln1613">}</a>
<a name="ln1614"> </a>
<a name="ln1615">void msg_make(const char *arg)</a>
<a name="ln1616">{</a>
<a name="ln1617">  int i;</a>
<a name="ln1618">  static const char *str = &quot;eeffoc&quot;;</a>
<a name="ln1619">  static const char *rs = &quot;Plon#dqg#vxjduB&quot;;</a>
<a name="ln1620"> </a>
<a name="ln1621">  arg = skipwhite(arg);</a>
<a name="ln1622">  for (i = 5; *arg &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln1623">    if (*arg++ != str[i]) {</a>
<a name="ln1624">      break;</a>
<a name="ln1625">    }</a>
<a name="ln1626">  }</a>
<a name="ln1627">  if (i &lt; 0) {</a>
<a name="ln1628">    msg_putchar('\n');</a>
<a name="ln1629">    for (i = 0; rs[i]; i++) {</a>
<a name="ln1630">      msg_putchar(rs[i] - 3);</a>
<a name="ln1631">    }</a>
<a name="ln1632">  }</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">/// Output the string 'str' up to a NUL character.</a>
<a name="ln1636">/// Return the number of characters it takes on the screen.</a>
<a name="ln1637">///</a>
<a name="ln1638">/// If K_SPECIAL is encountered, then it is taken in conjunction with the</a>
<a name="ln1639">/// following character and shown as &lt;F1&gt;, &lt;S-Up&gt; etc.  Any other character</a>
<a name="ln1640">/// which is not printable shown in &lt;&gt; form.</a>
<a name="ln1641">/// If 'from' is true (lhs of a mapping), a space is shown as &lt;Space&gt;.</a>
<a name="ln1642">/// If a character is displayed in one of these special ways, is also</a>
<a name="ln1643">/// highlighted (its highlight name is '8' in the p_hl variable).</a>
<a name="ln1644">/// Otherwise characters are not highlighted.</a>
<a name="ln1645">/// This function is used to show mappings, where we want to see how to type</a>
<a name="ln1646">/// the character/string -- webb</a>
<a name="ln1647">///</a>
<a name="ln1648">/// @param from  true for LHS of a mapping</a>
<a name="ln1649">/// @param maxlen  screen columns, 0 for unlimited</a>
<a name="ln1650">int msg_outtrans_special(const char *strstart, bool from, int maxlen)</a>
<a name="ln1651">{</a>
<a name="ln1652">  if (strstart == NULL) {</a>
<a name="ln1653">    return 0;  // Do nothing.</a>
<a name="ln1654">  }</a>
<a name="ln1655">  const char *str = strstart;</a>
<a name="ln1656">  int retval = 0;</a>
<a name="ln1657">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln1658"> </a>
<a name="ln1659">  while (*str != NUL) {</a>
<a name="ln1660">    const char *text;</a>
<a name="ln1661">    // Leading and trailing spaces need to be displayed in &lt;&gt; form.</a>
<a name="ln1662">    if ((str == strstart || str[1] == NUL) &amp;&amp; *str == ' ') {</a>
<a name="ln1663">      text = &quot;&lt;Space&gt;&quot;;</a>
<a name="ln1664">      str++;</a>
<a name="ln1665">    } else {</a>
<a name="ln1666">      text = str2special(&amp;str, from, false);</a>
<a name="ln1667">    }</a>
<a name="ln1668">    if (text[0] != NUL &amp;&amp; text[1] == NUL) {</a>
<a name="ln1669">      // single-byte character or illegal byte</a>
<a name="ln1670">      text = transchar_byte_buf(NULL, (uint8_t)text[0]);</a>
<a name="ln1671">    }</a>
<a name="ln1672">    const int len = vim_strsize(text);</a>
<a name="ln1673">    if (maxlen &gt; 0 &amp;&amp; retval + len &gt;= maxlen) {</a>
<a name="ln1674">      break;</a>
<a name="ln1675">    }</a>
<a name="ln1676">    // Highlight special keys</a>
<a name="ln1677">    msg_puts_attr(text, (len &gt; 1</a>
<a name="ln1678">                         &amp;&amp; utfc_ptr2len(text) &lt;= 1</a>
<a name="ln1679">                         ? attr : 0));</a>
<a name="ln1680">    retval += len;</a>
<a name="ln1681">  }</a>
<a name="ln1682">  return retval;</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">/// Convert string, replacing key codes with printables</a>
<a name="ln1686">///</a>
<a name="ln1687">/// Used for lhs or rhs of mappings.</a>
<a name="ln1688">///</a>
<a name="ln1689">/// @param[in]  str  String to convert.</a>
<a name="ln1690">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1691">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1692">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1693">///</a>
<a name="ln1694">/// @return [allocated] Converted string.</a>
<a name="ln1695">char *str2special_save(const char *const str, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1696">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1697">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1698">{</a>
<a name="ln1699">  garray_T ga;</a>
<a name="ln1700">  ga_init(&amp;ga, 1, 40);</a>
<a name="ln1701"> </a>
<a name="ln1702">  const char *p = str;</a>
<a name="ln1703">  while (*p != NUL) {</a>
<a name="ln1704">    ga_concat(&amp;ga, str2special(&amp;p, replace_spaces, replace_lt));</a>
<a name="ln1705">  }</a>
<a name="ln1706">  ga_append(&amp;ga, NUL);</a>
<a name="ln1707">  return (char *)ga.ga_data;</a>
<a name="ln1708">}</a>
<a name="ln1709"> </a>
<a name="ln1710">/// Convert character, replacing key with printable representation.</a>
<a name="ln1711">///</a>
<a name="ln1712">/// @param[in,out]  sp  String to convert. Is advanced to the next key code.</a>
<a name="ln1713">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used for</a>
<a name="ln1714">///                             lhs of mapping and keytrans(), but not rhs.</a>
<a name="ln1715">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1716">///</a>
<a name="ln1717">/// @return Converted key code, in a static buffer. Buffer is always one and the</a>
<a name="ln1718">///         same, so save converted string somewhere before running str2special</a>
<a name="ln1719">///         for the second time.</a>
<a name="ln1720">///         On illegal byte return a string with only that byte.</a>
<a name="ln1721">const char *str2special(const char **const sp, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1722">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET</a>
<a name="ln1723">{</a>
<a name="ln1724">  static char buf[7];</a>
<a name="ln1725"> </a>
<a name="ln1726">  {</a>
<a name="ln1727">    // Try to un-escape a multi-byte character.  Return the un-escaped</a>
<a name="ln1728">    // string if it is a multi-byte character.</a>
<a name="ln1729">    const char *const p = mb_unescape(sp);</a>
<a name="ln1730">    if (p != NULL) {</a>
<a name="ln1731">      return p;</a>
<a name="ln1732">    }</a>
<a name="ln1733">  }</a>
<a name="ln1734"> </a>
<a name="ln1735">  const char *str = *sp;</a>
<a name="ln1736">  int c = (uint8_t)(*str);</a>
<a name="ln1737">  int modifiers = 0;</a>
<a name="ln1738">  bool special = false;</a>
<a name="ln1739">  if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1740">    if ((uint8_t)str[1] == KS_MODIFIER) {</a>
<a name="ln1741">      modifiers = (uint8_t)str[2];</a>
<a name="ln1742">      str += 3;</a>
<a name="ln1743">      c = (uint8_t)(*str);</a>
<a name="ln1744">    }</a>
<a name="ln1745">    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1746">      c = TO_SPECIAL((uint8_t)str[1], (uint8_t)str[2]);</a>
<a name="ln1747">      str += 2;</a>
<a name="ln1748">    }</a>
<a name="ln1749">    if (IS_SPECIAL(c) || modifiers) {  // Special key.</a>
<a name="ln1750">      special = true;</a>
<a name="ln1751">    }</a>
<a name="ln1752">  }</a>
<a name="ln1753"> </a>
<a name="ln1754">  if (!IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1) {</a>
<a name="ln1755">    *sp = str;</a>
<a name="ln1756">    // Try to un-escape a multi-byte character after modifiers.</a>
<a name="ln1757">    const char *p = mb_unescape(sp);</a>
<a name="ln1758">    if (p != NULL) {</a>
<a name="ln1759">      // Since 'special' is true the multi-byte character 'c' will be</a>
<a name="ln1760">      // processed by get_special_key_name().</a>
<a name="ln1761">      c = utf_ptr2char(p);</a>
<a name="ln1762">    } else {</a>
<a name="ln1763">      // illegal byte</a>
<a name="ln1764">      *sp = str + 1;</a>
<a name="ln1765">    }</a>
<a name="ln1766">  } else {</a>
<a name="ln1767">    // single-byte character, NUL or illegal byte</a>
<a name="ln1768">    *sp = str + (*str == NUL ? 0 : 1);</a>
<a name="ln1769">  }</a>
<a name="ln1770"> </a>
<a name="ln1771">  // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.</a>
<a name="ln1772">  if (special</a>
<a name="ln1773">      || c &lt; ' '</a>
<a name="ln1774">      || (replace_spaces &amp;&amp; c == ' ')</a>
<a name="ln1775">      || (replace_lt &amp;&amp; c == '&lt;')) {</a>
<a name="ln1776">    return get_special_key_name(c, modifiers);</a>
<a name="ln1777">  }</a>
<a name="ln1778">  buf[0] = (char)c;</a>
<a name="ln1779">  buf[1] = NUL;</a>
<a name="ln1780">  return buf;</a>
<a name="ln1781">}</a>
<a name="ln1782"> </a>
<a name="ln1783">/// Convert string, replacing key codes with printables</a>
<a name="ln1784">///</a>
<a name="ln1785">/// @param[in]  str  String to convert.</a>
<a name="ln1786">/// @param[out]  buf  Buffer to save results to.</a>
<a name="ln1787">/// @param[in]  len  Buffer length.</a>
<a name="ln1788">void str2specialbuf(const char *sp, char *buf, size_t len)</a>
<a name="ln1789">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1790">{</a>
<a name="ln1791">  while (*sp) {</a>
<a name="ln1792">    const char *s = str2special(&amp;sp, false, false);</a>
<a name="ln1793">    const size_t s_len = strlen(s);</a>
<a name="ln1794">    if (len &lt;= s_len) {</a>
<a name="ln1795">      break;</a>
<a name="ln1796">    }</a>
<a name="ln1797">    memcpy(buf, s, s_len);</a>
<a name="ln1798">    buf += s_len;</a>
<a name="ln1799">    len -= s_len;</a>
<a name="ln1800">  }</a>
<a name="ln1801">  *buf = NUL;</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">/// print line for :print or :list command</a>
<a name="ln1805">void msg_prt_line(const char *s, int list)</a>
<a name="ln1806">{</a>
<a name="ln1807">  int c;</a>
<a name="ln1808">  int col = 0;</a>
<a name="ln1809">  int n_extra = 0;</a>
<a name="ln1810">  int c_extra = 0;</a>
<a name="ln1811">  int c_final = 0;</a>
<a name="ln1812">  const char *p_extra = NULL;  // init to make SASC shut up</a>
<a name="ln1813">  int n;</a>
<a name="ln1814">  int attr = 0;</a>
<a name="ln1815">  const char *lead = NULL;</a>
<a name="ln1816">  bool in_multispace = false;</a>
<a name="ln1817">  int multispace_pos = 0;</a>
<a name="ln1818">  const char *trail = NULL;</a>
<a name="ln1819">  int l;</a>
<a name="ln1820"> </a>
<a name="ln1821">  if (curwin-&gt;w_p_list) {</a>
<a name="ln1822">    list = true;</a>
<a name="ln1823">  }</a>
<a name="ln1824"> </a>
<a name="ln1825">  if (list) {</a>
<a name="ln1826">    // find start of trailing whitespace</a>
<a name="ln1827">    if (curwin-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1828">      trail = s + strlen(s);</a>
<a name="ln1829">      while (trail &gt; s &amp;&amp; ascii_iswhite(trail[-1])) {</a>
<a name="ln1830">        trail--;</a>
<a name="ln1831">      }</a>
<a name="ln1832">    }</a>
<a name="ln1833">    // find end of leading whitespace</a>
<a name="ln1834">    if (curwin-&gt;w_p_lcs_chars.lead || curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1835">      lead = s;</a>
<a name="ln1836">      while (ascii_iswhite(lead[0])) {</a>
<a name="ln1837">        lead++;</a>
<a name="ln1838">      }</a>
<a name="ln1839">      // in a line full of spaces all of them are treated as trailing</a>
<a name="ln1840">      if (*lead == NUL) {</a>
<a name="ln1841">        lead = NULL;</a>
<a name="ln1842">      }</a>
<a name="ln1843">    }</a>
<a name="ln1844">  }</a>
<a name="ln1845"> </a>
<a name="ln1846">  // output a space for an empty line, otherwise the line will be overwritten</a>
<a name="ln1847">  if (*s == NUL &amp;&amp; !(list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL)) {</a>
<a name="ln1848">    msg_putchar(' ');</a>
<a name="ln1849">  }</a>
<a name="ln1850"> </a>
<a name="ln1851">  while (!got_int) {</a>
<a name="ln1852">    if (n_extra &gt; 0) {</a>
<a name="ln1853">      n_extra--;</a>
<a name="ln1854">      if (n_extra == 0 &amp;&amp; c_final) {</a>
<a name="ln1855">        c = c_final;</a>
<a name="ln1856">      } else if (c_extra) {</a>
<a name="ln1857">        c = c_extra;</a>
<a name="ln1858">      } else {</a>
<a name="ln1859">        assert(p_extra != NULL);</a>
<a name="ln1860">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1861">      }</a>
<a name="ln1862">    } else if ((l = utfc_ptr2len(s)) &gt; 1) {</a>
<a name="ln1863">      col += utf_ptr2cells(s);</a>
<a name="ln1864">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln1865">      if (l &gt;= MB_MAXBYTES) {</a>
<a name="ln1866">        xstrlcpy(buf, &quot;?&quot;, sizeof(buf));</a>
<a name="ln1867">      } else if (curwin-&gt;w_p_lcs_chars.nbsp != NUL &amp;&amp; list</a>
<a name="ln1868">                 &amp;&amp; (utf_ptr2char(s) == 160</a>
<a name="ln1869">                     || utf_ptr2char(s) == 0x202f)) {</a>
<a name="ln1870">        int len = utf_char2bytes(curwin-&gt;w_p_lcs_chars.nbsp, buf);</a>
<a name="ln1871">        buf[len] = NUL;</a>
<a name="ln1872">      } else {</a>
<a name="ln1873">        memmove(buf, s, (size_t)l);</a>
<a name="ln1874">        buf[l] = NUL;</a>
<a name="ln1875">      }</a>
<a name="ln1876">      msg_puts(buf);</a>
<a name="ln1877">      s += l;</a>
<a name="ln1878">      continue;</a>
<a name="ln1879">    } else {</a>
<a name="ln1880">      attr = 0;</a>
<a name="ln1881">      c = (uint8_t)(*s++);</a>
<a name="ln1882">      if (list) {</a>
<a name="ln1883">        in_multispace = c == ' ' &amp;&amp; (*s == ' '</a>
<a name="ln1884">                                     || (col &gt; 0 &amp;&amp; s[-2] == ' '));</a>
<a name="ln1885">        if (!in_multispace) {</a>
<a name="ln1886">          multispace_pos = 0;</a>
<a name="ln1887">        }</a>
<a name="ln1888">      }</a>
<a name="ln1889">      if (c == TAB &amp;&amp; (!list || curwin-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1890">        // tab amount depends on current column</a>
<a name="ln1891">        n_extra = tabstop_padding(col,</a>
<a name="ln1892">                                  curbuf-&gt;b_p_ts,</a>
<a name="ln1893">                                  curbuf-&gt;b_p_vts_array) - 1;</a>
<a name="ln1894">        if (!list) {</a>
<a name="ln1895">          c = ' ';</a>
<a name="ln1896">          c_extra = ' ';</a>
<a name="ln1897">          c_final = NUL;</a>
<a name="ln1898">        } else {</a>
<a name="ln1899">          c = (n_extra == 0 &amp;&amp; curwin-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln1900">              ? curwin-&gt;w_p_lcs_chars.tab3</a>
<a name="ln1901">              : curwin-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1902">          c_extra = curwin-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1903">          c_final = curwin-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1904">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1905">        }</a>
<a name="ln1906">      } else if (c == 160 &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp != NUL) {</a>
<a name="ln1907">        c = curwin-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1908">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1909">      } else if (c == NUL &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL) {</a>
<a name="ln1910">        p_extra = &quot;&quot;;</a>
<a name="ln1911">        c_extra = NUL;</a>
<a name="ln1912">        c_final = NUL;</a>
<a name="ln1913">        n_extra = 1;</a>
<a name="ln1914">        c = curwin-&gt;w_p_lcs_chars.eol;</a>
<a name="ln1915">        attr = HL_ATTR(HLF_AT);</a>
<a name="ln1916">        s--;</a>
<a name="ln1917">      } else if (c != NUL &amp;&amp; (n = byte2cells(c)) &gt; 1) {</a>
<a name="ln1918">        n_extra = n - 1;</a>
<a name="ln1919">        p_extra = transchar_byte_buf(NULL, c);</a>
<a name="ln1920">        c_extra = NUL;</a>
<a name="ln1921">        c_final = NUL;</a>
<a name="ln1922">        c = (unsigned char)(*p_extra++);</a>
<a name="ln1923">        // Use special coloring to be able to distinguish &lt;hex&gt; from</a>
<a name="ln1924">        // the same in plain text.</a>
<a name="ln1925">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1926">      } else if (c == ' ') {</a>
<a name="ln1927">        if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; in_multispace</a>
<a name="ln1928">            &amp;&amp; curwin-&gt;w_p_lcs_chars.leadmultispace != NULL) {</a>
<a name="ln1929">          c = curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos++];</a>
<a name="ln1930">          if (curwin-&gt;w_p_lcs_chars.leadmultispace[multispace_pos] == NUL) {</a>
<a name="ln1931">            multispace_pos = 0;</a>
<a name="ln1932">          }</a>
<a name="ln1933">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1934">        } else if (lead != NULL &amp;&amp; s &lt;= lead &amp;&amp; curwin-&gt;w_p_lcs_chars.lead != NUL) {</a>
<a name="ln1935">          c = curwin-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1936">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1937">        } else if (trail != NULL &amp;&amp; s &gt; trail) {</a>
<a name="ln1938">          c = curwin-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1939">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1940">        } else if (in_multispace</a>
<a name="ln1941">                   &amp;&amp; curwin-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1942">          c = curwin-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1943">          if (curwin-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1944">            multispace_pos = 0;</a>
<a name="ln1945">          }</a>
<a name="ln1946">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1947">        } else if (list &amp;&amp; curwin-&gt;w_p_lcs_chars.space != NUL) {</a>
<a name="ln1948">          c = curwin-&gt;w_p_lcs_chars.space;</a>
<a name="ln1949">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1950">        }</a>
<a name="ln1951">      }</a>
<a name="ln1952">    }</a>
<a name="ln1953"> </a>
<a name="ln1954">    if (c == NUL) {</a>
<a name="ln1955">      break;</a>
<a name="ln1956">    }</a>
<a name="ln1957"> </a>
<a name="ln1958">    msg_putchar_attr(c, attr);</a>
<a name="ln1959">    col++;</a>
<a name="ln1960">  }</a>
<a name="ln1961">  msg_clr_eos();</a>
<a name="ln1962">}</a>
<a name="ln1963"> </a>
<a name="ln1964">/// Output a string to the screen at position msg_row, msg_col.</a>
<a name="ln1965">/// Update msg_row and msg_col for the next message.</a>
<a name="ln1966">void msg_puts(const char *s)</a>
<a name="ln1967">{</a>
<a name="ln1968">  msg_puts_attr(s, 0);</a>
<a name="ln1969">}</a>
<a name="ln1970"> </a>
<a name="ln1971">void msg_puts_title(const char *s)</a>
<a name="ln1972">{</a>
<a name="ln1973">  msg_puts_attr(s, HL_ATTR(HLF_T));</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">/// Show a message in such a way that it always fits in the line.  Cut out a</a>
<a name="ln1977">/// part in the middle and replace it with &quot;...&quot; when necessary.</a>
<a name="ln1978">/// Does not handle multi-byte characters!</a>
<a name="ln1979">void msg_outtrans_long(const char *longstr, int attr)</a>
<a name="ln1980">{</a>
<a name="ln1981">  int len = (int)strlen(longstr);</a>
<a name="ln1982">  int slen = len;</a>
<a name="ln1983">  int room = Columns - msg_col;</a>
<a name="ln1984">  if (len &gt; room &amp;&amp; room &gt;= 20) {</a>
<a name="ln1985">    slen = (room - 3) / 2;</a>
<a name="ln1986">    msg_outtrans_len(longstr, slen, attr);</a>
<a name="ln1987">    msg_puts_attr(&quot;...&quot;, HL_ATTR(HLF_8));</a>
<a name="ln1988">  }</a>
<a name="ln1989">  msg_outtrans_len(longstr + len - slen, slen, attr);</a>
<a name="ln1990">}</a>
<a name="ln1991"> </a>
<a name="ln1992">/// Basic function for writing a message with highlight attributes.</a>
<a name="ln1993">void msg_puts_attr(const char *const s, const int attr)</a>
<a name="ln1994">{</a>
<a name="ln1995">  msg_puts_len(s, -1, attr);</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/// Write a message with highlight attributes</a>
<a name="ln1999">///</a>
<a name="ln2000">/// @param[in]  str  NUL-terminated message string.</a>
<a name="ln2001">/// @param[in]  len  Length of the string or -1.</a>
<a name="ln2002">/// @param[in]  attr  Highlight attribute.</a>
<a name="ln2003">void msg_puts_len(const char *const str, const ptrdiff_t len, int attr)</a>
<a name="ln2004">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2005">{</a>
<a name="ln2006">  assert(len &lt; 0 || memchr(str, 0, (size_t)len) == NULL);</a>
<a name="ln2007">  // If redirection is on, also write to the redirection file.</a>
<a name="ln2008">  redir_write(str, len);</a>
<a name="ln2009"> </a>
<a name="ln2010">  // Don't print anything when using &quot;:silent cmd&quot;.</a>
<a name="ln2011">  if (msg_silent != 0) {</a>
<a name="ln2012">    return;</a>
<a name="ln2013">  }</a>
<a name="ln2014"> </a>
<a name="ln2015">  // if MSG_HIST flag set, add message to history</a>
<a name="ln2016">  if (attr &amp; MSG_HIST) {</a>
<a name="ln2017">    add_msg_hist(str, (int)len, attr, false);</a>
<a name="ln2018">    attr &amp;= ~MSG_HIST;</a>
<a name="ln2019">  }</a>
<a name="ln2020"> </a>
<a name="ln2021">  // When writing something to the screen after it has scrolled, requires a</a>
<a name="ln2022">  // wait-return prompt later.  Needed when scrolling, resetting</a>
<a name="ln2023">  // need_wait_return after some prompt, and then outputting something</a>
<a name="ln2024">  // without scrolling</a>
<a name="ln2025">  // Not needed when only using CR to move the cursor.</a>
<a name="ln2026">  bool overflow = false;</a>
<a name="ln2027">  if (ui_has(kUIMessages)) {</a>
<a name="ln2028">    int count = msg_ext_visible + (msg_ext_overwrite ? 0 : 1);</a>
<a name="ln2029">    // TODO(bfredl): possible extension point, let external UI control this</a>
<a name="ln2030">    if (count &gt; 1) {</a>
<a name="ln2031">      overflow = true;</a>
<a name="ln2032">    }</a>
<a name="ln2033">  } else {</a>
<a name="ln2034">    overflow = msg_scrolled &gt; (p_ch == 0 ? 1 : 0);</a>
<a name="ln2035">  }</a>
<a name="ln2036"> </a>
<a name="ln2037">  if (overflow &amp;&amp; !msg_scrolled_ign &amp;&amp; strcmp(str, &quot;\r&quot;) != 0) {</a>
<a name="ln2038">    need_wait_return = true;</a>
<a name="ln2039">  }</a>
<a name="ln2040">  msg_didany = true;  // remember that something was outputted</a>
<a name="ln2041"> </a>
<a name="ln2042">  // If there is no valid screen, use fprintf so we can see error messages.</a>
<a name="ln2043">  // If termcap is not active, we may be writing in an alternate console</a>
<a name="ln2044">  // window, cursor positioning may not work correctly (window size may be</a>
<a name="ln2045">  // different, e.g. for Win32 console) or we just don't know where the</a>
<a name="ln2046">  // cursor is.</a>
<a name="ln2047">  if (msg_use_printf()) {</a>
<a name="ln2048">    int saved_msg_col = msg_col;</a>
<a name="ln2049">    msg_puts_printf(str, len);</a>
<a name="ln2050">    if (headless_mode) {</a>
<a name="ln2051">      msg_col = saved_msg_col;</a>
<a name="ln2052">    }</a>
<a name="ln2053">  }</a>
<a name="ln2054">  if (!msg_use_printf() || (headless_mode &amp;&amp; default_grid.chars)) {</a>
<a name="ln2055">    msg_puts_display(str, (int)len, attr, false);</a>
<a name="ln2056">  }</a>
<a name="ln2057"> </a>
<a name="ln2058">  need_fileinfo = false;</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061">/// Print a formatted message</a>
<a name="ln2062">///</a>
<a name="ln2063">/// Message printed is limited by #IOSIZE. Must not be used from inside</a>
<a name="ln2064">/// msg_puts_attr().</a>
<a name="ln2065">///</a>
<a name="ln2066">/// @param[in]  attr  Highlight attributes.</a>
<a name="ln2067">/// @param[in]  fmt  Format string.</a>
<a name="ln2068">void msg_printf_attr(const int attr, const char *const fmt, ...)</a>
<a name="ln2069">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2070">{</a>
<a name="ln2071">  static char msgbuf[IOSIZE];</a>
<a name="ln2072"> </a>
<a name="ln2073">  va_list ap;</a>
<a name="ln2074">  va_start(ap, fmt);</a>
<a name="ln2075">  const size_t len = (size_t)vim_vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);</a>
<a name="ln2076">  va_end(ap);</a>
<a name="ln2077"> </a>
<a name="ln2078">  msg_scroll = true;</a>
<a name="ln2079">  msg_puts_len(msgbuf, (ptrdiff_t)len, attr);</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">static void msg_ext_emit_chunk(void)</a>
<a name="ln2083">{</a>
<a name="ln2084">  // Color was changed or a message flushed, end current chunk.</a>
<a name="ln2085">  if (msg_ext_last_attr == -1) {</a>
<a name="ln2086">    return;  // no chunk</a>
<a name="ln2087">  }</a>
<a name="ln2088">  Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln2089">  ADD(chunk, INTEGER_OBJ(msg_ext_last_attr));</a>
<a name="ln2090">  msg_ext_last_attr = -1;</a>
<a name="ln2091">  String text = ga_take_string(&amp;msg_ext_last_chunk);</a>
<a name="ln2092">  ADD(chunk, STRING_OBJ(text));</a>
<a name="ln2093">  ADD(msg_ext_chunks, ARRAY_OBJ(chunk));</a>
<a name="ln2094">}</a>
<a name="ln2095"> </a>
<a name="ln2096">/// The display part of msg_puts_len().</a>
<a name="ln2097">/// May be called recursively to display scroll-back text.</a>
<a name="ln2098">static void msg_puts_display(const char *str, int maxlen, int attr, int recurse)</a>
<a name="ln2099">{</a>
<a name="ln2100">  const char *s = str;</a>
<a name="ln2101">  const char *sb_str = str;</a>
<a name="ln2102">  int sb_col = msg_col;</a>
<a name="ln2103"> </a>
<a name="ln2104">  did_wait_return = false;</a>
<a name="ln2105"> </a>
<a name="ln2106">  if (ui_has(kUIMessages)) {</a>
<a name="ln2107">    if (attr != msg_ext_last_attr) {</a>
<a name="ln2108">      msg_ext_emit_chunk();</a>
<a name="ln2109">      msg_ext_last_attr = attr;</a>
<a name="ln2110">    }</a>
<a name="ln2111">    // Concat pieces with the same highlight</a>
<a name="ln2112">    size_t len = strnlen(str, (size_t)maxlen);  // -V781</a>
<a name="ln2113">    ga_concat_len(&amp;msg_ext_last_chunk, str, len);</a>
<a name="ln2114">    msg_ext_cur_len += len;</a>
<a name="ln2115">    return;</a>
<a name="ln2116">  }</a>
<a name="ln2117"> </a>
<a name="ln2118">  int print_attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2119">  msg_grid_validate();</a>
<a name="ln2120"> </a>
<a name="ln2121">  cmdline_was_last_drawn = redrawing_cmdline;</a>
<a name="ln2122"> </a>
<a name="ln2123">  int msg_row_pending = -1;</a>
<a name="ln2124"> </a>
<a name="ln2125">  while (true) {</a>
<a name="ln2126">    if (cmdmsg_rl ? msg_col &lt;= 0 : msg_col &gt;= Columns) {</a>
<a name="ln2127">      if (p_more &amp;&amp; !recurse) {</a>
<a name="ln2128">        // Store text for scrolling back.</a>
<a name="ln2129">        store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2130">      }</a>
<a name="ln2131">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2132">        break;</a>
<a name="ln2133">      }</a>
<a name="ln2134"> </a>
<a name="ln2135">      msg_col = cmdmsg_rl ? Columns - 1 : 0;</a>
<a name="ln2136">      msg_row++;</a>
<a name="ln2137">      msg_didout = false;</a>
<a name="ln2138">    }</a>
<a name="ln2139"> </a>
<a name="ln2140">    if (msg_row &gt;= Rows) {</a>
<a name="ln2141">      msg_row = Rows - 1;</a>
<a name="ln2142"> </a>
<a name="ln2143">      // When no more prompt and no more room, truncate here</a>
<a name="ln2144">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2145">        break;</a>
<a name="ln2146">      }</a>
<a name="ln2147"> </a>
<a name="ln2148">      if (!recurse) {</a>
<a name="ln2149">        if (msg_row_pending &gt;= 0) {</a>
<a name="ln2150">          grid_line_flush_if_valid_row();</a>
<a name="ln2151">          msg_row_pending = -1;</a>
<a name="ln2152">        }</a>
<a name="ln2153"> </a>
<a name="ln2154">        // Scroll the screen up one line.</a>
<a name="ln2155">        msg_scroll_up(true, false);</a>
<a name="ln2156"> </a>
<a name="ln2157">        inc_msg_scrolled();</a>
<a name="ln2158">        need_wait_return = true;       // may need wait_return() in main()</a>
<a name="ln2159">        redraw_cmdline = true;</a>
<a name="ln2160">        if (cmdline_row &gt; 0 &amp;&amp; !exmode_active) {</a>
<a name="ln2161">          cmdline_row--;</a>
<a name="ln2162">        }</a>
<a name="ln2163"> </a>
<a name="ln2164">        // If screen is completely filled and 'more' is set then wait</a>
<a name="ln2165">        // for a character.</a>
<a name="ln2166">        if (lines_left &gt; 0) {</a>
<a name="ln2167">          lines_left--;</a>
<a name="ln2168">        }</a>
<a name="ln2169"> </a>
<a name="ln2170">        if (p_more &amp;&amp; lines_left == 0 &amp;&amp; State != MODE_HITRETURN</a>
<a name="ln2171">            &amp;&amp; !msg_no_more &amp;&amp; !exmode_active) {</a>
<a name="ln2172">          if (do_more_prompt(NUL)) {</a>
<a name="ln2173">            s = confirm_msg_tail;</a>
<a name="ln2174">          }</a>
<a name="ln2175">          if (quit_more) {</a>
<a name="ln2176">            return;</a>
<a name="ln2177">          }</a>
<a name="ln2178">        }</a>
<a name="ln2179">      }</a>
<a name="ln2180">    }</a>
<a name="ln2181"> </a>
<a name="ln2182">    if (!((maxlen &lt; 0 || (int)(s - str) &lt; maxlen) &amp;&amp; *s != NUL)) {</a>
<a name="ln2183">      break;</a>
<a name="ln2184">    }</a>
<a name="ln2185"> </a>
<a name="ln2186">    if (msg_row != msg_row_pending &amp;&amp; ((uint8_t)(*s) &gt;= 0x20 || *s == TAB)) {</a>
<a name="ln2187">      // TODO(bfredl): this logic is messier that it has to be. What</a>
<a name="ln2188">      // messages really want is its own private linebuf_char buffer.</a>
<a name="ln2189">      if (msg_row_pending &gt;= 0) {</a>
<a name="ln2190">        grid_line_flush_if_valid_row();</a>
<a name="ln2191">      }</a>
<a name="ln2192">      grid_line_start(&amp;msg_grid_adj, msg_row);</a>
<a name="ln2193">      msg_row_pending = msg_row;</a>
<a name="ln2194">    }</a>
<a name="ln2195"> </a>
<a name="ln2196">    if ((uint8_t)(*s) &gt;= 0x20) {  // printable char</a>
<a name="ln2197">      int cw = utf_ptr2cells(s);</a>
<a name="ln2198">      // avoid including composing chars after the end</a>
<a name="ln2199">      int l = (maxlen &gt;= 0) ? utfc_ptr2len_len(s, (int)((str + maxlen) - s)) : utfc_ptr2len(s);</a>
<a name="ln2200"> </a>
<a name="ln2201">      if (cw &gt; 1 &amp;&amp; (cmdmsg_rl ? msg_col &lt;= 1 : msg_col == Columns - 1)) {</a>
<a name="ln2202">        // Doesn't fit, print a highlighted '&gt;' to fill it up.</a>
<a name="ln2203">        grid_line_puts(msg_col, &quot;&gt;&quot;, 1, HL_ATTR(HLF_AT));</a>
<a name="ln2204">        cw = 1;</a>
<a name="ln2205">      } else {</a>
<a name="ln2206">        grid_line_puts(msg_col, s, l, print_attr);</a>
<a name="ln2207">        s += l;</a>
<a name="ln2208">      }</a>
<a name="ln2209">      msg_didout = true;  // remember that line is not empty</a>
<a name="ln2210">      if (cmdmsg_rl) {</a>
<a name="ln2211">        msg_col -= cw;</a>
<a name="ln2212">      } else {</a>
<a name="ln2213">        msg_col += cw;</a>
<a name="ln2214">      }</a>
<a name="ln2215">    } else {</a>
<a name="ln2216">      char c = *s++;</a>
<a name="ln2217">      if (c == '\n') {  // go to next line</a>
<a name="ln2218">        msg_didout = false;  // remember that line is empty</a>
<a name="ln2219">        if (cmdmsg_rl) {</a>
<a name="ln2220">          msg_col = Columns - 1;</a>
<a name="ln2221">        } else {</a>
<a name="ln2222">          msg_col = 0;</a>
<a name="ln2223">        }</a>
<a name="ln2224">        msg_row++;</a>
<a name="ln2225">        if (p_more &amp;&amp; !recurse) {</a>
<a name="ln2226">          // Store text for scrolling back.</a>
<a name="ln2227">          store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, true);</a>
<a name="ln2228">        }</a>
<a name="ln2229">      } else if (c == '\r') {  // go to column 0</a>
<a name="ln2230">        msg_col = 0;</a>
<a name="ln2231">      } else if (c == '\b') {  // go to previous char</a>
<a name="ln2232">        if (msg_col) {</a>
<a name="ln2233">          msg_col--;</a>
<a name="ln2234">        }</a>
<a name="ln2235">      } else if (c == TAB) {  // translate Tab into spaces</a>
<a name="ln2236">        do {</a>
<a name="ln2237">          grid_line_puts(msg_col, &quot; &quot;, 1, print_attr);</a>
<a name="ln2238">          msg_col += cmdmsg_rl ? -1 : 1;</a>
<a name="ln2239"> </a>
<a name="ln2240">          if (msg_col == (cmdmsg_rl ? 0 : Columns)) {</a>
<a name="ln2241">            break;</a>
<a name="ln2242">          }</a>
<a name="ln2243">        } while (msg_col &amp; 7);</a>
<a name="ln2244">      } else if (c == BELL) {  // beep (from &quot;:sh&quot;)</a>
<a name="ln2245">        vim_beep(BO_SH);</a>
<a name="ln2246">      }</a>
<a name="ln2247">    }</a>
<a name="ln2248">  }</a>
<a name="ln2249"> </a>
<a name="ln2250">  if (msg_row_pending &gt;= 0) {</a>
<a name="ln2251">    grid_line_flush_if_valid_row();</a>
<a name="ln2252">  }</a>
<a name="ln2253">  msg_cursor_goto(msg_row, msg_col);</a>
<a name="ln2254"> </a>
<a name="ln2255">  if (p_more &amp;&amp; !recurse &amp;&amp; !(s == sb_str + 1 &amp;&amp; *sb_str == '\n')) {</a>
<a name="ln2256">    store_sb_text(&amp;sb_str, s, attr, &amp;sb_col, false);</a>
<a name="ln2257">  }</a>
<a name="ln2258"> </a>
<a name="ln2259">  msg_check();</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262">void msg_cursor_goto(int row, int col)</a>
<a name="ln2263">{</a>
<a name="ln2264">  ScreenGrid *grid = &amp;msg_grid_adj;</a>
<a name="ln2265">  grid_adjust(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln2266">  ui_grid_cursor_goto(grid-&gt;handle, row, col);</a>
<a name="ln2267">}</a>
<a name="ln2268"> </a>
<a name="ln2269">/// @return  true when &quot;:filter pattern&quot; was used and &quot;msg&quot; does not match</a>
<a name="ln2270">///          &quot;pattern&quot;.</a>
<a name="ln2271">bool message_filtered(const char *msg)</a>
<a name="ln2272">{</a>
<a name="ln2273">  if (cmdmod.cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2274">    return false;</a>
<a name="ln2275">  }</a>
<a name="ln2276"> </a>
<a name="ln2277">  bool match = vim_regexec(&amp;cmdmod.cmod_filter_regmatch, msg, (colnr_T)0);</a>
<a name="ln2278">  return cmdmod.cmod_filter_force ? match : !match;</a>
<a name="ln2279">}</a>
<a name="ln2280"> </a>
<a name="ln2281">/// including horizontal separator</a>
<a name="ln2282">int msg_scrollsize(void)</a>
<a name="ln2283">{</a>
<a name="ln2284">  return msg_scrolled + (int)p_ch + ((p_ch &gt; 0 || msg_scrolled &gt; 1) ? 1 : 0);</a>
<a name="ln2285">}</a>
<a name="ln2286"> </a>
<a name="ln2287">bool msg_do_throttle(void)</a>
<a name="ln2288">{</a>
<a name="ln2289">  return msg_use_grid() &amp;&amp; !(rdb_flags &amp; RDB_NOTHROTTLE);</a>
<a name="ln2290">}</a>
<a name="ln2291"> </a>
<a name="ln2292">/// Scroll the screen up one line for displaying the next message line.</a>
<a name="ln2293">void msg_scroll_up(bool may_throttle, bool zerocmd)</a>
<a name="ln2294">{</a>
<a name="ln2295">  if (may_throttle &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2296">    msg_grid.throttled = true;</a>
<a name="ln2297">  }</a>
<a name="ln2298">  msg_did_scroll = true;</a>
<a name="ln2299">  if (msg_grid_pos &gt; 0) {</a>
<a name="ln2300">    msg_grid_set_pos(msg_grid_pos - 1, !zerocmd);</a>
<a name="ln2301"> </a>
<a name="ln2302">    // When displaying the first line with cmdheight=0, we need to draw over</a>
<a name="ln2303">    // the existing last line of the screen.</a>
<a name="ln2304">    if (zerocmd &amp;&amp; msg_grid.chars) {</a>
<a name="ln2305">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[0], msg_grid.cols, false);</a>
<a name="ln2306">    }</a>
<a name="ln2307">  } else {</a>
<a name="ln2308">    grid_del_lines(&amp;msg_grid, 0, 1, msg_grid.rows, 0, msg_grid.cols);</a>
<a name="ln2309">    memmove(msg_grid.dirty_col, msg_grid.dirty_col + 1,</a>
<a name="ln2310">            (size_t)(msg_grid.rows - 1) * sizeof(*msg_grid.dirty_col));</a>
<a name="ln2311">    msg_grid.dirty_col[msg_grid.rows - 1] = 0;</a>
<a name="ln2312">  }</a>
<a name="ln2313"> </a>
<a name="ln2314">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317">/// Send throttled message output to UI clients</a>
<a name="ln2318">///</a>
<a name="ln2319">/// The way message.c uses the grid_xx family of functions is quite inefficient</a>
<a name="ln2320">/// relative to the &quot;gridline&quot; UI protocol used by TUI and modern clients.</a>
<a name="ln2321">/// For instance scrolling is done one line at a time. By throttling drawing</a>
<a name="ln2322">/// on the message grid, we can coalesce scrolling to a single grid_scroll</a>
<a name="ln2323">/// per screen update.</a>
<a name="ln2324">///</a>
<a name="ln2325">/// NB: The bookkeeping is quite messy, and rests on a bunch of poorly</a>
<a name="ln2326">/// documented assumptions. For instance that the message area always grows</a>
<a name="ln2327">/// while being throttled, messages are only being output on the last line</a>
<a name="ln2328">/// etc.</a>
<a name="ln2329">///</a>
<a name="ln2330">/// Probably message scrollback storage should be reimplemented as a</a>
<a name="ln2331">/// file_buffer, and message scrolling in TUI be reimplemented as a modal</a>
<a name="ln2332">/// floating window. Then we get throttling &quot;for free&quot; using standard</a>
<a name="ln2333">/// redraw_later code paths.</a>
<a name="ln2334">void msg_scroll_flush(void)</a>
<a name="ln2335">{</a>
<a name="ln2336">  if (msg_grid.throttled) {</a>
<a name="ln2337">    msg_grid.throttled = false;</a>
<a name="ln2338">    int pos_delta = msg_grid_pos_at_flush - msg_grid_pos;</a>
<a name="ln2339">    assert(pos_delta &gt;= 0);</a>
<a name="ln2340">    int delta = MIN(msg_scrolled - msg_scrolled_at_flush, msg_grid.rows);</a>
<a name="ln2341"> </a>
<a name="ln2342">    if (pos_delta &gt; 0) {</a>
<a name="ln2343">      ui_ext_msg_set_pos(msg_grid_pos, true);</a>
<a name="ln2344">    }</a>
<a name="ln2345"> </a>
<a name="ln2346">    int to_scroll = delta - pos_delta - msg_grid_scroll_discount;</a>
<a name="ln2347">    assert(to_scroll &gt;= 0);</a>
<a name="ln2348"> </a>
<a name="ln2349">    // TODO(bfredl): msg_grid_pos should be 0 already when starting scrolling</a>
<a name="ln2350">    // but this sometimes fails in &quot;headless&quot; message printing.</a>
<a name="ln2351">    if (to_scroll &gt; 0 &amp;&amp; msg_grid_pos == 0) {</a>
<a name="ln2352">      ui_call_grid_scroll(msg_grid.handle, 0, Rows, 0, Columns, to_scroll, 0);</a>
<a name="ln2353">    }</a>
<a name="ln2354"> </a>
<a name="ln2355">    for (int i = MAX(Rows - MAX(delta, 1), 0); i &lt; Rows; i++) {</a>
<a name="ln2356">      int row = i - msg_grid_pos;</a>
<a name="ln2357">      assert(row &gt;= 0);</a>
<a name="ln2358">      ui_line(&amp;msg_grid, row, 0, msg_grid.dirty_col[row], msg_grid.cols,</a>
<a name="ln2359">              HL_ATTR(HLF_MSG), false);</a>
<a name="ln2360">      msg_grid.dirty_col[row] = 0;</a>
<a name="ln2361">    }</a>
<a name="ln2362">  }</a>
<a name="ln2363">  msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln2364">  msg_grid_scroll_discount = 0;</a>
<a name="ln2365">  msg_grid_pos_at_flush = msg_grid_pos;</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">void msg_reset_scroll(void)</a>
<a name="ln2369">{</a>
<a name="ln2370">  if (ui_has(kUIMessages)) {</a>
<a name="ln2371">    msg_ext_clear(true);</a>
<a name="ln2372">    return;</a>
<a name="ln2373">  }</a>
<a name="ln2374">  // TODO(bfredl): some duplicate logic with update_screen(). Later on</a>
<a name="ln2375">  // we should properly disentangle message clear with full screen redraw.</a>
<a name="ln2376">  msg_grid.throttled = false;</a>
<a name="ln2377">  // TODO(bfredl): risk for extra flicker i e with</a>
<a name="ln2378">  // &quot;nvim -o has_swap also_has_swap&quot;</a>
<a name="ln2379">  msg_grid_set_pos(Rows - (int)p_ch, false);</a>
<a name="ln2380">  clear_cmdline = true;</a>
<a name="ln2381">  if (msg_grid.chars) {</a>
<a name="ln2382">    // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln2383">    for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.rows); i++) {</a>
<a name="ln2384">      grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln2385">                      msg_grid.cols, false);</a>
<a name="ln2386">    }</a>
<a name="ln2387">  }</a>
<a name="ln2388">  msg_scrolled = 0;</a>
<a name="ln2389">  msg_scrolled_at_flush = 0;</a>
<a name="ln2390">  msg_grid_scroll_discount = 0;</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">/// Increment &quot;msg_scrolled&quot;.</a>
<a name="ln2394">static void inc_msg_scrolled(void)</a>
<a name="ln2395">{</a>
<a name="ln2396">  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {</a>
<a name="ln2397">    char *p = SOURCING_NAME;</a>
<a name="ln2398">    char *tofree = NULL;</a>
<a name="ln2399"> </a>
<a name="ln2400">    // v:scrollstart is empty, set it to the script/function name and line</a>
<a name="ln2401">    // number</a>
<a name="ln2402">    if (p == NULL) {</a>
<a name="ln2403">      p = _(&quot;Unknown&quot;);</a>
<a name="ln2404">    } else {</a>
<a name="ln2405">      size_t len = strlen(p) + 40;</a>
<a name="ln2406">      tofree = xmalloc(len);</a>
<a name="ln2407">      vim_snprintf(tofree, len, _(&quot;%s line %&quot; PRId64),</a>
<a name="ln2408">                   p, (int64_t)SOURCING_LNUM);</a>
<a name="ln2409">      p = tofree;</a>
<a name="ln2410">    }</a>
<a name="ln2411">    set_vim_var_string(VV_SCROLLSTART, p, -1);</a>
<a name="ln2412">    xfree(tofree);</a>
<a name="ln2413">  }</a>
<a name="ln2414">  msg_scrolled++;</a>
<a name="ln2415">  if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln2416">    must_redraw = UPD_VALID;</a>
<a name="ln2417">  }</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420">static msgchunk_T *last_msgchunk = NULL;  // last displayed text</a>
<a name="ln2421"> </a>
<a name="ln2422">typedef enum {</a>
<a name="ln2423">  SB_CLEAR_NONE = 0,</a>
<a name="ln2424">  SB_CLEAR_ALL,</a>
<a name="ln2425">  SB_CLEAR_CMDLINE_BUSY,</a>
<a name="ln2426">  SB_CLEAR_CMDLINE_DONE,</a>
<a name="ln2427">} sb_clear_T;</a>
<a name="ln2428"> </a>
<a name="ln2429">// When to clear text on next msg.</a>
<a name="ln2430">static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2431"> </a>
<a name="ln2432">/// Store part of a printed message for displaying when scrolling back.</a>
<a name="ln2433">///</a>
<a name="ln2434">/// @param sb_str  start of string</a>
<a name="ln2435">/// @param s  just after string</a>
<a name="ln2436">/// @param finish  line ends</a>
<a name="ln2437">static void store_sb_text(const char **sb_str, const char *s, int attr, int *sb_col, int finish)</a>
<a name="ln2438">{</a>
<a name="ln2439">  msgchunk_T *mp;</a>
<a name="ln2440"> </a>
<a name="ln2441">  if (do_clear_sb_text == SB_CLEAR_ALL</a>
<a name="ln2442">      || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE) {</a>
<a name="ln2443">    clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);</a>
<a name="ln2444">    msg_sb_eol();  // prevent messages from overlapping</a>
<a name="ln2445">    if (do_clear_sb_text == SB_CLEAR_CMDLINE_DONE &amp;&amp; s &gt; *sb_str &amp;&amp; **sb_str == '\n') {</a>
<a name="ln2446">      (*sb_str)++;</a>
<a name="ln2447">    }</a>
<a name="ln2448">    do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2449">  }</a>
<a name="ln2450"> </a>
<a name="ln2451">  if (s &gt; *sb_str) {</a>
<a name="ln2452">    mp = xmalloc(offsetof(msgchunk_T, sb_text) + (size_t)(s - *sb_str) + 1);</a>
<a name="ln2453">    mp-&gt;sb_eol = (char)finish;</a>
<a name="ln2454">    mp-&gt;sb_msg_col = *sb_col;</a>
<a name="ln2455">    mp-&gt;sb_attr = attr;</a>
<a name="ln2456">    memcpy(mp-&gt;sb_text, *sb_str, (size_t)(s - *sb_str));</a>
<a name="ln2457">    mp-&gt;sb_text[s - *sb_str] = NUL;</a>
<a name="ln2458"> </a>
<a name="ln2459">    if (last_msgchunk == NULL) {</a>
<a name="ln2460">      last_msgchunk = mp;</a>
<a name="ln2461">      mp-&gt;sb_prev = NULL;</a>
<a name="ln2462">    } else {</a>
<a name="ln2463">      mp-&gt;sb_prev = last_msgchunk;</a>
<a name="ln2464">      last_msgchunk-&gt;sb_next = mp;</a>
<a name="ln2465">      last_msgchunk = mp;</a>
<a name="ln2466">    }</a>
<a name="ln2467">    mp-&gt;sb_next = NULL;</a>
<a name="ln2468">  } else if (finish &amp;&amp; last_msgchunk != NULL) {</a>
<a name="ln2469">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2470">  }</a>
<a name="ln2471"> </a>
<a name="ln2472">  *sb_str = s;</a>
<a name="ln2473">  *sb_col = 0;</a>
<a name="ln2474">}</a>
<a name="ln2475"> </a>
<a name="ln2476">/// Finished showing messages, clear the scroll-back text on the next message.</a>
<a name="ln2477">void may_clear_sb_text(void)</a>
<a name="ln2478">{</a>
<a name="ln2479">  do_clear_sb_text = SB_CLEAR_ALL;</a>
<a name="ln2480">}</a>
<a name="ln2481"> </a>
<a name="ln2482">/// Starting to edit the command line: do not clear messages now.</a>
<a name="ln2483">void sb_text_start_cmdline(void)</a>
<a name="ln2484">{</a>
<a name="ln2485">  if (do_clear_sb_text == SB_CLEAR_CMDLINE_BUSY) {</a>
<a name="ln2486">    // Invoking command line recursively: the previous-level command line</a>
<a name="ln2487">    // doesn't need to be remembered as it will be redrawn when returning</a>
<a name="ln2488">    // to that level.</a>
<a name="ln2489">    sb_text_restart_cmdline();</a>
<a name="ln2490">  } else {</a>
<a name="ln2491">    msg_sb_eol();</a>
<a name="ln2492">    do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2493">  }</a>
<a name="ln2494">}</a>
<a name="ln2495"> </a>
<a name="ln2496">/// Redrawing the command line: clear the last unfinished line.</a>
<a name="ln2497">void sb_text_restart_cmdline(void)</a>
<a name="ln2498">{</a>
<a name="ln2499">  // Needed when returning from nested command line.</a>
<a name="ln2500">  do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2501"> </a>
<a name="ln2502">  if (last_msgchunk == NULL || last_msgchunk-&gt;sb_eol) {</a>
<a name="ln2503">    // No unfinished line: don't clear anything.</a>
<a name="ln2504">    return;</a>
<a name="ln2505">  }</a>
<a name="ln2506"> </a>
<a name="ln2507">  msgchunk_T *tofree = msg_sb_start(last_msgchunk);</a>
<a name="ln2508">  last_msgchunk = tofree-&gt;sb_prev;</a>
<a name="ln2509">  if (last_msgchunk != NULL) {</a>
<a name="ln2510">    last_msgchunk-&gt;sb_next = NULL;</a>
<a name="ln2511">  }</a>
<a name="ln2512">  while (tofree != NULL) {</a>
<a name="ln2513">    msgchunk_T *tofree_next = tofree-&gt;sb_next;</a>
<a name="ln2514">    xfree(tofree);</a>
<a name="ln2515">    tofree = tofree_next;</a>
<a name="ln2516">  }</a>
<a name="ln2517">}</a>
<a name="ln2518"> </a>
<a name="ln2519">/// Ending to edit the command line: clear old lines but the last one later.</a>
<a name="ln2520">void sb_text_end_cmdline(void)</a>
<a name="ln2521">{</a>
<a name="ln2522">  do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525">/// Clear any text remembered for scrolling back.</a>
<a name="ln2526">/// When &quot;all&quot; is false keep the last line.</a>
<a name="ln2527">/// Called when redrawing the screen.</a>
<a name="ln2528">void clear_sb_text(int all)</a>
<a name="ln2529">{</a>
<a name="ln2530">  msgchunk_T *mp;</a>
<a name="ln2531">  msgchunk_T **lastp;</a>
<a name="ln2532"> </a>
<a name="ln2533">  if (all) {</a>
<a name="ln2534">    lastp = &amp;last_msgchunk;</a>
<a name="ln2535">  } else {</a>
<a name="ln2536">    if (last_msgchunk == NULL) {</a>
<a name="ln2537">      return;</a>
<a name="ln2538">    }</a>
<a name="ln2539">    lastp = &amp;msg_sb_start(last_msgchunk)-&gt;sb_prev;</a>
<a name="ln2540">  }</a>
<a name="ln2541"> </a>
<a name="ln2542">  while (*lastp != NULL) {</a>
<a name="ln2543">    mp = (*lastp)-&gt;sb_prev;</a>
<a name="ln2544">    xfree(*lastp);</a>
<a name="ln2545">    *lastp = mp;</a>
<a name="ln2546">  }</a>
<a name="ln2547">}</a>
<a name="ln2548"> </a>
<a name="ln2549">/// &quot;g&lt;&quot; command.</a>
<a name="ln2550">void show_sb_text(void)</a>
<a name="ln2551">{</a>
<a name="ln2552">  msgchunk_T *mp;</a>
<a name="ln2553"> </a>
<a name="ln2554">  // Only show something if there is more than one line, otherwise it looks</a>
<a name="ln2555">  // weird, typing a command without output results in one line.</a>
<a name="ln2556">  mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2557">  if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2558">    vim_beep(BO_MESS);</a>
<a name="ln2559">  } else {</a>
<a name="ln2560">    do_more_prompt('G');</a>
<a name="ln2561">    wait_return(false);</a>
<a name="ln2562">  }</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">/// Move to the start of screen line in already displayed text.</a>
<a name="ln2566">static msgchunk_T *msg_sb_start(msgchunk_T *mps)</a>
<a name="ln2567">{</a>
<a name="ln2568">  msgchunk_T *mp = mps;</a>
<a name="ln2569"> </a>
<a name="ln2570">  while (mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL &amp;&amp; !mp-&gt;sb_prev-&gt;sb_eol) {</a>
<a name="ln2571">    mp = mp-&gt;sb_prev;</a>
<a name="ln2572">  }</a>
<a name="ln2573">  return mp;</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">/// Mark the last message chunk as finishing the line.</a>
<a name="ln2577">void msg_sb_eol(void)</a>
<a name="ln2578">{</a>
<a name="ln2579">  if (last_msgchunk != NULL) {</a>
<a name="ln2580">    last_msgchunk-&gt;sb_eol = true;</a>
<a name="ln2581">  }</a>
<a name="ln2582">}</a>
<a name="ln2583"> </a>
<a name="ln2584">/// Display a screen line from previously displayed text at row &quot;row&quot;.</a>
<a name="ln2585">///</a>
<a name="ln2586">/// @return  a pointer to the text for the next line (can be NULL).</a>
<a name="ln2587">static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp)</a>
<a name="ln2588">{</a>
<a name="ln2589">  msgchunk_T *mp = smp;</a>
<a name="ln2590"> </a>
<a name="ln2591">  while (true) {</a>
<a name="ln2592">    msg_row = row;</a>
<a name="ln2593">    msg_col = mp-&gt;sb_msg_col;</a>
<a name="ln2594">    char *p = mp-&gt;sb_text;</a>
<a name="ln2595">    msg_puts_display(p, -1, mp-&gt;sb_attr, true);</a>
<a name="ln2596">    if (mp-&gt;sb_eol || mp-&gt;sb_next == NULL) {</a>
<a name="ln2597">      break;</a>
<a name="ln2598">    }</a>
<a name="ln2599">    mp = mp-&gt;sb_next;</a>
<a name="ln2600">  }</a>
<a name="ln2601"> </a>
<a name="ln2602">  return mp-&gt;sb_next;</a>
<a name="ln2603">}</a>
<a name="ln2604"> </a>
<a name="ln2605">/// @return  true when messages should be printed to stdout/stderr:</a>
<a name="ln2606">///          - &quot;batch mode&quot; (&quot;silent mode&quot;, -es/-Es)</a>
<a name="ln2607">///          - no UI and not embedded</a>
<a name="ln2608">int msg_use_printf(void)</a>
<a name="ln2609">{</a>
<a name="ln2610">  return !embedded_mode &amp;&amp; !ui_active();</a>
<a name="ln2611">}</a>
<a name="ln2612"> </a>
<a name="ln2613">/// Print a message when there is no valid screen.</a>
<a name="ln2614">static void msg_puts_printf(const char *str, const ptrdiff_t maxlen)</a>
<a name="ln2615">{</a>
<a name="ln2616">  const char *s = str;</a>
<a name="ln2617">  char buf[7];</a>
<a name="ln2618">  char *p;</a>
<a name="ln2619"> </a>
<a name="ln2620">  if (on_print.type != kCallbackNone) {</a>
<a name="ln2621">    typval_T argv[1];</a>
<a name="ln2622">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2623">    argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln2624">    argv[0].vval.v_string = (char *)str;</a>
<a name="ln2625">    typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln2626">    callback_call(&amp;on_print, 1, argv, &amp;rettv);</a>
<a name="ln2627">    tv_clear(&amp;rettv);</a>
<a name="ln2628">    return;</a>
<a name="ln2629">  }</a>
<a name="ln2630"> </a>
<a name="ln2631">  while ((maxlen &lt; 0 || s - str &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2632">    int len = utf_ptr2len(s);</a>
<a name="ln2633">    if (!(silent_mode &amp;&amp; p_verbose == 0)) {</a>
<a name="ln2634">      // NL --&gt; CR NL translation (for Unix, not for &quot;--version&quot;)</a>
<a name="ln2635">      p = &amp;buf[0];</a>
<a name="ln2636">      if (*s == '\n' &amp;&amp; !info_message) {</a>
<a name="ln2637">        *p++ = '\r';</a>
<a name="ln2638">      }</a>
<a name="ln2639">      memcpy(p, s, (size_t)len);</a>
<a name="ln2640">      *(p + len) = '\0';</a>
<a name="ln2641">      if (info_message) {</a>
<a name="ln2642">        os_msg(buf);</a>
<a name="ln2643">      } else {</a>
<a name="ln2644">        os_errmsg(buf);</a>
<a name="ln2645">      }</a>
<a name="ln2646">    }</a>
<a name="ln2647"> </a>
<a name="ln2648">    int cw = utf_char2cells(utf_ptr2char(s));</a>
<a name="ln2649">    // primitive way to compute the current column</a>
<a name="ln2650">    if (cmdmsg_rl) {</a>
<a name="ln2651">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2652">        msg_col = Columns - 1;</a>
<a name="ln2653">      } else {</a>
<a name="ln2654">        msg_col -= cw;</a>
<a name="ln2655">      }</a>
<a name="ln2656">    } else {</a>
<a name="ln2657">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2658">        msg_col = 0;</a>
<a name="ln2659">      } else {</a>
<a name="ln2660">        msg_col += cw;</a>
<a name="ln2661">      }</a>
<a name="ln2662">    }</a>
<a name="ln2663">    s += len;</a>
<a name="ln2664">  }</a>
<a name="ln2665">  msg_didout = true;  // assume that line is not empty</a>
<a name="ln2666">}</a>
<a name="ln2667"> </a>
<a name="ln2668">/// Show the more-prompt and handle the user response.</a>
<a name="ln2669">/// This takes care of scrolling back and displaying previously displayed text.</a>
<a name="ln2670">/// When at hit-enter prompt &quot;typed_char&quot; is the already typed character,</a>
<a name="ln2671">/// otherwise it's NUL.</a>
<a name="ln2672">///</a>
<a name="ln2673">/// @return  true when jumping ahead to &quot;confirm_msg_tail&quot;.</a>
<a name="ln2674">static int do_more_prompt(int typed_char)</a>
<a name="ln2675">{</a>
<a name="ln2676">  static bool entered = false;</a>
<a name="ln2677">  int used_typed_char = typed_char;</a>
<a name="ln2678">  int oldState = State;</a>
<a name="ln2679">  int c;</a>
<a name="ln2680">  int retval = false;</a>
<a name="ln2681">  bool to_redraw = false;</a>
<a name="ln2682">  msgchunk_T *mp_last = NULL;</a>
<a name="ln2683">  msgchunk_T *mp;</a>
<a name="ln2684">  int i;</a>
<a name="ln2685"> </a>
<a name="ln2686">  // If headless mode is enabled and no input is required, this variable</a>
<a name="ln2687">  // will be true. However If server mode is enabled, the message &quot;--more--&quot;</a>
<a name="ln2688">  // should be displayed.</a>
<a name="ln2689">  bool no_need_more = headless_mode &amp;&amp; !embedded_mode;</a>
<a name="ln2690"> </a>
<a name="ln2691">  // We get called recursively when a timer callback outputs a message. In</a>
<a name="ln2692">  // that case don't show another prompt. Also when at the hit-Enter prompt</a>
<a name="ln2693">  // and nothing was typed.</a>
<a name="ln2694">  if (no_need_more || entered || (State == MODE_HITRETURN &amp;&amp; typed_char == 0)) {</a>
<a name="ln2695">    return false;</a>
<a name="ln2696">  }</a>
<a name="ln2697">  entered = true;</a>
<a name="ln2698"> </a>
<a name="ln2699">  if (typed_char == 'G') {</a>
<a name="ln2700">    // &quot;g&lt;&quot;: Find first line on the last page.</a>
<a name="ln2701">    mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2702">    for (i = 0; i &lt; Rows - 2 &amp;&amp; mp_last != NULL</a>
<a name="ln2703">         &amp;&amp; mp_last-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2704">      mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2705">    }</a>
<a name="ln2706">  }</a>
<a name="ln2707"> </a>
<a name="ln2708">  State = MODE_ASKMORE;</a>
<a name="ln2709">  setmouse();</a>
<a name="ln2710">  if (typed_char == NUL) {</a>
<a name="ln2711">    msg_moremsg(false);</a>
<a name="ln2712">  }</a>
<a name="ln2713">  while (true) {</a>
<a name="ln2714">    // Get a typed character directly from the user.</a>
<a name="ln2715">    if (used_typed_char != NUL) {</a>
<a name="ln2716">      c = used_typed_char;              // was typed at hit-enter prompt</a>
<a name="ln2717">      used_typed_char = NUL;</a>
<a name="ln2718">    } else {</a>
<a name="ln2719">      c = get_keystroke(resize_events);</a>
<a name="ln2720">    }</a>
<a name="ln2721"> </a>
<a name="ln2722">    int toscroll = 0;</a>
<a name="ln2723">    switch (c) {</a>
<a name="ln2724">    case BS:                    // scroll one line back</a>
<a name="ln2725">    case K_BS:</a>
<a name="ln2726">    case 'k':</a>
<a name="ln2727">    case K_UP:</a>
<a name="ln2728">      toscroll = -1;</a>
<a name="ln2729">      break;</a>
<a name="ln2730"> </a>
<a name="ln2731">    case CAR:                   // one extra line</a>
<a name="ln2732">    case NL:</a>
<a name="ln2733">    case 'j':</a>
<a name="ln2734">    case K_DOWN:</a>
<a name="ln2735">      toscroll = 1;</a>
<a name="ln2736">      break;</a>
<a name="ln2737"> </a>
<a name="ln2738">    case 'u':                   // Up half a page</a>
<a name="ln2739">      toscroll = -(Rows / 2);</a>
<a name="ln2740">      break;</a>
<a name="ln2741"> </a>
<a name="ln2742">    case 'd':                   // Down half a page</a>
<a name="ln2743">      toscroll = Rows / 2;</a>
<a name="ln2744">      break;</a>
<a name="ln2745"> </a>
<a name="ln2746">    case 'b':                   // one page back</a>
<a name="ln2747">    case K_PAGEUP:</a>
<a name="ln2748">      toscroll = -(Rows - 1);</a>
<a name="ln2749">      break;</a>
<a name="ln2750"> </a>
<a name="ln2751">    case ' ':                   // one extra page</a>
<a name="ln2752">    case 'f':</a>
<a name="ln2753">    case K_PAGEDOWN:</a>
<a name="ln2754">    case K_LEFTMOUSE:</a>
<a name="ln2755">      toscroll = Rows - 1;</a>
<a name="ln2756">      break;</a>
<a name="ln2757"> </a>
<a name="ln2758">    case 'g':                   // all the way back to the start</a>
<a name="ln2759">      toscroll = -999999;</a>
<a name="ln2760">      break;</a>
<a name="ln2761"> </a>
<a name="ln2762">    case 'G':                   // all the way to the end</a>
<a name="ln2763">      toscroll = 999999;</a>
<a name="ln2764">      lines_left = 999999;</a>
<a name="ln2765">      break;</a>
<a name="ln2766"> </a>
<a name="ln2767">    case ':':                   // start new command line</a>
<a name="ln2768">      if (!confirm_msg_used) {</a>
<a name="ln2769">        // Since got_int is set all typeahead will be flushed, but we</a>
<a name="ln2770">        // want to keep this ':', remember that in a special way.</a>
<a name="ln2771">        typeahead_noflush(':');</a>
<a name="ln2772">        cmdline_row = Rows - 1;                 // put ':' on this line</a>
<a name="ln2773">        skip_redraw = true;                     // skip redraw once</a>
<a name="ln2774">        need_wait_return = false;               // don't wait in main()</a>
<a name="ln2775">      }</a>
<a name="ln2776">      FALLTHROUGH;</a>
<a name="ln2777">    case 'q':                   // quit</a>
<a name="ln2778">    case Ctrl_C:</a>
<a name="ln2779">    case ESC:</a>
<a name="ln2780">      if (confirm_msg_used) {</a>
<a name="ln2781">        // Jump to the choices of the dialog.</a>
<a name="ln2782">        retval = true;</a>
<a name="ln2783">      } else {</a>
<a name="ln2784">        got_int = true;</a>
<a name="ln2785">        quit_more = true;</a>
<a name="ln2786">      }</a>
<a name="ln2787">      // When there is some more output (wrapping line) display that</a>
<a name="ln2788">      // without another prompt.</a>
<a name="ln2789">      lines_left = Rows - 1;</a>
<a name="ln2790">      break;</a>
<a name="ln2791"> </a>
<a name="ln2792">    case K_EVENT:</a>
<a name="ln2793">      // only resize_events are processed here</a>
<a name="ln2794">      // Attempt to redraw the screen. sb_text doesn't support reflow</a>
<a name="ln2795">      // so this only really works for vertical resize.</a>
<a name="ln2796">      multiqueue_process_events(resize_events);</a>
<a name="ln2797">      to_redraw = true;</a>
<a name="ln2798">      break;</a>
<a name="ln2799"> </a>
<a name="ln2800">    default:                    // no valid response</a>
<a name="ln2801">      msg_moremsg(true);</a>
<a name="ln2802">      continue;</a>
<a name="ln2803">    }</a>
<a name="ln2804"> </a>
<a name="ln2805">    // code assumes we only do one at a time</a>
<a name="ln2806">    assert((toscroll == 0) || !to_redraw);</a>
<a name="ln2807"> </a>
<a name="ln2808">    if (toscroll != 0 || to_redraw) {</a>
<a name="ln2809">      if (toscroll &lt; 0 || to_redraw) {</a>
<a name="ln2810">        // go to start of last line</a>
<a name="ln2811">        if (mp_last == NULL) {</a>
<a name="ln2812">          mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2813">        } else if (mp_last-&gt;sb_prev != NULL) {</a>
<a name="ln2814">          mp = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2815">        } else {</a>
<a name="ln2816">          mp = NULL;</a>
<a name="ln2817">        }</a>
<a name="ln2818"> </a>
<a name="ln2819">        // go to start of line at top of the screen</a>
<a name="ln2820">        for (i = 0; i &lt; Rows - 2 &amp;&amp; mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL; i++) {</a>
<a name="ln2821">          mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2822">        }</a>
<a name="ln2823"> </a>
<a name="ln2824">        if (mp != NULL &amp;&amp; (mp-&gt;sb_prev != NULL || to_redraw)) {</a>
<a name="ln2825">          // Find line to be displayed at top</a>
<a name="ln2826">          for (i = 0; i &gt; toscroll; i--) {</a>
<a name="ln2827">            if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2828">              break;</a>
<a name="ln2829">            }</a>
<a name="ln2830">            mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2831">            if (mp_last == NULL) {</a>
<a name="ln2832">              mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2833">            } else {</a>
<a name="ln2834">              mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2835">            }</a>
<a name="ln2836">          }</a>
<a name="ln2837"> </a>
<a name="ln2838">          if (toscroll == -1 &amp;&amp; !to_redraw) {</a>
<a name="ln2839">            grid_ins_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2840">            grid_fill(&amp;msg_grid_adj, 0, 1, 0, Columns, ' ', ' ',</a>
<a name="ln2841">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2842">            // display line at top</a>
<a name="ln2843">            (void)disp_sb_line(0, mp);</a>
<a name="ln2844">          } else {</a>
<a name="ln2845">            // redisplay all lines</a>
<a name="ln2846">            // TODO(bfredl): this case is not optimized (though only concerns</a>
<a name="ln2847">            // event fragmentization, not unnecessary scroll events).</a>
<a name="ln2848">            grid_fill(&amp;msg_grid_adj, 0, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2849">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2850">            for (i = 0; mp != NULL &amp;&amp; i &lt; Rows - 1; i++) {</a>
<a name="ln2851">              mp = disp_sb_line(i, mp);</a>
<a name="ln2852">              msg_scrolled++;</a>
<a name="ln2853">            }</a>
<a name="ln2854">            to_redraw = false;</a>
<a name="ln2855">          }</a>
<a name="ln2856">          toscroll = 0;</a>
<a name="ln2857">        }</a>
<a name="ln2858">      } else {</a>
<a name="ln2859">        // First display any text that we scrolled back.</a>
<a name="ln2860">        // if p_ch=0 we need to allocate a line for &quot;press enter&quot; messages!</a>
<a name="ln2861">        if (cmdline_row &gt;= Rows &amp;&amp; !ui_has(kUIMessages)) {</a>
<a name="ln2862">          msg_scroll_up(true, false);</a>
<a name="ln2863">          msg_scrolled++;</a>
<a name="ln2864">        }</a>
<a name="ln2865">        while (toscroll &gt; 0 &amp;&amp; mp_last != NULL) {</a>
<a name="ln2866">          if (msg_do_throttle() &amp;&amp; !msg_grid.throttled) {</a>
<a name="ln2867">            // Tricky: we redraw at one line higher than usual. Therefore</a>
<a name="ln2868">            // the non-flushed area is one line larger.</a>
<a name="ln2869">            msg_scrolled_at_flush--;</a>
<a name="ln2870">            msg_grid_scroll_discount++;</a>
<a name="ln2871">          }</a>
<a name="ln2872">          // scroll up, display line at bottom</a>
<a name="ln2873">          msg_scroll_up(true, false);</a>
<a name="ln2874">          inc_msg_scrolled();</a>
<a name="ln2875">          grid_fill(&amp;msg_grid_adj, Rows - 2, Rows - 1, 0, Columns, ' ', ' ',</a>
<a name="ln2876">                    HL_ATTR(HLF_MSG));</a>
<a name="ln2877">          mp_last = disp_sb_line(Rows - 2, mp_last);</a>
<a name="ln2878">          toscroll--;</a>
<a name="ln2879">        }</a>
<a name="ln2880">      }</a>
<a name="ln2881"> </a>
<a name="ln2882">      if (toscroll &lt;= 0) {</a>
<a name="ln2883">        // displayed the requested text, more prompt again</a>
<a name="ln2884">        grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2885">                  HL_ATTR(HLF_MSG));</a>
<a name="ln2886">        msg_moremsg(false);</a>
<a name="ln2887">        continue;</a>
<a name="ln2888">      }</a>
<a name="ln2889"> </a>
<a name="ln2890">      // display more text, return to caller</a>
<a name="ln2891">      lines_left = toscroll;</a>
<a name="ln2892">    }</a>
<a name="ln2893"> </a>
<a name="ln2894">    break;</a>
<a name="ln2895">  }</a>
<a name="ln2896"> </a>
<a name="ln2897">  // clear the --more-- message</a>
<a name="ln2898">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2899">            HL_ATTR(HLF_MSG));</a>
<a name="ln2900">  redraw_cmdline = true;</a>
<a name="ln2901">  clear_cmdline = false;</a>
<a name="ln2902">  mode_displayed = false;</a>
<a name="ln2903"> </a>
<a name="ln2904">  State = oldState;</a>
<a name="ln2905">  setmouse();</a>
<a name="ln2906">  if (quit_more) {</a>
<a name="ln2907">    msg_row = Rows - 1;</a>
<a name="ln2908">    msg_col = 0;</a>
<a name="ln2909">  } else if (cmdmsg_rl) {</a>
<a name="ln2910">    msg_col = Columns - 1;</a>
<a name="ln2911">  }</a>
<a name="ln2912"> </a>
<a name="ln2913">  entered = false;</a>
<a name="ln2914">  return retval;</a>
<a name="ln2915">}</a>
<a name="ln2916"> </a>
<a name="ln2917">#if defined(MSWIN)</a>
<a name="ln2918">/// Headless (no UI) error message handler.</a>
<a name="ln2919">static void do_msg(const char *str, bool errmsg)</a>
<a name="ln2920">{</a>
<a name="ln2921">  static bool did_err = false;</a>
<a name="ln2922">  assert(str != NULL);</a>
<a name="ln2923">  wchar_t *utf16str;</a>
<a name="ln2924">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln2925">  if (r != 0 &amp;&amp; !did_err) {</a>
<a name="ln2926">    did_err = true;</a>
<a name="ln2927">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2928">    ELOG(&quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2929">  } else if (r == 0) {</a>
<a name="ln2930">    if (errmsg) {</a>
<a name="ln2931">      fwprintf(stderr, L&quot;%ls&quot;, utf16str);</a>
<a name="ln2932">    } else {</a>
<a name="ln2933">      wprintf(L&quot;%ls&quot;, utf16str);</a>
<a name="ln2934">    }</a>
<a name="ln2935">    xfree(utf16str);</a>
<a name="ln2936">  }</a>
<a name="ln2937">}</a>
<a name="ln2938"> </a>
<a name="ln2939">void os_errmsg(const char *str)</a>
<a name="ln2940">{</a>
<a name="ln2941">  do_msg(str, true);</a>
<a name="ln2942">}</a>
<a name="ln2943"> </a>
<a name="ln2944">/// Headless (no UI) message handler.</a>
<a name="ln2945">void os_msg(const char *str)</a>
<a name="ln2946">{</a>
<a name="ln2947">  do_msg(str, false);</a>
<a name="ln2948">}</a>
<a name="ln2949">#endif  // MSWIN</a>
<a name="ln2950"> </a>
<a name="ln2951">void msg_moremsg(int full)</a>
<a name="ln2952">{</a>
<a name="ln2953">  int attr;</a>
<a name="ln2954">  char *s = _(&quot;-- More --&quot;);</a>
<a name="ln2955"> </a>
<a name="ln2956">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), HL_ATTR(HLF_M));</a>
<a name="ln2957">  grid_puts(&amp;msg_grid_adj, s, -1, Rows - 1, 0, attr);</a>
<a name="ln2958">  if (full) {</a>
<a name="ln2959">    grid_puts(&amp;msg_grid_adj, _(&quot; SPACE/d/j: screen/page/line down, b/u/k: up, q: quit &quot;), -1,</a>
<a name="ln2960">              Rows - 1, vim_strsize(s), attr);</a>
<a name="ln2961">  }</a>
<a name="ln2962">}</a>
<a name="ln2963"> </a>
<a name="ln2964">/// Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,</a>
<a name="ln2965">/// MODE_CONFIRM or exmode_active.</a>
<a name="ln2966">void repeat_message(void)</a>
<a name="ln2967">{</a>
<a name="ln2968">  if (State == MODE_ASKMORE) {</a>
<a name="ln2969">    msg_moremsg(true);          // display --more-- message again</a>
<a name="ln2970">    msg_row = Rows - 1;</a>
<a name="ln2971">  } else if (State == MODE_CONFIRM) {</a>
<a name="ln2972">    display_confirm_msg();      // display &quot;:confirm&quot; message again</a>
<a name="ln2973">    msg_row = Rows - 1;</a>
<a name="ln2974">  } else if (State == MODE_EXTERNCMD) {</a>
<a name="ln2975">    ui_cursor_goto(msg_row, msg_col);     // put cursor back</a>
<a name="ln2976">  } else if (State == MODE_HITRETURN || State == MODE_SETWSIZE) {</a>
<a name="ln2977">    if (msg_row == Rows - 1) {</a>
<a name="ln2978">      // Avoid drawing the &quot;hit-enter&quot; prompt below the previous one,</a>
<a name="ln2979">      // overwrite it.  Esp. useful when regaining focus and a</a>
<a name="ln2980">      // FocusGained autocmd exists but didn't draw anything.</a>
<a name="ln2981">      msg_didout = false;</a>
<a name="ln2982">      msg_col = 0;</a>
<a name="ln2983">      msg_clr_eos();</a>
<a name="ln2984">    }</a>
<a name="ln2985">    hit_return_msg();</a>
<a name="ln2986">    msg_row = Rows - 1;</a>
<a name="ln2987">  }</a>
<a name="ln2988">}</a>
<a name="ln2989"> </a>
<a name="ln2990">/// Clear from current message position to end of screen.</a>
<a name="ln2991">/// Skip this when &quot;:silent&quot; was used, no need to clear for redirection.</a>
<a name="ln2992">void msg_clr_eos(void)</a>
<a name="ln2993">{</a>
<a name="ln2994">  if (msg_silent == 0) {</a>
<a name="ln2995">    msg_clr_eos_force();</a>
<a name="ln2996">  }</a>
<a name="ln2997">}</a>
<a name="ln2998"> </a>
<a name="ln2999">/// Clear from current message position to end of screen.</a>
<a name="ln3000">/// Note: msg_col is not updated, so we remember the end of the message</a>
<a name="ln3001">/// for msg_check().</a>
<a name="ln3002">void msg_clr_eos_force(void)</a>
<a name="ln3003">{</a>
<a name="ln3004">  if (ui_has(kUIMessages)) {</a>
<a name="ln3005">    return;</a>
<a name="ln3006">  }</a>
<a name="ln3007">  int msg_startcol = (cmdmsg_rl) ? 0 : msg_col;</a>
<a name="ln3008">  int msg_endcol = (cmdmsg_rl) ? msg_col + 1 : Columns;</a>
<a name="ln3009"> </a>
<a name="ln3010">  if (msg_grid.chars &amp;&amp; msg_row &lt; msg_grid_pos) {</a>
<a name="ln3011">    // TODO(bfredl): ugly, this state should already been validated at this</a>
<a name="ln3012">    // point. But msg_clr_eos() is called in a lot of places.</a>
<a name="ln3013">    msg_row = msg_grid_pos;</a>
<a name="ln3014">  }</a>
<a name="ln3015"> </a>
<a name="ln3016">  grid_fill(&amp;msg_grid_adj, msg_row, msg_row + 1, msg_startcol, msg_endcol,</a>
<a name="ln3017">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3018">  grid_fill(&amp;msg_grid_adj, msg_row + 1, Rows, 0, Columns,</a>
<a name="ln3019">            ' ', ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3020"> </a>
<a name="ln3021">  redraw_cmdline = true;  // overwritten the command line</a>
<a name="ln3022">  if (msg_row &lt; Rows - 1 || msg_col == (cmdmsg_rl ? Columns : 0)) {</a>
<a name="ln3023">    clear_cmdline = false;  // command line has been cleared</a>
<a name="ln3024">    mode_displayed = false;  // mode cleared or overwritten</a>
<a name="ln3025">  }</a>
<a name="ln3026">}</a>
<a name="ln3027"> </a>
<a name="ln3028">/// Clear the command line.</a>
<a name="ln3029">void msg_clr_cmdline(void)</a>
<a name="ln3030">{</a>
<a name="ln3031">  msg_row = cmdline_row;</a>
<a name="ln3032">  msg_col = 0;</a>
<a name="ln3033">  msg_clr_eos_force();</a>
<a name="ln3034">}</a>
<a name="ln3035"> </a>
<a name="ln3036">/// end putting a message on the screen</a>
<a name="ln3037">/// call wait_return() if the message does not fit in the available space</a>
<a name="ln3038">///</a>
<a name="ln3039">/// @return  true if wait_return() not called.</a>
<a name="ln3040">int msg_end(void)</a>
<a name="ln3041">{</a>
<a name="ln3042">  // If the string is larger than the window,</a>
<a name="ln3043">  // or the ruler option is set and we run into it,</a>
<a name="ln3044">  // we have to redraw the window.</a>
<a name="ln3045">  // Do not do this if we are abandoning the file or editing the command line.</a>
<a name="ln3046">  if (!exiting &amp;&amp; need_wait_return &amp;&amp; !(State &amp; MODE_CMDLINE)) {</a>
<a name="ln3047">    wait_return(false);</a>
<a name="ln3048">    return false;</a>
<a name="ln3049">  }</a>
<a name="ln3050"> </a>
<a name="ln3051">  // NOTE: ui_flush() used to be called here. This had to be removed, as it</a>
<a name="ln3052">  // inhibited substantial performance improvements. It is assumed that relevant</a>
<a name="ln3053">  // callers invoke ui_flush() before going into CPU busywork, or restricted</a>
<a name="ln3054">  // event processing after displaying a message to the user.</a>
<a name="ln3055">  msg_ext_ui_flush();</a>
<a name="ln3056">  return true;</a>
<a name="ln3057">}</a>
<a name="ln3058"> </a>
<a name="ln3059">void msg_ext_ui_flush(void)</a>
<a name="ln3060">{</a>
<a name="ln3061">  if (!ui_has(kUIMessages)) {</a>
<a name="ln3062">    msg_ext_kind = NULL;</a>
<a name="ln3063">    return;</a>
<a name="ln3064">  }</a>
<a name="ln3065"> </a>
<a name="ln3066">  msg_ext_emit_chunk();</a>
<a name="ln3067">  if (msg_ext_chunks.size &gt; 0) {</a>
<a name="ln3068">    ui_call_msg_show(cstr_as_string((char *)msg_ext_kind),</a>
<a name="ln3069">                     msg_ext_chunks, msg_ext_overwrite);</a>
<a name="ln3070">    if (!msg_ext_overwrite) {</a>
<a name="ln3071">      msg_ext_visible++;</a>
<a name="ln3072">    }</a>
<a name="ln3073">    msg_ext_kind = NULL;</a>
<a name="ln3074">    api_free_array(msg_ext_chunks);</a>
<a name="ln3075">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3076">    msg_ext_cur_len = 0;</a>
<a name="ln3077">    msg_ext_overwrite = false;</a>
<a name="ln3078">  }</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081">void msg_ext_flush_showmode(void)</a>
<a name="ln3082">{</a>
<a name="ln3083">  // Showmode messages doesn't interrupt normal message flow, so we use</a>
<a name="ln3084">  // separate event. Still reuse the same chunking logic, for simplicity.</a>
<a name="ln3085">  if (ui_has(kUIMessages)) {</a>
<a name="ln3086">    msg_ext_emit_chunk();</a>
<a name="ln3087">    ui_call_msg_showmode(msg_ext_chunks);</a>
<a name="ln3088">    api_free_array(msg_ext_chunks);</a>
<a name="ln3089">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3090">    msg_ext_cur_len = 0;</a>
<a name="ln3091">  }</a>
<a name="ln3092">}</a>
<a name="ln3093"> </a>
<a name="ln3094">void msg_ext_clear(bool force)</a>
<a name="ln3095">{</a>
<a name="ln3096">  if (msg_ext_visible &amp;&amp; (!msg_ext_keep_after_cmdline || force)) {</a>
<a name="ln3097">    ui_call_msg_clear();</a>
<a name="ln3098">    msg_ext_visible = 0;</a>
<a name="ln3099">    msg_ext_overwrite = false;  // nothing to overwrite</a>
<a name="ln3100">  }</a>
<a name="ln3101">  if (msg_ext_history_visible) {</a>
<a name="ln3102">    ui_call_msg_history_clear();</a>
<a name="ln3103">    msg_ext_history_visible = false;</a>
<a name="ln3104">  }</a>
<a name="ln3105"> </a>
<a name="ln3106">  // Only keep once.</a>
<a name="ln3107">  msg_ext_keep_after_cmdline = false;</a>
<a name="ln3108">}</a>
<a name="ln3109"> </a>
<a name="ln3110">void msg_ext_clear_later(void)</a>
<a name="ln3111">{</a>
<a name="ln3112">  if (msg_ext_is_visible()) {</a>
<a name="ln3113">    msg_ext_need_clear = true;</a>
<a name="ln3114">    if (must_redraw &lt; UPD_VALID) {</a>
<a name="ln3115">      must_redraw = UPD_VALID;</a>
<a name="ln3116">    }</a>
<a name="ln3117">  }</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120">void msg_ext_check_clear(void)</a>
<a name="ln3121">{</a>
<a name="ln3122">  // Redraw after cmdline or prompt is expected to clear messages.</a>
<a name="ln3123">  if (msg_ext_need_clear) {</a>
<a name="ln3124">    msg_ext_clear(true);</a>
<a name="ln3125">    msg_ext_need_clear = false;</a>
<a name="ln3126">  }</a>
<a name="ln3127">}</a>
<a name="ln3128"> </a>
<a name="ln3129">bool msg_ext_is_visible(void)</a>
<a name="ln3130">{</a>
<a name="ln3131">  return ui_has(kUIMessages) &amp;&amp; msg_ext_visible &gt; 0;</a>
<a name="ln3132">}</a>
<a name="ln3133"> </a>
<a name="ln3134">/// If the written message runs into the shown command or ruler, we have to</a>
<a name="ln3135">/// wait for hit-return and redraw the window later.</a>
<a name="ln3136">void msg_check(void)</a>
<a name="ln3137">{</a>
<a name="ln3138">  if (ui_has(kUIMessages)) {</a>
<a name="ln3139">    return;</a>
<a name="ln3140">  }</a>
<a name="ln3141">  if (msg_row == Rows - 1 &amp;&amp; msg_col &gt;= sc_col) {</a>
<a name="ln3142">    need_wait_return = true;</a>
<a name="ln3143">    redraw_cmdline = true;</a>
<a name="ln3144">  }</a>
<a name="ln3145">}</a>
<a name="ln3146"> </a>
<a name="ln3147">/// May write a string to the redirection file.</a>
<a name="ln3148">///</a>
<a name="ln3149">/// @param maxlen  if -1, write the whole string, otherwise up to &quot;maxlen&quot; bytes.</a>
<a name="ln3150">static void redir_write(const char *const str, const ptrdiff_t maxlen)</a>
<a name="ln3151">{</a>
<a name="ln3152">  const char *s = str;</a>
<a name="ln3153">  static int cur_col = 0;</a>
<a name="ln3154"> </a>
<a name="ln3155">  if (maxlen == 0) {</a>
<a name="ln3156">    return;</a>
<a name="ln3157">  }</a>
<a name="ln3158"> </a>
<a name="ln3159">  // Don't do anything for displaying prompts and the like.</a>
<a name="ln3160">  if (redir_off) {</a>
<a name="ln3161">    return;</a>
<a name="ln3162">  }</a>
<a name="ln3163"> </a>
<a name="ln3164">  // If 'verbosefile' is set prepare for writing in that file.</a>
<a name="ln3165">  if (*p_vfile != NUL &amp;&amp; verbose_fd == NULL) {</a>
<a name="ln3166">    verbose_open();</a>
<a name="ln3167">  }</a>
<a name="ln3168"> </a>
<a name="ln3169">  if (redirecting()) {</a>
<a name="ln3170">    // If the string doesn't start with CR or NL, go to msg_col</a>
<a name="ln3171">    if (*s != '\n' &amp;&amp; *s != '\r') {</a>
<a name="ln3172">      while (cur_col &lt; msg_col) {</a>
<a name="ln3173">        if (capture_ga) {</a>
<a name="ln3174">          ga_concat_len(capture_ga, &quot; &quot;, 1);</a>
<a name="ln3175">        }</a>
<a name="ln3176">        if (redir_reg) {</a>
<a name="ln3177">          write_reg_contents(redir_reg, &quot; &quot;, 1, true);</a>
<a name="ln3178">        } else if (redir_vname) {</a>
<a name="ln3179">          var_redir_str(&quot; &quot;, -1);</a>
<a name="ln3180">        } else if (redir_fd != NULL) {</a>
<a name="ln3181">          fputs(&quot; &quot;, redir_fd);</a>
<a name="ln3182">        }</a>
<a name="ln3183">        if (verbose_fd != NULL) {</a>
<a name="ln3184">          fputs(&quot; &quot;, verbose_fd);</a>
<a name="ln3185">        }</a>
<a name="ln3186">        cur_col++;</a>
<a name="ln3187">      }</a>
<a name="ln3188">    }</a>
<a name="ln3189"> </a>
<a name="ln3190">    size_t len = maxlen == -1 ? strlen(s) : (size_t)maxlen;</a>
<a name="ln3191">    if (capture_ga) {</a>
<a name="ln3192">      ga_concat_len(capture_ga, str, len);</a>
<a name="ln3193">    }</a>
<a name="ln3194">    if (redir_reg) {</a>
<a name="ln3195">      write_reg_contents(redir_reg, s, (ssize_t)len, true);</a>
<a name="ln3196">    }</a>
<a name="ln3197">    if (redir_vname) {</a>
<a name="ln3198">      var_redir_str(s, (int)maxlen);</a>
<a name="ln3199">    }</a>
<a name="ln3200"> </a>
<a name="ln3201">    // Write and adjust the current column.</a>
<a name="ln3202">    while (*s != NUL</a>
<a name="ln3203">           &amp;&amp; (maxlen &lt; 0 || (int)(s - str) &lt; maxlen)) {</a>
<a name="ln3204">      if (!redir_reg &amp;&amp; !redir_vname &amp;&amp; !capture_ga) {</a>
<a name="ln3205">        if (redir_fd != NULL) {</a>
<a name="ln3206">          putc(*s, redir_fd);</a>
<a name="ln3207">        }</a>
<a name="ln3208">      }</a>
<a name="ln3209">      if (verbose_fd != NULL) {</a>
<a name="ln3210">        putc(*s, verbose_fd);</a>
<a name="ln3211">      }</a>
<a name="ln3212">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln3213">        cur_col = 0;</a>
<a name="ln3214">      } else if (*s == '\t') {</a>
<a name="ln3215">        cur_col += (8 - cur_col % 8);</a>
<a name="ln3216">      } else {</a>
<a name="ln3217">        cur_col++;</a>
<a name="ln3218">      }</a>
<a name="ln3219">      s++;</a>
<a name="ln3220">    }</a>
<a name="ln3221"> </a>
<a name="ln3222">    if (msg_silent != 0) {      // should update msg_col</a>
<a name="ln3223">      msg_col = cur_col;</a>
<a name="ln3224">    }</a>
<a name="ln3225">  }</a>
<a name="ln3226">}</a>
<a name="ln3227"> </a>
<a name="ln3228">int redirecting(void)</a>
<a name="ln3229">{</a>
<a name="ln3230">  return redir_fd != NULL || *p_vfile != NUL</a>
<a name="ln3231">         || redir_reg || redir_vname || capture_ga != NULL;</a>
<a name="ln3232">}</a>
<a name="ln3233"> </a>
<a name="ln3234">/// Before giving verbose message.</a>
<a name="ln3235">/// Must always be called paired with verbose_leave()!</a>
<a name="ln3236">void verbose_enter(void)</a>
<a name="ln3237">{</a>
<a name="ln3238">  if (*p_vfile != NUL) {</a>
<a name="ln3239">    msg_silent++;</a>
<a name="ln3240">  }</a>
<a name="ln3241">}</a>
<a name="ln3242"> </a>
<a name="ln3243">/// After giving verbose message.</a>
<a name="ln3244">/// Must always be called paired with verbose_enter()!</a>
<a name="ln3245">void verbose_leave(void)</a>
<a name="ln3246">{</a>
<a name="ln3247">  if (*p_vfile != NUL) {</a>
<a name="ln3248">    if (--msg_silent &lt; 0) {</a>
<a name="ln3249">      msg_silent = 0;</a>
<a name="ln3250">    }</a>
<a name="ln3251">  }</a>
<a name="ln3252">}</a>
<a name="ln3253"> </a>
<a name="ln3254">/// Like verbose_enter() and set msg_scroll when displaying the message.</a>
<a name="ln3255">void verbose_enter_scroll(void)</a>
<a name="ln3256">{</a>
<a name="ln3257">  if (*p_vfile != NUL) {</a>
<a name="ln3258">    msg_silent++;</a>
<a name="ln3259">  } else {</a>
<a name="ln3260">    // always scroll up, don't overwrite</a>
<a name="ln3261">    msg_scroll = true;</a>
<a name="ln3262">  }</a>
<a name="ln3263">}</a>
<a name="ln3264"> </a>
<a name="ln3265">/// Like verbose_leave() and set cmdline_row when displaying the message.</a>
<a name="ln3266">void verbose_leave_scroll(void)</a>
<a name="ln3267">{</a>
<a name="ln3268">  if (*p_vfile != NUL) {</a>
<a name="ln3269">    if (--msg_silent &lt; 0) {</a>
<a name="ln3270">      msg_silent = 0;</a>
<a name="ln3271">    }</a>
<a name="ln3272">  } else {</a>
<a name="ln3273">    cmdline_row = msg_row;</a>
<a name="ln3274">  }</a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">/// Called when 'verbosefile' is set: stop writing to the file.</a>
<a name="ln3278">void verbose_stop(void)</a>
<a name="ln3279">{</a>
<a name="ln3280">  if (verbose_fd != NULL) {</a>
<a name="ln3281">    fclose(verbose_fd);</a>
<a name="ln3282">    verbose_fd = NULL;</a>
<a name="ln3283">  }</a>
<a name="ln3284">  verbose_did_open = false;</a>
<a name="ln3285">}</a>
<a name="ln3286"> </a>
<a name="ln3287">/// Open the file 'verbosefile'.</a>
<a name="ln3288">///</a>
<a name="ln3289">/// @return  FAIL or OK.</a>
<a name="ln3290">int verbose_open(void)</a>
<a name="ln3291">{</a>
<a name="ln3292">  if (verbose_fd == NULL &amp;&amp; !verbose_did_open) {</a>
<a name="ln3293">    // Only give the error message once.</a>
<a name="ln3294">    verbose_did_open = true;</a>
<a name="ln3295"> </a>
<a name="ln3296">    verbose_fd = os_fopen(p_vfile, &quot;a&quot;);</a>
<a name="ln3297">    if (verbose_fd == NULL) {</a>
<a name="ln3298">      semsg(_(e_notopen), p_vfile);</a>
<a name="ln3299">      return FAIL;</a>
<a name="ln3300">    }</a>
<a name="ln3301">  }</a>
<a name="ln3302">  return OK;</a>
<a name="ln3303">}</a>
<a name="ln3304"> </a>
<a name="ln3305">/// Give a warning message (for searching).</a>
<a name="ln3306">/// Use 'w' highlighting and may repeat the message after redrawing</a>
<a name="ln3307">void give_warning(const char *message, bool hl)</a>
<a name="ln3308">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3309">{</a>
<a name="ln3310">  // Don't do this for &quot;:silent&quot;.</a>
<a name="ln3311">  if (msg_silent != 0) {</a>
<a name="ln3312">    return;</a>
<a name="ln3313">  }</a>
<a name="ln3314"> </a>
<a name="ln3315">  // Don't want a hit-enter prompt here.</a>
<a name="ln3316">  no_wait_return++;</a>
<a name="ln3317"> </a>
<a name="ln3318">  set_vim_var_string(VV_WARNINGMSG, message, -1);</a>
<a name="ln3319">  XFREE_CLEAR(keep_msg);</a>
<a name="ln3320">  if (hl) {</a>
<a name="ln3321">    keep_msg_attr = HL_ATTR(HLF_W);</a>
<a name="ln3322">  } else {</a>
<a name="ln3323">    keep_msg_attr = 0;</a>
<a name="ln3324">  }</a>
<a name="ln3325"> </a>
<a name="ln3326">  if (msg_ext_kind == NULL) {</a>
<a name="ln3327">    msg_ext_set_kind(&quot;wmsg&quot;);</a>
<a name="ln3328">  }</a>
<a name="ln3329"> </a>
<a name="ln3330">  if (msg(message, keep_msg_attr) &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln3331">    set_keep_msg(message, keep_msg_attr);</a>
<a name="ln3332">  }</a>
<a name="ln3333">  msg_didout = false;  // Overwrite this message.</a>
<a name="ln3334">  msg_nowait = true;   // Don't wait for this message.</a>
<a name="ln3335">  msg_col = 0;</a>
<a name="ln3336"> </a>
<a name="ln3337">  no_wait_return--;</a>
<a name="ln3338">}</a>
<a name="ln3339"> </a>
<a name="ln3340">void give_warning2(const char *const message, const char *const a1, bool hl)</a>
<a name="ln3341">{</a>
<a name="ln3342">  vim_snprintf(IObuff, IOSIZE, message, a1);</a>
<a name="ln3343">  give_warning(IObuff, hl);</a>
<a name="ln3344">}</a>
<a name="ln3345"> </a>
<a name="ln3346">/// Advance msg cursor to column &quot;col&quot;.</a>
<a name="ln3347">void msg_advance(int col)</a>
<a name="ln3348">{</a>
<a name="ln3349">  if (msg_silent != 0) {        // nothing to advance to</a>
<a name="ln3350">    msg_col = col;              // for redirection, may fill it up later</a>
<a name="ln3351">    return;</a>
<a name="ln3352">  }</a>
<a name="ln3353">  if (ui_has(kUIMessages)) {</a>
<a name="ln3354">    // TODO(bfredl): use byte count as a basic proxy.</a>
<a name="ln3355">    // later on we might add proper support for formatted messages.</a>
<a name="ln3356">    while (msg_ext_cur_len &lt; (size_t)col) {</a>
<a name="ln3357">      msg_putchar(' ');</a>
<a name="ln3358">    }</a>
<a name="ln3359">    return;</a>
<a name="ln3360">  }</a>
<a name="ln3361">  if (col &gt;= Columns) {         // not enough room</a>
<a name="ln3362">    col = Columns - 1;</a>
<a name="ln3363">  }</a>
<a name="ln3364">  if (cmdmsg_rl) {</a>
<a name="ln3365">    while (msg_col &gt; Columns - col) {</a>
<a name="ln3366">      msg_putchar(' ');</a>
<a name="ln3367">    }</a>
<a name="ln3368">  } else {</a>
<a name="ln3369">    while (msg_col &lt; col) {</a>
<a name="ln3370">      msg_putchar(' ');</a>
<a name="ln3371">    }</a>
<a name="ln3372">  }</a>
<a name="ln3373">}</a>
<a name="ln3374"> </a>
<a name="ln3375">/// Used for &quot;confirm()&quot; function, and the :confirm command prefix.</a>
<a name="ln3376">/// Versions which haven't got flexible dialogs yet, and console</a>
<a name="ln3377">/// versions, get this generic handler which uses the command line.</a>
<a name="ln3378">///</a>
<a name="ln3379">/// type  = one of:</a>
<a name="ln3380">///         VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC</a>
<a name="ln3381">/// title = title string (can be NULL for default)</a>
<a name="ln3382">/// (neither used in console dialogs at the moment)</a>
<a name="ln3383">///</a>
<a name="ln3384">/// Format of the &quot;buttons&quot; string:</a>
<a name="ln3385">/// &quot;Button1Name\nButton2Name\nButton3Name&quot;</a>
<a name="ln3386">/// The first button should normally be the default/accept</a>
<a name="ln3387">/// The second button should be the 'Cancel' button</a>
<a name="ln3388">/// Other buttons- use your imagination!</a>
<a name="ln3389">/// A '&amp;' in a button name becomes a shortcut, so each '&amp;' should be before a</a>
<a name="ln3390">/// different letter.</a>
<a name="ln3391">///</a>
<a name="ln3392">/// @param textfiel  IObuff for inputdialog(), NULL otherwise</a>
<a name="ln3393">/// @param ex_cmd  when true pressing : accepts default and starts Ex command</a>
<a name="ln3394">/// @returns 0 if cancelled, otherwise the nth button (1-indexed).</a>
<a name="ln3395">int do_dialog(int type, const char *title, const char *message, const char *buttons, int dfltbutton,</a>
<a name="ln3396">              const char *textfield, int ex_cmd)</a>
<a name="ln3397">{</a>
<a name="ln3398">  int retval = 0;</a>
<a name="ln3399">  char *hotkeys;</a>
<a name="ln3400">  int i;</a>
<a name="ln3401"> </a>
<a name="ln3402">  if (silent_mode      // No dialogs in silent mode (&quot;ex -s&quot;)</a>
<a name="ln3403">      || !ui_active()  // Without a UI Nvim waits for input forever.</a>
<a name="ln3404">      ) {</a>
<a name="ln3405">    return dfltbutton;  // return default option</a>
<a name="ln3406">  }</a>
<a name="ln3407"> </a>
<a name="ln3408">  int save_msg_silent = msg_silent;</a>
<a name="ln3409">  int oldState = State;</a>
<a name="ln3410"> </a>
<a name="ln3411">  msg_silent = 0;  // If dialog prompts for input, user needs to see it! #8788</a>
<a name="ln3412">  State = MODE_CONFIRM;</a>
<a name="ln3413">  setmouse();</a>
<a name="ln3414"> </a>
<a name="ln3415">  // Since we wait for a keypress, don't make the</a>
<a name="ln3416">  // user press RETURN as well afterwards.</a>
<a name="ln3417">  no_wait_return++;</a>
<a name="ln3418">  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);</a>
<a name="ln3419"> </a>
<a name="ln3420">  while (true) {</a>
<a name="ln3421">    // Get a typed character directly from the user.</a>
<a name="ln3422">    int c = get_keystroke(NULL);</a>
<a name="ln3423">    switch (c) {</a>
<a name="ln3424">    case CAR:                 // User accepts default option</a>
<a name="ln3425">    case NL:</a>
<a name="ln3426">      retval = dfltbutton;</a>
<a name="ln3427">      break;</a>
<a name="ln3428">    case Ctrl_C:              // User aborts/cancels</a>
<a name="ln3429">    case ESC:</a>
<a name="ln3430">      retval = 0;</a>
<a name="ln3431">      break;</a>
<a name="ln3432">    default:                  // Could be a hotkey?</a>
<a name="ln3433">      if (c &lt; 0) {            // special keys are ignored here</a>
<a name="ln3434">        continue;</a>
<a name="ln3435">      }</a>
<a name="ln3436">      if (c == ':' &amp;&amp; ex_cmd) {</a>
<a name="ln3437">        retval = dfltbutton;</a>
<a name="ln3438">        ins_char_typebuf(':', 0);</a>
<a name="ln3439">        break;</a>
<a name="ln3440">      }</a>
<a name="ln3441"> </a>
<a name="ln3442">      // Make the character lowercase, as chars in &quot;hotkeys&quot; are.</a>
<a name="ln3443">      c = mb_tolower(c);</a>
<a name="ln3444">      retval = 1;</a>
<a name="ln3445">      for (i = 0; hotkeys[i]; i++) {</a>
<a name="ln3446">        if (utf_ptr2char(hotkeys + i) == c) {</a>
<a name="ln3447">          break;</a>
<a name="ln3448">        }</a>
<a name="ln3449">        i += utfc_ptr2len(hotkeys + i) - 1;</a>
<a name="ln3450">        retval++;</a>
<a name="ln3451">      }</a>
<a name="ln3452">      if (hotkeys[i]) {</a>
<a name="ln3453">        break;</a>
<a name="ln3454">      }</a>
<a name="ln3455">      // No hotkey match, so keep waiting</a>
<a name="ln3456">      continue;</a>
<a name="ln3457">    }</a>
<a name="ln3458">    break;</a>
<a name="ln3459">  }</a>
<a name="ln3460"> </a>
<a name="ln3461">  xfree(hotkeys);</a>
<a name="ln3462"> </a>
<a name="ln3463">  msg_silent = save_msg_silent;</a>
<a name="ln3464">  State = oldState;</a>
<a name="ln3465">  setmouse();</a>
<a name="ln3466">  no_wait_return--;</a>
<a name="ln3467">  msg_end_prompt();</a>
<a name="ln3468"> </a>
<a name="ln3469">  return retval;</a>
<a name="ln3470">}</a>
<a name="ln3471"> </a>
<a name="ln3472">/// Copy one character from &quot;*from&quot; to &quot;*to&quot;, taking care of multi-byte</a>
<a name="ln3473">/// characters.  Return the length of the character in bytes.</a>
<a name="ln3474">///</a>
<a name="ln3475">/// @param lowercase  make character lower case</a>
<a name="ln3476">static int copy_char(const char *from, char *to, bool lowercase)</a>
<a name="ln3477">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3478">{</a>
<a name="ln3479">  if (lowercase) {</a>
<a name="ln3480">    int c = mb_tolower(utf_ptr2char(from));</a>
<a name="ln3481">    return utf_char2bytes(c, to);</a>
<a name="ln3482">  }</a>
<a name="ln3483">  int len = utfc_ptr2len(from);</a>
<a name="ln3484">  memmove(to, from, (size_t)len);</a>
<a name="ln3485">  return len;</a>
<a name="ln3486">}</a>
<a name="ln3487"> </a>
<a name="ln3488">#define HAS_HOTKEY_LEN 30</a>
<a name="ln3489">#define HOTK_LEN MB_MAXBYTES</a>
<a name="ln3490"> </a>
<a name="ln3491">/// Allocates memory for dialog string &amp; for storing hotkeys</a>
<a name="ln3492">///</a>
<a name="ln3493">/// Finds the size of memory required for the confirm_msg &amp; for storing hotkeys</a>
<a name="ln3494">/// and then allocates the memory for them.</a>
<a name="ln3495">/// has_hotkey array is also filled-up.</a>
<a name="ln3496">///</a>
<a name="ln3497">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3498">/// @param buttons String containing button names</a>
<a name="ln3499">/// @param[out] has_hotkey An element in this array is set to true if</a>
<a name="ln3500">///                        corresponding button has a hotkey</a>
<a name="ln3501">///</a>
<a name="ln3502">/// @return Pointer to memory allocated for storing hotkeys</a>
<a name="ln3503">static char *console_dialog_alloc(const char *message, const char *buttons, bool has_hotkey[])</a>
<a name="ln3504">{</a>
<a name="ln3505">  int lenhotkey = HOTK_LEN;  // count first button</a>
<a name="ln3506">  has_hotkey[0] = false;</a>
<a name="ln3507"> </a>
<a name="ln3508">  // Compute the size of memory to allocate.</a>
<a name="ln3509">  int len = 0;</a>
<a name="ln3510">  int idx = 0;</a>
<a name="ln3511">  const char *r = buttons;</a>
<a name="ln3512">  while (*r) {</a>
<a name="ln3513">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3514">      len += 3;                         // '\n' -&gt; ', '; 'x' -&gt; '(x)'</a>
<a name="ln3515">      lenhotkey += HOTK_LEN;            // each button needs a hotkey</a>
<a name="ln3516">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3517">        has_hotkey[++idx] = false;</a>
<a name="ln3518">      }</a>
<a name="ln3519">    } else if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3520">      r++;</a>
<a name="ln3521">      len++;                    // '&amp;a' -&gt; '[a]'</a>
<a name="ln3522">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3523">        has_hotkey[idx] = true;</a>
<a name="ln3524">      }</a>
<a name="ln3525">    }</a>
<a name="ln3526"> </a>
<a name="ln3527">    // Advance to the next character</a>
<a name="ln3528">    MB_PTR_ADV(r);</a>
<a name="ln3529">  }</a>
<a name="ln3530"> </a>
<a name="ln3531">  len += (int)(strlen(message)</a>
<a name="ln3532">               + 2                          // for the NL's</a>
<a name="ln3533">               + strlen(buttons)</a>
<a name="ln3534">               + 3);                        // for the &quot;: &quot; and NUL</a>
<a name="ln3535">  lenhotkey++;                               // for the NUL</a>
<a name="ln3536"> </a>
<a name="ln3537">  // If no hotkey is specified, first char is used.</a>
<a name="ln3538">  if (!has_hotkey[0]) {</a>
<a name="ln3539">    len += 2;                                // &quot;x&quot; -&gt; &quot;[x]&quot;</a>
<a name="ln3540">  }</a>
<a name="ln3541"> </a>
<a name="ln3542">  // Now allocate space for the strings</a>
<a name="ln3543">  xfree(confirm_msg);</a>
<a name="ln3544">  confirm_msg = xmalloc((size_t)len);</a>
<a name="ln3545">  *confirm_msg = NUL;</a>
<a name="ln3546"> </a>
<a name="ln3547">  return xmalloc((size_t)lenhotkey);</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">/// Format the dialog string, and display it at the bottom of</a>
<a name="ln3551">/// the screen. Return a string of hotkey chars (if defined) for</a>
<a name="ln3552">/// each 'button'. If a button has no hotkey defined, the first character of</a>
<a name="ln3553">/// the button is used.</a>
<a name="ln3554">/// The hotkeys can be multi-byte characters, but without combining chars.</a>
<a name="ln3555">///</a>
<a name="ln3556">/// @return  an allocated string with hotkeys.</a>
<a name="ln3557">static char *msg_show_console_dialog(const char *message, const char *buttons, int dfltbutton)</a>
<a name="ln3558">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3559">{</a>
<a name="ln3560">  bool has_hotkey[HAS_HOTKEY_LEN] = { false };</a>
<a name="ln3561">  char *hotk = console_dialog_alloc(message, buttons, has_hotkey);</a>
<a name="ln3562"> </a>
<a name="ln3563">  copy_hotkeys_and_msg(message, buttons, dfltbutton, has_hotkey, hotk);</a>
<a name="ln3564"> </a>
<a name="ln3565">  display_confirm_msg();</a>
<a name="ln3566">  return hotk;</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569">/// Copies hotkeys &amp; dialog message into the memory allocated for it</a>
<a name="ln3570">///</a>
<a name="ln3571">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3572">/// @param buttons String containing button names</a>
<a name="ln3573">/// @param default_button_idx Number of default button</a>
<a name="ln3574">/// @param has_hotkey An element in this array is true if corresponding button</a>
<a name="ln3575">///                   has a hotkey</a>
<a name="ln3576">/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied</a>
<a name="ln3577">static void copy_hotkeys_and_msg(const char *message, const char *buttons, int default_button_idx,</a>
<a name="ln3578">                                 const bool has_hotkey[], char *hotkeys_ptr)</a>
<a name="ln3579">{</a>
<a name="ln3580">  *confirm_msg = '\n';</a>
<a name="ln3581">  STRCPY(confirm_msg + 1, message);</a>
<a name="ln3582"> </a>
<a name="ln3583">  char *msgp = confirm_msg + 1 + strlen(message);</a>
<a name="ln3584"> </a>
<a name="ln3585">  // Define first default hotkey. Keep the hotkey string NUL</a>
<a name="ln3586">  // terminated to avoid reading past the end.</a>
<a name="ln3587">  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3588"> </a>
<a name="ln3589">  // Remember where the choices start, displaying starts here when</a>
<a name="ln3590">  // &quot;hotkeys_ptr&quot; typed at the more prompt.</a>
<a name="ln3591">  confirm_msg_tail = msgp;</a>
<a name="ln3592">  *msgp++ = '\n';</a>
<a name="ln3593"> </a>
<a name="ln3594">  bool first_hotkey = false;  // Is the first char of button a hotkey</a>
<a name="ln3595">  if (!has_hotkey[0]) {</a>
<a name="ln3596">    first_hotkey = true;     // If no hotkey is specified, first char is used</a>
<a name="ln3597">  }</a>
<a name="ln3598"> </a>
<a name="ln3599">  int idx = 0;</a>
<a name="ln3600">  const char *r = buttons;</a>
<a name="ln3601">  while (*r) {</a>
<a name="ln3602">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3603">      *msgp++ = ',';</a>
<a name="ln3604">      *msgp++ = ' ';                    // '\n' -&gt; ', '</a>
<a name="ln3605"> </a>
<a name="ln3606">      // Advance to next hotkey and set default hotkey</a>
<a name="ln3607">      hotkeys_ptr += strlen(hotkeys_ptr);</a>
<a name="ln3608">      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3609"> </a>
<a name="ln3610">      if (default_button_idx) {</a>
<a name="ln3611">        default_button_idx--;</a>
<a name="ln3612">      }</a>
<a name="ln3613"> </a>
<a name="ln3614">      // If no hotkey is specified, first char is used.</a>
<a name="ln3615">      if (idx &lt; HAS_HOTKEY_LEN - 1 &amp;&amp; !has_hotkey[++idx]) {</a>
<a name="ln3616">        first_hotkey = true;</a>
<a name="ln3617">      }</a>
<a name="ln3618">    } else if (*r == DLG_HOTKEY_CHAR || first_hotkey) {</a>
<a name="ln3619">      if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3620">        r++;</a>
<a name="ln3621">      }</a>
<a name="ln3622"> </a>
<a name="ln3623">      first_hotkey = false;</a>
<a name="ln3624">      if (*r == DLG_HOTKEY_CHAR) {                 // '&amp;&amp;a' -&gt; '&amp;a'</a>
<a name="ln3625">        *msgp++ = *r;</a>
<a name="ln3626">      } else {</a>
<a name="ln3627">        // '&amp;a' -&gt; '[a]'</a>
<a name="ln3628">        *msgp++ = (default_button_idx == 1) ? '[' : '(';</a>
<a name="ln3629">        msgp += copy_char(r, msgp, false);</a>
<a name="ln3630">        *msgp++ = (default_button_idx == 1) ? ']' : ')';</a>
<a name="ln3631"> </a>
<a name="ln3632">        // redefine hotkey</a>
<a name="ln3633">        hotkeys_ptr[copy_char(r, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3634">      }</a>
<a name="ln3635">    } else {</a>
<a name="ln3636">      // everything else copy literally</a>
<a name="ln3637">      msgp += copy_char(r, msgp, false);</a>
<a name="ln3638">    }</a>
<a name="ln3639"> </a>
<a name="ln3640">    // advance to the next character</a>
<a name="ln3641">    MB_PTR_ADV(r);</a>
<a name="ln3642">  }</a>
<a name="ln3643"> </a>
<a name="ln3644">  *msgp++ = ':';</a>
<a name="ln3645">  *msgp++ = ' ';</a>
<a name="ln3646">  *msgp = NUL;</a>
<a name="ln3647">}</a>
<a name="ln3648"> </a>
<a name="ln3649">/// Display the &quot;:confirm&quot; message.  Also called when screen resized.</a>
<a name="ln3650">void display_confirm_msg(void)</a>
<a name="ln3651">{</a>
<a name="ln3652">  // Avoid that 'q' at the more prompt truncates the message here.</a>
<a name="ln3653">  confirm_msg_used++;</a>
<a name="ln3654">  if (confirm_msg != NULL) {</a>
<a name="ln3655">    msg_ext_set_kind(&quot;confirm&quot;);</a>
<a name="ln3656">    msg_puts_attr(confirm_msg, HL_ATTR(HLF_M));</a>
<a name="ln3657">  }</a>
<a name="ln3658">  confirm_msg_used--;</a>
<a name="ln3659">}</a>
<a name="ln3660"> </a>
<a name="ln3661">int vim_dialog_yesno(int type, char *title, char *message, int dflt)</a>
<a name="ln3662">{</a>
<a name="ln3663">  if (do_dialog(type,</a>
<a name="ln3664">                title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3665">                message,</a>
<a name="ln3666">                _(&quot;&amp;Yes\n&amp;No&quot;), dflt, NULL, false) == 1) {</a>
<a name="ln3667">    return VIM_YES;</a>
<a name="ln3668">  }</a>
<a name="ln3669">  return VIM_NO;</a>
<a name="ln3670">}</a>
<a name="ln3671"> </a>
<a name="ln3672">int vim_dialog_yesnocancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3673">{</a>
<a name="ln3674">  switch (do_dialog(type,</a>
<a name="ln3675">                    title == NULL ? _(&quot;Question&quot;) : title,</a>
<a name="ln3676">                    message,</a>
<a name="ln3677">                    _(&quot;&amp;Yes\n&amp;No\n&amp;Cancel&quot;), dflt, NULL, false)) {</a>
<a name="ln3678">  case 1:</a>
<a name="ln3679">    return VIM_YES;</a>
<a name="ln3680">  case 2:</a>
<a name="ln3681">    return VIM_NO;</a>
<a name="ln3682">  }</a>
<a name="ln3683">  return VIM_CANCEL;</a>
<a name="ln3684">}</a>
<a name="ln3685"> </a>
<a name="ln3686">int vim_dialog_yesnoallcancel(int type, char *title, char *message, int dflt)</a>
<a name="ln3687">{</a>
<a name="ln3688">  switch (do_dialog(type,</a>
<a name="ln3689">                    title == NULL ? &quot;Question&quot; : title,</a>
<a name="ln3690">                    message,</a>
<a name="ln3691">                    _(&quot;&amp;Yes\n&amp;No\nSave &amp;All\n&amp;Discard All\n&amp;Cancel&quot;),</a>
<a name="ln3692">                    dflt, NULL, false)) {</a>
<a name="ln3693">  case 1:</a>
<a name="ln3694">    return VIM_YES;</a>
<a name="ln3695">  case 2:</a>
<a name="ln3696">    return VIM_NO;</a>
<a name="ln3697">  case 3:</a>
<a name="ln3698">    return VIM_ALL;</a>
<a name="ln3699">  case 4:</a>
<a name="ln3700">    return VIM_DISCARDALL;</a>
<a name="ln3701">  }</a>
<a name="ln3702">  return VIM_CANCEL;</a>
<a name="ln3703">}</a>
<a name="ln3704"> </a>
<a name="ln3705">/// Check if there should be a delay to allow the user to see a message.</a>
<a name="ln3706">///</a>
<a name="ln3707">/// Used before clearing or redrawing the screen or the command line.</a>
<a name="ln3708">void msg_check_for_delay(bool check_msg_scroll)</a>
<a name="ln3709">{</a>
<a name="ln3710">  if ((emsg_on_display || (check_msg_scroll &amp;&amp; msg_scroll))</a>
<a name="ln3711">      &amp;&amp; !did_wait_return</a>
<a name="ln3712">      &amp;&amp; emsg_silent == 0</a>
<a name="ln3713">      &amp;&amp; !in_assert_fails) {</a>
<a name="ln3714">    ui_flush();</a>
<a name="ln3715">    os_delay(1006L, true);</a>
<a name="ln3716">    emsg_on_display = false;</a>
<a name="ln3717">    if (check_msg_scroll) {</a>
<a name="ln3718">      msg_scroll = false;</a>
<a name="ln3719">    }</a>
<a name="ln3720">  }</a>
<a name="ln3721">}</a>
</code></pre>
<div class="balloon" rel="484"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="495"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="766"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="785"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="835"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="862"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="880"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<div class="balloon" rel="2074"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v601/" target="_blank">V601</a> Pointer is implicitly cast to an integer type. Inspect the second argument.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>