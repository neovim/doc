<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fileio.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// fileio.c: read from and write to a file</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;errno.h&gt;</a>
<a name="ln8">#include &lt;fcntl.h&gt;</a>
<a name="ln9">#include &lt;iconv.h&gt;</a>
<a name="ln10">#include &lt;inttypes.h&gt;</a>
<a name="ln11">#include &lt;limits.h&gt;</a>
<a name="ln12">#include &lt;stdbool.h&gt;</a>
<a name="ln13">#include &lt;stddef.h&gt;</a>
<a name="ln14">#include &lt;stdio.h&gt;</a>
<a name="ln15">#include &lt;string.h&gt;</a>
<a name="ln16">#include &lt;sys/stat.h&gt;</a>
<a name="ln17">#include &lt;uv.h&gt;</a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;auto/config.h&quot;</a>
<a name="ln20">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln21">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln22">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln23">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/buffer_updates.h&quot;</a>
<a name="ln25">#include &quot;nvim/change.h&quot;</a>
<a name="ln26">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln27">#include &quot;nvim/diff.h&quot;</a>
<a name="ln28">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln29">#include &quot;nvim/edit.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval.h&quot;</a>
<a name="ln31">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln33">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln34">#include &quot;nvim/fold.h&quot;</a>
<a name="ln35">#include &quot;nvim/garray.h&quot;</a>
<a name="ln36">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln37">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln38">#include &quot;nvim/globals.h&quot;</a>
<a name="ln39">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln40">#include &quot;nvim/iconv.h&quot;</a>
<a name="ln41">#include &quot;nvim/log.h&quot;</a>
<a name="ln42">#include &quot;nvim/macros.h&quot;</a>
<a name="ln43">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln44">#include &quot;nvim/memfile.h&quot;</a>
<a name="ln45">#include &quot;nvim/memline.h&quot;</a>
<a name="ln46">#include &quot;nvim/memory.h&quot;</a>
<a name="ln47">#include &quot;nvim/message.h&quot;</a>
<a name="ln48">#include &quot;nvim/move.h&quot;</a>
<a name="ln49">#include &quot;nvim/option.h&quot;</a>
<a name="ln50">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln51">#include &quot;nvim/os/fs_defs.h&quot;</a>
<a name="ln52">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln53">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln54">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln55">#include &quot;nvim/path.h&quot;</a>
<a name="ln56">#include &quot;nvim/pos.h&quot;</a>
<a name="ln57">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln58">#include &quot;nvim/sha256.h&quot;</a>
<a name="ln59">#include &quot;nvim/shada.h&quot;</a>
<a name="ln60">#include &quot;nvim/strings.h&quot;</a>
<a name="ln61">#include &quot;nvim/types.h&quot;</a>
<a name="ln62">#include &quot;nvim/ui.h&quot;</a>
<a name="ln63">#include &quot;nvim/undo.h&quot;</a>
<a name="ln64">#include &quot;nvim/vim.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln67"># include &quot;nvim/charset.h&quot;</a>
<a name="ln68">#endif</a>
<a name="ln69"> </a>
<a name="ln70">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln71"># include &lt;dirent.h&gt;</a>
<a name="ln72"># include &lt;sys/file.h&gt;</a>
<a name="ln73">#endif</a>
<a name="ln74"> </a>
<a name="ln75">#ifdef OPEN_CHR_FILES</a>
<a name="ln76"># include &quot;nvim/charset.h&quot;</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">// For compatibility with libuv &lt; 1.20.0 (tested on 1.18.0)</a>
<a name="ln80">#ifndef UV_FS_COPYFILE_FICLONE</a>
<a name="ln81"># define UV_FS_COPYFILE_FICLONE 0</a>
<a name="ln82">#endif</a>
<a name="ln83"> </a>
<a name="ln84">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln85"># include &quot;fileio.c.generated.h&quot;</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">static const char *e_auchangedbuf = N_(&quot;E812: Autocommands changed buffer or buffer name&quot;);</a>
<a name="ln89"> </a>
<a name="ln90">void filemess(buf_T *buf, char *name, char *s, int attr)</a>
<a name="ln91">{</a>
<a name="ln92">  int msg_scroll_save;</a>
<a name="ln93">  int prev_msg_col = msg_col;</a>
<a name="ln94"> </a>
<a name="ln95">  if (msg_silent != 0) {</a>
<a name="ln96">    return;</a>
<a name="ln97">  }</a>
<a name="ln98"> </a>
<a name="ln99">  add_quoted_fname(IObuff, IOSIZE - 100, buf, name);</a>
<a name="ln100"> </a>
<a name="ln101">  // Avoid an over-long translation to cause trouble.</a>
<a name="ln102">  xstrlcat(IObuff, s, IOSIZE);</a>
<a name="ln103"> </a>
<a name="ln104">  // For the first message may have to start a new line.</a>
<a name="ln105">  // For further ones overwrite the previous one, reset msg_scroll before</a>
<a name="ln106">  // calling filemess().</a>
<a name="ln107">  msg_scroll_save = msg_scroll;</a>
<a name="ln108">  if (shortmess(SHM_OVERALL) &amp;&amp; !msg_listdo_overwrite &amp;&amp; !exiting &amp;&amp; p_verbose == 0) {</a>
<a name="ln109">    msg_scroll = false;</a>
<a name="ln110">  }</a>
<a name="ln111">  if (!msg_scroll) {    // wait a bit when overwriting an error msg</a>
<a name="ln112">    msg_check_for_delay(false);</a>
<a name="ln113">  }</a>
<a name="ln114">  msg_start();</a>
<a name="ln115">  if (prev_msg_col != 0 &amp;&amp; msg_col == 0) {</a>
<a name="ln116">    msg_putchar('\r');  // overwrite any previous message.</a>
<a name="ln117">  }</a>
<a name="ln118">  msg_scroll = msg_scroll_save;</a>
<a name="ln119">  msg_scrolled_ign = true;</a>
<a name="ln120">  // may truncate the message to avoid a hit-return prompt</a>
<a name="ln121">  msg_outtrans_attr(msg_may_trunc(false, IObuff), attr);</a>
<a name="ln122">  msg_clr_eos();</a>
<a name="ln123">  ui_flush();</a>
<a name="ln124">  msg_scrolled_ign = false;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">/// Read lines from file &quot;fname&quot; into the buffer after line &quot;from&quot;.</a>
<a name="ln128">///</a>
<a name="ln129">/// 1. We allocate blocks with try_malloc, as big as possible.</a>
<a name="ln130">/// 2. Each block is filled with characters from the file with a single read().</a>
<a name="ln131">/// 3. The lines are inserted in the buffer with ml_append().</a>
<a name="ln132">///</a>
<a name="ln133">/// (caller must check that fname != NULL, unless READ_STDIN is used)</a>
<a name="ln134">///</a>
<a name="ln135">/// &quot;lines_to_skip&quot; is the number of lines that must be skipped</a>
<a name="ln136">/// &quot;lines_to_read&quot; is the number of lines that are appended</a>
<a name="ln137">/// When not recovering lines_to_skip is 0 and lines_to_read MAXLNUM.</a>
<a name="ln138">///</a>
<a name="ln139">/// flags:</a>
<a name="ln140">/// READ_NEW     starting to edit a new buffer</a>
<a name="ln141">/// READ_FILTER  reading filter output</a>
<a name="ln142">/// READ_STDIN   read from stdin instead of a file</a>
<a name="ln143">/// READ_BUFFER  read from curbuf instead of a file (converting after reading</a>
<a name="ln144">///              stdin)</a>
<a name="ln145">/// READ_NOFILE  do not read a file, only trigger BufReadCmd</a>
<a name="ln146">/// READ_DUMMY   read into a dummy buffer (to check if file contents changed)</a>
<a name="ln147">/// READ_KEEP_UNDO  don't clear undo info or read it from a file</a>
<a name="ln148">/// READ_FIFO    read from fifo/socket instead of a file</a>
<a name="ln149">///</a>
<a name="ln150">/// @param eap  can be NULL!</a>
<a name="ln151">///</a>
<a name="ln152">/// @return     FAIL for failure, NOTDONE for directory (failure), or OK</a>
<a name="ln153">int readfile(char *fname, char *sfname, linenr_T from, linenr_T lines_to_skip,</a>
<a name="ln154">             linenr_T lines_to_read, exarg_T *eap, int flags, bool silent)</a>
<a name="ln155">{</a>
<a name="ln156">  int retval = FAIL;  // jump to &quot;theend&quot; instead of returning</a>
<a name="ln157">  int fd = stdin_fd &gt;= 0 ? stdin_fd : 0;</a>
<a name="ln158">  int newfile = (flags &amp; READ_NEW);</a>
<a name="ln159">  int check_readonly;</a>
<a name="ln160">  int filtering = (flags &amp; READ_FILTER);</a>
<a name="ln161">  int read_stdin = (flags &amp; READ_STDIN);</a>
<a name="ln162">  int read_buffer = (flags &amp; READ_BUFFER);</a>
<a name="ln163">  int read_fifo = (flags &amp; READ_FIFO);</a>
<a name="ln164">  int set_options = newfile || read_buffer</a>
<a name="ln165">                    || (eap != NULL &amp;&amp; eap-&gt;read_edit);</a>
<a name="ln166">  linenr_T read_buf_lnum = 1;           // next line to read from curbuf</a>
<a name="ln167">  colnr_T read_buf_col = 0;             // next char to read from this line</a>
<a name="ln168">  char c;</a>
<a name="ln169">  linenr_T lnum = from;</a>
<a name="ln170">  char *ptr = NULL;              // pointer into read buffer</a>
<a name="ln171">  char *buffer = NULL;           // read buffer</a>
<a name="ln172">  char *new_buffer = NULL;       // init to shut up gcc</a>
<a name="ln173">  char *line_start = NULL;       // init to shut up gcc</a>
<a name="ln174">  int wasempty;                         // buffer was empty before reading</a>
<a name="ln175">  colnr_T len;</a>
<a name="ln176">  ptrdiff_t size = 0;</a>
<a name="ln177">  uint8_t *p = NULL;</a>
<a name="ln178">  off_T filesize = 0;</a>
<a name="ln179">  bool skip_read = false;</a>
<a name="ln180">  context_sha256_T sha_ctx;</a>
<a name="ln181">  int read_undo_file = false;</a>
<a name="ln182">  int split = 0;  // number of split lines</a>
<a name="ln183">  linenr_T linecnt;</a>
<a name="ln184">  bool error = false;                   // errors encountered</a>
<a name="ln185">  int ff_error = EOL_UNKNOWN;           // file format with errors</a>
<a name="ln186">  ptrdiff_t linerest = 0;               // remaining chars in line</a>
<a name="ln187">  int perm = 0;</a>
<a name="ln188">#ifdef UNIX</a>
<a name="ln189">  int swap_mode = -1;                   // protection bits for swap file</a>
<a name="ln190">#endif</a>
<a name="ln191">  int fileformat = 0;                   // end-of-line format</a>
<a name="ln192">  bool keep_fileformat = false;</a>
<a name="ln193">  FileInfo file_info;</a>
<a name="ln194">  linenr_T skip_count = 0;</a>
<a name="ln195">  linenr_T read_count = 0;</a>
<a name="ln196">  int msg_save = msg_scroll;</a>
<a name="ln197">  linenr_T read_no_eol_lnum = 0;        // non-zero lnum when last line of</a>
<a name="ln198">                                        // last read was missing the eol</a>
<a name="ln199">  bool file_rewind = false;</a>
<a name="ln200">  int can_retry;</a>
<a name="ln201">  linenr_T conv_error = 0;              // line nr with conversion error</a>
<a name="ln202">  linenr_T illegal_byte = 0;            // line nr with illegal byte</a>
<a name="ln203">  bool keep_dest_enc = false;           // don't retry when char doesn't fit</a>
<a name="ln204">                                        // in destination encoding</a>
<a name="ln205">  int bad_char_behavior = BAD_REPLACE;</a>
<a name="ln206">  // BAD_KEEP, BAD_DROP or character to</a>
<a name="ln207">  // replace with</a>
<a name="ln208">  char *tmpname = NULL;          // name of 'charconvert' output file</a>
<a name="ln209">  int fio_flags = 0;</a>
<a name="ln210">  char *fenc;                    // fileencoding to use</a>
<a name="ln211">  bool fenc_alloced;                    // fenc_next is in allocated memory</a>
<a name="ln212">  char *fenc_next = NULL;        // next item in 'fencs' or NULL</a>
<a name="ln213">  bool advance_fenc = false;</a>
<a name="ln214">  long real_size = 0;</a>
<a name="ln215">  iconv_t iconv_fd = (iconv_t)-1;       // descriptor for iconv() or -1</a>
<a name="ln216">  bool did_iconv = false;               // true when iconv() failed and trying</a>
<a name="ln217">                                        // 'charconvert' next</a>
<a name="ln218">  bool converted = false;                // true if conversion done</a>
<a name="ln219">  bool notconverted = false;             // true if conversion wanted but it wasn't possible</a>
<a name="ln220">  char conv_rest[CONV_RESTLEN];</a>
<a name="ln221">  int conv_restlen = 0;                 // nr of bytes in conv_rest[]</a>
<a name="ln222">  pos_T orig_start;</a>
<a name="ln223">  buf_T *old_curbuf;</a>
<a name="ln224">  char *old_b_ffname;</a>
<a name="ln225">  char *old_b_fname;</a>
<a name="ln226">  int using_b_ffname;</a>
<a name="ln227">  int using_b_fname;</a>
<a name="ln228">  static char *msg_is_a_directory = N_(&quot;is a directory&quot;);</a>
<a name="ln229"> </a>
<a name="ln230">  au_did_filetype = false;  // reset before triggering any autocommands</a>
<a name="ln231"> </a>
<a name="ln232">  curbuf-&gt;b_no_eol_lnum = 0;    // in case it was set by the previous read</a>
<a name="ln233"> </a>
<a name="ln234">  // If there is no file name yet, use the one for the read file.</a>
<a name="ln235">  // BF_NOTEDITED is set to reflect this.</a>
<a name="ln236">  // Don't do this for a read from a filter.</a>
<a name="ln237">  // Only do this when 'cpoptions' contains the 'f' flag.</a>
<a name="ln238">  if (curbuf-&gt;b_ffname == NULL</a>
<a name="ln239">      &amp;&amp; !filtering</a>
<a name="ln240">      &amp;&amp; fname != NULL</a>
<a name="ln241">      &amp;&amp; vim_strchr(p_cpo, CPO_FNAMER) != NULL</a>
<a name="ln242">      &amp;&amp; !(flags &amp; READ_DUMMY)) {</a>
<a name="ln243">    if (set_rw_fname(fname, sfname) == FAIL) {</a>
<a name="ln244">      goto theend;</a>
<a name="ln245">    }</a>
<a name="ln246">  }</a>
<a name="ln247"> </a>
<a name="ln248">  // Remember the initial values of curbuf, curbuf-&gt;b_ffname and</a>
<a name="ln249">  // curbuf-&gt;b_fname to detect whether they are altered as a result of</a>
<a name="ln250">  // executing nasty autocommands.  Also check if &quot;fname&quot; and &quot;sfname&quot;</a>
<a name="ln251">  // point to one of these values.</a>
<a name="ln252">  old_curbuf = curbuf;</a>
<a name="ln253">  old_b_ffname = curbuf-&gt;b_ffname;</a>
<a name="ln254">  old_b_fname = curbuf-&gt;b_fname;</a>
<a name="ln255">  using_b_ffname = (fname == curbuf-&gt;b_ffname) || (sfname == curbuf-&gt;b_ffname);</a>
<a name="ln256">  using_b_fname = (fname == curbuf-&gt;b_fname) || (sfname == curbuf-&gt;b_fname);</a>
<a name="ln257"> </a>
<a name="ln258">  // After reading a file the cursor line changes but we don't want to</a>
<a name="ln259">  // display the line.</a>
<a name="ln260">  ex_no_reprint = true;</a>
<a name="ln261"> </a>
<a name="ln262">  // don't display the file info for another buffer now</a>
<a name="ln263">  need_fileinfo = false;</a>
<a name="ln264"> </a>
<a name="ln265">  // For Unix: Use the short file name whenever possible.</a>
<a name="ln266">  // Avoids problems with networks and when directory names are changed.</a>
<a name="ln267">  // Don't do this for Windows, a &quot;cd&quot; in a sub-shell may have moved us to</a>
<a name="ln268">  // another directory, which we don't detect.</a>
<a name="ln269">  if (sfname == NULL) {</a>
<a name="ln270">    sfname = fname;</a>
<a name="ln271">  }</a>
<a name="ln272">#if defined(UNIX)</a>
<a name="ln273">  fname = sfname;</a>
<a name="ln274">#endif</a>
<a name="ln275"> </a>
<a name="ln276">  // The BufReadCmd and FileReadCmd events intercept the reading process by</a>
<a name="ln277">  // executing the associated commands instead.</a>
<a name="ln278">  if (!filtering &amp;&amp; !read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln279">    orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln280"> </a>
<a name="ln281">    // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln282">    curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln283">    curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln284"> </a>
<a name="ln285">    if (newfile) {</a>
<a name="ln286">      if (apply_autocmds_exarg(EVENT_BUFREADCMD, NULL, sfname,</a>
<a name="ln287">                               false, curbuf, eap)) {</a>
<a name="ln288">        retval = OK;</a>
<a name="ln289">        if (aborting()) {</a>
<a name="ln290">          retval = FAIL;</a>
<a name="ln291">        }</a>
<a name="ln292"> </a>
<a name="ln293">        // The BufReadCmd code usually uses &quot;:read&quot; to get the text and</a>
<a name="ln294">        // perhaps &quot;:file&quot; to change the buffer name. But we should</a>
<a name="ln295">        // consider this to work like &quot;:edit&quot;, thus reset the</a>
<a name="ln296">        // BF_NOTEDITED flag.  Then &quot;:write&quot; will work to overwrite the</a>
<a name="ln297">        // same file.</a>
<a name="ln298">        if (retval == OK) {</a>
<a name="ln299">          curbuf-&gt;b_flags &amp;= ~BF_NOTEDITED;</a>
<a name="ln300">        }</a>
<a name="ln301">        goto theend;</a>
<a name="ln302">      }</a>
<a name="ln303">    } else if (apply_autocmds_exarg(EVENT_FILEREADCMD, sfname, sfname,</a>
<a name="ln304">                                    false, NULL, eap)) {</a>
<a name="ln305">      retval = aborting() ? FAIL : OK;</a>
<a name="ln306">      goto theend;</a>
<a name="ln307">    }</a>
<a name="ln308"> </a>
<a name="ln309">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln310"> </a>
<a name="ln311">    if (flags &amp; READ_NOFILE) {</a>
<a name="ln312">      // Return NOTDONE instead of FAIL so that BufEnter can be triggered</a>
<a name="ln313">      // and other operations don't fail.</a>
<a name="ln314">      retval = NOTDONE;</a>
<a name="ln315">      goto theend;</a>
<a name="ln316">    }</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">  if (((shortmess(SHM_OVER) &amp;&amp; !msg_listdo_overwrite) || curbuf-&gt;b_help) &amp;&amp; p_verbose == 0) {</a>
<a name="ln320">    msg_scroll = false;         // overwrite previous file message</a>
<a name="ln321">  } else {</a>
<a name="ln322">    msg_scroll = true;          // don't overwrite previous file message</a>
<a name="ln323">  }</a>
<a name="ln324">  // If the name is too long we might crash further on, quit here.</a>
<a name="ln325">  if (fname != NULL &amp;&amp; *fname != NUL) {</a>
<a name="ln326">    size_t namelen = strlen(fname);</a>
<a name="ln327"> </a>
<a name="ln328">    // If the name is too long we might crash further on, quit here.</a>
<a name="ln329">    if (namelen &gt;= MAXPATHL) {</a>
<a name="ln330">      filemess(curbuf, fname, _(&quot;Illegal file name&quot;), 0);</a>
<a name="ln331">      msg_end();</a>
<a name="ln332">      msg_scroll = msg_save;</a>
<a name="ln333">      goto theend;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">    // If the name ends in a path separator, we can't open it.  Check here,</a>
<a name="ln337">    // because reading the file may actually work, but then creating the</a>
<a name="ln338">    // swap file may destroy it!  Reported on MS-DOS and Win 95.</a>
<a name="ln339">    if (after_pathsep(fname, fname + namelen)) {</a>
<a name="ln340">      if (!silent) {</a>
<a name="ln341">        filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln342">      }</a>
<a name="ln343">      msg_end();</a>
<a name="ln344">      msg_scroll = msg_save;</a>
<a name="ln345">      retval = NOTDONE;</a>
<a name="ln346">      goto theend;</a>
<a name="ln347">    }</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  if (!read_buffer &amp;&amp; !read_stdin &amp;&amp; !read_fifo) {</a>
<a name="ln351">    perm = os_getperm(fname);</a>
<a name="ln352">    // On Unix it is possible to read a directory, so we have to</a>
<a name="ln353">    // check for it before os_open().</a>
<a name="ln354"> </a>
<a name="ln355">#ifdef OPEN_CHR_FILES</a>
<a name="ln356"># define IS_CHR_DEV(perm, fname) S_ISCHR(perm) &amp;&amp; is_dev_fd_file(fname)</a>
<a name="ln357">#else</a>
<a name="ln358"># define IS_CHR_DEV(perm, fname) false</a>
<a name="ln359">#endif</a>
<a name="ln360"> </a>
<a name="ln361">    if (perm &gt;= 0 &amp;&amp; !S_ISREG(perm)                 // not a regular file ...</a>
<a name="ln362">        &amp;&amp; !S_ISFIFO(perm)                          // ... or fifo</a>
<a name="ln363">        &amp;&amp; !S_ISSOCK(perm)                          // ... or socket</a>
<a name="ln364">        &amp;&amp; !(IS_CHR_DEV(perm, fname))</a>
<a name="ln365">        // ... or a character special file named /dev/fd/&lt;n&gt;</a>
<a name="ln366">        ) {</a>
<a name="ln367">      if (S_ISDIR(perm)) {</a>
<a name="ln368">        if (!silent) {</a>
<a name="ln369">          filemess(curbuf, fname, _(msg_is_a_directory), 0);</a>
<a name="ln370">        }</a>
<a name="ln371">        retval = NOTDONE;</a>
<a name="ln372">      } else {</a>
<a name="ln373">        filemess(curbuf, fname, _(&quot;is not a file&quot;), 0);</a>
<a name="ln374">      }</a>
<a name="ln375">      msg_end();</a>
<a name="ln376">      msg_scroll = msg_save;</a>
<a name="ln377">      goto theend;</a>
<a name="ln378">    }</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  // Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln382">  set_file_options(set_options, eap);</a>
<a name="ln383"> </a>
<a name="ln384">  // When opening a new file we take the readonly flag from the file.</a>
<a name="ln385">  // Default is r/w, can be set to r/o below.</a>
<a name="ln386">  // Don't reset it when in readonly mode</a>
<a name="ln387">  // Only set/reset b_p_ro when BF_CHECK_RO is set.</a>
<a name="ln388">  check_readonly = (newfile &amp;&amp; (curbuf-&gt;b_flags &amp; BF_CHECK_RO));</a>
<a name="ln389">  if (check_readonly &amp;&amp; !readonlymode) {</a>
<a name="ln390">    curbuf-&gt;b_p_ro = false;</a>
<a name="ln391">  }</a>
<a name="ln392"> </a>
<a name="ln393">  if (newfile &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; !read_fifo) {</a>
<a name="ln394">    // Remember time of file.</a>
<a name="ln395">    if (os_fileinfo(fname, &amp;file_info)) {</a>
<a name="ln396">      buf_store_file_info(curbuf, &amp;file_info);</a>
<a name="ln397">      curbuf-&gt;b_mtime_read = curbuf-&gt;b_mtime;</a>
<a name="ln398">      curbuf-&gt;b_mtime_read_ns = curbuf-&gt;b_mtime_ns;</a>
<a name="ln399">#ifdef UNIX</a>
<a name="ln400">      // Use the protection bits of the original file for the swap file.</a>
<a name="ln401">      // This makes it possible for others to read the name of the</a>
<a name="ln402">      // edited file from the swapfile, but only if they can read the</a>
<a name="ln403">      // edited file.</a>
<a name="ln404">      // Remove the &quot;write&quot; and &quot;execute&quot; bits for group and others</a>
<a name="ln405">      // (they must not write the swapfile).</a>
<a name="ln406">      // Add the &quot;read&quot; and &quot;write&quot; bits for the user, otherwise we may</a>
<a name="ln407">      // not be able to write to the file ourselves.</a>
<a name="ln408">      // Setting the bits is done below, after creating the swap file.</a>
<a name="ln409">      swap_mode = ((int)file_info.stat.st_mode &amp; 0644) | 0600;</a>
<a name="ln410">#endif</a>
<a name="ln411">    } else {</a>
<a name="ln412">      curbuf-&gt;b_mtime = 0;</a>
<a name="ln413">      curbuf-&gt;b_mtime_ns = 0;</a>
<a name="ln414">      curbuf-&gt;b_mtime_read = 0;</a>
<a name="ln415">      curbuf-&gt;b_mtime_read_ns = 0;</a>
<a name="ln416">      curbuf-&gt;b_orig_size = 0;</a>
<a name="ln417">      curbuf-&gt;b_orig_mode = 0;</a>
<a name="ln418">    }</a>
<a name="ln419"> </a>
<a name="ln420">    // Reset the &quot;new file&quot; flag.  It will be set again below when the</a>
<a name="ln421">    // file doesn't exist.</a>
<a name="ln422">    curbuf-&gt;b_flags &amp;= ~(BF_NEW | BF_NEW_W);</a>
<a name="ln423">  }</a>
<a name="ln424"> </a>
<a name="ln425">  // Check readonly.</a>
<a name="ln426">  bool file_readonly = false;</a>
<a name="ln427">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln428">    if (!newfile || readonlymode || !(perm &amp; 0222)</a>
<a name="ln429">        || !os_file_is_writable(fname)) {</a>
<a name="ln430">      file_readonly = true;</a>
<a name="ln431">    }</a>
<a name="ln432">    fd = os_open(fname, O_RDONLY, 0);</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  if (fd &lt; 0) {                     // cannot open at all</a>
<a name="ln436">    msg_scroll = msg_save;</a>
<a name="ln437">    if (!newfile) {</a>
<a name="ln438">      goto theend;</a>
<a name="ln439">    }</a>
<a name="ln440">    if (perm == UV_ENOENT) {  // check if the file exists</a>
<a name="ln441">      // Set the 'new-file' flag, so that when the file has</a>
<a name="ln442">      // been created by someone else, a &quot;:w&quot; will complain.</a>
<a name="ln443">      curbuf-&gt;b_flags |= BF_NEW;</a>
<a name="ln444"> </a>
<a name="ln445">      // Create a swap file now, so that other Vims are warned</a>
<a name="ln446">      // that we are editing this file.  Don't do this for a</a>
<a name="ln447">      // &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln448">      if (!bt_dontwrite(curbuf)) {</a>
<a name="ln449">        check_need_swap(newfile);</a>
<a name="ln450">        // SwapExists autocommand may mess things up</a>
<a name="ln451">        if (curbuf != old_curbuf</a>
<a name="ln452">            || (using_b_ffname</a>
<a name="ln453">                &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln454">            || (using_b_fname</a>
<a name="ln455">                &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))) {</a>
<a name="ln456">          emsg(_(e_auchangedbuf));</a>
<a name="ln457">          goto theend;</a>
<a name="ln458">        }</a>
<a name="ln459">      }</a>
<a name="ln460">      if (!silent) {</a>
<a name="ln461">        if (dir_of_file_exists(fname)) {</a>
<a name="ln462">          filemess(curbuf, sfname, _(&quot;[New]&quot;), 0);</a>
<a name="ln463">        } else {</a>
<a name="ln464">          filemess(curbuf, sfname, _(&quot;[New DIRECTORY]&quot;), 0);</a>
<a name="ln465">        }</a>
<a name="ln466">      }</a>
<a name="ln467">      // Even though this is a new file, it might have been</a>
<a name="ln468">      // edited before and deleted.  Get the old marks.</a>
<a name="ln469">      check_marks_read();</a>
<a name="ln470">      // Set forced 'fileencoding'.</a>
<a name="ln471">      if (eap != NULL) {</a>
<a name="ln472">        set_forced_fenc(eap);</a>
<a name="ln473">      }</a>
<a name="ln474">      apply_autocmds_exarg(EVENT_BUFNEWFILE, sfname, sfname,</a>
<a name="ln475">                           false, curbuf, eap);</a>
<a name="ln476">      // remember the current fileformat</a>
<a name="ln477">      save_file_ff(curbuf);</a>
<a name="ln478"> </a>
<a name="ln479">      if (!aborting()) {  // autocmds may abort script processing</a>
<a name="ln480">        retval = OK;      // a new file is not an error</a>
<a name="ln481">      }</a>
<a name="ln482">      goto theend;</a>
<a name="ln483">    }</a>
<a name="ln484">#if defined(UNIX) &amp;&amp; defined(EOVERFLOW)</a>
<a name="ln485">    filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln486">                              // libuv only returns -errno</a>
<a name="ln487">                              // in Unix and in Windows</a>
<a name="ln488">                              // open() does not set</a>
<a name="ln489">                              // EOVERFLOW</a>
<a name="ln490">                              (fd == -EOVERFLOW) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln491">                              _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln492">#else</a>
<a name="ln493">    filemess(curbuf, sfname, ((fd == UV_EFBIG) ? _(&quot;[File too big]&quot;) :</a>
<a name="ln494">                              _(&quot;[Permission Denied]&quot;)), 0);</a>
<a name="ln495">#endif</a>
<a name="ln496">    curbuf-&gt;b_p_ro = true;                  // must use &quot;w!&quot; now</a>
<a name="ln497"> </a>
<a name="ln498">    goto theend;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">  // Only set the 'ro' flag for readonly files the first time they are</a>
<a name="ln502">  // loaded.    Help files always get readonly mode</a>
<a name="ln503">  if ((check_readonly &amp;&amp; file_readonly) || curbuf-&gt;b_help) {</a>
<a name="ln504">    curbuf-&gt;b_p_ro = true;</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  if (set_options) {</a>
<a name="ln508">    // Don't change 'eol' if reading from buffer as it will already be</a>
<a name="ln509">    // correctly set when reading stdin.</a>
<a name="ln510">    if (!read_buffer) {</a>
<a name="ln511">      curbuf-&gt;b_p_eof = false;</a>
<a name="ln512">      curbuf-&gt;b_start_eof = false;</a>
<a name="ln513">      curbuf-&gt;b_p_eol = true;</a>
<a name="ln514">      curbuf-&gt;b_start_eol = true;</a>
<a name="ln515">    }</a>
<a name="ln516">    curbuf-&gt;b_p_bomb = false;</a>
<a name="ln517">    curbuf-&gt;b_start_bomb = false;</a>
<a name="ln518">  }</a>
<a name="ln519"> </a>
<a name="ln520">  // Create a swap file now, so that other Vims are warned that we are</a>
<a name="ln521">  // editing this file.</a>
<a name="ln522">  // Don't do this for a &quot;nofile&quot; or &quot;nowrite&quot; buffer type.</a>
<a name="ln523">  if (!bt_dontwrite(curbuf)) {</a>
<a name="ln524">    check_need_swap(newfile);</a>
<a name="ln525">    if (!read_stdin</a>
<a name="ln526">        &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln527">            || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln528">            || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname)))) {</a>
<a name="ln529">      emsg(_(e_auchangedbuf));</a>
<a name="ln530">      if (!read_buffer) {</a>
<a name="ln531">        close(fd);</a>
<a name="ln532">      }</a>
<a name="ln533">      goto theend;</a>
<a name="ln534">    }</a>
<a name="ln535">#ifdef UNIX</a>
<a name="ln536">    // Set swap file protection bits after creating it.</a>
<a name="ln537">    if (swap_mode &gt; 0 &amp;&amp; curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln538">        &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname != NULL) {</a>
<a name="ln539">      const char *swap_fname = curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname;</a>
<a name="ln540"> </a>
<a name="ln541">      // If the group-read bit is set but not the world-read bit, then</a>
<a name="ln542">      // the group must be equal to the group of the original file.  If</a>
<a name="ln543">      // we can't make that happen then reset the group-read bit.  This</a>
<a name="ln544">      // avoids making the swap file readable to more users when the</a>
<a name="ln545">      // primary group of the user is too permissive.</a>
<a name="ln546">      if ((swap_mode &amp; 044) == 040) {</a>
<a name="ln547">        FileInfo swap_info;</a>
<a name="ln548"> </a>
<a name="ln549">        if (os_fileinfo(swap_fname, &amp;swap_info)</a>
<a name="ln550">            &amp;&amp; file_info.stat.st_gid != swap_info.stat.st_gid</a>
<a name="ln551">            &amp;&amp; os_fchown(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fd, (uv_uid_t)(-1),</a>
<a name="ln552">                         (uv_gid_t)file_info.stat.st_gid)</a>
<a name="ln553">            == -1) {</a>
<a name="ln554">          swap_mode &amp;= 0600;</a>
<a name="ln555">        }</a>
<a name="ln556">      }</a>
<a name="ln557"> </a>
<a name="ln558">      (void)os_setperm(swap_fname, swap_mode);</a>
<a name="ln559">    }</a>
<a name="ln560">#endif</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">  // If &quot;Quit&quot; selected at ATTENTION dialog, don't load the file.</a>
<a name="ln564">  if (swap_exists_action == SEA_QUIT) {</a>
<a name="ln565">    if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln566">      close(fd);</a>
<a name="ln567">    }</a>
<a name="ln568">    goto theend;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">  no_wait_return++;         // don't wait for return yet</a>
<a name="ln572"> </a>
<a name="ln573">  // Set '[ mark to the line above where the lines go (line 1 if zero).</a>
<a name="ln574">  orig_start = curbuf-&gt;b_op_start;</a>
<a name="ln575">  curbuf-&gt;b_op_start.lnum = ((from == 0) ? 1 : from);</a>
<a name="ln576">  curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln577"> </a>
<a name="ln578">  int try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln579">  int try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln580">  int try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln581"> </a>
<a name="ln582">  if (!read_buffer) {</a>
<a name="ln583">    int m = msg_scroll;</a>
<a name="ln584">    int n = msg_scrolled;</a>
<a name="ln585"> </a>
<a name="ln586">    // The file must be closed again, the autocommands may want to change</a>
<a name="ln587">    // the file before reading it.</a>
<a name="ln588">    if (!read_stdin) {</a>
<a name="ln589">      close(fd);                // ignore errors</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln593">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln594">    // output was done.</a>
<a name="ln595">    msg_scroll = true;</a>
<a name="ln596">    if (filtering) {</a>
<a name="ln597">      apply_autocmds_exarg(EVENT_FILTERREADPRE, NULL, sfname,</a>
<a name="ln598">                           false, curbuf, eap);</a>
<a name="ln599">    } else if (read_stdin) {</a>
<a name="ln600">      apply_autocmds_exarg(EVENT_STDINREADPRE, NULL, sfname,</a>
<a name="ln601">                           false, curbuf, eap);</a>
<a name="ln602">    } else if (newfile) {</a>
<a name="ln603">      apply_autocmds_exarg(EVENT_BUFREADPRE, NULL, sfname,</a>
<a name="ln604">                           false, curbuf, eap);</a>
<a name="ln605">    } else {</a>
<a name="ln606">      apply_autocmds_exarg(EVENT_FILEREADPRE, sfname, sfname,</a>
<a name="ln607">                           false, NULL, eap);</a>
<a name="ln608">    }</a>
<a name="ln609"> </a>
<a name="ln610">    // autocommands may have changed it</a>
<a name="ln611">    try_mac = (vim_strchr(p_ffs, 'm') != NULL);</a>
<a name="ln612">    try_dos = (vim_strchr(p_ffs, 'd') != NULL);</a>
<a name="ln613">    try_unix = (vim_strchr(p_ffs, 'x') != NULL);</a>
<a name="ln614">    curbuf-&gt;b_op_start = orig_start;</a>
<a name="ln615"> </a>
<a name="ln616">    if (msg_scrolled == n) {</a>
<a name="ln617">      msg_scroll = m;</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln621">      no_wait_return--;</a>
<a name="ln622">      msg_scroll = msg_save;</a>
<a name="ln623">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln624">      goto theend;</a>
<a name="ln625">    }</a>
<a name="ln626">    // Don't allow the autocommands to change the current buffer.</a>
<a name="ln627">    // Try to re-open the file.</a>
<a name="ln628">    //</a>
<a name="ln629">    // Don't allow the autocommands to change the buffer name either</a>
<a name="ln630">    // (cd for example) if it invalidates fname or sfname.</a>
<a name="ln631">    if (!read_stdin &amp;&amp; (curbuf != old_curbuf</a>
<a name="ln632">                        || (using_b_ffname &amp;&amp; (old_b_ffname != curbuf-&gt;b_ffname))</a>
<a name="ln633">                        || (using_b_fname &amp;&amp; (old_b_fname != curbuf-&gt;b_fname))</a>
<a name="ln634">                        || (fd = os_open(fname, O_RDONLY, 0)) &lt; 0)) {</a>
<a name="ln635">      no_wait_return--;</a>
<a name="ln636">      msg_scroll = msg_save;</a>
<a name="ln637">      if (fd &lt; 0) {</a>
<a name="ln638">        emsg(_(&quot;E200: *ReadPre autocommands made the file unreadable&quot;));</a>
<a name="ln639">      } else {</a>
<a name="ln640">        emsg(_(&quot;E201: *ReadPre autocommands must not change current buffer&quot;));</a>
<a name="ln641">      }</a>
<a name="ln642">      curbuf-&gt;b_p_ro = true;            // must use &quot;w!&quot; now</a>
<a name="ln643">      goto theend;</a>
<a name="ln644">    }</a>
<a name="ln645">  }</a>
<a name="ln646"> </a>
<a name="ln647">  // Autocommands may add lines to the file, need to check if it is empty</a>
<a name="ln648">  wasempty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln649"> </a>
<a name="ln650">  if (!recoverymode &amp;&amp; !filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln651">    if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln652">      filemess(curbuf, sfname, &quot;&quot;, 0);</a>
<a name="ln653">    }</a>
<a name="ln654">  }</a>
<a name="ln655"> </a>
<a name="ln656">  msg_scroll = false;                   // overwrite the file message</a>
<a name="ln657"> </a>
<a name="ln658">  // Set linecnt now, before the &quot;retry&quot; caused by a wrong guess for</a>
<a name="ln659">  // fileformat, and after the autocommands, which may change them.</a>
<a name="ln660">  linecnt = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln661"> </a>
<a name="ln662">  // &quot;++bad=&quot; argument.</a>
<a name="ln663">  if (eap != NULL &amp;&amp; eap-&gt;bad_char != 0) {</a>
<a name="ln664">    bad_char_behavior = eap-&gt;bad_char;</a>
<a name="ln665">    if (set_options) {</a>
<a name="ln666">      curbuf-&gt;b_bad_char = eap-&gt;bad_char;</a>
<a name="ln667">    }</a>
<a name="ln668">  } else {</a>
<a name="ln669">    curbuf-&gt;b_bad_char = 0;</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  // Decide which 'encoding' to use or use first.</a>
<a name="ln673">  if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln674">    fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln675">    fenc_alloced = true;</a>
<a name="ln676">    keep_dest_enc = true;</a>
<a name="ln677">  } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln678">    fenc = &quot;&quot;;                // binary: don't convert</a>
<a name="ln679">    fenc_alloced = false;</a>
<a name="ln680">  } else if (curbuf-&gt;b_help) {</a>
<a name="ln681">    // Help files are either utf-8 or latin1.  Try utf-8 first, if this</a>
<a name="ln682">    // fails it must be latin1.</a>
<a name="ln683">    // It is needed when the first line contains non-ASCII characters.</a>
<a name="ln684">    // That is only in *.??x files.</a>
<a name="ln685">    fenc_next = &quot;latin1&quot;;</a>
<a name="ln686">    fenc = &quot;utf-8&quot;;</a>
<a name="ln687"> </a>
<a name="ln688">    fenc_alloced = false;</a>
<a name="ln689">  } else if (*p_fencs == NUL) {</a>
<a name="ln690">    fenc = curbuf-&gt;b_p_fenc;            // use format from buffer</a>
<a name="ln691">    fenc_alloced = false;</a>
<a name="ln692">  } else {</a>
<a name="ln693">    fenc_next = p_fencs;                // try items in 'fileencodings'</a>
<a name="ln694">    fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">  // Jump back here to retry reading the file in different ways.</a>
<a name="ln698">  // Reasons to retry:</a>
<a name="ln699">  // - encoding conversion failed: try another one from &quot;fenc_next&quot;</a>
<a name="ln700">  // - BOM detected and fenc was set, need to setup conversion</a>
<a name="ln701">  // - &quot;fileformat&quot; check failed: try another</a>
<a name="ln702">  //</a>
<a name="ln703">  // Variables set for special retry actions:</a>
<a name="ln704">  // &quot;file_rewind&quot;      Rewind the file to start reading it again.</a>
<a name="ln705">  // &quot;advance_fenc&quot;     Advance &quot;fenc&quot; using &quot;fenc_next&quot;.</a>
<a name="ln706">  // &quot;skip_read&quot;        Re-use already read bytes (BOM detected).</a>
<a name="ln707">  // &quot;did_iconv&quot;        iconv() conversion failed, try 'charconvert'.</a>
<a name="ln708">  // &quot;keep_fileformat&quot; Don't reset &quot;fileformat&quot;.</a>
<a name="ln709">  //</a>
<a name="ln710">  // Other status indicators:</a>
<a name="ln711">  // &quot;tmpname&quot;  When != NULL did conversion with 'charconvert'.</a>
<a name="ln712">  //                    Output file has to be deleted afterwards.</a>
<a name="ln713">  // &quot;iconv_fd&quot; When != -1 did conversion with iconv().</a>
<a name="ln714">retry:</a>
<a name="ln715"> </a>
<a name="ln716">  if (file_rewind) {</a>
<a name="ln717">    if (read_buffer) {</a>
<a name="ln718">      read_buf_lnum = 1;</a>
<a name="ln719">      read_buf_col = 0;</a>
<a name="ln720">    } else if (read_stdin || vim_lseek(fd, (off_T)0L, SEEK_SET) != 0) {</a>
<a name="ln721">      // Can't rewind the file, give up.</a>
<a name="ln722">      error = true;</a>
<a name="ln723">      goto failed;</a>
<a name="ln724">    }</a>
<a name="ln725">    // Delete the previously read lines.</a>
<a name="ln726">    while (lnum &gt; from) {</a>
<a name="ln727">      ml_delete(lnum--, false);</a>
<a name="ln728">    }</a>
<a name="ln729">    file_rewind = false;</a>
<a name="ln730">    if (set_options) {</a>
<a name="ln731">      curbuf-&gt;b_p_bomb = false;</a>
<a name="ln732">      curbuf-&gt;b_start_bomb = false;</a>
<a name="ln733">    }</a>
<a name="ln734">    conv_error = 0;</a>
<a name="ln735">  }</a>
<a name="ln736"> </a>
<a name="ln737">  // When retrying with another &quot;fenc&quot; and the first time &quot;fileformat&quot;</a>
<a name="ln738">  // will be reset.</a>
<a name="ln739">  if (keep_fileformat) {</a>
<a name="ln740">    keep_fileformat = false;</a>
<a name="ln741">  } else {</a>
<a name="ln742">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln743">      fileformat = get_fileformat_force(curbuf, eap);</a>
<a name="ln744">      try_unix = try_dos = try_mac = false;</a>
<a name="ln745">    } else if (curbuf-&gt;b_p_bin) {</a>
<a name="ln746">      fileformat = EOL_UNIX;                    // binary: use Unix format</a>
<a name="ln747">    } else if (*p_ffs ==</a>
<a name="ln748">               NUL) {</a>
<a name="ln749">      fileformat = get_fileformat(curbuf);      // use format from buffer</a>
<a name="ln750">    } else {</a>
<a name="ln751">      fileformat = EOL_UNKNOWN;                 // detect from file</a>
<a name="ln752">    }</a>
<a name="ln753">  }</a>
<a name="ln754"> </a>
<a name="ln755">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln756">    // aborted conversion with iconv(), close the descriptor</a>
<a name="ln757">    iconv_close(iconv_fd);</a>
<a name="ln758">    iconv_fd = (iconv_t)-1;</a>
<a name="ln759">  }</a>
<a name="ln760"> </a>
<a name="ln761">  if (advance_fenc) {</a>
<a name="ln762">    // Try the next entry in 'fileencodings'.</a>
<a name="ln763">    advance_fenc = false;</a>
<a name="ln764"> </a>
<a name="ln765">    if (eap != NULL &amp;&amp; eap-&gt;force_enc != 0) {</a>
<a name="ln766">      // Conversion given with &quot;++cc=&quot; wasn't possible, read</a>
<a name="ln767">      // without conversion.</a>
<a name="ln768">      notconverted = true;</a>
<a name="ln769">      conv_error = 0;</a>
<a name="ln770">      if (fenc_alloced) {</a>
<a name="ln771">        xfree(fenc);</a>
<a name="ln772">      }</a>
<a name="ln773">      fenc = &quot;&quot;;</a>
<a name="ln774">      fenc_alloced = false;</a>
<a name="ln775">    } else {</a>
<a name="ln776">      if (fenc_alloced) {</a>
<a name="ln777">        xfree(fenc);</a>
<a name="ln778">      }</a>
<a name="ln779">      if (fenc_next != NULL) {</a>
<a name="ln780">        fenc = next_fenc(&amp;fenc_next, &amp;fenc_alloced);</a>
<a name="ln781">      } else {</a>
<a name="ln782">        fenc = &quot;&quot;;</a>
<a name="ln783">        fenc_alloced = false;</a>
<a name="ln784">      }</a>
<a name="ln785">    }</a>
<a name="ln786">    if (tmpname != NULL) {</a>
<a name="ln787">      os_remove(tmpname);  // delete converted file</a>
<a name="ln788">      XFREE_CLEAR(tmpname);</a>
<a name="ln789">    }</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  // Conversion may be required when the encoding of the file is different</a>
<a name="ln793">  // from 'encoding' or 'encoding' is UTF-16, UCS-2 or UCS-4.</a>
<a name="ln794">  fio_flags = 0;</a>
<a name="ln795">  converted = need_conversion(fenc);</a>
<a name="ln796">  if (converted) {</a>
<a name="ln797">    // &quot;ucs-bom&quot; means we need to check the first bytes of the file</a>
<a name="ln798">    // for a BOM.</a>
<a name="ln799">    if (strcmp(fenc, ENC_UCSBOM) == 0) {</a>
<a name="ln800">      fio_flags = FIO_UCSBOM;</a>
<a name="ln801">    } else {</a>
<a name="ln802">      // Check if UCS-2/4 or Latin1 to UTF-8 conversion needs to be</a>
<a name="ln803">      // done.  This is handled below after read().  Prepare the</a>
<a name="ln804">      // fio_flags to avoid having to parse the string each time.</a>
<a name="ln805">      // Also check for Unicode to Latin1 conversion, because iconv()</a>
<a name="ln806">      // appears not to handle this correctly.  This works just like</a>
<a name="ln807">      // conversion to UTF-8 except how the resulting character is put in</a>
<a name="ln808">      // the buffer.</a>
<a name="ln809">      fio_flags = get_fio_flags(fenc);</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">    // Try using iconv() if we can't convert internally.</a>
<a name="ln813">    if (fio_flags == 0</a>
<a name="ln814">        &amp;&amp; !did_iconv) {</a>
<a name="ln815">      iconv_fd = (iconv_t)my_iconv_open(&quot;utf-8&quot;, fenc);</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    // Use the 'charconvert' expression when conversion is required</a>
<a name="ln819">    // and we can't do it internally or with iconv().</a>
<a name="ln820">    if (fio_flags == 0 &amp;&amp; !read_stdin &amp;&amp; !read_buffer &amp;&amp; *p_ccv != NUL</a>
<a name="ln821">        &amp;&amp; !read_fifo &amp;&amp; iconv_fd == (iconv_t)-1) {</a>
<a name="ln822">      did_iconv = false;</a>
<a name="ln823">      // Skip conversion when it's already done (retry for wrong</a>
<a name="ln824">      // &quot;fileformat&quot;).</a>
<a name="ln825">      if (tmpname == NULL) {</a>
<a name="ln826">        tmpname = readfile_charconvert(fname, fenc, &amp;fd);</a>
<a name="ln827">        if (tmpname == NULL) {</a>
<a name="ln828">          // Conversion failed.  Try another one.</a>
<a name="ln829">          advance_fenc = true;</a>
<a name="ln830">          if (fd &lt; 0) {</a>
<a name="ln831">            // Re-opening the original file failed!</a>
<a name="ln832">            emsg(_(&quot;E202: Conversion made file unreadable!&quot;));</a>
<a name="ln833">            error = true;</a>
<a name="ln834">            goto failed;</a>
<a name="ln835">          }</a>
<a name="ln836">          goto retry;</a>
<a name="ln837">        }</a>
<a name="ln838">      }</a>
<a name="ln839">    } else {</a>
<a name="ln840">      if (fio_flags == 0 &amp;&amp; iconv_fd == (iconv_t)-1) {</a>
<a name="ln841">        // Conversion wanted but we can't.</a>
<a name="ln842">        // Try the next conversion in 'fileencodings'</a>
<a name="ln843">        advance_fenc = true;</a>
<a name="ln844">        goto retry;</a>
<a name="ln845">      }</a>
<a name="ln846">    }</a>
<a name="ln847">  }</a>
<a name="ln848"> </a>
<a name="ln849">  // Set &quot;can_retry&quot; when it's possible to rewind the file and try with</a>
<a name="ln850">  // another &quot;fenc&quot; value.  It's false when no other &quot;fenc&quot; to try, reading</a>
<a name="ln851">  // stdin or fixed at a specific encoding.</a>
<a name="ln852">  can_retry = (*fenc != NUL &amp;&amp; !read_stdin &amp;&amp; !keep_dest_enc &amp;&amp; !read_fifo);</a>
<a name="ln853"> </a>
<a name="ln854">  if (!skip_read) {</a>
<a name="ln855">    linerest = 0;</a>
<a name="ln856">    filesize = 0;</a>
<a name="ln857">    skip_count = lines_to_skip;</a>
<a name="ln858">    read_count = lines_to_read;</a>
<a name="ln859">    conv_restlen = 0;</a>
<a name="ln860">    read_undo_file = (newfile &amp;&amp; (flags &amp; READ_KEEP_UNDO) == 0</a>
<a name="ln861">                      &amp;&amp; curbuf-&gt;b_ffname != NULL</a>
<a name="ln862">                      &amp;&amp; curbuf-&gt;b_p_udf</a>
<a name="ln863">                      &amp;&amp; !filtering</a>
<a name="ln864">                      &amp;&amp; !read_fifo</a>
<a name="ln865">                      &amp;&amp; !read_stdin</a>
<a name="ln866">                      &amp;&amp; !read_buffer);</a>
<a name="ln867">    if (read_undo_file) {</a>
<a name="ln868">      sha256_start(&amp;sha_ctx);</a>
<a name="ln869">    }</a>
<a name="ln870">  }</a>
<a name="ln871"> </a>
<a name="ln872">  while (!error &amp;&amp; !got_int) {</a>
<a name="ln873">    // We allocate as much space for the file as we can get, plus</a>
<a name="ln874">    // space for the old line plus room for one terminating NUL.</a>
<a name="ln875">    // The amount is limited by the fact that read() only can read</a>
<a name="ln876">    // up to max_unsigned characters (and other things).</a>
<a name="ln877">    {</a>
<a name="ln878">      if (!skip_read) {</a>
<a name="ln879">        // Use buffer &gt;= 64K.  Add linerest to double the size if the</a>
<a name="ln880">        // line gets very long, to avoid a lot of copying. But don't</a>
<a name="ln881">        // read more than 1 Mbyte at a time, so we can be interrupted.</a>
<a name="ln882">        size = 0x10000L + linerest;</a>
<a name="ln883">        if (size &gt; 0x100000L) {</a>
<a name="ln884">          size = 0x100000L;</a>
<a name="ln885">        }</a>
<a name="ln886">      }</a>
<a name="ln887"> </a>
<a name="ln888">      // Protect against the argument of lalloc() going negative.</a>
<a name="ln889">      if (size &lt; 0 || size + linerest + 1 &lt; 0 || linerest &gt;= MAXCOL) {</a>
<a name="ln890">        split++;</a>
<a name="ln891">        *ptr = NL;  // split line by inserting a NL</a>
<a name="ln892">        size = 1;</a>
<a name="ln893">      } else if (!skip_read) {</a>
<a name="ln894">        for (; size &gt;= 10; size /= 2) {</a>
<a name="ln895">          new_buffer = verbose_try_malloc((size_t)size + (size_t)linerest + 1);</a>
<a name="ln896">          if (new_buffer) {</a>
<a name="ln897">            break;</a>
<a name="ln898">          }</a>
<a name="ln899">        }</a>
<a name="ln900">        if (new_buffer == NULL) {</a>
<a name="ln901">          error = true;</a>
<a name="ln902">          break;</a>
<a name="ln903">        }</a>
<a name="ln904">        if (linerest) {         // copy characters from the previous buffer</a>
<a name="ln905">          memmove(new_buffer, ptr - linerest, (size_t)linerest);</a>
<a name="ln906">        }</a>
<a name="ln907">        xfree(buffer);</a>
<a name="ln908">        buffer = new_buffer;</a>
<a name="ln909">        ptr = buffer + linerest;</a>
<a name="ln910">        line_start = buffer;</a>
<a name="ln911"> </a>
<a name="ln912">        // May need room to translate into.</a>
<a name="ln913">        // For iconv() we don't really know the required space, use a</a>
<a name="ln914">        // factor ICONV_MULT.</a>
<a name="ln915">        // latin1 to utf-8: 1 byte becomes up to 2 bytes</a>
<a name="ln916">        // utf-16 to utf-8: 2 bytes become up to 3 bytes, 4 bytes</a>
<a name="ln917">        // become up to 4 bytes, size must be multiple of 2</a>
<a name="ln918">        // ucs-2 to utf-8: 2 bytes become up to 3 bytes, size must be</a>
<a name="ln919">        // multiple of 2</a>
<a name="ln920">        // ucs-4 to utf-8: 4 bytes become up to 6 bytes, size must be</a>
<a name="ln921">        // multiple of 4</a>
<a name="ln922">        real_size = (int)size;</a>
<a name="ln923">        if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln924">          size = size / ICONV_MULT;</a>
<a name="ln925">        } else if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln926">          size = size / 2;</a>
<a name="ln927">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln928">          size = (size * 2 / 3) &amp; ~1;</a>
<a name="ln929">        } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln930">          size = (size * 2 / 3) &amp; ~3;</a>
<a name="ln931">        } else if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln932">          size = size / ICONV_MULT;  // worst case</a>
<a name="ln933">        }</a>
<a name="ln934"> </a>
<a name="ln935">        if (conv_restlen &gt; 0) {</a>
<a name="ln936">          // Insert unconverted bytes from previous line.</a>
<a name="ln937">          memmove(ptr, conv_rest, (size_t)conv_restlen);  // -V614</a>
<a name="ln938">          ptr += conv_restlen;</a>
<a name="ln939">          size -= conv_restlen;</a>
<a name="ln940">        }</a>
<a name="ln941"> </a>
<a name="ln942">        if (read_buffer) {</a>
<a name="ln943">          // Read bytes from curbuf.  Used for converting text read</a>
<a name="ln944">          // from stdin.</a>
<a name="ln945">          if (read_buf_lnum &gt; from) {</a>
<a name="ln946">            size = 0;</a>
<a name="ln947">          } else {</a>
<a name="ln948">            int ni;</a>
<a name="ln949">            long tlen = 0;</a>
<a name="ln950">            while (true) {</a>
<a name="ln951">              p = (uint8_t *)ml_get(read_buf_lnum) + read_buf_col;</a>
<a name="ln952">              int n = (int)strlen((char *)p);</a>
<a name="ln953">              if ((int)tlen + n + 1 &gt; size) {</a>
<a name="ln954">                // Filled up to &quot;size&quot;, append partial line.</a>
<a name="ln955">                // Change NL to NUL to reverse the effect done</a>
<a name="ln956">                // below.</a>
<a name="ln957">                n = (int)(size - tlen);</a>
<a name="ln958">                for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln959">                  if (p[ni] == NL) {</a>
<a name="ln960">                    ptr[tlen++] = NUL;</a>
<a name="ln961">                  } else {</a>
<a name="ln962">                    ptr[tlen++] = (char)p[ni];</a>
<a name="ln963">                  }</a>
<a name="ln964">                }</a>
<a name="ln965">                read_buf_col += n;</a>
<a name="ln966">                break;</a>
<a name="ln967">              }</a>
<a name="ln968"> </a>
<a name="ln969">              // Append whole line and new-line.  Change NL</a>
<a name="ln970">              // to NUL to reverse the effect done below.</a>
<a name="ln971">              for (ni = 0; ni &lt; n; ni++) {</a>
<a name="ln972">                if (p[ni] == NL) {</a>
<a name="ln973">                  ptr[tlen++] = NUL;</a>
<a name="ln974">                } else {</a>
<a name="ln975">                  ptr[tlen++] = (char)p[ni];</a>
<a name="ln976">                }</a>
<a name="ln977">              }</a>
<a name="ln978">              ptr[tlen++] = NL;</a>
<a name="ln979">              read_buf_col = 0;</a>
<a name="ln980">              if (++read_buf_lnum &gt; from) {</a>
<a name="ln981">                // When the last line didn't have an</a>
<a name="ln982">                // end-of-line don't add it now either.</a>
<a name="ln983">                if (!curbuf-&gt;b_p_eol) {</a>
<a name="ln984">                  tlen--;</a>
<a name="ln985">                }</a>
<a name="ln986">                size = tlen;</a>
<a name="ln987">                break;</a>
<a name="ln988">              }</a>
<a name="ln989">            }</a>
<a name="ln990">          }</a>
<a name="ln991">        } else {</a>
<a name="ln992">          // Read bytes from the file.</a>
<a name="ln993">          size_t read_size = (size_t)size;</a>
<a name="ln994">          size = read_eintr(fd, ptr, read_size);</a>
<a name="ln995">        }</a>
<a name="ln996"> </a>
<a name="ln997">        if (size &lt;= 0) {</a>
<a name="ln998">          if (size &lt; 0) {                           // read error</a>
<a name="ln999">            error = true;</a>
<a name="ln1000">          } else if (conv_restlen &gt; 0) {</a>
<a name="ln1001">            // Reached end-of-file but some trailing bytes could</a>
<a name="ln1002">            // not be converted.  Truncated file?</a>
<a name="ln1003"> </a>
<a name="ln1004">            // When we did a conversion report an error.</a>
<a name="ln1005">            if (fio_flags != 0 || iconv_fd != (iconv_t)-1) {</a>
<a name="ln1006">              if (can_retry) {</a>
<a name="ln1007">                goto rewind_retry;</a>
<a name="ln1008">              }</a>
<a name="ln1009">              if (conv_error == 0) {</a>
<a name="ln1010">                conv_error = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1011">                             - linecnt + 1;</a>
<a name="ln1012">              }</a>
<a name="ln1013">            } else if (illegal_byte == 0) {</a>
<a name="ln1014">              // Remember the first linenr with an illegal byte</a>
<a name="ln1015">              illegal_byte = curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln1016">                             - linecnt + 1;</a>
<a name="ln1017">            }</a>
<a name="ln1018">            if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1019">              *(ptr - conv_restlen) = NUL;</a>
<a name="ln1020">              conv_restlen = 0;</a>
<a name="ln1021">            } else {</a>
<a name="ln1022">              // Replace the trailing bytes with the replacement</a>
<a name="ln1023">              // character if we were converting; if we weren't,</a>
<a name="ln1024">              // leave the UTF8 checking code to do it, as it</a>
<a name="ln1025">              // works slightly differently.</a>
<a name="ln1026">              if (bad_char_behavior != BAD_KEEP &amp;&amp; (fio_flags != 0 || iconv_fd != (iconv_t)-1)) {</a>
<a name="ln1027">                while (conv_restlen &gt; 0) {</a>
<a name="ln1028">                  *(--ptr) = (char)bad_char_behavior;</a>
<a name="ln1029">                  conv_restlen--;</a>
<a name="ln1030">                }</a>
<a name="ln1031">              }</a>
<a name="ln1032">              fio_flags = 0;  // don't convert this</a>
<a name="ln1033">              if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1034">                iconv_close(iconv_fd);</a>
<a name="ln1035">                iconv_fd = (iconv_t)-1;</a>
<a name="ln1036">              }</a>
<a name="ln1037">            }</a>
<a name="ln1038">          }</a>
<a name="ln1039">        }</a>
<a name="ln1040">      }</a>
<a name="ln1041"> </a>
<a name="ln1042">      skip_read = false;</a>
<a name="ln1043"> </a>
<a name="ln1044">      // At start of file: Check for BOM.</a>
<a name="ln1045">      // Also check for a BOM for other Unicode encodings, but not after</a>
<a name="ln1046">      // converting with 'charconvert' or when a BOM has already been</a>
<a name="ln1047">      // found.</a>
<a name="ln1048">      if ((filesize == 0)</a>
<a name="ln1049">          &amp;&amp; (fio_flags == FIO_UCSBOM</a>
<a name="ln1050">              || (!curbuf-&gt;b_p_bomb</a>
<a name="ln1051">                  &amp;&amp; tmpname == NULL</a>
<a name="ln1052">                  &amp;&amp; (*fenc == 'u' || *fenc == NUL)))) {</a>
<a name="ln1053">        char *ccname;</a>
<a name="ln1054">        int blen = 0;</a>
<a name="ln1055"> </a>
<a name="ln1056">        // no BOM detection in a short file or in binary mode</a>
<a name="ln1057">        if (size &lt; 2 || curbuf-&gt;b_p_bin) {</a>
<a name="ln1058">          ccname = NULL;</a>
<a name="ln1059">        } else {</a>
<a name="ln1060">          ccname = check_for_bom(ptr, (int)size, &amp;blen,</a>
<a name="ln1061">                                 fio_flags == FIO_UCSBOM ? FIO_ALL : get_fio_flags(fenc));</a>
<a name="ln1062">        }</a>
<a name="ln1063">        if (ccname != NULL) {</a>
<a name="ln1064">          // Remove BOM from the text</a>
<a name="ln1065">          filesize += blen;</a>
<a name="ln1066">          size -= blen;</a>
<a name="ln1067">          memmove(ptr, ptr + blen, (size_t)size);</a>
<a name="ln1068">          if (set_options) {</a>
<a name="ln1069">            curbuf-&gt;b_p_bomb = true;</a>
<a name="ln1070">            curbuf-&gt;b_start_bomb = true;</a>
<a name="ln1071">          }</a>
<a name="ln1072">        }</a>
<a name="ln1073"> </a>
<a name="ln1074">        if (fio_flags == FIO_UCSBOM) {</a>
<a name="ln1075">          if (ccname == NULL) {</a>
<a name="ln1076">            // No BOM detected: retry with next encoding.</a>
<a name="ln1077">            advance_fenc = true;</a>
<a name="ln1078">          } else {</a>
<a name="ln1079">            // BOM detected: set &quot;fenc&quot; and jump back</a>
<a name="ln1080">            if (fenc_alloced) {</a>
<a name="ln1081">              xfree(fenc);</a>
<a name="ln1082">            }</a>
<a name="ln1083">            fenc = ccname;</a>
<a name="ln1084">            fenc_alloced = false;</a>
<a name="ln1085">          }</a>
<a name="ln1086">          // retry reading without getting new bytes or rewinding</a>
<a name="ln1087">          skip_read = true;</a>
<a name="ln1088">          goto retry;</a>
<a name="ln1089">        }</a>
<a name="ln1090">      }</a>
<a name="ln1091"> </a>
<a name="ln1092">      // Include not converted bytes.</a>
<a name="ln1093">      ptr -= conv_restlen;</a>
<a name="ln1094">      size += conv_restlen;</a>
<a name="ln1095">      conv_restlen = 0;</a>
<a name="ln1096">      // Break here for a read error or end-of-file.</a>
<a name="ln1097">      if (size &lt;= 0) {</a>
<a name="ln1098">        break;</a>
<a name="ln1099">      }</a>
<a name="ln1100"> </a>
<a name="ln1101">      if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1102">        // Attempt conversion of the read bytes to 'encoding' using iconv().</a>
<a name="ln1103">        const char *fromp = ptr;</a>
<a name="ln1104">        size_t from_size = (size_t)size;</a>
<a name="ln1105">        ptr += size;</a>
<a name="ln1106">        char *top = ptr;</a>
<a name="ln1107">        size_t to_size = (size_t)(real_size - size);</a>
<a name="ln1108"> </a>
<a name="ln1109">        // If there is conversion error or not enough room try using</a>
<a name="ln1110">        // another conversion.  Except for when there is no</a>
<a name="ln1111">        // alternative (help files).</a>
<a name="ln1112">        while ((iconv(iconv_fd, (void *)&amp;fromp, &amp;from_size,</a>
<a name="ln1113">                      &amp;top, &amp;to_size)</a>
<a name="ln1114">                == (size_t)-1 &amp;&amp; ICONV_ERRNO != ICONV_EINVAL)</a>
<a name="ln1115">               || from_size &gt; CONV_RESTLEN) {</a>
<a name="ln1116">          if (can_retry) {</a>
<a name="ln1117">            goto rewind_retry;</a>
<a name="ln1118">          }</a>
<a name="ln1119">          if (conv_error == 0) {</a>
<a name="ln1120">            conv_error = readfile_linenr(linecnt, ptr, top);</a>
<a name="ln1121">          }</a>
<a name="ln1122"> </a>
<a name="ln1123">          // Deal with a bad byte and continue with the next.</a>
<a name="ln1124">          fromp++;</a>
<a name="ln1125">          from_size--;</a>
<a name="ln1126">          if (bad_char_behavior == BAD_KEEP) {</a>
<a name="ln1127">            *top++ = *(fromp - 1);</a>
<a name="ln1128">            to_size--;</a>
<a name="ln1129">          } else if (bad_char_behavior != BAD_DROP) {</a>
<a name="ln1130">            *top++ = (char)bad_char_behavior;</a>
<a name="ln1131">            to_size--;</a>
<a name="ln1132">          }</a>
<a name="ln1133">        }</a>
<a name="ln1134"> </a>
<a name="ln1135">        if (from_size &gt; 0) {</a>
<a name="ln1136">          // Some remaining characters, keep them for the next</a>
<a name="ln1137">          // round.</a>
<a name="ln1138">          memmove(conv_rest, fromp, from_size);</a>
<a name="ln1139">          conv_restlen = (int)from_size;</a>
<a name="ln1140">        }</a>
<a name="ln1141"> </a>
<a name="ln1142">        // move the linerest to before the converted characters</a>
<a name="ln1143">        line_start = ptr - linerest;</a>
<a name="ln1144">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1145">        size = (top - ptr);</a>
<a name="ln1146">      }</a>
<a name="ln1147"> </a>
<a name="ln1148">      if (fio_flags != 0) {</a>
<a name="ln1149">        unsigned u8c;</a>
<a name="ln1150">        char *dest;</a>
<a name="ln1151">        char *tail = NULL;</a>
<a name="ln1152"> </a>
<a name="ln1153">        // Convert Unicode or Latin1 to UTF-8.</a>
<a name="ln1154">        // Go from end to start through the buffer, because the number</a>
<a name="ln1155">        // of bytes may increase.</a>
<a name="ln1156">        // &quot;dest&quot; points to after where the UTF-8 bytes go, &quot;p&quot; points</a>
<a name="ln1157">        // to after the next character to convert.</a>
<a name="ln1158">        dest = ptr + real_size;</a>
<a name="ln1159">        if (fio_flags == FIO_LATIN1 || fio_flags == FIO_UTF8) {</a>
<a name="ln1160">          p = (uint8_t *)ptr + size;</a>
<a name="ln1161">          if (fio_flags == FIO_UTF8) {</a>
<a name="ln1162">            // Check for a trailing incomplete UTF-8 sequence</a>
<a name="ln1163">            tail = ptr + size - 1;</a>
<a name="ln1164">            while (tail &gt; ptr &amp;&amp; (*tail &amp; 0xc0) == 0x80) {</a>
<a name="ln1165">              tail--;</a>
<a name="ln1166">            }</a>
<a name="ln1167">            if (tail + utf_byte2len(*tail) &lt;= ptr + size) {</a>
<a name="ln1168">              tail = NULL;</a>
<a name="ln1169">            } else {</a>
<a name="ln1170">              p = (uint8_t *)tail;</a>
<a name="ln1171">            }</a>
<a name="ln1172">          }</a>
<a name="ln1173">        } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1174">          // Check for a trailing byte</a>
<a name="ln1175">          p = (uint8_t *)ptr + (size &amp; ~1);</a>
<a name="ln1176">          if (size &amp; 1) {</a>
<a name="ln1177">            tail = (char *)p;</a>
<a name="ln1178">          }</a>
<a name="ln1179">          if ((fio_flags &amp; FIO_UTF16) &amp;&amp; p &gt; (uint8_t *)ptr) {</a>
<a name="ln1180">            // Check for a trailing leading word</a>
<a name="ln1181">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1182">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1183">              u8c += *--p;</a>
<a name="ln1184">            } else {</a>
<a name="ln1185">              u8c = *--p;</a>
<a name="ln1186">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1187">            }</a>
<a name="ln1188">            if (u8c &gt;= 0xd800 &amp;&amp; u8c &lt;= 0xdbff) {</a>
<a name="ln1189">              tail = (char *)p;</a>
<a name="ln1190">            } else {</a>
<a name="ln1191">              p += 2;</a>
<a name="ln1192">            }</a>
<a name="ln1193">          }</a>
<a name="ln1194">        } else {   //  FIO_UCS4</a>
<a name="ln1195">                   // Check for trailing 1, 2 or 3 bytes</a>
<a name="ln1196">          p = (uint8_t *)ptr + (size &amp; ~3);</a>
<a name="ln1197">          if (size &amp; 3) {</a>
<a name="ln1198">            tail = (char *)p;</a>
<a name="ln1199">          }</a>
<a name="ln1200">        }</a>
<a name="ln1201"> </a>
<a name="ln1202">        // If there is a trailing incomplete sequence move it to</a>
<a name="ln1203">        // conv_rest[].</a>
<a name="ln1204">        if (tail != NULL) {</a>
<a name="ln1205">          conv_restlen = (int)((ptr + size) - tail);</a>
<a name="ln1206">          memmove(conv_rest, tail, (size_t)conv_restlen);</a>
<a name="ln1207">          size -= conv_restlen;</a>
<a name="ln1208">        }</a>
<a name="ln1209"> </a>
<a name="ln1210">        while (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1211">          if (fio_flags &amp; FIO_LATIN1) {</a>
<a name="ln1212">            u8c = *--p;</a>
<a name="ln1213">          } else if (fio_flags &amp; (FIO_UCS2 | FIO_UTF16)) {</a>
<a name="ln1214">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1215">              u8c = (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1216">              u8c += *--p;</a>
<a name="ln1217">            } else {</a>
<a name="ln1218">              u8c = *--p;</a>
<a name="ln1219">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1220">            }</a>
<a name="ln1221">            if ((fio_flags &amp; FIO_UTF16)</a>
<a name="ln1222">                &amp;&amp; u8c &gt;= 0xdc00 &amp;&amp; u8c &lt;= 0xdfff) {</a>
<a name="ln1223">              int u16c;</a>
<a name="ln1224"> </a>
<a name="ln1225">              if (p == (uint8_t *)ptr) {</a>
<a name="ln1226">                // Missing leading word.</a>
<a name="ln1227">                if (can_retry) {</a>
<a name="ln1228">                  goto rewind_retry;</a>
<a name="ln1229">                }</a>
<a name="ln1230">                if (conv_error == 0) {</a>
<a name="ln1231">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1232">                }</a>
<a name="ln1233">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1234">                  continue;</a>
<a name="ln1235">                }</a>
<a name="ln1236">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1237">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1238">                }</a>
<a name="ln1239">              }</a>
<a name="ln1240"> </a>
<a name="ln1241">              // found second word of double-word, get the first</a>
<a name="ln1242">              // word and compute the resulting character</a>
<a name="ln1243">              if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1244">                u16c = (*--p &lt;&lt; 8);</a>
<a name="ln1245">                u16c += *--p;</a>
<a name="ln1246">              } else {</a>
<a name="ln1247">                u16c = *--p;</a>
<a name="ln1248">                u16c += (*--p &lt;&lt; 8);</a>
<a name="ln1249">              }</a>
<a name="ln1250">              u8c = 0x10000 + (((unsigned)u16c &amp; 0x3ff) &lt;&lt; 10)</a>
<a name="ln1251">                    + (u8c &amp; 0x3ff);</a>
<a name="ln1252"> </a>
<a name="ln1253">              // Check if the word is indeed a leading word.</a>
<a name="ln1254">              if (u16c &lt; 0xd800 || u16c &gt; 0xdbff) {</a>
<a name="ln1255">                if (can_retry) {</a>
<a name="ln1256">                  goto rewind_retry;</a>
<a name="ln1257">                }</a>
<a name="ln1258">                if (conv_error == 0) {</a>
<a name="ln1259">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1260">                }</a>
<a name="ln1261">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1262">                  continue;</a>
<a name="ln1263">                }</a>
<a name="ln1264">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1265">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1266">                }</a>
<a name="ln1267">              }</a>
<a name="ln1268">            }</a>
<a name="ln1269">          } else if (fio_flags &amp; FIO_UCS4) {</a>
<a name="ln1270">            if (fio_flags &amp; FIO_ENDIAN_L) {</a>
<a name="ln1271">              u8c = (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1272">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1273">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1274">              u8c += *--p;</a>
<a name="ln1275">            } else {          // big endian</a>
<a name="ln1276">              u8c = *--p;</a>
<a name="ln1277">              u8c += (unsigned)(*--p) &lt;&lt; 8;</a>
<a name="ln1278">              u8c += (unsigned)(*--p) &lt;&lt; 16;</a>
<a name="ln1279">              u8c += (unsigned)(*--p) &lt;&lt; 24;</a>
<a name="ln1280">            }</a>
<a name="ln1281">            // Replace characters over INT_MAX with Unicode replacement character</a>
<a name="ln1282">            if (u8c &gt; INT_MAX) {</a>
<a name="ln1283">              u8c = 0xfffd;</a>
<a name="ln1284">            }</a>
<a name="ln1285">          } else {        // UTF-8</a>
<a name="ln1286">            if (*--p &lt; 0x80) {</a>
<a name="ln1287">              u8c = *p;</a>
<a name="ln1288">            } else {</a>
<a name="ln1289">              len = utf_head_off(ptr, (char *)p);</a>
<a name="ln1290">              p -= len;</a>
<a name="ln1291">              u8c = (unsigned)utf_ptr2char((char *)p);</a>
<a name="ln1292">              if (len == 0) {</a>
<a name="ln1293">                // Not a valid UTF-8 character, retry with</a>
<a name="ln1294">                // another fenc when possible, otherwise just</a>
<a name="ln1295">                // report the error.</a>
<a name="ln1296">                if (can_retry) {</a>
<a name="ln1297">                  goto rewind_retry;</a>
<a name="ln1298">                }</a>
<a name="ln1299">                if (conv_error == 0) {</a>
<a name="ln1300">                  conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1301">                }</a>
<a name="ln1302">                if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1303">                  continue;</a>
<a name="ln1304">                }</a>
<a name="ln1305">                if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1306">                  u8c = (unsigned)bad_char_behavior;</a>
<a name="ln1307">                }</a>
<a name="ln1308">              }</a>
<a name="ln1309">            }</a>
<a name="ln1310">          }</a>
<a name="ln1311">          assert(u8c &lt;= INT_MAX);</a>
<a name="ln1312">          // produce UTF-8</a>
<a name="ln1313">          dest -= utf_char2len((int)u8c);</a>
<a name="ln1314">          (void)utf_char2bytes((int)u8c, dest);</a>
<a name="ln1315">        }</a>
<a name="ln1316"> </a>
<a name="ln1317">        // move the linerest to before the converted characters</a>
<a name="ln1318">        line_start = dest - linerest;</a>
<a name="ln1319">        memmove(line_start, buffer, (size_t)linerest);</a>
<a name="ln1320">        size = ((ptr + real_size) - dest);</a>
<a name="ln1321">        ptr = dest;</a>
<a name="ln1322">      } else if (!curbuf-&gt;b_p_bin) {</a>
<a name="ln1323">        bool incomplete_tail = false;</a>
<a name="ln1324"> </a>
<a name="ln1325">        // Reading UTF-8: Check if the bytes are valid UTF-8.</a>
<a name="ln1326">        for (p = (uint8_t *)ptr;; p++) {</a>
<a name="ln1327">          int todo = (int)(((uint8_t *)ptr + size) - p);</a>
<a name="ln1328">          int l;</a>
<a name="ln1329"> </a>
<a name="ln1330">          if (todo &lt;= 0) {</a>
<a name="ln1331">            break;</a>
<a name="ln1332">          }</a>
<a name="ln1333">          if (*p &gt;= 0x80) {</a>
<a name="ln1334">            // A length of 1 means it's an illegal byte.  Accept</a>
<a name="ln1335">            // an incomplete character at the end though, the next</a>
<a name="ln1336">            // read() will get the next bytes, we'll check it</a>
<a name="ln1337">            // then.</a>
<a name="ln1338">            l = utf_ptr2len_len((char *)p, todo);</a>
<a name="ln1339">            if (l &gt; todo &amp;&amp; !incomplete_tail) {</a>
<a name="ln1340">              // Avoid retrying with a different encoding when</a>
<a name="ln1341">              // a truncated file is more likely, or attempting</a>
<a name="ln1342">              // to read the rest of an incomplete sequence when</a>
<a name="ln1343">              // we have already done so.</a>
<a name="ln1344">              if (p &gt; (uint8_t *)ptr || filesize &gt; 0) {</a>
<a name="ln1345">                incomplete_tail = true;</a>
<a name="ln1346">              }</a>
<a name="ln1347">              // Incomplete byte sequence, move it to conv_rest[]</a>
<a name="ln1348">              // and try to read the rest of it, unless we've</a>
<a name="ln1349">              // already done so.</a>
<a name="ln1350">              if (p &gt; (uint8_t *)ptr) {</a>
<a name="ln1351">                conv_restlen = todo;</a>
<a name="ln1352">                memmove(conv_rest, p, (size_t)conv_restlen);</a>
<a name="ln1353">                size -= conv_restlen;</a>
<a name="ln1354">                break;</a>
<a name="ln1355">              }</a>
<a name="ln1356">            }</a>
<a name="ln1357">            if (l == 1 || l &gt; todo) {</a>
<a name="ln1358">              // Illegal byte.  If we can try another encoding</a>
<a name="ln1359">              // do that, unless at EOF where a truncated</a>
<a name="ln1360">              // file is more likely than a conversion error.</a>
<a name="ln1361">              if (can_retry &amp;&amp; !incomplete_tail) {</a>
<a name="ln1362">                break;</a>
<a name="ln1363">              }</a>
<a name="ln1364"> </a>
<a name="ln1365">              // When we did a conversion report an error.</a>
<a name="ln1366">              if (iconv_fd != (iconv_t)-1 &amp;&amp; conv_error == 0) {</a>
<a name="ln1367">                conv_error = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1368">              }</a>
<a name="ln1369"> </a>
<a name="ln1370">              // Remember the first linenr with an illegal byte</a>
<a name="ln1371">              if (conv_error == 0 &amp;&amp; illegal_byte == 0) {</a>
<a name="ln1372">                illegal_byte = readfile_linenr(linecnt, ptr, (char *)p);</a>
<a name="ln1373">              }</a>
<a name="ln1374"> </a>
<a name="ln1375">              // Drop, keep or replace the bad byte.</a>
<a name="ln1376">              if (bad_char_behavior == BAD_DROP) {</a>
<a name="ln1377">                memmove(p, p + 1, (size_t)(todo - 1));</a>
<a name="ln1378">                p--;</a>
<a name="ln1379">                size--;</a>
<a name="ln1380">              } else if (bad_char_behavior != BAD_KEEP) {</a>
<a name="ln1381">                *p = (uint8_t)bad_char_behavior;</a>
<a name="ln1382">              }</a>
<a name="ln1383">            } else {</a>
<a name="ln1384">              p += l - 1;</a>
<a name="ln1385">            }</a>
<a name="ln1386">          }</a>
<a name="ln1387">        }</a>
<a name="ln1388">        if (p &lt; (uint8_t *)ptr + size &amp;&amp; !incomplete_tail) {</a>
<a name="ln1389">          // Detected a UTF-8 error.</a>
<a name="ln1390">rewind_retry:</a>
<a name="ln1391">          // Retry reading with another conversion.</a>
<a name="ln1392">          if (*p_ccv != NUL &amp;&amp; iconv_fd != (iconv_t)-1) {</a>
<a name="ln1393">            // iconv() failed, try 'charconvert'</a>
<a name="ln1394">            did_iconv = true;</a>
<a name="ln1395">          } else {</a>
<a name="ln1396">            // use next item from 'fileencodings'</a>
<a name="ln1397">            advance_fenc = true;</a>
<a name="ln1398">          }</a>
<a name="ln1399">          file_rewind = true;</a>
<a name="ln1400">          goto retry;</a>
<a name="ln1401">        }</a>
<a name="ln1402">      }</a>
<a name="ln1403"> </a>
<a name="ln1404">      // count the number of characters (after conversion!)</a>
<a name="ln1405">      filesize += size;</a>
<a name="ln1406"> </a>
<a name="ln1407">      // when reading the first part of a file: guess EOL type</a>
<a name="ln1408">      if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1409">        // First try finding a NL, for Dos and Unix</a>
<a name="ln1410">        if (try_dos || try_unix) {</a>
<a name="ln1411">          // Reset the carriage return counter.</a>
<a name="ln1412">          if (try_mac) {</a>
<a name="ln1413">            try_mac = 1;</a>
<a name="ln1414">          }</a>
<a name="ln1415"> </a>
<a name="ln1416">          for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1417">            if (*p == NL) {</a>
<a name="ln1418">              if (!try_unix</a>
<a name="ln1419">                  || (try_dos &amp;&amp; p &gt; (uint8_t *)ptr &amp;&amp; p[-1] == CAR)) {</a>
<a name="ln1420">                fileformat = EOL_DOS;</a>
<a name="ln1421">              } else {</a>
<a name="ln1422">                fileformat = EOL_UNIX;</a>
<a name="ln1423">              }</a>
<a name="ln1424">              break;</a>
<a name="ln1425">            } else if (*p == CAR &amp;&amp; try_mac) {</a>
<a name="ln1426">              try_mac++;</a>
<a name="ln1427">            }</a>
<a name="ln1428">          }</a>
<a name="ln1429"> </a>
<a name="ln1430">          // Don't give in to EOL_UNIX if EOL_MAC is more likely</a>
<a name="ln1431">          if (fileformat == EOL_UNIX &amp;&amp; try_mac) {</a>
<a name="ln1432">            // Need to reset the counters when retrying fenc.</a>
<a name="ln1433">            try_mac = 1;</a>
<a name="ln1434">            try_unix = 1;</a>
<a name="ln1435">            for (; p &gt;= (uint8_t *)ptr &amp;&amp; *p != CAR; p--) {}</a>
<a name="ln1436">            if (p &gt;= (uint8_t *)ptr) {</a>
<a name="ln1437">              for (p = (uint8_t *)ptr; p &lt; (uint8_t *)ptr + size; p++) {</a>
<a name="ln1438">                if (*p == NL) {</a>
<a name="ln1439">                  try_unix++;</a>
<a name="ln1440">                } else if (*p == CAR) {</a>
<a name="ln1441">                  try_mac++;</a>
<a name="ln1442">                }</a>
<a name="ln1443">              }</a>
<a name="ln1444">              if (try_mac &gt; try_unix) {</a>
<a name="ln1445">                fileformat = EOL_MAC;</a>
<a name="ln1446">              }</a>
<a name="ln1447">            }</a>
<a name="ln1448">          } else if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac == 1) {</a>
<a name="ln1449">            // Looking for CR but found no end-of-line markers at all:</a>
<a name="ln1450">            // use the default format.</a>
<a name="ln1451">            fileformat = default_fileformat();</a>
<a name="ln1452">          }</a>
<a name="ln1453">        }</a>
<a name="ln1454"> </a>
<a name="ln1455">        // No NL found: may use Mac format</a>
<a name="ln1456">        if (fileformat == EOL_UNKNOWN &amp;&amp; try_mac) {</a>
<a name="ln1457">          fileformat = EOL_MAC;</a>
<a name="ln1458">        }</a>
<a name="ln1459"> </a>
<a name="ln1460">        // Still nothing found?  Use first format in 'ffs'</a>
<a name="ln1461">        if (fileformat == EOL_UNKNOWN) {</a>
<a name="ln1462">          fileformat = default_fileformat();</a>
<a name="ln1463">        }</a>
<a name="ln1464"> </a>
<a name="ln1465">        // May set 'p_ff' if editing a new file.</a>
<a name="ln1466">        if (set_options) {</a>
<a name="ln1467">          set_fileformat(fileformat, OPT_LOCAL);</a>
<a name="ln1468">        }</a>
<a name="ln1469">      }</a>
<a name="ln1470">    }</a>
<a name="ln1471"> </a>
<a name="ln1472">    // This loop is executed once for every character read.</a>
<a name="ln1473">    // Keep it fast!</a>
<a name="ln1474">    if (fileformat == EOL_MAC) {</a>
<a name="ln1475">      ptr--;</a>
<a name="ln1476">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1477">        // catch most common case first</a>
<a name="ln1478">        if ((c = *ptr) != NUL &amp;&amp; c != CAR &amp;&amp; c != NL) {</a>
<a name="ln1479">          continue;</a>
<a name="ln1480">        }</a>
<a name="ln1481">        if (c == NUL) {</a>
<a name="ln1482">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1483">        } else if (c == NL) {</a>
<a name="ln1484">          *ptr = CAR;           // NLs are replaced by CRs!</a>
<a name="ln1485">        } else {</a>
<a name="ln1486">          if (skip_count == 0) {</a>
<a name="ln1487">            *ptr = NUL;                     // end of line</a>
<a name="ln1488">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1489">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1490">              error = true;</a>
<a name="ln1491">              break;</a>
<a name="ln1492">            }</a>
<a name="ln1493">            if (read_undo_file) {</a>
<a name="ln1494">              sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1495">            }</a>
<a name="ln1496">            lnum++;</a>
<a name="ln1497">            if (--read_count == 0) {</a>
<a name="ln1498">              error = true;                     // break loop</a>
<a name="ln1499">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1500">              break;</a>
<a name="ln1501">            }</a>
<a name="ln1502">          } else {</a>
<a name="ln1503">            skip_count--;</a>
<a name="ln1504">          }</a>
<a name="ln1505">          line_start = ptr + 1;</a>
<a name="ln1506">        }</a>
<a name="ln1507">      }</a>
<a name="ln1508">    } else {</a>
<a name="ln1509">      ptr--;</a>
<a name="ln1510">      while (++ptr, --size &gt;= 0) {</a>
<a name="ln1511">        if ((c = *ptr) != NUL &amp;&amp; c != NL) {        // catch most common case</a>
<a name="ln1512">          continue;</a>
<a name="ln1513">        }</a>
<a name="ln1514">        if (c == NUL) {</a>
<a name="ln1515">          *ptr = NL;            // NULs are replaced by newlines!</a>
<a name="ln1516">        } else {</a>
<a name="ln1517">          if (skip_count == 0) {</a>
<a name="ln1518">            *ptr = NUL;                         // end of line</a>
<a name="ln1519">            len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1520">            if (fileformat == EOL_DOS) {</a>
<a name="ln1521">              if (ptr &gt; line_start &amp;&amp; ptr[-1] == CAR) {</a>
<a name="ln1522">                // remove CR before NL</a>
<a name="ln1523">                ptr[-1] = NUL;</a>
<a name="ln1524">                len--;</a>
<a name="ln1525">              } else if (ff_error != EOL_DOS) {</a>
<a name="ln1526">                // Reading in Dos format, but no CR-LF found!</a>
<a name="ln1527">                // When 'fileformats' includes &quot;unix&quot;, delete all</a>
<a name="ln1528">                // the lines read so far and start all over again.</a>
<a name="ln1529">                // Otherwise give an error message later.</a>
<a name="ln1530">                if (try_unix</a>
<a name="ln1531">                    &amp;&amp; !read_stdin</a>
<a name="ln1532">                    &amp;&amp; (read_buffer</a>
<a name="ln1533">                        || vim_lseek(fd, (off_T)0L, SEEK_SET) == 0)) {</a>
<a name="ln1534">                  fileformat = EOL_UNIX;</a>
<a name="ln1535">                  if (set_options) {</a>
<a name="ln1536">                    set_fileformat(EOL_UNIX, OPT_LOCAL);</a>
<a name="ln1537">                  }</a>
<a name="ln1538">                  file_rewind = true;</a>
<a name="ln1539">                  keep_fileformat = true;</a>
<a name="ln1540">                  goto retry;</a>
<a name="ln1541">                }</a>
<a name="ln1542">                ff_error = EOL_DOS;</a>
<a name="ln1543">              }</a>
<a name="ln1544">            }</a>
<a name="ln1545">            if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1546">              error = true;</a>
<a name="ln1547">              break;</a>
<a name="ln1548">            }</a>
<a name="ln1549">            if (read_undo_file) {</a>
<a name="ln1550">              sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1551">            }</a>
<a name="ln1552">            lnum++;</a>
<a name="ln1553">            if (--read_count == 0) {</a>
<a name="ln1554">              error = true;                         // break loop</a>
<a name="ln1555">              line_start = ptr;                 // nothing left to write</a>
<a name="ln1556">              break;</a>
<a name="ln1557">            }</a>
<a name="ln1558">          } else {</a>
<a name="ln1559">            skip_count--;</a>
<a name="ln1560">          }</a>
<a name="ln1561">          line_start = ptr + 1;</a>
<a name="ln1562">        }</a>
<a name="ln1563">      }</a>
<a name="ln1564">    }</a>
<a name="ln1565">    linerest = (ptr - line_start);</a>
<a name="ln1566">    os_breakcheck();</a>
<a name="ln1567">  }</a>
<a name="ln1568"> </a>
<a name="ln1569">failed:</a>
<a name="ln1570">  // not an error, max. number of lines reached</a>
<a name="ln1571">  if (error &amp;&amp; read_count == 0) {</a>
<a name="ln1572">    error = false;</a>
<a name="ln1573">  }</a>
<a name="ln1574"> </a>
<a name="ln1575">  // In Dos format ignore a trailing CTRL-Z, unless 'binary' is set.</a>
<a name="ln1576">  // In old days the file length was in sector count and the CTRL-Z the</a>
<a name="ln1577">  // marker where the file really ended.  Assuming we write it to a file</a>
<a name="ln1578">  // system that keeps file length properly the CTRL-Z should be dropped.</a>
<a name="ln1579">  // Set the 'endoffile' option so the user can decide what to write later.</a>
<a name="ln1580">  // In Unix format the CTRL-Z is just another character.</a>
<a name="ln1581">  if (linerest != 0</a>
<a name="ln1582">      &amp;&amp; !curbuf-&gt;b_p_bin</a>
<a name="ln1583">      &amp;&amp; fileformat == EOL_DOS</a>
<a name="ln1584">      &amp;&amp; ptr[-1] == Ctrl_Z) {</a>
<a name="ln1585">    ptr--;</a>
<a name="ln1586">    linerest--;</a>
<a name="ln1587">    if (set_options) {</a>
<a name="ln1588">      curbuf-&gt;b_p_eof = true;</a>
<a name="ln1589">    }</a>
<a name="ln1590">  }</a>
<a name="ln1591"> </a>
<a name="ln1592">  // If we get EOF in the middle of a line, note the fact and</a>
<a name="ln1593">  // complete the line ourselves.</a>
<a name="ln1594">  if (!error</a>
<a name="ln1595">      &amp;&amp; !got_int</a>
<a name="ln1596">      &amp;&amp; linerest != 0) {</a>
<a name="ln1597">    // remember for when writing</a>
<a name="ln1598">    if (set_options) {</a>
<a name="ln1599">      curbuf-&gt;b_p_eol = false;</a>
<a name="ln1600">    }</a>
<a name="ln1601">    *ptr = NUL;</a>
<a name="ln1602">    len = (colnr_T)(ptr - line_start + 1);</a>
<a name="ln1603">    if (ml_append(lnum, line_start, len, newfile) == FAIL) {</a>
<a name="ln1604">      error = true;</a>
<a name="ln1605">    } else {</a>
<a name="ln1606">      if (read_undo_file) {</a>
<a name="ln1607">        sha256_update(&amp;sha_ctx, (uint8_t *)line_start, (size_t)len);</a>
<a name="ln1608">      }</a>
<a name="ln1609">      read_no_eol_lnum = ++lnum;</a>
<a name="ln1610">    }</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613">  if (set_options) {</a>
<a name="ln1614">    // Remember the current file format.</a>
<a name="ln1615">    save_file_ff(curbuf);</a>
<a name="ln1616">    // If editing a new file: set 'fenc' for the current buffer.</a>
<a name="ln1617">    // Also for &quot;:read ++edit file&quot;.</a>
<a name="ln1618">    set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE | OPT_LOCAL, 0);</a>
<a name="ln1619">  }</a>
<a name="ln1620">  if (fenc_alloced) {</a>
<a name="ln1621">    xfree(fenc);</a>
<a name="ln1622">  }</a>
<a name="ln1623">  if (iconv_fd != (iconv_t)-1) {</a>
<a name="ln1624">    iconv_close(iconv_fd);</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  if (!read_buffer &amp;&amp; !read_stdin) {</a>
<a name="ln1628">    close(fd);  // errors are ignored</a>
<a name="ln1629">  } else {</a>
<a name="ln1630">    (void)os_set_cloexec(fd);</a>
<a name="ln1631">  }</a>
<a name="ln1632">  xfree(buffer);</a>
<a name="ln1633"> </a>
<a name="ln1634">  if (read_stdin) {</a>
<a name="ln1635">    close(fd);</a>
<a name="ln1636">    if (stdin_fd &lt; 0) {</a>
<a name="ln1637">#ifndef MSWIN</a>
<a name="ln1638">      // On Unix, use stderr for stdin, makes shell commands work.</a>
<a name="ln1639">      vim_ignored = dup(2);</a>
<a name="ln1640">#else</a>
<a name="ln1641">      // On Windows, use the console input handle for stdin.</a>
<a name="ln1642">      HANDLE conin = CreateFile(&quot;CONIN$&quot;, GENERIC_READ | GENERIC_WRITE,</a>
<a name="ln1643">                                FILE_SHARE_READ, (LPSECURITY_ATTRIBUTES)NULL,</a>
<a name="ln1644">                                OPEN_EXISTING, 0, (HANDLE)NULL);</a>
<a name="ln1645">      vim_ignored = _open_osfhandle((intptr_t)conin, _O_RDONLY);</a>
<a name="ln1646">#endif</a>
<a name="ln1647">    }</a>
<a name="ln1648">  }</a>
<a name="ln1649"> </a>
<a name="ln1650">  if (tmpname != NULL) {</a>
<a name="ln1651">    os_remove(tmpname);  // delete converted file</a>
<a name="ln1652">    xfree(tmpname);</a>
<a name="ln1653">  }</a>
<a name="ln1654">  no_wait_return--;                     // may wait for return now</a>
<a name="ln1655"> </a>
<a name="ln1656">  // In recovery mode everything but autocommands is skipped.</a>
<a name="ln1657">  if (!recoverymode) {</a>
<a name="ln1658">    // need to delete the last line, which comes from the empty buffer</a>
<a name="ln1659">    if (newfile &amp;&amp; wasempty &amp;&amp; !(curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY)) {</a>
<a name="ln1660">      ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln1661">      linecnt--;</a>
<a name="ln1662">    }</a>
<a name="ln1663">    curbuf-&gt;deleted_bytes = 0;</a>
<a name="ln1664">    curbuf-&gt;deleted_bytes2 = 0;</a>
<a name="ln1665">    curbuf-&gt;deleted_codepoints = 0;</a>
<a name="ln1666">    curbuf-&gt;deleted_codeunits = 0;</a>
<a name="ln1667">    linecnt = curbuf-&gt;b_ml.ml_line_count - linecnt;</a>
<a name="ln1668">    if (filesize == 0) {</a>
<a name="ln1669">      linecnt = 0;</a>
<a name="ln1670">    }</a>
<a name="ln1671">    if (newfile || read_buffer) {</a>
<a name="ln1672">      redraw_curbuf_later(UPD_NOT_VALID);</a>
<a name="ln1673">      // After reading the text into the buffer the diff info needs to</a>
<a name="ln1674">      // be updated.</a>
<a name="ln1675">      diff_invalidate(curbuf);</a>
<a name="ln1676">      // All folds in the window are invalid now.  Mark them for update</a>
<a name="ln1677">      // before triggering autocommands.</a>
<a name="ln1678">      foldUpdateAll(curwin);</a>
<a name="ln1679">    } else if (linecnt) {               // appended at least one line</a>
<a name="ln1680">      appended_lines_mark(from, linecnt);</a>
<a name="ln1681">    }</a>
<a name="ln1682"> </a>
<a name="ln1683">    if (got_int) {</a>
<a name="ln1684">      if (!(flags &amp; READ_DUMMY)) {</a>
<a name="ln1685">        filemess(curbuf, sfname, _(e_interr), 0);</a>
<a name="ln1686">        if (newfile) {</a>
<a name="ln1687">          curbuf-&gt;b_p_ro = true;                // must use &quot;w!&quot; now</a>
<a name="ln1688">        }</a>
<a name="ln1689">      }</a>
<a name="ln1690">      msg_scroll = msg_save;</a>
<a name="ln1691">      check_marks_read();</a>
<a name="ln1692">      retval = OK;        // an interrupt isn't really an error</a>
<a name="ln1693">      goto theend;</a>
<a name="ln1694">    }</a>
<a name="ln1695"> </a>
<a name="ln1696">    if (!filtering &amp;&amp; !(flags &amp; READ_DUMMY) &amp;&amp; !silent) {</a>
<a name="ln1697">      add_quoted_fname(IObuff, IOSIZE, curbuf, sfname);</a>
<a name="ln1698">      c = false;</a>
<a name="ln1699"> </a>
<a name="ln1700">#ifdef UNIX</a>
<a name="ln1701">      if (S_ISFIFO(perm)) {             // fifo</a>
<a name="ln1702">        xstrlcat(IObuff, _(&quot;[fifo]&quot;), IOSIZE);</a>
<a name="ln1703">        c = true;</a>
<a name="ln1704">      }</a>
<a name="ln1705">      if (S_ISSOCK(perm)) {            // or socket</a>
<a name="ln1706">        xstrlcat(IObuff, _(&quot;[socket]&quot;), IOSIZE);</a>
<a name="ln1707">        c = true;</a>
<a name="ln1708">      }</a>
<a name="ln1709"># ifdef OPEN_CHR_FILES</a>
<a name="ln1710">      if (S_ISCHR(perm)) {                          // or character special</a>
<a name="ln1711">        xstrlcat(IObuff, _(&quot;[character special]&quot;), IOSIZE);</a>
<a name="ln1712">        c = true;</a>
<a name="ln1713">      }</a>
<a name="ln1714"># endif</a>
<a name="ln1715">#endif</a>
<a name="ln1716">      if (curbuf-&gt;b_p_ro) {</a>
<a name="ln1717">        xstrlcat(IObuff, shortmess(SHM_RO) ? _(&quot;[RO]&quot;) : _(&quot;[readonly]&quot;), IOSIZE);</a>
<a name="ln1718">        c = true;</a>
<a name="ln1719">      }</a>
<a name="ln1720">      if (read_no_eol_lnum) {</a>
<a name="ln1721">        xstrlcat(IObuff, _(&quot;[noeol]&quot;), IOSIZE);</a>
<a name="ln1722">        c = true;</a>
<a name="ln1723">      }</a>
<a name="ln1724">      if (ff_error == EOL_DOS) {</a>
<a name="ln1725">        xstrlcat(IObuff, _(&quot;[CR missing]&quot;), IOSIZE);</a>
<a name="ln1726">        c = true;</a>
<a name="ln1727">      }</a>
<a name="ln1728">      if (split) {</a>
<a name="ln1729">        xstrlcat(IObuff, _(&quot;[long lines split]&quot;), IOSIZE);</a>
<a name="ln1730">        c = true;</a>
<a name="ln1731">      }</a>
<a name="ln1732">      if (notconverted) {</a>
<a name="ln1733">        xstrlcat(IObuff, _(&quot;[NOT converted]&quot;), IOSIZE);</a>
<a name="ln1734">        c = true;</a>
<a name="ln1735">      } else if (converted) {</a>
<a name="ln1736">        xstrlcat(IObuff, _(&quot;[converted]&quot;), IOSIZE);</a>
<a name="ln1737">        c = true;</a>
<a name="ln1738">      }</a>
<a name="ln1739">      if (conv_error != 0) {</a>
<a name="ln1740">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1741">                 _(&quot;[CONVERSION ERROR in line %&quot; PRId64 &quot;]&quot;), (int64_t)conv_error);</a>
<a name="ln1742">        c = true;</a>
<a name="ln1743">      } else if (illegal_byte &gt; 0) {</a>
<a name="ln1744">        snprintf(IObuff + strlen(IObuff), IOSIZE - strlen(IObuff),</a>
<a name="ln1745">                 _(&quot;[ILLEGAL BYTE in line %&quot; PRId64 &quot;]&quot;), (int64_t)illegal_byte);</a>
<a name="ln1746">        c = true;</a>
<a name="ln1747">      } else if (error) {</a>
<a name="ln1748">        xstrlcat(IObuff, _(&quot;[READ ERRORS]&quot;), IOSIZE);</a>
<a name="ln1749">        c = true;</a>
<a name="ln1750">      }</a>
<a name="ln1751">      if (msg_add_fileformat(fileformat)) {</a>
<a name="ln1752">        c = true;</a>
<a name="ln1753">      }</a>
<a name="ln1754"> </a>
<a name="ln1755">      msg_add_lines(c, (long)linecnt, filesize);</a>
<a name="ln1756"> </a>
<a name="ln1757">      XFREE_CLEAR(keep_msg);</a>
<a name="ln1758">      p = NULL;</a>
<a name="ln1759">      msg_scrolled_ign = true;</a>
<a name="ln1760"> </a>
<a name="ln1761">      if (!read_stdin &amp;&amp; !read_buffer) {</a>
<a name="ln1762">        if (msg_col &gt; 0) {</a>
<a name="ln1763">          msg_putchar('\r');  // overwrite previous message</a>
<a name="ln1764">        }</a>
<a name="ln1765">        p = (uint8_t *)msg_trunc_attr(IObuff, false, 0);</a>
<a name="ln1766">      }</a>
<a name="ln1767"> </a>
<a name="ln1768">      if (read_stdin || read_buffer || restart_edit != 0</a>
<a name="ln1769">          || (msg_scrolled != 0 &amp;&amp; !need_wait_return)) {</a>
<a name="ln1770">        // Need to repeat the message after redrawing when:</a>
<a name="ln1771">        // - When reading from stdin (the screen will be cleared next).</a>
<a name="ln1772">        // - When restart_edit is set (otherwise there will be a delay before</a>
<a name="ln1773">        //   redrawing).</a>
<a name="ln1774">        // - When the screen was scrolled but there is no wait-return prompt.</a>
<a name="ln1775">        set_keep_msg((char *)p, 0);</a>
<a name="ln1776">      }</a>
<a name="ln1777">      msg_scrolled_ign = false;</a>
<a name="ln1778">    }</a>
<a name="ln1779"> </a>
<a name="ln1780">    // with errors writing the file requires &quot;:w!&quot;</a>
<a name="ln1781">    if (newfile &amp;&amp; (error</a>
<a name="ln1782">                    || conv_error != 0</a>
<a name="ln1783">                    || (illegal_byte &gt; 0 &amp;&amp; bad_char_behavior != BAD_KEEP))) {</a>
<a name="ln1784">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln1785">    }</a>
<a name="ln1786"> </a>
<a name="ln1787">    u_clearline(curbuf);   // cannot use &quot;U&quot; command after adding lines</a>
<a name="ln1788"> </a>
<a name="ln1789">    // In Ex mode: cursor at last new line.</a>
<a name="ln1790">    // Otherwise: cursor at first new line.</a>
<a name="ln1791">    if (exmode_active) {</a>
<a name="ln1792">      curwin-&gt;w_cursor.lnum = from + linecnt;</a>
<a name="ln1793">    } else {</a>
<a name="ln1794">      curwin-&gt;w_cursor.lnum = from + 1;</a>
<a name="ln1795">    }</a>
<a name="ln1796">    check_cursor_lnum(curwin);</a>
<a name="ln1797">    beginline(BL_WHITE | BL_FIX);           // on first non-blank</a>
<a name="ln1798"> </a>
<a name="ln1799">    if ((cmdmod.cmod_flags &amp; CMOD_LOCKMARKS) == 0) {</a>
<a name="ln1800">      // Set '[ and '] marks to the newly read lines.</a>
<a name="ln1801">      curbuf-&gt;b_op_start.lnum = from + 1;</a>
<a name="ln1802">      curbuf-&gt;b_op_start.col = 0;</a>
<a name="ln1803">      curbuf-&gt;b_op_end.lnum = from + linecnt;</a>
<a name="ln1804">      curbuf-&gt;b_op_end.col = 0;</a>
<a name="ln1805">    }</a>
<a name="ln1806">  }</a>
<a name="ln1807">  msg_scroll = msg_save;</a>
<a name="ln1808"> </a>
<a name="ln1809">  // Get the marks before executing autocommands, so they can be used there.</a>
<a name="ln1810">  check_marks_read();</a>
<a name="ln1811"> </a>
<a name="ln1812">  // We remember if the last line of the read didn't have</a>
<a name="ln1813">  // an eol even when 'binary' is off, to support turning 'fixeol' off,</a>
<a name="ln1814">  // or writing the read again with 'binary' on.  The latter is required</a>
<a name="ln1815">  // for &quot;:autocmd FileReadPost *.gz set bin|'[,']!gunzip&quot; to work.</a>
<a name="ln1816">  curbuf-&gt;b_no_eol_lnum = read_no_eol_lnum;</a>
<a name="ln1817"> </a>
<a name="ln1818">  // When reloading a buffer put the cursor at the first line that is</a>
<a name="ln1819">  // different.</a>
<a name="ln1820">  if (flags &amp; READ_KEEP_UNDO) {</a>
<a name="ln1821">    u_find_first_changed();</a>
<a name="ln1822">  }</a>
<a name="ln1823"> </a>
<a name="ln1824">  // When opening a new file locate undo info and read it.</a>
<a name="ln1825">  if (read_undo_file) {</a>
<a name="ln1826">    uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln1827"> </a>
<a name="ln1828">    sha256_finish(&amp;sha_ctx, hash);</a>
<a name="ln1829">    u_read_undo(NULL, hash, fname);</a>
<a name="ln1830">  }</a>
<a name="ln1831"> </a>
<a name="ln1832">  if (!read_stdin &amp;&amp; !read_fifo &amp;&amp; (!read_buffer || sfname != NULL)) {</a>
<a name="ln1833">    int m = msg_scroll;</a>
<a name="ln1834">    int n = msg_scrolled;</a>
<a name="ln1835"> </a>
<a name="ln1836">    // Save the fileformat now, otherwise the buffer will be considered</a>
<a name="ln1837">    // modified if the format/encoding was automatically detected.</a>
<a name="ln1838">    if (set_options) {</a>
<a name="ln1839">      save_file_ff(curbuf);</a>
<a name="ln1840">    }</a>
<a name="ln1841"> </a>
<a name="ln1842">    // The output from the autocommands should not overwrite anything and</a>
<a name="ln1843">    // should not be overwritten: Set msg_scroll, restore its value if no</a>
<a name="ln1844">    // output was done.</a>
<a name="ln1845">    msg_scroll = true;</a>
<a name="ln1846">    if (filtering) {</a>
<a name="ln1847">      apply_autocmds_exarg(EVENT_FILTERREADPOST, NULL, sfname,</a>
<a name="ln1848">                           false, curbuf, eap);</a>
<a name="ln1849">    } else if (newfile || (read_buffer &amp;&amp; sfname != NULL)) {</a>
<a name="ln1850">      apply_autocmds_exarg(EVENT_BUFREADPOST, NULL, sfname,</a>
<a name="ln1851">                           false, curbuf, eap);</a>
<a name="ln1852">      if (!au_did_filetype &amp;&amp; *curbuf-&gt;b_p_ft != NUL) {</a>
<a name="ln1853">        // EVENT_FILETYPE was not triggered but the buffer already has a</a>
<a name="ln1854">        // filetype.  Trigger EVENT_FILETYPE using the existing filetype.</a>
<a name="ln1855">        apply_autocmds(EVENT_FILETYPE, curbuf-&gt;b_p_ft, curbuf-&gt;b_fname, true, curbuf);</a>
<a name="ln1856">      }</a>
<a name="ln1857">    } else {</a>
<a name="ln1858">      apply_autocmds_exarg(EVENT_FILEREADPOST, sfname, sfname,</a>
<a name="ln1859">                           false, NULL, eap);</a>
<a name="ln1860">    }</a>
<a name="ln1861">    if (msg_scrolled == n) {</a>
<a name="ln1862">      msg_scroll = m;</a>
<a name="ln1863">    }</a>
<a name="ln1864">    if (aborting()) {       // autocmds may abort script processing</a>
<a name="ln1865">      return FAIL;</a>
<a name="ln1866">    }</a>
<a name="ln1867">  }</a>
<a name="ln1868"> </a>
<a name="ln1869">  if (!(recoverymode &amp;&amp; error)) {</a>
<a name="ln1870">    retval = OK;</a>
<a name="ln1871">  }</a>
<a name="ln1872"> </a>
<a name="ln1873">theend:</a>
<a name="ln1874">  if (curbuf-&gt;b_ml.ml_mfp != NULL</a>
<a name="ln1875">      &amp;&amp; curbuf-&gt;b_ml.ml_mfp-&gt;mf_dirty == MF_DIRTY_YES_NOSYNC) {</a>
<a name="ln1876">    // OK to sync the swap file now</a>
<a name="ln1877">    curbuf-&gt;b_ml.ml_mfp-&gt;mf_dirty = MF_DIRTY_YES;</a>
<a name="ln1878">  }</a>
<a name="ln1879"> </a>
<a name="ln1880">  return retval;</a>
<a name="ln1881">}</a>
<a name="ln1882"> </a>
<a name="ln1883">#ifdef OPEN_CHR_FILES</a>
<a name="ln1884">/// Returns true if the file name argument is of the form &quot;/dev/fd/\d\+&quot;,</a>
<a name="ln1885">/// which is the name of files used for process substitution output by</a>
<a name="ln1886">/// some shells on some operating systems, e.g., bash on SunOS.</a>
<a name="ln1887">/// Do not accept &quot;/dev/fd/[012]&quot;, opening these may hang Vim.</a>
<a name="ln1888">///</a>
<a name="ln1889">/// @param fname file name to check</a>
<a name="ln1890">bool is_dev_fd_file(char *fname)</a>
<a name="ln1891">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1892">{</a>
<a name="ln1893">  return strncmp(fname, &quot;/dev/fd/&quot;, 8) == 0</a>
<a name="ln1894">         &amp;&amp; ascii_isdigit((uint8_t)fname[8])</a>
<a name="ln1895">         &amp;&amp; *skipdigits(fname + 9) == NUL</a>
<a name="ln1896">         &amp;&amp; (fname[9] != NUL</a>
<a name="ln1897">             || (fname[8] != '0' &amp;&amp; fname[8] != '1' &amp;&amp; fname[8] != '2'));</a>
<a name="ln1898">}</a>
<a name="ln1899">#endif</a>
<a name="ln1900"> </a>
<a name="ln1901">/// From the current line count and characters read after that, estimate the</a>
<a name="ln1902">/// line number where we are now.</a>
<a name="ln1903">/// Used for error messages that include a line number.</a>
<a name="ln1904">///</a>
<a name="ln1905">/// @param linecnt  line count before reading more bytes</a>
<a name="ln1906">/// @param p        start of more bytes read</a>
<a name="ln1907">/// @param endp     end of more bytes read</a>
<a name="ln1908">static linenr_T readfile_linenr(linenr_T linecnt, char *p, const char *endp)</a>
<a name="ln1909">{</a>
<a name="ln1910">  char *s;</a>
<a name="ln1911">  linenr_T lnum;</a>
<a name="ln1912"> </a>
<a name="ln1913">  lnum = curbuf-&gt;b_ml.ml_line_count - linecnt + 1;</a>
<a name="ln1914">  for (s = p; s &lt; endp; s++) {</a>
<a name="ln1915">    if (*s == '\n') {</a>
<a name="ln1916">      lnum++;</a>
<a name="ln1917">    }</a>
<a name="ln1918">  }</a>
<a name="ln1919">  return lnum;</a>
<a name="ln1920">}</a>
<a name="ln1921"> </a>
<a name="ln1922">/// Fill &quot;*eap&quot; to force the 'fileencoding', 'fileformat' and 'binary' to be</a>
<a name="ln1923">/// equal to the buffer &quot;buf&quot;.  Used for calling readfile().</a>
<a name="ln1924">void prep_exarg(exarg_T *eap, const buf_T *buf)</a>
<a name="ln1925">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1926">{</a>
<a name="ln1927">  const size_t cmd_len = 15 + strlen(buf-&gt;b_p_fenc);</a>
<a name="ln1928">  eap-&gt;cmd = xmalloc(cmd_len);</a>
<a name="ln1929"> </a>
<a name="ln1930">  snprintf(eap-&gt;cmd, cmd_len, &quot;e ++enc=%s&quot;, buf-&gt;b_p_fenc);</a>
<a name="ln1931">  eap-&gt;force_enc = 8;</a>
<a name="ln1932">  eap-&gt;bad_char = buf-&gt;b_bad_char;</a>
<a name="ln1933">  eap-&gt;force_ff = (unsigned char)(*buf-&gt;b_p_ff);</a>
<a name="ln1934"> </a>
<a name="ln1935">  eap-&gt;force_bin = buf-&gt;b_p_bin ? FORCE_BIN : FORCE_NOBIN;</a>
<a name="ln1936">  eap-&gt;read_edit = false;</a>
<a name="ln1937">  eap-&gt;forceit = false;</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">/// Set default or forced 'fileformat' and 'binary'.</a>
<a name="ln1941">void set_file_options(int set_options, exarg_T *eap)</a>
<a name="ln1942">{</a>
<a name="ln1943">  // set default 'fileformat'</a>
<a name="ln1944">  if (set_options) {</a>
<a name="ln1945">    if (eap != NULL &amp;&amp; eap-&gt;force_ff != 0) {</a>
<a name="ln1946">      set_fileformat(get_fileformat_force(curbuf, eap), OPT_LOCAL);</a>
<a name="ln1947">    } else if (*p_ffs != NUL) {</a>
<a name="ln1948">      set_fileformat(default_fileformat(), OPT_LOCAL);</a>
<a name="ln1949">    }</a>
<a name="ln1950">  }</a>
<a name="ln1951"> </a>
<a name="ln1952">  // set or reset 'binary'</a>
<a name="ln1953">  if (eap != NULL &amp;&amp; eap-&gt;force_bin != 0) {</a>
<a name="ln1954">    int oldval = curbuf-&gt;b_p_bin;</a>
<a name="ln1955"> </a>
<a name="ln1956">    curbuf-&gt;b_p_bin = (eap-&gt;force_bin == FORCE_BIN);</a>
<a name="ln1957">    set_options_bin(oldval, curbuf-&gt;b_p_bin, OPT_LOCAL);</a>
<a name="ln1958">  }</a>
<a name="ln1959">}</a>
<a name="ln1960"> </a>
<a name="ln1961">/// Set forced 'fileencoding'.</a>
<a name="ln1962">void set_forced_fenc(exarg_T *eap)</a>
<a name="ln1963">{</a>
<a name="ln1964">  if (eap-&gt;force_enc == 0) {</a>
<a name="ln1965">    return;</a>
<a name="ln1966">  }</a>
<a name="ln1967"> </a>
<a name="ln1968">  char *fenc = enc_canonize(eap-&gt;cmd + eap-&gt;force_enc);</a>
<a name="ln1969">  set_string_option_direct(&quot;fenc&quot;, -1, fenc, OPT_FREE|OPT_LOCAL, 0);</a>
<a name="ln1970">  xfree(fenc);</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">/// Find next fileencoding to use from 'fileencodings'.</a>
<a name="ln1974">/// &quot;pp&quot; points to fenc_next.  It's advanced to the next item.</a>
<a name="ln1975">/// When there are no more items, an empty string is returned and *pp is set to</a>
<a name="ln1976">/// NULL.</a>
<a name="ln1977">/// When *pp is not set to NULL, the result is in allocated memory and &quot;alloced&quot;</a>
<a name="ln1978">/// is set to true.</a>
<a name="ln1979">static char *next_fenc(char **pp, bool *alloced)</a>
<a name="ln1980">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_NONNULL_RET</a>
<a name="ln1981">{</a>
<a name="ln1982">  char *p;</a>
<a name="ln1983">  char *r;</a>
<a name="ln1984"> </a>
<a name="ln1985">  *alloced = false;</a>
<a name="ln1986">  if (**pp == NUL) {</a>
<a name="ln1987">    *pp = NULL;</a>
<a name="ln1988">    return &quot;&quot;;</a>
<a name="ln1989">  }</a>
<a name="ln1990">  p = vim_strchr(*pp, ',');</a>
<a name="ln1991">  if (p == NULL) {</a>
<a name="ln1992">    r = enc_canonize(*pp);</a>
<a name="ln1993">    *pp += strlen(*pp);</a>
<a name="ln1994">  } else {</a>
<a name="ln1995">    r = xstrnsave(*pp, (size_t)(p - *pp));</a>
<a name="ln1996">    *pp = p + 1;</a>
<a name="ln1997">    p = enc_canonize(r);</a>
<a name="ln1998">    xfree(r);</a>
<a name="ln1999">    r = p;</a>
<a name="ln2000">  }</a>
<a name="ln2001">  *alloced = true;</a>
<a name="ln2002">  return r;</a>
<a name="ln2003">}</a>
<a name="ln2004"> </a>
<a name="ln2005">/// Convert a file with the 'charconvert' expression.</a>
<a name="ln2006">/// This closes the file which is to be read, converts it and opens the</a>
<a name="ln2007">/// resulting file for reading.</a>
<a name="ln2008">///</a>
<a name="ln2009">/// @param fname  name of input file</a>
<a name="ln2010">/// @param fenc   converted from</a>
<a name="ln2011">/// @param fdp    in/out: file descriptor of file</a>
<a name="ln2012">///</a>
<a name="ln2013">/// @return       name of the resulting converted file (the caller should delete it after reading it).</a>
<a name="ln2014">///               Returns NULL if the conversion failed (&quot;*fdp&quot; is not set) .</a>
<a name="ln2015">static char *readfile_charconvert(char *fname, char *fenc, int *fdp)</a>
<a name="ln2016">{</a>
<a name="ln2017">  char *tmpname;</a>
<a name="ln2018">  char *errmsg = NULL;</a>
<a name="ln2019"> </a>
<a name="ln2020">  tmpname = vim_tempname();</a>
<a name="ln2021">  if (tmpname == NULL) {</a>
<a name="ln2022">    errmsg = _(&quot;Can't find temp file for conversion&quot;);</a>
<a name="ln2023">  } else {</a>
<a name="ln2024">    close(*fdp);                // close the input file, ignore errors</a>
<a name="ln2025">    *fdp = -1;</a>
<a name="ln2026">    if (eval_charconvert(fenc, &quot;utf-8&quot;,</a>
<a name="ln2027">                         fname, tmpname) == FAIL) {</a>
<a name="ln2028">      errmsg = _(&quot;Conversion with 'charconvert' failed&quot;);</a>
<a name="ln2029">    }</a>
<a name="ln2030">    if (errmsg == NULL &amp;&amp; (*fdp = os_open(tmpname, O_RDONLY, 0)) &lt; 0) {</a>
<a name="ln2031">      errmsg = _(&quot;can't read output of 'charconvert'&quot;);</a>
<a name="ln2032">    }</a>
<a name="ln2033">  }</a>
<a name="ln2034"> </a>
<a name="ln2035">  if (errmsg != NULL) {</a>
<a name="ln2036">    // Don't use emsg(), it breaks mappings, the retry with</a>
<a name="ln2037">    // another type of conversion might still work.</a>
<a name="ln2038">    msg(errmsg);</a>
<a name="ln2039">    if (tmpname != NULL) {</a>
<a name="ln2040">      os_remove(tmpname);  // delete converted file</a>
<a name="ln2041">      XFREE_CLEAR(tmpname);</a>
<a name="ln2042">    }</a>
<a name="ln2043">  }</a>
<a name="ln2044"> </a>
<a name="ln2045">  // If the input file is closed, open it (caller should check for error).</a>
<a name="ln2046">  if (*fdp &lt; 0) {</a>
<a name="ln2047">    *fdp = os_open(fname, O_RDONLY, 0);</a>
<a name="ln2048">  }</a>
<a name="ln2049"> </a>
<a name="ln2050">  return tmpname;</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053">/// Read marks for the current buffer from the ShaDa file, when we support</a>
<a name="ln2054">/// buffer marks and the buffer has a name.</a>
<a name="ln2055">static void check_marks_read(void)</a>
<a name="ln2056">{</a>
<a name="ln2057">  if (!curbuf-&gt;b_marks_read &amp;&amp; get_shada_parameter('\'') &gt; 0</a>
<a name="ln2058">      &amp;&amp; curbuf-&gt;b_ffname != NULL) {</a>
<a name="ln2059">    shada_read_marks();</a>
<a name="ln2060">  }</a>
<a name="ln2061"> </a>
<a name="ln2062">  // Always set b_marks_read; needed when 'shada' is changed to include</a>
<a name="ln2063">  // the ' parameter after opening a buffer.</a>
<a name="ln2064">  curbuf-&gt;b_marks_read = true;</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">/// Set the name of the current buffer.  Use when the buffer doesn't have a</a>
<a name="ln2068">/// name and a &quot;:r&quot; or &quot;:w&quot; command with a file name is used.</a>
<a name="ln2069">int set_rw_fname(char *fname, char *sfname)</a>
<a name="ln2070">{</a>
<a name="ln2071">  buf_T *buf = curbuf;</a>
<a name="ln2072"> </a>
<a name="ln2073">  // It's like the unnamed buffer is deleted....</a>
<a name="ln2074">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln2075">    apply_autocmds(EVENT_BUFDELETE, NULL, NULL, false, curbuf);</a>
<a name="ln2076">  }</a>
<a name="ln2077">  apply_autocmds(EVENT_BUFWIPEOUT, NULL, NULL, false, curbuf);</a>
<a name="ln2078">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2079">    return FAIL;</a>
<a name="ln2080">  }</a>
<a name="ln2081">  if (curbuf != buf) {</a>
<a name="ln2082">    // We are in another buffer now, don't do the renaming.</a>
<a name="ln2083">    emsg(_(e_auchangedbuf));</a>
<a name="ln2084">    return FAIL;</a>
<a name="ln2085">  }</a>
<a name="ln2086"> </a>
<a name="ln2087">  if (setfname(curbuf, fname, sfname, false) == OK) {</a>
<a name="ln2088">    curbuf-&gt;b_flags |= BF_NOTEDITED;</a>
<a name="ln2089">  }</a>
<a name="ln2090"> </a>
<a name="ln2091">  // ....and a new named one is created</a>
<a name="ln2092">  apply_autocmds(EVENT_BUFNEW, NULL, NULL, false, curbuf);</a>
<a name="ln2093">  if (curbuf-&gt;b_p_bl) {</a>
<a name="ln2094">    apply_autocmds(EVENT_BUFADD, NULL, NULL, false, curbuf);</a>
<a name="ln2095">  }</a>
<a name="ln2096">  if (aborting()) {         // autocmds may abort script processing</a>
<a name="ln2097">    return FAIL;</a>
<a name="ln2098">  }</a>
<a name="ln2099"> </a>
<a name="ln2100">  // Do filetype detection now if 'filetype' is empty.</a>
<a name="ln2101">  if (*curbuf-&gt;b_p_ft == NUL) {</a>
<a name="ln2102">    if (augroup_exists(&quot;filetypedetect&quot;)) {</a>
<a name="ln2103">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, false, NULL);</a>
<a name="ln2104">    }</a>
<a name="ln2105">    do_modelines(0);</a>
<a name="ln2106">  }</a>
<a name="ln2107"> </a>
<a name="ln2108">  return OK;</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">/// Put file name into the specified buffer with quotes</a>
<a name="ln2112">///</a>
<a name="ln2113">/// Replaces home directory at the start with `~`.</a>
<a name="ln2114">///</a>
<a name="ln2115">/// @param[out]  ret_buf  Buffer to save results to.</a>
<a name="ln2116">/// @param[in]  buf_len  ret_buf length.</a>
<a name="ln2117">/// @param[in]  buf  buf_T file name is coming from.</a>
<a name="ln2118">/// @param[in]  fname  File name to write.</a>
<a name="ln2119">void add_quoted_fname(char *const ret_buf, const size_t buf_len, const buf_T *const buf,</a>
<a name="ln2120">                      const char *fname)</a>
<a name="ln2121">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2122">{</a>
<a name="ln2123">  if (fname == NULL) {</a>
<a name="ln2124">    fname = &quot;-stdin-&quot;;</a>
<a name="ln2125">  }</a>
<a name="ln2126">  ret_buf[0] = '&quot;';</a>
<a name="ln2127">  home_replace(buf, fname, ret_buf + 1, buf_len - 4, true);</a>
<a name="ln2128">  xstrlcat(ret_buf, &quot;\&quot; &quot;, buf_len);</a>
<a name="ln2129">}</a>
<a name="ln2130"> </a>
<a name="ln2131">/// Append message for text mode to IObuff.</a>
<a name="ln2132">///</a>
<a name="ln2133">/// @param eol_type line ending type</a>
<a name="ln2134">///</a>
<a name="ln2135">/// @return true if something was appended.</a>
<a name="ln2136">bool msg_add_fileformat(int eol_type)</a>
<a name="ln2137">{</a>
<a name="ln2138">#ifndef USE_CRNL</a>
<a name="ln2139">  if (eol_type == EOL_DOS) {</a>
<a name="ln2140">    xstrlcat(IObuff, _(&quot;[dos]&quot;), IOSIZE);</a>
<a name="ln2141">    return true;</a>
<a name="ln2142">  }</a>
<a name="ln2143">#endif</a>
<a name="ln2144">  if (eol_type == EOL_MAC) {</a>
<a name="ln2145">    xstrlcat(IObuff, _(&quot;[mac]&quot;), IOSIZE);</a>
<a name="ln2146">    return true;</a>
<a name="ln2147">  }</a>
<a name="ln2148">#ifdef USE_CRNL</a>
<a name="ln2149">  if (eol_type == EOL_UNIX) {</a>
<a name="ln2150">    xstrlcat(IObuff, _(&quot;[unix]&quot;), IOSIZE);</a>
<a name="ln2151">    return true;</a>
<a name="ln2152">  }</a>
<a name="ln2153">#endif</a>
<a name="ln2154">  return false;</a>
<a name="ln2155">}</a>
<a name="ln2156"> </a>
<a name="ln2157">/// Append line and character count to IObuff.</a>
<a name="ln2158">void msg_add_lines(int insert_space, long lnum, off_T nchars)</a>
<a name="ln2159">{</a>
<a name="ln2160">  char *p = IObuff + strlen(IObuff);</a>
<a name="ln2161"> </a>
<a name="ln2162">  if (insert_space) {</a>
<a name="ln2163">    *p++ = ' ';</a>
<a name="ln2164">  }</a>
<a name="ln2165">  if (shortmess(SHM_LINES)) {</a>
<a name="ln2166">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)), &quot;%&quot; PRId64 &quot;L, %&quot; PRId64 &quot;B&quot;,</a>
<a name="ln2167">                 (int64_t)lnum, (int64_t)nchars);</a>
<a name="ln2168">  } else {</a>
<a name="ln2169">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)),</a>
<a name="ln2170">                 NGETTEXT(&quot;%&quot; PRId64 &quot; line, &quot;, &quot;%&quot; PRId64 &quot; lines, &quot;, lnum),</a>
<a name="ln2171">                 (int64_t)lnum);</a>
<a name="ln2172">    p += strlen(p);</a>
<a name="ln2173">    vim_snprintf(p, (size_t)(IOSIZE - (p - IObuff)),</a>
<a name="ln2174">                 NGETTEXT(&quot;%&quot; PRId64 &quot; byte&quot;, &quot;%&quot; PRId64 &quot; bytes&quot;, nchars),</a>
<a name="ln2175">                 (int64_t)nchars);</a>
<a name="ln2176">  }</a>
<a name="ln2177">}</a>
<a name="ln2178"> </a>
<a name="ln2179">bool time_differs(const FileInfo *file_info, long mtime, long mtime_ns) FUNC_ATTR_CONST</a>
<a name="ln2180">{</a>
<a name="ln2181">#if defined(__linux__) || defined(MSWIN)</a>
<a name="ln2182">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln2183">         // On a FAT filesystem, esp. under Linux, there are only 5 bits to store</a>
<a name="ln2184">         // the seconds.  Since the roundoff is done when flushing the inode, the</a>
<a name="ln2185">         // time may change unexpectedly by one second!!!</a>
<a name="ln2186">         || file_info-&gt;stat.st_mtim.tv_sec - mtime &gt; 1</a>
<a name="ln2187">         || mtime - file_info-&gt;stat.st_mtim.tv_sec &gt; 1;</a>
<a name="ln2188">#else</a>
<a name="ln2189">  return file_info-&gt;stat.st_mtim.tv_nsec != mtime_ns</a>
<a name="ln2190">         || file_info-&gt;stat.st_mtim.tv_sec != mtime;</a>
<a name="ln2191">#endif</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">/// Return true if file encoding &quot;fenc&quot; requires conversion from or to</a>
<a name="ln2195">/// 'encoding'.</a>
<a name="ln2196">///</a>
<a name="ln2197">/// @param fenc file encoding to check</a>
<a name="ln2198">///</a>
<a name="ln2199">/// @return true if conversion is required</a>
<a name="ln2200">bool need_conversion(const char *fenc)</a>
<a name="ln2201">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2202">{</a>
<a name="ln2203">  int same_encoding;</a>
<a name="ln2204">  int fenc_flags;</a>
<a name="ln2205"> </a>
<a name="ln2206">  if (*fenc == NUL || strcmp(p_enc, fenc) == 0) {</a>
<a name="ln2207">    same_encoding = true;</a>
<a name="ln2208">    fenc_flags = 0;</a>
<a name="ln2209">  } else {</a>
<a name="ln2210">    // Ignore difference between &quot;ansi&quot; and &quot;latin1&quot;, &quot;ucs-4&quot; and</a>
<a name="ln2211">    // &quot;ucs-4be&quot;, etc.</a>
<a name="ln2212">    int enc_flags = get_fio_flags(p_enc);</a>
<a name="ln2213">    fenc_flags = get_fio_flags(fenc);</a>
<a name="ln2214">    same_encoding = (enc_flags != 0 &amp;&amp; fenc_flags == enc_flags);</a>
<a name="ln2215">  }</a>
<a name="ln2216">  if (same_encoding) {</a>
<a name="ln2217">    // Specified file encoding matches UTF-8.</a>
<a name="ln2218">    return false;</a>
<a name="ln2219">  }</a>
<a name="ln2220"> </a>
<a name="ln2221">  // Encodings differ.  However, conversion is not needed when 'enc' is any</a>
<a name="ln2222">  // Unicode encoding and the file is UTF-8.</a>
<a name="ln2223">  return !(fenc_flags == FIO_UTF8);</a>
<a name="ln2224">}</a>
<a name="ln2225"> </a>
<a name="ln2226">/// Return the FIO_ flags needed for the internal conversion if 'name' was</a>
<a name="ln2227">/// unicode or latin1, otherwise 0. If &quot;name&quot; is an empty string,</a>
<a name="ln2228">/// use 'encoding'.</a>
<a name="ln2229">///</a>
<a name="ln2230">/// @param name string to check for encoding</a>
<a name="ln2231">int get_fio_flags(const char *name)</a>
<a name="ln2232">{</a>
<a name="ln2233">  if (*name == NUL) {</a>
<a name="ln2234">    name = p_enc;</a>
<a name="ln2235">  }</a>
<a name="ln2236">  int prop = enc_canon_props(name);</a>
<a name="ln2237">  if (prop &amp; ENC_UNICODE) {</a>
<a name="ln2238">    if (prop &amp; ENC_2BYTE) {</a>
<a name="ln2239">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2240">        return FIO_UCS2 | FIO_ENDIAN_L;</a>
<a name="ln2241">      }</a>
<a name="ln2242">      return FIO_UCS2;</a>
<a name="ln2243">    }</a>
<a name="ln2244">    if (prop &amp; ENC_4BYTE) {</a>
<a name="ln2245">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2246">        return FIO_UCS4 | FIO_ENDIAN_L;</a>
<a name="ln2247">      }</a>
<a name="ln2248">      return FIO_UCS4;</a>
<a name="ln2249">    }</a>
<a name="ln2250">    if (prop &amp; ENC_2WORD) {</a>
<a name="ln2251">      if (prop &amp; ENC_ENDIAN_L) {</a>
<a name="ln2252">        return FIO_UTF16 | FIO_ENDIAN_L;</a>
<a name="ln2253">      }</a>
<a name="ln2254">      return FIO_UTF16;</a>
<a name="ln2255">    }</a>
<a name="ln2256">    return FIO_UTF8;</a>
<a name="ln2257">  }</a>
<a name="ln2258">  if (prop &amp; ENC_LATIN1) {</a>
<a name="ln2259">    return FIO_LATIN1;</a>
<a name="ln2260">  }</a>
<a name="ln2261">  // must be ENC_DBCS, requires iconv()</a>
<a name="ln2262">  return 0;</a>
<a name="ln2263">}</a>
<a name="ln2264"> </a>
<a name="ln2265">/// Check for a Unicode BOM (Byte Order Mark) at the start of p[size].</a>
<a name="ln2266">/// &quot;size&quot; must be at least 2.</a>
<a name="ln2267">///</a>
<a name="ln2268">/// @return  the name of the encoding and set &quot;*lenp&quot; to the length or,</a>
<a name="ln2269">///          NULL when no BOM found.</a>
<a name="ln2270">static char *check_for_bom(const char *p_in, int size, int *lenp, int flags)</a>
<a name="ln2271">{</a>
<a name="ln2272">  const uint8_t *p = (const uint8_t *)p_in;</a>
<a name="ln2273">  char *name = NULL;</a>
<a name="ln2274">  int len = 2;</a>
<a name="ln2275"> </a>
<a name="ln2276">  if (p[0] == 0xef &amp;&amp; p[1] == 0xbb &amp;&amp; size &gt;= 3 &amp;&amp; p[2] == 0xbf</a>
<a name="ln2277">      &amp;&amp; (flags == FIO_ALL || flags == FIO_UTF8 || flags == 0)) {</a>
<a name="ln2278">    name = &quot;utf-8&quot;;             // EF BB BF</a>
<a name="ln2279">    len = 3;</a>
<a name="ln2280">  } else if (p[0] == 0xff &amp;&amp; p[1] == 0xfe) {</a>
<a name="ln2281">    if (size &gt;= 4 &amp;&amp; p[2] == 0 &amp;&amp; p[3] == 0</a>
<a name="ln2282">        &amp;&amp; (flags == FIO_ALL || flags == (FIO_UCS4 | FIO_ENDIAN_L))) {</a>
<a name="ln2283">      name = &quot;ucs-4le&quot;;         // FF FE 00 00</a>
<a name="ln2284">      len = 4;</a>
<a name="ln2285">    } else if (flags == (FIO_UCS2 | FIO_ENDIAN_L)) {</a>
<a name="ln2286">      name = &quot;ucs-2le&quot;;         // FF FE</a>
<a name="ln2287">    } else if (flags == FIO_ALL</a>
<a name="ln2288">               || flags == (FIO_UTF16 | FIO_ENDIAN_L)) {</a>
<a name="ln2289">      // utf-16le is preferred, it also works for ucs-2le text</a>
<a name="ln2290">      name = &quot;utf-16le&quot;;        // FF FE</a>
<a name="ln2291">    }</a>
<a name="ln2292">  } else if (p[0] == 0xfe &amp;&amp; p[1] == 0xff</a>
<a name="ln2293">             &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS2 || flags ==</a>
<a name="ln2294">                 FIO_UTF16)) {</a>
<a name="ln2295">    // Default to utf-16, it works also for ucs-2 text.</a>
<a name="ln2296">    if (flags == FIO_UCS2) {</a>
<a name="ln2297">      name = &quot;ucs-2&quot;;           // FE FF</a>
<a name="ln2298">    } else {</a>
<a name="ln2299">      name = &quot;utf-16&quot;;          // FE FF</a>
<a name="ln2300">    }</a>
<a name="ln2301">  } else if (size &gt;= 4 &amp;&amp; p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 0xfe</a>
<a name="ln2302">             &amp;&amp; p[3] == 0xff &amp;&amp; (flags == FIO_ALL || flags == FIO_UCS4)) {</a>
<a name="ln2303">    name = &quot;ucs-4&quot;;             // 00 00 FE FF</a>
<a name="ln2304">    len = 4;</a>
<a name="ln2305">  }</a>
<a name="ln2306"> </a>
<a name="ln2307">  *lenp = len;</a>
<a name="ln2308">  return name;</a>
<a name="ln2309">}</a>
<a name="ln2310"> </a>
<a name="ln2311">/// Shorten filename of a buffer.</a>
<a name="ln2312">///</a>
<a name="ln2313">/// @param force  when true: Use full path from now on for files currently being</a>
<a name="ln2314">///               edited, both for file name and swap file name.  Try to shorten the file</a>
<a name="ln2315">///               names a bit, if safe to do so.</a>
<a name="ln2316">///               when false: Only try to shorten absolute file names.</a>
<a name="ln2317">///</a>
<a name="ln2318">/// For buffers that have buftype &quot;nofile&quot; or &quot;scratch&quot;: never change the file</a>
<a name="ln2319">/// name.</a>
<a name="ln2320">void shorten_buf_fname(buf_T *buf, char *dirname, int force)</a>
<a name="ln2321">{</a>
<a name="ln2322">  if (buf-&gt;b_fname != NULL</a>
<a name="ln2323">      &amp;&amp; !bt_nofilename(buf)</a>
<a name="ln2324">      &amp;&amp; !path_with_url(buf-&gt;b_fname)</a>
<a name="ln2325">      &amp;&amp; (force</a>
<a name="ln2326">          || buf-&gt;b_sfname == NULL</a>
<a name="ln2327">          || path_is_absolute(buf-&gt;b_sfname))) {</a>
<a name="ln2328">    if (buf-&gt;b_sfname != buf-&gt;b_ffname) {</a>
<a name="ln2329">      XFREE_CLEAR(buf-&gt;b_sfname);</a>
<a name="ln2330">    }</a>
<a name="ln2331">    char *p = path_shorten_fname(buf-&gt;b_ffname, dirname);</a>
<a name="ln2332">    if (p != NULL) {</a>
<a name="ln2333">      buf-&gt;b_sfname = xstrdup(p);</a>
<a name="ln2334">      buf-&gt;b_fname = buf-&gt;b_sfname;</a>
<a name="ln2335">    }</a>
<a name="ln2336">    if (p == NULL) {</a>
<a name="ln2337">      buf-&gt;b_fname = buf-&gt;b_ffname;</a>
<a name="ln2338">    }</a>
<a name="ln2339">  }</a>
<a name="ln2340">}</a>
<a name="ln2341"> </a>
<a name="ln2342">/// Shorten filenames for all buffers.</a>
<a name="ln2343">void shorten_fnames(int force)</a>
<a name="ln2344">{</a>
<a name="ln2345">  char dirname[MAXPATHL];</a>
<a name="ln2346"> </a>
<a name="ln2347">  os_dirname(dirname, MAXPATHL);</a>
<a name="ln2348">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2349">    shorten_buf_fname(buf, dirname, force);</a>
<a name="ln2350"> </a>
<a name="ln2351">    // Always make the swap file name a full path, a &quot;nofile&quot; buffer may</a>
<a name="ln2352">    // also have a swap file.</a>
<a name="ln2353">    mf_fullname(buf-&gt;b_ml.ml_mfp);</a>
<a name="ln2354">  }</a>
<a name="ln2355">  status_redraw_all();</a>
<a name="ln2356">  redraw_tabline = true;</a>
<a name="ln2357">}</a>
<a name="ln2358"> </a>
<a name="ln2359">/// Get new filename ended by given extension.</a>
<a name="ln2360">///</a>
<a name="ln2361">/// @param fname        The original filename.</a>
<a name="ln2362">///                     If NULL, use current directory name and ext to</a>
<a name="ln2363">///                     compute new filename.</a>
<a name="ln2364">/// @param ext          The extension to add to the filename.</a>
<a name="ln2365">///                     4 chars max if prefixed with a dot, 3 otherwise.</a>
<a name="ln2366">/// @param prepend_dot  If true, prefix ext with a dot.</a>
<a name="ln2367">///                     Does nothing if ext already starts with a dot, or</a>
<a name="ln2368">///                     if fname is NULL.</a>
<a name="ln2369">///</a>
<a name="ln2370">/// @return [allocated] - A new filename, made up from:</a>
<a name="ln2371">///                       * fname + ext, if fname not NULL.</a>
<a name="ln2372">///                       * current dir + ext, if fname is NULL.</a>
<a name="ln2373">///                       Result is guaranteed to:</a>
<a name="ln2374">///                       * be ended by &lt;ext&gt;.</a>
<a name="ln2375">///                       * have a basename with at most BASENAMELEN chars:</a>
<a name="ln2376">///                         original basename is truncated if necessary.</a>
<a name="ln2377">///                       * be different than original: basename chars are</a>
<a name="ln2378">///                         replaced by &quot;_&quot; if necessary. If that can't be done</a>
<a name="ln2379">///                         because truncated value of original filename was</a>
<a name="ln2380">///                         made of all underscores, replace first &quot;_&quot; by &quot;v&quot;.</a>
<a name="ln2381">///                     - NULL, if fname is NULL and there was a problem trying</a>
<a name="ln2382">///                       to get current directory.</a>
<a name="ln2383">char *modname(const char *fname, const char *ext, bool prepend_dot)</a>
<a name="ln2384">  FUNC_ATTR_NONNULL_ARG(2)</a>
<a name="ln2385">{</a>
<a name="ln2386">  char *retval;</a>
<a name="ln2387">  size_t fnamelen;</a>
<a name="ln2388">  size_t extlen = strlen(ext);</a>
<a name="ln2389"> </a>
<a name="ln2390">  // If there is no file name we must get the name of the current directory</a>
<a name="ln2391">  // (we need the full path in case :cd is used).</a>
<a name="ln2392">  if (fname == NULL || *fname == NUL) {</a>
<a name="ln2393">    retval = xmalloc(MAXPATHL + extlen + 3);  // +3 for PATHSEP, &quot;_&quot; (Win), NUL</a>
<a name="ln2394">    if (os_dirname(retval, MAXPATHL) == FAIL</a>
<a name="ln2395">        || strlen(retval) == 0) {</a>
<a name="ln2396">      xfree(retval);</a>
<a name="ln2397">      return NULL;</a>
<a name="ln2398">    }</a>
<a name="ln2399">    add_pathsep(retval);</a>
<a name="ln2400">    fnamelen = strlen(retval);</a>
<a name="ln2401">    prepend_dot = false;  // nothing to prepend a dot to</a>
<a name="ln2402">  } else {</a>
<a name="ln2403">    fnamelen = strlen(fname);</a>
<a name="ln2404">    retval = xmalloc(fnamelen + extlen + 3);</a>
<a name="ln2405">    strcpy(retval, fname);  // NOLINT(runtime/printf)</a>
<a name="ln2406">  }</a>
<a name="ln2407"> </a>
<a name="ln2408">  // Search backwards until we hit a '/', '\' or ':'.</a>
<a name="ln2409">  // Then truncate what is after the '/', '\' or ':' to BASENAMELEN characters.</a>
<a name="ln2410">  char *ptr = NULL;</a>
<a name="ln2411">  for (ptr = retval + fnamelen; ptr &gt; retval; MB_PTR_BACK(retval, ptr)) {</a>
<a name="ln2412">    if (vim_ispathsep(*ptr)) {</a>
<a name="ln2413">      ptr++;</a>
<a name="ln2414">      break;</a>
<a name="ln2415">    }</a>
<a name="ln2416">  }</a>
<a name="ln2417"> </a>
<a name="ln2418">  // the file name has at most BASENAMELEN characters.</a>
<a name="ln2419">  if (strlen(ptr) &gt; BASENAMELEN) {</a>
<a name="ln2420">    ptr[BASENAMELEN] = '\0';</a>
<a name="ln2421">  }</a>
<a name="ln2422"> </a>
<a name="ln2423">  char *s = ptr + strlen(ptr);</a>
<a name="ln2424"> </a>
<a name="ln2425">  // Append the extension.</a>
<a name="ln2426">  // ext can start with '.' and cannot exceed 3 more characters.</a>
<a name="ln2427">  strcpy(s, ext);  // NOLINT(runtime/printf)</a>
<a name="ln2428"> </a>
<a name="ln2429">  char *e;</a>
<a name="ln2430">  // Prepend the dot if needed.</a>
<a name="ln2431">  if (prepend_dot &amp;&amp; *(e = path_tail(retval)) != '.') {</a>
<a name="ln2432">    STRMOVE(e + 1, e);</a>
<a name="ln2433">    *e = '.';</a>
<a name="ln2434">  }</a>
<a name="ln2435"> </a>
<a name="ln2436">  // Check that, after appending the extension, the file name is really</a>
<a name="ln2437">  // different.</a>
<a name="ln2438">  if (fname != NULL &amp;&amp; strcmp(fname, retval) == 0) {</a>
<a name="ln2439">    // we search for a character that can be replaced by '_'</a>
<a name="ln2440">    while (--s &gt;= ptr) {</a>
<a name="ln2441">      if (*s != '_') {</a>
<a name="ln2442">        *s = '_';</a>
<a name="ln2443">        break;</a>
<a name="ln2444">      }</a>
<a name="ln2445">    }</a>
<a name="ln2446">    if (s &lt; ptr) {  // fname was &quot;________.&lt;ext&gt;&quot;, how tricky!</a>
<a name="ln2447">      *ptr = 'v';</a>
<a name="ln2448">    }</a>
<a name="ln2449">  }</a>
<a name="ln2450">  return retval;</a>
<a name="ln2451">}</a>
<a name="ln2452"> </a>
<a name="ln2453">/// Like fgets(), but if the file line is too long, it is truncated and the</a>
<a name="ln2454">/// rest of the line is thrown away.</a>
<a name="ln2455">///</a>
<a name="ln2456">/// @param[out] buf buffer to fill</a>
<a name="ln2457">/// @param size size of the buffer</a>
<a name="ln2458">/// @param fp file to read from</a>
<a name="ln2459">///</a>
<a name="ln2460">/// @return true for EOF or error</a>
<a name="ln2461">bool vim_fgets(char *buf, int size, FILE *fp)</a>
<a name="ln2462">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2463">{</a>
<a name="ln2464">  char *retval;</a>
<a name="ln2465"> </a>
<a name="ln2466">  assert(size &gt; 0);</a>
<a name="ln2467">  buf[size - 2] = NUL;</a>
<a name="ln2468"> </a>
<a name="ln2469">  do {</a>
<a name="ln2470">    errno = 0;</a>
<a name="ln2471">    retval = fgets(buf, size, fp);</a>
<a name="ln2472">  } while (retval == NULL &amp;&amp; errno == EINTR &amp;&amp; ferror(fp));</a>
<a name="ln2473"> </a>
<a name="ln2474">  if (buf[size - 2] != NUL &amp;&amp; buf[size - 2] != '\n') {</a>
<a name="ln2475">    char tbuf[200];</a>
<a name="ln2476"> </a>
<a name="ln2477">    buf[size - 1] = NUL;  // Truncate the line.</a>
<a name="ln2478"> </a>
<a name="ln2479">    // Now throw away the rest of the line:</a>
<a name="ln2480">    do {</a>
<a name="ln2481">      tbuf[sizeof(tbuf) - 2] = NUL;</a>
<a name="ln2482">      errno = 0;</a>
<a name="ln2483">      retval = fgets(tbuf, sizeof(tbuf), fp);</a>
<a name="ln2484">      if (retval == NULL &amp;&amp; (feof(fp) || errno != EINTR)) {</a>
<a name="ln2485">        break;</a>
<a name="ln2486">      }</a>
<a name="ln2487">    } while (tbuf[sizeof(tbuf) - 2] != NUL &amp;&amp; tbuf[sizeof(tbuf) - 2] != '\n');</a>
<a name="ln2488">  }</a>
<a name="ln2489">  return retval == NULL;</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">/// Read 2 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2493">///</a>
<a name="ln2494">/// @return  -1 when encountering EOF.</a>
<a name="ln2495">int get2c(FILE *fd)</a>
<a name="ln2496">{</a>
<a name="ln2497">  const int n = getc(fd);</a>
<a name="ln2498">  if (n == EOF) {</a>
<a name="ln2499">    return -1;</a>
<a name="ln2500">  }</a>
<a name="ln2501">  const int c = getc(fd);</a>
<a name="ln2502">  if (c == EOF) {</a>
<a name="ln2503">    return -1;</a>
<a name="ln2504">  }</a>
<a name="ln2505">  return (n &lt;&lt; 8) + c;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/// Read 3 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2509">///</a>
<a name="ln2510">/// @return  -1 when encountering EOF.</a>
<a name="ln2511">int get3c(FILE *fd)</a>
<a name="ln2512">{</a>
<a name="ln2513">  int n = getc(fd);</a>
<a name="ln2514">  if (n == EOF) {</a>
<a name="ln2515">    return -1;</a>
<a name="ln2516">  }</a>
<a name="ln2517">  int c = getc(fd);</a>
<a name="ln2518">  if (c == EOF) {</a>
<a name="ln2519">    return -1;</a>
<a name="ln2520">  }</a>
<a name="ln2521">  n = (n &lt;&lt; 8) + c;</a>
<a name="ln2522">  c = getc(fd);</a>
<a name="ln2523">  if (c == EOF) {</a>
<a name="ln2524">    return -1;</a>
<a name="ln2525">  }</a>
<a name="ln2526">  return (n &lt;&lt; 8) + c;</a>
<a name="ln2527">}</a>
<a name="ln2528"> </a>
<a name="ln2529">/// Read 4 bytes from &quot;fd&quot; and turn them into an int, MSB first.</a>
<a name="ln2530">///</a>
<a name="ln2531">/// @return  -1 when encountering EOF.</a>
<a name="ln2532">int get4c(FILE *fd)</a>
<a name="ln2533">{</a>
<a name="ln2534">  // Use unsigned rather than int otherwise result is undefined</a>
<a name="ln2535">  // when left-shift sets the MSB.</a>
<a name="ln2536">  unsigned n;</a>
<a name="ln2537"> </a>
<a name="ln2538">  int c = getc(fd);</a>
<a name="ln2539">  if (c == EOF) {</a>
<a name="ln2540">    return -1;</a>
<a name="ln2541">  }</a>
<a name="ln2542">  n = (unsigned)c;</a>
<a name="ln2543">  c = getc(fd);</a>
<a name="ln2544">  if (c == EOF) {</a>
<a name="ln2545">    return -1;</a>
<a name="ln2546">  }</a>
<a name="ln2547">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2548">  c = getc(fd);</a>
<a name="ln2549">  if (c == EOF) {</a>
<a name="ln2550">    return -1;</a>
<a name="ln2551">  }</a>
<a name="ln2552">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2553">  c = getc(fd);</a>
<a name="ln2554">  if (c == EOF) {</a>
<a name="ln2555">    return -1;</a>
<a name="ln2556">  }</a>
<a name="ln2557">  n = (n &lt;&lt; 8) + (unsigned)c;</a>
<a name="ln2558">  return (int)n;</a>
<a name="ln2559">}</a>
<a name="ln2560"> </a>
<a name="ln2561">/// Read 8 bytes from `fd` and turn them into a time_t, MSB first.</a>
<a name="ln2562">///</a>
<a name="ln2563">/// @return  -1 when encountering EOF.</a>
<a name="ln2564">time_t get8ctime(FILE *fd)</a>
<a name="ln2565">{</a>
<a name="ln2566">  time_t n = 0;</a>
<a name="ln2567"> </a>
<a name="ln2568">  for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln2569">    const int c = getc(fd);</a>
<a name="ln2570">    if (c == EOF) {</a>
<a name="ln2571">      return -1;</a>
<a name="ln2572">    }</a>
<a name="ln2573">    n = (n &lt;&lt; 8) + c;</a>
<a name="ln2574">  }</a>
<a name="ln2575">  return n;</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578">/// Reads a string of length &quot;cnt&quot; from &quot;fd&quot; into allocated memory.</a>
<a name="ln2579">///</a>
<a name="ln2580">/// @return  pointer to the string or NULL when unable to read that many bytes.</a>
<a name="ln2581">char *read_string(FILE *fd, size_t cnt)</a>
<a name="ln2582">{</a>
<a name="ln2583">  char *str = xmallocz(cnt);</a>
<a name="ln2584">  for (size_t i = 0; i &lt; cnt; i++) {</a>
<a name="ln2585">    int c = getc(fd);</a>
<a name="ln2586">    if (c == EOF) {</a>
<a name="ln2587">      xfree(str);</a>
<a name="ln2588">      return NULL;</a>
<a name="ln2589">    }</a>
<a name="ln2590">    str[i] = (char)c;</a>
<a name="ln2591">  }</a>
<a name="ln2592">  return str;</a>
<a name="ln2593">}</a>
<a name="ln2594"> </a>
<a name="ln2595">/// Writes a number to file &quot;fd&quot;, most significant bit first, in &quot;len&quot; bytes.</a>
<a name="ln2596">///</a>
<a name="ln2597">/// @return  false in case of an error.</a>
<a name="ln2598">bool put_bytes(FILE *fd, uintmax_t number, size_t len)</a>
<a name="ln2599">{</a>
<a name="ln2600">  assert(len &gt; 0);</a>
<a name="ln2601">  for (size_t i = len - 1; i &lt; len; i--) {</a>
<a name="ln2602">    if (putc((int)(number &gt;&gt; (i * 8)), fd) == EOF) {</a>
<a name="ln2603">      return false;</a>
<a name="ln2604">    }</a>
<a name="ln2605">  }</a>
<a name="ln2606">  return true;</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">/// Writes time_t to file &quot;fd&quot; in 8 bytes.</a>
<a name="ln2610">///</a>
<a name="ln2611">/// @return  FAIL when the write failed.</a>
<a name="ln2612">int put_time(FILE *fd, time_t time_)</a>
<a name="ln2613">{</a>
<a name="ln2614">  uint8_t buf[8];</a>
<a name="ln2615">  time_to_bytes(time_, buf);</a>
<a name="ln2616">  return fwrite(buf, sizeof(uint8_t), ARRAY_SIZE(buf), fd) == 1 ? OK : FAIL;</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">static int rename_with_tmp(const char *const from, const char *const to)</a>
<a name="ln2620">{</a>
<a name="ln2621">  // Find a name that doesn't exist and is in the same directory.</a>
<a name="ln2622">  // Rename &quot;from&quot; to &quot;tempname&quot; and then rename &quot;tempname&quot; to &quot;to&quot;.</a>
<a name="ln2623">  if (strlen(from) &gt;= MAXPATHL - 5) {</a>
<a name="ln2624">    return -1;</a>
<a name="ln2625">  }</a>
<a name="ln2626"> </a>
<a name="ln2627">  char tempname[MAXPATHL + 1];</a>
<a name="ln2628">  STRCPY(tempname, from);</a>
<a name="ln2629">  for (int n = 123; n &lt; 99999; n++) {</a>
<a name="ln2630">    char *tail = path_tail(tempname);</a>
<a name="ln2631">    snprintf(tail, (size_t)((MAXPATHL + 1) - (tail - tempname - 1)), &quot;%d&quot;, n);</a>
<a name="ln2632"> </a>
<a name="ln2633">    if (!os_path_exists(tempname)) {</a>
<a name="ln2634">      if (os_rename(from, tempname) == OK) {</a>
<a name="ln2635">        if (os_rename(tempname, to) == OK) {</a>
<a name="ln2636">          return 0;</a>
<a name="ln2637">        }</a>
<a name="ln2638">        // Strange, the second step failed.  Try moving the</a>
<a name="ln2639">        // file back and return failure.</a>
<a name="ln2640">        (void)os_rename(tempname, from);</a>
<a name="ln2641">        return -1;</a>
<a name="ln2642">      }</a>
<a name="ln2643">      // If it fails for one temp name it will most likely fail</a>
<a name="ln2644">      // for any temp name, give up.</a>
<a name="ln2645">      return -1;</a>
<a name="ln2646">    }</a>
<a name="ln2647">  }</a>
<a name="ln2648">  return -1;</a>
<a name="ln2649">}</a>
<a name="ln2650"> </a>
<a name="ln2651">/// os_rename() only works if both files are on the same file system, this</a>
<a name="ln2652">/// function will (attempts to?) copy the file across if rename fails -- webb</a>
<a name="ln2653">///</a>
<a name="ln2654">/// @return  -1 for failure, 0 for success</a>
<a name="ln2655">int vim_rename(const char *from, const char *to)</a>
<a name="ln2656">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2657">{</a>
<a name="ln2658">  char *errmsg = NULL;</a>
<a name="ln2659">  bool use_tmp_file = false;</a>
<a name="ln2660"> </a>
<a name="ln2661">  // When the names are identical, there is nothing to do.  When they refer</a>
<a name="ln2662">  // to the same file (ignoring case and slash/backslash differences) but</a>
<a name="ln2663">  // the file name differs we need to go through a temp file.</a>
<a name="ln2664">  if (path_fnamecmp(from, to) == 0) {</a>
<a name="ln2665">    if (p_fic &amp;&amp; (strcmp(path_tail(from), path_tail(to)) != 0)) {</a>
<a name="ln2666">      use_tmp_file = true;</a>
<a name="ln2667">    } else {</a>
<a name="ln2668">      return 0;</a>
<a name="ln2669">    }</a>
<a name="ln2670">  }</a>
<a name="ln2671"> </a>
<a name="ln2672">  // Fail if the &quot;from&quot; file doesn't exist. Avoids that &quot;to&quot; is deleted.</a>
<a name="ln2673">  FileInfo from_info;</a>
<a name="ln2674">  if (!os_fileinfo(from, &amp;from_info)) {</a>
<a name="ln2675">    return -1;</a>
<a name="ln2676">  }</a>
<a name="ln2677"> </a>
<a name="ln2678">  // It's possible for the source and destination to be the same file.</a>
<a name="ln2679">  // This happens when &quot;from&quot; and &quot;to&quot; differ in case and are on a FAT32</a>
<a name="ln2680">  // filesystem. In that case go through a temp file name.</a>
<a name="ln2681">  FileInfo to_info;</a>
<a name="ln2682">  if (os_fileinfo(to, &amp;to_info) &amp;&amp; os_fileinfo_id_equal(&amp;from_info,  &amp;to_info)) {</a>
<a name="ln2683">    use_tmp_file = true;</a>
<a name="ln2684">  }</a>
<a name="ln2685"> </a>
<a name="ln2686">  if (use_tmp_file) {</a>
<a name="ln2687">    return rename_with_tmp(from, to);</a>
<a name="ln2688">  }</a>
<a name="ln2689"> </a>
<a name="ln2690">  // Delete the &quot;to&quot; file, this is required on some systems to make the</a>
<a name="ln2691">  // os_rename() work, on other systems it makes sure that we don't have</a>
<a name="ln2692">  // two files when the os_rename() fails.</a>
<a name="ln2693"> </a>
<a name="ln2694">  os_remove(to);</a>
<a name="ln2695"> </a>
<a name="ln2696">  // First try a normal rename, return if it works.</a>
<a name="ln2697">  if (os_rename(from, to) == OK) {</a>
<a name="ln2698">    return 0;</a>
<a name="ln2699">  }</a>
<a name="ln2700"> </a>
<a name="ln2701">  // Rename() failed, try copying the file.</a>
<a name="ln2702">  long perm = os_getperm(from);</a>
<a name="ln2703">  // For systems that support ACL: get the ACL from the original file.</a>
<a name="ln2704">  vim_acl_T acl = os_get_acl(from);</a>
<a name="ln2705">  int fd_in = os_open(from, O_RDONLY, 0);</a>
<a name="ln2706">  if (fd_in &lt; 0) {</a>
<a name="ln2707">    os_free_acl(acl);</a>
<a name="ln2708">    return -1;</a>
<a name="ln2709">  }</a>
<a name="ln2710"> </a>
<a name="ln2711">  // Create the new file with same permissions as the original.</a>
<a name="ln2712">  int fd_out = os_open(to, O_CREAT|O_EXCL|O_WRONLY|O_NOFOLLOW, (int)perm);</a>
<a name="ln2713">  if (fd_out &lt; 0) {</a>
<a name="ln2714">    close(fd_in);</a>
<a name="ln2715">    os_free_acl(acl);</a>
<a name="ln2716">    return -1;</a>
<a name="ln2717">  }</a>
<a name="ln2718"> </a>
<a name="ln2719">  // Avoid xmalloc() here as vim_rename() is called by buf_write() when nvim</a>
<a name="ln2720">  // is `preserve_exit()`ing.</a>
<a name="ln2721">  char *buffer = try_malloc(WRITEBUFSIZE);</a>
<a name="ln2722">  if (buffer == NULL) {</a>
<a name="ln2723">    close(fd_out);</a>
<a name="ln2724">    close(fd_in);</a>
<a name="ln2725">    os_free_acl(acl);</a>
<a name="ln2726">    return -1;</a>
<a name="ln2727">  }</a>
<a name="ln2728"> </a>
<a name="ln2729">  int n;</a>
<a name="ln2730">  while ((n = (int)read_eintr(fd_in, buffer, WRITEBUFSIZE)) &gt; 0) {</a>
<a name="ln2731">    if (write_eintr(fd_out, buffer, (size_t)n) != n) {</a>
<a name="ln2732">      errmsg = _(&quot;E208: Error writing to \&quot;%s\&quot;&quot;);</a>
<a name="ln2733">      break;</a>
<a name="ln2734">    }</a>
<a name="ln2735">  }</a>
<a name="ln2736"> </a>
<a name="ln2737">  xfree(buffer);</a>
<a name="ln2738">  close(fd_in);</a>
<a name="ln2739">  if (close(fd_out) &lt; 0) {</a>
<a name="ln2740">    errmsg = _(&quot;E209: Error closing \&quot;%s\&quot;&quot;);</a>
<a name="ln2741">  }</a>
<a name="ln2742">  if (n &lt; 0) {</a>
<a name="ln2743">    errmsg = _(&quot;E210: Error reading \&quot;%s\&quot;&quot;);</a>
<a name="ln2744">    to = from;</a>
<a name="ln2745">  }</a>
<a name="ln2746">#ifndef UNIX  // For Unix os_open() already set the permission.</a>
<a name="ln2747">  os_setperm(to, perm);</a>
<a name="ln2748">#endif</a>
<a name="ln2749">  os_set_acl(to, acl);</a>
<a name="ln2750">  os_free_acl(acl);</a>
<a name="ln2751">  if (errmsg != NULL) {</a>
<a name="ln2752">    semsg(errmsg, to);</a>
<a name="ln2753">    return -1;</a>
<a name="ln2754">  }</a>
<a name="ln2755">  os_remove(from);</a>
<a name="ln2756">  return 0;</a>
<a name="ln2757">}</a>
<a name="ln2758"> </a>
<a name="ln2759">static int already_warned = false;</a>
<a name="ln2760"> </a>
<a name="ln2761">/// Check if any not hidden buffer has been changed.</a>
<a name="ln2762">/// Postpone the check if there are characters in the stuff buffer, a global</a>
<a name="ln2763">/// command is being executed, a mapping is being executed or an autocommand is</a>
<a name="ln2764">/// busy.</a>
<a name="ln2765">///</a>
<a name="ln2766">/// @param focus  called for GUI focus event</a>
<a name="ln2767">///</a>
<a name="ln2768">/// @return       true if some message was written (screen should be redrawn and cursor positioned).</a>
<a name="ln2769">int check_timestamps(int focus)</a>
<a name="ln2770">{</a>
<a name="ln2771">  // Don't check timestamps while system() or another low-level function may</a>
<a name="ln2772">  // cause us to lose and gain focus.</a>
<a name="ln2773">  if (no_check_timestamps &gt; 0) {</a>
<a name="ln2774">    return false;</a>
<a name="ln2775">  }</a>
<a name="ln2776"> </a>
<a name="ln2777">  // Avoid doing a check twice.  The OK/Reload dialog can cause a focus</a>
<a name="ln2778">  // event and we would keep on checking if the file is steadily growing.</a>
<a name="ln2779">  // Do check again after typing something.</a>
<a name="ln2780">  if (focus &amp;&amp; did_check_timestamps) {</a>
<a name="ln2781">    need_check_timestamps = true;</a>
<a name="ln2782">    return false;</a>
<a name="ln2783">  }</a>
<a name="ln2784"> </a>
<a name="ln2785">  int didit = 0;</a>
<a name="ln2786"> </a>
<a name="ln2787">  if (!stuff_empty() || global_busy || !typebuf_typed()</a>
<a name="ln2788">      || autocmd_busy || curbuf-&gt;b_ro_locked &gt; 0</a>
<a name="ln2789">      || allbuf_lock &gt; 0) {</a>
<a name="ln2790">    need_check_timestamps = true;               // check later</a>
<a name="ln2791">  } else {</a>
<a name="ln2792">    no_wait_return++;</a>
<a name="ln2793">    did_check_timestamps = true;</a>
<a name="ln2794">    already_warned = false;</a>
<a name="ln2795">    FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2796">      // Only check buffers in a window.</a>
<a name="ln2797">      if (buf-&gt;b_nwindows &gt; 0) {</a>
<a name="ln2798">        bufref_T bufref;</a>
<a name="ln2799">        set_bufref(&amp;bufref, buf);</a>
<a name="ln2800">        const int n = buf_check_timestamp(buf);</a>
<a name="ln2801">        if (didit &lt; n) {</a>
<a name="ln2802">          didit = n;</a>
<a name="ln2803">        }</a>
<a name="ln2804">        if (n &gt; 0 &amp;&amp; !bufref_valid(&amp;bufref)) {</a>
<a name="ln2805">          // Autocommands have removed the buffer, start at the first one again.</a>
<a name="ln2806">          buf = firstbuf;</a>
<a name="ln2807">          continue;</a>
<a name="ln2808">        }</a>
<a name="ln2809">      }</a>
<a name="ln2810">    }</a>
<a name="ln2811">    no_wait_return--;</a>
<a name="ln2812">    need_check_timestamps = false;</a>
<a name="ln2813">    if (need_wait_return &amp;&amp; didit == 2) {</a>
<a name="ln2814">      // make sure msg isn't overwritten</a>
<a name="ln2815">      msg_puts(&quot;\n&quot;);</a>
<a name="ln2816">      ui_flush();</a>
<a name="ln2817">    }</a>
<a name="ln2818">  }</a>
<a name="ln2819">  return didit;</a>
<a name="ln2820">}</a>
<a name="ln2821"> </a>
<a name="ln2822">/// Move all the lines from buffer &quot;frombuf&quot; to buffer &quot;tobuf&quot;.</a>
<a name="ln2823">///</a>
<a name="ln2824">/// @return  OK or FAIL.</a>
<a name="ln2825">///          When FAIL &quot;tobuf&quot; is incomplete and/or &quot;frombuf&quot; is not empty.</a>
<a name="ln2826">static int move_lines(buf_T *frombuf, buf_T *tobuf)</a>
<a name="ln2827">{</a>
<a name="ln2828">  buf_T *tbuf = curbuf;</a>
<a name="ln2829">  int retval = OK;</a>
<a name="ln2830"> </a>
<a name="ln2831">  // Copy the lines in &quot;frombuf&quot; to &quot;tobuf&quot;.</a>
<a name="ln2832">  curbuf = tobuf;</a>
<a name="ln2833">  for (linenr_T lnum = 1; lnum &lt;= frombuf-&gt;b_ml.ml_line_count; lnum++) {</a>
<a name="ln2834">    char *p = xstrdup(ml_get_buf(frombuf, lnum));</a>
<a name="ln2835">    if (ml_append(lnum - 1, p, 0, false) == FAIL) {</a>
<a name="ln2836">      xfree(p);</a>
<a name="ln2837">      retval = FAIL;</a>
<a name="ln2838">      break;</a>
<a name="ln2839">    }</a>
<a name="ln2840">    xfree(p);</a>
<a name="ln2841">  }</a>
<a name="ln2842"> </a>
<a name="ln2843">  // Delete all the lines in &quot;frombuf&quot;.</a>
<a name="ln2844">  if (retval != FAIL) {</a>
<a name="ln2845">    curbuf = frombuf;</a>
<a name="ln2846">    for (linenr_T lnum = curbuf-&gt;b_ml.ml_line_count; lnum &gt; 0; lnum--) {</a>
<a name="ln2847">      if (ml_delete(lnum, false) == FAIL) {</a>
<a name="ln2848">        // Oops!  We could try putting back the saved lines, but that</a>
<a name="ln2849">        // might fail again...</a>
<a name="ln2850">        retval = FAIL;</a>
<a name="ln2851">        break;</a>
<a name="ln2852">      }</a>
<a name="ln2853">    }</a>
<a name="ln2854">  }</a>
<a name="ln2855"> </a>
<a name="ln2856">  curbuf = tbuf;</a>
<a name="ln2857">  return retval;</a>
<a name="ln2858">}</a>
<a name="ln2859"> </a>
<a name="ln2860">/// Check if buffer &quot;buf&quot; has been changed.</a>
<a name="ln2861">/// Also check if the file for a new buffer unexpectedly appeared.</a>
<a name="ln2862">///</a>
<a name="ln2863">/// @return  1 if a changed buffer was found or,</a>
<a name="ln2864">///          2 if a message has been displayed or,</a>
<a name="ln2865">///          0 otherwise.</a>
<a name="ln2866">int buf_check_timestamp(buf_T *buf)</a>
<a name="ln2867">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2868">{</a>
<a name="ln2869">  int retval = 0;</a>
<a name="ln2870">  char *mesg = NULL;</a>
<a name="ln2871">  char *mesg2 = &quot;&quot;;</a>
<a name="ln2872">  bool helpmesg = false;</a>
<a name="ln2873"> </a>
<a name="ln2874">  enum {</a>
<a name="ln2875">    RELOAD_NONE,</a>
<a name="ln2876">    RELOAD_NORMAL,</a>
<a name="ln2877">    RELOAD_DETECT,</a>
<a name="ln2878">  } reload = RELOAD_NONE;</a>
<a name="ln2879"> </a>
<a name="ln2880">  bool can_reload = false;</a>
<a name="ln2881">  uint64_t orig_size = buf-&gt;b_orig_size;</a>
<a name="ln2882">  int orig_mode = buf-&gt;b_orig_mode;</a>
<a name="ln2883">  static bool busy = false;</a>
<a name="ln2884"> </a>
<a name="ln2885">  bufref_T bufref;</a>
<a name="ln2886">  set_bufref(&amp;bufref, buf);</a>
<a name="ln2887"> </a>
<a name="ln2888">  // If its a terminal, there is no file name, the buffer is not loaded,</a>
<a name="ln2889">  // 'buftype' is set, we are in the middle of a save or being called</a>
<a name="ln2890">  // recursively: ignore this buffer.</a>
<a name="ln2891">  if (buf-&gt;terminal</a>
<a name="ln2892">      || buf-&gt;b_ffname == NULL</a>
<a name="ln2893">      || buf-&gt;b_ml.ml_mfp == NULL</a>
<a name="ln2894">      || !bt_normal(buf)</a>
<a name="ln2895">      || buf-&gt;b_saving</a>
<a name="ln2896">      || busy) {</a>
<a name="ln2897">    return 0;</a>
<a name="ln2898">  }</a>
<a name="ln2899"> </a>
<a name="ln2900">  FileInfo file_info;</a>
<a name="ln2901">  bool file_info_ok;</a>
<a name="ln2902">  if (!(buf-&gt;b_flags &amp; BF_NOTEDITED)</a>
<a name="ln2903">      &amp;&amp; buf-&gt;b_mtime != 0</a>
<a name="ln2904">      &amp;&amp; (!(file_info_ok = os_fileinfo(buf-&gt;b_ffname, &amp;file_info))</a>
<a name="ln2905">          || time_differs(&amp;file_info, buf-&gt;b_mtime, buf-&gt;b_mtime_ns)</a>
<a name="ln2906">          || (int)file_info.stat.st_mode != buf-&gt;b_orig_mode)) {</a>
<a name="ln2907">    const long prev_b_mtime = buf-&gt;b_mtime;</a>
<a name="ln2908"> </a>
<a name="ln2909">    retval = 1;</a>
<a name="ln2910"> </a>
<a name="ln2911">    // set b_mtime to stop further warnings (e.g., when executing</a>
<a name="ln2912">    // FileChangedShell autocmd)</a>
<a name="ln2913">    if (!file_info_ok) {</a>
<a name="ln2914">      // Check the file again later to see if it re-appears.</a>
<a name="ln2915">      buf-&gt;b_mtime = -1;</a>
<a name="ln2916">      buf-&gt;b_orig_size = 0;</a>
<a name="ln2917">      buf-&gt;b_orig_mode = 0;</a>
<a name="ln2918">    } else {</a>
<a name="ln2919">      buf_store_file_info(buf, &amp;file_info);</a>
<a name="ln2920">    }</a>
<a name="ln2921"> </a>
<a name="ln2922">    if (os_isdir(buf-&gt;b_fname)) {</a>
<a name="ln2923">      // Don't do anything for a directory.  Might contain the file explorer.</a>
<a name="ln2924">    } else if ((buf-&gt;b_p_ar &gt;= 0 ? buf-&gt;b_p_ar : p_ar)</a>
<a name="ln2925">               &amp;&amp; !bufIsChanged(buf) &amp;&amp; file_info_ok) {</a>
<a name="ln2926">      // If 'autoread' is set, the buffer has no changes and the file still</a>
<a name="ln2927">      // exists, reload the buffer.  Use the buffer-local option value if it</a>
<a name="ln2928">      // was set, the global option value otherwise.</a>
<a name="ln2929">      reload = RELOAD_NORMAL;</a>
<a name="ln2930">    } else {</a>
<a name="ln2931">      char *reason;</a>
<a name="ln2932">      if (!file_info_ok) {</a>
<a name="ln2933">        reason = &quot;deleted&quot;;</a>
<a name="ln2934">      } else if (bufIsChanged(buf)) {</a>
<a name="ln2935">        reason = &quot;conflict&quot;;</a>
<a name="ln2936">      } else if (orig_size != buf-&gt;b_orig_size || buf_contents_changed(buf)) {</a>
<a name="ln2937">        reason = &quot;changed&quot;;</a>
<a name="ln2938">      } else if (orig_mode != buf-&gt;b_orig_mode) {</a>
<a name="ln2939">        reason = &quot;mode&quot;;</a>
<a name="ln2940">      } else {</a>
<a name="ln2941">        reason = &quot;time&quot;;</a>
<a name="ln2942">      }</a>
<a name="ln2943"> </a>
<a name="ln2944">      // Only give the warning if there are no FileChangedShell</a>
<a name="ln2945">      // autocommands.</a>
<a name="ln2946">      // Avoid being called recursively by setting &quot;busy&quot;.</a>
<a name="ln2947">      busy = true;</a>
<a name="ln2948">      set_vim_var_string(VV_FCS_REASON, reason, -1);</a>
<a name="ln2949">      set_vim_var_string(VV_FCS_CHOICE, &quot;&quot;, -1);</a>
<a name="ln2950">      allbuf_lock++;</a>
<a name="ln2951">      bool n = apply_autocmds(EVENT_FILECHANGEDSHELL, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln2952">      allbuf_lock--;</a>
<a name="ln2953">      busy = false;</a>
<a name="ln2954">      if (n) {</a>
<a name="ln2955">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2956">          emsg(_(&quot;E246: FileChangedShell autocommand deleted buffer&quot;));</a>
<a name="ln2957">        }</a>
<a name="ln2958">        char *s = get_vim_var_str(VV_FCS_CHOICE);</a>
<a name="ln2959">        if (strcmp(s, &quot;reload&quot;) == 0 &amp;&amp; *reason != 'd') {</a>
<a name="ln2960">          reload = RELOAD_NORMAL;</a>
<a name="ln2961">        } else if (strcmp(s, &quot;edit&quot;) == 0) {</a>
<a name="ln2962">          reload = RELOAD_DETECT;</a>
<a name="ln2963">        } else if (strcmp(s, &quot;ask&quot;) == 0) {</a>
<a name="ln2964">          n = false;</a>
<a name="ln2965">        } else {</a>
<a name="ln2966">          return 2;</a>
<a name="ln2967">        }</a>
<a name="ln2968">      }</a>
<a name="ln2969">      if (!n) {</a>
<a name="ln2970">        if (*reason == 'd') {</a>
<a name="ln2971">          // Only give the message once.</a>
<a name="ln2972">          if (prev_b_mtime != -1) {</a>
<a name="ln2973">            mesg = _(&quot;E211: File \&quot;%s\&quot; no longer available&quot;);</a>
<a name="ln2974">          }</a>
<a name="ln2975">        } else {</a>
<a name="ln2976">          helpmesg = true;</a>
<a name="ln2977">          can_reload = true;</a>
<a name="ln2978"> </a>
<a name="ln2979">          // Check if the file contents really changed to avoid</a>
<a name="ln2980">          // giving a warning when only the timestamp was set (e.g.,</a>
<a name="ln2981">          // checked out of CVS).  Always warn when the buffer was</a>
<a name="ln2982">          // changed.</a>
<a name="ln2983">          if (reason[2] == 'n') {</a>
<a name="ln2984">            mesg = _(</a>
<a name="ln2985">                    &quot;W12: Warning: File \&quot;%s\&quot; has changed and the buffer was changed in Vim as well&quot;);</a>
<a name="ln2986">            mesg2 = _(&quot;See \&quot;:help W12\&quot; for more info.&quot;);</a>
<a name="ln2987">          } else if (reason[1] == 'h') {</a>
<a name="ln2988">            mesg = _(&quot;W11: Warning: File \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln2989">            mesg2 = _(&quot;See \&quot;:help W11\&quot; for more info.&quot;);</a>
<a name="ln2990">          } else if (*reason == 'm') {</a>
<a name="ln2991">            mesg = _(&quot;W16: Warning: Mode of file \&quot;%s\&quot; has changed since editing started&quot;);</a>
<a name="ln2992">            mesg2 = _(&quot;See \&quot;:help W16\&quot; for more info.&quot;);</a>
<a name="ln2993">          } else {</a>
<a name="ln2994">            // Only timestamp changed, store it to avoid a warning</a>
<a name="ln2995">            // in check_mtime() later.</a>
<a name="ln2996">            buf-&gt;b_mtime_read = buf-&gt;b_mtime;</a>
<a name="ln2997">            buf-&gt;b_mtime_read_ns = buf-&gt;b_mtime_ns;</a>
<a name="ln2998">          }</a>
<a name="ln2999">        }</a>
<a name="ln3000">      }</a>
<a name="ln3001">    }</a>
<a name="ln3002">  } else if ((buf-&gt;b_flags &amp; BF_NEW) &amp;&amp; !(buf-&gt;b_flags &amp; BF_NEW_W)</a>
<a name="ln3003">             &amp;&amp; os_path_exists(buf-&gt;b_ffname)) {</a>
<a name="ln3004">    retval = 1;</a>
<a name="ln3005">    mesg = _(&quot;W13: Warning: File \&quot;%s\&quot; has been created after editing started&quot;);</a>
<a name="ln3006">    buf-&gt;b_flags |= BF_NEW_W;</a>
<a name="ln3007">    can_reload = true;</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010">  if (mesg != NULL) {</a>
<a name="ln3011">    char *path = home_replace_save(buf, buf-&gt;b_fname);</a>
<a name="ln3012">    if (!helpmesg) {</a>
<a name="ln3013">      mesg2 = &quot;&quot;;</a>
<a name="ln3014">    }</a>
<a name="ln3015">    const size_t tbuf_len = strlen(path) + strlen(mesg) + strlen(mesg2) + 2;</a>
<a name="ln3016">    char *const tbuf = xmalloc(tbuf_len);</a>
<a name="ln3017">    snprintf(tbuf, tbuf_len, mesg, path);</a>
<a name="ln3018">    // Set warningmsg here, before the unimportant and output-specific</a>
<a name="ln3019">    // mesg2 has been appended.</a>
<a name="ln3020">    set_vim_var_string(VV_WARNINGMSG, tbuf, -1);</a>
<a name="ln3021">    if (can_reload) {</a>
<a name="ln3022">      if (*mesg2 != NUL) {</a>
<a name="ln3023">        xstrlcat(tbuf, &quot;\n&quot;, tbuf_len - 1);</a>
<a name="ln3024">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln3025">      }</a>
<a name="ln3026">      switch (do_dialog(VIM_WARNING, _(&quot;Warning&quot;), tbuf,</a>
<a name="ln3027">                        _(&quot;&amp;OK\n&amp;Load File\nLoad File &amp;and Options&quot;),</a>
<a name="ln3028">                        1, NULL, true)) {</a>
<a name="ln3029">      case 2:</a>
<a name="ln3030">        reload = RELOAD_NORMAL;</a>
<a name="ln3031">        break;</a>
<a name="ln3032">      case 3:</a>
<a name="ln3033">        reload = RELOAD_DETECT;</a>
<a name="ln3034">        break;</a>
<a name="ln3035">      }</a>
<a name="ln3036">    } else if (State &gt; MODE_NORMAL_BUSY || (State &amp; MODE_CMDLINE) || already_warned) {</a>
<a name="ln3037">      if (*mesg2 != NUL) {</a>
<a name="ln3038">        xstrlcat(tbuf, &quot;; &quot;, tbuf_len - 1);</a>
<a name="ln3039">        xstrlcat(tbuf, mesg2, tbuf_len - 1);</a>
<a name="ln3040">      }</a>
<a name="ln3041">      emsg(tbuf);</a>
<a name="ln3042">      retval = 2;</a>
<a name="ln3043">    } else {</a>
<a name="ln3044">      if (!autocmd_busy) {</a>
<a name="ln3045">        msg_start();</a>
<a name="ln3046">        msg_puts_attr(tbuf, HL_ATTR(HLF_E) + MSG_HIST);</a>
<a name="ln3047">        if (*mesg2 != NUL) {</a>
<a name="ln3048">          msg_puts_attr(mesg2, HL_ATTR(HLF_W) + MSG_HIST);</a>
<a name="ln3049">        }</a>
<a name="ln3050">        msg_clr_eos();</a>
<a name="ln3051">        (void)msg_end();</a>
<a name="ln3052">        if (emsg_silent == 0 &amp;&amp; !in_assert_fails) {</a>
<a name="ln3053">          ui_flush();</a>
<a name="ln3054">          // give the user some time to think about it</a>
<a name="ln3055">          os_delay(1004L, true);</a>
<a name="ln3056"> </a>
<a name="ln3057">          // don't redraw and erase the message</a>
<a name="ln3058">          redraw_cmdline = false;</a>
<a name="ln3059">        }</a>
<a name="ln3060">      }</a>
<a name="ln3061">      already_warned = true;</a>
<a name="ln3062">    }</a>
<a name="ln3063"> </a>
<a name="ln3064">    xfree(path);</a>
<a name="ln3065">    xfree(tbuf);</a>
<a name="ln3066">  }</a>
<a name="ln3067"> </a>
<a name="ln3068">  if (reload != RELOAD_NONE) {</a>
<a name="ln3069">    // Reload the buffer.</a>
<a name="ln3070">    buf_reload(buf, orig_mode, reload == RELOAD_DETECT);</a>
<a name="ln3071">    if (buf-&gt;b_p_udf &amp;&amp; buf-&gt;b_ffname != NULL) {</a>
<a name="ln3072">      uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln3073"> </a>
<a name="ln3074">      // Any existing undo file is unusable, write it now.</a>
<a name="ln3075">      u_compute_hash(buf, hash);</a>
<a name="ln3076">      u_write_undo(NULL, false, buf, hash);</a>
<a name="ln3077">    }</a>
<a name="ln3078">  }</a>
<a name="ln3079"> </a>
<a name="ln3080">  // Trigger FileChangedShell when the file was changed in any way.</a>
<a name="ln3081">  if (bufref_valid(&amp;bufref) &amp;&amp; retval != 0) {</a>
<a name="ln3082">    (void)apply_autocmds(EVENT_FILECHANGEDSHELLPOST, buf-&gt;b_fname, buf-&gt;b_fname, false, buf);</a>
<a name="ln3083">  }</a>
<a name="ln3084">  return retval;</a>
<a name="ln3085">}</a>
<a name="ln3086"> </a>
<a name="ln3087">/// Reload a buffer that is already loaded.</a>
<a name="ln3088">/// Used when the file was changed outside of Vim.</a>
<a name="ln3089">/// &quot;orig_mode&quot; is buf-&gt;b_orig_mode before the need for reloading was detected.</a>
<a name="ln3090">/// buf-&gt;b_orig_mode may have been reset already.</a>
<a name="ln3091">void buf_reload(buf_T *buf, int orig_mode, bool reload_options)</a>
<a name="ln3092">{</a>
<a name="ln3093">  exarg_T ea;</a>
<a name="ln3094">  int old_ro = buf-&gt;b_p_ro;</a>
<a name="ln3095">  buf_T *savebuf;</a>
<a name="ln3096">  bufref_T bufref;</a>
<a name="ln3097">  int saved = OK;</a>
<a name="ln3098">  aco_save_T aco;</a>
<a name="ln3099">  int flags = READ_NEW;</a>
<a name="ln3100"> </a>
<a name="ln3101">  // Set curwin/curbuf for &quot;buf&quot; and save some things.</a>
<a name="ln3102">  aucmd_prepbuf(&amp;aco, buf);</a>
<a name="ln3103"> </a>
<a name="ln3104">  // Unless reload_options is set, we only want to read the text from the</a>
<a name="ln3105">  // file, not reset the syntax highlighting, clear marks, diff status, etc.</a>
<a name="ln3106">  // Force the fileformat and encoding to be the same.</a>
<a name="ln3107">  if (reload_options) {</a>
<a name="ln3108">    CLEAR_FIELD(ea);</a>
<a name="ln3109">  } else {</a>
<a name="ln3110">    prep_exarg(&amp;ea, buf);</a>
<a name="ln3111">  }</a>
<a name="ln3112"> </a>
<a name="ln3113">  pos_T old_cursor = curwin-&gt;w_cursor;</a>
<a name="ln3114">  linenr_T old_topline = curwin-&gt;w_topline;</a>
<a name="ln3115"> </a>
<a name="ln3116">  if (p_ur &lt; 0 || curbuf-&gt;b_ml.ml_line_count &lt;= p_ur) {</a>
<a name="ln3117">    // Save all the text, so that the reload can be undone.</a>
<a name="ln3118">    // Sync first so that this is a separate undo-able action.</a>
<a name="ln3119">    u_sync(false);</a>
<a name="ln3120">    saved = u_savecommon(curbuf, 0, curbuf-&gt;b_ml.ml_line_count + 1, 0, true);</a>
<a name="ln3121">    flags |= READ_KEEP_UNDO;</a>
<a name="ln3122">  }</a>
<a name="ln3123"> </a>
<a name="ln3124">  // To behave like when a new file is edited (matters for</a>
<a name="ln3125">  // BufReadPost autocommands) we first need to delete the current</a>
<a name="ln3126">  // buffer contents.  But if reading the file fails we should keep</a>
<a name="ln3127">  // the old contents.  Can't use memory only, the file might be</a>
<a name="ln3128">  // too big.  Use a hidden buffer to move the buffer contents to.</a>
<a name="ln3129">  if (buf_is_empty(curbuf) || saved == FAIL) {</a>
<a name="ln3130">    savebuf = NULL;</a>
<a name="ln3131">  } else {</a>
<a name="ln3132">    // Allocate a buffer without putting it in the buffer list.</a>
<a name="ln3133">    savebuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);</a>
<a name="ln3134">    set_bufref(&amp;bufref, savebuf);</a>
<a name="ln3135">    if (savebuf != NULL &amp;&amp; buf == curbuf) {</a>
<a name="ln3136">      // Open the memline.</a>
<a name="ln3137">      curbuf = savebuf;</a>
<a name="ln3138">      curwin-&gt;w_buffer = savebuf;</a>
<a name="ln3139">      saved = ml_open(curbuf);</a>
<a name="ln3140">      curbuf = buf;</a>
<a name="ln3141">      curwin-&gt;w_buffer = buf;</a>
<a name="ln3142">    }</a>
<a name="ln3143">    if (savebuf == NULL || saved == FAIL || buf != curbuf</a>
<a name="ln3144">        || move_lines(buf, savebuf) == FAIL) {</a>
<a name="ln3145">      semsg(_(&quot;E462: Could not prepare for reloading \&quot;%s\&quot;&quot;),</a>
<a name="ln3146">            buf-&gt;b_fname);</a>
<a name="ln3147">      saved = FAIL;</a>
<a name="ln3148">    }</a>
<a name="ln3149">  }</a>
<a name="ln3150"> </a>
<a name="ln3151">  if (saved == OK) {</a>
<a name="ln3152">    curbuf-&gt;b_flags |= BF_CHECK_RO;           // check for RO again</a>
<a name="ln3153">    keep_filetype = true;                     // don't detect 'filetype'</a>
<a name="ln3154">    if (readfile(buf-&gt;b_ffname, buf-&gt;b_fname, (linenr_T)0, (linenr_T)0,</a>
<a name="ln3155">                 (linenr_T)MAXLNUM, &amp;ea, flags, false) != OK) {</a>
<a name="ln3156">      if (!aborting()) {</a>
<a name="ln3157">        semsg(_(&quot;E321: Could not reload \&quot;%s\&quot;&quot;), buf-&gt;b_fname);</a>
<a name="ln3158">      }</a>
<a name="ln3159">      if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref) &amp;&amp; buf == curbuf) {</a>
<a name="ln3160">        // Put the text back from the save buffer.  First</a>
<a name="ln3161">        // delete any lines that readfile() added.</a>
<a name="ln3162">        while (!buf_is_empty(curbuf)) {</a>
<a name="ln3163">          if (ml_delete(buf-&gt;b_ml.ml_line_count, false) == FAIL) {</a>
<a name="ln3164">            break;</a>
<a name="ln3165">          }</a>
<a name="ln3166">        }</a>
<a name="ln3167">        (void)move_lines(savebuf, buf);</a>
<a name="ln3168">      }</a>
<a name="ln3169">    } else if (buf == curbuf) {  // &quot;buf&quot; still valid.</a>
<a name="ln3170">      // Mark the buffer as unmodified and free undo info.</a>
<a name="ln3171">      unchanged(buf, true, true);</a>
<a name="ln3172">      if ((flags &amp; READ_KEEP_UNDO) == 0) {</a>
<a name="ln3173">        u_blockfree(buf);</a>
<a name="ln3174">        u_clearall(buf);</a>
<a name="ln3175">      } else {</a>
<a name="ln3176">        // Mark all undo states as changed.</a>
<a name="ln3177">        u_unchanged(curbuf);</a>
<a name="ln3178">      }</a>
<a name="ln3179">      buf_updates_unload(curbuf, true);</a>
<a name="ln3180">      curbuf-&gt;b_mod_set = true;</a>
<a name="ln3181">    }</a>
<a name="ln3182">  }</a>
<a name="ln3183">  xfree(ea.cmd);</a>
<a name="ln3184"> </a>
<a name="ln3185">  if (savebuf != NULL &amp;&amp; bufref_valid(&amp;bufref)) {</a>
<a name="ln3186">    wipe_buffer(savebuf, false);</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189">  // Invalidate diff info if necessary.</a>
<a name="ln3190">  diff_invalidate(curbuf);</a>
<a name="ln3191"> </a>
<a name="ln3192">  // Restore the topline and cursor position and check it (lines may</a>
<a name="ln3193">  // have been removed).</a>
<a name="ln3194">  if (old_topline &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln3195">    curwin-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3196">  } else {</a>
<a name="ln3197">    curwin-&gt;w_topline = old_topline;</a>
<a name="ln3198">  }</a>
<a name="ln3199">  curwin-&gt;w_cursor = old_cursor;</a>
<a name="ln3200">  check_cursor();</a>
<a name="ln3201">  update_topline(curwin);</a>
<a name="ln3202">  keep_filetype = false;</a>
<a name="ln3203"> </a>
<a name="ln3204">  // Update folds unless they are defined manually.</a>
<a name="ln3205">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln3206">    if (wp-&gt;w_buffer == curwin-&gt;w_buffer</a>
<a name="ln3207">        &amp;&amp; !foldmethodIsManual(wp)) {</a>
<a name="ln3208">      foldUpdateAll(wp);</a>
<a name="ln3209">    }</a>
<a name="ln3210">  }</a>
<a name="ln3211"> </a>
<a name="ln3212">  // If the mode didn't change and 'readonly' was set, keep the old</a>
<a name="ln3213">  // value; the user probably used the &quot;:view&quot; command.  But don't</a>
<a name="ln3214">  // reset it, might have had a read error.</a>
<a name="ln3215">  if (orig_mode == curbuf-&gt;b_orig_mode) {</a>
<a name="ln3216">    curbuf-&gt;b_p_ro |= old_ro;</a>
<a name="ln3217">  }</a>
<a name="ln3218"> </a>
<a name="ln3219">  // Modelines must override settings done by autocommands.</a>
<a name="ln3220">  do_modelines(0);</a>
<a name="ln3221"> </a>
<a name="ln3222">  // restore curwin/curbuf and a few other things</a>
<a name="ln3223">  aucmd_restbuf(&amp;aco);</a>
<a name="ln3224">  // Careful: autocommands may have made &quot;buf&quot; invalid!</a>
<a name="ln3225">}</a>
<a name="ln3226"> </a>
<a name="ln3227">void buf_store_file_info(buf_T *buf, FileInfo *file_info)</a>
<a name="ln3228">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3229">{</a>
<a name="ln3230">  buf-&gt;b_mtime = file_info-&gt;stat.st_mtim.tv_sec;</a>
<a name="ln3231">  buf-&gt;b_mtime_ns = file_info-&gt;stat.st_mtim.tv_nsec;</a>
<a name="ln3232">  buf-&gt;b_orig_size = os_fileinfo_size(file_info);</a>
<a name="ln3233">  buf-&gt;b_orig_mode = (int)file_info-&gt;stat.st_mode;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">/// Adjust the line with missing eol, used for the next write.</a>
<a name="ln3237">/// Used for do_filter(), when the input lines for the filter are deleted.</a>
<a name="ln3238">void write_lnum_adjust(linenr_T offset)</a>
<a name="ln3239">{</a>
<a name="ln3240">  if (curbuf-&gt;b_no_eol_lnum != 0) {     // only if there is a missing eol</a>
<a name="ln3241">    curbuf-&gt;b_no_eol_lnum += offset;</a>
<a name="ln3242">  }</a>
<a name="ln3243">}</a>
<a name="ln3244"> </a>
<a name="ln3245">#if defined(BACKSLASH_IN_FILENAME)</a>
<a name="ln3246">/// Convert all backslashes in fname to forward slashes in-place,</a>
<a name="ln3247">/// unless when it looks like a URL.</a>
<a name="ln3248">void forward_slash(char *fname)</a>
<a name="ln3249">{</a>
<a name="ln3250">  char *p;</a>
<a name="ln3251"> </a>
<a name="ln3252">  if (path_with_url(fname)) {</a>
<a name="ln3253">    return;</a>
<a name="ln3254">  }</a>
<a name="ln3255">  for (p = fname; *p != NUL; p++) {</a>
<a name="ln3256">    if (*p == '\\') {</a>
<a name="ln3257">      *p = '/';</a>
<a name="ln3258">    }</a>
<a name="ln3259">  }</a>
<a name="ln3260">}</a>
<a name="ln3261">#endif</a>
<a name="ln3262"> </a>
<a name="ln3263">/// Path to Nvim's own temp dir. Ends in a slash.</a>
<a name="ln3264">static char *vim_tempdir = NULL;</a>
<a name="ln3265">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3266">DIR *vim_tempdir_dp = NULL;  ///&lt; File descriptor of temp dir</a>
<a name="ln3267">#endif</a>
<a name="ln3268"> </a>
<a name="ln3269">/// Creates a directory for private use by this instance of Nvim, trying each of</a>
<a name="ln3270">/// `TEMP_DIR_NAMES` until one succeeds.</a>
<a name="ln3271">///</a>
<a name="ln3272">/// Only done once, the same directory is used for all temp files.</a>
<a name="ln3273">/// This method avoids security problems because of symlink attacks et al.</a>
<a name="ln3274">/// It's also a bit faster, because we only need to check for an existing</a>
<a name="ln3275">/// file when creating the directory and not for each temp file.</a>
<a name="ln3276">static void vim_mktempdir(void)</a>
<a name="ln3277">{</a>
<a name="ln3278">  static const char *temp_dirs[] = TEMP_DIR_NAMES;  // Try each of these until one succeeds.</a>
<a name="ln3279">  char tmp[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3280">  char path[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3281">  char user[40] = { 0 };</a>
<a name="ln3282"> </a>
<a name="ln3283">  (void)os_get_username(user, sizeof(user));</a>
<a name="ln3284">  // Usernames may contain slashes! #19240</a>
<a name="ln3285">  memchrsub(user, '/', '_', sizeof(user));</a>
<a name="ln3286">  memchrsub(user, '\\', '_', sizeof(user));</a>
<a name="ln3287"> </a>
<a name="ln3288">  // Make sure the umask doesn't remove the executable bit.</a>
<a name="ln3289">  // &quot;repl&quot; has been reported to use &quot;0177&quot;.</a>
<a name="ln3290">  mode_t umask_save = umask(0077);</a>
<a name="ln3291">  for (size_t i = 0; i &lt; ARRAY_SIZE(temp_dirs); i++) {</a>
<a name="ln3292">    // Expand environment variables, leave room for &quot;/tmp/nvim.&lt;user&gt;/XXXXXX/999999999&quot;.</a>
<a name="ln3293">    expand_env((char *)temp_dirs[i], tmp, TEMP_FILE_PATH_MAXLEN - 64);</a>
<a name="ln3294">    if (!os_isdir(tmp)) {</a>
<a name="ln3295">      continue;</a>
<a name="ln3296">    }</a>
<a name="ln3297"> </a>
<a name="ln3298">    // &quot;/tmp/&quot; exists, now try to create &quot;/tmp/nvim.&lt;user&gt;/&quot;.</a>
<a name="ln3299">    add_pathsep(tmp);</a>
<a name="ln3300"> </a>
<a name="ln3301">    const char *appname = get_appname();</a>
<a name="ln3302">    xstrlcat(tmp, appname, sizeof(tmp));</a>
<a name="ln3303">    xstrlcat(tmp, &quot;.&quot;, sizeof(tmp));</a>
<a name="ln3304">    xstrlcat(tmp, user, sizeof(tmp));</a>
<a name="ln3305">    (void)os_mkdir(tmp, 0700);  // Always create, to avoid a race.</a>
<a name="ln3306">    bool owned = os_file_owned(tmp);</a>
<a name="ln3307">    bool isdir = os_isdir(tmp);</a>
<a name="ln3308">#ifdef UNIX</a>
<a name="ln3309">    int perm = os_getperm(tmp);  // XDG_RUNTIME_DIR must be owned by the user, mode 0700.</a>
<a name="ln3310">    bool valid = isdir &amp;&amp; owned &amp;&amp; 0700 == (perm &amp; 0777);</a>
<a name="ln3311">#else</a>
<a name="ln3312">    bool valid = isdir &amp;&amp; owned;  // TODO(justinmk): Windows ACL?</a>
<a name="ln3313">#endif</a>
<a name="ln3314">    if (valid) {</a>
<a name="ln3315">      add_pathsep(tmp);</a>
<a name="ln3316">    } else {</a>
<a name="ln3317">      if (!owned) {</a>
<a name="ln3318">        ELOG(&quot;tempdir root not owned by current user (%s): %s&quot;, user, tmp);</a>
<a name="ln3319">      } else if (!isdir) {</a>
<a name="ln3320">        ELOG(&quot;tempdir root not a directory: %s&quot;, tmp);</a>
<a name="ln3321">      }</a>
<a name="ln3322">#ifdef UNIX</a>
<a name="ln3323">      if (0700 != (perm &amp; 0777)) {</a>
<a name="ln3324">        ELOG(&quot;tempdir root has invalid permissions (%o): %s&quot;, perm, tmp);</a>
<a name="ln3325">      }</a>
<a name="ln3326">#endif</a>
<a name="ln3327">      // If our &quot;root&quot; tempdir is invalid or fails, proceed without &quot;&lt;user&gt;/&quot;.</a>
<a name="ln3328">      // Else user1 could break user2 by creating &quot;/tmp/nvim.user2/&quot;.</a>
<a name="ln3329">      tmp[strlen(tmp) - strlen(user)] = '\0';</a>
<a name="ln3330">    }</a>
<a name="ln3331"> </a>
<a name="ln3332">    // Now try to create &quot;/tmp/nvim.&lt;user&gt;/XXXXXX&quot;.</a>
<a name="ln3333">    xstrlcat(tmp, &quot;XXXXXX&quot;, sizeof(tmp));  // mkdtemp &quot;template&quot;, will be replaced with random alphanumeric chars.</a>
<a name="ln3334">    int r = os_mkdtemp(tmp, path);</a>
<a name="ln3335">    if (r != 0) {</a>
<a name="ln3336">      WLOG(&quot;tempdir create failed: %s: %s&quot;, os_strerror(r), tmp);</a>
<a name="ln3337">      continue;</a>
<a name="ln3338">    }</a>
<a name="ln3339"> </a>
<a name="ln3340">    if (vim_settempdir(path)) {</a>
<a name="ln3341">      // Successfully created and set temporary directory so stop trying.</a>
<a name="ln3342">      break;</a>
<a name="ln3343">    }</a>
<a name="ln3344">    // Couldn't set `vim_tempdir` to `path` so remove created directory.</a>
<a name="ln3345">    os_rmdir(path);</a>
<a name="ln3346">  }</a>
<a name="ln3347">  (void)umask(umask_save);</a>
<a name="ln3348">}</a>
<a name="ln3349"> </a>
<a name="ln3350">/// Core part of &quot;readdir()&quot; function.</a>
<a name="ln3351">/// Retrieve the list of files/directories of &quot;path&quot; into &quot;gap&quot;.</a>
<a name="ln3352">///</a>
<a name="ln3353">/// @return  OK for success, FAIL for failure.</a>
<a name="ln3354">int readdir_core(garray_T *gap, const char *path, void *context, CheckItem checkitem)</a>
<a name="ln3355">  FUNC_ATTR_NONNULL_ARG(1, 2)</a>
<a name="ln3356">{</a>
<a name="ln3357">  ga_init(gap, (int)sizeof(char *), 20);</a>
<a name="ln3358"> </a>
<a name="ln3359">  Directory dir;</a>
<a name="ln3360">  if (!os_scandir(&amp;dir, path)) {</a>
<a name="ln3361">    smsg(_(e_notopen), path);</a>
<a name="ln3362">    return FAIL;</a>
<a name="ln3363">  }</a>
<a name="ln3364"> </a>
<a name="ln3365">  while (true) {</a>
<a name="ln3366">    const char *p = os_scandir_next(&amp;dir);</a>
<a name="ln3367">    if (p == NULL) {</a>
<a name="ln3368">      break;</a>
<a name="ln3369">    }</a>
<a name="ln3370"> </a>
<a name="ln3371">    bool ignore = (p[0] == '.' &amp;&amp; (p[1] == NUL || (p[1] == '.' &amp;&amp; p[2] == NUL)));</a>
<a name="ln3372">    if (!ignore &amp;&amp; checkitem != NULL) {</a>
<a name="ln3373">      varnumber_T r = checkitem(context, p);</a>
<a name="ln3374">      if (r &lt; 0) {</a>
<a name="ln3375">        break;</a>
<a name="ln3376">      }</a>
<a name="ln3377">      if (r == 0) {</a>
<a name="ln3378">        ignore = true;</a>
<a name="ln3379">      }</a>
<a name="ln3380">    }</a>
<a name="ln3381"> </a>
<a name="ln3382">    if (!ignore) {</a>
<a name="ln3383">      ga_grow(gap, 1);</a>
<a name="ln3384">      ((char **)gap-&gt;ga_data)[gap-&gt;ga_len++] = xstrdup(p);</a>
<a name="ln3385">    }</a>
<a name="ln3386">  }</a>
<a name="ln3387"> </a>
<a name="ln3388">  os_closedir(&amp;dir);</a>
<a name="ln3389"> </a>
<a name="ln3390">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln3391">    sort_strings(gap-&gt;ga_data, gap-&gt;ga_len);</a>
<a name="ln3392">  }</a>
<a name="ln3393"> </a>
<a name="ln3394">  return OK;</a>
<a name="ln3395">}</a>
<a name="ln3396"> </a>
<a name="ln3397">/// Delete &quot;name&quot; and everything in it, recursively.</a>
<a name="ln3398">///</a>
<a name="ln3399">/// @param name  The path which should be deleted.</a>
<a name="ln3400">///</a>
<a name="ln3401">/// @return  0 for success, -1 if some file was not deleted.</a>
<a name="ln3402">int delete_recursive(const char *name)</a>
<a name="ln3403">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3404">{</a>
<a name="ln3405">  int result = 0;</a>
<a name="ln3406"> </a>
<a name="ln3407">  if (os_isrealdir(name)) {</a>
<a name="ln3408">    char *exp = xstrdup(name);</a>
<a name="ln3409">    garray_T ga;</a>
<a name="ln3410">    if (readdir_core(&amp;ga, exp, NULL, NULL) == OK) {</a>
<a name="ln3411">      for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln3412">        vim_snprintf(NameBuff, MAXPATHL, &quot;%s/%s&quot;, exp, ((char **)ga.ga_data)[i]);</a>
<a name="ln3413">        if (delete_recursive(NameBuff) != 0) {</a>
<a name="ln3414">          // Remember the failure but continue deleting any further</a>
<a name="ln3415">          // entries.</a>
<a name="ln3416">          result = -1;</a>
<a name="ln3417">        }</a>
<a name="ln3418">      }</a>
<a name="ln3419">      ga_clear_strings(&amp;ga);</a>
<a name="ln3420">      if (os_rmdir(exp) != 0) {</a>
<a name="ln3421">        result = -1;</a>
<a name="ln3422">      }</a>
<a name="ln3423">    } else {</a>
<a name="ln3424">      result = -1;</a>
<a name="ln3425">    }</a>
<a name="ln3426">    xfree(exp);</a>
<a name="ln3427">  } else {</a>
<a name="ln3428">    // Delete symlink only.</a>
<a name="ln3429">    result = os_remove(name) == 0 ? 0 : -1;</a>
<a name="ln3430">  }</a>
<a name="ln3431"> </a>
<a name="ln3432">  return result;</a>
<a name="ln3433">}</a>
<a name="ln3434"> </a>
<a name="ln3435">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3436">/// Open temporary directory and take file lock to prevent</a>
<a name="ln3437">/// to be auto-cleaned.</a>
<a name="ln3438">static void vim_opentempdir(void)</a>
<a name="ln3439">{</a>
<a name="ln3440">  if (vim_tempdir_dp != NULL) {</a>
<a name="ln3441">    return;</a>
<a name="ln3442">  }</a>
<a name="ln3443"> </a>
<a name="ln3444">  DIR *dp = opendir(vim_tempdir);</a>
<a name="ln3445">  if (dp == NULL) {</a>
<a name="ln3446">    return;</a>
<a name="ln3447">  }</a>
<a name="ln3448"> </a>
<a name="ln3449">  vim_tempdir_dp = dp;</a>
<a name="ln3450">  flock(dirfd(vim_tempdir_dp), LOCK_SH);</a>
<a name="ln3451">}</a>
<a name="ln3452"> </a>
<a name="ln3453">/// Close temporary directory - it automatically release file lock.</a>
<a name="ln3454">static void vim_closetempdir(void)</a>
<a name="ln3455">{</a>
<a name="ln3456">  if (vim_tempdir_dp == NULL) {</a>
<a name="ln3457">    return;</a>
<a name="ln3458">  }</a>
<a name="ln3459"> </a>
<a name="ln3460">  closedir(vim_tempdir_dp);</a>
<a name="ln3461">  vim_tempdir_dp = NULL;</a>
<a name="ln3462">}</a>
<a name="ln3463">#endif</a>
<a name="ln3464"> </a>
<a name="ln3465">/// Delete the temp directory and all files it contains.</a>
<a name="ln3466">void vim_deltempdir(void)</a>
<a name="ln3467">{</a>
<a name="ln3468">  if (vim_tempdir == NULL) {</a>
<a name="ln3469">    return;</a>
<a name="ln3470">  }</a>
<a name="ln3471"> </a>
<a name="ln3472">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3473">  vim_closetempdir();</a>
<a name="ln3474">#endif</a>
<a name="ln3475">  // remove the trailing path separator</a>
<a name="ln3476">  path_tail(vim_tempdir)[-1] = NUL;</a>
<a name="ln3477">  delete_recursive(vim_tempdir);</a>
<a name="ln3478">  XFREE_CLEAR(vim_tempdir);</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">/// Gets path to Nvim's own temp dir (ending with slash).</a>
<a name="ln3482">///</a>
<a name="ln3483">/// Creates the directory on the first call.</a>
<a name="ln3484">char *vim_gettempdir(void)</a>
<a name="ln3485">{</a>
<a name="ln3486">  static int notfound = 0;</a>
<a name="ln3487">  if (vim_tempdir == NULL || !os_isdir(vim_tempdir)) {</a>
<a name="ln3488">    if (vim_tempdir != NULL) {</a>
<a name="ln3489">      notfound++;</a>
<a name="ln3490">      if (notfound == 1) {</a>
<a name="ln3491">        ELOG(&quot;tempdir disappeared (antivirus or broken cleanup job?): %s&quot;, vim_tempdir);</a>
<a name="ln3492">      }</a>
<a name="ln3493">      if (notfound &gt; 1) {</a>
<a name="ln3494">        msg_schedule_semsg(&quot;E5431: tempdir disappeared (%d times)&quot;, notfound);</a>
<a name="ln3495">      }</a>
<a name="ln3496">      XFREE_CLEAR(vim_tempdir);</a>
<a name="ln3497">    }</a>
<a name="ln3498">    vim_mktempdir();</a>
<a name="ln3499">  }</a>
<a name="ln3500">  return vim_tempdir;</a>
<a name="ln3501">}</a>
<a name="ln3502"> </a>
<a name="ln3503">/// Sets Nvim's own temporary directory name to `tempdir`. This directory must</a>
<a name="ln3504">/// already exist. Expands the name to a full path and put it in `vim_tempdir`.</a>
<a name="ln3505">/// This avoids that using `:cd` would confuse us.</a>
<a name="ln3506">///</a>
<a name="ln3507">/// @param tempdir must be no longer than MAXPATHL.</a>
<a name="ln3508">///</a>
<a name="ln3509">/// @return false if we run out of memory.</a>
<a name="ln3510">static bool vim_settempdir(char *tempdir)</a>
<a name="ln3511">{</a>
<a name="ln3512">  char *buf = verbose_try_malloc(MAXPATHL + 2);</a>
<a name="ln3513">  if (buf == NULL) {</a>
<a name="ln3514">    return false;</a>
<a name="ln3515">  }</a>
<a name="ln3516"> </a>
<a name="ln3517">  vim_FullName(tempdir, buf, MAXPATHL, false);</a>
<a name="ln3518">  add_pathsep(buf);</a>
<a name="ln3519">  vim_tempdir = xstrdup(buf);</a>
<a name="ln3520">#ifdef HAVE_DIRFD_AND_FLOCK</a>
<a name="ln3521">  vim_opentempdir();</a>
<a name="ln3522">#endif</a>
<a name="ln3523">  xfree(buf);</a>
<a name="ln3524">  return true;</a>
<a name="ln3525">}</a>
<a name="ln3526"> </a>
<a name="ln3527">/// Return a unique name that can be used for a temp file.</a>
<a name="ln3528">///</a>
<a name="ln3529">/// @note The temp file is NOT created.</a>
<a name="ln3530">///</a>
<a name="ln3531">/// @return  pointer to the temp file name or NULL if Nvim can't create</a>
<a name="ln3532">///          temporary directory for its own temporary files.</a>
<a name="ln3533">char *vim_tempname(void)</a>
<a name="ln3534">{</a>
<a name="ln3535">  // Temp filename counter.</a>
<a name="ln3536">  static uint64_t temp_count;</a>
<a name="ln3537"> </a>
<a name="ln3538">  char *tempdir = vim_gettempdir();</a>
<a name="ln3539">  if (!tempdir) {</a>
<a name="ln3540">    return NULL;</a>
<a name="ln3541">  }</a>
<a name="ln3542"> </a>
<a name="ln3543">  // There is no need to check if the file exists, because we own the directory</a>
<a name="ln3544">  // and nobody else creates a file in it.</a>
<a name="ln3545">  char templ[TEMP_FILE_PATH_MAXLEN];</a>
<a name="ln3546">  snprintf(templ, TEMP_FILE_PATH_MAXLEN, &quot;%s%&quot; PRIu64, tempdir, temp_count++);</a>
<a name="ln3547">  return xstrdup(templ);</a>
<a name="ln3548">}</a>
<a name="ln3549"> </a>
<a name="ln3550">/// Tries matching a filename with a &quot;pattern&quot; (&quot;prog&quot; is NULL), or use the</a>
<a name="ln3551">/// precompiled regprog &quot;prog&quot; (&quot;pattern&quot; is NULL).  That avoids calling</a>
<a name="ln3552">/// vim_regcomp() often.</a>
<a name="ln3553">///</a>
<a name="ln3554">/// Used for autocommands and 'wildignore'.</a>
<a name="ln3555">///</a>
<a name="ln3556">/// @param pattern pattern to match with</a>
<a name="ln3557">/// @param prog pre-compiled regprog or NULL</a>
<a name="ln3558">/// @param fname full path of the file name</a>
<a name="ln3559">/// @param sfname short file name or NULL</a>
<a name="ln3560">/// @param tail tail of the path</a>
<a name="ln3561">/// @param allow_dirs Allow matching with dir</a>
<a name="ln3562">///</a>
<a name="ln3563">/// @return true if there is a match, false otherwise</a>
<a name="ln3564">bool match_file_pat(char *pattern, regprog_T **prog, char *fname, char *sfname, char *tail,</a>
<a name="ln3565">                    int allow_dirs)</a>
<a name="ln3566">{</a>
<a name="ln3567">  regmatch_T regmatch;</a>
<a name="ln3568">  bool result = false;</a>
<a name="ln3569"> </a>
<a name="ln3570">  regmatch.rm_ic = p_fic;   // ignore case if 'fileignorecase' is set</a>
<a name="ln3571">  regmatch.regprog = prog != NULL ? *prog : vim_regcomp(pattern, RE_MAGIC);</a>
<a name="ln3572"> </a>
<a name="ln3573">  // Try for a match with the pattern with:</a>
<a name="ln3574">  // 1. the full file name, when the pattern has a '/'.</a>
<a name="ln3575">  // 2. the short file name, when the pattern has a '/'.</a>
<a name="ln3576">  // 3. the tail of the file name, when the pattern has no '/'.</a>
<a name="ln3577">  if (regmatch.regprog != NULL</a>
<a name="ln3578">      &amp;&amp; ((allow_dirs</a>
<a name="ln3579">           &amp;&amp; (vim_regexec(&amp;regmatch, fname, (colnr_T)0)</a>
<a name="ln3580">               || (sfname != NULL</a>
<a name="ln3581">                   &amp;&amp; vim_regexec(&amp;regmatch, sfname, (colnr_T)0))))</a>
<a name="ln3582">          || (!allow_dirs &amp;&amp; vim_regexec(&amp;regmatch, tail, (colnr_T)0)))) {</a>
<a name="ln3583">    result = true;</a>
<a name="ln3584">  }</a>
<a name="ln3585"> </a>
<a name="ln3586">  if (prog != NULL) {</a>
<a name="ln3587">    *prog = regmatch.regprog;</a>
<a name="ln3588">  } else {</a>
<a name="ln3589">    vim_regfree(regmatch.regprog);</a>
<a name="ln3590">  }</a>
<a name="ln3591">  return result;</a>
<a name="ln3592">}</a>
<a name="ln3593"> </a>
<a name="ln3594">/// Check if a file matches with a pattern in &quot;list&quot;.</a>
<a name="ln3595">/// &quot;list&quot; is a comma-separated list of patterns, like 'wildignore'.</a>
<a name="ln3596">/// &quot;sfname&quot; is the short file name or NULL, &quot;ffname&quot; the long file name.</a>
<a name="ln3597">///</a>
<a name="ln3598">/// @param list list of patterns to match</a>
<a name="ln3599">/// @param sfname short file name</a>
<a name="ln3600">/// @param ffname full file name</a>
<a name="ln3601">///</a>
<a name="ln3602">/// @return true if there was a match</a>
<a name="ln3603">bool match_file_list(char *list, char *sfname, char *ffname)</a>
<a name="ln3604">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1, 3)</a>
<a name="ln3605">{</a>
<a name="ln3606">  char *tail = path_tail(sfname);</a>
<a name="ln3607"> </a>
<a name="ln3608">  // try all patterns in 'wildignore'</a>
<a name="ln3609">  char *p = list;</a>
<a name="ln3610">  while (*p) {</a>
<a name="ln3611">    char buf[MAXPATHL];</a>
<a name="ln3612">    copy_option_part(&amp;p, buf, ARRAY_SIZE(buf), &quot;,&quot;);</a>
<a name="ln3613">    char allow_dirs;</a>
<a name="ln3614">    char *regpat = file_pat_to_reg_pat(buf, NULL, &amp;allow_dirs, false);</a>
<a name="ln3615">    if (regpat == NULL) {</a>
<a name="ln3616">      break;</a>
<a name="ln3617">    }</a>
<a name="ln3618">    bool match = match_file_pat(regpat, NULL, ffname, sfname, tail, (int)allow_dirs);</a>
<a name="ln3619">    xfree(regpat);</a>
<a name="ln3620">    if (match) {</a>
<a name="ln3621">      return true;</a>
<a name="ln3622">    }</a>
<a name="ln3623">  }</a>
<a name="ln3624">  return false;</a>
<a name="ln3625">}</a>
<a name="ln3626"> </a>
<a name="ln3627">/// Convert the given pattern &quot;pat&quot; which has shell style wildcards in it, into</a>
<a name="ln3628">/// a regular expression, and return the result in allocated memory.  If there</a>
<a name="ln3629">/// is a directory path separator to be matched, then true is put in</a>
<a name="ln3630">/// allow_dirs, otherwise false is put there -- webb.</a>
<a name="ln3631">/// Handle backslashes before special characters, like &quot;\*&quot; and &quot;\ &quot;.</a>
<a name="ln3632">///</a>
<a name="ln3633">/// @param pat_end     first char after pattern or NULL</a>
<a name="ln3634">/// @param allow_dirs  Result passed back out in here</a>
<a name="ln3635">/// @param no_bslash   Don't use a backward slash as pathsep</a>
<a name="ln3636">///</a>
<a name="ln3637">/// @return            NULL on failure.</a>
<a name="ln3638">char *file_pat_to_reg_pat(const char *pat, const char *pat_end, char *allow_dirs, int no_bslash)</a>
<a name="ln3639">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3640">{</a>
<a name="ln3641">  if (allow_dirs != NULL) {</a>
<a name="ln3642">    *allow_dirs = false;</a>
<a name="ln3643">  }</a>
<a name="ln3644"> </a>
<a name="ln3645">  if (pat_end == NULL) {</a>
<a name="ln3646">    pat_end = pat + strlen(pat);</a>
<a name="ln3647">  }</a>
<a name="ln3648"> </a>
<a name="ln3649">  if (pat_end == pat) {</a>
<a name="ln3650">    return xstrdup(&quot;^$&quot;);</a>
<a name="ln3651">  }</a>
<a name="ln3652"> </a>
<a name="ln3653">  size_t size = 2;  // '^' at start, '$' at end.</a>
<a name="ln3654"> </a>
<a name="ln3655">  for (const char *p = pat; p &lt; pat_end; p++) {</a>
<a name="ln3656">    switch (*p) {</a>
<a name="ln3657">    case '*':</a>
<a name="ln3658">    case '.':</a>
<a name="ln3659">    case ',':</a>
<a name="ln3660">    case '{':</a>
<a name="ln3661">    case '}':</a>
<a name="ln3662">    case '~':</a>
<a name="ln3663">      size += 2;                // extra backslash</a>
<a name="ln3664">      break;</a>
<a name="ln3665">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3666">    case '\\':</a>
<a name="ln3667">    case '/':</a>
<a name="ln3668">      size += 4;                // could become &quot;[\/]&quot;</a>
<a name="ln3669">      break;</a>
<a name="ln3670">#endif</a>
<a name="ln3671">    default:</a>
<a name="ln3672">      size++;</a>
<a name="ln3673">      break;</a>
<a name="ln3674">    }</a>
<a name="ln3675">  }</a>
<a name="ln3676">  char *reg_pat = xmalloc(size + 1);</a>
<a name="ln3677"> </a>
<a name="ln3678">  size_t i = 0;</a>
<a name="ln3679"> </a>
<a name="ln3680">  if (pat[0] == '*') {</a>
<a name="ln3681">    while (pat[0] == '*' &amp;&amp; pat &lt; pat_end - 1) {</a>
<a name="ln3682">      pat++;</a>
<a name="ln3683">    }</a>
<a name="ln3684">  } else {</a>
<a name="ln3685">    reg_pat[i++] = '^';</a>
<a name="ln3686">  }</a>
<a name="ln3687">  const char *endp = pat_end - 1;</a>
<a name="ln3688">  bool add_dollar = true;</a>
<a name="ln3689">  if (endp &gt;= pat &amp;&amp; *endp == '*') {</a>
<a name="ln3690">    while (endp - pat &gt; 0 &amp;&amp; *endp == '*') {</a>
<a name="ln3691">      endp--;</a>
<a name="ln3692">    }</a>
<a name="ln3693">    add_dollar = false;</a>
<a name="ln3694">  }</a>
<a name="ln3695">  int nested = 0;</a>
<a name="ln3696">  for (const char *p = pat; *p &amp;&amp; nested &gt;= 0 &amp;&amp; p &lt;= endp; p++) {</a>
<a name="ln3697">    switch (*p) {</a>
<a name="ln3698">    case '*':</a>
<a name="ln3699">      reg_pat[i++] = '.';</a>
<a name="ln3700">      reg_pat[i++] = '*';</a>
<a name="ln3701">      while (p[1] == '*') {  // &quot;**&quot; matches like &quot;*&quot;</a>
<a name="ln3702">        p++;</a>
<a name="ln3703">      }</a>
<a name="ln3704">      break;</a>
<a name="ln3705">    case '.':</a>
<a name="ln3706">    case '~':</a>
<a name="ln3707">      reg_pat[i++] = '\\';</a>
<a name="ln3708">      reg_pat[i++] = *p;</a>
<a name="ln3709">      break;</a>
<a name="ln3710">    case '?':</a>
<a name="ln3711">      reg_pat[i++] = '.';</a>
<a name="ln3712">      break;</a>
<a name="ln3713">    case '\\':</a>
<a name="ln3714">      if (p[1] == NUL) {</a>
<a name="ln3715">        break;</a>
<a name="ln3716">      }</a>
<a name="ln3717">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3718">      if (!no_bslash) {</a>
<a name="ln3719">        // translate:</a>
<a name="ln3720">        // &quot;\x&quot; to &quot;\\x&quot;  e.g., &quot;dir\file&quot;</a>
<a name="ln3721">        // &quot;\*&quot; to &quot;\\.*&quot; e.g., &quot;dir\*.c&quot;</a>
<a name="ln3722">        // &quot;\?&quot; to &quot;\\.&quot;  e.g., &quot;dir\??.c&quot;</a>
<a name="ln3723">        // &quot;\+&quot; to &quot;\+&quot;   e.g., &quot;fileX\+.c&quot;</a>
<a name="ln3724">        if ((vim_isfilec((uint8_t)p[1]) || p[1] == '*' || p[1] == '?')</a>
<a name="ln3725">            &amp;&amp; p[1] != '+') {</a>
<a name="ln3726">          reg_pat[i++] = '[';</a>
<a name="ln3727">          reg_pat[i++] = '\\';</a>
<a name="ln3728">          reg_pat[i++] = '/';</a>
<a name="ln3729">          reg_pat[i++] = ']';</a>
<a name="ln3730">          if (allow_dirs != NULL) {</a>
<a name="ln3731">            *allow_dirs = true;</a>
<a name="ln3732">          }</a>
<a name="ln3733">          break;</a>
<a name="ln3734">        }</a>
<a name="ln3735">      }</a>
<a name="ln3736">#endif</a>
<a name="ln3737">      // Undo escaping from ExpandEscape():</a>
<a name="ln3738">      // foo\?bar -&gt; foo?bar</a>
<a name="ln3739">      // foo\%bar -&gt; foo%bar</a>
<a name="ln3740">      // foo\,bar -&gt; foo,bar</a>
<a name="ln3741">      // foo\ bar -&gt; foo bar</a>
<a name="ln3742">      // Don't unescape \, * and others that are also special in a</a>
<a name="ln3743">      // regexp.</a>
<a name="ln3744">      // An escaped { must be unescaped since we use magic not</a>
<a name="ln3745">      // verymagic.  Use &quot;\\\{n,m\}&quot;&quot; to get &quot;\{n,m}&quot;.</a>
<a name="ln3746">      if (*++p == '?' &amp;&amp; (!BACKSLASH_IN_FILENAME_BOOL || no_bslash)) {</a>
<a name="ln3747">        reg_pat[i++] = '?';</a>
<a name="ln3748">      } else if (*p == ',' || *p == '%' || *p == '#'</a>
<a name="ln3749">                 || ascii_isspace(*p) || *p == '{' || *p == '}') {</a>
<a name="ln3750">        reg_pat[i++] = *p;</a>
<a name="ln3751">      } else if (*p == '\\' &amp;&amp; p[1] == '\\' &amp;&amp; p[2] == '{') {</a>
<a name="ln3752">        reg_pat[i++] = '\\';</a>
<a name="ln3753">        reg_pat[i++] = '{';</a>
<a name="ln3754">        p += 2;</a>
<a name="ln3755">      } else {</a>
<a name="ln3756">        if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)</a>
<a name="ln3757">            &amp;&amp; (!BACKSLASH_IN_FILENAME_BOOL || (!no_bslash || *p != '\\'))) {</a>
<a name="ln3758">          *allow_dirs = true;</a>
<a name="ln3759">        }</a>
<a name="ln3760">        reg_pat[i++] = '\\';</a>
<a name="ln3761">        reg_pat[i++] = *p;</a>
<a name="ln3762">      }</a>
<a name="ln3763">      break;</a>
<a name="ln3764">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3765">    case '/':</a>
<a name="ln3766">      reg_pat[i++] = '[';</a>
<a name="ln3767">      reg_pat[i++] = '\\';</a>
<a name="ln3768">      reg_pat[i++] = '/';</a>
<a name="ln3769">      reg_pat[i++] = ']';</a>
<a name="ln3770">      if (allow_dirs != NULL) {</a>
<a name="ln3771">        *allow_dirs = true;</a>
<a name="ln3772">      }</a>
<a name="ln3773">      break;</a>
<a name="ln3774">#endif</a>
<a name="ln3775">    case '{':</a>
<a name="ln3776">      reg_pat[i++] = '\\';</a>
<a name="ln3777">      reg_pat[i++] = '(';</a>
<a name="ln3778">      nested++;</a>
<a name="ln3779">      break;</a>
<a name="ln3780">    case '}':</a>
<a name="ln3781">      reg_pat[i++] = '\\';</a>
<a name="ln3782">      reg_pat[i++] = ')';</a>
<a name="ln3783">      nested--;</a>
<a name="ln3784">      break;</a>
<a name="ln3785">    case ',':</a>
<a name="ln3786">      if (nested) {</a>
<a name="ln3787">        reg_pat[i++] = '\\';</a>
<a name="ln3788">        reg_pat[i++] = '|';</a>
<a name="ln3789">      } else {</a>
<a name="ln3790">        reg_pat[i++] = ',';</a>
<a name="ln3791">      }</a>
<a name="ln3792">      break;</a>
<a name="ln3793">    default:</a>
<a name="ln3794">      if (allow_dirs != NULL &amp;&amp; vim_ispathsep(*p)) {</a>
<a name="ln3795">        *allow_dirs = true;</a>
<a name="ln3796">      }</a>
<a name="ln3797">      reg_pat[i++] = *p;</a>
<a name="ln3798">      break;</a>
<a name="ln3799">    }</a>
<a name="ln3800">  }</a>
<a name="ln3801">  if (add_dollar) {</a>
<a name="ln3802">    reg_pat[i++] = '$';</a>
<a name="ln3803">  }</a>
<a name="ln3804">  reg_pat[i] = NUL;</a>
<a name="ln3805">  if (nested != 0) {</a>
<a name="ln3806">    if (nested &lt; 0) {</a>
<a name="ln3807">      emsg(_(&quot;E219: Missing {.&quot;));</a>
<a name="ln3808">    } else {</a>
<a name="ln3809">      emsg(_(&quot;E220: Missing }.&quot;));</a>
<a name="ln3810">    }</a>
<a name="ln3811">    XFREE_CLEAR(reg_pat);</a>
<a name="ln3812">  }</a>
<a name="ln3813">  return reg_pat;</a>
<a name="ln3814">}</a>
<a name="ln3815"> </a>
<a name="ln3816">#if defined(EINTR)</a>
<a name="ln3817"> </a>
<a name="ln3818">/// Version of read() that retries when interrupted by EINTR (possibly</a>
<a name="ln3819">/// by a SIGWINCH).</a>
<a name="ln3820">long read_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln3821">{</a>
<a name="ln3822">  long ret;</a>
<a name="ln3823"> </a>
<a name="ln3824">  while (true) {</a>
<a name="ln3825">    ret = read(fd, buf, (unsigned)bufsize);</a>
<a name="ln3826">    if (ret &gt;= 0 || errno != EINTR) {</a>
<a name="ln3827">      break;</a>
<a name="ln3828">    }</a>
<a name="ln3829">  }</a>
<a name="ln3830">  return ret;</a>
<a name="ln3831">}</a>
<a name="ln3832"> </a>
<a name="ln3833">/// Version of write() that retries when interrupted by EINTR (possibly</a>
<a name="ln3834">/// by a SIGWINCH).</a>
<a name="ln3835">long write_eintr(int fd, void *buf, size_t bufsize)</a>
<a name="ln3836">{</a>
<a name="ln3837">  long ret = 0;</a>
<a name="ln3838"> </a>
<a name="ln3839">  // Repeat the write() so long it didn't fail, other than being interrupted</a>
<a name="ln3840">  // by a signal.</a>
<a name="ln3841">  while (ret &lt; (long)bufsize) {</a>
<a name="ln3842">    long wlen = write(fd, (char *)buf + ret, (unsigned)(bufsize - (size_t)ret));</a>
<a name="ln3843">    if (wlen &lt; 0) {</a>
<a name="ln3844">      if (errno != EINTR) {</a>
<a name="ln3845">        break;</a>
<a name="ln3846">      }</a>
<a name="ln3847">    } else {</a>
<a name="ln3848">      ret += wlen;</a>
<a name="ln3849">    }</a>
<a name="ln3850">  }</a>
<a name="ln3851">  return ret;</a>
<a name="ln3852">}</a>
<a name="ln3853">#endif</a>
</code></pre>
<div class="balloon" rel="3329"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'strlen(tmp) - strlen(user)' index could reach 18446744073709551615.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>