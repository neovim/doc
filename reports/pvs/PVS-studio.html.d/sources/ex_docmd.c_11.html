<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ex_docmd.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// ex_docmd.c: functions for executing an Ex command line.</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;ctype.h&gt;</a>
<a name="ln8">#include &lt;inttypes.h&gt;</a>
<a name="ln9">#include &lt;limits.h&gt;</a>
<a name="ln10">#include &lt;stdbool.h&gt;</a>
<a name="ln11">#include &lt;stddef.h&gt;</a>
<a name="ln12">#include &lt;stdio.h&gt;</a>
<a name="ln13">#include &lt;stdlib.h&gt;</a>
<a name="ln14">#include &lt;string.h&gt;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;auto/config.h&quot;</a>
<a name="ln17">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/change.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/cmdexpand.h&quot;</a>
<a name="ln24">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln25">#include &quot;nvim/debugger.h&quot;</a>
<a name="ln26">#include &quot;nvim/digraph.h&quot;</a>
<a name="ln27">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln28">#include &quot;nvim/edit.h&quot;</a>
<a name="ln29">#include &quot;nvim/eval.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/typval_defs.h&quot;</a>
<a name="ln32">#include &quot;nvim/eval/userfunc.h&quot;</a>
<a name="ln33">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln36">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln37">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln38">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln39">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln40">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln41">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln42">#include &quot;nvim/fold.h&quot;</a>
<a name="ln43">#include &quot;nvim/garray.h&quot;</a>
<a name="ln44">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln45">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln46">#include &quot;nvim/globals.h&quot;</a>
<a name="ln47">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln48">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln49">#include &quot;nvim/input.h&quot;</a>
<a name="ln50">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln51">#include &quot;nvim/macros.h&quot;</a>
<a name="ln52">#include &quot;nvim/main.h&quot;</a>
<a name="ln53">#include &quot;nvim/mark.h&quot;</a>
<a name="ln54">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln55">#include &quot;nvim/memfile_defs.h&quot;</a>
<a name="ln56">#include &quot;nvim/memline.h&quot;</a>
<a name="ln57">#include &quot;nvim/memory.h&quot;</a>
<a name="ln58">#include &quot;nvim/message.h&quot;</a>
<a name="ln59">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln60">#include &quot;nvim/move.h&quot;</a>
<a name="ln61">#include &quot;nvim/normal.h&quot;</a>
<a name="ln62">#include &quot;nvim/ops.h&quot;</a>
<a name="ln63">#include &quot;nvim/option.h&quot;</a>
<a name="ln64">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln65">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln66">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln67">#include &quot;nvim/os/shell.h&quot;</a>
<a name="ln68">#include &quot;nvim/path.h&quot;</a>
<a name="ln69">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln70">#include &quot;nvim/pos.h&quot;</a>
<a name="ln71">#include &quot;nvim/profile.h&quot;</a>
<a name="ln72">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln73">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln74">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln75">#include &quot;nvim/search.h&quot;</a>
<a name="ln76">#include &quot;nvim/shada.h&quot;</a>
<a name="ln77">#include &quot;nvim/state.h&quot;</a>
<a name="ln78">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln79">#include &quot;nvim/strings.h&quot;</a>
<a name="ln80">#include &quot;nvim/tag.h&quot;</a>
<a name="ln81">#include &quot;nvim/types.h&quot;</a>
<a name="ln82">#include &quot;nvim/ui.h&quot;</a>
<a name="ln83">#include &quot;nvim/undo.h&quot;</a>
<a name="ln84">#include &quot;nvim/usercmd.h&quot;</a>
<a name="ln85">#include &quot;nvim/vim.h&quot;</a>
<a name="ln86">#include &quot;nvim/window.h&quot;</a>
<a name="ln87"> </a>
<a name="ln88">static const char e_ambiguous_use_of_user_defined_command[]</a>
<a name="ln89">  = N_(&quot;E464: Ambiguous use of user-defined command&quot;);</a>
<a name="ln90">static const char e_no_call_stack_to_substitute_for_stack[]</a>
<a name="ln91">  = N_(&quot;E489: No call stack to substitute for \&quot;&lt;stack&gt;\&quot;&quot;);</a>
<a name="ln92">static const char e_not_an_editor_command[]</a>
<a name="ln93">  = N_(&quot;E492: Not an editor command&quot;);</a>
<a name="ln94">static const char e_no_autocommand_file_name_to_substitute_for_afile[]</a>
<a name="ln95">  = N_(&quot;E495: No autocommand file name to substitute for \&quot;&lt;afile&gt;\&quot;&quot;);</a>
<a name="ln96">static const char e_no_autocommand_buffer_number_to_substitute_for_abuf[]</a>
<a name="ln97">  = N_(&quot;E496: No autocommand buffer number to substitute for \&quot;&lt;abuf&gt;\&quot;&quot;);</a>
<a name="ln98">static const char e_no_autocommand_match_name_to_substitute_for_amatch[]</a>
<a name="ln99">  = N_(&quot;E497: No autocommand match name to substitute for \&quot;&lt;amatch&gt;\&quot;&quot;);</a>
<a name="ln100">static const char e_no_source_file_name_to_substitute_for_sfile[]</a>
<a name="ln101">  = N_(&quot;E498: No :source file name to substitute for \&quot;&lt;sfile&gt;\&quot;&quot;);</a>
<a name="ln102">static const char e_no_line_number_to_use_for_slnum[]</a>
<a name="ln103">  = N_(&quot;E842: No line number to use for \&quot;&lt;slnum&gt;\&quot;&quot;);</a>
<a name="ln104">static const char e_no_line_number_to_use_for_sflnum[]</a>
<a name="ln105">  = N_(&quot;E961: No line number to use for \&quot;&lt;sflnum&gt;\&quot;&quot;);</a>
<a name="ln106">static const char e_no_script_file_name_to_substitute_for_script[]</a>
<a name="ln107">  = N_(&quot;E1274: No script file name to substitute for \&quot;&lt;script&gt;\&quot;&quot;);</a>
<a name="ln108"> </a>
<a name="ln109">static int quitmore = 0;</a>
<a name="ln110">static bool ex_pressedreturn = false;</a>
<a name="ln111"> </a>
<a name="ln112">// Struct for storing a line inside a while/for loop</a>
<a name="ln113">typedef struct {</a>
<a name="ln114">  char *line;            // command line</a>
<a name="ln115">  linenr_T lnum;                // sourcing_lnum of the line</a>
<a name="ln116">} wcmd_T;</a>
<a name="ln117"> </a>
<a name="ln118">#define FREE_WCMD(wcmd) xfree((wcmd)-&gt;line)</a>
<a name="ln119"> </a>
<a name="ln120">/// Structure used to store info for line position in a while or for loop.</a>
<a name="ln121">/// This is required, because do_one_cmd() may invoke ex_function(), which</a>
<a name="ln122">/// reads more lines that may come from the while/for loop.</a>
<a name="ln123">struct loop_cookie {</a>
<a name="ln124">  garray_T *lines_gap;               // growarray with line info</a>
<a name="ln125">  int current_line;                     // last read line from growarray</a>
<a name="ln126">  int repeating;                        // true when looping a second time</a>
<a name="ln127">  // When &quot;repeating&quot; is false use &quot;getline&quot; and &quot;cookie&quot; to get lines</a>
<a name="ln128">  char *(*getline)(int, void *, int, bool);</a>
<a name="ln129">  void *cookie;</a>
<a name="ln130">};</a>
<a name="ln131"> </a>
<a name="ln132">// Struct to save a few things while debugging.  Used in do_cmdline() only.</a>
<a name="ln133">struct dbg_stuff {</a>
<a name="ln134">  int trylevel;</a>
<a name="ln135">  int force_abort;</a>
<a name="ln136">  except_T *caught_stack;</a>
<a name="ln137">  char *vv_exception;</a>
<a name="ln138">  char *vv_throwpoint;</a>
<a name="ln139">  int did_emsg;</a>
<a name="ln140">  int got_int;</a>
<a name="ln141">  bool did_throw;</a>
<a name="ln142">  int need_rethrow;</a>
<a name="ln143">  int check_cstack;</a>
<a name="ln144">  except_T *current_exception;</a>
<a name="ln145">};</a>
<a name="ln146"> </a>
<a name="ln147">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln148"># include &quot;ex_docmd.c.generated.h&quot;</a>
<a name="ln149">#endif</a>
<a name="ln150"> </a>
<a name="ln151">#ifndef HAVE_WORKING_LIBINTL</a>
<a name="ln152"># define ex_language            ex_ni</a>
<a name="ln153">#endif</a>
<a name="ln154"> </a>
<a name="ln155">// Declare cmdnames[].</a>
<a name="ln156">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln157"># include &quot;ex_cmds_defs.generated.h&quot;</a>
<a name="ln158">#endif</a>
<a name="ln159"> </a>
<a name="ln160">static char dollar_command[2] = { '$', 0 };</a>
<a name="ln161"> </a>
<a name="ln162">static void save_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln163">{</a>
<a name="ln164">  dsp-&gt;trylevel       = trylevel;             trylevel = 0;</a>
<a name="ln165">  dsp-&gt;force_abort    = force_abort;          force_abort = false;</a>
<a name="ln166">  dsp-&gt;caught_stack   = caught_stack;         caught_stack = NULL;</a>
<a name="ln167">  dsp-&gt;vv_exception   = v_exception(NULL);</a>
<a name="ln168">  dsp-&gt;vv_throwpoint  = v_throwpoint(NULL);</a>
<a name="ln169"> </a>
<a name="ln170">  // Necessary for debugging an inactive &quot;:catch&quot;, &quot;:finally&quot;, &quot;:endtry&quot;.</a>
<a name="ln171">  dsp-&gt;did_emsg       = did_emsg;             did_emsg     = false;</a>
<a name="ln172">  dsp-&gt;got_int        = got_int;              got_int      = false;</a>
<a name="ln173">  dsp-&gt;did_throw      = did_throw;            did_throw    = false;</a>
<a name="ln174">  dsp-&gt;need_rethrow   = need_rethrow;         need_rethrow = false;</a>
<a name="ln175">  dsp-&gt;check_cstack   = check_cstack;         check_cstack = false;</a>
<a name="ln176">  dsp-&gt;current_exception = current_exception; current_exception = NULL;</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">static void restore_dbg_stuff(struct dbg_stuff *dsp)</a>
<a name="ln180">{</a>
<a name="ln181">  suppress_errthrow = false;</a>
<a name="ln182">  trylevel = dsp-&gt;trylevel;</a>
<a name="ln183">  force_abort = dsp-&gt;force_abort;</a>
<a name="ln184">  caught_stack = dsp-&gt;caught_stack;</a>
<a name="ln185">  (void)v_exception(dsp-&gt;vv_exception);</a>
<a name="ln186">  (void)v_throwpoint(dsp-&gt;vv_throwpoint);</a>
<a name="ln187">  did_emsg = dsp-&gt;did_emsg;</a>
<a name="ln188">  got_int = dsp-&gt;got_int;</a>
<a name="ln189">  did_throw = dsp-&gt;did_throw;</a>
<a name="ln190">  need_rethrow = dsp-&gt;need_rethrow;</a>
<a name="ln191">  check_cstack = dsp-&gt;check_cstack;</a>
<a name="ln192">  current_exception = dsp-&gt;current_exception;</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">/// Repeatedly get commands for Ex mode, until the &quot;:vi&quot; command is given.</a>
<a name="ln196">void do_exmode(void)</a>
<a name="ln197">{</a>
<a name="ln198">  exmode_active = true;</a>
<a name="ln199">  State = MODE_NORMAL;</a>
<a name="ln200">  may_trigger_modechanged();</a>
<a name="ln201"> </a>
<a name="ln202">  // When using &quot;:global /pat/ visual&quot; and then &quot;Q&quot; we return to continue</a>
<a name="ln203">  // the :global command.</a>
<a name="ln204">  if (global_busy) {</a>
<a name="ln205">    return;</a>
<a name="ln206">  }</a>
<a name="ln207"> </a>
<a name="ln208">  int save_msg_scroll = msg_scroll;</a>
<a name="ln209">  RedrawingDisabled++;  // don't redisplay the window</a>
<a name="ln210">  no_wait_return++;  // don't wait for return</a>
<a name="ln211"> </a>
<a name="ln212">  msg(_(&quot;Entering Ex mode.  Type \&quot;visual\&quot; to go to Normal mode.&quot;));</a>
<a name="ln213">  while (exmode_active) {</a>
<a name="ln214">    // Check for a &quot;:normal&quot; command and no more characters left.</a>
<a name="ln215">    if (ex_normal_busy &gt; 0 &amp;&amp; typebuf.tb_len == 0) {</a>
<a name="ln216">      exmode_active = false;</a>
<a name="ln217">      break;</a>
<a name="ln218">    }</a>
<a name="ln219">    msg_scroll = true;</a>
<a name="ln220">    need_wait_return = false;</a>
<a name="ln221">    ex_pressedreturn = false;</a>
<a name="ln222">    ex_no_reprint = false;</a>
<a name="ln223">    varnumber_T changedtick = buf_get_changedtick(curbuf);</a>
<a name="ln224">    int prev_msg_row = msg_row;</a>
<a name="ln225">    linenr_T prev_line = curwin-&gt;w_cursor.lnum;</a>
<a name="ln226">    cmdline_row = msg_row;</a>
<a name="ln227">    do_cmdline(NULL, getexline, NULL, 0);</a>
<a name="ln228">    lines_left = Rows - 1;</a>
<a name="ln229"> </a>
<a name="ln230">    if ((prev_line != curwin-&gt;w_cursor.lnum</a>
<a name="ln231">         || changedtick != buf_get_changedtick(curbuf)) &amp;&amp; !ex_no_reprint) {</a>
<a name="ln232">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln233">        emsg(_(e_empty_buffer));</a>
<a name="ln234">      } else {</a>
<a name="ln235">        if (ex_pressedreturn) {</a>
<a name="ln236">          // Make sure the message overwrites the right line and isn't throttled.</a>
<a name="ln237">          msg_scroll_flush();</a>
<a name="ln238">          // go up one line, to overwrite the &quot;:&lt;CR&gt;&quot; line, so the</a>
<a name="ln239">          // output doesn't contain empty lines.</a>
<a name="ln240">          msg_row = prev_msg_row;</a>
<a name="ln241">          if (prev_msg_row == Rows - 1) {</a>
<a name="ln242">            msg_row--;</a>
<a name="ln243">          }</a>
<a name="ln244">        }</a>
<a name="ln245">        msg_col = 0;</a>
<a name="ln246">        print_line_no_prefix(curwin-&gt;w_cursor.lnum, false, false);</a>
<a name="ln247">        msg_clr_eos();</a>
<a name="ln248">      }</a>
<a name="ln249">    } else if (ex_pressedreturn &amp;&amp; !ex_no_reprint) {  // must be at EOF</a>
<a name="ln250">      if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln251">        emsg(_(e_empty_buffer));</a>
<a name="ln252">      } else {</a>
<a name="ln253">        emsg(_(&quot;E501: At end-of-file&quot;));</a>
<a name="ln254">      }</a>
<a name="ln255">    }</a>
<a name="ln256">  }</a>
<a name="ln257"> </a>
<a name="ln258">  RedrawingDisabled--;</a>
<a name="ln259">  no_wait_return--;</a>
<a name="ln260">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln261">  update_screen();</a>
<a name="ln262">  need_wait_return = false;</a>
<a name="ln263">  msg_scroll = save_msg_scroll;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">/// Print the executed command for when 'verbose' is set.</a>
<a name="ln267">///</a>
<a name="ln268">/// @param lnum  if 0, only print the command.</a>
<a name="ln269">static void msg_verbose_cmd(linenr_T lnum, char *cmd)</a>
<a name="ln270">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln271">{</a>
<a name="ln272">  no_wait_return++;</a>
<a name="ln273">  verbose_enter_scroll();</a>
<a name="ln274"> </a>
<a name="ln275">  if (lnum == 0) {</a>
<a name="ln276">    smsg(_(&quot;Executing: %s&quot;), cmd);</a>
<a name="ln277">  } else {</a>
<a name="ln278">    smsg(_(&quot;line %&quot; PRIdLINENR &quot;: %s&quot;), lnum, cmd);</a>
<a name="ln279">  }</a>
<a name="ln280">  if (msg_silent == 0) {</a>
<a name="ln281">    msg_puts(&quot;\n&quot;);   // don't overwrite this</a>
<a name="ln282">  }</a>
<a name="ln283"> </a>
<a name="ln284">  verbose_leave_scroll();</a>
<a name="ln285">  no_wait_return--;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/// Execute a simple command line.  Used for translated commands like &quot;*&quot;.</a>
<a name="ln289">int do_cmdline_cmd(const char *cmd)</a>
<a name="ln290">{</a>
<a name="ln291">  return do_cmdline((char *)cmd, NULL, NULL, DOCMD_VERBOSE|DOCMD_NOWAIT|DOCMD_KEYTYPED);</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">/// do_cmdline(): execute one Ex command line</a>
<a name="ln295">///</a>
<a name="ln296">/// 1. Execute &quot;cmdline&quot; when it is not NULL.</a>
<a name="ln297">///    If &quot;cmdline&quot; is NULL, or more lines are needed, fgetline() is used.</a>
<a name="ln298">/// 2. Split up in parts separated with '|'.</a>
<a name="ln299">///</a>
<a name="ln300">/// This function can be called recursively!</a>
<a name="ln301">///</a>
<a name="ln302">/// flags:</a>
<a name="ln303">///   DOCMD_VERBOSE  - The command will be included in the error message.</a>
<a name="ln304">///   DOCMD_NOWAIT   - Don't call wait_return() and friends.</a>
<a name="ln305">///   DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.</a>
<a name="ln306">///   DOCMD_KEYTYPED - Don't reset KeyTyped.</a>
<a name="ln307">///   DOCMD_EXCRESET - Reset the exception environment (used for debugging).</a>
<a name="ln308">///   DOCMD_KEEPLINE - Store first typed line (for repeating with &quot;.&quot;).</a>
<a name="ln309">///</a>
<a name="ln310">/// @param cookie  argument for fgetline()</a>
<a name="ln311">///</a>
<a name="ln312">/// @return FAIL if cmdline could not be executed, OK otherwise</a>
<a name="ln313">int do_cmdline(char *cmdline, LineGetter fgetline, void *cookie, int flags)</a>
<a name="ln314">{</a>
<a name="ln315">  char *next_cmdline;                   // next cmd to execute</a>
<a name="ln316">  char *cmdline_copy = NULL;            // copy of cmd line</a>
<a name="ln317">  bool used_getline = false;            // used &quot;fgetline&quot; to obtain command</a>
<a name="ln318">  static int recursive = 0;             // recursive depth</a>
<a name="ln319">  bool msg_didout_before_start = false;</a>
<a name="ln320">  int count = 0;                        // line number count</a>
<a name="ln321">  bool did_inc = false;                 // incremented RedrawingDisabled</a>
<a name="ln322">  int retval = OK;</a>
<a name="ln323">  cstack_T cstack = {                   // conditional stack</a>
<a name="ln324">    .cs_idx = -1,</a>
<a name="ln325">  };</a>
<a name="ln326">  garray_T lines_ga;                    // keep lines for &quot;:while&quot;/&quot;:for&quot;</a>
<a name="ln327">  int current_line = 0;                 // active line in lines_ga</a>
<a name="ln328">  char *fname = NULL;                   // function or script name</a>
<a name="ln329">  linenr_T *breakpoint = NULL;          // ptr to breakpoint field in cookie</a>
<a name="ln330">  int *dbg_tick = NULL;                 // ptr to dbg_tick field in cookie</a>
<a name="ln331">  struct dbg_stuff debug_saved;         // saved things for debug mode</a>
<a name="ln332">  int initial_trylevel;</a>
<a name="ln333">  msglist_T **saved_msg_list = NULL;</a>
<a name="ln334">  msglist_T *private_msg_list;</a>
<a name="ln335"> </a>
<a name="ln336">  // &quot;fgetline&quot; and &quot;cookie&quot; passed to do_one_cmd()</a>
<a name="ln337">  char *(*cmd_getline)(int, void *, int, bool);</a>
<a name="ln338">  void *cmd_cookie;</a>
<a name="ln339">  struct loop_cookie cmd_loop_cookie;</a>
<a name="ln340">  void *real_cookie;</a>
<a name="ln341">  int getline_is_func;</a>
<a name="ln342">  static int call_depth = 0;            // recursiveness</a>
<a name="ln343"> </a>
<a name="ln344">  // For every pair of do_cmdline()/do_one_cmd() calls, use an extra memory</a>
<a name="ln345">  // location for storing error messages to be converted to an exception.</a>
<a name="ln346">  // This ensures that the do_errthrow() call in do_one_cmd() does not</a>
<a name="ln347">  // combine the messages stored by an earlier invocation of do_one_cmd()</a>
<a name="ln348">  // with the command name of the later one.  This would happen when</a>
<a name="ln349">  // BufWritePost autocommands are executed after a write error.</a>
<a name="ln350">  saved_msg_list = msg_list;</a>
<a name="ln351">  msg_list = &amp;private_msg_list;</a>
<a name="ln352">  private_msg_list = NULL;</a>
<a name="ln353"> </a>
<a name="ln354">  // It's possible to create an endless loop with &quot;:execute&quot;, catch that</a>
<a name="ln355">  // here.  The value of 200 allows nested function calls, &quot;:source&quot;, etc.</a>
<a name="ln356">  // Allow 200 or 'maxfuncdepth', whatever is larger.</a>
<a name="ln357">  if (call_depth &gt;= 200 &amp;&amp; call_depth &gt;= p_mfd) {</a>
<a name="ln358">    emsg(_(e_command_too_recursive));</a>
<a name="ln359">    // When converting to an exception, we do not include the command name</a>
<a name="ln360">    // since this is not an error of the specific command.</a>
<a name="ln361">    do_errthrow((cstack_T *)NULL, NULL);</a>
<a name="ln362">    msg_list = saved_msg_list;</a>
<a name="ln363">    return FAIL;</a>
<a name="ln364">  }</a>
<a name="ln365">  call_depth++;</a>
<a name="ln366">  start_batch_changes();</a>
<a name="ln367"> </a>
<a name="ln368">  ga_init(&amp;lines_ga, (int)sizeof(wcmd_T), 10);</a>
<a name="ln369"> </a>
<a name="ln370">  real_cookie = getline_cookie(fgetline, cookie);</a>
<a name="ln371"> </a>
<a name="ln372">  // Inside a function use a higher nesting level.</a>
<a name="ln373">  getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln374">  if (getline_is_func &amp;&amp; ex_nesting_level == func_level(real_cookie)) {</a>
<a name="ln375">    ex_nesting_level++;</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378">  // Get the function or script name and the address where the next breakpoint</a>
<a name="ln379">  // line and the debug tick for a function or script are stored.</a>
<a name="ln380">  if (getline_is_func) {</a>
<a name="ln381">    fname = func_name(real_cookie);</a>
<a name="ln382">    breakpoint = func_breakpoint(real_cookie);</a>
<a name="ln383">    dbg_tick = func_dbg_tick(real_cookie);</a>
<a name="ln384">  } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln385">    fname = SOURCING_NAME;</a>
<a name="ln386">    breakpoint = source_breakpoint(real_cookie);</a>
<a name="ln387">    dbg_tick = source_dbg_tick(real_cookie);</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  // Initialize &quot;force_abort&quot;  and &quot;suppress_errthrow&quot; at the top level.</a>
<a name="ln391">  if (!recursive) {</a>
<a name="ln392">    force_abort = false;</a>
<a name="ln393">    suppress_errthrow = false;</a>
<a name="ln394">  }</a>
<a name="ln395"> </a>
<a name="ln396">  // If requested, store and reset the global values controlling the</a>
<a name="ln397">  // exception handling (used when debugging).  Otherwise clear it to avoid</a>
<a name="ln398">  // a bogus compiler warning when the optimizer uses inline functions...</a>
<a name="ln399">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln400">    save_dbg_stuff(&amp;debug_saved);</a>
<a name="ln401">  } else {</a>
<a name="ln402">    CLEAR_FIELD(debug_saved);</a>
<a name="ln403">  }</a>
<a name="ln404"> </a>
<a name="ln405">  initial_trylevel = trylevel;</a>
<a name="ln406"> </a>
<a name="ln407">  // &quot;did_throw&quot; will be set to true when an exception is being thrown.</a>
<a name="ln408">  did_throw = false;</a>
<a name="ln409">  // &quot;did_emsg&quot; will be set to true when emsg() is used, in which case we</a>
<a name="ln410">  // cancel the whole command line, and any if/endif or loop.</a>
<a name="ln411">  // If force_abort is set, we cancel everything.</a>
<a name="ln412">  did_emsg = false;</a>
<a name="ln413"> </a>
<a name="ln414">  // KeyTyped is only set when calling vgetc().  Reset it here when not</a>
<a name="ln415">  // calling vgetc() (sourced command lines).</a>
<a name="ln416">  if (!(flags &amp; DOCMD_KEYTYPED)</a>
<a name="ln417">      &amp;&amp; !getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln418">    KeyTyped = false;</a>
<a name="ln419">  }</a>
<a name="ln420"> </a>
<a name="ln421">  // Continue executing command lines:</a>
<a name="ln422">  // - when inside an &quot;:if&quot;, &quot;:while&quot; or &quot;:for&quot;</a>
<a name="ln423">  // - for multiple commands on one line, separated with '|'</a>
<a name="ln424">  // - when repeating until there are no more lines (for &quot;:source&quot;)</a>
<a name="ln425">  next_cmdline = cmdline;</a>
<a name="ln426">  do {</a>
<a name="ln427">    getline_is_func = getline_equal(fgetline, cookie, get_func_line);</a>
<a name="ln428"> </a>
<a name="ln429">    // stop skipping cmds for an error msg after all endif/while/for</a>
<a name="ln430">    if (next_cmdline == NULL</a>
<a name="ln431">        &amp;&amp; !force_abort</a>
<a name="ln432">        &amp;&amp; cstack.cs_idx &lt; 0</a>
<a name="ln433">        &amp;&amp; !(getline_is_func</a>
<a name="ln434">             &amp;&amp; func_has_abort(real_cookie))) {</a>
<a name="ln435">      did_emsg = false;</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">    // 1. If repeating a line in a loop, get a line from lines_ga.</a>
<a name="ln439">    // 2. If no line given: Get an allocated line with fgetline().</a>
<a name="ln440">    // 3. If a line is given: Make a copy, so we can mess with it.</a>
<a name="ln441"> </a>
<a name="ln442">    // 1. If repeating, get a previous line from lines_ga.</a>
<a name="ln443">    if (cstack.cs_looplevel &gt; 0 &amp;&amp; current_line &lt; lines_ga.ga_len) {</a>
<a name="ln444">      // Each '|' separated command is stored separately in lines_ga, to</a>
<a name="ln445">      // be able to jump to it.  Don't use next_cmdline now.</a>
<a name="ln446">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln447"> </a>
<a name="ln448">      // Check if a function has returned or, unless it has an unclosed</a>
<a name="ln449">      // try conditional, aborted.</a>
<a name="ln450">      if (getline_is_func) {</a>
<a name="ln451">        if (do_profiling == PROF_YES) {</a>
<a name="ln452">          func_line_end(real_cookie);</a>
<a name="ln453">        }</a>
<a name="ln454">        if (func_has_ended(real_cookie)) {</a>
<a name="ln455">          retval = FAIL;</a>
<a name="ln456">          break;</a>
<a name="ln457">        }</a>
<a name="ln458">      } else if (do_profiling == PROF_YES</a>
<a name="ln459">                 &amp;&amp; getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln460">        script_line_end();</a>
<a name="ln461">      }</a>
<a name="ln462"> </a>
<a name="ln463">      // Check if a sourced file hit a &quot;:finish&quot; command.</a>
<a name="ln464">      if (source_finished(fgetline, cookie)) {</a>
<a name="ln465">        retval = FAIL;</a>
<a name="ln466">        break;</a>
<a name="ln467">      }</a>
<a name="ln468"> </a>
<a name="ln469">      // If breakpoints have been added/deleted need to check for it.</a>
<a name="ln470">      if (breakpoint != NULL &amp;&amp; dbg_tick != NULL</a>
<a name="ln471">          &amp;&amp; *dbg_tick != debug_tick) {</a>
<a name="ln472">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln473">                                          fname, SOURCING_LNUM);</a>
<a name="ln474">        *dbg_tick = debug_tick;</a>
<a name="ln475">      }</a>
<a name="ln476"> </a>
<a name="ln477">      next_cmdline = ((wcmd_T *)(lines_ga.ga_data))[current_line].line;</a>
<a name="ln478">      SOURCING_LNUM = ((wcmd_T *)(lines_ga.ga_data))[current_line].lnum;</a>
<a name="ln479"> </a>
<a name="ln480">      // Did we encounter a breakpoint?</a>
<a name="ln481">      if (breakpoint != NULL &amp;&amp; *breakpoint != 0 &amp;&amp; *breakpoint &lt;= SOURCING_LNUM) {</a>
<a name="ln482">        dbg_breakpoint(fname, SOURCING_LNUM);</a>
<a name="ln483">        // Find next breakpoint.</a>
<a name="ln484">        *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline),</a>
<a name="ln485">                                          fname, SOURCING_LNUM);</a>
<a name="ln486">        *dbg_tick = debug_tick;</a>
<a name="ln487">      }</a>
<a name="ln488">      if (do_profiling == PROF_YES) {</a>
<a name="ln489">        if (getline_is_func) {</a>
<a name="ln490">          func_line_start(real_cookie);</a>
<a name="ln491">        } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln492">          script_line_start();</a>
<a name="ln493">        }</a>
<a name="ln494">      }</a>
<a name="ln495">    }</a>
<a name="ln496"> </a>
<a name="ln497">    // 2. If no line given, get an allocated line with fgetline().</a>
<a name="ln498">    if (next_cmdline == NULL) {</a>
<a name="ln499">      // Need to set msg_didout for the first line after an &quot;:if&quot;,</a>
<a name="ln500">      // otherwise the &quot;:if&quot; will be overwritten.</a>
<a name="ln501">      if (count == 1 &amp;&amp; getline_equal(fgetline, cookie, getexline)) {</a>
<a name="ln502">        msg_didout = true;</a>
<a name="ln503">      }</a>
<a name="ln504">      if (fgetline == NULL</a>
<a name="ln505">          || (next_cmdline = fgetline(':', cookie,</a>
<a name="ln506">                                      cstack.cs_idx &lt;</a>
<a name="ln507">                                      0 ? 0 : (cstack.cs_idx + 1) * 2,</a>
<a name="ln508">                                      true)) == NULL) {</a>
<a name="ln509">        // Don't call wait_return() for aborted command line.  The NULL</a>
<a name="ln510">        // returned for the end of a sourced file or executed function</a>
<a name="ln511">        // doesn't do this.</a>
<a name="ln512">        if (KeyTyped &amp;&amp; !(flags &amp; DOCMD_REPEAT)) {</a>
<a name="ln513">          need_wait_return = false;</a>
<a name="ln514">        }</a>
<a name="ln515">        retval = FAIL;</a>
<a name="ln516">        break;</a>
<a name="ln517">      }</a>
<a name="ln518">      used_getline = true;</a>
<a name="ln519"> </a>
<a name="ln520">      // Keep the first typed line.  Clear it when more lines are typed.</a>
<a name="ln521">      if (flags &amp; DOCMD_KEEPLINE) {</a>
<a name="ln522">        xfree(repeat_cmdline);</a>
<a name="ln523">        if (count == 0) {</a>
<a name="ln524">          repeat_cmdline = xstrdup(next_cmdline);</a>
<a name="ln525">        } else {</a>
<a name="ln526">          repeat_cmdline = NULL;</a>
<a name="ln527">        }</a>
<a name="ln528">      }</a>
<a name="ln529">    } else if (cmdline_copy == NULL) {</a>
<a name="ln530">      // 3. Make a copy of the command so we can mess with it.</a>
<a name="ln531">      next_cmdline = xstrdup(next_cmdline);</a>
<a name="ln532">    }</a>
<a name="ln533">    cmdline_copy = next_cmdline;</a>
<a name="ln534"> </a>
<a name="ln535">    int current_line_before = 0;</a>
<a name="ln536">    // Inside a while/for loop, and when the command looks like a &quot;:while&quot;</a>
<a name="ln537">    // or &quot;:for&quot;, the line is stored, because we may need it later when</a>
<a name="ln538">    // looping.</a>
<a name="ln539">    //</a>
<a name="ln540">    // When there is a '|' and another command, it is stored separately,</a>
<a name="ln541">    // because we need to be able to jump back to it from an</a>
<a name="ln542">    // :endwhile/:endfor.</a>
<a name="ln543">    //</a>
<a name="ln544">    // Pass a different &quot;fgetline&quot; function to do_one_cmd() below,</a>
<a name="ln545">    // that it stores lines in or reads them from &quot;lines_ga&quot;.  Makes it</a>
<a name="ln546">    // possible to define a function inside a while/for loop.</a>
<a name="ln547">    if ((cstack.cs_looplevel &gt; 0 || has_loop_cmd(next_cmdline))) {</a>
<a name="ln548">      cmd_getline = get_loop_line;</a>
<a name="ln549">      cmd_cookie = (void *)&amp;cmd_loop_cookie;</a>
<a name="ln550">      cmd_loop_cookie.lines_gap = &amp;lines_ga;</a>
<a name="ln551">      cmd_loop_cookie.current_line = current_line;</a>
<a name="ln552">      cmd_loop_cookie.getline = fgetline;</a>
<a name="ln553">      cmd_loop_cookie.cookie = cookie;</a>
<a name="ln554">      cmd_loop_cookie.repeating = (current_line &lt; lines_ga.ga_len);</a>
<a name="ln555"> </a>
<a name="ln556">      // Save the current line when encountering it the first time.</a>
<a name="ln557">      if (current_line == lines_ga.ga_len) {</a>
<a name="ln558">        store_loop_line(&amp;lines_ga, next_cmdline);</a>
<a name="ln559">      }</a>
<a name="ln560">      current_line_before = current_line;</a>
<a name="ln561">    } else {</a>
<a name="ln562">      cmd_getline = fgetline;</a>
<a name="ln563">      cmd_cookie = cookie;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">    did_endif = false;</a>
<a name="ln567"> </a>
<a name="ln568">    if (count++ == 0) {</a>
<a name="ln569">      // All output from the commands is put below each other, without</a>
<a name="ln570">      // waiting for a return. Don't do this when executing commands</a>
<a name="ln571">      // from a script or when being called recursive (e.g. for &quot;:e</a>
<a name="ln572">      // +command file&quot;).</a>
<a name="ln573">      if (!(flags &amp; DOCMD_NOWAIT) &amp;&amp; !recursive) {</a>
<a name="ln574">        msg_didout_before_start = msg_didout;</a>
<a name="ln575">        msg_didany = false;         // no output yet</a>
<a name="ln576">        msg_start();</a>
<a name="ln577">        msg_scroll = true;          // put messages below each other</a>
<a name="ln578">        no_wait_return++;           // don't wait for return until finished</a>
<a name="ln579">        RedrawingDisabled++;</a>
<a name="ln580">        did_inc = true;</a>
<a name="ln581">      }</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    if ((p_verbose &gt;= 15 &amp;&amp; SOURCING_NAME != NULL) || p_verbose &gt;= 16) {</a>
<a name="ln585">      msg_verbose_cmd(SOURCING_LNUM, cmdline_copy);</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    // 2. Execute one '|' separated command.</a>
<a name="ln589">    //    do_one_cmd() will return NULL if there is no trailing '|'.</a>
<a name="ln590">    //    &quot;cmdline_copy&quot; can change, e.g. for '%' and '#' expansion.</a>
<a name="ln591">    recursive++;</a>
<a name="ln592">    next_cmdline = do_one_cmd(&amp;cmdline_copy, flags, &amp;cstack, cmd_getline, cmd_cookie);</a>
<a name="ln593">    recursive--;</a>
<a name="ln594"> </a>
<a name="ln595">    if (cmd_cookie == (void *)&amp;cmd_loop_cookie) {</a>
<a name="ln596">      // Use &quot;current_line&quot; from &quot;cmd_loop_cookie&quot;, it may have been</a>
<a name="ln597">      // incremented when defining a function.</a>
<a name="ln598">      current_line = cmd_loop_cookie.current_line;</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">    if (next_cmdline == NULL) {</a>
<a name="ln602">      XFREE_CLEAR(cmdline_copy);</a>
<a name="ln603"> </a>
<a name="ln604">      // If the command was typed, remember it for the ':' register.</a>
<a name="ln605">      // Do this AFTER executing the command to make :@: work.</a>
<a name="ln606">      if (getline_equal(fgetline, cookie, getexline)</a>
<a name="ln607">          &amp;&amp; new_last_cmdline != NULL) {</a>
<a name="ln608">        xfree(last_cmdline);</a>
<a name="ln609">        last_cmdline = new_last_cmdline;</a>
<a name="ln610">        new_last_cmdline = NULL;</a>
<a name="ln611">      }</a>
<a name="ln612">    } else {</a>
<a name="ln613">      // need to copy the command after the '|' to cmdline_copy, for the</a>
<a name="ln614">      // next do_one_cmd()</a>
<a name="ln615">      STRMOVE(cmdline_copy, next_cmdline);</a>
<a name="ln616">      next_cmdline = cmdline_copy;</a>
<a name="ln617">    }</a>
<a name="ln618"> </a>
<a name="ln619">    // reset did_emsg for a function that is not aborted by an error</a>
<a name="ln620">    if (did_emsg &amp;&amp; !force_abort</a>
<a name="ln621">        &amp;&amp; getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln622">        &amp;&amp; !func_has_abort(real_cookie)) {</a>
<a name="ln623">      did_emsg = false;</a>
<a name="ln624">    }</a>
<a name="ln625"> </a>
<a name="ln626">    if (cstack.cs_looplevel &gt; 0) {</a>
<a name="ln627">      current_line++;</a>
<a name="ln628"> </a>
<a name="ln629">      // An &quot;:endwhile&quot;, &quot;:endfor&quot; and &quot;:continue&quot; is handled here.</a>
<a name="ln630">      // If we were executing commands, jump back to the &quot;:while&quot; or</a>
<a name="ln631">      // &quot;:for&quot;.</a>
<a name="ln632">      // If we were not executing commands, decrement cs_looplevel.</a>
<a name="ln633">      if (cstack.cs_lflags &amp; (CSL_HAD_CONT | CSL_HAD_ENDLOOP)) {</a>
<a name="ln634">        cstack.cs_lflags &amp;= ~(CSL_HAD_CONT | CSL_HAD_ENDLOOP);</a>
<a name="ln635"> </a>
<a name="ln636">        // Jump back to the matching &quot;:while&quot; or &quot;:for&quot;.  Be careful</a>
<a name="ln637">        // not to use a cs_line[] from an entry that isn't a &quot;:while&quot;</a>
<a name="ln638">        // or &quot;:for&quot;: It would make &quot;current_line&quot; invalid and can</a>
<a name="ln639">        // cause a crash.</a>
<a name="ln640">        if (!did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw</a>
<a name="ln641">            &amp;&amp; cstack.cs_idx &gt;= 0</a>
<a name="ln642">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx]</a>
<a name="ln643">                &amp; (CSF_WHILE | CSF_FOR))</a>
<a name="ln644">            &amp;&amp; cstack.cs_line[cstack.cs_idx] &gt;= 0</a>
<a name="ln645">            &amp;&amp; (cstack.cs_flags[cstack.cs_idx] &amp; CSF_ACTIVE)) {</a>
<a name="ln646">          current_line = cstack.cs_line[cstack.cs_idx];</a>
<a name="ln647">          // remember we jumped there</a>
<a name="ln648">          cstack.cs_lflags |= CSL_HAD_LOOP;</a>
<a name="ln649">          line_breakcheck();                    // check if CTRL-C typed</a>
<a name="ln650"> </a>
<a name="ln651">          // Check for the next breakpoint at or after the &quot;:while&quot;</a>
<a name="ln652">          // or &quot;:for&quot;.</a>
<a name="ln653">          if (breakpoint != NULL &amp;&amp; lines_ga.ga_len &gt; current_line) {</a>
<a name="ln654">            *breakpoint = dbg_find_breakpoint(getline_equal(fgetline, cookie, getsourceline), fname,</a>
<a name="ln655">                                              ((wcmd_T *)lines_ga.ga_data)[current_line].lnum - 1);</a>
<a name="ln656">            *dbg_tick = debug_tick;</a>
<a name="ln657">          }</a>
<a name="ln658">        } else {</a>
<a name="ln659">          // can only get here with &quot;:endwhile&quot; or &quot;:endfor&quot;</a>
<a name="ln660">          if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln661">            rewind_conditionals(&amp;cstack, cstack.cs_idx - 1,</a>
<a name="ln662">                                CSF_WHILE | CSF_FOR, &amp;cstack.cs_looplevel);</a>
<a name="ln663">          }</a>
<a name="ln664">        }</a>
<a name="ln665">      } else if (cstack.cs_lflags &amp; CSL_HAD_LOOP) {</a>
<a name="ln666">        // For a &quot;:while&quot; or &quot;:for&quot; we need to remember the line number.</a>
<a name="ln667">        cstack.cs_lflags &amp;= ~CSL_HAD_LOOP;</a>
<a name="ln668">        cstack.cs_line[cstack.cs_idx] = current_line_before;</a>
<a name="ln669">      }</a>
<a name="ln670">    }</a>
<a name="ln671"> </a>
<a name="ln672">    // When not inside any &quot;:while&quot; loop, clear remembered lines.</a>
<a name="ln673">    if (cstack.cs_looplevel == 0) {</a>
<a name="ln674">      if (!GA_EMPTY(&amp;lines_ga)) {</a>
<a name="ln675">        SOURCING_LNUM = ((wcmd_T *)lines_ga.ga_data)[lines_ga.ga_len - 1].lnum;</a>
<a name="ln676">        GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln677">      }</a>
<a name="ln678">      current_line = 0;</a>
<a name="ln679">    }</a>
<a name="ln680"> </a>
<a name="ln681">    // A &quot;:finally&quot; makes did_emsg, got_int and did_throw pending for</a>
<a name="ln682">    // being restored at the &quot;:endtry&quot;.  Reset them here and set the</a>
<a name="ln683">    // ACTIVE and FINALLY flags, so that the finally clause gets executed.</a>
<a name="ln684">    // This includes the case where a missing &quot;:endif&quot;, &quot;:endwhile&quot; or</a>
<a name="ln685">    // &quot;:endfor&quot; was detected by the &quot;:finally&quot; itself.</a>
<a name="ln686">    if (cstack.cs_lflags &amp; CSL_HAD_FINA) {</a>
<a name="ln687">      cstack.cs_lflags &amp;= ~CSL_HAD_FINA;</a>
<a name="ln688">      report_make_pending((cstack.cs_pending[cstack.cs_idx]</a>
<a name="ln689">                           &amp; (CSTP_ERROR | CSTP_INTERRUPT | CSTP_THROW)),</a>
<a name="ln690">                          did_throw ? current_exception : NULL);</a>
<a name="ln691">      did_emsg = got_int = did_throw = false;</a>
<a name="ln692">      cstack.cs_flags[cstack.cs_idx] |= CSF_ACTIVE | CSF_FINALLY;</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">    // Update global &quot;trylevel&quot; for recursive calls to do_cmdline() from</a>
<a name="ln696">    // within this loop.</a>
<a name="ln697">    trylevel = initial_trylevel + cstack.cs_trylevel;</a>
<a name="ln698"> </a>
<a name="ln699">    // If the outermost try conditional (across function calls and sourced</a>
<a name="ln700">    // files) is aborted because of an error, an interrupt, or an uncaught</a>
<a name="ln701">    // exception, cancel everything.  If it is left normally, reset</a>
<a name="ln702">    // force_abort to get the non-EH compatible abortion behavior for</a>
<a name="ln703">    // the rest of the script.</a>
<a name="ln704">    if (trylevel == 0 &amp;&amp; !did_emsg &amp;&amp; !got_int &amp;&amp; !did_throw) {</a>
<a name="ln705">      force_abort = false;</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">    // Convert an interrupt to an exception if appropriate.</a>
<a name="ln709">    (void)do_intthrow(&amp;cstack);</a>
<a name="ln710"> </a>
<a name="ln711">    // Continue executing command lines when:</a>
<a name="ln712">    // - no CTRL-C typed, no aborting error, no exception thrown or try</a>
<a name="ln713">    //   conditionals need to be checked for executing finally clauses or</a>
<a name="ln714">    //   catching an interrupt exception</a>
<a name="ln715">    // - didn't get an error message or lines are not typed</a>
<a name="ln716">    // - there is a command after '|', inside a :if, :while, :for or :try, or</a>
<a name="ln717">    //   looping for &quot;:source&quot; command or function call.</a>
<a name="ln718">  } while (!((got_int || (did_emsg &amp;&amp; force_abort) || did_throw)</a>
<a name="ln719">             &amp;&amp; cstack.cs_trylevel == 0)</a>
<a name="ln720">           &amp;&amp; !(did_emsg</a>
<a name="ln721">                // Keep going when inside try/catch, so that the error can be</a>
<a name="ln722">                // deal with, except when it is a syntax error, it may cause</a>
<a name="ln723">                // the :endtry to be missed.</a>
<a name="ln724">                &amp;&amp; (cstack.cs_trylevel == 0 || did_emsg_syntax)</a>
<a name="ln725">                &amp;&amp; used_getline</a>
<a name="ln726">                &amp;&amp; getline_equal(fgetline, cookie, getexline))</a>
<a name="ln727">           &amp;&amp; (next_cmdline != NULL</a>
<a name="ln728">               || cstack.cs_idx &gt;= 0</a>
<a name="ln729">               || (flags &amp; DOCMD_REPEAT)));</a>
<a name="ln730"> </a>
<a name="ln731">  xfree(cmdline_copy);</a>
<a name="ln732">  did_emsg_syntax = false;</a>
<a name="ln733">  GA_DEEP_CLEAR(&amp;lines_ga, wcmd_T, FREE_WCMD);</a>
<a name="ln734"> </a>
<a name="ln735">  if (cstack.cs_idx &gt;= 0) {</a>
<a name="ln736">    // If a sourced file or executed function ran to its end, report the</a>
<a name="ln737">    // unclosed conditional.</a>
<a name="ln738">    if (!got_int &amp;&amp; !did_throw &amp;&amp; !aborting()</a>
<a name="ln739">        &amp;&amp; ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln740">             &amp;&amp; !source_finished(fgetline, cookie))</a>
<a name="ln741">            || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln742">                &amp;&amp; !func_has_ended(real_cookie)))) {</a>
<a name="ln743">      if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_TRY) {</a>
<a name="ln744">        emsg(_(e_endtry));</a>
<a name="ln745">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_WHILE) {</a>
<a name="ln746">        emsg(_(e_endwhile));</a>
<a name="ln747">      } else if (cstack.cs_flags[cstack.cs_idx] &amp; CSF_FOR) {</a>
<a name="ln748">        emsg(_(e_endfor));</a>
<a name="ln749">      } else {</a>
<a name="ln750">        emsg(_(e_endif));</a>
<a name="ln751">      }</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    // Reset &quot;trylevel&quot; in case of a &quot;:finish&quot; or &quot;:return&quot; or a missing</a>
<a name="ln755">    // &quot;:endtry&quot; in a sourced file or executed function.  If the try</a>
<a name="ln756">    // conditional is in its finally clause, ignore anything pending.</a>
<a name="ln757">    // If it is in a catch clause, finish the caught exception.</a>
<a name="ln758">    // Also cleanup any &quot;cs_forinfo&quot; structures.</a>
<a name="ln759">    do {</a>
<a name="ln760">      int idx = cleanup_conditionals(&amp;cstack, 0, true);</a>
<a name="ln761"> </a>
<a name="ln762">      if (idx &gt;= 0) {</a>
<a name="ln763">        idx--;              // remove try block not in its finally clause</a>
<a name="ln764">      }</a>
<a name="ln765">      rewind_conditionals(&amp;cstack, idx, CSF_WHILE | CSF_FOR,</a>
<a name="ln766">                          &amp;cstack.cs_looplevel);</a>
<a name="ln767">    } while (cstack.cs_idx &gt;= 0);</a>
<a name="ln768">    trylevel = initial_trylevel;</a>
<a name="ln769">  }</a>
<a name="ln770"> </a>
<a name="ln771">  // If a missing &quot;:endtry&quot;, &quot;:endwhile&quot;, &quot;:endfor&quot;, or &quot;:endif&quot; or a memory</a>
<a name="ln772">  // lack was reported above and the error message is to be converted to an</a>
<a name="ln773">  // exception, do this now after rewinding the cstack.</a>
<a name="ln774">  do_errthrow(&amp;cstack, getline_equal(fgetline, cookie, get_func_line) ? &quot;endfunction&quot; : NULL);</a>
<a name="ln775"> </a>
<a name="ln776">  if (trylevel == 0) {</a>
<a name="ln777">    // When an exception is being thrown out of the outermost try</a>
<a name="ln778">    // conditional, discard the uncaught exception, disable the conversion</a>
<a name="ln779">    // of interrupts or errors to exceptions, and ensure that no more</a>
<a name="ln780">    // commands are executed.</a>
<a name="ln781">    if (did_throw) {</a>
<a name="ln782">      handle_did_throw();</a>
<a name="ln783">    } else if (got_int || (did_emsg &amp;&amp; force_abort)) {</a>
<a name="ln784">      // On an interrupt or an aborting error not converted to an exception,</a>
<a name="ln785">      // disable the conversion of errors to exceptions.  (Interrupts are not</a>
<a name="ln786">      // converted any more, here.) This enables also the interrupt message</a>
<a name="ln787">      // when force_abort is set and did_emsg unset in case of an interrupt</a>
<a name="ln788">      // from a finally clause after an error.</a>
<a name="ln789">      suppress_errthrow = true;</a>
<a name="ln790">    }</a>
<a name="ln791">  }</a>
<a name="ln792"> </a>
<a name="ln793">  // The current cstack will be freed when do_cmdline() returns.  An uncaught</a>
<a name="ln794">  // exception will have to be rethrown in the previous cstack.  If a function</a>
<a name="ln795">  // has just returned or a script file was just finished and the previous</a>
<a name="ln796">  // cstack belongs to the same function or, respectively, script file, it</a>
<a name="ln797">  // will have to be checked for finally clauses to be executed due to the</a>
<a name="ln798">  // &quot;:return&quot; or &quot;:finish&quot;.  This is done in do_one_cmd().</a>
<a name="ln799">  if (did_throw) {</a>
<a name="ln800">    need_rethrow = true;</a>
<a name="ln801">  }</a>
<a name="ln802">  if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln803">       &amp;&amp; ex_nesting_level &gt; source_level(real_cookie))</a>
<a name="ln804">      || (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln805">          &amp;&amp; ex_nesting_level &gt; func_level(real_cookie) + 1)) {</a>
<a name="ln806">    if (!did_throw) {</a>
<a name="ln807">      check_cstack = true;</a>
<a name="ln808">    }</a>
<a name="ln809">  } else {</a>
<a name="ln810">    // When leaving a function, reduce nesting level.</a>
<a name="ln811">    if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln812">      ex_nesting_level--;</a>
<a name="ln813">    }</a>
<a name="ln814">    // Go to debug mode when returning from a function in which we are</a>
<a name="ln815">    // single-stepping.</a>
<a name="ln816">    if ((getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln817">         || getline_equal(fgetline, cookie, get_func_line))</a>
<a name="ln818">        &amp;&amp; ex_nesting_level + 1 &lt;= debug_break_level) {</a>
<a name="ln819">      do_debug(getline_equal(fgetline, cookie, getsourceline)</a>
<a name="ln820">               ? _(&quot;End of sourced file&quot;)</a>
<a name="ln821">               : _(&quot;End of function&quot;));</a>
<a name="ln822">    }</a>
<a name="ln823">  }</a>
<a name="ln824"> </a>
<a name="ln825">  // Restore the exception environment (done after returning from the</a>
<a name="ln826">  // debugger).</a>
<a name="ln827">  if (flags &amp; DOCMD_EXCRESET) {</a>
<a name="ln828">    restore_dbg_stuff(&amp;debug_saved);</a>
<a name="ln829">  }</a>
<a name="ln830"> </a>
<a name="ln831">  msg_list = saved_msg_list;</a>
<a name="ln832"> </a>
<a name="ln833">  // Cleanup if &quot;cs_emsg_silent_list&quot; remains.</a>
<a name="ln834">  if (cstack.cs_emsg_silent_list != NULL) {</a>
<a name="ln835">    eslist_T *elem, *temp;</a>
<a name="ln836">    for (elem = cstack.cs_emsg_silent_list; elem != NULL; elem = temp) {</a>
<a name="ln837">      temp = elem-&gt;next;</a>
<a name="ln838">      xfree(elem);</a>
<a name="ln839">    }</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842">  // If there was too much output to fit on the command line, ask the user to</a>
<a name="ln843">  // hit return before redrawing the screen. With the &quot;:global&quot; command we do</a>
<a name="ln844">  // this only once after the command is finished.</a>
<a name="ln845">  if (did_inc) {</a>
<a name="ln846">    RedrawingDisabled--;</a>
<a name="ln847">    no_wait_return--;</a>
<a name="ln848">    msg_scroll = false;</a>
<a name="ln849"> </a>
<a name="ln850">    // When just finished an &quot;:if&quot;-&quot;:else&quot; which was typed, no need to</a>
<a name="ln851">    // wait for hit-return.  Also for an error situation.</a>
<a name="ln852">    if (retval == FAIL</a>
<a name="ln853">        || (did_endif &amp;&amp; KeyTyped &amp;&amp; !did_emsg)) {</a>
<a name="ln854">      need_wait_return = false;</a>
<a name="ln855">      msg_didany = false;               // don't wait when restarting edit</a>
<a name="ln856">    } else if (need_wait_return) {</a>
<a name="ln857">      // The msg_start() above clears msg_didout. The wait_return() we do</a>
<a name="ln858">      // here should not overwrite the command that may be shown before</a>
<a name="ln859">      // doing that.</a>
<a name="ln860">      msg_didout |= msg_didout_before_start;</a>
<a name="ln861">      wait_return(false);</a>
<a name="ln862">    }</a>
<a name="ln863">  }</a>
<a name="ln864"> </a>
<a name="ln865">  did_endif = false;    // in case do_cmdline used recursively</a>
<a name="ln866"> </a>
<a name="ln867">  call_depth--;</a>
<a name="ln868">  end_batch_changes();</a>
<a name="ln869">  return retval;</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">/// Handle when &quot;did_throw&quot; is set after executing commands.</a>
<a name="ln873">void handle_did_throw(void)</a>
<a name="ln874">{</a>
<a name="ln875">  assert(current_exception != NULL);</a>
<a name="ln876">  char *p = NULL;</a>
<a name="ln877">  msglist_T *messages = NULL;</a>
<a name="ln878"> </a>
<a name="ln879">  // If the uncaught exception is a user exception, report it as an</a>
<a name="ln880">  // error.  If it is an error exception, display the saved error</a>
<a name="ln881">  // message now.  For an interrupt exception, do nothing; the</a>
<a name="ln882">  // interrupt message is given elsewhere.</a>
<a name="ln883">  switch (current_exception-&gt;type) {</a>
<a name="ln884">  case ET_USER:</a>
<a name="ln885">    vim_snprintf(IObuff, IOSIZE,</a>
<a name="ln886">                 _(&quot;E605: Exception not caught: %s&quot;),</a>
<a name="ln887">                 current_exception-&gt;value);</a>
<a name="ln888">    p = xstrdup(IObuff);</a>
<a name="ln889">    break;</a>
<a name="ln890">  case ET_ERROR:</a>
<a name="ln891">    messages = current_exception-&gt;messages;</a>
<a name="ln892">    current_exception-&gt;messages = NULL;</a>
<a name="ln893">    break;</a>
<a name="ln894">  case ET_INTERRUPT:</a>
<a name="ln895">    break;</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  estack_push(ETYPE_EXCEPT, current_exception-&gt;throw_name, current_exception-&gt;throw_lnum);</a>
<a name="ln899">  current_exception-&gt;throw_name = NULL;</a>
<a name="ln900"> </a>
<a name="ln901">  discard_current_exception();              // uses IObuff if 'verbose'</a>
<a name="ln902">  suppress_errthrow = true;</a>
<a name="ln903">  force_abort = true;</a>
<a name="ln904">  msg_ext_set_kind(&quot;emsg&quot;);  // kind=emsg for :throw, exceptions. #9993</a>
<a name="ln905"> </a>
<a name="ln906">  if (messages != NULL) {</a>
<a name="ln907">    do {</a>
<a name="ln908">      msglist_T *next = messages-&gt;next;</a>
<a name="ln909">      emsg(messages-&gt;msg);</a>
<a name="ln910">      xfree(messages-&gt;msg);</a>
<a name="ln911">      xfree(messages-&gt;sfile);</a>
<a name="ln912">      xfree(messages);</a>
<a name="ln913">      messages = next;</a>
<a name="ln914">    } while (messages != NULL);</a>
<a name="ln915">  } else if (p != NULL) {</a>
<a name="ln916">    emsg(p);</a>
<a name="ln917">    xfree(p);</a>
<a name="ln918">  }</a>
<a name="ln919">  xfree(SOURCING_NAME);</a>
<a name="ln920">  estack_pop();</a>
<a name="ln921">}</a>
<a name="ln922"> </a>
<a name="ln923">/// Obtain a line when inside a &quot;:while&quot; or &quot;:for&quot; loop.</a>
<a name="ln924">static char *get_loop_line(int c, void *cookie, int indent, bool do_concat)</a>
<a name="ln925">{</a>
<a name="ln926">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln927"> </a>
<a name="ln928">  if (cp-&gt;current_line + 1 &gt;= cp-&gt;lines_gap-&gt;ga_len) {</a>
<a name="ln929">    if (cp-&gt;repeating) {</a>
<a name="ln930">      return NULL;              // trying to read past &quot;:endwhile&quot;/&quot;:endfor&quot;</a>
<a name="ln931">    }</a>
<a name="ln932">    char *line;</a>
<a name="ln933">    // First time inside the &quot;:while&quot;/&quot;:for&quot;: get line normally.</a>
<a name="ln934">    if (cp-&gt;getline == NULL) {</a>
<a name="ln935">      line = getcmdline(c, 0L, indent, do_concat);</a>
<a name="ln936">    } else {</a>
<a name="ln937">      line = cp-&gt;getline(c, cp-&gt;cookie, indent, do_concat);</a>
<a name="ln938">    }</a>
<a name="ln939">    if (line != NULL) {</a>
<a name="ln940">      store_loop_line(cp-&gt;lines_gap, line);</a>
<a name="ln941">      cp-&gt;current_line++;</a>
<a name="ln942">    }</a>
<a name="ln943"> </a>
<a name="ln944">    return line;</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  KeyTyped = false;</a>
<a name="ln948">  cp-&gt;current_line++;</a>
<a name="ln949">  wcmd_T *wp = (wcmd_T *)(cp-&gt;lines_gap-&gt;ga_data) + cp-&gt;current_line;</a>
<a name="ln950">  SOURCING_LNUM = wp-&gt;lnum;</a>
<a name="ln951">  return xstrdup(wp-&gt;line);</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/// Store a line in &quot;gap&quot; so that a &quot;:while&quot; loop can execute it again.</a>
<a name="ln955">static void store_loop_line(garray_T *gap, char *line)</a>
<a name="ln956">{</a>
<a name="ln957">  wcmd_T *p = GA_APPEND_VIA_PTR(wcmd_T, gap);</a>
<a name="ln958">  p-&gt;line = xstrdup(line);</a>
<a name="ln959">  p-&gt;lnum = SOURCING_LNUM;</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">/// If &quot;fgetline&quot; is get_loop_line(), return true if the getline it uses equals</a>
<a name="ln963">/// &quot;func&quot;.  * Otherwise return true when &quot;fgetline&quot; equals &quot;func&quot;.</a>
<a name="ln964">///</a>
<a name="ln965">/// @param cookie  argument for fgetline()</a>
<a name="ln966">bool getline_equal(LineGetter fgetline, void *cookie, LineGetter func)</a>
<a name="ln967">{</a>
<a name="ln968">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln969">  // function that's originally used to obtain the lines.  This may be</a>
<a name="ln970">  // nested several levels.</a>
<a name="ln971">  LineGetter gp = fgetline;</a>
<a name="ln972">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln973">  while (gp == get_loop_line) {</a>
<a name="ln974">    gp = cp-&gt;getline;</a>
<a name="ln975">    cp = cp-&gt;cookie;</a>
<a name="ln976">  }</a>
<a name="ln977">  return gp == func;</a>
<a name="ln978">}</a>
<a name="ln979"> </a>
<a name="ln980">/// If &quot;fgetline&quot; is get_loop_line(), return the cookie used by the original</a>
<a name="ln981">/// getline function.  Otherwise return &quot;cookie&quot;.</a>
<a name="ln982">///</a>
<a name="ln983">/// @param cookie  argument for fgetline()</a>
<a name="ln984">void *getline_cookie(LineGetter fgetline, void *cookie)</a>
<a name="ln985">{</a>
<a name="ln986">  // When &quot;fgetline&quot; is &quot;get_loop_line()&quot; use the &quot;cookie&quot; to find the</a>
<a name="ln987">  // cookie that's originally used to obtain the lines.  This may be nested</a>
<a name="ln988">  // several levels.</a>
<a name="ln989">  LineGetter gp = fgetline;</a>
<a name="ln990">  struct loop_cookie *cp = (struct loop_cookie *)cookie;</a>
<a name="ln991">  while (gp == get_loop_line) {</a>
<a name="ln992">    gp = cp-&gt;getline;</a>
<a name="ln993">    cp = cp-&gt;cookie;</a>
<a name="ln994">  }</a>
<a name="ln995">  return cp;</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">/// Helper function to apply an offset for buffer commands, i.e. &quot;:bdelete&quot;,</a>
<a name="ln999">/// &quot;:bwipeout&quot;, etc.</a>
<a name="ln1000">///</a>
<a name="ln1001">/// @return  the buffer number.</a>
<a name="ln1002">static int compute_buffer_local_count(cmd_addr_T addr_type, linenr_T lnum, int offset)</a>
<a name="ln1003">{</a>
<a name="ln1004">  buf_T *nextbuf;</a>
<a name="ln1005">  int count = offset;</a>
<a name="ln1006"> </a>
<a name="ln1007">  buf_T *buf = firstbuf;</a>
<a name="ln1008">  while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_fnum &lt; lnum) {</a>
<a name="ln1009">    buf = buf-&gt;b_next;</a>
<a name="ln1010">  }</a>
<a name="ln1011">  while (count != 0) {</a>
<a name="ln1012">    count += (count &lt; 0) ? 1 : -1;</a>
<a name="ln1013">    nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1014">    if (nextbuf == NULL) {</a>
<a name="ln1015">      break;</a>
<a name="ln1016">    }</a>
<a name="ln1017">    buf = nextbuf;</a>
<a name="ln1018">    if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1019">      // skip over unloaded buffers</a>
<a name="ln1020">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1021">        nextbuf = (offset &lt; 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1022">        if (nextbuf == NULL) {</a>
<a name="ln1023">          break;</a>
<a name="ln1024">        }</a>
<a name="ln1025">        buf = nextbuf;</a>
<a name="ln1026">      }</a>
<a name="ln1027">    }</a>
<a name="ln1028">  }</a>
<a name="ln1029">  // we might have gone too far, last buffer is not loaded</a>
<a name="ln1030">  if (addr_type == ADDR_LOADED_BUFFERS) {</a>
<a name="ln1031">    while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1032">      nextbuf = (offset &gt;= 0) ? buf-&gt;b_prev : buf-&gt;b_next;</a>
<a name="ln1033">      if (nextbuf == NULL) {</a>
<a name="ln1034">        break;</a>
<a name="ln1035">      }</a>
<a name="ln1036">      buf = nextbuf;</a>
<a name="ln1037">    }</a>
<a name="ln1038">  }</a>
<a name="ln1039">  return buf-&gt;b_fnum;</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">/// @return  the window number of &quot;win&quot; or,</a>
<a name="ln1043">///          the number of windows if &quot;win&quot; is NULL</a>
<a name="ln1044">static int current_win_nr(const win_T *win)</a>
<a name="ln1045">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1046">{</a>
<a name="ln1047">  int nr = 0;</a>
<a name="ln1048"> </a>
<a name="ln1049">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1050">    nr++;</a>
<a name="ln1051">    if (wp == win) {</a>
<a name="ln1052">      break;</a>
<a name="ln1053">    }</a>
<a name="ln1054">  }</a>
<a name="ln1055">  return nr;</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">static int current_tab_nr(tabpage_T *tab)</a>
<a name="ln1059">{</a>
<a name="ln1060">  int nr = 0;</a>
<a name="ln1061"> </a>
<a name="ln1062">  FOR_ALL_TABS(tp) {</a>
<a name="ln1063">    nr++;</a>
<a name="ln1064">    if (tp == tab) {</a>
<a name="ln1065">      break;</a>
<a name="ln1066">    }</a>
<a name="ln1067">  }</a>
<a name="ln1068">  return nr;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">#define CURRENT_WIN_NR current_win_nr(curwin)</a>
<a name="ln1072">#define LAST_WIN_NR current_win_nr(NULL)</a>
<a name="ln1073">#define CURRENT_TAB_NR current_tab_nr(curtab)</a>
<a name="ln1074">#define LAST_TAB_NR current_tab_nr(NULL)</a>
<a name="ln1075"> </a>
<a name="ln1076">/// Figure out the address type for &quot;:wincmd&quot;.</a>
<a name="ln1077">static void get_wincmd_addr_type(const char *arg, exarg_T *eap)</a>
<a name="ln1078">{</a>
<a name="ln1079">  switch (*arg) {</a>
<a name="ln1080">  case 'S':</a>
<a name="ln1081">  case Ctrl_S:</a>
<a name="ln1082">  case 's':</a>
<a name="ln1083">  case Ctrl_N:</a>
<a name="ln1084">  case 'n':</a>
<a name="ln1085">  case 'j':</a>
<a name="ln1086">  case Ctrl_J:</a>
<a name="ln1087">  case 'k':</a>
<a name="ln1088">  case Ctrl_K:</a>
<a name="ln1089">  case 'T':</a>
<a name="ln1090">  case Ctrl_R:</a>
<a name="ln1091">  case 'r':</a>
<a name="ln1092">  case 'R':</a>
<a name="ln1093">  case 'K':</a>
<a name="ln1094">  case 'J':</a>
<a name="ln1095">  case '+':</a>
<a name="ln1096">  case '-':</a>
<a name="ln1097">  case Ctrl__:</a>
<a name="ln1098">  case '_':</a>
<a name="ln1099">  case '|':</a>
<a name="ln1100">  case ']':</a>
<a name="ln1101">  case Ctrl_RSB:</a>
<a name="ln1102">  case 'g':</a>
<a name="ln1103">  case Ctrl_G:</a>
<a name="ln1104">  case Ctrl_V:</a>
<a name="ln1105">  case 'v':</a>
<a name="ln1106">  case 'h':</a>
<a name="ln1107">  case Ctrl_H:</a>
<a name="ln1108">  case 'l':</a>
<a name="ln1109">  case Ctrl_L:</a>
<a name="ln1110">  case 'H':</a>
<a name="ln1111">  case 'L':</a>
<a name="ln1112">  case '&gt;':</a>
<a name="ln1113">  case '&lt;':</a>
<a name="ln1114">  case '}':</a>
<a name="ln1115">  case 'f':</a>
<a name="ln1116">  case 'F':</a>
<a name="ln1117">  case Ctrl_F:</a>
<a name="ln1118">  case 'i':</a>
<a name="ln1119">  case Ctrl_I:</a>
<a name="ln1120">  case 'd':</a>
<a name="ln1121">  case Ctrl_D:</a>
<a name="ln1122">    // window size or any count</a>
<a name="ln1123">    eap-&gt;addr_type = ADDR_OTHER;  // -V1037</a>
<a name="ln1124">    break;</a>
<a name="ln1125"> </a>
<a name="ln1126">  case Ctrl_HAT:</a>
<a name="ln1127">  case '^':</a>
<a name="ln1128">    // buffer number</a>
<a name="ln1129">    eap-&gt;addr_type = ADDR_BUFFERS;</a>
<a name="ln1130">    break;</a>
<a name="ln1131"> </a>
<a name="ln1132">  case Ctrl_Q:</a>
<a name="ln1133">  case 'q':</a>
<a name="ln1134">  case Ctrl_C:</a>
<a name="ln1135">  case 'c':</a>
<a name="ln1136">  case Ctrl_O:</a>
<a name="ln1137">  case 'o':</a>
<a name="ln1138">  case Ctrl_W:</a>
<a name="ln1139">  case 'w':</a>
<a name="ln1140">  case 'W':</a>
<a name="ln1141">  case 'x':</a>
<a name="ln1142">  case Ctrl_X:</a>
<a name="ln1143">    // window number</a>
<a name="ln1144">    eap-&gt;addr_type = ADDR_WINDOWS;</a>
<a name="ln1145">    break;</a>
<a name="ln1146"> </a>
<a name="ln1147">  case Ctrl_Z:</a>
<a name="ln1148">  case 'z':</a>
<a name="ln1149">  case 'P':</a>
<a name="ln1150">  case 't':</a>
<a name="ln1151">  case Ctrl_T:</a>
<a name="ln1152">  case 'b':</a>
<a name="ln1153">  case Ctrl_B:</a>
<a name="ln1154">  case 'p':</a>
<a name="ln1155">  case Ctrl_P:</a>
<a name="ln1156">  case '=':</a>
<a name="ln1157">  case CAR:</a>
<a name="ln1158">    // no count</a>
<a name="ln1159">    eap-&gt;addr_type = ADDR_NONE;</a>
<a name="ln1160">    break;</a>
<a name="ln1161">  }</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">/// Skip colons and trailing whitespace, returning a pointer to the first</a>
<a name="ln1165">/// non-colon, non-whitespace character.</a>
<a name="ln1166">//</a>
<a name="ln1167">/// @param skipleadingwhite Skip leading whitespace too</a>
<a name="ln1168">static char *skip_colon_white(const char *p, bool skipleadingwhite)</a>
<a name="ln1169">{</a>
<a name="ln1170">  if (skipleadingwhite) {</a>
<a name="ln1171">    p = skipwhite(p);</a>
<a name="ln1172">  }</a>
<a name="ln1173"> </a>
<a name="ln1174">  while (*p == ':') {</a>
<a name="ln1175">    p = skipwhite(p + 1);</a>
<a name="ln1176">  }</a>
<a name="ln1177"> </a>
<a name="ln1178">  return (char *)p;</a>
<a name="ln1179">}</a>
<a name="ln1180"> </a>
<a name="ln1181">/// Set the addr type for command</a>
<a name="ln1182">///</a>
<a name="ln1183">/// @param p pointer to character after command name in cmdline</a>
<a name="ln1184">void set_cmd_addr_type(exarg_T *eap, char *p)</a>
<a name="ln1185">{</a>
<a name="ln1186">  // ea.addr_type for user commands is set by find_ucmd</a>
<a name="ln1187">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1188">    return;</a>
<a name="ln1189">  }</a>
<a name="ln1190">  if (eap-&gt;cmdidx != CMD_SIZE) {</a>
<a name="ln1191">    eap-&gt;addr_type = cmdnames[(int)eap-&gt;cmdidx].cmd_addr_type;</a>
<a name="ln1192">  } else {</a>
<a name="ln1193">    eap-&gt;addr_type = ADDR_LINES;</a>
<a name="ln1194">  }</a>
<a name="ln1195">  // :wincmd range depends on the argument</a>
<a name="ln1196">  if (eap-&gt;cmdidx == CMD_wincmd &amp;&amp; p != NULL) {</a>
<a name="ln1197">    get_wincmd_addr_type(skipwhite(p), eap);</a>
<a name="ln1198">  }</a>
<a name="ln1199">  // :.cc in quickfix window uses line number</a>
<a name="ln1200">  if ((eap-&gt;cmdidx == CMD_cc || eap-&gt;cmdidx == CMD_ll) &amp;&amp; bt_quickfix(curbuf)) {</a>
<a name="ln1201">    eap-&gt;addr_type = ADDR_OTHER;</a>
<a name="ln1202">  }</a>
<a name="ln1203">}</a>
<a name="ln1204"> </a>
<a name="ln1205">/// Get default range number for command based on its address type</a>
<a name="ln1206">linenr_T get_cmd_default_range(exarg_T *eap)</a>
<a name="ln1207">{</a>
<a name="ln1208">  switch (eap-&gt;addr_type) {</a>
<a name="ln1209">  case ADDR_LINES:</a>
<a name="ln1210">  case ADDR_OTHER:</a>
<a name="ln1211">    // Default is the cursor line number.  Avoid using an invalid</a>
<a name="ln1212">    // line number though.</a>
<a name="ln1213">    return MIN(curwin-&gt;w_cursor.lnum, curbuf-&gt;b_ml.ml_line_count);</a>
<a name="ln1214">    break;</a>
<a name="ln1215">  case ADDR_WINDOWS:</a>
<a name="ln1216">    return CURRENT_WIN_NR;</a>
<a name="ln1217">    break;</a>
<a name="ln1218">  case ADDR_ARGUMENTS:</a>
<a name="ln1219">    return MIN(curwin-&gt;w_arg_idx + 1, ARGCOUNT);</a>
<a name="ln1220">    break;</a>
<a name="ln1221">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1222">  case ADDR_BUFFERS:</a>
<a name="ln1223">    return curbuf-&gt;b_fnum;</a>
<a name="ln1224">    break;</a>
<a name="ln1225">  case ADDR_TABS:</a>
<a name="ln1226">    return CURRENT_TAB_NR;</a>
<a name="ln1227">    break;</a>
<a name="ln1228">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1229">  case ADDR_UNSIGNED:</a>
<a name="ln1230">    return 1;</a>
<a name="ln1231">    break;</a>
<a name="ln1232">  case ADDR_QUICKFIX:</a>
<a name="ln1233">    return (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln1234">    break;</a>
<a name="ln1235">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1236">    return qf_get_cur_valid_idx(eap);</a>
<a name="ln1237">    break;</a>
<a name="ln1238">  default:</a>
<a name="ln1239">    return 0;</a>
<a name="ln1240">    // Will give an error later if a range is found.</a>
<a name="ln1241">    break;</a>
<a name="ln1242">  }</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">/// Set default command range for -range=% based on the addr type of the command</a>
<a name="ln1246">void set_cmd_dflall_range(exarg_T *eap)</a>
<a name="ln1247">{</a>
<a name="ln1248">  buf_T *buf;</a>
<a name="ln1249"> </a>
<a name="ln1250">  eap-&gt;line1 = 1;</a>
<a name="ln1251">  switch (eap-&gt;addr_type) {</a>
<a name="ln1252">  case ADDR_LINES:</a>
<a name="ln1253">  case ADDR_OTHER:</a>
<a name="ln1254">    eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1255">    break;</a>
<a name="ln1256">  case ADDR_LOADED_BUFFERS:</a>
<a name="ln1257">    buf = firstbuf;</a>
<a name="ln1258">    while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1259">      buf = buf-&gt;b_next;</a>
<a name="ln1260">    }</a>
<a name="ln1261">    eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln1262">    buf = lastbuf;</a>
<a name="ln1263">    while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln1264">      buf = buf-&gt;b_prev;</a>
<a name="ln1265">    }</a>
<a name="ln1266">    eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln1267">    break;</a>
<a name="ln1268">  case ADDR_BUFFERS:</a>
<a name="ln1269">    eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln1270">    eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln1271">    break;</a>
<a name="ln1272">  case ADDR_WINDOWS:</a>
<a name="ln1273">    eap-&gt;line2 = LAST_WIN_NR;</a>
<a name="ln1274">    break;</a>
<a name="ln1275">  case ADDR_TABS:</a>
<a name="ln1276">    eap-&gt;line2 = LAST_TAB_NR;</a>
<a name="ln1277">    break;</a>
<a name="ln1278">  case ADDR_TABS_RELATIVE:</a>
<a name="ln1279">    eap-&gt;line2 = 1;</a>
<a name="ln1280">    break;</a>
<a name="ln1281">  case ADDR_ARGUMENTS:</a>
<a name="ln1282">    if (ARGCOUNT == 0) {</a>
<a name="ln1283">      eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln1284">    } else {</a>
<a name="ln1285">      eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln1286">    }</a>
<a name="ln1287">    break;</a>
<a name="ln1288">  case ADDR_QUICKFIX_VALID:</a>
<a name="ln1289">    eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln1290">    if (eap-&gt;line2 == 0) {</a>
<a name="ln1291">      eap-&gt;line2 = 1;</a>
<a name="ln1292">    }</a>
<a name="ln1293">    break;</a>
<a name="ln1294">  case ADDR_NONE:</a>
<a name="ln1295">  case ADDR_UNSIGNED:</a>
<a name="ln1296">  case ADDR_QUICKFIX:</a>
<a name="ln1297">    iemsg(_(&quot;INTERNAL: Cannot use EX_DFLALL &quot;</a>
<a name="ln1298">            &quot;with ADDR_NONE, ADDR_UNSIGNED or ADDR_QUICKFIX&quot;));</a>
<a name="ln1299">    break;</a>
<a name="ln1300">  }</a>
<a name="ln1301">}</a>
<a name="ln1302"> </a>
<a name="ln1303">static void parse_register(exarg_T *eap)</a>
<a name="ln1304">{</a>
<a name="ln1305">  // Accept numbered register only when no count allowed (:put)</a>
<a name="ln1306">  if ((eap-&gt;argt &amp; EX_REGSTR)</a>
<a name="ln1307">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln1308">      // Do not allow register = for user commands</a>
<a name="ln1309">      &amp;&amp; (!IS_USER_CMDIDX(eap-&gt;cmdidx) || *eap-&gt;arg != '=')</a>
<a name="ln1310">      &amp;&amp; !((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg))) {</a>
<a name="ln1311">    if (valid_yank_reg(*eap-&gt;arg, (eap-&gt;cmdidx != CMD_put</a>
<a name="ln1312">                                   &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)))) {</a>
<a name="ln1313">      eap-&gt;regname = (uint8_t)(*eap-&gt;arg++);</a>
<a name="ln1314">      // for '=' register: accept the rest of the line as an expression</a>
<a name="ln1315">      if (eap-&gt;arg[-1] == '=' &amp;&amp; eap-&gt;arg[0] != NUL) {</a>
<a name="ln1316">        if (!eap-&gt;skip) {</a>
<a name="ln1317">          set_expr_line(xstrdup(eap-&gt;arg));</a>
<a name="ln1318">        }</a>
<a name="ln1319">        eap-&gt;arg += strlen(eap-&gt;arg);</a>
<a name="ln1320">      }</a>
<a name="ln1321">      eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1322">    }</a>
<a name="ln1323">  }</a>
<a name="ln1324">}</a>
<a name="ln1325"> </a>
<a name="ln1326">// Change line1 and line2 of Ex command to use count</a>
<a name="ln1327">void set_cmd_count(exarg_T *eap, linenr_T count, bool validate)</a>
<a name="ln1328">{</a>
<a name="ln1329">  if (eap-&gt;addr_type != ADDR_LINES) {  // e.g. :buffer 2, :sleep 3</a>
<a name="ln1330">    eap-&gt;line2 = count;</a>
<a name="ln1331">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln1332">      eap-&gt;addr_count = 1;</a>
<a name="ln1333">    }</a>
<a name="ln1334">  } else {</a>
<a name="ln1335">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln1336">    eap-&gt;line2 += count - 1;</a>
<a name="ln1337">    eap-&gt;addr_count++;</a>
<a name="ln1338">    // Be vi compatible: no error message for out of range.</a>
<a name="ln1339">    if (validate &amp;&amp; eap-&gt;line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln1340">      eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln1341">    }</a>
<a name="ln1342">  }</a>
<a name="ln1343">}</a>
<a name="ln1344"> </a>
<a name="ln1345">static int parse_count(exarg_T *eap, const char **errormsg, bool validate)</a>
<a name="ln1346">{</a>
<a name="ln1347">  // Check for a count.  When accepting a EX_BUFNAME, don't use &quot;123foo&quot; as a</a>
<a name="ln1348">  // count, it's a buffer name.</a>
<a name="ln1349">  char *p;</a>
<a name="ln1350"> </a>
<a name="ln1351">  if ((eap-&gt;argt &amp; EX_COUNT) &amp;&amp; ascii_isdigit(*eap-&gt;arg)</a>
<a name="ln1352">      &amp;&amp; (!(eap-&gt;argt &amp; EX_BUFNAME) || *(p = skipdigits(eap-&gt;arg + 1)) == NUL</a>
<a name="ln1353">          || ascii_iswhite(*p))) {</a>
<a name="ln1354">    linenr_T n = getdigits_int32(&amp;eap-&gt;arg, false, -1);</a>
<a name="ln1355">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln1356"> </a>
<a name="ln1357">    if (eap-&gt;args != NULL) {</a>
<a name="ln1358">      assert(eap-&gt;argc &gt; 0 &amp;&amp; eap-&gt;arg &gt;= eap-&gt;args[0]);</a>
<a name="ln1359">      // If eap-&gt;arg is still pointing to the first argument, just make eap-&gt;args[0] point to the</a>
<a name="ln1360">      // same location. This is needed for usecases like vim.cmd.sleep('10m'). If eap-&gt;arg is</a>
<a name="ln1361">      // pointing outside the first argument, shift arguments by 1.</a>
<a name="ln1362">      if (eap-&gt;arg &lt; eap-&gt;args[0] + eap-&gt;arglens[0]) {</a>
<a name="ln1363">        eap-&gt;arglens[0] -= (size_t)(eap-&gt;arg - eap-&gt;args[0]);</a>
<a name="ln1364">        eap-&gt;args[0] = eap-&gt;arg;</a>
<a name="ln1365">      } else {</a>
<a name="ln1366">        shift_cmd_args(eap);</a>
<a name="ln1367">      }</a>
<a name="ln1368">    }</a>
<a name="ln1369"> </a>
<a name="ln1370">    if (n &lt;= 0 &amp;&amp; (eap-&gt;argt &amp; EX_ZEROR) == 0) {</a>
<a name="ln1371">      if (errormsg != NULL) {</a>
<a name="ln1372">        *errormsg = _(e_zerocount);</a>
<a name="ln1373">      }</a>
<a name="ln1374">      return FAIL;</a>
<a name="ln1375">    }</a>
<a name="ln1376">    set_cmd_count(eap, n, validate);</a>
<a name="ln1377">  }</a>
<a name="ln1378"> </a>
<a name="ln1379">  return OK;</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">/// Check if command is not implemented</a>
<a name="ln1383">bool is_cmd_ni(cmdidx_T cmdidx)</a>
<a name="ln1384">{</a>
<a name="ln1385">  return !IS_USER_CMDIDX(cmdidx) &amp;&amp; (cmdnames[cmdidx].cmd_func == ex_ni</a>
<a name="ln1386">                                     || cmdnames[cmdidx].cmd_func == ex_script_ni);</a>
<a name="ln1387">}</a>
<a name="ln1388"> </a>
<a name="ln1389">/// Parse command line and return information about the first command.</a>
<a name="ln1390">/// If parsing is done successfully, need to free cmod_filter_pat and cmod_filter_regmatch.regprog</a>
<a name="ln1391">/// after calling, usually done using undo_cmdmod() or execute_cmd().</a>
<a name="ln1392">///</a>
<a name="ln1393">/// @param cmdline Command line string</a>
<a name="ln1394">/// @param[out] eap Ex command arguments</a>
<a name="ln1395">/// @param[out] cmdinfo Command parse information</a>
<a name="ln1396">/// @param[out] errormsg Error message, if any</a>
<a name="ln1397">///</a>
<a name="ln1398">/// @return Success or failure</a>
<a name="ln1399">bool parse_cmdline(char *cmdline, exarg_T *eap, CmdParseInfo *cmdinfo, const char **errormsg)</a>
<a name="ln1400">{</a>
<a name="ln1401">  char *after_modifier = NULL;</a>
<a name="ln1402">  bool retval = false;</a>
<a name="ln1403">  // parsing the command modifiers may set ex_pressedreturn</a>
<a name="ln1404">  const bool save_ex_pressedreturn = ex_pressedreturn;</a>
<a name="ln1405">  // parsing the command range may require moving the cursor</a>
<a name="ln1406">  const pos_T save_cursor = curwin-&gt;w_cursor;</a>
<a name="ln1407">  // parsing the command range may set the last search pattern</a>
<a name="ln1408">  save_last_search_pattern();</a>
<a name="ln1409"> </a>
<a name="ln1410">  // Initialize cmdinfo</a>
<a name="ln1411">  CLEAR_POINTER(cmdinfo);</a>
<a name="ln1412"> </a>
<a name="ln1413">  // Initialize eap</a>
<a name="ln1414">  *eap = (exarg_T){</a>
<a name="ln1415">    .line1 = 1,</a>
<a name="ln1416">    .line2 = 1,</a>
<a name="ln1417">    .cmd = cmdline,</a>
<a name="ln1418">    .cmdlinep = &amp;cmdline,</a>
<a name="ln1419">    .getline = NULL,</a>
<a name="ln1420">    .cookie = NULL,</a>
<a name="ln1421">  };</a>
<a name="ln1422"> </a>
<a name="ln1423">  // Parse command modifiers</a>
<a name="ln1424">  if (parse_command_modifiers(eap, errormsg, &amp;cmdinfo-&gt;cmdmod, false) == FAIL) {</a>
<a name="ln1425">    goto end;</a>
<a name="ln1426">  }</a>
<a name="ln1427">  after_modifier = eap-&gt;cmd;</a>
<a name="ln1428"> </a>
<a name="ln1429">  // Save location after command modifiers</a>
<a name="ln1430">  char *cmd = eap-&gt;cmd;</a>
<a name="ln1431">  // Skip ranges to find command name since we need the command to know what kind of range it uses</a>
<a name="ln1432">  eap-&gt;cmd = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln1433">  if (*eap-&gt;cmd == '*') {</a>
<a name="ln1434">    eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln1435">  }</a>
<a name="ln1436">  char *p = find_ex_command(eap, NULL);</a>
<a name="ln1437">  if (p == NULL) {</a>
<a name="ln1438">    *errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln1439">    goto end;</a>
<a name="ln1440">  }</a>
<a name="ln1441"> </a>
<a name="ln1442">  // Set command address type and parse command range</a>
<a name="ln1443">  set_cmd_addr_type(eap, p);</a>
<a name="ln1444">  eap-&gt;cmd = cmd;</a>
<a name="ln1445">  if (parse_cmd_address(eap, errormsg, true) == FAIL) {</a>
<a name="ln1446">    goto end;</a>
<a name="ln1447">  }</a>
<a name="ln1448"> </a>
<a name="ln1449">  // Skip colon and whitespace</a>
<a name="ln1450">  eap-&gt;cmd = skip_colon_white(eap-&gt;cmd, true);</a>
<a name="ln1451">  // Fail if command is a comment or if command doesn't exist</a>
<a name="ln1452">  if (*eap-&gt;cmd == NUL || *eap-&gt;cmd == '&quot;') {</a>
<a name="ln1453">    goto end;</a>
<a name="ln1454">  }</a>
<a name="ln1455">  // Fail if command is invalid</a>
<a name="ln1456">  if (eap-&gt;cmdidx == CMD_SIZE) {</a>
<a name="ln1457">    xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln1458">    // If the modifier was parsed OK the error must be in the following command</a>
<a name="ln1459">    char *cmdname = after_modifier ? after_modifier : cmdline;</a>
<a name="ln1460">    append_command(cmdname);</a>
<a name="ln1461">    *errormsg = IObuff;</a>
<a name="ln1462">    goto end;</a>
<a name="ln1463">  }</a>
<a name="ln1464"> </a>
<a name="ln1465">  // Correctly set 'forceit' for commands</a>
<a name="ln1466">  if (*p == '!' &amp;&amp; eap-&gt;cmdidx != CMD_substitute</a>
<a name="ln1467">      &amp;&amp; eap-&gt;cmdidx != CMD_smagic &amp;&amp; eap-&gt;cmdidx != CMD_snomagic) {</a>
<a name="ln1468">    p++;</a>
<a name="ln1469">    eap-&gt;forceit = true;</a>
<a name="ln1470">  } else {</a>
<a name="ln1471">    eap-&gt;forceit = false;</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  // Parse arguments.</a>
<a name="ln1475">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1476">    eap-&gt;argt = cmdnames[(int)eap-&gt;cmdidx].cmd_argt;</a>
<a name="ln1477">  }</a>
<a name="ln1478">  // Skip to start of argument.</a>
<a name="ln1479">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln1480">  if (eap-&gt;cmdidx == CMD_bang) {</a>
<a name="ln1481">    eap-&gt;arg = p;</a>
<a name="ln1482">  } else {</a>
<a name="ln1483">    eap-&gt;arg = skipwhite(p);</a>
<a name="ln1484">  }</a>
<a name="ln1485"> </a>
<a name="ln1486">  // Don't treat &quot;:r! filter&quot; like a bang</a>
<a name="ln1487">  if (eap-&gt;cmdidx == CMD_read) {</a>
<a name="ln1488">    if (eap-&gt;forceit) {</a>
<a name="ln1489">      eap-&gt;forceit = false;                     // :r! filter</a>
<a name="ln1490">    }</a>
<a name="ln1491">  }</a>
<a name="ln1492"> </a>
<a name="ln1493">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln1494">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln1495">  if ((eap-&gt;argt &amp; EX_TRLBAR)) {</a>
<a name="ln1496">    separate_nextcmd(eap);</a>
<a name="ln1497">  }</a>
<a name="ln1498">  // Fail if command doesn't support bang but is used with a bang</a>
<a name="ln1499">  if (!(eap-&gt;argt &amp; EX_BANG) &amp;&amp; eap-&gt;forceit) {</a>
<a name="ln1500">    *errormsg = _(e_nobang);</a>
<a name="ln1501">    goto end;</a>
<a name="ln1502">  }</a>
<a name="ln1503">  // Fail if command doesn't support a range but it is given a range</a>
<a name="ln1504">  if (!(eap-&gt;argt &amp; EX_RANGE) &amp;&amp; eap-&gt;addr_count &gt; 0) {</a>
<a name="ln1505">    *errormsg = _(e_norange);</a>
<a name="ln1506">    goto end;</a>
<a name="ln1507">  }</a>
<a name="ln1508">  // Set default range for command if required</a>
<a name="ln1509">  if ((eap-&gt;argt &amp; EX_DFLALL) &amp;&amp; eap-&gt;addr_count == 0) {</a>
<a name="ln1510">    set_cmd_dflall_range(eap);</a>
<a name="ln1511">  }</a>
<a name="ln1512"> </a>
<a name="ln1513">  // Parse register and count</a>
<a name="ln1514">  parse_register(eap);</a>
<a name="ln1515">  if (parse_count(eap, errormsg, false) == FAIL) {</a>
<a name="ln1516">    goto end;</a>
<a name="ln1517">  }</a>
<a name="ln1518"> </a>
<a name="ln1519">  // Remove leading whitespace and colon from next command</a>
<a name="ln1520">  if (eap-&gt;nextcmd) {</a>
<a name="ln1521">    eap-&gt;nextcmd = skip_colon_white(eap-&gt;nextcmd, true);</a>
<a name="ln1522">  }</a>
<a name="ln1523"> </a>
<a name="ln1524">  // Set the &quot;magic&quot; values (characters that get treated specially)</a>
<a name="ln1525">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1526">    cmdinfo-&gt;magic.file = true;</a>
<a name="ln1527">  }</a>
<a name="ln1528">  if (eap-&gt;argt &amp; EX_TRLBAR) {</a>
<a name="ln1529">    cmdinfo-&gt;magic.bar = true;</a>
<a name="ln1530">  }</a>
<a name="ln1531"> </a>
<a name="ln1532">  retval = true;</a>
<a name="ln1533">end:</a>
<a name="ln1534">  if (!retval) {</a>
<a name="ln1535">    undo_cmdmod(&amp;cmdinfo-&gt;cmdmod);</a>
<a name="ln1536">  }</a>
<a name="ln1537">  ex_pressedreturn = save_ex_pressedreturn;</a>
<a name="ln1538">  curwin-&gt;w_cursor = save_cursor;</a>
<a name="ln1539">  restore_last_search_pattern();</a>
<a name="ln1540">  return retval;</a>
<a name="ln1541">}</a>
<a name="ln1542"> </a>
<a name="ln1543">// Shift Ex-command arguments to the right.</a>
<a name="ln1544">static void shift_cmd_args(exarg_T *eap)</a>
<a name="ln1545">{</a>
<a name="ln1546">  assert(eap-&gt;args != NULL &amp;&amp; eap-&gt;argc &gt; 0);</a>
<a name="ln1547"> </a>
<a name="ln1548">  char **oldargs = eap-&gt;args;</a>
<a name="ln1549">  size_t *oldarglens = eap-&gt;arglens;</a>
<a name="ln1550"> </a>
<a name="ln1551">  eap-&gt;argc--;</a>
<a name="ln1552">  eap-&gt;args = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(char *)) : NULL;</a>
<a name="ln1553">  eap-&gt;arglens = eap-&gt;argc &gt; 0 ? xcalloc(eap-&gt;argc, sizeof(size_t)) : NULL;</a>
<a name="ln1554"> </a>
<a name="ln1555">  for (size_t i = 0; i &lt; eap-&gt;argc; i++) {</a>
<a name="ln1556">    eap-&gt;args[i] = oldargs[i + 1];</a>
<a name="ln1557">    eap-&gt;arglens[i] = oldarglens[i + 1];</a>
<a name="ln1558">  }</a>
<a name="ln1559"> </a>
<a name="ln1560">  // If there are no arguments, make eap-&gt;arg point to the end of string.</a>
<a name="ln1561">  eap-&gt;arg = (eap-&gt;argc &gt; 0 ? eap-&gt;args[0] : (oldargs[0] + oldarglens[0]));</a>
<a name="ln1562"> </a>
<a name="ln1563">  xfree(oldargs);</a>
<a name="ln1564">  xfree(oldarglens);</a>
<a name="ln1565">}</a>
<a name="ln1566"> </a>
<a name="ln1567">static int execute_cmd0(int *retv, exarg_T *eap, const char **errormsg, bool preview)</a>
<a name="ln1568">{</a>
<a name="ln1569">  // If filename expansion is enabled, expand filenames</a>
<a name="ln1570">  if (eap-&gt;argt &amp; EX_XFILE) {</a>
<a name="ln1571">    if (expand_filename(eap, eap-&gt;cmdlinep, errormsg) == FAIL) {</a>
<a name="ln1572">      return FAIL;</a>
<a name="ln1573">    }</a>
<a name="ln1574">  }</a>
<a name="ln1575"> </a>
<a name="ln1576">  // Accept buffer name.  Cannot be used at the same time with a buffer</a>
<a name="ln1577">  // number.  Don't do this for a user command.</a>
<a name="ln1578">  if ((eap-&gt;argt &amp; EX_BUFNAME) &amp;&amp; *eap-&gt;arg != NUL &amp;&amp; eap-&gt;addr_count == 0</a>
<a name="ln1579">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1580">    if (eap-&gt;args == NULL) {</a>
<a name="ln1581">      // If argument positions are not specified, search the argument for the buffer name.</a>
<a name="ln1582">      // :bdelete, :bwipeout and :bunload take several arguments, separated by spaces:</a>
<a name="ln1583">      // find next space (skipping over escaped characters).</a>
<a name="ln1584">      // The others take one argument: ignore trailing spaces.</a>
<a name="ln1585">      char *p;</a>
<a name="ln1586"> </a>
<a name="ln1587">      if (eap-&gt;cmdidx == CMD_bdelete || eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln1588">          || eap-&gt;cmdidx == CMD_bunload) {</a>
<a name="ln1589">        p = skiptowhite_esc(eap-&gt;arg);</a>
<a name="ln1590">      } else {</a>
<a name="ln1591">        p = eap-&gt;arg + strlen(eap-&gt;arg);</a>
<a name="ln1592">        while (p &gt; eap-&gt;arg &amp;&amp; ascii_iswhite(p[-1])) {</a>
<a name="ln1593">          p--;</a>
<a name="ln1594">        }</a>
<a name="ln1595">      }</a>
<a name="ln1596">      eap-&gt;line2 = buflist_findpat(eap-&gt;arg, p, (eap-&gt;argt &amp; EX_BUFUNL) != 0,</a>
<a name="ln1597">                                   false, false);</a>
<a name="ln1598">      eap-&gt;addr_count = 1;</a>
<a name="ln1599">      eap-&gt;arg = skipwhite(p);</a>
<a name="ln1600">    } else {</a>
<a name="ln1601">      // If argument positions are specified, just use the first argument</a>
<a name="ln1602">      eap-&gt;line2 = buflist_findpat(eap-&gt;args[0],</a>
<a name="ln1603">                                   eap-&gt;args[0] + eap-&gt;arglens[0],</a>
<a name="ln1604">                                   (eap-&gt;argt &amp; EX_BUFUNL) != 0, false, false);</a>
<a name="ln1605">      eap-&gt;addr_count = 1;</a>
<a name="ln1606">      shift_cmd_args(eap);</a>
<a name="ln1607">    }</a>
<a name="ln1608">    if (eap-&gt;line2 &lt; 0) {  // failed</a>
<a name="ln1609">      return FAIL;</a>
<a name="ln1610">    }</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613">  // The :try command saves the emsg_silent flag, reset it here when</a>
<a name="ln1614">  // &quot;:silent! try&quot; was used, it should only apply to :try itself.</a>
<a name="ln1615">  if (eap-&gt;cmdidx == CMD_try &amp;&amp; cmdmod.cmod_did_esilent &gt; 0) {</a>
<a name="ln1616">    emsg_silent -= cmdmod.cmod_did_esilent;</a>
<a name="ln1617">    if (emsg_silent &lt; 0) {</a>
<a name="ln1618">      emsg_silent = 0;</a>
<a name="ln1619">    }</a>
<a name="ln1620">    cmdmod.cmod_did_esilent = 0;</a>
<a name="ln1621">  }</a>
<a name="ln1622"> </a>
<a name="ln1623">  // Execute the command</a>
<a name="ln1624">  if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1625">    // Execute a user-defined command.</a>
<a name="ln1626">    *retv = do_ucmd(eap, preview);</a>
<a name="ln1627">  } else {</a>
<a name="ln1628">    // Call the function to execute the builtin command or the preview callback.</a>
<a name="ln1629">    eap-&gt;errmsg = NULL;</a>
<a name="ln1630">    if (preview) {</a>
<a name="ln1631">      *retv = (cmdnames[eap-&gt;cmdidx].cmd_preview_func)(eap, cmdpreview_get_ns(),</a>
<a name="ln1632">                                                       cmdpreview_get_bufnr());</a>
<a name="ln1633">    } else {</a>
<a name="ln1634">      (cmdnames[eap-&gt;cmdidx].cmd_func)(eap);</a>
<a name="ln1635">    }</a>
<a name="ln1636">    if (eap-&gt;errmsg != NULL) {</a>
<a name="ln1637">      *errormsg = eap-&gt;errmsg;</a>
<a name="ln1638">    }</a>
<a name="ln1639">  }</a>
<a name="ln1640"> </a>
<a name="ln1641">  return OK;</a>
<a name="ln1642">}</a>
<a name="ln1643"> </a>
<a name="ln1644">/// Execute an Ex command using parsed command line information.</a>
<a name="ln1645">/// Does not do any validation of the Ex command arguments.</a>
<a name="ln1646">///</a>
<a name="ln1647">/// @param eap Ex-command arguments</a>
<a name="ln1648">/// @param cmdinfo Command parse information</a>
<a name="ln1649">/// @param preview Execute command preview callback instead of actual command</a>
<a name="ln1650">int execute_cmd(exarg_T *eap, CmdParseInfo *cmdinfo, bool preview)</a>
<a name="ln1651">{</a>
<a name="ln1652">  const char *errormsg = NULL;</a>
<a name="ln1653">  int retv = 0;</a>
<a name="ln1654"> </a>
<a name="ln1655">#undef ERROR</a>
<a name="ln1656">#define ERROR(msg) \</a>
<a name="ln1657">  do { \</a>
<a name="ln1658">    errormsg = msg; \</a>
<a name="ln1659">    goto end; \</a>
<a name="ln1660">  } while (0)</a>
<a name="ln1661"> </a>
<a name="ln1662">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1663">  cmdmod = cmdinfo-&gt;cmdmod;</a>
<a name="ln1664"> </a>
<a name="ln1665">  // Apply command modifiers</a>
<a name="ln1666">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1667"> </a>
<a name="ln1668">  if (!MODIFIABLE(curbuf) &amp;&amp; (eap-&gt;argt &amp; EX_MODIFY)</a>
<a name="ln1669">      // allow :put in terminals</a>
<a name="ln1670">      &amp;&amp; !(curbuf-&gt;terminal &amp;&amp; eap-&gt;cmdidx == CMD_put)) {</a>
<a name="ln1671">    ERROR(_(e_modifiable));</a>
<a name="ln1672">  }</a>
<a name="ln1673">  if (!IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln1674">    if (cmdwin_type != 0 &amp;&amp; !(eap-&gt;argt &amp; EX_CMDWIN)) {</a>
<a name="ln1675">      // Command not allowed in the command line window</a>
<a name="ln1676">      ERROR(_(e_cmdwin));</a>
<a name="ln1677">    }</a>
<a name="ln1678">    if (text_locked() &amp;&amp; !(eap-&gt;argt &amp; EX_LOCK_OK)) {</a>
<a name="ln1679">      // Command not allowed when text is locked</a>
<a name="ln1680">      ERROR(_(get_text_locked_msg()));</a>
<a name="ln1681">    }</a>
<a name="ln1682">  }</a>
<a name="ln1683">  // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln1684">  // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln1685">  // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln1686">  // Do allow &quot;:file&quot; with no arguments</a>
<a name="ln1687">  if (!(eap-&gt;argt &amp; EX_CMDWIN)</a>
<a name="ln1688">      &amp;&amp; eap-&gt;cmdidx != CMD_checktime</a>
<a name="ln1689">      &amp;&amp; eap-&gt;cmdidx != CMD_edit</a>
<a name="ln1690">      &amp;&amp; !(eap-&gt;cmdidx == CMD_file &amp;&amp; *eap-&gt;arg == NUL)</a>
<a name="ln1691">      &amp;&amp; !IS_USER_CMDIDX(eap-&gt;cmdidx)</a>
<a name="ln1692">      &amp;&amp; curbuf_locked()) {</a>
<a name="ln1693">    goto end;</a>
<a name="ln1694">  }</a>
<a name="ln1695"> </a>
<a name="ln1696">  correct_range(eap);</a>
<a name="ln1697"> </a>
<a name="ln1698">  if (((eap-&gt;argt &amp; EX_WHOLEFOLD) || eap-&gt;addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln1699">      &amp;&amp; eap-&gt;addr_type == ADDR_LINES) {</a>
<a name="ln1700">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln1701">    // at the end of a closed fold.</a>
<a name="ln1702">    (void)hasFolding(eap-&gt;line1, &amp;eap-&gt;line1, NULL);</a>
<a name="ln1703">    (void)hasFolding(eap-&gt;line2, NULL, &amp;eap-&gt;line2);</a>
<a name="ln1704">  }</a>
<a name="ln1705"> </a>
<a name="ln1706">  // Use first argument as count when possible</a>
<a name="ln1707">  if (parse_count(eap, &amp;errormsg, true) == FAIL) {</a>
<a name="ln1708">    goto end;</a>
<a name="ln1709">  }</a>
<a name="ln1710"> </a>
<a name="ln1711">  // Execute the command</a>
<a name="ln1712">  execute_cmd0(&amp;retv, eap, &amp;errormsg, preview);</a>
<a name="ln1713"> </a>
<a name="ln1714">end:</a>
<a name="ln1715">  if (errormsg != NULL &amp;&amp; *errormsg != NUL) {</a>
<a name="ln1716">    emsg(errormsg);</a>
<a name="ln1717">  }</a>
<a name="ln1718">  // Undo command modifiers</a>
<a name="ln1719">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln1720">  cmdmod = save_cmdmod;</a>
<a name="ln1721">  return retv;</a>
<a name="ln1722">#undef ERROR</a>
<a name="ln1723">}</a>
<a name="ln1724"> </a>
<a name="ln1725">static void profile_cmd(const exarg_T *eap, cstack_T *cstack, LineGetter fgetline, void *cookie)</a>
<a name="ln1726">{</a>
<a name="ln1727">  // Count this line for profiling if skip is true.</a>
<a name="ln1728">  if (do_profiling == PROF_YES</a>
<a name="ln1729">      &amp;&amp; (!eap-&gt;skip || cstack-&gt;cs_idx == 0</a>
<a name="ln1730">          || (cstack-&gt;cs_idx &gt; 0</a>
<a name="ln1731">              &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx - 1] &amp; CSF_ACTIVE)))) {</a>
<a name="ln1732">    bool skip = did_emsg || got_int || did_throw;</a>
<a name="ln1733"> </a>
<a name="ln1734">    if (eap-&gt;cmdidx == CMD_catch) {</a>
<a name="ln1735">      skip = !skip &amp;&amp; !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1736">                        &amp;&amp; (cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_THROWN)</a>
<a name="ln1737">                        &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_CAUGHT));</a>
<a name="ln1738">    } else if (eap-&gt;cmdidx == CMD_else || eap-&gt;cmdidx == CMD_elseif) {</a>
<a name="ln1739">      skip = skip || !(cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1740">                       &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx]</a>
<a name="ln1741">                            &amp; (CSF_ACTIVE | CSF_TRUE)));</a>
<a name="ln1742">    } else if (eap-&gt;cmdidx == CMD_finally) {</a>
<a name="ln1743">      skip = false;</a>
<a name="ln1744">    } else if (eap-&gt;cmdidx != CMD_endif</a>
<a name="ln1745">               &amp;&amp; eap-&gt;cmdidx != CMD_endfor</a>
<a name="ln1746">               &amp;&amp; eap-&gt;cmdidx != CMD_endtry</a>
<a name="ln1747">               &amp;&amp; eap-&gt;cmdidx != CMD_endwhile) {</a>
<a name="ln1748">      skip = eap-&gt;skip;</a>
<a name="ln1749">    }</a>
<a name="ln1750"> </a>
<a name="ln1751">    if (!skip) {</a>
<a name="ln1752">      if (getline_equal(fgetline, cookie, get_func_line)) {</a>
<a name="ln1753">        func_line_exec(getline_cookie(fgetline, cookie));</a>
<a name="ln1754">      } else if (getline_equal(fgetline, cookie, getsourceline)) {</a>
<a name="ln1755">        script_line_exec();</a>
<a name="ln1756">      }</a>
<a name="ln1757">    }</a>
<a name="ln1758">  }</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">static bool skip_cmd(const exarg_T *eap)</a>
<a name="ln1762">{</a>
<a name="ln1763">  // Skip the command when it's not going to be executed.</a>
<a name="ln1764">  // The commands like :if, :endif, etc. always need to be executed.</a>
<a name="ln1765">  // Also make an exception for commands that handle a trailing command</a>
<a name="ln1766">  // themselves.</a>
<a name="ln1767">  if (eap-&gt;skip) {</a>
<a name="ln1768">    switch (eap-&gt;cmdidx) {</a>
<a name="ln1769">    // commands that need evaluation</a>
<a name="ln1770">    case CMD_while:</a>
<a name="ln1771">    case CMD_endwhile:</a>
<a name="ln1772">    case CMD_for:</a>
<a name="ln1773">    case CMD_endfor:</a>
<a name="ln1774">    case CMD_if:</a>
<a name="ln1775">    case CMD_elseif:</a>
<a name="ln1776">    case CMD_else:</a>
<a name="ln1777">    case CMD_endif:</a>
<a name="ln1778">    case CMD_try:</a>
<a name="ln1779">    case CMD_catch:</a>
<a name="ln1780">    case CMD_finally:</a>
<a name="ln1781">    case CMD_endtry:</a>
<a name="ln1782">    case CMD_function:</a>
<a name="ln1783">      break;</a>
<a name="ln1784"> </a>
<a name="ln1785">    // Commands that handle '|' themselves.  Check: A command should</a>
<a name="ln1786">    // either have the EX_TRLBAR flag, appear in this list or appear in</a>
<a name="ln1787">    // the list at &quot;:help :bar&quot;.</a>
<a name="ln1788">    case CMD_aboveleft:</a>
<a name="ln1789">    case CMD_and:</a>
<a name="ln1790">    case CMD_belowright:</a>
<a name="ln1791">    case CMD_botright:</a>
<a name="ln1792">    case CMD_browse:</a>
<a name="ln1793">    case CMD_call:</a>
<a name="ln1794">    case CMD_confirm:</a>
<a name="ln1795">    case CMD_const:</a>
<a name="ln1796">    case CMD_delfunction:</a>
<a name="ln1797">    case CMD_djump:</a>
<a name="ln1798">    case CMD_dlist:</a>
<a name="ln1799">    case CMD_dsearch:</a>
<a name="ln1800">    case CMD_dsplit:</a>
<a name="ln1801">    case CMD_echo:</a>
<a name="ln1802">    case CMD_echoerr:</a>
<a name="ln1803">    case CMD_echomsg:</a>
<a name="ln1804">    case CMD_echon:</a>
<a name="ln1805">    case CMD_eval:</a>
<a name="ln1806">    case CMD_execute:</a>
<a name="ln1807">    case CMD_filter:</a>
<a name="ln1808">    case CMD_help:</a>
<a name="ln1809">    case CMD_hide:</a>
<a name="ln1810">    case CMD_horizontal:</a>
<a name="ln1811">    case CMD_ijump:</a>
<a name="ln1812">    case CMD_ilist:</a>
<a name="ln1813">    case CMD_isearch:</a>
<a name="ln1814">    case CMD_isplit:</a>
<a name="ln1815">    case CMD_keepalt:</a>
<a name="ln1816">    case CMD_keepjumps:</a>
<a name="ln1817">    case CMD_keepmarks:</a>
<a name="ln1818">    case CMD_keeppatterns:</a>
<a name="ln1819">    case CMD_leftabove:</a>
<a name="ln1820">    case CMD_let:</a>
<a name="ln1821">    case CMD_lockmarks:</a>
<a name="ln1822">    case CMD_lockvar:</a>
<a name="ln1823">    case CMD_lua:</a>
<a name="ln1824">    case CMD_match:</a>
<a name="ln1825">    case CMD_mzscheme:</a>
<a name="ln1826">    case CMD_noautocmd:</a>
<a name="ln1827">    case CMD_noswapfile:</a>
<a name="ln1828">    case CMD_perl:</a>
<a name="ln1829">    case CMD_psearch:</a>
<a name="ln1830">    case CMD_python:</a>
<a name="ln1831">    case CMD_py3:</a>
<a name="ln1832">    case CMD_python3:</a>
<a name="ln1833">    case CMD_pythonx:</a>
<a name="ln1834">    case CMD_pyx:</a>
<a name="ln1835">    case CMD_return:</a>
<a name="ln1836">    case CMD_rightbelow:</a>
<a name="ln1837">    case CMD_ruby:</a>
<a name="ln1838">    case CMD_silent:</a>
<a name="ln1839">    case CMD_smagic:</a>
<a name="ln1840">    case CMD_snomagic:</a>
<a name="ln1841">    case CMD_substitute:</a>
<a name="ln1842">    case CMD_syntax:</a>
<a name="ln1843">    case CMD_tab:</a>
<a name="ln1844">    case CMD_tcl:</a>
<a name="ln1845">    case CMD_throw:</a>
<a name="ln1846">    case CMD_tilde:</a>
<a name="ln1847">    case CMD_topleft:</a>
<a name="ln1848">    case CMD_trust:</a>
<a name="ln1849">    case CMD_unlet:</a>
<a name="ln1850">    case CMD_unlockvar:</a>
<a name="ln1851">    case CMD_verbose:</a>
<a name="ln1852">    case CMD_vertical:</a>
<a name="ln1853">    case CMD_wincmd:</a>
<a name="ln1854">      break;</a>
<a name="ln1855"> </a>
<a name="ln1856">    default:</a>
<a name="ln1857">      return true;</a>
<a name="ln1858">    }</a>
<a name="ln1859">  }</a>
<a name="ln1860">  return false;</a>
<a name="ln1861">}</a>
<a name="ln1862"> </a>
<a name="ln1863">/// Execute one Ex command.</a>
<a name="ln1864">///</a>
<a name="ln1865">/// If &quot;flags&quot; has DOCMD_VERBOSE, the command will be included in the error</a>
<a name="ln1866">/// message.</a>
<a name="ln1867">///</a>
<a name="ln1868">/// 1. skip comment lines and leading space</a>
<a name="ln1869">/// 2. handle command modifiers</a>
<a name="ln1870">/// 3. skip over the range to find the command</a>
<a name="ln1871">/// 4. parse the range</a>
<a name="ln1872">/// 5. parse the command</a>
<a name="ln1873">/// 6. parse arguments</a>
<a name="ln1874">/// 7. switch on command name</a>
<a name="ln1875">///</a>
<a name="ln1876">/// Note: &quot;fgetline&quot; can be NULL.</a>
<a name="ln1877">///</a>
<a name="ln1878">/// This function may be called recursively!</a>
<a name="ln1879">///</a>
<a name="ln1880">/// @param cookie  argument for fgetline()</a>
<a name="ln1881">static char *do_one_cmd(char **cmdlinep, int flags, cstack_T *cstack, LineGetter fgetline,</a>
<a name="ln1882">                        void *cookie)</a>
<a name="ln1883">{</a>
<a name="ln1884">  const char *errormsg = NULL;  // error message</a>
<a name="ln1885">  const int save_reg_executing = reg_executing;</a>
<a name="ln1886">  const bool save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln1887"> </a>
<a name="ln1888">  exarg_T ea = {</a>
<a name="ln1889">    .line1 = 1,</a>
<a name="ln1890">    .line2 = 1,</a>
<a name="ln1891">  };</a>
<a name="ln1892">  ex_nesting_level++;</a>
<a name="ln1893"> </a>
<a name="ln1894">  // When the last file has not been edited :q has to be typed twice.</a>
<a name="ln1895">  if (quitmore</a>
<a name="ln1896">      // avoid that a function call in 'statusline' does this</a>
<a name="ln1897">      &amp;&amp; !getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln1898">      // avoid that an autocommand, e.g. QuitPre, does this</a>
<a name="ln1899">      &amp;&amp; !getline_equal(fgetline, cookie, getnextac)) {</a>
<a name="ln1900">    quitmore--;</a>
<a name="ln1901">  }</a>
<a name="ln1902"> </a>
<a name="ln1903">  // Reset browse, confirm, etc..  They are restored when returning, for</a>
<a name="ln1904">  // recursive calls.</a>
<a name="ln1905">  cmdmod_T save_cmdmod = cmdmod;</a>
<a name="ln1906"> </a>
<a name="ln1907">  // &quot;#!anything&quot; is handled like a comment.</a>
<a name="ln1908">  if ((*cmdlinep)[0] == '#' &amp;&amp; (*cmdlinep)[1] == '!') {</a>
<a name="ln1909">    goto doend;</a>
<a name="ln1910">  }</a>
<a name="ln1911"> </a>
<a name="ln1912">  // 1. Skip comment lines and leading white space and colons.</a>
<a name="ln1913">  // 2. Handle command modifiers.</a>
<a name="ln1914"> </a>
<a name="ln1915">  // The &quot;ea&quot; structure holds the arguments that can be used.</a>
<a name="ln1916">  ea.cmd = *cmdlinep;</a>
<a name="ln1917">  ea.cmdlinep = cmdlinep;</a>
<a name="ln1918">  ea.getline = fgetline;</a>
<a name="ln1919">  ea.cookie = cookie;</a>
<a name="ln1920">  ea.cstack = cstack;</a>
<a name="ln1921"> </a>
<a name="ln1922">  if (parse_command_modifiers(&amp;ea, &amp;errormsg, &amp;cmdmod, false) == FAIL) {</a>
<a name="ln1923">    goto doend;</a>
<a name="ln1924">  }</a>
<a name="ln1925">  apply_cmdmod(&amp;cmdmod);</a>
<a name="ln1926"> </a>
<a name="ln1927">  char *after_modifier = ea.cmd;</a>
<a name="ln1928"> </a>
<a name="ln1929">  ea.skip = (did_emsg</a>
<a name="ln1930">             || got_int</a>
<a name="ln1931">             || did_throw</a>
<a name="ln1932">             || (cstack-&gt;cs_idx &gt;= 0</a>
<a name="ln1933">                 &amp;&amp; !(cstack-&gt;cs_flags[cstack-&gt;cs_idx] &amp; CSF_ACTIVE)));</a>
<a name="ln1934"> </a>
<a name="ln1935">  // 3. Skip over the range to find the command. Let &quot;p&quot; point to after it.</a>
<a name="ln1936">  //</a>
<a name="ln1937">  // We need the command to know what kind of range it uses.</a>
<a name="ln1938">  char *cmd = ea.cmd;</a>
<a name="ln1939">  ea.cmd = skip_range(ea.cmd, NULL);</a>
<a name="ln1940">  if (*ea.cmd == '*') {</a>
<a name="ln1941">    ea.cmd = skipwhite(ea.cmd + 1);</a>
<a name="ln1942">  }</a>
<a name="ln1943">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln1944"> </a>
<a name="ln1945">  profile_cmd(&amp;ea, cstack, fgetline, cookie);</a>
<a name="ln1946"> </a>
<a name="ln1947">  if (!exiting) {</a>
<a name="ln1948">    // May go to debug mode.  If this happens and the &quot;&gt;quit&quot; debug command is</a>
<a name="ln1949">    // used, throw an interrupt exception and skip the next command.</a>
<a name="ln1950">    dbg_check_breakpoint(&amp;ea);</a>
<a name="ln1951">  }</a>
<a name="ln1952">  if (!ea.skip &amp;&amp; got_int) {</a>
<a name="ln1953">    ea.skip = true;</a>
<a name="ln1954">    (void)do_intthrow(cstack);</a>
<a name="ln1955">  }</a>
<a name="ln1956"> </a>
<a name="ln1957">  // 4. Parse a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln1958">  //</a>
<a name="ln1959">  // where 'addr' is:</a>
<a name="ln1960">  //</a>
<a name="ln1961">  // %          (entire file)</a>
<a name="ln1962">  // $  [+-NUM]</a>
<a name="ln1963">  // 'x [+-NUM] (where x denotes a currently defined mark)</a>
<a name="ln1964">  // .  [+-NUM]</a>
<a name="ln1965">  // [+-NUM]..</a>
<a name="ln1966">  // NUM</a>
<a name="ln1967">  //</a>
<a name="ln1968">  // The ea.cmd pointer is updated to point to the first character following the</a>
<a name="ln1969">  // range spec. If an initial address is found, but no second, the upper bound</a>
<a name="ln1970">  // is equal to the lower.</a>
<a name="ln1971">  set_cmd_addr_type(&amp;ea, p);</a>
<a name="ln1972"> </a>
<a name="ln1973">  ea.cmd = cmd;</a>
<a name="ln1974">  if (parse_cmd_address(&amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln1975">    goto doend;</a>
<a name="ln1976">  }</a>
<a name="ln1977"> </a>
<a name="ln1978">  // 5. Parse the command.</a>
<a name="ln1979"> </a>
<a name="ln1980">  // Skip ':' and any white space</a>
<a name="ln1981">  ea.cmd = skip_colon_white(ea.cmd, true);</a>
<a name="ln1982"> </a>
<a name="ln1983">  // If we got a line, but no command, then go to the line.</a>
<a name="ln1984">  // If we find a '|' or '\n' we set ea.nextcmd.</a>
<a name="ln1985">  if (*ea.cmd == NUL || *ea.cmd == '&quot;'</a>
<a name="ln1986">      || (ea.nextcmd = check_nextcmd(ea.cmd)) != NULL) {</a>
<a name="ln1987">    // strange vi behaviour:</a>
<a name="ln1988">    // &quot;:3&quot;     jumps to line 3</a>
<a name="ln1989">    // &quot;:3|...&quot; prints line 3</a>
<a name="ln1990">    // &quot;:|&quot;     prints current line</a>
<a name="ln1991">    if (ea.skip) {  // skip this if inside :if</a>
<a name="ln1992">      goto doend;</a>
<a name="ln1993">    }</a>
<a name="ln1994">    if (*ea.cmd == '|' || (exmode_active &amp;&amp; ea.line1 != ea.line2)) {</a>
<a name="ln1995">      ea.cmdidx = CMD_print;</a>
<a name="ln1996">      ea.argt = EX_RANGE | EX_COUNT | EX_TRLBAR;</a>
<a name="ln1997">      if ((errormsg = invalid_range(&amp;ea)) == NULL) {</a>
<a name="ln1998">        correct_range(&amp;ea);</a>
<a name="ln1999">        ex_print(&amp;ea);</a>
<a name="ln2000">      }</a>
<a name="ln2001">    } else if (ea.addr_count != 0) {</a>
<a name="ln2002">      if (ea.line2 &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2003">        ea.line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2004">      }</a>
<a name="ln2005"> </a>
<a name="ln2006">      if (ea.line2 &lt; 0) {</a>
<a name="ln2007">        errormsg = _(e_invrange);</a>
<a name="ln2008">      } else {</a>
<a name="ln2009">        if (ea.line2 == 0) {</a>
<a name="ln2010">          curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2011">        } else {</a>
<a name="ln2012">          curwin-&gt;w_cursor.lnum = ea.line2;</a>
<a name="ln2013">        }</a>
<a name="ln2014">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln2015">      }</a>
<a name="ln2016">    }</a>
<a name="ln2017">    goto doend;</a>
<a name="ln2018">  }</a>
<a name="ln2019"> </a>
<a name="ln2020">  // If this looks like an undefined user command and there are CmdUndefined</a>
<a name="ln2021">  // autocommands defined, trigger the matching autocommands.</a>
<a name="ln2022">  if (p != NULL &amp;&amp; ea.cmdidx == CMD_SIZE &amp;&amp; !ea.skip</a>
<a name="ln2023">      &amp;&amp; ASCII_ISUPPER(*ea.cmd)</a>
<a name="ln2024">      &amp;&amp; has_event(EVENT_CMDUNDEFINED)) {</a>
<a name="ln2025">    p = ea.cmd;</a>
<a name="ln2026">    while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2027">      p++;</a>
<a name="ln2028">    }</a>
<a name="ln2029">    p = xstrnsave(ea.cmd, (size_t)(p - ea.cmd));</a>
<a name="ln2030">    int ret = apply_autocmds(EVENT_CMDUNDEFINED, p, p, true, NULL);</a>
<a name="ln2031">    xfree(p);</a>
<a name="ln2032">    // If the autocommands did something and didn't cause an error, try</a>
<a name="ln2033">    // finding the command again.</a>
<a name="ln2034">    p = (ret &amp;&amp; !aborting()) ? find_ex_command(&amp;ea, NULL) : ea.cmd;</a>
<a name="ln2035">  }</a>
<a name="ln2036"> </a>
<a name="ln2037">  if (p == NULL) {</a>
<a name="ln2038">    if (!ea.skip) {</a>
<a name="ln2039">      errormsg = _(e_ambiguous_use_of_user_defined_command);</a>
<a name="ln2040">    }</a>
<a name="ln2041">    goto doend;</a>
<a name="ln2042">  }</a>
<a name="ln2043"> </a>
<a name="ln2044">  // Check for wrong commands.</a>
<a name="ln2045">  if (ea.cmdidx == CMD_SIZE) {</a>
<a name="ln2046">    if (!ea.skip) {</a>
<a name="ln2047">      xstrlcpy(IObuff, _(e_not_an_editor_command), IOSIZE);</a>
<a name="ln2048">      // If the modifier was parsed OK the error must be in the following</a>
<a name="ln2049">      // command</a>
<a name="ln2050">      char *cmdname = after_modifier ? after_modifier : *cmdlinep;</a>
<a name="ln2051">      if (!(flags &amp; DOCMD_VERBOSE)) {</a>
<a name="ln2052">        append_command(cmdname);</a>
<a name="ln2053">      }</a>
<a name="ln2054">      errormsg = IObuff;</a>
<a name="ln2055">      did_emsg_syntax = true;</a>
<a name="ln2056">      verify_command(cmdname);</a>
<a name="ln2057">    }</a>
<a name="ln2058">    goto doend;</a>
<a name="ln2059">  }</a>
<a name="ln2060"> </a>
<a name="ln2061">  // set when Not Implemented</a>
<a name="ln2062">  const int ni = is_cmd_ni(ea.cmdidx);</a>
<a name="ln2063"> </a>
<a name="ln2064">  // Forced commands.</a>
<a name="ln2065">  ea.forceit = *p == '!'</a>
<a name="ln2066">               &amp;&amp; ea.cmdidx != CMD_substitute</a>
<a name="ln2067">               &amp;&amp; ea.cmdidx != CMD_smagic</a>
<a name="ln2068">               &amp;&amp; ea.cmdidx != CMD_snomagic;</a>
<a name="ln2069">  if (ea.forceit) {</a>
<a name="ln2070">    p++;</a>
<a name="ln2071">  }</a>
<a name="ln2072"> </a>
<a name="ln2073">  // 6. Parse arguments.  Then check for errors.</a>
<a name="ln2074">  if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2075">    ea.argt = cmdnames[(int)ea.cmdidx].cmd_argt;</a>
<a name="ln2076">  }</a>
<a name="ln2077"> </a>
<a name="ln2078">  if (!ea.skip) {</a>
<a name="ln2079">    if (sandbox != 0 &amp;&amp; !(ea.argt &amp; EX_SBOXOK)) {</a>
<a name="ln2080">      // Command not allowed in sandbox.</a>
<a name="ln2081">      errormsg = _(e_sandbox);</a>
<a name="ln2082">      goto doend;</a>
<a name="ln2083">    }</a>
<a name="ln2084">    if (!MODIFIABLE(curbuf) &amp;&amp; (ea.argt &amp; EX_MODIFY)</a>
<a name="ln2085">        // allow :put in terminals</a>
<a name="ln2086">        &amp;&amp; (!curbuf-&gt;terminal || ea.cmdidx != CMD_put)) {</a>
<a name="ln2087">      // Command not allowed in non-'modifiable' buffer</a>
<a name="ln2088">      errormsg = _(e_modifiable);</a>
<a name="ln2089">      goto doend;</a>
<a name="ln2090">    }</a>
<a name="ln2091"> </a>
<a name="ln2092">    if (!IS_USER_CMDIDX(ea.cmdidx)) {</a>
<a name="ln2093">      if (cmdwin_type != 0 &amp;&amp; !(ea.argt &amp; EX_CMDWIN)) {</a>
<a name="ln2094">        // Command not allowed in the command line window</a>
<a name="ln2095">        errormsg = _(e_cmdwin);</a>
<a name="ln2096">        goto doend;</a>
<a name="ln2097">      }</a>
<a name="ln2098">      if (text_locked() &amp;&amp; !(ea.argt &amp; EX_LOCK_OK)) {</a>
<a name="ln2099">        // Command not allowed when text is locked</a>
<a name="ln2100">        errormsg = _(get_text_locked_msg());</a>
<a name="ln2101">        goto doend;</a>
<a name="ln2102">      }</a>
<a name="ln2103">    }</a>
<a name="ln2104"> </a>
<a name="ln2105">    // Disallow editing another buffer when &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln2106">    // Do allow &quot;:checktime&quot; (it is postponed).</a>
<a name="ln2107">    // Do allow &quot;:edit&quot; (check for an argument later).</a>
<a name="ln2108">    // Do allow &quot;:file&quot; with no arguments (check for an argument later).</a>
<a name="ln2109">    if (!(ea.argt &amp; EX_CMDWIN)</a>
<a name="ln2110">        &amp;&amp; ea.cmdidx != CMD_checktime</a>
<a name="ln2111">        &amp;&amp; ea.cmdidx != CMD_edit</a>
<a name="ln2112">        &amp;&amp; ea.cmdidx != CMD_file</a>
<a name="ln2113">        &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln2114">        &amp;&amp; curbuf_locked()) {</a>
<a name="ln2115">      goto doend;</a>
<a name="ln2116">    }</a>
<a name="ln2117"> </a>
<a name="ln2118">    if (!ni &amp;&amp; !(ea.argt &amp; EX_RANGE) &amp;&amp; ea.addr_count &gt; 0) {</a>
<a name="ln2119">      // no range allowed</a>
<a name="ln2120">      errormsg = _(e_norange);</a>
<a name="ln2121">      goto doend;</a>
<a name="ln2122">    }</a>
<a name="ln2123">  }</a>
<a name="ln2124"> </a>
<a name="ln2125">  if (!ni &amp;&amp; !(ea.argt &amp; EX_BANG) &amp;&amp; ea.forceit) {  // no &lt;!&gt; allowed</a>
<a name="ln2126">    errormsg = _(e_nobang);</a>
<a name="ln2127">    goto doend;</a>
<a name="ln2128">  }</a>
<a name="ln2129"> </a>
<a name="ln2130">  // Don't complain about the range if it is not used</a>
<a name="ln2131">  // (could happen if line_count is accidentally set to 0).</a>
<a name="ln2132">  if (!ea.skip &amp;&amp; !ni &amp;&amp; (ea.argt &amp; EX_RANGE)) {</a>
<a name="ln2133">    // If the range is backwards, ask for confirmation and, if given, swap</a>
<a name="ln2134">    // ea.line1 &amp; ea.line2 so it's forwards again.</a>
<a name="ln2135">    // When global command is busy, don't ask, will fail below.</a>
<a name="ln2136">    if (!global_busy &amp;&amp; ea.line1 &gt; ea.line2) {</a>
<a name="ln2137">      if (msg_silent == 0) {</a>
<a name="ln2138">        if ((flags &amp; DOCMD_VERBOSE) || exmode_active) {</a>
<a name="ln2139">          errormsg = _(&quot;E493: Backwards range given&quot;);</a>
<a name="ln2140">          goto doend;</a>
<a name="ln2141">        }</a>
<a name="ln2142">        if (ask_yesno(_(&quot;Backwards range given, OK to swap&quot;), false) != 'y') {</a>
<a name="ln2143">          goto doend;</a>
<a name="ln2144">        }</a>
<a name="ln2145">      }</a>
<a name="ln2146">      linenr_T lnum = ea.line1;</a>
<a name="ln2147">      ea.line1 = ea.line2;</a>
<a name="ln2148">      ea.line2 = lnum;</a>
<a name="ln2149">    }</a>
<a name="ln2150">    if ((errormsg = invalid_range(&amp;ea)) != NULL) {</a>
<a name="ln2151">      goto doend;</a>
<a name="ln2152">    }</a>
<a name="ln2153">  }</a>
<a name="ln2154"> </a>
<a name="ln2155">  if ((ea.addr_type == ADDR_OTHER) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2156">    // default is 1, not cursor</a>
<a name="ln2157">    ea.line2 = 1;</a>
<a name="ln2158">  }</a>
<a name="ln2159"> </a>
<a name="ln2160">  correct_range(&amp;ea);</a>
<a name="ln2161"> </a>
<a name="ln2162">  if (((ea.argt &amp; EX_WHOLEFOLD) || ea.addr_count &gt;= 2) &amp;&amp; !global_busy</a>
<a name="ln2163">      &amp;&amp; ea.addr_type == ADDR_LINES) {</a>
<a name="ln2164">    // Put the first line at the start of a closed fold, put the last line</a>
<a name="ln2165">    // at the end of a closed fold.</a>
<a name="ln2166">    (void)hasFolding(ea.line1, &amp;ea.line1, NULL);</a>
<a name="ln2167">    (void)hasFolding(ea.line2, NULL, &amp;ea.line2);</a>
<a name="ln2168">  }</a>
<a name="ln2169"> </a>
<a name="ln2170">  // For the &quot;:make&quot; and &quot;:grep&quot; commands we insert the 'makeprg'/'grepprg'</a>
<a name="ln2171">  // option here, so things like % get expanded.</a>
<a name="ln2172">  p = replace_makeprg(&amp;ea, p, cmdlinep);</a>
<a name="ln2173">  if (p == NULL) {</a>
<a name="ln2174">    goto doend;</a>
<a name="ln2175">  }</a>
<a name="ln2176"> </a>
<a name="ln2177">  // Skip to start of argument.</a>
<a name="ln2178">  // Don't do this for the &quot;:!&quot; command, because &quot;:!! -l&quot; needs the space.</a>
<a name="ln2179">  ea.arg = ea.cmdidx == CMD_bang ? p : skipwhite(p);</a>
<a name="ln2180"> </a>
<a name="ln2181">  // &quot;:file&quot; cannot be run with an argument when &quot;curbuf-&gt;b_ro_locked&quot; is set</a>
<a name="ln2182">  if (ea.cmdidx == CMD_file &amp;&amp; *ea.arg != NUL &amp;&amp; curbuf_locked()) {</a>
<a name="ln2183">    goto doend;</a>
<a name="ln2184">  }</a>
<a name="ln2185"> </a>
<a name="ln2186">  // Check for &quot;++opt=val&quot; argument.</a>
<a name="ln2187">  // Must be first, allow &quot;:w ++enc=utf8 !cmd&quot;</a>
<a name="ln2188">  if (ea.argt &amp; EX_ARGOPT) {</a>
<a name="ln2189">    while (ea.arg[0] == '+' &amp;&amp; ea.arg[1] == '+') {</a>
<a name="ln2190">      if (getargopt(&amp;ea) == FAIL &amp;&amp; !ni) {</a>
<a name="ln2191">        errormsg = _(e_invarg);</a>
<a name="ln2192">        goto doend;</a>
<a name="ln2193">      }</a>
<a name="ln2194">    }</a>
<a name="ln2195">  }</a>
<a name="ln2196"> </a>
<a name="ln2197">  if (ea.cmdidx == CMD_write || ea.cmdidx == CMD_update) {</a>
<a name="ln2198">    if (*ea.arg == '&gt;') {                       // append</a>
<a name="ln2199">      if (*++ea.arg != '&gt;') {                   // typed wrong</a>
<a name="ln2200">        errormsg = _(&quot;E494: Use w or w&gt;&gt;&quot;);</a>
<a name="ln2201">        goto doend;</a>
<a name="ln2202">      }</a>
<a name="ln2203">      ea.arg = skipwhite(ea.arg + 1);</a>
<a name="ln2204">      ea.append = true;</a>
<a name="ln2205">    } else if (*ea.arg == '!' &amp;&amp; ea.cmdidx == CMD_write) {  // :w !filter</a>
<a name="ln2206">      ea.arg++;</a>
<a name="ln2207">      ea.usefilter = true;</a>
<a name="ln2208">    }</a>
<a name="ln2209">  } else if (ea.cmdidx == CMD_read) {</a>
<a name="ln2210">    if (ea.forceit) {</a>
<a name="ln2211">      ea.usefilter = true;                      // :r! filter if ea.forceit</a>
<a name="ln2212">      ea.forceit = false;</a>
<a name="ln2213">    } else if (*ea.arg == '!') {              // :r !filter</a>
<a name="ln2214">      ea.arg++;</a>
<a name="ln2215">      ea.usefilter = true;</a>
<a name="ln2216">    }</a>
<a name="ln2217">  } else if (ea.cmdidx == CMD_lshift || ea.cmdidx == CMD_rshift) {</a>
<a name="ln2218">    ea.amount = 1;</a>
<a name="ln2219">    while (*ea.arg == *ea.cmd) {                // count number of '&gt;' or '&lt;'</a>
<a name="ln2220">      ea.arg++;</a>
<a name="ln2221">      ea.amount++;</a>
<a name="ln2222">    }</a>
<a name="ln2223">    ea.arg = skipwhite(ea.arg);</a>
<a name="ln2224">  }</a>
<a name="ln2225"> </a>
<a name="ln2226">  // Check for &quot;+command&quot; argument, before checking for next command.</a>
<a name="ln2227">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2228">  if ((ea.argt &amp; EX_CMDARG) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2229">    ea.do_ecmd_cmd = getargcmd(&amp;ea.arg);</a>
<a name="ln2230">  }</a>
<a name="ln2231"> </a>
<a name="ln2232">  // Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln2233">  // Don't do this for &quot;:read !cmd&quot; and &quot;:write !cmd&quot;.</a>
<a name="ln2234">  if ((ea.argt &amp; EX_TRLBAR) &amp;&amp; !ea.usefilter) {</a>
<a name="ln2235">    separate_nextcmd(&amp;ea);</a>
<a name="ln2236">  } else if (ea.cmdidx == CMD_bang</a>
<a name="ln2237">             || ea.cmdidx == CMD_terminal</a>
<a name="ln2238">             || ea.cmdidx == CMD_global</a>
<a name="ln2239">             || ea.cmdidx == CMD_vglobal</a>
<a name="ln2240">             || ea.usefilter) {</a>
<a name="ln2241">    // Check for &lt;newline&gt; to end a shell command.</a>
<a name="ln2242">    // Also do this for &quot;:read !cmd&quot;, &quot;:write !cmd&quot; and &quot;:global&quot;.</a>
<a name="ln2243">    // Any others?</a>
<a name="ln2244">    for (char *s = ea.arg; *s; s++) {</a>
<a name="ln2245">      // Remove one backslash before a newline, so that it's possible to</a>
<a name="ln2246">      // pass a newline to the shell and also a newline that is preceded</a>
<a name="ln2247">      // with a backslash.  This makes it impossible to end a shell</a>
<a name="ln2248">      // command in a backslash, but that doesn't appear useful.</a>
<a name="ln2249">      // Halving the number of backslashes is incompatible with previous</a>
<a name="ln2250">      // versions.</a>
<a name="ln2251">      if (*s == '\\' &amp;&amp; s[1] == '\n') {</a>
<a name="ln2252">        STRMOVE(s, s + 1);</a>
<a name="ln2253">      } else if (*s == '\n') {</a>
<a name="ln2254">        ea.nextcmd = s + 1;</a>
<a name="ln2255">        *s = NUL;</a>
<a name="ln2256">        break;</a>
<a name="ln2257">      }</a>
<a name="ln2258">    }</a>
<a name="ln2259">  }</a>
<a name="ln2260"> </a>
<a name="ln2261">  if ((ea.argt &amp; EX_DFLALL) &amp;&amp; ea.addr_count == 0) {</a>
<a name="ln2262">    set_cmd_dflall_range(&amp;ea);</a>
<a name="ln2263">  }</a>
<a name="ln2264"> </a>
<a name="ln2265">  // Parse register and count</a>
<a name="ln2266">  parse_register(&amp;ea);</a>
<a name="ln2267">  if (parse_count(&amp;ea, &amp;errormsg, true) == FAIL) {</a>
<a name="ln2268">    goto doend;</a>
<a name="ln2269">  }</a>
<a name="ln2270"> </a>
<a name="ln2271">  // Check for flags: 'l', 'p' and '#'.</a>
<a name="ln2272">  if (ea.argt &amp; EX_FLAGS) {</a>
<a name="ln2273">    get_flags(&amp;ea);</a>
<a name="ln2274">  }</a>
<a name="ln2275">  if (!ni &amp;&amp; !(ea.argt &amp; EX_EXTRA) &amp;&amp; *ea.arg != NUL</a>
<a name="ln2276">      &amp;&amp; *ea.arg != '&quot;' &amp;&amp; (*ea.arg != '|' || (ea.argt &amp; EX_TRLBAR) == 0)) {</a>
<a name="ln2277">    // no arguments allowed but there is something</a>
<a name="ln2278">    errormsg = ex_errmsg(e_trailing_arg, ea.arg);</a>
<a name="ln2279">    goto doend;</a>
<a name="ln2280">  }</a>
<a name="ln2281"> </a>
<a name="ln2282">  if (!ni &amp;&amp; (ea.argt &amp; EX_NEEDARG) &amp;&amp; *ea.arg == NUL) {</a>
<a name="ln2283">    errormsg = _(e_argreq);</a>
<a name="ln2284">    goto doend;</a>
<a name="ln2285">  }</a>
<a name="ln2286"> </a>
<a name="ln2287">  if (skip_cmd(&amp;ea)) {</a>
<a name="ln2288">    goto doend;</a>
<a name="ln2289">  }</a>
<a name="ln2290"> </a>
<a name="ln2291">  // 7. Execute the command.</a>
<a name="ln2292">  int retv = 0;</a>
<a name="ln2293">  if (execute_cmd0(&amp;retv, &amp;ea, &amp;errormsg, false) == FAIL) {</a>
<a name="ln2294">    goto doend;</a>
<a name="ln2295">  }</a>
<a name="ln2296"> </a>
<a name="ln2297">  // If the command just executed called do_cmdline(), any throw or &quot;:return&quot;</a>
<a name="ln2298">  // or &quot;:finish&quot; encountered there must also check the cstack of the still</a>
<a name="ln2299">  // active do_cmdline() that called this do_one_cmd().  Rethrow an uncaught</a>
<a name="ln2300">  // exception, or reanimate a returned function or finished script file and</a>
<a name="ln2301">  // return or finish it again.</a>
<a name="ln2302">  if (need_rethrow) {</a>
<a name="ln2303">    do_throw(cstack);</a>
<a name="ln2304">  } else if (check_cstack) {</a>
<a name="ln2305">    if (source_finished(fgetline, cookie)) {</a>
<a name="ln2306">      do_finish(&amp;ea, true);</a>
<a name="ln2307">    } else if (getline_equal(fgetline, cookie, get_func_line)</a>
<a name="ln2308">               &amp;&amp; current_func_returned()) {</a>
<a name="ln2309">      do_return(&amp;ea, true, false, NULL);</a>
<a name="ln2310">    }</a>
<a name="ln2311">  }</a>
<a name="ln2312">  need_rethrow = check_cstack = false;</a>
<a name="ln2313"> </a>
<a name="ln2314">doend:</a>
<a name="ln2315">  // can happen with zero line number</a>
<a name="ln2316">  if (curwin-&gt;w_cursor.lnum == 0) {</a>
<a name="ln2317">    curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln2318">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2319">  }</a>
<a name="ln2320"> </a>
<a name="ln2321">  if (errormsg != NULL &amp;&amp; *errormsg != NUL &amp;&amp; !did_emsg) {</a>
<a name="ln2322">    if (flags &amp; DOCMD_VERBOSE) {</a>
<a name="ln2323">      if (errormsg != IObuff) {</a>
<a name="ln2324">        xstrlcpy(IObuff, errormsg, IOSIZE);</a>
<a name="ln2325">        errormsg = IObuff;</a>
<a name="ln2326">      }</a>
<a name="ln2327">      append_command(*ea.cmdlinep);</a>
<a name="ln2328">    }</a>
<a name="ln2329">    emsg(errormsg);</a>
<a name="ln2330">  }</a>
<a name="ln2331">  do_errthrow(cstack,</a>
<a name="ln2332">              (ea.cmdidx != CMD_SIZE</a>
<a name="ln2333">               &amp;&amp; !IS_USER_CMDIDX(ea.cmdidx)) ? cmdnames[(int)ea.cmdidx].cmd_name : NULL);</a>
<a name="ln2334"> </a>
<a name="ln2335">  undo_cmdmod(&amp;cmdmod);</a>
<a name="ln2336">  cmdmod = save_cmdmod;</a>
<a name="ln2337">  reg_executing = save_reg_executing;</a>
<a name="ln2338">  pending_end_reg_executing = save_pending_end_reg_executing;</a>
<a name="ln2339"> </a>
<a name="ln2340">  if (ea.nextcmd &amp;&amp; *ea.nextcmd == NUL) {       // not really a next command</a>
<a name="ln2341">    ea.nextcmd = NULL;</a>
<a name="ln2342">  }</a>
<a name="ln2343"> </a>
<a name="ln2344">  ex_nesting_level--;</a>
<a name="ln2345">  xfree(ea.cmdline_tofree);</a>
<a name="ln2346"> </a>
<a name="ln2347">  return ea.nextcmd;</a>
<a name="ln2348">}</a>
<a name="ln2349"> </a>
<a name="ln2350">static char ex_error_buf[MSG_BUF_LEN];</a>
<a name="ln2351"> </a>
<a name="ln2352">/// @return an error message with argument included.</a>
<a name="ln2353">/// Uses a static buffer, only the last error will be kept.</a>
<a name="ln2354">/// &quot;msg&quot; will be translated, caller should use N_().</a>
<a name="ln2355">char *ex_errmsg(const char *const msg, const char *const arg)</a>
<a name="ln2356">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2357">{</a>
<a name="ln2358">  vim_snprintf(ex_error_buf, MSG_BUF_LEN, _(msg), arg);</a>
<a name="ln2359">  return ex_error_buf;</a>
<a name="ln2360">}</a>
<a name="ln2361"> </a>
<a name="ln2362">/// Parse and skip over command modifiers:</a>
<a name="ln2363">/// - update eap-&gt;cmd</a>
<a name="ln2364">/// - store flags in &quot;cmod&quot;.</a>
<a name="ln2365">/// - Set ex_pressedreturn for an empty command line.</a>
<a name="ln2366">///</a>
<a name="ln2367">/// @param skip_only      if false, undo_cmdmod() must be called later to free</a>
<a name="ln2368">///                       any cmod_filter_pat and cmod_filter_regmatch.regprog,</a>
<a name="ln2369">///                       and ex_pressedreturn may be set.</a>
<a name="ln2370">/// @param[out] errormsg  potential error message.</a>
<a name="ln2371">///</a>
<a name="ln2372">/// Call apply_cmdmod() to get the side effects of the modifiers:</a>
<a name="ln2373">/// - Increment &quot;sandbox&quot; for &quot;:sandbox&quot;</a>
<a name="ln2374">/// - set p_verbose for &quot;:verbose&quot;</a>
<a name="ln2375">/// - set msg_silent for &quot;:silent&quot;</a>
<a name="ln2376">/// - set 'eventignore' to &quot;all&quot; for &quot;:noautocmd&quot;</a>
<a name="ln2377">///</a>
<a name="ln2378">/// @return  FAIL when the command is not to be executed.</a>
<a name="ln2379">int parse_command_modifiers(exarg_T *eap, const char **errormsg, cmdmod_T *cmod, bool skip_only)</a>
<a name="ln2380">{</a>
<a name="ln2381">  CLEAR_POINTER(cmod);</a>
<a name="ln2382"> </a>
<a name="ln2383">  // Repeat until no more command modifiers are found.</a>
<a name="ln2384">  while (true) {</a>
<a name="ln2385">    while (*eap-&gt;cmd == ' '</a>
<a name="ln2386">           || *eap-&gt;cmd == '\t'</a>
<a name="ln2387">           || *eap-&gt;cmd == ':') {</a>
<a name="ln2388">      eap-&gt;cmd++;</a>
<a name="ln2389">    }</a>
<a name="ln2390"> </a>
<a name="ln2391">    // in ex mode, an empty line works like :+</a>
<a name="ln2392">    if (*eap-&gt;cmd == NUL &amp;&amp; exmode_active</a>
<a name="ln2393">        &amp;&amp; getline_equal(eap-&gt;getline, eap-&gt;cookie, getexline)</a>
<a name="ln2394">        &amp;&amp; curwin-&gt;w_cursor.lnum &lt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln2395">      eap-&gt;cmd = &quot;+&quot;;</a>
<a name="ln2396">      if (!skip_only) {</a>
<a name="ln2397">        ex_pressedreturn = true;</a>
<a name="ln2398">      }</a>
<a name="ln2399">    }</a>
<a name="ln2400"> </a>
<a name="ln2401">    // ignore comment and empty lines</a>
<a name="ln2402">    if (*eap-&gt;cmd == '&quot;') {</a>
<a name="ln2403">      return FAIL;</a>
<a name="ln2404">    }</a>
<a name="ln2405">    if (*eap-&gt;cmd == NUL) {</a>
<a name="ln2406">      if (!skip_only) {</a>
<a name="ln2407">        ex_pressedreturn = true;</a>
<a name="ln2408">      }</a>
<a name="ln2409">      return FAIL;</a>
<a name="ln2410">    }</a>
<a name="ln2411"> </a>
<a name="ln2412">    char *p = skip_range(eap-&gt;cmd, NULL);</a>
<a name="ln2413">    switch (*p) {</a>
<a name="ln2414">    // When adding an entry, also modify cmdmods[]</a>
<a name="ln2415">    case 'a':</a>
<a name="ln2416">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;aboveleft&quot;, 3)) {</a>
<a name="ln2417">        break;</a>
<a name="ln2418">      }</a>
<a name="ln2419">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2420">      continue;</a>
<a name="ln2421"> </a>
<a name="ln2422">    case 'b':</a>
<a name="ln2423">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;belowright&quot;, 3)) {</a>
<a name="ln2424">        cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2425">        continue;</a>
<a name="ln2426">      }</a>
<a name="ln2427">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;browse&quot;, 3)) {</a>
<a name="ln2428">        cmod-&gt;cmod_flags |= CMOD_BROWSE;</a>
<a name="ln2429">        continue;</a>
<a name="ln2430">      }</a>
<a name="ln2431">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;botright&quot;, 2)) {</a>
<a name="ln2432">        break;</a>
<a name="ln2433">      }</a>
<a name="ln2434">      cmod-&gt;cmod_split |= WSP_BOT;</a>
<a name="ln2435">      continue;</a>
<a name="ln2436"> </a>
<a name="ln2437">    case 'c':</a>
<a name="ln2438">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;confirm&quot;, 4)) {</a>
<a name="ln2439">        break;</a>
<a name="ln2440">      }</a>
<a name="ln2441">      cmod-&gt;cmod_flags |= CMOD_CONFIRM;</a>
<a name="ln2442">      continue;</a>
<a name="ln2443"> </a>
<a name="ln2444">    case 'k':</a>
<a name="ln2445">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepmarks&quot;, 3)) {</a>
<a name="ln2446">        cmod-&gt;cmod_flags |= CMOD_KEEPMARKS;</a>
<a name="ln2447">        continue;</a>
<a name="ln2448">      }</a>
<a name="ln2449">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keepalt&quot;, 5)) {</a>
<a name="ln2450">        cmod-&gt;cmod_flags |= CMOD_KEEPALT;</a>
<a name="ln2451">        continue;</a>
<a name="ln2452">      }</a>
<a name="ln2453">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;keeppatterns&quot;, 5)) {</a>
<a name="ln2454">        cmod-&gt;cmod_flags |= CMOD_KEEPPATTERNS;</a>
<a name="ln2455">        continue;</a>
<a name="ln2456">      }</a>
<a name="ln2457">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;keepjumps&quot;, 5)) {</a>
<a name="ln2458">        break;</a>
<a name="ln2459">      }</a>
<a name="ln2460">      cmod-&gt;cmod_flags |= CMOD_KEEPJUMPS;</a>
<a name="ln2461">      continue;</a>
<a name="ln2462"> </a>
<a name="ln2463">    case 'f': {  // only accept &quot;:filter {pat} cmd&quot;</a>
<a name="ln2464">      char *reg_pat;</a>
<a name="ln2465"> </a>
<a name="ln2466">      if (!checkforcmd(&amp;p, &quot;filter&quot;, 4) || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2467">        break;</a>
<a name="ln2468">      }</a>
<a name="ln2469">      if (*p == '!') {</a>
<a name="ln2470">        cmod-&gt;cmod_filter_force = true;</a>
<a name="ln2471">        p = skipwhite(p + 1);</a>
<a name="ln2472">        if (*p == NUL || ends_excmd(*p)) {</a>
<a name="ln2473">          break;</a>
<a name="ln2474">        }</a>
<a name="ln2475">      }</a>
<a name="ln2476">      if (skip_only) {</a>
<a name="ln2477">        p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln2478">      } else {</a>
<a name="ln2479">        // NOTE: This puts a NUL after the pattern.</a>
<a name="ln2480">        p = skip_vimgrep_pat(p, &amp;reg_pat, NULL);</a>
<a name="ln2481">      }</a>
<a name="ln2482">      if (p == NULL || *p == NUL) {</a>
<a name="ln2483">        break;</a>
<a name="ln2484">      }</a>
<a name="ln2485">      if (!skip_only) {</a>
<a name="ln2486">        cmod-&gt;cmod_filter_pat = xstrdup(reg_pat);</a>
<a name="ln2487">        cmod-&gt;cmod_filter_regmatch.regprog = vim_regcomp(reg_pat, RE_MAGIC);</a>
<a name="ln2488">        if (cmod-&gt;cmod_filter_regmatch.regprog == NULL) {</a>
<a name="ln2489">          break;</a>
<a name="ln2490">        }</a>
<a name="ln2491">      }</a>
<a name="ln2492">      eap-&gt;cmd = p;</a>
<a name="ln2493">      continue;</a>
<a name="ln2494">    }</a>
<a name="ln2495"> </a>
<a name="ln2496">    case 'h':</a>
<a name="ln2497">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;horizontal&quot;, 3)) {</a>
<a name="ln2498">        cmod-&gt;cmod_split |= WSP_HOR;</a>
<a name="ln2499">        continue;</a>
<a name="ln2500">      }</a>
<a name="ln2501">      // &quot;:hide&quot; and &quot;:hide | cmd&quot; are not modifiers</a>
<a name="ln2502">      if (p != eap-&gt;cmd || !checkforcmd(&amp;p, &quot;hide&quot;, 3)</a>
<a name="ln2503">          || *p == NUL || ends_excmd(*p)) {</a>
<a name="ln2504">        break;</a>
<a name="ln2505">      }</a>
<a name="ln2506">      eap-&gt;cmd = p;</a>
<a name="ln2507">      cmod-&gt;cmod_flags |= CMOD_HIDE;</a>
<a name="ln2508">      continue;</a>
<a name="ln2509"> </a>
<a name="ln2510">    case 'l':</a>
<a name="ln2511">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;lockmarks&quot;, 3)) {</a>
<a name="ln2512">        cmod-&gt;cmod_flags |= CMOD_LOCKMARKS;</a>
<a name="ln2513">        continue;</a>
<a name="ln2514">      }</a>
<a name="ln2515"> </a>
<a name="ln2516">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;leftabove&quot;, 5)) {</a>
<a name="ln2517">        break;</a>
<a name="ln2518">      }</a>
<a name="ln2519">      cmod-&gt;cmod_split |= WSP_ABOVE;</a>
<a name="ln2520">      continue;</a>
<a name="ln2521"> </a>
<a name="ln2522">    case 'n':</a>
<a name="ln2523">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;noautocmd&quot;, 3)) {</a>
<a name="ln2524">        cmod-&gt;cmod_flags |= CMOD_NOAUTOCMD;</a>
<a name="ln2525">        continue;</a>
<a name="ln2526">      }</a>
<a name="ln2527">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;noswapfile&quot;, 3)) {</a>
<a name="ln2528">        break;</a>
<a name="ln2529">      }</a>
<a name="ln2530">      cmod-&gt;cmod_flags |= CMOD_NOSWAPFILE;</a>
<a name="ln2531">      continue;</a>
<a name="ln2532"> </a>
<a name="ln2533">    case 'r':</a>
<a name="ln2534">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;rightbelow&quot;, 6)) {</a>
<a name="ln2535">        break;</a>
<a name="ln2536">      }</a>
<a name="ln2537">      cmod-&gt;cmod_split |= WSP_BELOW;</a>
<a name="ln2538">      continue;</a>
<a name="ln2539"> </a>
<a name="ln2540">    case 's':</a>
<a name="ln2541">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;sandbox&quot;, 3)) {</a>
<a name="ln2542">        cmod-&gt;cmod_flags |= CMOD_SANDBOX;</a>
<a name="ln2543">        continue;</a>
<a name="ln2544">      }</a>
<a name="ln2545">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;silent&quot;, 3)) {</a>
<a name="ln2546">        break;</a>
<a name="ln2547">      }</a>
<a name="ln2548">      cmod-&gt;cmod_flags |= CMOD_SILENT;</a>
<a name="ln2549">      if (*eap-&gt;cmd == '!' &amp;&amp; !ascii_iswhite(eap-&gt;cmd[-1])) {</a>
<a name="ln2550">        // &quot;:silent!&quot;, but not &quot;silent !cmd&quot;</a>
<a name="ln2551">        eap-&gt;cmd = skipwhite(eap-&gt;cmd + 1);</a>
<a name="ln2552">        cmod-&gt;cmod_flags |= CMOD_ERRSILENT;</a>
<a name="ln2553">      }</a>
<a name="ln2554">      continue;</a>
<a name="ln2555"> </a>
<a name="ln2556">    case 't':</a>
<a name="ln2557">      if (checkforcmd(&amp;p, &quot;tab&quot;, 3)) {</a>
<a name="ln2558">        if (!skip_only) {</a>
<a name="ln2559">          int tabnr = (int)get_address(eap, &amp;eap-&gt;cmd, ADDR_TABS, eap-&gt;skip, skip_only,</a>
<a name="ln2560">                                       false, 1, errormsg);</a>
<a name="ln2561">          if (eap-&gt;cmd == NULL) {</a>
<a name="ln2562">            return false;</a>
<a name="ln2563">          }</a>
<a name="ln2564"> </a>
<a name="ln2565">          if (tabnr == MAXLNUM) {</a>
<a name="ln2566">            cmod-&gt;cmod_tab = tabpage_index(curtab) + 1;</a>
<a name="ln2567">          } else {</a>
<a name="ln2568">            if (tabnr &lt; 0 || tabnr &gt; LAST_TAB_NR) {</a>
<a name="ln2569">              *errormsg = _(e_invrange);</a>
<a name="ln2570">              return false;</a>
<a name="ln2571">            }</a>
<a name="ln2572">            cmod-&gt;cmod_tab = tabnr + 1;</a>
<a name="ln2573">          }</a>
<a name="ln2574">        }</a>
<a name="ln2575">        eap-&gt;cmd = p;</a>
<a name="ln2576">        continue;</a>
<a name="ln2577">      }</a>
<a name="ln2578">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;topleft&quot;, 2)) {</a>
<a name="ln2579">        break;</a>
<a name="ln2580">      }</a>
<a name="ln2581">      cmod-&gt;cmod_split |= WSP_TOP;</a>
<a name="ln2582">      continue;</a>
<a name="ln2583"> </a>
<a name="ln2584">    case 'u':</a>
<a name="ln2585">      if (!checkforcmd(&amp;eap-&gt;cmd, &quot;unsilent&quot;, 3)) {</a>
<a name="ln2586">        break;</a>
<a name="ln2587">      }</a>
<a name="ln2588">      cmod-&gt;cmod_flags |= CMOD_UNSILENT;</a>
<a name="ln2589">      continue;</a>
<a name="ln2590"> </a>
<a name="ln2591">    case 'v':</a>
<a name="ln2592">      if (checkforcmd(&amp;eap-&gt;cmd, &quot;vertical&quot;, 4)) {</a>
<a name="ln2593">        cmod-&gt;cmod_split |= WSP_VERT;</a>
<a name="ln2594">        continue;</a>
<a name="ln2595">      }</a>
<a name="ln2596">      if (!checkforcmd(&amp;p, &quot;verbose&quot;, 4)) {</a>
<a name="ln2597">        break;</a>
<a name="ln2598">      }</a>
<a name="ln2599">      if (ascii_isdigit(*eap-&gt;cmd)) {</a>
<a name="ln2600">        // zero means not set, one is verbose == 0, etc.</a>
<a name="ln2601">        cmod-&gt;cmod_verbose = atoi(eap-&gt;cmd) + 1;</a>
<a name="ln2602">      } else {</a>
<a name="ln2603">        cmod-&gt;cmod_verbose = 2;  // default: verbose == 1</a>
<a name="ln2604">      }</a>
<a name="ln2605">      eap-&gt;cmd = p;</a>
<a name="ln2606">      continue;</a>
<a name="ln2607">    }</a>
<a name="ln2608">    break;</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  return OK;</a>
<a name="ln2612">}</a>
<a name="ln2613"> </a>
<a name="ln2614">/// Apply the command modifiers.  Saves current state in &quot;cmdmod&quot;, call</a>
<a name="ln2615">/// undo_cmdmod() later.</a>
<a name="ln2616">static void apply_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2617">{</a>
<a name="ln2618">  if ((cmod-&gt;cmod_flags &amp; CMOD_SANDBOX) &amp;&amp; !cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2619">    sandbox++;</a>
<a name="ln2620">    cmod-&gt;cmod_did_sandbox = true;</a>
<a name="ln2621">  }</a>
<a name="ln2622">  if (cmod-&gt;cmod_verbose &gt; 0) {</a>
<a name="ln2623">    if (cmod-&gt;cmod_verbose_save == 0) {</a>
<a name="ln2624">      cmod-&gt;cmod_verbose_save = p_verbose + 1;</a>
<a name="ln2625">    }</a>
<a name="ln2626">    p_verbose = cmod-&gt;cmod_verbose - 1;</a>
<a name="ln2627">  }</a>
<a name="ln2628"> </a>
<a name="ln2629">  if ((cmod-&gt;cmod_flags &amp; (CMOD_SILENT | CMOD_UNSILENT))</a>
<a name="ln2630">      &amp;&amp; cmod-&gt;cmod_save_msg_silent == 0) {</a>
<a name="ln2631">    cmod-&gt;cmod_save_msg_silent = msg_silent + 1;</a>
<a name="ln2632">    cmod-&gt;cmod_save_msg_scroll = msg_scroll;</a>
<a name="ln2633">  }</a>
<a name="ln2634">  if (cmod-&gt;cmod_flags &amp; CMOD_SILENT) {</a>
<a name="ln2635">    msg_silent++;</a>
<a name="ln2636">  }</a>
<a name="ln2637">  if (cmod-&gt;cmod_flags &amp; CMOD_UNSILENT) {</a>
<a name="ln2638">    msg_silent = 0;</a>
<a name="ln2639">  }</a>
<a name="ln2640"> </a>
<a name="ln2641">  if (cmod-&gt;cmod_flags &amp; CMOD_ERRSILENT) {</a>
<a name="ln2642">    emsg_silent++;</a>
<a name="ln2643">    cmod-&gt;cmod_did_esilent++;</a>
<a name="ln2644">  }</a>
<a name="ln2645"> </a>
<a name="ln2646">  if ((cmod-&gt;cmod_flags &amp; CMOD_NOAUTOCMD) &amp;&amp; cmod-&gt;cmod_save_ei == NULL) {</a>
<a name="ln2647">    // Set 'eventignore' to &quot;all&quot;.</a>
<a name="ln2648">    // First save the existing option value for restoring it later.</a>
<a name="ln2649">    cmod-&gt;cmod_save_ei = xstrdup(p_ei);</a>
<a name="ln2650">    set_string_option_direct(&quot;ei&quot;, -1, &quot;all&quot;, OPT_FREE, SID_NONE);</a>
<a name="ln2651">  }</a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">/// Undo and free contents of &quot;cmod&quot;.</a>
<a name="ln2655">void undo_cmdmod(cmdmod_T *cmod)</a>
<a name="ln2656">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2657">{</a>
<a name="ln2658">  if (cmod-&gt;cmod_verbose_save &gt; 0) {</a>
<a name="ln2659">    p_verbose = cmod-&gt;cmod_verbose_save - 1;</a>
<a name="ln2660">    cmod-&gt;cmod_verbose_save = 0;</a>
<a name="ln2661">  }</a>
<a name="ln2662"> </a>
<a name="ln2663">  if (cmod-&gt;cmod_did_sandbox) {</a>
<a name="ln2664">    sandbox--;</a>
<a name="ln2665">    cmod-&gt;cmod_did_sandbox = false;</a>
<a name="ln2666">  }</a>
<a name="ln2667"> </a>
<a name="ln2668">  if (cmod-&gt;cmod_save_ei != NULL) {</a>
<a name="ln2669">    // Restore 'eventignore' to the value before &quot;:noautocmd&quot;.</a>
<a name="ln2670">    set_string_option_direct(&quot;ei&quot;, -1, cmod-&gt;cmod_save_ei, OPT_FREE, SID_NONE);</a>
<a name="ln2671">    free_string_option(cmod-&gt;cmod_save_ei);</a>
<a name="ln2672">    cmod-&gt;cmod_save_ei = NULL;</a>
<a name="ln2673">  }</a>
<a name="ln2674"> </a>
<a name="ln2675">  xfree(cmod-&gt;cmod_filter_pat);</a>
<a name="ln2676">  vim_regfree(cmod-&gt;cmod_filter_regmatch.regprog);</a>
<a name="ln2677"> </a>
<a name="ln2678">  if (cmod-&gt;cmod_save_msg_silent &gt; 0) {</a>
<a name="ln2679">    // messages could be enabled for a serious error, need to check if the</a>
<a name="ln2680">    // counters don't become negative</a>
<a name="ln2681">    if (!did_emsg || msg_silent &gt; cmod-&gt;cmod_save_msg_silent - 1) {</a>
<a name="ln2682">      msg_silent = cmod-&gt;cmod_save_msg_silent - 1;</a>
<a name="ln2683">    }</a>
<a name="ln2684">    emsg_silent -= cmod-&gt;cmod_did_esilent;</a>
<a name="ln2685">    if (emsg_silent &lt; 0) {</a>
<a name="ln2686">      emsg_silent = 0;</a>
<a name="ln2687">    }</a>
<a name="ln2688">    // Restore msg_scroll, it's set by file I/O commands, even when no</a>
<a name="ln2689">    // message is actually displayed.</a>
<a name="ln2690">    msg_scroll = cmod-&gt;cmod_save_msg_scroll;</a>
<a name="ln2691"> </a>
<a name="ln2692">    // &quot;silent reg&quot; or &quot;silent echo x&quot; inside &quot;redir&quot; leaves msg_col</a>
<a name="ln2693">    // somewhere in the line.  Put it back in the first column.</a>
<a name="ln2694">    if (redirecting()) {</a>
<a name="ln2695">      msg_col = 0;</a>
<a name="ln2696">    }</a>
<a name="ln2697"> </a>
<a name="ln2698">    cmod-&gt;cmod_save_msg_silent = 0;</a>
<a name="ln2699">    cmod-&gt;cmod_did_esilent = 0;</a>
<a name="ln2700">  }</a>
<a name="ln2701">}</a>
<a name="ln2702"> </a>
<a name="ln2703">/// Parse the address range, if any, in &quot;eap&quot;.</a>
<a name="ln2704">/// May set the last search pattern, unless &quot;silent&quot; is true.</a>
<a name="ln2705">///</a>
<a name="ln2706">/// @return  FAIL and set &quot;errormsg&quot; or return OK.</a>
<a name="ln2707">int parse_cmd_address(exarg_T *eap, const char **errormsg, bool silent)</a>
<a name="ln2708">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2709">{</a>
<a name="ln2710">  int address_count = 1;</a>
<a name="ln2711">  linenr_T lnum;</a>
<a name="ln2712">  bool need_check_cursor = false;</a>
<a name="ln2713">  int ret = FAIL;</a>
<a name="ln2714"> </a>
<a name="ln2715">  // Repeat for all ',' or ';' separated addresses.</a>
<a name="ln2716">  while (true) {</a>
<a name="ln2717">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2718">    eap-&gt;line2 = get_cmd_default_range(eap);</a>
<a name="ln2719">    eap-&gt;cmd = skipwhite(eap-&gt;cmd);</a>
<a name="ln2720">    lnum = get_address(eap, &amp;eap-&gt;cmd, eap-&gt;addr_type, eap-&gt;skip, silent,</a>
<a name="ln2721">                       eap-&gt;addr_count == 0, address_count++, errormsg);</a>
<a name="ln2722">    if (eap-&gt;cmd == NULL) {  // error detected</a>
<a name="ln2723">      goto theend;</a>
<a name="ln2724">    }</a>
<a name="ln2725">    if (lnum == MAXLNUM) {</a>
<a name="ln2726">      if (*eap-&gt;cmd == '%') {  // '%' - all lines</a>
<a name="ln2727">        eap-&gt;cmd++;</a>
<a name="ln2728">        switch (eap-&gt;addr_type) {</a>
<a name="ln2729">        case ADDR_LINES:</a>
<a name="ln2730">        case ADDR_OTHER:</a>
<a name="ln2731">          eap-&gt;line1 = 1;</a>
<a name="ln2732">          eap-&gt;line2 = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln2733">          break;</a>
<a name="ln2734">        case ADDR_LOADED_BUFFERS: {</a>
<a name="ln2735">          buf_T *buf = firstbuf;</a>
<a name="ln2736"> </a>
<a name="ln2737">          while (buf-&gt;b_next != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2738">            buf = buf-&gt;b_next;</a>
<a name="ln2739">          }</a>
<a name="ln2740">          eap-&gt;line1 = buf-&gt;b_fnum;</a>
<a name="ln2741">          buf = lastbuf;</a>
<a name="ln2742">          while (buf-&gt;b_prev != NULL &amp;&amp; buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln2743">            buf = buf-&gt;b_prev;</a>
<a name="ln2744">          }</a>
<a name="ln2745">          eap-&gt;line2 = buf-&gt;b_fnum;</a>
<a name="ln2746">          break;</a>
<a name="ln2747">        }</a>
<a name="ln2748">        case ADDR_BUFFERS:</a>
<a name="ln2749">          eap-&gt;line1 = firstbuf-&gt;b_fnum;</a>
<a name="ln2750">          eap-&gt;line2 = lastbuf-&gt;b_fnum;</a>
<a name="ln2751">          break;</a>
<a name="ln2752">        case ADDR_WINDOWS:</a>
<a name="ln2753">        case ADDR_TABS:</a>
<a name="ln2754">          if (IS_USER_CMDIDX(eap-&gt;cmdidx)) {</a>
<a name="ln2755">            eap-&gt;line1 = 1;</a>
<a name="ln2756">            eap-&gt;line2 = eap-&gt;addr_type == ADDR_WINDOWS</a>
<a name="ln2757">                ? LAST_WIN_NR : LAST_TAB_NR;</a>
<a name="ln2758">          } else {</a>
<a name="ln2759">            // there is no Vim command which uses '%' and</a>
<a name="ln2760">            // ADDR_WINDOWS or ADDR_TABS</a>
<a name="ln2761">            *errormsg = _(e_invrange);</a>
<a name="ln2762">            goto theend;</a>
<a name="ln2763">          }</a>
<a name="ln2764">          break;</a>
<a name="ln2765">        case ADDR_TABS_RELATIVE:</a>
<a name="ln2766">        case ADDR_UNSIGNED:</a>
<a name="ln2767">        case ADDR_QUICKFIX:</a>
<a name="ln2768">          *errormsg = _(e_invrange);</a>
<a name="ln2769">          goto theend;</a>
<a name="ln2770">        case ADDR_ARGUMENTS:</a>
<a name="ln2771">          if (ARGCOUNT == 0) {</a>
<a name="ln2772">            eap-&gt;line1 = eap-&gt;line2 = 0;</a>
<a name="ln2773">          } else {</a>
<a name="ln2774">            eap-&gt;line1 = 1;</a>
<a name="ln2775">            eap-&gt;line2 = ARGCOUNT;</a>
<a name="ln2776">          }</a>
<a name="ln2777">          break;</a>
<a name="ln2778">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln2779">          eap-&gt;line1 = 1;</a>
<a name="ln2780">          eap-&gt;line2 = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln2781">          if (eap-&gt;line2 == 0) {</a>
<a name="ln2782">            eap-&gt;line2 = 1;</a>
<a name="ln2783">          }</a>
<a name="ln2784">          break;</a>
<a name="ln2785">        case ADDR_NONE:</a>
<a name="ln2786">          // Will give an error later if a range is found.</a>
<a name="ln2787">          break;</a>
<a name="ln2788">        }</a>
<a name="ln2789">        eap-&gt;addr_count++;</a>
<a name="ln2790">      } else if (*eap-&gt;cmd == '*') {</a>
<a name="ln2791">        // '*' - visual area</a>
<a name="ln2792">        if (eap-&gt;addr_type != ADDR_LINES) {</a>
<a name="ln2793">          *errormsg = _(e_invrange);</a>
<a name="ln2794">          goto theend;</a>
<a name="ln2795">        }</a>
<a name="ln2796"> </a>
<a name="ln2797">        eap-&gt;cmd++;</a>
<a name="ln2798">        if (!eap-&gt;skip) {</a>
<a name="ln2799">          fmark_T *fm = mark_get_visual(curbuf, '&lt;');</a>
<a name="ln2800">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2801">            goto theend;</a>
<a name="ln2802">          }</a>
<a name="ln2803">          assert(fm != NULL);</a>
<a name="ln2804">          eap-&gt;line1 = fm-&gt;mark.lnum;</a>
<a name="ln2805">          fm = mark_get_visual(curbuf, '&gt;');</a>
<a name="ln2806">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln2807">            goto theend;</a>
<a name="ln2808">          }</a>
<a name="ln2809">          assert(fm != NULL);</a>
<a name="ln2810">          eap-&gt;line2 = fm-&gt;mark.lnum;</a>
<a name="ln2811">          eap-&gt;addr_count++;</a>
<a name="ln2812">        }</a>
<a name="ln2813">      }</a>
<a name="ln2814">    } else {</a>
<a name="ln2815">      eap-&gt;line2 = lnum;</a>
<a name="ln2816">    }</a>
<a name="ln2817">    eap-&gt;addr_count++;</a>
<a name="ln2818"> </a>
<a name="ln2819">    if (*eap-&gt;cmd == ';') {</a>
<a name="ln2820">      if (!eap-&gt;skip) {</a>
<a name="ln2821">        curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln2822"> </a>
<a name="ln2823">        // Don't leave the cursor on an illegal line or column, but do</a>
<a name="ln2824">        // accept zero as address, so 0;/PATTERN/ works correctly</a>
<a name="ln2825">        // (where zero usually means to use the first line).</a>
<a name="ln2826">        // Check the cursor position before returning.</a>
<a name="ln2827">        if (eap-&gt;line2 &gt; 0) {</a>
<a name="ln2828">          check_cursor();</a>
<a name="ln2829">        } else {</a>
<a name="ln2830">          check_cursor_col();</a>
<a name="ln2831">        }</a>
<a name="ln2832">        need_check_cursor = true;</a>
<a name="ln2833">      }</a>
<a name="ln2834">    } else if (*eap-&gt;cmd != ',') {</a>
<a name="ln2835">      break;</a>
<a name="ln2836">    }</a>
<a name="ln2837">    eap-&gt;cmd++;</a>
<a name="ln2838">  }</a>
<a name="ln2839"> </a>
<a name="ln2840">  // One address given: set start and end lines.</a>
<a name="ln2841">  if (eap-&gt;addr_count == 1) {</a>
<a name="ln2842">    eap-&gt;line1 = eap-&gt;line2;</a>
<a name="ln2843">    // ... but only implicit: really no address given</a>
<a name="ln2844">    if (lnum == MAXLNUM) {</a>
<a name="ln2845">      eap-&gt;addr_count = 0;</a>
<a name="ln2846">    }</a>
<a name="ln2847">  }</a>
<a name="ln2848">  ret = OK;</a>
<a name="ln2849"> </a>
<a name="ln2850">theend:</a>
<a name="ln2851">  if (need_check_cursor) {</a>
<a name="ln2852">    check_cursor();</a>
<a name="ln2853">  }</a>
<a name="ln2854">  return ret;</a>
<a name="ln2855">}</a>
<a name="ln2856"> </a>
<a name="ln2857">/// Check for an Ex command with optional tail.</a>
<a name="ln2858">/// If there is a match advance &quot;pp&quot; to the argument and return true.</a>
<a name="ln2859">///</a>
<a name="ln2860">/// @param pp   start of command</a>
<a name="ln2861">/// @param cmd  name of command</a>
<a name="ln2862">/// @param len  required length</a>
<a name="ln2863">bool checkforcmd(char **pp, const char *cmd, int len)</a>
<a name="ln2864">{</a>
<a name="ln2865">  int i;</a>
<a name="ln2866"> </a>
<a name="ln2867">  for (i = 0; cmd[i] != NUL; i++) {</a>
<a name="ln2868">    if ((cmd)[i] != (*pp)[i]) {</a>
<a name="ln2869">      break;</a>
<a name="ln2870">    }</a>
<a name="ln2871">  }</a>
<a name="ln2872">  if (i &gt;= len &amp;&amp; !ASCII_ISALPHA((*pp)[i])) {</a>
<a name="ln2873">    *pp = skipwhite(*pp + i);</a>
<a name="ln2874">    return true;</a>
<a name="ln2875">  }</a>
<a name="ln2876">  return false;</a>
<a name="ln2877">}</a>
<a name="ln2878"> </a>
<a name="ln2879">/// Append &quot;cmd&quot; to the error message in IObuff.</a>
<a name="ln2880">/// Takes care of limiting the length and handling 0xa0, which would be</a>
<a name="ln2881">/// invisible otherwise.</a>
<a name="ln2882">static void append_command(const char *cmd)</a>
<a name="ln2883">{</a>
<a name="ln2884">  size_t len = strlen(IObuff);</a>
<a name="ln2885">  const char *s = cmd;</a>
<a name="ln2886">  char *d;</a>
<a name="ln2887"> </a>
<a name="ln2888">  if (len &gt; IOSIZE - 100) {</a>
<a name="ln2889">    // Not enough space, truncate and put in &quot;...&quot;.</a>
<a name="ln2890">    d = IObuff + IOSIZE - 100;</a>
<a name="ln2891">    d -= utf_head_off(IObuff, d);</a>
<a name="ln2892">    STRCPY(d, &quot;...&quot;);</a>
<a name="ln2893">  }</a>
<a name="ln2894">  xstrlcat(IObuff, &quot;: &quot;, IOSIZE);</a>
<a name="ln2895">  d = IObuff + strlen(IObuff);</a>
<a name="ln2896">  while (*s != NUL &amp;&amp; d - IObuff + 5 &lt; IOSIZE) {</a>
<a name="ln2897">    if ((uint8_t)s[0] == 0xc2 &amp;&amp; (uint8_t)s[1] == 0xa0) {</a>
<a name="ln2898">      s += 2;</a>
<a name="ln2899">      STRCPY(d, &quot;&lt;a0&gt;&quot;);</a>
<a name="ln2900">      d += 4;</a>
<a name="ln2901">    } else if (d - IObuff + utfc_ptr2len(s) + 1 &gt;= IOSIZE) {</a>
<a name="ln2902">      break;</a>
<a name="ln2903">    } else {</a>
<a name="ln2904">      mb_copy_char(&amp;s, &amp;d);</a>
<a name="ln2905">    }</a>
<a name="ln2906">  }</a>
<a name="ln2907">  *d = NUL;</a>
<a name="ln2908">}</a>
<a name="ln2909"> </a>
<a name="ln2910">/// Return true and set &quot;*idx&quot; if &quot;p&quot; points to a one letter command.</a>
<a name="ln2911">/// - The 'k' command can directly be followed by any character.</a>
<a name="ln2912">/// - The 's' command can be followed directly by 'c', 'g', 'i', 'I' or 'r'</a>
<a name="ln2913">///          but :sre[wind] is another command, as are :scr[iptnames],</a>
<a name="ln2914">///          :scs[cope], :sim[alt], :sig[ns] and :sil[ent].</a>
<a name="ln2915">static int one_letter_cmd(const char *p, cmdidx_T *idx)</a>
<a name="ln2916">{</a>
<a name="ln2917">  if (*p == 'k') {</a>
<a name="ln2918">    *idx = CMD_k;</a>
<a name="ln2919">    return true;</a>
<a name="ln2920">  }</a>
<a name="ln2921">  if (p[0] == 's'</a>
<a name="ln2922">      &amp;&amp; ((p[1] == 'c'</a>
<a name="ln2923">           &amp;&amp; (p[2] == NUL</a>
<a name="ln2924">               || (p[2] != 's' &amp;&amp; p[2] != 'r'</a>
<a name="ln2925">                   &amp;&amp; (p[3] == NUL</a>
<a name="ln2926">                       || (p[3] != 'i' &amp;&amp; p[4] != 'p')))))</a>
<a name="ln2927">          || p[1] == 'g'</a>
<a name="ln2928">          || (p[1] == 'i' &amp;&amp; p[2] != 'm' &amp;&amp; p[2] != 'l' &amp;&amp; p[2] != 'g')</a>
<a name="ln2929">          || p[1] == 'I'</a>
<a name="ln2930">          || (p[1] == 'r' &amp;&amp; p[2] != 'e'))) {</a>
<a name="ln2931">    *idx = CMD_substitute;</a>
<a name="ln2932">    return true;</a>
<a name="ln2933">  }</a>
<a name="ln2934">  return false;</a>
<a name="ln2935">}</a>
<a name="ln2936"> </a>
<a name="ln2937">/// Find an Ex command by its name, either built-in or user.</a>
<a name="ln2938">/// Start of the name can be found at eap-&gt;cmd.</a>
<a name="ln2939">/// Sets eap-&gt;cmdidx and returns a pointer to char after the command name.</a>
<a name="ln2940">/// &quot;full&quot; is set to true if the whole command name matched.</a>
<a name="ln2941">///</a>
<a name="ln2942">/// @return  NULL for an ambiguous user command.</a>
<a name="ln2943">char *find_ex_command(exarg_T *eap, int *full)</a>
<a name="ln2944">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2945">{</a>
<a name="ln2946">  // Isolate the command and search for it in the command table.</a>
<a name="ln2947">  char *p = eap-&gt;cmd;</a>
<a name="ln2948">  if (one_letter_cmd(p, &amp;eap-&gt;cmdidx)) {</a>
<a name="ln2949">    p++;</a>
<a name="ln2950">  } else {</a>
<a name="ln2951">    while (ASCII_ISALPHA(*p)) {</a>
<a name="ln2952">      p++;</a>
<a name="ln2953">    }</a>
<a name="ln2954">    // for python 3.x support &quot;:py3&quot;, &quot;:python3&quot;, &quot;:py3file&quot;, etc.</a>
<a name="ln2955">    if (eap-&gt;cmd[0] == 'p' &amp;&amp; eap-&gt;cmd[1] == 'y') {</a>
<a name="ln2956">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln2957">        p++;</a>
<a name="ln2958">      }</a>
<a name="ln2959">    }</a>
<a name="ln2960"> </a>
<a name="ln2961">    // check for non-alpha command</a>
<a name="ln2962">    if (p == eap-&gt;cmd &amp;&amp; vim_strchr(&quot;@!=&gt;&lt;&amp;~#&quot;, (uint8_t)(*p)) != NULL) {</a>
<a name="ln2963">      p++;</a>
<a name="ln2964">    }</a>
<a name="ln2965">    int len = (int)(p - eap-&gt;cmd);</a>
<a name="ln2966">    // The &quot;d&quot; command can directly be followed by 'l' or 'p' flag.</a>
<a name="ln2967">    if (*eap-&gt;cmd == 'd' &amp;&amp; (p[-1] == 'l' || p[-1] == 'p')) {</a>
<a name="ln2968">      // Check for &quot;:dl&quot;, &quot;:dell&quot;, etc. to &quot;:deletel&quot;: that's</a>
<a name="ln2969">      // :delete with the 'l' flag.  Same for 'p'.</a>
<a name="ln2970">      int i;</a>
<a name="ln2971">      for (i = 0; i &lt; len; i++) {</a>
<a name="ln2972">        if (eap-&gt;cmd[i] != (&quot;delete&quot;)[i]) {</a>
<a name="ln2973">          break;</a>
<a name="ln2974">        }</a>
<a name="ln2975">      }</a>
<a name="ln2976">      if (i == len - 1) {</a>
<a name="ln2977">        len--;</a>
<a name="ln2978">        if (p[-1] == 'l') {</a>
<a name="ln2979">          eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln2980">        } else {</a>
<a name="ln2981">          eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln2982">        }</a>
<a name="ln2983">      }</a>
<a name="ln2984">    }</a>
<a name="ln2985"> </a>
<a name="ln2986">    if (ASCII_ISLOWER(eap-&gt;cmd[0])) {</a>
<a name="ln2987">      const int c1 = (uint8_t)eap-&gt;cmd[0];</a>
<a name="ln2988">      const int c2 = len == 1 ? NUL : eap-&gt;cmd[1];</a>
<a name="ln2989"> </a>
<a name="ln2990">      if (command_count != CMD_SIZE) {</a>
<a name="ln2991">        iemsg(_(&quot;E943: Command table needs to be updated, run 'make'&quot;));</a>
<a name="ln2992">        getout(1);</a>
<a name="ln2993">      }</a>
<a name="ln2994"> </a>
<a name="ln2995">      // Use a precomputed index for fast look-up in cmdnames[]</a>
<a name="ln2996">      // taking into account the first 2 letters of eap-&gt;cmd.</a>
<a name="ln2997">      eap-&gt;cmdidx = cmdidxs1[CHAR_ORD_LOW(c1)];</a>
<a name="ln2998">      if (ASCII_ISLOWER(c2)) {</a>
<a name="ln2999">        eap-&gt;cmdidx += cmdidxs2[CHAR_ORD_LOW(c1)][CHAR_ORD_LOW(c2)];</a>
<a name="ln3000">      }</a>
<a name="ln3001">    } else if (ASCII_ISUPPER(eap-&gt;cmd[0])) {</a>
<a name="ln3002">      eap-&gt;cmdidx = CMD_Next;</a>
<a name="ln3003">    } else {</a>
<a name="ln3004">      eap-&gt;cmdidx = CMD_bang;</a>
<a name="ln3005">    }</a>
<a name="ln3006">    assert(eap-&gt;cmdidx &gt;= 0);</a>
<a name="ln3007"> </a>
<a name="ln3008">    if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, eap-&gt;cmd, 3) == 0) {</a>
<a name="ln3009">      // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3010">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3011">    }</a>
<a name="ln3012"> </a>
<a name="ln3013">    for (; (int)eap-&gt;cmdidx &lt; CMD_SIZE;</a>
<a name="ln3014">         eap-&gt;cmdidx = (cmdidx_T)((int)eap-&gt;cmdidx + 1)) {</a>
<a name="ln3015">      if (strncmp(cmdnames[(int)eap-&gt;cmdidx].cmd_name, eap-&gt;cmd,</a>
<a name="ln3016">                  (size_t)len) == 0) {</a>
<a name="ln3017">        if (full != NULL</a>
<a name="ln3018">            &amp;&amp; cmdnames[(int)eap-&gt;cmdidx].cmd_name[len] == NUL) {</a>
<a name="ln3019">          *full = true;</a>
<a name="ln3020">        }</a>
<a name="ln3021">        break;</a>
<a name="ln3022">      }</a>
<a name="ln3023">    }</a>
<a name="ln3024"> </a>
<a name="ln3025">    // Look for a user defined command as a last resort.</a>
<a name="ln3026">    if ((eap-&gt;cmdidx == CMD_SIZE)</a>
<a name="ln3027">        &amp;&amp; *eap-&gt;cmd &gt;= 'A' &amp;&amp; *eap-&gt;cmd &lt;= 'Z') {</a>
<a name="ln3028">      // User defined commands may contain digits.</a>
<a name="ln3029">      while (ASCII_ISALNUM(*p)) {</a>
<a name="ln3030">        p++;</a>
<a name="ln3031">      }</a>
<a name="ln3032">      p = find_ucmd(eap, p, full, NULL, NULL);</a>
<a name="ln3033">    }</a>
<a name="ln3034">    if (p == eap-&gt;cmd) {</a>
<a name="ln3035">      eap-&gt;cmdidx = CMD_SIZE;</a>
<a name="ln3036">    }</a>
<a name="ln3037">  }</a>
<a name="ln3038"> </a>
<a name="ln3039">  return p;</a>
<a name="ln3040">}</a>
<a name="ln3041"> </a>
<a name="ln3042">static struct cmdmod {</a>
<a name="ln3043">  char *name;</a>
<a name="ln3044">  int minlen;</a>
<a name="ln3045">  int has_count;            // :123verbose  :3tab</a>
<a name="ln3046">} cmdmods[] = {</a>
<a name="ln3047">  { &quot;aboveleft&quot;, 3, false },</a>
<a name="ln3048">  { &quot;belowright&quot;, 3, false },</a>
<a name="ln3049">  { &quot;botright&quot;, 2, false },</a>
<a name="ln3050">  { &quot;browse&quot;, 3, false },</a>
<a name="ln3051">  { &quot;confirm&quot;, 4, false },</a>
<a name="ln3052">  { &quot;filter&quot;, 4, false },</a>
<a name="ln3053">  { &quot;hide&quot;, 3, false },</a>
<a name="ln3054">  { &quot;horizontal&quot;, 3, false },</a>
<a name="ln3055">  { &quot;keepalt&quot;, 5, false },</a>
<a name="ln3056">  { &quot;keepjumps&quot;, 5, false },</a>
<a name="ln3057">  { &quot;keepmarks&quot;, 3, false },</a>
<a name="ln3058">  { &quot;keeppatterns&quot;, 5, false },</a>
<a name="ln3059">  { &quot;leftabove&quot;, 5, false },</a>
<a name="ln3060">  { &quot;lockmarks&quot;, 3, false },</a>
<a name="ln3061">  { &quot;noautocmd&quot;, 3, false },</a>
<a name="ln3062">  { &quot;noswapfile&quot;, 3, false },</a>
<a name="ln3063">  { &quot;rightbelow&quot;, 6, false },</a>
<a name="ln3064">  { &quot;sandbox&quot;, 3, false },</a>
<a name="ln3065">  { &quot;silent&quot;, 3, false },</a>
<a name="ln3066">  { &quot;tab&quot;, 3, true },</a>
<a name="ln3067">  { &quot;topleft&quot;, 2, false },</a>
<a name="ln3068">  { &quot;unsilent&quot;, 3, false },</a>
<a name="ln3069">  { &quot;verbose&quot;, 4, true },</a>
<a name="ln3070">  { &quot;vertical&quot;, 4, false },</a>
<a name="ln3071">};</a>
<a name="ln3072"> </a>
<a name="ln3073">/// @return  length of a command modifier (including optional count) or,</a>
<a name="ln3074">///          zero when it's not a modifier.</a>
<a name="ln3075">int modifier_len(char *cmd)</a>
<a name="ln3076">{</a>
<a name="ln3077">  char *p = cmd;</a>
<a name="ln3078"> </a>
<a name="ln3079">  if (ascii_isdigit(*cmd)) {</a>
<a name="ln3080">    p = skipwhite(skipdigits(cmd + 1));</a>
<a name="ln3081">  }</a>
<a name="ln3082">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3083">    int j;</a>
<a name="ln3084">    for (j = 0; p[j] != NUL; j++) {</a>
<a name="ln3085">      if (p[j] != cmdmods[i].name[j]) {</a>
<a name="ln3086">        break;</a>
<a name="ln3087">      }</a>
<a name="ln3088">    }</a>
<a name="ln3089">    if (j &gt;= cmdmods[i].minlen</a>
<a name="ln3090">        &amp;&amp; !ASCII_ISALPHA(p[j])</a>
<a name="ln3091">        &amp;&amp; (p == cmd || cmdmods[i].has_count)) {</a>
<a name="ln3092">      return j + (int)(p - cmd);</a>
<a name="ln3093">    }</a>
<a name="ln3094">  }</a>
<a name="ln3095">  return 0;</a>
<a name="ln3096">}</a>
<a name="ln3097"> </a>
<a name="ln3098">/// @return  &gt; 0 if an Ex command &quot;name&quot; exists or,</a>
<a name="ln3099">///            2 if there is an exact match or,</a>
<a name="ln3100">///            3 if there is an ambiguous match.</a>
<a name="ln3101">int cmd_exists(const char *const name)</a>
<a name="ln3102">{</a>
<a name="ln3103">  // Check command modifiers.</a>
<a name="ln3104">  for (int i = 0; i &lt; (int)ARRAY_SIZE(cmdmods); i++) {</a>
<a name="ln3105">    int j;</a>
<a name="ln3106">    for (j = 0; name[j] != NUL; j++) {</a>
<a name="ln3107">      if (name[j] != cmdmods[i].name[j]) {</a>
<a name="ln3108">        break;</a>
<a name="ln3109">      }</a>
<a name="ln3110">    }</a>
<a name="ln3111">    if (name[j] == NUL &amp;&amp; j &gt;= cmdmods[i].minlen) {</a>
<a name="ln3112">      return cmdmods[i].name[j] == NUL ? 2 : 1;</a>
<a name="ln3113">    }</a>
<a name="ln3114">  }</a>
<a name="ln3115"> </a>
<a name="ln3116">  // Check built-in commands and user defined commands.</a>
<a name="ln3117">  // For &quot;:2match&quot; and &quot;:3match&quot; we need to skip the number.</a>
<a name="ln3118">  exarg_T ea;</a>
<a name="ln3119">  ea.cmd = (char *)((*name == '2' || *name == '3') ? name + 1 : name);</a>
<a name="ln3120">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3121">  ea.flags = 0;</a>
<a name="ln3122">  int full = false;</a>
<a name="ln3123">  char *p = find_ex_command(&amp;ea, &amp;full);</a>
<a name="ln3124">  if (p == NULL) {</a>
<a name="ln3125">    return 3;</a>
<a name="ln3126">  }</a>
<a name="ln3127">  if (ascii_isdigit(*name) &amp;&amp; ea.cmdidx != CMD_match) {</a>
<a name="ln3128">    return 0;</a>
<a name="ln3129">  }</a>
<a name="ln3130">  if (*skipwhite(p) != NUL) {</a>
<a name="ln3131">    return 0;           // trailing garbage</a>
<a name="ln3132">  }</a>
<a name="ln3133">  return ea.cmdidx == CMD_SIZE ? 0 : (full ? 2 : 1);</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136">/// &quot;fullcommand&quot; function</a>
<a name="ln3137">void f_fullcommand(typval_T *argvars, typval_T *rettv, EvalFuncData fptr)</a>
<a name="ln3138">{</a>
<a name="ln3139">  char *name = (char *)tv_get_string(&amp;argvars[0]);</a>
<a name="ln3140"> </a>
<a name="ln3141">  rettv-&gt;v_type = VAR_STRING;</a>
<a name="ln3142">  rettv-&gt;vval.v_string = NULL;</a>
<a name="ln3143">  if (name == NULL) {</a>
<a name="ln3144">    return;</a>
<a name="ln3145">  }</a>
<a name="ln3146"> </a>
<a name="ln3147">  while (*name == ':') {</a>
<a name="ln3148">    name++;</a>
<a name="ln3149">  }</a>
<a name="ln3150">  name = skip_range(name, NULL);</a>
<a name="ln3151"> </a>
<a name="ln3152">  exarg_T ea;</a>
<a name="ln3153">  ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name;</a>
<a name="ln3154">  ea.cmdidx = (cmdidx_T)0;</a>
<a name="ln3155">  ea.flags = 0;</a>
<a name="ln3156">  char *p = find_ex_command(&amp;ea, NULL);</a>
<a name="ln3157">  if (p == NULL || ea.cmdidx == CMD_SIZE) {</a>
<a name="ln3158">    return;</a>
<a name="ln3159">  }</a>
<a name="ln3160"> </a>
<a name="ln3161">  rettv-&gt;vval.v_string = xstrdup(IS_USER_CMDIDX(ea.cmdidx)</a>
<a name="ln3162">                                 ? get_user_command_name(ea.useridx, ea.cmdidx)</a>
<a name="ln3163">                                 : cmdnames[ea.cmdidx].cmd_name);</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166">cmdidx_T excmd_get_cmdidx(const char *cmd, size_t len)</a>
<a name="ln3167">{</a>
<a name="ln3168">  if (len == 3 &amp;&amp; strncmp(&quot;def&quot;, cmd, 3) == 0) {</a>
<a name="ln3169">    // Make :def an unknown command to avoid confusing behavior. #23149</a>
<a name="ln3170">    return CMD_SIZE;</a>
<a name="ln3171">  }</a>
<a name="ln3172"> </a>
<a name="ln3173">  cmdidx_T idx;</a>
<a name="ln3174"> </a>
<a name="ln3175">  if (!one_letter_cmd(cmd, &amp;idx)) {</a>
<a name="ln3176">    for (idx = (cmdidx_T)0; (int)idx &lt; CMD_SIZE; idx = (cmdidx_T)((int)idx + 1)) {</a>
<a name="ln3177">      if (strncmp(cmdnames[(int)idx].cmd_name, cmd, len) == 0) {</a>
<a name="ln3178">        break;</a>
<a name="ln3179">      }</a>
<a name="ln3180">    }</a>
<a name="ln3181">  }</a>
<a name="ln3182"> </a>
<a name="ln3183">  return idx;</a>
<a name="ln3184">}</a>
<a name="ln3185"> </a>
<a name="ln3186">uint32_t excmd_get_argt(cmdidx_T idx)</a>
<a name="ln3187">{</a>
<a name="ln3188">  return cmdnames[(int)idx].cmd_argt;</a>
<a name="ln3189">}</a>
<a name="ln3190"> </a>
<a name="ln3191">/// Skip a range specifier of the form: addr [,addr] [;addr] ..</a>
<a name="ln3192">///</a>
<a name="ln3193">/// Backslashed delimiters after / or ? will be skipped, and commands will</a>
<a name="ln3194">/// not be expanded between /'s and ?'s or after &quot;'&quot;.</a>
<a name="ln3195">///</a>
<a name="ln3196">/// Also skip white space and &quot;:&quot; characters.</a>
<a name="ln3197">///</a>
<a name="ln3198">/// @param ctx  pointer to xp_context or NULL</a>
<a name="ln3199">///</a>
<a name="ln3200">/// @return the &quot;cmd&quot; pointer advanced to beyond the range.</a>
<a name="ln3201">char *skip_range(const char *cmd, int *ctx)</a>
<a name="ln3202">{</a>
<a name="ln3203">  while (vim_strchr(&quot; \t0123456789.$%'/?-+,;\\&quot;, (uint8_t)(*cmd)) != NULL) {</a>
<a name="ln3204">    if (*cmd == '\\') {</a>
<a name="ln3205">      if (cmd[1] == '?' || cmd[1] == '/' || cmd[1] == '&amp;') {</a>
<a name="ln3206">        cmd++;</a>
<a name="ln3207">      } else {</a>
<a name="ln3208">        break;</a>
<a name="ln3209">      }</a>
<a name="ln3210">    } else if (*cmd == '\'') {</a>
<a name="ln3211">      if (*++cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3212">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3213">      }</a>
<a name="ln3214">    } else if (*cmd == '/' || *cmd == '?') {</a>
<a name="ln3215">      unsigned delim = (unsigned)(*cmd++);</a>
<a name="ln3216">      while (*cmd != NUL &amp;&amp; *cmd != (char)delim) {</a>
<a name="ln3217">        if (*cmd++ == '\\' &amp;&amp; *cmd != NUL) {</a>
<a name="ln3218">          cmd++;</a>
<a name="ln3219">        }</a>
<a name="ln3220">      }</a>
<a name="ln3221">      if (*cmd == NUL &amp;&amp; ctx != NULL) {</a>
<a name="ln3222">        *ctx = EXPAND_NOTHING;</a>
<a name="ln3223">      }</a>
<a name="ln3224">    }</a>
<a name="ln3225">    if (*cmd != NUL) {</a>
<a name="ln3226">      cmd++;</a>
<a name="ln3227">    }</a>
<a name="ln3228">  }</a>
<a name="ln3229"> </a>
<a name="ln3230">  // Skip &quot;:&quot; and white space.</a>
<a name="ln3231">  cmd = skip_colon_white(cmd, false);</a>
<a name="ln3232"> </a>
<a name="ln3233">  return (char *)cmd;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">static const char *addr_error(cmd_addr_T addr_type)</a>
<a name="ln3237">{</a>
<a name="ln3238">  if (addr_type == ADDR_NONE) {</a>
<a name="ln3239">    return _(e_norange);</a>
<a name="ln3240">  } else {</a>
<a name="ln3241">    return _(e_invrange);</a>
<a name="ln3242">  }</a>
<a name="ln3243">}</a>
<a name="ln3244"> </a>
<a name="ln3245">/// Gets a single EX address.</a>
<a name="ln3246">///</a>
<a name="ln3247">/// Sets ptr to the next character after the part that was interpreted.</a>
<a name="ln3248">/// Sets ptr to NULL when an error is encountered (stored in `errormsg`).</a>
<a name="ln3249">/// May set the last used search pattern.</a>
<a name="ln3250">///</a>
<a name="ln3251">/// @param skip           only skip the address, don't use it</a>
<a name="ln3252">/// @param silent         no errors or side effects</a>
<a name="ln3253">/// @param to_other_file  flag: may jump to other file</a>
<a name="ln3254">/// @param address_count  1 for first, &gt;1 after comma</a>
<a name="ln3255">/// @param errormsg       Error message, if any</a>
<a name="ln3256">///</a>
<a name="ln3257">/// @return               MAXLNUM when no Ex address was found.</a>
<a name="ln3258">static linenr_T get_address(exarg_T *eap, char **ptr, cmd_addr_T addr_type, int skip, bool silent,</a>
<a name="ln3259">                            int to_other_file, int address_count, const char **errormsg)</a>
<a name="ln3260">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3261">{</a>
<a name="ln3262">  int c;</a>
<a name="ln3263">  int i;</a>
<a name="ln3264">  linenr_T n;</a>
<a name="ln3265">  pos_T pos;</a>
<a name="ln3266">  buf_T *buf;</a>
<a name="ln3267"> </a>
<a name="ln3268">  char *cmd = skipwhite(*ptr);</a>
<a name="ln3269">  linenr_T lnum = MAXLNUM;</a>
<a name="ln3270">  do {</a>
<a name="ln3271">    switch (*cmd) {</a>
<a name="ln3272">    case '.':                               // '.' - Cursor position</a>
<a name="ln3273">      cmd++;</a>
<a name="ln3274">      switch (addr_type) {</a>
<a name="ln3275">      case ADDR_LINES:</a>
<a name="ln3276">      case ADDR_OTHER:</a>
<a name="ln3277">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3278">        break;</a>
<a name="ln3279">      case ADDR_WINDOWS:</a>
<a name="ln3280">        lnum = CURRENT_WIN_NR;</a>
<a name="ln3281">        break;</a>
<a name="ln3282">      case ADDR_ARGUMENTS:</a>
<a name="ln3283">        lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3284">        break;</a>
<a name="ln3285">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3286">      case ADDR_BUFFERS:</a>
<a name="ln3287">        lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3288">        break;</a>
<a name="ln3289">      case ADDR_TABS:</a>
<a name="ln3290">        lnum = CURRENT_TAB_NR;</a>
<a name="ln3291">        break;</a>
<a name="ln3292">      case ADDR_NONE:</a>
<a name="ln3293">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3294">      case ADDR_UNSIGNED:</a>
<a name="ln3295">        *errormsg = addr_error(addr_type);</a>
<a name="ln3296">        cmd = NULL;</a>
<a name="ln3297">        goto error;</a>
<a name="ln3298">        break;</a>
<a name="ln3299">      case ADDR_QUICKFIX:</a>
<a name="ln3300">        lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3301">        break;</a>
<a name="ln3302">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3303">        lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3304">        break;</a>
<a name="ln3305">      }</a>
<a name="ln3306">      break;</a>
<a name="ln3307"> </a>
<a name="ln3308">    case '$':                               // '$' - last line</a>
<a name="ln3309">      cmd++;</a>
<a name="ln3310">      switch (addr_type) {</a>
<a name="ln3311">      case ADDR_LINES:</a>
<a name="ln3312">      case ADDR_OTHER:</a>
<a name="ln3313">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln3314">        break;</a>
<a name="ln3315">      case ADDR_WINDOWS:</a>
<a name="ln3316">        lnum = LAST_WIN_NR;</a>
<a name="ln3317">        break;</a>
<a name="ln3318">      case ADDR_ARGUMENTS:</a>
<a name="ln3319">        lnum = ARGCOUNT;</a>
<a name="ln3320">        break;</a>
<a name="ln3321">      case ADDR_LOADED_BUFFERS:</a>
<a name="ln3322">        buf = lastbuf;</a>
<a name="ln3323">        while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3324">          if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3325">            break;</a>
<a name="ln3326">          }</a>
<a name="ln3327">          buf = buf-&gt;b_prev;</a>
<a name="ln3328">        }</a>
<a name="ln3329">        lnum = buf-&gt;b_fnum;</a>
<a name="ln3330">        break;</a>
<a name="ln3331">      case ADDR_BUFFERS:</a>
<a name="ln3332">        lnum = lastbuf-&gt;b_fnum;</a>
<a name="ln3333">        break;</a>
<a name="ln3334">      case ADDR_TABS:</a>
<a name="ln3335">        lnum = LAST_TAB_NR;</a>
<a name="ln3336">        break;</a>
<a name="ln3337">      case ADDR_NONE:</a>
<a name="ln3338">      case ADDR_TABS_RELATIVE:</a>
<a name="ln3339">      case ADDR_UNSIGNED:</a>
<a name="ln3340">        *errormsg = addr_error(addr_type);</a>
<a name="ln3341">        cmd = NULL;</a>
<a name="ln3342">        goto error;</a>
<a name="ln3343">        break;</a>
<a name="ln3344">      case ADDR_QUICKFIX:</a>
<a name="ln3345">        lnum = (linenr_T)qf_get_size(eap);</a>
<a name="ln3346">        if (lnum == 0) {</a>
<a name="ln3347">          lnum = 1;</a>
<a name="ln3348">        }</a>
<a name="ln3349">        break;</a>
<a name="ln3350">      case ADDR_QUICKFIX_VALID:</a>
<a name="ln3351">        lnum = (linenr_T)qf_get_valid_size(eap);</a>
<a name="ln3352">        if (lnum == 0) {</a>
<a name="ln3353">          lnum = 1;</a>
<a name="ln3354">        }</a>
<a name="ln3355">        break;</a>
<a name="ln3356">      }</a>
<a name="ln3357">      break;</a>
<a name="ln3358"> </a>
<a name="ln3359">    case '\'':                              // ''' - mark</a>
<a name="ln3360">      if (*++cmd == NUL) {</a>
<a name="ln3361">        cmd = NULL;</a>
<a name="ln3362">        goto error;</a>
<a name="ln3363">      }</a>
<a name="ln3364">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3365">        *errormsg = addr_error(addr_type);</a>
<a name="ln3366">        cmd = NULL;</a>
<a name="ln3367">        goto error;</a>
<a name="ln3368">      }</a>
<a name="ln3369">      if (skip) {</a>
<a name="ln3370">        cmd++;</a>
<a name="ln3371">      } else {</a>
<a name="ln3372">        // Only accept a mark in another file when it is</a>
<a name="ln3373">        // used by itself: &quot;:'M&quot;.</a>
<a name="ln3374">        MarkGet flag = to_other_file &amp;&amp; cmd[1] == NUL ? kMarkAll : kMarkBufLocal;</a>
<a name="ln3375">        fmark_T *fm = mark_get(curbuf, curwin, NULL, flag, *cmd);</a>
<a name="ln3376">        cmd++;</a>
<a name="ln3377">        if (fm != NULL &amp;&amp; fm-&gt;fnum != curbuf-&gt;handle) {</a>
<a name="ln3378">          // Jumped to another file.</a>
<a name="ln3379">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3380">        } else {</a>
<a name="ln3381">          if (!mark_check(fm, errormsg)) {</a>
<a name="ln3382">            cmd = NULL;</a>
<a name="ln3383">            goto error;</a>
<a name="ln3384">          }</a>
<a name="ln3385">          assert(fm != NULL);</a>
<a name="ln3386">          lnum = fm-&gt;mark.lnum;</a>
<a name="ln3387">        }</a>
<a name="ln3388">      }</a>
<a name="ln3389">      break;</a>
<a name="ln3390"> </a>
<a name="ln3391">    case '/':</a>
<a name="ln3392">    case '?':                           // '/' or '?' - search</a>
<a name="ln3393">      c = (uint8_t)(*cmd++);</a>
<a name="ln3394">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3395">        *errormsg = addr_error(addr_type);</a>
<a name="ln3396">        cmd = NULL;</a>
<a name="ln3397">        goto error;</a>
<a name="ln3398">      }</a>
<a name="ln3399">      if (skip) {                       // skip &quot;/pat/&quot;</a>
<a name="ln3400">        cmd = skip_regexp(cmd, c, magic_isset());</a>
<a name="ln3401">        if (*cmd == c) {</a>
<a name="ln3402">          cmd++;</a>
<a name="ln3403">        }</a>
<a name="ln3404">      } else {</a>
<a name="ln3405">        int flags;</a>
<a name="ln3406"> </a>
<a name="ln3407">        pos = curwin-&gt;w_cursor;  // save curwin-&gt;w_cursor</a>
<a name="ln3408"> </a>
<a name="ln3409">        // When '/' or '?' follows another address, start from</a>
<a name="ln3410">        // there.</a>
<a name="ln3411">        if (lnum &gt; 0 &amp;&amp; lnum != MAXLNUM) {</a>
<a name="ln3412">          curwin-&gt;w_cursor.lnum</a>
<a name="ln3413">            = lnum &gt; curbuf-&gt;b_ml.ml_line_count ? curbuf-&gt;b_ml.ml_line_count : lnum;</a>
<a name="ln3414">        }</a>
<a name="ln3415"> </a>
<a name="ln3416">        // Start a forward search at the end of the line (unless</a>
<a name="ln3417">        // before the first line).</a>
<a name="ln3418">        // Start a backward search at the start of the line.</a>
<a name="ln3419">        // This makes sure we never match in the current</a>
<a name="ln3420">        // line, and can match anywhere in the</a>
<a name="ln3421">        // next/previous line.</a>
<a name="ln3422">        if (c == '/' &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 0) {</a>
<a name="ln3423">          curwin-&gt;w_cursor.col = MAXCOL;</a>
<a name="ln3424">        } else {</a>
<a name="ln3425">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3426">        }</a>
<a name="ln3427">        searchcmdlen = 0;</a>
<a name="ln3428">        flags = silent ? 0 : SEARCH_HIS | SEARCH_MSG;</a>
<a name="ln3429">        if (!do_search(NULL, c, c, cmd, 1L, flags, NULL)) {</a>
<a name="ln3430">          curwin-&gt;w_cursor = pos;</a>
<a name="ln3431">          cmd = NULL;</a>
<a name="ln3432">          goto error;</a>
<a name="ln3433">        }</a>
<a name="ln3434">        lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3435">        curwin-&gt;w_cursor = pos;</a>
<a name="ln3436">        // adjust command string pointer</a>
<a name="ln3437">        cmd += searchcmdlen;</a>
<a name="ln3438">      }</a>
<a name="ln3439">      break;</a>
<a name="ln3440"> </a>
<a name="ln3441">    case '\\':                      // &quot;\?&quot;, &quot;\/&quot; or &quot;\&amp;&quot;, repeat search</a>
<a name="ln3442">      cmd++;</a>
<a name="ln3443">      if (addr_type != ADDR_LINES) {</a>
<a name="ln3444">        *errormsg = addr_error(addr_type);</a>
<a name="ln3445">        cmd = NULL;</a>
<a name="ln3446">        goto error;</a>
<a name="ln3447">      }</a>
<a name="ln3448">      if (*cmd == '&amp;') {</a>
<a name="ln3449">        i = RE_SUBST;</a>
<a name="ln3450">      } else if (*cmd == '?' || *cmd == '/') {</a>
<a name="ln3451">        i = RE_SEARCH;</a>
<a name="ln3452">      } else {</a>
<a name="ln3453">        *errormsg = _(e_backslash);</a>
<a name="ln3454">        cmd = NULL;</a>
<a name="ln3455">        goto error;</a>
<a name="ln3456">      }</a>
<a name="ln3457"> </a>
<a name="ln3458">      if (!skip) {</a>
<a name="ln3459">        // When search follows another address, start from there.</a>
<a name="ln3460">        pos.lnum = (lnum != MAXLNUM) ? lnum : curwin-&gt;w_cursor.lnum;</a>
<a name="ln3461">        // Start the search just like for the above do_search().</a>
<a name="ln3462">        pos.col = (*cmd != '?') ? MAXCOL : 0;</a>
<a name="ln3463">        pos.coladd = 0;</a>
<a name="ln3464">        if (searchit(curwin, curbuf, &amp;pos, NULL,</a>
<a name="ln3465">                     *cmd == '?' ? BACKWARD : FORWARD,</a>
<a name="ln3466">                     &quot;&quot;, 1L, SEARCH_MSG, i, NULL) != FAIL) {</a>
<a name="ln3467">          lnum = pos.lnum;</a>
<a name="ln3468">        } else {</a>
<a name="ln3469">          cmd = NULL;</a>
<a name="ln3470">          goto error;</a>
<a name="ln3471">        }</a>
<a name="ln3472">      }</a>
<a name="ln3473">      cmd++;</a>
<a name="ln3474">      break;</a>
<a name="ln3475"> </a>
<a name="ln3476">    default:</a>
<a name="ln3477">      if (ascii_isdigit(*cmd)) {                // absolute line number</a>
<a name="ln3478">        lnum = (linenr_T)getdigits(&amp;cmd, false, 0);</a>
<a name="ln3479">      }</a>
<a name="ln3480">    }</a>
<a name="ln3481"> </a>
<a name="ln3482">    while (true) {</a>
<a name="ln3483">      cmd = skipwhite(cmd);</a>
<a name="ln3484">      if (*cmd != '-' &amp;&amp; *cmd != '+' &amp;&amp; !ascii_isdigit(*cmd)) {</a>
<a name="ln3485">        break;</a>
<a name="ln3486">      }</a>
<a name="ln3487"> </a>
<a name="ln3488">      if (lnum == MAXLNUM) {</a>
<a name="ln3489">        switch (addr_type) {</a>
<a name="ln3490">        case ADDR_LINES:</a>
<a name="ln3491">        case ADDR_OTHER:</a>
<a name="ln3492">          // &quot;+1&quot; is same as &quot;.+1&quot;</a>
<a name="ln3493">          lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3494">          break;</a>
<a name="ln3495">        case ADDR_WINDOWS:</a>
<a name="ln3496">          lnum = CURRENT_WIN_NR;</a>
<a name="ln3497">          break;</a>
<a name="ln3498">        case ADDR_ARGUMENTS:</a>
<a name="ln3499">          lnum = curwin-&gt;w_arg_idx + 1;</a>
<a name="ln3500">          break;</a>
<a name="ln3501">        case ADDR_LOADED_BUFFERS:</a>
<a name="ln3502">        case ADDR_BUFFERS:</a>
<a name="ln3503">          lnum = curbuf-&gt;b_fnum;</a>
<a name="ln3504">          break;</a>
<a name="ln3505">        case ADDR_TABS:</a>
<a name="ln3506">          lnum = CURRENT_TAB_NR;</a>
<a name="ln3507">          break;</a>
<a name="ln3508">        case ADDR_TABS_RELATIVE:</a>
<a name="ln3509">          lnum = 1;</a>
<a name="ln3510">          break;</a>
<a name="ln3511">        case ADDR_QUICKFIX:</a>
<a name="ln3512">          lnum = (linenr_T)qf_get_cur_idx(eap);</a>
<a name="ln3513">          break;</a>
<a name="ln3514">        case ADDR_QUICKFIX_VALID:</a>
<a name="ln3515">          lnum = qf_get_cur_valid_idx(eap);</a>
<a name="ln3516">          break;</a>
<a name="ln3517">        case ADDR_NONE:</a>
<a name="ln3518">        case ADDR_UNSIGNED:</a>
<a name="ln3519">          lnum = 0;</a>
<a name="ln3520">          break;</a>
<a name="ln3521">        }</a>
<a name="ln3522">      }</a>
<a name="ln3523"> </a>
<a name="ln3524">      if (ascii_isdigit(*cmd)) {</a>
<a name="ln3525">        i = '+';                        // &quot;number&quot; is same as &quot;+number&quot;</a>
<a name="ln3526">      } else {</a>
<a name="ln3527">        i = (uint8_t)(*cmd++);</a>
<a name="ln3528">      }</a>
<a name="ln3529">      if (!ascii_isdigit(*cmd)) {       // '+' is '+1'</a>
<a name="ln3530">        n = 1;</a>
<a name="ln3531">      } else {</a>
<a name="ln3532">        // &quot;number&quot;, &quot;+number&quot; or &quot;-number&quot;</a>
<a name="ln3533">        n = getdigits_int32(&amp;cmd, false, MAXLNUM);</a>
<a name="ln3534">        if (n == MAXLNUM) {</a>
<a name="ln3535">          *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3536">          goto error;</a>
<a name="ln3537">        }</a>
<a name="ln3538">      }</a>
<a name="ln3539"> </a>
<a name="ln3540">      if (addr_type == ADDR_TABS_RELATIVE) {</a>
<a name="ln3541">        *errormsg = _(e_invrange);</a>
<a name="ln3542">        cmd = NULL;</a>
<a name="ln3543">        goto error;</a>
<a name="ln3544">      } else if (addr_type == ADDR_LOADED_BUFFERS || addr_type == ADDR_BUFFERS) {</a>
<a name="ln3545">        lnum = compute_buffer_local_count(addr_type, lnum, (i == '-') ? -1 * n : n);</a>
<a name="ln3546">      } else {</a>
<a name="ln3547">        // Relative line addressing: need to adjust for lines in a</a>
<a name="ln3548">        // closed fold after the first address.</a>
<a name="ln3549">        if (addr_type == ADDR_LINES &amp;&amp; (i == '-' || i == '+')</a>
<a name="ln3550">            &amp;&amp; address_count &gt;= 2) {</a>
<a name="ln3551">          (void)hasFolding(lnum, NULL, &amp;lnum);</a>
<a name="ln3552">        }</a>
<a name="ln3553">        if (i == '-') {</a>
<a name="ln3554">          lnum -= n;</a>
<a name="ln3555">        } else {</a>
<a name="ln3556">          if (n &gt;= INT32_MAX - lnum) {</a>
<a name="ln3557">            *errormsg = _(e_line_number_out_of_range);</a>
<a name="ln3558">            goto error;</a>
<a name="ln3559">          }</a>
<a name="ln3560">          lnum += n;</a>
<a name="ln3561">        }</a>
<a name="ln3562">      }</a>
<a name="ln3563">    }</a>
<a name="ln3564">  } while (*cmd == '/' || *cmd == '?');</a>
<a name="ln3565"> </a>
<a name="ln3566">error:</a>
<a name="ln3567">  *ptr = cmd;</a>
<a name="ln3568">  return lnum;</a>
<a name="ln3569">}</a>
<a name="ln3570"> </a>
<a name="ln3571">/// Get flags from an Ex command argument.</a>
<a name="ln3572">static void get_flags(exarg_T *eap)</a>
<a name="ln3573">{</a>
<a name="ln3574">  while (vim_strchr(&quot;lp#&quot;, (uint8_t)(*eap-&gt;arg)) != NULL) {</a>
<a name="ln3575">    if (*eap-&gt;arg == 'l') {</a>
<a name="ln3576">      eap-&gt;flags |= EXFLAG_LIST;</a>
<a name="ln3577">    } else if (*eap-&gt;arg == 'p') {</a>
<a name="ln3578">      eap-&gt;flags |= EXFLAG_PRINT;</a>
<a name="ln3579">    } else {</a>
<a name="ln3580">      eap-&gt;flags |= EXFLAG_NR;</a>
<a name="ln3581">    }</a>
<a name="ln3582">    eap-&gt;arg = skipwhite(eap-&gt;arg + 1);</a>
<a name="ln3583">  }</a>
<a name="ln3584">}</a>
<a name="ln3585"> </a>
<a name="ln3586">/// Stub function for command which is Not Implemented. NI!</a>
<a name="ln3587">void ex_ni(exarg_T *eap)</a>
<a name="ln3588">{</a>
<a name="ln3589">  if (!eap-&gt;skip) {</a>
<a name="ln3590">    eap-&gt;errmsg = _(&quot;E319: The command is not available in this version&quot;);</a>
<a name="ln3591">  }</a>
<a name="ln3592">}</a>
<a name="ln3593"> </a>
<a name="ln3594">/// Stub function for script command which is Not Implemented. NI!</a>
<a name="ln3595">/// Skips over &quot;:perl &lt;&lt;EOF&quot; constructs.</a>
<a name="ln3596">static void ex_script_ni(exarg_T *eap)</a>
<a name="ln3597">{</a>
<a name="ln3598">  if (!eap-&gt;skip) {</a>
<a name="ln3599">    ex_ni(eap);</a>
<a name="ln3600">  } else {</a>
<a name="ln3601">    size_t len;</a>
<a name="ln3602">    xfree(script_get(eap, &amp;len));</a>
<a name="ln3603">  }</a>
<a name="ln3604">}</a>
<a name="ln3605"> </a>
<a name="ln3606">/// Check range in Ex command for validity.</a>
<a name="ln3607">///</a>
<a name="ln3608">/// @return  NULL when valid, error message when invalid.</a>
<a name="ln3609">char *invalid_range(exarg_T *eap)</a>
<a name="ln3610">{</a>
<a name="ln3611">  buf_T *buf;</a>
<a name="ln3612">  if (eap-&gt;line1 &lt; 0 || eap-&gt;line2 &lt; 0 || eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln3613">    return _(e_invrange);</a>
<a name="ln3614">  }</a>
<a name="ln3615"> </a>
<a name="ln3616">  if (eap-&gt;argt &amp; EX_RANGE) {</a>
<a name="ln3617">    switch (eap-&gt;addr_type) {</a>
<a name="ln3618">    case ADDR_LINES:</a>
<a name="ln3619">      if (eap-&gt;line2 &gt; (curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3620">                        + (eap-&gt;cmdidx == CMD_diffget))) {</a>
<a name="ln3621">        return _(e_invrange);</a>
<a name="ln3622">      }</a>
<a name="ln3623">      break;</a>
<a name="ln3624">    case ADDR_ARGUMENTS:</a>
<a name="ln3625">      // add 1 if ARGCOUNT is 0</a>
<a name="ln3626">      if (eap-&gt;line2 &gt; ARGCOUNT + (!ARGCOUNT)) {</a>
<a name="ln3627">        return _(e_invrange);</a>
<a name="ln3628">      }</a>
<a name="ln3629">      break;</a>
<a name="ln3630">    case ADDR_BUFFERS:</a>
<a name="ln3631">      // Only a boundary check, not whether the buffers actually</a>
<a name="ln3632">      // exist.</a>
<a name="ln3633">      if (eap-&gt;line1 &lt; 1 || eap-&gt;line2 &gt; get_highest_fnum()) {</a>
<a name="ln3634">        return _(e_invrange);</a>
<a name="ln3635">      }</a>
<a name="ln3636">      break;</a>
<a name="ln3637">    case ADDR_LOADED_BUFFERS:</a>
<a name="ln3638">      buf = firstbuf;</a>
<a name="ln3639">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3640">        if (buf-&gt;b_next == NULL) {</a>
<a name="ln3641">          return _(e_invrange);</a>
<a name="ln3642">        }</a>
<a name="ln3643">        buf = buf-&gt;b_next;</a>
<a name="ln3644">      }</a>
<a name="ln3645">      if (eap-&gt;line1 &lt; buf-&gt;b_fnum) {</a>
<a name="ln3646">        return _(e_invrange);</a>
<a name="ln3647">      }</a>
<a name="ln3648">      buf = lastbuf;</a>
<a name="ln3649">      while (buf-&gt;b_ml.ml_mfp == NULL) {</a>
<a name="ln3650">        if (buf-&gt;b_prev == NULL) {</a>
<a name="ln3651">          return _(e_invrange);</a>
<a name="ln3652">        }</a>
<a name="ln3653">        buf = buf-&gt;b_prev;</a>
<a name="ln3654">      }</a>
<a name="ln3655">      if (eap-&gt;line2 &gt; buf-&gt;b_fnum) {</a>
<a name="ln3656">        return _(e_invrange);</a>
<a name="ln3657">      }</a>
<a name="ln3658">      break;</a>
<a name="ln3659">    case ADDR_WINDOWS:</a>
<a name="ln3660">      if (eap-&gt;line2 &gt; LAST_WIN_NR) {</a>
<a name="ln3661">        return _(e_invrange);</a>
<a name="ln3662">      }</a>
<a name="ln3663">      break;</a>
<a name="ln3664">    case ADDR_TABS:</a>
<a name="ln3665">      if (eap-&gt;line2 &gt; LAST_TAB_NR) {</a>
<a name="ln3666">        return _(e_invrange);</a>
<a name="ln3667">      }</a>
<a name="ln3668">      break;</a>
<a name="ln3669">    case ADDR_TABS_RELATIVE:</a>
<a name="ln3670">    case ADDR_OTHER:</a>
<a name="ln3671">      // Any range is OK.</a>
<a name="ln3672">      break;</a>
<a name="ln3673">    case ADDR_QUICKFIX:</a>
<a name="ln3674">      assert(eap-&gt;line2 &gt;= 0);</a>
<a name="ln3675">      // No error for value that is too big, will use the last entry.</a>
<a name="ln3676">      if (eap-&gt;line2 &lt;= 0) {</a>
<a name="ln3677">        if (eap-&gt;addr_count == 0) {</a>
<a name="ln3678">          return _(e_no_errors);</a>
<a name="ln3679">        }</a>
<a name="ln3680">        return _(e_invrange);</a>
<a name="ln3681">      }</a>
<a name="ln3682">      break;</a>
<a name="ln3683">    case ADDR_QUICKFIX_VALID:</a>
<a name="ln3684">      if ((eap-&gt;line2 != 1 &amp;&amp; (size_t)eap-&gt;line2 &gt; qf_get_valid_size(eap))</a>
<a name="ln3685">          || eap-&gt;line2 &lt; 0) {</a>
<a name="ln3686">        return _(e_invrange);</a>
<a name="ln3687">      }</a>
<a name="ln3688">      break;</a>
<a name="ln3689">    case ADDR_UNSIGNED:</a>
<a name="ln3690">    case ADDR_NONE:</a>
<a name="ln3691">      // Will give an error elsewhere.</a>
<a name="ln3692">      break;</a>
<a name="ln3693">    }</a>
<a name="ln3694">  }</a>
<a name="ln3695">  return NULL;</a>
<a name="ln3696">}</a>
<a name="ln3697"> </a>
<a name="ln3698">/// Correct the range for zero line number, if required.</a>
<a name="ln3699">static void correct_range(exarg_T *eap)</a>
<a name="ln3700">{</a>
<a name="ln3701">  if (!(eap-&gt;argt &amp; EX_ZEROR)) {  // zero in range not allowed</a>
<a name="ln3702">    if (eap-&gt;line1 == 0) {</a>
<a name="ln3703">      eap-&gt;line1 = 1;</a>
<a name="ln3704">    }</a>
<a name="ln3705">    if (eap-&gt;line2 == 0) {</a>
<a name="ln3706">      eap-&gt;line2 = 1;</a>
<a name="ln3707">    }</a>
<a name="ln3708">  }</a>
<a name="ln3709">}</a>
<a name="ln3710"> </a>
<a name="ln3711">/// For a &quot;:vimgrep&quot; or &quot;:vimgrepadd&quot; command return a pointer past the</a>
<a name="ln3712">/// pattern.  Otherwise return eap-&gt;arg.</a>
<a name="ln3713">static char *skip_grep_pat(exarg_T *eap)</a>
<a name="ln3714">{</a>
<a name="ln3715">  char *p = eap-&gt;arg;</a>
<a name="ln3716"> </a>
<a name="ln3717">  if (*p != NUL &amp;&amp; (eap-&gt;cmdidx == CMD_vimgrep || eap-&gt;cmdidx == CMD_lvimgrep</a>
<a name="ln3718">                    || eap-&gt;cmdidx == CMD_vimgrepadd</a>
<a name="ln3719">                    || eap-&gt;cmdidx == CMD_lvimgrepadd</a>
<a name="ln3720">                    || grep_internal(eap-&gt;cmdidx))) {</a>
<a name="ln3721">    p = skip_vimgrep_pat(p, NULL, NULL);</a>
<a name="ln3722">    if (p == NULL) {</a>
<a name="ln3723">      p = eap-&gt;arg;</a>
<a name="ln3724">    }</a>
<a name="ln3725">  }</a>
<a name="ln3726">  return p;</a>
<a name="ln3727">}</a>
<a name="ln3728"> </a>
<a name="ln3729">/// For the &quot;:make&quot; and &quot;:grep&quot; commands insert the 'makeprg'/'grepprg' option</a>
<a name="ln3730">/// in the command line, so that things like % get expanded.</a>
<a name="ln3731">char *replace_makeprg(exarg_T *eap, char *arg, char **cmdlinep)</a>
<a name="ln3732">{</a>
<a name="ln3733">  bool isgrep = eap-&gt;cmdidx == CMD_grep</a>
<a name="ln3734">                || eap-&gt;cmdidx == CMD_lgrep</a>
<a name="ln3735">                || eap-&gt;cmdidx == CMD_grepadd</a>
<a name="ln3736">                || eap-&gt;cmdidx == CMD_lgrepadd;</a>
<a name="ln3737"> </a>
<a name="ln3738">  // Don't do it when &quot;:vimgrep&quot; is used for &quot;:grep&quot;.</a>
<a name="ln3739">  if ((eap-&gt;cmdidx == CMD_make || eap-&gt;cmdidx == CMD_lmake || isgrep)</a>
<a name="ln3740">      &amp;&amp; !grep_internal(eap-&gt;cmdidx)) {</a>
<a name="ln3741">    const char *program = isgrep ? (*curbuf-&gt;b_p_gp == NUL ? p_gp : curbuf-&gt;b_p_gp)</a>
<a name="ln3742">                                 : (*curbuf-&gt;b_p_mp == NUL ? p_mp : curbuf-&gt;b_p_mp);</a>
<a name="ln3743"> </a>
<a name="ln3744">    arg = skipwhite(arg);</a>
<a name="ln3745"> </a>
<a name="ln3746">    char *new_cmdline;</a>
<a name="ln3747">    // Replace $* by given arguments</a>
<a name="ln3748">    if ((new_cmdline = strrep(program, &quot;$*&quot;, arg)) == NULL) {</a>
<a name="ln3749">      // No $* in arg, build &quot;&lt;makeprg&gt; &lt;arg&gt;&quot; instead</a>
<a name="ln3750">      new_cmdline = xmalloc(strlen(program) + strlen(arg) + 2);</a>
<a name="ln3751">      STRCPY(new_cmdline, program);</a>
<a name="ln3752">      STRCAT(new_cmdline, &quot; &quot;);</a>
<a name="ln3753">      STRCAT(new_cmdline, arg);</a>
<a name="ln3754">    }</a>
<a name="ln3755"> </a>
<a name="ln3756">    msg_make(arg);</a>
<a name="ln3757"> </a>
<a name="ln3758">    // 'eap-&gt;cmd' is not set here, because it is not used at CMD_make</a>
<a name="ln3759">    xfree(*cmdlinep);</a>
<a name="ln3760">    *cmdlinep = new_cmdline;</a>
<a name="ln3761">    arg = new_cmdline;</a>
<a name="ln3762">  }</a>
<a name="ln3763">  return arg;</a>
<a name="ln3764">}</a>
<a name="ln3765"> </a>
<a name="ln3766">/// Expand file name in Ex command argument.</a>
<a name="ln3767">/// When an error is detected, &quot;errormsgp&quot; is set to a non-NULL pointer.</a>
<a name="ln3768">///</a>
<a name="ln3769">/// @return  FAIL for failure, OK otherwise.</a>
<a name="ln3770">int expand_filename(exarg_T *eap, char **cmdlinep, const char **errormsgp)</a>
<a name="ln3771">{</a>
<a name="ln3772">  // Skip a regexp pattern for &quot;:vimgrep[add] pat file...&quot;</a>
<a name="ln3773">  char *p = skip_grep_pat(eap);</a>
<a name="ln3774"> </a>
<a name="ln3775">  // Decide to expand wildcards *before* replacing '%', '#', etc.  If</a>
<a name="ln3776">  // the file name contains a wildcard it should not cause expanding.</a>
<a name="ln3777">  // (it will be expanded anyway if there is a wildcard before replacing).</a>
<a name="ln3778">  int has_wildcards = path_has_wildcard(p);</a>
<a name="ln3779">  while (*p != NUL) {</a>
<a name="ln3780">    // Skip over `=expr`, wildcards in it are not expanded.</a>
<a name="ln3781">    if (p[0] == '`' &amp;&amp; p[1] == '=') {</a>
<a name="ln3782">      p += 2;</a>
<a name="ln3783">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln3784">      if (*p == '`') {</a>
<a name="ln3785">        p++;</a>
<a name="ln3786">      }</a>
<a name="ln3787">      continue;</a>
<a name="ln3788">    }</a>
<a name="ln3789">    // Quick check if this cannot be the start of a special string.</a>
<a name="ln3790">    // Also removes backslash before '%', '#' and '&lt;'.</a>
<a name="ln3791">    if (vim_strchr(&quot;%#&lt;&quot;, (uint8_t)(*p)) == NULL) {</a>
<a name="ln3792">      p++;</a>
<a name="ln3793">      continue;</a>
<a name="ln3794">    }</a>
<a name="ln3795"> </a>
<a name="ln3796">    // Try to find a match at this position.</a>
<a name="ln3797">    size_t srclen;</a>
<a name="ln3798">    int escaped;</a>
<a name="ln3799">    char *repl = eval_vars(p, eap-&gt;arg, &amp;srclen, &amp;(eap-&gt;do_ecmd_lnum),</a>
<a name="ln3800">                           errormsgp, &amp;escaped, true);</a>
<a name="ln3801">    if (*errormsgp != NULL) {           // error detected</a>
<a name="ln3802">      return FAIL;</a>
<a name="ln3803">    }</a>
<a name="ln3804">    if (repl == NULL) {                 // no match found</a>
<a name="ln3805">      p += srclen;</a>
<a name="ln3806">      continue;</a>
<a name="ln3807">    }</a>
<a name="ln3808"> </a>
<a name="ln3809">    // Wildcards won't be expanded below, the replacement is taken</a>
<a name="ln3810">    // literally.  But do expand &quot;~/file&quot;, &quot;~user/file&quot; and &quot;$HOME/file&quot;.</a>
<a name="ln3811">    if (vim_strchr(repl, '$') != NULL || vim_strchr(repl, '~') != NULL) {</a>
<a name="ln3812">      char *l = repl;</a>
<a name="ln3813"> </a>
<a name="ln3814">      repl = expand_env_save(repl);</a>
<a name="ln3815">      xfree(l);</a>
<a name="ln3816">    }</a>
<a name="ln3817"> </a>
<a name="ln3818">    // Need to escape white space et al. with a backslash.</a>
<a name="ln3819">    // Don't do this for:</a>
<a name="ln3820">    // - replacement that already has been escaped: &quot;##&quot;</a>
<a name="ln3821">    // - shell commands (may have to use quotes instead).</a>
<a name="ln3822">    if (!eap-&gt;usefilter</a>
<a name="ln3823">        &amp;&amp; !escaped</a>
<a name="ln3824">        &amp;&amp; eap-&gt;cmdidx != CMD_bang</a>
<a name="ln3825">        &amp;&amp; eap-&gt;cmdidx != CMD_grep</a>
<a name="ln3826">        &amp;&amp; eap-&gt;cmdidx != CMD_grepadd</a>
<a name="ln3827">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrep</a>
<a name="ln3828">        &amp;&amp; eap-&gt;cmdidx != CMD_lgrepadd</a>
<a name="ln3829">        &amp;&amp; eap-&gt;cmdidx != CMD_lmake</a>
<a name="ln3830">        &amp;&amp; eap-&gt;cmdidx != CMD_make</a>
<a name="ln3831">        &amp;&amp; eap-&gt;cmdidx != CMD_terminal</a>
<a name="ln3832">        &amp;&amp; !(eap-&gt;argt &amp; EX_NOSPC)) {</a>
<a name="ln3833">      char *l;</a>
<a name="ln3834">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln3835">      // Don't escape a backslash here, because rem_backslash() doesn't</a>
<a name="ln3836">      // remove it later.</a>
<a name="ln3837">      static char *nobslash = &quot; \t\&quot;|&quot;;</a>
<a name="ln3838"># define ESCAPE_CHARS nobslash</a>
<a name="ln3839">#else</a>
<a name="ln3840"># define ESCAPE_CHARS escape_chars</a>
<a name="ln3841">#endif</a>
<a name="ln3842"> </a>
<a name="ln3843">      for (l = repl; *l; l++) {</a>
<a name="ln3844">        if (vim_strchr(ESCAPE_CHARS, (uint8_t)(*l)) != NULL) {</a>
<a name="ln3845">          l = vim_strsave_escaped(repl, ESCAPE_CHARS);</a>
<a name="ln3846">          xfree(repl);</a>
<a name="ln3847">          repl = l;</a>
<a name="ln3848">          break;</a>
<a name="ln3849">        }</a>
<a name="ln3850">      }</a>
<a name="ln3851">    }</a>
<a name="ln3852"> </a>
<a name="ln3853">    // For a shell command a '!' must be escaped.</a>
<a name="ln3854">    if ((eap-&gt;usefilter</a>
<a name="ln3855">         || eap-&gt;cmdidx == CMD_bang</a>
<a name="ln3856">         || eap-&gt;cmdidx == CMD_terminal)</a>
<a name="ln3857">        &amp;&amp; strpbrk(repl, &quot;!&quot;) != NULL) {</a>
<a name="ln3858">      char *l;</a>
<a name="ln3859"> </a>
<a name="ln3860">      l = vim_strsave_escaped(repl, &quot;!&quot;);</a>
<a name="ln3861">      xfree(repl);</a>
<a name="ln3862">      repl = l;</a>
<a name="ln3863">    }</a>
<a name="ln3864"> </a>
<a name="ln3865">    p = repl_cmdline(eap, p, srclen, repl, cmdlinep);</a>
<a name="ln3866">    xfree(repl);</a>
<a name="ln3867">  }</a>
<a name="ln3868"> </a>
<a name="ln3869">  // One file argument: Expand wildcards.</a>
<a name="ln3870">  // Don't do this with &quot;:r !command&quot; or &quot;:w !command&quot;.</a>
<a name="ln3871">  if ((eap-&gt;argt &amp; EX_NOSPC) &amp;&amp; !eap-&gt;usefilter) {</a>
<a name="ln3872">    // Replace environment variables.</a>
<a name="ln3873">    if (has_wildcards) {</a>
<a name="ln3874">      // May expand environment variables.  This</a>
<a name="ln3875">      // can be done much faster with expand_env() than with</a>
<a name="ln3876">      // something else (e.g., calling a shell).</a>
<a name="ln3877">      // After expanding environment variables, check again</a>
<a name="ln3878">      // if there are still wildcards present.</a>
<a name="ln3879">      if (vim_strchr(eap-&gt;arg, '$') != NULL</a>
<a name="ln3880">          || vim_strchr(eap-&gt;arg, '~') != NULL) {</a>
<a name="ln3881">        expand_env_esc(eap-&gt;arg, NameBuff, MAXPATHL, true, true, NULL);</a>
<a name="ln3882">        has_wildcards = path_has_wildcard(NameBuff);</a>
<a name="ln3883">        p = NameBuff;</a>
<a name="ln3884">      } else {</a>
<a name="ln3885">        p = NULL;</a>
<a name="ln3886">      }</a>
<a name="ln3887">      if (p != NULL) {</a>
<a name="ln3888">        (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3889">      }</a>
<a name="ln3890">    }</a>
<a name="ln3891"> </a>
<a name="ln3892">    // Halve the number of backslashes (this is Vi compatible).</a>
<a name="ln3893">    // For Unix, when wildcards are expanded, this is</a>
<a name="ln3894">    // done by ExpandOne() below.</a>
<a name="ln3895">#ifdef UNIX</a>
<a name="ln3896">    if (!has_wildcards) {</a>
<a name="ln3897">      backslash_halve(eap-&gt;arg);</a>
<a name="ln3898">    }</a>
<a name="ln3899">#else</a>
<a name="ln3900">    backslash_halve(eap-&gt;arg);</a>
<a name="ln3901">#endif</a>
<a name="ln3902"> </a>
<a name="ln3903">    if (has_wildcards) {</a>
<a name="ln3904">      expand_T xpc;</a>
<a name="ln3905">      int options = WILD_LIST_NOTFOUND | WILD_NOERROR | WILD_ADD_SLASH;</a>
<a name="ln3906"> </a>
<a name="ln3907">      ExpandInit(&amp;xpc);</a>
<a name="ln3908">      xpc.xp_context = EXPAND_FILES;</a>
<a name="ln3909">      if (p_wic) {</a>
<a name="ln3910">        options += WILD_ICASE;</a>
<a name="ln3911">      }</a>
<a name="ln3912">      p = ExpandOne(&amp;xpc, eap-&gt;arg, NULL, options, WILD_EXPAND_FREE);</a>
<a name="ln3913">      if (p == NULL) {</a>
<a name="ln3914">        return FAIL;</a>
<a name="ln3915">      }</a>
<a name="ln3916">      (void)repl_cmdline(eap, eap-&gt;arg, strlen(eap-&gt;arg), p, cmdlinep);</a>
<a name="ln3917">      xfree(p);</a>
<a name="ln3918">    }</a>
<a name="ln3919">  }</a>
<a name="ln3920">  return OK;</a>
<a name="ln3921">}</a>
<a name="ln3922"> </a>
<a name="ln3923">/// Replace part of the command line, keeping eap-&gt;cmd, eap-&gt;arg, eap-&gt;args and</a>
<a name="ln3924">/// eap-&gt;nextcmd correct.</a>
<a name="ln3925">/// &quot;src&quot; points to the part that is to be replaced, of length &quot;srclen&quot;.</a>
<a name="ln3926">/// &quot;repl&quot; is the replacement string.</a>
<a name="ln3927">///</a>
<a name="ln3928">/// @return  a pointer to the character after the replaced string.</a>
<a name="ln3929">static char *repl_cmdline(exarg_T *eap, char *src, size_t srclen, char *repl, char **cmdlinep)</a>
<a name="ln3930">{</a>
<a name="ln3931">  // The new command line is build in new_cmdline[].</a>
<a name="ln3932">  // First allocate it.</a>
<a name="ln3933">  // Careful: a &quot;+cmd&quot; argument may have been NUL terminated.</a>
<a name="ln3934">  size_t len = strlen(repl);</a>
<a name="ln3935">  size_t i = (size_t)(src - *cmdlinep) + strlen(src + srclen) + len + 3;</a>
<a name="ln3936">  if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln3937">    i += strlen(eap-&gt;nextcmd);    // add space for next command</a>
<a name="ln3938">  }</a>
<a name="ln3939">  char *new_cmdline = xmalloc(i);</a>
<a name="ln3940">  size_t offset = (size_t)(src - *cmdlinep);</a>
<a name="ln3941"> </a>
<a name="ln3942">  // Copy the stuff before the expanded part.</a>
<a name="ln3943">  // Copy the expanded stuff.</a>
<a name="ln3944">  // Copy what came after the expanded part.</a>
<a name="ln3945">  // Copy the next commands, if there are any.</a>
<a name="ln3946">  i = offset;   // length of part before match</a>
<a name="ln3947">  memmove(new_cmdline, *cmdlinep, i);</a>
<a name="ln3948"> </a>
<a name="ln3949">  memmove(new_cmdline + i, repl, len);</a>
<a name="ln3950">  i += len;                             // remember the end of the string</a>
<a name="ln3951">  STRCPY(new_cmdline + i, src + srclen);</a>
<a name="ln3952">  src = new_cmdline + i;                // remember where to continue</a>
<a name="ln3953"> </a>
<a name="ln3954">  if (eap-&gt;nextcmd != NULL) {           // append next command</a>
<a name="ln3955">    i = strlen(new_cmdline) + 1;</a>
<a name="ln3956">    STRCPY(new_cmdline + i, eap-&gt;nextcmd);</a>
<a name="ln3957">    eap-&gt;nextcmd = new_cmdline + i;</a>
<a name="ln3958">  }</a>
<a name="ln3959">  eap-&gt;cmd = new_cmdline + (eap-&gt;cmd - *cmdlinep);</a>
<a name="ln3960">  eap-&gt;arg = new_cmdline + (eap-&gt;arg - *cmdlinep);</a>
<a name="ln3961"> </a>
<a name="ln3962">  for (size_t j = 0; j &lt; eap-&gt;argc; j++) {</a>
<a name="ln3963">    if (offset &gt;= (size_t)(eap-&gt;args[j] - *cmdlinep)) {</a>
<a name="ln3964">      // If replaced text is after or in the same position as the argument,</a>
<a name="ln3965">      // the argument's position relative to the beginning of the cmdline stays the same.</a>
<a name="ln3966">      eap-&gt;args[j] = new_cmdline + (eap-&gt;args[j] - *cmdlinep);</a>
<a name="ln3967">    } else {</a>
<a name="ln3968">      // Otherwise, argument gets shifted alongside the replaced text.</a>
<a name="ln3969">      // The amount of the shift is equal to the difference of the old and new string length.</a>
<a name="ln3970">      eap-&gt;args[j] = new_cmdline + ((eap-&gt;args[j] - *cmdlinep) + (ptrdiff_t)(len - srclen));</a>
<a name="ln3971">    }</a>
<a name="ln3972">  }</a>
<a name="ln3973"> </a>
<a name="ln3974">  if (eap-&gt;do_ecmd_cmd != NULL &amp;&amp; eap-&gt;do_ecmd_cmd != dollar_command) {</a>
<a name="ln3975">    eap-&gt;do_ecmd_cmd = new_cmdline + (eap-&gt;do_ecmd_cmd - *cmdlinep);</a>
<a name="ln3976">  }</a>
<a name="ln3977">  xfree(*cmdlinep);</a>
<a name="ln3978">  *cmdlinep = new_cmdline;</a>
<a name="ln3979"> </a>
<a name="ln3980">  return src;</a>
<a name="ln3981">}</a>
<a name="ln3982"> </a>
<a name="ln3983">/// Check for '|' to separate commands and '&quot;' to start comments.</a>
<a name="ln3984">void separate_nextcmd(exarg_T *eap)</a>
<a name="ln3985">{</a>
<a name="ln3986">  char *p = skip_grep_pat(eap);</a>
<a name="ln3987"> </a>
<a name="ln3988">  for (; *p; MB_PTR_ADV(p)) {</a>
<a name="ln3989">    if (*p == Ctrl_V) {</a>
<a name="ln3990">      if (eap-&gt;argt &amp; (EX_CTRLV | EX_XFILE)) {</a>
<a name="ln3991">        p++;  // skip CTRL-V and next char</a>
<a name="ln3992">      } else {</a>
<a name="ln3993">        // remove CTRL-V and skip next char</a>
<a name="ln3994">        STRMOVE(p, p + 1);</a>
<a name="ln3995">      }</a>
<a name="ln3996">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln3997">        break;</a>
<a name="ln3998">      }</a>
<a name="ln3999">    } else if (p[0] == '`' &amp;&amp; p[1] == '=' &amp;&amp; (eap-&gt;argt &amp; EX_XFILE)) {</a>
<a name="ln4000">      // Skip over `=expr` when wildcards are expanded.</a>
<a name="ln4001">      p += 2;</a>
<a name="ln4002">      (void)skip_expr(&amp;p, NULL);</a>
<a name="ln4003">      if (*p == NUL) {  // stop at NUL after CTRL-V</a>
<a name="ln4004">        break;</a>
<a name="ln4005">      }</a>
<a name="ln4006">    } else if (</a>
<a name="ln4007">               // Check for '&quot;': start of comment or '|': next command */</a>
<a name="ln4008">               // :@&quot; does not start a comment!</a>
<a name="ln4009">               // :redir @&quot; doesn't either.</a>
<a name="ln4010">               (*p == '&quot;'</a>
<a name="ln4011">                &amp;&amp; !(eap-&gt;argt &amp; EX_NOTRLCOM)</a>
<a name="ln4012">                &amp;&amp; (eap-&gt;cmdidx != CMD_at || p != eap-&gt;arg)</a>
<a name="ln4013">                &amp;&amp; (eap-&gt;cmdidx != CMD_redir</a>
<a name="ln4014">                    || p != eap-&gt;arg + 1 || p[-1] != '@')) || *p == '|' || *p == '\n') {</a>
<a name="ln4015">      // We remove the '\' before the '|', unless EX_CTRLV is used</a>
<a name="ln4016">      // AND 'b' is present in 'cpoptions'.</a>
<a name="ln4017">      if ((vim_strchr(p_cpo, CPO_BAR) == NULL</a>
<a name="ln4018">           || !(eap-&gt;argt &amp; EX_CTRLV)) &amp;&amp; *(p - 1) == '\\') {</a>
<a name="ln4019">        STRMOVE(p - 1, p);  // remove the '\'</a>
<a name="ln4020">        p--;</a>
<a name="ln4021">      } else {</a>
<a name="ln4022">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln4023">        *p = NUL;</a>
<a name="ln4024">        break;</a>
<a name="ln4025">      }</a>
<a name="ln4026">    }</a>
<a name="ln4027">  }</a>
<a name="ln4028"> </a>
<a name="ln4029">  if (!(eap-&gt;argt &amp; EX_NOTRLCOM)) {  // remove trailing spaces</a>
<a name="ln4030">    del_trailing_spaces(eap-&gt;arg);</a>
<a name="ln4031">  }</a>
<a name="ln4032">}</a>
<a name="ln4033"> </a>
<a name="ln4034">/// get + command from ex argument</a>
<a name="ln4035">static char *getargcmd(char **argp)</a>
<a name="ln4036">{</a>
<a name="ln4037">  char *arg = *argp;</a>
<a name="ln4038">  char *command = NULL;</a>
<a name="ln4039"> </a>
<a name="ln4040">  if (*arg == '+') {        // +[command]</a>
<a name="ln4041">    arg++;</a>
<a name="ln4042">    if (ascii_isspace(*arg) || *arg == '\0') {</a>
<a name="ln4043">      command = dollar_command;</a>
<a name="ln4044">    } else {</a>
<a name="ln4045">      command = arg;</a>
<a name="ln4046">      arg = skip_cmd_arg(command, true);</a>
<a name="ln4047">      if (*arg != NUL) {</a>
<a name="ln4048">        *arg++ = NUL;                   // terminate command with NUL</a>
<a name="ln4049">      }</a>
<a name="ln4050">    }</a>
<a name="ln4051"> </a>
<a name="ln4052">    arg = skipwhite(arg);       // skip over spaces</a>
<a name="ln4053">    *argp = arg;</a>
<a name="ln4054">  }</a>
<a name="ln4055">  return command;</a>
<a name="ln4056">}</a>
<a name="ln4057"> </a>
<a name="ln4058">/// Find end of &quot;+command&quot; argument.  Skip over &quot;\ &quot; and &quot;\\&quot;.</a>
<a name="ln4059">///</a>
<a name="ln4060">/// @param rembs  true to halve the number of backslashes</a>
<a name="ln4061">char *skip_cmd_arg(char *p, int rembs)</a>
<a name="ln4062">{</a>
<a name="ln4063">  while (*p &amp;&amp; !ascii_isspace(*p)) {</a>
<a name="ln4064">    if (*p == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln4065">      if (rembs) {</a>
<a name="ln4066">        STRMOVE(p, p + 1);</a>
<a name="ln4067">      } else {</a>
<a name="ln4068">        p++;</a>
<a name="ln4069">      }</a>
<a name="ln4070">    }</a>
<a name="ln4071">    MB_PTR_ADV(p);</a>
<a name="ln4072">  }</a>
<a name="ln4073">  return p;</a>
<a name="ln4074">}</a>
<a name="ln4075"> </a>
<a name="ln4076">int get_bad_opt(const char *p, exarg_T *eap)</a>
<a name="ln4077">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln4078">{</a>
<a name="ln4079">  if (STRICMP(p, &quot;keep&quot;) == 0) {</a>
<a name="ln4080">    eap-&gt;bad_char = BAD_KEEP;</a>
<a name="ln4081">  } else if (STRICMP(p, &quot;drop&quot;) == 0) {</a>
<a name="ln4082">    eap-&gt;bad_char = BAD_DROP;</a>
<a name="ln4083">  } else if (MB_BYTE2LEN((uint8_t)(*p)) == 1 &amp;&amp; p[1] == NUL) {</a>
<a name="ln4084">    eap-&gt;bad_char = (uint8_t)(*p);</a>
<a name="ln4085">  } else {</a>
<a name="ln4086">    return FAIL;</a>
<a name="ln4087">  }</a>
<a name="ln4088">  return OK;</a>
<a name="ln4089">}</a>
<a name="ln4090"> </a>
<a name="ln4091">/// Get &quot;++opt=arg&quot; argument.</a>
<a name="ln4092">///</a>
<a name="ln4093">/// @return  FAIL or OK.</a>
<a name="ln4094">static int getargopt(exarg_T *eap)</a>
<a name="ln4095">{</a>
<a name="ln4096">  char *arg = eap-&gt;arg + 2;</a>
<a name="ln4097">  int *pp = NULL;</a>
<a name="ln4098">  int bad_char_idx;</a>
<a name="ln4099"> </a>
<a name="ln4100">  // &quot;:edit ++[no]bin[ary] file&quot;</a>
<a name="ln4101">  if (strncmp(arg, &quot;bin&quot;, 3) == 0 || strncmp(arg, &quot;nobin&quot;, 5) == 0) {</a>
<a name="ln4102">    if (*arg == 'n') {</a>
<a name="ln4103">      arg += 2;</a>
<a name="ln4104">      eap-&gt;force_bin = FORCE_NOBIN;</a>
<a name="ln4105">    } else {</a>
<a name="ln4106">      eap-&gt;force_bin = FORCE_BIN;</a>
<a name="ln4107">    }</a>
<a name="ln4108">    if (!checkforcmd(&amp;arg, &quot;binary&quot;, 3)) {</a>
<a name="ln4109">      return FAIL;</a>
<a name="ln4110">    }</a>
<a name="ln4111">    eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4112">    return OK;</a>
<a name="ln4113">  }</a>
<a name="ln4114"> </a>
<a name="ln4115">  // &quot;:read ++edit file&quot;</a>
<a name="ln4116">  if (strncmp(arg, &quot;edit&quot;, 4) == 0) {</a>
<a name="ln4117">    eap-&gt;read_edit = true;</a>
<a name="ln4118">    eap-&gt;arg = skipwhite(arg + 4);</a>
<a name="ln4119">    return OK;</a>
<a name="ln4120">  }</a>
<a name="ln4121"> </a>
<a name="ln4122">  // &quot;:write ++p foo/bar/file</a>
<a name="ln4123">  if (strncmp(arg, &quot;p&quot;, 1) == 0) {</a>
<a name="ln4124">    eap-&gt;mkdir_p = true;</a>
<a name="ln4125">    eap-&gt;arg = skipwhite(arg + 1);</a>
<a name="ln4126">    return OK;</a>
<a name="ln4127">  }</a>
<a name="ln4128"> </a>
<a name="ln4129">  if (strncmp(arg, &quot;ff&quot;, 2) == 0) {</a>
<a name="ln4130">    arg += 2;</a>
<a name="ln4131">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4132">  } else if (strncmp(arg, &quot;fileformat&quot;, 10) == 0) {</a>
<a name="ln4133">    arg += 10;</a>
<a name="ln4134">    pp = &amp;eap-&gt;force_ff;</a>
<a name="ln4135">  } else if (strncmp(arg, &quot;enc&quot;, 3) == 0) {</a>
<a name="ln4136">    if (strncmp(arg, &quot;encoding&quot;, 8) == 0) {</a>
<a name="ln4137">      arg += 8;</a>
<a name="ln4138">    } else {</a>
<a name="ln4139">      arg += 3;</a>
<a name="ln4140">    }</a>
<a name="ln4141">    pp = &amp;eap-&gt;force_enc;</a>
<a name="ln4142">  } else if (strncmp(arg, &quot;bad&quot;, 3) == 0) {</a>
<a name="ln4143">    arg += 3;</a>
<a name="ln4144">    pp = &amp;bad_char_idx;</a>
<a name="ln4145">  }</a>
<a name="ln4146"> </a>
<a name="ln4147">  if (pp == NULL || *arg != '=') {</a>
<a name="ln4148">    return FAIL;</a>
<a name="ln4149">  }</a>
<a name="ln4150"> </a>
<a name="ln4151">  arg++;</a>
<a name="ln4152">  *pp = (int)(arg - eap-&gt;cmd);</a>
<a name="ln4153">  arg = skip_cmd_arg(arg, false);</a>
<a name="ln4154">  eap-&gt;arg = skipwhite(arg);</a>
<a name="ln4155">  *arg = NUL;</a>
<a name="ln4156"> </a>
<a name="ln4157">  if (pp == &amp;eap-&gt;force_ff) {</a>
<a name="ln4158">    if (check_ff_value(eap-&gt;cmd + eap-&gt;force_ff) == FAIL) {</a>
<a name="ln4159">      return FAIL;</a>
<a name="ln4160">    }</a>
<a name="ln4161">    eap-&gt;force_ff = (uint8_t)eap-&gt;cmd[eap-&gt;force_ff];</a>
<a name="ln4162">  } else if (pp == &amp;eap-&gt;force_enc) {</a>
<a name="ln4163">    // Make 'fileencoding' lower case.</a>
<a name="ln4164">    for (char *p = eap-&gt;cmd + eap-&gt;force_enc; *p != NUL; p++) {</a>
<a name="ln4165">      *p = (char)TOLOWER_ASC(*p);</a>
<a name="ln4166">    }</a>
<a name="ln4167">  } else {</a>
<a name="ln4168">    // Check ++bad= argument.  Must be a single-byte character, &quot;keep&quot; or</a>
<a name="ln4169">    // &quot;drop&quot;.</a>
<a name="ln4170">    if (get_bad_opt(eap-&gt;cmd + bad_char_idx, eap) == FAIL) {</a>
<a name="ln4171">      return FAIL;</a>
<a name="ln4172">    }</a>
<a name="ln4173">  }</a>
<a name="ln4174"> </a>
<a name="ln4175">  return OK;</a>
<a name="ln4176">}</a>
<a name="ln4177"> </a>
<a name="ln4178">/// Handle the argument for a tabpage related ex command.</a>
<a name="ln4179">/// When an error is encountered then eap-&gt;errmsg is set.</a>
<a name="ln4180">///</a>
<a name="ln4181">/// @return  a tabpage number.</a>
<a name="ln4182">static int get_tabpage_arg(exarg_T *eap)</a>
<a name="ln4183">{</a>
<a name="ln4184">  int tab_number = 0;</a>
<a name="ln4185">  int unaccept_arg0 = (eap-&gt;cmdidx == CMD_tabmove) ? 0 : 1;</a>
<a name="ln4186"> </a>
<a name="ln4187">  if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln4188">    char *p = eap-&gt;arg;</a>
<a name="ln4189">    int relative = 0;  // argument +N/-N means: go to N places to the</a>
<a name="ln4190">                       // right/left relative to the current position.</a>
<a name="ln4191"> </a>
<a name="ln4192">    if (*p == '-') {</a>
<a name="ln4193">      relative = -1;</a>
<a name="ln4194">      p++;</a>
<a name="ln4195">    } else if (*p == '+') {</a>
<a name="ln4196">      relative = 1;</a>
<a name="ln4197">      p++;</a>
<a name="ln4198">    }</a>
<a name="ln4199"> </a>
<a name="ln4200">    char *p_save = p;</a>
<a name="ln4201">    tab_number = (int)getdigits(&amp;p, false, tab_number);</a>
<a name="ln4202"> </a>
<a name="ln4203">    if (relative == 0) {</a>
<a name="ln4204">      if (strcmp(p, &quot;$&quot;) == 0) {</a>
<a name="ln4205">        tab_number = LAST_TAB_NR;</a>
<a name="ln4206">      } else if (strcmp(p, &quot;#&quot;) == 0) {</a>
<a name="ln4207">        if (valid_tabpage(lastused_tabpage)) {</a>
<a name="ln4208">          tab_number = tabpage_index(lastused_tabpage);</a>
<a name="ln4209">        } else {</a>
<a name="ln4210">          eap-&gt;errmsg = ex_errmsg(e_invargval, eap-&gt;arg);</a>
<a name="ln4211">          tab_number = 0;</a>
<a name="ln4212">          goto theend;</a>
<a name="ln4213">        }</a>
<a name="ln4214">      } else if (p == p_save || *p_save == '-' || *p != NUL</a>
<a name="ln4215">                 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4216">        // No numbers as argument.</a>
<a name="ln4217">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4218">        goto theend;</a>
<a name="ln4219">      }</a>
<a name="ln4220">    } else {</a>
<a name="ln4221">      if (*p_save == NUL) {</a>
<a name="ln4222">        tab_number = 1;</a>
<a name="ln4223">      } else if (p == p_save || *p_save == '-' || *p != NUL || tab_number == 0) {</a>
<a name="ln4224">        // No numbers as argument.</a>
<a name="ln4225">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4226">        goto theend;</a>
<a name="ln4227">      }</a>
<a name="ln4228">      tab_number = tab_number * relative + tabpage_index(curtab);</a>
<a name="ln4229">      if (!unaccept_arg0 &amp;&amp; relative == -1) {</a>
<a name="ln4230">        tab_number--;</a>
<a name="ln4231">      }</a>
<a name="ln4232">    }</a>
<a name="ln4233">    if (tab_number &lt; unaccept_arg0 || tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4234">      eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln4235">    }</a>
<a name="ln4236">  } else if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4237">    if (unaccept_arg0 &amp;&amp; eap-&gt;line2 == 0) {</a>
<a name="ln4238">      eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4239">      tab_number = 0;</a>
<a name="ln4240">    } else {</a>
<a name="ln4241">      tab_number = (int)eap-&gt;line2;</a>
<a name="ln4242">      char *cmdp = eap-&gt;cmd;</a>
<a name="ln4243">      while (--cmdp &gt; *eap-&gt;cmdlinep &amp;&amp; (*cmdp == ' ' || ascii_isdigit(*cmdp))) {}</a>
<a name="ln4244">      if (!unaccept_arg0 &amp;&amp; *cmdp == '-') {</a>
<a name="ln4245">        tab_number--;</a>
<a name="ln4246">        if (tab_number &lt; unaccept_arg0) {</a>
<a name="ln4247">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln4248">        }</a>
<a name="ln4249">      }</a>
<a name="ln4250">    }</a>
<a name="ln4251">  } else {</a>
<a name="ln4252">    switch (eap-&gt;cmdidx) {</a>
<a name="ln4253">    case CMD_tabnext:</a>
<a name="ln4254">      tab_number = tabpage_index(curtab) + 1;</a>
<a name="ln4255">      if (tab_number &gt; LAST_TAB_NR) {</a>
<a name="ln4256">        tab_number = 1;</a>
<a name="ln4257">      }</a>
<a name="ln4258">      break;</a>
<a name="ln4259">    case CMD_tabmove:</a>
<a name="ln4260">      tab_number = LAST_TAB_NR;</a>
<a name="ln4261">      break;</a>
<a name="ln4262">    default:</a>
<a name="ln4263">      tab_number = tabpage_index(curtab);</a>
<a name="ln4264">    }</a>
<a name="ln4265">  }</a>
<a name="ln4266"> </a>
<a name="ln4267">theend:</a>
<a name="ln4268">  return tab_number;</a>
<a name="ln4269">}</a>
<a name="ln4270"> </a>
<a name="ln4271">static void ex_autocmd(exarg_T *eap)</a>
<a name="ln4272">{</a>
<a name="ln4273">  // Disallow autocommands in secure mode.</a>
<a name="ln4274">  if (secure) {</a>
<a name="ln4275">    secure = 2;</a>
<a name="ln4276">    eap-&gt;errmsg = _(e_curdir);</a>
<a name="ln4277">  } else if (eap-&gt;cmdidx == CMD_autocmd) {</a>
<a name="ln4278">    do_autocmd(eap, eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4279">  } else {</a>
<a name="ln4280">    do_augroup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln4281">  }</a>
<a name="ln4282">}</a>
<a name="ln4283"> </a>
<a name="ln4284">/// &quot;:doautocmd&quot;: Apply the automatic commands to the current buffer.</a>
<a name="ln4285">static void ex_doautocmd(exarg_T *eap)</a>
<a name="ln4286">{</a>
<a name="ln4287">  char *arg = eap-&gt;arg;</a>
<a name="ln4288">  int call_do_modelines = check_nomodeline(&amp;arg);</a>
<a name="ln4289">  bool did_aucmd;</a>
<a name="ln4290"> </a>
<a name="ln4291">  (void)do_doautocmd(arg, false, &amp;did_aucmd);</a>
<a name="ln4292">  // Only when there is no &lt;nomodeline&gt;.</a>
<a name="ln4293">  if (call_do_modelines &amp;&amp; did_aucmd) {</a>
<a name="ln4294">    do_modelines(0);</a>
<a name="ln4295">  }</a>
<a name="ln4296">}</a>
<a name="ln4297"> </a>
<a name="ln4298">/// :[N]bunload[!] [N] [bufname] unload buffer</a>
<a name="ln4299">/// :[N]bdelete[!] [N] [bufname] delete buffer from buffer list</a>
<a name="ln4300">/// :[N]bwipeout[!] [N] [bufname] delete buffer really</a>
<a name="ln4301">static void ex_bunload(exarg_T *eap)</a>
<a name="ln4302">{</a>
<a name="ln4303">  eap-&gt;errmsg = do_bufdel(eap-&gt;cmdidx == CMD_bdelete</a>
<a name="ln4304">                          ? DOBUF_DEL</a>
<a name="ln4305">                          : eap-&gt;cmdidx == CMD_bwipeout</a>
<a name="ln4306">                          ? DOBUF_WIPE</a>
<a name="ln4307">                          : DOBUF_UNLOAD,</a>
<a name="ln4308">                          eap-&gt;arg, eap-&gt;addr_count, (int)eap-&gt;line1, (int)eap-&gt;line2,</a>
<a name="ln4309">                          eap-&gt;forceit);</a>
<a name="ln4310">}</a>
<a name="ln4311"> </a>
<a name="ln4312">/// :[N]buffer [N]       to buffer N</a>
<a name="ln4313">/// :[N]sbuffer [N]      to buffer N</a>
<a name="ln4314">static void ex_buffer(exarg_T *eap)</a>
<a name="ln4315">{</a>
<a name="ln4316">  if (*eap-&gt;arg) {</a>
<a name="ln4317">    eap-&gt;errmsg = ex_errmsg(e_trailing_arg, eap-&gt;arg);</a>
<a name="ln4318">  } else {</a>
<a name="ln4319">    if (eap-&gt;addr_count == 0) {  // default is current buffer</a>
<a name="ln4320">      goto_buffer(eap, DOBUF_CURRENT, FORWARD, 0);</a>
<a name="ln4321">    } else {</a>
<a name="ln4322">      goto_buffer(eap, DOBUF_FIRST, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4323">    }</a>
<a name="ln4324">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4325">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4326">    }</a>
<a name="ln4327">  }</a>
<a name="ln4328">}</a>
<a name="ln4329"> </a>
<a name="ln4330">/// :[N]bmodified [N]    to next mod. buffer</a>
<a name="ln4331">/// :[N]sbmodified [N]   to next mod. buffer</a>
<a name="ln4332">static void ex_bmodified(exarg_T *eap)</a>
<a name="ln4333">{</a>
<a name="ln4334">  goto_buffer(eap, DOBUF_MOD, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4335">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4336">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4337">  }</a>
<a name="ln4338">}</a>
<a name="ln4339"> </a>
<a name="ln4340">/// :[N]bnext [N]        to next buffer</a>
<a name="ln4341">/// :[N]sbnext [N]       split and to next buffer</a>
<a name="ln4342">static void ex_bnext(exarg_T *eap)</a>
<a name="ln4343">{</a>
<a name="ln4344">  goto_buffer(eap, DOBUF_CURRENT, FORWARD, (int)eap-&gt;line2);</a>
<a name="ln4345">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4346">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4347">  }</a>
<a name="ln4348">}</a>
<a name="ln4349"> </a>
<a name="ln4350">/// :[N]bNext [N]        to previous buffer</a>
<a name="ln4351">/// :[N]bprevious [N]    to previous buffer</a>
<a name="ln4352">/// :[N]sbNext [N]       split and to previous buffer</a>
<a name="ln4353">/// :[N]sbprevious [N]   split and to previous buffer</a>
<a name="ln4354">static void ex_bprevious(exarg_T *eap)</a>
<a name="ln4355">{</a>
<a name="ln4356">  goto_buffer(eap, DOBUF_CURRENT, BACKWARD, (int)eap-&gt;line2);</a>
<a name="ln4357">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4358">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4359">  }</a>
<a name="ln4360">}</a>
<a name="ln4361"> </a>
<a name="ln4362">/// :brewind             to first buffer</a>
<a name="ln4363">/// :bfirst              to first buffer</a>
<a name="ln4364">/// :sbrewind            split and to first buffer</a>
<a name="ln4365">/// :sbfirst             split and to first buffer</a>
<a name="ln4366">static void ex_brewind(exarg_T *eap)</a>
<a name="ln4367">{</a>
<a name="ln4368">  goto_buffer(eap, DOBUF_FIRST, FORWARD, 0);</a>
<a name="ln4369">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4370">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4371">  }</a>
<a name="ln4372">}</a>
<a name="ln4373"> </a>
<a name="ln4374">/// :blast               to last buffer</a>
<a name="ln4375">/// :sblast              split and to last buffer</a>
<a name="ln4376">static void ex_blast(exarg_T *eap)</a>
<a name="ln4377">{</a>
<a name="ln4378">  goto_buffer(eap, DOBUF_LAST, BACKWARD, 0);</a>
<a name="ln4379">  if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln4380">    do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln4381">  }</a>
<a name="ln4382">}</a>
<a name="ln4383"> </a>
<a name="ln4384">int ends_excmd(int c) FUNC_ATTR_CONST</a>
<a name="ln4385">{</a>
<a name="ln4386">  return c == NUL || c == '|' || c == '&quot;' || c == '\n';</a>
<a name="ln4387">}</a>
<a name="ln4388"> </a>
<a name="ln4389">/// @return  the next command, after the first '|' or '\n' or,</a>
<a name="ln4390">///          NULL if not found.</a>
<a name="ln4391">char *find_nextcmd(const char *p)</a>
<a name="ln4392">{</a>
<a name="ln4393">  while (*p != '|' &amp;&amp; *p != '\n') {</a>
<a name="ln4394">    if (*p == NUL) {</a>
<a name="ln4395">      return NULL;</a>
<a name="ln4396">    }</a>
<a name="ln4397">    p++;</a>
<a name="ln4398">  }</a>
<a name="ln4399">  return (char *)p + 1;</a>
<a name="ln4400">}</a>
<a name="ln4401"> </a>
<a name="ln4402">/// Check if *p is a separator between Ex commands, skipping over white space.</a>
<a name="ln4403">///</a>
<a name="ln4404">/// @return  NULL if it isn't, the following character if it is.</a>
<a name="ln4405">char *check_nextcmd(char *p)</a>
<a name="ln4406">{</a>
<a name="ln4407">  char *s = skipwhite(p);</a>
<a name="ln4408"> </a>
<a name="ln4409">  if (*s == '|' || *s == '\n') {</a>
<a name="ln4410">    return s + 1;</a>
<a name="ln4411">  }</a>
<a name="ln4412">  return NULL;</a>
<a name="ln4413">}</a>
<a name="ln4414"> </a>
<a name="ln4415">/// - if there are more files to edit</a>
<a name="ln4416">/// - and this is the last window</a>
<a name="ln4417">/// - and forceit not used</a>
<a name="ln4418">/// - and not repeated twice on a row</a>
<a name="ln4419">///</a>
<a name="ln4420">/// @param   message  when false check only, no messages</a>
<a name="ln4421">///</a>
<a name="ln4422">/// @return  FAIL and give error message if 'message' true, return OK otherwise</a>
<a name="ln4423">static int check_more(int message, bool forceit)</a>
<a name="ln4424">{</a>
<a name="ln4425">  int n = ARGCOUNT - curwin-&gt;w_arg_idx - 1;</a>
<a name="ln4426"> </a>
<a name="ln4427">  if (!forceit &amp;&amp; only_one_window()</a>
<a name="ln4428">      &amp;&amp; ARGCOUNT &gt; 1 &amp;&amp; !arg_had_last &amp;&amp; n &gt; 0 &amp;&amp; quitmore == 0) {</a>
<a name="ln4429">    if (message) {</a>
<a name="ln4430">      if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; curbuf-&gt;b_fname != NULL) {</a>
<a name="ln4431">        char buff[DIALOG_MSG_SIZE];</a>
<a name="ln4432"> </a>
<a name="ln4433">        vim_snprintf(buff, DIALOG_MSG_SIZE,</a>
<a name="ln4434">                     NGETTEXT(&quot;%d more file to edit.  Quit anyway?&quot;,</a>
<a name="ln4435">                              &quot;%d more files to edit.  Quit anyway?&quot;, n), n);</a>
<a name="ln4436">        if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES) {</a>
<a name="ln4437">          return OK;</a>
<a name="ln4438">        }</a>
<a name="ln4439">        return FAIL;</a>
<a name="ln4440">      }</a>
<a name="ln4441">      semsg(NGETTEXT(&quot;E173: %&quot; PRId64 &quot; more file to edit&quot;,</a>
<a name="ln4442">                     &quot;E173: %&quot; PRId64 &quot; more files to edit&quot;, n), (int64_t)n);</a>
<a name="ln4443">      quitmore = 2;                 // next try to quit is allowed</a>
<a name="ln4444">    }</a>
<a name="ln4445">    return FAIL;</a>
<a name="ln4446">  }</a>
<a name="ln4447">  return OK;</a>
<a name="ln4448">}</a>
<a name="ln4449"> </a>
<a name="ln4450">/// Function given to ExpandGeneric() to obtain the list of command names.</a>
<a name="ln4451">char *get_command_name(expand_T *xp, int idx)</a>
<a name="ln4452">{</a>
<a name="ln4453">  if (idx &gt;= CMD_SIZE) {</a>
<a name="ln4454">    return expand_user_command_name(idx);</a>
<a name="ln4455">  }</a>
<a name="ln4456">  return cmdnames[idx].cmd_name;</a>
<a name="ln4457">}</a>
<a name="ln4458"> </a>
<a name="ln4459">static void ex_colorscheme(exarg_T *eap)</a>
<a name="ln4460">{</a>
<a name="ln4461">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln4462">    char *expr = xstrdup(&quot;g:colors_name&quot;);</a>
<a name="ln4463"> </a>
<a name="ln4464">    emsg_off++;</a>
<a name="ln4465">    char *p = eval_to_string(expr, false);</a>
<a name="ln4466">    emsg_off--;</a>
<a name="ln4467">    xfree(expr);</a>
<a name="ln4468"> </a>
<a name="ln4469">    if (p != NULL) {</a>
<a name="ln4470">      msg(p);</a>
<a name="ln4471">      xfree(p);</a>
<a name="ln4472">    } else {</a>
<a name="ln4473">      msg(&quot;default&quot;);</a>
<a name="ln4474">    }</a>
<a name="ln4475">  } else if (load_colors(eap-&gt;arg) == FAIL) {</a>
<a name="ln4476">    semsg(_(&quot;E185: Cannot find color scheme '%s'&quot;), eap-&gt;arg);</a>
<a name="ln4477">  }</a>
<a name="ln4478">}</a>
<a name="ln4479"> </a>
<a name="ln4480">static void ex_highlight(exarg_T *eap)</a>
<a name="ln4481">{</a>
<a name="ln4482">  if (*eap-&gt;arg == NUL &amp;&amp; eap-&gt;cmd[2] == '!') {</a>
<a name="ln4483">    msg(_(&quot;Greetings, Vim user!&quot;));</a>
<a name="ln4484">  }</a>
<a name="ln4485">  do_highlight(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln4486">}</a>
<a name="ln4487"> </a>
<a name="ln4488">/// Call this function if we thought we were going to exit, but we won't</a>
<a name="ln4489">/// (because of an error).  May need to restore the terminal mode.</a>
<a name="ln4490">void not_exiting(void)</a>
<a name="ln4491">{</a>
<a name="ln4492">  exiting = false;</a>
<a name="ln4493">}</a>
<a name="ln4494"> </a>
<a name="ln4495">bool before_quit_autocmds(win_T *wp, bool quit_all, bool forceit)</a>
<a name="ln4496">{</a>
<a name="ln4497">  apply_autocmds(EVENT_QUITPRE, NULL, NULL, false, wp-&gt;w_buffer);</a>
<a name="ln4498"> </a>
<a name="ln4499">  // Bail out when autocommands closed the window.</a>
<a name="ln4500">  // Refuse to quit when the buffer in the last window is being closed (can</a>
<a name="ln4501">  // only happen in autocommands).</a>
<a name="ln4502">  if (!win_valid(wp)</a>
<a name="ln4503">      || curbuf_locked()</a>
<a name="ln4504">      || (wp-&gt;w_buffer-&gt;b_nwindows == 1 &amp;&amp; wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln4505">    return true;</a>
<a name="ln4506">  }</a>
<a name="ln4507"> </a>
<a name="ln4508">  if (quit_all</a>
<a name="ln4509">      || (check_more(false, forceit) == OK &amp;&amp; only_one_window())) {</a>
<a name="ln4510">    apply_autocmds(EVENT_EXITPRE, NULL, NULL, false, curbuf);</a>
<a name="ln4511">    // Refuse to quit when locked or when the window was closed or the</a>
<a name="ln4512">    // buffer in the last window is being closed (can only happen in</a>
<a name="ln4513">    // autocommands).</a>
<a name="ln4514">    if (!win_valid(wp)</a>
<a name="ln4515">        || curbuf_locked()</a>
<a name="ln4516">        || (curbuf-&gt;b_nwindows == 1 &amp;&amp; curbuf-&gt;b_locked &gt; 0)) {</a>
<a name="ln4517">      return true;</a>
<a name="ln4518">    }</a>
<a name="ln4519">  }</a>
<a name="ln4520"> </a>
<a name="ln4521">  return false;</a>
<a name="ln4522">}</a>
<a name="ln4523"> </a>
<a name="ln4524">/// &quot;:quit&quot;: quit current window, quit Vim if the last window is closed.</a>
<a name="ln4525">/// &quot;:{nr}quit&quot;: quit window {nr}</a>
<a name="ln4526">static void ex_quit(exarg_T *eap)</a>
<a name="ln4527">{</a>
<a name="ln4528">  if (cmdwin_type != 0) {</a>
<a name="ln4529">    cmdwin_result = Ctrl_C;</a>
<a name="ln4530">    return;</a>
<a name="ln4531">  }</a>
<a name="ln4532">  // Don't quit while editing the command line.</a>
<a name="ln4533">  if (text_locked()) {</a>
<a name="ln4534">    text_locked_msg();</a>
<a name="ln4535">    return;</a>
<a name="ln4536">  }</a>
<a name="ln4537"> </a>
<a name="ln4538">  win_T *wp;</a>
<a name="ln4539"> </a>
<a name="ln4540">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4541">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4542"> </a>
<a name="ln4543">    for (wp = firstwin; wp-&gt;w_next != NULL; wp = wp-&gt;w_next) {</a>
<a name="ln4544">      if (--wnr &lt;= 0) {</a>
<a name="ln4545">        break;</a>
<a name="ln4546">      }</a>
<a name="ln4547">    }</a>
<a name="ln4548">  } else {</a>
<a name="ln4549">    wp = curwin;</a>
<a name="ln4550">  }</a>
<a name="ln4551"> </a>
<a name="ln4552">  // Refuse to quit when locked.</a>
<a name="ln4553">  if (curbuf_locked()) {</a>
<a name="ln4554">    return;</a>
<a name="ln4555">  }</a>
<a name="ln4556"> </a>
<a name="ln4557">  // Trigger QuitPre and maybe ExitPre</a>
<a name="ln4558">  if (before_quit_autocmds(wp, false, eap-&gt;forceit)) {</a>
<a name="ln4559">    return;</a>
<a name="ln4560">  }</a>
<a name="ln4561"> </a>
<a name="ln4562">  // If there is only one relevant window we will exit.</a>
<a name="ln4563">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4564">    exiting = true;</a>
<a name="ln4565">  }</a>
<a name="ln4566">  if ((!buf_hide(wp-&gt;w_buffer)</a>
<a name="ln4567">       &amp;&amp; check_changed(wp-&gt;w_buffer, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4568">                        | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4569">                        | CCGD_EXCMD))</a>
<a name="ln4570">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4571">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, true))) {</a>
<a name="ln4572">    not_exiting();</a>
<a name="ln4573">  } else {</a>
<a name="ln4574">    // quit last window</a>
<a name="ln4575">    // Note: only_one_window() returns true, even so a help window is</a>
<a name="ln4576">    // still open. In that case only quit, if no address has been</a>
<a name="ln4577">    // specified. Example:</a>
<a name="ln4578">    // :h|wincmd w|1q     - don't quit</a>
<a name="ln4579">    // :h|wincmd w|q      - quit</a>
<a name="ln4580">    if (only_one_window() &amp;&amp; (ONE_WINDOW || eap-&gt;addr_count == 0)) {</a>
<a name="ln4581">      getout(0);</a>
<a name="ln4582">    }</a>
<a name="ln4583">    not_exiting();</a>
<a name="ln4584">    // close window; may free buffer</a>
<a name="ln4585">    win_close(wp, !buf_hide(wp-&gt;w_buffer) || eap-&gt;forceit, eap-&gt;forceit);</a>
<a name="ln4586">  }</a>
<a name="ln4587">}</a>
<a name="ln4588"> </a>
<a name="ln4589">/// &quot;:cquit&quot;.</a>
<a name="ln4590">static void ex_cquit(exarg_T *eap)</a>
<a name="ln4591">  FUNC_ATTR_NORETURN</a>
<a name="ln4592">{</a>
<a name="ln4593">  // this does not always pass on the exit code to the Manx compiler. why?</a>
<a name="ln4594">  getout(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : EXIT_FAILURE);</a>
<a name="ln4595">}</a>
<a name="ln4596"> </a>
<a name="ln4597">/// Do preparations for &quot;qall&quot; and &quot;wqall&quot;.</a>
<a name="ln4598">/// Returns FAIL when quitting should be aborted.</a>
<a name="ln4599">int before_quit_all(exarg_T *eap)</a>
<a name="ln4600">{</a>
<a name="ln4601">  if (cmdwin_type != 0) {</a>
<a name="ln4602">    if (eap-&gt;forceit) {</a>
<a name="ln4603">      cmdwin_result = K_XF1;            // open_cmdwin() takes care of this</a>
<a name="ln4604">    } else {</a>
<a name="ln4605">      cmdwin_result = K_XF2;</a>
<a name="ln4606">    }</a>
<a name="ln4607">    return FAIL;</a>
<a name="ln4608">  }</a>
<a name="ln4609"> </a>
<a name="ln4610">  // Don't quit while editing the command line.</a>
<a name="ln4611">  if (text_locked()) {</a>
<a name="ln4612">    text_locked_msg();</a>
<a name="ln4613">    return FAIL;</a>
<a name="ln4614">  }</a>
<a name="ln4615"> </a>
<a name="ln4616">  if (before_quit_autocmds(curwin, true, eap-&gt;forceit)) {</a>
<a name="ln4617">    return FAIL;</a>
<a name="ln4618">  }</a>
<a name="ln4619"> </a>
<a name="ln4620">  return OK;</a>
<a name="ln4621">}</a>
<a name="ln4622"> </a>
<a name="ln4623">/// &quot;:qall&quot;: try to quit all windows</a>
<a name="ln4624">static void ex_quit_all(exarg_T *eap)</a>
<a name="ln4625">{</a>
<a name="ln4626">  if (before_quit_all(eap) == FAIL) {</a>
<a name="ln4627">    return;</a>
<a name="ln4628">  }</a>
<a name="ln4629">  exiting = true;</a>
<a name="ln4630">  if (eap-&gt;forceit || !check_changed_any(false, false)) {</a>
<a name="ln4631">    getout(0);</a>
<a name="ln4632">  }</a>
<a name="ln4633">  not_exiting();</a>
<a name="ln4634">}</a>
<a name="ln4635"> </a>
<a name="ln4636">/// &quot;:close&quot;: close current window, unless it is the last one</a>
<a name="ln4637">static void ex_close(exarg_T *eap)</a>
<a name="ln4638">{</a>
<a name="ln4639">  win_T *win = NULL;</a>
<a name="ln4640">  int winnr = 0;</a>
<a name="ln4641">  if (cmdwin_type != 0) {</a>
<a name="ln4642">    cmdwin_result = Ctrl_C;</a>
<a name="ln4643">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4644">    if (eap-&gt;addr_count == 0) {</a>
<a name="ln4645">      ex_win_close(eap-&gt;forceit, curwin, NULL);</a>
<a name="ln4646">    } else {</a>
<a name="ln4647">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4648">        winnr++;</a>
<a name="ln4649">        if (winnr == eap-&gt;line2) {</a>
<a name="ln4650">          win = wp;</a>
<a name="ln4651">          break;</a>
<a name="ln4652">        }</a>
<a name="ln4653">      }</a>
<a name="ln4654">      if (win == NULL) {</a>
<a name="ln4655">        win = lastwin;</a>
<a name="ln4656">      }</a>
<a name="ln4657">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4658">    }</a>
<a name="ln4659">  }</a>
<a name="ln4660">}</a>
<a name="ln4661"> </a>
<a name="ln4662">/// &quot;:pclose&quot;: Close any preview window.</a>
<a name="ln4663">static void ex_pclose(exarg_T *eap)</a>
<a name="ln4664">{</a>
<a name="ln4665">  FOR_ALL_WINDOWS_IN_TAB(win, curtab) {</a>
<a name="ln4666">    if (win-&gt;w_p_pvw) {</a>
<a name="ln4667">      ex_win_close(eap-&gt;forceit, win, NULL);</a>
<a name="ln4668">      break;</a>
<a name="ln4669">    }</a>
<a name="ln4670">  }</a>
<a name="ln4671">}</a>
<a name="ln4672"> </a>
<a name="ln4673">/// Close window &quot;win&quot; and take care of handling closing the last window for a</a>
<a name="ln4674">/// modified buffer.</a>
<a name="ln4675">///</a>
<a name="ln4676">/// @param tp  NULL or the tab page &quot;win&quot; is in</a>
<a name="ln4677">void ex_win_close(int forceit, win_T *win, tabpage_T *tp)</a>
<a name="ln4678">{</a>
<a name="ln4679">  // Never close the autocommand window.</a>
<a name="ln4680">  if (is_aucmd_win(win)) {</a>
<a name="ln4681">    emsg(_(e_autocmd_close));</a>
<a name="ln4682">    return;</a>
<a name="ln4683">  }</a>
<a name="ln4684"> </a>
<a name="ln4685">  buf_T *buf = win-&gt;w_buffer;</a>
<a name="ln4686"> </a>
<a name="ln4687">  bool need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln4688">  if (need_hide &amp;&amp; !buf_hide(buf) &amp;&amp; !forceit) {</a>
<a name="ln4689">    if ((p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; p_write) {</a>
<a name="ln4690">      bufref_T bufref;</a>
<a name="ln4691">      set_bufref(&amp;bufref, buf);</a>
<a name="ln4692">      dialog_changed(buf, false);</a>
<a name="ln4693">      if (bufref_valid(&amp;bufref) &amp;&amp; bufIsChanged(buf)) {</a>
<a name="ln4694">        return;</a>
<a name="ln4695">      }</a>
<a name="ln4696">      need_hide = false;</a>
<a name="ln4697">    } else {</a>
<a name="ln4698">      no_write_message();</a>
<a name="ln4699">      return;</a>
<a name="ln4700">    }</a>
<a name="ln4701">  }</a>
<a name="ln4702"> </a>
<a name="ln4703">  // free buffer when not hiding it or when it's a scratch buffer</a>
<a name="ln4704">  if (tp == NULL) {</a>
<a name="ln4705">    win_close(win, !need_hide &amp;&amp; !buf_hide(buf), forceit);</a>
<a name="ln4706">  } else {</a>
<a name="ln4707">    win_close_othertab(win, !need_hide &amp;&amp; !buf_hide(buf), tp);</a>
<a name="ln4708">  }</a>
<a name="ln4709">}</a>
<a name="ln4710"> </a>
<a name="ln4711">/// &quot;:tabclose&quot;: close current tab page, unless it is the last one.</a>
<a name="ln4712">/// &quot;:tabclose N&quot;: close tab page N.</a>
<a name="ln4713">static void ex_tabclose(exarg_T *eap)</a>
<a name="ln4714">{</a>
<a name="ln4715">  if (cmdwin_type != 0) {</a>
<a name="ln4716">    cmdwin_result = K_IGNORE;</a>
<a name="ln4717">    return;</a>
<a name="ln4718">  }</a>
<a name="ln4719"> </a>
<a name="ln4720">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4721">    emsg(_(&quot;E784: Cannot close last tab page&quot;));</a>
<a name="ln4722">    return;</a>
<a name="ln4723">  }</a>
<a name="ln4724"> </a>
<a name="ln4725">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4726">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4727">    return;</a>
<a name="ln4728">  }</a>
<a name="ln4729"> </a>
<a name="ln4730">  tabpage_T *tp = find_tabpage(tab_number);</a>
<a name="ln4731">  if (tp == NULL) {</a>
<a name="ln4732">    beep_flush();</a>
<a name="ln4733">    return;</a>
<a name="ln4734">  }</a>
<a name="ln4735">  if (tp != curtab) {</a>
<a name="ln4736">    tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4737">    return;</a>
<a name="ln4738">  } else if (!text_locked() &amp;&amp; !curbuf_locked()) {</a>
<a name="ln4739">    tabpage_close(eap-&gt;forceit);</a>
<a name="ln4740">  }</a>
<a name="ln4741">}</a>
<a name="ln4742"> </a>
<a name="ln4743">/// &quot;:tabonly&quot;: close all tab pages except the current one</a>
<a name="ln4744">static void ex_tabonly(exarg_T *eap)</a>
<a name="ln4745">{</a>
<a name="ln4746">  if (cmdwin_type != 0) {</a>
<a name="ln4747">    cmdwin_result = K_IGNORE;</a>
<a name="ln4748">    return;</a>
<a name="ln4749">  }</a>
<a name="ln4750"> </a>
<a name="ln4751">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4752">    msg(_(&quot;Already only one tab page&quot;));</a>
<a name="ln4753">    return;</a>
<a name="ln4754">  }</a>
<a name="ln4755"> </a>
<a name="ln4756">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln4757">  if (eap-&gt;errmsg != NULL) {</a>
<a name="ln4758">    return;</a>
<a name="ln4759">  }</a>
<a name="ln4760"> </a>
<a name="ln4761">  goto_tabpage(tab_number);</a>
<a name="ln4762">  // Repeat this up to a 1000 times, because autocommands may</a>
<a name="ln4763">  // mess up the lists.</a>
<a name="ln4764">  for (int done = 0; done &lt; 1000; done++) {</a>
<a name="ln4765">    FOR_ALL_TABS(tp) {</a>
<a name="ln4766">      if (tp-&gt;tp_topframe != topframe) {</a>
<a name="ln4767">        tabpage_close_other(tp, eap-&gt;forceit);</a>
<a name="ln4768">        // if we failed to close it quit</a>
<a name="ln4769">        if (valid_tabpage(tp)) {</a>
<a name="ln4770">          done = 1000;</a>
<a name="ln4771">        }</a>
<a name="ln4772">        // start over, &quot;tp&quot; is now invalid</a>
<a name="ln4773">        break;</a>
<a name="ln4774">      }</a>
<a name="ln4775">    }</a>
<a name="ln4776">    assert(first_tabpage);</a>
<a name="ln4777">    if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4778">      break;</a>
<a name="ln4779">    }</a>
<a name="ln4780">  }</a>
<a name="ln4781">}</a>
<a name="ln4782"> </a>
<a name="ln4783">/// Close the current tab page.</a>
<a name="ln4784">void tabpage_close(int forceit)</a>
<a name="ln4785">{</a>
<a name="ln4786">  // First close all the windows but the current one.  If that worked then</a>
<a name="ln4787">  // close the last window in this tab, that will close it.</a>
<a name="ln4788">  while (curwin-&gt;w_floating) {</a>
<a name="ln4789">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4790">  }</a>
<a name="ln4791">  if (!ONE_WINDOW) {</a>
<a name="ln4792">    close_others(true, forceit);</a>
<a name="ln4793">  }</a>
<a name="ln4794">  if (ONE_WINDOW) {</a>
<a name="ln4795">    ex_win_close(forceit, curwin, NULL);</a>
<a name="ln4796">  }</a>
<a name="ln4797">}</a>
<a name="ln4798"> </a>
<a name="ln4799">/// Close tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln4800">/// Note that autocommands may make &quot;tp&quot; invalid.</a>
<a name="ln4801">/// Also takes care of the tab pages line disappearing when closing the</a>
<a name="ln4802">/// last-but-one tab page.</a>
<a name="ln4803">void tabpage_close_other(tabpage_T *tp, int forceit)</a>
<a name="ln4804">{</a>
<a name="ln4805">  int done = 0;</a>
<a name="ln4806">  char prev_idx[NUMBUFLEN];</a>
<a name="ln4807"> </a>
<a name="ln4808">  // Limit to 1000 windows, autocommands may add a window while we close</a>
<a name="ln4809">  // one.  OK, so I'm paranoid...</a>
<a name="ln4810">  while (++done &lt; 1000) {</a>
<a name="ln4811">    snprintf(prev_idx, sizeof(prev_idx), &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln4812">    win_T *wp = tp-&gt;tp_lastwin;</a>
<a name="ln4813">    ex_win_close(forceit, wp, tp);</a>
<a name="ln4814"> </a>
<a name="ln4815">    // Autocommands may delete the tab page under our fingers and we may</a>
<a name="ln4816">    // fail to close a window with a modified buffer.</a>
<a name="ln4817">    if (!valid_tabpage(tp) || tp-&gt;tp_lastwin == wp) {</a>
<a name="ln4818">      break;</a>
<a name="ln4819">    }</a>
<a name="ln4820">  }</a>
<a name="ln4821">}</a>
<a name="ln4822"> </a>
<a name="ln4823">/// &quot;:only&quot;.</a>
<a name="ln4824">static void ex_only(exarg_T *eap)</a>
<a name="ln4825">{</a>
<a name="ln4826">  win_T *wp;</a>
<a name="ln4827"> </a>
<a name="ln4828">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln4829">    linenr_T wnr = eap-&gt;line2;</a>
<a name="ln4830">    for (wp = firstwin; --wnr &gt; 0;) {</a>
<a name="ln4831">      if (wp-&gt;w_next == NULL) {</a>
<a name="ln4832">        break;</a>
<a name="ln4833">      }</a>
<a name="ln4834">      wp = wp-&gt;w_next;</a>
<a name="ln4835">    }</a>
<a name="ln4836">  } else {</a>
<a name="ln4837">    wp = curwin;</a>
<a name="ln4838">  }</a>
<a name="ln4839">  if (wp != curwin) {</a>
<a name="ln4840">    win_goto(wp);</a>
<a name="ln4841">  }</a>
<a name="ln4842">  close_others(true, eap-&gt;forceit);</a>
<a name="ln4843">}</a>
<a name="ln4844"> </a>
<a name="ln4845">static void ex_hide(exarg_T *eap)</a>
<a name="ln4846">{</a>
<a name="ln4847">  // &quot;:hide&quot; or &quot;:hide | cmd&quot;: hide current window</a>
<a name="ln4848">  if (eap-&gt;skip) {</a>
<a name="ln4849">    return;</a>
<a name="ln4850">  }</a>
<a name="ln4851"> </a>
<a name="ln4852">  if (eap-&gt;addr_count == 0) {</a>
<a name="ln4853">    win_close(curwin, false, eap-&gt;forceit);  // don't free buffer</a>
<a name="ln4854">  } else {</a>
<a name="ln4855">    int winnr = 0;</a>
<a name="ln4856">    win_T *win = NULL;</a>
<a name="ln4857"> </a>
<a name="ln4858">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln4859">      winnr++;</a>
<a name="ln4860">      if (winnr == eap-&gt;line2) {</a>
<a name="ln4861">        win = wp;</a>
<a name="ln4862">        break;</a>
<a name="ln4863">      }</a>
<a name="ln4864">    }</a>
<a name="ln4865">    if (win == NULL) {</a>
<a name="ln4866">      win = lastwin;</a>
<a name="ln4867">    }</a>
<a name="ln4868">    win_close(win, false, eap-&gt;forceit);</a>
<a name="ln4869">  }</a>
<a name="ln4870">}</a>
<a name="ln4871"> </a>
<a name="ln4872">/// &quot;:stop&quot; and &quot;:suspend&quot;: Suspend Vim.</a>
<a name="ln4873">static void ex_stop(exarg_T *eap)</a>
<a name="ln4874">{</a>
<a name="ln4875">  if (!eap-&gt;forceit) {</a>
<a name="ln4876">    autowrite_all();</a>
<a name="ln4877">  }</a>
<a name="ln4878">  may_trigger_vim_suspend_resume(true);</a>
<a name="ln4879">  ui_call_suspend();</a>
<a name="ln4880">  ui_flush();</a>
<a name="ln4881">}</a>
<a name="ln4882"> </a>
<a name="ln4883">/// &quot;:exit&quot;, &quot;:xit&quot; and &quot;:wq&quot;: Write file and quit the current window.</a>
<a name="ln4884">static void ex_exit(exarg_T *eap)</a>
<a name="ln4885">{</a>
<a name="ln4886">  if (cmdwin_type != 0) {</a>
<a name="ln4887">    cmdwin_result = Ctrl_C;</a>
<a name="ln4888">    return;</a>
<a name="ln4889">  }</a>
<a name="ln4890">  // Don't quit while editing the command line.</a>
<a name="ln4891">  if (text_locked()) {</a>
<a name="ln4892">    text_locked_msg();</a>
<a name="ln4893">    return;</a>
<a name="ln4894">  }</a>
<a name="ln4895"> </a>
<a name="ln4896">  // we plan to exit if there is only one relevant window</a>
<a name="ln4897">  if (check_more(false, eap-&gt;forceit) == OK &amp;&amp; only_one_window()) {</a>
<a name="ln4898">    exiting = true;</a>
<a name="ln4899">  }</a>
<a name="ln4900">  // Write the buffer for &quot;:wq&quot; or when it was changed.</a>
<a name="ln4901">  // Trigger QuitPre and ExitPre.</a>
<a name="ln4902">  // Check if we can exit now, after autocommands have changed things.</a>
<a name="ln4903">  if (((eap-&gt;cmdidx == CMD_wq || curbufIsChanged()) &amp;&amp; do_write(eap) == FAIL)</a>
<a name="ln4904">      || before_quit_autocmds(curwin, false, eap-&gt;forceit)</a>
<a name="ln4905">      || check_more(true, eap-&gt;forceit) == FAIL</a>
<a name="ln4906">      || (only_one_window() &amp;&amp; check_changed_any(eap-&gt;forceit, false))) {</a>
<a name="ln4907">    not_exiting();</a>
<a name="ln4908">  } else {</a>
<a name="ln4909">    if (only_one_window()) {</a>
<a name="ln4910">      // quit last window, exit Vim</a>
<a name="ln4911">      getout(0);</a>
<a name="ln4912">    }</a>
<a name="ln4913">    not_exiting();</a>
<a name="ln4914">    // Quit current window, may free the buffer.</a>
<a name="ln4915">    win_close(curwin, !buf_hide(curwin-&gt;w_buffer), eap-&gt;forceit);</a>
<a name="ln4916">  }</a>
<a name="ln4917">}</a>
<a name="ln4918"> </a>
<a name="ln4919">/// &quot;:print&quot;, &quot;:list&quot;, &quot;:number&quot;.</a>
<a name="ln4920">static void ex_print(exarg_T *eap)</a>
<a name="ln4921">{</a>
<a name="ln4922">  if (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY) {</a>
<a name="ln4923">    emsg(_(e_empty_buffer));</a>
<a name="ln4924">  } else {</a>
<a name="ln4925">    for (; !got_int; os_breakcheck()) {</a>
<a name="ln4926">      print_line(eap-&gt;line1,</a>
<a name="ln4927">                 (eap-&gt;cmdidx == CMD_number || eap-&gt;cmdidx == CMD_pound</a>
<a name="ln4928">                  || (eap-&gt;flags &amp; EXFLAG_NR)),</a>
<a name="ln4929">                 eap-&gt;cmdidx == CMD_list || (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln4930">      if (++eap-&gt;line1 &gt; eap-&gt;line2) {</a>
<a name="ln4931">        break;</a>
<a name="ln4932">      }</a>
<a name="ln4933">    }</a>
<a name="ln4934">    setpcmark();</a>
<a name="ln4935">    // put cursor at last line</a>
<a name="ln4936">    curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln4937">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln4938">  }</a>
<a name="ln4939"> </a>
<a name="ln4940">  ex_no_reprint = true;</a>
<a name="ln4941">}</a>
<a name="ln4942"> </a>
<a name="ln4943">static void ex_goto(exarg_T *eap)</a>
<a name="ln4944">{</a>
<a name="ln4945">  goto_byte(eap-&gt;line2);</a>
<a name="ln4946">}</a>
<a name="ln4947"> </a>
<a name="ln4948">/// &quot;:preserve&quot;.</a>
<a name="ln4949">static void ex_preserve(exarg_T *eap)</a>
<a name="ln4950">{</a>
<a name="ln4951">  ml_preserve(curbuf, true, true);</a>
<a name="ln4952">}</a>
<a name="ln4953"> </a>
<a name="ln4954">/// &quot;:recover&quot;.</a>
<a name="ln4955">static void ex_recover(exarg_T *eap)</a>
<a name="ln4956">{</a>
<a name="ln4957">  // Set recoverymode right away to avoid the ATTENTION prompt.</a>
<a name="ln4958">  recoverymode = true;</a>
<a name="ln4959">  if (!check_changed(curbuf, (p_awa ? CCGD_AW : 0)</a>
<a name="ln4960">                     | CCGD_MULTWIN</a>
<a name="ln4961">                     | (eap-&gt;forceit ? CCGD_FORCEIT : 0)</a>
<a name="ln4962">                     | CCGD_EXCMD)</a>
<a name="ln4963"> </a>
<a name="ln4964">      &amp;&amp; (*eap-&gt;arg == NUL</a>
<a name="ln4965">          || setfname(curbuf, eap-&gt;arg, NULL, true) == OK)) {</a>
<a name="ln4966">    ml_recover(true);</a>
<a name="ln4967">  }</a>
<a name="ln4968">  recoverymode = false;</a>
<a name="ln4969">}</a>
<a name="ln4970"> </a>
<a name="ln4971">/// Command modifier used in a wrong way.</a>
<a name="ln4972">static void ex_wrongmodifier(exarg_T *eap)</a>
<a name="ln4973">{</a>
<a name="ln4974">  eap-&gt;errmsg = _(e_invcmd);</a>
<a name="ln4975">}</a>
<a name="ln4976"> </a>
<a name="ln4977">/// :sview [+command] file       split window with new file, read-only</a>
<a name="ln4978">/// :split [[+command] file]     split window with current or new file</a>
<a name="ln4979">/// :vsplit [[+command] file]    split window vertically with current or new file</a>
<a name="ln4980">/// :new [[+command] file]       split window with no or new file</a>
<a name="ln4981">/// :vnew [[+command] file]      split vertically window with no or new file</a>
<a name="ln4982">/// :sfind [+command] file       split window with file in 'path'</a>
<a name="ln4983">///</a>
<a name="ln4984">/// :tabedit                     open new Tab page with empty window</a>
<a name="ln4985">/// :tabedit [+command] file     open new Tab page and edit &quot;file&quot;</a>
<a name="ln4986">/// :tabnew [[+command] file]    just like :tabedit</a>
<a name="ln4987">/// :tabfind [+command] file     open new Tab page and find &quot;file&quot;</a>
<a name="ln4988">void ex_splitview(exarg_T *eap)</a>
<a name="ln4989">{</a>
<a name="ln4990">  win_T *old_curwin = curwin;</a>
<a name="ln4991">  char *fname = NULL;</a>
<a name="ln4992">  const bool use_tab = eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln4993">                       || eap-&gt;cmdidx == CMD_tabfind</a>
<a name="ln4994">                       || eap-&gt;cmdidx == CMD_tabnew;</a>
<a name="ln4995"> </a>
<a name="ln4996">  // A &quot;:split&quot; in the quickfix window works like &quot;:new&quot;.  Don't want two</a>
<a name="ln4997">  // quickfix windows.  But it's OK when doing &quot;:tab split&quot;.</a>
<a name="ln4998">  if (bt_quickfix(curbuf) &amp;&amp; cmdmod.cmod_tab == 0) {</a>
<a name="ln4999">    if (eap-&gt;cmdidx == CMD_split) {</a>
<a name="ln5000">      eap-&gt;cmdidx = CMD_new;</a>
<a name="ln5001">    }</a>
<a name="ln5002">    if (eap-&gt;cmdidx == CMD_vsplit) {</a>
<a name="ln5003">      eap-&gt;cmdidx = CMD_vnew;</a>
<a name="ln5004">    }</a>
<a name="ln5005">  }</a>
<a name="ln5006"> </a>
<a name="ln5007">  if (eap-&gt;cmdidx == CMD_sfind || eap-&gt;cmdidx == CMD_tabfind) {</a>
<a name="ln5008">    char *file_to_find = NULL;</a>
<a name="ln5009">    char *search_ctx = NULL;</a>
<a name="ln5010">    fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5011">                              FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5012">                              &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5013">    xfree(file_to_find);</a>
<a name="ln5014">    vim_findfile_cleanup(search_ctx);</a>
<a name="ln5015">    if (fname == NULL) {</a>
<a name="ln5016">      goto theend;</a>
<a name="ln5017">    }</a>
<a name="ln5018">    eap-&gt;arg = fname;</a>
<a name="ln5019">  }</a>
<a name="ln5020"> </a>
<a name="ln5021">  // Either open new tab page or split the window.</a>
<a name="ln5022">  if (use_tab) {</a>
<a name="ln5023">    if (win_new_tabpage(cmdmod.cmod_tab != 0 ? cmdmod.cmod_tab : eap-&gt;addr_count == 0</a>
<a name="ln5024">                        ? 0 : (int)eap-&gt;line2 + 1, eap-&gt;arg) != FAIL) {</a>
<a name="ln5025">      do_exedit(eap, old_curwin);</a>
<a name="ln5026">      apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);</a>
<a name="ln5027"> </a>
<a name="ln5028">      // set the alternate buffer for the window we came from</a>
<a name="ln5029">      if (curwin != old_curwin</a>
<a name="ln5030">          &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5031">          &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5032">          &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5033">        old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5034">      }</a>
<a name="ln5035">    }</a>
<a name="ln5036">  } else if (win_split(eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 0,</a>
<a name="ln5037">                       *eap-&gt;cmd == 'v' ? WSP_VERT : 0) != FAIL) {</a>
<a name="ln5038">    // Reset 'scrollbind' when editing another file, but keep it when</a>
<a name="ln5039">    // doing &quot;:split&quot; without arguments.</a>
<a name="ln5040">    if (*eap-&gt;arg != NUL) {</a>
<a name="ln5041">      RESET_BINDING(curwin);</a>
<a name="ln5042">    } else {</a>
<a name="ln5043">      do_check_scrollbind(false);</a>
<a name="ln5044">    }</a>
<a name="ln5045">    do_exedit(eap, old_curwin);</a>
<a name="ln5046">  }</a>
<a name="ln5047"> </a>
<a name="ln5048">theend:</a>
<a name="ln5049">  xfree(fname);</a>
<a name="ln5050">}</a>
<a name="ln5051"> </a>
<a name="ln5052">/// Open a new tab page.</a>
<a name="ln5053">void tabpage_new(void)</a>
<a name="ln5054">{</a>
<a name="ln5055">  exarg_T ea = {</a>
<a name="ln5056">    .cmdidx = CMD_tabnew,</a>
<a name="ln5057">    .cmd = &quot;tabn&quot;,</a>
<a name="ln5058">    .arg = &quot;&quot;,</a>
<a name="ln5059">  };</a>
<a name="ln5060">  ex_splitview(&amp;ea);</a>
<a name="ln5061">}</a>
<a name="ln5062"> </a>
<a name="ln5063">/// :tabnext command</a>
<a name="ln5064">static void ex_tabnext(exarg_T *eap)</a>
<a name="ln5065">{</a>
<a name="ln5066">  int tab_number;</a>
<a name="ln5067"> </a>
<a name="ln5068">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5069">  case CMD_tabfirst:</a>
<a name="ln5070">  case CMD_tabrewind:</a>
<a name="ln5071">    goto_tabpage(1);</a>
<a name="ln5072">    break;</a>
<a name="ln5073">  case CMD_tablast:</a>
<a name="ln5074">    goto_tabpage(9999);</a>
<a name="ln5075">    break;</a>
<a name="ln5076">  case CMD_tabprevious:</a>
<a name="ln5077">  case CMD_tabNext:</a>
<a name="ln5078">    if (eap-&gt;arg &amp;&amp; *eap-&gt;arg != NUL) {</a>
<a name="ln5079">      char *p = eap-&gt;arg;</a>
<a name="ln5080">      char *p_save = p;</a>
<a name="ln5081">      tab_number = (int)getdigits(&amp;p, false, 0);</a>
<a name="ln5082">      if (p == p_save || *p_save == '-' || *p_save == '+' || *p != NUL</a>
<a name="ln5083">          || tab_number == 0) {</a>
<a name="ln5084">        // No numbers as argument.</a>
<a name="ln5085">        eap-&gt;errmsg = ex_errmsg(e_invarg2, eap-&gt;arg);</a>
<a name="ln5086">        return;</a>
<a name="ln5087">      }</a>
<a name="ln5088">    } else {</a>
<a name="ln5089">      if (eap-&gt;addr_count == 0) {</a>
<a name="ln5090">        tab_number = 1;</a>
<a name="ln5091">      } else {</a>
<a name="ln5092">        tab_number = (int)eap-&gt;line2;</a>
<a name="ln5093">        if (tab_number &lt; 1) {</a>
<a name="ln5094">          eap-&gt;errmsg = _(e_invrange);</a>
<a name="ln5095">          return;</a>
<a name="ln5096">        }</a>
<a name="ln5097">      }</a>
<a name="ln5098">    }</a>
<a name="ln5099">    goto_tabpage(-tab_number);</a>
<a name="ln5100">    break;</a>
<a name="ln5101">  default:       // CMD_tabnext</a>
<a name="ln5102">    tab_number = get_tabpage_arg(eap);</a>
<a name="ln5103">    if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5104">      goto_tabpage(tab_number);</a>
<a name="ln5105">    }</a>
<a name="ln5106">    break;</a>
<a name="ln5107">  }</a>
<a name="ln5108">}</a>
<a name="ln5109"> </a>
<a name="ln5110">/// :tabmove command</a>
<a name="ln5111">static void ex_tabmove(exarg_T *eap)</a>
<a name="ln5112">{</a>
<a name="ln5113">  int tab_number = get_tabpage_arg(eap);</a>
<a name="ln5114">  if (eap-&gt;errmsg == NULL) {</a>
<a name="ln5115">    tabpage_move(tab_number);</a>
<a name="ln5116">  }</a>
<a name="ln5117">}</a>
<a name="ln5118"> </a>
<a name="ln5119">/// :tabs command: List tabs and their contents.</a>
<a name="ln5120">static void ex_tabs(exarg_T *eap)</a>
<a name="ln5121">{</a>
<a name="ln5122">  int tabcount = 1;</a>
<a name="ln5123"> </a>
<a name="ln5124">  msg_start();</a>
<a name="ln5125">  msg_scroll = true;</a>
<a name="ln5126"> </a>
<a name="ln5127">  win_T *lastused_win = valid_tabpage(lastused_tabpage)</a>
<a name="ln5128">    ? lastused_tabpage-&gt;tp_curwin</a>
<a name="ln5129">    : NULL;</a>
<a name="ln5130"> </a>
<a name="ln5131">  FOR_ALL_TABS(tp) {</a>
<a name="ln5132">    if (got_int) {</a>
<a name="ln5133">      break;</a>
<a name="ln5134">    }</a>
<a name="ln5135"> </a>
<a name="ln5136">    msg_putchar('\n');</a>
<a name="ln5137">    vim_snprintf(IObuff, IOSIZE, _(&quot;Tab page %d&quot;), tabcount++);</a>
<a name="ln5138">    msg_outtrans_attr(IObuff, HL_ATTR(HLF_T));</a>
<a name="ln5139">    os_breakcheck();</a>
<a name="ln5140"> </a>
<a name="ln5141">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln5142">      if (got_int) {</a>
<a name="ln5143">        break;</a>
<a name="ln5144">      }</a>
<a name="ln5145"> </a>
<a name="ln5146">      msg_putchar('\n');</a>
<a name="ln5147">      msg_putchar(wp == curwin ? '&gt;' : wp == lastused_win ? '#' : ' ');</a>
<a name="ln5148">      msg_putchar(' ');</a>
<a name="ln5149">      msg_putchar(bufIsChanged(wp-&gt;w_buffer) ? '+' : ' ');</a>
<a name="ln5150">      msg_putchar(' ');</a>
<a name="ln5151">      if (buf_spname(wp-&gt;w_buffer) != NULL) {</a>
<a name="ln5152">        xstrlcpy(IObuff, buf_spname(wp-&gt;w_buffer), IOSIZE);</a>
<a name="ln5153">      } else {</a>
<a name="ln5154">        home_replace(wp-&gt;w_buffer, wp-&gt;w_buffer-&gt;b_fname, IObuff, IOSIZE, true);</a>
<a name="ln5155">      }</a>
<a name="ln5156">      msg_outtrans(IObuff);</a>
<a name="ln5157">      os_breakcheck();</a>
<a name="ln5158">    }</a>
<a name="ln5159">  }</a>
<a name="ln5160">}</a>
<a name="ln5161"> </a>
<a name="ln5162">/// &quot;:mode&quot;:</a>
<a name="ln5163">/// If no argument given, get the screen size and redraw.</a>
<a name="ln5164">static void ex_mode(exarg_T *eap)</a>
<a name="ln5165">{</a>
<a name="ln5166">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5167">    must_redraw = UPD_CLEAR;</a>
<a name="ln5168">    ex_redraw(eap);</a>
<a name="ln5169">  } else {</a>
<a name="ln5170">    emsg(_(e_screenmode));</a>
<a name="ln5171">  }</a>
<a name="ln5172">}</a>
<a name="ln5173"> </a>
<a name="ln5174">/// &quot;:resize&quot;.</a>
<a name="ln5175">/// set, increment or decrement current window height</a>
<a name="ln5176">static void ex_resize(exarg_T *eap)</a>
<a name="ln5177">{</a>
<a name="ln5178">  win_T *wp = curwin;</a>
<a name="ln5179"> </a>
<a name="ln5180">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5181">    int n = (int)eap-&gt;line2;</a>
<a name="ln5182">    for (wp = firstwin; wp-&gt;w_next != NULL &amp;&amp; --n &gt; 0; wp = wp-&gt;w_next) {}</a>
<a name="ln5183">  }</a>
<a name="ln5184"> </a>
<a name="ln5185">  int n = (int)atol(eap-&gt;arg);</a>
<a name="ln5186">  if (cmdmod.cmod_split &amp; WSP_VERT) {</a>
<a name="ln5187">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5188">      n += wp-&gt;w_width;</a>
<a name="ln5189">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very wide</a>
<a name="ln5190">      n = Columns;</a>
<a name="ln5191">    }</a>
<a name="ln5192">    win_setwidth_win(n, wp);</a>
<a name="ln5193">  } else {</a>
<a name="ln5194">    if (*eap-&gt;arg == '-' || *eap-&gt;arg == '+') {</a>
<a name="ln5195">      n += wp-&gt;w_height;</a>
<a name="ln5196">    } else if (n == 0 &amp;&amp; eap-&gt;arg[0] == NUL) {  // default is very high</a>
<a name="ln5197">      n = Rows - 1;</a>
<a name="ln5198">    }</a>
<a name="ln5199">    win_setheight_win(n, wp);</a>
<a name="ln5200">  }</a>
<a name="ln5201">}</a>
<a name="ln5202"> </a>
<a name="ln5203">/// &quot;:find [+command] &lt;file&gt;&quot; command.</a>
<a name="ln5204">static void ex_find(exarg_T *eap)</a>
<a name="ln5205">{</a>
<a name="ln5206">  char *file_to_find = NULL;</a>
<a name="ln5207">  char *search_ctx = NULL;</a>
<a name="ln5208">  char *fname = find_file_in_path(eap-&gt;arg, strlen(eap-&gt;arg),</a>
<a name="ln5209">                                  FNAME_MESS, true, curbuf-&gt;b_ffname,</a>
<a name="ln5210">                                  &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5211">  if (eap-&gt;addr_count &gt; 0) {</a>
<a name="ln5212">    // Repeat finding the file &quot;count&quot; times.  This matters when it appears</a>
<a name="ln5213">    // several times in the path.</a>
<a name="ln5214">    linenr_T count = eap-&gt;line2;</a>
<a name="ln5215">    while (fname != NULL &amp;&amp; --count &gt; 0) {</a>
<a name="ln5216">      xfree(fname);</a>
<a name="ln5217">      fname = find_file_in_path(NULL, 0, FNAME_MESS, false, curbuf-&gt;b_ffname,</a>
<a name="ln5218">                                &amp;file_to_find, &amp;search_ctx);</a>
<a name="ln5219">    }</a>
<a name="ln5220">  }</a>
<a name="ln5221">  xfree(file_to_find);</a>
<a name="ln5222">  vim_findfile_cleanup(search_ctx);</a>
<a name="ln5223"> </a>
<a name="ln5224">  if (fname == NULL) {</a>
<a name="ln5225">    return;</a>
<a name="ln5226">  }</a>
<a name="ln5227"> </a>
<a name="ln5228">  eap-&gt;arg = fname;</a>
<a name="ln5229">  do_exedit(eap, NULL);</a>
<a name="ln5230">  xfree(fname);</a>
<a name="ln5231">}</a>
<a name="ln5232"> </a>
<a name="ln5233">/// &quot;:edit&quot;, &quot;:badd&quot;, &quot;:balt&quot;, &quot;:visual&quot;.</a>
<a name="ln5234">static void ex_edit(exarg_T *eap)</a>
<a name="ln5235">{</a>
<a name="ln5236">  do_exedit(eap, NULL);</a>
<a name="ln5237">}</a>
<a name="ln5238"> </a>
<a name="ln5239">/// &quot;:edit &lt;file&gt;&quot; command and alike.</a>
<a name="ln5240">///</a>
<a name="ln5241">/// @param old_curwin  curwin before doing a split or NULL</a>
<a name="ln5242">void do_exedit(exarg_T *eap, win_T *old_curwin)</a>
<a name="ln5243">{</a>
<a name="ln5244">  int n;</a>
<a name="ln5245"> </a>
<a name="ln5246">  // &quot;:vi&quot; command ends Ex mode.</a>
<a name="ln5247">  if (exmode_active &amp;&amp; (eap-&gt;cmdidx == CMD_visual</a>
<a name="ln5248">                        || eap-&gt;cmdidx == CMD_view)) {</a>
<a name="ln5249">    exmode_active = false;</a>
<a name="ln5250">    ex_pressedreturn = false;</a>
<a name="ln5251">    if (*eap-&gt;arg == NUL) {</a>
<a name="ln5252">      // Special case:  &quot;:global/pat/visual\NLvi-commands&quot;</a>
<a name="ln5253">      if (global_busy) {</a>
<a name="ln5254">        if (eap-&gt;nextcmd != NULL) {</a>
<a name="ln5255">          stuffReadbuff(eap-&gt;nextcmd);</a>
<a name="ln5256">          eap-&gt;nextcmd = NULL;</a>
<a name="ln5257">        }</a>
<a name="ln5258"> </a>
<a name="ln5259">        const int save_rd = RedrawingDisabled;</a>
<a name="ln5260">        RedrawingDisabled = 0;</a>
<a name="ln5261">        const int save_nwr = no_wait_return;</a>
<a name="ln5262">        no_wait_return = 0;</a>
<a name="ln5263">        need_wait_return = false;</a>
<a name="ln5264">        const int save_ms = msg_scroll;</a>
<a name="ln5265">        msg_scroll = 0;</a>
<a name="ln5266">        redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln5267">        pending_exmode_active = true;</a>
<a name="ln5268"> </a>
<a name="ln5269">        normal_enter(false, true);</a>
<a name="ln5270"> </a>
<a name="ln5271">        pending_exmode_active = false;</a>
<a name="ln5272">        RedrawingDisabled = save_rd;</a>
<a name="ln5273">        no_wait_return = save_nwr;</a>
<a name="ln5274">        msg_scroll = save_ms;</a>
<a name="ln5275">      }</a>
<a name="ln5276">      return;</a>
<a name="ln5277">    }</a>
<a name="ln5278">  }</a>
<a name="ln5279"> </a>
<a name="ln5280">  if ((eap-&gt;cmdidx == CMD_new</a>
<a name="ln5281">       || eap-&gt;cmdidx == CMD_tabnew</a>
<a name="ln5282">       || eap-&gt;cmdidx == CMD_tabedit</a>
<a name="ln5283">       || eap-&gt;cmdidx == CMD_vnew) &amp;&amp; *eap-&gt;arg == NUL) {</a>
<a name="ln5284">    // &quot;:new&quot; or &quot;:tabnew&quot; without argument: edit a new empty buffer</a>
<a name="ln5285">    setpcmark();</a>
<a name="ln5286">    (void)do_ecmd(0, NULL, NULL, eap, ECMD_ONE,</a>
<a name="ln5287">                  ECMD_HIDE + (eap-&gt;forceit ? ECMD_FORCEIT : 0),</a>
<a name="ln5288">                  old_curwin == NULL ? curwin : NULL);</a>
<a name="ln5289">  } else if ((eap-&gt;cmdidx != CMD_split &amp;&amp; eap-&gt;cmdidx != CMD_vsplit)</a>
<a name="ln5290">             || *eap-&gt;arg != NUL) {</a>
<a name="ln5291">    // Can't edit another file when &quot;textlock&quot; or &quot;curbuf-&gt;b_ro_locked&quot; is set.</a>
<a name="ln5292">    // Only &quot;:edit&quot; or &quot;:script&quot; can bring us here, others are stopped earlier.</a>
<a name="ln5293">    if (*eap-&gt;arg != NUL &amp;&amp; text_or_buf_locked()) {</a>
<a name="ln5294">      return;</a>
<a name="ln5295">    }</a>
<a name="ln5296">    n = readonlymode;</a>
<a name="ln5297">    if (eap-&gt;cmdidx == CMD_view || eap-&gt;cmdidx == CMD_sview) {</a>
<a name="ln5298">      readonlymode = true;</a>
<a name="ln5299">    } else if (eap-&gt;cmdidx == CMD_enew) {</a>
<a name="ln5300">      readonlymode = false;  // 'readonly' doesn't make sense</a>
<a name="ln5301">                             // in an empty buffer</a>
<a name="ln5302">    }</a>
<a name="ln5303">    if (eap-&gt;cmdidx != CMD_balt &amp;&amp; eap-&gt;cmdidx != CMD_badd) {</a>
<a name="ln5304">      setpcmark();</a>
<a name="ln5305">    }</a>
<a name="ln5306">    if (do_ecmd(0, eap-&gt;cmdidx == CMD_enew ? NULL : eap-&gt;arg,</a>
<a name="ln5307">                NULL, eap, eap-&gt;do_ecmd_lnum,</a>
<a name="ln5308">                (buf_hide(curbuf) ? ECMD_HIDE : 0)</a>
<a name="ln5309">                + (eap-&gt;forceit ? ECMD_FORCEIT : 0)</a>
<a name="ln5310">                // After a split we can use an existing buffer.</a>
<a name="ln5311">                + (old_curwin != NULL ? ECMD_OLDBUF : 0)</a>
<a name="ln5312">                + (eap-&gt;cmdidx == CMD_badd ? ECMD_ADDBUF : 0)</a>
<a name="ln5313">                + (eap-&gt;cmdidx == CMD_balt ? ECMD_ALTBUF : 0),</a>
<a name="ln5314">                old_curwin == NULL ? curwin : NULL) == FAIL) {</a>
<a name="ln5315">      // Editing the file failed.  If the window was split, close it.</a>
<a name="ln5316">      if (old_curwin != NULL) {</a>
<a name="ln5317">        bool need_hide = (curbufIsChanged() &amp;&amp; curbuf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln5318">        if (!need_hide || buf_hide(curbuf)) {</a>
<a name="ln5319">          cleanup_T cs;</a>
<a name="ln5320"> </a>
<a name="ln5321">          // Reset the error/interrupt/exception state here so that</a>
<a name="ln5322">          // aborting() returns false when closing a window.</a>
<a name="ln5323">          enter_cleanup(&amp;cs);</a>
<a name="ln5324">          win_close(curwin, !need_hide &amp;&amp; !buf_hide(curbuf), false);</a>
<a name="ln5325"> </a>
<a name="ln5326">          // Restore the error/interrupt/exception state if not</a>
<a name="ln5327">          // discarded by a new aborting error, interrupt, or</a>
<a name="ln5328">          // uncaught exception.</a>
<a name="ln5329">          leave_cleanup(&amp;cs);</a>
<a name="ln5330">        }</a>
<a name="ln5331">      }</a>
<a name="ln5332">    } else if (readonlymode &amp;&amp; curbuf-&gt;b_nwindows == 1) {</a>
<a name="ln5333">      // When editing an already visited buffer, 'readonly' won't be set</a>
<a name="ln5334">      // but the previous value is kept.  With &quot;:view&quot; and &quot;:sview&quot; we</a>
<a name="ln5335">      // want the  file to be readonly, except when another window is</a>
<a name="ln5336">      // editing the same buffer.</a>
<a name="ln5337">      curbuf-&gt;b_p_ro = true;</a>
<a name="ln5338">    }</a>
<a name="ln5339">    readonlymode = n;</a>
<a name="ln5340">  } else {</a>
<a name="ln5341">    if (eap-&gt;do_ecmd_cmd != NULL) {</a>
<a name="ln5342">      do_cmdline_cmd(eap-&gt;do_ecmd_cmd);</a>
<a name="ln5343">    }</a>
<a name="ln5344">    n = curwin-&gt;w_arg_idx_invalid;</a>
<a name="ln5345">    check_arg_idx(curwin);</a>
<a name="ln5346">    if (n != curwin-&gt;w_arg_idx_invalid) {</a>
<a name="ln5347">      maketitle();</a>
<a name="ln5348">    }</a>
<a name="ln5349">  }</a>
<a name="ln5350"> </a>
<a name="ln5351">  // if &quot;:split file&quot; worked, set alternate file name in old window to new</a>
<a name="ln5352">  // file</a>
<a name="ln5353">  if (old_curwin != NULL</a>
<a name="ln5354">      &amp;&amp; *eap-&gt;arg != NUL</a>
<a name="ln5355">      &amp;&amp; curwin != old_curwin</a>
<a name="ln5356">      &amp;&amp; win_valid(old_curwin)</a>
<a name="ln5357">      &amp;&amp; old_curwin-&gt;w_buffer != curbuf</a>
<a name="ln5358">      &amp;&amp; (cmdmod.cmod_flags &amp; CMOD_KEEPALT) == 0) {</a>
<a name="ln5359">    old_curwin-&gt;w_alt_fnum = curbuf-&gt;b_fnum;</a>
<a name="ln5360">  }</a>
<a name="ln5361"> </a>
<a name="ln5362">  ex_no_reprint = true;</a>
<a name="ln5363">}</a>
<a name="ln5364"> </a>
<a name="ln5365">/// &quot;:gui&quot; and &quot;:gvim&quot; when there is no GUI.</a>
<a name="ln5366">static void ex_nogui(exarg_T *eap)</a>
<a name="ln5367">{</a>
<a name="ln5368">  eap-&gt;errmsg = _(&quot;E25: Nvim does not have a built-in GUI&quot;);</a>
<a name="ln5369">}</a>
<a name="ln5370"> </a>
<a name="ln5371">static void ex_popup(exarg_T *eap)</a>
<a name="ln5372">{</a>
<a name="ln5373">  pum_make_popup(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln5374">}</a>
<a name="ln5375"> </a>
<a name="ln5376">static void ex_swapname(exarg_T *eap)</a>
<a name="ln5377">{</a>
<a name="ln5378">  if (curbuf-&gt;b_ml.ml_mfp == NULL || curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname == NULL) {</a>
<a name="ln5379">    msg(_(&quot;No swap file&quot;));</a>
<a name="ln5380">  } else {</a>
<a name="ln5381">    msg(curbuf-&gt;b_ml.ml_mfp-&gt;mf_fname);</a>
<a name="ln5382">  }</a>
<a name="ln5383">}</a>
<a name="ln5384"> </a>
<a name="ln5385">/// &quot;:syncbind&quot; forces all 'scrollbind' windows to have the same relative</a>
<a name="ln5386">/// offset.</a>
<a name="ln5387">/// (1998-11-02 16:21:01  R. Edward Ralston &lt;eralston@computer.org&gt;)</a>
<a name="ln5388">static void ex_syncbind(exarg_T *eap)</a>
<a name="ln5389">{</a>
<a name="ln5390">  win_T *save_curwin = curwin;</a>
<a name="ln5391">  buf_T *save_curbuf = curbuf;</a>
<a name="ln5392">  linenr_T topline;</a>
<a name="ln5393">  int y;</a>
<a name="ln5394">  linenr_T old_linenr = curwin-&gt;w_cursor.lnum;</a>
<a name="ln5395"> </a>
<a name="ln5396">  setpcmark();</a>
<a name="ln5397"> </a>
<a name="ln5398">  // determine max topline</a>
<a name="ln5399">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5400">    topline = curwin-&gt;w_topline;</a>
<a name="ln5401">    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5402">      if (wp-&gt;w_p_scb &amp;&amp; wp-&gt;w_buffer) {</a>
<a name="ln5403">        y = wp-&gt;w_buffer-&gt;b_ml.ml_line_count - get_scrolloff_value(curwin);</a>
<a name="ln5404">        if (topline &gt; y) {</a>
<a name="ln5405">          topline = y;</a>
<a name="ln5406">        }</a>
<a name="ln5407">      }</a>
<a name="ln5408">    }</a>
<a name="ln5409">    if (topline &lt; 1) {</a>
<a name="ln5410">      topline = 1;</a>
<a name="ln5411">    }</a>
<a name="ln5412">  } else {</a>
<a name="ln5413">    topline = 1;</a>
<a name="ln5414">  }</a>
<a name="ln5415"> </a>
<a name="ln5416">  // Set all scrollbind windows to the same topline.</a>
<a name="ln5417">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5418">    curwin = wp;</a>
<a name="ln5419">    if (curwin-&gt;w_p_scb) {</a>
<a name="ln5420">      curbuf = curwin-&gt;w_buffer;</a>
<a name="ln5421">      y = topline - curwin-&gt;w_topline;</a>
<a name="ln5422">      if (y &gt; 0) {</a>
<a name="ln5423">        scrollup(y, true);</a>
<a name="ln5424">      } else {</a>
<a name="ln5425">        scrolldown(-y, true);</a>
<a name="ln5426">      }</a>
<a name="ln5427">      curwin-&gt;w_scbind_pos = topline;</a>
<a name="ln5428">      redraw_later(curwin, UPD_VALID);</a>
<a name="ln5429">      cursor_correct();</a>
<a name="ln5430">      curwin-&gt;w_redr_status = true;</a>
<a name="ln5431">    }</a>
<a name="ln5432">  }</a>
<a name="ln5433">  curwin = save_curwin;</a>
<a name="ln5434">  curbuf = save_curbuf;</a>
<a name="ln5435">  if (curwin-&gt;w_p_scb) {</a>
<a name="ln5436">    did_syncbind = true;</a>
<a name="ln5437">    checkpcmark();</a>
<a name="ln5438">    if (old_linenr != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln5439">      char ctrl_o[2];</a>
<a name="ln5440"> </a>
<a name="ln5441">      ctrl_o[0] = Ctrl_O;</a>
<a name="ln5442">      ctrl_o[1] = 0;</a>
<a name="ln5443">      ins_typebuf(ctrl_o, REMAP_NONE, 0, true, false);</a>
<a name="ln5444">    }</a>
<a name="ln5445">  }</a>
<a name="ln5446">}</a>
<a name="ln5447"> </a>
<a name="ln5448">static void ex_read(exarg_T *eap)</a>
<a name="ln5449">{</a>
<a name="ln5450">  int empty = (curbuf-&gt;b_ml.ml_flags &amp; ML_EMPTY);</a>
<a name="ln5451"> </a>
<a name="ln5452">  if (eap-&gt;usefilter) {  // :r!cmd</a>
<a name="ln5453">    do_bang(1, eap, false, false, true);</a>
<a name="ln5454">    return;</a>
<a name="ln5455">  }</a>
<a name="ln5456"> </a>
<a name="ln5457">  if (u_save(eap-&gt;line2, (linenr_T)(eap-&gt;line2 + 1)) == FAIL) {</a>
<a name="ln5458">    return;</a>
<a name="ln5459">  }</a>
<a name="ln5460"> </a>
<a name="ln5461">  int i;</a>
<a name="ln5462">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln5463">    if (check_fname() == FAIL) {       // check for no file name</a>
<a name="ln5464">      return;</a>
<a name="ln5465">    }</a>
<a name="ln5466">    i = readfile(curbuf-&gt;b_ffname, curbuf-&gt;b_fname,</a>
<a name="ln5467">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5468">  } else {</a>
<a name="ln5469">    if (vim_strchr(p_cpo, CPO_ALTREAD) != NULL) {</a>
<a name="ln5470">      (void)setaltfname(eap-&gt;arg, eap-&gt;arg, (linenr_T)1);</a>
<a name="ln5471">    }</a>
<a name="ln5472">    i = readfile(eap-&gt;arg, NULL,</a>
<a name="ln5473">                 eap-&gt;line2, (linenr_T)0, (linenr_T)MAXLNUM, eap, 0, false);</a>
<a name="ln5474">  }</a>
<a name="ln5475">  if (i != OK) {</a>
<a name="ln5476">    if (!aborting()) {</a>
<a name="ln5477">      semsg(_(e_notopen), eap-&gt;arg);</a>
<a name="ln5478">    }</a>
<a name="ln5479">  } else {</a>
<a name="ln5480">    if (empty &amp;&amp; exmode_active) {</a>
<a name="ln5481">      // Delete the empty line that remains.  Historically ex does</a>
<a name="ln5482">      // this but vi doesn't.</a>
<a name="ln5483">      linenr_T lnum;</a>
<a name="ln5484">      if (eap-&gt;line2 == 0) {</a>
<a name="ln5485">        lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln5486">      } else {</a>
<a name="ln5487">        lnum = 1;</a>
<a name="ln5488">      }</a>
<a name="ln5489">      if (*ml_get(lnum) == NUL &amp;&amp; u_savedel(lnum, 1L) == OK) {</a>
<a name="ln5490">        ml_delete(lnum, false);</a>
<a name="ln5491">        if (curwin-&gt;w_cursor.lnum &gt; 1</a>
<a name="ln5492">            &amp;&amp; curwin-&gt;w_cursor.lnum &gt;= lnum) {</a>
<a name="ln5493">          curwin-&gt;w_cursor.lnum--;</a>
<a name="ln5494">        }</a>
<a name="ln5495">        deleted_lines_mark(lnum, 1L);</a>
<a name="ln5496">      }</a>
<a name="ln5497">    }</a>
<a name="ln5498">    redraw_curbuf_later(UPD_VALID);</a>
<a name="ln5499">  }</a>
<a name="ln5500">}</a>
<a name="ln5501"> </a>
<a name="ln5502">static char *prev_dir = NULL;</a>
<a name="ln5503"> </a>
<a name="ln5504">#if defined(EXITFREE)</a>
<a name="ln5505">void free_cd_dir(void)</a>
<a name="ln5506">{</a>
<a name="ln5507">  XFREE_CLEAR(prev_dir);</a>
<a name="ln5508">  XFREE_CLEAR(globaldir);</a>
<a name="ln5509">}</a>
<a name="ln5510"> </a>
<a name="ln5511">#endif</a>
<a name="ln5512"> </a>
<a name="ln5513">/// Get the previous directory for the given chdir scope.</a>
<a name="ln5514">static char *get_prevdir(CdScope scope)</a>
<a name="ln5515">{</a>
<a name="ln5516">  switch (scope) {</a>
<a name="ln5517">  case kCdScopeTabpage:</a>
<a name="ln5518">    return curtab-&gt;tp_prevdir;</a>
<a name="ln5519">    break;</a>
<a name="ln5520">  case kCdScopeWindow:</a>
<a name="ln5521">    return curwin-&gt;w_prevdir;</a>
<a name="ln5522">    break;</a>
<a name="ln5523">  default:</a>
<a name="ln5524">    return prev_dir;</a>
<a name="ln5525">  }</a>
<a name="ln5526">}</a>
<a name="ln5527"> </a>
<a name="ln5528">/// Deal with the side effects of changing the current directory.</a>
<a name="ln5529">///</a>
<a name="ln5530">/// @param scope  Scope of the function call (global, tab or window).</a>
<a name="ln5531">static void post_chdir(CdScope scope, bool trigger_dirchanged)</a>
<a name="ln5532">{</a>
<a name="ln5533">  // Always overwrite the window-local CWD.</a>
<a name="ln5534">  XFREE_CLEAR(curwin-&gt;w_localdir);</a>
<a name="ln5535"> </a>
<a name="ln5536">  // Overwrite the tab-local CWD for :cd, :tcd.</a>
<a name="ln5537">  if (scope &gt;= kCdScopeTabpage) {</a>
<a name="ln5538">    XFREE_CLEAR(curtab-&gt;tp_localdir);</a>
<a name="ln5539">  }</a>
<a name="ln5540"> </a>
<a name="ln5541">  if (scope &lt; kCdScopeGlobal) {</a>
<a name="ln5542">    char *pdir = get_prevdir(scope);</a>
<a name="ln5543">    // If still in global directory, set CWD as the global directory.</a>
<a name="ln5544">    if (globaldir == NULL &amp;&amp; pdir != NULL) {</a>
<a name="ln5545">      globaldir = xstrdup(pdir);</a>
<a name="ln5546">    }</a>
<a name="ln5547">  }</a>
<a name="ln5548"> </a>
<a name="ln5549">  char cwd[MAXPATHL];</a>
<a name="ln5550">  if (os_dirname(cwd, MAXPATHL) != OK) {</a>
<a name="ln5551">    return;</a>
<a name="ln5552">  }</a>
<a name="ln5553">  switch (scope) {</a>
<a name="ln5554">  case kCdScopeGlobal:</a>
<a name="ln5555">    // We are now in the global directory, no need to remember its name.</a>
<a name="ln5556">    XFREE_CLEAR(globaldir);</a>
<a name="ln5557">    break;</a>
<a name="ln5558">  case kCdScopeTabpage:</a>
<a name="ln5559">    curtab-&gt;tp_localdir = xstrdup(cwd);</a>
<a name="ln5560">    break;</a>
<a name="ln5561">  case kCdScopeWindow:</a>
<a name="ln5562">    curwin-&gt;w_localdir = xstrdup(cwd);</a>
<a name="ln5563">    break;</a>
<a name="ln5564">  case kCdScopeInvalid:</a>
<a name="ln5565">    abort();</a>
<a name="ln5566">  }</a>
<a name="ln5567"> </a>
<a name="ln5568">  last_chdir_reason = NULL;</a>
<a name="ln5569">  shorten_fnames(true);</a>
<a name="ln5570"> </a>
<a name="ln5571">  if (trigger_dirchanged) {</a>
<a name="ln5572">    do_autocmd_dirchanged(cwd, scope, kCdCauseManual, false);</a>
<a name="ln5573">  }</a>
<a name="ln5574">}</a>
<a name="ln5575"> </a>
<a name="ln5576">/// Change directory function used by :cd/:tcd/:lcd Ex commands and the chdir() function.</a>
<a name="ln5577">/// @param new_dir  The directory to change to.</a>
<a name="ln5578">/// @param scope    Scope of the function call (global, tab or window).</a>
<a name="ln5579">/// @return true if the directory is successfully changed.</a>
<a name="ln5580">bool changedir_func(char *new_dir, CdScope scope)</a>
<a name="ln5581">{</a>
<a name="ln5582">  if (new_dir == NULL || allbuf_locked()) {</a>
<a name="ln5583">    return false;</a>
<a name="ln5584">  }</a>
<a name="ln5585"> </a>
<a name="ln5586">  char *pdir = NULL;</a>
<a name="ln5587">  // &quot;:cd -&quot;: Change to previous directory</a>
<a name="ln5588">  if (strcmp(new_dir, &quot;-&quot;) == 0) {</a>
<a name="ln5589">    pdir = get_prevdir(scope);</a>
<a name="ln5590">    if (pdir == NULL) {</a>
<a name="ln5591">      emsg(_(&quot;E186: No previous directory&quot;));</a>
<a name="ln5592">      return false;</a>
<a name="ln5593">    }</a>
<a name="ln5594">    new_dir = pdir;</a>
<a name="ln5595">  }</a>
<a name="ln5596"> </a>
<a name="ln5597">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5598">    pdir = xstrdup(NameBuff);</a>
<a name="ln5599">  } else {</a>
<a name="ln5600">    pdir = NULL;</a>
<a name="ln5601">  }</a>
<a name="ln5602"> </a>
<a name="ln5603">  // For UNIX &quot;:cd&quot; means: go to home directory.</a>
<a name="ln5604">  // On other systems too if 'cdhome' is set.</a>
<a name="ln5605">#if defined(UNIX)</a>
<a name="ln5606">  if (*new_dir == NUL) {</a>
<a name="ln5607">#else</a>
<a name="ln5608">  if (*new_dir == NUL &amp;&amp; p_cdh) {</a>
<a name="ln5609">#endif</a>
<a name="ln5610">    // Use NameBuff for home directory name.</a>
<a name="ln5611">    expand_env(&quot;$HOME&quot;, NameBuff, MAXPATHL);</a>
<a name="ln5612">    new_dir = NameBuff;</a>
<a name="ln5613">  }</a>
<a name="ln5614"> </a>
<a name="ln5615">  bool dir_differs = pdir == NULL || pathcmp(pdir, new_dir, -1) != 0;</a>
<a name="ln5616">  if (dir_differs) {</a>
<a name="ln5617">    do_autocmd_dirchanged(new_dir, scope, kCdCauseManual, true);</a>
<a name="ln5618">    if (vim_chdir(new_dir) != 0) {</a>
<a name="ln5619">      emsg(_(e_failed));</a>
<a name="ln5620">      xfree(pdir);</a>
<a name="ln5621">      return false;</a>
<a name="ln5622">    }</a>
<a name="ln5623">  }</a>
<a name="ln5624"> </a>
<a name="ln5625">  char **pp;</a>
<a name="ln5626">  switch (scope) {</a>
<a name="ln5627">  case kCdScopeTabpage:</a>
<a name="ln5628">    pp = &amp;curtab-&gt;tp_prevdir;</a>
<a name="ln5629">    break;</a>
<a name="ln5630">  case kCdScopeWindow:</a>
<a name="ln5631">    pp = &amp;curwin-&gt;w_prevdir;</a>
<a name="ln5632">    break;</a>
<a name="ln5633">  default:</a>
<a name="ln5634">    pp = &amp;prev_dir;</a>
<a name="ln5635">  }</a>
<a name="ln5636">  xfree(*pp);</a>
<a name="ln5637">  *pp = pdir;</a>
<a name="ln5638"> </a>
<a name="ln5639">  post_chdir(scope, dir_differs);</a>
<a name="ln5640"> </a>
<a name="ln5641">  return true;</a>
<a name="ln5642">}</a>
<a name="ln5643"> </a>
<a name="ln5644">/// &quot;:cd&quot;, &quot;:tcd&quot;, &quot;:lcd&quot;, &quot;:chdir&quot;, &quot;tchdir&quot; and &quot;:lchdir&quot;.</a>
<a name="ln5645">void ex_cd(exarg_T *eap)</a>
<a name="ln5646">{</a>
<a name="ln5647">  char *new_dir = eap-&gt;arg;</a>
<a name="ln5648">#if !defined(UNIX)</a>
<a name="ln5649">  // for non-UNIX &quot;:cd&quot; means: print current directory unless 'cdhome' is set</a>
<a name="ln5650">  if (*new_dir == NUL &amp;&amp; !p_cdh) {</a>
<a name="ln5651">    ex_pwd(NULL);</a>
<a name="ln5652">    return;</a>
<a name="ln5653">  }</a>
<a name="ln5654">#endif</a>
<a name="ln5655"> </a>
<a name="ln5656">  CdScope scope = kCdScopeGlobal;</a>
<a name="ln5657">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5658">  case CMD_tcd:</a>
<a name="ln5659">  case CMD_tchdir:</a>
<a name="ln5660">    scope = kCdScopeTabpage;</a>
<a name="ln5661">    break;</a>
<a name="ln5662">  case CMD_lcd:</a>
<a name="ln5663">  case CMD_lchdir:</a>
<a name="ln5664">    scope = kCdScopeWindow;</a>
<a name="ln5665">    break;</a>
<a name="ln5666">  default:</a>
<a name="ln5667">    break;</a>
<a name="ln5668">  }</a>
<a name="ln5669">  if (changedir_func(new_dir, scope)) {</a>
<a name="ln5670">    // Echo the new current directory if the command was typed.</a>
<a name="ln5671">    if (KeyTyped || p_verbose &gt;= 5) {</a>
<a name="ln5672">      ex_pwd(eap);</a>
<a name="ln5673">    }</a>
<a name="ln5674">  }</a>
<a name="ln5675">}</a>
<a name="ln5676"> </a>
<a name="ln5677">/// &quot;:pwd&quot;.</a>
<a name="ln5678">static void ex_pwd(exarg_T *eap)</a>
<a name="ln5679">{</a>
<a name="ln5680">  if (os_dirname(NameBuff, MAXPATHL) == OK) {</a>
<a name="ln5681">#ifdef BACKSLASH_IN_FILENAME</a>
<a name="ln5682">    slash_adjust(NameBuff);</a>
<a name="ln5683">#endif</a>
<a name="ln5684">    if (p_verbose &gt; 0) {</a>
<a name="ln5685">      char *context = &quot;global&quot;;</a>
<a name="ln5686">      if (last_chdir_reason != NULL) {</a>
<a name="ln5687">        context = last_chdir_reason;</a>
<a name="ln5688">      } else if (curwin-&gt;w_localdir != NULL) {</a>
<a name="ln5689">        context = &quot;window&quot;;</a>
<a name="ln5690">      } else if (curtab-&gt;tp_localdir != NULL) {</a>
<a name="ln5691">        context = &quot;tabpage&quot;;</a>
<a name="ln5692">      }</a>
<a name="ln5693">      smsg(&quot;[%s] %s&quot;, context, NameBuff);</a>
<a name="ln5694">    } else {</a>
<a name="ln5695">      msg(NameBuff);</a>
<a name="ln5696">    }</a>
<a name="ln5697">  } else {</a>
<a name="ln5698">    emsg(_(&quot;E187: Unknown&quot;));</a>
<a name="ln5699">  }</a>
<a name="ln5700">}</a>
<a name="ln5701"> </a>
<a name="ln5702">/// &quot;:=&quot;.</a>
<a name="ln5703">static void ex_equal(exarg_T *eap)</a>
<a name="ln5704">{</a>
<a name="ln5705">  if (*eap-&gt;arg != NUL &amp;&amp; *eap-&gt;arg != '|') {</a>
<a name="ln5706">    // equivalent to :lua= expr</a>
<a name="ln5707">    ex_lua(eap);</a>
<a name="ln5708">  } else {</a>
<a name="ln5709">    eap-&gt;nextcmd = find_nextcmd(eap-&gt;arg);</a>
<a name="ln5710">    smsg(&quot;%&quot; PRId64, (int64_t)eap-&gt;line2);</a>
<a name="ln5711">  }</a>
<a name="ln5712">}</a>
<a name="ln5713"> </a>
<a name="ln5714">static void ex_sleep(exarg_T *eap)</a>
<a name="ln5715">{</a>
<a name="ln5716">  if (cursor_valid()) {</a>
<a name="ln5717">    setcursor_mayforce(true);</a>
<a name="ln5718">  }</a>
<a name="ln5719"> </a>
<a name="ln5720">  int64_t len = eap-&gt;line2;</a>
<a name="ln5721">  switch (*eap-&gt;arg) {</a>
<a name="ln5722">  case 'm':</a>
<a name="ln5723">    break;</a>
<a name="ln5724">  case NUL:</a>
<a name="ln5725">    len *= 1000L; break;</a>
<a name="ln5726">  default:</a>
<a name="ln5727">    semsg(_(e_invarg2), eap-&gt;arg); return;</a>
<a name="ln5728">  }</a>
<a name="ln5729">  do_sleep(len);</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732">/// Sleep for &quot;msec&quot; milliseconds, but return early on CTRL-C.</a>
<a name="ln5733">void do_sleep(int64_t msec)</a>
<a name="ln5734">{</a>
<a name="ln5735">  ui_flush();  // flush before waiting</a>
<a name="ln5736">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, main_loop.events, msec, got_int);</a>
<a name="ln5737"> </a>
<a name="ln5738">  // If CTRL-C was typed to interrupt the sleep, drop the CTRL-C from the</a>
<a name="ln5739">  // input buffer, otherwise a following call to input() fails.</a>
<a name="ln5740">  if (got_int) {</a>
<a name="ln5741">    (void)vpeekc();</a>
<a name="ln5742">  }</a>
<a name="ln5743">}</a>
<a name="ln5744"> </a>
<a name="ln5745">/// &quot;:winsize&quot; command (obsolete).</a>
<a name="ln5746">static void ex_winsize(exarg_T *eap)</a>
<a name="ln5747">{</a>
<a name="ln5748">  char *arg = eap-&gt;arg;</a>
<a name="ln5749"> </a>
<a name="ln5750">  if (!ascii_isdigit(*arg)) {</a>
<a name="ln5751">    semsg(_(e_invarg2), arg);</a>
<a name="ln5752">    return;</a>
<a name="ln5753">  }</a>
<a name="ln5754">  int w = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5755">  arg = skipwhite(arg);</a>
<a name="ln5756">  char *p = arg;</a>
<a name="ln5757">  int h = getdigits_int(&amp;arg, false, 10);</a>
<a name="ln5758">  if (*p != NUL &amp;&amp; *arg == NUL) {</a>
<a name="ln5759">    screen_resize(w, h);</a>
<a name="ln5760">  } else {</a>
<a name="ln5761">    emsg(_(&quot;E465: :winsize requires two number arguments&quot;));</a>
<a name="ln5762">  }</a>
<a name="ln5763">}</a>
<a name="ln5764"> </a>
<a name="ln5765">static void ex_wincmd(exarg_T *eap)</a>
<a name="ln5766">{</a>
<a name="ln5767">  int xchar = NUL;</a>
<a name="ln5768">  char *p;</a>
<a name="ln5769"> </a>
<a name="ln5770">  if (*eap-&gt;arg == 'g' || *eap-&gt;arg == Ctrl_G) {</a>
<a name="ln5771">    // CTRL-W g and CTRL-W CTRL-G  have an extra command character</a>
<a name="ln5772">    if (eap-&gt;arg[1] == NUL) {</a>
<a name="ln5773">      emsg(_(e_invarg));</a>
<a name="ln5774">      return;</a>
<a name="ln5775">    }</a>
<a name="ln5776">    xchar = (uint8_t)eap-&gt;arg[1];</a>
<a name="ln5777">    p = eap-&gt;arg + 2;</a>
<a name="ln5778">  } else {</a>
<a name="ln5779">    p = eap-&gt;arg + 1;</a>
<a name="ln5780">  }</a>
<a name="ln5781"> </a>
<a name="ln5782">  eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln5783">  p = skipwhite(p);</a>
<a name="ln5784">  if (*p != NUL &amp;&amp; *p != '&quot;' &amp;&amp; eap-&gt;nextcmd == NULL) {</a>
<a name="ln5785">    emsg(_(e_invarg));</a>
<a name="ln5786">  } else if (!eap-&gt;skip) {</a>
<a name="ln5787">    // Pass flags on for &quot;:vertical wincmd ]&quot;.</a>
<a name="ln5788">    postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln5789">    postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln5790">    do_window(*eap-&gt;arg, eap-&gt;addr_count &gt; 0 ? eap-&gt;line2 : 0L, xchar);</a>
<a name="ln5791">    postponed_split_flags = 0;</a>
<a name="ln5792">    postponed_split_tab = 0;</a>
<a name="ln5793">  }</a>
<a name="ln5794">}</a>
<a name="ln5795"> </a>
<a name="ln5796">/// Handle command that work like operators: &quot;:delete&quot;, &quot;:yank&quot;, &quot;:&gt;&quot; and &quot;:&lt;&quot;.</a>
<a name="ln5797">static void ex_operators(exarg_T *eap)</a>
<a name="ln5798">{</a>
<a name="ln5799">  oparg_T oa;</a>
<a name="ln5800"> </a>
<a name="ln5801">  clear_oparg(&amp;oa);</a>
<a name="ln5802">  oa.regname = eap-&gt;regname;</a>
<a name="ln5803">  oa.start.lnum = eap-&gt;line1;</a>
<a name="ln5804">  oa.end.lnum = eap-&gt;line2;</a>
<a name="ln5805">  oa.line_count = eap-&gt;line2 - eap-&gt;line1 + 1;</a>
<a name="ln5806">  oa.motion_type = kMTLineWise;</a>
<a name="ln5807">  virtual_op = kFalse;</a>
<a name="ln5808">  if (eap-&gt;cmdidx != CMD_yank) {  // position cursor for undo</a>
<a name="ln5809">    setpcmark();</a>
<a name="ln5810">    curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5811">    beginline(BL_SOL | BL_FIX);</a>
<a name="ln5812">  }</a>
<a name="ln5813"> </a>
<a name="ln5814">  if (VIsual_active) {</a>
<a name="ln5815">    end_visual_mode();</a>
<a name="ln5816">  }</a>
<a name="ln5817"> </a>
<a name="ln5818">  switch (eap-&gt;cmdidx) {</a>
<a name="ln5819">  case CMD_delete:</a>
<a name="ln5820">    oa.op_type = OP_DELETE;</a>
<a name="ln5821">    op_delete(&amp;oa);</a>
<a name="ln5822">    break;</a>
<a name="ln5823"> </a>
<a name="ln5824">  case CMD_yank:</a>
<a name="ln5825">    oa.op_type = OP_YANK;</a>
<a name="ln5826">    (void)op_yank(&amp;oa, true);</a>
<a name="ln5827">    break;</a>
<a name="ln5828"> </a>
<a name="ln5829">  default:          // CMD_rshift or CMD_lshift</a>
<a name="ln5830">    if (</a>
<a name="ln5831">        (eap-&gt;cmdidx == CMD_rshift) ^ curwin-&gt;w_p_rl) {</a>
<a name="ln5832">      oa.op_type = OP_RSHIFT;</a>
<a name="ln5833">    } else {</a>
<a name="ln5834">      oa.op_type = OP_LSHIFT;</a>
<a name="ln5835">    }</a>
<a name="ln5836">    op_shift(&amp;oa, false, eap-&gt;amount);</a>
<a name="ln5837">    break;</a>
<a name="ln5838">  }</a>
<a name="ln5839">  virtual_op = kNone;</a>
<a name="ln5840">  ex_may_print(eap);</a>
<a name="ln5841">}</a>
<a name="ln5842"> </a>
<a name="ln5843">/// &quot;:put&quot;.</a>
<a name="ln5844">static void ex_put(exarg_T *eap)</a>
<a name="ln5845">{</a>
<a name="ln5846">  // &quot;:0put&quot; works like &quot;:1put!&quot;.</a>
<a name="ln5847">  if (eap-&gt;line2 == 0) {</a>
<a name="ln5848">    eap-&gt;line2 = 1;</a>
<a name="ln5849">    eap-&gt;forceit = true;</a>
<a name="ln5850">  }</a>
<a name="ln5851">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5852">  check_cursor_col();</a>
<a name="ln5853">  do_put(eap-&gt;regname, NULL, eap-&gt;forceit ? BACKWARD : FORWARD, 1,</a>
<a name="ln5854">         PUT_LINE|PUT_CURSLINE);</a>
<a name="ln5855">}</a>
<a name="ln5856"> </a>
<a name="ln5857">/// Handle &quot;:copy&quot; and &quot;:move&quot;.</a>
<a name="ln5858">static void ex_copymove(exarg_T *eap)</a>
<a name="ln5859">{</a>
<a name="ln5860">  const char *errormsg = NULL;</a>
<a name="ln5861">  linenr_T n = get_address(eap, &amp;eap-&gt;arg, eap-&gt;addr_type, false, false, false, 1, &amp;errormsg);</a>
<a name="ln5862">  if (eap-&gt;arg == NULL) {  // error detected</a>
<a name="ln5863">    if (errormsg != NULL) {</a>
<a name="ln5864">      emsg(errormsg);</a>
<a name="ln5865">    }</a>
<a name="ln5866">    eap-&gt;nextcmd = NULL;</a>
<a name="ln5867">    return;</a>
<a name="ln5868">  }</a>
<a name="ln5869">  get_flags(eap);</a>
<a name="ln5870"> </a>
<a name="ln5871">  // move or copy lines from 'eap-&gt;line1'-'eap-&gt;line2' to below line 'n'</a>
<a name="ln5872">  if (n == MAXLNUM || n &lt; 0 || n &gt; curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5873">    emsg(_(e_invrange));</a>
<a name="ln5874">    return;</a>
<a name="ln5875">  }</a>
<a name="ln5876"> </a>
<a name="ln5877">  if (eap-&gt;cmdidx == CMD_move) {</a>
<a name="ln5878">    if (do_move(eap-&gt;line1, eap-&gt;line2, n) == FAIL) {</a>
<a name="ln5879">      return;</a>
<a name="ln5880">    }</a>
<a name="ln5881">  } else {</a>
<a name="ln5882">    ex_copy(eap-&gt;line1, eap-&gt;line2, n);</a>
<a name="ln5883">  }</a>
<a name="ln5884">  u_clearline(curbuf);</a>
<a name="ln5885">  beginline(BL_SOL | BL_FIX);</a>
<a name="ln5886">  ex_may_print(eap);</a>
<a name="ln5887">}</a>
<a name="ln5888"> </a>
<a name="ln5889">/// Print the current line if flags were given to the Ex command.</a>
<a name="ln5890">void ex_may_print(exarg_T *eap)</a>
<a name="ln5891">{</a>
<a name="ln5892">  if (eap-&gt;flags != 0) {</a>
<a name="ln5893">    print_line(curwin-&gt;w_cursor.lnum, (eap-&gt;flags &amp; EXFLAG_NR),</a>
<a name="ln5894">               (eap-&gt;flags &amp; EXFLAG_LIST));</a>
<a name="ln5895">    ex_no_reprint = true;</a>
<a name="ln5896">  }</a>
<a name="ln5897">}</a>
<a name="ln5898"> </a>
<a name="ln5899">/// &quot;:smagic&quot; and &quot;:snomagic&quot;.</a>
<a name="ln5900">static void ex_submagic(exarg_T *eap)</a>
<a name="ln5901">{</a>
<a name="ln5902">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5903"> </a>
<a name="ln5904">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5905">  ex_substitute(eap);</a>
<a name="ln5906">  magic_overruled = saved;</a>
<a name="ln5907">}</a>
<a name="ln5908"> </a>
<a name="ln5909">/// &quot;:smagic&quot; and &quot;:snomagic&quot; preview callback.</a>
<a name="ln5910">static int ex_submagic_preview(exarg_T *eap, long cmdpreview_ns, handle_T cmdpreview_bufnr)</a>
<a name="ln5911">{</a>
<a name="ln5912">  const optmagic_T saved = magic_overruled;</a>
<a name="ln5913"> </a>
<a name="ln5914">  magic_overruled = eap-&gt;cmdidx == CMD_smagic ? OPTION_MAGIC_ON : OPTION_MAGIC_OFF;</a>
<a name="ln5915">  int retv = ex_substitute_preview(eap, cmdpreview_ns, cmdpreview_bufnr);</a>
<a name="ln5916">  magic_overruled = saved;</a>
<a name="ln5917"> </a>
<a name="ln5918">  return retv;</a>
<a name="ln5919">}</a>
<a name="ln5920"> </a>
<a name="ln5921">/// &quot;:join&quot;.</a>
<a name="ln5922">static void ex_join(exarg_T *eap)</a>
<a name="ln5923">{</a>
<a name="ln5924">  curwin-&gt;w_cursor.lnum = eap-&gt;line1;</a>
<a name="ln5925">  if (eap-&gt;line1 == eap-&gt;line2) {</a>
<a name="ln5926">    if (eap-&gt;addr_count &gt;= 2) {     // :2,2join does nothing</a>
<a name="ln5927">      return;</a>
<a name="ln5928">    }</a>
<a name="ln5929">    if (eap-&gt;line2 == curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln5930">      beep_flush();</a>
<a name="ln5931">      return;</a>
<a name="ln5932">    }</a>
<a name="ln5933">    eap-&gt;line2++;</a>
<a name="ln5934">  }</a>
<a name="ln5935">  do_join((size_t)((ssize_t)eap-&gt;line2 - eap-&gt;line1 + 1), !eap-&gt;forceit, true, true, true);</a>
<a name="ln5936">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln5937">  ex_may_print(eap);</a>
<a name="ln5938">}</a>
<a name="ln5939"> </a>
<a name="ln5940">/// &quot;:[addr]@r&quot;: execute register</a>
<a name="ln5941">static void ex_at(exarg_T *eap)</a>
<a name="ln5942">{</a>
<a name="ln5943">  int prev_len = typebuf.tb_len;</a>
<a name="ln5944"> </a>
<a name="ln5945">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln5946">  check_cursor_col();</a>
<a name="ln5947"> </a>
<a name="ln5948">  // Get the register name. No name means use the previous one.</a>
<a name="ln5949">  int c = (uint8_t)(*eap-&gt;arg);</a>
<a name="ln5950">  if (c == NUL) {</a>
<a name="ln5951">    c = '@';</a>
<a name="ln5952">  }</a>
<a name="ln5953"> </a>
<a name="ln5954">  // Put the register in the typeahead buffer with the &quot;silent&quot; flag.</a>
<a name="ln5955">  if (do_execreg(c, true, vim_strchr(p_cpo, CPO_EXECBUF) != NULL, true) == FAIL) {</a>
<a name="ln5956">    beep_flush();</a>
<a name="ln5957">    return;</a>
<a name="ln5958">  }</a>
<a name="ln5959"> </a>
<a name="ln5960">  const bool save_efr = exec_from_reg;</a>
<a name="ln5961"> </a>
<a name="ln5962">  exec_from_reg = true;</a>
<a name="ln5963"> </a>
<a name="ln5964">  // Execute from the typeahead buffer.</a>
<a name="ln5965">  // Continue until the stuff buffer is empty and all added characters</a>
<a name="ln5966">  // have been consumed.</a>
<a name="ln5967">  while (!stuff_empty() || typebuf.tb_len &gt; prev_len) {</a>
<a name="ln5968">    (void)do_cmdline(NULL, getexline, NULL, DOCMD_NOWAIT|DOCMD_VERBOSE);</a>
<a name="ln5969">  }</a>
<a name="ln5970"> </a>
<a name="ln5971">  exec_from_reg = save_efr;</a>
<a name="ln5972">}</a>
<a name="ln5973"> </a>
<a name="ln5974">/// &quot;:!&quot;.</a>
<a name="ln5975">static void ex_bang(exarg_T *eap)</a>
<a name="ln5976">{</a>
<a name="ln5977">  do_bang(eap-&gt;addr_count, eap, eap-&gt;forceit, true, true);</a>
<a name="ln5978">}</a>
<a name="ln5979"> </a>
<a name="ln5980">/// &quot;:undo&quot;.</a>
<a name="ln5981">static void ex_undo(exarg_T *eap)</a>
<a name="ln5982">{</a>
<a name="ln5983">  if (eap-&gt;addr_count != 1) {</a>
<a name="ln5984">    if (eap-&gt;forceit) {</a>
<a name="ln5985">      u_undo_and_forget(1, true);   // :undo!</a>
<a name="ln5986">    } else {</a>
<a name="ln5987">      u_undo(1);                    // :undo</a>
<a name="ln5988">    }</a>
<a name="ln5989">    return;</a>
<a name="ln5990">  }</a>
<a name="ln5991"> </a>
<a name="ln5992">  linenr_T step = eap-&gt;line2;</a>
<a name="ln5993"> </a>
<a name="ln5994">  if (eap-&gt;forceit) {             // undo! 123</a>
<a name="ln5995">    // change number for &quot;undo!&quot; must be lesser than current change number</a>
<a name="ln5996">    if (step &gt;= curbuf-&gt;b_u_seq_cur) {</a>
<a name="ln5997">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln5998">      return;</a>
<a name="ln5999">    }</a>
<a name="ln6000">    // ensure that target change number is in same branch</a>
<a name="ln6001">    // while also counting the amount of undoes it'd take to reach target</a>
<a name="ln6002">    u_header_T *uhp;</a>
<a name="ln6003">    int count = 0;</a>
<a name="ln6004"> </a>
<a name="ln6005">    for (uhp = curbuf-&gt;b_u_curhead ? curbuf-&gt;b_u_curhead : curbuf-&gt;b_u_newhead;</a>
<a name="ln6006">         uhp != NULL &amp;&amp; uhp-&gt;uh_seq &gt; step;</a>
<a name="ln6007">         uhp = uhp-&gt;uh_next.ptr, ++count) {}</a>
<a name="ln6008">    if (step != 0 &amp;&amp; (uhp == NULL || uhp-&gt;uh_seq &lt; step)) {</a>
<a name="ln6009">      emsg(_(e_undobang_cannot_redo_or_move_branch));</a>
<a name="ln6010">      return;</a>
<a name="ln6011">    }</a>
<a name="ln6012">    u_undo_and_forget(count, true);</a>
<a name="ln6013">  } else {                        // :undo 123</a>
<a name="ln6014">    undo_time(step, false, false, true);</a>
<a name="ln6015">  }</a>
<a name="ln6016">}</a>
<a name="ln6017"> </a>
<a name="ln6018">static void ex_wundo(exarg_T *eap)</a>
<a name="ln6019">{</a>
<a name="ln6020">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6021"> </a>
<a name="ln6022">  u_compute_hash(curbuf, hash);</a>
<a name="ln6023">  u_write_undo(eap-&gt;arg, eap-&gt;forceit, curbuf, hash);</a>
<a name="ln6024">}</a>
<a name="ln6025"> </a>
<a name="ln6026">static void ex_rundo(exarg_T *eap)</a>
<a name="ln6027">{</a>
<a name="ln6028">  uint8_t hash[UNDO_HASH_SIZE];</a>
<a name="ln6029"> </a>
<a name="ln6030">  u_compute_hash(curbuf, hash);</a>
<a name="ln6031">  u_read_undo(eap-&gt;arg, hash, NULL);</a>
<a name="ln6032">}</a>
<a name="ln6033"> </a>
<a name="ln6034">/// &quot;:redo&quot;.</a>
<a name="ln6035">static void ex_redo(exarg_T *eap)</a>
<a name="ln6036">{</a>
<a name="ln6037">  u_redo(1);</a>
<a name="ln6038">}</a>
<a name="ln6039"> </a>
<a name="ln6040">/// &quot;:earlier&quot; and &quot;:later&quot;.</a>
<a name="ln6041">static void ex_later(exarg_T *eap)</a>
<a name="ln6042">{</a>
<a name="ln6043">  long count = 0;</a>
<a name="ln6044">  bool sec = false;</a>
<a name="ln6045">  bool file = false;</a>
<a name="ln6046">  char *p = eap-&gt;arg;</a>
<a name="ln6047"> </a>
<a name="ln6048">  if (*p == NUL) {</a>
<a name="ln6049">    count = 1;</a>
<a name="ln6050">  } else if (isdigit((uint8_t)(*p))) {</a>
<a name="ln6051">    count = getdigits_long(&amp;p, false, 0);</a>
<a name="ln6052">    switch (*p) {</a>
<a name="ln6053">    case 's':</a>
<a name="ln6054">      p++; sec = true; break;</a>
<a name="ln6055">    case 'm':</a>
<a name="ln6056">      p++; sec = true; count *= 60; break;</a>
<a name="ln6057">    case 'h':</a>
<a name="ln6058">      p++; sec = true; count *= 60 * 60; break;</a>
<a name="ln6059">    case 'd':</a>
<a name="ln6060">      p++; sec = true; count *= 24 * 60 * 60; break;</a>
<a name="ln6061">    case 'f':</a>
<a name="ln6062">      p++; file = true; break;</a>
<a name="ln6063">    }</a>
<a name="ln6064">  }</a>
<a name="ln6065"> </a>
<a name="ln6066">  if (*p != NUL) {</a>
<a name="ln6067">    semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6068">  } else {</a>
<a name="ln6069">    undo_time(eap-&gt;cmdidx == CMD_earlier ? -count : count,</a>
<a name="ln6070">              sec, file, false);</a>
<a name="ln6071">  }</a>
<a name="ln6072">}</a>
<a name="ln6073"> </a>
<a name="ln6074">/// &quot;:redir&quot;: start/stop redirection.</a>
<a name="ln6075">static void ex_redir(exarg_T *eap)</a>
<a name="ln6076">{</a>
<a name="ln6077">  char *arg = eap-&gt;arg;</a>
<a name="ln6078"> </a>
<a name="ln6079">  if (STRICMP(eap-&gt;arg, &quot;END&quot;) == 0) {</a>
<a name="ln6080">    close_redir();</a>
<a name="ln6081">  } else {</a>
<a name="ln6082">    if (*arg == '&gt;') {</a>
<a name="ln6083">      arg++;</a>
<a name="ln6084">      char *mode;</a>
<a name="ln6085">      if (*arg == '&gt;') {</a>
<a name="ln6086">        arg++;</a>
<a name="ln6087">        mode = &quot;a&quot;;</a>
<a name="ln6088">      } else {</a>
<a name="ln6089">        mode = &quot;w&quot;;</a>
<a name="ln6090">      }</a>
<a name="ln6091">      arg = skipwhite(arg);</a>
<a name="ln6092"> </a>
<a name="ln6093">      close_redir();</a>
<a name="ln6094"> </a>
<a name="ln6095">      // Expand environment variables and &quot;~/&quot;.</a>
<a name="ln6096">      char *fname = expand_env_save(arg);</a>
<a name="ln6097">      if (fname == NULL) {</a>
<a name="ln6098">        return;</a>
<a name="ln6099">      }</a>
<a name="ln6100"> </a>
<a name="ln6101">      redir_fd = open_exfile(fname, eap-&gt;forceit, mode);</a>
<a name="ln6102">      xfree(fname);</a>
<a name="ln6103">    } else if (*arg == '@') {</a>
<a name="ln6104">      // redirect to a register a-z (resp. A-Z for appending)</a>
<a name="ln6105">      close_redir();</a>
<a name="ln6106">      arg++;</a>
<a name="ln6107">      if (valid_yank_reg(*arg, true) &amp;&amp; *arg != '_') {</a>
<a name="ln6108">        redir_reg = (uint8_t)(*arg++);</a>
<a name="ln6109">        if (*arg == '&gt;' &amp;&amp; arg[1] == '&gt;') {        // append</a>
<a name="ln6110">          arg += 2;</a>
<a name="ln6111">        } else {</a>
<a name="ln6112">          // Can use both &quot;@a&quot; and &quot;@a&gt;&quot;.</a>
<a name="ln6113">          if (*arg == '&gt;') {</a>
<a name="ln6114">            arg++;</a>
<a name="ln6115">          }</a>
<a name="ln6116">          // Make register empty when not using @A-@Z and the</a>
<a name="ln6117">          // command is valid.</a>
<a name="ln6118">          if (*arg == NUL &amp;&amp; !isupper(redir_reg)) {</a>
<a name="ln6119">            write_reg_contents(redir_reg, &quot;&quot;, 0, false);</a>
<a name="ln6120">          }</a>
<a name="ln6121">        }</a>
<a name="ln6122">      }</a>
<a name="ln6123">      if (*arg != NUL) {</a>
<a name="ln6124">        redir_reg = 0;</a>
<a name="ln6125">        semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6126">      }</a>
<a name="ln6127">    } else if (*arg == '=' &amp;&amp; arg[1] == '&gt;') {</a>
<a name="ln6128">      int append;</a>
<a name="ln6129"> </a>
<a name="ln6130">      // redirect to a variable</a>
<a name="ln6131">      close_redir();</a>
<a name="ln6132">      arg += 2;</a>
<a name="ln6133"> </a>
<a name="ln6134">      if (*arg == '&gt;') {</a>
<a name="ln6135">        arg++;</a>
<a name="ln6136">        append = true;</a>
<a name="ln6137">      } else {</a>
<a name="ln6138">        append = false;</a>
<a name="ln6139">      }</a>
<a name="ln6140"> </a>
<a name="ln6141">      if (var_redir_start(skipwhite(arg), append) == OK) {</a>
<a name="ln6142">        redir_vname = 1;</a>
<a name="ln6143">      }</a>
<a name="ln6144">    } else {  // TODO(vim): redirect to a buffer</a>
<a name="ln6145">      semsg(_(e_invarg2), eap-&gt;arg);</a>
<a name="ln6146">    }</a>
<a name="ln6147">  }</a>
<a name="ln6148"> </a>
<a name="ln6149">  // Make sure redirection is not off.  Can happen for cmdline completion</a>
<a name="ln6150">  // that indirectly invokes a command to catch its output.</a>
<a name="ln6151">  if (redir_fd != NULL</a>
<a name="ln6152">      || redir_reg || redir_vname) {</a>
<a name="ln6153">    redir_off = false;</a>
<a name="ln6154">  }</a>
<a name="ln6155">}</a>
<a name="ln6156"> </a>
<a name="ln6157">/// &quot;:redraw&quot;: force redraw</a>
<a name="ln6158">static void ex_redraw(exarg_T *eap)</a>
<a name="ln6159">{</a>
<a name="ln6160">  if (cmdpreview) {</a>
<a name="ln6161">    return;  // Ignore :redraw during 'inccommand' preview. #9777</a>
<a name="ln6162">  }</a>
<a name="ln6163">  int r = RedrawingDisabled;</a>
<a name="ln6164">  int p = p_lz;</a>
<a name="ln6165"> </a>
<a name="ln6166">  RedrawingDisabled = 0;</a>
<a name="ln6167">  p_lz = false;</a>
<a name="ln6168">  validate_cursor();</a>
<a name="ln6169">  update_topline(curwin);</a>
<a name="ln6170">  if (eap-&gt;forceit) {</a>
<a name="ln6171">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln6172">    redraw_cmdline = true;</a>
<a name="ln6173">  } else if (VIsual_active) {</a>
<a name="ln6174">    redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6175">  }</a>
<a name="ln6176">  update_screen();</a>
<a name="ln6177">  if (need_maketitle) {</a>
<a name="ln6178">    maketitle();</a>
<a name="ln6179">  }</a>
<a name="ln6180">  RedrawingDisabled = r;</a>
<a name="ln6181">  p_lz = p;</a>
<a name="ln6182"> </a>
<a name="ln6183">  // Reset msg_didout, so that a message that's there is overwritten.</a>
<a name="ln6184">  msg_didout = false;</a>
<a name="ln6185">  msg_col = 0;</a>
<a name="ln6186"> </a>
<a name="ln6187">  // No need to wait after an intentional redraw.</a>
<a name="ln6188">  need_wait_return = false;</a>
<a name="ln6189"> </a>
<a name="ln6190">  ui_flush();</a>
<a name="ln6191">}</a>
<a name="ln6192"> </a>
<a name="ln6193">/// &quot;:redrawstatus&quot;: force redraw of status line(s) and window bar(s)</a>
<a name="ln6194">static void ex_redrawstatus(exarg_T *eap)</a>
<a name="ln6195">{</a>
<a name="ln6196">  if (cmdpreview) {</a>
<a name="ln6197">    return;  // Ignore :redrawstatus during 'inccommand' preview. #9777</a>
<a name="ln6198">  }</a>
<a name="ln6199">  int r = RedrawingDisabled;</a>
<a name="ln6200">  int p = p_lz;</a>
<a name="ln6201"> </a>
<a name="ln6202">  if (eap-&gt;forceit) {</a>
<a name="ln6203">    status_redraw_all();</a>
<a name="ln6204">  } else {</a>
<a name="ln6205">    status_redraw_curbuf();</a>
<a name="ln6206">  }</a>
<a name="ln6207"> </a>
<a name="ln6208">  RedrawingDisabled = 0;</a>
<a name="ln6209">  p_lz = false;</a>
<a name="ln6210">  if (State &amp; MODE_CMDLINE) {</a>
<a name="ln6211">    redraw_statuslines();</a>
<a name="ln6212">  } else {</a>
<a name="ln6213">    if (VIsual_active) {</a>
<a name="ln6214">      redraw_curbuf_later(UPD_INVERTED);</a>
<a name="ln6215">    }</a>
<a name="ln6216">    update_screen();</a>
<a name="ln6217">  }</a>
<a name="ln6218">  RedrawingDisabled = r;</a>
<a name="ln6219">  p_lz = p;</a>
<a name="ln6220">  ui_flush();</a>
<a name="ln6221">}</a>
<a name="ln6222"> </a>
<a name="ln6223">/// &quot;:redrawtabline&quot;: force redraw of the tabline</a>
<a name="ln6224">static void ex_redrawtabline(exarg_T *eap FUNC_ATTR_UNUSED)</a>
<a name="ln6225">{</a>
<a name="ln6226">  const int r = RedrawingDisabled;</a>
<a name="ln6227">  const int p = p_lz;</a>
<a name="ln6228"> </a>
<a name="ln6229">  RedrawingDisabled = 0;</a>
<a name="ln6230">  p_lz = false;</a>
<a name="ln6231"> </a>
<a name="ln6232">  draw_tabline();</a>
<a name="ln6233"> </a>
<a name="ln6234">  RedrawingDisabled = r;</a>
<a name="ln6235">  p_lz = p;</a>
<a name="ln6236">  ui_flush();</a>
<a name="ln6237">}</a>
<a name="ln6238"> </a>
<a name="ln6239">static void close_redir(void)</a>
<a name="ln6240">{</a>
<a name="ln6241">  if (redir_fd != NULL) {</a>
<a name="ln6242">    fclose(redir_fd);</a>
<a name="ln6243">    redir_fd = NULL;</a>
<a name="ln6244">  }</a>
<a name="ln6245">  redir_reg = 0;</a>
<a name="ln6246">  if (redir_vname) {</a>
<a name="ln6247">    var_redir_stop();</a>
<a name="ln6248">    redir_vname = 0;</a>
<a name="ln6249">  }</a>
<a name="ln6250">}</a>
<a name="ln6251"> </a>
<a name="ln6252">/// Try creating a directory, give error message on failure</a>
<a name="ln6253">///</a>
<a name="ln6254">/// @param[in]  name  Directory to create.</a>
<a name="ln6255">/// @param[in]  prot  Directory permissions.</a>
<a name="ln6256">///</a>
<a name="ln6257">/// @return OK in case of success, FAIL otherwise.</a>
<a name="ln6258">int vim_mkdir_emsg(const char *const name, const int prot)</a>
<a name="ln6259">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6260">{</a>
<a name="ln6261">  int ret;</a>
<a name="ln6262">  if ((ret = os_mkdir(name, prot)) != 0) {</a>
<a name="ln6263">    semsg(_(e_mkdir), name, os_strerror(ret));</a>
<a name="ln6264">    return FAIL;</a>
<a name="ln6265">  }</a>
<a name="ln6266">  return OK;</a>
<a name="ln6267">}</a>
<a name="ln6268"> </a>
<a name="ln6269">/// Open a file for writing for an Ex command, with some checks.</a>
<a name="ln6270">///</a>
<a name="ln6271">/// @param mode  &quot;w&quot; for create new file or &quot;a&quot; for append</a>
<a name="ln6272">///</a>
<a name="ln6273">/// @return  file descriptor, or NULL on failure.</a>
<a name="ln6274">FILE *open_exfile(char *fname, int forceit, char *mode)</a>
<a name="ln6275">{</a>
<a name="ln6276">#ifdef UNIX</a>
<a name="ln6277">  // with Unix it is possible to open a directory</a>
<a name="ln6278">  if (os_isdir(fname)) {</a>
<a name="ln6279">    semsg(_(e_isadir2), fname);</a>
<a name="ln6280">    return NULL;</a>
<a name="ln6281">  }</a>
<a name="ln6282">#endif</a>
<a name="ln6283">  if (!forceit &amp;&amp; *mode != 'a' &amp;&amp; os_path_exists(fname)) {</a>
<a name="ln6284">    semsg(_(&quot;E189: \&quot;%s\&quot; exists (add ! to override)&quot;), fname);</a>
<a name="ln6285">    return NULL;</a>
<a name="ln6286">  }</a>
<a name="ln6287"> </a>
<a name="ln6288">  FILE *fd;</a>
<a name="ln6289">  if ((fd = os_fopen(fname, mode)) == NULL) {</a>
<a name="ln6290">    semsg(_(&quot;E190: Cannot open \&quot;%s\&quot; for writing&quot;), fname);</a>
<a name="ln6291">  }</a>
<a name="ln6292"> </a>
<a name="ln6293">  return fd;</a>
<a name="ln6294">}</a>
<a name="ln6295"> </a>
<a name="ln6296">/// &quot;:mark&quot; and &quot;:k&quot;.</a>
<a name="ln6297">static void ex_mark(exarg_T *eap)</a>
<a name="ln6298">{</a>
<a name="ln6299">  if (*eap-&gt;arg == NUL) {               // No argument?</a>
<a name="ln6300">    emsg(_(e_argreq));</a>
<a name="ln6301">    return;</a>
<a name="ln6302">  }</a>
<a name="ln6303"> </a>
<a name="ln6304">  if (eap-&gt;arg[1] != NUL) {         // more than one character?</a>
<a name="ln6305">    semsg(_(e_trailing_arg), eap-&gt;arg);</a>
<a name="ln6306">    return;</a>
<a name="ln6307">  }</a>
<a name="ln6308"> </a>
<a name="ln6309">  pos_T pos = curwin-&gt;w_cursor;             // save curwin-&gt;w_cursor</a>
<a name="ln6310">  curwin-&gt;w_cursor.lnum = eap-&gt;line2;</a>
<a name="ln6311">  beginline(BL_WHITE | BL_FIX);</a>
<a name="ln6312">  if (setmark(*eap-&gt;arg) == FAIL) {   // set mark</a>
<a name="ln6313">    emsg(_(&quot;E191: Argument must be a letter or forward/backward quote&quot;));</a>
<a name="ln6314">  }</a>
<a name="ln6315">  curwin-&gt;w_cursor = pos;             // restore curwin-&gt;w_cursor</a>
<a name="ln6316">}</a>
<a name="ln6317"> </a>
<a name="ln6318">/// Update w_topline, w_leftcol and the cursor position.</a>
<a name="ln6319">void update_topline_cursor(void)</a>
<a name="ln6320">{</a>
<a name="ln6321">  check_cursor();               // put cursor on valid line</a>
<a name="ln6322">  update_topline(curwin);</a>
<a name="ln6323">  if (!curwin-&gt;w_p_wrap) {</a>
<a name="ln6324">    validate_cursor();</a>
<a name="ln6325">  }</a>
<a name="ln6326">  update_curswant();</a>
<a name="ln6327">}</a>
<a name="ln6328"> </a>
<a name="ln6329">/// Save the current State and go to Normal mode.</a>
<a name="ln6330">///</a>
<a name="ln6331">/// @return  true if the typeahead could be saved.</a>
<a name="ln6332">bool save_current_state(save_state_T *sst)</a>
<a name="ln6333">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6334">{</a>
<a name="ln6335">  sst-&gt;save_msg_scroll = msg_scroll;</a>
<a name="ln6336">  sst-&gt;save_restart_edit = restart_edit;</a>
<a name="ln6337">  sst-&gt;save_msg_didout = msg_didout;</a>
<a name="ln6338">  sst-&gt;save_State = State;</a>
<a name="ln6339">  sst-&gt;save_finish_op = finish_op;</a>
<a name="ln6340">  sst-&gt;save_opcount = opcount;</a>
<a name="ln6341">  sst-&gt;save_reg_executing = reg_executing;</a>
<a name="ln6342">  sst-&gt;save_pending_end_reg_executing = pending_end_reg_executing;</a>
<a name="ln6343"> </a>
<a name="ln6344">  msg_scroll = false;   // no msg scrolling in Normal mode</a>
<a name="ln6345">  restart_edit = 0;     // don't go to Insert mode</a>
<a name="ln6346"> </a>
<a name="ln6347">  // Save the current typeahead.  This is required to allow using &quot;:normal&quot;</a>
<a name="ln6348">  // from an event handler and makes sure we don't hang when the argument</a>
<a name="ln6349">  // ends with half a command.</a>
<a name="ln6350">  save_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6351">  return sst-&gt;tabuf.typebuf_valid;</a>
<a name="ln6352">}</a>
<a name="ln6353"> </a>
<a name="ln6354">void restore_current_state(save_state_T *sst)</a>
<a name="ln6355">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6356">{</a>
<a name="ln6357">  // Restore the previous typeahead.</a>
<a name="ln6358">  restore_typeahead(&amp;sst-&gt;tabuf);</a>
<a name="ln6359"> </a>
<a name="ln6360">  msg_scroll = sst-&gt;save_msg_scroll;</a>
<a name="ln6361">  if (force_restart_edit) {</a>
<a name="ln6362">    force_restart_edit = false;</a>
<a name="ln6363">  } else {</a>
<a name="ln6364">    // Some function (terminal_enter()) was aware of ex_normal and decided to</a>
<a name="ln6365">    // override the value of restart_edit anyway.</a>
<a name="ln6366">    restart_edit = sst-&gt;save_restart_edit;</a>
<a name="ln6367">  }</a>
<a name="ln6368">  finish_op = sst-&gt;save_finish_op;</a>
<a name="ln6369">  opcount = sst-&gt;save_opcount;</a>
<a name="ln6370">  reg_executing = sst-&gt;save_reg_executing;</a>
<a name="ln6371">  pending_end_reg_executing = sst-&gt;save_pending_end_reg_executing;</a>
<a name="ln6372"> </a>
<a name="ln6373">  // don't reset msg_didout now</a>
<a name="ln6374">  msg_didout |= sst-&gt;save_msg_didout;</a>
<a name="ln6375"> </a>
<a name="ln6376">  // Restore the state (needed when called from a function executed for</a>
<a name="ln6377">  // 'indentexpr'). Update the mouse and cursor, they may have changed.</a>
<a name="ln6378">  State = sst-&gt;save_State;</a>
<a name="ln6379">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6380">}</a>
<a name="ln6381"> </a>
<a name="ln6382">bool expr_map_locked(void)</a>
<a name="ln6383">{</a>
<a name="ln6384">  return expr_map_lock &gt; 0 &amp;&amp; !(curbuf-&gt;b_flags &amp; BF_DUMMY);</a>
<a name="ln6385">}</a>
<a name="ln6386"> </a>
<a name="ln6387">/// &quot;:normal[!] {commands}&quot;: Execute normal mode commands.</a>
<a name="ln6388">static void ex_normal(exarg_T *eap)</a>
<a name="ln6389">{</a>
<a name="ln6390">  if (curbuf-&gt;terminal &amp;&amp; State &amp; MODE_TERMINAL) {</a>
<a name="ln6391">    emsg(&quot;Can't re-enter normal mode from terminal mode&quot;);</a>
<a name="ln6392">    return;</a>
<a name="ln6393">  }</a>
<a name="ln6394">  char *arg = NULL;</a>
<a name="ln6395"> </a>
<a name="ln6396">  if (expr_map_locked()) {</a>
<a name="ln6397">    emsg(_(e_secure));</a>
<a name="ln6398">    return;</a>
<a name="ln6399">  }</a>
<a name="ln6400"> </a>
<a name="ln6401">  if (ex_normal_busy &gt;= p_mmd) {</a>
<a name="ln6402">    emsg(_(&quot;E192: Recursive use of :normal too deep&quot;));</a>
<a name="ln6403">    return;</a>
<a name="ln6404">  }</a>
<a name="ln6405"> </a>
<a name="ln6406">  // vgetc() expects K_SPECIAL to have been escaped.  Don't do</a>
<a name="ln6407">  // this for the K_SPECIAL leading byte, otherwise special keys will not</a>
<a name="ln6408">  // work.</a>
<a name="ln6409">  {</a>
<a name="ln6410">    int len = 0;</a>
<a name="ln6411"> </a>
<a name="ln6412">    // Count the number of characters to be escaped.</a>
<a name="ln6413">    int l;</a>
<a name="ln6414">    char *p;</a>
<a name="ln6415">    for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6416">      for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6417">        if (*++p == (char)K_SPECIAL) {  // trailbyte K_SPECIAL</a>
<a name="ln6418">          len += 2;</a>
<a name="ln6419">        }</a>
<a name="ln6420">      }</a>
<a name="ln6421">    }</a>
<a name="ln6422">    if (len &gt; 0) {</a>
<a name="ln6423">      arg = xmalloc(strlen(eap-&gt;arg) + (size_t)len + 1);</a>
<a name="ln6424">      len = 0;</a>
<a name="ln6425">      for (p = eap-&gt;arg; *p != NUL; p++) {</a>
<a name="ln6426">        arg[len++] = *p;</a>
<a name="ln6427">        for (l = utfc_ptr2len(p) - 1; l &gt; 0; l--) {</a>
<a name="ln6428">          arg[len++] = *++p;</a>
<a name="ln6429">          if (*p == (char)K_SPECIAL) {</a>
<a name="ln6430">            arg[len++] = (char)KS_SPECIAL;</a>
<a name="ln6431">            arg[len++] = KE_FILLER;</a>
<a name="ln6432">          }</a>
<a name="ln6433">        }</a>
<a name="ln6434">        arg[len] = NUL;</a>
<a name="ln6435">      }</a>
<a name="ln6436">    }</a>
<a name="ln6437">  }</a>
<a name="ln6438"> </a>
<a name="ln6439">  ex_normal_busy++;</a>
<a name="ln6440">  save_state_T save_state;</a>
<a name="ln6441">  if (save_current_state(&amp;save_state)) {</a>
<a name="ln6442">    // Repeat the :normal command for each line in the range.  When no</a>
<a name="ln6443">    // range given, execute it just once, without positioning the cursor</a>
<a name="ln6444">    // first.</a>
<a name="ln6445">    do {</a>
<a name="ln6446">      if (eap-&gt;addr_count != 0) {</a>
<a name="ln6447">        curwin-&gt;w_cursor.lnum = eap-&gt;line1++;</a>
<a name="ln6448">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln6449">        check_cursor_moved(curwin);</a>
<a name="ln6450">      }</a>
<a name="ln6451"> </a>
<a name="ln6452">      exec_normal_cmd((arg != NULL ? arg : eap-&gt;arg),</a>
<a name="ln6453">                      eap-&gt;forceit ? REMAP_NONE : REMAP_YES, false);</a>
<a name="ln6454">    } while (eap-&gt;addr_count &gt; 0 &amp;&amp; eap-&gt;line1 &lt;= eap-&gt;line2 &amp;&amp; !got_int);</a>
<a name="ln6455">  }</a>
<a name="ln6456"> </a>
<a name="ln6457">  // Might not return to the main loop when in an event handler.</a>
<a name="ln6458">  update_topline_cursor();</a>
<a name="ln6459"> </a>
<a name="ln6460">  restore_current_state(&amp;save_state);</a>
<a name="ln6461"> </a>
<a name="ln6462">  ex_normal_busy--;</a>
<a name="ln6463"> </a>
<a name="ln6464">  setmouse();</a>
<a name="ln6465">  ui_cursor_shape();  // may show different cursor shape</a>
<a name="ln6466">  xfree(arg);</a>
<a name="ln6467">}</a>
<a name="ln6468"> </a>
<a name="ln6469">/// &quot;:startinsert&quot;, &quot;:startreplace&quot; and &quot;:startgreplace&quot;</a>
<a name="ln6470">static void ex_startinsert(exarg_T *eap)</a>
<a name="ln6471">{</a>
<a name="ln6472">  if (eap-&gt;forceit) {</a>
<a name="ln6473">    // cursor line can be zero on startup</a>
<a name="ln6474">    if (!curwin-&gt;w_cursor.lnum) {</a>
<a name="ln6475">      curwin-&gt;w_cursor.lnum = 1;</a>
<a name="ln6476">    }</a>
<a name="ln6477">    set_cursor_for_append_to_line();</a>
<a name="ln6478">  }</a>
<a name="ln6479"> </a>
<a name="ln6480">  // Ignore the command when already in Insert mode.  Inserting an</a>
<a name="ln6481">  // expression register that invokes a function can do this.</a>
<a name="ln6482">  if (State &amp; MODE_INSERT) {</a>
<a name="ln6483">    return;</a>
<a name="ln6484">  }</a>
<a name="ln6485"> </a>
<a name="ln6486">  if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6487">    restart_edit = 'a';</a>
<a name="ln6488">  } else if (eap-&gt;cmdidx == CMD_startreplace) {</a>
<a name="ln6489">    restart_edit = 'R';</a>
<a name="ln6490">  } else {</a>
<a name="ln6491">    restart_edit = 'V';</a>
<a name="ln6492">  }</a>
<a name="ln6493"> </a>
<a name="ln6494">  if (!eap-&gt;forceit) {</a>
<a name="ln6495">    if (eap-&gt;cmdidx == CMD_startinsert) {</a>
<a name="ln6496">      restart_edit = 'i';</a>
<a name="ln6497">    }</a>
<a name="ln6498">    curwin-&gt;w_curswant = 0;  // avoid MAXCOL</a>
<a name="ln6499">  }</a>
<a name="ln6500"> </a>
<a name="ln6501">  if (VIsual_active) {</a>
<a name="ln6502">    showmode();</a>
<a name="ln6503">  }</a>
<a name="ln6504">}</a>
<a name="ln6505"> </a>
<a name="ln6506">/// &quot;:stopinsert&quot;</a>
<a name="ln6507">static void ex_stopinsert(exarg_T *eap)</a>
<a name="ln6508">{</a>
<a name="ln6509">  restart_edit = 0;</a>
<a name="ln6510">  stop_insert_mode = true;</a>
<a name="ln6511">  clearmode();</a>
<a name="ln6512">}</a>
<a name="ln6513"> </a>
<a name="ln6514">/// Execute normal mode command &quot;cmd&quot;.</a>
<a name="ln6515">/// &quot;remap&quot; can be REMAP_NONE or REMAP_YES.</a>
<a name="ln6516">void exec_normal_cmd(char *cmd, int remap, bool silent)</a>
<a name="ln6517">{</a>
<a name="ln6518">  // Stuff the argument into the typeahead buffer.</a>
<a name="ln6519">  ins_typebuf(cmd, remap, 0, true, silent);</a>
<a name="ln6520">  exec_normal(false);</a>
<a name="ln6521">}</a>
<a name="ln6522"> </a>
<a name="ln6523">/// Execute normal_cmd() until there is no typeahead left.</a>
<a name="ln6524">///</a>
<a name="ln6525">/// @param was_typed whether or not something was typed</a>
<a name="ln6526">void exec_normal(bool was_typed)</a>
<a name="ln6527">{</a>
<a name="ln6528">  oparg_T oa;</a>
<a name="ln6529"> </a>
<a name="ln6530">  clear_oparg(&amp;oa);</a>
<a name="ln6531">  finish_op = false;</a>
<a name="ln6532">  while ((!stuff_empty()</a>
<a name="ln6533">          || ((was_typed || !typebuf_typed())</a>
<a name="ln6534">              &amp;&amp; typebuf.tb_len &gt; 0))</a>
<a name="ln6535">         &amp;&amp; !got_int) {</a>
<a name="ln6536">    update_topline_cursor();</a>
<a name="ln6537">    normal_cmd(&amp;oa, true);      // execute a Normal mode cmd</a>
<a name="ln6538">  }</a>
<a name="ln6539">}</a>
<a name="ln6540"> </a>
<a name="ln6541">static void ex_checkpath(exarg_T *eap)</a>
<a name="ln6542">{</a>
<a name="ln6543">  find_pattern_in_path(NULL, 0, 0, false, false, CHECK_PATH, 1L,</a>
<a name="ln6544">                       eap-&gt;forceit ? ACTION_SHOW_ALL : ACTION_SHOW,</a>
<a name="ln6545">                       (linenr_T)1, (linenr_T)MAXLNUM);</a>
<a name="ln6546">}</a>
<a name="ln6547"> </a>
<a name="ln6548">/// &quot;:psearch&quot;</a>
<a name="ln6549">static void ex_psearch(exarg_T *eap)</a>
<a name="ln6550">{</a>
<a name="ln6551">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6552">  ex_findpat(eap);</a>
<a name="ln6553">  g_do_tagpreview = 0;</a>
<a name="ln6554">}</a>
<a name="ln6555"> </a>
<a name="ln6556">static void ex_findpat(exarg_T *eap)</a>
<a name="ln6557">{</a>
<a name="ln6558">  bool whole = true;</a>
<a name="ln6559">  int action;</a>
<a name="ln6560"> </a>
<a name="ln6561">  switch (cmdnames[eap-&gt;cmdidx].cmd_name[2]) {</a>
<a name="ln6562">  case 'e':             // &quot;:psearch&quot;, &quot;:isearch&quot; and &quot;:dsearch&quot;</a>
<a name="ln6563">    if (cmdnames[eap-&gt;cmdidx].cmd_name[0] == 'p') {</a>
<a name="ln6564">      action = ACTION_GOTO;</a>
<a name="ln6565">    } else {</a>
<a name="ln6566">      action = ACTION_SHOW;</a>
<a name="ln6567">    }</a>
<a name="ln6568">    break;</a>
<a name="ln6569">  case 'i':             // &quot;:ilist&quot; and &quot;:dlist&quot;</a>
<a name="ln6570">    action = ACTION_SHOW_ALL;</a>
<a name="ln6571">    break;</a>
<a name="ln6572">  case 'u':             // &quot;:ijump&quot; and &quot;:djump&quot;</a>
<a name="ln6573">    action = ACTION_GOTO;</a>
<a name="ln6574">    break;</a>
<a name="ln6575">  default:              // &quot;:isplit&quot; and &quot;:dsplit&quot;</a>
<a name="ln6576">    action = ACTION_SPLIT;</a>
<a name="ln6577">    break;</a>
<a name="ln6578">  }</a>
<a name="ln6579"> </a>
<a name="ln6580">  int n = 1;</a>
<a name="ln6581">  if (ascii_isdigit(*eap-&gt;arg)) {  // get count</a>
<a name="ln6582">    n = getdigits_int(&amp;eap-&gt;arg, false, 0);</a>
<a name="ln6583">    eap-&gt;arg = skipwhite(eap-&gt;arg);</a>
<a name="ln6584">  }</a>
<a name="ln6585">  if (*eap-&gt;arg == '/') {   // Match regexp, not just whole words</a>
<a name="ln6586">    whole = false;</a>
<a name="ln6587">    eap-&gt;arg++;</a>
<a name="ln6588">    char *p = skip_regexp(eap-&gt;arg, '/', magic_isset());</a>
<a name="ln6589">    if (*p) {</a>
<a name="ln6590">      *p++ = NUL;</a>
<a name="ln6591">      p = skipwhite(p);</a>
<a name="ln6592"> </a>
<a name="ln6593">      // Check for trailing illegal characters.</a>
<a name="ln6594">      if (!ends_excmd(*p)) {</a>
<a name="ln6595">        eap-&gt;errmsg = ex_errmsg(e_trailing_arg, p);</a>
<a name="ln6596">      } else {</a>
<a name="ln6597">        eap-&gt;nextcmd = check_nextcmd(p);</a>
<a name="ln6598">      }</a>
<a name="ln6599">    }</a>
<a name="ln6600">  }</a>
<a name="ln6601">  if (!eap-&gt;skip) {</a>
<a name="ln6602">    find_pattern_in_path(eap-&gt;arg, 0, strlen(eap-&gt;arg), whole, !eap-&gt;forceit,</a>
<a name="ln6603">                         *eap-&gt;cmd == 'd' ? FIND_DEFINE : FIND_ANY,</a>
<a name="ln6604">                         n, action, eap-&gt;line1, eap-&gt;line2);</a>
<a name="ln6605">  }</a>
<a name="ln6606">}</a>
<a name="ln6607"> </a>
<a name="ln6608">/// &quot;:ptag&quot;, &quot;:ptselect&quot;, &quot;:ptjump&quot;, &quot;:ptnext&quot;, etc.</a>
<a name="ln6609">static void ex_ptag(exarg_T *eap)</a>
<a name="ln6610">{</a>
<a name="ln6611">  g_do_tagpreview = (int)p_pvh;    // will be reset to 0 in ex_tag_cmd()</a>
<a name="ln6612">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6613">}</a>
<a name="ln6614"> </a>
<a name="ln6615">/// &quot;:pedit&quot;</a>
<a name="ln6616">static void ex_pedit(exarg_T *eap)</a>
<a name="ln6617">{</a>
<a name="ln6618">  win_T *curwin_save = curwin;</a>
<a name="ln6619"> </a>
<a name="ln6620">  // Open the preview window or popup and make it the current window.</a>
<a name="ln6621">  g_do_tagpreview = (int)p_pvh;</a>
<a name="ln6622">  prepare_tagpreview(true);</a>
<a name="ln6623"> </a>
<a name="ln6624">  // Edit the file.</a>
<a name="ln6625">  do_exedit(eap, NULL);</a>
<a name="ln6626"> </a>
<a name="ln6627">  if (curwin != curwin_save &amp;&amp; win_valid(curwin_save)) {</a>
<a name="ln6628">    // Return cursor to where we were</a>
<a name="ln6629">    validate_cursor();</a>
<a name="ln6630">    redraw_later(curwin, UPD_VALID);</a>
<a name="ln6631">    win_enter(curwin_save, true);</a>
<a name="ln6632">  }</a>
<a name="ln6633">  g_do_tagpreview = 0;</a>
<a name="ln6634">}</a>
<a name="ln6635"> </a>
<a name="ln6636">/// &quot;:stag&quot;, &quot;:stselect&quot; and &quot;:stjump&quot;.</a>
<a name="ln6637">static void ex_stag(exarg_T *eap)</a>
<a name="ln6638">{</a>
<a name="ln6639">  postponed_split = -1;</a>
<a name="ln6640">  postponed_split_flags = cmdmod.cmod_split;</a>
<a name="ln6641">  postponed_split_tab = cmdmod.cmod_tab;</a>
<a name="ln6642">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name + 1);</a>
<a name="ln6643">  postponed_split_flags = 0;</a>
<a name="ln6644">  postponed_split_tab = 0;</a>
<a name="ln6645">}</a>
<a name="ln6646"> </a>
<a name="ln6647">/// &quot;:tag&quot;, &quot;:tselect&quot;, &quot;:tjump&quot;, &quot;:tnext&quot;, etc.</a>
<a name="ln6648">static void ex_tag(exarg_T *eap)</a>
<a name="ln6649">{</a>
<a name="ln6650">  ex_tag_cmd(eap, cmdnames[eap-&gt;cmdidx].cmd_name);</a>
<a name="ln6651">}</a>
<a name="ln6652"> </a>
<a name="ln6653">static void ex_tag_cmd(exarg_T *eap, const char *name)</a>
<a name="ln6654">{</a>
<a name="ln6655">  int cmd;</a>
<a name="ln6656"> </a>
<a name="ln6657">  switch (name[1]) {</a>
<a name="ln6658">  case 'j':</a>
<a name="ln6659">    cmd = DT_JUMP;              // &quot;:tjump&quot;</a>
<a name="ln6660">    break;</a>
<a name="ln6661">  case 's':</a>
<a name="ln6662">    cmd = DT_SELECT;            // &quot;:tselect&quot;</a>
<a name="ln6663">    break;</a>
<a name="ln6664">  case 'p':                             // &quot;:tprevious&quot;</a>
<a name="ln6665">  case 'N':</a>
<a name="ln6666">    cmd = DT_PREV;              // &quot;:tNext&quot;</a>
<a name="ln6667">    break;</a>
<a name="ln6668">  case 'n':</a>
<a name="ln6669">    cmd = DT_NEXT;              // &quot;:tnext&quot;</a>
<a name="ln6670">    break;</a>
<a name="ln6671">  case 'o':</a>
<a name="ln6672">    cmd = DT_POP;               // &quot;:pop&quot;</a>
<a name="ln6673">    break;</a>
<a name="ln6674">  case 'f':                             // &quot;:tfirst&quot;</a>
<a name="ln6675">  case 'r':</a>
<a name="ln6676">    cmd = DT_FIRST;             // &quot;:trewind&quot;</a>
<a name="ln6677">    break;</a>
<a name="ln6678">  case 'l':</a>
<a name="ln6679">    cmd = DT_LAST;              // &quot;:tlast&quot;</a>
<a name="ln6680">    break;</a>
<a name="ln6681">  default:                              // &quot;:tag&quot;</a>
<a name="ln6682">    cmd = DT_TAG;</a>
<a name="ln6683">    break;</a>
<a name="ln6684">  }</a>
<a name="ln6685"> </a>
<a name="ln6686">  if (name[0] == 'l') {</a>
<a name="ln6687">    cmd = DT_LTAG;</a>
<a name="ln6688">  }</a>
<a name="ln6689"> </a>
<a name="ln6690">  do_tag(eap-&gt;arg, cmd, eap-&gt;addr_count &gt; 0 ? (int)eap-&gt;line2 : 1,</a>
<a name="ln6691">         eap-&gt;forceit, true);</a>
<a name="ln6692">}</a>
<a name="ln6693"> </a>
<a name="ln6694">enum {</a>
<a name="ln6695">  SPEC_PERC = 0,</a>
<a name="ln6696">  SPEC_HASH,</a>
<a name="ln6697">  SPEC_CWORD,</a>
<a name="ln6698">  SPEC_CCWORD,</a>
<a name="ln6699">  SPEC_CEXPR,</a>
<a name="ln6700">  SPEC_CFILE,</a>
<a name="ln6701">  SPEC_SFILE,</a>
<a name="ln6702">  SPEC_SLNUM,</a>
<a name="ln6703">  SPEC_STACK,</a>
<a name="ln6704">  SPEC_SCRIPT,</a>
<a name="ln6705">  SPEC_AFILE,</a>
<a name="ln6706">  SPEC_ABUF,</a>
<a name="ln6707">  SPEC_AMATCH,</a>
<a name="ln6708">  SPEC_SFLNUM,</a>
<a name="ln6709">  SPEC_SID,</a>
<a name="ln6710">  // SPEC_CLIENT,</a>
<a name="ln6711">};</a>
<a name="ln6712"> </a>
<a name="ln6713">/// Check &quot;str&quot; for starting with a special cmdline variable.</a>
<a name="ln6714">/// If found return one of the SPEC_ values and set &quot;*usedlen&quot; to the length of</a>
<a name="ln6715">/// the variable.  Otherwise return -1 and &quot;*usedlen&quot; is unchanged.</a>
<a name="ln6716">ssize_t find_cmdline_var(const char *src, size_t *usedlen)</a>
<a name="ln6717">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln6718">{</a>
<a name="ln6719">  static char *(spec_str[]) = {</a>
<a name="ln6720">    [SPEC_PERC] = &quot;%&quot;,</a>
<a name="ln6721">    [SPEC_HASH] = &quot;#&quot;,</a>
<a name="ln6722">    [SPEC_CWORD] = &quot;&lt;cword&gt;&quot;,           // cursor word</a>
<a name="ln6723">    [SPEC_CCWORD] = &quot;&lt;cWORD&gt;&quot;,          // cursor WORD</a>
<a name="ln6724">    [SPEC_CEXPR] = &quot;&lt;cexpr&gt;&quot;,           // expr under cursor</a>
<a name="ln6725">    [SPEC_CFILE] = &quot;&lt;cfile&gt;&quot;,           // cursor path name</a>
<a name="ln6726">    [SPEC_SFILE] = &quot;&lt;sfile&gt;&quot;,           // &quot;:so&quot; file name</a>
<a name="ln6727">    [SPEC_SLNUM] = &quot;&lt;slnum&gt;&quot;,           // &quot;:so&quot; file line number</a>
<a name="ln6728">    [SPEC_STACK] = &quot;&lt;stack&gt;&quot;,           // call stack</a>
<a name="ln6729">    [SPEC_SCRIPT] = &quot;&lt;script&gt;&quot;,         // script file name</a>
<a name="ln6730">    [SPEC_AFILE] = &quot;&lt;afile&gt;&quot;,           // autocommand file name</a>
<a name="ln6731">    [SPEC_ABUF] = &quot;&lt;abuf&gt;&quot;,             // autocommand buffer number</a>
<a name="ln6732">    [SPEC_AMATCH] = &quot;&lt;amatch&gt;&quot;,         // autocommand match name</a>
<a name="ln6733">    [SPEC_SFLNUM] = &quot;&lt;sflnum&gt;&quot;,         // script file line number</a>
<a name="ln6734">    [SPEC_SID] = &quot;&lt;SID&gt;&quot;,               // script ID: &lt;SNR&gt;123_</a>
<a name="ln6735">    // [SPEC_CLIENT] = &quot;&lt;client&gt;&quot;,</a>
<a name="ln6736">  };</a>
<a name="ln6737"> </a>
<a name="ln6738">  for (size_t i = 0; i &lt; ARRAY_SIZE(spec_str); i++) {</a>
<a name="ln6739">    size_t len = strlen(spec_str[i]);</a>
<a name="ln6740">    if (strncmp(src, spec_str[i], len) == 0) {</a>
<a name="ln6741">      *usedlen = len;</a>
<a name="ln6742">      assert(i &lt;= SSIZE_MAX);</a>
<a name="ln6743">      return (ssize_t)i;</a>
<a name="ln6744">    }</a>
<a name="ln6745">  }</a>
<a name="ln6746">  return -1;</a>
<a name="ln6747">}</a>
<a name="ln6748"> </a>
<a name="ln6749">/// Evaluate cmdline variables.</a>
<a name="ln6750">///</a>
<a name="ln6751">/// change &quot;%&quot;       to curbuf-&gt;b_ffname</a>
<a name="ln6752">///        &quot;#&quot;       to curwin-&gt;w_alt_fnum</a>
<a name="ln6753">///        &quot;&lt;cword&gt;&quot; to word under the cursor</a>
<a name="ln6754">///        &quot;&lt;cWORD&gt;&quot; to WORD under the cursor</a>
<a name="ln6755">///        &quot;&lt;cexpr&gt;&quot; to C-expression under the cursor</a>
<a name="ln6756">///        &quot;&lt;cfile&gt;&quot; to path name under the cursor</a>
<a name="ln6757">///        &quot;&lt;sfile&gt;&quot; to sourced file name</a>
<a name="ln6758">///        &quot;&lt;stack&gt;&quot; to call stack</a>
<a name="ln6759">///        &quot;&lt;script&gt;&quot; to current script name</a>
<a name="ln6760">///        &quot;&lt;slnum&gt;&quot; to sourced file line number</a>
<a name="ln6761">///        &quot;&lt;afile&gt;&quot; to file name for autocommand</a>
<a name="ln6762">///        &quot;&lt;abuf&gt;&quot;  to buffer number for autocommand</a>
<a name="ln6763">///        &quot;&lt;amatch&gt;&quot; to matching name for autocommand</a>
<a name="ln6764">///</a>
<a name="ln6765">/// When an error is detected, &quot;errormsg&quot; is set to a non-NULL pointer (may be</a>
<a name="ln6766">/// &quot;&quot; for error without a message) and NULL is returned.</a>
<a name="ln6767">///</a>
<a name="ln6768">/// @param src             pointer into commandline</a>
<a name="ln6769">/// @param srcstart        beginning of valid memory for src</a>
<a name="ln6770">/// @param usedlen         characters after src that are used</a>
<a name="ln6771">/// @param lnump           line number for :e command, or NULL</a>
<a name="ln6772">/// @param errormsg        pointer to error message</a>
<a name="ln6773">/// @param escaped         return value has escaped white space (can be NULL)</a>
<a name="ln6774">/// @param empty_is_error  empty result is considered an error</a>
<a name="ln6775">///</a>
<a name="ln6776">/// @return          an allocated string if a valid match was found.</a>
<a name="ln6777">///                  Returns NULL if no match was found.  &quot;usedlen&quot; then still contains the</a>
<a name="ln6778">///                  number of characters to skip.</a>
<a name="ln6779">char *eval_vars(char *src, const char *srcstart, size_t *usedlen, linenr_T *lnump,</a>
<a name="ln6780">                const char **errormsg, int *escaped, bool empty_is_error)</a>
<a name="ln6781">{</a>
<a name="ln6782">  char *result;</a>
<a name="ln6783">  char *resultbuf = NULL;</a>
<a name="ln6784">  size_t resultlen;</a>
<a name="ln6785">  int valid = VALID_HEAD | VALID_PATH;  // Assume valid result.</a>
<a name="ln6786">  bool tilde_file = false;</a>
<a name="ln6787">  bool skip_mod = false;</a>
<a name="ln6788">  char strbuf[30];</a>
<a name="ln6789"> </a>
<a name="ln6790">  *errormsg = NULL;</a>
<a name="ln6791">  if (escaped != NULL) {</a>
<a name="ln6792">    *escaped = false;</a>
<a name="ln6793">  }</a>
<a name="ln6794"> </a>
<a name="ln6795">  // Check if there is something to do.</a>
<a name="ln6796">  ssize_t spec_idx = find_cmdline_var(src, usedlen);</a>
<a name="ln6797">  if (spec_idx &lt; 0) {   // no match</a>
<a name="ln6798">    *usedlen = 1;</a>
<a name="ln6799">    return NULL;</a>
<a name="ln6800">  }</a>
<a name="ln6801"> </a>
<a name="ln6802">  // Skip when preceded with a backslash &quot;\%&quot; and &quot;\#&quot;.</a>
<a name="ln6803">  // Note: In &quot;\\%&quot; the % is also not recognized!</a>
<a name="ln6804">  if (src &gt; srcstart &amp;&amp; src[-1] == '\\') {</a>
<a name="ln6805">    *usedlen = 0;</a>
<a name="ln6806">    STRMOVE(src - 1, src);      // remove backslash</a>
<a name="ln6807">    return NULL;</a>
<a name="ln6808">  }</a>
<a name="ln6809"> </a>
<a name="ln6810">  // word or WORD under cursor</a>
<a name="ln6811">  if (spec_idx == SPEC_CWORD</a>
<a name="ln6812">      || spec_idx == SPEC_CCWORD</a>
<a name="ln6813">      || spec_idx == SPEC_CEXPR) {</a>
<a name="ln6814">    resultlen = find_ident_under_cursor(&amp;result,</a>
<a name="ln6815">                                        spec_idx == SPEC_CWORD</a>
<a name="ln6816">                                        ? (FIND_IDENT | FIND_STRING)</a>
<a name="ln6817">                                        : (spec_idx == SPEC_CEXPR</a>
<a name="ln6818">                                           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)</a>
<a name="ln6819">                                           : FIND_STRING));</a>
<a name="ln6820">    if (resultlen == 0) {</a>
<a name="ln6821">      *errormsg = &quot;&quot;;</a>
<a name="ln6822">      return NULL;</a>
<a name="ln6823">    }</a>
<a name="ln6824">    //</a>
<a name="ln6825">    // '#': Alternate file name</a>
<a name="ln6826">    // '%': Current file name</a>
<a name="ln6827">    //        File name under the cursor</a>
<a name="ln6828">    //        File name for autocommand</a>
<a name="ln6829">    //    and following modifiers</a>
<a name="ln6830">    //</a>
<a name="ln6831">  } else {</a>
<a name="ln6832">    switch (spec_idx) {</a>
<a name="ln6833">    case SPEC_PERC:             // '%': current file</a>
<a name="ln6834">      if (curbuf-&gt;b_fname == NULL) {</a>
<a name="ln6835">        result = &quot;&quot;;</a>
<a name="ln6836">        valid = 0;                  // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6837">      } else {</a>
<a name="ln6838">        result = curbuf-&gt;b_fname;</a>
<a name="ln6839">        tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6840">      }</a>
<a name="ln6841">      break;</a>
<a name="ln6842"> </a>
<a name="ln6843">    case SPEC_HASH:             // '#' or &quot;#99&quot;: alternate file</a>
<a name="ln6844">      if (src[1] == '#') {          // &quot;##&quot;: the argument list</a>
<a name="ln6845">        result = arg_all();</a>
<a name="ln6846">        resultbuf = result;</a>
<a name="ln6847">        *usedlen = 2;</a>
<a name="ln6848">        if (escaped != NULL) {</a>
<a name="ln6849">          *escaped = true;</a>
<a name="ln6850">        }</a>
<a name="ln6851">        skip_mod = true;</a>
<a name="ln6852">        break;</a>
<a name="ln6853">      }</a>
<a name="ln6854">      char *s = src + 1;</a>
<a name="ln6855">      if (*s == '&lt;') {                  // &quot;#&lt;99&quot; uses v:oldfiles.</a>
<a name="ln6856">        s++;</a>
<a name="ln6857">      }</a>
<a name="ln6858">      int i = getdigits_int(&amp;s, false, 0);</a>
<a name="ln6859">      if (s == src + 2 &amp;&amp; src[1] == '-') {</a>
<a name="ln6860">        // just a minus sign, don't skip over it</a>
<a name="ln6861">        s--;</a>
<a name="ln6862">      }</a>
<a name="ln6863">      *usedlen = (size_t)(s - src);           // length of what we expand</a>
<a name="ln6864"> </a>
<a name="ln6865">      if (src[1] == '&lt;' &amp;&amp; i != 0) {</a>
<a name="ln6866">        if (*usedlen &lt; 2) {</a>
<a name="ln6867">          // Should we give an error message for #&lt;text?</a>
<a name="ln6868">          *usedlen = 1;</a>
<a name="ln6869">          return NULL;</a>
<a name="ln6870">        }</a>
<a name="ln6871">        result = (char *)tv_list_find_str(get_vim_var_list(VV_OLDFILES), i - 1);</a>
<a name="ln6872">        if (result == NULL) {</a>
<a name="ln6873">          *errormsg = &quot;&quot;;</a>
<a name="ln6874">          return NULL;</a>
<a name="ln6875">        }</a>
<a name="ln6876">      } else {</a>
<a name="ln6877">        if (i == 0 &amp;&amp; src[1] == '&lt;' &amp;&amp; *usedlen &gt; 1) {</a>
<a name="ln6878">          *usedlen = 1;</a>
<a name="ln6879">        }</a>
<a name="ln6880">        buf_T *buf = buflist_findnr(i);</a>
<a name="ln6881">        if (buf == NULL) {</a>
<a name="ln6882">          *errormsg = _(&quot;E194: No alternate file name to substitute for '#'&quot;);</a>
<a name="ln6883">          return NULL;</a>
<a name="ln6884">        }</a>
<a name="ln6885">        if (lnump != NULL) {</a>
<a name="ln6886">          *lnump = ECMD_LAST;</a>
<a name="ln6887">        }</a>
<a name="ln6888">        if (buf-&gt;b_fname == NULL) {</a>
<a name="ln6889">          result = &quot;&quot;;</a>
<a name="ln6890">          valid = 0;                        // Must have &quot;:p:h&quot; to be valid</a>
<a name="ln6891">        } else {</a>
<a name="ln6892">          result = buf-&gt;b_fname;</a>
<a name="ln6893">          tilde_file = strcmp(result, &quot;~&quot;) == 0;</a>
<a name="ln6894">        }</a>
<a name="ln6895">      }</a>
<a name="ln6896">      break;</a>
<a name="ln6897"> </a>
<a name="ln6898">    case SPEC_CFILE:            // file name under cursor</a>
<a name="ln6899">      result = file_name_at_cursor(FNAME_MESS|FNAME_HYP, 1L, NULL);</a>
<a name="ln6900">      if (result == NULL) {</a>
<a name="ln6901">        *errormsg = &quot;&quot;;</a>
<a name="ln6902">        return NULL;</a>
<a name="ln6903">      }</a>
<a name="ln6904">      resultbuf = result;                   // remember allocated string</a>
<a name="ln6905">      break;</a>
<a name="ln6906"> </a>
<a name="ln6907">    case SPEC_AFILE:  // file name for autocommand</a>
<a name="ln6908">      if (autocmd_fname != NULL &amp;&amp; !autocmd_fname_full) {</a>
<a name="ln6909">        // Still need to turn the fname into a full path.  It was</a>
<a name="ln6910">        // postponed to avoid a delay when &lt;afile&gt; is not used.</a>
<a name="ln6911">        autocmd_fname_full = true;</a>
<a name="ln6912">        result = FullName_save(autocmd_fname, false);</a>
<a name="ln6913">        // Copy into `autocmd_fname`, don't reassign it. #8165</a>
<a name="ln6914">        xstrlcpy(autocmd_fname, result, MAXPATHL);</a>
<a name="ln6915">        xfree(result);</a>
<a name="ln6916">      }</a>
<a name="ln6917">      result = autocmd_fname;</a>
<a name="ln6918">      if (result == NULL) {</a>
<a name="ln6919">        *errormsg = _(e_no_autocommand_file_name_to_substitute_for_afile);</a>
<a name="ln6920">        return NULL;</a>
<a name="ln6921">      }</a>
<a name="ln6922">      result = path_try_shorten_fname(result);</a>
<a name="ln6923">      break;</a>
<a name="ln6924"> </a>
<a name="ln6925">    case SPEC_ABUF:             // buffer number for autocommand</a>
<a name="ln6926">      if (autocmd_bufnr &lt;= 0) {</a>
<a name="ln6927">        *errormsg = _(e_no_autocommand_buffer_number_to_substitute_for_abuf);</a>
<a name="ln6928">        return NULL;</a>
<a name="ln6929">      }</a>
<a name="ln6930">      snprintf(strbuf, sizeof(strbuf), &quot;%d&quot;, autocmd_bufnr);</a>
<a name="ln6931">      result = strbuf;</a>
<a name="ln6932">      break;</a>
<a name="ln6933"> </a>
<a name="ln6934">    case SPEC_AMATCH:           // match name for autocommand</a>
<a name="ln6935">      result = autocmd_match;</a>
<a name="ln6936">      if (result == NULL) {</a>
<a name="ln6937">        *errormsg = _(e_no_autocommand_match_name_to_substitute_for_amatch);</a>
<a name="ln6938">        return NULL;</a>
<a name="ln6939">      }</a>
<a name="ln6940">      break;</a>
<a name="ln6941"> </a>
<a name="ln6942">    case SPEC_SFILE:            // file name for &quot;:so&quot; command</a>
<a name="ln6943">      result = estack_sfile(ESTACK_SFILE);</a>
<a name="ln6944">      if (result == NULL) {</a>
<a name="ln6945">        *errormsg = _(e_no_source_file_name_to_substitute_for_sfile);</a>
<a name="ln6946">        return NULL;</a>
<a name="ln6947">      }</a>
<a name="ln6948">      resultbuf = result;  // remember allocated string</a>
<a name="ln6949">      break;</a>
<a name="ln6950">    case SPEC_STACK:            // call stack</a>
<a name="ln6951">      result = estack_sfile(ESTACK_STACK);</a>
<a name="ln6952">      if (result == NULL) {</a>
<a name="ln6953">        *errormsg = _(e_no_call_stack_to_substitute_for_stack);</a>
<a name="ln6954">        return NULL;</a>
<a name="ln6955">      }</a>
<a name="ln6956">      resultbuf = result;  // remember allocated string</a>
<a name="ln6957">      break;</a>
<a name="ln6958">    case SPEC_SCRIPT:           // script file name</a>
<a name="ln6959">      result = estack_sfile(ESTACK_SCRIPT);</a>
<a name="ln6960">      if (result == NULL) {</a>
<a name="ln6961">        *errormsg = _(e_no_script_file_name_to_substitute_for_script);</a>
<a name="ln6962">        return NULL;</a>
<a name="ln6963">      }</a>
<a name="ln6964">      resultbuf = result;  // remember allocated string</a>
<a name="ln6965">      break;</a>
<a name="ln6966"> </a>
<a name="ln6967">    case SPEC_SLNUM:            // line in file for &quot;:so&quot; command</a>
<a name="ln6968">      if (SOURCING_NAME == NULL || SOURCING_LNUM == 0) {</a>
<a name="ln6969">        *errormsg = _(e_no_line_number_to_use_for_slnum);</a>
<a name="ln6970">        return NULL;</a>
<a name="ln6971">      }</a>
<a name="ln6972">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR, SOURCING_LNUM);</a>
<a name="ln6973">      result = strbuf;</a>
<a name="ln6974">      break;</a>
<a name="ln6975"> </a>
<a name="ln6976">    case SPEC_SFLNUM:  // line in script file</a>
<a name="ln6977">      if (current_sctx.sc_lnum + SOURCING_LNUM == 0) {</a>
<a name="ln6978">        *errormsg = _(e_no_line_number_to_use_for_sflnum);</a>
<a name="ln6979">        return NULL;</a>
<a name="ln6980">      }</a>
<a name="ln6981">      snprintf(strbuf, sizeof(strbuf), &quot;%&quot; PRIdLINENR,</a>
<a name="ln6982">               current_sctx.sc_lnum + SOURCING_LNUM);</a>
<a name="ln6983">      result = strbuf;</a>
<a name="ln6984">      break;</a>
<a name="ln6985"> </a>
<a name="ln6986">    case SPEC_SID:</a>
<a name="ln6987">      if (current_sctx.sc_sid &lt;= 0) {</a>
<a name="ln6988">        *errormsg = _(e_usingsid);</a>
<a name="ln6989">        return NULL;</a>
<a name="ln6990">      }</a>
<a name="ln6991">      snprintf(strbuf, sizeof(strbuf), &quot;&lt;SNR&gt;%&quot; PRIdSCID &quot;_&quot;,</a>
<a name="ln6992">               current_sctx.sc_sid);</a>
<a name="ln6993">      result = strbuf;</a>
<a name="ln6994">      break;</a>
<a name="ln6995"> </a>
<a name="ln6996">    default:</a>
<a name="ln6997">      // should not happen</a>
<a name="ln6998">      *errormsg = &quot;&quot;;</a>
<a name="ln6999">      result = &quot;&quot;;    // avoid gcc warning</a>
<a name="ln7000">      break;</a>
<a name="ln7001">    }</a>
<a name="ln7002"> </a>
<a name="ln7003">    // Length of new string.</a>
<a name="ln7004">    resultlen = strlen(result);</a>
<a name="ln7005">    // Remove the file name extension.</a>
<a name="ln7006">    if (src[*usedlen] == '&lt;') {</a>
<a name="ln7007">      (*usedlen)++;</a>
<a name="ln7008">      char *s;</a>
<a name="ln7009">      if ((s = strrchr(result, '.')) != NULL</a>
<a name="ln7010">          &amp;&amp; s &gt;= path_tail(result)) {</a>
<a name="ln7011">        resultlen = (size_t)(s - result);</a>
<a name="ln7012">      }</a>
<a name="ln7013">    } else if (!skip_mod) {</a>
<a name="ln7014">      valid |= modify_fname(src, tilde_file, usedlen, &amp;result,</a>
<a name="ln7015">                            &amp;resultbuf, &amp;resultlen);</a>
<a name="ln7016">      if (result == NULL) {</a>
<a name="ln7017">        *errormsg = &quot;&quot;;</a>
<a name="ln7018">        return NULL;</a>
<a name="ln7019">      }</a>
<a name="ln7020">    }</a>
<a name="ln7021">  }</a>
<a name="ln7022"> </a>
<a name="ln7023">  if (resultlen == 0 || valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7024">    if (empty_is_error) {</a>
<a name="ln7025">      if (valid != VALID_HEAD + VALID_PATH) {</a>
<a name="ln7026">        // xgettext:no-c-format</a>
<a name="ln7027">        *errormsg = _(&quot;E499: Empty file name for '%' or '#', only works with \&quot;:p:h\&quot;&quot;);</a>
<a name="ln7028">      } else {</a>
<a name="ln7029">        *errormsg = _(&quot;E500: Evaluates to an empty string&quot;);</a>
<a name="ln7030">      }</a>
<a name="ln7031">    }</a>
<a name="ln7032">    result = NULL;</a>
<a name="ln7033">  } else {</a>
<a name="ln7034">    result = xstrnsave(result, resultlen);</a>
<a name="ln7035">  }</a>
<a name="ln7036">  xfree(resultbuf);</a>
<a name="ln7037">  return result;</a>
<a name="ln7038">}</a>
<a name="ln7039"> </a>
<a name="ln7040">/// Expand the &lt;sfile&gt; string in &quot;arg&quot;.</a>
<a name="ln7041">///</a>
<a name="ln7042">/// @return  an allocated string, or NULL for any error.</a>
<a name="ln7043">char *expand_sfile(char *arg)</a>
<a name="ln7044">{</a>
<a name="ln7045">  char *result = xstrdup(arg);</a>
<a name="ln7046"> </a>
<a name="ln7047">  for (char *p = result; *p;) {</a>
<a name="ln7048">    if (strncmp(p, &quot;&lt;sfile&gt;&quot;, 7) != 0) {</a>
<a name="ln7049">      p++;</a>
<a name="ln7050">    } else {</a>
<a name="ln7051">      // replace &quot;&lt;sfile&gt;&quot; with the sourced file name, and do &quot;:&quot; stuff</a>
<a name="ln7052">      size_t srclen;</a>
<a name="ln7053">      const char *errormsg;</a>
<a name="ln7054">      char *repl = eval_vars(p, result, &amp;srclen, NULL, &amp;errormsg, NULL, true);</a>
<a name="ln7055">      if (errormsg != NULL) {</a>
<a name="ln7056">        if (*errormsg) {</a>
<a name="ln7057">          emsg(errormsg);</a>
<a name="ln7058">        }</a>
<a name="ln7059">        xfree(result);</a>
<a name="ln7060">        return NULL;</a>
<a name="ln7061">      }</a>
<a name="ln7062">      if (repl == NULL) {               // no match (cannot happen)</a>
<a name="ln7063">        p += srclen;</a>
<a name="ln7064">        continue;</a>
<a name="ln7065">      }</a>
<a name="ln7066">      size_t len = strlen(result) - srclen + strlen(repl) + 1;</a>
<a name="ln7067">      char *newres = xmalloc(len);</a>
<a name="ln7068">      memmove(newres, result, (size_t)(p - result));</a>
<a name="ln7069">      STRCPY(newres + (p - result), repl);</a>
<a name="ln7070">      len = strlen(newres);</a>
<a name="ln7071">      STRCAT(newres, p + srclen);</a>
<a name="ln7072">      xfree(repl);</a>
<a name="ln7073">      xfree(result);</a>
<a name="ln7074">      result = newres;</a>
<a name="ln7075">      p = newres + len;                 // continue after the match</a>
<a name="ln7076">    }</a>
<a name="ln7077">  }</a>
<a name="ln7078"> </a>
<a name="ln7079">  return result;</a>
<a name="ln7080">}</a>
<a name="ln7081"> </a>
<a name="ln7082">/// &quot;:rshada&quot; and &quot;:wshada&quot;.</a>
<a name="ln7083">static void ex_shada(exarg_T *eap)</a>
<a name="ln7084">{</a>
<a name="ln7085">  char *save_shada = p_shada;</a>
<a name="ln7086">  if (*p_shada == NUL) {</a>
<a name="ln7087">    p_shada = &quot;'100&quot;;</a>
<a name="ln7088">  }</a>
<a name="ln7089">  if (eap-&gt;cmdidx == CMD_rviminfo || eap-&gt;cmdidx == CMD_rshada) {</a>
<a name="ln7090">    (void)shada_read_everything(eap-&gt;arg, eap-&gt;forceit, false);</a>
<a name="ln7091">  } else {</a>
<a name="ln7092">    shada_write_file(eap-&gt;arg, eap-&gt;forceit);</a>
<a name="ln7093">  }</a>
<a name="ln7094">  p_shada = save_shada;</a>
<a name="ln7095">}</a>
<a name="ln7096"> </a>
<a name="ln7097">/// Make a dialog message in &quot;buff[DIALOG_MSG_SIZE]&quot;.</a>
<a name="ln7098">/// &quot;format&quot; must contain &quot;%s&quot;.</a>
<a name="ln7099">void dialog_msg(char *buff, char *format, char *fname)</a>
<a name="ln7100">{</a>
<a name="ln7101">  if (fname == NULL) {</a>
<a name="ln7102">    fname = _(&quot;Untitled&quot;);</a>
<a name="ln7103">  }</a>
<a name="ln7104">  vim_snprintf(buff, DIALOG_MSG_SIZE, format, fname);</a>
<a name="ln7105">}</a>
<a name="ln7106"> </a>
<a name="ln7107">static TriState filetype_detect = kNone;</a>
<a name="ln7108">static TriState filetype_plugin = kNone;</a>
<a name="ln7109">static TriState filetype_indent = kNone;</a>
<a name="ln7110"> </a>
<a name="ln7111">/// &quot;:filetype [plugin] [indent] {on,off,detect}&quot;</a>
<a name="ln7112">/// on: Load the filetype.vim file to install autocommands for file types.</a>
<a name="ln7113">/// off: Load the ftoff.vim file to remove all autocommands for file types.</a>
<a name="ln7114">/// plugin on: load filetype.vim and ftplugin.vim</a>
<a name="ln7115">/// plugin off: load ftplugof.vim</a>
<a name="ln7116">/// indent on: load filetype.vim and indent.vim</a>
<a name="ln7117">/// indent off: load indoff.vim</a>
<a name="ln7118">static void ex_filetype(exarg_T *eap)</a>
<a name="ln7119">{</a>
<a name="ln7120">  if (*eap-&gt;arg == NUL) {</a>
<a name="ln7121">    // Print current status.</a>
<a name="ln7122">    smsg(&quot;filetype detection:%s  plugin:%s  indent:%s&quot;,</a>
<a name="ln7123">         filetype_detect == kTrue ? &quot;ON&quot; : &quot;OFF&quot;,</a>
<a name="ln7124">         filetype_plugin == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;,</a>
<a name="ln7125">         filetype_indent == kTrue ? (filetype_detect == kTrue ? &quot;ON&quot; : &quot;(on)&quot;) : &quot;OFF&quot;);</a>
<a name="ln7126">    return;</a>
<a name="ln7127">  }</a>
<a name="ln7128"> </a>
<a name="ln7129">  char *arg = eap-&gt;arg;</a>
<a name="ln7130">  bool plugin = false;</a>
<a name="ln7131">  bool indent = false;</a>
<a name="ln7132"> </a>
<a name="ln7133">  // Accept &quot;plugin&quot; and &quot;indent&quot; in any order.</a>
<a name="ln7134">  while (true) {</a>
<a name="ln7135">    if (strncmp(arg, &quot;plugin&quot;, 6) == 0) {</a>
<a name="ln7136">      plugin = true;</a>
<a name="ln7137">      arg = skipwhite(arg + 6);</a>
<a name="ln7138">      continue;</a>
<a name="ln7139">    }</a>
<a name="ln7140">    if (strncmp(arg, &quot;indent&quot;, 6) == 0) {</a>
<a name="ln7141">      indent = true;</a>
<a name="ln7142">      arg = skipwhite(arg + 6);</a>
<a name="ln7143">      continue;</a>
<a name="ln7144">    }</a>
<a name="ln7145">    break;</a>
<a name="ln7146">  }</a>
<a name="ln7147">  if (strcmp(arg, &quot;on&quot;) == 0 || strcmp(arg, &quot;detect&quot;) == 0) {</a>
<a name="ln7148">    if (*arg == 'o' || !filetype_detect) {</a>
<a name="ln7149">      source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7150">      filetype_detect = kTrue;</a>
<a name="ln7151">      if (plugin) {</a>
<a name="ln7152">        source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7153">        filetype_plugin = kTrue;</a>
<a name="ln7154">      }</a>
<a name="ln7155">      if (indent) {</a>
<a name="ln7156">        source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7157">        filetype_indent = kTrue;</a>
<a name="ln7158">      }</a>
<a name="ln7159">    }</a>
<a name="ln7160">    if (*arg == 'd') {</a>
<a name="ln7161">      (void)do_doautocmd(&quot;filetypedetect BufRead&quot;, true, NULL);</a>
<a name="ln7162">      do_modelines(0);</a>
<a name="ln7163">    }</a>
<a name="ln7164">  } else if (strcmp(arg, &quot;off&quot;) == 0) {</a>
<a name="ln7165">    if (plugin || indent) {</a>
<a name="ln7166">      if (plugin) {</a>
<a name="ln7167">        source_runtime(FTPLUGOF_FILE, DIP_ALL);</a>
<a name="ln7168">        filetype_plugin = kFalse;</a>
<a name="ln7169">      }</a>
<a name="ln7170">      if (indent) {</a>
<a name="ln7171">        source_runtime(INDOFF_FILE, DIP_ALL);</a>
<a name="ln7172">        filetype_indent = kFalse;</a>
<a name="ln7173">      }</a>
<a name="ln7174">    } else {</a>
<a name="ln7175">      source_runtime(FTOFF_FILE, DIP_ALL);</a>
<a name="ln7176">      filetype_detect = kFalse;</a>
<a name="ln7177">    }</a>
<a name="ln7178">  } else {</a>
<a name="ln7179">    semsg(_(e_invarg2), arg);</a>
<a name="ln7180">  }</a>
<a name="ln7181">}</a>
<a name="ln7182"> </a>
<a name="ln7183">/// Source ftplugin.vim and indent.vim to create the necessary FileType</a>
<a name="ln7184">/// autocommands. We do this separately from filetype.vim so that these</a>
<a name="ln7185">/// autocommands will always fire first (and thus can be overridden) while still</a>
<a name="ln7186">/// allowing general filetype detection to be disabled in the user's init file.</a>
<a name="ln7187">void filetype_plugin_enable(void)</a>
<a name="ln7188">{</a>
<a name="ln7189">  if (filetype_plugin == kNone) {</a>
<a name="ln7190">    source_runtime(FTPLUGIN_FILE, DIP_ALL);</a>
<a name="ln7191">    filetype_plugin = kTrue;</a>
<a name="ln7192">  }</a>
<a name="ln7193">  if (filetype_indent == kNone) {</a>
<a name="ln7194">    source_runtime(INDENT_FILE, DIP_ALL);</a>
<a name="ln7195">    filetype_indent = kTrue;</a>
<a name="ln7196">  }</a>
<a name="ln7197">}</a>
<a name="ln7198"> </a>
<a name="ln7199">/// Enable filetype detection if the user did not explicitly disable it.</a>
<a name="ln7200">void filetype_maybe_enable(void)</a>
<a name="ln7201">{</a>
<a name="ln7202">  if (filetype_detect == kNone) {</a>
<a name="ln7203">    // Normally .vim files are sourced before .lua files when both are</a>
<a name="ln7204">    // supported, but we reverse the order here because we want the Lua</a>
<a name="ln7205">    // autocommand to be defined first so that it runs first</a>
<a name="ln7206">    source_runtime(FILETYPE_FILE, DIP_ALL);</a>
<a name="ln7207">    filetype_detect = kTrue;</a>
<a name="ln7208">  }</a>
<a name="ln7209">}</a>
<a name="ln7210"> </a>
<a name="ln7211">/// &quot;:setfiletype [FALLBACK] {name}&quot;</a>
<a name="ln7212">static void ex_setfiletype(exarg_T *eap)</a>
<a name="ln7213">{</a>
<a name="ln7214">  if (did_filetype) {</a>
<a name="ln7215">    return;</a>
<a name="ln7216">  }</a>
<a name="ln7217"> </a>
<a name="ln7218">  char *arg = eap-&gt;arg;</a>
<a name="ln7219">  if (strncmp(arg, &quot;FALLBACK &quot;, 9) == 0) {</a>
<a name="ln7220">    arg += 9;</a>
<a name="ln7221">  }</a>
<a name="ln7222"> </a>
<a name="ln7223">  set_option_value_give_err(&quot;filetype&quot;, CSTR_AS_OPTVAL(arg), OPT_LOCAL);</a>
<a name="ln7224">  if (arg != eap-&gt;arg) {</a>
<a name="ln7225">    did_filetype = false;</a>
<a name="ln7226">  }</a>
<a name="ln7227">}</a>
<a name="ln7228"> </a>
<a name="ln7229">static void ex_digraphs(exarg_T *eap)</a>
<a name="ln7230">{</a>
<a name="ln7231">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln7232">    putdigraph(eap-&gt;arg);</a>
<a name="ln7233">  } else {</a>
<a name="ln7234">    listdigraphs(eap-&gt;forceit);</a>
<a name="ln7235">  }</a>
<a name="ln7236">}</a>
<a name="ln7237"> </a>
<a name="ln7238">void set_no_hlsearch(bool flag)</a>
<a name="ln7239">{</a>
<a name="ln7240">  no_hlsearch = flag;</a>
<a name="ln7241">  set_vim_var_nr(VV_HLSEARCH, !no_hlsearch &amp;&amp; p_hls);</a>
<a name="ln7242">}</a>
<a name="ln7243"> </a>
<a name="ln7244">/// &quot;:nohlsearch&quot;</a>
<a name="ln7245">static void ex_nohlsearch(exarg_T *eap)</a>
<a name="ln7246">{</a>
<a name="ln7247">  set_no_hlsearch(true);</a>
<a name="ln7248">  redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln7249">}</a>
<a name="ln7250"> </a>
<a name="ln7251">static void ex_fold(exarg_T *eap)</a>
<a name="ln7252">{</a>
<a name="ln7253">  if (foldManualAllowed(true)) {</a>
<a name="ln7254">    pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7255">    pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7256">    foldCreate(curwin, start, end);</a>
<a name="ln7257">  }</a>
<a name="ln7258">}</a>
<a name="ln7259"> </a>
<a name="ln7260">static void ex_foldopen(exarg_T *eap)</a>
<a name="ln7261">{</a>
<a name="ln7262">  pos_T start = { eap-&gt;line1, 1, 0 };</a>
<a name="ln7263">  pos_T end = { eap-&gt;line2, 1, 0 };</a>
<a name="ln7264">  opFoldRange(start, end, eap-&gt;cmdidx == CMD_foldopen, eap-&gt;forceit, false);</a>
<a name="ln7265">}</a>
<a name="ln7266"> </a>
<a name="ln7267">static void ex_folddo(exarg_T *eap)</a>
<a name="ln7268">{</a>
<a name="ln7269">  // First set the marks for all lines closed/open.</a>
<a name="ln7270">  for (linenr_T lnum = eap-&gt;line1; lnum &lt;= eap-&gt;line2; lnum++) {</a>
<a name="ln7271">    if (hasFolding(lnum, NULL, NULL) == (eap-&gt;cmdidx == CMD_folddoclosed)) {</a>
<a name="ln7272">      ml_setmarked(lnum);</a>
<a name="ln7273">    }</a>
<a name="ln7274">  }</a>
<a name="ln7275"> </a>
<a name="ln7276">  global_exe(eap-&gt;arg);  // Execute the command on the marked lines.</a>
<a name="ln7277">  ml_clearmarked();      // clear rest of the marks</a>
<a name="ln7278">}</a>
<a name="ln7279"> </a>
<a name="ln7280">/// @return  true if the supplied Ex cmdidx is for a location list command</a>
<a name="ln7281">///          instead of a quickfix command.</a>
<a name="ln7282">bool is_loclist_cmd(int cmdidx)</a>
<a name="ln7283">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7284">{</a>
<a name="ln7285">  if (cmdidx &lt; 0 || cmdidx &gt;= CMD_SIZE) {</a>
<a name="ln7286">    return false;</a>
<a name="ln7287">  }</a>
<a name="ln7288">  return cmdnames[cmdidx].cmd_name[0] == 'l';</a>
<a name="ln7289">}</a>
<a name="ln7290"> </a>
<a name="ln7291">bool get_pressedreturn(void)</a>
<a name="ln7292">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7293">{</a>
<a name="ln7294">  return ex_pressedreturn;</a>
<a name="ln7295">}</a>
<a name="ln7296"> </a>
<a name="ln7297">void set_pressedreturn(bool val)</a>
<a name="ln7298">{</a>
<a name="ln7299">  ex_pressedreturn = val;</a>
<a name="ln7300">}</a>
<a name="ln7301"> </a>
<a name="ln7302">static void ex_terminal(exarg_T *eap)</a>
<a name="ln7303">{</a>
<a name="ln7304">  char ex_cmd[1024];</a>
<a name="ln7305">  size_t len = 0;</a>
<a name="ln7306"> </a>
<a name="ln7307">  if (cmdmod.cmod_tab &gt; 0 || cmdmod.cmod_split != 0) {</a>
<a name="ln7308">    bool multi_mods = false;</a>
<a name="ln7309"> </a>
<a name="ln7310">    // ex_cmd must be a null terminated string before passing to add_win_cmd_modifiers</a>
<a name="ln7311">    ex_cmd[0] = '\0';</a>
<a name="ln7312"> </a>
<a name="ln7313">    len = add_win_cmd_modifiers(ex_cmd, &amp;cmdmod, &amp;multi_mods);</a>
<a name="ln7314">    assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7315">    int result = snprintf(ex_cmd + len, sizeof(ex_cmd) - len, &quot; new&quot;);</a>
<a name="ln7316">    assert(result &gt; 0);</a>
<a name="ln7317">    len += (size_t)result;</a>
<a name="ln7318">  } else {</a>
<a name="ln7319">    int result = snprintf(ex_cmd, sizeof(ex_cmd), &quot;enew%s&quot;, eap-&gt;forceit ? &quot;!&quot; : &quot;&quot;);</a>
<a name="ln7320">    assert(result &gt; 0);</a>
<a name="ln7321">    len += (size_t)result;</a>
<a name="ln7322">  }</a>
<a name="ln7323"> </a>
<a name="ln7324">  assert(len &lt; sizeof(ex_cmd));</a>
<a name="ln7325"> </a>
<a name="ln7326">  if (*eap-&gt;arg != NUL) {  // Run {cmd} in 'shell'.</a>
<a name="ln7327">    char *name = vim_strsave_escaped(eap-&gt;arg, &quot;\&quot;\\&quot;);</a>
<a name="ln7328">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7329">             &quot; | call termopen(\&quot;%s\&quot;)&quot;, name);</a>
<a name="ln7330">    xfree(name);</a>
<a name="ln7331">  } else {  // No {cmd}: run the job with tokenized 'shell'.</a>
<a name="ln7332">    if (*p_sh == NUL) {</a>
<a name="ln7333">      emsg(_(e_shellempty));</a>
<a name="ln7334">      return;</a>
<a name="ln7335">    }</a>
<a name="ln7336"> </a>
<a name="ln7337">    char **argv = shell_build_argv(NULL, NULL);</a>
<a name="ln7338">    char **p = argv;</a>
<a name="ln7339">    char tempstring[512];</a>
<a name="ln7340">    char shell_argv[512] = { 0 };</a>
<a name="ln7341"> </a>
<a name="ln7342">    while (*p != NULL) {</a>
<a name="ln7343">      snprintf(tempstring, sizeof(tempstring), &quot;,\&quot;%s\&quot;&quot;, *p);</a>
<a name="ln7344">      xstrlcat(shell_argv, tempstring, sizeof(shell_argv));</a>
<a name="ln7345">      p++;</a>
<a name="ln7346">    }</a>
<a name="ln7347">    shell_free_argv(argv);</a>
<a name="ln7348"> </a>
<a name="ln7349">    snprintf(ex_cmd + len, sizeof(ex_cmd) - len,</a>
<a name="ln7350">             &quot; | call termopen([%s])&quot;, shell_argv + 1);</a>
<a name="ln7351">  }</a>
<a name="ln7352"> </a>
<a name="ln7353">  do_cmdline_cmd(ex_cmd);</a>
<a name="ln7354">}</a>
<a name="ln7355"> </a>
<a name="ln7356">void verify_command(char *cmd)</a>
<a name="ln7357">{</a>
<a name="ln7358">  if (strcmp(&quot;smile&quot;, cmd) != 0) {</a>
<a name="ln7359">    return;  // acceptable non-existing command</a>
<a name="ln7360">  }</a>
<a name="ln7361">  msg(&quot; #xxn`          #xnxx`        ,+x@##@Mz;`        .xxx&quot;</a>
<a name="ln7362">      &quot;xxxxxxnz+,      znnnnnnnnnnnnnnnn.&quot;);</a>
<a name="ln7363">  msg(&quot; n###z          x####`      :x##########W+`      ,###&quot;</a>
<a name="ln7364">      &quot;##########M;    W################.&quot;);</a>
<a name="ln7365">  msg(&quot; n####;         x####`    `z##############W:     ,###&quot;</a>
<a name="ln7366">      &quot;#############   W################.&quot;);</a>
<a name="ln7367">  msg(&quot; n####W.        x####`   ,W#################+    ,###&quot;</a>
<a name="ln7368">      &quot;##############  W################.&quot;);</a>
<a name="ln7369">  msg(&quot; n#####n        x####`   @###################    ,###&quot;</a>
<a name="ln7370">      &quot;##############i W################.&quot;);</a>
<a name="ln7371">  msg(&quot; n######i       x####`  .#########@W@########*   ,###&quot;</a>
<a name="ln7372">      &quot;##############W`W################.&quot;);</a>
<a name="ln7373">  msg(&quot; n######@.      x####`  x######W*.  `;n#######:  ,###&quot;</a>
<a name="ln7374">      &quot;#x,,,,:*M######iW###@:,,,,,,,,,,,`&quot;);</a>
<a name="ln7375">  msg(&quot; n#######n      x####` *######+`       :M#####M  ,###&quot;</a>
<a name="ln7376">      &quot;#n      `x#####xW###@`&quot;);</a>
<a name="ln7377">  msg(&quot; n########*     x####``@####@;          `x#####i ,###&quot;</a>
<a name="ln7378">      &quot;#n       ,#####@W###@`&quot;);</a>
<a name="ln7379">  msg(&quot; n########@     x####`*#####i            `M####M ,###&quot;</a>
<a name="ln7380">      &quot;#n        x#########@`&quot;);</a>
<a name="ln7381">  msg(&quot; n#########     x####`M####z              :#####:,###&quot;</a>
<a name="ln7382">      &quot;#n        z#########@`&quot;);</a>
<a name="ln7383">  msg(&quot; n#########*    x####,#####.               n####+,###&quot;</a>
<a name="ln7384">      &quot;#n        n#########@`&quot;);</a>
<a name="ln7385">  msg(&quot; n####@####@,   x####i####x                ;####x,###&quot;</a>
<a name="ln7386">      &quot;#n       `W#####@####+++++++++++i&quot;);</a>
<a name="ln7387">  msg(&quot; n####*#####M`  x#########*                `####@,###&quot;</a>
<a name="ln7388">      &quot;#n       i#####MW###############W&quot;);</a>
<a name="ln7389">  msg(&quot; n####.######+  x####z####;                 W####,###&quot;</a>
<a name="ln7390">      &quot;#n      i@######W###############W&quot;);</a>
<a name="ln7391">  msg(&quot; n####.`W#####: x####n####:                 M####:###&quot;</a>
<a name="ln7392">      &quot;#@nnnnnW#######,W###############W&quot;);</a>
<a name="ln7393">  msg(&quot; n####. :#####M`x####z####;                 W####,###&quot;</a>
<a name="ln7394">      &quot;##############z W###############W&quot;);</a>
<a name="ln7395">  msg(&quot; n####.  #######x#########*                `####W,###&quot;</a>
<a name="ln7396">      &quot;#############W` W###############W&quot;);</a>
<a name="ln7397">  msg(&quot; n####.  `M#####W####i####x                ;####x,###&quot;</a>
<a name="ln7398">      &quot;############W,  W####+**********i&quot;);</a>
<a name="ln7399">  msg(&quot; n####.   ,##########,#####.               n####+,###&quot;</a>
<a name="ln7400">      &quot;###########n.   W###@`&quot;);</a>
<a name="ln7401">  msg(&quot; n####.    ##########`M####z              :#####:,###&quot;</a>
<a name="ln7402">      &quot;########Wz:     W###@`&quot;);</a>
<a name="ln7403">  msg(&quot; n####.    x#########`*#####i            `M####M ,###&quot;</a>
<a name="ln7404">      &quot;#x.....`        W###@`&quot;);</a>
<a name="ln7405">  msg(&quot; n####.    ,@########``@####@;          `x#####i ,###&quot;</a>
<a name="ln7406">      &quot;#n              W###@`&quot;);</a>
<a name="ln7407">  msg(&quot; n####.     *########` *#####@+`       ,M#####M  ,###&quot;</a>
<a name="ln7408">      &quot;#n              W###@`&quot;);</a>
<a name="ln7409">  msg(&quot; n####.      x#######`  x######W*.  `;n######@:  ,###&quot;</a>
<a name="ln7410">      &quot;#n              W###@,,,,,,,,,,,,`&quot;);</a>
<a name="ln7411">  msg(&quot; n####.      .@######`  .#########@W@########*   ,###&quot;</a>
<a name="ln7412">      &quot;#n              W################,&quot;);</a>
<a name="ln7413">  msg(&quot; n####.       i######`   @###################    ,###&quot;</a>
<a name="ln7414">      &quot;#n              W################,&quot;);</a>
<a name="ln7415">  msg(&quot; n####.        n#####`   ,W#################+    ,###&quot;</a>
<a name="ln7416">      &quot;#n              W################,&quot;);</a>
<a name="ln7417">  msg(&quot; n####.        .@####`    .n##############W;     ,###&quot;</a>
<a name="ln7418">      &quot;#n              W################,&quot;);</a>
<a name="ln7419">  msg(&quot; n####.         i####`      :x##########W+`      ,###&quot;</a>
<a name="ln7420">      &quot;#n              W################,&quot;);</a>
<a name="ln7421">  msg(&quot; +nnnn`          +nnn`        ,+x@##@Mz;`        .nnn&quot;</a>
<a name="ln7422">      &quot;n+              zxxxxxxxxxxxxxxxx.&quot;);</a>
<a name="ln7423">  msg(&quot; &quot;);</a>
<a name="ln7424">  msg(&quot;                                                     &quot;</a>
<a name="ln7425">      &quot;                              ,+M@#Mi&quot;);</a>
<a name="ln7426">  msg(&quot;                                 &quot;</a>
<a name="ln7427">      &quot;                                                .z########&quot;);</a>
<a name="ln7428">  msg(&quot;                                 &quot;</a>
<a name="ln7429">      &quot;                                               i@#########i&quot;);</a>
<a name="ln7430">  msg(&quot;                                 &quot;</a>
<a name="ln7431">      &quot;                                             `############W`&quot;);</a>
<a name="ln7432">  msg(&quot;                                 &quot;</a>
<a name="ln7433">      &quot;                                            `n#############i&quot;);</a>
<a name="ln7434">  msg(&quot;                                 &quot;</a>
<a name="ln7435">      &quot;                                           `n##############n&quot;);</a>
<a name="ln7436">  msg(&quot;     ``                          &quot;</a>
<a name="ln7437">      &quot;                                           z###############@`&quot;);</a>
<a name="ln7438">  msg(&quot;    `W@z,                        &quot;</a>
<a name="ln7439">      &quot;                                          ##################,&quot;);</a>
<a name="ln7440">  msg(&quot;    *#####`                      &quot;</a>
<a name="ln7441">      &quot;                                         i############@x@###i&quot;);</a>
<a name="ln7442">  msg(&quot;    ######M.                     &quot;</a>
<a name="ln7443">      &quot;                                        :#############n`,W##+&quot;);</a>
<a name="ln7444">  msg(&quot;    +######@:                    &quot;</a>
<a name="ln7445">      &quot;                                       .W#########M@##+  *##z&quot;);</a>
<a name="ln7446">  msg(&quot;    :#######@:                   &quot;</a>
<a name="ln7447">      &quot;                                      `x########@#x###*  ,##n&quot;);</a>
<a name="ln7448">  msg(&quot;    `@#######@;                  &quot;</a>
<a name="ln7449">      &quot;                                      z#########M*@nW#i  .##x&quot;);</a>
<a name="ln7450">  msg(&quot;     z########@i                 &quot;</a>
<a name="ln7451">      &quot;                                     *###########WM#@#,  `##x&quot;);</a>
<a name="ln7452">  msg(&quot;     i##########+                &quot;</a>
<a name="ln7453">      &quot;                                    ;###########*n###@   `##x&quot;);</a>
<a name="ln7454">  msg(&quot;     `@#MM#######x,              &quot;</a>
<a name="ln7455">      &quot;                                   ,@#########zM,`z##M   `@#x&quot;);</a>
<a name="ln7456">  msg(&quot;      n##M#W#######n.            &quot;</a>
<a name="ln7457">      &quot;   `.:i*+#zzzz##+i:.`             ,W#########Wii,`n@#@` n@##n&quot;);</a>
<a name="ln7458">  msg(&quot;      ;###@#x#######n         `,i&quot;</a>
<a name="ln7459">      &quot;#nW@#####@@WWW@@####@Mzi.        ,W##########@z.. ;zM#+i####z&quot;);</a>
<a name="ln7460">  msg(&quot;       x####nz########    .;#x@##&quot;</a>
<a name="ln7461">      &quot;@Wn#*;,.`      ``,:*#x@##M+,    ;@########xz@WM+#` `n@#######&quot;);</a>
<a name="ln7462">  msg(&quot;       ,@####M########xi#@##@Mzi,&quot;</a>
<a name="ln7463">      &quot;`                     .+x###Mi:n##########Mz```.:i  *@######*&quot;);</a>
<a name="ln7464">  msg(&quot;        *#####W#########ix+:`    &quot;</a>
<a name="ln7465">      &quot;                         :n#############z:       `*.`M######i&quot;);</a>
<a name="ln7466">  msg(&quot;        i#W##nW@+@##@#M@;        &quot;</a>
<a name="ln7467">      &quot;                           ;W@@##########W,        i`x@#####,&quot;);</a>
<a name="ln7468">  msg(&quot;        `@@n@Wn#@iMW*#*:         &quot;</a>
<a name="ln7469">      &quot;                            `iz#z@######x.           M######`&quot;);</a>
<a name="ln7470">  msg(&quot;         z##zM###x`*, .`         &quot;</a>
<a name="ln7471">      &quot;                                 `iW#####W;:`        +#####M&quot;);</a>
<a name="ln7472">  msg(&quot;         ,###nn##n`              &quot;</a>
<a name="ln7473">      &quot;                                  ,#####x;`        ,;@######&quot;);</a>
<a name="ln7474">  msg(&quot;          x###xz#.               &quot;</a>
<a name="ln7475">      &quot;                                    in###+        `:######@.&quot;);</a>
<a name="ln7476">  msg(&quot;          ;####n+                &quot;</a>
<a name="ln7477">      &quot;                                    `Mnx##xi`   , zM#######&quot;);</a>
<a name="ln7478">  msg(&quot;          `W####+                &quot;</a>
<a name="ln7479">      &quot;i.                                   `.+x###@#. :n,z######:&quot;);</a>
<a name="ln7480">  msg(&quot;           z####@`              ;&quot;</a>
<a name="ln7481">      &quot;#:                                     .ii@###@;.*M*z####@`&quot;);</a>
<a name="ln7482">  msg(&quot;           i####M         `   `i@&quot;</a>
<a name="ln7483">      &quot;#,           ::                           +#n##@+@##W####n&quot;);</a>
<a name="ln7484">  msg(&quot;           :####x    ,i. ##xzM###&quot;</a>
<a name="ln7485">      &quot;@`     i.   .@@,                           .z####x#######*&quot;);</a>
<a name="ln7486">  msg(&quot;           ,###W;   i##Wz########&quot;</a>
<a name="ln7487">      &quot;#     :##   z##n                           ,@########x###:&quot;);</a>
<a name="ln7488">  msg(&quot;            n##n   `W###########M&quot;</a>
<a name="ln7489">      &quot;`;n,  i#x  ,###@i                           *W########W#@`&quot;);</a>
<a name="ln7490">  msg(&quot;           .@##+  `x###########@.&quot;</a>
<a name="ln7491">      &quot; z#+ .M#W``x#####n`                         `;#######@z#x&quot;);</a>
<a name="ln7492">  msg(&quot;           n###z :W############@ &quot;</a>
<a name="ln7493">      &quot; z#*  @##xM#######@n;                        `########nW+&quot;);</a>
<a name="ln7494">  msg(&quot;          ;####nW##############W &quot;</a>
<a name="ln7495">      &quot;:@#* `@#############*                        :########z@i`&quot;);</a>
<a name="ln7496">  msg(&quot;          M##################### &quot;</a>
<a name="ln7497">      &quot;M##:  @#############@:                       *W########M#&quot;);</a>
<a name="ln7498">  msg(&quot;         ;#####################i.&quot;</a>
<a name="ln7499">      &quot;##x`  W#############W,                       :n########zx&quot;);</a>
<a name="ln7500">  msg(&quot;         x####################@.`&quot;</a>
<a name="ln7501">      &quot;x;    @#############z.                       .@########W#&quot;);</a>
<a name="ln7502">  msg(&quot;        ,######################` &quot;</a>
<a name="ln7503">      &quot;      W###############x*,`                    W######zM#i&quot;);</a>
<a name="ln7504">  msg(&quot;        #######################: &quot;</a>
<a name="ln7505">      &quot;      z##################@x+*#zzi            `@#########.&quot;);</a>
<a name="ln7506">  msg(&quot;        W########W#z#M#########; &quot;</a>
<a name="ln7507">      &quot;      *##########################z            :@#######@`&quot;);</a>
<a name="ln7508">  msg(&quot;       `@#######x`;#z ,x#######; &quot;</a>
<a name="ln7509">      &quot;      z###########M###xnM@########*            :M######@&quot;);</a>
<a name="ln7510">  msg(&quot;       i########, x#@`  z######; &quot;</a>
<a name="ln7511">      &quot;      *##########i *#@`  `+########+`            n######.&quot;);</a>
<a name="ln7512">  msg(&quot;       n#######@` M##,  `W#####. &quot;</a>
<a name="ln7513">      &quot;      *#########z  ###;    z########M:           :W####n&quot;);</a>
<a name="ln7514">  msg(&quot;       M#######M  n##.   x####x  &quot;</a>
<a name="ln7515">      &quot;      `x########:  z##+    M#########@;           .n###+&quot;);</a>
<a name="ln7516">  msg(&quot;       W#######@` :#W   `@####:  &quot;</a>
<a name="ln7517">      &quot;       `@######W   i###   ;###########@.            n##n&quot;);</a>
<a name="ln7518">  msg(&quot;       W########z` ,,  .x####z   &quot;</a>
<a name="ln7519">      &quot;        @######@`  `W#;  `W############*            *###;&quot;);</a>
<a name="ln7520">  msg(&quot;      `@#########Mi,:*n@####W`   &quot;</a>
<a name="ln7521">      &quot;        W#######*   ..  `n#############i            i###x&quot;);</a>
<a name="ln7522">  msg(&quot;      .#####################z    &quot;</a>
<a name="ln7523">      &quot;       `@#######@*`    .x############n:`            ;####.&quot;);</a>
<a name="ln7524">  msg(&quot;      :####################x`,,` &quot;</a>
<a name="ln7525">      &quot;       `W#########@x#+#@#############i              ,####:&quot;);</a>
<a name="ln7526">  msg(&quot;      ;###################x#@###x&quot;</a>
<a name="ln7527">      &quot;i`      *############################:              `####i&quot;);</a>
<a name="ln7528">  msg(&quot;      i##################+#######&quot;</a>
<a name="ln7529">      &quot;#M,      x##########################@`               W###i&quot;);</a>
<a name="ln7530">  msg(&quot;      *################@; @######&quot;</a>
<a name="ln7531">      &quot;##@,     .W#########################@                x###:&quot;);</a>
<a name="ln7532">  msg(&quot;      .+M#############z.  M######&quot;</a>
<a name="ln7533">      &quot;###x      ,W########################@`               ####.&quot;);</a>
<a name="ln7534">  msg(&quot;      *M*;z@########x:    :W#####&quot;</a>
<a name="ln7535">      &quot;##i        .M########################i               i###:&quot;);</a>
<a name="ln7536">  msg(&quot;      *##@z;#@####x:        :z###&quot;</a>
<a name="ln7537">      &quot;@i          `########################x               .###;&quot;);</a>
<a name="ln7538">  msg(&quot;      *#####n;#@##            ;##&quot;</a>
<a name="ln7539">      &quot;*             ,x#####################@`               W##*&quot;);</a>
<a name="ln7540">  msg(&quot;      *#######n;*            :M##&quot;</a>
<a name="ln7541">      &quot;W*,             *W####################`               n##z&quot;);</a>
<a name="ln7542">  msg(&quot;      i########@.         ,*n####&quot;</a>
<a name="ln7543">      &quot;###M*`           `###################M                *##M&quot;);</a>
<a name="ln7544">  msg(&quot;      i########n        `z#####@@&quot;</a>
<a name="ln7545">      &quot;#####Wi            ,M################;                ,##@`&quot;);</a>
<a name="ln7546">  msg(&quot;      ;WMWW@###*       .x##@ni.``&quot;</a>
<a name="ln7547">      &quot;.:+zW##z`           `n##############z                  @##,&quot;);</a>
<a name="ln7548">  msg(&quot;      .*++*i;;;.      .M#@+`     &quot;</a>
<a name="ln7549">      &quot;     .##n            `x############x`                  n##i&quot;);</a>
<a name="ln7550">  msg(&quot;      :########*      x#W,       &quot;</a>
<a name="ln7551">      &quot;       *#+            *###########M`                   +##+&quot;);</a>
<a name="ln7552">  msg(&quot;      ,#########     :#@:        &quot;</a>
<a name="ln7553">      &quot;        ##:           #nzzzzzzzzzz.                    :##x&quot;);</a>
<a name="ln7554">  msg(&quot;      .#####Wz+`     ##+         &quot;</a>
<a name="ln7555">      &quot;        `MM`          .znnnnnnnnn.                     `@#@`&quot;);</a>
<a name="ln7556">  msg(&quot;      `@@ni;*nMz`    @W`         &quot;</a>
<a name="ln7557">      &quot;         :#+           .x#######n                       x##,&quot;);</a>
<a name="ln7558">  msg(&quot;       i;z@#####,   .#*          &quot;</a>
<a name="ln7559">      &quot;          z#:           ;;;*zW##;                       ###i&quot;);</a>
<a name="ln7560">  msg(&quot;       z########:   :#;          &quot;</a>
<a name="ln7561">      &quot;          `Wx          +###Wni;n.                       ;##z&quot;);</a>
<a name="ln7562">  msg(&quot;       n########W:  .#*          &quot;</a>
<a name="ln7563">      &quot;           ,#,        ;#######@+                        `@#M&quot;);</a>
<a name="ln7564">  msg(&quot;      .###########n;.MM          &quot;</a>
<a name="ln7565">      &quot;            n*        ;iM#######*                        x#@`&quot;);</a>
<a name="ln7566">  msg(&quot;      :#############@;;          &quot;</a>
<a name="ln7567">      &quot;            .n`      ,#W*iW#####W`                       +##,&quot;);</a>
<a name="ln7568">  msg(&quot;      ,##############.           &quot;</a>
<a name="ln7569">      &quot;             ix.    `x###M;#######                       ,##i&quot;);</a>
<a name="ln7570">  msg(&quot;      .#############@`           &quot;</a>
<a name="ln7571">      &quot;              x@n**#W######z;M###@.                       W##&quot;);</a>
<a name="ln7572">  msg(&quot;      .##############W:          &quot;</a>
<a name="ln7573">      &quot;              .x############@*;zW#;                       z#x&quot;);</a>
<a name="ln7574">  msg(&quot;      ,###############@;         &quot;</a>
<a name="ln7575">      &quot;               `##############@n*;.                       i#@&quot;);</a>
<a name="ln7576">  msg(&quot;      ,#################i        &quot;</a>
<a name="ln7577">      &quot;                 :n##############W`                       .##,&quot;);</a>
<a name="ln7578">  msg(&quot;      ,###################`      &quot;</a>
<a name="ln7579">      &quot;                   .+W##########W,                        `##i&quot;);</a>
<a name="ln7580">  msg(&quot;      :###################@zi,`  &quot;</a>
<a name="ln7581">      &quot;                      ;zM@@@WMn*`                          @#z&quot;);</a>
<a name="ln7582">  msg(&quot;      :#######################@x+&quot;</a>
<a name="ln7583">      &quot;*i;;:i#M,                 ``                               M#W&quot;);</a>
<a name="ln7584">  msg(&quot;      ;##########################&quot;</a>
<a name="ln7585">      &quot;######@x.                                                  n##,&quot;);</a>
<a name="ln7586">  msg(&quot;      i#####################@W@@@&quot;</a>
<a name="ln7587">      &quot;@Wxz*:`                                                    *##+&quot;);</a>
<a name="ln7588">  msg(&quot;      *######################+```&quot;</a>
<a name="ln7589">      &quot;                                                           :##M&quot;);</a>
<a name="ln7590">  msg(&quot;      ########################M; &quot;</a>
<a name="ln7591">      &quot;                                                           `@##,&quot;);</a>
<a name="ln7592">  msg(&quot;      z#########################x&quot;</a>
<a name="ln7593">      &quot;,                                                           z###&quot;);</a>
<a name="ln7594">  msg(&quot;      n##########################&quot;</a>
<a name="ln7595">      &quot;#n:                                                         ;##W`&quot;);</a>
<a name="ln7596">  msg(&quot;      x##########################&quot;</a>
<a name="ln7597">      &quot;###Mz#++##*                                                 `W##i&quot;);</a>
<a name="ln7598">  msg(&quot;      M##########################&quot;</a>
<a name="ln7599">      &quot;##########@`                                                 ###x&quot;);</a>
<a name="ln7600">  msg(&quot;      W##########################&quot;</a>
<a name="ln7601">      &quot;###########`                                                 .###,&quot;);</a>
<a name="ln7602">  msg(&quot;      @##########################&quot;</a>
<a name="ln7603">      &quot;##########M                                                   n##z&quot;);</a>
<a name="ln7604">  msg(&quot;      @##################z*i@WMMM&quot;</a>
<a name="ln7605">      &quot;x#x@#####,.                                                   :##@.&quot;);</a>
<a name="ln7606">  msg(&quot;     `#####################@xi`  &quot;</a>
<a name="ln7607">      &quot;   `::,*                                                       x##+&quot;);</a>
<a name="ln7608">  msg(&quot;     .#####################@#M.  &quot;</a>
<a name="ln7609">      &quot;                                                               ;##@`&quot;);</a>
<a name="ln7610">  msg(&quot;     ,#####################:.    &quot;</a>
<a name="ln7611">      &quot;                                                                M##i&quot;);</a>
<a name="ln7612">  msg(&quot;     ;###################ni`     &quot;</a>
<a name="ln7613">      &quot;                                                                i##M&quot;);</a>
<a name="ln7614">  msg(&quot;     *#################W#`       &quot;</a>
<a name="ln7615">      &quot;                                                                `W##,&quot;);</a>
<a name="ln7616">  msg(&quot;     z#################@Wx+.     &quot;</a>
<a name="ln7617">      &quot;                                                                 +###&quot;);</a>
<a name="ln7618">  msg(&quot;     x######################z.   &quot;</a>
<a name="ln7619">      &quot;                                                                 .@#@`&quot;);</a>
<a name="ln7620">  msg(&quot;    `@#######################@;  &quot;</a>
<a name="ln7621">      &quot;                                                                  z##;&quot;);</a>
<a name="ln7622">  msg(&quot;    :##########################: &quot;</a>
<a name="ln7623">      &quot;                                                                  :##z&quot;);</a>
<a name="ln7624">  msg(&quot;    +#########################W# &quot;</a>
<a name="ln7625">      &quot;                                                                   M#W&quot;);</a>
<a name="ln7626">  msg(&quot;    W################@n+*i;:,`                                &quot;</a>
<a name="ln7627">      &quot;                                      +##,&quot;);</a>
<a name="ln7628">  msg(&quot;   :##################WMxz+,                                  &quot;</a>
<a name="ln7629">      &quot;                                      ,##i&quot;);</a>
<a name="ln7630">  msg(&quot;   n#######################W..,                               &quot;</a>
<a name="ln7631">      &quot;                                       W##&quot;);</a>
<a name="ln7632">  msg(&quot;  +#########################WW@+. .:.                         &quot;</a>
<a name="ln7633">      &quot;                                       z#x&quot;);</a>
<a name="ln7634">  msg(&quot; `@#############################@@###:                        &quot;</a>
<a name="ln7635">      &quot;                                       *#W&quot;);</a>
<a name="ln7636">  msg(&quot; #################################Wz:                         &quot;</a>
<a name="ln7637">      &quot;                                       :#@&quot;);</a>
<a name="ln7638">  msg(&quot;,@###############################i                            &quot;</a>
<a name="ln7639">      &quot;                                       .##&quot;);</a>
<a name="ln7640">  msg(&quot;n@@@@@@@#########################+                            &quot;</a>
<a name="ln7641">      &quot;                                       `##&quot;);</a>
<a name="ln7642">  msg(&quot;`      `.:.`.,:iii;;;;;;;;iii;;;:`       `.``                 &quot;</a>
<a name="ln7643">      &quot;                                       `nW&quot;);</a>
<a name="ln7644">}</a>
<a name="ln7645"> </a>
<a name="ln7646">/// Get argt of command with id</a>
<a name="ln7647">uint32_t get_cmd_argt(cmdidx_T cmdidx)</a>
<a name="ln7648">{</a>
<a name="ln7649">  return cmdnames[(int)cmdidx].cmd_argt;</a>
<a name="ln7650">}</a>
</code></pre>
<div class="balloon" rel="3143"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'name == NULL' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>