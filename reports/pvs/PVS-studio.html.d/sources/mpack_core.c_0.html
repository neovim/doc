<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>mpack_core.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;string.h&gt;</a>
<a name="ln5"> </a>
<a name="ln6">#include &quot;mpack_core.h&quot;</a>
<a name="ln7"> </a>
<a name="ln8">#define UNUSED(p) (void)p;</a>
<a name="ln9">#define ADVANCE(buf, buflen) ((*buflen)--, (unsigned char)*((*buf)++))</a>
<a name="ln10">#define TLEN(val, range_start) ((mpack_uint32_t)(1 &lt;&lt; (val - range_start)))</a>
<a name="ln11">#ifndef MIN</a>
<a name="ln12"># define MIN(X, Y) ((X) &lt; (Y) ? (X) : (Y))</a>
<a name="ln13">#endif</a>
<a name="ln14"> </a>
<a name="ln15">static int mpack_rpending(const char **b, size_t *nl, mpack_tokbuf_t *tb);</a>
<a name="ln16">static int mpack_rvalue(mpack_token_type_t t, mpack_uint32_t l,</a>
<a name="ln17">    const char **b, size_t *bl, mpack_token_t *tok);</a>
<a name="ln18">static int mpack_rblob(mpack_token_type_t t, mpack_uint32_t l,</a>
<a name="ln19">    const char **b, size_t *bl, mpack_token_t *tok);</a>
<a name="ln20">static int mpack_wtoken(const mpack_token_t *tok, char **b, size_t *bl);</a>
<a name="ln21">static int mpack_wpending(char **b, size_t *bl, mpack_tokbuf_t *tb);</a>
<a name="ln22">static int mpack_wpint(char **b, size_t *bl, mpack_value_t v);</a>
<a name="ln23">static int mpack_wnint(char **b, size_t *bl, mpack_value_t v);</a>
<a name="ln24">static int mpack_wfloat(char **b, size_t *bl, const mpack_token_t *v);</a>
<a name="ln25">static int mpack_wstr(char **buf, size_t *buflen, mpack_uint32_t len);</a>
<a name="ln26">static int mpack_wbin(char **buf, size_t *buflen, mpack_uint32_t len);</a>
<a name="ln27">static int mpack_wext(char **buf, size_t *buflen, int type,</a>
<a name="ln28">    mpack_uint32_t len);</a>
<a name="ln29">static int mpack_warray(char **buf, size_t *buflen, mpack_uint32_t len);</a>
<a name="ln30">static int mpack_wmap(char **buf, size_t *buflen, mpack_uint32_t len);</a>
<a name="ln31">static int mpack_w1(char **b, size_t *bl, mpack_uint32_t v);</a>
<a name="ln32">static int mpack_w2(char **b, size_t *bl, mpack_uint32_t v);</a>
<a name="ln33">static int mpack_w4(char **b, size_t *bl, mpack_uint32_t v);</a>
<a name="ln34">static mpack_value_t mpack_byte(unsigned char b);</a>
<a name="ln35">static int mpack_value(mpack_token_type_t t, mpack_uint32_t l,</a>
<a name="ln36">    mpack_value_t v, mpack_token_t *tok);</a>
<a name="ln37">static int mpack_blob(mpack_token_type_t t, mpack_uint32_t l, int et,</a>
<a name="ln38">    mpack_token_t *tok);</a>
<a name="ln39"> </a>
<a name="ln40">MPACK_API void mpack_tokbuf_init(mpack_tokbuf_t *tokbuf)</a>
<a name="ln41">{</a>
<a name="ln42">  tokbuf-&gt;ppos = 0;</a>
<a name="ln43">  tokbuf-&gt;plen = 0;</a>
<a name="ln44">  tokbuf-&gt;passthrough = 0;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">MPACK_API int mpack_read(mpack_tokbuf_t *tokbuf, const char **buf,</a>
<a name="ln48">    size_t *buflen, mpack_token_t *tok)</a>
<a name="ln49">{</a>
<a name="ln50">  int status;</a>
<a name="ln51">  size_t initial_ppos, ptrlen, advanced;</a>
<a name="ln52">  const char *ptr, *ptr_save;</a>
<a name="ln53">  assert(*buf);</a>
<a name="ln54">  if (*buflen == 0) {</a>
<a name="ln55">    return MPACK_EOF;</a>
<a name="ln56">  }</a>
<a name="ln57"> </a>
<a name="ln58">  if (tokbuf-&gt;passthrough) {</a>
<a name="ln59">    /* pass data from str/bin/ext directly as a MPACK_TOKEN_CHUNK, adjusting</a>
<a name="ln60">     * *buf and *buflen */</a>
<a name="ln61">    tok-&gt;type = MPACK_TOKEN_CHUNK;</a>
<a name="ln62">    tok-&gt;data.chunk_ptr = *buf;</a>
<a name="ln63">    tok-&gt;length = MIN((mpack_uint32_t)*buflen, tokbuf-&gt;passthrough);</a>
<a name="ln64">    tokbuf-&gt;passthrough -= tok-&gt;length;</a>
<a name="ln65">    *buf += tok-&gt;length;</a>
<a name="ln66">    *buflen -= tok-&gt;length;</a>
<a name="ln67">    goto done;</a>
<a name="ln68">  }</a>
<a name="ln69"> </a>
<a name="ln70">  initial_ppos = tokbuf-&gt;ppos;</a>
<a name="ln71"> </a>
<a name="ln72">  if (tokbuf-&gt;plen) {</a>
<a name="ln73">    if (!mpack_rpending(buf, buflen, tokbuf)) {</a>
<a name="ln74">      return MPACK_EOF;</a>
<a name="ln75">    }</a>
<a name="ln76">    ptr = tokbuf-&gt;pending;</a>
<a name="ln77">    ptrlen = tokbuf-&gt;ppos;</a>
<a name="ln78">  } else {</a>
<a name="ln79">    ptr = *buf;</a>
<a name="ln80">    ptrlen = *buflen;</a>
<a name="ln81">  }</a>
<a name="ln82"> </a>
<a name="ln83">  ptr_save = ptr;</a>
<a name="ln84"> </a>
<a name="ln85">  if ((status = mpack_rtoken(&amp;ptr, &amp;ptrlen, tok))) {</a>
<a name="ln86">    if (status != MPACK_EOF) return MPACK_ERROR;</a>
<a name="ln87">    /* need more data */</a>
<a name="ln88">    assert(!tokbuf-&gt;plen);</a>
<a name="ln89">    /* read the remainder of *buf to tokbuf-&gt;pending so it can be parsed</a>
<a name="ln90">     * later with more data. only required when tokbuf-&gt;plen == 0 or else</a>
<a name="ln91">     * it would have been done already. */</a>
<a name="ln92">    tokbuf-&gt;plen = tok-&gt;length + 1;</a>
<a name="ln93">    assert(tokbuf-&gt;plen &lt;= sizeof(tokbuf-&gt;pending));</a>
<a name="ln94">    tokbuf-&gt;ppos = 0;</a>
<a name="ln95">    status = mpack_rpending(buf, buflen, tokbuf);</a>
<a name="ln96">    assert(!status);</a>
<a name="ln97">    return MPACK_EOF;</a>
<a name="ln98">  }</a>
<a name="ln99"> </a>
<a name="ln100">  advanced = (size_t)(ptr - ptr_save) - initial_ppos;</a>
<a name="ln101">  tokbuf-&gt;plen = tokbuf-&gt;ppos = 0;</a>
<a name="ln102">  *buflen -= advanced; </a>
<a name="ln103">  *buf += advanced;</a>
<a name="ln104"> </a>
<a name="ln105">  if (tok-&gt;type &gt; MPACK_TOKEN_MAP) {</a>
<a name="ln106">    tokbuf-&gt;passthrough = tok-&gt;length;</a>
<a name="ln107">  }</a>
<a name="ln108"> </a>
<a name="ln109">done:</a>
<a name="ln110">  return MPACK_OK;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">MPACK_API int mpack_write(mpack_tokbuf_t *tokbuf, char **buf, size_t *buflen,</a>
<a name="ln114">    const mpack_token_t *t)</a>
<a name="ln115">{</a>
<a name="ln116">  int status;</a>
<a name="ln117">  char *ptr;</a>
<a name="ln118">  size_t ptrlen;</a>
<a name="ln119">  mpack_token_t tok = tokbuf-&gt;plen ? tokbuf-&gt;pending_tok : *t;</a>
<a name="ln120">  assert(*buf &amp;&amp; *buflen);</a>
<a name="ln121"> </a>
<a name="ln122">  if (tok.type == MPACK_TOKEN_CHUNK) {</a>
<a name="ln123">    size_t written, pending, count;</a>
<a name="ln124">    if (!tokbuf-&gt;plen) tokbuf-&gt;ppos = 0;</a>
<a name="ln125">    written = tokbuf-&gt;ppos;</a>
<a name="ln126">    pending = tok.length - written;</a>
<a name="ln127">    count = MIN(pending, *buflen);</a>
<a name="ln128">    memcpy(*buf, tok.data.chunk_ptr + written, count);</a>
<a name="ln129">    *buf += count;</a>
<a name="ln130">    *buflen -= count;</a>
<a name="ln131">    tokbuf-&gt;ppos += count;</a>
<a name="ln132">    tokbuf-&gt;plen = count == pending ? 0 : tok.length;</a>
<a name="ln133">    if (count == pending) {</a>
<a name="ln134">      return MPACK_OK;</a>
<a name="ln135">    } else {</a>
<a name="ln136">      tokbuf-&gt;pending_tok = tok;</a>
<a name="ln137">      return MPACK_EOF;</a>
<a name="ln138">    }</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  if (tokbuf-&gt;plen) return mpack_wpending(buf, buflen, tokbuf);</a>
<a name="ln142"> </a>
<a name="ln143">  if (*buflen &lt; MPACK_MAX_TOKEN_LEN) {</a>
<a name="ln144">    ptr = tokbuf-&gt;pending;</a>
<a name="ln145">    ptrlen = sizeof(tokbuf-&gt;pending);</a>
<a name="ln146">  } else {</a>
<a name="ln147">    ptr = *buf;</a>
<a name="ln148">    ptrlen = *buflen;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  if ((status = mpack_wtoken(&amp;tok, &amp;ptr, &amp;ptrlen))) return status;</a>
<a name="ln152"> </a>
<a name="ln153">  if (*buflen &lt; MPACK_MAX_TOKEN_LEN) {</a>
<a name="ln154">    size_t toklen = sizeof(tokbuf-&gt;pending) - ptrlen;</a>
<a name="ln155">    size_t write_cnt = MIN(toklen, *buflen);</a>
<a name="ln156">    memcpy(*buf, tokbuf-&gt;pending, write_cnt);</a>
<a name="ln157">    *buf += write_cnt;</a>
<a name="ln158">    *buflen -= write_cnt;</a>
<a name="ln159">    if (write_cnt &lt; toklen) {</a>
<a name="ln160">      assert(!*buflen);</a>
<a name="ln161">      tokbuf-&gt;plen = toklen;</a>
<a name="ln162">      tokbuf-&gt;ppos = write_cnt;</a>
<a name="ln163">      tokbuf-&gt;pending_tok = tok;</a>
<a name="ln164">      return MPACK_EOF;</a>
<a name="ln165">    }</a>
<a name="ln166">  } else {</a>
<a name="ln167">    *buflen -= (size_t)(ptr - *buf);</a>
<a name="ln168">    *buf = ptr;</a>
<a name="ln169">  }</a>
<a name="ln170"> </a>
<a name="ln171">  return MPACK_OK;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">int mpack_rtoken(const char **buf, size_t *buflen, mpack_token_t *tok)</a>
<a name="ln175">{</a>
<a name="ln176">  if (*buflen == 0) {</a>
<a name="ln177">    return MPACK_EOF;</a>
<a name="ln178">  }</a>
<a name="ln179">  unsigned char t = ADVANCE(buf, buflen);</a>
<a name="ln180">  if (t &lt; 0x80) {</a>
<a name="ln181">    /* positive fixint */</a>
<a name="ln182">    return mpack_value(MPACK_TOKEN_UINT, 1, mpack_byte(t), tok);</a>
<a name="ln183">  } else if (t &lt; 0x90) {</a>
<a name="ln184">    /* fixmap */</a>
<a name="ln185">    return mpack_blob(MPACK_TOKEN_MAP, t &amp; 0xf, 0, tok);</a>
<a name="ln186">  } else if (t &lt; 0xa0) {</a>
<a name="ln187">    /* fixarray */</a>
<a name="ln188">    return mpack_blob(MPACK_TOKEN_ARRAY, t &amp; 0xf, 0, tok);</a>
<a name="ln189">  } else if (t &lt; 0xc0) {</a>
<a name="ln190">    /* fixstr */</a>
<a name="ln191">    return mpack_blob(MPACK_TOKEN_STR, t &amp; 0x1f, 0, tok);</a>
<a name="ln192">  } else if (t &lt; 0xe0) {</a>
<a name="ln193">    switch (t) {</a>
<a name="ln194">      case 0xc0:  /* nil */</a>
<a name="ln195">        return mpack_value(MPACK_TOKEN_NIL, 0, mpack_byte(0), tok);</a>
<a name="ln196">      case 0xc2:  /* false */</a>
<a name="ln197">        return mpack_value(MPACK_TOKEN_BOOLEAN, 1, mpack_byte(0), tok);</a>
<a name="ln198">      case 0xc3:  /* true */</a>
<a name="ln199">        return mpack_value(MPACK_TOKEN_BOOLEAN, 1, mpack_byte(1), tok);</a>
<a name="ln200">      case 0xc4:  /* bin 8 */</a>
<a name="ln201">      case 0xc5:  /* bin 16 */</a>
<a name="ln202">      case 0xc6:  /* bin 32 */</a>
<a name="ln203">        return mpack_rblob(MPACK_TOKEN_BIN, TLEN(t, 0xc4), buf, buflen, tok);</a>
<a name="ln204">      case 0xc7:  /* ext 8 */</a>
<a name="ln205">      case 0xc8:  /* ext 16 */</a>
<a name="ln206">      case 0xc9:  /* ext 32 */</a>
<a name="ln207">        return mpack_rblob(MPACK_TOKEN_EXT, TLEN(t, 0xc7), buf, buflen, tok);</a>
<a name="ln208">      case 0xca:  /* float 32 */</a>
<a name="ln209">      case 0xcb:  /* float 64 */</a>
<a name="ln210">        return mpack_rvalue(MPACK_TOKEN_FLOAT, TLEN(t, 0xc8), buf, buflen, tok);</a>
<a name="ln211">      case 0xcc:  /* uint 8 */</a>
<a name="ln212">      case 0xcd:  /* uint 16 */</a>
<a name="ln213">      case 0xce:  /* uint 32 */</a>
<a name="ln214">      case 0xcf:  /* uint 64 */</a>
<a name="ln215">        return mpack_rvalue(MPACK_TOKEN_UINT, TLEN(t, 0xcc), buf, buflen, tok);</a>
<a name="ln216">      case 0xd0:  /* int 8 */</a>
<a name="ln217">      case 0xd1:  /* int 16 */</a>
<a name="ln218">      case 0xd2:  /* int 32 */</a>
<a name="ln219">      case 0xd3:  /* int 64 */</a>
<a name="ln220">        return mpack_rvalue(MPACK_TOKEN_SINT, TLEN(t, 0xd0), buf, buflen, tok);</a>
<a name="ln221">      case 0xd4:  /* fixext 1 */</a>
<a name="ln222">      case 0xd5:  /* fixext 2 */</a>
<a name="ln223">      case 0xd6:  /* fixext 4 */</a>
<a name="ln224">      case 0xd7:  /* fixext 8 */</a>
<a name="ln225">      case 0xd8:  /* fixext 16 */</a>
<a name="ln226">        if (*buflen == 0) {</a>
<a name="ln227">          /* require only one extra byte for the type code */</a>
<a name="ln228">          tok-&gt;length = 1;</a>
<a name="ln229">          return MPACK_EOF;</a>
<a name="ln230">        }</a>
<a name="ln231">        tok-&gt;length = TLEN(t, 0xd4);</a>
<a name="ln232">        tok-&gt;type = MPACK_TOKEN_EXT;</a>
<a name="ln233">        tok-&gt;data.ext_type = ADVANCE(buf, buflen);</a>
<a name="ln234">        return MPACK_OK;</a>
<a name="ln235">      case 0xd9:  /* str 8 */</a>
<a name="ln236">      case 0xda:  /* str 16 */</a>
<a name="ln237">      case 0xdb:  /* str 32 */</a>
<a name="ln238">        return mpack_rblob(MPACK_TOKEN_STR, TLEN(t, 0xd9), buf, buflen, tok);</a>
<a name="ln239">      case 0xdc:  /* array 16 */</a>
<a name="ln240">      case 0xdd:  /* array 32 */</a>
<a name="ln241">        return mpack_rblob(MPACK_TOKEN_ARRAY, TLEN(t, 0xdb), buf, buflen, tok);</a>
<a name="ln242">      case 0xde:  /* map 16 */</a>
<a name="ln243">      case 0xdf:  /* map 32 */</a>
<a name="ln244">        return mpack_rblob(MPACK_TOKEN_MAP, TLEN(t, 0xdd), buf, buflen, tok);</a>
<a name="ln245">      default:</a>
<a name="ln246">        return MPACK_ERROR;</a>
<a name="ln247">    }</a>
<a name="ln248">  } else {</a>
<a name="ln249">    /* negative fixint */</a>
<a name="ln250">    return mpack_value(MPACK_TOKEN_SINT, 1, mpack_byte(t), tok);</a>
<a name="ln251">  }</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">static int mpack_rpending(const char **buf, size_t *buflen,</a>
<a name="ln255">    mpack_tokbuf_t *state)</a>
<a name="ln256">{</a>
<a name="ln257">  size_t count;</a>
<a name="ln258">  assert(state-&gt;ppos &lt; state-&gt;plen);</a>
<a name="ln259">  count = MIN(state-&gt;plen - state-&gt;ppos, *buflen);</a>
<a name="ln260">  memcpy(state-&gt;pending + state-&gt;ppos, *buf, count);</a>
<a name="ln261">  state-&gt;ppos += count;</a>
<a name="ln262">  if (state-&gt;ppos &lt; state-&gt;plen) {</a>
<a name="ln263">    /* consume buffer since no token will be parsed yet. */</a>
<a name="ln264">    *buf += *buflen;</a>
<a name="ln265">    *buflen = 0;</a>
<a name="ln266">    return 0;</a>
<a name="ln267">  }</a>
<a name="ln268">  return 1;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">static int mpack_rvalue(mpack_token_type_t type, mpack_uint32_t remaining,</a>
<a name="ln272">    const char **buf, size_t *buflen, mpack_token_t *tok)</a>
<a name="ln273">{</a>
<a name="ln274">  if (*buflen &lt; remaining) {</a>
<a name="ln275">    tok-&gt;length = remaining;</a>
<a name="ln276">    return MPACK_EOF;</a>
<a name="ln277">  }</a>
<a name="ln278"> </a>
<a name="ln279">  mpack_value(type, remaining, mpack_byte(0), tok);</a>
<a name="ln280"> </a>
<a name="ln281">  while (remaining) {</a>
<a name="ln282">    mpack_uint32_t byte = ADVANCE(buf, buflen), byte_idx, byte_shift;</a>
<a name="ln283">    byte_idx = (mpack_uint32_t)--remaining;</a>
<a name="ln284">    byte_shift = (byte_idx % 4) * 8;</a>
<a name="ln285">    tok-&gt;data.value.lo |= byte &lt;&lt; byte_shift;</a>
<a name="ln286">    if (remaining == 4) {</a>
<a name="ln287">      /* unpacked the first half of a 8-byte value, shift what was parsed to the</a>
<a name="ln288">       * &quot;hi&quot; field and reset &quot;lo&quot; for the trailing 4 bytes. */</a>
<a name="ln289">      tok-&gt;data.value.hi = tok-&gt;data.value.lo;</a>
<a name="ln290">      tok-&gt;data.value.lo = 0;</a>
<a name="ln291">    }</a>
<a name="ln292">  }</a>
<a name="ln293"> </a>
<a name="ln294">  if (type == MPACK_TOKEN_SINT) {</a>
<a name="ln295">    mpack_uint32_t hi = tok-&gt;data.value.hi;</a>
<a name="ln296">    mpack_uint32_t lo = tok-&gt;data.value.lo;</a>
<a name="ln297">    mpack_uint32_t msb = (tok-&gt;length == 8 &amp;&amp; hi &gt;&gt; 31) ||</a>
<a name="ln298">                         (tok-&gt;length == 4 &amp;&amp; lo &gt;&gt; 31) ||</a>
<a name="ln299">                         (tok-&gt;length == 2 &amp;&amp; lo &gt;&gt; 15) ||</a>
<a name="ln300">                         (tok-&gt;length == 1 &amp;&amp; lo &gt;&gt; 7);</a>
<a name="ln301">    if (!msb) {</a>
<a name="ln302">      tok-&gt;type = MPACK_TOKEN_UINT;</a>
<a name="ln303">    }</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  return MPACK_OK;</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309">static int mpack_rblob(mpack_token_type_t type, mpack_uint32_t tlen,</a>
<a name="ln310">    const char **buf, size_t *buflen, mpack_token_t *tok)</a>
<a name="ln311">{</a>
<a name="ln312">  mpack_token_t l;</a>
<a name="ln313">  mpack_uint32_t required = tlen + (type == MPACK_TOKEN_EXT ? 1 : 0);</a>
<a name="ln314"> </a>
<a name="ln315">  if (*buflen &lt; required) {</a>
<a name="ln316">    tok-&gt;length = required;</a>
<a name="ln317">    return MPACK_EOF;</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">  l.data.value.lo = 0;</a>
<a name="ln321">  mpack_rvalue(MPACK_TOKEN_UINT, tlen, buf, buflen, &amp;l);</a>
<a name="ln322">  tok-&gt;type = type;</a>
<a name="ln323">  tok-&gt;length = l.data.value.lo;</a>
<a name="ln324"> </a>
<a name="ln325">  if (type == MPACK_TOKEN_EXT) {</a>
<a name="ln326">    tok-&gt;data.ext_type = ADVANCE(buf, buflen);</a>
<a name="ln327">  }</a>
<a name="ln328"> </a>
<a name="ln329">  return MPACK_OK;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">static int mpack_wtoken(const mpack_token_t *tok, char **buf,</a>
<a name="ln333">    size_t *buflen)</a>
<a name="ln334">{</a>
<a name="ln335">  switch (tok-&gt;type) {</a>
<a name="ln336">    case MPACK_TOKEN_NIL:</a>
<a name="ln337">      return mpack_w1(buf, buflen, 0xc0);</a>
<a name="ln338">    case MPACK_TOKEN_BOOLEAN:</a>
<a name="ln339">      return mpack_w1(buf, buflen, tok-&gt;data.value.lo ? 0xc3 : 0xc2);</a>
<a name="ln340">    case MPACK_TOKEN_UINT:</a>
<a name="ln341">      return mpack_wpint(buf, buflen, tok-&gt;data.value);</a>
<a name="ln342">    case MPACK_TOKEN_SINT:</a>
<a name="ln343">      return mpack_wnint(buf, buflen, tok-&gt;data.value);</a>
<a name="ln344">    case MPACK_TOKEN_FLOAT:</a>
<a name="ln345">      return mpack_wfloat(buf, buflen, tok);</a>
<a name="ln346">    case MPACK_TOKEN_BIN:</a>
<a name="ln347">      return mpack_wbin(buf, buflen, tok-&gt;length);</a>
<a name="ln348">    case MPACK_TOKEN_STR:</a>
<a name="ln349">      return mpack_wstr(buf, buflen, tok-&gt;length);</a>
<a name="ln350">    case MPACK_TOKEN_EXT:</a>
<a name="ln351">      return mpack_wext(buf, buflen, tok-&gt;data.ext_type, tok-&gt;length);</a>
<a name="ln352">    case MPACK_TOKEN_ARRAY:</a>
<a name="ln353">      return mpack_warray(buf, buflen, tok-&gt;length);</a>
<a name="ln354">    case MPACK_TOKEN_MAP:</a>
<a name="ln355">      return mpack_wmap(buf, buflen, tok-&gt;length);</a>
<a name="ln356">    default:</a>
<a name="ln357">      return MPACK_ERROR;</a>
<a name="ln358">  }</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">static int mpack_wpending(char **buf, size_t *buflen, mpack_tokbuf_t *state)</a>
<a name="ln362">{</a>
<a name="ln363">  size_t count;</a>
<a name="ln364">  assert(state-&gt;ppos &lt; state-&gt;plen);</a>
<a name="ln365">  count = MIN(state-&gt;plen - state-&gt;ppos, *buflen);</a>
<a name="ln366">  memcpy(*buf, state-&gt;pending + state-&gt;ppos, count);</a>
<a name="ln367">  state-&gt;ppos += count;</a>
<a name="ln368">  *buf += count;</a>
<a name="ln369">  *buflen -= count;</a>
<a name="ln370">  if (state-&gt;ppos == state-&gt;plen) {</a>
<a name="ln371">    state-&gt;plen = 0;</a>
<a name="ln372">    return MPACK_OK;</a>
<a name="ln373">  }</a>
<a name="ln374">  return MPACK_EOF;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">static int mpack_wpint(char **buf, size_t *buflen, mpack_value_t val)</a>
<a name="ln378">{</a>
<a name="ln379">  mpack_uint32_t hi = val.hi;</a>
<a name="ln380">  mpack_uint32_t lo = val.lo;</a>
<a name="ln381"> </a>
<a name="ln382">  if (hi) {</a>
<a name="ln383">    /* uint 64 */</a>
<a name="ln384">    return mpack_w1(buf, buflen, 0xcf) ||</a>
<a name="ln385">           mpack_w4(buf, buflen, hi)   ||</a>
<a name="ln386">           mpack_w4(buf, buflen, lo);</a>
<a name="ln387">  } else if (lo &gt; 0xffff) {</a>
<a name="ln388">    /* uint 32 */</a>
<a name="ln389">    return mpack_w1(buf, buflen, 0xce) ||</a>
<a name="ln390">           mpack_w4(buf, buflen, lo);</a>
<a name="ln391">  } else if (lo &gt; 0xff) {</a>
<a name="ln392">    /* uint 16 */</a>
<a name="ln393">    return mpack_w1(buf, buflen, 0xcd) ||</a>
<a name="ln394">           mpack_w2(buf, buflen, lo);</a>
<a name="ln395">  } else if (lo &gt; 0x7f) {</a>
<a name="ln396">    /* uint 8 */</a>
<a name="ln397">    return mpack_w1(buf, buflen, 0xcc) ||</a>
<a name="ln398">           mpack_w1(buf, buflen, lo);</a>
<a name="ln399">  } else {</a>
<a name="ln400">    return mpack_w1(buf, buflen, lo);</a>
<a name="ln401">  }</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">static int mpack_wnint(char **buf, size_t *buflen, mpack_value_t val)</a>
<a name="ln405">{</a>
<a name="ln406">  mpack_uint32_t hi = val.hi;</a>
<a name="ln407">  mpack_uint32_t lo = val.lo;</a>
<a name="ln408"> </a>
<a name="ln409">  if (lo &lt; 0x80000000) {</a>
<a name="ln410">    /* int 64 */</a>
<a name="ln411">    return mpack_w1(buf, buflen, 0xd3) ||</a>
<a name="ln412">           mpack_w4(buf, buflen, hi)   ||</a>
<a name="ln413">           mpack_w4(buf, buflen, lo);</a>
<a name="ln414">  } else if (lo &lt; 0xffff7fff) {</a>
<a name="ln415">    /* int 32 */</a>
<a name="ln416">    return mpack_w1(buf, buflen, 0xd2) ||</a>
<a name="ln417">           mpack_w4(buf, buflen, lo);</a>
<a name="ln418">  } else if (lo &lt; 0xffffff7f) {</a>
<a name="ln419">    /* int 16 */</a>
<a name="ln420">    return mpack_w1(buf, buflen, 0xd1) ||</a>
<a name="ln421">           mpack_w2(buf, buflen, lo);</a>
<a name="ln422">  } else if (lo &lt; 0xffffffe0) {</a>
<a name="ln423">    /* int 8 */</a>
<a name="ln424">    return mpack_w1(buf, buflen, 0xd0) ||</a>
<a name="ln425">           mpack_w1(buf, buflen, lo);</a>
<a name="ln426">  } else {</a>
<a name="ln427">    /* negative fixint */</a>
<a name="ln428">    return mpack_w1(buf, buflen, (mpack_uint32_t)(0x100 + lo));</a>
<a name="ln429">  }</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">static int mpack_wfloat(char **buf, size_t *buflen,</a>
<a name="ln433">    const mpack_token_t *tok)</a>
<a name="ln434">{</a>
<a name="ln435">  if (tok-&gt;length == 4) {</a>
<a name="ln436">    return mpack_w1(buf, buflen, 0xca) ||</a>
<a name="ln437">           mpack_w4(buf, buflen, tok-&gt;data.value.lo);</a>
<a name="ln438">  } else if (tok-&gt;length == 8) {</a>
<a name="ln439">    return mpack_w1(buf, buflen, 0xcb) ||</a>
<a name="ln440">           mpack_w4(buf, buflen, tok-&gt;data.value.hi) ||</a>
<a name="ln441">           mpack_w4(buf, buflen, tok-&gt;data.value.lo);</a>
<a name="ln442">  } else {</a>
<a name="ln443">    return MPACK_ERROR;</a>
<a name="ln444">  }</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">static int mpack_wstr(char **buf, size_t *buflen, mpack_uint32_t len)</a>
<a name="ln448">{</a>
<a name="ln449">  if (len &lt; 0x20) {</a>
<a name="ln450">    return mpack_w1(buf, buflen, 0xa0 | len);</a>
<a name="ln451">  } else if (len &lt; 0x100) {</a>
<a name="ln452">    return mpack_w1(buf, buflen, 0xd9) ||</a>
<a name="ln453">           mpack_w1(buf, buflen, len);</a>
<a name="ln454">  } else if (len &lt; 0x10000) {</a>
<a name="ln455">    return mpack_w1(buf, buflen, 0xda) ||</a>
<a name="ln456">           mpack_w2(buf, buflen, len);</a>
<a name="ln457">  } else {</a>
<a name="ln458">    return mpack_w1(buf, buflen, 0xdb) ||</a>
<a name="ln459">           mpack_w4(buf, buflen, len);</a>
<a name="ln460">  }</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">static int mpack_wbin(char **buf, size_t *buflen, mpack_uint32_t len)</a>
<a name="ln464">{</a>
<a name="ln465">  if (len &lt; 0x100) {</a>
<a name="ln466">    return mpack_w1(buf, buflen, 0xc4) ||</a>
<a name="ln467">           mpack_w1(buf, buflen, len);</a>
<a name="ln468">  } else if (len &lt; 0x10000) {</a>
<a name="ln469">    return mpack_w1(buf, buflen, 0xc5) ||</a>
<a name="ln470">           mpack_w2(buf, buflen, len);</a>
<a name="ln471">  } else {</a>
<a name="ln472">    return mpack_w1(buf, buflen, 0xc6) ||</a>
<a name="ln473">           mpack_w4(buf, buflen, len);</a>
<a name="ln474">  }</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">static int mpack_wext(char **buf, size_t *buflen, int type,</a>
<a name="ln478">    mpack_uint32_t len)</a>
<a name="ln479">{</a>
<a name="ln480">  mpack_uint32_t t;</a>
<a name="ln481">  assert(type &gt;= 0 &amp;&amp; type &lt; 0x80);</a>
<a name="ln482">  t = (mpack_uint32_t)type;</a>
<a name="ln483">  switch (len) {</a>
<a name="ln484">    case 1: mpack_w1(buf, buflen, 0xd4); return mpack_w1(buf, buflen, t);</a>
<a name="ln485">    case 2: mpack_w1(buf, buflen, 0xd5); return mpack_w1(buf, buflen, t);</a>
<a name="ln486">    case 4: mpack_w1(buf, buflen, 0xd6); return mpack_w1(buf, buflen, t);</a>
<a name="ln487">    case 8: mpack_w1(buf, buflen, 0xd7); return mpack_w1(buf, buflen, t);</a>
<a name="ln488">    case 16: mpack_w1(buf, buflen, 0xd8); return mpack_w1(buf, buflen, t);</a>
<a name="ln489">    default:</a>
<a name="ln490">      if (len &lt; 0x100) {</a>
<a name="ln491">        return mpack_w1(buf, buflen, 0xc7) ||</a>
<a name="ln492">               mpack_w1(buf, buflen, len)  ||</a>
<a name="ln493">               mpack_w1(buf, buflen, t);</a>
<a name="ln494">      } else if (len &lt; 0x10000) {</a>
<a name="ln495">        return mpack_w1(buf, buflen, 0xc8) ||</a>
<a name="ln496">               mpack_w2(buf, buflen, len)  ||</a>
<a name="ln497">               mpack_w1(buf, buflen, t);</a>
<a name="ln498">      } else {</a>
<a name="ln499">        return mpack_w1(buf, buflen, 0xc9) ||</a>
<a name="ln500">               mpack_w4(buf, buflen, len)  ||</a>
<a name="ln501">               mpack_w1(buf, buflen, t);</a>
<a name="ln502">      }</a>
<a name="ln503">  }</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">static int mpack_warray(char **buf, size_t *buflen, mpack_uint32_t len)</a>
<a name="ln507">{</a>
<a name="ln508">  if (len &lt; 0x10) {</a>
<a name="ln509">    return mpack_w1(buf, buflen, 0x90 | len);</a>
<a name="ln510">  } else if (len &lt; 0x10000) {</a>
<a name="ln511">    return mpack_w1(buf, buflen, 0xdc) ||</a>
<a name="ln512">           mpack_w2(buf, buflen, len);</a>
<a name="ln513">  } else {</a>
<a name="ln514">    return mpack_w1(buf, buflen, 0xdd) ||</a>
<a name="ln515">           mpack_w4(buf, buflen, len);</a>
<a name="ln516">  }</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">static int mpack_wmap(char **buf, size_t *buflen, mpack_uint32_t len)</a>
<a name="ln520">{</a>
<a name="ln521">  if (len &lt; 0x10) {</a>
<a name="ln522">    return mpack_w1(buf, buflen, 0x80 | len);</a>
<a name="ln523">  } else if (len &lt; 0x10000) {</a>
<a name="ln524">    return mpack_w1(buf, buflen, 0xde) ||</a>
<a name="ln525">           mpack_w2(buf, buflen, len);</a>
<a name="ln526">  } else {</a>
<a name="ln527">    return mpack_w1(buf, buflen, 0xdf) ||</a>
<a name="ln528">           mpack_w4(buf, buflen, len);</a>
<a name="ln529">  }</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">static int mpack_w1(char **b, size_t *bl, mpack_uint32_t v)</a>
<a name="ln533">{</a>
<a name="ln534">  (*bl)--;</a>
<a name="ln535">  *(*b)++ = (char)(v &amp; 0xff);</a>
<a name="ln536">  return MPACK_OK;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">static int mpack_w2(char **b, size_t *bl, mpack_uint32_t v)</a>
<a name="ln540">{</a>
<a name="ln541">  *bl -= 2;</a>
<a name="ln542">  *(*b)++ = (char)((v &gt;&gt; 8) &amp; 0xff);</a>
<a name="ln543">  *(*b)++ = (char)(v &amp; 0xff);</a>
<a name="ln544">  return MPACK_OK;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">static int mpack_w4(char **b, size_t *bl, mpack_uint32_t v)</a>
<a name="ln548">{</a>
<a name="ln549">  *bl -= 4;</a>
<a name="ln550">  *(*b)++ = (char)((v &gt;&gt; 24) &amp; 0xff);</a>
<a name="ln551">  *(*b)++ = (char)((v &gt;&gt; 16) &amp; 0xff);</a>
<a name="ln552">  *(*b)++ = (char)((v &gt;&gt; 8) &amp; 0xff);</a>
<a name="ln553">  *(*b)++ = (char)(v &amp; 0xff);</a>
<a name="ln554">  return MPACK_OK;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">static int mpack_value(mpack_token_type_t type, mpack_uint32_t length,</a>
<a name="ln558">    mpack_value_t value, mpack_token_t *tok)</a>
<a name="ln559">{</a>
<a name="ln560">  tok-&gt;type = type;</a>
<a name="ln561">  tok-&gt;length = length;</a>
<a name="ln562">  tok-&gt;data.value = value;</a>
<a name="ln563">  return MPACK_OK;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">static int mpack_blob(mpack_token_type_t type, mpack_uint32_t length,</a>
<a name="ln567">    int ext_type, mpack_token_t *tok)</a>
<a name="ln568">{</a>
<a name="ln569">  tok-&gt;type = type;</a>
<a name="ln570">  tok-&gt;length = length;</a>
<a name="ln571">  tok-&gt;data.ext_type = ext_type;</a>
<a name="ln572">  return MPACK_OK;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static mpack_value_t mpack_byte(unsigned char byte)</a>
<a name="ln576">{</a>
<a name="ln577">  mpack_value_t rv;</a>
<a name="ln578">  rv.lo = byte;</a>
<a name="ln579">  rv.hi = 0;</a>
<a name="ln580">  return rv;</a>
<a name="ln581">}</a>
</code></pre>
<div class="balloon" rel="241"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v610/" target="_blank">V610</a> Undefined behavior. Check the shift operator '&lt;&lt;'. The right operand is negative ('(t - 0xdb)' = [-27..4]).</p></div>
<div class="balloon" rel="31"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1071/" target="_blank">V1071</a> Consider inspecting the 'mpack_w1' function. The return value is not always used. Total calls: 48, discarded results: 5.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>