<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">#include &lt;assert.h&gt;</a>
<a name="ln60">#include &lt;inttypes.h&gt;</a>
<a name="ln61">#include &lt;limits.h&gt;</a>
<a name="ln62">#include &lt;stdbool.h&gt;</a>
<a name="ln63">#include &lt;stddef.h&gt;</a>
<a name="ln64">#include &lt;stdio.h&gt;</a>
<a name="ln65">#include &lt;string.h&gt;</a>
<a name="ln66"> </a>
<a name="ln67">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln68">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln69">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln70">#include &quot;nvim/change.h&quot;</a>
<a name="ln71">#include &quot;nvim/charset.h&quot;</a>
<a name="ln72">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln73">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln74">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln75">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln76">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln77">#include &quot;nvim/ex_cmds_defs.h&quot;</a>
<a name="ln78">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln79">#include &quot;nvim/garray.h&quot;</a>
<a name="ln80">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln81">#include &quot;nvim/globals.h&quot;</a>
<a name="ln82">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln83">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln84">#include &quot;nvim/insexpand.h&quot;</a>
<a name="ln85">#include &quot;nvim/log.h&quot;</a>
<a name="ln86">#include &quot;nvim/macros.h&quot;</a>
<a name="ln87">#include &quot;nvim/mark.h&quot;</a>
<a name="ln88">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln89">#include &quot;nvim/memline.h&quot;</a>
<a name="ln90">#include &quot;nvim/memory.h&quot;</a>
<a name="ln91">#include &quot;nvim/message.h&quot;</a>
<a name="ln92">#include &quot;nvim/option.h&quot;</a>
<a name="ln93">#include &quot;nvim/os/fs.h&quot;</a>
<a name="ln94">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln95">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln96">#include &quot;nvim/path.h&quot;</a>
<a name="ln97">#include &quot;nvim/pos.h&quot;</a>
<a name="ln98">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln99">#include &quot;nvim/runtime.h&quot;</a>
<a name="ln100">#include &quot;nvim/search.h&quot;</a>
<a name="ln101">#include &quot;nvim/spell.h&quot;</a>
<a name="ln102">#include &quot;nvim/spell_defs.h&quot;</a>
<a name="ln103">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln104">#include &quot;nvim/spellsuggest.h&quot;</a>
<a name="ln105">#include &quot;nvim/strings.h&quot;</a>
<a name="ln106">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln107">#include &quot;nvim/types.h&quot;</a>
<a name="ln108">#include &quot;nvim/undo.h&quot;</a>
<a name="ln109">#include &quot;nvim/vim.h&quot;</a>
<a name="ln110">#include &quot;nvim/window.h&quot;</a>
<a name="ln111"> </a>
<a name="ln112">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln113">enum {</a>
<a name="ln114">  SP_BANNED = -1,</a>
<a name="ln115">  SP_RARE = 0,</a>
<a name="ln116">  SP_OK = 1,</a>
<a name="ln117">  SP_LOCAL = 2,</a>
<a name="ln118">  SP_BAD = 3,</a>
<a name="ln119">};</a>
<a name="ln120"> </a>
<a name="ln121">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln122">// languages.</a>
<a name="ln123">slang_T *first_lang = NULL;</a>
<a name="ln124"> </a>
<a name="ln125">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln126">char *int_wordlist = NULL;</a>
<a name="ln127"> </a>
<a name="ln128">// Structure to store info for word matching.</a>
<a name="ln129">typedef struct matchinf_S {</a>
<a name="ln130">  langp_T *mi_lp;                   // info for language and region</a>
<a name="ln131"> </a>
<a name="ln132">  // pointers to original text to be checked</a>
<a name="ln133">  char *mi_word;                   // start of word being checked</a>
<a name="ln134">  char *mi_end;                    // end of matching word so far</a>
<a name="ln135">  char *mi_fend;                   // next char to be added to mi_fword</a>
<a name="ln136">  char *mi_cend;                   // char after what was used for</a>
<a name="ln137">                                   // mi_capflags</a>
<a name="ln138"> </a>
<a name="ln139">  // case-folded text</a>
<a name="ln140">  char mi_fword[MAXWLEN + 1];           // mi_word case-folded</a>
<a name="ln141">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln142"> </a>
<a name="ln143">  // for when checking word after a prefix</a>
<a name="ln144">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln145">                                        // affixID/condition</a>
<a name="ln146">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln147">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln148">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln149">                                        // case</a>
<a name="ln150"> </a>
<a name="ln151">  // for when checking a compound word</a>
<a name="ln152">  int mi_compoff;                       // start of following word offset</a>
<a name="ln153">  uint8_t mi_compflags[MAXWLEN];        // flags for compound words used</a>
<a name="ln154">  int mi_complen;                       // nr of compound words used</a>
<a name="ln155">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln156"> </a>
<a name="ln157">  // others</a>
<a name="ln158">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln159">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln160">  win_T *mi_win;                  // buffer being checked</a>
<a name="ln161"> </a>
<a name="ln162">  // for NOBREAK</a>
<a name="ln163">  int mi_result2;                       // &quot;mi_result&quot; without following word</a>
<a name="ln164">  char *mi_end2;                        // &quot;mi_end&quot; without following word</a>
<a name="ln165">} matchinf_T;</a>
<a name="ln166"> </a>
<a name="ln167">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln168">typedef struct spelload_S {</a>
<a name="ln169">  char sl_lang[MAXWLEN + 1];            // language name</a>
<a name="ln170">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln171">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln172">} spelload_T;</a>
<a name="ln173"> </a>
<a name="ln174">#define SY_MAXLEN   30</a>
<a name="ln175">typedef struct syl_item_S {</a>
<a name="ln176">  char sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln177">  int sy_len;</a>
<a name="ln178">} syl_item_T;</a>
<a name="ln179"> </a>
<a name="ln180">spelltab_T spelltab;</a>
<a name="ln181">int did_set_spelltab;</a>
<a name="ln182"> </a>
<a name="ln183">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln184"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln185">#endif</a>
<a name="ln186"> </a>
<a name="ln187">/// mode values for find_word</a>
<a name="ln188">enum {</a>
<a name="ln189">  FIND_FOLDWORD     = 0,  ///&lt; find word case-folded</a>
<a name="ln190">  FIND_KEEPWORD     = 1,  ///&lt; find keep-case word</a>
<a name="ln191">  FIND_PREFIX       = 2,  ///&lt; find word after prefix</a>
<a name="ln192">  FIND_COMPOUND     = 3,  ///&lt; find case-folded compound word</a>
<a name="ln193">  FIND_KEEPCOMPOUND = 4,  ///&lt; find keep-case compound word</a>
<a name="ln194">};</a>
<a name="ln195"> </a>
<a name="ln196">/// type values for get_char_type</a>
<a name="ln197">enum {</a>
<a name="ln198">  CHAR_OTHER = 0,</a>
<a name="ln199">  CHAR_UPPER = 1,</a>
<a name="ln200">  CHAR_DIGIT = 2,</a>
<a name="ln201">};</a>
<a name="ln202"> </a>
<a name="ln203">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln204"> </a>
<a name="ln205">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln206">char *repl_from = NULL;</a>
<a name="ln207">char *repl_to = NULL;</a>
<a name="ln208"> </a>
<a name="ln209">/// Main spell-checking function.</a>
<a name="ln210">/// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln211">/// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln212">/// non-word or when it's OK it remains unchanged.</a>
<a name="ln213">/// This must only be called when 'spelllang' is not empty.</a>
<a name="ln214">///</a>
<a name="ln215">/// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln216">/// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln217">/// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln218">/// worry.</a>
<a name="ln219">///</a>
<a name="ln220">/// @param wp  current window</a>
<a name="ln221">/// @param capcol  column to check for Capital</a>
<a name="ln222">/// @param docount  count good words</a>
<a name="ln223">///</a>
<a name="ln224">/// @return  the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln225">/// caller can skip over the word.</a>
<a name="ln226">size_t spell_check(win_T *wp, char *ptr, hlf_T *attrp, int *capcol, bool docount)</a>
<a name="ln227">{</a>
<a name="ln228">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln229">                              // be passed to functions quickly.</a>
<a name="ln230">  size_t nrlen = 0;              // found a number first</a>
<a name="ln231">  size_t wrongcaplen = 0;</a>
<a name="ln232">  bool count_word = docount;</a>
<a name="ln233">  bool use_camel_case = (wp-&gt;w_s-&gt;b_p_spo_flags &amp; SPO_CAMEL) != 0;</a>
<a name="ln234">  bool is_camel_case = false;</a>
<a name="ln235"> </a>
<a name="ln236">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln237">  // then, skipping over the character.</a>
<a name="ln238">  if ((uint8_t)(*ptr) &lt;= ' ') {</a>
<a name="ln239">    return 1;</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  // Return here when loading language files failed.</a>
<a name="ln243">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln244">    return 1;</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  CLEAR_FIELD(mi);</a>
<a name="ln248"> </a>
<a name="ln249">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln250">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln251">  // julifeest&quot;.</a>
<a name="ln252">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln253">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln254">      mi.mi_end = (char *)skipbin(ptr + 2);</a>
<a name="ln255">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln256">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln257">    } else {</a>
<a name="ln258">      mi.mi_end = skipdigits(ptr);</a>
<a name="ln259">    }</a>
<a name="ln260">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln264">  mi.mi_word = ptr;</a>
<a name="ln265">  mi.mi_fend = ptr;</a>
<a name="ln266">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln267">    if (use_camel_case) {</a>
<a name="ln268">      mi.mi_fend = advance_camelcase_word(ptr, wp, &amp;is_camel_case);</a>
<a name="ln269">    } else {</a>
<a name="ln270">      do {</a>
<a name="ln271">        MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln272">      } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp));</a>
<a name="ln273">    }</a>
<a name="ln274"> </a>
<a name="ln275">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln276">      // Check word starting with capital letter.</a>
<a name="ln277">      int c = utf_ptr2char(ptr);</a>
<a name="ln278">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln279">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln280">      }</a>
<a name="ln281">    }</a>
<a name="ln282">  }</a>
<a name="ln283">  if (capcol != NULL) {</a>
<a name="ln284">    *capcol = -1;</a>
<a name="ln285">  }</a>
<a name="ln286"> </a>
<a name="ln287">  // We always use the characters up to the next non-word character,</a>
<a name="ln288">  // also for bad words.</a>
<a name="ln289">  mi.mi_end = mi.mi_fend;</a>
<a name="ln290"> </a>
<a name="ln291">  // Check caps type later.</a>
<a name="ln292">  mi.mi_capflags = 0;</a>
<a name="ln293">  mi.mi_cend = NULL;</a>
<a name="ln294">  mi.mi_win = wp;</a>
<a name="ln295"> </a>
<a name="ln296">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln297">  // for the word end.</a>
<a name="ln298">  if (*mi.mi_fend != NUL) {</a>
<a name="ln299">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln300">  }</a>
<a name="ln301"> </a>
<a name="ln302">  (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,</a>
<a name="ln303">                       MAXWLEN + 1);</a>
<a name="ln304">  mi.mi_fwordlen = (int)strlen(mi.mi_fword);</a>
<a name="ln305"> </a>
<a name="ln306">  if (is_camel_case &amp;&amp; mi.mi_fwordlen &gt; 0) {</a>
<a name="ln307">    // introduce a fake word end space into the folded word.</a>
<a name="ln308">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln309">  }</a>
<a name="ln310"> </a>
<a name="ln311">  // The word is bad unless we recognize it.</a>
<a name="ln312">  mi.mi_result = SP_BAD;</a>
<a name="ln313">  mi.mi_result2 = SP_BAD;</a>
<a name="ln314"> </a>
<a name="ln315">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln316">  // We check them all, because a word may be matched longer in another</a>
<a name="ln317">  // language.</a>
<a name="ln318">  for (int lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln319">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln320"> </a>
<a name="ln321">    // If reloading fails the language is still in the list but everything</a>
<a name="ln322">    // has been cleared.</a>
<a name="ln323">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln324">      continue;</a>
<a name="ln325">    }</a>
<a name="ln326"> </a>
<a name="ln327">    // Check for a matching word in case-folded words.</a>
<a name="ln328">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln329"> </a>
<a name="ln330">    // Check for a matching word in keep-case words.</a>
<a name="ln331">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln332"> </a>
<a name="ln333">    // Check for matching prefixes.</a>
<a name="ln334">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln335"> </a>
<a name="ln336">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln337">    // word as a backup.</a>
<a name="ln338">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln339">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln340">      mi.mi_result = mi.mi_result2;</a>
<a name="ln341">      mi.mi_end = mi.mi_end2;</a>
<a name="ln342">    }</a>
<a name="ln343"> </a>
<a name="ln344">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln345">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln346">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln347">                        (int)(mi.mi_end - ptr), 1);</a>
<a name="ln348">      count_word = false;</a>
<a name="ln349">    }</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  if (mi.mi_result != SP_OK) {</a>
<a name="ln353">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln354">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln355">    if (nrlen &gt; 0) {</a>
<a name="ln356">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln357">        return nrlen;</a>
<a name="ln358">      }</a>
<a name="ln359">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln360">      // When we are at a non-word character there is no error, just</a>
<a name="ln361">      // skip over the character (try looking for a word after it).</a>
<a name="ln362">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln363">        regmatch_T regmatch;</a>
<a name="ln364"> </a>
<a name="ln365">        // Check for end of sentence.</a>
<a name="ln366">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln367">        regmatch.rm_ic = false;</a>
<a name="ln368">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln369">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln370">        if (r) {</a>
<a name="ln371">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln372">        }</a>
<a name="ln373">      }</a>
<a name="ln374"> </a>
<a name="ln375">      return (size_t)(utfc_ptr2len(ptr));</a>
<a name="ln376">    } else if (mi.mi_end == ptr) {</a>
<a name="ln377">      // Always include at least one character.  Required for when there</a>
<a name="ln378">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln379">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln380">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln381">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln382">      char *p;</a>
<a name="ln383">      int save_result = mi.mi_result;</a>
<a name="ln384"> </a>
<a name="ln385">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln386">      // at which any word would be valid.</a>
<a name="ln387">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln388">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln389">        p = mi.mi_word;</a>
<a name="ln390">        char *fp = mi.mi_fword;</a>
<a name="ln391">        while (true) {</a>
<a name="ln392">          MB_PTR_ADV(p);</a>
<a name="ln393">          MB_PTR_ADV(fp);</a>
<a name="ln394">          if (p &gt;= mi.mi_end) {</a>
<a name="ln395">            break;</a>
<a name="ln396">          }</a>
<a name="ln397">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln398">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln399">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln400">            mi.mi_end = p;</a>
<a name="ln401">            break;</a>
<a name="ln402">          }</a>
<a name="ln403">        }</a>
<a name="ln404">        mi.mi_result = save_result;</a>
<a name="ln405">      }</a>
<a name="ln406">    }</a>
<a name="ln407"> </a>
<a name="ln408">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln409">      *attrp = HLF_SPB;</a>
<a name="ln410">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln411">      *attrp = HLF_SPR;</a>
<a name="ln412">    } else {</a>
<a name="ln413">      *attrp = HLF_SPL;</a>
<a name="ln414">    }</a>
<a name="ln415">  }</a>
<a name="ln416"> </a>
<a name="ln417">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln418">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln419">    *attrp = HLF_SPC;</a>
<a name="ln420">    return wrongcaplen;</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">/// Determine the type of character &quot;c&quot;.</a>
<a name="ln427">static int get_char_type(int c)</a>
<a name="ln428">{</a>
<a name="ln429">  if (ascii_isdigit(c)) {</a>
<a name="ln430">    return CHAR_DIGIT;</a>
<a name="ln431">  }</a>
<a name="ln432">  if (SPELL_ISUPPER(c)) {</a>
<a name="ln433">    return CHAR_UPPER;</a>
<a name="ln434">  }</a>
<a name="ln435">  return CHAR_OTHER;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">/// Returns a pointer to the end of the word starting at &quot;str&quot;.</a>
<a name="ln439">/// Supports camelCase words.</a>
<a name="ln440">static char *advance_camelcase_word(char *str, win_T *wp, bool *is_camel_case)</a>
<a name="ln441">{</a>
<a name="ln442">  char *end = str;</a>
<a name="ln443"> </a>
<a name="ln444">  *is_camel_case = false;</a>
<a name="ln445"> </a>
<a name="ln446">  if (*str == NUL) {</a>
<a name="ln447">    return str;</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  int c = utf_ptr2char(end);</a>
<a name="ln451">  MB_PTR_ADV(end);</a>
<a name="ln452">  // We need at most the types of the type of the last two chars.</a>
<a name="ln453">  int last_last_type = -1;</a>
<a name="ln454">  int last_type = get_char_type(c);</a>
<a name="ln455"> </a>
<a name="ln456">  while (*end != NUL &amp;&amp; spell_iswordp(end, wp)) {</a>
<a name="ln457">    c = utf_ptr2char(end);</a>
<a name="ln458">    int this_type = get_char_type(c);</a>
<a name="ln459"> </a>
<a name="ln460">    if (last_last_type == CHAR_UPPER &amp;&amp; last_type == CHAR_UPPER</a>
<a name="ln461">        &amp;&amp; this_type == CHAR_OTHER) {</a>
<a name="ln462">      // Handle the following cases:</a>
<a name="ln463">      // UpperUpperLower</a>
<a name="ln464">      *is_camel_case = true;</a>
<a name="ln465">      // Back up by one char.</a>
<a name="ln466">      MB_PTR_BACK(str, end);</a>
<a name="ln467">      break;</a>
<a name="ln468">    } else if ((this_type == CHAR_UPPER &amp;&amp; last_type == CHAR_OTHER)</a>
<a name="ln469">               || (this_type != last_type</a>
<a name="ln470">                   &amp;&amp; (this_type == CHAR_DIGIT || last_type == CHAR_DIGIT))) {</a>
<a name="ln471">      // Handle the following cases:</a>
<a name="ln472">      // LowerUpper LowerDigit UpperDigit DigitUpper DigitLower</a>
<a name="ln473">      *is_camel_case = true;</a>
<a name="ln474">      break;</a>
<a name="ln475">    }</a>
<a name="ln476"> </a>
<a name="ln477">    last_last_type = last_type;</a>
<a name="ln478">    last_type = this_type;</a>
<a name="ln479"> </a>
<a name="ln480">    MB_PTR_ADV(end);</a>
<a name="ln481">  }</a>
<a name="ln482"> </a>
<a name="ln483">  return end;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln487">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln488">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln489">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln490">// tree.</a>
<a name="ln491">//</a>
<a name="ln492">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln493">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln494">{</a>
<a name="ln495">  int wlen = 0;</a>
<a name="ln496">  int flen;</a>
<a name="ln497">  char *ptr;</a>
<a name="ln498">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln499">  uint8_t *byts;</a>
<a name="ln500">  idx_T *idxs;</a>
<a name="ln501"> </a>
<a name="ln502">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln503">    // Check for word with matching case in keep-case tree.</a>
<a name="ln504">    ptr = mip-&gt;mi_word;</a>
<a name="ln505">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln506">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln507">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln508"> </a>
<a name="ln509">    if (mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln510">      // Skip over the previously found word(s).</a>
<a name="ln511">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln512">    }</a>
<a name="ln513">  } else {</a>
<a name="ln514">    // Check for case-folded in case-folded tree.</a>
<a name="ln515">    ptr = mip-&gt;mi_fword;</a>
<a name="ln516">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln517">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln518">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln519"> </a>
<a name="ln520">    if (mode == FIND_PREFIX) {</a>
<a name="ln521">      // Skip over the prefix.</a>
<a name="ln522">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln523">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln524">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln525">      // Skip over the previously found word(s).</a>
<a name="ln526">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln527">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln528">    }</a>
<a name="ln529">  }</a>
<a name="ln530"> </a>
<a name="ln531">  if (byts == NULL) {</a>
<a name="ln532">    return;                     // array is empty</a>
<a name="ln533">  }</a>
<a name="ln534">  idx_T arridx = 0;</a>
<a name="ln535">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln536">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln537">  int endidxcnt = 0;</a>
<a name="ln538">  int c;</a>
<a name="ln539"> </a>
<a name="ln540">  // Repeat advancing in the tree until:</a>
<a name="ln541">  // - there is a byte that doesn't match,</a>
<a name="ln542">  // - we reach the end of the tree,</a>
<a name="ln543">  // - or we reach the end of the line.</a>
<a name="ln544">  while (true) {</a>
<a name="ln545">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln546">      flen = fold_more(mip);</a>
<a name="ln547">    }</a>
<a name="ln548"> </a>
<a name="ln549">    int len = byts[arridx++];</a>
<a name="ln550"> </a>
<a name="ln551">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln552">    // Remember this index, we first check for the longest word.</a>
<a name="ln553">    if (byts[arridx] == 0) {</a>
<a name="ln554">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln555">        // Must be a corrupted spell file.</a>
<a name="ln556">        emsg(_(e_format));</a>
<a name="ln557">        return;</a>
<a name="ln558">      }</a>
<a name="ln559">      endlen[endidxcnt] = wlen;</a>
<a name="ln560">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln561">      len--;</a>
<a name="ln562"> </a>
<a name="ln563">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln564">      // combinations.</a>
<a name="ln565">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln566">        arridx++;</a>
<a name="ln567">        len--;</a>
<a name="ln568">      }</a>
<a name="ln569">      if (len == 0) {</a>
<a name="ln570">        break;              // no children, word must end here</a>
<a name="ln571">      }</a>
<a name="ln572">    }</a>
<a name="ln573"> </a>
<a name="ln574">    // Stop looking at end of the line.</a>
<a name="ln575">    if (ptr[wlen] == NUL) {</a>
<a name="ln576">      break;</a>
<a name="ln577">    }</a>
<a name="ln578"> </a>
<a name="ln579">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln580">    c = (uint8_t)ptr[wlen];</a>
<a name="ln581">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln582">      c = ' ';</a>
<a name="ln583">    }</a>
<a name="ln584">    idx_T lo = arridx;</a>
<a name="ln585">    idx_T hi = arridx + len - 1;</a>
<a name="ln586">    while (lo &lt; hi) {</a>
<a name="ln587">      idx_T m = (lo + hi) / 2;</a>
<a name="ln588">      if (byts[m] &gt; c) {</a>
<a name="ln589">        hi = m - 1;</a>
<a name="ln590">      } else if (byts[m] &lt; c) {</a>
<a name="ln591">        lo = m + 1;</a>
<a name="ln592">      } else {</a>
<a name="ln593">        lo = hi = m;</a>
<a name="ln594">        break;</a>
<a name="ln595">      }</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598">    // Stop if there is no matching byte.</a>
<a name="ln599">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln600">      break;</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    // Continue at the child (if there is one).</a>
<a name="ln604">    arridx = idxs[lo];</a>
<a name="ln605">    wlen++;</a>
<a name="ln606">    flen--;</a>
<a name="ln607"> </a>
<a name="ln608">    // One space in the good word may stand for several spaces in the</a>
<a name="ln609">    // checked word.</a>
<a name="ln610">    if (c == ' ') {</a>
<a name="ln611">      while (true) {</a>
<a name="ln612">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln613">          flen = fold_more(mip);</a>
<a name="ln614">        }</a>
<a name="ln615">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB) {</a>
<a name="ln616">          break;</a>
<a name="ln617">        }</a>
<a name="ln618">        wlen++;</a>
<a name="ln619">        flen--;</a>
<a name="ln620">      }</a>
<a name="ln621">    }</a>
<a name="ln622">  }</a>
<a name="ln623"> </a>
<a name="ln624">  char *p;</a>
<a name="ln625">  bool word_ends;</a>
<a name="ln626"> </a>
<a name="ln627">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln628">  // first.</a>
<a name="ln629">  while (endidxcnt &gt; 0) {</a>
<a name="ln630">    endidxcnt--;</a>
<a name="ln631">    arridx = endidx[endidxcnt];</a>
<a name="ln632">    wlen = endlen[endidxcnt];</a>
<a name="ln633"> </a>
<a name="ln634">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln635">      continue;             // not at first byte of character</a>
<a name="ln636">    }</a>
<a name="ln637">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln638">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak) {</a>
<a name="ln639">        continue;                   // next char is a word character</a>
<a name="ln640">      }</a>
<a name="ln641">      word_ends = false;</a>
<a name="ln642">    } else {</a>
<a name="ln643">      word_ends = true;</a>
<a name="ln644">    }</a>
<a name="ln645">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln646">    // has been found we try compound flags.</a>
<a name="ln647">    bool prefix_found = false;</a>
<a name="ln648"> </a>
<a name="ln649">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln650">      // Compute byte length in original word, length may change</a>
<a name="ln651">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln652">      // case-folded word is equal to the keep-case word.</a>
<a name="ln653">      p = mip-&gt;mi_word;</a>
<a name="ln654">      if (strncmp(ptr, p, (size_t)wlen) != 0) {</a>
<a name="ln655">        for (char *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln656">          MB_PTR_ADV(p);</a>
<a name="ln657">        }</a>
<a name="ln658">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln659">      }</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln663">    // prefix ID.</a>
<a name="ln664">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln665">    // is a match.</a>
<a name="ln666">    for (int len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0; len--, arridx++) {</a>
<a name="ln667">      uint32_t flags = (uint32_t)idxs[arridx];</a>
<a name="ln668"> </a>
<a name="ln669">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln670">      // matches with what the word in the tree requires.</a>
<a name="ln671">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln672">      // don't bother to check.</a>
<a name="ln673">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln674">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln675">          // mi_capflags was set for a different word length, need</a>
<a name="ln676">          // to do it again.</a>
<a name="ln677">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln678">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln679">        }</a>
<a name="ln680"> </a>
<a name="ln681">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln682">            || !spell_valid_case(mip-&gt;mi_capflags, (int)flags)) {</a>
<a name="ln683">          continue;</a>
<a name="ln684">        }</a>
<a name="ln685">      } else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln686">        // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln687">        // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln688">        // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln689">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln690">                              (int)flags,</a>
<a name="ln691">                              mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln692">                              false);</a>
<a name="ln693">        if (c == 0) {</a>
<a name="ln694">          continue;</a>
<a name="ln695">        }</a>
<a name="ln696"> </a>
<a name="ln697">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln698">        if (c &amp; WF_RAREPFX) {</a>
<a name="ln699">          flags |= WF_RARE;</a>
<a name="ln700">        }</a>
<a name="ln701">        prefix_found = true;</a>
<a name="ln702">      }</a>
<a name="ln703"> </a>
<a name="ln704">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln705">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln706">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln707">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln708">          // need to know, so return.</a>
<a name="ln709">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln710">          break;</a>
<a name="ln711">        }</a>
<a name="ln712">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln713">                  || !word_ends)) {</a>
<a name="ln714">        // If there is no compound flag or the word is shorter than</a>
<a name="ln715">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln716">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln717">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln718">        // anyway.</a>
<a name="ln719">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln720">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln721">          continue;</a>
<a name="ln722">        }</a>
<a name="ln723">        // For multi-byte chars check character length against</a>
<a name="ln724">        // COMPOUNDMIN.</a>
<a name="ln725">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln726">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln727">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln728">          continue;</a>
<a name="ln729">        }</a>
<a name="ln730"> </a>
<a name="ln731">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln732">        // maximum for syllables is specified.</a>
<a name="ln733">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln734">            &gt; slang-&gt;sl_compmax</a>
<a name="ln735">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN) {</a>
<a name="ln736">          continue;</a>
<a name="ln737">        }</a>
<a name="ln738"> </a>
<a name="ln739">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln740">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln741">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF)) {</a>
<a name="ln742">          continue;</a>
<a name="ln743">        }</a>
<a name="ln744">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT)) {</a>
<a name="ln745">          continue;</a>
<a name="ln746">        }</a>
<a name="ln747"> </a>
<a name="ln748">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln749">        if (!byte_in_str(mip-&gt;mi_complen ==</a>
<a name="ln750">                         0 ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags,</a>
<a name="ln751">                         (int)((unsigned)flags &gt;&gt; 24))) {</a>
<a name="ln752">          continue;</a>
<a name="ln753">        }</a>
<a name="ln754"> </a>
<a name="ln755">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln756">        // discard the compound word.</a>
<a name="ln757">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln758">          continue;</a>
<a name="ln759">        }</a>
<a name="ln760"> </a>
<a name="ln761">        if (mode == FIND_COMPOUND) {</a>
<a name="ln762">          int capflags;</a>
<a name="ln763"> </a>
<a name="ln764">          // Need to check the caps type of the appended compound</a>
<a name="ln765">          // word.</a>
<a name="ln766">          if (strncmp(ptr, mip-&gt;mi_word, (size_t)mip-&gt;mi_compoff) != 0) {</a>
<a name="ln767">            // case folding may have changed the length</a>
<a name="ln768">            p = mip-&gt;mi_word;</a>
<a name="ln769">            for (char *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln770">              MB_PTR_ADV(p);</a>
<a name="ln771">            }</a>
<a name="ln772">          } else {</a>
<a name="ln773">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln774">          }</a>
<a name="ln775">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln776">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln777">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln778">            continue;</a>
<a name="ln779">          }</a>
<a name="ln780"> </a>
<a name="ln781">          if (capflags != WF_ALLCAP) {</a>
<a name="ln782">            // When the character before the word is a word</a>
<a name="ln783">            // character we do not accept a Onecap word.  We do</a>
<a name="ln784">            // accept a no-caps word, even when the dictionary</a>
<a name="ln785">            // word specifies ONECAP.</a>
<a name="ln786">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln787">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln788">                ? capflags == WF_ONECAP</a>
<a name="ln789">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln790">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln791">              continue;</a>
<a name="ln792">            }</a>
<a name="ln793">          }</a>
<a name="ln794">        }</a>
<a name="ln795"> </a>
<a name="ln796">        // If the word ends the sequence of compound flags of the</a>
<a name="ln797">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln798">        // the number of syllables must not be too large.</a>
<a name="ln799">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = (uint8_t)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln800">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln801">        if (word_ends) {</a>
<a name="ln802">          char fword[MAXWLEN] = { 0 };</a>
<a name="ln803"> </a>
<a name="ln804">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln805">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln806">            if (ptr == mip-&gt;mi_word) {</a>
<a name="ln807">              (void)spell_casefold(mip-&gt;mi_win, ptr, wlen, fword, MAXWLEN);</a>
<a name="ln808">            } else {</a>
<a name="ln809">              xstrlcpy(fword, ptr, (size_t)endlen[endidxcnt] + 1);</a>
<a name="ln810">            }</a>
<a name="ln811">          }</a>
<a name="ln812">          if (!can_compound(slang, fword, mip-&gt;mi_compflags)) {</a>
<a name="ln813">            continue;</a>
<a name="ln814">          }</a>
<a name="ln815">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln816">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags)) {</a>
<a name="ln817">          // The compound flags collected so far do not match any</a>
<a name="ln818">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln819">          continue;</a>
<a name="ln820">        }</a>
<a name="ln821">      } else if (flags &amp; WF_NEEDCOMP) {</a>
<a name="ln822">        // skip if word is only valid in a compound</a>
<a name="ln823">        continue;</a>
<a name="ln824">      }</a>
<a name="ln825"> </a>
<a name="ln826">      int nobreak_result = SP_OK;</a>
<a name="ln827"> </a>
<a name="ln828">      if (!word_ends) {</a>
<a name="ln829">        int save_result = mip-&gt;mi_result;</a>
<a name="ln830">        char *save_end = mip-&gt;mi_end;</a>
<a name="ln831">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln832"> </a>
<a name="ln833">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln834">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln835">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln836">        // valid word follows.</a>
<a name="ln837">        // Recursive!</a>
<a name="ln838">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln839">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln840">        }</a>
<a name="ln841"> </a>
<a name="ln842">        // Find following word in case-folded tree.</a>
<a name="ln843">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln844">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln845">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln846">          // byte length in keep-case word.  Length may change when</a>
<a name="ln847">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln848">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln849">          p = mip-&gt;mi_fword;</a>
<a name="ln850">          if (strncmp(ptr, p, (size_t)wlen) != 0) {</a>
<a name="ln851">            for (char *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln852">              MB_PTR_ADV(p);</a>
<a name="ln853">            }</a>
<a name="ln854">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln855">          }</a>
<a name="ln856">        }</a>
<a name="ln857">#if 0</a>
<a name="ln858">        c = mip-&gt;mi_compoff;</a>
<a name="ln859">#endif</a>
<a name="ln860">        mip-&gt;mi_complen++;</a>
<a name="ln861">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln862">          mip-&gt;mi_compextra++;</a>
<a name="ln863">        }</a>
<a name="ln864"> </a>
<a name="ln865">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln866">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln867">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln868">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln869">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln870">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln871">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln872">              continue;</a>
<a name="ln873">            }</a>
<a name="ln874">          }</a>
<a name="ln875"> </a>
<a name="ln876">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln877"> </a>
<a name="ln878">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln879">          // need to find the longest match, thus try with keep-case</a>
<a name="ln880">          // and prefix too.</a>
<a name="ln881">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln882">            // Find following word in keep-case tree.</a>
<a name="ln883">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln884">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln885"> </a>
<a name="ln886">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln887">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln888">            // can't be a postponed prefix.</a>
<a name="ln889">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln890">              // Check for following word with prefix.</a>
<a name="ln891">              mip-&gt;mi_compoff = c;</a>
<a name="ln892">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln893">            }</a>
<a name="ln894">#endif</a>
<a name="ln895">          }</a>
<a name="ln896"> </a>
<a name="ln897">          if (!slang-&gt;sl_nobreak) {</a>
<a name="ln898">            break;</a>
<a name="ln899">          }</a>
<a name="ln900">        }</a>
<a name="ln901">        mip-&gt;mi_complen--;</a>
<a name="ln902">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln903">          mip-&gt;mi_compextra--;</a>
<a name="ln904">        }</a>
<a name="ln905">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln906"> </a>
<a name="ln907">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln908">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln909">          mip-&gt;mi_result = save_result;</a>
<a name="ln910">          mip-&gt;mi_end = save_end;</a>
<a name="ln911">        } else {</a>
<a name="ln912">          if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln913">            break;</a>
<a name="ln914">          }</a>
<a name="ln915">          continue;</a>
<a name="ln916">        }</a>
<a name="ln917">      }</a>
<a name="ln918"> </a>
<a name="ln919">      int res = SP_BAD;</a>
<a name="ln920">      if (flags &amp; WF_BANNED) {</a>
<a name="ln921">        res = SP_BANNED;</a>
<a name="ln922">      } else if (flags &amp; WF_REGION) {</a>
<a name="ln923">        // Check region.</a>
<a name="ln924">        if (((unsigned)mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0) {</a>
<a name="ln925">          res = SP_OK;</a>
<a name="ln926">        } else {</a>
<a name="ln927">          res = SP_LOCAL;</a>
<a name="ln928">        }</a>
<a name="ln929">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln930">        res = SP_RARE;</a>
<a name="ln931">      } else {</a>
<a name="ln932">        res = SP_OK;</a>
<a name="ln933">      }</a>
<a name="ln934"> </a>
<a name="ln935">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln936">      // we separately keep the longest match without a following good</a>
<a name="ln937">      // word as a fall-back.</a>
<a name="ln938">      if (nobreak_result == SP_BAD) {</a>
<a name="ln939">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln940">          mip-&gt;mi_result2 = res;</a>
<a name="ln941">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln942">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln943">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln944">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln945">        }</a>
<a name="ln946">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln947">        mip-&gt;mi_result = res;</a>
<a name="ln948">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln949">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln950">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln951">      }</a>
<a name="ln952"> </a>
<a name="ln953">      if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln954">        break;</a>
<a name="ln955">      }</a>
<a name="ln956">    }</a>
<a name="ln957"> </a>
<a name="ln958">    if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln959">      break;</a>
<a name="ln960">    }</a>
<a name="ln961">  }</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">/// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln965">/// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln966">/// word.</a>
<a name="ln967">/// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln968">/// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln969">///</a>
<a name="ln970">/// @param gap  &amp;sl_comppat</a>
<a name="ln971">bool match_checkcompoundpattern(char *ptr, int wlen, garray_T *gap)</a>
<a name="ln972">{</a>
<a name="ln973">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln974">    char *p = ((char **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln975">    if (strncmp(ptr + wlen, p, strlen(p)) == 0) {</a>
<a name="ln976">      // Second part matches at start of following compound word, now</a>
<a name="ln977">      // check if first part matches at end of previous word.</a>
<a name="ln978">      p = ((char **)gap-&gt;ga_data)[i];</a>
<a name="ln979">      int len = (int)strlen(p);</a>
<a name="ln980">      if (len &lt;= wlen &amp;&amp; strncmp(ptr + wlen - len, p, (size_t)len) == 0) {</a>
<a name="ln981">        return true;</a>
<a name="ln982">      }</a>
<a name="ln983">    }</a>
<a name="ln984">  }</a>
<a name="ln985">  return false;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/// @return  true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln989">///          does not have too many syllables.</a>
<a name="ln990">bool can_compound(slang_T *slang, const char *word, const uint8_t *flags)</a>
<a name="ln991">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln992">{</a>
<a name="ln993">  char uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln994"> </a>
<a name="ln995">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln996">    return false;</a>
<a name="ln997">  }</a>
<a name="ln998">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln999">  char *p = uflags;</a>
<a name="ln1000">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1001">    p += utf_char2bytes(flags[i], p);</a>
<a name="ln1002">  }</a>
<a name="ln1003">  *p = NUL;</a>
<a name="ln1004">  p = uflags;</a>
<a name="ln1005">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1006">    return false;</a>
<a name="ln1007">  }</a>
<a name="ln1008"> </a>
<a name="ln1009">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1010">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1011">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1012">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1013">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax) {</a>
<a name="ln1014">    return (int)strlen((char *)flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1015">  }</a>
<a name="ln1016">  return true;</a>
<a name="ln1017">}</a>
<a name="ln1018"> </a>
<a name="ln1019">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1020">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1021">// collected so far can't possibly match any compound rule.</a>
<a name="ln1022">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1023">bool match_compoundrule(slang_T *slang, const uint8_t *compflags)</a>
<a name="ln1024">{</a>
<a name="ln1025">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1026">  for (char *p = (char *)slang-&gt;sl_comprules; *p != NUL; p++) {</a>
<a name="ln1027">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1028">    // them against the current rule entry</a>
<a name="ln1029">    for (int i = 0;; i++) {</a>
<a name="ln1030">      int c = compflags[i];</a>
<a name="ln1031">      if (c == NUL) {</a>
<a name="ln1032">        // found a rule that matches for the flags we have so far</a>
<a name="ln1033">        return true;</a>
<a name="ln1034">      }</a>
<a name="ln1035">      if (*p == '/' || *p == NUL) {</a>
<a name="ln1036">        break;          // end of rule, it's too short</a>
<a name="ln1037">      }</a>
<a name="ln1038">      if (*p == '[') {</a>
<a name="ln1039">        bool match = false;</a>
<a name="ln1040"> </a>
<a name="ln1041">        // compare against all the flags in []</a>
<a name="ln1042">        p++;</a>
<a name="ln1043">        while (*p != ']' &amp;&amp; *p != NUL) {</a>
<a name="ln1044">          if ((uint8_t)(*p++) == c) {</a>
<a name="ln1045">            match = true;</a>
<a name="ln1046">          }</a>
<a name="ln1047">        }</a>
<a name="ln1048">        if (!match) {</a>
<a name="ln1049">          break;            // none matches</a>
<a name="ln1050">        }</a>
<a name="ln1051">      } else if ((uint8_t)(*p) != c) {</a>
<a name="ln1052">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1053">      }</a>
<a name="ln1054">      p++;</a>
<a name="ln1055">    }</a>
<a name="ln1056"> </a>
<a name="ln1057">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1058">    p = vim_strchr(p, '/');</a>
<a name="ln1059">    if (p == NULL) {</a>
<a name="ln1060">      break;</a>
<a name="ln1061">    }</a>
<a name="ln1062">  }</a>
<a name="ln1063"> </a>
<a name="ln1064">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1065">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1066">  return false;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">/// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1070">/// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1071">/// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1072">///</a>
<a name="ln1073">/// @param totprefcnt  nr of prefix IDs</a>
<a name="ln1074">/// @param arridx  idx in sl_pidxs[]</a>
<a name="ln1075">/// @param cond_req  only use prefixes with a condition</a>
<a name="ln1076">int valid_word_prefix(int totprefcnt, int arridx, int flags, char *word, slang_T *slang,</a>
<a name="ln1077">                      bool cond_req)</a>
<a name="ln1078">{</a>
<a name="ln1079">  int prefid = (int)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln1080">  for (int prefcnt = totprefcnt - 1; prefcnt &gt;= 0; prefcnt--) {</a>
<a name="ln1081">    int pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1082"> </a>
<a name="ln1083">    // Check the prefix ID.</a>
<a name="ln1084">    if (prefid != (pidx &amp; 0xff)) {</a>
<a name="ln1085">      continue;</a>
<a name="ln1086">    }</a>
<a name="ln1087"> </a>
<a name="ln1088">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1089">    // suffix.</a>
<a name="ln1090">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC)) {</a>
<a name="ln1091">      continue;</a>
<a name="ln1092">    }</a>
<a name="ln1093"> </a>
<a name="ln1094">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1095">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1096">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1097">    if (*rp != NULL) {</a>
<a name="ln1098">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1099">        continue;</a>
<a name="ln1100">      }</a>
<a name="ln1101">    } else if (cond_req) {</a>
<a name="ln1102">      continue;</a>
<a name="ln1103">    }</a>
<a name="ln1104"> </a>
<a name="ln1105">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1106">    return pidx;</a>
<a name="ln1107">  }</a>
<a name="ln1108">  return 0;</a>
<a name="ln1109">}</a>
<a name="ln1110"> </a>
<a name="ln1111">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1112">// If it does, then check the following word.</a>
<a name="ln1113">//</a>
<a name="ln1114">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1115">// prefix in a compound word.</a>
<a name="ln1116">//</a>
<a name="ln1117">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1118">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1119">{</a>
<a name="ln1120">  idx_T arridx = 0;</a>
<a name="ln1121">  int wlen = 0;</a>
<a name="ln1122">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1123"> </a>
<a name="ln1124">  uint8_t *byts = slang-&gt;sl_pbyts;</a>
<a name="ln1125">  if (byts == NULL) {</a>
<a name="ln1126">    return;                     // array is empty</a>
<a name="ln1127">  }</a>
<a name="ln1128">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1129">  // case-folded.</a>
<a name="ln1130">  char *ptr = mip-&gt;mi_fword;</a>
<a name="ln1131">  int flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1132">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1133">    // Skip over the previously found word(s).</a>
<a name="ln1134">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1135">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1136">  }</a>
<a name="ln1137">  idx_T *idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1138"> </a>
<a name="ln1139">  // Repeat advancing in the tree until:</a>
<a name="ln1140">  // - there is a byte that doesn't match,</a>
<a name="ln1141">  // - we reach the end of the tree,</a>
<a name="ln1142">  // - or we reach the end of the line.</a>
<a name="ln1143">  while (true) {</a>
<a name="ln1144">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln1145">      flen = fold_more(mip);</a>
<a name="ln1146">    }</a>
<a name="ln1147"> </a>
<a name="ln1148">    int len = byts[arridx++];</a>
<a name="ln1149"> </a>
<a name="ln1150">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1151">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1152">    if (byts[arridx] == 0) {</a>
<a name="ln1153">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1154">      // try them all, since we don't know which one will give the</a>
<a name="ln1155">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1156">      // of possible prefixes to find_word().</a>
<a name="ln1157">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1158">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1159">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1160">        arridx++;</a>
<a name="ln1161">        len--;</a>
<a name="ln1162">      }</a>
<a name="ln1163">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1164"> </a>
<a name="ln1165">      // Find the word that comes after the prefix.</a>
<a name="ln1166">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1167">      if (mode == FIND_COMPOUND) {</a>
<a name="ln1168">        // Skip over the previously found word(s).</a>
<a name="ln1169">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1170">      }</a>
<a name="ln1171"> </a>
<a name="ln1172">      // Case-folded length may differ from original length.</a>
<a name="ln1173">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1174">                                      mip-&gt;mi_word);</a>
<a name="ln1175">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1176"> </a>
<a name="ln1177">      if (len == 0) {</a>
<a name="ln1178">        break;              // no children, word must end here</a>
<a name="ln1179">      }</a>
<a name="ln1180">    }</a>
<a name="ln1181"> </a>
<a name="ln1182">    // Stop looking at end of the line.</a>
<a name="ln1183">    if (ptr[wlen] == NUL) {</a>
<a name="ln1184">      break;</a>
<a name="ln1185">    }</a>
<a name="ln1186"> </a>
<a name="ln1187">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1188">    int c = (uint8_t)ptr[wlen];</a>
<a name="ln1189">    idx_T lo = arridx;</a>
<a name="ln1190">    idx_T hi = arridx + len - 1;</a>
<a name="ln1191">    while (lo &lt; hi) {</a>
<a name="ln1192">      idx_T m = (lo + hi) / 2;</a>
<a name="ln1193">      if (byts[m] &gt; c) {</a>
<a name="ln1194">        hi = m - 1;</a>
<a name="ln1195">      } else if (byts[m] &lt; c) {</a>
<a name="ln1196">        lo = m + 1;</a>
<a name="ln1197">      } else {</a>
<a name="ln1198">        lo = hi = m;</a>
<a name="ln1199">        break;</a>
<a name="ln1200">      }</a>
<a name="ln1201">    }</a>
<a name="ln1202"> </a>
<a name="ln1203">    // Stop if there is no matching byte.</a>
<a name="ln1204">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln1205">      break;</a>
<a name="ln1206">    }</a>
<a name="ln1207"> </a>
<a name="ln1208">    // Continue at the child (if there is one).</a>
<a name="ln1209">    arridx = idxs[lo];</a>
<a name="ln1210">    wlen++;</a>
<a name="ln1211">    flen--;</a>
<a name="ln1212">  }</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1216">// for efficiency.  Include the non-word character too.</a>
<a name="ln1217">// Return the length of the folded chars in bytes.</a>
<a name="ln1218">static int fold_more(matchinf_T *mip)</a>
<a name="ln1219">{</a>
<a name="ln1220">  char *p = mip-&gt;mi_fend;</a>
<a name="ln1221">  do {</a>
<a name="ln1222">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1223">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1224"> </a>
<a name="ln1225">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1226">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1227">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  (void)spell_casefold(mip-&gt;mi_win, p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1231">                       mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1232">                       MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1233">  int flen = (int)strlen(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1234">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1235">  return flen;</a>
<a name="ln1236">}</a>
<a name="ln1237"> </a>
<a name="ln1238">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1239">/// case.</a>
<a name="ln1240">///</a>
<a name="ln1241">/// @param wordflags Flags for the checked word.</a>
<a name="ln1242">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1243">bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1244">{</a>
<a name="ln1245">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1246">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1247">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1248">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">/// Return true if spell checking is enabled for &quot;wp&quot;.</a>
<a name="ln1252">bool spell_check_window(win_T *wp)</a>
<a name="ln1253">{</a>
<a name="ln1254">  return wp-&gt;w_p_spell</a>
<a name="ln1255">         &amp;&amp; *wp-&gt;w_s-&gt;b_p_spl != NUL</a>
<a name="ln1256">         &amp;&amp; wp-&gt;w_s-&gt;b_langp.ga_len &gt; 0</a>
<a name="ln1257">         &amp;&amp; *(char **)(wp-&gt;w_s-&gt;b_langp.ga_data) != NULL;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">/// Return true and give an error if spell checking is not enabled.</a>
<a name="ln1261">bool no_spell_checking(win_T *wp)</a>
<a name="ln1262">{</a>
<a name="ln1263">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1264">    emsg(_(e_no_spell));</a>
<a name="ln1265">    return true;</a>
<a name="ln1266">  }</a>
<a name="ln1267">  return false;</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">static void decor_spell_nav_start(win_T *wp)</a>
<a name="ln1271">{</a>
<a name="ln1272">  decor_state = (DecorState){ 0 };</a>
<a name="ln1273">  decor_redraw_reset(wp, &amp;decor_state);</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">static TriState decor_spell_nav_col(win_T *wp, linenr_T lnum, linenr_T *decor_lnum, int col)</a>
<a name="ln1277">{</a>
<a name="ln1278">  if (*decor_lnum != lnum) {</a>
<a name="ln1279">    decor_providers_invoke_spell(wp, lnum - 1, col, lnum - 1, -1);</a>
<a name="ln1280">    decor_redraw_line(wp, lnum - 1, &amp;decor_state);</a>
<a name="ln1281">    *decor_lnum = lnum;</a>
<a name="ln1282">  }</a>
<a name="ln1283">  decor_redraw_col(wp, col, 0, false, &amp;decor_state);</a>
<a name="ln1284">  return decor_state.spell;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">static inline bool can_syn_spell(win_T *wp, linenr_T lnum, int col)</a>
<a name="ln1288">{</a>
<a name="ln1289">  bool can_spell;</a>
<a name="ln1290">  (void)syn_get_id(wp, lnum, col, false, &amp;can_spell, false);</a>
<a name="ln1291">  return can_spell;</a>
<a name="ln1292">}</a>
<a name="ln1293"> </a>
<a name="ln1294">/// Moves to the next spell error.</a>
<a name="ln1295">/// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1296">/// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1297">/// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1298">/// to after badly spelled word before the cursor.</a>
<a name="ln1299">///</a>
<a name="ln1300">/// @param dir  FORWARD or BACKWARD</a>
<a name="ln1301">/// @param allwords  true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1302">/// @param attrp  return: attributes of bad word or NULL (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1303">///</a>
<a name="ln1304">/// @return  0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1305">size_t spell_move_to(win_T *wp, int dir, bool allwords, bool curline, hlf_T *attrp)</a>
<a name="ln1306">{</a>
<a name="ln1307">  pos_T found_pos;</a>
<a name="ln1308">  size_t found_len = 0;</a>
<a name="ln1309">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1310">  size_t len;</a>
<a name="ln1311">  int has_syntax = syntax_present(wp);</a>
<a name="ln1312">  colnr_T col;</a>
<a name="ln1313">  char *buf = NULL;</a>
<a name="ln1314">  size_t buflen = 0;</a>
<a name="ln1315">  int skip = 0;</a>
<a name="ln1316">  colnr_T capcol = -1;</a>
<a name="ln1317">  bool found_one = false;</a>
<a name="ln1318">  bool wrapped = false;</a>
<a name="ln1319"> </a>
<a name="ln1320">  if (no_spell_checking(wp)) {</a>
<a name="ln1321">    return 0;</a>
<a name="ln1322">  }</a>
<a name="ln1323"> </a>
<a name="ln1324">  size_t ret = 0;</a>
<a name="ln1325"> </a>
<a name="ln1326">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1327">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1328">  //</a>
<a name="ln1329">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1330">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1331">  //</a>
<a name="ln1332">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1333">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1334">  // though...</a>
<a name="ln1335">  linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1336">  clearpos(&amp;found_pos);</a>
<a name="ln1337"> </a>
<a name="ln1338">  // Ephemeral extmarks are currently stored in the global decor_state.</a>
<a name="ln1339">  // When looking for spell errors, we need to:</a>
<a name="ln1340">  //  - temporarily reset decor_state</a>
<a name="ln1341">  //  - run the _on_spell_nav decor callback for each line we look at</a>
<a name="ln1342">  //  - detect if any spell marks are present</a>
<a name="ln1343">  //  - restore decor_state to the value saved here.</a>
<a name="ln1344">  // TODO(lewis6991): un-globalize decor_state and allow ephemeral marks to be stored into a</a>
<a name="ln1345">  // temporary DecorState.</a>
<a name="ln1346">  DecorState saved_decor_start = decor_state;</a>
<a name="ln1347">  linenr_T decor_lnum = -1;</a>
<a name="ln1348">  decor_spell_nav_start(wp);</a>
<a name="ln1349"> </a>
<a name="ln1350">  while (!got_int) {</a>
<a name="ln1351">    char *line = ml_get_buf(wp-&gt;w_buffer, lnum);</a>
<a name="ln1352"> </a>
<a name="ln1353">    len = strlen(line);</a>
<a name="ln1354">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1355">      xfree(buf);</a>
<a name="ln1356">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1357">      buf = xmalloc(buflen);</a>
<a name="ln1358">    }</a>
<a name="ln1359">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1360"> </a>
<a name="ln1361">    // In first line check first word for Capital.</a>
<a name="ln1362">    if (lnum == 1) {</a>
<a name="ln1363">      capcol = 0;</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">    // For checking first word with a capital skip white space.</a>
<a name="ln1367">    if (capcol == 0) {</a>
<a name="ln1368">      capcol = (colnr_T)getwhitecols(line);</a>
<a name="ln1369">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1370">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1371">      col = (colnr_T)getwhitecols(line);</a>
<a name="ln1372">      if (check_need_cap(curwin, lnum, col)) {</a>
<a name="ln1373">        capcol = col;</a>
<a name="ln1374">      }</a>
<a name="ln1375"> </a>
<a name="ln1376">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1377">      // one.</a>
<a name="ln1378">      line = ml_get_buf(wp-&gt;w_buffer, lnum);</a>
<a name="ln1379">    }</a>
<a name="ln1380"> </a>
<a name="ln1381">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1382">    // possible.  Note: this ml_get_buf() may make &quot;line&quot; invalid, check</a>
<a name="ln1383">    // for empty line first.</a>
<a name="ln1384">    bool empty_line = *skipwhite(line) == NUL;</a>
<a name="ln1385">    STRCPY(buf, line);</a>
<a name="ln1386">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1387">      spell_cat_line(buf + strlen(buf),</a>
<a name="ln1388">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1),</a>
<a name="ln1389">                     MAXWLEN);</a>
<a name="ln1390">    }</a>
<a name="ln1391">    char *p = buf + skip;</a>
<a name="ln1392">    char *endp = buf + len;</a>
<a name="ln1393">    while (p &lt; endp) {</a>
<a name="ln1394">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1395">      // we wrapped around the end of the buffer.</a>
<a name="ln1396">      if (dir == BACKWARD</a>
<a name="ln1397">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1398">          &amp;&amp; !wrapped</a>
<a name="ln1399">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col) {</a>
<a name="ln1400">        break;</a>
<a name="ln1401">      }</a>
<a name="ln1402"> </a>
<a name="ln1403">      // start of word</a>
<a name="ln1404">      attr = HLF_COUNT;</a>
<a name="ln1405">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1406"> </a>
<a name="ln1407">      if (attr != HLF_COUNT) {</a>
<a name="ln1408">        // We found a bad word.  Check the attribute.</a>
<a name="ln1409">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1410">          // When searching forward only accept a bad word after</a>
<a name="ln1411">          // the cursor.</a>
<a name="ln1412">          if (dir == BACKWARD</a>
<a name="ln1413">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1414">              || wrapped</a>
<a name="ln1415">              || ((colnr_T)(curline</a>
<a name="ln1416">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1417">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1418">            col = (colnr_T)(p - buf);</a>
<a name="ln1419"> </a>
<a name="ln1420">            bool no_plain_buffer = (wp-&gt;w_s-&gt;b_p_spo_flags &amp; SPO_NPBUFFER) != 0;</a>
<a name="ln1421">            bool can_spell = !no_plain_buffer;</a>
<a name="ln1422">            switch (decor_spell_nav_col(wp, lnum, &amp;decor_lnum, col)) {</a>
<a name="ln1423">            case kTrue:</a>
<a name="ln1424">              can_spell = true; break;</a>
<a name="ln1425">            case kFalse:</a>
<a name="ln1426">              can_spell = false; break;</a>
<a name="ln1427">            case kNone:</a>
<a name="ln1428">              if (has_syntax) {</a>
<a name="ln1429">                can_spell = can_syn_spell(wp, lnum, col);</a>
<a name="ln1430">              }</a>
<a name="ln1431">            }</a>
<a name="ln1432"> </a>
<a name="ln1433">            if (!can_spell) {</a>
<a name="ln1434">              attr = HLF_COUNT;</a>
<a name="ln1435">            }</a>
<a name="ln1436"> </a>
<a name="ln1437">            if (can_spell) {</a>
<a name="ln1438">              found_one = true;</a>
<a name="ln1439">              found_pos = (pos_T) {</a>
<a name="ln1440">                .lnum = lnum,</a>
<a name="ln1441">                .col = col,</a>
<a name="ln1442">                .coladd = 0</a>
<a name="ln1443">              };</a>
<a name="ln1444">              if (dir == FORWARD) {</a>
<a name="ln1445">                // No need to search further.</a>
<a name="ln1446">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1447">                if (attrp != NULL) {</a>
<a name="ln1448">                  *attrp = attr;</a>
<a name="ln1449">                }</a>
<a name="ln1450">                ret = len;</a>
<a name="ln1451">                goto theend;</a>
<a name="ln1452">              } else if (curline) {</a>
<a name="ln1453">                // Insert mode completion: put cursor after</a>
<a name="ln1454">                // the bad word.</a>
<a name="ln1455">                assert(len &lt;= INT_MAX);</a>
<a name="ln1456">                found_pos.col += (int)len;</a>
<a name="ln1457">              }</a>
<a name="ln1458">              found_len = len;</a>
<a name="ln1459">            }</a>
<a name="ln1460">          } else {</a>
<a name="ln1461">            found_one = true;</a>
<a name="ln1462">          }</a>
<a name="ln1463">        }</a>
<a name="ln1464">      }</a>
<a name="ln1465"> </a>
<a name="ln1466">      // advance to character after the word</a>
<a name="ln1467">      p += len;</a>
<a name="ln1468">      assert(len &lt;= INT_MAX);</a>
<a name="ln1469">      capcol -= (int)len;</a>
<a name="ln1470">    }</a>
<a name="ln1471"> </a>
<a name="ln1472">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1473">      // Use the last match in the line (before the cursor).</a>
<a name="ln1474">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1475">      ret = found_len;</a>
<a name="ln1476">      goto theend;</a>
<a name="ln1477">    }</a>
<a name="ln1478"> </a>
<a name="ln1479">    if (curline) {</a>
<a name="ln1480">      break;            // only check cursor line</a>
<a name="ln1481">    }</a>
<a name="ln1482"> </a>
<a name="ln1483">    // If we are back at the starting line and searched it again there</a>
<a name="ln1484">    // is no match, give up.</a>
<a name="ln1485">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1486">      break;</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">    // Advance to next line.</a>
<a name="ln1490">    if (dir == BACKWARD) {</a>
<a name="ln1491">      if (lnum &gt; 1) {</a>
<a name="ln1492">        lnum--;</a>
<a name="ln1493">      } else if (!p_ws) {</a>
<a name="ln1494">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1495">      } else {</a>
<a name="ln1496">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1497">        // starting line again and accept the last match.</a>
<a name="ln1498">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1499">        wrapped = true;</a>
<a name="ln1500">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1501">          give_warning(_(top_bot_msg), true);</a>
<a name="ln1502">        }</a>
<a name="ln1503">      }</a>
<a name="ln1504">      capcol = -1;</a>
<a name="ln1505">    } else {</a>
<a name="ln1506">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1507">        lnum++;</a>
<a name="ln1508">      } else if (!p_ws) {</a>
<a name="ln1509">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1510">      } else {</a>
<a name="ln1511">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1512">        // starting line again and accept the first match.</a>
<a name="ln1513">        lnum = 1;</a>
<a name="ln1514">        wrapped = true;</a>
<a name="ln1515">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1516">          give_warning(_(bot_top_msg), true);</a>
<a name="ln1517">        }</a>
<a name="ln1518">      }</a>
<a name="ln1519"> </a>
<a name="ln1520">      // If we are back at the starting line and there is no match then</a>
<a name="ln1521">      // give up.</a>
<a name="ln1522">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1523">        break;</a>
<a name="ln1524">      }</a>
<a name="ln1525"> </a>
<a name="ln1526">      // Skip the characters at the start of the next line that were</a>
<a name="ln1527">      // included in a match crossing line boundaries.</a>
<a name="ln1528">      if (attr == HLF_COUNT) {</a>
<a name="ln1529">        skip = (int)(p - endp);</a>
<a name="ln1530">      } else {</a>
<a name="ln1531">        skip = 0;</a>
<a name="ln1532">      }</a>
<a name="ln1533"> </a>
<a name="ln1534">      // Capcol skips over the inserted space.</a>
<a name="ln1535">      capcol--;</a>
<a name="ln1536"> </a>
<a name="ln1537">      // But after empty line check first word in next line</a>
<a name="ln1538">      if (empty_line) {</a>
<a name="ln1539">        capcol = 0;</a>
<a name="ln1540">      }</a>
<a name="ln1541">    }</a>
<a name="ln1542"> </a>
<a name="ln1543">    line_breakcheck();</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546">theend:</a>
<a name="ln1547">  decor_state_free(&amp;decor_state);</a>
<a name="ln1548">  decor_state = saved_decor_start;</a>
<a name="ln1549">  xfree(buf);</a>
<a name="ln1550">  return ret;</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1554">// &quot;buf&quot;, blanking-out special characters.  Copy less than &quot;maxlen&quot; bytes.</a>
<a name="ln1555">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1556">// to skip those bytes if the word was OK.</a>
<a name="ln1557">void spell_cat_line(char *buf, char *line, int maxlen)</a>
<a name="ln1558">{</a>
<a name="ln1559">  char *p = skipwhite(line);</a>
<a name="ln1560">  while (vim_strchr(&quot;*#/\&quot;\t&quot;, (uint8_t)(*p)) != NULL) {</a>
<a name="ln1561">    p = skipwhite(p + 1);</a>
<a name="ln1562">  }</a>
<a name="ln1563"> </a>
<a name="ln1564">  if (*p == NUL) {</a>
<a name="ln1565">    return;</a>
<a name="ln1566">  }</a>
<a name="ln1567"> </a>
<a name="ln1568">  // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1569">  // concatenate.</a>
<a name="ln1570">  int n = (int)(p - line) + 1;</a>
<a name="ln1571">  if (n &lt; maxlen - 1) {</a>
<a name="ln1572">    memset(buf, ' ', (size_t)n);</a>
<a name="ln1573">    xstrlcpy(buf + n, p, (size_t)(maxlen - n));</a>
<a name="ln1574">  }</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1578">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1579">static void spell_load_lang(char *lang)</a>
<a name="ln1580">{</a>
<a name="ln1581">  char fname_enc[85];</a>
<a name="ln1582">  int r;</a>
<a name="ln1583">  spelload_T sl;</a>
<a name="ln1584"> </a>
<a name="ln1585">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1586">  // It's truncated when an error is detected.</a>
<a name="ln1587">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1588">  sl.sl_slang = NULL;</a>
<a name="ln1589">  sl.sl_nobreak = false;</a>
<a name="ln1590"> </a>
<a name="ln1591">  // Disallow deleting the current buffer.  Autocommands can do weird things</a>
<a name="ln1592">  // and cause &quot;lang&quot; to be freed.</a>
<a name="ln1593">  curbuf-&gt;b_locked++;</a>
<a name="ln1594"> </a>
<a name="ln1595">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1596">  // autocommand may load it then.</a>
<a name="ln1597">  for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln1598">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1599">    vim_snprintf(fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1600">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1601">    r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1602"> </a>
<a name="ln1603">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1604">      // Try loading the ASCII version.</a>
<a name="ln1605">      vim_snprintf(fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1606">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1607">      r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1608"> </a>
<a name="ln1609">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1610">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, lang,</a>
<a name="ln1611">                            curbuf-&gt;b_fname, false, curbuf)) {</a>
<a name="ln1612">        continue;</a>
<a name="ln1613">      }</a>
<a name="ln1614">      break;</a>
<a name="ln1615">    }</a>
<a name="ln1616">    break;</a>
<a name="ln1617">  }</a>
<a name="ln1618"> </a>
<a name="ln1619">  if (r == FAIL) {</a>
<a name="ln1620">    if (starting) {</a>
<a name="ln1621">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1622">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1623">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1624">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1625">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1626">               lang);</a>
<a name="ln1627">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1628">    } else {</a>
<a name="ln1629">      smsg(0, _(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1630">           lang, spell_enc(), lang);</a>
<a name="ln1631">    }</a>
<a name="ln1632">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1633">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1634">    STRCPY(fname_enc + strlen(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1635">    do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1636">  }</a>
<a name="ln1637"> </a>
<a name="ln1638">  curbuf-&gt;b_locked--;</a>
<a name="ln1639">}</a>
<a name="ln1640"> </a>
<a name="ln1641">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1642">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1643">char *spell_enc(void)</a>
<a name="ln1644">{</a>
<a name="ln1645">  if (strlen(p_enc) &lt; 60 &amp;&amp; strcmp(p_enc, &quot;iso-8859-15&quot;) != 0) {</a>
<a name="ln1646">    return p_enc;</a>
<a name="ln1647">  }</a>
<a name="ln1648">  return &quot;latin1&quot;;</a>
<a name="ln1649">}</a>
<a name="ln1650"> </a>
<a name="ln1651">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1652">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1653">static void int_wordlist_spl(char *fname)</a>
<a name="ln1654">{</a>
<a name="ln1655">  vim_snprintf(fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1656">               int_wordlist, spell_enc());</a>
<a name="ln1657">}</a>
<a name="ln1658"> </a>
<a name="ln1659">/// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1660">/// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1661">slang_T *slang_alloc(char *lang)</a>
<a name="ln1662">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1663">{</a>
<a name="ln1664">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1665"> </a>
<a name="ln1666">  if (lang != NULL) {</a>
<a name="ln1667">    lp-&gt;sl_name = xstrdup(lang);</a>
<a name="ln1668">  }</a>
<a name="ln1669">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1670">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1671">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1672">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1673">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1674"> </a>
<a name="ln1675">  return lp;</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1679">void slang_free(slang_T *lp)</a>
<a name="ln1680">{</a>
<a name="ln1681">  xfree(lp-&gt;sl_name);</a>
<a name="ln1682">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1683">  slang_clear(lp);</a>
<a name="ln1684">  xfree(lp);</a>
<a name="ln1685">}</a>
<a name="ln1686"> </a>
<a name="ln1687">/// Frees a salitem_T</a>
<a name="ln1688">static void free_salitem(salitem_T *smp)</a>
<a name="ln1689">{</a>
<a name="ln1690">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1691">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1692">  xfree(smp-&gt;sm_to);</a>
<a name="ln1693">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1694">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1695">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1696">}</a>
<a name="ln1697"> </a>
<a name="ln1698">/// Frees a fromto_T</a>
<a name="ln1699">static void free_fromto(fromto_T *ftp)</a>
<a name="ln1700">{</a>
<a name="ln1701">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1702">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1703">}</a>
<a name="ln1704"> </a>
<a name="ln1705">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1706">void slang_clear(slang_T *lp)</a>
<a name="ln1707">{</a>
<a name="ln1708">  garray_T *gap;</a>
<a name="ln1709"> </a>
<a name="ln1710">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1711">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1712">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1713"> </a>
<a name="ln1714">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1715">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1716">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1717"> </a>
<a name="ln1718">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1719">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1720"> </a>
<a name="ln1721">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1722">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1723">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1724">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1725">  } else {</a>
<a name="ln1726">    // SAL items: free salitem_T items</a>
<a name="ln1727">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1728">  }</a>
<a name="ln1729"> </a>
<a name="ln1730">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; i++) {</a>
<a name="ln1731">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1732">  }</a>
<a name="ln1733">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1734">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1735">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1736">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1737"> </a>
<a name="ln1738">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1739">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1740">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1741">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1742">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1743"> </a>
<a name="ln1744">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1745">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1746"> </a>
<a name="ln1747">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1748"> </a>
<a name="ln1749">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1750">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1751"> </a>
<a name="ln1752">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1753"> </a>
<a name="ln1754">  // Clear info from .sug file.</a>
<a name="ln1755">  slang_clear_sug(lp);</a>
<a name="ln1756"> </a>
<a name="ln1757">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1758">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1759">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1760">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1761">}</a>
<a name="ln1762"> </a>
<a name="ln1763">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1764">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1765">{</a>
<a name="ln1766">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1767">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1768">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1769">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1770">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1771">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1772">}</a>
<a name="ln1773"> </a>
<a name="ln1774">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1775">// Invoked through do_in_runtimepath().</a>
<a name="ln1776">static bool spell_load_cb(int num_fnames, char **fnames, bool all, void *cookie)</a>
<a name="ln1777">{</a>
<a name="ln1778">  spelload_T *slp = (spelload_T *)cookie;</a>
<a name="ln1779">  for (int i = 0; i &lt; num_fnames; i++) {</a>
<a name="ln1780">    slang_T *slang = spell_load_file(fnames[i], slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1781"> </a>
<a name="ln1782">    if (slang == NULL) {</a>
<a name="ln1783">      continue;</a>
<a name="ln1784">    }</a>
<a name="ln1785"> </a>
<a name="ln1786">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1787">    // &quot;.add&quot; files.</a>
<a name="ln1788">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add) {</a>
<a name="ln1789">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1790">    } else if (slang-&gt;sl_nobreak) {</a>
<a name="ln1791">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1792">    }</a>
<a name="ln1793"> </a>
<a name="ln1794">    slp-&gt;sl_slang = slang;</a>
<a name="ln1795"> </a>
<a name="ln1796">    if (!all) {</a>
<a name="ln1797">      break;</a>
<a name="ln1798">    }</a>
<a name="ln1799">  }</a>
<a name="ln1800"> </a>
<a name="ln1801">  return num_fnames &gt; 0;</a>
<a name="ln1802">}</a>
<a name="ln1803"> </a>
<a name="ln1804">/// Add a word to the hashtable of common words.</a>
<a name="ln1805">/// If it's already there then the counter is increased.</a>
<a name="ln1806">///</a>
<a name="ln1807">/// @param[in]  lp</a>
<a name="ln1808">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1809">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1810">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1811">void count_common_word(slang_T *lp, char *word, int len, uint8_t count)</a>
<a name="ln1812">{</a>
<a name="ln1813">  char buf[MAXWLEN];</a>
<a name="ln1814">  char *p;</a>
<a name="ln1815"> </a>
<a name="ln1816">  if (len == -1) {</a>
<a name="ln1817">    p = word;</a>
<a name="ln1818">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1819">    return;</a>
<a name="ln1820">  } else {</a>
<a name="ln1821">    xstrlcpy(buf, word, (size_t)len + 1);</a>
<a name="ln1822">    p = buf;</a>
<a name="ln1823">  }</a>
<a name="ln1824"> </a>
<a name="ln1825">  wordcount_T *wc;</a>
<a name="ln1826">  hash_T hash = hash_hash(p);</a>
<a name="ln1827">  const size_t p_len = strlen(p);</a>
<a name="ln1828">  hashitem_T *hi = hash_lookup(&amp;lp-&gt;sl_wordcount, p, p_len, hash);</a>
<a name="ln1829">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1830">    wc = xmalloc(offsetof(wordcount_T, wc_word) + p_len + 1);</a>
<a name="ln1831">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1832">    wc-&gt;wc_count = count;</a>
<a name="ln1833">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1834">  } else {</a>
<a name="ln1835">    wc = HI2WC(hi);</a>
<a name="ln1836">    wc-&gt;wc_count = (uint16_t)(wc-&gt;wc_count + count);</a>
<a name="ln1837">    if (wc-&gt;wc_count &lt; count) {    // check for overflow</a>
<a name="ln1838">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1839">    }</a>
<a name="ln1840">  }</a>
<a name="ln1841">}</a>
<a name="ln1842"> </a>
<a name="ln1843">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1844">// Like strchr() but independent of locale.</a>
<a name="ln1845">bool byte_in_str(uint8_t *str, int n)</a>
<a name="ln1846">{</a>
<a name="ln1847">  for (uint8_t *p = str; *p != NUL; p++) {</a>
<a name="ln1848">    if (*p == n) {</a>
<a name="ln1849">      return true;</a>
<a name="ln1850">    }</a>
<a name="ln1851">  }</a>
<a name="ln1852">  return false;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1856">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1857">int init_syl_tab(slang_T *slang)</a>
<a name="ln1858">{</a>
<a name="ln1859">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1860">  char *p = vim_strchr(slang-&gt;sl_syllable, '/');</a>
<a name="ln1861">  while (p != NULL) {</a>
<a name="ln1862">    *p++ = NUL;</a>
<a name="ln1863">    if (*p == NUL) {        // trailing slash</a>
<a name="ln1864">      break;</a>
<a name="ln1865">    }</a>
<a name="ln1866">    char *s = p;</a>
<a name="ln1867">    p = vim_strchr(p, '/');</a>
<a name="ln1868">    int l;</a>
<a name="ln1869">    if (p == NULL) {</a>
<a name="ln1870">      l = (int)strlen(s);</a>
<a name="ln1871">    } else {</a>
<a name="ln1872">      l = (int)(p - s);</a>
<a name="ln1873">    }</a>
<a name="ln1874">    if (l &gt;= SY_MAXLEN) {</a>
<a name="ln1875">      return SP_FORMERROR;</a>
<a name="ln1876">    }</a>
<a name="ln1877"> </a>
<a name="ln1878">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1879">    xstrlcpy(syl-&gt;sy_chars, s, (size_t)l + 1);</a>
<a name="ln1880">    syl-&gt;sy_len = l;</a>
<a name="ln1881">  }</a>
<a name="ln1882">  return OK;</a>
<a name="ln1883">}</a>
<a name="ln1884"> </a>
<a name="ln1885">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1886">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1887">// Returns zero if syllables are not defines.</a>
<a name="ln1888">static int count_syllables(slang_T *slang, const char *word)</a>
<a name="ln1889">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1890">{</a>
<a name="ln1891">  int cnt = 0;</a>
<a name="ln1892">  bool skip = false;</a>
<a name="ln1893">  int len;</a>
<a name="ln1894"> </a>
<a name="ln1895">  if (slang-&gt;sl_syllable == NULL) {</a>
<a name="ln1896">    return 0;</a>
<a name="ln1897">  }</a>
<a name="ln1898"> </a>
<a name="ln1899">  for (const char *p = word; *p != NUL; p += len) {</a>
<a name="ln1900">    // When running into a space reset counter.</a>
<a name="ln1901">    if (*p == ' ') {</a>
<a name="ln1902">      len = 1;</a>
<a name="ln1903">      cnt = 0;</a>
<a name="ln1904">      continue;</a>
<a name="ln1905">    }</a>
<a name="ln1906"> </a>
<a name="ln1907">    // Find longest match of syllable items.</a>
<a name="ln1908">    len = 0;</a>
<a name="ln1909">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; i++) {</a>
<a name="ln1910">      syl_item_T *syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln1911">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln1912">          &amp;&amp; strncmp(p, syl-&gt;sy_chars, (size_t)syl-&gt;sy_len) == 0) {</a>
<a name="ln1913">        len = syl-&gt;sy_len;</a>
<a name="ln1914">      }</a>
<a name="ln1915">    }</a>
<a name="ln1916">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln1917">      cnt++;</a>
<a name="ln1918">      skip = false;</a>
<a name="ln1919">    } else {</a>
<a name="ln1920">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln1921">      int c = utf_ptr2char(p);</a>
<a name="ln1922">      len = utfc_ptr2len(p);</a>
<a name="ln1923">      if (vim_strchr(slang-&gt;sl_syllable, c) == NULL) {</a>
<a name="ln1924">        skip = false;               // No, search for next syllable</a>
<a name="ln1925">      } else if (!skip) {</a>
<a name="ln1926">        cnt++;                      // Yes, count it</a>
<a name="ln1927">        skip = true;                // don't count following syllable chars</a>
<a name="ln1928">      }</a>
<a name="ln1929">    }</a>
<a name="ln1930">  }</a>
<a name="ln1931">  return cnt;</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934">/// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln1935">/// @return  NULL if it's OK, an untranslated error message otherwise.</a>
<a name="ln1936">char *parse_spelllang(win_T *wp)</a>
<a name="ln1937">{</a>
<a name="ln1938">  garray_T ga;</a>
<a name="ln1939">  char *splp;</a>
<a name="ln1940">  char *region;</a>
<a name="ln1941">  char region_cp[3];</a>
<a name="ln1942">  bool filename;</a>
<a name="ln1943">  int region_mask;</a>
<a name="ln1944">  slang_T *slang;</a>
<a name="ln1945">  int c;</a>
<a name="ln1946">  char lang[MAXWLEN + 1];</a>
<a name="ln1947">  char spf_name[MAXPATHL];</a>
<a name="ln1948">  int len;</a>
<a name="ln1949">  char *p;</a>
<a name="ln1950">  int round;</a>
<a name="ln1951">  char *spf;</a>
<a name="ln1952">  char *use_region = NULL;</a>
<a name="ln1953">  bool dont_use_region = false;</a>
<a name="ln1954">  bool nobreak = false;</a>
<a name="ln1955">  langp_T *lp, *lp2;</a>
<a name="ln1956">  static bool recursive = false;</a>
<a name="ln1957">  char *ret_msg = NULL;</a>
<a name="ln1958">  char *spl_copy;</a>
<a name="ln1959"> </a>
<a name="ln1960">  bufref_T bufref;</a>
<a name="ln1961">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln1962"> </a>
<a name="ln1963">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln1964">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln1965">  // in which 'spell' is set.</a>
<a name="ln1966">  if (recursive) {</a>
<a name="ln1967">    return NULL;</a>
<a name="ln1968">  }</a>
<a name="ln1969">  recursive = true;</a>
<a name="ln1970"> </a>
<a name="ln1971">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln1972">  clear_midword(wp);</a>
<a name="ln1973"> </a>
<a name="ln1974">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln1975">  // it under our fingers.</a>
<a name="ln1976">  spl_copy = xstrdup(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln1977"> </a>
<a name="ln1978">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln1979"> </a>
<a name="ln1980">  // Loop over comma separated language names.</a>
<a name="ln1981">  for (splp = spl_copy; *splp != NUL;) {</a>
<a name="ln1982">    // Get one language name.</a>
<a name="ln1983">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln1984">    region = NULL;</a>
<a name="ln1985">    len = (int)strlen(lang);</a>
<a name="ln1986"> </a>
<a name="ln1987">    if (!valid_spelllang(lang)) {</a>
<a name="ln1988">      continue;</a>
<a name="ln1989">    }</a>
<a name="ln1990"> </a>
<a name="ln1991">    if (strcmp(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln1992">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln1993">      continue;</a>
<a name="ln1994">    }</a>
<a name="ln1995"> </a>
<a name="ln1996">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln1997">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln1998">    // from the name.</a>
<a name="ln1999">    if (len &gt; 4 &amp;&amp; path_fnamecmp(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2000">      filename = true;</a>
<a name="ln2001"> </a>
<a name="ln2002">      // Locate a region and remove it from the file name.</a>
<a name="ln2003">      p = vim_strchr(path_tail(lang), '_');</a>
<a name="ln2004">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2005">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2006">        xstrlcpy(region_cp, p + 1, 3);</a>
<a name="ln2007">        memmove(p, p + 3, (size_t)(len - (p - lang) - 2));</a>
<a name="ln2008">        region = region_cp;</a>
<a name="ln2009">      } else {</a>
<a name="ln2010">        dont_use_region = true;</a>
<a name="ln2011">      }</a>
<a name="ln2012"> </a>
<a name="ln2013">      // Check if we loaded this language before.</a>
<a name="ln2014">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2015">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2016">            == kEqualFiles) {</a>
<a name="ln2017">          break;</a>
<a name="ln2018">        }</a>
<a name="ln2019">      }</a>
<a name="ln2020">    } else {</a>
<a name="ln2021">      filename = false;</a>
<a name="ln2022">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2023">        region = lang + len - 2;</a>
<a name="ln2024">        lang[len - 3] = NUL;</a>
<a name="ln2025">      } else {</a>
<a name="ln2026">        dont_use_region = true;</a>
<a name="ln2027">      }</a>
<a name="ln2028"> </a>
<a name="ln2029">      // Check if we loaded this language before.</a>
<a name="ln2030">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2031">        if (STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2032">          break;</a>
<a name="ln2033">        }</a>
<a name="ln2034">      }</a>
<a name="ln2035">    }</a>
<a name="ln2036"> </a>
<a name="ln2037">    if (region != NULL) {</a>
<a name="ln2038">      // If the region differs from what was used before then don't</a>
<a name="ln2039">      // use it for 'spellfile'.</a>
<a name="ln2040">      if (use_region != NULL &amp;&amp; strcmp(region, use_region) != 0) {</a>
<a name="ln2041">        dont_use_region = true;</a>
<a name="ln2042">      }</a>
<a name="ln2043">      use_region = region;</a>
<a name="ln2044">    }</a>
<a name="ln2045"> </a>
<a name="ln2046">    // If not found try loading the language now.</a>
<a name="ln2047">    if (slang == NULL) {</a>
<a name="ln2048">      if (filename) {</a>
<a name="ln2049">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2050">      } else {</a>
<a name="ln2051">        spell_load_lang(lang);</a>
<a name="ln2052">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2053">        // destroying the buffer we are using or closing the window.</a>
<a name="ln2054">        if (!bufref_valid(&amp;bufref) || !win_valid_any_tab(wp)) {</a>
<a name="ln2055">          ret_msg = N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2056">          goto theend;</a>
<a name="ln2057">        }</a>
<a name="ln2058">      }</a>
<a name="ln2059">    }</a>
<a name="ln2060"> </a>
<a name="ln2061">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2062">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2063">      if (filename</a>
<a name="ln2064">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2065">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2066">        region_mask = REGION_ALL;</a>
<a name="ln2067">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2068">          // find region in sl_regions</a>
<a name="ln2069">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2070">          if (c == REGION_ALL) {</a>
<a name="ln2071">            if (slang-&gt;sl_add) {</a>
<a name="ln2072">              if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2073">                // This addition file is for other regions.</a>
<a name="ln2074">                region_mask = 0;</a>
<a name="ln2075">              }</a>
<a name="ln2076">            } else {</a>
<a name="ln2077">              // This is probably an error.  Give a warning and</a>
<a name="ln2078">              // accept the words anyway.</a>
<a name="ln2079">              smsg(0, _(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2080">                   region);</a>
<a name="ln2081">            }</a>
<a name="ln2082">          } else {</a>
<a name="ln2083">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2084">          }</a>
<a name="ln2085">        }</a>
<a name="ln2086"> </a>
<a name="ln2087">        if (region_mask != 0) {</a>
<a name="ln2088">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2089">          p_-&gt;lp_slang = slang;</a>
<a name="ln2090">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2091"> </a>
<a name="ln2092">          use_midword(slang, wp);</a>
<a name="ln2093">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln2094">            nobreak = true;</a>
<a name="ln2095">          }</a>
<a name="ln2096">        }</a>
<a name="ln2097">      }</a>
<a name="ln2098">    }</a>
<a name="ln2099">  }</a>
<a name="ln2100"> </a>
<a name="ln2101">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2102">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2103">  // round 2: load second name in 'spellfile.</a>
<a name="ln2104">  // etc.</a>
<a name="ln2105">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2106">  for (round = 0; round == 0 || *spf != NUL; round++) {</a>
<a name="ln2107">    if (round == 0) {</a>
<a name="ln2108">      // Internal wordlist, if there is one.</a>
<a name="ln2109">      if (int_wordlist == NULL) {</a>
<a name="ln2110">        continue;</a>
<a name="ln2111">      }</a>
<a name="ln2112">      int_wordlist_spl(spf_name);</a>
<a name="ln2113">    } else {</a>
<a name="ln2114">      // One entry in 'spellfile'.</a>
<a name="ln2115">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2116">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2117"> </a>
<a name="ln2118">      // If it was already found above then skip it.</a>
<a name="ln2119">      for (c = 0; c &lt; ga.ga_len; c++) {</a>
<a name="ln2120">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2121">        if (p != NULL</a>
<a name="ln2122">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2123">          break;</a>
<a name="ln2124">        }</a>
<a name="ln2125">      }</a>
<a name="ln2126">      if (c &lt; ga.ga_len) {</a>
<a name="ln2127">        continue;</a>
<a name="ln2128">      }</a>
<a name="ln2129">    }</a>
<a name="ln2130"> </a>
<a name="ln2131">    // Check if it was loaded already.</a>
<a name="ln2132">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2133">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2134">          == kEqualFiles) {</a>
<a name="ln2135">        break;</a>
<a name="ln2136">      }</a>
<a name="ln2137">    }</a>
<a name="ln2138">    if (slang == NULL) {</a>
<a name="ln2139">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2140">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2141">      // use an arbitrary name.</a>
<a name="ln2142">      if (round == 0) {</a>
<a name="ln2143">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2144">      } else {</a>
<a name="ln2145">        xstrlcpy(lang, path_tail(spf_name), MAXWLEN + 1);</a>
<a name="ln2146">        p = vim_strchr(lang, '.');</a>
<a name="ln2147">        if (p != NULL) {</a>
<a name="ln2148">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2149">        }</a>
<a name="ln2150">      }</a>
<a name="ln2151">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2152"> </a>
<a name="ln2153">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2154">      // files also have this.</a>
<a name="ln2155">      if (slang != NULL &amp;&amp; nobreak) {</a>
<a name="ln2156">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2157">      }</a>
<a name="ln2158">    }</a>
<a name="ln2159">    if (slang != NULL) {</a>
<a name="ln2160">      region_mask = REGION_ALL;</a>
<a name="ln2161">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2162">        // find region in sl_regions</a>
<a name="ln2163">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2164">        if (c != REGION_ALL) {</a>
<a name="ln2165">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2166">        } else if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2167">          // This spell file is for other regions.</a>
<a name="ln2168">          region_mask = 0;</a>
<a name="ln2169">        }</a>
<a name="ln2170">      }</a>
<a name="ln2171"> </a>
<a name="ln2172">      if (region_mask != 0) {</a>
<a name="ln2173">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2174">        p_-&gt;lp_slang = slang;</a>
<a name="ln2175">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2176">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2177">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2178"> </a>
<a name="ln2179">        use_midword(slang, wp);</a>
<a name="ln2180">      }</a>
<a name="ln2181">    }</a>
<a name="ln2182">  }</a>
<a name="ln2183"> </a>
<a name="ln2184">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2185">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2186">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2187"> </a>
<a name="ln2188">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2189">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2190">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2191">  for (int i = 0; i &lt; ga.ga_len; i++) {</a>
<a name="ln2192">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2193"> </a>
<a name="ln2194">    // sound folding</a>
<a name="ln2195">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2196">      // language does sound folding itself</a>
<a name="ln2197">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2198">    } else {</a>
<a name="ln2199">      // find first similar language that does sound folding</a>
<a name="ln2200">      for (int j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2201">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2202">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2203">            &amp;&amp; strncmp(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2204">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2205">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2206">          break;</a>
<a name="ln2207">        }</a>
<a name="ln2208">      }</a>
<a name="ln2209">    }</a>
<a name="ln2210"> </a>
<a name="ln2211">    // REP items</a>
<a name="ln2212">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep)) {</a>
<a name="ln2213">      // language has REP items itself</a>
<a name="ln2214">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2215">    } else {</a>
<a name="ln2216">      // find first similar language that has REP items</a>
<a name="ln2217">      for (int j = 0; j &lt; ga.ga_len; j++) {</a>
<a name="ln2218">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2219">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2220">            &amp;&amp; strncmp(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2221">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2222">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2223">          break;</a>
<a name="ln2224">        }</a>
<a name="ln2225">      }</a>
<a name="ln2226">    }</a>
<a name="ln2227">  }</a>
<a name="ln2228">  redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln2229"> </a>
<a name="ln2230">theend:</a>
<a name="ln2231">  xfree(spl_copy);</a>
<a name="ln2232">  recursive = false;</a>
<a name="ln2233">  return ret_msg;</a>
<a name="ln2234">}</a>
<a name="ln2235"> </a>
<a name="ln2236">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2237">static void clear_midword(win_T *wp)</a>
<a name="ln2238">{</a>
<a name="ln2239">  CLEAR_FIELD(wp-&gt;w_s-&gt;b_spell_ismw);</a>
<a name="ln2240">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2241">}</a>
<a name="ln2242"> </a>
<a name="ln2243">/// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2244">/// They add up to any currently used midword characters.</a>
<a name="ln2245">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2246">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2247">{</a>
<a name="ln2248">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2249">    return;</a>
<a name="ln2250">  }</a>
<a name="ln2251"> </a>
<a name="ln2252">  for (char *p = lp-&gt;sl_midword; *p != NUL;) {</a>
<a name="ln2253">    const int c = utf_ptr2char(p);</a>
<a name="ln2254">    const int l = utfc_ptr2len(p);</a>
<a name="ln2255">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2256">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2257">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2258">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2259">      wp-&gt;w_s-&gt;b_spell_ismw_mb = xstrnsave(p, (size_t)l);</a>
<a name="ln2260">    } else {</a>
<a name="ln2261">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2262">      const int n = (int)strlen(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2263">      char *bp = xstrnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, (size_t)n + (size_t)l);</a>
<a name="ln2264">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2265">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2266">      xstrlcpy(bp + n, p, (size_t)l + 1);</a>
<a name="ln2267">    }</a>
<a name="ln2268">    p += l;</a>
<a name="ln2269">  }</a>
<a name="ln2270">}</a>
<a name="ln2271"> </a>
<a name="ln2272">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2273">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2274">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2275">static int find_region(const char *rp, const char *region)</a>
<a name="ln2276">{</a>
<a name="ln2277">  int i;</a>
<a name="ln2278"> </a>
<a name="ln2279">  for (i = 0;; i += 2) {</a>
<a name="ln2280">    if (rp[i] == NUL) {</a>
<a name="ln2281">      return REGION_ALL;</a>
<a name="ln2282">    }</a>
<a name="ln2283">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1]) {</a>
<a name="ln2284">      break;</a>
<a name="ln2285">    }</a>
<a name="ln2286">  }</a>
<a name="ln2287">  return i / 2;</a>
<a name="ln2288">}</a>
<a name="ln2289"> </a>
<a name="ln2290">/// Return case type of word:</a>
<a name="ln2291">/// w word       0</a>
<a name="ln2292">/// Word         WF_ONECAP</a>
<a name="ln2293">/// W WORD       WF_ALLCAP</a>
<a name="ln2294">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2295">///</a>
<a name="ln2296">/// @param[in]  word</a>
<a name="ln2297">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2298">///</a>
<a name="ln2299">/// @returns  Case type of word</a>
<a name="ln2300">int captype(const char *word, const char *end)</a>
<a name="ln2301">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2302">{</a>
<a name="ln2303">  const char *p;</a>
<a name="ln2304"> </a>
<a name="ln2305">  // find first letter</a>
<a name="ln2306">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2307">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2308">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2309">    }</a>
<a name="ln2310">  }</a>
<a name="ln2311">  int c = mb_ptr2char_adv(&amp;p);</a>
<a name="ln2312">  bool allcap;</a>
<a name="ln2313">  bool firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2314">  bool past_second = false;              // past second word char</a>
<a name="ln2315"> </a>
<a name="ln2316">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2317">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2318">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2319">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2320">      c = utf_ptr2char(p);</a>
<a name="ln2321">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2322">        // UUl -&gt; KEEPCAP</a>
<a name="ln2323">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2324">          return WF_KEEPCAP;</a>
<a name="ln2325">        }</a>
<a name="ln2326">        allcap = false;</a>
<a name="ln2327">      } else if (!allcap) {</a>
<a name="ln2328">        // UlU -&gt; KEEPCAP</a>
<a name="ln2329">        return WF_KEEPCAP;</a>
<a name="ln2330">      }</a>
<a name="ln2331">      past_second = true;</a>
<a name="ln2332">    }</a>
<a name="ln2333">  }</a>
<a name="ln2334"> </a>
<a name="ln2335">  if (allcap) {</a>
<a name="ln2336">    return WF_ALLCAP;</a>
<a name="ln2337">  }</a>
<a name="ln2338">  if (firstcap) {</a>
<a name="ln2339">    return WF_ONECAP;</a>
<a name="ln2340">  }</a>
<a name="ln2341">  return 0;</a>
<a name="ln2342">}</a>
<a name="ln2343"> </a>
<a name="ln2344">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2345">void spell_delete_wordlist(void)</a>
<a name="ln2346">{</a>
<a name="ln2347">  if (int_wordlist == NULL) {</a>
<a name="ln2348">    return;</a>
<a name="ln2349">  }</a>
<a name="ln2350"> </a>
<a name="ln2351">  char fname[MAXPATHL] = { 0 };</a>
<a name="ln2352">  os_remove(int_wordlist);</a>
<a name="ln2353">  int_wordlist_spl(fname);</a>
<a name="ln2354">  os_remove(fname);</a>
<a name="ln2355">  XFREE_CLEAR(int_wordlist);</a>
<a name="ln2356">}</a>
<a name="ln2357"> </a>
<a name="ln2358">// Free all languages.</a>
<a name="ln2359">void spell_free_all(void)</a>
<a name="ln2360">{</a>
<a name="ln2361">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2362">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2363">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2364">  }</a>
<a name="ln2365"> </a>
<a name="ln2366">  while (first_lang != NULL) {</a>
<a name="ln2367">    slang_T *slang = first_lang;</a>
<a name="ln2368">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2369">    slang_free(slang);</a>
<a name="ln2370">  }</a>
<a name="ln2371"> </a>
<a name="ln2372">  spell_delete_wordlist();</a>
<a name="ln2373"> </a>
<a name="ln2374">  XFREE_CLEAR(repl_to);</a>
<a name="ln2375">  XFREE_CLEAR(repl_from);</a>
<a name="ln2376">}</a>
<a name="ln2377"> </a>
<a name="ln2378">// Clear all spelling tables and reload them.</a>
<a name="ln2379">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2380">void spell_reload(void)</a>
<a name="ln2381">{</a>
<a name="ln2382">  // Initialize the table for spell_iswordp().</a>
<a name="ln2383">  init_spell_chartab();</a>
<a name="ln2384"> </a>
<a name="ln2385">  // Unload all allocated memory.</a>
<a name="ln2386">  spell_free_all();</a>
<a name="ln2387"> </a>
<a name="ln2388">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2389">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2390">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2391">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2392">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2393">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2394">        (void)parse_spelllang(wp);</a>
<a name="ln2395">        break;</a>
<a name="ln2396">      }</a>
<a name="ln2397">    }</a>
<a name="ln2398">  }</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2402">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2403">// use.</a>
<a name="ln2404">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2405">// NULL and there is no undo info.</a>
<a name="ln2406">buf_T *open_spellbuf(void)</a>
<a name="ln2407">{</a>
<a name="ln2408">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2409"> </a>
<a name="ln2410">  buf-&gt;b_spell = true;</a>
<a name="ln2411">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2412">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2413">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2414">  }</a>
<a name="ln2415">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2416"> </a>
<a name="ln2417">  return buf;</a>
<a name="ln2418">}</a>
<a name="ln2419"> </a>
<a name="ln2420">// Close the buffer used for spell info.</a>
<a name="ln2421">void close_spellbuf(buf_T *buf)</a>
<a name="ln2422">{</a>
<a name="ln2423">  if (buf == NULL) {</a>
<a name="ln2424">    return;</a>
<a name="ln2425">  }</a>
<a name="ln2426"> </a>
<a name="ln2427">  ml_close(buf, true);</a>
<a name="ln2428">  xfree(buf);</a>
<a name="ln2429">}</a>
<a name="ln2430"> </a>
<a name="ln2431">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2432">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2433">{</a>
<a name="ln2434">  // Init everything to false (zero).</a>
<a name="ln2435">  CLEAR_FIELD(sp-&gt;st_isw);</a>
<a name="ln2436">  CLEAR_FIELD(sp-&gt;st_isu);</a>
<a name="ln2437"> </a>
<a name="ln2438">  for (int i = 0; i &lt; 256; i++) {</a>
<a name="ln2439">    sp-&gt;st_fold[i] = (uint8_t)i;</a>
<a name="ln2440">    sp-&gt;st_upper[i] = (uint8_t)i;</a>
<a name="ln2441">  }</a>
<a name="ln2442"> </a>
<a name="ln2443">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2444">  // that is done separately.</a>
<a name="ln2445">  for (int i = '0'; i &lt;= '9'; i++) {</a>
<a name="ln2446">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2447">  }</a>
<a name="ln2448">  for (int i = 'A'; i &lt;= 'Z'; i++) {</a>
<a name="ln2449">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2450">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2451">    sp-&gt;st_fold[i] = (uint8_t)(i + 0x20);</a>
<a name="ln2452">  }</a>
<a name="ln2453">  for (int i = 'a'; i &lt;= 'z'; i++) {</a>
<a name="ln2454">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2455">    sp-&gt;st_upper[i] = (uint8_t)(i - 0x20);</a>
<a name="ln2456">  }</a>
<a name="ln2457">}</a>
<a name="ln2458"> </a>
<a name="ln2459">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2460">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2461">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2462">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2463">void init_spell_chartab(void)</a>
<a name="ln2464">{</a>
<a name="ln2465">  did_set_spelltab = false;</a>
<a name="ln2466">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2467">  for (int i = 128; i &lt; 256; i++) {</a>
<a name="ln2468">    int f = utf_fold(i);</a>
<a name="ln2469">    int u = mb_toupper(i);</a>
<a name="ln2470"> </a>
<a name="ln2471">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2472">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2473">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2474">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2475">    // value for utf-8 to avoid this.</a>
<a name="ln2476">    spelltab.st_fold[i] = (f &lt; 256) ? (uint8_t)f : (uint8_t)i;</a>
<a name="ln2477">    spelltab.st_upper[i] = (u &lt; 256) ? (uint8_t)u : (uint8_t)i;</a>
<a name="ln2478">  }</a>
<a name="ln2479">}</a>
<a name="ln2480"> </a>
<a name="ln2481">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2482">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2483">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2484">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2485">///</a>
<a name="ln2486">/// @param wp Buffer used.</a>
<a name="ln2487">bool spell_iswordp(const char *p, const win_T *wp)</a>
<a name="ln2488">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2489">{</a>
<a name="ln2490">  const int l = utfc_ptr2len(p);</a>
<a name="ln2491">  const char *s = p;</a>
<a name="ln2492">  if (l == 1) {</a>
<a name="ln2493">    // be quick for ASCII</a>
<a name="ln2494">    if (wp-&gt;w_s-&gt;b_spell_ismw[(uint8_t)(*p)]) {</a>
<a name="ln2495">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2496">    }</a>
<a name="ln2497">  } else {</a>
<a name="ln2498">    int c = utf_ptr2char(p);</a>
<a name="ln2499">    if (c &lt; 256</a>
<a name="ln2500">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2501">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2502">           &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2503">      s = p + l;</a>
<a name="ln2504">    }</a>
<a name="ln2505">  }</a>
<a name="ln2506"> </a>
<a name="ln2507">  int c = utf_ptr2char(s);</a>
<a name="ln2508">  if (c &gt; 255) {</a>
<a name="ln2509">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2510">  }</a>
<a name="ln2511">  return spelltab.st_isw[c];</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2515">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2516">bool spell_iswordp_nmw(const char *p, win_T *wp)</a>
<a name="ln2517">{</a>
<a name="ln2518">  int c = utf_ptr2char(p);</a>
<a name="ln2519">  if (c &gt; 255) {</a>
<a name="ln2520">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2521">  }</a>
<a name="ln2522">  return spelltab.st_isw[c];</a>
<a name="ln2523">}</a>
<a name="ln2524"> </a>
<a name="ln2525">// Returns true if word class indicates a word character.</a>
<a name="ln2526">// Only for characters above 255.</a>
<a name="ln2527">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2528">// See also utf_class() in mbyte.c.</a>
<a name="ln2529">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2530">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2531">{</a>
<a name="ln2532">  if (wp-&gt;w_s-&gt;b_cjk) {</a>
<a name="ln2533">    // East Asian characters are not considered word characters.</a>
<a name="ln2534">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2535">  }</a>
<a name="ln2536">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2537">}</a>
<a name="ln2538"> </a>
<a name="ln2539">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2540">// Wide version of spell_iswordp().</a>
<a name="ln2541">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2542">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2543">{</a>
<a name="ln2544">  const int *s;</a>
<a name="ln2545"> </a>
<a name="ln2546">  if (*p &lt;</a>
<a name="ln2547">      256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p] : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2548">                                         &amp;&amp; vim_strchr(wp-&gt;w_s-&gt;b_spell_ismw_mb,</a>
<a name="ln2549">                                                       *p) != NULL)) {</a>
<a name="ln2550">    s = p + 1;</a>
<a name="ln2551">  } else {</a>
<a name="ln2552">    s = p;</a>
<a name="ln2553">  }</a>
<a name="ln2554"> </a>
<a name="ln2555">  if (*s &gt; 255) {</a>
<a name="ln2556">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2557">  }</a>
<a name="ln2558">  return spelltab.st_isw[*s];</a>
<a name="ln2559">}</a>
<a name="ln2560"> </a>
<a name="ln2561">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2562">// Uses the character definitions from the .spl file.</a>
<a name="ln2563">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2564">// Returns FAIL when something wrong.</a>
<a name="ln2565">int spell_casefold(const win_T *wp, const char *str, int len, char *buf, int buflen)</a>
<a name="ln2566">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2567">{</a>
<a name="ln2568">  if (len &gt;= buflen) {</a>
<a name="ln2569">    buf[0] = NUL;</a>
<a name="ln2570">    return FAIL;                // result will not fit</a>
<a name="ln2571">  }</a>
<a name="ln2572"> </a>
<a name="ln2573">  int outi = 0;</a>
<a name="ln2574"> </a>
<a name="ln2575">  // Fold one character at a time.</a>
<a name="ln2576">  for (const char *p = str; p &lt; str + len;) {</a>
<a name="ln2577">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2578">      buf[outi] = NUL;</a>
<a name="ln2579">      return FAIL;</a>
<a name="ln2580">    }</a>
<a name="ln2581">    int c = mb_cptr2char_adv(&amp;p);</a>
<a name="ln2582"> </a>
<a name="ln2583">    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except</a>
<a name="ln2584">    // when it is the last character in a word, then it folds to</a>
<a name="ln2585">    // 0x03C2.</a>
<a name="ln2586">    if (c == 0x03a3 || c == 0x03c2) {</a>
<a name="ln2587">      if (p == str + len || !spell_iswordp(p, wp)) {</a>
<a name="ln2588">        c = 0x03c2;</a>
<a name="ln2589">      } else {</a>
<a name="ln2590">        c = 0x03c3;</a>
<a name="ln2591">      }</a>
<a name="ln2592">    } else {</a>
<a name="ln2593">      c = SPELL_TOFOLD(c);</a>
<a name="ln2594">    }</a>
<a name="ln2595"> </a>
<a name="ln2596">    outi += utf_char2bytes(c, buf + outi);</a>
<a name="ln2597">  }</a>
<a name="ln2598">  buf[outi] = NUL;</a>
<a name="ln2599"> </a>
<a name="ln2600">  return OK;</a>
<a name="ln2601">}</a>
<a name="ln2602"> </a>
<a name="ln2603">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln2604">// capital.  This uses 'spellcapcheck' of the buffer in window &quot;wp&quot;.</a>
<a name="ln2605">bool check_need_cap(win_T *wp, linenr_T lnum, colnr_T col)</a>
<a name="ln2606">{</a>
<a name="ln2607">  if (wp-&gt;w_s-&gt;b_cap_prog == NULL) {</a>
<a name="ln2608">    return false;</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  bool need_cap = false;</a>
<a name="ln2612">  char *line = col ? ml_get_buf(wp-&gt;w_buffer, lnum) : NULL;</a>
<a name="ln2613">  char *line_copy = NULL;</a>
<a name="ln2614">  colnr_T endcol = 0;</a>
<a name="ln2615">  if (col == 0 || getwhitecols(line) &gt;= col) {</a>
<a name="ln2616">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln2617">    // ends there.</a>
<a name="ln2618">    if (lnum == 1) {</a>
<a name="ln2619">      need_cap = true;</a>
<a name="ln2620">    } else {</a>
<a name="ln2621">      line = ml_get_buf(wp-&gt;w_buffer, lnum - 1);</a>
<a name="ln2622">      if (*skipwhite(line) == NUL) {</a>
<a name="ln2623">        need_cap = true;</a>
<a name="ln2624">      } else {</a>
<a name="ln2625">        // Append a space in place of the line break.</a>
<a name="ln2626">        line_copy = concat_str(line, &quot; &quot;);</a>
<a name="ln2627">        line = line_copy;</a>
<a name="ln2628">        endcol = (colnr_T)strlen(line);</a>
<a name="ln2629">      }</a>
<a name="ln2630">    }</a>
<a name="ln2631">  } else {</a>
<a name="ln2632">    endcol = col;</a>
<a name="ln2633">  }</a>
<a name="ln2634"> </a>
<a name="ln2635">  if (endcol &gt; 0) {</a>
<a name="ln2636">    // Check if sentence ends before the bad word.</a>
<a name="ln2637">    regmatch_T regmatch = {</a>
<a name="ln2638">      .regprog = wp-&gt;w_s-&gt;b_cap_prog,</a>
<a name="ln2639">      .rm_ic = false</a>
<a name="ln2640">    };</a>
<a name="ln2641">    char *p = line + endcol;</a>
<a name="ln2642">    while (true) {</a>
<a name="ln2643">      MB_PTR_BACK(line, p);</a>
<a name="ln2644">      if (p == line || spell_iswordp_nmw(p, wp)) {</a>
<a name="ln2645">        break;</a>
<a name="ln2646">      }</a>
<a name="ln2647">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln2648">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln2649">        need_cap = true;</a>
<a name="ln2650">        break;</a>
<a name="ln2651">      }</a>
<a name="ln2652">    }</a>
<a name="ln2653">    wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln2654">  }</a>
<a name="ln2655"> </a>
<a name="ln2656">  xfree(line_copy);</a>
<a name="ln2657"> </a>
<a name="ln2658">  return need_cap;</a>
<a name="ln2659">}</a>
<a name="ln2660"> </a>
<a name="ln2661">// &quot;:spellrepall&quot;</a>
<a name="ln2662">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln2663">{</a>
<a name="ln2664">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln2665">  bool save_ws = p_ws;</a>
<a name="ln2666">  linenr_T prev_lnum = 0;</a>
<a name="ln2667"> </a>
<a name="ln2668">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln2669">    emsg(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln2670">    return;</a>
<a name="ln2671">  }</a>
<a name="ln2672">  const size_t repl_from_len = strlen(repl_from);</a>
<a name="ln2673">  const size_t repl_to_len = strlen(repl_to);</a>
<a name="ln2674">  const int addlen = (int)(repl_to_len - repl_from_len);</a>
<a name="ln2675"> </a>
<a name="ln2676">  const size_t frompatlen = repl_from_len + 7;</a>
<a name="ln2677">  char *frompat = xmalloc(frompatlen);</a>
<a name="ln2678">  snprintf(frompat, frompatlen, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln2679">  p_ws = false;</a>
<a name="ln2680"> </a>
<a name="ln2681">  sub_nsubs = 0;</a>
<a name="ln2682">  sub_nlines = 0;</a>
<a name="ln2683">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln2684">  while (!got_int) {</a>
<a name="ln2685">    if (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0</a>
<a name="ln2686">        || u_save_cursor() == FAIL) {</a>
<a name="ln2687">      break;</a>
<a name="ln2688">    }</a>
<a name="ln2689"> </a>
<a name="ln2690">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln2691">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln2692">    char *line = get_cursor_line_ptr();</a>
<a name="ln2693">    if (addlen &lt;= 0</a>
<a name="ln2694">        || strncmp(line + curwin-&gt;w_cursor.col, repl_to, repl_to_len) != 0) {</a>
<a name="ln2695">      char *p = xmalloc(strlen(line) + (size_t)addlen + 1);</a>
<a name="ln2696">      memmove(p, line, (size_t)curwin-&gt;w_cursor.col);</a>
<a name="ln2697">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln2698">      STRCAT(p, line + curwin-&gt;w_cursor.col + repl_from_len);</a>
<a name="ln2699">      ml_replace(curwin-&gt;w_cursor.lnum, p, false);</a>
<a name="ln2700">      inserted_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col,</a>
<a name="ln2701">                     (int)repl_from_len, (int)repl_to_len);</a>
<a name="ln2702"> </a>
<a name="ln2703">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln2704">        sub_nlines++;</a>
<a name="ln2705">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2706">      }</a>
<a name="ln2707">      sub_nsubs++;</a>
<a name="ln2708">    }</a>
<a name="ln2709">    curwin-&gt;w_cursor.col += (colnr_T)repl_to_len;</a>
<a name="ln2710">  }</a>
<a name="ln2711"> </a>
<a name="ln2712">  p_ws = save_ws;</a>
<a name="ln2713">  curwin-&gt;w_cursor = pos;</a>
<a name="ln2714">  xfree(frompat);</a>
<a name="ln2715"> </a>
<a name="ln2716">  if (sub_nsubs == 0) {</a>
<a name="ln2717">    semsg(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln2718">  } else {</a>
<a name="ln2719">    do_sub_msg(false);</a>
<a name="ln2720">  }</a>
<a name="ln2721">}</a>
<a name="ln2722"> </a>
<a name="ln2723">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln2724">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln2725">/// The result is NUL terminated.</a>
<a name="ln2726">///</a>
<a name="ln2727">/// @param[in]  word  source string to copy</a>
<a name="ln2728">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln2729">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln2730">void onecap_copy(const char *word, char *wcopy, bool upper)</a>
<a name="ln2731">{</a>
<a name="ln2732">  const char *p = word;</a>
<a name="ln2733">  int c = mb_cptr2char_adv(&amp;p);</a>
<a name="ln2734">  if (upper) {</a>
<a name="ln2735">    c = SPELL_TOUPPER(c);</a>
<a name="ln2736">  } else {</a>
<a name="ln2737">    c = SPELL_TOFOLD(c);</a>
<a name="ln2738">  }</a>
<a name="ln2739">  int l = utf_char2bytes(c, wcopy);</a>
<a name="ln2740">  xstrlcpy(wcopy + l, p, (size_t)(MAXWLEN - l));</a>
<a name="ln2741">}</a>
<a name="ln2742"> </a>
<a name="ln2743">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln2744">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln2745">void allcap_copy(const char *word, char *wcopy)</a>
<a name="ln2746">{</a>
<a name="ln2747">  char *d = wcopy;</a>
<a name="ln2748">  for (const char *s = word; *s != NUL;) {</a>
<a name="ln2749">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2750"> </a>
<a name="ln2751">    if (c == 0xdf) {</a>
<a name="ln2752">      c = 'S';</a>
<a name="ln2753">      if (d - wcopy &gt;= MAXWLEN - 1) {</a>
<a name="ln2754">        break;</a>
<a name="ln2755">      }</a>
<a name="ln2756">      *d++ = (char)c;</a>
<a name="ln2757">    } else {</a>
<a name="ln2758">      c = SPELL_TOUPPER(c);</a>
<a name="ln2759">    }</a>
<a name="ln2760"> </a>
<a name="ln2761">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln2762">      break;</a>
<a name="ln2763">    }</a>
<a name="ln2764">    d += utf_char2bytes(c, d);</a>
<a name="ln2765">  }</a>
<a name="ln2766">  *d = NUL;</a>
<a name="ln2767">}</a>
<a name="ln2768"> </a>
<a name="ln2769">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln2770">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln2771">int nofold_len(char *fword, int flen, char *word)</a>
<a name="ln2772">{</a>
<a name="ln2773">  char *p;</a>
<a name="ln2774">  int i = 0;</a>
<a name="ln2775"> </a>
<a name="ln2776">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln2777">    i++;</a>
<a name="ln2778">  }</a>
<a name="ln2779">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln2780">    i--;</a>
<a name="ln2781">  }</a>
<a name="ln2782">  return (int)(p - word);</a>
<a name="ln2783">}</a>
<a name="ln2784"> </a>
<a name="ln2785">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln2786">void make_case_word(char *fword, char *cword, int flags)</a>
<a name="ln2787">{</a>
<a name="ln2788">  if (flags &amp; WF_ALLCAP) {</a>
<a name="ln2789">    // Make it all upper-case</a>
<a name="ln2790">    allcap_copy(fword, cword);</a>
<a name="ln2791">  } else if (flags &amp; WF_ONECAP) {</a>
<a name="ln2792">    // Make the first letter upper-case</a>
<a name="ln2793">    onecap_copy(fword, cword, true);</a>
<a name="ln2794">  } else {</a>
<a name="ln2795">    // Use goodword as-is.</a>
<a name="ln2796">    STRCPY(cword, fword);</a>
<a name="ln2797">  }</a>
<a name="ln2798">}</a>
<a name="ln2799"> </a>
<a name="ln2800">/// Soundfold a string, for soundfold()</a>
<a name="ln2801">///</a>
<a name="ln2802">/// @param[in]  word  Word to soundfold.</a>
<a name="ln2803">///</a>
<a name="ln2804">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln2805">///                     copy of the input string if soundfolding is not</a>
<a name="ln2806">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln2807">char *eval_soundfold(const char *const word)</a>
<a name="ln2808">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2809">{</a>
<a name="ln2810">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2811">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln2812">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln2813">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln2814">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2815">        // soundfold the word</a>
<a name="ln2816">        char sound[MAXWLEN];</a>
<a name="ln2817">        spell_soundfold(lp-&gt;lp_slang, (char *)word, false, sound);</a>
<a name="ln2818">        return xstrdup(sound);</a>
<a name="ln2819">      }</a>
<a name="ln2820">    }</a>
<a name="ln2821">  }</a>
<a name="ln2822"> </a>
<a name="ln2823">  // No language with sound folding, return word as-is.</a>
<a name="ln2824">  return xstrdup(word);</a>
<a name="ln2825">}</a>
<a name="ln2826"> </a>
<a name="ln2827">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln2828">///</a>
<a name="ln2829">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln2830">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln2831">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln2832">/// Erikson.</a>
<a name="ln2833">///</a>
<a name="ln2834">/// We support two methods:</a>
<a name="ln2835">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln2836">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln2837">///</a>
<a name="ln2838">/// @param[in]  slang</a>
<a name="ln2839">/// @param[in]  inword  word to soundfold</a>
<a name="ln2840">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln2841">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln2842">void spell_soundfold(slang_T *slang, char *inword, bool folded, char *res)</a>
<a name="ln2843">{</a>
<a name="ln2844">  if (slang-&gt;sl_sofo) {</a>
<a name="ln2845">    // SOFOFROM and SOFOTO used</a>
<a name="ln2846">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln2847">  } else {</a>
<a name="ln2848">    char fword[MAXWLEN];</a>
<a name="ln2849">    char *word;</a>
<a name="ln2850">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln2851">    if (folded) {</a>
<a name="ln2852">      word = inword;</a>
<a name="ln2853">    } else {</a>
<a name="ln2854">      (void)spell_casefold(curwin, inword, (int)strlen(inword), fword, MAXWLEN);</a>
<a name="ln2855">      word = fword;</a>
<a name="ln2856">    }</a>
<a name="ln2857"> </a>
<a name="ln2858">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln2859">  }</a>
<a name="ln2860">}</a>
<a name="ln2861"> </a>
<a name="ln2862">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln2863">// SOFOTO lines.</a>
<a name="ln2864">static void spell_soundfold_sofo(slang_T *slang, const char *inword, char *res)</a>
<a name="ln2865">{</a>
<a name="ln2866">  int ri = 0;</a>
<a name="ln2867"> </a>
<a name="ln2868">  int prevc = 0;</a>
<a name="ln2869"> </a>
<a name="ln2870">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln2871">  // 255, sl_sal the rest.</a>
<a name="ln2872">  for (const char *s = inword; *s != NUL;) {</a>
<a name="ln2873">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2874">    if (utf_class(c) == 0) {</a>
<a name="ln2875">      c = ' ';</a>
<a name="ln2876">    } else if (c &lt; 256) {</a>
<a name="ln2877">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln2878">    } else {</a>
<a name="ln2879">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln2880">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln2881">        c = NUL;</a>
<a name="ln2882">      } else {</a>
<a name="ln2883">        while (true) {                // find &quot;c&quot; in the list</a>
<a name="ln2884">          if (*ip == 0) {             // not found</a>
<a name="ln2885">            c = NUL;</a>
<a name="ln2886">            break;</a>
<a name="ln2887">          }</a>
<a name="ln2888">          if (*ip == c) {             // match!</a>
<a name="ln2889">            c = ip[1];</a>
<a name="ln2890">            break;</a>
<a name="ln2891">          }</a>
<a name="ln2892">          ip += 2;</a>
<a name="ln2893">        }</a>
<a name="ln2894">      }</a>
<a name="ln2895">    }</a>
<a name="ln2896"> </a>
<a name="ln2897">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln2898">      ri += utf_char2bytes(c, res + ri);</a>
<a name="ln2899">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln2900">        break;</a>
<a name="ln2901">      }</a>
<a name="ln2902">      prevc = c;</a>
<a name="ln2903">    }</a>
<a name="ln2904">  }</a>
<a name="ln2905"> </a>
<a name="ln2906">  res[ri] = NUL;</a>
<a name="ln2907">}</a>
<a name="ln2908"> </a>
<a name="ln2909">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln2910">// Multi-byte version of spell_soundfold().</a>
<a name="ln2911">static void spell_soundfold_wsal(slang_T *slang, const char *inword, char *res)</a>
<a name="ln2912">{</a>
<a name="ln2913">  salitem_T *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln2914">  int word[MAXWLEN] = { 0 };</a>
<a name="ln2915">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln2916">  int *ws;</a>
<a name="ln2917">  int *pf;</a>
<a name="ln2918">  int j, z;</a>
<a name="ln2919">  int reslen;</a>
<a name="ln2920">  int k = 0;</a>
<a name="ln2921">  int k0;</a>
<a name="ln2922">  int n0;</a>
<a name="ln2923">  int pri;</a>
<a name="ln2924">  int p0 = -333;</a>
<a name="ln2925">  int c0;</a>
<a name="ln2926">  bool did_white = false;</a>
<a name="ln2927"> </a>
<a name="ln2928">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln2929">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln2930">  // But keep white space.</a>
<a name="ln2931">  int wordlen = 0;</a>
<a name="ln2932">  for (const char *s = inword; *s != NUL;) {</a>
<a name="ln2933">    const char *t = s;</a>
<a name="ln2934">    int c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln2935">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln2936">      if (utf_class(c) == 0) {</a>
<a name="ln2937">        if (did_white) {</a>
<a name="ln2938">          continue;</a>
<a name="ln2939">        }</a>
<a name="ln2940">        c = ' ';</a>
<a name="ln2941">        did_white = true;</a>
<a name="ln2942">      } else {</a>
<a name="ln2943">        did_white = false;</a>
<a name="ln2944">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln2945">          continue;</a>
<a name="ln2946">        }</a>
<a name="ln2947">      }</a>
<a name="ln2948">    }</a>
<a name="ln2949">    word[wordlen++] = c;</a>
<a name="ln2950">  }</a>
<a name="ln2951">  word[wordlen] = NUL;</a>
<a name="ln2952"> </a>
<a name="ln2953">  int c;</a>
<a name="ln2954">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln2955">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln2956">  // Changed to keep spaces.</a>
<a name="ln2957">  int i = reslen = z = 0;</a>
<a name="ln2958">  while ((c = word[i]) != NUL) {</a>
<a name="ln2959">    // Start with the first rule that has the character in the word.</a>
<a name="ln2960">    int n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln2961">    int z0 = 0;</a>
<a name="ln2962"> </a>
<a name="ln2963">    if (n &gt;= 0) {</a>
<a name="ln2964">      // Check all rules for the same index byte.</a>
<a name="ln2965">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln2966">      // (c &amp; 0xff) is NUL.</a>
<a name="ln2967">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln2968">           &amp;&amp; ws[0] != NUL; n++) {</a>
<a name="ln2969">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln2970">        // entries are less than three chars, optimize for that.</a>
<a name="ln2971">        if (c != ws[0]) {</a>
<a name="ln2972">          continue;</a>
<a name="ln2973">        }</a>
<a name="ln2974">        k = smp[n].sm_leadlen;</a>
<a name="ln2975">        if (k &gt; 1) {</a>
<a name="ln2976">          if (word[i + 1] != ws[1]) {</a>
<a name="ln2977">            continue;</a>
<a name="ln2978">          }</a>
<a name="ln2979">          if (k &gt; 2) {</a>
<a name="ln2980">            for (j = 2; j &lt; k; j++) {</a>
<a name="ln2981">              if (word[i + j] != ws[j]) {</a>
<a name="ln2982">                break;</a>
<a name="ln2983">              }</a>
<a name="ln2984">            }</a>
<a name="ln2985">            if (j &lt; k) {</a>
<a name="ln2986">              continue;</a>
<a name="ln2987">            }</a>
<a name="ln2988">          }</a>
<a name="ln2989">        }</a>
<a name="ln2990"> </a>
<a name="ln2991">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln2992">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln2993">          while (*pf != NUL &amp;&amp; *pf != word[i + k]) {</a>
<a name="ln2994">            pf++;</a>
<a name="ln2995">          }</a>
<a name="ln2996">          if (*pf == NUL) {</a>
<a name="ln2997">            continue;</a>
<a name="ln2998">          }</a>
<a name="ln2999">          k++;</a>
<a name="ln3000">        }</a>
<a name="ln3001">        char *s = smp[n].sm_rules;</a>
<a name="ln3002">        pri = 5;            // default priority</a>
<a name="ln3003"> </a>
<a name="ln3004">        p0 = (uint8_t)(*s);</a>
<a name="ln3005">        k0 = k;</a>
<a name="ln3006">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln3007">          k--;</a>
<a name="ln3008">          s++;</a>
<a name="ln3009">        }</a>
<a name="ln3010">        if (*s == '&lt;') {</a>
<a name="ln3011">          s++;</a>
<a name="ln3012">        }</a>
<a name="ln3013">        if (ascii_isdigit(*s)) {</a>
<a name="ln3014">          // determine priority</a>
<a name="ln3015">          pri = (uint8_t)(*s) - '0';</a>
<a name="ln3016">          s++;</a>
<a name="ln3017">        }</a>
<a name="ln3018">        if (*s == '^' &amp;&amp; *(s + 1) == '^') {</a>
<a name="ln3019">          s++;</a>
<a name="ln3020">        }</a>
<a name="ln3021"> </a>
<a name="ln3022">        if (*s == NUL</a>
<a name="ln3023">            || (*s == '^'</a>
<a name="ln3024">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln3025">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln3026">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln3027">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln3028">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln3029">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln3030">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln3031">          // search for followup rules, if:</a>
<a name="ln3032">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln3033">          c0 = word[i + k - 1];</a>
<a name="ln3034">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln3035"> </a>
<a name="ln3036">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln3037">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln3038">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln3039">            // all entries with the same index byte.</a>
<a name="ln3040">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln3041">                 == (c0 &amp; 0xff); n0++) {</a>
<a name="ln3042">              // Quickly skip entries that don't match the word.</a>
<a name="ln3043">              if (c0 != ws[0]) {</a>
<a name="ln3044">                continue;</a>
<a name="ln3045">              }</a>
<a name="ln3046">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln3047">              if (k0 &gt; 1) {</a>
<a name="ln3048">                if (word[i + k] != ws[1]) {</a>
<a name="ln3049">                  continue;</a>
<a name="ln3050">                }</a>
<a name="ln3051">                if (k0 &gt; 2) {</a>
<a name="ln3052">                  pf = word + i + k + 1;</a>
<a name="ln3053">                  for (j = 2; j &lt; k0; j++) {</a>
<a name="ln3054">                    if (*pf++ != ws[j]) {</a>
<a name="ln3055">                      break;</a>
<a name="ln3056">                    }</a>
<a name="ln3057">                  }</a>
<a name="ln3058">                  if (j &lt; k0) {</a>
<a name="ln3059">                    continue;</a>
<a name="ln3060">                  }</a>
<a name="ln3061">                }</a>
<a name="ln3062">              }</a>
<a name="ln3063">              k0 += k - 1;</a>
<a name="ln3064"> </a>
<a name="ln3065">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln3066">                // Check for match with one of the chars in</a>
<a name="ln3067">                // &quot;sm_oneof&quot;.</a>
<a name="ln3068">                while (*pf != NUL &amp;&amp; *pf != word[i + k0]) {</a>
<a name="ln3069">                  pf++;</a>
<a name="ln3070">                }</a>
<a name="ln3071">                if (*pf == NUL) {</a>
<a name="ln3072">                  continue;</a>
<a name="ln3073">                }</a>
<a name="ln3074">                k0++;</a>
<a name="ln3075">              }</a>
<a name="ln3076"> </a>
<a name="ln3077">              p0 = 5;</a>
<a name="ln3078">              s = smp[n0].sm_rules;</a>
<a name="ln3079">              while (*s == '-') {</a>
<a name="ln3080">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln3081">                // &quot;if (k0 == k)&quot;</a>
<a name="ln3082">                s++;</a>
<a name="ln3083">              }</a>
<a name="ln3084">              if (*s == '&lt;') {</a>
<a name="ln3085">                s++;</a>
<a name="ln3086">              }</a>
<a name="ln3087">              if (ascii_isdigit(*s)) {</a>
<a name="ln3088">                p0 = (uint8_t)(*s) - '0';</a>
<a name="ln3089">                s++;</a>
<a name="ln3090">              }</a>
<a name="ln3091"> </a>
<a name="ln3092">              if (*s == NUL</a>
<a name="ln3093">                  // *s == '^' cuts</a>
<a name="ln3094">                  || (*s == '$'</a>
<a name="ln3095">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln3096">                                          curwin))) {</a>
<a name="ln3097">                if (k0 == k) {</a>
<a name="ln3098">                  // this is just a piece of the string</a>
<a name="ln3099">                  continue;</a>
<a name="ln3100">                }</a>
<a name="ln3101"> </a>
<a name="ln3102">                if (p0 &lt; pri) {</a>
<a name="ln3103">                  // priority too low</a>
<a name="ln3104">                  continue;</a>
<a name="ln3105">                }</a>
<a name="ln3106">                // rule fits; stop search</a>
<a name="ln3107">                break;</a>
<a name="ln3108">              }</a>
<a name="ln3109">            }</a>
<a name="ln3110"> </a>
<a name="ln3111">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln3112">                == (c0 &amp; 0xff)) {</a>
<a name="ln3113">              continue;</a>
<a name="ln3114">            }</a>
<a name="ln3115">          }</a>
<a name="ln3116"> </a>
<a name="ln3117">          // replace string</a>
<a name="ln3118">          ws = smp[n].sm_to_w;</a>
<a name="ln3119">          s = smp[n].sm_rules;</a>
<a name="ln3120">          p0 = (vim_strchr(s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln3121">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln3122">            // rule with '&lt;' is used</a>
<a name="ln3123">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln3124">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln3125">                    || wres[reslen - 1] == *ws)) {</a>
<a name="ln3126">              reslen--;</a>
<a name="ln3127">            }</a>
<a name="ln3128">            z0 = 1;</a>
<a name="ln3129">            z = 1;</a>
<a name="ln3130">            k0 = 0;</a>
<a name="ln3131">            if (ws != NULL) {</a>
<a name="ln3132">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln3133">                word[i + k0] = *ws;</a>
<a name="ln3134">                k0++;</a>
<a name="ln3135">                ws++;</a>
<a name="ln3136">              }</a>
<a name="ln3137">            }</a>
<a name="ln3138">            if (k &gt; k0) {</a>
<a name="ln3139">              memmove(word + i + k0, word + i + k, sizeof(int) * (size_t)(wordlen - (i + k) + 1));</a>
<a name="ln3140">            }</a>
<a name="ln3141"> </a>
<a name="ln3142">            // new &quot;actual letter&quot;</a>
<a name="ln3143">            c = word[i];</a>
<a name="ln3144">          } else {</a>
<a name="ln3145">            // no '&lt;' rule used</a>
<a name="ln3146">            i += k - 1;</a>
<a name="ln3147">            z = 0;</a>
<a name="ln3148">            if (ws != NULL) {</a>
<a name="ln3149">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln3150">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln3151">                if (reslen == 0 || wres[reslen - 1] != *ws) {</a>
<a name="ln3152">                  wres[reslen++] = *ws;</a>
<a name="ln3153">                }</a>
<a name="ln3154">                ws++;</a>
<a name="ln3155">              }</a>
<a name="ln3156">            }</a>
<a name="ln3157">            // new &quot;actual letter&quot;</a>
<a name="ln3158">            if (ws == NULL) {</a>
<a name="ln3159">              c = NUL;</a>
<a name="ln3160">            } else {</a>
<a name="ln3161">              c = *ws;</a>
<a name="ln3162">            }</a>
<a name="ln3163">            if (strstr(s, &quot;^^&quot;) != NULL) {</a>
<a name="ln3164">              if (c != NUL) {</a>
<a name="ln3165">                wres[reslen++] = c;</a>
<a name="ln3166">              }</a>
<a name="ln3167">              memmove(word, word + i + 1, sizeof(int) * (size_t)(wordlen - (i + 1) + 1));</a>
<a name="ln3168">              i = 0;</a>
<a name="ln3169">              z0 = 1;</a>
<a name="ln3170">            }</a>
<a name="ln3171">          }</a>
<a name="ln3172">          break;</a>
<a name="ln3173">        }</a>
<a name="ln3174">      }</a>
<a name="ln3175">    } else if (ascii_iswhite(c)) {</a>
<a name="ln3176">      c = ' ';</a>
<a name="ln3177">      k = 1;</a>
<a name="ln3178">    }</a>
<a name="ln3179"> </a>
<a name="ln3180">    if (z0 == 0) {</a>
<a name="ln3181">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln3182">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln3183">              || wres[reslen - 1] != c)) {</a>
<a name="ln3184">        // condense only double letters</a>
<a name="ln3185">        wres[reslen++] = c;</a>
<a name="ln3186">      }</a>
<a name="ln3187"> </a>
<a name="ln3188">      i++;</a>
<a name="ln3189">      z = 0;</a>
<a name="ln3190">      k = 0;</a>
<a name="ln3191">    }</a>
<a name="ln3192">  }</a>
<a name="ln3193"> </a>
<a name="ln3194">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln3195">  int l = 0;</a>
<a name="ln3196">  for (int n = 0; n &lt; reslen; n++) {</a>
<a name="ln3197">    l += utf_char2bytes(wres[n], res + l);</a>
<a name="ln3198">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln3199">      break;</a>
<a name="ln3200">    }</a>
<a name="ln3201">  }</a>
<a name="ln3202">  res[l] = NUL;</a>
<a name="ln3203">}</a>
<a name="ln3204"> </a>
<a name="ln3205">// &quot;:spellinfo&quot;</a>
<a name="ln3206">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln3207">{</a>
<a name="ln3208">  if (no_spell_checking(curwin)) {</a>
<a name="ln3209">    return;</a>
<a name="ln3210">  }</a>
<a name="ln3211"> </a>
<a name="ln3212">  msg_start();</a>
<a name="ln3213">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln3214">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3215">    msg_puts(&quot;file: &quot;);</a>
<a name="ln3216">    msg_puts(lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln3217">    msg_putchar('\n');</a>
<a name="ln3218">    const char *const p = lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln3219">    if (p != NULL) {</a>
<a name="ln3220">      msg_puts(p);</a>
<a name="ln3221">      msg_putchar('\n');</a>
<a name="ln3222">    }</a>
<a name="ln3223">  }</a>
<a name="ln3224">  msg_end();</a>
<a name="ln3225">}</a>
<a name="ln3226"> </a>
<a name="ln3227">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln3228">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln3229">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln3230">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln3231">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln3232"> </a>
<a name="ln3233">// &quot;:spelldump&quot;</a>
<a name="ln3234">void ex_spelldump(exarg_T *eap)</a>
<a name="ln3235">{</a>
<a name="ln3236">  if (no_spell_checking(curwin)) {</a>
<a name="ln3237">    return;</a>
<a name="ln3238">  }</a>
<a name="ln3239">  OptVal spl = get_option_value(&quot;spl&quot;, NULL, OPT_LOCAL, NULL);</a>
<a name="ln3240"> </a>
<a name="ln3241">  // Create a new empty buffer in a new window.</a>
<a name="ln3242">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln3243"> </a>
<a name="ln3244">  // enable spelling locally in the new window</a>
<a name="ln3245">  set_option_value_give_err(&quot;spell&quot;, BOOLEAN_OPTVAL(true), OPT_LOCAL);</a>
<a name="ln3246">  set_option_value_give_err(&quot;spl&quot;, spl, OPT_LOCAL);</a>
<a name="ln3247">  optval_free(spl);</a>
<a name="ln3248"> </a>
<a name="ln3249">  if (!buf_is_empty(curbuf)) {</a>
<a name="ln3250">    return;</a>
<a name="ln3251">  }</a>
<a name="ln3252"> </a>
<a name="ln3253">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln3254"> </a>
<a name="ln3255">  // Delete the empty line that we started with.</a>
<a name="ln3256">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln3257">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln3258">  }</a>
<a name="ln3259">  redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262">/// Go through all possible words and:</a>
<a name="ln3263">/// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln3264">///      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln3265">/// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln3266">///</a>
<a name="ln3267">/// @param pat  leading part of the word</a>
<a name="ln3268">/// @param ic  ignore case</a>
<a name="ln3269">/// @param dir  direction for adding matches</a>
<a name="ln3270">/// @param dumpflags_arg  DUMPFLAG_*</a>
<a name="ln3271">void spell_dump_compl(char *pat, int ic, Direction *dir, int dumpflags_arg)</a>
<a name="ln3272">{</a>
<a name="ln3273">  langp_T *lp;</a>
<a name="ln3274">  slang_T *slang;</a>
<a name="ln3275">  idx_T arridx[MAXWLEN];</a>
<a name="ln3276">  int curi[MAXWLEN];</a>
<a name="ln3277">  char word[MAXWLEN];</a>
<a name="ln3278">  int c;</a>
<a name="ln3279">  uint8_t *byts;</a>
<a name="ln3280">  idx_T *idxs;</a>
<a name="ln3281">  linenr_T lnum = 0;</a>
<a name="ln3282">  int depth;</a>
<a name="ln3283">  int n;</a>
<a name="ln3284">  int flags;</a>
<a name="ln3285">  char *region_names = NULL;         // region names being used</a>
<a name="ln3286">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln3287">  char *p;</a>
<a name="ln3288">  int dumpflags = dumpflags_arg;</a>
<a name="ln3289">  int patlen;</a>
<a name="ln3290"> </a>
<a name="ln3291">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln3292">  // to dump_word().</a>
<a name="ln3293">  if (pat != NULL) {</a>
<a name="ln3294">    if (ic) {</a>
<a name="ln3295">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln3296">    } else {</a>
<a name="ln3297">      n = captype(pat, NULL);</a>
<a name="ln3298">      if (n == WF_ONECAP) {</a>
<a name="ln3299">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln3300">      } else if (n == WF_ALLCAP</a>
<a name="ln3301">                 &amp;&amp; (int)strlen(pat) &gt; utfc_ptr2len(pat)) {</a>
<a name="ln3302">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln3303">      }</a>
<a name="ln3304">    }</a>
<a name="ln3305">  }</a>
<a name="ln3306"> </a>
<a name="ln3307">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln3308">  // regions or none at all.</a>
<a name="ln3309">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln3310">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3311">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln3312">    if (p[0] != 0) {</a>
<a name="ln3313">      if (region_names == NULL) {           // first language with regions</a>
<a name="ln3314">        region_names = p;</a>
<a name="ln3315">      } else if (strcmp(region_names, p) != 0) {</a>
<a name="ln3316">        do_region = false;                  // region names are different</a>
<a name="ln3317">        break;</a>
<a name="ln3318">      }</a>
<a name="ln3319">    }</a>
<a name="ln3320">  }</a>
<a name="ln3321"> </a>
<a name="ln3322">  if (do_region &amp;&amp; region_names != NULL &amp;&amp; pat == NULL) {</a>
<a name="ln3323">    vim_snprintf(IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln3324">    ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln3325">  } else {</a>
<a name="ln3326">    do_region = false;</a>
<a name="ln3327">  }</a>
<a name="ln3328"> </a>
<a name="ln3329">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln3330">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln3331">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3332">    slang = lp-&gt;lp_slang;</a>
<a name="ln3333">    if (slang-&gt;sl_fbyts == NULL) {          // reloading failed</a>
<a name="ln3334">      continue;</a>
<a name="ln3335">    }</a>
<a name="ln3336"> </a>
<a name="ln3337">    if (pat == NULL) {</a>
<a name="ln3338">      vim_snprintf(IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln3339">      ml_append(lnum++, IObuff, (colnr_T)0, false);</a>
<a name="ln3340">    }</a>
<a name="ln3341"> </a>
<a name="ln3342">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln3343">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln3344">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL) {</a>
<a name="ln3345">      patlen = (int)strlen(pat);</a>
<a name="ln3346">    } else {</a>
<a name="ln3347">      patlen = -1;</a>
<a name="ln3348">    }</a>
<a name="ln3349"> </a>
<a name="ln3350">    // round 1: case-folded tree</a>
<a name="ln3351">    // round 2: keep-case tree</a>
<a name="ln3352">    for (int round = 1; round &lt;= 2; round++) {</a>
<a name="ln3353">      if (round == 1) {</a>
<a name="ln3354">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln3355">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln3356">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln3357">      } else {</a>
<a name="ln3358">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln3359">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln3360">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln3361">      }</a>
<a name="ln3362">      if (byts == NULL) {</a>
<a name="ln3363">        continue;                       // array is empty</a>
<a name="ln3364">      }</a>
<a name="ln3365">      depth = 0;</a>
<a name="ln3366">      arridx[0] = 0;</a>
<a name="ln3367">      curi[0] = 1;</a>
<a name="ln3368">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln3369">             &amp;&amp; (pat == NULL || !ins_compl_interrupted())) {</a>
<a name="ln3370">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln3371">          // Done all bytes at this node, go up one level.</a>
<a name="ln3372">          depth--;</a>
<a name="ln3373">          line_breakcheck();</a>
<a name="ln3374">          ins_compl_check_keys(50, false);</a>
<a name="ln3375">        } else {</a>
<a name="ln3376">          // Do one more byte at this node.</a>
<a name="ln3377">          n = arridx[depth] + curi[depth];</a>
<a name="ln3378">          curi[depth]++;</a>
<a name="ln3379">          c = byts[n];</a>
<a name="ln3380">          if (c == 0 || depth &gt;= MAXWLEN - 1) {</a>
<a name="ln3381">            // End of word or reached maximum length, deal with the</a>
<a name="ln3382">            // word.</a>
<a name="ln3383">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln3384">            // they will appear in the keep-case tree.</a>
<a name="ln3385">            // Only use the word when the region matches.</a>
<a name="ln3386">            flags = (int)idxs[n];</a>
<a name="ln3387">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln3388">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln3389">                &amp;&amp; (do_region</a>
<a name="ln3390">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln3391">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln3392">                        &amp; (unsigned)lp-&gt;lp_region) != 0)) {</a>
<a name="ln3393">              word[depth] = NUL;</a>
<a name="ln3394">              if (!do_region) {</a>
<a name="ln3395">                flags &amp;= ~WF_REGION;</a>
<a name="ln3396">              }</a>
<a name="ln3397"> </a>
<a name="ln3398">              // Dump the basic word if there is no prefix or</a>
<a name="ln3399">              // when it's the first one.</a>
<a name="ln3400">              c = (int)((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3401">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln3402">                dump_word(slang, word, pat, dir, dumpflags, flags, lnum);</a>
<a name="ln3403">                if (pat == NULL) {</a>
<a name="ln3404">                  lnum++;</a>
<a name="ln3405">                }</a>
<a name="ln3406">              }</a>
<a name="ln3407"> </a>
<a name="ln3408">              // Apply the prefix, if there is one.</a>
<a name="ln3409">              if (c != 0) {</a>
<a name="ln3410">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln3411">                                     dumpflags, flags, lnum);</a>
<a name="ln3412">              }</a>
<a name="ln3413">            }</a>
<a name="ln3414">          } else {</a>
<a name="ln3415">            // Normal char, go one level deeper.</a>
<a name="ln3416">            word[depth++] = (char)c;</a>
<a name="ln3417">            arridx[depth] = idxs[n];</a>
<a name="ln3418">            curi[depth] = 1;</a>
<a name="ln3419"> </a>
<a name="ln3420">            // Check if this character matches with the pattern.</a>
<a name="ln3421">            // If not skip the whole tree below it.</a>
<a name="ln3422">            // Always ignore case here, dump_word() will check</a>
<a name="ln3423">            // proper case later.  This isn't exactly right when</a>
<a name="ln3424">            // length changes for multi-byte characters with</a>
<a name="ln3425">            // ignore case...</a>
<a name="ln3426">            assert(depth &gt;= 0);</a>
<a name="ln3427">            if (depth &lt;= patlen</a>
<a name="ln3428">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0) {</a>
<a name="ln3429">              depth--;</a>
<a name="ln3430">            }</a>
<a name="ln3431">          }</a>
<a name="ln3432">        }</a>
<a name="ln3433">      }</a>
<a name="ln3434">    }</a>
<a name="ln3435">  }</a>
<a name="ln3436">}</a>
<a name="ln3437"> </a>
<a name="ln3438">/// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln3439">/// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln3440">static void dump_word(slang_T *slang, char *word, char *pat, Direction *dir, int dumpflags,</a>
<a name="ln3441">                      int wordflags, linenr_T lnum)</a>
<a name="ln3442">{</a>
<a name="ln3443">  bool keepcap = false;</a>
<a name="ln3444">  char *p;</a>
<a name="ln3445">  char cword[MAXWLEN];</a>
<a name="ln3446">  char badword[MAXWLEN + 10];</a>
<a name="ln3447">  int flags = wordflags;</a>
<a name="ln3448"> </a>
<a name="ln3449">  if (dumpflags &amp; DUMPFLAG_ONECAP) {</a>
<a name="ln3450">    flags |= WF_ONECAP;</a>
<a name="ln3451">  }</a>
<a name="ln3452">  if (dumpflags &amp; DUMPFLAG_ALLCAP) {</a>
<a name="ln3453">    flags |= WF_ALLCAP;</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln3457">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln3458">    make_case_word(word, cword, flags);</a>
<a name="ln3459">    p = cword;</a>
<a name="ln3460">  } else {</a>
<a name="ln3461">    p = word;</a>
<a name="ln3462">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln3463">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln3464">            || (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln3465">      keepcap = true;</a>
<a name="ln3466">    }</a>
<a name="ln3467">  }</a>
<a name="ln3468">  char *tw = p;</a>
<a name="ln3469"> </a>
<a name="ln3470">  if (pat == NULL) {</a>
<a name="ln3471">    // Add flags and regions after a slash.</a>
<a name="ln3472">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln3473">      STRCPY(badword, p);</a>
<a name="ln3474">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln3475">      if (keepcap) {</a>
<a name="ln3476">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln3477">      }</a>
<a name="ln3478">      if (flags &amp; WF_BANNED) {</a>
<a name="ln3479">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln3480">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln3481">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln3482">      }</a>
<a name="ln3483">      if (flags &amp; WF_REGION) {</a>
<a name="ln3484">        for (int i = 0; i &lt; 7; i++) {</a>
<a name="ln3485">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln3486">            const size_t badword_len = strlen(badword);</a>
<a name="ln3487">            snprintf(badword + badword_len,</a>
<a name="ln3488">                     sizeof(badword) - badword_len,</a>
<a name="ln3489">                     &quot;%d&quot;, i + 1);</a>
<a name="ln3490">          }</a>
<a name="ln3491">        }</a>
<a name="ln3492">      }</a>
<a name="ln3493">      p = badword;</a>
<a name="ln3494">    }</a>
<a name="ln3495"> </a>
<a name="ln3496">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln3497">      hashitem_T *hi;</a>
<a name="ln3498"> </a>
<a name="ln3499">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln3500">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln3501">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln3502">        vim_snprintf(IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln3503">                     tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln3504">        p = IObuff;</a>
<a name="ln3505">      }</a>
<a name="ln3506">    }</a>
<a name="ln3507"> </a>
<a name="ln3508">    ml_append(lnum, p, (colnr_T)0, false);</a>
<a name="ln3509">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln3510">              ? mb_strnicmp(p, pat, strlen(pat)) == 0</a>
<a name="ln3511">              : strncmp(p, pat, strlen(pat)) == 0)</a>
<a name="ln3512">             &amp;&amp; ins_compl_add_infercase(p, (int)strlen(p),</a>
<a name="ln3513">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln3514">    // if dir was BACKWARD then honor it just once</a>
<a name="ln3515">    *dir = FORWARD;</a>
<a name="ln3516">  }</a>
<a name="ln3517">}</a>
<a name="ln3518"> </a>
<a name="ln3519">/// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln3520">/// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln3521">/// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln3522">///</a>
<a name="ln3523">/// @param word  case-folded word</a>
<a name="ln3524">/// @param flags  flags with prefix ID</a>
<a name="ln3525">///</a>
<a name="ln3526">/// @return  the updated line number.</a>
<a name="ln3527">static linenr_T dump_prefixes(slang_T *slang, char *word, char *pat, Direction *dir, int dumpflags,</a>
<a name="ln3528">                              int flags, linenr_T startlnum)</a>
<a name="ln3529">{</a>
<a name="ln3530">  idx_T arridx[MAXWLEN];</a>
<a name="ln3531">  int curi[MAXWLEN];</a>
<a name="ln3532">  char prefix[MAXWLEN];</a>
<a name="ln3533">  char word_up[MAXWLEN];</a>
<a name="ln3534">  bool has_word_up = false;</a>
<a name="ln3535">  linenr_T lnum = startlnum;</a>
<a name="ln3536"> </a>
<a name="ln3537">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln3538">  // upper-case letter in word_up[].</a>
<a name="ln3539">  int c = utf_ptr2char(word);</a>
<a name="ln3540">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln3541">    onecap_copy(word, word_up, true);</a>
<a name="ln3542">    has_word_up = true;</a>
<a name="ln3543">  }</a>
<a name="ln3544"> </a>
<a name="ln3545">  uint8_t *byts = slang-&gt;sl_pbyts;</a>
<a name="ln3546">  idx_T *idxs = slang-&gt;sl_pidxs;</a>
<a name="ln3547">  if (byts != NULL) {           // array not is empty</a>
<a name="ln3548">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln3549">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln3550">    int depth = 0;</a>
<a name="ln3551">    arridx[0] = 0;</a>
<a name="ln3552">    curi[0] = 1;</a>
<a name="ln3553">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3554">      int n = arridx[depth];</a>
<a name="ln3555">      int len = byts[n];</a>
<a name="ln3556">      if (curi[depth] &gt; len) {</a>
<a name="ln3557">        // Done all bytes at this node, go up one level.</a>
<a name="ln3558">        depth--;</a>
<a name="ln3559">        line_breakcheck();</a>
<a name="ln3560">      } else {</a>
<a name="ln3561">        // Do one more byte at this node.</a>
<a name="ln3562">        n += curi[depth];</a>
<a name="ln3563">        curi[depth]++;</a>
<a name="ln3564">        c = byts[n];</a>
<a name="ln3565">        if (c == 0) {</a>
<a name="ln3566">          // End of prefix, find out how many IDs there are.</a>
<a name="ln3567">          int i;</a>
<a name="ln3568">          for (i = 1; i &lt; len; i++) {</a>
<a name="ln3569">            if (byts[n + i] != 0) {</a>
<a name="ln3570">              break;</a>
<a name="ln3571">            }</a>
<a name="ln3572">          }</a>
<a name="ln3573">          curi[depth] += i - 1;</a>
<a name="ln3574"> </a>
<a name="ln3575">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln3576">          if (c != 0) {</a>
<a name="ln3577">            xstrlcpy(prefix + depth, word, (size_t)(MAXWLEN - depth));</a>
<a name="ln3578">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln3579">                      (c &amp; WF_RAREPFX) ? (flags | WF_RARE) : flags, lnum);</a>
<a name="ln3580">            if (lnum != 0) {</a>
<a name="ln3581">              lnum++;</a>
<a name="ln3582">            }</a>
<a name="ln3583">          }</a>
<a name="ln3584"> </a>
<a name="ln3585">          // Check for prefix that matches the word when the</a>
<a name="ln3586">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln3587">          // a condition.</a>
<a name="ln3588">          if (has_word_up) {</a>
<a name="ln3589">            c = valid_word_prefix(i, n, flags, word_up, slang, true);</a>
<a name="ln3590">            if (c != 0) {</a>
<a name="ln3591">              xstrlcpy(prefix + depth, word_up, (size_t)(MAXWLEN - depth));</a>
<a name="ln3592">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln3593">                        (c &amp; WF_RAREPFX) ? (flags | WF_RARE) : flags, lnum);</a>
<a name="ln3594">              if (lnum != 0) {</a>
<a name="ln3595">                lnum++;</a>
<a name="ln3596">              }</a>
<a name="ln3597">            }</a>
<a name="ln3598">          }</a>
<a name="ln3599">        } else {</a>
<a name="ln3600">          // Normal char, go one level deeper.</a>
<a name="ln3601">          prefix[depth++] = (char)c;</a>
<a name="ln3602">          arridx[depth] = idxs[n];</a>
<a name="ln3603">          curi[depth] = 1;</a>
<a name="ln3604">        }</a>
<a name="ln3605">      }</a>
<a name="ln3606">    }</a>
<a name="ln3607">  }</a>
<a name="ln3608"> </a>
<a name="ln3609">  return lnum;</a>
<a name="ln3610">}</a>
<a name="ln3611"> </a>
<a name="ln3612">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln3613">// Uses the spell-checking word characters.</a>
<a name="ln3614">char *spell_to_word_end(char *start, win_T *win)</a>
<a name="ln3615">{</a>
<a name="ln3616">  char *p = start;</a>
<a name="ln3617"> </a>
<a name="ln3618">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln3619">    MB_PTR_ADV(p);</a>
<a name="ln3620">  }</a>
<a name="ln3621">  return p;</a>
<a name="ln3622">}</a>
<a name="ln3623"> </a>
<a name="ln3624">// For Insert mode completion CTRL-X s:</a>
<a name="ln3625">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln3626">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln3627">// the word in front of the cursor.</a>
<a name="ln3628">// Returns the column number of the word.</a>
<a name="ln3629">int spell_word_start(int startcol)</a>
<a name="ln3630">{</a>
<a name="ln3631">  if (no_spell_checking(curwin)) {</a>
<a name="ln3632">    return startcol;</a>
<a name="ln3633">  }</a>
<a name="ln3634"> </a>
<a name="ln3635">  char *line = get_cursor_line_ptr();</a>
<a name="ln3636">  char *p;</a>
<a name="ln3637"> </a>
<a name="ln3638">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln3639">  for (p = line + startcol; p &gt; line;) {</a>
<a name="ln3640">    MB_PTR_BACK(line, p);</a>
<a name="ln3641">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln3642">      break;</a>
<a name="ln3643">    }</a>
<a name="ln3644">  }</a>
<a name="ln3645"> </a>
<a name="ln3646">  int col = 0;</a>
<a name="ln3647"> </a>
<a name="ln3648">  // Go back to start of the word.</a>
<a name="ln3649">  while (p &gt; line) {</a>
<a name="ln3650">    col = (int)(p - line);</a>
<a name="ln3651">    MB_PTR_BACK(line, p);</a>
<a name="ln3652">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln3653">      break;</a>
<a name="ln3654">    }</a>
<a name="ln3655">    col = 0;</a>
<a name="ln3656">  }</a>
<a name="ln3657"> </a>
<a name="ln3658">  return col;</a>
<a name="ln3659">}</a>
<a name="ln3660"> </a>
<a name="ln3661">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln3662">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln3663">static bool spell_expand_need_cap;</a>
<a name="ln3664"> </a>
<a name="ln3665">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln3666">{</a>
<a name="ln3667">  spell_expand_need_cap = check_need_cap(curwin, curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln3668">}</a>
<a name="ln3669"> </a>
<a name="ln3670">// Get list of spelling suggestions.</a>
<a name="ln3671">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln3672">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln3673">// allocated strings.</a>
<a name="ln3674">int expand_spelling(linenr_T lnum, char *pat, char ***matchp)</a>
<a name="ln3675">{</a>
<a name="ln3676">  garray_T ga;</a>
<a name="ln3677"> </a>
<a name="ln3678">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln3679">  *matchp = ga.ga_data;</a>
<a name="ln3680">  return ga.ga_len;</a>
<a name="ln3681">}</a>
<a name="ln3682"> </a>
<a name="ln3683">/// @return  true if &quot;val&quot; is a valid 'spelllang' value.</a>
<a name="ln3684">bool valid_spelllang(const char *val)</a>
<a name="ln3685">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3686">{</a>
<a name="ln3687">  return valid_name(val, &quot;.-_,@&quot;);</a>
<a name="ln3688">}</a>
<a name="ln3689"> </a>
<a name="ln3690">/// @return  true if &quot;val&quot; is a valid 'spellfile' value.</a>
<a name="ln3691">bool valid_spellfile(const char *val)</a>
<a name="ln3692">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln3693">{</a>
<a name="ln3694">  for (const char *s = val; *s != NUL; s++) {</a>
<a name="ln3695">    if (!vim_is_fname_char((uint8_t)(*s))) {</a>
<a name="ln3696">      return false;</a>
<a name="ln3697">    }</a>
<a name="ln3698">  }</a>
<a name="ln3699">  return true;</a>
<a name="ln3700">}</a>
<a name="ln3701"> </a>
<a name="ln3702">const char *did_set_spell_option(bool is_spellfile)</a>
<a name="ln3703">{</a>
<a name="ln3704">  const char *errmsg = NULL;</a>
<a name="ln3705"> </a>
<a name="ln3706">  if (is_spellfile) {</a>
<a name="ln3707">    int l = (int)strlen(curwin-&gt;w_s-&gt;b_p_spf);</a>
<a name="ln3708">    if (l &gt; 0</a>
<a name="ln3709">        &amp;&amp; (l &lt; 4 || strcmp(curwin-&gt;w_s-&gt;b_p_spf + l - 4, &quot;.add&quot;) != 0)) {</a>
<a name="ln3710">      errmsg = e_invarg;</a>
<a name="ln3711">    }</a>
<a name="ln3712">  }</a>
<a name="ln3713"> </a>
<a name="ln3714">  if (errmsg != NULL) {</a>
<a name="ln3715">    return errmsg;</a>
<a name="ln3716">  }</a>
<a name="ln3717"> </a>
<a name="ln3718">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln3719">    if (wp-&gt;w_buffer == curbuf &amp;&amp; wp-&gt;w_p_spell) {</a>
<a name="ln3720">      errmsg = parse_spelllang(wp);</a>
<a name="ln3721">      break;</a>
<a name="ln3722">    }</a>
<a name="ln3723">  }</a>
<a name="ln3724">  return errmsg;</a>
<a name="ln3725">}</a>
<a name="ln3726"> </a>
<a name="ln3727">/// Set curbuf-&gt;b_cap_prog to the regexp program for 'spellcapcheck'.</a>
<a name="ln3728">/// Return error message when failed, NULL when OK.</a>
<a name="ln3729">const char *compile_cap_prog(synblock_T *synblock)</a>
<a name="ln3730">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3731">{</a>
<a name="ln3732">  regprog_T *rp = synblock-&gt;b_cap_prog;</a>
<a name="ln3733"> </a>
<a name="ln3734">  if (synblock-&gt;b_p_spc == NULL || *synblock-&gt;b_p_spc == NUL) {</a>
<a name="ln3735">    synblock-&gt;b_cap_prog = NULL;</a>
<a name="ln3736">  } else {</a>
<a name="ln3737">    // Prepend a ^ so that we only match at one column</a>
<a name="ln3738">    char *re = concat_str(&quot;^&quot;, synblock-&gt;b_p_spc);</a>
<a name="ln3739">    synblock-&gt;b_cap_prog = vim_regcomp(re, RE_MAGIC);</a>
<a name="ln3740">    xfree(re);</a>
<a name="ln3741">    if (synblock-&gt;b_cap_prog == NULL) {</a>
<a name="ln3742">      synblock-&gt;b_cap_prog = rp;         // restore the previous program</a>
<a name="ln3743">      return e_invarg;</a>
<a name="ln3744">    }</a>
<a name="ln3745">  }</a>
<a name="ln3746"> </a>
<a name="ln3747">  vim_regfree(rp);</a>
<a name="ln3748">  return NULL;</a>
<a name="ln3749">}</a>
</code></pre>
<div class="balloon" rel="3022"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>