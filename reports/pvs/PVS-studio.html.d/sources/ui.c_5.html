<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ui.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6">#include &lt;msgpack/pack.h&gt;</a>
<a name="ln7">#include &lt;stdbool.h&gt;</a>
<a name="ln8">#include &lt;stdint.h&gt;</a>
<a name="ln9">#include &lt;stdlib.h&gt;</a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;klib/kvec.h&quot;</a>
<a name="ln13">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln14">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/ui.h&quot;</a>
<a name="ln17">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln18">#include &quot;nvim/channel.h&quot;</a>
<a name="ln19">#include &quot;nvim/event/loop.h&quot;</a>
<a name="ln20">#include &quot;nvim/event/wstream.h&quot;</a>
<a name="ln21">#include &quot;nvim/globals.h&quot;</a>
<a name="ln22">#include &quot;nvim/grid.h&quot;</a>
<a name="ln23">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln24">#include &quot;nvim/main.h&quot;</a>
<a name="ln25">#include &quot;nvim/map.h&quot;</a>
<a name="ln26">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln27">#include &quot;nvim/memory.h&quot;</a>
<a name="ln28">#include &quot;nvim/msgpack_rpc/channel.h&quot;</a>
<a name="ln29">#include &quot;nvim/msgpack_rpc/channel_defs.h&quot;</a>
<a name="ln30">#include &quot;nvim/msgpack_rpc/helpers.h&quot;</a>
<a name="ln31">#include &quot;nvim/option.h&quot;</a>
<a name="ln32">#include &quot;nvim/types.h&quot;</a>
<a name="ln33">#include &quot;nvim/ui.h&quot;</a>
<a name="ln34">#include &quot;nvim/vim.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#define BUF_POS(data) ((size_t)((data)-&gt;buf_wptr - (data)-&gt;buf))</a>
<a name="ln37"> </a>
<a name="ln38">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln39"># include &quot;api/ui.c.generated.h&quot;</a>
<a name="ln40"># include &quot;ui_events_remote.generated.h&quot;  // IWYU pragma: export</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">static PMap(uint64_t) connected_uis = MAP_INIT;</a>
<a name="ln44"> </a>
<a name="ln45">#define mpack_w(b, byte) *(*b)++ = (char)(byte);</a>
<a name="ln46">static void mpack_w2(char **b, uint32_t v)</a>
<a name="ln47">{</a>
<a name="ln48">  *(*b)++ = (char)((v &gt;&gt; 8) &amp; 0xff);</a>
<a name="ln49">  *(*b)++ = (char)(v &amp; 0xff);</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">static void mpack_w4(char **b, uint32_t v)</a>
<a name="ln53">{</a>
<a name="ln54">  *(*b)++ = (char)((v &gt;&gt; 24) &amp; 0xff);</a>
<a name="ln55">  *(*b)++ = (char)((v &gt;&gt; 16) &amp; 0xff);</a>
<a name="ln56">  *(*b)++ = (char)((v &gt;&gt; 8) &amp; 0xff);</a>
<a name="ln57">  *(*b)++ = (char)(v &amp; 0xff);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">static void mpack_uint(char **buf, uint32_t val)</a>
<a name="ln61">{</a>
<a name="ln62">  if (val &gt; 0xffff) {</a>
<a name="ln63">    mpack_w(buf, 0xce);</a>
<a name="ln64">    mpack_w4(buf, val);</a>
<a name="ln65">  } else if (val &gt; 0xff) {</a>
<a name="ln66">    mpack_w(buf, 0xcd);</a>
<a name="ln67">    mpack_w2(buf, val);</a>
<a name="ln68">  } else if (val &gt; 0x7f) {</a>
<a name="ln69">    mpack_w(buf, 0xcc);</a>
<a name="ln70">    mpack_w(buf, val);</a>
<a name="ln71">  } else {</a>
<a name="ln72">    mpack_w(buf, val);</a>
<a name="ln73">  }</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">static void mpack_bool(char **buf, bool val)</a>
<a name="ln77">{</a>
<a name="ln78">  mpack_w(buf, 0xc2 | val);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">static void mpack_array(char **buf, uint32_t len)</a>
<a name="ln82">{</a>
<a name="ln83">  if (len &lt; 0x10) {</a>
<a name="ln84">    mpack_w(buf, 0x90 | len);</a>
<a name="ln85">  } else if (len &lt; 0x10000) {</a>
<a name="ln86">    mpack_w(buf, 0xdc);</a>
<a name="ln87">    mpack_w2(buf, len);</a>
<a name="ln88">  } else {</a>
<a name="ln89">    mpack_w(buf, 0xdd);</a>
<a name="ln90">    mpack_w4(buf, len);</a>
<a name="ln91">  }</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">static char *mpack_array_dyn16(char **buf)</a>
<a name="ln95">{</a>
<a name="ln96">  mpack_w(buf, 0xdc);</a>
<a name="ln97">  char *pos = *buf;</a>
<a name="ln98">  mpack_w2(buf, 0xFFEF);</a>
<a name="ln99">  return pos;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void mpack_str(char **buf, const char *str)</a>
<a name="ln103">{</a>
<a name="ln104">  assert(sizeof(schar_T) - 1 &lt; 0x20);</a>
<a name="ln105">  size_t len = strlen(str);</a>
<a name="ln106">  mpack_w(buf, 0xa0 | len);</a>
<a name="ln107">  memcpy(*buf, str, len);</a>
<a name="ln108">  *buf += len;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">void remote_ui_disconnect(uint64_t channel_id)</a>
<a name="ln112">{</a>
<a name="ln113">  UI *ui = pmap_get(uint64_t)(&amp;connected_uis, channel_id);</a>
<a name="ln114">  if (!ui) {</a>
<a name="ln115">    return;</a>
<a name="ln116">  }</a>
<a name="ln117">  UIData *data = ui-&gt;data;</a>
<a name="ln118">  kv_destroy(data-&gt;call_buf);</a>
<a name="ln119">  pmap_del(uint64_t)(&amp;connected_uis, channel_id, NULL);</a>
<a name="ln120">  ui_detach_impl(ui, channel_id);</a>
<a name="ln121"> </a>
<a name="ln122">  // Destroy `ui`.</a>
<a name="ln123">  XFREE_CLEAR(ui-&gt;term_name);</a>
<a name="ln124">  XFREE_CLEAR(ui-&gt;term_background);</a>
<a name="ln125">  xfree(ui);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">/// Wait until ui has connected on stdio channel.</a>
<a name="ln129">void remote_ui_wait_for_attach(void)</a>
<a name="ln130">{</a>
<a name="ln131">  Channel *channel = find_channel(CHAN_STDIO);</a>
<a name="ln132">  if (!channel) {</a>
<a name="ln133">    // this function should only be called in --embed mode, stdio channel</a>
<a name="ln134">    // can be assumed.</a>
<a name="ln135">    abort();</a>
<a name="ln136">  }</a>
<a name="ln137"> </a>
<a name="ln138">  LOOP_PROCESS_EVENTS_UNTIL(&amp;main_loop, channel-&gt;events, -1,</a>
<a name="ln139">                            map_has(uint64_t, &amp;connected_uis, CHAN_STDIO));</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/// Activates UI events on the channel.</a>
<a name="ln143">///</a>
<a name="ln144">/// Entry point of all UI clients.  Allows |\-\-embed| to continue startup.</a>
<a name="ln145">/// Implies that the client is ready to show the UI.  Adds the client to the</a>
<a name="ln146">/// list of UIs. |nvim_list_uis()|</a>
<a name="ln147">///</a>
<a name="ln148">/// @note If multiple UI clients are attached, the global screen dimensions</a>
<a name="ln149">///       degrade to the smallest client. E.g. if client A requests 80x40 but</a>
<a name="ln150">///       client B requests 200x100, the global screen has size 80x40.</a>
<a name="ln151">///</a>
<a name="ln152">/// @param channel_id</a>
<a name="ln153">/// @param width  Requested screen columns</a>
<a name="ln154">/// @param height  Requested screen rows</a>
<a name="ln155">/// @param options  |ui-option| map</a>
<a name="ln156">/// @param[out] err Error details, if any</a>
<a name="ln157">void nvim_ui_attach(uint64_t channel_id, Integer width, Integer height, Dictionary options,</a>
<a name="ln158">                    Error *err)</a>
<a name="ln159">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln160">{</a>
<a name="ln161">  if (map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln162">    api_set_error(err, kErrorTypeException,</a>
<a name="ln163">                  &quot;UI already attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln164">    return;</a>
<a name="ln165">  }</a>
<a name="ln166"> </a>
<a name="ln167">  if (width &lt;= 0 || height &lt;= 0) {</a>
<a name="ln168">    api_set_error(err, kErrorTypeValidation,</a>
<a name="ln169">                  &quot;Expected width &gt; 0 and height &gt; 0&quot;);</a>
<a name="ln170">    return;</a>
<a name="ln171">  }</a>
<a name="ln172">  UI *ui = xcalloc(1, sizeof(UI));</a>
<a name="ln173">  ui-&gt;width = (int)width;</a>
<a name="ln174">  ui-&gt;height = (int)height;</a>
<a name="ln175">  ui-&gt;pum_row = -1.0;</a>
<a name="ln176">  ui-&gt;pum_col = -1.0;</a>
<a name="ln177">  ui-&gt;rgb = true;</a>
<a name="ln178">  CLEAR_FIELD(ui-&gt;ui_ext);</a>
<a name="ln179"> </a>
<a name="ln180">  for (size_t i = 0; i &lt; options.size; i++) {</a>
<a name="ln181">    ui_set_option(ui, true, options.items[i].key, options.items[i].value, err);</a>
<a name="ln182">    if (ERROR_SET(err)) {</a>
<a name="ln183">      xfree(ui);</a>
<a name="ln184">      return;</a>
<a name="ln185">    }</a>
<a name="ln186">  }</a>
<a name="ln187"> </a>
<a name="ln188">  if (ui-&gt;ui_ext[kUIHlState] || ui-&gt;ui_ext[kUIMultigrid]) {</a>
<a name="ln189">    ui-&gt;ui_ext[kUILinegrid] = true;</a>
<a name="ln190">  }</a>
<a name="ln191"> </a>
<a name="ln192">  if (ui-&gt;ui_ext[kUIMessages]) {</a>
<a name="ln193">    // This uses attribute indices, so ext_linegrid is needed.</a>
<a name="ln194">    ui-&gt;ui_ext[kUILinegrid] = true;</a>
<a name="ln195">    // Cmdline uses the messages area, so it should be externalized too.</a>
<a name="ln196">    ui-&gt;ui_ext[kUICmdline] = true;</a>
<a name="ln197">  }</a>
<a name="ln198"> </a>
<a name="ln199">  UIData *data = ui-&gt;data;</a>
<a name="ln200">  data-&gt;channel_id = channel_id;</a>
<a name="ln201">  data-&gt;cur_event = NULL;</a>
<a name="ln202">  data-&gt;hl_id = 0;</a>
<a name="ln203">  data-&gt;client_col = -1;</a>
<a name="ln204">  data-&gt;nevents_pos = NULL;</a>
<a name="ln205">  data-&gt;nevents = 0;</a>
<a name="ln206">  data-&gt;flushed_events = false;</a>
<a name="ln207">  data-&gt;ncalls_pos = NULL;</a>
<a name="ln208">  data-&gt;ncalls = 0;</a>
<a name="ln209">  data-&gt;ncells_pending = 0;</a>
<a name="ln210">  data-&gt;buf_wptr = data-&gt;buf;</a>
<a name="ln211">  data-&gt;temp_buf = NULL;</a>
<a name="ln212">  data-&gt;wildmenu_active = false;</a>
<a name="ln213">  data-&gt;call_buf = (Array)ARRAY_DICT_INIT;</a>
<a name="ln214">  kv_ensure_space(data-&gt;call_buf, 16);</a>
<a name="ln215"> </a>
<a name="ln216">  pmap_put(uint64_t)(&amp;connected_uis, channel_id, ui);</a>
<a name="ln217">  ui_attach_impl(ui, channel_id);</a>
<a name="ln218"> </a>
<a name="ln219">  may_trigger_vim_suspend_resume(false);</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">/// @deprecated</a>
<a name="ln223">void ui_attach(uint64_t channel_id, Integer width, Integer height, Boolean enable_rgb, Error *err)</a>
<a name="ln224">  FUNC_API_DEPRECATED_SINCE(1)</a>
<a name="ln225">{</a>
<a name="ln226">  Dictionary opts = ARRAY_DICT_INIT;</a>
<a name="ln227">  PUT(opts, &quot;rgb&quot;, BOOLEAN_OBJ(enable_rgb));</a>
<a name="ln228">  nvim_ui_attach(channel_id, width, height, opts, err);</a>
<a name="ln229">  api_free_dictionary(opts);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">/// Tells the nvim server if focus was gained or lost by the GUI</a>
<a name="ln233">void nvim_ui_set_focus(uint64_t channel_id, Boolean gained, Error *error)</a>
<a name="ln234">  FUNC_API_SINCE(11) FUNC_API_REMOTE_ONLY</a>
<a name="ln235">{</a>
<a name="ln236">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln237">    api_set_error(error, kErrorTypeException,</a>
<a name="ln238">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln239">    return;</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242">  if (gained) {</a>
<a name="ln243">    may_trigger_vim_suspend_resume(false);</a>
<a name="ln244">  }</a>
<a name="ln245"> </a>
<a name="ln246">  do_autocmd_focusgained((bool)gained);</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/// Deactivates UI events on the channel.</a>
<a name="ln250">///</a>
<a name="ln251">/// Removes the client from the list of UIs. |nvim_list_uis()|</a>
<a name="ln252">///</a>
<a name="ln253">/// @param channel_id</a>
<a name="ln254">/// @param[out] err Error details, if any</a>
<a name="ln255">void nvim_ui_detach(uint64_t channel_id, Error *err)</a>
<a name="ln256">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln257">{</a>
<a name="ln258">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln259">    api_set_error(err, kErrorTypeException,</a>
<a name="ln260">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln261">    return;</a>
<a name="ln262">  }</a>
<a name="ln263">  remote_ui_disconnect(channel_id);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">// TODO(bfredl): use me to detach a specific ui from the server</a>
<a name="ln267">void remote_ui_stop(UI *ui)</a>
<a name="ln268">{</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">void nvim_ui_try_resize(uint64_t channel_id, Integer width, Integer height, Error *err)</a>
<a name="ln272">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln273">{</a>
<a name="ln274">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln275">    api_set_error(err, kErrorTypeException,</a>
<a name="ln276">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln277">    return;</a>
<a name="ln278">  }</a>
<a name="ln279"> </a>
<a name="ln280">  if (width &lt;= 0 || height &lt;= 0) {</a>
<a name="ln281">    api_set_error(err, kErrorTypeValidation,</a>
<a name="ln282">                  &quot;Expected width &gt; 0 and height &gt; 0&quot;);</a>
<a name="ln283">    return;</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  UI *ui = pmap_get(uint64_t)(&amp;connected_uis, channel_id);</a>
<a name="ln287">  ui-&gt;width = (int)width;</a>
<a name="ln288">  ui-&gt;height = (int)height;</a>
<a name="ln289">  ui_refresh();</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">void nvim_ui_set_option(uint64_t channel_id, String name, Object value, Error *error)</a>
<a name="ln293">  FUNC_API_SINCE(1) FUNC_API_REMOTE_ONLY</a>
<a name="ln294">{</a>
<a name="ln295">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln296">    api_set_error(error, kErrorTypeException,</a>
<a name="ln297">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln298">    return;</a>
<a name="ln299">  }</a>
<a name="ln300">  UI *ui = pmap_get(uint64_t)(&amp;connected_uis, channel_id);</a>
<a name="ln301"> </a>
<a name="ln302">  ui_set_option(ui, false, name, value, error);</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">static void ui_set_option(UI *ui, bool init, String name, Object value, Error *err)</a>
<a name="ln306">{</a>
<a name="ln307">  if (strequal(name.data, &quot;override&quot;)) {</a>
<a name="ln308">    VALIDATE_T(&quot;override&quot;, kObjectTypeBoolean, value.type, {</a>
<a name="ln309">      return;</a>
<a name="ln310">    });</a>
<a name="ln311">    ui-&gt;override = value.data.boolean;</a>
<a name="ln312">    return;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  if (strequal(name.data, &quot;rgb&quot;)) {</a>
<a name="ln316">    VALIDATE_T(&quot;rgb&quot;, kObjectTypeBoolean, value.type, {</a>
<a name="ln317">      return;</a>
<a name="ln318">    });</a>
<a name="ln319">    ui-&gt;rgb = value.data.boolean;</a>
<a name="ln320">    // A little drastic, but only takes effect for legacy uis. For linegrid UI</a>
<a name="ln321">    // only changes metadata for nvim_list_uis(), no refresh needed.</a>
<a name="ln322">    if (!init &amp;&amp; !ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln323">      ui_refresh();</a>
<a name="ln324">    }</a>
<a name="ln325">    return;</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  if (strequal(name.data, &quot;term_name&quot;)) {</a>
<a name="ln329">    VALIDATE_T(&quot;term_name&quot;, kObjectTypeString, value.type, {</a>
<a name="ln330">      return;</a>
<a name="ln331">    });</a>
<a name="ln332">    set_tty_option(&quot;term&quot;, string_to_cstr(value.data.string));</a>
<a name="ln333">    ui-&gt;term_name = string_to_cstr(value.data.string);</a>
<a name="ln334">    return;</a>
<a name="ln335">  }</a>
<a name="ln336"> </a>
<a name="ln337">  if (strequal(name.data, &quot;term_colors&quot;)) {</a>
<a name="ln338">    VALIDATE_T(&quot;term_colors&quot;, kObjectTypeInteger, value.type, {</a>
<a name="ln339">      return;</a>
<a name="ln340">    });</a>
<a name="ln341">    t_colors = (int)value.data.integer;</a>
<a name="ln342">    ui-&gt;term_colors = (int)value.data.integer;</a>
<a name="ln343">    return;</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">  if (strequal(name.data, &quot;term_background&quot;)) {</a>
<a name="ln347">    VALIDATE_T(&quot;term_background&quot;, kObjectTypeString, value.type, {</a>
<a name="ln348">      return;</a>
<a name="ln349">    });</a>
<a name="ln350">    set_tty_background(value.data.string.data);</a>
<a name="ln351">    ui-&gt;term_background = string_to_cstr(value.data.string);</a>
<a name="ln352">    return;</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  if (strequal(name.data, &quot;stdin_fd&quot;)) {</a>
<a name="ln356">    VALIDATE_T(&quot;stdin_fd&quot;, kObjectTypeInteger, value.type, {</a>
<a name="ln357">      return;</a>
<a name="ln358">    });</a>
<a name="ln359">    VALIDATE_INT((value.data.integer &gt;= 0), &quot;stdin_fd&quot;, value.data.integer, {</a>
<a name="ln360">      return;</a>
<a name="ln361">    });</a>
<a name="ln362">    VALIDATE((starting == NO_SCREEN), &quot;%s&quot;, &quot;stdin_fd can only be used with first attached UI&quot;, {</a>
<a name="ln363">      return;</a>
<a name="ln364">    });</a>
<a name="ln365"> </a>
<a name="ln366">    stdin_fd = (int)value.data.integer;</a>
<a name="ln367">    return;</a>
<a name="ln368">  }</a>
<a name="ln369"> </a>
<a name="ln370">  if (strequal(name.data, &quot;stdin_tty&quot;)) {</a>
<a name="ln371">    VALIDATE_T(&quot;stdin_tty&quot;, kObjectTypeBoolean, value.type, {</a>
<a name="ln372">      return;</a>
<a name="ln373">    });</a>
<a name="ln374">    stdin_isatty = value.data.boolean;</a>
<a name="ln375">    ui-&gt;stdin_tty = value.data.boolean;</a>
<a name="ln376">    return;</a>
<a name="ln377">  }</a>
<a name="ln378"> </a>
<a name="ln379">  if (strequal(name.data, &quot;stdout_tty&quot;)) {</a>
<a name="ln380">    VALIDATE_T(&quot;stdout_tty&quot;, kObjectTypeBoolean, value.type, {</a>
<a name="ln381">      return;</a>
<a name="ln382">    });</a>
<a name="ln383">    stdout_isatty = value.data.boolean;</a>
<a name="ln384">    ui-&gt;stdout_tty = value.data.boolean;</a>
<a name="ln385">    return;</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  // LEGACY: Deprecated option, use `ext_cmdline` instead.</a>
<a name="ln389">  bool is_popupmenu = strequal(name.data, &quot;popupmenu_external&quot;);</a>
<a name="ln390"> </a>
<a name="ln391">  for (UIExtension i = 0; i &lt; kUIExtCount; i++) {</a>
<a name="ln392">    if (strequal(name.data, ui_ext_names[i])</a>
<a name="ln393">        || (i == kUIPopupmenu &amp;&amp; is_popupmenu)) {</a>
<a name="ln394">      VALIDATE_EXP((value.type == kObjectTypeBoolean), name.data, &quot;Boolean&quot;,</a>
<a name="ln395">                   api_typename(value.type), {</a>
<a name="ln396">        return;</a>
<a name="ln397">      });</a>
<a name="ln398">      bool boolval = value.data.boolean;</a>
<a name="ln399">      if (!init &amp;&amp; i == kUILinegrid &amp;&amp; boolval != ui-&gt;ui_ext[i]) {</a>
<a name="ln400">        // There shouldn't be a reason for a UI to do this ever</a>
<a name="ln401">        // so explicitly don't support this.</a>
<a name="ln402">        api_set_error(err, kErrorTypeValidation, &quot;ext_linegrid option cannot be changed&quot;);</a>
<a name="ln403">      }</a>
<a name="ln404">      ui-&gt;ui_ext[i] = boolval;</a>
<a name="ln405">      if (!init) {</a>
<a name="ln406">        ui_set_ext_option(ui, i, boolval);</a>
<a name="ln407">      }</a>
<a name="ln408">      return;</a>
<a name="ln409">    }</a>
<a name="ln410">  }</a>
<a name="ln411"> </a>
<a name="ln412">  api_set_error(err, kErrorTypeValidation, &quot;No such UI option: %s&quot;, name.data);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/// Tell Nvim to resize a grid. Triggers a grid_resize event with the requested</a>
<a name="ln416">/// grid size or the maximum size if it exceeds size limits.</a>
<a name="ln417">///</a>
<a name="ln418">/// On invalid grid handle, fails with error.</a>
<a name="ln419">///</a>
<a name="ln420">/// @param channel_id</a>
<a name="ln421">/// @param grid    The handle of the grid to be changed.</a>
<a name="ln422">/// @param width   The new requested width.</a>
<a name="ln423">/// @param height  The new requested height.</a>
<a name="ln424">/// @param[out] err Error details, if any</a>
<a name="ln425">void nvim_ui_try_resize_grid(uint64_t channel_id, Integer grid, Integer width, Integer height,</a>
<a name="ln426">                             Error *err)</a>
<a name="ln427">  FUNC_API_SINCE(6) FUNC_API_REMOTE_ONLY</a>
<a name="ln428">{</a>
<a name="ln429">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln430">    api_set_error(err, kErrorTypeException,</a>
<a name="ln431">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln432">    return;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  if (grid == DEFAULT_GRID_HANDLE) {</a>
<a name="ln436">    nvim_ui_try_resize(channel_id, width, height, err);</a>
<a name="ln437">  } else {</a>
<a name="ln438">    ui_grid_resize((handle_T)grid, (int)width, (int)height, err);</a>
<a name="ln439">  }</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">/// Tells Nvim the number of elements displaying in the popupmenu, to decide</a>
<a name="ln443">/// &lt;PageUp&gt; and &lt;PageDown&gt; movement.</a>
<a name="ln444">///</a>
<a name="ln445">/// @param channel_id</a>
<a name="ln446">/// @param height  Popupmenu height, must be greater than zero.</a>
<a name="ln447">/// @param[out] err Error details, if any</a>
<a name="ln448">void nvim_ui_pum_set_height(uint64_t channel_id, Integer height, Error *err)</a>
<a name="ln449">  FUNC_API_SINCE(6) FUNC_API_REMOTE_ONLY</a>
<a name="ln450">{</a>
<a name="ln451">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln452">    api_set_error(err, kErrorTypeException,</a>
<a name="ln453">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln454">    return;</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  if (height &lt;= 0) {</a>
<a name="ln458">    api_set_error(err, kErrorTypeValidation, &quot;Expected pum height &gt; 0&quot;);</a>
<a name="ln459">    return;</a>
<a name="ln460">  }</a>
<a name="ln461"> </a>
<a name="ln462">  UI *ui = pmap_get(uint64_t)(&amp;connected_uis, channel_id);</a>
<a name="ln463">  if (!ui-&gt;ui_ext[kUIPopupmenu]) {</a>
<a name="ln464">    api_set_error(err, kErrorTypeValidation,</a>
<a name="ln465">                  &quot;It must support the ext_popupmenu option&quot;);</a>
<a name="ln466">    return;</a>
<a name="ln467">  }</a>
<a name="ln468"> </a>
<a name="ln469">  ui-&gt;pum_nlines = (int)height;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/// Tells Nvim the geometry of the popupmenu, to align floating windows with an</a>
<a name="ln473">/// external popup menu.</a>
<a name="ln474">///</a>
<a name="ln475">/// Note that this method is not to be confused with |nvim_ui_pum_set_height()|,</a>
<a name="ln476">/// which sets the number of visible items in the popup menu, while this</a>
<a name="ln477">/// function sets the bounding box of the popup menu, including visual</a>
<a name="ln478">/// elements such as borders and sliders. Floats need not use the same font</a>
<a name="ln479">/// size, nor be anchored to exact grid corners, so one can set floating-point</a>
<a name="ln480">/// numbers to the popup menu geometry.</a>
<a name="ln481">///</a>
<a name="ln482">/// @param channel_id</a>
<a name="ln483">/// @param width   Popupmenu width.</a>
<a name="ln484">/// @param height  Popupmenu height.</a>
<a name="ln485">/// @param row     Popupmenu row.</a>
<a name="ln486">/// @param col     Popupmenu height.</a>
<a name="ln487">/// @param[out] err Error details, if any.</a>
<a name="ln488">void nvim_ui_pum_set_bounds(uint64_t channel_id, Float width, Float height, Float row, Float col,</a>
<a name="ln489">                            Error *err)</a>
<a name="ln490">  FUNC_API_SINCE(7) FUNC_API_REMOTE_ONLY</a>
<a name="ln491">{</a>
<a name="ln492">  if (!map_has(uint64_t, &amp;connected_uis, channel_id)) {</a>
<a name="ln493">    api_set_error(err, kErrorTypeException,</a>
<a name="ln494">                  &quot;UI not attached to channel: %&quot; PRId64, channel_id);</a>
<a name="ln495">    return;</a>
<a name="ln496">  }</a>
<a name="ln497"> </a>
<a name="ln498">  UI *ui = pmap_get(uint64_t)(&amp;connected_uis, channel_id);</a>
<a name="ln499">  if (!ui-&gt;ui_ext[kUIPopupmenu]) {</a>
<a name="ln500">    api_set_error(err, kErrorTypeValidation,</a>
<a name="ln501">                  &quot;UI must support the ext_popupmenu option&quot;);</a>
<a name="ln502">    return;</a>
<a name="ln503">  }</a>
<a name="ln504"> </a>
<a name="ln505">  if (width &lt;= 0) {</a>
<a name="ln506">    api_set_error(err, kErrorTypeValidation, &quot;Expected width &gt; 0&quot;);</a>
<a name="ln507">    return;</a>
<a name="ln508">  } else if (height &lt;= 0) {</a>
<a name="ln509">    api_set_error(err, kErrorTypeValidation, &quot;Expected height &gt; 0&quot;);</a>
<a name="ln510">    return;</a>
<a name="ln511">  }</a>
<a name="ln512"> </a>
<a name="ln513">  ui-&gt;pum_row = (double)row;</a>
<a name="ln514">  ui-&gt;pum_col = (double)col;</a>
<a name="ln515">  ui-&gt;pum_width = (double)width;</a>
<a name="ln516">  ui-&gt;pum_height = (double)height;</a>
<a name="ln517">  ui-&gt;pum_pos = true;</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">static void flush_event(UIData *data)</a>
<a name="ln521">{</a>
<a name="ln522">  if (data-&gt;cur_event) {</a>
<a name="ln523">    mpack_w2(&amp;data-&gt;ncalls_pos, data-&gt;ncalls);</a>
<a name="ln524">    data-&gt;cur_event = NULL;</a>
<a name="ln525">  }</a>
<a name="ln526">  if (!data-&gt;nevents_pos) {</a>
<a name="ln527">    assert(BUF_POS(data) == 0);</a>
<a name="ln528">    char **buf = &amp;data-&gt;buf_wptr;</a>
<a name="ln529">    // [2, &quot;redraw&quot;, [...]]</a>
<a name="ln530">    mpack_array(buf, 3);</a>
<a name="ln531">    mpack_uint(buf, 2);</a>
<a name="ln532">    mpack_str(buf, &quot;redraw&quot;);</a>
<a name="ln533">    data-&gt;nevents_pos = mpack_array_dyn16(buf);</a>
<a name="ln534">  }</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">static inline int write_cb(void *vdata, const char *buf, size_t len)</a>
<a name="ln538">{</a>
<a name="ln539">  UIData *data = (UIData *)vdata;</a>
<a name="ln540">  if (!buf) {</a>
<a name="ln541">    return 0;</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  data-&gt;pack_totlen += len;</a>
<a name="ln545">  if (!data-&gt;temp_buf &amp;&amp; UI_BUF_SIZE - BUF_POS(data) &lt; len) {</a>
<a name="ln546">    data-&gt;buf_overflow = true;</a>
<a name="ln547">    return 0;</a>
<a name="ln548">  }</a>
<a name="ln549"> </a>
<a name="ln550">  memcpy(data-&gt;buf_wptr, buf, len);</a>
<a name="ln551">  data-&gt;buf_wptr += len;</a>
<a name="ln552"> </a>
<a name="ln553">  return 0;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">static bool prepare_call(UI *ui, const char *name)</a>
<a name="ln557">{</a>
<a name="ln558">  UIData *data = ui-&gt;data;</a>
<a name="ln559"> </a>
<a name="ln560">  if (BUF_POS(data) &gt; UI_BUF_SIZE - EVENT_BUF_SIZE) {</a>
<a name="ln561">    remote_ui_flush_buf(ui);</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  // To optimize data transfer(especially for &quot;grid_line&quot;), we bundle adjacent</a>
<a name="ln565">  // calls to same method together, so only add a new call entry if the last</a>
<a name="ln566">  // method call is different from &quot;name&quot;</a>
<a name="ln567"> </a>
<a name="ln568">  if (!data-&gt;cur_event || !strequal(data-&gt;cur_event, name)) {</a>
<a name="ln569">    flush_event(data);</a>
<a name="ln570">    data-&gt;cur_event = name;</a>
<a name="ln571">    char **buf = &amp;data-&gt;buf_wptr;</a>
<a name="ln572">    data-&gt;ncalls_pos = mpack_array_dyn16(buf);</a>
<a name="ln573">    mpack_str(buf, name);</a>
<a name="ln574">    data-&gt;nevents++;</a>
<a name="ln575">    data-&gt;ncalls = 1;</a>
<a name="ln576">    return true;</a>
<a name="ln577">  }</a>
<a name="ln578"> </a>
<a name="ln579">  return false;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">/// Pushes data into UI.UIData, to be consumed later by remote_ui_flush().</a>
<a name="ln583">static void push_call(UI *ui, const char *name, Array args)</a>
<a name="ln584">{</a>
<a name="ln585">  UIData *data = ui-&gt;data;</a>
<a name="ln586">  bool pending = data-&gt;nevents_pos;</a>
<a name="ln587">  char *buf_pos_save = data-&gt;buf_wptr;</a>
<a name="ln588"> </a>
<a name="ln589">  bool new_event = prepare_call(ui, name);</a>
<a name="ln590"> </a>
<a name="ln591">  msgpack_packer pac;</a>
<a name="ln592">  data-&gt;pack_totlen = 0;</a>
<a name="ln593">  data-&gt;buf_overflow = false;</a>
<a name="ln594">  msgpack_packer_init(&amp;pac, data, write_cb);</a>
<a name="ln595">  msgpack_rpc_from_array(args, &amp;pac);</a>
<a name="ln596">  if (data-&gt;buf_overflow) {</a>
<a name="ln597">    data-&gt;buf_wptr = buf_pos_save;</a>
<a name="ln598">    if (new_event) {</a>
<a name="ln599">      data-&gt;cur_event = NULL;</a>
<a name="ln600">      data-&gt;nevents--;</a>
<a name="ln601">    }</a>
<a name="ln602">    if (pending) {</a>
<a name="ln603">      remote_ui_flush_buf(ui);</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">    if (data-&gt;pack_totlen &gt; UI_BUF_SIZE - strlen(name) - 20) {</a>
<a name="ln607">      // TODO(bfredl): manually testable by setting UI_BUF_SIZE to 1024 (mode_info_set)</a>
<a name="ln608">      data-&gt;temp_buf = xmalloc(20 + strlen(name) + data-&gt;pack_totlen);</a>
<a name="ln609">      data-&gt;buf_wptr = data-&gt;temp_buf;</a>
<a name="ln610">      char **buf = &amp;data-&gt;buf_wptr;</a>
<a name="ln611">      mpack_array(buf, 3);</a>
<a name="ln612">      mpack_uint(buf, 2);</a>
<a name="ln613">      mpack_str(buf, &quot;redraw&quot;);</a>
<a name="ln614">      mpack_array(buf, 1);</a>
<a name="ln615">      mpack_array(buf, 2);</a>
<a name="ln616">      mpack_str(buf, name);</a>
<a name="ln617">    } else {</a>
<a name="ln618">      prepare_call(ui, name);</a>
<a name="ln619">    }</a>
<a name="ln620">    data-&gt;pack_totlen = 0;</a>
<a name="ln621">    data-&gt;buf_overflow = false;</a>
<a name="ln622">    msgpack_rpc_from_array(args, &amp;pac);</a>
<a name="ln623"> </a>
<a name="ln624">    if (data-&gt;temp_buf) {</a>
<a name="ln625">      size_t size = (size_t)(data-&gt;buf_wptr - data-&gt;temp_buf);</a>
<a name="ln626">      WBuffer *buf = wstream_new_buffer(data-&gt;temp_buf, size, 1, xfree);</a>
<a name="ln627">      rpc_write_raw(data-&gt;channel_id, buf);</a>
<a name="ln628">      data-&gt;temp_buf = NULL;</a>
<a name="ln629">      data-&gt;buf_wptr = data-&gt;buf;</a>
<a name="ln630">      data-&gt;nevents_pos = NULL;</a>
<a name="ln631">    }</a>
<a name="ln632">  }</a>
<a name="ln633">  data-&gt;ncalls++;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">void remote_ui_grid_clear(UI *ui, Integer grid)</a>
<a name="ln637">{</a>
<a name="ln638">  UIData *data = ui-&gt;data;</a>
<a name="ln639">  Array args = data-&gt;call_buf;</a>
<a name="ln640">  if (ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln641">    ADD_C(args, INTEGER_OBJ(grid));</a>
<a name="ln642">  }</a>
<a name="ln643">  const char *name = ui-&gt;ui_ext[kUILinegrid] ? &quot;grid_clear&quot; : &quot;clear&quot;;</a>
<a name="ln644">  push_call(ui, name, args);</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">void remote_ui_grid_resize(UI *ui, Integer grid, Integer width, Integer height)</a>
<a name="ln648">{</a>
<a name="ln649">  UIData *data = ui-&gt;data;</a>
<a name="ln650">  Array args = data-&gt;call_buf;</a>
<a name="ln651">  if (ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln652">    ADD_C(args, INTEGER_OBJ(grid));</a>
<a name="ln653">  } else {</a>
<a name="ln654">    data-&gt;client_col = -1;  // force cursor update</a>
<a name="ln655">  }</a>
<a name="ln656">  ADD_C(args, INTEGER_OBJ(width));</a>
<a name="ln657">  ADD_C(args, INTEGER_OBJ(height));</a>
<a name="ln658">  const char *name = ui-&gt;ui_ext[kUILinegrid] ? &quot;grid_resize&quot; : &quot;resize&quot;;</a>
<a name="ln659">  push_call(ui, name, args);</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">void remote_ui_grid_scroll(UI *ui, Integer grid, Integer top, Integer bot, Integer left,</a>
<a name="ln663">                           Integer right, Integer rows, Integer cols)</a>
<a name="ln664">{</a>
<a name="ln665">  UIData *data = ui-&gt;data;</a>
<a name="ln666">  if (ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln667">    Array args = data-&gt;call_buf;</a>
<a name="ln668">    ADD_C(args, INTEGER_OBJ(grid));</a>
<a name="ln669">    ADD_C(args, INTEGER_OBJ(top));</a>
<a name="ln670">    ADD_C(args, INTEGER_OBJ(bot));</a>
<a name="ln671">    ADD_C(args, INTEGER_OBJ(left));</a>
<a name="ln672">    ADD_C(args, INTEGER_OBJ(right));</a>
<a name="ln673">    ADD_C(args, INTEGER_OBJ(rows));</a>
<a name="ln674">    ADD_C(args, INTEGER_OBJ(cols));</a>
<a name="ln675">    push_call(ui, &quot;grid_scroll&quot;, args);</a>
<a name="ln676">  } else {</a>
<a name="ln677">    Array args = data-&gt;call_buf;</a>
<a name="ln678">    ADD_C(args, INTEGER_OBJ(top));</a>
<a name="ln679">    ADD_C(args, INTEGER_OBJ(bot - 1));</a>
<a name="ln680">    ADD_C(args, INTEGER_OBJ(left));</a>
<a name="ln681">    ADD_C(args, INTEGER_OBJ(right - 1));</a>
<a name="ln682">    push_call(ui, &quot;set_scroll_region&quot;, args);</a>
<a name="ln683"> </a>
<a name="ln684">    args = data-&gt;call_buf;</a>
<a name="ln685">    ADD_C(args, INTEGER_OBJ(rows));</a>
<a name="ln686">    push_call(ui, &quot;scroll&quot;, args);</a>
<a name="ln687"> </a>
<a name="ln688">    // some clients have &quot;clear&quot; being affected by scroll region,</a>
<a name="ln689">    // so reset it.</a>
<a name="ln690">    args = data-&gt;call_buf;</a>
<a name="ln691">    ADD_C(args, INTEGER_OBJ(0));</a>
<a name="ln692">    ADD_C(args, INTEGER_OBJ(ui-&gt;height - 1));</a>
<a name="ln693">    ADD_C(args, INTEGER_OBJ(0));</a>
<a name="ln694">    ADD_C(args, INTEGER_OBJ(ui-&gt;width - 1));</a>
<a name="ln695">    push_call(ui, &quot;set_scroll_region&quot;, args);</a>
<a name="ln696">  }</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">void remote_ui_default_colors_set(UI *ui, Integer rgb_fg, Integer rgb_bg, Integer rgb_sp,</a>
<a name="ln700">                                  Integer cterm_fg, Integer cterm_bg)</a>
<a name="ln701">{</a>
<a name="ln702">  if (!ui-&gt;ui_ext[kUITermColors]) {</a>
<a name="ln703">    HL_SET_DEFAULT_COLORS(rgb_fg, rgb_bg, rgb_sp);</a>
<a name="ln704">  }</a>
<a name="ln705">  UIData *data = ui-&gt;data;</a>
<a name="ln706">  Array args = data-&gt;call_buf;</a>
<a name="ln707">  ADD_C(args, INTEGER_OBJ(rgb_fg));</a>
<a name="ln708">  ADD_C(args, INTEGER_OBJ(rgb_bg));</a>
<a name="ln709">  ADD_C(args, INTEGER_OBJ(rgb_sp));</a>
<a name="ln710">  ADD_C(args, INTEGER_OBJ(cterm_fg));</a>
<a name="ln711">  ADD_C(args, INTEGER_OBJ(cterm_bg));</a>
<a name="ln712">  push_call(ui, &quot;default_colors_set&quot;, args);</a>
<a name="ln713"> </a>
<a name="ln714">  // Deprecated</a>
<a name="ln715">  if (!ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln716">    args = data-&gt;call_buf;</a>
<a name="ln717">    ADD_C(args, INTEGER_OBJ(ui-&gt;rgb ? rgb_fg : cterm_fg - 1));</a>
<a name="ln718">    push_call(ui, &quot;update_fg&quot;, args);</a>
<a name="ln719"> </a>
<a name="ln720">    args = data-&gt;call_buf;</a>
<a name="ln721">    ADD_C(args, INTEGER_OBJ(ui-&gt;rgb ? rgb_bg : cterm_bg - 1));</a>
<a name="ln722">    push_call(ui, &quot;update_bg&quot;, args);</a>
<a name="ln723"> </a>
<a name="ln724">    args = data-&gt;call_buf;</a>
<a name="ln725">    ADD_C(args, INTEGER_OBJ(ui-&gt;rgb ? rgb_sp : -1));</a>
<a name="ln726">    push_call(ui, &quot;update_sp&quot;, args);</a>
<a name="ln727">  }</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">void remote_ui_hl_attr_define(UI *ui, Integer id, HlAttrs rgb_attrs, HlAttrs cterm_attrs,</a>
<a name="ln731">                              Array info)</a>
<a name="ln732">{</a>
<a name="ln733">  if (!ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln734">    return;</a>
<a name="ln735">  }</a>
<a name="ln736"> </a>
<a name="ln737">  UIData *data = ui-&gt;data;</a>
<a name="ln738">  Array args = data-&gt;call_buf;</a>
<a name="ln739">  ADD_C(args, INTEGER_OBJ(id));</a>
<a name="ln740">  MAXSIZE_TEMP_DICT(rgb, HLATTRS_DICT_SIZE);</a>
<a name="ln741">  MAXSIZE_TEMP_DICT(cterm, HLATTRS_DICT_SIZE);</a>
<a name="ln742">  hlattrs2dict(&amp;rgb, NULL, rgb_attrs, true, false);</a>
<a name="ln743">  hlattrs2dict(&amp;cterm, NULL, rgb_attrs, false, false);</a>
<a name="ln744">  ADD_C(args, DICTIONARY_OBJ(rgb));</a>
<a name="ln745">  ADD_C(args, DICTIONARY_OBJ(cterm));</a>
<a name="ln746"> </a>
<a name="ln747">  if (ui-&gt;ui_ext[kUIHlState]) {</a>
<a name="ln748">    ADD_C(args, ARRAY_OBJ(info));</a>
<a name="ln749">  } else {</a>
<a name="ln750">    ADD_C(args, ARRAY_OBJ((Array)ARRAY_DICT_INIT));</a>
<a name="ln751">  }</a>
<a name="ln752"> </a>
<a name="ln753">  push_call(ui, &quot;hl_attr_define&quot;, args);</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">void remote_ui_highlight_set(UI *ui, int id)</a>
<a name="ln757">{</a>
<a name="ln758">  UIData *data = ui-&gt;data;</a>
<a name="ln759">  Array args = data-&gt;call_buf;</a>
<a name="ln760"> </a>
<a name="ln761">  if (data-&gt;hl_id == id) {</a>
<a name="ln762">    return;</a>
<a name="ln763">  }</a>
<a name="ln764">  data-&gt;hl_id = id;</a>
<a name="ln765">  MAXSIZE_TEMP_DICT(dict, HLATTRS_DICT_SIZE);</a>
<a name="ln766">  hlattrs2dict(&amp;dict, NULL, syn_attr2entry(id), ui-&gt;rgb, false);</a>
<a name="ln767">  ADD_C(args, DICTIONARY_OBJ(dict));</a>
<a name="ln768">  push_call(ui, &quot;highlight_set&quot;, args);</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">/// &quot;true&quot; cursor used only for input focus</a>
<a name="ln772">void remote_ui_grid_cursor_goto(UI *ui, Integer grid, Integer row, Integer col)</a>
<a name="ln773">{</a>
<a name="ln774">  if (ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln775">    UIData *data = ui-&gt;data;</a>
<a name="ln776">    Array args = data-&gt;call_buf;</a>
<a name="ln777">    ADD_C(args, INTEGER_OBJ(grid));</a>
<a name="ln778">    ADD_C(args, INTEGER_OBJ(row));</a>
<a name="ln779">    ADD_C(args, INTEGER_OBJ(col));</a>
<a name="ln780">    push_call(ui, &quot;grid_cursor_goto&quot;, args);</a>
<a name="ln781">  } else {</a>
<a name="ln782">    UIData *data = ui-&gt;data;</a>
<a name="ln783">    data-&gt;cursor_row = row;</a>
<a name="ln784">    data-&gt;cursor_col = col;</a>
<a name="ln785">    remote_ui_cursor_goto(ui, row, col);</a>
<a name="ln786">  }</a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/// emulated cursor used both for drawing and for input focus</a>
<a name="ln790">void remote_ui_cursor_goto(UI *ui, Integer row, Integer col)</a>
<a name="ln791">{</a>
<a name="ln792">  UIData *data = ui-&gt;data;</a>
<a name="ln793">  if (data-&gt;client_row == row &amp;&amp; data-&gt;client_col == col) {</a>
<a name="ln794">    return;</a>
<a name="ln795">  }</a>
<a name="ln796">  data-&gt;client_row = row;</a>
<a name="ln797">  data-&gt;client_col = col;</a>
<a name="ln798">  Array args = data-&gt;call_buf;</a>
<a name="ln799">  ADD_C(args, INTEGER_OBJ(row));</a>
<a name="ln800">  ADD_C(args, INTEGER_OBJ(col));</a>
<a name="ln801">  push_call(ui, &quot;cursor_goto&quot;, args);</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">void remote_ui_put(UI *ui, const char *cell)</a>
<a name="ln805">{</a>
<a name="ln806">  UIData *data = ui-&gt;data;</a>
<a name="ln807">  data-&gt;client_col++;</a>
<a name="ln808">  Array args = data-&gt;call_buf;</a>
<a name="ln809">  ADD_C(args, CSTR_AS_OBJ((char *)cell));</a>
<a name="ln810">  push_call(ui, &quot;put&quot;, args);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">void remote_ui_raw_line(UI *ui, Integer grid, Integer row, Integer startcol, Integer endcol,</a>
<a name="ln814">                        Integer clearcol, Integer clearattr, LineFlags flags, const schar_T *chunk,</a>
<a name="ln815">                        const sattr_T *attrs)</a>
<a name="ln816">{</a>
<a name="ln817">  UIData *data = ui-&gt;data;</a>
<a name="ln818">  if (ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln819">    prepare_call(ui, &quot;grid_line&quot;);</a>
<a name="ln820">    data-&gt;ncalls++;</a>
<a name="ln821"> </a>
<a name="ln822">    char **buf = &amp;data-&gt;buf_wptr;</a>
<a name="ln823">    mpack_array(buf, 5);</a>
<a name="ln824">    mpack_uint(buf, (uint32_t)grid);</a>
<a name="ln825">    mpack_uint(buf, (uint32_t)row);</a>
<a name="ln826">    mpack_uint(buf, (uint32_t)startcol);</a>
<a name="ln827">    char *lenpos = mpack_array_dyn16(buf);</a>
<a name="ln828"> </a>
<a name="ln829">    uint32_t repeat = 0;</a>
<a name="ln830">    size_t ncells = (size_t)(endcol - startcol);</a>
<a name="ln831">    int last_hl = -1;</a>
<a name="ln832">    uint32_t nelem = 0;</a>
<a name="ln833">    bool was_space = false;</a>
<a name="ln834">    for (size_t i = 0; i &lt; ncells; i++) {</a>
<a name="ln835">      repeat++;</a>
<a name="ln836">      if (i == ncells - 1 || attrs[i] != attrs[i + 1]</a>
<a name="ln837">          || strcmp(chunk[i], chunk[i + 1]) != 0) {</a>
<a name="ln838">        if (UI_BUF_SIZE - BUF_POS(data) &lt; 2 * (1 + 2 + sizeof(schar_T) + 5 + 5) + 1) {</a>
<a name="ln839">          // close to overflowing the redraw buffer. finish this event,</a>
<a name="ln840">          // flush, and start a new &quot;grid_line&quot; event at the current position.</a>
<a name="ln841">          // For simplicity leave place for the final &quot;clear&quot; element</a>
<a name="ln842">          // as well, hence the factor of 2 in the check.</a>
<a name="ln843">          mpack_w2(&amp;lenpos, nelem);</a>
<a name="ln844"> </a>
<a name="ln845">          // We only ever set the wrap field on the final &quot;grid_line&quot; event for the line.</a>
<a name="ln846">          mpack_bool(buf, false);</a>
<a name="ln847">          remote_ui_flush_buf(ui);</a>
<a name="ln848"> </a>
<a name="ln849">          prepare_call(ui, &quot;grid_line&quot;);</a>
<a name="ln850">          data-&gt;ncalls++;</a>
<a name="ln851">          mpack_array(buf, 5);</a>
<a name="ln852">          mpack_uint(buf, (uint32_t)grid);</a>
<a name="ln853">          mpack_uint(buf, (uint32_t)row);</a>
<a name="ln854">          mpack_uint(buf, (uint32_t)startcol + (uint32_t)i - repeat + 1);</a>
<a name="ln855">          lenpos = mpack_array_dyn16(buf);</a>
<a name="ln856">          nelem = 0;</a>
<a name="ln857">          last_hl = -1;</a>
<a name="ln858">        }</a>
<a name="ln859">        uint32_t csize = (repeat &gt; 1) ? 3 : ((attrs[i] != last_hl) ? 2 : 1);</a>
<a name="ln860">        nelem++;</a>
<a name="ln861">        mpack_array(buf, csize);</a>
<a name="ln862">        mpack_str(buf, chunk[i]);</a>
<a name="ln863">        if (csize &gt;= 2) {</a>
<a name="ln864">          mpack_uint(buf, (uint32_t)attrs[i]);</a>
<a name="ln865">          if (csize &gt;= 3) {</a>
<a name="ln866">            mpack_uint(buf, repeat);</a>
<a name="ln867">          }</a>
<a name="ln868">        }</a>
<a name="ln869">        data-&gt;ncells_pending += MIN(repeat, 2);</a>
<a name="ln870">        last_hl = attrs[i];</a>
<a name="ln871">        repeat = 0;</a>
<a name="ln872">        was_space = strequal(chunk[i], &quot; &quot;);</a>
<a name="ln873">      }</a>
<a name="ln874">    }</a>
<a name="ln875">    // If the last chunk was all spaces, add a clearing chunk even if there are</a>
<a name="ln876">    // no more cells to clear, so there is no ambiguity about what to clear.</a>
<a name="ln877">    if (endcol &lt; clearcol || was_space) {</a>
<a name="ln878">      nelem++;</a>
<a name="ln879">      data-&gt;ncells_pending += 1;</a>
<a name="ln880">      mpack_array(buf, 3);</a>
<a name="ln881">      mpack_str(buf, &quot; &quot;);</a>
<a name="ln882">      mpack_uint(buf, (uint32_t)clearattr);</a>
<a name="ln883">      mpack_uint(buf, (uint32_t)(clearcol - endcol));</a>
<a name="ln884">    }</a>
<a name="ln885">    mpack_w2(&amp;lenpos, nelem);</a>
<a name="ln886">    mpack_bool(buf, flags &amp; kLineFlagWrap);</a>
<a name="ln887"> </a>
<a name="ln888">    if (data-&gt;ncells_pending &gt; 500) {</a>
<a name="ln889">      // pass off cells to UI to let it start processing them</a>
<a name="ln890">      remote_ui_flush_buf(ui);</a>
<a name="ln891">    }</a>
<a name="ln892">  } else {</a>
<a name="ln893">    for (int i = 0; i &lt; endcol - startcol; i++) {</a>
<a name="ln894">      remote_ui_cursor_goto(ui, row, startcol + i);</a>
<a name="ln895">      remote_ui_highlight_set(ui, attrs[i]);</a>
<a name="ln896">      remote_ui_put(ui, chunk[i]);</a>
<a name="ln897">      if (utf_ambiguous_width(utf_ptr2char((char *)chunk[i]))) {</a>
<a name="ln898">        data-&gt;client_col = -1;  // force cursor update</a>
<a name="ln899">      }</a>
<a name="ln900">    }</a>
<a name="ln901">    if (endcol &lt; clearcol) {</a>
<a name="ln902">      remote_ui_cursor_goto(ui, row, endcol);</a>
<a name="ln903">      remote_ui_highlight_set(ui, (int)clearattr);</a>
<a name="ln904">      // legacy eol_clear was only ever used with cleared attributes</a>
<a name="ln905">      // so be on the safe side</a>
<a name="ln906">      if (clearattr == 0 &amp;&amp; clearcol == Columns) {</a>
<a name="ln907">        Array args = ARRAY_DICT_INIT;</a>
<a name="ln908">        push_call(ui, &quot;eol_clear&quot;, args);</a>
<a name="ln909">      } else {</a>
<a name="ln910">        for (Integer c = endcol; c &lt; clearcol; c++) {</a>
<a name="ln911">          remote_ui_put(ui, &quot; &quot;);</a>
<a name="ln912">        }</a>
<a name="ln913">      }</a>
<a name="ln914">    }</a>
<a name="ln915">  }</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">/// Flush the internal packing buffer to the client.</a>
<a name="ln919">///</a>
<a name="ln920">/// This might happen multiple times before the actual ui_flush, if the</a>
<a name="ln921">/// total redraw size is large!</a>
<a name="ln922">void remote_ui_flush_buf(UI *ui)</a>
<a name="ln923">{</a>
<a name="ln924">  UIData *data = ui-&gt;data;</a>
<a name="ln925">  if (!data-&gt;nevents_pos) {</a>
<a name="ln926">    return;</a>
<a name="ln927">  }</a>
<a name="ln928">  if (data-&gt;cur_event) {</a>
<a name="ln929">    flush_event(data);</a>
<a name="ln930">  }</a>
<a name="ln931">  mpack_w2(&amp;data-&gt;nevents_pos, data-&gt;nevents);</a>
<a name="ln932">  data-&gt;nevents = 0;</a>
<a name="ln933">  data-&gt;nevents_pos = NULL;</a>
<a name="ln934"> </a>
<a name="ln935">  // TODO(bfredl): elide copy by a length one free-list like the arena</a>
<a name="ln936">  size_t size = BUF_POS(data);</a>
<a name="ln937">  WBuffer *buf = wstream_new_buffer(xmemdup(data-&gt;buf, size), size, 1, xfree);</a>
<a name="ln938">  rpc_write_raw(data-&gt;channel_id, buf);</a>
<a name="ln939">  data-&gt;buf_wptr = data-&gt;buf;</a>
<a name="ln940">  // we have sent events to the client, but possibly not yet the final &quot;flush&quot;</a>
<a name="ln941">  // event.</a>
<a name="ln942">  data-&gt;flushed_events = true;</a>
<a name="ln943"> </a>
<a name="ln944">  data-&gt;ncells_pending = 0;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/// An intentional flush (vsync) when Nvim is finished redrawing the screen</a>
<a name="ln948">///</a>
<a name="ln949">/// Clients can know this happened by a final &quot;flush&quot; event at the end of the</a>
<a name="ln950">/// &quot;redraw&quot; batch.</a>
<a name="ln951">void remote_ui_flush(UI *ui)</a>
<a name="ln952">{</a>
<a name="ln953">  UIData *data = ui-&gt;data;</a>
<a name="ln954">  if (data-&gt;nevents &gt; 0 || data-&gt;flushed_events) {</a>
<a name="ln955">    if (!ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln956">      remote_ui_cursor_goto(ui, data-&gt;cursor_row, data-&gt;cursor_col);</a>
<a name="ln957">    }</a>
<a name="ln958">    push_call(ui, &quot;flush&quot;, (Array)ARRAY_DICT_INIT);</a>
<a name="ln959">    remote_ui_flush_buf(ui);</a>
<a name="ln960">    data-&gt;flushed_events = false;</a>
<a name="ln961">  }</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">static Array translate_contents(UI *ui, Array contents, Arena *arena)</a>
<a name="ln965">{</a>
<a name="ln966">  Array new_contents = arena_array(arena, contents.size);</a>
<a name="ln967">  for (size_t i = 0; i &lt; contents.size; i++) {</a>
<a name="ln968">    Array item = contents.items[i].data.array;</a>
<a name="ln969">    Array new_item = arena_array(arena, 2);</a>
<a name="ln970">    int attr = (int)item.items[0].data.integer;</a>
<a name="ln971">    if (attr) {</a>
<a name="ln972">      Dictionary rgb_attrs = arena_dict(arena, HLATTRS_DICT_SIZE);</a>
<a name="ln973">      hlattrs2dict(&amp;rgb_attrs, NULL, syn_attr2entry(attr), ui-&gt;rgb, false);</a>
<a name="ln974">      ADD(new_item, DICTIONARY_OBJ(rgb_attrs));</a>
<a name="ln975">    } else {</a>
<a name="ln976">      ADD(new_item, DICTIONARY_OBJ((Dictionary)ARRAY_DICT_INIT));</a>
<a name="ln977">    }</a>
<a name="ln978">    ADD(new_item, item.items[1]);</a>
<a name="ln979">    ADD(new_contents, ARRAY_OBJ(new_item));</a>
<a name="ln980">  }</a>
<a name="ln981">  return new_contents;</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984">static Array translate_firstarg(UI *ui, Array args, Arena *arena)</a>
<a name="ln985">{</a>
<a name="ln986">  Array new_args = arena_array(arena, args.size);</a>
<a name="ln987">  Array contents = args.items[0].data.array;</a>
<a name="ln988"> </a>
<a name="ln989">  ADD_C(new_args, ARRAY_OBJ(translate_contents(ui, contents, arena)));</a>
<a name="ln990">  for (size_t i = 1; i &lt; args.size; i++) {</a>
<a name="ln991">    ADD(new_args, args.items[i]);</a>
<a name="ln992">  }</a>
<a name="ln993">  return new_args;</a>
<a name="ln994">}</a>
<a name="ln995"> </a>
<a name="ln996">void remote_ui_event(UI *ui, char *name, Array args)</a>
<a name="ln997">{</a>
<a name="ln998">  Arena arena = ARENA_EMPTY;</a>
<a name="ln999">  UIData *data = ui-&gt;data;</a>
<a name="ln1000">  if (!ui-&gt;ui_ext[kUILinegrid]) {</a>
<a name="ln1001">    // the representation of highlights in cmdline changed, translate back</a>
<a name="ln1002">    // never consumes args</a>
<a name="ln1003">    if (strequal(name, &quot;cmdline_show&quot;)) {</a>
<a name="ln1004">      Array new_args = translate_firstarg(ui, args, &amp;arena);</a>
<a name="ln1005">      push_call(ui, name, new_args);</a>
<a name="ln1006">      goto free_ret;</a>
<a name="ln1007">    } else if (strequal(name, &quot;cmdline_block_show&quot;)) {</a>
<a name="ln1008">      Array new_args = data-&gt;call_buf;</a>
<a name="ln1009">      Array block = args.items[0].data.array;</a>
<a name="ln1010">      Array new_block = arena_array(&amp;arena, block.size);</a>
<a name="ln1011">      for (size_t i = 0; i &lt; block.size; i++) {</a>
<a name="ln1012">        ADD_C(new_block, ARRAY_OBJ(translate_contents(ui, block.items[i].data.array, &amp;arena)));</a>
<a name="ln1013">      }</a>
<a name="ln1014">      ADD_C(new_args, ARRAY_OBJ(new_block));</a>
<a name="ln1015">      push_call(ui, name, new_args);</a>
<a name="ln1016">      goto free_ret;</a>
<a name="ln1017">    } else if (strequal(name, &quot;cmdline_block_append&quot;)) {</a>
<a name="ln1018">      Array new_args = translate_firstarg(ui, args, &amp;arena);</a>
<a name="ln1019">      push_call(ui, name, new_args);</a>
<a name="ln1020">      goto free_ret;</a>
<a name="ln1021">    }</a>
<a name="ln1022">  }</a>
<a name="ln1023"> </a>
<a name="ln1024">  // Back-compat: translate popupmenu_xx to legacy wildmenu_xx.</a>
<a name="ln1025">  if (ui-&gt;ui_ext[kUIWildmenu]) {</a>
<a name="ln1026">    if (strequal(name, &quot;popupmenu_show&quot;)) {</a>
<a name="ln1027">      data-&gt;wildmenu_active = (args.items[4].data.integer == -1)</a>
<a name="ln1028">                              || !ui-&gt;ui_ext[kUIPopupmenu];</a>
<a name="ln1029">      if (data-&gt;wildmenu_active) {</a>
<a name="ln1030">        Array new_args = data-&gt;call_buf;</a>
<a name="ln1031">        Array items = args.items[0].data.array;</a>
<a name="ln1032">        Array new_items = arena_array(&amp;arena, items.size);</a>
<a name="ln1033">        for (size_t i = 0; i &lt; items.size; i++) {</a>
<a name="ln1034">          ADD_C(new_items, items.items[i].data.array.items[0]);</a>
<a name="ln1035">        }</a>
<a name="ln1036">        ADD_C(new_args, ARRAY_OBJ(new_items));</a>
<a name="ln1037">        push_call(ui, &quot;wildmenu_show&quot;, new_args);</a>
<a name="ln1038">        if (args.items[1].data.integer != -1) {</a>
<a name="ln1039">          Array new_args2 = data-&gt;call_buf;</a>
<a name="ln1040">          ADD_C(new_args2, args.items[1]);</a>
<a name="ln1041">          push_call(ui, &quot;wildmenu_select&quot;, new_args2);</a>
<a name="ln1042">        }</a>
<a name="ln1043">        goto free_ret;</a>
<a name="ln1044">      }</a>
<a name="ln1045">    } else if (strequal(name, &quot;popupmenu_select&quot;)) {</a>
<a name="ln1046">      if (data-&gt;wildmenu_active) {</a>
<a name="ln1047">        name = &quot;wildmenu_select&quot;;</a>
<a name="ln1048">      }</a>
<a name="ln1049">    } else if (strequal(name, &quot;popupmenu_hide&quot;)) {</a>
<a name="ln1050">      if (data-&gt;wildmenu_active) {</a>
<a name="ln1051">        name = &quot;wildmenu_hide&quot;;</a>
<a name="ln1052">      }</a>
<a name="ln1053">    }</a>
<a name="ln1054">  }</a>
<a name="ln1055"> </a>
<a name="ln1056">  push_call(ui, name, args);</a>
<a name="ln1057">  return;</a>
<a name="ln1058"> </a>
<a name="ln1059">free_ret:</a>
<a name="ln1060">  arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">void remote_ui_inspect(UI *ui, Dictionary *info)</a>
<a name="ln1064">{</a>
<a name="ln1065">  UIData *data = ui-&gt;data;</a>
<a name="ln1066">  PUT(*info, &quot;chan&quot;, INTEGER_OBJ((Integer)data-&gt;channel_id));</a>
<a name="ln1067">}</a>
</code></pre>
<div class="balloon" rel="78"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v564/" target="_blank">V564</a> The '|' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '||' operator.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>