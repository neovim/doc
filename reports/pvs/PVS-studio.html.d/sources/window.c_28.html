<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>window.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;ctype.h&gt;</a>
<a name="ln6">#include &lt;inttypes.h&gt;</a>
<a name="ln7">#include &lt;limits.h&gt;</a>
<a name="ln8">#include &lt;stdbool.h&gt;</a>
<a name="ln9">#include &lt;stddef.h&gt;</a>
<a name="ln10">#include &lt;stdio.h&gt;</a>
<a name="ln11">#include &lt;stdlib.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;klib/kvec.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln17">#include &quot;nvim/arglist.h&quot;</a>
<a name="ln18">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln19">#include &quot;nvim/autocmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln21">#include &quot;nvim/buffer_defs.h&quot;</a>
<a name="ln22">#include &quot;nvim/charset.h&quot;</a>
<a name="ln23">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln24">#include &quot;nvim/decoration.h&quot;</a>
<a name="ln25">#include &quot;nvim/diff.h&quot;</a>
<a name="ln26">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln27">#include &quot;nvim/edit.h&quot;</a>
<a name="ln28">#include &quot;nvim/eval.h&quot;</a>
<a name="ln29">#include &quot;nvim/eval/typval.h&quot;</a>
<a name="ln30">#include &quot;nvim/eval/vars.h&quot;</a>
<a name="ln31">#include &quot;nvim/eval/window.h&quot;</a>
<a name="ln32">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln33">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln34">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln35">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln36">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln37">#include &quot;nvim/file_search.h&quot;</a>
<a name="ln38">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln39">#include &quot;nvim/fold.h&quot;</a>
<a name="ln40">#include &quot;nvim/garray.h&quot;</a>
<a name="ln41">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln42">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln43">#include &quot;nvim/globals.h&quot;</a>
<a name="ln44">#include &quot;nvim/grid.h&quot;</a>
<a name="ln45">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln46">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln47">#include &quot;nvim/macros.h&quot;</a>
<a name="ln48">#include &quot;nvim/main.h&quot;</a>
<a name="ln49">#include &quot;nvim/map.h&quot;</a>
<a name="ln50">#include &quot;nvim/mapping.h&quot;  // IWYU pragma: keep (langmap_adjust_mb)</a>
<a name="ln51">#include &quot;nvim/mark.h&quot;</a>
<a name="ln52">#include &quot;nvim/match.h&quot;</a>
<a name="ln53">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln54">#include &quot;nvim/memory.h&quot;</a>
<a name="ln55">#include &quot;nvim/message.h&quot;</a>
<a name="ln56">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln57">#include &quot;nvim/move.h&quot;</a>
<a name="ln58">#include &quot;nvim/normal.h&quot;</a>
<a name="ln59">#include &quot;nvim/option.h&quot;</a>
<a name="ln60">#include &quot;nvim/option_defs.h&quot;</a>
<a name="ln61">#include &quot;nvim/option_vars.h&quot;</a>
<a name="ln62">#include &quot;nvim/optionstr.h&quot;</a>
<a name="ln63">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln64">#include &quot;nvim/os/os_defs.h&quot;</a>
<a name="ln65">#include &quot;nvim/path.h&quot;</a>
<a name="ln66">#include &quot;nvim/plines.h&quot;</a>
<a name="ln67">#include &quot;nvim/pos.h&quot;</a>
<a name="ln68">#include &quot;nvim/quickfix.h&quot;</a>
<a name="ln69">#include &quot;nvim/search.h&quot;</a>
<a name="ln70">#include &quot;nvim/state.h&quot;</a>
<a name="ln71">#include &quot;nvim/statusline.h&quot;</a>
<a name="ln72">#include &quot;nvim/strings.h&quot;</a>
<a name="ln73">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln74">#include &quot;nvim/terminal.h&quot;</a>
<a name="ln75">#include &quot;nvim/types.h&quot;</a>
<a name="ln76">#include &quot;nvim/ui.h&quot;</a>
<a name="ln77">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln78">#include &quot;nvim/undo.h&quot;</a>
<a name="ln79">#include &quot;nvim/vim.h&quot;</a>
<a name="ln80">#include &quot;nvim/window.h&quot;</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln83"># include &quot;window.c.generated.h&quot;</a>
<a name="ln84">#endif</a>
<a name="ln85"> </a>
<a name="ln86">#define NOWIN           ((win_T *)-1)   // non-existing window</a>
<a name="ln87"> </a>
<a name="ln88">#define ROWS_AVAIL (Rows - p_ch - tabline_height() - global_stl_height())</a>
<a name="ln89"> </a>
<a name="ln90">/// flags for win_enter_ext()</a>
<a name="ln91">typedef enum {</a>
<a name="ln92">  WEE_UNDO_SYNC = 0x01,</a>
<a name="ln93">  WEE_CURWIN_INVALID = 0x02,</a>
<a name="ln94">  WEE_TRIGGER_NEW_AUTOCMDS = 0x04,</a>
<a name="ln95">  WEE_TRIGGER_ENTER_AUTOCMDS = 0x08,</a>
<a name="ln96">  WEE_TRIGGER_LEAVE_AUTOCMDS = 0x10,</a>
<a name="ln97">} wee_flags_T;</a>
<a name="ln98"> </a>
<a name="ln99">static const char e_cannot_split_window_when_closing_buffer[]</a>
<a name="ln100">  = N_(&quot;E1159: Cannot split a window when closing the buffer&quot;);</a>
<a name="ln101"> </a>
<a name="ln102">static char *m_onlyone = N_(&quot;Already only one window&quot;);</a>
<a name="ln103"> </a>
<a name="ln104">/// When non-zero splitting a window is forbidden.  Used to avoid that nasty</a>
<a name="ln105">/// autocommands mess up the window structure.</a>
<a name="ln106">static int split_disallowed = 0;</a>
<a name="ln107"> </a>
<a name="ln108">// #define WIN_DEBUG</a>
<a name="ln109">#ifdef WIN_DEBUG</a>
<a name="ln110">/// Call this method to log the current window layout.</a>
<a name="ln111">static void log_frame_layout(frame_T *frame)</a>
<a name="ln112">{</a>
<a name="ln113">  DLOG(&quot;layout %s, wi: %d, he: %d, wwi: %d, whe: %d, id: %d&quot;,</a>
<a name="ln114">       frame-&gt;fr_layout == FR_LEAF ? &quot;LEAF&quot; : frame-&gt;fr_layout == FR_ROW ? &quot;ROW&quot; : &quot;COL&quot;,</a>
<a name="ln115">       frame-&gt;fr_width,</a>
<a name="ln116">       frame-&gt;fr_height,</a>
<a name="ln117">       frame-&gt;fr_win == NULL ? -1 : frame-&gt;fr_win-&gt;w_width,</a>
<a name="ln118">       frame-&gt;fr_win == NULL ? -1 : frame-&gt;fr_win-&gt;w_height,</a>
<a name="ln119">       frame-&gt;fr_win == NULL ? -1 : frame-&gt;fr_win-&gt;w_id);</a>
<a name="ln120">  if (frame-&gt;fr_child != NULL) {</a>
<a name="ln121">    DLOG(&quot;children&quot;);</a>
<a name="ln122">    log_frame_layout(frame-&gt;fr_child);</a>
<a name="ln123">    if (frame-&gt;fr_next != NULL) {</a>
<a name="ln124">      DLOG(&quot;END of children&quot;);</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127">  if (frame-&gt;fr_next != NULL) {</a>
<a name="ln128">    log_frame_layout(frame-&gt;fr_next);</a>
<a name="ln129">  }</a>
<a name="ln130">}</a>
<a name="ln131">#endif</a>
<a name="ln132"> </a>
<a name="ln133">/// @return the current window, unless in the cmdline window and &quot;prevwin&quot; is</a>
<a name="ln134">/// set, then return &quot;prevwin&quot;.</a>
<a name="ln135">win_T *prevwin_curwin(void)</a>
<a name="ln136">  FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln137">{</a>
<a name="ln138">  // In cmdwin, the alternative buffer should be used.</a>
<a name="ln139">  return is_in_cmdwin() &amp;&amp; prevwin != NULL ? prevwin : curwin;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/// If the 'switchbuf' option contains &quot;useopen&quot; or &quot;usetab&quot;, then try to jump</a>
<a name="ln143">/// to a window containing &quot;buf&quot;.</a>
<a name="ln144">/// Returns the pointer to the window that was jumped to or NULL.</a>
<a name="ln145">win_T *swbuf_goto_win_with_buf(buf_T *buf)</a>
<a name="ln146">{</a>
<a name="ln147">  win_T *wp = NULL;</a>
<a name="ln148"> </a>
<a name="ln149">  if (buf == NULL) {</a>
<a name="ln150">    return wp;</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  // If 'switchbuf' contains &quot;useopen&quot;: jump to first window in the current</a>
<a name="ln154">  // tab page containing &quot;buf&quot; if one exists.</a>
<a name="ln155">  if (swb_flags &amp; SWB_USEOPEN) {</a>
<a name="ln156">    wp = buf_jump_open_win(buf);</a>
<a name="ln157">  }</a>
<a name="ln158"> </a>
<a name="ln159">  // If 'switchbuf' contains &quot;usetab&quot;: jump to first window in any tab page</a>
<a name="ln160">  // containing &quot;buf&quot; if one exists.</a>
<a name="ln161">  if (wp == NULL &amp;&amp; (swb_flags &amp; SWB_USETAB)) {</a>
<a name="ln162">    wp = buf_jump_open_tab(buf);</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  return wp;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">/// all CTRL-W window commands are handled here, called from normal_cmd().</a>
<a name="ln169">///</a>
<a name="ln170">/// @param xchar  extra char from &quot;:wincmd gx&quot; or NUL</a>
<a name="ln171">void do_window(int nchar, int Prenum, int xchar)</a>
<a name="ln172">{</a>
<a name="ln173">  int type = FIND_DEFINE;</a>
<a name="ln174">  char cbuf[40];</a>
<a name="ln175"> </a>
<a name="ln176">  int Prenum1 = Prenum == 0 ? 1 : Prenum;</a>
<a name="ln177"> </a>
<a name="ln178">#define CHECK_CMDWIN \</a>
<a name="ln179">  do { \</a>
<a name="ln180">    if (cmdwin_type != 0) { \</a>
<a name="ln181">      emsg(_(e_cmdwin)); \</a>
<a name="ln182">      return; \</a>
<a name="ln183">    } \</a>
<a name="ln184">  } while (0)</a>
<a name="ln185"> </a>
<a name="ln186">  switch (nchar) {</a>
<a name="ln187">  // split current window in two parts, horizontally</a>
<a name="ln188">  case 'S':</a>
<a name="ln189">  case Ctrl_S:</a>
<a name="ln190">  case 's':</a>
<a name="ln191">    CHECK_CMDWIN;</a>
<a name="ln192">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln193">    // When splitting the quickfix window open a new buffer in it,</a>
<a name="ln194">    // don't replicate the quickfix buffer.</a>
<a name="ln195">    if (bt_quickfix(curbuf)) {</a>
<a name="ln196">      goto newwindow;</a>
<a name="ln197">    }</a>
<a name="ln198">    (void)win_split(Prenum, 0);</a>
<a name="ln199">    break;</a>
<a name="ln200"> </a>
<a name="ln201">  // split current window in two parts, vertically</a>
<a name="ln202">  case Ctrl_V:</a>
<a name="ln203">  case 'v':</a>
<a name="ln204">    CHECK_CMDWIN;</a>
<a name="ln205">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln206">    // When splitting the quickfix window open a new buffer in it,</a>
<a name="ln207">    // don't replicate the quickfix buffer.</a>
<a name="ln208">    if (bt_quickfix(curbuf)) {</a>
<a name="ln209">      goto newwindow;</a>
<a name="ln210">    }</a>
<a name="ln211">    (void)win_split(Prenum, WSP_VERT);</a>
<a name="ln212">    break;</a>
<a name="ln213"> </a>
<a name="ln214">  // split current window and edit alternate file</a>
<a name="ln215">  case Ctrl_HAT:</a>
<a name="ln216">  case '^':</a>
<a name="ln217">    CHECK_CMDWIN;</a>
<a name="ln218">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln219"> </a>
<a name="ln220">    if (buflist_findnr(Prenum == 0 ? curwin-&gt;w_alt_fnum : Prenum) == NULL) {</a>
<a name="ln221">      if (Prenum == 0) {</a>
<a name="ln222">        emsg(_(e_noalt));</a>
<a name="ln223">      } else {</a>
<a name="ln224">        semsg(_(&quot;E92: Buffer %&quot; PRId64 &quot; not found&quot;), (int64_t)Prenum);</a>
<a name="ln225">      }</a>
<a name="ln226">      break;</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">    if (!curbuf_locked() &amp;&amp; win_split(0, 0) == OK) {</a>
<a name="ln230">      (void)buflist_getfile(Prenum == 0 ? curwin-&gt;w_alt_fnum : Prenum,</a>
<a name="ln231">                            (linenr_T)0, GETF_ALT, false);</a>
<a name="ln232">    }</a>
<a name="ln233">    break;</a>
<a name="ln234"> </a>
<a name="ln235">  // open new window</a>
<a name="ln236">  case Ctrl_N:</a>
<a name="ln237">  case 'n':</a>
<a name="ln238">    CHECK_CMDWIN;</a>
<a name="ln239">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln240">newwindow:</a>
<a name="ln241">    if (Prenum) {</a>
<a name="ln242">      // window height</a>
<a name="ln243">      vim_snprintf(cbuf, sizeof(cbuf) - 5, &quot;%&quot; PRId64, (int64_t)Prenum);</a>
<a name="ln244">    } else {</a>
<a name="ln245">      cbuf[0] = NUL;</a>
<a name="ln246">    }</a>
<a name="ln247">    if (nchar == 'v' || nchar == Ctrl_V) {</a>
<a name="ln248">      xstrlcat(cbuf, &quot;v&quot;, sizeof(cbuf));</a>
<a name="ln249">    }</a>
<a name="ln250">    xstrlcat(cbuf, &quot;new&quot;, sizeof(cbuf));</a>
<a name="ln251">    do_cmdline_cmd(cbuf);</a>
<a name="ln252">    break;</a>
<a name="ln253"> </a>
<a name="ln254">  // quit current window</a>
<a name="ln255">  case Ctrl_Q:</a>
<a name="ln256">  case 'q':</a>
<a name="ln257">    reset_VIsual_and_resel();                   // stop Visual mode</a>
<a name="ln258">    cmd_with_count(&quot;quit&quot;, cbuf, sizeof(cbuf), Prenum);</a>
<a name="ln259">    do_cmdline_cmd(cbuf);</a>
<a name="ln260">    break;</a>
<a name="ln261"> </a>
<a name="ln262">  // close current window</a>
<a name="ln263">  case Ctrl_C:</a>
<a name="ln264">  case 'c':</a>
<a name="ln265">    reset_VIsual_and_resel();                   // stop Visual mode</a>
<a name="ln266">    cmd_with_count(&quot;close&quot;, cbuf, sizeof(cbuf), Prenum);</a>
<a name="ln267">    do_cmdline_cmd(cbuf);</a>
<a name="ln268">    break;</a>
<a name="ln269"> </a>
<a name="ln270">  // close preview window</a>
<a name="ln271">  case Ctrl_Z:</a>
<a name="ln272">  case 'z':</a>
<a name="ln273">    CHECK_CMDWIN;</a>
<a name="ln274">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln275">    do_cmdline_cmd(&quot;pclose&quot;);</a>
<a name="ln276">    break;</a>
<a name="ln277"> </a>
<a name="ln278">  // cursor to preview window</a>
<a name="ln279">  case 'P': {</a>
<a name="ln280">    win_T *wp = NULL;</a>
<a name="ln281">    FOR_ALL_WINDOWS_IN_TAB(wp2, curtab) {</a>
<a name="ln282">      if (wp2-&gt;w_p_pvw) {</a>
<a name="ln283">        wp = wp2;</a>
<a name="ln284">        break;</a>
<a name="ln285">      }</a>
<a name="ln286">    }</a>
<a name="ln287">    if (wp == NULL) {</a>
<a name="ln288">      emsg(_(&quot;E441: There is no preview window&quot;));</a>
<a name="ln289">    } else {</a>
<a name="ln290">      win_goto(wp);</a>
<a name="ln291">    }</a>
<a name="ln292">    break;</a>
<a name="ln293">  }</a>
<a name="ln294"> </a>
<a name="ln295">  // close all but current window</a>
<a name="ln296">  case Ctrl_O:</a>
<a name="ln297">  case 'o':</a>
<a name="ln298">    CHECK_CMDWIN;</a>
<a name="ln299">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln300">    cmd_with_count(&quot;only&quot;, cbuf, sizeof(cbuf), Prenum);</a>
<a name="ln301">    do_cmdline_cmd(cbuf);</a>
<a name="ln302">    break;</a>
<a name="ln303"> </a>
<a name="ln304">  // cursor to next window with wrap around</a>
<a name="ln305">  case Ctrl_W:</a>
<a name="ln306">  case 'w':</a>
<a name="ln307">  // cursor to previous window with wrap around</a>
<a name="ln308">  case 'W':</a>
<a name="ln309">    CHECK_CMDWIN;</a>
<a name="ln310">    if (ONE_WINDOW &amp;&amp; Prenum != 1) {  // just one window</a>
<a name="ln311">      beep_flush();</a>
<a name="ln312">    } else {</a>
<a name="ln313">      win_T *wp;</a>
<a name="ln314">      if (Prenum) {  // go to specified window</a>
<a name="ln315">        for (wp = firstwin; --Prenum &gt; 0;) {</a>
<a name="ln316">          if (wp-&gt;w_next == NULL) {</a>
<a name="ln317">            break;</a>
<a name="ln318">          }</a>
<a name="ln319">          wp = wp-&gt;w_next;</a>
<a name="ln320">        }</a>
<a name="ln321">      } else {</a>
<a name="ln322">        if (nchar == 'W') {  // go to previous window</a>
<a name="ln323">          wp = curwin-&gt;w_prev;</a>
<a name="ln324">          if (wp == NULL) {</a>
<a name="ln325">            wp = lastwin;  // wrap around</a>
<a name="ln326">          }</a>
<a name="ln327">          while (wp != NULL &amp;&amp; wp-&gt;w_floating</a>
<a name="ln328">                 &amp;&amp; !wp-&gt;w_float_config.focusable) {</a>
<a name="ln329">            wp = wp-&gt;w_prev;</a>
<a name="ln330">          }</a>
<a name="ln331">        } else {  // go to next window</a>
<a name="ln332">          wp = curwin-&gt;w_next;</a>
<a name="ln333">          while (wp != NULL &amp;&amp; wp-&gt;w_floating</a>
<a name="ln334">                 &amp;&amp; !wp-&gt;w_float_config.focusable) {</a>
<a name="ln335">            wp = wp-&gt;w_next;</a>
<a name="ln336">          }</a>
<a name="ln337">          if (wp == NULL) {</a>
<a name="ln338">            wp = firstwin;  // wrap around</a>
<a name="ln339">          }</a>
<a name="ln340">        }</a>
<a name="ln341">      }</a>
<a name="ln342">      win_goto(wp);</a>
<a name="ln343">    }</a>
<a name="ln344">    break;</a>
<a name="ln345"> </a>
<a name="ln346">  // cursor to window below</a>
<a name="ln347">  case 'j':</a>
<a name="ln348">  case K_DOWN:</a>
<a name="ln349">  case Ctrl_J:</a>
<a name="ln350">    CHECK_CMDWIN;</a>
<a name="ln351">    win_goto_ver(false, Prenum1);</a>
<a name="ln352">    break;</a>
<a name="ln353"> </a>
<a name="ln354">  // cursor to window above</a>
<a name="ln355">  case 'k':</a>
<a name="ln356">  case K_UP:</a>
<a name="ln357">  case Ctrl_K:</a>
<a name="ln358">    CHECK_CMDWIN;</a>
<a name="ln359">    win_goto_ver(true, Prenum1);</a>
<a name="ln360">    break;</a>
<a name="ln361"> </a>
<a name="ln362">  // cursor to left window</a>
<a name="ln363">  case 'h':</a>
<a name="ln364">  case K_LEFT:</a>
<a name="ln365">  case Ctrl_H:</a>
<a name="ln366">  case K_BS:</a>
<a name="ln367">    CHECK_CMDWIN;</a>
<a name="ln368">    win_goto_hor(true, Prenum1);</a>
<a name="ln369">    break;</a>
<a name="ln370"> </a>
<a name="ln371">  // cursor to right window</a>
<a name="ln372">  case 'l':</a>
<a name="ln373">  case K_RIGHT:</a>
<a name="ln374">  case Ctrl_L:</a>
<a name="ln375">    CHECK_CMDWIN;</a>
<a name="ln376">    win_goto_hor(false, Prenum1);</a>
<a name="ln377">    break;</a>
<a name="ln378"> </a>
<a name="ln379">  // move window to new tab page</a>
<a name="ln380">  case 'T':</a>
<a name="ln381">    CHECK_CMDWIN;</a>
<a name="ln382">    if (one_window(curwin)) {</a>
<a name="ln383">      msg(_(m_onlyone), 0);</a>
<a name="ln384">    } else {</a>
<a name="ln385">      tabpage_T *oldtab = curtab;</a>
<a name="ln386"> </a>
<a name="ln387">      // First create a new tab with the window, then go back to</a>
<a name="ln388">      // the old tab and close the window there.</a>
<a name="ln389">      win_T *wp = curwin;</a>
<a name="ln390">      if (win_new_tabpage(Prenum, NULL) == OK</a>
<a name="ln391">          &amp;&amp; valid_tabpage(oldtab)) {</a>
<a name="ln392">        tabpage_T *newtab = curtab;</a>
<a name="ln393">        goto_tabpage_tp(oldtab, true, true);</a>
<a name="ln394">        if (curwin == wp) {</a>
<a name="ln395">          win_close(curwin, false, false);</a>
<a name="ln396">        }</a>
<a name="ln397">        if (valid_tabpage(newtab)) {</a>
<a name="ln398">          goto_tabpage_tp(newtab, true, true);</a>
<a name="ln399">          apply_autocmds(EVENT_TABNEWENTERED, NULL, NULL, false, curbuf);</a>
<a name="ln400">        }</a>
<a name="ln401">      }</a>
<a name="ln402">    }</a>
<a name="ln403">    break;</a>
<a name="ln404"> </a>
<a name="ln405">  // cursor to top-left window</a>
<a name="ln406">  case 't':</a>
<a name="ln407">  case Ctrl_T:</a>
<a name="ln408">    win_goto(firstwin);</a>
<a name="ln409">    break;</a>
<a name="ln410"> </a>
<a name="ln411">  // cursor to bottom-right window</a>
<a name="ln412">  case 'b':</a>
<a name="ln413">  case Ctrl_B:</a>
<a name="ln414">    win_goto(lastwin_nofloating());</a>
<a name="ln415">    break;</a>
<a name="ln416"> </a>
<a name="ln417">  // cursor to last accessed (previous) window</a>
<a name="ln418">  case 'p':</a>
<a name="ln419">  case Ctrl_P:</a>
<a name="ln420">    if (!win_valid(prevwin)) {</a>
<a name="ln421">      beep_flush();</a>
<a name="ln422">    } else {</a>
<a name="ln423">      win_goto(prevwin);</a>
<a name="ln424">    }</a>
<a name="ln425">    break;</a>
<a name="ln426"> </a>
<a name="ln427">  // exchange current and next window</a>
<a name="ln428">  case 'x':</a>
<a name="ln429">  case Ctrl_X:</a>
<a name="ln430">    CHECK_CMDWIN;</a>
<a name="ln431">    win_exchange(Prenum);</a>
<a name="ln432">    break;</a>
<a name="ln433"> </a>
<a name="ln434">  // rotate windows downwards</a>
<a name="ln435">  case Ctrl_R:</a>
<a name="ln436">  case 'r':</a>
<a name="ln437">    CHECK_CMDWIN;</a>
<a name="ln438">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln439">    win_rotate(false, Prenum1);  // downwards</a>
<a name="ln440">    break;</a>
<a name="ln441"> </a>
<a name="ln442">  // rotate windows upwards</a>
<a name="ln443">  case 'R':</a>
<a name="ln444">    CHECK_CMDWIN;</a>
<a name="ln445">    reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln446">    win_rotate(true, Prenum1);  // upwards</a>
<a name="ln447">    break;</a>
<a name="ln448"> </a>
<a name="ln449">  // move window to the very top/bottom/left/right</a>
<a name="ln450">  case 'K':</a>
<a name="ln451">  case 'J':</a>
<a name="ln452">  case 'H':</a>
<a name="ln453">  case 'L':</a>
<a name="ln454">    CHECK_CMDWIN;</a>
<a name="ln455">    win_totop(Prenum,</a>
<a name="ln456">              ((nchar == 'H' || nchar == 'L') ? WSP_VERT : 0)</a>
<a name="ln457">              | ((nchar == 'H' || nchar == 'K') ? WSP_TOP : WSP_BOT));</a>
<a name="ln458">    break;</a>
<a name="ln459"> </a>
<a name="ln460">  // make all windows the same width and/or height</a>
<a name="ln461">  case '=': {</a>
<a name="ln462">    int mod = cmdmod.cmod_split &amp; (WSP_VERT | WSP_HOR);</a>
<a name="ln463">    win_equal(NULL, false, mod == WSP_VERT ? 'v' : mod == WSP_HOR ? 'h' : 'b');</a>
<a name="ln464">    break;</a>
<a name="ln465">  }</a>
<a name="ln466"> </a>
<a name="ln467">  // increase current window height</a>
<a name="ln468">  case '+':</a>
<a name="ln469">    win_setheight(curwin-&gt;w_height + Prenum1);</a>
<a name="ln470">    break;</a>
<a name="ln471"> </a>
<a name="ln472">  // decrease current window height</a>
<a name="ln473">  case '-':</a>
<a name="ln474">    win_setheight(curwin-&gt;w_height - Prenum1);</a>
<a name="ln475">    break;</a>
<a name="ln476"> </a>
<a name="ln477">  // set current window height</a>
<a name="ln478">  case Ctrl__:</a>
<a name="ln479">  case '_':</a>
<a name="ln480">    win_setheight(Prenum ? Prenum : Rows - 1);</a>
<a name="ln481">    break;</a>
<a name="ln482"> </a>
<a name="ln483">  // increase current window width</a>
<a name="ln484">  case '&gt;':</a>
<a name="ln485">    win_setwidth(curwin-&gt;w_width + Prenum1);</a>
<a name="ln486">    break;</a>
<a name="ln487"> </a>
<a name="ln488">  // decrease current window width</a>
<a name="ln489">  case '&lt;':</a>
<a name="ln490">    win_setwidth(curwin-&gt;w_width - Prenum1);</a>
<a name="ln491">    break;</a>
<a name="ln492"> </a>
<a name="ln493">  // set current window width</a>
<a name="ln494">  case '|':</a>
<a name="ln495">    win_setwidth(Prenum != 0 ? Prenum : Columns);</a>
<a name="ln496">    break;</a>
<a name="ln497"> </a>
<a name="ln498">  // jump to tag and split window if tag exists (in preview window)</a>
<a name="ln499">  case '}':</a>
<a name="ln500">    CHECK_CMDWIN;</a>
<a name="ln501">    if (Prenum) {</a>
<a name="ln502">      g_do_tagpreview = Prenum;</a>
<a name="ln503">    } else {</a>
<a name="ln504">      g_do_tagpreview = (int)p_pvh;</a>
<a name="ln505">    }</a>
<a name="ln506">    FALLTHROUGH;</a>
<a name="ln507">  case ']':</a>
<a name="ln508">  case Ctrl_RSB:</a>
<a name="ln509">    CHECK_CMDWIN;</a>
<a name="ln510">    // Keep visual mode, can select words to use as a tag.</a>
<a name="ln511">    if (Prenum) {</a>
<a name="ln512">      postponed_split = Prenum;</a>
<a name="ln513">    } else {</a>
<a name="ln514">      postponed_split = -1;</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">    if (nchar != '}') {</a>
<a name="ln518">      g_do_tagpreview = 0;</a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521">    // Execute the command right here, required when</a>
<a name="ln522">    // &quot;wincmd ]&quot; was used in a function.</a>
<a name="ln523">    do_nv_ident(Ctrl_RSB, NUL);</a>
<a name="ln524">    postponed_split = 0;</a>
<a name="ln525">    break;</a>
<a name="ln526"> </a>
<a name="ln527">  // edit file name under cursor in a new window</a>
<a name="ln528">  case 'f':</a>
<a name="ln529">  case 'F':</a>
<a name="ln530">  case Ctrl_F: {</a>
<a name="ln531">wingotofile:</a>
<a name="ln532">    CHECK_CMDWIN;</a>
<a name="ln533">    if (check_text_or_curbuf_locked(NULL)) {</a>
<a name="ln534">      break;</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">    linenr_T lnum = -1;</a>
<a name="ln538">    char *ptr = grab_file_name(Prenum1, &amp;lnum);</a>
<a name="ln539">    if (ptr != NULL) {</a>
<a name="ln540">      tabpage_T *oldtab = curtab;</a>
<a name="ln541">      win_T *oldwin = curwin;</a>
<a name="ln542">      setpcmark();</a>
<a name="ln543"> </a>
<a name="ln544">      // If 'switchbuf' is set to 'useopen' or 'usetab' and the</a>
<a name="ln545">      // file is already opened in a window, then jump to it.</a>
<a name="ln546">      win_T *wp = NULL;</a>
<a name="ln547">      if ((swb_flags &amp; (SWB_USEOPEN | SWB_USETAB))</a>
<a name="ln548">          &amp;&amp; cmdmod.cmod_tab == 0) {</a>
<a name="ln549">        wp = swbuf_goto_win_with_buf(buflist_findname_exp(ptr));</a>
<a name="ln550">      }</a>
<a name="ln551"> </a>
<a name="ln552">      if (wp == NULL &amp;&amp; win_split(0, 0) == OK) {</a>
<a name="ln553">        RESET_BINDING(curwin);</a>
<a name="ln554">        if (do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL, ECMD_HIDE, NULL) == FAIL) {</a>
<a name="ln555">          // Failed to open the file, close the window opened for it.</a>
<a name="ln556">          win_close(curwin, false, false);</a>
<a name="ln557">          goto_tabpage_win(oldtab, oldwin);</a>
<a name="ln558">        } else {</a>
<a name="ln559">          wp = curwin;</a>
<a name="ln560">        }</a>
<a name="ln561">      }</a>
<a name="ln562"> </a>
<a name="ln563">      if (wp != NULL &amp;&amp; nchar == 'F' &amp;&amp; lnum &gt;= 0) {</a>
<a name="ln564">        curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln565">        check_cursor_lnum(curwin);</a>
<a name="ln566">        beginline(BL_SOL | BL_FIX);</a>
<a name="ln567">      }</a>
<a name="ln568">      xfree(ptr);</a>
<a name="ln569">    }</a>
<a name="ln570">    break;</a>
<a name="ln571">  }</a>
<a name="ln572"> </a>
<a name="ln573">  // Go to the first occurrence of the identifier under cursor along path in a</a>
<a name="ln574">  // new window -- webb</a>
<a name="ln575">  case 'i':                         // Go to any match</a>
<a name="ln576">  case Ctrl_I:</a>
<a name="ln577">    type = FIND_ANY;</a>
<a name="ln578">    FALLTHROUGH;</a>
<a name="ln579">  case 'd':                         // Go to definition, using 'define'</a>
<a name="ln580">  case Ctrl_D: {</a>
<a name="ln581">    CHECK_CMDWIN;</a>
<a name="ln582">    size_t len;</a>
<a name="ln583">    char *ptr;</a>
<a name="ln584">    if ((len = find_ident_under_cursor(&amp;ptr, FIND_IDENT)) == 0) {</a>
<a name="ln585">      break;</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    // Make a copy, if the line was changed it will be freed.</a>
<a name="ln589">    ptr = xstrnsave(ptr, len);</a>
<a name="ln590"> </a>
<a name="ln591">    find_pattern_in_path(ptr, 0, len, true, Prenum == 0,</a>
<a name="ln592">                         type, Prenum1, ACTION_SPLIT, 1, MAXLNUM);</a>
<a name="ln593">    xfree(ptr);</a>
<a name="ln594">    curwin-&gt;w_set_curswant = true;</a>
<a name="ln595">    break;</a>
<a name="ln596">  }</a>
<a name="ln597"> </a>
<a name="ln598">  // Quickfix window only: view the result under the cursor in a new split.</a>
<a name="ln599">  case K_KENTER:</a>
<a name="ln600">  case CAR:</a>
<a name="ln601">    if (bt_quickfix(curbuf)) {</a>
<a name="ln602">      qf_view_result(true);</a>
<a name="ln603">    }</a>
<a name="ln604">    break;</a>
<a name="ln605"> </a>
<a name="ln606">  // CTRL-W g  extended commands</a>
<a name="ln607">  case 'g':</a>
<a name="ln608">  case Ctrl_G:</a>
<a name="ln609">    CHECK_CMDWIN;</a>
<a name="ln610">    no_mapping++;</a>
<a name="ln611">    allow_keys++;               // no mapping for xchar, but allow key codes</a>
<a name="ln612">    if (xchar == NUL) {</a>
<a name="ln613">      xchar = plain_vgetc();</a>
<a name="ln614">    }</a>
<a name="ln615">    LANGMAP_ADJUST(xchar, true);</a>
<a name="ln616">    no_mapping--;</a>
<a name="ln617">    allow_keys--;</a>
<a name="ln618">    (void)add_to_showcmd(xchar);</a>
<a name="ln619"> </a>
<a name="ln620">    switch (xchar) {</a>
<a name="ln621">    case '}':</a>
<a name="ln622">      xchar = Ctrl_RSB;</a>
<a name="ln623">      if (Prenum) {</a>
<a name="ln624">        g_do_tagpreview = Prenum;</a>
<a name="ln625">      } else {</a>
<a name="ln626">        g_do_tagpreview = (int)p_pvh;</a>
<a name="ln627">      }</a>
<a name="ln628">      FALLTHROUGH;</a>
<a name="ln629">    case ']':</a>
<a name="ln630">    case Ctrl_RSB:</a>
<a name="ln631">      // Keep visual mode, can select words to use as a tag.</a>
<a name="ln632">      if (Prenum) {</a>
<a name="ln633">        postponed_split = Prenum;</a>
<a name="ln634">      } else {</a>
<a name="ln635">        postponed_split = -1;</a>
<a name="ln636">      }</a>
<a name="ln637"> </a>
<a name="ln638">      // Execute the command right here, required when</a>
<a name="ln639">      // &quot;wincmd g}&quot; was used in a function.</a>
<a name="ln640">      do_nv_ident('g', xchar);</a>
<a name="ln641">      postponed_split = 0;</a>
<a name="ln642">      break;</a>
<a name="ln643"> </a>
<a name="ln644">    case 'f':                       // CTRL-W gf: &quot;gf&quot; in a new tab page</a>
<a name="ln645">    case 'F':                       // CTRL-W gF: &quot;gF&quot; in a new tab page</a>
<a name="ln646">      cmdmod.cmod_tab = tabpage_index(curtab) + 1;</a>
<a name="ln647">      nchar = xchar;</a>
<a name="ln648">      goto wingotofile;</a>
<a name="ln649"> </a>
<a name="ln650">    case 't':                       // CTRL-W gt: go to next tab page</a>
<a name="ln651">      goto_tabpage(Prenum);</a>
<a name="ln652">      break;</a>
<a name="ln653"> </a>
<a name="ln654">    case 'T':                       // CTRL-W gT: go to previous tab page</a>
<a name="ln655">      goto_tabpage(-Prenum1);</a>
<a name="ln656">      break;</a>
<a name="ln657"> </a>
<a name="ln658">    case TAB:                       // CTRL-W g&lt;Tab&gt;: go to last used tab page</a>
<a name="ln659">      if (!goto_tabpage_lastused()) {</a>
<a name="ln660">        beep_flush();</a>
<a name="ln661">      }</a>
<a name="ln662">      break;</a>
<a name="ln663"> </a>
<a name="ln664">    case 'e':</a>
<a name="ln665">      if (curwin-&gt;w_floating || !ui_has(kUIMultigrid)) {</a>
<a name="ln666">        beep_flush();</a>
<a name="ln667">        break;</a>
<a name="ln668">      }</a>
<a name="ln669">      FloatConfig config = FLOAT_CONFIG_INIT;</a>
<a name="ln670">      config.width = curwin-&gt;w_width;</a>
<a name="ln671">      config.height = curwin-&gt;w_height;</a>
<a name="ln672">      config.external = true;</a>
<a name="ln673">      Error err = ERROR_INIT;</a>
<a name="ln674">      if (!win_new_float(curwin, false, config, &amp;err)) {</a>
<a name="ln675">        emsg(err.msg);</a>
<a name="ln676">        api_clear_error(&amp;err);</a>
<a name="ln677">        beep_flush();</a>
<a name="ln678">      }</a>
<a name="ln679">      break;</a>
<a name="ln680">    default:</a>
<a name="ln681">      beep_flush();</a>
<a name="ln682">      break;</a>
<a name="ln683">    }</a>
<a name="ln684">    break;</a>
<a name="ln685"> </a>
<a name="ln686">  default:</a>
<a name="ln687">    beep_flush();</a>
<a name="ln688">    break;</a>
<a name="ln689">  }</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">static void cmd_with_count(char *cmd, char *bufp, size_t bufsize, int64_t Prenum)</a>
<a name="ln693">{</a>
<a name="ln694">  size_t len = xstrlcpy(bufp, cmd, bufsize);</a>
<a name="ln695"> </a>
<a name="ln696">  if (Prenum &gt; 0 &amp;&amp; len &lt; bufsize) {</a>
<a name="ln697">    vim_snprintf(bufp + len, bufsize - len, &quot;%&quot; PRId64, Prenum);</a>
<a name="ln698">  }</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">void win_set_buf(win_T *win, buf_T *buf, bool noautocmd, Error *err)</a>
<a name="ln702">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln703">{</a>
<a name="ln704">  tabpage_T *tab = win_find_tabpage(win);</a>
<a name="ln705"> </a>
<a name="ln706">  // no redrawing and don't set the window title</a>
<a name="ln707">  RedrawingDisabled++;</a>
<a name="ln708">  if (noautocmd) {</a>
<a name="ln709">    block_autocmds();</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  switchwin_T switchwin;</a>
<a name="ln713">  if (switch_win_noblock(&amp;switchwin, win, tab, false) == FAIL) {</a>
<a name="ln714">    api_set_error(err,</a>
<a name="ln715">                  kErrorTypeException,</a>
<a name="ln716">                  &quot;Failed to switch to window %d&quot;,</a>
<a name="ln717">                  win-&gt;handle);</a>
<a name="ln718">  }</a>
<a name="ln719"> </a>
<a name="ln720">  try_start();</a>
<a name="ln721">  int result = do_buffer(DOBUF_GOTO, DOBUF_FIRST, FORWARD, buf-&gt;b_fnum, 0);</a>
<a name="ln722">  if (!try_end(err) &amp;&amp; result == FAIL) {</a>
<a name="ln723">    api_set_error(err,</a>
<a name="ln724">                  kErrorTypeException,</a>
<a name="ln725">                  &quot;Failed to set buffer %d&quot;,</a>
<a name="ln726">                  buf-&gt;handle);</a>
<a name="ln727">  }</a>
<a name="ln728"> </a>
<a name="ln729">  // If window is not current, state logic will not validate its cursor.</a>
<a name="ln730">  // So do it now.</a>
<a name="ln731">  validate_cursor();</a>
<a name="ln732"> </a>
<a name="ln733">  restore_win_noblock(&amp;switchwin, false);</a>
<a name="ln734">  if (noautocmd) {</a>
<a name="ln735">    unblock_autocmds();</a>
<a name="ln736">  }</a>
<a name="ln737">  RedrawingDisabled--;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/// Create a new float.</a>
<a name="ln741">///</a>
<a name="ln742">/// @param wp      if NULL, allocate a new window, otherwise turn existing window into a float.</a>
<a name="ln743">///                It must then already belong to the current tabpage!</a>
<a name="ln744">/// @param last    make the window the last one in the window list.</a>
<a name="ln745">///                Only used when allocating the autocommand window.</a>
<a name="ln746">/// @param config  must already have been validated!</a>
<a name="ln747">win_T *win_new_float(win_T *wp, bool last, FloatConfig fconfig, Error *err)</a>
<a name="ln748">{</a>
<a name="ln749">  if (wp == NULL) {</a>
<a name="ln750">    wp = win_alloc(last ? lastwin : lastwin_nofloating(), false);</a>
<a name="ln751">    win_init(wp, curwin, 0);</a>
<a name="ln752">  } else {</a>
<a name="ln753">    assert(!last);</a>
<a name="ln754">    assert(!wp-&gt;w_floating);</a>
<a name="ln755">    if (firstwin == wp &amp;&amp; lastwin_nofloating() == wp) {</a>
<a name="ln756">      // last non-float</a>
<a name="ln757">      api_set_error(err, kErrorTypeException,</a>
<a name="ln758">                    &quot;Cannot change last window into float&quot;);</a>
<a name="ln759">      return NULL;</a>
<a name="ln760">    } else if (!win_valid(wp)) {</a>
<a name="ln761">      api_set_error(err, kErrorTypeException,</a>
<a name="ln762">                    &quot;Cannot change window from different tabpage into float&quot;);</a>
<a name="ln763">      return NULL;</a>
<a name="ln764">    }</a>
<a name="ln765">    int dir;</a>
<a name="ln766">    winframe_remove(wp, &amp;dir, NULL);</a>
<a name="ln767">    XFREE_CLEAR(wp-&gt;w_frame);</a>
<a name="ln768">    (void)win_comp_pos();  // recompute window positions</a>
<a name="ln769">    win_remove(wp, NULL);</a>
<a name="ln770">    win_append(lastwin_nofloating(), wp);</a>
<a name="ln771">  }</a>
<a name="ln772">  wp-&gt;w_floating = true;</a>
<a name="ln773">  wp-&gt;w_status_height = 0;</a>
<a name="ln774">  wp-&gt;w_winbar_height = 0;</a>
<a name="ln775">  wp-&gt;w_hsep_height = 0;</a>
<a name="ln776">  wp-&gt;w_vsep_width = 0;</a>
<a name="ln777"> </a>
<a name="ln778">  win_config_float(wp, fconfig);</a>
<a name="ln779">  win_set_inner_size(wp, true);</a>
<a name="ln780">  wp-&gt;w_pos_changed = true;</a>
<a name="ln781">  redraw_later(wp, UPD_VALID);</a>
<a name="ln782">  return wp;</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">void win_set_minimal_style(win_T *wp)</a>
<a name="ln786">{</a>
<a name="ln787">  wp-&gt;w_p_nu = false;</a>
<a name="ln788">  wp-&gt;w_p_rnu = false;</a>
<a name="ln789">  wp-&gt;w_p_cul = false;</a>
<a name="ln790">  wp-&gt;w_p_cuc = false;</a>
<a name="ln791">  wp-&gt;w_p_spell = false;</a>
<a name="ln792">  wp-&gt;w_p_list = false;</a>
<a name="ln793"> </a>
<a name="ln794">  // Hide EOB region: use &quot; &quot; fillchar and cleared highlighting</a>
<a name="ln795">  if (wp-&gt;w_p_fcs_chars.eob != ' ') {</a>
<a name="ln796">    char *old = wp-&gt;w_p_fcs;</a>
<a name="ln797">    wp-&gt;w_p_fcs = ((*old == NUL)</a>
<a name="ln798">                   ? xstrdup(&quot;eob: &quot;)</a>
<a name="ln799">                   : concat_str(old, &quot;,eob: &quot;));</a>
<a name="ln800">    free_string_option(old);</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">  // TODO(bfredl): this could use a highlight namespace directly,</a>
<a name="ln804">  // and avoid peculiarities around window options</a>
<a name="ln805">  char *old = wp-&gt;w_p_winhl;</a>
<a name="ln806">  wp-&gt;w_p_winhl = ((*old == NUL)</a>
<a name="ln807">                   ? xstrdup(&quot;EndOfBuffer:&quot;)</a>
<a name="ln808">                   : concat_str(old, &quot;,EndOfBuffer:&quot;));</a>
<a name="ln809">  free_string_option(old);</a>
<a name="ln810">  parse_winhl_opt(wp);</a>
<a name="ln811"> </a>
<a name="ln812">  // signcolumn: use 'auto'</a>
<a name="ln813">  if (wp-&gt;w_p_scl[0] != 'a' || strlen(wp-&gt;w_p_scl) &gt;= 8) {</a>
<a name="ln814">    free_string_option(wp-&gt;w_p_scl);</a>
<a name="ln815">    wp-&gt;w_p_scl = xstrdup(&quot;auto&quot;);</a>
<a name="ln816">  }</a>
<a name="ln817"> </a>
<a name="ln818">  // foldcolumn: use '0'</a>
<a name="ln819">  if (wp-&gt;w_p_fdc[0] != '0') {</a>
<a name="ln820">    free_string_option(wp-&gt;w_p_fdc);</a>
<a name="ln821">    wp-&gt;w_p_fdc = xstrdup(&quot;0&quot;);</a>
<a name="ln822">  }</a>
<a name="ln823"> </a>
<a name="ln824">  // colorcolumn: cleared</a>
<a name="ln825">  if (wp-&gt;w_p_cc != NULL &amp;&amp; *wp-&gt;w_p_cc != NUL) {</a>
<a name="ln826">    free_string_option(wp-&gt;w_p_cc);</a>
<a name="ln827">    wp-&gt;w_p_cc = xstrdup(&quot;&quot;);</a>
<a name="ln828">  }</a>
<a name="ln829"> </a>
<a name="ln830">  // statuscolumn: cleared</a>
<a name="ln831">  if (wp-&gt;w_p_stc != NULL &amp;&amp; *wp-&gt;w_p_stc != NUL) {</a>
<a name="ln832">    free_string_option(wp-&gt;w_p_stc);</a>
<a name="ln833">    wp-&gt;w_p_stc = xstrdup(&quot;&quot;);</a>
<a name="ln834">  }</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">void win_config_float(win_T *wp, FloatConfig fconfig)</a>
<a name="ln838">{</a>
<a name="ln839">  wp-&gt;w_width = MAX(fconfig.width, 1);</a>
<a name="ln840">  wp-&gt;w_height = MAX(fconfig.height, 1);</a>
<a name="ln841"> </a>
<a name="ln842">  if (fconfig.relative == kFloatRelativeCursor) {</a>
<a name="ln843">    fconfig.relative = kFloatRelativeWindow;</a>
<a name="ln844">    fconfig.row += curwin-&gt;w_wrow;</a>
<a name="ln845">    fconfig.col += curwin-&gt;w_wcol;</a>
<a name="ln846">    fconfig.window = curwin-&gt;handle;</a>
<a name="ln847">  } else if (fconfig.relative == kFloatRelativeMouse) {</a>
<a name="ln848">    int row = mouse_row, col = mouse_col, grid = mouse_grid;</a>
<a name="ln849">    win_T *mouse_win = mouse_find_win(&amp;grid, &amp;row, &amp;col);</a>
<a name="ln850">    if (mouse_win != NULL) {</a>
<a name="ln851">      fconfig.relative = kFloatRelativeWindow;</a>
<a name="ln852">      fconfig.row += row;</a>
<a name="ln853">      fconfig.col += col;</a>
<a name="ln854">      fconfig.window = mouse_win-&gt;handle;</a>
<a name="ln855">    }</a>
<a name="ln856">  }</a>
<a name="ln857"> </a>
<a name="ln858">  bool change_external = fconfig.external != wp-&gt;w_float_config.external;</a>
<a name="ln859">  bool change_border = (fconfig.border != wp-&gt;w_float_config.border</a>
<a name="ln860">                        || memcmp(fconfig.border_hl_ids,</a>
<a name="ln861">                                  wp-&gt;w_float_config.border_hl_ids,</a>
<a name="ln862">                                  sizeof fconfig.border_hl_ids) != 0);</a>
<a name="ln863"> </a>
<a name="ln864">  wp-&gt;w_float_config = fconfig;</a>
<a name="ln865"> </a>
<a name="ln866">  bool has_border = wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border;</a>
<a name="ln867">  for (int i = 0; i &lt; 4; i++) {</a>
<a name="ln868">    int new_adj = has_border &amp;&amp; wp-&gt;w_float_config.border_chars[2 * i + 1][0];</a>
<a name="ln869">    if (new_adj != wp-&gt;w_border_adj[i]) {</a>
<a name="ln870">      change_border = true;</a>
<a name="ln871">      wp-&gt;w_border_adj[i] = new_adj;</a>
<a name="ln872">    }</a>
<a name="ln873">  }</a>
<a name="ln874"> </a>
<a name="ln875">  if (!ui_has(kUIMultigrid)) {</a>
<a name="ln876">    wp-&gt;w_height = MIN(wp-&gt;w_height, Rows - win_border_height(wp));</a>
<a name="ln877">    wp-&gt;w_width = MIN(wp-&gt;w_width, Columns - win_border_width(wp));</a>
<a name="ln878">  }</a>
<a name="ln879"> </a>
<a name="ln880">  win_set_inner_size(wp, true);</a>
<a name="ln881">  must_redraw = MAX(must_redraw, UPD_VALID);</a>
<a name="ln882"> </a>
<a name="ln883">  wp-&gt;w_pos_changed = true;</a>
<a name="ln884">  if (change_external || change_border) {</a>
<a name="ln885">    wp-&gt;w_hl_needs_update = true;</a>
<a name="ln886">    redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  // compute initial position</a>
<a name="ln890">  if (wp-&gt;w_float_config.relative == kFloatRelativeWindow) {</a>
<a name="ln891">    int row = (int)wp-&gt;w_float_config.row;</a>
<a name="ln892">    int col = (int)wp-&gt;w_float_config.col;</a>
<a name="ln893">    Error dummy = ERROR_INIT;</a>
<a name="ln894">    win_T *parent = find_window_by_handle(wp-&gt;w_float_config.window, &amp;dummy);</a>
<a name="ln895">    if (parent) {</a>
<a name="ln896">      row += parent-&gt;w_winrow;</a>
<a name="ln897">      col += parent-&gt;w_wincol;</a>
<a name="ln898">      ScreenGrid *grid = &amp;parent-&gt;w_grid;</a>
<a name="ln899">      int row_off = 0, col_off = 0;</a>
<a name="ln900">      grid_adjust(&amp;grid, &amp;row_off, &amp;col_off);</a>
<a name="ln901">      row += row_off;</a>
<a name="ln902">      col += col_off;</a>
<a name="ln903">      if (wp-&gt;w_float_config.bufpos.lnum &gt;= 0) {</a>
<a name="ln904">        pos_T pos = { wp-&gt;w_float_config.bufpos.lnum + 1,</a>
<a name="ln905">                      wp-&gt;w_float_config.bufpos.col, 0 };</a>
<a name="ln906">        int trow, tcol, tcolc, tcole;</a>
<a name="ln907">        textpos2screenpos(parent, &amp;pos, &amp;trow, &amp;tcol, &amp;tcolc, &amp;tcole, true);</a>
<a name="ln908">        row += trow - 1;</a>
<a name="ln909">        col += tcol - 1;</a>
<a name="ln910">      }</a>
<a name="ln911">    }</a>
<a name="ln912">    api_clear_error(&amp;dummy);</a>
<a name="ln913">    wp-&gt;w_winrow = row;</a>
<a name="ln914">    wp-&gt;w_wincol = col;</a>
<a name="ln915">  } else {</a>
<a name="ln916">    wp-&gt;w_winrow = (int)fconfig.row;</a>
<a name="ln917">    wp-&gt;w_wincol = (int)fconfig.col;</a>
<a name="ln918">  }</a>
<a name="ln919"> </a>
<a name="ln920">  // changing border style while keeping border only requires redrawing border</a>
<a name="ln921">  if (fconfig.border) {</a>
<a name="ln922">    wp-&gt;w_redr_border = true;</a>
<a name="ln923">    redraw_later(wp, UPD_VALID);</a>
<a name="ln924">  }</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">void win_check_anchored_floats(win_T *win)</a>
<a name="ln928">{</a>
<a name="ln929">  for (win_T *wp = lastwin; wp &amp;&amp; wp-&gt;w_floating; wp = wp-&gt;w_prev) {</a>
<a name="ln930">    // float might be anchored to moved window</a>
<a name="ln931">    if (wp-&gt;w_float_config.relative == kFloatRelativeWindow</a>
<a name="ln932">        &amp;&amp; wp-&gt;w_float_config.window == win-&gt;handle) {</a>
<a name="ln933">      wp-&gt;w_pos_changed = true;</a>
<a name="ln934">    }</a>
<a name="ln935">  }</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">/// Return the number of fold columns to display</a>
<a name="ln939">int win_fdccol_count(win_T *wp)</a>
<a name="ln940">{</a>
<a name="ln941">  const char *fdc = wp-&gt;w_p_fdc;</a>
<a name="ln942"> </a>
<a name="ln943">  // auto:&lt;NUM&gt;</a>
<a name="ln944">  if (strncmp(fdc, &quot;auto&quot;, 4) == 0) {</a>
<a name="ln945">    const int fdccol = fdc[4] == ':' ? fdc[5] - '0' : 1;</a>
<a name="ln946">    int needed_fdccols = getDeepestNesting(wp);</a>
<a name="ln947">    return MIN(fdccol, needed_fdccols);</a>
<a name="ln948">  }</a>
<a name="ln949">  return fdc[0] - '0';</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">void ui_ext_win_position(win_T *wp, bool validate)</a>
<a name="ln953">{</a>
<a name="ln954">  wp-&gt;w_pos_changed = false;</a>
<a name="ln955">  if (!wp-&gt;w_floating) {</a>
<a name="ln956">    ui_call_win_pos(wp-&gt;w_grid_alloc.handle, wp-&gt;handle, wp-&gt;w_winrow,</a>
<a name="ln957">                    wp-&gt;w_wincol, wp-&gt;w_width, wp-&gt;w_height);</a>
<a name="ln958">    return;</a>
<a name="ln959">  }</a>
<a name="ln960"> </a>
<a name="ln961">  FloatConfig c = wp-&gt;w_float_config;</a>
<a name="ln962">  if (!c.external) {</a>
<a name="ln963">    ScreenGrid *grid = &amp;default_grid;</a>
<a name="ln964">    Float row = c.row, col = c.col;</a>
<a name="ln965">    if (c.relative == kFloatRelativeWindow) {</a>
<a name="ln966">      Error dummy = ERROR_INIT;</a>
<a name="ln967">      win_T *win = find_window_by_handle(c.window, &amp;dummy);</a>
<a name="ln968">      api_clear_error(&amp;dummy);</a>
<a name="ln969">      if (win != NULL) {</a>
<a name="ln970">        // When a floating window is anchored to another window,</a>
<a name="ln971">        // update the position of its anchored window first.</a>
<a name="ln972">        if (win-&gt;w_pos_changed &amp;&amp; win-&gt;w_grid_alloc.chars != NULL &amp;&amp; win_valid(win)) {</a>
<a name="ln973">          ui_ext_win_position(win, validate);</a>
<a name="ln974">        }</a>
<a name="ln975">        grid = &amp;win-&gt;w_grid;</a>
<a name="ln976">        int row_off = 0, col_off = 0;</a>
<a name="ln977">        grid_adjust(&amp;grid, &amp;row_off, &amp;col_off);</a>
<a name="ln978">        row += row_off;</a>
<a name="ln979">        col += col_off;</a>
<a name="ln980">        if (c.bufpos.lnum &gt;= 0) {</a>
<a name="ln981">          pos_T pos = { c.bufpos.lnum + 1, c.bufpos.col, 0 };</a>
<a name="ln982">          int trow, tcol, tcolc, tcole;</a>
<a name="ln983">          textpos2screenpos(win, &amp;pos, &amp;trow, &amp;tcol, &amp;tcolc, &amp;tcole, true);</a>
<a name="ln984">          row += trow - 1;</a>
<a name="ln985">          col += tcol - 1;</a>
<a name="ln986">        }</a>
<a name="ln987">      }</a>
<a name="ln988">    }</a>
<a name="ln989"> </a>
<a name="ln990">    wp-&gt;w_grid_alloc.zindex = wp-&gt;w_float_config.zindex;</a>
<a name="ln991">    if (ui_has(kUIMultigrid)) {</a>
<a name="ln992">      String anchor = cstr_as_string((char *)float_anchor_str[c.anchor]);</a>
<a name="ln993">      if (!c.hide) {</a>
<a name="ln994">        ui_call_win_float_pos(wp-&gt;w_grid_alloc.handle, wp-&gt;handle, anchor,</a>
<a name="ln995">                              grid-&gt;handle, row, col, c.focusable,</a>
<a name="ln996">                              wp-&gt;w_grid_alloc.zindex);</a>
<a name="ln997">      } else {</a>
<a name="ln998">        ui_call_win_hide(wp-&gt;w_grid_alloc.handle);</a>
<a name="ln999">      }</a>
<a name="ln1000">    } else {</a>
<a name="ln1001">      bool valid = (wp-&gt;w_redr_type == 0);</a>
<a name="ln1002">      if (!valid &amp;&amp; !validate) {</a>
<a name="ln1003">        wp-&gt;w_pos_changed = true;</a>
<a name="ln1004">        return;</a>
<a name="ln1005">      }</a>
<a name="ln1006">      // TODO(bfredl): ideally, compositor should work like any multigrid UI</a>
<a name="ln1007">      // and use standard win_pos events.</a>
<a name="ln1008">      bool east = c.anchor &amp; kFloatAnchorEast;</a>
<a name="ln1009">      bool south = c.anchor &amp; kFloatAnchorSouth;</a>
<a name="ln1010"> </a>
<a name="ln1011">      int comp_row = (int)row - (south ? wp-&gt;w_height_outer : 0);</a>
<a name="ln1012">      int comp_col = (int)col - (east ? wp-&gt;w_width_outer : 0);</a>
<a name="ln1013">      comp_row += grid-&gt;comp_row;</a>
<a name="ln1014">      comp_col += grid-&gt;comp_col;</a>
<a name="ln1015">      comp_row = MAX(MIN(comp_row, Rows - wp-&gt;w_height_outer - (p_ch &gt; 0 ? 1 : 0)), 0);</a>
<a name="ln1016">      if (!c.fixed || east) {</a>
<a name="ln1017">        comp_col = MAX(MIN(comp_col, Columns - wp-&gt;w_width_outer), 0);</a>
<a name="ln1018">      }</a>
<a name="ln1019">      wp-&gt;w_winrow = comp_row;</a>
<a name="ln1020">      wp-&gt;w_wincol = comp_col;</a>
<a name="ln1021"> </a>
<a name="ln1022">      if (!c.hide) {</a>
<a name="ln1023">        ui_comp_put_grid(&amp;wp-&gt;w_grid_alloc, comp_row, comp_col,</a>
<a name="ln1024">                         wp-&gt;w_height_outer, wp-&gt;w_width_outer, valid, false);</a>
<a name="ln1025">        ui_check_cursor_grid(wp-&gt;w_grid_alloc.handle);</a>
<a name="ln1026">        wp-&gt;w_grid_alloc.focusable = wp-&gt;w_float_config.focusable;</a>
<a name="ln1027">        if (!valid) {</a>
<a name="ln1028">          wp-&gt;w_grid_alloc.valid = false;</a>
<a name="ln1029">          redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln1030">        }</a>
<a name="ln1031">      } else {</a>
<a name="ln1032">        ui_comp_remove_grid(&amp;wp-&gt;w_grid_alloc);</a>
<a name="ln1033">      }</a>
<a name="ln1034">    }</a>
<a name="ln1035">  } else {</a>
<a name="ln1036">    ui_call_win_external_pos(wp-&gt;w_grid_alloc.handle, wp-&gt;handle);</a>
<a name="ln1037">  }</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">void ui_ext_win_viewport(win_T *wp)</a>
<a name="ln1041">{</a>
<a name="ln1042">  // NOTE: The win_viewport command is delayed until the next flush when there are pending updates.</a>
<a name="ln1043">  // This ensures that the updates and the viewport are sent together.</a>
<a name="ln1044">  if ((wp == curwin || ui_has(kUIMultigrid)) &amp;&amp; wp-&gt;w_viewport_invalid &amp;&amp; wp-&gt;w_redr_type == 0) {</a>
<a name="ln1045">    const linenr_T line_count = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1046">    // Avoid ml_get errors when producing &quot;scroll_delta&quot;.</a>
<a name="ln1047">    const linenr_T cur_topline = MIN(wp-&gt;w_topline, line_count);</a>
<a name="ln1048">    const linenr_T cur_botline = MIN(wp-&gt;w_botline, line_count);</a>
<a name="ln1049">    int64_t delta = 0;</a>
<a name="ln1050">    linenr_T last_topline = wp-&gt;w_viewport_last_topline;</a>
<a name="ln1051">    linenr_T last_botline = wp-&gt;w_viewport_last_botline;</a>
<a name="ln1052">    int last_topfill = wp-&gt;w_viewport_last_topfill;</a>
<a name="ln1053">    int64_t last_skipcol = wp-&gt;w_viewport_last_skipcol;</a>
<a name="ln1054">    if (last_topline &gt; line_count) {</a>
<a name="ln1055">      delta -= last_topline - line_count;</a>
<a name="ln1056">      last_topline = line_count;</a>
<a name="ln1057">      last_topfill = 0;</a>
<a name="ln1058">      last_skipcol = MAXCOL;</a>
<a name="ln1059">    }</a>
<a name="ln1060">    last_botline = MIN(last_botline, line_count);</a>
<a name="ln1061">    if (cur_topline &lt; last_topline</a>
<a name="ln1062">        || (cur_topline == last_topline &amp;&amp; wp-&gt;w_skipcol &lt; last_skipcol)) {</a>
<a name="ln1063">      if (last_topline &gt; 0 &amp;&amp; cur_botline &lt; last_topline) {</a>
<a name="ln1064">        // Scrolling too many lines: only give an approximate &quot;scroll_delta&quot;.</a>
<a name="ln1065">        delta -= win_text_height(wp, cur_topline, wp-&gt;w_skipcol, cur_botline, 0, NULL);</a>
<a name="ln1066">        delta -= last_topline - cur_botline;</a>
<a name="ln1067">      } else {</a>
<a name="ln1068">        delta -= win_text_height(wp, cur_topline, wp-&gt;w_skipcol, last_topline, last_skipcol, NULL);</a>
<a name="ln1069">      }</a>
<a name="ln1070">    } else if (cur_topline &gt; last_topline</a>
<a name="ln1071">               || (cur_topline == last_topline &amp;&amp; wp-&gt;w_skipcol &gt; last_skipcol)) {</a>
<a name="ln1072">      if (last_botline &gt; 0 &amp;&amp; cur_topline &gt; last_botline) {</a>
<a name="ln1073">        // Scrolling too many lines: only give an approximate &quot;scroll_delta&quot;.</a>
<a name="ln1074">        delta += win_text_height(wp, last_topline, last_skipcol, last_botline, 0, NULL);</a>
<a name="ln1075">        delta += cur_topline - last_botline;</a>
<a name="ln1076">      } else {</a>
<a name="ln1077">        delta += win_text_height(wp, last_topline, last_skipcol, cur_topline, wp-&gt;w_skipcol, NULL);</a>
<a name="ln1078">      }</a>
<a name="ln1079">    }</a>
<a name="ln1080">    delta += last_topfill;</a>
<a name="ln1081">    delta -= wp-&gt;w_topfill;</a>
<a name="ln1082">    linenr_T ev_botline = wp-&gt;w_botline;</a>
<a name="ln1083">    if (ev_botline == line_count + 1 &amp;&amp; wp-&gt;w_empty_rows == 0) {</a>
<a name="ln1084">      // TODO(bfredl): The might be more cases to consider, like how does this</a>
<a name="ln1085">      // interact with incomplete final line? Diff filler lines?</a>
<a name="ln1086">      ev_botline = line_count;</a>
<a name="ln1087">    }</a>
<a name="ln1088">    ui_call_win_viewport(wp-&gt;w_grid_alloc.handle, wp-&gt;handle, wp-&gt;w_topline - 1, ev_botline,</a>
<a name="ln1089">                         wp-&gt;w_cursor.lnum - 1, wp-&gt;w_cursor.col, line_count, delta);</a>
<a name="ln1090">    wp-&gt;w_viewport_invalid = false;</a>
<a name="ln1091">    wp-&gt;w_viewport_last_topline = wp-&gt;w_topline;</a>
<a name="ln1092">    wp-&gt;w_viewport_last_botline = wp-&gt;w_botline;</a>
<a name="ln1093">    wp-&gt;w_viewport_last_topfill = wp-&gt;w_topfill;</a>
<a name="ln1094">    wp-&gt;w_viewport_last_skipcol = wp-&gt;w_skipcol;</a>
<a name="ln1095">  }</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/// If &quot;split_disallowed&quot; is set give an error and return FAIL.</a>
<a name="ln1099">/// Otherwise return OK.</a>
<a name="ln1100">static int check_split_disallowed(void)</a>
<a name="ln1101">{</a>
<a name="ln1102">  if (split_disallowed &gt; 0) {</a>
<a name="ln1103">    emsg(_(&quot;E242: Can't split a window while closing another&quot;));</a>
<a name="ln1104">    return FAIL;</a>
<a name="ln1105">  }</a>
<a name="ln1106">  if (curwin-&gt;w_buffer-&gt;b_locked_split) {</a>
<a name="ln1107">    emsg(_(e_cannot_split_window_when_closing_buffer));</a>
<a name="ln1108">    return FAIL;</a>
<a name="ln1109">  }</a>
<a name="ln1110">  return OK;</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">// split the current window, implements CTRL-W s and :split</a>
<a name="ln1114">//</a>
<a name="ln1115">// &quot;size&quot; is the height or width for the new window, 0 to use half of current</a>
<a name="ln1116">// height or width.</a>
<a name="ln1117">//</a>
<a name="ln1118">// &quot;flags&quot;:</a>
<a name="ln1119">// WSP_ROOM: require enough room for new window</a>
<a name="ln1120">// WSP_VERT: vertical split.</a>
<a name="ln1121">// WSP_TOP:  open window at the top-left of the screen (help window).</a>
<a name="ln1122">// WSP_BOT:  open window at the bottom-right of the screen (quickfix window).</a>
<a name="ln1123">// WSP_HELP: creating the help window, keep layout snapshot</a>
<a name="ln1124">//</a>
<a name="ln1125">// return FAIL for failure, OK otherwise</a>
<a name="ln1126">int win_split(int size, int flags)</a>
<a name="ln1127">{</a>
<a name="ln1128">  if (check_split_disallowed() == FAIL) {</a>
<a name="ln1129">    return FAIL;</a>
<a name="ln1130">  }</a>
<a name="ln1131"> </a>
<a name="ln1132">  // When the &quot;:tab&quot; modifier was used open a new tab page instead.</a>
<a name="ln1133">  if (may_open_tabpage() == OK) {</a>
<a name="ln1134">    return OK;</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  // Add flags from &quot;:vertical&quot;, &quot;:topleft&quot; and &quot;:botright&quot;.</a>
<a name="ln1138">  flags |= cmdmod.cmod_split;</a>
<a name="ln1139">  if ((flags &amp; WSP_TOP) &amp;&amp; (flags &amp; WSP_BOT)) {</a>
<a name="ln1140">    emsg(_(&quot;E442: Can't split topleft and botright at the same time&quot;));</a>
<a name="ln1141">    return FAIL;</a>
<a name="ln1142">  }</a>
<a name="ln1143"> </a>
<a name="ln1144">  // When creating the help window make a snapshot of the window layout.</a>
<a name="ln1145">  // Otherwise clear the snapshot, it's now invalid.</a>
<a name="ln1146">  if (flags &amp; WSP_HELP) {</a>
<a name="ln1147">    make_snapshot(SNAP_HELP_IDX);</a>
<a name="ln1148">  } else {</a>
<a name="ln1149">    clear_snapshot(curtab, SNAP_HELP_IDX);</a>
<a name="ln1150">  }</a>
<a name="ln1151"> </a>
<a name="ln1152">  return win_split_ins(size, flags, NULL, 0);</a>
<a name="ln1153">}</a>
<a name="ln1154"> </a>
<a name="ln1155">/// When &quot;new_wp&quot; is NULL: split the current window in two.</a>
<a name="ln1156">/// When &quot;new_wp&quot; is not NULL: insert this window at the far</a>
<a name="ln1157">/// top/left/right/bottom.</a>
<a name="ln1158">/// @return  FAIL for failure, OK otherwise</a>
<a name="ln1159">int win_split_ins(int size, int flags, win_T *new_wp, int dir)</a>
<a name="ln1160">{</a>
<a name="ln1161">  win_T *wp = new_wp;</a>
<a name="ln1162"> </a>
<a name="ln1163">  // aucmd_win[] should always remain floating</a>
<a name="ln1164">  if (new_wp != NULL &amp;&amp; is_aucmd_win(new_wp)) {</a>
<a name="ln1165">    return FAIL;</a>
<a name="ln1166">  }</a>
<a name="ln1167"> </a>
<a name="ln1168">  win_T *oldwin;</a>
<a name="ln1169">  if (flags &amp; WSP_TOP) {</a>
<a name="ln1170">    oldwin = firstwin;</a>
<a name="ln1171">  } else if (flags &amp; WSP_BOT || curwin-&gt;w_floating) {</a>
<a name="ln1172">    // can't split float, use last nonfloating window instead</a>
<a name="ln1173">    oldwin = lastwin_nofloating();</a>
<a name="ln1174">  } else {</a>
<a name="ln1175">    oldwin = curwin;</a>
<a name="ln1176">  }</a>
<a name="ln1177"> </a>
<a name="ln1178">  int need_status = 0;</a>
<a name="ln1179">  int new_size = size;</a>
<a name="ln1180">  bool new_in_layout = (new_wp == NULL || new_wp-&gt;w_floating);</a>
<a name="ln1181"> </a>
<a name="ln1182">  // add a status line when p_ls == 1 and splitting the first window</a>
<a name="ln1183">  if (one_nonfloat() &amp;&amp; p_ls == 1 &amp;&amp; oldwin-&gt;w_status_height == 0) {</a>
<a name="ln1184">    if (oldwin-&gt;w_height &lt;= p_wmh &amp;&amp; new_in_layout) {</a>
<a name="ln1185">      emsg(_(e_noroom));</a>
<a name="ln1186">      return FAIL;</a>
<a name="ln1187">    }</a>
<a name="ln1188">    need_status = STATUS_HEIGHT;</a>
<a name="ln1189">  }</a>
<a name="ln1190"> </a>
<a name="ln1191">  bool do_equal = false;</a>
<a name="ln1192">  int oldwin_height = 0;</a>
<a name="ln1193">  const int layout = flags &amp; WSP_VERT ? FR_ROW : FR_COL;</a>
<a name="ln1194">  bool did_set_fraction = false;</a>
<a name="ln1195"> </a>
<a name="ln1196">  if (flags &amp; WSP_VERT) {</a>
<a name="ln1197">    // Check if we are able to split the current window and compute its</a>
<a name="ln1198">    // width.</a>
<a name="ln1199">    // Current window requires at least 1 space.</a>
<a name="ln1200">    int wmw1 = (p_wmw == 0 ? 1 : (int)p_wmw);</a>
<a name="ln1201">    int needed = wmw1 + 1;</a>
<a name="ln1202">    if (flags &amp; WSP_ROOM) {</a>
<a name="ln1203">      needed += (int)p_wiw - wmw1;</a>
<a name="ln1204">    }</a>
<a name="ln1205">    int minwidth;</a>
<a name="ln1206">    int available;</a>
<a name="ln1207">    if (flags &amp; (WSP_BOT | WSP_TOP)) {</a>
<a name="ln1208">      minwidth = frame_minwidth(topframe, NOWIN);</a>
<a name="ln1209">      available = topframe-&gt;fr_width;</a>
<a name="ln1210">      needed += minwidth;</a>
<a name="ln1211">    } else if (p_ea) {</a>
<a name="ln1212">      minwidth = frame_minwidth(oldwin-&gt;w_frame, NOWIN);</a>
<a name="ln1213">      frame_T *prevfrp = oldwin-&gt;w_frame;</a>
<a name="ln1214">      for (frame_T *frp = oldwin-&gt;w_frame-&gt;fr_parent; frp != NULL;</a>
<a name="ln1215">           frp = frp-&gt;fr_parent) {</a>
<a name="ln1216">        if (frp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln1217">          frame_T *frp2;</a>
<a name="ln1218">          FOR_ALL_FRAMES(frp2, frp-&gt;fr_child) {</a>
<a name="ln1219">            if (frp2 != prevfrp) {</a>
<a name="ln1220">              minwidth += frame_minwidth(frp2, NOWIN);</a>
<a name="ln1221">            }</a>
<a name="ln1222">          }</a>
<a name="ln1223">        }</a>
<a name="ln1224">        prevfrp = frp;</a>
<a name="ln1225">      }</a>
<a name="ln1226">      available = topframe-&gt;fr_width;</a>
<a name="ln1227">      needed += minwidth;</a>
<a name="ln1228">    } else {</a>
<a name="ln1229">      minwidth = frame_minwidth(oldwin-&gt;w_frame, NOWIN);</a>
<a name="ln1230">      available = oldwin-&gt;w_frame-&gt;fr_width;</a>
<a name="ln1231">      needed += minwidth;</a>
<a name="ln1232">    }</a>
<a name="ln1233">    if (available &lt; needed &amp;&amp; new_in_layout) {</a>
<a name="ln1234">      emsg(_(e_noroom));</a>
<a name="ln1235">      return FAIL;</a>
<a name="ln1236">    }</a>
<a name="ln1237">    if (new_size == 0) {</a>
<a name="ln1238">      new_size = oldwin-&gt;w_width / 2;</a>
<a name="ln1239">    }</a>
<a name="ln1240">    if (new_size &gt; available - minwidth - 1) {</a>
<a name="ln1241">      new_size = available - minwidth - 1;</a>
<a name="ln1242">    }</a>
<a name="ln1243">    if (new_size &lt; wmw1) {</a>
<a name="ln1244">      new_size = wmw1;</a>
<a name="ln1245">    }</a>
<a name="ln1246"> </a>
<a name="ln1247">    // if it doesn't fit in the current window, need win_equal()</a>
<a name="ln1248">    if (oldwin-&gt;w_width - new_size - 1 &lt; p_wmw) {</a>
<a name="ln1249">      do_equal = true;</a>
<a name="ln1250">    }</a>
<a name="ln1251"> </a>
<a name="ln1252">    // We don't like to take lines for the new window from a</a>
<a name="ln1253">    // 'winfixwidth' window.  Take them from a window to the left or right</a>
<a name="ln1254">    // instead, if possible. Add one for the separator.</a>
<a name="ln1255">    if (oldwin-&gt;w_p_wfw) {</a>
<a name="ln1256">      win_setwidth_win(oldwin-&gt;w_width + new_size + 1, oldwin);</a>
<a name="ln1257">    }</a>
<a name="ln1258"> </a>
<a name="ln1259">    // Only make all windows the same width if one of them (except oldwin)</a>
<a name="ln1260">    // is wider than one of the split windows.</a>
<a name="ln1261">    if (!do_equal &amp;&amp; p_ea &amp;&amp; size == 0 &amp;&amp; *p_ead != 'v'</a>
<a name="ln1262">        &amp;&amp; oldwin-&gt;w_frame-&gt;fr_parent != NULL) {</a>
<a name="ln1263">      frame_T *frp = oldwin-&gt;w_frame-&gt;fr_parent-&gt;fr_child;</a>
<a name="ln1264">      while (frp != NULL) {</a>
<a name="ln1265">        if (frp-&gt;fr_win != oldwin &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln1266">            &amp;&amp; (frp-&gt;fr_win-&gt;w_width &gt; new_size</a>
<a name="ln1267">                || frp-&gt;fr_win-&gt;w_width &gt; (oldwin-&gt;w_width</a>
<a name="ln1268">                                           - new_size - 1))) {</a>
<a name="ln1269">          do_equal = true;</a>
<a name="ln1270">          break;</a>
<a name="ln1271">        }</a>
<a name="ln1272">        frp = frp-&gt;fr_next;</a>
<a name="ln1273">      }</a>
<a name="ln1274">    }</a>
<a name="ln1275">  } else {</a>
<a name="ln1276">    // Check if we are able to split the current window and compute its height.</a>
<a name="ln1277">    // Current window requires at least 1 space plus space for the window bar.</a>
<a name="ln1278">    int wmh1 = MAX((int)p_wmh, 1) + oldwin-&gt;w_winbar_height;</a>
<a name="ln1279">    int needed = wmh1 + STATUS_HEIGHT;</a>
<a name="ln1280">    if (flags &amp; WSP_ROOM) {</a>
<a name="ln1281">      needed += (int)p_wh - wmh1 + oldwin-&gt;w_winbar_height;</a>
<a name="ln1282">    }</a>
<a name="ln1283">    if (p_ch &lt; 1) {</a>
<a name="ln1284">      needed += 1;  // Adjust for cmdheight=0.</a>
<a name="ln1285">    }</a>
<a name="ln1286">    int minheight;</a>
<a name="ln1287">    int available;</a>
<a name="ln1288">    if (flags &amp; (WSP_BOT | WSP_TOP)) {</a>
<a name="ln1289">      minheight = frame_minheight(topframe, NOWIN) + need_status;</a>
<a name="ln1290">      available = topframe-&gt;fr_height;</a>
<a name="ln1291">      needed += minheight;</a>
<a name="ln1292">    } else if (p_ea) {</a>
<a name="ln1293">      minheight = frame_minheight(oldwin-&gt;w_frame, NOWIN) + need_status;</a>
<a name="ln1294">      frame_T *prevfrp = oldwin-&gt;w_frame;</a>
<a name="ln1295">      for (frame_T *frp = oldwin-&gt;w_frame-&gt;fr_parent; frp != NULL; frp = frp-&gt;fr_parent) {</a>
<a name="ln1296">        if (frp-&gt;fr_layout == FR_COL) {</a>
<a name="ln1297">          frame_T *frp2;</a>
<a name="ln1298">          FOR_ALL_FRAMES(frp2, frp-&gt;fr_child) {</a>
<a name="ln1299">            if (frp2 != prevfrp) {</a>
<a name="ln1300">              minheight += frame_minheight(frp2, NOWIN);</a>
<a name="ln1301">            }</a>
<a name="ln1302">          }</a>
<a name="ln1303">        }</a>
<a name="ln1304">        prevfrp = frp;</a>
<a name="ln1305">      }</a>
<a name="ln1306">      available = topframe-&gt;fr_height;</a>
<a name="ln1307">      needed += minheight;</a>
<a name="ln1308">    } else {</a>
<a name="ln1309">      minheight = frame_minheight(oldwin-&gt;w_frame, NOWIN) + need_status;</a>
<a name="ln1310">      available = oldwin-&gt;w_frame-&gt;fr_height;</a>
<a name="ln1311">      needed += minheight;</a>
<a name="ln1312">    }</a>
<a name="ln1313">    if (available &lt; needed &amp;&amp; new_in_layout) {</a>
<a name="ln1314">      emsg(_(e_noroom));</a>
<a name="ln1315">      return FAIL;</a>
<a name="ln1316">    }</a>
<a name="ln1317">    oldwin_height = oldwin-&gt;w_height;</a>
<a name="ln1318">    if (need_status) {</a>
<a name="ln1319">      oldwin-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln1320">      oldwin_height -= STATUS_HEIGHT;</a>
<a name="ln1321">    }</a>
<a name="ln1322">    if (new_size == 0) {</a>
<a name="ln1323">      new_size = oldwin_height / 2;</a>
<a name="ln1324">    }</a>
<a name="ln1325"> </a>
<a name="ln1326">    if (new_size &gt; available - minheight - STATUS_HEIGHT) {</a>
<a name="ln1327">      new_size = available - minheight - STATUS_HEIGHT;</a>
<a name="ln1328">    }</a>
<a name="ln1329">    if (new_size &lt; wmh1) {</a>
<a name="ln1330">      new_size = wmh1;</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    // if it doesn't fit in the current window, need win_equal()</a>
<a name="ln1334">    if (oldwin_height - new_size - STATUS_HEIGHT &lt; p_wmh) {</a>
<a name="ln1335">      do_equal = true;</a>
<a name="ln1336">    }</a>
<a name="ln1337"> </a>
<a name="ln1338">    // We don't like to take lines for the new window from a</a>
<a name="ln1339">    // 'winfixheight' window.  Take them from a window above or below</a>
<a name="ln1340">    // instead, if possible.</a>
<a name="ln1341">    if (oldwin-&gt;w_p_wfh) {</a>
<a name="ln1342">      // Set w_fraction now so that the cursor keeps the same relative</a>
<a name="ln1343">      // vertical position using the old height.</a>
<a name="ln1344">      set_fraction(oldwin);</a>
<a name="ln1345">      did_set_fraction = true;</a>
<a name="ln1346"> </a>
<a name="ln1347">      win_setheight_win(oldwin-&gt;w_height + new_size + STATUS_HEIGHT,</a>
<a name="ln1348">                        oldwin);</a>
<a name="ln1349">      oldwin_height = oldwin-&gt;w_height;</a>
<a name="ln1350">      if (need_status) {</a>
<a name="ln1351">        oldwin_height -= STATUS_HEIGHT;</a>
<a name="ln1352">      }</a>
<a name="ln1353">    }</a>
<a name="ln1354"> </a>
<a name="ln1355">    // Only make all windows the same height if one of them (except oldwin)</a>
<a name="ln1356">    // is higher than one of the split windows.</a>
<a name="ln1357">    if (!do_equal &amp;&amp; p_ea &amp;&amp; size == 0</a>
<a name="ln1358">        &amp;&amp; *p_ead != 'h'</a>
<a name="ln1359">        &amp;&amp; oldwin-&gt;w_frame-&gt;fr_parent != NULL) {</a>
<a name="ln1360">      frame_T *frp = oldwin-&gt;w_frame-&gt;fr_parent-&gt;fr_child;</a>
<a name="ln1361">      while (frp != NULL) {</a>
<a name="ln1362">        if (frp-&gt;fr_win != oldwin &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln1363">            &amp;&amp; (frp-&gt;fr_win-&gt;w_height &gt; new_size</a>
<a name="ln1364">                || frp-&gt;fr_win-&gt;w_height &gt; oldwin_height - new_size - STATUS_HEIGHT)) {</a>
<a name="ln1365">          do_equal = true;</a>
<a name="ln1366">          break;</a>
<a name="ln1367">        }</a>
<a name="ln1368">        frp = frp-&gt;fr_next;</a>
<a name="ln1369">      }</a>
<a name="ln1370">    }</a>
<a name="ln1371">  }</a>
<a name="ln1372"> </a>
<a name="ln1373">  // allocate new window structure and link it in the window list</a>
<a name="ln1374">  if ((flags &amp; WSP_TOP) == 0</a>
<a name="ln1375">      &amp;&amp; ((flags &amp; WSP_BOT)</a>
<a name="ln1376">          || (flags &amp; WSP_BELOW)</a>
<a name="ln1377">          || (!(flags &amp; WSP_ABOVE)</a>
<a name="ln1378">              &amp;&amp; ((flags &amp; WSP_VERT) ? p_spr : p_sb)))) {</a>
<a name="ln1379">    // new window below/right of current one</a>
<a name="ln1380">    if (new_wp == NULL) {</a>
<a name="ln1381">      wp = win_alloc(oldwin, false);</a>
<a name="ln1382">    } else {</a>
<a name="ln1383">      win_append(oldwin, wp);</a>
<a name="ln1384">    }</a>
<a name="ln1385">  } else {</a>
<a name="ln1386">    if (new_wp == NULL) {</a>
<a name="ln1387">      wp = win_alloc(oldwin-&gt;w_prev, false);</a>
<a name="ln1388">    } else {</a>
<a name="ln1389">      win_append(oldwin-&gt;w_prev, wp);</a>
<a name="ln1390">    }</a>
<a name="ln1391">  }</a>
<a name="ln1392"> </a>
<a name="ln1393">  if (new_wp == NULL) {</a>
<a name="ln1394">    if (wp == NULL) {</a>
<a name="ln1395">      return FAIL;</a>
<a name="ln1396">    }</a>
<a name="ln1397"> </a>
<a name="ln1398">    new_frame(wp);</a>
<a name="ln1399"> </a>
<a name="ln1400">    // make the contents of the new window the same as the current one</a>
<a name="ln1401">    win_init(wp, curwin, flags);</a>
<a name="ln1402">  } else if (wp-&gt;w_floating) {</a>
<a name="ln1403">    new_frame(wp);</a>
<a name="ln1404">    wp-&gt;w_floating = false;</a>
<a name="ln1405">    // non-floating window doesn't store float config or have a border.</a>
<a name="ln1406">    wp-&gt;w_float_config = FLOAT_CONFIG_INIT;</a>
<a name="ln1407">    CLEAR_FIELD(wp-&gt;w_border_adj);</a>
<a name="ln1408">  }</a>
<a name="ln1409"> </a>
<a name="ln1410">  int before;</a>
<a name="ln1411">  frame_T *curfrp;</a>
<a name="ln1412"> </a>
<a name="ln1413">  // Reorganise the tree of frames to insert the new window.</a>
<a name="ln1414">  if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1415">    if ((topframe-&gt;fr_layout == FR_COL &amp;&amp; (flags &amp; WSP_VERT) == 0)</a>
<a name="ln1416">        || (topframe-&gt;fr_layout == FR_ROW &amp;&amp; (flags &amp; WSP_VERT) != 0)) {</a>
<a name="ln1417">      curfrp = topframe-&gt;fr_child;</a>
<a name="ln1418">      if (flags &amp; WSP_BOT) {</a>
<a name="ln1419">        while (curfrp-&gt;fr_next != NULL) {</a>
<a name="ln1420">          curfrp = curfrp-&gt;fr_next;</a>
<a name="ln1421">        }</a>
<a name="ln1422">      }</a>
<a name="ln1423">    } else {</a>
<a name="ln1424">      curfrp = topframe;</a>
<a name="ln1425">    }</a>
<a name="ln1426">    before = (flags &amp; WSP_TOP);</a>
<a name="ln1427">  } else {</a>
<a name="ln1428">    curfrp = oldwin-&gt;w_frame;</a>
<a name="ln1429">    if (flags &amp; WSP_BELOW) {</a>
<a name="ln1430">      before = false;</a>
<a name="ln1431">    } else if (flags &amp; WSP_ABOVE) {</a>
<a name="ln1432">      before = true;</a>
<a name="ln1433">    } else if (flags &amp; WSP_VERT) {</a>
<a name="ln1434">      before = !p_spr;</a>
<a name="ln1435">    } else {</a>
<a name="ln1436">      before = !p_sb;</a>
<a name="ln1437">    }</a>
<a name="ln1438">  }</a>
<a name="ln1439">  if (curfrp-&gt;fr_parent == NULL || curfrp-&gt;fr_parent-&gt;fr_layout != layout) {</a>
<a name="ln1440">    // Need to create a new frame in the tree to make a branch.</a>
<a name="ln1441">    frame_T *frp = xcalloc(1, sizeof(frame_T));</a>
<a name="ln1442">    *frp = *curfrp;</a>
<a name="ln1443">    curfrp-&gt;fr_layout = (char)layout;</a>
<a name="ln1444">    frp-&gt;fr_parent = curfrp;</a>
<a name="ln1445">    frp-&gt;fr_next = NULL;</a>
<a name="ln1446">    frp-&gt;fr_prev = NULL;</a>
<a name="ln1447">    curfrp-&gt;fr_child = frp;</a>
<a name="ln1448">    curfrp-&gt;fr_win = NULL;</a>
<a name="ln1449">    curfrp = frp;</a>
<a name="ln1450">    if (frp-&gt;fr_win != NULL) {</a>
<a name="ln1451">      oldwin-&gt;w_frame = frp;</a>
<a name="ln1452">    } else {</a>
<a name="ln1453">      FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln1454">        frp-&gt;fr_parent = curfrp;</a>
<a name="ln1455">      }</a>
<a name="ln1456">    }</a>
<a name="ln1457">  }</a>
<a name="ln1458"> </a>
<a name="ln1459">  frame_T *frp;</a>
<a name="ln1460">  if (new_wp == NULL) {</a>
<a name="ln1461">    frp = wp-&gt;w_frame;</a>
<a name="ln1462">  } else {</a>
<a name="ln1463">    frp = new_wp-&gt;w_frame;</a>
<a name="ln1464">  }</a>
<a name="ln1465">  frp-&gt;fr_parent = curfrp-&gt;fr_parent;</a>
<a name="ln1466"> </a>
<a name="ln1467">  // Insert the new frame at the right place in the frame list.</a>
<a name="ln1468">  if (before) {</a>
<a name="ln1469">    frame_insert(curfrp, frp);</a>
<a name="ln1470">  } else {</a>
<a name="ln1471">    frame_append(curfrp, frp);</a>
<a name="ln1472">  }</a>
<a name="ln1473"> </a>
<a name="ln1474">  // Set w_fraction now so that the cursor keeps the same relative</a>
<a name="ln1475">  // vertical position.</a>
<a name="ln1476">  if (!did_set_fraction) {</a>
<a name="ln1477">    set_fraction(oldwin);</a>
<a name="ln1478">  }</a>
<a name="ln1479">  wp-&gt;w_fraction = oldwin-&gt;w_fraction;</a>
<a name="ln1480"> </a>
<a name="ln1481">  if (flags &amp; WSP_VERT) {</a>
<a name="ln1482">    wp-&gt;w_p_scr = curwin-&gt;w_p_scr;</a>
<a name="ln1483"> </a>
<a name="ln1484">    if (need_status) {</a>
<a name="ln1485">      win_new_height(oldwin, oldwin-&gt;w_height - 1);</a>
<a name="ln1486">      oldwin-&gt;w_status_height = need_status;</a>
<a name="ln1487">    }</a>
<a name="ln1488">    if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1489">      // set height and row of new window to full height</a>
<a name="ln1490">      wp-&gt;w_winrow = tabline_height();</a>
<a name="ln1491">      win_new_height(wp, curfrp-&gt;fr_height - (p_ls == 1 || p_ls == 2));</a>
<a name="ln1492">      wp-&gt;w_status_height = (p_ls == 1 || p_ls == 2);</a>
<a name="ln1493">      wp-&gt;w_hsep_height = 0;</a>
<a name="ln1494">    } else {</a>
<a name="ln1495">      // height and row of new window is same as current window</a>
<a name="ln1496">      wp-&gt;w_winrow = oldwin-&gt;w_winrow;</a>
<a name="ln1497">      win_new_height(wp, oldwin-&gt;w_height);</a>
<a name="ln1498">      wp-&gt;w_status_height = oldwin-&gt;w_status_height;</a>
<a name="ln1499">      wp-&gt;w_hsep_height = oldwin-&gt;w_hsep_height;</a>
<a name="ln1500">    }</a>
<a name="ln1501">    frp-&gt;fr_height = curfrp-&gt;fr_height;</a>
<a name="ln1502"> </a>
<a name="ln1503">    // &quot;new_size&quot; of the current window goes to the new window, use</a>
<a name="ln1504">    // one column for the vertical separator</a>
<a name="ln1505">    win_new_width(wp, new_size);</a>
<a name="ln1506">    if (before) {</a>
<a name="ln1507">      wp-&gt;w_vsep_width = 1;</a>
<a name="ln1508">    } else {</a>
<a name="ln1509">      wp-&gt;w_vsep_width = oldwin-&gt;w_vsep_width;</a>
<a name="ln1510">      oldwin-&gt;w_vsep_width = 1;</a>
<a name="ln1511">    }</a>
<a name="ln1512">    if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1513">      if (flags &amp; WSP_BOT) {</a>
<a name="ln1514">        frame_add_vsep(curfrp);</a>
<a name="ln1515">      }</a>
<a name="ln1516">      // Set width of neighbor frame</a>
<a name="ln1517">      frame_new_width(curfrp, curfrp-&gt;fr_width</a>
<a name="ln1518">                      - (new_size + ((flags &amp; WSP_TOP) != 0)), flags &amp; WSP_TOP,</a>
<a name="ln1519">                      false);</a>
<a name="ln1520">    } else {</a>
<a name="ln1521">      win_new_width(oldwin, oldwin-&gt;w_width - (new_size + 1));</a>
<a name="ln1522">    }</a>
<a name="ln1523">    if (before) {       // new window left of current one</a>
<a name="ln1524">      wp-&gt;w_wincol = oldwin-&gt;w_wincol;</a>
<a name="ln1525">      oldwin-&gt;w_wincol += new_size + 1;</a>
<a name="ln1526">    } else {  // new window right of current one</a>
<a name="ln1527">      wp-&gt;w_wincol = oldwin-&gt;w_wincol + oldwin-&gt;w_width + 1;</a>
<a name="ln1528">    }</a>
<a name="ln1529">    frame_fix_width(oldwin);</a>
<a name="ln1530">    frame_fix_width(wp);</a>
<a name="ln1531">  } else {</a>
<a name="ln1532">    const bool is_stl_global = global_stl_height() &gt; 0;</a>
<a name="ln1533">    // width and column of new window is same as current window</a>
<a name="ln1534">    if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1535">      wp-&gt;w_wincol = 0;</a>
<a name="ln1536">      win_new_width(wp, Columns);</a>
<a name="ln1537">      wp-&gt;w_vsep_width = 0;</a>
<a name="ln1538">    } else {</a>
<a name="ln1539">      wp-&gt;w_wincol = oldwin-&gt;w_wincol;</a>
<a name="ln1540">      win_new_width(wp, oldwin-&gt;w_width);</a>
<a name="ln1541">      wp-&gt;w_vsep_width = oldwin-&gt;w_vsep_width;</a>
<a name="ln1542">    }</a>
<a name="ln1543">    frp-&gt;fr_width = curfrp-&gt;fr_width;</a>
<a name="ln1544"> </a>
<a name="ln1545">    // &quot;new_size&quot; of the current window goes to the new window, use</a>
<a name="ln1546">    // one row for the status line</a>
<a name="ln1547">    win_new_height(wp, new_size);</a>
<a name="ln1548">    const int old_status_height = oldwin-&gt;w_status_height;</a>
<a name="ln1549">    if (before) {</a>
<a name="ln1550">      wp-&gt;w_hsep_height = is_stl_global ? 1 : 0;</a>
<a name="ln1551">    } else {</a>
<a name="ln1552">      wp-&gt;w_hsep_height = oldwin-&gt;w_hsep_height;</a>
<a name="ln1553">      oldwin-&gt;w_hsep_height = is_stl_global ? 1 : 0;</a>
<a name="ln1554">    }</a>
<a name="ln1555">    if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1556">      int new_fr_height = curfrp-&gt;fr_height - new_size;</a>
<a name="ln1557">      if (is_stl_global) {</a>
<a name="ln1558">        if (flags &amp; WSP_BOT) {</a>
<a name="ln1559">          frame_add_hsep(curfrp);</a>
<a name="ln1560">        } else {</a>
<a name="ln1561">          new_fr_height -= 1;</a>
<a name="ln1562">        }</a>
<a name="ln1563">      } else {</a>
<a name="ln1564">        if (!((flags &amp; WSP_BOT) &amp;&amp; p_ls == 0)) {</a>
<a name="ln1565">          new_fr_height -= STATUS_HEIGHT;</a>
<a name="ln1566">        }</a>
<a name="ln1567">        if (flags &amp; WSP_BOT) {</a>
<a name="ln1568">          frame_add_statusline(curfrp);</a>
<a name="ln1569">        }</a>
<a name="ln1570">      }</a>
<a name="ln1571">      frame_new_height(curfrp, new_fr_height, flags &amp; WSP_TOP, false);</a>
<a name="ln1572">    } else {</a>
<a name="ln1573">      win_new_height(oldwin, oldwin_height - (new_size + STATUS_HEIGHT));</a>
<a name="ln1574">    }</a>
<a name="ln1575"> </a>
<a name="ln1576">    if (before) {       // new window above current one</a>
<a name="ln1577">      wp-&gt;w_winrow = oldwin-&gt;w_winrow;</a>
<a name="ln1578">      if (is_stl_global) {</a>
<a name="ln1579">        wp-&gt;w_status_height = 0;</a>
<a name="ln1580">        oldwin-&gt;w_winrow += wp-&gt;w_height + 1;</a>
<a name="ln1581">      } else {</a>
<a name="ln1582">        wp-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln1583">        oldwin-&gt;w_winrow += wp-&gt;w_height + STATUS_HEIGHT;</a>
<a name="ln1584">      }</a>
<a name="ln1585">    } else {            // new window below current one</a>
<a name="ln1586">      if (is_stl_global) {</a>
<a name="ln1587">        wp-&gt;w_winrow = oldwin-&gt;w_winrow + oldwin-&gt;w_height + 1;</a>
<a name="ln1588">        wp-&gt;w_status_height = 0;</a>
<a name="ln1589">      } else {</a>
<a name="ln1590">        wp-&gt;w_winrow = oldwin-&gt;w_winrow + oldwin-&gt;w_height + STATUS_HEIGHT;</a>
<a name="ln1591">        wp-&gt;w_status_height = old_status_height;</a>
<a name="ln1592">        if (!(flags &amp; WSP_BOT)) {</a>
<a name="ln1593">          oldwin-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln1594">        }</a>
<a name="ln1595">      }</a>
<a name="ln1596">    }</a>
<a name="ln1597">    frame_fix_height(wp);</a>
<a name="ln1598">    frame_fix_height(oldwin);</a>
<a name="ln1599">  }</a>
<a name="ln1600"> </a>
<a name="ln1601">  if (flags &amp; (WSP_TOP | WSP_BOT)) {</a>
<a name="ln1602">    (void)win_comp_pos();</a>
<a name="ln1603">  }</a>
<a name="ln1604"> </a>
<a name="ln1605">  // Both windows need redrawing.  Update all status lines, in case they</a>
<a name="ln1606">  // show something related to the window count or position.</a>
<a name="ln1607">  redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln1608">  redraw_later(oldwin, UPD_NOT_VALID);</a>
<a name="ln1609">  status_redraw_all();</a>
<a name="ln1610"> </a>
<a name="ln1611">  if (need_status) {</a>
<a name="ln1612">    msg_row = Rows - 1;</a>
<a name="ln1613">    msg_col = sc_col;</a>
<a name="ln1614">    msg_clr_eos_force();        // Old command/ruler may still be there</a>
<a name="ln1615">    comp_col();</a>
<a name="ln1616">    msg_row = Rows - 1;</a>
<a name="ln1617">    msg_col = 0;        // put position back at start of line</a>
<a name="ln1618">  }</a>
<a name="ln1619"> </a>
<a name="ln1620">  // equalize the window sizes.</a>
<a name="ln1621">  if (do_equal || dir != 0) {</a>
<a name="ln1622">    win_equal(wp, true, (flags &amp; WSP_VERT) ? (dir == 'v' ? 'b' : 'h') : (dir == 'h' ? 'b' : 'v'));</a>
<a name="ln1623">  } else if (!is_aucmd_win(wp)) {</a>
<a name="ln1624">    win_fix_scroll(false);</a>
<a name="ln1625">  }</a>
<a name="ln1626"> </a>
<a name="ln1627">  int i;</a>
<a name="ln1628"> </a>
<a name="ln1629">  // Don't change the window height/width to 'winheight' / 'winwidth' if a</a>
<a name="ln1630">  // size was given.</a>
<a name="ln1631">  if (flags &amp; WSP_VERT) {</a>
<a name="ln1632">    i = (int)p_wiw;</a>
<a name="ln1633">    if (size != 0) {</a>
<a name="ln1634">      p_wiw = size;</a>
<a name="ln1635">    }</a>
<a name="ln1636">  } else {</a>
<a name="ln1637">    i = (int)p_wh;</a>
<a name="ln1638">    if (size != 0) {</a>
<a name="ln1639">      p_wh = size;</a>
<a name="ln1640">    }</a>
<a name="ln1641">  }</a>
<a name="ln1642"> </a>
<a name="ln1643">  // make the new window the current window</a>
<a name="ln1644">  win_enter_ext(wp, WEE_TRIGGER_NEW_AUTOCMDS | WEE_TRIGGER_ENTER_AUTOCMDS</a>
<a name="ln1645">                | WEE_TRIGGER_LEAVE_AUTOCMDS);</a>
<a name="ln1646">  if (flags &amp; WSP_VERT) {</a>
<a name="ln1647">    p_wiw = i;</a>
<a name="ln1648">  } else {</a>
<a name="ln1649">    p_wh = i;</a>
<a name="ln1650">  }</a>
<a name="ln1651"> </a>
<a name="ln1652">  if (win_valid(oldwin)) {</a>
<a name="ln1653">    // Send the window positions to the UI</a>
<a name="ln1654">    oldwin-&gt;w_pos_changed = true;</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657">  return OK;</a>
<a name="ln1658">}</a>
<a name="ln1659"> </a>
<a name="ln1660">// Initialize window &quot;newp&quot; from window &quot;oldp&quot;.</a>
<a name="ln1661">// Used when splitting a window and when creating a new tab page.</a>
<a name="ln1662">// The windows will both edit the same buffer.</a>
<a name="ln1663">// WSP_NEWLOC may be specified in flags to prevent the location list from</a>
<a name="ln1664">// being copied.</a>
<a name="ln1665">static void win_init(win_T *newp, win_T *oldp, int flags)</a>
<a name="ln1666">{</a>
<a name="ln1667">  newp-&gt;w_buffer = oldp-&gt;w_buffer;</a>
<a name="ln1668">  newp-&gt;w_s = &amp;(oldp-&gt;w_buffer-&gt;b_s);</a>
<a name="ln1669">  oldp-&gt;w_buffer-&gt;b_nwindows++;</a>
<a name="ln1670">  newp-&gt;w_cursor = oldp-&gt;w_cursor;</a>
<a name="ln1671">  newp-&gt;w_valid = 0;</a>
<a name="ln1672">  newp-&gt;w_curswant = oldp-&gt;w_curswant;</a>
<a name="ln1673">  newp-&gt;w_set_curswant = oldp-&gt;w_set_curswant;</a>
<a name="ln1674">  newp-&gt;w_topline = oldp-&gt;w_topline;</a>
<a name="ln1675">  newp-&gt;w_topfill = oldp-&gt;w_topfill;</a>
<a name="ln1676">  newp-&gt;w_leftcol = oldp-&gt;w_leftcol;</a>
<a name="ln1677">  newp-&gt;w_pcmark = oldp-&gt;w_pcmark;</a>
<a name="ln1678">  newp-&gt;w_prev_pcmark = oldp-&gt;w_prev_pcmark;</a>
<a name="ln1679">  newp-&gt;w_alt_fnum = oldp-&gt;w_alt_fnum;</a>
<a name="ln1680">  newp-&gt;w_wrow = oldp-&gt;w_wrow;</a>
<a name="ln1681">  newp-&gt;w_fraction = oldp-&gt;w_fraction;</a>
<a name="ln1682">  newp-&gt;w_prev_fraction_row = oldp-&gt;w_prev_fraction_row;</a>
<a name="ln1683">  copy_jumplist(oldp, newp);</a>
<a name="ln1684">  if (flags &amp; WSP_NEWLOC) {</a>
<a name="ln1685">    // Don't copy the location list.</a>
<a name="ln1686">    newp-&gt;w_llist = NULL;</a>
<a name="ln1687">    newp-&gt;w_llist_ref = NULL;</a>
<a name="ln1688">  } else {</a>
<a name="ln1689">    copy_loclist_stack(oldp, newp);</a>
<a name="ln1690">  }</a>
<a name="ln1691">  newp-&gt;w_localdir = (oldp-&gt;w_localdir == NULL)</a>
<a name="ln1692">                     ? NULL : xstrdup(oldp-&gt;w_localdir);</a>
<a name="ln1693">  newp-&gt;w_prevdir = (oldp-&gt;w_prevdir == NULL)</a>
<a name="ln1694">                    ? NULL : xstrdup(oldp-&gt;w_prevdir);</a>
<a name="ln1695"> </a>
<a name="ln1696">  if (*p_spk != 'c') {</a>
<a name="ln1697">    if (*p_spk == 't') {</a>
<a name="ln1698">      newp-&gt;w_skipcol = oldp-&gt;w_skipcol;</a>
<a name="ln1699">    }</a>
<a name="ln1700">    newp-&gt;w_botline = oldp-&gt;w_botline;</a>
<a name="ln1701">    newp-&gt;w_prev_height = oldp-&gt;w_height;</a>
<a name="ln1702">    newp-&gt;w_prev_winrow = oldp-&gt;w_winrow;</a>
<a name="ln1703">  }</a>
<a name="ln1704"> </a>
<a name="ln1705">  // copy tagstack and folds</a>
<a name="ln1706">  for (int i = 0; i &lt; oldp-&gt;w_tagstacklen; i++) {</a>
<a name="ln1707">    taggy_T *tag = &amp;newp-&gt;w_tagstack[i];</a>
<a name="ln1708">    *tag = oldp-&gt;w_tagstack[i];</a>
<a name="ln1709">    if (tag-&gt;tagname != NULL) {</a>
<a name="ln1710">      tag-&gt;tagname = xstrdup(tag-&gt;tagname);</a>
<a name="ln1711">    }</a>
<a name="ln1712">    if (tag-&gt;user_data != NULL) {</a>
<a name="ln1713">      tag-&gt;user_data = xstrdup(tag-&gt;user_data);</a>
<a name="ln1714">    }</a>
<a name="ln1715">  }</a>
<a name="ln1716">  newp-&gt;w_tagstackidx = oldp-&gt;w_tagstackidx;</a>
<a name="ln1717">  newp-&gt;w_tagstacklen = oldp-&gt;w_tagstacklen;</a>
<a name="ln1718"> </a>
<a name="ln1719">  // Keep same changelist position in new window.</a>
<a name="ln1720">  newp-&gt;w_changelistidx = oldp-&gt;w_changelistidx;</a>
<a name="ln1721"> </a>
<a name="ln1722">  copyFoldingState(oldp, newp);</a>
<a name="ln1723"> </a>
<a name="ln1724">  win_init_some(newp, oldp);</a>
<a name="ln1725"> </a>
<a name="ln1726">  newp-&gt;w_winbar_height = oldp-&gt;w_winbar_height;</a>
<a name="ln1727">}</a>
<a name="ln1728"> </a>
<a name="ln1729">// Initialize window &quot;newp&quot; from window &quot;old&quot;.</a>
<a name="ln1730">// Only the essential things are copied.</a>
<a name="ln1731">static void win_init_some(win_T *newp, win_T *oldp)</a>
<a name="ln1732">{</a>
<a name="ln1733">  // Use the same argument list.</a>
<a name="ln1734">  newp-&gt;w_alist = oldp-&gt;w_alist;</a>
<a name="ln1735">  newp-&gt;w_alist-&gt;al_refcount++;</a>
<a name="ln1736">  newp-&gt;w_arg_idx = oldp-&gt;w_arg_idx;</a>
<a name="ln1737"> </a>
<a name="ln1738">  // copy options from existing window</a>
<a name="ln1739">  win_copy_options(oldp, newp);</a>
<a name="ln1740">}</a>
<a name="ln1741"> </a>
<a name="ln1742">/// Return true if &quot;win&quot; is floating window in the current tab page.</a>
<a name="ln1743">///</a>
<a name="ln1744">/// @param  win  window to check</a>
<a name="ln1745">bool win_valid_floating(const win_T *win)</a>
<a name="ln1746">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1747">{</a>
<a name="ln1748">  if (win == NULL) {</a>
<a name="ln1749">    return false;</a>
<a name="ln1750">  }</a>
<a name="ln1751"> </a>
<a name="ln1752">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1753">    if (wp == win) {</a>
<a name="ln1754">      return wp-&gt;w_floating;</a>
<a name="ln1755">    }</a>
<a name="ln1756">  }</a>
<a name="ln1757">  return false;</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760">/// Check if &quot;win&quot; is a pointer to an existing window in the current tabpage.</a>
<a name="ln1761">///</a>
<a name="ln1762">/// @param  win  window to check</a>
<a name="ln1763">bool win_valid(const win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1764">{</a>
<a name="ln1765">  return tabpage_win_valid(curtab, win);</a>
<a name="ln1766">}</a>
<a name="ln1767"> </a>
<a name="ln1768">/// Check if &quot;win&quot; is a pointer to an existing window in tabpage &quot;tp&quot;.</a>
<a name="ln1769">///</a>
<a name="ln1770">/// @param  win  window to check</a>
<a name="ln1771">static bool tabpage_win_valid(const tabpage_T *tp, const win_T *win)</a>
<a name="ln1772">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1773">{</a>
<a name="ln1774">  if (win == NULL) {</a>
<a name="ln1775">    return false;</a>
<a name="ln1776">  }</a>
<a name="ln1777"> </a>
<a name="ln1778">  FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln1779">    if (wp == win) {</a>
<a name="ln1780">      return true;</a>
<a name="ln1781">    }</a>
<a name="ln1782">  }</a>
<a name="ln1783">  return false;</a>
<a name="ln1784">}</a>
<a name="ln1785"> </a>
<a name="ln1786">// Find window &quot;handle&quot; in the current tab page.</a>
<a name="ln1787">// Return NULL if not found.</a>
<a name="ln1788">win_T *win_find_by_handle(handle_T handle)</a>
<a name="ln1789">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1790">{</a>
<a name="ln1791">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1792">    if (wp-&gt;handle == handle) {</a>
<a name="ln1793">      return wp;</a>
<a name="ln1794">    }</a>
<a name="ln1795">  }</a>
<a name="ln1796">  return NULL;</a>
<a name="ln1797">}</a>
<a name="ln1798"> </a>
<a name="ln1799">/// Check if &quot;win&quot; is a pointer to an existing window in any tabpage.</a>
<a name="ln1800">///</a>
<a name="ln1801">/// @param  win  window to check</a>
<a name="ln1802">bool win_valid_any_tab(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln1803">{</a>
<a name="ln1804">  if (win == NULL) {</a>
<a name="ln1805">    return false;</a>
<a name="ln1806">  }</a>
<a name="ln1807"> </a>
<a name="ln1808">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln1809">    if (wp == win) {</a>
<a name="ln1810">      return true;</a>
<a name="ln1811">    }</a>
<a name="ln1812">  }</a>
<a name="ln1813">  return false;</a>
<a name="ln1814">}</a>
<a name="ln1815"> </a>
<a name="ln1816">// Return the number of windows.</a>
<a name="ln1817">int win_count(void)</a>
<a name="ln1818">{</a>
<a name="ln1819">  int count = 0;</a>
<a name="ln1820"> </a>
<a name="ln1821">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln1822">    count++;</a>
<a name="ln1823">  }</a>
<a name="ln1824">  return count;</a>
<a name="ln1825">}</a>
<a name="ln1826"> </a>
<a name="ln1827">/// Make &quot;count&quot; windows on the screen.</a>
<a name="ln1828">/// Must be called when there is just one window, filling the whole screen.</a>
<a name="ln1829">/// (excluding the command line).</a>
<a name="ln1830">///</a>
<a name="ln1831">/// @param vertical  split windows vertically if true.</a>
<a name="ln1832">///</a>
<a name="ln1833">/// @return actual number of windows on the screen.</a>
<a name="ln1834">int make_windows(int count, bool vertical)</a>
<a name="ln1835">{</a>
<a name="ln1836">  int maxcount;</a>
<a name="ln1837"> </a>
<a name="ln1838">  if (vertical) {</a>
<a name="ln1839">    // Each window needs at least 'winminwidth' lines and a separator column.</a>
<a name="ln1840">    maxcount = (int)(curwin-&gt;w_width + curwin-&gt;w_vsep_width</a>
<a name="ln1841">                     - (p_wiw - p_wmw)) / ((int)p_wmw + 1);</a>
<a name="ln1842">  } else {</a>
<a name="ln1843">    // Each window needs at least 'winminheight' lines.</a>
<a name="ln1844">    // If statusline isn't global, each window also needs a statusline.</a>
<a name="ln1845">    // If 'winbar' is set, each window also needs a winbar.</a>
<a name="ln1846">    maxcount = (int)(curwin-&gt;w_height + curwin-&gt;w_hsep_height + curwin-&gt;w_status_height</a>
<a name="ln1847">                     - (p_wh - p_wmh)) / ((int)p_wmh + STATUS_HEIGHT + global_winbar_height());</a>
<a name="ln1848">  }</a>
<a name="ln1849"> </a>
<a name="ln1850">  if (maxcount &lt; 2) {</a>
<a name="ln1851">    maxcount = 2;</a>
<a name="ln1852">  }</a>
<a name="ln1853">  if (count &gt; maxcount) {</a>
<a name="ln1854">    count = maxcount;</a>
<a name="ln1855">  }</a>
<a name="ln1856"> </a>
<a name="ln1857">  // add status line now, otherwise first window will be too big</a>
<a name="ln1858">  if (count &gt; 1) {</a>
<a name="ln1859">    last_status(true);</a>
<a name="ln1860">  }</a>
<a name="ln1861"> </a>
<a name="ln1862">  // Don't execute autocommands while creating the windows.  Must do that</a>
<a name="ln1863">  // when putting the buffers in the windows.</a>
<a name="ln1864">  block_autocmds();</a>
<a name="ln1865"> </a>
<a name="ln1866">  int todo;</a>
<a name="ln1867"> </a>
<a name="ln1868">  // todo is number of windows left to create</a>
<a name="ln1869">  for (todo = count - 1; todo &gt; 0; todo--) {</a>
<a name="ln1870">    if (vertical) {</a>
<a name="ln1871">      if (win_split(curwin-&gt;w_width - (curwin-&gt;w_width - todo)</a>
<a name="ln1872">                    / (todo + 1) - 1, WSP_VERT | WSP_ABOVE) == FAIL) {</a>
<a name="ln1873">        break;</a>
<a name="ln1874">      }</a>
<a name="ln1875">    } else {</a>
<a name="ln1876">      if (win_split(curwin-&gt;w_height - (curwin-&gt;w_height - todo</a>
<a name="ln1877">                                        * STATUS_HEIGHT) / (todo + 1)</a>
<a name="ln1878">                    - STATUS_HEIGHT, WSP_ABOVE) == FAIL) {</a>
<a name="ln1879">        break;</a>
<a name="ln1880">      }</a>
<a name="ln1881">    }</a>
<a name="ln1882">  }</a>
<a name="ln1883"> </a>
<a name="ln1884">  unblock_autocmds();</a>
<a name="ln1885"> </a>
<a name="ln1886">  // return actual number of windows</a>
<a name="ln1887">  return count - todo;</a>
<a name="ln1888">}</a>
<a name="ln1889"> </a>
<a name="ln1890">// Exchange current and next window</a>
<a name="ln1891">static void win_exchange(int Prenum)</a>
<a name="ln1892">{</a>
<a name="ln1893">  if (curwin-&gt;w_floating) {</a>
<a name="ln1894">    emsg(e_floatexchange);</a>
<a name="ln1895">    return;</a>
<a name="ln1896">  }</a>
<a name="ln1897"> </a>
<a name="ln1898">  if (firstwin == curwin &amp;&amp; lastwin_nofloating() == curwin) {</a>
<a name="ln1899">    // just one window</a>
<a name="ln1900">    beep_flush();</a>
<a name="ln1901">    return;</a>
<a name="ln1902">  }</a>
<a name="ln1903">  if (text_or_buf_locked()) {</a>
<a name="ln1904">    beep_flush();</a>
<a name="ln1905">    return;</a>
<a name="ln1906">  }</a>
<a name="ln1907"> </a>
<a name="ln1908">  frame_T *frp;</a>
<a name="ln1909"> </a>
<a name="ln1910">  // find window to exchange with</a>
<a name="ln1911">  if (Prenum) {</a>
<a name="ln1912">    frp = curwin-&gt;w_frame-&gt;fr_parent-&gt;fr_child;</a>
<a name="ln1913">    while (frp != NULL &amp;&amp; --Prenum &gt; 0) {</a>
<a name="ln1914">      frp = frp-&gt;fr_next;</a>
<a name="ln1915">    }</a>
<a name="ln1916">  } else if (curwin-&gt;w_frame-&gt;fr_next != NULL) {  // Swap with next</a>
<a name="ln1917">    frp = curwin-&gt;w_frame-&gt;fr_next;</a>
<a name="ln1918">  } else {  // Swap last window in row/col with previous</a>
<a name="ln1919">    frp = curwin-&gt;w_frame-&gt;fr_prev;</a>
<a name="ln1920">  }</a>
<a name="ln1921"> </a>
<a name="ln1922">  // We can only exchange a window with another window, not with a frame</a>
<a name="ln1923">  // containing windows.</a>
<a name="ln1924">  if (frp == NULL || frp-&gt;fr_win == NULL || frp-&gt;fr_win == curwin) {</a>
<a name="ln1925">    return;</a>
<a name="ln1926">  }</a>
<a name="ln1927">  win_T *wp = frp-&gt;fr_win;</a>
<a name="ln1928"> </a>
<a name="ln1929">  // 1. remove curwin from the list. Remember after which window it was in wp2</a>
<a name="ln1930">  // 2. insert curwin before wp in the list</a>
<a name="ln1931">  // if wp != wp2</a>
<a name="ln1932">  //    3. remove wp from the list</a>
<a name="ln1933">  //    4. insert wp after wp2</a>
<a name="ln1934">  // 5. exchange the status line height, winbar height, hsep height and vsep width.</a>
<a name="ln1935">  win_T *wp2 = curwin-&gt;w_prev;</a>
<a name="ln1936">  frame_T *frp2 = curwin-&gt;w_frame-&gt;fr_prev;</a>
<a name="ln1937">  if (wp-&gt;w_prev != curwin) {</a>
<a name="ln1938">    win_remove(curwin, NULL);</a>
<a name="ln1939">    frame_remove(curwin-&gt;w_frame);</a>
<a name="ln1940">    win_append(wp-&gt;w_prev, curwin);</a>
<a name="ln1941">    frame_insert(frp, curwin-&gt;w_frame);</a>
<a name="ln1942">  }</a>
<a name="ln1943">  if (wp != wp2) {</a>
<a name="ln1944">    win_remove(wp, NULL);</a>
<a name="ln1945">    frame_remove(wp-&gt;w_frame);</a>
<a name="ln1946">    win_append(wp2, wp);</a>
<a name="ln1947">    if (frp2 == NULL) {</a>
<a name="ln1948">      frame_insert(wp-&gt;w_frame-&gt;fr_parent-&gt;fr_child, wp-&gt;w_frame);</a>
<a name="ln1949">    } else {</a>
<a name="ln1950">      frame_append(frp2, wp-&gt;w_frame);</a>
<a name="ln1951">    }</a>
<a name="ln1952">  }</a>
<a name="ln1953">  int temp = curwin-&gt;w_status_height;</a>
<a name="ln1954">  curwin-&gt;w_status_height = wp-&gt;w_status_height;</a>
<a name="ln1955">  wp-&gt;w_status_height = temp;</a>
<a name="ln1956">  temp = curwin-&gt;w_vsep_width;</a>
<a name="ln1957">  curwin-&gt;w_vsep_width = wp-&gt;w_vsep_width;</a>
<a name="ln1958">  wp-&gt;w_vsep_width = temp;</a>
<a name="ln1959">  temp = curwin-&gt;w_hsep_height;</a>
<a name="ln1960">  curwin-&gt;w_hsep_height = wp-&gt;w_hsep_height;</a>
<a name="ln1961">  wp-&gt;w_hsep_height = temp;</a>
<a name="ln1962"> </a>
<a name="ln1963">  frame_fix_height(curwin);</a>
<a name="ln1964">  frame_fix_height(wp);</a>
<a name="ln1965">  frame_fix_width(curwin);</a>
<a name="ln1966">  frame_fix_width(wp);</a>
<a name="ln1967"> </a>
<a name="ln1968">  (void)win_comp_pos();                 // recompute window positions</a>
<a name="ln1969"> </a>
<a name="ln1970">  if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln1971">    reset_VIsual_and_resel();</a>
<a name="ln1972">  } else if (VIsual_active) {</a>
<a name="ln1973">    wp-&gt;w_cursor = curwin-&gt;w_cursor;</a>
<a name="ln1974">  }</a>
<a name="ln1975"> </a>
<a name="ln1976">  win_enter(wp, true);</a>
<a name="ln1977">  redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln1978">  redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">// rotate windows: if upwards true the second window becomes the first one</a>
<a name="ln1982">//                 if upwards false the first window becomes the second one</a>
<a name="ln1983">static void win_rotate(bool upwards, int count)</a>
<a name="ln1984">{</a>
<a name="ln1985">  if (curwin-&gt;w_floating) {</a>
<a name="ln1986">    emsg(e_floatexchange);</a>
<a name="ln1987">    return;</a>
<a name="ln1988">  }</a>
<a name="ln1989"> </a>
<a name="ln1990">  if (count &lt;= 0 || (firstwin == curwin &amp;&amp; lastwin_nofloating() == curwin)) {</a>
<a name="ln1991">    // nothing to do</a>
<a name="ln1992">    beep_flush();</a>
<a name="ln1993">    return;</a>
<a name="ln1994">  }</a>
<a name="ln1995"> </a>
<a name="ln1996">  // Check if all frames in this row/col have one window.</a>
<a name="ln1997">  frame_T *frp;</a>
<a name="ln1998">  FOR_ALL_FRAMES(frp, curwin-&gt;w_frame-&gt;fr_parent-&gt;fr_child) {</a>
<a name="ln1999">    if (frp-&gt;fr_win == NULL) {</a>
<a name="ln2000">      emsg(_(&quot;E443: Cannot rotate when another window is split&quot;));</a>
<a name="ln2001">      return;</a>
<a name="ln2002">    }</a>
<a name="ln2003">  }</a>
<a name="ln2004"> </a>
<a name="ln2005">  win_T *wp1 = NULL;</a>
<a name="ln2006">  win_T *wp2 = NULL;</a>
<a name="ln2007"> </a>
<a name="ln2008">  while (count--) {</a>
<a name="ln2009">    if (upwards) {              // first window becomes last window</a>
<a name="ln2010">      // remove first window/frame from the list</a>
<a name="ln2011">      frp = curwin-&gt;w_frame-&gt;fr_parent-&gt;fr_child;</a>
<a name="ln2012">      assert(frp != NULL);</a>
<a name="ln2013">      wp1 = frp-&gt;fr_win;</a>
<a name="ln2014">      win_remove(wp1, NULL);</a>
<a name="ln2015">      frame_remove(frp);</a>
<a name="ln2016">      assert(frp-&gt;fr_parent-&gt;fr_child);</a>
<a name="ln2017"> </a>
<a name="ln2018">      // find last frame and append removed window/frame after it</a>
<a name="ln2019">      for (; frp-&gt;fr_next != NULL; frp = frp-&gt;fr_next) {}</a>
<a name="ln2020">      win_append(frp-&gt;fr_win, wp1);</a>
<a name="ln2021">      frame_append(frp, wp1-&gt;w_frame);</a>
<a name="ln2022"> </a>
<a name="ln2023">      wp2 = frp-&gt;fr_win;                // previously last window</a>
<a name="ln2024">    } else {                  // last window becomes first window</a>
<a name="ln2025">      // find last window/frame in the list and remove it</a>
<a name="ln2026">      for (frp = curwin-&gt;w_frame; frp-&gt;fr_next != NULL;</a>
<a name="ln2027">           frp = frp-&gt;fr_next) {}</a>
<a name="ln2028">      wp1 = frp-&gt;fr_win;</a>
<a name="ln2029">      wp2 = wp1-&gt;w_prev;                    // will become last window</a>
<a name="ln2030">      win_remove(wp1, NULL);</a>
<a name="ln2031">      frame_remove(frp);</a>
<a name="ln2032">      assert(frp-&gt;fr_parent-&gt;fr_child);</a>
<a name="ln2033"> </a>
<a name="ln2034">      // append the removed window/frame before the first in the list</a>
<a name="ln2035">      win_append(frp-&gt;fr_parent-&gt;fr_child-&gt;fr_win-&gt;w_prev, wp1);</a>
<a name="ln2036">      frame_insert(frp-&gt;fr_parent-&gt;fr_child, frp);</a>
<a name="ln2037">    }</a>
<a name="ln2038"> </a>
<a name="ln2039">    // exchange status height, winbar height, hsep height and vsep width of old and new last window</a>
<a name="ln2040">    int n = wp2-&gt;w_status_height;</a>
<a name="ln2041">    wp2-&gt;w_status_height = wp1-&gt;w_status_height;</a>
<a name="ln2042">    wp1-&gt;w_status_height = n;</a>
<a name="ln2043">    n = wp2-&gt;w_hsep_height;</a>
<a name="ln2044">    wp2-&gt;w_hsep_height = wp1-&gt;w_hsep_height;</a>
<a name="ln2045">    wp1-&gt;w_hsep_height = n;</a>
<a name="ln2046">    frame_fix_height(wp1);</a>
<a name="ln2047">    frame_fix_height(wp2);</a>
<a name="ln2048">    n = wp2-&gt;w_vsep_width;</a>
<a name="ln2049">    wp2-&gt;w_vsep_width = wp1-&gt;w_vsep_width;</a>
<a name="ln2050">    wp1-&gt;w_vsep_width = n;</a>
<a name="ln2051">    frame_fix_width(wp1);</a>
<a name="ln2052">    frame_fix_width(wp2);</a>
<a name="ln2053"> </a>
<a name="ln2054">    // recompute w_winrow and w_wincol for all windows</a>
<a name="ln2055">    (void)win_comp_pos();</a>
<a name="ln2056">  }</a>
<a name="ln2057"> </a>
<a name="ln2058">  wp1-&gt;w_pos_changed = true;</a>
<a name="ln2059">  wp2-&gt;w_pos_changed = true;</a>
<a name="ln2060"> </a>
<a name="ln2061">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">// Move the current window to the very top/bottom/left/right of the screen.</a>
<a name="ln2065">static void win_totop(int size, int flags)</a>
<a name="ln2066">{</a>
<a name="ln2067">  int dir = 0;</a>
<a name="ln2068">  int height = curwin-&gt;w_height;</a>
<a name="ln2069"> </a>
<a name="ln2070">  if (firstwin == curwin &amp;&amp; lastwin_nofloating() == curwin) {</a>
<a name="ln2071">    beep_flush();</a>
<a name="ln2072">    return;</a>
<a name="ln2073">  }</a>
<a name="ln2074">  if (is_aucmd_win(curwin)) {</a>
<a name="ln2075">    return;</a>
<a name="ln2076">  }</a>
<a name="ln2077">  if (check_split_disallowed() == FAIL) {</a>
<a name="ln2078">    return;</a>
<a name="ln2079">  }</a>
<a name="ln2080"> </a>
<a name="ln2081">  if (curwin-&gt;w_floating) {</a>
<a name="ln2082">    ui_comp_remove_grid(&amp;curwin-&gt;w_grid_alloc);</a>
<a name="ln2083">    if (ui_has(kUIMultigrid)) {</a>
<a name="ln2084">      curwin-&gt;w_pos_changed = true;</a>
<a name="ln2085">    } else {</a>
<a name="ln2086">      // No longer a float, a non-multigrid UI shouldn't draw it as such</a>
<a name="ln2087">      ui_call_win_hide(curwin-&gt;w_grid_alloc.handle);</a>
<a name="ln2088">      win_free_grid(curwin, true);</a>
<a name="ln2089">    }</a>
<a name="ln2090">  } else {</a>
<a name="ln2091">    // Remove the window and frame from the tree of frames.</a>
<a name="ln2092">    (void)winframe_remove(curwin, &amp;dir, NULL);</a>
<a name="ln2093">  }</a>
<a name="ln2094">  win_remove(curwin, NULL);</a>
<a name="ln2095">  last_status(false);       // may need to remove last status line</a>
<a name="ln2096">  (void)win_comp_pos();     // recompute window positions</a>
<a name="ln2097"> </a>
<a name="ln2098">  // Split a window on the desired side and put the window there.</a>
<a name="ln2099">  (void)win_split_ins(size, flags, curwin, dir);</a>
<a name="ln2100">  if (!(flags &amp; WSP_VERT)) {</a>
<a name="ln2101">    win_setheight(height);</a>
<a name="ln2102">    if (p_ea) {</a>
<a name="ln2103">      win_equal(curwin, true, 'v');</a>
<a name="ln2104">    }</a>
<a name="ln2105">  }</a>
<a name="ln2106">}</a>
<a name="ln2107"> </a>
<a name="ln2108">// Move window &quot;win1&quot; to below/right of &quot;win2&quot; and make &quot;win1&quot; the current</a>
<a name="ln2109">// window.  Only works within the same frame!</a>
<a name="ln2110">void win_move_after(win_T *win1, win_T *win2)</a>
<a name="ln2111">{</a>
<a name="ln2112">  // check if the arguments are reasonable</a>
<a name="ln2113">  if (win1 == win2) {</a>
<a name="ln2114">    return;</a>
<a name="ln2115">  }</a>
<a name="ln2116"> </a>
<a name="ln2117">  // check if there is something to do</a>
<a name="ln2118">  if (win2-&gt;w_next != win1) {</a>
<a name="ln2119">    if (win1-&gt;w_frame-&gt;fr_parent != win2-&gt;w_frame-&gt;fr_parent) {</a>
<a name="ln2120">      iemsg(&quot;INTERNAL: trying to move a window into another frame&quot;);</a>
<a name="ln2121">      return;</a>
<a name="ln2122">    }</a>
<a name="ln2123"> </a>
<a name="ln2124">    // may need to move the status line, window bar, horizontal or vertical separator of the last</a>
<a name="ln2125">    // window</a>
<a name="ln2126">    if (win1 == lastwin) {</a>
<a name="ln2127">      int height = win1-&gt;w_prev-&gt;w_status_height;</a>
<a name="ln2128">      win1-&gt;w_prev-&gt;w_status_height = win1-&gt;w_status_height;</a>
<a name="ln2129">      win1-&gt;w_status_height = height;</a>
<a name="ln2130"> </a>
<a name="ln2131">      height = win1-&gt;w_prev-&gt;w_hsep_height;</a>
<a name="ln2132">      win1-&gt;w_prev-&gt;w_hsep_height = win1-&gt;w_hsep_height;</a>
<a name="ln2133">      win1-&gt;w_hsep_height = height;</a>
<a name="ln2134"> </a>
<a name="ln2135">      if (win1-&gt;w_prev-&gt;w_vsep_width == 1) {</a>
<a name="ln2136">        // Remove the vertical separator from the last-but-one window,</a>
<a name="ln2137">        // add it to the last window.  Adjust the frame widths.</a>
<a name="ln2138">        win1-&gt;w_prev-&gt;w_vsep_width = 0;</a>
<a name="ln2139">        win1-&gt;w_prev-&gt;w_frame-&gt;fr_width -= 1;</a>
<a name="ln2140">        win1-&gt;w_vsep_width = 1;</a>
<a name="ln2141">        win1-&gt;w_frame-&gt;fr_width += 1;</a>
<a name="ln2142">      }</a>
<a name="ln2143">    } else if (win2 == lastwin) {</a>
<a name="ln2144">      int height = win1-&gt;w_status_height;</a>
<a name="ln2145">      win1-&gt;w_status_height = win2-&gt;w_status_height;</a>
<a name="ln2146">      win2-&gt;w_status_height = height;</a>
<a name="ln2147"> </a>
<a name="ln2148">      height = win1-&gt;w_hsep_height;</a>
<a name="ln2149">      win1-&gt;w_hsep_height = win2-&gt;w_hsep_height;</a>
<a name="ln2150">      win2-&gt;w_hsep_height = height;</a>
<a name="ln2151"> </a>
<a name="ln2152">      if (win1-&gt;w_vsep_width == 1) {</a>
<a name="ln2153">        // Remove the vertical separator from win1, add it to the last</a>
<a name="ln2154">        // window, win2.  Adjust the frame widths.</a>
<a name="ln2155">        win2-&gt;w_vsep_width = 1;</a>
<a name="ln2156">        win2-&gt;w_frame-&gt;fr_width += 1;</a>
<a name="ln2157">        win1-&gt;w_vsep_width = 0;</a>
<a name="ln2158">        win1-&gt;w_frame-&gt;fr_width -= 1;</a>
<a name="ln2159">      }</a>
<a name="ln2160">    }</a>
<a name="ln2161">    win_remove(win1, NULL);</a>
<a name="ln2162">    frame_remove(win1-&gt;w_frame);</a>
<a name="ln2163">    win_append(win2, win1);</a>
<a name="ln2164">    frame_append(win2-&gt;w_frame, win1-&gt;w_frame);</a>
<a name="ln2165"> </a>
<a name="ln2166">    (void)win_comp_pos();  // recompute w_winrow for all windows</a>
<a name="ln2167">    redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln2168">  }</a>
<a name="ln2169">  win_enter(win1, false);</a>
<a name="ln2170"> </a>
<a name="ln2171">  win1-&gt;w_pos_changed = true;</a>
<a name="ln2172">  win2-&gt;w_pos_changed = true;</a>
<a name="ln2173">}</a>
<a name="ln2174"> </a>
<a name="ln2175">/// Compute maximum number of windows that can fit within &quot;height&quot; in frame &quot;fr&quot;.</a>
<a name="ln2176">static int get_maximum_wincount(frame_T *fr, int height)</a>
<a name="ln2177">{</a>
<a name="ln2178">  if (fr-&gt;fr_layout != FR_COL) {</a>
<a name="ln2179">    return (height / ((int)p_wmh + STATUS_HEIGHT + frame2win(fr)-&gt;w_winbar_height));</a>
<a name="ln2180">  } else if (global_winbar_height()) {</a>
<a name="ln2181">    // If winbar is globally enabled, no need to check each window for it.</a>
<a name="ln2182">    return (height / ((int)p_wmh + STATUS_HEIGHT + 1));</a>
<a name="ln2183">  }</a>
<a name="ln2184"> </a>
<a name="ln2185">  frame_T *frp;</a>
<a name="ln2186">  int total_wincount = 0;</a>
<a name="ln2187"> </a>
<a name="ln2188">  // First, try to fit all child frames of &quot;fr&quot; into &quot;height&quot;</a>
<a name="ln2189">  FOR_ALL_FRAMES(frp, fr-&gt;fr_child) {</a>
<a name="ln2190">    win_T *wp = frame2win(frp);</a>
<a name="ln2191"> </a>
<a name="ln2192">    if (height &lt; (p_wmh + STATUS_HEIGHT + wp-&gt;w_winbar_height)) {</a>
<a name="ln2193">      break;</a>
<a name="ln2194">    }</a>
<a name="ln2195">    height -= (int)p_wmh + STATUS_HEIGHT + wp-&gt;w_winbar_height;</a>
<a name="ln2196">    total_wincount += 1;</a>
<a name="ln2197">  }</a>
<a name="ln2198"> </a>
<a name="ln2199">  // If we still have enough room for more windows, just use the default winbar height (which is 0)</a>
<a name="ln2200">  // in order to get the amount of windows that'd fit in the remaining space</a>
<a name="ln2201">  total_wincount += height / ((int)p_wmh + STATUS_HEIGHT);</a>
<a name="ln2202"> </a>
<a name="ln2203">  return total_wincount;</a>
<a name="ln2204">}</a>
<a name="ln2205"> </a>
<a name="ln2206">/// Make all windows the same height.</a>
<a name="ln2207">/// 'next_curwin' will soon be the current window, make sure it has enough rows.</a>
<a name="ln2208">///</a>
<a name="ln2209">/// @param next_curwin  pointer to current window to be or NULL</a>
<a name="ln2210">/// @param current  do only frame with current window</a>
<a name="ln2211">/// @param dir  'v' for vertically, 'h' for horizontally, 'b' for both, 0 for using p_ead</a>
<a name="ln2212">void win_equal(win_T *next_curwin, bool current, int dir)</a>
<a name="ln2213">{</a>
<a name="ln2214">  if (dir == 0) {</a>
<a name="ln2215">    dir = (unsigned char)(*p_ead);</a>
<a name="ln2216">  }</a>
<a name="ln2217">  win_equal_rec(next_curwin == NULL ? curwin : next_curwin, current,</a>
<a name="ln2218">                topframe, dir, 0, tabline_height(),</a>
<a name="ln2219">                Columns, topframe-&gt;fr_height);</a>
<a name="ln2220">  if (!is_aucmd_win(next_curwin)) {</a>
<a name="ln2221">    win_fix_scroll(true);</a>
<a name="ln2222">  }</a>
<a name="ln2223">}</a>
<a name="ln2224"> </a>
<a name="ln2225">/// Set a frame to a new position and height, spreading the available room</a>
<a name="ln2226">/// equally over contained frames.</a>
<a name="ln2227">/// The window &quot;next_curwin&quot; (if not NULL) should at least get the size from</a>
<a name="ln2228">/// 'winheight' and 'winwidth' if possible.</a>
<a name="ln2229">///</a>
<a name="ln2230">/// @param next_curwin  pointer to current window to be or NULL</a>
<a name="ln2231">/// @param current      do only frame with current window</a>
<a name="ln2232">/// @param topfr        frame to set size off</a>
<a name="ln2233">/// @param dir          'v', 'h' or 'b', see win_equal()</a>
<a name="ln2234">/// @param col          horizontal position for frame</a>
<a name="ln2235">/// @param row          vertical position for frame</a>
<a name="ln2236">/// @param width        new width of frame</a>
<a name="ln2237">/// @param height       new height of frame</a>
<a name="ln2238">static void win_equal_rec(win_T *next_curwin, bool current, frame_T *topfr, int dir, int col,</a>
<a name="ln2239">                          int row, int width, int height)</a>
<a name="ln2240">{</a>
<a name="ln2241">  int extra_sep = 0;</a>
<a name="ln2242">  int totwincount = 0;</a>
<a name="ln2243">  int next_curwin_size = 0;</a>
<a name="ln2244">  int room = 0;</a>
<a name="ln2245">  int has_next_curwin = 0;</a>
<a name="ln2246"> </a>
<a name="ln2247">  if (topfr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln2248">    // Set the width/height of this frame.</a>
<a name="ln2249">    // Redraw when size or position changes</a>
<a name="ln2250">    if (topfr-&gt;fr_height != height || topfr-&gt;fr_win-&gt;w_winrow != row</a>
<a name="ln2251">        || topfr-&gt;fr_width != width</a>
<a name="ln2252">        || topfr-&gt;fr_win-&gt;w_wincol != col) {</a>
<a name="ln2253">      topfr-&gt;fr_win-&gt;w_winrow = row;</a>
<a name="ln2254">      frame_new_height(topfr, height, false, false);</a>
<a name="ln2255">      topfr-&gt;fr_win-&gt;w_wincol = col;</a>
<a name="ln2256">      frame_new_width(topfr, width, false, false);</a>
<a name="ln2257">      redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln2258">    }</a>
<a name="ln2259">  } else if (topfr-&gt;fr_layout == FR_ROW) {</a>
<a name="ln2260">    topfr-&gt;fr_width = width;</a>
<a name="ln2261">    topfr-&gt;fr_height = height;</a>
<a name="ln2262"> </a>
<a name="ln2263">    if (dir != 'v') {                   // equalize frame widths</a>
<a name="ln2264">      // Compute the maximum number of windows horizontally in this</a>
<a name="ln2265">      // frame.</a>
<a name="ln2266">      int n = frame_minwidth(topfr, NOWIN);</a>
<a name="ln2267">      // add one for the rightmost window, it doesn't have a separator</a>
<a name="ln2268">      if (col + width == Columns) {</a>
<a name="ln2269">        extra_sep = 1;</a>
<a name="ln2270">      } else {</a>
<a name="ln2271">        extra_sep = 0;</a>
<a name="ln2272">      }</a>
<a name="ln2273">      totwincount = (n + extra_sep) / ((int)p_wmw + 1);</a>
<a name="ln2274">      has_next_curwin = frame_has_win(topfr, next_curwin);</a>
<a name="ln2275"> </a>
<a name="ln2276">      // Compute width for &quot;next_curwin&quot; window and room available for</a>
<a name="ln2277">      // other windows.</a>
<a name="ln2278">      // &quot;m&quot; is the minimal width when counting p_wiw for &quot;next_curwin&quot;.</a>
<a name="ln2279">      int m = frame_minwidth(topfr, next_curwin);</a>
<a name="ln2280">      room = width - m;</a>
<a name="ln2281">      if (room &lt; 0) {</a>
<a name="ln2282">        next_curwin_size = (int)p_wiw + room;</a>
<a name="ln2283">        room = 0;</a>
<a name="ln2284">      } else {</a>
<a name="ln2285">        next_curwin_size = -1;</a>
<a name="ln2286">        frame_T *fr;</a>
<a name="ln2287">        FOR_ALL_FRAMES(fr, topfr-&gt;fr_child) {</a>
<a name="ln2288">          if (!frame_fixed_width(fr)) {</a>
<a name="ln2289">            continue;</a>
<a name="ln2290">          }</a>
<a name="ln2291">          // If 'winfixwidth' set keep the window width if possible.</a>
<a name="ln2292">          // Watch out for this window being the next_curwin.</a>
<a name="ln2293">          n = frame_minwidth(fr, NOWIN);</a>
<a name="ln2294">          int new_size = fr-&gt;fr_width;</a>
<a name="ln2295">          if (frame_has_win(fr, next_curwin)) {</a>
<a name="ln2296">            room += (int)p_wiw - (int)p_wmw;</a>
<a name="ln2297">            next_curwin_size = 0;</a>
<a name="ln2298">            if (new_size &lt; p_wiw) {</a>
<a name="ln2299">              new_size = (int)p_wiw;</a>
<a name="ln2300">            }</a>
<a name="ln2301">          } else {</a>
<a name="ln2302">            // These windows don't use up room.</a>
<a name="ln2303">            totwincount -= (n + (fr-&gt;fr_next == NULL ? extra_sep : 0)) / ((int)p_wmw + 1);</a>
<a name="ln2304">          }</a>
<a name="ln2305">          room -= new_size - n;</a>
<a name="ln2306">          if (room &lt; 0) {</a>
<a name="ln2307">            new_size += room;</a>
<a name="ln2308">            room = 0;</a>
<a name="ln2309">          }</a>
<a name="ln2310">          fr-&gt;fr_newwidth = new_size;</a>
<a name="ln2311">        }</a>
<a name="ln2312">        if (next_curwin_size == -1) {</a>
<a name="ln2313">          if (!has_next_curwin) {</a>
<a name="ln2314">            next_curwin_size = 0;</a>
<a name="ln2315">          } else if (totwincount &gt; 1</a>
<a name="ln2316">                     &amp;&amp; (room + (totwincount - 2))</a>
<a name="ln2317">                     / (totwincount - 1) &gt; p_wiw) {</a>
<a name="ln2318">            // Can make all windows wider than 'winwidth', spread</a>
<a name="ln2319">            // the room equally.</a>
<a name="ln2320">            next_curwin_size = (int)(room + p_wiw</a>
<a name="ln2321">                                     + (totwincount - 1) * p_wmw</a>
<a name="ln2322">                                     + (totwincount - 1)) / totwincount;</a>
<a name="ln2323">            room -= next_curwin_size - (int)p_wiw;</a>
<a name="ln2324">          } else {</a>
<a name="ln2325">            next_curwin_size = (int)p_wiw;</a>
<a name="ln2326">          }</a>
<a name="ln2327">        }</a>
<a name="ln2328">      }</a>
<a name="ln2329"> </a>
<a name="ln2330">      if (has_next_curwin) {</a>
<a name="ln2331">        totwincount--;                  // don't count curwin</a>
<a name="ln2332">      }</a>
<a name="ln2333">    }</a>
<a name="ln2334"> </a>
<a name="ln2335">    frame_T *fr;</a>
<a name="ln2336">    FOR_ALL_FRAMES(fr, topfr-&gt;fr_child) {</a>
<a name="ln2337">      int wincount = 1;</a>
<a name="ln2338">      int new_size;</a>
<a name="ln2339">      if (fr-&gt;fr_next == NULL) {</a>
<a name="ln2340">        // last frame gets all that remains (avoid roundoff error)</a>
<a name="ln2341">        new_size = width;</a>
<a name="ln2342">      } else if (dir == 'v') {</a>
<a name="ln2343">        new_size = fr-&gt;fr_width;</a>
<a name="ln2344">      } else if (frame_fixed_width(fr)) {</a>
<a name="ln2345">        new_size = fr-&gt;fr_newwidth;</a>
<a name="ln2346">        wincount = 0;               // doesn't count as a sizeable window</a>
<a name="ln2347">      } else {</a>
<a name="ln2348">        // Compute the maximum number of windows horiz. in &quot;fr&quot;.</a>
<a name="ln2349">        int n = frame_minwidth(fr, NOWIN);</a>
<a name="ln2350">        wincount = (n + (fr-&gt;fr_next == NULL ? extra_sep : 0)) / ((int)p_wmw + 1);</a>
<a name="ln2351">        int m = frame_minwidth(fr, next_curwin);</a>
<a name="ln2352">        bool hnc = has_next_curwin &amp;&amp; frame_has_win(fr, next_curwin);</a>
<a name="ln2353">        if (hnc) {                    // don't count next_curwin</a>
<a name="ln2354">          wincount--;</a>
<a name="ln2355">        }</a>
<a name="ln2356">        if (totwincount == 0) {</a>
<a name="ln2357">          new_size = room;</a>
<a name="ln2358">        } else {</a>
<a name="ln2359">          new_size = (wincount * room + (totwincount / 2)) / totwincount;</a>
<a name="ln2360">        }</a>
<a name="ln2361">        if (hnc) {                  // add next_curwin size</a>
<a name="ln2362">          next_curwin_size -= (int)p_wiw - (m - n);</a>
<a name="ln2363">          if (next_curwin_size &lt; 0) {</a>
<a name="ln2364">            next_curwin_size = 0;</a>
<a name="ln2365">          }</a>
<a name="ln2366">          new_size += next_curwin_size;</a>
<a name="ln2367">          room -= new_size - next_curwin_size;</a>
<a name="ln2368">        } else {</a>
<a name="ln2369">          room -= new_size;</a>
<a name="ln2370">        }</a>
<a name="ln2371">        new_size += n;</a>
<a name="ln2372">      }</a>
<a name="ln2373"> </a>
<a name="ln2374">      // Skip frame that is full width when splitting or closing a</a>
<a name="ln2375">      // window, unless equalizing all frames.</a>
<a name="ln2376">      if (!current || dir != 'v' || topfr-&gt;fr_parent != NULL</a>
<a name="ln2377">          || (new_size != fr-&gt;fr_width)</a>
<a name="ln2378">          || frame_has_win(fr, next_curwin)) {</a>
<a name="ln2379">        win_equal_rec(next_curwin, current, fr, dir, col, row,</a>
<a name="ln2380">                      new_size, height);</a>
<a name="ln2381">      }</a>
<a name="ln2382">      col += new_size;</a>
<a name="ln2383">      width -= new_size;</a>
<a name="ln2384">      totwincount -= wincount;</a>
<a name="ln2385">    }</a>
<a name="ln2386">  } else {  // topfr-&gt;fr_layout == FR_COL</a>
<a name="ln2387">    topfr-&gt;fr_width = width;</a>
<a name="ln2388">    topfr-&gt;fr_height = height;</a>
<a name="ln2389"> </a>
<a name="ln2390">    if (dir != 'h') {                   // equalize frame heights</a>
<a name="ln2391">      // Compute maximum number of windows vertically in this frame.</a>
<a name="ln2392">      int n = frame_minheight(topfr, NOWIN);</a>
<a name="ln2393">      // add one for the bottom window if it doesn't have a statusline or separator</a>
<a name="ln2394">      if (row + height &gt;= cmdline_row &amp;&amp; p_ls == 0) {</a>
<a name="ln2395">        extra_sep = STATUS_HEIGHT;</a>
<a name="ln2396">      } else if (global_stl_height() &gt; 0) {</a>
<a name="ln2397">        extra_sep = 1;</a>
<a name="ln2398">      } else {</a>
<a name="ln2399">        extra_sep = 0;</a>
<a name="ln2400">      }</a>
<a name="ln2401">      totwincount = get_maximum_wincount(topfr, n + extra_sep);</a>
<a name="ln2402">      has_next_curwin = frame_has_win(topfr, next_curwin);</a>
<a name="ln2403"> </a>
<a name="ln2404">      // Compute height for &quot;next_curwin&quot; window and room available for</a>
<a name="ln2405">      // other windows.</a>
<a name="ln2406">      // &quot;m&quot; is the minimal height when counting p_wh for &quot;next_curwin&quot;.</a>
<a name="ln2407">      int m = frame_minheight(topfr, next_curwin);</a>
<a name="ln2408">      room = height - m;</a>
<a name="ln2409">      if (room &lt; 0) {</a>
<a name="ln2410">        // The room is less than 'winheight', use all space for the</a>
<a name="ln2411">        // current window.</a>
<a name="ln2412">        next_curwin_size = (int)p_wh + room;</a>
<a name="ln2413">        room = 0;</a>
<a name="ln2414">      } else {</a>
<a name="ln2415">        next_curwin_size = -1;</a>
<a name="ln2416">        frame_T *fr;</a>
<a name="ln2417">        FOR_ALL_FRAMES(fr, topfr-&gt;fr_child) {</a>
<a name="ln2418">          if (!frame_fixed_height(fr)) {</a>
<a name="ln2419">            continue;</a>
<a name="ln2420">          }</a>
<a name="ln2421">          // If 'winfixheight' set keep the window height if possible.</a>
<a name="ln2422">          // Watch out for this window being the next_curwin.</a>
<a name="ln2423">          n = frame_minheight(fr, NOWIN);</a>
<a name="ln2424">          int new_size = fr-&gt;fr_height;</a>
<a name="ln2425">          if (frame_has_win(fr, next_curwin)) {</a>
<a name="ln2426">            room += (int)p_wh - (int)p_wmh;</a>
<a name="ln2427">            next_curwin_size = 0;</a>
<a name="ln2428">            if (new_size &lt; p_wh) {</a>
<a name="ln2429">              new_size = (int)p_wh;</a>
<a name="ln2430">            }</a>
<a name="ln2431">          } else {</a>
<a name="ln2432">            // These windows don't use up room.</a>
<a name="ln2433">            totwincount -= get_maximum_wincount(fr, (n + (fr-&gt;fr_next == NULL ? extra_sep : 0)));</a>
<a name="ln2434">          }</a>
<a name="ln2435">          room -= new_size - n;</a>
<a name="ln2436">          if (room &lt; 0) {</a>
<a name="ln2437">            new_size += room;</a>
<a name="ln2438">            room = 0;</a>
<a name="ln2439">          }</a>
<a name="ln2440">          fr-&gt;fr_newheight = new_size;</a>
<a name="ln2441">        }</a>
<a name="ln2442">        if (next_curwin_size == -1) {</a>
<a name="ln2443">          if (!has_next_curwin) {</a>
<a name="ln2444">            next_curwin_size = 0;</a>
<a name="ln2445">          } else if (totwincount &gt; 1</a>
<a name="ln2446">                     &amp;&amp; (room + (totwincount - 2))</a>
<a name="ln2447">                     / (totwincount - 1) &gt; p_wh) {</a>
<a name="ln2448">            // can make all windows higher than 'winheight',</a>
<a name="ln2449">            // spread the room equally.</a>
<a name="ln2450">            next_curwin_size = (int)(room + p_wh</a>
<a name="ln2451">                                     + (totwincount - 1) * p_wmh</a>
<a name="ln2452">                                     + (totwincount - 1)) / totwincount;</a>
<a name="ln2453">            room -= next_curwin_size - (int)p_wh;</a>
<a name="ln2454">          } else {</a>
<a name="ln2455">            next_curwin_size = (int)p_wh;</a>
<a name="ln2456">          }</a>
<a name="ln2457">        }</a>
<a name="ln2458">      }</a>
<a name="ln2459"> </a>
<a name="ln2460">      if (has_next_curwin) {</a>
<a name="ln2461">        totwincount--;                  // don't count curwin</a>
<a name="ln2462">      }</a>
<a name="ln2463">    }</a>
<a name="ln2464"> </a>
<a name="ln2465">    frame_T *fr;</a>
<a name="ln2466">    FOR_ALL_FRAMES(fr, topfr-&gt;fr_child) {</a>
<a name="ln2467">      int new_size;</a>
<a name="ln2468">      int wincount = 1;</a>
<a name="ln2469">      if (fr-&gt;fr_next == NULL) {</a>
<a name="ln2470">        // last frame gets all that remains (avoid roundoff error)</a>
<a name="ln2471">        new_size = height;</a>
<a name="ln2472">      } else if (dir == 'h') {</a>
<a name="ln2473">        new_size = fr-&gt;fr_height;</a>
<a name="ln2474">      } else if (frame_fixed_height(fr)) {</a>
<a name="ln2475">        new_size = fr-&gt;fr_newheight;</a>
<a name="ln2476">        wincount = 0;               // doesn't count as a sizeable window</a>
<a name="ln2477">      } else {</a>
<a name="ln2478">        // Compute the maximum number of windows vert. in &quot;fr&quot;.</a>
<a name="ln2479">        int n = frame_minheight(fr, NOWIN);</a>
<a name="ln2480">        wincount = get_maximum_wincount(fr, (n + (fr-&gt;fr_next == NULL ? extra_sep : 0)));</a>
<a name="ln2481">        int m = frame_minheight(fr, next_curwin);</a>
<a name="ln2482">        bool hnc = has_next_curwin &amp;&amp; frame_has_win(fr, next_curwin);</a>
<a name="ln2483">        if (hnc) {                    // don't count next_curwin</a>
<a name="ln2484">          wincount--;</a>
<a name="ln2485">        }</a>
<a name="ln2486">        if (totwincount == 0) {</a>
<a name="ln2487">          new_size = room;</a>
<a name="ln2488">        } else {</a>
<a name="ln2489">          new_size = (wincount * room + (totwincount / 2)) / totwincount;</a>
<a name="ln2490">        }</a>
<a name="ln2491">        if (hnc) {                  // add next_curwin size</a>
<a name="ln2492">          next_curwin_size -= (int)p_wh - (m - n);</a>
<a name="ln2493">          new_size += next_curwin_size;</a>
<a name="ln2494">          room -= new_size - next_curwin_size;</a>
<a name="ln2495">        } else {</a>
<a name="ln2496">          room -= new_size;</a>
<a name="ln2497">        }</a>
<a name="ln2498">        new_size += n;</a>
<a name="ln2499">      }</a>
<a name="ln2500">      // Skip frame that is full width when splitting or closing a</a>
<a name="ln2501">      // window, unless equalizing all frames.</a>
<a name="ln2502">      if (!current || dir != 'h' || topfr-&gt;fr_parent != NULL</a>
<a name="ln2503">          || (new_size != fr-&gt;fr_height)</a>
<a name="ln2504">          || frame_has_win(fr, next_curwin)) {</a>
<a name="ln2505">        win_equal_rec(next_curwin, current, fr, dir, col, row,</a>
<a name="ln2506">                      width, new_size);</a>
<a name="ln2507">      }</a>
<a name="ln2508">      row += new_size;</a>
<a name="ln2509">      height -= new_size;</a>
<a name="ln2510">      totwincount -= wincount;</a>
<a name="ln2511">    }</a>
<a name="ln2512">  }</a>
<a name="ln2513">}</a>
<a name="ln2514"> </a>
<a name="ln2515">void leaving_window(win_T *const win)</a>
<a name="ln2516">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2517">{</a>
<a name="ln2518">  // Only matters for a prompt window.</a>
<a name="ln2519">  if (!bt_prompt(win-&gt;w_buffer)) {</a>
<a name="ln2520">    return;</a>
<a name="ln2521">  }</a>
<a name="ln2522"> </a>
<a name="ln2523">  // When leaving a prompt window stop Insert mode and perhaps restart</a>
<a name="ln2524">  // it when entering that window again.</a>
<a name="ln2525">  win-&gt;w_buffer-&gt;b_prompt_insert = restart_edit;</a>
<a name="ln2526">  if (restart_edit != NUL &amp;&amp; mode_displayed) {</a>
<a name="ln2527">    clear_cmdline = true;  // unshow mode later</a>
<a name="ln2528">  }</a>
<a name="ln2529">  restart_edit = NUL;</a>
<a name="ln2530"> </a>
<a name="ln2531">  // When leaving the window (or closing the window) was done from a</a>
<a name="ln2532">  // callback we need to break out of the Insert mode loop and restart Insert</a>
<a name="ln2533">  // mode when entering the window again.</a>
<a name="ln2534">  if (State &amp; MODE_INSERT) {</a>
<a name="ln2535">    stop_insert_mode = true;</a>
<a name="ln2536">    if (win-&gt;w_buffer-&gt;b_prompt_insert == NUL) {</a>
<a name="ln2537">      win-&gt;w_buffer-&gt;b_prompt_insert = 'A';</a>
<a name="ln2538">    }</a>
<a name="ln2539">  }</a>
<a name="ln2540">}</a>
<a name="ln2541"> </a>
<a name="ln2542">void entering_window(win_T *const win)</a>
<a name="ln2543">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2544">{</a>
<a name="ln2545">  // Only matters for a prompt window.</a>
<a name="ln2546">  if (!bt_prompt(win-&gt;w_buffer)) {</a>
<a name="ln2547">    return;</a>
<a name="ln2548">  }</a>
<a name="ln2549"> </a>
<a name="ln2550">  // When switching to a prompt buffer that was in Insert mode, don't stop</a>
<a name="ln2551">  // Insert mode, it may have been set in leaving_window().</a>
<a name="ln2552">  if (win-&gt;w_buffer-&gt;b_prompt_insert != NUL) {</a>
<a name="ln2553">    stop_insert_mode = false;</a>
<a name="ln2554">  }</a>
<a name="ln2555"> </a>
<a name="ln2556">  // When entering the prompt window restart Insert mode if we were in Insert</a>
<a name="ln2557">  // mode when we left it and not already in Insert mode.</a>
<a name="ln2558">  if ((State &amp; MODE_INSERT) == 0) {</a>
<a name="ln2559">    restart_edit = win-&gt;w_buffer-&gt;b_prompt_insert;</a>
<a name="ln2560">  }</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">void win_init_empty(win_T *wp)</a>
<a name="ln2564">{</a>
<a name="ln2565">  redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln2566">  wp-&gt;w_lines_valid = 0;</a>
<a name="ln2567">  wp-&gt;w_cursor.lnum = 1;</a>
<a name="ln2568">  wp-&gt;w_curswant = wp-&gt;w_cursor.col = 0;</a>
<a name="ln2569">  wp-&gt;w_cursor.coladd = 0;</a>
<a name="ln2570">  wp-&gt;w_pcmark.lnum = 1;        // pcmark not cleared but set to line 1</a>
<a name="ln2571">  wp-&gt;w_pcmark.col = 0;</a>
<a name="ln2572">  wp-&gt;w_prev_pcmark.lnum = 0;</a>
<a name="ln2573">  wp-&gt;w_prev_pcmark.col = 0;</a>
<a name="ln2574">  wp-&gt;w_topline = 1;</a>
<a name="ln2575">  wp-&gt;w_topfill = 0;</a>
<a name="ln2576">  wp-&gt;w_botline = 2;</a>
<a name="ln2577">  wp-&gt;w_s = &amp;wp-&gt;w_buffer-&gt;b_s;</a>
<a name="ln2578">}</a>
<a name="ln2579"> </a>
<a name="ln2580">/// Init the current window &quot;curwin&quot;.</a>
<a name="ln2581">/// Called when a new file is being edited.</a>
<a name="ln2582">void curwin_init(void)</a>
<a name="ln2583">{</a>
<a name="ln2584">  win_init_empty(curwin);</a>
<a name="ln2585">}</a>
<a name="ln2586"> </a>
<a name="ln2587">/// Closes all windows for buffer `buf` unless there is only one non-floating window.</a>
<a name="ln2588">///</a>
<a name="ln2589">/// @param keep_curwin  don't close `curwin`</a>
<a name="ln2590">void close_windows(buf_T *buf, bool keep_curwin)</a>
<a name="ln2591">{</a>
<a name="ln2592">  RedrawingDisabled++;</a>
<a name="ln2593"> </a>
<a name="ln2594">  // Start from lastwin to close floating windows with the same buffer first.</a>
<a name="ln2595">  // When the autocommand window is involved win_close() may need to print an error message.</a>
<a name="ln2596">  for (win_T *wp = lastwin; wp != NULL &amp;&amp; (is_aucmd_win(lastwin) || !one_window(wp));) {</a>
<a name="ln2597">    if (wp-&gt;w_buffer == buf &amp;&amp; (!keep_curwin || wp != curwin)</a>
<a name="ln2598">        &amp;&amp; !(wp-&gt;w_closing || wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln2599">      if (win_close(wp, false, false) == FAIL) {</a>
<a name="ln2600">        // If closing the window fails give up, to avoid looping forever.</a>
<a name="ln2601">        break;</a>
<a name="ln2602">      }</a>
<a name="ln2603"> </a>
<a name="ln2604">      // Start all over, autocommands may change the window layout.</a>
<a name="ln2605">      wp = lastwin;</a>
<a name="ln2606">    } else {</a>
<a name="ln2607">      wp = wp-&gt;w_prev;</a>
<a name="ln2608">    }</a>
<a name="ln2609">  }</a>
<a name="ln2610"> </a>
<a name="ln2611">  tabpage_T *nexttp;</a>
<a name="ln2612"> </a>
<a name="ln2613">  // Also check windows in other tab pages.</a>
<a name="ln2614">  for (tabpage_T *tp = first_tabpage; tp != NULL; tp = nexttp) {</a>
<a name="ln2615">    nexttp = tp-&gt;tp_next;</a>
<a name="ln2616">    if (tp != curtab) {</a>
<a name="ln2617">      // Start from tp_lastwin to close floating windows with the same buffer first.</a>
<a name="ln2618">      for (win_T *wp = tp-&gt;tp_lastwin; wp != NULL; wp = wp-&gt;w_prev) {</a>
<a name="ln2619">        if (wp-&gt;w_buffer == buf</a>
<a name="ln2620">            &amp;&amp; !(wp-&gt;w_closing || wp-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln2621">          win_close_othertab(wp, false, tp);</a>
<a name="ln2622"> </a>
<a name="ln2623">          // Start all over, the tab page may be closed and</a>
<a name="ln2624">          // autocommands may change the window layout.</a>
<a name="ln2625">          nexttp = first_tabpage;</a>
<a name="ln2626">          break;</a>
<a name="ln2627">        }</a>
<a name="ln2628">      }</a>
<a name="ln2629">    }</a>
<a name="ln2630">  }</a>
<a name="ln2631"> </a>
<a name="ln2632">  RedrawingDisabled--;</a>
<a name="ln2633">}</a>
<a name="ln2634"> </a>
<a name="ln2635">/// Check if &quot;win&quot; is the last non-floating window that exists.</a>
<a name="ln2636">bool last_window(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2637">{</a>
<a name="ln2638">  return one_window(win) &amp;&amp; first_tabpage-&gt;tp_next == NULL;</a>
<a name="ln2639">}</a>
<a name="ln2640"> </a>
<a name="ln2641">/// Check if &quot;win&quot; is the only non-floating window in the current tabpage.</a>
<a name="ln2642">bool one_window(win_T *win) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2643">{</a>
<a name="ln2644">  if (win-&gt;w_floating) {</a>
<a name="ln2645">    return false;</a>
<a name="ln2646">  }</a>
<a name="ln2647"> </a>
<a name="ln2648">  bool seen_one = false;</a>
<a name="ln2649"> </a>
<a name="ln2650">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2651">    if (!wp-&gt;w_floating) {</a>
<a name="ln2652">      if (seen_one) {</a>
<a name="ln2653">        return false;</a>
<a name="ln2654">      }</a>
<a name="ln2655">      seen_one = true;</a>
<a name="ln2656">    }</a>
<a name="ln2657">  }</a>
<a name="ln2658">  return true;</a>
<a name="ln2659">}</a>
<a name="ln2660"> </a>
<a name="ln2661">/// Like ONE_WINDOW but only considers non-floating windows</a>
<a name="ln2662">bool one_nonfloat(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2663">{</a>
<a name="ln2664">  return firstwin-&gt;w_next == NULL || firstwin-&gt;w_next-&gt;w_floating;</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667">/// if wp is the last non-floating window</a>
<a name="ln2668">///</a>
<a name="ln2669">/// always false for a floating window</a>
<a name="ln2670">bool last_nonfloat(win_T *wp) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2671">{</a>
<a name="ln2672">  return wp != NULL &amp;&amp; firstwin == wp &amp;&amp; !(wp-&gt;w_next &amp;&amp; !wp-&gt;w_floating);</a>
<a name="ln2673">}</a>
<a name="ln2674"> </a>
<a name="ln2675">/// Check if floating windows in the current tab can be closed.</a>
<a name="ln2676">/// Do not call this when the autocommand window is in use!</a>
<a name="ln2677">///</a>
<a name="ln2678">/// @return true if all floating windows can be closed</a>
<a name="ln2679">static bool can_close_floating_windows(void)</a>
<a name="ln2680">{</a>
<a name="ln2681">  assert(!is_aucmd_win(lastwin));</a>
<a name="ln2682">  for (win_T *wp = lastwin; wp-&gt;w_floating; wp = wp-&gt;w_prev) {</a>
<a name="ln2683">    buf_T *buf = wp-&gt;w_buffer;</a>
<a name="ln2684">    int need_hide = (bufIsChanged(buf) &amp;&amp; buf-&gt;b_nwindows &lt;= 1);</a>
<a name="ln2685"> </a>
<a name="ln2686">    if (need_hide &amp;&amp; !buf_hide(buf)) {</a>
<a name="ln2687">      return false;</a>
<a name="ln2688">    }</a>
<a name="ln2689">  }</a>
<a name="ln2690">  return true;</a>
<a name="ln2691">}</a>
<a name="ln2692"> </a>
<a name="ln2693">/// @return true if, considering the cmdwin, `win` is safe to close.</a>
<a name="ln2694">/// If false and `win` is the cmdwin, it is closed; otherwise, `err` is set.</a>
<a name="ln2695">bool can_close_in_cmdwin(win_T *win, Error *err)</a>
<a name="ln2696">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2697">{</a>
<a name="ln2698">  if (cmdwin_type != 0) {</a>
<a name="ln2699">    if (win == curwin) {</a>
<a name="ln2700">      cmdwin_result = Ctrl_C;</a>
<a name="ln2701">      return false;</a>
<a name="ln2702">    } else if (win == cmdwin_old_curwin) {</a>
<a name="ln2703">      api_set_error(err, kErrorTypeException, &quot;%s&quot;, e_cmdwin);</a>
<a name="ln2704">      return false;</a>
<a name="ln2705">    }</a>
<a name="ln2706">  }</a>
<a name="ln2707">  return true;</a>
<a name="ln2708">}</a>
<a name="ln2709"> </a>
<a name="ln2710">/// Close the possibly last window in a tab page.</a>
<a name="ln2711">///</a>
<a name="ln2712">/// @param  win          window to close</a>
<a name="ln2713">/// @param  free_buf     whether to free the window's current buffer</a>
<a name="ln2714">/// @param  prev_curtab  previous tabpage that will be closed if &quot;win&quot; is the</a>
<a name="ln2715">///                      last window in the tabpage</a>
<a name="ln2716">///</a>
<a name="ln2717">/// @return true when the window was closed already.</a>
<a name="ln2718">static bool close_last_window_tabpage(win_T *win, bool free_buf, tabpage_T *prev_curtab)</a>
<a name="ln2719">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2720">{</a>
<a name="ln2721">  if (!ONE_WINDOW) {</a>
<a name="ln2722">    return false;</a>
<a name="ln2723">  }</a>
<a name="ln2724"> </a>
<a name="ln2725">  buf_T *old_curbuf = curbuf;</a>
<a name="ln2726"> </a>
<a name="ln2727">  Terminal *term = win-&gt;w_buffer ? win-&gt;w_buffer-&gt;terminal : NULL;</a>
<a name="ln2728">  if (term) {</a>
<a name="ln2729">    // Don't free terminal buffers</a>
<a name="ln2730">    free_buf = false;</a>
<a name="ln2731">  }</a>
<a name="ln2732"> </a>
<a name="ln2733">  // Closing the last window in a tab page.  First go to another tab</a>
<a name="ln2734">  // page and then close the window and the tab page.  This avoids that</a>
<a name="ln2735">  // curwin and curtab are invalid while we are freeing memory, they may</a>
<a name="ln2736">  // be used in GUI events.</a>
<a name="ln2737">  // Don't trigger autocommands yet, they may use wrong values, so do</a>
<a name="ln2738">  // that below.</a>
<a name="ln2739">  goto_tabpage_tp(alt_tabpage(), false, true);</a>
<a name="ln2740"> </a>
<a name="ln2741">  // save index for tabclosed event</a>
<a name="ln2742">  char prev_idx[NUMBUFLEN];</a>
<a name="ln2743">  snprintf(prev_idx, NUMBUFLEN, &quot;%i&quot;, tabpage_index(prev_curtab));</a>
<a name="ln2744"> </a>
<a name="ln2745">  // Safety check: Autocommands may have closed the window when jumping</a>
<a name="ln2746">  // to the other tab page.</a>
<a name="ln2747">  if (valid_tabpage(prev_curtab) &amp;&amp; prev_curtab-&gt;tp_firstwin == win) {</a>
<a name="ln2748">    win_close_othertab(win, free_buf, prev_curtab);</a>
<a name="ln2749">  }</a>
<a name="ln2750">  entering_window(curwin);</a>
<a name="ln2751"> </a>
<a name="ln2752">  // Since goto_tabpage_tp above did not trigger *Enter autocommands, do</a>
<a name="ln2753">  // that now.</a>
<a name="ln2754">  apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);</a>
<a name="ln2755">  apply_autocmds(EVENT_TABENTER, NULL, NULL, false, curbuf);</a>
<a name="ln2756">  if (old_curbuf != curbuf) {</a>
<a name="ln2757">    apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);</a>
<a name="ln2758">  }</a>
<a name="ln2759">  return true;</a>
<a name="ln2760">}</a>
<a name="ln2761"> </a>
<a name="ln2762">/// Close the buffer of &quot;win&quot; and unload it if &quot;free_buf&quot; is true.</a>
<a name="ln2763">/// &quot;abort_if_last&quot; is passed to close_buffer(): abort closing if all other</a>
<a name="ln2764">/// windows are closed.</a>
<a name="ln2765">static void win_close_buffer(win_T *win, bool free_buf, bool abort_if_last)</a>
<a name="ln2766">{</a>
<a name="ln2767">  // Free independent synblock before the buffer is freed.</a>
<a name="ln2768">  if (win-&gt;w_buffer != NULL) {</a>
<a name="ln2769">    reset_synblock(win);</a>
<a name="ln2770">  }</a>
<a name="ln2771"> </a>
<a name="ln2772">  // When a quickfix/location list window is closed and the buffer is</a>
<a name="ln2773">  // displayed in only one window, then unlist the buffer.</a>
<a name="ln2774">  if (win-&gt;w_buffer != NULL &amp;&amp; bt_quickfix(win-&gt;w_buffer)</a>
<a name="ln2775">      &amp;&amp; win-&gt;w_buffer-&gt;b_nwindows == 1) {</a>
<a name="ln2776">    win-&gt;w_buffer-&gt;b_p_bl = false;</a>
<a name="ln2777">  }</a>
<a name="ln2778"> </a>
<a name="ln2779">  // Close the link to the buffer.</a>
<a name="ln2780">  if (win-&gt;w_buffer != NULL) {</a>
<a name="ln2781">    bufref_T bufref;</a>
<a name="ln2782">    set_bufref(&amp;bufref, curbuf);</a>
<a name="ln2783">    win-&gt;w_closing = true;</a>
<a name="ln2784">    close_buffer(win, win-&gt;w_buffer, free_buf ? DOBUF_UNLOAD : 0, abort_if_last, true);</a>
<a name="ln2785">    if (win_valid_any_tab(win)) {</a>
<a name="ln2786">      win-&gt;w_closing = false;</a>
<a name="ln2787">    }</a>
<a name="ln2788"> </a>
<a name="ln2789">    // Make sure curbuf is valid. It can become invalid if 'bufhidden' is</a>
<a name="ln2790">    // &quot;wipe&quot;.</a>
<a name="ln2791">    if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2792">      curbuf = firstbuf;</a>
<a name="ln2793">    }</a>
<a name="ln2794">  }</a>
<a name="ln2795">}</a>
<a name="ln2796"> </a>
<a name="ln2797">// Close window &quot;win&quot;.  Only works for the current tab page.</a>
<a name="ln2798">// If &quot;free_buf&quot; is true related buffer may be unloaded.</a>
<a name="ln2799">//</a>
<a name="ln2800">// Called by :quit, :close, :xit, :wq and findtag().</a>
<a name="ln2801">// Returns FAIL when the window was not closed.</a>
<a name="ln2802">int win_close(win_T *win, bool free_buf, bool force)</a>
<a name="ln2803">{</a>
<a name="ln2804">  tabpage_T *prev_curtab = curtab;</a>
<a name="ln2805">  frame_T *win_frame = win-&gt;w_floating ? NULL : win-&gt;w_frame-&gt;fr_parent;</a>
<a name="ln2806">  const bool had_diffmode = win-&gt;w_p_diff;</a>
<a name="ln2807"> </a>
<a name="ln2808">  if (last_window(win)) {</a>
<a name="ln2809">    emsg(_(&quot;E444: Cannot close last window&quot;));</a>
<a name="ln2810">    return FAIL;</a>
<a name="ln2811">  }</a>
<a name="ln2812"> </a>
<a name="ln2813">  if (win-&gt;w_closing</a>
<a name="ln2814">      || (win-&gt;w_buffer != NULL &amp;&amp; win-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln2815">    return FAIL;     // window is already being closed</a>
<a name="ln2816">  }</a>
<a name="ln2817">  if (is_aucmd_win(win)) {</a>
<a name="ln2818">    emsg(_(e_autocmd_close));</a>
<a name="ln2819">    return FAIL;</a>
<a name="ln2820">  }</a>
<a name="ln2821">  if (lastwin-&gt;w_floating &amp;&amp; one_window(win)) {</a>
<a name="ln2822">    if (is_aucmd_win(lastwin)) {</a>
<a name="ln2823">      emsg(_(&quot;E814: Cannot close window, only autocmd window would remain&quot;));</a>
<a name="ln2824">      return FAIL;</a>
<a name="ln2825">    }</a>
<a name="ln2826">    if (force || can_close_floating_windows()) {</a>
<a name="ln2827">      // close the last window until the there are no floating windows</a>
<a name="ln2828">      while (lastwin-&gt;w_floating) {</a>
<a name="ln2829">        // `force` flag isn't actually used when closing a floating window.</a>
<a name="ln2830">        if (win_close(lastwin, free_buf, true) == FAIL) {</a>
<a name="ln2831">          // If closing the window fails give up, to avoid looping forever.</a>
<a name="ln2832">          return FAIL;</a>
<a name="ln2833">        }</a>
<a name="ln2834">      }</a>
<a name="ln2835">    } else {</a>
<a name="ln2836">      emsg(e_floatonly);</a>
<a name="ln2837">      return FAIL;</a>
<a name="ln2838">    }</a>
<a name="ln2839">  }</a>
<a name="ln2840"> </a>
<a name="ln2841">  // When closing the last window in a tab page first go to another tab page</a>
<a name="ln2842">  // and then close the window and the tab page to avoid that curwin and</a>
<a name="ln2843">  // curtab are invalid while we are freeing memory.</a>
<a name="ln2844">  if (close_last_window_tabpage(win, free_buf, prev_curtab)) {</a>
<a name="ln2845">    return FAIL;</a>
<a name="ln2846">  }</a>
<a name="ln2847"> </a>
<a name="ln2848">  bool help_window = false;</a>
<a name="ln2849"> </a>
<a name="ln2850">  // When closing the help window, try restoring a snapshot after closing</a>
<a name="ln2851">  // the window.  Otherwise clear the snapshot, it's now invalid.</a>
<a name="ln2852">  if (bt_help(win-&gt;w_buffer)) {</a>
<a name="ln2853">    help_window = true;</a>
<a name="ln2854">  } else {</a>
<a name="ln2855">    clear_snapshot(curtab, SNAP_HELP_IDX);</a>
<a name="ln2856">  }</a>
<a name="ln2857"> </a>
<a name="ln2858">  win_T *wp;</a>
<a name="ln2859">  bool other_buffer = false;</a>
<a name="ln2860"> </a>
<a name="ln2861">  if (win == curwin) {</a>
<a name="ln2862">    leaving_window(curwin);</a>
<a name="ln2863"> </a>
<a name="ln2864">    // Guess which window is going to be the new current window.</a>
<a name="ln2865">    // This may change because of the autocommands (sigh).</a>
<a name="ln2866">    if (!win-&gt;w_floating) {</a>
<a name="ln2867">      wp = frame2win(win_altframe(win, NULL));</a>
<a name="ln2868">    } else {</a>
<a name="ln2869">      if (win_valid(prevwin) &amp;&amp; prevwin != win) {</a>
<a name="ln2870">        wp = prevwin;</a>
<a name="ln2871">      } else {</a>
<a name="ln2872">        wp = firstwin;</a>
<a name="ln2873">      }</a>
<a name="ln2874">    }</a>
<a name="ln2875"> </a>
<a name="ln2876">    // Be careful: If autocommands delete the window or cause this window</a>
<a name="ln2877">    // to be the last one left, return now.</a>
<a name="ln2878">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln2879">      reset_VIsual_and_resel();  // stop Visual mode</a>
<a name="ln2880"> </a>
<a name="ln2881">      other_buffer = true;</a>
<a name="ln2882">      win-&gt;w_closing = true;</a>
<a name="ln2883">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2884">      if (!win_valid(win)) {</a>
<a name="ln2885">        return FAIL;</a>
<a name="ln2886">      }</a>
<a name="ln2887">      win-&gt;w_closing = false;</a>
<a name="ln2888">      if (last_window(win)) {</a>
<a name="ln2889">        return FAIL;</a>
<a name="ln2890">      }</a>
<a name="ln2891">    }</a>
<a name="ln2892">    win-&gt;w_closing = true;</a>
<a name="ln2893">    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln2894">    if (!win_valid(win)) {</a>
<a name="ln2895">      return FAIL;</a>
<a name="ln2896">    }</a>
<a name="ln2897">    win-&gt;w_closing = false;</a>
<a name="ln2898">    if (last_window(win)) {</a>
<a name="ln2899">      return FAIL;</a>
<a name="ln2900">    }</a>
<a name="ln2901">    // autocmds may abort script processing</a>
<a name="ln2902">    if (aborting()) {</a>
<a name="ln2903">      return FAIL;</a>
<a name="ln2904">    }</a>
<a name="ln2905">  }</a>
<a name="ln2906"> </a>
<a name="ln2907">  // Fire WinClosed just before starting to free window-related resources.</a>
<a name="ln2908">  do_autocmd_winclosed(win);</a>
<a name="ln2909">  // autocmd may have freed the window already.</a>
<a name="ln2910">  if (!win_valid_any_tab(win)) {</a>
<a name="ln2911">    return OK;</a>
<a name="ln2912">  }</a>
<a name="ln2913"> </a>
<a name="ln2914">  win_close_buffer(win, free_buf, true);</a>
<a name="ln2915"> </a>
<a name="ln2916">  if (only_one_window() &amp;&amp; win_valid(win) &amp;&amp; win-&gt;w_buffer == NULL</a>
<a name="ln2917">      &amp;&amp; (last_window(win) || curtab != prev_curtab</a>
<a name="ln2918">          || close_last_window_tabpage(win, free_buf, prev_curtab))</a>
<a name="ln2919">      &amp;&amp; !win-&gt;w_floating) {</a>
<a name="ln2920">    // Autocommands have closed all windows, quit now.  Restore</a>
<a name="ln2921">    // curwin-&gt;w_buffer, otherwise writing ShaDa file may fail.</a>
<a name="ln2922">    if (curwin-&gt;w_buffer == NULL) {</a>
<a name="ln2923">      curwin-&gt;w_buffer = curbuf;</a>
<a name="ln2924">    }</a>
<a name="ln2925">    getout(0);</a>
<a name="ln2926">  }</a>
<a name="ln2927">  // Autocommands may have moved to another tab page.</a>
<a name="ln2928">  if (curtab != prev_curtab &amp;&amp; win_valid_any_tab(win)</a>
<a name="ln2929">      &amp;&amp; win-&gt;w_buffer == NULL) {</a>
<a name="ln2930">    // Need to close the window anyway, since the buffer is NULL.</a>
<a name="ln2931">    // Don't trigger autocmds with a NULL buffer.</a>
<a name="ln2932">    block_autocmds();</a>
<a name="ln2933">    win_close_othertab(win, false, prev_curtab);</a>
<a name="ln2934">    unblock_autocmds();</a>
<a name="ln2935">    return FAIL;</a>
<a name="ln2936">  }</a>
<a name="ln2937"> </a>
<a name="ln2938">  // Autocommands may have closed the window already, or closed the only</a>
<a name="ln2939">  // other window or moved to another tab page.</a>
<a name="ln2940">  if (!win_valid(win) || (!win-&gt;w_floating &amp;&amp; last_window(win))</a>
<a name="ln2941">      || close_last_window_tabpage(win, free_buf, prev_curtab)) {</a>
<a name="ln2942">    return FAIL;</a>
<a name="ln2943">  }</a>
<a name="ln2944"> </a>
<a name="ln2945">  // Now we are really going to close the window.  Disallow any autocommand</a>
<a name="ln2946">  // to split a window to avoid trouble.</a>
<a name="ln2947">  split_disallowed++;</a>
<a name="ln2948"> </a>
<a name="ln2949">  // let terminal buffers know that this window dimensions may be ignored</a>
<a name="ln2950">  win-&gt;w_closing = true;</a>
<a name="ln2951"> </a>
<a name="ln2952">  bool was_floating = win-&gt;w_floating;</a>
<a name="ln2953">  if (ui_has(kUIMultigrid)) {</a>
<a name="ln2954">    ui_call_win_close(win-&gt;w_grid_alloc.handle);</a>
<a name="ln2955">  }</a>
<a name="ln2956"> </a>
<a name="ln2957">  if (win-&gt;w_floating) {</a>
<a name="ln2958">    ui_comp_remove_grid(&amp;win-&gt;w_grid_alloc);</a>
<a name="ln2959">    assert(first_tabpage != NULL);  // suppress clang &quot;Dereference of NULL pointer&quot;</a>
<a name="ln2960">    if (win-&gt;w_float_config.external) {</a>
<a name="ln2961">      for (tabpage_T *tp = first_tabpage; tp != NULL; tp = tp-&gt;tp_next) {</a>
<a name="ln2962">        if (tp == curtab) {</a>
<a name="ln2963">          continue;</a>
<a name="ln2964">        }</a>
<a name="ln2965">        if (tp-&gt;tp_curwin == win) {</a>
<a name="ln2966">          // NB: an autocmd can still abort the closing of this window,</a>
<a name="ln2967">          // bur carring out this change anyway shouldn't be a catastrophe.</a>
<a name="ln2968">          tp-&gt;tp_curwin = tp-&gt;tp_firstwin;</a>
<a name="ln2969">        }</a>
<a name="ln2970">      }</a>
<a name="ln2971">    }</a>
<a name="ln2972">  }</a>
<a name="ln2973"> </a>
<a name="ln2974">  // Free the memory used for the window and get the window that received</a>
<a name="ln2975">  // the screen space.</a>
<a name="ln2976">  int dir;</a>
<a name="ln2977">  wp = win_free_mem(win, &amp;dir, NULL);</a>
<a name="ln2978"> </a>
<a name="ln2979">  if (help_window) {</a>
<a name="ln2980">    // Closing the help window moves the cursor back to the current window</a>
<a name="ln2981">    // of the snapshot.</a>
<a name="ln2982">    win_T *prev_win = get_snapshot_curwin(SNAP_HELP_IDX);</a>
<a name="ln2983">    if (win_valid(prev_win)) {</a>
<a name="ln2984">      wp = prev_win;</a>
<a name="ln2985">    }</a>
<a name="ln2986">  }</a>
<a name="ln2987"> </a>
<a name="ln2988">  bool close_curwin = false;</a>
<a name="ln2989"> </a>
<a name="ln2990">  // Make sure curwin isn't invalid.  It can cause severe trouble when</a>
<a name="ln2991">  // printing an error message.  For win_equal() curbuf needs to be valid</a>
<a name="ln2992">  // too.</a>
<a name="ln2993">  if (win == curwin) {</a>
<a name="ln2994">    curwin = wp;</a>
<a name="ln2995">    if (wp-&gt;w_p_pvw || bt_quickfix(wp-&gt;w_buffer)) {</a>
<a name="ln2996">      // If the cursor goes to the preview or the quickfix window, try</a>
<a name="ln2997">      // finding another window to go to.</a>
<a name="ln2998">      while (true) {</a>
<a name="ln2999">        if (wp-&gt;w_next == NULL) {</a>
<a name="ln3000">          wp = firstwin;</a>
<a name="ln3001">        } else {</a>
<a name="ln3002">          wp = wp-&gt;w_next;</a>
<a name="ln3003">        }</a>
<a name="ln3004">        if (wp == curwin) {</a>
<a name="ln3005">          break;</a>
<a name="ln3006">        }</a>
<a name="ln3007">        if (!wp-&gt;w_p_pvw &amp;&amp; !bt_quickfix(wp-&gt;w_buffer)) {</a>
<a name="ln3008">          curwin = wp;</a>
<a name="ln3009">          break;</a>
<a name="ln3010">        }</a>
<a name="ln3011">      }</a>
<a name="ln3012">    }</a>
<a name="ln3013">    curbuf = curwin-&gt;w_buffer;</a>
<a name="ln3014">    close_curwin = true;</a>
<a name="ln3015"> </a>
<a name="ln3016">    // The cursor position may be invalid if the buffer changed after last</a>
<a name="ln3017">    // using the window.</a>
<a name="ln3018">    check_cursor();</a>
<a name="ln3019">  }</a>
<a name="ln3020"> </a>
<a name="ln3021">  if (!was_floating) {</a>
<a name="ln3022">    // If last window has a status line now and we don't want one,</a>
<a name="ln3023">    // remove the status line. Do this before win_equal(), because</a>
<a name="ln3024">    // it may change the height of a window.</a>
<a name="ln3025">    last_status(false);</a>
<a name="ln3026"> </a>
<a name="ln3027">    if (!curwin-&gt;w_floating &amp;&amp; p_ea &amp;&amp; (*p_ead == 'b' || *p_ead == dir)) {</a>
<a name="ln3028">      // If the frame of the closed window contains the new current window,</a>
<a name="ln3029">      // only resize that frame.  Otherwise resize all windows.</a>
<a name="ln3030">      win_equal(curwin, curwin-&gt;w_frame-&gt;fr_parent == win_frame, dir);</a>
<a name="ln3031">    } else {</a>
<a name="ln3032">      (void)win_comp_pos();</a>
<a name="ln3033">      win_fix_scroll(false);</a>
<a name="ln3034">    }</a>
<a name="ln3035">  }</a>
<a name="ln3036"> </a>
<a name="ln3037">  if (close_curwin) {</a>
<a name="ln3038">    win_enter_ext(wp, WEE_CURWIN_INVALID | WEE_TRIGGER_ENTER_AUTOCMDS</a>
<a name="ln3039">                  | WEE_TRIGGER_LEAVE_AUTOCMDS);</a>
<a name="ln3040">    if (other_buffer) {</a>
<a name="ln3041">      // careful: after this wp and win may be invalid!</a>
<a name="ln3042">      apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);</a>
<a name="ln3043">    }</a>
<a name="ln3044">  }</a>
<a name="ln3045"> </a>
<a name="ln3046">  split_disallowed--;</a>
<a name="ln3047"> </a>
<a name="ln3048">  // After closing the help window, try restoring the window layout from</a>
<a name="ln3049">  // before it was opened.</a>
<a name="ln3050">  if (help_window) {</a>
<a name="ln3051">    restore_snapshot(SNAP_HELP_IDX, close_curwin);</a>
<a name="ln3052">  }</a>
<a name="ln3053"> </a>
<a name="ln3054">  // If the window had 'diff' set and now there is only one window left in</a>
<a name="ln3055">  // the tab page with 'diff' set, and &quot;closeoff&quot; is in 'diffopt', then</a>
<a name="ln3056">  // execute &quot;:diffoff!&quot;.</a>
<a name="ln3057">  if (diffopt_closeoff() &amp;&amp; had_diffmode &amp;&amp; curtab == prev_curtab) {</a>
<a name="ln3058">    int diffcount = 0;</a>
<a name="ln3059"> </a>
<a name="ln3060">    FOR_ALL_WINDOWS_IN_TAB(dwin, curtab) {</a>
<a name="ln3061">      if (dwin-&gt;w_p_diff) {</a>
<a name="ln3062">        diffcount++;</a>
<a name="ln3063">      }</a>
<a name="ln3064">    }</a>
<a name="ln3065">    if (diffcount == 1) {</a>
<a name="ln3066">      do_cmdline_cmd(&quot;diffoff!&quot;);</a>
<a name="ln3067">    }</a>
<a name="ln3068">  }</a>
<a name="ln3069"> </a>
<a name="ln3070">  curwin-&gt;w_pos_changed = true;</a>
<a name="ln3071">  if (!was_floating) {</a>
<a name="ln3072">    // TODO(bfredl): how about no?</a>
<a name="ln3073">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln3074">  }</a>
<a name="ln3075">  return OK;</a>
<a name="ln3076">}</a>
<a name="ln3077"> </a>
<a name="ln3078">static void do_autocmd_winclosed(win_T *win)</a>
<a name="ln3079">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3080">{</a>
<a name="ln3081">  static bool recursive = false;</a>
<a name="ln3082">  if (recursive || !has_event(EVENT_WINCLOSED)) {</a>
<a name="ln3083">    return;</a>
<a name="ln3084">  }</a>
<a name="ln3085">  recursive = true;</a>
<a name="ln3086">  char winid[NUMBUFLEN];</a>
<a name="ln3087">  vim_snprintf(winid, sizeof(winid), &quot;%d&quot;, win-&gt;handle);</a>
<a name="ln3088">  apply_autocmds(EVENT_WINCLOSED, winid, winid, false, win-&gt;w_buffer);</a>
<a name="ln3089">  recursive = false;</a>
<a name="ln3090">}</a>
<a name="ln3091"> </a>
<a name="ln3092">// Close window &quot;win&quot; in tab page &quot;tp&quot;, which is not the current tab page.</a>
<a name="ln3093">// This may be the last window in that tab page and result in closing the tab,</a>
<a name="ln3094">// thus &quot;tp&quot; may become invalid!</a>
<a name="ln3095">// Caller must check if buffer is hidden and whether the tabline needs to be</a>
<a name="ln3096">// updated.</a>
<a name="ln3097">void win_close_othertab(win_T *win, int free_buf, tabpage_T *tp)</a>
<a name="ln3098">{</a>
<a name="ln3099">  // Get here with win-&gt;w_buffer == NULL when win_close() detects the tab page</a>
<a name="ln3100">  // changed.</a>
<a name="ln3101">  if (win-&gt;w_closing</a>
<a name="ln3102">      || (win-&gt;w_buffer != NULL &amp;&amp; win-&gt;w_buffer-&gt;b_locked &gt; 0)) {</a>
<a name="ln3103">    return;  // window is already being closed</a>
<a name="ln3104">  }</a>
<a name="ln3105"> </a>
<a name="ln3106">  // Fire WinClosed just before starting to free window-related resources.</a>
<a name="ln3107">  do_autocmd_winclosed(win);</a>
<a name="ln3108">  // autocmd may have freed the window already.</a>
<a name="ln3109">  if (!win_valid_any_tab(win)) {</a>
<a name="ln3110">    return;</a>
<a name="ln3111">  }</a>
<a name="ln3112"> </a>
<a name="ln3113">  if (win-&gt;w_buffer != NULL) {</a>
<a name="ln3114">    // Close the link to the buffer.</a>
<a name="ln3115">    close_buffer(win, win-&gt;w_buffer, free_buf ? DOBUF_UNLOAD : 0, false, true);</a>
<a name="ln3116">  }</a>
<a name="ln3117"> </a>
<a name="ln3118">  tabpage_T *ptp = NULL;</a>
<a name="ln3119"> </a>
<a name="ln3120">  // Careful: Autocommands may have closed the tab page or made it the</a>
<a name="ln3121">  // current tab page.</a>
<a name="ln3122">  for (ptp = first_tabpage; ptp != NULL &amp;&amp; ptp != tp; ptp = ptp-&gt;tp_next) {}</a>
<a name="ln3123">  if (ptp == NULL || tp == curtab) {</a>
<a name="ln3124">    // If the buffer was removed from the window we have to give it any</a>
<a name="ln3125">    // buffer.</a>
<a name="ln3126">    if (win_valid_any_tab(win) &amp;&amp; win-&gt;w_buffer == NULL) {</a>
<a name="ln3127">      win-&gt;w_buffer = firstbuf;</a>
<a name="ln3128">      firstbuf-&gt;b_nwindows++;</a>
<a name="ln3129">      win_init_empty(win);</a>
<a name="ln3130">    }</a>
<a name="ln3131">    return;</a>
<a name="ln3132">  }</a>
<a name="ln3133"> </a>
<a name="ln3134">  // Autocommands may have closed the window already.</a>
<a name="ln3135">  {</a>
<a name="ln3136">    bool found_window = false;</a>
<a name="ln3137">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln3138">      if (wp == win) {</a>
<a name="ln3139">        found_window = true;</a>
<a name="ln3140">        break;</a>
<a name="ln3141">      }</a>
<a name="ln3142">    }</a>
<a name="ln3143">    if (!found_window) {</a>
<a name="ln3144">      return;</a>
<a name="ln3145">    }</a>
<a name="ln3146">  }</a>
<a name="ln3147"> </a>
<a name="ln3148">  bool free_tp = false;</a>
<a name="ln3149"> </a>
<a name="ln3150">  // When closing the last window in a tab page remove the tab page.</a>
<a name="ln3151">  if (tp-&gt;tp_firstwin == tp-&gt;tp_lastwin) {</a>
<a name="ln3152">    char prev_idx[NUMBUFLEN];</a>
<a name="ln3153">    if (has_event(EVENT_TABCLOSED)) {</a>
<a name="ln3154">      vim_snprintf(prev_idx, NUMBUFLEN, &quot;%i&quot;, tabpage_index(tp));</a>
<a name="ln3155">    }</a>
<a name="ln3156"> </a>
<a name="ln3157">    int h = tabline_height();</a>
<a name="ln3158"> </a>
<a name="ln3159">    if (tp == first_tabpage) {</a>
<a name="ln3160">      first_tabpage = tp-&gt;tp_next;</a>
<a name="ln3161">    } else {</a>
<a name="ln3162">      for (ptp = first_tabpage; ptp != NULL &amp;&amp; ptp-&gt;tp_next != tp;</a>
<a name="ln3163">           ptp = ptp-&gt;tp_next) {</a>
<a name="ln3164">        // loop</a>
<a name="ln3165">      }</a>
<a name="ln3166">      if (ptp == NULL) {</a>
<a name="ln3167">        internal_error(&quot;win_close_othertab()&quot;);</a>
<a name="ln3168">        return;</a>
<a name="ln3169">      }</a>
<a name="ln3170">      ptp-&gt;tp_next = tp-&gt;tp_next;</a>
<a name="ln3171">    }</a>
<a name="ln3172">    free_tp = true;</a>
<a name="ln3173">    redraw_tabline = true;</a>
<a name="ln3174">    if (h != tabline_height()) {</a>
<a name="ln3175">      win_new_screen_rows();</a>
<a name="ln3176">    }</a>
<a name="ln3177"> </a>
<a name="ln3178">    if (has_event(EVENT_TABCLOSED)) {</a>
<a name="ln3179">      apply_autocmds(EVENT_TABCLOSED, prev_idx, prev_idx, false, win-&gt;w_buffer);</a>
<a name="ln3180">    }</a>
<a name="ln3181">  }</a>
<a name="ln3182"> </a>
<a name="ln3183">  // Free the memory used for the window.</a>
<a name="ln3184">  int dir;</a>
<a name="ln3185">  win_free_mem(win, &amp;dir, tp);</a>
<a name="ln3186"> </a>
<a name="ln3187">  if (free_tp) {</a>
<a name="ln3188">    free_tabpage(tp);</a>
<a name="ln3189">  }</a>
<a name="ln3190">}</a>
<a name="ln3191"> </a>
<a name="ln3192">/// Free the memory used for a window.</a>
<a name="ln3193">///</a>
<a name="ln3194">/// @param dirp  set to 'v' or 'h' for direction if 'ea'</a>
<a name="ln3195">/// @param tp    tab page &quot;win&quot; is in, NULL for current</a>
<a name="ln3196">///</a>
<a name="ln3197">/// @return      a pointer to the window that got the freed up space.</a>
<a name="ln3198">static win_T *win_free_mem(win_T *win, int *dirp, tabpage_T *tp)</a>
<a name="ln3199">{</a>
<a name="ln3200">  win_T *wp;</a>
<a name="ln3201">  tabpage_T *win_tp = tp == NULL ? curtab : tp;</a>
<a name="ln3202"> </a>
<a name="ln3203">  if (!win-&gt;w_floating) {</a>
<a name="ln3204">    // Remove the window and its frame from the tree of frames.</a>
<a name="ln3205">    frame_T *frp = win-&gt;w_frame;</a>
<a name="ln3206">    wp = winframe_remove(win, dirp, tp);</a>
<a name="ln3207">    xfree(frp);</a>
<a name="ln3208">  } else {</a>
<a name="ln3209">    *dirp = 'h';  // Dummy value.</a>
<a name="ln3210">    if (tp == NULL) {</a>
<a name="ln3211">      if (win_valid(prevwin) &amp;&amp; prevwin != win) {</a>
<a name="ln3212">        wp = prevwin;</a>
<a name="ln3213">      } else {</a>
<a name="ln3214">        wp = firstwin;</a>
<a name="ln3215">      }</a>
<a name="ln3216">    } else {</a>
<a name="ln3217">      if (tabpage_win_valid(tp, tp-&gt;tp_prevwin) &amp;&amp; tp-&gt;tp_prevwin != win) {</a>
<a name="ln3218">        wp = tp-&gt;tp_prevwin;</a>
<a name="ln3219">      } else {</a>
<a name="ln3220">        wp = tp-&gt;tp_firstwin;</a>
<a name="ln3221">      }</a>
<a name="ln3222">    }</a>
<a name="ln3223">  }</a>
<a name="ln3224">  win_free(win, tp);</a>
<a name="ln3225"> </a>
<a name="ln3226">  // When deleting the current window in the tab, select a new current</a>
<a name="ln3227">  // window.</a>
<a name="ln3228">  if (win == win_tp-&gt;tp_curwin) {</a>
<a name="ln3229">    win_tp-&gt;tp_curwin = wp;</a>
<a name="ln3230">  }</a>
<a name="ln3231"> </a>
<a name="ln3232">  return wp;</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">#if defined(EXITFREE)</a>
<a name="ln3236">void win_free_all(void)</a>
<a name="ln3237">{</a>
<a name="ln3238">  // avoid an error for switching tabpage with the cmdline window open</a>
<a name="ln3239">  cmdwin_type = 0;</a>
<a name="ln3240"> </a>
<a name="ln3241">  while (first_tabpage-&gt;tp_next != NULL) {</a>
<a name="ln3242">    tabpage_close(true);</a>
<a name="ln3243">  }</a>
<a name="ln3244"> </a>
<a name="ln3245">  while (lastwin != NULL &amp;&amp; lastwin-&gt;w_floating) {</a>
<a name="ln3246">    win_T *wp = lastwin;</a>
<a name="ln3247">    win_remove(lastwin, NULL);</a>
<a name="ln3248">    int dummy;</a>
<a name="ln3249">    (void)win_free_mem(wp, &amp;dummy, NULL);</a>
<a name="ln3250">    for (int i = 0; i &lt; AUCMD_WIN_COUNT; i++) {</a>
<a name="ln3251">      if (aucmd_win[i].auc_win == wp) {</a>
<a name="ln3252">        aucmd_win[i].auc_win = NULL;</a>
<a name="ln3253">      }</a>
<a name="ln3254">    }</a>
<a name="ln3255">  }</a>
<a name="ln3256"> </a>
<a name="ln3257">  for (int i = 0; i &lt; AUCMD_WIN_COUNT; i++) {</a>
<a name="ln3258">    if (aucmd_win[i].auc_win != NULL) {</a>
<a name="ln3259">      int dummy;</a>
<a name="ln3260">      (void)win_free_mem(aucmd_win[i].auc_win, &amp;dummy, NULL);</a>
<a name="ln3261">      aucmd_win[i].auc_win = NULL;</a>
<a name="ln3262">    }</a>
<a name="ln3263">  }</a>
<a name="ln3264"> </a>
<a name="ln3265">  kv_destroy(aucmd_win_vec);</a>
<a name="ln3266"> </a>
<a name="ln3267">  while (firstwin != NULL) {</a>
<a name="ln3268">    int dummy;</a>
<a name="ln3269">    (void)win_free_mem(firstwin, &amp;dummy, NULL);</a>
<a name="ln3270">  }</a>
<a name="ln3271"> </a>
<a name="ln3272">  // No window should be used after this. Set curwin to NULL to crash</a>
<a name="ln3273">  // instead of using freed memory.</a>
<a name="ln3274">  curwin = NULL;</a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">#endif</a>
<a name="ln3278"> </a>
<a name="ln3279">/// Remove a window and its frame from the tree of frames.</a>
<a name="ln3280">///</a>
<a name="ln3281">/// @param dirp  set to 'v' or 'h' for direction if 'ea'</a>
<a name="ln3282">/// @param tp    tab page &quot;win&quot; is in, NULL for current</a>
<a name="ln3283">///</a>
<a name="ln3284">/// @return      a pointer to the window that got the freed up space.</a>
<a name="ln3285">win_T *winframe_remove(win_T *win, int *dirp, tabpage_T *tp)</a>
<a name="ln3286">{</a>
<a name="ln3287">  // If there is only one window there is nothing to remove.</a>
<a name="ln3288">  if (tp == NULL ? ONE_WINDOW : tp-&gt;tp_firstwin == tp-&gt;tp_lastwin) {</a>
<a name="ln3289">    return NULL;</a>
<a name="ln3290">  }</a>
<a name="ln3291"> </a>
<a name="ln3292">  frame_T *frp_close = win-&gt;w_frame;</a>
<a name="ln3293"> </a>
<a name="ln3294">  // Remove the window from its frame.</a>
<a name="ln3295">  frame_T *frp2 = win_altframe(win, tp);</a>
<a name="ln3296">  win_T *wp = frame2win(frp2);</a>
<a name="ln3297"> </a>
<a name="ln3298">  // Remove this frame from the list of frames.</a>
<a name="ln3299">  frame_remove(frp_close);</a>
<a name="ln3300"> </a>
<a name="ln3301">  if (frp_close-&gt;fr_parent-&gt;fr_layout == FR_COL) {</a>
<a name="ln3302">    // When 'winfixheight' is set, try to find another frame in the column</a>
<a name="ln3303">    // (as close to the closed frame as possible) to distribute the height</a>
<a name="ln3304">    // to.</a>
<a name="ln3305">    if (frp2-&gt;fr_win != NULL &amp;&amp; frp2-&gt;fr_win-&gt;w_p_wfh) {</a>
<a name="ln3306">      frame_T *frp = frp_close-&gt;fr_prev;</a>
<a name="ln3307">      frame_T *frp3 = frp_close-&gt;fr_next;</a>
<a name="ln3308">      while (frp != NULL || frp3 != NULL) {</a>
<a name="ln3309">        if (frp != NULL) {</a>
<a name="ln3310">          if (!frame_fixed_height(frp)) {</a>
<a name="ln3311">            frp2 = frp;</a>
<a name="ln3312">            wp = frame2win(frp2);</a>
<a name="ln3313">            break;</a>
<a name="ln3314">          }</a>
<a name="ln3315">          frp = frp-&gt;fr_prev;</a>
<a name="ln3316">        }</a>
<a name="ln3317">        if (frp3 != NULL) {</a>
<a name="ln3318">          if (frp3-&gt;fr_win != NULL &amp;&amp; !frp3-&gt;fr_win-&gt;w_p_wfh) {</a>
<a name="ln3319">            frp2 = frp3;</a>
<a name="ln3320">            wp = frp3-&gt;fr_win;</a>
<a name="ln3321">            break;</a>
<a name="ln3322">          }</a>
<a name="ln3323">          frp3 = frp3-&gt;fr_next;</a>
<a name="ln3324">        }</a>
<a name="ln3325">      }</a>
<a name="ln3326">    }</a>
<a name="ln3327">    frame_new_height(frp2, frp2-&gt;fr_height + frp_close-&gt;fr_height,</a>
<a name="ln3328">                     frp2 == frp_close-&gt;fr_next, false);</a>
<a name="ln3329">    *dirp = 'v';</a>
<a name="ln3330">  } else {</a>
<a name="ln3331">    // When 'winfixwidth' is set, try to find another frame in the column</a>
<a name="ln3332">    // (as close to the closed frame as possible) to distribute the width</a>
<a name="ln3333">    // to.</a>
<a name="ln3334">    if (frp2-&gt;fr_win != NULL &amp;&amp; frp2-&gt;fr_win-&gt;w_p_wfw) {</a>
<a name="ln3335">      frame_T *frp = frp_close-&gt;fr_prev;</a>
<a name="ln3336">      frame_T *frp3 = frp_close-&gt;fr_next;</a>
<a name="ln3337">      while (frp != NULL || frp3 != NULL) {</a>
<a name="ln3338">        if (frp != NULL) {</a>
<a name="ln3339">          if (!frame_fixed_width(frp)) {</a>
<a name="ln3340">            frp2 = frp;</a>
<a name="ln3341">            wp = frame2win(frp2);</a>
<a name="ln3342">            break;</a>
<a name="ln3343">          }</a>
<a name="ln3344">          frp = frp-&gt;fr_prev;</a>
<a name="ln3345">        }</a>
<a name="ln3346">        if (frp3 != NULL) {</a>
<a name="ln3347">          if (frp3-&gt;fr_win != NULL &amp;&amp; !frp3-&gt;fr_win-&gt;w_p_wfw) {</a>
<a name="ln3348">            frp2 = frp3;</a>
<a name="ln3349">            wp = frp3-&gt;fr_win;</a>
<a name="ln3350">            break;</a>
<a name="ln3351">          }</a>
<a name="ln3352">          frp3 = frp3-&gt;fr_next;</a>
<a name="ln3353">        }</a>
<a name="ln3354">      }</a>
<a name="ln3355">    }</a>
<a name="ln3356">    frame_new_width(frp2, frp2-&gt;fr_width + frp_close-&gt;fr_width,</a>
<a name="ln3357">                    frp2 == frp_close-&gt;fr_next, false);</a>
<a name="ln3358">    *dirp = 'h';</a>
<a name="ln3359">  }</a>
<a name="ln3360"> </a>
<a name="ln3361">  // If rows/columns go to a window below/right its positions need to be</a>
<a name="ln3362">  // updated.  Can only be done after the sizes have been updated.</a>
<a name="ln3363">  if (frp2 == frp_close-&gt;fr_next) {</a>
<a name="ln3364">    int row = win-&gt;w_winrow;</a>
<a name="ln3365">    int col = win-&gt;w_wincol;</a>
<a name="ln3366"> </a>
<a name="ln3367">    frame_comp_pos(frp2, &amp;row, &amp;col);</a>
<a name="ln3368">  }</a>
<a name="ln3369"> </a>
<a name="ln3370">  if (frp2-&gt;fr_next == NULL &amp;&amp; frp2-&gt;fr_prev == NULL) {</a>
<a name="ln3371">    // There is no other frame in this list, move its info to the parent</a>
<a name="ln3372">    // and remove it.</a>
<a name="ln3373">    frp2-&gt;fr_parent-&gt;fr_layout = frp2-&gt;fr_layout;</a>
<a name="ln3374">    frp2-&gt;fr_parent-&gt;fr_child = frp2-&gt;fr_child;</a>
<a name="ln3375">    frame_T *frp;</a>
<a name="ln3376">    FOR_ALL_FRAMES(frp, frp2-&gt;fr_child) {</a>
<a name="ln3377">      frp-&gt;fr_parent = frp2-&gt;fr_parent;</a>
<a name="ln3378">    }</a>
<a name="ln3379">    frp2-&gt;fr_parent-&gt;fr_win = frp2-&gt;fr_win;</a>
<a name="ln3380">    if (frp2-&gt;fr_win != NULL) {</a>
<a name="ln3381">      frp2-&gt;fr_win-&gt;w_frame = frp2-&gt;fr_parent;</a>
<a name="ln3382">    }</a>
<a name="ln3383">    frp = frp2-&gt;fr_parent;</a>
<a name="ln3384">    if (topframe-&gt;fr_child == frp2) {</a>
<a name="ln3385">      topframe-&gt;fr_child = frp;</a>
<a name="ln3386">    }</a>
<a name="ln3387">    xfree(frp2);</a>
<a name="ln3388"> </a>
<a name="ln3389">    frp2 = frp-&gt;fr_parent;</a>
<a name="ln3390">    if (frp2 != NULL &amp;&amp; frp2-&gt;fr_layout == frp-&gt;fr_layout) {</a>
<a name="ln3391">      // The frame above the parent has the same layout, have to merge</a>
<a name="ln3392">      // the frames into this list.</a>
<a name="ln3393">      if (frp2-&gt;fr_child == frp) {</a>
<a name="ln3394">        frp2-&gt;fr_child = frp-&gt;fr_child;</a>
<a name="ln3395">      }</a>
<a name="ln3396">      assert(frp-&gt;fr_child);</a>
<a name="ln3397">      frp-&gt;fr_child-&gt;fr_prev = frp-&gt;fr_prev;</a>
<a name="ln3398">      if (frp-&gt;fr_prev != NULL) {</a>
<a name="ln3399">        frp-&gt;fr_prev-&gt;fr_next = frp-&gt;fr_child;</a>
<a name="ln3400">      }</a>
<a name="ln3401">      frame_T *frp3;</a>
<a name="ln3402">      for (frp3 = frp-&gt;fr_child;; frp3 = frp3-&gt;fr_next) {</a>
<a name="ln3403">        frp3-&gt;fr_parent = frp2;</a>
<a name="ln3404">        if (frp3-&gt;fr_next == NULL) {</a>
<a name="ln3405">          frp3-&gt;fr_next = frp-&gt;fr_next;</a>
<a name="ln3406">          if (frp-&gt;fr_next != NULL) {</a>
<a name="ln3407">            frp-&gt;fr_next-&gt;fr_prev = frp3;</a>
<a name="ln3408">          }</a>
<a name="ln3409">          break;</a>
<a name="ln3410">        }</a>
<a name="ln3411">      }</a>
<a name="ln3412">      if (topframe-&gt;fr_child == frp) {</a>
<a name="ln3413">        topframe-&gt;fr_child = frp2;</a>
<a name="ln3414">      }</a>
<a name="ln3415">      xfree(frp);</a>
<a name="ln3416">    }</a>
<a name="ln3417">  }</a>
<a name="ln3418"> </a>
<a name="ln3419">  return wp;</a>
<a name="ln3420">}</a>
<a name="ln3421"> </a>
<a name="ln3422">/// If 'splitbelow' or 'splitright' is set, the space goes above or to the left</a>
<a name="ln3423">/// by default.  Otherwise, the free space goes below or to the right.  The</a>
<a name="ln3424">/// result is that opening a window and then immediately closing it will</a>
<a name="ln3425">/// preserve the initial window layout.  The 'wfh' and 'wfw' settings are</a>
<a name="ln3426">/// respected when possible.</a>
<a name="ln3427">///</a>
<a name="ln3428">/// @param  tp  tab page &quot;win&quot; is in, NULL for current</a>
<a name="ln3429">///</a>
<a name="ln3430">/// @return a pointer to the frame that will receive the empty screen space that</a>
<a name="ln3431">/// is left over after &quot;win&quot; is closed.</a>
<a name="ln3432">static frame_T *win_altframe(win_T *win, tabpage_T *tp)</a>
<a name="ln3433">{</a>
<a name="ln3434">  if (tp == NULL ? ONE_WINDOW : tp-&gt;tp_firstwin == tp-&gt;tp_lastwin) {</a>
<a name="ln3435">    return alt_tabpage()-&gt;tp_curwin-&gt;w_frame;</a>
<a name="ln3436">  }</a>
<a name="ln3437"> </a>
<a name="ln3438">  frame_T *frp = win-&gt;w_frame;</a>
<a name="ln3439"> </a>
<a name="ln3440">  if (frp-&gt;fr_prev == NULL) {</a>
<a name="ln3441">    return frp-&gt;fr_next;</a>
<a name="ln3442">  }</a>
<a name="ln3443">  if (frp-&gt;fr_next == NULL) {</a>
<a name="ln3444">    return frp-&gt;fr_prev;</a>
<a name="ln3445">  }</a>
<a name="ln3446"> </a>
<a name="ln3447">  // By default the next window will get the space that was abandoned by this</a>
<a name="ln3448">  // window</a>
<a name="ln3449">  frame_T *target_fr = frp-&gt;fr_next;</a>
<a name="ln3450">  frame_T *other_fr  = frp-&gt;fr_prev;</a>
<a name="ln3451"> </a>
<a name="ln3452">  // If this is part of a column of windows and 'splitbelow' is true then the</a>
<a name="ln3453">  // previous window will get the space.</a>
<a name="ln3454">  if (frp-&gt;fr_parent != NULL &amp;&amp; frp-&gt;fr_parent-&gt;fr_layout == FR_COL &amp;&amp; p_sb) {</a>
<a name="ln3455">    target_fr = frp-&gt;fr_prev;</a>
<a name="ln3456">    other_fr  = frp-&gt;fr_next;</a>
<a name="ln3457">  }</a>
<a name="ln3458"> </a>
<a name="ln3459">  // If this is part of a row of windows, and 'splitright' is true then the</a>
<a name="ln3460">  // previous window will get the space.</a>
<a name="ln3461">  if (frp-&gt;fr_parent != NULL &amp;&amp; frp-&gt;fr_parent-&gt;fr_layout == FR_ROW &amp;&amp; p_spr) {</a>
<a name="ln3462">    target_fr = frp-&gt;fr_prev;</a>
<a name="ln3463">    other_fr  = frp-&gt;fr_next;</a>
<a name="ln3464">  }</a>
<a name="ln3465"> </a>
<a name="ln3466">  // If 'wfh' or 'wfw' is set for the target and not for the alternate</a>
<a name="ln3467">  // window, reverse the selection.</a>
<a name="ln3468">  if (frp-&gt;fr_parent != NULL &amp;&amp; frp-&gt;fr_parent-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3469">    if (frame_fixed_width(target_fr) &amp;&amp; !frame_fixed_width(other_fr)) {</a>
<a name="ln3470">      target_fr = other_fr;</a>
<a name="ln3471">    }</a>
<a name="ln3472">  } else {</a>
<a name="ln3473">    if (frame_fixed_height(target_fr) &amp;&amp; !frame_fixed_height(other_fr)) {</a>
<a name="ln3474">      target_fr = other_fr;</a>
<a name="ln3475">    }</a>
<a name="ln3476">  }</a>
<a name="ln3477"> </a>
<a name="ln3478">  return target_fr;</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">// Return the tabpage that will be used if the current one is closed.</a>
<a name="ln3482">static tabpage_T *alt_tabpage(void)</a>
<a name="ln3483">{</a>
<a name="ln3484">  // Use the next tab page if possible.</a>
<a name="ln3485">  if (curtab-&gt;tp_next != NULL) {</a>
<a name="ln3486">    return curtab-&gt;tp_next;</a>
<a name="ln3487">  }</a>
<a name="ln3488"> </a>
<a name="ln3489">  // Find the last but one tab page.</a>
<a name="ln3490">  tabpage_T *tp;</a>
<a name="ln3491">  for (tp = first_tabpage; tp-&gt;tp_next != curtab; tp = tp-&gt;tp_next) {}</a>
<a name="ln3492">  return tp;</a>
<a name="ln3493">}</a>
<a name="ln3494"> </a>
<a name="ln3495">// Find the left-upper window in frame &quot;frp&quot;.</a>
<a name="ln3496">win_T *frame2win(frame_T *frp)</a>
<a name="ln3497">{</a>
<a name="ln3498">  while (frp-&gt;fr_win == NULL) {</a>
<a name="ln3499">    frp = frp-&gt;fr_child;</a>
<a name="ln3500">  }</a>
<a name="ln3501">  return frp-&gt;fr_win;</a>
<a name="ln3502">}</a>
<a name="ln3503"> </a>
<a name="ln3504">/// Check that the frame &quot;frp&quot; contains the window &quot;wp&quot;.</a>
<a name="ln3505">///</a>
<a name="ln3506">/// @param  frp  frame</a>
<a name="ln3507">/// @param  wp   window</a>
<a name="ln3508">static bool frame_has_win(const frame_T *frp, const win_T *wp)</a>
<a name="ln3509">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3510">{</a>
<a name="ln3511">  if (frp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln3512">    return frp-&gt;fr_win == wp;</a>
<a name="ln3513">  }</a>
<a name="ln3514">  const frame_T *p;</a>
<a name="ln3515">  FOR_ALL_FRAMES(p, frp-&gt;fr_child) {</a>
<a name="ln3516">    if (frame_has_win(p, wp)) {</a>
<a name="ln3517">      return true;</a>
<a name="ln3518">    }</a>
<a name="ln3519">  }</a>
<a name="ln3520">  return false;</a>
<a name="ln3521">}</a>
<a name="ln3522"> </a>
<a name="ln3523">/// Check if current window is at the bottom</a>
<a name="ln3524">/// Returns true if there are no windows below current window</a>
<a name="ln3525">static bool is_bottom_win(win_T *wp)</a>
<a name="ln3526">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3527">{</a>
<a name="ln3528">  for (frame_T *frp = wp-&gt;w_frame; frp-&gt;fr_parent != NULL; frp = frp-&gt;fr_parent) {</a>
<a name="ln3529">    if (frp-&gt;fr_parent-&gt;fr_layout == FR_COL &amp;&amp; frp-&gt;fr_next != NULL) {</a>
<a name="ln3530">      return false;</a>
<a name="ln3531">    }</a>
<a name="ln3532">  }</a>
<a name="ln3533">  return true;</a>
<a name="ln3534">}</a>
<a name="ln3535">/// Set a new height for a frame.  Recursively sets the height for contained</a>
<a name="ln3536">/// frames and windows.  Caller must take care of positions.</a>
<a name="ln3537">///</a>
<a name="ln3538">/// @param topfirst  resize topmost contained frame first.</a>
<a name="ln3539">/// @param wfh       obey 'winfixheight' when there is a choice;</a>
<a name="ln3540">///                  may cause the height not to be set.</a>
<a name="ln3541">void frame_new_height(frame_T *topfrp, int height, bool topfirst, bool wfh)</a>
<a name="ln3542">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3543">{</a>
<a name="ln3544">  if (topfrp-&gt;fr_win != NULL) {</a>
<a name="ln3545">    // Simple case: just one window.</a>
<a name="ln3546">    win_T *wp = topfrp-&gt;fr_win;</a>
<a name="ln3547">    if (is_bottom_win(wp)) {</a>
<a name="ln3548">      wp-&gt;w_hsep_height = 0;</a>
<a name="ln3549">    }</a>
<a name="ln3550">    win_new_height(wp, height - wp-&gt;w_hsep_height - wp-&gt;w_status_height);</a>
<a name="ln3551">  } else if (topfrp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3552">    frame_T *frp;</a>
<a name="ln3553">    do {</a>
<a name="ln3554">      // All frames in this row get the same new height.</a>
<a name="ln3555">      FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3556">        frame_new_height(frp, height, topfirst, wfh);</a>
<a name="ln3557">        if (frp-&gt;fr_height &gt; height) {</a>
<a name="ln3558">          // Could not fit the windows, make the whole row higher.</a>
<a name="ln3559">          height = frp-&gt;fr_height;</a>
<a name="ln3560">          break;</a>
<a name="ln3561">        }</a>
<a name="ln3562">      }</a>
<a name="ln3563">    } while (frp != NULL);</a>
<a name="ln3564">  } else {  // fr_layout == FR_COL</a>
<a name="ln3565">    // Complicated case: Resize a column of frames.  Resize the bottom</a>
<a name="ln3566">    // frame first, frames above that when needed.</a>
<a name="ln3567"> </a>
<a name="ln3568">    frame_T *frp = topfrp-&gt;fr_child;</a>
<a name="ln3569">    if (wfh) {</a>
<a name="ln3570">      // Advance past frames with one window with 'wfh' set.</a>
<a name="ln3571">      while (frame_fixed_height(frp)) {</a>
<a name="ln3572">        frp = frp-&gt;fr_next;</a>
<a name="ln3573">        if (frp == NULL) {</a>
<a name="ln3574">          return;                   // no frame without 'wfh', give up</a>
<a name="ln3575">        }</a>
<a name="ln3576">      }</a>
<a name="ln3577">    }</a>
<a name="ln3578">    if (!topfirst) {</a>
<a name="ln3579">      // Find the bottom frame of this column</a>
<a name="ln3580">      while (frp-&gt;fr_next != NULL) {</a>
<a name="ln3581">        frp = frp-&gt;fr_next;</a>
<a name="ln3582">      }</a>
<a name="ln3583">      if (wfh) {</a>
<a name="ln3584">        // Advance back for frames with one window with 'wfh' set.</a>
<a name="ln3585">        while (frame_fixed_height(frp)) {</a>
<a name="ln3586">          frp = frp-&gt;fr_prev;</a>
<a name="ln3587">        }</a>
<a name="ln3588">      }</a>
<a name="ln3589">    }</a>
<a name="ln3590"> </a>
<a name="ln3591">    int extra_lines = height - topfrp-&gt;fr_height;</a>
<a name="ln3592">    if (extra_lines &lt; 0) {</a>
<a name="ln3593">      // reduce height of contained frames, bottom or top frame first</a>
<a name="ln3594">      while (frp != NULL) {</a>
<a name="ln3595">        int h = frame_minheight(frp, NULL);</a>
<a name="ln3596">        if (frp-&gt;fr_height + extra_lines &lt; h) {</a>
<a name="ln3597">          extra_lines += frp-&gt;fr_height - h;</a>
<a name="ln3598">          frame_new_height(frp, h, topfirst, wfh);</a>
<a name="ln3599">        } else {</a>
<a name="ln3600">          frame_new_height(frp, frp-&gt;fr_height + extra_lines,</a>
<a name="ln3601">                           topfirst, wfh);</a>
<a name="ln3602">          break;</a>
<a name="ln3603">        }</a>
<a name="ln3604">        if (topfirst) {</a>
<a name="ln3605">          do {</a>
<a name="ln3606">            frp = frp-&gt;fr_next;</a>
<a name="ln3607">          } while (wfh &amp;&amp; frp != NULL &amp;&amp; frame_fixed_height(frp));</a>
<a name="ln3608">        } else {</a>
<a name="ln3609">          do {</a>
<a name="ln3610">            frp = frp-&gt;fr_prev;</a>
<a name="ln3611">          } while (wfh &amp;&amp; frp != NULL &amp;&amp; frame_fixed_height(frp));</a>
<a name="ln3612">        }</a>
<a name="ln3613">        // Increase &quot;height&quot; if we could not reduce enough frames.</a>
<a name="ln3614">        if (frp == NULL) {</a>
<a name="ln3615">          height -= extra_lines;</a>
<a name="ln3616">        }</a>
<a name="ln3617">      }</a>
<a name="ln3618">    } else if (extra_lines &gt; 0) {</a>
<a name="ln3619">      // increase height of bottom or top frame</a>
<a name="ln3620">      frame_new_height(frp, frp-&gt;fr_height + extra_lines, topfirst, wfh);</a>
<a name="ln3621">    }</a>
<a name="ln3622">  }</a>
<a name="ln3623">  topfrp-&gt;fr_height = height;</a>
<a name="ln3624">}</a>
<a name="ln3625"> </a>
<a name="ln3626">/// Return true if height of frame &quot;frp&quot; should not be changed because of</a>
<a name="ln3627">/// the 'winfixheight' option.</a>
<a name="ln3628">///</a>
<a name="ln3629">/// @param  frp  frame</a>
<a name="ln3630">///</a>
<a name="ln3631">/// @return true if the frame has a fixed height</a>
<a name="ln3632">static bool frame_fixed_height(frame_T *frp)</a>
<a name="ln3633">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3634">{</a>
<a name="ln3635">  // frame with one window: fixed height if 'winfixheight' set.</a>
<a name="ln3636">  if (frp-&gt;fr_win != NULL) {</a>
<a name="ln3637">    return frp-&gt;fr_win-&gt;w_p_wfh;</a>
<a name="ln3638">  }</a>
<a name="ln3639">  if (frp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3640">    // The frame is fixed height if one of the frames in the row is fixed</a>
<a name="ln3641">    // height.</a>
<a name="ln3642">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3643">      if (frame_fixed_height(frp)) {</a>
<a name="ln3644">        return true;</a>
<a name="ln3645">      }</a>
<a name="ln3646">    }</a>
<a name="ln3647">    return false;</a>
<a name="ln3648">  }</a>
<a name="ln3649"> </a>
<a name="ln3650">  // frp-&gt;fr_layout == FR_COL: The frame is fixed height if all of the</a>
<a name="ln3651">  // frames in the row are fixed height.</a>
<a name="ln3652">  FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3653">    if (!frame_fixed_height(frp)) {</a>
<a name="ln3654">      return false;</a>
<a name="ln3655">    }</a>
<a name="ln3656">  }</a>
<a name="ln3657">  return true;</a>
<a name="ln3658">}</a>
<a name="ln3659"> </a>
<a name="ln3660">/// Return true if width of frame &quot;frp&quot; should not be changed because of</a>
<a name="ln3661">/// the 'winfixwidth' option.</a>
<a name="ln3662">///</a>
<a name="ln3663">/// @param  frp  frame</a>
<a name="ln3664">///</a>
<a name="ln3665">/// @return true if the frame has a fixed width</a>
<a name="ln3666">static bool frame_fixed_width(frame_T *frp)</a>
<a name="ln3667">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3668">{</a>
<a name="ln3669">  // frame with one window: fixed width if 'winfixwidth' set.</a>
<a name="ln3670">  if (frp-&gt;fr_win != NULL) {</a>
<a name="ln3671">    return frp-&gt;fr_win-&gt;w_p_wfw;</a>
<a name="ln3672">  }</a>
<a name="ln3673">  if (frp-&gt;fr_layout == FR_COL) {</a>
<a name="ln3674">    // The frame is fixed width if one of the frames in the row is fixed</a>
<a name="ln3675">    // width.</a>
<a name="ln3676">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3677">      if (frame_fixed_width(frp)) {</a>
<a name="ln3678">        return true;</a>
<a name="ln3679">      }</a>
<a name="ln3680">    }</a>
<a name="ln3681">    return false;</a>
<a name="ln3682">  }</a>
<a name="ln3683"> </a>
<a name="ln3684">  // frp-&gt;fr_layout == FR_ROW: The frame is fixed width if all of the</a>
<a name="ln3685">  // frames in the row are fixed width.</a>
<a name="ln3686">  FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3687">    if (!frame_fixed_width(frp)) {</a>
<a name="ln3688">      return false;</a>
<a name="ln3689">    }</a>
<a name="ln3690">  }</a>
<a name="ln3691">  return true;</a>
<a name="ln3692">}</a>
<a name="ln3693"> </a>
<a name="ln3694">// Add a status line to windows at the bottom of &quot;frp&quot;.</a>
<a name="ln3695">// Note: Does not check if there is room!</a>
<a name="ln3696">static void frame_add_statusline(frame_T *frp)</a>
<a name="ln3697">{</a>
<a name="ln3698">  if (frp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln3699">    win_T *wp = frp-&gt;fr_win;</a>
<a name="ln3700">    wp-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln3701">  } else if (frp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3702">    // Handle all the frames in the row.</a>
<a name="ln3703">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3704">      frame_add_statusline(frp);</a>
<a name="ln3705">    }</a>
<a name="ln3706">  } else {</a>
<a name="ln3707">    assert(frp-&gt;fr_layout == FR_COL);</a>
<a name="ln3708">    // Only need to handle the last frame in the column.</a>
<a name="ln3709">    for (frp = frp-&gt;fr_child; frp-&gt;fr_next != NULL; frp = frp-&gt;fr_next) {}</a>
<a name="ln3710">    frame_add_statusline(frp);</a>
<a name="ln3711">  }</a>
<a name="ln3712">}</a>
<a name="ln3713"> </a>
<a name="ln3714">/// Set width of a frame.  Handles recursively going through contained frames.</a>
<a name="ln3715">/// May remove separator line for windows at the right side (for win_close()).</a>
<a name="ln3716">///</a>
<a name="ln3717">/// @param leftfirst  resize leftmost contained frame first.</a>
<a name="ln3718">/// @param wfw        obey 'winfixwidth' when there is a choice;</a>
<a name="ln3719">///                   may cause the width not to be set.</a>
<a name="ln3720">static void frame_new_width(frame_T *topfrp, int width, bool leftfirst, bool wfw)</a>
<a name="ln3721">{</a>
<a name="ln3722">  if (topfrp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln3723">    // Simple case: just one window.</a>
<a name="ln3724">    win_T *wp = topfrp-&gt;fr_win;</a>
<a name="ln3725">    // Find out if there are any windows right of this one.</a>
<a name="ln3726">    frame_T *frp;</a>
<a name="ln3727">    for (frp = topfrp; frp-&gt;fr_parent != NULL; frp = frp-&gt;fr_parent) {</a>
<a name="ln3728">      if (frp-&gt;fr_parent-&gt;fr_layout == FR_ROW &amp;&amp; frp-&gt;fr_next != NULL) {</a>
<a name="ln3729">        break;</a>
<a name="ln3730">      }</a>
<a name="ln3731">    }</a>
<a name="ln3732">    if (frp-&gt;fr_parent == NULL) {</a>
<a name="ln3733">      wp-&gt;w_vsep_width = 0;</a>
<a name="ln3734">    }</a>
<a name="ln3735">    win_new_width(wp, width - wp-&gt;w_vsep_width);</a>
<a name="ln3736">  } else if (topfrp-&gt;fr_layout == FR_COL) {</a>
<a name="ln3737">    frame_T *frp;</a>
<a name="ln3738">    do {</a>
<a name="ln3739">      // All frames in this column get the same new width.</a>
<a name="ln3740">      FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3741">        frame_new_width(frp, width, leftfirst, wfw);</a>
<a name="ln3742">        if (frp-&gt;fr_width &gt; width) {</a>
<a name="ln3743">          // Could not fit the windows, make whole column wider.</a>
<a name="ln3744">          width = frp-&gt;fr_width;</a>
<a name="ln3745">          break;</a>
<a name="ln3746">        }</a>
<a name="ln3747">      }</a>
<a name="ln3748">    } while (frp != NULL);</a>
<a name="ln3749">  } else {  // fr_layout == FR_ROW</a>
<a name="ln3750">    // Complicated case: Resize a row of frames.  Resize the rightmost</a>
<a name="ln3751">    // frame first, frames left of it when needed.</a>
<a name="ln3752"> </a>
<a name="ln3753">    frame_T *frp = topfrp-&gt;fr_child;</a>
<a name="ln3754">    if (wfw) {</a>
<a name="ln3755">      // Advance past frames with one window with 'wfw' set.</a>
<a name="ln3756">      while (frame_fixed_width(frp)) {</a>
<a name="ln3757">        frp = frp-&gt;fr_next;</a>
<a name="ln3758">        if (frp == NULL) {</a>
<a name="ln3759">          return;                   // no frame without 'wfw', give up</a>
<a name="ln3760">        }</a>
<a name="ln3761">      }</a>
<a name="ln3762">    }</a>
<a name="ln3763">    if (!leftfirst) {</a>
<a name="ln3764">      // Find the rightmost frame of this row</a>
<a name="ln3765">      while (frp-&gt;fr_next != NULL) {</a>
<a name="ln3766">        frp = frp-&gt;fr_next;</a>
<a name="ln3767">      }</a>
<a name="ln3768">      if (wfw) {</a>
<a name="ln3769">        // Advance back for frames with one window with 'wfw' set.</a>
<a name="ln3770">        while (frame_fixed_width(frp)) {</a>
<a name="ln3771">          frp = frp-&gt;fr_prev;</a>
<a name="ln3772">        }</a>
<a name="ln3773">      }</a>
<a name="ln3774">    }</a>
<a name="ln3775"> </a>
<a name="ln3776">    int extra_cols = width - topfrp-&gt;fr_width;</a>
<a name="ln3777">    if (extra_cols &lt; 0) {</a>
<a name="ln3778">      // reduce frame width, rightmost frame first</a>
<a name="ln3779">      while (frp != NULL) {</a>
<a name="ln3780">        int w = frame_minwidth(frp, NULL);</a>
<a name="ln3781">        if (frp-&gt;fr_width + extra_cols &lt; w) {</a>
<a name="ln3782">          extra_cols += frp-&gt;fr_width - w;</a>
<a name="ln3783">          frame_new_width(frp, w, leftfirst, wfw);</a>
<a name="ln3784">        } else {</a>
<a name="ln3785">          frame_new_width(frp, frp-&gt;fr_width + extra_cols,</a>
<a name="ln3786">                          leftfirst, wfw);</a>
<a name="ln3787">          break;</a>
<a name="ln3788">        }</a>
<a name="ln3789">        if (leftfirst) {</a>
<a name="ln3790">          do {</a>
<a name="ln3791">            frp = frp-&gt;fr_next;</a>
<a name="ln3792">          } while (wfw &amp;&amp; frp != NULL &amp;&amp; frame_fixed_width(frp));</a>
<a name="ln3793">        } else {</a>
<a name="ln3794">          do {</a>
<a name="ln3795">            frp = frp-&gt;fr_prev;</a>
<a name="ln3796">          } while (wfw &amp;&amp; frp != NULL &amp;&amp; frame_fixed_width(frp));</a>
<a name="ln3797">        }</a>
<a name="ln3798">        // Increase &quot;width&quot; if we could not reduce enough frames.</a>
<a name="ln3799">        if (frp == NULL) {</a>
<a name="ln3800">          width -= extra_cols;</a>
<a name="ln3801">        }</a>
<a name="ln3802">      }</a>
<a name="ln3803">    } else if (extra_cols &gt; 0) {</a>
<a name="ln3804">      // increase width of rightmost frame</a>
<a name="ln3805">      frame_new_width(frp, frp-&gt;fr_width + extra_cols, leftfirst, wfw);</a>
<a name="ln3806">    }</a>
<a name="ln3807">  }</a>
<a name="ln3808">  topfrp-&gt;fr_width = width;</a>
<a name="ln3809">}</a>
<a name="ln3810"> </a>
<a name="ln3811">/// Add the vertical separator to windows at the right side of &quot;frp&quot;.</a>
<a name="ln3812">/// Note: Does not check if there is room!</a>
<a name="ln3813">static void frame_add_vsep(const frame_T *frp)</a>
<a name="ln3814">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3815">{</a>
<a name="ln3816">  if (frp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln3817">    win_T *wp = frp-&gt;fr_win;</a>
<a name="ln3818">    if (wp-&gt;w_vsep_width == 0) {</a>
<a name="ln3819">      if (wp-&gt;w_width &gt; 0) {            // don't make it negative</a>
<a name="ln3820">        wp-&gt;w_width--;</a>
<a name="ln3821">      }</a>
<a name="ln3822">      wp-&gt;w_vsep_width = 1;</a>
<a name="ln3823">    }</a>
<a name="ln3824">  } else if (frp-&gt;fr_layout == FR_COL) {</a>
<a name="ln3825">    // Handle all the frames in the column.</a>
<a name="ln3826">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3827">      frame_add_vsep(frp);</a>
<a name="ln3828">    }</a>
<a name="ln3829">  } else {</a>
<a name="ln3830">    assert(frp-&gt;fr_layout == FR_ROW);</a>
<a name="ln3831">    // Only need to handle the last frame in the row.</a>
<a name="ln3832">    frp = frp-&gt;fr_child;</a>
<a name="ln3833">    while (frp-&gt;fr_next != NULL) {</a>
<a name="ln3834">      frp = frp-&gt;fr_next;</a>
<a name="ln3835">    }</a>
<a name="ln3836">    frame_add_vsep(frp);</a>
<a name="ln3837">  }</a>
<a name="ln3838">}</a>
<a name="ln3839"> </a>
<a name="ln3840">/// Add the horizontal separator to windows at the bottom of &quot;frp&quot;.</a>
<a name="ln3841">/// Note: Does not check if there is room or whether the windows have a statusline!</a>
<a name="ln3842">static void frame_add_hsep(const frame_T *frp)</a>
<a name="ln3843">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3844">{</a>
<a name="ln3845">  if (frp-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln3846">    win_T *wp = frp-&gt;fr_win;</a>
<a name="ln3847">    wp-&gt;w_hsep_height = 1;</a>
<a name="ln3848">  } else if (frp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3849">    // Handle all the frames in the row.</a>
<a name="ln3850">    FOR_ALL_FRAMES(frp, frp-&gt;fr_child) {</a>
<a name="ln3851">      frame_add_hsep(frp);</a>
<a name="ln3852">    }</a>
<a name="ln3853">  } else {</a>
<a name="ln3854">    assert(frp-&gt;fr_layout == FR_COL);</a>
<a name="ln3855">    // Only need to handle the last frame in the column.</a>
<a name="ln3856">    frp = frp-&gt;fr_child;</a>
<a name="ln3857">    while (frp-&gt;fr_next != NULL) {</a>
<a name="ln3858">      frp = frp-&gt;fr_next;</a>
<a name="ln3859">    }</a>
<a name="ln3860">    frame_add_hsep(frp);</a>
<a name="ln3861">  }</a>
<a name="ln3862">}</a>
<a name="ln3863"> </a>
<a name="ln3864">// Set frame width from the window it contains.</a>
<a name="ln3865">static void frame_fix_width(win_T *wp)</a>
<a name="ln3866">{</a>
<a name="ln3867">  wp-&gt;w_frame-&gt;fr_width = wp-&gt;w_width + wp-&gt;w_vsep_width;</a>
<a name="ln3868">}</a>
<a name="ln3869"> </a>
<a name="ln3870">// Set frame height from the window it contains.</a>
<a name="ln3871">static void frame_fix_height(win_T *wp)</a>
<a name="ln3872">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3873">{</a>
<a name="ln3874">  wp-&gt;w_frame-&gt;fr_height = wp-&gt;w_height + wp-&gt;w_hsep_height + wp-&gt;w_status_height;</a>
<a name="ln3875">}</a>
<a name="ln3876"> </a>
<a name="ln3877">/// Compute the minimal height for frame &quot;topfrp&quot;. Uses the 'winminheight' option.</a>
<a name="ln3878">/// When &quot;next_curwin&quot; isn't NULL, use p_wh for this window.</a>
<a name="ln3879">/// When &quot;next_curwin&quot; is NOWIN, don't use at least one line for the current window.</a>
<a name="ln3880">static int frame_minheight(frame_T *topfrp, win_T *next_curwin)</a>
<a name="ln3881">{</a>
<a name="ln3882">  int m;</a>
<a name="ln3883"> </a>
<a name="ln3884">  if (topfrp-&gt;fr_win != NULL) {</a>
<a name="ln3885">    // Combined height of window bar and separator column or status line.</a>
<a name="ln3886">    int extra_height = topfrp-&gt;fr_win-&gt;w_winbar_height + topfrp-&gt;fr_win-&gt;w_hsep_height</a>
<a name="ln3887">                       + topfrp-&gt;fr_win-&gt;w_status_height;</a>
<a name="ln3888"> </a>
<a name="ln3889">    if (topfrp-&gt;fr_win == next_curwin) {</a>
<a name="ln3890">      m = (int)p_wh + extra_height;</a>
<a name="ln3891">    } else {</a>
<a name="ln3892">      m = (int)p_wmh + extra_height;</a>
<a name="ln3893">      if (topfrp-&gt;fr_win == curwin &amp;&amp; next_curwin == NULL) {</a>
<a name="ln3894">        // Current window is minimal one line high.</a>
<a name="ln3895">        if (p_wmh == 0) {</a>
<a name="ln3896">          m++;</a>
<a name="ln3897">        }</a>
<a name="ln3898">      }</a>
<a name="ln3899">    }</a>
<a name="ln3900">  } else if (topfrp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln3901">    // get the minimal height from each frame in this row</a>
<a name="ln3902">    m = 0;</a>
<a name="ln3903">    frame_T *frp;</a>
<a name="ln3904">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3905">      int n = frame_minheight(frp, next_curwin);</a>
<a name="ln3906">      if (n &gt; m) {</a>
<a name="ln3907">        m = n;</a>
<a name="ln3908">      }</a>
<a name="ln3909">    }</a>
<a name="ln3910">  } else {</a>
<a name="ln3911">    // Add up the minimal heights for all frames in this column.</a>
<a name="ln3912">    m = 0;</a>
<a name="ln3913">    frame_T *frp;</a>
<a name="ln3914">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3915">      m += frame_minheight(frp, next_curwin);</a>
<a name="ln3916">    }</a>
<a name="ln3917">  }</a>
<a name="ln3918"> </a>
<a name="ln3919">  return m;</a>
<a name="ln3920">}</a>
<a name="ln3921"> </a>
<a name="ln3922">/// Compute the minimal width for frame &quot;topfrp&quot;.</a>
<a name="ln3923">/// When &quot;next_curwin&quot; isn't NULL, use p_wiw for this window.</a>
<a name="ln3924">/// When &quot;next_curwin&quot; is NOWIN, don't use at least one column for the current</a>
<a name="ln3925">/// window.</a>
<a name="ln3926">///</a>
<a name="ln3927">/// @param next_curwin  use p_wh and p_wiw for next_curwin</a>
<a name="ln3928">static int frame_minwidth(frame_T *topfrp, win_T *next_curwin)</a>
<a name="ln3929">{</a>
<a name="ln3930">  int m;</a>
<a name="ln3931"> </a>
<a name="ln3932">  if (topfrp-&gt;fr_win != NULL) {</a>
<a name="ln3933">    if (topfrp-&gt;fr_win == next_curwin) {</a>
<a name="ln3934">      m = (int)p_wiw + topfrp-&gt;fr_win-&gt;w_vsep_width;</a>
<a name="ln3935">    } else {</a>
<a name="ln3936">      // window: minimal width of the window plus separator column</a>
<a name="ln3937">      m = (int)p_wmw + topfrp-&gt;fr_win-&gt;w_vsep_width;</a>
<a name="ln3938">      // Current window is minimal one column wide</a>
<a name="ln3939">      if (p_wmw == 0 &amp;&amp; topfrp-&gt;fr_win == curwin &amp;&amp; next_curwin == NULL) {</a>
<a name="ln3940">        m++;</a>
<a name="ln3941">      }</a>
<a name="ln3942">    }</a>
<a name="ln3943">  } else if (topfrp-&gt;fr_layout == FR_COL) {</a>
<a name="ln3944">    // get the minimal width from each frame in this column</a>
<a name="ln3945">    m = 0;</a>
<a name="ln3946">    frame_T *frp;</a>
<a name="ln3947">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3948">      int n = frame_minwidth(frp, next_curwin);</a>
<a name="ln3949">      if (n &gt; m) {</a>
<a name="ln3950">        m = n;</a>
<a name="ln3951">      }</a>
<a name="ln3952">    }</a>
<a name="ln3953">  } else {</a>
<a name="ln3954">    // Add up the minimal widths for all frames in this row.</a>
<a name="ln3955">    m = 0;</a>
<a name="ln3956">    frame_T *frp;</a>
<a name="ln3957">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln3958">      m += frame_minwidth(frp, next_curwin);</a>
<a name="ln3959">    }</a>
<a name="ln3960">  }</a>
<a name="ln3961"> </a>
<a name="ln3962">  return m;</a>
<a name="ln3963">}</a>
<a name="ln3964"> </a>
<a name="ln3965">/// Try to close all windows except current one.</a>
<a name="ln3966">/// Buffers in the other windows become hidden if 'hidden' is set, or '!' is</a>
<a name="ln3967">/// used and the buffer was modified.</a>
<a name="ln3968">///</a>
<a name="ln3969">/// Used by &quot;:bdel&quot; and &quot;:only&quot;.</a>
<a name="ln3970">///</a>
<a name="ln3971">/// @param forceit  always hide all other windows</a>
<a name="ln3972">void close_others(int message, int forceit)</a>
<a name="ln3973">{</a>
<a name="ln3974">  if (curwin-&gt;w_floating) {</a>
<a name="ln3975">    if (message &amp;&amp; !autocmd_busy) {</a>
<a name="ln3976">      emsg(e_floatonly);</a>
<a name="ln3977">    }</a>
<a name="ln3978">    return;</a>
<a name="ln3979">  }</a>
<a name="ln3980"> </a>
<a name="ln3981">  if (one_nonfloat() &amp;&amp; !lastwin-&gt;w_floating) {</a>
<a name="ln3982">    if (message</a>
<a name="ln3983">        &amp;&amp; !autocmd_busy) {</a>
<a name="ln3984">      msg(_(m_onlyone), 0);</a>
<a name="ln3985">    }</a>
<a name="ln3986">    return;</a>
<a name="ln3987">  }</a>
<a name="ln3988"> </a>
<a name="ln3989">  // Be very careful here: autocommands may change the window layout.</a>
<a name="ln3990">  win_T *nextwp;</a>
<a name="ln3991">  for (win_T *wp = firstwin; win_valid(wp); wp = nextwp) {</a>
<a name="ln3992">    nextwp = wp-&gt;w_next;</a>
<a name="ln3993">    if (wp == curwin) {                 // don't close current window</a>
<a name="ln3994">      continue;</a>
<a name="ln3995">    }</a>
<a name="ln3996"> </a>
<a name="ln3997">    // Check if it's allowed to abandon this window</a>
<a name="ln3998">    int r = can_abandon(wp-&gt;w_buffer, forceit);</a>
<a name="ln3999">    if (!win_valid(wp)) {             // autocommands messed wp up</a>
<a name="ln4000">      nextwp = firstwin;</a>
<a name="ln4001">      continue;</a>
<a name="ln4002">    }</a>
<a name="ln4003">    if (!r) {</a>
<a name="ln4004">      if (message &amp;&amp; (p_confirm || (cmdmod.cmod_flags &amp; CMOD_CONFIRM)) &amp;&amp; p_write) {</a>
<a name="ln4005">        dialog_changed(wp-&gt;w_buffer, false);</a>
<a name="ln4006">        if (!win_valid(wp)) {                 // autocommands messed wp up</a>
<a name="ln4007">          nextwp = firstwin;</a>
<a name="ln4008">          continue;</a>
<a name="ln4009">        }</a>
<a name="ln4010">      }</a>
<a name="ln4011">      if (bufIsChanged(wp-&gt;w_buffer)) {</a>
<a name="ln4012">        continue;</a>
<a name="ln4013">      }</a>
<a name="ln4014">    }</a>
<a name="ln4015">    win_close(wp, !buf_hide(wp-&gt;w_buffer) &amp;&amp; !bufIsChanged(wp-&gt;w_buffer), false);</a>
<a name="ln4016">  }</a>
<a name="ln4017"> </a>
<a name="ln4018">  if (message &amp;&amp; !ONE_WINDOW) {</a>
<a name="ln4019">    emsg(_(&quot;E445: Other window contains changes&quot;));</a>
<a name="ln4020">  }</a>
<a name="ln4021">}</a>
<a name="ln4022"> </a>
<a name="ln4023">/// Store the relevant window pointers for tab page &quot;tp&quot;.  To be used before</a>
<a name="ln4024">/// use_tabpage().</a>
<a name="ln4025">void unuse_tabpage(tabpage_T *tp)</a>
<a name="ln4026">{</a>
<a name="ln4027">  tp-&gt;tp_topframe = topframe;</a>
<a name="ln4028">  tp-&gt;tp_firstwin = firstwin;</a>
<a name="ln4029">  tp-&gt;tp_lastwin = lastwin;</a>
<a name="ln4030">  tp-&gt;tp_curwin = curwin;</a>
<a name="ln4031">}</a>
<a name="ln4032"> </a>
<a name="ln4033">/// Set the relevant pointers to use tab page &quot;tp&quot;.  May want to call</a>
<a name="ln4034">/// unuse_tabpage() first.</a>
<a name="ln4035">void use_tabpage(tabpage_T *tp)</a>
<a name="ln4036">{</a>
<a name="ln4037">  curtab = tp;</a>
<a name="ln4038">  topframe = curtab-&gt;tp_topframe;</a>
<a name="ln4039">  firstwin = curtab-&gt;tp_firstwin;</a>
<a name="ln4040">  lastwin = curtab-&gt;tp_lastwin;</a>
<a name="ln4041">  curwin = curtab-&gt;tp_curwin;</a>
<a name="ln4042">}</a>
<a name="ln4043"> </a>
<a name="ln4044">// Allocate the first window and put an empty buffer in it.</a>
<a name="ln4045">// Only called from main().</a>
<a name="ln4046">void win_alloc_first(void)</a>
<a name="ln4047">{</a>
<a name="ln4048">  if (win_alloc_firstwin(NULL) == FAIL) {</a>
<a name="ln4049">    // allocating first buffer before any autocmds should not fail.</a>
<a name="ln4050">    abort();</a>
<a name="ln4051">  }</a>
<a name="ln4052"> </a>
<a name="ln4053">  first_tabpage = alloc_tabpage();</a>
<a name="ln4054">  curtab = first_tabpage;</a>
<a name="ln4055">  unuse_tabpage(first_tabpage);</a>
<a name="ln4056">}</a>
<a name="ln4057"> </a>
<a name="ln4058">// Init `aucmd_win[idx]`. This can only be done after the first window</a>
<a name="ln4059">// is fully initialized, thus it can't be in win_alloc_first().</a>
<a name="ln4060">void win_alloc_aucmd_win(int idx)</a>
<a name="ln4061">{</a>
<a name="ln4062">  Error err = ERROR_INIT;</a>
<a name="ln4063">  FloatConfig fconfig = FLOAT_CONFIG_INIT;</a>
<a name="ln4064">  fconfig.width = Columns;</a>
<a name="ln4065">  fconfig.height = 5;</a>
<a name="ln4066">  fconfig.focusable = false;</a>
<a name="ln4067">  aucmd_win[idx].auc_win = win_new_float(NULL, true, fconfig, &amp;err);</a>
<a name="ln4068">  aucmd_win[idx].auc_win-&gt;w_buffer-&gt;b_nwindows--;</a>
<a name="ln4069">  RESET_BINDING(aucmd_win[idx].auc_win);</a>
<a name="ln4070">}</a>
<a name="ln4071"> </a>
<a name="ln4072">// Allocate the first window or the first window in a new tab page.</a>
<a name="ln4073">// When &quot;oldwin&quot; is NULL create an empty buffer for it.</a>
<a name="ln4074">// When &quot;oldwin&quot; is not NULL copy info from it to the new window.</a>
<a name="ln4075">// Return FAIL when something goes wrong (out of memory).</a>
<a name="ln4076">static int win_alloc_firstwin(win_T *oldwin)</a>
<a name="ln4077">{</a>
<a name="ln4078">  curwin = win_alloc(NULL, false);</a>
<a name="ln4079">  if (oldwin == NULL) {</a>
<a name="ln4080">    // Very first window, need to create an empty buffer for it and</a>
<a name="ln4081">    // initialize from scratch.</a>
<a name="ln4082">    curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);</a>
<a name="ln4083">    if (curbuf == NULL) {</a>
<a name="ln4084">      return FAIL;</a>
<a name="ln4085">    }</a>
<a name="ln4086">    curwin-&gt;w_buffer = curbuf;</a>
<a name="ln4087">    curwin-&gt;w_s = &amp;(curbuf-&gt;b_s);</a>
<a name="ln4088">    curbuf-&gt;b_nwindows = 1;     // there is one window</a>
<a name="ln4089">    curwin-&gt;w_alist = &amp;global_alist;</a>
<a name="ln4090">    curwin_init();              // init current window</a>
<a name="ln4091">  } else {</a>
<a name="ln4092">    // First window in new tab page, initialize it from &quot;oldwin&quot;.</a>
<a name="ln4093">    win_init(curwin, oldwin, 0);</a>
<a name="ln4094"> </a>
<a name="ln4095">    // We don't want cursor- and scroll-binding in the first window.</a>
<a name="ln4096">    RESET_BINDING(curwin);</a>
<a name="ln4097">  }</a>
<a name="ln4098"> </a>
<a name="ln4099">  new_frame(curwin);</a>
<a name="ln4100">  topframe = curwin-&gt;w_frame;</a>
<a name="ln4101">  topframe-&gt;fr_width = Columns;</a>
<a name="ln4102">  topframe-&gt;fr_height = Rows - (int)p_ch - global_stl_height();</a>
<a name="ln4103"> </a>
<a name="ln4104">  return OK;</a>
<a name="ln4105">}</a>
<a name="ln4106"> </a>
<a name="ln4107">// Create a frame for window &quot;wp&quot;.</a>
<a name="ln4108">static void new_frame(win_T *wp)</a>
<a name="ln4109">{</a>
<a name="ln4110">  frame_T *frp = xcalloc(1, sizeof(frame_T));</a>
<a name="ln4111"> </a>
<a name="ln4112">  wp-&gt;w_frame = frp;</a>
<a name="ln4113">  frp-&gt;fr_layout = FR_LEAF;</a>
<a name="ln4114">  frp-&gt;fr_win = wp;</a>
<a name="ln4115">}</a>
<a name="ln4116"> </a>
<a name="ln4117">// Initialize the window and frame size to the maximum.</a>
<a name="ln4118">void win_init_size(void)</a>
<a name="ln4119">{</a>
<a name="ln4120">  firstwin-&gt;w_height = (int)ROWS_AVAIL;</a>
<a name="ln4121">  firstwin-&gt;w_prev_height = (int)ROWS_AVAIL;</a>
<a name="ln4122">  firstwin-&gt;w_height_inner = firstwin-&gt;w_height - firstwin-&gt;w_winbar_height;</a>
<a name="ln4123">  firstwin-&gt;w_height_outer = firstwin-&gt;w_height;</a>
<a name="ln4124">  firstwin-&gt;w_winrow_off = firstwin-&gt;w_winbar_height;</a>
<a name="ln4125">  topframe-&gt;fr_height = (int)ROWS_AVAIL;</a>
<a name="ln4126">  firstwin-&gt;w_width = Columns;</a>
<a name="ln4127">  firstwin-&gt;w_width_inner = firstwin-&gt;w_width;</a>
<a name="ln4128">  firstwin-&gt;w_width_outer = firstwin-&gt;w_width;</a>
<a name="ln4129">  topframe-&gt;fr_width = Columns;</a>
<a name="ln4130">}</a>
<a name="ln4131"> </a>
<a name="ln4132">// Allocate a new tabpage_T and init the values.</a>
<a name="ln4133">static tabpage_T *alloc_tabpage(void)</a>
<a name="ln4134">{</a>
<a name="ln4135">  static int last_tp_handle = 0;</a>
<a name="ln4136">  tabpage_T *tp = xcalloc(1, sizeof(tabpage_T));</a>
<a name="ln4137">  tp-&gt;handle = ++last_tp_handle;</a>
<a name="ln4138">  pmap_put(int)(&amp;tabpage_handles, tp-&gt;handle, tp);</a>
<a name="ln4139"> </a>
<a name="ln4140">  // Init t: variables.</a>
<a name="ln4141">  tp-&gt;tp_vars = tv_dict_alloc();</a>
<a name="ln4142">  init_var_dict(tp-&gt;tp_vars, &amp;tp-&gt;tp_winvar, VAR_SCOPE);</a>
<a name="ln4143">  tp-&gt;tp_diff_invalid = true;</a>
<a name="ln4144">  tp-&gt;tp_ch_used = p_ch;</a>
<a name="ln4145"> </a>
<a name="ln4146">  return tp;</a>
<a name="ln4147">}</a>
<a name="ln4148"> </a>
<a name="ln4149">void free_tabpage(tabpage_T *tp)</a>
<a name="ln4150">{</a>
<a name="ln4151">  pmap_del(int)(&amp;tabpage_handles, tp-&gt;handle, NULL);</a>
<a name="ln4152">  diff_clear(tp);</a>
<a name="ln4153">  for (int idx = 0; idx &lt; SNAP_COUNT; idx++) {</a>
<a name="ln4154">    clear_snapshot(tp, idx);</a>
<a name="ln4155">  }</a>
<a name="ln4156">  vars_clear(&amp;tp-&gt;tp_vars-&gt;dv_hashtab);         // free all t: variables</a>
<a name="ln4157">  hash_init(&amp;tp-&gt;tp_vars-&gt;dv_hashtab);</a>
<a name="ln4158">  unref_var_dict(tp-&gt;tp_vars);</a>
<a name="ln4159"> </a>
<a name="ln4160">  if (tp == lastused_tabpage) {</a>
<a name="ln4161">    lastused_tabpage = NULL;</a>
<a name="ln4162">  }</a>
<a name="ln4163"> </a>
<a name="ln4164">  xfree(tp-&gt;tp_localdir);</a>
<a name="ln4165">  xfree(tp-&gt;tp_prevdir);</a>
<a name="ln4166">  xfree(tp);</a>
<a name="ln4167">}</a>
<a name="ln4168"> </a>
<a name="ln4169">/// Create a new tabpage with one window.</a>
<a name="ln4170">///</a>
<a name="ln4171">/// It will edit the current buffer, like after :split.</a>
<a name="ln4172">///</a>
<a name="ln4173">/// @param after Put new tabpage after tabpage &quot;after&quot;, or after the current</a>
<a name="ln4174">///              tabpage in case of 0.</a>
<a name="ln4175">/// @param filename Will be passed to apply_autocmds().</a>
<a name="ln4176">/// @return Was the new tabpage created successfully? FAIL or OK.</a>
<a name="ln4177">int win_new_tabpage(int after, char *filename)</a>
<a name="ln4178">{</a>
<a name="ln4179">  tabpage_T *old_curtab = curtab;</a>
<a name="ln4180"> </a>
<a name="ln4181">  if (cmdwin_type != 0) {</a>
<a name="ln4182">    emsg(_(e_cmdwin));</a>
<a name="ln4183">    return FAIL;</a>
<a name="ln4184">  }</a>
<a name="ln4185"> </a>
<a name="ln4186">  tabpage_T *newtp = alloc_tabpage();</a>
<a name="ln4187"> </a>
<a name="ln4188">  // Remember the current windows in this Tab page.</a>
<a name="ln4189">  if (leave_tabpage(curbuf, true) == FAIL) {</a>
<a name="ln4190">    xfree(newtp);</a>
<a name="ln4191">    return FAIL;</a>
<a name="ln4192">  }</a>
<a name="ln4193"> </a>
<a name="ln4194">  newtp-&gt;tp_localdir = old_curtab-&gt;tp_localdir</a>
<a name="ln4195">    ? xstrdup(old_curtab-&gt;tp_localdir) : NULL;</a>
<a name="ln4196"> </a>
<a name="ln4197">  curtab = newtp;</a>
<a name="ln4198"> </a>
<a name="ln4199">  // Create a new empty window.</a>
<a name="ln4200">  if (win_alloc_firstwin(old_curtab-&gt;tp_curwin) == OK) {</a>
<a name="ln4201">    // Make the new Tab page the new topframe.</a>
<a name="ln4202">    if (after == 1) {</a>
<a name="ln4203">      // New tab page becomes the first one.</a>
<a name="ln4204">      newtp-&gt;tp_next = first_tabpage;</a>
<a name="ln4205">      first_tabpage = newtp;</a>
<a name="ln4206">    } else {</a>
<a name="ln4207">      tabpage_T *tp = old_curtab;</a>
<a name="ln4208"> </a>
<a name="ln4209">      if (after &gt; 0) {</a>
<a name="ln4210">        // Put new tab page before tab page &quot;after&quot;.</a>
<a name="ln4211">        int n = 2;</a>
<a name="ln4212">        for (tp = first_tabpage; tp-&gt;tp_next != NULL</a>
<a name="ln4213">             &amp;&amp; n &lt; after; tp = tp-&gt;tp_next) {</a>
<a name="ln4214">          n++;</a>
<a name="ln4215">        }</a>
<a name="ln4216">      }</a>
<a name="ln4217">      newtp-&gt;tp_next = tp-&gt;tp_next;</a>
<a name="ln4218">      tp-&gt;tp_next = newtp;</a>
<a name="ln4219">    }</a>
<a name="ln4220">    newtp-&gt;tp_firstwin = newtp-&gt;tp_lastwin = newtp-&gt;tp_curwin = curwin;</a>
<a name="ln4221"> </a>
<a name="ln4222">    win_init_size();</a>
<a name="ln4223">    firstwin-&gt;w_winrow = tabline_height();</a>
<a name="ln4224">    firstwin-&gt;w_prev_winrow = firstwin-&gt;w_winrow;</a>
<a name="ln4225">    win_comp_scroll(curwin);</a>
<a name="ln4226"> </a>
<a name="ln4227">    newtp-&gt;tp_topframe = topframe;</a>
<a name="ln4228">    last_status(false);</a>
<a name="ln4229"> </a>
<a name="ln4230">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln4231"> </a>
<a name="ln4232">    tabpage_check_windows(old_curtab);</a>
<a name="ln4233"> </a>
<a name="ln4234">    lastused_tabpage = old_curtab;</a>
<a name="ln4235"> </a>
<a name="ln4236">    entering_window(curwin);</a>
<a name="ln4237"> </a>
<a name="ln4238">    apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf);</a>
<a name="ln4239">    apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4240">    apply_autocmds(EVENT_TABNEW, filename, filename, false, curbuf);</a>
<a name="ln4241">    apply_autocmds(EVENT_TABENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4242"> </a>
<a name="ln4243">    return OK;</a>
<a name="ln4244">  }</a>
<a name="ln4245"> </a>
<a name="ln4246">  // Failed, get back the previous Tab page</a>
<a name="ln4247">  enter_tabpage(curtab, curbuf, true, true);</a>
<a name="ln4248">  return FAIL;</a>
<a name="ln4249">}</a>
<a name="ln4250"> </a>
<a name="ln4251">// Open a new tab page if &quot;:tab cmd&quot; was used.  It will edit the same buffer,</a>
<a name="ln4252">// like with &quot;:split&quot;.</a>
<a name="ln4253">// Returns OK if a new tab page was created, FAIL otherwise.</a>
<a name="ln4254">int may_open_tabpage(void)</a>
<a name="ln4255">{</a>
<a name="ln4256">  int n = (cmdmod.cmod_tab == 0) ? postponed_split_tab : cmdmod.cmod_tab;</a>
<a name="ln4257"> </a>
<a name="ln4258">  if (n == 0) {</a>
<a name="ln4259">    return FAIL;</a>
<a name="ln4260">  }</a>
<a name="ln4261"> </a>
<a name="ln4262">  cmdmod.cmod_tab = 0;         // reset it to avoid doing it twice</a>
<a name="ln4263">  postponed_split_tab = 0;</a>
<a name="ln4264">  return win_new_tabpage(n, NULL);</a>
<a name="ln4265">}</a>
<a name="ln4266"> </a>
<a name="ln4267">// Create up to &quot;maxcount&quot; tabpages with empty windows.</a>
<a name="ln4268">// Returns the number of resulting tab pages.</a>
<a name="ln4269">int make_tabpages(int maxcount)</a>
<a name="ln4270">{</a>
<a name="ln4271">  int count = maxcount;</a>
<a name="ln4272"> </a>
<a name="ln4273">  // Limit to 'tabpagemax' tabs.</a>
<a name="ln4274">  if (count &gt; p_tpm) {</a>
<a name="ln4275">    count = (int)p_tpm;</a>
<a name="ln4276">  }</a>
<a name="ln4277"> </a>
<a name="ln4278">  // Don't execute autocommands while creating the tab pages.  Must do that</a>
<a name="ln4279">  // when putting the buffers in the windows.</a>
<a name="ln4280">  block_autocmds();</a>
<a name="ln4281"> </a>
<a name="ln4282">  int todo;</a>
<a name="ln4283">  for (todo = count - 1; todo &gt; 0; todo--) {</a>
<a name="ln4284">    if (win_new_tabpage(0, NULL) == FAIL) {</a>
<a name="ln4285">      break;</a>
<a name="ln4286">    }</a>
<a name="ln4287">  }</a>
<a name="ln4288"> </a>
<a name="ln4289">  unblock_autocmds();</a>
<a name="ln4290"> </a>
<a name="ln4291">  // return actual number of tab pages</a>
<a name="ln4292">  return count - todo;</a>
<a name="ln4293">}</a>
<a name="ln4294"> </a>
<a name="ln4295">/// Check that tpc points to a valid tab page.</a>
<a name="ln4296">///</a>
<a name="ln4297">/// @param[in]  tpc  Tabpage to check.</a>
<a name="ln4298">bool valid_tabpage(tabpage_T *tpc) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln4299">{</a>
<a name="ln4300">  FOR_ALL_TABS(tp) {</a>
<a name="ln4301">    if (tp == tpc) {</a>
<a name="ln4302">      return true;</a>
<a name="ln4303">    }</a>
<a name="ln4304">  }</a>
<a name="ln4305">  return false;</a>
<a name="ln4306">}</a>
<a name="ln4307"> </a>
<a name="ln4308">/// Returns true when `tpc` is valid and at least one window is valid.</a>
<a name="ln4309">int valid_tabpage_win(tabpage_T *tpc)</a>
<a name="ln4310">{</a>
<a name="ln4311">  FOR_ALL_TABS(tp) {</a>
<a name="ln4312">    if (tp == tpc) {</a>
<a name="ln4313">      FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln4314">        if (win_valid_any_tab(wp)) {</a>
<a name="ln4315">          return true;</a>
<a name="ln4316">        }</a>
<a name="ln4317">      }</a>
<a name="ln4318">      return false;</a>
<a name="ln4319">    }</a>
<a name="ln4320">  }</a>
<a name="ln4321">  // shouldn't happen</a>
<a name="ln4322">  return false;</a>
<a name="ln4323">}</a>
<a name="ln4324"> </a>
<a name="ln4325">/// Close tabpage `tab`, assuming it has no windows in it.</a>
<a name="ln4326">/// There must be another tabpage or this will crash.</a>
<a name="ln4327">void close_tabpage(tabpage_T *tab)</a>
<a name="ln4328">{</a>
<a name="ln4329">  tabpage_T *ptp;</a>
<a name="ln4330"> </a>
<a name="ln4331">  if (tab == first_tabpage) {</a>
<a name="ln4332">    first_tabpage = tab-&gt;tp_next;</a>
<a name="ln4333">    ptp = first_tabpage;</a>
<a name="ln4334">  } else {</a>
<a name="ln4335">    for (ptp = first_tabpage; ptp != NULL &amp;&amp; ptp-&gt;tp_next != tab;</a>
<a name="ln4336">         ptp = ptp-&gt;tp_next) {</a>
<a name="ln4337">      // do nothing</a>
<a name="ln4338">    }</a>
<a name="ln4339">    assert(ptp != NULL);</a>
<a name="ln4340">    ptp-&gt;tp_next = tab-&gt;tp_next;</a>
<a name="ln4341">  }</a>
<a name="ln4342"> </a>
<a name="ln4343">  goto_tabpage_tp(ptp, false, false);</a>
<a name="ln4344">  free_tabpage(tab);</a>
<a name="ln4345">}</a>
<a name="ln4346"> </a>
<a name="ln4347">// Find tab page &quot;n&quot; (first one is 1).  Returns NULL when not found.</a>
<a name="ln4348">tabpage_T *find_tabpage(int n)</a>
<a name="ln4349">{</a>
<a name="ln4350">  tabpage_T *tp;</a>
<a name="ln4351">  int i = 1;</a>
<a name="ln4352"> </a>
<a name="ln4353">  for (tp = first_tabpage; tp != NULL &amp;&amp; i != n; tp = tp-&gt;tp_next) {</a>
<a name="ln4354">    i++;</a>
<a name="ln4355">  }</a>
<a name="ln4356">  return tp;</a>
<a name="ln4357">}</a>
<a name="ln4358"> </a>
<a name="ln4359">// Get index of tab page &quot;tp&quot;.  First one has index 1.</a>
<a name="ln4360">// When not found returns number of tab pages plus one.</a>
<a name="ln4361">int tabpage_index(tabpage_T *ftp)</a>
<a name="ln4362">{</a>
<a name="ln4363">  int i = 1;</a>
<a name="ln4364">  tabpage_T *tp;</a>
<a name="ln4365"> </a>
<a name="ln4366">  for (tp = first_tabpage; tp != NULL &amp;&amp; tp != ftp; tp = tp-&gt;tp_next) {</a>
<a name="ln4367">    i++;</a>
<a name="ln4368">  }</a>
<a name="ln4369">  return i;</a>
<a name="ln4370">}</a>
<a name="ln4371"> </a>
<a name="ln4372">/// Prepare for leaving the current tab page.</a>
<a name="ln4373">/// When autocommands change &quot;curtab&quot; we don't leave the tab page and return</a>
<a name="ln4374">/// FAIL.</a>
<a name="ln4375">/// Careful: When OK is returned need to get a new tab page very very soon!</a>
<a name="ln4376">///</a>
<a name="ln4377">/// @param new_curbuf              what is going to be the new curbuf,</a>
<a name="ln4378">///                                NULL if unknown.</a>
<a name="ln4379">/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.</a>
<a name="ln4380">static int leave_tabpage(buf_T *new_curbuf, bool trigger_leave_autocmds)</a>
<a name="ln4381">{</a>
<a name="ln4382">  tabpage_T *tp = curtab;</a>
<a name="ln4383"> </a>
<a name="ln4384">  leaving_window(curwin);</a>
<a name="ln4385">  reset_VIsual_and_resel();     // stop Visual mode</a>
<a name="ln4386">  if (trigger_leave_autocmds) {</a>
<a name="ln4387">    if (new_curbuf != curbuf) {</a>
<a name="ln4388">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln4389">      if (curtab != tp) {</a>
<a name="ln4390">        return FAIL;</a>
<a name="ln4391">      }</a>
<a name="ln4392">    }</a>
<a name="ln4393">    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln4394">    if (curtab != tp) {</a>
<a name="ln4395">      return FAIL;</a>
<a name="ln4396">    }</a>
<a name="ln4397">    apply_autocmds(EVENT_TABLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln4398">    if (curtab != tp) {</a>
<a name="ln4399">      return FAIL;</a>
<a name="ln4400">    }</a>
<a name="ln4401">  }</a>
<a name="ln4402"> </a>
<a name="ln4403">  reset_dragwin();</a>
<a name="ln4404">  tp-&gt;tp_curwin = curwin;</a>
<a name="ln4405">  tp-&gt;tp_prevwin = prevwin;</a>
<a name="ln4406">  tp-&gt;tp_firstwin = firstwin;</a>
<a name="ln4407">  tp-&gt;tp_lastwin = lastwin;</a>
<a name="ln4408">  tp-&gt;tp_old_Rows_avail = ROWS_AVAIL;</a>
<a name="ln4409">  if (tp-&gt;tp_old_Columns != -1) {</a>
<a name="ln4410">    tp-&gt;tp_old_Columns = Columns;</a>
<a name="ln4411">  }</a>
<a name="ln4412">  firstwin = NULL;</a>
<a name="ln4413">  lastwin = NULL;</a>
<a name="ln4414">  return OK;</a>
<a name="ln4415">}</a>
<a name="ln4416"> </a>
<a name="ln4417">/// Start using tab page &quot;tp&quot;.</a>
<a name="ln4418">/// Only to be used after leave_tabpage() or freeing the current tab page.</a>
<a name="ln4419">///</a>
<a name="ln4420">/// @param trigger_enter_autocmds  when true trigger *Enter autocommands.</a>
<a name="ln4421">/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.</a>
<a name="ln4422">static void enter_tabpage(tabpage_T *tp, buf_T *old_curbuf, bool trigger_enter_autocmds,</a>
<a name="ln4423">                          bool trigger_leave_autocmds)</a>
<a name="ln4424">{</a>
<a name="ln4425">  int old_off = tp-&gt;tp_firstwin-&gt;w_winrow;</a>
<a name="ln4426">  win_T *next_prevwin = tp-&gt;tp_prevwin;</a>
<a name="ln4427">  tabpage_T *old_curtab = curtab;</a>
<a name="ln4428"> </a>
<a name="ln4429">  use_tabpage(tp);</a>
<a name="ln4430"> </a>
<a name="ln4431">  if (old_curtab != curtab) {</a>
<a name="ln4432">    tabpage_check_windows(old_curtab);</a>
<a name="ln4433">  }</a>
<a name="ln4434"> </a>
<a name="ln4435">  // We would like doing the TabEnter event first, but we don't have a</a>
<a name="ln4436">  // valid current window yet, which may break some commands.</a>
<a name="ln4437">  // This triggers autocommands, thus may make &quot;tp&quot; invalid.</a>
<a name="ln4438">  win_enter_ext(tp-&gt;tp_curwin, WEE_CURWIN_INVALID</a>
<a name="ln4439">                | (trigger_enter_autocmds ? WEE_TRIGGER_ENTER_AUTOCMDS : 0)</a>
<a name="ln4440">                | (trigger_leave_autocmds ? WEE_TRIGGER_LEAVE_AUTOCMDS : 0));</a>
<a name="ln4441">  prevwin = next_prevwin;</a>
<a name="ln4442"> </a>
<a name="ln4443">  last_status(false);  // status line may appear or disappear</a>
<a name="ln4444">  const int row = win_comp_pos();  // recompute w_winrow for all windows</a>
<a name="ln4445">  diff_need_scrollbind = true;</a>
<a name="ln4446"> </a>
<a name="ln4447">  // Use the stored value of p_ch, so that it can be different for each tab page.</a>
<a name="ln4448">  if (p_ch != curtab-&gt;tp_ch_used) {</a>
<a name="ln4449">    clear_cmdline = true;</a>
<a name="ln4450">    if (msg_grid.chars &amp;&amp; p_ch &lt; curtab-&gt;tp_ch_used) {</a>
<a name="ln4451">      // TODO(bfredl): a bit expensive, should be enough to invalidate the</a>
<a name="ln4452">      // region between the old and the new p_ch.</a>
<a name="ln4453">      grid_invalidate(&amp;msg_grid);</a>
<a name="ln4454">    }</a>
<a name="ln4455">  }</a>
<a name="ln4456">  p_ch = curtab-&gt;tp_ch_used;</a>
<a name="ln4457"> </a>
<a name="ln4458">  // When cmdheight is changed in a tab page with '&lt;C-w&gt;-', cmdline_row is</a>
<a name="ln4459">  // changed but p_ch and tp_ch_used are not changed. Thus we also need to</a>
<a name="ln4460">  // check cmdline_row.</a>
<a name="ln4461">  if (row &lt; cmdline_row &amp;&amp; cmdline_row &lt;= Rows - p_ch) {</a>
<a name="ln4462">    clear_cmdline = true;</a>
<a name="ln4463">  }</a>
<a name="ln4464"> </a>
<a name="ln4465">  // If there was a click in a window, it won't be usable for a following</a>
<a name="ln4466">  // drag.</a>
<a name="ln4467">  reset_dragwin();</a>
<a name="ln4468"> </a>
<a name="ln4469">  // The tabpage line may have appeared or disappeared, may need to resize the frames for that.</a>
<a name="ln4470">  // When the Vim window was resized or ROWS_AVAIL changed need to update frame sizes too.</a>
<a name="ln4471">  if (curtab-&gt;tp_old_Rows_avail != ROWS_AVAIL || (old_off != firstwin-&gt;w_winrow)) {</a>
<a name="ln4472">    win_new_screen_rows();</a>
<a name="ln4473">  }</a>
<a name="ln4474">  if (curtab-&gt;tp_old_Columns != Columns) {</a>
<a name="ln4475">    if (starting == 0) {</a>
<a name="ln4476">      win_new_screen_cols();  // update window widths</a>
<a name="ln4477">      curtab-&gt;tp_old_Columns = Columns;</a>
<a name="ln4478">    } else {</a>
<a name="ln4479">      curtab-&gt;tp_old_Columns = -1;  // update window widths later</a>
<a name="ln4480">    }</a>
<a name="ln4481">  }</a>
<a name="ln4482"> </a>
<a name="ln4483">  lastused_tabpage = old_curtab;</a>
<a name="ln4484"> </a>
<a name="ln4485">  // Apply autocommands after updating the display, when 'rows' and</a>
<a name="ln4486">  // 'columns' have been set correctly.</a>
<a name="ln4487">  if (trigger_enter_autocmds) {</a>
<a name="ln4488">    apply_autocmds(EVENT_TABENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4489">    if (old_curbuf != curbuf) {</a>
<a name="ln4490">      apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4491">    }</a>
<a name="ln4492">  }</a>
<a name="ln4493"> </a>
<a name="ln4494">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln4495">}</a>
<a name="ln4496"> </a>
<a name="ln4497">/// tells external UI that windows and inline floats in old_curtab are invisible</a>
<a name="ln4498">/// and that floats in curtab is now visible.</a>
<a name="ln4499">///</a>
<a name="ln4500">/// External floats are considered independent of tabpages. This is</a>
<a name="ln4501">/// implemented by always moving them to curtab.</a>
<a name="ln4502">static void tabpage_check_windows(tabpage_T *old_curtab)</a>
<a name="ln4503">{</a>
<a name="ln4504">  win_T *next_wp;</a>
<a name="ln4505">  for (win_T *wp = old_curtab-&gt;tp_firstwin; wp; wp = next_wp) {</a>
<a name="ln4506">    next_wp = wp-&gt;w_next;</a>
<a name="ln4507">    if (wp-&gt;w_floating) {</a>
<a name="ln4508">      if (wp-&gt;w_float_config.external) {</a>
<a name="ln4509">        win_remove(wp, old_curtab);</a>
<a name="ln4510">        win_append(lastwin_nofloating(), wp);</a>
<a name="ln4511">      } else {</a>
<a name="ln4512">        ui_comp_remove_grid(&amp;wp-&gt;w_grid_alloc);</a>
<a name="ln4513">      }</a>
<a name="ln4514">    }</a>
<a name="ln4515">    wp-&gt;w_pos_changed = true;</a>
<a name="ln4516">  }</a>
<a name="ln4517"> </a>
<a name="ln4518">  for (win_T *wp = firstwin; wp; wp = wp-&gt;w_next) {</a>
<a name="ln4519">    if (wp-&gt;w_floating &amp;&amp; !wp-&gt;w_float_config.external) {</a>
<a name="ln4520">      win_config_float(wp, wp-&gt;w_float_config);</a>
<a name="ln4521">    }</a>
<a name="ln4522">    wp-&gt;w_pos_changed = true;</a>
<a name="ln4523">  }</a>
<a name="ln4524">}</a>
<a name="ln4525"> </a>
<a name="ln4526">// Go to tab page &quot;n&quot;.  For &quot;:tab N&quot; and &quot;Ngt&quot;.</a>
<a name="ln4527">// When &quot;n&quot; is 9999 go to the last tab page.</a>
<a name="ln4528">void goto_tabpage(int n)</a>
<a name="ln4529">{</a>
<a name="ln4530">  if (text_locked()) {</a>
<a name="ln4531">    // Not allowed when editing the command line.</a>
<a name="ln4532">    text_locked_msg();</a>
<a name="ln4533">    return;</a>
<a name="ln4534">  }</a>
<a name="ln4535"> </a>
<a name="ln4536">  // If there is only one it can't work.</a>
<a name="ln4537">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4538">    if (n &gt; 1) {</a>
<a name="ln4539">      beep_flush();</a>
<a name="ln4540">    }</a>
<a name="ln4541">    return;</a>
<a name="ln4542">  }</a>
<a name="ln4543"> </a>
<a name="ln4544">  tabpage_T *tp = NULL;  // shut up compiler</a>
<a name="ln4545"> </a>
<a name="ln4546">  if (n == 0) {</a>
<a name="ln4547">    // No count, go to next tab page, wrap around end.</a>
<a name="ln4548">    if (curtab-&gt;tp_next == NULL) {</a>
<a name="ln4549">      tp = first_tabpage;</a>
<a name="ln4550">    } else {</a>
<a name="ln4551">      tp = curtab-&gt;tp_next;</a>
<a name="ln4552">    }</a>
<a name="ln4553">  } else if (n &lt; 0) {</a>
<a name="ln4554">    // &quot;gT&quot;: go to previous tab page, wrap around end.  &quot;N gT&quot; repeats</a>
<a name="ln4555">    // this N times.</a>
<a name="ln4556">    tabpage_T *ttp = curtab;</a>
<a name="ln4557">    for (int i = n; i &lt; 0; i++) {</a>
<a name="ln4558">      for (tp = first_tabpage; tp-&gt;tp_next != ttp &amp;&amp; tp-&gt;tp_next != NULL;</a>
<a name="ln4559">           tp = tp-&gt;tp_next) {}</a>
<a name="ln4560">      ttp = tp;</a>
<a name="ln4561">    }</a>
<a name="ln4562">  } else if (n == 9999) {</a>
<a name="ln4563">    // Go to last tab page.</a>
<a name="ln4564">    for (tp = first_tabpage; tp-&gt;tp_next != NULL; tp = tp-&gt;tp_next) {}</a>
<a name="ln4565">  } else {</a>
<a name="ln4566">    // Go to tab page &quot;n&quot;.</a>
<a name="ln4567">    tp = find_tabpage(n);</a>
<a name="ln4568">    if (tp == NULL) {</a>
<a name="ln4569">      beep_flush();</a>
<a name="ln4570">      return;</a>
<a name="ln4571">    }</a>
<a name="ln4572">  }</a>
<a name="ln4573"> </a>
<a name="ln4574">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln4575">}</a>
<a name="ln4576"> </a>
<a name="ln4577">/// Go to tabpage &quot;tp&quot;.</a>
<a name="ln4578">/// Note: doesn't update the GUI tab.</a>
<a name="ln4579">///</a>
<a name="ln4580">/// @param trigger_enter_autocmds  when true trigger *Enter autocommands.</a>
<a name="ln4581">/// @param trigger_leave_autocmds  when true trigger *Leave autocommands.</a>
<a name="ln4582">void goto_tabpage_tp(tabpage_T *tp, bool trigger_enter_autocmds, bool trigger_leave_autocmds)</a>
<a name="ln4583">{</a>
<a name="ln4584">  if (trigger_enter_autocmds || trigger_leave_autocmds) {</a>
<a name="ln4585">    CHECK_CMDWIN;</a>
<a name="ln4586">  }</a>
<a name="ln4587"> </a>
<a name="ln4588">  // Don't repeat a message in another tab page.</a>
<a name="ln4589">  set_keep_msg(NULL, 0);</a>
<a name="ln4590"> </a>
<a name="ln4591">  skip_win_fix_scroll = true;</a>
<a name="ln4592">  if (tp != curtab &amp;&amp; leave_tabpage(tp-&gt;tp_curwin-&gt;w_buffer,</a>
<a name="ln4593">                                    trigger_leave_autocmds) == OK) {</a>
<a name="ln4594">    if (valid_tabpage(tp)) {</a>
<a name="ln4595">      enter_tabpage(tp, curbuf, trigger_enter_autocmds,</a>
<a name="ln4596">                    trigger_leave_autocmds);</a>
<a name="ln4597">    } else {</a>
<a name="ln4598">      enter_tabpage(curtab, curbuf, trigger_enter_autocmds,</a>
<a name="ln4599">                    trigger_leave_autocmds);</a>
<a name="ln4600">    }</a>
<a name="ln4601">  }</a>
<a name="ln4602">  skip_win_fix_scroll = false;</a>
<a name="ln4603">}</a>
<a name="ln4604"> </a>
<a name="ln4605">/// Go to the last accessed tab page, if there is one.</a>
<a name="ln4606">/// @return true if the tab page is valid, false otherwise.</a>
<a name="ln4607">bool goto_tabpage_lastused(void)</a>
<a name="ln4608">{</a>
<a name="ln4609">  if (!valid_tabpage(lastused_tabpage)) {</a>
<a name="ln4610">    return false;</a>
<a name="ln4611">  }</a>
<a name="ln4612"> </a>
<a name="ln4613">  goto_tabpage_tp(lastused_tabpage, true, true);</a>
<a name="ln4614">  return true;</a>
<a name="ln4615">}</a>
<a name="ln4616"> </a>
<a name="ln4617">// Enter window &quot;wp&quot; in tab page &quot;tp&quot;.</a>
<a name="ln4618">// Also updates the GUI tab.</a>
<a name="ln4619">void goto_tabpage_win(tabpage_T *tp, win_T *wp)</a>
<a name="ln4620">{</a>
<a name="ln4621">  goto_tabpage_tp(tp, true, true);</a>
<a name="ln4622">  if (curtab == tp &amp;&amp; win_valid(wp)) {</a>
<a name="ln4623">    win_enter(wp, true);</a>
<a name="ln4624">  }</a>
<a name="ln4625">}</a>
<a name="ln4626"> </a>
<a name="ln4627">// Move the current tab page to after tab page &quot;nr&quot;.</a>
<a name="ln4628">void tabpage_move(int nr)</a>
<a name="ln4629">{</a>
<a name="ln4630">  assert(curtab != NULL);</a>
<a name="ln4631"> </a>
<a name="ln4632">  if (first_tabpage-&gt;tp_next == NULL) {</a>
<a name="ln4633">    return;</a>
<a name="ln4634">  }</a>
<a name="ln4635"> </a>
<a name="ln4636">  int n = 1;</a>
<a name="ln4637">  tabpage_T *tp;</a>
<a name="ln4638"> </a>
<a name="ln4639">  for (tp = first_tabpage; tp-&gt;tp_next != NULL &amp;&amp; n &lt; nr; tp = tp-&gt;tp_next) {</a>
<a name="ln4640">    n++;</a>
<a name="ln4641">  }</a>
<a name="ln4642"> </a>
<a name="ln4643">  if (tp == curtab || (nr &gt; 0 &amp;&amp; tp-&gt;tp_next != NULL</a>
<a name="ln4644">                       &amp;&amp; tp-&gt;tp_next == curtab)) {</a>
<a name="ln4645">    return;</a>
<a name="ln4646">  }</a>
<a name="ln4647"> </a>
<a name="ln4648">  tabpage_T *tp_dst = tp;</a>
<a name="ln4649"> </a>
<a name="ln4650">  // Remove the current tab page from the list of tab pages.</a>
<a name="ln4651">  if (curtab == first_tabpage) {</a>
<a name="ln4652">    first_tabpage = curtab-&gt;tp_next;</a>
<a name="ln4653">  } else {</a>
<a name="ln4654">    tp = NULL;</a>
<a name="ln4655">    FOR_ALL_TABS(tp2) {</a>
<a name="ln4656">      if (tp2-&gt;tp_next == curtab) {</a>
<a name="ln4657">        tp = tp2;</a>
<a name="ln4658">        break;</a>
<a name="ln4659">      }</a>
<a name="ln4660">    }</a>
<a name="ln4661">    if (tp == NULL) {   // &quot;cannot happen&quot;</a>
<a name="ln4662">      return;</a>
<a name="ln4663">    }</a>
<a name="ln4664">    tp-&gt;tp_next = curtab-&gt;tp_next;</a>
<a name="ln4665">  }</a>
<a name="ln4666"> </a>
<a name="ln4667">  // Re-insert it at the specified position.</a>
<a name="ln4668">  if (nr &lt;= 0) {</a>
<a name="ln4669">    curtab-&gt;tp_next = first_tabpage;</a>
<a name="ln4670">    first_tabpage = curtab;</a>
<a name="ln4671">  } else {</a>
<a name="ln4672">    curtab-&gt;tp_next = tp_dst-&gt;tp_next;</a>
<a name="ln4673">    tp_dst-&gt;tp_next = curtab;</a>
<a name="ln4674">  }</a>
<a name="ln4675"> </a>
<a name="ln4676">  // Need to redraw the tabline.  Tab page contents doesn't change.</a>
<a name="ln4677">  redraw_tabline = true;</a>
<a name="ln4678">}</a>
<a name="ln4679"> </a>
<a name="ln4680">// Go to another window.</a>
<a name="ln4681">// When jumping to another buffer, stop Visual mode.  Do this before</a>
<a name="ln4682">// changing windows so we can yank the selection into the '*' register.</a>
<a name="ln4683">// When jumping to another window on the same buffer, adjust its cursor</a>
<a name="ln4684">// position to keep the same Visual area.</a>
<a name="ln4685">void win_goto(win_T *wp)</a>
<a name="ln4686">{</a>
<a name="ln4687">  win_T *owp = curwin;</a>
<a name="ln4688"> </a>
<a name="ln4689">  if (text_or_buf_locked()) {</a>
<a name="ln4690">    beep_flush();</a>
<a name="ln4691">    return;</a>
<a name="ln4692">  }</a>
<a name="ln4693"> </a>
<a name="ln4694">  if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln4695">    reset_VIsual_and_resel();</a>
<a name="ln4696">  } else if (VIsual_active) {</a>
<a name="ln4697">    wp-&gt;w_cursor = curwin-&gt;w_cursor;</a>
<a name="ln4698">  }</a>
<a name="ln4699"> </a>
<a name="ln4700">  win_enter(wp, true);</a>
<a name="ln4701"> </a>
<a name="ln4702">  // Conceal cursor line in previous window, unconceal in current window.</a>
<a name="ln4703">  if (win_valid(owp) &amp;&amp; owp-&gt;w_p_cole &gt; 0 &amp;&amp; !msg_scrolled) {</a>
<a name="ln4704">    redrawWinline(owp, owp-&gt;w_cursor.lnum);</a>
<a name="ln4705">  }</a>
<a name="ln4706">  if (curwin-&gt;w_p_cole &gt; 0 &amp;&amp; !msg_scrolled) {</a>
<a name="ln4707">    redrawWinline(curwin, curwin-&gt;w_cursor.lnum);</a>
<a name="ln4708">  }</a>
<a name="ln4709">}</a>
<a name="ln4710"> </a>
<a name="ln4711">// Find the tabpage for window &quot;win&quot;.</a>
<a name="ln4712">tabpage_T *win_find_tabpage(win_T *win)</a>
<a name="ln4713">{</a>
<a name="ln4714">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln4715">    if (wp == win) {</a>
<a name="ln4716">      return tp;</a>
<a name="ln4717">    }</a>
<a name="ln4718">  }</a>
<a name="ln4719">  return NULL;</a>
<a name="ln4720">}</a>
<a name="ln4721"> </a>
<a name="ln4722">/// Get the above or below neighbor window of the specified window.</a>
<a name="ln4723">///</a>
<a name="ln4724">/// Returns the specified window if the neighbor is not found.</a>
<a name="ln4725">/// Returns the previous window if the specifiecied window is a floating window.</a>
<a name="ln4726">///</a>
<a name="ln4727">/// @param up     true for the above neighbor</a>
<a name="ln4728">/// @param count  nth neighbor window</a>
<a name="ln4729">///</a>
<a name="ln4730">/// @return       found window</a>
<a name="ln4731">win_T *win_vert_neighbor(tabpage_T *tp, win_T *wp, bool up, int count)</a>
<a name="ln4732">{</a>
<a name="ln4733">  frame_T *foundfr = wp-&gt;w_frame;</a>
<a name="ln4734"> </a>
<a name="ln4735">  if (wp-&gt;w_floating) {</a>
<a name="ln4736">    return win_valid(prevwin) &amp;&amp; !prevwin-&gt;w_floating ? prevwin : firstwin;</a>
<a name="ln4737">  }</a>
<a name="ln4738"> </a>
<a name="ln4739">  while (count--) {</a>
<a name="ln4740">    frame_T *nfr;</a>
<a name="ln4741">    // First go upwards in the tree of frames until we find an upwards or</a>
<a name="ln4742">    // downwards neighbor.</a>
<a name="ln4743">    frame_T *fr = foundfr;</a>
<a name="ln4744">    while (true) {</a>
<a name="ln4745">      if (fr == tp-&gt;tp_topframe) {</a>
<a name="ln4746">        goto end;</a>
<a name="ln4747">      }</a>
<a name="ln4748">      if (up) {</a>
<a name="ln4749">        nfr = fr-&gt;fr_prev;</a>
<a name="ln4750">      } else {</a>
<a name="ln4751">        nfr = fr-&gt;fr_next;</a>
<a name="ln4752">      }</a>
<a name="ln4753">      if (fr-&gt;fr_parent-&gt;fr_layout == FR_COL &amp;&amp; nfr != NULL) {</a>
<a name="ln4754">        break;</a>
<a name="ln4755">      }</a>
<a name="ln4756">      fr = fr-&gt;fr_parent;</a>
<a name="ln4757">    }</a>
<a name="ln4758"> </a>
<a name="ln4759">    // Now go downwards to find the bottom or top frame in it.</a>
<a name="ln4760">    while (true) {</a>
<a name="ln4761">      if (nfr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln4762">        foundfr = nfr;</a>
<a name="ln4763">        break;</a>
<a name="ln4764">      }</a>
<a name="ln4765">      fr = nfr-&gt;fr_child;</a>
<a name="ln4766">      if (nfr-&gt;fr_layout == FR_ROW) {</a>
<a name="ln4767">        // Find the frame at the cursor row.</a>
<a name="ln4768">        while (fr-&gt;fr_next != NULL</a>
<a name="ln4769">               &amp;&amp; frame2win(fr)-&gt;w_wincol + fr-&gt;fr_width</a>
<a name="ln4770">               &lt;= wp-&gt;w_wincol + wp-&gt;w_wcol) {</a>
<a name="ln4771">          fr = fr-&gt;fr_next;</a>
<a name="ln4772">        }</a>
<a name="ln4773">      }</a>
<a name="ln4774">      if (nfr-&gt;fr_layout == FR_COL &amp;&amp; up) {</a>
<a name="ln4775">        while (fr-&gt;fr_next != NULL) {</a>
<a name="ln4776">          fr = fr-&gt;fr_next;</a>
<a name="ln4777">        }</a>
<a name="ln4778">      }</a>
<a name="ln4779">      nfr = fr;</a>
<a name="ln4780">    }</a>
<a name="ln4781">  }</a>
<a name="ln4782">end:</a>
<a name="ln4783">  return foundfr != NULL ? foundfr-&gt;fr_win : NULL;</a>
<a name="ln4784">}</a>
<a name="ln4785"> </a>
<a name="ln4786">/// Move to window above or below &quot;count&quot; times.</a>
<a name="ln4787">///</a>
<a name="ln4788">/// @param up     true to go to win above</a>
<a name="ln4789">/// @param count  go count times into direction</a>
<a name="ln4790">static void win_goto_ver(bool up, int count)</a>
<a name="ln4791">{</a>
<a name="ln4792">  win_T *win = win_vert_neighbor(curtab, curwin, up, count);</a>
<a name="ln4793">  if (win != NULL) {</a>
<a name="ln4794">    win_goto(win);</a>
<a name="ln4795">  }</a>
<a name="ln4796">}</a>
<a name="ln4797"> </a>
<a name="ln4798">/// Get the left or right neighbor window of the specified window.</a>
<a name="ln4799">///</a>
<a name="ln4800">/// Returns the specified window if the neighbor is not found.</a>
<a name="ln4801">/// Returns the previous window if the specifiecied window is a floating window.</a>
<a name="ln4802">///</a>
<a name="ln4803">/// @param left  true for the left neighbor</a>
<a name="ln4804">/// @param count nth neighbor window</a>
<a name="ln4805">///</a>
<a name="ln4806">/// @return      found window</a>
<a name="ln4807">win_T *win_horz_neighbor(tabpage_T *tp, win_T *wp, bool left, int count)</a>
<a name="ln4808">{</a>
<a name="ln4809">  frame_T *foundfr = wp-&gt;w_frame;</a>
<a name="ln4810"> </a>
<a name="ln4811">  if (wp-&gt;w_floating) {</a>
<a name="ln4812">    return win_valid(prevwin) &amp;&amp; !prevwin-&gt;w_floating ? prevwin : firstwin;</a>
<a name="ln4813">  }</a>
<a name="ln4814"> </a>
<a name="ln4815">  while (count--) {</a>
<a name="ln4816">    frame_T *nfr;</a>
<a name="ln4817">    // First go upwards in the tree of frames until we find a left or</a>
<a name="ln4818">    // right neighbor.</a>
<a name="ln4819">    frame_T *fr = foundfr;</a>
<a name="ln4820">    while (true) {</a>
<a name="ln4821">      if (fr == tp-&gt;tp_topframe) {</a>
<a name="ln4822">        goto end;</a>
<a name="ln4823">      }</a>
<a name="ln4824">      if (left) {</a>
<a name="ln4825">        nfr = fr-&gt;fr_prev;</a>
<a name="ln4826">      } else {</a>
<a name="ln4827">        nfr = fr-&gt;fr_next;</a>
<a name="ln4828">      }</a>
<a name="ln4829">      if (fr-&gt;fr_parent-&gt;fr_layout == FR_ROW &amp;&amp; nfr != NULL) {</a>
<a name="ln4830">        break;</a>
<a name="ln4831">      }</a>
<a name="ln4832">      fr = fr-&gt;fr_parent;</a>
<a name="ln4833">    }</a>
<a name="ln4834"> </a>
<a name="ln4835">    // Now go downwards to find the leftmost or rightmost frame in it.</a>
<a name="ln4836">    while (true) {</a>
<a name="ln4837">      if (nfr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln4838">        foundfr = nfr;</a>
<a name="ln4839">        break;</a>
<a name="ln4840">      }</a>
<a name="ln4841">      fr = nfr-&gt;fr_child;</a>
<a name="ln4842">      if (nfr-&gt;fr_layout == FR_COL) {</a>
<a name="ln4843">        // Find the frame at the cursor row.</a>
<a name="ln4844">        while (fr-&gt;fr_next != NULL</a>
<a name="ln4845">               &amp;&amp; frame2win(fr)-&gt;w_winrow + fr-&gt;fr_height</a>
<a name="ln4846">               &lt;= wp-&gt;w_winrow + wp-&gt;w_wrow) {</a>
<a name="ln4847">          fr = fr-&gt;fr_next;</a>
<a name="ln4848">        }</a>
<a name="ln4849">      }</a>
<a name="ln4850">      if (nfr-&gt;fr_layout == FR_ROW &amp;&amp; left) {</a>
<a name="ln4851">        while (fr-&gt;fr_next != NULL) {</a>
<a name="ln4852">          fr = fr-&gt;fr_next;</a>
<a name="ln4853">        }</a>
<a name="ln4854">      }</a>
<a name="ln4855">      nfr = fr;</a>
<a name="ln4856">    }</a>
<a name="ln4857">  }</a>
<a name="ln4858">end:</a>
<a name="ln4859">  return foundfr != NULL ? foundfr-&gt;fr_win : NULL;</a>
<a name="ln4860">}</a>
<a name="ln4861"> </a>
<a name="ln4862">/// Move to left or right window.</a>
<a name="ln4863">///</a>
<a name="ln4864">/// @param left   true to go to left window</a>
<a name="ln4865">/// @param count  go count times into direction</a>
<a name="ln4866">static void win_goto_hor(bool left, int count)</a>
<a name="ln4867">{</a>
<a name="ln4868">  win_T *win = win_horz_neighbor(curtab, curwin, left, count);</a>
<a name="ln4869">  if (win != NULL) {</a>
<a name="ln4870">    win_goto(win);</a>
<a name="ln4871">  }</a>
<a name="ln4872">}</a>
<a name="ln4873"> </a>
<a name="ln4874">/// Make window `wp` the current window.</a>
<a name="ln4875">///</a>
<a name="ln4876">/// @warning Autocmds may close the window immediately, so caller must check</a>
<a name="ln4877">///          win_valid(wp).</a>
<a name="ln4878">void win_enter(win_T *wp, bool undo_sync)</a>
<a name="ln4879">{</a>
<a name="ln4880">  win_enter_ext(wp, (undo_sync ? WEE_UNDO_SYNC : 0)</a>
<a name="ln4881">                | WEE_TRIGGER_ENTER_AUTOCMDS | WEE_TRIGGER_LEAVE_AUTOCMDS);</a>
<a name="ln4882">}</a>
<a name="ln4883"> </a>
<a name="ln4884">/// Make window &quot;wp&quot; the current window.</a>
<a name="ln4885">///</a>
<a name="ln4886">/// @param flags  if contains WEE_CURWIN_INVALID, it means curwin has just been</a>
<a name="ln4887">///               closed and isn't valid.</a>
<a name="ln4888">static void win_enter_ext(win_T *const wp, const int flags)</a>
<a name="ln4889">{</a>
<a name="ln4890">  bool other_buffer = false;</a>
<a name="ln4891">  const bool curwin_invalid = (flags &amp; WEE_CURWIN_INVALID);</a>
<a name="ln4892"> </a>
<a name="ln4893">  if (wp == curwin &amp;&amp; !curwin_invalid) {        // nothing to do</a>
<a name="ln4894">    return;</a>
<a name="ln4895">  }</a>
<a name="ln4896"> </a>
<a name="ln4897">  if (!curwin_invalid) {</a>
<a name="ln4898">    leaving_window(curwin);</a>
<a name="ln4899">  }</a>
<a name="ln4900"> </a>
<a name="ln4901">  if (!curwin_invalid &amp;&amp; (flags &amp; WEE_TRIGGER_LEAVE_AUTOCMDS)) {</a>
<a name="ln4902">    // Be careful: If autocommands delete the window, return now.</a>
<a name="ln4903">    if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln4904">      apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln4905">      other_buffer = true;</a>
<a name="ln4906">      if (!win_valid(wp)) {</a>
<a name="ln4907">        return;</a>
<a name="ln4908">      }</a>
<a name="ln4909">    }</a>
<a name="ln4910">    apply_autocmds(EVENT_WINLEAVE, NULL, NULL, false, curbuf);</a>
<a name="ln4911">    if (!win_valid(wp)) {</a>
<a name="ln4912">      return;</a>
<a name="ln4913">    }</a>
<a name="ln4914">    // autocmds may abort script processing</a>
<a name="ln4915">    if (aborting()) {</a>
<a name="ln4916">      return;</a>
<a name="ln4917">    }</a>
<a name="ln4918">  }</a>
<a name="ln4919"> </a>
<a name="ln4920">  // sync undo before leaving the current buffer</a>
<a name="ln4921">  if ((flags &amp; WEE_UNDO_SYNC) &amp;&amp; curbuf != wp-&gt;w_buffer) {</a>
<a name="ln4922">    u_sync(false);</a>
<a name="ln4923">  }</a>
<a name="ln4924"> </a>
<a name="ln4925">  // Might need to scroll the old window before switching, e.g., when the</a>
<a name="ln4926">  // cursor was moved.</a>
<a name="ln4927">  if (*p_spk == 'c' &amp;&amp; !curwin_invalid) {</a>
<a name="ln4928">    update_topline(curwin);</a>
<a name="ln4929">  }</a>
<a name="ln4930"> </a>
<a name="ln4931">  // may have to copy the buffer options when 'cpo' contains 'S'</a>
<a name="ln4932">  if (wp-&gt;w_buffer != curbuf) {</a>
<a name="ln4933">    buf_copy_options(wp-&gt;w_buffer, BCO_ENTER | BCO_NOHELP);</a>
<a name="ln4934">  }</a>
<a name="ln4935">  if (!curwin_invalid) {</a>
<a name="ln4936">    prevwin = curwin;           // remember for CTRL-W p</a>
<a name="ln4937">    curwin-&gt;w_redr_status = true;</a>
<a name="ln4938">  }</a>
<a name="ln4939">  curwin = wp;</a>
<a name="ln4940">  curbuf = wp-&gt;w_buffer;</a>
<a name="ln4941"> </a>
<a name="ln4942">  check_cursor();</a>
<a name="ln4943">  if (!virtual_active()) {</a>
<a name="ln4944">    curwin-&gt;w_cursor.coladd = 0;</a>
<a name="ln4945">  }</a>
<a name="ln4946">  if (*p_spk == 'c') {</a>
<a name="ln4947">    changed_line_abv_curs();      // assume cursor position needs updating</a>
<a name="ln4948">  } else {</a>
<a name="ln4949">    // Make sure the cursor position is valid, either by moving the cursor</a>
<a name="ln4950">    // or by scrolling the text.</a>
<a name="ln4951">    win_fix_cursor(get_real_state() &amp; (MODE_NORMAL|MODE_CMDLINE|MODE_TERMINAL));</a>
<a name="ln4952">  }</a>
<a name="ln4953"> </a>
<a name="ln4954">  fix_current_dir();</a>
<a name="ln4955"> </a>
<a name="ln4956">  entering_window(curwin);</a>
<a name="ln4957">  // Careful: autocommands may close the window and make &quot;wp&quot; invalid</a>
<a name="ln4958">  if (flags &amp; WEE_TRIGGER_NEW_AUTOCMDS) {</a>
<a name="ln4959">    apply_autocmds(EVENT_WINNEW, NULL, NULL, false, curbuf);</a>
<a name="ln4960">  }</a>
<a name="ln4961">  if (flags &amp; WEE_TRIGGER_ENTER_AUTOCMDS) {</a>
<a name="ln4962">    apply_autocmds(EVENT_WINENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4963">    if (other_buffer) {</a>
<a name="ln4964">      apply_autocmds(EVENT_BUFENTER, NULL, NULL, false, curbuf);</a>
<a name="ln4965">    }</a>
<a name="ln4966">  }</a>
<a name="ln4967"> </a>
<a name="ln4968">  maketitle();</a>
<a name="ln4969">  curwin-&gt;w_redr_status = true;</a>
<a name="ln4970">  redraw_tabline = true;</a>
<a name="ln4971">  if (restart_edit) {</a>
<a name="ln4972">    redraw_later(curwin, UPD_VALID);  // causes status line redraw</a>
<a name="ln4973">  }</a>
<a name="ln4974"> </a>
<a name="ln4975">  // change background color according to NormalNC,</a>
<a name="ln4976">  // but only if actually defined (otherwise no extra redraw)</a>
<a name="ln4977">  if (curwin-&gt;w_hl_attr_normal != curwin-&gt;w_hl_attr_normalnc) {</a>
<a name="ln4978">    // TODO(bfredl): eventually we should be smart enough</a>
<a name="ln4979">    // to only recompose the window, not redraw it.</a>
<a name="ln4980">    redraw_later(curwin, UPD_NOT_VALID);</a>
<a name="ln4981">  }</a>
<a name="ln4982">  if (prevwin) {</a>
<a name="ln4983">    if (prevwin-&gt;w_hl_attr_normal != prevwin-&gt;w_hl_attr_normalnc) {</a>
<a name="ln4984">      redraw_later(prevwin, UPD_NOT_VALID);</a>
<a name="ln4985">    }</a>
<a name="ln4986">  }</a>
<a name="ln4987"> </a>
<a name="ln4988">  // set window height to desired minimal value</a>
<a name="ln4989">  if (curwin-&gt;w_height &lt; p_wh &amp;&amp; !curwin-&gt;w_p_wfh &amp;&amp; !curwin-&gt;w_floating) {</a>
<a name="ln4990">    win_setheight((int)p_wh);</a>
<a name="ln4991">  } else if (curwin-&gt;w_height == 0) {</a>
<a name="ln4992">    win_setheight(1);</a>
<a name="ln4993">  }</a>
<a name="ln4994"> </a>
<a name="ln4995">  // set window width to desired minimal value</a>
<a name="ln4996">  if (curwin-&gt;w_width &lt; p_wiw &amp;&amp; !curwin-&gt;w_p_wfw &amp;&amp; !curwin-&gt;w_floating) {</a>
<a name="ln4997">    win_setwidth((int)p_wiw);</a>
<a name="ln4998">  }</a>
<a name="ln4999"> </a>
<a name="ln5000">  setmouse();                   // in case jumped to/from help buffer</a>
<a name="ln5001"> </a>
<a name="ln5002">  // Change directories when the 'acd' option is set.</a>
<a name="ln5003">  do_autochdir();</a>
<a name="ln5004">}</a>
<a name="ln5005"> </a>
<a name="ln5006">/// Used after making another window the current one: change directory if needed.</a>
<a name="ln5007">void fix_current_dir(void)</a>
<a name="ln5008">{</a>
<a name="ln5009">  // New directory is either the local directory of the window, tab or NULL.</a>
<a name="ln5010">  char *new_dir = curwin-&gt;w_localdir ? curwin-&gt;w_localdir : curtab-&gt;tp_localdir;</a>
<a name="ln5011">  char cwd[MAXPATHL];</a>
<a name="ln5012">  if (os_dirname(cwd, MAXPATHL) != OK) {</a>
<a name="ln5013">    cwd[0] = NUL;</a>
<a name="ln5014">  }</a>
<a name="ln5015"> </a>
<a name="ln5016">  if (new_dir) {</a>
<a name="ln5017">    // Window/tab has a local directory: Save current directory as global</a>
<a name="ln5018">    // (unless that was done already) and change to the local directory.</a>
<a name="ln5019">    if (globaldir == NULL) {</a>
<a name="ln5020">      if (cwd[0] != NUL) {</a>
<a name="ln5021">        globaldir = xstrdup(cwd);</a>
<a name="ln5022">      }</a>
<a name="ln5023">    }</a>
<a name="ln5024">    bool dir_differs = pathcmp(new_dir, cwd, -1) != 0;</a>
<a name="ln5025">    if (!p_acd &amp;&amp; dir_differs) {</a>
<a name="ln5026">      do_autocmd_dirchanged(new_dir, curwin-&gt;w_localdir ? kCdScopeWindow : kCdScopeTabpage,</a>
<a name="ln5027">                            kCdCauseWindow, true);</a>
<a name="ln5028">    }</a>
<a name="ln5029">    if (os_chdir(new_dir) == 0) {</a>
<a name="ln5030">      if (!p_acd &amp;&amp; dir_differs) {</a>
<a name="ln5031">        do_autocmd_dirchanged(new_dir, curwin-&gt;w_localdir ? kCdScopeWindow : kCdScopeTabpage,</a>
<a name="ln5032">                              kCdCauseWindow, false);</a>
<a name="ln5033">      }</a>
<a name="ln5034">    }</a>
<a name="ln5035">    last_chdir_reason = NULL;</a>
<a name="ln5036">    shorten_fnames(true);</a>
<a name="ln5037">  } else if (globaldir != NULL) {</a>
<a name="ln5038">    // Window doesn't have a local directory and we are not in the global</a>
<a name="ln5039">    // directory: Change to the global directory.</a>
<a name="ln5040">    bool dir_differs = pathcmp(globaldir, cwd, -1) != 0;</a>
<a name="ln5041">    if (!p_acd &amp;&amp; dir_differs) {</a>
<a name="ln5042">      do_autocmd_dirchanged(globaldir, kCdScopeGlobal, kCdCauseWindow, true);</a>
<a name="ln5043">    }</a>
<a name="ln5044">    if (os_chdir(globaldir) == 0) {</a>
<a name="ln5045">      if (!p_acd &amp;&amp; dir_differs) {</a>
<a name="ln5046">        do_autocmd_dirchanged(globaldir, kCdScopeGlobal, kCdCauseWindow, false);</a>
<a name="ln5047">      }</a>
<a name="ln5048">    }</a>
<a name="ln5049">    XFREE_CLEAR(globaldir);</a>
<a name="ln5050">    last_chdir_reason = NULL;</a>
<a name="ln5051">    shorten_fnames(true);</a>
<a name="ln5052">  }</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">/// Jump to the first open window that contains buffer &quot;buf&quot;, if one exists.</a>
<a name="ln5056">/// Returns a pointer to the window found, otherwise NULL.</a>
<a name="ln5057">win_T *buf_jump_open_win(buf_T *buf)</a>
<a name="ln5058">{</a>
<a name="ln5059">  if (curwin-&gt;w_buffer == buf) {</a>
<a name="ln5060">    win_enter(curwin, false);</a>
<a name="ln5061">    return curwin;</a>
<a name="ln5062">  }</a>
<a name="ln5063">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5064">    if (wp-&gt;w_buffer == buf) {</a>
<a name="ln5065">      win_enter(wp, false);</a>
<a name="ln5066">      return wp;</a>
<a name="ln5067">    }</a>
<a name="ln5068">  }</a>
<a name="ln5069"> </a>
<a name="ln5070">  return NULL;</a>
<a name="ln5071">}</a>
<a name="ln5072"> </a>
<a name="ln5073">/// Jump to the first open window in any tab page that contains buffer &quot;buf&quot;,</a>
<a name="ln5074">/// if one exists. First search in the windows present in the current tab page.</a>
<a name="ln5075">/// @return the found window, or NULL.</a>
<a name="ln5076">win_T *buf_jump_open_tab(buf_T *buf)</a>
<a name="ln5077">{</a>
<a name="ln5078">  // First try the current tab page.</a>
<a name="ln5079">  {</a>
<a name="ln5080">    win_T *wp = buf_jump_open_win(buf);</a>
<a name="ln5081">    if (wp != NULL) {</a>
<a name="ln5082">      return wp;</a>
<a name="ln5083">    }</a>
<a name="ln5084">  }</a>
<a name="ln5085"> </a>
<a name="ln5086">  FOR_ALL_TABS(tp) {</a>
<a name="ln5087">    // Skip the current tab since we already checked it.</a>
<a name="ln5088">    if (tp == curtab) {</a>
<a name="ln5089">      continue;</a>
<a name="ln5090">    }</a>
<a name="ln5091">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln5092">      if (wp-&gt;w_buffer == buf) {</a>
<a name="ln5093">        goto_tabpage_win(tp, wp);</a>
<a name="ln5094"> </a>
<a name="ln5095">        // If we the current window didn't switch,</a>
<a name="ln5096">        // something went wrong.</a>
<a name="ln5097">        if (curwin != wp) {</a>
<a name="ln5098">          wp = NULL;</a>
<a name="ln5099">        }</a>
<a name="ln5100"> </a>
<a name="ln5101">        // Return the window we switched to.</a>
<a name="ln5102">        return wp;</a>
<a name="ln5103">      }</a>
<a name="ln5104">    }</a>
<a name="ln5105">  }</a>
<a name="ln5106"> </a>
<a name="ln5107">  // If we made it this far, we didn't find the buffer.</a>
<a name="ln5108">  return NULL;</a>
<a name="ln5109">}</a>
<a name="ln5110"> </a>
<a name="ln5111">/// @param hidden  allocate a window structure and link it in the window if</a>
<a name="ln5112">//                 false.</a>
<a name="ln5113">static win_T *win_alloc(win_T *after, bool hidden)</a>
<a name="ln5114">{</a>
<a name="ln5115">  static int last_win_id = LOWEST_WIN_ID - 1;</a>
<a name="ln5116"> </a>
<a name="ln5117">  // allocate window structure and linesizes arrays</a>
<a name="ln5118">  win_T *new_wp = xcalloc(1, sizeof(win_T));</a>
<a name="ln5119"> </a>
<a name="ln5120">  new_wp-&gt;handle = ++last_win_id;</a>
<a name="ln5121">  pmap_put(int)(&amp;window_handles, new_wp-&gt;handle, new_wp);</a>
<a name="ln5122"> </a>
<a name="ln5123">  grid_assign_handle(&amp;new_wp-&gt;w_grid_alloc);</a>
<a name="ln5124"> </a>
<a name="ln5125">  // Init w: variables.</a>
<a name="ln5126">  new_wp-&gt;w_vars = tv_dict_alloc();</a>
<a name="ln5127">  init_var_dict(new_wp-&gt;w_vars, &amp;new_wp-&gt;w_winvar, VAR_SCOPE);</a>
<a name="ln5128"> </a>
<a name="ln5129">  // Don't execute autocommands while the window is not properly</a>
<a name="ln5130">  // initialized yet.  gui_create_scrollbar() may trigger a FocusGained</a>
<a name="ln5131">  // event.</a>
<a name="ln5132">  block_autocmds();</a>
<a name="ln5133">  // link the window in the window list</a>
<a name="ln5134">  if (!hidden) {</a>
<a name="ln5135">    win_append(after, new_wp);</a>
<a name="ln5136">  }</a>
<a name="ln5137"> </a>
<a name="ln5138">  new_wp-&gt;w_wincol = 0;</a>
<a name="ln5139">  new_wp-&gt;w_width = Columns;</a>
<a name="ln5140"> </a>
<a name="ln5141">  // position the display and the cursor at the top of the file.</a>
<a name="ln5142">  new_wp-&gt;w_topline = 1;</a>
<a name="ln5143">  new_wp-&gt;w_topfill = 0;</a>
<a name="ln5144">  new_wp-&gt;w_botline = 2;</a>
<a name="ln5145">  new_wp-&gt;w_cursor.lnum = 1;</a>
<a name="ln5146">  new_wp-&gt;w_scbind_pos = 1;</a>
<a name="ln5147">  new_wp-&gt;w_floating = 0;</a>
<a name="ln5148">  new_wp-&gt;w_float_config = FLOAT_CONFIG_INIT;</a>
<a name="ln5149">  new_wp-&gt;w_viewport_invalid = true;</a>
<a name="ln5150">  new_wp-&gt;w_viewport_last_topline = 1;</a>
<a name="ln5151"> </a>
<a name="ln5152">  new_wp-&gt;w_ns_hl = -1;</a>
<a name="ln5153"> </a>
<a name="ln5154">  // use global option for global-local options</a>
<a name="ln5155">  new_wp-&gt;w_allbuf_opt.wo_so = new_wp-&gt;w_p_so = -1;</a>
<a name="ln5156">  new_wp-&gt;w_allbuf_opt.wo_siso = new_wp-&gt;w_p_siso = -1;</a>
<a name="ln5157"> </a>
<a name="ln5158">  // We won't calculate w_fraction until resizing the window</a>
<a name="ln5159">  new_wp-&gt;w_fraction = 0;</a>
<a name="ln5160">  new_wp-&gt;w_prev_fraction_row = -1;</a>
<a name="ln5161"> </a>
<a name="ln5162">  foldInitWin(new_wp);</a>
<a name="ln5163">  unblock_autocmds();</a>
<a name="ln5164">  new_wp-&gt;w_next_match_id = 1000;  // up to 1000 can be picked by the user</a>
<a name="ln5165">  return new_wp;</a>
<a name="ln5166">}</a>
<a name="ln5167"> </a>
<a name="ln5168">// Free one wininfo_T.</a>
<a name="ln5169">void free_wininfo(wininfo_T *wip, buf_T *bp)</a>
<a name="ln5170">{</a>
<a name="ln5171">  if (wip-&gt;wi_optset) {</a>
<a name="ln5172">    clear_winopt(&amp;wip-&gt;wi_opt);</a>
<a name="ln5173">    deleteFoldRecurse(bp, &amp;wip-&gt;wi_folds);</a>
<a name="ln5174">  }</a>
<a name="ln5175">  xfree(wip);</a>
<a name="ln5176">}</a>
<a name="ln5177"> </a>
<a name="ln5178">/// Remove window 'wp' from the window list and free the structure.</a>
<a name="ln5179">///</a>
<a name="ln5180">/// @param tp  tab page &quot;win&quot; is in, NULL for current</a>
<a name="ln5181">static void win_free(win_T *wp, tabpage_T *tp)</a>
<a name="ln5182">{</a>
<a name="ln5183">  pmap_del(int)(&amp;window_handles, wp-&gt;handle, NULL);</a>
<a name="ln5184">  clearFolding(wp);</a>
<a name="ln5185"> </a>
<a name="ln5186">  // reduce the reference count to the argument list.</a>
<a name="ln5187">  alist_unlink(wp-&gt;w_alist);</a>
<a name="ln5188"> </a>
<a name="ln5189">  // Don't execute autocommands while the window is halfway being deleted.</a>
<a name="ln5190">  block_autocmds();</a>
<a name="ln5191"> </a>
<a name="ln5192">  clear_winopt(&amp;wp-&gt;w_onebuf_opt);</a>
<a name="ln5193">  clear_winopt(&amp;wp-&gt;w_allbuf_opt);</a>
<a name="ln5194"> </a>
<a name="ln5195">  xfree(wp-&gt;w_p_lcs_chars.multispace);</a>
<a name="ln5196">  xfree(wp-&gt;w_p_lcs_chars.leadmultispace);</a>
<a name="ln5197"> </a>
<a name="ln5198">  vars_clear(&amp;wp-&gt;w_vars-&gt;dv_hashtab);          // free all w: variables</a>
<a name="ln5199">  hash_init(&amp;wp-&gt;w_vars-&gt;dv_hashtab);</a>
<a name="ln5200">  unref_var_dict(wp-&gt;w_vars);</a>
<a name="ln5201"> </a>
<a name="ln5202">  if (prevwin == wp) {</a>
<a name="ln5203">    prevwin = NULL;</a>
<a name="ln5204">  }</a>
<a name="ln5205">  FOR_ALL_TABS(ttp) {</a>
<a name="ln5206">    if (ttp-&gt;tp_prevwin == wp) {</a>
<a name="ln5207">      ttp-&gt;tp_prevwin = NULL;</a>
<a name="ln5208">    }</a>
<a name="ln5209">  }</a>
<a name="ln5210"> </a>
<a name="ln5211">  xfree(wp-&gt;w_lines);</a>
<a name="ln5212"> </a>
<a name="ln5213">  for (int i = 0; i &lt; wp-&gt;w_tagstacklen; i++) {</a>
<a name="ln5214">    xfree(wp-&gt;w_tagstack[i].tagname);</a>
<a name="ln5215">    xfree(wp-&gt;w_tagstack[i].user_data);</a>
<a name="ln5216">  }</a>
<a name="ln5217"> </a>
<a name="ln5218">  xfree(wp-&gt;w_localdir);</a>
<a name="ln5219">  xfree(wp-&gt;w_prevdir);</a>
<a name="ln5220"> </a>
<a name="ln5221">  stl_clear_click_defs(wp-&gt;w_status_click_defs, wp-&gt;w_status_click_defs_size);</a>
<a name="ln5222">  xfree(wp-&gt;w_status_click_defs);</a>
<a name="ln5223"> </a>
<a name="ln5224">  stl_clear_click_defs(wp-&gt;w_winbar_click_defs, wp-&gt;w_winbar_click_defs_size);</a>
<a name="ln5225">  xfree(wp-&gt;w_winbar_click_defs);</a>
<a name="ln5226"> </a>
<a name="ln5227">  stl_clear_click_defs(wp-&gt;w_statuscol_click_defs, wp-&gt;w_statuscol_click_defs_size);</a>
<a name="ln5228">  xfree(wp-&gt;w_statuscol_click_defs);</a>
<a name="ln5229"> </a>
<a name="ln5230">  // Remove the window from the b_wininfo lists, it may happen that the</a>
<a name="ln5231">  // freed memory is re-used for another window.</a>
<a name="ln5232">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln5233">    for (wininfo_T *wip = buf-&gt;b_wininfo; wip != NULL; wip = wip-&gt;wi_next) {</a>
<a name="ln5234">      if (wip-&gt;wi_win == wp) {</a>
<a name="ln5235">        wininfo_T *wip2;</a>
<a name="ln5236"> </a>
<a name="ln5237">        // If there already is an entry with &quot;wi_win&quot; set to NULL it</a>
<a name="ln5238">        // must be removed, it would never be used.</a>
<a name="ln5239">        // Skip &quot;wip&quot; itself, otherwise Coverity complains.</a>
<a name="ln5240">        for (wip2 = buf-&gt;b_wininfo; wip2 != NULL; wip2 = wip2-&gt;wi_next) {</a>
<a name="ln5241">          // `wip2 != wip` to satisfy Coverity. #14884</a>
<a name="ln5242">          if (wip2 != wip &amp;&amp; wip2-&gt;wi_win == NULL) {</a>
<a name="ln5243">            if (wip2-&gt;wi_next != NULL) {</a>
<a name="ln5244">              wip2-&gt;wi_next-&gt;wi_prev = wip2-&gt;wi_prev;</a>
<a name="ln5245">            }</a>
<a name="ln5246">            if (wip2-&gt;wi_prev == NULL) {</a>
<a name="ln5247">              buf-&gt;b_wininfo = wip2-&gt;wi_next;</a>
<a name="ln5248">            } else {</a>
<a name="ln5249">              wip2-&gt;wi_prev-&gt;wi_next = wip2-&gt;wi_next;</a>
<a name="ln5250">            }</a>
<a name="ln5251">            free_wininfo(wip2, buf);</a>
<a name="ln5252">            break;</a>
<a name="ln5253">          }</a>
<a name="ln5254">        }</a>
<a name="ln5255"> </a>
<a name="ln5256">        wip-&gt;wi_win = NULL;</a>
<a name="ln5257">      }</a>
<a name="ln5258">    }</a>
<a name="ln5259">  }</a>
<a name="ln5260"> </a>
<a name="ln5261">  // free the border text</a>
<a name="ln5262">  clear_virttext(&amp;wp-&gt;w_float_config.title_chunks);</a>
<a name="ln5263">  clear_virttext(&amp;wp-&gt;w_float_config.footer_chunks);</a>
<a name="ln5264"> </a>
<a name="ln5265">  clear_matches(wp);</a>
<a name="ln5266"> </a>
<a name="ln5267">  free_jumplist(wp);</a>
<a name="ln5268"> </a>
<a name="ln5269">  qf_free_all(wp);</a>
<a name="ln5270"> </a>
<a name="ln5271">  xfree(wp-&gt;w_p_cc_cols);</a>
<a name="ln5272"> </a>
<a name="ln5273">  win_free_grid(wp, false);</a>
<a name="ln5274"> </a>
<a name="ln5275">  if (win_valid_any_tab(wp)) {</a>
<a name="ln5276">    win_remove(wp, tp);</a>
<a name="ln5277">  }</a>
<a name="ln5278">  if (autocmd_busy) {</a>
<a name="ln5279">    wp-&gt;w_next = au_pending_free_win;</a>
<a name="ln5280">    au_pending_free_win = wp;</a>
<a name="ln5281">  } else {</a>
<a name="ln5282">    xfree(wp);</a>
<a name="ln5283">  }</a>
<a name="ln5284"> </a>
<a name="ln5285">  unblock_autocmds();</a>
<a name="ln5286">}</a>
<a name="ln5287"> </a>
<a name="ln5288">void win_free_grid(win_T *wp, bool reinit)</a>
<a name="ln5289">{</a>
<a name="ln5290">  if (wp-&gt;w_grid_alloc.handle != 0 &amp;&amp; ui_has(kUIMultigrid)) {</a>
<a name="ln5291">    ui_call_grid_destroy(wp-&gt;w_grid_alloc.handle);</a>
<a name="ln5292">  }</a>
<a name="ln5293">  grid_free(&amp;wp-&gt;w_grid_alloc);</a>
<a name="ln5294">  if (reinit) {</a>
<a name="ln5295">    // if a float is turned into a split, the grid data structure will be reused</a>
<a name="ln5296">    CLEAR_FIELD(wp-&gt;w_grid_alloc);</a>
<a name="ln5297">  }</a>
<a name="ln5298">}</a>
<a name="ln5299"> </a>
<a name="ln5300">// Append window &quot;wp&quot; in the window list after window &quot;after&quot;.</a>
<a name="ln5301">void win_append(win_T *after, win_T *wp)</a>
<a name="ln5302">{</a>
<a name="ln5303">  // after NULL is in front of the first</a>
<a name="ln5304">  win_T *before = after == NULL ? firstwin : after-&gt;w_next;</a>
<a name="ln5305"> </a>
<a name="ln5306">  wp-&gt;w_next = before;</a>
<a name="ln5307">  wp-&gt;w_prev = after;</a>
<a name="ln5308">  if (after == NULL) {</a>
<a name="ln5309">    firstwin = wp;</a>
<a name="ln5310">  } else {</a>
<a name="ln5311">    after-&gt;w_next = wp;</a>
<a name="ln5312">  }</a>
<a name="ln5313">  if (before == NULL) {</a>
<a name="ln5314">    lastwin = wp;</a>
<a name="ln5315">  } else {</a>
<a name="ln5316">    before-&gt;w_prev = wp;</a>
<a name="ln5317">  }</a>
<a name="ln5318">}</a>
<a name="ln5319"> </a>
<a name="ln5320">/// Remove a window from the window list.</a>
<a name="ln5321">///</a>
<a name="ln5322">/// @param tp  tab page &quot;win&quot; is in, NULL for current</a>
<a name="ln5323">void win_remove(win_T *wp, tabpage_T *tp)</a>
<a name="ln5324">{</a>
<a name="ln5325">  if (wp-&gt;w_prev != NULL) {</a>
<a name="ln5326">    wp-&gt;w_prev-&gt;w_next = wp-&gt;w_next;</a>
<a name="ln5327">  } else if (tp == NULL) {</a>
<a name="ln5328">    firstwin = curtab-&gt;tp_firstwin = wp-&gt;w_next;</a>
<a name="ln5329">  } else {</a>
<a name="ln5330">    tp-&gt;tp_firstwin = wp-&gt;w_next;</a>
<a name="ln5331">  }</a>
<a name="ln5332">  if (wp-&gt;w_next != NULL) {</a>
<a name="ln5333">    wp-&gt;w_next-&gt;w_prev = wp-&gt;w_prev;</a>
<a name="ln5334">  } else if (tp == NULL) {</a>
<a name="ln5335">    lastwin = curtab-&gt;tp_lastwin = wp-&gt;w_prev;</a>
<a name="ln5336">  } else {</a>
<a name="ln5337">    tp-&gt;tp_lastwin = wp-&gt;w_prev;</a>
<a name="ln5338">  }</a>
<a name="ln5339">}</a>
<a name="ln5340"> </a>
<a name="ln5341">// Append frame &quot;frp&quot; in a frame list after frame &quot;after&quot;.</a>
<a name="ln5342">static void frame_append(frame_T *after, frame_T *frp)</a>
<a name="ln5343">{</a>
<a name="ln5344">  frp-&gt;fr_next = after-&gt;fr_next;</a>
<a name="ln5345">  after-&gt;fr_next = frp;</a>
<a name="ln5346">  if (frp-&gt;fr_next != NULL) {</a>
<a name="ln5347">    frp-&gt;fr_next-&gt;fr_prev = frp;</a>
<a name="ln5348">  }</a>
<a name="ln5349">  frp-&gt;fr_prev = after;</a>
<a name="ln5350">}</a>
<a name="ln5351"> </a>
<a name="ln5352">// Insert frame &quot;frp&quot; in a frame list before frame &quot;before&quot;.</a>
<a name="ln5353">static void frame_insert(frame_T *before, frame_T *frp)</a>
<a name="ln5354">{</a>
<a name="ln5355">  frp-&gt;fr_next = before;</a>
<a name="ln5356">  frp-&gt;fr_prev = before-&gt;fr_prev;</a>
<a name="ln5357">  before-&gt;fr_prev = frp;</a>
<a name="ln5358">  if (frp-&gt;fr_prev != NULL) {</a>
<a name="ln5359">    frp-&gt;fr_prev-&gt;fr_next = frp;</a>
<a name="ln5360">  } else {</a>
<a name="ln5361">    frp-&gt;fr_parent-&gt;fr_child = frp;</a>
<a name="ln5362">  }</a>
<a name="ln5363">}</a>
<a name="ln5364"> </a>
<a name="ln5365">// Remove a frame from a frame list.</a>
<a name="ln5366">static void frame_remove(frame_T *frp)</a>
<a name="ln5367">{</a>
<a name="ln5368">  if (frp-&gt;fr_prev != NULL) {</a>
<a name="ln5369">    frp-&gt;fr_prev-&gt;fr_next = frp-&gt;fr_next;</a>
<a name="ln5370">  } else {</a>
<a name="ln5371">    frp-&gt;fr_parent-&gt;fr_child = frp-&gt;fr_next;</a>
<a name="ln5372">  }</a>
<a name="ln5373">  if (frp-&gt;fr_next != NULL) {</a>
<a name="ln5374">    frp-&gt;fr_next-&gt;fr_prev = frp-&gt;fr_prev;</a>
<a name="ln5375">  }</a>
<a name="ln5376">}</a>
<a name="ln5377"> </a>
<a name="ln5378">void win_new_screensize(void)</a>
<a name="ln5379">{</a>
<a name="ln5380">  static int old_Rows = 0;</a>
<a name="ln5381">  static int old_Columns = 0;</a>
<a name="ln5382"> </a>
<a name="ln5383">  if (old_Rows != Rows) {</a>
<a name="ln5384">    // If 'window' uses the whole screen, keep it using that.</a>
<a name="ln5385">    // Don't change it when set with &quot;-w size&quot; on the command line.</a>
<a name="ln5386">    if (p_window == old_Rows - 1 || (old_Rows == 0 &amp;&amp; !option_was_set(&quot;window&quot;))) {</a>
<a name="ln5387">      p_window = Rows - 1;</a>
<a name="ln5388">    }</a>
<a name="ln5389">    old_Rows = Rows;</a>
<a name="ln5390">    win_new_screen_rows();  // update window sizes</a>
<a name="ln5391">  }</a>
<a name="ln5392">  if (old_Columns != Columns) {</a>
<a name="ln5393">    old_Columns = Columns;</a>
<a name="ln5394">    win_new_screen_cols();  // update window sizes</a>
<a name="ln5395">  }</a>
<a name="ln5396">}</a>
<a name="ln5397">/// Called from win_new_screensize() after Rows changed.</a>
<a name="ln5398">///</a>
<a name="ln5399">/// This only does the current tab page, others must be done when made active.</a>
<a name="ln5400">void win_new_screen_rows(void)</a>
<a name="ln5401">{</a>
<a name="ln5402">  int h = (int)ROWS_AVAIL;</a>
<a name="ln5403"> </a>
<a name="ln5404">  if (firstwin == NULL) {       // not initialized yet</a>
<a name="ln5405">    return;</a>
<a name="ln5406">  }</a>
<a name="ln5407">  if (h &lt; frame_minheight(topframe, NULL)) {</a>
<a name="ln5408">    h = frame_minheight(topframe, NULL);</a>
<a name="ln5409">  }</a>
<a name="ln5410"> </a>
<a name="ln5411">  // First try setting the heights of windows with 'winfixheight'.  If</a>
<a name="ln5412">  // that doesn't result in the right height, forget about that option.</a>
<a name="ln5413">  frame_new_height(topframe, h, false, true);</a>
<a name="ln5414">  if (!frame_check_height(topframe, h)) {</a>
<a name="ln5415">    frame_new_height(topframe, h, false, false);</a>
<a name="ln5416">  }</a>
<a name="ln5417"> </a>
<a name="ln5418">  (void)win_comp_pos();  // recompute w_winrow and w_wincol</a>
<a name="ln5419">  win_reconfig_floats();  // The size of floats might change</a>
<a name="ln5420">  compute_cmdrow();</a>
<a name="ln5421">  curtab-&gt;tp_ch_used = p_ch;</a>
<a name="ln5422"> </a>
<a name="ln5423">  if (!skip_win_fix_scroll) {</a>
<a name="ln5424">    win_fix_scroll(true);</a>
<a name="ln5425">  }</a>
<a name="ln5426">}</a>
<a name="ln5427"> </a>
<a name="ln5428">/// Called from win_new_screensize() after Columns changed.</a>
<a name="ln5429">void win_new_screen_cols(void)</a>
<a name="ln5430">{</a>
<a name="ln5431">  if (firstwin == NULL) {       // not initialized yet</a>
<a name="ln5432">    return;</a>
<a name="ln5433">  }</a>
<a name="ln5434"> </a>
<a name="ln5435">  // First try setting the widths of windows with 'winfixwidth'.  If that</a>
<a name="ln5436">  // doesn't result in the right width, forget about that option.</a>
<a name="ln5437">  frame_new_width(topframe, Columns, false, true);</a>
<a name="ln5438">  if (!frame_check_width(topframe, Columns)) {</a>
<a name="ln5439">    frame_new_width(topframe, Columns, false, false);</a>
<a name="ln5440">  }</a>
<a name="ln5441"> </a>
<a name="ln5442">  (void)win_comp_pos();  // recompute w_winrow and w_wincol</a>
<a name="ln5443">  win_reconfig_floats();  // The size of floats might change</a>
<a name="ln5444">}</a>
<a name="ln5445"> </a>
<a name="ln5446">/// Make a snapshot of all the window scroll positions and sizes of the current</a>
<a name="ln5447">/// tab page.</a>
<a name="ln5448">void snapshot_windows_scroll_size(void)</a>
<a name="ln5449">{</a>
<a name="ln5450">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5451">    wp-&gt;w_last_topline = wp-&gt;w_topline;</a>
<a name="ln5452">    wp-&gt;w_last_topfill = wp-&gt;w_topfill;</a>
<a name="ln5453">    wp-&gt;w_last_leftcol = wp-&gt;w_leftcol;</a>
<a name="ln5454">    wp-&gt;w_last_skipcol = wp-&gt;w_skipcol;</a>
<a name="ln5455">    wp-&gt;w_last_width = wp-&gt;w_width;</a>
<a name="ln5456">    wp-&gt;w_last_height = wp-&gt;w_height;</a>
<a name="ln5457">  }</a>
<a name="ln5458">}</a>
<a name="ln5459"> </a>
<a name="ln5460">static bool did_initial_scroll_size_snapshot = false;</a>
<a name="ln5461"> </a>
<a name="ln5462">void may_make_initial_scroll_size_snapshot(void)</a>
<a name="ln5463">{</a>
<a name="ln5464">  if (!did_initial_scroll_size_snapshot) {</a>
<a name="ln5465">    did_initial_scroll_size_snapshot = true;</a>
<a name="ln5466">    snapshot_windows_scroll_size();</a>
<a name="ln5467">  }</a>
<a name="ln5468">}</a>
<a name="ln5469"> </a>
<a name="ln5470">/// Create a dictionary with information about size and scroll changes in a</a>
<a name="ln5471">/// window.</a>
<a name="ln5472">/// Returns the dictionary with refcount set to one.</a>
<a name="ln5473">/// Returns NULL on internal error.</a>
<a name="ln5474">static dict_T *make_win_info_dict(int width, int height, int topline, int topfill, int leftcol,</a>
<a name="ln5475">                                  int skipcol)</a>
<a name="ln5476">{</a>
<a name="ln5477">  dict_T *const d = tv_dict_alloc();</a>
<a name="ln5478">  d-&gt;dv_refcount = 1;</a>
<a name="ln5479"> </a>
<a name="ln5480">  // not actually looping, for breaking out on error</a>
<a name="ln5481">  while (true) {</a>
<a name="ln5482">    typval_T tv = {</a>
<a name="ln5483">      .v_lock = VAR_UNLOCKED,</a>
<a name="ln5484">      .v_type = VAR_NUMBER,</a>
<a name="ln5485">    };</a>
<a name="ln5486"> </a>
<a name="ln5487">    tv.vval.v_number = width;</a>
<a name="ln5488">    if (tv_dict_add_tv(d, S_LEN(&quot;width&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5489">      break;</a>
<a name="ln5490">    }</a>
<a name="ln5491">    tv.vval.v_number = height;</a>
<a name="ln5492">    if (tv_dict_add_tv(d, S_LEN(&quot;height&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5493">      break;</a>
<a name="ln5494">    }</a>
<a name="ln5495">    tv.vval.v_number = topline;</a>
<a name="ln5496">    if (tv_dict_add_tv(d, S_LEN(&quot;topline&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5497">      break;</a>
<a name="ln5498">    }</a>
<a name="ln5499">    tv.vval.v_number = topfill;</a>
<a name="ln5500">    if (tv_dict_add_tv(d, S_LEN(&quot;topfill&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5501">      break;</a>
<a name="ln5502">    }</a>
<a name="ln5503">    tv.vval.v_number = leftcol;</a>
<a name="ln5504">    if (tv_dict_add_tv(d, S_LEN(&quot;leftcol&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5505">      break;</a>
<a name="ln5506">    }</a>
<a name="ln5507">    tv.vval.v_number = skipcol;</a>
<a name="ln5508">    if (tv_dict_add_tv(d, S_LEN(&quot;skipcol&quot;), &amp;tv) == FAIL) {</a>
<a name="ln5509">      break;</a>
<a name="ln5510">    }</a>
<a name="ln5511">    return d;</a>
<a name="ln5512">  }</a>
<a name="ln5513">  tv_dict_unref(d);</a>
<a name="ln5514">  return NULL;</a>
<a name="ln5515">}</a>
<a name="ln5516"> </a>
<a name="ln5517">/// Return values of check_window_scroll_resize():</a>
<a name="ln5518">enum {</a>
<a name="ln5519">  CWSR_SCROLLED = 1,  ///&lt; at least one window scrolled</a>
<a name="ln5520">  CWSR_RESIZED  = 2,  ///&lt; at least one window size changed</a>
<a name="ln5521">};</a>
<a name="ln5522"> </a>
<a name="ln5523">/// This function is used for three purposes:</a>
<a name="ln5524">/// 1. Goes over all windows in the current tab page and returns:</a>
<a name="ln5525">///      0                               no scrolling and no size changes found</a>
<a name="ln5526">///      CWSR_SCROLLED                   at least one window scrolled</a>
<a name="ln5527">///      CWSR_RESIZED                    at least one window changed size</a>
<a name="ln5528">///      CWSR_SCROLLED + CWSR_RESIZED    both</a>
<a name="ln5529">///    &quot;size_count&quot; is set to the nr of windows with size changes.</a>
<a name="ln5530">///    &quot;first_scroll_win&quot; is set to the first window with any relevant changes.</a>
<a name="ln5531">///    &quot;first_size_win&quot; is set to the first window with size changes.</a>
<a name="ln5532">///</a>
<a name="ln5533">/// 2. When the first three arguments are NULL and &quot;winlist&quot; is not NULL,</a>
<a name="ln5534">///    &quot;winlist&quot; is set to the list of window IDs with size changes.</a>
<a name="ln5535">///</a>
<a name="ln5536">/// 3. When the first three arguments are NULL and &quot;v_event&quot; is not NULL,</a>
<a name="ln5537">///    information about changed windows is added to &quot;v_event&quot;.</a>
<a name="ln5538">static int check_window_scroll_resize(int *size_count, win_T **first_scroll_win,</a>
<a name="ln5539">                                      win_T **first_size_win, list_T *winlist, dict_T *v_event)</a>
<a name="ln5540">{</a>
<a name="ln5541">  int result = 0;</a>
<a name="ln5542">  // int listidx = 0;</a>
<a name="ln5543">  int tot_width = 0;</a>
<a name="ln5544">  int tot_height = 0;</a>
<a name="ln5545">  int tot_topline = 0;</a>
<a name="ln5546">  int tot_topfill = 0;</a>
<a name="ln5547">  int tot_leftcol = 0;</a>
<a name="ln5548">  int tot_skipcol = 0;</a>
<a name="ln5549"> </a>
<a name="ln5550">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5551">    // Skip floating windows that do not have a snapshot (usually because they are newly-created),</a>
<a name="ln5552">    // as unlike split windows, creating floating windows do not cause other windows to resize.</a>
<a name="ln5553">    if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_last_topline == 0) {</a>
<a name="ln5554">      wp-&gt;w_last_topline = wp-&gt;w_topline;</a>
<a name="ln5555">      wp-&gt;w_last_topfill = wp-&gt;w_topfill;</a>
<a name="ln5556">      wp-&gt;w_last_leftcol = wp-&gt;w_leftcol;</a>
<a name="ln5557">      wp-&gt;w_last_skipcol = wp-&gt;w_skipcol;</a>
<a name="ln5558">      wp-&gt;w_last_width = wp-&gt;w_width;</a>
<a name="ln5559">      wp-&gt;w_last_height = wp-&gt;w_height;</a>
<a name="ln5560">      continue;</a>
<a name="ln5561">    }</a>
<a name="ln5562"> </a>
<a name="ln5563">    const bool size_changed = wp-&gt;w_last_width != wp-&gt;w_width</a>
<a name="ln5564">                              || wp-&gt;w_last_height != wp-&gt;w_height;</a>
<a name="ln5565">    if (size_changed) {</a>
<a name="ln5566">      result |= CWSR_RESIZED;</a>
<a name="ln5567">      if (winlist != NULL) {</a>
<a name="ln5568">        // Add this window to the list of changed windows.</a>
<a name="ln5569">        typval_T tv = {</a>
<a name="ln5570">          .v_lock = VAR_UNLOCKED,</a>
<a name="ln5571">          .v_type = VAR_NUMBER,</a>
<a name="ln5572">          .vval.v_number = wp-&gt;handle,</a>
<a name="ln5573">        };</a>
<a name="ln5574">        // tv_list_set_item(winlist, listidx++, &amp;tv);</a>
<a name="ln5575">        tv_list_append_owned_tv(winlist, tv);</a>
<a name="ln5576">      } else if (size_count != NULL) {</a>
<a name="ln5577">        assert(first_size_win != NULL &amp;&amp; first_scroll_win != NULL);</a>
<a name="ln5578">        (*size_count)++;</a>
<a name="ln5579">        if (*first_size_win == NULL) {</a>
<a name="ln5580">          *first_size_win = wp;</a>
<a name="ln5581">        }</a>
<a name="ln5582">        // For WinScrolled the first window with a size change is used</a>
<a name="ln5583">        // even when it didn't scroll.</a>
<a name="ln5584">        if (*first_scroll_win == NULL) {</a>
<a name="ln5585">          *first_scroll_win = wp;</a>
<a name="ln5586">        }</a>
<a name="ln5587">      }</a>
<a name="ln5588">    }</a>
<a name="ln5589"> </a>
<a name="ln5590">    const bool scroll_changed = wp-&gt;w_last_topline != wp-&gt;w_topline</a>
<a name="ln5591">                                || wp-&gt;w_last_topfill != wp-&gt;w_topfill</a>
<a name="ln5592">                                || wp-&gt;w_last_leftcol != wp-&gt;w_leftcol</a>
<a name="ln5593">                                || wp-&gt;w_last_skipcol != wp-&gt;w_skipcol;</a>
<a name="ln5594">    if (scroll_changed) {</a>
<a name="ln5595">      result |= CWSR_SCROLLED;</a>
<a name="ln5596">      if (first_scroll_win != NULL &amp;&amp; *first_scroll_win == NULL) {</a>
<a name="ln5597">        *first_scroll_win = wp;</a>
<a name="ln5598">      }</a>
<a name="ln5599">    }</a>
<a name="ln5600"> </a>
<a name="ln5601">    if ((size_changed || scroll_changed) &amp;&amp; v_event != NULL) {</a>
<a name="ln5602">      // Add info about this window to the v:event dictionary.</a>
<a name="ln5603">      int width = wp-&gt;w_width - wp-&gt;w_last_width;</a>
<a name="ln5604">      int height = wp-&gt;w_height - wp-&gt;w_last_height;</a>
<a name="ln5605">      int topline = wp-&gt;w_topline - wp-&gt;w_last_topline;</a>
<a name="ln5606">      int topfill = wp-&gt;w_topfill - wp-&gt;w_last_topfill;</a>
<a name="ln5607">      int leftcol = wp-&gt;w_leftcol - wp-&gt;w_last_leftcol;</a>
<a name="ln5608">      int skipcol = wp-&gt;w_skipcol - wp-&gt;w_last_skipcol;</a>
<a name="ln5609">      dict_T *d = make_win_info_dict(width, height, topline,</a>
<a name="ln5610">                                     topfill, leftcol, skipcol);</a>
<a name="ln5611">      if (d == NULL) {</a>
<a name="ln5612">        break;</a>
<a name="ln5613">      }</a>
<a name="ln5614">      char winid[NUMBUFLEN];</a>
<a name="ln5615">      int key_len = vim_snprintf(winid, sizeof(winid), &quot;%d&quot;, wp-&gt;handle);</a>
<a name="ln5616">      if (tv_dict_add_dict(v_event, winid, (size_t)key_len, d) == FAIL) {</a>
<a name="ln5617">        tv_dict_unref(d);</a>
<a name="ln5618">        break;</a>
<a name="ln5619">      }</a>
<a name="ln5620">      d-&gt;dv_refcount--;</a>
<a name="ln5621"> </a>
<a name="ln5622">      tot_width += abs(width);</a>
<a name="ln5623">      tot_height += abs(height);</a>
<a name="ln5624">      tot_topline += abs(topline);</a>
<a name="ln5625">      tot_topfill += abs(topfill);</a>
<a name="ln5626">      tot_leftcol += abs(leftcol);</a>
<a name="ln5627">      tot_skipcol += abs(skipcol);</a>
<a name="ln5628">    }</a>
<a name="ln5629">  }</a>
<a name="ln5630"> </a>
<a name="ln5631">  if (v_event != NULL) {</a>
<a name="ln5632">    dict_T *alldict = make_win_info_dict(tot_width, tot_height, tot_topline,</a>
<a name="ln5633">                                         tot_topfill, tot_leftcol, tot_skipcol);</a>
<a name="ln5634">    if (alldict != NULL) {</a>
<a name="ln5635">      if (tv_dict_add_dict(v_event, S_LEN(&quot;all&quot;), alldict) == FAIL) {</a>
<a name="ln5636">        tv_dict_unref(alldict);</a>
<a name="ln5637">      } else {</a>
<a name="ln5638">        alldict-&gt;dv_refcount--;</a>
<a name="ln5639">      }</a>
<a name="ln5640">    }</a>
<a name="ln5641">  }</a>
<a name="ln5642"> </a>
<a name="ln5643">  return result;</a>
<a name="ln5644">}</a>
<a name="ln5645"> </a>
<a name="ln5646">/// Trigger WinScrolled and/or WinResized if any window in the current tab page</a>
<a name="ln5647">/// scrolled or changed size.</a>
<a name="ln5648">void may_trigger_win_scrolled_resized(void)</a>
<a name="ln5649">{</a>
<a name="ln5650">  static bool recursive = false;</a>
<a name="ln5651">  const bool do_resize = has_event(EVENT_WINRESIZED);</a>
<a name="ln5652">  const bool do_scroll = has_event(EVENT_WINSCROLLED);</a>
<a name="ln5653"> </a>
<a name="ln5654">  if (recursive</a>
<a name="ln5655">      || !(do_scroll || do_resize)</a>
<a name="ln5656">      || !did_initial_scroll_size_snapshot) {</a>
<a name="ln5657">    return;</a>
<a name="ln5658">  }</a>
<a name="ln5659"> </a>
<a name="ln5660">  int size_count = 0;</a>
<a name="ln5661">  win_T *first_scroll_win = NULL, *first_size_win = NULL;</a>
<a name="ln5662">  int cwsr = check_window_scroll_resize(&amp;size_count,</a>
<a name="ln5663">                                        &amp;first_scroll_win, &amp;first_size_win,</a>
<a name="ln5664">                                        NULL, NULL);</a>
<a name="ln5665">  int trigger_resize = do_resize &amp;&amp; size_count &gt; 0;</a>
<a name="ln5666">  int trigger_scroll = do_scroll &amp;&amp; cwsr != 0;</a>
<a name="ln5667">  if (!trigger_resize &amp;&amp; !trigger_scroll) {</a>
<a name="ln5668">    return;  // no relevant changes</a>
<a name="ln5669">  }</a>
<a name="ln5670"> </a>
<a name="ln5671">  list_T *windows_list = NULL;</a>
<a name="ln5672">  if (trigger_resize) {</a>
<a name="ln5673">    // Create the list for v:event.windows before making the snapshot.</a>
<a name="ln5674">    // windows_list = tv_list_alloc_with_items(size_count);</a>
<a name="ln5675">    windows_list = tv_list_alloc(size_count);</a>
<a name="ln5676">    (void)check_window_scroll_resize(NULL, NULL, NULL, windows_list, NULL);</a>
<a name="ln5677">  }</a>
<a name="ln5678"> </a>
<a name="ln5679">  dict_T *scroll_dict = NULL;</a>
<a name="ln5680">  if (trigger_scroll) {</a>
<a name="ln5681">    // Create the dict with entries for v:event before making the snapshot.</a>
<a name="ln5682">    scroll_dict = tv_dict_alloc();</a>
<a name="ln5683">    scroll_dict-&gt;dv_refcount = 1;</a>
<a name="ln5684">    (void)check_window_scroll_resize(NULL, NULL, NULL, NULL, scroll_dict);</a>
<a name="ln5685">  }</a>
<a name="ln5686"> </a>
<a name="ln5687">  // WinScrolled/WinResized are triggered only once, even when multiple</a>
<a name="ln5688">  // windows scrolled or changed size.  Store the current values before</a>
<a name="ln5689">  // triggering the event, if a scroll or resize happens as a side effect</a>
<a name="ln5690">  // then WinScrolled/WinResized is triggered for that later.</a>
<a name="ln5691">  snapshot_windows_scroll_size();</a>
<a name="ln5692"> </a>
<a name="ln5693">  recursive = true;</a>
<a name="ln5694"> </a>
<a name="ln5695">  // If both are to be triggered do WinResized first.</a>
<a name="ln5696">  if (trigger_resize) {</a>
<a name="ln5697">    save_v_event_T save_v_event;</a>
<a name="ln5698">    dict_T *v_event = get_v_event(&amp;save_v_event);</a>
<a name="ln5699"> </a>
<a name="ln5700">    if (tv_dict_add_list(v_event, S_LEN(&quot;windows&quot;), windows_list) == OK) {</a>
<a name="ln5701">      tv_dict_set_keys_readonly(v_event);</a>
<a name="ln5702"> </a>
<a name="ln5703">      char winid[NUMBUFLEN];</a>
<a name="ln5704">      vim_snprintf(winid, sizeof(winid), &quot;%d&quot;, first_size_win-&gt;handle);</a>
<a name="ln5705">      apply_autocmds(EVENT_WINRESIZED, winid, winid, false, first_size_win-&gt;w_buffer);</a>
<a name="ln5706">    }</a>
<a name="ln5707">    restore_v_event(v_event, &amp;save_v_event);</a>
<a name="ln5708">  }</a>
<a name="ln5709"> </a>
<a name="ln5710">  if (trigger_scroll) {</a>
<a name="ln5711">    save_v_event_T save_v_event;</a>
<a name="ln5712">    dict_T *v_event = get_v_event(&amp;save_v_event);</a>
<a name="ln5713"> </a>
<a name="ln5714">    // Move the entries from scroll_dict to v_event.</a>
<a name="ln5715">    tv_dict_extend(v_event, scroll_dict, &quot;move&quot;);</a>
<a name="ln5716">    tv_dict_set_keys_readonly(v_event);</a>
<a name="ln5717">    tv_dict_unref(scroll_dict);</a>
<a name="ln5718"> </a>
<a name="ln5719">    char winid[NUMBUFLEN];</a>
<a name="ln5720">    vim_snprintf(winid, sizeof(winid), &quot;%d&quot;, first_scroll_win-&gt;handle);</a>
<a name="ln5721">    apply_autocmds(EVENT_WINSCROLLED, winid, winid, false, first_scroll_win-&gt;w_buffer);</a>
<a name="ln5722"> </a>
<a name="ln5723">    restore_v_event(v_event, &amp;save_v_event);</a>
<a name="ln5724">  }</a>
<a name="ln5725"> </a>
<a name="ln5726">  recursive = false;</a>
<a name="ln5727">}</a>
<a name="ln5728"> </a>
<a name="ln5729">// Save the size of all windows in &quot;gap&quot;.</a>
<a name="ln5730">void win_size_save(garray_T *gap)</a>
<a name="ln5731">{</a>
<a name="ln5732">  ga_init(gap, (int)sizeof(int), 1);</a>
<a name="ln5733">  ga_grow(gap, win_count() * 2 + 1);</a>
<a name="ln5734">  // first entry is the total lines available for windows</a>
<a name="ln5735">  ((int *)gap-&gt;ga_data)[gap-&gt;ga_len++] =</a>
<a name="ln5736">    (int)ROWS_AVAIL + global_stl_height() - last_stl_height(false);</a>
<a name="ln5737"> </a>
<a name="ln5738">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5739">    ((int *)gap-&gt;ga_data)[gap-&gt;ga_len++] =</a>
<a name="ln5740">      wp-&gt;w_width + wp-&gt;w_vsep_width;</a>
<a name="ln5741">    ((int *)gap-&gt;ga_data)[gap-&gt;ga_len++] = wp-&gt;w_height;</a>
<a name="ln5742">  }</a>
<a name="ln5743">}</a>
<a name="ln5744"> </a>
<a name="ln5745">// Restore window sizes, but only if the number of windows is still the same</a>
<a name="ln5746">// and total lines available for windows didn't change.</a>
<a name="ln5747">// Does not free the growarray.</a>
<a name="ln5748">void win_size_restore(garray_T *gap)</a>
<a name="ln5749">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5750">{</a>
<a name="ln5751">  if (win_count() * 2 + 1 == gap-&gt;ga_len</a>
<a name="ln5752">      &amp;&amp; ((int *)gap-&gt;ga_data)[0] ==</a>
<a name="ln5753">      ROWS_AVAIL + global_stl_height() - last_stl_height(false)) {</a>
<a name="ln5754">    // The order matters, because frames contain other frames, but it's</a>
<a name="ln5755">    // difficult to get right. The easy way out is to do it twice.</a>
<a name="ln5756">    for (int j = 0; j &lt; 2; j++) {</a>
<a name="ln5757">      int i = 1;</a>
<a name="ln5758">      FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln5759">        int width = ((int *)gap-&gt;ga_data)[i++];</a>
<a name="ln5760">        int height = ((int *)gap-&gt;ga_data)[i++];</a>
<a name="ln5761">        if (!wp-&gt;w_floating) {</a>
<a name="ln5762">          frame_setwidth(wp-&gt;w_frame, width);</a>
<a name="ln5763">          win_setheight_win(height, wp);</a>
<a name="ln5764">        }</a>
<a name="ln5765">      }</a>
<a name="ln5766">    }</a>
<a name="ln5767">    // recompute the window positions</a>
<a name="ln5768">    (void)win_comp_pos();</a>
<a name="ln5769">  }</a>
<a name="ln5770">}</a>
<a name="ln5771"> </a>
<a name="ln5772">// Update the position for all windows, using the width and height of the frames.</a>
<a name="ln5773">// Returns the row just after the last window and global statusline (if there is one).</a>
<a name="ln5774">int win_comp_pos(void)</a>
<a name="ln5775">{</a>
<a name="ln5776">  int row = tabline_height();</a>
<a name="ln5777">  int col = 0;</a>
<a name="ln5778"> </a>
<a name="ln5779">  frame_comp_pos(topframe, &amp;row, &amp;col);</a>
<a name="ln5780"> </a>
<a name="ln5781">  for (win_T *wp = lastwin; wp &amp;&amp; wp-&gt;w_floating; wp = wp-&gt;w_prev) {</a>
<a name="ln5782">    // float might be anchored to moved window</a>
<a name="ln5783">    if (wp-&gt;w_float_config.relative == kFloatRelativeWindow) {</a>
<a name="ln5784">      wp-&gt;w_pos_changed = true;</a>
<a name="ln5785">    }</a>
<a name="ln5786">  }</a>
<a name="ln5787"> </a>
<a name="ln5788">  return row + global_stl_height();</a>
<a name="ln5789">}</a>
<a name="ln5790"> </a>
<a name="ln5791">void win_reconfig_floats(void)</a>
<a name="ln5792">{</a>
<a name="ln5793">  for (win_T *wp = lastwin; wp &amp;&amp; wp-&gt;w_floating; wp = wp-&gt;w_prev) {</a>
<a name="ln5794">    win_config_float(wp, wp-&gt;w_float_config);</a>
<a name="ln5795">  }</a>
<a name="ln5796">}</a>
<a name="ln5797"> </a>
<a name="ln5798">// Update the position of the windows in frame &quot;topfrp&quot;, using the width and</a>
<a name="ln5799">// height of the frames.</a>
<a name="ln5800">// &quot;*row&quot; and &quot;*col&quot; are the top-left position of the frame.  They are updated</a>
<a name="ln5801">// to the bottom-right position plus one.</a>
<a name="ln5802">static void frame_comp_pos(frame_T *topfrp, int *row, int *col)</a>
<a name="ln5803">{</a>
<a name="ln5804">  win_T *wp = topfrp-&gt;fr_win;</a>
<a name="ln5805">  if (wp != NULL) {</a>
<a name="ln5806">    if (wp-&gt;w_winrow != *row</a>
<a name="ln5807">        || wp-&gt;w_wincol != *col) {</a>
<a name="ln5808">      // position changed, redraw</a>
<a name="ln5809">      wp-&gt;w_winrow = *row;</a>
<a name="ln5810">      wp-&gt;w_wincol = *col;</a>
<a name="ln5811">      redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln5812">      wp-&gt;w_redr_status = true;</a>
<a name="ln5813">      wp-&gt;w_pos_changed = true;</a>
<a name="ln5814">    }</a>
<a name="ln5815">    const int h = wp-&gt;w_height + wp-&gt;w_hsep_height + wp-&gt;w_status_height;</a>
<a name="ln5816">    *row += h &gt; topfrp-&gt;fr_height ? topfrp-&gt;fr_height : h;</a>
<a name="ln5817">    *col += wp-&gt;w_width + wp-&gt;w_vsep_width;</a>
<a name="ln5818">  } else {</a>
<a name="ln5819">    int startrow = *row;</a>
<a name="ln5820">    int startcol = *col;</a>
<a name="ln5821">    frame_T *frp;</a>
<a name="ln5822">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln5823">      if (topfrp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln5824">        *row = startrow;  // all frames are at the same row</a>
<a name="ln5825">      } else {</a>
<a name="ln5826">        *col = startcol;  // all frames are at the same col</a>
<a name="ln5827">      }</a>
<a name="ln5828">      frame_comp_pos(frp, row, col);</a>
<a name="ln5829">    }</a>
<a name="ln5830">  }</a>
<a name="ln5831">}</a>
<a name="ln5832"> </a>
<a name="ln5833">// Set current window height and take care of repositioning other windows to</a>
<a name="ln5834">// fit around it.</a>
<a name="ln5835">void win_setheight(int height)</a>
<a name="ln5836">{</a>
<a name="ln5837">  win_setheight_win(height, curwin);</a>
<a name="ln5838">}</a>
<a name="ln5839"> </a>
<a name="ln5840">// Set the window height of window &quot;win&quot; and take care of repositioning other</a>
<a name="ln5841">// windows to fit around it.</a>
<a name="ln5842">void win_setheight_win(int height, win_T *win)</a>
<a name="ln5843">{</a>
<a name="ln5844">  // Always keep current window at least one line high, even when 'winminheight' is zero.</a>
<a name="ln5845">  // Keep window at least two lines high if 'winbar' is enabled.</a>
<a name="ln5846">  height = MAX(height, (int)(win == curwin ? MAX(p_wmh, 1) : p_wmh) + win-&gt;w_winbar_height);</a>
<a name="ln5847"> </a>
<a name="ln5848">  if (win-&gt;w_floating) {</a>
<a name="ln5849">    win-&gt;w_float_config.height = height;</a>
<a name="ln5850">    win_config_float(win, win-&gt;w_float_config);</a>
<a name="ln5851">    redraw_later(win, UPD_VALID);</a>
<a name="ln5852">  } else {</a>
<a name="ln5853">    frame_setheight(win-&gt;w_frame, height + win-&gt;w_hsep_height + win-&gt;w_status_height);</a>
<a name="ln5854"> </a>
<a name="ln5855">    // recompute the window positions</a>
<a name="ln5856">    int row = win_comp_pos();</a>
<a name="ln5857"> </a>
<a name="ln5858">    // If there is extra space created between the last window and the command</a>
<a name="ln5859">    // line, clear it.</a>
<a name="ln5860">    if (full_screen &amp;&amp; msg_scrolled == 0 &amp;&amp; row &lt; cmdline_row) {</a>
<a name="ln5861">      grid_fill(&amp;default_grid, row, cmdline_row, 0, Columns, ' ', ' ', 0);</a>
<a name="ln5862">      if (msg_grid.chars) {</a>
<a name="ln5863">        clear_cmdline = true;</a>
<a name="ln5864">      }</a>
<a name="ln5865">    }</a>
<a name="ln5866">    cmdline_row = row;</a>
<a name="ln5867">    p_ch = MAX(Rows - cmdline_row, 0);</a>
<a name="ln5868">    curtab-&gt;tp_ch_used = p_ch;</a>
<a name="ln5869">    msg_row = row;</a>
<a name="ln5870">    msg_col = 0;</a>
<a name="ln5871"> </a>
<a name="ln5872">    win_fix_scroll(true);</a>
<a name="ln5873"> </a>
<a name="ln5874">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln5875">    redraw_cmdline = true;</a>
<a name="ln5876">  }</a>
<a name="ln5877">}</a>
<a name="ln5878"> </a>
<a name="ln5879">// Set the height of a frame to &quot;height&quot; and take care that all frames and</a>
<a name="ln5880">// windows inside it are resized.  Also resize frames on the left and right if</a>
<a name="ln5881">// the are in the same FR_ROW frame.</a>
<a name="ln5882">//</a>
<a name="ln5883">// Strategy:</a>
<a name="ln5884">// If the frame is part of a FR_COL frame, try fitting the frame in that</a>
<a name="ln5885">// frame.  If that doesn't work (the FR_COL frame is too small), recursively</a>
<a name="ln5886">// go to containing frames to resize them and make room.</a>
<a name="ln5887">// If the frame is part of a FR_ROW frame, all frames must be resized as well.</a>
<a name="ln5888">// Check for the minimal height of the FR_ROW frame.</a>
<a name="ln5889">// At the top level we can also use change the command line height.</a>
<a name="ln5890">static void frame_setheight(frame_T *curfrp, int height)</a>
<a name="ln5891">{</a>
<a name="ln5892">  // If the height already is the desired value, nothing to do.</a>
<a name="ln5893">  if (curfrp-&gt;fr_height == height) {</a>
<a name="ln5894">    return;</a>
<a name="ln5895">  }</a>
<a name="ln5896"> </a>
<a name="ln5897">  if (curfrp-&gt;fr_parent == NULL) {</a>
<a name="ln5898">    // topframe: can only change the command line height</a>
<a name="ln5899">    // Avoid doing so with external messages.</a>
<a name="ln5900">    if (ui_has(kUIMessages)) {</a>
<a name="ln5901">      return;</a>
<a name="ln5902">    }</a>
<a name="ln5903">    if (height &gt; ROWS_AVAIL) {</a>
<a name="ln5904">      // If height is greater than the available space, try to create space for</a>
<a name="ln5905">      // the frame by reducing 'cmdheight' if possible, while making sure</a>
<a name="ln5906">      // `cmdheight` doesn't go below 1 if it wasn't set to 0 explicitly.</a>
<a name="ln5907">      height = (int)MIN(ROWS_AVAIL + p_ch - !p_ch_was_zero, height);</a>
<a name="ln5908">    }</a>
<a name="ln5909">    if (height &gt; 0) {</a>
<a name="ln5910">      frame_new_height(curfrp, height, false, false);</a>
<a name="ln5911">    }</a>
<a name="ln5912">  } else if (curfrp-&gt;fr_parent-&gt;fr_layout == FR_ROW) {</a>
<a name="ln5913">    // Row of frames: Also need to resize frames left and right of this</a>
<a name="ln5914">    // one.  First check for the minimal height of these.</a>
<a name="ln5915">    int h = frame_minheight(curfrp-&gt;fr_parent, NULL);</a>
<a name="ln5916">    if (height &lt; h) {</a>
<a name="ln5917">      height = h;</a>
<a name="ln5918">    }</a>
<a name="ln5919">    frame_setheight(curfrp-&gt;fr_parent, height);</a>
<a name="ln5920">  } else {</a>
<a name="ln5921">    // Column of frames: try to change only frames in this column.</a>
<a name="ln5922"> </a>
<a name="ln5923">    int room;                     // total number of lines available</a>
<a name="ln5924">    int room_cmdline;             // lines available from cmdline</a>
<a name="ln5925">    int room_reserved;</a>
<a name="ln5926"> </a>
<a name="ln5927">    // Do this twice:</a>
<a name="ln5928">    // 1: compute room available, if it's not enough try resizing the</a>
<a name="ln5929">    //    containing frame.</a>
<a name="ln5930">    // 2: compute the room available and adjust the height to it.</a>
<a name="ln5931">    // Try not to reduce the height of a window with 'winfixheight' set.</a>
<a name="ln5932">    for (int run = 1; run &lt;= 2; run++) {</a>
<a name="ln5933">      room = 0;</a>
<a name="ln5934">      room_reserved = 0;</a>
<a name="ln5935">      frame_T *frp;</a>
<a name="ln5936">      FOR_ALL_FRAMES(frp, curfrp-&gt;fr_parent-&gt;fr_child) {</a>
<a name="ln5937">        if (frp != curfrp</a>
<a name="ln5938">            &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln5939">            &amp;&amp; frp-&gt;fr_win-&gt;w_p_wfh) {</a>
<a name="ln5940">          room_reserved += frp-&gt;fr_height;</a>
<a name="ln5941">        }</a>
<a name="ln5942">        room += frp-&gt;fr_height;</a>
<a name="ln5943">        if (frp != curfrp) {</a>
<a name="ln5944">          room -= frame_minheight(frp, NULL);</a>
<a name="ln5945">        }</a>
<a name="ln5946">      }</a>
<a name="ln5947">      if (curfrp-&gt;fr_width != Columns) {</a>
<a name="ln5948">        room_cmdline = 0;</a>
<a name="ln5949">      } else {</a>
<a name="ln5950">        win_T *wp = lastwin_nofloating();</a>
<a name="ln5951">        room_cmdline = Rows - (int)p_ch - global_stl_height()</a>
<a name="ln5952">                       - (wp-&gt;w_winrow + wp-&gt;w_height + wp-&gt;w_hsep_height + wp-&gt;w_status_height);</a>
<a name="ln5953">        if (room_cmdline &lt; 0) {</a>
<a name="ln5954">          room_cmdline = 0;</a>
<a name="ln5955">        }</a>
<a name="ln5956">      }</a>
<a name="ln5957"> </a>
<a name="ln5958">      if (height &lt;= room + room_cmdline) {</a>
<a name="ln5959">        break;</a>
<a name="ln5960">      }</a>
<a name="ln5961">      if (run == 2 || curfrp-&gt;fr_width == Columns) {</a>
<a name="ln5962">        height = room + room_cmdline;</a>
<a name="ln5963">        break;</a>
<a name="ln5964">      }</a>
<a name="ln5965">      frame_setheight(curfrp-&gt;fr_parent, height</a>
<a name="ln5966">                      + frame_minheight(curfrp-&gt;fr_parent, NOWIN) - (int)p_wmh - 1);</a>
<a name="ln5967">      // NOTREACHED</a>
<a name="ln5968">    }</a>
<a name="ln5969"> </a>
<a name="ln5970">    // Compute the number of lines we will take from others frames (can be</a>
<a name="ln5971">    // negative!).</a>
<a name="ln5972">    int take = height - curfrp-&gt;fr_height;</a>
<a name="ln5973"> </a>
<a name="ln5974">    // If there is not enough room, also reduce the height of a window</a>
<a name="ln5975">    // with 'winfixheight' set.</a>
<a name="ln5976">    if (height &gt; room + room_cmdline - room_reserved) {</a>
<a name="ln5977">      room_reserved = room + room_cmdline - height;</a>
<a name="ln5978">    }</a>
<a name="ln5979">    // If there is only a 'winfixheight' window and making the</a>
<a name="ln5980">    // window smaller, need to make the other window taller.</a>
<a name="ln5981">    if (take &lt; 0 &amp;&amp; room - curfrp-&gt;fr_height &lt; room_reserved) {</a>
<a name="ln5982">      room_reserved = 0;</a>
<a name="ln5983">    }</a>
<a name="ln5984"> </a>
<a name="ln5985">    if (take &gt; 0 &amp;&amp; room_cmdline &gt; 0) {</a>
<a name="ln5986">      // use lines from cmdline first</a>
<a name="ln5987">      if (take &lt; room_cmdline) {</a>
<a name="ln5988">        room_cmdline = take;</a>
<a name="ln5989">      }</a>
<a name="ln5990">      take -= room_cmdline;</a>
<a name="ln5991">      topframe-&gt;fr_height += room_cmdline;</a>
<a name="ln5992">    }</a>
<a name="ln5993"> </a>
<a name="ln5994">    // set the current frame to the new height</a>
<a name="ln5995">    frame_new_height(curfrp, height, false, false);</a>
<a name="ln5996"> </a>
<a name="ln5997">    // First take lines from the frames after the current frame.  If</a>
<a name="ln5998">    // that is not enough, takes lines from frames above the current</a>
<a name="ln5999">    // frame.</a>
<a name="ln6000">    for (int run = 0; run &lt; 2; run++) {</a>
<a name="ln6001">      // 1st run: start with next window</a>
<a name="ln6002">      // 2nd run: start with prev window</a>
<a name="ln6003">      frame_T *frp = run == 0 ? curfrp-&gt;fr_next : curfrp-&gt;fr_prev;</a>
<a name="ln6004"> </a>
<a name="ln6005">      while (frp != NULL &amp;&amp; take != 0) {</a>
<a name="ln6006">        int h = frame_minheight(frp, NULL);</a>
<a name="ln6007">        if (room_reserved &gt; 0</a>
<a name="ln6008">            &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln6009">            &amp;&amp; frp-&gt;fr_win-&gt;w_p_wfh) {</a>
<a name="ln6010">          if (room_reserved &gt;= frp-&gt;fr_height) {</a>
<a name="ln6011">            room_reserved -= frp-&gt;fr_height;</a>
<a name="ln6012">          } else {</a>
<a name="ln6013">            if (frp-&gt;fr_height - room_reserved &gt; take) {</a>
<a name="ln6014">              room_reserved = frp-&gt;fr_height - take;</a>
<a name="ln6015">            }</a>
<a name="ln6016">            take -= frp-&gt;fr_height - room_reserved;</a>
<a name="ln6017">            frame_new_height(frp, room_reserved, false, false);</a>
<a name="ln6018">            room_reserved = 0;</a>
<a name="ln6019">          }</a>
<a name="ln6020">        } else {</a>
<a name="ln6021">          if (frp-&gt;fr_height - take &lt; h) {</a>
<a name="ln6022">            take -= frp-&gt;fr_height - h;</a>
<a name="ln6023">            frame_new_height(frp, h, false, false);</a>
<a name="ln6024">          } else {</a>
<a name="ln6025">            frame_new_height(frp, frp-&gt;fr_height - take, false, false);</a>
<a name="ln6026">            take = 0;</a>
<a name="ln6027">          }</a>
<a name="ln6028">        }</a>
<a name="ln6029">        if (run == 0) {</a>
<a name="ln6030">          frp = frp-&gt;fr_next;</a>
<a name="ln6031">        } else {</a>
<a name="ln6032">          frp = frp-&gt;fr_prev;</a>
<a name="ln6033">        }</a>
<a name="ln6034">      }</a>
<a name="ln6035">    }</a>
<a name="ln6036">  }</a>
<a name="ln6037">}</a>
<a name="ln6038"> </a>
<a name="ln6039">// Set current window width and take care of repositioning other windows to</a>
<a name="ln6040">// fit around it.</a>
<a name="ln6041">void win_setwidth(int width)</a>
<a name="ln6042">{</a>
<a name="ln6043">  win_setwidth_win(width, curwin);</a>
<a name="ln6044">}</a>
<a name="ln6045"> </a>
<a name="ln6046">void win_setwidth_win(int width, win_T *wp)</a>
<a name="ln6047">{</a>
<a name="ln6048">  // Always keep current window at least one column wide, even when</a>
<a name="ln6049">  // 'winminwidth' is zero.</a>
<a name="ln6050">  if (wp == curwin) {</a>
<a name="ln6051">    if (width &lt; p_wmw) {</a>
<a name="ln6052">      width = (int)p_wmw;</a>
<a name="ln6053">    }</a>
<a name="ln6054">    if (width == 0) {</a>
<a name="ln6055">      width = 1;</a>
<a name="ln6056">    }</a>
<a name="ln6057">  } else if (width &lt; 0) {</a>
<a name="ln6058">    width = 0;</a>
<a name="ln6059">  }</a>
<a name="ln6060">  if (wp-&gt;w_floating) {</a>
<a name="ln6061">    wp-&gt;w_float_config.width = width;</a>
<a name="ln6062">    win_config_float(wp, wp-&gt;w_float_config);</a>
<a name="ln6063">    redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln6064">  } else {</a>
<a name="ln6065">    frame_setwidth(wp-&gt;w_frame, width + wp-&gt;w_vsep_width);</a>
<a name="ln6066"> </a>
<a name="ln6067">    // recompute the window positions</a>
<a name="ln6068">    (void)win_comp_pos();</a>
<a name="ln6069">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln6070">  }</a>
<a name="ln6071">}</a>
<a name="ln6072"> </a>
<a name="ln6073">// Set the width of a frame to &quot;width&quot; and take care that all frames and</a>
<a name="ln6074">// windows inside it are resized.  Also resize frames above and below if the</a>
<a name="ln6075">// are in the same FR_ROW frame.</a>
<a name="ln6076">//</a>
<a name="ln6077">// Strategy is similar to frame_setheight().</a>
<a name="ln6078">static void frame_setwidth(frame_T *curfrp, int width)</a>
<a name="ln6079">{</a>
<a name="ln6080">  // If the width already is the desired value, nothing to do.</a>
<a name="ln6081">  if (curfrp-&gt;fr_width == width) {</a>
<a name="ln6082">    return;</a>
<a name="ln6083">  }</a>
<a name="ln6084"> </a>
<a name="ln6085">  if (curfrp-&gt;fr_parent == NULL) {</a>
<a name="ln6086">    // topframe: can't change width</a>
<a name="ln6087">    return;</a>
<a name="ln6088">  }</a>
<a name="ln6089"> </a>
<a name="ln6090">  if (curfrp-&gt;fr_parent-&gt;fr_layout == FR_COL) {</a>
<a name="ln6091">    // Column of frames: Also need to resize frames above and below of</a>
<a name="ln6092">    // this one.  First check for the minimal width of these.</a>
<a name="ln6093">    int w = frame_minwidth(curfrp-&gt;fr_parent, NULL);</a>
<a name="ln6094">    if (width &lt; w) {</a>
<a name="ln6095">      width = w;</a>
<a name="ln6096">    }</a>
<a name="ln6097">    frame_setwidth(curfrp-&gt;fr_parent, width);</a>
<a name="ln6098">  } else {</a>
<a name="ln6099">    // Row of frames: try to change only frames in this row.</a>
<a name="ln6100">    //</a>
<a name="ln6101">    // Do this twice:</a>
<a name="ln6102">    // 1: compute room available, if it's not enough try resizing the</a>
<a name="ln6103">    //    containing frame.</a>
<a name="ln6104">    // 2: compute the room available and adjust the width to it.</a>
<a name="ln6105"> </a>
<a name="ln6106">    int room;  // total number of lines available</a>
<a name="ln6107">    int room_reserved;</a>
<a name="ln6108">    for (int run = 1; run &lt;= 2; run++) {</a>
<a name="ln6109">      room = 0;</a>
<a name="ln6110">      room_reserved = 0;</a>
<a name="ln6111">      frame_T *frp;</a>
<a name="ln6112">      FOR_ALL_FRAMES(frp, curfrp-&gt;fr_parent-&gt;fr_child) {</a>
<a name="ln6113">        if (frp != curfrp</a>
<a name="ln6114">            &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln6115">            &amp;&amp; frp-&gt;fr_win-&gt;w_p_wfw) {</a>
<a name="ln6116">          room_reserved += frp-&gt;fr_width;</a>
<a name="ln6117">        }</a>
<a name="ln6118">        room += frp-&gt;fr_width;</a>
<a name="ln6119">        if (frp != curfrp) {</a>
<a name="ln6120">          room -= frame_minwidth(frp, NULL);</a>
<a name="ln6121">        }</a>
<a name="ln6122">      }</a>
<a name="ln6123"> </a>
<a name="ln6124">      if (width &lt;= room) {</a>
<a name="ln6125">        break;</a>
<a name="ln6126">      }</a>
<a name="ln6127">      if (run == 2 || curfrp-&gt;fr_height &gt;= ROWS_AVAIL) {</a>
<a name="ln6128">        width = room;</a>
<a name="ln6129">        break;</a>
<a name="ln6130">      }</a>
<a name="ln6131">      frame_setwidth(curfrp-&gt;fr_parent, width</a>
<a name="ln6132">                     + frame_minwidth(curfrp-&gt;fr_parent, NOWIN) - (int)p_wmw - 1);</a>
<a name="ln6133">    }</a>
<a name="ln6134"> </a>
<a name="ln6135">    // Compute the number of lines we will take from others frames (can be</a>
<a name="ln6136">    // negative!).</a>
<a name="ln6137">    int take = width - curfrp-&gt;fr_width;</a>
<a name="ln6138"> </a>
<a name="ln6139">    // If there is not enough room, also reduce the width of a window</a>
<a name="ln6140">    // with 'winfixwidth' set.</a>
<a name="ln6141">    if (width &gt; room - room_reserved) {</a>
<a name="ln6142">      room_reserved = room - width;</a>
<a name="ln6143">    }</a>
<a name="ln6144">    // If there is only a 'winfixwidth' window and making the</a>
<a name="ln6145">    // window smaller, need to make the other window narrower.</a>
<a name="ln6146">    if (take &lt; 0 &amp;&amp; room - curfrp-&gt;fr_width &lt; room_reserved) {</a>
<a name="ln6147">      room_reserved = 0;</a>
<a name="ln6148">    }</a>
<a name="ln6149"> </a>
<a name="ln6150">    // set the current frame to the new width</a>
<a name="ln6151">    frame_new_width(curfrp, width, false, false);</a>
<a name="ln6152"> </a>
<a name="ln6153">    // First take lines from the frames right of the current frame.  If</a>
<a name="ln6154">    // that is not enough, takes lines from frames left of the current</a>
<a name="ln6155">    // frame.</a>
<a name="ln6156">    for (int run = 0; run &lt; 2; run++) {</a>
<a name="ln6157">      // 1st run: start with next window</a>
<a name="ln6158">      // 2nd run: start with prev window</a>
<a name="ln6159">      frame_T *frp = run == 0 ? curfrp-&gt;fr_next : curfrp-&gt;fr_prev;</a>
<a name="ln6160"> </a>
<a name="ln6161">      while (frp != NULL &amp;&amp; take != 0) {</a>
<a name="ln6162">        int w = frame_minwidth(frp, NULL);</a>
<a name="ln6163">        if (room_reserved &gt; 0</a>
<a name="ln6164">            &amp;&amp; frp-&gt;fr_win != NULL</a>
<a name="ln6165">            &amp;&amp; frp-&gt;fr_win-&gt;w_p_wfw) {</a>
<a name="ln6166">          if (room_reserved &gt;= frp-&gt;fr_width) {</a>
<a name="ln6167">            room_reserved -= frp-&gt;fr_width;</a>
<a name="ln6168">          } else {</a>
<a name="ln6169">            if (frp-&gt;fr_width - room_reserved &gt; take) {</a>
<a name="ln6170">              room_reserved = frp-&gt;fr_width - take;</a>
<a name="ln6171">            }</a>
<a name="ln6172">            take -= frp-&gt;fr_width - room_reserved;</a>
<a name="ln6173">            frame_new_width(frp, room_reserved, false, false);</a>
<a name="ln6174">            room_reserved = 0;</a>
<a name="ln6175">          }</a>
<a name="ln6176">        } else {</a>
<a name="ln6177">          if (frp-&gt;fr_width - take &lt; w) {</a>
<a name="ln6178">            take -= frp-&gt;fr_width - w;</a>
<a name="ln6179">            frame_new_width(frp, w, false, false);</a>
<a name="ln6180">          } else {</a>
<a name="ln6181">            frame_new_width(frp, frp-&gt;fr_width - take, false, false);</a>
<a name="ln6182">            take = 0;</a>
<a name="ln6183">          }</a>
<a name="ln6184">        }</a>
<a name="ln6185">        if (run == 0) {</a>
<a name="ln6186">          frp = frp-&gt;fr_next;</a>
<a name="ln6187">        } else {</a>
<a name="ln6188">          frp = frp-&gt;fr_prev;</a>
<a name="ln6189">        }</a>
<a name="ln6190">      }</a>
<a name="ln6191">    }</a>
<a name="ln6192">  }</a>
<a name="ln6193">}</a>
<a name="ln6194"> </a>
<a name="ln6195">// Check 'winminheight' for a valid value and reduce it if needed.</a>
<a name="ln6196">const char *did_set_winminheight(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln6197">{</a>
<a name="ln6198">  bool first = true;</a>
<a name="ln6199"> </a>
<a name="ln6200">  // loop until there is a 'winminheight' that is possible</a>
<a name="ln6201">  while (p_wmh &gt; 0) {</a>
<a name="ln6202">    const int room = Rows - (int)p_ch;</a>
<a name="ln6203">    const int needed = min_rows();</a>
<a name="ln6204">    if (room &gt;= needed) {</a>
<a name="ln6205">      break;</a>
<a name="ln6206">    }</a>
<a name="ln6207">    p_wmh--;</a>
<a name="ln6208">    if (first) {</a>
<a name="ln6209">      emsg(_(e_noroom));</a>
<a name="ln6210">      first = false;</a>
<a name="ln6211">    }</a>
<a name="ln6212">  }</a>
<a name="ln6213">  return NULL;</a>
<a name="ln6214">}</a>
<a name="ln6215"> </a>
<a name="ln6216">// Check 'winminwidth' for a valid value and reduce it if needed.</a>
<a name="ln6217">const char *did_set_winminwidth(optset_T *args FUNC_ATTR_UNUSED)</a>
<a name="ln6218">{</a>
<a name="ln6219">  bool first = true;</a>
<a name="ln6220"> </a>
<a name="ln6221">  // loop until there is a 'winminheight' that is possible</a>
<a name="ln6222">  while (p_wmw &gt; 0) {</a>
<a name="ln6223">    const int room = Columns;</a>
<a name="ln6224">    const int needed = frame_minwidth(topframe, NULL);</a>
<a name="ln6225">    if (room &gt;= needed) {</a>
<a name="ln6226">      break;</a>
<a name="ln6227">    }</a>
<a name="ln6228">    p_wmw--;</a>
<a name="ln6229">    if (first) {</a>
<a name="ln6230">      emsg(_(e_noroom));</a>
<a name="ln6231">      first = false;</a>
<a name="ln6232">    }</a>
<a name="ln6233">  }</a>
<a name="ln6234">  return NULL;</a>
<a name="ln6235">}</a>
<a name="ln6236"> </a>
<a name="ln6237">/// Status line of dragwin is dragged &quot;offset&quot; lines down (negative is up).</a>
<a name="ln6238">void win_drag_status_line(win_T *dragwin, int offset)</a>
<a name="ln6239">{</a>
<a name="ln6240">  frame_T *fr = dragwin-&gt;w_frame;</a>
<a name="ln6241"> </a>
<a name="ln6242">  // Avoid changing command line height with external messages.</a>
<a name="ln6243">  if (fr-&gt;fr_next == NULL &amp;&amp; ui_has(kUIMessages)) {</a>
<a name="ln6244">    return;</a>
<a name="ln6245">  }</a>
<a name="ln6246"> </a>
<a name="ln6247">  frame_T *curfr = fr;</a>
<a name="ln6248">  if (fr != topframe) {         // more than one window</a>
<a name="ln6249">    fr = fr-&gt;fr_parent;</a>
<a name="ln6250">    // When the parent frame is not a column of frames, its parent should</a>
<a name="ln6251">    // be.</a>
<a name="ln6252">    if (fr-&gt;fr_layout != FR_COL) {</a>
<a name="ln6253">      curfr = fr;</a>
<a name="ln6254">      if (fr != topframe) {     // only a row of windows, may drag statusline</a>
<a name="ln6255">        fr = fr-&gt;fr_parent;</a>
<a name="ln6256">      }</a>
<a name="ln6257">    }</a>
<a name="ln6258">  }</a>
<a name="ln6259"> </a>
<a name="ln6260">  // If this is the last frame in a column, may want to resize the parent</a>
<a name="ln6261">  // frame instead (go two up to skip a row of frames).</a>
<a name="ln6262">  while (curfr != topframe &amp;&amp; curfr-&gt;fr_next == NULL) {</a>
<a name="ln6263">    if (fr != topframe) {</a>
<a name="ln6264">      fr = fr-&gt;fr_parent;</a>
<a name="ln6265">    }</a>
<a name="ln6266">    curfr = fr;</a>
<a name="ln6267">    if (fr != topframe) {</a>
<a name="ln6268">      fr = fr-&gt;fr_parent;</a>
<a name="ln6269">    }</a>
<a name="ln6270">  }</a>
<a name="ln6271"> </a>
<a name="ln6272">  int room;</a>
<a name="ln6273">  const bool up = offset &lt; 0;  // if true, drag status line up, otherwise down</a>
<a name="ln6274"> </a>
<a name="ln6275">  if (up) {  // drag up</a>
<a name="ln6276">    offset = -offset;</a>
<a name="ln6277">    // sum up the room of the current frame and above it</a>
<a name="ln6278">    if (fr == curfr) {</a>
<a name="ln6279">      // only one window</a>
<a name="ln6280">      room = fr-&gt;fr_height - frame_minheight(fr, NULL);</a>
<a name="ln6281">    } else {</a>
<a name="ln6282">      room = 0;</a>
<a name="ln6283">      for (fr = fr-&gt;fr_child;; fr = fr-&gt;fr_next) {</a>
<a name="ln6284">        room += fr-&gt;fr_height - frame_minheight(fr, NULL);</a>
<a name="ln6285">        if (fr == curfr) {</a>
<a name="ln6286">          break;</a>
<a name="ln6287">        }</a>
<a name="ln6288">      }</a>
<a name="ln6289">    }</a>
<a name="ln6290">    fr = curfr-&gt;fr_next;                // put fr at frame that grows</a>
<a name="ln6291">  } else {  // drag down</a>
<a name="ln6292">    // Only dragging the last status line can reduce p_ch.</a>
<a name="ln6293">    room = Rows - cmdline_row;</a>
<a name="ln6294">    if (curfr-&gt;fr_next != NULL) {</a>
<a name="ln6295">      room -= (int)p_ch + global_stl_height();</a>
<a name="ln6296">    } else if (!p_ch_was_zero) {</a>
<a name="ln6297">      room--;</a>
<a name="ln6298">    }</a>
<a name="ln6299">    if (room &lt; 0) {</a>
<a name="ln6300">      room = 0;</a>
<a name="ln6301">    }</a>
<a name="ln6302">    // sum up the room of frames below of the current one</a>
<a name="ln6303">    FOR_ALL_FRAMES(fr, curfr-&gt;fr_next) {</a>
<a name="ln6304">      room += fr-&gt;fr_height - frame_minheight(fr, NULL);</a>
<a name="ln6305">    }</a>
<a name="ln6306">    fr = curfr;  // put fr at window that grows</a>
<a name="ln6307">  }</a>
<a name="ln6308"> </a>
<a name="ln6309">  if (room &lt; offset) {          // Not enough room</a>
<a name="ln6310">    offset = room;              // Move as far as we can</a>
<a name="ln6311">  }</a>
<a name="ln6312">  if (offset &lt;= 0) {</a>
<a name="ln6313">    return;</a>
<a name="ln6314">  }</a>
<a name="ln6315"> </a>
<a name="ln6316">  // Grow frame fr by &quot;offset&quot; lines.</a>
<a name="ln6317">  // Doesn't happen when dragging the last status line up.</a>
<a name="ln6318">  if (fr != NULL) {</a>
<a name="ln6319">    frame_new_height(fr, fr-&gt;fr_height + offset, up, false);</a>
<a name="ln6320">  }</a>
<a name="ln6321"> </a>
<a name="ln6322">  if (up) {</a>
<a name="ln6323">    fr = curfr;                 // current frame gets smaller</a>
<a name="ln6324">  } else {</a>
<a name="ln6325">    fr = curfr-&gt;fr_next;        // next frame gets smaller</a>
<a name="ln6326">  }</a>
<a name="ln6327">  // Now make the other frames smaller.</a>
<a name="ln6328">  while (fr != NULL &amp;&amp; offset &gt; 0) {</a>
<a name="ln6329">    int n = frame_minheight(fr, NULL);</a>
<a name="ln6330">    if (fr-&gt;fr_height - offset &lt;= n) {</a>
<a name="ln6331">      offset -= fr-&gt;fr_height - n;</a>
<a name="ln6332">      frame_new_height(fr, n, !up, false);</a>
<a name="ln6333">    } else {</a>
<a name="ln6334">      frame_new_height(fr, fr-&gt;fr_height - offset, !up, false);</a>
<a name="ln6335">      break;</a>
<a name="ln6336">    }</a>
<a name="ln6337">    if (up) {</a>
<a name="ln6338">      fr = fr-&gt;fr_prev;</a>
<a name="ln6339">    } else {</a>
<a name="ln6340">      fr = fr-&gt;fr_next;</a>
<a name="ln6341">    }</a>
<a name="ln6342">  }</a>
<a name="ln6343">  int row = win_comp_pos();</a>
<a name="ln6344">  grid_fill(&amp;default_grid, row, cmdline_row, 0, Columns, ' ', ' ', 0);</a>
<a name="ln6345">  if (msg_grid.chars) {</a>
<a name="ln6346">    clear_cmdline = true;</a>
<a name="ln6347">  }</a>
<a name="ln6348">  cmdline_row = row;</a>
<a name="ln6349">  p_ch = MAX(Rows - cmdline_row, p_ch_was_zero ? 0 : 1);</a>
<a name="ln6350">  curtab-&gt;tp_ch_used = p_ch;</a>
<a name="ln6351"> </a>
<a name="ln6352">  win_fix_scroll(true);</a>
<a name="ln6353"> </a>
<a name="ln6354">  redraw_all_later(UPD_SOME_VALID);</a>
<a name="ln6355">  showmode();</a>
<a name="ln6356">}</a>
<a name="ln6357"> </a>
<a name="ln6358">// Separator line of dragwin is dragged &quot;offset&quot; lines right (negative is left).</a>
<a name="ln6359">void win_drag_vsep_line(win_T *dragwin, int offset)</a>
<a name="ln6360">{</a>
<a name="ln6361">  frame_T *fr = dragwin-&gt;w_frame;</a>
<a name="ln6362">  if (fr == topframe) {         // only one window (cannot happen?)</a>
<a name="ln6363">    return;</a>
<a name="ln6364">  }</a>
<a name="ln6365">  frame_T *curfr = fr;</a>
<a name="ln6366">  fr = fr-&gt;fr_parent;</a>
<a name="ln6367">  // When the parent frame is not a row of frames, its parent should be.</a>
<a name="ln6368">  if (fr-&gt;fr_layout != FR_ROW) {</a>
<a name="ln6369">    if (fr == topframe) {       // only a column of windows (cannot happen?)</a>
<a name="ln6370">      return;</a>
<a name="ln6371">    }</a>
<a name="ln6372">    curfr = fr;</a>
<a name="ln6373">    fr = fr-&gt;fr_parent;</a>
<a name="ln6374">  }</a>
<a name="ln6375"> </a>
<a name="ln6376">  // If this is the last frame in a row, may want to resize a parent</a>
<a name="ln6377">  // frame instead.</a>
<a name="ln6378">  while (curfr-&gt;fr_next == NULL) {</a>
<a name="ln6379">    if (fr == topframe) {</a>
<a name="ln6380">      break;</a>
<a name="ln6381">    }</a>
<a name="ln6382">    curfr = fr;</a>
<a name="ln6383">    fr = fr-&gt;fr_parent;</a>
<a name="ln6384">    if (fr != topframe) {</a>
<a name="ln6385">      curfr = fr;</a>
<a name="ln6386">      fr = fr-&gt;fr_parent;</a>
<a name="ln6387">    }</a>
<a name="ln6388">  }</a>
<a name="ln6389"> </a>
<a name="ln6390">  int room;</a>
<a name="ln6391">  const bool left = offset &lt; 0;  // if true, drag separator line left, otherwise right</a>
<a name="ln6392"> </a>
<a name="ln6393">  if (left) {  // drag left</a>
<a name="ln6394">    offset = -offset;</a>
<a name="ln6395">    // sum up the room of the current frame and left of it</a>
<a name="ln6396">    room = 0;</a>
<a name="ln6397">    for (fr = fr-&gt;fr_child;; fr = fr-&gt;fr_next) {</a>
<a name="ln6398">      room += fr-&gt;fr_width - frame_minwidth(fr, NULL);</a>
<a name="ln6399">      if (fr == curfr) {</a>
<a name="ln6400">        break;</a>
<a name="ln6401">      }</a>
<a name="ln6402">    }</a>
<a name="ln6403">    fr = curfr-&gt;fr_next;                // put fr at frame that grows</a>
<a name="ln6404">  } else {  // drag right</a>
<a name="ln6405">    // sum up the room of frames right of the current one</a>
<a name="ln6406">    room = 0;</a>
<a name="ln6407">    FOR_ALL_FRAMES(fr, curfr-&gt;fr_next) {</a>
<a name="ln6408">      room += fr-&gt;fr_width - frame_minwidth(fr, NULL);</a>
<a name="ln6409">    }</a>
<a name="ln6410">    fr = curfr;  // put fr at window that grows</a>
<a name="ln6411">  }</a>
<a name="ln6412"> </a>
<a name="ln6413">  // Not enough room</a>
<a name="ln6414">  if (room &lt; offset) {</a>
<a name="ln6415">    offset = room;  // Move as far as we can</a>
<a name="ln6416">  }</a>
<a name="ln6417"> </a>
<a name="ln6418">  // No room at all, quit.</a>
<a name="ln6419">  if (offset &lt;= 0) {</a>
<a name="ln6420">    return;</a>
<a name="ln6421">  }</a>
<a name="ln6422"> </a>
<a name="ln6423">  if (fr == NULL) {</a>
<a name="ln6424">    // This can happen when calling win_move_separator() on the rightmost</a>
<a name="ln6425">    // window.  Just don't do anything.</a>
<a name="ln6426">    return;</a>
<a name="ln6427">  }</a>
<a name="ln6428"> </a>
<a name="ln6429">  // grow frame fr by offset lines</a>
<a name="ln6430">  frame_new_width(fr, fr-&gt;fr_width + offset, left, false);</a>
<a name="ln6431"> </a>
<a name="ln6432">  // shrink other frames: current and at the left or at the right</a>
<a name="ln6433">  if (left) {</a>
<a name="ln6434">    fr = curfr;                 // current frame gets smaller</a>
<a name="ln6435">  } else {</a>
<a name="ln6436">    fr = curfr-&gt;fr_next;        // next frame gets smaller</a>
<a name="ln6437">  }</a>
<a name="ln6438">  while (fr != NULL &amp;&amp; offset &gt; 0) {</a>
<a name="ln6439">    int n = frame_minwidth(fr, NULL);</a>
<a name="ln6440">    if (fr-&gt;fr_width - offset &lt;= n) {</a>
<a name="ln6441">      offset -= fr-&gt;fr_width - n;</a>
<a name="ln6442">      frame_new_width(fr, n, !left, false);</a>
<a name="ln6443">    } else {</a>
<a name="ln6444">      frame_new_width(fr, fr-&gt;fr_width - offset, !left, false);</a>
<a name="ln6445">      break;</a>
<a name="ln6446">    }</a>
<a name="ln6447">    if (left) {</a>
<a name="ln6448">      fr = fr-&gt;fr_prev;</a>
<a name="ln6449">    } else {</a>
<a name="ln6450">      fr = fr-&gt;fr_next;</a>
<a name="ln6451">    }</a>
<a name="ln6452">  }</a>
<a name="ln6453">  (void)win_comp_pos();</a>
<a name="ln6454">  redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln6455">}</a>
<a name="ln6456"> </a>
<a name="ln6457">#define FRACTION_MULT   16384L</a>
<a name="ln6458"> </a>
<a name="ln6459">// Set wp-&gt;w_fraction for the current w_wrow and w_height.</a>
<a name="ln6460">// Has no effect when the window is less than two lines.</a>
<a name="ln6461">void set_fraction(win_T *wp)</a>
<a name="ln6462">{</a>
<a name="ln6463">  if (wp-&gt;w_height_inner &gt; 1) {</a>
<a name="ln6464">    // When cursor is in the first line the percentage is computed as if</a>
<a name="ln6465">    // it's halfway that line.  Thus with two lines it is 25%, with three</a>
<a name="ln6466">    // lines 17%, etc.  Similarly for the last line: 75%, 83%, etc.</a>
<a name="ln6467">    wp-&gt;w_fraction = (int)(wp-&gt;w_wrow * FRACTION_MULT + FRACTION_MULT / 2) / wp-&gt;w_height_inner;</a>
<a name="ln6468">  }</a>
<a name="ln6469">}</a>
<a name="ln6470"> </a>
<a name="ln6471">/// Handle scroll position, depending on 'splitkeep'.  Replaces the</a>
<a name="ln6472">/// scroll_to_fraction() call from win_new_height() if 'splitkeep' is &quot;screen&quot;</a>
<a name="ln6473">/// or &quot;topline&quot;.  Instead we iterate over all windows in a tabpage and</a>
<a name="ln6474">/// calculate the new scroll position.</a>
<a name="ln6475">/// TODO(vim): Ensure this also works with wrapped lines.</a>
<a name="ln6476">/// Requires a not fully visible cursor line to be allowed at the bottom of</a>
<a name="ln6477">/// a window(&quot;zb&quot;), probably only when 'smoothscroll' is also set.</a>
<a name="ln6478">void win_fix_scroll(int resize)</a>
<a name="ln6479">{</a>
<a name="ln6480">  if (*p_spk == 'c') {</a>
<a name="ln6481">    return;  // 'splitkeep' is &quot;cursor&quot;</a>
<a name="ln6482">  }</a>
<a name="ln6483"> </a>
<a name="ln6484">  skip_update_topline = true;</a>
<a name="ln6485">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln6486">    // Skip when window height has not changed or when floating.</a>
<a name="ln6487">    if (!wp-&gt;w_floating &amp;&amp; wp-&gt;w_height != wp-&gt;w_prev_height) {</a>
<a name="ln6488">      // Cursor position in this window may now be invalid.  It is kept</a>
<a name="ln6489">      // potentially invalid until the window is made the current window.</a>
<a name="ln6490">      wp-&gt;w_do_win_fix_cursor = true;</a>
<a name="ln6491"> </a>
<a name="ln6492">      // If window has moved update botline to keep the same screenlines.</a>
<a name="ln6493">      if (*p_spk == 's' &amp;&amp; wp-&gt;w_winrow != wp-&gt;w_prev_winrow</a>
<a name="ln6494">          &amp;&amp; wp-&gt;w_botline - 1 &lt;= wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln6495">        int diff = (wp-&gt;w_winrow - wp-&gt;w_prev_winrow)</a>
<a name="ln6496">                   + (wp-&gt;w_height - wp-&gt;w_prev_height);</a>
<a name="ln6497">        linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln6498">        wp-&gt;w_cursor.lnum = wp-&gt;w_botline - 1;</a>
<a name="ln6499"> </a>
<a name="ln6500">        // Add difference in height and row to botline.</a>
<a name="ln6501">        if (diff &gt; 0) {</a>
<a name="ln6502">          cursor_down_inner(wp, diff);</a>
<a name="ln6503">        } else {</a>
<a name="ln6504">          cursor_up_inner(wp, -diff);</a>
<a name="ln6505">        }</a>
<a name="ln6506"> </a>
<a name="ln6507">        // Scroll to put the new cursor position at the bottom of the</a>
<a name="ln6508">        // screen.</a>
<a name="ln6509">        wp-&gt;w_fraction = FRACTION_MULT;</a>
<a name="ln6510">        scroll_to_fraction(wp, wp-&gt;w_prev_height);</a>
<a name="ln6511">        wp-&gt;w_cursor.lnum = lnum;</a>
<a name="ln6512">      } else if (wp == curwin) {</a>
<a name="ln6513">        wp-&gt;w_valid &amp;= ~VALID_CROW;</a>
<a name="ln6514">      }</a>
<a name="ln6515"> </a>
<a name="ln6516">      invalidate_botline(wp);</a>
<a name="ln6517">      validate_botline(wp);</a>
<a name="ln6518">    }</a>
<a name="ln6519">    wp-&gt;w_prev_height = wp-&gt;w_height;</a>
<a name="ln6520">    wp-&gt;w_prev_winrow = wp-&gt;w_winrow;</a>
<a name="ln6521">  }</a>
<a name="ln6522">  skip_update_topline = false;</a>
<a name="ln6523">  // Ensure cursor is valid when not in normal mode or when resized.</a>
<a name="ln6524">  if (!(get_real_state() &amp; (MODE_NORMAL|MODE_CMDLINE|MODE_TERMINAL))) {</a>
<a name="ln6525">    win_fix_cursor(false);</a>
<a name="ln6526">  } else if (resize) {</a>
<a name="ln6527">    win_fix_cursor(true);</a>
<a name="ln6528">  }</a>
<a name="ln6529">}</a>
<a name="ln6530"> </a>
<a name="ln6531">/// Make sure the cursor position is valid for 'splitkeep'.</a>
<a name="ln6532">/// If it is not, put the cursor position in the jumplist and move it.</a>
<a name="ln6533">/// If we are not in normal mode (&quot;normal&quot; is false), make it valid by scrolling</a>
<a name="ln6534">/// instead.</a>
<a name="ln6535">static void win_fix_cursor(bool normal)</a>
<a name="ln6536">{</a>
<a name="ln6537">  win_T *wp = curwin;</a>
<a name="ln6538"> </a>
<a name="ln6539">  if (skip_win_fix_cursor</a>
<a name="ln6540">      || !wp-&gt;w_do_win_fix_cursor</a>
<a name="ln6541">      || wp-&gt;w_buffer-&gt;b_ml.ml_line_count &lt; wp-&gt;w_height_inner) {</a>
<a name="ln6542">    return;</a>
<a name="ln6543">  }</a>
<a name="ln6544"> </a>
<a name="ln6545">  wp-&gt;w_do_win_fix_cursor = false;</a>
<a name="ln6546">  // Determine valid cursor range.</a>
<a name="ln6547">  int so = MIN(wp-&gt;w_height_inner / 2, get_scrolloff_value(wp));</a>
<a name="ln6548">  linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln6549"> </a>
<a name="ln6550">  wp-&gt;w_cursor.lnum = wp-&gt;w_topline;</a>
<a name="ln6551">  cursor_down_inner(wp, so);</a>
<a name="ln6552">  linenr_T top = wp-&gt;w_cursor.lnum;</a>
<a name="ln6553"> </a>
<a name="ln6554">  wp-&gt;w_cursor.lnum = wp-&gt;w_botline - 1;</a>
<a name="ln6555">  cursor_up_inner(wp, so);</a>
<a name="ln6556">  linenr_T bot = wp-&gt;w_cursor.lnum;</a>
<a name="ln6557"> </a>
<a name="ln6558">  wp-&gt;w_cursor.lnum = lnum;</a>
<a name="ln6559">  // Check if cursor position is above or below valid cursor range.</a>
<a name="ln6560">  linenr_T nlnum = 0;</a>
<a name="ln6561">  if (lnum &gt; bot &amp;&amp; (wp-&gt;w_botline - wp-&gt;w_buffer-&gt;b_ml.ml_line_count) != 1) {</a>
<a name="ln6562">    nlnum = bot;</a>
<a name="ln6563">  } else if (lnum &lt; top &amp;&amp; wp-&gt;w_topline != 1) {</a>
<a name="ln6564">    nlnum = (so == wp-&gt;w_height_inner / 2) ? bot : top;</a>
<a name="ln6565">  }</a>
<a name="ln6566"> </a>
<a name="ln6567">  if (nlnum != 0) {  // Cursor is invalid for current scroll position.</a>
<a name="ln6568">    if (normal) {    // Save to jumplist and set cursor to avoid scrolling.</a>
<a name="ln6569">      setmark('\'');</a>
<a name="ln6570">      wp-&gt;w_cursor.lnum = nlnum;</a>
<a name="ln6571">    } else {         // Scroll instead when not in normal mode.</a>
<a name="ln6572">      wp-&gt;w_fraction = (nlnum == bot) ? FRACTION_MULT : 0;</a>
<a name="ln6573">      scroll_to_fraction(wp, wp-&gt;w_prev_height);</a>
<a name="ln6574">      validate_botline(curwin);</a>
<a name="ln6575">    }</a>
<a name="ln6576">  }</a>
<a name="ln6577">}</a>
<a name="ln6578"> </a>
<a name="ln6579">// Set the height of a window.</a>
<a name="ln6580">// &quot;height&quot; excludes any window toolbar.</a>
<a name="ln6581">// This takes care of the things inside the window, not what happens to the</a>
<a name="ln6582">// window position, the frame or to other windows.</a>
<a name="ln6583">void win_new_height(win_T *wp, int height)</a>
<a name="ln6584">{</a>
<a name="ln6585">  // Don't want a negative height.  Happens when splitting a tiny window.</a>
<a name="ln6586">  // Will equalize heights soon to fix it.</a>
<a name="ln6587">  if (height &lt; 0) {</a>
<a name="ln6588">    height = 0;</a>
<a name="ln6589">  }</a>
<a name="ln6590">  if (wp-&gt;w_height == height) {</a>
<a name="ln6591">    return;  // nothing to do</a>
<a name="ln6592">  }</a>
<a name="ln6593"> </a>
<a name="ln6594">  wp-&gt;w_height = height;</a>
<a name="ln6595">  wp-&gt;w_pos_changed = true;</a>
<a name="ln6596">  win_set_inner_size(wp, true);</a>
<a name="ln6597">}</a>
<a name="ln6598"> </a>
<a name="ln6599">void scroll_to_fraction(win_T *wp, int prev_height)</a>
<a name="ln6600">{</a>
<a name="ln6601">  int height = wp-&gt;w_height_inner;</a>
<a name="ln6602"> </a>
<a name="ln6603">  // Don't change w_topline in any of these cases:</a>
<a name="ln6604">  // - window height is 0</a>
<a name="ln6605">  // - 'scrollbind' is set and this isn't the current window</a>
<a name="ln6606">  // - window height is sufficient to display the whole buffer and first line</a>
<a name="ln6607">  //   is visible.</a>
<a name="ln6608">  if (height &gt; 0</a>
<a name="ln6609">      &amp;&amp; (!wp-&gt;w_p_scb || wp == curwin)</a>
<a name="ln6610">      &amp;&amp; (height &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count</a>
<a name="ln6611">          || wp-&gt;w_topline &gt; 1)) {</a>
<a name="ln6612">    // Find a value for w_topline that shows the cursor at the same</a>
<a name="ln6613">    // relative position in the window as before (more or less).</a>
<a name="ln6614">    linenr_T lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln6615">    if (lnum &lt; 1) {             // can happen when starting up</a>
<a name="ln6616">      lnum = 1;</a>
<a name="ln6617">    }</a>
<a name="ln6618">    wp-&gt;w_wrow = (int)((long)wp-&gt;w_fraction * (long)height - 1L) / FRACTION_MULT;</a>
<a name="ln6619">    int line_size = plines_win_col(wp, lnum, (long)(wp-&gt;w_cursor.col)) - 1;</a>
<a name="ln6620">    int sline = wp-&gt;w_wrow - line_size;</a>
<a name="ln6621"> </a>
<a name="ln6622">    if (sline &gt;= 0) {</a>
<a name="ln6623">      // Make sure the whole cursor line is visible, if possible.</a>
<a name="ln6624">      const int rows = plines_win(wp, lnum, false);</a>
<a name="ln6625"> </a>
<a name="ln6626">      if (sline &gt; wp-&gt;w_height_inner - rows) {</a>
<a name="ln6627">        sline = wp-&gt;w_height_inner - rows;</a>
<a name="ln6628">        wp-&gt;w_wrow -= rows - line_size;</a>
<a name="ln6629">      }</a>
<a name="ln6630">    }</a>
<a name="ln6631"> </a>
<a name="ln6632">    if (sline &lt; 0) {</a>
<a name="ln6633">      // Cursor line would go off top of screen if w_wrow was this high.</a>
<a name="ln6634">      // Make cursor line the first line in the window.  If not enough</a>
<a name="ln6635">      // room use w_skipcol;</a>
<a name="ln6636">      wp-&gt;w_wrow = line_size;</a>
<a name="ln6637">      if (wp-&gt;w_wrow &gt;= wp-&gt;w_height_inner</a>
<a name="ln6638">          &amp;&amp; (wp-&gt;w_width_inner - win_col_off(wp)) &gt; 0) {</a>
<a name="ln6639">        wp-&gt;w_skipcol += wp-&gt;w_width_inner - win_col_off(wp);</a>
<a name="ln6640">        wp-&gt;w_wrow--;</a>
<a name="ln6641">        while (wp-&gt;w_wrow &gt;= wp-&gt;w_height_inner) {</a>
<a name="ln6642">          wp-&gt;w_skipcol += wp-&gt;w_width_inner - win_col_off(wp)</a>
<a name="ln6643">                           + win_col_off2(wp);</a>
<a name="ln6644">          wp-&gt;w_wrow--;</a>
<a name="ln6645">        }</a>
<a name="ln6646">      }</a>
<a name="ln6647">    } else if (sline &gt; 0) {</a>
<a name="ln6648">      while (sline &gt; 0 &amp;&amp; lnum &gt; 1) {</a>
<a name="ln6649">        (void)hasFoldingWin(wp, lnum, &amp;lnum, NULL, true, NULL);</a>
<a name="ln6650">        if (lnum == 1) {</a>
<a name="ln6651">          // first line in buffer is folded</a>
<a name="ln6652">          line_size = 1;</a>
<a name="ln6653">          sline--;</a>
<a name="ln6654">          break;</a>
<a name="ln6655">        }</a>
<a name="ln6656">        lnum--;</a>
<a name="ln6657">        if (lnum == wp-&gt;w_topline) {</a>
<a name="ln6658">          line_size = plines_win_nofill(wp, lnum, true)</a>
<a name="ln6659">                      + wp-&gt;w_topfill;</a>
<a name="ln6660">        } else {</a>
<a name="ln6661">          line_size = plines_win(wp, lnum, true);</a>
<a name="ln6662">        }</a>
<a name="ln6663">        sline -= line_size;</a>
<a name="ln6664">      }</a>
<a name="ln6665"> </a>
<a name="ln6666">      if (sline &lt; 0) {</a>
<a name="ln6667">        // Line we want at top would go off top of screen.  Use next</a>
<a name="ln6668">        // line instead.</a>
<a name="ln6669">        (void)hasFoldingWin(wp, lnum, NULL, &amp;lnum, true, NULL);</a>
<a name="ln6670">        lnum++;</a>
<a name="ln6671">        wp-&gt;w_wrow -= line_size + sline;</a>
<a name="ln6672">      } else if (sline &gt; 0) {</a>
<a name="ln6673">        // First line of file reached, use that as topline.</a>
<a name="ln6674">        lnum = 1;</a>
<a name="ln6675">        wp-&gt;w_wrow -= sline;</a>
<a name="ln6676">      }</a>
<a name="ln6677">    }</a>
<a name="ln6678">    set_topline(wp, lnum);</a>
<a name="ln6679">  }</a>
<a name="ln6680"> </a>
<a name="ln6681">  if (wp == curwin) {</a>
<a name="ln6682">    curs_columns(wp, false);        // validate w_wrow</a>
<a name="ln6683">  }</a>
<a name="ln6684">  if (prev_height &gt; 0) {</a>
<a name="ln6685">    wp-&gt;w_prev_fraction_row = wp-&gt;w_wrow;</a>
<a name="ln6686">  }</a>
<a name="ln6687"> </a>
<a name="ln6688">  redraw_later(wp, UPD_SOME_VALID);</a>
<a name="ln6689">  invalidate_botline(wp);</a>
<a name="ln6690">}</a>
<a name="ln6691"> </a>
<a name="ln6692">void win_set_inner_size(win_T *wp, bool valid_cursor)</a>
<a name="ln6693">{</a>
<a name="ln6694">  int width = wp-&gt;w_width_request;</a>
<a name="ln6695">  if (width == 0) {</a>
<a name="ln6696">    width = wp-&gt;w_width;</a>
<a name="ln6697">  }</a>
<a name="ln6698"> </a>
<a name="ln6699">  int prev_height = wp-&gt;w_height_inner;</a>
<a name="ln6700">  int height = wp-&gt;w_height_request;</a>
<a name="ln6701">  if (height == 0) {</a>
<a name="ln6702">    height = wp-&gt;w_height - wp-&gt;w_winbar_height;</a>
<a name="ln6703">  }</a>
<a name="ln6704"> </a>
<a name="ln6705">  if (height != prev_height) {</a>
<a name="ln6706">    if (height &gt; 0 &amp;&amp; valid_cursor) {</a>
<a name="ln6707">      if (wp == curwin &amp;&amp; *p_spk == 'c') {</a>
<a name="ln6708">        // w_wrow needs to be valid. When setting 'laststatus' this may</a>
<a name="ln6709">        // call win_new_height() recursively.</a>
<a name="ln6710">        validate_cursor();</a>
<a name="ln6711">      }</a>
<a name="ln6712">      if (wp-&gt;w_height_inner != prev_height) {  // -V547</a>
<a name="ln6713">        return;  // Recursive call already changed the size, bail out.</a>
<a name="ln6714">      }</a>
<a name="ln6715">      if (wp-&gt;w_wrow != wp-&gt;w_prev_fraction_row) {</a>
<a name="ln6716">        set_fraction(wp);</a>
<a name="ln6717">      }</a>
<a name="ln6718">    }</a>
<a name="ln6719">    wp-&gt;w_height_inner = height;</a>
<a name="ln6720">    win_comp_scroll(wp);</a>
<a name="ln6721"> </a>
<a name="ln6722">    // There is no point in adjusting the scroll position when exiting.  Some</a>
<a name="ln6723">    // values might be invalid.</a>
<a name="ln6724">    if (valid_cursor &amp;&amp; !exiting &amp;&amp; *p_spk == 'c') {</a>
<a name="ln6725">      wp-&gt;w_skipcol = 0;</a>
<a name="ln6726">      scroll_to_fraction(wp, prev_height);</a>
<a name="ln6727">    }</a>
<a name="ln6728">    redraw_later(wp, UPD_SOME_VALID);</a>
<a name="ln6729">  }</a>
<a name="ln6730"> </a>
<a name="ln6731">  if (width != wp-&gt;w_width_inner) {</a>
<a name="ln6732">    wp-&gt;w_width_inner = width;</a>
<a name="ln6733">    wp-&gt;w_lines_valid = 0;</a>
<a name="ln6734">    if (valid_cursor) {</a>
<a name="ln6735">      changed_line_abv_curs_win(wp);</a>
<a name="ln6736">      invalidate_botline(wp);</a>
<a name="ln6737">      if (wp == curwin &amp;&amp; *p_spk == 'c') {</a>
<a name="ln6738">        curs_columns(wp, true);  // validate w_wrow</a>
<a name="ln6739">      }</a>
<a name="ln6740">    }</a>
<a name="ln6741">    redraw_later(wp, UPD_NOT_VALID);</a>
<a name="ln6742">  }</a>
<a name="ln6743"> </a>
<a name="ln6744">  if (wp-&gt;w_buffer-&gt;terminal) {</a>
<a name="ln6745">    terminal_check_size(wp-&gt;w_buffer-&gt;terminal);</a>
<a name="ln6746">  }</a>
<a name="ln6747"> </a>
<a name="ln6748">  wp-&gt;w_height_outer = (wp-&gt;w_height_inner + win_border_height(wp) + wp-&gt;w_winbar_height);</a>
<a name="ln6749">  wp-&gt;w_width_outer = (wp-&gt;w_width_inner + win_border_width(wp));</a>
<a name="ln6750">  wp-&gt;w_winrow_off = wp-&gt;w_border_adj[0] + wp-&gt;w_winbar_height;</a>
<a name="ln6751">  wp-&gt;w_wincol_off = wp-&gt;w_border_adj[3];</a>
<a name="ln6752">  wp-&gt;w_redr_status = true;</a>
<a name="ln6753">}</a>
<a name="ln6754"> </a>
<a name="ln6755">static int win_border_height(win_T *wp)</a>
<a name="ln6756">{</a>
<a name="ln6757">  return wp-&gt;w_border_adj[0] + wp-&gt;w_border_adj[2];</a>
<a name="ln6758">}</a>
<a name="ln6759"> </a>
<a name="ln6760">static int win_border_width(win_T *wp)</a>
<a name="ln6761">{</a>
<a name="ln6762">  return wp-&gt;w_border_adj[1] + wp-&gt;w_border_adj[3];</a>
<a name="ln6763">}</a>
<a name="ln6764"> </a>
<a name="ln6765">/// Set the width of a window.</a>
<a name="ln6766">void win_new_width(win_T *wp, int width)</a>
<a name="ln6767">{</a>
<a name="ln6768">  // Should we give an error if width &lt; 0?</a>
<a name="ln6769">  wp-&gt;w_width = width &lt; 0 ? 0 : width;</a>
<a name="ln6770">  wp-&gt;w_pos_changed = true;</a>
<a name="ln6771">  win_set_inner_size(wp, true);</a>
<a name="ln6772">}</a>
<a name="ln6773"> </a>
<a name="ln6774">void win_comp_scroll(win_T *wp)</a>
<a name="ln6775">{</a>
<a name="ln6776">  const OptInt old_w_p_scr = wp-&gt;w_p_scr;</a>
<a name="ln6777"> </a>
<a name="ln6778">  wp-&gt;w_p_scr = wp-&gt;w_height_inner / 2;</a>
<a name="ln6779">  if (wp-&gt;w_p_scr == 0) {</a>
<a name="ln6780">    wp-&gt;w_p_scr = 1;</a>
<a name="ln6781">  }</a>
<a name="ln6782">  if (wp-&gt;w_p_scr != old_w_p_scr) {</a>
<a name="ln6783">    // Used by &quot;verbose set scroll&quot;.</a>
<a name="ln6784">    wp-&gt;w_p_script_ctx[WV_SCROLL].script_ctx.sc_sid = SID_WINLAYOUT;</a>
<a name="ln6785">    wp-&gt;w_p_script_ctx[WV_SCROLL].script_ctx.sc_lnum = 0;</a>
<a name="ln6786">  }</a>
<a name="ln6787">}</a>
<a name="ln6788"> </a>
<a name="ln6789">/// command_height: called whenever p_ch has been changed.</a>
<a name="ln6790">void command_height(void)</a>
<a name="ln6791">{</a>
<a name="ln6792">  int old_p_ch = (int)curtab-&gt;tp_ch_used;</a>
<a name="ln6793"> </a>
<a name="ln6794">  // Use the value of p_ch that we remembered.  This is needed for when the</a>
<a name="ln6795">  // GUI starts up, we can't be sure in what order things happen.  And when</a>
<a name="ln6796">  // p_ch was changed in another tab page.</a>
<a name="ln6797">  curtab-&gt;tp_ch_used = p_ch;</a>
<a name="ln6798"> </a>
<a name="ln6799">  // Update cmdline_row to what it should be: just below the last window.</a>
<a name="ln6800">  cmdline_row = topframe-&gt;fr_height + tabline_height() + global_stl_height();</a>
<a name="ln6801"> </a>
<a name="ln6802">  // If cmdline_row is smaller than what it is supposed to be for 'cmdheight'</a>
<a name="ln6803">  // then set old_p_ch to what it would be, so that the windows get resized</a>
<a name="ln6804">  // properly for the new value.</a>
<a name="ln6805">  if (cmdline_row &lt; Rows - p_ch) {</a>
<a name="ln6806">    old_p_ch = Rows - cmdline_row;</a>
<a name="ln6807">  }</a>
<a name="ln6808"> </a>
<a name="ln6809">  // Find bottom frame with width of screen.</a>
<a name="ln6810">  frame_T *frp = lastwin_nofloating()-&gt;w_frame;</a>
<a name="ln6811">  while (frp-&gt;fr_width != Columns &amp;&amp; frp-&gt;fr_parent != NULL) {</a>
<a name="ln6812">    frp = frp-&gt;fr_parent;</a>
<a name="ln6813">  }</a>
<a name="ln6814"> </a>
<a name="ln6815">  // Avoid changing the height of a window with 'winfixheight' set.</a>
<a name="ln6816">  while (frp-&gt;fr_prev != NULL &amp;&amp; frp-&gt;fr_layout == FR_LEAF</a>
<a name="ln6817">         &amp;&amp; frp-&gt;fr_win-&gt;w_p_wfh) {</a>
<a name="ln6818">    frp = frp-&gt;fr_prev;</a>
<a name="ln6819">  }</a>
<a name="ln6820"> </a>
<a name="ln6821">  if (starting != NO_SCREEN) {</a>
<a name="ln6822">    cmdline_row = Rows - (int)p_ch;</a>
<a name="ln6823"> </a>
<a name="ln6824">    if (p_ch &gt; old_p_ch) {                  // p_ch got bigger</a>
<a name="ln6825">      while (p_ch &gt; old_p_ch) {</a>
<a name="ln6826">        if (frp == NULL) {</a>
<a name="ln6827">          emsg(_(e_noroom));</a>
<a name="ln6828">          p_ch = old_p_ch;</a>
<a name="ln6829">          curtab-&gt;tp_ch_used = p_ch;</a>
<a name="ln6830">          cmdline_row = Rows - (int)p_ch;</a>
<a name="ln6831">          break;</a>
<a name="ln6832">        }</a>
<a name="ln6833">        int h = frp-&gt;fr_height - frame_minheight(frp, NULL);</a>
<a name="ln6834">        if (h &gt; p_ch - old_p_ch) {</a>
<a name="ln6835">          h = (int)p_ch - old_p_ch;</a>
<a name="ln6836">        }</a>
<a name="ln6837">        old_p_ch += h;</a>
<a name="ln6838">        frame_add_height(frp, -h);</a>
<a name="ln6839">        frp = frp-&gt;fr_prev;</a>
<a name="ln6840">      }</a>
<a name="ln6841"> </a>
<a name="ln6842">      // Recompute window positions.</a>
<a name="ln6843">      (void)win_comp_pos();</a>
<a name="ln6844"> </a>
<a name="ln6845">      // clear the lines added to cmdline</a>
<a name="ln6846">      if (full_screen) {</a>
<a name="ln6847">        grid_fill(&amp;default_grid, cmdline_row, Rows, 0, Columns, ' ', ' ', 0);</a>
<a name="ln6848">      }</a>
<a name="ln6849">      msg_row = cmdline_row;</a>
<a name="ln6850">      redraw_cmdline = true;</a>
<a name="ln6851">      return;</a>
<a name="ln6852">    }</a>
<a name="ln6853"> </a>
<a name="ln6854">    if (msg_row &lt; cmdline_row) {</a>
<a name="ln6855">      msg_row = cmdline_row;</a>
<a name="ln6856">    }</a>
<a name="ln6857">    redraw_cmdline = true;</a>
<a name="ln6858">  }</a>
<a name="ln6859">  frame_add_height(frp, (int)(old_p_ch - p_ch));</a>
<a name="ln6860"> </a>
<a name="ln6861">  // Recompute window positions.</a>
<a name="ln6862">  if (frp != lastwin-&gt;w_frame) {</a>
<a name="ln6863">    (void)win_comp_pos();</a>
<a name="ln6864">  }</a>
<a name="ln6865">}</a>
<a name="ln6866"> </a>
<a name="ln6867">// Resize frame &quot;frp&quot; to be &quot;n&quot; lines higher (negative for less high).</a>
<a name="ln6868">// Also resize the frames it is contained in.</a>
<a name="ln6869">static void frame_add_height(frame_T *frp, int n)</a>
<a name="ln6870">{</a>
<a name="ln6871">  frame_new_height(frp, frp-&gt;fr_height + n, false, false);</a>
<a name="ln6872">  while (true) {</a>
<a name="ln6873">    frp = frp-&gt;fr_parent;</a>
<a name="ln6874">    if (frp == NULL) {</a>
<a name="ln6875">      break;</a>
<a name="ln6876">    }</a>
<a name="ln6877">    frp-&gt;fr_height += n;</a>
<a name="ln6878">  }</a>
<a name="ln6879">}</a>
<a name="ln6880"> </a>
<a name="ln6881">// Get the file name at the cursor.</a>
<a name="ln6882">// If Visual mode is active, use the selected text if it's in one line.</a>
<a name="ln6883">// Returns the name in allocated memory, NULL for failure.</a>
<a name="ln6884">char *grab_file_name(int count, linenr_T *file_lnum)</a>
<a name="ln6885">{</a>
<a name="ln6886">  int options = FNAME_MESS | FNAME_EXP | FNAME_REL | FNAME_UNESC;</a>
<a name="ln6887">  if (VIsual_active) {</a>
<a name="ln6888">    size_t len;</a>
<a name="ln6889">    char *ptr;</a>
<a name="ln6890">    if (get_visual_text(NULL, &amp;ptr, &amp;len) == FAIL) {</a>
<a name="ln6891">      return NULL;</a>
<a name="ln6892">    }</a>
<a name="ln6893">    // Only recognize &quot;:123&quot; here</a>
<a name="ln6894">    if (file_lnum != NULL &amp;&amp; ptr[len] == ':' &amp;&amp; isdigit((uint8_t)ptr[len + 1])) {</a>
<a name="ln6895">      char *p = ptr + len + 1;</a>
<a name="ln6896"> </a>
<a name="ln6897">      *file_lnum = (linenr_T)getdigits_long(&amp;p, false, 0);</a>
<a name="ln6898">    }</a>
<a name="ln6899">    return find_file_name_in_path(ptr, len, options, count, curbuf-&gt;b_ffname);</a>
<a name="ln6900">  }</a>
<a name="ln6901">  return file_name_at_cursor(options | FNAME_HYP, count, file_lnum);</a>
<a name="ln6902">}</a>
<a name="ln6903"> </a>
<a name="ln6904">// Return the file name under or after the cursor.</a>
<a name="ln6905">//</a>
<a name="ln6906">// The 'path' option is searched if the file name is not absolute.</a>
<a name="ln6907">// The string returned has been alloc'ed and should be freed by the caller.</a>
<a name="ln6908">// NULL is returned if the file name or file is not found.</a>
<a name="ln6909">//</a>
<a name="ln6910">// options:</a>
<a name="ln6911">// FNAME_MESS       give error messages</a>
<a name="ln6912">// FNAME_EXP        expand to path</a>
<a name="ln6913">// FNAME_HYP        check for hypertext link</a>
<a name="ln6914">// FNAME_INCL       apply &quot;includeexpr&quot;</a>
<a name="ln6915">char *file_name_at_cursor(int options, int count, linenr_T *file_lnum)</a>
<a name="ln6916">{</a>
<a name="ln6917">  return file_name_in_line(get_cursor_line_ptr(),</a>
<a name="ln6918">                           curwin-&gt;w_cursor.col, options, count, curbuf-&gt;b_ffname,</a>
<a name="ln6919">                           file_lnum);</a>
<a name="ln6920">}</a>
<a name="ln6921"> </a>
<a name="ln6922">/// @param rel_fname  file we are searching relative to</a>
<a name="ln6923">/// @param file_lnum  line number after the file name</a>
<a name="ln6924">///</a>
<a name="ln6925">/// @return  the name of the file under or after ptr[col]. Otherwise like file_name_at_cursor().</a>
<a name="ln6926">char *file_name_in_line(char *line, int col, int options, int count, char *rel_fname,</a>
<a name="ln6927">                        linenr_T *file_lnum)</a>
<a name="ln6928">{</a>
<a name="ln6929">  // search forward for what could be the start of a file name</a>
<a name="ln6930">  char *ptr = line + col;</a>
<a name="ln6931">  while (*ptr != NUL &amp;&amp; !vim_isfilec((uint8_t)(*ptr))) {</a>
<a name="ln6932">    MB_PTR_ADV(ptr);</a>
<a name="ln6933">  }</a>
<a name="ln6934">  if (*ptr == NUL) {            // nothing found</a>
<a name="ln6935">    if (options &amp; FNAME_MESS) {</a>
<a name="ln6936">      emsg(_(&quot;E446: No file name under cursor&quot;));</a>
<a name="ln6937">    }</a>
<a name="ln6938">    return NULL;</a>
<a name="ln6939">  }</a>
<a name="ln6940"> </a>
<a name="ln6941">  size_t len;</a>
<a name="ln6942">  bool in_type = true;</a>
<a name="ln6943">  bool is_url = false;</a>
<a name="ln6944"> </a>
<a name="ln6945">  // Search backward for first char of the file name.</a>
<a name="ln6946">  // Go one char back to &quot;:&quot; before &quot;//&quot;, or to the drive letter before &quot;:\&quot; (even if &quot;:&quot;</a>
<a name="ln6947">  // is not in 'isfname').</a>
<a name="ln6948">  while (ptr &gt; line) {</a>
<a name="ln6949">    if ((len = (size_t)(utf_head_off(line, ptr - 1))) &gt; 0) {</a>
<a name="ln6950">      ptr -= len + 1;</a>
<a name="ln6951">    } else if (vim_isfilec((uint8_t)ptr[-1])</a>
<a name="ln6952">               || (len &gt;= 2 &amp;&amp; path_has_drive_letter(ptr - 2))</a>
<a name="ln6953">               || ((options &amp; FNAME_HYP) &amp;&amp; path_is_url(ptr - 1))) {</a>
<a name="ln6954">      ptr--;</a>
<a name="ln6955">    } else {</a>
<a name="ln6956">      break;</a>
<a name="ln6957">    }</a>
<a name="ln6958">  }</a>
<a name="ln6959"> </a>
<a name="ln6960">  // Search forward for the last char of the file name.</a>
<a name="ln6961">  // Also allow &quot;:/&quot; when ':' is not in 'isfname'.</a>
<a name="ln6962">  len = path_has_drive_letter(ptr) ? 2 : 0;</a>
<a name="ln6963">  while (vim_isfilec((uint8_t)ptr[len]) || (ptr[len] == '\\' &amp;&amp; ptr[len + 1] == ' ')</a>
<a name="ln6964">         || ((options &amp; FNAME_HYP) &amp;&amp; path_is_url(ptr + len))</a>
<a name="ln6965">         || (is_url &amp;&amp; vim_strchr(&quot;:?&amp;=&quot;, (uint8_t)ptr[len]) != NULL)) {</a>
<a name="ln6966">    // After type:// we also include :, ?, &amp; and = as valid characters, so that</a>
<a name="ln6967">    // http://google.com:8080?q=this&amp;that=ok works.</a>
<a name="ln6968">    if ((ptr[len] &gt;= 'A' &amp;&amp; ptr[len] &lt;= 'Z') || (ptr[len] &gt;= 'a' &amp;&amp; ptr[len] &lt;= 'z')) {</a>
<a name="ln6969">      if (in_type &amp;&amp; path_is_url(ptr + len + 1)) {</a>
<a name="ln6970">        is_url = true;</a>
<a name="ln6971">      }</a>
<a name="ln6972">    } else {</a>
<a name="ln6973">      in_type = false;</a>
<a name="ln6974">    }</a>
<a name="ln6975"> </a>
<a name="ln6976">    if (ptr[len] == '\\' &amp;&amp; ptr[len + 1] == ' ') {</a>
<a name="ln6977">      // Skip over the &quot;\&quot; in &quot;\ &quot;.</a>
<a name="ln6978">      len++;</a>
<a name="ln6979">    }</a>
<a name="ln6980">    len += (size_t)(utfc_ptr2len(ptr + len));</a>
<a name="ln6981">  }</a>
<a name="ln6982"> </a>
<a name="ln6983">  // If there is trailing punctuation, remove it.</a>
<a name="ln6984">  // But don't remove &quot;..&quot;, could be a directory name.</a>
<a name="ln6985">  if (len &gt; 2 &amp;&amp; vim_strchr(&quot;.,:;!&quot;, (uint8_t)ptr[len - 1]) != NULL</a>
<a name="ln6986">      &amp;&amp; ptr[len - 2] != '.') {</a>
<a name="ln6987">    len--;</a>
<a name="ln6988">  }</a>
<a name="ln6989"> </a>
<a name="ln6990">  if (file_lnum != NULL) {</a>
<a name="ln6991">    const char *line_english = &quot; line &quot;;</a>
<a name="ln6992">    const char *line_transl = _(line_msg);</a>
<a name="ln6993"> </a>
<a name="ln6994">    // Get the number after the file name and a separator character.</a>
<a name="ln6995">    // Also accept &quot; line 999&quot; with and without the same translation as</a>
<a name="ln6996">    // used in last_set_msg().</a>
<a name="ln6997">    char *p = ptr + len;</a>
<a name="ln6998">    if (strncmp(p, line_english, strlen(line_english)) == 0) {</a>
<a name="ln6999">      p += strlen(line_english);</a>
<a name="ln7000">    } else if (strncmp(p, line_transl, strlen(line_transl)) == 0) {</a>
<a name="ln7001">      p += strlen(line_transl);</a>
<a name="ln7002">    } else {</a>
<a name="ln7003">      p = skipwhite(p);</a>
<a name="ln7004">    }</a>
<a name="ln7005">    if (*p != NUL) {</a>
<a name="ln7006">      if (!isdigit((uint8_t)(*p))) {</a>
<a name="ln7007">        p++;                        // skip the separator</a>
<a name="ln7008">      }</a>
<a name="ln7009">      p = skipwhite(p);</a>
<a name="ln7010">      if (isdigit((uint8_t)(*p))) {</a>
<a name="ln7011">        *file_lnum = (linenr_T)getdigits_long(&amp;p, false, 0);</a>
<a name="ln7012">      }</a>
<a name="ln7013">    }</a>
<a name="ln7014">  }</a>
<a name="ln7015"> </a>
<a name="ln7016">  return find_file_name_in_path(ptr, len, options, count, rel_fname);</a>
<a name="ln7017">}</a>
<a name="ln7018"> </a>
<a name="ln7019">/// Add or remove a status line from window(s), according to the</a>
<a name="ln7020">/// value of 'laststatus'.</a>
<a name="ln7021">///</a>
<a name="ln7022">/// @param morewin  pretend there are two or more windows if true.</a>
<a name="ln7023">void last_status(bool morewin)</a>
<a name="ln7024">{</a>
<a name="ln7025">  // Don't make a difference between horizontal or vertical split.</a>
<a name="ln7026">  last_status_rec(topframe, last_stl_height(morewin) &gt; 0, global_stl_height() &gt; 0);</a>
<a name="ln7027">}</a>
<a name="ln7028"> </a>
<a name="ln7029">// Remove status line from window, replacing it with a horizontal separator if needed.</a>
<a name="ln7030">static void win_remove_status_line(win_T *wp, bool add_hsep)</a>
<a name="ln7031">{</a>
<a name="ln7032">  wp-&gt;w_status_height = 0;</a>
<a name="ln7033">  if (add_hsep) {</a>
<a name="ln7034">    wp-&gt;w_hsep_height = 1;</a>
<a name="ln7035">  } else {</a>
<a name="ln7036">    win_new_height(wp, wp-&gt;w_height + STATUS_HEIGHT);</a>
<a name="ln7037">  }</a>
<a name="ln7038">  comp_col();</a>
<a name="ln7039"> </a>
<a name="ln7040">  stl_clear_click_defs(wp-&gt;w_status_click_defs, wp-&gt;w_status_click_defs_size);</a>
<a name="ln7041">  xfree(wp-&gt;w_status_click_defs);</a>
<a name="ln7042">  wp-&gt;w_status_click_defs_size = 0;</a>
<a name="ln7043">  wp-&gt;w_status_click_defs = NULL;</a>
<a name="ln7044">}</a>
<a name="ln7045"> </a>
<a name="ln7046">// Look for a horizontally resizable frame, starting with frame &quot;fr&quot;.</a>
<a name="ln7047">// Returns NULL if there are no resizable frames.</a>
<a name="ln7048">static frame_T *find_horizontally_resizable_frame(frame_T *fr)</a>
<a name="ln7049">{</a>
<a name="ln7050">  frame_T *fp = fr;</a>
<a name="ln7051"> </a>
<a name="ln7052">  while (fp-&gt;fr_height &lt;= frame_minheight(fp, NULL)) {</a>
<a name="ln7053">    if (fp == topframe) {</a>
<a name="ln7054">      return NULL;</a>
<a name="ln7055">    }</a>
<a name="ln7056">    // In a column of frames: go to frame above.  If already at</a>
<a name="ln7057">    // the top or in a row of frames: go to parent.</a>
<a name="ln7058">    if (fp-&gt;fr_parent-&gt;fr_layout == FR_COL &amp;&amp; fp-&gt;fr_prev != NULL) {</a>
<a name="ln7059">      fp = fp-&gt;fr_prev;</a>
<a name="ln7060">    } else {</a>
<a name="ln7061">      fp = fp-&gt;fr_parent;</a>
<a name="ln7062">    }</a>
<a name="ln7063">  }</a>
<a name="ln7064"> </a>
<a name="ln7065">  return fp;</a>
<a name="ln7066">}</a>
<a name="ln7067"> </a>
<a name="ln7068">// Look for resizable frames and take lines from them to make room for the statusline.</a>
<a name="ln7069">// @return Success or failure.</a>
<a name="ln7070">static bool resize_frame_for_status(frame_T *fr)</a>
<a name="ln7071">{</a>
<a name="ln7072">  win_T *wp = fr-&gt;fr_win;</a>
<a name="ln7073">  frame_T *fp = find_horizontally_resizable_frame(fr);</a>
<a name="ln7074"> </a>
<a name="ln7075">  if (fp == NULL) {</a>
<a name="ln7076">    emsg(_(e_noroom));</a>
<a name="ln7077">    return false;</a>
<a name="ln7078">  } else if (fp != fr) {</a>
<a name="ln7079">    frame_new_height(fp, fp-&gt;fr_height - 1, false, false);</a>
<a name="ln7080">    frame_fix_height(wp);</a>
<a name="ln7081">    (void)win_comp_pos();</a>
<a name="ln7082">  } else {</a>
<a name="ln7083">    win_new_height(wp, wp-&gt;w_height - 1);</a>
<a name="ln7084">  }</a>
<a name="ln7085"> </a>
<a name="ln7086">  return true;</a>
<a name="ln7087">}</a>
<a name="ln7088"> </a>
<a name="ln7089">// Look for resizable frames and take lines from them to make room for the winbar.</a>
<a name="ln7090">// @return Success or failure.</a>
<a name="ln7091">static bool resize_frame_for_winbar(frame_T *fr)</a>
<a name="ln7092">{</a>
<a name="ln7093">  win_T *wp = fr-&gt;fr_win;</a>
<a name="ln7094">  frame_T *fp = find_horizontally_resizable_frame(fr);</a>
<a name="ln7095"> </a>
<a name="ln7096">  if (fp == NULL || fp == fr) {</a>
<a name="ln7097">    emsg(_(e_noroom));</a>
<a name="ln7098">    return false;</a>
<a name="ln7099">  }</a>
<a name="ln7100">  frame_new_height(fp, fp-&gt;fr_height - 1, false, false);</a>
<a name="ln7101">  win_new_height(wp, wp-&gt;w_height + 1);</a>
<a name="ln7102">  frame_fix_height(wp);</a>
<a name="ln7103">  (void)win_comp_pos();</a>
<a name="ln7104"> </a>
<a name="ln7105">  return true;</a>
<a name="ln7106">}</a>
<a name="ln7107"> </a>
<a name="ln7108">static void last_status_rec(frame_T *fr, bool statusline, bool is_stl_global)</a>
<a name="ln7109">{</a>
<a name="ln7110">  if (fr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln7111">    win_T *wp = fr-&gt;fr_win;</a>
<a name="ln7112">    bool is_last = is_bottom_win(wp);</a>
<a name="ln7113"> </a>
<a name="ln7114">    if (is_last) {</a>
<a name="ln7115">      if (wp-&gt;w_status_height != 0 &amp;&amp; (!statusline || is_stl_global)) {</a>
<a name="ln7116">        win_remove_status_line(wp, false);</a>
<a name="ln7117">      } else if (wp-&gt;w_status_height == 0 &amp;&amp; !is_stl_global &amp;&amp; statusline) {</a>
<a name="ln7118">        // Add statusline to window if needed</a>
<a name="ln7119">        wp-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln7120">        if (!resize_frame_for_status(fr)) {</a>
<a name="ln7121">          return;</a>
<a name="ln7122">        }</a>
<a name="ln7123">        comp_col();</a>
<a name="ln7124">      }</a>
<a name="ln7125">      // Set prev_height when difference is due to 'laststatus'.</a>
<a name="ln7126">      if (abs(wp-&gt;w_height - wp-&gt;w_prev_height) == 1) {</a>
<a name="ln7127">        wp-&gt;w_prev_height = wp-&gt;w_height;</a>
<a name="ln7128">      }</a>
<a name="ln7129">    } else if (wp-&gt;w_status_height != 0 &amp;&amp; is_stl_global) {</a>
<a name="ln7130">      // If statusline is global and the window has a statusline, replace it with a horizontal</a>
<a name="ln7131">      // separator</a>
<a name="ln7132">      win_remove_status_line(wp, true);</a>
<a name="ln7133">    } else if (wp-&gt;w_status_height == 0 &amp;&amp; !is_stl_global) {</a>
<a name="ln7134">      // If statusline isn't global and the window doesn't have a statusline, re-add it</a>
<a name="ln7135">      wp-&gt;w_status_height = STATUS_HEIGHT;</a>
<a name="ln7136">      wp-&gt;w_hsep_height = 0;</a>
<a name="ln7137">      comp_col();</a>
<a name="ln7138">    }</a>
<a name="ln7139">  } else {</a>
<a name="ln7140">    // For a column or row frame, recursively call this function for all child frames</a>
<a name="ln7141">    frame_T *fp;</a>
<a name="ln7142">    FOR_ALL_FRAMES(fp, fr-&gt;fr_child) {</a>
<a name="ln7143">      last_status_rec(fp, statusline, is_stl_global);</a>
<a name="ln7144">    }</a>
<a name="ln7145">  }</a>
<a name="ln7146">}</a>
<a name="ln7147"> </a>
<a name="ln7148">/// Add or remove window bar from window &quot;wp&quot;.</a>
<a name="ln7149">///</a>
<a name="ln7150">/// @param make_room Whether to resize frames to make room for winbar.</a>
<a name="ln7151">/// @param valid_cursor Whether the cursor is valid and should be used while</a>
<a name="ln7152">///                     resizing.</a>
<a name="ln7153">///</a>
<a name="ln7154">/// @return Success status.</a>
<a name="ln7155">int set_winbar_win(win_T *wp, bool make_room, bool valid_cursor)</a>
<a name="ln7156">{</a>
<a name="ln7157">  // Require the local value to be set in order to show winbar on a floating window.</a>
<a name="ln7158">  int winbar_height = wp-&gt;w_floating ? ((*wp-&gt;w_p_wbr != NUL) ? 1 : 0)</a>
<a name="ln7159">                                     : ((*p_wbr != NUL || *wp-&gt;w_p_wbr != NUL) ? 1 : 0);</a>
<a name="ln7160"> </a>
<a name="ln7161">  if (wp-&gt;w_winbar_height != winbar_height) {</a>
<a name="ln7162">    if (winbar_height == 1 &amp;&amp; wp-&gt;w_height_inner &lt;= 1) {</a>
<a name="ln7163">      if (wp-&gt;w_floating) {</a>
<a name="ln7164">        emsg(_(e_noroom));</a>
<a name="ln7165">        return NOTDONE;</a>
<a name="ln7166">      } else if (!make_room || !resize_frame_for_winbar(wp-&gt;w_frame)) {</a>
<a name="ln7167">        return FAIL;</a>
<a name="ln7168">      }</a>
<a name="ln7169">    }</a>
<a name="ln7170">    wp-&gt;w_winbar_height = winbar_height;</a>
<a name="ln7171">    win_set_inner_size(wp, valid_cursor);</a>
<a name="ln7172"> </a>
<a name="ln7173">    if (winbar_height == 0) {</a>
<a name="ln7174">      // When removing winbar, deallocate the w_winbar_click_defs array</a>
<a name="ln7175">      stl_clear_click_defs(wp-&gt;w_winbar_click_defs, wp-&gt;w_winbar_click_defs_size);</a>
<a name="ln7176">      xfree(wp-&gt;w_winbar_click_defs);</a>
<a name="ln7177">      wp-&gt;w_winbar_click_defs_size = 0;</a>
<a name="ln7178">      wp-&gt;w_winbar_click_defs = NULL;</a>
<a name="ln7179">    }</a>
<a name="ln7180">  }</a>
<a name="ln7181"> </a>
<a name="ln7182">  return OK;</a>
<a name="ln7183">}</a>
<a name="ln7184"> </a>
<a name="ln7185">/// Add or remove window bars from all windows in tab depending on the value of 'winbar'.</a>
<a name="ln7186">///</a>
<a name="ln7187">/// @param make_room Whether to resize frames to make room for winbar.</a>
<a name="ln7188">void set_winbar(bool make_room)</a>
<a name="ln7189">{</a>
<a name="ln7190">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7191">    if (set_winbar_win(wp, make_room, true) == FAIL) {</a>
<a name="ln7192">      break;</a>
<a name="ln7193">    }</a>
<a name="ln7194">  }</a>
<a name="ln7195">}</a>
<a name="ln7196"> </a>
<a name="ln7197">/// Return the number of lines used by the tab page line.</a>
<a name="ln7198">int tabline_height(void)</a>
<a name="ln7199">{</a>
<a name="ln7200">  if (ui_has(kUITabline)) {</a>
<a name="ln7201">    return 0;</a>
<a name="ln7202">  }</a>
<a name="ln7203">  assert(first_tabpage);</a>
<a name="ln7204">  switch (p_stal) {</a>
<a name="ln7205">  case 0:</a>
<a name="ln7206">    return 0;</a>
<a name="ln7207">  case 1:</a>
<a name="ln7208">    return (first_tabpage-&gt;tp_next == NULL) ? 0 : 1;</a>
<a name="ln7209">  }</a>
<a name="ln7210">  return 1;</a>
<a name="ln7211">}</a>
<a name="ln7212"> </a>
<a name="ln7213">/// Return the number of lines used by default by the window bar.</a>
<a name="ln7214">int global_winbar_height(void)</a>
<a name="ln7215">{</a>
<a name="ln7216">  return *p_wbr != NUL ? 1 : 0;</a>
<a name="ln7217">}</a>
<a name="ln7218"> </a>
<a name="ln7219">/// Return the number of lines used by the global statusline</a>
<a name="ln7220">int global_stl_height(void)</a>
<a name="ln7221">{</a>
<a name="ln7222">  return (p_ls == 3) ? STATUS_HEIGHT : 0;</a>
<a name="ln7223">}</a>
<a name="ln7224"> </a>
<a name="ln7225">/// Return the height of the last window's statusline, or the global statusline if set.</a>
<a name="ln7226">///</a>
<a name="ln7227">/// @param morewin  pretend there are two or more windows if true.</a>
<a name="ln7228">int last_stl_height(bool morewin)</a>
<a name="ln7229">{</a>
<a name="ln7230">  return (p_ls &gt; 1 || (p_ls == 1 &amp;&amp; (morewin || !one_nonfloat()))) ? STATUS_HEIGHT : 0;</a>
<a name="ln7231">}</a>
<a name="ln7232"> </a>
<a name="ln7233">/// Return the minimal number of rows that is needed on the screen to display</a>
<a name="ln7234">/// the current number of windows.</a>
<a name="ln7235">int min_rows(void)</a>
<a name="ln7236">{</a>
<a name="ln7237">  if (firstwin == NULL) {       // not initialized yet</a>
<a name="ln7238">    return MIN_LINES;</a>
<a name="ln7239">  }</a>
<a name="ln7240"> </a>
<a name="ln7241">  int total = 0;</a>
<a name="ln7242">  FOR_ALL_TABS(tp) {</a>
<a name="ln7243">    int n = frame_minheight(tp-&gt;tp_topframe, NULL);</a>
<a name="ln7244">    if (total &lt; n) {</a>
<a name="ln7245">      total = n;</a>
<a name="ln7246">    }</a>
<a name="ln7247">  }</a>
<a name="ln7248">  total += tabline_height() + global_stl_height();</a>
<a name="ln7249">  if (p_ch &gt; 0) {</a>
<a name="ln7250">    total += 1;           // count the room for the command line</a>
<a name="ln7251">  }</a>
<a name="ln7252">  return total;</a>
<a name="ln7253">}</a>
<a name="ln7254"> </a>
<a name="ln7255">/// Check that there is only one window (and only one tab page), not counting a</a>
<a name="ln7256">/// help or preview window, unless it is the current window. Does not count</a>
<a name="ln7257">/// &quot;aucmd_win&quot;. Does not count floats unless it is current.</a>
<a name="ln7258">bool only_one_window(void) FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln7259">{</a>
<a name="ln7260">  // If there is another tab page there always is another window.</a>
<a name="ln7261">  if (first_tabpage-&gt;tp_next != NULL) {</a>
<a name="ln7262">    return false;</a>
<a name="ln7263">  }</a>
<a name="ln7264"> </a>
<a name="ln7265">  int count = 0;</a>
<a name="ln7266">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln7267">    if (wp-&gt;w_buffer != NULL</a>
<a name="ln7268">        &amp;&amp; (!((bt_help(wp-&gt;w_buffer) &amp;&amp; !bt_help(curbuf)) || wp-&gt;w_floating</a>
<a name="ln7269">              || wp-&gt;w_p_pvw) || wp == curwin) &amp;&amp; !is_aucmd_win(wp)) {</a>
<a name="ln7270">      count++;</a>
<a name="ln7271">    }</a>
<a name="ln7272">  }</a>
<a name="ln7273">  return count &lt;= 1;</a>
<a name="ln7274">}</a>
<a name="ln7275"> </a>
<a name="ln7276">/// Implementation of check_lnums() and check_lnums_nested().</a>
<a name="ln7277">static void check_lnums_both(bool do_curwin, bool nested)</a>
<a name="ln7278">{</a>
<a name="ln7279">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln7280">    if ((do_curwin || wp != curwin) &amp;&amp; wp-&gt;w_buffer == curbuf) {</a>
<a name="ln7281">      if (!nested) {</a>
<a name="ln7282">        // save the original cursor position and topline</a>
<a name="ln7283">        wp-&gt;w_save_cursor.w_cursor_save = wp-&gt;w_cursor;</a>
<a name="ln7284">        wp-&gt;w_save_cursor.w_topline_save = wp-&gt;w_topline;</a>
<a name="ln7285">      }</a>
<a name="ln7286"> </a>
<a name="ln7287">      bool need_adjust = wp-&gt;w_cursor.lnum &gt; curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7288">      if (need_adjust) {</a>
<a name="ln7289">        wp-&gt;w_cursor.lnum = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7290">      }</a>
<a name="ln7291">      if (need_adjust || !nested) {</a>
<a name="ln7292">        // save the (corrected) cursor position</a>
<a name="ln7293">        wp-&gt;w_save_cursor.w_cursor_corr = wp-&gt;w_cursor;</a>
<a name="ln7294">      }</a>
<a name="ln7295"> </a>
<a name="ln7296">      need_adjust = wp-&gt;w_topline &gt; curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7297">      if (need_adjust) {</a>
<a name="ln7298">        wp-&gt;w_topline = curbuf-&gt;b_ml.ml_line_count;</a>
<a name="ln7299">      }</a>
<a name="ln7300">      if (need_adjust || !nested) {</a>
<a name="ln7301">        // save the (corrected) topline</a>
<a name="ln7302">        wp-&gt;w_save_cursor.w_topline_corr = wp-&gt;w_topline;</a>
<a name="ln7303">      }</a>
<a name="ln7304">    }</a>
<a name="ln7305">  }</a>
<a name="ln7306">}</a>
<a name="ln7307"> </a>
<a name="ln7308">/// Correct the cursor line number in other windows.  Used after changing the</a>
<a name="ln7309">/// current buffer, and before applying autocommands.</a>
<a name="ln7310">///</a>
<a name="ln7311">/// @param do_curwin  when true, also check current window.</a>
<a name="ln7312">void check_lnums(bool do_curwin)</a>
<a name="ln7313">{</a>
<a name="ln7314">  check_lnums_both(do_curwin, false);</a>
<a name="ln7315">}</a>
<a name="ln7316"> </a>
<a name="ln7317">/// Like check_lnums() but for when check_lnums() was already called.</a>
<a name="ln7318">void check_lnums_nested(bool do_curwin)</a>
<a name="ln7319">{</a>
<a name="ln7320">  check_lnums_both(do_curwin, true);</a>
<a name="ln7321">}</a>
<a name="ln7322"> </a>
<a name="ln7323">/// Reset cursor and topline to its stored values from check_lnums().</a>
<a name="ln7324">/// check_lnums() must have been called first!</a>
<a name="ln7325">void reset_lnums(void)</a>
<a name="ln7326">{</a>
<a name="ln7327">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln7328">    if (wp-&gt;w_buffer == curbuf) {</a>
<a name="ln7329">      // Restore the value if the autocommand didn't change it and it was</a>
<a name="ln7330">      // set.</a>
<a name="ln7331">      if (equalpos(wp-&gt;w_save_cursor.w_cursor_corr, wp-&gt;w_cursor)</a>
<a name="ln7332">          &amp;&amp; wp-&gt;w_save_cursor.w_cursor_save.lnum != 0) {</a>
<a name="ln7333">        wp-&gt;w_cursor = wp-&gt;w_save_cursor.w_cursor_save;</a>
<a name="ln7334">      }</a>
<a name="ln7335">      if (wp-&gt;w_save_cursor.w_topline_corr == wp-&gt;w_topline</a>
<a name="ln7336">          &amp;&amp; wp-&gt;w_save_cursor.w_topline_save != 0) {</a>
<a name="ln7337">        wp-&gt;w_topline = wp-&gt;w_save_cursor.w_topline_save;</a>
<a name="ln7338">      }</a>
<a name="ln7339">    }</a>
<a name="ln7340">  }</a>
<a name="ln7341">}</a>
<a name="ln7342"> </a>
<a name="ln7343">// A snapshot of the window sizes, to restore them after closing the help</a>
<a name="ln7344">// window.</a>
<a name="ln7345">// Only these fields are used:</a>
<a name="ln7346">// fr_layout</a>
<a name="ln7347">// fr_width</a>
<a name="ln7348">// fr_height</a>
<a name="ln7349">// fr_next</a>
<a name="ln7350">// fr_child</a>
<a name="ln7351">// fr_win (only valid for the old curwin, NULL otherwise)</a>
<a name="ln7352"> </a>
<a name="ln7353">// Create a snapshot of the current frame sizes.</a>
<a name="ln7354">void make_snapshot(int idx)</a>
<a name="ln7355">{</a>
<a name="ln7356">  clear_snapshot(curtab, idx);</a>
<a name="ln7357">  make_snapshot_rec(topframe, &amp;curtab-&gt;tp_snapshot[idx]);</a>
<a name="ln7358">}</a>
<a name="ln7359"> </a>
<a name="ln7360">static void make_snapshot_rec(frame_T *fr, frame_T **frp)</a>
<a name="ln7361">{</a>
<a name="ln7362">  *frp = xcalloc(1, sizeof(frame_T));</a>
<a name="ln7363">  (*frp)-&gt;fr_layout = fr-&gt;fr_layout;</a>
<a name="ln7364">  (*frp)-&gt;fr_width = fr-&gt;fr_width;</a>
<a name="ln7365">  (*frp)-&gt;fr_height = fr-&gt;fr_height;</a>
<a name="ln7366">  if (fr-&gt;fr_next != NULL) {</a>
<a name="ln7367">    make_snapshot_rec(fr-&gt;fr_next, &amp;((*frp)-&gt;fr_next));</a>
<a name="ln7368">  }</a>
<a name="ln7369">  if (fr-&gt;fr_child != NULL) {</a>
<a name="ln7370">    make_snapshot_rec(fr-&gt;fr_child, &amp;((*frp)-&gt;fr_child));</a>
<a name="ln7371">  }</a>
<a name="ln7372">  if (fr-&gt;fr_layout == FR_LEAF &amp;&amp; fr-&gt;fr_win == curwin) {</a>
<a name="ln7373">    (*frp)-&gt;fr_win = curwin;</a>
<a name="ln7374">  }</a>
<a name="ln7375">}</a>
<a name="ln7376"> </a>
<a name="ln7377">// Remove any existing snapshot.</a>
<a name="ln7378">static void clear_snapshot(tabpage_T *tp, int idx)</a>
<a name="ln7379">{</a>
<a name="ln7380">  clear_snapshot_rec(tp-&gt;tp_snapshot[idx]);</a>
<a name="ln7381">  tp-&gt;tp_snapshot[idx] = NULL;</a>
<a name="ln7382">}</a>
<a name="ln7383"> </a>
<a name="ln7384">static void clear_snapshot_rec(frame_T *fr)</a>
<a name="ln7385">{</a>
<a name="ln7386">  if (fr == NULL) {</a>
<a name="ln7387">    return;</a>
<a name="ln7388">  }</a>
<a name="ln7389">  clear_snapshot_rec(fr-&gt;fr_next);</a>
<a name="ln7390">  clear_snapshot_rec(fr-&gt;fr_child);</a>
<a name="ln7391">  xfree(fr);</a>
<a name="ln7392">}</a>
<a name="ln7393"> </a>
<a name="ln7394">/// Traverse a snapshot to find the previous curwin.</a>
<a name="ln7395">static win_T *get_snapshot_curwin_rec(frame_T *ft)</a>
<a name="ln7396">{</a>
<a name="ln7397">  win_T *wp;</a>
<a name="ln7398"> </a>
<a name="ln7399">  if (ft-&gt;fr_next != NULL) {</a>
<a name="ln7400">    if ((wp = get_snapshot_curwin_rec(ft-&gt;fr_next)) != NULL) {</a>
<a name="ln7401">      return wp;</a>
<a name="ln7402">    }</a>
<a name="ln7403">  }</a>
<a name="ln7404">  if (ft-&gt;fr_child != NULL) {</a>
<a name="ln7405">    if ((wp = get_snapshot_curwin_rec(ft-&gt;fr_child)) != NULL) {</a>
<a name="ln7406">      return wp;</a>
<a name="ln7407">    }</a>
<a name="ln7408">  }</a>
<a name="ln7409"> </a>
<a name="ln7410">  return ft-&gt;fr_win;</a>
<a name="ln7411">}</a>
<a name="ln7412"> </a>
<a name="ln7413">/// @return  the current window stored in the snapshot or NULL.</a>
<a name="ln7414">static win_T *get_snapshot_curwin(int idx)</a>
<a name="ln7415">{</a>
<a name="ln7416">  if (curtab-&gt;tp_snapshot[idx] == NULL) {</a>
<a name="ln7417">    return NULL;</a>
<a name="ln7418">  }</a>
<a name="ln7419"> </a>
<a name="ln7420">  return get_snapshot_curwin_rec(curtab-&gt;tp_snapshot[idx]);</a>
<a name="ln7421">}</a>
<a name="ln7422"> </a>
<a name="ln7423">/// Restore a previously created snapshot, if there is any.</a>
<a name="ln7424">/// This is only done if the screen size didn't change and the window layout is</a>
<a name="ln7425">/// still the same.</a>
<a name="ln7426">///</a>
<a name="ln7427">/// @param close_curwin  closing current window</a>
<a name="ln7428">void restore_snapshot(int idx, int close_curwin)</a>
<a name="ln7429">{</a>
<a name="ln7430">  if (curtab-&gt;tp_snapshot[idx] != NULL</a>
<a name="ln7431">      &amp;&amp; curtab-&gt;tp_snapshot[idx]-&gt;fr_width == topframe-&gt;fr_width</a>
<a name="ln7432">      &amp;&amp; curtab-&gt;tp_snapshot[idx]-&gt;fr_height == topframe-&gt;fr_height</a>
<a name="ln7433">      &amp;&amp; check_snapshot_rec(curtab-&gt;tp_snapshot[idx], topframe) == OK) {</a>
<a name="ln7434">    win_T *wp = restore_snapshot_rec(curtab-&gt;tp_snapshot[idx], topframe);</a>
<a name="ln7435">    (void)win_comp_pos();</a>
<a name="ln7436">    if (wp != NULL &amp;&amp; close_curwin) {</a>
<a name="ln7437">      win_goto(wp);</a>
<a name="ln7438">    }</a>
<a name="ln7439">    redraw_all_later(UPD_NOT_VALID);</a>
<a name="ln7440">  }</a>
<a name="ln7441">  clear_snapshot(curtab, idx);</a>
<a name="ln7442">}</a>
<a name="ln7443"> </a>
<a name="ln7444">/// Check if frames &quot;sn&quot; and &quot;fr&quot; have the same layout, same following frames</a>
<a name="ln7445">/// and same children.  And the window pointer is valid.</a>
<a name="ln7446">static int check_snapshot_rec(frame_T *sn, frame_T *fr)</a>
<a name="ln7447">{</a>
<a name="ln7448">  if (sn-&gt;fr_layout != fr-&gt;fr_layout</a>
<a name="ln7449">      || (sn-&gt;fr_next == NULL) != (fr-&gt;fr_next == NULL)</a>
<a name="ln7450">      || (sn-&gt;fr_child == NULL) != (fr-&gt;fr_child == NULL)</a>
<a name="ln7451">      || (sn-&gt;fr_next != NULL</a>
<a name="ln7452">          &amp;&amp; check_snapshot_rec(sn-&gt;fr_next, fr-&gt;fr_next) == FAIL)</a>
<a name="ln7453">      || (sn-&gt;fr_child != NULL</a>
<a name="ln7454">          &amp;&amp; check_snapshot_rec(sn-&gt;fr_child, fr-&gt;fr_child) == FAIL)</a>
<a name="ln7455">      || (sn-&gt;fr_win != NULL &amp;&amp; !win_valid(sn-&gt;fr_win))) {</a>
<a name="ln7456">    return FAIL;</a>
<a name="ln7457">  }</a>
<a name="ln7458">  return OK;</a>
<a name="ln7459">}</a>
<a name="ln7460"> </a>
<a name="ln7461">// Copy the size of snapshot frame &quot;sn&quot; to frame &quot;fr&quot;.  Do the same for all</a>
<a name="ln7462">// following frames and children.</a>
<a name="ln7463">// Returns a pointer to the old current window, or NULL.</a>
<a name="ln7464">static win_T *restore_snapshot_rec(frame_T *sn, frame_T *fr)</a>
<a name="ln7465">{</a>
<a name="ln7466">  win_T *wp = NULL;</a>
<a name="ln7467"> </a>
<a name="ln7468">  fr-&gt;fr_height = sn-&gt;fr_height;</a>
<a name="ln7469">  fr-&gt;fr_width = sn-&gt;fr_width;</a>
<a name="ln7470">  if (fr-&gt;fr_layout == FR_LEAF) {</a>
<a name="ln7471">    frame_new_height(fr, fr-&gt;fr_height, false, false);</a>
<a name="ln7472">    frame_new_width(fr, fr-&gt;fr_width, false, false);</a>
<a name="ln7473">    wp = sn-&gt;fr_win;</a>
<a name="ln7474">  }</a>
<a name="ln7475">  if (sn-&gt;fr_next != NULL) {</a>
<a name="ln7476">    win_T *wp2 = restore_snapshot_rec(sn-&gt;fr_next, fr-&gt;fr_next);</a>
<a name="ln7477">    if (wp2 != NULL) {</a>
<a name="ln7478">      wp = wp2;</a>
<a name="ln7479">    }</a>
<a name="ln7480">  }</a>
<a name="ln7481">  if (sn-&gt;fr_child != NULL) {</a>
<a name="ln7482">    win_T *wp2 = restore_snapshot_rec(sn-&gt;fr_child, fr-&gt;fr_child);</a>
<a name="ln7483">    if (wp2 != NULL) {</a>
<a name="ln7484">      wp = wp2;</a>
<a name="ln7485">    }</a>
<a name="ln7486">  }</a>
<a name="ln7487">  return wp;</a>
<a name="ln7488">}</a>
<a name="ln7489"> </a>
<a name="ln7490">/// Check that &quot;topfrp&quot; and its children are at the right height.</a>
<a name="ln7491">///</a>
<a name="ln7492">/// @param  topfrp  top frame pointer</a>
<a name="ln7493">/// @param  height  expected height</a>
<a name="ln7494">static bool frame_check_height(const frame_T *topfrp, int height)</a>
<a name="ln7495">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7496">{</a>
<a name="ln7497">  if (topfrp-&gt;fr_height != height) {</a>
<a name="ln7498">    return false;</a>
<a name="ln7499">  }</a>
<a name="ln7500">  if (topfrp-&gt;fr_layout == FR_ROW) {</a>
<a name="ln7501">    const frame_T *frp;</a>
<a name="ln7502">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln7503">      if (frp-&gt;fr_height != height) {</a>
<a name="ln7504">        return false;</a>
<a name="ln7505">      }</a>
<a name="ln7506">    }</a>
<a name="ln7507">  }</a>
<a name="ln7508">  return true;</a>
<a name="ln7509">}</a>
<a name="ln7510"> </a>
<a name="ln7511">/// Check that &quot;topfrp&quot; and its children are at the right width.</a>
<a name="ln7512">///</a>
<a name="ln7513">/// @param  topfrp  top frame pointer</a>
<a name="ln7514">/// @param  width   expected width</a>
<a name="ln7515">static bool frame_check_width(const frame_T *topfrp, int width)</a>
<a name="ln7516">  FUNC_ATTR_PURE FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7517">{</a>
<a name="ln7518">  if (topfrp-&gt;fr_width != width) {</a>
<a name="ln7519">    return false;</a>
<a name="ln7520">  }</a>
<a name="ln7521">  if (topfrp-&gt;fr_layout == FR_COL) {</a>
<a name="ln7522">    const frame_T *frp;</a>
<a name="ln7523">    FOR_ALL_FRAMES(frp, topfrp-&gt;fr_child) {</a>
<a name="ln7524">      if (frp-&gt;fr_width != width) {</a>
<a name="ln7525">        return false;</a>
<a name="ln7526">      }</a>
<a name="ln7527">    }</a>
<a name="ln7528">  }</a>
<a name="ln7529">  return true;</a>
<a name="ln7530">}</a>
<a name="ln7531"> </a>
<a name="ln7532">/// Simple int comparison function for use with qsort()</a>
<a name="ln7533">static int int_cmp(const void *a, const void *b)</a>
<a name="ln7534">{</a>
<a name="ln7535">  return *(const int *)a - *(const int *)b;</a>
<a name="ln7536">}</a>
<a name="ln7537"> </a>
<a name="ln7538">/// Handle setting 'colorcolumn' or 'textwidth' in window &quot;wp&quot;.</a>
<a name="ln7539">///</a>
<a name="ln7540">/// @return error message, NULL if it's OK.</a>
<a name="ln7541">const char *check_colorcolumn(win_T *wp)</a>
<a name="ln7542">{</a>
<a name="ln7543">  if (wp-&gt;w_buffer == NULL) {</a>
<a name="ln7544">    return NULL;      // buffer was closed</a>
<a name="ln7545">  }</a>
<a name="ln7546"> </a>
<a name="ln7547">  unsigned count = 0;</a>
<a name="ln7548">  int color_cols[256];</a>
<a name="ln7549">  for (char *s = wp-&gt;w_p_cc; *s != NUL &amp;&amp; count &lt; 255;) {</a>
<a name="ln7550">    int col;</a>
<a name="ln7551">    if (*s == '-' || *s == '+') {</a>
<a name="ln7552">      // -N and +N: add to 'textwidth'</a>
<a name="ln7553">      col = (*s == '-') ? -1 : 1;</a>
<a name="ln7554">      s++;</a>
<a name="ln7555">      if (!ascii_isdigit(*s)) {</a>
<a name="ln7556">        return e_invarg;</a>
<a name="ln7557">      }</a>
<a name="ln7558">      col = col * getdigits_int(&amp;s, true, 0);</a>
<a name="ln7559">      if (wp-&gt;w_buffer-&gt;b_p_tw == 0) {</a>
<a name="ln7560">        goto skip;          // 'textwidth' not set, skip this item</a>
<a name="ln7561">      }</a>
<a name="ln7562">      assert((col &gt;= 0</a>
<a name="ln7563">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &lt;= INT_MAX - col</a>
<a name="ln7564">              &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &gt;= INT_MIN)</a>
<a name="ln7565">             || (col &lt; 0</a>
<a name="ln7566">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw &gt;= INT_MIN - col</a>
<a name="ln7567">                 &amp;&amp; wp-&gt;w_buffer-&gt;b_p_tw + col &lt;= INT_MAX));</a>
<a name="ln7568">      col += (int)wp-&gt;w_buffer-&gt;b_p_tw;</a>
<a name="ln7569">      if (col &lt; 0) {</a>
<a name="ln7570">        goto skip;</a>
<a name="ln7571">      }</a>
<a name="ln7572">    } else if (ascii_isdigit(*s)) {</a>
<a name="ln7573">      col = getdigits_int(&amp;s, true, 0);</a>
<a name="ln7574">    } else {</a>
<a name="ln7575">      return e_invarg;</a>
<a name="ln7576">    }</a>
<a name="ln7577">    color_cols[count++] = col - 1;      // 1-based to 0-based</a>
<a name="ln7578">skip:</a>
<a name="ln7579">    if (*s == NUL) {</a>
<a name="ln7580">      break;</a>
<a name="ln7581">    }</a>
<a name="ln7582">    if (*s != ',') {</a>
<a name="ln7583">      return e_invarg;</a>
<a name="ln7584">    }</a>
<a name="ln7585">    if (*++s == NUL) {</a>
<a name="ln7586">      return e_invarg;        // illegal trailing comma as in &quot;set cc=80,&quot;</a>
<a name="ln7587">    }</a>
<a name="ln7588">  }</a>
<a name="ln7589"> </a>
<a name="ln7590">  xfree(wp-&gt;w_p_cc_cols);</a>
<a name="ln7591">  if (count == 0) {</a>
<a name="ln7592">    wp-&gt;w_p_cc_cols = NULL;</a>
<a name="ln7593">  } else {</a>
<a name="ln7594">    wp-&gt;w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));</a>
<a name="ln7595">    // sort the columns for faster usage on screen redraw inside</a>
<a name="ln7596">    // win_line()</a>
<a name="ln7597">    qsort(color_cols, count, sizeof(int), int_cmp);</a>
<a name="ln7598"> </a>
<a name="ln7599">    int j = 0;</a>
<a name="ln7600">    for (unsigned i = 0; i &lt; count; i++) {</a>
<a name="ln7601">      // skip duplicates</a>
<a name="ln7602">      if (j == 0 || wp-&gt;w_p_cc_cols[j - 1] != color_cols[i]) {</a>
<a name="ln7603">        wp-&gt;w_p_cc_cols[j++] = color_cols[i];</a>
<a name="ln7604">      }</a>
<a name="ln7605">    }</a>
<a name="ln7606">    wp-&gt;w_p_cc_cols[j] = -1;        // end marker</a>
<a name="ln7607">  }</a>
<a name="ln7608"> </a>
<a name="ln7609">  return NULL;    // no error</a>
<a name="ln7610">}</a>
<a name="ln7611"> </a>
<a name="ln7612">void win_get_tabwin(handle_T id, int *tabnr, int *winnr)</a>
<a name="ln7613">{</a>
<a name="ln7614">  *tabnr = 0;</a>
<a name="ln7615">  *winnr = 0;</a>
<a name="ln7616"> </a>
<a name="ln7617">  int tnum = 1, wnum = 1;</a>
<a name="ln7618">  FOR_ALL_TABS(tp) {</a>
<a name="ln7619">    FOR_ALL_WINDOWS_IN_TAB(wp, tp) {</a>
<a name="ln7620">      if (wp-&gt;handle == id) {</a>
<a name="ln7621">        *winnr = wnum;</a>
<a name="ln7622">        *tabnr = tnum;</a>
<a name="ln7623">        return;</a>
<a name="ln7624">      }</a>
<a name="ln7625">      wnum++;</a>
<a name="ln7626">    }</a>
<a name="ln7627">    tnum++;</a>
<a name="ln7628">    wnum = 1;</a>
<a name="ln7629">  }</a>
<a name="ln7630">}</a>
<a name="ln7631"> </a>
<a name="ln7632">void win_ui_flush(bool validate)</a>
<a name="ln7633">{</a>
<a name="ln7634">  FOR_ALL_TAB_WINDOWS(tp, wp) {</a>
<a name="ln7635">    if (wp-&gt;w_pos_changed &amp;&amp; wp-&gt;w_grid_alloc.chars != NULL) {</a>
<a name="ln7636">      if (tp == curtab) {</a>
<a name="ln7637">        ui_ext_win_position(wp, validate);</a>
<a name="ln7638">      } else {</a>
<a name="ln7639">        ui_call_win_hide(wp-&gt;w_grid_alloc.handle);</a>
<a name="ln7640">        wp-&gt;w_pos_changed = false;</a>
<a name="ln7641">      }</a>
<a name="ln7642">    }</a>
<a name="ln7643">    if (tp == curtab) {</a>
<a name="ln7644">      ui_ext_win_viewport(wp);</a>
<a name="ln7645">    }</a>
<a name="ln7646">  }</a>
<a name="ln7647">}</a>
<a name="ln7648"> </a>
<a name="ln7649">win_T *lastwin_nofloating(void)</a>
<a name="ln7650">{</a>
<a name="ln7651">  win_T *res = lastwin;</a>
<a name="ln7652">  while (res-&gt;w_floating) {</a>
<a name="ln7653">    res = res-&gt;w_prev;</a>
<a name="ln7654">  }</a>
<a name="ln7655">  return res;</a>
<a name="ln7656">}</a>
</code></pre>
<div class="balloon" rel="6952"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: len &gt;= 2.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>