<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>marktree.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// Tree data structure for storing marks at (row, col) positions and updating</a>
<a name="ln5">// them to arbitrary text changes. Derivative work of kbtree in klib, whose</a>
<a name="ln6">// copyright notice is reproduced below. Also inspired by the design of the</a>
<a name="ln7">// marker tree data structure of the Atom editor, regarding efficient updates</a>
<a name="ln8">// to text changes.</a>
<a name="ln9">//</a>
<a name="ln10">// Marks are inserted using marktree_put. Text changes are processed using</a>
<a name="ln11">// marktree_splice. All read and delete operations use the iterator.</a>
<a name="ln12">// use marktree_itr_get to put an iterator at a given position or</a>
<a name="ln13">// marktree_lookup to lookup a mark by its id (iterator optional in this case).</a>
<a name="ln14">// Use marktree_itr_current and marktree_itr_next/prev to read marks in a loop.</a>
<a name="ln15">// marktree_del_itr deletes the current mark of the iterator and implicitly</a>
<a name="ln16">// moves the iterator to the next mark.</a>
<a name="ln17"> </a>
<a name="ln18">// Copyright notice for kbtree (included in heavily modified form):</a>
<a name="ln19">//</a>
<a name="ln20">// Copyright 1997-1999, 2001, John-Mark Gurney.</a>
<a name="ln21">//           2008-2009, Attractive Chaos &lt;attractor@live.co.uk&gt;</a>
<a name="ln22">//</a>
<a name="ln23">// Redistribution and use in source and binary forms, with or without</a>
<a name="ln24">// modification, are permitted provided that the following conditions</a>
<a name="ln25">// are met:</a>
<a name="ln26">//</a>
<a name="ln27">// 1. Redistributions of source code must retain the above copyright</a>
<a name="ln28">//    notice, this list of conditions and the following disclaimer.</a>
<a name="ln29">// 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln30">//    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln31">//    documentation and/or other materials provided with the distribution.</a>
<a name="ln32">//</a>
<a name="ln33">// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln34">// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln35">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln36">// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</a>
<a name="ln37">// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln38">// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln39">// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln40">// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln41">// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln42">// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln43">// SUCH DAMAGE.</a>
<a name="ln44">//</a>
<a name="ln45">// Changes done by by the neovim project follow the Apache v2 license available</a>
<a name="ln46">// at the repo root.</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;assert.h&gt;</a>
<a name="ln49">#include &lt;inttypes.h&gt;</a>
<a name="ln50">#include &lt;stdio.h&gt;</a>
<a name="ln51">#include &lt;stdlib.h&gt;</a>
<a name="ln52">#include &lt;string.h&gt;</a>
<a name="ln53"> </a>
<a name="ln54">#include &quot;klib/kvec.h&quot;</a>
<a name="ln55">#include &quot;nvim/garray.h&quot;</a>
<a name="ln56">#include &quot;nvim/marktree.h&quot;</a>
<a name="ln57">#include &quot;nvim/memory.h&quot;</a>
<a name="ln58">#include &quot;nvim/pos.h&quot;</a>
<a name="ln59">// only for debug functions</a>
<a name="ln60">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln61">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln62">#include &quot;nvim/macros.h&quot;</a>
<a name="ln63"> </a>
<a name="ln64">#define T MT_BRANCH_FACTOR</a>
<a name="ln65">#define ILEN (sizeof(MTNode) + (2 * T) * sizeof(void *))</a>
<a name="ln66"> </a>
<a name="ln67">#define ID_INCR (((uint64_t)1) &lt;&lt; 2)</a>
<a name="ln68"> </a>
<a name="ln69">#define rawkey(itr) ((itr)-&gt;x-&gt;key[(itr)-&gt;i])</a>
<a name="ln70"> </a>
<a name="ln71">static bool pos_leq(MTPos a, MTPos b)</a>
<a name="ln72">{</a>
<a name="ln73">  return a.row &lt; b.row || (a.row == b.row &amp;&amp; a.col &lt;= b.col);</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">static bool pos_less(MTPos a, MTPos b)</a>
<a name="ln77">{</a>
<a name="ln78">  return !pos_leq(b, a);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">static void relative(MTPos base, MTPos *val)</a>
<a name="ln82">{</a>
<a name="ln83">  assert(pos_leq(base, *val));</a>
<a name="ln84">  if (val-&gt;row == base.row) {</a>
<a name="ln85">    val-&gt;row = 0;</a>
<a name="ln86">    val-&gt;col -= base.col;</a>
<a name="ln87">  } else {</a>
<a name="ln88">    val-&gt;row -= base.row;</a>
<a name="ln89">  }</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">static void unrelative(MTPos base, MTPos *val)</a>
<a name="ln93">{</a>
<a name="ln94">  if (val-&gt;row == 0) {</a>
<a name="ln95">    val-&gt;row = base.row;</a>
<a name="ln96">    val-&gt;col += base.col;</a>
<a name="ln97">  } else {</a>
<a name="ln98">    val-&gt;row += base.row;</a>
<a name="ln99">  }</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void compose(MTPos *base, MTPos val)</a>
<a name="ln103">{</a>
<a name="ln104">  if (val.row == 0) {</a>
<a name="ln105">    base-&gt;col += val.col;</a>
<a name="ln106">  } else {</a>
<a name="ln107">    base-&gt;row += val.row;</a>
<a name="ln108">    base-&gt;col = val.col;</a>
<a name="ln109">  }</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">// Used by `marktree_splice`. Need to keep track of marks which moved</a>
<a name="ln113">// in order to repair intersections.</a>
<a name="ln114">typedef struct {</a>
<a name="ln115">  uint64_t id;</a>
<a name="ln116">  MTNode *old, *new;</a>
<a name="ln117">  int old_i, new_i;</a>
<a name="ln118">} Damage;</a>
<a name="ln119">typedef kvec_withinit_t(Damage, 8) DamageList;</a>
<a name="ln120"> </a>
<a name="ln121">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln122"># include &quot;marktree.c.generated.h&quot;</a>
<a name="ln123">#endif</a>
<a name="ln124"> </a>
<a name="ln125">#define mt_generic_cmp(a, b) (((b) &lt; (a)) - ((a) &lt; (b)))</a>
<a name="ln126">static int key_cmp(MTKey a, MTKey b)</a>
<a name="ln127">{</a>
<a name="ln128">  int cmp = mt_generic_cmp(a.pos.row, b.pos.row);</a>
<a name="ln129">  if (cmp != 0) {</a>
<a name="ln130">    return cmp;</a>
<a name="ln131">  }</a>
<a name="ln132">  cmp = mt_generic_cmp(a.pos.col, b.pos.col);</a>
<a name="ln133">  if (cmp != 0) {</a>
<a name="ln134">    return cmp;</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  // TODO(bfredl): MT_FLAG_REAL could go away if we fix marktree_getp_aux for real</a>
<a name="ln138">  const uint16_t cmp_mask = MT_FLAG_RIGHT_GRAVITY | MT_FLAG_END | MT_FLAG_REAL | MT_FLAG_LAST;</a>
<a name="ln139">  return mt_generic_cmp(a.flags &amp; cmp_mask, b.flags &amp; cmp_mask);</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/// @return position of k if it exists in the node, otherwise the position</a>
<a name="ln143">/// it should be inserted, which ranges from 0 to x-&gt;n _inclusively_</a>
<a name="ln144">/// @param match (optional) set to TRUE if match (pos, gravity) was found</a>
<a name="ln145">static inline int marktree_getp_aux(const MTNode *x, MTKey k, bool *match)</a>
<a name="ln146">{</a>
<a name="ln147">  bool dummy_match;</a>
<a name="ln148">  bool *m = match ? match : &amp;dummy_match;</a>
<a name="ln149"> </a>
<a name="ln150">  int begin = 0, end = x-&gt;n;</a>
<a name="ln151">  if (x-&gt;n == 0) {</a>
<a name="ln152">    *m = false;</a>
<a name="ln153">    return -1;</a>
<a name="ln154">  }</a>
<a name="ln155">  while (begin &lt; end) {</a>
<a name="ln156">    int mid = (begin + end) &gt;&gt; 1;</a>
<a name="ln157">    if (key_cmp(x-&gt;key[mid], k) &lt; 0) {</a>
<a name="ln158">      begin = mid + 1;</a>
<a name="ln159">    } else {</a>
<a name="ln160">      end = mid;</a>
<a name="ln161">    }</a>
<a name="ln162">  }</a>
<a name="ln163">  if (begin == x-&gt;n) {</a>
<a name="ln164">    *m = false;</a>
<a name="ln165">    return x-&gt;n - 1;</a>
<a name="ln166">  }</a>
<a name="ln167">  if (!(*m = (key_cmp(k, x-&gt;key[begin]) == 0))) {</a>
<a name="ln168">    begin--;</a>
<a name="ln169">  }</a>
<a name="ln170">  return begin;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static inline void refkey(MarkTree *b, MTNode *x, int i)</a>
<a name="ln174">{</a>
<a name="ln175">  pmap_put(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i]), x);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">static MTNode *id2node(MarkTree *b, uint64_t id)</a>
<a name="ln179">{</a>
<a name="ln180">  return pmap_get(uint64_t)(b-&gt;id2node, id);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">// put functions</a>
<a name="ln184"> </a>
<a name="ln185">// x must be an internal node, which is not full</a>
<a name="ln186">// x-&gt;ptr[i] should be a full node, i e x-&gt;ptr[i]-&gt;n == 2*T-1</a>
<a name="ln187">static inline void split_node(MarkTree *b, MTNode *x, const int i, MTKey next)</a>
<a name="ln188">{</a>
<a name="ln189">  MTNode *y = x-&gt;ptr[i];</a>
<a name="ln190">  MTNode *z = marktree_alloc_node(b, y-&gt;level);</a>
<a name="ln191">  z-&gt;level = y-&gt;level;</a>
<a name="ln192">  z-&gt;n = T - 1;</a>
<a name="ln193"> </a>
<a name="ln194">  // tricky: we might split a node in between inserting the start node and the end</a>
<a name="ln195">  // node of the same pair. Then we must not intersect this id yet (done later</a>
<a name="ln196">  // in marktree_intersect_pair).</a>
<a name="ln197">  uint64_t last_start = mt_end(next) ? mt_lookup_id(next.ns, next.id, false) : MARKTREE_END_FLAG;</a>
<a name="ln198"> </a>
<a name="ln199">  // no alloc in the common case (less than 4 intersects)</a>
<a name="ln200">  kvi_copy(z-&gt;intersect, y-&gt;intersect);</a>
<a name="ln201"> </a>
<a name="ln202">  if (!y-&gt;level) {</a>
<a name="ln203">    uint64_t pi = pseudo_index(y, 0);  // note: sloppy pseudo-index</a>
<a name="ln204">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln205">      MTKey k = y-&gt;key[j];</a>
<a name="ln206">      uint64_t pi_end = pseudo_index_for_id(b, mt_lookup_id(k.ns, k.id, true), true);</a>
<a name="ln207">      if (mt_start(k) &amp;&amp; pi_end &gt; pi &amp;&amp; mt_lookup_key(k) != last_start) {</a>
<a name="ln208">        intersect_node(b, z, mt_lookup_id(k.ns, k.id, false));</a>
<a name="ln209">      }</a>
<a name="ln210">    }</a>
<a name="ln211"> </a>
<a name="ln212">    // note: y-&gt;key[T-1] is moved up and thus checked for both</a>
<a name="ln213">    for (int j = T - 1; j &lt; (T * 2) - 1; j++) {</a>
<a name="ln214">      MTKey k = y-&gt;key[j];</a>
<a name="ln215">      uint64_t pi_start = pseudo_index_for_id(b, mt_lookup_id(k.ns, k.id, false), true);</a>
<a name="ln216">      if (mt_end(k) &amp;&amp; pi_start &gt; 0 &amp;&amp; pi_start &lt; pi) {</a>
<a name="ln217">        intersect_node(b, y, mt_lookup_id(k.ns, k.id, false));</a>
<a name="ln218">      }</a>
<a name="ln219">    }</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  memcpy(z-&gt;key, &amp;y-&gt;key[T], sizeof(MTKey) * (T - 1));</a>
<a name="ln223">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln224">    refkey(b, z, j);</a>
<a name="ln225">  }</a>
<a name="ln226">  if (y-&gt;level) {</a>
<a name="ln227">    memcpy(z-&gt;ptr, &amp;y-&gt;ptr[T], sizeof(MTNode *) * T);</a>
<a name="ln228">    for (int j = 0; j &lt; T; j++) {</a>
<a name="ln229">      z-&gt;ptr[j]-&gt;parent = z;</a>
<a name="ln230">      z-&gt;ptr[j]-&gt;p_idx = (int16_t)j;</a>
<a name="ln231">    }</a>
<a name="ln232">  }</a>
<a name="ln233">  y-&gt;n = T - 1;</a>
<a name="ln234">  memmove(&amp;x-&gt;ptr[i + 2], &amp;x-&gt;ptr[i + 1],</a>
<a name="ln235">          sizeof(MTNode *) * (size_t)(x-&gt;n - i));</a>
<a name="ln236">  x-&gt;ptr[i + 1] = z;</a>
<a name="ln237">  z-&gt;parent = x;  // == y-&gt;parent</a>
<a name="ln238">  for (int j = i + 1; j &lt; x-&gt;n + 2; j++) {</a>
<a name="ln239">    x-&gt;ptr[j]-&gt;p_idx = (int16_t)j;</a>
<a name="ln240">  }</a>
<a name="ln241">  memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i], sizeof(MTKey) * (size_t)(x-&gt;n - i));</a>
<a name="ln242"> </a>
<a name="ln243">  // move key to internal layer:</a>
<a name="ln244">  x-&gt;key[i] = y-&gt;key[T - 1];</a>
<a name="ln245">  refkey(b, x, i);</a>
<a name="ln246">  x-&gt;n++;</a>
<a name="ln247"> </a>
<a name="ln248">  for (int j = 0; j &lt; T - 1; j++) {</a>
<a name="ln249">    relative(x-&gt;key[i].pos, &amp;z-&gt;key[j].pos);</a>
<a name="ln250">  }</a>
<a name="ln251">  if (i &gt; 0) {</a>
<a name="ln252">    unrelative(x-&gt;key[i - 1].pos, &amp;x-&gt;key[i].pos);</a>
<a name="ln253">  }</a>
<a name="ln254"> </a>
<a name="ln255">  if (y-&gt;level) {</a>
<a name="ln256">    bubble_up(y);</a>
<a name="ln257">    bubble_up(z);</a>
<a name="ln258">  } else {</a>
<a name="ln259">    // code above goose here</a>
<a name="ln260">  }</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">// x must not be a full node (even if there might be internal space)</a>
<a name="ln264">static inline void marktree_putp_aux(MarkTree *b, MTNode *x, MTKey k)</a>
<a name="ln265">{</a>
<a name="ln266">  // TODO(bfredl): ugh, make sure this is the _last_ valid (pos, gravity) position,</a>
<a name="ln267">  // to minimize movement</a>
<a name="ln268">  int i = marktree_getp_aux(x, k, NULL) + 1;</a>
<a name="ln269">  if (x-&gt;level == 0) {</a>
<a name="ln270">    if (i != x-&gt;n) {</a>
<a name="ln271">      memmove(&amp;x-&gt;key[i + 1], &amp;x-&gt;key[i],</a>
<a name="ln272">              (size_t)(x-&gt;n - i) * sizeof(MTKey));</a>
<a name="ln273">    }</a>
<a name="ln274">    x-&gt;key[i] = k;</a>
<a name="ln275">    refkey(b, x, i);</a>
<a name="ln276">    x-&gt;n++;</a>
<a name="ln277">  } else {</a>
<a name="ln278">    if (x-&gt;ptr[i]-&gt;n == 2 * T - 1) {</a>
<a name="ln279">      split_node(b, x, i, k);</a>
<a name="ln280">      if (key_cmp(k, x-&gt;key[i]) &gt; 0) {</a>
<a name="ln281">        i++;</a>
<a name="ln282">      }</a>
<a name="ln283">    }</a>
<a name="ln284">    if (i &gt; 0) {</a>
<a name="ln285">      relative(x-&gt;key[i - 1].pos, &amp;k.pos);</a>
<a name="ln286">    }</a>
<a name="ln287">    marktree_putp_aux(b, x-&gt;ptr[i], k);</a>
<a name="ln288">  }</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">void marktree_put(MarkTree *b, MTKey key, int end_row, int end_col, bool end_right)</a>
<a name="ln292">{</a>
<a name="ln293">  assert(!(key.flags &amp; ~MT_FLAG_EXTERNAL_MASK));</a>
<a name="ln294">  if (end_row &gt;= 0) {</a>
<a name="ln295">    key.flags |= MT_FLAG_PAIRED;</a>
<a name="ln296">  }</a>
<a name="ln297"> </a>
<a name="ln298">  marktree_put_key(b, key);</a>
<a name="ln299"> </a>
<a name="ln300">  if (end_row &gt;= 0) {</a>
<a name="ln301">    MTKey end_key = key;</a>
<a name="ln302">    end_key.flags = (uint16_t)((uint16_t)(key.flags &amp; ~MT_FLAG_RIGHT_GRAVITY)</a>
<a name="ln303">                               |(uint16_t)MT_FLAG_END</a>
<a name="ln304">                               |(uint16_t)(end_right ? MT_FLAG_RIGHT_GRAVITY : 0));</a>
<a name="ln305">    end_key.pos = (MTPos){ end_row, end_col };</a>
<a name="ln306">    marktree_put_key(b, end_key);</a>
<a name="ln307">    MarkTreeIter itr[1] = { 0 }, end_itr[1] = { 0 };</a>
<a name="ln308">    marktree_lookup(b, mt_lookup_key(key), itr);</a>
<a name="ln309">    marktree_lookup(b, mt_lookup_key(end_key), end_itr);</a>
<a name="ln310"> </a>
<a name="ln311">    marktree_intersect_pair(b, mt_lookup_key(key), itr, end_itr, false);</a>
<a name="ln312">  }</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">// this is currently not used very often, but if it was it should use binary search</a>
<a name="ln316">static bool intersection_has(Intersection *x, uint64_t id)</a>
<a name="ln317">{</a>
<a name="ln318">  for (size_t i = 0; i &lt; kv_size(*x); i++) {</a>
<a name="ln319">    if (kv_A(*x, i) == id) {</a>
<a name="ln320">      return true;</a>
<a name="ln321">    } else if (kv_A(*x, i) &gt;= id) {</a>
<a name="ln322">      return false;</a>
<a name="ln323">    }</a>
<a name="ln324">  }</a>
<a name="ln325">  return false;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">static void intersect_node(MarkTree *b, MTNode *x, uint64_t id)</a>
<a name="ln329">{</a>
<a name="ln330">  assert(!(id &amp; MARKTREE_END_FLAG));</a>
<a name="ln331">  kvi_pushp(x-&gt;intersect);</a>
<a name="ln332">  // optimized for the common case: new key is always in the end</a>
<a name="ln333">  for (ssize_t i = (ssize_t)kv_size(x-&gt;intersect) - 1; i &gt;= 0; i--) {</a>
<a name="ln334">    if (i &gt; 0 &amp;&amp; kv_A(x-&gt;intersect, i - 1) &gt; id) {</a>
<a name="ln335">      kv_A(x-&gt;intersect, i) = kv_A(x-&gt;intersect, i - 1);</a>
<a name="ln336">    } else {</a>
<a name="ln337">      kv_A(x-&gt;intersect, i) = id;</a>
<a name="ln338">      break;</a>
<a name="ln339">    }</a>
<a name="ln340">  }</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static void unintersect_node(MarkTree *b, MTNode *x, uint64_t id, bool strict)</a>
<a name="ln344">{</a>
<a name="ln345">  assert(!(id &amp; MARKTREE_END_FLAG));</a>
<a name="ln346">  bool seen = false;</a>
<a name="ln347">  size_t i;</a>
<a name="ln348">  for (i = 0; i &lt; kv_size(x-&gt;intersect); i++) {</a>
<a name="ln349">    if (kv_A(x-&gt;intersect, i) &lt; id) {</a>
<a name="ln350">      continue;</a>
<a name="ln351">    } else if (kv_A(x-&gt;intersect, i) == id) {</a>
<a name="ln352">      seen = true;</a>
<a name="ln353">      break;</a>
<a name="ln354">    } else {  // (kv_A(x-&gt;intersect, i) &gt; id)</a>
<a name="ln355">      break;</a>
<a name="ln356">    }</a>
<a name="ln357">  }</a>
<a name="ln358">  if (strict) {</a>
<a name="ln359">    assert(seen);</a>
<a name="ln360">  }</a>
<a name="ln361"> </a>
<a name="ln362">  if (seen) {</a>
<a name="ln363">    if (i &lt; kv_size(x-&gt;intersect) - 1) {</a>
<a name="ln364">      memmove(&amp;kv_A(x-&gt;intersect, i), &amp;kv_A(x-&gt;intersect, i + 1), (kv_size(x-&gt;intersect) - i - 1) *</a>
<a name="ln365">              sizeof(kv_A(x-&gt;intersect, i)));</a>
<a name="ln366">    }</a>
<a name="ln367">    kv_size(x-&gt;intersect)--;</a>
<a name="ln368">  }</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371">/// @param itr mutated</a>
<a name="ln372">/// @param end_itr not mutated</a>
<a name="ln373">void marktree_intersect_pair(MarkTree *b, uint64_t id, MarkTreeIter *itr, MarkTreeIter *end_itr,</a>
<a name="ln374">                             bool delete)</a>
<a name="ln375">{</a>
<a name="ln376">  int lvl = 0, maxlvl = MIN(itr-&gt;lvl, end_itr-&gt;lvl);</a>
<a name="ln377">#define iat(itr, l, q) ((l == itr-&gt;lvl) ? itr-&gt;i + q : itr-&gt;s[l].i)</a>
<a name="ln378">  for (; lvl &lt; maxlvl; lvl++) {</a>
<a name="ln379">    if (itr-&gt;s[lvl].i &gt; end_itr-&gt;s[lvl].i) {</a>
<a name="ln380">      return;  // empty range</a>
<a name="ln381">    } else if (itr-&gt;s[lvl].i &lt; end_itr-&gt;s[lvl].i) {</a>
<a name="ln382">      break;  // work to do</a>
<a name="ln383">    }</a>
<a name="ln384">  }</a>
<a name="ln385">  if (lvl == maxlvl &amp;&amp; iat(itr, lvl, 1) &gt; iat(end_itr, lvl, 0)) {</a>
<a name="ln386">    return;  // empty range</a>
<a name="ln387">  }</a>
<a name="ln388"> </a>
<a name="ln389">  while (itr-&gt;x) {</a>
<a name="ln390">    bool skip = false;</a>
<a name="ln391">    if (itr-&gt;x == end_itr-&gt;x) {</a>
<a name="ln392">      if (itr-&gt;x-&gt;level == 0 || itr-&gt;i &gt;= end_itr-&gt;i) {</a>
<a name="ln393">        break;</a>
<a name="ln394">      } else {</a>
<a name="ln395">        skip = true;</a>
<a name="ln396">      }</a>
<a name="ln397">    } else if (itr-&gt;lvl &gt; lvl) {</a>
<a name="ln398">      skip = true;</a>
<a name="ln399">    } else {</a>
<a name="ln400">      if (iat(itr, lvl, 1) &lt; iat(end_itr, lvl, 1)) {</a>
<a name="ln401">        skip = true;</a>
<a name="ln402">      } else {</a>
<a name="ln403">        lvl++;</a>
<a name="ln404">      }</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">    if (skip) {</a>
<a name="ln408">      if (itr-&gt;x-&gt;level) {</a>
<a name="ln409">        MTNode *x = itr-&gt;x-&gt;ptr[itr-&gt;i + 1];</a>
<a name="ln410">        if (delete) {</a>
<a name="ln411">          unintersect_node(b, x, id, true);</a>
<a name="ln412">        } else {</a>
<a name="ln413">          intersect_node(b, x, id);</a>
<a name="ln414">        }</a>
<a name="ln415">      }</a>
<a name="ln416">    }</a>
<a name="ln417">    marktree_itr_next_skip(b, itr, skip, true, NULL);</a>
<a name="ln418">  }</a>
<a name="ln419">#undef iat</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static MTNode *marktree_alloc_node(MarkTree *b, bool internal)</a>
<a name="ln423">{</a>
<a name="ln424">  MTNode *x = xcalloc(1, internal ? ILEN : sizeof(MTNode));</a>
<a name="ln425">  kvi_init(x-&gt;intersect);</a>
<a name="ln426">  b-&gt;n_nodes++;</a>
<a name="ln427">  return x;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">void marktree_put_key(MarkTree *b, MTKey k)</a>
<a name="ln431">{</a>
<a name="ln432">  k.flags |= MT_FLAG_REAL;  // let's be real.</a>
<a name="ln433">  if (!b-&gt;root) {</a>
<a name="ln434">    b-&gt;root = marktree_alloc_node(b, true);</a>
<a name="ln435">  }</a>
<a name="ln436">  MTNode *r, *s;</a>
<a name="ln437">  b-&gt;n_keys++;</a>
<a name="ln438">  r = b-&gt;root;</a>
<a name="ln439">  if (r-&gt;n == 2 * T - 1) {</a>
<a name="ln440">    s = marktree_alloc_node(b, true);</a>
<a name="ln441">    b-&gt;root = s; s-&gt;level = r-&gt;level + 1; s-&gt;n = 0;</a>
<a name="ln442">    s-&gt;ptr[0] = r;</a>
<a name="ln443">    r-&gt;parent = s;</a>
<a name="ln444">    r-&gt;p_idx = 0;</a>
<a name="ln445">    split_node(b, s, 0, k);</a>
<a name="ln446">    r = s;</a>
<a name="ln447">  }</a>
<a name="ln448">  marktree_putp_aux(b, r, k);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">/// INITIATING DELETION PROTOCOL:</a>
<a name="ln452">///</a>
<a name="ln453">/// 1. Construct a valid iterator to the node to delete (argument)</a>
<a name="ln454">/// 2. If an &quot;internal&quot; key. Iterate one step to the left or right,</a>
<a name="ln455">///     which gives an internal key &quot;auxiliary key&quot;.</a>
<a name="ln456">/// 3. Now delete this internal key (intended or auxiliary).</a>
<a name="ln457">///    The leaf node X might become undersized.</a>
<a name="ln458">/// 4. If step two was done: now replace the key that _should_ be</a>
<a name="ln459">///    deleted with the auxiliary key. Adjust relative</a>
<a name="ln460">/// 5. Now &quot;repair&quot; the tree as needed. We always start at a leaf node X.</a>
<a name="ln461">///     - if the node is big enough, terminate</a>
<a name="ln462">///     - if we can steal from the left, steal</a>
<a name="ln463">///     - if we can steal from the right, steal</a>
<a name="ln464">///     - otherwise merge this node with a neighbour. This might make our</a>
<a name="ln465">///       parent undersized. So repeat 5 for the parent.</a>
<a name="ln466">/// 6. If 4 went all the way to the root node. The root node</a>
<a name="ln467">///    might have ended up with size 0. Delete it then.</a>
<a name="ln468">///</a>
<a name="ln469">/// The iterator remains valid, and now points at the key _after_ the deleted</a>
<a name="ln470">/// one.</a>
<a name="ln471">///</a>
<a name="ln472">/// @param rev should be true if we plan to iterate _backwards_ and delete</a>
<a name="ln473">///            stuff before this key. Most of the time this is false (the</a>
<a name="ln474">///            recommended strategy is to always iterate forward)</a>
<a name="ln475">uint64_t marktree_del_itr(MarkTree *b, MarkTreeIter *itr, bool rev)</a>
<a name="ln476">{</a>
<a name="ln477">  int adjustment = 0;</a>
<a name="ln478"> </a>
<a name="ln479">  MTNode *cur = itr-&gt;x;</a>
<a name="ln480">  int curi = itr-&gt;i;</a>
<a name="ln481">  uint64_t id = mt_lookup_key(cur-&gt;key[curi]);</a>
<a name="ln482"> </a>
<a name="ln483">  MTKey raw = rawkey(itr);</a>
<a name="ln484">  uint64_t other = 0;</a>
<a name="ln485">  if (mt_paired(raw) &amp;&amp; !(raw.flags &amp; MT_FLAG_ORPHANED)) {</a>
<a name="ln486">    other = mt_lookup_key_side(raw, !mt_end(raw));</a>
<a name="ln487"> </a>
<a name="ln488">    MarkTreeIter other_itr[1];</a>
<a name="ln489">    marktree_lookup(b, other, other_itr);</a>
<a name="ln490">    rawkey(other_itr).flags |= MT_FLAG_ORPHANED;</a>
<a name="ln491">    // Remove intersect markers. NB: must match exactly!</a>
<a name="ln492">    if (mt_start(raw)) {</a>
<a name="ln493">      MarkTreeIter this_itr[1] = { *itr };  // mutated copy</a>
<a name="ln494">      marktree_intersect_pair(b, id, this_itr, other_itr, true);</a>
<a name="ln495">    } else {</a>
<a name="ln496">      marktree_intersect_pair(b, other, other_itr, itr, true);</a>
<a name="ln497">    }</a>
<a name="ln498">  }</a>
<a name="ln499"> </a>
<a name="ln500">  if (itr-&gt;x-&gt;level) {</a>
<a name="ln501">    if (rev) {</a>
<a name="ln502">      abort();</a>
<a name="ln503">    } else {</a>
<a name="ln504">      // steal previous node</a>
<a name="ln505">      marktree_itr_prev(b, itr);</a>
<a name="ln506">      adjustment = -1;</a>
<a name="ln507">    }</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  // 3.</a>
<a name="ln511">  MTNode *x = itr-&gt;x;</a>
<a name="ln512">  assert(x-&gt;level == 0);</a>
<a name="ln513">  MTKey intkey = x-&gt;key[itr-&gt;i];</a>
<a name="ln514">  if (x-&gt;n &gt; itr-&gt;i + 1) {</a>
<a name="ln515">    memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i + 1],</a>
<a name="ln516">            sizeof(MTKey) * (size_t)(x-&gt;n - itr-&gt;i - 1));</a>
<a name="ln517">  }</a>
<a name="ln518">  x-&gt;n--;</a>
<a name="ln519"> </a>
<a name="ln520">  b-&gt;n_keys--;</a>
<a name="ln521">  pmap_del(uint64_t)(b-&gt;id2node, id, NULL);</a>
<a name="ln522"> </a>
<a name="ln523">  // 4.</a>
<a name="ln524">  // if (adjustment == 1) {</a>
<a name="ln525">  //   abort();</a>
<a name="ln526">  // }</a>
<a name="ln527">  if (adjustment == -1) {</a>
<a name="ln528">    int ilvl = itr-&gt;lvl - 1;</a>
<a name="ln529">    MTNode *lnode = x;</a>
<a name="ln530">    uint64_t start_id = 0;</a>
<a name="ln531">    bool did_bubble = false;</a>
<a name="ln532">    if (mt_end(intkey)) {</a>
<a name="ln533">      start_id = mt_lookup_key_side(intkey, false);</a>
<a name="ln534">    }</a>
<a name="ln535">    do {</a>
<a name="ln536">      MTNode *p = lnode-&gt;parent;</a>
<a name="ln537">      if (ilvl &lt; 0) {</a>
<a name="ln538">        abort();</a>
<a name="ln539">      }</a>
<a name="ln540">      int i = itr-&gt;s[ilvl].i;</a>
<a name="ln541">      assert(p-&gt;ptr[i] == lnode);</a>
<a name="ln542">      if (i &gt; 0) {</a>
<a name="ln543">        unrelative(p-&gt;key[i - 1].pos, &amp;intkey.pos);</a>
<a name="ln544">      }</a>
<a name="ln545"> </a>
<a name="ln546">      if (p != cur &amp;&amp; start_id) {</a>
<a name="ln547">        if (intersection_has(&amp;p-&gt;ptr[0]-&gt;intersect, start_id)) {</a>
<a name="ln548">          // if not the first time, we need to undo the addition in the</a>
<a name="ln549">          // previous step (`intersect_node` just below)</a>
<a name="ln550">          int last = (lnode != x) ? 1 : 0;</a>
<a name="ln551">          for (int k = 0; k &lt; p-&gt;n + last; k++) {  // one less as p-&gt;ptr[n] is the last</a>
<a name="ln552">            unintersect_node(b, p-&gt;ptr[k], start_id, true);</a>
<a name="ln553">          }</a>
<a name="ln554">          intersect_node(b, p, start_id);</a>
<a name="ln555">          did_bubble = true;</a>
<a name="ln556">        }</a>
<a name="ln557">      }</a>
<a name="ln558"> </a>
<a name="ln559">      lnode = p;</a>
<a name="ln560">      ilvl--;</a>
<a name="ln561">    } while (lnode != cur);</a>
<a name="ln562"> </a>
<a name="ln563">    MTKey deleted = cur-&gt;key[curi];</a>
<a name="ln564">    cur-&gt;key[curi] = intkey;</a>
<a name="ln565">    refkey(b, cur, curi);</a>
<a name="ln566">    // if `did_bubble` then we already added `start_id` to some parent</a>
<a name="ln567">    if (mt_end(cur-&gt;key[curi]) &amp;&amp; !did_bubble) {</a>
<a name="ln568">      uint64_t pi = pseudo_index(x, 0);  // note: sloppy pseudo-index</a>
<a name="ln569">      uint64_t pi_start = pseudo_index_for_id(b, start_id, true);</a>
<a name="ln570">      if (pi_start &gt; 0 &amp;&amp; pi_start &lt; pi) {</a>
<a name="ln571">        intersect_node(b, x, start_id);</a>
<a name="ln572">      }</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">    relative(intkey.pos, &amp;deleted.pos);</a>
<a name="ln576">    MTNode *y = cur-&gt;ptr[curi + 1];</a>
<a name="ln577">    if (deleted.pos.row || deleted.pos.col) {</a>
<a name="ln578">      while (y) {</a>
<a name="ln579">        for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln580">          unrelative(deleted.pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln581">        }</a>
<a name="ln582">        y = y-&gt;level ? y-&gt;ptr[0] : NULL;</a>
<a name="ln583">      }</a>
<a name="ln584">    }</a>
<a name="ln585">    itr-&gt;i--;</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  // 5.</a>
<a name="ln589">  bool itr_dirty = false;</a>
<a name="ln590">  int rlvl = itr-&gt;lvl - 1;</a>
<a name="ln591">  int *lasti = &amp;itr-&gt;i;</a>
<a name="ln592">  MTPos ppos = itr-&gt;pos;</a>
<a name="ln593">  while (x != b-&gt;root) {</a>
<a name="ln594">    assert(rlvl &gt;= 0);</a>
<a name="ln595">    MTNode *p = x-&gt;parent;</a>
<a name="ln596">    if (x-&gt;n &gt;= T - 1) {</a>
<a name="ln597">      // we are done, if this node is fine the rest of the tree will be</a>
<a name="ln598">      break;</a>
<a name="ln599">    }</a>
<a name="ln600">    int pi = itr-&gt;s[rlvl].i;</a>
<a name="ln601">    assert(p-&gt;ptr[pi] == x);</a>
<a name="ln602">    if (pi &gt; 0) {</a>
<a name="ln603">      ppos.row -= p-&gt;key[pi - 1].pos.row;</a>
<a name="ln604">      ppos.col = itr-&gt;s[rlvl].oldcol;</a>
<a name="ln605">    }</a>
<a name="ln606">    // ppos is now the pos of p</a>
<a name="ln607"> </a>
<a name="ln608">    if (pi &gt; 0 &amp;&amp; p-&gt;ptr[pi - 1]-&gt;n &gt; T - 1) {</a>
<a name="ln609">      *lasti += 1;</a>
<a name="ln610">      itr_dirty = true;</a>
<a name="ln611">      // steal one key from the left neighbour</a>
<a name="ln612">      pivot_right(b, ppos, p, pi - 1);</a>
<a name="ln613">      break;</a>
<a name="ln614">    } else if (pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n &gt; T - 1) {</a>
<a name="ln615">      // steal one key from right neighbour</a>
<a name="ln616">      pivot_left(b, ppos, p, pi);</a>
<a name="ln617">      break;</a>
<a name="ln618">    } else if (pi &gt; 0) {</a>
<a name="ln619">      assert(p-&gt;ptr[pi - 1]-&gt;n == T - 1);</a>
<a name="ln620">      // merge with left neighbour</a>
<a name="ln621">      *lasti += T;</a>
<a name="ln622">      x = merge_node(b, p, pi - 1);</a>
<a name="ln623">      if (lasti == &amp;itr-&gt;i) {</a>
<a name="ln624">        // TRICKY: we merged the node the iterator was on</a>
<a name="ln625">        itr-&gt;x = x;</a>
<a name="ln626">      }</a>
<a name="ln627">      itr-&gt;s[rlvl].i--;</a>
<a name="ln628">      itr_dirty = true;</a>
<a name="ln629">    } else {</a>
<a name="ln630">      assert(pi &lt; p-&gt;n &amp;&amp; p-&gt;ptr[pi + 1]-&gt;n == T - 1);</a>
<a name="ln631">      merge_node(b, p, pi);</a>
<a name="ln632">      // no iter adjustment needed</a>
<a name="ln633">    }</a>
<a name="ln634">    lasti = &amp;itr-&gt;s[rlvl].i;</a>
<a name="ln635">    rlvl--;</a>
<a name="ln636">    x = p;</a>
<a name="ln637">  }</a>
<a name="ln638"> </a>
<a name="ln639">  // 6.</a>
<a name="ln640">  if (b-&gt;root-&gt;n == 0) {</a>
<a name="ln641">    if (itr-&gt;lvl &gt; 0) {</a>
<a name="ln642">      memmove(itr-&gt;s, itr-&gt;s + 1, (size_t)(itr-&gt;lvl - 1) * sizeof(*itr-&gt;s));</a>
<a name="ln643">      itr-&gt;lvl--;</a>
<a name="ln644">    }</a>
<a name="ln645">    if (b-&gt;root-&gt;level) {</a>
<a name="ln646">      MTNode *oldroot = b-&gt;root;</a>
<a name="ln647">      b-&gt;root = b-&gt;root-&gt;ptr[0];</a>
<a name="ln648">      b-&gt;root-&gt;parent = NULL;</a>
<a name="ln649">      marktree_free_node(b, oldroot);</a>
<a name="ln650">    } else {</a>
<a name="ln651">      // no items, nothing for iterator to point to</a>
<a name="ln652">      // not strictly needed, should handle delete right-most mark anyway</a>
<a name="ln653">      itr-&gt;x = NULL;</a>
<a name="ln654">    }</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  if (itr-&gt;x &amp;&amp; itr_dirty) {</a>
<a name="ln658">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln659">  }</a>
<a name="ln660"> </a>
<a name="ln661">  // BONUS STEP: fix the iterator, so that it points to the key afterwards</a>
<a name="ln662">  // TODO(bfredl): with &quot;rev&quot; should point before</a>
<a name="ln663">  // if (adjustment == 1) {</a>
<a name="ln664">  //   abort();</a>
<a name="ln665">  // }</a>
<a name="ln666">  if (adjustment == -1) {</a>
<a name="ln667">    // tricky: we stand at the deleted space in the previous leaf node.</a>
<a name="ln668">    // But the inner key is now the previous key we stole, so we need</a>
<a name="ln669">    // to skip that one as well.</a>
<a name="ln670">    marktree_itr_next(b, itr);</a>
<a name="ln671">    marktree_itr_next(b, itr);</a>
<a name="ln672">  } else {</a>
<a name="ln673">    if (itr-&gt;x &amp;&amp; itr-&gt;i &gt;= itr-&gt;x-&gt;n) {</a>
<a name="ln674">      // we deleted the last key of a leaf node</a>
<a name="ln675">      // go to the inner key after that.</a>
<a name="ln676">      assert(itr-&gt;x-&gt;level == 0);</a>
<a name="ln677">      marktree_itr_next(b, itr);</a>
<a name="ln678">    }</a>
<a name="ln679">  }</a>
<a name="ln680"> </a>
<a name="ln681">  return other;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/// similar to intersect_common but modify x and y in place to retain</a>
<a name="ln685">/// only the items which are NOT in common</a>
<a name="ln686">static void intersect_merge(Intersection *restrict m, Intersection *restrict x,</a>
<a name="ln687">                            Intersection *restrict y)</a>
<a name="ln688">{</a>
<a name="ln689">  size_t xi = 0, yi = 0;</a>
<a name="ln690">  size_t xn = 0, yn = 0;</a>
<a name="ln691">  while (xi &lt; kv_size(*x) &amp;&amp; yi &lt; kv_size(*y)) {</a>
<a name="ln692">    if (kv_A(*x, xi) == kv_A(*y, yi)) {</a>
<a name="ln693">      // TODO(bfredl): kvi_pushp is actually quite complex, break out kvi_resize() to a function?</a>
<a name="ln694">      kvi_push(*m, kv_A(*x, xi));</a>
<a name="ln695">      xi++;</a>
<a name="ln696">      yi++;</a>
<a name="ln697">    } else if (kv_A(*x, xi) &lt; kv_A(*y, yi)) {</a>
<a name="ln698">      kv_A(*x, xn++) = kv_A(*x, xi++);</a>
<a name="ln699">    } else {</a>
<a name="ln700">      kv_A(*y, yn++) = kv_A(*y, yi++);</a>
<a name="ln701">    }</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  if (xi &lt; kv_size(*x)) {</a>
<a name="ln705">    memmove(&amp;kv_A(*x, xn), &amp;kv_A(*x, xi), sizeof(kv_A(*x, xn)) * (kv_size(*x) - xi));</a>
<a name="ln706">    xn += kv_size(*x) - xi;</a>
<a name="ln707">  }</a>
<a name="ln708">  if (yi &lt; kv_size(*y)) {</a>
<a name="ln709">    memmove(&amp;kv_A(*y, yn), &amp;kv_A(*y, yi), sizeof(kv_A(*y, yn)) * (kv_size(*y) - yi));</a>
<a name="ln710">    yn += kv_size(*y) - yi;</a>
<a name="ln711">  }</a>
<a name="ln712"> </a>
<a name="ln713">  kv_size(*x) = xn;</a>
<a name="ln714">  kv_size(*y) = yn;</a>
<a name="ln715">}</a>
<a name="ln716"> </a>
<a name="ln717">// w used to be a child of x but it is now a child of y, adjust intersections accordingly</a>
<a name="ln718">// @param[out] d are intersections which should be added to the old children of y</a>
<a name="ln719">static void intersect_mov(Intersection *restrict x, Intersection *restrict y,</a>
<a name="ln720">                          Intersection *restrict w, Intersection *restrict d)</a>
<a name="ln721">{</a>
<a name="ln722">  size_t wi = 0, yi = 0;</a>
<a name="ln723">  size_t wn = 0, yn = 0;</a>
<a name="ln724">  size_t xi = 0;</a>
<a name="ln725">  while (wi &lt; kv_size(*w) || xi &lt; kv_size(*x)) {</a>
<a name="ln726">    if (wi &lt; kv_size(*w) &amp;&amp; (xi &gt;= kv_size(*x) || kv_A(*x, xi) &gt;= kv_A(*w, wi))) {</a>
<a name="ln727">      if (xi &lt; kv_size(*x) &amp;&amp; kv_A(*x, xi) == kv_A(*w, wi)) {</a>
<a name="ln728">        xi++;</a>
<a name="ln729">      }</a>
<a name="ln730">      // now w &lt; x strictly</a>
<a name="ln731">      while (yi &lt; kv_size(*y) &amp;&amp; kv_A(*y, yi) &lt; kv_A(*w, wi)) {</a>
<a name="ln732">        kvi_push(*d, kv_A(*y, yi));</a>
<a name="ln733">        yi++;</a>
<a name="ln734">      }</a>
<a name="ln735">      if (yi &lt; kv_size(*y) &amp;&amp; kv_A(*y, yi) == kv_A(*w, wi)) {</a>
<a name="ln736">        kv_A(*y, yn++) = kv_A(*y, yi++);</a>
<a name="ln737">        wi++;</a>
<a name="ln738">      } else {</a>
<a name="ln739">        kv_A(*w, wn++) = kv_A(*w, wi++);</a>
<a name="ln740">      }</a>
<a name="ln741">    } else {</a>
<a name="ln742">      // x &lt; w strictly</a>
<a name="ln743">      while (yi &lt; kv_size(*y) &amp;&amp; kv_A(*y, yi) &lt; kv_A(*x, xi)) {</a>
<a name="ln744">        kvi_push(*d, kv_A(*y, yi));</a>
<a name="ln745">        yi++;</a>
<a name="ln746">      }</a>
<a name="ln747">      if (yi &lt; kv_size(*y) &amp;&amp; kv_A(*y, yi) == kv_A(*x, xi)) {</a>
<a name="ln748">        kv_A(*y, yn++) = kv_A(*y, yi++);</a>
<a name="ln749">        xi++;</a>
<a name="ln750">      } else {</a>
<a name="ln751">        // add kv_A(x, xi) at kv_A(w, wn), pushing up wi if wi == wn</a>
<a name="ln752">        if (wi == wn) {</a>
<a name="ln753">          size_t n = kv_size(*w) - wn;</a>
<a name="ln754">          kvi_pushp(*w);</a>
<a name="ln755">          if (n &gt; 0) {</a>
<a name="ln756">            memmove(&amp;kv_A(*w, wn + 1), &amp;kv_A(*w, wn), n * sizeof(kv_A(*w, 0)));</a>
<a name="ln757">          }</a>
<a name="ln758">          kv_A(*w, wi) = kv_A(*x, xi);</a>
<a name="ln759">          wn++;</a>
<a name="ln760">          wi++;  // no need to consider the added element again</a>
<a name="ln761">        } else {</a>
<a name="ln762">          assert(wn &lt; wi);</a>
<a name="ln763">          kv_A(*w, wn++) = kv_A(*x, xi);</a>
<a name="ln764">        }</a>
<a name="ln765">        xi++;</a>
<a name="ln766">      }</a>
<a name="ln767">    }</a>
<a name="ln768">  }</a>
<a name="ln769">  if (yi &lt; kv_size(*y)) {</a>
<a name="ln770">    // move remaining items to d</a>
<a name="ln771">    size_t n = kv_size(*y) - yi;  // at least one</a>
<a name="ln772">    kvi_ensure_more_space(*d, n);</a>
<a name="ln773">    memcpy(&amp;kv_A(*d, kv_size(*d)), &amp;kv_A(*y, yi), n * sizeof(kv_A(*d, 0)));</a>
<a name="ln774">    kv_size(*d) += n;</a>
<a name="ln775">  }</a>
<a name="ln776">  kv_size(*w) = wn;</a>
<a name="ln777">  kv_size(*y) = yn;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">bool intersect_mov_test(uint64_t *x, size_t nx, uint64_t *y, size_t ny, uint64_t *win, size_t nwin,</a>
<a name="ln781">                        uint64_t *wout, size_t *nwout, uint64_t *dout, size_t *ndout)</a>
<a name="ln782">{</a>
<a name="ln783">  // x is immutable in the context of intersect_mov. y might shrink, but we</a>
<a name="ln784">  // don't care about it (we get it the deleted ones in d)</a>
<a name="ln785">  Intersection xi = { .items = x, .size = nx };</a>
<a name="ln786">  Intersection yi = { .items = y, .size = ny };</a>
<a name="ln787"> </a>
<a name="ln788">  Intersection w;</a>
<a name="ln789">  kvi_init(w);</a>
<a name="ln790">  for (size_t i = 0; i &lt; nwin; i++) {</a>
<a name="ln791">    kvi_push(w, win[i]);</a>
<a name="ln792">  }</a>
<a name="ln793">  Intersection d;</a>
<a name="ln794">  kvi_init(d);</a>
<a name="ln795"> </a>
<a name="ln796">  intersect_mov(&amp;xi, &amp;yi, &amp;w, &amp;d);</a>
<a name="ln797"> </a>
<a name="ln798">  if (w.size &gt; *nwout || d.size &gt; *ndout) {</a>
<a name="ln799">    return false;</a>
<a name="ln800">  }</a>
<a name="ln801"> </a>
<a name="ln802">  memcpy(wout, w.items, sizeof(w.items[0]) * w.size);</a>
<a name="ln803">  *nwout = w.size;</a>
<a name="ln804"> </a>
<a name="ln805">  memcpy(dout, d.items, sizeof(d.items[0]) * d.size);</a>
<a name="ln806">  *ndout = d.size;</a>
<a name="ln807"> </a>
<a name="ln808">  return true;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">/// intersection: i = x &amp; y</a>
<a name="ln812">static void intersect_common(Intersection *i, Intersection *x, Intersection *y)</a>
<a name="ln813">{</a>
<a name="ln814">  size_t xi = 0, yi = 0;</a>
<a name="ln815">  while (xi &lt; kv_size(*x) &amp;&amp; yi &lt; kv_size(*y)) {</a>
<a name="ln816">    if (kv_A(*x, xi) == kv_A(*y, yi)) {</a>
<a name="ln817">      kvi_push(*i, kv_A(*x, xi));</a>
<a name="ln818">      xi++;</a>
<a name="ln819">      yi++;</a>
<a name="ln820">    } else if (kv_A(*x, xi) &lt; kv_A(*y, yi)) {</a>
<a name="ln821">      xi++;</a>
<a name="ln822">    } else {</a>
<a name="ln823">      yi++;</a>
<a name="ln824">    }</a>
<a name="ln825">  }</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">// inplace union: x |= y</a>
<a name="ln829">static void intersect_add(Intersection *x, Intersection *y)</a>
<a name="ln830">{</a>
<a name="ln831">  size_t xi = 0, yi = 0;</a>
<a name="ln832">  while (xi &lt; kv_size(*x) &amp;&amp; yi &lt; kv_size(*y)) {</a>
<a name="ln833">    if (kv_A(*x, xi) == kv_A(*y, yi)) {</a>
<a name="ln834">      xi++;</a>
<a name="ln835">      yi++;</a>
<a name="ln836">    } else if (kv_A(*y, yi) &lt; kv_A(*x, xi)) {</a>
<a name="ln837">      size_t n = kv_size(*x) - xi;  // at least one</a>
<a name="ln838">      kvi_pushp(*x);</a>
<a name="ln839">      memmove(&amp;kv_A(*x, xi + 1), &amp;kv_A(*x, xi), n * sizeof(kv_A(*x, 0)));</a>
<a name="ln840">      kv_A(*x, xi) = kv_A(*y, yi);</a>
<a name="ln841">      xi++;  // newly added element</a>
<a name="ln842">      yi++;</a>
<a name="ln843">    } else {</a>
<a name="ln844">      xi++;</a>
<a name="ln845">    }</a>
<a name="ln846">  }</a>
<a name="ln847">  if (yi &lt; kv_size(*y)) {</a>
<a name="ln848">    size_t n = kv_size(*y) - yi;  // at least one</a>
<a name="ln849">    kvi_ensure_more_space(*x, n);</a>
<a name="ln850">    memcpy(&amp;kv_A(*x, kv_size(*x)), &amp;kv_A(*y, yi), n * sizeof(kv_A(*x, 0)));</a>
<a name="ln851">    kv_size(*x) += n;</a>
<a name="ln852">  }</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">// inplace assymetric difference: x &amp;= ~y</a>
<a name="ln856">static void intersect_sub(Intersection *restrict x, Intersection *restrict y)</a>
<a name="ln857">{</a>
<a name="ln858">  size_t xi = 0, yi = 0;</a>
<a name="ln859">  size_t xn = 0;</a>
<a name="ln860">  while (xi &lt; kv_size(*x) &amp;&amp; yi &lt; kv_size(*y)) {</a>
<a name="ln861">    if (kv_A(*x, xi) == kv_A(*y, yi)) {</a>
<a name="ln862">      xi++;</a>
<a name="ln863">      yi++;</a>
<a name="ln864">    } else if (kv_A(*x, xi) &lt; kv_A(*y, yi)) {</a>
<a name="ln865">      kv_A(*x, xn++) = kv_A(*x, xi++);</a>
<a name="ln866">    } else {</a>
<a name="ln867">      yi++;</a>
<a name="ln868">    }</a>
<a name="ln869">  }</a>
<a name="ln870">  if (xi &lt; kv_size(*x)) {</a>
<a name="ln871">    size_t n = kv_size(*x) - xi;</a>
<a name="ln872">    if (xn &lt; xi) {  // otherwise xn == xi</a>
<a name="ln873">      memmove(&amp;kv_A(*x, xn), &amp;kv_A(*x, xi), n * sizeof(kv_A(*x, 0)));</a>
<a name="ln874">    }</a>
<a name="ln875">    xn += n;</a>
<a name="ln876">  }</a>
<a name="ln877">  kv_size(*x) = xn;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">/// x is a node which shrunk, or the half of a split</a>
<a name="ln881">///</a>
<a name="ln882">/// this means that intervals which previously intersected all the (current)</a>
<a name="ln883">/// child nodes, now instead intersects `x` itself.</a>
<a name="ln884">static void bubble_up(MTNode *x)</a>
<a name="ln885">{</a>
<a name="ln886">  Intersection xi;</a>
<a name="ln887">  kvi_init(xi);</a>
<a name="ln888">  // due to invariants, the largest subset of _all_ subnodes is the intersection</a>
<a name="ln889">  // between the first and the last</a>
<a name="ln890">  intersect_common(&amp;xi, &amp;x-&gt;ptr[0]-&gt;intersect, &amp;x-&gt;ptr[x-&gt;n]-&gt;intersect);</a>
<a name="ln891">  if (kv_size(xi)) {</a>
<a name="ln892">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln893">      intersect_sub(&amp;x-&gt;ptr[i]-&gt;intersect, &amp;xi);</a>
<a name="ln894">    }</a>
<a name="ln895">    intersect_add(&amp;x-&gt;intersect, &amp;xi);</a>
<a name="ln896">  }</a>
<a name="ln897">  kvi_destroy(xi);</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">static MTNode *merge_node(MarkTree *b, MTNode *p, int i)</a>
<a name="ln901">{</a>
<a name="ln902">  MTNode *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln903">  Intersection m;</a>
<a name="ln904">  kvi_init(m);</a>
<a name="ln905"> </a>
<a name="ln906">  intersect_merge(&amp;m, &amp;x-&gt;intersect, &amp;y-&gt;intersect);</a>
<a name="ln907"> </a>
<a name="ln908">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln909">  refkey(b, x, x-&gt;n);</a>
<a name="ln910">  if (i &gt; 0) {</a>
<a name="ln911">    relative(p-&gt;key[i - 1].pos, &amp;x-&gt;key[x-&gt;n].pos);</a>
<a name="ln912">  }</a>
<a name="ln913"> </a>
<a name="ln914">  memmove(&amp;x-&gt;key[x-&gt;n + 1], y-&gt;key, (size_t)y-&gt;n * sizeof(MTKey));</a>
<a name="ln915">  for (int k = 0; k &lt; y-&gt;n; k++) {</a>
<a name="ln916">    refkey(b, x, x-&gt;n + 1 + k);</a>
<a name="ln917">    unrelative(x-&gt;key[x-&gt;n].pos, &amp;x-&gt;key[x-&gt;n + 1 + k].pos);</a>
<a name="ln918">  }</a>
<a name="ln919">  if (x-&gt;level) {</a>
<a name="ln920">    // bubble down: ranges that intersected old-x but not old-y or vice versa</a>
<a name="ln921">    // must be moved to their respective children</a>
<a name="ln922">    memmove(&amp;x-&gt;ptr[x-&gt;n + 1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(MTNode *));</a>
<a name="ln923">    for (int k = 0; k &lt; x-&gt;n + 1; k++) {</a>
<a name="ln924">      // TODO(bfredl): dedicated impl for &quot;Z |= Y&quot;</a>
<a name="ln925">      for (size_t idx = 0; idx &lt; kv_size(x-&gt;intersect); idx++) {</a>
<a name="ln926">        intersect_node(b, x-&gt;ptr[k], kv_A(x-&gt;intersect, idx));</a>
<a name="ln927">      }</a>
<a name="ln928">    }</a>
<a name="ln929">    for (int ky = 0; ky &lt; y-&gt;n + 1; ky++) {</a>
<a name="ln930">      int k = x-&gt;n + ky + 1;</a>
<a name="ln931">      // nodes that used to be in y, now the second half of x</a>
<a name="ln932">      x-&gt;ptr[k]-&gt;parent = x;</a>
<a name="ln933">      x-&gt;ptr[k]-&gt;p_idx = (int16_t)k;</a>
<a name="ln934">      // TODO(bfredl): dedicated impl for &quot;Z |= X&quot;</a>
<a name="ln935">      for (size_t idx = 0; idx &lt; kv_size(y-&gt;intersect); idx++) {</a>
<a name="ln936">        intersect_node(b, x-&gt;ptr[k], kv_A(y-&gt;intersect, idx));</a>
<a name="ln937">      }</a>
<a name="ln938">    }</a>
<a name="ln939">  }</a>
<a name="ln940">  x-&gt;n += y-&gt;n + 1;</a>
<a name="ln941">  memmove(&amp;p-&gt;key[i], &amp;p-&gt;key[i + 1], (size_t)(p-&gt;n - i - 1) * sizeof(MTKey));</a>
<a name="ln942">  memmove(&amp;p-&gt;ptr[i + 1], &amp;p-&gt;ptr[i + 2],</a>
<a name="ln943">          (size_t)(p-&gt;n - i - 1) * sizeof(MTKey *));</a>
<a name="ln944">  for (int j = i + 1; j &lt; p-&gt;n; j++) {  // note: one has been deleted</a>
<a name="ln945">    p-&gt;ptr[j]-&gt;p_idx = (int16_t)j;</a>
<a name="ln946">  }</a>
<a name="ln947">  p-&gt;n--;</a>
<a name="ln948">  marktree_free_node(b, y);</a>
<a name="ln949"> </a>
<a name="ln950">  kvi_destroy(x-&gt;intersect);</a>
<a name="ln951"> </a>
<a name="ln952">  // move of a kvec_withinit_t, messy!</a>
<a name="ln953">  // TODO(bfredl): special case version of intersect_merge(x_out, x_in_m_out, y) to avoid this</a>
<a name="ln954">  kvi_move(&amp;x-&gt;intersect, &amp;m);</a>
<a name="ln955"> </a>
<a name="ln956">  return x;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">/// @param dest is overwritten (assumed to already been freed/moved)</a>
<a name="ln960">/// @param src consumed (don't free or use)</a>
<a name="ln961">void kvi_move(Intersection *dest, Intersection *src)</a>
<a name="ln962">{</a>
<a name="ln963">  dest-&gt;size = src-&gt;size;</a>
<a name="ln964">  dest-&gt;capacity = src-&gt;capacity;</a>
<a name="ln965">  if (src-&gt;items == src-&gt;init_array) {</a>
<a name="ln966">    memcpy(dest-&gt;init_array, src-&gt;init_array, src-&gt;size * sizeof(*src-&gt;init_array));</a>
<a name="ln967">    dest-&gt;items = dest-&gt;init_array;</a>
<a name="ln968">  } else {</a>
<a name="ln969">    dest-&gt;items = src-&gt;items;</a>
<a name="ln970">  }</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">// TODO(bfredl): as a potential &quot;micro&quot; optimization, pivoting should balance</a>
<a name="ln974">// the two nodes instead of stealing just one key</a>
<a name="ln975">// x_pos is the absolute position of the key just before x (or a dummy key strictly less than any</a>
<a name="ln976">// key inside x, if x is the first leaf)</a>
<a name="ln977">static void pivot_right(MarkTree *b, MTPos p_pos, MTNode *p, const int i)</a>
<a name="ln978">{</a>
<a name="ln979">  MTNode *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln980">  memmove(&amp;y-&gt;key[1], y-&gt;key, (size_t)y-&gt;n * sizeof(MTKey));</a>
<a name="ln981">  if (y-&gt;level) {</a>
<a name="ln982">    memmove(&amp;y-&gt;ptr[1], y-&gt;ptr, ((size_t)y-&gt;n + 1) * sizeof(MTNode *));</a>
<a name="ln983">    for (int j = 1; j &lt; y-&gt;n + 2; j++) {</a>
<a name="ln984">      y-&gt;ptr[j]-&gt;p_idx = (int16_t)j;</a>
<a name="ln985">    }</a>
<a name="ln986">  }</a>
<a name="ln987">  y-&gt;key[0] = p-&gt;key[i];</a>
<a name="ln988">  refkey(b, y, 0);</a>
<a name="ln989">  p-&gt;key[i] = x-&gt;key[x-&gt;n - 1];</a>
<a name="ln990">  refkey(b, p, i);</a>
<a name="ln991">  if (x-&gt;level) {</a>
<a name="ln992">    y-&gt;ptr[0] = x-&gt;ptr[x-&gt;n];</a>
<a name="ln993">    y-&gt;ptr[0]-&gt;parent = y;</a>
<a name="ln994">    y-&gt;ptr[0]-&gt;p_idx = 0;</a>
<a name="ln995">  }</a>
<a name="ln996">  x-&gt;n--;</a>
<a name="ln997">  y-&gt;n++;</a>
<a name="ln998">  if (i &gt; 0) {</a>
<a name="ln999">    unrelative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln1000">  }</a>
<a name="ln1001">  relative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln1002">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln1003">    unrelative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln1004">  }</a>
<a name="ln1005"> </a>
<a name="ln1006">  // repair intersections of x</a>
<a name="ln1007">  if (x-&gt;level) {</a>
<a name="ln1008">    // handle y and first new y-&gt;ptr[0]</a>
<a name="ln1009">    Intersection d;</a>
<a name="ln1010">    kvi_init(d);</a>
<a name="ln1011">    // y-&gt;ptr[0] was moved from x to y</a>
<a name="ln1012">    // adjust y-&gt;ptr[0] for a difference between the parents</a>
<a name="ln1013">    // in addition, this might cause some intersection of the old y</a>
<a name="ln1014">    // to bubble down to the old children of y (if y-&gt;ptr[0] wasn't intersected)</a>
<a name="ln1015">    intersect_mov(&amp;x-&gt;intersect, &amp;y-&gt;intersect, &amp;y-&gt;ptr[0]-&gt;intersect, &amp;d);</a>
<a name="ln1016">    if (kv_size(d)) {</a>
<a name="ln1017">      for (int yi = 1; yi &lt; y-&gt;n + 1; yi++) {</a>
<a name="ln1018">        intersect_add(&amp;y-&gt;ptr[yi]-&gt;intersect, &amp;d);</a>
<a name="ln1019">      }</a>
<a name="ln1020">    }</a>
<a name="ln1021">    kvi_destroy(d);</a>
<a name="ln1022"> </a>
<a name="ln1023">    bubble_up(x);</a>
<a name="ln1024">  } else {</a>
<a name="ln1025">    // if the last element of x used to be an end node, check if it now covers all of x</a>
<a name="ln1026">    if (mt_end(p-&gt;key[i])) {</a>
<a name="ln1027">      uint64_t pi = pseudo_index(x, 0);  // note: sloppy pseudo-index</a>
<a name="ln1028">      uint64_t start_id = mt_lookup_key_side(p-&gt;key[i], false);</a>
<a name="ln1029">      uint64_t pi_start = pseudo_index_for_id(b, start_id, true);</a>
<a name="ln1030">      if (pi_start &gt; 0 &amp;&amp; pi_start &lt; pi) {</a>
<a name="ln1031">        intersect_node(b, x, start_id);</a>
<a name="ln1032">      }</a>
<a name="ln1033">    }</a>
<a name="ln1034"> </a>
<a name="ln1035">    if (mt_start(y-&gt;key[0])) {</a>
<a name="ln1036">      // no need for a check, just delet it if it was there</a>
<a name="ln1037">      unintersect_node(b, y, mt_lookup_key(y-&gt;key[0]), false);</a>
<a name="ln1038">    }</a>
<a name="ln1039">  }</a>
<a name="ln1040">}</a>
<a name="ln1041"> </a>
<a name="ln1042">static void pivot_left(MarkTree *b, MTPos p_pos, MTNode *p, int i)</a>
<a name="ln1043">{</a>
<a name="ln1044">  MTNode *x = p-&gt;ptr[i], *y = p-&gt;ptr[i + 1];</a>
<a name="ln1045"> </a>
<a name="ln1046">  // reverse from how we &quot;always&quot; do it. but pivot_left</a>
<a name="ln1047">  // is just the inverse of pivot_right, so reverse it literally.</a>
<a name="ln1048">  for (int k = 1; k &lt; y-&gt;n; k++) {</a>
<a name="ln1049">    relative(y-&gt;key[0].pos, &amp;y-&gt;key[k].pos);</a>
<a name="ln1050">  }</a>
<a name="ln1051">  unrelative(p-&gt;key[i].pos, &amp;y-&gt;key[0].pos);</a>
<a name="ln1052">  if (i &gt; 0) {</a>
<a name="ln1053">    relative(p-&gt;key[i - 1].pos, &amp;p-&gt;key[i].pos);</a>
<a name="ln1054">  }</a>
<a name="ln1055"> </a>
<a name="ln1056">  x-&gt;key[x-&gt;n] = p-&gt;key[i];</a>
<a name="ln1057">  refkey(b, x, x-&gt;n);</a>
<a name="ln1058">  p-&gt;key[i] = y-&gt;key[0];</a>
<a name="ln1059">  refkey(b, p, i);</a>
<a name="ln1060">  if (x-&gt;level) {</a>
<a name="ln1061">    x-&gt;ptr[x-&gt;n + 1] = y-&gt;ptr[0];</a>
<a name="ln1062">    x-&gt;ptr[x-&gt;n + 1]-&gt;parent = x;</a>
<a name="ln1063">    x-&gt;ptr[x-&gt;n + 1]-&gt;p_idx = (int16_t)(x-&gt;n + 1);</a>
<a name="ln1064">  }</a>
<a name="ln1065">  memmove(y-&gt;key, &amp;y-&gt;key[1], (size_t)(y-&gt;n - 1) * sizeof(MTKey));</a>
<a name="ln1066">  if (y-&gt;level) {</a>
<a name="ln1067">    memmove(y-&gt;ptr, &amp;y-&gt;ptr[1], (size_t)y-&gt;n * sizeof(MTNode *));</a>
<a name="ln1068">    for (int j = 0; j &lt; y-&gt;n; j++) {  // note: last item deleted</a>
<a name="ln1069">      y-&gt;ptr[j]-&gt;p_idx = (int16_t)j;</a>
<a name="ln1070">    }</a>
<a name="ln1071">  }</a>
<a name="ln1072">  x-&gt;n++;</a>
<a name="ln1073">  y-&gt;n--;</a>
<a name="ln1074"> </a>
<a name="ln1075">  // repair intersections of x,y</a>
<a name="ln1076">  if (x-&gt;level) {</a>
<a name="ln1077">    // handle y and first new y-&gt;ptr[0]</a>
<a name="ln1078">    Intersection d;</a>
<a name="ln1079">    kvi_init(d);</a>
<a name="ln1080">    // x-&gt;ptr[x-&gt;n] was moved from y to x</a>
<a name="ln1081">    // adjust x-&gt;ptr[x-&gt;n] for a difference between the parents</a>
<a name="ln1082">    // in addition, this might cause some intersection of the old x</a>
<a name="ln1083">    // to bubble down to the old children of x (if x-&gt;ptr[n] wasn't intersected)</a>
<a name="ln1084">    intersect_mov(&amp;y-&gt;intersect, &amp;x-&gt;intersect, &amp;x-&gt;ptr[x-&gt;n]-&gt;intersect, &amp;d);</a>
<a name="ln1085">    if (kv_size(d)) {</a>
<a name="ln1086">      for (int xi = 0; xi &lt; x-&gt;n; xi++) {  // ptr[x-&gt;n| deliberately skipped</a>
<a name="ln1087">        intersect_add(&amp;x-&gt;ptr[xi]-&gt;intersect, &amp;d);</a>
<a name="ln1088">      }</a>
<a name="ln1089">    }</a>
<a name="ln1090">    kvi_destroy(d);</a>
<a name="ln1091"> </a>
<a name="ln1092">    bubble_up(y);</a>
<a name="ln1093">  } else {</a>
<a name="ln1094">    // if the first element of y used to be an start node, check if it now covers all of y</a>
<a name="ln1095">    if (mt_start(p-&gt;key[i])) {</a>
<a name="ln1096">      uint64_t pi = pseudo_index(y, 0);  // note: sloppy pseudo-index</a>
<a name="ln1097"> </a>
<a name="ln1098">      uint64_t end_id = mt_lookup_key_side(p-&gt;key[i], true);</a>
<a name="ln1099">      uint64_t pi_end = pseudo_index_for_id(b, end_id, true);</a>
<a name="ln1100"> </a>
<a name="ln1101">      if (pi_end &gt; pi) {</a>
<a name="ln1102">        intersect_node(b, y, mt_lookup_key(p-&gt;key[i]));</a>
<a name="ln1103">      }</a>
<a name="ln1104">    }</a>
<a name="ln1105"> </a>
<a name="ln1106">    if (mt_end(x-&gt;key[x-&gt;n - 1])) {</a>
<a name="ln1107">      // no need for a check, just delet it if it was there</a>
<a name="ln1108">      unintersect_node(b, x, mt_lookup_key_side(x-&gt;key[x-&gt;n - 1], false), false);</a>
<a name="ln1109">    }</a>
<a name="ln1110">  }</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">/// frees all mem, resets tree to valid empty state</a>
<a name="ln1114">void marktree_clear(MarkTree *b)</a>
<a name="ln1115">{</a>
<a name="ln1116">  if (b-&gt;root) {</a>
<a name="ln1117">    marktree_free_subtree(b, b-&gt;root);</a>
<a name="ln1118">    b-&gt;root = NULL;</a>
<a name="ln1119">  }</a>
<a name="ln1120">  map_destroy(uint64_t, b-&gt;id2node);</a>
<a name="ln1121">  *b-&gt;id2node = (PMap(uint64_t)) MAP_INIT;</a>
<a name="ln1122">  b-&gt;n_keys = 0;</a>
<a name="ln1123">  assert(b-&gt;n_nodes == 0);</a>
<a name="ln1124">}</a>
<a name="ln1125"> </a>
<a name="ln1126">void marktree_free_subtree(MarkTree *b, MTNode *x)</a>
<a name="ln1127">{</a>
<a name="ln1128">  if (x-&gt;level) {</a>
<a name="ln1129">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln1130">      marktree_free_subtree(b, x-&gt;ptr[i]);</a>
<a name="ln1131">    }</a>
<a name="ln1132">  }</a>
<a name="ln1133">  marktree_free_node(b, x);</a>
<a name="ln1134">}</a>
<a name="ln1135"> </a>
<a name="ln1136">static void marktree_free_node(MarkTree *b, MTNode *x)</a>
<a name="ln1137">{</a>
<a name="ln1138">  kvi_destroy(x-&gt;intersect);</a>
<a name="ln1139">  xfree(x);</a>
<a name="ln1140">  b-&gt;n_nodes--;</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">/// NB: caller must check not pair!</a>
<a name="ln1144">void marktree_revise(MarkTree *b, MarkTreeIter *itr, uint8_t decor_level, MTKey key)</a>
<a name="ln1145">{</a>
<a name="ln1146">  // TODO(bfredl): clean up this mess and re-instantiate &amp;= and |= forms</a>
<a name="ln1147">  // once we upgrade to a non-broken version of gcc in functionaltest-lua CI</a>
<a name="ln1148">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags &amp; (uint16_t) ~MT_FLAG_DECOR_MASK);</a>
<a name="ln1149">  rawkey(itr).flags = (uint16_t)(rawkey(itr).flags</a>
<a name="ln1150">                                 | (uint16_t)(decor_level &lt;&lt; MT_FLAG_DECOR_OFFSET)</a>
<a name="ln1151">                                 | (uint16_t)(key.flags &amp; MT_FLAG_DECOR_MASK));</a>
<a name="ln1152">  rawkey(itr).decor_full = key.decor_full;</a>
<a name="ln1153">  rawkey(itr).hl_id = key.hl_id;</a>
<a name="ln1154">  rawkey(itr).priority = key.priority;</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">/// @param itr iterator is invalid after call</a>
<a name="ln1158">void marktree_move(MarkTree *b, MarkTreeIter *itr, int row, int col)</a>
<a name="ln1159">{</a>
<a name="ln1160">  MTKey key = rawkey(itr);</a>
<a name="ln1161">  MTNode *x = itr-&gt;x;</a>
<a name="ln1162">  if (!x-&gt;level) {</a>
<a name="ln1163">    bool internal = false;</a>
<a name="ln1164">    MTPos newpos = MTPos(row, col);</a>
<a name="ln1165">    if (x-&gt;parent != NULL) {</a>
<a name="ln1166">      // strictly _after_ key before `x`</a>
<a name="ln1167">      // (not optimal when x is very first leaf of the entire tree, but that's fine)</a>
<a name="ln1168">      if (pos_less(itr-&gt;pos, newpos)) {</a>
<a name="ln1169">        relative(itr-&gt;pos, &amp;newpos);</a>
<a name="ln1170"> </a>
<a name="ln1171">        // strictly before the end of x. (this could be made sharper by</a>
<a name="ln1172">        // finding the internal key just after x, but meh)</a>
<a name="ln1173">        if (pos_less(newpos, x-&gt;key[x-&gt;n - 1].pos)) {</a>
<a name="ln1174">          internal = true;</a>
<a name="ln1175">        }</a>
<a name="ln1176">      }</a>
<a name="ln1177">    } else {</a>
<a name="ln1178">      // tree is one node. newpos thus is already &quot;relative&quot; itr-&gt;pos</a>
<a name="ln1179">      internal = true;</a>
<a name="ln1180">    }</a>
<a name="ln1181"> </a>
<a name="ln1182">    if (internal) {</a>
<a name="ln1183">      if (key.pos.row == newpos.row &amp;&amp; key.pos.col == newpos.col) {</a>
<a name="ln1184">        return;</a>
<a name="ln1185">      }</a>
<a name="ln1186">      key.pos = newpos;</a>
<a name="ln1187">      bool match;</a>
<a name="ln1188">      // tricky: could minimize movement in either direction better</a>
<a name="ln1189">      int new_i = marktree_getp_aux(x, key, &amp;match);</a>
<a name="ln1190">      if (!match) {</a>
<a name="ln1191">        new_i++;</a>
<a name="ln1192">      }</a>
<a name="ln1193">      if (new_i == itr-&gt;i) {</a>
<a name="ln1194">        x-&gt;key[itr-&gt;i].pos = newpos;</a>
<a name="ln1195">      } else if (new_i &lt; itr-&gt;i) {</a>
<a name="ln1196">        memmove(&amp;x-&gt;key[new_i + 1], &amp;x-&gt;key[new_i], sizeof(MTKey) * (size_t)(itr-&gt;i - new_i));</a>
<a name="ln1197">        x-&gt;key[new_i] = key;</a>
<a name="ln1198">      } else if (new_i &gt; itr-&gt;i) {</a>
<a name="ln1199">        memmove(&amp;x-&gt;key[itr-&gt;i], &amp;x-&gt;key[itr-&gt;i + 1], sizeof(MTKey) * (size_t)(new_i - itr-&gt;i - 1));</a>
<a name="ln1200">        x-&gt;key[new_i - 1] = key;</a>
<a name="ln1201">      }</a>
<a name="ln1202">      return;</a>
<a name="ln1203">    }</a>
<a name="ln1204">  }</a>
<a name="ln1205">  uint64_t other = marktree_del_itr(b, itr, false);</a>
<a name="ln1206">  key.pos = (MTPos){ row, col };</a>
<a name="ln1207"> </a>
<a name="ln1208">  marktree_put_key(b, key);</a>
<a name="ln1209"> </a>
<a name="ln1210">  if (other) {</a>
<a name="ln1211">    marktree_restore_pair(b, key);</a>
<a name="ln1212">  }</a>
<a name="ln1213">  itr-&gt;x = NULL;  // itr might become invalid by put</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">void marktree_restore_pair(MarkTree *b, MTKey key)</a>
<a name="ln1217">{</a>
<a name="ln1218">  MarkTreeIter itr[1];</a>
<a name="ln1219">  MarkTreeIter end_itr[1];</a>
<a name="ln1220">  marktree_lookup(b, mt_lookup_key_side(key, false), itr);</a>
<a name="ln1221">  marktree_lookup(b, mt_lookup_key_side(key, true), end_itr);</a>
<a name="ln1222">  if (!itr-&gt;x || !end_itr-&gt;x) {</a>
<a name="ln1223">    // this could happen if the other end is waiting to be restored later</a>
<a name="ln1224">    // this function will be called again for the other end.</a>
<a name="ln1225">    return;</a>
<a name="ln1226">  }</a>
<a name="ln1227">  rawkey(itr).flags &amp;= (uint16_t) ~MT_FLAG_ORPHANED;</a>
<a name="ln1228">  rawkey(end_itr).flags &amp;= (uint16_t) ~MT_FLAG_ORPHANED;</a>
<a name="ln1229"> </a>
<a name="ln1230">  marktree_intersect_pair(b, mt_lookup_key_side(key, false), itr, end_itr, false);</a>
<a name="ln1231">}</a>
<a name="ln1232"> </a>
<a name="ln1233">// itr functions</a>
<a name="ln1234"> </a>
<a name="ln1235">bool marktree_itr_get(MarkTree *b, int32_t row, int col, MarkTreeIter *itr)</a>
<a name="ln1236">{</a>
<a name="ln1237">  return marktree_itr_get_ext(b, MTPos(row, col), itr, false, false, NULL);</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">bool marktree_itr_get_ext(MarkTree *b, MTPos p, MarkTreeIter *itr, bool last, bool gravity,</a>
<a name="ln1241">                          MTPos *oldbase)</a>
<a name="ln1242">{</a>
<a name="ln1243">  if (b-&gt;n_keys == 0) {</a>
<a name="ln1244">    itr-&gt;x = NULL;</a>
<a name="ln1245">    return false;</a>
<a name="ln1246">  }</a>
<a name="ln1247"> </a>
<a name="ln1248">  MTKey k = { .pos = p, .flags = gravity ? MT_FLAG_RIGHT_GRAVITY : 0 };</a>
<a name="ln1249">  if (last &amp;&amp; !gravity) {</a>
<a name="ln1250">    k.flags = MT_FLAG_LAST;</a>
<a name="ln1251">  }</a>
<a name="ln1252">  itr-&gt;pos = (MTPos){ 0, 0 };</a>
<a name="ln1253">  itr-&gt;x = b-&gt;root;</a>
<a name="ln1254">  itr-&gt;lvl = 0;</a>
<a name="ln1255">  if (oldbase) {</a>
<a name="ln1256">    oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln1257">  }</a>
<a name="ln1258">  while (true) {</a>
<a name="ln1259">    itr-&gt;i = marktree_getp_aux(itr-&gt;x, k, 0) + 1;</a>
<a name="ln1260"> </a>
<a name="ln1261">    if (itr-&gt;x-&gt;level == 0) {</a>
<a name="ln1262">      break;</a>
<a name="ln1263">    }</a>
<a name="ln1264"> </a>
<a name="ln1265">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1266">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1267"> </a>
<a name="ln1268">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln1269">      compose(&amp;itr-&gt;pos, itr-&gt;x-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln1270">      relative(itr-&gt;x-&gt;key[itr-&gt;i - 1].pos, &amp;k.pos);</a>
<a name="ln1271">    }</a>
<a name="ln1272">    itr-&gt;x = itr-&gt;x-&gt;ptr[itr-&gt;i];</a>
<a name="ln1273">    itr-&gt;lvl++;</a>
<a name="ln1274">    if (oldbase) {</a>
<a name="ln1275">      oldbase[itr-&gt;lvl] = itr-&gt;pos;</a>
<a name="ln1276">    }</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  if (last) {</a>
<a name="ln1280">    return marktree_itr_prev(b, itr);</a>
<a name="ln1281">  } else if (itr-&gt;i &gt;= itr-&gt;x-&gt;n) {</a>
<a name="ln1282">    return marktree_itr_next(b, itr);</a>
<a name="ln1283">  }</a>
<a name="ln1284">  return true;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">bool marktree_itr_first(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1288">{</a>
<a name="ln1289">  if (b-&gt;n_keys == 0) {</a>
<a name="ln1290">    itr-&gt;x = NULL;</a>
<a name="ln1291">    return false;</a>
<a name="ln1292">  }</a>
<a name="ln1293"> </a>
<a name="ln1294">  itr-&gt;x = b-&gt;root;</a>
<a name="ln1295">  itr-&gt;i = 0;</a>
<a name="ln1296">  itr-&gt;lvl = 0;</a>
<a name="ln1297">  itr-&gt;pos = MTPos(0, 0);</a>
<a name="ln1298">  while (itr-&gt;x-&gt;level &gt; 0) {</a>
<a name="ln1299">    itr-&gt;s[itr-&gt;lvl].i = 0;</a>
<a name="ln1300">    itr-&gt;s[itr-&gt;lvl].oldcol = 0;</a>
<a name="ln1301">    itr-&gt;lvl++;</a>
<a name="ln1302">    itr-&gt;x = itr-&gt;x-&gt;ptr[0];</a>
<a name="ln1303">  }</a>
<a name="ln1304">  return true;</a>
<a name="ln1305">}</a>
<a name="ln1306"> </a>
<a name="ln1307">// gives the first key that is greater or equal to p</a>
<a name="ln1308">int marktree_itr_last(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1309">{</a>
<a name="ln1310">  if (b-&gt;n_keys == 0) {</a>
<a name="ln1311">    itr-&gt;x = NULL;</a>
<a name="ln1312">    return false;</a>
<a name="ln1313">  }</a>
<a name="ln1314">  itr-&gt;pos = MTPos(0, 0);</a>
<a name="ln1315">  itr-&gt;x = b-&gt;root;</a>
<a name="ln1316">  itr-&gt;lvl = 0;</a>
<a name="ln1317">  while (true) {</a>
<a name="ln1318">    itr-&gt;i = itr-&gt;x-&gt;n;</a>
<a name="ln1319"> </a>
<a name="ln1320">    if (itr-&gt;x-&gt;level == 0) {</a>
<a name="ln1321">      break;</a>
<a name="ln1322">    }</a>
<a name="ln1323"> </a>
<a name="ln1324">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1325">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1326"> </a>
<a name="ln1327">    assert(itr-&gt;i &gt; 0);</a>
<a name="ln1328">    compose(&amp;itr-&gt;pos, itr-&gt;x-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln1329"> </a>
<a name="ln1330">    itr-&gt;x = itr-&gt;x-&gt;ptr[itr-&gt;i];</a>
<a name="ln1331">    itr-&gt;lvl++;</a>
<a name="ln1332">  }</a>
<a name="ln1333">  itr-&gt;i--;</a>
<a name="ln1334">  return true;</a>
<a name="ln1335">}</a>
<a name="ln1336"> </a>
<a name="ln1337">bool marktree_itr_next(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1338">{</a>
<a name="ln1339">  return marktree_itr_next_skip(b, itr, false, false, NULL);</a>
<a name="ln1340">}</a>
<a name="ln1341"> </a>
<a name="ln1342">static bool marktree_itr_next_skip(MarkTree *b, MarkTreeIter *itr, bool skip, bool preload,</a>
<a name="ln1343">                                   MTPos oldbase[])</a>
<a name="ln1344">{</a>
<a name="ln1345">  if (!itr-&gt;x) {</a>
<a name="ln1346">    return false;</a>
<a name="ln1347">  }</a>
<a name="ln1348">  itr-&gt;i++;</a>
<a name="ln1349">  if (itr-&gt;x-&gt;level == 0 || skip) {</a>
<a name="ln1350">    if (preload &amp;&amp; itr-&gt;x-&gt;level == 0 &amp;&amp; skip) {</a>
<a name="ln1351">      // skip rest of this leaf node</a>
<a name="ln1352">      itr-&gt;i = itr-&gt;x-&gt;n;</a>
<a name="ln1353">    } else if (itr-&gt;i &lt; itr-&gt;x-&gt;n) {</a>
<a name="ln1354">      // TODO(bfredl): this is the common case,</a>
<a name="ln1355">      // and could be handled by inline wrapper</a>
<a name="ln1356">      return true;</a>
<a name="ln1357">    }</a>
<a name="ln1358">    // we ran out of non-internal keys. Go up until we find an internal key</a>
<a name="ln1359">    while (itr-&gt;i &gt;= itr-&gt;x-&gt;n) {</a>
<a name="ln1360">      itr-&gt;x = itr-&gt;x-&gt;parent;</a>
<a name="ln1361">      if (itr-&gt;x == NULL) {</a>
<a name="ln1362">        return false;</a>
<a name="ln1363">      }</a>
<a name="ln1364">      itr-&gt;lvl--;</a>
<a name="ln1365">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln1366">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln1367">        itr-&gt;pos.row -= itr-&gt;x-&gt;key[itr-&gt;i - 1].pos.row;</a>
<a name="ln1368">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln1369">      }</a>
<a name="ln1370">    }</a>
<a name="ln1371">  } else {</a>
<a name="ln1372">    // we stood at an &quot;internal&quot; key. Go down to the first non-internal</a>
<a name="ln1373">    // key after it.</a>
<a name="ln1374">    while (itr-&gt;x-&gt;level &gt; 0) {</a>
<a name="ln1375">      // internal key, there is always a child after</a>
<a name="ln1376">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln1377">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1378">        compose(&amp;itr-&gt;pos, itr-&gt;x-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln1379">      }</a>
<a name="ln1380">      if (oldbase &amp;&amp; itr-&gt;i == 0) {</a>
<a name="ln1381">        oldbase[itr-&gt;lvl + 1] = oldbase[itr-&gt;lvl];</a>
<a name="ln1382">      }</a>
<a name="ln1383">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1384">      assert(itr-&gt;x-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;x);</a>
<a name="ln1385">      itr-&gt;lvl++;</a>
<a name="ln1386">      itr-&gt;x = itr-&gt;x-&gt;ptr[itr-&gt;i];</a>
<a name="ln1387">      if (preload &amp;&amp; itr-&gt;x-&gt;level) {</a>
<a name="ln1388">        itr-&gt;i = -1;</a>
<a name="ln1389">        break;</a>
<a name="ln1390">      } else {</a>
<a name="ln1391">        itr-&gt;i = 0;</a>
<a name="ln1392">      }</a>
<a name="ln1393">    }</a>
<a name="ln1394">  }</a>
<a name="ln1395">  return true;</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">bool marktree_itr_prev(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1399">{</a>
<a name="ln1400">  if (!itr-&gt;x) {</a>
<a name="ln1401">    return false;</a>
<a name="ln1402">  }</a>
<a name="ln1403">  if (itr-&gt;x-&gt;level == 0) {</a>
<a name="ln1404">    itr-&gt;i--;</a>
<a name="ln1405">    if (itr-&gt;i &gt;= 0) {</a>
<a name="ln1406">      // TODO(bfredl): this is the common case,</a>
<a name="ln1407">      // and could be handled by inline wrapper</a>
<a name="ln1408">      return true;</a>
<a name="ln1409">    }</a>
<a name="ln1410">    // we ran out of non-internal keys. Go up until we find a non-internal key</a>
<a name="ln1411">    while (itr-&gt;i &lt; 0) {</a>
<a name="ln1412">      itr-&gt;x = itr-&gt;x-&gt;parent;</a>
<a name="ln1413">      if (itr-&gt;x == NULL) {</a>
<a name="ln1414">        return false;</a>
<a name="ln1415">      }</a>
<a name="ln1416">      itr-&gt;lvl--;</a>
<a name="ln1417">      itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i - 1;</a>
<a name="ln1418">      if (itr-&gt;i &gt;= 0) {</a>
<a name="ln1419">        itr-&gt;pos.row -= itr-&gt;x-&gt;key[itr-&gt;i].pos.row;</a>
<a name="ln1420">        itr-&gt;pos.col = itr-&gt;s[itr-&gt;lvl].oldcol;</a>
<a name="ln1421">      }</a>
<a name="ln1422">    }</a>
<a name="ln1423">  } else {</a>
<a name="ln1424">    // we stood at an &quot;internal&quot; key. Go down to the last non-internal</a>
<a name="ln1425">    // key before it.</a>
<a name="ln1426">    while (itr-&gt;x-&gt;level &gt; 0) {</a>
<a name="ln1427">      // internal key, there is always a child before</a>
<a name="ln1428">      if (itr-&gt;i &gt; 0) {</a>
<a name="ln1429">        itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1430">        compose(&amp;itr-&gt;pos, itr-&gt;x-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln1431">      }</a>
<a name="ln1432">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1433">      assert(itr-&gt;x-&gt;ptr[itr-&gt;i]-&gt;parent == itr-&gt;x);</a>
<a name="ln1434">      itr-&gt;x = itr-&gt;x-&gt;ptr[itr-&gt;i];</a>
<a name="ln1435">      itr-&gt;i = itr-&gt;x-&gt;n;</a>
<a name="ln1436">      itr-&gt;lvl++;</a>
<a name="ln1437">    }</a>
<a name="ln1438">    itr-&gt;i--;</a>
<a name="ln1439">  }</a>
<a name="ln1440">  return true;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">bool marktree_itr_node_done(MarkTreeIter *itr)</a>
<a name="ln1444">{</a>
<a name="ln1445">  return !itr-&gt;x || itr-&gt;i == itr-&gt;x-&gt;n - 1;</a>
<a name="ln1446">}</a>
<a name="ln1447"> </a>
<a name="ln1448">MTPos marktree_itr_pos(MarkTreeIter *itr)</a>
<a name="ln1449">{</a>
<a name="ln1450">  MTPos pos = rawkey(itr).pos;</a>
<a name="ln1451">  unrelative(itr-&gt;pos, &amp;pos);</a>
<a name="ln1452">  return pos;</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">MTKey marktree_itr_current(MarkTreeIter *itr)</a>
<a name="ln1456">{</a>
<a name="ln1457">  if (itr-&gt;x) {</a>
<a name="ln1458">    MTKey key = rawkey(itr);</a>
<a name="ln1459">    key.pos = marktree_itr_pos(itr);</a>
<a name="ln1460">    return key;</a>
<a name="ln1461">  }</a>
<a name="ln1462">  return MT_INVALID_KEY;</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">static bool itr_eq(MarkTreeIter *itr1, MarkTreeIter *itr2)</a>
<a name="ln1466">{</a>
<a name="ln1467">  return (&amp;rawkey(itr1) == &amp;rawkey(itr2));</a>
<a name="ln1468">}</a>
<a name="ln1469"> </a>
<a name="ln1470">/// Get all marks which overlaps the position (row,col)</a>
<a name="ln1471">///</a>
<a name="ln1472">/// After calling this function, use marktree_itr_step_overlap to step through</a>
<a name="ln1473">/// one overlapping mark at a time, until it returns false</a>
<a name="ln1474">///</a>
<a name="ln1475">/// NOTE: It's possible to get all marks which overlaps a region (row,col) to (row_end,col_end)</a>
<a name="ln1476">/// To do this, first call marktree_itr_get_overlap with the start position and</a>
<a name="ln1477">/// keep calling marktree_itr_step_overlap until it returns false.</a>
<a name="ln1478">/// After this, as a second loop, keep calling the marktree_itr_next() until</a>
<a name="ln1479">/// the iterator is invalid or reaches past (row_end, col_end). In this loop,</a>
<a name="ln1480">/// consider all &quot;start&quot; marks (and unpaired marks if relevant), but skip over</a>
<a name="ln1481">/// all &quot;end&quot; marks, using mt_end(mark).</a>
<a name="ln1482">///</a>
<a name="ln1483">/// @return false if we already know no marks can be found</a>
<a name="ln1484">///               even if &quot;true&quot; the first call to marktree_itr_step_overlap</a>
<a name="ln1485">///               could return false</a>
<a name="ln1486">bool marktree_itr_get_overlap(MarkTree *b, int row, int col, MarkTreeIter *itr)</a>
<a name="ln1487">{</a>
<a name="ln1488">  if (b-&gt;n_keys == 0) {</a>
<a name="ln1489">    itr-&gt;x = NULL;</a>
<a name="ln1490">    return false;</a>
<a name="ln1491">  }</a>
<a name="ln1492"> </a>
<a name="ln1493">  itr-&gt;x = b-&gt;root;</a>
<a name="ln1494">  itr-&gt;i = -1;</a>
<a name="ln1495">  itr-&gt;lvl = 0;</a>
<a name="ln1496">  itr-&gt;pos = MTPos(0, 0);</a>
<a name="ln1497">  itr-&gt;intersect_pos = MTPos(row, col);</a>
<a name="ln1498">  // intersect_pos but will be adjusted relative itr-&gt;x</a>
<a name="ln1499">  itr-&gt;intersect_pos_x = MTPos(row, col);</a>
<a name="ln1500">  itr-&gt;intersect_idx = 0;</a>
<a name="ln1501">  return true;</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">static inline MTPair pair_from(MTKey start, MTKey end)</a>
<a name="ln1505">{</a>
<a name="ln1506">  return (MTPair){ .start = start, .end_pos = end.pos, .end_right_gravity = mt_right(end) };</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">/// Step through all overlapping pairs at a position.</a>
<a name="ln1510">///</a>
<a name="ln1511">/// This function must only be used with an iterator from |marktree_itr_step_overlap|</a>
<a name="ln1512">///</a>
<a name="ln1513">/// @return true if a valid pair was found (returned as `pair`)</a>
<a name="ln1514">/// When all overlapping mark pairs have been found, false will be returned. `itr`</a>
<a name="ln1515">/// is then valid as an ordinary iterator at the (row, col) position specified in</a>
<a name="ln1516">/// marktree_itr_step_overlap</a>
<a name="ln1517">bool marktree_itr_step_overlap(MarkTree *b, MarkTreeIter *itr, MTPair *pair)</a>
<a name="ln1518">{</a>
<a name="ln1519">  // phase one: we start at the root node and step inwards towards itr-&gt;intersect_pos</a>
<a name="ln1520">  // (the position queried in marktree_itr_get_overlap)</a>
<a name="ln1521">  //</a>
<a name="ln1522">  // For each node (ancestor node to the node containing the sought position)</a>
<a name="ln1523">  // we return all intersecting intervals, one at a time</a>
<a name="ln1524">  while (itr-&gt;i == -1) {</a>
<a name="ln1525">    if (itr-&gt;intersect_idx &lt; kv_size(itr-&gt;x-&gt;intersect)) {</a>
<a name="ln1526">      uint64_t id = kv_A(itr-&gt;x-&gt;intersect, itr-&gt;intersect_idx++);</a>
<a name="ln1527">      *pair = pair_from(marktree_lookup(b, id, NULL),</a>
<a name="ln1528">                        marktree_lookup(b, id|MARKTREE_END_FLAG, NULL));</a>
<a name="ln1529">      return true;</a>
<a name="ln1530">    }</a>
<a name="ln1531"> </a>
<a name="ln1532">    if (itr-&gt;x-&gt;level == 0) {</a>
<a name="ln1533">      itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i = 0;</a>
<a name="ln1534">      break;</a>
<a name="ln1535">    }</a>
<a name="ln1536"> </a>
<a name="ln1537">    MTKey k = { .pos = itr-&gt;intersect_pos_x, .flags = 0 };</a>
<a name="ln1538">    itr-&gt;i = marktree_getp_aux(itr-&gt;x, k, 0) + 1;</a>
<a name="ln1539"> </a>
<a name="ln1540">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1541">    itr-&gt;s[itr-&gt;lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1542"> </a>
<a name="ln1543">    if (itr-&gt;i &gt; 0) {</a>
<a name="ln1544">      compose(&amp;itr-&gt;pos, itr-&gt;x-&gt;key[itr-&gt;i - 1].pos);</a>
<a name="ln1545">      relative(itr-&gt;x-&gt;key[itr-&gt;i - 1].pos, &amp;itr-&gt;intersect_pos_x);</a>
<a name="ln1546">    }</a>
<a name="ln1547">    itr-&gt;x = itr-&gt;x-&gt;ptr[itr-&gt;i];</a>
<a name="ln1548">    itr-&gt;lvl++;</a>
<a name="ln1549">    itr-&gt;i = -1;</a>
<a name="ln1550">    itr-&gt;intersect_idx = 0;</a>
<a name="ln1551">  }</a>
<a name="ln1552"> </a>
<a name="ln1553">  // phase two: we now need to handle the node found at itr-&gt;intersect_pos</a>
<a name="ln1554">  // first consider all start nodes in the node before this position.</a>
<a name="ln1555">  while (itr-&gt;i &lt; itr-&gt;x-&gt;n &amp;&amp; pos_less(rawkey(itr).pos, itr-&gt;intersect_pos_x)) {</a>
<a name="ln1556">    MTKey k = itr-&gt;x-&gt;key[itr-&gt;i++];</a>
<a name="ln1557">    itr-&gt;s[itr-&gt;lvl].i = itr-&gt;i;</a>
<a name="ln1558">    if (mt_start(k)) {</a>
<a name="ln1559">      MTKey end = marktree_lookup(b, mt_lookup_id(k.ns, k.id, true), NULL);</a>
<a name="ln1560">      if (pos_less(end.pos, itr-&gt;intersect_pos)) {</a>
<a name="ln1561">        continue;</a>
<a name="ln1562">      }</a>
<a name="ln1563"> </a>
<a name="ln1564">      unrelative(itr-&gt;pos, &amp;k.pos);</a>
<a name="ln1565">      *pair = pair_from(k, end);</a>
<a name="ln1566">      return true;  // it's a start!</a>
<a name="ln1567">    }</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570">  // phase 2B: We also need to step to the end of this node and consider all end marks, which</a>
<a name="ln1571">  // might end an interval overlapping itr-&gt;intersect_pos</a>
<a name="ln1572">  while (itr-&gt;i &lt; itr-&gt;x-&gt;n) {</a>
<a name="ln1573">    MTKey k = itr-&gt;x-&gt;key[itr-&gt;i++];</a>
<a name="ln1574">    if (mt_end(k)) {</a>
<a name="ln1575">      uint64_t id = mt_lookup_id(k.ns, k.id, false);</a>
<a name="ln1576">      if (id2node(b, id) == itr-&gt;x) {</a>
<a name="ln1577">        continue;</a>
<a name="ln1578">      }</a>
<a name="ln1579">      unrelative(itr-&gt;pos, &amp;k.pos);</a>
<a name="ln1580">      MTKey start = marktree_lookup(b, id, NULL);</a>
<a name="ln1581">      if (pos_less(itr-&gt;intersect_pos, start.pos)) {</a>
<a name="ln1582">        continue;</a>
<a name="ln1583">      }</a>
<a name="ln1584">      *pair = pair_from(start, k);</a>
<a name="ln1585">      return true;  // end of a range which began before us!</a>
<a name="ln1586">    }</a>
<a name="ln1587">  }</a>
<a name="ln1588"> </a>
<a name="ln1589">  // when returning false, get back to the queried position, to ensure the caller</a>
<a name="ln1590">  // can keep using it as an ordinary iterator at the queried position. The docstring</a>
<a name="ln1591">  // for marktree_itr_get_overlap explains how this is useful.</a>
<a name="ln1592">  itr-&gt;i = itr-&gt;s[itr-&gt;lvl].i;</a>
<a name="ln1593">  assert(itr-&gt;i &gt;= 0);</a>
<a name="ln1594">  if (itr-&gt;i &gt;= itr-&gt;x-&gt;n) {</a>
<a name="ln1595">    marktree_itr_next(b, itr);</a>
<a name="ln1596">  }</a>
<a name="ln1597"> </a>
<a name="ln1598">  // either on or after the intersected position, bail out</a>
<a name="ln1599">  return false;</a>
<a name="ln1600">}</a>
<a name="ln1601"> </a>
<a name="ln1602">static void swap_keys(MarkTree *b, MarkTreeIter *itr1, MarkTreeIter *itr2, DamageList *damage)</a>
<a name="ln1603">{</a>
<a name="ln1604">  if (itr1-&gt;x != itr2-&gt;x) {</a>
<a name="ln1605">    if (mt_paired(rawkey(itr1))) {</a>
<a name="ln1606">      kvi_push(*damage, ((Damage){ mt_lookup_key(rawkey(itr1)), itr1-&gt;x, itr2-&gt;x,</a>
<a name="ln1607">                                   itr1-&gt;i, itr2-&gt;i }));</a>
<a name="ln1608">    }</a>
<a name="ln1609">    if (mt_paired(rawkey(itr2))) {</a>
<a name="ln1610">      kvi_push(*damage, ((Damage){ mt_lookup_key(rawkey(itr2)), itr2-&gt;x, itr1-&gt;x,</a>
<a name="ln1611">                                   itr2-&gt;i, itr1-&gt;i }));</a>
<a name="ln1612">    }</a>
<a name="ln1613">  }</a>
<a name="ln1614"> </a>
<a name="ln1615">  MTKey key1 = rawkey(itr1);</a>
<a name="ln1616">  MTKey key2 = rawkey(itr2);</a>
<a name="ln1617">  rawkey(itr1) = key2;</a>
<a name="ln1618">  rawkey(itr1).pos = key1.pos;</a>
<a name="ln1619">  rawkey(itr2) = key1;</a>
<a name="ln1620">  rawkey(itr2).pos = key2.pos;</a>
<a name="ln1621">  refkey(b, itr1-&gt;x, itr1-&gt;i);</a>
<a name="ln1622">  refkey(b, itr2-&gt;x, itr2-&gt;i);</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">static int damage_cmp(const void *s1, const void *s2)</a>
<a name="ln1626">{</a>
<a name="ln1627">  Damage *d1 = (Damage *)s1, *d2 = (Damage *)s2;</a>
<a name="ln1628">  assert(d1-&gt;id != d2-&gt;id);</a>
<a name="ln1629">  return d1-&gt;id &gt; d2-&gt;id;</a>
<a name="ln1630">}</a>
<a name="ln1631"> </a>
<a name="ln1632">bool marktree_splice(MarkTree *b, int32_t start_line, int start_col, int old_extent_line,</a>
<a name="ln1633">                     int old_extent_col, int new_extent_line, int new_extent_col)</a>
<a name="ln1634">{</a>
<a name="ln1635">  MTPos start = { start_line, start_col };</a>
<a name="ln1636">  MTPos old_extent = { old_extent_line, old_extent_col };</a>
<a name="ln1637">  MTPos new_extent = { new_extent_line, new_extent_col };</a>
<a name="ln1638"> </a>
<a name="ln1639">  bool may_delete = (old_extent.row != 0 || old_extent.col != 0);</a>
<a name="ln1640">  bool same_line = old_extent.row == 0 &amp;&amp; new_extent.row == 0;</a>
<a name="ln1641">  unrelative(start, &amp;old_extent);</a>
<a name="ln1642">  unrelative(start, &amp;new_extent);</a>
<a name="ln1643">  MarkTreeIter itr[1] = { 0 }, enditr[1] = { 0 };</a>
<a name="ln1644"> </a>
<a name="ln1645">  MTPos oldbase[MT_MAX_DEPTH] = { 0 };</a>
<a name="ln1646"> </a>
<a name="ln1647">  marktree_itr_get_ext(b, start, itr, false, true, oldbase);</a>
<a name="ln1648">  if (!itr-&gt;x) {</a>
<a name="ln1649">    // den e FÄRDIG</a>
<a name="ln1650">    return false;</a>
<a name="ln1651">  }</a>
<a name="ln1652">  MTPos delta = { new_extent.row - old_extent.row,</a>
<a name="ln1653">                  new_extent.col - old_extent.col };</a>
<a name="ln1654"> </a>
<a name="ln1655">  if (may_delete) {</a>
<a name="ln1656">    MTPos ipos = marktree_itr_pos(itr);</a>
<a name="ln1657">    if (!pos_leq(old_extent, ipos)</a>
<a name="ln1658">        || (old_extent.row == ipos.row &amp;&amp; old_extent.col == ipos.col</a>
<a name="ln1659">            &amp;&amp; !mt_right(rawkey(itr)))) {</a>
<a name="ln1660">      marktree_itr_get_ext(b, old_extent, enditr, true, true, NULL);</a>
<a name="ln1661">      assert(enditr-&gt;x);</a>
<a name="ln1662">      // &quot;assert&quot; (itr &lt;= enditr)</a>
<a name="ln1663">    } else {</a>
<a name="ln1664">      may_delete = false;</a>
<a name="ln1665">    }</a>
<a name="ln1666">  }</a>
<a name="ln1667"> </a>
<a name="ln1668">  bool past_right = false;</a>
<a name="ln1669">  bool moved = false;</a>
<a name="ln1670">  DamageList damage;</a>
<a name="ln1671">  kvi_init(damage);</a>
<a name="ln1672"> </a>
<a name="ln1673">  // Follow the general strategy of messing things up and fix them later</a>
<a name="ln1674">  // &quot;oldbase&quot; carries the information needed to calculate old position of</a>
<a name="ln1675">  // children.</a>
<a name="ln1676">  if (may_delete) {</a>
<a name="ln1677">    while (itr-&gt;x &amp;&amp; !past_right) {</a>
<a name="ln1678">      MTPos loc_start = start;</a>
<a name="ln1679">      MTPos loc_old = old_extent;</a>
<a name="ln1680">      relative(itr-&gt;pos, &amp;loc_start);</a>
<a name="ln1681"> </a>
<a name="ln1682">      relative(oldbase[itr-&gt;lvl], &amp;loc_old);</a>
<a name="ln1683"> </a>
<a name="ln1684">continue_same_node:</a>
<a name="ln1685">      // NB: strictly should be less than the right gravity of loc_old, but</a>
<a name="ln1686">      // the iter comparison below will already break on that.</a>
<a name="ln1687">      if (!pos_leq(rawkey(itr).pos, loc_old)) {</a>
<a name="ln1688">        break;</a>
<a name="ln1689">      }</a>
<a name="ln1690"> </a>
<a name="ln1691">      if (mt_right(rawkey(itr))) {</a>
<a name="ln1692">        while (!itr_eq(itr, enditr)</a>
<a name="ln1693">               &amp;&amp; mt_right(rawkey(enditr))) {</a>
<a name="ln1694">          marktree_itr_prev(b, enditr);</a>
<a name="ln1695">        }</a>
<a name="ln1696">        if (!mt_right(rawkey(enditr))) {</a>
<a name="ln1697">          swap_keys(b, itr, enditr, &amp;damage);</a>
<a name="ln1698">        } else {</a>
<a name="ln1699">          past_right = true;  // NOLINT</a>
<a name="ln1700">          (void)past_right;</a>
<a name="ln1701">          break;</a>
<a name="ln1702">        }</a>
<a name="ln1703">      }</a>
<a name="ln1704"> </a>
<a name="ln1705">      if (itr_eq(itr, enditr)) {</a>
<a name="ln1706">        // actually, will be past_right after this key</a>
<a name="ln1707">        past_right = true;</a>
<a name="ln1708">      }</a>
<a name="ln1709"> </a>
<a name="ln1710">      moved = true;</a>
<a name="ln1711">      if (itr-&gt;x-&gt;level) {</a>
<a name="ln1712">        oldbase[itr-&gt;lvl + 1] = rawkey(itr).pos;</a>
<a name="ln1713">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln1714">        rawkey(itr).pos = loc_start;</a>
<a name="ln1715">        marktree_itr_next_skip(b, itr, false, false, oldbase);</a>
<a name="ln1716">      } else {</a>
<a name="ln1717">        rawkey(itr).pos = loc_start;</a>
<a name="ln1718">        if (itr-&gt;i &lt; itr-&gt;x-&gt;n - 1) {</a>
<a name="ln1719">          itr-&gt;i++;</a>
<a name="ln1720">          if (!past_right) {</a>
<a name="ln1721">            goto continue_same_node;</a>
<a name="ln1722">          }</a>
<a name="ln1723">        } else {</a>
<a name="ln1724">          marktree_itr_next(b, itr);</a>
<a name="ln1725">        }</a>
<a name="ln1726">      }</a>
<a name="ln1727">    }</a>
<a name="ln1728">    while (itr-&gt;x) {</a>
<a name="ln1729">      MTPos loc_new = new_extent;</a>
<a name="ln1730">      relative(itr-&gt;pos, &amp;loc_new);</a>
<a name="ln1731">      MTPos limit = old_extent;</a>
<a name="ln1732"> </a>
<a name="ln1733">      relative(oldbase[itr-&gt;lvl], &amp;limit);</a>
<a name="ln1734"> </a>
<a name="ln1735">past_continue_same_node:</a>
<a name="ln1736"> </a>
<a name="ln1737">      if (pos_leq(limit, rawkey(itr).pos)) {</a>
<a name="ln1738">        break;</a>
<a name="ln1739">      }</a>
<a name="ln1740"> </a>
<a name="ln1741">      MTPos oldpos = rawkey(itr).pos;</a>
<a name="ln1742">      rawkey(itr).pos = loc_new;</a>
<a name="ln1743">      moved = true;</a>
<a name="ln1744">      if (itr-&gt;x-&gt;level) {</a>
<a name="ln1745">        oldbase[itr-&gt;lvl + 1] = oldpos;</a>
<a name="ln1746">        unrelative(oldbase[itr-&gt;lvl], &amp;oldbase[itr-&gt;lvl + 1]);</a>
<a name="ln1747"> </a>
<a name="ln1748">        marktree_itr_next_skip(b, itr, false, false, oldbase);</a>
<a name="ln1749">      } else {</a>
<a name="ln1750">        if (itr-&gt;i &lt; itr-&gt;x-&gt;n - 1) {</a>
<a name="ln1751">          itr-&gt;i++;</a>
<a name="ln1752">          goto past_continue_same_node;</a>
<a name="ln1753">        } else {</a>
<a name="ln1754">          marktree_itr_next(b, itr);</a>
<a name="ln1755">        }</a>
<a name="ln1756">      }</a>
<a name="ln1757">    }</a>
<a name="ln1758">  }</a>
<a name="ln1759"> </a>
<a name="ln1760">  while (itr-&gt;x) {</a>
<a name="ln1761">    unrelative(oldbase[itr-&gt;lvl], &amp;rawkey(itr).pos);</a>
<a name="ln1762">    int realrow = rawkey(itr).pos.row;</a>
<a name="ln1763">    assert(realrow &gt;= old_extent.row);</a>
<a name="ln1764">    bool done = false;</a>
<a name="ln1765">    if (realrow == old_extent.row) {</a>
<a name="ln1766">      if (delta.col) {</a>
<a name="ln1767">        rawkey(itr).pos.col += delta.col;</a>
<a name="ln1768">      }</a>
<a name="ln1769">    } else {</a>
<a name="ln1770">      if (same_line) {</a>
<a name="ln1771">        // optimization: column only adjustment can skip remaining rows</a>
<a name="ln1772">        done = true;</a>
<a name="ln1773">      }</a>
<a name="ln1774">    }</a>
<a name="ln1775">    if (delta.row) {</a>
<a name="ln1776">      rawkey(itr).pos.row += delta.row;</a>
<a name="ln1777">      moved = true;</a>
<a name="ln1778">    }</a>
<a name="ln1779">    relative(itr-&gt;pos, &amp;rawkey(itr).pos);</a>
<a name="ln1780">    if (done) {</a>
<a name="ln1781">      break;</a>
<a name="ln1782">    }</a>
<a name="ln1783">    marktree_itr_next_skip(b, itr, true, false, NULL);</a>
<a name="ln1784">  }</a>
<a name="ln1785"> </a>
<a name="ln1786">  if (kv_size(damage)) {</a>
<a name="ln1787">    // TODO(bfredl): a full sort is not really needed. we just need a &quot;start&quot; node to find</a>
<a name="ln1788">    // its corresponding &quot;end&quot; node. Set up some dedicated hash for this later (c.f. the</a>
<a name="ln1789">    // &quot;grow only&quot; variant of khash_t branch)</a>
<a name="ln1790">    qsort((void *)&amp;kv_A(damage, 0), kv_size(damage), sizeof(kv_A(damage, 0)),</a>
<a name="ln1791">          damage_cmp);</a>
<a name="ln1792"> </a>
<a name="ln1793">    for (size_t i = 0; i &lt; kv_size(damage); i++) {</a>
<a name="ln1794">      Damage d = kv_A(damage, i);</a>
<a name="ln1795">      if (!(d.id &amp; MARKTREE_END_FLAG)) {  // start</a>
<a name="ln1796">        if (i + 1 &lt; kv_size(damage) &amp;&amp; kv_A(damage, i + 1).id == (d.id | MARKTREE_END_FLAG)) {</a>
<a name="ln1797">          Damage d2 = kv_A(damage, i + 1);</a>
<a name="ln1798"> </a>
<a name="ln1799">          // pair</a>
<a name="ln1800">          marktree_itr_set_node(b, itr, d.old, d.old_i);</a>
<a name="ln1801">          marktree_itr_set_node(b, enditr, d2.old, d2.old_i);</a>
<a name="ln1802">          marktree_intersect_pair(b, d.id, itr, enditr, true);</a>
<a name="ln1803">          marktree_itr_set_node(b, itr, d.new, d.new_i);</a>
<a name="ln1804">          marktree_itr_set_node(b, enditr, d2.new, d2.new_i);</a>
<a name="ln1805">          marktree_intersect_pair(b, d.id, itr, enditr, false);</a>
<a name="ln1806"> </a>
<a name="ln1807">          i++;  // consume two items</a>
<a name="ln1808">          continue;</a>
<a name="ln1809">        }</a>
<a name="ln1810"> </a>
<a name="ln1811">        // d is lone start, end didn't move</a>
<a name="ln1812">        MarkTreeIter endpos[1];</a>
<a name="ln1813">        marktree_lookup(b, d.id | MARKTREE_END_FLAG, endpos);</a>
<a name="ln1814">        if (endpos-&gt;x) {</a>
<a name="ln1815">          marktree_itr_set_node(b, itr, d.old, d.old_i);</a>
<a name="ln1816">          *enditr = *endpos;</a>
<a name="ln1817">          marktree_intersect_pair(b, d.id, itr, enditr, true);</a>
<a name="ln1818">          marktree_itr_set_node(b, itr, d.new, d.new_i);</a>
<a name="ln1819">          *enditr = *endpos;</a>
<a name="ln1820">          marktree_intersect_pair(b, d.id, itr, enditr, false);</a>
<a name="ln1821">        }</a>
<a name="ln1822">      } else {</a>
<a name="ln1823">        // d is lone end, start didn't move</a>
<a name="ln1824">        MarkTreeIter startpos[1];</a>
<a name="ln1825">        uint64_t start_id = d.id &amp; ~MARKTREE_END_FLAG;</a>
<a name="ln1826"> </a>
<a name="ln1827">        marktree_lookup(b, start_id, startpos);</a>
<a name="ln1828">        if (startpos-&gt;x) {</a>
<a name="ln1829">          *itr = *startpos;</a>
<a name="ln1830">          marktree_itr_set_node(b, enditr, d.old, d.old_i);</a>
<a name="ln1831">          marktree_intersect_pair(b, start_id, itr, enditr, true);</a>
<a name="ln1832">          *itr = *startpos;</a>
<a name="ln1833">          marktree_itr_set_node(b, enditr, d.new, d.new_i);</a>
<a name="ln1834">          marktree_intersect_pair(b, start_id, itr, enditr, false);</a>
<a name="ln1835">        }</a>
<a name="ln1836">      }</a>
<a name="ln1837">    }</a>
<a name="ln1838">  }</a>
<a name="ln1839">  kvi_destroy(damage);</a>
<a name="ln1840"> </a>
<a name="ln1841">  return moved;</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">void marktree_move_region(MarkTree *b, int start_row, colnr_T start_col, int extent_row,</a>
<a name="ln1845">                          colnr_T extent_col, int new_row, colnr_T new_col)</a>
<a name="ln1846">{</a>
<a name="ln1847">  MTPos start = { start_row, start_col }, size = { extent_row, extent_col };</a>
<a name="ln1848">  MTPos end = size;</a>
<a name="ln1849">  unrelative(start, &amp;end);</a>
<a name="ln1850">  MarkTreeIter itr[1] = { 0 };</a>
<a name="ln1851">  marktree_itr_get_ext(b, start, itr, false, true, NULL);</a>
<a name="ln1852">  kvec_t(MTKey) saved = KV_INITIAL_VALUE;</a>
<a name="ln1853">  while (itr-&gt;x) {</a>
<a name="ln1854">    MTKey k = marktree_itr_current(itr);</a>
<a name="ln1855">    if (!pos_leq(k.pos, end) || (k.pos.row == end.row &amp;&amp; k.pos.col == end.col</a>
<a name="ln1856">                                 &amp;&amp; mt_right(k))) {</a>
<a name="ln1857">      break;</a>
<a name="ln1858">    }</a>
<a name="ln1859">    relative(start, &amp;k.pos);</a>
<a name="ln1860">    kv_push(saved, k);</a>
<a name="ln1861">    marktree_del_itr(b, itr, false);</a>
<a name="ln1862">  }</a>
<a name="ln1863"> </a>
<a name="ln1864">  marktree_splice(b, start.row, start.col, size.row, size.col, 0, 0);</a>
<a name="ln1865">  MTPos new = { new_row, new_col };</a>
<a name="ln1866">  marktree_splice(b, new.row, new.col,</a>
<a name="ln1867">                  0, 0, size.row, size.col);</a>
<a name="ln1868"> </a>
<a name="ln1869">  for (size_t i = 0; i &lt; kv_size(saved); i++) {</a>
<a name="ln1870">    MTKey item = kv_A(saved, i);</a>
<a name="ln1871">    unrelative(new, &amp;item.pos);</a>
<a name="ln1872">    marktree_put_key(b, item);</a>
<a name="ln1873">    if (mt_paired(item)) {</a>
<a name="ln1874">      // other end might be later in `saved`, this will safely bail out then</a>
<a name="ln1875">      marktree_restore_pair(b, item);</a>
<a name="ln1876">    }</a>
<a name="ln1877">  }</a>
<a name="ln1878">  kv_destroy(saved);</a>
<a name="ln1879">}</a>
<a name="ln1880"> </a>
<a name="ln1881">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1882">MTKey marktree_lookup_ns(MarkTree *b, uint32_t ns, uint32_t id, bool end, MarkTreeIter *itr)</a>
<a name="ln1883">{</a>
<a name="ln1884">  return marktree_lookup(b, mt_lookup_id(ns, id, end), itr);</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">static uint64_t pseudo_index(MTNode *x, int i)</a>
<a name="ln1888">{</a>
<a name="ln1889">  int off = MT_LOG2_BRANCH * x-&gt;level;</a>
<a name="ln1890">  uint64_t index = 0;</a>
<a name="ln1891"> </a>
<a name="ln1892">  while (x) {</a>
<a name="ln1893">    index |= (uint64_t)(i + 1) &lt;&lt; off;</a>
<a name="ln1894">    off += MT_LOG2_BRANCH;</a>
<a name="ln1895">    i = x-&gt;p_idx;</a>
<a name="ln1896">    x = x-&gt;parent;</a>
<a name="ln1897">  }</a>
<a name="ln1898"> </a>
<a name="ln1899">  return index;</a>
<a name="ln1900">}</a>
<a name="ln1901"> </a>
<a name="ln1902">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1903">/// if sloppy, two keys at the same _leaf_ node has the same index</a>
<a name="ln1904">static uint64_t pseudo_index_for_id(MarkTree *b, uint64_t id, bool sloppy)</a>
<a name="ln1905">{</a>
<a name="ln1906">  MTNode *n = id2node(b, id);</a>
<a name="ln1907">  if (n == NULL) {</a>
<a name="ln1908">    return 0;  // a valid pseudo-index is never zero!</a>
<a name="ln1909">  }</a>
<a name="ln1910"> </a>
<a name="ln1911">  int i = 0;</a>
<a name="ln1912">  if (n-&gt;level || !sloppy) {</a>
<a name="ln1913">    for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1914">      if (mt_lookup_key(n-&gt;key[i]) == id) {</a>
<a name="ln1915">        break;</a>
<a name="ln1916">      }</a>
<a name="ln1917">    }</a>
<a name="ln1918">    assert(i &lt; n-&gt;n);</a>
<a name="ln1919">    if (n-&gt;level) {</a>
<a name="ln1920">      i += 1;  // internal key i comes after ptr[i]</a>
<a name="ln1921">    }</a>
<a name="ln1922">  }</a>
<a name="ln1923"> </a>
<a name="ln1924">  return pseudo_index(n, i);</a>
<a name="ln1925">}</a>
<a name="ln1926"> </a>
<a name="ln1927">/// @param itr OPTIONAL. set itr to pos.</a>
<a name="ln1928">MTKey marktree_lookup(MarkTree *b, uint64_t id, MarkTreeIter *itr)</a>
<a name="ln1929">{</a>
<a name="ln1930">  MTNode *n = id2node(b, id);</a>
<a name="ln1931">  if (n == NULL) {</a>
<a name="ln1932">    if (itr) {</a>
<a name="ln1933">      itr-&gt;x = NULL;</a>
<a name="ln1934">    }</a>
<a name="ln1935">    return MT_INVALID_KEY;</a>
<a name="ln1936">  }</a>
<a name="ln1937">  int i = 0;</a>
<a name="ln1938">  for (i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln1939">    if (mt_lookup_key(n-&gt;key[i]) == id) {</a>
<a name="ln1940">      return marktree_itr_set_node(b, itr, n, i);</a>
<a name="ln1941">    }</a>
<a name="ln1942">  }</a>
<a name="ln1943"> </a>
<a name="ln1944">  abort();</a>
<a name="ln1945">}</a>
<a name="ln1946"> </a>
<a name="ln1947">MTKey marktree_itr_set_node(MarkTree *b, MarkTreeIter *itr, MTNode *n, int i)</a>
<a name="ln1948">{</a>
<a name="ln1949">  MTKey key = n-&gt;key[i];</a>
<a name="ln1950">  if (itr) {</a>
<a name="ln1951">    itr-&gt;i = i;</a>
<a name="ln1952">    itr-&gt;x = n;</a>
<a name="ln1953">    itr-&gt;lvl = b-&gt;root-&gt;level - n-&gt;level;</a>
<a name="ln1954">  }</a>
<a name="ln1955">  while (n-&gt;parent != NULL) {</a>
<a name="ln1956">    MTNode *p = n-&gt;parent;</a>
<a name="ln1957">    i = n-&gt;p_idx;</a>
<a name="ln1958">    assert(p-&gt;ptr[i] == n);</a>
<a name="ln1959"> </a>
<a name="ln1960">    if (itr) {</a>
<a name="ln1961">      itr-&gt;s[b-&gt;root-&gt;level - p-&gt;level].i = i;</a>
<a name="ln1962">    }</a>
<a name="ln1963">    if (i &gt; 0) {</a>
<a name="ln1964">      unrelative(p-&gt;key[i - 1].pos, &amp;key.pos);</a>
<a name="ln1965">    }</a>
<a name="ln1966">    n = p;</a>
<a name="ln1967">  }</a>
<a name="ln1968">  if (itr) {</a>
<a name="ln1969">    marktree_itr_fix_pos(b, itr);</a>
<a name="ln1970">  }</a>
<a name="ln1971">  return key;</a>
<a name="ln1972">}</a>
<a name="ln1973"> </a>
<a name="ln1974">MTPos marktree_get_altpos(MarkTree *b, MTKey mark, MarkTreeIter *itr)</a>
<a name="ln1975">{</a>
<a name="ln1976">  return marktree_get_alt(b, mark, itr).pos;</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979">MTKey marktree_get_alt(MarkTree *b, MTKey mark, MarkTreeIter *itr)</a>
<a name="ln1980">{</a>
<a name="ln1981">  MTKey end = MT_INVALID_KEY;</a>
<a name="ln1982">  if (mt_paired(mark)) {</a>
<a name="ln1983">    end = marktree_lookup_ns(b, mark.ns, mark.id, !mt_end(mark), itr);</a>
<a name="ln1984">  }</a>
<a name="ln1985">  return end;</a>
<a name="ln1986">}</a>
<a name="ln1987"> </a>
<a name="ln1988">static void marktree_itr_fix_pos(MarkTree *b, MarkTreeIter *itr)</a>
<a name="ln1989">{</a>
<a name="ln1990">  itr-&gt;pos = (MTPos){ 0, 0 };</a>
<a name="ln1991">  MTNode *x = b-&gt;root;</a>
<a name="ln1992">  for (int lvl = 0; lvl &lt; itr-&gt;lvl; lvl++) {</a>
<a name="ln1993">    itr-&gt;s[lvl].oldcol = itr-&gt;pos.col;</a>
<a name="ln1994">    int i = itr-&gt;s[lvl].i;</a>
<a name="ln1995">    if (i &gt; 0) {</a>
<a name="ln1996">      compose(&amp;itr-&gt;pos, x-&gt;key[i - 1].pos);</a>
<a name="ln1997">    }</a>
<a name="ln1998">    assert(x-&gt;level);</a>
<a name="ln1999">    x = x-&gt;ptr[i];</a>
<a name="ln2000">  }</a>
<a name="ln2001">  assert(x == itr-&gt;x);</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004">// for unit test</a>
<a name="ln2005">void marktree_put_test(MarkTree *b, uint32_t ns, uint32_t id, int row, int col, bool right_gravity,</a>
<a name="ln2006">                       int end_row, int end_col, bool end_right)</a>
<a name="ln2007">{</a>
<a name="ln2008">  MTKey key = { { row, col }, ns, id, 0,</a>
<a name="ln2009">                mt_flags(right_gravity, 0), 0, NULL };</a>
<a name="ln2010">  marktree_put(b, key, end_row, end_col, end_right);</a>
<a name="ln2011">}</a>
<a name="ln2012"> </a>
<a name="ln2013">// for unit test</a>
<a name="ln2014">bool mt_right_test(MTKey key)</a>
<a name="ln2015">{</a>
<a name="ln2016">  return mt_right(key);</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">// for unit test</a>
<a name="ln2020">void marktree_del_pair_test(MarkTree *b, uint32_t ns, uint32_t id)</a>
<a name="ln2021">{</a>
<a name="ln2022">  MarkTreeIter itr[1];</a>
<a name="ln2023">  marktree_lookup_ns(b, ns, id, false, itr);</a>
<a name="ln2024"> </a>
<a name="ln2025">  uint64_t other = marktree_del_itr(b, itr, false);</a>
<a name="ln2026">  assert(other);</a>
<a name="ln2027">  marktree_lookup(b, other, itr);</a>
<a name="ln2028">  marktree_del_itr(b, itr, false);</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">void marktree_check(MarkTree *b)</a>
<a name="ln2032">{</a>
<a name="ln2033">#ifndef NDEBUG</a>
<a name="ln2034">  if (b-&gt;root == NULL) {</a>
<a name="ln2035">    assert(b-&gt;n_keys == 0);</a>
<a name="ln2036">    assert(b-&gt;n_nodes == 0);</a>
<a name="ln2037">    assert(b-&gt;id2node == NULL || map_size(b-&gt;id2node) == 0);</a>
<a name="ln2038">    return;</a>
<a name="ln2039">  }</a>
<a name="ln2040"> </a>
<a name="ln2041">  MTPos dummy;</a>
<a name="ln2042">  bool last_right = false;</a>
<a name="ln2043">  size_t nkeys = marktree_check_node(b, b-&gt;root, &amp;dummy, &amp;last_right);</a>
<a name="ln2044">  assert(b-&gt;n_keys == nkeys);</a>
<a name="ln2045">  assert(b-&gt;n_keys == map_size(b-&gt;id2node));</a>
<a name="ln2046">#else</a>
<a name="ln2047">  // Do nothing, as assertions are required</a>
<a name="ln2048">  (void)b;</a>
<a name="ln2049">#endif</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052">#ifndef NDEBUG</a>
<a name="ln2053">size_t marktree_check_node(MarkTree *b, MTNode *x, MTPos *last, bool *last_right)</a>
<a name="ln2054">{</a>
<a name="ln2055">  assert(x-&gt;n &lt;= 2 * T - 1);</a>
<a name="ln2056">  // TODO(bfredl): too strict if checking &quot;in repair&quot; post-delete tree.</a>
<a name="ln2057">  assert(x-&gt;n &gt;= (x != b-&gt;root ? T - 1 : 0));</a>
<a name="ln2058">  size_t n_keys = (size_t)x-&gt;n;</a>
<a name="ln2059"> </a>
<a name="ln2060">  for (int i = 0; i &lt; x-&gt;n; i++) {</a>
<a name="ln2061">    if (x-&gt;level) {</a>
<a name="ln2062">      n_keys += marktree_check_node(b, x-&gt;ptr[i], last, last_right);</a>
<a name="ln2063">    } else {</a>
<a name="ln2064">      *last = (MTPos) { 0, 0 };</a>
<a name="ln2065">    }</a>
<a name="ln2066">    if (i &gt; 0) {</a>
<a name="ln2067">      unrelative(x-&gt;key[i - 1].pos, last);</a>
<a name="ln2068">    }</a>
<a name="ln2069">    assert(pos_leq(*last, x-&gt;key[i].pos));</a>
<a name="ln2070">    if (last-&gt;row == x-&gt;key[i].pos.row &amp;&amp; last-&gt;col == x-&gt;key[i].pos.col) {</a>
<a name="ln2071">      assert(!*last_right || mt_right(x-&gt;key[i]));</a>
<a name="ln2072">    }</a>
<a name="ln2073">    *last_right = mt_right(x-&gt;key[i]);</a>
<a name="ln2074">    assert(x-&gt;key[i].pos.col &gt;= 0);</a>
<a name="ln2075">    assert(pmap_get(uint64_t)(b-&gt;id2node, mt_lookup_key(x-&gt;key[i])) == x);</a>
<a name="ln2076">  }</a>
<a name="ln2077"> </a>
<a name="ln2078">  if (x-&gt;level) {</a>
<a name="ln2079">    n_keys += marktree_check_node(b, x-&gt;ptr[x-&gt;n], last, last_right);</a>
<a name="ln2080">    unrelative(x-&gt;key[x-&gt;n - 1].pos, last);</a>
<a name="ln2081"> </a>
<a name="ln2082">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln2083">      assert(x-&gt;ptr[i]-&gt;parent == x);</a>
<a name="ln2084">      assert(x-&gt;ptr[i]-&gt;p_idx == i);</a>
<a name="ln2085">      assert(x-&gt;ptr[i]-&gt;level == x-&gt;level - 1);</a>
<a name="ln2086">      // PARANOIA: check no double node ref</a>
<a name="ln2087">      for (int j = 0; j &lt; i; j++) {</a>
<a name="ln2088">        assert(x-&gt;ptr[i] != x-&gt;ptr[j]);</a>
<a name="ln2089">      }</a>
<a name="ln2090">    }</a>
<a name="ln2091">  } else if (x-&gt;n &gt; 0) {</a>
<a name="ln2092">    *last = x-&gt;key[x-&gt;n - 1].pos;</a>
<a name="ln2093">  }</a>
<a name="ln2094">  return n_keys;</a>
<a name="ln2095">}</a>
<a name="ln2096"> </a>
<a name="ln2097">bool marktree_check_intersections(MarkTree *b)</a>
<a name="ln2098">{</a>
<a name="ln2099">  if (!b-&gt;root) {</a>
<a name="ln2100">    return true;</a>
<a name="ln2101">  }</a>
<a name="ln2102">  PMap(ptr_t) checked = MAP_INIT;</a>
<a name="ln2103"> </a>
<a name="ln2104">  // 1. move x-&gt;intersect to checked[x] and reinit x-&gt;intersect</a>
<a name="ln2105">  mt_recurse_nodes(b-&gt;root, &amp;checked);</a>
<a name="ln2106"> </a>
<a name="ln2107">  // 2. iterate over all marks. for each START mark of a pair,</a>
<a name="ln2108">  // intersect the nodes between the pair</a>
<a name="ln2109">  MarkTreeIter itr[1];</a>
<a name="ln2110">  marktree_itr_first(b, itr);</a>
<a name="ln2111">  while (true) {</a>
<a name="ln2112">    MTKey mark = marktree_itr_current(itr);</a>
<a name="ln2113">    if (mark.pos.row &lt; 0) {</a>
<a name="ln2114">      break;</a>
<a name="ln2115">    }</a>
<a name="ln2116"> </a>
<a name="ln2117">    if (mt_start(mark)) {</a>
<a name="ln2118">      MarkTreeIter start_itr[1];</a>
<a name="ln2119">      MarkTreeIter end_itr[1];</a>
<a name="ln2120">      uint64_t end_id = mt_lookup_id(mark.ns, mark.id, true);</a>
<a name="ln2121">      MTKey k = marktree_lookup(b, end_id, end_itr);</a>
<a name="ln2122">      if (k.pos.row &gt;= 0) {</a>
<a name="ln2123">        *start_itr = *itr;</a>
<a name="ln2124">        marktree_intersect_pair(b, mt_lookup_key(mark), start_itr, end_itr, false);</a>
<a name="ln2125">      }</a>
<a name="ln2126">    }</a>
<a name="ln2127"> </a>
<a name="ln2128">    marktree_itr_next(b, itr);</a>
<a name="ln2129">  }</a>
<a name="ln2130"> </a>
<a name="ln2131">  // 3. for each node check if the recreated intersection</a>
<a name="ln2132">  // matches the old checked[x] intersection.</a>
<a name="ln2133">  bool status = mt_recurse_nodes_compare(b-&gt;root, &amp;checked);</a>
<a name="ln2134"> </a>
<a name="ln2135">  uint64_t *val;</a>
<a name="ln2136">  map_foreach_value(&amp;checked, val, {</a>
<a name="ln2137">    xfree(val);</a>
<a name="ln2138">  });</a>
<a name="ln2139">  map_destroy(ptr_t, &amp;checked);</a>
<a name="ln2140"> </a>
<a name="ln2141">  return status;</a>
<a name="ln2142">}</a>
<a name="ln2143"> </a>
<a name="ln2144">void mt_recurse_nodes(MTNode *x, PMap(ptr_t) *checked)</a>
<a name="ln2145">{</a>
<a name="ln2146">  if (kv_size(x-&gt;intersect)) {</a>
<a name="ln2147">    kvi_push(x-&gt;intersect, (uint64_t)-1);  // sentinel</a>
<a name="ln2148">    uint64_t *val;</a>
<a name="ln2149">    if (x-&gt;intersect.items == x-&gt;intersect.init_array) {</a>
<a name="ln2150">      val = xmemdup(x-&gt;intersect.items, x-&gt;intersect.size * sizeof(*x-&gt;intersect.items));</a>
<a name="ln2151">    } else {</a>
<a name="ln2152">      val = x-&gt;intersect.items;</a>
<a name="ln2153">    }</a>
<a name="ln2154">    pmap_put(ptr_t)(checked, x, val);</a>
<a name="ln2155">    kvi_init(x-&gt;intersect);</a>
<a name="ln2156">  }</a>
<a name="ln2157"> </a>
<a name="ln2158">  if (x-&gt;level) {</a>
<a name="ln2159">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln2160">      mt_recurse_nodes(x-&gt;ptr[i], checked);</a>
<a name="ln2161">    }</a>
<a name="ln2162">  }</a>
<a name="ln2163">}</a>
<a name="ln2164"> </a>
<a name="ln2165">bool mt_recurse_nodes_compare(MTNode *x, PMap(ptr_t) *checked)</a>
<a name="ln2166">{</a>
<a name="ln2167">  uint64_t *ref = pmap_get(ptr_t)(checked, x);</a>
<a name="ln2168">  if (ref != NULL) {</a>
<a name="ln2169">    for (size_t i = 0;; i++) {</a>
<a name="ln2170">      if (ref[i] == (uint64_t)-1) {</a>
<a name="ln2171">        if (i != kv_size(x-&gt;intersect)) {</a>
<a name="ln2172">          return false;</a>
<a name="ln2173">        }</a>
<a name="ln2174"> </a>
<a name="ln2175">        break;</a>
<a name="ln2176">      } else {</a>
<a name="ln2177">        if (kv_size(x-&gt;intersect) &lt;= i || ref[i] != kv_A(x-&gt;intersect, i)) {</a>
<a name="ln2178">          return false;</a>
<a name="ln2179">        }</a>
<a name="ln2180">      }</a>
<a name="ln2181">    }</a>
<a name="ln2182">  } else {</a>
<a name="ln2183">    if (kv_size(x-&gt;intersect)) {</a>
<a name="ln2184">      return false;</a>
<a name="ln2185">    }</a>
<a name="ln2186">  }</a>
<a name="ln2187"> </a>
<a name="ln2188">  if (x-&gt;level) {</a>
<a name="ln2189">    for (int i = 0; i &lt; x-&gt;n + 1; i++) {</a>
<a name="ln2190">      if (!mt_recurse_nodes_compare(x-&gt;ptr[i], checked)) {</a>
<a name="ln2191">        return false;</a>
<a name="ln2192">      }</a>
<a name="ln2193">    }</a>
<a name="ln2194">  }</a>
<a name="ln2195"> </a>
<a name="ln2196">  return true;</a>
<a name="ln2197">}</a>
<a name="ln2198"> </a>
<a name="ln2199">#endif</a>
<a name="ln2200"> </a>
<a name="ln2201">// TODO(bfredl): kv_print</a>
<a name="ln2202">#define GA_PUT(x) ga_concat(ga, (char *)(x))</a>
<a name="ln2203">#define GA_PRINT(fmt, ...) snprintf(buf, sizeof(buf), fmt, __VA_ARGS__); \</a>
<a name="ln2204">  GA_PUT(buf);</a>
<a name="ln2205"> </a>
<a name="ln2206">String mt_inspect(MarkTree *b, bool keys, bool dot)</a>
<a name="ln2207">{</a>
<a name="ln2208">  garray_T ga[1];</a>
<a name="ln2209">  ga_init(ga, (int)sizeof(char), 80);</a>
<a name="ln2210">  MTPos p = { 0, 0 };</a>
<a name="ln2211">  if (b-&gt;root) {</a>
<a name="ln2212">    if (dot) {</a>
<a name="ln2213">      GA_PUT(&quot;digraph D {\n\n&quot;);</a>
<a name="ln2214">      mt_inspect_dotfile_node(b, ga, b-&gt;root, p, NULL);</a>
<a name="ln2215">      GA_PUT(&quot;\n}&quot;);</a>
<a name="ln2216">    } else {</a>
<a name="ln2217">      mt_inspect_node(b, ga, keys, b-&gt;root, p);</a>
<a name="ln2218">    }</a>
<a name="ln2219">  }</a>
<a name="ln2220">  return ga_take_string(ga);</a>
<a name="ln2221">}</a>
<a name="ln2222"> </a>
<a name="ln2223">void mt_inspect_node(MarkTree *b, garray_T *ga, bool keys, MTNode *n, MTPos off)</a>
<a name="ln2224">{</a>
<a name="ln2225">  static char buf[1024];</a>
<a name="ln2226">  GA_PUT(&quot;[&quot;);</a>
<a name="ln2227">  if (keys &amp;&amp; kv_size(n-&gt;intersect)) {</a>
<a name="ln2228">    for (size_t i = 0; i &lt; kv_size(n-&gt;intersect); i++) {</a>
<a name="ln2229">      GA_PUT(i == 0 ? &quot;{&quot; : &quot;;&quot;);</a>
<a name="ln2230">      // GA_PRINT(&quot;%&quot;PRIu64, kv_A(n-&gt;intersect, i));</a>
<a name="ln2231">      GA_PRINT(&quot;%&quot; PRIu64, mt_dbg_id(kv_A(n-&gt;intersect, i)));</a>
<a name="ln2232">    }</a>
<a name="ln2233">    GA_PUT(&quot;},&quot;);</a>
<a name="ln2234">  }</a>
<a name="ln2235">  if (n-&gt;level) {</a>
<a name="ln2236">    mt_inspect_node(b, ga, keys, n-&gt;ptr[0], off);</a>
<a name="ln2237">  }</a>
<a name="ln2238">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln2239">    MTPos p = n-&gt;key[i].pos;</a>
<a name="ln2240">    unrelative(off, &amp;p);</a>
<a name="ln2241">    GA_PRINT(&quot;%d/%d&quot;, p.row, p.col);</a>
<a name="ln2242">    if (keys) {</a>
<a name="ln2243">      MTKey key = n-&gt;key[i];</a>
<a name="ln2244">      GA_PUT(&quot;:&quot;);</a>
<a name="ln2245">      if (mt_start(key)) {</a>
<a name="ln2246">        GA_PUT(&quot;&lt;&quot;);</a>
<a name="ln2247">      }</a>
<a name="ln2248">      // GA_PRINT(&quot;%&quot;PRIu64, mt_lookup_id(key.ns, key.id, false));</a>
<a name="ln2249">      GA_PRINT(&quot;%&quot; PRIu32, key.id);</a>
<a name="ln2250">      if (mt_end(key)) {</a>
<a name="ln2251">        GA_PUT(&quot;&gt;&quot;);</a>
<a name="ln2252">      }</a>
<a name="ln2253">    }</a>
<a name="ln2254">    if (n-&gt;level) {</a>
<a name="ln2255">      mt_inspect_node(b, ga, keys, n-&gt;ptr[i + 1], p);</a>
<a name="ln2256">    } else {</a>
<a name="ln2257">      ga_concat(ga, &quot;,&quot;);</a>
<a name="ln2258">    }</a>
<a name="ln2259">  }</a>
<a name="ln2260">  ga_concat(ga, &quot;]&quot;);</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">void mt_inspect_dotfile_node(MarkTree *b, garray_T *ga, MTNode *n, MTPos off, char *parent)</a>
<a name="ln2264">{</a>
<a name="ln2265">  static char buf[1024];</a>
<a name="ln2266">  char namebuf[64];</a>
<a name="ln2267">  if (parent != NULL) {</a>
<a name="ln2268">    snprintf(namebuf, sizeof namebuf, &quot;%s_%c%d&quot;, parent, 'a' + n-&gt;level, n-&gt;p_idx);</a>
<a name="ln2269">  } else {</a>
<a name="ln2270">    snprintf(namebuf, sizeof namebuf, &quot;Node&quot;);</a>
<a name="ln2271">  }</a>
<a name="ln2272"> </a>
<a name="ln2273">  GA_PRINT(&quot;  %s[shape=plaintext, label=&lt;\n&quot;, namebuf);</a>
<a name="ln2274">  GA_PUT(&quot;    &lt;table border='0' cellborder='1' cellspacing='0'&gt;\n&quot;);</a>
<a name="ln2275">  if (kv_size(n-&gt;intersect)) {</a>
<a name="ln2276">    GA_PUT(&quot;    &lt;tr&gt;&lt;td&gt;&quot;);</a>
<a name="ln2277">    for (size_t i = 0; i &lt; kv_size(n-&gt;intersect); i++) {</a>
<a name="ln2278">      if (i &gt; 0) {</a>
<a name="ln2279">        GA_PUT(&quot;, &quot;);</a>
<a name="ln2280">      }</a>
<a name="ln2281">      GA_PRINT(&quot;%&quot; PRIu64, mt_dbg_id(kv_A(n-&gt;intersect, i)));</a>
<a name="ln2282">    }</a>
<a name="ln2283">    GA_PUT(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</a>
<a name="ln2284">  }</a>
<a name="ln2285"> </a>
<a name="ln2286">  GA_PUT(&quot;    &lt;tr&gt;&lt;td&gt;&quot;);</a>
<a name="ln2287">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln2288">    MTKey k = n-&gt;key[i];</a>
<a name="ln2289">    if (i &gt; 0) {</a>
<a name="ln2290">      GA_PUT(&quot;, &quot;);</a>
<a name="ln2291">    }</a>
<a name="ln2292">    GA_PRINT(&quot;%d&quot;, k.id);</a>
<a name="ln2293">    if (mt_paired(k)) {</a>
<a name="ln2294">      GA_PUT(mt_end(k) ? &quot;e&quot; : &quot;s&quot;);</a>
<a name="ln2295">    }</a>
<a name="ln2296">  }</a>
<a name="ln2297">  GA_PUT(&quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</a>
<a name="ln2298">  GA_PUT(&quot;    &lt;/table&gt;\n&quot;);</a>
<a name="ln2299">  GA_PUT(&quot;&gt;];\n&quot;);</a>
<a name="ln2300">  if (parent) {</a>
<a name="ln2301">    GA_PRINT(&quot;  %s -&gt; %s\n&quot;, parent, namebuf);</a>
<a name="ln2302">  }</a>
<a name="ln2303">  if (n-&gt;level) {</a>
<a name="ln2304">    mt_inspect_dotfile_node(b, ga, n-&gt;ptr[0], off, namebuf);</a>
<a name="ln2305">  }</a>
<a name="ln2306">  for (int i = 0; i &lt; n-&gt;n; i++) {</a>
<a name="ln2307">    MTPos p = n-&gt;key[i].pos;</a>
<a name="ln2308">    unrelative(off, &amp;p);</a>
<a name="ln2309">    if (n-&gt;level) {</a>
<a name="ln2310">      mt_inspect_dotfile_node(b, ga, n-&gt;ptr[i + 1], p, namebuf);</a>
<a name="ln2311">    }</a>
<a name="ln2312">  }</a>
<a name="ln2313">}</a>
</code></pre>
<div class="balloon" rel="222"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1086/" target="_blank">V1086</a> A call of the 'memcpy' function will lead to underflow of the buffer 'z-&gt;key'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>