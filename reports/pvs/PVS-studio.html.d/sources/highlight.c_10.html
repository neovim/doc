<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>highlight.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// highlight.c: low level code for UI and syntax highlighting</a>
<a name="ln5"> </a>
<a name="ln6">#include &lt;assert.h&gt;</a>
<a name="ln7">#include &lt;inttypes.h&gt;</a>
<a name="ln8">#include &lt;limits.h&gt;</a>
<a name="ln9">#include &lt;string.h&gt;</a>
<a name="ln10"> </a>
<a name="ln11">#include &quot;klib/kvec.h&quot;</a>
<a name="ln12">#include &quot;lauxlib.h&quot;</a>
<a name="ln13">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln14">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln15">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln16">#include &quot;nvim/api/private/validate.h&quot;</a>
<a name="ln17">#include &quot;nvim/api/ui.h&quot;</a>
<a name="ln18">#include &quot;nvim/decoration_provider.h&quot;</a>
<a name="ln19">#include &quot;nvim/drawscreen.h&quot;</a>
<a name="ln20">#include &quot;nvim/gettext.h&quot;</a>
<a name="ln21">#include &quot;nvim/globals.h&quot;</a>
<a name="ln22">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln23">#include &quot;nvim/highlight_defs.h&quot;</a>
<a name="ln24">#include &quot;nvim/highlight_group.h&quot;</a>
<a name="ln25">#include &quot;nvim/log.h&quot;</a>
<a name="ln26">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln27">#include &quot;nvim/macros.h&quot;</a>
<a name="ln28">#include &quot;nvim/map.h&quot;</a>
<a name="ln29">#include &quot;nvim/memory.h&quot;</a>
<a name="ln30">#include &quot;nvim/message.h&quot;</a>
<a name="ln31">#include &quot;nvim/option.h&quot;</a>
<a name="ln32">#include &quot;nvim/popupmenu.h&quot;</a>
<a name="ln33">#include &quot;nvim/types.h&quot;</a>
<a name="ln34">#include &quot;nvim/ui.h&quot;</a>
<a name="ln35">#include &quot;nvim/vim.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln38"># include &quot;highlight.c.generated.h&quot;</a>
<a name="ln39">#endif</a>
<a name="ln40"> </a>
<a name="ln41">static bool hlstate_active = false;</a>
<a name="ln42"> </a>
<a name="ln43">static kvec_t(HlEntry) attr_entries = KV_INITIAL_VALUE;</a>
<a name="ln44"> </a>
<a name="ln45">static Map(HlEntry, int) attr_entry_ids = MAP_INIT;</a>
<a name="ln46">static Map(int, int) combine_attr_entries = MAP_INIT;</a>
<a name="ln47">static Map(int, int) blend_attr_entries = MAP_INIT;</a>
<a name="ln48">static Map(int, int) blendthrough_attr_entries = MAP_INIT;</a>
<a name="ln49"> </a>
<a name="ln50">/// highlight entries private to a namespace</a>
<a name="ln51">static Map(ColorKey, ColorItem) ns_hls;</a>
<a name="ln52">typedef int NSHlAttr[HLF_COUNT + 1];</a>
<a name="ln53">static PMap(int) ns_hl_attr;</a>
<a name="ln54"> </a>
<a name="ln55">void highlight_init(void)</a>
<a name="ln56">{</a>
<a name="ln57">  // index 0 is no attribute, add dummy entry:</a>
<a name="ln58">  kv_push(attr_entries, ((HlEntry){ .attr = HLATTRS_INIT, .kind = kHlUnknown,</a>
<a name="ln59">                                    .id1 = 0, .id2 = 0 }));</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">/// @return true if hl table was reset</a>
<a name="ln63">bool highlight_use_hlstate(void)</a>
<a name="ln64">{</a>
<a name="ln65">  if (hlstate_active) {</a>
<a name="ln66">    return false;</a>
<a name="ln67">  }</a>
<a name="ln68">  hlstate_active = true;</a>
<a name="ln69">  // hl tables must now be rebuilt.</a>
<a name="ln70">  clear_hl_tables(true);</a>
<a name="ln71">  return true;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">/// Return the attr number for a set of colors and font, and optionally</a>
<a name="ln75">/// a semantic description (see ext_hlstate documentation).</a>
<a name="ln76">/// Add a new entry to the attr_entries array if the combination is new.</a>
<a name="ln77">/// @return 0 for error.</a>
<a name="ln78">static int get_attr_entry(HlEntry entry)</a>
<a name="ln79">{</a>
<a name="ln80">  if (!hlstate_active) {</a>
<a name="ln81">    // This information will not be used, erase it and reduce the table size.</a>
<a name="ln82">    entry.kind = kHlUnknown;</a>
<a name="ln83">    entry.id1 = 0;</a>
<a name="ln84">    entry.id2 = 0;</a>
<a name="ln85">  }</a>
<a name="ln86"> </a>
<a name="ln87">  int id = map_get(HlEntry, int)(&amp;attr_entry_ids, entry);</a>
<a name="ln88">  if (id &gt; 0) {</a>
<a name="ln89">    return id;</a>
<a name="ln90">  }</a>
<a name="ln91"> </a>
<a name="ln92">  static bool recursive = false;</a>
<a name="ln93">  if (kv_size(attr_entries) &gt; MAX_TYPENR) {</a>
<a name="ln94">    // Running out of attribute entries!  remove all attributes, and</a>
<a name="ln95">    // compute new ones for all groups.</a>
<a name="ln96">    // When called recursively, we are really out of numbers.</a>
<a name="ln97">    if (recursive) {</a>
<a name="ln98">      emsg(_(&quot;E424: Too many different highlighting attributes in use&quot;));</a>
<a name="ln99">      return 0;</a>
<a name="ln100">    }</a>
<a name="ln101">    recursive = true;</a>
<a name="ln102"> </a>
<a name="ln103">    clear_hl_tables(true);</a>
<a name="ln104"> </a>
<a name="ln105">    recursive = false;</a>
<a name="ln106">    if (entry.kind == kHlCombine) {</a>
<a name="ln107">      // This entry is now invalid, don't put it</a>
<a name="ln108">      return 0;</a>
<a name="ln109">    }</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  size_t next_id = kv_size(attr_entries);</a>
<a name="ln113">  if (next_id &gt; INT_MAX) {</a>
<a name="ln114">    ELOG(&quot;The index on attr_entries has overflowed&quot;);</a>
<a name="ln115">    return 0;</a>
<a name="ln116">  }</a>
<a name="ln117">  id = (int)next_id;</a>
<a name="ln118">  kv_push(attr_entries, entry);</a>
<a name="ln119"> </a>
<a name="ln120">  map_put(HlEntry, int)(&amp;attr_entry_ids, entry, id);</a>
<a name="ln121"> </a>
<a name="ln122">  Array inspect = hl_inspect(id);</a>
<a name="ln123"> </a>
<a name="ln124">  // Note: internally we don't distinguish between cterm and rgb attributes,</a>
<a name="ln125">  // remote_ui_hl_attr_define will however.</a>
<a name="ln126">  ui_call_hl_attr_define(id, entry.attr, entry.attr, inspect);</a>
<a name="ln127">  api_free_array(inspect);</a>
<a name="ln128">  return id;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">/// When a UI connects, we need to send it the table of highlights used so far.</a>
<a name="ln132">void ui_send_all_hls(UI *ui)</a>
<a name="ln133">{</a>
<a name="ln134">  for (size_t i = 1; i &lt; kv_size(attr_entries); i++) {</a>
<a name="ln135">    Array inspect = hl_inspect((int)i);</a>
<a name="ln136">    remote_ui_hl_attr_define(ui, (Integer)i, kv_A(attr_entries, i).attr,</a>
<a name="ln137">                             kv_A(attr_entries, i).attr, inspect);</a>
<a name="ln138">    api_free_array(inspect);</a>
<a name="ln139">  }</a>
<a name="ln140">  for (size_t hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln141">    remote_ui_hl_group_set(ui, cstr_as_string((char *)hlf_names[hlf]),</a>
<a name="ln142">                           highlight_attr[hlf]);</a>
<a name="ln143">  }</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">/// Get attribute code for a syntax group.</a>
<a name="ln147">int hl_get_syn_attr(int ns_id, int idx, HlAttrs at_en)</a>
<a name="ln148">{</a>
<a name="ln149">  // TODO(bfredl): should we do this unconditionally</a>
<a name="ln150">  if (at_en.cterm_fg_color != 0 || at_en.cterm_bg_color != 0</a>
<a name="ln151">      || at_en.rgb_fg_color != -1 || at_en.rgb_bg_color != -1</a>
<a name="ln152">      || at_en.rgb_sp_color != -1 || at_en.cterm_ae_attr != 0</a>
<a name="ln153">      || at_en.rgb_ae_attr != 0 || ns_id != 0) {</a>
<a name="ln154">    return get_attr_entry((HlEntry){ .attr = at_en, .kind = kHlSyntax,</a>
<a name="ln155">                                     .id1 = idx, .id2 = ns_id });</a>
<a name="ln156">  }</a>
<a name="ln157">  // If all the fields are cleared, clear the attr field back to default value</a>
<a name="ln158">  return 0;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void ns_hl_def(NS ns_id, int hl_id, HlAttrs attrs, int link_id, Dict(highlight) *dict)</a>
<a name="ln162">{</a>
<a name="ln163">  if (ns_id == 0) {</a>
<a name="ln164">    assert(dict);</a>
<a name="ln165">    // set in global (':highlight') namespace</a>
<a name="ln166">    set_hl_group(hl_id, attrs, dict, link_id);</a>
<a name="ln167">    return;</a>
<a name="ln168">  }</a>
<a name="ln169">  if ((attrs.rgb_ae_attr &amp; HL_DEFAULT)</a>
<a name="ln170">      &amp;&amp; map_has(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id))) {</a>
<a name="ln171">    return;</a>
<a name="ln172">  }</a>
<a name="ln173">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln174">  int attr_id = link_id &gt; 0 ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln175">  ColorItem it = { .attr_id = attr_id,</a>
<a name="ln176">                   .link_id = link_id,</a>
<a name="ln177">                   .version = p-&gt;hl_valid,</a>
<a name="ln178">                   .is_default = (attrs.rgb_ae_attr &amp; HL_DEFAULT),</a>
<a name="ln179">                   .link_global = (attrs.rgb_ae_attr &amp; HL_GLOBAL) };</a>
<a name="ln180">  map_put(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id), it);</a>
<a name="ln181">  p-&gt;hl_cached = false;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">int ns_get_hl(NS *ns_hl, int hl_id, bool link, bool nodefault)</a>
<a name="ln185">{</a>
<a name="ln186">  static int recursive = 0;</a>
<a name="ln187"> </a>
<a name="ln188">  if (*ns_hl == 0) {</a>
<a name="ln189">    // ns=0 (the default namespace) does not have a provider so stop here</a>
<a name="ln190">    return -1;</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193">  if (*ns_hl &lt; 0) {</a>
<a name="ln194">    if (ns_hl_active &lt;= 0) {</a>
<a name="ln195">      return -1;</a>
<a name="ln196">    }</a>
<a name="ln197">    *ns_hl = ns_hl_active;</a>
<a name="ln198">  }</a>
<a name="ln199"> </a>
<a name="ln200">  int ns_id = *ns_hl;</a>
<a name="ln201"> </a>
<a name="ln202">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln203">  ColorItem it = map_get(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id));</a>
<a name="ln204">  // TODO(bfredl): map_ref true even this?</a>
<a name="ln205">  bool valid_item = it.version &gt;= p-&gt;hl_valid;</a>
<a name="ln206"> </a>
<a name="ln207">  if (!valid_item &amp;&amp; p-&gt;hl_def != LUA_NOREF &amp;&amp; !recursive) {</a>
<a name="ln208">    MAXSIZE_TEMP_ARRAY(args, 3);</a>
<a name="ln209">    ADD_C(args, INTEGER_OBJ((Integer)ns_id));</a>
<a name="ln210">    ADD_C(args, CSTR_TO_OBJ(syn_id2name(hl_id)));</a>
<a name="ln211">    ADD_C(args, BOOLEAN_OBJ(link));</a>
<a name="ln212">    // TODO(bfredl): preload the &quot;global&quot; attr dict?</a>
<a name="ln213"> </a>
<a name="ln214">    Error err = ERROR_INIT;</a>
<a name="ln215">    recursive++;</a>
<a name="ln216">    Object ret = nlua_call_ref(p-&gt;hl_def, &quot;hl_def&quot;, args, true, &amp;err);</a>
<a name="ln217">    recursive--;</a>
<a name="ln218"> </a>
<a name="ln219">    // TODO(bfredl): or &quot;inherit&quot;, combine with global value?</a>
<a name="ln220">    bool fallback = true;</a>
<a name="ln221">    int tmp = false;</a>
<a name="ln222">    HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln223">    if (ret.type == kObjectTypeDictionary) {</a>
<a name="ln224">      fallback = false;</a>
<a name="ln225">      Dict(highlight) dict = { 0 };</a>
<a name="ln226">      if (api_dict_to_keydict(&amp;dict, KeyDict_highlight_get_field,</a>
<a name="ln227">                              ret.data.dictionary, &amp;err)) {</a>
<a name="ln228">        attrs = dict2hlattrs(&amp;dict, true, &amp;it.link_id, &amp;err);</a>
<a name="ln229">        fallback = api_object_to_bool(dict.fallback, &quot;fallback&quot;, true, &amp;err);</a>
<a name="ln230">        tmp = api_object_to_bool(dict.fallback, &quot;tmp&quot;, false, &amp;err);</a>
<a name="ln231">        if (it.link_id &gt;= 0) {</a>
<a name="ln232">          fallback = true;</a>
<a name="ln233">        }</a>
<a name="ln234">      }</a>
<a name="ln235">    }</a>
<a name="ln236"> </a>
<a name="ln237">    it.attr_id = fallback ? -1 : hl_get_syn_attr(ns_id, hl_id, attrs);</a>
<a name="ln238">    it.version = p-&gt;hl_valid - tmp;</a>
<a name="ln239">    it.is_default = attrs.rgb_ae_attr &amp; HL_DEFAULT;</a>
<a name="ln240">    it.link_global = attrs.rgb_ae_attr &amp; HL_GLOBAL;</a>
<a name="ln241">    map_put(ColorKey, ColorItem)(&amp;ns_hls, ColorKey(ns_id, hl_id), it);</a>
<a name="ln242">    valid_item = true;</a>
<a name="ln243">  }</a>
<a name="ln244"> </a>
<a name="ln245">  if ((it.is_default &amp;&amp; nodefault) || !valid_item) {</a>
<a name="ln246">    return -1;</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  if (link) {</a>
<a name="ln250">    if (it.attr_id &gt;= 0) {</a>
<a name="ln251">      return 0;</a>
<a name="ln252">    }</a>
<a name="ln253">    if (it.link_global) {</a>
<a name="ln254">      *ns_hl = 0;</a>
<a name="ln255">    }</a>
<a name="ln256">    return it.link_id;</a>
<a name="ln257">  } else {</a>
<a name="ln258">    return it.attr_id;</a>
<a name="ln259">  }</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">bool hl_check_ns(void)</a>
<a name="ln263">{</a>
<a name="ln264">  int ns = 0;</a>
<a name="ln265">  if (ns_hl_fast &gt; 0) {</a>
<a name="ln266">    ns = ns_hl_fast;</a>
<a name="ln267">  } else if (ns_hl_win &gt;= 0) {</a>
<a name="ln268">    ns = ns_hl_win;</a>
<a name="ln269">  } else {</a>
<a name="ln270">    ns = ns_hl_global;</a>
<a name="ln271">  }</a>
<a name="ln272">  if (ns_hl_active == ns) {</a>
<a name="ln273">    return false;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  ns_hl_active = ns;</a>
<a name="ln277">  hl_attr_active = highlight_attr;</a>
<a name="ln278">  if (ns &gt; 0) {</a>
<a name="ln279">    update_ns_hl(ns);</a>
<a name="ln280">    NSHlAttr *hl_def = (NSHlAttr *)pmap_get(int)(&amp;ns_hl_attr, ns);</a>
<a name="ln281">    if (hl_def) {</a>
<a name="ln282">      hl_attr_active = *hl_def;</a>
<a name="ln283">    }</a>
<a name="ln284">  }</a>
<a name="ln285">  need_highlight_changed = true;</a>
<a name="ln286">  return true;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">/// prepare for drawing window `wp` or global elements if NULL</a>
<a name="ln290">///</a>
<a name="ln291">/// Note: pum should be drawn in the context of the current window!</a>
<a name="ln292">bool win_check_ns_hl(win_T *wp)</a>
<a name="ln293">{</a>
<a name="ln294">  ns_hl_win = wp ? wp-&gt;w_ns_hl : -1;</a>
<a name="ln295">  return hl_check_ns();</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">/// Get attribute code for a builtin highlight group.</a>
<a name="ln299">///</a>
<a name="ln300">/// The final syntax group could be modified by hi-link or 'winhighlight'.</a>
<a name="ln301">int hl_get_ui_attr(int ns_id, int idx, int final_id, bool optional)</a>
<a name="ln302">{</a>
<a name="ln303">  HlAttrs attrs = HLATTRS_INIT;</a>
<a name="ln304">  bool available = false;</a>
<a name="ln305"> </a>
<a name="ln306">  if (final_id &gt; 0) {</a>
<a name="ln307">    int syn_attr = syn_ns_id2attr(ns_id, final_id, &amp;optional);</a>
<a name="ln308">    if (syn_attr &gt; 0) {</a>
<a name="ln309">      attrs = syn_attr2entry(syn_attr);</a>
<a name="ln310">      available = true;</a>
<a name="ln311">    }</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">  if (HLF_PNI &lt;= idx &amp;&amp; idx &lt;= HLF_PST) {</a>
<a name="ln315">    if (attrs.hl_blend == -1 &amp;&amp; p_pb &gt; 0) {</a>
<a name="ln316">      attrs.hl_blend = (int)p_pb;</a>
<a name="ln317">    }</a>
<a name="ln318">    if (pum_drawn()) {</a>
<a name="ln319">      must_redraw_pum = true;</a>
<a name="ln320">    }</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  if (optional &amp;&amp; !available) {</a>
<a name="ln324">    return 0;</a>
<a name="ln325">  }</a>
<a name="ln326">  return get_attr_entry((HlEntry){ .attr = attrs, .kind = kHlUI,</a>
<a name="ln327">                                   .id1 = idx, .id2 = final_id });</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">void update_window_hl(win_T *wp, bool invalid)</a>
<a name="ln331">{</a>
<a name="ln332">  int ns_id = wp-&gt;w_ns_hl;</a>
<a name="ln333"> </a>
<a name="ln334">  update_ns_hl(ns_id);</a>
<a name="ln335">  if (ns_id != wp-&gt;w_ns_hl_active || wp-&gt;w_ns_hl_attr == NULL) {</a>
<a name="ln336">    wp-&gt;w_ns_hl_active = ns_id;</a>
<a name="ln337"> </a>
<a name="ln338">    wp-&gt;w_ns_hl_attr = *(NSHlAttr *)pmap_get(int)(&amp;ns_hl_attr, ns_id);</a>
<a name="ln339">    if (!wp-&gt;w_ns_hl_attr) {</a>
<a name="ln340">      // No specific highlights, use the defaults.</a>
<a name="ln341">      wp-&gt;w_ns_hl_attr = highlight_attr;</a>
<a name="ln342">    }</a>
<a name="ln343">  }</a>
<a name="ln344"> </a>
<a name="ln345">  int *hl_def = wp-&gt;w_ns_hl_attr;</a>
<a name="ln346"> </a>
<a name="ln347">  if (!wp-&gt;w_hl_needs_update &amp;&amp; !invalid) {</a>
<a name="ln348">    return;</a>
<a name="ln349">  }</a>
<a name="ln350">  wp-&gt;w_hl_needs_update = false;</a>
<a name="ln351"> </a>
<a name="ln352">  // If a floating window is blending it always have a named</a>
<a name="ln353">  // wp-&gt;w_hl_attr_normal group. HL_ATTR(HLF_NFLOAT) is always named.</a>
<a name="ln354"> </a>
<a name="ln355">  // determine window specific background set in 'winhighlight'</a>
<a name="ln356">  bool float_win = wp-&gt;w_floating &amp;&amp; !wp-&gt;w_float_config.external;</a>
<a name="ln357">  if (float_win &amp;&amp; hl_def[HLF_NFLOAT] != 0) {</a>
<a name="ln358">    wp-&gt;w_hl_attr_normal = hl_def[HLF_NFLOAT];</a>
<a name="ln359">  } else if (hl_def[HLF_COUNT] &gt; 0) {</a>
<a name="ln360">    wp-&gt;w_hl_attr_normal = hl_def[HLF_COUNT];</a>
<a name="ln361">  } else {</a>
<a name="ln362">    wp-&gt;w_hl_attr_normal = float_win ? HL_ATTR(HLF_NFLOAT) : 0;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  // if blend= attribute is not set, 'winblend' value overrides it.</a>
<a name="ln366">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl &gt; 0) {</a>
<a name="ln367">    HlEntry entry = kv_A(attr_entries, wp-&gt;w_hl_attr_normal);</a>
<a name="ln368">    if (entry.attr.hl_blend == -1) {</a>
<a name="ln369">      entry.attr.hl_blend = (int)wp-&gt;w_p_winbl;</a>
<a name="ln370">      wp-&gt;w_hl_attr_normal = get_attr_entry(entry);</a>
<a name="ln371">    }</a>
<a name="ln372">  }</a>
<a name="ln373"> </a>
<a name="ln374">  wp-&gt;w_float_config.shadow = false;</a>
<a name="ln375">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_float_config.border) {</a>
<a name="ln376">    for (int i = 0; i &lt; 8; i++) {</a>
<a name="ln377">      int attr = hl_def[HLF_BORDER];</a>
<a name="ln378">      if (wp-&gt;w_float_config.border_hl_ids[i]) {</a>
<a name="ln379">        attr = hl_get_ui_attr(ns_id, HLF_BORDER,</a>
<a name="ln380">                              wp-&gt;w_float_config.border_hl_ids[i], false);</a>
<a name="ln381">        HlAttrs a = syn_attr2entry(attr);</a>
<a name="ln382">        if (a.hl_blend) {</a>
<a name="ln383">          wp-&gt;w_float_config.shadow = true;</a>
<a name="ln384">        }</a>
<a name="ln385">      }</a>
<a name="ln386">      wp-&gt;w_float_config.border_attr[i] = attr;</a>
<a name="ln387">    }</a>
<a name="ln388">  }</a>
<a name="ln389"> </a>
<a name="ln390">  // shadow might cause blending</a>
<a name="ln391">  check_blending(wp);</a>
<a name="ln392"> </a>
<a name="ln393">  // TODO(bfredl): this a bit ad-hoc. move it from highlight ns logic to 'winhl'</a>
<a name="ln394">  // implementation?</a>
<a name="ln395">  if (hl_def[HLF_INACTIVE] == 0) {</a>
<a name="ln396">    wp-&gt;w_hl_attr_normalnc = hl_combine_attr(HL_ATTR(HLF_INACTIVE),</a>
<a name="ln397">                                             wp-&gt;w_hl_attr_normal);</a>
<a name="ln398">  } else {</a>
<a name="ln399">    wp-&gt;w_hl_attr_normalnc = hl_def[HLF_INACTIVE];</a>
<a name="ln400">  }</a>
<a name="ln401"> </a>
<a name="ln402">  // if blend= attribute is not set, 'winblend' value overrides it.</a>
<a name="ln403">  if (wp-&gt;w_floating &amp;&amp; wp-&gt;w_p_winbl &gt; 0) {</a>
<a name="ln404">    HlEntry entry = kv_A(attr_entries, wp-&gt;w_hl_attr_normalnc);</a>
<a name="ln405">    if (entry.attr.hl_blend == -1) {</a>
<a name="ln406">      entry.attr.hl_blend = (int)wp-&gt;w_p_winbl;</a>
<a name="ln407">      wp-&gt;w_hl_attr_normalnc = get_attr_entry(entry);</a>
<a name="ln408">    }</a>
<a name="ln409">  }</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">void update_ns_hl(int ns_id)</a>
<a name="ln413">{</a>
<a name="ln414">  if (ns_id &lt;= 0) {</a>
<a name="ln415">    return;</a>
<a name="ln416">  }</a>
<a name="ln417">  DecorProvider *p = get_decor_provider(ns_id, true);</a>
<a name="ln418">  if (p-&gt;hl_cached) {</a>
<a name="ln419">    return;</a>
<a name="ln420">  }</a>
<a name="ln421"> </a>
<a name="ln422">  NSHlAttr **alloc = (NSHlAttr **)pmap_put_ref(int)(&amp;ns_hl_attr, ns_id, NULL, NULL);</a>
<a name="ln423">  if (*alloc == NULL) {</a>
<a name="ln424">    *alloc = xmalloc(sizeof(**alloc));</a>
<a name="ln425">  }</a>
<a name="ln426">  int *hl_attrs = **alloc;</a>
<a name="ln427"> </a>
<a name="ln428">  for (int hlf = 0; hlf &lt; HLF_COUNT; hlf++) {</a>
<a name="ln429">    int id = syn_check_group(hlf_names[hlf], strlen(hlf_names[hlf]));</a>
<a name="ln430">    bool optional = (hlf == HLF_INACTIVE || hlf == HLF_NFLOAT);</a>
<a name="ln431">    hl_attrs[hlf] = hl_get_ui_attr(ns_id, hlf, id, optional);</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  // NOOOO! You cannot just pretend that &quot;Normal&quot; is just like any other</a>
<a name="ln435">  // syntax group! It needs at least 10 layers of special casing! Noooooo!</a>
<a name="ln436">  //</a>
<a name="ln437">  // haha, tema engine go brrr</a>
<a name="ln438">  int normality = syn_check_group(S_LEN(&quot;Normal&quot;));</a>
<a name="ln439">  hl_attrs[HLF_COUNT] = hl_get_ui_attr(ns_id, -1, normality, true);</a>
<a name="ln440"> </a>
<a name="ln441">  // hl_get_ui_attr might have invalidated the decor provider</a>
<a name="ln442">  p = get_decor_provider(ns_id, true);</a>
<a name="ln443">  p-&gt;hl_cached = true;</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">int win_bg_attr(win_T *wp)</a>
<a name="ln447">{</a>
<a name="ln448">  if (ns_hl_fast &lt; 0) {</a>
<a name="ln449">    int local = (wp == curwin) ? wp-&gt;w_hl_attr_normal : wp-&gt;w_hl_attr_normalnc;</a>
<a name="ln450">    if (local) {</a>
<a name="ln451">      return local;</a>
<a name="ln452">    }</a>
<a name="ln453">  }</a>
<a name="ln454"> </a>
<a name="ln455">  if (wp == curwin || hl_attr_active[HLF_INACTIVE] == 0) {</a>
<a name="ln456">    return hl_attr_active[HLF_COUNT];</a>
<a name="ln457">  } else {</a>
<a name="ln458">    return hl_attr_active[HLF_INACTIVE];</a>
<a name="ln459">  }</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/// Gets HL_UNDERLINE highlight.</a>
<a name="ln463">int hl_get_underline(void)</a>
<a name="ln464">{</a>
<a name="ln465">  return get_attr_entry((HlEntry){</a>
<a name="ln466">    .attr = (HlAttrs){</a>
<a name="ln467">      .cterm_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln468">      .cterm_fg_color = 0,</a>
<a name="ln469">      .cterm_bg_color = 0,</a>
<a name="ln470">      .rgb_ae_attr = (int16_t)HL_UNDERLINE,</a>
<a name="ln471">      .rgb_fg_color = -1,</a>
<a name="ln472">      .rgb_bg_color = -1,</a>
<a name="ln473">      .rgb_sp_color = -1,</a>
<a name="ln474">      .hl_blend = -1,</a>
<a name="ln475">    },</a>
<a name="ln476">    .kind = kHlUI,</a>
<a name="ln477">    .id1 = 0,</a>
<a name="ln478">    .id2 = 0,</a>
<a name="ln479">  });</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/// Get attribute code for forwarded :terminal highlights.</a>
<a name="ln483">int hl_get_term_attr(HlAttrs *aep)</a>
<a name="ln484">{</a>
<a name="ln485">  return get_attr_entry((HlEntry){ .attr= *aep, .kind = kHlTerminal,</a>
<a name="ln486">                                   .id1 = 0, .id2 = 0 });</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">/// Clear all highlight tables.</a>
<a name="ln490">void clear_hl_tables(bool reinit)</a>
<a name="ln491">{</a>
<a name="ln492">  if (reinit) {</a>
<a name="ln493">    kv_size(attr_entries) = 1;</a>
<a name="ln494">    map_clear(HlEntry, &amp;attr_entry_ids);</a>
<a name="ln495">    map_clear(int, &amp;combine_attr_entries);</a>
<a name="ln496">    map_clear(int, &amp;blend_attr_entries);</a>
<a name="ln497">    map_clear(int, &amp;blendthrough_attr_entries);</a>
<a name="ln498">    memset(highlight_attr_last, -1, sizeof(highlight_attr_last));</a>
<a name="ln499">    highlight_attr_set_all();</a>
<a name="ln500">    highlight_changed();</a>
<a name="ln501">    screen_invalidate_highlights();</a>
<a name="ln502">  } else {</a>
<a name="ln503">    kv_destroy(attr_entries);</a>
<a name="ln504">    map_destroy(HlEntry, &amp;attr_entry_ids);</a>
<a name="ln505">    map_destroy(int, &amp;combine_attr_entries);</a>
<a name="ln506">    map_destroy(int, &amp;blend_attr_entries);</a>
<a name="ln507">    map_destroy(int, &amp;blendthrough_attr_entries);</a>
<a name="ln508">    map_destroy(ColorKey, &amp;ns_hls);</a>
<a name="ln509">  }</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">void hl_invalidate_blends(void)</a>
<a name="ln513">{</a>
<a name="ln514">  map_clear(int, &amp;blend_attr_entries);</a>
<a name="ln515">  map_clear(int, &amp;blendthrough_attr_entries);</a>
<a name="ln516">  highlight_changed();</a>
<a name="ln517">  update_window_hl(curwin, true);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/// Combine HlAttrFlags.</a>
<a name="ln521">/// The underline attribute in &quot;prim_ae&quot; overrules the one in &quot;char_ae&quot; if both are present.</a>
<a name="ln522">static int16_t hl_combine_ae(int16_t char_ae, int16_t prim_ae)</a>
<a name="ln523">{</a>
<a name="ln524">  int16_t char_ul = char_ae &amp; HL_UNDERLINE_MASK;</a>
<a name="ln525">  int16_t prim_ul = prim_ae &amp; HL_UNDERLINE_MASK;</a>
<a name="ln526">  int16_t new_ul = prim_ul ? prim_ul : char_ul;</a>
<a name="ln527">  return (char_ae &amp; ~HL_UNDERLINE_MASK) | (prim_ae &amp; ~HL_UNDERLINE_MASK) | new_ul;</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">// Combine special attributes (e.g., for spelling) with other attributes</a>
<a name="ln531">// (e.g., for syntax highlighting).</a>
<a name="ln532">// &quot;prim_attr&quot; overrules &quot;char_attr&quot;.</a>
<a name="ln533">// This creates a new group when required.</a>
<a name="ln534">// Since we expect there to be a lot of spelling mistakes we cache the result.</a>
<a name="ln535">// Return the resulting attributes.</a>
<a name="ln536">int hl_combine_attr(int char_attr, int prim_attr)</a>
<a name="ln537">{</a>
<a name="ln538">  if (char_attr == 0) {</a>
<a name="ln539">    return prim_attr;</a>
<a name="ln540">  } else if (prim_attr == 0) {</a>
<a name="ln541">    return char_attr;</a>
<a name="ln542">  }</a>
<a name="ln543"> </a>
<a name="ln544">  // TODO(bfredl): could use a struct for clearer intent.</a>
<a name="ln545">  int combine_tag = (char_attr &lt;&lt; 16) + prim_attr;</a>
<a name="ln546">  int id = map_get(int, int)(&amp;combine_attr_entries, combine_tag);</a>
<a name="ln547">  if (id &gt; 0) {</a>
<a name="ln548">    return id;</a>
<a name="ln549">  }</a>
<a name="ln550"> </a>
<a name="ln551">  HlAttrs char_aep = syn_attr2entry(char_attr);</a>
<a name="ln552">  HlAttrs prim_aep = syn_attr2entry(prim_attr);</a>
<a name="ln553"> </a>
<a name="ln554">  // start with low-priority attribute, and override colors if present below.</a>
<a name="ln555">  HlAttrs new_en = char_aep;</a>
<a name="ln556"> </a>
<a name="ln557">  if (prim_aep.cterm_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln558">    new_en.cterm_ae_attr = prim_aep.cterm_ae_attr;</a>
<a name="ln559">  } else {</a>
<a name="ln560">    new_en.cterm_ae_attr = hl_combine_ae(new_en.cterm_ae_attr, prim_aep.cterm_ae_attr);</a>
<a name="ln561">  }</a>
<a name="ln562">  if (prim_aep.rgb_ae_attr &amp; HL_NOCOMBINE) {</a>
<a name="ln563">    new_en.rgb_ae_attr = prim_aep.rgb_ae_attr;</a>
<a name="ln564">  } else {</a>
<a name="ln565">    new_en.rgb_ae_attr = hl_combine_ae(new_en.rgb_ae_attr, prim_aep.rgb_ae_attr);</a>
<a name="ln566">  }</a>
<a name="ln567"> </a>
<a name="ln568">  if (prim_aep.cterm_fg_color &gt; 0) {</a>
<a name="ln569">    new_en.cterm_fg_color = prim_aep.cterm_fg_color;</a>
<a name="ln570">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln571">                           | (prim_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  if (prim_aep.cterm_bg_color &gt; 0) {</a>
<a name="ln575">    new_en.cterm_bg_color = prim_aep.cterm_bg_color;</a>
<a name="ln576">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln577">                           | (prim_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln578">  }</a>
<a name="ln579"> </a>
<a name="ln580">  if (prim_aep.rgb_fg_color &gt;= 0) {</a>
<a name="ln581">    new_en.rgb_fg_color = prim_aep.rgb_fg_color;</a>
<a name="ln582">    new_en.rgb_ae_attr &amp;= ((~HL_FG_INDEXED)</a>
<a name="ln583">                           | (prim_aep.rgb_ae_attr &amp; HL_FG_INDEXED));</a>
<a name="ln584">  }</a>
<a name="ln585"> </a>
<a name="ln586">  if (prim_aep.rgb_bg_color &gt;= 0) {</a>
<a name="ln587">    new_en.rgb_bg_color = prim_aep.rgb_bg_color;</a>
<a name="ln588">    new_en.rgb_ae_attr &amp;= ((~HL_BG_INDEXED)</a>
<a name="ln589">                           | (prim_aep.rgb_ae_attr &amp; HL_BG_INDEXED));</a>
<a name="ln590">  }</a>
<a name="ln591"> </a>
<a name="ln592">  if (prim_aep.rgb_sp_color &gt;= 0) {</a>
<a name="ln593">    new_en.rgb_sp_color = prim_aep.rgb_sp_color;</a>
<a name="ln594">  }</a>
<a name="ln595"> </a>
<a name="ln596">  if (prim_aep.hl_blend &gt;= 0) {</a>
<a name="ln597">    new_en.hl_blend = prim_aep.hl_blend;</a>
<a name="ln598">  }</a>
<a name="ln599"> </a>
<a name="ln600">  id = get_attr_entry((HlEntry){ .attr = new_en, .kind = kHlCombine,</a>
<a name="ln601">                                 .id1 = char_attr, .id2 = prim_attr });</a>
<a name="ln602">  if (id &gt; 0) {</a>
<a name="ln603">    map_put(int, int)(&amp;combine_attr_entries, combine_tag, id);</a>
<a name="ln604">  }</a>
<a name="ln605"> </a>
<a name="ln606">  return id;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">/// Get the used rgb colors for an attr group.</a>
<a name="ln610">///</a>
<a name="ln611">/// If colors are unset, use builtin default colors. Never returns -1</a>
<a name="ln612">/// Cterm colors are unchanged.</a>
<a name="ln613">static HlAttrs get_colors_force(int attr)</a>
<a name="ln614">{</a>
<a name="ln615">  HlAttrs attrs = syn_attr2entry(attr);</a>
<a name="ln616">  if (attrs.rgb_bg_color == -1) {</a>
<a name="ln617">    attrs.rgb_bg_color = normal_bg;</a>
<a name="ln618">  }</a>
<a name="ln619">  if (attrs.rgb_fg_color == -1) {</a>
<a name="ln620">    attrs.rgb_fg_color = normal_fg;</a>
<a name="ln621">  }</a>
<a name="ln622">  if (attrs.rgb_sp_color == -1) {</a>
<a name="ln623">    attrs.rgb_sp_color = normal_sp;</a>
<a name="ln624">  }</a>
<a name="ln625">  HL_SET_DEFAULT_COLORS(attrs.rgb_fg_color, attrs.rgb_bg_color,</a>
<a name="ln626">                        attrs.rgb_sp_color);</a>
<a name="ln627"> </a>
<a name="ln628">  if (attrs.rgb_ae_attr &amp; HL_INVERSE) {</a>
<a name="ln629">    int temp = attrs.rgb_bg_color;</a>
<a name="ln630">    attrs.rgb_bg_color = attrs.rgb_fg_color;</a>
<a name="ln631">    attrs.rgb_fg_color = temp;</a>
<a name="ln632">    attrs.rgb_ae_attr &amp;= ~HL_INVERSE;</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">  return attrs;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">/// Blend overlay attributes (for popupmenu) with other attributes</a>
<a name="ln639">///</a>
<a name="ln640">/// This creates a new group when required.</a>
<a name="ln641">/// This is called per-cell, so cache the result.</a>
<a name="ln642">///</a>
<a name="ln643">/// @return the resulting attributes.</a>
<a name="ln644">int hl_blend_attrs(int back_attr, int front_attr, bool *through)</a>
<a name="ln645">{</a>
<a name="ln646">  if (front_attr &lt; 0 || back_attr &lt; 0) {</a>
<a name="ln647">    return -1;</a>
<a name="ln648">  }</a>
<a name="ln649"> </a>
<a name="ln650">  HlAttrs fattrs = get_colors_force(front_attr);</a>
<a name="ln651">  int ratio = fattrs.hl_blend;</a>
<a name="ln652">  if (ratio &lt;= 0) {</a>
<a name="ln653">    *through = false;</a>
<a name="ln654">    return front_attr;</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657">  int combine_tag = (back_attr &lt;&lt; 16) + front_attr;</a>
<a name="ln658">  Map(int, int) *map = (*through</a>
<a name="ln659">                        ? &amp;blendthrough_attr_entries</a>
<a name="ln660">                        : &amp;blend_attr_entries);</a>
<a name="ln661">  int id = map_get(int, int)(map, combine_tag);</a>
<a name="ln662">  if (id &gt; 0) {</a>
<a name="ln663">    return id;</a>
<a name="ln664">  }</a>
<a name="ln665"> </a>
<a name="ln666">  HlAttrs battrs = get_colors_force(back_attr);</a>
<a name="ln667">  HlAttrs cattrs;</a>
<a name="ln668"> </a>
<a name="ln669">  if (*through) {</a>
<a name="ln670">    cattrs = battrs;</a>
<a name="ln671">    cattrs.rgb_fg_color = rgb_blend(ratio, battrs.rgb_fg_color,</a>
<a name="ln672">                                    fattrs.rgb_bg_color);</a>
<a name="ln673">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE_MASK)) {</a>
<a name="ln674">      cattrs.rgb_sp_color = rgb_blend(ratio, battrs.rgb_sp_color,</a>
<a name="ln675">                                      fattrs.rgb_bg_color);</a>
<a name="ln676">    } else {</a>
<a name="ln677">      cattrs.rgb_sp_color = -1;</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    cattrs.cterm_bg_color = fattrs.cterm_bg_color;</a>
<a name="ln681">    cattrs.cterm_fg_color = cterm_blend(ratio, battrs.cterm_fg_color,</a>
<a name="ln682">                                        fattrs.cterm_bg_color);</a>
<a name="ln683">    cattrs.rgb_ae_attr &amp;= ~(HL_FG_INDEXED | HL_BG_INDEXED);</a>
<a name="ln684">  } else {</a>
<a name="ln685">    cattrs = fattrs;</a>
<a name="ln686">    if (ratio &gt;= 50) {</a>
<a name="ln687">      cattrs.rgb_ae_attr = hl_combine_ae(battrs.rgb_ae_attr, cattrs.rgb_ae_attr);</a>
<a name="ln688">    }</a>
<a name="ln689">    cattrs.rgb_fg_color = rgb_blend(ratio/2, battrs.rgb_fg_color,</a>
<a name="ln690">                                    fattrs.rgb_fg_color);</a>
<a name="ln691">    if (cattrs.rgb_ae_attr &amp; (HL_UNDERLINE_MASK)) {</a>
<a name="ln692">      cattrs.rgb_sp_color = rgb_blend(ratio/2, battrs.rgb_bg_color,</a>
<a name="ln693">                                      fattrs.rgb_sp_color);</a>
<a name="ln694">    } else {</a>
<a name="ln695">      cattrs.rgb_sp_color = -1;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">    cattrs.rgb_ae_attr &amp;= ~HL_BG_INDEXED;</a>
<a name="ln699">  }</a>
<a name="ln700">  cattrs.rgb_bg_color = rgb_blend(ratio, battrs.rgb_bg_color,</a>
<a name="ln701">                                  fattrs.rgb_bg_color);</a>
<a name="ln702"> </a>
<a name="ln703">  cattrs.hl_blend = -1;  // blend property was consumed</a>
<a name="ln704"> </a>
<a name="ln705">  HlKind kind = *through ? kHlBlendThrough : kHlBlend;</a>
<a name="ln706">  id = get_attr_entry((HlEntry){ .attr = cattrs, .kind = kind,</a>
<a name="ln707">                                 .id1 = back_attr, .id2 = front_attr });</a>
<a name="ln708">  if (id &gt; 0) {</a>
<a name="ln709">    map_put(int, int)(map, combine_tag, id);</a>
<a name="ln710">  }</a>
<a name="ln711">  return id;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">static int rgb_blend(int ratio, int rgb1, int rgb2)</a>
<a name="ln715">{</a>
<a name="ln716">  int a = ratio, b = 100 - ratio;</a>
<a name="ln717">  int r1 = (rgb1 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln718">  int g1 = (rgb1 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln719">  int b1 = (rgb1 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln720">  int r2 = (rgb2 &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln721">  int g2 = (rgb2 &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln722">  int b2 = (rgb2 &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln723">  int mr = (a * r1 + b * r2)/100;</a>
<a name="ln724">  int mg = (a * g1 + b * g2)/100;</a>
<a name="ln725">  int mb = (a * b1 + b * b2)/100;</a>
<a name="ln726">  return (mr &lt;&lt; 16) + (mg &lt;&lt; 8) + mb;</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">static int cterm_blend(int ratio, int c1, int c2)</a>
<a name="ln730">{</a>
<a name="ln731">  // 1. Convert cterm color numbers to RGB.</a>
<a name="ln732">  // 2. Blend the RGB colors.</a>
<a name="ln733">  // 3. Convert the RGB result to a cterm color.</a>
<a name="ln734">  int rgb1 = hl_cterm2rgb_color(c1);</a>
<a name="ln735">  int rgb2 = hl_cterm2rgb_color(c2);</a>
<a name="ln736">  int rgb_blended = rgb_blend(ratio, rgb1, rgb2);</a>
<a name="ln737">  return hl_rgb2cterm_color(rgb_blended);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/// Converts RGB color to 8-bit color (0-255).</a>
<a name="ln741">static int hl_rgb2cterm_color(int rgb)</a>
<a name="ln742">{</a>
<a name="ln743">  int r = (rgb &amp; 0xFF0000) &gt;&gt; 16;</a>
<a name="ln744">  int g = (rgb &amp; 0x00FF00) &gt;&gt; 8;</a>
<a name="ln745">  int b = (rgb &amp; 0x0000FF) &gt;&gt; 0;</a>
<a name="ln746"> </a>
<a name="ln747">  return (r * 6 / 256) * 36 + (g * 6 / 256) * 6 + (b * 6 / 256);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">/// Converts 8-bit color (0-255) to RGB color.</a>
<a name="ln751">/// This is compatible with xterm.</a>
<a name="ln752">static int hl_cterm2rgb_color(int nr)</a>
<a name="ln753">{</a>
<a name="ln754">  static int cube_value[] = {</a>
<a name="ln755">    0x00, 0x5F, 0x87, 0xAF, 0xD7, 0xFF</a>
<a name="ln756">  };</a>
<a name="ln757">  static int grey_ramp[] = {</a>
<a name="ln758">    0x08, 0x12, 0x1C, 0x26, 0x30, 0x3A, 0x44, 0x4E, 0x58, 0x62, 0x6C, 0x76,</a>
<a name="ln759">    0x80, 0x8A, 0x94, 0x9E, 0xA8, 0xB2, 0xBC, 0xC6, 0xD0, 0xDA, 0xE4, 0xEE</a>
<a name="ln760">  };</a>
<a name="ln761">  static uint8_t ansi_table[16][4] = {</a>
<a name="ln762">    //  R    G    B   idx</a>
<a name="ln763">    {   0,   0,   0,  1 },  // black</a>
<a name="ln764">    { 224,   0,   0,  2 },  // dark red</a>
<a name="ln765">    {   0, 224,   0,  3 },  // dark green</a>
<a name="ln766">    { 224, 224,   0,  4 },  // dark yellow / brown</a>
<a name="ln767">    {   0,   0, 224,  5 },  // dark blue</a>
<a name="ln768">    { 224,   0, 224,  6 },  // dark magenta</a>
<a name="ln769">    {   0, 224, 224,  7 },  // dark cyan</a>
<a name="ln770">    { 224, 224, 224,  8 },  // light grey</a>
<a name="ln771"> </a>
<a name="ln772">    { 128, 128, 128,  9 },  // dark grey</a>
<a name="ln773">    { 255,  64,  64, 10 },  // light red</a>
<a name="ln774">    {  64, 255,  64, 11 },  // light green</a>
<a name="ln775">    { 255, 255,  64, 12 },  // yellow</a>
<a name="ln776">    {  64,  64, 255, 13 },  // light blue</a>
<a name="ln777">    { 255,  64, 255, 14 },  // light magenta</a>
<a name="ln778">    {  64, 255, 255, 15 },  // light cyan</a>
<a name="ln779">    { 255, 255, 255, 16 },  // white</a>
<a name="ln780">  };</a>
<a name="ln781"> </a>
<a name="ln782">  int r = 0;</a>
<a name="ln783">  int g = 0;</a>
<a name="ln784">  int b = 0;</a>
<a name="ln785">  int idx;</a>
<a name="ln786">  // *ansi_idx = 0;</a>
<a name="ln787"> </a>
<a name="ln788">  if (nr &lt; 16) {</a>
<a name="ln789">    r = ansi_table[nr][0];</a>
<a name="ln790">    g = ansi_table[nr][1];</a>
<a name="ln791">    b = ansi_table[nr][2];</a>
<a name="ln792">    // *ansi_idx = ansi_table[nr][3];</a>
<a name="ln793">  } else if (nr &lt; 232) {  // 216 color-cube</a>
<a name="ln794">    idx = nr - 16;</a>
<a name="ln795">    r = cube_value[idx / 36 % 6];</a>
<a name="ln796">    g = cube_value[idx / 6  % 6];</a>
<a name="ln797">    b = cube_value[idx      % 6];</a>
<a name="ln798">    // *ansi_idx = -1;</a>
<a name="ln799">  } else if (nr &lt; 256) {  // 24 greyscale ramp</a>
<a name="ln800">    idx = nr - 232;</a>
<a name="ln801">    r = grey_ramp[idx];</a>
<a name="ln802">    g = grey_ramp[idx];</a>
<a name="ln803">    b = grey_ramp[idx];</a>
<a name="ln804">    // *ansi_idx = -1;</a>
<a name="ln805">  }</a>
<a name="ln806">  return (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">/// Get highlight attributes for a attribute code</a>
<a name="ln810">HlAttrs syn_attr2entry(int attr)</a>
<a name="ln811">{</a>
<a name="ln812">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln813">    // invalid attribute code, or the tables were cleared</a>
<a name="ln814">    return HLATTRS_INIT;</a>
<a name="ln815">  }</a>
<a name="ln816">  return kv_A(attr_entries, attr).attr;</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">/// Gets highlight description for id `attr_id` as a map.</a>
<a name="ln820">Dictionary hl_get_attr_by_id(Integer attr_id, Boolean rgb, Arena *arena, Error *err)</a>
<a name="ln821">{</a>
<a name="ln822">  Dictionary dic = ARRAY_DICT_INIT;</a>
<a name="ln823"> </a>
<a name="ln824">  if (attr_id == 0) {</a>
<a name="ln825">    return dic;</a>
<a name="ln826">  }</a>
<a name="ln827"> </a>
<a name="ln828">  if (attr_id &lt;= 0 || attr_id &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln829">    api_set_error(err, kErrorTypeException,</a>
<a name="ln830">                  &quot;Invalid attribute id: %&quot; PRId64, attr_id);</a>
<a name="ln831">    return dic;</a>
<a name="ln832">  }</a>
<a name="ln833">  Dictionary retval = arena_dict(arena, HLATTRS_DICT_SIZE);</a>
<a name="ln834">  hlattrs2dict(&amp;retval, NULL, syn_attr2entry((int)attr_id), rgb, false);</a>
<a name="ln835">  return retval;</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">/// Converts an HlAttrs into Dictionary</a>
<a name="ln839">///</a>
<a name="ln840">/// @param[in/out] hl Dictionary with pre-allocated space for HLATTRS_DICT_SIZE elements</a>
<a name="ln841">/// @param[in] aep data to convert</a>
<a name="ln842">/// @param use_rgb use 'gui*' settings if true, else resorts to 'cterm*'</a>
<a name="ln843">/// @param short_keys change (foreground, background, special) to (fg, bg, sp) for 'gui*' settings</a>
<a name="ln844">///                          (foreground, background) to (ctermfg, ctermbg) for 'cterm*' settings</a>
<a name="ln845">void hlattrs2dict(Dictionary *hl, Dictionary *hl_attrs, HlAttrs ae, bool use_rgb, bool short_keys)</a>
<a name="ln846">{</a>
<a name="ln847">  hl_attrs = hl_attrs ? hl_attrs : hl;</a>
<a name="ln848">  assert(hl-&gt;capacity &gt;= HLATTRS_DICT_SIZE);  // at most 16 items</a>
<a name="ln849">  assert(hl_attrs-&gt;capacity &gt;= HLATTRS_DICT_SIZE);  // at most 16 items</a>
<a name="ln850">  int mask  = use_rgb ? ae.rgb_ae_attr : ae.cterm_ae_attr;</a>
<a name="ln851"> </a>
<a name="ln852">  if (mask &amp; HL_INVERSE) {</a>
<a name="ln853">    PUT_C(*hl_attrs, &quot;reverse&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln854">  }</a>
<a name="ln855"> </a>
<a name="ln856">  if (mask &amp; HL_BOLD) {</a>
<a name="ln857">    PUT_C(*hl_attrs, &quot;bold&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860">  if (mask &amp; HL_ITALIC) {</a>
<a name="ln861">    PUT_C(*hl_attrs, &quot;italic&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln862">  }</a>
<a name="ln863"> </a>
<a name="ln864">  switch (mask &amp; HL_UNDERLINE_MASK) {</a>
<a name="ln865">  case HL_UNDERLINE:</a>
<a name="ln866">    PUT_C(*hl_attrs, &quot;underline&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln867">    break;</a>
<a name="ln868"> </a>
<a name="ln869">  case HL_UNDERCURL:</a>
<a name="ln870">    PUT_C(*hl_attrs, &quot;undercurl&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln871">    break;</a>
<a name="ln872"> </a>
<a name="ln873">  case HL_UNDERDOUBLE:</a>
<a name="ln874">    PUT_C(*hl_attrs, &quot;underdouble&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln875">    break;</a>
<a name="ln876"> </a>
<a name="ln877">  case HL_UNDERDOTTED:</a>
<a name="ln878">    PUT_C(*hl_attrs, &quot;underdotted&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln879">    break;</a>
<a name="ln880"> </a>
<a name="ln881">  case HL_UNDERDASHED:</a>
<a name="ln882">    PUT_C(*hl_attrs, &quot;underdashed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln883">    break;</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  if (mask &amp; HL_STANDOUT) {</a>
<a name="ln887">    PUT_C(*hl_attrs, &quot;standout&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln888">  }</a>
<a name="ln889"> </a>
<a name="ln890">  if (mask &amp; HL_STRIKETHROUGH) {</a>
<a name="ln891">    PUT_C(*hl_attrs, &quot;strikethrough&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln892">  }</a>
<a name="ln893"> </a>
<a name="ln894">  if (mask &amp; HL_ALTFONT) {</a>
<a name="ln895">    PUT_C(*hl_attrs, &quot;altfont&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln896">  }</a>
<a name="ln897"> </a>
<a name="ln898">  if (mask &amp; HL_NOCOMBINE) {</a>
<a name="ln899">    PUT_C(*hl_attrs, &quot;nocombine&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln900">  }</a>
<a name="ln901"> </a>
<a name="ln902">  if (use_rgb) {</a>
<a name="ln903">    if (ae.rgb_fg_color != -1) {</a>
<a name="ln904">      PUT_C(*hl, short_keys ? &quot;fg&quot; : &quot;foreground&quot;, INTEGER_OBJ(ae.rgb_fg_color));</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    if (ae.rgb_bg_color != -1) {</a>
<a name="ln908">      PUT_C(*hl, short_keys ? &quot;bg&quot; : &quot;background&quot;, INTEGER_OBJ(ae.rgb_bg_color));</a>
<a name="ln909">    }</a>
<a name="ln910"> </a>
<a name="ln911">    if (ae.rgb_sp_color != -1) {</a>
<a name="ln912">      PUT_C(*hl, short_keys ? &quot;sp&quot; : &quot;special&quot;, INTEGER_OBJ(ae.rgb_sp_color));</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    if (!short_keys) {</a>
<a name="ln916">      if (mask &amp; HL_FG_INDEXED) {</a>
<a name="ln917">        PUT_C(*hl, &quot;fg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln918">      }</a>
<a name="ln919"> </a>
<a name="ln920">      if (mask &amp; HL_BG_INDEXED) {</a>
<a name="ln921">        PUT_C(*hl, &quot;bg_indexed&quot;, BOOLEAN_OBJ(true));</a>
<a name="ln922">      }</a>
<a name="ln923">    }</a>
<a name="ln924">  } else {</a>
<a name="ln925">    if (ae.cterm_fg_color != 0) {</a>
<a name="ln926">      PUT_C(*hl, short_keys ? &quot;ctermfg&quot; : &quot;foreground&quot;, INTEGER_OBJ(ae.cterm_fg_color - 1));</a>
<a name="ln927">    }</a>
<a name="ln928"> </a>
<a name="ln929">    if (ae.cterm_bg_color != 0) {</a>
<a name="ln930">      PUT_C(*hl, short_keys ? &quot;ctermbg&quot; : &quot;background&quot;, INTEGER_OBJ(ae.cterm_bg_color - 1));</a>
<a name="ln931">    }</a>
<a name="ln932">  }</a>
<a name="ln933"> </a>
<a name="ln934">  if (ae.hl_blend &gt; -1 &amp;&amp; (use_rgb || !short_keys)) {</a>
<a name="ln935">    PUT_C(*hl, &quot;blend&quot;, INTEGER_OBJ(ae.hl_blend));</a>
<a name="ln936">  }</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">HlAttrs dict2hlattrs(Dict(highlight) *dict, bool use_rgb, int *link_id, Error *err)</a>
<a name="ln940">{</a>
<a name="ln941">  HlAttrs hlattrs = HLATTRS_INIT;</a>
<a name="ln942">  int32_t fg = -1, bg = -1, ctermfg = -1, ctermbg = -1, sp = -1;</a>
<a name="ln943">  int blend = -1;</a>
<a name="ln944">  int16_t mask = 0;</a>
<a name="ln945">  int16_t cterm_mask = 0;</a>
<a name="ln946">  bool cterm_mask_provided = false;</a>
<a name="ln947"> </a>
<a name="ln948">#define CHECK_FLAG(d, m, name, extra, flag) \</a>
<a name="ln949">  if (api_object_to_bool(d-&gt;name##extra, #name, false, err)) { \</a>
<a name="ln950">    if (flag &amp; HL_UNDERLINE_MASK) { \</a>
<a name="ln951">      m &amp;= ~HL_UNDERLINE_MASK; \</a>
<a name="ln952">    } \</a>
<a name="ln953">    m |= flag; \</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  CHECK_FLAG(dict, mask, reverse, , HL_INVERSE);</a>
<a name="ln957">  CHECK_FLAG(dict, mask, bold, , HL_BOLD);</a>
<a name="ln958">  CHECK_FLAG(dict, mask, italic, , HL_ITALIC);</a>
<a name="ln959">  CHECK_FLAG(dict, mask, underline, , HL_UNDERLINE);</a>
<a name="ln960">  CHECK_FLAG(dict, mask, undercurl, , HL_UNDERCURL);</a>
<a name="ln961">  CHECK_FLAG(dict, mask, underdouble, , HL_UNDERDOUBLE);</a>
<a name="ln962">  CHECK_FLAG(dict, mask, underdotted, , HL_UNDERDOTTED);</a>
<a name="ln963">  CHECK_FLAG(dict, mask, underdashed, , HL_UNDERDASHED);</a>
<a name="ln964">  CHECK_FLAG(dict, mask, standout, , HL_STANDOUT);</a>
<a name="ln965">  CHECK_FLAG(dict, mask, strikethrough, , HL_STRIKETHROUGH);</a>
<a name="ln966">  CHECK_FLAG(dict, mask, altfont, , HL_ALTFONT);</a>
<a name="ln967">  if (use_rgb) {</a>
<a name="ln968">    CHECK_FLAG(dict, mask, fg_indexed, , HL_FG_INDEXED);</a>
<a name="ln969">    CHECK_FLAG(dict, mask, bg_indexed, , HL_BG_INDEXED);</a>
<a name="ln970">  }</a>
<a name="ln971">  CHECK_FLAG(dict, mask, nocombine, , HL_NOCOMBINE);</a>
<a name="ln972">  CHECK_FLAG(dict, mask, default, _, HL_DEFAULT);</a>
<a name="ln973"> </a>
<a name="ln974">  if (HAS_KEY(dict-&gt;fg)) {</a>
<a name="ln975">    fg = object_to_color(dict-&gt;fg, &quot;fg&quot;, use_rgb, err);</a>
<a name="ln976">  } else if (HAS_KEY(dict-&gt;foreground)) {</a>
<a name="ln977">    fg = object_to_color(dict-&gt;foreground, &quot;foreground&quot;, use_rgb, err);</a>
<a name="ln978">  }</a>
<a name="ln979">  if (ERROR_SET(err)) {</a>
<a name="ln980">    return hlattrs;</a>
<a name="ln981">  }</a>
<a name="ln982"> </a>
<a name="ln983">  if (HAS_KEY(dict-&gt;bg)) {</a>
<a name="ln984">    bg = object_to_color(dict-&gt;bg, &quot;bg&quot;, use_rgb, err);</a>
<a name="ln985">  } else if (HAS_KEY(dict-&gt;background)) {</a>
<a name="ln986">    bg = object_to_color(dict-&gt;background, &quot;background&quot;, use_rgb, err);</a>
<a name="ln987">  }</a>
<a name="ln988">  if (ERROR_SET(err)) {</a>
<a name="ln989">    return hlattrs;</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992">  if (HAS_KEY(dict-&gt;sp)) {</a>
<a name="ln993">    sp = object_to_color(dict-&gt;sp, &quot;sp&quot;, true, err);</a>
<a name="ln994">  } else if (HAS_KEY(dict-&gt;special)) {</a>
<a name="ln995">    sp = object_to_color(dict-&gt;special, &quot;special&quot;, true, err);</a>
<a name="ln996">  }</a>
<a name="ln997">  if (ERROR_SET(err)) {</a>
<a name="ln998">    return hlattrs;</a>
<a name="ln999">  }</a>
<a name="ln1000"> </a>
<a name="ln1001">  if (HAS_KEY(dict-&gt;blend)) {</a>
<a name="ln1002">    VALIDATE_T(&quot;blend&quot;, kObjectTypeInteger, dict-&gt;blend.type, {</a>
<a name="ln1003">      return hlattrs;</a>
<a name="ln1004">    });</a>
<a name="ln1005"> </a>
<a name="ln1006">    Integer blend0 = dict-&gt;blend.data.integer;</a>
<a name="ln1007">    VALIDATE_RANGE((blend0 &gt;= 0 &amp;&amp; blend0 &lt;= 100), &quot;blend&quot;, {</a>
<a name="ln1008">      return hlattrs;</a>
<a name="ln1009">    });</a>
<a name="ln1010">    blend = (int)blend0;</a>
<a name="ln1011">  }</a>
<a name="ln1012"> </a>
<a name="ln1013">  if (HAS_KEY(dict-&gt;link) || HAS_KEY(dict-&gt;global_link)) {</a>
<a name="ln1014">    if (!link_id) {</a>
<a name="ln1015">      api_set_error(err, kErrorTypeValidation, &quot;Invalid Key: '%s'&quot;,</a>
<a name="ln1016">                    HAS_KEY(dict-&gt;global_link) ? &quot;global_link&quot; : &quot;link&quot;);</a>
<a name="ln1017">      return hlattrs;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    if (HAS_KEY(dict-&gt;global_link)) {</a>
<a name="ln1020">      *link_id = object_to_hl_id(dict-&gt;global_link, &quot;link&quot;, err);</a>
<a name="ln1021">      mask |= HL_GLOBAL;</a>
<a name="ln1022">    } else {</a>
<a name="ln1023">      *link_id = object_to_hl_id(dict-&gt;link, &quot;link&quot;, err);</a>
<a name="ln1024">    }</a>
<a name="ln1025"> </a>
<a name="ln1026">    if (ERROR_SET(err)) {</a>
<a name="ln1027">      return hlattrs;</a>
<a name="ln1028">    }</a>
<a name="ln1029">  }</a>
<a name="ln1030"> </a>
<a name="ln1031">  // Handle cterm attrs</a>
<a name="ln1032">  if (dict-&gt;cterm.type == kObjectTypeDictionary) {</a>
<a name="ln1033">    Dict(highlight_cterm) cterm[1] = { 0 };</a>
<a name="ln1034">    if (!api_dict_to_keydict(cterm, KeyDict_highlight_cterm_get_field,</a>
<a name="ln1035">                             dict-&gt;cterm.data.dictionary, err)) {</a>
<a name="ln1036">      return hlattrs;</a>
<a name="ln1037">    }</a>
<a name="ln1038"> </a>
<a name="ln1039">    cterm_mask_provided = true;</a>
<a name="ln1040">    CHECK_FLAG(cterm, cterm_mask, reverse, , HL_INVERSE);</a>
<a name="ln1041">    CHECK_FLAG(cterm, cterm_mask, bold, , HL_BOLD);</a>
<a name="ln1042">    CHECK_FLAG(cterm, cterm_mask, italic, , HL_ITALIC);</a>
<a name="ln1043">    CHECK_FLAG(cterm, cterm_mask, underline, , HL_UNDERLINE);</a>
<a name="ln1044">    CHECK_FLAG(cterm, cterm_mask, undercurl, , HL_UNDERCURL);</a>
<a name="ln1045">    CHECK_FLAG(cterm, cterm_mask, standout, , HL_STANDOUT);</a>
<a name="ln1046">    CHECK_FLAG(cterm, cterm_mask, strikethrough, , HL_STRIKETHROUGH);</a>
<a name="ln1047">    CHECK_FLAG(cterm, cterm_mask, altfont, , HL_ALTFONT);</a>
<a name="ln1048">    CHECK_FLAG(cterm, cterm_mask, nocombine, , HL_NOCOMBINE);</a>
<a name="ln1049">  } else if (dict-&gt;cterm.type == kObjectTypeArray &amp;&amp; dict-&gt;cterm.data.array.size == 0) {</a>
<a name="ln1050">    // empty list from Lua API should clear all cterm attributes</a>
<a name="ln1051">    // TODO(clason): handle via gen_api_dispatch</a>
<a name="ln1052">    cterm_mask_provided = true;</a>
<a name="ln1053">  } else if (HAS_KEY(dict-&gt;cterm)) {</a>
<a name="ln1054">    VALIDATE_EXP(false, &quot;cterm&quot;, &quot;Dict&quot;, api_typename(dict-&gt;cterm.type), {</a>
<a name="ln1055">      return hlattrs;</a>
<a name="ln1056">    });</a>
<a name="ln1057">  }</a>
<a name="ln1058">#undef CHECK_FLAG</a>
<a name="ln1059"> </a>
<a name="ln1060">  if (HAS_KEY(dict-&gt;ctermfg)) {</a>
<a name="ln1061">    ctermfg = object_to_color(dict-&gt;ctermfg, &quot;ctermfg&quot;, false, err);</a>
<a name="ln1062">    if (ERROR_SET(err)) {</a>
<a name="ln1063">      return hlattrs;</a>
<a name="ln1064">    }</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  if (HAS_KEY(dict-&gt;ctermbg)) {</a>
<a name="ln1068">    ctermbg = object_to_color(dict-&gt;ctermbg, &quot;ctermbg&quot;, false, err);</a>
<a name="ln1069">    if (ERROR_SET(err)) {</a>
<a name="ln1070">      return hlattrs;</a>
<a name="ln1071">    }</a>
<a name="ln1072">  }</a>
<a name="ln1073"> </a>
<a name="ln1074">  if (use_rgb) {</a>
<a name="ln1075">    // apply gui mask as default for cterm mask</a>
<a name="ln1076">    if (!cterm_mask_provided) {</a>
<a name="ln1077">      cterm_mask = mask;</a>
<a name="ln1078">    }</a>
<a name="ln1079">    hlattrs.rgb_ae_attr = mask;</a>
<a name="ln1080">    hlattrs.rgb_bg_color = bg;</a>
<a name="ln1081">    hlattrs.rgb_fg_color = fg;</a>
<a name="ln1082">    hlattrs.rgb_sp_color = sp;</a>
<a name="ln1083">    hlattrs.hl_blend = blend;</a>
<a name="ln1084">    hlattrs.cterm_bg_color = ctermbg == -1 ? 0 : ctermbg + 1;</a>
<a name="ln1085">    hlattrs.cterm_fg_color = ctermfg == -1 ? 0 : ctermfg + 1;</a>
<a name="ln1086">    hlattrs.cterm_ae_attr = cterm_mask;</a>
<a name="ln1087">  } else {</a>
<a name="ln1088">    hlattrs.cterm_bg_color = bg == -1 ? 0 : bg + 1;</a>
<a name="ln1089">    hlattrs.cterm_fg_color = fg == -1 ? 0 : fg + 1;</a>
<a name="ln1090">    hlattrs.cterm_ae_attr = mask;</a>
<a name="ln1091">  }</a>
<a name="ln1092"> </a>
<a name="ln1093">  return hlattrs;</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">int object_to_color(Object val, char *key, bool rgb, Error *err)</a>
<a name="ln1097">{</a>
<a name="ln1098">  if (val.type == kObjectTypeInteger) {</a>
<a name="ln1099">    return (int)val.data.integer;</a>
<a name="ln1100">  } else if (val.type == kObjectTypeString) {</a>
<a name="ln1101">    String str = val.data.string;</a>
<a name="ln1102">    // TODO(bfredl): be more fancy with &quot;bg&quot;, &quot;fg&quot; etc</a>
<a name="ln1103">    if (!str.size || STRICMP(str.data, &quot;NONE&quot;) == 0) {</a>
<a name="ln1104">      return -1;</a>
<a name="ln1105">    }</a>
<a name="ln1106">    int color;</a>
<a name="ln1107">    if (rgb) {</a>
<a name="ln1108">      int dummy;</a>
<a name="ln1109">      color = name_to_color(str.data, &amp;dummy);</a>
<a name="ln1110">    } else {</a>
<a name="ln1111">      color = name_to_ctermcolor(str.data);</a>
<a name="ln1112">    }</a>
<a name="ln1113">    VALIDATE_S((color &gt;= 0), &quot;highlight color&quot;, str.data, {</a>
<a name="ln1114">      return color;</a>
<a name="ln1115">    });</a>
<a name="ln1116">    return color;</a>
<a name="ln1117">  } else {</a>
<a name="ln1118">    VALIDATE_EXP(false, key, &quot;String or Integer&quot;, NULL, {</a>
<a name="ln1119">      return 0;</a>
<a name="ln1120">    });</a>
<a name="ln1121">  }</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">Array hl_inspect(int attr)</a>
<a name="ln1125">{</a>
<a name="ln1126">  // TODO(bfredl): use arena allocation</a>
<a name="ln1127">  Array ret = ARRAY_DICT_INIT;</a>
<a name="ln1128">  if (hlstate_active) {</a>
<a name="ln1129">    hl_inspect_impl(&amp;ret, attr);</a>
<a name="ln1130">  }</a>
<a name="ln1131">  return ret;</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">static void hl_inspect_impl(Array *arr, int attr)</a>
<a name="ln1135">{</a>
<a name="ln1136">  Dictionary item = ARRAY_DICT_INIT;</a>
<a name="ln1137">  if (attr &lt;= 0 || attr &gt;= (int)kv_size(attr_entries)) {</a>
<a name="ln1138">    return;</a>
<a name="ln1139">  }</a>
<a name="ln1140"> </a>
<a name="ln1141">  HlEntry e = kv_A(attr_entries, attr);</a>
<a name="ln1142">  switch (e.kind) {</a>
<a name="ln1143">  case kHlSyntax:</a>
<a name="ln1144">    PUT(item, &quot;kind&quot;, CSTR_TO_OBJ(&quot;syntax&quot;));</a>
<a name="ln1145">    PUT(item, &quot;hi_name&quot;,</a>
<a name="ln1146">        CSTR_TO_OBJ(syn_id2name(e.id1)));</a>
<a name="ln1147">    break;</a>
<a name="ln1148"> </a>
<a name="ln1149">  case kHlUI:</a>
<a name="ln1150">    PUT(item, &quot;kind&quot;, CSTR_TO_OBJ(&quot;ui&quot;));</a>
<a name="ln1151">    const char *ui_name = (e.id1 == -1) ? &quot;Normal&quot; : hlf_names[e.id1];</a>
<a name="ln1152">    PUT(item, &quot;ui_name&quot;, CSTR_TO_OBJ(ui_name));</a>
<a name="ln1153">    PUT(item, &quot;hi_name&quot;,</a>
<a name="ln1154">        CSTR_TO_OBJ(syn_id2name(e.id2)));</a>
<a name="ln1155">    break;</a>
<a name="ln1156"> </a>
<a name="ln1157">  case kHlTerminal:</a>
<a name="ln1158">    PUT(item, &quot;kind&quot;, CSTR_TO_OBJ(&quot;term&quot;));</a>
<a name="ln1159">    break;</a>
<a name="ln1160"> </a>
<a name="ln1161">  case kHlCombine:</a>
<a name="ln1162">  case kHlBlend:</a>
<a name="ln1163">  case kHlBlendThrough:</a>
<a name="ln1164">    // attribute combination is associative, so flatten to an array</a>
<a name="ln1165">    hl_inspect_impl(arr, e.id1);</a>
<a name="ln1166">    hl_inspect_impl(arr, e.id2);</a>
<a name="ln1167">    return;</a>
<a name="ln1168"> </a>
<a name="ln1169">  case kHlUnknown:</a>
<a name="ln1170">    return;</a>
<a name="ln1171">  }</a>
<a name="ln1172">  PUT(item, &quot;id&quot;, INTEGER_OBJ(attr));</a>
<a name="ln1173">  ADD(*arr, DICTIONARY_OBJ(item));</a>
<a name="ln1174">}</a>
</code></pre>
<div class="balloon" rel="339"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!wp-&gt;w_ns_hl_attr' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>