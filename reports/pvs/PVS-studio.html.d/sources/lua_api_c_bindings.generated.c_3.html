<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>lua_api_c_bindings.generated.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3">#include &lt;lua.h&gt;</a>
<a name="ln4">#include &lt;lualib.h&gt;</a>
<a name="ln5">#include &lt;lauxlib.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln8">#include &quot;nvim/ex_getln.h&quot;</a>
<a name="ln9">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln10">#include &quot;nvim/api/private/defs.h&quot;</a>
<a name="ln11">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln12">#include &quot;nvim/api/private/dispatch.h&quot;</a>
<a name="ln13">#include &quot;nvim/lua/converter.h&quot;</a>
<a name="ln14">#include &quot;nvim/lua/executor.h&quot;</a>
<a name="ln15">#include &quot;nvim/memory.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;nvim/api/autocmd.h&quot;</a>
<a name="ln19">#include &quot;nvim/api/buffer.h&quot;</a>
<a name="ln20">#include &quot;nvim/api/command.h&quot;</a>
<a name="ln21">#include &quot;nvim/api/deprecated.h&quot;</a>
<a name="ln22">#include &quot;nvim/api/extmark.h&quot;</a>
<a name="ln23">#include &quot;nvim/api/keysets.h&quot;</a>
<a name="ln24">#include &quot;nvim/api/options.h&quot;</a>
<a name="ln25">#include &quot;nvim/api/tabpage.h&quot;</a>
<a name="ln26">#include &quot;nvim/api/ui.h&quot;</a>
<a name="ln27">#include &quot;nvim/api/vim.h&quot;</a>
<a name="ln28">#include &quot;nvim/api/vimscript.h&quot;</a>
<a name="ln29">#include &quot;nvim/api/win_config.h&quot;</a>
<a name="ln30">#include &quot;nvim/api/window.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">static int nlua_api_nvim_get_autocmds(lua_State *lstate)</a>
<a name="ln33">{</a>
<a name="ln34">  Error err = ERROR_INIT;</a>
<a name="ln35">  char *err_param = 0;</a>
<a name="ln36">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln37">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln38">    goto exit_0;</a>
<a name="ln39">  }</a>
<a name="ln40">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln41">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_autocmds&quot;);</a>
<a name="ln42">  }</a>
<a name="ln43">    KeyDict_get_autocmds arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_get_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln44">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln45">  }</a>
<a name="ln46"> </a>
<a name="ln47">  const Array ret = nvim_get_autocmds(&amp;arg1, &amp;err);</a>
<a name="ln48">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln49">api_free_array(ret);</a>
<a name="ln50"> </a>
<a name="ln51">exit_1:</a>
<a name="ln52">  api_free_keydict_get_autocmds(&amp;arg1);</a>
<a name="ln53"> </a>
<a name="ln54">exit_0:</a>
<a name="ln55">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln56">    luaL_where(lstate, 1);</a>
<a name="ln57">    if (err_param) {</a>
<a name="ln58">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln59">      lua_pushstring(lstate, err_param);</a>
<a name="ln60">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln61">    }</a>
<a name="ln62">    lua_pushstring(lstate, err.msg);</a>
<a name="ln63">    api_clear_error(&amp;err);</a>
<a name="ln64">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln65">    return lua_error(lstate);</a>
<a name="ln66">  }</a>
<a name="ln67"> </a>
<a name="ln68">  return 1;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">static int nlua_api_nvim_create_autocmd(lua_State *lstate)</a>
<a name="ln72">{</a>
<a name="ln73">  Error err = ERROR_INIT;</a>
<a name="ln74">  char *err_param = 0;</a>
<a name="ln75">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln76">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln77">    goto exit_0;</a>
<a name="ln78">  }</a>
<a name="ln79">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln80">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_autocmd&quot;);</a>
<a name="ln81">  }</a>
<a name="ln82">    KeyDict_create_autocmd arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_create_autocmd_get_field, &amp;err_param, &amp;err);</a>
<a name="ln83">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln84">  }</a>
<a name="ln85"> </a>
<a name="ln86">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln87">  if (ERROR_SET(&amp;err)) {      err_param = &quot;event&quot;;      goto exit_1;</a>
<a name="ln88">  }</a>
<a name="ln89"> </a>
<a name="ln90">  const Integer ret = nvim_create_autocmd(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln91">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln92">api_free_integer(ret);</a>
<a name="ln93"> </a>
<a name="ln94">  api_free_object(arg1);</a>
<a name="ln95">exit_1:</a>
<a name="ln96">  api_free_keydict_create_autocmd(&amp;arg2);</a>
<a name="ln97"> </a>
<a name="ln98">exit_0:</a>
<a name="ln99">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln100">    luaL_where(lstate, 1);</a>
<a name="ln101">    if (err_param) {</a>
<a name="ln102">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln103">      lua_pushstring(lstate, err_param);</a>
<a name="ln104">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln105">    }</a>
<a name="ln106">    lua_pushstring(lstate, err.msg);</a>
<a name="ln107">    api_clear_error(&amp;err);</a>
<a name="ln108">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln109">    return lua_error(lstate);</a>
<a name="ln110">  }</a>
<a name="ln111"> </a>
<a name="ln112">  return 1;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">static int nlua_api_nvim_del_autocmd(lua_State *lstate)</a>
<a name="ln116">{</a>
<a name="ln117">  Error err = ERROR_INIT;</a>
<a name="ln118">  char *err_param = 0;</a>
<a name="ln119">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln120">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln121">    goto exit_0;</a>
<a name="ln122">  }</a>
<a name="ln123">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln124">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_autocmd&quot;);</a>
<a name="ln125">  }</a>
<a name="ln126">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln127">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  nvim_del_autocmd(arg1, &amp;err);</a>
<a name="ln131"> </a>
<a name="ln132">  api_free_integer(arg1);</a>
<a name="ln133"> </a>
<a name="ln134">exit_0:</a>
<a name="ln135">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln136">    luaL_where(lstate, 1);</a>
<a name="ln137">    if (err_param) {</a>
<a name="ln138">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln139">      lua_pushstring(lstate, err_param);</a>
<a name="ln140">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln141">    }</a>
<a name="ln142">    lua_pushstring(lstate, err.msg);</a>
<a name="ln143">    api_clear_error(&amp;err);</a>
<a name="ln144">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln145">    return lua_error(lstate);</a>
<a name="ln146">  }</a>
<a name="ln147"> </a>
<a name="ln148">  return 0;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static int nlua_api_nvim_clear_autocmds(lua_State *lstate)</a>
<a name="ln152">{</a>
<a name="ln153">  Error err = ERROR_INIT;</a>
<a name="ln154">  char *err_param = 0;</a>
<a name="ln155">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln156">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln157">    goto exit_0;</a>
<a name="ln158">  }</a>
<a name="ln159">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln160">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_clear_autocmds&quot;);</a>
<a name="ln161">  }</a>
<a name="ln162">    KeyDict_clear_autocmds arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_clear_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln163">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  nvim_clear_autocmds(&amp;arg1, &amp;err);</a>
<a name="ln167"> </a>
<a name="ln168">exit_1:</a>
<a name="ln169">  api_free_keydict_clear_autocmds(&amp;arg1);</a>
<a name="ln170"> </a>
<a name="ln171">exit_0:</a>
<a name="ln172">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln173">    luaL_where(lstate, 1);</a>
<a name="ln174">    if (err_param) {</a>
<a name="ln175">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln176">      lua_pushstring(lstate, err_param);</a>
<a name="ln177">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln178">    }</a>
<a name="ln179">    lua_pushstring(lstate, err.msg);</a>
<a name="ln180">    api_clear_error(&amp;err);</a>
<a name="ln181">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln182">    return lua_error(lstate);</a>
<a name="ln183">  }</a>
<a name="ln184"> </a>
<a name="ln185">  return 0;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static int nlua_api_nvim_create_augroup(lua_State *lstate)</a>
<a name="ln189">{</a>
<a name="ln190">  Error err = ERROR_INIT;</a>
<a name="ln191">  char *err_param = 0;</a>
<a name="ln192">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln193">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln194">    goto exit_0;</a>
<a name="ln195">  }</a>
<a name="ln196">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln197">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_augroup&quot;);</a>
<a name="ln198">  }</a>
<a name="ln199">    KeyDict_create_augroup arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_create_augroup_get_field, &amp;err_param, &amp;err);</a>
<a name="ln200">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln204">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln205">  }</a>
<a name="ln206"> </a>
<a name="ln207">  const Integer ret = nvim_create_augroup(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln208">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln209">api_free_integer(ret);</a>
<a name="ln210"> </a>
<a name="ln211">  api_free_string(arg1);</a>
<a name="ln212">exit_1:</a>
<a name="ln213">  api_free_keydict_create_augroup(&amp;arg2);</a>
<a name="ln214"> </a>
<a name="ln215">exit_0:</a>
<a name="ln216">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln217">    luaL_where(lstate, 1);</a>
<a name="ln218">    if (err_param) {</a>
<a name="ln219">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln220">      lua_pushstring(lstate, err_param);</a>
<a name="ln221">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln222">    }</a>
<a name="ln223">    lua_pushstring(lstate, err.msg);</a>
<a name="ln224">    api_clear_error(&amp;err);</a>
<a name="ln225">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln226">    return lua_error(lstate);</a>
<a name="ln227">  }</a>
<a name="ln228"> </a>
<a name="ln229">  return 1;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static int nlua_api_nvim_del_augroup_by_id(lua_State *lstate)</a>
<a name="ln233">{</a>
<a name="ln234">  Error err = ERROR_INIT;</a>
<a name="ln235">  char *err_param = 0;</a>
<a name="ln236">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln237">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln238">    goto exit_0;</a>
<a name="ln239">  }</a>
<a name="ln240">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln241">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_augroup_by_id&quot;);</a>
<a name="ln242">  }</a>
<a name="ln243">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln244">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln245">  }</a>
<a name="ln246"> </a>
<a name="ln247">  nvim_del_augroup_by_id(arg1, &amp;err);</a>
<a name="ln248"> </a>
<a name="ln249">  api_free_integer(arg1);</a>
<a name="ln250"> </a>
<a name="ln251">exit_0:</a>
<a name="ln252">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln253">    luaL_where(lstate, 1);</a>
<a name="ln254">    if (err_param) {</a>
<a name="ln255">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln256">      lua_pushstring(lstate, err_param);</a>
<a name="ln257">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln258">    }</a>
<a name="ln259">    lua_pushstring(lstate, err.msg);</a>
<a name="ln260">    api_clear_error(&amp;err);</a>
<a name="ln261">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln262">    return lua_error(lstate);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  return 0;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">static int nlua_api_nvim_del_augroup_by_name(lua_State *lstate)</a>
<a name="ln269">{</a>
<a name="ln270">  Error err = ERROR_INIT;</a>
<a name="ln271">  char *err_param = 0;</a>
<a name="ln272">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln273">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln274">    goto exit_0;</a>
<a name="ln275">  }</a>
<a name="ln276">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln277">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_augroup_by_name&quot;);</a>
<a name="ln278">  }</a>
<a name="ln279">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln280">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  nvim_del_augroup_by_name(arg1, &amp;err);</a>
<a name="ln284"> </a>
<a name="ln285">  api_free_string(arg1);</a>
<a name="ln286"> </a>
<a name="ln287">exit_0:</a>
<a name="ln288">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln289">    luaL_where(lstate, 1);</a>
<a name="ln290">    if (err_param) {</a>
<a name="ln291">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln292">      lua_pushstring(lstate, err_param);</a>
<a name="ln293">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln294">    }</a>
<a name="ln295">    lua_pushstring(lstate, err.msg);</a>
<a name="ln296">    api_clear_error(&amp;err);</a>
<a name="ln297">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln298">    return lua_error(lstate);</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  return 0;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">static int nlua_api_nvim_exec_autocmds(lua_State *lstate)</a>
<a name="ln305">{</a>
<a name="ln306">  Error err = ERROR_INIT;</a>
<a name="ln307">  char *err_param = 0;</a>
<a name="ln308">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln309">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln310">    goto exit_0;</a>
<a name="ln311">  }</a>
<a name="ln312">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln313">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec_autocmds&quot;);</a>
<a name="ln314">  }</a>
<a name="ln315">    KeyDict_exec_autocmds arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_exec_autocmds_get_field, &amp;err_param, &amp;err);</a>
<a name="ln316">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln320">  if (ERROR_SET(&amp;err)) {      err_param = &quot;event&quot;;      goto exit_1;</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  nvim_exec_autocmds(arg1, &amp;arg2, &amp;err);</a>
<a name="ln324"> </a>
<a name="ln325">  api_free_object(arg1);</a>
<a name="ln326">exit_1:</a>
<a name="ln327">  api_free_keydict_exec_autocmds(&amp;arg2);</a>
<a name="ln328"> </a>
<a name="ln329">exit_0:</a>
<a name="ln330">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln331">    luaL_where(lstate, 1);</a>
<a name="ln332">    if (err_param) {</a>
<a name="ln333">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln334">      lua_pushstring(lstate, err_param);</a>
<a name="ln335">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln336">    }</a>
<a name="ln337">    lua_pushstring(lstate, err.msg);</a>
<a name="ln338">    api_clear_error(&amp;err);</a>
<a name="ln339">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln340">    return lua_error(lstate);</a>
<a name="ln341">  }</a>
<a name="ln342"> </a>
<a name="ln343">  return 0;</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">static int nlua_api_nvim_buf_line_count(lua_State *lstate)</a>
<a name="ln347">{</a>
<a name="ln348">  Error err = ERROR_INIT;</a>
<a name="ln349">  char *err_param = 0;</a>
<a name="ln350">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln351">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln352">    goto exit_0;</a>
<a name="ln353">  }</a>
<a name="ln354">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln355">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_line_count&quot;);</a>
<a name="ln356">  }</a>
<a name="ln357">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln358">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln359">  }</a>
<a name="ln360"> </a>
<a name="ln361">  const Integer ret = nvim_buf_line_count(arg1, &amp;err);</a>
<a name="ln362">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln363">api_free_integer(ret);</a>
<a name="ln364"> </a>
<a name="ln365">  api_free_buffer(arg1);</a>
<a name="ln366"> </a>
<a name="ln367">exit_0:</a>
<a name="ln368">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln369">    luaL_where(lstate, 1);</a>
<a name="ln370">    if (err_param) {</a>
<a name="ln371">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln372">      lua_pushstring(lstate, err_param);</a>
<a name="ln373">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln374">    }</a>
<a name="ln375">    lua_pushstring(lstate, err.msg);</a>
<a name="ln376">    api_clear_error(&amp;err);</a>
<a name="ln377">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln378">    return lua_error(lstate);</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  return 1;</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static int nlua_api_nvim_buf_attach(lua_State *lstate)</a>
<a name="ln385">{</a>
<a name="ln386">  Error err = ERROR_INIT;</a>
<a name="ln387">  char *err_param = 0;</a>
<a name="ln388">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln389">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln390">    goto exit_0;</a>
<a name="ln391">  }</a>
<a name="ln392">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln393">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_attach&quot;);</a>
<a name="ln394">  }</a>
<a name="ln395">    const DictionaryOf(LuaRef) arg3 = nlua_pop_Dictionary(lstate, true, &amp;err);</a>
<a name="ln396">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln397">  }</a>
<a name="ln398"> </a>
<a name="ln399">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln400">  if (ERROR_SET(&amp;err)) {      err_param = &quot;send_buffer&quot;;      goto exit_1;</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln404">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  const Boolean ret = nvim_buf_attach(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln408">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln409">api_free_boolean(ret);</a>
<a name="ln410"> </a>
<a name="ln411">  api_free_buffer(arg1);</a>
<a name="ln412">exit_2:</a>
<a name="ln413">  api_free_boolean(arg2);</a>
<a name="ln414">exit_1:</a>
<a name="ln415">  api_free_dictionary(arg3);</a>
<a name="ln416"> </a>
<a name="ln417">exit_0:</a>
<a name="ln418">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln419">    luaL_where(lstate, 1);</a>
<a name="ln420">    if (err_param) {</a>
<a name="ln421">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln422">      lua_pushstring(lstate, err_param);</a>
<a name="ln423">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln424">    }</a>
<a name="ln425">    lua_pushstring(lstate, err.msg);</a>
<a name="ln426">    api_clear_error(&amp;err);</a>
<a name="ln427">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln428">    return lua_error(lstate);</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  return 1;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">static int nlua_api_nvim__buf_redraw_range(lua_State *lstate)</a>
<a name="ln435">{</a>
<a name="ln436">  Error err = ERROR_INIT;</a>
<a name="ln437">  char *err_param = 0;</a>
<a name="ln438">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln439">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln440">    goto exit_0;</a>
<a name="ln441">  }</a>
<a name="ln442">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln443">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_redraw_range&quot;);</a>
<a name="ln444">  }</a>
<a name="ln445">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln446">  if (ERROR_SET(&amp;err)) {      err_param = &quot;last&quot;;      goto exit_0;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln450">  if (ERROR_SET(&amp;err)) {      err_param = &quot;first&quot;;      goto exit_1;</a>
<a name="ln451">  }</a>
<a name="ln452"> </a>
<a name="ln453">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln454">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln455">  }</a>
<a name="ln456"> </a>
<a name="ln457">  nvim__buf_redraw_range(arg1, arg2, arg3, &amp;err);</a>
<a name="ln458"> </a>
<a name="ln459">  api_free_buffer(arg1);</a>
<a name="ln460">exit_2:</a>
<a name="ln461">  api_free_integer(arg2);</a>
<a name="ln462">exit_1:</a>
<a name="ln463">  api_free_integer(arg3);</a>
<a name="ln464"> </a>
<a name="ln465">exit_0:</a>
<a name="ln466">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln467">    luaL_where(lstate, 1);</a>
<a name="ln468">    if (err_param) {</a>
<a name="ln469">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln470">      lua_pushstring(lstate, err_param);</a>
<a name="ln471">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln472">    }</a>
<a name="ln473">    lua_pushstring(lstate, err.msg);</a>
<a name="ln474">    api_clear_error(&amp;err);</a>
<a name="ln475">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln476">    return lua_error(lstate);</a>
<a name="ln477">  }</a>
<a name="ln478"> </a>
<a name="ln479">  return 0;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">static int nlua_api_nvim_buf_get_lines(lua_State *lstate)</a>
<a name="ln483">{</a>
<a name="ln484">  Error err = ERROR_INIT;</a>
<a name="ln485">  char *err_param = 0;</a>
<a name="ln486">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln487">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln488">    goto exit_0;</a>
<a name="ln489">  }</a>
<a name="ln490">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln491">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_lines&quot;);</a>
<a name="ln492">  }</a>
<a name="ln493">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln494">  if (ERROR_SET(&amp;err)) {      err_param = &quot;strict_indexing&quot;;      goto exit_0;</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln498">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_1;</a>
<a name="ln499">  }</a>
<a name="ln500"> </a>
<a name="ln501">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln502">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_2;</a>
<a name="ln503">  }</a>
<a name="ln504"> </a>
<a name="ln505">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln506">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln507">  }</a>
<a name="ln508"> </a>
<a name="ln509">  const ArrayOf(String) ret = nvim_buf_get_lines(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, lstate, &amp;err);</a>
<a name="ln510">  if (lua_gettop(lstate) == 0) {</a>
<a name="ln511">    nlua_push_Array(lstate, ret, true);</a>
<a name="ln512">  }</a>
<a name="ln513">api_free_array(ret);</a>
<a name="ln514"> </a>
<a name="ln515">  api_free_buffer(arg1);</a>
<a name="ln516">exit_3:</a>
<a name="ln517">  api_free_integer(arg2);</a>
<a name="ln518">exit_2:</a>
<a name="ln519">  api_free_integer(arg3);</a>
<a name="ln520">exit_1:</a>
<a name="ln521">  api_free_boolean(arg4);</a>
<a name="ln522"> </a>
<a name="ln523">exit_0:</a>
<a name="ln524">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln525">    luaL_where(lstate, 1);</a>
<a name="ln526">    if (err_param) {</a>
<a name="ln527">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln528">      lua_pushstring(lstate, err_param);</a>
<a name="ln529">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln530">    }</a>
<a name="ln531">    lua_pushstring(lstate, err.msg);</a>
<a name="ln532">    api_clear_error(&amp;err);</a>
<a name="ln533">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln534">    return lua_error(lstate);</a>
<a name="ln535">  }</a>
<a name="ln536"> </a>
<a name="ln537">  return 1;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">static int nlua_api_nvim_buf_set_lines(lua_State *lstate)</a>
<a name="ln541">{</a>
<a name="ln542">  Error err = ERROR_INIT;</a>
<a name="ln543">  char *err_param = 0;</a>
<a name="ln544">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln545">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln546">    goto exit_0;</a>
<a name="ln547">  }</a>
<a name="ln548">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln549">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_lines&quot;);</a>
<a name="ln550">  }</a>
<a name="ln551">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln552">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln553">    goto exit_0;</a>
<a name="ln554">  }</a>
<a name="ln555">    const ArrayOf(String) arg5 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln556">  if (ERROR_SET(&amp;err)) {      err_param = &quot;replacement&quot;;      goto exit_0;</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln560">  if (ERROR_SET(&amp;err)) {      err_param = &quot;strict_indexing&quot;;      goto exit_1;</a>
<a name="ln561">  }</a>
<a name="ln562"> </a>
<a name="ln563">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln564">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_2;</a>
<a name="ln565">  }</a>
<a name="ln566"> </a>
<a name="ln567">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln568">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_3;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln572">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln573">  }</a>
<a name="ln574"> </a>
<a name="ln575">  nvim_buf_set_lines(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln576"> </a>
<a name="ln577">  api_free_buffer(arg1);</a>
<a name="ln578">exit_4:</a>
<a name="ln579">  api_free_integer(arg2);</a>
<a name="ln580">exit_3:</a>
<a name="ln581">  api_free_integer(arg3);</a>
<a name="ln582">exit_2:</a>
<a name="ln583">  api_free_boolean(arg4);</a>
<a name="ln584">exit_1:</a>
<a name="ln585">  api_free_array(arg5);</a>
<a name="ln586"> </a>
<a name="ln587">exit_0:</a>
<a name="ln588">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln589">    luaL_where(lstate, 1);</a>
<a name="ln590">    if (err_param) {</a>
<a name="ln591">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln592">      lua_pushstring(lstate, err_param);</a>
<a name="ln593">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln594">    }</a>
<a name="ln595">    lua_pushstring(lstate, err.msg);</a>
<a name="ln596">    api_clear_error(&amp;err);</a>
<a name="ln597">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln598">    return lua_error(lstate);</a>
<a name="ln599">  }</a>
<a name="ln600"> </a>
<a name="ln601">  return 0;</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">static int nlua_api_nvim_buf_set_text(lua_State *lstate)</a>
<a name="ln605">{</a>
<a name="ln606">  Error err = ERROR_INIT;</a>
<a name="ln607">  char *err_param = 0;</a>
<a name="ln608">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln609">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln610">    goto exit_0;</a>
<a name="ln611">  }</a>
<a name="ln612">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln613">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_text&quot;);</a>
<a name="ln614">  }</a>
<a name="ln615">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln616">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln617">    goto exit_0;</a>
<a name="ln618">  }</a>
<a name="ln619">    const ArrayOf(String) arg6 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln620">  if (ERROR_SET(&amp;err)) {      err_param = &quot;replacement&quot;;      goto exit_0;</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln624">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_col&quot;;      goto exit_1;</a>
<a name="ln625">  }</a>
<a name="ln626"> </a>
<a name="ln627">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln628">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_row&quot;;      goto exit_2;</a>
<a name="ln629">  }</a>
<a name="ln630"> </a>
<a name="ln631">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln632">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_col&quot;;      goto exit_3;</a>
<a name="ln633">  }</a>
<a name="ln634"> </a>
<a name="ln635">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln636">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_row&quot;;      goto exit_4;</a>
<a name="ln637">  }</a>
<a name="ln638"> </a>
<a name="ln639">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln640">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln641">  }</a>
<a name="ln642"> </a>
<a name="ln643">  nvim_buf_set_text(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln644"> </a>
<a name="ln645">  api_free_buffer(arg1);</a>
<a name="ln646">exit_5:</a>
<a name="ln647">  api_free_integer(arg2);</a>
<a name="ln648">exit_4:</a>
<a name="ln649">  api_free_integer(arg3);</a>
<a name="ln650">exit_3:</a>
<a name="ln651">  api_free_integer(arg4);</a>
<a name="ln652">exit_2:</a>
<a name="ln653">  api_free_integer(arg5);</a>
<a name="ln654">exit_1:</a>
<a name="ln655">  api_free_array(arg6);</a>
<a name="ln656"> </a>
<a name="ln657">exit_0:</a>
<a name="ln658">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln659">    luaL_where(lstate, 1);</a>
<a name="ln660">    if (err_param) {</a>
<a name="ln661">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln662">      lua_pushstring(lstate, err_param);</a>
<a name="ln663">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln664">    }</a>
<a name="ln665">    lua_pushstring(lstate, err.msg);</a>
<a name="ln666">    api_clear_error(&amp;err);</a>
<a name="ln667">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln668">    return lua_error(lstate);</a>
<a name="ln669">  }</a>
<a name="ln670"> </a>
<a name="ln671">  return 0;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">static int nlua_api_nvim_buf_get_text(lua_State *lstate)</a>
<a name="ln675">{</a>
<a name="ln676">  Error err = ERROR_INIT;</a>
<a name="ln677">  char *err_param = 0;</a>
<a name="ln678">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln679">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln680">    goto exit_0;</a>
<a name="ln681">  }</a>
<a name="ln682">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln683">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_text&quot;);</a>
<a name="ln684">  }</a>
<a name="ln685">    const Dictionary arg6 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln686">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln687">  }</a>
<a name="ln688"> </a>
<a name="ln689">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln690">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_col&quot;;      goto exit_1;</a>
<a name="ln691">  }</a>
<a name="ln692"> </a>
<a name="ln693">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln694">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end_row&quot;;      goto exit_2;</a>
<a name="ln695">  }</a>
<a name="ln696"> </a>
<a name="ln697">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln698">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_col&quot;;      goto exit_3;</a>
<a name="ln699">  }</a>
<a name="ln700"> </a>
<a name="ln701">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln702">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start_row&quot;;      goto exit_4;</a>
<a name="ln703">  }</a>
<a name="ln704"> </a>
<a name="ln705">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln706">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln707">  }</a>
<a name="ln708"> </a>
<a name="ln709">  const ArrayOf(String) ret = nvim_buf_get_text(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, arg5, arg6, lstate, &amp;err);</a>
<a name="ln710">  if (lua_gettop(lstate) == 0) {</a>
<a name="ln711">    nlua_push_Array(lstate, ret, true);</a>
<a name="ln712">  }</a>
<a name="ln713">api_free_array(ret);</a>
<a name="ln714"> </a>
<a name="ln715">  api_free_buffer(arg1);</a>
<a name="ln716">exit_5:</a>
<a name="ln717">  api_free_integer(arg2);</a>
<a name="ln718">exit_4:</a>
<a name="ln719">  api_free_integer(arg3);</a>
<a name="ln720">exit_3:</a>
<a name="ln721">  api_free_integer(arg4);</a>
<a name="ln722">exit_2:</a>
<a name="ln723">  api_free_integer(arg5);</a>
<a name="ln724">exit_1:</a>
<a name="ln725">  api_free_dictionary(arg6);</a>
<a name="ln726"> </a>
<a name="ln727">exit_0:</a>
<a name="ln728">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln729">    luaL_where(lstate, 1);</a>
<a name="ln730">    if (err_param) {</a>
<a name="ln731">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln732">      lua_pushstring(lstate, err_param);</a>
<a name="ln733">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln734">    }</a>
<a name="ln735">    lua_pushstring(lstate, err.msg);</a>
<a name="ln736">    api_clear_error(&amp;err);</a>
<a name="ln737">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln738">    return lua_error(lstate);</a>
<a name="ln739">  }</a>
<a name="ln740"> </a>
<a name="ln741">  return 1;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">static int nlua_api_nvim_buf_get_offset(lua_State *lstate)</a>
<a name="ln745">{</a>
<a name="ln746">  Error err = ERROR_INIT;</a>
<a name="ln747">  char *err_param = 0;</a>
<a name="ln748">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln749">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln750">    goto exit_0;</a>
<a name="ln751">  }</a>
<a name="ln752">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln753">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_offset&quot;);</a>
<a name="ln754">  }</a>
<a name="ln755">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln756">  if (ERROR_SET(&amp;err)) {      err_param = &quot;index&quot;;      goto exit_0;</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln760">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln761">  }</a>
<a name="ln762"> </a>
<a name="ln763">  const Integer ret = nvim_buf_get_offset(arg1, arg2, &amp;err);</a>
<a name="ln764">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln765">api_free_integer(ret);</a>
<a name="ln766"> </a>
<a name="ln767">  api_free_buffer(arg1);</a>
<a name="ln768">exit_1:</a>
<a name="ln769">  api_free_integer(arg2);</a>
<a name="ln770"> </a>
<a name="ln771">exit_0:</a>
<a name="ln772">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln773">    luaL_where(lstate, 1);</a>
<a name="ln774">    if (err_param) {</a>
<a name="ln775">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln776">      lua_pushstring(lstate, err_param);</a>
<a name="ln777">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln778">    }</a>
<a name="ln779">    lua_pushstring(lstate, err.msg);</a>
<a name="ln780">    api_clear_error(&amp;err);</a>
<a name="ln781">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln782">    return lua_error(lstate);</a>
<a name="ln783">  }</a>
<a name="ln784"> </a>
<a name="ln785">  return 1;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">static int nlua_api_nvim_buf_get_var(lua_State *lstate)</a>
<a name="ln789">{</a>
<a name="ln790">  Error err = ERROR_INIT;</a>
<a name="ln791">  char *err_param = 0;</a>
<a name="ln792">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln793">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln794">    goto exit_0;</a>
<a name="ln795">  }</a>
<a name="ln796">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln797">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_var&quot;);</a>
<a name="ln798">  }</a>
<a name="ln799">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln800">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln801">  }</a>
<a name="ln802"> </a>
<a name="ln803">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln804">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln805">  }</a>
<a name="ln806"> </a>
<a name="ln807">  const Object ret = nvim_buf_get_var(arg1, arg2, &amp;err);</a>
<a name="ln808">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln809">api_free_object(ret);</a>
<a name="ln810"> </a>
<a name="ln811">  api_free_buffer(arg1);</a>
<a name="ln812">exit_1:</a>
<a name="ln813">  api_free_string(arg2);</a>
<a name="ln814"> </a>
<a name="ln815">exit_0:</a>
<a name="ln816">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln817">    luaL_where(lstate, 1);</a>
<a name="ln818">    if (err_param) {</a>
<a name="ln819">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln820">      lua_pushstring(lstate, err_param);</a>
<a name="ln821">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln822">    }</a>
<a name="ln823">    lua_pushstring(lstate, err.msg);</a>
<a name="ln824">    api_clear_error(&amp;err);</a>
<a name="ln825">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln826">    return lua_error(lstate);</a>
<a name="ln827">  }</a>
<a name="ln828"> </a>
<a name="ln829">  return 1;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static int nlua_api_nvim_buf_get_changedtick(lua_State *lstate)</a>
<a name="ln833">{</a>
<a name="ln834">  Error err = ERROR_INIT;</a>
<a name="ln835">  char *err_param = 0;</a>
<a name="ln836">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln837">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln838">    goto exit_0;</a>
<a name="ln839">  }</a>
<a name="ln840">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln841">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_changedtick&quot;);</a>
<a name="ln842">  }</a>
<a name="ln843">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln844">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln845">  }</a>
<a name="ln846"> </a>
<a name="ln847">  const Integer ret = nvim_buf_get_changedtick(arg1, &amp;err);</a>
<a name="ln848">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln849">api_free_integer(ret);</a>
<a name="ln850"> </a>
<a name="ln851">  api_free_buffer(arg1);</a>
<a name="ln852"> </a>
<a name="ln853">exit_0:</a>
<a name="ln854">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln855">    luaL_where(lstate, 1);</a>
<a name="ln856">    if (err_param) {</a>
<a name="ln857">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln858">      lua_pushstring(lstate, err_param);</a>
<a name="ln859">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln860">    }</a>
<a name="ln861">    lua_pushstring(lstate, err.msg);</a>
<a name="ln862">    api_clear_error(&amp;err);</a>
<a name="ln863">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln864">    return lua_error(lstate);</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  return 1;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">static int nlua_api_nvim_buf_get_keymap(lua_State *lstate)</a>
<a name="ln871">{</a>
<a name="ln872">  Error err = ERROR_INIT;</a>
<a name="ln873">  char *err_param = 0;</a>
<a name="ln874">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln875">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln876">    goto exit_0;</a>
<a name="ln877">  }</a>
<a name="ln878">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln879">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_keymap&quot;);</a>
<a name="ln880">  }</a>
<a name="ln881">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln882">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_0;</a>
<a name="ln883">  }</a>
<a name="ln884"> </a>
<a name="ln885">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln886">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889">  const ArrayOf(Dictionary) ret = nvim_buf_get_keymap(arg1, arg2, &amp;err);</a>
<a name="ln890">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln891">api_free_array(ret);</a>
<a name="ln892"> </a>
<a name="ln893">  api_free_buffer(arg1);</a>
<a name="ln894">exit_1:</a>
<a name="ln895">  api_free_string(arg2);</a>
<a name="ln896"> </a>
<a name="ln897">exit_0:</a>
<a name="ln898">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln899">    luaL_where(lstate, 1);</a>
<a name="ln900">    if (err_param) {</a>
<a name="ln901">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln902">      lua_pushstring(lstate, err_param);</a>
<a name="ln903">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln904">    }</a>
<a name="ln905">    lua_pushstring(lstate, err.msg);</a>
<a name="ln906">    api_clear_error(&amp;err);</a>
<a name="ln907">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln908">    return lua_error(lstate);</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911">  return 1;</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">static int nlua_api_nvim_buf_set_keymap(lua_State *lstate)</a>
<a name="ln915">{</a>
<a name="ln916">  Error err = ERROR_INIT;</a>
<a name="ln917">  char *err_param = 0;</a>
<a name="ln918">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln919">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln920">    goto exit_0;</a>
<a name="ln921">  }</a>
<a name="ln922">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln923">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_keymap&quot;);</a>
<a name="ln924">  }</a>
<a name="ln925">    KeyDict_keymap arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_keymap_get_field, &amp;err_param, &amp;err);</a>
<a name="ln926">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln927">  }</a>
<a name="ln928"> </a>
<a name="ln929">    const String arg4 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln930">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rhs&quot;;      goto exit_1;</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln934">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_2;</a>
<a name="ln935">  }</a>
<a name="ln936"> </a>
<a name="ln937">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln938">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_3;</a>
<a name="ln939">  }</a>
<a name="ln940"> </a>
<a name="ln941">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln942">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln943">  }</a>
<a name="ln944"> </a>
<a name="ln945">  nvim_buf_set_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln946"> </a>
<a name="ln947">  api_free_buffer(arg1);</a>
<a name="ln948">exit_4:</a>
<a name="ln949">  api_free_string(arg2);</a>
<a name="ln950">exit_3:</a>
<a name="ln951">  api_free_string(arg3);</a>
<a name="ln952">exit_2:</a>
<a name="ln953">  api_free_string(arg4);</a>
<a name="ln954">exit_1:</a>
<a name="ln955">  api_free_keydict_keymap(&amp;arg5);</a>
<a name="ln956"> </a>
<a name="ln957">exit_0:</a>
<a name="ln958">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln959">    luaL_where(lstate, 1);</a>
<a name="ln960">    if (err_param) {</a>
<a name="ln961">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln962">      lua_pushstring(lstate, err_param);</a>
<a name="ln963">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln964">    }</a>
<a name="ln965">    lua_pushstring(lstate, err.msg);</a>
<a name="ln966">    api_clear_error(&amp;err);</a>
<a name="ln967">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln968">    return lua_error(lstate);</a>
<a name="ln969">  }</a>
<a name="ln970"> </a>
<a name="ln971">  return 0;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static int nlua_api_nvim_buf_del_keymap(lua_State *lstate)</a>
<a name="ln975">{</a>
<a name="ln976">  Error err = ERROR_INIT;</a>
<a name="ln977">  char *err_param = 0;</a>
<a name="ln978">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln979">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln980">    goto exit_0;</a>
<a name="ln981">  }</a>
<a name="ln982">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln983">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_keymap&quot;);</a>
<a name="ln984">  }</a>
<a name="ln985">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln986">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_0;</a>
<a name="ln987">  }</a>
<a name="ln988"> </a>
<a name="ln989">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln990">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln991">  }</a>
<a name="ln992"> </a>
<a name="ln993">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln994">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln995">  }</a>
<a name="ln996"> </a>
<a name="ln997">  nvim_buf_del_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln998"> </a>
<a name="ln999">  api_free_buffer(arg1);</a>
<a name="ln1000">exit_2:</a>
<a name="ln1001">  api_free_string(arg2);</a>
<a name="ln1002">exit_1:</a>
<a name="ln1003">  api_free_string(arg3);</a>
<a name="ln1004"> </a>
<a name="ln1005">exit_0:</a>
<a name="ln1006">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1007">    luaL_where(lstate, 1);</a>
<a name="ln1008">    if (err_param) {</a>
<a name="ln1009">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1010">      lua_pushstring(lstate, err_param);</a>
<a name="ln1011">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1012">    }</a>
<a name="ln1013">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1014">    api_clear_error(&amp;err);</a>
<a name="ln1015">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1016">    return lua_error(lstate);</a>
<a name="ln1017">  }</a>
<a name="ln1018"> </a>
<a name="ln1019">  return 0;</a>
<a name="ln1020">}</a>
<a name="ln1021"> </a>
<a name="ln1022">static int nlua_api_nvim_buf_set_var(lua_State *lstate)</a>
<a name="ln1023">{</a>
<a name="ln1024">  Error err = ERROR_INIT;</a>
<a name="ln1025">  char *err_param = 0;</a>
<a name="ln1026">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln1027">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln1028">    goto exit_0;</a>
<a name="ln1029">  }</a>
<a name="ln1030">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1031">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_var&quot;);</a>
<a name="ln1032">  }</a>
<a name="ln1033">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1034">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln1035">  }</a>
<a name="ln1036"> </a>
<a name="ln1037">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1038">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln1039">  }</a>
<a name="ln1040"> </a>
<a name="ln1041">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1042">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln1043">  }</a>
<a name="ln1044"> </a>
<a name="ln1045">  nvim_buf_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln1046"> </a>
<a name="ln1047">  api_free_buffer(arg1);</a>
<a name="ln1048">exit_2:</a>
<a name="ln1049">  api_free_string(arg2);</a>
<a name="ln1050">exit_1:</a>
<a name="ln1051">  api_free_object(arg3);</a>
<a name="ln1052"> </a>
<a name="ln1053">exit_0:</a>
<a name="ln1054">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1055">    luaL_where(lstate, 1);</a>
<a name="ln1056">    if (err_param) {</a>
<a name="ln1057">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1058">      lua_pushstring(lstate, err_param);</a>
<a name="ln1059">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1060">    }</a>
<a name="ln1061">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1062">    api_clear_error(&amp;err);</a>
<a name="ln1063">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1064">    return lua_error(lstate);</a>
<a name="ln1065">  }</a>
<a name="ln1066"> </a>
<a name="ln1067">  return 0;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">static int nlua_api_nvim_buf_del_var(lua_State *lstate)</a>
<a name="ln1071">{</a>
<a name="ln1072">  Error err = ERROR_INIT;</a>
<a name="ln1073">  char *err_param = 0;</a>
<a name="ln1074">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1075">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1076">    goto exit_0;</a>
<a name="ln1077">  }</a>
<a name="ln1078">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1079">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_var&quot;);</a>
<a name="ln1080">  }</a>
<a name="ln1081">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1082">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1083">  }</a>
<a name="ln1084"> </a>
<a name="ln1085">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1086">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1087">  }</a>
<a name="ln1088"> </a>
<a name="ln1089">  nvim_buf_del_var(arg1, arg2, &amp;err);</a>
<a name="ln1090"> </a>
<a name="ln1091">  api_free_buffer(arg1);</a>
<a name="ln1092">exit_1:</a>
<a name="ln1093">  api_free_string(arg2);</a>
<a name="ln1094"> </a>
<a name="ln1095">exit_0:</a>
<a name="ln1096">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1097">    luaL_where(lstate, 1);</a>
<a name="ln1098">    if (err_param) {</a>
<a name="ln1099">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1100">      lua_pushstring(lstate, err_param);</a>
<a name="ln1101">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1102">    }</a>
<a name="ln1103">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1104">    api_clear_error(&amp;err);</a>
<a name="ln1105">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1106">    return lua_error(lstate);</a>
<a name="ln1107">  }</a>
<a name="ln1108"> </a>
<a name="ln1109">  return 0;</a>
<a name="ln1110">}</a>
<a name="ln1111"> </a>
<a name="ln1112">static int nlua_api_nvim_buf_get_name(lua_State *lstate)</a>
<a name="ln1113">{</a>
<a name="ln1114">  Error err = ERROR_INIT;</a>
<a name="ln1115">  char *err_param = 0;</a>
<a name="ln1116">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1117">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1118">    goto exit_0;</a>
<a name="ln1119">  }</a>
<a name="ln1120">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1121">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_name&quot;);</a>
<a name="ln1122">  }</a>
<a name="ln1123">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1124">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1125">  }</a>
<a name="ln1126"> </a>
<a name="ln1127">  Arena arena = ARENA_EMPTY;</a>
<a name="ln1128">  const String ret = nvim_buf_get_name(arg1, &amp;arena, &amp;err);</a>
<a name="ln1129">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1130">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln1131"> </a>
<a name="ln1132">  api_free_buffer(arg1);</a>
<a name="ln1133"> </a>
<a name="ln1134">exit_0:</a>
<a name="ln1135">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1136">    luaL_where(lstate, 1);</a>
<a name="ln1137">    if (err_param) {</a>
<a name="ln1138">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1139">      lua_pushstring(lstate, err_param);</a>
<a name="ln1140">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1141">    }</a>
<a name="ln1142">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1143">    api_clear_error(&amp;err);</a>
<a name="ln1144">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1145">    return lua_error(lstate);</a>
<a name="ln1146">  }</a>
<a name="ln1147"> </a>
<a name="ln1148">  return 1;</a>
<a name="ln1149">}</a>
<a name="ln1150"> </a>
<a name="ln1151">static int nlua_api_nvim_buf_set_name(lua_State *lstate)</a>
<a name="ln1152">{</a>
<a name="ln1153">  Error err = ERROR_INIT;</a>
<a name="ln1154">  char *err_param = 0;</a>
<a name="ln1155">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1156">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1157">    goto exit_0;</a>
<a name="ln1158">  }</a>
<a name="ln1159">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1160">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_name&quot;);</a>
<a name="ln1161">  }</a>
<a name="ln1162">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1163">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1164">  }</a>
<a name="ln1165"> </a>
<a name="ln1166">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1167">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1168">  }</a>
<a name="ln1169"> </a>
<a name="ln1170">  nvim_buf_set_name(arg1, arg2, &amp;err);</a>
<a name="ln1171"> </a>
<a name="ln1172">  api_free_buffer(arg1);</a>
<a name="ln1173">exit_1:</a>
<a name="ln1174">  api_free_string(arg2);</a>
<a name="ln1175"> </a>
<a name="ln1176">exit_0:</a>
<a name="ln1177">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1178">    luaL_where(lstate, 1);</a>
<a name="ln1179">    if (err_param) {</a>
<a name="ln1180">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1181">      lua_pushstring(lstate, err_param);</a>
<a name="ln1182">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1183">    }</a>
<a name="ln1184">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1185">    api_clear_error(&amp;err);</a>
<a name="ln1186">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1187">    return lua_error(lstate);</a>
<a name="ln1188">  }</a>
<a name="ln1189"> </a>
<a name="ln1190">  return 0;</a>
<a name="ln1191">}</a>
<a name="ln1192"> </a>
<a name="ln1193">static int nlua_api_nvim_buf_is_loaded(lua_State *lstate)</a>
<a name="ln1194">{</a>
<a name="ln1195">  Error err = ERROR_INIT;</a>
<a name="ln1196">  char *err_param = 0;</a>
<a name="ln1197">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1198">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1199">    goto exit_0;</a>
<a name="ln1200">  }</a>
<a name="ln1201">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1202">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_is_loaded&quot;);</a>
<a name="ln1203">  }</a>
<a name="ln1204">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1205">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1206">  }</a>
<a name="ln1207"> </a>
<a name="ln1208">  const Boolean ret = nvim_buf_is_loaded(arg1);</a>
<a name="ln1209">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1210">api_free_boolean(ret);</a>
<a name="ln1211"> </a>
<a name="ln1212">  api_free_buffer(arg1);</a>
<a name="ln1213"> </a>
<a name="ln1214">exit_0:</a>
<a name="ln1215">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1216">    luaL_where(lstate, 1);</a>
<a name="ln1217">    if (err_param) {</a>
<a name="ln1218">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1219">      lua_pushstring(lstate, err_param);</a>
<a name="ln1220">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1221">    }</a>
<a name="ln1222">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1223">    api_clear_error(&amp;err);</a>
<a name="ln1224">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1225">    return lua_error(lstate);</a>
<a name="ln1226">  }</a>
<a name="ln1227"> </a>
<a name="ln1228">  return 1;</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231">static int nlua_api_nvim_buf_delete(lua_State *lstate)</a>
<a name="ln1232">{</a>
<a name="ln1233">  Error err = ERROR_INIT;</a>
<a name="ln1234">  char *err_param = 0;</a>
<a name="ln1235">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1236">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1237">    goto exit_0;</a>
<a name="ln1238">  }</a>
<a name="ln1239">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1240">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_delete&quot;);</a>
<a name="ln1241">  }</a>
<a name="ln1242">  if (text_locked()) {</a>
<a name="ln1243">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln1244">    goto exit_0;</a>
<a name="ln1245">  }</a>
<a name="ln1246">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1247">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1248">  }</a>
<a name="ln1249"> </a>
<a name="ln1250">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1251">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  nvim_buf_delete(arg1, arg2, &amp;err);</a>
<a name="ln1255"> </a>
<a name="ln1256">  api_free_buffer(arg1);</a>
<a name="ln1257">exit_1:</a>
<a name="ln1258">  api_free_dictionary(arg2);</a>
<a name="ln1259"> </a>
<a name="ln1260">exit_0:</a>
<a name="ln1261">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1262">    luaL_where(lstate, 1);</a>
<a name="ln1263">    if (err_param) {</a>
<a name="ln1264">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1265">      lua_pushstring(lstate, err_param);</a>
<a name="ln1266">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1267">    }</a>
<a name="ln1268">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1269">    api_clear_error(&amp;err);</a>
<a name="ln1270">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1271">    return lua_error(lstate);</a>
<a name="ln1272">  }</a>
<a name="ln1273"> </a>
<a name="ln1274">  return 0;</a>
<a name="ln1275">}</a>
<a name="ln1276"> </a>
<a name="ln1277">static int nlua_api_nvim_buf_is_valid(lua_State *lstate)</a>
<a name="ln1278">{</a>
<a name="ln1279">  Error err = ERROR_INIT;</a>
<a name="ln1280">  char *err_param = 0;</a>
<a name="ln1281">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1282">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1283">    goto exit_0;</a>
<a name="ln1284">  }</a>
<a name="ln1285">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1286">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_is_valid&quot;);</a>
<a name="ln1287">  }</a>
<a name="ln1288">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1289">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1290">  }</a>
<a name="ln1291"> </a>
<a name="ln1292">  const Boolean ret = nvim_buf_is_valid(arg1);</a>
<a name="ln1293">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1294">api_free_boolean(ret);</a>
<a name="ln1295"> </a>
<a name="ln1296">  api_free_buffer(arg1);</a>
<a name="ln1297"> </a>
<a name="ln1298">exit_0:</a>
<a name="ln1299">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1300">    luaL_where(lstate, 1);</a>
<a name="ln1301">    if (err_param) {</a>
<a name="ln1302">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1303">      lua_pushstring(lstate, err_param);</a>
<a name="ln1304">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1305">    }</a>
<a name="ln1306">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1307">    api_clear_error(&amp;err);</a>
<a name="ln1308">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1309">    return lua_error(lstate);</a>
<a name="ln1310">  }</a>
<a name="ln1311"> </a>
<a name="ln1312">  return 1;</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">static int nlua_api_nvim_buf_del_mark(lua_State *lstate)</a>
<a name="ln1316">{</a>
<a name="ln1317">  Error err = ERROR_INIT;</a>
<a name="ln1318">  char *err_param = 0;</a>
<a name="ln1319">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1320">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1321">    goto exit_0;</a>
<a name="ln1322">  }</a>
<a name="ln1323">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1324">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_mark&quot;);</a>
<a name="ln1325">  }</a>
<a name="ln1326">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1327">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1328">  }</a>
<a name="ln1329"> </a>
<a name="ln1330">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1331">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1332">  }</a>
<a name="ln1333"> </a>
<a name="ln1334">  const Boolean ret = nvim_buf_del_mark(arg1, arg2, &amp;err);</a>
<a name="ln1335">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1336">api_free_boolean(ret);</a>
<a name="ln1337"> </a>
<a name="ln1338">  api_free_buffer(arg1);</a>
<a name="ln1339">exit_1:</a>
<a name="ln1340">  api_free_string(arg2);</a>
<a name="ln1341"> </a>
<a name="ln1342">exit_0:</a>
<a name="ln1343">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1344">    luaL_where(lstate, 1);</a>
<a name="ln1345">    if (err_param) {</a>
<a name="ln1346">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1347">      lua_pushstring(lstate, err_param);</a>
<a name="ln1348">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1349">    }</a>
<a name="ln1350">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1351">    api_clear_error(&amp;err);</a>
<a name="ln1352">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1353">    return lua_error(lstate);</a>
<a name="ln1354">  }</a>
<a name="ln1355"> </a>
<a name="ln1356">  return 1;</a>
<a name="ln1357">}</a>
<a name="ln1358"> </a>
<a name="ln1359">static int nlua_api_nvim_buf_set_mark(lua_State *lstate)</a>
<a name="ln1360">{</a>
<a name="ln1361">  Error err = ERROR_INIT;</a>
<a name="ln1362">  char *err_param = 0;</a>
<a name="ln1363">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln1364">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln1365">    goto exit_0;</a>
<a name="ln1366">  }</a>
<a name="ln1367">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1368">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_mark&quot;);</a>
<a name="ln1369">  }</a>
<a name="ln1370">    const Dictionary arg5 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1371">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1372">  }</a>
<a name="ln1373"> </a>
<a name="ln1374">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln1375">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_1;</a>
<a name="ln1376">  }</a>
<a name="ln1377"> </a>
<a name="ln1378">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln1379">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln1380">  }</a>
<a name="ln1381"> </a>
<a name="ln1382">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1383">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_3;</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1387">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln1388">  }</a>
<a name="ln1389"> </a>
<a name="ln1390">  const Boolean ret = nvim_buf_set_mark(arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln1391">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln1392">api_free_boolean(ret);</a>
<a name="ln1393"> </a>
<a name="ln1394">  api_free_buffer(arg1);</a>
<a name="ln1395">exit_4:</a>
<a name="ln1396">  api_free_string(arg2);</a>
<a name="ln1397">exit_3:</a>
<a name="ln1398">  api_free_integer(arg3);</a>
<a name="ln1399">exit_2:</a>
<a name="ln1400">  api_free_integer(arg4);</a>
<a name="ln1401">exit_1:</a>
<a name="ln1402">  api_free_dictionary(arg5);</a>
<a name="ln1403"> </a>
<a name="ln1404">exit_0:</a>
<a name="ln1405">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1406">    luaL_where(lstate, 1);</a>
<a name="ln1407">    if (err_param) {</a>
<a name="ln1408">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1409">      lua_pushstring(lstate, err_param);</a>
<a name="ln1410">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1411">    }</a>
<a name="ln1412">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1413">    api_clear_error(&amp;err);</a>
<a name="ln1414">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1415">    return lua_error(lstate);</a>
<a name="ln1416">  }</a>
<a name="ln1417"> </a>
<a name="ln1418">  return 1;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">static int nlua_api_nvim_buf_get_mark(lua_State *lstate)</a>
<a name="ln1422">{</a>
<a name="ln1423">  Error err = ERROR_INIT;</a>
<a name="ln1424">  char *err_param = 0;</a>
<a name="ln1425">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1426">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1427">    goto exit_0;</a>
<a name="ln1428">  }</a>
<a name="ln1429">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1430">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_mark&quot;);</a>
<a name="ln1431">  }</a>
<a name="ln1432">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1433">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1434">  }</a>
<a name="ln1435"> </a>
<a name="ln1436">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1437">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1438">  }</a>
<a name="ln1439"> </a>
<a name="ln1440">  const ArrayOf(Integer, 2) ret = nvim_buf_get_mark(arg1, arg2, &amp;err);</a>
<a name="ln1441">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln1442">api_free_array(ret);</a>
<a name="ln1443"> </a>
<a name="ln1444">  api_free_buffer(arg1);</a>
<a name="ln1445">exit_1:</a>
<a name="ln1446">  api_free_string(arg2);</a>
<a name="ln1447"> </a>
<a name="ln1448">exit_0:</a>
<a name="ln1449">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1450">    luaL_where(lstate, 1);</a>
<a name="ln1451">    if (err_param) {</a>
<a name="ln1452">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1453">      lua_pushstring(lstate, err_param);</a>
<a name="ln1454">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1455">    }</a>
<a name="ln1456">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1457">    api_clear_error(&amp;err);</a>
<a name="ln1458">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1459">    return lua_error(lstate);</a>
<a name="ln1460">  }</a>
<a name="ln1461"> </a>
<a name="ln1462">  return 1;</a>
<a name="ln1463">}</a>
<a name="ln1464"> </a>
<a name="ln1465">static int nlua_api_nvim_buf_call(lua_State *lstate)</a>
<a name="ln1466">{</a>
<a name="ln1467">  Error err = ERROR_INIT;</a>
<a name="ln1468">  char *err_param = 0;</a>
<a name="ln1469">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1470">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1471">    goto exit_0;</a>
<a name="ln1472">  }</a>
<a name="ln1473">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1474">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_call&quot;);</a>
<a name="ln1475">  }</a>
<a name="ln1476">    const LuaRef arg2 = nlua_pop_LuaRef(lstate, &amp;err);</a>
<a name="ln1477">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fun&quot;;      goto exit_0;</a>
<a name="ln1478">  }</a>
<a name="ln1479"> </a>
<a name="ln1480">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1481">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1482">  }</a>
<a name="ln1483"> </a>
<a name="ln1484">  const Object ret = nvim_buf_call(arg1, arg2, &amp;err);</a>
<a name="ln1485">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln1486">api_free_object(ret);</a>
<a name="ln1487"> </a>
<a name="ln1488">  api_free_buffer(arg1);</a>
<a name="ln1489">exit_1:</a>
<a name="ln1490">  api_free_luaref(arg2);</a>
<a name="ln1491"> </a>
<a name="ln1492">exit_0:</a>
<a name="ln1493">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1494">    luaL_where(lstate, 1);</a>
<a name="ln1495">    if (err_param) {</a>
<a name="ln1496">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1497">      lua_pushstring(lstate, err_param);</a>
<a name="ln1498">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1499">    }</a>
<a name="ln1500">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1501">    api_clear_error(&amp;err);</a>
<a name="ln1502">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1503">    return lua_error(lstate);</a>
<a name="ln1504">  }</a>
<a name="ln1505"> </a>
<a name="ln1506">  return 1;</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">static int nlua_api_nvim__buf_stats(lua_State *lstate)</a>
<a name="ln1510">{</a>
<a name="ln1511">  Error err = ERROR_INIT;</a>
<a name="ln1512">  char *err_param = 0;</a>
<a name="ln1513">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1514">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1515">    goto exit_0;</a>
<a name="ln1516">  }</a>
<a name="ln1517">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1518">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_stats&quot;);</a>
<a name="ln1519">  }</a>
<a name="ln1520">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1521">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1522">  }</a>
<a name="ln1523"> </a>
<a name="ln1524">  const Dictionary ret = nvim__buf_stats(arg1, &amp;err);</a>
<a name="ln1525">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1526">api_free_dictionary(ret);</a>
<a name="ln1527"> </a>
<a name="ln1528">  api_free_buffer(arg1);</a>
<a name="ln1529"> </a>
<a name="ln1530">exit_0:</a>
<a name="ln1531">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1532">    luaL_where(lstate, 1);</a>
<a name="ln1533">    if (err_param) {</a>
<a name="ln1534">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1535">      lua_pushstring(lstate, err_param);</a>
<a name="ln1536">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1537">    }</a>
<a name="ln1538">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1539">    api_clear_error(&amp;err);</a>
<a name="ln1540">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1541">    return lua_error(lstate);</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544">  return 1;</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547">static int nlua_api_nvim_parse_cmd(lua_State *lstate)</a>
<a name="ln1548">{</a>
<a name="ln1549">  Error err = ERROR_INIT;</a>
<a name="ln1550">  char *err_param = 0;</a>
<a name="ln1551">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1552">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1553">    goto exit_0;</a>
<a name="ln1554">  }</a>
<a name="ln1555">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln1556">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln1557">  }</a>
<a name="ln1558"> </a>
<a name="ln1559">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1560">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_1;</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  const Dictionary ret = nvim_parse_cmd(arg1, arg2, &amp;err);</a>
<a name="ln1564">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1565">api_free_dictionary(ret);</a>
<a name="ln1566"> </a>
<a name="ln1567">  api_free_string(arg1);</a>
<a name="ln1568">exit_1:</a>
<a name="ln1569">  api_free_dictionary(arg2);</a>
<a name="ln1570"> </a>
<a name="ln1571">exit_0:</a>
<a name="ln1572">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1573">    luaL_where(lstate, 1);</a>
<a name="ln1574">    if (err_param) {</a>
<a name="ln1575">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1576">      lua_pushstring(lstate, err_param);</a>
<a name="ln1577">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1578">    }</a>
<a name="ln1579">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1580">    api_clear_error(&amp;err);</a>
<a name="ln1581">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1582">    return lua_error(lstate);</a>
<a name="ln1583">  }</a>
<a name="ln1584"> </a>
<a name="ln1585">  return 1;</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">static int nlua_api_nvim_cmd(lua_State *lstate)</a>
<a name="ln1589">{</a>
<a name="ln1590">  Error err = ERROR_INIT;</a>
<a name="ln1591">  char *err_param = 0;</a>
<a name="ln1592">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1593">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1594">    goto exit_0;</a>
<a name="ln1595">  }</a>
<a name="ln1596">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1597">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_cmd&quot;);</a>
<a name="ln1598">  }</a>
<a name="ln1599">    KeyDict_cmd_opts arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_cmd_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1600">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1601">  }</a>
<a name="ln1602"> </a>
<a name="ln1603">    KeyDict_cmd arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_cmd_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1604">  if (ERROR_SET(&amp;err)) {      goto exit_2;</a>
<a name="ln1605">  }</a>
<a name="ln1606"> </a>
<a name="ln1607">  const String ret = nvim_cmd(LUA_INTERNAL_CALL, &amp;arg1, &amp;arg2, &amp;err);</a>
<a name="ln1608">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1609">api_free_string(ret);</a>
<a name="ln1610"> </a>
<a name="ln1611">exit_2:</a>
<a name="ln1612">  api_free_keydict_cmd(&amp;arg1);</a>
<a name="ln1613">exit_1:</a>
<a name="ln1614">  api_free_keydict_cmd_opts(&amp;arg2);</a>
<a name="ln1615"> </a>
<a name="ln1616">exit_0:</a>
<a name="ln1617">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1618">    luaL_where(lstate, 1);</a>
<a name="ln1619">    if (err_param) {</a>
<a name="ln1620">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1621">      lua_pushstring(lstate, err_param);</a>
<a name="ln1622">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1623">    }</a>
<a name="ln1624">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1625">    api_clear_error(&amp;err);</a>
<a name="ln1626">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1627">    return lua_error(lstate);</a>
<a name="ln1628">  }</a>
<a name="ln1629"> </a>
<a name="ln1630">  return 1;</a>
<a name="ln1631">}</a>
<a name="ln1632"> </a>
<a name="ln1633">static int nlua_api_nvim_create_user_command(lua_State *lstate)</a>
<a name="ln1634">{</a>
<a name="ln1635">  Error err = ERROR_INIT;</a>
<a name="ln1636">  char *err_param = 0;</a>
<a name="ln1637">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln1638">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln1639">    goto exit_0;</a>
<a name="ln1640">  }</a>
<a name="ln1641">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1642">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_user_command&quot;);</a>
<a name="ln1643">  }</a>
<a name="ln1644">    KeyDict_user_command arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_user_command_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1645">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1646">  }</a>
<a name="ln1647"> </a>
<a name="ln1648">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1649">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_1;</a>
<a name="ln1650">  }</a>
<a name="ln1651"> </a>
<a name="ln1652">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1653">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln1654">  }</a>
<a name="ln1655"> </a>
<a name="ln1656">  nvim_create_user_command(LUA_INTERNAL_CALL, arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln1657"> </a>
<a name="ln1658">  api_free_string(arg1);</a>
<a name="ln1659">exit_2:</a>
<a name="ln1660">  api_free_object(arg2);</a>
<a name="ln1661">exit_1:</a>
<a name="ln1662">  api_free_keydict_user_command(&amp;arg3);</a>
<a name="ln1663"> </a>
<a name="ln1664">exit_0:</a>
<a name="ln1665">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1666">    luaL_where(lstate, 1);</a>
<a name="ln1667">    if (err_param) {</a>
<a name="ln1668">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1669">      lua_pushstring(lstate, err_param);</a>
<a name="ln1670">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1671">    }</a>
<a name="ln1672">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1673">    api_clear_error(&amp;err);</a>
<a name="ln1674">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1675">    return lua_error(lstate);</a>
<a name="ln1676">  }</a>
<a name="ln1677"> </a>
<a name="ln1678">  return 0;</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">static int nlua_api_nvim_del_user_command(lua_State *lstate)</a>
<a name="ln1682">{</a>
<a name="ln1683">  Error err = ERROR_INIT;</a>
<a name="ln1684">  char *err_param = 0;</a>
<a name="ln1685">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1686">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1687">    goto exit_0;</a>
<a name="ln1688">  }</a>
<a name="ln1689">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1690">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_user_command&quot;);</a>
<a name="ln1691">  }</a>
<a name="ln1692">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1693">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1694">  }</a>
<a name="ln1695"> </a>
<a name="ln1696">  nvim_del_user_command(arg1, &amp;err);</a>
<a name="ln1697"> </a>
<a name="ln1698">  api_free_string(arg1);</a>
<a name="ln1699"> </a>
<a name="ln1700">exit_0:</a>
<a name="ln1701">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1702">    luaL_where(lstate, 1);</a>
<a name="ln1703">    if (err_param) {</a>
<a name="ln1704">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1705">      lua_pushstring(lstate, err_param);</a>
<a name="ln1706">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1707">    }</a>
<a name="ln1708">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1709">    api_clear_error(&amp;err);</a>
<a name="ln1710">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1711">    return lua_error(lstate);</a>
<a name="ln1712">  }</a>
<a name="ln1713"> </a>
<a name="ln1714">  return 0;</a>
<a name="ln1715">}</a>
<a name="ln1716"> </a>
<a name="ln1717">static int nlua_api_nvim_buf_create_user_command(lua_State *lstate)</a>
<a name="ln1718">{</a>
<a name="ln1719">  Error err = ERROR_INIT;</a>
<a name="ln1720">  char *err_param = 0;</a>
<a name="ln1721">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln1722">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln1723">    goto exit_0;</a>
<a name="ln1724">  }</a>
<a name="ln1725">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1726">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_create_user_command&quot;);</a>
<a name="ln1727">  }</a>
<a name="ln1728">    KeyDict_user_command arg4 = { 0 }; nlua_pop_keydict(lstate, &amp;arg4, KeyDict_user_command_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1729">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1730">  }</a>
<a name="ln1731"> </a>
<a name="ln1732">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln1733">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_1;</a>
<a name="ln1734">  }</a>
<a name="ln1735"> </a>
<a name="ln1736">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1737">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln1738">  }</a>
<a name="ln1739"> </a>
<a name="ln1740">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1741">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744">  nvim_buf_create_user_command(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;arg4, &amp;err);</a>
<a name="ln1745"> </a>
<a name="ln1746">  api_free_buffer(arg1);</a>
<a name="ln1747">exit_3:</a>
<a name="ln1748">  api_free_string(arg2);</a>
<a name="ln1749">exit_2:</a>
<a name="ln1750">  api_free_object(arg3);</a>
<a name="ln1751">exit_1:</a>
<a name="ln1752">  api_free_keydict_user_command(&amp;arg4);</a>
<a name="ln1753"> </a>
<a name="ln1754">exit_0:</a>
<a name="ln1755">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1756">    luaL_where(lstate, 1);</a>
<a name="ln1757">    if (err_param) {</a>
<a name="ln1758">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1759">      lua_pushstring(lstate, err_param);</a>
<a name="ln1760">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1761">    }</a>
<a name="ln1762">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1763">    api_clear_error(&amp;err);</a>
<a name="ln1764">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1765">    return lua_error(lstate);</a>
<a name="ln1766">  }</a>
<a name="ln1767"> </a>
<a name="ln1768">  return 0;</a>
<a name="ln1769">}</a>
<a name="ln1770"> </a>
<a name="ln1771">static int nlua_api_nvim_buf_del_user_command(lua_State *lstate)</a>
<a name="ln1772">{</a>
<a name="ln1773">  Error err = ERROR_INIT;</a>
<a name="ln1774">  char *err_param = 0;</a>
<a name="ln1775">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1776">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1777">    goto exit_0;</a>
<a name="ln1778">  }</a>
<a name="ln1779">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1780">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_user_command&quot;);</a>
<a name="ln1781">  }</a>
<a name="ln1782">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1783">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln1784">  }</a>
<a name="ln1785"> </a>
<a name="ln1786">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1787">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1788">  }</a>
<a name="ln1789"> </a>
<a name="ln1790">  nvim_buf_del_user_command(arg1, arg2, &amp;err);</a>
<a name="ln1791"> </a>
<a name="ln1792">  api_free_buffer(arg1);</a>
<a name="ln1793">exit_1:</a>
<a name="ln1794">  api_free_string(arg2);</a>
<a name="ln1795"> </a>
<a name="ln1796">exit_0:</a>
<a name="ln1797">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1798">    luaL_where(lstate, 1);</a>
<a name="ln1799">    if (err_param) {</a>
<a name="ln1800">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1801">      lua_pushstring(lstate, err_param);</a>
<a name="ln1802">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1803">    }</a>
<a name="ln1804">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1805">    api_clear_error(&amp;err);</a>
<a name="ln1806">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1807">    return lua_error(lstate);</a>
<a name="ln1808">  }</a>
<a name="ln1809"> </a>
<a name="ln1810">  return 0;</a>
<a name="ln1811">}</a>
<a name="ln1812"> </a>
<a name="ln1813">static int nlua_api_nvim_get_commands(lua_State *lstate)</a>
<a name="ln1814">{</a>
<a name="ln1815">  Error err = ERROR_INIT;</a>
<a name="ln1816">  char *err_param = 0;</a>
<a name="ln1817">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1818">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1819">    goto exit_0;</a>
<a name="ln1820">  }</a>
<a name="ln1821">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1822">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_commands&quot;);</a>
<a name="ln1823">  }</a>
<a name="ln1824">    KeyDict_get_commands arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_get_commands_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1825">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1826">  }</a>
<a name="ln1827"> </a>
<a name="ln1828">  const Dictionary ret = nvim_get_commands(&amp;arg1, &amp;err);</a>
<a name="ln1829">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1830">api_free_dictionary(ret);</a>
<a name="ln1831"> </a>
<a name="ln1832">exit_1:</a>
<a name="ln1833">  api_free_keydict_get_commands(&amp;arg1);</a>
<a name="ln1834"> </a>
<a name="ln1835">exit_0:</a>
<a name="ln1836">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1837">    luaL_where(lstate, 1);</a>
<a name="ln1838">    if (err_param) {</a>
<a name="ln1839">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1840">      lua_pushstring(lstate, err_param);</a>
<a name="ln1841">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1842">    }</a>
<a name="ln1843">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1844">    api_clear_error(&amp;err);</a>
<a name="ln1845">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1846">    return lua_error(lstate);</a>
<a name="ln1847">  }</a>
<a name="ln1848"> </a>
<a name="ln1849">  return 1;</a>
<a name="ln1850">}</a>
<a name="ln1851"> </a>
<a name="ln1852">static int nlua_api_nvim_buf_get_commands(lua_State *lstate)</a>
<a name="ln1853">{</a>
<a name="ln1854">  Error err = ERROR_INIT;</a>
<a name="ln1855">  char *err_param = 0;</a>
<a name="ln1856">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1857">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1858">    goto exit_0;</a>
<a name="ln1859">  }</a>
<a name="ln1860">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1861">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_commands&quot;);</a>
<a name="ln1862">  }</a>
<a name="ln1863">    KeyDict_get_commands arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_get_commands_get_field, &amp;err_param, &amp;err);</a>
<a name="ln1864">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln1865">  }</a>
<a name="ln1866"> </a>
<a name="ln1867">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1868">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln1869">  }</a>
<a name="ln1870"> </a>
<a name="ln1871">  const Dictionary ret = nvim_buf_get_commands(arg1, &amp;arg2, &amp;err);</a>
<a name="ln1872">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln1873">api_free_dictionary(ret);</a>
<a name="ln1874"> </a>
<a name="ln1875">  api_free_buffer(arg1);</a>
<a name="ln1876">exit_1:</a>
<a name="ln1877">  api_free_keydict_get_commands(&amp;arg2);</a>
<a name="ln1878"> </a>
<a name="ln1879">exit_0:</a>
<a name="ln1880">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1881">    luaL_where(lstate, 1);</a>
<a name="ln1882">    if (err_param) {</a>
<a name="ln1883">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1884">      lua_pushstring(lstate, err_param);</a>
<a name="ln1885">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1886">    }</a>
<a name="ln1887">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1888">    api_clear_error(&amp;err);</a>
<a name="ln1889">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1890">    return lua_error(lstate);</a>
<a name="ln1891">  }</a>
<a name="ln1892"> </a>
<a name="ln1893">  return 1;</a>
<a name="ln1894">}</a>
<a name="ln1895"> </a>
<a name="ln1896">static int nlua_api_nvim_exec(lua_State *lstate)</a>
<a name="ln1897">{</a>
<a name="ln1898">  Error err = ERROR_INIT;</a>
<a name="ln1899">  char *err_param = 0;</a>
<a name="ln1900">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln1901">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln1902">    goto exit_0;</a>
<a name="ln1903">  }</a>
<a name="ln1904">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1905">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec&quot;);</a>
<a name="ln1906">  }</a>
<a name="ln1907">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln1908">  if (ERROR_SET(&amp;err)) {      err_param = &quot;output&quot;;      goto exit_0;</a>
<a name="ln1909">  }</a>
<a name="ln1910"> </a>
<a name="ln1911">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1912">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src&quot;;      goto exit_1;</a>
<a name="ln1913">  }</a>
<a name="ln1914"> </a>
<a name="ln1915">  const String ret = nvim_exec(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln1916">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1917">api_free_string(ret);</a>
<a name="ln1918"> </a>
<a name="ln1919">  api_free_string(arg1);</a>
<a name="ln1920">exit_1:</a>
<a name="ln1921">  api_free_boolean(arg2);</a>
<a name="ln1922"> </a>
<a name="ln1923">exit_0:</a>
<a name="ln1924">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1925">    luaL_where(lstate, 1);</a>
<a name="ln1926">    if (err_param) {</a>
<a name="ln1927">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1928">      lua_pushstring(lstate, err_param);</a>
<a name="ln1929">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1930">    }</a>
<a name="ln1931">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1932">    api_clear_error(&amp;err);</a>
<a name="ln1933">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1934">    return lua_error(lstate);</a>
<a name="ln1935">  }</a>
<a name="ln1936"> </a>
<a name="ln1937">  return 1;</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">static int nlua_api_nvim_command_output(lua_State *lstate)</a>
<a name="ln1941">{</a>
<a name="ln1942">  Error err = ERROR_INIT;</a>
<a name="ln1943">  char *err_param = 0;</a>
<a name="ln1944">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1945">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1946">    goto exit_0;</a>
<a name="ln1947">  }</a>
<a name="ln1948">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1949">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_command_output&quot;);</a>
<a name="ln1950">  }</a>
<a name="ln1951">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln1952">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_0;</a>
<a name="ln1953">  }</a>
<a name="ln1954"> </a>
<a name="ln1955">  const String ret = nvim_command_output(LUA_INTERNAL_CALL, arg1, &amp;err);</a>
<a name="ln1956">  nlua_push_String(lstate, ret, true);</a>
<a name="ln1957">api_free_string(ret);</a>
<a name="ln1958"> </a>
<a name="ln1959">  api_free_string(arg1);</a>
<a name="ln1960"> </a>
<a name="ln1961">exit_0:</a>
<a name="ln1962">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln1963">    luaL_where(lstate, 1);</a>
<a name="ln1964">    if (err_param) {</a>
<a name="ln1965">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln1966">      lua_pushstring(lstate, err_param);</a>
<a name="ln1967">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln1968">    }</a>
<a name="ln1969">    lua_pushstring(lstate, err.msg);</a>
<a name="ln1970">    api_clear_error(&amp;err);</a>
<a name="ln1971">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln1972">    return lua_error(lstate);</a>
<a name="ln1973">  }</a>
<a name="ln1974"> </a>
<a name="ln1975">  return 1;</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978">static int nlua_api_nvim_buf_get_number(lua_State *lstate)</a>
<a name="ln1979">{</a>
<a name="ln1980">  Error err = ERROR_INIT;</a>
<a name="ln1981">  char *err_param = 0;</a>
<a name="ln1982">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln1983">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln1984">    goto exit_0;</a>
<a name="ln1985">  }</a>
<a name="ln1986">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln1987">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_number&quot;);</a>
<a name="ln1988">  }</a>
<a name="ln1989">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln1990">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln1991">  }</a>
<a name="ln1992"> </a>
<a name="ln1993">  const Integer ret = nvim_buf_get_number(arg1, &amp;err);</a>
<a name="ln1994">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln1995">api_free_integer(ret);</a>
<a name="ln1996"> </a>
<a name="ln1997">  api_free_buffer(arg1);</a>
<a name="ln1998"> </a>
<a name="ln1999">exit_0:</a>
<a name="ln2000">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2001">    luaL_where(lstate, 1);</a>
<a name="ln2002">    if (err_param) {</a>
<a name="ln2003">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2004">      lua_pushstring(lstate, err_param);</a>
<a name="ln2005">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2006">    }</a>
<a name="ln2007">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2008">    api_clear_error(&amp;err);</a>
<a name="ln2009">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2010">    return lua_error(lstate);</a>
<a name="ln2011">  }</a>
<a name="ln2012"> </a>
<a name="ln2013">  return 1;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">static int nlua_api_nvim_buf_clear_highlight(lua_State *lstate)</a>
<a name="ln2017">{</a>
<a name="ln2018">  Error err = ERROR_INIT;</a>
<a name="ln2019">  char *err_param = 0;</a>
<a name="ln2020">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2021">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2022">    goto exit_0;</a>
<a name="ln2023">  }</a>
<a name="ln2024">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2025">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_clear_highlight&quot;);</a>
<a name="ln2026">  }</a>
<a name="ln2027">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2028">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_end&quot;;      goto exit_0;</a>
<a name="ln2029">  }</a>
<a name="ln2030"> </a>
<a name="ln2031">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2032">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_start&quot;;      goto exit_1;</a>
<a name="ln2033">  }</a>
<a name="ln2034"> </a>
<a name="ln2035">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2036">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2037">  }</a>
<a name="ln2038"> </a>
<a name="ln2039">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2040">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2041">  }</a>
<a name="ln2042"> </a>
<a name="ln2043">  nvim_buf_clear_highlight(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2044"> </a>
<a name="ln2045">  api_free_buffer(arg1);</a>
<a name="ln2046">exit_3:</a>
<a name="ln2047">  api_free_integer(arg2);</a>
<a name="ln2048">exit_2:</a>
<a name="ln2049">  api_free_integer(arg3);</a>
<a name="ln2050">exit_1:</a>
<a name="ln2051">  api_free_integer(arg4);</a>
<a name="ln2052"> </a>
<a name="ln2053">exit_0:</a>
<a name="ln2054">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2055">    luaL_where(lstate, 1);</a>
<a name="ln2056">    if (err_param) {</a>
<a name="ln2057">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2058">      lua_pushstring(lstate, err_param);</a>
<a name="ln2059">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2060">    }</a>
<a name="ln2061">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2062">    api_clear_error(&amp;err);</a>
<a name="ln2063">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2064">    return lua_error(lstate);</a>
<a name="ln2065">  }</a>
<a name="ln2066"> </a>
<a name="ln2067">  return 0;</a>
<a name="ln2068">}</a>
<a name="ln2069"> </a>
<a name="ln2070">static int nlua_api_nvim_buf_set_virtual_text(lua_State *lstate)</a>
<a name="ln2071">{</a>
<a name="ln2072">  Error err = ERROR_INIT;</a>
<a name="ln2073">  char *err_param = 0;</a>
<a name="ln2074">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2075">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2076">    goto exit_0;</a>
<a name="ln2077">  }</a>
<a name="ln2078">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2079">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_virtual_text&quot;);</a>
<a name="ln2080">  }</a>
<a name="ln2081">    const Dictionary arg5 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln2082">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln2083">  }</a>
<a name="ln2084"> </a>
<a name="ln2085">    const Array arg4 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln2086">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chunks&quot;;      goto exit_1;</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2090">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2091">  }</a>
<a name="ln2092"> </a>
<a name="ln2093">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2094">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src_id&quot;;      goto exit_3;</a>
<a name="ln2095">  }</a>
<a name="ln2096"> </a>
<a name="ln2097">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2098">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2099">  }</a>
<a name="ln2100"> </a>
<a name="ln2101">  const Integer ret = nvim_buf_set_virtual_text(arg1, arg2, arg3, arg4, arg5, &amp;err);</a>
<a name="ln2102">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2103">api_free_integer(ret);</a>
<a name="ln2104"> </a>
<a name="ln2105">  api_free_buffer(arg1);</a>
<a name="ln2106">exit_4:</a>
<a name="ln2107">  api_free_integer(arg2);</a>
<a name="ln2108">exit_3:</a>
<a name="ln2109">  api_free_integer(arg3);</a>
<a name="ln2110">exit_2:</a>
<a name="ln2111">  api_free_array(arg4);</a>
<a name="ln2112">exit_1:</a>
<a name="ln2113">  api_free_dictionary(arg5);</a>
<a name="ln2114"> </a>
<a name="ln2115">exit_0:</a>
<a name="ln2116">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2117">    luaL_where(lstate, 1);</a>
<a name="ln2118">    if (err_param) {</a>
<a name="ln2119">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2120">      lua_pushstring(lstate, err_param);</a>
<a name="ln2121">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2122">    }</a>
<a name="ln2123">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2124">    api_clear_error(&amp;err);</a>
<a name="ln2125">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2126">    return lua_error(lstate);</a>
<a name="ln2127">  }</a>
<a name="ln2128"> </a>
<a name="ln2129">  return 1;</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">static int nlua_api_nvim_get_hl_by_id(lua_State *lstate)</a>
<a name="ln2133">{</a>
<a name="ln2134">  Error err = ERROR_INIT;</a>
<a name="ln2135">  char *err_param = 0;</a>
<a name="ln2136">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2137">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2138">    goto exit_0;</a>
<a name="ln2139">  }</a>
<a name="ln2140">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2141">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_by_id&quot;);</a>
<a name="ln2142">  }</a>
<a name="ln2143">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln2144">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rgb&quot;;      goto exit_0;</a>
<a name="ln2145">  }</a>
<a name="ln2146"> </a>
<a name="ln2147">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2148">  if (ERROR_SET(&amp;err)) {      err_param = &quot;hl_id&quot;;      goto exit_1;</a>
<a name="ln2149">  }</a>
<a name="ln2150"> </a>
<a name="ln2151">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2152">  const Dictionary ret = nvim_get_hl_by_id(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2153">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2154">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2155"> </a>
<a name="ln2156">  api_free_integer(arg1);</a>
<a name="ln2157">exit_1:</a>
<a name="ln2158">  api_free_boolean(arg2);</a>
<a name="ln2159"> </a>
<a name="ln2160">exit_0:</a>
<a name="ln2161">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2162">    luaL_where(lstate, 1);</a>
<a name="ln2163">    if (err_param) {</a>
<a name="ln2164">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2165">      lua_pushstring(lstate, err_param);</a>
<a name="ln2166">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2167">    }</a>
<a name="ln2168">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2169">    api_clear_error(&amp;err);</a>
<a name="ln2170">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2171">    return lua_error(lstate);</a>
<a name="ln2172">  }</a>
<a name="ln2173"> </a>
<a name="ln2174">  return 1;</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">static int nlua_api_nvim_get_hl_by_name(lua_State *lstate)</a>
<a name="ln2178">{</a>
<a name="ln2179">  Error err = ERROR_INIT;</a>
<a name="ln2180">  char *err_param = 0;</a>
<a name="ln2181">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2182">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2183">    goto exit_0;</a>
<a name="ln2184">  }</a>
<a name="ln2185">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2186">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_by_name&quot;);</a>
<a name="ln2187">  }</a>
<a name="ln2188">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln2189">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rgb&quot;;      goto exit_0;</a>
<a name="ln2190">  }</a>
<a name="ln2191"> </a>
<a name="ln2192">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2193">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2194">  }</a>
<a name="ln2195"> </a>
<a name="ln2196">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2197">  const Dictionary ret = nvim_get_hl_by_name(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2198">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2199">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2200"> </a>
<a name="ln2201">  api_free_string(arg1);</a>
<a name="ln2202">exit_1:</a>
<a name="ln2203">  api_free_boolean(arg2);</a>
<a name="ln2204"> </a>
<a name="ln2205">exit_0:</a>
<a name="ln2206">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2207">    luaL_where(lstate, 1);</a>
<a name="ln2208">    if (err_param) {</a>
<a name="ln2209">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2210">      lua_pushstring(lstate, err_param);</a>
<a name="ln2211">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2212">    }</a>
<a name="ln2213">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2214">    api_clear_error(&amp;err);</a>
<a name="ln2215">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2216">    return lua_error(lstate);</a>
<a name="ln2217">  }</a>
<a name="ln2218"> </a>
<a name="ln2219">  return 1;</a>
<a name="ln2220">}</a>
<a name="ln2221"> </a>
<a name="ln2222">static int nlua_api_nvim_get_option_info(lua_State *lstate)</a>
<a name="ln2223">{</a>
<a name="ln2224">  Error err = ERROR_INIT;</a>
<a name="ln2225">  char *err_param = 0;</a>
<a name="ln2226">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2227">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2228">    goto exit_0;</a>
<a name="ln2229">  }</a>
<a name="ln2230">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2231">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_info&quot;);</a>
<a name="ln2232">  }</a>
<a name="ln2233">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2234">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2235">  }</a>
<a name="ln2236"> </a>
<a name="ln2237">  const Dictionary ret = nvim_get_option_info(arg1, &amp;err);</a>
<a name="ln2238">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2239">api_free_dictionary(ret);</a>
<a name="ln2240"> </a>
<a name="ln2241">  api_free_string(arg1);</a>
<a name="ln2242"> </a>
<a name="ln2243">exit_0:</a>
<a name="ln2244">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2245">    luaL_where(lstate, 1);</a>
<a name="ln2246">    if (err_param) {</a>
<a name="ln2247">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2248">      lua_pushstring(lstate, err_param);</a>
<a name="ln2249">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2250">    }</a>
<a name="ln2251">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2252">    api_clear_error(&amp;err);</a>
<a name="ln2253">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2254">    return lua_error(lstate);</a>
<a name="ln2255">  }</a>
<a name="ln2256"> </a>
<a name="ln2257">  return 1;</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260">static int nlua_api_nvim_set_option(lua_State *lstate)</a>
<a name="ln2261">{</a>
<a name="ln2262">  Error err = ERROR_INIT;</a>
<a name="ln2263">  char *err_param = 0;</a>
<a name="ln2264">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2265">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2266">    goto exit_0;</a>
<a name="ln2267">  }</a>
<a name="ln2268">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2269">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_option&quot;);</a>
<a name="ln2270">  }</a>
<a name="ln2271">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2272">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2273">  }</a>
<a name="ln2274"> </a>
<a name="ln2275">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2276">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2277">  }</a>
<a name="ln2278"> </a>
<a name="ln2279">  nvim_set_option(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln2280"> </a>
<a name="ln2281">  api_free_string(arg1);</a>
<a name="ln2282">exit_1:</a>
<a name="ln2283">  api_free_object(arg2);</a>
<a name="ln2284"> </a>
<a name="ln2285">exit_0:</a>
<a name="ln2286">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2287">    luaL_where(lstate, 1);</a>
<a name="ln2288">    if (err_param) {</a>
<a name="ln2289">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2290">      lua_pushstring(lstate, err_param);</a>
<a name="ln2291">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2292">    }</a>
<a name="ln2293">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2294">    api_clear_error(&amp;err);</a>
<a name="ln2295">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2296">    return lua_error(lstate);</a>
<a name="ln2297">  }</a>
<a name="ln2298"> </a>
<a name="ln2299">  return 0;</a>
<a name="ln2300">}</a>
<a name="ln2301"> </a>
<a name="ln2302">static int nlua_api_nvim_get_option(lua_State *lstate)</a>
<a name="ln2303">{</a>
<a name="ln2304">  Error err = ERROR_INIT;</a>
<a name="ln2305">  char *err_param = 0;</a>
<a name="ln2306">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2307">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2308">    goto exit_0;</a>
<a name="ln2309">  }</a>
<a name="ln2310">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2311">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option&quot;);</a>
<a name="ln2312">  }</a>
<a name="ln2313">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2314">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2315">  }</a>
<a name="ln2316"> </a>
<a name="ln2317">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2318">  const Object ret = nvim_get_option(arg1, &amp;arena, &amp;err);</a>
<a name="ln2319">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2320">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2321"> </a>
<a name="ln2322">  api_free_string(arg1);</a>
<a name="ln2323"> </a>
<a name="ln2324">exit_0:</a>
<a name="ln2325">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2326">    luaL_where(lstate, 1);</a>
<a name="ln2327">    if (err_param) {</a>
<a name="ln2328">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2329">      lua_pushstring(lstate, err_param);</a>
<a name="ln2330">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2331">    }</a>
<a name="ln2332">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2333">    api_clear_error(&amp;err);</a>
<a name="ln2334">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2335">    return lua_error(lstate);</a>
<a name="ln2336">  }</a>
<a name="ln2337"> </a>
<a name="ln2338">  return 1;</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341">static int nlua_api_nvim_buf_get_option(lua_State *lstate)</a>
<a name="ln2342">{</a>
<a name="ln2343">  Error err = ERROR_INIT;</a>
<a name="ln2344">  char *err_param = 0;</a>
<a name="ln2345">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2346">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2347">    goto exit_0;</a>
<a name="ln2348">  }</a>
<a name="ln2349">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2350">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_option&quot;);</a>
<a name="ln2351">  }</a>
<a name="ln2352">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2353">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2354">  }</a>
<a name="ln2355"> </a>
<a name="ln2356">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2357">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln2358">  }</a>
<a name="ln2359"> </a>
<a name="ln2360">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2361">  const Object ret = nvim_buf_get_option(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2362">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2363">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2364"> </a>
<a name="ln2365">  api_free_buffer(arg1);</a>
<a name="ln2366">exit_1:</a>
<a name="ln2367">  api_free_string(arg2);</a>
<a name="ln2368"> </a>
<a name="ln2369">exit_0:</a>
<a name="ln2370">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2371">    luaL_where(lstate, 1);</a>
<a name="ln2372">    if (err_param) {</a>
<a name="ln2373">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2374">      lua_pushstring(lstate, err_param);</a>
<a name="ln2375">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2376">    }</a>
<a name="ln2377">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2378">    api_clear_error(&amp;err);</a>
<a name="ln2379">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2380">    return lua_error(lstate);</a>
<a name="ln2381">  }</a>
<a name="ln2382"> </a>
<a name="ln2383">  return 1;</a>
<a name="ln2384">}</a>
<a name="ln2385"> </a>
<a name="ln2386">static int nlua_api_nvim_buf_set_option(lua_State *lstate)</a>
<a name="ln2387">{</a>
<a name="ln2388">  Error err = ERROR_INIT;</a>
<a name="ln2389">  char *err_param = 0;</a>
<a name="ln2390">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2391">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2392">    goto exit_0;</a>
<a name="ln2393">  }</a>
<a name="ln2394">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2395">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_option&quot;);</a>
<a name="ln2396">  }</a>
<a name="ln2397">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2398">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2399">  }</a>
<a name="ln2400"> </a>
<a name="ln2401">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2402">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2403">  }</a>
<a name="ln2404"> </a>
<a name="ln2405">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2406">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln2407">  }</a>
<a name="ln2408"> </a>
<a name="ln2409">  nvim_buf_set_option(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln2410"> </a>
<a name="ln2411">  api_free_buffer(arg1);</a>
<a name="ln2412">exit_2:</a>
<a name="ln2413">  api_free_string(arg2);</a>
<a name="ln2414">exit_1:</a>
<a name="ln2415">  api_free_object(arg3);</a>
<a name="ln2416"> </a>
<a name="ln2417">exit_0:</a>
<a name="ln2418">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2419">    luaL_where(lstate, 1);</a>
<a name="ln2420">    if (err_param) {</a>
<a name="ln2421">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2422">      lua_pushstring(lstate, err_param);</a>
<a name="ln2423">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2424">    }</a>
<a name="ln2425">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2426">    api_clear_error(&amp;err);</a>
<a name="ln2427">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2428">    return lua_error(lstate);</a>
<a name="ln2429">  }</a>
<a name="ln2430"> </a>
<a name="ln2431">  return 0;</a>
<a name="ln2432">}</a>
<a name="ln2433"> </a>
<a name="ln2434">static int nlua_api_nvim_win_get_option(lua_State *lstate)</a>
<a name="ln2435">{</a>
<a name="ln2436">  Error err = ERROR_INIT;</a>
<a name="ln2437">  char *err_param = 0;</a>
<a name="ln2438">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2439">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2440">    goto exit_0;</a>
<a name="ln2441">  }</a>
<a name="ln2442">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2443">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_option&quot;);</a>
<a name="ln2444">  }</a>
<a name="ln2445">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2446">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2447">  }</a>
<a name="ln2448"> </a>
<a name="ln2449">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln2450">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln2451">  }</a>
<a name="ln2452"> </a>
<a name="ln2453">  Arena arena = ARENA_EMPTY;</a>
<a name="ln2454">  const Object ret = nvim_win_get_option(arg1, arg2, &amp;arena, &amp;err);</a>
<a name="ln2455">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln2456">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln2457"> </a>
<a name="ln2458">  api_free_window(arg1);</a>
<a name="ln2459">exit_1:</a>
<a name="ln2460">  api_free_string(arg2);</a>
<a name="ln2461"> </a>
<a name="ln2462">exit_0:</a>
<a name="ln2463">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2464">    luaL_where(lstate, 1);</a>
<a name="ln2465">    if (err_param) {</a>
<a name="ln2466">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2467">      lua_pushstring(lstate, err_param);</a>
<a name="ln2468">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2469">    }</a>
<a name="ln2470">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2471">    api_clear_error(&amp;err);</a>
<a name="ln2472">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2473">    return lua_error(lstate);</a>
<a name="ln2474">  }</a>
<a name="ln2475"> </a>
<a name="ln2476">  return 1;</a>
<a name="ln2477">}</a>
<a name="ln2478"> </a>
<a name="ln2479">static int nlua_api_nvim_win_set_option(lua_State *lstate)</a>
<a name="ln2480">{</a>
<a name="ln2481">  Error err = ERROR_INIT;</a>
<a name="ln2482">  char *err_param = 0;</a>
<a name="ln2483">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2484">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2485">    goto exit_0;</a>
<a name="ln2486">  }</a>
<a name="ln2487">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2488">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_option&quot;);</a>
<a name="ln2489">  }</a>
<a name="ln2490">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2491">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln2492">  }</a>
<a name="ln2493"> </a>
<a name="ln2494">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2495">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln2496">  }</a>
<a name="ln2497"> </a>
<a name="ln2498">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln2499">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_2;</a>
<a name="ln2500">  }</a>
<a name="ln2501"> </a>
<a name="ln2502">  nvim_win_set_option(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;err);</a>
<a name="ln2503"> </a>
<a name="ln2504">  api_free_window(arg1);</a>
<a name="ln2505">exit_2:</a>
<a name="ln2506">  api_free_string(arg2);</a>
<a name="ln2507">exit_1:</a>
<a name="ln2508">  api_free_object(arg3);</a>
<a name="ln2509"> </a>
<a name="ln2510">exit_0:</a>
<a name="ln2511">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2512">    luaL_where(lstate, 1);</a>
<a name="ln2513">    if (err_param) {</a>
<a name="ln2514">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2515">      lua_pushstring(lstate, err_param);</a>
<a name="ln2516">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2517">    }</a>
<a name="ln2518">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2519">    api_clear_error(&amp;err);</a>
<a name="ln2520">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2521">    return lua_error(lstate);</a>
<a name="ln2522">  }</a>
<a name="ln2523"> </a>
<a name="ln2524">  return 0;</a>
<a name="ln2525">}</a>
<a name="ln2526"> </a>
<a name="ln2527">static int nlua_api_nvim_create_namespace(lua_State *lstate)</a>
<a name="ln2528">{</a>
<a name="ln2529">  Error err = ERROR_INIT;</a>
<a name="ln2530">  char *err_param = 0;</a>
<a name="ln2531">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln2532">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln2533">    goto exit_0;</a>
<a name="ln2534">  }</a>
<a name="ln2535">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2536">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_namespace&quot;);</a>
<a name="ln2537">  }</a>
<a name="ln2538">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2539">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln2540">  }</a>
<a name="ln2541"> </a>
<a name="ln2542">  const Integer ret = nvim_create_namespace(arg1);</a>
<a name="ln2543">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2544">api_free_integer(ret);</a>
<a name="ln2545"> </a>
<a name="ln2546">  api_free_string(arg1);</a>
<a name="ln2547"> </a>
<a name="ln2548">exit_0:</a>
<a name="ln2549">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2550">    luaL_where(lstate, 1);</a>
<a name="ln2551">    if (err_param) {</a>
<a name="ln2552">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2553">      lua_pushstring(lstate, err_param);</a>
<a name="ln2554">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2555">    }</a>
<a name="ln2556">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2557">    api_clear_error(&amp;err);</a>
<a name="ln2558">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2559">    return lua_error(lstate);</a>
<a name="ln2560">  }</a>
<a name="ln2561"> </a>
<a name="ln2562">  return 1;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">static int nlua_api_nvim_get_namespaces(lua_State *lstate)</a>
<a name="ln2566">{</a>
<a name="ln2567">  Error err = ERROR_INIT;</a>
<a name="ln2568">  char *err_param = 0;</a>
<a name="ln2569">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln2570">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln2571">    goto exit_0;</a>
<a name="ln2572">  }</a>
<a name="ln2573">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2574">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_namespaces&quot;);</a>
<a name="ln2575">  }</a>
<a name="ln2576">  const Dictionary ret = nvim_get_namespaces();</a>
<a name="ln2577">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln2578">api_free_dictionary(ret);</a>
<a name="ln2579"> </a>
<a name="ln2580"> </a>
<a name="ln2581">exit_0:</a>
<a name="ln2582">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2583">    luaL_where(lstate, 1);</a>
<a name="ln2584">    if (err_param) {</a>
<a name="ln2585">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2586">      lua_pushstring(lstate, err_param);</a>
<a name="ln2587">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2588">    }</a>
<a name="ln2589">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2590">    api_clear_error(&amp;err);</a>
<a name="ln2591">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2592">    return lua_error(lstate);</a>
<a name="ln2593">  }</a>
<a name="ln2594"> </a>
<a name="ln2595">  return 1;</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">static int nlua_api_nvim_buf_get_extmark_by_id(lua_State *lstate)</a>
<a name="ln2599">{</a>
<a name="ln2600">  Error err = ERROR_INIT;</a>
<a name="ln2601">  char *err_param = 0;</a>
<a name="ln2602">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2603">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2604">    goto exit_0;</a>
<a name="ln2605">  }</a>
<a name="ln2606">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2607">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_extmark_by_id&quot;);</a>
<a name="ln2608">  }</a>
<a name="ln2609">    const Dictionary arg4 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln2610">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln2611">  }</a>
<a name="ln2612"> </a>
<a name="ln2613">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2614">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_1;</a>
<a name="ln2615">  }</a>
<a name="ln2616"> </a>
<a name="ln2617">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2618">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2619">  }</a>
<a name="ln2620"> </a>
<a name="ln2621">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2622">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2623">  }</a>
<a name="ln2624"> </a>
<a name="ln2625">  const ArrayOf(Integer) ret = nvim_buf_get_extmark_by_id(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2626">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln2627">api_free_array(ret);</a>
<a name="ln2628"> </a>
<a name="ln2629">  api_free_buffer(arg1);</a>
<a name="ln2630">exit_3:</a>
<a name="ln2631">  api_free_integer(arg2);</a>
<a name="ln2632">exit_2:</a>
<a name="ln2633">  api_free_integer(arg3);</a>
<a name="ln2634">exit_1:</a>
<a name="ln2635">  api_free_dictionary(arg4);</a>
<a name="ln2636"> </a>
<a name="ln2637">exit_0:</a>
<a name="ln2638">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2639">    luaL_where(lstate, 1);</a>
<a name="ln2640">    if (err_param) {</a>
<a name="ln2641">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2642">      lua_pushstring(lstate, err_param);</a>
<a name="ln2643">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2644">    }</a>
<a name="ln2645">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2646">    api_clear_error(&amp;err);</a>
<a name="ln2647">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2648">    return lua_error(lstate);</a>
<a name="ln2649">  }</a>
<a name="ln2650"> </a>
<a name="ln2651">  return 1;</a>
<a name="ln2652">}</a>
<a name="ln2653"> </a>
<a name="ln2654">static int nlua_api_nvim_buf_get_extmarks(lua_State *lstate)</a>
<a name="ln2655">{</a>
<a name="ln2656">  Error err = ERROR_INIT;</a>
<a name="ln2657">  char *err_param = 0;</a>
<a name="ln2658">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2659">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2660">    goto exit_0;</a>
<a name="ln2661">  }</a>
<a name="ln2662">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2663">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_get_extmarks&quot;);</a>
<a name="ln2664">  }</a>
<a name="ln2665">    KeyDict_get_extmarks arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_get_extmarks_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2666">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2667">  }</a>
<a name="ln2668"> </a>
<a name="ln2669">    const Object arg4 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2670">  if (ERROR_SET(&amp;err)) {      err_param = &quot;end&quot;;      goto exit_1;</a>
<a name="ln2671">  }</a>
<a name="ln2672"> </a>
<a name="ln2673">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln2674">  if (ERROR_SET(&amp;err)) {      err_param = &quot;start&quot;;      goto exit_2;</a>
<a name="ln2675">  }</a>
<a name="ln2676"> </a>
<a name="ln2677">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2678">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_3;</a>
<a name="ln2679">  }</a>
<a name="ln2680"> </a>
<a name="ln2681">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2682">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2683">  }</a>
<a name="ln2684"> </a>
<a name="ln2685">  const Array ret = nvim_buf_get_extmarks(arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln2686">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln2687">api_free_array(ret);</a>
<a name="ln2688"> </a>
<a name="ln2689">  api_free_buffer(arg1);</a>
<a name="ln2690">exit_4:</a>
<a name="ln2691">  api_free_integer(arg2);</a>
<a name="ln2692">exit_3:</a>
<a name="ln2693">  api_free_object(arg3);</a>
<a name="ln2694">exit_2:</a>
<a name="ln2695">  api_free_object(arg4);</a>
<a name="ln2696">exit_1:</a>
<a name="ln2697">  api_free_keydict_get_extmarks(&amp;arg5);</a>
<a name="ln2698"> </a>
<a name="ln2699">exit_0:</a>
<a name="ln2700">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2701">    luaL_where(lstate, 1);</a>
<a name="ln2702">    if (err_param) {</a>
<a name="ln2703">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2704">      lua_pushstring(lstate, err_param);</a>
<a name="ln2705">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2706">    }</a>
<a name="ln2707">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2708">    api_clear_error(&amp;err);</a>
<a name="ln2709">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2710">    return lua_error(lstate);</a>
<a name="ln2711">  }</a>
<a name="ln2712"> </a>
<a name="ln2713">  return 1;</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">static int nlua_api_nvim_buf_set_extmark(lua_State *lstate)</a>
<a name="ln2717">{</a>
<a name="ln2718">  Error err = ERROR_INIT;</a>
<a name="ln2719">  char *err_param = 0;</a>
<a name="ln2720">  if (lua_gettop(lstate) != 5) {</a>
<a name="ln2721">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 5 arguments&quot;);</a>
<a name="ln2722">    goto exit_0;</a>
<a name="ln2723">  }</a>
<a name="ln2724">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2725">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_set_extmark&quot;);</a>
<a name="ln2726">  }</a>
<a name="ln2727">    KeyDict_set_extmark arg5 = { 0 }; nlua_pop_keydict(lstate, &amp;arg5, KeyDict_set_extmark_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2728">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2729">  }</a>
<a name="ln2730"> </a>
<a name="ln2731">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2732">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_1;</a>
<a name="ln2733">  }</a>
<a name="ln2734"> </a>
<a name="ln2735">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2736">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2737">  }</a>
<a name="ln2738"> </a>
<a name="ln2739">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2740">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_3;</a>
<a name="ln2741">  }</a>
<a name="ln2742"> </a>
<a name="ln2743">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2744">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_4;</a>
<a name="ln2745">  }</a>
<a name="ln2746"> </a>
<a name="ln2747">  const Integer ret = nvim_buf_set_extmark(arg1, arg2, arg3, arg4, &amp;arg5, &amp;err);</a>
<a name="ln2748">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2749">api_free_integer(ret);</a>
<a name="ln2750"> </a>
<a name="ln2751">  api_free_buffer(arg1);</a>
<a name="ln2752">exit_4:</a>
<a name="ln2753">  api_free_integer(arg2);</a>
<a name="ln2754">exit_3:</a>
<a name="ln2755">  api_free_integer(arg3);</a>
<a name="ln2756">exit_2:</a>
<a name="ln2757">  api_free_integer(arg4);</a>
<a name="ln2758">exit_1:</a>
<a name="ln2759">  api_free_keydict_set_extmark(&amp;arg5);</a>
<a name="ln2760"> </a>
<a name="ln2761">exit_0:</a>
<a name="ln2762">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2763">    luaL_where(lstate, 1);</a>
<a name="ln2764">    if (err_param) {</a>
<a name="ln2765">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2766">      lua_pushstring(lstate, err_param);</a>
<a name="ln2767">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2768">    }</a>
<a name="ln2769">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2770">    api_clear_error(&amp;err);</a>
<a name="ln2771">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2772">    return lua_error(lstate);</a>
<a name="ln2773">  }</a>
<a name="ln2774"> </a>
<a name="ln2775">  return 1;</a>
<a name="ln2776">}</a>
<a name="ln2777"> </a>
<a name="ln2778">static int nlua_api_nvim_buf_del_extmark(lua_State *lstate)</a>
<a name="ln2779">{</a>
<a name="ln2780">  Error err = ERROR_INIT;</a>
<a name="ln2781">  char *err_param = 0;</a>
<a name="ln2782">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2783">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2784">    goto exit_0;</a>
<a name="ln2785">  }</a>
<a name="ln2786">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2787">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_del_extmark&quot;);</a>
<a name="ln2788">  }</a>
<a name="ln2789">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2790">  if (ERROR_SET(&amp;err)) {      err_param = &quot;id&quot;;      goto exit_0;</a>
<a name="ln2791">  }</a>
<a name="ln2792"> </a>
<a name="ln2793">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2794">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln2795">  }</a>
<a name="ln2796"> </a>
<a name="ln2797">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2798">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln2799">  }</a>
<a name="ln2800"> </a>
<a name="ln2801">  const Boolean ret = nvim_buf_del_extmark(arg1, arg2, arg3, &amp;err);</a>
<a name="ln2802">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln2803">api_free_boolean(ret);</a>
<a name="ln2804"> </a>
<a name="ln2805">  api_free_buffer(arg1);</a>
<a name="ln2806">exit_2:</a>
<a name="ln2807">  api_free_integer(arg2);</a>
<a name="ln2808">exit_1:</a>
<a name="ln2809">  api_free_integer(arg3);</a>
<a name="ln2810"> </a>
<a name="ln2811">exit_0:</a>
<a name="ln2812">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2813">    luaL_where(lstate, 1);</a>
<a name="ln2814">    if (err_param) {</a>
<a name="ln2815">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2816">      lua_pushstring(lstate, err_param);</a>
<a name="ln2817">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2818">    }</a>
<a name="ln2819">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2820">    api_clear_error(&amp;err);</a>
<a name="ln2821">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2822">    return lua_error(lstate);</a>
<a name="ln2823">  }</a>
<a name="ln2824"> </a>
<a name="ln2825">  return 1;</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828">static int nlua_api_nvim_buf_add_highlight(lua_State *lstate)</a>
<a name="ln2829">{</a>
<a name="ln2830">  Error err = ERROR_INIT;</a>
<a name="ln2831">  char *err_param = 0;</a>
<a name="ln2832">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln2833">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln2834">    goto exit_0;</a>
<a name="ln2835">  }</a>
<a name="ln2836">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2837">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_add_highlight&quot;);</a>
<a name="ln2838">  }</a>
<a name="ln2839">    const Integer arg6 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2840">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col_end&quot;;      goto exit_0;</a>
<a name="ln2841">  }</a>
<a name="ln2842"> </a>
<a name="ln2843">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2844">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col_start&quot;;      goto exit_1;</a>
<a name="ln2845">  }</a>
<a name="ln2846"> </a>
<a name="ln2847">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2848">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_2;</a>
<a name="ln2849">  }</a>
<a name="ln2850"> </a>
<a name="ln2851">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln2852">  if (ERROR_SET(&amp;err)) {      err_param = &quot;hl_group&quot;;      goto exit_3;</a>
<a name="ln2853">  }</a>
<a name="ln2854"> </a>
<a name="ln2855">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2856">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_4;</a>
<a name="ln2857">  }</a>
<a name="ln2858"> </a>
<a name="ln2859">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2860">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_5;</a>
<a name="ln2861">  }</a>
<a name="ln2862"> </a>
<a name="ln2863">  const Integer ret = nvim_buf_add_highlight(arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln2864">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln2865">api_free_integer(ret);</a>
<a name="ln2866"> </a>
<a name="ln2867">  api_free_buffer(arg1);</a>
<a name="ln2868">exit_5:</a>
<a name="ln2869">  api_free_integer(arg2);</a>
<a name="ln2870">exit_4:</a>
<a name="ln2871">  api_free_string(arg3);</a>
<a name="ln2872">exit_3:</a>
<a name="ln2873">  api_free_integer(arg4);</a>
<a name="ln2874">exit_2:</a>
<a name="ln2875">  api_free_integer(arg5);</a>
<a name="ln2876">exit_1:</a>
<a name="ln2877">  api_free_integer(arg6);</a>
<a name="ln2878"> </a>
<a name="ln2879">exit_0:</a>
<a name="ln2880">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2881">    luaL_where(lstate, 1);</a>
<a name="ln2882">    if (err_param) {</a>
<a name="ln2883">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2884">      lua_pushstring(lstate, err_param);</a>
<a name="ln2885">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2886">    }</a>
<a name="ln2887">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2888">    api_clear_error(&amp;err);</a>
<a name="ln2889">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2890">    return lua_error(lstate);</a>
<a name="ln2891">  }</a>
<a name="ln2892"> </a>
<a name="ln2893">  return 1;</a>
<a name="ln2894">}</a>
<a name="ln2895"> </a>
<a name="ln2896">static int nlua_api_nvim_buf_clear_namespace(lua_State *lstate)</a>
<a name="ln2897">{</a>
<a name="ln2898">  Error err = ERROR_INIT;</a>
<a name="ln2899">  char *err_param = 0;</a>
<a name="ln2900">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln2901">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln2902">    goto exit_0;</a>
<a name="ln2903">  }</a>
<a name="ln2904">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2905">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_buf_clear_namespace&quot;);</a>
<a name="ln2906">  }</a>
<a name="ln2907">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2908">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_end&quot;;      goto exit_0;</a>
<a name="ln2909">  }</a>
<a name="ln2910"> </a>
<a name="ln2911">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2912">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line_start&quot;;      goto exit_1;</a>
<a name="ln2913">  }</a>
<a name="ln2914"> </a>
<a name="ln2915">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2916">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln2917">  }</a>
<a name="ln2918"> </a>
<a name="ln2919">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln2920">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_3;</a>
<a name="ln2921">  }</a>
<a name="ln2922"> </a>
<a name="ln2923">  nvim_buf_clear_namespace(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln2924"> </a>
<a name="ln2925">  api_free_buffer(arg1);</a>
<a name="ln2926">exit_3:</a>
<a name="ln2927">  api_free_integer(arg2);</a>
<a name="ln2928">exit_2:</a>
<a name="ln2929">  api_free_integer(arg3);</a>
<a name="ln2930">exit_1:</a>
<a name="ln2931">  api_free_integer(arg4);</a>
<a name="ln2932"> </a>
<a name="ln2933">exit_0:</a>
<a name="ln2934">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2935">    luaL_where(lstate, 1);</a>
<a name="ln2936">    if (err_param) {</a>
<a name="ln2937">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2938">      lua_pushstring(lstate, err_param);</a>
<a name="ln2939">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2940">    }</a>
<a name="ln2941">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2942">    api_clear_error(&amp;err);</a>
<a name="ln2943">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2944">    return lua_error(lstate);</a>
<a name="ln2945">  }</a>
<a name="ln2946"> </a>
<a name="ln2947">  return 0;</a>
<a name="ln2948">}</a>
<a name="ln2949"> </a>
<a name="ln2950">static int nlua_api_nvim_set_decoration_provider(lua_State *lstate)</a>
<a name="ln2951">{</a>
<a name="ln2952">  Error err = ERROR_INIT;</a>
<a name="ln2953">  char *err_param = 0;</a>
<a name="ln2954">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln2955">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln2956">    goto exit_0;</a>
<a name="ln2957">  }</a>
<a name="ln2958">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln2959">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_decoration_provider&quot;);</a>
<a name="ln2960">  }</a>
<a name="ln2961">    KeyDict_set_decoration_provider arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_set_decoration_provider_get_field, &amp;err_param, &amp;err);</a>
<a name="ln2962">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln2963">  }</a>
<a name="ln2964"> </a>
<a name="ln2965">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln2966">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln2967">  }</a>
<a name="ln2968"> </a>
<a name="ln2969">  nvim_set_decoration_provider(arg1, &amp;arg2, &amp;err);</a>
<a name="ln2970"> </a>
<a name="ln2971">  api_free_integer(arg1);</a>
<a name="ln2972">exit_1:</a>
<a name="ln2973">  api_free_keydict_set_decoration_provider(&amp;arg2);</a>
<a name="ln2974"> </a>
<a name="ln2975">exit_0:</a>
<a name="ln2976">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln2977">    luaL_where(lstate, 1);</a>
<a name="ln2978">    if (err_param) {</a>
<a name="ln2979">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln2980">      lua_pushstring(lstate, err_param);</a>
<a name="ln2981">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln2982">    }</a>
<a name="ln2983">    lua_pushstring(lstate, err.msg);</a>
<a name="ln2984">    api_clear_error(&amp;err);</a>
<a name="ln2985">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln2986">    return lua_error(lstate);</a>
<a name="ln2987">  }</a>
<a name="ln2988"> </a>
<a name="ln2989">  return 0;</a>
<a name="ln2990">}</a>
<a name="ln2991"> </a>
<a name="ln2992">static int nlua_api_nvim__buf_debug_extmarks(lua_State *lstate)</a>
<a name="ln2993">{</a>
<a name="ln2994">  Error err = ERROR_INIT;</a>
<a name="ln2995">  char *err_param = 0;</a>
<a name="ln2996">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln2997">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln2998">    goto exit_0;</a>
<a name="ln2999">  }</a>
<a name="ln3000">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3001">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__buf_debug_extmarks&quot;);</a>
<a name="ln3002">  }</a>
<a name="ln3003">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3004">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dot&quot;;      goto exit_0;</a>
<a name="ln3005">  }</a>
<a name="ln3006"> </a>
<a name="ln3007">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3008">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_1;</a>
<a name="ln3009">  }</a>
<a name="ln3010"> </a>
<a name="ln3011">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln3012">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln3013">  }</a>
<a name="ln3014"> </a>
<a name="ln3015">  const String ret = nvim__buf_debug_extmarks(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3016">  nlua_push_String(lstate, ret, true);</a>
<a name="ln3017">api_free_string(ret);</a>
<a name="ln3018"> </a>
<a name="ln3019">  api_free_buffer(arg1);</a>
<a name="ln3020">exit_2:</a>
<a name="ln3021">  api_free_boolean(arg2);</a>
<a name="ln3022">exit_1:</a>
<a name="ln3023">  api_free_boolean(arg3);</a>
<a name="ln3024"> </a>
<a name="ln3025">exit_0:</a>
<a name="ln3026">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3027">    luaL_where(lstate, 1);</a>
<a name="ln3028">    if (err_param) {</a>
<a name="ln3029">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3030">      lua_pushstring(lstate, err_param);</a>
<a name="ln3031">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3032">    }</a>
<a name="ln3033">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3034">    api_clear_error(&amp;err);</a>
<a name="ln3035">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3036">    return lua_error(lstate);</a>
<a name="ln3037">  }</a>
<a name="ln3038"> </a>
<a name="ln3039">  return 1;</a>
<a name="ln3040">}</a>
<a name="ln3041"> </a>
<a name="ln3042">static int nlua_api_nvim_get_option_value(lua_State *lstate)</a>
<a name="ln3043">{</a>
<a name="ln3044">  Error err = ERROR_INIT;</a>
<a name="ln3045">  char *err_param = 0;</a>
<a name="ln3046">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3047">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3048">    goto exit_0;</a>
<a name="ln3049">  }</a>
<a name="ln3050">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3051">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_value&quot;);</a>
<a name="ln3052">  }</a>
<a name="ln3053">    KeyDict_option arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3054">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3055">  }</a>
<a name="ln3056"> </a>
<a name="ln3057">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3058">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3059">  }</a>
<a name="ln3060"> </a>
<a name="ln3061">  const Object ret = nvim_get_option_value(arg1, &amp;arg2, &amp;err);</a>
<a name="ln3062">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3063">api_free_object(ret);</a>
<a name="ln3064"> </a>
<a name="ln3065">  api_free_string(arg1);</a>
<a name="ln3066">exit_1:</a>
<a name="ln3067">  api_free_keydict_option(&amp;arg2);</a>
<a name="ln3068"> </a>
<a name="ln3069">exit_0:</a>
<a name="ln3070">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3071">    luaL_where(lstate, 1);</a>
<a name="ln3072">    if (err_param) {</a>
<a name="ln3073">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3074">      lua_pushstring(lstate, err_param);</a>
<a name="ln3075">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3076">    }</a>
<a name="ln3077">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3078">    api_clear_error(&amp;err);</a>
<a name="ln3079">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3080">    return lua_error(lstate);</a>
<a name="ln3081">  }</a>
<a name="ln3082"> </a>
<a name="ln3083">  return 1;</a>
<a name="ln3084">}</a>
<a name="ln3085"> </a>
<a name="ln3086">static int nlua_api_nvim_set_option_value(lua_State *lstate)</a>
<a name="ln3087">{</a>
<a name="ln3088">  Error err = ERROR_INIT;</a>
<a name="ln3089">  char *err_param = 0;</a>
<a name="ln3090">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3091">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3092">    goto exit_0;</a>
<a name="ln3093">  }</a>
<a name="ln3094">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3095">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_option_value&quot;);</a>
<a name="ln3096">  }</a>
<a name="ln3097">    KeyDict_option arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3098">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3099">  }</a>
<a name="ln3100"> </a>
<a name="ln3101">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln3102">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_1;</a>
<a name="ln3103">  }</a>
<a name="ln3104"> </a>
<a name="ln3105">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3106">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_2;</a>
<a name="ln3107">  }</a>
<a name="ln3108"> </a>
<a name="ln3109">  nvim_set_option_value(LUA_INTERNAL_CALL, arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln3110"> </a>
<a name="ln3111">  api_free_string(arg1);</a>
<a name="ln3112">exit_2:</a>
<a name="ln3113">  api_free_object(arg2);</a>
<a name="ln3114">exit_1:</a>
<a name="ln3115">  api_free_keydict_option(&amp;arg3);</a>
<a name="ln3116"> </a>
<a name="ln3117">exit_0:</a>
<a name="ln3118">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3119">    luaL_where(lstate, 1);</a>
<a name="ln3120">    if (err_param) {</a>
<a name="ln3121">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3122">      lua_pushstring(lstate, err_param);</a>
<a name="ln3123">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3124">    }</a>
<a name="ln3125">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3126">    api_clear_error(&amp;err);</a>
<a name="ln3127">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3128">    return lua_error(lstate);</a>
<a name="ln3129">  }</a>
<a name="ln3130"> </a>
<a name="ln3131">  return 0;</a>
<a name="ln3132">}</a>
<a name="ln3133"> </a>
<a name="ln3134">static int nlua_api_nvim_get_all_options_info(lua_State *lstate)</a>
<a name="ln3135">{</a>
<a name="ln3136">  Error err = ERROR_INIT;</a>
<a name="ln3137">  char *err_param = 0;</a>
<a name="ln3138">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln3139">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln3140">    goto exit_0;</a>
<a name="ln3141">  }</a>
<a name="ln3142">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3143">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_all_options_info&quot;);</a>
<a name="ln3144">  }</a>
<a name="ln3145">  const Dictionary ret = nvim_get_all_options_info(&amp;err);</a>
<a name="ln3146">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln3147">api_free_dictionary(ret);</a>
<a name="ln3148"> </a>
<a name="ln3149"> </a>
<a name="ln3150">exit_0:</a>
<a name="ln3151">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3152">    luaL_where(lstate, 1);</a>
<a name="ln3153">    if (err_param) {</a>
<a name="ln3154">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3155">      lua_pushstring(lstate, err_param);</a>
<a name="ln3156">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3157">    }</a>
<a name="ln3158">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3159">    api_clear_error(&amp;err);</a>
<a name="ln3160">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3161">    return lua_error(lstate);</a>
<a name="ln3162">  }</a>
<a name="ln3163"> </a>
<a name="ln3164">  return 1;</a>
<a name="ln3165">}</a>
<a name="ln3166"> </a>
<a name="ln3167">static int nlua_api_nvim_get_option_info2(lua_State *lstate)</a>
<a name="ln3168">{</a>
<a name="ln3169">  Error err = ERROR_INIT;</a>
<a name="ln3170">  char *err_param = 0;</a>
<a name="ln3171">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3172">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3173">    goto exit_0;</a>
<a name="ln3174">  }</a>
<a name="ln3175">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3176">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_option_info2&quot;);</a>
<a name="ln3177">  }</a>
<a name="ln3178">    KeyDict_option arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_option_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3179">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3180">  }</a>
<a name="ln3181"> </a>
<a name="ln3182">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3183">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3184">  }</a>
<a name="ln3185"> </a>
<a name="ln3186">  const Dictionary ret = nvim_get_option_info2(arg1, &amp;arg2, &amp;err);</a>
<a name="ln3187">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln3188">api_free_dictionary(ret);</a>
<a name="ln3189"> </a>
<a name="ln3190">  api_free_string(arg1);</a>
<a name="ln3191">exit_1:</a>
<a name="ln3192">  api_free_keydict_option(&amp;arg2);</a>
<a name="ln3193"> </a>
<a name="ln3194">exit_0:</a>
<a name="ln3195">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3196">    luaL_where(lstate, 1);</a>
<a name="ln3197">    if (err_param) {</a>
<a name="ln3198">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3199">      lua_pushstring(lstate, err_param);</a>
<a name="ln3200">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3201">    }</a>
<a name="ln3202">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3203">    api_clear_error(&amp;err);</a>
<a name="ln3204">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3205">    return lua_error(lstate);</a>
<a name="ln3206">  }</a>
<a name="ln3207"> </a>
<a name="ln3208">  return 1;</a>
<a name="ln3209">}</a>
<a name="ln3210"> </a>
<a name="ln3211">static int nlua_api_nvim_tabpage_list_wins(lua_State *lstate)</a>
<a name="ln3212">{</a>
<a name="ln3213">  Error err = ERROR_INIT;</a>
<a name="ln3214">  char *err_param = 0;</a>
<a name="ln3215">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3216">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3217">    goto exit_0;</a>
<a name="ln3218">  }</a>
<a name="ln3219">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3220">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_list_wins&quot;);</a>
<a name="ln3221">  }</a>
<a name="ln3222">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3223">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3224">  }</a>
<a name="ln3225"> </a>
<a name="ln3226">  const ArrayOf(Window) ret = nvim_tabpage_list_wins(arg1, &amp;err);</a>
<a name="ln3227">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln3228">api_free_array(ret);</a>
<a name="ln3229"> </a>
<a name="ln3230">  api_free_tabpage(arg1);</a>
<a name="ln3231"> </a>
<a name="ln3232">exit_0:</a>
<a name="ln3233">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3234">    luaL_where(lstate, 1);</a>
<a name="ln3235">    if (err_param) {</a>
<a name="ln3236">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3237">      lua_pushstring(lstate, err_param);</a>
<a name="ln3238">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3239">    }</a>
<a name="ln3240">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3241">    api_clear_error(&amp;err);</a>
<a name="ln3242">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3243">    return lua_error(lstate);</a>
<a name="ln3244">  }</a>
<a name="ln3245"> </a>
<a name="ln3246">  return 1;</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">static int nlua_api_nvim_tabpage_get_var(lua_State *lstate)</a>
<a name="ln3250">{</a>
<a name="ln3251">  Error err = ERROR_INIT;</a>
<a name="ln3252">  char *err_param = 0;</a>
<a name="ln3253">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3254">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3255">    goto exit_0;</a>
<a name="ln3256">  }</a>
<a name="ln3257">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3258">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_var&quot;);</a>
<a name="ln3259">  }</a>
<a name="ln3260">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3261">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3262">  }</a>
<a name="ln3263"> </a>
<a name="ln3264">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3265">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_1;</a>
<a name="ln3266">  }</a>
<a name="ln3267"> </a>
<a name="ln3268">  const Object ret = nvim_tabpage_get_var(arg1, arg2, &amp;err);</a>
<a name="ln3269">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3270">api_free_object(ret);</a>
<a name="ln3271"> </a>
<a name="ln3272">  api_free_tabpage(arg1);</a>
<a name="ln3273">exit_1:</a>
<a name="ln3274">  api_free_string(arg2);</a>
<a name="ln3275"> </a>
<a name="ln3276">exit_0:</a>
<a name="ln3277">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3278">    luaL_where(lstate, 1);</a>
<a name="ln3279">    if (err_param) {</a>
<a name="ln3280">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3281">      lua_pushstring(lstate, err_param);</a>
<a name="ln3282">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3283">    }</a>
<a name="ln3284">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3285">    api_clear_error(&amp;err);</a>
<a name="ln3286">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3287">    return lua_error(lstate);</a>
<a name="ln3288">  }</a>
<a name="ln3289"> </a>
<a name="ln3290">  return 1;</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">static int nlua_api_nvim_tabpage_set_var(lua_State *lstate)</a>
<a name="ln3294">{</a>
<a name="ln3295">  Error err = ERROR_INIT;</a>
<a name="ln3296">  char *err_param = 0;</a>
<a name="ln3297">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3298">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3299">    goto exit_0;</a>
<a name="ln3300">  }</a>
<a name="ln3301">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3302">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_set_var&quot;);</a>
<a name="ln3303">  }</a>
<a name="ln3304">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln3305">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln3306">  }</a>
<a name="ln3307"> </a>
<a name="ln3308">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3309">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3310">  }</a>
<a name="ln3311"> </a>
<a name="ln3312">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3313">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_2;</a>
<a name="ln3314">  }</a>
<a name="ln3315"> </a>
<a name="ln3316">  nvim_tabpage_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3317"> </a>
<a name="ln3318">  api_free_tabpage(arg1);</a>
<a name="ln3319">exit_2:</a>
<a name="ln3320">  api_free_string(arg2);</a>
<a name="ln3321">exit_1:</a>
<a name="ln3322">  api_free_object(arg3);</a>
<a name="ln3323"> </a>
<a name="ln3324">exit_0:</a>
<a name="ln3325">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3326">    luaL_where(lstate, 1);</a>
<a name="ln3327">    if (err_param) {</a>
<a name="ln3328">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3329">      lua_pushstring(lstate, err_param);</a>
<a name="ln3330">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3331">    }</a>
<a name="ln3332">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3333">    api_clear_error(&amp;err);</a>
<a name="ln3334">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3335">    return lua_error(lstate);</a>
<a name="ln3336">  }</a>
<a name="ln3337"> </a>
<a name="ln3338">  return 0;</a>
<a name="ln3339">}</a>
<a name="ln3340"> </a>
<a name="ln3341">static int nlua_api_nvim_tabpage_del_var(lua_State *lstate)</a>
<a name="ln3342">{</a>
<a name="ln3343">  Error err = ERROR_INIT;</a>
<a name="ln3344">  char *err_param = 0;</a>
<a name="ln3345">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3346">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3347">    goto exit_0;</a>
<a name="ln3348">  }</a>
<a name="ln3349">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3350">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_del_var&quot;);</a>
<a name="ln3351">  }</a>
<a name="ln3352">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3353">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3354">  }</a>
<a name="ln3355"> </a>
<a name="ln3356">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3357">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_1;</a>
<a name="ln3358">  }</a>
<a name="ln3359"> </a>
<a name="ln3360">  nvim_tabpage_del_var(arg1, arg2, &amp;err);</a>
<a name="ln3361"> </a>
<a name="ln3362">  api_free_tabpage(arg1);</a>
<a name="ln3363">exit_1:</a>
<a name="ln3364">  api_free_string(arg2);</a>
<a name="ln3365"> </a>
<a name="ln3366">exit_0:</a>
<a name="ln3367">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3368">    luaL_where(lstate, 1);</a>
<a name="ln3369">    if (err_param) {</a>
<a name="ln3370">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3371">      lua_pushstring(lstate, err_param);</a>
<a name="ln3372">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3373">    }</a>
<a name="ln3374">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3375">    api_clear_error(&amp;err);</a>
<a name="ln3376">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3377">    return lua_error(lstate);</a>
<a name="ln3378">  }</a>
<a name="ln3379"> </a>
<a name="ln3380">  return 0;</a>
<a name="ln3381">}</a>
<a name="ln3382"> </a>
<a name="ln3383">static int nlua_api_nvim_tabpage_get_win(lua_State *lstate)</a>
<a name="ln3384">{</a>
<a name="ln3385">  Error err = ERROR_INIT;</a>
<a name="ln3386">  char *err_param = 0;</a>
<a name="ln3387">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3388">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3389">    goto exit_0;</a>
<a name="ln3390">  }</a>
<a name="ln3391">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3392">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_win&quot;);</a>
<a name="ln3393">  }</a>
<a name="ln3394">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3395">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3396">  }</a>
<a name="ln3397"> </a>
<a name="ln3398">  const Window ret = nvim_tabpage_get_win(arg1, &amp;err);</a>
<a name="ln3399">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln3400">api_free_window(ret);</a>
<a name="ln3401"> </a>
<a name="ln3402">  api_free_tabpage(arg1);</a>
<a name="ln3403"> </a>
<a name="ln3404">exit_0:</a>
<a name="ln3405">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3406">    luaL_where(lstate, 1);</a>
<a name="ln3407">    if (err_param) {</a>
<a name="ln3408">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3409">      lua_pushstring(lstate, err_param);</a>
<a name="ln3410">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3411">    }</a>
<a name="ln3412">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3413">    api_clear_error(&amp;err);</a>
<a name="ln3414">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3415">    return lua_error(lstate);</a>
<a name="ln3416">  }</a>
<a name="ln3417"> </a>
<a name="ln3418">  return 1;</a>
<a name="ln3419">}</a>
<a name="ln3420"> </a>
<a name="ln3421">static int nlua_api_nvim_tabpage_get_number(lua_State *lstate)</a>
<a name="ln3422">{</a>
<a name="ln3423">  Error err = ERROR_INIT;</a>
<a name="ln3424">  char *err_param = 0;</a>
<a name="ln3425">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3426">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3427">    goto exit_0;</a>
<a name="ln3428">  }</a>
<a name="ln3429">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3430">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_get_number&quot;);</a>
<a name="ln3431">  }</a>
<a name="ln3432">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3433">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3434">  }</a>
<a name="ln3435"> </a>
<a name="ln3436">  const Integer ret = nvim_tabpage_get_number(arg1, &amp;err);</a>
<a name="ln3437">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3438">api_free_integer(ret);</a>
<a name="ln3439"> </a>
<a name="ln3440">  api_free_tabpage(arg1);</a>
<a name="ln3441"> </a>
<a name="ln3442">exit_0:</a>
<a name="ln3443">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3444">    luaL_where(lstate, 1);</a>
<a name="ln3445">    if (err_param) {</a>
<a name="ln3446">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3447">      lua_pushstring(lstate, err_param);</a>
<a name="ln3448">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3449">    }</a>
<a name="ln3450">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3451">    api_clear_error(&amp;err);</a>
<a name="ln3452">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3453">    return lua_error(lstate);</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456">  return 1;</a>
<a name="ln3457">}</a>
<a name="ln3458"> </a>
<a name="ln3459">static int nlua_api_nvim_tabpage_is_valid(lua_State *lstate)</a>
<a name="ln3460">{</a>
<a name="ln3461">  Error err = ERROR_INIT;</a>
<a name="ln3462">  char *err_param = 0;</a>
<a name="ln3463">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3464">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3465">    goto exit_0;</a>
<a name="ln3466">  }</a>
<a name="ln3467">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3468">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_tabpage_is_valid&quot;);</a>
<a name="ln3469">  }</a>
<a name="ln3470">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln3471">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln3472">  }</a>
<a name="ln3473"> </a>
<a name="ln3474">  const Boolean ret = nvim_tabpage_is_valid(arg1);</a>
<a name="ln3475">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln3476">api_free_boolean(ret);</a>
<a name="ln3477"> </a>
<a name="ln3478">  api_free_tabpage(arg1);</a>
<a name="ln3479"> </a>
<a name="ln3480">exit_0:</a>
<a name="ln3481">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3482">    luaL_where(lstate, 1);</a>
<a name="ln3483">    if (err_param) {</a>
<a name="ln3484">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3485">      lua_pushstring(lstate, err_param);</a>
<a name="ln3486">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3487">    }</a>
<a name="ln3488">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3489">    api_clear_error(&amp;err);</a>
<a name="ln3490">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3491">    return lua_error(lstate);</a>
<a name="ln3492">  }</a>
<a name="ln3493"> </a>
<a name="ln3494">  return 1;</a>
<a name="ln3495">}</a>
<a name="ln3496"> </a>
<a name="ln3497">static int nlua_api_nvim_get_hl_id_by_name(lua_State *lstate)</a>
<a name="ln3498">{</a>
<a name="ln3499">  Error err = ERROR_INIT;</a>
<a name="ln3500">  char *err_param = 0;</a>
<a name="ln3501">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3502">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3503">    goto exit_0;</a>
<a name="ln3504">  }</a>
<a name="ln3505">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3506">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_id_by_name&quot;);</a>
<a name="ln3507">  }</a>
<a name="ln3508">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3509">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln3510">  }</a>
<a name="ln3511"> </a>
<a name="ln3512">  const Integer ret = nvim_get_hl_id_by_name(arg1);</a>
<a name="ln3513">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3514">api_free_integer(ret);</a>
<a name="ln3515"> </a>
<a name="ln3516">  api_free_string(arg1);</a>
<a name="ln3517"> </a>
<a name="ln3518">exit_0:</a>
<a name="ln3519">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3520">    luaL_where(lstate, 1);</a>
<a name="ln3521">    if (err_param) {</a>
<a name="ln3522">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3523">      lua_pushstring(lstate, err_param);</a>
<a name="ln3524">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3525">    }</a>
<a name="ln3526">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3527">    api_clear_error(&amp;err);</a>
<a name="ln3528">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3529">    return lua_error(lstate);</a>
<a name="ln3530">  }</a>
<a name="ln3531"> </a>
<a name="ln3532">  return 1;</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">static int nlua_api_nvim_get_hl(lua_State *lstate)</a>
<a name="ln3536">{</a>
<a name="ln3537">  Error err = ERROR_INIT;</a>
<a name="ln3538">  char *err_param = 0;</a>
<a name="ln3539">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln3540">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln3541">    goto exit_0;</a>
<a name="ln3542">  }</a>
<a name="ln3543">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3544">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl&quot;);</a>
<a name="ln3545">  }</a>
<a name="ln3546">    KeyDict_get_highlight arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_get_highlight_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3547">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3548">  }</a>
<a name="ln3549"> </a>
<a name="ln3550">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3551">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_1;</a>
<a name="ln3552">  }</a>
<a name="ln3553"> </a>
<a name="ln3554">  Arena arena = ARENA_EMPTY;</a>
<a name="ln3555">  const Dictionary ret = nvim_get_hl(arg1, &amp;arg2, &amp;arena, &amp;err);</a>
<a name="ln3556">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln3557">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln3558"> </a>
<a name="ln3559">  api_free_integer(arg1);</a>
<a name="ln3560">exit_1:</a>
<a name="ln3561">  api_free_keydict_get_highlight(&amp;arg2);</a>
<a name="ln3562"> </a>
<a name="ln3563">exit_0:</a>
<a name="ln3564">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3565">    luaL_where(lstate, 1);</a>
<a name="ln3566">    if (err_param) {</a>
<a name="ln3567">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3568">      lua_pushstring(lstate, err_param);</a>
<a name="ln3569">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3570">    }</a>
<a name="ln3571">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3572">    api_clear_error(&amp;err);</a>
<a name="ln3573">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3574">    return lua_error(lstate);</a>
<a name="ln3575">  }</a>
<a name="ln3576"> </a>
<a name="ln3577">  return 1;</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">static int nlua_api_nvim_set_hl(lua_State *lstate)</a>
<a name="ln3581">{</a>
<a name="ln3582">  Error err = ERROR_INIT;</a>
<a name="ln3583">  char *err_param = 0;</a>
<a name="ln3584">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3585">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3586">    goto exit_0;</a>
<a name="ln3587">  }</a>
<a name="ln3588">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3589">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_hl&quot;);</a>
<a name="ln3590">  }</a>
<a name="ln3591">    KeyDict_highlight arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_highlight_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3592">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3593">  }</a>
<a name="ln3594"> </a>
<a name="ln3595">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3596">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln3597">  }</a>
<a name="ln3598"> </a>
<a name="ln3599">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3600">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_2;</a>
<a name="ln3601">  }</a>
<a name="ln3602"> </a>
<a name="ln3603">  nvim_set_hl(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln3604"> </a>
<a name="ln3605">  api_free_integer(arg1);</a>
<a name="ln3606">exit_2:</a>
<a name="ln3607">  api_free_string(arg2);</a>
<a name="ln3608">exit_1:</a>
<a name="ln3609">  api_free_keydict_highlight(&amp;arg3);</a>
<a name="ln3610"> </a>
<a name="ln3611">exit_0:</a>
<a name="ln3612">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3613">    luaL_where(lstate, 1);</a>
<a name="ln3614">    if (err_param) {</a>
<a name="ln3615">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3616">      lua_pushstring(lstate, err_param);</a>
<a name="ln3617">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3618">    }</a>
<a name="ln3619">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3620">    api_clear_error(&amp;err);</a>
<a name="ln3621">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3622">    return lua_error(lstate);</a>
<a name="ln3623">  }</a>
<a name="ln3624"> </a>
<a name="ln3625">  return 0;</a>
<a name="ln3626">}</a>
<a name="ln3627"> </a>
<a name="ln3628">static int nlua_api_nvim_get_hl_ns(lua_State *lstate)</a>
<a name="ln3629">{</a>
<a name="ln3630">  Error err = ERROR_INIT;</a>
<a name="ln3631">  char *err_param = 0;</a>
<a name="ln3632">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3633">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3634">    goto exit_0;</a>
<a name="ln3635">  }</a>
<a name="ln3636">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3637">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_hl_ns&quot;);</a>
<a name="ln3638">  }</a>
<a name="ln3639">    KeyDict_get_ns arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_get_ns_get_field, &amp;err_param, &amp;err);</a>
<a name="ln3640">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln3641">  }</a>
<a name="ln3642"> </a>
<a name="ln3643">  const Integer ret = nvim_get_hl_ns(&amp;arg1, &amp;err);</a>
<a name="ln3644">  nlua_push_Integer(lstate, ret, false);</a>
<a name="ln3645">api_free_integer(ret);</a>
<a name="ln3646"> </a>
<a name="ln3647">exit_1:</a>
<a name="ln3648">  api_free_keydict_get_ns(&amp;arg1);</a>
<a name="ln3649"> </a>
<a name="ln3650">exit_0:</a>
<a name="ln3651">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3652">    luaL_where(lstate, 1);</a>
<a name="ln3653">    if (err_param) {</a>
<a name="ln3654">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3655">      lua_pushstring(lstate, err_param);</a>
<a name="ln3656">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3657">    }</a>
<a name="ln3658">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3659">    api_clear_error(&amp;err);</a>
<a name="ln3660">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3661">    return lua_error(lstate);</a>
<a name="ln3662">  }</a>
<a name="ln3663"> </a>
<a name="ln3664">  return 1;</a>
<a name="ln3665">}</a>
<a name="ln3666"> </a>
<a name="ln3667">static int nlua_api_nvim_set_hl_ns(lua_State *lstate)</a>
<a name="ln3668">{</a>
<a name="ln3669">  Error err = ERROR_INIT;</a>
<a name="ln3670">  char *err_param = 0;</a>
<a name="ln3671">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3672">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3673">    goto exit_0;</a>
<a name="ln3674">  }</a>
<a name="ln3675">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3676">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_hl_ns&quot;);</a>
<a name="ln3677">  }</a>
<a name="ln3678">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3679">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln3680">  }</a>
<a name="ln3681"> </a>
<a name="ln3682">  nvim_set_hl_ns(arg1, &amp;err);</a>
<a name="ln3683"> </a>
<a name="ln3684">  api_free_integer(arg1);</a>
<a name="ln3685"> </a>
<a name="ln3686">exit_0:</a>
<a name="ln3687">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3688">    luaL_where(lstate, 1);</a>
<a name="ln3689">    if (err_param) {</a>
<a name="ln3690">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3691">      lua_pushstring(lstate, err_param);</a>
<a name="ln3692">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3693">    }</a>
<a name="ln3694">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3695">    api_clear_error(&amp;err);</a>
<a name="ln3696">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3697">    return lua_error(lstate);</a>
<a name="ln3698">  }</a>
<a name="ln3699"> </a>
<a name="ln3700">  return 0;</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">static int nlua_api_nvim_set_hl_ns_fast(lua_State *lstate)</a>
<a name="ln3704">{</a>
<a name="ln3705">  Error err = ERROR_INIT;</a>
<a name="ln3706">  char *err_param = 0;</a>
<a name="ln3707">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3708">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3709">    goto exit_0;</a>
<a name="ln3710">  }</a>
<a name="ln3711">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3712">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln3713">  }</a>
<a name="ln3714"> </a>
<a name="ln3715">  nvim_set_hl_ns_fast(arg1, &amp;err);</a>
<a name="ln3716"> </a>
<a name="ln3717">  api_free_integer(arg1);</a>
<a name="ln3718"> </a>
<a name="ln3719">exit_0:</a>
<a name="ln3720">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3721">    luaL_where(lstate, 1);</a>
<a name="ln3722">    if (err_param) {</a>
<a name="ln3723">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3724">      lua_pushstring(lstate, err_param);</a>
<a name="ln3725">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3726">    }</a>
<a name="ln3727">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3728">    api_clear_error(&amp;err);</a>
<a name="ln3729">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3730">    return lua_error(lstate);</a>
<a name="ln3731">  }</a>
<a name="ln3732"> </a>
<a name="ln3733">  return 0;</a>
<a name="ln3734">}</a>
<a name="ln3735"> </a>
<a name="ln3736">static int nlua_api_nvim_feedkeys(lua_State *lstate)</a>
<a name="ln3737">{</a>
<a name="ln3738">  Error err = ERROR_INIT;</a>
<a name="ln3739">  char *err_param = 0;</a>
<a name="ln3740">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3741">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3742">    goto exit_0;</a>
<a name="ln3743">  }</a>
<a name="ln3744">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3745">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_feedkeys&quot;);</a>
<a name="ln3746">  }</a>
<a name="ln3747">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3748">  if (ERROR_SET(&amp;err)) {      err_param = &quot;escape_ks&quot;;      goto exit_0;</a>
<a name="ln3749">  }</a>
<a name="ln3750"> </a>
<a name="ln3751">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3752">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln3753">  }</a>
<a name="ln3754"> </a>
<a name="ln3755">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3756">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_2;</a>
<a name="ln3757">  }</a>
<a name="ln3758"> </a>
<a name="ln3759">  nvim_feedkeys(arg1, arg2, arg3);</a>
<a name="ln3760"> </a>
<a name="ln3761">  api_free_string(arg1);</a>
<a name="ln3762">exit_2:</a>
<a name="ln3763">  api_free_string(arg2);</a>
<a name="ln3764">exit_1:</a>
<a name="ln3765">  api_free_boolean(arg3);</a>
<a name="ln3766"> </a>
<a name="ln3767">exit_0:</a>
<a name="ln3768">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3769">    luaL_where(lstate, 1);</a>
<a name="ln3770">    if (err_param) {</a>
<a name="ln3771">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3772">      lua_pushstring(lstate, err_param);</a>
<a name="ln3773">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3774">    }</a>
<a name="ln3775">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3776">    api_clear_error(&amp;err);</a>
<a name="ln3777">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3778">    return lua_error(lstate);</a>
<a name="ln3779">  }</a>
<a name="ln3780"> </a>
<a name="ln3781">  return 0;</a>
<a name="ln3782">}</a>
<a name="ln3783"> </a>
<a name="ln3784">static int nlua_api_nvim_input(lua_State *lstate)</a>
<a name="ln3785">{</a>
<a name="ln3786">  Error err = ERROR_INIT;</a>
<a name="ln3787">  char *err_param = 0;</a>
<a name="ln3788">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3789">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3790">    goto exit_0;</a>
<a name="ln3791">  }</a>
<a name="ln3792">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3793">  if (ERROR_SET(&amp;err)) {      err_param = &quot;keys&quot;;      goto exit_0;</a>
<a name="ln3794">  }</a>
<a name="ln3795"> </a>
<a name="ln3796">  const Integer ret = nvim_input(arg1);</a>
<a name="ln3797">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln3798">api_free_integer(ret);</a>
<a name="ln3799"> </a>
<a name="ln3800">  api_free_string(arg1);</a>
<a name="ln3801"> </a>
<a name="ln3802">exit_0:</a>
<a name="ln3803">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3804">    luaL_where(lstate, 1);</a>
<a name="ln3805">    if (err_param) {</a>
<a name="ln3806">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3807">      lua_pushstring(lstate, err_param);</a>
<a name="ln3808">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3809">    }</a>
<a name="ln3810">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3811">    api_clear_error(&amp;err);</a>
<a name="ln3812">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3813">    return lua_error(lstate);</a>
<a name="ln3814">  }</a>
<a name="ln3815"> </a>
<a name="ln3816">  return 1;</a>
<a name="ln3817">}</a>
<a name="ln3818"> </a>
<a name="ln3819">static int nlua_api_nvim_input_mouse(lua_State *lstate)</a>
<a name="ln3820">{</a>
<a name="ln3821">  Error err = ERROR_INIT;</a>
<a name="ln3822">  char *err_param = 0;</a>
<a name="ln3823">  if (lua_gettop(lstate) != 6) {</a>
<a name="ln3824">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 6 arguments&quot;);</a>
<a name="ln3825">    goto exit_0;</a>
<a name="ln3826">  }</a>
<a name="ln3827">    const Integer arg6 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3828">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_0;</a>
<a name="ln3829">  }</a>
<a name="ln3830"> </a>
<a name="ln3831">    const Integer arg5 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3832">  if (ERROR_SET(&amp;err)) {      err_param = &quot;row&quot;;      goto exit_1;</a>
<a name="ln3833">  }</a>
<a name="ln3834"> </a>
<a name="ln3835">    const Integer arg4 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3836">  if (ERROR_SET(&amp;err)) {      err_param = &quot;grid&quot;;      goto exit_2;</a>
<a name="ln3837">  }</a>
<a name="ln3838"> </a>
<a name="ln3839">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3840">  if (ERROR_SET(&amp;err)) {      err_param = &quot;modifier&quot;;      goto exit_3;</a>
<a name="ln3841">  }</a>
<a name="ln3842"> </a>
<a name="ln3843">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3844">  if (ERROR_SET(&amp;err)) {      err_param = &quot;action&quot;;      goto exit_4;</a>
<a name="ln3845">  }</a>
<a name="ln3846"> </a>
<a name="ln3847">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3848">  if (ERROR_SET(&amp;err)) {      err_param = &quot;button&quot;;      goto exit_5;</a>
<a name="ln3849">  }</a>
<a name="ln3850"> </a>
<a name="ln3851">  nvim_input_mouse(arg1, arg2, arg3, arg4, arg5, arg6, &amp;err);</a>
<a name="ln3852"> </a>
<a name="ln3853">  api_free_string(arg1);</a>
<a name="ln3854">exit_5:</a>
<a name="ln3855">  api_free_string(arg2);</a>
<a name="ln3856">exit_4:</a>
<a name="ln3857">  api_free_string(arg3);</a>
<a name="ln3858">exit_3:</a>
<a name="ln3859">  api_free_integer(arg4);</a>
<a name="ln3860">exit_2:</a>
<a name="ln3861">  api_free_integer(arg5);</a>
<a name="ln3862">exit_1:</a>
<a name="ln3863">  api_free_integer(arg6);</a>
<a name="ln3864"> </a>
<a name="ln3865">exit_0:</a>
<a name="ln3866">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3867">    luaL_where(lstate, 1);</a>
<a name="ln3868">    if (err_param) {</a>
<a name="ln3869">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3870">      lua_pushstring(lstate, err_param);</a>
<a name="ln3871">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3872">    }</a>
<a name="ln3873">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3874">    api_clear_error(&amp;err);</a>
<a name="ln3875">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3876">    return lua_error(lstate);</a>
<a name="ln3877">  }</a>
<a name="ln3878"> </a>
<a name="ln3879">  return 0;</a>
<a name="ln3880">}</a>
<a name="ln3881"> </a>
<a name="ln3882">static int nlua_api_nvim_replace_termcodes(lua_State *lstate)</a>
<a name="ln3883">{</a>
<a name="ln3884">  Error err = ERROR_INIT;</a>
<a name="ln3885">  char *err_param = 0;</a>
<a name="ln3886">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln3887">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln3888">    goto exit_0;</a>
<a name="ln3889">  }</a>
<a name="ln3890">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3891">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_replace_termcodes&quot;);</a>
<a name="ln3892">  }</a>
<a name="ln3893">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3894">  if (ERROR_SET(&amp;err)) {      err_param = &quot;special&quot;;      goto exit_0;</a>
<a name="ln3895">  }</a>
<a name="ln3896"> </a>
<a name="ln3897">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3898">  if (ERROR_SET(&amp;err)) {      err_param = &quot;do_lt&quot;;      goto exit_1;</a>
<a name="ln3899">  }</a>
<a name="ln3900"> </a>
<a name="ln3901">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln3902">  if (ERROR_SET(&amp;err)) {      err_param = &quot;from_part&quot;;      goto exit_2;</a>
<a name="ln3903">  }</a>
<a name="ln3904"> </a>
<a name="ln3905">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3906">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_3;</a>
<a name="ln3907">  }</a>
<a name="ln3908"> </a>
<a name="ln3909">  const String ret = nvim_replace_termcodes(arg1, arg2, arg3, arg4);</a>
<a name="ln3910">  nlua_push_String(lstate, ret, true);</a>
<a name="ln3911">api_free_string(ret);</a>
<a name="ln3912"> </a>
<a name="ln3913">  api_free_string(arg1);</a>
<a name="ln3914">exit_3:</a>
<a name="ln3915">  api_free_boolean(arg2);</a>
<a name="ln3916">exit_2:</a>
<a name="ln3917">  api_free_boolean(arg3);</a>
<a name="ln3918">exit_1:</a>
<a name="ln3919">  api_free_boolean(arg4);</a>
<a name="ln3920"> </a>
<a name="ln3921">exit_0:</a>
<a name="ln3922">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3923">    luaL_where(lstate, 1);</a>
<a name="ln3924">    if (err_param) {</a>
<a name="ln3925">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3926">      lua_pushstring(lstate, err_param);</a>
<a name="ln3927">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3928">    }</a>
<a name="ln3929">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3930">    api_clear_error(&amp;err);</a>
<a name="ln3931">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3932">    return lua_error(lstate);</a>
<a name="ln3933">  }</a>
<a name="ln3934"> </a>
<a name="ln3935">  return 1;</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">static int nlua_api_nvim_notify(lua_State *lstate)</a>
<a name="ln3939">{</a>
<a name="ln3940">  Error err = ERROR_INIT;</a>
<a name="ln3941">  char *err_param = 0;</a>
<a name="ln3942">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln3943">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln3944">    goto exit_0;</a>
<a name="ln3945">  }</a>
<a name="ln3946">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3947">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_notify&quot;);</a>
<a name="ln3948">  }</a>
<a name="ln3949">    const Dictionary arg3 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln3950">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln3951">  }</a>
<a name="ln3952"> </a>
<a name="ln3953">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln3954">  if (ERROR_SET(&amp;err)) {      err_param = &quot;log_level&quot;;      goto exit_1;</a>
<a name="ln3955">  }</a>
<a name="ln3956"> </a>
<a name="ln3957">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln3958">  if (ERROR_SET(&amp;err)) {      err_param = &quot;msg&quot;;      goto exit_2;</a>
<a name="ln3959">  }</a>
<a name="ln3960"> </a>
<a name="ln3961">  const Object ret = nvim_notify(arg1, arg2, arg3, &amp;err);</a>
<a name="ln3962">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln3963">api_free_object(ret);</a>
<a name="ln3964"> </a>
<a name="ln3965">  api_free_string(arg1);</a>
<a name="ln3966">exit_2:</a>
<a name="ln3967">  api_free_integer(arg2);</a>
<a name="ln3968">exit_1:</a>
<a name="ln3969">  api_free_dictionary(arg3);</a>
<a name="ln3970"> </a>
<a name="ln3971">exit_0:</a>
<a name="ln3972">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln3973">    luaL_where(lstate, 1);</a>
<a name="ln3974">    if (err_param) {</a>
<a name="ln3975">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln3976">      lua_pushstring(lstate, err_param);</a>
<a name="ln3977">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln3978">    }</a>
<a name="ln3979">    lua_pushstring(lstate, err.msg);</a>
<a name="ln3980">    api_clear_error(&amp;err);</a>
<a name="ln3981">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln3982">    return lua_error(lstate);</a>
<a name="ln3983">  }</a>
<a name="ln3984"> </a>
<a name="ln3985">  return 1;</a>
<a name="ln3986">}</a>
<a name="ln3987"> </a>
<a name="ln3988">static int nlua_api_nvim_strwidth(lua_State *lstate)</a>
<a name="ln3989">{</a>
<a name="ln3990">  Error err = ERROR_INIT;</a>
<a name="ln3991">  char *err_param = 0;</a>
<a name="ln3992">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln3993">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln3994">    goto exit_0;</a>
<a name="ln3995">  }</a>
<a name="ln3996">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln3997">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_strwidth&quot;);</a>
<a name="ln3998">  }</a>
<a name="ln3999">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4000">  if (ERROR_SET(&amp;err)) {      err_param = &quot;text&quot;;      goto exit_0;</a>
<a name="ln4001">  }</a>
<a name="ln4002"> </a>
<a name="ln4003">  const Integer ret = nvim_strwidth(arg1, &amp;err);</a>
<a name="ln4004">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln4005">api_free_integer(ret);</a>
<a name="ln4006"> </a>
<a name="ln4007">  api_free_string(arg1);</a>
<a name="ln4008"> </a>
<a name="ln4009">exit_0:</a>
<a name="ln4010">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4011">    luaL_where(lstate, 1);</a>
<a name="ln4012">    if (err_param) {</a>
<a name="ln4013">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4014">      lua_pushstring(lstate, err_param);</a>
<a name="ln4015">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4016">    }</a>
<a name="ln4017">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4018">    api_clear_error(&amp;err);</a>
<a name="ln4019">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4020">    return lua_error(lstate);</a>
<a name="ln4021">  }</a>
<a name="ln4022"> </a>
<a name="ln4023">  return 1;</a>
<a name="ln4024">}</a>
<a name="ln4025"> </a>
<a name="ln4026">static int nlua_api_nvim_list_runtime_paths(lua_State *lstate)</a>
<a name="ln4027">{</a>
<a name="ln4028">  Error err = ERROR_INIT;</a>
<a name="ln4029">  char *err_param = 0;</a>
<a name="ln4030">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4031">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4032">    goto exit_0;</a>
<a name="ln4033">  }</a>
<a name="ln4034">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4035">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_runtime_paths&quot;);</a>
<a name="ln4036">  }</a>
<a name="ln4037">  const ArrayOf(String) ret = nvim_list_runtime_paths(&amp;err);</a>
<a name="ln4038">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4039">api_free_array(ret);</a>
<a name="ln4040"> </a>
<a name="ln4041"> </a>
<a name="ln4042">exit_0:</a>
<a name="ln4043">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4044">    luaL_where(lstate, 1);</a>
<a name="ln4045">    if (err_param) {</a>
<a name="ln4046">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4047">      lua_pushstring(lstate, err_param);</a>
<a name="ln4048">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4049">    }</a>
<a name="ln4050">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4051">    api_clear_error(&amp;err);</a>
<a name="ln4052">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4053">    return lua_error(lstate);</a>
<a name="ln4054">  }</a>
<a name="ln4055"> </a>
<a name="ln4056">  return 1;</a>
<a name="ln4057">}</a>
<a name="ln4058"> </a>
<a name="ln4059">static int nlua_api_nvim__runtime_inspect(lua_State *lstate)</a>
<a name="ln4060">{</a>
<a name="ln4061">  Error err = ERROR_INIT;</a>
<a name="ln4062">  char *err_param = 0;</a>
<a name="ln4063">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4064">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4065">    goto exit_0;</a>
<a name="ln4066">  }</a>
<a name="ln4067">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4068">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__runtime_inspect&quot;);</a>
<a name="ln4069">  }</a>
<a name="ln4070">  const Array ret = nvim__runtime_inspect();</a>
<a name="ln4071">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4072">api_free_array(ret);</a>
<a name="ln4073"> </a>
<a name="ln4074"> </a>
<a name="ln4075">exit_0:</a>
<a name="ln4076">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4077">    luaL_where(lstate, 1);</a>
<a name="ln4078">    if (err_param) {</a>
<a name="ln4079">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4080">      lua_pushstring(lstate, err_param);</a>
<a name="ln4081">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4082">    }</a>
<a name="ln4083">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4084">    api_clear_error(&amp;err);</a>
<a name="ln4085">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4086">    return lua_error(lstate);</a>
<a name="ln4087">  }</a>
<a name="ln4088"> </a>
<a name="ln4089">  return 1;</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">static int nlua_api_nvim_get_runtime_file(lua_State *lstate)</a>
<a name="ln4093">{</a>
<a name="ln4094">  Error err = ERROR_INIT;</a>
<a name="ln4095">  char *err_param = 0;</a>
<a name="ln4096">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4097">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4098">    goto exit_0;</a>
<a name="ln4099">  }</a>
<a name="ln4100">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4101">  if (ERROR_SET(&amp;err)) {      err_param = &quot;all&quot;;      goto exit_0;</a>
<a name="ln4102">  }</a>
<a name="ln4103"> </a>
<a name="ln4104">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4105">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4106">  }</a>
<a name="ln4107"> </a>
<a name="ln4108">  const ArrayOf(String) ret = nvim_get_runtime_file(arg1, arg2, &amp;err);</a>
<a name="ln4109">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4110">api_free_array(ret);</a>
<a name="ln4111"> </a>
<a name="ln4112">  api_free_string(arg1);</a>
<a name="ln4113">exit_1:</a>
<a name="ln4114">  api_free_boolean(arg2);</a>
<a name="ln4115"> </a>
<a name="ln4116">exit_0:</a>
<a name="ln4117">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4118">    luaL_where(lstate, 1);</a>
<a name="ln4119">    if (err_param) {</a>
<a name="ln4120">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4121">      lua_pushstring(lstate, err_param);</a>
<a name="ln4122">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4123">    }</a>
<a name="ln4124">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4125">    api_clear_error(&amp;err);</a>
<a name="ln4126">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4127">    return lua_error(lstate);</a>
<a name="ln4128">  }</a>
<a name="ln4129"> </a>
<a name="ln4130">  return 1;</a>
<a name="ln4131">}</a>
<a name="ln4132"> </a>
<a name="ln4133">static int nlua_api_nvim__get_lib_dir(lua_State *lstate)</a>
<a name="ln4134">{</a>
<a name="ln4135">  Error err = ERROR_INIT;</a>
<a name="ln4136">  char *err_param = 0;</a>
<a name="ln4137">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4138">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4139">    goto exit_0;</a>
<a name="ln4140">  }</a>
<a name="ln4141">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4142">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__get_lib_dir&quot;);</a>
<a name="ln4143">  }</a>
<a name="ln4144">  const String ret = nvim__get_lib_dir();</a>
<a name="ln4145">  nlua_push_String(lstate, ret, true);</a>
<a name="ln4146">api_free_string(ret);</a>
<a name="ln4147"> </a>
<a name="ln4148"> </a>
<a name="ln4149">exit_0:</a>
<a name="ln4150">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4151">    luaL_where(lstate, 1);</a>
<a name="ln4152">    if (err_param) {</a>
<a name="ln4153">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4154">      lua_pushstring(lstate, err_param);</a>
<a name="ln4155">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4156">    }</a>
<a name="ln4157">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4158">    api_clear_error(&amp;err);</a>
<a name="ln4159">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4160">    return lua_error(lstate);</a>
<a name="ln4161">  }</a>
<a name="ln4162"> </a>
<a name="ln4163">  return 1;</a>
<a name="ln4164">}</a>
<a name="ln4165"> </a>
<a name="ln4166">static int nlua_api_nvim__get_runtime(lua_State *lstate)</a>
<a name="ln4167">{</a>
<a name="ln4168">  Error err = ERROR_INIT;</a>
<a name="ln4169">  char *err_param = 0;</a>
<a name="ln4170">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln4171">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln4172">    goto exit_0;</a>
<a name="ln4173">  }</a>
<a name="ln4174">    KeyDict_runtime arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_runtime_get_field, &amp;err_param, &amp;err);</a>
<a name="ln4175">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln4176">  }</a>
<a name="ln4177"> </a>
<a name="ln4178">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4179">  if (ERROR_SET(&amp;err)) {      err_param = &quot;all&quot;;      goto exit_1;</a>
<a name="ln4180">  }</a>
<a name="ln4181"> </a>
<a name="ln4182">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln4183">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pat&quot;;      goto exit_2;</a>
<a name="ln4184">  }</a>
<a name="ln4185"> </a>
<a name="ln4186">  const ArrayOf(String) ret = nvim__get_runtime(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln4187">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4188">api_free_array(ret);</a>
<a name="ln4189"> </a>
<a name="ln4190">  api_free_array(arg1);</a>
<a name="ln4191">exit_2:</a>
<a name="ln4192">  api_free_boolean(arg2);</a>
<a name="ln4193">exit_1:</a>
<a name="ln4194">  api_free_keydict_runtime(&amp;arg3);</a>
<a name="ln4195"> </a>
<a name="ln4196">exit_0:</a>
<a name="ln4197">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4198">    luaL_where(lstate, 1);</a>
<a name="ln4199">    if (err_param) {</a>
<a name="ln4200">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4201">      lua_pushstring(lstate, err_param);</a>
<a name="ln4202">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4203">    }</a>
<a name="ln4204">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4205">    api_clear_error(&amp;err);</a>
<a name="ln4206">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4207">    return lua_error(lstate);</a>
<a name="ln4208">  }</a>
<a name="ln4209"> </a>
<a name="ln4210">  return 1;</a>
<a name="ln4211">}</a>
<a name="ln4212"> </a>
<a name="ln4213">static int nlua_api_nvim_set_current_dir(lua_State *lstate)</a>
<a name="ln4214">{</a>
<a name="ln4215">  Error err = ERROR_INIT;</a>
<a name="ln4216">  char *err_param = 0;</a>
<a name="ln4217">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4218">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4219">    goto exit_0;</a>
<a name="ln4220">  }</a>
<a name="ln4221">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4222">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_dir&quot;);</a>
<a name="ln4223">  }</a>
<a name="ln4224">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4225">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dir&quot;;      goto exit_0;</a>
<a name="ln4226">  }</a>
<a name="ln4227"> </a>
<a name="ln4228">  nvim_set_current_dir(arg1, &amp;err);</a>
<a name="ln4229"> </a>
<a name="ln4230">  api_free_string(arg1);</a>
<a name="ln4231"> </a>
<a name="ln4232">exit_0:</a>
<a name="ln4233">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4234">    luaL_where(lstate, 1);</a>
<a name="ln4235">    if (err_param) {</a>
<a name="ln4236">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4237">      lua_pushstring(lstate, err_param);</a>
<a name="ln4238">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4239">    }</a>
<a name="ln4240">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4241">    api_clear_error(&amp;err);</a>
<a name="ln4242">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4243">    return lua_error(lstate);</a>
<a name="ln4244">  }</a>
<a name="ln4245"> </a>
<a name="ln4246">  return 0;</a>
<a name="ln4247">}</a>
<a name="ln4248"> </a>
<a name="ln4249">static int nlua_api_nvim_get_current_line(lua_State *lstate)</a>
<a name="ln4250">{</a>
<a name="ln4251">  Error err = ERROR_INIT;</a>
<a name="ln4252">  char *err_param = 0;</a>
<a name="ln4253">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4254">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4255">    goto exit_0;</a>
<a name="ln4256">  }</a>
<a name="ln4257">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4258">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_line&quot;);</a>
<a name="ln4259">  }</a>
<a name="ln4260">  const String ret = nvim_get_current_line(&amp;err);</a>
<a name="ln4261">  nlua_push_String(lstate, ret, true);</a>
<a name="ln4262">api_free_string(ret);</a>
<a name="ln4263"> </a>
<a name="ln4264"> </a>
<a name="ln4265">exit_0:</a>
<a name="ln4266">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4267">    luaL_where(lstate, 1);</a>
<a name="ln4268">    if (err_param) {</a>
<a name="ln4269">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4270">      lua_pushstring(lstate, err_param);</a>
<a name="ln4271">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4272">    }</a>
<a name="ln4273">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4274">    api_clear_error(&amp;err);</a>
<a name="ln4275">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4276">    return lua_error(lstate);</a>
<a name="ln4277">  }</a>
<a name="ln4278"> </a>
<a name="ln4279">  return 1;</a>
<a name="ln4280">}</a>
<a name="ln4281"> </a>
<a name="ln4282">static int nlua_api_nvim_set_current_line(lua_State *lstate)</a>
<a name="ln4283">{</a>
<a name="ln4284">  Error err = ERROR_INIT;</a>
<a name="ln4285">  char *err_param = 0;</a>
<a name="ln4286">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4287">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4288">    goto exit_0;</a>
<a name="ln4289">  }</a>
<a name="ln4290">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4291">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_line&quot;);</a>
<a name="ln4292">  }</a>
<a name="ln4293">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4294">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4295">    goto exit_0;</a>
<a name="ln4296">  }</a>
<a name="ln4297">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4298">  if (ERROR_SET(&amp;err)) {      err_param = &quot;line&quot;;      goto exit_0;</a>
<a name="ln4299">  }</a>
<a name="ln4300"> </a>
<a name="ln4301">  nvim_set_current_line(arg1, &amp;err);</a>
<a name="ln4302"> </a>
<a name="ln4303">  api_free_string(arg1);</a>
<a name="ln4304"> </a>
<a name="ln4305">exit_0:</a>
<a name="ln4306">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4307">    luaL_where(lstate, 1);</a>
<a name="ln4308">    if (err_param) {</a>
<a name="ln4309">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4310">      lua_pushstring(lstate, err_param);</a>
<a name="ln4311">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4312">    }</a>
<a name="ln4313">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4314">    api_clear_error(&amp;err);</a>
<a name="ln4315">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4316">    return lua_error(lstate);</a>
<a name="ln4317">  }</a>
<a name="ln4318"> </a>
<a name="ln4319">  return 0;</a>
<a name="ln4320">}</a>
<a name="ln4321"> </a>
<a name="ln4322">static int nlua_api_nvim_del_current_line(lua_State *lstate)</a>
<a name="ln4323">{</a>
<a name="ln4324">  Error err = ERROR_INIT;</a>
<a name="ln4325">  char *err_param = 0;</a>
<a name="ln4326">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4327">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4328">    goto exit_0;</a>
<a name="ln4329">  }</a>
<a name="ln4330">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4331">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_current_line&quot;);</a>
<a name="ln4332">  }</a>
<a name="ln4333">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4334">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4335">    goto exit_0;</a>
<a name="ln4336">  }</a>
<a name="ln4337">  nvim_del_current_line(&amp;err);</a>
<a name="ln4338"> </a>
<a name="ln4339"> </a>
<a name="ln4340">exit_0:</a>
<a name="ln4341">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4342">    luaL_where(lstate, 1);</a>
<a name="ln4343">    if (err_param) {</a>
<a name="ln4344">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4345">      lua_pushstring(lstate, err_param);</a>
<a name="ln4346">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4347">    }</a>
<a name="ln4348">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4349">    api_clear_error(&amp;err);</a>
<a name="ln4350">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4351">    return lua_error(lstate);</a>
<a name="ln4352">  }</a>
<a name="ln4353"> </a>
<a name="ln4354">  return 0;</a>
<a name="ln4355">}</a>
<a name="ln4356"> </a>
<a name="ln4357">static int nlua_api_nvim_get_var(lua_State *lstate)</a>
<a name="ln4358">{</a>
<a name="ln4359">  Error err = ERROR_INIT;</a>
<a name="ln4360">  char *err_param = 0;</a>
<a name="ln4361">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4362">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4363">    goto exit_0;</a>
<a name="ln4364">  }</a>
<a name="ln4365">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4366">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_var&quot;);</a>
<a name="ln4367">  }</a>
<a name="ln4368">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4369">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4370">  }</a>
<a name="ln4371"> </a>
<a name="ln4372">  const Object ret = nvim_get_var(arg1, &amp;err);</a>
<a name="ln4373">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln4374">api_free_object(ret);</a>
<a name="ln4375"> </a>
<a name="ln4376">  api_free_string(arg1);</a>
<a name="ln4377"> </a>
<a name="ln4378">exit_0:</a>
<a name="ln4379">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4380">    luaL_where(lstate, 1);</a>
<a name="ln4381">    if (err_param) {</a>
<a name="ln4382">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4383">      lua_pushstring(lstate, err_param);</a>
<a name="ln4384">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4385">    }</a>
<a name="ln4386">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4387">    api_clear_error(&amp;err);</a>
<a name="ln4388">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4389">    return lua_error(lstate);</a>
<a name="ln4390">  }</a>
<a name="ln4391"> </a>
<a name="ln4392">  return 1;</a>
<a name="ln4393">}</a>
<a name="ln4394"> </a>
<a name="ln4395">static int nlua_api_nvim_set_var(lua_State *lstate)</a>
<a name="ln4396">{</a>
<a name="ln4397">  Error err = ERROR_INIT;</a>
<a name="ln4398">  char *err_param = 0;</a>
<a name="ln4399">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4400">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4401">    goto exit_0;</a>
<a name="ln4402">  }</a>
<a name="ln4403">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4404">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_var&quot;);</a>
<a name="ln4405">  }</a>
<a name="ln4406">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln4407">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln4408">  }</a>
<a name="ln4409"> </a>
<a name="ln4410">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4411">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4412">  }</a>
<a name="ln4413"> </a>
<a name="ln4414">  nvim_set_var(arg1, arg2, &amp;err);</a>
<a name="ln4415"> </a>
<a name="ln4416">  api_free_string(arg1);</a>
<a name="ln4417">exit_1:</a>
<a name="ln4418">  api_free_object(arg2);</a>
<a name="ln4419"> </a>
<a name="ln4420">exit_0:</a>
<a name="ln4421">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4422">    luaL_where(lstate, 1);</a>
<a name="ln4423">    if (err_param) {</a>
<a name="ln4424">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4425">      lua_pushstring(lstate, err_param);</a>
<a name="ln4426">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4427">    }</a>
<a name="ln4428">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4429">    api_clear_error(&amp;err);</a>
<a name="ln4430">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4431">    return lua_error(lstate);</a>
<a name="ln4432">  }</a>
<a name="ln4433"> </a>
<a name="ln4434">  return 0;</a>
<a name="ln4435">}</a>
<a name="ln4436"> </a>
<a name="ln4437">static int nlua_api_nvim_del_var(lua_State *lstate)</a>
<a name="ln4438">{</a>
<a name="ln4439">  Error err = ERROR_INIT;</a>
<a name="ln4440">  char *err_param = 0;</a>
<a name="ln4441">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4442">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4443">    goto exit_0;</a>
<a name="ln4444">  }</a>
<a name="ln4445">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4446">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_var&quot;);</a>
<a name="ln4447">  }</a>
<a name="ln4448">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4449">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4450">  }</a>
<a name="ln4451"> </a>
<a name="ln4452">  nvim_del_var(arg1, &amp;err);</a>
<a name="ln4453"> </a>
<a name="ln4454">  api_free_string(arg1);</a>
<a name="ln4455"> </a>
<a name="ln4456">exit_0:</a>
<a name="ln4457">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4458">    luaL_where(lstate, 1);</a>
<a name="ln4459">    if (err_param) {</a>
<a name="ln4460">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4461">      lua_pushstring(lstate, err_param);</a>
<a name="ln4462">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4463">    }</a>
<a name="ln4464">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4465">    api_clear_error(&amp;err);</a>
<a name="ln4466">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4467">    return lua_error(lstate);</a>
<a name="ln4468">  }</a>
<a name="ln4469"> </a>
<a name="ln4470">  return 0;</a>
<a name="ln4471">}</a>
<a name="ln4472"> </a>
<a name="ln4473">static int nlua_api_nvim_get_vvar(lua_State *lstate)</a>
<a name="ln4474">{</a>
<a name="ln4475">  Error err = ERROR_INIT;</a>
<a name="ln4476">  char *err_param = 0;</a>
<a name="ln4477">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4478">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4479">    goto exit_0;</a>
<a name="ln4480">  }</a>
<a name="ln4481">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4482">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_vvar&quot;);</a>
<a name="ln4483">  }</a>
<a name="ln4484">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4485">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln4486">  }</a>
<a name="ln4487"> </a>
<a name="ln4488">  const Object ret = nvim_get_vvar(arg1, &amp;err);</a>
<a name="ln4489">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln4490">api_free_object(ret);</a>
<a name="ln4491"> </a>
<a name="ln4492">  api_free_string(arg1);</a>
<a name="ln4493"> </a>
<a name="ln4494">exit_0:</a>
<a name="ln4495">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4496">    luaL_where(lstate, 1);</a>
<a name="ln4497">    if (err_param) {</a>
<a name="ln4498">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4499">      lua_pushstring(lstate, err_param);</a>
<a name="ln4500">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4501">    }</a>
<a name="ln4502">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4503">    api_clear_error(&amp;err);</a>
<a name="ln4504">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4505">    return lua_error(lstate);</a>
<a name="ln4506">  }</a>
<a name="ln4507"> </a>
<a name="ln4508">  return 1;</a>
<a name="ln4509">}</a>
<a name="ln4510"> </a>
<a name="ln4511">static int nlua_api_nvim_set_vvar(lua_State *lstate)</a>
<a name="ln4512">{</a>
<a name="ln4513">  Error err = ERROR_INIT;</a>
<a name="ln4514">  char *err_param = 0;</a>
<a name="ln4515">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4516">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4517">    goto exit_0;</a>
<a name="ln4518">  }</a>
<a name="ln4519">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4520">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_vvar&quot;);</a>
<a name="ln4521">  }</a>
<a name="ln4522">    const Object arg2 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln4523">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln4524">  }</a>
<a name="ln4525"> </a>
<a name="ln4526">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4527">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln4528">  }</a>
<a name="ln4529"> </a>
<a name="ln4530">  nvim_set_vvar(arg1, arg2, &amp;err);</a>
<a name="ln4531"> </a>
<a name="ln4532">  api_free_string(arg1);</a>
<a name="ln4533">exit_1:</a>
<a name="ln4534">  api_free_object(arg2);</a>
<a name="ln4535"> </a>
<a name="ln4536">exit_0:</a>
<a name="ln4537">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4538">    luaL_where(lstate, 1);</a>
<a name="ln4539">    if (err_param) {</a>
<a name="ln4540">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4541">      lua_pushstring(lstate, err_param);</a>
<a name="ln4542">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4543">    }</a>
<a name="ln4544">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4545">    api_clear_error(&amp;err);</a>
<a name="ln4546">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4547">    return lua_error(lstate);</a>
<a name="ln4548">  }</a>
<a name="ln4549"> </a>
<a name="ln4550">  return 0;</a>
<a name="ln4551">}</a>
<a name="ln4552"> </a>
<a name="ln4553">static int nlua_api_nvim_echo(lua_State *lstate)</a>
<a name="ln4554">{</a>
<a name="ln4555">  Error err = ERROR_INIT;</a>
<a name="ln4556">  char *err_param = 0;</a>
<a name="ln4557">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln4558">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln4559">    goto exit_0;</a>
<a name="ln4560">  }</a>
<a name="ln4561">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4562">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_echo&quot;);</a>
<a name="ln4563">  }</a>
<a name="ln4564">    KeyDict_echo_opts arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_echo_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln4565">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln4566">  }</a>
<a name="ln4567"> </a>
<a name="ln4568">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4569">  if (ERROR_SET(&amp;err)) {      err_param = &quot;history&quot;;      goto exit_1;</a>
<a name="ln4570">  }</a>
<a name="ln4571"> </a>
<a name="ln4572">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln4573">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chunks&quot;;      goto exit_2;</a>
<a name="ln4574">  }</a>
<a name="ln4575"> </a>
<a name="ln4576">  nvim_echo(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln4577"> </a>
<a name="ln4578">  api_free_array(arg1);</a>
<a name="ln4579">exit_2:</a>
<a name="ln4580">  api_free_boolean(arg2);</a>
<a name="ln4581">exit_1:</a>
<a name="ln4582">  api_free_keydict_echo_opts(&amp;arg3);</a>
<a name="ln4583"> </a>
<a name="ln4584">exit_0:</a>
<a name="ln4585">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4586">    luaL_where(lstate, 1);</a>
<a name="ln4587">    if (err_param) {</a>
<a name="ln4588">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4589">      lua_pushstring(lstate, err_param);</a>
<a name="ln4590">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4591">    }</a>
<a name="ln4592">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4593">    api_clear_error(&amp;err);</a>
<a name="ln4594">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4595">    return lua_error(lstate);</a>
<a name="ln4596">  }</a>
<a name="ln4597"> </a>
<a name="ln4598">  return 0;</a>
<a name="ln4599">}</a>
<a name="ln4600"> </a>
<a name="ln4601">static int nlua_api_nvim_out_write(lua_State *lstate)</a>
<a name="ln4602">{</a>
<a name="ln4603">  Error err = ERROR_INIT;</a>
<a name="ln4604">  char *err_param = 0;</a>
<a name="ln4605">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4606">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4607">    goto exit_0;</a>
<a name="ln4608">  }</a>
<a name="ln4609">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4610">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_out_write&quot;);</a>
<a name="ln4611">  }</a>
<a name="ln4612">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4613">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4614">  }</a>
<a name="ln4615"> </a>
<a name="ln4616">  nvim_out_write(arg1);</a>
<a name="ln4617"> </a>
<a name="ln4618">  api_free_string(arg1);</a>
<a name="ln4619"> </a>
<a name="ln4620">exit_0:</a>
<a name="ln4621">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4622">    luaL_where(lstate, 1);</a>
<a name="ln4623">    if (err_param) {</a>
<a name="ln4624">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4625">      lua_pushstring(lstate, err_param);</a>
<a name="ln4626">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4627">    }</a>
<a name="ln4628">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4629">    api_clear_error(&amp;err);</a>
<a name="ln4630">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4631">    return lua_error(lstate);</a>
<a name="ln4632">  }</a>
<a name="ln4633"> </a>
<a name="ln4634">  return 0;</a>
<a name="ln4635">}</a>
<a name="ln4636"> </a>
<a name="ln4637">static int nlua_api_nvim_err_write(lua_State *lstate)</a>
<a name="ln4638">{</a>
<a name="ln4639">  Error err = ERROR_INIT;</a>
<a name="ln4640">  char *err_param = 0;</a>
<a name="ln4641">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4642">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4643">    goto exit_0;</a>
<a name="ln4644">  }</a>
<a name="ln4645">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4646">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_err_write&quot;);</a>
<a name="ln4647">  }</a>
<a name="ln4648">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4649">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4650">  }</a>
<a name="ln4651"> </a>
<a name="ln4652">  nvim_err_write(arg1);</a>
<a name="ln4653"> </a>
<a name="ln4654">  api_free_string(arg1);</a>
<a name="ln4655"> </a>
<a name="ln4656">exit_0:</a>
<a name="ln4657">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4658">    luaL_where(lstate, 1);</a>
<a name="ln4659">    if (err_param) {</a>
<a name="ln4660">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4661">      lua_pushstring(lstate, err_param);</a>
<a name="ln4662">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4663">    }</a>
<a name="ln4664">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4665">    api_clear_error(&amp;err);</a>
<a name="ln4666">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4667">    return lua_error(lstate);</a>
<a name="ln4668">  }</a>
<a name="ln4669"> </a>
<a name="ln4670">  return 0;</a>
<a name="ln4671">}</a>
<a name="ln4672"> </a>
<a name="ln4673">static int nlua_api_nvim_err_writeln(lua_State *lstate)</a>
<a name="ln4674">{</a>
<a name="ln4675">  Error err = ERROR_INIT;</a>
<a name="ln4676">  char *err_param = 0;</a>
<a name="ln4677">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4678">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4679">    goto exit_0;</a>
<a name="ln4680">  }</a>
<a name="ln4681">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4682">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_err_writeln&quot;);</a>
<a name="ln4683">  }</a>
<a name="ln4684">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln4685">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln4686">  }</a>
<a name="ln4687"> </a>
<a name="ln4688">  nvim_err_writeln(arg1);</a>
<a name="ln4689"> </a>
<a name="ln4690">  api_free_string(arg1);</a>
<a name="ln4691"> </a>
<a name="ln4692">exit_0:</a>
<a name="ln4693">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4694">    luaL_where(lstate, 1);</a>
<a name="ln4695">    if (err_param) {</a>
<a name="ln4696">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4697">      lua_pushstring(lstate, err_param);</a>
<a name="ln4698">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4699">    }</a>
<a name="ln4700">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4701">    api_clear_error(&amp;err);</a>
<a name="ln4702">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4703">    return lua_error(lstate);</a>
<a name="ln4704">  }</a>
<a name="ln4705"> </a>
<a name="ln4706">  return 0;</a>
<a name="ln4707">}</a>
<a name="ln4708"> </a>
<a name="ln4709">static int nlua_api_nvim_list_bufs(lua_State *lstate)</a>
<a name="ln4710">{</a>
<a name="ln4711">  Error err = ERROR_INIT;</a>
<a name="ln4712">  char *err_param = 0;</a>
<a name="ln4713">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4714">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4715">    goto exit_0;</a>
<a name="ln4716">  }</a>
<a name="ln4717">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4718">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_bufs&quot;);</a>
<a name="ln4719">  }</a>
<a name="ln4720">  const ArrayOf(Buffer) ret = nvim_list_bufs();</a>
<a name="ln4721">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4722">api_free_array(ret);</a>
<a name="ln4723"> </a>
<a name="ln4724"> </a>
<a name="ln4725">exit_0:</a>
<a name="ln4726">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4727">    luaL_where(lstate, 1);</a>
<a name="ln4728">    if (err_param) {</a>
<a name="ln4729">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4730">      lua_pushstring(lstate, err_param);</a>
<a name="ln4731">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4732">    }</a>
<a name="ln4733">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4734">    api_clear_error(&amp;err);</a>
<a name="ln4735">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4736">    return lua_error(lstate);</a>
<a name="ln4737">  }</a>
<a name="ln4738"> </a>
<a name="ln4739">  return 1;</a>
<a name="ln4740">}</a>
<a name="ln4741"> </a>
<a name="ln4742">static int nlua_api_nvim_get_current_buf(lua_State *lstate)</a>
<a name="ln4743">{</a>
<a name="ln4744">  Error err = ERROR_INIT;</a>
<a name="ln4745">  char *err_param = 0;</a>
<a name="ln4746">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4747">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4748">    goto exit_0;</a>
<a name="ln4749">  }</a>
<a name="ln4750">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4751">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_buf&quot;);</a>
<a name="ln4752">  }</a>
<a name="ln4753">  const Buffer ret = nvim_get_current_buf();</a>
<a name="ln4754">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln4755">api_free_buffer(ret);</a>
<a name="ln4756"> </a>
<a name="ln4757"> </a>
<a name="ln4758">exit_0:</a>
<a name="ln4759">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4760">    luaL_where(lstate, 1);</a>
<a name="ln4761">    if (err_param) {</a>
<a name="ln4762">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4763">      lua_pushstring(lstate, err_param);</a>
<a name="ln4764">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4765">    }</a>
<a name="ln4766">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4767">    api_clear_error(&amp;err);</a>
<a name="ln4768">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4769">    return lua_error(lstate);</a>
<a name="ln4770">  }</a>
<a name="ln4771"> </a>
<a name="ln4772">  return 1;</a>
<a name="ln4773">}</a>
<a name="ln4774"> </a>
<a name="ln4775">static int nlua_api_nvim_set_current_buf(lua_State *lstate)</a>
<a name="ln4776">{</a>
<a name="ln4777">  Error err = ERROR_INIT;</a>
<a name="ln4778">  char *err_param = 0;</a>
<a name="ln4779">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4780">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4781">    goto exit_0;</a>
<a name="ln4782">  }</a>
<a name="ln4783">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4784">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_buf&quot;);</a>
<a name="ln4785">  }</a>
<a name="ln4786">  if (text_locked()) {</a>
<a name="ln4787">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln4788">    goto exit_0;</a>
<a name="ln4789">  }</a>
<a name="ln4790">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln4791">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln4792">  }</a>
<a name="ln4793"> </a>
<a name="ln4794">  nvim_set_current_buf(arg1, &amp;err);</a>
<a name="ln4795"> </a>
<a name="ln4796">  api_free_buffer(arg1);</a>
<a name="ln4797"> </a>
<a name="ln4798">exit_0:</a>
<a name="ln4799">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4800">    luaL_where(lstate, 1);</a>
<a name="ln4801">    if (err_param) {</a>
<a name="ln4802">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4803">      lua_pushstring(lstate, err_param);</a>
<a name="ln4804">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4805">    }</a>
<a name="ln4806">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4807">    api_clear_error(&amp;err);</a>
<a name="ln4808">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4809">    return lua_error(lstate);</a>
<a name="ln4810">  }</a>
<a name="ln4811"> </a>
<a name="ln4812">  return 0;</a>
<a name="ln4813">}</a>
<a name="ln4814"> </a>
<a name="ln4815">static int nlua_api_nvim_list_wins(lua_State *lstate)</a>
<a name="ln4816">{</a>
<a name="ln4817">  Error err = ERROR_INIT;</a>
<a name="ln4818">  char *err_param = 0;</a>
<a name="ln4819">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4820">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4821">    goto exit_0;</a>
<a name="ln4822">  }</a>
<a name="ln4823">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4824">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_wins&quot;);</a>
<a name="ln4825">  }</a>
<a name="ln4826">  const ArrayOf(Window) ret = nvim_list_wins();</a>
<a name="ln4827">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln4828">api_free_array(ret);</a>
<a name="ln4829"> </a>
<a name="ln4830"> </a>
<a name="ln4831">exit_0:</a>
<a name="ln4832">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4833">    luaL_where(lstate, 1);</a>
<a name="ln4834">    if (err_param) {</a>
<a name="ln4835">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4836">      lua_pushstring(lstate, err_param);</a>
<a name="ln4837">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4838">    }</a>
<a name="ln4839">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4840">    api_clear_error(&amp;err);</a>
<a name="ln4841">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4842">    return lua_error(lstate);</a>
<a name="ln4843">  }</a>
<a name="ln4844"> </a>
<a name="ln4845">  return 1;</a>
<a name="ln4846">}</a>
<a name="ln4847"> </a>
<a name="ln4848">static int nlua_api_nvim_get_current_win(lua_State *lstate)</a>
<a name="ln4849">{</a>
<a name="ln4850">  Error err = ERROR_INIT;</a>
<a name="ln4851">  char *err_param = 0;</a>
<a name="ln4852">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln4853">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln4854">    goto exit_0;</a>
<a name="ln4855">  }</a>
<a name="ln4856">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4857">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_win&quot;);</a>
<a name="ln4858">  }</a>
<a name="ln4859">  const Window ret = nvim_get_current_win();</a>
<a name="ln4860">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln4861">api_free_window(ret);</a>
<a name="ln4862"> </a>
<a name="ln4863"> </a>
<a name="ln4864">exit_0:</a>
<a name="ln4865">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4866">    luaL_where(lstate, 1);</a>
<a name="ln4867">    if (err_param) {</a>
<a name="ln4868">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4869">      lua_pushstring(lstate, err_param);</a>
<a name="ln4870">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4871">    }</a>
<a name="ln4872">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4873">    api_clear_error(&amp;err);</a>
<a name="ln4874">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4875">    return lua_error(lstate);</a>
<a name="ln4876">  }</a>
<a name="ln4877"> </a>
<a name="ln4878">  return 1;</a>
<a name="ln4879">}</a>
<a name="ln4880"> </a>
<a name="ln4881">static int nlua_api_nvim_set_current_win(lua_State *lstate)</a>
<a name="ln4882">{</a>
<a name="ln4883">  Error err = ERROR_INIT;</a>
<a name="ln4884">  char *err_param = 0;</a>
<a name="ln4885">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln4886">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln4887">    goto exit_0;</a>
<a name="ln4888">  }</a>
<a name="ln4889">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4890">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_win&quot;);</a>
<a name="ln4891">  }</a>
<a name="ln4892">  if (text_locked()) {</a>
<a name="ln4893">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln4894">    goto exit_0;</a>
<a name="ln4895">  }</a>
<a name="ln4896">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln4897">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln4898">  }</a>
<a name="ln4899"> </a>
<a name="ln4900">  nvim_set_current_win(arg1, &amp;err);</a>
<a name="ln4901"> </a>
<a name="ln4902">  api_free_window(arg1);</a>
<a name="ln4903"> </a>
<a name="ln4904">exit_0:</a>
<a name="ln4905">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4906">    luaL_where(lstate, 1);</a>
<a name="ln4907">    if (err_param) {</a>
<a name="ln4908">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4909">      lua_pushstring(lstate, err_param);</a>
<a name="ln4910">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4911">    }</a>
<a name="ln4912">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4913">    api_clear_error(&amp;err);</a>
<a name="ln4914">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4915">    return lua_error(lstate);</a>
<a name="ln4916">  }</a>
<a name="ln4917"> </a>
<a name="ln4918">  return 0;</a>
<a name="ln4919">}</a>
<a name="ln4920"> </a>
<a name="ln4921">static int nlua_api_nvim_create_buf(lua_State *lstate)</a>
<a name="ln4922">{</a>
<a name="ln4923">  Error err = ERROR_INIT;</a>
<a name="ln4924">  char *err_param = 0;</a>
<a name="ln4925">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4926">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4927">    goto exit_0;</a>
<a name="ln4928">  }</a>
<a name="ln4929">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4930">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_create_buf&quot;);</a>
<a name="ln4931">  }</a>
<a name="ln4932">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4933">  if (ERROR_SET(&amp;err)) {      err_param = &quot;scratch&quot;;      goto exit_0;</a>
<a name="ln4934">  }</a>
<a name="ln4935"> </a>
<a name="ln4936">    const Boolean arg1 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln4937">  if (ERROR_SET(&amp;err)) {      err_param = &quot;listed&quot;;      goto exit_1;</a>
<a name="ln4938">  }</a>
<a name="ln4939"> </a>
<a name="ln4940">  const Buffer ret = nvim_create_buf(arg1, arg2, &amp;err);</a>
<a name="ln4941">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln4942">api_free_buffer(ret);</a>
<a name="ln4943"> </a>
<a name="ln4944">  api_free_boolean(arg1);</a>
<a name="ln4945">exit_1:</a>
<a name="ln4946">  api_free_boolean(arg2);</a>
<a name="ln4947"> </a>
<a name="ln4948">exit_0:</a>
<a name="ln4949">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4950">    luaL_where(lstate, 1);</a>
<a name="ln4951">    if (err_param) {</a>
<a name="ln4952">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln4953">      lua_pushstring(lstate, err_param);</a>
<a name="ln4954">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln4955">    }</a>
<a name="ln4956">    lua_pushstring(lstate, err.msg);</a>
<a name="ln4957">    api_clear_error(&amp;err);</a>
<a name="ln4958">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln4959">    return lua_error(lstate);</a>
<a name="ln4960">  }</a>
<a name="ln4961"> </a>
<a name="ln4962">  return 1;</a>
<a name="ln4963">}</a>
<a name="ln4964"> </a>
<a name="ln4965">static int nlua_api_nvim_open_term(lua_State *lstate)</a>
<a name="ln4966">{</a>
<a name="ln4967">  Error err = ERROR_INIT;</a>
<a name="ln4968">  char *err_param = 0;</a>
<a name="ln4969">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln4970">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln4971">    goto exit_0;</a>
<a name="ln4972">  }</a>
<a name="ln4973">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln4974">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_open_term&quot;);</a>
<a name="ln4975">  }</a>
<a name="ln4976">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln4977">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln4978">    goto exit_0;</a>
<a name="ln4979">  }</a>
<a name="ln4980">    const DictionaryOf(LuaRef) arg2 = nlua_pop_Dictionary(lstate, true, &amp;err);</a>
<a name="ln4981">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln4982">  }</a>
<a name="ln4983"> </a>
<a name="ln4984">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln4985">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_1;</a>
<a name="ln4986">  }</a>
<a name="ln4987"> </a>
<a name="ln4988">  const Integer ret = nvim_open_term(arg1, arg2, &amp;err);</a>
<a name="ln4989">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln4990">api_free_integer(ret);</a>
<a name="ln4991"> </a>
<a name="ln4992">  api_free_buffer(arg1);</a>
<a name="ln4993">exit_1:</a>
<a name="ln4994">  api_free_dictionary(arg2);</a>
<a name="ln4995"> </a>
<a name="ln4996">exit_0:</a>
<a name="ln4997">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln4998">    luaL_where(lstate, 1);</a>
<a name="ln4999">    if (err_param) {</a>
<a name="ln5000">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5001">      lua_pushstring(lstate, err_param);</a>
<a name="ln5002">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5003">    }</a>
<a name="ln5004">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5005">    api_clear_error(&amp;err);</a>
<a name="ln5006">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5007">    return lua_error(lstate);</a>
<a name="ln5008">  }</a>
<a name="ln5009"> </a>
<a name="ln5010">  return 1;</a>
<a name="ln5011">}</a>
<a name="ln5012"> </a>
<a name="ln5013">static int nlua_api_nvim_chan_send(lua_State *lstate)</a>
<a name="ln5014">{</a>
<a name="ln5015">  Error err = ERROR_INIT;</a>
<a name="ln5016">  char *err_param = 0;</a>
<a name="ln5017">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln5018">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln5019">    goto exit_0;</a>
<a name="ln5020">  }</a>
<a name="ln5021">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5022">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_chan_send&quot;);</a>
<a name="ln5023">  }</a>
<a name="ln5024">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5025">  if (ERROR_SET(&amp;err)) {      err_param = &quot;data&quot;;      goto exit_0;</a>
<a name="ln5026">  }</a>
<a name="ln5027"> </a>
<a name="ln5028">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5029">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chan&quot;;      goto exit_1;</a>
<a name="ln5030">  }</a>
<a name="ln5031"> </a>
<a name="ln5032">  nvim_chan_send(arg1, arg2, &amp;err);</a>
<a name="ln5033"> </a>
<a name="ln5034">  api_free_integer(arg1);</a>
<a name="ln5035">exit_1:</a>
<a name="ln5036">  api_free_string(arg2);</a>
<a name="ln5037"> </a>
<a name="ln5038">exit_0:</a>
<a name="ln5039">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5040">    luaL_where(lstate, 1);</a>
<a name="ln5041">    if (err_param) {</a>
<a name="ln5042">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5043">      lua_pushstring(lstate, err_param);</a>
<a name="ln5044">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5045">    }</a>
<a name="ln5046">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5047">    api_clear_error(&amp;err);</a>
<a name="ln5048">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5049">    return lua_error(lstate);</a>
<a name="ln5050">  }</a>
<a name="ln5051"> </a>
<a name="ln5052">  return 0;</a>
<a name="ln5053">}</a>
<a name="ln5054"> </a>
<a name="ln5055">static int nlua_api_nvim_list_tabpages(lua_State *lstate)</a>
<a name="ln5056">{</a>
<a name="ln5057">  Error err = ERROR_INIT;</a>
<a name="ln5058">  char *err_param = 0;</a>
<a name="ln5059">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5060">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5061">    goto exit_0;</a>
<a name="ln5062">  }</a>
<a name="ln5063">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5064">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_tabpages&quot;);</a>
<a name="ln5065">  }</a>
<a name="ln5066">  const ArrayOf(Tabpage) ret = nvim_list_tabpages();</a>
<a name="ln5067">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5068">api_free_array(ret);</a>
<a name="ln5069"> </a>
<a name="ln5070"> </a>
<a name="ln5071">exit_0:</a>
<a name="ln5072">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5073">    luaL_where(lstate, 1);</a>
<a name="ln5074">    if (err_param) {</a>
<a name="ln5075">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5076">      lua_pushstring(lstate, err_param);</a>
<a name="ln5077">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5078">    }</a>
<a name="ln5079">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5080">    api_clear_error(&amp;err);</a>
<a name="ln5081">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5082">    return lua_error(lstate);</a>
<a name="ln5083">  }</a>
<a name="ln5084"> </a>
<a name="ln5085">  return 1;</a>
<a name="ln5086">}</a>
<a name="ln5087"> </a>
<a name="ln5088">static int nlua_api_nvim_get_current_tabpage(lua_State *lstate)</a>
<a name="ln5089">{</a>
<a name="ln5090">  Error err = ERROR_INIT;</a>
<a name="ln5091">  char *err_param = 0;</a>
<a name="ln5092">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5093">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5094">    goto exit_0;</a>
<a name="ln5095">  }</a>
<a name="ln5096">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5097">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_current_tabpage&quot;);</a>
<a name="ln5098">  }</a>
<a name="ln5099">  const Tabpage ret = nvim_get_current_tabpage();</a>
<a name="ln5100">  nlua_push_Tabpage(lstate, ret, true);</a>
<a name="ln5101">api_free_tabpage(ret);</a>
<a name="ln5102"> </a>
<a name="ln5103"> </a>
<a name="ln5104">exit_0:</a>
<a name="ln5105">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5106">    luaL_where(lstate, 1);</a>
<a name="ln5107">    if (err_param) {</a>
<a name="ln5108">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5109">      lua_pushstring(lstate, err_param);</a>
<a name="ln5110">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5111">    }</a>
<a name="ln5112">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5113">    api_clear_error(&amp;err);</a>
<a name="ln5114">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5115">    return lua_error(lstate);</a>
<a name="ln5116">  }</a>
<a name="ln5117"> </a>
<a name="ln5118">  return 1;</a>
<a name="ln5119">}</a>
<a name="ln5120"> </a>
<a name="ln5121">static int nlua_api_nvim_set_current_tabpage(lua_State *lstate)</a>
<a name="ln5122">{</a>
<a name="ln5123">  Error err = ERROR_INIT;</a>
<a name="ln5124">  char *err_param = 0;</a>
<a name="ln5125">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5126">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5127">    goto exit_0;</a>
<a name="ln5128">  }</a>
<a name="ln5129">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5130">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_current_tabpage&quot;);</a>
<a name="ln5131">  }</a>
<a name="ln5132">  if (text_locked()) {</a>
<a name="ln5133">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, get_text_locked_msg());</a>
<a name="ln5134">    goto exit_0;</a>
<a name="ln5135">  }</a>
<a name="ln5136">    const Tabpage arg1 = nlua_pop_Tabpage(lstate, &amp;err);</a>
<a name="ln5137">  if (ERROR_SET(&amp;err)) {      err_param = &quot;tabpage&quot;;      goto exit_0;</a>
<a name="ln5138">  }</a>
<a name="ln5139"> </a>
<a name="ln5140">  nvim_set_current_tabpage(arg1, &amp;err);</a>
<a name="ln5141"> </a>
<a name="ln5142">  api_free_tabpage(arg1);</a>
<a name="ln5143"> </a>
<a name="ln5144">exit_0:</a>
<a name="ln5145">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5146">    luaL_where(lstate, 1);</a>
<a name="ln5147">    if (err_param) {</a>
<a name="ln5148">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5149">      lua_pushstring(lstate, err_param);</a>
<a name="ln5150">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5151">    }</a>
<a name="ln5152">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5153">    api_clear_error(&amp;err);</a>
<a name="ln5154">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5155">    return lua_error(lstate);</a>
<a name="ln5156">  }</a>
<a name="ln5157"> </a>
<a name="ln5158">  return 0;</a>
<a name="ln5159">}</a>
<a name="ln5160"> </a>
<a name="ln5161">static int nlua_api_nvim_paste(lua_State *lstate)</a>
<a name="ln5162">{</a>
<a name="ln5163">  Error err = ERROR_INIT;</a>
<a name="ln5164">  char *err_param = 0;</a>
<a name="ln5165">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln5166">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln5167">    goto exit_0;</a>
<a name="ln5168">  }</a>
<a name="ln5169">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5170">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_paste&quot;);</a>
<a name="ln5171">  }</a>
<a name="ln5172">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln5173">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln5174">    goto exit_0;</a>
<a name="ln5175">  }</a>
<a name="ln5176">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5177">  if (ERROR_SET(&amp;err)) {      err_param = &quot;phase&quot;;      goto exit_0;</a>
<a name="ln5178">  }</a>
<a name="ln5179"> </a>
<a name="ln5180">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5181">  if (ERROR_SET(&amp;err)) {      err_param = &quot;crlf&quot;;      goto exit_1;</a>
<a name="ln5182">  }</a>
<a name="ln5183"> </a>
<a name="ln5184">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5185">  if (ERROR_SET(&amp;err)) {      err_param = &quot;data&quot;;      goto exit_2;</a>
<a name="ln5186">  }</a>
<a name="ln5187"> </a>
<a name="ln5188">  const Boolean ret = nvim_paste(arg1, arg2, arg3, &amp;err);</a>
<a name="ln5189">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln5190">api_free_boolean(ret);</a>
<a name="ln5191"> </a>
<a name="ln5192">  api_free_string(arg1);</a>
<a name="ln5193">exit_2:</a>
<a name="ln5194">  api_free_boolean(arg2);</a>
<a name="ln5195">exit_1:</a>
<a name="ln5196">  api_free_integer(arg3);</a>
<a name="ln5197"> </a>
<a name="ln5198">exit_0:</a>
<a name="ln5199">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5200">    luaL_where(lstate, 1);</a>
<a name="ln5201">    if (err_param) {</a>
<a name="ln5202">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5203">      lua_pushstring(lstate, err_param);</a>
<a name="ln5204">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5205">    }</a>
<a name="ln5206">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5207">    api_clear_error(&amp;err);</a>
<a name="ln5208">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5209">    return lua_error(lstate);</a>
<a name="ln5210">  }</a>
<a name="ln5211"> </a>
<a name="ln5212">  return 1;</a>
<a name="ln5213">}</a>
<a name="ln5214"> </a>
<a name="ln5215">static int nlua_api_nvim_put(lua_State *lstate)</a>
<a name="ln5216">{</a>
<a name="ln5217">  Error err = ERROR_INIT;</a>
<a name="ln5218">  char *err_param = 0;</a>
<a name="ln5219">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5220">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5221">    goto exit_0;</a>
<a name="ln5222">  }</a>
<a name="ln5223">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5224">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_put&quot;);</a>
<a name="ln5225">  }</a>
<a name="ln5226">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln5227">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln5228">    goto exit_0;</a>
<a name="ln5229">  }</a>
<a name="ln5230">    const Boolean arg4 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5231">  if (ERROR_SET(&amp;err)) {      err_param = &quot;follow&quot;;      goto exit_0;</a>
<a name="ln5232">  }</a>
<a name="ln5233"> </a>
<a name="ln5234">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5235">  if (ERROR_SET(&amp;err)) {      err_param = &quot;after&quot;;      goto exit_1;</a>
<a name="ln5236">  }</a>
<a name="ln5237"> </a>
<a name="ln5238">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5239">  if (ERROR_SET(&amp;err)) {      err_param = &quot;type&quot;;      goto exit_2;</a>
<a name="ln5240">  }</a>
<a name="ln5241"> </a>
<a name="ln5242">    const ArrayOf(String) arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln5243">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lines&quot;;      goto exit_3;</a>
<a name="ln5244">  }</a>
<a name="ln5245"> </a>
<a name="ln5246">  nvim_put(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln5247"> </a>
<a name="ln5248">  api_free_array(arg1);</a>
<a name="ln5249">exit_3:</a>
<a name="ln5250">  api_free_string(arg2);</a>
<a name="ln5251">exit_2:</a>
<a name="ln5252">  api_free_boolean(arg3);</a>
<a name="ln5253">exit_1:</a>
<a name="ln5254">  api_free_boolean(arg4);</a>
<a name="ln5255"> </a>
<a name="ln5256">exit_0:</a>
<a name="ln5257">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5258">    luaL_where(lstate, 1);</a>
<a name="ln5259">    if (err_param) {</a>
<a name="ln5260">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5261">      lua_pushstring(lstate, err_param);</a>
<a name="ln5262">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5263">    }</a>
<a name="ln5264">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5265">    api_clear_error(&amp;err);</a>
<a name="ln5266">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5267">    return lua_error(lstate);</a>
<a name="ln5268">  }</a>
<a name="ln5269"> </a>
<a name="ln5270">  return 0;</a>
<a name="ln5271">}</a>
<a name="ln5272"> </a>
<a name="ln5273">static int nlua_api_nvim_get_color_by_name(lua_State *lstate)</a>
<a name="ln5274">{</a>
<a name="ln5275">  Error err = ERROR_INIT;</a>
<a name="ln5276">  char *err_param = 0;</a>
<a name="ln5277">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5278">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5279">    goto exit_0;</a>
<a name="ln5280">  }</a>
<a name="ln5281">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5282">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_color_by_name&quot;);</a>
<a name="ln5283">  }</a>
<a name="ln5284">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5285">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln5286">  }</a>
<a name="ln5287"> </a>
<a name="ln5288">  const Integer ret = nvim_get_color_by_name(arg1);</a>
<a name="ln5289">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln5290">api_free_integer(ret);</a>
<a name="ln5291"> </a>
<a name="ln5292">  api_free_string(arg1);</a>
<a name="ln5293"> </a>
<a name="ln5294">exit_0:</a>
<a name="ln5295">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5296">    luaL_where(lstate, 1);</a>
<a name="ln5297">    if (err_param) {</a>
<a name="ln5298">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5299">      lua_pushstring(lstate, err_param);</a>
<a name="ln5300">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5301">    }</a>
<a name="ln5302">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5303">    api_clear_error(&amp;err);</a>
<a name="ln5304">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5305">    return lua_error(lstate);</a>
<a name="ln5306">  }</a>
<a name="ln5307"> </a>
<a name="ln5308">  return 1;</a>
<a name="ln5309">}</a>
<a name="ln5310"> </a>
<a name="ln5311">static int nlua_api_nvim_get_color_map(lua_State *lstate)</a>
<a name="ln5312">{</a>
<a name="ln5313">  Error err = ERROR_INIT;</a>
<a name="ln5314">  char *err_param = 0;</a>
<a name="ln5315">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5316">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5317">    goto exit_0;</a>
<a name="ln5318">  }</a>
<a name="ln5319">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5320">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_color_map&quot;);</a>
<a name="ln5321">  }</a>
<a name="ln5322">  const Dictionary ret = nvim_get_color_map();</a>
<a name="ln5323">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5324">api_free_dictionary(ret);</a>
<a name="ln5325"> </a>
<a name="ln5326"> </a>
<a name="ln5327">exit_0:</a>
<a name="ln5328">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5329">    luaL_where(lstate, 1);</a>
<a name="ln5330">    if (err_param) {</a>
<a name="ln5331">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5332">      lua_pushstring(lstate, err_param);</a>
<a name="ln5333">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5334">    }</a>
<a name="ln5335">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5336">    api_clear_error(&amp;err);</a>
<a name="ln5337">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5338">    return lua_error(lstate);</a>
<a name="ln5339">  }</a>
<a name="ln5340"> </a>
<a name="ln5341">  return 1;</a>
<a name="ln5342">}</a>
<a name="ln5343"> </a>
<a name="ln5344">static int nlua_api_nvim_get_context(lua_State *lstate)</a>
<a name="ln5345">{</a>
<a name="ln5346">  Error err = ERROR_INIT;</a>
<a name="ln5347">  char *err_param = 0;</a>
<a name="ln5348">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5349">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5350">    goto exit_0;</a>
<a name="ln5351">  }</a>
<a name="ln5352">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5353">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_context&quot;);</a>
<a name="ln5354">  }</a>
<a name="ln5355">    KeyDict_context arg1 = { 0 }; nlua_pop_keydict(lstate, &amp;arg1, KeyDict_context_get_field, &amp;err_param, &amp;err);</a>
<a name="ln5356">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln5357">  }</a>
<a name="ln5358"> </a>
<a name="ln5359">  const Dictionary ret = nvim_get_context(&amp;arg1, &amp;err);</a>
<a name="ln5360">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5361">api_free_dictionary(ret);</a>
<a name="ln5362"> </a>
<a name="ln5363">exit_1:</a>
<a name="ln5364">  api_free_keydict_context(&amp;arg1);</a>
<a name="ln5365"> </a>
<a name="ln5366">exit_0:</a>
<a name="ln5367">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5368">    luaL_where(lstate, 1);</a>
<a name="ln5369">    if (err_param) {</a>
<a name="ln5370">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5371">      lua_pushstring(lstate, err_param);</a>
<a name="ln5372">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5373">    }</a>
<a name="ln5374">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5375">    api_clear_error(&amp;err);</a>
<a name="ln5376">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5377">    return lua_error(lstate);</a>
<a name="ln5378">  }</a>
<a name="ln5379"> </a>
<a name="ln5380">  return 1;</a>
<a name="ln5381">}</a>
<a name="ln5382"> </a>
<a name="ln5383">static int nlua_api_nvim_load_context(lua_State *lstate)</a>
<a name="ln5384">{</a>
<a name="ln5385">  Error err = ERROR_INIT;</a>
<a name="ln5386">  char *err_param = 0;</a>
<a name="ln5387">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5388">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5389">    goto exit_0;</a>
<a name="ln5390">  }</a>
<a name="ln5391">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5392">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_load_context&quot;);</a>
<a name="ln5393">  }</a>
<a name="ln5394">    const Dictionary arg1 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5395">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dict&quot;;      goto exit_0;</a>
<a name="ln5396">  }</a>
<a name="ln5397"> </a>
<a name="ln5398">  const Object ret = nvim_load_context(arg1);</a>
<a name="ln5399">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5400">api_free_object(ret);</a>
<a name="ln5401"> </a>
<a name="ln5402">  api_free_dictionary(arg1);</a>
<a name="ln5403"> </a>
<a name="ln5404">exit_0:</a>
<a name="ln5405">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5406">    luaL_where(lstate, 1);</a>
<a name="ln5407">    if (err_param) {</a>
<a name="ln5408">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5409">      lua_pushstring(lstate, err_param);</a>
<a name="ln5410">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5411">    }</a>
<a name="ln5412">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5413">    api_clear_error(&amp;err);</a>
<a name="ln5414">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5415">    return lua_error(lstate);</a>
<a name="ln5416">  }</a>
<a name="ln5417"> </a>
<a name="ln5418">  return 1;</a>
<a name="ln5419">}</a>
<a name="ln5420"> </a>
<a name="ln5421">static int nlua_api_nvim_get_mode(lua_State *lstate)</a>
<a name="ln5422">{</a>
<a name="ln5423">  Error err = ERROR_INIT;</a>
<a name="ln5424">  char *err_param = 0;</a>
<a name="ln5425">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5426">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5427">    goto exit_0;</a>
<a name="ln5428">  }</a>
<a name="ln5429">  const Dictionary ret = nvim_get_mode();</a>
<a name="ln5430">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5431">api_free_dictionary(ret);</a>
<a name="ln5432"> </a>
<a name="ln5433"> </a>
<a name="ln5434">exit_0:</a>
<a name="ln5435">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5436">    luaL_where(lstate, 1);</a>
<a name="ln5437">    if (err_param) {</a>
<a name="ln5438">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5439">      lua_pushstring(lstate, err_param);</a>
<a name="ln5440">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5441">    }</a>
<a name="ln5442">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5443">    api_clear_error(&amp;err);</a>
<a name="ln5444">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5445">    return lua_error(lstate);</a>
<a name="ln5446">  }</a>
<a name="ln5447"> </a>
<a name="ln5448">  return 1;</a>
<a name="ln5449">}</a>
<a name="ln5450"> </a>
<a name="ln5451">static int nlua_api_nvim_get_keymap(lua_State *lstate)</a>
<a name="ln5452">{</a>
<a name="ln5453">  Error err = ERROR_INIT;</a>
<a name="ln5454">  char *err_param = 0;</a>
<a name="ln5455">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5456">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5457">    goto exit_0;</a>
<a name="ln5458">  }</a>
<a name="ln5459">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5460">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_keymap&quot;);</a>
<a name="ln5461">  }</a>
<a name="ln5462">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5463">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_0;</a>
<a name="ln5464">  }</a>
<a name="ln5465"> </a>
<a name="ln5466">  const ArrayOf(Dictionary) ret = nvim_get_keymap(arg1);</a>
<a name="ln5467">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5468">api_free_array(ret);</a>
<a name="ln5469"> </a>
<a name="ln5470">  api_free_string(arg1);</a>
<a name="ln5471"> </a>
<a name="ln5472">exit_0:</a>
<a name="ln5473">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5474">    luaL_where(lstate, 1);</a>
<a name="ln5475">    if (err_param) {</a>
<a name="ln5476">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5477">      lua_pushstring(lstate, err_param);</a>
<a name="ln5478">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5479">    }</a>
<a name="ln5480">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5481">    api_clear_error(&amp;err);</a>
<a name="ln5482">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5483">    return lua_error(lstate);</a>
<a name="ln5484">  }</a>
<a name="ln5485"> </a>
<a name="ln5486">  return 1;</a>
<a name="ln5487">}</a>
<a name="ln5488"> </a>
<a name="ln5489">static int nlua_api_nvim_set_keymap(lua_State *lstate)</a>
<a name="ln5490">{</a>
<a name="ln5491">  Error err = ERROR_INIT;</a>
<a name="ln5492">  char *err_param = 0;</a>
<a name="ln5493">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5494">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5495">    goto exit_0;</a>
<a name="ln5496">  }</a>
<a name="ln5497">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5498">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_set_keymap&quot;);</a>
<a name="ln5499">  }</a>
<a name="ln5500">    KeyDict_keymap arg4 = { 0 }; nlua_pop_keydict(lstate, &amp;arg4, KeyDict_keymap_get_field, &amp;err_param, &amp;err);</a>
<a name="ln5501">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln5502">  }</a>
<a name="ln5503"> </a>
<a name="ln5504">    const String arg3 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5505">  if (ERROR_SET(&amp;err)) {      err_param = &quot;rhs&quot;;      goto exit_1;</a>
<a name="ln5506">  }</a>
<a name="ln5507"> </a>
<a name="ln5508">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5509">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_2;</a>
<a name="ln5510">  }</a>
<a name="ln5511"> </a>
<a name="ln5512">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5513">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_3;</a>
<a name="ln5514">  }</a>
<a name="ln5515"> </a>
<a name="ln5516">  nvim_set_keymap(LUA_INTERNAL_CALL, arg1, arg2, arg3, &amp;arg4, &amp;err);</a>
<a name="ln5517"> </a>
<a name="ln5518">  api_free_string(arg1);</a>
<a name="ln5519">exit_3:</a>
<a name="ln5520">  api_free_string(arg2);</a>
<a name="ln5521">exit_2:</a>
<a name="ln5522">  api_free_string(arg3);</a>
<a name="ln5523">exit_1:</a>
<a name="ln5524">  api_free_keydict_keymap(&amp;arg4);</a>
<a name="ln5525"> </a>
<a name="ln5526">exit_0:</a>
<a name="ln5527">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5528">    luaL_where(lstate, 1);</a>
<a name="ln5529">    if (err_param) {</a>
<a name="ln5530">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5531">      lua_pushstring(lstate, err_param);</a>
<a name="ln5532">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5533">    }</a>
<a name="ln5534">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5535">    api_clear_error(&amp;err);</a>
<a name="ln5536">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5537">    return lua_error(lstate);</a>
<a name="ln5538">  }</a>
<a name="ln5539"> </a>
<a name="ln5540">  return 0;</a>
<a name="ln5541">}</a>
<a name="ln5542"> </a>
<a name="ln5543">static int nlua_api_nvim_del_keymap(lua_State *lstate)</a>
<a name="ln5544">{</a>
<a name="ln5545">  Error err = ERROR_INIT;</a>
<a name="ln5546">  char *err_param = 0;</a>
<a name="ln5547">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln5548">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln5549">    goto exit_0;</a>
<a name="ln5550">  }</a>
<a name="ln5551">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5552">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_keymap&quot;);</a>
<a name="ln5553">  }</a>
<a name="ln5554">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5555">  if (ERROR_SET(&amp;err)) {      err_param = &quot;lhs&quot;;      goto exit_0;</a>
<a name="ln5556">  }</a>
<a name="ln5557"> </a>
<a name="ln5558">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln5559">  if (ERROR_SET(&amp;err)) {      err_param = &quot;mode&quot;;      goto exit_1;</a>
<a name="ln5560">  }</a>
<a name="ln5561"> </a>
<a name="ln5562">  nvim_del_keymap(LUA_INTERNAL_CALL, arg1, arg2, &amp;err);</a>
<a name="ln5563"> </a>
<a name="ln5564">  api_free_string(arg1);</a>
<a name="ln5565">exit_1:</a>
<a name="ln5566">  api_free_string(arg2);</a>
<a name="ln5567"> </a>
<a name="ln5568">exit_0:</a>
<a name="ln5569">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5570">    luaL_where(lstate, 1);</a>
<a name="ln5571">    if (err_param) {</a>
<a name="ln5572">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5573">      lua_pushstring(lstate, err_param);</a>
<a name="ln5574">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5575">    }</a>
<a name="ln5576">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5577">    api_clear_error(&amp;err);</a>
<a name="ln5578">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5579">    return lua_error(lstate);</a>
<a name="ln5580">  }</a>
<a name="ln5581"> </a>
<a name="ln5582">  return 0;</a>
<a name="ln5583">}</a>
<a name="ln5584"> </a>
<a name="ln5585">static int nlua_api_nvim_get_chan_info(lua_State *lstate)</a>
<a name="ln5586">{</a>
<a name="ln5587">  Error err = ERROR_INIT;</a>
<a name="ln5588">  char *err_param = 0;</a>
<a name="ln5589">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5590">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5591">    goto exit_0;</a>
<a name="ln5592">  }</a>
<a name="ln5593">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5594">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_chan_info&quot;);</a>
<a name="ln5595">  }</a>
<a name="ln5596">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5597">  if (ERROR_SET(&amp;err)) {      err_param = &quot;chan&quot;;      goto exit_0;</a>
<a name="ln5598">  }</a>
<a name="ln5599"> </a>
<a name="ln5600">  const Dictionary ret = nvim_get_chan_info(arg1, &amp;err);</a>
<a name="ln5601">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5602">api_free_dictionary(ret);</a>
<a name="ln5603"> </a>
<a name="ln5604">  api_free_integer(arg1);</a>
<a name="ln5605"> </a>
<a name="ln5606">exit_0:</a>
<a name="ln5607">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5608">    luaL_where(lstate, 1);</a>
<a name="ln5609">    if (err_param) {</a>
<a name="ln5610">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5611">      lua_pushstring(lstate, err_param);</a>
<a name="ln5612">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5613">    }</a>
<a name="ln5614">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5615">    api_clear_error(&amp;err);</a>
<a name="ln5616">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5617">    return lua_error(lstate);</a>
<a name="ln5618">  }</a>
<a name="ln5619"> </a>
<a name="ln5620">  return 1;</a>
<a name="ln5621">}</a>
<a name="ln5622"> </a>
<a name="ln5623">static int nlua_api_nvim_list_chans(lua_State *lstate)</a>
<a name="ln5624">{</a>
<a name="ln5625">  Error err = ERROR_INIT;</a>
<a name="ln5626">  char *err_param = 0;</a>
<a name="ln5627">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5628">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5629">    goto exit_0;</a>
<a name="ln5630">  }</a>
<a name="ln5631">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5632">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_chans&quot;);</a>
<a name="ln5633">  }</a>
<a name="ln5634">  const Array ret = nvim_list_chans();</a>
<a name="ln5635">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5636">api_free_array(ret);</a>
<a name="ln5637"> </a>
<a name="ln5638"> </a>
<a name="ln5639">exit_0:</a>
<a name="ln5640">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5641">    luaL_where(lstate, 1);</a>
<a name="ln5642">    if (err_param) {</a>
<a name="ln5643">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5644">      lua_pushstring(lstate, err_param);</a>
<a name="ln5645">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5646">    }</a>
<a name="ln5647">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5648">    api_clear_error(&amp;err);</a>
<a name="ln5649">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5650">    return lua_error(lstate);</a>
<a name="ln5651">  }</a>
<a name="ln5652"> </a>
<a name="ln5653">  return 1;</a>
<a name="ln5654">}</a>
<a name="ln5655"> </a>
<a name="ln5656">static int nlua_api_nvim__id(lua_State *lstate)</a>
<a name="ln5657">{</a>
<a name="ln5658">  Error err = ERROR_INIT;</a>
<a name="ln5659">  char *err_param = 0;</a>
<a name="ln5660">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5661">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5662">    goto exit_0;</a>
<a name="ln5663">  }</a>
<a name="ln5664">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5665">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id&quot;);</a>
<a name="ln5666">  }</a>
<a name="ln5667">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln5668">  if (ERROR_SET(&amp;err)) {      err_param = &quot;obj&quot;;      goto exit_0;</a>
<a name="ln5669">  }</a>
<a name="ln5670"> </a>
<a name="ln5671">  const Object ret = nvim__id(arg1);</a>
<a name="ln5672">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5673">api_free_object(ret);</a>
<a name="ln5674"> </a>
<a name="ln5675">  api_free_object(arg1);</a>
<a name="ln5676"> </a>
<a name="ln5677">exit_0:</a>
<a name="ln5678">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5679">    luaL_where(lstate, 1);</a>
<a name="ln5680">    if (err_param) {</a>
<a name="ln5681">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5682">      lua_pushstring(lstate, err_param);</a>
<a name="ln5683">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5684">    }</a>
<a name="ln5685">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5686">    api_clear_error(&amp;err);</a>
<a name="ln5687">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5688">    return lua_error(lstate);</a>
<a name="ln5689">  }</a>
<a name="ln5690"> </a>
<a name="ln5691">  return 1;</a>
<a name="ln5692">}</a>
<a name="ln5693"> </a>
<a name="ln5694">static int nlua_api_nvim__id_array(lua_State *lstate)</a>
<a name="ln5695">{</a>
<a name="ln5696">  Error err = ERROR_INIT;</a>
<a name="ln5697">  char *err_param = 0;</a>
<a name="ln5698">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5699">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5700">    goto exit_0;</a>
<a name="ln5701">  }</a>
<a name="ln5702">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5703">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_array&quot;);</a>
<a name="ln5704">  }</a>
<a name="ln5705">    const Array arg1 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln5706">  if (ERROR_SET(&amp;err)) {      err_param = &quot;arr&quot;;      goto exit_0;</a>
<a name="ln5707">  }</a>
<a name="ln5708"> </a>
<a name="ln5709">  const Array ret = nvim__id_array(arg1);</a>
<a name="ln5710">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5711">api_free_array(ret);</a>
<a name="ln5712"> </a>
<a name="ln5713">  api_free_array(arg1);</a>
<a name="ln5714"> </a>
<a name="ln5715">exit_0:</a>
<a name="ln5716">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5717">    luaL_where(lstate, 1);</a>
<a name="ln5718">    if (err_param) {</a>
<a name="ln5719">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5720">      lua_pushstring(lstate, err_param);</a>
<a name="ln5721">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5722">    }</a>
<a name="ln5723">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5724">    api_clear_error(&amp;err);</a>
<a name="ln5725">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5726">    return lua_error(lstate);</a>
<a name="ln5727">  }</a>
<a name="ln5728"> </a>
<a name="ln5729">  return 1;</a>
<a name="ln5730">}</a>
<a name="ln5731"> </a>
<a name="ln5732">static int nlua_api_nvim__id_dictionary(lua_State *lstate)</a>
<a name="ln5733">{</a>
<a name="ln5734">  Error err = ERROR_INIT;</a>
<a name="ln5735">  char *err_param = 0;</a>
<a name="ln5736">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5737">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5738">    goto exit_0;</a>
<a name="ln5739">  }</a>
<a name="ln5740">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5741">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_dictionary&quot;);</a>
<a name="ln5742">  }</a>
<a name="ln5743">    const Dictionary arg1 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5744">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dct&quot;;      goto exit_0;</a>
<a name="ln5745">  }</a>
<a name="ln5746"> </a>
<a name="ln5747">  const Dictionary ret = nvim__id_dictionary(arg1);</a>
<a name="ln5748">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5749">api_free_dictionary(ret);</a>
<a name="ln5750"> </a>
<a name="ln5751">  api_free_dictionary(arg1);</a>
<a name="ln5752"> </a>
<a name="ln5753">exit_0:</a>
<a name="ln5754">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5755">    luaL_where(lstate, 1);</a>
<a name="ln5756">    if (err_param) {</a>
<a name="ln5757">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5758">      lua_pushstring(lstate, err_param);</a>
<a name="ln5759">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5760">    }</a>
<a name="ln5761">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5762">    api_clear_error(&amp;err);</a>
<a name="ln5763">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5764">    return lua_error(lstate);</a>
<a name="ln5765">  }</a>
<a name="ln5766"> </a>
<a name="ln5767">  return 1;</a>
<a name="ln5768">}</a>
<a name="ln5769"> </a>
<a name="ln5770">static int nlua_api_nvim__id_float(lua_State *lstate)</a>
<a name="ln5771">{</a>
<a name="ln5772">  Error err = ERROR_INIT;</a>
<a name="ln5773">  char *err_param = 0;</a>
<a name="ln5774">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5775">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5776">    goto exit_0;</a>
<a name="ln5777">  }</a>
<a name="ln5778">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5779">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__id_float&quot;);</a>
<a name="ln5780">  }</a>
<a name="ln5781">    const Float arg1 = nlua_pop_Float(lstate, &amp;err);</a>
<a name="ln5782">  if (ERROR_SET(&amp;err)) {      err_param = &quot;flt&quot;;      goto exit_0;</a>
<a name="ln5783">  }</a>
<a name="ln5784"> </a>
<a name="ln5785">  const Float ret = nvim__id_float(arg1);</a>
<a name="ln5786">  nlua_push_Float(lstate, ret, true);</a>
<a name="ln5787">api_free_float(ret);</a>
<a name="ln5788"> </a>
<a name="ln5789">  api_free_float(arg1);</a>
<a name="ln5790"> </a>
<a name="ln5791">exit_0:</a>
<a name="ln5792">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5793">    luaL_where(lstate, 1);</a>
<a name="ln5794">    if (err_param) {</a>
<a name="ln5795">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5796">      lua_pushstring(lstate, err_param);</a>
<a name="ln5797">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5798">    }</a>
<a name="ln5799">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5800">    api_clear_error(&amp;err);</a>
<a name="ln5801">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5802">    return lua_error(lstate);</a>
<a name="ln5803">  }</a>
<a name="ln5804"> </a>
<a name="ln5805">  return 1;</a>
<a name="ln5806">}</a>
<a name="ln5807"> </a>
<a name="ln5808">static int nlua_api_nvim__stats(lua_State *lstate)</a>
<a name="ln5809">{</a>
<a name="ln5810">  Error err = ERROR_INIT;</a>
<a name="ln5811">  char *err_param = 0;</a>
<a name="ln5812">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5813">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5814">    goto exit_0;</a>
<a name="ln5815">  }</a>
<a name="ln5816">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5817">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__stats&quot;);</a>
<a name="ln5818">  }</a>
<a name="ln5819">  const Dictionary ret = nvim__stats();</a>
<a name="ln5820">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln5821">api_free_dictionary(ret);</a>
<a name="ln5822"> </a>
<a name="ln5823"> </a>
<a name="ln5824">exit_0:</a>
<a name="ln5825">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5826">    luaL_where(lstate, 1);</a>
<a name="ln5827">    if (err_param) {</a>
<a name="ln5828">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5829">      lua_pushstring(lstate, err_param);</a>
<a name="ln5830">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5831">    }</a>
<a name="ln5832">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5833">    api_clear_error(&amp;err);</a>
<a name="ln5834">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5835">    return lua_error(lstate);</a>
<a name="ln5836">  }</a>
<a name="ln5837"> </a>
<a name="ln5838">  return 1;</a>
<a name="ln5839">}</a>
<a name="ln5840"> </a>
<a name="ln5841">static int nlua_api_nvim_list_uis(lua_State *lstate)</a>
<a name="ln5842">{</a>
<a name="ln5843">  Error err = ERROR_INIT;</a>
<a name="ln5844">  char *err_param = 0;</a>
<a name="ln5845">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln5846">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln5847">    goto exit_0;</a>
<a name="ln5848">  }</a>
<a name="ln5849">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5850">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_list_uis&quot;);</a>
<a name="ln5851">  }</a>
<a name="ln5852">  const Array ret = nvim_list_uis();</a>
<a name="ln5853">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5854">api_free_array(ret);</a>
<a name="ln5855"> </a>
<a name="ln5856"> </a>
<a name="ln5857">exit_0:</a>
<a name="ln5858">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5859">    luaL_where(lstate, 1);</a>
<a name="ln5860">    if (err_param) {</a>
<a name="ln5861">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5862">      lua_pushstring(lstate, err_param);</a>
<a name="ln5863">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5864">    }</a>
<a name="ln5865">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5866">    api_clear_error(&amp;err);</a>
<a name="ln5867">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5868">    return lua_error(lstate);</a>
<a name="ln5869">  }</a>
<a name="ln5870"> </a>
<a name="ln5871">  return 1;</a>
<a name="ln5872">}</a>
<a name="ln5873"> </a>
<a name="ln5874">static int nlua_api_nvim_get_proc_children(lua_State *lstate)</a>
<a name="ln5875">{</a>
<a name="ln5876">  Error err = ERROR_INIT;</a>
<a name="ln5877">  char *err_param = 0;</a>
<a name="ln5878">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5879">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5880">    goto exit_0;</a>
<a name="ln5881">  }</a>
<a name="ln5882">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5883">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_proc_children&quot;);</a>
<a name="ln5884">  }</a>
<a name="ln5885">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5886">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pid&quot;;      goto exit_0;</a>
<a name="ln5887">  }</a>
<a name="ln5888"> </a>
<a name="ln5889">  const Array ret = nvim_get_proc_children(arg1, &amp;err);</a>
<a name="ln5890">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln5891">api_free_array(ret);</a>
<a name="ln5892"> </a>
<a name="ln5893">  api_free_integer(arg1);</a>
<a name="ln5894"> </a>
<a name="ln5895">exit_0:</a>
<a name="ln5896">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5897">    luaL_where(lstate, 1);</a>
<a name="ln5898">    if (err_param) {</a>
<a name="ln5899">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5900">      lua_pushstring(lstate, err_param);</a>
<a name="ln5901">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5902">    }</a>
<a name="ln5903">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5904">    api_clear_error(&amp;err);</a>
<a name="ln5905">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5906">    return lua_error(lstate);</a>
<a name="ln5907">  }</a>
<a name="ln5908"> </a>
<a name="ln5909">  return 1;</a>
<a name="ln5910">}</a>
<a name="ln5911"> </a>
<a name="ln5912">static int nlua_api_nvim_get_proc(lua_State *lstate)</a>
<a name="ln5913">{</a>
<a name="ln5914">  Error err = ERROR_INIT;</a>
<a name="ln5915">  char *err_param = 0;</a>
<a name="ln5916">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln5917">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln5918">    goto exit_0;</a>
<a name="ln5919">  }</a>
<a name="ln5920">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5921">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_proc&quot;);</a>
<a name="ln5922">  }</a>
<a name="ln5923">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5924">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pid&quot;;      goto exit_0;</a>
<a name="ln5925">  }</a>
<a name="ln5926"> </a>
<a name="ln5927">  const Object ret = nvim_get_proc(arg1, &amp;err);</a>
<a name="ln5928">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln5929">api_free_object(ret);</a>
<a name="ln5930"> </a>
<a name="ln5931">  api_free_integer(arg1);</a>
<a name="ln5932"> </a>
<a name="ln5933">exit_0:</a>
<a name="ln5934">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5935">    luaL_where(lstate, 1);</a>
<a name="ln5936">    if (err_param) {</a>
<a name="ln5937">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5938">      lua_pushstring(lstate, err_param);</a>
<a name="ln5939">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5940">    }</a>
<a name="ln5941">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5942">    api_clear_error(&amp;err);</a>
<a name="ln5943">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5944">    return lua_error(lstate);</a>
<a name="ln5945">  }</a>
<a name="ln5946"> </a>
<a name="ln5947">  return 1;</a>
<a name="ln5948">}</a>
<a name="ln5949"> </a>
<a name="ln5950">static int nlua_api_nvim_select_popupmenu_item(lua_State *lstate)</a>
<a name="ln5951">{</a>
<a name="ln5952">  Error err = ERROR_INIT;</a>
<a name="ln5953">  char *err_param = 0;</a>
<a name="ln5954">  if (lua_gettop(lstate) != 4) {</a>
<a name="ln5955">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 4 arguments&quot;);</a>
<a name="ln5956">    goto exit_0;</a>
<a name="ln5957">  }</a>
<a name="ln5958">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln5959">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_select_popupmenu_item&quot;);</a>
<a name="ln5960">  }</a>
<a name="ln5961">    const Dictionary arg4 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln5962">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln5963">  }</a>
<a name="ln5964"> </a>
<a name="ln5965">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5966">  if (ERROR_SET(&amp;err)) {      err_param = &quot;finish&quot;;      goto exit_1;</a>
<a name="ln5967">  }</a>
<a name="ln5968"> </a>
<a name="ln5969">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln5970">  if (ERROR_SET(&amp;err)) {      err_param = &quot;insert&quot;;      goto exit_2;</a>
<a name="ln5971">  }</a>
<a name="ln5972"> </a>
<a name="ln5973">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln5974">  if (ERROR_SET(&amp;err)) {      err_param = &quot;item&quot;;      goto exit_3;</a>
<a name="ln5975">  }</a>
<a name="ln5976"> </a>
<a name="ln5977">  nvim_select_popupmenu_item(arg1, arg2, arg3, arg4, &amp;err);</a>
<a name="ln5978"> </a>
<a name="ln5979">  api_free_integer(arg1);</a>
<a name="ln5980">exit_3:</a>
<a name="ln5981">  api_free_boolean(arg2);</a>
<a name="ln5982">exit_2:</a>
<a name="ln5983">  api_free_boolean(arg3);</a>
<a name="ln5984">exit_1:</a>
<a name="ln5985">  api_free_dictionary(arg4);</a>
<a name="ln5986"> </a>
<a name="ln5987">exit_0:</a>
<a name="ln5988">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln5989">    luaL_where(lstate, 1);</a>
<a name="ln5990">    if (err_param) {</a>
<a name="ln5991">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln5992">      lua_pushstring(lstate, err_param);</a>
<a name="ln5993">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln5994">    }</a>
<a name="ln5995">    lua_pushstring(lstate, err.msg);</a>
<a name="ln5996">    api_clear_error(&amp;err);</a>
<a name="ln5997">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln5998">    return lua_error(lstate);</a>
<a name="ln5999">  }</a>
<a name="ln6000"> </a>
<a name="ln6001">  return 0;</a>
<a name="ln6002">}</a>
<a name="ln6003"> </a>
<a name="ln6004">static int nlua_api_nvim__inspect_cell(lua_State *lstate)</a>
<a name="ln6005">{</a>
<a name="ln6006">  Error err = ERROR_INIT;</a>
<a name="ln6007">  char *err_param = 0;</a>
<a name="ln6008">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6009">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6010">    goto exit_0;</a>
<a name="ln6011">  }</a>
<a name="ln6012">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6013">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__inspect_cell&quot;);</a>
<a name="ln6014">  }</a>
<a name="ln6015">    const Integer arg3 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6016">  if (ERROR_SET(&amp;err)) {      err_param = &quot;col&quot;;      goto exit_0;</a>
<a name="ln6017">  }</a>
<a name="ln6018"> </a>
<a name="ln6019">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6020">  if (ERROR_SET(&amp;err)) {      err_param = &quot;row&quot;;      goto exit_1;</a>
<a name="ln6021">  }</a>
<a name="ln6022"> </a>
<a name="ln6023">    const Integer arg1 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6024">  if (ERROR_SET(&amp;err)) {      err_param = &quot;grid&quot;;      goto exit_2;</a>
<a name="ln6025">  }</a>
<a name="ln6026"> </a>
<a name="ln6027">  Arena arena = ARENA_EMPTY;</a>
<a name="ln6028">  const Array ret = nvim__inspect_cell(arg1, arg2, arg3, &amp;arena, &amp;err);</a>
<a name="ln6029">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln6030">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln6031"> </a>
<a name="ln6032">  api_free_integer(arg1);</a>
<a name="ln6033">exit_2:</a>
<a name="ln6034">  api_free_integer(arg2);</a>
<a name="ln6035">exit_1:</a>
<a name="ln6036">  api_free_integer(arg3);</a>
<a name="ln6037"> </a>
<a name="ln6038">exit_0:</a>
<a name="ln6039">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6040">    luaL_where(lstate, 1);</a>
<a name="ln6041">    if (err_param) {</a>
<a name="ln6042">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6043">      lua_pushstring(lstate, err_param);</a>
<a name="ln6044">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6045">    }</a>
<a name="ln6046">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6047">    api_clear_error(&amp;err);</a>
<a name="ln6048">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6049">    return lua_error(lstate);</a>
<a name="ln6050">  }</a>
<a name="ln6051"> </a>
<a name="ln6052">  return 1;</a>
<a name="ln6053">}</a>
<a name="ln6054"> </a>
<a name="ln6055">static int nlua_api_nvim__screenshot(lua_State *lstate)</a>
<a name="ln6056">{</a>
<a name="ln6057">  Error err = ERROR_INIT;</a>
<a name="ln6058">  char *err_param = 0;</a>
<a name="ln6059">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6060">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6061">    goto exit_0;</a>
<a name="ln6062">  }</a>
<a name="ln6063">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6064">  if (ERROR_SET(&amp;err)) {      err_param = &quot;path&quot;;      goto exit_0;</a>
<a name="ln6065">  }</a>
<a name="ln6066"> </a>
<a name="ln6067">  nvim__screenshot(arg1);</a>
<a name="ln6068"> </a>
<a name="ln6069">  api_free_string(arg1);</a>
<a name="ln6070"> </a>
<a name="ln6071">exit_0:</a>
<a name="ln6072">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6073">    luaL_where(lstate, 1);</a>
<a name="ln6074">    if (err_param) {</a>
<a name="ln6075">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6076">      lua_pushstring(lstate, err_param);</a>
<a name="ln6077">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6078">    }</a>
<a name="ln6079">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6080">    api_clear_error(&amp;err);</a>
<a name="ln6081">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6082">    return lua_error(lstate);</a>
<a name="ln6083">  }</a>
<a name="ln6084"> </a>
<a name="ln6085">  return 0;</a>
<a name="ln6086">}</a>
<a name="ln6087"> </a>
<a name="ln6088">static int nlua_api_nvim__invalidate_glyph_cache(lua_State *lstate)</a>
<a name="ln6089">{</a>
<a name="ln6090">  Error err = ERROR_INIT;</a>
<a name="ln6091">  char *err_param = 0;</a>
<a name="ln6092">  if (lua_gettop(lstate) != 0) {</a>
<a name="ln6093">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 0 arguments&quot;);</a>
<a name="ln6094">    goto exit_0;</a>
<a name="ln6095">  }</a>
<a name="ln6096">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6097">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim__invalidate_glyph_cache&quot;);</a>
<a name="ln6098">  }</a>
<a name="ln6099">  nvim__invalidate_glyph_cache();</a>
<a name="ln6100"> </a>
<a name="ln6101"> </a>
<a name="ln6102">exit_0:</a>
<a name="ln6103">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6104">    luaL_where(lstate, 1);</a>
<a name="ln6105">    if (err_param) {</a>
<a name="ln6106">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6107">      lua_pushstring(lstate, err_param);</a>
<a name="ln6108">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6109">    }</a>
<a name="ln6110">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6111">    api_clear_error(&amp;err);</a>
<a name="ln6112">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6113">    return lua_error(lstate);</a>
<a name="ln6114">  }</a>
<a name="ln6115"> </a>
<a name="ln6116">  return 0;</a>
<a name="ln6117">}</a>
<a name="ln6118"> </a>
<a name="ln6119">static int nlua_api_nvim__unpack(lua_State *lstate)</a>
<a name="ln6120">{</a>
<a name="ln6121">  Error err = ERROR_INIT;</a>
<a name="ln6122">  char *err_param = 0;</a>
<a name="ln6123">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6124">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6125">    goto exit_0;</a>
<a name="ln6126">  }</a>
<a name="ln6127">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6128">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_0;</a>
<a name="ln6129">  }</a>
<a name="ln6130"> </a>
<a name="ln6131">  const Object ret = nvim__unpack(arg1, &amp;err);</a>
<a name="ln6132">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6133">api_free_object(ret);</a>
<a name="ln6134"> </a>
<a name="ln6135">  api_free_string(arg1);</a>
<a name="ln6136"> </a>
<a name="ln6137">exit_0:</a>
<a name="ln6138">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6139">    luaL_where(lstate, 1);</a>
<a name="ln6140">    if (err_param) {</a>
<a name="ln6141">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6142">      lua_pushstring(lstate, err_param);</a>
<a name="ln6143">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6144">    }</a>
<a name="ln6145">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6146">    api_clear_error(&amp;err);</a>
<a name="ln6147">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6148">    return lua_error(lstate);</a>
<a name="ln6149">  }</a>
<a name="ln6150"> </a>
<a name="ln6151">  return 1;</a>
<a name="ln6152">}</a>
<a name="ln6153"> </a>
<a name="ln6154">static int nlua_api_nvim_del_mark(lua_State *lstate)</a>
<a name="ln6155">{</a>
<a name="ln6156">  Error err = ERROR_INIT;</a>
<a name="ln6157">  char *err_param = 0;</a>
<a name="ln6158">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6159">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6160">    goto exit_0;</a>
<a name="ln6161">  }</a>
<a name="ln6162">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6163">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_del_mark&quot;);</a>
<a name="ln6164">  }</a>
<a name="ln6165">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6166">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln6167">  }</a>
<a name="ln6168"> </a>
<a name="ln6169">  const Boolean ret = nvim_del_mark(arg1, &amp;err);</a>
<a name="ln6170">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln6171">api_free_boolean(ret);</a>
<a name="ln6172"> </a>
<a name="ln6173">  api_free_string(arg1);</a>
<a name="ln6174"> </a>
<a name="ln6175">exit_0:</a>
<a name="ln6176">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6177">    luaL_where(lstate, 1);</a>
<a name="ln6178">    if (err_param) {</a>
<a name="ln6179">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6180">      lua_pushstring(lstate, err_param);</a>
<a name="ln6181">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6182">    }</a>
<a name="ln6183">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6184">    api_clear_error(&amp;err);</a>
<a name="ln6185">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6186">    return lua_error(lstate);</a>
<a name="ln6187">  }</a>
<a name="ln6188"> </a>
<a name="ln6189">  return 1;</a>
<a name="ln6190">}</a>
<a name="ln6191"> </a>
<a name="ln6192">static int nlua_api_nvim_get_mark(lua_State *lstate)</a>
<a name="ln6193">{</a>
<a name="ln6194">  Error err = ERROR_INIT;</a>
<a name="ln6195">  char *err_param = 0;</a>
<a name="ln6196">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6197">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6198">    goto exit_0;</a>
<a name="ln6199">  }</a>
<a name="ln6200">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6201">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_get_mark&quot;);</a>
<a name="ln6202">  }</a>
<a name="ln6203">    const Dictionary arg2 = nlua_pop_Dictionary(lstate, false, &amp;err);</a>
<a name="ln6204">  if (ERROR_SET(&amp;err)) {      err_param = &quot;opts&quot;;      goto exit_0;</a>
<a name="ln6205">  }</a>
<a name="ln6206"> </a>
<a name="ln6207">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6208">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln6209">  }</a>
<a name="ln6210"> </a>
<a name="ln6211">  const Array ret = nvim_get_mark(arg1, arg2, &amp;err);</a>
<a name="ln6212">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln6213">api_free_array(ret);</a>
<a name="ln6214"> </a>
<a name="ln6215">  api_free_string(arg1);</a>
<a name="ln6216">exit_1:</a>
<a name="ln6217">  api_free_dictionary(arg2);</a>
<a name="ln6218"> </a>
<a name="ln6219">exit_0:</a>
<a name="ln6220">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6221">    luaL_where(lstate, 1);</a>
<a name="ln6222">    if (err_param) {</a>
<a name="ln6223">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6224">      lua_pushstring(lstate, err_param);</a>
<a name="ln6225">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6226">    }</a>
<a name="ln6227">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6228">    api_clear_error(&amp;err);</a>
<a name="ln6229">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6230">    return lua_error(lstate);</a>
<a name="ln6231">  }</a>
<a name="ln6232"> </a>
<a name="ln6233">  return 1;</a>
<a name="ln6234">}</a>
<a name="ln6235"> </a>
<a name="ln6236">static int nlua_api_nvim_eval_statusline(lua_State *lstate)</a>
<a name="ln6237">{</a>
<a name="ln6238">  Error err = ERROR_INIT;</a>
<a name="ln6239">  char *err_param = 0;</a>
<a name="ln6240">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6241">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6242">    goto exit_0;</a>
<a name="ln6243">  }</a>
<a name="ln6244">    KeyDict_eval_statusline arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_eval_statusline_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6245">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6246">  }</a>
<a name="ln6247"> </a>
<a name="ln6248">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6249">  if (ERROR_SET(&amp;err)) {      err_param = &quot;str&quot;;      goto exit_1;</a>
<a name="ln6250">  }</a>
<a name="ln6251"> </a>
<a name="ln6252">  const Dictionary ret = nvim_eval_statusline(arg1, &amp;arg2, &amp;err);</a>
<a name="ln6253">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6254">api_free_dictionary(ret);</a>
<a name="ln6255"> </a>
<a name="ln6256">  api_free_string(arg1);</a>
<a name="ln6257">exit_1:</a>
<a name="ln6258">  api_free_keydict_eval_statusline(&amp;arg2);</a>
<a name="ln6259"> </a>
<a name="ln6260">exit_0:</a>
<a name="ln6261">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6262">    luaL_where(lstate, 1);</a>
<a name="ln6263">    if (err_param) {</a>
<a name="ln6264">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6265">      lua_pushstring(lstate, err_param);</a>
<a name="ln6266">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6267">    }</a>
<a name="ln6268">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6269">    api_clear_error(&amp;err);</a>
<a name="ln6270">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6271">    return lua_error(lstate);</a>
<a name="ln6272">  }</a>
<a name="ln6273"> </a>
<a name="ln6274">  return 1;</a>
<a name="ln6275">}</a>
<a name="ln6276"> </a>
<a name="ln6277">static int nlua_api_nvim_exec2(lua_State *lstate)</a>
<a name="ln6278">{</a>
<a name="ln6279">  Error err = ERROR_INIT;</a>
<a name="ln6280">  char *err_param = 0;</a>
<a name="ln6281">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6282">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6283">    goto exit_0;</a>
<a name="ln6284">  }</a>
<a name="ln6285">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6286">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_exec2&quot;);</a>
<a name="ln6287">  }</a>
<a name="ln6288">    KeyDict_exec_opts arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_exec_opts_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6289">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6290">  }</a>
<a name="ln6291"> </a>
<a name="ln6292">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6293">  if (ERROR_SET(&amp;err)) {      err_param = &quot;src&quot;;      goto exit_1;</a>
<a name="ln6294">  }</a>
<a name="ln6295"> </a>
<a name="ln6296">  const Dictionary ret = nvim_exec2(LUA_INTERNAL_CALL, arg1, &amp;arg2, &amp;err);</a>
<a name="ln6297">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln6298">api_free_dictionary(ret);</a>
<a name="ln6299"> </a>
<a name="ln6300">  api_free_string(arg1);</a>
<a name="ln6301">exit_1:</a>
<a name="ln6302">  api_free_keydict_exec_opts(&amp;arg2);</a>
<a name="ln6303"> </a>
<a name="ln6304">exit_0:</a>
<a name="ln6305">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6306">    luaL_where(lstate, 1);</a>
<a name="ln6307">    if (err_param) {</a>
<a name="ln6308">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6309">      lua_pushstring(lstate, err_param);</a>
<a name="ln6310">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6311">    }</a>
<a name="ln6312">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6313">    api_clear_error(&amp;err);</a>
<a name="ln6314">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6315">    return lua_error(lstate);</a>
<a name="ln6316">  }</a>
<a name="ln6317"> </a>
<a name="ln6318">  return 1;</a>
<a name="ln6319">}</a>
<a name="ln6320"> </a>
<a name="ln6321">static int nlua_api_nvim_command(lua_State *lstate)</a>
<a name="ln6322">{</a>
<a name="ln6323">  Error err = ERROR_INIT;</a>
<a name="ln6324">  char *err_param = 0;</a>
<a name="ln6325">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6326">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6327">    goto exit_0;</a>
<a name="ln6328">  }</a>
<a name="ln6329">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6330">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_command&quot;);</a>
<a name="ln6331">  }</a>
<a name="ln6332">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6333">  if (ERROR_SET(&amp;err)) {      err_param = &quot;command&quot;;      goto exit_0;</a>
<a name="ln6334">  }</a>
<a name="ln6335"> </a>
<a name="ln6336">  nvim_command(arg1, &amp;err);</a>
<a name="ln6337"> </a>
<a name="ln6338">  api_free_string(arg1);</a>
<a name="ln6339"> </a>
<a name="ln6340">exit_0:</a>
<a name="ln6341">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6342">    luaL_where(lstate, 1);</a>
<a name="ln6343">    if (err_param) {</a>
<a name="ln6344">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6345">      lua_pushstring(lstate, err_param);</a>
<a name="ln6346">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6347">    }</a>
<a name="ln6348">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6349">    api_clear_error(&amp;err);</a>
<a name="ln6350">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6351">    return lua_error(lstate);</a>
<a name="ln6352">  }</a>
<a name="ln6353"> </a>
<a name="ln6354">  return 0;</a>
<a name="ln6355">}</a>
<a name="ln6356"> </a>
<a name="ln6357">static int nlua_api_nvim_eval(lua_State *lstate)</a>
<a name="ln6358">{</a>
<a name="ln6359">  Error err = ERROR_INIT;</a>
<a name="ln6360">  char *err_param = 0;</a>
<a name="ln6361">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6362">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6363">    goto exit_0;</a>
<a name="ln6364">  }</a>
<a name="ln6365">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6366">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_eval&quot;);</a>
<a name="ln6367">  }</a>
<a name="ln6368">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6369">  if (ERROR_SET(&amp;err)) {      err_param = &quot;expr&quot;;      goto exit_0;</a>
<a name="ln6370">  }</a>
<a name="ln6371"> </a>
<a name="ln6372">  const Object ret = nvim_eval(arg1, &amp;err);</a>
<a name="ln6373">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6374">api_free_object(ret);</a>
<a name="ln6375"> </a>
<a name="ln6376">  api_free_string(arg1);</a>
<a name="ln6377"> </a>
<a name="ln6378">exit_0:</a>
<a name="ln6379">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6380">    luaL_where(lstate, 1);</a>
<a name="ln6381">    if (err_param) {</a>
<a name="ln6382">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6383">      lua_pushstring(lstate, err_param);</a>
<a name="ln6384">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6385">    }</a>
<a name="ln6386">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6387">    api_clear_error(&amp;err);</a>
<a name="ln6388">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6389">    return lua_error(lstate);</a>
<a name="ln6390">  }</a>
<a name="ln6391"> </a>
<a name="ln6392">  return 1;</a>
<a name="ln6393">}</a>
<a name="ln6394"> </a>
<a name="ln6395">static int nlua_api_nvim_call_function(lua_State *lstate)</a>
<a name="ln6396">{</a>
<a name="ln6397">  Error err = ERROR_INIT;</a>
<a name="ln6398">  char *err_param = 0;</a>
<a name="ln6399">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6400">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6401">    goto exit_0;</a>
<a name="ln6402">  }</a>
<a name="ln6403">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6404">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_call_function&quot;);</a>
<a name="ln6405">  }</a>
<a name="ln6406">    const Array arg2 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6407">  if (ERROR_SET(&amp;err)) {      err_param = &quot;args&quot;;      goto exit_0;</a>
<a name="ln6408">  }</a>
<a name="ln6409"> </a>
<a name="ln6410">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6411">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fn&quot;;      goto exit_1;</a>
<a name="ln6412">  }</a>
<a name="ln6413"> </a>
<a name="ln6414">  const Object ret = nvim_call_function(arg1, arg2, &amp;err);</a>
<a name="ln6415">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6416">api_free_object(ret);</a>
<a name="ln6417"> </a>
<a name="ln6418">  api_free_string(arg1);</a>
<a name="ln6419">exit_1:</a>
<a name="ln6420">  api_free_array(arg2);</a>
<a name="ln6421"> </a>
<a name="ln6422">exit_0:</a>
<a name="ln6423">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6424">    luaL_where(lstate, 1);</a>
<a name="ln6425">    if (err_param) {</a>
<a name="ln6426">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6427">      lua_pushstring(lstate, err_param);</a>
<a name="ln6428">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6429">    }</a>
<a name="ln6430">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6431">    api_clear_error(&amp;err);</a>
<a name="ln6432">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6433">    return lua_error(lstate);</a>
<a name="ln6434">  }</a>
<a name="ln6435"> </a>
<a name="ln6436">  return 1;</a>
<a name="ln6437">}</a>
<a name="ln6438"> </a>
<a name="ln6439">static int nlua_api_nvim_call_dict_function(lua_State *lstate)</a>
<a name="ln6440">{</a>
<a name="ln6441">  Error err = ERROR_INIT;</a>
<a name="ln6442">  char *err_param = 0;</a>
<a name="ln6443">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6444">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6445">    goto exit_0;</a>
<a name="ln6446">  }</a>
<a name="ln6447">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6448">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_call_dict_function&quot;);</a>
<a name="ln6449">  }</a>
<a name="ln6450">    const Array arg3 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6451">  if (ERROR_SET(&amp;err)) {      err_param = &quot;args&quot;;      goto exit_0;</a>
<a name="ln6452">  }</a>
<a name="ln6453"> </a>
<a name="ln6454">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6455">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fn&quot;;      goto exit_1;</a>
<a name="ln6456">  }</a>
<a name="ln6457"> </a>
<a name="ln6458">    const Object arg1 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln6459">  if (ERROR_SET(&amp;err)) {      err_param = &quot;dict&quot;;      goto exit_2;</a>
<a name="ln6460">  }</a>
<a name="ln6461"> </a>
<a name="ln6462">  const Object ret = nvim_call_dict_function(arg1, arg2, arg3, &amp;err);</a>
<a name="ln6463">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln6464">api_free_object(ret);</a>
<a name="ln6465"> </a>
<a name="ln6466">  api_free_object(arg1);</a>
<a name="ln6467">exit_2:</a>
<a name="ln6468">  api_free_string(arg2);</a>
<a name="ln6469">exit_1:</a>
<a name="ln6470">  api_free_array(arg3);</a>
<a name="ln6471"> </a>
<a name="ln6472">exit_0:</a>
<a name="ln6473">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6474">    luaL_where(lstate, 1);</a>
<a name="ln6475">    if (err_param) {</a>
<a name="ln6476">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6477">      lua_pushstring(lstate, err_param);</a>
<a name="ln6478">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6479">    }</a>
<a name="ln6480">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6481">    api_clear_error(&amp;err);</a>
<a name="ln6482">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6483">    return lua_error(lstate);</a>
<a name="ln6484">  }</a>
<a name="ln6485"> </a>
<a name="ln6486">  return 1;</a>
<a name="ln6487">}</a>
<a name="ln6488"> </a>
<a name="ln6489">static int nlua_api_nvim_parse_expression(lua_State *lstate)</a>
<a name="ln6490">{</a>
<a name="ln6491">  Error err = ERROR_INIT;</a>
<a name="ln6492">  char *err_param = 0;</a>
<a name="ln6493">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6494">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6495">    goto exit_0;</a>
<a name="ln6496">  }</a>
<a name="ln6497">    const Boolean arg3 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln6498">  if (ERROR_SET(&amp;err)) {      err_param = &quot;highlight&quot;;      goto exit_0;</a>
<a name="ln6499">  }</a>
<a name="ln6500"> </a>
<a name="ln6501">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6502">  if (ERROR_SET(&amp;err)) {      err_param = &quot;flags&quot;;      goto exit_1;</a>
<a name="ln6503">  }</a>
<a name="ln6504"> </a>
<a name="ln6505">    const String arg1 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln6506">  if (ERROR_SET(&amp;err)) {      err_param = &quot;expr&quot;;      goto exit_2;</a>
<a name="ln6507">  }</a>
<a name="ln6508"> </a>
<a name="ln6509">  const Dictionary ret = nvim_parse_expression(arg1, arg2, arg3, &amp;err);</a>
<a name="ln6510">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6511">api_free_dictionary(ret);</a>
<a name="ln6512"> </a>
<a name="ln6513">  api_free_string(arg1);</a>
<a name="ln6514">exit_2:</a>
<a name="ln6515">  api_free_string(arg2);</a>
<a name="ln6516">exit_1:</a>
<a name="ln6517">  api_free_boolean(arg3);</a>
<a name="ln6518"> </a>
<a name="ln6519">exit_0:</a>
<a name="ln6520">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6521">    luaL_where(lstate, 1);</a>
<a name="ln6522">    if (err_param) {</a>
<a name="ln6523">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6524">      lua_pushstring(lstate, err_param);</a>
<a name="ln6525">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6526">    }</a>
<a name="ln6527">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6528">    api_clear_error(&amp;err);</a>
<a name="ln6529">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6530">    return lua_error(lstate);</a>
<a name="ln6531">  }</a>
<a name="ln6532"> </a>
<a name="ln6533">  return 1;</a>
<a name="ln6534">}</a>
<a name="ln6535"> </a>
<a name="ln6536">static int nlua_api_nvim_open_win(lua_State *lstate)</a>
<a name="ln6537">{</a>
<a name="ln6538">  Error err = ERROR_INIT;</a>
<a name="ln6539">  char *err_param = 0;</a>
<a name="ln6540">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln6541">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln6542">    goto exit_0;</a>
<a name="ln6543">  }</a>
<a name="ln6544">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6545">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_open_win&quot;);</a>
<a name="ln6546">  }</a>
<a name="ln6547">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln6548">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln6549">    goto exit_0;</a>
<a name="ln6550">  }</a>
<a name="ln6551">    KeyDict_float_config arg3 = { 0 }; nlua_pop_keydict(lstate, &amp;arg3, KeyDict_float_config_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6552">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6553">  }</a>
<a name="ln6554"> </a>
<a name="ln6555">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln6556">  if (ERROR_SET(&amp;err)) {      err_param = &quot;enter&quot;;      goto exit_1;</a>
<a name="ln6557">  }</a>
<a name="ln6558"> </a>
<a name="ln6559">    const Buffer arg1 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln6560">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_2;</a>
<a name="ln6561">  }</a>
<a name="ln6562"> </a>
<a name="ln6563">  const Window ret = nvim_open_win(arg1, arg2, &amp;arg3, &amp;err);</a>
<a name="ln6564">  nlua_push_Window(lstate, ret, true);</a>
<a name="ln6565">api_free_window(ret);</a>
<a name="ln6566"> </a>
<a name="ln6567">  api_free_buffer(arg1);</a>
<a name="ln6568">exit_2:</a>
<a name="ln6569">  api_free_boolean(arg2);</a>
<a name="ln6570">exit_1:</a>
<a name="ln6571">  api_free_keydict_float_config(&amp;arg3);</a>
<a name="ln6572"> </a>
<a name="ln6573">exit_0:</a>
<a name="ln6574">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6575">    luaL_where(lstate, 1);</a>
<a name="ln6576">    if (err_param) {</a>
<a name="ln6577">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6578">      lua_pushstring(lstate, err_param);</a>
<a name="ln6579">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6580">    }</a>
<a name="ln6581">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6582">    api_clear_error(&amp;err);</a>
<a name="ln6583">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6584">    return lua_error(lstate);</a>
<a name="ln6585">  }</a>
<a name="ln6586"> </a>
<a name="ln6587">  return 1;</a>
<a name="ln6588">}</a>
<a name="ln6589"> </a>
<a name="ln6590">static int nlua_api_nvim_win_set_config(lua_State *lstate)</a>
<a name="ln6591">{</a>
<a name="ln6592">  Error err = ERROR_INIT;</a>
<a name="ln6593">  char *err_param = 0;</a>
<a name="ln6594">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6595">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6596">    goto exit_0;</a>
<a name="ln6597">  }</a>
<a name="ln6598">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6599">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_config&quot;);</a>
<a name="ln6600">  }</a>
<a name="ln6601">    KeyDict_float_config arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_float_config_get_field, &amp;err_param, &amp;err);</a>
<a name="ln6602">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln6603">  }</a>
<a name="ln6604"> </a>
<a name="ln6605">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6606">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6607">  }</a>
<a name="ln6608"> </a>
<a name="ln6609">  nvim_win_set_config(arg1, &amp;arg2, &amp;err);</a>
<a name="ln6610"> </a>
<a name="ln6611">  api_free_window(arg1);</a>
<a name="ln6612">exit_1:</a>
<a name="ln6613">  api_free_keydict_float_config(&amp;arg2);</a>
<a name="ln6614"> </a>
<a name="ln6615">exit_0:</a>
<a name="ln6616">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6617">    luaL_where(lstate, 1);</a>
<a name="ln6618">    if (err_param) {</a>
<a name="ln6619">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6620">      lua_pushstring(lstate, err_param);</a>
<a name="ln6621">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6622">    }</a>
<a name="ln6623">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6624">    api_clear_error(&amp;err);</a>
<a name="ln6625">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6626">    return lua_error(lstate);</a>
<a name="ln6627">  }</a>
<a name="ln6628"> </a>
<a name="ln6629">  return 0;</a>
<a name="ln6630">}</a>
<a name="ln6631"> </a>
<a name="ln6632">static int nlua_api_nvim_win_get_config(lua_State *lstate)</a>
<a name="ln6633">{</a>
<a name="ln6634">  Error err = ERROR_INIT;</a>
<a name="ln6635">  char *err_param = 0;</a>
<a name="ln6636">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6637">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6638">    goto exit_0;</a>
<a name="ln6639">  }</a>
<a name="ln6640">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6641">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_config&quot;);</a>
<a name="ln6642">  }</a>
<a name="ln6643">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6644">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6645">  }</a>
<a name="ln6646"> </a>
<a name="ln6647">  const Dictionary ret = nvim_win_get_config(arg1, &amp;err);</a>
<a name="ln6648">  nlua_push_Dictionary(lstate, ret, true);</a>
<a name="ln6649">api_free_dictionary(ret);</a>
<a name="ln6650"> </a>
<a name="ln6651">  api_free_window(arg1);</a>
<a name="ln6652"> </a>
<a name="ln6653">exit_0:</a>
<a name="ln6654">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6655">    luaL_where(lstate, 1);</a>
<a name="ln6656">    if (err_param) {</a>
<a name="ln6657">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6658">      lua_pushstring(lstate, err_param);</a>
<a name="ln6659">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6660">    }</a>
<a name="ln6661">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6662">    api_clear_error(&amp;err);</a>
<a name="ln6663">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6664">    return lua_error(lstate);</a>
<a name="ln6665">  }</a>
<a name="ln6666"> </a>
<a name="ln6667">  return 1;</a>
<a name="ln6668">}</a>
<a name="ln6669"> </a>
<a name="ln6670">static int nlua_api_nvim_win_get_buf(lua_State *lstate)</a>
<a name="ln6671">{</a>
<a name="ln6672">  Error err = ERROR_INIT;</a>
<a name="ln6673">  char *err_param = 0;</a>
<a name="ln6674">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6675">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6676">    goto exit_0;</a>
<a name="ln6677">  }</a>
<a name="ln6678">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6679">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_buf&quot;);</a>
<a name="ln6680">  }</a>
<a name="ln6681">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6682">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6683">  }</a>
<a name="ln6684"> </a>
<a name="ln6685">  const Buffer ret = nvim_win_get_buf(arg1, &amp;err);</a>
<a name="ln6686">  nlua_push_Buffer(lstate, ret, true);</a>
<a name="ln6687">api_free_buffer(ret);</a>
<a name="ln6688"> </a>
<a name="ln6689">  api_free_window(arg1);</a>
<a name="ln6690"> </a>
<a name="ln6691">exit_0:</a>
<a name="ln6692">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6693">    luaL_where(lstate, 1);</a>
<a name="ln6694">    if (err_param) {</a>
<a name="ln6695">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6696">      lua_pushstring(lstate, err_param);</a>
<a name="ln6697">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6698">    }</a>
<a name="ln6699">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6700">    api_clear_error(&amp;err);</a>
<a name="ln6701">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6702">    return lua_error(lstate);</a>
<a name="ln6703">  }</a>
<a name="ln6704"> </a>
<a name="ln6705">  return 1;</a>
<a name="ln6706">}</a>
<a name="ln6707"> </a>
<a name="ln6708">static int nlua_api_nvim_win_set_buf(lua_State *lstate)</a>
<a name="ln6709">{</a>
<a name="ln6710">  Error err = ERROR_INIT;</a>
<a name="ln6711">  char *err_param = 0;</a>
<a name="ln6712">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6713">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6714">    goto exit_0;</a>
<a name="ln6715">  }</a>
<a name="ln6716">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6717">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_buf&quot;);</a>
<a name="ln6718">  }</a>
<a name="ln6719">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln6720">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln6721">    goto exit_0;</a>
<a name="ln6722">  }</a>
<a name="ln6723">    const Buffer arg2 = nlua_pop_Buffer(lstate, &amp;err);</a>
<a name="ln6724">  if (ERROR_SET(&amp;err)) {      err_param = &quot;buffer&quot;;      goto exit_0;</a>
<a name="ln6725">  }</a>
<a name="ln6726"> </a>
<a name="ln6727">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6728">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6729">  }</a>
<a name="ln6730"> </a>
<a name="ln6731">  nvim_win_set_buf(arg1, arg2, &amp;err);</a>
<a name="ln6732"> </a>
<a name="ln6733">  api_free_window(arg1);</a>
<a name="ln6734">exit_1:</a>
<a name="ln6735">  api_free_buffer(arg2);</a>
<a name="ln6736"> </a>
<a name="ln6737">exit_0:</a>
<a name="ln6738">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6739">    luaL_where(lstate, 1);</a>
<a name="ln6740">    if (err_param) {</a>
<a name="ln6741">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6742">      lua_pushstring(lstate, err_param);</a>
<a name="ln6743">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6744">    }</a>
<a name="ln6745">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6746">    api_clear_error(&amp;err);</a>
<a name="ln6747">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6748">    return lua_error(lstate);</a>
<a name="ln6749">  }</a>
<a name="ln6750"> </a>
<a name="ln6751">  return 0;</a>
<a name="ln6752">}</a>
<a name="ln6753"> </a>
<a name="ln6754">static int nlua_api_nvim_win_get_cursor(lua_State *lstate)</a>
<a name="ln6755">{</a>
<a name="ln6756">  Error err = ERROR_INIT;</a>
<a name="ln6757">  char *err_param = 0;</a>
<a name="ln6758">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6759">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6760">    goto exit_0;</a>
<a name="ln6761">  }</a>
<a name="ln6762">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6763">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_cursor&quot;);</a>
<a name="ln6764">  }</a>
<a name="ln6765">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6766">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6767">  }</a>
<a name="ln6768"> </a>
<a name="ln6769">  const ArrayOf(Integer, 2) ret = nvim_win_get_cursor(arg1, &amp;err);</a>
<a name="ln6770">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln6771">api_free_array(ret);</a>
<a name="ln6772"> </a>
<a name="ln6773">  api_free_window(arg1);</a>
<a name="ln6774"> </a>
<a name="ln6775">exit_0:</a>
<a name="ln6776">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6777">    luaL_where(lstate, 1);</a>
<a name="ln6778">    if (err_param) {</a>
<a name="ln6779">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6780">      lua_pushstring(lstate, err_param);</a>
<a name="ln6781">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6782">    }</a>
<a name="ln6783">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6784">    api_clear_error(&amp;err);</a>
<a name="ln6785">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6786">    return lua_error(lstate);</a>
<a name="ln6787">  }</a>
<a name="ln6788"> </a>
<a name="ln6789">  return 1;</a>
<a name="ln6790">}</a>
<a name="ln6791"> </a>
<a name="ln6792">static int nlua_api_nvim_win_set_cursor(lua_State *lstate)</a>
<a name="ln6793">{</a>
<a name="ln6794">  Error err = ERROR_INIT;</a>
<a name="ln6795">  char *err_param = 0;</a>
<a name="ln6796">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6797">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6798">    goto exit_0;</a>
<a name="ln6799">  }</a>
<a name="ln6800">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6801">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_cursor&quot;);</a>
<a name="ln6802">  }</a>
<a name="ln6803">    const ArrayOf(Integer, 2) arg2 = nlua_pop_Array(lstate, &amp;err);</a>
<a name="ln6804">  if (ERROR_SET(&amp;err)) {      err_param = &quot;pos&quot;;      goto exit_0;</a>
<a name="ln6805">  }</a>
<a name="ln6806"> </a>
<a name="ln6807">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6808">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6809">  }</a>
<a name="ln6810"> </a>
<a name="ln6811">  nvim_win_set_cursor(arg1, arg2, &amp;err);</a>
<a name="ln6812"> </a>
<a name="ln6813">  api_free_window(arg1);</a>
<a name="ln6814">exit_1:</a>
<a name="ln6815">  api_free_array(arg2);</a>
<a name="ln6816"> </a>
<a name="ln6817">exit_0:</a>
<a name="ln6818">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6819">    luaL_where(lstate, 1);</a>
<a name="ln6820">    if (err_param) {</a>
<a name="ln6821">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6822">      lua_pushstring(lstate, err_param);</a>
<a name="ln6823">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6824">    }</a>
<a name="ln6825">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6826">    api_clear_error(&amp;err);</a>
<a name="ln6827">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6828">    return lua_error(lstate);</a>
<a name="ln6829">  }</a>
<a name="ln6830"> </a>
<a name="ln6831">  return 0;</a>
<a name="ln6832">}</a>
<a name="ln6833"> </a>
<a name="ln6834">static int nlua_api_nvim_win_get_height(lua_State *lstate)</a>
<a name="ln6835">{</a>
<a name="ln6836">  Error err = ERROR_INIT;</a>
<a name="ln6837">  char *err_param = 0;</a>
<a name="ln6838">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6839">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6840">    goto exit_0;</a>
<a name="ln6841">  }</a>
<a name="ln6842">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6843">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_height&quot;);</a>
<a name="ln6844">  }</a>
<a name="ln6845">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6846">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6847">  }</a>
<a name="ln6848"> </a>
<a name="ln6849">  const Integer ret = nvim_win_get_height(arg1, &amp;err);</a>
<a name="ln6850">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln6851">api_free_integer(ret);</a>
<a name="ln6852"> </a>
<a name="ln6853">  api_free_window(arg1);</a>
<a name="ln6854"> </a>
<a name="ln6855">exit_0:</a>
<a name="ln6856">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6857">    luaL_where(lstate, 1);</a>
<a name="ln6858">    if (err_param) {</a>
<a name="ln6859">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6860">      lua_pushstring(lstate, err_param);</a>
<a name="ln6861">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6862">    }</a>
<a name="ln6863">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6864">    api_clear_error(&amp;err);</a>
<a name="ln6865">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6866">    return lua_error(lstate);</a>
<a name="ln6867">  }</a>
<a name="ln6868"> </a>
<a name="ln6869">  return 1;</a>
<a name="ln6870">}</a>
<a name="ln6871"> </a>
<a name="ln6872">static int nlua_api_nvim_win_set_height(lua_State *lstate)</a>
<a name="ln6873">{</a>
<a name="ln6874">  Error err = ERROR_INIT;</a>
<a name="ln6875">  char *err_param = 0;</a>
<a name="ln6876">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6877">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6878">    goto exit_0;</a>
<a name="ln6879">  }</a>
<a name="ln6880">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6881">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_height&quot;);</a>
<a name="ln6882">  }</a>
<a name="ln6883">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6884">  if (ERROR_SET(&amp;err)) {      err_param = &quot;height&quot;;      goto exit_0;</a>
<a name="ln6885">  }</a>
<a name="ln6886"> </a>
<a name="ln6887">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6888">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6889">  }</a>
<a name="ln6890"> </a>
<a name="ln6891">  nvim_win_set_height(arg1, arg2, &amp;err);</a>
<a name="ln6892"> </a>
<a name="ln6893">  api_free_window(arg1);</a>
<a name="ln6894">exit_1:</a>
<a name="ln6895">  api_free_integer(arg2);</a>
<a name="ln6896"> </a>
<a name="ln6897">exit_0:</a>
<a name="ln6898">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6899">    luaL_where(lstate, 1);</a>
<a name="ln6900">    if (err_param) {</a>
<a name="ln6901">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6902">      lua_pushstring(lstate, err_param);</a>
<a name="ln6903">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6904">    }</a>
<a name="ln6905">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6906">    api_clear_error(&amp;err);</a>
<a name="ln6907">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6908">    return lua_error(lstate);</a>
<a name="ln6909">  }</a>
<a name="ln6910"> </a>
<a name="ln6911">  return 0;</a>
<a name="ln6912">}</a>
<a name="ln6913"> </a>
<a name="ln6914">static int nlua_api_nvim_win_get_width(lua_State *lstate)</a>
<a name="ln6915">{</a>
<a name="ln6916">  Error err = ERROR_INIT;</a>
<a name="ln6917">  char *err_param = 0;</a>
<a name="ln6918">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln6919">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln6920">    goto exit_0;</a>
<a name="ln6921">  }</a>
<a name="ln6922">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6923">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_width&quot;);</a>
<a name="ln6924">  }</a>
<a name="ln6925">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6926">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln6927">  }</a>
<a name="ln6928"> </a>
<a name="ln6929">  const Integer ret = nvim_win_get_width(arg1, &amp;err);</a>
<a name="ln6930">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln6931">api_free_integer(ret);</a>
<a name="ln6932"> </a>
<a name="ln6933">  api_free_window(arg1);</a>
<a name="ln6934"> </a>
<a name="ln6935">exit_0:</a>
<a name="ln6936">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6937">    luaL_where(lstate, 1);</a>
<a name="ln6938">    if (err_param) {</a>
<a name="ln6939">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6940">      lua_pushstring(lstate, err_param);</a>
<a name="ln6941">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6942">    }</a>
<a name="ln6943">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6944">    api_clear_error(&amp;err);</a>
<a name="ln6945">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6946">    return lua_error(lstate);</a>
<a name="ln6947">  }</a>
<a name="ln6948"> </a>
<a name="ln6949">  return 1;</a>
<a name="ln6950">}</a>
<a name="ln6951"> </a>
<a name="ln6952">static int nlua_api_nvim_win_set_width(lua_State *lstate)</a>
<a name="ln6953">{</a>
<a name="ln6954">  Error err = ERROR_INIT;</a>
<a name="ln6955">  char *err_param = 0;</a>
<a name="ln6956">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6957">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln6958">    goto exit_0;</a>
<a name="ln6959">  }</a>
<a name="ln6960">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln6961">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_width&quot;);</a>
<a name="ln6962">  }</a>
<a name="ln6963">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln6964">  if (ERROR_SET(&amp;err)) {      err_param = &quot;width&quot;;      goto exit_0;</a>
<a name="ln6965">  }</a>
<a name="ln6966"> </a>
<a name="ln6967">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln6968">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln6969">  }</a>
<a name="ln6970"> </a>
<a name="ln6971">  nvim_win_set_width(arg1, arg2, &amp;err);</a>
<a name="ln6972"> </a>
<a name="ln6973">  api_free_window(arg1);</a>
<a name="ln6974">exit_1:</a>
<a name="ln6975">  api_free_integer(arg2);</a>
<a name="ln6976"> </a>
<a name="ln6977">exit_0:</a>
<a name="ln6978">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln6979">    luaL_where(lstate, 1);</a>
<a name="ln6980">    if (err_param) {</a>
<a name="ln6981">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln6982">      lua_pushstring(lstate, err_param);</a>
<a name="ln6983">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln6984">    }</a>
<a name="ln6985">    lua_pushstring(lstate, err.msg);</a>
<a name="ln6986">    api_clear_error(&amp;err);</a>
<a name="ln6987">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln6988">    return lua_error(lstate);</a>
<a name="ln6989">  }</a>
<a name="ln6990"> </a>
<a name="ln6991">  return 0;</a>
<a name="ln6992">}</a>
<a name="ln6993"> </a>
<a name="ln6994">static int nlua_api_nvim_win_get_var(lua_State *lstate)</a>
<a name="ln6995">{</a>
<a name="ln6996">  Error err = ERROR_INIT;</a>
<a name="ln6997">  char *err_param = 0;</a>
<a name="ln6998">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln6999">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7000">    goto exit_0;</a>
<a name="ln7001">  }</a>
<a name="ln7002">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7003">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_var&quot;);</a>
<a name="ln7004">  }</a>
<a name="ln7005">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln7006">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln7007">  }</a>
<a name="ln7008"> </a>
<a name="ln7009">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7010">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7011">  }</a>
<a name="ln7012"> </a>
<a name="ln7013">  const Object ret = nvim_win_get_var(arg1, arg2, &amp;err);</a>
<a name="ln7014">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln7015">api_free_object(ret);</a>
<a name="ln7016"> </a>
<a name="ln7017">  api_free_window(arg1);</a>
<a name="ln7018">exit_1:</a>
<a name="ln7019">  api_free_string(arg2);</a>
<a name="ln7020"> </a>
<a name="ln7021">exit_0:</a>
<a name="ln7022">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7023">    luaL_where(lstate, 1);</a>
<a name="ln7024">    if (err_param) {</a>
<a name="ln7025">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7026">      lua_pushstring(lstate, err_param);</a>
<a name="ln7027">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7028">    }</a>
<a name="ln7029">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7030">    api_clear_error(&amp;err);</a>
<a name="ln7031">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7032">    return lua_error(lstate);</a>
<a name="ln7033">  }</a>
<a name="ln7034"> </a>
<a name="ln7035">  return 1;</a>
<a name="ln7036">}</a>
<a name="ln7037"> </a>
<a name="ln7038">static int nlua_api_nvim_win_set_var(lua_State *lstate)</a>
<a name="ln7039">{</a>
<a name="ln7040">  Error err = ERROR_INIT;</a>
<a name="ln7041">  char *err_param = 0;</a>
<a name="ln7042">  if (lua_gettop(lstate) != 3) {</a>
<a name="ln7043">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 3 arguments&quot;);</a>
<a name="ln7044">    goto exit_0;</a>
<a name="ln7045">  }</a>
<a name="ln7046">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7047">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_var&quot;);</a>
<a name="ln7048">  }</a>
<a name="ln7049">    const Object arg3 = nlua_pop_Object(lstate, true, &amp;err);</a>
<a name="ln7050">  if (ERROR_SET(&amp;err)) {      err_param = &quot;value&quot;;      goto exit_0;</a>
<a name="ln7051">  }</a>
<a name="ln7052"> </a>
<a name="ln7053">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln7054">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_1;</a>
<a name="ln7055">  }</a>
<a name="ln7056"> </a>
<a name="ln7057">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7058">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_2;</a>
<a name="ln7059">  }</a>
<a name="ln7060"> </a>
<a name="ln7061">  nvim_win_set_var(arg1, arg2, arg3, &amp;err);</a>
<a name="ln7062"> </a>
<a name="ln7063">  api_free_window(arg1);</a>
<a name="ln7064">exit_2:</a>
<a name="ln7065">  api_free_string(arg2);</a>
<a name="ln7066">exit_1:</a>
<a name="ln7067">  api_free_object(arg3);</a>
<a name="ln7068"> </a>
<a name="ln7069">exit_0:</a>
<a name="ln7070">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7071">    luaL_where(lstate, 1);</a>
<a name="ln7072">    if (err_param) {</a>
<a name="ln7073">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7074">      lua_pushstring(lstate, err_param);</a>
<a name="ln7075">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7076">    }</a>
<a name="ln7077">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7078">    api_clear_error(&amp;err);</a>
<a name="ln7079">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7080">    return lua_error(lstate);</a>
<a name="ln7081">  }</a>
<a name="ln7082"> </a>
<a name="ln7083">  return 0;</a>
<a name="ln7084">}</a>
<a name="ln7085"> </a>
<a name="ln7086">static int nlua_api_nvim_win_del_var(lua_State *lstate)</a>
<a name="ln7087">{</a>
<a name="ln7088">  Error err = ERROR_INIT;</a>
<a name="ln7089">  char *err_param = 0;</a>
<a name="ln7090">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7091">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7092">    goto exit_0;</a>
<a name="ln7093">  }</a>
<a name="ln7094">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7095">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_del_var&quot;);</a>
<a name="ln7096">  }</a>
<a name="ln7097">    const String arg2 = nlua_pop_String(lstate, &amp;err);</a>
<a name="ln7098">  if (ERROR_SET(&amp;err)) {      err_param = &quot;name&quot;;      goto exit_0;</a>
<a name="ln7099">  }</a>
<a name="ln7100"> </a>
<a name="ln7101">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7102">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7103">  }</a>
<a name="ln7104"> </a>
<a name="ln7105">  nvim_win_del_var(arg1, arg2, &amp;err);</a>
<a name="ln7106"> </a>
<a name="ln7107">  api_free_window(arg1);</a>
<a name="ln7108">exit_1:</a>
<a name="ln7109">  api_free_string(arg2);</a>
<a name="ln7110"> </a>
<a name="ln7111">exit_0:</a>
<a name="ln7112">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7113">    luaL_where(lstate, 1);</a>
<a name="ln7114">    if (err_param) {</a>
<a name="ln7115">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7116">      lua_pushstring(lstate, err_param);</a>
<a name="ln7117">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7118">    }</a>
<a name="ln7119">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7120">    api_clear_error(&amp;err);</a>
<a name="ln7121">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7122">    return lua_error(lstate);</a>
<a name="ln7123">  }</a>
<a name="ln7124"> </a>
<a name="ln7125">  return 0;</a>
<a name="ln7126">}</a>
<a name="ln7127"> </a>
<a name="ln7128">static int nlua_api_nvim_win_get_position(lua_State *lstate)</a>
<a name="ln7129">{</a>
<a name="ln7130">  Error err = ERROR_INIT;</a>
<a name="ln7131">  char *err_param = 0;</a>
<a name="ln7132">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7133">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7134">    goto exit_0;</a>
<a name="ln7135">  }</a>
<a name="ln7136">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7137">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_position&quot;);</a>
<a name="ln7138">  }</a>
<a name="ln7139">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7140">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7141">  }</a>
<a name="ln7142"> </a>
<a name="ln7143">  const ArrayOf(Integer, 2) ret = nvim_win_get_position(arg1, &amp;err);</a>
<a name="ln7144">  nlua_push_Array(lstate, ret, true);</a>
<a name="ln7145">api_free_array(ret);</a>
<a name="ln7146"> </a>
<a name="ln7147">  api_free_window(arg1);</a>
<a name="ln7148"> </a>
<a name="ln7149">exit_0:</a>
<a name="ln7150">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7151">    luaL_where(lstate, 1);</a>
<a name="ln7152">    if (err_param) {</a>
<a name="ln7153">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7154">      lua_pushstring(lstate, err_param);</a>
<a name="ln7155">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7156">    }</a>
<a name="ln7157">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7158">    api_clear_error(&amp;err);</a>
<a name="ln7159">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7160">    return lua_error(lstate);</a>
<a name="ln7161">  }</a>
<a name="ln7162"> </a>
<a name="ln7163">  return 1;</a>
<a name="ln7164">}</a>
<a name="ln7165"> </a>
<a name="ln7166">static int nlua_api_nvim_win_get_tabpage(lua_State *lstate)</a>
<a name="ln7167">{</a>
<a name="ln7168">  Error err = ERROR_INIT;</a>
<a name="ln7169">  char *err_param = 0;</a>
<a name="ln7170">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7171">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7172">    goto exit_0;</a>
<a name="ln7173">  }</a>
<a name="ln7174">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7175">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_tabpage&quot;);</a>
<a name="ln7176">  }</a>
<a name="ln7177">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7178">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7179">  }</a>
<a name="ln7180"> </a>
<a name="ln7181">  const Tabpage ret = nvim_win_get_tabpage(arg1, &amp;err);</a>
<a name="ln7182">  nlua_push_Tabpage(lstate, ret, true);</a>
<a name="ln7183">api_free_tabpage(ret);</a>
<a name="ln7184"> </a>
<a name="ln7185">  api_free_window(arg1);</a>
<a name="ln7186"> </a>
<a name="ln7187">exit_0:</a>
<a name="ln7188">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7189">    luaL_where(lstate, 1);</a>
<a name="ln7190">    if (err_param) {</a>
<a name="ln7191">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7192">      lua_pushstring(lstate, err_param);</a>
<a name="ln7193">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7194">    }</a>
<a name="ln7195">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7196">    api_clear_error(&amp;err);</a>
<a name="ln7197">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7198">    return lua_error(lstate);</a>
<a name="ln7199">  }</a>
<a name="ln7200"> </a>
<a name="ln7201">  return 1;</a>
<a name="ln7202">}</a>
<a name="ln7203"> </a>
<a name="ln7204">static int nlua_api_nvim_win_get_number(lua_State *lstate)</a>
<a name="ln7205">{</a>
<a name="ln7206">  Error err = ERROR_INIT;</a>
<a name="ln7207">  char *err_param = 0;</a>
<a name="ln7208">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7209">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7210">    goto exit_0;</a>
<a name="ln7211">  }</a>
<a name="ln7212">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7213">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_get_number&quot;);</a>
<a name="ln7214">  }</a>
<a name="ln7215">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7216">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7217">  }</a>
<a name="ln7218"> </a>
<a name="ln7219">  const Integer ret = nvim_win_get_number(arg1, &amp;err);</a>
<a name="ln7220">  nlua_push_Integer(lstate, ret, true);</a>
<a name="ln7221">api_free_integer(ret);</a>
<a name="ln7222"> </a>
<a name="ln7223">  api_free_window(arg1);</a>
<a name="ln7224"> </a>
<a name="ln7225">exit_0:</a>
<a name="ln7226">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7227">    luaL_where(lstate, 1);</a>
<a name="ln7228">    if (err_param) {</a>
<a name="ln7229">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7230">      lua_pushstring(lstate, err_param);</a>
<a name="ln7231">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7232">    }</a>
<a name="ln7233">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7234">    api_clear_error(&amp;err);</a>
<a name="ln7235">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7236">    return lua_error(lstate);</a>
<a name="ln7237">  }</a>
<a name="ln7238"> </a>
<a name="ln7239">  return 1;</a>
<a name="ln7240">}</a>
<a name="ln7241"> </a>
<a name="ln7242">static int nlua_api_nvim_win_is_valid(lua_State *lstate)</a>
<a name="ln7243">{</a>
<a name="ln7244">  Error err = ERROR_INIT;</a>
<a name="ln7245">  char *err_param = 0;</a>
<a name="ln7246">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7247">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7248">    goto exit_0;</a>
<a name="ln7249">  }</a>
<a name="ln7250">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7251">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_is_valid&quot;);</a>
<a name="ln7252">  }</a>
<a name="ln7253">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7254">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7255">  }</a>
<a name="ln7256"> </a>
<a name="ln7257">  const Boolean ret = nvim_win_is_valid(arg1);</a>
<a name="ln7258">  nlua_push_Boolean(lstate, ret, true);</a>
<a name="ln7259">api_free_boolean(ret);</a>
<a name="ln7260"> </a>
<a name="ln7261">  api_free_window(arg1);</a>
<a name="ln7262"> </a>
<a name="ln7263">exit_0:</a>
<a name="ln7264">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7265">    luaL_where(lstate, 1);</a>
<a name="ln7266">    if (err_param) {</a>
<a name="ln7267">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7268">      lua_pushstring(lstate, err_param);</a>
<a name="ln7269">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7270">    }</a>
<a name="ln7271">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7272">    api_clear_error(&amp;err);</a>
<a name="ln7273">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7274">    return lua_error(lstate);</a>
<a name="ln7275">  }</a>
<a name="ln7276"> </a>
<a name="ln7277">  return 1;</a>
<a name="ln7278">}</a>
<a name="ln7279"> </a>
<a name="ln7280">static int nlua_api_nvim_win_hide(lua_State *lstate)</a>
<a name="ln7281">{</a>
<a name="ln7282">  Error err = ERROR_INIT;</a>
<a name="ln7283">  char *err_param = 0;</a>
<a name="ln7284">  if (lua_gettop(lstate) != 1) {</a>
<a name="ln7285">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 1 argument&quot;);</a>
<a name="ln7286">    goto exit_0;</a>
<a name="ln7287">  }</a>
<a name="ln7288">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7289">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_hide&quot;);</a>
<a name="ln7290">  }</a>
<a name="ln7291">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln7292">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln7293">    goto exit_0;</a>
<a name="ln7294">  }</a>
<a name="ln7295">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7296">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_0;</a>
<a name="ln7297">  }</a>
<a name="ln7298"> </a>
<a name="ln7299">  nvim_win_hide(arg1, &amp;err);</a>
<a name="ln7300"> </a>
<a name="ln7301">  api_free_window(arg1);</a>
<a name="ln7302"> </a>
<a name="ln7303">exit_0:</a>
<a name="ln7304">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7305">    luaL_where(lstate, 1);</a>
<a name="ln7306">    if (err_param) {</a>
<a name="ln7307">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7308">      lua_pushstring(lstate, err_param);</a>
<a name="ln7309">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7310">    }</a>
<a name="ln7311">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7312">    api_clear_error(&amp;err);</a>
<a name="ln7313">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7314">    return lua_error(lstate);</a>
<a name="ln7315">  }</a>
<a name="ln7316"> </a>
<a name="ln7317">  return 0;</a>
<a name="ln7318">}</a>
<a name="ln7319"> </a>
<a name="ln7320">static int nlua_api_nvim_win_close(lua_State *lstate)</a>
<a name="ln7321">{</a>
<a name="ln7322">  Error err = ERROR_INIT;</a>
<a name="ln7323">  char *err_param = 0;</a>
<a name="ln7324">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7325">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7326">    goto exit_0;</a>
<a name="ln7327">  }</a>
<a name="ln7328">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7329">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_close&quot;);</a>
<a name="ln7330">  }</a>
<a name="ln7331">  if (textlock != 0 || expr_map_locked()) {</a>
<a name="ln7332">    api_set_error(&amp;err, kErrorTypeException, &quot;%s&quot;, e_textlock);</a>
<a name="ln7333">    goto exit_0;</a>
<a name="ln7334">  }</a>
<a name="ln7335">    const Boolean arg2 = nlua_pop_Boolean(lstate, &amp;err);</a>
<a name="ln7336">  if (ERROR_SET(&amp;err)) {      err_param = &quot;force&quot;;      goto exit_0;</a>
<a name="ln7337">  }</a>
<a name="ln7338"> </a>
<a name="ln7339">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7340">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7341">  }</a>
<a name="ln7342"> </a>
<a name="ln7343">  nvim_win_close(arg1, arg2, &amp;err);</a>
<a name="ln7344"> </a>
<a name="ln7345">  api_free_window(arg1);</a>
<a name="ln7346">exit_1:</a>
<a name="ln7347">  api_free_boolean(arg2);</a>
<a name="ln7348"> </a>
<a name="ln7349">exit_0:</a>
<a name="ln7350">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7351">    luaL_where(lstate, 1);</a>
<a name="ln7352">    if (err_param) {</a>
<a name="ln7353">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7354">      lua_pushstring(lstate, err_param);</a>
<a name="ln7355">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7356">    }</a>
<a name="ln7357">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7358">    api_clear_error(&amp;err);</a>
<a name="ln7359">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7360">    return lua_error(lstate);</a>
<a name="ln7361">  }</a>
<a name="ln7362"> </a>
<a name="ln7363">  return 0;</a>
<a name="ln7364">}</a>
<a name="ln7365"> </a>
<a name="ln7366">static int nlua_api_nvim_win_call(lua_State *lstate)</a>
<a name="ln7367">{</a>
<a name="ln7368">  Error err = ERROR_INIT;</a>
<a name="ln7369">  char *err_param = 0;</a>
<a name="ln7370">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7371">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7372">    goto exit_0;</a>
<a name="ln7373">  }</a>
<a name="ln7374">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7375">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_call&quot;);</a>
<a name="ln7376">  }</a>
<a name="ln7377">    const LuaRef arg2 = nlua_pop_LuaRef(lstate, &amp;err);</a>
<a name="ln7378">  if (ERROR_SET(&amp;err)) {      err_param = &quot;fun&quot;;      goto exit_0;</a>
<a name="ln7379">  }</a>
<a name="ln7380"> </a>
<a name="ln7381">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7382">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7383">  }</a>
<a name="ln7384"> </a>
<a name="ln7385">  const Object ret = nvim_win_call(arg1, arg2, &amp;err);</a>
<a name="ln7386">  nlua_push_Object(lstate, ret, true);</a>
<a name="ln7387">api_free_object(ret);</a>
<a name="ln7388"> </a>
<a name="ln7389">  api_free_window(arg1);</a>
<a name="ln7390">exit_1:</a>
<a name="ln7391">  api_free_luaref(arg2);</a>
<a name="ln7392"> </a>
<a name="ln7393">exit_0:</a>
<a name="ln7394">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7395">    luaL_where(lstate, 1);</a>
<a name="ln7396">    if (err_param) {</a>
<a name="ln7397">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7398">      lua_pushstring(lstate, err_param);</a>
<a name="ln7399">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7400">    }</a>
<a name="ln7401">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7402">    api_clear_error(&amp;err);</a>
<a name="ln7403">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7404">    return lua_error(lstate);</a>
<a name="ln7405">  }</a>
<a name="ln7406"> </a>
<a name="ln7407">  return 1;</a>
<a name="ln7408">}</a>
<a name="ln7409"> </a>
<a name="ln7410">static int nlua_api_nvim_win_set_hl_ns(lua_State *lstate)</a>
<a name="ln7411">{</a>
<a name="ln7412">  Error err = ERROR_INIT;</a>
<a name="ln7413">  char *err_param = 0;</a>
<a name="ln7414">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7415">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7416">    goto exit_0;</a>
<a name="ln7417">  }</a>
<a name="ln7418">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7419">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_set_hl_ns&quot;);</a>
<a name="ln7420">  }</a>
<a name="ln7421">    const Integer arg2 = nlua_pop_Integer(lstate, &amp;err);</a>
<a name="ln7422">  if (ERROR_SET(&amp;err)) {      err_param = &quot;ns_id&quot;;      goto exit_0;</a>
<a name="ln7423">  }</a>
<a name="ln7424"> </a>
<a name="ln7425">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7426">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7427">  }</a>
<a name="ln7428"> </a>
<a name="ln7429">  nvim_win_set_hl_ns(arg1, arg2, &amp;err);</a>
<a name="ln7430"> </a>
<a name="ln7431">  api_free_window(arg1);</a>
<a name="ln7432">exit_1:</a>
<a name="ln7433">  api_free_integer(arg2);</a>
<a name="ln7434"> </a>
<a name="ln7435">exit_0:</a>
<a name="ln7436">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7437">    luaL_where(lstate, 1);</a>
<a name="ln7438">    if (err_param) {</a>
<a name="ln7439">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7440">      lua_pushstring(lstate, err_param);</a>
<a name="ln7441">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7442">    }</a>
<a name="ln7443">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7444">    api_clear_error(&amp;err);</a>
<a name="ln7445">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7446">    return lua_error(lstate);</a>
<a name="ln7447">  }</a>
<a name="ln7448"> </a>
<a name="ln7449">  return 0;</a>
<a name="ln7450">}</a>
<a name="ln7451"> </a>
<a name="ln7452">static int nlua_api_nvim_win_text_height(lua_State *lstate)</a>
<a name="ln7453">{</a>
<a name="ln7454">  Error err = ERROR_INIT;</a>
<a name="ln7455">  char *err_param = 0;</a>
<a name="ln7456">  if (lua_gettop(lstate) != 2) {</a>
<a name="ln7457">    api_set_error(&amp;err, kErrorTypeValidation, &quot;Expected 2 arguments&quot;);</a>
<a name="ln7458">    goto exit_0;</a>
<a name="ln7459">  }</a>
<a name="ln7460">  if (!nlua_is_deferred_safe()) {</a>
<a name="ln7461">    return luaL_error(lstate, e_luv_api_disabled, &quot;nvim_win_text_height&quot;);</a>
<a name="ln7462">  }</a>
<a name="ln7463">    KeyDict_win_text_height arg2 = { 0 }; nlua_pop_keydict(lstate, &amp;arg2, KeyDict_win_text_height_get_field, &amp;err_param, &amp;err);</a>
<a name="ln7464">  if (ERROR_SET(&amp;err)) {      goto exit_1;</a>
<a name="ln7465">  }</a>
<a name="ln7466"> </a>
<a name="ln7467">    const Window arg1 = nlua_pop_Window(lstate, &amp;err);</a>
<a name="ln7468">  if (ERROR_SET(&amp;err)) {      err_param = &quot;window&quot;;      goto exit_1;</a>
<a name="ln7469">  }</a>
<a name="ln7470"> </a>
<a name="ln7471">  Arena arena = ARENA_EMPTY;</a>
<a name="ln7472">  const Dictionary ret = nvim_win_text_height(arg1, &amp;arg2, &amp;arena, &amp;err);</a>
<a name="ln7473">  nlua_push_Dictionary(lstate, ret, false);</a>
<a name="ln7474">arena_mem_free(arena_finish(&amp;arena));</a>
<a name="ln7475"> </a>
<a name="ln7476">  api_free_window(arg1);</a>
<a name="ln7477">exit_1:</a>
<a name="ln7478">  api_free_keydict_win_text_height(&amp;arg2);</a>
<a name="ln7479"> </a>
<a name="ln7480">exit_0:</a>
<a name="ln7481">  if (ERROR_SET(&amp;err)) {</a>
<a name="ln7482">    luaL_where(lstate, 1);</a>
<a name="ln7483">    if (err_param) {</a>
<a name="ln7484">      lua_pushstring(lstate, &quot;Invalid '&quot;);</a>
<a name="ln7485">      lua_pushstring(lstate, err_param);</a>
<a name="ln7486">      lua_pushstring(lstate, &quot;': &quot;);</a>
<a name="ln7487">    }</a>
<a name="ln7488">    lua_pushstring(lstate, err.msg);</a>
<a name="ln7489">    api_clear_error(&amp;err);</a>
<a name="ln7490">    lua_concat(lstate, err_param ? 5 : 2);</a>
<a name="ln7491">    return lua_error(lstate);</a>
<a name="ln7492">  }</a>
<a name="ln7493"> </a>
<a name="ln7494">  return 1;</a>
<a name="ln7495">}</a>
<a name="ln7496">void nlua_add_api_functions(lua_State *lstate);  // silence -Wmissing-prototypes</a>
<a name="ln7497">void nlua_add_api_functions(lua_State *lstate)</a>
<a name="ln7498">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln7499">{</a>
<a name="ln7500">  lua_createtable(lstate, 0, 175);</a>
<a name="ln7501"> </a>
<a name="ln7502">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_autocmds);</a>
<a name="ln7503">  lua_setfield(lstate, -2, &quot;nvim_get_autocmds&quot;);</a>
<a name="ln7504">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_autocmd);</a>
<a name="ln7505">  lua_setfield(lstate, -2, &quot;nvim_create_autocmd&quot;);</a>
<a name="ln7506">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_autocmd);</a>
<a name="ln7507">  lua_setfield(lstate, -2, &quot;nvim_del_autocmd&quot;);</a>
<a name="ln7508">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_clear_autocmds);</a>
<a name="ln7509">  lua_setfield(lstate, -2, &quot;nvim_clear_autocmds&quot;);</a>
<a name="ln7510">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_augroup);</a>
<a name="ln7511">  lua_setfield(lstate, -2, &quot;nvim_create_augroup&quot;);</a>
<a name="ln7512">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_augroup_by_id);</a>
<a name="ln7513">  lua_setfield(lstate, -2, &quot;nvim_del_augroup_by_id&quot;);</a>
<a name="ln7514">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_augroup_by_name);</a>
<a name="ln7515">  lua_setfield(lstate, -2, &quot;nvim_del_augroup_by_name&quot;);</a>
<a name="ln7516">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec_autocmds);</a>
<a name="ln7517">  lua_setfield(lstate, -2, &quot;nvim_exec_autocmds&quot;);</a>
<a name="ln7518">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_line_count);</a>
<a name="ln7519">  lua_setfield(lstate, -2, &quot;nvim_buf_line_count&quot;);</a>
<a name="ln7520">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_attach);</a>
<a name="ln7521">  lua_setfield(lstate, -2, &quot;nvim_buf_attach&quot;);</a>
<a name="ln7522">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_redraw_range);</a>
<a name="ln7523">  lua_setfield(lstate, -2, &quot;nvim__buf_redraw_range&quot;);</a>
<a name="ln7524">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_lines);</a>
<a name="ln7525">  lua_setfield(lstate, -2, &quot;nvim_buf_get_lines&quot;);</a>
<a name="ln7526">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_lines);</a>
<a name="ln7527">  lua_setfield(lstate, -2, &quot;nvim_buf_set_lines&quot;);</a>
<a name="ln7528">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_text);</a>
<a name="ln7529">  lua_setfield(lstate, -2, &quot;nvim_buf_set_text&quot;);</a>
<a name="ln7530">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_text);</a>
<a name="ln7531">  lua_setfield(lstate, -2, &quot;nvim_buf_get_text&quot;);</a>
<a name="ln7532">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_offset);</a>
<a name="ln7533">  lua_setfield(lstate, -2, &quot;nvim_buf_get_offset&quot;);</a>
<a name="ln7534">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_var);</a>
<a name="ln7535">  lua_setfield(lstate, -2, &quot;nvim_buf_get_var&quot;);</a>
<a name="ln7536">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_changedtick);</a>
<a name="ln7537">  lua_setfield(lstate, -2, &quot;nvim_buf_get_changedtick&quot;);</a>
<a name="ln7538">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_keymap);</a>
<a name="ln7539">  lua_setfield(lstate, -2, &quot;nvim_buf_get_keymap&quot;);</a>
<a name="ln7540">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_keymap);</a>
<a name="ln7541">  lua_setfield(lstate, -2, &quot;nvim_buf_set_keymap&quot;);</a>
<a name="ln7542">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_keymap);</a>
<a name="ln7543">  lua_setfield(lstate, -2, &quot;nvim_buf_del_keymap&quot;);</a>
<a name="ln7544">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_var);</a>
<a name="ln7545">  lua_setfield(lstate, -2, &quot;nvim_buf_set_var&quot;);</a>
<a name="ln7546">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_var);</a>
<a name="ln7547">  lua_setfield(lstate, -2, &quot;nvim_buf_del_var&quot;);</a>
<a name="ln7548">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_name);</a>
<a name="ln7549">  lua_setfield(lstate, -2, &quot;nvim_buf_get_name&quot;);</a>
<a name="ln7550">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_name);</a>
<a name="ln7551">  lua_setfield(lstate, -2, &quot;nvim_buf_set_name&quot;);</a>
<a name="ln7552">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_is_loaded);</a>
<a name="ln7553">  lua_setfield(lstate, -2, &quot;nvim_buf_is_loaded&quot;);</a>
<a name="ln7554">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_delete);</a>
<a name="ln7555">  lua_setfield(lstate, -2, &quot;nvim_buf_delete&quot;);</a>
<a name="ln7556">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_is_valid);</a>
<a name="ln7557">  lua_setfield(lstate, -2, &quot;nvim_buf_is_valid&quot;);</a>
<a name="ln7558">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_mark);</a>
<a name="ln7559">  lua_setfield(lstate, -2, &quot;nvim_buf_del_mark&quot;);</a>
<a name="ln7560">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_mark);</a>
<a name="ln7561">  lua_setfield(lstate, -2, &quot;nvim_buf_set_mark&quot;);</a>
<a name="ln7562">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_mark);</a>
<a name="ln7563">  lua_setfield(lstate, -2, &quot;nvim_buf_get_mark&quot;);</a>
<a name="ln7564">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_call);</a>
<a name="ln7565">  lua_setfield(lstate, -2, &quot;nvim_buf_call&quot;);</a>
<a name="ln7566">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_stats);</a>
<a name="ln7567">  lua_setfield(lstate, -2, &quot;nvim__buf_stats&quot;);</a>
<a name="ln7568">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_parse_cmd);</a>
<a name="ln7569">  lua_setfield(lstate, -2, &quot;nvim_parse_cmd&quot;);</a>
<a name="ln7570">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_cmd);</a>
<a name="ln7571">  lua_setfield(lstate, -2, &quot;nvim_cmd&quot;);</a>
<a name="ln7572">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_user_command);</a>
<a name="ln7573">  lua_setfield(lstate, -2, &quot;nvim_create_user_command&quot;);</a>
<a name="ln7574">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_user_command);</a>
<a name="ln7575">  lua_setfield(lstate, -2, &quot;nvim_del_user_command&quot;);</a>
<a name="ln7576">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_create_user_command);</a>
<a name="ln7577">  lua_setfield(lstate, -2, &quot;nvim_buf_create_user_command&quot;);</a>
<a name="ln7578">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_user_command);</a>
<a name="ln7579">  lua_setfield(lstate, -2, &quot;nvim_buf_del_user_command&quot;);</a>
<a name="ln7580">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_commands);</a>
<a name="ln7581">  lua_setfield(lstate, -2, &quot;nvim_get_commands&quot;);</a>
<a name="ln7582">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_commands);</a>
<a name="ln7583">  lua_setfield(lstate, -2, &quot;nvim_buf_get_commands&quot;);</a>
<a name="ln7584">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec);</a>
<a name="ln7585">  lua_setfield(lstate, -2, &quot;nvim_exec&quot;);</a>
<a name="ln7586">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_command_output);</a>
<a name="ln7587">  lua_setfield(lstate, -2, &quot;nvim_command_output&quot;);</a>
<a name="ln7588">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_number);</a>
<a name="ln7589">  lua_setfield(lstate, -2, &quot;nvim_buf_get_number&quot;);</a>
<a name="ln7590">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_clear_highlight);</a>
<a name="ln7591">  lua_setfield(lstate, -2, &quot;nvim_buf_clear_highlight&quot;);</a>
<a name="ln7592">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_virtual_text);</a>
<a name="ln7593">  lua_setfield(lstate, -2, &quot;nvim_buf_set_virtual_text&quot;);</a>
<a name="ln7594">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_by_id);</a>
<a name="ln7595">  lua_setfield(lstate, -2, &quot;nvim_get_hl_by_id&quot;);</a>
<a name="ln7596">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_by_name);</a>
<a name="ln7597">  lua_setfield(lstate, -2, &quot;nvim_get_hl_by_name&quot;);</a>
<a name="ln7598">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_info);</a>
<a name="ln7599">  lua_setfield(lstate, -2, &quot;nvim_get_option_info&quot;);</a>
<a name="ln7600">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_option);</a>
<a name="ln7601">  lua_setfield(lstate, -2, &quot;nvim_set_option&quot;);</a>
<a name="ln7602">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option);</a>
<a name="ln7603">  lua_setfield(lstate, -2, &quot;nvim_get_option&quot;);</a>
<a name="ln7604">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_option);</a>
<a name="ln7605">  lua_setfield(lstate, -2, &quot;nvim_buf_get_option&quot;);</a>
<a name="ln7606">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_option);</a>
<a name="ln7607">  lua_setfield(lstate, -2, &quot;nvim_buf_set_option&quot;);</a>
<a name="ln7608">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_option);</a>
<a name="ln7609">  lua_setfield(lstate, -2, &quot;nvim_win_get_option&quot;);</a>
<a name="ln7610">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_option);</a>
<a name="ln7611">  lua_setfield(lstate, -2, &quot;nvim_win_set_option&quot;);</a>
<a name="ln7612">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_namespace);</a>
<a name="ln7613">  lua_setfield(lstate, -2, &quot;nvim_create_namespace&quot;);</a>
<a name="ln7614">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_namespaces);</a>
<a name="ln7615">  lua_setfield(lstate, -2, &quot;nvim_get_namespaces&quot;);</a>
<a name="ln7616">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_extmark_by_id);</a>
<a name="ln7617">  lua_setfield(lstate, -2, &quot;nvim_buf_get_extmark_by_id&quot;);</a>
<a name="ln7618">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_get_extmarks);</a>
<a name="ln7619">  lua_setfield(lstate, -2, &quot;nvim_buf_get_extmarks&quot;);</a>
<a name="ln7620">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_set_extmark);</a>
<a name="ln7621">  lua_setfield(lstate, -2, &quot;nvim_buf_set_extmark&quot;);</a>
<a name="ln7622">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_del_extmark);</a>
<a name="ln7623">  lua_setfield(lstate, -2, &quot;nvim_buf_del_extmark&quot;);</a>
<a name="ln7624">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_add_highlight);</a>
<a name="ln7625">  lua_setfield(lstate, -2, &quot;nvim_buf_add_highlight&quot;);</a>
<a name="ln7626">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_buf_clear_namespace);</a>
<a name="ln7627">  lua_setfield(lstate, -2, &quot;nvim_buf_clear_namespace&quot;);</a>
<a name="ln7628">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_decoration_provider);</a>
<a name="ln7629">  lua_setfield(lstate, -2, &quot;nvim_set_decoration_provider&quot;);</a>
<a name="ln7630">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__buf_debug_extmarks);</a>
<a name="ln7631">  lua_setfield(lstate, -2, &quot;nvim__buf_debug_extmarks&quot;);</a>
<a name="ln7632">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_value);</a>
<a name="ln7633">  lua_setfield(lstate, -2, &quot;nvim_get_option_value&quot;);</a>
<a name="ln7634">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_option_value);</a>
<a name="ln7635">  lua_setfield(lstate, -2, &quot;nvim_set_option_value&quot;);</a>
<a name="ln7636">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_all_options_info);</a>
<a name="ln7637">  lua_setfield(lstate, -2, &quot;nvim_get_all_options_info&quot;);</a>
<a name="ln7638">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_option_info2);</a>
<a name="ln7639">  lua_setfield(lstate, -2, &quot;nvim_get_option_info2&quot;);</a>
<a name="ln7640">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_list_wins);</a>
<a name="ln7641">  lua_setfield(lstate, -2, &quot;nvim_tabpage_list_wins&quot;);</a>
<a name="ln7642">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_var);</a>
<a name="ln7643">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_var&quot;);</a>
<a name="ln7644">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_set_var);</a>
<a name="ln7645">  lua_setfield(lstate, -2, &quot;nvim_tabpage_set_var&quot;);</a>
<a name="ln7646">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_del_var);</a>
<a name="ln7647">  lua_setfield(lstate, -2, &quot;nvim_tabpage_del_var&quot;);</a>
<a name="ln7648">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_win);</a>
<a name="ln7649">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_win&quot;);</a>
<a name="ln7650">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_get_number);</a>
<a name="ln7651">  lua_setfield(lstate, -2, &quot;nvim_tabpage_get_number&quot;);</a>
<a name="ln7652">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_tabpage_is_valid);</a>
<a name="ln7653">  lua_setfield(lstate, -2, &quot;nvim_tabpage_is_valid&quot;);</a>
<a name="ln7654">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_id_by_name);</a>
<a name="ln7655">  lua_setfield(lstate, -2, &quot;nvim_get_hl_id_by_name&quot;);</a>
<a name="ln7656">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl);</a>
<a name="ln7657">  lua_setfield(lstate, -2, &quot;nvim_get_hl&quot;);</a>
<a name="ln7658">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl);</a>
<a name="ln7659">  lua_setfield(lstate, -2, &quot;nvim_set_hl&quot;);</a>
<a name="ln7660">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_hl_ns);</a>
<a name="ln7661">  lua_setfield(lstate, -2, &quot;nvim_get_hl_ns&quot;);</a>
<a name="ln7662">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl_ns);</a>
<a name="ln7663">  lua_setfield(lstate, -2, &quot;nvim_set_hl_ns&quot;);</a>
<a name="ln7664">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_hl_ns_fast);</a>
<a name="ln7665">  lua_setfield(lstate, -2, &quot;nvim_set_hl_ns_fast&quot;);</a>
<a name="ln7666">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_feedkeys);</a>
<a name="ln7667">  lua_setfield(lstate, -2, &quot;nvim_feedkeys&quot;);</a>
<a name="ln7668">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_input);</a>
<a name="ln7669">  lua_setfield(lstate, -2, &quot;nvim_input&quot;);</a>
<a name="ln7670">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_input_mouse);</a>
<a name="ln7671">  lua_setfield(lstate, -2, &quot;nvim_input_mouse&quot;);</a>
<a name="ln7672">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_replace_termcodes);</a>
<a name="ln7673">  lua_setfield(lstate, -2, &quot;nvim_replace_termcodes&quot;);</a>
<a name="ln7674">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_notify);</a>
<a name="ln7675">  lua_setfield(lstate, -2, &quot;nvim_notify&quot;);</a>
<a name="ln7676">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_strwidth);</a>
<a name="ln7677">  lua_setfield(lstate, -2, &quot;nvim_strwidth&quot;);</a>
<a name="ln7678">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_runtime_paths);</a>
<a name="ln7679">  lua_setfield(lstate, -2, &quot;nvim_list_runtime_paths&quot;);</a>
<a name="ln7680">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__runtime_inspect);</a>
<a name="ln7681">  lua_setfield(lstate, -2, &quot;nvim__runtime_inspect&quot;);</a>
<a name="ln7682">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_runtime_file);</a>
<a name="ln7683">  lua_setfield(lstate, -2, &quot;nvim_get_runtime_file&quot;);</a>
<a name="ln7684">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__get_lib_dir);</a>
<a name="ln7685">  lua_setfield(lstate, -2, &quot;nvim__get_lib_dir&quot;);</a>
<a name="ln7686">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__get_runtime);</a>
<a name="ln7687">  lua_setfield(lstate, -2, &quot;nvim__get_runtime&quot;);</a>
<a name="ln7688">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_dir);</a>
<a name="ln7689">  lua_setfield(lstate, -2, &quot;nvim_set_current_dir&quot;);</a>
<a name="ln7690">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_line);</a>
<a name="ln7691">  lua_setfield(lstate, -2, &quot;nvim_get_current_line&quot;);</a>
<a name="ln7692">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_line);</a>
<a name="ln7693">  lua_setfield(lstate, -2, &quot;nvim_set_current_line&quot;);</a>
<a name="ln7694">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_current_line);</a>
<a name="ln7695">  lua_setfield(lstate, -2, &quot;nvim_del_current_line&quot;);</a>
<a name="ln7696">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_var);</a>
<a name="ln7697">  lua_setfield(lstate, -2, &quot;nvim_get_var&quot;);</a>
<a name="ln7698">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_var);</a>
<a name="ln7699">  lua_setfield(lstate, -2, &quot;nvim_set_var&quot;);</a>
<a name="ln7700">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_var);</a>
<a name="ln7701">  lua_setfield(lstate, -2, &quot;nvim_del_var&quot;);</a>
<a name="ln7702">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_vvar);</a>
<a name="ln7703">  lua_setfield(lstate, -2, &quot;nvim_get_vvar&quot;);</a>
<a name="ln7704">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_vvar);</a>
<a name="ln7705">  lua_setfield(lstate, -2, &quot;nvim_set_vvar&quot;);</a>
<a name="ln7706">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_echo);</a>
<a name="ln7707">  lua_setfield(lstate, -2, &quot;nvim_echo&quot;);</a>
<a name="ln7708">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_out_write);</a>
<a name="ln7709">  lua_setfield(lstate, -2, &quot;nvim_out_write&quot;);</a>
<a name="ln7710">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_err_write);</a>
<a name="ln7711">  lua_setfield(lstate, -2, &quot;nvim_err_write&quot;);</a>
<a name="ln7712">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_err_writeln);</a>
<a name="ln7713">  lua_setfield(lstate, -2, &quot;nvim_err_writeln&quot;);</a>
<a name="ln7714">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_bufs);</a>
<a name="ln7715">  lua_setfield(lstate, -2, &quot;nvim_list_bufs&quot;);</a>
<a name="ln7716">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_buf);</a>
<a name="ln7717">  lua_setfield(lstate, -2, &quot;nvim_get_current_buf&quot;);</a>
<a name="ln7718">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_buf);</a>
<a name="ln7719">  lua_setfield(lstate, -2, &quot;nvim_set_current_buf&quot;);</a>
<a name="ln7720">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_wins);</a>
<a name="ln7721">  lua_setfield(lstate, -2, &quot;nvim_list_wins&quot;);</a>
<a name="ln7722">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_win);</a>
<a name="ln7723">  lua_setfield(lstate, -2, &quot;nvim_get_current_win&quot;);</a>
<a name="ln7724">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_win);</a>
<a name="ln7725">  lua_setfield(lstate, -2, &quot;nvim_set_current_win&quot;);</a>
<a name="ln7726">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_create_buf);</a>
<a name="ln7727">  lua_setfield(lstate, -2, &quot;nvim_create_buf&quot;);</a>
<a name="ln7728">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_open_term);</a>
<a name="ln7729">  lua_setfield(lstate, -2, &quot;nvim_open_term&quot;);</a>
<a name="ln7730">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_chan_send);</a>
<a name="ln7731">  lua_setfield(lstate, -2, &quot;nvim_chan_send&quot;);</a>
<a name="ln7732">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_tabpages);</a>
<a name="ln7733">  lua_setfield(lstate, -2, &quot;nvim_list_tabpages&quot;);</a>
<a name="ln7734">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_current_tabpage);</a>
<a name="ln7735">  lua_setfield(lstate, -2, &quot;nvim_get_current_tabpage&quot;);</a>
<a name="ln7736">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_current_tabpage);</a>
<a name="ln7737">  lua_setfield(lstate, -2, &quot;nvim_set_current_tabpage&quot;);</a>
<a name="ln7738">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_paste);</a>
<a name="ln7739">  lua_setfield(lstate, -2, &quot;nvim_paste&quot;);</a>
<a name="ln7740">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_put);</a>
<a name="ln7741">  lua_setfield(lstate, -2, &quot;nvim_put&quot;);</a>
<a name="ln7742">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_color_by_name);</a>
<a name="ln7743">  lua_setfield(lstate, -2, &quot;nvim_get_color_by_name&quot;);</a>
<a name="ln7744">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_color_map);</a>
<a name="ln7745">  lua_setfield(lstate, -2, &quot;nvim_get_color_map&quot;);</a>
<a name="ln7746">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_context);</a>
<a name="ln7747">  lua_setfield(lstate, -2, &quot;nvim_get_context&quot;);</a>
<a name="ln7748">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_load_context);</a>
<a name="ln7749">  lua_setfield(lstate, -2, &quot;nvim_load_context&quot;);</a>
<a name="ln7750">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_mode);</a>
<a name="ln7751">  lua_setfield(lstate, -2, &quot;nvim_get_mode&quot;);</a>
<a name="ln7752">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_keymap);</a>
<a name="ln7753">  lua_setfield(lstate, -2, &quot;nvim_get_keymap&quot;);</a>
<a name="ln7754">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_set_keymap);</a>
<a name="ln7755">  lua_setfield(lstate, -2, &quot;nvim_set_keymap&quot;);</a>
<a name="ln7756">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_keymap);</a>
<a name="ln7757">  lua_setfield(lstate, -2, &quot;nvim_del_keymap&quot;);</a>
<a name="ln7758">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_chan_info);</a>
<a name="ln7759">  lua_setfield(lstate, -2, &quot;nvim_get_chan_info&quot;);</a>
<a name="ln7760">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_chans);</a>
<a name="ln7761">  lua_setfield(lstate, -2, &quot;nvim_list_chans&quot;);</a>
<a name="ln7762">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id);</a>
<a name="ln7763">  lua_setfield(lstate, -2, &quot;nvim__id&quot;);</a>
<a name="ln7764">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_array);</a>
<a name="ln7765">  lua_setfield(lstate, -2, &quot;nvim__id_array&quot;);</a>
<a name="ln7766">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_dictionary);</a>
<a name="ln7767">  lua_setfield(lstate, -2, &quot;nvim__id_dictionary&quot;);</a>
<a name="ln7768">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__id_float);</a>
<a name="ln7769">  lua_setfield(lstate, -2, &quot;nvim__id_float&quot;);</a>
<a name="ln7770">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__stats);</a>
<a name="ln7771">  lua_setfield(lstate, -2, &quot;nvim__stats&quot;);</a>
<a name="ln7772">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_list_uis);</a>
<a name="ln7773">  lua_setfield(lstate, -2, &quot;nvim_list_uis&quot;);</a>
<a name="ln7774">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_proc_children);</a>
<a name="ln7775">  lua_setfield(lstate, -2, &quot;nvim_get_proc_children&quot;);</a>
<a name="ln7776">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_proc);</a>
<a name="ln7777">  lua_setfield(lstate, -2, &quot;nvim_get_proc&quot;);</a>
<a name="ln7778">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_select_popupmenu_item);</a>
<a name="ln7779">  lua_setfield(lstate, -2, &quot;nvim_select_popupmenu_item&quot;);</a>
<a name="ln7780">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__inspect_cell);</a>
<a name="ln7781">  lua_setfield(lstate, -2, &quot;nvim__inspect_cell&quot;);</a>
<a name="ln7782">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__screenshot);</a>
<a name="ln7783">  lua_setfield(lstate, -2, &quot;nvim__screenshot&quot;);</a>
<a name="ln7784">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__invalidate_glyph_cache);</a>
<a name="ln7785">  lua_setfield(lstate, -2, &quot;nvim__invalidate_glyph_cache&quot;);</a>
<a name="ln7786">  lua_pushcfunction(lstate, &amp;nlua_api_nvim__unpack);</a>
<a name="ln7787">  lua_setfield(lstate, -2, &quot;nvim__unpack&quot;);</a>
<a name="ln7788">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_del_mark);</a>
<a name="ln7789">  lua_setfield(lstate, -2, &quot;nvim_del_mark&quot;);</a>
<a name="ln7790">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_get_mark);</a>
<a name="ln7791">  lua_setfield(lstate, -2, &quot;nvim_get_mark&quot;);</a>
<a name="ln7792">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_eval_statusline);</a>
<a name="ln7793">  lua_setfield(lstate, -2, &quot;nvim_eval_statusline&quot;);</a>
<a name="ln7794">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_exec2);</a>
<a name="ln7795">  lua_setfield(lstate, -2, &quot;nvim_exec2&quot;);</a>
<a name="ln7796">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_command);</a>
<a name="ln7797">  lua_setfield(lstate, -2, &quot;nvim_command&quot;);</a>
<a name="ln7798">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_eval);</a>
<a name="ln7799">  lua_setfield(lstate, -2, &quot;nvim_eval&quot;);</a>
<a name="ln7800">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_call_function);</a>
<a name="ln7801">  lua_setfield(lstate, -2, &quot;nvim_call_function&quot;);</a>
<a name="ln7802">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_call_dict_function);</a>
<a name="ln7803">  lua_setfield(lstate, -2, &quot;nvim_call_dict_function&quot;);</a>
<a name="ln7804">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_parse_expression);</a>
<a name="ln7805">  lua_setfield(lstate, -2, &quot;nvim_parse_expression&quot;);</a>
<a name="ln7806">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_open_win);</a>
<a name="ln7807">  lua_setfield(lstate, -2, &quot;nvim_open_win&quot;);</a>
<a name="ln7808">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_config);</a>
<a name="ln7809">  lua_setfield(lstate, -2, &quot;nvim_win_set_config&quot;);</a>
<a name="ln7810">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_config);</a>
<a name="ln7811">  lua_setfield(lstate, -2, &quot;nvim_win_get_config&quot;);</a>
<a name="ln7812">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_buf);</a>
<a name="ln7813">  lua_setfield(lstate, -2, &quot;nvim_win_get_buf&quot;);</a>
<a name="ln7814">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_buf);</a>
<a name="ln7815">  lua_setfield(lstate, -2, &quot;nvim_win_set_buf&quot;);</a>
<a name="ln7816">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_cursor);</a>
<a name="ln7817">  lua_setfield(lstate, -2, &quot;nvim_win_get_cursor&quot;);</a>
<a name="ln7818">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_cursor);</a>
<a name="ln7819">  lua_setfield(lstate, -2, &quot;nvim_win_set_cursor&quot;);</a>
<a name="ln7820">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_height);</a>
<a name="ln7821">  lua_setfield(lstate, -2, &quot;nvim_win_get_height&quot;);</a>
<a name="ln7822">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_height);</a>
<a name="ln7823">  lua_setfield(lstate, -2, &quot;nvim_win_set_height&quot;);</a>
<a name="ln7824">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_width);</a>
<a name="ln7825">  lua_setfield(lstate, -2, &quot;nvim_win_get_width&quot;);</a>
<a name="ln7826">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_width);</a>
<a name="ln7827">  lua_setfield(lstate, -2, &quot;nvim_win_set_width&quot;);</a>
<a name="ln7828">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_var);</a>
<a name="ln7829">  lua_setfield(lstate, -2, &quot;nvim_win_get_var&quot;);</a>
<a name="ln7830">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_var);</a>
<a name="ln7831">  lua_setfield(lstate, -2, &quot;nvim_win_set_var&quot;);</a>
<a name="ln7832">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_del_var);</a>
<a name="ln7833">  lua_setfield(lstate, -2, &quot;nvim_win_del_var&quot;);</a>
<a name="ln7834">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_position);</a>
<a name="ln7835">  lua_setfield(lstate, -2, &quot;nvim_win_get_position&quot;);</a>
<a name="ln7836">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_tabpage);</a>
<a name="ln7837">  lua_setfield(lstate, -2, &quot;nvim_win_get_tabpage&quot;);</a>
<a name="ln7838">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_get_number);</a>
<a name="ln7839">  lua_setfield(lstate, -2, &quot;nvim_win_get_number&quot;);</a>
<a name="ln7840">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_is_valid);</a>
<a name="ln7841">  lua_setfield(lstate, -2, &quot;nvim_win_is_valid&quot;);</a>
<a name="ln7842">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_hide);</a>
<a name="ln7843">  lua_setfield(lstate, -2, &quot;nvim_win_hide&quot;);</a>
<a name="ln7844">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_close);</a>
<a name="ln7845">  lua_setfield(lstate, -2, &quot;nvim_win_close&quot;);</a>
<a name="ln7846">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_call);</a>
<a name="ln7847">  lua_setfield(lstate, -2, &quot;nvim_win_call&quot;);</a>
<a name="ln7848">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_set_hl_ns);</a>
<a name="ln7849">  lua_setfield(lstate, -2, &quot;nvim_win_set_hl_ns&quot;);</a>
<a name="ln7850">  lua_pushcfunction(lstate, &amp;nlua_api_nvim_win_text_height);</a>
<a name="ln7851">  lua_setfield(lstate, -2, &quot;nvim_win_text_height&quot;);</a>
<a name="ln7852">  lua_setfield(lstate, -2, &quot;api&quot;);</a>
<a name="ln7853">}</a>
</code></pre>
<div class="balloon" rel="2584"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="2591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="3153"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="3160"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4045"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4052"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4078"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4085"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4152"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4159"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4268"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4275"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4343"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4350"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4728"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4735"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4761"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4768"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4834"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4841"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4867"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="4874"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5074"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5081"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5107"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5114"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5330"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5337"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5437"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5444"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5642"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5649"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5827"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5834"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5860"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="5867"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="6105"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<div class="balloon" rel="6112"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'err_param' is always false.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>